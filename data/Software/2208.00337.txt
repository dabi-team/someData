Tai-e: A Static Analysis Framework for Java by
Harnessing the Best Designs of Classics

Tian Tan
State Key Laboratory for Novel Software Technology
Nanjing University
tiantan@nju.edu.cn

Yue Li
State Key Laboratory for Novel Software Technology
Nanjing University
yueli@nju.edu.cn

Abstract
Static analysis is a mature field with applications to bug
detection, security analysis, program understanding, opti-
mization, and more. To facilitate these applications, static
analysis frameworks play an essential role by providing a
series of fundamental services such as intermediate repre-
sentation (IR) abstraction, control flow graph construction,
points-to/alias information computation, and so on. How-
ever, despite impressive progress of static analysis, and this
field has seen several popular frameworks in the last decades,
it is still not clear how a static analysis framework should be
designed in a way that users (analysis developers) could ben-
efit more: for example, what a good IR (for analysis) ought to
look like? What functionalities should the module of funda-
mental analyses provide to ease or accelerate client analyses?
How to develop and integrate new analysis conveniently?
How to manage multiple analyses for a specific task?

To answer these questions, in this work, we discuss the
design trade-offs for the crucial components of a static anal-
ysis framework, and argue for the most appropriate design
by following the HBDC (Harnessing the Best Designs of Clas-
sics) principle: for each crucial component of a static anal-
ysis framework, we compare the design choices made for it
(possibly) by different classic frameworks such as Soot, WALA,
SpotBugs and Doop, and choose arguably the best one, but if
none is good enough, we then propose a better design. These
selected or newly proposed designs finally constitute Tai-e,
a new static analysis framework for Java, which has been
implemented from scratch. Specifically, Tai-e is novel in
the designs of several aspects like IR, pointer analysis and
development of new analyses, etc., leading to an easy-to-
learn, easy-to-use and efficient system. To our knowledge,
this is the first work that systematically explores the designs
and implementations of various static analysis frameworks,
and we believe it provides useful materials and viewpoints
for building better static analysis infrastructures, and we
expect it to draw more attentions of the community to this
challenging but tangible topic.

Keywords: static analysis, framework design, Java

1 Introduction
Static analysis is a well-studied technique that has been suc-
cessfully applied to many applications like bug detection [12,

1

56], security analysis [3, 49], code optimization [65, 69], pro-
gram understanding [46, 71] and verification [20, 58], and its
effect has translated into real benefit for a substantial number
of research work and industry products [15, 61]. To facili-
tate these applications (by implementing specific analysis
algorithms), static analysis frameworks play an essential role
by providing a series of fundamental services such as inter-
mediate representation (IR) abstraction, control flow graph
construction, points-to/alias information computation, and
more. However, despite impressive progress of static analy-
sis, and this field has seen several popular frameworks in the
last decades [10, 26, 68, 77, 78], we are still not clear about
what a good static analysis framework ought to look like, or
at least, whether the designs of existing classic frameworks
are good enough, and if not, can we have better ones?

This is a challenging problem, as system design is mostly a
trade-off among different goals such as simplicity, efficiency
and usability (one is often implemented at the expense of
another); in addition, design intents are sometimes very sub-
tle, which can hardly be aware of without the explanations
from designers. But this does not mean that we cannot have
some objective observations and reasonable judgments for
this subjective problem. Despite very few, there is past work
that attempt to offer some lessons learned for improving
(or adding) certain facilities for their analysis frameworks
after using it for a period of time [35, 63], but none addresses
the core of our problem — we still lack a systematic view
to examine the quality of a static analysis framework from
the perspective of developers who rely on the framework to
create new analysis; in other words, it is still unclear how
a static analysis framework should be designed such that
analysis developers can benefit more from it.

To deal with this problem, in this paper, we take one step
forward by discussing the design trade-offs for each of the
following crucial components that a static analysis frame-
work (for Java) is supposed to provide.

• Program Abstraction. It needs to provide an abstraction
model, including IR, type system, class hierarchy, etc.,
to represent all program elements that are ready for
various static analyses to obtain;

• Fundamental Analyses. It oughts to support fundamen-
tal facilities to allow analysis developers to operate on
analysis-friendly structures, e.g., control flow and call
graphs, enabling classic graph-based algorithms, and

to utilize abstracted memory information, e.g., points-
to/alias relations, to build sophisticated analyses;
• New Analysis Development. It is supposed to offer a
mechanism to develop and integrate any new analy-
sis, covering both fundamental ones like exception or
reflection analyses, and clients like bug detectors or
security analyzers;

• Multiple Analyses Management. It should provide a
standardized approach to managing multiple analyses
(e.g., configure the dependencies or cooperate the re-
sults of them) when they are required to work together
for accomplishing a specific analysis task.

In addition, for each of the above crucial components, we
argue for the most appropriate design by following the HBDC
(Harnessing the Best Designs of Classics) principle:

Given any component, we compare the design choices made
for it (possibly) by different classic frameworks such as Soot [77],
WALA [78], SpotBugs [68] and Doop [10], and choose arguably
the best one. But if none is good enough, we then propose a
better design. These selected or newly proposed designs to-
gether constitute Tai-e, a new static analysis framework
for Java, which has been implemented from scratch, and
built with great care; these efforts finally contribute to an
easy-to-learn, easy-to-use and efficient static analysis system.
Specifically, this work makes the following contributions.
1. We present the first work that systematically explores
the designs and implementations of various classic static
analysis frameworks for Java, and discuss their rationalities
for different crucial analysis components, providing useful
materials and viewpoints for building better static analysis
infrastructures.

2. We introduce Tai-e, a new static analysis framework
for Java, which is built from scratch, following the HBDC prin-
ciple for every crucial component mentioned above. In addi-
tion to the integration novelty stemming from HBDC, Tai-e
has its specific novel designs. For examples,

• Tai-e presents a usage-friendly IR for analysis imple-
mentation: compared to the IRs of Soot and WALA, it
enables to produce more succinct code for implement-
ing static analysis algorithms, and makes it easier to
understand its underlying intents.

• Tai-e offers a more effective pointer analysis system
by presenting some new designs (e.g., virtual-memory-
like sparse bit sets to store points-to results) that can
yield faster and more sound pointer analyses than all
state of the arts for virtually all evaluated cases, in both
context-insensitive and context-sensitive settings.
• Tai-e introduces a novel analysis plugin system to
develop and integrate new analysis. A dozen analyses
of Tai-e was developed on top of it, and it is currently
being used by a number of ongoing internal projects;
every developer agrees that this system can fulfill their
practical needs and is simple to understand and apply.

2

Tian Tan and Yue Li

Besides, despite not that novel, Tai-e is built with many
engineering improvements. For example, in multiple-analyses
management, Tai-e offers a scheme to more flexibly specify
and resolve the dependencies among different analyses, and
it enforces the analysis results to be stored distributively, en-
abling analysis developers to retrieve results consistently and
conveniently. Such improvements can be found in every com-
ponent of Tai-e. These engineering efforts, together with
its designs (selected and newly proposed), making Tai-e
easy-to-learn and easy-to-use.

3. We release Tai-e as an open-source framework for
providing a uniform research platform to develop new fun-
damental analyses and clients with low cost of learning and
implementation (https://github.com/pascal-lab/Tai-e). In ad-
dition, we develop an educational version of Tai-e (http:
//tai-e.pascal-lab.net/en/intro/overview.html) where eight
assignments are carefully designed for systematically train-
ing students to implement various static analysis techniques
to analyze real Java programs; this educational version was
released three months ago (April 2022), and now it has at-
tracted lecturers from 18 universities (for teaching purpose),
team leaders from 10 companies (for training their engineers),
and students from 85 universities and research institutes (for
doing Tai-e assignments on our online judgment platform).
We will actively and constantly contribute to Tai-e by
adding state-of-the-art analyses from existing work and de-
veloping new ones, including but not limited to incremental
analysis [47, 48, 51], accumulation analysis [34], program
slicing [24, 76], escape analysis [7, 14], new clients like bug
detectors for data races [6, 48, 56], security analyzers for
specific vulnerabilities [59, 63] (we now support taint analy-
sis [21]), program understanding tools [46, 71], and more.

No doubt there is still a lot to explore, and years of research
will be required to understand the right design choices and
establish best practices for building an all-round and high-
quality static analysis framework. Still, we believe that this
work, together with Tai-e, have taken a big step on the way
toward achieving this goal.

In the rest of the paper, we show how classic frameworks
(if related) and Tai-e deal with the design points for each of
the crucial components mentioned previously (Sections 2–5),
discuss whether Tai-e, also as a system software, is reason-
ably designed in accordance with the classic STEADY princi-
ple [36, 37] from a view of system design (Section 6), discuss
the related work and conclude the paper (Sections 7–8).

2 Program Abstraction
A static analysis framework needs to provide an abstraction
model of programs, including IR, type system, class hierarchy,
etc., to represent all program elements for static analysis to
conveniently obtain. Below, we elaborate on some key design
choices made by Tai-e and other related frameworks for
this model and explain why we arrive at making them.

Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

2.1 IR
We consider two classic frameworks, Soot and WALA, that
have their specific IRs for analysis. Soot is virtually the most
popular static analysis framework for Java over 20 years, and
WALA also has attracted many researchers to build analyses
during the last decade. The IR of Tai-e is largely inspired
by these two frameworks with notable improvements for
helping analysis developers implement more concise analysis
code and better understand the underlying intents of IR.
Below we take a representative example to illustrate the
design choices made by these frameworks.

Soot represents all statements that have “=” operator in-
side as AssignStmt and does not explicitly distinguish the
concrete cases of assign statements, e.g., new, load, store,
unary, binary statements, etc. (but WALA and Tai-e do). Al-
though utilizing fewer statement types makes IR simpler,
it may also introduce many unnecessary conditional type
checks. As an example, Figure 1 depicts how a binary state-
ment (e.g., 𝑥 = 𝑦 + 𝑧), as a parameter of processBinary,
is processed in different frameworks. The declared type of
the assign parameter (line 2) has to be AssignStmt as it is
the lowest-level interface in the class hierarchy of Soot to
represent a binary statement; accordingly, conditional check
to the right operand of assign is required (line 5) to ensure
the casting (line 6) to be safe.

In addition, as Soot always returns Value (the highest-
level interface in the class hierarchy) to represent data, e.g.,
local, constant, expression, reference, etc., further casting is
needed to determine the right type of data. Line 8 explains
one such case: the type of the left operand of a binary state-
ment is a local variable (this is a pre-knowledge of Soot,
but if users do not know it, a conditional type check is also
required here), but as Soot declares Value as the returned
type of getLeftOp(), casting to Local is needed due to
type constraint. As another example (not shown in code),
Soot provides <Value getCondition()> of class IfStmt to
obtain the conditional expression of an if statement; that
means Soot still returns Value even if it knows that the con-
dition of an if statement must be a type of ConditionExpr
(can be validated via its code), which is a subtype of Value,
resulting in another case of unnecessary casting. The above
cases imply that distinction in IR may appear subtle, but its
effect is often profound.

WALA does not have this problem and it adopts a different
strategy to represent local variables. For instance, getUse()
in line 30 returns an int value (op2) as the index to access
the information of the corresponding operand: to obtain the
constant value stored in this operand, op2 is used as index to
lookup a symbol table (line 39) which can be retrieved from
ir (line 37); in other words, unlike Soot (line 10) and Tai-e
(line 47) that directly holds the operand values, WALA adopts
the above int index strategy to obtain the related values,
which is not straightforward to understand and debug.

}

}

Constant val2 = (Constant) op2;

Local var1 = (Local) op1;
String name1 = var1.getName();

}
// obtain type of op1
Type type1 = op1.getType();
// obtain constant value of op2
if (op2 instanceof Constant) {

BinopExpr binopExpr = (BinopExpr) rightOp;
// "Top" returned type needs casting
Local lhs = (Local) assign.getLeftOp();
Value op1 = binopExpr.getOp1();
Value op2 = binopExpr.getOp2();
// obtain name of op1
if (op1 instanceof Local) {

1 // Soot
2 void processBinary(AssignStmt assign) {
Value rightOp = assign.getRightOp();
3
// "Abstract" statement introduces conditional checks
4
5
if (rightOp instanceof BinopExpr) {
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23 }
24 // WALA
25 void processBinary(SSABinaryOpInstruction binary, IR ir) {
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41 }
42 // Tai-e
43 void processBinary(Binary binary) {
44
45
46
47
48
49
50
51
52
53
54
55
56 }

int lhs = binary.getDef();
// getUse() returns an int value as index to access the
// info of the corresponding operand: lines 32, 37-39
int op1 = binary.getUse(0);
int op2 = binary.getUse(1);
// obtain name of op1
String[] name1 = ir.getLocalNames(binary.iIndex(), op1);
// obtain type of op1
TypeInference tinfer = TypeInference.make(ir, true);
TypeAbstraction type1 = ti.getType(op1);
// obtain constant value of op2
SymbolTable symbolTable = ir.getSymbolTable();
if (symbolTable.isConstant(op2)) {

Var lhs = binary.getLValue();
BinaryExp binaryExp = binary.getRValue();
Var op1 = binaryExp.getOperand1();
Var op2 = binaryExp.getOperand2();
// obtain name of op1
String name1 = op1.getName();
// obtain type of op1
Type type1 = op1.getType();
// obtain constant value of op2
if (op2.isConst()) {

Object val2 = symbolTable.getConstantValue(op2);

Literal val2 = op2.getConstValue();

}

}

Figure 1. An example for illustrating how to process binary
statement in Soot, WALA and Tai-e based on different IRs.

3

Moreover, possibly due to the above design, different from
Soot (lines 11–17) and Tai-e (lines 48–51) which uniformly
obtains information from operands directly, WALA needs to
utilize other interfaces to obtain the name and type of an
operand, through ir (line 32) and TypeInference (lines 34–
35) respectively, increasing learning costs.

Tai-e avoids the above issues of Soot and WALA as re-
flected in lines 43–56. Now we invite readers to view the
code of Figure 1 in its entirety to experience how the same
binary statement is handled differently based on different IRs.
Given the binary statement example in Figure 1, and the fact
that a program is often made of many different statements
and expressions, we could anticipate considerable benefits
afforded by Tai-e’s IR for writing more concise and under-
standable analysis code. Additionally, Tai-e introduces a
few new IR designs to make it more accessible for certain
analyses. For example, to facilitate pointer analysis, Tai-e
associates each variable v with its related statements in its IR,
and once v’s value is changed during analysis, developers can
directly and conveniently retrieve all the related statements
of v via IR to take further actions.

We can hardly say that Tai-e offers a better IR than others
as Soot and WALA may have different intents in their designs,
which is difficult to be aware of without the explanations
from designers. Still, we believe the IR of Tai-e reflects well
its easy-to-learn/use nature and has clear advantages over
others in that sense.

2.2 Type System and Class Hierarchy
A static analysis framework should provide a type system to
represent types, and offer facilities for operating on types,
e.g., for obtaining specific types and performing subtype
checking. Soot explicitly distinguishes types like primitive,
reference, array, null and void types, while WALA uses
a uniform interface called TypeReference to represent all
types. Tai-e is akin to Soot in designing type system as
concrete type representation often eases API understand-
ing and usage. For example, when we want to handle an
array type which is passed as the parameter of a method, we
can declare its (parameter) type as ArrayType (rather than
TypeReference), then we know that this method can only
accept array type and no further type checking is needed.
A static analysis framework should offer functionalities
for managing classes, class members and their resolutions
related to class hierarchy, e.g., obtaining a class by its name,
returning subclasses of a given class, resolving fields based on
field references and resolving methods according to method
dispatch. Unlike Soot which places these functionalities in
different classes like Scene and FastHierarchy (a bit dis-
tracting when learning the framework), Tai-e prefers WALA’s
design which accesses all class related information through
a single entry named IClassHierarchy (easier to find and
maintain relevant APIs). Compared to WALA, Tai-e offers
more facilities like getting class members by their signatures.

4

Tian Tan and Yue Li

In a nutshell, Tai-e has no novelty for type system and
class hierarchy, but it follows the HBDC principle to choose
more appropriate designs and implement them uniformly.

3 Fundamental Analyses
Broadly, static analysis approximates how abstracted data
flows along the control structure of a program according to
the language semantics and runtime environment. Accord-
ingly, a static analysis framework should offer fundamental
facilities to produce such control structures like control flow
graphs and call graphs (which are analysis-friendly struc-
tures that enable classic graph-based analysis algorithms)
to develop various data flow analyses; besides, we need a
pointer analysis to compute abstractions of the possible val-
ues/relations of pointer variables (points-to/alias informa-
tion) in a program that are required by many other fundamen-
tal analyses and clients [65, 70]. In this section, we introduce
what design choices are made by different frameworks for
these two fundamental facilities: pointer analysis and con-
trol/data flow analysis, and explain how Tai-e is inspired by
and differs from classic frameworks in designing them.

3.1 Pointer Analysis
“Pointer analysis is one of the most fundamental static pro-
gram analyses, on which virtually all others are built.” [40].
Soot offers a pioneer (context-insensitive) pointer analy-
sis system for Java called Spark that is highly optimized
and runs very fast [39], and WALA also implements a pointer
analysis system with context-sensitivity enhancement [70].
Doop [10] is another classic pointer analysis framework that
is full of clever and useful designs. Unlike Soot, WALA and
Tai-e which are imperative (implemented in Java), Doop is
fully declarative and implemented in Datalog, and it is consid-
ered as the mainstream platform to implement and compare
different newly proposed pointer analysis algorithms for
Java in the last decade [13, 27–30, 33, 41–43, 66, 67, 73–75].
All of these frameworks implement the same Andersen-style
algorithm [1] as the core of pointer analysis; however, differ-
ent choices are made by them for the following key points
that need to be considered when designing a pointer analysis
system for Java:

• a representation of points-to information
• a solver for propagating points-to information
• a heap manager for modeling heap objects
• a context manager for handling context sensitivity1
Besides, a practical pointer analysis system should offer a
mechanism to conveniently develop new analyses (e.g., re-
flection analysis, exception analysis, taint analysis, etc.) that
need to interact with pointer analysis. We next discuss how
Tai-e and others deal with the above design points. For each
point, only its major part is discussed due to limited space.

1Unlike pointer analysis for C/C++, context sensitivity is much more prac-
tically useful than flow sensitivity in improving precision for Java [65]

Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

Solver. Pointer analysis relies on its solver to propagate
points-to information, and this process is usually based on a
graph structure. For Spark, it is called pointer assignment
graph (PAG) and its edges basically show how pointers are
syntactically assigned to others. PAG is straightforward to
understand (its nodes directly correspond to the code ele-
ments) and it is used in many analysis work [48, 51]. How-
ever, Tai-e adopts another structure called pointer flow
graph (PFG) that is very similar to the flow graph in WALA;
actually, the Datalog rules of Doop can also constitute such
a graph although it does not encode it explicitly.

Unlike PAG, every node in PFG is a real pointer that points
to objects. As shown in the example below, suppose variables

a and b point to objects o1 and o2 (not shown) respectively.
By the store operation a.f = b, o2 is propagated to o1.f, and
the real pointer that points to o2 is o1.f, rather than the field
reference a.f. Thus in PFG, we add the edge (from node b
to node o1.f) that reflects the real points-to relation (means
what are pointed to by pointer b will flow to pointer o1.f).
This design enables to directly retrieve the reachability
information from PFG even in the presence of aliasing. In the
above example, o2 will flow to x, if a and y are aliases (they
point to the same object o1), and this reachable flow can be
expressed via the path in PFG (but cannot in PAG). PFG can
avoid the reiteration of the worklist algorithm that occurs in
Spark (based on PAG) when handling field stores and loads,
and it also eases to develop sophisticated pointer analysis
algorithms that need direct object flow information [41, 43]

Heap Manager. Typically, a huge number of heap objects
will be allocated when executing a Java program, and as the
protagonists of pointer analysis, how to model heap is an
important issue that needs to be addressed. Regarding heap
modeling, Tai-e is largely inspired by Doop and divide heap
objects into four categories.

• New object. It includes all the objects that are allocated
explicitly via keyword new (e.g., new T, new T[]).
• Constant object. It represents the constant objects whose
fields will not be modified, (e.g., String, T.class, etc.).
We can omit contexts for these objects in context sen-
sitivity (no need to distinguish them via contexts as
their field values remain the same through execution).
• Merged object. It covers the objects that could be merged
(i.e., the new and constant objects with the same type)
and Tai-e provides facilities to abstract them and ac-
cess their origins, which eases the development of
various heap abstraction techniques for pointer analy-
sis [13, 19, 29, 75].

5

Figure 2. An example for illustrating regular (212 = 4096) and
(one-level) “virtual memory”-like sparse bit sets in Tai-e.

Representation of Points-to Information. Pointer anal-
ysis requires a uniform data structure to effectively represent
points-to set that is associated with each variable in a pro-
gram. Both Spark and WALA adopt a hybrid points-to set:
when the size of set is less than certain value, they use array
to store the pointed-to objects; otherwise, a regular bit set is
considered to represent the points-to set. Tai-e follows this
hybrid approach, but the bit set is designed differently.

Assume a regular bit set uses 212 = 4096 bits to represent
4096 pointed-to objects stored in the points-to set of any
variable that points to them. Figure 2 depicts a case that
variable v has a points-to set {𝑂20, 𝑂100, 𝑂3990, 𝑂3993}, and
the four objects inside are presented by 1 (highlighted in red
color) and the other bits remain 0 in the 4096-bits set. It is not
hard to see that many bits are wasted when there are only a
few pointed-to objects. To address this issue, Tai-e adopts
a scheme called “virtual memory”-like sparse bit set [11] to
represent points-to sets, as shown in Figure 2. In this case,
16 integers (each occupies 32-bits) are used as pointers for
referring to maximally sixteen 256-bits sets (also 4096 bits in
total). Since there are only four objects to represent in this
case, two 256-bits sets are enough to store them, totaling
1024 = 2 × 256 + 16 × 32 (space for storing pointers) bits
instead of the 4096 bits required by regular bit set.

In practice, to save more space, instead of the one-level
page table used in the above example, Tai-e adopts two-level
page table (like the concept in virtual memory) for referring
to objects, and the table size is dynamically determined ac-
cording to the number of pointed-to objects. Compared to
regular bit set (used in Soot and WALA), the “virtual memory”-
like sparse bit set in Tai-e helps save on average 23% (up
to 40%) memory for context-sensitive pointer analysis in
the experiment (introduced later). When we constrain the
memory size to a limited one (like 8G for a laptop), this ap-
proach helps Tai-e scale for three more benchmarks under
context-sensitive settings. Actually, the idea of sparse bit
set is not new and it is used in some pointer analysis work
for C/C++ but with different “sparse” strategies such as [4].
More attempts for designing new bit sets are encouraged for
Java. Note that as Doop is declarative, its points-to set rep-
resentation is not accessible to users, and different Datalog
engines may use different representations [2, 10].

0115…0255201003840409539903993……pts(v) = {o20, o100, o3990, o3993} 0409520100…39903993vm-bitset = 256     21632= 1024 bitsbitset = 4096 bits     +a.f = bx = y.fpts(a) = pts(y) = {o1}…o1.fbxa.fby.fxPFGPAG• Mocked object. It indicates the objects with no alloca-
tion sites in Java code. For instances, the metaobjects
of reflection (e.g., Method/Field objects allocated in
native code), the special objects created by JVM (e.g.,
main thread and parameters), taint values (used by
taint analysis), and abstracted objects for modeling
framework behaviors. Distinguishing mocked objects
from others eases heap management, e.g., we can eas-
ily apply distinct heap contexts to mocked objects, and
design specific tracing or logging strategies for them.

Both Spark and WALA consider the first two categories, and
they additionally support merged objects but with limited
capabilities: the merged objects are needed to be specified
within a single method (WALA) or the entire program other-
wise (Spark and WALA), and no other granularities are sup-
ported. As for Doop, Tai-e is mostly like it with some differ-
ences. For example, Tai-e regards all environment-related
objects as mocked ones (including the objects of file system,
main thread, system thread group, etc.) but Doop does not.
These objects should be treated uniformly for consistency.

Context Manager. Context sensitivity is the most widely
used approach to improving precision of Java pointer anal-
ysis [65, 70], and we need a strategy to manage various
context-sensitivity variants (call-site sensitivity [64], object
sensitivity [54] and type sensitivity [66]) with different con-
text lengths, for both method calls and heap objects.

Soot does not have an effective context-sensitive pointer
analysis system: Spark is context-insensitive; Paddle is a
BDD-based context-sensitive pointer analysis [38] of Soot
and it has been shown to be noticeably less efficient than
Doop [10] and hasn’t been maintained for years. Doop pro-
vides a set of elegant rules to deal with context sensitivity.
However, due to the limitation of Datalog, for each context
length for the combination of method calls and heap ob-
jects, developers have to write a separate implementation for
context-sensitive analysis, resulting in redundant code. In
contrast, Tai-e is imperative and it can easily treat context
length as an input parameter to the same implementation
of context-sensitive analysis. WALA only provides context
management for method calls, and its heap contexts directly
inherit from the ones selected for the method that includes
the allocation site of the heap object. Compared to WALA,
Tai-e offers more flexible context management: developers
can specify the contexts for both method calls and heap ob-
jects, e.g., 3-call-site (or 2-object) sensitivity for method calls
and 1-call-site (or 1-object) sensitivity for heap objects.

Tai-e also provides facilities to develop selective context
sensitivity (currently a hot research topic of Java pointer
analysis) that scales for large and complex Java programs
with good precision. Now many state-of-the-art selective
pointer analyses like Zipper [41], Zipper𝑒 [43], Scaler [42]
and Mahjong [75] have been implemented in Tai-e, serving

6

Tian Tan and Yue Li

as a uniform pointer analysis framework to compare and
develop new context-sensitivity approaches.

Experimental Evaluation. So far, we have explained
how Tai-e makes choices for the key points for designing
pointer analysis following the HBDC principle, to ease the
development of sophisticated pointer analysis algorithms.
Now we show how Tai-e performs in practice compared to
the state-of-the-art pointer analysis frameworks.

State of the arts. We consider two state of the arts, Doop
and Qilin [22] (the latest versions of both) which are rep-
resentatives of declarative and imperative pointer analysis
frameworks. Specifically, Qilin is a recently released tool
developed on top of Soot, and some designs of it are similar
to Spark (e.g., the same representation of points-to informa-
tion and similar data structures used for solvers) but with
enhancement of context sensitivity. As Spark does not sup-
port context sensitivity, it is not included in Table 1, but we
will later summarize its results when explaining the data
for context-insensitive pointer analysis. Unlike Tai-e, Doop,
Qilin and Spark, WALA does not accept the output of dy-
namic reflection analysis as its input (explained in next para-
graph), and it runs noticeably slower than others under con-
text sensitivity. Therefore, it is excluded in our experiment.
Benchmarks and Settings. We consider standard Java Da-
Capo benchmarks [5] plus several large real-world applica-
tions that are often used in recent literature [29, 43, 50, 73].
We conduct all experiments on a machine with an Intel Xeon
2.2GHz CPU and 128GB of memory. All benchmarks are an-
alyzed with a large Java library JDK 1.6 that is widely used
in recent related work [22, 27–29, 31, 42, 43, 50]. All frame-
works adopt the same reflection results for the same program
by running the dynamic reflection analysis tool TamiFlex [8].
Time budget is set to three hours for each analysis.

Evaluation metrics. Pointer analysis algorithms are typi-
cally evaluated in the same framework to ensure the same
soundness, so that efficiency and precision can be compared.
To compare the effectiveness of pointer analyses provided
in different frameworks, soundness and efficiency are the
two most important metrics to evaluate whether program
behaviors are well over-approximated and whether the anal-
ysis cost is reasonable, respectively. To evaluate soundness
(or in some research fields, it is more understandable to say
that whether an analysis is more complete than another),
we conduct recall experiments to record the amounts of real
reachable methods and call graph edges (The two “Total”
columns in Table 1) that are dynamically collected when
running the benchmarks.

Results. Table 1 shows the detailed results. Generally, Tai-e
achieves higher recall (better soundness) than Qilin, Doop
and Spark in both clients (amounts of reachable methods
and call graph edges) for all programs. Specially, for these

Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

Table 1. Pointer analysis results in terms of recall and analysis time. “Total”, “Recall” and “R/T ” mean the real results collected
by running dynamic analysis, the real results resolved by a pointer analysis, and Recall/Total (recall rate), respectively. “#varpt”,
“#reach” and “#edges” mean the total number of points-to relations for all variables, reachable methods and call graph edges
respectively. “2-obj” and “2-call” represent two widely adopted context-sensitive pointer analysis algorithms (2 levels of object
sensitivity and call-site sensitivity). “–” means the analysis cannot finish running within time budget or run out of memory.

Reachable Methods

Call Graph Edges

Context Insensitivity

2-obj

2-call

Program Tool

Recall Total

R/T

Recall Total

findbugs

soot

gruntspud

columba

antlr

bloat

.

xalan

eclipse

hsqldb

jython

luindex

lusearch

pmd

chart

Tai-e 5,808
Qilin 5,663
4,835
Doop
Tai-e 4,288
Qilin 4,225
4,253
Doop
Tai-e 14,360
Qilin 14,279
9,508
Doop
Tai-e 6,673
Qilin 6,617
4,983
Doop
Tai-e 2,697
Qilin 2,568
2,510
Doop
Tai-e 3,339
Qilin 3,292
3,231
Doop
Tai-e 3,826
Qilin 3,650
3,132
Doop
Tai-e 7,080
Qilin 6,936
3,378
Doop
Tai-e 2,608
Qilin 1,707
1,626
Doop
Tai-e 4,243
Qilin 4,056
3,985
Doop
Tai-e 2,179
Qilin 2,052
1,973
Doop
Tai-e 1,736
Qilin 1,606
1,545
Doop
Tai-e 3,908
Qilin 3,735
2,718
Doop
Tai-e 5,197
Qilin 5,024
4,691
Doop

5,857

4,372

14,543

6,757

2,786

3,421

3,966

8,093

2,733

4,835

2,266

1,826

4,025

5,326

99.16% 13,899
96.69% 13,323
82.55% 11,121
98.08% 16,233
96.64% 16,120
97.28% 16,156
98.74% 41,426
98.18% 41,261
65.38% 25,363
98.76% 14,368
97.93% 14,260
73.75% 9,798
96.81% 10,086
92.18% 9,531
90.09% 9,401
97.60% 11,794
96.23% 11,722
94.45% 11,297
96.47% 9,254
92.03% 8,571
78.97% 6,999
87.48% 18,050
85.70% 17,476
41.74% 6,860
95.43% 5,856
62.46% 2,996
59.50% 2,841
87.76% 11,639
83.89% 10,847
82.42% 10,717
96.16% 4,461
90.56% 3,907
87.07% 3,376
95.07% 3,261
87.95% 2,705
84.61% 2,534
97.09% 9,287
92.80% 8,613
67.53% 5,737
97.58% 12,751
94.33% 12,064
88.08% 11,172

14,075

16,452

42,099

14,689

10,341

12,029

9,614

20,916

6,295

35,970

4,710

3,511

9,635

13,110

R/T
98.75%
94.66%
79.01%
98.67%
97.98%
98.20%
98.40%
98.01%
60.25%
97.81%
97.08%
66.70%
97.53%
92.17%
90.91%
98.05%
97.45%
93.91%
96.26%
89.15%
72.80%
86.30%
83.55%
32.80%
93.03%
47.59%
45.13%
32.36%
30.16%
29.79%
94.71%
82.95%
71.68%
92.88%
77.04%
72.17%
96.39%
89.39%
59.54%
97.26%
92.02%
85.22%

Time (s)
15.2
23.5
46.0
107.7
173.9
454.0
69.0
113.9
159.0
135.8
170.0
616.0
9.0
11.5
31.0
11.7
13.1
26.0
9.8
16.5
28.0
26.8
48.1
21.0
11.7
8.8
78.0
17.0
25.7
78.0
8.8
9.1
14.0
9.2
9.5
15.0
10.1
15.8
29.0
17.4
21.8
42.0

#reach #edges Time (s) Time (s)
#varpt
2114.5
17,353 107,339
7,355,719
4214.6
16,988 106,998
7,360,275
5292.0
13,660
83,699
5,239,275
32,918 415,728
84,628,666
−
32,780 420,243
82,179,258
−
32,600 413,411
74,564,948
−
39,800 274,872
48,179,683
−
39,247 273,794
50,073,466
−
22,309,125
25,077 154,763
−
107,856,623 56,787 425,149
−
101,298,328 56,726 416,791
−
42,665 286,990
70,315,191
−
654.0
59,190
8,674
2,003,409
2009.9
58,486
8,363
2,066,405
1646.0
57,560
8,250
2,385,993
1107.0
69,219
9,936
3,270,010
2691.2
68,922
9,631
3,363,502
67,604
9,509
3,393,681
−
1221.5
72,661
12,942
2,805,148
2546.6
70,612
12,526
2,697,455
1359.4
9,956
1,681,360
53,278
23,920 184,294
22,633,879
−
23,550 184,290
24,230,566
−
56,595
9,764
2,044,456
−
654.6
64,393
11,588
1,838,669
968.3
42,896
7,570
1,016,624
2477.4
6,945
839,150
37,414
13,076 121,603
10,885,453
−
12,650 119,872
10,101,462
−
12,507 118,706
11,267,651
−
515.8
41,520
7,899
829,314
1226.4
40,828
7,590
889,969
469.2
39,743
7,456
921,998
509.8
44,839
8,574
981,532
1234.2
44,166
8,263
1,048,650
1435.8
43,072
8,136
1,099,851
1174.2
73,890
13,311
2,848,296
2136.0
73,292
12,981
2,974,963
1605.9
46,862
8,905
1,330,917
856.7
87,938
16,455
5,755,512
2281.8
87,848
16,109
6,103,008
3506.0
73,106
13,643
4,679,309

1419.1
2033.0
638.0
−
−
−
−
−
−
−
−
−
37.1
71.0
282.0
452.3
1253.8
1394.0
1854.0
869.3
439.0
−
−
−
−
−
−
−
−
−
18.4
30.4
46.0
18.9
47.7
49.0
39.1
75.0
68.0
184.9
283.6
216.0

two clients, Tai-e’s recall rates are 95.87% and 91.31% re-
spectively on average, while Qilin’s are 90.54% and 83.51%,
Doop’s are 78.10% and 68.44%, and Spark’s are 81.32% and
73.20% (not shown in the table). We found that Doop is not
taking full advantage of the reflection information offered

by Tamiflex (e.g., omits classes mentioned in reflection logs
from the initial facts upon which the analysis logic runs).
Therefore, its recall results are not good for these cases.

Many reasons could possibly contribute to the good re-
call of Tai-e, and it is very hard to accurately find them

7

out. One explanation is that Tai-e may have better static
treatment to language features such as reflection resolution
(we have found such cases), native code modeling, etc., and
perhaps the implementation of analysis algorithms in Tai-e
is more robust and thus more dynamic behaviors are well
over-approximated.

Meanwhile, Tai-e has the fastest analysis speed com-
pared to other frameworks for virtually all cases under both
context-insensitive and context-sensitive settings, as reflected
in the three “Time(s)” columns in Table 1. For context sensi-
tivity, we consider two widely used algorithms: object sen-
sitivity and call-site sensitivity, both of which have context
lengths of two [43, 65, 67, 74, 75], denoted as 2-obj and 2-call,
respectively. Note that for 2-call, the latest version of Doop
either runs out of memory (and killed by operating system)
or exceeds time limit for all programs, we instead list the
results of running an old version of Doop for 2-call in Table 1.
Now let us examine the analysis time. Note that we can-
not easily draw a conclusion that one framework has bet-
ter efficiency ability than others if it spends less time, as
the soundnesses achieved by different frameworks vary (an
analysis is faster perhaps because it analyzes less code than
others). But we can trust the capability of Tai-e for yielding
highly efficient pointer analysis (benefiting from its designs
for efficiency like representation of points-to information
and solver), because it achieves better recall (more sound)
for all programs than all other frameworks; moreover, in
many cases, even if Tai-e analyzes more reachable methods
(#reach) and computes more points-to relations (#varpt) or
call graph edges (#edges), it still runs faster than others (this
also includes the case of Spark: Tai-e outperforms Spark
in analysis speed for 12/14 programs even if Tai-e has sig-
nificantly better recall than Spark), demonstrating again the
good efficiency of Tai-e.

3.2 Control/Data Flow Analysis
The algorithms for building control and data flow analy-
ses (e.g., control flow graph construction and various data
flow analyses like constant propagation, live variables anal-
ysis, etc.) are standard and well understood in the field of
compilers. However, as the providers that support fundamen-
tal facilities to build these analyses, static analysis frame-
works may adopt different strategies in design details. We
next introduce how Tai-e, Soot, WALA and SpotBugs make
choices for certain key design points to ease the develop-
ment of effective control and data flow analyses (SpotBugs
is a famous static bug detection framework (the successor of
FindBugs [25]) that has a powerful system of control/data
flow analysis [68]).

Control Flow Analysis. Building control flow graph (CFG)
is the major task of control flow analysis, and despite its basic
algorithm is standard, its effectiveness for facilitating users
to build analysis varies. We use two examples to explain.

8

Tian Tan and Yue Li

Edge categories. Unlike Tai-e and SpotBugs, Soot and
WALA do not category edges of CFG, such as IF_TRUE, IF_FALSE
and CAUGHT_EXCEPTION, etc. These well-categorized edge
information will ease to develop certain analyses like path-
sensitive and branch-correlated analysis, or perform exception-
specific handling. Compared to SpotBugs, Tai-e provides
additionally useful edge information, e.g., it labels the switch
edges with case values, and the exception edges with con-
crete exception types. Note that developers can also parse
out the edge information in Soot and WALA by resolving the
related nodes and IR in their analyses, but doing so would
be inconvenient and not easy to use.

Exception handling. Regarding CFG for Java, an essential
factor that affects its effectiveness is how to statically re-
solve Java exception, and it is considered as the most critical
source of unsoundness in program analysis that developers
indicated should not be overlooked [15]. There are explicit
and implicit exceptions: the former is thrown by throw state-
ment and is caught by the corresponding catch statement if
their types are matched, and the latter is thrown implicitly by
JVM (like out of memory errors, and arithmetic exceptions).
A sound CFG should consider both of them, but in many
cases, there is possibly a huge number of implicit exceptional
control flows in a program and they do not interact much
with the normal flows (explicit exceptional control flows do
as logics are often implemented in their catch body), and
thus consider them in CFG may reduce analysis precision
(and usability). Unlike WALA and SpotBugs, Tai-e and Soot
distinguish explicit and implicit exceptional control flows
and allow users to decide which ones should be added to a
CFG. Moreover, Tai-e implements state-of-the-art exception
analysis [9, 32] that resolves exception significantly more
precise (sometimes also more sound) than Soot, WALA and
SpotBugs, and offers it as an option for constructing CFG.

Data Flow Analysis. Typically, to implement customized
analysis, developers should follow the interfaces provided by
a data flow analysis system to specify (1) data facts abstrac-
tion and initialization, (2) the transfer function for approxi-
mating different statements, and (3) the meet/join operation
for merging data facts at control flow confluences, while mak-
ing their analyses monotonic and safe-approximated. Below,
we take three examples to illustrate how different designs
may lead to different perceptions of use for developers.

Data facts initialization. Unlike Tai-e, SpotBugs and Soot,
WALA does not allow to initialize data facts in the analysis;
instead, it puts the related API in the solver, and thus every
time we write a new analysis that needs different initial-
ization, we have to additionally implement a new solver to
override the API that is responsible for initializing data facts.
We argue that an elegant design is to have just one solver
to drive multiple data flow analyses, so that developers only
need to focus on the implementations of their analyses (no
need to know the details of solver).

Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

Edge transfer functions. Unlike Tai-e, SpotBugs and WALA,
Soot does not explicitly support edge transfer functions.
Edge transfer functions differ from node transfer functions
in that they allow distinct data facts to be sent to various suc-
cessors of a particular node along the edges between these
nodes, utilizing branch information (e.g., fact D is propa-
gated when expression E’s value is true) to create more ef-
fective analysis. When the body of edge transfer function
is left empty, it is regarded as an identity function to di-
rectly propagate the OUT fact of its source node to the IN
fact of its target node (i.e., at this point, the analysis will
change back to the normal one where only node transfer
function is in charge). However, in Soot, to leverage branch
information, developers need to extend a special analysis
called BranchedFlowAnalysis and implement the logics for
both edges and nodes in its node transfer function, which is
inconvenient and a bit cumbersome in design.

Data facts comparison. Unlike Tai-e and WALA, in SpotBugs
and Soot, in order to determine whether data facts have
changed during consecutive iterations and accordingly de-
cide whether to add the relevant nodes to worklist for further
handling, their analysis solvers retain the old data facts and
will compare them to the new ones in each iteration in the
same way. However, although optimization can be used for
certain analyses, it is hard to accomplish when the solver
is in charge of the comparison. In contrast, Tai-e and WALA
reverse the comparison right to developers (actually, to the
transfer function) and the solver waits for transfer function’s
decision before proceeding. For example, assume that we
have 1000 variable-value pairs in the data fact of constant
propagation. After solver sends the merged IN and old OUT
facts (of certain node) to transfer function, constant propa-
gation can directly update the old OUT fact (as new OUT
fact) when it finds, e.g., a variable’s value has changed from
1 to NAC, and then notifies the solver to add the successors
of the node to worklist. As a result, the solver does not need
to retain a copy of old fact and compare it (1000 pairs) to the
new one.

4 New Analysis Development
A static analysis framework should offer mechanisms to in-
corporate new analyses, from intraprocedural to interproce-
dural ones, and it is important to keep in mind that working
with pointer analysis is necessary for the creation of a vari-
ety of analyses [65, 70]. We introduce how Tai-e and other
frameworks design for developing new analyses that need
to interact with pointer analysis (Section 4.1), as well as for
developing or integrating other analyses (Section 4.2).

4.1 Develop Analysis that Interacts with Pointer

Analysis

Numerous static analyses, including fundamental ones like
reflection analysis [44, 45] and exception analysis [9, 32] as

9

well as clients like bug finders [12, 56] and security analyz-
ers [3, 21, 49], require to interact with pointer analysis.

Doop naturally supports such interactive analysis and is
able to yield elegant implementation, benefiting from Data-
log’s declarative ability. However, Doop is also limited by Dat-
alog in implementing analysis that requires non-set-based
lattices [52, 72], and it is hard to optimize specific analysis
as Datalog solver adopts analysis-independent data struc-
tures and execution strategy [23]. As a result, imperative
frameworks that facilitate such interactive analysis are in
high demand. As representatives, Soot lacks this backing,
whereas WALA does.

WALA provides a scheme to add new analysis that interacts
with pointer analysis, but in a limited way. Briefly, develop-
ers need to implement an interface called ContextSelector
to specify related call sites (of certain APIs) which the new
analysis aims to model based on the points-to results; for
example, to analyze reflective call v = c.newInstance(),
developers encode ContextSelector to identify this call site
and retrieve the Class objects, say CO, that are pointed to
by c via pointer analysis. Then, developers need to imple-
ment ContextInterpreter to generate different fictitious
but effect-equivalent IRs (e.g., v = new T(); v.<init>():
allocating an object and calling its constructor in this case)
according to the resolved types of CO (say T). Then these
generated IRs are fed back to pointer analysis to continue
the resolution for this reflective call.

We argue that this scheme has some limitations to fa-
cilitate interactions with pointer analysis. First, for certain
analyses, it is insufficient to interact with pointer analysis by
only giving developers a way to concentrate on and resolve
related call sites; capabilities for monitoring the points-to in-
formation of specified variables are required. For example, in
exception analysis, if the points-to set of variable e in throw
e is changed, the points-to set of the corresponding catch
variable should also be updated. Second, in many situations,
it is simpler to update points-to-information or call graph
edges directly, which can prevent the generation of exces-
sive amounts of fictitious IR code and the need to invoke the
solver to reanalyze the created code. Thus, a framework is
supposed to also offer a mechanism to perceive changes for
any variables of a program in order to accommodate more
analyses; additionally, it should provide a way to directly
adjust the points-to results and call graph edges for an easier
or more effective engagement with pointer analysis.

Recently, Helm et al. [23] present an ambitious approach to
collaborating various analyses on the fly, even with different
analysis lattices. However, this approach is too complex to
adopt for addressing our problem, because many constraints
must be put in place by developers, including encoding the
rules that govern how control engine should interpret and
communicate the results of one analysis to others.

To practically facilitate the development of new analysis
that needs to interact with pointer analysis, in Tai-e, we

Tian Tan and Yue Li

Figure 3. Overview of the analysis plugin system of Tai-e for developing new analyses, e.g., taint analysis, exception analysis,
reflection analysis, etc. that require interaction with pointer analysis.

introduce a simple yet effective method called analysis plugin
system. Currently a dozen analyses in Tai-e are built on top
of this system, including fundamentals like reflection and ex-
ception analyses, clients like taint analysis, utility tools like
analysis timer and constraint checker (for debugging), mod-
ern language feature handling like lambda expression and
method reference analyses, runtime environment modeling
like native code and thread modeling, and so on.

Basic Idea. We explain how this analysis plugin system
works. As shown in Figure 3, this system includes a pointer
analysis solver and a number of analyses that communicate
with it. Each of these analyses is referred to as an analysis plu-
gin that needs to implement interface Plugin of Tai-e. The
interactions between pointer analysis solver and analysis
plugin are carried out by calling each other’s APIs. The core
APIs of Solver and Plugin are highlighted in blue and red,
respectively. The Solver APIs have been implemented in the
framework, and developers only need to implement the re-
lated APIs of Plugin to develop new analysis. The additional
auxiliary APIs are optional and designed to make it easier
to create specific functionalities; for example, addStmts of
Solver can be called to simulate the effect of specific call
sites, which is similar to the generated-IR approach of WALA
mentioned above.

Let us briefly illustrate the basic working mechanism that
drives those core APIs. Assuming you are implementing
the onNewPointsToSet method of an analysis Plugin, this
means whenever an interested variable’s (parameter Var)
points-to set (parameter PointsToSet) is changed (i.e., it
points to more objects), you need to encode your logic to
reflect the side effect made by this change; the final conse-
quence of such an effect, from the perspective of pointer
analysis, is to modify the points-to set of any related point-
ers or to add call graph edges at pertinent call sites. Ac-
cordingly, you should call the addPointsTo or addCallEdge
methods of the Solver to alert it of these modifications. Con-
versely, during each analysis iteration, the Solver calls the
onNewPointsToSet and onNewCallEdge methods of every

10

Plugin to notify them of any changes to the variables’ points-
to sets or call graph edges, respectively. As a result, to add
a new analysis that interacts with pointer analysis, devel-
opers just need to implement a few methods of Plugin in
accordance with the requirement, as previously described.

Case Study. To better understand how to build new anal-
yses on top of this plugin system, let us look at a specific
example: creating a taint analysis, and its pseudocode is
depicted in Figure 4. We recommend following the figure
together with our text explaining the scenario below.

1 String s1 = x.source();
2 s3 = s2.concat(s1);
3 y.sink(s3);

The code above outlines a typical case for taint analysis:
Sensitive data from an object, say o1, returned by x.source(),
is combined with an object, say o3, pointed to by s3, returned
by s2.concat(s1). Finally, taint analysis reports that line 3
contains a leak of o1’s sensitive data because o3 is used as
an argument by a sink method.

As taint analysis is developed as an analysis plugin, it
needs to implement some of its methods in Figure 3. In our
case, as shown in Figure 4, two core methods onNewCallEdge
(line 5) and onNewPointsToSet (line 16), and an auxiliary
method onFinish (line 27) are considered.

Let us first examine onNewCallEdge. Assuming we are
handling call site 1: String s1 = x.source() in the code
snippet above, and for this call site, the pointer analysis solver
has resolved a new call graph edge from edge source (which
is a call site denoted as edge.cs), i.e., call site 1, to edge
target, i.e., the dispatched method source; then the solver
notifies the taint analysis plugin and passes this new edge to
parameter edge in line 5, by calling plugin’s onNewCallEdge
method (the solver code is omitted).

Then the plugin code checks what the edge.target is.
If the target is a sensitive source method, denoted as
source (line 6) (the source, transfer and sink methods
are specified in the configuration file of taint analysis), a

addPointsTo(Pointer, PointsToSet)addCallEdge(Edge)addPFGEdge(Pointer, Pointer)onStart()onFinish()onNewPointsToSet(Var, PointsToSet)onNewCallEdge(Edge)onNewMethod(JMethod)Notify analysis plugin by callingplugin analysis’s interfacesUpdate solver by callingsolver’s interfacesSolverAnalysis PluginaddStmts(Collection<Stmt>)Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

mocked taint object is created (line 7) and the plugin up-
dates the solver that the left-hand side variable of this call
site, namely s1 (of the above code), should point to the taint
object that was just created (line 8).

If the target is a transfer method (line 10), e.g., the concat
method at call site 2: s3 = s2.concat(s1), by which taint
objects could be transferred from its parameters (e.g., s1)
to other variables at the call site (e.g., s3) [21], for each of
such transfer relation, denoted as (from,to) in line 11, the
taint objects that are pointed to by from should be added
in the points-to set of to (line 12 and lines 21 – 24). As a
result, s3 now points to the taint object transferred from
s1. Actually, this transfer relation is also recorded in a data
structure called transferVars (line 13), which is equivalent
to add a taint-relevant flows-to edge summarized for transfer
method. Then the code of onNewPointsToSet (line 16) is
easy to understand: whenever a new taint object flows to
parameter v, and v is also the from variable recorded in
transferVars mentioned above, the corresponding flows-
to variable to, should also point to this taint object (line 18)
for soundness.

onFinish (line 27) will be called by solver after it reaches
the fixed point. For each sink method and its sensitive param-
eter param_i (line 28), onFinish identifies all its call sites cs
and checks to see if any taint objects flow to param_i (lines
29 – 31), and if they do, it reports this taint information.

Finally, let us discuss a possible design trade-off for this
analysis plugin system. As described above, Solver invokes
methods onNewPointsToSet and onNewCallEdge of every
Plugin in turn to notify them any changes to variables’
points-to sets or call graph edges. One might wonder why
not allow each analysis plugin to register their interested
variables or call graph edges to the solver in advance, so
that the plugins only receive notifications when the regis-
tered variables or edges change. We do not take this design
into consideration for three reasons. First of all, this will add
more API to the interface to register the interesting variables,
increasing developers’ workload. Second, while creating an
analysis plugin, it can be hard to identify and specify the call
graph edges that are of relevance in advance. Third, we use
runtime profiling and discover that our current design (the
solver notifies every plugin in turn) actually introduces neg-
ligible cost in practice. As Section 6 will discuss, our analysis
plugin system has received very positive user feedback.

4.2 Develop Other Analyses
A static analysis framework would be beneficial if it could
also provide facilities for developing other analyses, includ-
ing intraprocedrual and interprocedural ones.

Soot categories analysis into two kinds, method-level and
program-level, and developers need to implement so-called
BodyTransformer and SceneTransformer to develop their

11

void onNewCallEdge(Edge edge) {

Set<Pair<Var, Var>> transferVars;

1 class TaintAnalysis implements Plugin {
2
3
4
5
6
7
8
9
10
11

if edge.target is transfer:

if edge.target is source:

o = heapModel.getMockObj("TaintObj", edge.cs)
solver.addPointsTo(edge.cs.lhsV, o)

foreach (from, to) in getTransfer(edge.target,

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34 }

edge.cs):

transferTaint(solver.getPointsToSet(from), to)
record (from, to) in transferVars

}

void onNewPoinstToSet(Var v, PointsToSet pts) {

foreach (v, to) in transferVars:

transferTaint(pts, to)

}

void transferTaint(PointsToSet pts, Var to) {

foreach o in pts:

if o.desc is "TaintObj":

solver.addPointsTo(to, o)

}

void onFinish() {

foreach (sink, param_i) in sinks:

foreach callsite cs in solver.getCallersOf(sink):

foreach o in solver.getPointsToSet(cs.args[param_i]):

if o.desc is "TaintObj":

report(o, cs)

}

Figure 4. Plugin of taint analysis (pseudocode version).

specified intraprocedrual and whole-program analyses, re-
spectively. SpotBugs facilitates to develop method-level and
class-level analyses, and the latter covers certain field- and
hierarchy-related analyses that require the information of
classes. For example, FindMaskedFields is to detect if a field
has the same name with local variables in its declaring class
or its parents’ fields; RedundantInterfaces is to find out
if an interface implemented by a class has also been imple-
mented by its parent. WALA does not have an explicit scheme
to develop and integrate new analysis as it is often used as
a library, and when users develop new analysis, they often
need to specify their main() behaviors nearly from scratch.
Tai-e supports all three types of the analyses mentioned
above (i.e., method-, class- and program-level analyses); fur-
thermore, unlike Soot where developers require to follow
the implicit rules to hard-code new analysis into frame-
works, Tai-e (similar to SpotBugs) allows to configure new
analysis in a decoupled way. To develop a new analysis in
Tai-e, developers only need to choose one of the classes
MethodAnalysis, ClassAnalysis and ProgramAnalysis to
extend, and implement the corresponding analyze() method

based on the specific application, and then register the anal-
ysis in a configuration file (specifying analysis name, depen-
dent analyses, and certain default options if needed). Tai-e
will take care of the process regarding how to automatically
drive new analyses and record analysis results according to
the specified analysis categories, dependences and options,
which greatly reduces the effort required from developers.

5 Multiple Analyses Management
In many circumstances, an analysis depends on the outcomes
of other analyses, and thus it will be helpful if the framework
can provide a mechanism to coordinate multiple analyses. In
this section, we discuss two crucial issues related to manag-
ing numerous analyses: how to configure an analysis and its
dependencies (Section 5.1), and how to save the outcomes of
one analysis and access them in another (Section 5.2)?

5.1 Configure Analysis and Its Dependences
WALA has no explicit management for multiple analyses, and
as mentioned previously, Soot needs to hard-code new anal-
yses while Tai-e and SpotBugs support to register them in
the framework through configuration files and then drive
them via reflection. Figure 5 depicts a configuration example
for specifying control flow graph (CFG) builder in Tai-e
with format of YAML [80] (a concise and human-friendly
format that is commonly used for configuration files where
data is being stored or transmitted).

Figure 5. A configuration example of Tai-e for CFG builder.

The first three attributes are easy to understand and the
fourth one, requires specifies all the dependent analyses
for cfg (i.e., all the analyses whose results are required by
cfg). In this instance, it is an exception analysis (denoted
by throw) and the boolean expression inside its followed
parenthesis indicates that the dependent analysis is only re-
quired when the expression value is true. In our case, that
means Tai-e needs to run throw before cfg only when op-
tion exception’s value is explicit or all. The last attribute
options lists all the default values for the options designed
for cfg: only the explicit edges of exception are considered,
and the analysis results are not dumped to files.

In Soot, before running an analysis, users must explicitly
list any dependent analyses (including those that depend
on the dependent ones) in the command. This approach
is cumbersome and prone to mistakes for users who are
unfamiliar with the framework.

12

Tian Tan and Yue Li

In Tai-e and SpotBugs, the dependency resolution is au-
tomatic by analyzing configuration files, ensuring the cor-
rectness of execution order for all dependent analyses; be-
sides, this approach frees up developers to concentrate on
the specification of their own analysis, and saves their effort
of writing command options when running an analysis.

Compared to SpotBugs, Tai-e is more flexible in resolv-
ing analysis dependences. Let us take an example to explain.
We want to build two different types of CFGs: one that re-
solves a program’s explicit exceptional edges and the other
that ignores exception. In Tai-e, this can be done by simply
giving different commands: one is “-a cfg” (-a means anal-
ysis) and the other is “-a cfg=exception:null”. The latter
uses runtime option value (exception:null) to override the
default one (specified by exception:explicit in Figure 5).
But in SpotBugs, as it does not support conditional logics to
describe analysis options and dependences, every time we
perform the analysis, we have to find the relevant configura-
tion files/options and modify the values as necessary.

In summary, in order to facilitate simple usage, mainte-
nance, and troubleshooting in terms of configuring and con-
ducting analyses, Tai-e strives to guide users to modify code
or configurations as little as possible.

5.2 Store/Access Analysis Results
Storing and accessing analysis results may seem like a mi-
nor concern that doesn’t need to be discussed, but a good
design, despite the fact that it may not look technical, can
nevertheless produce a favorable user experience.

Unlike Tai-e and SpotBugs, WALA and Soot do not have a
uniform mechanism to manage analysis results for all analy-
ses (Soot only stores the results of some analyses like pointer
analysis in the singleton instance of Scene). In SpotBugs,
users need to remember different methods to get related re-
sults. For example, assuming you are implementing a dead
code analysis for any given method (or IR, as IR is typically re-
lated to each method), to obtain the analysis result yielded by
an intraprocedural analysis like CFG builder for this method,
users should call IAnalysisCache.getMethodAnalysis(),
and send it two arguments, one for the analysis they want
(CFG builder) and the other for the method they wish to an-
alyze. Accordingly, users need to remember and call another
method and provide additional relevant arguments if they
require the results from a class-related analysis.

However, in Tai-e, regarding analysis results, users only
need to remember one method getResult(id) (id is the
analysis name) for all types of analyses, including method-,
class- and program-level analyses, as described in Section 4.2.
For the same example above, as it is an intraprocedural or
method-level analysis (which means that in Tai-e, it will ex-
tend MethodAnalysis and encode its analyze(ir) method
where ir represents the IR for any method, and is passed by
the framework), users only need to use the parameter ir to
directly obtain the result by calling ir.getResult("cfg").

-description: intraprocedural control-flow graphanalysisClass: pascal.taie.analysis.graph.cfg.CFGBuilderid: cfgrequires: [ throw(exception=explicit|all)]options: # default valuesexception: explicit# | null | alldump: false# dump .dot filesTai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

Similarly, if users are implementing a class-level analysis
(which means it extends class ClassAnalysis and imple-
ments method analyze(jclass)), they only need to call
jclass.getResult(id) to get the results. The straightfor-
ward user interface for accessing analysis results benefits
from the fact that Tai-e automatically stores analysis results
in different locations based on various types of analyses. As
a result, users no longer have to bother trying to memorize
complicated methods and specify additional arguments.

in terms of efficiency and soundness, for virtually all cases,
under both context-insensitivity and context-sensitivity set-
tings. With such efficient capabilities, other analyses, includ-
ing those that interact with pointer analysis (Section 4.1)
and those that use its results (Section 4.2), can profit from
increased analysis speed. In addition, Tai-e also offers effi-
cient analysis-relevant data structures (such as index map,
various bit sets, and hybrid sets, etc.) to make it easier to
develop efficient new analysis.

6 A View of System Design
Our primary goal is to make Tai-e an easy-to-learn and easy-
to-use static analysis framework for Java, and to do this, we
painstakingly design and implement it from scratch while
adhering to the HBDC principle. From another perspective,
Tai-e is a sophisticated system software, and a good system
should also go by a few well-established design principles,
which are summed up as STEADY by Butler W. Lampson in
his seminal work for system design [36, 37]. In this section,
we examine Tai-e from the view of STEADY which stands
for “Simple, Timely, Efficient, Adaptive, Dependable and
Yummy” 2.

Simple. Keep the design simple. Tai-e follows the sim-
plicity principle from the high-level goal to the low-level
implementation. “Do one thing well” and “be aware of univer-
sal goals’ [37]’: Tai-e is designed to analyze Java programs
only (there is no requirement for code transformation and
for supporting to analyze other languages), so the designs
for program abstractions and facilities to build analysis can
be simplified. The code structure of Tai-e, including its
modules or packages, is well organized and simple to com-
prehend. The facilities offered by Tai-e, accessed through
its APIs, are likewise designed in an easy-to-use way. For
example, as explained previously, the code for utilizing IR
and retrieving type/class information (Section 2), developing
certain sophisticated control/data flow analyses (Section 3),
obtaining results of various analyses (Section 5), is simpler to
write than others. In the lowest level, we even make an effort
to make the code simple to understand. All of these factors,
along with the emphasis placed on the adaptivity principle
(discussed later), make Tai-e easy-to-learn and easy-to-use.

Efficient. Build a high-performance system. As explained
previously, as pointer analysis is a fundamental analysis,
on which virtually all others are built [40], it severs as the
framework’s core motor, propelling other analyses, and thus
its efficiency is of utmost importance. As demonstrated in a
thorough evaluation in Section 3.1, Tai-e’s pointer analysis
system outperforms all other state-of-the-art frameworks

2Note that if a principle or certain aspects of it have no bearing on the pri-
mary goal of Tai-e, for examples, “Timely” means “shipping soon enough to
meet time-to-market needs”, and a system should be “Adaptive” to changes
“in scale” (from 100 to 1 million users), we will omit the related discussion.

13

Adaptive. Build a system that is adaptive to functional
changes, and the keys to enabling it are modularity and exten-
sion points in design [37]. We create Tai-e with adaptivity
in mind at all times. For instance, as introduced in Section 3.1,
Tai-e supports fine-granularity modules for pointer analy-
sis system by providing various kinds of heap abstractions
and context-sensitivity approaches, and it offers interfaces to
easily implement new pointer analysis algorithms, or change
any heap and context components of existing ones as needed.
Take another example, to add a new analysis (Section 4.2)
in Tai-e, users only need to extend a related class (method-
/class-/program-level), completes its logics accordingly and
register the analysis in a configuration file (no other hard-
code operations are required), and Tai-e will handle the rest
of activities for managing it (e.g., resolving its dependences,
driving it with specified options, accessing its results, etc.).
Such decouple design improves Tai-e’s ability to adjust to
the addition or removal of analysis.

Dependable. A system is dependable if it is reliable, avail-
able (in case of failures) and secure [37]. However, Tai-e
is not a software that offers continuous services or stores
private user data, and thus dependability is not its major
concern at the current stage. Still, we have made some at-
tempts in design to make Tai-e more reliable by preventing
certain faults that users unwittingly cause, e.g., the IR of
Tai-e is immutable and the dependencies among multiple
analyses (which affects execution order of analyses) are re-
solved automatically by Tai-e based on their configurations
(rather than having users specifically list them in input op-
tion). In addition, inspired by TAJS (a classic static analysis
framework for JavaScript) [26], Tai-e supports regression
testing which can take advantage of the integrated analyses
to assess the correctness of framework code in the event of
any improper modifications.

Yummy. A system should be yummy, which implies it
ought to have an attractive feature that customers are en-
thusiastic about [37]. In our opinion, one yummy design
of Tai-e is its analysis plugin system which facilities the
development of analysis that needs to interact with pointer
analysis (Section 4.1). To make a yummy system, we’d better
study the users deeply, and “it is much easier if the designers
are also users” [37]. That exactly describes our case: we have
been researching pointer analysis and the analyses rely on

it for about ten years, and we know users’ needs of pointer
analysis well. As described in Section 4.1, a dozen analyses
including fundamental ones, clients, utility tools, language
features and runtime environment modeling, are all devel-
oped on top of this system (actually, it enables many analyses
to be pluggable, which introduces fine modularity to Tai-e
to make it more adaptable). Moreover, our analysis plugin
system is currently being used by a number of ongoing in-
ternal projects implemented by different developers (these
projects will be released when finished), and the feedback
from developers is very promising: everyone agrees that it
can fulfill their practical needs and is simple to understand
and apply.

7 Related Work
The most pertinent work has been thoroughly compared
and discussed throughout the paper, and in this section, we
discuss additional related work.

Lam et al. [35] give a retrospective of Soot by summa-
rizing its main features, major changes (e.g., it consolidated
singletons to support multiple runs, and supported to an-
alyze incomplete programs), and future directions (e.g., to
build faster startup and enhance interprocedural analysis).
In addition, they mention some difficulties in developing
Soot and suggest some desirable features for future com-
piler frameworks. Particularly, the authors observe that it is
difficult to publish framework papers and urged the commu-
nity to embrace more framework articles; their appeal is a
great encouragement to us.

Schubert et al. [63] introduce the lessons from construct-
ing a data flow analysis framework for C/C++ [62], some
of which are specific to framework’s features while others
are more general. For instance, it would be beneficial for a
framework to offer means like instrumentation to help debug
analysis-related bugs. This is inspiring and we may consider
developing similar approach in Tai-e in the future.

Sadowski et al. [61] summarize the lessons from build-
ing static analysis tools at Google. They advise integrating
static analysis into workflow as early as possible, and do
the analysis checks as compiler errors if possible (otherwise,
developers often ignore analysis results). Integrating Tai-e’s
individual analyses into developers’ workflows may need
to modify the basic infrastructure of Tai-e, but that is an
interesting subject that merit further investigation.

Some studies evaluate static analysis tools from the view
of users’ needs [15, 16, 55]. For instance, a good static analy-
sis tool should produce high-quality warning messages that
offer information on what might be wrong, why it should be
fixed, and how it could be fixed, have low false positives of
analysis results, and support the integration of user knowl-
edge, and more.

Although the work mentioned above offers helpful lessons
(from building specific static analysis frameworks), or study

Tian Tan and Yue Li

results (by evaluating static analysis tools based on users’
requirements), none of them addresses the problem of our
research. We still lack a systematic way to observe and dis-
cuss a static analysis framework’s design quality from the
perspective of the developers who build their analyses using
the abstractions and facilities provided by the framework.
Our work substantially fills this gap by comprehensively
compare and discuss the designs of various classic frame-
works for Java. Below we briefly describe some other Java
static analysis framework.

Chord [56] is a static analysis framework for Java that is
written in Java and Datalog with bddbddb [79] (a BDD-based
implementation of Datalog), serving as the Datalog solver.
As explained in Section 4.1, despite being elegant when im-
plementing various analyses, Datalog has limited expression
capacity and optimization potential. Chord is particularly
known for its capability to detect concurrent errors such as
data races, and we will develop these clients imperatively
(rather than declaratively) in Tai-e.

OPAL [17] is a static analysis framework for Java which is
written in Scala. The collaborative analysis approach [23]
described in Section 4.1 is implemented in OPAL, but unfor-
tunately their approach is too complex to be effective for
our problem: developing analysis that interacts with pointer
analysis. In addition, the same authors [60] conduct interest-
ing study to assess the soundness of call graphs produced by
call-graph algorithms (like RTA and CHA) in various frame-
works, emphasizing the importance of effectively handling
language features.

We discuss TAJS [26], a classic static analysis framework
for JavaScript and Node.js [18, 53, 57], as some designs of
Tai-e are inspired by it. One is the regression testing men-
tioned in Section 6 and the other is the initial idea of Tai-e’s
analysis plugin system, where the solver-plugins structure
resembles TAJS’s monitor approach, despite that their goals,
methodologies and APIs are fundamentally different. For
examples, their monitor approach is mainly used to collect
analysis results and perform statistics, e.g., recording the
times a statement is accessed, or timing an analysis spent
on each statement, and it requires that monitor interface
implementations should not have side effects on the analysis
state prior to the monitor scan, but Tai-e’s interface imple-
mentation for analysis plugin is to have side effect on the
pointer analysis by calling methods like addPointsToSet as
explained in Section 4.1.

8 Conclusions
From the perspective of analysis developers, what should a
good static analysis framework look like? Even after years,
there might not be a satisfactory answer to this subject ques-
tion. But in the real world, it is a valuable question that
cannot be avoided as a static analysis framework serves as

14

Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

the foundation for creating static analyses for various appli-
cations. To bridge this knowledge gap, this paper takes a big
step forward by systematically comparing and discussing
the design trade-offs for each of the crucial components of
a static analysis framework for Java including program ab-
straction, fundamental analyses, new analysis development
and multiple analysis management. For each component,
the design choice made for it by each of the related clas-
sic frameworks (Soot, WALA, Doop and SpotBugs) are deeply
examined and debated according to the HBDC principle.

Our efforts are both labor- and intelligence-intensive as for
each design point, we must study and comprehend the code
of those large and intricate frameworks full of challenging
analysis algorithms. But such efforts are also worthwhile
as they aid in the creation of Tai-e, a new static analysis
framework for Java that features arguably the “best” designs
from both the novel ones we proposed and those of classic
frameworks. Tai-e was meticulously constructed from the
ground up with the intention of being easy-to-learn and easy-
to-use, and we have demonstrated throughout the article
that it works well in attaining the goals. Although we cannot
ensure to make a comprehensive and accurate assessment for
every framework design point (due to the subjective nature
of this problem), we believe this paper and Tai-e provide
useful materials and perspectives for building better static
analysis infrastructures, and we will actively and constantly
contribute to Tai-e by developing and incorporating more
analyses and clients in the future.

References
[1] Lars Ole Andersen. 1994. Program analysis and specialization for the C
programming language. Ph.D. Dissertation. University of Copenhagen.
[2] Tony Antoniadis, Konstantinos Triantafyllou, and Yannis Smaragdakis.
2017. Porting Doop to Soufflé: A Tale of Inter-Engine Portability for
Datalog-Based Analyses. In Proceedings of the 6th ACM SIGPLAN Inter-
national Workshop on State Of the Art in Program Analysis (Barcelona,
Spain) (SOAP 2017). Association for Computing Machinery, New York,
NY, USA, 25–30. https://doi.org/10.1145/3088515.3088522

[3] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexan-
dre Bartel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick D.
McDaniel. 2014. FlowDroid: precise context, flow, field, object-sensitive
and lifecycle-aware taint analysis for Android apps. In ACM SIG-
PLAN Conference on Programming Language Design and Implemen-
tation, PLDI ’14, Edinburgh, United Kingdom - June 09 - 11, 2014,
Michael F. P. O’Boyle and Keshav Pingali (Eds.). ACM, 259–269.
https://doi.org/10.1145/2594291.2594299

[4] Mohamad Barbar and Yulei Sui. 2021. Compacting Points-to Sets
through Object Clustering. Proc. ACM Program. Lang. 5, OOPSLA,
Article 159 (oct 2021), 27 pages. https://doi.org/10.1145/3485547
[5] Stephen M. Blackburn, Robin Garner, Chris Hoffmann, Asjad M. Khan,
Kathryn S. McKinley, Rotem Bentzur, Amer Diwan, Daniel Feinberg,
Daniel Frampton, Samuel Z. Guyer, Martin Hirzel, Antony L. Hosk-
ing, Maria Jump, Han Bok Lee, J. Eliot B. Moss, Aashish Phansalkar,
Darko Stefanovic, Thomas VanDrunen, Daniel von Dincklage, and
Ben Wiedermann. 2006. The DaCapo benchmarks: Java benchmark-
ing development and analysis. In Proceedings of the 21th Annual ACM
SIGPLAN Conference on Object-Oriented Programming, Systems, Lan-
guages, and Applications, OOPSLA 2006, October 22-26, 2006, Portland,

15

Oregon, USA, Peri L. Tarr and William R. Cook (Eds.). ACM, 169–190.
https://doi.org/10.1145/1167473.1167488

[6] Sam Blackshear, Nikos Gorogiannis, Peter W. O’Hearn, and Ilya
Sergey. 2018. RacerD: Compositional Static Race Detection. Proc.
ACM Program. Lang. 2, OOPSLA, Article 144 (oct 2018), 28 pages.
https://doi.org/10.1145/3276514

[7] Bruno Blanchet. 2003. Escape Analysis for JavaTM: Theory and
Practice. ACM Trans. Program. Lang. Syst. 25, 6 (nov 2003), 713–775.
https://doi.org/10.1145/945885.945886

[8] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela Oueslati, and Mira
Mezini. 2011. Taming reflection: Aiding static analysis in the pres-
ence of reflection and custom class loaders. In Proceedings of the 33rd
International Conference on Software Engineering, ICSE 2011, Waikiki,
Honolulu, HI, USA, May 21-28, 2011. 241–250. https://doi.org/10.1145/
1985793.1985827

[9] Martin Bravenboer and Yannis Smaragdakis. 2009. Exception Analysis
and Points-to Analysis: Better Together. In Proceedings of the Eighteenth
International Symposium on Software Testing and Analysis (Chicago, IL,
USA) (ISSTA ’09). Association for Computing Machinery, New York,
NY, USA, 1–12. https://doi.org/10.1145/1572272.1572274

[10] Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly declarative
specification of sophisticated points-to analyses. In Proceedings of the
24th Annual ACM SIGPLAN Conference on Object-Oriented Program-
ming, Systems, Languages, and Applications, OOPSLA 2009, October
25-29, 2009, Orlando, Florida, USA, Shail Arora and Gary T. Leavens
(Eds.). ACM, 243–262. https://doi.org/10.1145/1640089.1640108

[11] Bruce K.Haddon. 2010.

Virtual-memory-like sparse bit set.

https://github.com/brettwooldridge/SparseBitSet/blob/master/
SparseBitSet.pdf.

[12] Satish Chandra, Stephen J. Fink, and Manu Sridharan. 2009. Snug-
glebug: a powerful approach to weakest preconditions. In Proceed-
ings of the 2009 ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation, PLDI 2009, Dublin, Ireland, June
15-21, 2009, Michael Hind and Amer Diwan (Eds.). ACM, 363–374.
https://doi.org/10.1145/1542476.1542517

[13] Yifan Chen, Chenyang Yang, Xin Zhang, Yingfei Xiong, Hao Tang,
Xiaoyin Wang, and Lu Zhang. 2021. Accelerating Program Analyses in
Datalog by Merging Library Facts. In Static Analysis: 28th International
Symposium, SAS 2021, Chicago, IL, USA, October 17–19, 2021, Proceed-
ings (Chicago, IL, USA). Springer-Verlag, Berlin, Heidelberg, 77–101.
https://doi.org/10.1007/978-3-030-88806-0_4

[14] Jong-Deok Choi, Manish Gupta, Mauricio Serrano, Vugranam C. Sreed-
har, and Sam Midkiff. 1999. Escape Analysis for Java. In Proceedings of
the 14th ACM SIGPLAN Conference on Object-Oriented Programming,
Systems, Languages, and Applications (Denver, Colorado, USA) (OOP-
SLA ’99). Association for Computing Machinery, New York, NY, USA,
1–19. https://doi.org/10.1145/320384.320386

[15] Maria Christakis and Christian Bird. 2016. What developers want
and need from program analysis: an empirical study. In Proceedings
of the 31st IEEE/ACM International Conference on Automated Software
Engineering, ASE 2016, Singapore, September 3-7, 2016, David Lo, Sven
Apel, and Sarfraz Khurshid (Eds.). ACM, 332–343. https://doi.org/10.
1145/2970276.2970347

[16] Lisa Nguyen Quang Do, James R. Wright, and Karim Ali. 2022. Why
Do Software Developers Use Static Analysis Tools? A User-Centered
Study of Developer Needs and Motivations.
IEEE Transactions on
Software Engineering 48, 3 (2022), 835–847. https://doi.org/10.1109/
TSE.2020.3004525

[17] Michael Eichberg and Ben Hermann. 2014. A Software Product Line for
Static Analyses: The OPAL Framework. In Proceedings of the 3rd ACM
SIGPLAN International Workshop on the State of the Art in Java Program
Analysis (Edinburgh, United Kingdom) (SOAP ’14). Association for
Computing Machinery, New York, NY, USA, 1–6. https://doi.org/10.
1145/2614628.2614630

[18] André Takeshi Endo and Anders Møller. 2020. NodeRacer: Event
Race Detection for Node.js Applications. In Proc. IEEE International
Conference on Software Testing, Verification, and Validation (ICST).
[19] Pratik Fegade and Christian Wimmer. 2020. Scalable Pointer Analysis
of Data Structures Using Semantic Models. In Proceedings of the 29th
International Conference on Compiler Construction (San Diego, CA,
USA) (CC 2020). Association for Computing Machinery, New York, NY,
USA, 39–50. https://doi.org/10.1145/3377555.3377885

[20] Stephen J. Fink, Eran Yahav, Nurit Dor, G. Ramalingam, and Emmanuel
Geay. 2008. Effective Typestate Verification in the Presence of Aliasing.
ACM Trans. Softw. Eng. Methodol. 17, 2, Article 9 (May 2008), 34 pages.
https://doi.org/10.1145/1348250.1348255

[21] Neville Grech and Yannis Smaragdakis. 2017. P/Taint: unified points-to
and taint analysis. PACMPL 1, OOPSLA (2017), 102:1–102:28. https:
//doi.org/10.1145/3133926

[22] Dongjie He, Jingbo Lu, and Jingling Xue. 2022. Qilin: A New Frame-
work For Supporting Fine-Grained Context-Sensitivity in Java Pointer
Analysis. In 36th European Conference on Object-Oriented Programming,
ECOOP 2022, June 6-10, 2022, Berlin, Germany (LIPIcs, Vol. 222), Karim
Ali and Jan Vitek (Eds.). Schloss Dagstuhl - Leibniz-Zentrum für Infor-
matik, 30:1–30:29. https://doi.org/10.4230/LIPIcs.ECOOP.2022.30

[23] Dominik Helm, Florian Kübler, Michael Reif, Michael Eichberg, and
Mira Mezini. 2020. Modular collaborative program analysis in OPAL.
In ESEC/FSE ’20: 28th ACM Joint European Software Engineering Con-
ference and Symposium on the Foundations of Software Engineering,
Virtual Event, USA, November 8-13, 2020, Prem Devanbu, Myra B.
Cohen, and Thomas Zimmermann (Eds.). ACM, 184–196.
https:
//doi.org/10.1145/3368089.3409765

[24] S. Horwitz, T. Reps, and D. Binkley. 1988. Interprocedural Slicing Using
Dependence Graphs. In Proceedings of the ACM SIGPLAN 1988 Confer-
ence on Programming Language Design and Implementation (Atlanta,
Georgia, USA) (PLDI ’88). Association for Computing Machinery, New
York, NY, USA, 35–46. https://doi.org/10.1145/53990.53994
[25] David Hovemeyer and William Pugh. 2004. Finding Bugs is Easy. In
Companion to the 19th Annual ACM SIGPLAN Conference on Object-
Oriented Programming Systems, Languages, and Applications (Vancou-
ver, BC, CANADA) (OOPSLA ’04). Association for Computing Machin-
ery, New York, NY, USA, 132–136. https://doi.org/10.1145/1028664.
1028717

[26] Simon Holm Jensen, Anders Møller, and Peter Thiemann. 2009. Type
Analysis for JavaScript. In Static Analysis, 16th International Sympo-
sium, SAS 2009, Los Angeles, CA, USA, August 9-11, 2009. Proceedings
(Lecture Notes in Computer Science, Vol. 5673), Jens Palsberg and Zhen-
dong Su (Eds.). Springer, 238–255. https://doi.org/10.1007/978-3-642-
03237-0_17

[27] Minseok Jeon, Sehun Jeong, Sungdeok Cha, and Hakjoo Oh. 2019. A
Machine-Learning Algorithm with Disjunctive Model for Data-Driven
Program Analysis. ACM Trans. Program. Lang. Syst. 41, 2 (2019), 13:1–
13:41. https://doi.org/10.1145/3293607

[28] Minseok Jeon, Sehun Jeong, and Hakjoo Oh. 2018. Precise and Scalable
Points-to Analysis via Data-driven Context Tunneling. Proc. ACM
Program. Lang. 2, OOPSLA, Article 140 (Oct. 2018), 29 pages. https:
//doi.org/10.1145/3276510

[29] Minseok Jeon, Myungho Lee, and Hakjoo Oh. 2020.

Learning
Graph-Based Heuristics for Pointer Analysis without Handcrafting
Application-Specific Features. Proc. ACM Program. Lang. 4, OOPSLA,
Article 179 (nov 2020), 30 pages. https://doi.org/10.1145/3428247
[30] Minseok Jeon and Hakjoo Oh. 2022. Return of CFA: Call-Site Sensi-
tivity Can Be Superior to Object Sensitivity Even for Object-Oriented
Programs. Proc. ACM Program. Lang. 6, POPL, Article 58 (jan 2022),
29 pages. https://doi.org/10.1145/3498720

[31] Sehun Jeong, Minseok Jeon, Sung Deok Cha, and Hakjoo Oh. 2017.
Data-driven context-sensitivity for points-to analysis. PACMPL 1,
OOPSLA (2017), 100:1–100:28. https://doi.org/10.1145/3133924

16

Tian Tan and Yue Li

[32] George Kastrinis and Yannis Smaragdakis. 2013. Efficient and Effective
Handling of Exceptions in Java Points-to Analysis. In Compiler Con-
struction, Ranjit Jhala and Koen De Bosschere (Eds.). Springer Berlin
Heidelberg, Berlin, Heidelberg, 41–60.

[33] George Kastrinis and Yannis Smaragdakis. 2013. Hybrid context-
sensitivity for points-to analysis. In ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI ’13, Seattle,
WA, USA, June 16-19, 2013, Hans-Juergen Boehm and Cormac Flanagan
(Eds.). ACM, 423–434. https://doi.org/10.1145/2462156.2462191
[34] Martin Kellogg, Narges Shadab, Manu Sridharan, and Michael D. Ernst.
2022. Accumulation Analysis. In 36th European Conference on Object-
Oriented Programming (ECOOP 2022) (Leibniz International Proceedings
in Informatics (LIPIcs), Vol. 222), Karim Ali and Jan Vitek (Eds.). Schloss
Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl, Germany, 10:1–
10:30. https://doi.org/10.4230/LIPIcs.ECOOP.2022.10

[35] Patrick Lam, Eric Bodden, Ondřej Lhoták, and Laurie Hendren. 2011.
The Soot framework for Java program analysis: a retrospective. In
Cetus Users and Compiler Infrastructure Workshop (CETUS 2011). https:
//www.bodden.de/pubs/lblh11soot.pdf

[36] Butler W. Lampson. 1983. Hints for Computer System Design. In Pro-
ceedings of the Ninth ACM Symposium on Operating System Principles,
SOSP 1983, Bretton Woods, New Hampshire, USA, October 10-13, 1983,
Jerome H. Saltzer, Roy Levin, and David D. Redell (Eds.). ACM, 33–48.
https://doi.org/10.1145/800217.806614

[37] Butler W. Lampson. 2020. Hints and Principles for Computer System
Design. CoRR abs/2011.02455 (2020). arXiv:2011.02455 https://arxiv.
org/abs/2011.02455

[38] Ondřej Lhoták and Laurie Hendren. 2008. Evaluating the Benefits of
Context-Sensitive Points-to Analysis Using a BDD-Based Implemen-
tation. ACM Trans. Softw. Eng. Methodol. 18, 1, Article 3 (oct 2008),
53 pages. https://doi.org/10.1145/1391984.1391987

[39] Ondrej Lhoták and Laurie J. Hendren. 2003. Scaling Java Points-to
Analysis Using SPARK. In Compiler Construction, 12th International
Conference, CC 2003, Held as Part of the Joint European Conferences
on Theory and Practice of Software, ETAPS 2003, Warsaw, Poland, April
7-11, 2003, Proceedings (Lecture Notes in Computer Science, Vol. 2622),
Görel Hedin (Ed.). Springer, 153–169. https://doi.org/10.1007/3-540-
36579-6_12

[40] Ondrej Lhotak, Yannis Smaragdakis, and Manu Sridharan. 2013.
Pointer Analysis (Dagstuhl Seminar 13162). Dagstuhl Reports 3, 4
(2013), 91–113. https://doi.org/10.4230/DagRep.3.4.91

[41] Yue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. 2018.
Precision-guided Context Sensitivity for Pointer Analysis.
Proc.
ACM Program. Lang. 2, OOPSLA, Article 141 (Oct. 2018), 29 pages.
https://doi.org/10.1145/3276511

[42] Yue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. 2018.
Scalability-First Pointer Analysis with Self-Tuning Context-Sensitivity.
In Proc. 12th joint meeting of the European Software Engineering Con-
ference and the ACM SIGSOFT Symposium on the Foundations of Soft-
ware Engineering (ESEC/FSE). ACM, 129–140. https://doi.org/10.1145/
3236024.3236041

[43] Yue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. 2020. A
Principled Approach to Selective Context Sensitivity for Pointer Anal-
ysis. ACM Trans. Program. Lang. Syst. 42, 2, Article 10 (May 2020),
40 pages. https://doi.org/10.1145/3381915

[44] Yue Li, Tian Tan, Yulei Sui, and Jingling Xue. 2014. Self-inferencing
Reflection Resolution for Java. In ECOOP 2014 - Object-Oriented Pro-
gramming - 28th European Conference, Uppsala, Sweden, July 28 - Au-
gust 1, 2014. Proceedings (Lecture Notes in Computer Science, Vol. 8586),
Richard E. Jones (Ed.). Springer, 27–53. https://doi.org/10.1007/978-
3-662-44202-9_2

[45] Yue Li, Tian Tan, and Jingling Xue. 2015. Effective Soundness-Guided
Reflection Analysis. In Static Analysis - 22nd International Symposium,
SAS 2015, Saint-Malo, France, September 9-11, 2015, Proceedings (Lecture

Tai-e: A Static Analysis Framework for Java by Harnessing the Best Designs of Classics

Notes in Computer Science, Vol. 9291), Sandrine Blazy and Thomas
Jensen (Eds.). Springer, 162–180. https://doi.org/10.1007/978-3-662-
48288-9_10

[46] Yue Li, Tian Tan, Yifei Zhang, and Jingling Xue. 2016. Program Tai-
loring: Slicing by Sequential Criteria. In 30th European Conference on
Object-Oriented Programming, ECOOP 2016, July 18-22, 2016, Rome,
Italy (LIPIcs, Vol. 56), Shriram Krishnamurthi and Benjamin S. Lerner
(Eds.). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 15:1–15:27.
https://doi.org/10.4230/LIPIcs.ECOOP.2016.15

[47] Bozhen Liu and Jeff Huang. 2022. SHARP: Fast Incremental Context-
Sensitive Pointer Analysis for Java. Proc. ACM Program. Lang. 6,
OOPSLA1, Article 88 (apr 2022), 28 pages. https://doi.org/10.1145/
3527332

[48] Bozhen Liu, Jeff Huang, and Lawrence Rauchwerger. 2019. Rethinking
Incremental and Parallel Pointer Analysis. ACM Trans. Program. Lang.
Syst. 41, 1, Article 6 (March 2019), 31 pages. https://doi.org/10.1145/
3293606

[49] Benjamin Livshits and Monica S. Lam. 2005. Finding Security Vulner-
abilities in Java Applications with Static Analysis. In Proceedings of
the 14th USENIX Security Symposium, Baltimore, MD, USA, July 31 -
August 5, 2005, Patrick D. McDaniel (Ed.). USENIX Association.
[50] Jingbo Lu and Jingling Xue. 2019. Precision-Preserving yet Fast Object-
Sensitive Pointer Analysis with Partial Context Sensitivity. Proc. ACM
Program. Lang. 3, OOPSLA, Article 148 (Oct. 2019), 29 pages. https:
//doi.org/10.1145/3360574

[51] Yi Lu, Lei Shang, Xinwei Xie, and Jingling Xue. 2013. An Incremental
Points-to Analysis with CFL-Reachability. In Compiler Construction,
Ranjit Jhala and Koen De Bosschere (Eds.). Springer Berlin Heidelberg,
Berlin, Heidelberg, 61–81.

[52] Magnus Madsen, Ming-Ho Yee, and Ondřej Lhoták. 2016. From Dat-
alog to Flix: A Declarative Language for Fixed Points on Lattices. In
Proceedings of the 37th ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation (Santa Barbara, CA, USA) (PLDI ’16).
Association for Computing Machinery, New York, NY, USA, 194–208.
https://doi.org/10.1145/2908080.2908096

[53] Gianluca Mezzetti, Anders Møller, and Martin Toldam Torp. 2018. Type
Regression Testing to Detect Breaking Changes in Node.js Libraries.
In Proc. 32nd European Conference on Object-Oriented Programming
(ECOOP).

[54] Ana Milanova, Atanas Rountev, and Barbara G. Ryder. 2005. Parameter-
ized object sensitivity for points-to analysis for Java. ACM Trans. Softw.
Eng. Methodol. 14, 1 (2005), 1–41. https://doi.org/10.1145/1044834.
1044835

[55] Marcus Nachtigall, Michael Schlichtig, and Eric Bodden. 2022. A
Large-Scale Study of Usability Criteria Addressed by Static Analysis
Tools. In Proceedings of the 31st ACM SIGSOFT International Symposium
on Software Testing and Analysis (Virtual, South Korea) (ISSTA 2022).
Association for Computing Machinery, New York, NY, USA, 532–543.
https://doi.org/10.1145/3533767.3534374

[56] Mayur Naik, Alex Aiken, and John Whaley. 2006. Effective static race
detection for Java. In Proceedings of the ACM SIGPLAN 2006 Conference
on Programming Language Design and Implementation, Ottawa, Ontario,
Canada, June 11-14, 2006, Michael I. Schwartzbach and Thomas Ball
(Eds.). ACM, 308–319. https://doi.org/10.1145/1133981.1134018
[57] Benjamin Barslev Nielsen, Martin Toldam Torp, and Anders Møller.
2021. Modular Call Graph Construction for Security Scanning of
Node.js Applications. In Proc. 30th International Symposium on Software
Testing and Analysis (ISSTA).

[58] Michael Pradel, Ciera Jaspan, Jonathan Aldrich, and Thomas R. Gross.
2012. Statically checking API protocol conformance with mined multi-
object specifications. In 34th International Conference on Software En-
gineering, ICSE 2012, June 2-9, 2012, Zurich, Switzerland, Martin Glinz,
Gail C. Murphy, and Mauro Pezzè (Eds.). IEEE Computer Society, 925–
935. https://doi.org/10.1109/ICSE.2012.6227127

17

[59] Sazzadur Rahaman, Ya Xiao, Sharmin Afrose, Fahad Shaon, Ke Tian,
Miles Frantz, Murat Kantarcioglu, and Danfeng (Daphne) Yao. 2019.
CryptoGuard: High Precision Detection of Cryptographic Vulnerabil-
ities in Massive-Sized Java Projects. In Proceedings of the 2019 ACM
SIGSAC Conference on Computer and Communications Security (London,
United Kingdom) (CCS ’19). Association for Computing Machinery,
New York, NY, USA, 2455–2472. https://doi.org/10.1145/3319535.
3345659

[60] Michael Reif, Florian Kübler, Michael Eichberg, Dominik Helm, and
Mira Mezini. 2019. Judge: identifying, understanding, and evaluating
sources of unsoundness in call graphs. In Proceedings of the 28th ACM
SIGSOFT International Symposium on Software Testing and Analysis,
ISSTA 2019, Beijing, China, July 15-19, 2019, Dongmei Zhang and An-
ders Møller (Eds.). ACM, 251–261. https://doi.org/10.1145/3293882.
3330555

[61] Caitlin Sadowski, Edward Aftandilian, Alex Eagle, Liam Miller-Cushon,
and Ciera Jaspan. 2018. Lessons from Building Static Analysis Tools
at Google. Commun. ACM 61, 4 (mar 2018), 58–66. https://doi.org/10.
1145/3188720

[62] Philipp Dominik Schubert, Ben Hermann, and Eric Bodden. 2019.
PhASAR: An Inter-procedural Static Analysis Framework for C/C++. In
Tools and Algorithms for the Construction and Analysis of Systems - 25th
International Conference, TACAS 2019, Held as Part of the European Joint
Conferences on Theory and Practice of Software, ETAPS 2019, Prague,
Czech Republic, April 6-11, 2019, Proceedings, Part II (Lecture Notes in
Computer Science, Vol. 11428), Tomás Vojnar and Lijun Zhang (Eds.).
Springer, 393–410. https://doi.org/10.1007/978-3-030-17465-1_22
[63] Philipp Dominik Schubert, Ben Hermann, Eric Bodden, and Richard
Leer. 2021. Into the Woods: Experiences from Building a Dataflow
Analysis Framework for C/C++. In SCAM ’21: IEEE International Work-
ing Conference on Source Code Analysis and Manipulation (Engineering
Track). To appear.

[64] Olin Shivers. 1991. Control-flow analysis of higher-order languages.

Ph.D. Dissertation. Carnegie Mellon University.

[65] Yannis Smaragdakis and George Balatsouras. 2015. Pointer Analysis.
Foundations and Trends in Programming Languages 2, 1 (2015), 1–69.
https://doi.org/10.1561/2500000014

[66] Yannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. 2011.
Pick your contexts well: understanding object-sensitivity. In Pro-
ceedings of the 38th ACM SIGPLAN-SIGACT Symposium on Princi-
ples of Programming Languages, POPL 2011, Austin, TX, USA, Jan-
uary 26-28, 2011, Thomas Ball and Mooly Sagiv (Eds.). ACM, 17–30.
https://doi.org/10.1145/1926385.1926390

[67] Yannis Smaragdakis, George Kastrinis, and George Balatsouras. 2014.
Introspective analysis: context-sensitivity, across the board. In ACM
SIGPLAN Conference on Programming Language Design and Imple-
mentation, PLDI ’14, Edinburgh, United Kingdom - June 09 - 11, 2014,
Michael F. P. O’Boyle and Keshav Pingali (Eds.). ACM, 485–495.
https://doi.org/10.1145/2594291.2594320

[68] SpotBugs. 2018. Find bugs in Java Programs. https://spotbugs.github.

io.

[69] Manu Sridharan and Rastislav Bodík. 2006. Refinement-based context-
sensitive points-to analysis for Java. In Proceedings of the ACM SIG-
PLAN 2006 Conference on Programming Language Design and Im-
plementation, Ottawa, Ontario, Canada, June 11-14, 2006, Michael I.
Schwartzbach and Thomas Ball (Eds.). ACM, 387–400. https://doi.org/
10.1145/1133981.1134027

[70] Manu Sridharan, Satish Chandra, Julian Dolby, Stephen J. Fink, and
Eran Yahav. 2013. Alias Analysis for Object-Oriented Programs. In
Aliasing in Object-Oriented Programming. Types, Analysis and Verifi-
cation, Dave Clarke, James Noble, and Tobias Wrigstad (Eds.). Lec-
ture Notes in Computer Science, Vol. 7850. Springer, 196–232. https:
//doi.org/10.1007/978-3-642-36946-9_8

[71] Manu Sridharan, Stephen J. Fink, and Rastislav Bodík. 2007. Thin
slicing. In Proceedings of the ACM SIGPLAN 2007 Conference on Pro-
gramming Language Design and Implementation, San Diego, California,
USA, June 10-13, 2007, Jeanne Ferrante and Kathryn S. McKinley (Eds.).
ACM, 112–122. https://doi.org/10.1145/1250734.1250748

[72] Tamás Szabó, Gábor Bergmann, Sebastian Erdweg, and Markus Voelter.
2018. Incrementalizing Lattice-Based Program Analyses in Datalog.
Proc. ACM Program. Lang. 2, OOPSLA, Article 139 (oct 2018), 29 pages.
https://doi.org/10.1145/3276509

[73] Tian Tan, Yue Li, Xiaoxing Ma, Chang Xu, and Yannis Smaragdakis.
2021. Making Pointer Analysis More Precise by Unleashing the Power
of Selective Context Sensitivity. Proc. ACM Program. Lang. 5, OOPSLA,
Article 147 (oct 2021), 27 pages. https://doi.org/10.1145/3485524
[74] Tian Tan, Yue Li, and Jingling Xue. 2016. Making k-Object-Sensitive
Pointer Analysis More Precise with Still k-Limiting. In Static Analysis
- 23rd International Symposium, SAS 2016, Edinburgh, UK, September
8-10, 2016, Proceedings (Lecture Notes in Computer Science, Vol. 9837),
Xavier Rival (Ed.). Springer, 489–510. https://doi.org/10.1007/978-3-
662-53413-7_24

[75] Tian Tan, Yue Li, and Jingling Xue. 2017. Efficient and precise points-
to analysis: modeling the heap by merging equivalent automata. In

Tian Tan and Yue Li

Proceedings of the 38th ACM SIGPLAN Conference on Programming
Language Design and Implementation, PLDI 2017, Barcelona, Spain,
June 18-23, 2017, Albert Cohen and Martin T. Vechev (Eds.). ACM,
278–291. https://doi.org/10.1145/3062341.3062360

[76] Frank Tip. 1995. A survey of program slicing techniques. J. Prog. Lang.
3, 3 (1995). http://compscinet.dcs.kcl.ac.uk/JP/jp030301.abs.html
[77] Raja Vallée-Rai, Phong Co, Etienne Gagnon, Laurie J. Hendren, Patrick
Lam, and Vijay Sundaresan. 1999. Soot - a Java bytecode optimiza-
tion framework. In Proceedings of the 1999 conference of the Centre for
Advanced Studies on Collaborative Research, November 8-11, 1999, Mis-
sissauga, Ontario, Canada, Stephen A. MacKay and J. Howard Johnson
(Eds.). IBM, 13. https://doi.org/10.1145/781995.782008
[78] WALA. 2018. Watson Libraries for Analysis. http://wala.sf.net.
[79] John Whaley and Monica S. Lam. 2004. Cloning-based Context-
sensitive Pointer Alias Analysis Using Binary Decision Diagrams. In
Proceedings of the ACM SIGPLAN 2004 Conference on Programming
Language Design and Implementation (Washington DC, USA) (PLDI
’04). ACM, New York, NY, USA, 131–144. https://doi.org/10.1145/
996841.996859

[80] YAML. [n.d.]. https://yaml.org/.

18

