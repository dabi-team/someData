Noname manuscript No.
(will be inserted by the editor)

The Sense of Logging in the Linux Kernel

Keyur Patel · Jo˜ao Faccin · Abdelwahab
Hamou-Lhadj · Ingrid Nunes

2
2
0
2

g
u
A
3
1

]
E
S
.
s
c
[

1
v
0
4
6
6
0
.
8
0
2
2
:
v
i
X
r
a

Received: date / Accepted: date

Abstract Logging plays a crucial role in software engineering because it is key to
perform various tasks including debugging, performance analysis, and detection of
anomalies. Despite the importance of log data, the practice of logging still suﬀers
from the lack of common guidelines and best practices. Recent studies investigated
logging in C/C++ and Java open-source systems. In this paper, we complement
these studies by conducting the ﬁrst empirical study on logging practices in the
Linux kernel, one of the most elaborate open-source development projects in the
computer industry. We analyze 22 Linux releases with a focus on three main as-
pects: the pervasiveness of logging in Linux, the types of changes made to logging
statements, and the rationale behind these changes. Our ﬁndings show that logging
code accounts for 3.73% of the total source code in the Linux kernel, distributed
across 72.36% of Linux ﬁles. We also found that the distribution of logging state-
ments across Linux subsystems and their components vary signiﬁcantly with no
apparent reasons, suggesting that developers use diﬀerent criteria when logging.
In addition, we observed a slow decrease in the use of logging—reduction of 9.27%
between versions v4.3 and v5.3. The majority of changes in logging code are made
to ﬁx language issues, modify log levels, and upgrade logging code to use new log-
ging libraries, with the overall goal of improving the precision and consistency of
the log output. Many recommendations are derived from our ﬁndings such as the
use of static analysis tools to detect log-related issues, the adoption of common
writing styles to improve the quality of log messages, the development of conven-
tions to guide developers when selecting log levels, the establishment of review
sessions to review logging code, and so on. Our recommendations can serve as a
basis for developing logging guidelines as well as better logging processes, tools,
and techniques.

K. Patel and A. Hamou-Lhadj
Concordia University, Montreal, CA
E-mail: {keyur.patel,wahab.hamou-lhadj}@concordia.ca

J. Faccin and I. Nunes
Universidade Federal do Rio Grande do Sul (UFRGS), Porto Alegre, BR
E-mail: {jgfaccin,ingridnunes}@inf.ufrgs.br

 
 
 
 
 
 
2

Keyur Patel et al.

Keywords Linux Kernel · Software Logging · Empirical Studies · Software
Engineering

1 Introduction

Software logging is a practice that has long been used by developers to record
valuable runtime information (e.g., events and data) about a running system (Yuan
et al. 2012b; Pecchia et al. 2015; Miranskyy et al. 2016). These records are in the
form of log messages, which are generated by logging statements in the source
code. Studies have shown that the analysis of log data can help with many tasks,
including debugging and diagnosis of system failures (Khatuya et al. 2018; El-
Masri et al. 2020), detection of security vulnerabilities (Yen et al. 2013; Zhou
et al. 2020), proﬁling of distributed systems (Pi et al. 2018), troubleshooting cloud
computing environments (Kc and Gu 2011; Miranskyy et al. 2016), detection of
anomalies (Bertero et al. 2017; Islam et al. 2018; Oliner et al. 2008), and reliability
evaluation of applications (Tian et al. 2004).

Despite the importance of log analysis, the practice of logging remains largely
ad-hoc with no recognized guidelines and systematic processes (Yuan et al. 2012a;
Fu et al. 2014; Pecchia et al. 2015). Software developers continue to insert logging
statements in the source code without clear and suﬃcient guidance. The decisions
on how and where to log are often left to the discretion of the developers, resulting
in inconsistencies even among developers working on the same projects. In a study
performed at Microsoft (Zhu et al. 2015), the authors showed that 68% of the
participants (mainly Microsoft developers) found it challenging to make decisions
on how and where to log. The lack of systematic and automated approaches for
logging raises serious questions as to the validity of the generated log data as well
as the eﬃcacy of existing log analytic tools, which may impede failure diagnosis
and other log-related tasks, threatening the stability of deployed software systems.
There exist studies that investigate the practice of logging in software engi-
neering (e.g., (Zhou et al. 2020; Yuan et al. 2012a; Chen and Jiang 2017b; Zhu
et al. 2015; Zeng et al. 2019)). Yuan et al. (2012a) made the ﬁrst characterization
of logging practices in open-source projects. The authors studied logging practices
in four server-side C/C++ projects and provided many ﬁndings with respect to
the pervasiveness of logging code, how often logging code is changed, and what
kind of changes are made to it. Chen and Jiang (2017b) conducted an extensive
replication study of this work with a focus on open-source projects written in Java.
These studies revealed many issues related to the practice of logging. For exam-
ple, they showed that software developers use logging in an inconsistent way. In
addition, they showed that developers often have to change logging code in subse-
quent versions of the system as afterthoughts, adding to the maintenance burden
of software systems.

In this paper, we build on these studies by conducting the ﬁrst empirical study
to understand the practice of logging in the Linux kernel. Linux is perhaps one
of the greatest collaborative eﬀorts in the computer industry with more than a
thousand experienced developers contributing to its growth on a regular basis.
Many studies have examined the structure and evolution of the Linux kernel from
diﬀerent perspectives (Bagherzadeh et al. 2018; Israeli and Feitelson 2010; Lotufo
et al. 2010; Passos et al. 2012; Lu et al. 2014; Fadel 2011), but little is known

The Sense of Logging in the Linux Kernel

3

about the logging practices followed by Linux kernel developers. Existing Linux
development guidelines do not include guidelines for making logging decisions.

Similarly to previous studies (Yuan et al. 2012a; Chen and Jiang 2017b), we
explore three main aspects related to the practice of logging: (1) the pervasiveness
of logging in Linux, (2) the types of changes made to logging statements over
several releases, and (3) the rationale underlying changes to logging code. From
this perspective, this is a replication study with a focus on the Linux kernel.
Because Linux developers are considered as experienced developers, understanding
how they log their code provides useful insights into the practice of logging in
software engineering, further contributing to the corpus of knowledge in this area.
Our ﬁndings show that there is a logging statement for every 27 lines of code
in Linux v5.3 (the latest version when we collected data for this study). The
pervasiveness of logging, however, varies from one kernel subsystem to another,
with ﬁlesystem and drivers being the most logged subsystems. After investigating
changes made to logging statements across 22 releases of Linux, we found that
developers tend to modify logging code to improve the quality of the logging output
by enhancing precision, conciseness, and consistency. By means of a qualitative
analysis of 900 commits that target ﬁxes and improvements of logging code, we
found that the reasons behind these changes are similar to those reported by other
studies (Hassani et al. 2018; Yuan et al. 2012a; Chen and Jiang 2019, 2017a),
such as ambiguous log messages, redundant information and logging the wrong
variables. We also found many issues that pertain to the Linux kernel such as
revealing vulnerable data and problems related to early logging. Based on these
results, we derive many recommendations that are not only applicable to Linux,
but can be readily generalized to other software systems. Our long-term goal is
to help design better processes, techniques, and tools for eﬀective logging, and set
the groundwork for establishing logging standards.

In summary, the main contributions of our work are listed as follows.

– We study the pervasiveness of logging in the Linux kernel. To our knowledge,

this is the ﬁrst study that focuses on the practice of logging in Linux.

– We present a study that shows the evolution of logging statements in 22 releases

of the Linux kernel.

– We study the rationale behind changes made to logging statements across

multiple releases of the kernel.

– Based on the analysis of afterthought changes to logging code in the Linux
kernel, we derive several guidelines that can help the maintenance of logging
code in Linux. These guidelines can possibly be applied to other systems as
well.

This study can beneﬁt researchers and practitioners interested in understand-
ing and improving the practice of logging in software engineering. The ultimate
objective is to better deﬁne guidelines and processes for logging software systems.
Additionally, Linux developers can directly refer to the ﬁndings of this paper to
develop better logging practices for Linux.

The remainder of this paper is structured as follows. We discuss existing work
related to logging in Section 2. Next, we present our study design in Section 3.
The results obtained with the analysis of logging practices in the Linux kernel are
presented in Section 4. In Section 5, we discuss our ﬁndings and implications as
well as threats to validity. Finally, we conclude the paper in Section 6.

4

2 Related Work

Keyur Patel et al.

In this section, we review existing studies on the practice of logging (i.e., how to
log). We also review related studies on what and where to log. We discuss how
these studies diﬀer from ours at the end of the section.

2.1 Research Studies on the Practice of Logging

In an attempt to understand the characteristics of software logging in open-source
projects, Yuan et al. (2012a) conducted one of the ﬁrst studies that examines
the practice of software logging by mining the evolution history of four C/C++
projects (Apache httpd, OpenSSH, PostgreSQL, and Squid). The authors found
that logging statements account for 3.30% of the source code. They also reported
that developers often ﬁnd it challenging to get logging statements right at the
ﬁrst try. They showed that developers changed 36% of all log messages at least
once as afterthoughts. The changes are categorized as changes to verbosity level,
static content, and variables. They observed that 75% of log modiﬁcations of the
static content of the logs consist of ﬁxing inconsistent and confusing log messages.
Additionally, the authors showed that developers often struggle to use the right
verbosity level. To address this problem, they designed a simple verbosity level
checker. Chen and Jiang (2017b) conducted a replication study of the work of
Yuan et al. (2012a) with the objective to understand the practice of logging in
Java systems. Their ﬁndings diﬀer in many aspects from the original study. For
example, they found that consistency updates account for 41% of all the logging
code updates. These updates are much more present in C/C++ project and rep-
resent 67% of the logging code updates.

Pecchia et al. (2015) investigated the practice of logging on the development
process of critical software systems in industry. They identiﬁed three main rea-
sons for using logging code: state dump, execution tracing, and event reporting.
They found that the logging practice lacks standardization over key-value rep-
resentations and missing contextual information, which hinders the adoption of
automated log analysis tools.

Shang et al. (2014) conducted a study on one large open-source and one indus-
trial software system to explore the evolution of logging statements (referred to as
communicated information) by mining the execution logs of these systems. They
found that logging statements change across versions, impacting log processing
applications. They also showed that the use of advanced log analysis techniques
can reduce the impact of these changes on log preprocessing tools.

Zeng et al. (2019) focused on understanding the practice of logging in Android
apps. Their ﬁndings suggest that there are diﬀerences between logging practices
observed in mobile apps when compared to desktop and server applications. They
provided evidence that logging code in mobile apps is less pervasive and not main-
tained as actively as in desktop and server applications.

The analysis of two open-source software systems conducted by Shang et al.
(2015) showed a relationship between post-release defects and some log-related
metrics. This study suggests that more maintenance eﬀort should be devoted to
ﬁles with logging code as they are more susceptible to contain problems.

The Sense of Logging in the Linux Kernel

5

The quality of logging code was investigated by Hassani et al. (2018). The
authors characterized log-related issues using the number of ﬁles involved in an
issue, the time required to ﬁx it, and who provides the ﬁx. In addition, they
manually examined log-related issues to identify common problems associated with
logging code, which served as the basis for developing a tool to automatically detect
problems such as spelling errors and empty catch blocks.

Cinque et al. (2010) conducted a quantitative study in which they assessed
the eﬀectiveness of logging mechanisms to generate logs when a fault is triggered.
They injected faults in three open-source systems and observed whether faults
that lead to failures generate logs or not. The authors found that the percentage
of logged failures ranges between 35.6% and 42.1% among the three systems they
used in the case study. Their experimental results are then exploited to suggest
places where to place additional logs based on the analysis of memory dumps.

Recently, Li et al. (2020) conducted a qualitative study to understand the ben-
eﬁts of software logging and the costs associated with it by surveying 66 developers
and examining 223 logging-related issue reports. The found that developers do not
have a systematic strategy for reconciling the beneﬁt and cost of logging. The au-
thors argued that the lack of clear strategies may lead to logging practices with a
negative impact.

Li et al. (2017) proposed a predictive model that suggests the most appropriate
log levels for new logging statements based on features such as the average log level
and log churn. This is important in light of the ﬁndings of
(Yuan et al. 2012a;
Chen and Jiang 2017b; Hassani et al. 2018) who showed that developers have
diﬃculties determining the correct log level to be used.

Chen and Jiang (2017a) analyzed many code-independent log updates from
three open-source Java projects and identiﬁed ﬁve logging anti-patterns. A tool,
called LCAnalyzer, was developed to allow the automatic identiﬁcation of these
poor logging practices.

Zhou et al. (2020) investigated the impact of logging practices on data leakage
with a focus on Android mobile applications. They studied logging code in 5,000
mobile apps and showed using taint analysis that out of 276 apps with taint ﬂow
paths, 200 (72%) leaked sensitive data due to poor logging practices such as for-
getting to remove debug logging statements before deployment. They categorized
the types of data leakage that are related to logging practices into four types:
network, account, location, database. They manually analyzed source-sing paths
of log-related taint ﬂow paths of the 200 apps and found that 49% of the data that
is leaked is network-related, followed by database sensitive data (45%).

2.2 Studies on where and what to log

Fu et al. (2014) performed an empirical investigation on enterprise applications
written in C# in order to understand where developers insert logging statements.
The authors found that logging statements can be grouped based on where they are
inserted in the code using these categories: assertion-check logging, return-value-
check logging, exception logging, logic-branch logging, and observing-point logging.
They also found that 39%–53% of logging statements are placed to capture infor-
mation when the software fails while 47%–61% of logging statements are used to
trace the normal execution ﬂow. To complement their ﬁndings, the authors trained

6

Keyur Patel et al.

a decision tree model that suggests where to log based on contextual keywords ex-
tracted from code snippets. Their recommendation tool achieved a precision of
81.1%–90.2%, and recall of 80.8%–90.4%. A similar tool, called LogAdvisor, was
proposed by Zhu et al. (2015). The tool aims to help developers by providing
suggestions on where to log with an accuracy of 84.6%–93.4%.

In their position paper, Zhao et al. (2017) proposed a strategy for automatically
placing logs in the source code using information theory concepts by measuring
the software’s uncertainty using Shannon Entropy. Their approach respects a pre-
deﬁned performance overhead (less than 2%). The idea is to place logs in execution
paths that reduce uncertainty. The approach was tested on a small example. The
authors stated that the preliminary results show that their approach holds real
promise for automating the placement of logging statements. The problem with
this technique, however, is that it is completely agnostic to the semantic of the
code blocks that are being logged. It simply adds logs in paths that would most
likely be executed. The authors did not discuss the quality of the generated logging
statements when used for debugging and other tasks.

Yang et al. (2018) proposed NanoLog, a logging mechanism that is 1–2 or-
ders of magnitude faster than existing logging systems and that achieves a high
throughout (80 million log messages per second), while exposing the traditional
printf-like statements. NanoLog modiﬁes the log messages at compile-time, and
uses compaction techniques to output logs in a compact binary format. The au-
thors showed that their approach can improve the performance of log analytic
tools.

Because there is no standard way to know what information should be included
in logs, developers insert logging statements into the code in an ad-hoc manner.
Sometimes, the information from these logs may be insuﬃcient to diagnose soft-
ware failures. To handle this issue, Yuan et al. (2012b) designed LogEnhancer a
tool that can infer what information could be helpful to narrow down the root
cause of failures and to include that information into existing logging code au-
tomatically. To help developers decide which variables should be included in the
logging statements, a recent study by Liu et al. (2019) proposed a recurrent neural
network-based model. The work of He et al. (2018) also focuses on what to log, with
the objective to understand the goal of the static text used in these statements.
Their results suggest that static text is used essentially for describing program
operation, error conditions, and high-level code semantics. They also proposed an
information retrieval approach for generating logging messages automatically.

Li et al. (2018) used topic modelling to understand whether there is any re-
lationship between topics of source code and having logging statements. Their
ﬁndings suggest that some source code topics are more likely to include logging
statements than others.

The single attempt to address the challenge of logging in Linux was made by
Tschudin et al. (2015). The authors proposed a machine learning-based approach
to suggest the most appropriate logging functions, using the evolution history of
the Linux kernel. However, the approach consists of a conceptual description of a
framework that still needs to be implemented and validated.

The Sense of Logging in the Linux Kernel

7

2.3 Discussion

Our study focuses on understanding the practice of logging adopted by Linux
developers. To our knowledge, this is the ﬁrst study that focuses on the Linux
kernel, which makes our study unique. To achieve our goal, we address the same
research questions on characterizing the practice of logging as the ones discussed
in related work (Yuan et al. 2012a; Chen and Jiang 2017b). In this sense, this
study can be considered as a replication study with a focus on the Linux kernel. It
complements the studies that aim to better understand of the practice of logging in
software development. We found that Linux developers tend to modify logging code
to improve the quality of the logging output by enhancing precision, conciseness,
and consistency. We also found that the reasons behind afterthought changes to
logging statements include to the ones reported in other studies (Hassani et al.
2018; Yuan et al. 2012a; Chen and Jiang 2019, 2017a). This conﬁrms the need
for better guidelines and processes for logging in software engineering. We derive
many recommendations from our study that can improve the logging practices in
Linux and other systems. Many of these can be implemented in tools such as the
ones discussed in the previous subsection to make suggestions to developers as
they write logging code.

3 Study Design

3.1 Research questions

Our goal is to characterize how logging is used in the Linux kernel so that we can
understand the adopted practices and identify the challenges. To achieve this goal,
we focus on answering the following research questions.

RQ1 What is the pervasiveness of logging in the Linux kernel?
RQ2 How does the logging code in the Linux kernel evolve?
RQ3 What are the causes other than keeping consistency in the code that lead

developers to change the logging code?

By answering RQ1, we aim to understand whether logging is a practice con-
sistently adopted by Linux kernel developers. This involves the analysis of the
location of logging statements to understand the rationale of why they are placed
in speciﬁc locations. In RQ2, we focus on investigating the lifecycle of logging state-
ments, i.e. when they are created, updated, or removed. By making such analyses,
we are able to understand the state of practice of the Linux kernel, that is, how
much logging exists in the code, how it is distributed, and its lifestyle. The goal is
to observe discrepancies in how logging is adopted so that we can raise questions
related to the adopted practices. Such questions can be the basis for future studies
to better understand logging decisions or to improve how logging is added and
maintained in the code.

These two research questions are similar to those answered in previous stud-
ies (Yuan et al. 2012a; Chen and Jiang 2017b). This would allow us not only to
understand these aspects in a project with distinguished characteristics but also
to contrast obtained results. These previous studies also further analyzed logging
changes to logging code, classifying them as consistent changes and afterthought

8

Keyur Patel et al.

changes. The former refers to changes that are due to changes in other parts of
the code that requires the logging code to be updated to keep consistency, for
example, when a variable referred to in a logging statement has its name changed.
Afterthought changes, in turn, are changes made to logging statements to ﬁx or im-
prove the logging statements for other purposes. In this paper, we investigate such
purposes in RQ3 to provide insights with respect to the eﬀort required to maintain
logging code. We aim to identify the reasons behind afterthought changes, which
we hope can help researchers and practitioners develop techniques to automatically
prevent, detect and automate such changes.

3.2 Subject project

The Linux kernel, our subject project, is a free and open-source software dis-
tributed under the GPLv21 license. It is responsible for managing the interactions
between hardware components and higher-level programs that use these compo-
nents. Used across a wide range of computer systems, from mobile devices and
server systems to supercomputers, the kernel can be considered as one of the most
important software projects in the computing industry. In fact, we are surrounded
by the Linux kernel in one way or another. Being developed by roughly ﬁfteen
thousand developers throughout its history, as of 2020, it contains around 18M
lines of C code. This project is continuously evolving to meet both hardware man-
ufacturers’ requirements and end-user expectations.

For RQ1, we study the pervasiveness of logging in version v5.3 (the last version
when doing this study). This version received 14,605 commits from 1,881 devel-
opers, adding 837,732 and removing 253,255 lines of code, which represents an
increase of 584,477 lines of code when compared to its previous version.2

To understand changes to logging code across various Linux releases and hence
answer RQ2 and RQ3, we need to select a number of releases to include in the
study. Our ﬁrst attempt was to cover ten years of development going back starting
from v5.3 (the last version when we conducted this study), but the amount of data
that was generated was simply too high to conduct a viable analysis, especially that
there is a lot of manual work to answer RQ3 and part of RQ2. We therefore decided
to focus on a smaller dataset without loss of generality by going back 20 releases
starting from v5.3. We settled for v4.33 to v5.34 (22 releases to be exact). This
corresponds to an interval of four years of software development, from November
2015 to September 2019. All releases used in this study are available in the oﬃcial
Linux kernel repository.5 We believe that this dataset is representative since our
objective is not to uncover all the problems related to logging in Linux but rather
to provide insight into the practice of logging in software development by looking
at how Linux developers (even in a narrower scope) use logging.

1 https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 https://github.com/gregkh/kernel-history/
3 https://github.com/torvalds/linux/commit/6a13feb9
4 https://github.com/torvalds/linux/commit/4d856f72
5 https://github.com/torvalds/linux

The Sense of Logging in the Linux Kernel

9

Table 1: Linux kernel architectural decomposition.

Subsystem Top level directories

core
ﬁlesystem
drivers
net
arch

init, block, ipc, kernel, lib, mm, virt
fs
crypto, drivers, sound, security
net
arch

3.2.1 Linux subsystems

In our analysis, we frequently refer to Linux subsystems. The Linux kernel con-
sists of ﬁve major subsystems;6 each covering particular aspects of the project. Ta-
ble 1 shows the system decomposition. The core subsystem is in charge of memory
management, inter-process communication, management of I/O operations, among
others. The ﬁlesystem subsystem is responsible for providing the ﬁle system in-
terface as well as individual ﬁle system implementations. The drivers subsystem
provides device and sound drivers as well as the implementation of cryptography
algorithms used within the system and other security-related code. Finally, the
net and arch subsystems are responsible for networking and architecture-speciﬁc
code, respectively.

3.2.2 Logging in the Linux kernel

Logging statements are used to record relevant information about a running sys-
tem. A logging statement usually comprises three elements: (i) the log level of
the event being recorded; (ii) a static message that describes that event; and,
optionally, (iii) values of variables related to the logged event. A log message is
typically generated by the execution of a function speciﬁcally created for that pur-
pose. These functions can be either project-speciﬁc or provided by external logging
libraries and frameworks.

The Linux kernel provides developers with its own set of logging functions. One
of the simplest ways to write a message to the kernel log buﬀer is by using the
printk() function. It is the kernel’s equivalent of printf(), with the diﬀerence
that it allows developers to specify the log level of the event being recorded (Corbet
et al. 2005). An example of a logging statement is as follows:

printk(KERN_ERR "Device initialized with return code %d\n", code);

where KERN ERR corresponds to the log level, "Device initialized with return
code %d\n" is the static message, and code is the corresponding variable. There
are eight log levels deﬁned in the Linux kernel, representing diﬀerent degrees of
severity (see Table 2). KERN WARNING is the default log level and is assigned to a
message in case no log level is speciﬁed when calling printk().

Additional sets of logging functions were introduced in the Linux kernel v1.3.983
with the aim of making logging statements more concise. These functions incor-

6 https://github.com/gregkh/kernel-history/blob/master/scripts/genstat.pl

10

Keyur Patel et al.

Table 2: The eight possible log levels deﬁned in the Linux kernel.

Log level

Description

System is unusable
An action must be taken immediately
Critical conditions
Error conditions

KERN EMERG
KERN ALERT
KERN CRIT
KERN ERR
KERN WARNING Warning conditions (default)
KERN NOTICE
KERN INFO
KERN DEBUG

Normal but signiﬁcant condition
Informational
Debug-level messages

Table 3: New sets of logging functions.

Log level

pr *() function dev *() function

KERN EMERG
KERN ALERT
KERN CRIT
KERN ERR
KERN WARNING
KERN NOTICE
KERN INFO
KERN DEBUG

pr emerg()
pr alert()
pr crit()
pr err()
pr warn()
pr notice()
pr info()
pr debug()

dev emerg()
dev alert()
dev crit()
dev err()
dev warn()
dev notice()
dev info()
dev dbg()

porate log levels in their names. Therefore, in order to log a debug or informa-
tional message, instead of using the printk() function with the KERN DEBUG and
KERN INFO levels as parameters, developers can use the pr debug() and pr info()
functions, respectively. Another family of functions speciﬁcally designed for device
drivers, e.g. dev dbg() and dev info(), automatically include device names in
their outputs, making it easier to identify the origin of log messages. Table 3 lists
both sets of functions and their corresponding log levels. Currently, some kernel
components present their own logging functions, which are able to generate mes-
sages with service-speciﬁc information. Examples include network device and TI
wl1251 drivers, which provide the netdev *() and wl1251 *() families of logging
functions, respectively.

3.3 Procedure

In this section, we detail how we collected logging data from the Linux kernel.
Figure 1 summarizes the tasks that were carried out. In the following subsections,
we describe how we (1) extracted logging statements from the target project; (2)
calculated metrics; (3) identiﬁed changes made to logging code between diﬀerent
versions; and (4) selected a subset of changes in logging statements to be analyzed.

The Sense of Logging in the Linux Kernel

11

Fig. 1: Overview of the study procedure.

3.3.1 Identiﬁcation of logging functions

Traditional approaches to automatically locate logging statements into the source
code rely on logging functions that are known in advance (e.g., Log4j in Java) or
use regular expressions looking for variations of the term “log”. Although these
methods have been successfully adopted in previous studies (Shang et al. 2015; Zhu
et al. 2015; Chen and Jiang 2017b; Yuan et al. 2012a), they are not applicable in the
context of the Linux kernel, which uses a wide variety of functions and macros for
logging purposes. It is common to ﬁnd situations in which customized calls to these
macros are implemented by particular services (e.g., _enter7, pr_pic_unimpl8).
Listing 1 shows an example. A macro named adsp dbg() is implemented with the
aim of ensuring the invocation of dev dbg() with a particular set of parameters
and formatting (lines 2–3) so that there is no need to specify such elements in
further calls (line 5). This type of logging statements cannot be detected unless
we know that adsp dbg() is a logging function.

1
2
3
4
5
6

[...]
#define adsp_dbg(_dsp, fmt, ...) \

dev_dbg(_dsp->dev, "%s: " fmt, _dsp->name, ##__VA_ARGS__)

[...]
adsp_dbg(dsp, "Wrote %zu bytes to %x\n", len, reg);
[...]

Listing 1: Logging macro deﬁned in /sound/soc/codecs/wm adsp.c.

To identify Linux logging functions and macros in our study, we take advan-
tage of the pattern-based method presented by Tschudin et al. (2015). The authors
proposed an identiﬁcation method that consists of three semantic patterns. These

7 https://github.com/torvalds/linux/blob/v5.3/fs/afs/internal.h#L1449
8 https://github.com/torvalds/linux/blob/v5.3/arch/x86/kvm/i8259.c#L37

RQ2Logging code modificationsRQ3RQ1/RQ2Linux kernel repositoryExtraction of commits between Linux kernelv4.3 and v5.3285,045commitsIdentification of changes to logging codeCode Revision 1Manual inspection14,427 commits with updates in logging statements4,323 commits withfixes/improvements to logging code900commitsExtraction of metricsCode Revision nDeleteUpdateInsertRandom samplingMetrics12

Keyur Patel et al.

patterns, although describing general properties when taken individually, are able
to correctly characterize logging functions when combined, yielding a low number
of false positives. The ﬁrst pattern states that logging functions should be called
at least once inside an if block that ends with a return statement. The second
pattern indicates that logging functions have at least one string argument, repre-
senting a log message. Finally, the third pattern requires logging functions to have
a variable number of arguments. Listing 2 shows how macro adsp dbg() satisﬁes
all three patterns and thus can be considered as a logging function.

1
2
3
4
5
6
7

[...]
if (val == 0) {

adsp_dbg(dsp, "Acked control ACKED at poll %u\n", i);
return 0;

}
[...]
adsp_dbg(dsp, "Wrote %zu bytes to %x\n", len, reg);

Listing 2: A logging macro deﬁned in /sound/soc/codecs/wm adsp.c that sat-
isﬁes the identiﬁcation patterns.

Although this approach yields good results, it might miss logging functions with
a ﬁxed number of arguments (e.g., PRINTK_29 and PRINTK_410). These functions
do not satisfy the third pattern. We therefore decided to relax the third pattern
by including logging functions that contain a ﬁxed number of arguments (i.e., the
ones that are not overloaded).

We have carefully reviewed the list of logging functions extracted with this
approach. Although we believe that this is a very comprehensive list of functions,
we cannot guarantee 100% coverage, which is a threat to internal validity of this
study. To mitigate this threat, we selected randomly 20 ﬁles and checked manually
their content to see if we missed any logging functions. We found that our list
covered all the logging functions invoked in these ﬁles. Further, we make the list
of logging functions (and the data used for RQ1, RQ2, and RQ3) available to
the community.11 Once we know which functions/macros are used for logging, we
write a script to detect all calls to these functions/macros to retrieve the speciﬁc
logging statements.

Another alternative to handle the problem of the many forms of log printing
functions caused by macros would be to expand macro deﬁnitions using a compiler
preprocessor (e.g., gcc -E). However, Tschudin et al. (2015) found that this ap-
proach may result in false positives because of the possibility of having non-logging
functions that contain calls to printk-like functions.

3.3.2 Logging code metrics

To assess the pervasiveness of logging in the Linux kernel, we consider four metrics,
summarized in Table 4. Similarly to previous studies (e.g., Yuan et al. (2012a)),
we extract the number of lines of source code (SLOC) and the number of lines

9 https://github.com/torvalds/linux/blob/v5.3/drivers/char/mwave/mwavedd.h#L79
10 https://github.com/torvalds/linux/blob/v5.3/drivers/char/mwave/mwavedd.h#L89
11 https://github.com/iamkeyur/linux-logging-2021

The Sense of Logging in the Linux Kernel

13

Table 4: Extracted metrics related to logging code.

Metric

Description

SLOC
LLOC
Log Density The number of lines of source code per logging statement
Log Ratio

Number of lines of source code excluding comments and empty lines
Number of lines of logging code

The percentage of number of lines of logging code per source line of code

of logging code (LLOC). We only included .c ﬁles in our analysis, that is, header
ﬁles were not taken into account. Comments and empty lines are discarded when
measuring SLOC. These metrics are collected considering diﬀerent levels of gran-
ularity: (i) overall system and subsystems; (ii) ﬁles; and (iii) program constructs.
The latter comprises functions as well as blocks of control statements, namely
do-while, if, else, else-if, for, switch, and while. We also compute the Log
Density (Yuan et al. 2012a; Chen and Jiang 2017b; Zeng et al. 2019) and Log
Ratio metrics (see Equations 1 and 2). The Log Density measures the number of
lines of source code per logging statement, whereas the Log Ratio measures the
number of logging statements per line of source code. For example, a log density
of 10 would mean that for every ten lines of code, there is one logging statement.
A log ratio of 0.2 means that 20% of the code consists of logging statements.

Log Density =

SLOC
LLOC

(1)

Log Ratio =

LLOC
SLOC

(2)

3.3.3 Detection of changes in logging statements

To understand how logging code evolves in the Linux kernel, we study three
types of modiﬁcations made to logging code—log insertion, log deletion, and log
update—similarly to previous work (Yuan et al. 2012a; Chen and Jiang 2017b;
Zeng et al. 2019). We further divide insertion and deletion of logging statements
into two categories: logging statements that are added or deleted along with the
addition or deletion of ﬁles. To retrieve changes to logging statements, we wrote a
script using the git rev-list command with --no-merges option to retrieve the
commits. Note that the --no-merges option omits commits with more than one
parent. This is necessary in order to avoid duplicate commits. For each commit, we
extract two adjacent versions of each ﬁle that are changed in the commit. We only
consider .c ﬁles. Then, to generate an edit script representing syntactic modiﬁca-
tions by inferring changes at the level of abstract syntax tree, we use GumTree,
which is the state-of-the-art AST diﬀerencing tool (Falleri et al. 2014). As result,
we found that 14,427 commits modiﬁed at least one logging statement, which are
those used to answer RQ2.

3.3.4 Selection of changes in logging statements

Considering the 14,427 commits used to answer RQ2, not all aim to provide ﬁxes
or improvements to logging code, which is the type of change in logging code

14

Keyur Patel et al.

that we are interested in to answer RQ3. To identify changes that were made
targeting logging code, previous studies (Hassani et al. 2018; Mazuera-Rozo et al.
2020) rely on a keyword-based approach by searching for commits that contain in
their message variations of the word “log”. This strategy may miss many commits
in Linux such as the one described above. To address this, the ﬁrst author of
this study manually examined all 14,427 commits by reading the commit titles
and messages. He identiﬁed 4,323 commits out of 14,427 commits that explicitly
discuss changes to logging statements. This task took several weeks to complete
and required multiple iterations. He then selected randomly 900 commits out of
4,323 for a qualitative analysis. This subset is statistically representative with a
conﬁdence level of 99% and a margin of error of ± 4% (Boslaugh 2012).

4 Results and Analysis

We followed the previously described study procedure and obtained the results
detailed in this section. We present and analyze the results by research question.

4.1 RQ1: Pervasiveness of logging in Linux kernel

To examine the pervasiveness of logging in the Linux kernel, we consider its lat-
est available version when we collected data for this study (v5.3). Based on the
introduced metrics, we quantitatively assess how logging statements are spread in
the code, considering four granularity levels: system (i.e., the entire Linux kernel),
subsystems, ﬁles, and programming constructs.

4.1.1 System and subsystem level

We ﬁrst report the values obtained for each metric (SLOC, LLOC, Log Density
and Log Ratio) considering the system and subsystems levels. Table 5 presents
the results. We found that from a total of 13,390,104 lines of source code, 498,897
(i.e., 3.73%) are lines of logging code. It is equivalent to a logging density of 27,
which means that for every 27 lines of source code in Linux there is one logging
statement. This ﬁnding is in line with the observations made by Yuan et al. (2012a)
who reported an average log density of 30 in the four C/C++ applications they
examined. This result, however, diﬀers from the study by Chen and Jiang (2017b)
who reported an average log density of 50 in the 21 Java applications they studied.
Although these results are not conclusive, they suggest that the language in which
the project is written as well as the application domain may aﬀect the prevalence
of logging statements in the source code. In addition, this gives evidence of the
relevance of logging code. Logging statements do not provide additional application
functionality and they, still, account for almost 4% of the written code in our target
system. Consequently, logging code should be maintained with the same practices
of code associated with other concerns. For example, developers should carefully
review logging code in code review.

When looking at each subsystem individually, we obtain heterogeneous results.
The log ratio ranges from 1.94% to 4.26%. A deeper look at the components of
the Linux subsystems shows important discrepancies. For example, we observe

The Sense of Logging in the Linux Kernel

15

Table 5: Summary of metrics collected from the Linux kernel and its subsystems.

Subsystem Component

SLOC

LLOC Log Density

Log Ratio

core

lib
kernel
mm
block
ipc
init
virt

106,577
208,000
86,921
31,846
6,468
2,935
16,839

459,586

2,296
4,396
1,940
713
13
192
184

9,734

ﬁlesystem

fs

840,527

35,780

drivers

net

arch

Total

drivers
sound
security
crypto

net

arch

9,358,913
765,988
57,974
52,888

384,269
19,673
1,192
835

10,235,763

405,969

746,263

1,107,992

14,490

32,924

13,390,131

498,897

46
47
45
45
498
15
92

47

23

24
39
49
63

25

52

34

27

2.15%
2.11%
2.23%
2.24%
0.20%
6.54%
1.09%

2.12%

4.26%

4.11%
2.57%
2.06%
1.58%

3.97%

1.94%

2.97%

3.73%

that the init component of core, which consists only of 2,935 SLOC, contains
192 lines of logging code (Log Ratio = 6.54%). This is considerably higher than
the other components. This may be explained by the fact the init component is
responsible for the initialization of the console and other key kernel services such
as the security framework, scheduler, memory allocation (Bootlin 2020). For these
services, it is important to log all possible errors in order to quickly debug potential
failures. However, the idea that critical components are logged the most does not
always hold. Take for example the ipc component from the core subsystem with
the highest log density (Log Density = 498). This component, which contains only
six ﬁles, is responsible for setting up the inter-process communication mechanisms
on which the kernel processes rely. Yet, despite being critical, this component is
the least logged.

Without further studies, we can only attribute these variations to the fact that
diﬀerent groups of developers are maintaining each subsystem, and there are no
recognized (or common) guidelines on how to log. This calls for future studies
to understand the rationale for adding a large amount of logging statements in
particular modules of the code considering diﬀerent goals, such as debugging or
auditing. It is important to understand when it is critical to have detailed logged
information, e.g. when a module have a speciﬁc role or is the target of frequent
changes. Moreover, given that logging can have a performance impact, certain
components may have a reduced number of logging statements due to that reason.

4.1.2 File level

Similarly to the study of Lal et al. (2015), we also calculate the log ratio at the
ﬁle level. Note that we do not use log density here due to the fact that many ﬁles
do not contain logging statements, and therefore this metric cannot be calculated

16

Keyur Patel et al.

because SLOC cannot be divided by zero. The log ratio provides a more accurate
measurement by assessing the pervasiveness of logging across Linux ﬁles. Figure 2
shows the collected data. We found that 94.34% of the total number of ﬁles in Linux
v5.3 have a log ratio between 0% and 10%. More precisely, 7,134 ﬁles (27.64%) do
not contain any logging statements, while a signiﬁcant number of ﬁles (66.70%)
have a log ratio greater than 0% and less than or equal to 10%. Files with a log ratio
greater than 10% account for only 5.66% of the total number of ﬁles. Figure 2 thus
highlights that the number of logging statements by ﬁle is a skewed distribution.
Having the majority of ﬁles with a few logging statements is expected because
many ﬁles may include code statements that can result in errors, and these are
typically logged. However, it is interesting to observe that there are ﬁles with a
substantial amount of logging statements. As discussed above, a qualitative study
focusing on these highly logged ﬁles could give directions why this occurs and is
needed. We, in particular, manually inspected 6 ﬁles with a log ratio close to 90%.
We found that they contain mostly debugging routines. For example, drivers/
scsi/qla4xxx/ql4_dbg.c contains functions to dump relevant information about
the Linux Host Adapter structure.

The analysis of this distribution by the Linux subsystems can be seen in Fig-
ure 3, which shows the distribution of ﬁles by subsystem according to their log
ratio. We can observe that 22%–44% of the ﬁles have no logging statements in
the subsystem ﬁles. This indicates that in some systems—core, net, and mainly
arch—the logging is concentrated in fewer ﬁles. Except ﬁlesystem, only a small
percentage of ﬁles (3%–5%) has a high log ratio, that is, having many logging
statements is an exception. This is not the case of ﬁlesystem, which has 11% of the
ﬁles with more than 10% of their code being logging statements. In all subsystems,
the majority (sometimes nearly half) of the ﬁles have at most 10% of their code
as logging statements, but contain at least one. Similarly to what was discussed
above, these diﬀerences cannot be explained without future studies.

4.1.3 Programming construct level

In this section, we measure the number of logging statements in program constructs
of the Linux kernel including functions, do-while, if, else, else-if, for, switch,
and while. Determining where logging statements are located can help understand
the purpose they serve. There exist studies that examine the location of logging
statements in the source code. In particular, the work by Pecchia et al. (2015)
measured the number of logging statements in the same program constructs as
those listed above. Their work targeted two large C/C++ industrial applications.
We followed the same approach and compared our results to theirs.

Table 6 shows the distribution of logging statements in the kernel functions.
We found that from a total of 476,522 functions, 352,045 (73.88%) do not have any
logging statements. For the remaining functions (26.12%), 88.28% of these have
the number of logging statements in the range of one to ﬁve. Less than 1% of the
functions have more than eight logging statements. Here, again, the distribution of
logging statements is skewed. But diﬀerently, we observe that the vast majority of
functions do not contain any logging statements at all. This shows that a relatively
low number of functions need to have their information recorded in logs.

Complementing this information, Figure 4 shows the distribution of logging
statements in diﬀerent program constructs. We found that 55.66% (168,539 out

The Sense of Logging in the Linux Kernel

17

Fig. 2: Value of log ratio at the ﬁle level (Total #ﬁles = 25,814).

Fig. 3: Distribution of ﬁles by subsystem based on the log ratio.

SubsystemLog Ratio = 0Log Ratio in (0, 0.1]Log Ratio > 0.1core0.380.570.05filesystem0.280.610.11drivers0.220.720.06net0.360.610.03arch0.440.510.060.380.280.220.360.440.570.610.720.610.510.050.110.060.030.0600.20.40.60.811.2corefilesystemdriversnetarchLog Ratio = 0Log Ratio in (0, 0.1]Log Ratio > 0.118

Keyur Patel et al.

Table 6: Number of functions that have a certain amount of logging statements.

#Logging Statements

#Functions

0
1
2
3
4
5
6
7
8
≥ 9

352,045 (73.88%)
64,553 (13.55%)
25,823 (5.42%)
12,432 (2.61%)
7,075 (1.48%)
4,432 (0.93%)
2,752 (0.58%)
1,902 (0.40%)
1,282 (0.27%)
4,226 (0.89%)

Total

476,522 (100.00%)

of 302,799) of logging statements are used inside the if block and 4,585 (1.51%)
are within else-if. Together, they represent 57.17% of the use of logging. These
results are similar to those of the study by Pecchia et al. (2015), who reported that
around 60% of the logging statements are used inside the if blocks. These logs
are typically used for logging errors after checking the return value of function
calls. The logging statements in the else block accounts for 4.16% (12,586 out
of total 302,799 logging statements). The switch block, which is another control
statement available in C, accounts for 6.05% of the total logging statements. The
logging statements used directly inside loop controls represent only 2.52% of the
logging statements. The logging statements used directly within functions (i.e.,
not in any of the program constructs) account for 30.10% of the total number of
logging statements. This suggests that the cyclomatic complexity of a function
may be related to the presence of logging statements. Given that developers may
need to understand when a function follows a particular path during the program
execution, they add logging to conditional constructs. However, this does not occur
within loops. This can be explained by the fact that adding a log statement to
a loop may generate a high number of log messages and slow down the function
performance.

4.1.4 RQ1: Summary

RQ1 - Findings. The log density in Linux v5.3 is 27, i.e., on average there is one
logging statement for every 27 lines of code. This is similar to the study of Yuan
et al. (2012a) on C/C++ systems, but diﬀerent from the result obtained by Chen
and Jiang (2017b) when working on Java projects. The logging code represents
3.73% of the entire source code, with ﬁlesystem and drivers being the most logged
subsystems with a log ratio of 4.26% and 3.97% and a log density of 23 and 25,
respectively. We found that 72.36% of the total number of ﬁles in the Linux kernel
have at least one logging statement. However, only 26.12% of the functions in
the Linux kernel have one or more logging statements. Further studies, such as
the work from Li et al. (2018), are needed in order to understand which topics
of source code are more likely to be logged. 57.17% of the logging statements are

The Sense of Logging in the Linux Kernel

19

Fig. 4: Distribution of logging statements across diﬀerent program constructs.

used within an if and else-if blocks, while 30.10% are used inside code blocks
in no particular program constructs.

RQ1 - Implications. The fact that logging code accounts for almost 4% of the
entire code base is a strong reason for developers to carefully review logging code
with the same rigour they use to review the other code. The discrepancies in the log
density of various Linux subsystems calls for future studies (with a protocol similar
to that by Fu et al. (2014)) to understand the goals of logging (e.g., debugging,
auditing, security, etc.) in the diﬀerent parts of the kernel. This study should be
extended to the ﬁle and function levels where the distribution of logging statements
is also heterogeneous with no apparent reason. Another implication of these results
is the need for common guidelines for logging to ensure that best logging practices
are followed. Finally, we suggest to study the correlation between code quality
(using metrics such as cyclomatic complexity) and the need for logging, which
may explain the fact the majority of logging code is found in if-else blocks.

4.2 RQ2: Logging code evolution

As shown in the previous section, logging is widespread in Linux—for every 27
lines of code, there is one line of logging code. Now, we focus on understanding

20

Keyur Patel et al.

(a) Log ratio

(b) Comparison of SLOC and LLOC

Fig. 5: Evolution of the use of logging code between Linux v4.3 and v5.3.

how the logging code evolves across various releases of the kernel in terms of size
as well as the type and the nature of changes.

4.2.1 Evolution of the size of logging code

We start by analyzing the logging code size by looking at two perspectives. First,
we observe how the proportion of logging code evolved, measured by the log ratio
metric. Second, we compare the evolution of SLOC and LLOC. The evolution
of the log ratio metric for the Linux system from v4.3 to v5.3 can be seen in
Figure 5a. We observe that it has been decreasing over the years. This can be
due to the addition of code that has fewer logging statements than the average
or the deletion of code that has more logging statements than the average. To
better understand this observed evolution, we complement this analysis with the
data shown in Figure 5b, which indicates how LLOC and SLOC, individually,
increased across the diﬀerent versions. SLOC and LLOC are normalized using
min-max normalization to fall in the [0, 1] interval.

The SLOC and LLOC curves shown in Figure 5b generally have a similar
behavior, except for versions v4.11 to v4.18. By going through the Linux ker-
nel changelogs, we found that these inconsistencies seem to be the result of the
addition/removal of drivers or ﬁlesystems, which contained a large amount of log-
ging code. The Linux kernel v4.12 added Intel atomisp camera drivers (commit
a49d253) and rtl8723bs sdio wiﬁ driver (commit 554c0a3a). These two changes in-
creased the number of logging statements by 6,103, which contributed to a sharp
increase in the number of lines of logging code. Similarly, we can see a sudden de-
crease in SLOC and LLOC between v4.16 and v4.18 releases. After inspecting the
Linux kernel v4.18 changelogs, we found that SLOC of the Linux kernel v4.18 was
smaller than its previous release, and that occurred just three times in the history
of the Linux kernel before the release of kernel v4.18. The reason for this can be
attributed to removal of the lustre ﬁlesystem (commit be65f9e) and the atomisp
driver (commit 51b8dc51), which earlier contributed to 10,442 logging statements.
As discussed earlier, the amount of logging statements within modules and ﬁles

The Sense of Logging in the Linux Kernel

21

varies. Consequently, the removal of particular parts of the system can largely
aﬀect the amount of logging code when compared to the rest of the code.

Considering both the log ratio and the number of lines of logging code, it is
thus possible to observe that, though the number of lines of code increased as
the Linux kernel evolved, the log ratio decreased. This can be due to a number
of reasons, such as the types of changes made in the analyzed Linux versions—as
it was discussed, diﬀerent subsystems have varying amounts of logging. This may
also be explained by the reliance on debugging and tracing tools, which can be
used to diagnose problems as shown by Corbet (2016) and Edge (2019). These
authors noticed an increase in the use of tracepoints rather than simple printk()
in recent versions of Linux. The term tracing is used here to show the ﬂow of
execution of speciﬁc program constructs, e.g., traces of routine calls, and system
calls (Hamou-Lhadj and Lethbridge 2002, 2004)). A discussion with one Linux
expert (see Section 5.2) conﬁrms this ﬁnding. We need to conduct further studies
including user studies with Linux developers to understand the real causes behind
this decline of logging code (see Section 5.3 on the implications for future research
for more discussion), including the identiﬁcation of the impact of the use of new
tools that capture runtime information automatically without the need for logging
statements added manually. It is relevant to understand what types of statements
are removed and what types of statements remain in the code.

Similarly to previous studies (Yuan et al. 2012a; Chen and Jiang 2017b; Zeng
et al. 2019; Li et al. 2019a), we calculate the ratio of the number of commits
that involve modiﬁcations to logging code (i.e., additions, deletions, or updates
to logging statements) to the total number of commits so that it is possible to
understand how often a source code revision involves a modiﬁcation to logging
code. Out a total of 285,045 commits, we found that 39,351 (14%) commits involve
modiﬁcations to logging code. This result compares to that of the study of Yuan
et al. (2012a) on C/C++ systems, who found that 18% of the commits they
studied involve log modiﬁcations. It is also similar to the results reported by Chen
and Jiang (2017b) who found that there are around 21% of such commits in
the studied Java systems. Some changes are expected because logging statements
should be kept consistent with the corresponding code. However, it is relevant to
understand why the logging statements change when this is not the case. This is
in fact investigated in our RQ3.

4.2.2 Types of modiﬁcations in logging statements

Given that logging code changes overtime, we now look at the types of modiﬁ-
cations that are made. Table 7 reports the number of logging statements added,
deleted, and updated across Linux versions v4.3 to v5.3. There are 211,437 log-
ging statement modiﬁcations, out of which 24.78% are log updates, 45.99% are log
insertions, and log deletions account for 29.23%. The drivers subsystem alone rep-
resents 86.60% of the total modiﬁcations made to logging code, followed by arch
(5.47%), and ﬁlesystem (3.74%). This is somewhat expected because the drivers
subsystem is considerably larger (over 10 million SLOC) than the other subsystems
(see Table 5). In addition, drivers are typically dynamic in operating systems. As
new devices are released or become obsolete, the operating system must be evolved
accordingly. Consequently, some of these modiﬁcations to the logging statements

22

Keyur Patel et al.

Table 7: Distribution of modiﬁcations made to logging statements.

Subsystem Insertion Deletion Update

arch
core
driver
fs
net

Total
Percentage

3,987
1,863
87,125
2,776
1,490

97,241
45.99%

4,620
647
53,235
1,626
1,677

2,962
1,700
42,748
3,502
1,479

61,805
29.23%

52,391
24.78%

may be not due to changes speciﬁcally done on these statements, but to the ad-
dition or deletion of drivers. Moreover, as discussed in our RQ1, drivers typically
include much logging code. This justiﬁes why the drivers subsystem is associated
with the vast majority of modiﬁcation on logging code.

The percentage of log additions in Linux is similar to that reported by Chen
and Jiang (2017b), who showed that log additions contribute to 18%–41% of the
total log modiﬁcations. Yuan et al. (2012a) did not report the percentage of log
additions in their examination of C/C++ systems.

We found that the number of log deletions represents 29.23% of the total num-
ber of modiﬁcations made to logging statements. This result diﬀers signiﬁcantly
from the work of Yuan et al. (2012a) who reported that the number of log dele-
tions is only 2% of the total number of modiﬁcations. Our result is similar to that
of Chen and Jiang (2017b) who reported that log deletion contributes to 26% of the
total modiﬁcations in Java systems. Such evolution of logging code may adversely
impact the bug triaging process as developers rely on the logs contained in the bug
reports, as noted by Ran (2019). The authors found that it is not possible to re-
build the execution paths for bug reproduction from bug report logs in 34% cases.
They also argued that the continuous evolution of system logs can have an eﬀect
on the accuracy of log processing tools and machine learning models deployed for
identifying anomalous activities, as models need to be retrained whenever logging
statements are changed.

To drill down into the data, we grouped log additions and deletions into two
categories: added along with the addition of a new ﬁle and deleted along with
the deletion of an existing ﬁle. Table 8 shows a detailed breakdown. We found
that 55.77% of all log insertions were made along with the addition of new ﬁles.
Similarly, we found that 55.34% of the deleted logging statements were deleted
along with the deletion of existing ﬁles. These data corroborate with our hypothesis
of why the drivers subsystem accounts for many modiﬁcation on logging code.
These type of changes—that is, addition and deletion of ﬁles—have in fact a large
impact in the log ratio, as shown in Figure 5.

4.2.3 Updates in logging statements

We now proceed to a deeper analysis of logging changes, analyzing how log state-
ments are updated. We classify log updates into three categories depending on
which part of the logging statement has been modiﬁed: (i) the logging function (or

The Sense of Logging in the Linux Kernel

23

Table 8: Impact of adding or deleting ﬁles on logging code.

Subsystem Additions in new ﬁles Deletions in a deleted ﬁles

arch
core
driver
fs
net

Total

1,289
614
51,178
833
320

3,038
84
30,452
409
218

54,234
55.77% of the additions

34,201
55.34% of the deletions

Table 9: Distribution of updates made to logging statements.

Subsystem

Logging function Static content Dynamic content

arch
core
driver
fs
net

Total
% of updates

1,226
606
15,685
1,344
435

19,296
36.83%

2,014
979
23,127
2,422
809

29,351
56.02%

1,284
721
28,501
1,863
952

33,321
63.60%

macro), including the log level, (ii) the static content representing the log message,
and (iii) the dynamic content, i.e. the variables and function calls. Table 9 presents
the results. Note that one update may consist of one or more changes to the same
logging statement. For example, if the log function and the static content of a
logging statement has changed, they appear as two updates. This explains why
the total number of log updates is higher than the total number of the updated
logging statements. We next analyze the diﬀerent categories of updates.

Changes made to the logging function. Of the 52,391 updated logging statements,
19,296 (36.83%) include modiﬁcations to the used logging functions. A wide range
of changes are possible, as shown in Table 10. In this table, we show only the most
frequent changes in logging function, i.e. those with a frequency higher than 100.
The analysis of the changes to the logging functions revealed that 6,512 (33.75%)
of these updates are changes between printk, pr_<*>, and dev_<*> macros. For
example, in commit 26a0a10, a developer updated logging statements from printk
to using device-aware dev_err()/dev_info() logging functions for improving the
precision of the resulting logs by including device-speciﬁc information. This is
further cemented by an observation that there has been a steady decrease in the
usage of the printk() function, with a usage reduction of 29.32% between versions
4.3 and 5.3 of the Linux kernel. However, we found that the use of pr *() and
dev *() functions has increased to replace printk() call sites (Corbet 2012). This
gives evidence of evolving the importance of logging code in Linux, that is, de-
velopers have been modifying logging functions, possibly with the aim of creating
standardised functions.

24

Keyur Patel et al.

Table 10: Frequency of changes made to logging functions (frequency > 100).

Old logging function New logging function Frequency

printk
printk
BTC_PRINT
btc_alg_dbg
printk
printk
PDEBUG
pr_err
pr_info
PDBG
dev_err
pr_debug
test_msg
brcmf_err
RT_TRACE
pr_warning
pr_err
printk
BT_ERR
DTRACE
PRINT_ER
dev_dbg
pr_info
SSI_LOG_DEBUG
BUGMSG
SSI_LOG_ERR
dev_info
dev_err
DRM_ERROR
dev_info
PERR
btc_iface_dbg
BTC_PRINT
pr_info
gvt_err
DRM_ERROR
pr_warn
pr_info
pr_err

pr_err
pr_info
btc_alg_dbg
RT_TRACE
pr_cont
pr_warn
gspca_dbg
dev_err
ioc_info
pr_debug
DRM_DEV_ERROR
dev_dbg
test_err
bphy_err
pr_err
pr_warn
ioc_err
pr_debug
bt_dev_err
dml_print
netdev_err
musb_dbg
dev_info
dev_dbg
arc_printk
dev_err
dev_dbg
dev_dbg
DRM_DEBUG
pci_info
gspca_err
RT_TRACE
btc_iface_dbg
pr_debug
gvt_vgpu_err
DRM_DEV_ERROR
dev_warn
pr_info_ratelimited
pr_debug

950
881
663
621
606
591
477
440
418
392
387
369
345
315
275
262
231
226
205
173
169
163
161
156
153
152
151
146
145
139
129
119
119
119
118
104
102
102
100

We also found an increasing use of the so-called “rate limited” logging functions
such as the <*>[_once/_ratelimited] family of macros, which can be seen in com-
mit 527aa2a, where all calls to pr_info were converted to pr_info_ratelimited.
The objective of this type of functions is to prevent overloading the log buﬀers by
controlling the amount of logs generated in a given period of time. Consequently,
while writing logging code, it is important to consider not only the information
being logged, but also the amount of information being generated and its impact
on the application execution.

Moreover, we observed that many changes to logging functions are triggered
by the need to make them more concise. For example, in commit 466414a, a devel-
oper introduced btc_alg_dbg and btc_iface_dbg logging macros, and converted
all calls to BTC_PRINTK to the new functions (btc_<*>_dbg). The beneﬁt is that

The Sense of Logging in the Linux Kernel

25

software developers do not have to specify btc_msg_type, resulting in more concise
logging statements. Ten months later, in commit 10468c3, all calls to btc_<*>_dbg
were again changed to another logging function, named RT_TRACE, to be consistent
with the use of this function in other drivers.

We thus conclude from the above observations that changes to logging functions
aimed to improve the quality of the logging output by either enhancing precision,
conciseness, or consistency. However, after analyzing many commits related to log
updates, we could not ﬁnd any evidence that there was a Linux-wide strategy,
which suggests that these updates are a result of established guidelines. It appears
that the decision on how to log is left to the discretion of the developers.

The second reason for logging function modiﬁcation is changing the severity of
logging statements by specifying log levels. The printk function allows one of the
eight log levels deﬁned in /include/linux/kern_levels.h. For example,

printk(KERN_ERR "GCT Node MAGIC incorrect - GCT invalid\n");

However, the new logging API introduced in Linux 1.3.9812 embedded log levels
into the function names, such as pr_debug and pr_info. This change makes the
logging API richer, as developers have dedicated functions for speciﬁc log levels.
Table 11 provides the distribution of changes made to the severity of logging
statements. If the developer updates a logging statement to use a new logging
function, while keeping the same log level, we do not consider this change as a log
level change. This avoids including in the analysis refactoring in the logging code
that preserved the log level. As stated in previous work (Yuan et al. 2012a), de-
velopers often fail at determining how critical an error is in the ﬁrst attempt. This
observation is conﬁrmed by the ﬁnding from our study that, out a total of 4,127 log
level changes, approximately one third of the total log level changes were between
ERR and DEBUG log levels. Speciﬁcally, 720 (17.45%) logging statements low-
ered the severity of the log message from ERR to DEBUG, and 616 (14.93%) from
DEBUG to ERR. We found a total of 1,522 (36.88%) instances where developers
increased the severity of a logging statement to increase their visibility. In addi-
tion, logging debugging messages at the ERROR level would result in log ﬂooding,
making it diﬃcult to diagnose the real problems. We found that a total of 2,605
(63.12%) instances where developers reduced the severity of a logging statement in
order to prevent log ﬂooding. In fact, of these 4,127 log level modiﬁcations, 3,832
(92.85%) changes are between ERR, WARNING, INFO, and DEBUG log levels.
This suggests, as stated before, a lack of standards when logging, in particular,
when choosing a log level. Moreover, it indicates that it is by checking generated
log messages generated by already written logging statements that developers are
better able to reason about appropriate log levels.

Changes made to the static content. 56.02% of the 52,391 changed logging state-
ments, i.e. the majority, include modiﬁcations to the static content (i.e. the log
message). A similar result has also been observed by Chen and Jiang (2017b)
and Yuan et al. (2012a), who reported a ratio of 14%–65% and 18%–56%, respec-
tively. Prior studies list ﬁxing inconsistency, clariﬁcation, and spelling/grammar
mistakes as the major causes of this type of modiﬁcations (Chen and Jiang 2017b;

12 https://repo.or.cz/davej-history.git?a=commit;h=aa66269c

26

Keyur Patel et al.

Table 11: Changes in the level of logging statements between Linux v4.3 and v5.3.

New

Old

EMERG
ALERT
CRIT
ERR
WARN
NOTICE
INFO
DEBUG

EMERG ALERT

CRIT

ERR WARN

NOTICE

INFO DEBUG

0
0
1
1
22
0
1
0

1
0
0
0
2
0
0
0

10
6
0
5
14
0
1
0

51
8
8
0
343
10
188
616

30
10
3
242
0
5
62
77

0
0
0
19
14
0
23
6

1
0
0
195
336
21
0
145

0
0
0
720
346
22
562
0

Yuan et al. 2012a; Chen and Jiang 2019). Because static content consists of qual-
itative data, we are not able to make further claims about these changes in RQ2.
However, this is further investigated in RQ3, with a qualitative analysis of logging
modiﬁcations.

Changes made to the dynamic content. Of the 52,391 updated logging statements,
33,321 (63.60%) include modiﬁcations to the dynamic content (i.e. variables and
function calls). Yuan et al. (2012a) found that developers often add variables into
existing logging statements as afterthoughts, which can aid in the failure diagno-
sis process. However, changes to dynamic content represent only 27% of all log
modiﬁcations in their study. Our ﬁnding is, however, in line with the study of Li
et al. (2019a) on 12 C/C++ open-source projects, where the authors found that
69.1% updates to logging statement made modiﬁcations to the dynamic content.
This high number of changes to dynamic content has also been observed by Chen
and Jiang (2017b) and Zeng et al. (2019), in which they studied server/desktop
and Android applications written in Java, respectively. That is, despite Yuan et al.
(2012a) already claims that the addition of variables to logging statement is fre-
quent, in various projects—including Linux—it is more than twice more frequent
than they observed in their target systems.

One possible explanation for this high number of changes of the logging state-
ment dynamic content in Linux can be seen in commit 6be9005, where the devel-
oper switched to DRM_DEV_DEBUG_<*> instead of DRM_DEBUG. DRM_DEV_DEBUG_<*>
are device-aware logging macros and they require struct *device as an argu-
ment to include device name in the log output. In order to help developers decide
which variables should be included in the logging statement, a recent study by Liu
et al. (2019) proposed a deep learning-based approach that achieved an average
MAP score of 0.84 on nine open-source Java projects. Such approaches tailored to
Linux kernel domain could be helpful to alleviate this problem of what information
should be included in a logging statement.

4.2.4 RQ2: Summary

RQ2 - Findings. The log ratio (LLOC/SLOC) has been decreasing slowly from
v4.3 to v5.3, with a log ratio of 4.10% and 3.72%, respectively. This represents a
reduction of 9.27%. SLOC and LLOC are closely correlated across most versions of
Linux kernel between v4.3 and v5.3. This seems to be caused by the increase use of
tracing mechanism as a substitute to logging. We found that 14% of the commits

The Sense of Logging in the Linux Kernel

27

made between the Linux kernel versions v4.3 and v5.3 involve modiﬁcations to
logging code. Out of the 211,437 logging statements modiﬁcations, 24.78% are log
updates, 45.99% are log insertions, and 29.23% are log deletions. The majority of
changes to logging code (86.60%) are made in the drivers subsystem. The changes
to logging functions are triggered by the need to improve the quality of the logging
output by either enhancing precision, conciseness, or consistency. We found that
92.85% of the changes of log levels are between ERR, WARNING, INFO, and
DEBUG log levels, suggesting that it is diﬃcult for Linux developers to decide on
which log level to use. We found that 63.60% of the updated logging statements
include modiﬁcations to the dynamic content, while 56.02% are changes to the
static content.

RQ2 - Implications. A study should be conducted to dig deeper into the reasons
behind the decline of the log ratio over the years. The study should explore the
correlation between logging and tracing as it appears that tracing is being used
as a substitute to logging in more recent versions of Linux. We recommend to
examine the beneﬁts of logging, tracing, and other debugging mechanisms when
used individually and together. This may lead to better ways to optimize the use of
these mechanisms. For example, tracing has the advantage of being less dependent
on the developer’s input, and hence requires less maintenance. However, it comes
with an added overhead due to the presence of trace points, which may limit its
overall deployment. Another implication of these results is related to the lack of
guidelines and best practices, which is the main trigger behind the many changes
to logging statements. This is also evidenced in the high number of changes to log
levels, which clearly show that developers face challenges when deciding on the log
levels to use. These issues should be addressed by developing a set of guidelines
and best practices that do not only consider the information being logged (i.e.,
what to log), but also the amount of information that is generated and its impact
on the application execution. Finally, the high number of changes to the dynamic
variables is problematic since many errors can occur, leading to faults and crashes.
To address this issue, we suggest to use tools that would automatically recommend
updates to the dynamic variables of logging statements when these variables have
been modiﬁed in others parts of the code.

4.3 RQ3: Afterthought changes in logging code

For this research question, we look into afterthought changes, which are those that
explicitly address a bug caused by or is used to enhance the logging code (Yuan
et al. 2012a; Chen and Jiang 2017b). It is essential to study afterthought changes
because they add to the overall maintenance eﬀort. Having a large number of
afterthought log changes may defeat the very purpose of logging, which is to reduce
the maintenance eﬀort by facilitating debugging and other failure diagnosis tasks.
An example of a commit addressing a problem associated with logging code can
be seen in Listing 3. In this code snippet, there is an error message displayed by
the thinkpad acpi driver when brightness interfaces are not supported, encouraging
the user to contact IBM for this problem. However, according to the developer that
handled this commit, back-light interfaces on newer devices are supported by the
i915 driver. The developer decided to change the log level from “error ” to “info”

28

Keyur Patel et al.

to reduce the visibility of the log message. Another example consists of a commit in
which a developer decided to enhance the existing logging statements by including
qp_num(qp) in debug messages to improve debugging tasks (commit e404f94).

--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@ -6459,8 +6459,7 @@ static void __init

(cid:44)→ tpacpi_detect_brightness_capabilities(void)

pr_info("detected a 8-level brightness capable ThinkPad\n");
break;

default:

-
-
+

}

pr_err("Unsupported brightness interface, "
"please contact %s\n", TPACPI_MAIL);

pr_info("Unsupported brightness interface\n");
tp_features.bright_unkfw = 1;
bright_maxlvl = b - 1;

Listing 3: Commit d618651 - thinkpad acpi: Don’t yell on unsupported brightness
interfaces.

To understand the nature of afterthought changes made to logging code, we
conducted a qualitative analysis, detailed in Section 3, in which we manually exam-
ined the corresponding ﬁxes provided by the Linux developers. The ultimate goal
is to gain deep insight into the reasons behind these changes, which can help devel-
opers and researchers design new approaches and tools to prevent these problems.
To analyze the resulting 900 commits, for each commit, the ﬁrst author reviewed
the commit message, the commit diﬀ, related artefacts such as bug reports, and
discussions on the Linux kernel mailing lists, if available. He classiﬁed the reasons
behind these afterthought changes into 13 categories, which were reviewed and
validated by the other authors. These categories are shown in Table 12 and are
discussed in more detail in the subsequent sections, split into ﬁve groups.

4.3.1 Lack of information

LF01: Missing variables and statements. We found that 10.22% of the studied
commits are about improving debuggability by adding information to logging code
with the aim of reducing the time needed to diagnose program failures. This is
in line with the ﬁnding of Yuan et al. (2012a), who concluded that developers
often add information to the existing logging statements to narrow down the root
causes of the underlying problems. For example, in commit d0de579, a developer
mentioned: “Identify Namespace failures are logged as a warning but there is not
an indication of the cause for the failure. Update the log message to include the
error status.” Another example is commit 077c066, which added to the logging
statement a local variable representing a section index (idx), as shown in Exam-
ple 1 of Table 13. The reason for this change is given by the developer as: “While
debugging a bpf ELF loading issue, I needed to correlate the ELF section number
with the failed relocation section reference. Thus, add section numbers/index to the

The Sense of Logging in the Linux Kernel

29

Table 12: Characterization of ﬁxes to the logging code.

Group

Logging Fix

#Commits

Lack of Information LF01: Missing variables and statements

LF02: Imprecise logging messages
LF03: Null pointer dereference
LF04: Uninitialized variables
LF05: Logging wrong variables
LF06: Fixing incorrect log levels
LF07: Fixing inconsistencies
LF08: Deleting redundant information
LF09: Language mistakes
LF10: Fixing format speciﬁers
LF11: Message mistakes
LF12: Formatting issues
LF13: Revealing kernel pointers

Issues in
variable usage

Inadequate logging
conﬁguration

Writing issues

Disclosure of
Sensitive data

Total

92
62
13
9
28
156
163
31
171
125
6
71
16

900

pr debug.” We also found many cases where developers added logging statements
to record additional runtime information. This is exempliﬁed by commit 9ef8690,
where a developer inserted few additional logging points in order to make errors
more visible: “The NCSI driver is mostly silent which becomes a headache when
trying to determine what has occurred on the NCSI connection. This adds addi-
tional logging in a few key areas such as ...”

LF02: Imprecise logging messages. Ambiguity in an error message can delay the
process of diagnosis as it does not allow end users to easily uncover the part of the
programs that failed as in, for instance, Example 2 of Table 13. In this example, a
developer chose to use the full register name in the error message because a short
version of the register name may be ambiguous when diagnosing a fault. A similar
example can be found in commit 2e5d04dad, where the iwlagn driver uses exactly
the same error message in three diﬀerent functions. Therefore, the developer chose
to add the name of the function to the error string to disambiguate from where
the error originated.

Another common problem is the ambiguity of a log message, which can be
misleading during the analysis phase. Example 3 of Table 13 shows an example
where the original log message “failed to start DMA” together with an error log
level might mislead users to think that a fatal error occurred. In fact, although
DMA could not be used, the transfer could still be completed by PIO mode. The
updated message thus makes this clear as well as has a debug log level.

Another example of this type of logging ﬁx is when developers reword the
logging message to make the logs more informative and facilitate analysis. This
is shown in Example 4 of Table 13, where developers decided to reword NULL
pointer dereference message. The logging message was modiﬁed to drop “unable
to handle” from the message, because it might imply that in some cases the

30

Keyur Patel et al.

Table 13: Examples of lack of information.

Example 1

tools/libbpf: improve the pr debug statements to contain
section numbers | linux@077c066

Original

pr_warning("failed to alloc name for prog under

(cid:44)→ section %s\n", section_name);

Updated

pr_warning("failed to alloc name for prog under
(cid:44)→ section(%d) %s\n",idx, section_name);

Example 2 ASoC: tas6424: Print full register name in error message

| linux@919869214

Original

dev_err(dev, "failed to read FAULT1 register: %d\n",

(cid:44)→ ret);

Updated

dev_err(dev, "failed to read GLOB FAULT1 register:

(cid:44)→ %d\n", ret);

Example 3 mmc: dw mmc: ﬁx misleading error print if failing to do

DMA transfer | linux@d12d0cb

Original

/* We can’t do DMA */

dev err(host->dev, "%s: failed to start DMA.\n",

(cid:44)→ __func__);

Updated

/* We can’t do DMA, try PIO for this one */

dev dbg(host->dev,

(cid:44)→ "%s: fall back to PIO mode for current transfer\n"
(cid:44)→ , __func__);

Example 4

x86/fault: Reword initial BUG message for unhandled
page faults | linux@f28b11a

Original

pr_alert("BUG: unable to handle kernel %s at %px\n",

(cid:44)→ address < PAGE_SIZE ? "NULL pointer
(cid:44)→ dereference" : "paging request",
(cid:44)→ (void*)address);

Updated

if (address < PAGE_SIZE && !user_mode(regs))

pr_alert("BUG: kernel NULL pointer dereference,

(cid:44)→ address = %px\n", (void *)address);

else

pr_alert("BUG: unable to handle page fault for

(cid:44)→ address = %px\n", (void *)address);

kernel actually handles NULL pointer dereference, which is not valid. A simi-
lar example is found in commit 135e535, where the developer clariﬁed an error
message to avoid user confusion. He reported that: “Some user who install SIG-
BUS handler that does longjmp out therefore keeping the process alive is confused
by the error message [188988.765862] Memory failure: 0x1840200: Killing
cellsrv:33395 due to hardware memory corruption. Slightly modify the error
message to improve clarity.” In conclusion, poorly worded log messages may lead
to user confusion and ﬁxing these logs takes up maintenance time and eﬀort.

The Sense of Logging in the Linux Kernel

31

Table 14: Examples of issues in variable usage.

Example 5

staging: ks7010: don’t print skb->dev->name if skb is null |
linux@95d2a32

Original

printk(KERN_WARNING "%s: Memory squeeze, dropping

(cid:44)→ packet.\n",skb->dev->name);

Updated

printk(KERN_WARNING "ks wlan: Memory squeeze,

(cid:44)→ dropping packet.\n");

Example 6

staging: fsl-dpaa2/eth: Don’t use netdev err too early |
linux@0f4c295

Original
Updated

netdev err(net dev, "Failed to configure hashing\n");
dev err(dev, "Failed to configure hashing\n");

Example 7 btrfs: tree-log.c: Wrong printk information about name-

len | linux@286b92f

Original

Updated

btrfs_crit(fs_info, "invalid dir item name len: %u",
(cid:44)→ (unsigned)btrfs dir data len(leaf, dir_item));
btrfs_crit(fs_info, "invalid dir item name len: %u",
(cid:44)→ (unsigned)btrfs dir name len(leaf, dir_item));

Using the same static text in a single ﬁle is also a case that contributes to
ambiguity in logging statements. This practice of duplication in logging code was
rightfully reported by Li et al. (2019b) as a logging code smell. One example of this
practice is depicted in commit a15e824 and commit 90cc7f1, where the developer
added additional information so that log messages can be uniquely identiﬁed using
search techniques.

4.3.2 Issues in variable usage

LF03: Null pointer dereference. In 1.44% of the cases, a developer attempted to
dereference a pointer that may have a NULL value or an empty variable. This is
something that can occur in Example 5 of Table 14, which illustrates a ﬁx made
in commit 95d2a32.13 In this commit, the original logging statement included the
dereferencing of the skb pointer, which can be NULL. A NULL pointer dereferenc-
ing causes a runtime crash. To prevent this type of problems, developers should
incorporate tools such as Coccinelle14 in their workﬂow for detecting dereferences
of NULL pointers.

LF04: Uninitialized variables. Out of 900 commits, we found 9 cases in which
log messages refer to device names before they are registered. These logs contain

13 Note that the change made to the logging statement is not semantically equivalent to the
original statement, but with the bug ﬁxed. The goal in the change was to ﬁx the NULL pointer
and the change was accepted to ﬁx this issue.
14 http://coccinelle.lip6.fr/rules/#null

32

Keyur Patel et al.

Table 15: Examples of inadequate logging conﬁguration.

Example 8

imx:

i2c:
real
notify
i2c_imx_dma_request | linux@5b3a23a

about

errors

on

dma

Original
Updated

dev dbg(dev, "can’t configure rx channel\n");
dev err(dev, "can’t configure rx channel (%d)\n", ret);

Example 9 mei: bus: remove redundant uuid string in debug mes-

sages | linux@2bcfdc2

Original

dev_dbg(&cldev->dev, "running hook %s on %pUl\n",
(cid:44)→ __func__, mei me cl uuid(cldev->me cl));

Updated

dev_dbg(&cldev->dev, "running hook %s\n", __func__);

messages referring to “unnamed net device” or “uninitialized”, which lead to
logs that may confuse end users. Example 6 of Table 14 shows a ﬁx to one of these
problems. The logging statements consists now of a call to the function dev err,
which considers the possibility that the ﬁrst parameter is null. In this case, it will
add “NULL net device” to the log message.

LF05: Logging wrong variables. Developers speciﬁed the wrong variables as argu-
ments of the logging function calls in 28 cases. The root causes of these issues are
simple copy/paste mistakes or typographical errors.15 This is illustrated in Exam-
ple 7 of Table 14, in which the original and updated logging functions have similar
names, but the former calls the function btrfs_dir_data_len, reporting data_len
in the error message. However, the correct function is btrfs_dir_name_len, which
reports name_len in the message. Such errors are diﬃcult to detect using static
analysis tools, because both btrfs_dir_name_len and btrfs_dir_data_len have
the same return type.

4.3.3 Inadequate logging conﬁguration

LF06: Fixing incorrect log levels. We found that in 17.33% of the cases there are
changes in the log levels. This includes cases where developers failed to make a
distinction between fatal errors and errors that are recoverable. Moreover, using a
non-error log level for logging error conditions would make it hard to diagnose such
errors as the corresponding error messages would go unnoticed. Likewise, logging
debugging messages as errors will also result in a ﬂood of log messages making it
hard to concentrate on the real problems. In example of such an issue is shown
in Example 8 (Table 15), where the developer mentioned that “... In contrast real
problems that were only emitted at debug level before should be described at a higher
level to be better visible and so understandable.” Thus, the developer decided to
change the log level from DEBUG to ERROR.

Developers need to carry out logging activities taking into account performance
constraints (Ding et al. 2015; Sigelman et al. 2010). One of the most frequent issues

15 https://cwe.mitre.org/data/definitions/688.html

The Sense of Logging in the Linux Kernel

33

is log spamming, which often leads to degradation of system performance. This
occurred in commit 7f20d83, where the developer downgraded the log message to
DEBUG level to suppress frequent “VTU miss violations” messages, as “VTU miss
violations” are rather common.

LF07: Fixing inconsistencies. We found 163 commits (18.11%) that were the re-
sult of ongoing modernization of logging code. Usually, such improvements do not
address severe problems associated with the logging code; instead, they arise from
attempts to improve the consistency of logging code across various parts of the
Linux kernel. One such change is the use of device-managed logging macros in or-
der to simplify error handling, reduce source code size, improve readability, and/or
reduce the risks of bugs. Another improvement is the use of
and pr fmt
rather than hard-coded function names and module names in error messages. For
example, in commit a8ab042, a developer mentioned: “Instead of having the func-
tion name hard-coded (it might change and we forgot to update them in the debug
output) we can use
instead and also shorter the line so we do not need to
break it.” As Yuan et al. (2012a) pointed out, inconsistency in the function names
referred in the log message is one of the main reasons for changes made to logging
code.

func

func

LF08: Deleting redundant information. We found 31 cases in which developers
report information that is redundant or not needed. One illustration of this case
found in commit 2bcfdc2 is shown in Example 9 (Table 15), where the developer
removed uuid from the debug messages in bus-fixup.c as this was already part
of the device name. Another common pattern that we observed is the removal of
__func__ from dev_dbg() calls. The reason for this change is given in commit
b814735 as “Dynamic debug can be instructed to add the function name to the
debug output using the +f switch, so there is no need for the nﬁt module to do it
again. If a user decides to add the +f switch for nﬁt’s dynamic debug this results in
double prints of the function name ..... Thus remove the stray
printing.”
In addition, removing __func__ from dev *() callsites helps reduce the Linux
kernel size as pointed out by Wolfram Sang, the current maintainer of the Linux
I2C subsystem.16

func

4.3.4 Writing issues

LF09: Language mistakes. 19% of the 900 studied log updates are caused by
spelling or grammar mistakes. Example 10 (Table 16) shows an example where
the word “synchronously” was misspelt as “synchronuously” in the static text. An-
other example can be seen in commit 748ac56. To correct a grammatical mistake,
the static text was changed from “Failed to registered ssb SPROM handler”
to “Failed to register ssb SPROM handler”. We also noticed that there is no
standardization over the use of capitalization, grammatical style, punctuation, etc.

16 https://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux.git/commit/?h=
strings/rtc-no-func&id=762c5af234c5b816b7da3687a3e703cf8cdc2214

34

Keyur Patel et al.

Table 16: Examples of writing issues.

Example 10 usbip: vhci: ﬁx spelling mistake: “synchronuously” →

“synchronously” | linux@cb48326

Original

dev_dbg(&urb->dev->dev, "urb seq# %u was unlinked

(cid:44)→ %ssynchronuously\n",seqnum,status == -ENOENT ?
(cid:44)→ "":"a");

Updated

dev_dbg(&urb->dev->dev, "urb seq# %u was unlinked

(cid:44)→ %ssynchronously\n",seqnum,status == -ENOENT ?
(cid:44)→ "":"a");

Example 11

ti sci: Use %pS printk format for direct addresses |
linux@595f3a9

Original

dev_err(dev, "Mbox timedout in resp(caller: %pF)\n",

(cid:44)→ (void *)_RET_IP_);

Updated

dev_err(dev, "Mbox timedout in resp(caller: %pS)\n",

(cid:44)→ (void *)_RET_IP_);

Example 12

greybus: gpb: Fix print mistakes | linux@b908dec

Original

if (gb_usb_protocol_init()) {

pr_err("error initializing usb protocol\n");
goto error_usb;

}
if (gb_i2c_protocol_init()) {

pr_err("error initializing usb protocol\n");
goto error_i2c;

Updated

}
if (gb_usb_protocol_init()) {

pr_err("error initializing usb protocol\n");
goto error_usb;

}
if (gb_i2c_protocol_init()) {

pr_err("error initializing i2c protocol\n");
goto error_i2c;

}

LF10: Fixing format speciﬁers. We found 13.89% of the 900 studied revisions are
the result of using improper format speciﬁers in logging statements.17 A typical
issue related to printk format speciﬁer is shown in Example 11 (Table 16). In the
example, the developer decided to use the %pS printk format speciﬁer for printing
symbols from direct addresses. Moreover, the explanation for this change was given
as “This is important for the ia64, ppc64 and parisc64 architectures, while on other
architectures there is no diﬀerence between %pS and %pF. Fix it for consistency
across the kernel.” It appears that most of this type of changes are motivated
by the intention to ﬁx build warnings, which developers should have addressed

17 https://www.kernel.org/doc/Documentation/printk-formats.txt

The Sense of Logging in the Linux Kernel

35

Table 17: Example of sensitive data.

Example 13 drm/exynos: Print kernel pointers in a restricted form |

linux@9cdf0ed

Original

Updated

dev_dbg(dev, "< xfer %p: tx len %u, done %u, rx len
(cid:44)→ %u, done %u\n", xfer, length, xfer->tx_done,
(cid:44)→ xfer->rx_len, xfer->rx_done);

dev_dbg(dev, "< xfer %pK: tx len %u, done %u, rx len
(cid:44)→ %u, done %u\n", xfer, length, xfer->tx_done,
(cid:44)→ xfer->rx_len, xfer->rx_done);

at commit-time. We found that developers often get around using proper format
speciﬁers by resorting to unnecessary casts.18 This practice was rightfully reported
by Chen and Jiang (2017a) as a logging anti-pattern.

LF11: Message mistakes. We identiﬁed six instances where developers made mis-
takes in the static messages. Similarly to LF05 (Logging wrong variables), it seems
that developers aimed at save time by copying and pasting a few snippets of code.
However, some of the necessary modiﬁcations are left behind. This happens in
Example 12 (Table 16), where the developer entered an incorrect logging message
in the gpbridge_init method, likely caused by a copy/paste mistake. It seems
that the developer copied the line if (gb_usb_protocol_init()) and corrected
it. However, the debugging statements were not updated accordingly, referring to
the i2c protocol, as in the updated statement.

LF12: Formatting issues. Developers ﬁxed formatting of log messages in 71 cases.
Poorly formatted messages make it diﬃcult to search for matching text in the
log ﬁle. We can see this issue in commit a790634, where certain messages were
appearing on separate lines resulting in a strange output. This was ﬁxed using
line continuations where necessary. Another issue that falls under this category is
that developers frequently break log message strings over several lines to meet the
checkpatch’s 80 characters per line restriction. According to commit 4bd69e7b,
this is no longer considered a good practice, because it makes it more diﬃcult to
grep for strings in the source code.

4.3.5 Disclosure of sensitive data

LF13: Revealing kernel pointers. Insuﬃcient information in log messages can de-
lay the diagnosis process. However, revealing sensitive information such as cryp-
tographic keys or kernel addresses can lead to information leaks.19 We found 16
commits, which mentioned these cases. An example can be seen in commit 9cdf0ed
shown in Example 13 (Table 17). It states in the commit message that “Printing
raw kernel pointers might reveal information which sometimes we try to hide (e.g.

18 https://github.com/torvalds/linux/commit/3fcb3c836ef413d3fc848288b308eb655e08d853
19 https://cwe.mitre.org/data/definitions/200.html

36

Keyur Patel et al.

with Kernel Address Space Layout Randomization). Use the ”%pK” format so these
pointers will be hidden for unprivileged users.” Other examples of such cases can
be seen at CVE-2018-599520 and CVE-2018-727321, where developers print kernel
addresses into logs, which can allow an attacker to extract sensitive information.
The problem of accidental data leakage through the misuse of logs has recently
been examined by Zhou et al. (2020). The authors showed that logs could reveal
sensitive information in Android apps. Similar studies should be conducted for
larger systems such as the Linux kernel to understand the extent of this serious
problem.

4.3.6 RQ3: Summary

RQ3 - Findings. After manually analyzing 900 commits randomly selected from
those that include ﬁxes or improvements in logging code, we identiﬁed 13 types
of logging ﬁx, categorized into ﬁve groups: lack of information, issues in variable
usage, inadequate logging conﬁguration, writing issues, and disclosure of sensitive
data. The most common type of logging ﬁx consists of language mistakes, ap-
pearing in 19% of the commits, followed by ﬁxing inconsistencies (18%), log levels
(17%), and format speciﬁers (13%). The last three types of logging ﬁx indicate a
lack of logging standards. Another type of ﬁx that appeared with a certain fre-
quency is missing variables and statements (10%), which suggests that developers
should further consider all information that is needed for debugging when adding
logging information.

RQ3 - Implications. The ﬁndings show that there are many errors in the logging
code, which may have a signiﬁcant impact on log analysis tasks. Based on these
ﬁndings, we derived a list of guidelines and recommendations to help address each
of the issues raised in this section. The proposed guidelines can be found in Section
5.4.

5 Discussion

In this section, we discuss insights derived from our study. First, we focus on lessons
learned associated with the pervasiveness of logging, followed by comparison of
our ﬁndings to previous similar studies. Then, we present guidelines and point
out directions for automated support for logging. Next, we detail the feedback
provided by a Linux expert regarding the ﬁndings of our study. Finally, we discuss
threats to the validity of our study.

5.1 On the Pervasiveness of Logging

Logging code represents 3.69% of the Linux kernel, being pervasive in its source
code. However, when we evaluate the pervasiveness of logging at the ﬁle and
method levels, we found that the distribution of logging code is highly skewed,

20 https://nvd.nist.gov/vuln/detail/CVE-2018-5995
21 https://nvd.nist.gov/vuln/detail/CVE-2018-7273

The Sense of Logging in the Linux Kernel

37

suggesting that certain aspects of the Linux kernel are more likely to have logging
code than others. It would be interesting to assess the correlation between the log
ratio of a method and its cyclomatic complexity in future studies.

Although logging code corresponds to only less than 4% of the Linux kernel
code, this type of code is actively maintained. We found that 14% of commits
related to Linux kernel versions 4.3 to 5.3 involves modiﬁcations to logging code
resulting in a total of 211,437 logging statements modiﬁcations, which represents
66.19% of the total number of logging statements present in Linux kernel v5.3.
Moreover, we identiﬁed that logging code deletion accounts for 29.23% of the to-
tal modiﬁcations to logging code, in contrary to ﬁndings reported by Yuan et al.
(2012a). Despite the majority of logging code deletion happens when a ﬁle is
deleted, there is a non-negligible amount (44.66%) of deletion of logging code oc-
curring as afterthoughts. A possible explanation for this might be observed in
commit a8d5dad, where a developer deleted two logging statements that report
memory allocation failures. There is a rule in checkpatch.pl to check for possible
unnecessary out of memory message. However, it seems that developers do not care
to ﬁx this issue at commit time, because there is a large number of commits remov-
ing out of memory error messages as afterthoughts. Logging statements are also
deleted in cases in which they are redundant. For instance, in commit c99a23e55,
a developer removed an error message present within error handling code when
i2c_mux_add_adapter fails because i2c_mux_add_adapter already prints an error
message when it fails.

We found that developers often face diﬃculties to specify the right log level
in the ﬁrst attempt, because there is no such a static veriﬁcation of whether a
log level is correct. For example, in commit 3b364c659, a developer downgraded
the logging message from WARN to INFO log level, and reason for this change was:
“On an embedded system it is quite possible for the bootloader to avoid conﬁguring
PCIe devices if they are not needed.” It is surprising that it took the developers
26 months to notice this problem.

The majority of the logging statements (55.66%) are used within an if block.
Moreover, most of them is used for logging errors after checking the return value
of function calls. As the decision regarding logging is left to developers, we noticed
many inconsistencies in the text of an error message, logging function used, and
information included in an error message. Table 18 shows an example of this situ-
ation. A call to thermal zone device register() returns a pointer to the newly
created struct thermal zone device, and in case of error it returns an ERR PTR.22
All these three drivers perform a registration of a new thermal zone device and
check the return value using IS ERR() macros and, in case of an error, log an error
using dev err(). Even though all three drivers are performing the same action,
there is no consistency among the error messages. This can prevent automated
post-mortem analysis.

We also observed inconsistencies in the information included when logging an
error message. For example, there are many locations that report an error when
there is a failure when calling the function devm_request_irq. However, plenty of
the callers of this function do not include the irq requested and the returned error

22 https://github.com/torvalds/linux/blob/v5.3/drivers/thermal/thermal_core.c#
L1211

38

Keyur Patel et al.

Table 18: Lack of consistency in the text of the error messages

spear_thermal = thermal_zone_device_register(...);
if (IS_ERR(spear_thermal)) {

dev_err(&pdev->dev, "thermal zone device is NULL\n");
[...]

}

drivers/thermal/spear thermal.c

priv->zone = thermal_zone_device_register(...);
if (IS_ERR(priv->zone)) {

dev_err(dev, "can’t register thermal zone\n");
[...]

}

drivers/thermal/rcar thermal.c

sensor->thermal_dev = thermal_zone_device_register(...);
if (IS_ERR(sensor->thermal_dev)) {

dev_err(dev, "failed to register thermal zone device\n");
[...]

}

drivers/thermal/st/st thermal.c

code.23 A possible solution to avoid such inconsistencies would be centralizing error
reporting rather than leaving the decision to the developers. One such a change
made to get more consistent error reporting can be seen in commit 7723f4c, the
reason for this change is that “A grep of the kernel shows that many drivers print
an error message if they fail to get the irq they’re looking for. Furthermore, those
drivers all decide to print the device name, or not, and the irq they were requesting,
or not, etc. Let’s consolidate all these error messages into the API itself, allowing
us to get rid of the error messages in each driver.” This centralization of error
reporting helps reduce the size of the Linux kernel code. This also decreases the
need for commits made as afterthoughts to add additional information or ﬁxing
typographical mistakes.

5.2 Comparison to Existing Studies

Our study replicates existing studies that had as target systems C/C++ and Java
projects. We, in turn, analyzed the Linux kernel, which is one of the greatest
collaborative eﬀorts in the computer industry. Based on these previous studies
and their results, we show in Table 19 a comparison of the results obtained in
our study and those from Yuan et al. (2012a) and Chen and Jiang (2017b), which
explore similar aspects related to the practice of logging.

23 https://github.com/torvalds/linux/blob/v5.3/drivers/usb/dwc2/gadget.c#L4846

The Sense of Logging in the Linux Kernel

39

Table 19: Comparison of results from our study and previous work.

Research
Question

RQ1:
Pervasiveness of
logging in Linux
kernel

RQ2: Logging
code evolution

RQ3:
Afterthought
changes in
logging code

Our study

On average,
every 27 lines of
code contained
one line of
logging code in
the Linux kernel.

Logging code is
modiﬁed in 14%
of all analysed
commits.

Logging deletions
account for 29%
of the number of
modiﬁcations
made to logging
code.

30% of analyzed
commits are
related to
afterthought
updates.

Fixing incorrect
log levels
accounts for 17%
of analyzed
commits.

Almost 16% of
analyzed
commits are
related to issues
in variable usage
or missing
variables and
statements.

Fixing language
mistakes is the
most frequent
update to static
text.

Yuan et al.
(2012a)

On average,
every 30 lines of
code contained
one line of
logging code in
four open-source
C/C++ projects.

Logging code is
modiﬁed in 18%
of all committed
revisions.

Logging deletions
account for 2% of
the number of
modiﬁcations
made to logging
code.

33% of updates
to the log
printing code are
afterthought
updates.

Fixing incorrect
log levels
accounts for 26%
of afterthought
updates.

27% of the
afterthought
updates are
related to
variable logging.

Chen and
Jiang (2017b)

On average,
every 51 lines of
code contained
one line of
logging code in
21 Java projects.

Logging code is
modiﬁed in 16%
of all committed
revisions.

Logging deletions
account for 26%
of the number of
modiﬁcations
made to logging
code.

59% of updates
to the log
printing code are
afterthought
updates.

Fixing incorrect
log levels
accounts for 21%
of afterthought
updates.

32% of
afterthought
updates are
related to
variable logging.

Fixing
misleading
information is
the most
frequent updates
to the static text.

Fixing
misleading
information is
the most
frequent updates
to the static text.

40

Keyur Patel et al.

5.3 Feedback from a Linux Expert

We reached out to a Linux development expert, who has also been very active
in discussing the use of logging libraries in Linux, to obtain feedback on this
study and discuss possible improvements. We also gave him an early version of
the paper to review. In general, the expert agreed with the fact that logging is
not a practice that is well governed in Linux, which explains the fact that logging
varies signiﬁcantly from one component of the system to another, depending on
the development teams of the components. He added that most of the ﬁndings
related the change of the logging code are caused by a lack of guidelines across all
the development teams in Linux. He added that he had himself committed many
updates to ﬁx issues related to logging code to improve the quality of the logging
statements.

Further, the Linux expert made three suggestions that do not only provide
insights into the results, but can also be used to drive future studies. The ﬁrst
suggestion is to separate code written speciﬁcally for Linux from that ported to
Linux such as some external drivers. This would perhaps provide a better picture
of the logging landscape of Linux-speciﬁc code. Having said, our answer to RQ1
shows that the most logged components are ”ﬁlesystem” and ”core”, which are
speciﬁc to Linux. In other words, it is not clear whether excluding the drivers
would have an important eﬀect on the results of RQ2 and RQ3. Besides drivers
are an integral part of Linux, removing them may weaken the study. The second
suggestion is related to the use of various tools (codespell, integrated spelling tests
in checkpatch, coccinelle, etc) that have recently been made available to Linux
developers. These tools are now recommended to improve the quality of code.
On one hand, this comment conﬁrms our ﬁndings with respect to RQ3 where we
concluded that many errors in the logging code could have been avoided using
this type of tools. On the other hand, the point raised by the expert warrants
a study on how these tools are used to check logging code and what the impact
on the quality of logging statements would be. Finally, the expert explained that
in recent years, there has been an increase in the use of tracing tools such as
ftrace to log the entry/exit of function, which justiﬁes the decrease in the use of
logging. This comment is inline with our ﬁnding in RQ2 where we showed that
despite the increase of the number of LOCs across versions, the number of logging
statements have decreased. We attributed this to the emergence of tracing and
other debugging mechanisms as substitutes to logging on the premise of the studies
of Corbet (2016) and Edge (2019). The Linux expert’s opinion converges with this
ﬁnding. The input provided by the Linux expert encourages us to conduct a formal
user study to gain more insights into the way logging is used in Linux. This study
should build on the results obtained in this paper, which are an important ﬁrst
step to understand the logging landscape in Linux in particular and in software
engineering in general.

5.4 Logging Guidelines

Based on the analysis of the afterthoughts changes in the logging statements in
the Linux kernel source code, we derived the following guidelines that can help
the maintenance of logging code. For each listed guideline, we also indicate the

The Sense of Logging in the Linux Kernel

41

identiﬁed types of logging ﬁx that serves as a foundation for it and a description.
We also indicate opportunities for automation when applicable.
A. Be precise, concise and consistent in logging statements. (LF02, LF07,
LF08, LF10, LF12 ) In order for logs to be useful, they should be precise (not
leaving room for ambiguity), concise (to not create huge amounts of logs with
redundant information) and consistent (to facilitate post-mortem analysis). An
example of speciﬁc recommendations is to not use hard-coded module or function
names and refer to complete variable names.

Developers should strive for writing concise logging statements to prevent re-
dundant information. Automatic tools can be developed to detect redundancies.
However, some redundancies may require domain knowledge. These can be de-
tected by developers when reviewing the code. There are static analysis tools such
as smatch 24 and sparse 25, that are useful at detecting incorrect format speciﬁers.
Developers should consider using these tools to detect this type of problems at
commit time rather than ﬁxing the corresponding code as afterthought.

It is recommended to use a spell checker, as provided by many IDEs. This is an
initial step to prevent the need for corrections in language issues. Additional tools
for grammar checking could be embedded in current IDEs. Guidelines for a com-
mon writing style should be developed and promoted. Tools such as kernelscan 26
should be incorporated into build pipelines.
B. Specify (in advance) and follow logging conventions. (LF06, LF08 )
Even though there are existing descriptions of how the diﬀerent log levels should
be used in the Linux kernel, a suggestion is to further detail logging conventions.
For instance, the error level should only be used in situations in which components
may fail and compromise system operation. Moreover, conventions can be used to
avoid redundant or missing information, and use similar static messages, because
for the same situation, such as an error, diﬀerent messages and variables are logged
in distinct code locations. This can be aided by dedicated logging functions.
C. Program for debuggability. (LF01, LF12 ) To prevent posterior logging
changes, we recommend that developers provide beforehand detailed information
on where the failures are located and any other information relevant to failure
that can facilitate debugging. For example, including error code in the logging
statement, if available, is always a good idea. In addition, developers should avoid
breaking log message lines to facilitate post-mortem analysis of the logs.
D. Reason about possible variable values. (LF03, LF04 ) NULL pointer deref-
erencing causes a runtime crash. Consequently, it is crucial to reason if a referred
pointer can be NULL or a variable can be empty. A potential NULL pointer
dereferencing can be avoided by adding automatic checks to logged variables, and
function return values that are used as logging statements arguments. Further-
more, developers should only use the device or network-speciﬁc logging macros
after checking that the devices were correctly initialized and registered. Static
analysis tools can be used to check that all variables are initialized before they are
used for logging.
E. Be careful with copy-paste. (LF05, LF11 ) Developers should avoid copying
and pasting logging statements, as this is a source of mistakes. If the statements

24 https://repo.or.cz/w/smatch.git
25 https://sparse.wiki.kernel.org/
26 https://github.com/ColinIanKing/kernelscan

42

Keyur Patel et al.

do not match the targeted subject, they may confuse and mislead developers when
debugging and analyzing logged messages. In the case of a copy-paste of a logging
statement, it is essencial to check if (i) a called logging function has been updated;
(ii) the static message has been adequately changed; and (iii) referred variables
are correct.
F. Consider security issues. (LF13 ) Tests should be put in place to verify
that logs do not accidentally cause security and data privacy breaches. This eﬀort
should adhere to the broader task of ensuring the security of the Linux kernel.
G. Review logging code. (LF02, LF09 ) To avoid many of the raised issues, such
as imprecise, redundant, and inconsistent logging statements as well as copy-paste
mistakes, can be detected at commit time during a code review process. Therefore,
we recommend logging code to be carefully reviewed. This task can be done before
accepting the commits.
H. Use recommender systems. (LF01, LF05, LF06, LF07 ) There is an ongoing
research in developing recommendation tools to assist developers in logging. For
example, Panthaplackel et al. (2020) proposed a deep-learning-based approach to
automatically update the static text in the logging statements based on changes
made to the surrounding source code. Fu et al. (2014) conducted a study at Mi-
crosoft where they showed that it is possible to use machine learning techniques to
predict with a good accuracy where to log. Developers should consider including
these tools, if shown eﬀective in the context of the Linux kernel, to predict log
levels, variables that need to be logged, static analysis of logging statements, etc.

5.5 Implications for Future Research

Our study allowed us to understand how logging is present in the Linux kernel and
to identify issues that caused the evolution of logging statements. The analysis of
collected data revealed facts related to logging in the Linux kernel, leaving room
for future research work. We discuss directions for future studies as follows.

The analysis of the pervasiveness of the logging in the Linux kernel showed that
the log ratio in the many Linux subsystems and components varies. This can be
explained by various arguments, such as: (i) long-lived less-changed components
may be stable and are the cause of few bugs, so they do not need to be as logged
as other components; (ii) logging can have an impact on system performance and,
therefore, certain code parts may be less logged to prevent performance decay; and
(iii) diﬀerent parts of the code may be maintained by diﬀerent teams of developers,
with diverging logging practices. Based on the data collected for this study, it is
not possible to reach a conclusion regarding the rationale for the current logging
decisions and their variability across the diﬀerent Linux subsystems and ﬁles. This
calls for future studies that investigate this. Possible types of studies that are
suitable for testing these hypotheses are:

– a user study in which developers think out loud, justifying the logging state-

ments that they add, modify or delete;

– interviews with developers immediately after they commit a code change that

involves logging changes; or

– a qualitative study of code review comments, in which there are requests for
changes in logging statements with an accompanying rationale for the change.

The Sense of Logging in the Linux Kernel

43

With respect to our logging guidelines, a future study can be conducted to eval-
uate their impact on the evolution of logging practices. The presented guidelines
were derived using the principles of grounded theory—the guidelines are grounded
on the conducted qualitative analysis. Although there are supporting evidences
for each derived guideline, it is important to assess if their adoption in the Linux
kernel (or a software project) can have a positive impact on the standardization
of the logging statements, reducing the need for constant modiﬁcations due to
inadequate logging. An experimental study in which the intervention is the use of
our derived guidelines is suitable for answering this question.

5.6 Threats to Validity

Internal Validity. Threats to internal validity are associated with factors that may
impact our results. In this study, a source of bias is the automated data collection
process. To identify logging statements, we rely on the semantic patterns speciﬁed
by Tschudin et al. (2015). However, this approach may not identify statements that
lack variability in their use. To mitigate this issue, we manually examined macros
containing calls to basic functions, such as printk(), pr *(), and dev *(), in order
to identify missed logging functions. The set of functions collected by combining
both processes was thus manually reviewed with the aim of eliminating obvious
false positives. In addition, although we believe that the list of logging functions
extracted with this approach is a very comprehensive, we cannot guarantee 100%
coverage. To mitigate this threat, we selected randomly 20 ﬁles and checked manu-
ally their content to see if we missed any logging functions. We found that our list
covered all the logging functions invoked in these ﬁles. We also want to emphasize
that we do not think that the missing of some logging functions aﬀects much the
conclusions of this study. For RQ1 (the pervasiveness of logging), we already es-
tablished that logging is pervasive in Linux (on average for every 27 lines of code,
there is one logging statement), so ﬁnding more logging statements can only con-
ﬁrm this fact. For RQ2-The evolution of logging code, we found that logging code
is constantly maintained by Linux developers (14% of commits modify logging
statements). Additional logging statements will eventually conﬁrm this ﬁnding.
The nature of changes are due to the need to improve the quality of the logging
output by either enhancing precision,conciseness, or consistency. RQ3 (analysis of
afterthought log changes) is based on a sample of commits and is not aﬀected by
the number of logging statements.

In order to automatically identify and classify changes made to logging code,
we use a pipeline that consists of GumTree (Falleri et al. 2014) and a script speciﬁ-
cally developed for this study. To mitigate possible misclassiﬁcations, we manually
inspected a sample of 100 randomly selected modiﬁcations, which showed an ac-
curacy of 98% on classiﬁed modiﬁcations. Although 2% have been misclassiﬁed,
given the amount of analyzed code, it can be considered noise in the data.

Another threat to this study is the manual classiﬁcation of log-related commits.
We manually examined all commits by their title and message whenever necessary.
However, we cannot eliminate the possibility that errors may have occurred during
this manual analysis. We thus do not claim that our dataset is complete. This
threat is mitigated by the fact that our goal was to collectively study the nature
of the problematic logging code rather than collecting every possible revision made

44

Keyur Patel et al.

to ﬁx or improve logging. Because we perform a qualitative analysis in order to
categorize changes made to logging code and the nature of problematic logging
code, researcher bias also becomes a threat to the internal validity of our study.
In this kind of analysis, results are associated with researcher interpretation of
the data. Therefore, to mitigate it, every classiﬁcation that raised questions were
discussed by the authors until they reached an agreement. In addition, all the
results were largely discussed and validated among all authors.

External Validity. Threats to external validity are related to which extent our re-
sults can be generalized. One threat to external validity is due to the fact that we
only examined 22 releases (v4.3 - v5.3) of the Linux kernel to answer part of RQ2
where we measure the evolution of logging code in these releases. A larger dataset
may provide diﬀerent results. This said, we still think our dataset is representative
for the study as a whole since our objective is not to uncover all the problems
related to logging in Linux but rather to provide insight on the practice of logging
in software development by looking at how Linux developers, even in a narrower
scope, use logging. In addition, the fact that we focused solely on the Linux ker-
nel project, which is known for having its own development culture, may be a
threat to external validity. We believe that this threats is mitigate by the fact that
Linux is a large scale, open-source project maintained by developers from diﬀerent
companies, which constitutes a representative sample of C/C++ projects.

6 Conclusion

In this paper, we presented an empirical study that aims to shed light into existing
logging practices in the Linux kernel. Although the logging code accounts for 3.73%
of the total source code in the Linux kernel, we observed that the distribution
of logging code is skewed when evaluated at ﬁle and program construct level.
Future studies may employ survey methods to understand the circumstances in
which logging is needed and the rationales of logging activities. We also found that
32.37% of the log-level changes are between error and debug log levels, suggesting
that it is also diﬃcult for Linux developers to decide between fatal errors and
errors that are recoverable. We observed that the major causes underlying ﬁxes
to problematic logging code occurring in the Linux kernel are language mistakes,
appearing in 19% of the commits. Other common causes for changes are ﬁxing
inconsistencies (18%), log levels (17%), and format speciﬁers (13%). Based on our
results, we discussed insights associated with the pervasiveness of logging code in
the Linux kernel. In addition, we derived eight practical guidelines that can help
developers to maintain logging code, including the need for automated support for
logging.

As future work, we aim to perform an in-depth qualitative analysis of logging
code to further understand common patterns in logging statements. Our present
study targeting the Linux kernel, complemented by this future qualitative analysis,
will be the basis for the next generation of tools to provide automated support to
develop and evolve logging code.

The Sense of Logging in the Linux Kernel

45

Acknowledgements

Abdelwahab Hamou-Lhadj and Keyur Patel would like to thank Ericsson Global
Artiﬁcial Intelligence Accelerator (GAIA) Group in Montreal and MITACS for
supporting this project (Grant Number: IT15986). Ingrid Nunes would like to for
CNPq grants ref. 313357/2018-8 and ref. 428157/2018-1, and the Coordena¸c˜ao
de Aperfei¸coamento de Pessoal de N´ıvel Superior - Brasil (CAPES) - Finance
Code 001. Jo˜ao Faccin would like to acknowledge the support of the National
Council for Scientiﬁc and Technological Development of Brazil (CNPq) (grant
ref. 141840/2016-1), and the support of the Government of Canada through the
Emerging Leaders in the Americas Program (ELAP) program.

References

Bagherzadeh M, Kahani N, Bezemer CP, Hassan AE, Dingel J, Cordy JR (2018)
Analyzing a decade of linux system calls. Empirical Software Engineering
23(3):1519–1551

Bertero C, Roy M, Sauvanaud C, Tr´edan G (2017) Experience report: Log mining
using natural language processing and application to anomaly detection. In:
2017 IEEE 28th International Symposium on Software Reliability Engineering
(ISSRE), IEEE, pp 351–360

Bootlin (2020) Embedded Linux kernel and driver development training. CreateS-
pace Independent Publishing Platform, URL https://github.com/bootlin/
training-materials

Boslaugh S (2012) Statistics in a nutshell: A desktop quick reference. ” O’Reilly

Media, Inc.”

Chen B, Jiang ZM (2017a) Characterizing and detecting anti-patterns in the log-
ging code. In: 2017 IEEE/ACM 39th International Conference on Software En-
gineering (ICSE), IEEE, pp 71–81

Chen B, Jiang ZMJ (2017b) Characterizing logging practices in java-based open
source software projects–a replication study in apache software foundation. Em-
pirical Software Engineering 22(1):330–374

Chen B, Jiang ZMJ (2019) Extracting and studying the logging-code-issue-
introducing changes in java-based large-scale open source software systems. Em-
pirical Software Engineering 24(4):2285–2322

Cinque M, Cotroneo D, Natella R, Pecchia A (2010) Assessing and improving
the eﬀectiveness of logs for the analysis of software faults. In: IEEE/IFIP In-
ternational Conference on Dependable Systems & Networks (DSN), IEEE, pp
457–466

Corbet J (2012) The perils of pr info(). LWN net
Corbet J (2016) Tracepoint challenges. LWN net
Corbet J, Rubini A, Kroah-Hartman G (2005) Linux Device Drivers: Where the

Kernel Meets the Hardware. ” O’Reilly Media, Inc.”

Ding R, Zhou H, Lou JG, Zhang H, Lin Q, Fu Q, Zhang D, Xie T (2015) Log2:
A cost-aware logging mechanism for performance diagnosis. In: Proceedings of
the 2015 USENIX Conference on Usenix Annual Technical Conference, USENIX
Association, USA, USENIX ATC ’15, p 139–150

Edge J (2019) Unifying kernel tracing. LWN net

46

Keyur Patel et al.

El-Masri D, Petrillo F, Gu´eh´eneuc YG, Hamou-Lhadj A, Bouziane A (2020) A sys-
tematic literature review on automated log abstraction techniques. Information
and Software Technology 122:106276

Fadel W (2011) Techniques for the abstraction of system call traces to facilitate
the understanding of the behavioural aspects of the linux kernel. In: Master’s
Thesis, Concordia University

Falleri J, Morandat F, Blanc X, Martinez M, Monperrus M (2014) Fine-grained
and accurate source code diﬀerencing. In: ACM/IEEE International Conference
on Automated Software Engineering, ASE ’14, Vasteras, Sweden - September
15 - 19, 2014, pp 313–324, DOI 10.1145/2642937.2642982, URL http://doi.
acm.org/10.1145/2642937.2642982

Fu Q, Zhu J, Hu W, Lou JG, Ding R, Lin Q, Zhang D, Xie T (2014) Where do
developers log? an empirical study on logging practices in industry. In: Compan-
ion Proceedings of the 36th International Conference on Software Engineering,
pp 24–33

Hamou-Lhadj A, Lethbridge TC (2002) Compression techniques to simplify the
analysis of large execution traces. In: Proceedings 10th International Workshop
on Program Comprehension, IEEE, pp 159–168

Hamou-Lhadj A, Lethbridge TC (2004) A survey of trace exploration tools and
techniques. In: Proceedings of the 2004 conference of the Centre for Advanced
Studies on Collaborative research, pp 42–55

Hassani M, Shang W, Shihab E, Tsantalis N (2018) Studying and detecting log-

related issues. Empirical Software Engineering 23(6):3248–3280

He P, Chen Z, He S, Lyu MR (2018) Characterizing the natural language descrip-
tions in software logging statements. In: Proceedings of the 33rd ACM/IEEE
International Conference on Automated Software Engineering, ACM, New York,
NY, USA, ASE 2018, pp 178–189, DOI 10.1145/3238147.3238193, URL http:
//doi.acm.org/10.1145/3238147.3238193

Islam MS, Khreich W, Hamou-Lhadj A (2018) Anomaly detection techniques
based on kappa-pruned ensembles. IEEE Transactions on Reliability 67(1):212–
229

Israeli A, Feitelson DG (2010) The linux kernel as a case study in software evolu-

tion. Journal of Systems and Software 83(3):485–501

Kc K, Gu X (2011) Elt: Eﬃcient log-based troubleshooting system for cloud com-
puting infrastructures. In: 2011 IEEE 30th International Symposium on Reliable
Distributed Systems, IEEE, pp 11–20

Khatuya S, Ganguly N, Basak J, Bharde M, Mitra B (2018) Adele: Anomaly de-
tection from event log empiricism. In: IEEE INFOCOM 2018-IEEE Conference
on Computer Communications, IEEE, pp 2114–2122

Lal S, Sardana N, Sureka A (2015) Two level empirical study of logging statements
in open source java projects. International Journal of Open Source Software and
Processes (IJOSSP) 6(1):49–73

Li H, Shang W, Hassan AE (2017) Which log level

should develop-
ers choose for a new logging statement? Empirical Software Engineering
22(4):1684–1716, DOI 10.1007/s10664-016-9456-2, URL https://doi.org/10.
1007/s10664-016-9456-2

Li H, Chen THP, Shang W, Hassan AE (2018) Studying software logging
using topic models. Empirical Softw Engg 23(5):2655–2694, DOI 10.1007/
s10664-018-9595-8, URL https://doi.org/10.1007/s10664-018-9595-8

The Sense of Logging in the Linux Kernel

47

Li H, Shang W, Adams B, Sayagh M, Hassan AE (2020) A qualitative study of the
beneﬁts and costs of logging from developers’ perspectives. IEEE Transactions
on Software Engineering

Li S, Niu X, Jia Z, Liao X, Wang J, Li T (2019a) Guiding log revisions by learning

from software evolution history. Empirical Software Engineering pp 1–39

Li Z, Chen TH, Yang J, Shang W (2019b) Dlﬁnder: Characterizing and detecting
duplicate logging code smells. In: 2019 IEEE/ACM 41st International Confer-
ence on Software Engineering (ICSE), IEEE, pp 152–163

Liu Z, Xia X, Lo D, Xing Z, Hassan AE, Li S (2019) Which variables should i log?

IEEE Transactions on Software Engineering pp 1–1

Lotufo R, She S, Berger T, Czarnecki K, Wasowski A (2010) Evolution of the
linux kernel variability model. In: International Conference on Software Product
Lines, Springer, pp 136–150

Lu L, Arpaci-Dusseau AC, Arpaci-Dusseau RH, Lu S (2014) A Study of Linux
File System Evolution. ACM Transactions on Storage 10(1):1–32, DOI 10.1145/
2560012, URL https://dl.acm.org/doi/10.1145/2560012

Mazuera-Rozo A, Trubiani C, Linares-V´asquez M, Bavota G (2020) Investigating
types and survivability of performance bugs in mobile apps. Empirical Software
Engineering pp 1–43

Miranskyy A, Hamou-Lhadj A, Cialini E, Larsson A (2016) Operational-log anal-
ysis for big data systems: Challenges and solutions. IEEE Software 33(2):52–59
Oliner AJ, Aiken A, Stearley J (2008) Alert detection in system logs. In: 2008
Eighth IEEE International Conference on Data Mining, IEEE, pp 959–964
Panthaplackel S, Nie P, Gligoric M, Li JJ, Mooney RJ (2020) Learning to update

natural language comments based on code changes. 2004.12169

Passos L, Czarnecki K, Wasowski A (2012) Towards a catalog of variability
evolution patterns: the Linux kernel case. In: Proceedings of the 4th Inter-
national Workshop on Feature-Oriented Software Development - FOSD ’12,
ACM Press, Dresden, Germany, pp 62–69, DOI 10.1145/2377816.2377825, URL
http://dl.acm.org/citation.cfm?doid=2377816.2377825

Pecchia A, Cinque M, Carrozza G, Cotroneo D (2015) Industry practices and
event logging: Assessment of a critical software development process. In: 2015
IEEE/ACM 37th IEEE International Conference on Software Engineering,
IEEE, vol 2, pp 169–178

Pi A, Chen W, Zhou X (2018) Proﬁling distributed systems in lightweight virtu-
alized environments with logs and resource metrics. In: Proceedings of the 27th
International Symposium on High-Performance Parallel and Distributed Com-
puting, Association for Computing Machinery, New York, NY, USA, HPDC
’18, p 9–10, DOI 10.1145/3220192.3220197, URL https://doi.org/10.1145/
3220192.3220197

Ran CA (2019) Studying and leveraging user-provided logs in bug reports for de-
bugging assistance, URL https://spectrum.library.concordia.ca/985950/
Shang W, Jiang ZM, Adams B, Hassan AE, Godfrey MW, Nasser M, Flora P
(2014) An exploratory study of the evolution of communicated information
about the execution of large software systems. Journal of Software: Evolution
and Process 26(1):3–26, DOI 10.1002/smr.1579, URL https://onlinelibrary.
wiley.com/doi/abs/10.1002/smr.1579, https://onlinelibrary.wiley.com/
doi/pdf/10.1002/smr.1579

48

Keyur Patel et al.

Shang W, Nagappan M, Hassan AE (2015) Studying the relationship between log-
ging characteristics and the code quality of platform software. Empirical Soft-
ware Engineering 20(1):1–27

Sigelman BH, Barroso LA, Burrows M, Stephenson P, Plakal M, Beaver D, Jas-
pan S, Shanbhag C (2010) Dapper, a large-scale distributed systems tracing
infrastructure. Tech. rep., Google, Inc., URL https://research.google.com/
archive/papers/dapper-2010-1.pdf

Tian J, Rudraraju S, Li Z (2004) Evaluating web software reliability based on
workload and failure data extracted from server logs. IEEE Transactions on
Software Engineering 30(11):754–769

Tschudin PS, Lawall J, Muller G (2015) 3l: Learning linux logging. In: BElgian-

NEtherlands software eVOLution seminar (BENEVOL 2015)

Yang S, Park SJ, Ousterhout J (2018) Nanolog: A nanosecond scale logging system.
In: 2018 USENIX Annual Technical Conference (USENIX ATC 18), USENIX
Association, pp 335–350

Yen TF, Oprea A, Onarlioglu K, Leetham T, Robertson W, Juels A, Kirda E
(2013) Beehive: Large-scale log analysis for detecting suspicious activity in en-
terprise networks. In: Proceedings of the 29th Annual Computer Security Ap-
plications Conference, pp 199–208

Yuan D, Park S, Zhou Y (2012a) Characterizing logging practices in open-source
software. In: Proceedings of the 34th International Conference on Software En-
gineering, IEEE Press, pp 102–112

Yuan D, Zheng J, Park S, Zhou Y, Savage S (2012b) Improving software diagnos-
ability via log enhancement. ACM Trans Comput Syst 30(1):4:1–4:28, DOI 10.
1145/2110356.2110360, URL http://doi.acm.org/10.1145/2110356.2110360
Zeng Y, Chen J, Shang W, Chen THP (2019) Studying the characteristics of
logging practices in mobile apps: a case study on f-droid. Empirical Software
Engineering 24(6):3394–3434

Zhao X, Rodrigues K, Luo Y, Stumm M, Yuan DY, Zhou Y (2017) The game of
twenty questions: Do you know where to log? In: 16th Workshop on Hot Topics
in Operating Systems (HotOS), pp 125—-131

Zhou R, Hamdaqa M, Cai H, Hamou-Lhadj A (2020) Mobilogleak: A preliminary
study on data leakage caused by poor logging practices. In: 2020 IEEE 27th
International Conference on Software Analysis, Evolution and Reengineering
(SANER), IEEE, pp 577–581

Zhu J, He P, Fu Q, Zhang H, Lyu MR, Zhang D (2015) Learning to log: Helping
developers make informed logging decisions. In: Proceedings of the 37th Interna-
tional Conference on Software Engineering - Volume 1, IEEE Press, Piscataway,
NJ, USA, ICSE ’15, pp 415–425, URL http://dl.acm.org/citation.cfm?id=
2818754.2818807

