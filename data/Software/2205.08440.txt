Moving Smart Contracts â€“ A Privacy Preserving
Method for Off-Chain Data Trust

Simon Tschirner, Shashank Shekher Tripathi, Mathias RÃ¶per, Markus M. Becker and Volker Skwarek

1

2
2
0
2

y
a
M
8
1

]

R
C
.
s
c
[

2
v
0
4
4
8
0
.
5
0
2
2
:
v
i
X
r
a

Abstractâ€”Blockchains provide environments where parties
can interact transparently and securely peer-to-peer without
needing a trusted third party. Parties can trust the integrity
and correctness of transactions and the veriï¬able execution of
of binary code on the blockchain (smart contracts) inside the
system. Including information from outside of the blockchain
remains challenging. A challenge is data privacy. In a public
system, shared data becomes public and, coming from a single
source, often lacks credibility. A private system gives the parties
control over their data and sources but trades in positive aspects
as transparency. Often, not the data itself is the most critical
information but the result of a computation performed on it.

An example is research data certiï¬cation. To keep data private
but still prove data provenance, researchers can store a hash value
of that data on the blockchain. This hash value is either calculated
locally on private data without the chance for validation or
is calculated on the blockchain, meaning that data must be
published and stored on the blockchainâ€”a problem of the overall
data amount stored on and distributed with the ledger.

A system we called moving smart contracts bypasses this
problem: Data remain local, but trusted nodes can access them
and execute trusted smart contract code stored on the blockchain.
This method avoids the system-wide distribution of research data
and makes it accessible and veriï¬able with trusted software.

Index Termsâ€”blockchain, smart contract, trusted software,

oracles

I. INTRODUCTION

T WO main features of distributed ledger or blockchain

technology are data decentralization and immutability.
These features lead to trust and transparency in the system.
Public permissionless systems ensure most transparency, as
they allow anyone to join the network, receive a copy of
the stored information and participate in the consensusâ€”the
process of deciding what
transactions to be added to the
ledger. Naturally, the architecture of blockchains mandates the
accessibility of the data generally to be public [1]. Therefore,
this architecture is infeasible in scenarios dealing with data
that has to be (temporarily) private such as sensitive data
or intellectual property. The development private distributed
ledgers addresses this problem [2] (e. g., Hyperledger Fabric
[3]). However, private platforms reduce the beneï¬cial core
properties of blockchains: decentralization and transparency
[4], while consortia platforms usually still allow public data
access.

Simon, Shashank, Mathias and Volker are with the Research and Transfer
Centre - Digital Business Processing, Faculty of Life Sciences, Hamburg
University of Applied Sciences, Ulmenliet 20, 21033 Hamburg, Germany.
Corresponding authorâ€™s e-mail: shashank.tripathi@haw-hamburg.de.

Markus is with the Leibniz Institute for Plasma Science and Technology

(INP), Felix-Hausdorff-Str. 2, 17489 Greifswald, Germany.

A distributed ledger creates a closed environment, allowing
participants to trust information and computations by programs
stored and executed within it (so-called smart contracts).
However, this separate environment poses another challenge:
The interaction between a blockchain and the outside world,
which is usually conducted by distributed ledger technology
(DLT) oracles [1]. Oracles are services updating a ledger with
off-chain data [5]. However, data from outside a blockchain
(off-chain data) cannot have the same level of trust as data
originated from within it. Furthermore, DLT oracles fail to
handle situations where data is intellectual property or too
large to be written on a blockchain. In many cases, the result
of a computation based on off-chain data is as signiï¬cant
as the data itself. A way to make computation trustworthy
is to conduct it on-chain. However, on-chain execution costs
become a challenge because each block building node (miner)
has to execute the smart contract computing the introduced
data. In large networks, this is resource-consuming.

This paper provides a solution to the described problem of
introducing a trusted state to a blockchain network based on
sensitive and/or big off-chain data. The proposed concept is
called moving smart contracts. Moving smart contracts provide
trusted (reviewed) software, controlled by the blockchain, to
a user on request. Furthermore,
the network includes so-
called notaries. A notary is a trusted and authorized full-node
that offers off-chain execution using on-chain stored trusted
software as a service. Therefore, a notary can validate any
result by repeating a previously conducted computation using
the same software and data. If a user wants an on-chain state
to be ï¬‚agged as validated (and therefore to be trustworthy),
the raw data needs only to be made accessible to a notary.
Furthermore, since the software for off-chain computation is
provided by the blockchain, all actors can rely in its integrity
and are able to reproduce results.

The primary research objective is to answer the following
research question: What process must be deï¬ned to make a
result based on potentially private and large off-chain data to
be trustworthy within a blockchain network?

Certiï¬cation of research data is a speciï¬c example, requiring
complex computations and data privacy. A certiï¬cate usually
includes storing a hash value of the original research data
on a blockchain [6]. On one hand, research data can involve
intellectual property that should remain private before formal
publication. On the other hand, this data can include vast
amounts of data, meaning that hash value calculation is
resource-consuming. This example solves all three require-
ments for the application of moving smart contracts. Data
shall remain private, the computation can be very resource-

 
 
 
 
 
 
consuming, and the computation result is as valuable as the
input data. Therefore, this example is the perfect use case to
evaluate moving smart contracts.

The secondary objective is thus to implement the use case

of research data certiï¬cation using moving smart contracts.

The remainder of this paper is structured as follows. After
discussing the related work and background in section II, a
theoretical model describes the concept in section III in detail.
A detailed description of the implementation of academic data
sharing in section IV demonstrates the practical feasibility.
Before the conclusion (section VI), in section V an evaluation
explores the degree to which moving smart contracts solve the
use case and their limitations.

II. BACKGROUND

This section brieï¬‚y presents the state-of-the-art from a
theoretical point of view and discusses, how moving smart
contracts differ from other approaches.

A mechanism build solely for local machines face many
kinds of threats like attacks on control ï¬‚ow of program,
masquerading malicious code, malevolent writes to memory
or run-time attack. A hostile unit can inject its own program
that will have all the permissions as the intended original
program [7]. Therefore, adding checks to the application is not
sufï¬cient to counter such attacks. A weakly written program is
also susceptible to attacks. A common example includes buffer
overï¬‚ows [8] that allows the adversary to modify arbitrary
memory locations for its beneï¬t. With the help of blockchain,
moving smart contracts addresses these threats.

A. Blockchains and Smart Contracts

A blockchain is a list of blocks containing transaction
data linked together with cryptographic hashes, constructing
a Merkle tree, distributed over several network peers (nodes).
Any change in a transaction would change the Merkle treeâ€™s
root address, eventually changing the address of a block.
Hence, the block is invalidated. With proper implementation of
consensus algorithms like Proof of Work, [9], Proof of Stake
[10], or Practical Byzantine Fault Tolerance [11], a blockchain-
based peer-to-peer network can become tamper-proof.

Buterin proposed the idea of the Ethereum blockchain
that can perform computations besides being a peer-to-peer
network [10]. Smart contracts are small programs, giving
rules for performing computations. Szabo ï¬rst proposed the
term smart contract in 1994 to refer to self-executing codes
[12]. In Ethereum, smart contracts are self-executing and
tamper-resistant programs deployed on the blockchain. Since
the execution of smart contracts happens on-chain, it utilizes
the nodesâ€™ resources. All consensus-creating nodes of the
respective blockchain network carry out the smart contract
execution in parallel; the resulting redundancy leads to high
computational and storage expenses. Therefore, it is common
for an application to use off-chain resources and oracles
[13], e.g., for computationally extensive processing and large
storage requirements.

In centralized systems, a central authority is responsible for
creating a valid state based on given transactions. Furthermore,

2

the users depend on the central authority to maintain their
assets, like money in the case of banks. Blockchains, on the
other hand, provide a system where participating peers make
decisions in the network reaching a consensus following a con-
sensus algorithm [14]. In terms of permission required for the
participation in consensus-creating procedures, blockchains
can be classiï¬ed into two major types:

a) Permissioned (consortia platforms): Only authorized
nodes are permitted to participate in consensus-creating pro-
cedures. Depending on the blockchainâ€™s governance design,
nodes can, for example, become authorized through voting
procedures. In some cases, there are different roles assigned
to nodes in hierarchical order. The most common examples
include Ripple and Eris.

b) Permissionless: Permissionless blockchains are pub-
licly accessible. Any user can join the network, become a node,
perform transactions, participate in creating consensus and
reading the transactions conducted by other network partici-
pants [15]. The typical examples of permissionless blockchains
are Bitcoin and Ethereum. The advantages of such blockchains
are a high degree of decentralization, transparency, and avail-
ability open source.

B. Adding External Information Into Blockchain Environments

An oracle is an agent that facilitates the interaction of a
blockchain with the external world [16], [17]. Usually, it is
a trusted third party in the system, which could be software
or a human feeding the data manually. Town Crier [18] and
Corda [19] have a single oracle responsible for data transfer.
Augur [20], Gnosis, MS Bletchley [21] and ChainLink [22]
propose to have multiple (independent) oracles. Multiple or-
acles vote for the correct answers mitigating the possibility
of a single-point-of-failure. Although oracles can address off-
chain communication, data integrity remains an issue. There
is a risk that data from oracles could be manipulated or bogus;
therefore, the smart contract at the receiving end must build
a mechanism for data check [23] but there is always a risk
at the intersection of on and off chain. Also, oracles work
in an external environment; consequently, undesired events
can obstruct the operation of the whole system. With the
concept of moving smart contracts, data/results written to the
blockchain can be validated by notaries. Errors in the off-chain
execution of software are made visible since the computation
is conducted in the process of validation by two independent
parties, using the same trusted software.

Blockchain technology, especially public blockchains, has
on-chain resource limitations making data storage infeasible in
case of enormous data size. Therefore, researchers have tried
to solve this problem by using off-chain storage. Eberhardt
and Tai [24] have discussed how off-chain computation and
storage can help resolve the on-chain issues. They have
considered ï¬ve applications where off-chain processing can
address on-chain limitations. They have discussed a method to
demonstrate how a large amount of data can be associated with
a smart contract. The reference to data stored in an addressable
content system is stored in the blockchain. The reference is
the hash of the data. Storing the hash as a variable of the

in this method,

smart contract ensures that a change of the data is detectable.
Although,
the addressable content system
has to be trusted for hosting the data. The other possible
solution includes decentralized storage systems, such as the
InterPlanetary File System (IPFS) [25]. However, IPFS has no
implementation of intellectual property management [26]. On
a technical level, the storage for big data ï¬les on a distributed
ï¬le system is not feasible as it requires resources from multiple
network participants. IPFS stores parts of a ï¬le at multiple
locations causing redundancy. Thus, ensuring data availability
even when a node in the network goes ofï¬‚ine. There are
some projects that explore the possibilities to ensure correct
execution, e.g., like Ethernity [27], via trusted environments,
this paper aims to choose a more straightforward approach
discussed in section III and IV.

C. Use Case â€“ Certiï¬cation of Research Data

Sharing of research data is an important aspect in open sci-
ence [28] and sometimes even required by research funds such
as by â€œGuidelines for Safeguarding Good Research Practiceâ€
of the German Research Foundation (DFG1). Especially in
data-driven science, provenance (authorship and integrity) and
reliability of data and metadata have to be proven. Therefore,
a neutral and immutable platform that researchers can use to
certify their data brings signiï¬cant beneï¬ts to the research
community [29]. The certiï¬cation consists of creating a hash
(serving as a ï¬ngerprint) of the research data, and storing this
hash together with a trusted timestamp on the blockchain.
At this stage, the certiï¬cation proves the existence of the
data at a particular time. Including further references to the
researcher/data origin to the on-chain certiï¬cate, provenance
can also be proven, even after publication.

One very common method for such an proof-of-existence
is publishing a data-certiï¬cate by their cryptographic hash
value. Later, this data can be veriï¬ed by its hash value as
it is sufï¬ciently pseudo-random and unique.

As the only issue,

the hash computation with a local
algorithm can be faked. The blockchain itself can only check
the validity of the hash, if this data is stored on the blockchain.
But this again shall be avoided due to its size. Consequently,
moving smart contracts provide a compromise: allowing initial
data privacy and later memory resources without trading in
trust entirely.

D. Bloxberg Blockchain Network

The Bloxberg consortium was founded in 2019 with the
aim of providing a blockchain for science, i.e. to establish an
alternative infrastructure for academic purposes [30]. At the
time of writing this paper, the consortium consists of around 40
academic institutions globally. Collectively, they are providing
the Bloxberg blockchain2.

Bloxberg is a consortial (public permissioned) blockchain
network based on Ethereum. Only academic institutions can be

1https://www.dfg.de/en/research_funding/principles_dfg_funding

last

access June 7, 2021

2https://bloxberg.org last access May 14, 2021

3

voted into the consortium; members are automatically entitled
(and required) to run a full node (participating in creating
the consensus). As consensus protocol, the Proof-of-Authority
algorithm Aura3 is used.

The academic orientation of Bloxberg ï¬ts well to the use
case of research data certiï¬cation, the primary use case to
evaluate the moving smart contracts in this paper. Additionally,
the authorâ€™s institution (HAW Hamburg) is a member of the
Bloxberg consortium, which allows deploying and testing the
server-side tool that is part of the suggested implementation.
Thus, Bloxberg is the natural choice for the exploration of
moving smart contracts.

III. MODEL

This section describes the idea of the moving smart con-
tracts in detail. It outlines the theoretical process, how parties
in the process can be assured to use the same software to
achieve a result based on off-chain data and how the moving
smart contract evaluates that the result is trustworthy. In other
words, a concept to introduce a validated state based on off-
chain data onto the blockchain.

A. General Idea

Given the usage of Bloxberg, this process is tailored toward
public permissioned blockchains. It utilizes the additional
portion of trust or stake (since the network needs to approve
on a new consortium member) that is connected to a full
node of the network. It further aims to transfer the possibility
of keeping data private from private blockchains onto public
blockchains.

There are four kind of actors, interacting with the moving
smart contract: The client, this is the party that owns or
provides the off-chain data, in the example of research data
certiï¬cation, this would be the researcher, the notary that can
act as a validator of the published provenance if requested by
the client, moving smart contract that provides and govern
the ecosystems and lastly, the peer can request the clientâ€™s
data and verify the results.

At ï¬rst, only the client obtains or holds the data to be
processed. The ï¬rst important difference when using moving
the software for the processing is
smart contracts is that
available via the blockchain. In the ï¬rst step,
the client
downloads that software and processes her data. The result
is written back on the blockchain and thus publicly available.
The result stored on the blockchain can prove data existence
at this stage, but it is impossible to guarantee the correct
execution of the software stored on the blockchain. However,
instead of utilizing complex solutions, moving smart contracts
rely on the validation of Aliceâ€™s execution in later steps.

in the data. The basic idea is that

The second step is an optional step for pre-public validation
to increase trust
the
researcher selects a trusted notary in the blockchain network.
The researcher can now transfer his data conï¬dentially to Bob,
who can validate and conï¬rm or create the PoE-hash. As the
notary node is part of the blockchain, it uses and accesses

3https://openethereum.github.io/Aura last access May 14, 2021

the validated and trusted veriï¬cation smart contracts on the
blockchain.

At last, during the third step, three options exist.
â€¢ The researcher can publicly share data by adding its
access link to the PoE on the blockchain, and the refer-
ence to the written publication including scripts or smart
contracts for evaluation. Now everyone can download the
data and software stored on the blockchain to validate the
results independently.

â€¢ Alternatively,

the researcher can decide to share data
privately with selected partners. They will need the same
information as before (link to data, software, and result),
including, e. g., credentials to access the data.

â€¢ As a last option it is possible to withdraw the result. If
for some reason, the researcher decides not to share data
or results anymore, he can use a smart contract on the
blockchain to mark the previously submitted PoE or even
results as invalid.

In summary, the steps to be covered by moving smart contracts
are:

1) Proof of existence (certiï¬cation)â€”the client processes

its data and stores the result on the blockchain.

2) Validationâ€”the client picks a notary to conï¬rm the

result from the previous step.

3) Further steps

a) Publicationâ€”client decides to share its data pub-
licly; everyone will be able to access the clientâ€™s
data and to validate the certiï¬cate/processing.
b) Private sharingâ€”client decides to share its data
privately, a selected peer gets access to the data
protected by credentials; the peer can access the
clientâ€™s data and validate the certiï¬cate/processing.

c) Withdrawalâ€”client withdraws result.

Having the certiï¬cate additionally validated by a notary (the
second step above) is optional in this scenario. However, using
a notary, the network has strong evidence that the data existed,
and Alice rests assured that later validation of the certiï¬cate
will succeed.

B. Process ï¬‚ow of privacy preserving research data publica-
tion and moving smart contracts

This section gives a more technical perspective on moving

smart contracts based on the steps presented above.

The process starts with the initial certiï¬cation or PoE. In
ï¬gure 1, the researcher wants to create a proof of existence
for his data. The software needed for this certiï¬cation is
stored on or is accessible via the blockchain. The moving
smart contractâ€”an actual smart contract deployed on the
blockchainâ€”transfers the software for the certiï¬cation request
to the client. The client processes the data and returns the result
to the moving smart contract, which takes care of storing the
result on the blockchain. From now on, the client can prove
that the data processing happened at a particular time.

The sub-step process data takes place in several steps. It
means that the active part processes the data with a piece
of software. In the typical case, the software will always be
the same in one instance of the process, as the moving smart

4

Fig. 1. Step 1: A client processes its data and stores the result on the
blockchain (proof-of-existence).

Fig. 2. Step 2: A client selects a notary to verify its result from the ï¬rst step.

contract provides it. The data should, in any case, be the data
that the client initially processed. If not, any later processing
will yield a different result.

The previous proof has one problem: As long as no other
trusted party conï¬rms it, this self-certiï¬cation is of limited
value. The optional second step (see Figure 2) increases trust:
A notary within the blockchain networkâ€“a node of higher and
central trustâ€”gets the task to validate the certiï¬cation from
the previous step. In order to do so, the client sends a validator
package to the moving smart contract.

The validator package is a data structure consisting of the

following:

â€¢ recipientâ€”optional, but as long as data privacy is an
issue, these packages address a certain receiver, either
a peer or a notary,

â€¢ reference to on-chain dataâ€”optional, a reference to the

result the client initially stored on the blockchain,

â€¢ software referenceâ€”a reference to the required software
that reproduces the processed data from the raw data on
the client,

â€¢ external data referenceâ€”typically a URL under which the

original data is accessible,

â€¢ credentialsâ€”optional, credentials needed to access the

data, in case it is to be kept private.

in this case,

The moving smart contract uses the receiver information
to notify,
the notary. The notary can accept
the package, and, in consequence, the moving smart contract
pushes the software onto the notary. The notary then reads the
data, which shall be veriï¬ed, on a separate channel outside

5

Fig. 3. Step 3a: A client publishes the original data, similar to step 2, a node
from the blockchain network veriï¬es the clientâ€™s result before the data can be
published.

Fig. 4. Step 3b: A peer request to (privately) receive the clientâ€™s data, only
when the peer conï¬rms the clientâ€™s result, integrity of the data is proven

the blockchain from the client. This sub-step is also common
to several steps. It includes receiving the location of the data
(request data(URL)) to process and its retrieval (access data),
in this case,
to retain data
typically requiring credentials,
privacy.

The notary now processes the data and returns his result
to the moving smart contract. In the recurring sub-step com-
pare/store, the moving smart contract compares the notaryâ€™s
result with the initially stored clientâ€™s result. A match yields
in conï¬rmation of the certiï¬cate, otherwise a refutation of
the validation. In the latter case, the client could renew the
validation request, as something might have gone wrong, e.g.,
during data transmission. However, retries should be limited.
the client might choose to publish her data
publicly. Figure 3 depicts this step. This step resembles the
previous step with a few differences: The validator package
does not contain a receiver and is publicly available via the
moving smart contract. Consequently, now any node of the
blockchain network may execute the validation step previously
done by the notary. On successful comparison, the moving
smart contract conï¬rms the publication.

Eventually,

Before publication, a client might also want to share her data
privately. Figure 4 depicts this step, and again, it resembles the
two previously described steps. However, in this step, the peer
initializes the process, asking the client for her data. According
to the request, the client creates another validator package,
this time directed towards the peer. The peer gets notiï¬ed
via the moving smart contract, software and data transfer to
and processing on the peer functions similarly. Afterward, the
peer writes the result back to the moving smart contract. The
moving smart contract compares the new result to the stored
result. A match conï¬rms data integrity, and the peer is free to
proceed with the transferred data, which can now be regarded
as validated.

The ï¬nal option is for the client to withdraw the data. As
depicted in ï¬gure 5, this step is relatively simple: The client
indicates withdrawal to a smart contract; after that, the smart
contract on the blockchain adds a note of withdrawal to the
information stored on the blockchain. The result should not

Fig. 5. Step 3c: Client withdraws the result from ï¬rst step.

be regarded as certiï¬ed anymore.

C. Software for execution uniformity

The software is either stored in a transaction on the
blockchain or on off-chain storage. In the latter case, design
patterns such as [31] ensure the integrity of the software, e.g.,
securing it with a hash stored on the blockchain (cf. [31],
Section 4.3).

The software can exist in the form of source code that
needs to be compiled ï¬rst, in the form of byte code or a
container. Each form has advantages and disadvantages. On
the one hand, source code is lightweight, but it requires an
executable environment installed on the systems supposed to
run the software. On the other hand, containers are complete
in terms of the environment but are bulkier than source code.
Additionally,
the software must guarantee the same result
independent of the used platform, which is more challenging
when compiling source code separately on each target.

At last, the software must be (manually) controlled ï¬rst.
Otherwise, it is possible to introduce malicious code to the
notary or any party to execute the software.

IV. IMPLEMENTATION

The goal of the implementation is to prove the feasibility
of the presented moving smart contracts. The implementation
covers step 1 and 2 from the previous section (see Figure 1
and 2). As discussed, steps 3a and 3b are, to a large extent,
similar to step 2. The main difference is that the third party
in step 2 is a notary, i.e., an actively selected node of the
blockchain network, while it can be any node of the blockchain

network in step 3a. In step 3b, the restriction of the third party
to be a member of the blockchain network does not apply
anymore. Therefore it is safe to assume that the feasibility of
implementation of step 1 and 2 implies the feasibility of step
3a and 3b. Due to its minimal extent, the implementation of
step 3c is omitted.

A. Implementation Details

The prototype system consists of

three components:
the client-side application,
the smart contract deployed to
Bloxberg (public permissioned blockchain), and the notary
side server application. The client-side and notary (server)-
side applications are programmed in the Python programming
language. The smart contract is written in Vyperâ€”a Python-
like programming language for Ethereum smart contract de-
velopment. Pseudo-code presents relevant parts of the imple-
mentation.

1) Client-Side Implementation: Clients are actors, e.g., re-
searchers, who use the provided functionalities of the system.
To do so, they use the client-side toolâ€”an application running
on their local computer. Since running an own node to interact
with the blockchain is not feasible for most clients, a trusted
third party node can serve as an entry point for blockchain
interaction.

in the client-side tool,

The pseudo-code in listing 1 shows the procedure to
certify data (cf. Figure 1),
in an
abstract way. The communication with the moving smart
contract, i.e., the smart contract deployed on Bloxberg im-
plementing the functionality of the moving smart contract,
happens via the sc_interface. The user is prompted
for the data path (e.g., on her local computer). The tool
then requests the software from the smart contract, compiles
it (create_executable_script), and runs it, passing
the data from the inserted path onto the executable. In this
example, the selected software calculates the hash value on
the passed data, the result is written back onto Bloxberg via
the smart contract interface.

Listing 1 Client certiï¬es data
1: procedure CERTIFY_DATA(ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’)
2:
3:

ğ‘  â† false
ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘ â† â€ğ» ğ´ğ‘†ğ»_ğ¹ğ‘ˆğ‘ğ¶ğ‘‡ ğ¼ğ‘‚ğ‘â€
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘ğ‘¡â„ â† user input
ğ‘ğ‘œğ‘‘ğ‘’ â† ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘’ğ‘ ğ‘¡_ğ‘ğ‘œğ‘‘ğ‘’(ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘)
ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š â† ğ‘ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’_ğ‘’ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘ğ‘ğ‘™ğ‘’_ğ‘ ğ‘ğ‘Ÿğ‘– ğ‘ğ‘¡ (ğ‘ğ‘œğ‘‘ğ‘’)
ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„ â† ğ‘’ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’( ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘ğ‘¡â„)
ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡_â„ğ‘ğ‘ â„ â† ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡ ()
ğ‘  â† ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’_ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘– ğ‘“ ğ‘–ğ‘ğ‘ğ‘¡ğ‘’(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„,

4:
5:
6:
7:
8:
9:

ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡_â„ğ‘ğ‘ â„, ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘)
return [ğ‘ , ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡]

10:
11:
12: end procedure

To perform the step of data validation via a notary (cf.
Figure 2), the clients use the tool for creating the requests
in the form of validator packages. Each validator package is
organized as an object within the dedicated smart contract.
Each contains information regarding who shall using what
code to process which data.

6

Listing 2 shows the procedure to create validator packages.
First, the tool prompts the user for all relevant input: IDs of
the notary and software to select and a URL pointing to the
data. Not shown in the pseudo-code: Users can also use the
tool to list possible notaries and software to choose from.
The next step involves the selection of the notary node of
interest. In principle, the selected notaries are the only party in
the blockchain network to access the clientsâ€™ data. However,
if data and its URL are provided unencrypted, anyone can
read the data, as the access to the information on Bloxberg
is public. If data should remain private, which typically is
the case for this step, users should select to use encryption.
First, the data storage requires credentials (data_pw) for data
transfer/decryption. Second, either the credentials or addition-
ally the provided URL need to be encrypted. If the data is to
be shared with a node of the blockchain network (which is part
of the deï¬nition of a notary), the tool uses that nodeâ€™s public
key for encryption, which is available through the blockchain
network, accessed via the smart contract interface.

ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡)

Listing 2 Client initiates data validation by notary
1: procedure INITIATE_DATA_VALIDATION(ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’,
2:
3:
4:
5:
6:
7:

ğ‘£ ğ‘ â† false
ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘ â† user input
ğ‘ ğ‘œ ğ‘“ ğ‘¡ğ‘¤ğ‘ğ‘Ÿğ‘’_ğ‘–ğ‘‘ â† user input
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™ â† user input
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤ â† user input
ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ğ‘’ğ‘‘ â† user input
if ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ğ‘’ğ‘‘ = true then

ğ‘ğ‘¢ğ‘_ğ‘˜ğ‘’ğ‘¦ â† ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘˜ğ‘’ğ‘¦(ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘)
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™ â† ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ (ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™, ğ‘ğ‘¢ğ‘_ğ‘˜ğ‘’ğ‘¦)
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤ â† ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ (ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤, ğ‘ğ‘¢ğ‘_ğ‘˜ğ‘’ğ‘¦)

8:
9:
10:
11:
12:

end if
ğ‘£ ğ‘ â† ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’_ğ‘£ ğ‘(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„,

ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤, ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ğ‘’ğ‘‘)

13:
14:
15:
return ğ‘£ ğ‘
16:
17: end procedure

After the tool has collected all information, the validator
package is created via the smart contract interface. The process
continues on the notary.

2) Notary-Side Implementation: A notary is a supervisory
node and, in this case, part of the Bloxberg network, i.e., a
public or private research institute, university, or organization.
A node needs to run the program shown in Listing 3 to become
a possible notary and register to the moving smart contract
(that functionality is available but omitted in this paper to
focus on the primary functionality).

Notaries continuously stay in listening mode. A notary
triggers when a client publishes a validator package on the
blockchain directed to the notary itself. The triggered notary
extracts information from the validator package lying on
the blockchain. On acceptance, the moving smart contract
transfers the software to the notary. If the client encrypted
data access, the notary uses its private key to decrypt the
information. The notary retrieves the data from the URL in
the validator package and processes it with the software it

ğ¾ ğ¸ğ‘Œ â† ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ƒğ‘…ğ¼ğ‘‰ ğ´ğ‘‡ ğ¸_ğ¾ ğ¸ğ‘Œ
while true do

Listing 3 Receive and process validator package
1: procedure VALIDATE_DATA(ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’, ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘)
2:
3:
4:
5:
6:

vp â† ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘”ğ‘’ğ‘¡_ğ‘£ ğ‘(ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘)
ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„ â† ğ‘£ ğ‘ [â€ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„â€]
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™ â† ğ‘£ ğ‘ [â€ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™â€]
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤ â† ğ‘£ ğ‘[â€ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤â€]
if ğ‘£ ğ‘[â€ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ğ‘’ğ‘‘â€] = true then

ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™ â† ğ‘‘ğ‘’ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ (ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™, ğ¾ ğ¸ğ‘Œ )
ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤ â† ğ‘‘ğ‘’ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ (ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤, ğ¾ ğ¸ğ‘Œ )

end if
ğ‘ğ‘œğ‘‘ğ‘’ â† ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘ğ‘ğ‘ğ‘’ ğ‘ğ‘¡ (ğ‘£ ğ‘)
ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š â† ğ‘ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’_ğ‘’ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘ğ‘ğ‘™ğ‘’_ğ‘ ğ‘ğ‘Ÿğ‘– ğ‘ğ‘¡ (ğ‘ğ‘œğ‘‘ğ‘’)
ğ‘‘ğ‘ğ‘¡ğ‘ â† ğ‘Ÿğ‘’ğ‘¡ğ‘Ÿğ‘–ğ‘’ğ‘£ğ‘’_ğ‘‘ğ‘ğ‘¡ğ‘(ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤)
ğ‘›_â„ğ‘ğ‘ â„ â† ğ‘’ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’( ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š, ğ‘‘ğ‘ğ‘¡ğ‘)
ğ‘ ğ‘_ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿ ğ‘“ ğ‘ğ‘ğ‘’.ğ‘ ğ‘’ğ‘›ğ‘‘_ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ (

ğ‘£ ğ‘, ğ‘›_â„ğ‘ğ‘ â„)

7:
8:
9:
10:
11:
12:

13:
14:
15:
16:
17:

end while

18:
19: end procedure

received from the moving smart contract. After execution, the
notary sends the validator package alongside its result back to
the moving smart contract; the notary cleared the validation
package.

3) Moving Smart Contract Implementation: This subsec-
tion describes the implementation of the moving smart con-
tract, which is deployed on the Bloxberg blockchain. The
moving smart contract is the main communication medium
for clients and notaries; it brings together the previous two
subsections. It also keeps track of the available software,
the available notary nodes, created and published results,
and the publication of validator packages. In the context
of the underlying use case, the software represents solely
hashing algorithms written in Python. The prototype includes
the algorithms of SHA-2 (SHA-256) and SHA-3 (Keccak).
Consequently, the execution of the code results in hashes that
can be interpreted as certiï¬cates and prove the existence of
the research data. These are the results stored on Bloxberg.

The moving smart contract deï¬nes a couple of structures

(structs), depicted in Figure 6.

Both notary nodes and software are organized as objects and
stored within callable and extendable registers (hash tables).
Since the content lies on the blockchain, an append-only data
structure,
the content added to the hash tables cannot be
altered afterward. It applies to the stored software as well.
Therefore, and because it will be executed on blockchain
nodes, the software must be peer-reviewed and able to execute
or compile. Additionally, large software should be stored off-
chain, secured with an on-chain hash-value for veriï¬cation.
The implemented hashing algorithms used in the example are
small enough to be stored on-chain. They can be retrieved
via the get_code procedure. This procedure returns the
elements of the code hash table stored under the given name.
The moving smart contract adds new execution results, in
this case certiï¬cates, in the cert hash table. This procedure
is shown in Listing 4. The proposed implementation takes

7

Fig. 6. Architecture of the smart contract

advantage of a requirement from the use case: The result is
always a hash value of the research data that is unique and
can be used as a key for the hash table. Other use cases would
require the creation of a separate hash key. The ï¬rst step is to
assert the novelty of the result to add. If this assertion fails,
the research data has already been certiï¬ed before; another
certiï¬cation is not allowed. Otherwise,
the certiï¬cation is
added alongside a timestamp and a hashed secret. The hashed
secret is an additional way to prove ownership: only the client
originally requesting certiï¬cation knows the secret. To initiate
further steps in the process of certiï¬cation (depicted in Figure
2 to 5), a client would need to reveal this secret to the moving
smart contract. This prevents third parties from initiation of
further steps.

ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡)

Listing 4 Certify data (smart contract functionality)
1: procedure SEND_DATA_HASH(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘,
2:
3:

# Abort execution if data is already certiï¬ed
assert ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘›ğ‘’ğ‘¤_ğ‘’ğ‘›ğ‘¡ğ‘Ÿ ğ‘¦(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„)
4:
# Create certiï¬cate on-chain
5:
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘¡ğ‘–ğ‘šğ‘’ğ‘ ğ‘¡ğ‘ğ‘š ğ‘ â† ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘¡ğ‘–ğ‘šğ‘’()
6:
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡_â„ğ‘ğ‘ â„ â† ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡
7:
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘ â† ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘
8:
return true
9:
10: end procedure

Listing 5 is the counterpart to the clientâ€™s validation request
Listing 2. It starts with two assertions to ensure that the data to
validate exists and the initiation request includes the correct
secret. Since the secret is now revealed, it is replaced with
another secret to authenticate future access to that certiï¬cate.
If everything is correct, the moving smart contract creates a
validator package based on the received parameters and places
the validator package so that the notary can ï¬nd it.

On acceptance, the notary calls the smart contract procedure
accept_vp in Listing 6. First, the moving smart contract
makes sure that the caller is the notary speciï¬ed in the valida-

Listing 5 Request validation (smart contract functionality)

ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘, ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤,
ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ğ‘’ğ‘‘, ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ‘›ğ‘’ğ‘¤_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡_â„ğ‘ğ‘ â„)

1: procedure REQUEST_VALIDATION(
2:
3:
4:
5:
6:

# Abort execution if data is not certiï¬ed
assert ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘–ğ‘ _ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘– ğ‘“ ğ‘–ğ‘’ğ‘‘ (ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„)
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘¢ğ‘ ğ‘’ğ‘‘_ğ‘ğ‘œğ‘‘ğ‘’ â† ğ‘¢ğ‘ ğ‘’ğ‘‘_ğ‘ğ‘œğ‘‘ğ‘’
# Abort execution if wrong secret is provided
assert ğ‘â„ğ‘’ğ‘ğ‘˜_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡ (ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡)
# Renew secret hash
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡_â„ğ‘ğ‘ â„

ğ‘›ğ‘’ğ‘¤_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡_â„ğ‘ğ‘ â„

# Creating validation package
ğ‘£ ğ‘ â† ğ‘›ğ‘’ğ‘¤ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›_ğ‘ğ‘ğ‘ğ‘˜ğ‘ğ‘”ğ‘’(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„,

12:
ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘¢ğ‘Ÿğ‘™, ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¤, ğ‘’ğ‘›ğ‘ğ‘Ÿ ğ‘¦ ğ‘ğ‘¡ğ‘’ğ‘‘)
13:
# Make validation package available for notary
14:
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘™ğ‘ğ‘ğ‘’_ğ‘£ ğ‘(ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦_ğ‘–ğ‘‘, ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘£ ğ‘)
15:
return true
16:
17: end procedure

7:
8:
9:
10:

11:

tor package. It would also reveal if the certiï¬cate were non-
existent or no validator package had been created. Afterward,
it returns the code speciï¬ed in the validator package.

Listing 6 Accept validation package (smart contract function-
ality)
1: procedure ACCEPT_VP(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„)
2:
3:
4:
5:
6:

ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ â† ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘Ÿğ‘’ğ‘ğ‘‘_ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ_ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘’ğ‘ ğ‘ ()
# Abort execution if sender is not the requested...
# ... notary or certiï¬cate does not exist
assert ğ‘–ğ‘ _ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘’ğ‘ ğ‘¡ğ‘’ğ‘‘_ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ)
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘£ ğ‘.ğ‘ğ‘ğ‘ğ‘’ ğ‘ğ‘¡ğ‘’ğ‘‘ â† true
ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘ â† ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡.[ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘¢ğ‘ ğ‘’ğ‘‘_ğ‘ğ‘œğ‘‘ğ‘’
7:
ğ‘ğ‘œğ‘‘ğ‘’ â† ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘œğ‘‘ğ‘’(ğ‘ğ‘œğ‘‘ğ‘’_ğ‘–ğ‘‘)
8:
return ğ‘ğ‘œğ‘‘ğ‘’
9:
10: end procedure

Finally, after the client created a certiï¬cate and further a
validator package directed toward a notary, and after the notary
executed that validator package, the moving smart contract has
to evaluate the validation. The notary calls the smart contract
procedure shown in Listing 7. Again, this procedure starts with
an assertion to assure that the call from the notary is correct
and permitted. The moving smart contract now compares the
new result (i.e., hash) from the notary with the stored (i.e.,
calculated by the client) result in the certiï¬cate. On a match,
the validator package of that certiï¬cate is tagged as validated,
and a timestamp is added.

B. Implementation Results

To test the concept, the presented implementation needs
to be deployed on a running system. Therefore, the devel-
oped moving smart contract
is deployed on the Bloxberg
blockchain, while the client-side code can be run on any
personal computer. The server-side tool has to be deployed on
a Bloxberg node. For this, the node hosted by the RTC Digital

8

Listing 7 Validate data (smart contract functionality)
1: procedure SEND_NOTARY_RESULT(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘›_ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡)
2:
3:
4:
5:
6:

ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ â† ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘Ÿğ‘’ğ‘ğ‘‘_ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ_ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘’ğ‘ ğ‘ ()
# Abort execution if sender is not the requested...
# ... notary or certiï¬cate does not exist
assert ğ‘–ğ‘ _ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘’ğ‘ ğ‘¡ğ‘’ğ‘‘_ğ‘›ğ‘œğ‘¡ğ‘ğ‘Ÿ ğ‘¦(ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„, ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ)
# Check if results (hashes) match
ğ‘šğ‘ğ‘¡ğ‘â„ â† (ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„ = ğ‘›_ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡)
if ğ‘šğ‘ğ‘¡ğ‘â„ then

ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘£ ğ‘.ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’ğ‘‘ â† true
ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘ğ‘’ğ‘Ÿğ‘¡ [ğ‘‘ğ‘ğ‘¡ğ‘_â„ğ‘ğ‘ â„].ğ‘£ ğ‘.ğ‘¡ğ‘–ğ‘šğ‘’ğ‘ ğ‘¡ğ‘ğ‘š ğ‘

â†

7:
8:
9:
10:

11:

â†

ğ‘ ğ‘’ğ‘™ ğ‘“ .ğ‘¡ğ‘–ğ‘šğ‘’()
end if
return ğ‘šğ‘ğ‘¡ğ‘â„

12:
13: end procedure

Business Processes at
the University of Applied Sciences
Hamburg was available. This section summarizes the results
that could be observed during implementation and test runs.
The test run was successful, as the client used the software
stored in the moving smart contract and added a hash of
arbitrary data to Bloxberg. The client could also invoke
validation of the hash by the notary via the moving smart
contract. Finally, the comparison performed by the moving
smart contract reported a match.

Since data privacy is a concern in this project,

it was
necessary to use encryption in order to prevent access to
the data via the information posted on the blockchain. The
availability of public keys of the blockchain nodes is suitable
here.

The ability to deploy and call smart contracts is a necessity
to implement the presented concept. On Bloxberg, everyone
can access the (public) blockchain, add and call new smart
contracts via an open accessible node (hosted by the Max
Planck Digital Library). Also, the internal Bloxberg crypto-
currency â€œBergâ€, needed for transaction fees, is available via
a faucet at no cost. In the presented case, it turned out to be an
advantage to let clients use the open accessible node instead
of their notary to interact with the moving smart contract.
Otherwise, a malicious notary could misuse its power of being
both, a notary and access provider at the same time.

The test runs also revealed certain limitations of the concept.
Foremost, the process of creating executable scripts based on
source code stored on the blockchain turned out to be error-
prone. Since the source code is handled as a string, little
errors such as missing line breaks can cause syntax violations
and, ï¬nally, compilation errors. This would be hard to control
the execution environment,
in a productive system. Also,
including the interpreter and available libraries, needs to offer
all necessities to make the scripts properly executable. The
source code must also be written following deï¬ned rules in
order to make the resulting scripts operable by the client/notary
tool. This includes rules deï¬ning the parameters for function
calls as well as return values.

Furthermore, the current state of the implementation lacks
processes to add new notary nodes or software/source code.
Trustable notaries and reviewed software build the foundation

of the presented concept. Therefore, further implementations
need to include sophisticated governance concepts, controlling
the availability of both. Such concepts can be part of future
research works.

V. EVALUATION AND DISCUSSION

In the system described in this paper, there are four el-
ements: (1) parties (entities that can request and execute
software and retrieve and input data to that software), (2)
software, (3) data, and calculation (4) results. The calculation
result depends on the used software and data. The scenario
of research data certiï¬cation deï¬nes the software so that it
delivers the same result for the same input data, but it should
deliver a different result if the input data differs. This deï¬nition
describes a robust hash function.

The central goal of moving smart contract is to distribute the
software to the parties (clients, notaries, and peers) to make
sure that every party can handle given data in the same way.
Combined, this implies that parties receiving their software
via the moving smart contract deliver the same result when
processing the same input data. The implementation results
have conï¬rmed this behavior.

There are two possibilities for deviating outcomes when
two parties are processing data with software provided by
the moving smart contract: (1) the two parties used different
software, or (2) the two parties used different input data. Since
the presented implementation does not control execution, if
the used software is the same as the one transferred, they can
cheat. However, a client has little incentive to cheat. If she
decides to do so, her results will probably never be validated.
So while having the possibility to introduce a manipulated
state into the system, it will not be possible to validate the
result by a notary, i.e. the added state will eventually become
useless. Consequently, the only reason to add such information
to the blockchain would be to block a notary. Therefore, in
the future, one needs to take measures to avoid such behavior.
The concept, even more, limits the incentive for notaries
to cheat. In principle, they can report any result back to the
moving smart contract. They can validate a result without
checking it; in this case, at the latest, after complete publica-
tion (i.e., disclosure of the processed data by the client), any
party will be able to (in-) validate the result, thereby proving
the notaryâ€™s misbehavior. They can also choose to invalidate
a result on purpose. In this case, the client could choose to
publish her data or let another notary validate her result. Even
this could be proof of notary misbehavior. For notaries, proven
misconduct can have a severe effect. This paper suggests
moving smart contracts, especially for consortium blockchains.
Misbehavior could lead to a ban from the consortium. For
research institutions, as in the case of the Bloxberg blockchain,
such a ban could result in a very negative impact on the
institutionâ€™s reputation.

Similarly, parties could cheat regarding the used data. The
results would be similar. However, a client could deliberately
share incorrect data with a notary and the correct data with
another notary to collect proof for the misbehavior of a
particular notary. There are possible solutions to this problem

9

(e.g., parties could be required to do a handshake on data).
Additionally, one could argue that there is no motivation for
a notary to fail a validation; therefore, such cases should
be irrelevant for judging a notary. Finally, this paper aims
to present a concept that introduces a trusted state onto the
blockchain based on off-chain data. If a client decides to
misuse the system to undermine the credibility of a notary,
it ï¬rst undermines the credibility of her data.

The discussion above does not include errors resulting from
accidents. Data could get corrupted during transportation, a
client could advertise the wrong software, or a client could
forget about the secret she stored together with her result (see
implementation details). Discussing such problems will remain
part of future research and development and is out of the scope
of the present work.

VI. CONCLUSIONS

This paper presented and evaluated the concept of moving
is to
smart contracts. The basic idea behind this concept
deploy a smart contract that administers software available via
a blockchain. When a new state on the blockchain is based on
off-chain data, involved parties can always rely on the moving
smart contract to provide the same software (guaranteed by
its availability on the blockchain) to process that data. In
this way, the initial processing of the off-chain data can be
repeated and validated by other parties that gain access to the
original dataâ€”the introduced state on the blockchain gains
trust. Furthermore, the notary is introduced. A notary is a node
of the blockchain network selected by the client, introducing
the off-chain data. The concept of the moving smart contracts
allows the notary to validate the clientâ€™s data processing result
and, as such, the state introduced on the blockchain.

Research data certiï¬cation proved to be a good use case to
evaluate the concept. In this, research data is hashed and the
hash is stored on the blockchain to prove data provenance later
on. Every party (re-)producing the hash must use precisely the
same algorithm to create the hash value. If every party uses the
same piece of software, this is guaranteed. Additionally, data
privacy can be a concern early on in the research publication
process. This paper presented the implementation of research
data certiï¬cation using moving smart contracts. The moving
smart contract administered software for hashing and spread
this to the client and notary in the implementation. The parties
successfully performed certiï¬cation and validation.

While there is undoubtedly future research and development
work left (e.g. the processes to add and review new software
and notaries need to be developed,
the way to store and
execute the software needs to be more robust) the present
implementation convinced that the concept of moving smart
contracts is feasible and adds a new way to introduce trusted
states based on off-chain data onto the blockchain.

ACKNOWLEDGMENT

The work was funded by the German Federal Ministry
of Education and Research (BMBF) under the grant marks
16QK03A and 16QK03C. The responsibility for the content
of this publication lies with the authors.

10

[23] H. Al-Breiki, M. H. U. Rehman, K. Salah, and D. Svetinovic, â€œTrust-
worthy blockchain oracles: Review, comparison, and open research
challenges,â€ IEEE Access, vol. 8, pp. 85 675â€“85 685, 2020.

[24] S. T. Jacob Eberhardt, â€œOn or off the blockchain? insights on off-
chaining computation and data,â€ pp. 3â€“15, 2017. [Online]. Available:
https://link.springer.com/chapter/10.1007/978-3-319-67262-5_1

[25] J. Benet, â€œIpfs - content addressed, versioned, p2p ï¬le system,â€ 2014.

[Online]. Available: https://arxiv.org/pdf/1407.3561

[26] K. Ito and M. Oâ€™Dair, â€œA critical examination of the application of
blockchain technology to intellectual property management,â€ in Business
transformation through blockchain, H. Treiblmaier and R. Beck, Eds.
[Cham, Switzerland]: Palgrave Macmillan, 2019, pp. 317â€“335.

[27] NN,

decentralized

â€œSecure
controls,â€ European
2021.
pdf-document?pn=3793130&ki=A1&cc=EP&pd=20210317

privacy
130 A1,
https://data.epo.org/publication-server/

cloud
Patent Request EP

computing with
3

[Online]. Available:

793

[28] L. Paulet, F. Hoppe, D. Loffhagen, H. Sack, V. Skwarek, T. Tietz,
for Plasma
and M. M. Becker, Open Science
S. Tschirner,
Technology. Zenodo, Feb. 2020, The German Federal Ministry of
funded this work under grant
Education and Research (BMBF)
marks 16QK03A, 16QK03B, and 16QK03C.
[Online]. Available:
https://doi.org/10.5281/zenodo.3758137

[29] Simon Tschirner, Mathias Roeper , Katharina Zeuch, Markus M. Becker,
Laura Vilardell Scholten, and Volker Skwarek, Fostering Open Data
Using Blockchain Technology. SpringerLink, 2021.

[30] F. Kleinfercher, S. Vengadasalam, and J. Lawton, â€œbloxberg: The
trusted research infrastructure: Whitepaper.â€ [Online]. Available: https://
bloxberg.org/wp-content/uploads/2020/02/bloxberg_whitepaper_1.1.pdf
[31] J. Eberhardt and S. Tai, â€œOn or off the blockchain? insights on off-
chaining computation and data,â€ in Service-Oriented and Cloud Com-
puting, ser. Lecture Notes in Computer Science, F. de Paoli, S. Schulte,
and E. Broch Johnsen, Eds. Cham: Springer International Publishing,
2017, vol. 10465, pp. 3â€“15.

REFERENCES

[1] X. Xu, I. Weber, M. Staples, L. Zhu, J. Bosch, L. Bass, C. Pautasso, and
P. Rimba, â€œA taxonomy of blockchain-based systems for architecture
design,â€ in IEEE International Conference on Software Architecture
(ICSA).

IEEE, 2017, pp. 243â€“252.

[2] J. Bernal Bernabe, J. L. Canovas, J. L. Hernandez-Ramos, R. Torres
Moreno, and A. Skarmeta, â€œPrivacy-preserving solutions for blockchain:
Review and challenges,â€ IEEE Access, vol. 7, pp. 164 908â€“164 940,
2019.
[3] Linux

[Online].
https://www.hyperledger.org/wp-content/uploads/2020/03/

fabric whitepaper.â€

â€œHyperledger

Fundation,

Available:
hyperledger_fabric_whitepaper.pdf
of

[4] S. Kulhari, Building-blocks

a

data

revolution:
The uneasy case for blockchain technology to secure privacy
and identity, 1st
ser. Munich Intellectual Property Law
Center
Baden-Baden: Nomos, 2018, vol.
Band 35. [Online]. Available: https://www.nomos-elibrary.de/10.5771/
9783845294025/building-blocks-of-a-data-protection-revolution

- MIPLC Studies.

protection

ed.,

[5] International Organization for Standardization, â€œBlockchain and dis-

tributed ledger technologies â€” vocabulary.â€

[6] S. Tschirner, M. RÃ¶per, K. Zeuch, M. M. Becker, L. Scholten, and
V. Skwarek, â€œFostering open data using blockchain technology,â€ 2021.
[7] A. One, â€œSmashing The Stack For Fun And Proï¬t,â€ p. 25, 1996.
[Online]. Available: https://inst.eecs.berkeley.edu/{~}cs161/fa08/papers/
stack{_}smashing.pdf

[8] J. C. Foster, V. Osipov, N. Bhalla, N. Heinen, and D. Aitel, Buffer

Overï¬‚ow Attacks. Elsevier Inc., 2005.

[9] Satoshi Nakamoto, â€œBitcoin - open source p2p money,â€ 15-05-2021.

[Online]. Available: https://bitcoin.org/en/

[10] â€œEthereum whitepaper | ethereum.org,â€ 21-05-2021. [Online]. Available:

https://ethereum.org/en/whitepaper/

[11] B. L. Miguel Castro, â€œPractical byzantine fault

tolerance,â€ OSDI
â€™99: Proceedings of
the third symposium on Operating systems
design and implementation, pp. 173â€“186, 1999. [Online]. Available:
https://dl.acm.org/doi/10.5555/296806.296824

[12] Nick Szabo, â€œSmart contracts: Building blocks for digital markets,â€ 23-
01-2006. [Online]. Available: https://www.fon.hum.uva.nl/rob/Courses/
InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.
best.vwh.net/smart_contracts_2.html

[13] X. Liu, R. Chen, Y. Chen, and S. Yuan, â€œOff-chain data fetching archi-
tecture for ethereum smart contract,â€ in 2018 International Conference
on Cloud Computing, Big Data and Blockchain (ICCBB), 2018, pp. 1â€“4.
[14] D. Mingxiao, M. Xiaofeng, Z. Zhe, W. Xiangwei, and C. Qijun, â€œA
review on consensus algorithm of blockchain,â€ in 2017 IEEE Interna-
tional Conference on Systems, Man, and Cybernetics (SMC), 2017, pp.
2567â€“2572.

[15] Z. Zheng, S. Xie, H. Dai, X. Chen, and H. Wang, â€œAn overview of
blockchain technology: Architecture, consensus, and future trends,â€ in
2017 IEEE International Congress on Big Data (BigData Congress),
2017, pp. 557â€“564.

[16] Sin Kuang Lo, Xiwei Xu, Mark Staples, Lina Yao, â€œReliability analysis

for blockchain oracles.â€

[17] Xiwei Xu and others, â€œThe blockchain as a software connector,â€
2016. [Online]. Available: https://ieeexplore.ieee.org/abstract/document/
7516828

[18] F. Zhang, E. Cecchetti, K. Croman, A.

and E. Shi,
â€œTown crier: An authenticated data feed for smart contracts,â€ in
Proceedings of
the 2016 ACM SIGSAC Conference on Computer
and Communications Security, ser. CCS â€™16. New York, NY, USA:
Association for Computing Machinery, 2016, p. 270â€“282. [Online].
Available: https://doi.org/10.1145/2976749.2978326

Juels,

[19] R. G. Brown, J. Carlyle, I. Grigg, and M. Hearn, Corda: An Introduction.
Unpublished, 2016. [Online]. Available: https://www.researchgate.net/
proï¬le/ian_grigg/publication/308636477_corda_an_introduction

[20] J. Peterson, J. Krug, M. Zoltu, A. K. Williams, and S. Alexander,
â€œAugur: a decentralized oracle and prediction market platform,â€ arXiv:
Cryptography and Security, 2015.

[21] S. K. Lo, X. Xu, M. Staples, and L. Yao, â€œReliability analysis for
blockchain oracles,â€ Computers & Electrical Engineering, vol. 83, p.
106582, 2020.

[22] Y. Wang, H. Liu, J. Wang, and S. Wang, â€œEfï¬cient data interaction of
blockchain smart contract with oracle mechanism,â€ in 2020 IEEE 9th
Joint International Information Technology and Artiï¬cial Intelligence
Conference (ITAIC), vol. 9.

IEEE, 2020, pp. 1000â€“1003.

