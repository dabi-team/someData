2
2
0
2

g
u
A
6
2

]
h
p
-
t
n
a
u
q
[

1
v
0
2
8
2
1
.
8
0
2
2
:
v
i
X
r
a

1

Equivalence Checking of
Quantum Circuits with the ZX-Calculus
Tom Peham∗ Graduate Student Member, IEEE,
Lukas Burgholzer† Graduate Student Member, IEEE, Robert Wille∗‡ Senior Member, IEEE
∗Chair for Design Automation, Technical University of Munich, Germany
†Institute for Integrated Circuits, Johannes Kepler University Linz, Austria
‡Software Competence Center Hagenberg GmbH (SCCH), Hagenberg, Austria
lukas.burgholzer@jku.at
robert.wille@tum.de
tom.peham@tum.de
https://www.cda.cit.tum.de/research/quantum/

Abstract—As state-of-the-art quantum computers are capa-
ble of running increasingly complex algorithms, the need for
automated methods to design and test potential applications
rises. Equivalence checking of quantum circuits is an important,
yet hardly automated, task in the development of the quantum
software stack. Recently, new methods have been proposed that
tackle this problem from widely different perspectives. One of
them is based on the ZX-calculus, a graphical rewriting system
for quantum computing. However, the power and capability of
this equivalence checking method has barely been explored.
The aim of this work is to evaluate the ZX-calculus as a
tool for equivalence checking of quantum circuits. To this end,
it is demonstrated how the ZX-calculus based approach for
equivalence checking can be expanded in order to verify the
results of compilation ﬂows and optimizations on quantum
circuits. It is also shown that the ZX-calculus based method
is not complete—especially for quantum circuits with ancillary
qubits. In order to properly evaluate the proposed method, we
conduct a detailed case study by comparing it to two other
state-of-the-art methods for equivalence checking: one based
on path-sums and another based on decision diagrams. The
proposed methods have been integrated into the publicly available
QCEC tool (https://github.com/cda-tum/qcec) which is part of the
Munich Quantum Toolkit (MQT).

I. INTRODUCTION

Quantum computing [1] has had a surge in research endeav-
ors by academia and industry in recent years. While quantum
computers have not reached a stage of widespread practical
usability yet, they promise to outperform classical computers
in various important tasks, such as unstructured search, in-
teger factorization, optimization problems, the simulation of
molecules, and more [2]–[7]. To keep pace with the rapid
developments in quantum hardware, various tools have been
developed that help in designing corresponding applications.
Initially, a quantum computation is described as a sequence
of (high-level) quantum gates—somewhat similar to a classical
C program. However, just like assembly for a classical proces-
sor, the actual machine instructions that may be performed on
a given quantum processor are generally restricted to a small
(low-level) gate-set and might only allow interactions between
speciﬁc pairs of qubits. Therefore, in order to execute a given
circuit on quantum hardware, it needs to be compiled to a
representation that adheres to all constraints imposed by the
targeted device [8]–[11]. Since quantum computers are heavily
affected by noise and decoherence, it is paramount to optimize

circuits as much as possible in order to maximize the expected
ﬁdelity when running the circuit [12]–[16].

Since the compiled quantum circuit might be altered dras-
tically from its original high-level description, it is of utmost
importance that the circuit to be executed on the hardware
still implements the same functionality as originally intended.
Veriﬁcation of compilation results or, more generally, equiv-
alence checking of quantum circuits,
to be an
extremely complex, even QMA-complete1 [17], task and is in
dire need of automation. Although various methods have been
proposed [18]–[25] to tackle the equivalence checking problem
from completely different perspectives, a baseline indicating
which paradigm is suited best for which use case is yet to be
established.

turns out

is difﬁcult

the time of writing,

One method for equivalence checking of quantum circuits
is based on the ZX-calculus [25]–[28], a graphical calculus
used for reasoning about quantum computing. While some
results on this equivalence checking method exist [28],
it
was introduced as more of a side-note in the original work
than a fully-ﬂedged method. At
the
only publicly available implementation of this algorithm is
written in Python [29]. Therefore it
to assess
the performance of this method due to the inherently slower
runtime of the Python interpreter when compared to a com-
piled language like C++. This makes it somewhat problematic
to compare the method with other established equivalence
checking algorithms. Furthermore, issues unique to design
automation in quantum computing, like inaccurate representa-
tions of complex numbers, different logical-to-physical qubit
mappings, and ancillary qubits, have not been addressed in the
ZX-calculus framework. Apart from practical considerations,
theoretical aspects have also hardly been investigated so far.
It is not known for what class of circuits the equivalence
checking method based on the ZX-calculus is complete, i.e.,
whether it can actually prove the equivalence of any two
equivalent quantum circuits.

Motivated by that, the aim of this work is twofold. Firstly, to
establish whether the ZX-calculus provides a solid equivalence
checking methodology, we review the current state of the
art in equivalence checking with the ZX-calculus. To expand
on this, we discuss how this method can be augmented to

1QMA is the quantum computing analogue to NP. Indeed, NP is a subset

of QMA

 
 
 
 
 
 
handle inaccurate representations of complex numbers aris-
ing from compilation and optimization processes, deal with
alterations of the input and output layout of a circuit that
happen during compilation, and integrate ancillary qubits into
the equivalence checking procedure. We provide ﬁrst results
on the completeness of this equivalence checking algorithm.
Secondly, in order to empirically show that the ZX-calculus
is a practically relevant method in equivalence checking, we
conduct a detailed case study2 to establish a baseline for the
current state of the art in equivalence checking of quantum
circuits considering a large range of benchmarks. To this end,
we re-implemented the ZX-calculus based equivalence check-
ing algorithm in C++ and expanded it with the capabilities
mentioned above. We compare this implementation—which
has been integrated into the publicly available equivalence
checking tool QCEC (https://github.com/cda-tum/qcec)—with
two other state-of-the-art equivalence checking methods: one
based on path-sums [22] and another based on quantum
decision diagrams [24], [31]–[34].

Overall, we show that

the ZX-calculus can be adapted
to verify the results of compilation ﬂows effectively,
that
it outperforms the path-sum approach by a constant factor,
and that it performs on par with the decision diagram based
method in many cases. However, both the ZX-calculus and
the decision diagram based methods have domains where they
clearly outperform the other. Since we show that the ZX-
calculus based approach may fail to prove the equivalence
of two equivalent quantum circuits, it cannot be used to prove
non-equivalence of quantum circuits—only to give an indica-
tion of non-equivalence. All in all, we conclude that neither
the ZX-calculus nor the decision diagram based method is
clearly better than the other but that they rather serve as
complementary methods that are best used in conjunction.

The remainder of this work is structured as follows: Sec-
tion II provides the necessary background and motivates the
necessity of equivalence checking routines in quantum com-
puting. Then, Section III describes the equivalence checking
problem in detail. Based on that, Section IV recapitulates
the theory of the ZX-calculus, explains the state-of-the art
equivalence checking algorithm based on the ZX-calculus in
detail, and shows how the method can be expanded to handle
more relevant equivalence checking problems in quantum
circuit compilation and optimization. There we also prove
that the ZX-calculus based equivalence checking method is
complete for Clifford circuits and illustrate that
is not
complete in general—failing to prove the equivalence of a
simple example. In Section VII we compare ZX-calculus based
equivalence checking with methods based on paths-sums and
decision diagrams. Finally, Section VIII concludes this work.

it

II. BACKGROUND
To keep this work as self-contained as possible, this section
provides a brief introduction to the concepts of quantum
computing and quantum circuits relevant for this work.

A. Quantum Computing

In classical computing, information is encoded in classical
in quantum

bits that can be either 0 or 1. Analogously,

2A preliminary version of this case study has been published in [30].

2

computing, quantum bits (or qubits in short) are used which
can be either in the |0(cid:105) or |1(cid:105) state (in Dirac notation). Contrary
to the classical domain, qubits can also be in superposition of
multiple states. Formally, the state |φ(cid:105) of a qubit is written as

|φ(cid:105) = α0 |0(cid:105) + α1 |1(cid:105) = α0

(cid:21)
(cid:20)1
0

+ α1

(cid:21)
(cid:20)0
1

=

(cid:21)

(cid:20)α0
α1

with amplitudes α0, α1 ∈ C, |α0|2 + |α1|2 = 1.

The basis states of multi-qubit systems are obtained as the
tensor product of single qubit states. So a basis state of a 3-
qubit system would for example be written as |1(cid:105)⊗|1(cid:105)⊗|0(cid:105) =
|110(cid:105) =: |6(cid:105). In general, an n-qubit state |φ(cid:105) is described by
a linear combination of basis vectors, i.e.,

2n−1
(cid:88)

i=0

αi |i(cid:105) with

2n−1
(cid:88)

i=0

|αi|2 = 1 and αi ∈ C.

Any operation manipulating the state of a quantum system
must again yield a valid quantum state. As a consequence,
any such operation U must be unitary, i.e., it must obey
the equation U U † = U †U = I where U † is the conjugate
transpose of U and I is the identity transformation.

the

(cid:2) 1 1
1 −1

1. Consider
(cid:3).
It

Example
transform
H = 1√
checked by matrix
2
multiplication that H is a unitary transformation. The
Hadamard transform maps Z-basis states to X-basis states,
i.e.,

Hadamard

can be

easily

H |0(cid:105) =

H |1(cid:105) =

1
√
2
1
√
2

|0(cid:105) +

|0(cid:105) −

1
√
2
1
√
2

|1(cid:105) =: |+(cid:105)

|1(cid:105) =: |−(cid:105) .

An important unitary acting on two qubits is the controlled not

or CNOT gate. It is deﬁned by the matrix

and ﬂips

(cid:21)

(cid:20) 1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0

the second qubit (the target) when the ﬁrst qubit (the control)
is in state |1(cid:105).

A quantum computation is a unitary transformation acting
on some initial state (usually the qubits are all prepared to be
|0(cid:105)). Instead of writing the system matrix (i.e., the unitary
describing the behavior of the whole circuit) explicitly, a
common way to describe the unitary evolution of a quantum
system is through quantum circuit notation [1]. There, qubits
are represented by wires and operations (called gates) are
annotated as boxes and circles on the wires. The evolution of
the initial state is read from left to right. Thus, a quantum
circuit G is described as a sequence of gates g0 . . . gm−1.
Due to their unitary nature, quantum circuits are inherently
reversible. More speciﬁcally, the inverse of a quantum circuit
G = g0 . . . gm−1 is obtained by inverting each gate and re-
versing the order of operations, i.e., G† = g†

m−1 . . . g†
0.

Example 2. The circuit G in Fig. 1a represents a 3-qubit
system. The box annotated with H is a Hadamard transform
on qubit q0 and the connected circles and dots are CNOT gates
with q0 as control and q1 and q2 as target qubit, respectively.
The circuit maps |000(cid:105) to 1√
|111(cid:105), the well-known
2
GHZ state [35]. The system matrix describing the unitary this
circuit realizes is given in Fig. 1b.

|000(cid:105)+ 1√
2

q2 : |0(cid:105)
q1 : |0(cid:105)
q0 : |0(cid:105)

H •

•


1











1

1√
2

1

1

1

1

1
1



1
-1













1

-1

1

1

-1

-1

c2
c1
c0

(a) GHZ state preparation circuit G

(b) System matrix U of G

Fig. 1: GHZ state preparation

q2 :

q1 :

q0 :

•

•

•

•

H

T†

T

•

T

T†

T

•

T

T†

H

Fig. 2: Decomposition of the Toffoli gate in Clifford+T

B. Quantum Circuit Compilation

Quantum algorithms are typically designed at a rather high
abstraction level without considering speciﬁc hardware restric-
tions. In order to execute a conceptual quantum algorithm on
an actual device, it has to be compiled to a representation that
conforms to all restrictions imposed by the targeted device.
Since quantum computers typically only support a limited
gate-set, every high-level operation has to be decomposed
into that gate-set [36]–[38]. This can sometimes signiﬁcantly
increase the size of the circuit. Fig. 2 shows an exemplary
decomposition of the Toffoli gate in the Clifford+T gate-set.
In addition, many architectures (such as those based on
superconducting qubits) restrict the pairs of qubits that op-
erations may be applied to. Hence, it is necessary to map
the decomposed circuit to the device such that it adheres to
the device’s coupling constraints [39]–[41]. In general, this is
accomplished by establishing a mapping between the circuit’s
logical qubits and the device’s physical qubits. Since it is
generally not possible to determine a conforming mapping
in a static fashion, SWAP gates are inserted into the circuit
that allow to dynamically change the logical-to-physical qubit
mapping over the course of the compilation.

Example 3. Consider again the GHZ preparation circuit
shown in Fig. 1a and assume it shall be mapped to the 5-
qubit, linear architecture shown on the left-hand side of Fig. 3.
Assume that, initially, logical qubit qi is mapped to physical
qubit Qi for 0 ≤ i ≤ 2. Then, the ﬁrst two operations can
be directly applied, while the last operation cannot—due to
the fact that Q0 and Q2 are not directly connected on the
architecture. Hence, a SWAP operation between Q2 and Q1
is introduced, which allows to execute the ﬁnal gate. At the
end of the circuit q0 is measured on Q0, q1 on Q2 and q2 on
Q1.

C. Quantum Circuit Optimization

Through decomposition and mapping, even small quantum
circuits can signiﬁcantly increase in size. In classical com-
puting, circuits are usually optimized in order to require less
space, time, or energy. While time is still an important factor in
quantum computing, this is because of a different reason. The
coherence time of a quantum mechanical system is the time for
which the system remains quantum-mechanically coherent [1].

Architecture

Q4

Q3

Q2

Q1

q2 (cid:55)→

q1 (cid:55)→

q0 (cid:55)→

Q0

Initial layout

SWAP decomposition
•

•

•

×

×

H •

•

c1

c2

c0

Output permutation

Fig. 3: Compilation of GHZ state preparation circuit

RZ ( π
8 )
RZ ( π
8 )
RZ ( π
8 )

q3 :

q2 :

q1 :

q0 :

H

RZ ( π
8 )

· · ·
· · ·
· · ·
· · ·

•

•

•

•

•

RZ (− π
8 )

•

•

•

RZ (− π
8 )

RZ ( π
8 )

RZ (− π
8 )

•

•

•

•

RZ (− π
8 )

RZ ( π
8 )

•

•

RZ (− π
8 )

RZ ( π
8 )

RZ (− π
8 )

RZ ( π
8 )

RZ (− π
8 )

H

3

· · ·
· · ·
· · ·
· · ·

(a) Multi-controlled Toffoli without ancillary qubits

q3 :

q2 :

q1 :

q0 :

a0 :

H

H

•

•

•

•

•

•

T

T †

T

T † H •

•

•

•

T †

T

T †

T

•

•

H

T

T

T †

H

T

T †

T

T † H

(b) Multi-controlled Toffoli gate with ancillary qubits

Fig. 4: Decompositions of the multi-controlled Toffoli gate

When this time is exceeded, the system collapses into some
basis state and is therefore no longer in superposition and
qubits are not entangled anymore. The decoherence time
essentially puts a limit on the maximum number of operations
that can be performed on a quantum system before it collapses.
Another factor unique to quantum computing is the gate
error rate. Gates are difﬁcult to realize precisely in practice.
Every operation performed on qubits potentially introduces
some error. This is often quantiﬁed using the ﬁdelity F, which
measures the distance between two quantum states. The gate
ﬁdelity [1] is then a measure of the ﬁdelity of the quantum
state after applying a noisy gate compared to the quantum
state if an ideal (noiseless) gate was applied. The higher the
gate ﬁdelity, the better the implementation of the gate. Some
gates are easier to realize than others. On superconducting
architectures, CNOT error is the dominating error factor. At
the time of writing, for example, the single-qubit Pauli X error
on the IBMQ Montreal quantum computer was 2.003 × 10−4
on the physical qubit Q0 compared to the CNOT error between
qubit Q0 and Q1 of 2.276 × 10−3.

Because of the coherence time and gate errors, it is im-
portant to optimize the number of elementary gate operations
just a matter of
used in a quantum algorithm. It
execution time but of whether a meaningful result can be
obtained at all from the execution of a quantum algorithm
on a speciﬁc architecture. Many optimization schemes exist
and optimization of quantum circuits is still an active area of
research [14], [15], [42].

is not

The simplest of these optimization schemes is the single-
qubit gate fusion. Since any single qubit unitary represents
a rotation of the Bloch sphere, any sequence of such gates
also represents a rotation. Instead of performing each rotation
separately, the complete rotation can be performed at once.

Another kind of optimization involves using ancillary
qubits. Ancillary qubits are additional qubits apart from those
required for the quantum algorithm. They can act as a sort of
“working memory” to allow for a more compact representation
of certain quantum gates or algorithms. Because the value of
ancillary qubits is only important during the computation, they
are not measured and do not factor into the ﬁnal result.

Example 4. Consider the quantum circuit in Fig. 4a which
represents a multi-controlled Toffoli gate with three control
qubits. This gate performs a Pauli X gate on the last qubit
if and only if all the previous qubits are in the |1(cid:105) state.
Otherwise it acts as the identity on all qubits. Fig. 4b shows an
implementation of this gate with the addition of one ancillary
qubit. This is now a quantum circuit acting on ﬁve qubits with
a higher total gate count, using 33 compared to the 31 of the
original circuit. This circuit uses less CNOT gates however,
needing only 12 CNOT operations compared to the 14 of
the previous circuit. This trade-off is desirable because of the
higher gate error of CNOT gates.

Of course, optimizations are also employed in conjunction
with compilation methods to optimize a compiled circuit while
still obeying all restrictions enforced by the hardware. But
sometimes optimizations are done before mapping. In fact,
some available optimization methods are not designed to han-
dle hardware-speciﬁc restrictions [28]. Therefore, equivalence
checking methods are not only relevant when verifying the
result of a compilation from a high-level description but also
when verifying the results of optimizations of an uncompiled
circuit or even just verifying the equivalence of a high-level
description with an uncompiled optimized version of the high-
level description.

Eventually, compilation and optimization yields a new cir-
cuit that might look quite different from the original high-level
description. It is essential for the successful execution of a
quantum computation to verify that the compiled circuit still
implements the same functionality as the original one. To this
end, methods to check the equivalence of quantum circuits are
necessary.

III. EQUIVALENCE CHECKING

In order to discuss equivalence checking methods for quan-
tum circuits we ﬁrst need to precisely deﬁne the equivalence
checking problem and aspects unique to equivalence checking
in the quantum realm—namely permutations of the input and
output layout of a quantum circuit, inaccuracies stemming
from working with complex numbers, and ancillary qubits.

In general, given two quantum circuits
G = g0 . . . gm−1 and G(cid:48) = g(cid:48)

0 . . . g(cid:48)

m(cid:48)−1

with corresponding system matrices

U = Um−1 · · · U0 and U (cid:48) = U (cid:48)

m(cid:48)−1 · · · U (cid:48)
0,

the equivalence checking problem for quantum circuits asks
whether

U = eiθU (cid:48) or, equivalently, U †U (cid:48) = eiθI,

where θ ∈ (−π, π] denotes a physically unobservable global
phase.

4

So, in principle, checking the equivalence of two quantum
circuits reduces to the construction and the comparison of
the respective system matrices. While this is straightforward
conceptually, it quickly becomes an increasingly difﬁcult task
due to the size of the involved matrices scaling exponentially
with the number of qubits. Equivalence checking of quantum
circuits has even been shown to be QMA-complete [17].

Even this deﬁnition is lacking when talking about the results
of compilation ﬂows. Compilation and optimization can alter
a circuit in such a way that two circuits can be considered
equal even if they have different system matrices.

Firstly, there are numerical inaccuracies. This is one of the
biggest, yet hardly talked about, practical issues when actually
conducting equivalence checking. Because quantum gates are
described by matrices over C, they are hard to accurately
represent in memory. Usually, these matrices are stored us-
ing ﬂoating point numbers which leads to imprecisions and
rounding errors. Therefore, comparing two matrices for exact
equality becomes pointless in many practical cases. Instead,
the Hilbert-Schmidt inner product can be used to quantify the
similarity between two matrices. Let tr denote the trace of a
matrix, i.e., the sum of its diagonal elements. Then, because
tr(I) = 2n for the identity transformation on n qubits, one
can check whether | tr(U †U (cid:48))| ≈ 2n in order to conclude the
equivalence of both circuits up to a given tolerance.

Secondly, compilation ﬂows introduce SWAP operations
into a circuit such that the resulting circuit conforms to the
hardware topology. These techniques use a circuit’s initial
layout and output permutation as an additional degree of
freedom for saving SWAP operations, as, e.g., illustrated in
Example 3. Because of these SWAPs, two circuits might only
be equivalent up to a reordering of the qubits. Hence, in
order to verify the equivalence of compilation ﬂow results,
any equivalence checking routine must be able to handle
these kinds of permutations and accurately track which gate
is performed on which qubit.

Lastly, as discussed in Section II-C, sometimes it is neces-
sary to check the equivalence of two circuits that might not
even operate on the same number of qubits due to the use of
ancillary qubits. Ideally, an equivalence checking routine can
also handle those cases. The difﬁculty comes from the fact
that quantum circuits with differing numbers of qubits cannot
represent the same unitary. Indeed, their unitaries do not even
have the same dimensions. Ancillary qubits have a constant
initial state, being either in the |0(cid:105) or |1(cid:105) state.

Given two quantum circuits

G = g0 . . . gm−1 and G(cid:48) = g(cid:48)

0 . . . g(cid:48)

m(cid:48)−1

with ancillaries qubits with corresponding system matrices

U = Um−1 · · · U0 and U (cid:48) = U (cid:48)

m(cid:48)−1 · · · U (cid:48)
0,

the equivalence checking problem for quantum circuits in-
volving ancillary qubits asks whether

Uanc = eiθU (cid:48)

anc or, equivalently, U †
where θ ∈ (−π, π] denotes a physically unobservable global
phase and Uanc is the unitary obtained from U by ﬁxing the
ancillary qubits in G to their constant state.

anc = eiθI,

ancU (cid:48)

...

α
...

...

...

β

...

(f )
= ... α+β

...

...

α

...

(h)
=

...

α

...

(id)
=

(hh)
=

...

α

...

(c)
= ...

π

α

...

...

(b)
=

(π)
=

−α

π

π

Fig. 5: Axioms of the scalar-free ZX-calculus

Example 5. A CNOT gate can be trivially used as a Pauli X
gate by treating the control qubit as an ancillary with constant
state |1(cid:105). To conform with our construction that the ancilla is
the last qubit, we consider the matrix of a CNOT where the
target is on qubit 0.

U =

(cid:21)

(cid:20) 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0

= |00(cid:105) (cid:104)00| + |01(cid:105) (cid:104)11| + |10(cid:105) (cid:104)10| + |11(cid:105) (cid:104)01| .

Fixing the last qubit gives:

Uanc = (cid:104)10|

+ (cid:104)10|

(cid:21)

(cid:21)

(cid:20) 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
(cid:20) 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0

= |1(cid:105) (cid:104)0| + |0(cid:105) (cid:104)1| =

|01(cid:105) |0(cid:105) (cid:104)0| + (cid:104)11|

|11(cid:105) |0(cid:105) (cid:104)1| + (cid:104)11|

(cid:20)0
1

(cid:21)

1
0

= X.

(cid:21)

(cid:21)

(cid:20) 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
(cid:20) 1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0

|01(cid:105) |1(cid:105) (cid:104)0|

|11(cid:105) |1(cid:105) (cid:104)1|

This shows that Uanc of a CNOT gate with constant control of
|1(cid:105) is equivalent to a Pauli X gate.

In order to avoid the emergence of a veriﬁcation gap as
for classical systems, automated software solutions for equiv-
alence checking of quantum circuits have to be developed.
To this end, various methods have been proposed [18]–[25].
However, most of them either only work on small circuits, lack
publicly available implementations or are based on paradigms
established in classical computing that do not take the full
picture of quantum computing into account. Few methods
exist that approach equivalence checking entirely from the
perspective of quantum computing [22], [23], [25]. Even these
existing approaches view the equivalence checking problem
from completely different perspectives and a baseline indicat-
ing which paradigm is suited best for which use case is yet to
be established.

IV. ZX-CALCULUS
The ZX-calculus [26], [43] is a graphical notation for
quantum circuits equipped with a powerful set of rewrite
rules that enable diagrammatic reasoning about quantum com-
puting. It has been successfully applied to quantum circuit
compilation and optimization [25], [27], [28] and to some
extent also to equivalence checking of quantum circuits [28].
The algorithm for equivalence checking using the ZX-calculus
was only mentioned brieﬂy as an alternative application of
the optimization proposed in [28] and has not been adapted
to handle numerical inaccuracies, permutations of input and

5

(a) Uncompiled GHZ circuit (b) Compiled GHZ circuit

Fig. 6: ZX-diagrams of GHZ state preparation circuits

output layout of a compiled circuit, and ancillary qubits as
mentioned in Section III. In short, more work is needed to
handle equivalence checking of compilation results with the
ZX-calculus. In this section, we are going to discuss how
this can be done as well as provide ﬁrst results on the (in-
)completeness of the ZX-calculus based equivalence checking
algorithm.

In order to do this, we are ﬁrst going to introduce the
necessary background on the ZX-calculus and the current
state-of-the-art algorithm in equivalence checking with the
ZX-calculus.

A. Basics of ZX-Calculus

A ZX-diagram is made up of colored nodes (called spiders)
that are connected by wires (representing qubits, similar to
quantum circuit notation). Each spider can either be green (Z-
spider
) and is optionally attributed a
scalar phase.

) or red (X-spider

ZX-diagrams can be composed just

like quantum cir-
cuits. Horizontal composition or concatenation (denoted ◦)
is achieved by connecting the outputs of one diagram to the
” acts as the identity for
input of another. The bare wire “
concatenation. Vertical composition (denoted ⊗) is achieved
by simply “stacking” two diagrams on top of each other. The
empty diagram
acts as the identity for vertical composition.
Additionally, a ZX-diagram can carry a global phase that
is annotated along the diagram. Since global phases are
negligible in most cases, they are frequently omitted from ZX-
diagrams and equations in the ZX-calculus usually hold up to
a global phase. A spider with a phase of ±π is called a Pauli
2 | k ∈ Z} is called
spider. A spider with a phase α ∈ {k π
a Clifford spider. A Clifford spider that is not a Pauli spider
is called a proper Clifford spider. A ZX-diagram consisting
entirely of Clifford (Pauli) spiders is called a Clifford (Pauli)
ZX-diagram.

Any quantum circuit can be interpreted as a ZX-diagram.
The reverse of this statement is not true, i.e., not every ZX-
diagram can be interpreted as a quantum circuit because the
ZX-diagram does not necessarily encode a unitary transforma-
tion. Every ZX-diagram does, however, have an interpretation
as a linear map.

... α
... α

(cid:74)

...
...

(cid:75)

= |0 . . . 0(cid:105) (cid:104)0 . . . 0| + eiα |1 . . . 1(cid:105) (cid:104)1 . . . 1|
= |+ · · · +(cid:105) (cid:104)+ · · · +| + eiα |− · · · −(cid:105) (cid:104)− · · · −|

·
(cid:75)

(cid:74)
Here

(cid:75)
denotes the interpretation function which maps a
ZX-diagram to its corresponding linear map. Any linear map
on qubits can then be built up from Z- and X-spiders by
connecting and stacking diagrams.

(cid:74)

Spiders without inputs are called states, whereas spiders
with no outputs are called effects. Interpreted as linear maps,
states represent column vectors whereas effects represent row
vectors. A ZX-diagram without inputs or outputs represents a
number.

± π
2

...

... α1

...

α2

αn−1

... α1∓ π

2

αn∓ π
2

...

... α2∓ π

2

αn−1∓ π
2

...

...

...

(LC)
=

αn

...

jπ

...

... α1

αn

...

α

...

(GB)
=

jπ

...

... α1

αn

...

6

α

...

jπ

kπ

... α1
...
... αn

β1
...

βm

...

...

...

...

α1+kπ
...
αn+kπ

γ1
...

γl

...

...

(P)
=

β1+(j+k+1)π
...
βm+(j+k+1)π

...

...

γ1+jπ
...
γl+jπ

...

...

... α

β

...

(ZHH)

= ... α

β

...

α

= α

α

=

α+ π
2

...

...

...

...

α

β

...

(UG)

= α+β

...

α

kπ

β

jπ

α1
...
αn

...

...

(GF)
=

(−1)kα+(−1)j β

α1
...

αn

...

...

Fig. 7: Rewrite system for graph-like ZX-diagrams

The real power of ZX-diagrams becomes evident when
adding rewrite rules to the language. The axioms of the scalar-
free ZX-calculus are given in Fig. 5.

Example 6. To give a feel for how to work with ZX-diagrams,
we are going to prove the well-known equivalence of a SWAP
with 3 CNOT operations (as shown in Fig. 3). For this, we ﬁrst
need to prove the following rule, which is sometimes listed
explicitly among the axioms for the ZX-calculus but can also
be derived from the axioms as follows

(f )
=

(b)
=

(c)
=

=

.

(1)

With this we can proceed with

=

(b)
=

(f )
=

(1)=

.

(2)

B. Equivalence Checking Graph-like ZX-diagrams

Equivalence checking with the ZX-calculus can be done
in one of two ways, by either rewriting the diagram of both
circuits into one another (as in Ex. 6) or by inverting one
diagram, composing the diagrams, and simplifying as much
as possible. This is sometimes called an equivalence checking
miter. If the composed diagram simpliﬁes to a diagram com-
posed only of bare wires, it is either the identity or contains
swaps, i.e., resembles a permutation.

Example 7. Consider again the circuits G from Fig. 1a and
G(cid:48) from Fig. 3. Their respective ZX-diagrams are shown in
Fig. 6a and Fig. 6b. Since all phases in all spiders are 0,
the inverse of each diagram is obtained by just reversing the
diagram. Using the rewrite rules of the ZX-calculus to prove
the identity of the circuits proceeds as follows:

(2)=

=

(hh)
=

(f)
=

(1)=

(id)
=

(f)
=

(1)=

(id)
=

The diagram contains a SWAP which permutes qubit Q1 and
Q2. Since this is what we expect from the output permutation
shown in Fig. 3 it can be concluded that the circuits are
equivalent.

This example shows that the ZX-calculus cannot only show
the equivalence of circuits but that it can also provide a proof
certiﬁcate in the form of the order of rewrite rules that are
applied to derive the identity.

The set of equations in Fig. 5 is not well suited for
automated equivalence checking. In Eq. (1) we needed to use
the spider fusion rule in both directions. This is undesirable
in automated rewriting where terminating rewriting systems
are preferable. In [27], the authors introduce an alternative
structure for ZX-diagrams coupled with additional rewrite
rules.

A ZX-diagram is graph-like when:

1) All spiders are Z-spiders.
2) Z-spiders are only connected via Hadamard edges.
3) There are no parallel Hadamard edges or self-loops.
4) Every input or output is connected to a Z-spider and every
Z-spider is connected to at most one input or output.

In graph-like ZX-diagrams, a spider connected to an input or
output is called a boundary spider. Otherwise, it is called an
interior spider.

Most importantly, every ZX-diagram is equal to a graph-
like ZX-diagram [27]. Every ZX-diagram can be rewritten to
its equivalent graph-like form using the basic rules given in
Fig. 5. Instead of rigorously deﬁning this rewriting procedure
we give an intuition with the following example.

Example 8. The ZX-diagram of the GHZ state preparation
circuit from Fig. 6a can easily be transformed to its equivalent
graph-like form by applying rules (id) and (h).

π
4

π

π
2

π
2

3π
4

π
2

π
4

π
2

π
2

π
2

π
2

7

π
2

3π
2

∼0

∼0

3π
2

π
2

=

=

=

(a) ZX-diagram of Clifford+T circuit

(b) Reduced diagram

Graph-like diagrams allow for the formulation of a nor-
malizing rewrite system. The rules of this system are given
in Fig. 7. Adding rules (f ), (id) and (hh) (applied from
left to right) to this system allows for the deﬁnition of a
simpliﬁcation algorithm that reduces every ZX-diagram into
a reduced gadget form [28].

This automated rewriting of diagrams into reduced gadget
form allows for the deﬁnition of an equivalence checking
algorithm. Given two quantum circuits G and G(cid:48) we can check
them for equivalence by taking their respective representations
as ZX-diagrams D and D(cid:48), combining them to D†D(cid:48) and
simplifying the combined diagram to reduced gadget form.
If the reduced gadget form is the identity diagram—the ZX-
diagram consisting only of bare wires—then G and G(cid:48) are
equivalent. Otherwise, nothing can be concluded about the
relation of G and G† because there are generally multiple
reduced gadget forms for a ZX-diagram.

V. EQUIVALENCE CHECKING
COMPILATION FLOWS USING THE ZX-CALCULUS

The original ZX-calculus equivalence checking algorithm
proposed in [26] has been introduced as a byproduct of the
optimization algorithm proposed in that work. It has, therefore,
not been expanded to handle the more technical aspects of
quantum circuit equivalence checking necessary to check the
results of compilation ﬂows. In the following, we will remedy
this by showing how inaccuracies, permutations, and ancillae
can be handled in ZX-calculus equivalence checking.

A. Handling Inaccuracies

The equivalence checking routine based on the ZX-calculus
is an exact method. Hence, when considering two quantum
circuits G and G(cid:48), where G(cid:48) is equivalent to G up to some
small error, the ZX-calculus is unable to conclude equivalence.
But can anything be concluded about the reduced gadget form
of D†D(cid:48) where

D(cid:48)

D

≈

?

(cid:74)

(cid:75)

(cid:74)

(cid:75)

To give an intuition, consider the Clifford+T circuit given
in Fig. 8a. Introducing an error of 10−15 in the phase of two
spiders and checking the equivalence of the original and the
erroneous circuit yields the ZX-diagram shown in Fig. 8b. The
phases indicated with ∼ α means that the phase is α ± 10−15.
It is not at all obvious that this diagram is close to the identity.
However,
if we were to round the phases and simpliﬁed
further, we would indeed be able to derive the identity.

One strategy is to interleave simpliﬁcation to normal form
with detection and rounding of phases close to k π
2 for some
k ∈ Z. This allows equivalence checking of quantum circuits
that differ by small numerical inaccuracies in some continuous
parameters. The corresponding algorithm is obviously not
correct in a formal sense, i.e., it can attest two non-equivalent
circuits to be equivalent, but that is the whole point. The
threshold for rounding (cid:15) can be used to tune the degree
to which errors are allowed. However, it does not give any
indication about the absolute error.

Fig. 8: Equivalence checking with the ZX-calculus in the
presence of few small errors

To clarify this point, consider a ZX-diagram M after
simpliﬁcation and the corresponding ZX-diagram M (cid:48) obtained
after rounding and simplifying again. The tolerance (cid:15) can not
D(cid:48)
D†
be used to assess tr(
)—the Hilbert-Schmidt inner
(cid:75)
(cid:74)
product discussed in Section III.
A question one might ask is why the rounding doesn’t
already occur on the diagrams D and D(cid:48). The reason is
that even phases that are not nice fractions of π (or very
small fractions) might cancel during simpliﬁcation due to the
rules UG and GF. Thus rounding before simplifying would
increase the total error made during the equivalence check.

(cid:75)(cid:74)

This way of handling inaccuracies is still

lacking. As
discussed above it is hard to gauge the tolerance required
in order to ensure the absolute error allowed is within some
bound. Given the ZX-diagram M after full simpliﬁcation, how
)| ≈ 2n? The diagrammatic
can we determine whether | tr(
(cid:74)
trace is deﬁned as follows:

M

(cid:75)

(cid:32)

(cid:33)

tr

...

...D

=

...

D

...

...

Unfortunately, this deﬁnition is hardly helpful if we want to
actually compute the trace. In order to compute the trace,
further simpliﬁcations have to be made after the inputs and
outputs have been connected. This doesn’t necessarily enable
the ZX-diagram to be simpliﬁed to a point where calculations
are practical. A possible solution to this problem is to leave the
ZX-calculus framework entirely. ZX-diagrams are, in essence,
tensor networks [43], [44]. Therefore methods from the tensor
network domain can be used to compute the trace of a ZX-
diagram.

B. Handling Permutations

Handling SWAPs in ZX-diagrams is a trivial matter. Since
SWAPs are nothing but edges connecting spiders acting on
different qubits, they do not add much complexity to a ZX-
diagram. To correct permutations of the initial layout, it has
to be ensured that wires are connected accordingly when con-
structing D† ◦ D(cid:48). But since SWAPs incur such little overhead
in ZX-diagrams, the initial layout can also just be encoded
into the original diagrams themselves before performing the
equivalence check. The wires can then be connected in the
usual fashion, i.e. by connecting the i-th output wire of D†
with the i-th input wire of D(cid:48).

Output permutations can be handled in a similar fashion
as with decision diagrams, by comparing the permutation
of wires after fully simplifying D† ◦ D(cid:48) with the expected
permutation. Once again the permutation can also just be
handled by encoding the SWAPs directly into the diagrams.

As discussed in Section II-B, permutations of input and
output layouts are performed in order to save CNOT gates
that need to be executed on the quantum hardware. When
converting a compiled circuit to a ZX-diagram, Eq. (2) can
be used to reconstruct compiled SWAP gates if they are not
optimized away. Since a SWAP in the ZX-calculus is only a
crossing of the wires, this reconstruction can greatly improve
the performance of the equivalence check, decreasing runtime
by up to two orders of magnitude.

Example 9. The output permutation of the qubits in Fig. 6b
can be directly encoded back into the circuit via a SWAP at the
end of the circuit. Additionally, the 3 CNOTs can be converted
back into a SWAP, yielding the following ZX-diagram:

This ZX-diagram is equivalent to the one in Fig. 6a up to

an untangling of the wires.

C. Handling Ancillaries

In the ZX-calculus the equivalence checking problem using
ancillaries is reducible to the ancilla-free case in a straightfor-
ward fashion. Remember that ancillaries are qubits that have
a constant initial state and end in the same state. This is easily
translated into the diagrammatic language of the ZX-calculus,
by replacing each input and output belonging to an ancilla
qubit by the respective state and effect, which are just X-
spiders with a phase of either 0 or π.

Example 10. In Example 5 it was shown how ﬁxing the control
qubit of a CNOT gate to the |1(cid:105) state, transforms it into a Pauli
X gate. This can also be shown in the ZX-calculus with only
basic applications of the axioms. We start by applying the |1(cid:105)
state and effect to the ancillary line and proceed to simplify.

→ π

(π)
=

π

π

(f)
=

π

π

π

π

π

Since we ignore scalars, the right-hand side indeed imple-
).

ments a Pauli X gate (

π

VI. COMPLETENESS
A natural question to ask is whether the ZX-calculus is
powerful enough to derive the identity for any pair of func-
tionally equivalent circuits. The good news is that the ruleset
provided in this paper is complete for circuits solely composed
of Clifford gates [45]. The bad news is that, in order to achieve
completeness for universal quantum computing, the ruleset
has to be extended with a rule involving complicated iterated
trigonometric functions [46], which makes it difﬁcult to apply
in automated reasoning.

The question of completeness arises naturally in the context
of rewriting. Given two circuits G and G(cid:48), can we prove their
(non-)equivalence using the ZX-calculus rewriting strategy?

As the ZX-calculus is complete for Clifford ZX-diagrams,
it is not surprising that automated equivalence checking with
the ZX-calculus is also complete for Clifford ZX-diagrams.

8

π
8

π
8

π
8

(cid:57) π
8

π
8

(cid:57) π
8

π
8

(cid:57) π
8

(cid:57) π
8

π
8

(cid:57) π
8

π
8

(cid:57) π
8

π
8

(cid:57) π
8

(a) Multi-controlled Toffoli without ancillary qubits

π
4

(cid:57) π
4

π
4

(cid:57) π
4

(cid:57) π
4

π
4

(cid:57) π
4

π
4

π
4

π
4

(cid:57) π
4

π
4

(cid:57) π
4

π
4

(cid:57) π
4

(b) Multi-controlled Toffoli with ancillary qubits

Fig. 9: ZX-diagrams of the multi-controlled Toffoli gate

π
8

(cid:57) π
8

π
8

(cid:57) π
8

π
8

(cid:57) π
8

π
8

π
8

(cid:57) π
8

π
8

π
8

(cid:57) π
8

(cid:57) π
8

(cid:57) π
8

(cid:57) π
8

π
4

(cid:57) π
4

π
4

(cid:57) π
4

(cid:57) π
4

π
4

(cid:57) π
4

π
4

π
4

π
4

(cid:57) π
4

π
4

(cid:57) π
4

π
4

(cid:57) π
4

(a) Miter of multi-controlled Toffoli ZX-diagrams

(cid:57) π
8

π
8

(cid:57) π
8

π
8

π
8

(cid:57) π
8

π
8

(cid:57) π
8

π
8

π
4

π
4

(cid:57) π
4

π
4

(cid:57) π
4

π
8

π
4

(cid:57) π
8

(cid:57) π
4

(cid:57) π
4

π
4

(cid:57) π
8

(cid:57) π
8

π
8

π
8

(cid:57) π
4

(cid:57) π
4

π
4

(b) Reduced miter

Fig. 10: Counterexample to completeness

Theorem 1. Given two quantum Circuits G and G(cid:48) consisting
only of Clifford gates with corresponding ZX-diagrams D and
D(cid:48)
is the identity
diagram.

the only reduced gadget form of D†D(cid:48)

Proof. The rules LC and P remove every interior Clifford
spider from a ZX-diagram. Since all spiders in D†D(cid:48) are Clif-
ford, there are no more interior spiders left after simplifying.
After simpliﬁcation D†D(cid:48) must therefore be of the form

j0π
2

k0π
2

... ...

...

...

...

jn−1π
2

kn−1π
2

,

i.e. a Clifford ZX-diagram with only boundary spiders,
where all boundary spiders (that are in fact connected) are
connected via Hadamard edges and where there must be
exactly one Hadamard box on each line. In fact this structure
D†D(cid:48)
= In—every Clifford
is independent of the fact that
(cid:74)
ZX-Diagram has this reduced gadget form. W.l.o.g. assume
that the Hadamard boxes are all on the left-hand side and call
this diagram Dsimp

(cid:75)

We need to show ji = ki = 0 for all 0 ≤ i < n
there are no connections between spiders on
and that
lines. To break this problem into simpler sub-
different
problems we are going to use the following helpful trick:

(h)=

(h)=

j0π
2

k0π
2

... ...

...

...

...

jn−1π
2

...

kn−1π
2

...

...

...

...

jn−1π
2

kn−1π
2

...

jn−1π
2

...

...

kn−1π
2

j0π
2

k0π
2

... ...

...

...

...

jn−1π
2

...

kn−1π
2

...

...

...

...

jn−1π
2

kn−1π
2

(c)=

(f)=

The spider fusion in the last equality is due to the fact that all
spiders in the second row have a phase of 0 and all the spiders
they are connected to are Z-spiders (all spiders in the diagram
are Z-spiders). With this trick, we can effectively eliminate
a line from the diagram because the diagram manipulations
only effect the connections from the ﬁrst row and not the
connections between other rows. The rest of the diagram still
has to act as the identity on the rest of the qubits. This is due
...

to the fact that if

then

=

Dsimp
(cid:74)
j0π
2

(cid:75)

(cid:74)

(cid:75)
k0π
2

... ...

...

...

...

jn−1π
2

kn−1π
2

= ...

.

If two ZX-diagrams have the same interpretation they can
be replaced with each other in every context. This is a simple
consequence of the soundness of the ZX-calculus.

With the introduced trick, we can effectively reduce Dsimp
until only one line remains. In this case the remaining line
still has to represent the identity. We prove
that jt = kt = 0 by concrete calculation of the matrix of the
diagram.

ktπ
2

jtπ
2

=

(cid:75)

π
2 |1(cid:105) (cid:104)1|) =

jtπ
2

ktπ
2
π

(cid:74)
(|+(cid:105) (cid:104)+| + eijt
(cid:20)1 + eijt
1
1 − eijt
2

π
2
π
2

(h)=

jtπ
2

ktπ
2

(cid:75)

(cid:74)

π

π

(cid:21)

2 |−(cid:105) (cid:104)−|)(|0(cid:105) (cid:104)0| + eikt
2 )eikt
(1 − eijt
2 )eikt
(1 + eijt
(cid:20)1
0

π
2
π
2

Since this matrix has to equal

(cid:21)
0
1
eijt
2 = 1 which can only be true if jt = kt = 0.
Thus we can conclude that all spiders in Dsimp have a phase
of 0.

the constraints force

2 = eikt

π

π

To show that no spiders belonging to different lines can be
connected, we use our trick again. But this time we reduce
down to two lines.

The Hadamard edges between spiders on different lines may
or may not exist. We are going to see that for the purpose of
this proof we do not need to make a case distinction on all
possible combinations of connections. Using a similar strategy
as for the line removal trick we obtain

(h)=

(f)=

(c)=

(h)=

(h)=

in the ﬁrst line and

Since this diagram has to be the identity on each line and
on the second line, they
we input
also have to be the output on their respective lines. But this
can only be the case if the diagonal connection between the
ﬁrst and second line does not exist. Therefore there is also no
connection in the original diagram, i.e. it has to look like

.

9

Similar reasoning can be applied to conclude that
the
remaining inter-line connections cannot exist if the diagram
is equal to the identity diagram.

We have proven that all phases in Dsimp are 0 and that
there are no connections between spiders on different lines.
Therefore Dsimp looks like

...

.

Rules (hh), (f ) and (id) remove identity spiders, fuse
spiders and cancel adjacent Hadamard boxes as much as
possible. Thus the diagram is further simpliﬁed. Then,

...

(id)=

...

(hh)=

...

Due to symmetry the proof still works if some of the

Hadamard boxes are at the outputs.

Theorem 1 establishes a baseline for what equivalences can
be proven via automated reasoning with the ZX-calculus. Next,
we want to look at completeness from a different perspective,
by showing that rewriting to reduced gadget form is not
sufﬁcient for proving the equivalence of arbitrary equivalent
circuits. In particular, we are going to show that this algorithm
is not even sufﬁcient for proving equivalence of reversible
circuits.

Theorem 2. There exist
two equivalent quantum Circuits
G and G(cid:48)—using ancillary qubits—with corresponding ZX-
diagrams D and D(cid:48) where D†D(cid:48) possesses a reduced gadget
form that is not the identity diagram.

Proof. Unfortunately the proof of this theorem is not achieved
through cunning manipulation of diagrams, kets and bras but
by brute-force calculation. Consider the ZX-diagrams in Fig. 9
which are the ZX-diagrams of the circuits in Fig. 4 where the
ancillary qubit’s input and output has been set to |0(cid:105) = .
Taking the adjoint of the diagram in Fig. 9a, and concatenating
the two diagrams, yields the diagram in Fig. 10a. A reduced
gadget form of this diagrams is shown in Fig. 10b. No further
simpliﬁcations can be made but this diagram is clearly not the
identity. It can be checked by (tedious) computation of the
corresponding matrices that the ZX-diagram in Fig. 10a does
actually implement the identity transformation.

It is not surprising at all that equivalence checking via sim-
pliﬁcation to reduced gadget form is not complete in general.
Because the equivalence checking problem is QMA-complete
and since NP is a subset of QMA,
it would be entirely
unexpected that the ZX-calculus based equivalence checking
algorithm solves the equivalence checking problem, given that
a reduced gadget form can be derived in polynomial time with
respect to the number of spiders of the original diagram [28].
But the proof by counterexample shows that it cannot even
show the equivalence of two circuits (involving ancillaries)
even when they are fairly simple.

VII. CASE STUDY
The basic equivalence checking routine based on the
ZX-calculus is publicly available via the Python library
pyzx [29]. Since pyzx does not support
layout permuta-
tions, inaccuracies, or ancillary qubits, and because Python
is inherently slower than a compiled programming language,
the ZX-calculus based equivalence checking algorithm has
been re-implemented in C++ and integrated into the publicly
available QCEC tool (https://github.com/cda-tum/qcec) which
is part of the Munich Quantum Toolkit (MQT, formerly known
as JKQ [47]). This re-implementation has additional features
that allow for handling of the mentioned problems.

To properly evaluate the resulting implementation of the
ZX-calculus based equivalence checking algorithm, two state-
of-the-art equivalence checking tools have been considered as
a comparison: First, the proposed ZX-calculus equivalence
checker is compared against an approach based on path-
sums [22] on a large set of random Clifford circuits. This
is done in order to assess how the proposed checker—which
we proved to be complete for Clifford circuits—performs in
relation to another Clifford-complete method.

Second, an extensive comparison is performed against
the complete equivalence checking approach based on deci-
sion diagrams proposed in [23] to see how the incomplete
ZX-calculus checker compares on a broad range of quantum
circuits.

The path-sum equivalence checker is publicly available via
the Feynver tool which is part of the Feynman toolset. The
decision diagram based equivalence checker is also publicly
available via QCEC. For the remainder of this section “QCEC”
explicitly refers to the decision diagram based equivalence
checker proposed in [23] and implemented in QCEC.

Before the experimental setup and the results are discussed,
we will brieﬂy introduce the basics of the two other equiva-
lence checking methods considered for the evaluation.

A. Equivalence Checking Using Decision Diagrams

Decision Diagrams [24], [31]–[34] are a data structure used
for efﬁciently representing complex matrices. Using redun-
dancies in the representation of a matrix, decision diagrams
can often represent an exponentially large matrix using only
polynomial resources. This makes them great candidates for
use in equivalence checking of quantum circuits, as a quantum
circuit is just another way of writing a unitary matrix.

0g(cid:48)

0 · · · g(cid:48)

m · · · g†

m(cid:48) are equivalent if G†G(cid:48) = g†

Recall that two quantum circuits G = g0 · · · gm and G(cid:48) =
0 · · · g(cid:48)
g(cid:48)
m(cid:48) = I.
Similar to equivalence checking using ZX-diagrams, decision
diagrams can be used to efﬁciently carry out
the matrix
multiplication of G† and G(cid:48). The idea is to start constructing
the functionality of the combined circuit from the “middle”
and alternating between applications of G† and G(cid:48), such that
the decision diagram being constructed remains as close to the
identity as possible [23]. This is desirable because the n-qubit
identity matrix only requires linear space when represented as
a decision diagram instead of 2n × 2n complex numbers for
the entire matrix.

B. Equivalence Checking Using Path-Sums

10

ZX-calculus checker

Feynver

(a) Runtimes for differing gate count

ZX-calculus checker

Feynver

(b) Runtimes for differing qubit count

Fig. 11: Equivalence checking random Clifford benchmarks

the idea of
variables. Similar to Feynman path integrals,
path-sums is to encode the action of a unitary as a sum over all
possible input-output basis states of a quantum computation.
This symbolic representation of a quantum circuit allows
2k ) k ∈ Z, circuits on a high
for handling Clifford + RZ( π
abstraction level.

The symbolic treatment of quantum circuits as path-sums
allows for the formulation of a set of rewrite rules which—
similar to ZX-calculus rewriting—can be used to successively
reduce a path-sum into a normal form in polynomial time.
While this approach is not complete in general, it is complete
for Clifford circuits [22]. Thus path-sum rewriting serves as
an alternative complete approach to proving equivalence of
Clifford circuits.

C. Experimental Setup

While there is no explicit conﬁguration for the ZX-calculus
and path-sum equivalence checker, QCEC has different meth-
ods with their respective parameters based on [23], [48], [49].
For the evaluations involving decision diagrams, we compare
the ZX-calculus based equivalence checking routine with the
combined approach as presented in [23]. For QCEC, we run
the equivalence checking routine in parallel with a sequence
of 16 simulation runs. If the simulations manage to prove
non-equivalence of the circuits,
the equivalence checking
routine is terminated early.

In order to compare the methods, various benchmarks have
been considered. All benchmarks are provided in the form of
QASM [50] ﬁles, which serves as a common language for the
ZX-calculus tool and QCEC. All circuits have been compiled
using qiskit-terra 0.18.3, either with the optimization level O1
or O2 depending on the benchmark set. Before checking the
Clifford Circuits with Feynver, the circuits had to be translated
to a format supported by Feynver, but since only Clifford
circuits were considered, this was a trivial matter.

Path-sums [22] are an abstract representation of quantum
circuits in the form of multivariate polynomials over Boolean

To compare the scaling of the ZX-checker and Feynver, a
large set of random Clifford circuits with a varying number of

010002000300040005000# GATES010203040506070t [s]# QUBITS153045607590105120010002000300040005000# GATES0500100015002000250030003500t [s]# QUBITS153045607590105120020406080100120# QUBITS01020304050607080t [s]# GATES2000300040005000020406080100120# QUBITS0500100015002000250030003500t [s]# GATES2000300040005000TABLE I: Slightly optimized reversible circuits

TABLE II: Highly optimized reversible circuits

11

Name
9symml-195
dist-223
clip-206
hwb7-61
life-238
hwb7-60
alu2-199
sym9-193
example2-231
hwb7-59
sym9-148
urf2-277
add6-196
urf2-153
hwb8-117
hwb8-116
urf2-161
hwb8-114
hwb8-118
urf2-154
hwb8-115
hwb8-113
urf5-159
plus63mod4096-163
plus63mod8192-164
urf3-279
urf1-150
urf6-281

Benchmark
n
20
20
53
20
20
20
53
20
53
20
20
20
53
20
20
20
20
20
20
20
20
20
20
53
53
20
20
20

|G|
15701
22778
23782
14680
12114
14096
21474
15944
22017
18435
17061
33348
30296
55243
23596
23353
100189
45079
52692
52432
45247
52905
65250
94520
125612
172651
156575
98462

|G(cid:48)|
13662
19458
20872
12557
10441
12167
19007
13327
19411
15616
14044
30940
25460
47155
20697
20996
92597
38733
45784
44615
39172
46230
57099
82195
111720
157462
134216
94097

Equivalent
tqcec[s]
tzx[s]
7.37
8.04
11.88
11.82
20.49
12.53
1.56
13.45
3.78
13.55
0.83
19.24
28.05
19.76
6.17
21.70
18.36
23.63
2.53
40.81
0.60
75.53
3.36
76.59
14.94
82.48
210.77
214.21
1.54
259.78
2.68
274.82
5.08
403.99
38.64
453.13
63.61
521.59
145.44
587.01
30.47
734.52
68.62
1211.62
45.17
1325.16
>3600
87.94
>3600
412.22
>3600
416.96
>3600 >3600
>3600 >3600

1 Gate Missing
tqcec[s]
tzx[s]
0.12
2.04
0.16
24.65
0.29
2.18
0.11
0.56
0.10
1.57
0.10
1.14
0.26
2.04
0.11
1.89
0.27
5.12
0.18
0.75
0.11
6.59
0.26
2.03
0.38
3.13
0.35
6.54
0.22
43.95
0.15
18.58
0.69
5.48
0.31
16.01
0.43
85.34
0.54
7.97
0.28
9.78
0.46
22.03
0.39
25.78
1.28
48.61
>3600
1.22
1.38
158.13
1.06
51.37
1.30
604.79

Flipped CNOT
tqcec[s]
tzx[s]
0.11
8.25
0.17
9.13
0.31
8.92
0.10
13.68
0.09
9.92
0.11
51.74
0.29
19.16
0.11
24.64
0.25
25.64
0.15
20.55
0.11
34.26
0.26
77.75
0.34
95.46
0.39
162.52
0.17
27.28
0.16
272.41
1.32
25.83
0.36
40.13
0.39
617.56
0.49
16.57
0.28
467.74
0.37
1476.73
0.46
659.13
>3600
0.94
1.60
78.41
>3600
1.50
1.34
3084.44
>3600
1.28

Name
9symml-195
dist-223
clip-206
hwb7-61
life-238
alu2-199
sym9-193
example2-231
hwb7-59
sym9-148
urf2-277
add6-196
urf2-153
hwb8-117
hwb8-116
urf2-161
hwb8-114
hwb8-118
urf2-154
hwb8-115
hwb8-113
urf5-159
plus63mod4096-163
plus63mod8192-164
urf3-279
urf1-150
urf6-281

Benchmark
n
20
20
53
20
20
53
20
53
20
20
20
53
20
20
20
20
20
20
20
20
20
20
53
53
20
20
20

|G|
15701
22778
23782
14680
12114
21474
15944
22017
18435
17061
33348
30296
55243
23596
23353
100189
45079
52692
52432
45247
52905
65250
94520
125612
172651
156575
98462

|G(cid:48)|
13159
18721
21407
12741
9869
19080
13908
19207
16027
14002
29711
26201
46103
20413
20519
91018
38398
44901
44306
38205
45833
56089
83835
111258
153474
132898
88750

Equivalent

tzx[s]
42.82
16.44
11.14
34.99
8.73
26.23
7.76
38.71
15.68
284.87
68.28
154.88
296.04
123.04
323.72
405.14
1263.37
712.38
1150.70
269.99
1036.07
2369.23
>3600
>3600
>3600
>3600
>3600

tqcec[s]
5.41
11.96
15.65
0.52
2.80
4.27
11.21
51.12
1.24
0.96
16.10
30.21
42.08
17.21
13.97
122.92
9.11
13.65
20.02
13.15
11.59
18.12
1249.90
>3600
>3600
>3600
>3600

1 Gate Missing
tqcec[s]
tzx[s]
0.13
1.96
0.16
3.45
0.43
2.00
0.18
0.47
0.10
1.12
0.31
7.00
0.14
1.41
0.31
3.13
0.15
0.46
0.11
1.07
0.32
2.95
0.45
10.77
0.48
3.12
0.20
2.56
0.17
11.78
1.15
3.11
0.33
10.15
0.68
8.40
0.57
5.53
0.40
6.26
0.41
15.25
0.52
21.70
1.27
78.66
1.49
313.11
1.40
40.35
1.17
103.27
1.36
198.70

Flipped CNOT
tqcec[s]
tzx[s]
0.13
2.39
0.17
2.49
0.39
1.37
0.17
0.46
0.10
0.69
0.36
6.23
0.13
1.07
0.31
3.40
0.16
0.50
0.11
1.08
0.31
2.68
0.43
11.97
0.43
3.18
0.20
3.03
0.18
10.28
1.33
3.16
0.35
10.63
0.41
5.93
0.52
5.54
0.32
8.26
0.48
16.68
0.47
30.52
1.12
73.99
1.61
300.36
1.75
40.53
1.16
105.97
1.32
187.00

qubits and gate counts has been generated and veriﬁed using
both tools. Each of these circuits has been optimized with O2.
The resulting runtimes can be seen in Fig. 11.

The remainder of the comparison was done against QCEC.
QCEC has been previously evaluated on a benchmark set of
reversible circuits (from [51]) which are mapped to suitable
quantum architectures. We also use these in our evaluation
as well as a selection of common quantum circuits that are
available as part of the MQT Bench benchmark set [52]. For
each benchmark, we consider three conﬁgurations. First, two
circuits that are indeed equivalent are used as input. Then, two
instances are created where errors are injected into one of the
circuits—one with a random gate removed and one where the
control and target of one CNOT gate have been swapped.

The benchmark set of reversible circuits is compiled to the
to the 65-qubit IBM Manhattan architecture using optimization
level O0 (no optimizations), O1 (slight optimizations) and O2
(advanced optimizations). The circuits compiled to O1 and O2
were checked against the unoptimized compiled circuit.

For the quantum circuits, we distinguish two use cases:
The ﬁrst is concerned with verifying the compilation result
of a high-level circuit. To this end, the circuits are compiled
to the 65-qubit IBM Manhattan architecture with a gate-set
comprised of arbitrary single qubit rotations and the CNOT
gate. The second use case is about verifying the equivalence
of two different implementations of the same functionality—
an original circuit and an optimized version (O2).

In the following, we summarize the results of our evalua-
tions by means of a representative subset of benchmarks. The
results for the reversible benchmarks are shown in Table I and
Table II. The results for the quantum benchmarks are shown
in Table III.

For further analysis of the inﬂuence of the size of the
circuits on the runtimes of the equivalence checking routines,
we consider a set of random quantum circuits comprised of
CNOT, Hadamard and T gates with speciﬁc numbers of qubits
and gates. Every gate in this set of benchmarks has a 20%
chance of being a Hadamard gate and a 20% chance of being
a T gate. For this benchmark set only equivalent instances have
been considered. Every circuit has been checked twice, once
against a slightly optimized version (O1) and once against a

highly optimized version (O2).The resulting runtimes can be
seen in Fig. 12a and Fig. 12b.

All computations were conducted on a 4.2 GHz Intel i7-
7700K machine running Ubuntu 18.04 and 32 GiB main
memory. Each benchmark was run with a hard timeout of 1 h
for each method.

D. Discussion

Fig. 11 shows runtimes for the proposed ZX-calculus
checker and Feynver for the set of random Clifford bench-
marks. Fig. 11a shows runtimes with respect to the number
of gates in the original circuit for ﬁxed numbers of qubits
and Fig. 11a shows runtimes with respect to the number of
qubits for ﬁxed numbers of gates. The similarity between
the plots for both methods suggests that both methods scale
somewhat similarly with respect to the size of the circuits,
however. Indeed, the two methods exhibit the same asymptotic
behavior. However, considering the scaling of the vertical
the proposed
axis in the plots, one can clearly see that
implementation outperforms Feynver by orders of magnitude
on all benchmarks.

In the comparison with QCEC, both methods managed to
prove the correct result for all considered circuits where a
result is obtained within the given time frame. As discussed
before, this is not guaranteed by the theory of the ZX-calculus.
On the other hand, the question of completeness for the deci-
sion diagram based approach is trivial. Decision diagrams are
a canonical representation of a matrix. Thus, if the combined
circuit G†G(cid:48) has the identity system matrix,
the decision
diagram for G†G(cid:48) has to be the identity decision diagram as
well.

For the set of reversible benchmarks (Table I and Table II),
the two methods ﬁnished within 10 s of each other for 92 %
of benchmark instances in the case of equivalent instances for
both optimization levels. The remaining reversible benchmarks
and circuits containing large reversible parts in their high-
level description (such as Grover’s algorithm and the Quantum
Random Walk) favor the decision diagram based approach.
These circuits can be exactly compiled to polynomially-sized
quantum circuits comprised only of Clifford+T gates, i.e.,
circuits only using Hadamard (H), Phase (S), CNOT (CX),
and T gates. As a consequence, the respective functionalities

12

TABLE III: Common quantum algorithms

Name

Benchmark
|G|
n

Grover
Grover
Grover
QFT
QFT
Random-Walk
Random-Walk
Random-Walk
QPE-Exact
QPE-Exact
GHZ
Graph State

Grover
Grover
Grover
Grover
QFT
QFT
QFT
QFT
Random-Walk
Random-Walk
Random-Walk

6
7
8
23
38
7
8
9
22
39
65
62

8
9
10
11
32
43
44
75
7
8
9

1606
4732
12482
1311
3591
6523
14084
29325
1217
3823
130
403

12479
37193
104977
308074
2544
4601
4818
14136
2351
4648
9249

|G(cid:48)|

2803
8476
22860
3741
10449
8955
19755
41942
3006
11552
493
2041

12287
36881
104501
307322
2482
4502
4702
11013
1906
3925
7987

Equivalent
tqcec[s]

tzx[s]

Compiled Circuits

3.40
0.39
0.30
1.24
0.91
12.15
0.06
2.00
0.32 >3600
0.24
150.36
0.57
1289.13
>3600
1.31
0.83
0.10
3.19 >3600
<0.01
0.06
0.17
0.36

Optimized Circuits

0.04
8.00
0.14
82.9446
0.42
779.291
0.07
2178.13
0.04
1.43
2.86
10.837
3.01 >3600
1.23 >3600
0.02
0.04
0.09

140.90
2175.39
>3600

1 Gate Missing
tzx[s]

tqcec[s]

Flipped CNOT
tqcec[s]
tzx[s]

0.31
3.03
5.11
0.05
0.20
9.35
455.58
1001.93
0.78
2.89
0.06
0.43

0.04
0.14
0.42
>3600
>3600
0.14
0.33
0.59
>3600
>3600
<0.01
0.17

0.24
2.11
3.02
129.56
72.05 > 3600
588.62
3.57
17.78
1.27
>3600
0.10
62.15
0.11

2316.00
1.49
2.86
3.05
1.30
11.86
78.91
245.39

0.47
4.16
189.61
0.05
0.21
55.44
687.95
2477.31
0.79
2.92
0.59
0.35

9.837
145.574
90.68
2264.67
1.89
2.81
2.90
1.26
212.527
149.49
>3600

0.04
0.14
0.39
902.99
>3600
0.16
0.31
0.50
0.82
>3600
0.01
0.17

0.04
0.17
41.24
281.j04
14.53
1.02
1.21
>3600
0.02
0.11
0.11

(i.e., the system matrices) possess lots of structure that can be
exploited by decision diagrams and, additionally, only feature
a very limited set of complex numbers which limits the effect
of numerical instabilities. In contrast, the ZX-calculus based
approach does not beneﬁt from this structure very much.

In the case of proper quantum circuits (Table III) the story
looks a bit different. For circuits containing no or smaller re-
versible parts (such as the QFT or Quantum Phase Estimation),
the ZX-calculus approach fairs much better in comparison to
decision diagrams. The main obstacle in these cases is that
the considered algorithms feature many rotation gates with
arbitrarily small rotation angles. Due to numerical instabilities
and rounding errors, it might happen that two decision diagram
nodes that should be identical in theory, differ by a small
margin in practice. As a consequence, inherent redundancies
in the underlying representations cannot be captured accurately
anymore. Thus, while the resulting decision diagram is very
close to the identity with respect to the Hilbert-Schmidt norm,
it might grow exponentially large in the worst case. In contrast,
ZX-diagrams are not susceptible to such exponential growth
under numerical errors.

The above observations are similar in the case of non-
equivalent instances. Although runtimes for both methods are
generally lower, the relative performances are still similar.
Since the resulting decision diagram is almost guaranteed
to not be very close to the identity during the equivalence
check, the alternating scheme discussed cannot be as efﬁ-
cient as in the equivalent case. Due to this, QCEC resorts
to simulations of the circuit with random inputs which, as
shown in [23], are expected to show the non-equivalence
within a few simulations. Yet, the complexity of decision
diagram based simulation is still exponential in the worst case.
The rewriting approach of the ZX-calculus is less volatile

to errors in the circuit. During the equivalence check, the
combined circuit diagram is simpliﬁed as much as possible
until no more rules can be applied. Depending on the severity
and kind of error, the procedure stops sooner or later. Of
course, the ZX-calculus checker cannot prove non-equivalence
of circuits, but the experiments show that inability to show
equivalence of circuits with the ZX-calculus at least gives a
strong indication that two circuits are indeed non-equivalent
since the ZX-calculus checker managed to prove equivalence
in all equivalent benchmarks.

What Table III also shows is the volatility of the decision
diagram based approach. Runtimes can increase dramatically
for the same type of circuit with a differing number of qubits.
As soon as the intermediate decision diagram does not admit
is a costly
a compact representation, applying gates to it
operation. This volatility is shown in more detail in the case
of random Clifford+T benchmarks. Fig. 12a and Fig. 12b
show the runtimes of equivalence checking random Clifford+T
circuits with increasing gate count and number of qubits.

In Fig. 12a the different lines correspond to benchmarks
with differing qubit counts. If a data point is at 3600s in the
graph this indicates that the equivalence check took longer
than the timeout limit of 3600s or—in the case of decision
diagrams— it means that the memory limit has been exceeded.
In Fig. 12b different lines correspond to benchmarks with
differing gate counts in the original circuit. With O1 an
average of 0.9% of gates were optimized away. With O2 an
average of 6.1% of gates were optimized away.

Both Fig. 12a and Fig. 12b clearly show that the equivalence
checking routine based on the ZX-calculus has a clear corre-
lation between runtime and the size of the circuits, whether
that size is due to the number of gates or qubits. Although
there are some simpler instances where the runtime decreases,

13

ZX-calculus checker O1

QCEC O1

ZX-calculus checker O1

QCEC O1

ZX-calculus checker O2

QCEC O2

ZX-calculus checker O2

QCEC O2

(a) Runtimes for differing gate count

(b) Runtimes for differing qubit count

Fig. 12: Equivalence checking random Clifford+T benchmarks

the general trend can be clearly seen. Fig. 12a also further
supports the claim in [28] that the complexity of reducing
a ZX-diagram to reduced gadget form is between O(n) and
O(n2) where n is the number of gates in the circuit.

On the other hand,

the plots for QCEC show no such
correlation. Whether QCEC manages to prove equivalence
for a circuit only depends on the speciﬁc circuit in question
after a certain circuit size and complexity has been reached.
This is not too surprising—decision diagrams can blow up
to exponential size with respect to the number of qubits. This
volatility can hardly be held against decision diagrams though.
After all, Fig. 12a and Fig. 12b show runtimes for random
benchmarks, i.e. circuits that do not exhibit much structure.
This volatility is actually a positive feature of the decision
diagram based approach. If this method yields a result at
all it usually does so using signiﬁcantly less time than the
ZX-calculus based method and is, therefore, able to prove
equivalence of some very large circuits where the worst case
complexity of O(n3) of the ZX-calculus based approach leads
to long runtimes.

This shows that the two methods are complementary and are
best used in tandem, especially for more optimized circuits.
For circuits with many qubits but a smaller number of gates,
the ZX-calculus based approach performs more favorably. For
even larger circuits the problem itself is too complex to be
solved even in polynomial time for the ZX-calculus based ap-
proach. In this case, the decision diagram based method might
still be able to show equivalence by keeping the intermediate
decision diagrams small. Because the size of the ZX-diagram
during the equivalence check is bounded by the size of the
original circuit (the number of spiders is strictly decreasing)
the ZX-calculus based equivalence checking method has a low
memory footprint. It can therefore easily be used in parallel
with the decision diagram based method without using too
many resources.

VIII. CONCLUSION

In this work, we examined the viability and effectiveness
of the ZX-calculus for equivalence checking of quantum
circuits. By improving the state of the art to be able to handle

inaccurate representations of complex numbers, permutations
of the input, and output layout of a circuit and ancillary qubits,
we can now verify the results of compilation ﬂows with the
ZX-calculus. We have also discussed the limitations of the
ZX-calculus based approach which prevents it from being a
general equivalence checking method.

To give empirical

results on the practicality of

the
ZX-calculus in equivalence checking, we conducted a case
study comparing the ZX-calculus equivalence checker with
one based on path-sums and one based on decision diagrams.
Empirical results show that path-sums and ZX-calculus ex-
hibit similar scaling when checking the equivalence of Clifford
circuits but the ZX-calculus based approach is still orders
of magnitude faster on average. Also, the ZX-calculus and
decision diagram show similar performance in many cases: but
they differ in key aspects. Decision diagrams show signiﬁcant
beneﬁts for circuits containing large reversible parts, such as
oracles or adders. The sensibility of decision diagrams to
numerical imprecision makes them hard to use on quantum
algorithms that cannot be exactly represented using ﬂoating
points, such as algorithms relying on arbitrary rotation angles,
due to the potential blow-up of the intermediate representation.
The ZX-calculus based equivalence checking procedure is
less sensitive to this and is useful in showing equivalence
in these cases. However, the ZX-calculus tends to be more
suitable for verifying smaller building blocks than whole
quantum algorithms due to the large number of involved gates.
In conclusion, we can see that decision diagrams and the
ZX-calculus can serve as complementary approaches for the
equivalence checking problem.

Acknowledgements

This work received funding from the European Re-
search Council (ERC) under the European Union’s Horizon
2020 research and innovation program (grant agreement No.
101001318), was part of the Munich Quantum Valley, which is
supported by the Bavarian state government with funds from
the Hightech Agenda Bayern Plus, and has been supported
by the BMWK on the basis of a decision by the German
Bundestag through project QuaST.

020000400006000080000# GATES0500100015002000250030003500t [s]10203040506070020000400006000080000# GATES0500100015002000250030003500t [s]# QUBITS10203040506070020000400006000080000# GATES0500100015002000250030003500t [s]# QUBITS10203040506070100020003000400050006000700080009000# GATES0500100015002000250030003500t [s]# QUBITS1020304050607010203040506070# QUBITS02004006008001000t [s]# GATES7000800090001000010203040506070# QUBITS0500100015002000250030003500t [s]# GATES7000800090001000010203040506070# QUBITS02505007501000125015001750t [s]# GATES7000800090001000010203040506070# GATES0500100015002000250030003500t [s]# GATES70008000900010000REFERENCES
[1] M. A. Nielsen and I. L. Chuang, Quantum Computation and
Quantum Information. Cambridge University Press, 2010.
[2] L. K. Grover, “A fast quantum mechanical algorithm for
database search,” Proc. of the ACM, pp. 212–219, 1996.
[3] P. W. Shor, “Polynomial-time algorithms for prime factoriza-
tion and discrete logarithms on a quantum computer,” SIAM
J. Comput., 1997.

[4] M. Cerezo et al., Variational quantum algorithms, 2020. arXiv:

2012.09265.

[5] E. Farhi et al., A quantum approximate optimization algorithm,

2014. arXiv: 1411.4028.

[6] D. Herman et al., A survey of quantum computing for ﬁnance,

[7]

2022. arXiv: 2201.02773.
J. Biamonte et al., “Quantum machine learning,” Nature,
vol. 549, no. 7671, pp. 195–202, 2017. arXiv: 1611.09347.

[8] S. Sivarajah et al., “T—ket>: A retargetable compiler for

NISQ devices,” Quantum Sci. Technol., 2020.

[9] M. Amy and V. Gheorghiu, “Staq—A full-stack quantum
processing toolkit,” Quantum Sci. Technol., vol. 5, no. 3,
p. 034 016, 2020.

[10] K. N. Smith and M. A. Thornton, “A quantum computational
compiler and design tool for technology-speciﬁc targets,” in
Int’l Symp. on Computer Architecture, 2019, pp. 579–588.

[11] T. H¨aner et al., “A software methodology for compiling
quantum programs,” Quantum Sci. Technol., vol. 3, no. 2,
p. 020 501, 2018.

[12] W. Hattori and S. Yamashita, “Quantum circuit optimization
by changing the gate order for 2D nearest neighbor archi-
tectures,” in Int’l Conf. of Reversible Computation, 2018,
pp. 228–243.

[13] Z. Sasanian and D. M. Miller, “Reversible and quantum
circuit optimization: A functional approach,” in Int’l Conf. of
Reversible Computation, R. Gl¨uck and T. Yokoyama, Eds.,
2013, pp. 112–124.

[14] T. Itoko et al., “Optimization of quantum circuit mapping
using gate transformation and commutation,” Integration,
vol. 70, pp. 43–50, 2020.

[15] Y. Nam et al., “Automated optimization of large quantum
circuits with continuous parameters,” npj Quantum Inf, 2018.
[16] B. A. Cordier et al., Biology and medicine in the landscape

of quantum advantages, 2021. arXiv: 2112.00760.

[17] D. Janzing et al., ““Non-identity check” is QMA-complete,”
Int. J. Quantum Inform., vol. 03, no. 03, pp. 463–473, 2005.
[18] S. Yamashita and I. L. Markov, “Fast equivalence-checking for
quantum circuits,” in Int’l Symp. on Nanoscale Architectures,
2010.

[19] L. Berent et al., Towards a SAT encoding for quantum circuits:
A journey from classical circuits to Clifford circuits and
beyond, 2022. arXiv: 2203.00698.

[20] X. Hong et al., Approximate equivalence checking of noisy

quantum circuits, 2021. arXiv: 2103.11595.

[21] G. F. Viamontes et al., “Checking equivalence of quantum

circuits and states,” in Int’l Conf. on CAD, 2007.

[22] M. Amy, “Towards large-scale functional veriﬁcation of
universal quantum circuits,” in International Conference on
Quantum Physics and Logic, 2019.

[23] L. Burgholzer and R. Wille, “Advanced equivalence checking
for quantum circuits,” IEEE Trans. on CAD of Integrated
Circuits and Systems, 2021.

[24] S.-A. Wang et al., “An XQDD-based veriﬁcation method
for quantum circuits,” in IEICE Trans. Fundamentals, 2008,
pp. 584–594.

[25] A. Cowtan et al., A generic compilation strategy for the unitary

[26]

coupled cluster ansatz, 2020. arXiv: 2007.10515.
J. van de Wetering, ZX-calculus for the working quantum
computer scientist, 2020. arXiv: 2012.13966.

14

[27] R. Duncan et al., Graph-theoretic simpliﬁcation of quantum
circuits with the ZX-calculus, 2019. arXiv: 1902.03178.
[28] A. Kissinger and J. van de Wetering, “Reducing T-count with

the ZX-calculus,” Phys. Rev. A, 2020.

[29] A. Kissinger and J. van de Wetering, “PyZX: Large scale
automated diagrammatic reasoning,” presented at the Quantum
Physics and Logic, vol. 318, 2019, pp. 229–241.

[30] T. Peham et al., “Equivalence checking paradigms in quantum
circuit design: A case study,” in Design Automation Conf.,
2022.

[31] G. F. Viamontes et al., “Gate-level simulation of quantum
circuits,” in Asia and South Paciﬁc Design Automation Conf.,
2003, pp. 295–301.

[32] P. Niemann et al., “QMDDs: Efﬁcient quantum function
representation and manipulation,” IEEE Trans. on CAD of
Integrated Circuits and Systems, 2016.

[33] D. Miller and M. Thornton, “QMDD: A decision diagram
structure for reversible and quantum circuits,” in Int’l Symp.
on Multi-Valued Logic, 2006.

[34] A. Zulehner et al., “How to efﬁciently handle complex values?
Implementing decision diagrams for quantum computing,” in
Int’l Conf. on CAD, 2019.

[35] D. M. Greenberger et al., Going beyond Bell’s theorem, 2007.

arXiv: 0712.0921.

[36] G. Vidal and C. M. Dawson, “Universal quantum circuit for
two-qubit transformations with three controlled-NOT gates,”
Phys. Rev. A, vol. 69, no. 1, p. 010 301, 2004.

[37] A. Barenco et al., “Elementary gates for quantum computa-

tion,” Phys. Rev. A, 1995.

[38] D. Maslov, “On the advantages of using relative phase Toffolis
with an application to multiple control Toffoli optimization,”
Phys. Rev. A, vol. 93, no. 2, p. 022 311, 2016.

[39] R. Wille et al., “Mapping quantum circuits to IBM QX
architectures using the minimal number of SWAP and H
operations,” in Design Automation Conf., 2019.

[40] P. Murali et al., “Noise-adaptive compiler mappings for Noisy
Intermediate-Scale Quantum computers,” in Int’l Conf. on
Architectural Support for Programming Languages and Op-
erating Systems, 2019.

[41] G. Li et al., “Tackling the qubit mapping problem for NISQ-
era quantum devices,” in Int’l Conf. on Architectural Support
for Programming Languages and Operating Systems, 2019.

[42] K. Hietala et al., A veriﬁed optimizer for quantum circuits,

2019. arXiv: 1912.02250.

[43] B. Coecke and A. Kissinger, “Picturing quantum processes,”
in Diagrammatic Representation and Inference, P. Chapman
et al., Eds., 2018.
J. D. Biamonte and V. Bergholm, Tensor networks in a
nutshell, 2017. arXiv: 1708.00006.

[44]

[45] M. Backens, The ZX-calculus is complete for stabilizer quan-

tum mechanics, 2013. arXiv: 1307.7025.

[46] R. Vilmart, A near-optimal axiomatisation of ZX-calculus for

pure qubit quantum mechanics, 2018. arXiv: 1812.09114.

[47] R. Wille et al., “JKQ: JKU tools for quantum computing,” in

Int’l Conf. on CAD, 2020.

[48] L. Burgholzer et al., “Random stimuli generation for the
veriﬁcation of quantum circuits,” in Asia and South Paciﬁc
Design Automation Conf., 2021.

[49] L. Burgholzer et al., “Verifying results of the IBM Qiskit
quantum circuit compilation ﬂow,” in Int’l Conf. on Quantum
Computing and Engineering, 2020.

[50] A. W. Cross et al., OpenQASM 3: A broader and deeper
quantum assembly language, 2021. arXiv: 2104.14722.
[51] R. Wille et al., “RevLib: An online resource for reversible
functions and reversible circuits,” in Int’l Symp. on Multi-
Valued Logic, 2008, pp. 220–225.

[52] N. Quetschlich et al., “MQT Bench: Benchmarking software
and design automation tools for quantum computing,” 2022.
arXiv: 2204.13719.

15

Robert Wille Robert Wille is a Full and Distin-
guished Professor at
the Technical University of
Munich, Germany, and Chief Scientiﬁc Ofﬁcer at the
Software Competence Center Hagenberg, Austria.
He received the Diploma and Dr.-Ing. degrees in
Computer Science from the University of Bremen,
Germany, in 2006 and 2009, respectively. Since then,
he worked at the University of Bremen, the German
Research Center for Artiﬁcial Intelligence (DFKI),
the University of Applied Science of Bremen, the
University of Potsdam, and the Technical University
Dresden. From 2015 until 2022, he was Full Professor at
the Johannes
Kepler University Linz, Austria, until he moved to Munich. His research
interests are in the design of circuits and systems for both conventional and
emerging technologies. In these areas, he published more than 400 papers
and served in editorial boards as well as program committees of numerous
journals/conferences such as TCAD, ASP-DAC, DAC, DATE, and ICCAD.
For his research, he was awarded, e.g., with Best Paper Awards, e.g., at TCAD
and ICCAD, an ERC Consolidator Grant, a Distinguished and a Lighthouse
Professor appointment, a Google Research Award, and more.

Tom Peham Tom Peham received his Master’s de-
gree in computer science (2022) from the Johannes
Kepler University Linz, Austria. He is currently a
Ph.D. student at the Chair for Design Automation
at the Technical University of Munich, Germany.
His research interests include design automation for
quantum computing—currently focusing on applica-
tions of the ZX-calculus in this domain.

Lukas Burgholzer Lukas Burgholzer (S’19) re-
ceived his Master’s degree in industrial mathematics
(2018) and Bachelor’s degree in computer science
(2019) from the Johannes Kepler University Linz,
Austria. He is currently a Ph.D. student at
the
Institute for Integrated Circuits at the Johannes Ke-
pler University Linz, Austria. His research focuses
on design automation and software for quantum
computing. In these areas, he has published several
papers on international conferences such as ASP-
DAC, DAC, ICCAD, DATE, and QCE.

