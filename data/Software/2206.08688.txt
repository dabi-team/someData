Detecting Connectivity Issues in Android Apps

Alejandro Mazuera-Rozo1,2, Camilo Escobar-Vel´asquez2, Juan Espitia-Acero2
Mario Linares-V´asquez2, Gabriele Bavota1
1SEART @ Software Institute, Universit`a della Svizzera italiana, Lugano, Switzerland
2The Software Design Lab @ Universidad de los Andes, Bogot´a, Colombia

2
2
0
2

n
u
J

7
1

]
E
S
.
s
c
[

1
v
8
8
6
8
0
.
6
0
2
2
:
v
i
X
r
a

Abstract—Android is the most popular mobile operating
system in the world, running on more than 70% of mobile
devices. This implies a gigantic and very competitive market
for Android apps. Being successful
in such a market is far
from trivial and requires, besides the tackling of a problem or
need felt by a vast audience, the development of high-quality
apps. As recently showed in the literature, connectivity issues
(e.g., mishandling of zero/unreliable Internet connection) can
result in bugs and/or crashes, negatively affecting the app’s
user experience. While these issues have been studied in the
literature, there are no techniques able to automatically detect
and report them to developers. We present CONAN, a tool able to
detect statically 16 types of connectivity issues affecting Android
apps. We assessed the ability of CONAN to precisely identify
these issues in a set of 44 open source apps, observing an
average precision of 80%. Then, we studied the relevance of
these issues for developers by (i) conducting interviews with
six practitioners working with commercial Android apps, and
(ii) submitting 84 issue reports for 27 open source apps. Our
results show that several of the identiﬁed connectivity issues are
considered as relevant by practitioners in speciﬁc contexts, in
which connectivity is considered a ﬁrst-class feature.
Index Terms—Android, Connectivity Issues, Linter

I. INTRODUCTION

The always increasing popularity of mobile devices such as
smartphones has triggered a strong growth of the mobile apps
market in recent years. These apps support everyday activities
such as online shopping, social networking, banking, etc. It
comes without surprise that the research community put the
attention on studying mobile apps from different perspectives
[1], [2]. For example, several studies highlighted the role
played by the apps’ code quality (e.g., usage of robust APIs)
on their success [3]–[6]. Among the several quality attributes
that are relevant for the user experience,
those related to
Internet connectivity are becoming more and more important1.
Indeed, as it has been shown in the literature [7]–[10], network
permissions are the most requested by Android apps, showing
the central role Internet access plays for their functioning.

A recent work by Escobar-Vel´asquez et al. [11] studied
connectivity issues affecting Android apps, namely suboptimal
the user experience in
implementation choices that affect
zero/unreliable connectivity scenarios. For example, an appli-
cation triggering a network operation without ﬁrstly checking
the availability of Internet connection can crash in case of no
connectivity [11].

1Note that in this work we use the term “connectivity” to refer to the
Internet connectivity. Other types of connectivity (e.g., bluetooth, NFC) are
out of the scope of this paper.

The reported ﬁndings conﬁrmed the prevalence of these
issues in 50 open source apps analyzed by the authors, who
reported a total of 304 connectivity issues present in them.

Building on top of the work by Escobar-Vel´asquez et
al. [11], we present in this paper CONAN, the ﬁrst approach
able to automatically detect CONnectivity issues in ANdroid
apps. We designed CONAN in multiple steps. First, we studied
the related literature (e.g., [11]–[20]) and online resources
such as the ofﬁcial Android development guidelines [21] to
deﬁne a catalogue of connectivity issues to target. From this
analysis, we distilled 16 connectivity issues (CI) that CONAN
is currently able to detect by using static analysis.

Then, we deﬁned for each of these issues CIi a detection
strategy, namely a set of rules that can be checked via static
analysis to identify CIi’s instances. The deﬁnition of these
rules was not straightforward. Mobile apps mostly rely on
external libraries (e.g., OkHttp [22]) to handle their network
(HTTP) requests. This means that the implementation of a
detection strategy must be instantiated to support speciﬁc
libraries. Indeed, the implementation patterns change from
library to library, with different APIs involved. For this reason,
we ran a survey with 98 Android developers asking which
HTTP libraries they mostly use when building apps. Based
on the results, we implemented full support for Retroﬁt [23],
OkHttp [22], Volley [24], and HttpURLConnection [25],
which were the main libraries reported by developers.

Once we built our tool, we ran it on a set of 44 open source
apps, identifying 898 candidate connectivity issues in them.
Two of the authors manually inspected a statistically signif-
icant sample (389 instances) of these candidates, to classify
them as true or false positives. This evaluation provided us
with information about the precision of the detection rules we
implemented that, on average, resulted to be 80%.

Finally, we assessed the relevance of the issues identiﬁed by
CONAN. First, we interviewed six practitioners and collected
their opinions about the relevance of the 16 issue types we
detect. The focus here was on the type of issue in general
rather than on speciﬁc instances identiﬁed by CONAN. Second,
we opened 84 issue reports for 27 open source apps, reporting
some of the true positive instances we identiﬁed. The study
participants indicated that the relevance of the identiﬁed issues
strongly depends on the speciﬁc type of app in which they are
identiﬁed. The results of the two studies highlight that, despite
all 16 issues we support represent sub-optimal implementation
choices for handling connectivity in Android apps, some of
them are not perceived as relevant by practitioners.

 
 
 
 
 
 
CONAN implementation and all data used in our study are

III. APPROACH OVERVIEW

publicly available [26].

II. RELATED WORK

Techniques and tools have been proposed in the literature
to improve different quality attributes of mobile apps [27],
such as: performance-related concerns [28]–[31], (ii) security
issues [32]–[36], (iii) poor responsiveness [37]–[39], and (iv)
energy consumption [40]–[44]. Most of these approaches rely
on static and dynamic analysis, while more recent proposals
try to learn semantic and syntactic features of problematic code
components by using deep learning models.

Despite the fact that Internet connectivity is becoming in-
creasingly important for mobile apps, quality issues related to
it have not been addressed by any of the previous approaches
[27]. However, related to the “connectivity topic”, previous
works investigated issues related to network proﬁling [9],
[45]–[47], network privacy concerns [48]–[51], and network
exploitability [52]–[54]. Also, while no tool has been specif-
ically designed for detecting connectivity issues, some of the
techniques proposed in the literature to identify apps’ crashes,
can detect crashes caused by a mishandling of the lack of
connectivity. For instance, Moran et al. introduced CrashScope
[55], [56], a tool to test mobile apps by employing (i) static and
dynamic analysis, and (ii) automatically generated gestures
and contextual inputs. Similarly, Adamsen et al. [57] and Azim
et al. [58] proposed tools for the automated exploration of
apps, with the goal of identifying crash events. The afore-
mentioned approaches systematically explore the app to test
and generate events like intermittent network connectivity.
However, these tools are limited in the type of connectivity
issue they investigate (e.g., intermittent connectivity).

Liang et al. presented Caiipa [59], a mobile app testing
framework employing contextual fuzzing methods to test
Android apps over an expanded context space. Caiipa is
able to simulate a variety of contexts observed in the wild
including diverse network-related factors, for example, the
throughput and loss rates observed for Wi-Fi and 3G networks.
Similarly, JazzDroid [38] is an automated fuzzer which injects
into applications various environmental
interferences, such
as network delays, network trafﬁc interference and HTTP
requests manipulation. While these tools address a variety of
bugs, they are not specialized to connectivity issues.

More broadly, there are methods for diagnosing poor re-
sponsiveness in Android apps given some connectivity short-
comings. Relevant tools under this category are Monkey [60],
AppSPIN [39], TRIANGLE [61] and the approach proposed
by Yang et al. [37]. These tools could eventually test Android
apps looking for connectivity issues, by assuming that random
events could lead to connectivity issues.

CONAN differs from current approaches since our line of
action is aligned to static analysis mechanisms. CONAN does
not need the app to be run nor the simulation of ﬂaky Internet
connectivity. CONAN allows practitioners to spot potential
connectivity issues in the early development stages, since all
it needs is the source code of the app to analyze.

CONAN is a static analysis tool built on top of Android
identifying connectivity issues in
Lint [62], and aimed at
Android apps. CONAN is able to detect these issues for apps
that use the libraries described in Section III-B. The list of con-
nectivity issues that CONAN supports has been deﬁned based
on: (i) ofﬁcial resources for Android developers (i.e., Google
developer guidelines); (ii) library-speciﬁc documentation; and
(iii) research articles on this topic.

A. Android Lint Overview

Besides ensuring that an app meets its functional require-
ments, it is also important to guarantee its quality (e.g., the
absence of bugs). Therefore, the Android SDK provides a tool
named Lint that is able to identify code quality issues via
static analysis. Android Lint is capable of identifying over 400
issue types [63] corresponding to a variety of quality attributes
such as accessibility, correctness, performance, and security.
Android Lint follows the open-closed principle, allowing to
add custom rules that can detect quality issues of interest.

Android Lint supports the ofﬁcial programming languages
used in Android, i.e., Kotlin and Java. While Java has been
historically the ofﬁcial programming language for creating An-
droid apps, Kotlin is currently the recommended language for
native Android apps. By exploiting an universal abstract syntax
tree (UAST), Android Lint can analyze source code written
both in Java and Kotlin, since both of them are represented
using the UAST while running the static analysis. Thus, it is
sufﬁcient to write the detection rule for a speciﬁc quality issue
and Lint provides support for both languages. Additionally, the
Android Lint is also IDE-independent, meaning that it can be
run through the command line either as a standalone tool or
by employing the Gradle wrapper [64] present in Gradle-based
Android projects. Given these characteristics, we integrated the
detection of connectivity issues in Android Lint.

B. Supported libraries

As explained before, the implementation of the detection
strategies strongly depends on the network libraries used by
developers. To decide the libraries for which CONAN should
provide support, we ran a survey investigating which libraries
Android developers use to handle network requests. The
survey has been designed to last at most 5 minutes to maximize
the completion rate and it was structured as reported in Table I.
We collected background information about participants (Q1-
Q4). If a participant answered “zero” to Q4 (i.e., no experience
with native Android apps) the survey ended and the participant
was excluded from the study (4 cases). Q5 aimed to collect
information about the libraries developers use to implement
network requests in Android apps. We provided a predeﬁned
list of existing libraries, with the possibility of specifying ad-
ditional libraries. The predeﬁned list included, among others,
well-known libraries such as: Retroﬁt, OkHttp, and Volley.

To avoid a leading answer bias, each participant was pre-

sented with a shufﬂed version of the predeﬁned list.

Table I: Survey on network libraries used in Android apps

BACKGROUND QUESTIONS

Q1: In which country do you live?
Q2: What is your current job position?
Q3: How many years of programming experience do you have?
Q4: How many years of programming experience do you have
concerning native Android apps?

ADOPTED NETWORK LIBRARIES

Q5: Which libraries do you use to implement network requests
in Android apps?

In addition, an option stating “I have never used an API for

network request” was included.

Besides sharing the survey with developers from companies
we know, it was also shared in social media and within the
Google Android developers group [65]. We collected answers
for two months, with a total of 98 participants that completed
our survey from 41 countries (e.g., Germany, USA, Ukraine,
etc.). On average, participants had ∼10 years of programming
experience and ∼5 years of Android development experience.
Regarding their job position, 7% of participants are B.Sc.
students, 16% M.Sc. students, 2% Ph.D students, 1% Postdoc
and 74% professional software engineers having different
specializations (e.g., CTO, CoFounder, Developer, etc.).

The achieved results reported ﬁve libraries as the ones
used by developers for network requests: (i) Retrofit,
mentioned by 65 participants; (ii) OkHttp, 61 participants;
(iii) HttpURLConnection, 23; (iv) Volley 20; and (v)
Apache HTTP client, with 19 participants. Since from
Android 6.0 Apache HTTP is no longer recommended and
its employment has been discouraged by Google, we decided
to exclude it from the ﬁnal list of libraries to be supported in
CONAN. Concerning the rest of the libraries, these fell under
a long-tail area, thus we included only the ﬁrst four listed by
developers. The complete list of libraries mentioned by the
surveyees is available in our replication package [26].

C. Connectivity Issues Supported by CONAN

In the context of our work, a connectivity issue is a subopti-
mal implementation choice that can affect the correct behavior
of an Android app when used in zero/unreliable connectivity
scenarios. As shown in the literature, these issues can cause
crashes in apps leading to user experience issues [11]. In this
section we describe the six categories of issues we support in
CONAN, while the complete list of 16 issue types (belonging
to these six categories) is presented in Table II. The speciﬁc
detection strategies are described in Section III-D.

1) Connect to network permissions (CNP) :

When performing network operations within an Android
app, the manifest ﬁle must include some essential permissions:
(i) INTERNET, allowing full network access to the app, thus
being able to open network sockets and use custom network
protocols; and (ii) ACCESS_NETWORK_STATE, allowing to

access information about network connections such as which
networks exist and to which ones the device is connected [12].

Despite the fact that both permissions are normal permis-
sions, which means they are granted at install time and do
not need to be requested at runtime, they must be explicitly
included in the manifest [13]. Since the Android manifest
ﬁle is manually written by developers, misconﬁgurations may
happen, such as the lack of permissions that are actually
required by the app [14].

2) Connection Status Check (CSC):

Before performing network operations within an app it is
recommended [12], [16] to validate the state of the network
connectivity, and in particular: (i) the type of network (e.g.,
WI-FI, MOBILE, ETHERNET) that would allow the develop-
ers to check, for example, whether a Wi-Fi network is available
in case large amounts of data must be downloaded (to avoid
the user to incur in unexpected expenses); (ii) its availability,
as a user could be experimenting ﬂaky mobile networks,
airplane mode, and restricted background data; and (iii) its
Internet capabilities, in consideration of a scenario in which a
user is connected to a certain network not providing Internet
access. These validations should be implemented globally in
the project and before triggering a network request, thus pre-
venting an app from inadvertently using wrong conﬁgurations.
Also, if a network connection is unavailable, the application
should be able to handle such a case via the implementation
of ofﬂine practices [11], [15], [20].

3) Network usage management (NMG):

Fine-grained control over the usage of network resources
should be provided to the user if an application constantly
performs network operations [66]. The user should be able
to modify such settings, e.g., the frequency at which the app
syncs data or whether to trigger network operations only when
the device is connected to Wi-Fi. To provide the user with such
a possibility, an Activity offering options to control data
usage should be deﬁned within the Android manifest.

4) Response handling (RH):

Libraries providing HTTP services use callback functions
for
response and error handling. Regarding “successful”
onResponse() callbacks and notably when back-end ser-
vices are not under the app developers control, it is critical
to interpret the data provided by the external service (e.g.,
HTTP message body data and HTTP status codes) since the
lack of routines for handling exceptional scenarios can cause
broken data manipulation, thus leading to a crash. Therefore,
it is important to validate possible errors on the response
in order to make the app react properly in such scenarios.
Concerning the onFailure() callbacks, it is indispensable
to employ the error callback to (i) handle unexpected behaviors
and (ii) improve the user experience by presenting informative
messages aimed at properly conveying the errors [11], [16].

5) Task scheduling (TS):

It is not recommended to implement network operations

performing synchronous requests.

Indeed,

the latter blocks the execution of code which
may cause an unresponsive behavior from the app. Note
that this is not an Android-speciﬁc issue [67], [68]. Avoid-
ing synchronous requests reduces the chance of running
network operations in the main thread, something that
it
is discouraged and also reported with the throwing of a
NetworkOnMainThreadException [11], [16], [17].

Complementary, to reliably schedule asynchronous tasks
that are expected to be properly executed even under ﬂaky
circumstances, the WorkManager API [18] is the recom-
mended scheduling API in Android, and should be pre-
ferred to older managers (e.g., FirebaseJobDispatcher,
GcmNetworkManager, and Job Scheduler).

6) Library speciﬁc issues (LBS):

While the above-presented categories of connectivity issues
can affect network operations implemented using different
libraries, we also identiﬁed a well-known anti-pattern concern-
ing the OkHttp library. According to its documentation [22]:
“OkHttp performs best when you create a single OkHttpClient
instance and reuse it for all of your HTTP calls. This is
because each client holds its own connection pool and thread
pools. Reusing connections and threads reduces latency and
saves memory. Conversely, creating a client for each request
wastes resources on idle pools...”.

D. Detection Strategies used by CONAN

The majority of the issues discussed in Section III-C are
related to network operations triggered by the libraries used
for handling network requests. Therefore, to detect potential
connectivity issues it is crucial to identify in the app’s code
the methods generating network requests. We refer to the
points in code in which a network operation is triggered as
a “network operation trigger” (NT). The identiﬁcation of a
NT is supported by the built-in call graph and interprocedural
analysis provided by Android Lint that eases the identiﬁcation
of method calls raised within an app. This allows to easily
identify (i) the NT, since for each library we support, we
know what the API methods used to start a network operation
are (see next paragraph); and (ii) speciﬁc methods from the
Android APIs that allow to, e.g., check connectivity, verify
the internet access, etc. These will be used in some of the
detection rules described in the following.

For both Retroﬁt and OkHttp the network requests can
be triggered by invoking enqueue() and execute().
The former follows an asynchronous approach whilst
the
latter employs a synchronous mechanism. HttpURLConnection
opens a connection to a remote object given a URL by
employing the synchronous openConnection() method
and it lacks of an asynchronous counterpart. Oppositely, Volley
only operates asynchronously through the add() method.
The current section discusses every detection strategy we
implemented to detect the connectivity issues.

A summary of the 16 supported connectivity issues is
presented in Table II, which reports: (i) the category to
which each issue type belongs (among the ones described in
Section III-C); (ii) the name we assigned to the connectivity
issue; (iii) the libraries in which it can manifest and for which
we provide detection support; and (iv) the resources (e.g.,
articles, ofﬁcial Android guidelines, etc.) we used as references
to deﬁne such a connectivity issue.
1) Connect to network permissions (CNP)

No INTERNET Permission: If a NT exists within the
tool parses the Android
If no
found,

app analyzed by CONAN, our
manifest
to iterate over
android.permission.INTERNET element
CONAN raises a warning.

the declared permissions.
is

No ACCESS_NETWORK_STATE Permission: If an app
queries (i) the state of network connectivity or (i) the sta-
tus of a network interface, both ConnectivityManager
and NetworkInfo packages must be imported. If these
imports exist, CONAN parses the permissions in the mani-
fest and raises a warning if no android.permission.-
ACCESS_NETWORK_STATE element is found.
2) Connection status check (CSC)

No Network connection check (Project & Method): CONAN
veriﬁes whether a NT exists and, if this is the case, it checks
if the isConnected() or onAvailable() methods are
invoked at least once in the project. If such methods have
been invoked at least once but they are not being invoked
in a speciﬁc method including a NT, CONAN notiﬁes of the
need for invoking these methods to check the connection
state before the NT. If, instead, these methods have never
been used in the project but NT exist, CONAN reports such
a lack highlighting all code locations including a NT. Note
that isConnected() has been deprecated in API level 29,
with the recommendation of using instead onAvailable().
However, CONAN still considers both methods as a viable
solution to check the network status in order to be able to
support also apps using an API level lower than 29.

No Network type check (Project & Method): Similarly to
the above-described check for the network status, assuming at
least a NT exists in the app, CONAN veriﬁes whether a call to
either getType() or hasTransport() is present in the
scope of the NT deﬁned in the project. Both methods allow
the developer to know the type of a network (e.g., WiFi). If
these methods have never been invoked in the whole project,
CONAN will notify the developer of such a lack at project-
level reporting all NT in which the network type is not veriﬁed.
Instead, if a speciﬁc method using a NT is not invoking one of
those methods, a method-level warning is raised. The method
getType() has been deprecated in API level 28 in favor of
hasTransport(). Also in this case, we preferred to support
both of them in CONAN to favor compatibility with older apps.
No Internet availability check (Project & Method): For each
NT, CONAN checks if hasCapability() is being called
within its scope with either NET_CAPABILITY_INTERNET
or NET_CAPABILITY_VALIDATED as arguments.

Table II: List of connectivity issues detected by CONAN and their respective coverage given a network library

Category

CNP

CSC

NMG

RH

TS

LBS

ID
INP
ACP
NP
NM
TP
TM
IP
IM
AMN
RI
RB
RC
OF
SYN
WM
OK

Issue
No INTERNET Permission
No ACCESS_NETWORK_STATE Permission
No Network connection check in Project
No Network connection check in Method
No Network type check in Project
No Network type check in Method
No Internet availability check in Project
No Internet availability check in Method
No ACTION_MANAGE_NETWORK_USAGE
No Response implementation
No Response body veriﬁcation
No Response code veriﬁcation
No onFailure implementation
Avoid synchronous calls
No WorkingManager employment
No more than one OkHttp Constructor

(cid:88)
-
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
-
N/A

Retroﬁt OkHttp Volley HttpURLConnection
(cid:88)
-
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

(cid:88)
-
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

(cid:88)
-
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
-
(cid:88)

N/A
(cid:88)
(cid:88)
(cid:88)
(cid:88)
-
N/A

N/A
-
N/A

Resource
[10], [12]–[14]

[11], [12], [15], [16], [19], [20]

[66]
[11], [16], [19], [69]–[71]

[11], [16]–[18], [72]

[22]

The former checks if the network has Internet capabilities
while the latter coveys that Internet connectivity was suc-
cessfully detected. If hasCapability() is never invoked,
CONAN raises a project-level warning and all the methods
including NT will be ﬂagged.

Otherwise, CONAN only locates the methods with NT not
having the Internet availability validation. Note that
there
are other non-standard ways to validate the Internet access;
however, those are not currently supported in CONAN.
3) Network usage management (NMG)

No ACTION_MANAGE_NETWORK_USAGE:

If CONAN
identiﬁes at least one NT, it veriﬁes whether the application
declares in the Android manifest an activity offering options
to the user to control the app’s data usage. Such an activity
is identiﬁed by looking for the declaration of an intent ﬁlter
for the ACTION_MANAGE_NETWORK_USAGE action. If such
an intent is not present in the Android manifest, a warning is
reported to the developer.
4) Response handling (RH)

No Response implementation: Three of the four libraries
we support (i.e., all but HttpURLConnection) allow the imple-
mentation of a Response callback through which it is possi-
ble to check that a response has been successfully returned to
the HTTP request. CONAN veriﬁes if such a response callback
is implemented and extend the scope of this information
by using it as a preliminary check for the detection of the
following issue (i.e., No Response body veriﬁcation). If this
is not the case, a warning is raised. The detection of this issue
is not supported for apps using HttpURLConnection.

No Response body veriﬁcation: Given a NT performed
through Retroﬁt, OkHttp or Volley, CONAN checks if the
body of their respective Response object is being pro-
cessed through a decision-making statement including a null
validation. For HttpURLConnection, such validation is being
addressed with the methods getResponseMessage() and
getInputStream(), since they are the ones containing the
content load.

No Response code veriﬁcation: Similarly to the previous
check, CONAN looks for HTTP status code veriﬁcations within
the Response object of each supported library.

This can be done: in Retroﬁt, through the method code();
in OkHttp, using code() or isSuccessful(); in Volley,
by invoking statusCode(); and in HttpURLConnection
through getResponseCode(). CONAN veriﬁes if these
methods are invoked within a decision-making statement look-
ing for a null validation.

No onFailure implementation: In Retroﬁt and OkHttp,
the error callback is called onFailure(), while Volley han-
dles the errors with the ErrorListener. Lastly, HttpURL-
Connection does not have callbacks, and similarly to the cases
in which the developers have implemented synchronous NT
related to the rest of the libraries, CONAN veriﬁes if they
are surrounded by a TRY-CATCH clause. Additionally, the
CATCH statement is expected to not be empty. CONAN reports
a warning if (i) the method needed for the error callback is
not implemented (in the case of the ﬁrst three libraries), or (ii)
errors are not correctly handled in HttpURLConnection.
5) Task scheduling (TS)

Avoid synchronous calls: CONAN detects each occur-
synchronous NT, namely invocations
rence of
to the
execute() method for both Retroﬁt and OkHttp. Con-
cerning HttpURLConnection, openConnection() itself is
synchronous. Google used to suggest that these operations
should be executed with an asynchronous workaround by
using AsyncTask, which is a Class intended to enable
proper use of the UI thread, widely employed for this aim
before Android API level 30. Currently, it is recommended to
use the standard java.util.concurrent package or the
Kotlin concurrency utilities (depending on the used language)
or co-routines. Since this advice is recent and eventually
AsyncTask will no longer be supported, CONAN pinpoints
every synchronous NT in the app under analysis. Note that the
Volley library does not provide any synchronous operation.

No WorkingManager employment: WorkingManager
is an API intended to ease the implementation of reliable
asynchronous tasks scheduling. CONAN detects in the source
code ﬁles the importing of old APIs that have been replaced by
WorkingManager, namely FirebaseJobDispatcher,
GcmNetworkManager, and JobScheduler,
reporting
such an issue to the developers.

A. Data Collection and Analysis

To answer our research questions, we selected 44 Android
open source apps as subject systems. As a starting point we
adopted the two following datasets:

Geiger et al. [73]. Composed of 8,431 real-world open-
source Android apps. It combines source and history informa-
tion from GitHub with metadata from Google Play store.

Coppola et al. [74]. Composed of 1,232 Android apps. The
authors of this dataset mined all projects hosted on F-Droid
[75], a repository for free and open source Android apps.

After removing duplicates among both datasets we obtained
8,157 unique open source Android apps, from which we
excluded the ones no longer available on GitHub, leaving
8,003 apps. Then, we ﬁltered out those not written in Java
and/or Kotlin, obtaining 6,847 apps. This new dataset was
then analyzed to identify repositories that could support an
automated running of CONAN. This basically translates in the
requirement that the repositories must use Gradle as their
project-building tool. Thus, we identiﬁed repositories that: 1
contain the source code of more than one Android app (70);
2 do not use Gradle (1,902); 3 use Gradle, without however
adopting the default name (i.e., app) for the main module to
build (3,522); and 4 use Gradle, by adopting a customized
name for the main module (1,353). We discarded repositories
from 1 and 2 , since they do not support the automated
running of CONAN. Also, we excluded all repositories not
using a version of Gradle equal or newer than 6.7.1. Indeed,
accordingly to the Android Lint documentation [76], [77], the
version in which we integrated CONAN (30.0.0-alpha10) works
properly on projects adopting those Gradle versions.

After these ﬁlters, we obtained a sample of 62 repositories
belonging to 3 and 160 repositories belonging to 4 . For the
projects in 4 (i.e., not using the default name for the main
module), we manually identiﬁed such a name. The ﬁnal set
of 44 open-source apps was obtained as the set of projects
successfully compiling and notifying at least one incident (i.e.,
a warning raised by CONAN) when running CONAN on their
latest snapshot (as of July 19th, 2021). On average, these apps
have 1.6k commits, 36 releases, and 520 issues.

1) RQ1: What is the precision of CONAN in identifying
Connectivity issues in Android apps?: CONAN detected 898
candidate issues, distributed by app and type of issue as re-
ported in the ﬁrst three columns of Table III. Note that for two
connectivity issues (i.e., those belonging to the CNP category
in Table II) we did not ﬁnd any instance in the analyzed apps,
excluding them from RQ1. Two authors performed a manual
validation on a sample of the 898 candidate instances. We
performed a stratiﬁed sampling: For each connectivity issues
type Ti we targeted the random selection of 50 of its instances
by considering the analyzed apps as strata. This means that
the number of Ti
instances we selected from each app is
proportional to their prevalence in the app. For example, if Ti
affects three apps with 70, 20, and 10 instances, respectively,
when extracting a random sample of 50 instances we picked
35, 10, and 5 instances from the three apps.

Fig. 1: No onFailure implementation report

6) Library speciﬁc issues (LBS)

No more than one OkHtpp Constructor: CONAN analyzes
the entire project looking for constructor calls of OkHttp-
Client(). In case more than one instance is deﬁned within
the application a warning is raised.

E. CONAN Report

CONAN adopts the same output format of Android Lint
describing the identiﬁed connectivity issues in a structured
HTML ﬁle. For each identiﬁed issue CONAN provides the
snippet of code in which it has been identiﬁed marking its
category as connectivity issues. Figure 1 shows an example
of report for the issue type No onFailure implementation.
Android Lint, and consequently our tool, can also be used
directly in the IDE. In this case, identiﬁed issues will be
marked directly in the code editor.

IV. STUDY DESIGN
The goal of this study is to assess (i) the precision of
CONAN in detecting connectivity issues in Android apps, and
(ii) the relevance of the identiﬁed issues from the practitioners’
perspective. The context is represented by (i) 44 open source
apps on which we run CONAN looking for connectivity issues;
(ii) six interviews conducted with practitioners working with
Android apps; and (iii) 84 issues we opened in 27 open source
apps to report the connectivity issues identiﬁed by CONAN.
We aim at answering the following research questions:
RQ1: What is the precision of CONAN in identifying con-
nectivity issues in Android apps? We run CONAN on 44
open source apps, and we manually validated the reported
connectivity issues, classifying them as true or false positives.
We discuss CONAN’s accuracy for the different types of issues
it is designed to detect (see Section III).

RQ2: What

is the relevance of

the connectivity issues
identiﬁed by CONAN for Android practitioners? We answer
this research question in two steps. First, we conducted six in-
terviews with Android practitioners asking them the relevance
of the connectivity issues that CONAN supports. Note that in
these interviews practitioners did not inspect actual instances
detected by CONAN, but were rather asked for their opinion
about the types of issues we support (Table II). Second, we
opened 84 issues in the issue tracker of 27 of the 44 apps
analyzed in RQ1 to collect developers’ feedback about the
connectivity issues we identiﬁed. In this case, speciﬁc issue
instances are studied.

Table III: Number of candidate connectivity issues identiﬁed by CONAN in the 44 subject apps

ID

Issue Type

#Affected
Apps

#Candidate
Instances

#Manually
Validated

True
Positives

False
Positives

Precision

No Network connection check in Project
No Network connection check in Method
No Network type check in Project
No Network type check in Method
No Internet availability check in Project
No Internet availability check in Method
No ACTION_MANAGE_NETWORK_USAGE
No Response implementation
No Response body veriﬁcation
No Response code veriﬁcation
No onFailure implementation
Avoid synchronous approach
No WorkingManager employment
No more than one OkHttp Constructor

NP
NM
TP
TM
IP
IM
AMN
RI
RB
RC
OF
SYN
WM
OK

Total

16
26
20
26
25
27
42
1
9
8
13
23
3
6

16
163
20
166
25
191
42
1
16
15
45
189
3
6

898

16
50
20
50
25
50
42
1
16
15
45
50
3
6

16
50
20
50
25
50
42
0
1
6
10
41
3
0

389

314

100%
100%
100%
100%
100%
100%
100%
0%
6.25%
40%
22.22%
82%
100%
0%

0
0
0
0
0
0
0
1
15
9
35
9
0
6

75

There are two exceptions to this procedure: (i) when an app
is only affected by a single Ti instance, we always selected
such an instance for manual inspection; (ii) if Ti had less than
50 instances across all apps, we picked all its instances for
manual analysis.

Overall, we manually analyzed 389 instances, ensuring
a signiﬁcance interval (margin of error) of ±5% with a
conﬁdence level of 99% [78]. The two authors involved in
the manual validation independently inspected each instance,
classifying it as a true positive (TP) or false positive (FP). This
was done by inspecting the source code of the apps. Once
completed, the two authors together inspected the 44 cases
of conﬂict (11.31%), solving them through open discussion.
The inspected instances together with the output of the manual
validation are available in our replication package [26].

Using the results of our manual analysis we computed
the precision, i.e., TP/(TP+FP), of CONAN for each of the
supported issue types, thus answering RQ1. Note that we did
not assess CONAN’s recall since this would require the manual
analysis of the entire code base of all subject apps.

2) RQ2: What is the relevance of the connectivity issues
identiﬁed by CONAN for Android practitioners?: We answer
RQ2 in two steps. First, we conduct six interviews with
Android practitioners in our contact network asking them
about the relevance of the issue types currently supported
in CONAN. The ﬁrst part of the interview asked participants
a few demographics questions including (i) the country in
which they were located; (ii) their role in the company (e.g.,
developer,
tester); (iii) their programming experience and
Android programming experience (in years). Then, we asked
a few questions related to whether (i) they have experienced
connectivity issues as app users; (ii) they adopt connectivity
strategies (i.e., code aimed at ensuring the proper working on
the app in different connectivity scenarios) in their apps; (iii)
they think connectivity strategies are part of the prioritized
tasks when developing an app. After that, we asked the
participants to assess their perceived relevance of the 16
connectivity issues that CONAN is able to detect.

For each issue type, we showed the participant a description
of the issue and asked their perceived relevance of this issue
on a ﬁve-point scale: Very Irrelevant, Irrelevant, Neutral,
Relevant, Very Relevant. The last question of the interview
was: What kind of support would you like to have from
an automated tool
these issues? We
that helps to detect
summarize in Section V the participants’ perceived relevance
of the issue types we support.

Second, using the true positive instances (i.e., actual connec-
tivity issues) manually identiﬁed in RQ1, we opened 84 issues
in 27 of the 44 apps involved in our study (some were excluded
due to the lack of true positive instances to report). When the
same issue type affected the same app in multiple locations
(e.g., several methods of the app used network connectivity
without ﬁrst checking for the status of the network), we only
opened one issue summarizing all of them. For this reason, the
84 reports concern a total of 150 connectivity issues detected
by CONAN. We discuss in Section V the number of issue
reports in which developers (i) reacted by posting a comment
to our issue; (ii) conﬁrmed the issue by just commenting; or
(iii) conﬁrmed the issue and also took proper action to ﬁx it.
We also report qualitative examples of issues conﬁrmed and
“discarded” by developers.

V. RESULTS

We discuss the achieved results accordingly to the formu-
lated RQs. We start by discussing the results related to RQ1
(Section V-A) focusing on the data reported in Table III and
complementing its discussion with qualitative examples. The
results achieved for RQ2 are instead presented in Section V-B
(relevance of the issue types identiﬁed by CONAN as perceived
by the six interviewed practitioners) and Section V-C (per-
ceived relevance of the issue instances identiﬁed by CONAN
in open source projects). We provide in our replication pack-
age [26] (i) the CONAN tool, which is available as a JAR
ﬁle with instructions on how to run it; (ii) the list of 898
connectivity issues detected by CONAN; (iii) the transcriptions
of our interviews (translated from Spanish to English); (iv) the
list of opened issues; and (v) the list of analyzed apps.

A. RQ1: Precision of CONAN

Looking at Table III, it is ﬁrst important to notice the lack of
speciﬁc connectivity issues, for which no instances have been
identiﬁed in our study. These are the issues belonging to the
network permissions, and in particular “No INTERNET per-
mission” and “No ACCESS_NETWORK_STATE permission”.
We believe that this result is a consequence of our ex-
in which we run CONAN on the latest
perimental design,
available snapshot of the subject apps. Indeed, issues related
to permissions are more likely to affect the app in the early
stages of the software lifecycle, since those issues are easy to
spot, not allowing the app to properly work.

Concerning the connectivity issues within the Connection
Status Check (CSC) category, this block of issues comprises
most of the identiﬁed instances, with a total of 581 candidate
instances, accounting for 64% of total instances. Based on our
manual validation, all the issues in the CSC category were
detected with a 100% precision (see Table III).

The CSC issue depicted in Fig. 2a is a representative ex-
ample of a network operation performed without verifying the
network connection, network type nor the Internet availability.
The presented snippet of code is in charge of opening an
InputStream to the HTML content of the given URL. The
NT in this scenario is openConnection(), which returns a
URLConnection instance that represents a connection to the
remote object. Similarly, in Open Song Tablet (see Fig. 2b),
the developers are downloading songs from a URL, also in this
case implementing a NT with openConnection(). Despite
the downloading operation is performed within a TRY-CATCH
block that can handle eventual exceptions, the lack of speciﬁc
checks for network connection (NM), network type (TM), and
Internet availability (IM) does not allow to notify the user
about speciﬁc errors occurring when running the NT, leaving
the user with a generic error. The lack of informative messages
in case of connectivity errors is one of the main issues recently
highlighted in the literature [11].

(a) Lack of connection status check in mtg-familiar

Also in this case all detected instances we manually validated
were classiﬁed as true positives. Differently, for issues related
to the response handling, CONAN’s precision is not consistent
across the different issue types.

Concerning RI (i.e., the lack of onResponse implementa-
tion), CONAN only reported a single instance that was classiﬁed
as a false positive, since developers used a non-standard
mechanism to handle the request. Also in this case, it is likely
that this type of issue affect the app in the early development
stages. In fact, in mature projects the onResponse imple-
mentation is expected. Thus, the identiﬁcation of this type of
issue is probably more useful when using CONAN inside the
IDE rather than when running it on newer versions of the app.
Similarly, the identiﬁcation of RB (no response body ver-
iﬁcation) and OF (no onFailure implementation) also
resulted in low precision values, being 6.25% and 22.2%,
respectively. This suggests that the detection rules we deﬁned
must be revised and reﬁned to handle special cases we did
not consider. For example, in case of RB, among the cases
highlighted as false positive, we noticed that developers were
assigning the body() content to a variable and then a null
check was performed. However, CONAN checks if the body
given by a Response object is being processed by the app
through a direct decision-making statement such as a null
validation, meaning that this heuristic must be enhanced in
future releases of our approach. Moreover, concerning OF,
in some false positives we found the presence of logging
elements (e.g., Log.d()) printing the errors in response to
a failure. While these are “borderline” strategies to handle
errors, we still decided to consider them as a false positives. A
better precision (40%) was achieved by CONAN when detecting
instances of RC (no response code veriﬁcation). Still, also here
margins for improvement are present.

Moving to the issues

related to the task schedul-
i.e., “avoid synchronous approach” (SYN) and “no
ing,
WorkingManager employment” (WM),
the precision is
quite high, with 82% and 100% of correctly detected instances,
respectively. However, for the “no WorkingManager em-
ployment” issue we only assessed the three candidate instances
CONAN identiﬁed. Several examples of SYN issues within the
Ultrasonic app are shown in Fig. 3. Developers are using
OkHttp’s execute() method in order to synchronously
retrieve some resources from an external server. This issue
was detected in an Kotlin ﬁle.

(b) Lack of connection status check in OpenSongTablet

Fig. 2: Missing connection status veriﬁcation

Out of the 44 inspected apps, 42 of them do not implement
the intent ﬁlter ACTION_MANAGE_NETWORK_USAGE (AMN
issue), meaning that they do not allow their user to have ﬁne-
grained control over the app’s usage of network resources.

Fig. 3: Several synchronous operations in Ultrasonic

Lastly, for the issue speciﬁc to OkHttp, i.e., no more than
one OkHttp Constructor (OK), CONAN found six instances
all labeled as false positives.

InputStream getHttpInputStream(URL url …) {        ...        HttpURLConnection.setFollowRedirects(true);        HttpURLConnection connection = (HttpURLConnection) (url).openConnection();        ...        connection.setRequestProperty(...);        connection.setConnectTimeout(5000);        connection.setInstanceFollowRedirects(true);}Project: mtg-familiar | File: FamiliarActivity.java protected String doInBackground(String… sUrl) {InputStream input = null;OutputStream outputStream = null;HttpURLConnection connection = null;    try {          URL url = new URL(address);          connection = (HttpURLConnection) url.openConnection();          connection.connect(); … }}Project: OpenSongTablet | File: DownloadTask.javaval response = API.getUser(username).execute().throwOnFailure()Project: Ultrasonic | File: RESTMusicService.ktval response = API.getBookmarks().execute().throwOnFailure()val response = API.getSongsByGenre(...).execute().throwOnFailure()val response = API.getShares().execute().throwOnFailure()This is because CONAN was run not only on the source code
of the subject apps, but also on the code of their dependencies.
This means that it identiﬁed several instances of OkHttp
clients that, however, were not due to multiple instances
declared within the app, but in the app and in its dependencies.
This can be avoided by simply setting an Android Lint
property, indicating that it must only be run on the app’s code.
Note also that such a setting only affected the detection of this
speciﬁc type of issue (i.e., all other reported instances were
related to the app’s source code).

B. RQ2: Relevance of connectivity issues (Interviews)

We focus our discussion on the relevance of the types of
connectivity issues CONAN supports as perceived by the six
interviewed Android practitioners (Fig. 4), while the answers
they provided to all our questions are available in the replica-
tion package [26]. Participants have, on average, ∼7 years of
overall programming experience and approximately ∼3 years
concerning Android engineering tasks. The rows in the heat
map represent the six interviewed practitioners (indicated with
In, with n going from 1 to 6), while the columns are the types
of issues we investigated. The rectangle at the intersection
participant/issue-type can have different colors based on the
speciﬁc answer we got. First, we use a 5-step color scale from
blue to red representing the reported relevance: dark blue for
very irrelevant, light blue for irrelevant, white for neutral, light
red for relevant, and dark red for very relevant. Additionally,
there are 2 marks that are used in the ﬁgure to represent: (i)
the cases in which a participant did not answer the question
(i.e., a NA is shown in the rectangle); and (ii) cases in which
the interviewee stated that the relevance of the issue depends
on the app analyzed (e.g., by how important is connectivity
for that app)—an asterisk inside the rectangle is shown in this
case. In the latter case, Fig. 4 reports the highest relevance
perceived by the interviewee (e.g., the answer “it can be very
relevant but it depends on the connectivity usage of the app” is
represented with a dark red rectangle with an asterisk inside).

Fig. 4: Issue relevance classiﬁcation from interviews
As it can be seen from Fig. 4, none of the issues was
tagged as very irrelevant by the interviewees. Nevertheless,
three of the interviewees reported one case (each) as irrelevant.
Speciﬁcally, I2 said that checking Internet availability at
method level is irrelevant if there is already an existent check
at project level; I5 claimed that allowing users to manage
network usage is irrelevant since efﬁcient design processes
should contemplate that factor; ﬁnally, I6 said that checking
the implementation of response handling is irrelevant since
they never saw such a problem in any of the app they worked
on.

However, as it can be seen from Fig. 4, for each of these
three issues there were other developers ﬁnding them relevant.
The issues perceived as more relevant by practitioners are:
(i) No Network connection check in Project, (ii) No onFailure
implementation, (iii) No Network connection check in Method,
and (iv) No Internet availability check in Project. Basically,
issues related to the lack of checks for connectivity and the
lack of handling error conditions. For example, I1 talking
about the No Network connection check in Project issue, said:
“In our case, it would be very relevant. In our apps we start
by validating that a network connection exists; we have a
background process for that that starts with the opening of
the application, it is like a daemon continuously checking”.

is

the case of

I5 talking about the No onFailure implementation issue said:
“Yes, I have seen it and I think it is very relevant. In fact,
for me it is so relevant that I usually prefer to implement the
error paths and then the success path, because in a distributed
environment I do not know what is happening to the device”.
On the other side there are issue types that practi-
the
tioners do not ﬁnd relevant. This
No ACCESS_NETWORK_STATE Permission (ACP) that was
marked by three interviewees as “neutral” in terms of rele-
vance, since they claimed that the associated permission is
added along with the INTERNET Permission. Also, intervie-
wees do not ﬁnd the No WorkingManager employment
(WM) as an actual
issue, since the beneﬁts provided by
this component for asynchronous tasks are considered minor.
Finally, four of the six participants do not use the OkHttp
library and, thus, did not assess the relevance of the No more
than one OkHttp Constructor (OK), that was marked as
relevant and very relevant by the remaining two practitioners.
As a ﬁnal note, it is worth noticing that ﬁve out of the
six participants indicated that the relevance of at least one
of the assessed issue types depend on the speciﬁc context
(i.e., app) in which it manifests and, more in particular, on
the importance that connectivity has in the affected app.

To summarize, we found that: (i) for 13 out of the 16 issue
types, there is a majority of participants (at least 4 out of
6) assessing them as relevant or very relevant; and (ii) the
relevance of speciﬁc issues is inﬂuenced by the context in
which they appear.

C. RQ2: Relevance of connectivity issues (OSS projects)

We opened 84 GitHub issues in 27 of the 44 apps we
studied. These issues represent a total of 150 connectivity
issues since, as previously said, a single opened issue can con-
cern multiple instances of the same issue type (e.g., multiple
instances of No Network connection check in Method). Once
opened the issues, in the following six weeks we interacted
with the developers who reacted by posting a comment and/or
taking other types of action. After the six weeks, we summa-
rized the status of the 84 issues.

Out of 84, 53 resulted in a reaction from the developers,
which means that either they provided us a feedback by
commenting or they modiﬁed the status of the issue (e.g., by
closing it, adding a tag).

ACPINPNPNMTMTPIPIMRIAMNRBRCSYNOFWMOKI1*NAI2*******I3NAI4*NANAI5*I6*NANACNMNCNMGDHTSLBS*IrrelevantNeutralRelevantVery RelevantNo AnswerNA** Depends on ContextOut of these 53 issues, 15 have been recognized as connec-
tivity issues, and for 8 of them the developers implemented
a change to address the issue. For example, developers of
OpenSongTablet commented: “Many thanks for alerting me
to this. This issue is addressed in an upcoming version that is
still in early alpha [...]”.

Concerning the remaining 38 issues, in 14 cases the issue
was just closed without any interaction with the developer.
The remaining ones were tagged by the developers as false
issues, leading to the their closure. Only on 24 of those the
developers provided us feedback regarding the issues. In one
of those, developers pointed to the low relevance of the type
of issue (i.e., No Network connection check in Method) in
BinaryEye, explaining that “If this app would make many
requests at once, then I would probably check the network
connection before making all these requests. But for just one
request per scan, this would be overkill”. In the other cases,
the negative outcome (i.e., the lack of ﬁxing) was due to the
fact that the developers did not recognize the reported issue
as a potential point of failure in connectivity scenarios.

Interestingly, we did not observe any speciﬁc pattern in
terms of types of issue that were considered relevant/not
relevant by developers. In other words, some issue types were
considered relevant by some developers (with a consequent
ﬁxing) and irrelevant by others (with a closing of the issue).
These ﬁndings point to three observations. First, as already
observed in our interviews, the relevance of the connectivity
issues we identify is substantially impacted by the context in
which they appear (i.e., by the affected app). Second, it is
possible that some of the issues identiﬁed by CONAN, while
recognized in the literature or in the technical documentation,
are unlikely to manifest in failures, thus being mostly con-
sidered as “good practices” rather than potential “bugs” to
ﬁx. This implies that a better reporting of the severity of the
identiﬁed issue might be needed in CONAN, possibly exploiting
an “adaptive” mechanism that can change the severity level
depending on the app under analysis. Third, while it is clear
that more work is needed on CONAN, we found as a positive
result the identiﬁcation of 26 conﬁrmed connectivity issues
(reported in the 15 conﬁrmed issues) in open source apps.

VI. THREATS TO VALIDITY
Construct Validity. To assess the precision of CONAN,
we relied on a manual analysis independently performed by
two authors, reporting the number of conﬂicts raised in this
process. Despite such a double-check, we are aware that
imprecisions are still possible, and this is one of the reasons
why we share in the replication package [26] the output of our
manual validation. Concerning our second research question,
we acknowledge that both in the interviews and in the study
involving the opening of issues, the reported results represent
the subjective perception of practitioners.

Internal Validity. The set of connectivity issues that CONAN
supports was derived by the analysis of the literature, the
ofﬁcial Android developer guidelines, and the documentation
of the libraries used to establish HTTP connections.

We acknowledge that our contribution is limited by the fact
that CONAN is tied to speciﬁc versions of certain libraries
and that other, and possibly more relevant connectivity issues,
might have been missed in our study. Similarly, the detection
strategies we deﬁned connectivity issues were based on our
intuition. Further research is needed to optimize/improve them.
External Validity. In RQ1 the assessment of CONAN’s
precision is based on a set of 389 manually validated instances.
Additional
instances should be inspected for better gener-
alization as we acknowledge that static analysis approaches
are prone to introduce false positives. For RQ2, we preferred
interviews with a limited number of practitioners rather than
surveys with more participants to better understand and inter-
pret the practitioners’ perceptions of the connectivity issues.
Finally, the number of issues we opened, while limited (84),
still covered a total of 150 connectivity issues.

VII. CONCLUSION & FUTURE WORK
We presented CONAN, a tool designed to statically detect
connectivity issues affecting Android apps. The list of 16
connectivity issues supported by CONAN has been derived
from the existing literature and by studying the technical
documentation of Android and of libraries usually adopted
to handle HTTP connections in Android apps. The precision
of the detection strategies we implemented has been evaluated
by manually inspecting the candidate instances identiﬁed by
CONAN, showing that improvements are needed for the detec-
tion of 5 of the 16 issue types, while excellent precision is
achieved in the remaining 11 cases.

We then assessed the relevance of the issue types detected
by CONAN by interviewing six practitioners, showing that
they found most of the issues relevant, despite reporting their
relevance as inﬂuenced by the speciﬁc context (app) in which
they appear (e.g., domain category). Such a ﬁnding has also
been conﬁrmed in the subsequent evaluation performed by
opening 84 issues in open source projects, with contradicting
observations provided by the developers who managed those
issues. In 15 cases, they conﬁrmed the issue (for a total of
26 actual code issues identiﬁed, since one issue report could
concern multiple connectivity issues), while in 24 cases they
closed the issue as non-relevant for their app.

The achieved results are not fully positive nor negative, in-
dicating the need for additional research on connectivity issues
and on effective detection tools considering different Android
artifacts (e.g., Android Packages - APKs) and languages (e.g.,
Flutter/DART). Also, additional studies with developers are
needed to better understand the contexts in which connectivity
issues are actually considered relevant.

VIII. ACKNOWLEDGEMENTS

Mazuera-Rozo and Bavota gratefully acknowledge the ﬁ-
nancial support of the Swiss National Science Foundation
for the CCQR project (SNF Project No. 175513). Escobar-
Vel´asquez and Linares-V´asquez were funded by a Google
Latin America Research Award 2018-2021. Escobar-Vel´asquez
was supported by a ESKAS scholarship, No. 2020.0820.

REFERENCES

[1] M. Nagappan and E. Shihab, “Future trends in software engineering
research for mobile apps,” in 2016 IEEE 23rd International Conference
on Software Analysis, Evolution, and Reengineering (SANER), vol. 5,
2016, pp. 21–32.

[2] W. Martin, F. Sarro, Y. Jia, Y. Zhang, and M. Harman, “A survey of app
store analysis for software engineering,” IEEE Transactions on Software
Engineering, vol. 43, no. 9, pp. 817–847, 2017.

[3] G. Bavota, M. Linares-V´asquez, C. E. Bernal-C´ardenas, M. D. Penta,
R. Oliveto, and D. Poshyvanyk, “The impact of api change- and fault-
proneness on the user ratings of android apps,” IEEE Transactions on
Software Engineering, vol. 41, no. 4, pp. 384–407, 2015.

[4] M. Linares-V´asquez, G. Bavota, C. Bernal-C´ardenas, M. Di Penta,
R. Oliveto, and D. Poshyvanyk, “Api change and fault proneness: A
threat to the success of android apps,” in Proceedings of the 2013 9th
Joint Meeting on Foundations of Software Engineering, ser. ESEC/FSE
2013, 2013.

[5] Y. Tian, M. Nagappan, D. Lo, and A. E. Hassan, “What are the charac-
teristics of high-rated apps? a case study on free android applications,”
in 2015 IEEE International Conference on Software Maintenance and
Evolution (ICSME), 2015, pp. 301–310.

[6] E. Noei, M. D. Syer, Y. Zou, A. E. Hassan, and I. Keivanloo, “A study
of the relation of mobile device attributes with the user-perceived quality
of android apps,” Empirical Softw. Engg., 2017.

[7] N. S. A. A. Bakar and I. Mahmud, “Empirical analysis of android apps
permissions,” in 2013 International Conference on Advanced Computer
Science Applications and Technologies, 2013, pp. 406–411.

[8] M. Frank, B. Dong, A. Porter Felt, and D. Song, “Mining permission
request patterns from android and facebook applications,” in 2012 IEEE
12th International Conference on Data Mining, 2012, pp. 870–875.
[9] S. Mostafa, R. Rodriguez, and X. Wang, “Netdroid: Summarizing net-
work behavior of android apps for network code maintenance,” in 2017
IEEE/ACM 25th International Conference on Program Comprehension
(ICPC), 2017, pp. 165–175.

[10] K. Olmstead and M. Atkinson, “Apps permissions in the google play

store,” 2015.

[11] C. Escobar-Vel´asquez, A. Mazuera-Rozo, C. Bedoya, M. Osorio-Ria˜no,
M. Linares-V´asquez, and G. Bavota, “Studying eventual connectivity
issues in android apps,” Empirical Software Engineering, 2022.
to the network.”
//developer.android.com/training/basics/network-ops/connecting

[Online]. Available: https:

[12] Google,

“Connect

[13] ——, “Permissions on android.” [Online]. Available: https://developer.

android.com/guide/topics/permissions/overview

[14] A. K. Jha, S. Lee, and W. J. Lee, “Developer mistakes in writing
android manifests: An empirical study of conﬁguration errors,” in
2017 IEEE/ACM 14th International Conference on Mining Software
Repositories (MSR), 2017, pp. 25–36.

[15] J. Archibald, “The ofﬂine cookbook.” [Online]. Available: https:

//web.dev/ofﬂine-cookbook/

[16] C. Escobar-Vel´asquez, M. Linares-V´asquez, G. Bavota, M. Tufano,
K. P. Moran, M. Di Penta, C. Vendome, C. Bernal-C´ardenas, and
D. Poshyvanyk, “Enabling mutant generation for open- and closed-
source android apps,” IEEE Transactions on Software Engineering,
2020.

“Processes

[17] Google,

[Online]. Available:
and threads overview.”
https://developer.android.com/guide/components/processes-and-threads
[18] ——, “Schedule tasks with workmanager.” [Online]. Available:

https://developer.android.com/topic/libraries/architecture/workmanager

[19] E. Hellman, Android Programming : Pushing the Limits. Chichester,

[20] Google,

West Sussex, United Kingdom: John Wiley & Sons Ltd, 2014.
for

Available:
https://developer.android.com/docs/quality-guidelines/build-for-billions/
connectivity#network-ofﬂine

“Connectivity

[Online].

billions.”

[21] “Android development guides. https://developer.android.com/guide.”
[22] “Okhttp. https://square.github.io/okhttp/.”
[23] “Retroﬁt. https://square.github.io/retroﬁt/.”
[24] “Volley. https://developer.android.com/training/volley/index.html.”
[25] “Httpurlconnection.

https://developer.android.com/reference/java/net/

HttpURLConnection.”

[26] A. Mazuera-Rozo, C. Escobar-Vel´asquez, J. Espitia-Acero, M. Linares-
V´asquez, and G. Bavota, “Replication package.” [Online]. Available:
https://sites.google.com/view/conan-ecn

[27] L. Li, T. F. Bissyand´e, M. Papadakis, S. Rasthofer, A. Bartel, D. Octeau,
J. Klein, and L. Traon, “Static analysis of android apps: A systematic
literature review,” Information and Software Technology, 2017.

[28] T. Parsons and J. Murphy, “Detecting performance antipatterns in
component based enterprise systems,” Journal of Object Technology,
2008.

[29] C. Trubiani, A. Bran, A. van Hoorn, A. Avritzer, and H. Knoche, “Ex-
ploiting load testing and proﬁling for performance antipattern detection,”
Information & Software Technology, 2018.

[30] M. Grechanik, C. Fu, and Q. Xie, “Automatically Finding Performance
Problems with Feedback-directed Learning Software Testing,” in Inter-
national Conference on Software Engineering (ICSE), 2012.

[31] Y. Liu, C. Xu, and S.-C. Cheung, “Characterizing and detecting perfor-
mance bugs for smartphone applications,” in Proceedings of the 36th
International Conference on Software Engineering, 2014.

[32] A. Sadeghi, H. Bagheri, and S. Malek, “Analysis of android inter-app

security vulnerabilities using covert,” in ICSE’15, 2015.

[33] H. Bagheri, A. Sadeghi, J. Garcia, and S. Malek, “Covert: Compositional
analysis of android inter-app permission leakage,” IEEE Transactions on
Software Engineering, 2015.

[34] W. Ahmad, C. K¨astner, J. Sunshine, and J. Aldrich, “Inter-app commu-
nication in android: Developer challenges,” in Proceedings of the 13th
International Conference on Mining Software Repositories, ser. MSR
’16, 2016.

[36] L. Bello-Jim´enez, A. Mazuera-Rozo, M. Linares-V´asquez,

[35] A. Sadeghi, H. Bagheri, J. Garcia, and S. Malek, “A taxonomy and quali-
tative comparison of program analysis techniques for security assessment
of android software,” IEEE Transactions on Software Engineering, 2016.
and
G. Bavota, “Opia: A tool for on-device testing of vulnerabilities in an-
droid applications,” in 2019 IEEE International Conference on Software
Maintenance and Evolution (ICSME), 2019.

[37] S. Yang, D. Yan, and A. Rountev, “Testing for poor responsiveness
in android applications,” in 2013 1st International Workshop on the
Engineering of Mobile-Enabled Systems (MOBS), 2013.

[38] W. Xiong, S. Chen, Y. Zhang, M. Xia, and Z. Qi, “Reproducible
interference-aware mobile testing,” in 2018 IEEE International Con-
ference on Software Maintenance and Evolution (ICSME), 2018.
[39] W. Zhao, Z. Ding, M. Xia, and Z. Qi, “Systematically testing and
diagnosing responsiveness for android apps,” in 2019 IEEE International
Conference on Software Maintenance and Evolution (ICSME), 2019.

[40] M. Linares-V´asquez, G. Bavota, C. Bernal-C´ardenas, R. Oliveto,
M. Di Penta, and D. Poshyvanyk, “Mining energy-greedy api usage
patterns in android apps: An empirical study,” in Proceedings of the 11th
Working Conference on Mining Software Repositories, ser. MSR 2014.
New York, NY, USA: Association for Computing Machinery, 2014, pp.
2–11. [Online]. Available: https://doi.org/10.1145/2597073.2597085
[41] M. Linares-V´asquez, G. Bavota, C. Bernal-C´ardenas, M. D. Penta,
R. Oliveto, and D. Poshyvanyk, “Multi-objective optimization of
energy consumption of guis in android apps,” ACM Trans. Softw.
Eng. Methodol., vol. 27, no. 3, Sep. 2018.
[Online]. Available:
https://doi.org/10.1145/3241742

[42] D. Li, S. Hao, W. G. J. Halfond, and R. Govindan, “Calculating source
line level energy information for android applications,” ser. ISSTA 2013,
2013.

[43] R. J. Behrouz, A. Sadeghi, J. Garcia, S. Malek, and P. Ammann,
“Ecodroid: An approach for energy-based ranking of android apps,” in
2015 IEEE/ACM 4th International Workshop on Green and Sustainable
Software, 2015.

[44] S. Hao, D. Li, W. G. J. Halfond, and R. Govindan, “Estimating mobile
application energy consumption using program analysis,” in 2013 35th
International Conference on Software Engineering (ICSE), 2013.
[45] W. Nayam, A. Laolee, L. Charoenwatana, and K. Sripanidkulchai, “An
analysis of mobile application network behavior,” in Proceedings of the
12th Asian Internet Engineering Conference, 2016.

[46] M. Conti, Q. Q. Li, A. Maragno, and R. Spolaor, “The dark side(-
channel) of mobile devices: A survey on network trafﬁc analysis,” IEEE
Communications Surveys Tutorials, 2018.

[47] M. Rapoport, P. Suter, E. Wittern, O. Lhotak, and J. Dolby, “Who
you gonna call? analyzing web requests in android applications,” in
2017 IEEE/ACM 14th International Conference on Mining Software
Repositories (MSR), 2017.

[48] Z. Cheng, X. Chen, Y. Zhang, S. Li, and Y. Sang, “Detecting information
theft based on mobile network ﬂows for android users,” in 2017 Inter-
national Conference on Networking, Architecture, and Storage (NAS),
2017.

[49] A. Continella, Y. Fratantonio, M. Lindorfer, A. Puccetti, A. Zand,
C. Kruegel, and G. Vigna, “Obfuscation-Resilient Privacy Leak Detec-
tion for Mobile Apps Through Differential Analysis,” in Proceedings of
the ISOC Network and Distributed System Security Symposium (NDSS),
2017.

real network scenarios,” International Journal on Software Tools for
Technology Transfer, 2019.

[62] Google, “Improve your code with lint checks.” [Online]. Available:

https://developer.android.com/studio/write/lint
issue

index,”

“Lint

[63] ——,

http://googlesamples.github.io/

[50] X. Huang, A. Zhou, P. Jia, L. Liu, and L. Liu, “Fuzzing the android

android-custom-lint-rules/checks/index.md.html.

applications with http/https network data,” IEEE Access, 2019.

[64] Gradle, “The gradle wrapper,” https://docs.gradle.org/current/userguide/

[51] P. Gadient, M. Ghafari, M. Tarnutzer, and O. Nierstrasz, “Web apis
in android through the lens of security,” in 2020 IEEE 27th Interna-
tional Conference on Software Analysis, Evolution and Reengineering
(SANER), 2020.

[52] A. Shabtai, U. Kanonov, Y. Elovici, C. Glezer, and Y. Weiss, ““andro-
maly”: a behavioral malware detection framework for android devices,”
Journal of Intelligent Information Systems, 2011.

[53] J. Crussell, R. Stevens, and H. Chen, “Madfraud: Investigating ad fraud
in android applications,” in Proceedings of the 12th Annual International
Conference on Mobile Systems, Applications, and Services, ser. MobiSys
’14, 2014.

[54] T. Wei, C. Mao, A. B. Jeng, H. Lee, H. Wang, and D. Wu, “Android
malware detection via a latent network behavior analysis,” in 2012
IEEE 11th International Conference on Trust, Security and Privacy in
Computing and Communications, 2012.

[55] K. Moran, M. Linares-Vasquez, C. Bernal-Cardenas, C. Vendome, and
D. Poshyvanyk, “Crashscope: A practical tool for automated testing of
android applications,” in 2017 IEEE/ACM 39th International Conference
on Software Engineering Companion (ICSE-C), 2017.

[56] K. Moran, M. Linares-V´asquez, C. Bernal-C´ardenas, C. Vendome, and
D. Poshyvanyk, “Automatically discovering, reporting and reproducing
android application crashes,” in 2016 IEEE International Conference on
Software Testing, Veriﬁcation and Validation (ICST), 2016.

[57] C. Q. Adamsen, G. Mezzetti, and A. Møller, “Systematic execution of
android test suites in adverse conditions,” in Proceedings of the 2015
International Symposium on Software Testing and Analysis, ser. ISSTA
2015, 2015.

[58] M. T. Azim, I. Neamtiu, and L. M. Marvel, “Towards self-healing
smartphone software via automated patching,” ser. ASE ’14, 2014.
[59] C.-J. M. Liang, N. D. Lane, N. Brouwers, L. Zhang, B. F. Karlsson,
H. Liu, Y. Liu, J. Tang, X. Shan, R. Chandra, and F. Zhao, “Caiipa:
Automated large-scale mobile app testing through contextual fuzzing,”
in Proceedings of the 20th Annual International Conference on Mobile
Computing and Networking, ser. MobiCom ’14, 2014.

[60] Google, “Monkey,” https://developer.android.com/studio/test/monkey.
[61] L. Panizo, A. D´ıaz, and B. Garc´ıa, “Model-based testing of apps in

gradle wrapper.html.
“Android

[65] Google,

android-developers.

developers,”

https://groups.google.com/g/

[66] ——, “Manage network usage.” [Online]. Available: https://developer.

android.com/training/basics/network-ops/managing

[67] Microsoft, “Synchronous i/o antipattern - performance antipatterns
for cloud apps.” [Online]. Available: https://docs.microsoft.com/en-us/
azure/architecture/antipatterns/synchronous-io/

[68] Mozilla, “Synchronous and asynchronous requests - web apis: Mdn.”
[Online]. Available: https://developer.mozilla.org/en-US/docs/Web/API/
XMLHttpRequest/Synchronous and Asynchronous Requests

[69] MITRE, “Common weakness enumeration - error conditions, return
values, status codes.” [Online]. Available: https://cwe.mitre.org/data/
deﬁnitions/389.html

[70] ——, “Common weakness enumeration - empty exception block.”
[Online]. Available: https://cwe.mitre.org/data/deﬁnitions/1069.html
[71] ——, “Common weakness enumeration - empty code block.” [Online].

Available: https://cwe.mitre.org/data/deﬁnitions/1071.html

[72] L. Fan, T. Su, S. Chen, G. Meng, Y. Liu, L. Xu, and G. Pu, “Efﬁciently
manifesting asynchronous programming errors in android apps,” in Pro-
ceedings of the 33rd ACM/IEEE International Conference on Automated
Software Engineering, ser. ASE 2018, 2018.

[73] F.-X. Geiger, I. Malavolta, L. Pascarella, F. Palomba, D. Di Nucci,
and A. Bacchelli, “A graph-based dataset of commit history of real-
world android apps,” in Int. Conference on Mining Software Repositories
(MSR), 2018, pp. 30–33.

[74] R. Coppola, L. Ardito, and M. Torchiano, “Characterizing the transition
to kotlin of android apps: A study on f-droid, play store, and github,”
in Int. Workshop on App Market Analytics (WAMA), 2019, pp. 8–14.

[75] F-Droid, “F-droid: software repository for android,” https://www.f-droid.

org/.

[76] “Android user guide.” [Online]. Available: http://googlesamples.github.

io/android-custom-lint-rules/user-guide.html

[77] “Android lint api guide.” [Online]. Available: http://googlesamples.

github.io/android-custom-lint-rules/api-guide.md.html

[78] B. Rosner, Fundamentals of Biostatistics, 7th ed. Brooks/Cole, Boston,

MA, 2011.

