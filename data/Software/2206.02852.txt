2
2
0
2

n
u
J

1
1

]

R
C
.
s
c
[

2
v
2
5
8
2
0
.
6
0
2
2
:
v
i
X
r
a

CompartOS: CHERI Compartmentalization for Embedded Systems

Hesham Almatary1, Michael Dodson1, Jessica Clarke1, Peter Rugg1, Ivan Gomes1, Michal
Podhradsky2, Peter G. Neumann3, Simon W. Moore1, and Robert N. M. Watson1

1University of Cambridge
2Galois, Inc.
3SRI International

Abstract
Existing high-end embedded systems face frequent secu-
rity attacks. Software compartmentalization is one tech-
nique to limit the attacks’ effects to the compromised
compartment and not the entire system. Unfortunately,
the existing state-of-the-art embedded hardware-software
solutions do not work well to enforce software compart-
mentalization for high-end embedded systems. MPUs are
not ﬁne-grained and suffer from signiﬁcant scalability lim-
itations as they can only protect a small and ﬁxed number
of memory regions. On the other hand, MMUs suffer from
non-determinism and coarse-grained protection.

This paper introduces CompartOS as a lightweight
linkage-based compartmentalization model for high-end,
complex, mainstream embedded systems. CompartOS
builds on CHERI, a capability-based hardware architec-
ture, to meet scalability, availability, compatibility, and
ﬁne-grained security goals.

Microbenchmarks show that CompartOS’ protection-
domain crossing is 95% faster than MPU-based IPC. We
applied the CompartOS model, with low effort, to complex
existing systems, including TCP servers and a safety-
critical automotive demo. CompartOS not only catches
10 out of 13 FreeRTOS-TCP published vulnerabilities that
MPU-based protection (e.g., uVisor) cannot catch but can
also recover from them. Further, our TCP throughput
evaluations show that our CompartOS prototype is 52%
faster than relevant MPU-based compartmentalization
models (e.g., ACES), with a 15% overhead compared to
an unprotected system. This comes at an FPGA’s LUTs
overhead of 10.4% to support CHERI for an unprotected
baseline RISC-V processor, compared to 7.6% to support
MPU, while CHERI only incurs 1.3% of the registers area
overhead compared to 2% for MPU.

1. Introduction and Related Work

The inexorable need to add more features and leverage
connectivity in embedded systems creates potential at-
tack vectors [18, 19, 37, 12, 45, 31, 15, 35] in areas that
were not subject to security concerns before. Individ-
ual’s privacy could now be violated, cars and planes could
crash, credit-card details could be stolen, and medical
devices could critically malfunction, affecting vital life-
concerning actions or leak sensitive patients’ details. The

prevalence of such devices creates large scale risks for
the economy, national security, and the safety of large
populations.

Embedded systems and Internet of Things (IoT) get
more complex and feature-rich every day. While com-
plexity increases, they tend to maintain the real-time re-
quirements and determinism of previous generations. We
are narrowing down the scope of systems we are target-
ing, to the mainstream, large, feature-rich systems that
are unprotected and require some form of security to
defend against unknown and future vulnerability-based
software attacks. That is, we do not try to provide a
security model or solution for small embedded systems
that get created from scratch. To protect such systems
from the inevitable vulnerabilities exploitable in the soft-
ware, all protection models require some hardware sup-
port, such as privilege rings, Memory Protection Unit
(MPU)s, TrustZone [49], or Memory Managment Unit
(MMU)s. However, there is currently a gap in hardware-
software security for targeted embedded applications; the
M-class-like processors [50] with MPU and TrustZone
are too small and inadequate for their needs in terms of
scalability, memory requirements, and ﬁne-grained secu-
rity, while A-class-like processors [48] and MMUs do
not meet the ﬁne-grained security or real-time and deter-
minism requirements. Thus, such systems tend to stay
unprotected or apply complicated workarounds and man-
ual task-based compartmentalization to get some form of
security with non-trivial development, maintenance, and
time-to-market overheads. The scope such systems fall in
is safety-critical avionics and automotive.

Based on the security analysis of embedded systems
in [38, 39, 29], vulnerability-based software attacks (e.g.,
buffer overﬂows) are the most common and they are
what we are concerned about in this paper. Software
compartmentalization [47, 24, 25, 40, 26, 46] is a
technique to split up a large monolithic software into
smaller compartments in order to reduce the attack vector
and limit the effects of a successful software attack
only to the compromised compartment. There have
been multiple recent attempts [43] to provide software
compartmentalization, sandboxing, and isolation in
embedded systems by relying on MPUs as a standard
hardware feature for embedded systems. Due to the

 
 
 
 
 
 
hardware limitations of MPUs (by design) [52], such
solutions are not scalable and do not provide ﬁne-grained
protection, especially for rich and complex mainstream
software stacks with hundreds of thousands of lines
of code (LoC) and many resources. For example, the
state-of-the-art deployed Real Time Operating System
(RTOS)es such as FreeRTOS-MPU [5], TockOS [32],
and Mbed uVisor [11] rely on an MPU-based task or
process model for isolation. This could work ﬁne for
relatively small embedded systems with a small number
of resources, but not for large systems as MPU hardware
scales poorly with tens or hundreds of compartments
and resources that need to be isolated while maintaining
some form of determinism (hence cannot use MMUs
either). Further, for mainstream applications to be
secured using such technologies, they will have to be
ported to use new Application Programming Interface
(API)s or memory-safe languages (e.g., Rust) and
redesigned around tasks or processes. This could be
a deal-breaker for large and mainstream projects that
are written in different languages and not designed
around tasks or processes due to the time-to-market
requirements and development overheads. ACES [17]
tries to provide an automatic compartmentalization
technique that
is source-ﬁle or IO-based for small
embedded systems, using the MPU. This helps with the
compatibility requirement by not requiring to port or
refactor mainstream code. While promising for small and
simple embedded systems, ACES still cannot target large
software projects due to the MPU hardware limitations.
Further, ACES does not try to provide an Operating
System (OS) protection model,
including threading,
secure interrupt handling, or dynamic memory allocation.
TrustLite [30] and TyTan [14] try to mitigate the MPU
design limitations by increasing the number of memory
regions to protect. However, increasing the MPU regions
does not scale in either hardware due to the increased
associative lookups or in software as context switches
will incur O(N) performance overhead where N is the
number of memory regions to protect, per protection
domain.
In almost all of the MPU-based protection
published literature, the limitations of MPU scalability
are admitted, and, therefore, they only try to target small
systems. Further, none of these works attempts to address
availability, an essential requirement of safety-critical
systems. This leaves large, mainstream and complex
embedded systems that require some form of security
while maintaining determinism as a real-time requirement
still vulnerable.

CompartOS aims to ﬁll this security requirement gap
in mainstream, complex, high-end embedded systems,
where manually porting them to use MPU or MMU hard-
ware, OS’ APIs, and/or rewriting them in memory-safe

languages is inadequate or requires signiﬁcant redesign
and reimplementation efforts which would have a high
development, testing, and deployment cost and are error-
prone. More speciﬁcally, CompartOS aims to reduce
the effects of programming errors and vulnerabilities be-
tween software components running on the same embed-
ded processor, in the same address space and privilege
ring and sharing resources by applying a novel software
compartmentalization technique that builds on Capability
Hardware Enhanced RISC Instructions (CHERI). Com-
patibility, availability, and scalability are the main design
goals in this work.

The primary research contribution of this paper is the
CompartOS model (and its evaluation via prototyping) as
a linkage-based, automatic compartmentalization model
for embedded systems. Building on CHERI to provide
software compartmentalization protects against memory-
safety attacks that represent 70% of software vulnera-
bilities in commodity OSes according to Microsoft [16].
However, in embedded systems, it is not enough to catch
a security violation but to appropriately handle it to main-
tain the integrity and availability of security requirements.
In terms of contributions, CompartOS, as a model for
CHERI-enabled, MMU-less, embedded systems, is com-
parable to the well-deﬁned UNIX process model (inspired
by Multics [41, 20]) for general-purpose systems.

CompartOS is novel and differs from state-of-the-art
systems. First, CompartOS signiﬁcantly differs from pre-
vious CHERI work as follows:
• Unlike [47, 22], CompartOS focuses on embedded sys-
tems by enforcing complete protection and compart-
mentalization solely using CHERI (i.e., by replacing
MMUs and MPUs) instead of being complementary
to the MMU-based UNIX process model. Further,
CompartOS leverages system-level compartmentaliza-
tion, rather than just application-level compartmental-
ization, on all OS aspects, including kernels, device
drivers, OS libraries, and applications.

• Unlike CheriOS [23] and CheriRTOS [51] (where both
are task-based), CompartOS does not introduce a new
OS or API to manually compartmentalize complex soft-
ware, but it automatically enforces compartmentaliza-
tion based on the linkage model and programming lan-
guages.

• Focuses on availability and recovery in safety-critically
embedded systems after catching CHERI faults (or oth-
ers), rather than accepting fail-stop on, for example, a
memory protection fault.
Second, unlike MPU-based state-of-the-art secure
embedded architectures [11, 27, 17, 32, 30, 14, 43],
CompartOS:
• Scales to hundreds of compartments and resources with-

out hardware protection limitations.

• Targets existing mainstream and complex unprotected

2

embedded (operating) systems and libraries that could
scale to millions of lines of code.

• Provides capability-based security that is enforced on
every pointer and linkage module, inter- and intra-
task/application.

• Assumes malicious compartments and aims to protect
against current and unknown future software vulnera-
bilities.

• Outperforms comparable state-of-the-art systems.

In summary, we describe the major contributions in

this paper as follows:
CompartOS abstract model A generic CHERI-based
compartmentalization and protection model for embedded
(operating) systems, which can be effortlessly applied to
most mainstream embedded systems and RTOSes.
CheriFreeRTOS implementation of CompartOS A
real-world, sound prototype of the CompartOS model in
FreeRTOS including a secure loader and protecting the
kernel, OS/IoT libraries, and large and complex deployed
mainstream applications.
MPU-based comparisons Implementations of the state-
of-the-art MPU-based protection models in FreeRTOS to
fairly evaluate the CheriFreeRTOS prototype against, at
scale.
Evaluation Demonstrating complete and functional real-
world, deployed use cases with CompartOS and other
MPU-based models and providing security, compatibility,
availability, and performance analysis.

2. Background

This section provides the background necessary to contex-
tualize subsequent use of CHERI, and the run-time linker
(libdl) in CompartOS.

2.1. CHERI

CHERI is an architecture-neutral, state-of-art hardware
capability system that provides the architectural features
necessary to support efﬁcient and ﬁne-grained mem-
ory protection and software-deﬁned compartmentaliza-
tion [47]. CHERI-aware Instruction Set Architecture
(ISA) extensions and deployments exist for MIPS, RISC-
V, and Armv8 (Morello) [34] hardware and software
stacks. CHERI is designed to enforce the principles of
least privilege [42] and intentional use. The former is
enforced by explicitly granting to a software component
only the privileges required to perform its intended ser-
vice. The latter is enforced by requiring that memory
operations, capability manipulations, and privileged op-
erations explicitly provide and name capabilities hold-
ing restricted permissions to perform a service. This
avoids the ambient authority that can produce a confused
deputy [13]. There are two CHERI protection models
actively being researched: pointer safety and software
compartmentalization.

Pointer safety in C/C++ languages has been the primary
application of CHERI to date. It leverages the compiler
toolchain to map C/C++ pointers to CHERI’s capabili-
ties. Every pointer is represented as a CHERI capability
with base, bounds, and permissions, and CHERI-aware
instructions enforce complete spatial pointer safety. Point-
ers include conventional data pointers, arrays, function
pointers, stack and heap allocations, and return addresses.
Violations trap to the executive, which determines how to
handle the memory fault.

Software compartmentalization is a newer application
of CHERI. The purpose of compartmentalization is to di-
vide a monolithic system into smaller components, where
each component is granted only the explicit privileges
necessary to perform its service. Compartmentalization
reduces the system’s attack surface, limits the effect of a
successful exploit to the affected compartment, protects
against currently-unknown vulnerabilities in a software
component, and provides opportunities to improve fault
handling due to the well-deﬁned boundaries between com-
partments. The main contribution of this paper is a novel
CHERI-based compartmentalization model for embedded
systems.

2.2. LIBDL

libdl [1] is a component initially developed by the
RTEMS project [9] to dynamically load and link ELF
modules against a single-address-space, MMU-less,
statically-linked ELF image. After the loading/linking
process is completed, the resulting performance is the
same as if the ELF image was generated at build-time
with static linkers. libdl is useful in patching, ﬁxing
bugs, updating libraries, and adding more features (e.g.,
applications, drivers, and libraries) without having to reset
the entire system, affecting its availability, as in conven-
tional software updates.

3. Threat Model

Compartments are untrusted and could attempt to violate
(deliberately or unintentionally) language-based memory-
safety guarantees enforced by CHERI, OS-level isolation
mechanisms, or externally deﬁned inter-compartment se-
curity policies. Like other isolation technologies, we
assume the attacker seeks to compromise the system’s
conﬁdentiality and integrity. Unlike other technologies,
we also assume the attacker seeks to disrupt system avail-
ability, and we explicitly design and evaluate against this
target. We assume a CHERI-aware attacker that is either
resident on the device (e.g., controlling a library) or in
direct communication with a vulnerable software comop-
nent on the device (e.g., the TCP/IP library) but has not
compromised the TCB.

3

4. Design Principles and Requirements

This section discusses the requirements and goals that
CompartOS is designed to meet and how they are useful,
and how they compare to other state-of-the-art embed-
ded security architectures. It also brieﬂy describes how
CompartOS meets those requirements, but the thorough
evaluations are further discussed in subsequent sections.

Capability-Based Security: Due to their OS design
and limited hardware, embedded systems generally lack
an access control model such as Access Control List
(ACL) and ﬁlesystems in UNIX-based OSes. This means
that nothing stops an attacker on an embedded system
from accessing the entire memory space and all system
resources. Capability-based access control provides a
scalable, lightweight mechanism that can be implemented
with little perturbation to existing software. CompartOS
aims to leverage capability-based security [36, 33, 44]
everywhere: not only protecting kernel objects (as in
capability-based microkernels [28]) but also providing
hardware memory protection and programming-language
pointer safety. That is, CompartOS extends security en-
forcement into the compartment itself, rather than just
providing isolation guarantees between compartments.

Scalable Automatic Compartmentalization: Com-
posing multiple components, libraries, or applications
is increasingly common in embedded systems, with third-
party libraries and standards becoming more feature-rich
every day. Therefore, increasing the number of resources
and features (represented as compartments) should be
scalable, without signiﬁcantly affecting performance and
security guarantees or requiring major engineering and
maintenance overhead.

Source-Code Compatibility: Mainstream, large, com-
plex, and unprotected embedded system software could
be written in millions of lines of code. Providing security
for such systems at a minimum development and main-
tenance overhead is one of the main requirements. That
is, applications should require few, if any, source-code
changes. We deliberately chose to avoid designing a com-
pletely new research OS or rewriting existing non-secure
systems in memory-safe languages such as Rust, all of
which complicate learning, development, runtime, and
maintenance overheads, and can be a deal-breaker for
large complex mainstream systems in the industry.

Improved Availability: Many attacks target the avail-
ability of embedded systems rather than conﬁdentiality
and integrity. General-purpose OSes (e.g., UNIX) have
a lower focus on availability and it is often a secondary
design goal. In contrast, breaking availability in safety-
critical embedded systems could sometimes cost lives,
e.g., if they manage medical databases, information on air
trafﬁc, and so on.

Figure 1: CompartOS build-time workﬂow. Developers
feed the (mainstream) source-code to the build system
as well as an optional security policy that splits up the
source-code into logical compartments with well-deﬁned
APIs (e.g., libraries), along with the restricted communica-
tions between them. The output is linkage modules that
are fed to the dynamic secure loader at runtime.

Figure 2: CompartOS runtime model. Green boxes
are trusted. Everything else is untrusted, including the
toolchain. Linkage module compartments are in red, and
OS tasks (or threads) are in yellow. Dotted lines indicate
isolation boundaries with potential bridges for communi-
cation between compartments as speciﬁed by the secu-
rity policy. The secure loader notch indicates some form
of integration with the OS (e.g., threading).

Real-time and Embedded-Systems Requirements:
Most mainstream RTOSes still need some form of de-
terminism as a real-time requirement, and that is why
they avoid using an MMU to enforce security and pro-
tection. CompartOS does not introduce non-determinism
or add to the complexity of the to-be-compartmentalized
real-time embedded system itself.

5. Compartmentalization Model

This section describes CompartOS as a generic compart-
mentalization model and its design choices. The model is

4

ToolchainSourceCodeOptionalPolicyLinkage-Modules(Compartments)BuildSystemSecure Dynamic LoaderCHERI ProcessorTask T4Task T1Task T2OS CompC1 OS CompC2 OS CompC3OS CompC4App CompC8App Comp C5App Comp C6App CompC9OSKernel CompC0App Comp C7Task T3Single-address-space, Single-ringnot speciﬁc to a particular implementation but can be ap-
plied to mainstream embedded (operating) systems, boot
loaders, and programming languages. An overview of a
CompartOS model system is shown in Figures 1 and 2.
Both ﬁgures are further described in the design choices
discussed next.

CompartOS is a programming language- and
linkage-based compartmentalization model.

CompartOS relies on the underlying linkage model
and format (e.g., ELF, Mach-O, or PE) to deﬁne what
a compartment is at compile time. The security policy
between compartments is speciﬁed at development and
compile time and enforced at runtime load and link time.
Linkage-based compartmentalization has several beneﬁts
over other compartmentalization models:
• Intuitive: Compartments are directly mapped to source-

code ﬁles, objects, and libraries.

• Compatible: No need to reimplement or redesign exist-

ing software projects.

• OS-independent: No reliance on speciﬁc threading
or process models, virtual memory support, or OS-
enforced access control policies (e.g., ﬁlesystem-based
ACL)

A compartment is a linkage-based module.

In CompartOS, the basis of a compartment is deﬁned
to be anything that could go into one or more source-code
ﬁles that will be compiled into a relocatable object mod-
ule or a library. This could optionally contain code (func-
tions), data (variables), and other sections. Compartmen-
talization is thus speciﬁed at compile-time and enforced
at the runtime linkage stage. That is, CompartOS relies
on the linkage model and modules to deﬁne the basis of
compartments statically at development and compile time.
Therefore, a compartment can encapsulate applications,
libraries, device drivers, secret keys, software updates,
etc., independent of the task or process model. Such
beneﬁts make it easy to compartmentalize projects like
static baremetal single-threaded ones, to rich Embedded
Operating System (EOS)es with multi-threading support,
dynamic memory, and ﬁlesystems.

An inter-compartment security policy is deﬁned
by the language/linkage model.

Since compartments are directly mapped to source-
code ﬁles, it is natural to make use of the programming
language and linkage model to specify:
• API: to deﬁne the visibility of each symbol to other

compartments.

• Communication: to deﬁne the relationship with other

compartments.
The speciﬁcation is later on enforced using CompartOS

and a CHERI-aware secure loader.

A compartment owns static linkage-based and
dynamic resources.

Besides statically deﬁned linkage-based resources, a
compartment can also own dynamic resources it allocates
at runtime. Furthermore, compartments can own privi-
leges to access IO memory regions and certain privileged
instructions, deﬁned and granted as CHERI capabilities
with associated restricted permissions.

Capability-based access control.

In CompartOS, any access to resources has to be per-
formed via a capability. Each compartment has a capa-
bility table that contains CHERI capabilities to access
linkage-based and dynamic resources. The access control
is speciﬁed at both language-based and OS/linkage-based
compartmentalization levels. A secure CHERI-aware
compartment loader enforces both memory-safety within
a compartment (like in memory-safe languages) and spa-
tial compartmentalization guarantees between compart-
ments like in capability-based microkernels.

CompartOS provides a mechanism for compart-
mentalized fault isolation and recovery, not for
catching speciﬁc security violation faults.

While CompartOS is beneﬁting from CHERI’s memory
safety for catching security violations, CHERI’s security
guarantees are not part of the model as a new contribution.
That is, CompartOS does not require or enforce a partic-
ular mechanism or policy for catching speciﬁc security
violations (e.g., buffer overﬂows, use-after-free, ﬁlesys-
tem access control, etc.). It is up to the embedded systems
designer to deploy and implement mechanisms for catch-
ing security-related violations and triggering architectural
faults for them.

A compartment does not trap to perform a protec-
tion domain switch.

Unlike MMU and MPU based compartmentalization
techniques, CompartOS does not have the notions of sys-
tem calls or user, kernel, secure, unsecure, privileged or
unprivileged. Compartment switches are normal function
calls in the same privilege ring and do not incur further
microarchitectural overheads due to traps or hardware
reconﬁguration.

5

No software monitors, hypervisors, or back-
ground checks.

preserve the ability to selectively patch and update spe-
ciﬁc components if needed without affecting the remain-
ing system.

Unlike hypervisors, microkernels, and secure EOSes,
CompartOS only requires a secure loader to enforce the
compartmentalization policy at load or boot time. Once
compartmentalized, no further background checks or mon-
itoring happen in software. The integrity and conﬁdential-
ity of the system are maintained by virtue of capability-
based access control and CHERI hardware.

CompartOS’ linkage-based compartmentalization
can also support task-based compartmentaliza-
tion.

The CompartOS model could be used to support differ-

ent types of compartmentalisation models:
• Task-based: Single task per compartment.
• Library-based: Multiple compartments per task.
• Multitask-based: Multiple tasks per compartment.

All compartments execute in a single-address-
space, MMU-less, single-privilege-ring environ-
ment.

Except for CHERI, there is no reliance on speciﬁc hard-
ware (e.g., MMU, MPU, privilege rings) or OS (virtual-
ization, paging, address spaces, ﬁlesystem access control)
features for protection or privilege separation. CHERI en-
ables enforcing software compartmentalization in a single
ﬂat physical address space. Coarse-grained user and ker-
nel separations are not required as CHERI could isolate
privileges for memory and system registers; thus, a single
processor ring or privilege mode is sufﬁcient. This makes
it possible for OSes, libraries, device drivers, and appli-
cations to be all in the same privilege ring as different
compartments.

Dynamic runtime compartmentalization with ac-
tively malicious compartments.

While formal veriﬁcation, type-safe programming lan-
guages, certiﬁcation, and static analysis tools provide
guarantees reasoning about the security of a software sys-
tem, adding new features, libraries, or refactoring some
existing code requires considerable effort to maintain such
guarantees. Furthermore, static guarantees are obtained
against certain types of known models, vulnerabilities,
and exploits. Our approach, on the other hand, allows
for dynamic security, including creation, isolation and
deletion of compartments during (boot, load, and unload)
runtime. This helps protect against unknown future vul-
nerabilities and exploits. Moreover, once deployed, we

6. Implementation

In this section, we discuss how we implement the
CompartOS model spanning three different software com-
ponents: a toolchain, a dynamic loader, and an embed-
ded operating system. These parts collaborate to carry a
compartmentalization policy from compilation and code
generation through to runtime using static and dynamic
linkage of a set of modules. We have extended the existing
CHERI-LLVM toolchain, libdl dynamic loader, and the
FreeRTOS EOS to implement the CompartOS model. For
simplicity, we refer to the implementations of those three
software subsystems collectively as CheriFreeRTOS.

7. CHERI-LLVM: GPREL Addressing ABI

Current embedded operating systems, even the existing
CHERI-based ones, compile and build statically and get
linked into a single binary image that executes in a single
address space and single privilege ring. This means that
all code can call any other code, and access any other data.
Global variables and functions can thus be referenced
from anywhere. Accesses happen in a Program Counter
Relative (PCREL) manner, and in the case of CHERI,
only one capability table is shared for the entire image.

Having a single globally shared captable that is PCREL-
accessed sufﬁces for UNIX-based systems with well-
deﬁned process models and MMUs (such as in Cheri-
ABI [21]), but is inadequate to support compartmentaliza-
tion in embedded systems with a single physical memory
space. For example, if this PCREL addressing was em-
ployed in EOSes with CompartOS, it would create a sin-
gle captable granting all compartments (e.g., applications,
drivers, kernels, libraries) unrestricted shared access to all
globals. CompartOS, therefore, requires runtime support
for a single-address-space image with multiple indepen-
dent captables and bounded functions (e.g., that cannot
address anything relative to their address, except their
code) as shown later in Figure 3.

We overcame this challenge by adding new support
for per-compartment captables; however, this required
changes to the ABI. Speciﬁcally, we used another archi-
tectural capability register, the Capability Global Pointer
(CGP) and changed the compiler ABI for compartments
to generate GP-relative (GPREL) instead of PCREL ac-
cesses. Each compartment’s CGP holds its root captable.

8. libdl: Secure Dynamic Linker and Loader

The original libdl (a dynamic linker and loader library)
provides no protection between linkage modules such
as objects, libraries and the base ELF image (e.g., the

6

allocates the memory necessary for loading and linking,
it also allocates capability table with an initial size of
the deﬁned symbols count within that module. External
function symbols are treated as inter-compartment do-
main switches. Those are detected by libdl during a
compartment creation. For every external function call
within a compartment, an additional lightweight function
trampoline is emitted (discussed later). Capabilities can
be minted (by libdl) from other capabilities through mono-
tonic action. Minting means deriving a new capability out
of an original one, with the same or less permissions. If an
inter-compartment call is allowed (by some user-deﬁned
policy), libdl mints a capability from the callee’s capt-
able and installs it in the caller’s captable dynamically.
The captable will come to hold capabilities for four dif-
ferent classes of linkage-based symbol capabilities: local,
global, interface, and external. Interface capabilities form
a compartment’s API that other compartments can have
minted external capabilities to.

On boot time, libdl automatically loads and links all
the compartments that the embedded system designer des-
ignates in a conﬁguration ﬁle. The conﬁguration ﬁle is
considered part of the security policy. CheriFreeRTOS
aligns with C and ELF linkage-based symbols attributes.
For example, it creates read-only capabilities for code
and constants. Similarly, stack capabilities and malloced
memory (from compartments) do not have execute per-
missions.

8.2. Compartment Switch

A compartment switch triggers a protection domain
switch between distrusting compartments, as shown in
Figure 3. libdl detects inter-compartment calls at load
time and emits a read-only, Sentry trampoline that per-
forms a compartment domain switch accordingly. Sen-
try (sealed entry) functions are CHERI capabilities that
can only be jumped to but not read from or written to.
Additionally, libdl wraps function pointers with a tram-
poline since those can be leaked between compartments.
The trampoline consists of metadata and code to deﬁne
which compartment a function belongs to, the destination
compartment captable, and a bounded capability to the
function itself (see Listing 1). libdl sets up the metadata
(function capability, destination captable, and compart-
ment identiﬁer) during compartment loading. The only
privilege a trampoline has is the metadata.

9. FreeRTOS: an Embedded OS

In this section, we describe the subsystems where the dy-
namic linker and an embedded OS may need to cooperate.
The required change in an EOS to support linkage-based
software compartmentalization is its threading support.
Optionally, if the EOS supports dynamic memory alloca-
tion, some changes might also be required there. We have

Figure 3: A runtime example of a compartmentalized sys-
tem performing domain switching. The switch starts with
a function call that references a capability from the exter-
nals capability list (#1) which points to a small, read-only
trampoline (#2) that performs compartment switches by
setting the new captable (#3) and compartment ID (#4) af-
ter storing the caller’s context. It then jumps via the inter-
face capability (#5) provided by the target compartment.
This interface capability points to the function within its
associated compartment (#6). Upon its return (#7), the
trampoline restores the caller’s context, captable, and ID,
then returns back to the caller function (#8).

OS kernel), and in fact, has no mechanism it could even
use to do so. That is, once new objects or libraries are
loaded, the resulting system is indistinguishable from a
baseline system statically linked at build-time. In run-
time, object modules can call global external functions
in other modules. This is considered the baseline for a
dynamically loaded system by libdl. Even if we build
libdl and its loaded modules in CHERI C, there will only
provide spatial pointer memory-safety, but not isolation
and compartmentalization between loaded linkage mod-
ules, which can still access a globally shared captable
between modules. We have extended libdl to support
CHERI and CompartOS linkage-based software compart-
mentalization. libdl acts as a secure boot loader or a
trusted ﬁrmware. That is, it is the most privileged piece of
software that ﬁrst takes control of the hardware on reset,
holds access to the CHERI root capabilities (i.e., initial ca-
pabilities that hold all privileges such as PCC and DDC),
and then loads and grants compartments the minimum
restricted capabilities they need to perform their job.

8.1. Compartment Creation

A compartment is dynamically created by calling dlopen()
with the path to the module in the ﬁle system. After libdl

7

.text.data.rodatacaptable(gp)IDlocal capsglobal capsinterface capsexternal capsSW-object caps.text.data.rodatacaptable(gp)IDlocal capsglobal capsinterface capsexternal capsSW-object capsTrampoline    SwitchCompartment ACompartment B12345678In-memory read-only capabilities arrayFault HandlerFault HandlerRun-time linkage-module CompartmentThese per-compartment software fault handlers improve
fault tolerance and maximize availability.

ID

10. Evaluation

. z e r o CAP_SIZE % C a l l e e ’ s
. z e r o CAP_SIZE % C a l l e e ’ s
. z e r o CAP_SIZE % C a l l e e ’ s c o m p a r t m e n t

f u n c t i o n c a p a b i l i t y
c a p a b i l i t y t a b l e

x P o r t C o m p a r t m e n t E n t e r T r a m p o l i n e :
% M e t a d a t a
. L f u n c :
. L c a p t a b l e :
. Lcompid :
/ / Compartment / Domain S w i t c h
Save c a l l e r ’ s c o n t e x t
S e t u p new GP / c a p t a b l e
S e t c u r r e n t C o m p a r t m e n t I D = Lcompid
( O p t i o n a l ) R e s t r i c t / bound t h e
C a l l
t h e d e s t i n a t i o n f u n c t i o n
R e s t o r e
R e t u r n t o t h e

c a l l e r ’ s c o n t e x t

c o m p a r t m e n t

( r e g i s t e r

( r e g i s t e r

c a l l e r

s e t , GP , compid )

c a l l e e ’ s

s t a c k

s e t , GP , compid )

Listing 1: Compartment trampoline pseudo code

chosen FreeRTOS as an EOS, which is widely deployed
and is representative.

9.1. Compartments and Threading

In CheriFreeRTOS, a thread can enter exactly one com-
partment at a time, and compartment entrances can be
nested in a function-call manner. A compartment is also
re-entrant from different threads, assuming the function
is re-entrant and thread-safe. When a thread enters a
compartment, it donates its remaining stack to the com-
partment. The bookkeeping is handled by the FreeRTOS
TCB_t structure, which is extended to contain a com-
partment context, including the current compartment ID
(xCompID), the caller’s return address, and the caller’s
return stack.

9.2. Software Fault Handling

We have modiﬁed FreeRTOS to support handling archi-
tectural exceptions for the RISC-V port. The baseline
port does not handle or support any form of exception
handling and instead hangs or performs a reset instead.
9.2.1. Fault Handler Registration There could be dif-
ferent types of fault handlers in the CompartOS model,
discussed in Section 10.5.1. Those can involve either libdl,
FreeRTOS or both of them. In CheriFreeRTOS, a custom
fault handler can be registered per compartment by deﬁn-
ing and implementing a CheriFreeRTOS_FaultHandler
function for each compartment at development and build
time. During the loading process, libdl searches for any
occurrence of CheriFreeRTOS_FaultHandler as a func-
tion symbol and registers it as a callback function for the
loaded compartment. Otherwise, if libdl could not ﬁnd
CheriFreeRTOS_FaultHandler, it applies default fault
handling techniques.
9.2.2. Runtime Fault Handling If an exception occurs,
the modiﬁed FreeRTOS architectural exception handler
checks if the current task is running in a compartment (by
checking the associated per-task compartment structure),
and if so, it jumps to a registered custom per-compartment
software fault handler (if provided). In the case of Return-
Error and Compartment-Kill (see Section 10.5.1), the
exception handler returns back to the trampoline that per-
formed the compartment switch, which returns to the
caller compartment with an optional return error code.

8

We evaluate CompartOS through our CheriFreeRTOS
prototypes with regards to performance, compatibility,
availability, security, and practicality, demonstrating fully-
functional real-world use cases. We ported and developed
MPU and CHERI-aware CheriFreeRTOS to run on dif-
ferent variants of RISC-V processors on the VCU-118
Xilinx Field Programmable Gate Arrays (FPGA) board.
The (CHERI-)RISC-V processor’s HDL and CheriFreeR-
TOS software stacks are open-source. This section starts
with measuring the hardware costs in terms of FPGA
LUTs for unprotected, MPU/Physical Memory Protection
(PMP) (the RISC-V analogous version of Arm’s MPUs),
MMU, and CHERI processors. Next, we evaluate differ-
ent security models implemented by our software variants
in CheriFreeRTOS, including MPU, CHERI/PURECAP,
and CompartOS through a set of micro- and macro- bench-
marks.

We require the hardware to provide at least a few
megabytes of RAM memory to support a ﬁlesystem,
compartmentalization, and dynamic loading and linking.
Thus, we exclude memory resource restrictions, as we
target high-end embedded system applications.

10.1. Hardware Measurements

We use an FPGA softcore called Flute by Bluespec which
is a RISC-V processor and is comparable to Armv7 low-
end cores (e.g., A9) that are commonly used in high-end
embedded systems. We synthesize Flute to run at 100
MHz with 5 pipeline stages, 32-bit mode, without a Float-
ing Point Unit (FPU). Flute’s privilege modes are similar
to Arm’s. For example, Machine-mode (EL3) is used
for ﬁrmware, embedded systems or RTOSes, Supervisor-
mode (EL1) runs conventional OSes that support pag-
ing and virtualization. Flute is also extended to support
CHERI-RISC-V [4]. We have built four different proces-
sors of Flute for evaluation, as shown in Table 1. The
hardware consumption numbers are shown in Table 2.
We provide these numbers just for completeness with
a notice that we mostly rule out the area and power re-
quirements as we target high-end embedded processors.
Further, the power row in the table represents the ap-
proximate static power consumption, but that might not
be a good indication of the runtime power consumption
as that depends on the software workload and IO oper-
ations (e.g., DRAM and peripherals access). We ﬁnd
that the PMP variant with 16 regions adds 7.6% LUTs
overhead compared to NOPROT, while the MMU_PMP
one takes slightly more. CHERI takes the most LUTs
overhead of 10.4% as it implements a rich capability-
based ISA. On the other hand, CHERI takes the least

NOPROT PMP

MMU_PMP

CHERI

RISC-V Privilege Modes M
Protection
PMP regions
TLB

N/A
N/A
N/A

M, U
PMP (MPU)
16
N/A

M
M, S, U
CHERI
PMP, MMU
16
N/A
16 entry direct-mapped NA

Table 1: Hardware conﬁgurations of different Bluespec
processors we build for evaluation.

NOPROT PMP

MMU_PMP

CHERI

LUTs
Registers
Power (W)

92222
119012
0.212

99810 (7.6%)
121498 (2.0%)
0.213 (.47%)

101132 (8.8%)
122096 (2.5%)
0.221 (4.1%)

102955 (10.4%)
120600 (1.3%)
0.245 (13.5%)

Table 2: Power and area results for different variants of
Flute. Overhead percentage is calculated against NO-
PROT.

Registers area overhead of 1.3% compared to 2% and
2.5% overheads for PMP and MMU_PMP, respectively,
as CHERI does only run in Machine-mode and thus re-
quires no further Supervisor/User privilege mode regis-
ters, Translation Lookaside Buffer (TLB)s, or PMPs. We
think that such overheads are low for the security beneﬁts
that CHERI and CompartOS bring.

10.2. Software Variants

We have evaluated multiple FreeRTOS-based benchmarks
and case studies on the previously discussed hardware
variants and the following software setups that we devel-
oped:
• INSECURE-STATIC: Statically-linked, unmodiﬁed
(and unprotected) baseline RISC-V software built with-
out CHERI, PMP, or MMU support.
• INSECURE-DYNAMIC: Same as

INSECURE-
STATIC, but supports dynamically loading and linking
RISC-V modules using libdl. This is running on the
NOPROT hardware processor.

• PMP-4-TASKS: Statically-linked RISC-V software
providing coarse-grained task-based and MPU-based
compartmentalization (4 regions). This is running
on the PMP hardware variant. This is similar to
FreeRTOS-MPU, TockOS, and RTEMS’ MPU-based
security models.

• PMP-N-OBJS: Automatic linkage-based compartmen-
talization where every object module (source ﬁle) is
a compartment protecting N number of resources and
protection is enforced using PMP/MPU, and is dynam-
ically loaded and linked. This is running on the the
PMP hardware processor. This is similar to ACES,
TyTan/TrustLite, and uVisor’s security models.

• PMP-N-LIBS: Like PMP-N-OBJ, but compartments

are library modules rather than object modules.

• PURECAP: Statically-linked pure-capability CHERI-
RISC-V software providing complete (spatial) pointer
safety, but no compartmentalization, running on the the
CHERI hardware processor. This is similar to task-

Figure 4: The cost,
switching, sending one byte from one task to another.

in cycles, of task-based domain

based CheriRTOS model.

• COMPARTOS-OBJS: Our new automatic linkage-
based compartmentalization where every source ﬁle
(object module) is a compartment, protection is en-
forced using CHERI, and is dynamically loaded and
linked. This is running on the CHERI hardware pro-
cessor.

• COMPARTOS-LIBS: Like COMPARTOS-OBJ,
but compartments are library modules rather than object
modules.

10.3. Microbenchmarks

We have developed a custom microbenchmark from
scratch to measure the performance of the lowest level,
most critical and frequently executed code paths in em-
bedded OSes in the different software variants that we
discussed. There are two main communicating com-
partments: a sender and a receiver. Communication
is done over function calls, compartment calls/switches,
and Inter Process Communication (IPC) message-passing.
In the object-based compartmentalized variants (e.g.,
COMPARTOS-OBJS and PMP-N-OBJS), each compart-
ment is an object ﬁle. The sender compartment has 18
resources to protect, and the receiver compartment has 41.
Those are memory regions representing pointers, global
variables, UART regions, and functions.
10.3.1. Task-based IPC Evaluation In secure EOSes
(like in seL4, FreeRTOS-MPU, and TockOS), secure do-
main switches are often task-based using IPC and mes-
sage passing. In Figure 4, we show the performance over-
head of performing task-based domain switches, sending 1
byte over a FreeRTOS queue. Some instructions are multi-
cycle and/or require pipeline ﬂushes; those are placed in
the Other segment. Other instructions take one cycle,
and they are accounted for in the Instructions segment.
The remaining segments are cache misses and branch
misprediction latencies. The PMP variants take the most
instructions represented in Instructions and Other seg-
ments as they have to perform system calls, reconﬁgure
PMP registers (see Figure 5) that require loading permis-
sions from memory and writing the PMP system registers.

9

010002000300040005000CyclesINSECURESTATICINSECUREDYNAMICPMP4TASKSPMP16OBJSPMPNOBJSPMPNLIBSPURECAPCOMPARTOSLIBSCOMPARTOSOBJSBaselineMPU/PMPCHERIInstructionsICachereﬁllsDCachereﬁllsBranchmispredictionOtherFigure 5: Comparison between different protection do-
main switch mechanisms cost in instructions count.

Figure 7: Small packet round-trip latency with ping (lower
is better).

Finally, we compare CompartOS’ linkage-based com-
partmentalization against off-the-shelf deployed OSes that
rely on task-based, MPU-based compartmentalization.
CompartOS offers intra-thread domain switches thanks
to its linkage-based (rather than task-based) design. We
conclude that CompartOS’ linkage-based domain switch
is 95% faster than the off-the-shelf message-passing IPC
in task-based, MPU-based models implemented by state-
of-the-art deployed systems (e.g., FreeRTOS-MPU and
TockOS).

Figure 6: Comparison between different protection do-
main switch mechanisms cost in cycles count.

10.4. TCP/IP Benchmarks

CompartOS variants do incur negligible overhead in data
cache misses, likely because of the partitioned capability
table per compartment, unlike PURECAP.
10.3.2. Performance Evaluation of Domain Switching
We compare CompartOS’ linkage-based domain switch
against state-of-the-art PMP/MPU task-based domain
switch in Figures 5 and 6.

Unlike task-based, linkage-based compartmentaliza-
tion performs compartments switches during function
calls. Looking at Figure 5, we notice that the Task-based-
PMP instructions are consumed in performing system
calls, IPC/kernel path, and PMP conﬁgurations. On the
other hand, CompartOS’ task-based compartmentaliza-
tion does not require any system calls or PMP reloads, and
compartment switches happen implicitly during task con-
text switches when the CGP register is swapped. Based
on Figure 6, we conclude that CompartOS’ task-based
domain crossing is 26.6% faster than MPU-based, task-
based, IPC mode, implemented by state-of-the-art de-
ployed systems (like in FreeRTOS-MPU and TockOS).

Similarly, we compare CompartOS linkage-based do-
main switch against the state-of-the-art MPU-based
linkage-based systems (e.g., ACES, uVisor, TrustLite/Ty-
Tan). The PMP reconﬁgurations and system calls domi-
nate the cost of Linkage-based-PMP; both are not required
in CompartOS. We conclude that CompartOS’ linkage-
based domain switch is 85% faster than the most similar
MPU-based compartmentalization state-of-the-art sys-
tems.

We perform TCP/IP evaluation to understand how a real-
world mainstream system would perform across the dif-
ferent protection models implemented by our FreeRTOS
software variants. The evaluation includes response time,
throughput, and security. As most feature-rich IoT sys-
tems do have a TCP/IP stack for communication and
connectivity, this TCP/IP use case is the most critical,
complex, and realistic application we are discussing so
far. It is important to note that we evaluate mainstream
TCP/IP centric applications that are deployed by Free-
RTOS and are published publicly [7], including multiple
internet servers and protocol stacks built as library com-
partments. Those are over 9 library compartments (in
COMPARTOS-LIBS) and over than 50 compartments
(in COMPARTOS-OBJS and PMP-N-OBJS), each with
hundreds of resources, and over than 10 compartment
switches in the FTP use case, discussed later. Hence,
scalablity is evaluated as well. Further, the compartments
are mutually separate, often distrusting, and sometimes
come from different vendors with different criticalities
and real-world published vulnerabilities. We have not de-
veloped any of the code-based (which is about 100 KLoC)
ourselves, and, thus, we also evaluate the compatibility
and applicability advantage of CompartOS. The FPGA
board running the benchmarks communicates with a host
computer and are connected over a 1 Gigabit Ethernet
(cross-over).
10.4.1. Response Time We perform response time eval-
uation by sending a total number of 100 ping packets

10

0200400600800100012001400InstructionscountLinkage-based-CompartOSLinkage-based-PMPTask-based-CompartOSTask-based-PMPProtectiondomainswitchmechanismCaller’ssaveSystemcallKernel(Scheduler/Queues)PMP/MPUCompartment-relatedFunctioncall010002000300040005000CyclesLinkage-based-CompartOSLinkage-based-PMPTask-based-CompartOSTask-based-PMPProtectiondomainswitchmechanismINSECURESTATICINSECUREDYNAMICPMP4TASKSPMPNOBJSPMPNLIBSPURECAPCOMPARTOSLIBSCOMPARTOSOBJS0.00.20.40.60.81.01.21.41.6RoundTripTime(RTT)inmillisecondsBaselineMPU/PMPCHERI0.800.850.831.191.020.470.480.53and getting the average and standard deviation numbers
reported by the ping command on a Linux PC. The com-
mand calculates the standard deviation of the Round Trip
Time (RTT), which is shown in Figure 7. Ping sends a sin-
gle ICMP packet from the client to the server and receives
back an acknowledgment packet. This makes the code
path short and fast and thus maximizes the overheads.
Further, the ICMP packet processing only incurs one do-
main switch in the case of library compartmentalization
from the FreeRTOS ISR to the TCP/IP stack. The PMP-
4-TASKS is also effectively doing nothing when it comes
to protection; FreeRTOS-MPU does not try to rework the
TCP/IP stack (being relatively complex and large) to use
task-based MPU compartmentalization as that is likely
inadequate due to the MPU limitations mentioned so far.
PURECAP is 62.66% faster INSECURE-STATIC
baseline, because CHERI doubles the register sizes, which
halves the number of instructions spent in memcpy that
is frequently used in the TCP/IP code paths. We can-
not use a non-CHERI-aware memcpy in this case, as
events and the IPC buffers include pointers. However,
in Section 10.4.2, we amortize this advantage. Compar-
ing he COMPARTOS-LIBS against PURECAP gets us
the compartmentalization and protection domain switches
overhead. This is a negligible 3.6% for such a small op-
eration. Similarly, if we compare PMP-N-LIBS against
INSECURE-STATIC, we ﬁnd that PMP-based compart-
mentalization adds 25% overhead. A large part of this
high overhead is because of the domain switch between
FreeRTOS ISR and the TCP/IP stack, which is dominated
by costly PMP reconﬁgurations.
10.4.2. Throughput We measure the throughput of dif-
ferent implemented models by uploading a ﬁle from the
host computer to an FTP server running on FreeRTOS.
This is the most realistic workload and resembles a real-
world use case where there are different protocols, com-
partments, and subsystems triggering multiple protection
domain switches. The aim is to investigate how different
implementations of protection models affect the over-
all performance by amortizing the cost of timer inter-
rupts, memcpy advantage in CHERI, and single-packet
processing time, discussed in the previous section. We
replaced all of the memcpy calls that do not contain point-
ers to use 4-byte integer registers copies instead of 8-byte
CHERI registers, across all variants, including PURE-
CAP and COMPARTOS. For each received packet, there
are multiple protection domain switches between task-
based compartments, multi-threaded compartments, and
library-based compartments. For instance, a packet is
received by the FreeRTOS ISR, which jumps to the VCU-
118 network device driver, which is part of a multi-task
compartment (freertos_tcpip) as it contains a thread for
the ISR and a thread for the TCP/IP stack processing.
Communication between them is IPC-based over queues,

Figure 8: FTP upload bandwidth of varying ﬁle sizes.

Figure 9: FTP upload bandwidth for 8 MiB ﬁle size.

thus triggering a context switch that implicitly performs a
protection domain switch. Later on, other compartments
like tcp_servers and ftp_server and the ﬁlesystem are
called to process the FTP commands and write the ﬁle
before sending back an acknowledgment and response
packet to the host. Overall, the processing includes mul-
tiple domain switches, IO handling, memory-intensive
operations, and per-packet and scheduling handling, thus
demonstrating a rich and real diverse workload that is
commonly used in deployed embedded systems.

Figure 8 shows the absolute bandwidth of upload-
ing different ﬁle sizes from the host to FreeRTOS over
FTP. The most relevant and important variants there are
COMPARTOS-LIBS and PMP-N-LIBS, with library
compartments represented. The bandwidth stabilizes af-
ter a certain ﬁle size as the host PC cannot send packets
any faster due to its hardware and Linux networking sub-
systems. Figure 8 shows that the linkage-based PMP
variants are quite slow compared to all other variants, in-
cluding CompartOS and PURECAP, regardless of the ﬁle
size. The bandwidth overheads further increase across the
PMP variants when the ﬁle size increases. This suggests
that PMP-based compartmentalization is not as scalable
as CompartOS.

In Figure 9, we pick a ﬁle size of 8 MiB when
the bandwidth stabilizes and compare the overheads
against INSECURE-STATIC. The PMP-N-LIBS has a
signiﬁcant 60% overhead while COMPATOS-LIBS only
incurs 18% overhead. Further, COMPATOS-LIBS’s
overhead is less than 2% higher compared to PURE-

11

211213215217219221223Filesizes(bytes)100200300400Bandwidth(KiB/Second)INSECURESTATICPMP4TASKSPMPNOBJSPMPNLIBSPURECAPCOMPARTOSOBJSCOMPARTOSLIBSINSECURESTATICINSECUREDYNAMICPMP4TASKSPMPNOBJSPMPNLIBSPURECAPCOMPARTOSLIBSCOMPARTOSOBJS050100150200250300350400Bandwidth(KiB/Second)BaselineMPU/PMPCHERI371.90338.66377.26128.78148.94310.84303.63285.7110.5.1. Fault Handling The ECU demo is a good use
case for evaluating a few fault handling techniques within
CompartOS as it is a safety-critical system that is also
subject to real-time requirements. It does integrate both
critical and less critical compartments with different at-
tributes and requirements. We evaluate fault handling in
the three following compartments and report the lesson
and conclusions learned for each scenario.
10.5.2. J1939 The J1939 compartment is safety-critical
and needs to be reliable and running all the time. It is
used to send brakes and steering commands with real-time
requirements; the main loop delay is 50 milliseconds;
thus, commands should be detected and handled in less
than that.

Return-Error: We experimented with a per-
compartment fault handler that simply drops the mali-
cious command and returns to the caller with an error.
The entire fault handling and return take approximately
30 microseconds, which will not have any effect on the
car’s steering logic; therefore, the real-time guarantees are
maintained. On the other hand, a non-compartmentalized
system may be forced to perform a full restart as a brute-
force recovery mechanism, which takes at least 2 seconds
(the boot time of FreeRTOS and the Automotive ECU
application)—an unacceptable latency for a safety-critical
car brake system. However, Return-Error handling could
cause memory exhaustion and Denial of Service (DoS) if
the attack is recurrent as some buffers are allocated but
not freed in that case.

Custom-Handler: To address the issue of DoS in-
curred in Return-Error, we implemented a Custom-
Handler, which requires knowledge of the design and
implementation of the compartment itself, and assumes
a faulting compartment would return an error code. It
then takes further actions to free the buffer itself, thus not
causing DoS or memory exhaustion. This is a more robust
and secure strategy, but it requires a good knowledge of
the underlying compartments, potential faults (to TRY-
CATCH), and adds some implementation efforts. The
custom handler for J1939 took 10 LoC changes that are
mostly a new function to free the allocated canlib’s buffer.
The overall fault handing took 60 microseconds, which
includes an addition of 30 microseconds to free the buffer,
which is completely acceptable and meets the real-time
requirements.

Micro-reboot: The J1939 compartment has some at-
tributes that made it possible to be micro-rebooted while
meeting real-time requirements. The compartment is
stateless; it only performs services, allocates buffers, pro-
cesses and decodes the J1939 packets and ﬁnally returns.
Further, it is small and simple enough to perform a snap-
shot of its ELF sections and roll them back to a known
start state on faults, effectively performing a micro-reboot.
The entire compartment, including the captable, .text,

Figure 10: Automotive ECU compartmentalized graph.

CAP’s, which suggests that the compartmentalization
trampolines, and per-
overhead (GPREL addressing,
compartment captables) is negligible. Finally, we con-
clude that CompartOS’ TCP/IP bandwidth is 52% faster
than linkage-based, MPU-based compartmentalization.
10.4.3. Security We evaluate the security aspects of
the new compartmentalization model by analyzing the
integrity, conﬁdentiality, and availability of a compart-
mentalized FreeRTOS vulnerable system. This yields a
good speculative indication about the nature and impact
of future unknown vulnerabilities, and how they can be
mitigated by CompartOS. We use the National Vulner-
ability Database (NVD) [8] from the US government’s
National Institute of Standards and Technology (NIST)
Based on our analysis, we found out that at least 10 out of
13 FreeRTOS CVEs [6] would have been caught directly
by CHERI, protecting against critical integrity and conﬁ-
dentiality vulnerabilities. CompartOS takes security fur-
ther to allow a compartment-speciﬁc handler to catch and
handle the violation signal, ensuring the system can con-
tinue to operate—thus, meeting the improved availability
design goal. We have reproduced CVE-2018-16526, and
developed an exploit for it as a proof-of-concept exam-
ple for vulnerability mitigation and improved availability
evaluation. This CVE is very severe, and similar to other
CVEs (as far as reproduction and exploitation); it is also
a base on which others can build.

10.5. Case Study: Safety-Critical Automotive ECU

The Automotive ECU demonstrator is an existing
FreeRTOS-based system (not created by us) on which we
apply the CompartOS model to evaluate availability (par-
tial recovery) and compatibility (no source-code changes)
of a real-time safety-critical system. The demonstrator
(see Figure 10) imitates a modern car, where multiple
microcontrollers are responsible for various tasks and
communicate with each other over a CAN network [3].
This ECU runs FreeRTOS and contains a buffer-overﬂow
vulnerability in the SAE J1939 [10] protocol stack. An
attacker could make use of that and carefully craft a J1939
packet that leads to a buffer overﬂow and remote code ex-
ecution (e.g., disabling reading the brake pedal position).

12

Core FreeRTOS LibsApplication LibsFreeRTOS-Kernelfreertos_tcpip ⌇⌇cyberphys ⌇⌇4cherifreertos148722j1939 2malicious 1Application Entry2canlib 622511.data, etc., ﬁt in less than 4 KiB. Since .text and .rodata
cannot be written (due to CHERI permissions), only .bss
and .data need to be rolled back to a start state. The pro-
cess of doing so takes 83 microseconds. No code changes
were required at all. Rolling back all the ELF sections
(though unnecessary) takes 220 microseconds.
10.5.3. Malicious The Malicious compartment repre-
sents a non-critical compartment that might have been
dynamically loaded or taken control of. This threat model
is not addressed in most secure embedded systems like
TockOS and ACES. This compartment could be some-
thing like a web browser, FTP server, or music player; all
are non-critical to the car steering system but may have
zero-day vulnerabilities that might be exploited. Mali-
cious could try to attack conﬁdentiality and integrity, and
that will be prevented by virtue of capability-based se-
curity offered by CHERI/CompartOS. More importantly,
Malicious could try to perform DoS attacks by faulting
frequently or performing recursive calls, thus preventing
critical compartments from executing or affecting their
real-time requirements. A few fault handling techniques
could be applied here as Malicious is non-critical and
does not have critical compartments relying on it. How-
ever, in such a scenario, the compartment could be simply
killed or suspended for good until an appropriate action
is performed (e.g., software updates).

Compartment-Kill Malicious has faulting instruction
and can be killed. Killing a compartment is as straight-
forward as invalidating its root capability table register
(CGP). Malicious tries to create sockets and send data
over a port. The ﬁrst caught violation attempt takes
14.4 milliseconds which may affect the real-time require-
ments of the main loop as it is part of its path. Once
caught by CHERI, the entire fault handling technique (by
CompartOS) takes 22 microseconds which meets real-
time requirements. Further attempts to invoke the com-
partment immediately fault as CGP is invalid, and that
takes 22 microseconds or less. This prevents the Ma-
licious compartment from accessing any external or in-
ternal functions or data capabilities and protects against
DoS attempts. Finally, this technique did not require any
source-code changes at all on the application level, thus
maintaining compatibility.
10.5.4. TCP/IP The TCP/IP stack is the most complex
compartment in this demo and likely most other RTOSes
as well. It does have many resources, dynamically allo-
cates memory, integrates network device drivers, and has
many dependencies on it. Thus, a single vulnerability
in the TCP/IP stack can massively affect the availability
and overall security of the system. We have reproduced
CVE-2018-16526, discussed earlier, and demonstrated
a real attack that exploits it to understand the implica-
tions associated with fault handling in such scenarios.
First, in a non-secure system, this vulnerability could

cause integrity and conﬁdentially violations (e.g., remote
code execution), which might take control of steering the
car or crash it. Second, in a PURECAP system that is
non-compartmentalized, the buffer overﬂow will be de-
tected by CHERI, but this will trigger an exception and
put the entire system on halt, thus affecting its availabil-
ity and causing a crash. CompartOS is uniquely able to
identify the faulting compartment, its boundaries, and
dependencies which allows it to take further fault han-
dling actions. Only a custom fault handler could work
for the TCP/IP stack as opposed to other fault handling
techniques discussed before. Thus, we chose to experi-
ment with a custom fault handler that restarts the TCP/IP
stack. The following implementation actions were re-
quired: 1) reset some of the TCP/IP stack state, 2) free
memory resources and kill threads created by the com-
partment, 3) notify the dependent compartments that the
TCP/IP stack is going to be restarted, 4) dependent com-
partments need to stop using the sockets and the TCP/IP
compartments, 5) reinitialize the TCP/IP stack, 6) de-
pendent compartments need to recreate sockets and can
resume using the TCP/IP compartment. In our evaluation,
it took 1 second to perform a complete restart (in the back-
ground), while other critical components such as cyber-
phys kept functioning and meeting their real-time require-
ments. We compare that against non-compartmentalized
INSECURE-STATIC and PURECAP systems that take
at least 2 seconds to perform a complete restart of the
whole system that stops all safety-critical compartments.

11. Conclusions and future work

We have described CompartOS as a lightweight linkage-
based compartmentalization model for existing, large,
complex, mainstream embedded systems. Through our
CheriFreeRTOS implementation of CompartOS, we eval-
uated performance, compatibility, availability, scalablity,
and security of both micro- and macro- benchmarks. We
showed that CompartOS outperforms all MPU-based se-
curity models and could protect against (future) exploits
that MPUs cannot detect. Further, CompartOS main-
tains source-code compatibility while compartmentaliz-
ing a large code-base of hundreds or millions LoC with
hundreds of compartments and resources, unlike MPU-
based solutions. Still, CompartOS also preserves the
traditional determinism requirement of RTOSes, unlike
MMUs. Finally, we showed how availability of a safety-
critical system can be improved through a few fault han-
dling mechanisms and partial recovery, while meeting
real-time requirements. Our future work will focus on the
formalization and evaluation of security policies across
speciﬁc security applications and standards such as AR-
INC 653 [2]. The CompartOS linkage-based model could
also be applied to other (embedded) operating systems,
boot loaders, and even general purpose operating systems.

13

We will also explore how CompartOS can be applied to
compartmentalize Linux Kernel Modules.

12. Acknowledgments

This work was supported by the Defense Advanced
Research Projects Agency (DARPA) under contracts
HR0011-18-C-0016 (“ECATS”) and HR0011-18-C-0013
(“BESSPIN”). The views, opinions, and/or ﬁndings con-
tained in this report are those of the authors and should
not be interpreted as representing the ofﬁcial views or
policies of the Department of Defense or the U.S. Govern-
ment. We also acknowledge the Gates Cambridge Trust,
EPSRC grant EP/R513180/1, Arm Limited, and Google.
Approved for Public Release, Distribution Unlimited.

References

[1] 9.7. Dynamic Loader - RTEMS User Manual 6.b528508 (2nd
July 2021) documentation. http://web.archive.org/web/
20210702090729/https://docs.rtems.org/branches/
master/user/exe/loader.html.

[2] ARINC 653. https://en.wikipedia.org/wiki/ARINC_6

[3] CAN bus - Wikipedia. https://en.wikipedia.org/wiki/

53.

CAN_bus.

[4] CHERI-RISC-V. https://www.cl.cam.ac.uk/research/

security/ctsrd/cheri/cheri-risc-v.html.

[5] FreeRTOS-MPU: Memory Protection Unit (MPU) Support. ht
tps://web.archive.org/web/20211031125921/https:
//www.freertos.org/FreeRTOS-MPU-memory-protectio
n-unit.html.

[6] FreeRTOS TCP/IP Stack Vulnerabilities | Mobile Security Blog.
https://blog.zimperium.com/freertos-tcpip-stack-
vulnerabilities-details/.

[7] FreeRTOS+TCP and FreeRTOS+FAT Examples. https://www.
freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/TCP
_FAT_demo_projects.html#Free_TCPIP_FAT_examples.

[8] NVD - Vulnerabilities. https://nvd.nist.gov/vuln.
[9] RTEMS Real Time Operating System (RTOS) (26th July 2021).
https://web.archive.org/web/20210726094718/https:
//www.rtems.org/.

[10] SAE J1939 - Wikipedia. https://en.wikipedia.org/wiki/

SAE_J1939.

[11] The Arm Mbed uVisor. https://github.com/ARMmbed/uvi

sor.

[12] V. Ananda Kumar, Krishan K. Pandey, and Devendra Kumar
Punia. Cyber security threats in the power sector: Need for a
domain speciﬁc regulatory framework in India. Energy Policy,
65:126–133, 2014.

[13] William E. Boebert and Richard Y. Kain. Further note on the
IEEE Annual International Carnahan
conﬁnement problem.
Conference on Security Technology, Proceedings, pages 198–203,
1996.

[14] Ferdi NAND Brasser, Brahim El Mahjoub, Ahmad Reza Sadeghi,
Christian Wachsmann, and Patrick Koeberl. TyTAN: Tiny trust
anchor for tiny devices. Proceedings - Design Automation Con-
ference, 2015-July, 2015.

[15] Stephen Checkoway, Damon McCoy, Brian Kantor, Danny An-
derson, Hovav Shacham, Stefan Savage, Karl Koscher, Alexei
Czeskis, Franziska Roesner, and Tadayoshi Kohno. Comprehen-
sive experimental analyses of automotive attack surfaces. Pro-
ceedings of the 20th USENIX Security Symposium, pages 77–92,
2011.

[16] Catalin Cimpanu. Microsoft: 70 percent of all security bugs are
memory safety issues. https://www.zdnet.com/article/
microsoft-70-percent-of-all- security- bugs-are-
memory-safety-issues.

[17] Abraham A Clements, Naif Saleh Almakhdhub, Saurabh Bagchi,
and Mathias Payer. {ACES}: Automatic compartments for
In 27th {USENIX} Security Symposium
embedded systems.
({USENIX} Security 18), pages 65–82, 2018.

[18] Andrei Costin, Jonas Zaddach, Aurélien Francillon, and Davide
Balzarotti. A large-scale analysis of the security of embedded
ﬁrmwares. Proceedings of the 23rd USENIX Security Symposium,
pages 95–110, 2014.

14

[19] Ang Cui and Salvatore J Stolfo. A quantitative analysis of the
insecurity of embedded network devices: results of a wide-area
In Proceedings of the 26th Annual Computer Security
scan.
Applications Conference, pages 97–106, 2010.

[20] Robert C Daley and Jack B Dennis. Virtual memory, processes,
and sharing in multics. Communications of the ACM, 11(5):306–
312, 1968.

[21] Brooks Davis, Robert N M Watson, Alexander Richardson, Pe-
ter G Neumann, Simon W Moore, John Baldwin, David Chisnall,
Jessica Clarke, Nathaniel Wesley Filardo, Khilan Gudka, and
Others. CheriABI: Enforcing valid pointer provenance and mini-
mizing pointer privilege in the POSIX C run-time environment.
In Proceedings of the Twenty-Fourth International Conference
on Architectural Support for Programming Languages and Oper-
ating Systems, pages 379–393, 2019.

[22] Brooks Davis, Robert N.M. Watson, Alexander Richardson, Pe-
ter G. Neumann, Simon W. Moore, John Baldwin, David Chisnall,
James Clarke, Nathaniel Wesley Filardo, Khilan Gudka, Alexan-
dre Joannou, Ben Laurie, A. Theodore Markettos, J. Edward
Maste, Alfredo Mazzinghi, Edward Tomasz Napierala, Robert M.
Norton, Michael Roe, Peter Sewell, Stacey Son, and Jonathan
Woodruff. CheriABI: Enforcing Valid Pointer Provenance and
Minimizing Pointer Privilege in the POSIX C Run-time Envi-
International Conference on Architectural Support
ronment.
for Programming Languages and Operating Systems - ASPLOS,
pages 379–393, 2019.

[23] Lawrence Esswood. CheriOS: designing an untrusted single-
address-space capability operating system utilising capability
hardware and a minimal hypervisor. PhD thesis, University of
Cambridge, 2021.

[24] Khilan Gudka, Robert NM Watson, Jonathan Anderson, David
Chisnall, Brooks Davis, Ben Laurie, Ilias Marinos, Peter G Neu-
mann, and Alex Richardson. Clean application compartmental-
ization with soaap. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security, pages
1016–1031, 2015.

[25] Paul A Karger. Limiting the damage potential of discretionary
trojan horses. In 1987 IEEE Symposium on Security and Privacy,
pages 32–32. IEEE, 1987.

[26] Douglas Kilpatrick. Privman: A library for partitioning appli-
cations. In USENIX Annual Technical Conference, FREENIX
Track, pages 273–284, 2003.

[27] Chung Hwan Kim, Taegyu Kim, Hongjun Choi, Zhongshu Gu,
Byoungyoung Lee, Xiangyu Zhang, and Dongyan Xu. Securing
Real-Time Microcontroller Systems through Customized Mem-
ory View Switching. (February), 2018.

[28] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andron-
ick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai En-
gelhardt, Rafal Kolanski, Michael Norrish, and Others. seL4:
Formal veriﬁcation of an OS kernel. In Proceedings of the ACM
SIGOPS 22nd symposium on Operating systems principles, pages
207–220, 2009.

[29] Paul Kocher, Ruby Lee, Gary McGraw, and Anand Raghunathan.
Security as a new dimension in embedded system design. In
Proceedings of the 41st annual Design Automation Conference,
pages 753–760, 2004.

[30] Patrick Koeberl, Steffen Schulz, Ahmad Reza Sadeghi, and Vijay
Varadharajan. TrustLite: A security architecture for tiny embed-
ded devices. Proceedings of the 9th European Conference on
Computer Systems, EuroSys 2014, 2014.

[31] Karl Koscher, Alexei Czeskis, Franziska Roesner, Shwetak Patel,
Tadayoshi Kohno, Stephen Checkoway, Damon McCoy, Brian
Kantor, Danny Anderson, Hovav Shacham, and Others. Experi-
mental security analysis of a modern automobile. In Security and
Privacy (SP), 2010 IEEE Symposium on, pages 447–462. IEEE,
2010.

[32] Amit Levy, Bradford Campbell, Branden Ghena, Daniel B Gifﬁn,
Pat Pannuto, Prabal Dutta, and Philip Levis. Multiprogramming a
64kb computer safely and efﬁciently. In Proceedings of the 26th
Symposium on Operating Systems Principles, pages 234–251,
2017.

[33] Henry M Levy. Capability-based computer systems. Digital

Press, 1984.

[34] Arm Limited. Arm Architecture Reference Manual Supplement -
Morello for A-Proﬁle Architecture. https://developer.arm.
com/documentation/ddi0606/latest.

[35] Charlie Miller and Chris Valasek. A Survey of Remote Automo-

tive Attack Surfaces. Defcon 22, pages 1–90, 2014.

[36] Mark S Miller, Ka-Ping Yee, and Jonathan Shapiro. Capabil-
ity Myths Demolished. Technical Report SRL2003-02, Johns
Hopkins University Systems Research Laboratory, 2003.
[37] David M. Nicoul. Hacking the lights out. Computer viruses
have taken out hardened industrial control systems. The electrical
power grid may be next. Scientiﬁc American, 305(1):70–75,
2011.

[38] Dorottya Papp, Zhendong Ma, and Levente Buttyan. Embedded
systems security: Threats, vulnerabilities, and attack taxonomy.
2015 13th Annual Conference on Privacy, Security and Trust,
PST 2015, pages 145–152, 2015.

[39] Sri Parameswaran and Tilman Wolf. Embedded systems secu-
rity—an overview. Design Automation for Embedded Systems,
12(3):173–183, 2008.

[40] Niels Provos, Markus Friedl, and Peter Honeyman. Preventing
privilege escalation. In USENIX Security Symposium, 2003.
[41] Jerome H Saltzer. Protection and the control of information
sharing in multics. Communications of the ACM, 17(7):388–402,
1974.

[42] Jerome H. Saltzer and Michael D. Schroeder. The Protection
of Information in Computer Systems. Proceedings of the IEEE,
63(9):1278–1308, 1975.

[43] Abderrahmane Sensaoui, Oum-El-Kheir Aktouf, David Hely,
and Stephane Di Vito. An in-depth study of mpu-based isolation
techniques. Journal of Hardware and Systems Security, 3(4):365–
381, 2019.

[44] Jonathan S Shapiro, Jonathan M Smith, and David J Farber.
EROS: a fast capability system. In Proceedings of the seventeenth
ACM symposium on Operating systems principles, pages 170–
185, 1999.

[45] Molugu Surya Virat, S. M. Bindu, B. Aishwarya, B. N. Dhanush,
and Maniunath R. Kounte. Security and Privacy Challenges
in Internet of Things. Proceedings of the 2nd International
Conference on Trends in Electronics and Informatics, ICOEI
2018, pages 454–460, 2018.

[46] Robert N M Watson, Jonathan Anderson, Ben Laurie, and Kris
Kennaway. Capsicum: Practical Capabilities for UNIX. USENIX
Security Symposium, 46:2, 2010.

[47] Robert N M Watson, Jonathan Woodruff, Peter G Neumann, Si-
mon W Moore, Jonathan Anderson, David Chisnall, Nirav Dave,
Brooks Davis, Khilan Gudka, Ben Laurie, and Others. Cheri: A
hybrid capability-system architecture for scalable software com-
partmentalization. In 2015 IEEE Symposium on Security and
Privacy, pages 20–37. IEEE, 2015.

[48] Wikipedia contributors. Arm cortex-a — Wikipedia, the free en-
cyclopedia. https://en.wikipedia.org/w/index.php?t
itle=ARM_Cortex- A&oldid=1061921480, 2021. [Online;
accessed 16-February-2022].

[49] Wikipedia contributors. Arm architecture - security extensions —
Wikipedia, the free encyclopedia. https://en.wikipedia.o
rg/w/index.php?title=ARM_architecture#Security_e
xtensions, 2022. [Online; accessed 16-February-2022].
[50] Wikipedia contributors. Arm cortex-m — Wikipedia, the free en-
cyclopedia. https://en.wikipedia.org/w/index.php?t
itle=ARM_Cortex- M&oldid=1070148237, 2022. [Online;
accessed 16-February-2022].

[51] Hongyan Xia, Jonathan Woodruff, Hadrien Barral, Lawrence
Esswood, Alexandre Joannou, Robert Kovacsics, David Chisnall,
Michael Roe, Brooks Davis, Edward Napierala, John Baldwin,
Khilan Gudka, Peter G Neumann, Alexander Richardson, Si-
mon W Moore, and Robert N M Watson. CheriRTOS: A Capa-
bility Model for Embedded Devices. In Proceedings of the 36th
IEEE International Conference on Computer Design (ICCD ’18),
pages 92–99. IEEE.

[52] Wei Zhou, Le Guan, Peng Liu, and Yuqing Zhang. Good motive
but bad design: Why ARM MPU has become an outcast in
embedded systems. arXiv preprint arXiv:1908.03638, 2019.

15

