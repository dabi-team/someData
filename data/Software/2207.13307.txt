2
2
0
2

l
u
J

7
2

]

Y
S
.
s
s
e
e
[

1
v
7
0
3
3
1
.
7
0
2
2
:
v
i
X
r
a

Marker and source-marker reprogramming of Most Permissive

Boolean networks and ensembles with BoNesis

Lo¨ıc Paulev´e

Univ. Bordeaux, CNRS, Bordeaux INP, LaBRI, UMR 5800, F-33400 Talence, France

Abstract

Boolean networks (BNs) are discrete dynamical systems with applications to the modeling of

cellular behaviors. In this paper, we demonstrate how the software BoNesis can be employed to

exhaustively identify combinations of perturbations which enforce properties on their ﬁxed points

and attractors. We consider marker properties, which specify that some components are ﬁxed to a

speciﬁc value. We study 4 variants of the marker reprogramming problem: the reprogramming of

ﬁxed points, of minimal trap spaces, and of ﬁxed points and minimal trap spaces reachable from a

given initial conﬁguration with the most permissive update mode. The perturbations consist of ﬁxing

a set of components to a ﬁxed value. They can destroy and create new attractors. In each case, we

give an upper bound on their theoretical computational complexity, and give an implementation of

the resolution using the BoNesis Python framework. Finally, we lift the reprogramming problems to

ensembles of BNs, as supported by BoNesis, bringing insight on possible and universal reprogramming

strategies. This paper can be executed and modiﬁed interactively.

Introduction

Boolean networks (BNs) are formal discrete dynamical systems with notorious applications for modeling

cellular diﬀerentiation and fate decision processes (Saez-Rodriguez et al., 2009; Cohen et al., 2015; Schwab

et al., 2021; Za˜nudo et al., 2021; Montagud et al., 2022). In these applications, BNs aim at capturing the

stable behaviors (attractors) and the transient dynamics (trajectories) of the cell. From this perspective,

BNs oﬀer a formal framework for predicting perturbations that destabilize the system and drive it towards

a desired new stable behavior. BN control or BN reprogramming, in reference to cellular reprogramming

which aims at converting cell types, is thus receiving a lot of interest from the computational systems

biology community (Za˜nudo and Albert, 2015; Biane and Delaplace, 2019; Mandon et al., 2019; Fontanals

et al., 2020; Su and Pang, 2020; Rozum et al., 2021).

The reprogramming of BNs led to a range of methods and tools addressing diﬀerent instantiations

of this problem: with diﬀerent type of perturbations (instantaneous, temporary, permanent), diﬀerent

temporal modalities (one-step, sequential), diﬀerent scopes (global reprogramming or from a given initial

condition), diﬀerent restrictions on the target attractor (ﬁxed points only, attractors of the original

“wild-type” BN). On top of that, the update mode of the BN, which determines how the trajectories are

computed, can play an important role on the predictions. In this paper, we address the BN reprogramming
with the Most Permissive (MP) update mode, where attractors are the minimal trap spaces of the BN

(Paulev´e et al., 2020). The problems we tackle are related to marker reprogramming: the desired target

attractors are speciﬁed by a set of markers, associating a subset of nodes of the network to ﬁxed values

1

 
 
 
 
 
 
(e.g., A = 1, C = 0). After reprogramming, all the conﬁgurations in all (reachable) attractors must be

compatible with these markers. Importantly, the target attractors are not necessarily attractors of the

original (wild-type) BN: the reprogramming can destroy and create new attractors. In particular, if

there is no attractor in the original model matching with the marker, the reprogramming will identify

perturbations that will create such an attractor and ensure its reachability. This is a substantial diﬀerence

with many of the methods in the literature. Moreover, the approach we present here can return all

the possible solutions, possibly up to a given maximum number of perturbations to apply, and possibly

avoiding uncontrollable nodes.

We address the following BN reprogramming problems in the scope of the MP update mode:

• P1 : Marker reprogramming of ﬁxed points: after reprogramming, all the ﬁxed points of the BN
match with the given markers; optionally, we can also ensure that at least one ﬁxed point exists.
• P2 : Source-marker reprogramming of ﬁxed points: after reprogramming, all the ﬁxed points that

are reachable from the given initial conﬁguration match with the given markers.

• P3 : Marker reprogramming of attractors: after reprogramming, all the conﬁgurations of all the MP

attractors (the minimal trap spaces) of the BN match with the given markers.

• P4 : Source-marker reprogramming of attractors: after reprogramming, all the conﬁgurations of all
the attractors that are reachable from the given initial conﬁguration match with the given markers.

MP ﬁxed points match with the ﬁxed points of the global Boolean map of the BN (and are thus

identical to the ﬁxed points of the (a)synchronous update modes). MP attractors match with so-called

minimal trap spaces of the BN, which are the smallest sub-hypercubes closed by the Boolean map.

Problem P1 has been already addressed in the literature, notably by Biane and Delaplace (2019) with

the ActoNet method and by Moon et al. (2022), based on bilevel integer programming. To our knowledge,

none of the other problems have been addressed completely in the literature.

The software BoNesis (github.com/bnediction/bonesis W) provides a generic environment for the
automated construction of BNs with MP update mode from a speciﬁed structural and dynamical properties.

The properties are translated into a logic satisﬁability problem, expressed in Answer-Set Programming

(ASP). Initially, BoNesis has been designed for performing BN synthesis (Chevalier et al., 2019): solutions

of the logic model correspond to BNs that possess the speciﬁed structural and dynamical properties.

Leveraging this generic declarative speciﬁcation of properties, BoNesis is a versatile tool for reasoning

on BNs in general, with the MP update mode: besides synthesis, it can be used to do model checking,

identify ﬁxed points and attractors in ensemble of BNs, and identifying reprogramming strategies.

In this paper, we show how the software BoNesis can be employed to solve P1, P2, P3, and P4 in the
scope of locally-monotone BNs, where each local function is unate W, i.e., where each local function never
depends on both positively and negatively from a same component.

BoNesis enables reasoning on ensembles of BNs: one of its basic input is the domain of BNs to

consider. This domain could be reduced to a singleton BN: in that case, the reasoning is similar to

standard model checking and reprogramming. In general, the domain is speciﬁed from an inﬂuence graph,

possibly with additional constraints on the underlying logical functions. For BN synthesis, this domain

is used to delimit symbolically the set of candidate models: BoNesis will output the subset of them

that verify the desired dynamical properties. We show how problems P1 to P4 can be partly lifted to

ensembles of BNs using this approach. The paper is structured as follows. The Methods section gives the

necessary background on BNs and MP update mode and formulation of elementary dynamical properties

as satisfaction problems, as well as main principles of the BoNesis environment. The Results section

details how the diﬀerent reprogramming problems P1-P4 can be addressed using BoNesis and shows

2

some experiments to assess their scalability. Finally, the Discussion section sketches possible extensions

of the addressed problems and underlines current challenges for their resolution.

This paper is executable:

it contains snippets of Python code employing BoNesis to demon-

strate its usage on small examples,

including command line usage.

Instructions for its ex-

ecution are given at the beginning of the Results section.
It can be visualized online at
nbviewer.org/github/bnediction/reprogramming-with-bonesis/blob/release/paper.ipynb W and interac-
tively executed either online at mybinder.org/v2/gh/bnediction/reprogramming-with-bonesis/release W
using mybinder W online free service, or locally, following instructions given later in this paper.

Methods

Boolean networks and the Most Permissive update mode

Basic deﬁnitions

A Boolean network (BN) of dimension n is speciﬁed by a function f : Bn → Bn where B = {0, 1} is the
Boolean domain. For i ∈ {1, · · · , n}, fi : Bn → B is referred to as the local function of the component i.
The Boolean vectors x ∈ Bn are called conﬁgurations, where for any i ∈ {1, · · · , n}, xi denotes the state
of component i in the conﬁguration x.

A BN f is locally monotone whenever every of its local functions are unate: for each i ∈ {1, · · · , n},
there exists an ordering of components (cid:22)i∈ {≤, ≥}n such that ∀x, y ∈ Bn, (x1 (cid:22)i
n yn) =⇒
fi(x) ≤ fi(y). Intuitively, a BN is locally monotone whenever each of its local function can be expressed
in propositional logic such that each variable appears either never or always with the same sign. For
instance f1(x) = x1 ∨ (¬x3 ∧ x2) is unate, whereas f1(x) = x2 ⊕ x3 = (x2 ∧ ¬x3) ∨ (¬x2 ∧ x3) is not unate.
Example. The BN f of dimension 3 with f1(x) = ¬x2, f2(x) = ¬x1, and f3(x) = ¬x1 ∧ x2 is locally

1 y1 ∧ · · · xn (cid:22)i

monotone; and an instance of application is f (000) = 110.

Update modes

Given a BN f and a conﬁguration x, the update mode speciﬁes how to compute the next conﬁguration.

There is a vast zoo of update modes (Paulev´e and Sen´e, 2022), but traditionally, two modes are usually

considered in biological modeling: the synchronous (or parallel) deterministic mode, where the next

conﬁguration is given by its application to f (x is succeeded by f (x)), and the fully asynchronous (often

denoted only asynchronous) where the next conﬁguration results from the application of only one local

function, chosen non-deterministically.

However, (a)synchronous update modes do not lead to a complete qualitative abstraction of quantitative
systems and preclude the prediction of trajectories that are actually feasible when considering time scales

or concentration scales. The Most Permissive (MP) (Paulev´e et al., 2020; Paulev´e and Sen´e, 2021) is

a recently-introduced update mode which brings the formal guarantee to capture any trajectory that

is feasible by any quantitative system compatible with the Boolean network (see (Paulev´e et al., 2020)

for details). The main idea behind the MP update mode is to systematically consider a potential delay

when a component changes state, and consider any additional transitions that could occur if the changing

component is in an intermediate state. It can be modeled as additional dynamic states “increase” ((cid:37))

and “decrease” ((cid:38)): when a component can be activated, it will ﬁrst go through the “increase” state

where it can be interpreted as either 0 or 1 by the other components, until eventually reaching the Boolean

3

1 state; and symmetrically for deactivation. A formal deﬁnition of MP dynamics is given later in this

section.

Perturbations

In this paper we will consider BN perturbations that modify the local functions of some components so they

become a constant function. Perturbations model mutations, where a gene is silenced or constitutively

activated. Mathematically, a perturbation is a map associating a set of components to a Boolean value,

for instance, P = {2 (cid:55)→ 0, 4 (cid:55)→ 1}. Given a perturbation P , the perturbed BN f /P is given by, for each

component i ∈ {1, . . . , n}:

(f /P )i(x) =




b

if i (cid:55)→ b ∈ P



fi(x)

otherwise.

Quantiﬁed Boolean expressions and computational complexity

A Boolean expression is a logic formula composed of Boolean variables and propositional logic operators

(negation ¬, conjunction ∧, disjunction ∨, implication =⇒ , equivalence ≡, exclusive disjunction ⊕).
Given variables x1, · · · , xm, a quantiﬁed Boolean expression is of the form Q1x1 · · · Qnxmφ(x1, · · · , xm)
where Q1, · · · , Qm can be the existential ∃ or universal ∀ quantiﬁer, and φ(x1, · · · , xm) a quantiﬁer-free
Boolean expression composed of variables x1, · · · , xm. For instance, consider the quantiﬁed Boolean
expression “∃x1∃x2∀x3 (x3 ∧ x1) ∨ (¬x3 ∧ ¬x2)”. This expression is satisﬁable: ﬁx x1 = 1 and x2 = 0,
then the Boolean expression becomes equivalent to x3 ∨ ¬x3 which is true for all assignments of x3.

Deciding whether such an expression is true (satisﬁable) is a fundamental problem in computer science.

The complexity of this problem actually depends on the alternance of quantiﬁers. Thus, in the following
we will classify the quantiﬁed Boolean expressions by their sequence of quantiﬁers Q1 · · · Qm but ignoring
repetitions: an ∃∃∀∀∀∃∃∀-expression has the same decision complexity as an ∃∀∃∀-expression.

Computational complexity (Papadimitriou, 1995) is a fundamental theory of computer science to

classify decision problems: a (decision) problem is in class C whenever there exists an algorithm of

worst-case complexity C, C referring to either a time or space complexity. For instance, the class PTIME
gathers all the problems that can be decided in time polynomial with the size of the input (e.g., the

length of the Boolean expression).

The decision of satisﬁability of ∃-expressions is the infamous (Boolean) SAT(isﬁability) problem, which

is NP-complete: it can be solved by a non-deterministic polynomial time algorithm, and it is among the

hardest problems in this class: any problem in NP can be (eﬃciently) transformed into a SAT problem.

In practice, our computers being deterministic, the resolution of the SAT problems employs algorithms

running in worst-case time and space exponential with the number of variables in the Boolean expression.

However, modern SAT solvers can approach expressions with thousands to millions of variables.

The decision of satisﬁability of ∀-expressions can be seen as a complementary problem to ∃-expression:

∀X φ(X) is satisﬁable if and only if ∃X ¬φ(X) is not satisﬁable: it is a coNP-complete problem. It is

not known whether coNP = NP.

Then, the alternance of quantiﬁers makes the problem climbing into the so-called polynomial hierarchy1.
k -complete problems, where k is the number of alternating quantiﬁers (starting
1 =coNP). It is not known yet whether

∃ . . .-expressions are ΣP
with ∃), while ∀ . . .-expressions are ΠP

1 =NP and ΠP

k -complete (ΣP

1See en.wikipedia.org/wiki/Polynomial hierarchy W

4

all these complexity classes are equal, but in practice, algorithms of resolution scale rapidly down with

their height in the polynomial hierarchy. Each of these complexity classes are included in PSPACE, the

class of problems solvable in polynomial space. PSPACE-complete problems, such as the veriﬁcation of

properties of asynchronous BNs, are known to be diﬃcult to tackle in practice (currently limited to a

couple of hundreds of variables in the case of BNs).

The reader should keep in mind that the length of the expression is a crucial parameter for the decision

complexity. When variables have a ﬁnite domain, one can rewrite quantiﬁed Boolean expression in a

universal-free one. However, the length of the obtained expression will be exponentially larger.

In the rest of the paper, for the sake of simplicity, we will not fully detail the size of the quantiﬁed

Boolean expression we derive, and are expected to be of length linear or polynomial with the size of the
BN.

Elementary dynamical properties and their complexity

We present the formal aspects of the MP dynamics that are employed in the rest of the paper, i.e., related

to attractors and the reachability of attractors. The proofs and full MP deﬁnition and properties can be

found in (Paulev´e et al., 2020).

Sub-hypercubes and trap spaces

A sub-hypercube speciﬁes for each dimension of the BN if it is either ﬁxed to a Boolean value, or free: it
can be characterized by a vector h ∈ {0, 1, ∗}n. Its vertices are denoted by c(h) = {x ∈ Bn | hi (cid:54)= ∗ =⇒
xi = hi}. For instance, h = 0 ∗ ∗ is a sub-hypercube of dimension 3, with c(h) = {000, 001, 010, 011}.

A sub-hypercube h is a trap space whenever for each of its vertices x ∈ c(h), f (x) is also one of its

vertices (h is closed by f ). In particular, the (sub-)hypercube ∗n is always a trap space.

Given a sub-hypercube h, a local Boolean function fi : Bn → B, and a Boolean value b ∈ B, deciding
whether there exists a conﬁguration x ∈ c(h) such that fi(x) = b is the SAT problem. It is NP-complete
in the general case, and it is PTIME if fi is unate, or with other speciﬁc representations of it.

Deciding whether a sub-hypercube h is not a trap space boils down to determining whether there
exists a non-free component i (hi (cid:54)= ∗) and a conﬁguration x ∈ c(h) such that fi(x) = ¬hi, which is a
similar SAT decision problem. Therefore, deciding whether a sub-hypercube h is a trap space is in coNP

in general, and in PTIME when f is locally-monotone.

MP attractors are minimal trap spaces

The attractors of MP dynamics are the minimal trap spaces of the Boolean function f . A sub-hypercube
h is smaller than a sub-hypercube h(cid:48), denoted by h (cid:22) h(cid:48) whenever c(h) ⊆ c(h(cid:48)). Equivalently, this means
that each non-free component of h(cid:48) is ﬁxed to the same value in h: h (cid:22) h(cid:48) ⇐⇒ ∀i ∈ {1, . . . , n}, h(cid:48)
i (cid:54)=
∗ =⇒ hi = h(cid:48)
i.

Deciding whether a trap space is not minimal boils down to deciding the existence of a (strictly)

smaller trap space. This can be performed by a non-deterministic algorithm which checks for the trap
space property of a given smaller trap space, thus residing in the complexity class denoted as NPcoNP,
and in NP in the locally-monotone case. Thus, deciding whether a trap space is a minimal trap space
resides in coNPcoNP (i.e., ΠP

2 ) in general, and coNP in the locally-monotone case.

5

MP reachability of attractors

Given a conﬁguration x and an MP attractor A ∈ {0, 1, ∗}n, there is an MP trajectory from x to any
conﬁguration y ∈ A if and only if A is smaller than the smallest trap space containing x. We write

reach(x, y) the existence of such a trajectory.

Let us denote by TS(x) ∈ {0, 1, ∗}n the smallest trap space containing x. The computation of
h = TS(x) can be performed from x by iteratively freeing the components necessarily to fulﬁll the
closeness property. Here is a sketch of algorithm, where SAT(h, f[i] = -x[i]) is true if and only if
there exists a conﬁguration y ∈ c(h) such that fi(y) = ¬xi:

Algorithm TS(x: configuration)

Returns sub-hypercube h

--

h := x

repeat

changed := false

for i in 1..n:

if h[i] != * and SAT(h, f[i] = -x[i]):

h[i] := *

changed := true

while changed

In the worst case, this algorithm makes a quadratic number of calls to the SAT problem. Therefore, the
decision of MP reachability of attractors is in PTIMENP in general2, and PTIME in the locally-monotone
case.

Note that the general MP reachability property is not addressed here, but its overall complexity is

identical. With (a)synchronous update modes, it is a PSPACE-complete problem.

Belonging to an MP attractor

Finally, given a conﬁguration x, we are interested in deciding whether x belongs to an attractor of f (with

the MP update mode). We write IN-ATTRACTOR(x) such a property. Following the above sub-sections,

this can be veriﬁed in two steps: (1) compute the smallest trap spaces containing x, noted TS(x), and (2)

verify whether TS(x) is a minimal trap space. This later property is true if and only if for any vertex y

of TS(x), the minimal trap space containing y is equal to TS(x):

IN-ATTRACTOR(x) ≡ ∀y ∈ c(TS(x)), TS(y) = TS(x) .

In the following, given a set of perturbations P , we write TSP (x) for the small trap space of perturbed
BN (f /P ) containing x, and IN-ATTRACTORP (x) the property of x belonging to an attractor of the
perturbed BN (f /P ).

BoNesis

BoNesis (github.com/bnediction/bonesis W) is a Python library which has been primarily designed for
identifying BNs satisfying user-given dynamical properties among a given domain of BNs and with the

2this problem is actually in NP when allowing a number of variables quadratic with n

6

MP update mode. It takes as input (1) a domain of BNs F, and (2) a set of Boolean dynamical properties
φ, and can enumerate the BNs f ∈ F such that f |= φ, i.e., f veriﬁes the properties φ.

Currently, the domain of BNs F can be one of the following:

• A singleton locally-monotone BN F = {f }. In that case, BoNesis can be employed as a model
checker to verify that f has the speciﬁed dynamical properties. In this paper, this is the main

setting we will consider, in order to predict perturbations to reprogram the attractors of f .

• An explicit ensemble of locally-montone BNs F = {f 1, · · · , f m}.
• Any locally-monotone BN matching with a given inﬂuence graph G: F = {f | G(f ) ⊆ G}. An
inﬂuence graph is a signed digraph between components, i.e., of the form ({1, · · · , n}, V ) with

V ⊆ {1, · · · , n} × {+1, −1} × {1, · · · n}. The inﬂuence graph of a BN f , denoted by G(f ) has an edge
i s−→ j if and only there exists a conﬁguration x ∈ Bn such that fj(x1, . . . , xi−1, 1, xi+1, . . . , xn) −
fj(x1, . . . , xi−1, 0, xi+1, . . . , xn) = s.

• Any locally-monotone BN matching with a partially-deﬁned BN following the AEON framework

(Beneˇs et al., 2021).

BoNesis oﬀers a Python programming interface to declare the dynamical properties over BNs, including

reachability, ﬁxed points and trap spaces. BoNesis relies on Answer-Set Programming (ASP) and the
ASP solver clingo W for the enumeration of solutions. ASP is a declarative logic programming framework
for expressing combinatorial decision problems and enumerate their solutions, possibly with optimizations.

ASP can be employed for eﬃciently solving ∃- and ∃∀-expressions, thus having an expressiveness higher

than classical SAT.

The usage of BoNesis Python programming interface and command line will be explained along with

the code snippets provided in the next sections.

Results

We show how the general declarative approach of BoNesis can be instantiated to compute the complete

solutions to the P1, P2, P3, and P4 reprogramming problems on BNs, and also extend the reasoning to

ensembles of BNs. Importantly, note that BoNesis currently supports only locally-monotone BNs.

This is an executable paper which demonstrates the use of BoNesis for the reprogramming of BNs. The

corresponding notebook can be downloaded from nbviewer.org/github/bnediction/reprogramming-with-
bonesis/blob/release/paper.ipynb W. Its execution requires the Jupyter notebook W system, Python W,
and the Python package bonesis to be installed, see github.com/bnediction/bonesis W for instructions.
Alternatively, the notebook can be executed within the CoLoMoTo Docker distribution (Naldi et al., 2018),
using the Docker image colomoto/colomoto-docker:2022-07-01, which can be launched as follows:

pip install colomoto-docker

colomoto-docker -V 2022-07-01

then open http://127.0.0.1:8888 W and upload the notebook from the Jupyter interface. See

github.com/bnediction/reprogramming-with-bonesis W for further help.

In [1]: #!pip install --user bonesis

# uncomment to install bonesis locally

import bonesis

In [2]: from colomoto_jupyter import tabulate # for display

import pandas as pd # for display

import mpbn # for analyzing individual Boolean networks with MP update mode

7

Alternatively, the computation of reprogramming perturbations from single Boolean networks can be
performed using the command line programbonesis-reprogramming, provided alongside the bonesis
Python package. We detail its usage in each case.

Marker reprogramming of Boolean networks

We ﬁrst consider the reprogramming of a single BN f of dimension n. In the framework of BoNesis, this
means the domain of BNs is the singleton F = {f }.

A marker M is a map associating a subset of components of f to a Boolean value. For instance,

M = {1 (cid:55)→ 0, 3 (cid:55)→ 1} is the marker where component 1 is 0 and component 3 is 1. We denote by dom(M )
the domain of the map M , i.e., in our example dom(M ) = {1, 3}. Given a conﬁguration x ∈ Bn, we say
x matches with a marker M , denoted by x |= M , if and only if ∀i ∈ dom(M ), xi = M (i). Given a set
of conﬁgurations A ⊆ Bn, we say A matches with a marker M if and only if each of its conﬁgurations
match with M (∀x ∈ A, x |= M ). Given k ∈ N, we denote by M≤k the sets of maps associating at most k
components among {1, · · · , n} to a Boolean value.

The objective of marker-reprogramming is to identify perturbations so that all the ﬁxed

points/attractors of the perturbed f match with the marker M . The source-marker reprogramming then

focuses on the ﬁxed points/attractors reachable from a given initial conﬁguration only, thus potentially

requiring fewer perturbations.

A very important aspect of marker reprogramming is that it accounts for the creation and deletion of

attractors due to the perturbation. Thus, in general, the attractors of the reprogrammed BN are diﬀerent

from the attractors of the input (wild-type) BN.

In this section, we tackle the following instantiations of the reprogramming problem:

1. Marker reprogramming of ﬁxed points (P1 );

2. Source-marker reprogramming of ﬁxed points (P2 );

3. Marker reprogramming of attractors (P3 );

4. Source-marker reprogramming of attractors (P4 ).

In each case, we brieﬂy study the complexity of the associated decision problem (existence of a

perturbation given the desired reprogramming property), and give the Python and command line recipe to

identify the perturbations with BoNesis. The following table summarizes the results, with the complexity

in the locally-monotone case and command line usage:

Problem Complexity Command line

P1

P2

P3

P4

∃∀

∃∀

∃∀∃

∃∀∃

[base] --fixpoints

[base] --fixpoints --reachable-from z

[base]

[base] --reachable-from z

where [base] is the command line bonesis-reprogramming model.bnet M k, with model.bnet the
path to a ﬁle in BooleanNet format W, M speciﬁes the marker as a JSON map, k is the maximum number
of simultaneous perturbations, and z is the initial conﬁguration as a JSON map. For instance,

bonesis-reprogramming model.bnet '{"A": 0, "C": 1}' 3 \
--reachable-from '{"A":1, "B":0, "C":0,"D":0}'

8

Marker-reprogramming of ﬁxed points (P1)

We identify the perturbations P of at most k components so that all the ﬁxed points of f /P match with

the given marker M . The associated decision problem can be expressed as the following ∃∀-expression,
hence being at most in ΣP
2 :

∃P ∈ M≤k, ∀x ∈ Bn, (f /P )(x) = x ⇒ x |= M

(1)

“There exists a perturbation being a map of at most k components to a Boolean value, such that
for all conﬁgurations x ∈ Bn, if x is a ﬁxed point of the perturbed BN (f /P ), then x matches with the
marker M ”.

Remark that any BN having no ﬁxed point verify the above equation with an empty perturbation.

Thus, in practice, one may also expect that the perturbed BN possesses at least one ﬁxed point:

∃P ∈ M≤k, ∃y ∈ Bn, (f /P )(y) = y, ∀x ∈ Bn, (f /P )(x) = x ⇒ x |= M .

(2)

With the BoNesis Python interface, this reprogramming property can be declared as follows, where f
is a BN, M the marker (speciﬁed as Python dictionary associating a subset of components to a Boolean
value), and k the maximum number of components that can be perturbed (at most n):

In [3]: def marker_reprogramming_fixpoints(f, M, k, ensure_exists=True):

# f: Boolean network; M: marker; k: maximum number of components to perturb

bo = bonesis.BoNesis(f)

P = bo.Some(max_size=k) # perturbations to identify

with bo.mutant(P):

# impose that all the fixed points of the perturbed BN match with M

bo.all_fixpoints(bo.obs(M))

if ensure_exists:

# impose the existence of at least one fixed point matching with M

bo.fixed(~bo.obs(M))

return P.assignments()

The line bo = bonesis.BoNesis(f) instantiates a BoNesis object bo with the domain f. In this
section, we assume that f is a single Boolean network. It can be either the path to a BooleanNet ﬁle, a
minibn object, for instance as returned by the biolqm.to minibn function for importing models from
various formats, or a Python dictionary, associating components to a Boolean function. Examples are

given below.

Then, the line P = bo.Some(max size=k) declares a variable that will consist of a map associating

at most k components to a Boolean value (the perturbation to be identiﬁed).

The instruction with bo.mutant(P) opens a context where dynamical properties will be veriﬁed
against the BN f with the perturbation P applied. Within this mutant context, we declare with
bo.all fixpoints(bo.obs(M)) that each ﬁxed point of the perturbed model matches with M. Moreover,
whenever ensure exists is true, the constraint bo.fixed(~bo.obs(M)) imposes that the conﬁguration
associated with M (~bo.obs(M)) is a ﬁxed point.

Finally, P.assignments() returns an iterator over all the possible assignments of P that fulﬁll the

above dynamical properties.

The corresponding command line is of the form

bonesis-reprogramming model.bnet M k --fixpoints

9

Figure 1: Inﬂuence graph of the example BN for P1

where model.bnet is a BN encoded in BooleanNet format, M speciﬁes the marker as a JSON map, and
k is the maximum number of perturbations. The existence of at least one ﬁxed point can be lifted with
the option --allow-no-fixpoint. Example. We illustrate the marker-reprogramming of ﬁxed points on
a small toy BN example, which has no ﬁxed point. In the following, we use colomoto.minibn to deﬁne
this BN.

In [4]: from colomoto.minibn import BooleanNetwork

In [5]: f = BooleanNetwork({

"A": "B",

"B": "!A",

"C": "!A & B"

})

f

Out[5]: A <- B

B <- !A

C <- !A&B

This example BN has two components in a negative feedback: they will oscillate forever. The state of the
third component C is then determined by the state of the oscillating components. The following command
returns its inﬂuence graph:

In [6]: f.influence_graph()

The resulting graphics is reproduced in Figure 1.

With the (fully) asynchronous update mode, the system has a single attractor, consisting of all the

conﬁgurations of the network.

In [7]: f.dynamics("asynchronous")

The resulting graphics is reproduced in Figure 2.

Recall that the ﬁxed points are identical in asynchronous and MP. We use mpbn W to analyze the

dynamical properties with the MP update mode:

In [8]: mf = mpbn.MPBooleanNetwork(f)

list(mf.fixedpoints())

Out[8]: []

In [9]: list(mf.attractors())

10

AB-C-++Figure 2: Fully-asynchronous dynamics of the example BN for P1

Out[9]: [{'A': '*', 'B': '*', 'C': '*'}]

Indeed, the network has no ﬁxed points, and its attractor is the full hypercube of dimension 3.

Using the marker reprogramming fixpoints snippet deﬁned above, we identify all perturbations of
at most 2 components which ensure that (1) all the ﬁxed points have C active, and (2) at least one ﬁxed
point exists:

In [10]: list(marker_reprogramming_fixpoints(f, {"C": 1}, 2))

Out[10]: [{'A': 0}, {'C': 1, 'B': 0}, {'A': 1, 'C': 1}, {'B': 1, 'C': 1}]

Indeed, ﬁxing A to 0 breaks the negative feedback, and make B converge to 1. There, C converges to state
1. Then, remark that ﬁxing C to 1 is not enough to fulﬁll the property, as A and B still oscillate. Thus,
one of these 2 must be ﬁxed as well, to any value. The solution {'A': 0, 'C': 1} is not returned as
{'A': 0} is suﬃcient to acquire the desired dynamical property.

In our BoNesis code snippet deﬁned above, by default we ensure that the perturbed BN possesses
at least one ﬁxed point. When relaxing this constraint, we obtain that the empty perturbation is the
(unique) minimal solution, as f has no ﬁxed point.

In [11]: list(marker_reprogramming_fixpoints(f, {"C": 1}, 2, ensure_exists=False))

Out[11]: [{}]

In the following, we demonstrate how to perform the same computation with the command line. By
default, the reprogramming of ﬁxed points adds the constraint that at least one ﬁxed point must exist.

In [12]: with open("example1.bnet", "w") as fp:

fp.write(f.source())

%cat example1.bnet

11

000010110011100111101001A, B

B, !A

C, !A&B

In [13]: !bonesis-reprogramming example1.bnet '{"C": 1}' 2 --fixpoints

{'A': 0}
{'C': 1, 'B': 0}
{'A': 1, 'C': 1}
{'B': 1, 'C': 1}

Adding the option --allow-no-fixpoint would return an empty perturbation as unique minimal

solution.

Source-marker reprogramming of ﬁxed points (P2)

Given an initial conﬁguration z, we identify the perturbations P of at most k components so that all the

ﬁxed points of f /P that are reachable from z in f /P match with the given marker M . The associated
decision problem can be expressed as the following ∃∀-expression, hence being at most in ΣP
2 :

∃P ∈ Mk, ∀x ∈ Bn, ((f /P )(x) = x ∧ reachP (z, x)) =⇒ x |= M

(3)

“There exists a perturbation P such that for any conﬁguration x ∈ Bn, if x is a ﬁxed point of the

perturbed BN (f /P ), and x is reachable from z in (f /P ), then x must match with M ”.

As explained in the Method section, the reachability property boils down to computing the smallest

trap space containing z: if it contains the ﬁxed point x, then x is reachable from z with the MP update
mode.

∃P ∈ Mk, ∀x ∈ Bn, ((f /P )(x) = x ∧ x ∈ TSP (z)) =⇒ x |= M .

(4)

As with the previous case, in practice we may also want that there exists at least one ﬁxed point

reachable from z.

With the BoNesis Python interface, this reprogramming property is declared as follows, where f is
a BN, z the initial conﬁguration (Python dictionary), M the marker, and k the maximum number of
components that can be perturbed (at most n):

In [14]: def source_marker_reprogramming_fixpoints(f, z, M, k):

# f: Boolean network; z: initial configuration;

# M: marker; k: maximum number of components to perturb

bo = bonesis.BoNesis(f)

P = bo.Some(max_size=k) # perturbation to identify

with bo.mutant(P):

# all the fixed points reachable from z match with M

~bo.obs(z) >> "fixpoints" ^ {bo.obs(M)}

# at least one fixed point matching with M is reachable from z

~bo.obs(z) >= bo.fixed(~bo.obs(M))

return P.assignments()

12

Figure 3: Inﬂuence graph of the example BN for P2

Compared to the previous code snippet, this function relies on speciﬁc operators to restrict the
properties to the ﬁxed point reachable from z. The instruction ~bo.obs(z) refers to a speciﬁc con-
ﬁguration matching with z; ~bo.obs(z) >> "fixpoints" ^ {bo.obs(M)} speciﬁes that all the ﬁxed
points reachable from such conﬁguration have to match with at least one conﬁguration given in the set
{bo.obs(M)}, i.e., M in this case. This property is satisﬁed whenever no ﬁxed point are reachable. Thus,
the next line ensures that at least one ﬁxed point is reachable from the conﬁguration associated with z:
bo.fixed(~bo.obs(M)) refers to one conﬁguration which is a ﬁxed point (in the perturbed BN), and
which matches with M. Then, the binary operator >= declares the existence of a trajectory from its left to
itrs right conﬁguration.

Notice that with this formulation, in the case whenever z is only partially deﬁned (some components
are not associated to a Boolean value), a perturbation is returned as long as there exists at least one

fully-deﬁned conﬁguration matching with z which fulﬁl the speciﬁed dynamical properties.

The corresponding command line is of the form

bonesis-reprogramming model.bnet M k --fixpoints --reachable-from z

where model.bnet is a BN encoded in BooleanNet format, M speciﬁes the marker as a JSON map, k is
the maximum number of perturbations, and z is the initial conﬁguration as a JSON map. The existence
of at least one ﬁxed point can be lifted with the option --allow-no-fixpoint. Example. Let us consider
the following toy BN with two positive feedback cycles:

In [15]: f = BooleanNetwork({

"A": "B",

"B": "A",

"C": "!D & (A|B)",

"D": "!C"

})

f.influence_graph()

The resulting graphics is reproduced in Figure 3.

This BN has 3 ﬁxed points, 2 of which are reachable from the conﬁguration where A and B are active,

and C and D inactive:

13

AB+C+++D--Figure 4: Fully-asynchronous dynamics of the example BN for P2 from the conﬁguration 1100

In [16]: z = {"A": 1, "B": 1, "C": 0, "D": 0}

f.dynamics("asynchronous", init=z)

The resulting graphics is reproduced in Figure 4.

In [17]: list(mpbn.MPBooleanNetwork(f).fixedpoints())

Out[17]: [{'A': 0, 'B': 0, 'C': 0, 'D': 1},
{'A': 1, 'B': 1, 'C': 0, 'D': 1},
{'A': 1, 'B': 1, 'C': 1, 'D': 0}]

In [18]: list(mpbn.MPBooleanNetwork(f).fixedpoints(reachable_from=z))

Out[18]: [{'A': 1, 'B': 1, 'C': 1, 'D': 0}, {'A': 1, 'B': 1, 'C': 0, 'D': 1}]

Let us compare the results of the global marker-reprogramming of ﬁxed points (P1) with the source-marker
reprogramming of ﬁxed points (P2), the objective being to have ﬁxed points having C active. In the ﬁrst
case, putting aside the perturbation of C, this necessitates to act on either A or B to prevent the existence
of the ﬁxed points where A, B and C are inactive:

In [19]: list(marker_reprogramming_fixpoints(f, {"C": 1}, 2))

Out[19]: [{'A': 1, 'D': 0}, {'B': 1, 'D': 0}, {'C': 1}]

Considering only the ﬁxed points reachable from the conﬁguration z, there is no need to act on A or B:

In [20]: list(source_marker_reprogramming_fixpoints(f, z, {"C": 1}, 2))

Out[20]: [{'D': 0}, {'C': 1}]

The command line program bonesis-reprogramming can perform P2 by specifying the --rechable-from
option giving the initial conﬁguration in JSON format:

In [21]: with open("example2.bnet", "w") as fp:

fp.write(f.source())

In [22]: !bonesis-reprogramming example2.bnet '{"C": 1}' 2 --fixpoints \

--reachable-from '{"A": 1, "B": 1, "C": 0, "D": 0}'

{'D': 0}
{'C': 1}

Marker reprogramming of attractors (P3)

We identify the perturbations P of at most k components so that the conﬁgurations of the all the

attractors of f /P match with the given marker M (i.e., in each attractor, the speciﬁed markers cannot

oscillate). The associated decision problem can be expressed as follows:

∃P ∈ Mk, ∀x ∈ Bn, IN-ATTRACTORP (x) =⇒ x |= M

(5)

14

110011101101(“There exists a perturbation P of at most k components, such that for all conﬁgurations x, if x

belongs to an attractor of the perturbed BN f /P , then x matches with the speciﬁed markers M ”)

By restricting the range of the universal part of the equation to the conﬁgurations which do not match

with the marker M , we obtain:

∃P ∈ Mk, ∀x ∈ Bn : x (cid:54)|= M, ¬ IN-ATTRACTORP (x)

(6)

The IN-ATTRACTOR property being itself a quantiﬁed Boolean expression, we obtain the following

∃∀∃-expression:

∃P ∈ Mk, ∀x ∈ Bn : x (cid:54)|= M, ∃y ∈ Bn, y ∈ TSP (x), TSP (y) (cid:54)= TSP (x)

(7)

The problem of satisﬁability of this quantiﬁed Boolean expression is beyond the expressiveness power of

ASP which is limited to ∃∀-expressions. Nevertheless, we can approach this problem by its complementary:

the existence of perturbations of size k such that at least one conﬁguration belonging to an attractor

does not match with the marker M . This complementary problem can be expressed with this following

expression

∃P ∈ Mk, ∃x ∈ Bn, x (cid:54)|= M ∧ IN-ATTRACTORP (x)

which is an ∃∀-expression:

∃P ∈ Mk, ∃x ∈ Bn, x (cid:54)|= M ∧ ∀y ∈ Bn, y ∈ TSP (x) =⇒ TSP (y) (cid:54)= TSP (x) .

(8)

(9)

Because the domain of candidate perturbations M≤k is ﬁnite, one can thus ﬁrst resolve the comple-

mentary problem, giving all bad perturbations, and returns its complement.

Notice that this approach is highly combinatorics, and is likely limited to identifying perturbations

of small size. However, to our knowledge, this is the ﬁrst implemented method which addresses the

complement reprogramming of MP attractors, i.e., of the minimal trap spaces of the BN.

With the BoNesis Python interface, this reprogramming property is declared as follows, where f is a

BN, M the marker, and k the maximum number of components that can be perturbed (at most n):

In [23]: def marker_reprogramming(f, M, k):

bo = bonesis.BoNesis(f)

coP = bo.Some(max_size=k)

with bo.mutant(coP):

x = bo.cfg()

bo.in_attractor(x)

x != bo.obs(M)

return coP.complementary_assignments()

The idea of the above code snippet is to declare the property of being a bad perturbation (coP). In the
context of this perturbation, we declare with x=bo.cfg() a conﬁguration. Then, bo.in attractor(x)
imposes that x belongs to an attractor (minimal trap space) of the perturbed BN; and the x != bo.obs(M)
instruction adds the constraint that x must no match with M.

The .complementary assignments() method performs the computation of the complement of solu-
tions. It solves the above problem with perturbation sizes ranging from 0 to k, and returns complement
minimal perturbations only.

The corresponding command line is of the form

15

Figure 5: Inﬂuence graph of the example BN for P3

bonesis-reprogramming model.bnet M k

where model.bnet is a BN encoded in BooleanNet format, M speciﬁes the marker as a JSON map, k

is the maximum number of perturbations. Example. Let us consider the following BN:

In [24]: f = mpbn.MPBooleanNetwork({

"A": "!B",

"B": "!A",

"C": "A & !B & !D",

"D": "C | E",

"E": "!C & !E",

})

f.influence_graph()

The resulting graphics is reproduced in Figure 5.

Essentially, A and B always stabilize to opposite states. Whenever A is active (and B inactive) then C
will oscillate, otherwise it stabilizes to 0. In each case D and E oscillate. This lead to the following MP
attractors:

In [25]: tabulate(list(f.attractors()))

Out[25]:

A

0

1

B

1

0

C

0

*

D

*

*

E

*

*

0

1

Let us say that our objective is to reprogram the BN such that all the attractors of the component C
ﬁxed to 1. The reprogramming of ﬁxed points (P1) gives the following solutions:

In [26]: list(marker_reprogramming_fixpoints(f, {"C": 1}, 3))

Out[26]: [{'D': 0}, {'C': 1}]

16

AB-C+--D+E--+-Putting aside the trivial solution of perturbing C, let us analyze the BN perturbed with the D forced to 0:

In [27]: pf = f.copy()

pf["D"] = 0

tabulate(pf.attractors())

Out[27]:

A

0

1

B

1

0

C

0

1

D

0

0

E

*

0

1

0

The (only) ﬁxed point of the network indeed has C active. However, it possesses another (cyclic) attractor,
where C is inactive. This example points out that focusing on ﬁxed point reprogramming may lead to
predicting perturbations which are not suﬃcient to ensure that all the attractors show the desired marker.
The complete attractor reprogramming returns that the perturbation of D must be coupled with a

perturbation of A or B, in this case to destroy the cyclic attractor.

In [28]: list(marker_reprogramming(f, {"C": 1}, 3))

Out[28]: [{'C': 1}, {'A': 1, 'D': 0}, {'B': 0, 'D': 0}]

The same results can be obtained using the command line as follows.

In [29]: with open("example3.bnet", "w") as fp:

fp.write(f.source())

In [30]: !bonesis-reprogramming example3.bnet '{"C": 1}' 3

{'C': 1}
{'D': 0, 'A': 1}
{'D': 0, 'B': 0}

In other cases, the reprogramming of attractors may also lead to fewer required perturbations than
focusing on ﬁxed points, provided we enforce the existence of at least one ﬁxed point. This can be
illustrated with the following example:

In [31]: g = mpbn.MPBooleanNetwork({

"A": "!B",

"B": "A",

"C": "A & B",

"D": "C"

})

g.influence_graph()

The resulting graphics is reproduced in Figure 6.

Unperturbed, this network has a single cyclic attractor, as A and B are in a sustained oscillation.

In [32]: tabulate(g.attractors())

Out[32]:

A

*

B

*

C

*

D

*

0

Enforcing that all attractors have D ﬁxed to 1 can be achieved either by perturbing A, or by perturbing
only C, letting A and B oscillate.

In [33]: list(marker_reprogramming(g, {"D": 1}, 2))

Out[33]: [{'A': 1}, {'C': 1}, {'D': 1}]

17

Figure 6: Inﬂuence graph of the example BN g for P3

However, besides the forced activation of A, ensuring that all and at least one ﬁxed point have D active
always requires perturbing at least two components.

In [34]: list(marker_reprogramming_fixpoints(g, {"D": 1}, 2))

Out[34]: [{'A': 1},

{'D': 1, 'A': 0},
{'D': 1, 'B': 0},
{'B': 1, 'D': 1},
{'C': 1, 'A': 0},
{'C': 1, 'B': 0},
{'B': 1, 'C': 1}]

Soure-marker reprograming of attractors (P4)

Given an initial conﬁguration z, we identify the perturbations P of at most k components so that the

conﬁgurations of the all the attractors of f /P that are reachable from z match with the given marker M

(i.e., in each reachable attractor, the speciﬁed markers cannot oscillate). Thus, P4 is the same problem

as P3, except that we focus only on attractors reachable from z, therefore potentially requiring fewer

perturbations.

The associated decision problem can be expressed as follows:

∃P ∈ Mk, ∀x ∈ Bn, x |= M ∨ x /∈ ¯ρf /P

mp (z) ∨ ¬ IN-ATTRACTORP (x)

(10)

(“There exists a perturbation P of at most k components, such that for all conﬁgurations x, either x

matches with the marker M , or x does not belong to an attractor, or x is not reachable from z”).

By integrating the deﬁnition of the IN-ATTRACTOR property, we obtain the following ∃∀∃-expression:

∃P ∈ Mk, ∀x ∈ Bn, x |= M ∨ x /∈ ¯ρf /P

mp (z) ∨ ∃y ∈ Bn, y ∈ TSP (x), TSP (y) (cid:54)= TSP (x)

(11)

The resolution of the problem can be approached in a very similar way to P3, i.e., by solving its

complement. The equation is almost the same, with the addition that x must be reachable from z, leading

18

AB+C+-+D+to the ∃∀-expression:

∃P ∈ Mk, ∃x ∈ Bn, x ∈ TSP (z) ∧ x (cid:54)|= M ∧ ∀y ∈ Bn, y ∈ TSP (x) =⇒ TSP (y) (cid:54)= TSP (x) .

(12)

With the BoNesis Python interface, this reprogramming property is declared as follows, where f is a
BN, z the initial conﬁguration, M the marker, and k the maximum number of components that can be
perturbed (at most n):

In [35]: def source_marker_reprogramming(f, z, M, k):

bo = bonesis.BoNesis(f)

coP = bo.Some(max_size=k)

with bo.mutant(coP):

x = bo.cfg()

bo.in_attractor(x)

x != bo.obs(M)

~bo.obs(z) >= x

return coP.complementary_assignments()

The above code snippet is very similar to the previous marker reprogramming, with the addition of
the ~bo.obs(z) >= x instruction which declares that x, a conﬁguration which belongs to an attractor of
the perturbed BN and which does not match with M, is reachable from z. The corresponding command
line is of the form

bonesis-reprogramming model.bnet M k --reachable-from z

where model.bnet is a BN encoded in BooleanNet format, M speciﬁes the marker as a JSON map, k
is the maximum number of perturbations, and z is the initial conﬁguration as a JSON map. Example.
Let us consider again the BN f analyzed in the previous section. By focusing only on attractors reachable
from the conﬁguration where A is ﬁxed to 1 and other nodes to 0, the reprogramming required to make
all attractors have C ﬁxed to 1 consists only of ﬁxing D to 0. Note that in the speciﬁc example, the
reprogramming of reachable ﬁxed point would give an equivalent result.

In [36]: z = f.zero()

z["A"] = 1

list(source_marker_reprogramming(f, z, {"C": 1}, 3))

Out[36]: [{'D': 0}, {'C': 1}]

The same results can be obtained using the command line as follows.

In [37]: !bonesis-reprogramming example3.bnet '{"C": 1}' 3 \

--reachable-from '{"A": 1, "B": 0, "C": 0, "D": 0}'

{'D': 0}
{'C': 1}

Reprogramming of ensembles of Boolean networks

In the previous section, the reprogramming was performed on a single BN, by giving to BoNesis the

singleton domain of BNs to consider. As described in the Method section, BoNesis can reason on

ensembles of BNs, either speciﬁed explicitly, or implicitly by an inﬂuence graph. The functions deﬁned

19

above can then be directly applied to such ensembles of BNs. In this section, we brieﬂy discuss how the

resulting reprogramming solutions should then be interpreted with respect to these ensembles.

Given a domain of BNs F, BoNesis returns a solution whenever at least one BN of this domain
satisﬁes the given properties. Intuitively, this means that the logic satisﬁability problem is of the form
∃f ∈ F, Φ(f ). As detailed in (Chevalier et al., 2019) in the scope of locally-montone BNs, the size of
the “f ∈ F” formula is, in general, exponential (binomial coeﬃcient) with the in-degree of nodes in the
inﬂuence graph. This complexity is due to the maximum number of clauses a Boolean function can have.

Our encoding in BoNesis allows specifying an upper bound to this number, which enables tackling very
large scale instances although giving access only to a subset of F. The encoding of F in BoNesis also
supports enforcing a canonic representation of BNs in order to oﬀer a non-redundant enumeration of the
BNs, at the price of a quadratic size of the formula. However, in our case, as we are only interested in

enumerating the perturbations, the canonicity of BNs is not needed.

In the case of our implementation of marker reprogramming of ﬁxed points (P1 and P2), the expression

becomes of the form:

∃f ∈ F, ∃P ∈ M≤k, · · ·

Therefore, a perturbation P is returned as soon as it is a reprogramming solution for at least one BN of
the input domain: P may not work on every BN in F, but at least one.

In the case of our implementation of marker reprogramming of attractors (P3 and P4), because we

tackle the complementary problem, the expression becomes of the form:

∃f ∈ F, ∃coP ∈ M≤k, · · ·

Therefore, a bad perturbation coP is returned as soon as it is a bad perturbation for at least one BN
of the input domain. By taking the complement of these perturbations (in M≤k), we obtain that the
returned perturbations are reprogramming solutions for all the BNs in F. Let us illustrate the ensemble
reprogramming with the following example. First, let us deﬁne an inﬂuence graph to delimit the domain
of admissible BNs:

In [38]: dom = bonesis.InfluenceGraph([

("C", "B", {"sign": 1}),

("A", "C", {"sign": 1}),

("B", "C", {"sign": -1}),

("C", "D", {"sign": 1}),

], exact=True, canonic=False) # we disable canonic encoding

dom

The resulting graphics is reproduced in Figure 7.

This domain encloses all the BNs having exactly (exact=True) the speciﬁed inﬂuence graph, 4 distinct

BNs in this case:

In [39]: dom.canonic = True # we set canonic encoding for enumerating BNs

F = list(bonesis.BoNesis(dom).boolean_networks())

Out[39]:

dom.canonic = False

pd.DataFrame(F)

A

1

0

0

1

B

C

C

C

C

C

A|!B

A|!B

A&!B

A&!B

D

C

C

C

C

0

1

2

3

20

Figure 7: Inﬂuence graph delimiting the ensembles of BNs in the example

Let us explore the attractors of each individual BNs:

In [40]: for i, f in enumerate(F):

print(f"Attractors of BN {i}:", list(f.attractors()))

Attractors of BN 0: [{'A': 1, 'B': 1, 'C': 1, 'D': 1}]
Attractors of BN 1: [{'A': 0, 'B': '*', 'C': '*', 'D': '*'}]
Attractors of BN 2: [{'A': 0, 'B': 0, 'C': 0, 'D': 0}]
Attractors of BN 3: [{'A': 1, 'B': '*', 'C': '*', 'D': '*'}]

In this example, we focus on reprogramming the attractors so that the component D is ﬁxed to 1.
On the one hand, when reprogramming ﬁxed points only, because one BN already veriﬁes this property,

the empty perturbation is a solution:

In [41]: list(marker_reprogramming_fixpoints(dom, {"D": 1}, 2))

Out[41]: [{}]

On the other hand, the reprogramming of attractors returns solution that work on every BN:

In [42]: list(marker_reprogramming(dom, {"D": 1}, 2))

Out[42]: [{'C': 1}, {'D': 1}, {'A': 1, 'B': 0}]

Indeed, ﬁxed C to 1, ensures in each case that D is ﬁxed to 1. One can remark that having universal
solutions for ﬁxed point reprogramming of ﬁxed points could be tackled by following a similar encoding
that the reprogramming of attractors: by identifying perturbations which do not fulﬁll the property for
at least one BN in the domain (the complement results in perturbations working for all the BNs):

In [43]: def universal_marker_reprogramming_fixpoints(f, M, k):

bo = bonesis.BoNesis(f)

coP = bo.Some(max_size=k)

with bo.mutant(coP):

x = bo.cfg()

bo.fixed(x) # x is a fixed point

x != bo.obs(M) # x does not match with M

return coP.complementary_assignments()

In [44]: list(universal_marker_reprogramming_fixpoints(dom, {"D": 1}, 2))

21

CB+D+-A+Out[44]: [{'C': 1}, {'A': 1}, {'D': 1}]

Note that in this implementation, we do not ensure the existence of a ﬁxed point after reprogramming:
this is why the perturbation ﬁxing only A to 1 is considered as a solution: for some BNs they will have no
ﬁxed points, therefore all their ﬁxed points match with the marker M.

Scalability

In order to evaluate the scalability on realistic BNs, we use the benchmark constituted by Moon et al.

(2022) to evaluate the reprogramming of ﬁxed points (P1). Their benchmark gathers 10 locally monotone

BNs and 1 non-monotone one, that BoNesis cannot address. The dimension of the 10 BNs are respectively

14, 17, 18, 20, 28, 32, 53, 59, 66, and 75. For each of these models, a target marker for reprogramming has

been deﬁned from the corresponding published studies. Moreover, a subset of nodes has been declared as

uncontrollable to avoid trivial solutions. We used this benchmark to evaluate the scalability of the P1

and P3 implementation we propose in this paper.

For these 10 models, we applied the P1 and P3 reprogramming for diﬀerent maximum number of

simultaneous perturbations (denoted k in the previous sections), up to k = 6. In each case, we measured
the time for the ﬁrst solution, for listing up to 100 solutions, and for listing all the solutions, with a

timeout of 10 minutes. The experiments have been performed on an Intel(R) Xeon(R) processor at

3.3Ghz with 16BG of RAM.

In the case of P1, with k = 6, it took around 1s to get at least one solution for each of the 10 models; up

to 100 solutions have been listed in the same timing, except for one model which took 8s. The full listing

of solutions of 3 of the larger models have timed out, the rest necessitating between 1 and 18s. With

k = 4, BoNesis was able to list all the solutions for all models (up to 5min for one of the larger model).

In the case of P3, with k ≥ 4, 3 of the 10 models could not ﬁnd a single solution in the given time limit;

for most of the other models, a ﬁrst solution was found in around 1s, a couple of models took around

1-2min. The enumeration of the ﬁrst 100 solutions took a similar time with k = 4, but timed out with

k = 6 for all but the 4 smallest models. With k ≤ 2, BoNesis has found all the solutions to P3 for all the

10 models in a few seconds maximum.

These experiments testify of the diﬀerence of complexity between P1 and P3, and more precisely on

the resolution approach taken for P3: the computation of the complementary sets of solutions becomes

rapidly intractable for large combinations of perturbation. Indeed, in practice, there are many bad

perturbations, thus their enumeration, which is necessary to compute their complement, is an important

bottleneck.

Evaluating the scalability of P2 and P4 would require deﬁning initial conﬁgurations which are

meaningful for the diﬀerent models, which are not available in the selected benchmark. Nevertheless,

because the source constraint does not change the complexity classes, we can conjecture that their

scalability should be comparable to P1 and P3 respectively. Moreover, having benchmarks at larger

scale would be insightful, but none of them are available to the best of our knowledge. It should be

noted BoNesis has been applied to do BN synthesis for models with 1,000 nodes (Chevalier et al., 2019),

suggesting a potential applicability of BoNesis for the reprogramming of large BNs. As stressed in the

introduction, there exists only tools addressing P1 to compare with. The experiments of Moon et al.
(2022) show that their bilevel integer programming-based method systematically outperforms the ASP

implementation of pyActoNet (Biane and Delaplace, 2019). On the same benchmark, BoNesis performed

either similarly or in shorter time, except that it is limited to locally monotone BNs only.

22

Discussion

In this paper, we demonstrated how the BoNesis Python library can be employed to fully characterize

permanent perturbations which guarantee that all the ﬁxed points or all minimal trap spaces of the

perturbed BN have a subset of components ﬁxed to desired values (marker).

For the sake of simplicity, we focused on reprogramming for achieving elementary dynamical properties,

that are the ﬁxed points or attractors, optionally reachable from a given conﬁguration. It should be

noted that the snippets shown in this paper can be extended to account for more complex or speciﬁc

dynamical properties after mutation (e.g., existence of additional trajectories, considering multiple initial
conﬁgurations). Moreover, BoNesis enables specifying components which must not be perturbed (exclude
option for the Some object, or --exclude for the command line, taking a list of components which should
be excluded from the candidate perturbations).

We considered for problems, referred to as P1, P2, P3, P4, where P1-P2 relate to the reprogramming

of ﬁxed points, and P3-P4 to the reprogramming of MP attractors (i.e., minimal trap spaces). The

computational complexity of P1-P2 allows an eﬃcient implementation using Answer-Set Programming

(ASP), whereas the one of P3-P4 necessitate working around complementary solution to ﬁt into the

expressiveness of ASP, limiting their scalability. Future work may explore alternative implementations

using diﬀerent logic frameworks.

The identiﬁed perturbations may destroy and create new ﬁxed points and attractors for the BN. This

is a signiﬁcant diﬀerence with most of the methods developed in the literature where many focus on the

control towards attractors of the unperturbed BNs only. Besides the problem P1 which has been already

addressed with diﬀerent methods, we are not aware of any other approach tackling P2, P3, and P4.

Besides the four reprogramming problems tackled in this paper, an additional variant would be the

marker-reprogramming of ﬁxed points which also ensures the absence of cyclic attractors. Note that its

complexity is equivalent to the one of P3/P4, i.e., it can be expressed as a ∃∀∃-expression. This problem

may be relevant for modeling cases where cyclic attractors do not make sense. The programming interface

of BoNesis do not permit an eﬃcient encoding of this problem at the moment.

Sequential reprogramming (Mandon et al., 2017; Pardo et al., 2021) consists in applying sets of

perturbations at diﬀerent time. This can lead to reducing the overall number of component to perturb,

by taking advantage of the natural transient dynamics of the system. Having ﬁxed a number of steps, say
m, the reprogramming problems consists in identifying m sets of perturbations which will be applied in

sequence, and their application may be restricted to attractors only (Mandon et al., 2019). Interestingly

in that case, having ﬁxed the number of reprogramming steps, the computational complexity remains

identical to the one-step reprogramming with locally-monotone BNs, due to the PTIME complexity of

the reachability. For instance, the 2-steps reprogramming of BNs along ﬁxed points only with the MP

update mode can be expressed as the following ∃∀-expression, as P1:

∃P, Q ∈ M≤k, ∀x, y ∈ Bn, fP (x) = x ⇒ reachQ(x, y) ⇒ fQ(y) = y ⇒ y |= M

“There exist two sets of perturbations P and Q, such that for any conﬁguration x and any conﬁguration

y, if x is a ﬁxed point of under the perturbation P , then if y is reachable from x under the perturbation

Q, then if y is a ﬁxed point under the perturbation Q, then it must match with the marker M ”. The

more general 2-steps reprogramming along attractors can be expressed as follows:

∃P, Q ∈ M≤k, ∀x, y ∈ Bn, IN-ATTRACTORP (x) ⇒ reachQ(x, y) ⇒ IN-ATTRACTORQ(y) ⇒ y |= M

23

which, by detailing the IN-ATTRACTOR property, leads to an ∃∀∃-expression, as for the single-step

reprogramming. Future work may then investigate the encoding of sequential reprogramming with

BoNesis.

Finally, we demonstrated how BoNesis can be employed to reason on the reprogramming of BNs,

leading to either solutions that work for at least one BN of the ensemble, or working on each of them

(universal reprogramming). We believe that reasoning on ensemble of models is a promising direction to

address the robustness of predictions in the scope of applications in systems biology.

Acknowledgements

The author would like to thank Kyungduk Moon and Kangbok Leee for stimulating discussions and for

providing the model and conﬁguration ﬁles for the benchmarks.

Software and data availability

The software BoNesis is available at github.com/bnediction/bonesis W. Its use, sharing, and modiﬁcation
are allowed for academic purpose only. The notebook, models, and instructions for reproducing the
results are available at github.com/bnediction/reprogramming-with-bonesis W.

Funding

This work has been supported by the French Agence Nationale pour la Recherche (ANR) in the scope of
the project BNeDiction W (grant number ANR-20-CE45-0001).

References

N. Beneˇs, L. Brim, S. Pastva, and D. ˇSafr´anek. Aeon 2021: Bifurcation decision trees in boolean networks.
In CMSB 2021 - 19th International Conference on Computational Methods in Systems Biology, pages
230–237. Springer International Publishing, 2021. doi:10.1007/978-3-030-85633-5_14 W.

C. Biane and F. Delaplace. Causal reasoning on boolean control networks based on abduction: Theory

and application to cancer drug discovery. IEEE/ACM Transactions on Computational Biology and
Bioinformatics, 16(5):1574–1585, 2019. doi:10.1109/tcbb.2018.2889102 W.

S. Chevalier, C. Froidevaux, L. Paulev´e, and A. Zinovyev. Synthesis of Boolean Networks from Biological

Dynamical Constraints using Answer-Set Programming. In 2019 IEEE 31st International Conference

on Tools with Artiﬁcial Intelligence (ICTAI), pages 34–41, Portland, Oregon, United States, 2019.
IEEE. doi:10.1109/ICTAI.2019.00014 W.

D. P. A. Cohen, L. Martignetti, S. Robine, E. Barillot, A. Zinovyev, and L. Calzone. Mathematical

modelling of molecular pathways enabling tumour cell invasion and migration. PLOS Computational
Biology, 11(11):e1004571, 2015. ISSN 1553-7358. doi:10.1371/journal.pcbi.1004571 W.

L. C. Fontanals, E. Tonello, and H. Siebert. Control strategy identiﬁcation via trap spaces in boolean

networks. In CMSB 2020 - 18th International Conference on Computational Methods in Systems Biology,
pages 159–175. Springer International Publishing, 2020. doi:10.1007/978-3-030-60327-4_9 W.

H. Mandon, S. Haar, and L. Paulev´e. Temporal Reprogramming of Boolean Networks.

In CMSB

2017 - 15th conference on Computational Methods for Systems Biology, volume 10545 of Lecture

24

Notes in Computer Science, pages 179–195. Springer International Publishing, 2017. doi:10.1007/
978-3-319-67471-1_11 W.

H. Mandon, C. Su, S. Haar, J. Pang, and L. Paulev´e. Sequential Reprogramming of Boolean Networks

Made Practical. In CMSB 2019 - 17th International Conference on Computational Methods in Systems

Biology, volume 11773 of Lecture Notes in Computer Science, pages 3–19, Cham, 2019. Springer.
doi:10.1007/978-3-030-31304-3_1 W.

A. Montagud, J. B´eal, L. Tobalina, P. Traynard, V. Subramanian, B. Szalai, R. Alf¨oldi, L. Pusk´as,

A. Valencia, E. Barillot, J. Saez-Rodriguez, and L. Calzone. Patient-speciﬁc boolean models of signalling
networks guide personalised treatments. eLife, 11, 2022. doi:10.7554/elife.72626 W.

K. Moon, K. Lee, S. Chopra, and S. Kwon. Bilevel integer programming on a boolean network for

discovering critical genetic alterations in cancer development and therapy. European Journal of
Operational Research, 300(2):743–754, 2022. doi:10.1016/j.ejor.2021.10.019 W.

A. Naldi, C. Hernandez, N. Levy, G. Stoll, P. T. Monteiro, C. Chaouiya, T. Helikar, A. Zinovyev,

L. Calzone, S. Cohen-Boulakia, D. Thieﬀry, and L. Paulev´e. The CoLoMoTo Interactive Notebook:

Accessible and Reproducible Computational Analyses for Qualitative Biological Networks. Frontiers in
Physiology, 9:680, 2018. doi:10.3389/fphys.2018.00680 W.

C. H. Papadimitriou. Computational Complexity. Addison-Wesley, 1995.

J. Pardo, S. Ivanov, and F. Delaplace. Sequential reprogramming of biological network fate. Theoretical

Computer Science, 872:97–116, 2021. doi:10.1016/j.tcs.2021.03.013 W.

L. Paulev´e and S. Sen´e. Non-deterministic updates of Boolean networks. In 27th IFIP WG 1.5 International

Workshop on Cellular Automata and Discrete Complex Systems (AUTOMATA 2021), volume 90 of Open

Access Series in Informatics (OASIcs), pages 10:1–10:16, Dagstuhl, Germany, 2021. Schloss Dagstuhl –
Leibniz-Zentrum f¨ur Informatik. ISBN 978-3-95977-189-4. doi:10.4230/OASIcs.AUTOMATA.2021.10 W.

L. Paulev´e and S. Sen´e. Boolean networks and their dynamics: the impact of updates. In Systems Biology

Modelling and Analysis: Formal Bioinformatics Methods and Tools. Wiley, 2022.

L. Paulev´e, J. Kolˇc´ak, T. Chatain, and S. Haar. Reconciling qualitative, abstract, and scalable modeling
of biological networks. Nature Communications, 11(1), 2020. doi:10.1038/s41467-020-18112-5 W.

J. C. Rozum, D. Deritei, K. H. Park, J. G. T. Za˜nudo, and R. Albert. pystablemotifs: Python library

for attractor identiﬁcation and control in boolean networks. Bioinformatics, 38(5):1465–1466, 2021.
doi:10.1093/bioinformatics/btab825 W.

J. Saez-Rodriguez, L. G. Alexopoulos, J. Epperlein, R. Samaga, D. A. Lauﬀenburger, S. Klamt, and P. K.

Sorger. Discrete logic modelling as a means to link protein signalling networks with functional analysis
of mammalian signal transduction. Molecular Systems Biology, 5(1):331, 2009. doi:10.1038/msb.2009.
87 W.

J. D. Schwab, N. Ikonomi, S. D. Werle, F. M. Weidner, H. Geiger, and H. A. Kestler. Reconstructing

boolean network ensembles from single-cell data for unraveling dynamics in the aging of human

hematopoietic stem cells. Computational and Structural Biotechnology Journal, 19:5321–5332, 2021.
doi:10.1016/j.csbj.2021.09.012 W.

25

C. Su and J. Pang. CABEAN: a software for the control of asynchronous boolean networks. Bioinformatics,

37(6):879–881, 2020. doi:10.1093/bioinformatics/btaa752 W.

J. G. T. Za˜nudo and R. Albert. Cell fate reprogramming by control of intracellular network dynamics.

PLOS Computational Biology, 11(4):e1004193, 2015. doi:10.1371/journal.pcbi.1004193 W.

J. G. T. Za˜nudo, P. Mao, C. Alcon, K. Kowalski, G. N. Johnson, G. Xu, J. Baselga, M. Scaltriti, A. Letai,

J. Montero, R. Albert, and N. Wagle. Cell line–speciﬁc network models of ER+ breast cancer identify
potential PI3kα inhibitor resistance mechanisms and drug combinations. Cancer Research, 81(17):
4603–4617, 2021. doi:10.1158/0008-5472.can-21-1208 W.

26

