Display of 3D Illuminations using Flying Light Specks∗

Extended Version

Shahram Ghandeharizadeh
University of Southern California
Los Angeles, California, USA
shahram@usc.edu

2
2
0
2

l
u
J

8
1

]

R
G
.
s
c
[

1
v
6
4
3
8
0
.
7
0
2
2
:
v
i
X
r
a

ABSTRACT
This paper presents techniques to display 3D illuminations using
Flying Light Specks, FLSs. Each FLS is a miniature (hundreds of
micrometers) sized drone with one or more light sources to gen-
erate different colors and textures with adjustable brightness. It is
network enabled with a processor and local storage. Synchronized
swarms of cooperating FLSs render illumination of virtual objects
in a pre-specified 3D volume, an FLS display. We present techniques
to display both static and motion illuminations. Our display tech-
niques consider the limited flight time of an FLS on a fully charged
battery and the duration of time to charge the FLS battery. More-
over, our techniques assume failure of FLSs is the norm rather than
an exception. We present a hardware and a software architecture
for an FLS-display along with a family of techniques to compute
flight paths of FLSs for illuminations. With motion illuminations,
one technique (ICF) minimizes the overall distance traveled by the
FLSs significantly when compared with the other techniques.

1 INTRODUCTION
Unmanned Aerial Vehicles (UAVs) are enabling diverse applications
ranging from journalism to entertainment [4, 14, 46]. A Flying Light
Speck, FLS, is a miniature (hundreds of micrometer) sized UAV
configured with Red, Green, and Blue light sources to render illumi-
nations [19, 21]. It is battery powered, network enabled, with some
storage, and processing to implement decentralized algorithms.

A swarm of cooperating FLSs are synchronized to render an
illumination of a virtual object in a 3D FLS display. The display is a
volume partitioned into a mesh of 3D cells. Each cell of the display
is identified by its length, height, and depth (L,H,D) coordinates,
see Figure 1b. We use the L, H, D coordinate system instead of X,
Y, Z because there is no consensus on one definition of the Y and
Z axes. While the picture industry uses the Z axis as the depth,
mathematicians use the Y axis for the depth. It is trivial to map our
L, H, D coordinate system to either definition without ambiguity.
The size of a display cell is dictated by the FLS downwash, a
region of instability caused by the flight of one UAV that adversely
impacts other UAVs entering this region [5, 8, 18, 41, 57, 59], e.g., loss
of control or unpredictable behavior. We assume the light emitted
by an FLS is larger than a display cell, positioning the FLS at the
center of multiple cells along each dimension.

A static illumination is a point cloud. Each point 𝑝𝑖 identifies a
3D coordinate with a value for its color model. In this study, we

∗A shorter version in [20], the Proceedings of the 30th ACM International Conference
on Multimedia (MM ’22), October 10–14, 2022, Lisboa, Portugal, DOI https://dl.acm.
org/doi/10.1145/3503161.3548250, ISBN 978-1-4503-9203-7/22/10. See https://github.
com/shahramg/FLS-Multimedia2022 for experimental software.

Figure 1: (a) A motion illumination of a rose with a falling
petal. It consists of 115 point clouds rendered at 24 point
clouds per second with a 4.79 second display time. 1(b) We
use Length (L), Height (H), and Depth (D) to identify the di-
mensions of a 3D coordinate used by both an FLS display
and an illumination. Motill constructs a grid to compute FLS
flight paths across a sequence of point clouds.

assume the RGBA model that specifies the red, green, blue, and
alpha color settings. Hence, a point is a {𝑙𝑖, ℎ𝑖, 𝑑𝑖, 𝑅𝑖, 𝐺𝑖, 𝐵𝑖, 𝐴𝑖 }.

A motion illumination is a stream. It may be a stream of {𝑝𝑖, 𝑙𝑖, ℎ𝑖,
𝑑𝑖, 𝑅𝑖, 𝐺𝑖, 𝐵𝑖, 𝑠𝑖, 𝑒𝑖 } where the interval {𝑠𝑖, 𝑒𝑖 } specifies when the
point identified by 𝑝𝑖 should be illuminated relative to the start
of the stream. Alternatively, it maybe a stream of point clouds
that must be rendered at a pre-specified rate, e.g., 24 point clouds
per second. Yet another possibility is a hybrid of these two by
associating only one {𝑠, 𝑒} for a point cloud and individual {𝑠𝑖, 𝑒𝑖 }
for select points. This paper assumes the second representation,
i.e., a sequence of point clouds rendered at a pre-specified rate. An
example is the Rose illumination of Figure 1a with a falling petal.
Display of a motion illumination is continuous when FLSs render
its 𝑛 point clouds in a timely manner. Relative to the illumination
of the first point cloud at time 𝑇1, each remaining point cloud
has a start and an end time stamp relative to 𝑇1. FLSs rendering
a point cloud Ξ𝑖 at time 𝑇𝑗 must fly to positions dictated by the
next point cloud Ξ𝑖+1 at time 𝑇𝑗+Δ. Δ is dictated by the rate of point
clouds displayed per unit of time, e.g., Δ = 1 𝑆𝑒𝑐𝑜𝑛𝑑
when 24 point
clouds are rendered per second. Once at their new position, FLSs
must render the lighting required by the point cloud Ξ𝑖+1. This
process continues until all point clouds of a motion illumination
are displayed.

24

Display of both static and motion illuminations is non-trivial
for several reasons. First, a rendering may require a large number
of FLSs. For example, each point cloud of the Rose illumination

 
 
 
 
 
 
consists of 65K points (FLSs). The Rose illumination is simple. We
anticipate more complex illuminations to consist of millions and
potentially billions of points.

Second, FLSs are mechanical devices that fail. Hence, failures are
the norm rather than an exception. A display requires techniques to
render an illumination in the presence of FLSs failing continuously.
Third, each FLS is battery powered with a fixed flight time. Its
battery requires a certain amount of time to charge. A key question
is what is the relationship between these factors and the extra
number of FLSs required to render an illumination? Sections 4
and 5 provide an answer.

Fourth, flight of FLSs may result in collisions. Computing colli-
sion free paths is expensive with tens of UAVs [5, 7–12, 17, 18, 24,
32, 36, 37, 40, 41, 48, 53–57, 59]. This may be prohibitively expen-
sive with tens of thousands of FLSs. It may be impractical in the
presence of FLSs with limited flight times failing constantly. Our
design philosophy is to detect FLS conflicts when computing flight
paths. We provide this information to the FLSs that participate in
the conflict. When FLSs take flight to render an illumination, they
use this information to implement a decentralized technique to
avoid collisions. A simple collision avoidance technique is for the
participating FLSs to take turns flying to their destination by us-
ing their unique identifier to order themselves. Such decentralized
techniques are implemented using the networking, processing, and
storage capabilities of FLSs.

Contributions of this paper include:

• An architecture for FLS displays to render 3D static and

motion illuminations. (Section 2.)

• MinDist and QuotaBalanced algorithms to render a static
illumination. These may be used in either offline or online
mode. In offline mode, they compute a representation that
may be stored in a file for future use without re-running
the algorithm. In online mode, they render the illumination
without generating files. Both algorithms are fast and run in
tens of milliseconds with illuminations consisting of tens of
thousands of points. (Section 3.1.)

• Motill, a family of offline algorithms to compute flight paths
of FLSs that render a motion illumination. One technique,
ICF, minimizes the overall distance travelled by FLSs when
compared with the other alternatives. (Section 3.2.3.)

• A technique that uses standby FLSs to render an illumina-
tion in the presence of FLS failures. With once a month as
the mean time to failure of an FLS, the quality of the Rose
illumination degrades once every 40 seconds due to failures.
Our proposed techniques enhance this to once a month or
more depending on the incurred overhead in the form of
additional FLSs. (Section 4.)

• STAG as a technique that overlaps charging of some FLS bat-
teries with other FLSs rendering an illumination. We prove
optimality of this algorithm in minimizing the total number
of FLSs and charging stations for an illumination. (Section 5.)
• We open source our software and data pertaining to the Rose
illumination for use by the scientific community. See https:
//github.com/shahramg/FLS-Multimedia2022 for details.

The rest of this paper is organized as follows. Section 2 presents
a hardware and software architecutre for an FLS display. Section 3

2

presents algorithms to render both static and motion illuminations.
Section 4 describes FLS failure handling. Section 5 presents an opti-
mal algorithm for continuously charging battery of FLSs. Related
work is presented in Section 6. We conclude with brief conclusions
and future research directions in Section 7.

2 ARCHITECTURE
A 3D FLS display consists of a number of software and hardware
components. These include:

• Hangars: FLSs are kept in one or more hangars. Hangars
protect FLSs from external factors that may either damage
them or reduce their lifetime. A hangar may be accessible to
one or more Dispatchers, Charging Stations, and Terminus.
• Charging Stations: These charge the battery of FLSs, de-
positing those with a fully charged battery into a hangar. A
charging station has one or more well defined entry points
known to the FLSs.

• Dispatchers: One or more dispatchers deploy FLSs to render
an illumination. One or more hangars may be accessible to
a dispatcher. Dispatchers may communicate identity, flight
path, and deploy time of their FLSs to one another to detect
potential FLS crashes. Dispatchers implement algorithms to
avoid potential crashes, see Section 3.1.

• Garbage Collectors, GCs: One or more GCs collect failed
FLSs that fall to the bottom of the display and bring them
to a Terminus. A GC may be in the form of a conveyor belt
that moves failed FLSs away from the display grid and into
entry points that open to the Terminus.

• Terminus: A Terminus has one or more entry points in the
display. In addition to GCs, an FLS that detects it may no
longer function properly may fly to a Terminus, see Section 4.
A Terminus may diagnose a failed FLS, perform procedures
to recover it to normal mode of operation, and deposit a
recovered FLS to a hangar.

• An Orchestrator: A software component that manages FLSs
in Hangars, Charging stations, Dispatchers, Garbage Collec-
tors, and Terminus. It also manages the storage and network
of the Hub. The Orchestrator may delegate tasks to other
components. For example, it may delegate deployment of
FLSs to one or more dispatchers, see Section 3.1.

• Hub: A Hub provides the processing, storage, and network-
ing capabilities of an FLS display. It uses an off-the-shelf op-
erating system such as the Linux Ubuntu. The Hub executes
the Orchestrator software that manages and coordinates all
aforementioned components.

The Orchestrator implements centralized algorithms to render a
motion illumination. It may also implement hybrid centralized and
decentralized algorithms that include the participation of the FLSs,
dispatchers, or both. For example, with the parity-based technique
of Section 4, the Orchestrator may identify the number of FLSs in
a group and their identity. However, detection of FLS failures and
subsequent substitution of a parity FLS for the failed FLS may be
performed by the FLSs without the Orchestrator involvement. At
the other end of the spectrum, certain tasks may be implemented
in a decentralized manner independent of the Orchestrator. An ex-
ample is collision avoidance implemented by FLSs and dispatchers.

Figure 2: Architecture of an FLS display.

Figure 2 depicts these components as the bottom of an FLS dis-
play that sits on a floor or a table top. The volume that is used
to render an illumination is above the garbage collector, i.e., the
conveyor belt at the top. A cylinder at each corner serves as a dis-
patcher. Each is accompanied with a cylinder that an FLS flies into
to obtain access to the charging stations. The charging stations
deposit fully charged FLSs into hangars located on the two sides
and the bottom of the display. Figure 2 shows the Hub as a server
blade installed below the charging stations. Above the charging
stations is the garbage collector. Failed FLSs fall on the garbage
collector’s conveyor belt that rotates and deposits these FLSs in a
Terminus at either end.

Figure 2 is one from many possibilities. With a wall-mounted
3D display and other application use cases, the organization may
be completely different.

3 DISPLAY OF 3D ILLUMINATIONS
To display an illumination, the Orchestrator constructs a 3D mesh
on the display volume. A cell of this mesh is dictated by the down-
wash of an FLS. Assuming an FLS is a quadrotar, a cell may be an
ellipsoid [5, 8, 41] or a cylinders [18, 59] that results in a larger sep-
aration along the height dimension. Each display cell has a unique
(L,H,D) coordinate. It is referenced by one point in the point cloud.

Definition 3.1. A display cell is occupied by one FLS. Its size
is dictated by the downwash of the FLS. It is identified by a unique
(L,H,D) coordinate.

We use a cuboid to represent an illumination cell rendered by an
FLS light source. The size of this cuboid is dictated by the character-
istics of the FLS light source. It may be either smaller than, equal to,
or larger than a display cell. When it is smaller, an FLS may be con-
figured with multiple sets of RGB light sources to render different
points. When equal to or greater than, an FLS may be configured
with one set of RGB light sources. When greater than, the FLS’s
light sources illuminate a point that corresponds to multiple display
cells. Hence, the FLS is placed at the center of these display cells
for illumination. This scenario is assumed in this paper, enabling

Figure 3: A 5x5x5 illumination cell consisting of 125 display
cells with an FLS at its center, occupying the display cell at
coordinates 3x3x3 of the illumination cell. The FLS is ren-
dering RGB lights from its top and bottom to illuminate the
top and bottom faces of the illumination cell.

an FLS𝑖 to pass by FLS𝑗 as long as it stay outside of FLS𝑗 ’s display
cell. We defer the other two cases to future work.

Definition 3.2. A cuboid consists of six flat faces and eight ver-
tices. All its faces are rectangles. A cuboid is a square prism when at
least two faces are squares. A cuboid is a cube when all its six faces
are squares. This paper refers to all as a cuboid.

Definition 3.3. An illumination cell is a cuboid that is larger
than a display cell. An FLS is positioned such that its rendered light
fills one or more faces of the cuboid. Typically, the illumination cell
is occupied by one FLS. Depending on its size, two or more FLSs may
occupy it with at most one rendering its light. The other FLSs may
either be a standby for failure handling (see Section 4) or transitory
on their route to their assigned coordinates or a charging station.

Figure 3 shows an illumination cell consisting of L=5, H=5, and
D=5 display cells. It consists of 125 display cells. It shows an FLS
at the center of the illumination cell, at coordinates L=3, H=3, and
D=3 of the illumination cells. The cones show the FLS rendering
its top and bottom RGB lights to illuminate the top and bottom
faces of the illumination cell. A maximum of 125 FLSs may occupy
this illumination cell with only one rendering its light sources to
illuminate one or more faces of the illumination cell. The other
124 may be transitory on their path to a destination, e.g., another
illumination cell, a charging station. The display cell considers
downwash. Hence, FLSs in an illumination cell will not interfere
with one another as long as they occupy a display cell.

3

Table 1: Notations and their definitions.

Notation Definition

Ξ𝑖
𝜓
𝜃
𝛽
Ω
𝜅𝑖
𝜖𝑖
𝛼
𝑀𝑇𝑇 𝐹

Point cloud 𝑖.
Number of dispatchers.
Max number of points/FLSs assigned to a cuboid.
Flight time of an FLS on a fully charged battery.
Time to charge an FLS battery fully.
Number of points assigned to Dispatcher 𝑖.
Flight paths that transition FLSs of Ξ𝑖 to render Ξ𝑖+1.
Number of points/FLSs in a point cloud.
Mean Time To Failure of an FLS.

Definition 3.4. A point in a point cloud identifies an illumination
cell of an FLS display. A single FLS renders its light to illuminate the
point.

This section describes display of illuminations assuming FLSs
do not fail and have unlimited flight times. These assumptions are
removed in Sections 4 and 5, respectively.

3.1 Display of Static Illumination
An algorithm may illuminate a point cloud based on different ob-
jectives. An example objective is to minimize the total distance
traveled by FLSs to arrive at the coordinate of their assigned point,
i.e., an illumination cell. The formal definition of this assignment
problem is as follows.

Problem 1. An illumination consists of 𝛼 points and a display
consists of 𝜓 dispatchers. The distance from a dispatcher to a point
is fixed, Distance(𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑖 , 𝑃 𝑗 ). Assign each point to a dispatcher
such that one and only one point is assigned to a dispatcher and the
total distance for a dispatcher and its assigned point is minimized,
i.e., minimize (cid:205)𝜓
(cid:205)𝜅𝑖
𝑗=1 𝐷𝑖𝑠𝑡𝑎𝑛𝑐𝑒 (𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑖, 𝑃 𝑗 ) where 𝜅𝑖 is the
𝑖=1
number of points assigned to a dispatcher 𝑖.

MinDist is an algorithm that iterates each point, computes the
distance of the point to a dispatcher, and assigns the point to the
dispatcher with the shortest euclidean distance. See the first for
loop of MinDist, Lines 1-10 of Alg 1.

Subsequently, each dispatcher sorts its assigned points in de-
scending order based on their distance from its location. It deploys
FLSs to render points starting with the farthest away one first, see
the second for loop of MinDist, Lines 11-14. This minimizes the
possibility of dispatched FLSs from colliding with one another.

The first for loop of MinDist, Lines 1-10, is sequential and may
be implemented by the Orchestrator. The second for loop may be
processed by each dispatcher in parallel and independent of the
Orchestrator.

The complexity of the first loop is O(𝜓 ×𝛼) where 𝛼 is the number
of points in a point cloud and 𝜓 is the number of dispatchers. The
complexity of the second loop is dictated by the number of points 𝜅𝑖
assigned to a dispatcher 𝑖 and its algorithm to sort the points based
on their distance, e.g., with the QuickSort algorithm, the complexity
is O(𝜅2

𝑖 ) for dispatcher 𝑖.

MinDist has several limitations. First, it may result in a slow
rendering of an illumination by utilizing a subset of dispatchers
more often than others. This happens when most of the points

Algorithm 1: MinDist
1 for 𝑖 ← 1 to 𝛼 by 1;
2 do
3

𝑚𝑖𝑛 ← 𝑀𝑎𝑥𝐼𝑛𝑡𝑒𝑔𝑒𝑟 ;
for 𝑗 ← 1 to 𝜓 by 1;
do

4

5

6

7

8

9

Δ ← Distance (𝑃𝑜𝑖𝑛𝑡𝑖 , 𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ 𝑗 );
if Δ < 𝑚𝑖𝑛 then
𝑚𝑖𝑛 ← Δ;
𝑡𝑔𝑡 ← 𝑗;

/* Iterate 𝛼 points */

/* Iterate 𝜓 dispatchers */

𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ← 𝑃𝑜𝑖𝑛𝑡𝑖 ;

10
11 for 𝑗 ← 1 to 𝜓 by 1;
12 do
13

𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ 𝑗 sorts its points in descending distance order;
𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ 𝑗 deploys points starting with the farthest away one;

14

/* Deploy FLSs */

in a cloud are clustered in close proximity of a few dispatchers.
While these dispatchers deploy most of the FLSs sequentially, other
dispatchers sit idle. See discussions of Table 2 in Section 3.1.1.

Second, MinDist assumes a dispatcher may access all hangars
and their FLSs. This assumption is violated when hangars are phys-
ically partitioned across dispatchers. MinDist may not render an
illumination that consists of a cluster of points in close proximity
of a dispatcher with insufficient number of FLSs.

We now present Alg 2, QuotaBlanced, that considers the distance
travelled by FLSs, FLS speed, the number of dispatchers, the number
of FLSs accessible to a dispatcher, and the rate at which a dispatcher
may deploy FLSs. It assigns a quota to each dispatcher that is re-
duced as a function of the travel time by its deployed FLSs. The idea
is to have a dispatcher that is very far from the points of a cloud to
deploy some FLSs but not as many FLSs as those dispatchers that
are in close proximity to the points of the cloud.

Distance is an approximation of travel time. The time for an
FLS to fly from a dispatcher to its display cell is a function of the
FLS speed. A dispatcher may be far from the point cloud. How-
ever, if FLSs are extremely fast then their travel time may become
insignificant to the time to deploy FLSs. This motivates an algo-
rithm that requires each dispatcher to deploy its fair share1 of FLSs
while considering travel time of FLSs. QuotaBalanced is one such
algorithm.

QuotaBalanced assumes each dispatcher may deploy 𝑓 FLSs per
time unit (Line 1 of Alg 2) and dispatcher 𝑖 has access to a fixed
number of FLSs. The granularity of its quota is time units required
for a dispatcher to deploy its fair share of FLSs for the point cloud,
. This algorithm converts distance to time using the speed of

𝛼
𝜓 ×𝑓
an FLS, see Line 12.

In each iteration, QuotaBalanced reduces the quota of a dis-
patcher by the FLS travel time to its assigned point. Once the quota
of a disptacher is exhausted, it is removed from the list of active
dispatchers. This causes QuotaBalanced to assign points to other
dispatchers that are not necessarily as close. However, the quota of
these dispatchers are reduced by a larger value because they are

1This changes the problem definition. We are no longer minimizing total distance

travelled.

4

𝑠𝑒𝑐𝑜𝑛𝑑 ;

Algorithm 2: QuotaBalanced
1 𝑓 ← 𝐹 𝐿𝑆 𝑑𝑒𝑝𝑙𝑜𝑦𝑚𝑒𝑛𝑡 𝑟𝑎𝑡𝑒, 𝐹 𝐿𝑆𝑠
2 𝑆 ← 𝐹 𝐿𝑆 𝑆𝑝𝑒𝑒𝑑;
3 𝜛 [1..𝜓 ] ← 𝛼
𝜓 ×𝑓 ;
4 {𝐴𝑐𝑡𝑖𝑣𝑒 } ← 𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑒𝑟𝑠 𝑤𝑖𝑡ℎ 𝐹 𝐿𝑆𝑠 𝑎𝑛𝑑 𝑞𝑢𝑜𝑡𝑎 > 0;
5 for 𝑖 ← 1 to 𝛼 by 1 do
6

𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ← The active dispatcher closest to 𝑃𝑜𝑖𝑛𝑡𝑖 ;
Δ ← Distance (𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ,𝑃𝑜𝑖𝑛𝑡𝑖 );
𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ← 𝑃𝑜𝑖𝑛𝑡𝑖 ;
if 𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 has zero FLSs then

/* Quota for each dispatcher */

{𝐴𝑐𝑡𝑖𝑣𝑒 } = {𝐴𝑐𝑡𝑖𝑣𝑒 } − 𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ;
Remove 𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 from further consideration;
𝑡 ← Δ
𝑆 ;
𝜛 [𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ] = 𝜛 [𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ] − 𝑡 ;
if 𝜛 [𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ] ≤ 0 then

/* FLS travel time */

{𝐴𝑐𝑡𝑖𝑣𝑒 } = {𝐴𝑐𝑡𝑖𝑣𝑒 } − 𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ𝑡𝑔𝑡 ;

if {𝐴𝑐𝑡𝑖𝑣𝑒 } == ∅ then
𝜛 [1..𝜓 ] ← 𝛼 −𝑖
{𝐴𝑐𝑡𝑖𝑣𝑒 } ← Dispatcher𝑖 with FLS[i]>0 and 𝜛 [𝑖 ] > 0;

𝜓 ×𝑓 ; /* Re-compute dispatcher quota */

19 for 𝑗 ← 1 to 𝜓 by 1 do
20

𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ 𝑗 sorts its points in descending distance order;
𝐷𝑖𝑠𝑝𝑎𝑡𝑐ℎ 𝑗 deploys points starting with the farthest away one;

7

8

9

10

11

12

13

14

15

16

17

18

21

farther away, i.e., time to travel is longer. Hence, these dispatchers
will be removed from the active list after a fewer point assignments.
The quota of all dispatchers may be exhausted while some points
remain unassigned. QuotaBalanced re-computes the quota of each
dispatcher using the remaining points, see Lines 16-18. It continues
to assigns points to the dispatchers until their quotas are exhausted.
This process repeats until all points are assigned to dispatchers. The
number of repetitions is 1393 with the point cloud of Section 3.1.1.
A dispatcher with no FLSs is permanently removed from the
Active list (Lines 9-11). This causes other dispatchers to deploy FLSs
to render the illumination.

The worst case complexity of this heuristic is O(𝜓 × 𝛼). It may
perform fewer comparisons than MinDist because dispatchers are
removed from the list. At the same time, in each iteration, it per-
forms more work when compared with MinDist because it must
consider the travel time of an FLS to adjust the quota of a dispatcher
and potentially reset the quota of all dispatchers. In our experiments
of Section 3.1.1, MinDist and QuotaBalanced provided comparable
execution times.

Once points are assigned to dispatchers, a dispatcher may deploy
FLSs similar to the discussion of MinDist, see Lines 19-21. There
is one difference. With QuotaBalanced, dispatchers may deploy
FLSs that cross paths and potentially crash with one another. Dis-
patchers may share the flight path and deployment time of their
FLSs with one another to detect such potential crashes. Prior to
deploying an FLS, a dispatcher may detect a conflict with other
deployed FLSs traveling to their target point. It may implement
a variety of techniques to prevent crashes. A simple technique
is to delay the deployment of the FLS by the flight time of the
conflicting FLS, increasing the latency to render an illumination.

5

Alternatively, the dispatcher may compute a different flight path
for its FLS, eliminating a possible crash.

3.1.1 A Comparison. We use the Princeton Shape Benchmark [47]
to highlight the quantitative and qualitative differences between
MinDist and QuotaBalanced. Its database consists of 1,814 3D mod-
els. We present results from 1 model, the race car (m1510), as the
findings are identical across all models. Figure 4 shows the thumb-
nail for this model and its derived point cloud consisting of 11,894
points.

Figure 4: Shape m1510, thumbnail and its point cloud.

We simulate an FLS display that is a cube with length=100,
height=100, and depth=100 cells. This display consists of 8 dis-
patchers, one at each corner of the cuboid. Each dispatcher may
deploy 10 FLSs per second, one FLS every 100 milliseconds. The
speed of each FLS is 4 cells per second. An FLS flies along a straight
line from the location of its dispatcher to the coordinates of its
assigned point.

While QuotaBalanced uses all 8 dispatchers2 to deploy FLSs,
MinDist uses only 2 at the bottom corner3 of the display. Hence,
QuotaBalanced enhances latency four folds, see 1st row of Table 2.
This comes at a cost, namely, an increase in the total distance
travelled by the FLSs. This metric is more than 2x higher with
QuotaBalanced, see 2nd row of Table 2. This translates into a higher
energy consumption to enhance latency.

QuotaBalanced exhausts the list of active dispatchers and resets

their quota (Lines 16-18 of Alg 2) 1393 times with this model.

Our simulated dispatchers detect when the path of their deployed
FLSs intersect one another, identifying a conflict that may result
in FLSs crashes. QuotaBalanced incurs 35 such conflicts. Not ev-
ery detected conflict is a crash because one FLS may fly past the
crash point in advance of the other conflicting FLSs. In our study,
FLSs must be in 20% proximity of one another to be considered as
conflicting. Table 2 shows QuotaBalanced incurs 12 such conflicts.
This is because dispatchers deploy FLSs that are farther away from
a point in the display coordinate system than the other dispatchers.
This is a small percentage (0.1%) of the 11,894 deployed FLSs by
the 8 dispatchers. See the last paragraph of the previous section on
how to eliminate possible crashes.

3.2 Display of Motion Illuminations
We assume a motion illumination consists of a sequence of point
clouds displayed at a pre-specified rate. See Figure 1a.

Assuming an FLS corresponds to a point, a display must compute
both travel path of FLSs and their change of color from one point

2The difference between the dispatcher that deploys the most number of FLSs

and the one that deploys the fewest number of FLSs is 197, approximately 20%.

3One deploys 6613 and the other deploys 5281 FLSs.

Table 2: MinDist vs. QuotaBalanced

MinDist QuotaBalanced

Illumination Latency (Seconds)
Distance Travelled (Cells)
Intersecting flight paths
FLS Conflicts
Execution Time (Milliseconds)

661
494,938
0
0
27.71

163
1,122,947
35
12
27.44

cloud Ξ𝑖 to the next point cloud Ξ𝑖+1. While these changes may be
minor with point clouds that constitute a scene, they may be drastic
from the last point cloud of one scene to the first point cloud of its
following scene. This paper focuses on computing the intra-scene
travel paths, deferring inter-scene travel paths to future work.

To render a scene, the display must assign an FLS to each point
of its first point cloud Ξ1. This is identical to rendering a static
illumination. Thus, either MinDist or QuotaBalanced maybe used.
To render its subsequent point cloud Ξ2, the Orchestrator must
compute whether:

(1) Ξ2 consists of more points than Ξ1, requiring additional FLSs
to render it. In general, dark FLSs from a previous point cloud
(say Ξ𝑖−1) may be used to render Ξ𝑖+1. If none are available
then FLSs are deployed by a dispatcher.

(2) Ξ2 consists of fewer points than Ξ1, requiring some FLSs
illuminating Ξ1 to either go dark or fly to a charging station.
Dark FLSs may be used in a subsequent point cloud, say Ξ3.
This may minimize the overall distance travelled by FLSs.
This is because requiring FLSs to fly back to a charging
station for Ξ2 only to dispatch FLSs to illuminate Ξ3 may
result in a longer total travel distance.

(3) An FLS illuminating Ξ1 remains stationary and changes color

in Ξ2.

(4) An FLS illuminating Ξ1 flies to a new point identified by Ξ2

and displays either the same or a different color.

(5) An FLS illuminating Ξ1 remains stationary and continues
to display its current color in Ξ2. This is the scenario where
the point in Ξ1 and Ξ2 are identical, i.e., identify the same
illumination cell and render the same color.

Any and all combinations of these possibilities may apply when
considering two point clouds Ξ𝑖 and Ξ𝑖+1.

This section presents two offline algorithms, Simple and Motill,
to detect the alternative scenarios and compute FLS flight paths
and color renderings. Similar to the MPEG encoding technique, a
system may execute these algorithms once for a motion illumina-
tion, store their computed flight paths, and reuse this information
when rendering a motion illumination repeatedly either for the
same user or different users.

Simple. Simple is an offline algorithm that consists of two
3.2.1
steps. Step 1 computes flight paths that transition one point cloud
to the next. It also identifies FLSs that are extras from one point
cloud to next. And, points that may require FLSs to be deployed by
a dispatchers. More formally, with 𝑛 point clouds, {Ξ1, Ξ2, · · · , Ξ𝑛 },
Step 1 computes four sets. Flight paths for the first 𝑛 − 1 point
clouds, denoted {𝜖1, 𝜖2, · · · , 𝜖𝑛−1}. Change of color for the FLSs
used in the first 𝑛 − 1 point clouds, denoted {𝛾1, 𝛾2, · · · , 𝛾𝑛−1}. Extra

FLSs for the first 𝑛 − 1 point clouds, denoted {𝛿1, 𝛿2, · · · , 𝛿𝑛−1}.
There are extra FLSs when Ξ𝑖 consists of more FLSs than Ξ𝑖+1.
Points with no assigned FLSs for the last 𝑛 − 1 point clouds, denoted
{𝜇2, 𝜇3, · · · , 𝜇𝑛 }. Ξ𝑖 may have points with no assigned FLSs when
it consists of more points than Ξ𝑖−1.

In Step 2, Simple processes {𝛿𝑖 } to decide whether one or more
of its FLSs should stay in the display grid and go dark or fly back to
a charging station. The dark FLSs are assigned to a point identified
by a {𝜇 𝑗 >𝑖 }. Step 2 may schedule a dispatcher to deploy FLSs to
illuminate points of {𝜇 𝑗 }.

Step 2 is required when there are extra FLSs, points with no
assigned FLSs, or both, i.e., either {𝛿𝑖 }, {𝜇 𝑗 }, or both are not empty.
Step 1 produces empty {𝛿𝑖 } and {𝜇 𝑗 } when the different point
clouds consist of the same number of points. In this case, Simple
does not execute Step 2.

Simple may optimize for total distance travelled, the amount of
energy used, the time required to execute flight paths, or a hybrid
of these. The hybrid may assign weights to different criterion. This
paper focuses on minimizing the total distance travelled by FLSs,
deferring other possibilities to future work. Below, we detail the
two steps in turn.

In Step 1, Simple constructs a hash table on the coordinates of
Ξ𝑖 and probes it with coordinates of Ξ𝑖+1. For each match, it checks
whether the color of the probing point is the same or different. If
they are the same, it has identified a point that belongs to Scenario 5.
If different then it has identified a point that belongs to Scenario 3.
It adds this change to 𝛾𝑖 .

If the point from Ξ𝑖+1 has no match then it is added to the
set {𝜇𝑖+1}. This point is a candidate for Scenario 4 if Ξ𝑖 and Ξ𝑖+1
consist of the same number of points. It is a candidate for Scenario 1
(Scenario 2) if Ξ𝑖 has more (fewer) points than Ξ𝑖+1.

Step 1 constructs {𝛿𝑖 } as follows. It deletes a hash table entry
that matches a coordinate of Ξ𝑖+1. Once all points of Ξ𝑖+1 have
probed the hash table, Simple enumerates those points that remain
in the hash table and assigns them to {𝛿𝑖 }. FLSs in {𝛿𝑖 } correspond
to Ξ𝑖 points with no matches in Ξ𝑖+1.

Step 1 computes flight paths by mapping points of {𝛿𝑖 } to {𝜇𝑖+1}.
It minimizes the overall distance using the following greedy heuris-
tic. It computes the distance4 between every pairing of a {𝛿𝑖 } point
with a {𝜇𝑖+1} point. It sorts these pairing in ascending distance. It
selects the first pairing, (𝑃1,𝛿, 𝑃1,𝜇 ), and assigns the FLS at the dis-
play cell 𝑃1,𝛿 to fly to the vacant display cell identifies by 𝑃1,𝜇 that
requires illumination. This is a flight path with a source coordinate
𝑃1,𝛿 and a destination coordinate 𝑃1,𝜇 that transitions Ξ𝑖 to render
Ξ𝑖+1. It is added to the set of flight paths {𝜖𝑖 }. Simple removes the
coordinates 𝑃1,𝛿 and 𝑃1,𝜇 from its sorted list of possibilities, and
from {𝛿𝑖 } and {𝜇𝑖+1}, respectively. Step 1 continues with the next
pairing, repeating this process until either {𝛿𝑖 }, {𝜇𝑖+1}, or both are
empty.

If both {𝛿𝑖 } and {𝜇 𝑗 } are empty then Simple terminates. Other-

wise, it proceeds to Step 2.

Step 2 processes {𝛿𝑖 } and {𝜇 𝑗 } sets. If {𝛿𝑖 } is not empty and {𝜇 𝑗 }
is empty then all FLSs in {𝛿𝑖 } are required to fly back to a charging
station after rendering their point cloud Ξ𝑖 . If {𝜇 𝑗 } is not empty

4Distance may be replaced with the amount of energy required or flight time to

consider different objectives.

6

and {𝛿𝑖 } is empty then dispatchers are scheduled to deploy FLSs to
points identified by {𝜇 𝑗 } to illuminate point cloud Ξ𝑗 . With both
scenarios, Step 2 is complete and Simple terminates.

When both {𝛿𝑖 } and {𝜇 𝑗 } are not empty then Step 2 processes
the two sets as follows. If there is a {𝛿𝑖 } with no following {𝜇 𝑗 }
(𝑖 < 𝑗) then all FLSs identified by {𝛿𝑖 } are scheduled to fly back to a
charging station. Otherwise, Step 2 computes the distance5 between
every pairing of a {𝛿𝑖 } point with a {𝜇 𝑗 } point. It sorts these pairing
in ascending distance. It selects the first pairing, (𝑃1,𝛿, 𝑃1,𝜇 ) with
distance 𝜏1, and computes the total distance travelled if 𝑃1,𝛿 flies to
a charging station and an FLS is deployed by a dispatcher closest to
𝑃1,𝜇 to illuminate 𝑃1,𝜇 . If the total distance is smaller than 𝜏1 then
the FLS identified by 𝑃1,𝛿 is scheduled to fly back to a charging
station6. Otherwise, Step 2 computes the flight path from 𝑃1,𝛿 to
𝑃1,𝜇 and adds this path to 𝜖𝑖 . Step 2 removes 𝑃1,𝛿 and 𝑃1,𝜇 from its
sorted table, and from 𝛿𝑖 and {𝜇 𝑗 }, respectively.

Step 2 processes other special cases not detailed here. For exam-
ple, if there is a {𝜇 𝑗 } with no preceding {𝛿𝑖 } (𝑖 < 𝑗) then Step 2
schedules FLSs to be deployed by a dispatcher to illuminate points
identified by {𝜇 𝑗 }.

3.2.2 An Analysis. In our experiments with the Rose illumination,
Step 1 requires approximately 600 seconds to compute flight paths
for FLSs that constitute two consecutive point clouds. This step
wastes time and resources by computing a pairing of each FLS
in {𝜇𝑖+1} with each FLS in {𝛿𝑖 } to identify the pairing with the
shortest distance. Only one qualifies. Step 1 must find and delete
the remaining |{𝜇𝑖+1}| − 1 possibilities.

Step 1 is not optimal even though it enumerates all possible
mappings from FLSs in {𝛿𝑖 } to the vacant coordinates in {𝜇𝑖+1}. This
is trivial to demonstrate with an example. Assume {𝛿𝑖 }={𝑃1, 𝑃2}
and {𝜇𝑖+1}={𝑄1, 𝑄2}. Assume distance from 𝑃1 to each of 𝑄1 and
𝑄2 is 1 and 2 cells, respectively. And, distance from 𝑃2 to each of 𝑄1
and 𝑄2 is 2 and 5 cells, respectively. The optimal minimum distance
of 4 is realized by flying the FLS located at 𝑃1 to the coordinates
of 𝑄2, and flying the FLS at 𝑃2 to the coordinates of 𝑄1. However,
Step 1 maps 𝑃1 to 𝑄1 because their distance is the smallest. It must
subsequently map 𝑃2 to 𝑄2, resulting in 6 as the total travelled
distance by FLSs at 𝑃1 and 𝑃2. This example demonstrates Step 1
of Simple does not compute optimal pairings of FLSs in {𝛿𝑖 } and
{𝜇𝑖+1}.

3.2.3 Motion Illuminations, Motill, Encoding. Motill is a family of
divide-and-conquer encoding techniques to implement Step 1 of
Simple. They localize mapping of the points by constructing a 3D
grid on the point clouds. Instead of computing the distance between
a freed FLS of Ξ𝑖 , {𝛿𝑖 }, with every vacant coordinate of Ξ𝑖+1, {𝜇𝑖+1},
Motill compares those in the same cuboid or its neighboring cuboids.
Other pairings are guaranteed to be farther away. By eliminating
them from consideration, Motill reduces complexity of Step 1 to
provide a faster execution time when computing FLS flight paths.
In addition, a Motill technique named ICF provides shorter flight
distances for FLSs when compared with Simple.

5Distance may be replaced with the amount of energy required or flight time to

consider different objectives.

6In this scenario, Step 2 may consider other following 𝜇𝑘 > 𝑗 . This may identify a
destination point in a point cloud Ξ𝑘 for the FLS in 𝛿𝑖 , producing a flight path stored
in 𝜖𝑖 .

7

Motill is highly parallelizable and may use multiple cores of
a processor to compute flight paths, see Section 3.2.6. Simple is
a special case of Motill with a grid consisting of 1 cuboid, see
Section 3.2.7.

Both lossy and lossless variants of Motill are possible. In lossy
mode, Motill may remove certain points to minimize the number of
FLSs used to render an illumination. In lossless mode, the number
of FLSs is the same as the number of points. The focus of this papers
is on the lossless Motill.

Motill partitions a scene consisting of 𝑛 points clouds into a
Group of Point Clouds (GPCs). Each GPC consisting of 𝜔 point
clouds, {Ξ1, Ξ2, · · · , Ξ𝜔 }, 𝜔 ≤ 𝑛. A point in a GPC corresponds
to an FLS. Motill computes flight paths for different FLSs across a
GPC {Ξ1, Ξ2, · · · , Ξ𝜔 }. Subsequently, Motill combines flight paths
computed for the different GPCs together to compute the travel
path of FLSs for the entire scene.

Motill processes a GPC by constructing a 3D grid on its first
point cloud Ξ1. A maximum limit 𝜃 is imposed on the number
of points assigned to each cuboid of the grid. Every time a cuboid
overflows, Motill breaks the cuboid into two by partitioning it along
a dimension. In our current implementation, we use a round-robin
policy to select among the dimensions across all cuboids. However,
it is possible to develop more sophisticated policies to better balance
points across the cuboids.

Motill constructs a copy of the Ξ1 grid with 𝜌1 cuboids on the
remaining point clouds of a GPC, Ξ2 to Ξ𝜔 . It scans points of
Ξ𝑖 (1 < 𝑖 ≤ 𝜔) and assigns each to the cuboid that contains it,
populating Ξ𝑖 grid. This step does not detect overflows and has no
cuboid splits. Hence, the cuboids of these point clouds may have
more points than the maximum limit 𝜃 .

The purpose of the grid is to reduce the number of points consid-
ered when computing the shortest distance. Its cuboids localize how
a point (FLS) changes position from one point cloud to the next. By
using the same grid across all point clouds of a GPC, Motill localizes
changes to a few cuboids. To describe how this is accomplished, we
define the terms grid and neighboring cuboids. We use these terms
in the following section that details Motill’s processing of the grid.

Definition 3.5. A grid is a 3-dimensional coordinate space con-

sisting of a fixed number of cuboids 𝜌.

Definition 3.6. Two cuboids of a grid are neighbors if their coor-
dinate spans overlap along 2 dimensions (i.e., share a 2D face either
partially or fully) and abut along one dimension.

3.2.4 Grid processing. Motill processes the cuboids that constitute
the grid of Ξ1 to Ξ𝜔 to compute FLS flight paths, {𝜖1, 𝜖2, · · · , 𝜖𝜔−1}.
It processes two sequential point clouds, Ξ𝑖 and Ξ𝑖+1, by enumerat-
ing their respective cuboids and processing one pair at a time. We
identify one such pairing as 𝐶 𝑗
𝑖 and 𝐶 𝑗
𝑖+1. The subscript identifies
the point cloud and the superscript identifies the cuboid. A pair-
ing must have the same superscript value, i.e., identify the same
cuboid in two consecutive point clouds with identical L, H, and D
dimensions and neighbors.

Motill uses Simple’s Step 1 hashing technique to detect Sce-
𝑖+1. With Scenario 4, it
𝑖+1} for each pairing per discussions of Step

narios 1-4 for each cuboid pair 𝐶 𝑗
constructs {𝛿 𝑗
𝑖 } and {𝜇 𝑗
1, see Section 3.2.1.

𝑖 and 𝐶 𝑗

𝑖 and 𝐶 𝑗

Motill computes intra-cuboid and inter-cuboid flight paths to
transition FLSs of Ξ𝑖 to illuminate Ξ𝑖+1. Intra-cuboid flight paths
are local to cuboids 𝐶 𝑗
𝑖+1. Inter-cuboid flight paths may be
in two from: FLSs from a different cuboid in Ξ𝑖 flying into 𝐶 𝑗
𝑖+1 or
FLSs from 𝐶 𝑗
𝑖 flying to a different cuboid in the point cloud Ξ𝑖+1.
Motill computes intra-cuboid flight paths by processing {𝛿 𝑗
𝑖 } and
{𝜇 𝑗
𝑖+1} using Simple, i.e., enumerating all possible combinations,
sorting, and selecting the one with the shortest distance for its
flight path. It computes inter-cuboid flight paths by identifying
those cuboids of Ξ𝑖+1 that have more points than their respective
Ξ𝑖 cuboids and those cuboids of Ξ𝑖+1 with fewer points than their
respective Ξ𝑖 cuboids. This results in two sets of cuboids, {𝐶+} and
{𝐶−}. It processes one cuboid of {𝐶+} by identifying its neighbors
to determine which appears in the set {𝐶−}. For each such cuboid,
it computes all possible mappings to select a destination point with
the shortest distance.

It is possible that there is no neighboring cuboid that intersects a
cuboid in set {𝐶−}. Motill collects these and in a final pass enumer-
ates the points in cuboids of {𝐶+} and points in cuboids of {𝐶−}. It
uses Simple’s technique to map these points together, computing
flight paths for FLSs.

3.2.5 Variants of Motill. Motill is a family of techniques. In this
paper, we consider two variants: Intra-Cuboid-First (ICF) and Intra-
Cuboid-Last (ICL). ICF computes intra-cuboid flight paths for every
cuboid pairing first. For the remaining cuboids, it computes inter-
cuboid flight paths. It is motivated by the insight that computing
flight paths local to a cuboid minimizes distance.

ICL reverses the order of these two steps, computing inter-cuboid
flight paths first and intra-cuboid flight paths last. Its motivation
is that computing inter-cuboid flight paths first has the benefit of
more candidate FLSs in {𝛿 𝑗

𝑖 } and vacant destinations in {𝜇 𝑗

Both ICF and ICL implement Step 2 of Simple. Experimental
results of Section 3.2.8 show ICF is superior to ICL for the Rose
illumination. It executes faster and minimizes the total distance
travelled by FLSs.

𝑖+1}.

3.2.6 Parallelism. Motill variants may employ parallelism at differ-
ent granularity, using multi-core CPUs with minimal coordination.
First, they may process different GPCs that constitute a scene in
parallel. A challenge is how to fuse travel paths computed for two
consecutive GPCs, 𝜑1 and 𝜑2. A simple technique is to repeat the
last point cloud Ξ𝜔 of 𝜑1 as the first point cloud Ξ1 of 𝜑2. This
reduces the matching task to a simple 3D coordinate lookup of the
first point cloud Ξ1 of 𝜑2 using the coordinates of the last point
cloud Ξ𝜔 of 𝜑1. For each match, the travel path for an FLS in 𝜑1 is
concatenated with travel path from 𝜑2 after removing the redundant
path attributed to the repeated use of Ξ𝜔 of 𝜑1.

Second, Motill may populate the grids on Ξ2 to Ξ𝜔 in parallel,
using a different core for each point cloud. (Recall from Section 3.2.4
that the structure of these grids is a copy of Ξ1 grid.)

Third, Motill may compute intra-cuboid flight paths for the dif-
ferent cuboids in parallel. With hundreds of cuboids in a grid, Motill
may use hundreds of cores concurrently. Parallel processing of inter-
cuboid flight paths requires an extra pre-processing step to identify
those cuboids considered concurrently to not share neighbors.

8

Motill may use the concept of stragglers to enhance latency.
Given a thousand core processor, assuming certain cores are idle,
Motill may use these cores to execute a copy of tasks that are
taking too long to complete (consuming the result of the copy that
finishes first). Stragglers waste computing resources by performing
redundant work to enhance latency.

3.2.7 Motill and Simple. Motill with one cuboid emulates Simple.
We realize this by setting the capacity of a cuboid to a large number,
i.e., maximum integer value. This transforms the different variants
of Motill to employ simple for intra-cuboid mappings.

Motill is faster than Simple. When configured with a reasonable
number of cuboids for its grid, Motill also provides better flight
paths that minimize total travelled distance. We quantify this in the
next section.

3.2.8 A Comparison. This section compares Simple, ICF, and ICL
using the Rose illumination of Figure 1a. This comparison uses the
same software, an implementation of Motill, for all three techniques.
An input parameter of Motill switches the order of intra-cuboid
processing to be either first or last. We emulate Simple by setting
the capacity of Motill cuboids to the maximum integer value to
force it to construct one cuboid. We quantify both the execution
time of an algorithm and the total distance of its computed flight
paths. The actual execution of the flight paths by FLSs to render an
illumination and its latency is a part of our future work.

The reported execution times for Simple do not include the time
to construct Motill’s one cuboid grid. With ICF and ICL, the reported
execution times include the grid construction times.

All reported execution times were gathered from MATLAB R2022a
(9.12.0.1884502) running on a MacBook Pro configured with a 2.3
GHz 8-Core Intel i9 processor and 16 GB of memory. Its operating
system is macOS Big Sur Version 11.5.2. All the data was staged in
memory prior to gathering execution times, eliminating disk I/O
times. While obtained results are written to disk, this is performed
at the end after the experiment timing has stopped. Reported ex-
periments did not use parallelism.
Main lessons are as follows:

• ICF’s computed flight paths provide a shorter total flight
distance when compared with ICL. Its execution time is
faster for almost all point cloud pairings. In those few cases
that it is slower, the percentage difference is less than 4%.
See discussions of Figure 5b.

• Simple is slower than both ICF and ICL. With some point
clouds, ICF is 5.5 to 6x faster than Simple. See discussions of
Figures 5b and 6b.

• ICF provides comparable flight distances to Simple for most
but not all pairs of point clouds. See discussions of Figures 5a
and 6a.

• Motill’s cuboid size impacts its execution time and computed
flight distances. This is true with both ICF and ICL. See
discussions of Figure 6.

• With the Rose illumination, once FLSs are deployed using
either MinDist or QuotaBalanced, the flight paths computed
by the different techniques do not result in collisions. Hence,
no FLS collisions are reported.

computed flight distances are comparable if not better than Simple,
see Figure 6a.

In Figure 6, 𝜃 = 100 results in 987 cuboids. The portion of ex-
ecution time used by ICF is 18%. The rest of the time is spent
constructing and copying the grid. It is interesting to note that the
time to copy and populate the grid with point clouds 2 to 14 is
approximately the same as constructing the grid on point cloud 1.
In contrast, 𝜃 =1500 constructs 68 cuboids. Its time to construct
the grid on the first point cloud is twice the time to copy it on
the remaining point clouds. Both are approximately 6x faster than
𝜃 =100. The portion of execution time used by ICF increases to
approximately 75%.

A large cuboid size, 𝜃 =10,000, constructs only 10 cuboids. It
spends 90% of its time computing possible flight paths that it subse-
quently discarded.

Note that 𝜃 =10,000 computes competitive flight paths compara-
ble to those of 𝜃 =1,500 and is superior to Simple, see Figure 6a. It
also provides execution times that are at least 3x faster than simple,
see Figure 6b.

Simple is the extreme cuboid size, resulting in a grid with one
cuboid. Its execution time is the highest in Figure 6b. It does not
incur the overhead of constructing a grid. Instead, it wastes time and
resources by computing many FLS flight paths that are subsequently
deleted. See discussions of Section 3.2.2.

.

4 FLS FAILURE HANDLING
An FLS is a mechanical device that may fail. Its failure may degrade
the quality of a rendering by not illuminating one or more of its
points. There are several types of FLS failures: rotor failures, light
source failures, computing failures in the form of reboots, and
battery power failures. Assuming these failures are independent and
occur at a constant rate, one may compute the Mean Time To Failure
of an FLS (𝑀𝑇𝑇 𝐹 ) similar to how magnetic disk manufacturers
calculate the MTTF of disk drives [38]. The Mean Time to Degraded
Illumination (MTDI) is a linear function of the number of FLSs (𝛼)
that constitute an illumination: 𝑀𝑇 𝐷𝐼 =

𝑀𝑇𝑇 𝐹 𝑜 𝑓 1 𝐹 𝐿𝑆
𝛼

Assuming an FLS fails once a month (MTTF of 720 hours), the
MTDI of the Rose illumination with 𝛼=65,321 FLSs is 40 seconds.
This is disheartening if we want to scale to illuminations consisting
of millions of FLSs. Below, we describe a group parity/replication
technique to enhance MTDI of an illumination in the presence of
frequent FLS failures. We start by describing how FLSs cooperate
to detect failures. Subsequently, we describe grouping of FLSs with
a standby using data replication and parity techniques to improve
MTDI. We discuss group formation techniques and analyze MTDI
as a function of group size.
Failure detection: FLSs cooperate to detect failures and notify the
Orchestrator of the identity of the failed FLS. This cooperation is
in two forms. First, once an FLS detects its own failure, it uses its
networking to inform its neighbors and the Hub (Orchestrator) of
its failures. This applies to the first two forms of failures. With
light source failures, the FLS flies to a Terminus immediately as
it is no longer able to illuminate a point. With rotor failures, it
repels [28, 33, 51] FLSs in its downward descent by generating
frequent failed messages. Those FLSs that receive this message
move away to prevent the failed FLS from crashing into them. With

(a) Flight Distance.

(b) Execution Time.

Figure 5: ICL vs. ICF, cuboid size (𝜃 ) is 1500 points/FLSs.

(a) ICF Flight Distance.

(b) ICF Execution Time.

Figure 6: ICF with different cuboid size (𝜃 ) values.

• The point clouds that constitute the Rose illumination have
the same number of points (65,321). Hence, Simple and Motill
do not execute their Step 2.

ICF vs. ICL: Figure 5a shows the flight distance computed by ICL
and ICF. The x-axis identifies the point cloud in the Rose illumi-
nation. We used the 20𝑡ℎ point cloud to the 33𝑟𝑑 point cloud. The
y-axis shows the total distance of the flight paths computed by
different techniques to transition from rendering point cloud 𝑖 (say
20) to the next point cloud 𝑖 + 1 (21). All techniques compute the
same number of flight paths (2009) for each point cloud.

Figure 5 highlights several observations. First, ICF results in a
lower flight distance for all point clouds. Second, ICF is faster than
ICL for most but not all the point clouds, see Figure 5b. It is slightly
(<4%) slower than ICL for the 33rd point cloud. Third, the point
cloud data impacts FLS flight distances and Motill execution times
significantly. It is interesting to note that the flight distance of ICF
increases linearly with the first 14 point clouds, see Figure 6a. And,
the total distance for each of these points is lower than that of point
clouds 20-26 of Figure 5. The y-axis scale is different for Figures 5a
and 6a.
Cuboid size: The cuboid size impacts Motill’s execution time and
computed flight distances, see Figure 6. It dictates the structure
of the grid and the number of cuboids that constitute it. A small
cuboid size results in a large number of cuboids and slow execution
times. A large cuboid size is also undesirable because it results in a
few cuboids and starts to approximate Simple. It computes many
combinations of possible flight paths only to select one.

Figure 6 highlights this using ICF with the 1𝑠𝑡 to 14𝑡ℎ point clouds
of the Rose illumination. We report on cuboid sizes 100, 1500, 10K,
and max integer (1 cuboid). (The latter is Simple.) Cuboid size 1500
provides the fastest execution times, see Figure 6b. Moreover, its

9

the architecture of Figure 2, the failed FLS falls on the conveyor
belt of the garbage collector and is deposited into a Terminus.

Second, FLSs exchange periodic heartbeat messages [42, 49] with
their neighbors in the display mesh to detect processor and battery
failures. An FLS that encounters these forms of failures may not
be able to notify other FLSs of its failure. Hence, FLSs cooperate to
detect these failed FLSs. If an FLS does not receive an anticipated
heart beat message from one of its neighbors then it polls the
neighbor. After a few failed attempts, it identifies the neighbor as
having failed and communicates the identity of this failed FLS to
its neighbors and the Hub (Orchestrator).
Parity and replication groups: To maintain the quality of an illu-
mination, a failed FLS must be replaced with a new one quickly.
The system must restore both the physical FLS and the data that
describes its flight path and lighting responsibilities. We assume
this data is stored on the local storage of each FLS.

We use standby FLSs to recover from FLS failures. In normal
mode, standby FLSs are dark. After the discovery of a failed FLS,
the standby assumes the lighting responsibilities and flight paths
of the failed FLS. This occurs concurrently with the Orchestrator
deploying a replacement FLS to substitute for the standby.

We use parity and replication techniques to maintain the data of
a failed FLS available. These techniques assign 𝐺 FLSs in close prox-
imity of one another to a group and assigns one or more standbys
to each group. The minimum value of 𝐺 is one, requiring a standby
for every FLS that is illuminating a point. This standby has a copy of
the data assigned to its paired FLS and mirrors its flight paths. If an
FLS fails, its standby resumes its lighting and flight responsibilities
immediately using its local copy of the data. A challenge of 𝐺=1 is
how to prevent the standbys from obstructing the user’s field of
view (FoV).

With 𝐺 > 1, replication requires the standby FLS to maintain
a copy of the data assigned to each FLS in its group. A parity
technique requires the standby to compute the parity (xor) of the
data assigned to the 𝐺 FLSs in the group.

Parity techniques are more space efficient than replication tech-
niques. However, a parity technique requires the standby to fetch
data from the remaining 𝐺 −1 FLSs and use this data in combination
with its parity data to compute the missing data of a failed FLS.
With more than 1 failure in a group, the standby must wait for the
Orchestrator dispatched FLSs to arrive with their data before it is
able to compute the missing data. With replication, the standby
may select a failed FLS and use the copy of its data to substitute for
the failed FLS.
Group construction: The 𝐺 FLSs in a group should be in close prox-
imity of one another. This minimizes the distance travelled (time)
by a standby to substitute for a failed FLS in the group. If the group
is using a parity scheme, close proximity facilitates local communi-
cation for the standby to obtain data from the remaining FLSs to
compute the failed FLS’s flight path and lighting responsibilities.

FLS group construction is a weighted matching problem [27, 58].
There exists centralized [15, 39], distributed [25], and decentral-
ized [13] algorithms for this problem. With static illuminations,
one may adapt these for use by the Orchestrator, multiple dispatch-
ers, and millions of FLSs, respectively. This is a short-term future
research direction.

Table 3: Reliability Groups enhance MTDI of the Rose illu-
mination from 40 seconds to more than a month.

G=10

G=20

Total Number of FLSs
Overhead Cost
MTDI Hours (Days)

71,853 (1.1𝛼)
10%
2670 (111)

68,588 (1.05𝛼)
5%
1399 (58)

With motion illuminations, the position of some FLSs will change
from one point cloud to the next. This may change the distance
between FLSs that constitute a group. The FLSs may re-construct
the groups using decentralized [13] algorithm. This may require
re-assignment of standbys. With a parity technique, an impacted
standby must re-compute its parity information for the new group.
With replication, the standby must delete flight paths and lighting
pattern of FLSs that it is no longer responsible for and obtain a
copy of the flight paths and lighting patterns of the new FLSs that
it may substitute for. To minimize the amount of exchanged data,
a display may relax the value of 𝐺 for evolving groups, allowing
some groups to consist of more than 𝐺 FLSs and others to consist
of fewer than 𝐺 FLSs.

Another approach is to maintain the same FLS membership
for the group and require the standby to adjust its position to
approximate the same distance to the different FLSs that constitute
the group. If the FLS reliability is heterogeneous, the standby may
position itself closer to those FLSs with a higher failure probability.
Yet another possibility is to remove the constraint that each FLS
must belong to a group. This enables an FLS to leave a group, pro-
vide its illumination for a few point clouds without being a part
of a group, and possibly join another group. Once it joins a group,
the standby of the impacted groups must adjust its membership
information and replicated/parity data. An FLS crucial to the illu-
mination may be provided with a mirror standby. An investigation
of these possibilities is a future research direction.
MTDI with different group sizes: We adapt the models of [38] to es-
tablish the MTDI of an illumination as a function of group size using
a parity technique. MTTF of a group is 𝑀𝑇𝑇 𝐹𝐺𝑟𝑜𝑢𝑝 = 𝑀𝑇𝑇 𝐹𝐹 𝐿𝑆
×
1
𝑃 , where 𝑃 is the probability of another FLS failure in a group
before restoring the group to normal mode of operation, 𝑃 =
𝑀𝑇𝑇 𝑅
. MTTR is the Mean Time To Repair a group with a
𝑀𝑇𝑇 𝐹𝐹 𝐿𝑆 /(𝐺+1)
failed FLS to normal mode of operation. It is the amount of time
elapsed from when an FLS fails to the time the group is restored
to normal mode of operation with a replacement FLS. The Mean
Time to Degraded Illumination is: 𝑀𝑇 𝐷𝐼 =
where 𝛼
is the number of FLSs to render an illumination.

𝐺×𝑀𝑇𝑇 𝐹𝐺𝑟𝑜𝑢𝑝
𝛼

𝐺+1

Table 3 shows MTDI of the Rose illumination assuming an FLS
fails once a month and the system’s MTTR is 1 second. Reliability
groups enhance MTDI from 40 seconds to almost two months with
20 FLSs in a group, 𝐺=20. This is enhanced almost two folds (to
111 days) with 10 FLSs per group, 𝐺=10. With 𝐺=10, the Rose
illumination requires approximately 6,400 additional FLSs.

10

5 STAGGERED BATTERY CHARGING, STAG
STAG is a novel algorithm that staggers charging of FLS batteries as
a function of time to minimize both the number of charging stations
and the overall number of FLSs required to render an illumination.
STAG makes several assumptions. First, each FLS has a battery
that provides a finite flight time 𝛽 when fully charged. Second,
Ω time units are required to fully charge a depleted battery with
minimal or no remaining flight time left. Third, the time to charge
an FLS battery, 𝜆, is a linear function of 𝛽 and its remaining flight
time 𝑟 , 𝜆= Ω∗𝑟
𝛽

.

An FLS computes the amount of battery flight time required for
it to fly to a charging station using its distance to the charging
station. Once its battery flight time reaches this threshold, the FLS
will go dark and fly to the charging station.

A standby FLS (see Section 4) will substitute for this FLS to
perform its lighting responsibility while a dispatcher will deploy
an FLS with 𝛽 flight time to substitute for the standby.

It is important to minimize the window of time Δ for a battery
depleted FLS𝑑 to switch places with a fully charged FLS𝑐 . Should
an FLS belonging to the parity group of FLS𝑑 fail during Δ, this
may result in loss of information and a degraded illumination.

Preliminaries: Consider an illumination with 𝛼 FLSs and assume
the time to charge the battery of each FLS equals its flight time on
a fully charged battery, Ω = 𝛽. A naive algorithm may deploy all
𝛼 FLSs at one instance in time. After 𝛽 time units, all FLSs must
fly back to a charging station while the dispatchers deploy 𝛼 fully
charged FLSs. Naive repeats this process every 𝛽 time units while
rendering the illumination.

Naive has several limitations. First, it requires 2𝛼 FLSs to render
an illumination: 𝛼 FLSs charge while 𝛼 FLSs render the illumination.
Second, there is an exchange step when fully changed FLSs and
fully depleted FLSs switch places. The illumination may become
distorted during this period because almost all FLSs that constitute
an illumination may go dark in order to switch places with fully
charged FLSs. Moreover, the algorithm that manages FLSs during
this period has a high complexity as it must manage flight patterns
of 2𝛼 FLSs.

STAG staggers FLSs as a function of time to prevent them from
exhausting their finite flight time at the same time. It overlaps
charging of some FLSs with others that are rendering an illumina-
tion, eliminating Naive’s exchange step. In its steady state, STAG
switches a fully charged FLS with a fully depleted FLS continuously.
Details of STAG are as follows.

STAG constructs ℎ flocks of FLSs. A flock 𝑖 consists of 𝛼𝑖 FLSs.
Within a flock 𝑖, STAG staggers its 𝛼𝑖 FLSs such that their remaining
battery flight time ranges from 𝛽 down to the staggering interval S,
S= 𝛽
. Assuming the FLSs in a flock are numbered from 1 to 𝛼𝑖 , the
𝛼𝑖
. Thus, FLS 𝑗 = 𝛼𝑖 has

remaining flight time of FLS 𝑗 is 𝛽 ( 𝑗) =
a fully charged battery with 𝛽 flight time.

𝑗∗𝛽
𝛼𝑖

The number of FLSs charging (or staged in a hangar) to substitute
for an FLS of Flock 𝑖 is ⌈ Ω
𝑆 ⌉. This is the extra number of FLSs
required by a flock to render an illumination. The total number of
FLSs that are charging (or staged in a hangar) is ℎ × ⌈ Ω

𝑆 ⌉.

Theorem 1. STAG minimizes the number of additional FLSs re-

quired to render an illumination.

11

Proof. An FLS spends 𝛽 time units rendering an illumination
and Ω time units charging. The fraction of time an FLS spends
. The minimum number of FLSs, Ψ, to render
illuminating is
an illumination consisting of 𝛼 FLSs must satisfy the following
equality:

Ψ = 𝛼. Solving for Ψ, one obtains:

𝛽
Ω+𝛽

𝛽
Ω+𝛽

Ψ = 𝛼 + 𝛼

Ω
𝛽

(1)

additional FLSs are required to render the

Thus, a minimum of 𝛼 Ω
𝛽
illumination.

STAG requires Ω

of S, 𝛽
𝛼 , in this equation produces 𝛼 Ω
𝛽
number of additional FLSs in Equation 1.

𝑆 additional FLSs. Substituting the definition
. This equals the minimum
■

Example 5.1. Consider an illumination consisting of 5 FLSs, 𝛼=5.
These FLSs are assigned to 1 flock, ℎ=1. The time to charge an empty
FLS battery is 3 minutes and each FLS provides 15 minutes of flight
time on a fully charged battery, Ω=3 and 𝛽 = 15. STAG interleaves
the charging of the 5 FLSs such that each FLS is staggered S=3 minutes
𝛽=15
𝛼=5 . The extra number of FLSs is 2, ⌈ Ω=5
𝑆=3 ⌉.
of flight time apart, S=
While 2 FLSs are charging, 5 FLSs render the illumination. Every
3 minutes, the Orchestrator deploys a fully charged FLS to render
the illumination. It replaces an FLS with an almost depleted battery
that returns to a charging station to be charged. This FLS spends 3
minutes in a charging station. Subsequently, the Orchestrator deploys
it to substitute for another FLS in the flock with an almost depleted
battery.■

The number of FLSs in transit from a charging station to an
illumination is 2ℎ. In Example 5.1 with ℎ = 1, there are 2 FLSs in
transit. One flying from the illumination to a charging station and a
second from a charging station to the illumination. A display must
ensure these FLSs are not in the user’s field of view.

Given a swarm, reducing its number of flocks to one, ℎ=1, mini-
mizes the number of FLSs in transit. This reduces the likelihood of
a dark FLS from obstructing the user’s field of view.

However, the number of flocks is dictated by the maximum time
required for an FLS to fly back to the charging station, 𝑆𝑡ℎ𝑟𝑒𝑠ℎ𝑜𝑙𝑑 ,
and the number of FLSs required by an illumination 𝛼. With an
illumination that consists of a large number of FLSs, maintaining
ℎ = 1 results in a small staggering interval S (because S is a function
of the number of FLSs in a flock). 𝑆𝑡ℎ𝑟𝑒𝑠ℎ𝑜𝑙𝑑 dictates the number of
FLSs in a flock (𝛼𝑖 =
) which in turns dictates the number
of flocks, ℎ = ⌈ 𝛼
⌉.
𝛼𝑖

𝛽
𝑆𝑡ℎ𝑟𝑒𝑠ℎ𝑜𝑙𝑑

Flocks that constitute an illumination may use different stagger-
ing intervals 𝑆 and consists of a different number of FLSs 𝛼𝑖 . This
is highlighted by the analysis of Section 5.3.

5.1 Flock Formation
With STAG, flocks are logical. Unlike the reliability groups of Sec-
tion 4, there is no constraint on them to be in close proximity of one
another. Each FLS requires a flock id 𝑖 and a logical number (termed
stag-id) within that flock ranging from 1 to 𝛼𝑖 , 1 ≤stag-id≤ 𝛼𝑖 .

The Orchastrator may compute the number of flocks and the
quota 𝛼𝑖 for each flock. It assigns flock ids to different dispatchers
that deploy FLSs. As a dispatcher deploys an FLS, it assigns a flock

id and stag-id (a simple counter) to each FLS until the quota of
the flock is exhausted, i.e., stag-id equals 𝛼𝑖 of flock 𝑖. There will
most likely be scenarios where multiple dispatchers are required to
deploy FLSs of a single flock. In this case, the Orchestrator assigns
a unique range of stag-id values to each participating dispatcher.

5.2 Staggering FLSs
A display that initiates an illumination for the first time may have its
FLSs with flight times that are not staggered. How does the display
stagger FLS flight times S time units apart given some initial flight
time for its FLSs? This section answers this question assuming
initial flight time of 𝛽, i.e., all FLSs have fully charged batteries.
One approach is to deploy FLSs of a flock every 𝑆 time units. A
limitation of this approach is that it introduces a delay of (𝛼𝑖 −1) ×𝑆
to render an illumination. The delay is 12 minutes with the small
scenario of Example 5.1. This delay may become unacceptable with
large values of 𝛼𝑖 and 𝑆. With the 65,321 FLSs required by the Rose
illumination, assuming 𝑆 is 1 second, the delay is more than 18
hours.

We now present a decentralized and efficient technique to stagger
FLSs. This technique deploys 𝛼𝑖 FLSs that constitute a flock as fast
as possible to render an illumination quickly. Each 𝛼𝑖 FLS is notified
that this is the first time it is being deployed. This causes FLS 𝑗
to fly back to a charging station after rendering the illumination
for 𝑗 × 𝑆 time units, 𝑗 is the stag-id assigned to an FLS in a flock,
1 ≤ 𝑗 ≤ 𝛼𝑖 . FLS 𝑗 is replaced by another FLS with a fully charged
battery that is no longer identified as being deployed for the first
time. This FLS performs flight and lighting responsibilities of FLS 𝑗
for the entire 𝛽 time units per earlier description of STAG.

In essence, this technique requires 𝛼𝑖 − 1 FLSs deployed for the
very first time to fly back to a charging station with partially full
batteries to charge fully. By controlling the remaining battery life
time of these FLSs prior to their flight back, this technique staggers
flight time of FLSs in a flock to be 𝑆 time units apart.

In Example 5.1, STAG deploys all 𝛼𝑖 =5 FLSs as fast as possible. For
their first deployment, FLSs 1, 2, 3, 4, and 5 fly back after rendering
the illumination for 3, 6, 9, 12, and 15 time units, respectively. This
is because the staggering interval is 3 time units, 𝑆 = 3. STAG
requires 7 FLS for this illumination, 2 charge while 5 render the
illumination. The 2 extra FLSs are in a hangar because they are fully
charged. FLSs 1 and 2 are replaced by these two FLSs. FLSs 3 and 4
are replaced by FLSs 1 and 2 with fully7 charged batteries. For the
remainder of the illumination time, FLSs are staggered 𝑆 = 3 time
units apart.

5.3 An Analysis
Table 4 quantifies the behavior of STAG with different 𝛽 and Ω
values. The first column pertains to the flight time and battery
charge time of today’s Sky Viper Dash Nano Drone8. The other two
columns correspond to future generations of such a device with

7We assume the time to charge a battery is a linear function of its remaining
flight time. FLS 1 is fully charged after 3 time units while FLS 2 is fully charged after 6
time units. This overlaps with the time FLSs 3 and 4 are rendering the illumination,
enabling batteries of FLSs 1 and 2 to become fully charged.

8Approximate cost of $17, length=2 inches, width=2.5 inches, height=0.75 inches,

weigth=7 ounces.

12

Table 4: STAG with the Rose illumination.

𝛽=5 min
Ω=10 min

𝛽=10 min
Ω=5 min

𝛽=20 min
Ω=2.5 min

ℎ, number of flocks
𝛼𝑖 , FLSs/Flock
Extra FLSs per Flock

FLSs for the last Flock
S for the last flock (Millisec)
Extra FLSs for the last flock

218
300
600

221
1358
442

Extra FLSs for the illumination
Overhead Cost
Total Number of FLSs

130642
200%
195,963

109
600
300

521
1152
261

32661
50%
97,982

55
1200
150

521
2303
65.125

8166
12.5%
73,487

flight time on a fully charged battery (𝛽) doubling and the time to
charge (Ω) its battery is halved.

We set the lower bound on 𝑆 to 1 second. It limits the number of
FLSs in a flock, 𝛼𝑖 , shown in the 2nd row of Table 4. The number of
FLSs that constitute the Rose illumination (𝛼=65,321) is not an even
multiple of 𝛼𝑖 . Hence, the middle 3 rows show the characteristics
of the last flock that has the remaining FLSs. Note that its value of
𝑆 is higher than 1 second (1000 millisec) because it has fewer FLSs.
The characteristics of today’s Sky Viper battery increases the
number of FLSs to render the Rose illumination 3 folds. This is a
200% overhead. This overhead decreases linearly as we enhance
battery characteristics, see the 2nd to last row of Table 4. With
an 8 fold overall improvement in battery characteristics (4 fold
enhancement of 𝛽 and 4 fold reduction of Ω), STAG’s overhead
decreases to 12.5%.

6 RELATED WORK
FLS displays render virtual objects in a physical volume. They
are in the same class of systems as physical artifacts [52] using
programmable matter consisting of catoms [22], roboxels as cellular
robots that dynamically configure themselves into the desired shape
and size [34], fast 3D printing [16], and BitDrones as interactive
nano-quadcopter [23]. These studies describe 3D displays. However,
they do not present algorithms to render 3D illuminations.

FLS displays are inspired by today’s indoor and outdoor drone
shows that use illuminated, synchronized, and choreographed groups
of drones arranged into various aerial formations. An FLS display
is similar because each FLS is a drone and a motion illumination is
rendered by computing FLS flight paths that synchronize FLSs as a
function of time and space.

Assignment of points to dispatchers (Section 3.1) and Step 1 of
Simple that matches {𝛿𝑖 } points to {𝜇𝑖+1} points (Section 3.2.1) are
centralized heuristics for euclidean matching [15]. Both strive to
solve a weighted matching problem [27, 58]. There exists central-
ized [15, 39], distributed [25], and decentralized [13] algorithms
for this problem. MinDist is centralized and similar to the greedy
heuristics of [31, 43]. QuotaBalanced is a novel greedy heuristic
that balances the load of deploying FLSs across dispatchers.

A centralized, offline algorithm to compute a flight/lighting plan
for outdoor light show performances is presented in [50]. This
algorithm requires drones to be placed in a field and in a specific

arrangement. It computes collision free paths for 500 drones to
display different images in sequence, e.g., a ballerina followed by a
guitar. It may be modified for use by the Orchestrator to compute
flight paths for point clouds that transition one scene to the next.
Motill is different because it is designed for a scene where changes
from one point cloud to the next is not anticipated to be drastic.

There are many path planning algorithms for robots and UAVs [5,
7–12, 17, 18, 24, 28, 29, 32, 36, 37, 40, 41, 48, 51, 53–57, 59]. They
address the challenge of moving from a given initial position to a
set of predefined targets while avoiding collisions with obstacles as
well as other UAVs. Most relevant are studies that avoid UAV (robot)
collision using an artificial potential field (APF) that defines a safety
radius around the drone [28, 29, 51]. With APF, the UAV (robot)
moves to its target point guided by attractive force and repulsive
forces. These techniques are applicable to FLSs that execute the
flight paths computed by Motill to render a motion illumination.
Our techniques have the added advantage that an FLS is informed of
a potential conflict and FLSs may communicate to avoid a collision.
In [28], a modified version of APF is used to identify a failing (rogue)
drone. An FLS display may use this technique to detect a failed FLS.
FLSs are network enabled and the failure detection techniques
described in Section 4 are inspired by those used in peer-to-peer
networks, e.g., CAN [42], Chord [49]. Formation of FLS groups
and use of standbys to tolerate failures is similar to disk striping
techniques [38, 44] in-use by the disk manufacturers. An interesting
dimension introduced by FLSs is their flight paths that may change
their memberships in groups.

7 FUTURE WORK
We are extending FLS displays in several exciting directions. First,
we are developing a positioning system for the FLSs to compute
their location in a display. Such a positioning system is essential to
enable FLSs to execute the flight paths computed by QuotaBalanced
and Motill to render an illumination.

Second, we are evaluating offline algorithms to form reliability
groups using the computed FLS flight paths. The offline algorithms
compute membership of the mobile FLSs in a reliability group and
provide this information for use by FLSs when rendering the illumi-
nation. Their tradeoffs may involve metrics such as cost, traveled
distance, consumed energy, amount of exchanged data, and MTDI.
Third, we are investigating the use of physics engines, e.g.,
Gazebo [3, 30] and AirSim [45] among others, to simulate the flight
paths computed by ICF. These simulation studies will implement
the alternative collision avoidance techniques and quantify their
tradeoffs. They are the first step towards an implementation of an
FLS display and its architecture.

Fourth, with Motill, STAG and our reliability techniques, it is
important to keep dark FLSs out of the user’s field of view. An
interesting question is the impact of the dark FLSs on the quality of
an illumination perceived by a user. This requires human studies
using a prototype for different applications.

Fifth, a display may consist of heterogeneous FLSs with vary-
ing reliability, flight times on a fully charged battery, and time to
fully charge their battery. Both the reliability models and STAG
are designed for FLSs with homogeneous characteristics. These
algorithms must be extended to support heterogeneous FLSs.

13

Finally, a swarm of FLSs may implement encounter-type haptic
interactions [35] by generating force back against a user touch [1, 2,
6, 21, 26]. This will enable a user to see virtual objects as illumina-
tions without wearing glasses and to touch them without wearing
gloves [19]. These concepts will facilitate immersive and interactive
3D displays depicted in science fiction shows, Star Trek’s holodeck.
We are developing algorithms for a swarm of FLSs to detect the
location of user touch, quantify the amount of exerted force, and
generate the kinesthetic sensation (“muscle sense” of contacting
objects with mass) for a user. User safety and trust are paramount
and we intend to address them from the start [21].

8 ACKNOWLEDGMENTS
We thank Hamed Alimohammadzadeh for generating the Rose
illumination and his drawings. We are grateful to the anonymous
reviewers of the ACM Multimedia 2022 for their valuable comments.

REFERENCES
[1] Muhammad Abdullah, Minji Kim, Waseem Hassan, Yoshihiro Kuroda, and
Seokhee Jeon. 2018. HapticDrone: An Encountered-type Kinesthetic Haptic
Interface with Controllable Force Feedback: Example of Stiffness and Weight
Rendering. In 2018 IEEE Haptics Symposium, HAPTICS 2018, San Francisco, CA,
USA, March 25-28, 2018, Katherine J. Kuchenbecker, Gregory J. Gerling, and Yon
Visell (Eds.). IEEE, USA, 334–339. https://doi.org/10.1109/HAPTICS.2018.8357197
[2] Parastoo Abtahi, Benoit Landry, Jackie (Junrui) Yang, Marco Pavone, Sean Follmer,
and James A. Landay. 2019. Beyond the Force: Using Quadcopters to Appropriate
Objects and the Environment for Haptics in Virtual Reality. In Proceedings of the
2019 CHI Conference on Human Factors in Computing Systems, CHI 2019, Glasgow,
Scotland, UK, May 04-09, 2019. ACM, New York, NY, USA, 1–13.

[3] C.E. Aguero, N. Koenig, I. Chen, H. Boyer, S. Peters, J. Hsu, B. Gerkey, S. Paepcke,
J.L. Rivero, J. Manzo, E. Krotkov, and G. Pratt. 2015. Inside the Virtual Robotics
Challenge: Simulating Real-Time Robotic Disaster Response. Automation Science
and Engineering, IEEE Transactions on 12, 2 (April 2015), 494–506. https://doi.
org/10.1109/TASE.2014.2368997

[4] Yousef Alghamdi, Arslan Munir, and Hung Manh La. 2021. Architecture, Classifi-
cation, and Applications of Contemporary Unmanned Aerial Vehicles. IEEE Con-
sumer Electron. Mag. 10, 6 (2021), 9–20. https://doi.org/10.1109/MCE.2021.3063945
[5] Senthil Hariharan Arul and D. Manocha. 2020. DCAD: Decentralized Collision
Avoidance With Dynamics Constraints for Agile Quadrotor Swarms. IEEE Ro-
botics and Automation Letters 5 (2020), 1191–1198. https://doi.org/10.1109/LRA.
2020.2967281

[6] Jonas Auda, Nils Verheyen, Sven Mayer, and Stefan Schneegass. 2021. Flyables:
Haptic Input Devices for Virtual Realityusing Quadcopters. In ACM Symposium
on Virtual Reality Software and Technology. ACM, New York, NY, USA, 1–11.
[7] Federico Augugliaro, Angela Schoellig, and Raffaello D’Andrea. 2012. Generation
of Collision-Free Trajectories for a Quadrocopter Fleet: A Sequential Convex
Programming Approach. In Proceedings of the IEEE/RSJ International Conference
on Intelligent Robots and Systems. IEEE, USA, 1917–1922. https://doi.org/10.1109/
IROS.2012.6385823

[8] Daman Bareiss and Joran van den Berg. 2013. Reciprocal Collision Avoidance
for Robots with Linear Dynamics using LQR-Obstacles. In Proceedings - IEEE
International Conference on Robotics and Automation. IEEE, USA, 3847–3853.
https://doi.org/10.1109/ICRA.2013.6631118

[9] Tomáš Báča, Daniel Hert, Giuseppe Loianno, Martin Saska, and Vijay Kumar.
2018. Model Predictive Trajectory Tracking and Collision Avoidance for Reliable
Outdoor Deployment of Unmanned Aerial Vehicles. In IEEE/RSJ International
Conference on Intelligent Robots and Systems (IROS). 6753–6760. https://doi.org/
10.1109/IROS.2018.8594266

[10] D. Cappello, S. Garcin, Z. Mao, M. Sassano, A. Paranjape, and T. Mylvaganam.
2020. A Hybrid Controller for Multi-Agent Collision Avoidance via a Differential
Game Formulation. IEEE Transactions on Control Systems Technology PP (07 2020),
1–8. https://doi.org/10.1109/TCST.2020.3005602

[11] Yu Fan Chen, Mark Cutler, and Jonathan How. 2015. Decoupled Multiagent Path
Planning via Incremental Sequential Convex Programming. Proceedings - IEEE
International Conference on Robotics and Automation 2015 (06 2015), 5954–5961.
https://doi.org/10.1109/ICRA.2015.7140034

[12] Hui Cheng, Q. Zhu, Z. Liu, Tianye Xu, and Liang Lin. 2017. Decentralized
Navigation of Multiple Agents Based on ORCA and Model Predictive Control.
2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)
(2017), 3446–3451. https://doi.org/10.1109/IROS.2017.8206184

[13] Anna Chmielowiec, Spyros Voulgaris, and Maarten van Steen. 2014. Decentralized
Group Formation. Journal of Internet Services and Applications 5, 1 (2014). https:
//doi.org/10.1186/s13174-014-0012-2

[14] Soon-Jo Chung, A. Paranjape, P. Dames, S. Shen, and Vijay R. Kumar. 2018.
A Survey on Aerial Swarm Robotics. IEEE Transactions on Robotics 34 (2018),
837–855.

[15] Avis David. 1983. A Survey of Heuristics for the Weighted Matching Problem.

Networks 13 (1983), 475–493.
[16] Joseph DeSimone. Onstage

at TED2015.

See https://www.ted.com/

talks/joseph_desimone_what_3d_printing_was_100x_faster?language=en#t-
20146. What if 3D Printing was 100x Faster?

[17] T. Engelhardt, T. Konrad, Bjorn E. Schafer, and D. Abel. 2016. Flatness-Based
Control for a Quadrotor Camera Helicopter using Model Predictive Control
Trajectory Generation. 24th Mediterranean Conference on Control and Automation
(MED) (2016), 852–859.

[18] Eduardo Ferrera, Alfonso Alcántara, J. Capitán, Á. R. Castaño, P. Marrón, and A.
Ollero. 2018. Decentralized 3D Collision Avoidance for Multiple UAVs in Outdoor
Environments. Sensors (Basel, Switzerland) 18 (2018).

[19] Shahram Ghandeharizadeh. 2021. Holodeck: Immersive 3D Displays Using
Swarms of Flying Light Specks. In ACM Multimedia Asia (Gold Coast, Australia).
ACM, New York, NY, USA, 1–7. https://doi.org/10.1145/3469877.3493698
[20] Shahram Ghandeharizadeh. 2022. Display of 3D Illuminations using Flying
Light Specks. In ACM Multimedia (Lisboa, Portugal). ACM, New York, NY, USA.
https://doi.org/10.1145/3503161.3548250

[21] Shahram Ghandeharizadeh and Luis Garcia. 2022. Safety in the Emerging
Holodeck Applications. In CHI 2022 Workshop on Novel Challenges of Safety,
Security and Privacy in Extended Reality.

[22] S.C. Goldstein, J.D. Campbell, and T.C. Mowry. 2005. Programmable Matter.

Computer 38, 6 (2005), 99–101. https://doi.org/10.1109/MC.2005.198

[23] Antonio Gomes, Calvin Rubens, Sean Braley, and Roel Vertegaal. 2016. Bit-
Drones: Towards Using 3D Nanocopter Displays as Interactive Self-Levitating
Programmable Matter. In Proc. ACM CHI Conference on Human Factors in Com-
puting Systems. ACM, New York, NY, USA, 770–780.

[24] Michael Hamer, Lino Widmer, and Raffaello Drandrea. 2018. Fast Generation
of Collision-Free Trajectories for Robot Swarms Using GPU Acceleration. IEEE
Access PP (12 2018), 1–1. https://doi.org/10.1109/ACCESS.2018.2889533
[25] Jaap-Henk Hoepman. 2004. Simple Distributed Weighted Matchings. CoRR

cs.DC/0410047 (2004). http://arxiv.org/abs/cs.DC/0410047

[26] Matthias Hoppe, Pascal Knierim, Thomas Kosch, Markus Funk, Lauren Futami,
Stefan Schneegass, Niels Henze, Albrecht Schmidt, and Tonja Machulla. 2018.
VRHapticDrones: Providing Haptics in Virtual Reality through Quadcopters.
In Proceedings of the 17th International Conference on Mobile and Ubiquitous
Multimedia, Cairo, Egypt, November 25-28, 2018, Slim Abdennadher and Florian Alt
(Eds.). ACM, New York, NY, USA, 7–18. https://doi.org/10.1145/3282894.3282898
[27] Edmonds Jack. 1965. Paths, Trees, and Flowers. Canada Journal of Math. 17

(1965), 449–467.

[28] Ravinder Kumar Jyoti, Mohit Kumar Malhotra, and Debasish Ghose. 2021. Rogue
Agent Identification and Collision Avoidance in Formation Flights using Potential
Fields. In 2021 International Conference on Unmanned Aircraft Systems (ICUAS).
IEEE, USA, 1080–1088. https://doi.org/10.1109/ICUAS51884.2021.9476866
[29] Oussama Khatib. 1985. Real-Time Obstacle Avoidance for Manipulators and
Mobile Robots. In IEEE International Conference on Robotics and Automation,
Vol. 2. IEEE, USA, 500–505. https://doi.org/10.1109/ROBOT.1985.1087247
[30] Nathan Koenig and Andrew Howard. 2004. Design and Use Paradigms for Gazebo,
An Open-Source Multi-Robot Simulator. In IEEE/RSJ International Conference on
Intelligent Robots and Systems. Sendai, Japan, 2149–2154.

[31] Jerome M. Kurtzberg. 1962. On Approximation Methods for the Assignment
Problem. J. ACM 9, 4 (oct 1962), 419–439. https://doi.org/10.1145/321138.321140
[32] Alex Kushleyev, Daniel Mellinger, Caitlin Powers, and Vijay Kumar. 2013. To-
wards a Swarm of Agile Micro Quadrotors. Autonomous Robots 35 (11 2013),
573–7527. https://doi.org/10.1007/s10514-013-9349-9

[33] Emmett Lalish. 2009. Distributed Reactive Collision Avoidance, Ph.D. Disertation,

University of Washington.

[34] William A. McNeely. 1993. Robotic Graphics: A New Approach to Force Feedback
for Virtual Reality. In Proceedings of IEEE Virtual Reality Annual International
Symposium. IEEE, USA, 336–341. https://doi.org/10.1109/VRAIS.1993.380761

[35] Victor Rodrigo Mercado, Maud Marchal, and Anatole Lecuyer. 2021. Haptics
On-Demand: A Survey on Encountered-Type Haptic Displays. IEEE Transactions
on Haptics 14, 3 (2021), 449–464.

[36] Daniel Morgan, Soon-Jo Chung, and Fred Y. Hadaegh. 2014. Model Predictive
Control of Swarms of Spacecraft Using Sequential Convex Programming. Journal
of Guidance, Control, and Dynamics 37, 6 (2014), 1725–1740. https://doi.org/10.
2514/1.G000218

[37] Thulasi Mylvaganam, Mario Sassano, and Alessandro Astolfi. 2017. A Differential
IEEE Trans. Automat.

Game Approach to Multi-Agent Collision Avoidance.
Control PP (04 2017), 4229–4235. https://doi.org/10.1109/TAC.2017.2680602

14

[38] David A. Patterson, Garth Gibson, and Randy H. Katz. 1988. A Case for Redundant
Arrays of Inexpensive Disks (RAID). In Proceedings of the 1988 ACM SIGMOD
(Chicago, Illinois, USA). Association for Computing Machinery, New York, NY,
USA, 109–116. https://doi.org/10.1145/50202.50214

[39] Robert Preis. 1999. Linear Time 1/2-Approximation Algorithm for Maximum
Weighted Matching in General Graphs. In STACS 99, 16th Annual Symposium on
Theoretical Aspects of Computer Science, Trier, Germany, March 4-6, 1999, Proceed-
ings (Lecture Notes in Computer Science, Vol. 1563), Christoph Meinel and Sophie
Tison (Eds.). Springer, Berlin, Heidelberg, 259–269. https://doi.org/10.1007/3-
540-49116-3_24

[40] James Preiss, Wolfgang Hoenig, Nora Ayanian, and Gaurav Sukhatme. 2017.
Downwash-Aware Trajectory Planning for Large Quadcopter Teams. IEEE/RSJ
International Conference on Intelligent Robots and Systems (IROS) (04 2017), 8.
[41] James Preiss, Wolfgang Honig, Gaurav Sukhatme, and Nora Ayanian. 2017.
Crazyswarm: A Large Nano-Quadcopter Swarm. In IEEE International Conference
on Robotics and Automation (ICRA). IEEE, 3299–3304. https://doi.org/10.1109/
ICRA.2017.7989376

[42] Sylvia Ratnasamy, Paul Francis, Mark Handley, Richard Karp, and Scott Shenker.
2001. A Scalable Content-Addressable Network. SIGCOMM Comput. Commun.
Rev. 31, 4 (Aug. 2001), 161–172. https://doi.org/10.1145/964723.383072

[43] Edward M. Reingold and Robert E. Tarjan. 1981. On a Greedy Heuristic for
Complete Matching. SIAM J. Comput. 10, 4 (1981), 676–681. https://doi.org/10.
1137/0210050 arXiv:https://doi.org/10.1137/0210050

[44] Kenneth Salem and Hector Garcia-Molina. 1986. Disk Striping. In Proceedings of
the Second International Conference on Data Engineering, February 5-7, 1986, Los
Angeles, California, USA. IEEE Computer Society, 336–342. https://doi.org/10.
1109/ICDE.1986.7266238

[45] Shital Shah, Debadeepta Dey, Chris Lovett, and Ashish Kapoor. 2017. AirSim:
High-Fidelity Visual and Physical Simulation for Autonomous Vehicles. In Field
and Service Robotics. arXiv:arXiv:1705.05065 https://arxiv.org/abs/1705.05065

[46] Hazim Shakhatreh, A. Sawalmeh, Ala Al-Fuqaha, Zuochao Dou, Eyad K. Almaita,
Issa M. Khalil, Noor Shamsiah Othman, A. Khreishah, and M. Guizani. 2019.
Unmanned Aerial Vehicles (UAVs): A Survey on Civil Applications and Key
Research Challenges. IEEE Access 7 (2019), 48572–48634.

[47] Philip Shilane, Patrick Min, Michael M. Kazhdan, and Thomas A. Funkhouser.
2004. The Princeton Shape Benchmark. In 2004 International Conference on Shape
Modeling and Applications (SMI 2004), 7-9 June 2004, Genova, Italy. IEEE Computer
Society, USA, 167–178. https://doi.org/10.1109/SMI.2004.1314504

[48] Martin Stephan, Javier Alonso-Mora, and Roland Siegwart. 2013. Reciprocal
Collision Avoidance With Motion Continuity Constraints. IEEE Transactions on
Robotics 29 (08 2013), 899–912. https://doi.org/10.1109/TRO.2013.2258733
[49] Ion Stoica, Robert Morris, David Karger, M. Frans Kaashoek, and Hari Bal-
akrishnan. 2001. Chord: A Scalable Peer-to-Peer Lookup Service for Internet
Applications. SIGCOMM Comput. Commun. Rev. 31, 4 (Aug. 2001), 149–160.
https://doi.org/10.1145/964723.383071

[50] Hang Sun, Juntong Qi, Chong Wu, and Mingming Wang. 2020. Path Planning
for Dense Drone Formation Based on Modified Artificial Potential Fields. 39th
Chinese Control Conference (CCC) (2020), 4658–4664.

[51] Jiayi Sun, Jun Tang, and Songyang Lao. 2017. Collision Avoidance for Cooperative
UAVs With Optimized Artificial Potential Field Algorithm. IEEE Access PP (08
2017), 18382–18390. https://doi.org/10.1109/ACCESS.2017.2746752
[52] Ivan E. Sutherland. 1965. The Ultimate Display. In IFIP Congress. 506–508.
[53] Camilla Tabasso, Venanzio Cichella, Syed Mehdi, Thiago Marinho, and Naira
Hovakimyan. 2021. Time Coordination and Collision Avoidance Using Leader-
Follower Strategies in Multi-Vehicle Missions. Robotics 10 (02 2021), 34. https:
//doi.org/10.3390/robotics10010034

[54] Jur van den Berg, Stephen Guy, Ming Lin, and Dinesh Manocha. 2011. Reciprocal
n-Body Collision Avoidance. Vol. 70. Berlin, Heidelberg, 3–19. https://doi.org/10.
1007/978-3-642-19457-3_1

[55] Jur van den Berg, Ming Lin, and Dinesh Manocha. 2008. Reciprocal Velocity
Obstacles for Real-Time Multi-agent Navigation. In IEEE International Conference
on Robotics and Automation. IEEE, USA, 1928–1935. https://doi.org/10.1109/
ROBOT.2008.4543489

[56] Jur van den Berg, Jamie Snape, Stephen Guy, and Dinesh Manocha. 2011. Re-
ciprocal Collision Avoidance with Acceleration-Velocity Obstacles. In 2011 IEEE
International Conference on Robotics and Automation. IEEE, USA, 3475–3482.
https://doi.org/10.1109/ICRA.2011.5980408

[57] Jur van den Berg, David Wilkie, Stephen Guy, Marc Niethammer, and Dinesh
Manocha. 2012. LQG-obstacles: Feedback Control with Collision Avoidance for
Mobile Robots with Motion and Sensing Uncertainty. In International Conference
on Robotics and Automation. IEEE, 346–353. https://doi.org/10.1109/ICRA.2012.
6224648

[58] Tutte W. 1947. The Factorization of Linear Graphs. Journal of London Mathematics

Society 22 (1947), 107–11.

[59] Yang Xu, Shupeng Lai, Jiaxin Li, Delin Luo, and Yancheng You. 2019. Concurrent
Optimal Trajectory Planning for Indoor Quadrotor Formation Switching. Journal
of Intelligent & Robotic Systems 94 (05 2019). https://doi.org/10.1007/s10846-018-
0813-9

