Testing Quantum Programs with Multiple
Subroutines

Peixun Long
State Key Laboratory of Computer Science
Institute of Software, Chinese Academy of Science
University of Chinese Academy of Science
Beijing, China
longpx@ios.ac.cn

Jianjun Zhao
Kyushu University
Fukuoka, Japan
zhao@ait.kyushu-u.ac.jp

2
2
0
2

g
u
A
9
1

]
E
S
.
s
c
[

1
v
6
0
2
9
0
.
8
0
2
2
:
v
i
X
r
a

Abstract—Errors in quantum programs are challenging to
track down due to the uncertainty of quantum programs. Testing
is, therefore, an indispensable method for assuring the quality of
quantum software. Existing testing methods focus only on testing
quantum programs with quantum circuits or single subroutines
and, therefore, cannot effectively test quantum programs with
multi-subroutines. In this paper, we ﬁrst discuss several critical
issues that must be considered when testing multi-subroutine
quantum programs and point out the limitations and problems
with existing testing methods. We then present a novel framework
for testing multi-subroutine quantum programs that allow for
both unit and integration testing. Our framework includes two
novel test coverage criteria for the equivalent class partition of
quantum variables to guide our testing tasks and techniques
to test quantum programs with several common patterns. We
also discuss how to generate test cases based on our framework.
To evaluate the effectiveness of our testing framework, we
implemented a tool called QSharpTester for testing Q# programs
with multiple subroutines. We used it to conduct experiments on
hundreds of mutation programs deriving from seven original
Q# programs. The experimental results show that our testing
methods can deal with broader types of quantum programs than
existing ones and perform well on almost all faulty mutation
programs.

Index Terms—Quantum program, software testing, Q#

I. INTRODUCTION

Quantum computing is a rapidly developing ﬁeld expected
to make breakthroughs in many areas [38]. It uses the princi-
ples of quantum mechanics to process information and com-
puting tasks. Compared with classical algorithms, quantum
algorithms can solve some speciﬁc problems with acceler-
ation [16], [22], [42]. With the development of quantum
hardware devices and algorithms,
it becomes increasingly
important to develop high-quality quantum software.

Recently, many quantum programming languages have been
proposed, such as Q# [43], Qiskit [3], Scaffold [1], Quip-
per [20], and Sliq [10], for supporting writing programs that
run on quantum simulators or real quantum devices. However,
due to the speciﬁc features of quantum programs, such as
superposition, entanglement, and non-cloning theorem, errors
in quantum programs are challenging to track down [26],
[35]. Although several testing methods have been proposed
for quantum programs [2], [4], [25], [30], [34], [44], [46],

they still have some limitations: (1) Existing meth-
[47],
ods migrate techniques for classical programs into quantum
programs and lack the consideration of quantum nature. (2)
Existing methods consider mostly single quantum programs,
but multi-subroutine quantum programs are more common
in practice and lack systematic support for testing them. (3)
The deﬁnitions of input, output, and program speciﬁcations in
existing testing methods limit the scope of their application to
test multi-subroutine quantum programs.

In this paper, we ﬁrst discuss several critical issues that
must be considered when testing multi-subroutine quantum
programs and point out the limitations and problems with
existing testing methods. Then, we propose a systematic test
process and a framework to support the testing tasks for multi-
subroutine quantum programs according to these properties.
We discuss IO analysis, equivalence class partition, coverage
criteria, and test case generation in succession. In IO analysis,
we introduce the IO mark to denote the input and output of
each subroutine. In equivalence class partition and coverage
criteria, we propose two novel coverage criteria for quantum
variables and discuss the combinations of variables. In test
case generation, we discuss the principle of choosing test
inputs and how to create required input and detect output. We
also discuss how to test quantum programs with two common
patterns. To support our testing methods and future testing
tasks, we implement QSharpTester, an efﬁcient testing tool
for testing Q# programs with multi-subroutines.

To evaluate the effectiveness of our testing methods, we
use a set of Q# benchmark programs, including seven orig-
inal correct programs and their 244 faulty mutations with
four mutation types. We use Q# and its simulator because
Q# is a program-level rather than circuit-level programming
language [43] to support complex quantum programs. The
results of benchmark programs show that our methods can ﬁnd
almost all faulty mutations and some equivalent mutations. The
results also show that our methods can ﬁnish testing tasks in an
acceptable time on a personal computer with a Q# simulator.
We also compare our testing methods with existing methods.
Our methods have advantages in (1) supporting the testing of
broader types of quantum programs, (2) ﬁnding bugs related
to quantum natures, and (3) scalability and compatibility.

1

 
 
 
 
 
 
Our paper makes the following contributions:
• Critical

issues in testing quantum programs: We
discuss and clarify some critical issues in testing muti-
subroutine quantum programs, which have been either
neglected or rarely discussed by previous research.

• Testing coverage criteria: We present two novel test-
ing coverage criteria, namely, classical-superposition
partition and classical-superposition-mixed partition for
equivalence class partitioning of quantum programs.
• Testing framework: We present a framework for testing
multi-subroutine quantum programs. Based on the frame-
work, we also implement QSharpTester, a tool for testing
Q# programs with multi-subroutines.

• Evaluation: We use a set of benchmark programs to
evaluate the effectiveness of our testing methods. The
experimental results show that our testing methods can
deal with broader types of quantum programs than exist-
ing ones and perform well on almost all faulty mutation
programs.

The rest of the paper is organized as follows. Section II
introduces some basic concepts of quantum computation.
We discuss how the properties of multi-subroutine quantum
programs inﬂuence the testing tasks in Section III. Section IV
presents the details of our testing methods, and Section V
discusses the tool support for testing multi-subroutine quantum
programs with QSharpTester. An experimental evaluation is
given in Section VI. We discuss related works in Section VII,
and the conclusion is given in Section VIII.

II. BACKGROUND

We ﬁrst introduce basic information on quantum compu-
tation, quantum algorithms, and quantum programming lan-
guages.

A. Basic Concepts of Quantum Computation

A quantum bit, or qubit for short, is the basis of quantum
computation. We know that a classical bit has two values:
0 and 1. A qubit also has two states with the form |0(cid:105) and
|1(cid:105) like the classical bit, and it can contain a superposition
between basis states. The general state of a qubit is a |0(cid:105)+b |1(cid:105),
where a and b are two complex numbers called amplitudes that
satisfy |a|2 + |b|2 = 1. Amplitudes represent the probability
proportion of each basis state. For more than one qubit, the
basis states are similar to binary strings. For example, a two-
qubit system has four basis states: |00(cid:105), |01(cid:105), |10(cid:105) and |11(cid:105),
and the general state is a00 |00(cid:105)+a01 |01(cid:105)+a10 |10(cid:105)+a11 |11(cid:105),
where |a00|2 + |a01|2 + |a10|2 + |a11|2 = 1. The state can also
be written as a column vector [a00, a01, a10, a11]T . The above
states are all pure states. Sometimes a quantum system may
have a distribution over several pure states rather than a certain
state, called a mixed state.

into a basis state according to obtained value. For example,
measuring a qubit a |0(cid:105)+b |1(cid:105) will get result 0 and collapse into
state |0(cid:105) with probability |a|2 and get result 1 and collapse into
state |1(cid:105) with probability |b|2. This property brings uncertainty
and inﬂuences testing work for quantum programs. Another
important property is entanglement. When two qubits are
entangled, the entire state cannot be departed as two irrelevant
qubits. The Bell state |β00(cid:105) = 1√
(|00(cid:105) + |11(cid:105)) is a typical
2
entangled state.

Quantum computing is performed by applying proper quan-
tum gates on qubits. An n-qubit quantum gate can be repre-
sented by a 2n × 2n unitary matrix G. Applying gate G on
quantum state |ψ(cid:105) will obtain state G |ψ(cid:105). There are several
basic quantum gates: single-qubit gates X, Z, H, and R1(θ),
and two-qubit gate CNOT. The matrices of these gates are
shown in the following:

X =

(cid:20) 0
1

(cid:21)

1
0

, Z =

(cid:20) 1

0
0 −1

(cid:21)

, H =

(cid:20) 1

1
1 −1

(cid:21)

1
√
2

R1(θ) =

(cid:20) 1
0

(cid:21)

0
eiπθ

, CNOT =






1
0
0
0

0
1
0
0

0
0
0
1






0
0
1
0

A quantum circuit is a popular model to express the process
of quantum computing. Every line represents a qubit in a
quantum circuit model, and a sequence of operations is applied
from left to right. For example, Figure 1 shows a quantum
circuit for preparing the Bell state |β00(cid:105) = 1√
(|00(cid:105) + |11(cid:105)),
2
which contains an H gate and a CNOT gate.

Fig. 1. A quantum circuit for preparing the Bell state, containing an H gate
and a CNOT gate.

B. Quantum Algorithms

Quantum algorithms use quantum mechanics to solve com-
putational problems. This section introduces some quantum
algorithms, which will be discussed in the following sections.
A fundamental quantum algorithm is Grover Search
(GS) [22], which has also been proven to be faster than its
n) times of oracle
classical counterparts. GS only needs O(
queries for searching a database with n elements [11].

√

Quantum Fourier Transform (QFT) is another fundamental
quantum algorithm that performs the following transformation:

|j(cid:105) →

1
√
2n

2n−1
(cid:88)

k=0

e2πijk/2n

|k(cid:105)

In quantum devices, the information of qubits can only be
obtained by measurement. Measuring a quantum system will
get a classical value with the probability of corresponding
amplitude. Then the state of the quantum system will collapse

The Fourier coefﬁcients are encoded in the amplitudes. QFT
requires only O(n2) steps for n-qubits input, whereas the
classical fast Fourier transform (FFT) still needs O(n2n) steps.
QFT has an inverse transform, which can be denoted as IQFT.

2

Hȁۧ0ȁۧ0ȁۧ𝛽00Quantum Phase Estimation (QPE) is a typical application
of QFT to attain the eigenvalue of a given eigenvector of a
target unitary operation. Let U be the unitary operation, and
it has an eigenvector |x(cid:105) with eigenvalue e2πiθx (The length
of the eigenvalue of a unitary is 1). QPE estimates θx and
stores its binary representation in multi-qubit quantum state
|θx(cid:105). Figure 2 gives the overall circuits of the QPE algorithm,
which requires two groups of qubits: target qubits and clock
qubits. The target qubits are initialized in state |x(cid:105), and the
clock qubits are initialized in an all-zero state. The binary
representation of θx will be output in the clock qubits.

Fig. 2. The quantum circuit for QPE algorithm.

Quantum Order Finding (QOF) is a typical application of
QFT and QPE. Shor’s Quantum Factoring (QF) and discrete
logarithms [42] are based on QOF. QF is a vital algorithm
because it can break some cryptosystems based on the com-
plexity of large number decomposition, such as RSA.

C. Quantum Programming Languages

Several quantum programming languages are available re-
cently, such as ProjectQ [24], Scaffold [1], [27], QWIRE [40],
Qiskit [3], and Q# [43]. Some of these languages, such as the
Python-based ProjectQ, are extensions of classical program-
ming languages, and some, such as Q#, are independent of
their classical counterparts. Some languages, such as QWIRE,
are lower level and suitable for describing quantum circuits.
In contrast, others, such as Q#, are higher level and capable
of implementing complex function calls. In addition, almost
all quantum programming languages provide simulators that
allow programmers to run quantum programs on a classical
computer. A few programming languages even provide inter-
faces to real quantum hardware. For example, Qiskit has an
interface to IBM’s quantum hardware.

III. THE PROPERTIES OF MULTI-SUBROUTINE QUANTUM
PROGRAMS

We next discuss some critical properties of multi-subroutine
quantum programs and try to answer the following research
question.

• How do the properties of multi-subroutine quantum pro-

grams inﬂuence testing tasks?

A. Quantum Circuits and Quantum Programs

Conventionally, a quantum circuit is used to describe a
quantum algorithm, as shown in Figure 2 for the QPE algo-
rithm. However, quantum circuits are not always equivalent
to quantum programs, and the quantum circuit model has
some limitations in describing general quantum programs. A
typical limitation is quantum-classical-hybrid programming.

3

(a) n = 1

(b) n = 2

(c) n = 3

Fig. 3. Corresponding circuits of QFT program with n = 1, 2 and 3, where
n is the number of qubits.

The quantum circuit model
is hard to describe quantum
programs with classical variables or control ﬂows (such as
if statements or while loop statements).

Many practical quantum algorithms contain both classical
and quantum parts. A case is where the input contains both
classical and quantum variables. A typical example is Param-
eterized Quantum Circuit (PQC) [9], widely used in quantum
machine learning. Another case is that the program contains
both classical and quantum subroutines. For example,
the
unique quantum subroutine of the QF program is QOF, and
other subroutines are classical. So the description of QF is, to
some extent, like a classical algorithm rather than a quantum
circuit.

A general quantum program is usually not on a ﬁxed scale,
which often corresponds to a family of quantum circuits rather
than a speciﬁc circuit. Although we can represent it as an
unﬁxed circuit, as Figure 2 shows, it is a high-level represen-
tation, omitting many details. As shown in Figure 3, the QFT
program corresponds to different circuits when the number n
of qubits is different, similar to the classical counterpart of the
quantum Boolean circuit [7], an essential computational model
in computational complexity. A classical algorithm usually
corresponds to a uniform family of Boolean circuits rather than
just a circuit.

This paper focuses on testing quantum programs rather than
quantum circuits and considering both quantum and classical
code in a quantum program. Moreover, the differences be-
tween quantum programs and quantum circuits motivate us to
reconsider the current quantum program testing process.

B. Subroutines

A complete quantum program is usually composed of a
number of subroutines. Listing 1 shows an implementation of
the QFT program in Q#. In the program, CRk and Reverse
are two subroutines called by the upper-level subroutine QFT.
Besides this direct call, another way to organize subroutines
is to take the subroutine as an input parameter. An example
is Grover Search [22], which needs a subroutine to identify
a solution and uses the subroutine as a black box. We call
the subroutine an oracle. Listing 2 shows another example

ȁۧ0ȁۧ𝑥ȁۧ𝜃𝑥ȁۧ𝑥clock qubitstarget qubitsHIQFT𝑈𝑗ȁۧ𝑗HH𝑅2××HH𝑅2𝑅3𝑅2H××1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33

1
2
3
4
5
6
7
8
9
10
11
12
13
14

operation CRk(qctrl: Qubit, k: Int, qtarget: Qubit)

: Unit is Adj {

body(...) {

let theta = 2.0*Math.PI()/Convert.IntAsDouble(2ˆk);
Controlled R1([qctrl], (theta, qtarget));

}
adjoint auto;

}

operation Reverse(qs : Qubit[]) : Unit is Adj {

body(...) {

let n = Length(qs);
for i in 0 .. n / 2 - 1
{ SWAP(qs[i], qs[n - i - 1]); }

}
adjoint auto;

}

operation QFT(qs : Qubit[]) : Unit is Adj {

body(...) {

let n = Length(qs);
for i in 0 .. n - 2 {

H(qs[i]);
for j in i + 1 .. n - 1 {
let k = j - i + 1;
CRk(qs[j], k, qs[i]); // Call "CRk"

}

}
H(qs[n - 1]);
Reverse(qs); // Call "Reverse"

}
adjoint auto;

}

Listing 1. The Q# code of QFT program

operation QPE(Upower : (Int,Qubit[])=>Unit is Adj+Ctl,
qsclock : Qubit[], qstarget : Qubit[])
: Unit is Adj {

body (...) { //Original operation

let n = Length(qsclock);
MultiH(qsclock);
for i in 0 .. n - 1 {

Controlled Upower([qsclock[n - i - 1]],

(2 ˆ i, qstarget));

}
Adjoint QFT(qsclock);

}
adjoint auto; //Generate adjoint version of QPE by Q#.

}

Listing 2. The Q# code of QPE program

QPE, which requires the target quantum operation as an input
parameter (Upower in lines 1 and 8).

Some variants deriving from the original subroutine are
needed in many quantum programs. For example, as shown
in Listing 2, the QPE program calls Adjoint QFT (line
11), which is the inverse of QFT. It also calls Controlled
Upower (lines 8-9),
the controlled version of Upower.
Generally, there are three important variants of a subroutine
in quantum programs: inverse, controlled, and power, and
these variants can also be combined. Formally, for a unitary
operation U , the inverse variant is U −1, the controlled is CU ,
and the power is U n.

Some high-level quantum programming languages, such as
Q# [43] and isQ [23], support the generation and management
of these three variants. As an example, Listing 3 gives an
implementation of H n, the power of the H gate, using these
three variants. The power n is implemented as an extra Int

1
2
3
4
5
6
7
8
9
10

operation Hpower(power : Int, q : Qubit)

: Unit is Adj + Ctl {

body (...) {

//If pow is odd, apply H, otherwise I
if (power % 2 == 1) { H(q); }

}
adjoint auto;
controlled auto;
adjoint controlled auto;

}

Listing 3. The implementation of the power variant of the H gate. The adjoint,
controlled, and adjoint controlled versions are generated by Q#.

parameter power. The result from H 2 = I, H n equals H
if n is odd; otherwise, it equals I (line 5). The inverse, con-
trolled, and inverse-and-controlled variants can be generated
automatically by Q# (lines 7-9, and Q# uses the keyword
“adjoint” to represent inverse operation). Because of the
wide use of these three variants, it is necessary to propose
speciﬁc techniques to test them. We will consider this issue in
Section IV-E.

C. Input and Output

Previous research [4], [46], [47] deﬁnes the input and output
of a quantum program as a subset of all used qubits. Such a
deﬁnition has some problems when testing multi-subroutine
quantum programs. First, it ignores the classical variables, an
essential part of many quantum programs. Second, it regards
the total input/output as an entity, ignoring the detailed logical
meaning. This paper considers both quantum and classical
input and output of a quantum program. It identiﬁes the input
and output by logic meaning, where the quantum variables can
be seen as a special type. For example, consider a quantum
adder program |x(cid:105) |y(cid:105) → |x(cid:105) |x + y(cid:105). The quantum registers
of |x(cid:105) and |y(cid:105) are logically two sets of qubits. Therefore,
the input should contain two quantum variables |x(cid:105) and |y(cid:105),
rather than taking all qubits as one input variable. For a target
program under test, correctly identifying the inputs and outputs
of all program subroutines is one of the prerequisites for a
successful testing task. We will give a more detailed discussion
in Section IV-B.

D. Program Speciﬁcation

Program speciﬁcation gives the expected behavior of the
program and is the basis for testing execution. The pur-
pose of testing is to check whether a program converts the
given input into the speciﬁc output according to the program
speciﬁcation. Previous research [4], [46], [47] deﬁned the
program speciﬁcation as the expected probability distribution
of the output values under given input values. However, this
deﬁnition implies that we must have a measurement at the end
of each subroutine to covert quantum states into probability
distributions. This restriction is not suitable for testing a
multi-subroutine program. In a multi-subroutine program, a
subroutine may only transform a quantum state into another
state, which is not necessary to measure the state at the end
of the subroutine.

4

On the other hand, it is better to consider the speciﬁca-
tion of quantum states rather than a probability distribution.
Generally, for some given inputs, the program speciﬁcation
gives the expected output for each input. This relationship
can be represented as a formula in most cases, and we call it
formula-based program speciﬁcation. For example, QFT has
the following formula description:

|j(cid:105) →

1
√
2n

2n−1
(cid:88)

k=0

e2πijk/2n

|k(cid:105)

(1)

where |j(cid:105) is a classical state with integer j. Formula (1)
only gives the transformation under classical state inputs.
Fortunately, QFT is a unitary transform, so the expected output
under general input can be deduced by linearity.

E. Quantum State Generation and Detection

Testing quantum programs relies on the processing of quan-
tum variables. However, because of the properties of quantum
states, it is challenging to generate and detect quantum states
compared to the generation and detection of classical states.
In the classical case, putting some parameters into a com-
puter is straightforward. It is easy to convert a natural lan-
guage description of the input (such as a block of text or
a decimal number) into a binary string that a computer can
recognize according to some predetermined coding rules. The
input process is to convert the binary string into the state of
internal components of a computer (e.g., high and low voltages
represent 1 and 0, respectively). However, quantum variables
not only have classical states like binary strings but also have
superposition states or mixed states. Some states which are
easily described in natural language may be difﬁcult to prepare
on quantum devices. Furthermore, it has been proved that some
states need high costs to prepare [29].

After running the program under a given input, we must
compare the actual output with the expected output. Reading
out the contents in classical memories is also straightforward.
However, we cannot avoid measurement to obtain information
on quantum variables, which may change the state of quantum
variables and disrupt the execution of programs.

IV. TESTING FRAMEWORK

We next present a systematic test process and a testing

framework for testing multi-subroutine quantum programs.

A. The Overall Test Process

Figure 4 shows the overall process of testing quantum
programs with multiple subroutines. In this process, given
the ﬁrst step is to analyze
a quantum program as input,
the structure of the whole program and ﬁnd its subroutines
and their organization. To this end, we use Q-UML [41] to
specify the structure of the program. After that, unit testing
is performed on each subroutine, and then integration testing
on the whole program. In unit testing, we ﬁrst analyze the
inputs and outputs of each subroutine to obtain the necessary
information for unit testing. We present a novel method called

Fig. 4. The overall process of testing quantum programs with multiple
subroutines.

IO marks to represent this information. We then partition the
input space of each subroutine into several equivalence classes
and generate test cases according to these equivalence classes
for the subroutine. We introduce two novel coverage criteria.
After that, we run the unit test to obtain the testing result for
each subroutine. The next step is to perform integration testing
by selecting proper integration methods to run and obtain the
testing results for the whole program.

In the rest of this section, we will discuss each part of our
test process, present tools and methods to deal with them, and
provide examples to show how to use our testing methods.

B. IO Analysis

As discussed in Section III-C, analyzing the input and
output is the origin of testing each subroutine. For a concrete
subroutine, only the variables that users should assign are
regarded as input. Similarly, only the variables users are
interested in after running are regarded as output. For example,
in many quantum algorithms, some qubits should always be
initialized with an all-zero state |0 . . . 0(cid:105). These qubits should
not be regarded as input. Another typical case is a qubit array,
such as qs in Listing 1 (line 19). Like an array of integers,
a qubit array contains both length and data. Therefore, when
identifying the input and output of a subroutine, a qubit array
should be regarded as two variables: length and quantum state.
To represent the input and output of a quantum program,
we introduce the IO mark, which can help developers design
test cases. The general form of the IO mark is:

program : (input variables) → (output variables’)

We use underline to denote the input parameters of
subroutine-type and bold font to denote quantum variables.
We add an “apostrophe” (’) on each output variable to distin-
guish input and output. If a variable var is both input and
output, we denote the input and output as the same name, i.e.,
var is the input, and var’ is the output. Example 4.1 shows
how to perform IO analysis and use IO marks.

5

IO analysis for each subroutineEquivalence class partitionTest cases generationRun unit testingSelect integration strategiesRun integration testingSubroutinesQuantum programsIntegration testing resultsIO markEquivalence classesTest casesQ-UML DiagramsStructural analysisUnit testing resultsIntegration testingUnit testingseveral “equivalence classes” by logical meaning, and all cases
in one class have the same effect in uncovering bugs. Such
an idea can be applied to quantum program testing as well.
The partitioning of quantum state input often depends on
the speciﬁc program, but some general principles are still
available.

We deﬁne a quantum variable as a subset of all qubits
in a logical meaning and the “data” of this variable as the
quantum state on these qubits. Generally, there are three types
of quantum states: classical state, superposition state, and
mixed state (see Section II-A). So a natural partition criterion
is to divide a quantum variable by state types, and we call
it “classical-superposition-mixed partition” (CSMP). However,
many quantum programs will not run under input with mixed
states. For these programs, we can omit the coverage of mixed
states, which is a “classical-superposition partition” (CSP). We
deﬁne two novel coverage criteria as follows.

Criterion 1 classical-superposition partition (CSP) For each
input variable of each quantum state type, partition it into
classical state input and superposition state input.

Criterion 2 classical-superposition-mixed partition (CSMP)
For each input variable of each quantum state type, partition
it into classical state input, superposition state input, and mixed
state input.

During the testing, which criterion should be used is de-
termined by the usage of the target program. If we run a
target program under mixed-state input, we can use CSMP.
Otherwise, CSP is enough. Note that both classical and super-
position states should be covered. There are two reasons why
both classical and superposition states should be covered in
any case. First, the program speciﬁcation in formula form gives
the expected output states of the program under a speciﬁc input
state, and the input states in the formula are usually classical
(such as formula (1) in Section III-D), so covering classical
states is to check the speciﬁcation directly. Second, superposi-
tion is the essential difference between classical and quantum
variables, and testing classical input alone cannot ensure the
program behavior in superposition input. We will discuss the
necessity of covering superposition states in Section VI-C.

On the other hand, many quantum programs have more than
one input variable, so the combination of variables should
also be considered. Several combination coverage criteria
between variables have been proposed for classical software
testing, such as All Combination Coverage (ACoC) [14], Each
Choice Coverage (ECC) [5], Pair-wise Coverage (PWC) [13],
and Base Choice Coverage (BCC) [5], [15]. These coverage
criteria can be migrated into quantum programs.

Example 4.2: Partitioning and combination for QFT pro-

gram. The IO mark of the QFT program is:

QFT : (n, qs) → (qs’)
As is shown in Listing 1, there are two loops in the QFT
program, where the maximum index of the outer loop (line 22)
is n − 2, and the maximum index of the inner loop (line 24) is
n − 1. It is easy to see that 1 and 2 are two boundary values

Fig. 5. The diagram represents the input and output of QPE program, where
the input variables are denoted in green, and the output variable is denoted
in red.

Example 4.1: IO analysis for QPE program.
The QPE program in Listing 2 has three parameters:
Upower, qsclock, and qstarget, while the latter two
are qubit-array types. On the input side, qsclock contains
two variables: the length “Nclock” and the data “clock.” It is
similar to qstarget, which contains two variables as well:
the length “Ntarget” and the data “target.” On the output side,
they should be denoted as “clock’” and “target’.” Upower
is a parameter of subroutine type and should be denoted as
“Upower.” Figure 5 shows the structure, input, and output of
the QPE program.

In the program, the quantum state clock is always initialized
with an all-zero state, so it is not an input. In most applications
of the QPE program, we do not care about the post-state
target’, so it is not output. In Figure 5, the input variables
are shown in green, while the output variable is red. The IO
mark can be written as:

QPE : (Nclock, Ntarget, Upower, target) → (clock’)

C. Equivalence Class Partition and Testing Coverage Criteria

A coverage criterion is a set of rules used to help determine
whether a program is adequately tested by a test suite and
guides the test process [6]. Some coverage criteria for quantum
programs have been proposed, such as Quito (Quantum Input-
output coverage) [4], to provide an objective measure of the
test quality of the programs. However, these coverage criteria
are based only on the speciﬁc input, output, and program
speciﬁcation deﬁnitions. As discussed in Section III-C and
Section III-D, these criteria have some limitations when ap-
plied for testing multi-subroutine quantum programs. For ex-
ample, the size of the generated test suite from Input Coverage
(IC) in [4] is |V DI |, where V DI is the subset of valid input
values. In most cases, |V DI | = O(2n), where n is the number
of input qubits, which means that the IC criterion becomes
unavailable when testing large-scale quantum programs. The
Output Coverage (OC) and Input-Output Coverage (IOC)
also have a similar problem of exponential complexity. As a
result, these coverage criteria are unsuitable for guiding the
overall test process for testing complex quantum programs
with multiple subroutines. In this paper, we deﬁne a novel
class of coverage criteria for partitioning quantum inputs of
quantum programs.

Equivalence class partitioning is an important

testing
method [37]. The basic idea is to partition input space into

6

ȁۧ0ȁۧ𝑥ȁۧ𝜃𝑥ȁۧ𝑥UpowerQPENclockNtargetclocktargettarget’clock’Callof n, so partition n into three parts: n = 1, n = 2 and n ≥ 3.
We use CSP to partition qs into a classical state (C) and a
superposition state (S). To combine n and qs, we use ACoC
on these two parameters. Finally, there are six equivalence
classes:

(n = 1, C)
(n = 2, S)

(n = 1, S)
(n ≥ 3, C)

(n = 2, C)
(n ≥ 3, S)

D. Test Case Generation

Having equivalence class partition, we can generate concrete
test cases. In classical testing, a test case is deﬁned as the
combination of inputs and expected outputs [6] as shown
below:

test case: (inputs, expected outputs)

We choose some pairs of values to ﬁll inputs and expected
outputs. However, for testing quantum programs, we should
consider more about the feasibility and how to execute the
test cases due to the speciﬁc properties of quantum states
(see Section III-E). Therefore, for each equivalence class of
a quantum variable, we choose quantum input states which
should satisfy the following three properties simultaneously:

• Input state is typical to represent its type;
• Input state is easy to prepare;
• Corresponding output state is also easy to check.
We discuss how to create inputs and detect outputs for

quantum variables in the following.

i

√

1) Creating quantum inputs: For general superposition
states, if we know the probability distribution {pi} of each
amplitude, we can use the algorithm [21] to generate the
superposition state (cid:80)
pi |i(cid:105). However, in most cases, test-
ing general input is not necessary or infeasible because (1)
generating general superposition state (cid:80)
pi |i(cid:105) is cost; (2)
i
the corresponding output of general input may be difﬁcult
to detect. According to our practice, two typical types of
superposition states as follows, are helpful in ﬁnding bugs and
they can be prepared easily:
• uniform superposition
• two-values superposition 1√
2

k=0 |k(cid:105);
(|x(cid:105) + eiθ |y(cid:105)), where two
integers x, y and phase difference θ can be

(cid:80)2n−1

1√

√

2n

classical
chosen by users.

If we know the ensemble composition, the preparation is
simple for mixed state input. If we only know the density
matrix ρ, we can use spectrum decomposition to ﬁnd the
ensemble composition [39].

2) Detecting quantum outputs: Although, as discussed in
Section III-E, obtaining information from quantum memories
is difﬁcult, there are still some methods and strategies to
ﬁnish this task, which can be divided into statistic-based
detection (SBD) methods and quantum runtime assertions
(QRAs) methods.

SBD means running the target program many times, col-
lecting the measurement information, and then reconstructing
the output state from this information. There have been many

7

methods and algorithms in quantum state detection and dis-
crimination [8], which can be used for checking the output
states during testing. For example, state tomography, swap
test [12], [17], and hypothesis test [26]. In essence, these
methods are based on the repeat running of programs, which
require running many times to achieve high precision, so they
are costly.

The QRA methods, such as those proposed in [30]–[32], are
based on the fact that if the target output state is a member of
the measurement basis, the measurement will not destroy the
state. By choosing a proper measurement basis, even only once
running is enough to get the necessary information. However,
according to our practical experience, the QRAs are not always
easy to implement for general quantum programs. In many
cases, however, the complexity of implementing a quantum
runtime assertion is the same as that of implementing the target
program, which means that the burden of testers is heavy,
and this testing method is also error-prone. Therefore, we still
need to use SBD or hybrid methods for programs that cannot
construct the runtime assertions easily.

A typical application of QRAs in testing tasks is transform-
based detection (TBD). Suppose expected output |ψeo(cid:105) can be
obtained by applying a simple unitary operation on an all-
zero state, i.e., there exists a unitary operation Ueo such that
|ψeo(cid:105) = Ueo |0 . . . 0(cid:105). If the practical output is |ψeo(cid:105), applying
U −1
eo on it will obtain an all-zero state, otherwise will not. The
measurement result for the all-zero state is always integer 0,
and the state will not be changed. In the testing view, U −1
eo is
the inverse variant of Ueo, which can be easily implemented as
long as Ueo can be easily implemented. The most signiﬁcant
advantage of this method is that only one run can get correct
detection results with high probability. The disadvantage is that
it is feasible only when a simple Ueo of the expected state
exists. If the code of U −1
is complex, then the TBD may
eo
be impractical. In this case, we need to use SBD or hybrid
detection methods. Example 4.3 shows how to construct U −1
eo
for the QFT program under classical input states.

Example 4.3: Output detection for QFT program.
The program speciﬁcation of QFT has been shown in

formula (1), and it can be rewritten in bitwise form:

|j1(cid:105) → 1√
2

(|0(cid:105) + e2πi0.jn |1(cid:105))

· · ·

|jn(cid:105) → 1√
2

(|0(cid:105) + e2πi0.j1j2...jn |1(cid:105))

(2)

Given classical state input |j(cid:105) = |j1(cid:105) · · · |jn(cid:105), the corre-
sponding output state is the product state of n single qubit
states, and each single qubit state is in form 1√
(|0(cid:105)+eiθk |1(cid:105)),
2
where θk = 0.jn−k+1 . . . jn−1jn. This single qubit state can
be generated by applying gate Uk on |0(cid:105), where

Uk = R1(θk)H =

(cid:20)

1
√
2

1

1
eiθk −eiθk

(cid:21)

(3)

To check the output, we can apply U −1

k = HR1(−θk) on
k-th qubit. If the output is correct, all qubits after applying

U −1
k will become |0(cid:105), then measuring the qubits will always
get integer 0. Otherwise, non-zero results are possible to occur.

E. Testing Strategies for Variant Subroutines

In Section III-B, we discussed three variants of an original
program. Essentially, they are different from the original pro-
gram. Some programming languages support the management
of these variants, such as automatically generating inverse or
controlled variants. However, this automation is not always
available, so testing for them is still necessary.

Fortunately, to test three variants of an origin subroutine, we
can use the relation between the variants and the original one
to avoid redesigning test cases, and the test can be ﬁnished
in uniﬁed processes. Suppose we have ﬁnished testing the
original subroutine P, we denote inverse, controlled, power
variants of P as InvP, CtrlP, and PowP, respectively.

For InvP, there is an obvious relation:

P ◦ InvP = I

(4)

where ‘◦’ denotes the sequential execution (from right
to
left) of two subroutines, InvP and P, and I is the identity
operation. Note that no matter what P is, the relation (4) is
always held, so we obtain a uniﬁed test process for any InvP,
that is, to check whether the sequential execution of InvP and
P is equivalent to identity I.

The input of PowP contains two parts: the power k (a
classical integer) and target qubits qs. Given k, the effect on
qs is equivalent to apply P (if k > 0) or InvP (if k < 0) for
|k| times. Also, the equivalence check can be converted into
an identity check with the following relations:

InvPk ◦ PowP(k) = I, k > 0
k < 0

P|k| ◦ PowP(k) = I,

(5)

The input of CtrlP contains two parts: control qubits qctrl
and target qubits qtar. If qctrl is in an all-one state |1 . . . 1(cid:105),
then the effect on qtar is P. If qctrl is in a state which is
orthogonal to |1 . . . 1(cid:105), then the effect is identity I:

InvP ◦ CtrlP(qs = |1 . . . 1(cid:105)) = I
CtrlP(qs⊥ |1 . . . 1(cid:105)) = I

(6)

We can see that the testing of variants subroutines can be
converted into the checking of identity, which can be ﬁnished
in uniﬁed processes. Here, I has the program speciﬁcation
with the following form:

I : |x(cid:105) → |x(cid:105)

(7)

for all input states |x(cid:105). A feasible scheme is randomly selecting
several input states and checking whether the program changes
the input states.

(a) Original Program

(b) Use test double Uf to re-
place PO which loads quan-
tum memory.

Fig. 6. The usage of test doubles to reduce the cost of testing GS.

F. Integration Testing

Similar to classical programs, bugs can also occur during
the combination of subroutines, so integration testing should
also be run for quantum programs. In this work, we use
Q-UML [41] as guidance for our integration testing. The
beginning of integration testing is to determine the order of
integration. The strategies for classical integration testing can
be migrated into quantum integration testing as well, such as
topological sorting on the dependency graph to determine the
integration order.

During the integration, if an upper subroutine needs to use
a lower subroutine that is unﬁnished, we can use a test double
to replace it. This technique is suitable for testing quantum
programs with oracles. Example 4.4 gives a strategy to test
a program for searching quantum memory using the Grover
algorithm. Test double can also be used to reduce costs and
speed up the testing task. For example, if the testing task
is run on a simulator, quantum arithmetic operations (such
as adder or multiplier on qubits) are slow and consume too
much memory. We can replace them with equivalent classical-
quantum-mixed implementation to speed up the test process
on the simulator.

Example 4.4: A quantum program that searches quantum

memory by the Grover algorithm.

It has two subroutines: (1) general Grover Search subroutine
GS, accepting an oracle; (2) subroutine PO to implement the
oracle of GS, which loads the quantum memory, compares the
contents, and ﬂips the phase of corresponding amplitudes. In
the whole program, GS calls PO, as Figure 6(a) shows.

We can test PO ﬁrst and then combine it into GS. However,
considering the effectiveness of locating bugs and the running
cost (loading a quantum memory may be a costly operation),
it is better to have individual testing for GS. In this case, the
oracle is unﬁnished, and we should use test doubles to replace
it. The test double can be implemented by some ﬁxed unitary
|x(cid:105) → (−1)f (x) |x(cid:105), where the indicator
operations Uf :
function f is chosen and controlled by testers, as Figure 6(b).
Compared with the original PO, Uf avoids loading quantum
memory. Using Uf , GS can be tested individually at a lower
cost.

8

GSPOQuantum Memorycallload (costly)GS𝑈𝑓test doublecall𝑓𝑥V. TOOL SUPPORT
It is necessary to have some tool support for ﬁnishing a text
plan. This section ﬁrst discusses the essential functions which
should be provided by a testing tool and then introduces our
testing tool QSharpTester for Q# programs.

A. Requirements of a Testing Tool

According to the properties of quantum programs (Sec-
tion III) and our testing methods (Section IV), we put forward
four essential functions which should be provided by a testing
tool for multi-subroutine quantum programs:

1. Support of repeated execution of target programs;
2. Support of data processing for quantum information;
3. Support of composition of quantum subroutines;
4. Support of results analysis.
Function 1 is based on the fact that SBD methods (Sec-
tion III-E) are important in detecting output and require the
repeated execution of target programs, while Function 3 is for
multi-subroutine quantum programs. These four functions are
the minimum requirements for a testing tool, and a practical
testing tool should provide more additional functions.

B. QSharpTester: A Testing Tool
Programs

for Multi-Subroutine Q#

Q# provides the package Microsoft.Quantum.XUnit
for users to perform unit testing. It is only a basic framework
supporting test scripts and showing results. Therefore, it is
necessary to build a more powerful testing tool. We imple-
mented QSharpTester, a testing tool for Q# programs, which
includes the following libraries:

• Preparation: It provides methods for preparing common

and important input quantum states.

• Detection: It provides the mechanism for running the
target program repeatedly and some common methods
to detect output testing.

• Assertion: It provides some methods for users to write

test scripts.

• Testing: It provides some preset procedures for per-
forming speciﬁc tests, including the test of inverse or
controlled variants.

• Display: It provides some methods to display the testing

results.

A complete testing task for Q# programs can be ﬁnished
using QSharpTester and Microsoft.Quantum.XUnit. In
the following section, we will evaluate the effectiveness of our
testing methods using QSharpTester.

VI. EVALUATION
We evaluate our testing methods with the following research

questions:

• RQ1: Is covering both classical and superposition states

necessary?

• RQ2: How do our testing methods perform on the

benchmark programs?

• RQ3: Compared with existing testing methods, what are

the advantages of our methods?

A. Benchmark Programs

We use the following seven original Q# programs as a
benchmark to evaluate the effectiveness and necessity of our
testing methods.
(1) Reverse: It reverses the order of qubits (see lines 10-17

in Listing 1).

(2) MultiSWAP: It swaps quantum variables.
(3) QFT: It performs the Quantum Fourier transform (see

lines 19-33 in Listing 1).

(4) invQFT: It performs the inverse Quantum Fourier trans-

form.

(5) Purity: Given a subroutine that generates a given
state ρ, it returns whether ρ is a pure state by several
repetitions.

(6) PhaseShift: A subroutine in Grover.
(7) Grover: Given an oracle, it performs the Grover Search

algorithm.

For each original program, we construct several faulty
programs by mutating the program using the following four
types of mutations:

• Gate Mutation (GM) has four types of operations:
adding, removing, modifying, and reordering the basic
quantum gates in the program.

• Subroutine Mutation (SM) has four types of operations
as well, including adding, removing, and modifying the
call statements in the program, which calls other subrou-
tines and also especially replacing the subroutine with an
error version.

• Classical Mutation (CM) contains the modiﬁcation of
the assignment of classical variables and control ﬂows.
• Measurement Mutation (MM) has three types of opera-
tions: adding, removing, and modifying the measurement
statements in the program.

Note that compared to previous research on testing quantum
programs [4], [18], [46], [47] and quantum platforms [45],
which mainly considers the gate mutations (GMs) as well as
measurement mutations (MMs), our research uses more types
of mutations that are commonly used in practical development
to evaluate our testing method.

Table I shows our benchmark programs in detail, including
their IO marks, program speciﬁcations, and the number of each
type of mutation. For a benchmark program, the number of a
type of mutation may be 0. For example, there is no SM for
a program that does not call other subroutines.

B. Experiment Design and Settings

In our experiment, as Table I shows, we use the ﬁrst four
programs (Reverse, MultiSWAP, QFT, and invQFT) to
answer RQ1 and all seven programs to answer RQ2. The
reason is that the ﬁrst four programs are suitable for using
the CSP criterion.

We use the CSP criterion to partition the quantum input
states of Reverse, MultiSWAP, and QFT. The scale of
Reverse is divided into n = 1 and n > 1, and we choose
n = 6 for n > 1 class. As shown in Example 4.2, the scale

9

TABLE I
BENCHMARK PROGRAMS

Related
RQs

Program

Reverse

IO mark

Program Speciﬁcation

(n, qs) → (qs’)

|j1(cid:105) . . . |jn(cid:105) → |jn(cid:105) . . . |j1(cid:105)

MultiSWAP

(n, qs1, qs2) → (qs1’, qs2’)

(n, qs) → (qs’)

(n, qs) → (qs’)

|j(cid:105) → 1√

2n

|φ(cid:105) |ψ(cid:105) → |ψ(cid:105) |φ(cid:105)
(cid:80)2n−1

k=0 e2πijk/2n
*

|k(cid:105)

RQ1, RQ2

QFT

invQFT

Purity

(n, t, GenRho) → (isPure)

return TRUE if ρ is pure state.

RQ2

PhaseFlip

(n, qs) → (qs’)

|x(cid:105) →

(cid:26) − |x(cid:105)
|x(cid:105)

x > 0
x = 0

Grover

(n, OracleK) → (qs’)

|0(cid:105) → ≈ |K(cid:105)

Number of mutations
GM SM CM MM

16

13

20

18

0

7

3

0

0

16

16

6

0

8

12

8

18

16

7

3

2

10

10

12

12

4

4

3

of QFT and invQFT should be divided into n = 1, n = 2,
and n ≥ 3, and we also choose n = 6 for the n ≥ 3 class.
We use ACoC to combine variable n and qs in Reverse
and QFT, which means that for each condition of n, we test
both classical and superposition inputs. MultiSWAP has three
input variables: n, qs1, and qs2. As our goal is to answer RQ1,
here we only consider the inputs that qs1 and qs2 are both
classical or superposition states.

For invQFT, we assume that we have ﬁnished the testing
of QFT and then use relation (4) to covert the testing task into
identity check: QFT ◦ invQFT = I.

We generate 2n2 test cases for each equivalent class (i.e., 2
cases for n = 1, 8 cases for n = 2 and 72 cases for n = 6), and
use them on each faulty program. Here, we chose the number
2n2 based on our practical experiences considering a balance
between accuracy and running time. We generate each test
case randomly with the support of QSharpTester. Concretely,
for the classical input state class (CI), we use input state |x(cid:105),
where x is a random n-bits binary string. For superposition
input state class (SI), we use input state 1√
(|x(cid:105) + |y(cid:105)), where
2
x and y are two n-bits binary strings. The experiment settings
for these four programs are shown in Table II.

For Purity, the input parameter GenRho is a subroutine to
generate target ρ, and t is the number of repetitions. Purity
contains subroutine MultiSWAP, which estimates the purity
of the target state ρ by swap test [12], [17]. If there is a
round obtaining result “mixed,” Purity will return FALSE;
otherwise, TRUE. We ﬁx t = 10. Note that Purity will run
under mixed ρ so that we can partition GenRho by the CSMP
criterion, although it is not a quantum variable.

For PhaseFlip, since global phases cannot be found by
measurement [39], we should have a ﬁne-grained partition
rather than a coarse-grained CSP or CSMP. According to
is feasible to partition qs into 4
program speciﬁcation,
types: (1) |0(cid:105)1; (2) |x1(cid:105) , x1 > 0; (3)
(|0(cid:105) + |x1(cid:105)), x1 > 0;
(|x1(cid:105) + |x2(cid:105)), x1, x2 > 0, x1 (cid:54)= x2. The output of
(4)
PhaseFilp under input types (1)(2)(4) can not be distin-
guished, whereas (3) can.

1√
2

1√
2

it

1Here |0(cid:105) represents a classical state with integer 0, rather than a single

qubit.

10

For Grover, as Example 4.4 shows, we use some test

doubles to ﬁll the subroutine-type input OracleK.

We use Q# language and its simulator to conduct our
experiments since (1) our methods and benchmark programs
are variable-scale and classical-quantum-mixed, and (2) Q#
is a high-level quantum programming language that supports
this pattern of programs. We run experiments on a personal
computer with an Intel Core i5-10210U CPU and 16 GB
RAM.

C. RQ1: The Necessity of Covering Both Classical and Su-
perposition States

Table II shows the number of trigger test cases. Here
“trigger” means the faulty program is reported as a “fail” under
the test case.

We use SBD methods only for the superposition input states
of QFT, and QRA methods for other cases because no QRA
method is easy to implement for the output of QFT under
superposition input. The number of repetitions of SBD is set
to 200. The number we choose here is also based on practical
experiences considering the balance between accuracy and
running time.

Concretely, Reverse exchange the big endian and little
endian of a qubit array. QSharpTester provides some methods
that can generate or uncompute given states on a qubit array
with a given endian mode. If the Reverse is correct, the
output state under the input state, which is generated by
little endian mode from the all-zero state, can be uncomputed
into the all-zero state by big-endian mode. MultiSWAP
exchanges two-qubit arrays with the same length. Suppose
G1 and G2 generate the input states of qs1 and qs2; the
output states can be uncomputed into all-zero states by G−1
and G−1
1 , respectively. How to check the output state for
QFT under classical input, denoted as |ψj(cid:105) = QFT(|j(cid:105)) =
1√
|k(cid:105), has been shown in Example 4.3.
What remains is how to detect output under a two-value-
superposition input state, which has the form 1√
(|ψa(cid:105)+|ψb(cid:105)),
2
where a and b are two binary strings. There is no intuitive way
to generate this state, but it has a useful property. Suppose for
any j we have Uj such that Uj |0 . . . 0(cid:105) = |ψj(cid:105). Apply U −1

k=0 e2πijk/2n

(cid:80)2n−1

2n

2

a

a [ 1√
2

(|ψa(cid:105) + |ψb(cid:105))] = 1√
2

on the target state: U −1
(|0 . . . 0(cid:105) +
U −1
|ψb(cid:105)). Then about half of the measurement results will
a
be 0. U −1
is similar. We can use statistical methods to check
whether the 0 results occur about half. Speciﬁcally, we give
a tolerance of 0.1, which means the test will pass if the
frequency of 0 results is between 0.4 and 0.6.

b

From the experiment, we can see that due to the repetitions,
the testing tasks running by SBD are slower than that of QRA,
but the trigger rate by SBD is higher than that of QRA. The
reason is that QRA is not a deterministic algorithm. QRA only
ensures it will report a “pass” when the output is correct. It still
has some probability of reporting a “pass” (false negative) for
wrong output. A better method is to repeat the QRA process
several times, just like other random algorithms. If there is at
least one case fail, report “fail.” As long as the probability of
returning correct results is not exponentially small, a reliable
result can be obtained after acceptable repetitions [7].

In the n = 1 class, the trigger rate of each program is always
low. The reason is that n = 1 means not executing loops, so
the mutations inside of loops will not be triggered. According
to the result of n = 1 test cases, we know whether the bugs
are inside or outside the loops.

Interestingly, the trigger rate of MMs by classical input
states is signiﬁcantly lower than that of MMs by superposition
input states. Especially for Reverse and MultiSWAP, clas-
sical input states cannot trigger any MMs. We have further
studied the phenomenon and discovered: (1) If the program
is classical-like, which means it only contains “essentially
classical” gates (such as X, CNOT, and SWAP), classical input
states cannot trigger any MMs. It is because under classical
input states, the computation process is essentially classical,
and measurement will not change the contents of variables. (2)
If the MM occurs at the beginning of a program, classical input
states cannot trigger it. The reason is that measurement will
not change the given input. (3) Some “phase-only” mutations
(such as adding an S or Z gate) cannot be triggered by the
classical input states.

Similarly, we also found that some mutations that can be
triggered by classical input states can not be triggered by su-
perposition input states. This fact implies that superposition is
one of the essential differences between classical and quantum
computing. Thus, covering both classical and superposition
inputs is necessary for testing quantum programs.

D. RQ2: Performance

To show the performance of our testing methods, we use
all seven benchmark programs in Table I. Like Section VI-C,
we use random testing to generate 2n2 test cases for each
equivalence class. The mutation program is killed if one test
case of all equivalence classes fails. Table III gives the number
of unkilled mutations for each benchmark program. Almost all
mutations are killed, which means our testing methods perform
well.

The last column of Table III shows the run time of testing
each program. We can see that the testing tasks can be ﬁnished
on a personal computer and Q# simulator at an acceptable

11

time. The time is related to the number of repetitions of the
measurement in each test case.

We have further studied the unkilled mutations. For the

unique unkilled SM of QFT, the concrete mutation is:

-
+

CRk(qs[j], k, qs[i]); //correct
CRk(qs[i], k, qs[j]); //mutation

The unique unkilled CM of PhaseFlip is:

-
+

Controlled Z(qs[0 .. N - 2], qs[N - 1]);
Controlled Z(qs[1 .. N - 1], qs[0]);

We can prove that the two mutations are equivalent to the
correct program. Actually, they are controlled Z-axis rotation
operations. Here we consider the case of one control qubit
and one target qubit. The general matrix is diag{1, 1, 1, eiθ}
and the status of the control qubit is equivalent to that of
the target qubit. For example, CRk is a case with θ = 1
2k ,
and the ﬁrst mutation is derived by exchanging the control
and target qubits. The equivalence of the second mutation
is for the same reason. Note that qs[1]· · · qs[N-2] are
always controlled qubits before and after the mutation. The
difference is just for qs[0] and qs[N-1]. The mutation is just
exchanging the control/target status of qs[0] and qs[N-1], so
they are equivalent.

The unique unkilled MM of Purity is adding measure-
ment after resetting all qubits, so the redundant measurement
will not change the state of qubits.

E. RQ3: Compared with Existing Methods

Our research aims to develop a novel framework for sup-
porting the test of multi-subroutine quantum programs rather
than a concrete method for some types of programs. It means
that our work and existing methods are not
in the same
hierarchy, so we cannot compare their execution efﬁciency.
However, comparing them from supporting users to ﬁnishing
testing tasks is still valuable.

1) Support Wider Program Types: Compared with existing
methods, the most signiﬁcant advantage of our work is to
support broader types of quantum programs, which contain
quantum programs with complex subroutine structures, vari-
able scales, and complex parameters. Existing methods [4],
[46], [47] focus mainly on the quantum circuit level, and their
deﬁnitions of input and output limit the scope of application.
As Tables I and III show, our methods can deal with not
only usual quantum programs such as Reverse and QFT,
which can also be dealt with by existing methods, but also
programs with complex parameters, such as MultiSWAP (a
program with multiple quantum input variables), Grover (a
program with oracle), and Purity (a program has even no
quantum input variables).

2) Quantum Natures: Unlike existing methods that migrate
classical testing methods into the quantum domain simply, our
work considers more about the nature of a quantum program.
We propose CSP and CSMP criteria that partition quantum
variables by quantum nature rather than considering only
the classical values. As a result, our methods can ﬁnd bugs
related to the nature of a quantum program, which existing

TABLE II
RQ1: NECESSITY EVALUATION FOR COVERING BOTH CLASSICAL(CI) AND SUPERPOSITION(SI) INPUT STATES

Program

Criteria/
Methods

Detection
Method

Reverse

CSP+ACoC

QRA

MultiSWAP

CSP+ECC

QRA

QFT

CSP+ACoC

invQFT

Use
relation (4)

QRA for CI
SBD for SI

Check whether

QFT ◦ invQFT
= I

n

1
6

1
6

1
2
6

1
2
6

#(Test Cases)
SI
CI

76
2736

62
2232

132
528
4752

124
496
4464

76
2736

62
2232

132
528
4752

124
496
4464

#(Trigger by CI)

GM

9
831

18
844

6
86
1186

3
57
943

SM

-
-

-
-

1
63
969

0
52
1062

CM

6
705

7
535

3
67
1135

4
40
1133

MM

0
0

0
0

4
44
493

3
40
595

trigger
rate

19.7%
56.1%

40.3%
61.8%

10.6%
49.2%
79.6%

8.1%
38.1%
83.6%

#(Trigger by SI)

GM

9
963

8
883

12
109
1391

7
78
1086

SM

-
-

-
-

0
96
1077

0
62
954

CM

6
759

6
549

4
92
1290

4
52
1233

MM

5
288

10
330

4
84
830

3
39
718

trigger
rate

26.3%
73.5%

38.7%
78.9%

15.2%
72.2%
96.5%

11.3%
46.6%
89.4%

Run Time
SI
CI

6.1s

7.5s

13.0s

16.2s

18.3s

155
min

24.2s

27.9s

TABLE III
RQ2: RUN TIME AND THE NUMBER OF UNKILLED BENCHMARK
PROGRAMS

Program

Reverse
MultiSWAP
QFT
invQFT
Purity
PhaseFlip
Grover

#(Total
Mutations)

#(unkilled mutations)
GM SM CM MM sum

38
31
66
62
17
14
16

0
0
0
0
0
0
0

0
0
1
0
0
0
0

0
0
0
0
0
1
0

0
0
0
0
1
0
0

0
0
1
0
1
1
0

Run
Time

13.6s
29.2s
156min
52.1s
11.2min
4.5s
2.2min

methods cannot. For example, existing methods cannot test
PhaseFlip.

3) Scalability and Compatibility: As shown in Table II,
existing classical partition and combination coverage criteria
(such as boundary value partition and ACoC combination
criterion) and both QRA and SBD detection methods can be
used in our framework. In addition, our framework can be
compatible with existing methods. For example, we can use
search-based methods [47] to generate test cases rather than
manual construction in some concrete tasks. The evaluation
demonstrates the scalability and compatibility of our frame-
work.

VII. RELATED WORK

Quantum software testing is an emerging research ﬁeld
still in the preliminary stage [48]. Miranskyy and Zhang [34]
discussed the importance and challenges of testing quantum
programs. Miranskyy et al. [36] and Garc´ıa de la Barrera et
al. [19] presented the research progress in quantum software
debugging and testing.

A typical thread of research in this area is to apply well-
established testing methods for classical programs to the
domain of quantum computing. Wang al et. [44] proposed
QuanFuzz, a fuzzy testing method for generating test cases for
quantum programs. Honarvar et al. [25] proposed a property-
based testing method to test the Q# program and developed
a tool called QSharpChecker. Li et al. [30] proposed Proq,
a projection-based runtime assertion tool for testing and de-
bugging quantum programs. Proq uses projection to represent

assertions, which, compared to classical representation, has
more expressive power. Ali et al. [4] deﬁned the input-output
coverage criteria for quantum program testing and used muta-
tion analysis to evaluate the effectiveness of the criteria. Wang
et al. [47] proposed QuSBT, a search-based test case genera-
tion algorithm to generate test cases containing more failure
cases. They also proposed a combinatorial testing approach
called QuCAT [46] to test quantum programs through testing
cases of input variables of the programs. The basic idea of the
approach is to automatically generate test suites of a speciﬁc
size based on the available test budget to maximize the number
of failed test cases in the test suite. Abreu et al. [2] proposed
a metamorphic testing method for oracle quantum programs.
The basic idea is to deﬁne some metamorphic rules speciﬁc to
quantum programs and use these rules to support the testing
of quantum programs. Some researchers also apply mutation
testing and analysis techniques to the domain of quantum
computing to support testing quantum programs [18], [33].
Compared to this thread of research, which mainly applied
speciﬁc testing techniques to quantum programs, our testing
framework can support a complete and systematic test process
for multi-subroutine quantum programs.

Assertions can be used to check quantum states and help
users ﬁnd bugs in quantum circuits and programs. A straight-
forward idea to implement quantum assertions is to prepare
many copies of quantum variables and repeat the measure-
ment. Huang et al. [26] applied hypothesis testing to partially
reconstruct the information of quantum registers according to
the measurement results and implement assertion. However,
implement runtime
the measurement-based method cannot
assertion. Liu et al. [31] proposed that additional qubits can
be introduced to capture the information of the qubits under
assertion, so there is a little interruption for the program
execution during assertion. Li et al. [30] proposed a projection-
based runtime assertion scheme, using the projection operator
to represent the predicates in the assertion. Liu et al. [31]
extended this idea to the assertion of mixed states and ap-
proximate assertion. In this paper, we follow these ideas to
perform output detection of quantum programs.

Building some benchmarks to assess the effectiveness of
different testing methods is necessary. Campos and Souto [28]

12

proposed QBugs, a collection of reproducible bugs in quantum
algorithms for supporting controlled experiments for quantum
software debugging and testing. But it is not available to
assess its details and usability. Zhao et al. [49] proposed
Bugs4Q, an open-source benchmark of 36 real, validated
bugs in practical Qiskit programs, supplemented with the test
cases for reproducing buggy behaviors for supporting quantum
program testing. As these benchmarks become mature, we can
consider using them to evaluate our testing method.

VIII. CONCLUSION

This paper has proposed a novel framework for testing
quantum programs with multiple subroutines. Our framework
contains IO analysis, equivalence class partition, coverage
criteria, and test case generation. To support our framework,
we also implemented QSharpTester, a testing tool for Q#
programs, and conducted experiments using Q# programs to
demonstrate the effectiveness of our testing framework. Our
experiment used a set of Q# benchmark programs, including
seven original correct programs and their 244 faulty mutations
with four mutation types. The experimental results show
that our methods can ﬁnd almost all faulty mutations and
some equivalent mutations and can ﬁnish testing tasks in an
acceptable time on a personal computer with a Q# simulator.
Moreover, although we present our testing framework in the
context of Q# [43], the underlying ideas are applicable to
other quantum programming languages such as Scaffold [1],
Silq [10], and Qiskit [3].

In future work, we plan to investigate several critical issues
further in testing quantum programs,
including (1) giving
a broader deﬁnition of quantum program speciﬁcations, (2)
deﬁning more novel coverage criteria for quantum variables,
especially those related to quantum entanglement, and (3) fur-
ther investigating metamorphic testing of quantum programs.

REFERENCES

[1] ABHARI, A. J., FARUQUE, A., DOUSTI, M. J., SVEC, L., CATU, O.,
CHAKRABATI, A., CHIANG, C.-F., VANDERWILT, S., BLACK, J., AND
CHONG, F. Scaffold: Quantum programming language. Tech. rep.,
Department of Computer Science, Princeton University, 2012.

[2] ABREU, R., FERNANDES, J. P., LLANA, L., AND TAVARES, G. Meta-
In 2022 IEEE/ACM
morphic testing of oracle quantum programs.
3rd International Workshop on Quantum Software Engineering (Q-SE)
(2022), IEEE, pp. 16–23.

[3] ALEKSANDROWICZ, G., ALEXANDER, T., BARKOUTSOS, P., BELLO,
L., BEN-HAIM, Y., BUCHER, D., CABRERA-HERN ´ANDEZ, F. J.,
CARBALLO-FRANQUIS, J., CHEN, A., CHEN, C.-F., CHOW, J. M.,
C ´ORCOLES-GONZALES, A. D., CROSS, A. J., CROSS, A., CRUZ-
BENITO, J., CULVER, C., GONZ ´ALEZ, S. D. L. P., TORRE, E. D. L.,
DING, D., DUMITRESCU, E., DURAN, I., EENDEBAK, P., EVERITT,
M., SERTAGE, I. F., FRISCH, A., FUHRER, A., GAMBETTA, J., GAGO,
B. G., GOMEZ-MOSQUERA, J., GREENBERG, D., HAMAMURA, I.,
HAVLICEK, V., HELLMERS, J., ŁUKASZ HEROK, HORII, H., HU,
S., IMAMICHI, T., ITOKO, T., JAVADI-ABHARI, A., KANAZAWA, N.,
KARAZEEV, A., KRSULICH, K., LIU, P., LUH, Y., MAENG, Y., MAR-
QUES, M., MART´IN-FERN ´ANDEZ, F. J., MCCLURE, D. T., MCKAY,
D., MEESALA, S., MEZZACAPO, A., MOLL, N., RODR´IGUEZ, D. M.,
NANNICINI, G., NATION, P., OLLITRAULT, P., O’RIORDAN, L. J.,
PAIK, H., P ´EREZ, J., PHAN, A., PISTOIA, M., PRUTYANOV, V.,
REUTER, M., RICE, J., DAVILA, A. R., RUDY, R. H. P., RYU, M.,
SATHAYE, N., SCHNABEL, C., SCHOUTE, E., SETIA, K., SHI, Y.,
SILVA, A., SIRAICHI, Y., SIVARAJAH, S., SMOLIN, J. A., SOEKEN,
M., TAKAHASHI, H., TAVERNELLI, I., TAYLOR, C., TAYLOUR, P.,

TRABING, K., TREINISH, M., TURNER, W., VOGT-LEE, D., VUILLOT,
C., WILDSTROM, J. A., WILSON, J., WINSTON, E., WOOD, C.,
WOOD, S., W ¨ORNER, S., AKHALWAYA, I. Y., AND ZOUFAL, C. Qiskit:
An Open-source Framework for Quantum Computing.

[4] ALI, S., ARCAINI, P., WANG, X., AND YUE, T. Assessing the effective-
ness of input and output coverage criteria for testing quantum programs.
In 2021 14th IEEE Conference on Software Testing, Veriﬁcation and
Validation (ICST) (2021), IEEE, pp. 13–23.

[5] AMMANN, P., AND OFFUTT, J. Using formal methods to derive test
frames in category-partition testing. In Proceedings of COMPASS’94-
1994 IEEE 9th Annual Conference on Computer Assurance (1994),
IEEE, pp. 69–79.

[6] AMMANN, P., AND OFFUTT, J.
Cambridge University Press, 2016.

Introduction to software testing.

[7] ARORA, S., AND BARAK, B. Computational complexity: a modern

approach. Cambridge University Press, 2009.

[8] BARNETT, S. M., AND CROKE, S. Quantum state discrimination. arXiv

preprint arXiv:0810.1970v1 (2008).

[9] BENEDETTI, M., LLOYD, E., SACK, S., AND FIORENTINI, M. Param-
eterized quantum circuits as machine learning models. arXiv preprint
arXiv:1906.07682v2 (2019).

[10] BICHSEL, B., BAADER, M., GEHR, T., AND VECHEV, M. Silq: A high-
level quantum language with safe uncomputation and intuitive semantics.
In Proceedings of the 41st ACM SIGPLAN Conference on Programming
Language Design and Implementation (2020), pp. 286–300.

[11] BOYER, M., BRASSARD, G., H?YER, P., AND TAPP, A. Tight bounds

on quantum searching. Tech. rep., 1996.

[12] BUHRMAN, H., CLEVE, R., WATROUS, J., AND DE WOLF, R. Quantum

ﬁngerprinting. Physical Review Letters 87, 16 (2001), 167902.

[13] BURROUGHS, K., JAIN, A., AND ERICKSON, R. L. Improved quality
In
of protocol
Proceedings of ICC/SUPERCOMM’94-1994 International Conference
on Communications (1994), IEEE, pp. 745–752.

testing through techniques of experimental design.

[14] COHEN, D. M., DALAL, S. R., FREDMAN, M. L., AND PATTON, G. C.
The AETG system: An approach to testing based on combinatorial
design. IEEE Transactions on Software Engineering 23, 7 (1997), 437–
444.

[15] COHEN, D. M., DALAL, S. R., KAJLA, A., AND PATTON, G. C. The
In Proceedings of
automatic efﬁcient test generator (AETG) system.
1994 IEEE International Symposium on Software Reliability Engineer-
ing (1994), IEEE, pp. 303–309.

[16] DEUTSCH, D. Quantum theory, the church–turing principle and the
universal quantum computer. Proceedings of
the Royal Society of
London. A. Mathematical and Physical Sciences 400, 1818 (1985), 97–
117.

[17] EKERT, A. K., ALVES, C. M., OI, D. K., HORODECKI, M.,
HORODECKI, P., AND KWEK, L. C. Direct estimations of linear and
nonlinear functionals of a quantum state. Physical review letters 88, 21
(2002), 217901.

[18] FORTUNATO, D., CAMPOS, J., AND ABREU, R. Qmutpy: a mutation
testing tool for quantum algorithms and applications in qiskit.
In
Proceedings of the 31st ACM SIGSOFT International Symposium on
Software Testing and Analysis (2022), pp. 797–800.

[19] GARC´IA DE LA BARRERA, A., GARC´IA-RODR´IGUEZ DE GUZM ´AN, I.,
POLO, M., AND PIATTINI, M. Quantum software testing: State of the
art. Journal of Software: Evolution and Process (2021), e2419.
[20] GREEN, A. S., LUMSDAINE, P. L., ROSS, N. J., SELINGER, P., AND
VALIRON, B. An introduction to quantum programming in Quipper. In
International Conference on Reversible Computation (2013), Springer,
pp. 110–124.

[21] GROVER, L., AND RUDOLPH, T. Creating superpositions that corre-
spond to efﬁciently integrable probability distributions. arXiv preprint
arXiv:quant-ph/0208112 (2002).

[22] GROVER, L. K. A fast quantum mechanical algorithm for database
search. In Proceedings of the twenty-eighth annual ACM symposium on
Theory of computing (1996), pp. 212–219.

[23] GUO, J., LOU, H., LI, R., FANG, W., LIU, J., LONG, P., YING, S.,
isQ: Towards a practical software stack for quantum

AND YING, M.
programming. arXiv preprint arXiv:2205.03866 (2022).

[24] H ¨ANER, T., STEIGER, D. S., SMELYANSKIY, M., AND TROYER, M.
High performance emulation of quantum circuits. In SC’16: Proceedings
of
the International Conference for High Performance Computing,
Networking, Storage and Analysis (2016), IEEE, pp. 866–874.

13

[47] WANG, X., ARCAINI, P., YUE, T., AND ALI, S. Generating failing test
suites for quantum programs with search. In International Symposium
on Search Based Software Engineering (2021), Springer, pp. 9–25.
[48] ZHAO, J. Quantum software engineering: Landscapes and horizons.

arXiv preprint arXiv:2007.07047 (2020).

[49] ZHAO, P., ZHAO, J., MIAO, Z., AND LAN, S. Bugs4Q: A benchmark of
real bugs for quantum programs. In 2021 36th IEEE/ACM International
Conference on Automated Software Engineering (ASE) (2021), IEEE,
pp. 1373–1376.

[25] HONARVAR, S., MOUSAVI, M., AND NAGARAJAN, R. Property-based
testing of quantum programs in Q#. In First International Workshop on
Quantum Software Engineering (Q-SE 2020) (2020).

[26] HUANG, Y., AND MARTONOSI, M. Statistical assertions for validating
In Proceedings of
patterns and ﬁnding bugs in quantum programs.
the 46th International Symposium on Computer Architecture (2019),
pp. 541–553.

[27] JAVADIABHARI, A., PATIL, S., KUDROW, D., HECKEY, J., LVOV, A.,
CHONG, F. T., AND MARTONOSI, M. ScaffCC: a framework for com-
pilation and analysis of quantum computing programs. In Proceedings
of the 11th ACM Conference on Computing Frontiers (2014), pp. 1–10.
[28] JOSE CAMPOS, J., AND SOUTO, A. QBugs: A collection of reproducible
bugs in quantum algorithms and a supporting infrastructure to enable
controlled quantum software testing and debugging experiments.
In
Second International Workshop on Quantum Software Engineering (Q-
SE 2021) (2021), pp. 28–32.

[29] KNILL, E. Approximation by quantum circuits, 1995.
[30] LI, G., ZHOU, L., YU, N., DING, Y., YING, M., AND XIE, Y.
Projection-based runtime assertions for testing and debugging quantum
programs. Proceedings of the ACM on Programming Languages 4,
OOPSLA (2020), 1–29.

[31] LIU, J., BYRD, G. T., AND ZHOU, H. Quantum circuits for dynamic
In Proceedings of the
runtime assertions in quantum computation.
Twenty-Fifth International Conference on Architectural Support
for
Programming Languages and Operating Systems (2020), pp. 1017–1030.
[32] LIU, J., AND ZHOU, H. Systematic approaches for precise and approxi-
mate quantum state runtime assertion. In IEEE International Symposium
on High-Performance Computer Architecture, HPCA 2021, Seoul, South
Korea, February 27 - March 3, 2021 (2021), IEEE, pp. 179–193.
[33] MENDILUZE, E., ALI, S., ARCAINI, P., AND YUE, T. Muskit: A muta-
tion analysis tool for quantum software testing. In 2021 36th IEEE/ACM
International Conference on Automated Software Engineering (ASE)
(2021), IEEE, pp. 1266–1270.

[34] MIRANSKYY, A., AND ZHANG, L. On testing quantum programs.
In 2019 IEEE/ACM 41st International Conference on Software Engi-
neering: New Ideas and Emerging Results (ICSE-NIER) (2019), IEEE,
pp. 57–60.

[35] MIRANSKYY, A., ZHANG, L., AND DOLISKANI, J.

Is your quantum
program bug-free? In 2020 IEEE/ACM 42nd International Conference
on Software Engineering: New Ideas and Emerging Results (ICSE-NIER)
(2020), IEEE Computer Society, pp. 29–32.

[36] MIRANSKYY, A., ZHANG, L., AND DOLISKANI, J. On testing and
debugging quantum software. arXiv preprint arXiv:2103.09172 (2021).
[37] MYERS, G. J. The art of software testing. 1979. A Wiley-Interscience

Publication (1979).

[38] NATIONAL ACADEMIES OF SCIENCES, E., MEDICINE, ET AL. Quan-
tum computing: progress and prospects. National Academies Press,
2019.

[39] NIELSEN, M. A., AND CHUANG, I. L. Quantum Computation and
Quantum Information: 10th Anniversary Edition. Cambridge University
Press, 2010.

[40] PAYKIN, J., RAND, R., AND ZDANCEWIC, S. Qwire: a core language

for quantum circuits. ACM SIGPLAN Notices 52, 1 (2017), 846–858.

[41] P ´EREZ-DELGADO, C. A., AND P ´EREZ-GONZ ´ALEZ, H. G. Towards a
quantum software modeling language. In First International Workshop
on Quantum Software Engineering (Q-SE 2020) (2020).

[42] SHOR, P. W. Polynomial-time algorithms for prime factorization and
discrete logarithms on a quantum computer. SIAM review 41, 2 (1999),
303–332.

[43] SVORE, K., GELLER, A., TROYER, M., AZARIAH, J., GRANADE, C.,
HEIM, B., KLIUCHNIKOV, V., MYKHAILOVA, M., PAZ, A., AND ROET-
TELER, M. Q#: enabling scalable quantum computing and development
In Proceedings of the Real World Domain
with a high-level DSL.
Speciﬁc Languages Workshop 2018 (2018), pp. 1–10.

[44] WANG, J., GAO, M., JIANG, Y., LOU, J., GAO, Y., ZHANG, D., AND
SUN, J. QuanFuzz: Fuzz testing of quantum program. arXiv preprint
arXiv:1810.10310 (2018).

[45] WANG, J., ZHANG, Q., XU, G. H., AND KIM, M. QDiff: Differential

testing of quantum software stacks. ASE.

[46] WANG, X., ARCAINI, P., YUE, T., AND ALI, S. Application of combi-
natorial testing to quantum programs. In 2021 IEEE 21st International
Conference on Software Quality, Reliability and Security (QRS) (2021),
IEEE, pp. 179–188.

14

