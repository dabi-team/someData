Backports: Change Types, Challenges and Strategies

Debasish Chakroborti
University of Saskatchewan
Canada
debasish.chakroborti@usask.ca

Kevin A. Schneider
University of Saskatchewan
Canada
kevin.schneider@usask.ca

Chanchal K. Roy
University of Saskatchewan
Canada
chanchal.roy@usask.ca

2
2
0
2

r
p
A
7

]
E
S
.
s
c
[

1
v
4
6
7
3
0
.
4
0
2
2
:
v
i
X
r
a

ABSTRACT
Source code repositories allow developers to manage multiple ver-
sions (or branches) of a software system. Pull-requests are used
to modify a branch, and backporting is a regular activity used to
port changes from a current development branch to other versions.
In open-source software, backports are common and often need
to be adapted by hand, which motivates us to explore backports
and backporting challenges and strategies. In our exploration of
68,424 backports from 10 GitHub projects, we found that bug, test,
document, and feature changes are commonly backported. We iden-
tified a number of backporting challenges, including that backports
were inconsistently linked to their original pull-request (49%), that
backports had incompatible code (13%), that backports failed to be
accepted (10%), and that there were backporting delays (16 days
to create, 5 days to merge). We identified some general strategies
for addressing backporting issues. We also noted that backporting
strategies depend on the project type and that further investigation
is needed to determine their suitability. Furthermore, we created the
first-ever backports dataset that can be used by other researchers
and practitioners for investigating backports and backporting.

CCS CONCEPTS
• Software and its engineering → Maintaining software.

KEYWORDS
pull-request, port, backport, branches, GitHub

ACM Reference Format:
Debasish Chakroborti, Kevin A. Schneider, and Chanchal K. Roy. 2022.
Backports: Change Types, Challenges and Strategies. In 30th International
Conference on Program Comprehension (ICPC ’22), May 16–17, 2022, Virtual
Event, Pittsburgh, USA.https://doi.org/10.1145/3524610.3527920

1 INTRODUCTION
Pull-based development in version control systems is crucial for
obtaining contributions from both core and external members. A
popular pull-based development platform is GitHub, where pull-
request (PR) creation and submission are major parts of the develop-
ment process. To contribute to an upstream repository (also known
as an original repository) with a pull-request, a contributor first
creates a forked repository (i.e., a personal copy). A pull-request

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA
© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9298-3/22/05. . . $15.00
https://doi.org/10.1145/3524610.3527920

Figure 1: Backports and forwardports among different ver-
sions

can also be submitted by creating a branch. A branch also acts
as an independent copy of the software for development inside a
repository. In both cases, pull-requests can be submitted to any
branch of an upstream repository. After submission, merging is
considered by the reviewers and core members [27] [26].

Merging software changes from one version to another is com-
monly known as porting. The term porting includes changes from
one software system to another, one repository to another, and one
branch to another. Most commonly the term is used with commits,
and there is research [42] [57] [58] [59] [40] on commit porting in
cross-system management. We use the term backport for merging
changes from one repository to another or from the default branch
to other branches for two reasons. First, in source-code repositories,
a default branch always receives all the development activities and
pull-requests, and other branches are just maintained (i.e., not ac-
tively developed) for different versions [38]. So, some changes from
the current development branch (i.e., default branch) are always
ported to previously defined version branches. Second, the term is
commonly used among contributors in the open-source develop-
ment community (i.e., used more than 162,189 times in 10 subject
repositories). Thus, any changes from the default branch to other
branches are called backporting changes in this paper. Similarly,
any changes from other branches to the default branch are called
forwardporting changes. Pull-requests related to these changes
are commonly called backports and forwardports. Fig. 1 shows
three development lines of the same software system: default, v1,
and v2. Development of these different versions/branches can be
pushed from different forked repositories. In this case, two forked
repositories are created for the default branch, and two more are
created for the v1 and v2 series. In the figure, dashed lines depict
initialization of original pull-requests, and solid lines depict du-
plicating pull-requests to create backports/forwardports. Six sets
of pull-requests are shown for three development lines. Each set
represents all the pull-requests to a branch at a particular time and
may contain both pull-requests and backports/forwardports. For
example, Set 1 has three pull-requests, two are normal pull-requests,
and one is a backport from the default series to the v1 series after

v1.0v2.0v3.0v1.1v1.2v1.3v2.1v2.2v2.3v2.4Defaultv1 seriesv2 seriesFuture MilestonesFuture MilestonesFuture MilestonesSet 4Set 6Set 5Forked repositorySame repositoryDuplicating pull-requestsOriginating pull-requestsSet 1Set 2Set 3Pull-request 
 
 
 
 
 
ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Chakroborti and Schneider, et al.

the v1.1 version from Set 6. Similarly, Set 3 has forwardports from
Set 2 and Set 5 has backports from Set 4 for the default branch
and v2 series, respectively. Thus, backports/forwardports can be
generated for different versions; details are discussed in Section 3.
Previously, techniques were proposed for porting commits, specif-
ically, for commit merging among cross-systems [58] [57], but it is
hereto unknown how porting is done in a social coding environ-
ment(e.g., GitHub). Similarly, how porting is related to pull-requests
is unexplored. This work explores a part of backport management
with change types, strategies, and challenges in open-source soft-
ware. In our exploration, we aim to answer the following research
questions that can supplement porting knowledge to open-source
software literature:

RQ1: How are pull-requests backported? Changes can be ported
in many ways among versions. If they are ported with pull-requests
they can be identified by the references/links. Both practitioners and
researchers will be benefited from the knowledge of porting ways
and intuition of versatile techniques to reference pull-requests.

RQ2: What kinds of pull-requests are backported? Tags are used
in repositories for categorizing and organizing pull-requests. Back-
ports are also tagged with various change types. It is important to
know the common changes in backports before making decisions
on them in repositories.

RQ3: What strategies are used for backports? Most of the reposi-
tories maintain contribution documents for instructing both core
and community members. Investigating strategies with data can
reveal current challenges from the required tasks to propose robust
techniques for future management.

RQ4: What challenges are encountered when backporting? This re-
search question will help us to improve the backporting process for
practitioners. Moreover, future research directions can be identified
for overcoming the challenges.

To answer our research questions, we identified and analyzed
68,424 backports from 361,514 pull-requests in 10 subject reposito-
ries and found that there are shortcomings in both research and
management of backports. The main two stages of the backporting
process are (1) identifying backports and (2) merging backports.
There are some tools for identifying backports, but they are logic-
based (e.g., pull-requests from one branch to another branch are
considered to be backports) [6] [24]. For merging, existing commit
porting techniques [58] [57] can be used, but how best to incor-
porate those techniques has not been determined. Since there are
inconsistencies (49%), incompatibles (13%), delays (16 days to create,
5 days to merge), and failures (10%) in backporting, our future work
will be to overcome the problems in both identifying and merging
backports. Towards identifying backports, we created a dataset for
others to use.

Our contributions can be summarized as follows:
1. We identify backporting processes and change types.
2. We explore and summarize the strategies of backporting.
3. We identify challenges in strategies for our future goals.
4. We created a dataset to investigate backports and for sharing

with others.

The paper is organized as follows. Section 2 presents related
work. Section 3 discusses backports. Section 4 presents our data col-
lection process. Section 5 presents backport change types. Section
6 discusses backporting strategies. Section 7 discusses challenges

in backporting. Section 8 answers the research questions. Finally,
sections 9 –11 conclude the paper with future directions and threats
to validity.

2 RELATED WORK
Related studies explored recommending, analyzing, managing, port-
ing, and classifying pull-requests.

Recommending pull-requests. A great number of works have
been done on systems for recommending collaborators. Jiang et al.
[34] analyzed the attributes of pull-based development and found
that activeness is most important for commenter prediction. Simi-
larly, Junior et al. [20] analyzed attributes that can be suitable for
integrator recommendations. Yu et al. [74] [73] analyzed attributes
(i.e., comment network and traditional attributes) to propose a
technique of reviewer recommendation. Soares et al. [63] analyzed
pull-request attributes to propose a reviewer recommender using
association rules. Cheng et al. [70] proposed an algorithm of rec-
ommender that recommends reviewers and reviewer roles. Junior
et al. [19] proposed a technique of assigning developers when their
number is low. Our work also analyzes attributes of pull-based
development that are related to backports. Here, we explore a part
of overall pull-requests (i.e., backports) to investigate change types,
strategies and challenges.

Analyzing pull-requests. A number of studies analyzed pull-
requests. Silva et al. [62] shows technical debt increases pull-request
discussion. Rahman et al. [54] reveals common topics among suc-
cessful and failed pull-requests. Kononenko et al. [39] [38] found
size, people, experiences, and affiliation are important factors for
merging decision and time. Terrell et al. [65] found that female
contributions tend to be accepted more when gender is not speci-
fied. Yu et al. [72] showed that commit size matters for reviewing.
Zampetti et al. [75] showed that build-status has limited influence
on pull-request closing. Gousios et al. [28] found responsiveness,
project compliance, communication are some major challenges of
contributions from social, code, and tools aspects. Similarly, authors
[29] found that time, maintaining quality, reviewing, and rejection
are common challenges for integrators. Similar to these studies,
in our study, we also analyze pull-requests where code changes
are intended for various versions. Contrary to the previous studies
where challenges are investigated for practitioner perspectives, we
identified backporting challenges from the metadata of their usage.
Managing pull-requests. Many studies investigated the orga-
nization of pull-requests. Li et al. [43], Wang et al. [69], Zhixing et al.
[44] proposed techniques for detecting duplicate pull-requests us-
ing the title, description, and time factor. Zampetti et al. [76] found
that online resources are rarely referenced in pull-requests. Mo-
hamed et al. [47] predicted probable reopened pull-requests. Chen
et al. [13] predicted the acceptance of pull-requests using crowed
source knowledge. Coelho et al. [15] distinguished refactoring-
inducing from normal pull-requests in terms of no. of commits,
time to merge and so on. Our study directs us to see some key parts
of backporting that need to be managed to reduce inconsistencies,
incompatibilities, delays, and failures.

Classifying pull-requests and issues. A number of studies
have been done on classifying pull-requests in version control sys-
tems. Azeem et al. [7] classified pull-requests for integrators to

Backports: Change Types, Challenges and Strategies

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

accept, reject, and respond. Li et al. [46] [45] proposed a review-
comment classification algorithm for understanding pull-requests.
Yu et al. [71] proposed a pull-request classification model for la-
belling. Veen et al. [67] prioritized important pull requests by con-
sidering static and dynamic information. Hoang et al. [31] [32]
proposed a deep learning-based approach that can classify patches
into stable and unstable classes. Jiang et al. [33] proposed a neural
network-based tag classifier for pull-requests. Cabot et al. [11] clas-
sified issue labels based on string-based similarities. Izquierdo et al.
[18] developed a visualization tool to show label co-occurrences.
Kallis et al. [36] proposed a tool, Ticket Tagger, based on the fast-
Text model. Mondal et al. [48] showed that natural language can
be used to classify code changes. A major difference between these
works and ours is that we identify backports from pull-requests
and classify backports based on available metadata of changes. (see
Section 5).

Porting commits. Some studies worked on commit porting. Al-
though these studies are not related to a contemporary social coding
environment, we included these here to compare them with our
future interests. Li et al. [42] proposed a semantic slicing algorithm
that can identify history commits for program correction while
porting. Ray et al. [57] proposed a porting analysis tool, Repertoire,
which finds ported edits from BSD cross-systems. Furthermore, Ray
et al. [58] proposed an algorithm to characterize semantic incon-
sistencies for ported code. On the other hand, Ren [59] recently
proposed a prototype for porting patches automatically. However,
their analysis is based on only 200 patches, and full implementation
is still unavailable. Apart from these, Lawall et al. [40] proposed two
tools, Prequel and GCC-reduce, that can help developers to collect
porting information from the Linux kernel. Rodriguez et al. [60]
proposed a backporting strategy using the program transformation
tool Coccinelle that only works with C code for Linux Drivers. Shar-
iffdeen et al. [61] proposed an approach of partial transformation
to backport patches for Linux kernels. Thung et al. [66] proposed
an approach to recommend changes while backporting Linux de-
vice drivers. Decan et al. [21] investigate backporting practices for
package distributions - Cargo, npm, Packagist and RubyGems and
found dependable packages are vulnerable in some versions. The
authors emphasized only on the security vulnerabilities, where we
investigate all types of backports. Also, the work is limited to the
package dependency network, where we explore all the change
propagation in a repository from pull-requests.

Prior studies mostly focus on managing and understanding pull-
requests and commits in version control systems. Our focus is on
backports and understanding current strategies/challenges with
their change types in backporting.

3 BACKPORTS
This section provides backgrounds of backports for subject systems.

Backports to other branches. Generally, a change to the default

branch (i.e., the main or current development branch) may be
merged with other branches using a backport (i.e., we found 18.92%
of the total 361,514 pull-requests are backports). Other branches
refer to any kind of independent line of software that originated
from the default branch. Our analysis suggests that in most cases,
backports are requested by duplicating the original pull-requests
from other branches of forked repositories to other branches of

Figure 2: A pull-request for porting in Elasticsearch

upstream repositories (i.e., 46,530 backports of 68,424, 68% are re-
quested from forked other branches to other branches) for propa-
gating changes from main development line to versions. In addi-
tion, we found some backports where changes propagated between
other branches in the same repository (i.e., 8% of 68,424). The main
reason to initiate backports from other branch to other branch
by duplicating the work of original pull-requests is - the process
is straightforward and merging needs less comparison. In this pro-
cedure, an immediate other branch (i.e., less deviated) is created
to be a head, and the original other branch works as a base. Fig-
ure 1 illustrates more forked repositories and pull-requests from
other branches to other branches in six sets, where backports are
initialized by duplicating original pull-requests.

Forwardports to the default branch. Our investigation iden-
tified a number of examples of merging backports to the default
branch (i.e., 23% of 68,424). For example, Figure 2 shows a forward-
port to the master branch. Forwardports occur in two ways: (1)
when a pull-request is merged with other branches, but the changes
do not exist in the default branch; thus, later the pull-request is
forward ported to the default branch; or, (2) when a pull-request
has already been applied to the default branch, and after a discus-
sion, someone tags it as a backport. In both cases, if a pull-request
is merged to a default branch, then another pull-request can be
created, or other merging methods can be used (e.g., a porting
pull-request) for backporting the commit changes to the desired
branch. We refer to original backporting related pull-requests in
the default branch as forwardports (see Table 4). Forwardporting
is also referred to as reverse backporting, fore-porting and may
even be considered an original pull-request.

Porting pull-requests. A pull-request originates from a head
branch to a base branch. Fig. 3 shows head and base information
of both upstream and forked repositories. While comparing across
existing branches or repositories, one can change the base to submit
a pull-request to different branches. However, submitting a pull-
request in this way can complicate the merging process as some of
the requested changes will be unnecessary. Thus, creating a new
branch (i.e., temp branch in Fig. 3) or forking an updated upstream
branch is easier for submitting and merging pull-requests.

In addition to porting pull-requests, we also found that Git’s
cherry-picking (6.81% of 68,424 backports talk about cherry-picking),
rebase (1% of 68,424), and patching commands (6.01% of 68,424) can
be used to merge backporting commits. Since these techniques are

MemberMemberMemberMemberA month later ReviewerICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Chakroborti and Schneider, et al.

question, feature, documentation, wontfix, and task are com-
mon labels for issues where they classify issue labels in priority,
version, workflow, and architecture classes based on string sim-
ilarities. Similarly, issue labels were presented with visualization of
co-occurrences, user involvements and timelines by Izquierdo et al.
[18]. Jiang et al. [33] classify pull-requests in five families - Mark
function, Give priority, Define status, Describe component,
and Other with a survey while proposing a tag recommender. There
is work on labels that directly predicted labels rather than upper
classes [1] [36] [22]. Abad et al. [1] use text, description, and com-
ment of issues to predict labels by support vector machine and
naive Bayes multinomial. Similarly, Kallis et al. [36] proposed the
Ticket Tagger tool based on the fastText model that can tag issues
as bug reports, feature requests, or questions. Jiang et al. [33] also
showed that tag usages are similar in issues and pull-requests. In
addition, GitHub tags are used in issues and pull-request from the
same corpus, where pull-requests are represented as issues for con-
venience. Here, we classify the labels of pull-requests/backports
based on their semantic representation. We use Word Embedding
in our classification algorithm since it can represent label meanings
more accurately than graph-based models [22].

Table 1: Repository tags clustered by the algorithm

Top Cluster
Component, Team
and Status (7) (10)
(12) (13)
Feature and Library
(14)

Backport, Patch, Sta-
tus (0) (9)

Document
Component (6) (8)

and

Bug and Compo-
nent (11)

Common keywords
collection, aws, cisco,
ansible, community, gcc,
topic, merged, approve
feature, plugin, connec-
tion
backport,
inventory,
patch, gem, approve,
reject
release_note, doc, com-
ponent, darwin, linux,
cloudstack, css
bug, regression, break,
fix, gcc

Description

mostly tags for modules

mostly tags for features

mostly tags for porting
and status

mostly tags for docu-
menting

mostly tags for bug fix-
ing

Algorithm 1 Tag clustering algorithm

tag_sentences = Normalized tags at sentence level

1: tag_Clustering(𝑡𝑎𝑔𝐹𝑖𝑙𝑒)
2: for tags = 1 to 𝐶𝑂𝑈 𝑁𝑇 (𝑡𝑎𝑔𝐹𝑖𝑙𝑒) do
3:
4: end for
5: model = Word2Vec(𝑡𝑎𝑔_𝑠𝑒𝑛𝑡𝑒𝑛𝑐𝑒𝑠)
6: for tags = 1 to 𝑡𝑎𝑔_𝑠𝑒𝑛𝑡𝑒𝑛𝑐𝑒𝑠 do
7:
8: end for
9: clusters = KMeansClusterer(𝑋 _𝑡𝑎𝑔𝑠)
10: Y_tags = TSNE(𝑋 _𝑡𝑎𝑔𝑠)
11: Matplotlib(𝑋 _𝑡𝑎𝑔𝑠, 𝑌 _𝑡𝑎𝑔𝑠, 𝑐𝑙𝑢𝑠𝑡𝑒𝑟𝑠)

X_tags = sentence_Vectorizer(𝑡𝑎𝑔_𝑠𝑒𝑛𝑡𝑒𝑛𝑐𝑒, 𝑚𝑜𝑑𝑒𝑙)

Algorithm 1 illustrates our tag clustering procedure. Since tags
can have more than one word, we treated them as sentences and
normalized them at sentence level in 1-4 lines. First, we tokenized
the tags, removed punctuation, stop words, HTML tags/emojis,
numbers, and at last lemmatized them. Normalized tags are fed in
the Word2Vec model at line 5. Line 6 to 8 are used for averaging

Figure 3: Head and base branches in repositories

rarely used in our subject systems, we excluded them in findings
for not being generalized for their low number.

4 DATA COLLECTION
We collected names of 1,000 top-ranked open-source projects from
the Gitstar Ranking [37] website and randomly sampled 100 projects
(since GitHub API calls are expensive) for our initial analysis. Fig-
ure 4 shows the number of backports and pull-requests for these
100 projects. We match the keyword ‘backport’ from the string
representation of the pull-request’s title, body, tags, and comments.
If the keyword in label or title (i.e., already marked by human
as a backport), we consider the pull-requests as backports. If the
keywords are in body or comments, we consider having it two
times (i.e., it is discussed two times for backporting) to identify
pull-requests as backports. For our detailed analysis, we selected
the top 10 projects (since calculating change percentages are expen-
sive for commits, files, hunks, and lines) based on the number of
backports (i.e., more than 400 to reduce the issues of marketing and
advertising strategies shown by the work [8] and [10]) that ensured
a diverse range of projects and programming languages to support
generalizing our findings. Default branches of the 10 repositories
are identified from the repository settings and activities by the
first author and validated by the second author while manually
investigating the repositories. From the 10 repositories, backports
and forwardports are determined from their backport keywords
and origin information (i.e., base and head), and we found 68,424
backports/forwardports. It should be noted that 79% of the 68,424
pull-requests are confirmed backports from their tagged labels and
the title prefix. For the others (i.e., not tagged with backport but
has backport keywords), we selected 3 random sets with 10 pull-
requests and found, on average, 73% are backports. Thus, more than
90% are confirmed backports in our dataset by the above heuristics.
The GitHub API is used to collect the data as of April 15, 2021. An
overview of the study is shown in Figure 5.

5 BACKPORTING CHANGE TYPES
Labels of pull-requests and issues are used to classify GitHub arti-
facts. There are two sets of labels in GitHub a default set of labels:
bug, duplicate, enhancement, help wanted, question, invalid,
wontfix, good first issue, documentation and custom set
of labels: repository-specific, created by team members.
Both sets are used similarly and are important for both issues, and
pull-requests [22]. Pull-requests or issues are classified in many
ways from their labels. Cabot et al. [11] find enhancement, bug,

Branch 1Branch 2defaultBranch 1Branch 2defaultOriginal RepositoryForked RepositoryComparing and initiating a pull-requestHeadBaseTemp BranchComparing and initiating a pull-requestBackports: Change Types, Challenges and Strategies

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

·105

s
t
s
e
u
q
e
r
-
l
l

u
p
f
o
#

1

0.5

0

Normal Pull-requests Backports

1

4

7

10

13

16

19

22

25

28

31

34

37

40

43

52

49

55
46
Repository

58

61

64

67

70

73

76

79

82

85

88

91

94

97

100

Figure 4: Number of backports and pull-requests for each repository

tags are overlapped semantically among them. We found many tags
are used for identifying modules, components, development team,
development stages (i.e., 1,601 of 3094 in Table 1’s first row). For
example, clusters (i.e., 7, 10, 12, 13) are accumulated together in
the first row of Table 1 since the tags are overlapped semantically
among them. In another cluster (i.e., 14 with 586 tags in the second
row), we found tags are related to features and libraries. Other tags
are mostly scattered with their semantic meaning. However, we
found some backport, status and patch-related tags in clusters 0
and 9. Similarly, document and component tags are overlapped in
clusters 6 and 8. Tags of bug and component are clustered in cluster
11. We identified a couple of clusters with common tags in reposi-
tories. We found that component tags are common in repositories
with status, feature, library, document, backport, and bug tags.

Table 2: Backport tags clustered by the algorithm

Figure 5: Overview of the study

the tag word vectors at the sentence level. In line 9, KMeans algo-
rithm [30] is used for tag clustering, where we kept K = 15 after
trying K from 1 to 20. Line 10 and 11 are used for visualization. We
used TSNE [68] for reducing the data dimension and plotting as
two dimensional. We included visualization in the algorithm since
we assumed fully automated classification of software tags is not
possible with natural language-based Word2Vec. From the visual
representation, we identified top clusters with their assigned num-
bers. Later, we extracted all the tags in different files with respect
to their assigned number. Then, we subdivided or aggregated a few
clusters based on the software development meaning of the tags.
Our algorithm is used in two stages - first, we gathered all tags of 10
subject repositories and clustered them with our algorithm. Figure
6a shows clustering of all 3,094 tags of 10 repositories. In the figure,
we can see that there are a few visible clusters, which are presented
in Table 1. In the table, tags are accumulated from 10 clusters (i.e., 0,
6, 7, 8, 9, 10, 11, 12, 13, 14). Here, we present 5 rows of the clusters
after our manual intervention. For example, clusters (i.e., 7, 10, 12,
13) are accumulated together in the first row of Table 1 since the

Top Cluster
Bug, Security, En-
hancement,
Test
and Documentation
(1) (6) (8) (9) (11)
(12)

Feature (14)

Release

Version,
and Refactor (2)
Component and Sta-
tus (0) (3)

Support (10) (13)

Review and Integra-
tion (5)

Common keywords
bug, security, issue, en-
hancement, bug, fix, re-
lease_note, authentica-
tion, analytic, doc, test,
review, package, feature
core, transform, feature,
visualization
affect, refactor, revision,
patch, sign
module, approve, net-
working, database
core, community, sup-
port

core, review, ci, conflict

Description

mostly tags for changes

mostly tags for features

mostly tags for version-
ing and refactoring
mostly tags for modules
and statues
mostly
core/remote teams
mostly tags for review-
ing

tags

for

In the above clustering, we did not consider the usage of the
tags; we considered their presence in repositories. The clusters
showed us the common tag groups among the 10 subject systems.
We found backport-related tags in the groups, and we explore them
here as well as the common tags used with backports. Figure 6b
represents the clustering of the tags used with all the backports.
Since we considered the usage of the tags, some commonly used
tags are clustered in the middle of the figure. In Table 2, 13 clus-
ters are accumulated in 6 rows. The first row represents 6 clusters
(i.e., 1, 6, 8, 9, 11, 12), here we see different change types of pull-
requests are clustered differently. The reason behind this is that

Pull-requests inGitHubBackports inDatasetRQ1 - RQ4Change TypesText1. Clusteringsubject systemtags2. Clusteringbackport tags CommonClusters10 Subject SystemsStrategiesTextQualitative datacollection fromcontributiondocumentsCommonTasksChallengesTextCommon tasksare verified byquantitative dataof backportsIdentifiedChallengesTagsContributionDocumentsQuantitativeAnalysesAnsweringRQ1-RQ4 StartICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Chakroborti and Schneider, et al.

(a) Repository tags

(b) Backport tags

Figure 6: Tag clustering of repositories and backports

repositories use different prefixes or postfixes in common tags. In
the first row’s clusters, we found 30,912 out of 82,896 tags used
with backports to represent bug, security, enhancement, test, and
documentation type changes. The first three rows of Table 2 show
clusters for different changes. The second row has around 4,332
tags with backports to indicate feature-related changes. The third
row has around 6,969 tags for different versions and refactoring.
As we found component and status tags are common in the reposi-
tories in the fourth row of Table 1, we also see a significant number
of tags are used with backports to indicate component and status
in Table 2. Apart from these, support from remote/core teams, re-
view, and integration scenarios are indicated with tags in backports
(i.e., in fourth and fifth rows, respectively). Our target in Table 2
is related to change types in backports, and they are in the first
three rows. In this stage, again, we manually explored 8 clusters
(i.e., 1, 2, 6, 8, 9, 11, 12, 14) to find common backport types. Here,
backport types indicate the common changes in pull-request while
porting them to other versions. In eight clusters, we found eight
common changes in backports, and they are fixing issues, securing
code base, adding/improving test codes, adding/improving docu-
mentation, refactoring code, adding/improving features, optimizing
performance, and others. Other type includes mainly tags related
to modules, status, team, and releases as they are common in repos-
itories. Similarly, backports are related to releases and versions, so
tags of them are used while backporting. It should be noted that a
pull-request/backport can have multiple tags and different changes.
However, we found change-type tags are mostly used with module,
release, and status tags in backports. Thus, the numbers in our
results that might be overlapped are negligible with other change
types. Here, we did not distinguish them and left as future work to
identify the changes from the code level. Our findings of common
changes in 8 clusters are illustrated in Table 3. In Table 3, we also
gathered the keywords for similar changes to identify them in our
experiments.

Table 3: Change types identified by backport tags

Type

Fix

Security

Keywords
bug, break, fix, broken, error,
fail, issue, fault, regression
encrypt, crypto, security,
auth, ssl, tls, certificate, ssh
test, validation, verification

Test
Document doc, note
Refactor

Feature

Optimize

cleanup, refactor
feature, change, new, design,
visuali
enhance, performance, op-
timi

Other

project specific keywords

Description

issues or bugs fixed

vulnerability patches

test script changes
improved documentation
structure improvements
new or improved functional-
ity

performance improvements

usually used for team and
module management

6 BACKPORTING STRATEGIES
In addition to identifying backport change types, we identified com-
mon backporting strategies. Our investigation of the repositories
and available supporting documents (i.e., contribution documents
collected from GitHub by the first author and discussed with the
second author to find key elements) helps us identify a number of
backporting strategies as written norms used by the subject repos-
itories. Based on the strategies, we also analyzed the backports
and the results are shown in Table 4, Table 5 and Table 6. Table 4
presents the results related to backports, forwardports, and back-
port change types. Table 5 presents the challenges of common tasks
that we identified from the contribution documents. Challenges are
also shown in Table 6 for the backport change types we previously
identified in Section 5. Details are discussed in Section 7. Here, we
present excerpts from the contribution documents of our subject
systems.

Ansible [6] [3] uses a backporting script with pr_id and auto
parameters to indicate the original pull-request. Sometimes back-
port and core_review labels are attached by a bot to each pull-
request that is requested by other branches (i.e., include release

6040200204060604020020406080962377771071414610705015911061012149312061313813131312011714141439101713604020020406060402002040601131110131121311115100111432115241421221120103220115104521150245121314131414152100112311118121411126112121214121211121219114661614699330900001100090060066141219612121214811414661111Backports: Change Types, Challenges and Strategies

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

branches). We found 91.92% of 5,509 backports are tagged with back-
port label in the Ansible repository. Forwardporting pull-requests
in the default branch first and creating changelog fragments (i.e.,
a YAML file) for bug-fix backports are encouraged. They discour-
age features from being backported to other branches. We also
found 70.81% backports of Ansible in Table 4 are related to fixing
bugs. Although features are discouraged, around 8.77% of back-
ports are related to features. Table 4 also shows backports related
to documentation and testing are common in Ansible.

Maintainers of Rails [55] prefer to merge security and bug fix-
ing commits in other branches by backports. Features are usually
not backported unless there is confusion to separate them from
bugs. Core team member resolves confusion after discussions. In
a backporting process, commits are squashed for future mainte-
nance. Merging of backports is done in two ways - small changes
are backported by creating git patches, and separate pull-requests
backport large changes. Similarly, maintainers of OwnCloud [52],
and Symfony [64] prefer to create change-logs for backports since
the backporting is highly related to releases. Bitcoin [9] prefers
for backporting bug and security fixing pull-requests in release
branches, and backports are managed and merged in batches by
core members. Figure 6b’s cluster 2 and Table 2’s third-row show a
large number of release tags are attached to backports.

ElasticSearch’s [23] pull-requests are submitted to the default
branch first; if merged, backports are created for the desired other
branch. ElasticSearch row of Table 4 show a significant number
(i.e., 1,438) of forwardports that are merged in the default branch.
Besides, Table 5 shows only 12% inconsistencies for ElasticSearch,
which is less than the average inconsistencies of 10 subject reposi-
tories.

Maintainers of Julia [35], Nxpkgs [51], and Electron [25] repos-
itories have several discussions to tag required pull-requests in
other branches upon a release. Usually, tagged pull-request com-
mits of Julia and Nxpkgs are cherry-picked to release branches.
This might be the reason for the low number of backports in Ju-
lia and Nxpkgs repositories (i.e., 152 and 1,031) compared to their
pull-request numbers in Table 4. On the other hand, 27.83% of total
pull-requests are backported in Electron with backports.

In the Kibana [24] repository, backports are also merged into
the default branch first. Maintainers also use a script (i.e., an
automatic merging workflow) to merge labeled small backports
automatically. In Table 4, we see a huge number (i.e., 26,888) of
backports for Kibana repository. Besides, for automated mainte-
nance their inconsistency (i.e., 10%) and incompatibility (i.e., 03%)
is low in Table 5.

In the CMSSW [14] and Cpython [53] repositories, maintain-
ers recommend submitting backports with original pull-request
information and backport keywords in the title. As a result, both
repositories have considerable numbers of backports compared to
their total pull-requests, 2,540 and 1,038 in Table 4, respectively.

The preceding examples are for just a few repositories on GitHub.
Nevertheless, backporting is a common mechanism used by most
repositories to port changes among version branches. In Figure 4
we see that out of 1,500,810 pull-requests from 100 repositories,
there are a total of 184,090 backports. Based on our analysis of the
10 subject systems’ contribution documents, bug and security fixing
backports are emphasized in most of the repositories. However, our

analysis revealed other change types are frequently backported.
The most common backport pull-requests apart from bug and secu-
rity fixes are test, document, and adding/modifying small features.
A few repositories discourage including new features in backports,
but feature changes is one of the change types that is frequently
backported. We need to investigate more why feature backports are
discouraged but are backported in most of the repositories. Some
repositories tried to automate parts of the backporting process to
overcome some of the challenges identified in Table 5. Another com-
mon scenario in the repositories we see is to first request backports
to the default branch. Furthermore, backports are highly related
to releases, and how they are affecting the milestones also needs
to be investigated further. Overall, most of the repositories discuss
and pay special attention to handling backports, where backports
are initiated after the original pull-request merging.

7 BACKPORTING CHALLENGES
Even though backporting is common among repositories, a number
of backporting tasks need to be performed manually. We present
these tasks with some challenges after investigating backport-
related data. We are interested to see the link between backports
and forwardports, the amount of changes required in backports,
the time required to identify a backport, and failing information.

Inconsistency. Normally backports are created after a pull-
request is merged to a default branch of an upstream repository.
When creating a backport, it is typical to include a reference to
the original pull-request. For example, Ansible backport #76043
[4] references the original pull-request #76041 [5]. However, we
found that there are many cases when these references are missing
(e.g., Ansible pull-request #14565 [2]). We use the regular expres-
sion r'#[\d]+' to extract a pull-request reference and verify the
reference is an original pull-request with a GitHub API endpoint. In
our analysis of the 10 subject repositories, we found that 49.09% of
backports (see Table 5) do not have this linking. In addition, change
types in Table 6 show inconsistencies between 33.22% to 64.35%.
We can also get some ideas of the inconsistencies from Table 4.
The third and fourth columns of Table 4 show the number of back-
ports and forwardports of each subject system. On average, we
found 5,203.20 backports compared to only 1,639.20 forwardports.
Table 4 shows the number of backports for individual repositories
is always higher than the forwardports except for Bootstrap, Ju-
lia, CPython, and OwnCloud Core where the default branch’s
pull-requests are highly maintained, or they do not have specific
tags for backports. For example, OwnCloud does not have any ex-
plicit backport tag, and default branch pull-requests are discussed
in comments for backporting. Bootstrap, Julia, and CPython use
backport-to-vX or needs_backport tags, and these tags are mostly
for the default branch rather than version branch pull-requests.
Overall, inconsistencies exist on both sides, which can harm both
project management and research.

Incompatibility. Some pull-requests need to be changed to
make them compatible with other branches when backporting. For
example, a backport (i.e., #24323 [16]) of CPython is changed 2%
(i.e., with os_helper.temp_cwd() as cwd: changed to

with support.temp_cwd() as cwd ) from pull-request #23412

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Chakroborti and Schneider, et al.

Table 4: Appearance of backports, forwardports and change types

Repository with pull-request

# Porting (# Normal)

Ansible (44,048)
Nixpkgs (97,100)
Bootstrap (12,067)
ElasticSearch (43,757)
Julia (19,628)
Cpython (24,412)
Electron (13,485)
OwnCloud (19,775)
CMSSW (30,571)
Kibana (56,668)
Average

5,509 (38,539)
1,956 (95,144)
725 (11,342)
11,238 (32,519)
469 (19,159)
5,485 (18,927)
3,881 (9,604)
3,877 (15,898)
4,602 (25,969)
30,682 (25,986)
6,842.80 (29,308.70)

Porting Type

Back
5,044
1,031
72
9,800
152
1,038
3,753
1,714
2,540
26,888
5,203.20

Forward
465
925
653
1,438
317
4,447
128
2,163
2,062
3,794
1,639.20

Fix
3,901
9
7
1,769
82
958
0
334
146
475
768.10

Security Test
1,240
152
1
217
6
0
822
256
10
3
325
60
0
19
992
25
4,586
0
169
299
815.10
103.10

Change types in backports
Document Refactor
1,291
108
215
1,840
23
1,033
20
16
3
3,487
803.60

0
80
0
223
0
0
0
0
0
4
30.70

Feature Optimize Other
483
196
33
1,381
5
2,626
162
206
68
1,789
694.90

12
13
2
551
12
92
1
92
0
231
100.60

292
1,442
469
5,556
340
2,221
3,679
2,324
16
26,453
4,279.20

Table 5: Challenges in pull-request backporting

Repository

Ansible
Nixpkgs
Bootstrap
ElasticSearch
Julia
Cpython
Electron
OwnCloud
CMSSW
Kibana
Average

INC
(%)
53.11
60.63
65.51
22.13
51.38
96.80
17.18
57.03
56.93
10.24
49.09

IPA Creating
(%)
13
18
25
12
20
16
04
11
12
03
13.4

delay(days)
13
21
22
06
25
30
05
18
17
01
15.80

Merging
delay(days)
06 (17)
02 (08)
15 (10)
01 (05)
07 (12)
10 (13)
01 (05)
02 (07)
10 (06)
01 (05)
5.40 (8.83)

Failport
(%)
10.44 (27.24)
12.52 (15.00)
08.41 (46.77)
05.77 (18.21)
08.74 (16.91)
23.20 (12.97)
05.43 (14.55)
12.04 (18.31)
14.10 (18.12)
03.46 (15.31)
10.41 (20.34)

Values in parentheses are for normal pull-requests.
INC = Inconsistency, IPA = Incompatibility.

[17]. In our experiment, we used the Python SequenceMatcher algo-
rithm (i.e., based on Ratcliff/Obershelp pattern-matching algorithm
[56]) and found around 50% of pull-requests need to be changed
with more than 13% code (i.e., details in Table 5). Changing code can
take considerable time and effort to resolve issues while merging
[41], which varies for our subject systems. For example, Table 5’s
third column shows only 3% changes required for Kibana’s backport
where automated approaches are applied for detecting and merging
backports. Thus, backports are created and merged within a day
(i.e., 1 day to create and merge in third and fourth columns). Less
time in creating and merging can be the reason for less incompati-
bility in Kibana, since versions are less diverted in a short period.
Similarly, the Electron repository also shows low incompatibility
04% with 05 days to create backports and 01 days to merge. The
highest incompatibility, 25%, is shown by the Bootstrap repository,
which takes on average 22 days to create and 15 days to merge
backports. Likewise, Julia, CPython, show a high level of incom-
patibility (i.e., 20 and 16, respectively) with 25 to 30 days to create
and 7 to 10 days to merge the backports. There can be a correlation
between incompatibility and delay. One reason can be developers
take time to make the changes compatible while creating and merg-
ing backports. If we look into the incompatibility of each change
type of backports in Table 6, we can see that each type of backports
is needed to be changed, and the changes vary from 10% to 17%.

Creating Delay. Since creating a backport is an independent
task, it might take time. We find that, on average, 16 days are
required to create a backport after the original one is merged in
Table 5. The average creating time varies for different repositories.
The fastest repository to create backport is Kibana, and we found
in the strategies that automated identification and merging are

used in Kibana. On the other hand, Ansible takes 13 days to create
backport, and the repository also uses a script to identify backports.
Thus, how automated techniques are used in repositories need to
be investigated for creating backports in less time. The highest time
required to create backports in CPython repository, if we look into
the inconsistency column of CPython, we can see that around 97%
backports are not consistent with linking, and their incompatibility
rate is also high, around 16%. Similarly, CMSSW (17 days), Nixpkgs
(21 days), Julia (25 days) show a high level of inconsistencies 56.93%,
60.63%, 51.38% with a high level of incompatibilities. Thus, low-level
maintenance can be the reason for the delays in creating backports.
If we look into Table 6 of change types, we see creating delays vary
for different types of backports. Test changes in backports require
a considerable time to create, which is 29 days in Table 6. On the
other hand, refactor and optimize-backports are created in a short
time, 5 and 7 days—more investigation is required to identify the
reasons for change-type importance.

Merging Delay. We investigated the time it takes to merge
backports. On average, 5 to 6 days are required to merge a backport
after its creation (see Table 5). ElasticSearch, Electron, and Kibana
repositories create and merge backports in a short time (e.g., 1
day to merge). Backport merging time for most repositories is
not high, varying between 1 to 7 days. Bootstrap, CPython, and
CMSSW are exceptions, taking 15, 10, and 10 days respectively
to merge a backport as they take time to create them with high
inconsistency. Furthermore, in Table 6 we see Document, Refactor
and Feature backports are merged in a day, whereas Fix and Test
backports require more than five days to merge. Although the
average backport merge time (5.40 days) is less than the normal
pull-request merge time (8.83 days) it is not negligible given they
are already reviewed.

Failport. Similar to a normal pull-request, a backport can also
be rejected for many reasons. Our analysis found that at least 10%
of backports are rejected, which is also less than the 20% rejected
normal pull-requests. The lowest number of backports are rejected
in Kibana, ElasticSearch repositories as we already recognized they
are highly maintained. CPython has the highest percentage of fail-
ports with a high percentage of inconsistencies. Thus, maintenance
can be the reason for the high number of failures. Change type-
wise backports in Table 6 show more failports for tests and features.
Why certain types of backports are failed can be investigated fur-
ther. Moreover, why reviewed pull-requests are failed should be
accounted for investigation by practitioners. Knowing the reasons
for failing to port will be worthwhile to resolve some issues.

Backports: Change Types, Challenges and Strategies

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Table 6: Challenges of change types in backporting

Type

Fix
Security
Test
Document
Refactor
Feature
Optimize

INC
(%)
51.75
52.28
53.66
56.38
33.22
64.35
48.80

IPA Creating
(%)
15
13
17
10
13
10
15

delay (days)
13
19
29
17
05
16
07

Merging
delay (days)
5
3
6
1
1
1
2

Failport
(%)
07.85
05.14
10.27
06.85
04.23
09.84
07.85

INC = Inconsistency, IPA = Incompatibility.

8 RESULTS
In this section, we summarize our findings on backports while
answering our four research questions.

RQ1. How are pull-requests backported? To answer RQ1,
we summarized the contribution documents in Section 6. In gen-
eral, strategies show, backporting commits are merged by creating
new pull-requests. Our data also supports this information; Table 4
shows, on average, 5,203.20 pull-requests are created among the
10 repositories for backporting changes. Maintainers also suggest
having backport changes in the default branch first, and we found
on average 1,639.20 forwardports in default branches from 10 sub-
ject systems. This number could have been higher, but references
are missing in many cases (i.e., 51% of pull-requests were found to
be linked). Apart from this, not all changes are propagated with
backports, other methods such as cherry-picking and patching can
also merge the pull-requests. In general, original pull-requests are
forwardported, then backports are created and backported, where
references to the original pull-requests are written in backports for
future maintenance.

RQ2. What kinds of pull-requests are backported? Table 4
shows the different types of backports. In contribution documents
(i.e., discussed in Section 6), we found that fix and security pull-
requests are commonly backported. Our experiments on such back-
ports in Table 4 show on average 768.10 bug and 103.10 security
fixes are backported. We also found that, on average, test (815.10),
document (803.60), refactor (30.7), feature (694.90), and optimize
(100.60) pull-requests are also backported. As we discussed earlier,
pull-requests can be classified in many ways, and many of the types
are not common in all repositories. Their nonexistence is repre-
sented with zeros in Table 4 if pull-requests do not have specific
tags for the change types or the tags are rarely used. The Other
column in the table shows a considerable number of backports that
represent the pull-requests without any specific change type tags.
Our clustering algorithm in Table 2 suggests that they are mostly
tagged with versions, releases, components, and community-related
labels. In the scope of this study, we only consider tags related to
change types, and columns 5 to 11 represent the results in Table
4. Additionally, Table 6 shows that most backport types have simi-
lar challenges. Overall, pull-requests with all types of changes are
backported, and bug, test, document, and feature changes backports
are more common for most repositories.

RQ3. What strategies are used for backporting? Table 1
shows tags used in repositories for backporting. Since tags are
mostly used to organize issues and pull-requests in repositories,
here backports are also organized with tags that include both “back-
port" and other tags (i.e., change type tags, version tags). Overall,

both backports and forwardports are tagged for default and other
branches, and backports are linked with referenced original pull-
request numbers. Some repositories have introduced techniques
for overcoming backporting challenges, such as automating a part
of the process. For example, Ansible and Kibana automate label
generation. The outcome is visible in Table 5, Kibana repository has
a low number of inconsistencies and incompatibilities compared
to the other repositories and pull-requests numbers. However, the
approaches are logic-based and can be improved. Some studies
work on automating commit-merging, but these need to be ana-
lyzed for different types of backporting. Since considerable time is
required to create and merge backports, automatic identification
and merging can reduce delay and effort for both development and
management teams. However, current strategies are only concerned
with automated labelling, and the benefits of automated merging
still need to be investigated.

RQ4. What challenges are encountered when backport-
ing? We collected data for each of the six challenges as shown
in Section 7. The inconsistency column represents the data of miss-
ing references between backports and original pull-requests in
Table 5. Around 49% of backports are not linked to the original pull-
requests. Similarly, the incompatibility column represents the code
differences of the commit changes from original pull-requests to
backports. The incompatibility column shows that merging required
considerable change in a backport (on average 13%). Inconsistencies
exist in all repositories from 10.24% to 96.80%, and these inconsis-
tencies need to be resolved for future maintenance. On the other
hand, incompatibility needs to be resolved just before the merging
backports, which varies from 03% to 25% among 10 repositories.
Apart from these challenges, considerable time is required to create
and merge a backport after merging the original pull-request. On
average, 15-16 days are required to create a backport and 5-6 days
to merge it. If we compare the merging time (i.e., 5.40 days) against
normal pull-request merging time (8.83 days), we see it takes less
time, and in most of the repositories, backport merging takes less
time (i.e., in between 1 to 15 days) than the normal pull-request
merging time (i.e., in between 5 to 17 days). But it is not negligible
as backports are already reviewed. Besides, the required 16 days to
create backports can propagate other issues in a repository. Like-
wise, the percentage of port changes failure in other branches is
only 10.41 on average, and it varies from 03.46% to 23.20% among
the 10 repositories. This rejection rate is double (20.34) and varies
from 12.97 to 46.77 for normal pull-requests. But again, why al-
ready reviewed backports are failed to port is worth investigating
for future management. Table 6 also shows similar challenges for
the backport types. Moreover, all the change type shows significant
inconsistencies, incompatibilities, and delays. So referencing to or-
ganize, transforming to make compatible, and waiting to create and
merge are the main challenges to overcome for backports.

9 DISCUSSION AND FUTURE DIRECTION
This section discusses the implications of our findings for backport
practitioners and researchers. Figure 4 shows that some projects
have many backports while some have a few. Our work here in-
cludes projects with at least 400 backports to see strategies and chal-
lenges when the backport number is high. However, considering
the backport appearance, projects can be further analyzed for the

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Chakroborti and Schneider, et al.

reasons, impacts, and techniques of backports among the high vari-
ances. We discussed the frequency of the types; however, discussing
their distribution in backports and normal pull-requests can reveal
some key characteristics that might be essential for prediction-
based approaches. Table 5 and 6’s incompatibility columns show
that backports in repositories and change types need to be changed
while porting. In our analysis of Table 4, we found that various
change types (i.e., not only highly emphasized bug-fix and security
changes) are frequently backported. Therefore, what kind of dis-
tinct measures are required for each of them can be investigated
further. For example, other properties of changes should be inves-
tigated rather than just looking for bug or security properties for
backporting. Since we are now familiar with the change amount,
what changes (e.g., resolving dependencies or others) are desired
and how the process can be automated require future exploration.
As well, researchers and contributors need to address inconsisten-
cies before analyzing and organizing backports in repositories. The
above knowledge can help integrators select appropriate tools for
identifying and merging backports.

Backports are already reviewed, but a considerable number of
pull-requests fail to be merged. These failports need to be analyzed,
and how the acceptance rate is related to project characteristics
needs to be explored. Knowledge regarding these can help reviewers
to suggest generic solutions for appropriate versions. Similarly,
a considerable amount of time is required to create and merge
backports. How these can be accomplished in a reasonable time
needs to be analyzed with respect to backporting types. Getting
this knowledge can help release planners to work on milestones
and documentation as relevant artifacts (i.e., pull-requests) need to
be identified in release notes [50] [49]. There can be many ways to
backport (e.g., patching, cherry-picking, and so on) and determining
their suitability for a project is important for project management
decisions.

We plan to analyze the risk factor of backporting in the open-
source community. A more detailed understanding of the character-
istics of repositories and pull-requests is needed in order to develop
general automatic techniques. Current techniques are logic-based
and repository-dependent, whereas more generalized techniques
are required for pull-request linking, identifying, and merging.

In support of future directions, we identified backport change
types and found that bug, test, document, and feature changes are
commonly backported to different versions. As we understand now,
if there is a bug or security fix, the probability that the change
will be backported is high. Similarly, if new test cases are added,
documentation changed, code refactoring performed, optimization
introduced, and even a small feature added, backports can be initi-
ated to maintain the quality of the stable versions. On the contrary,
large and complex changes are preferred to be discarded for stable
branches and need to be investigated for other properties along with
the types and challenges. A few backporting challenges included
link inconsistencies (49%), code incompatibilities (13%), failures
(10%), and delays (e.g., 16 days to create while porting to other
versions). We identified the challenges to indicate obstacles in the
backporting process, and they may not present the developer’s
perspective, and an in-depth survey is required to know the devel-
oper’s perspective. A few repositories used automated approaches
to address some challenges. Our study showed there is evidence

for backporting first to the default branch and some correlation
among inconsistencies, incompatibilities and delays.

10 THREATS TO VALIDITY
Construct validity. We collected our data using backport-related
keywords and extracted backports if the keywords used in pull-
requests occurred more than once. Our assumption for identifying
backports with keywords might not be true for a few cases. How-
ever, more than 90% of the pull-requests in the 68,424 backports of
our dataset are confirmed to be backports from the label, title tags
and analyses. We randomly sampled ten tagged backports to inves-
tigate tagging credibility and found that nine of them are ported
with only backporting changes for particular tasks. The last one is
tagged for porting various changes from a group of pull-requests
for a release branch. Thus, our results of the backporting analysis
are not subject to any chance.

External validity. We chose both backports and normal pull-
requests from GitHub subject systems. Considering the pull-requests
from other environments with respect to their types could have
made the results more generalizable. However, we used 68,424 back-
ports and 293,090 normal pull-requests from the 10 projects (i.e., 2
Python, 1 Nix, 1 JavaScript, 1 Java, 1 Julia, 2 C++, 1 PHP, and 1 Type-
Script based projects) to generalize our findings. Although we have
many backports in our dataset, they are collected from mostly large
projects. There is a chance that the pull-requests may not portray
the pull-requests structure of medium or small projects. However,
we believe that the backports are common in large projects, and the
results can be generalized to use in such cases from the validated
data.

11 CONCLUSION
Our exploratory study investigated backports in open-source soft-
ware, focusing on change types, strategies and challenges. We found
there are various pull-request change types (i.e., fix, security, release,
test, document, refactor, feature, optimize) that are backported dur-
ing software maintenance. Major backporting challenges include
inconsistent links, incompatible code, and delays. Our future goal is
to overcome these challenges by introducing automated techniques
for identifying, tracking, and merging backports. In support of this
goal and to encourage others, we created a dataset that can be used
to propose models for identifying backports.

12 DATA AVAILABILITY
Data are released on Zenodo [12]. The provided dataset contains
repository, pullID, origin, status, label, discussion, and commit infor-
mation of normal pull-request and backports in two CSV files. The
data can be used for binary classifications (i.e., for identification)
and changeset analyses (i.e., for automated merging).

13 ACKNOWLEDGMENTS
This research is supported in part by the Natural Sciences and
Engineering Research Council of Canada (NSERC) Discovery grants,
and by an NSERC Collaborative Research and Training Experience
(CREATE) grant, and by two Canada First Research Excellence
Fund (CFREF) grants coordinated by the Global Institute for Food
Security (GIFS) and the Global Institute for Water Security (GIWS).

Backports: Change Types, Challenges and Strategies

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

REFERENCES
[1] J. Abad, C. L. Nozal, Jesús Maudes, and Raúl Marticorena Sánchez. 2019. Label
prediction on issue tracking systems using text mining. Prog. Artif. Intell. 8 (2019),
325–342.

[2] Ansible. 2021. Avoid Merging Dict and Unicode. https://github.com/ansible/

ansible/pull/14565. [Online; accessed 10-Oct-2021].

[3] Ansible. 2021. Development Process.rst. https://github.com/ansible/ansible/blob/
0543916a866c1238223f2a839fd530b96769bb71/docs/docsite/rst/community/
development_process.rst. [Online; accessed 10-Oct-2021].

[4] Ansible. 2021. Fix Subversion Test. https://github.com/ansible/ansible/pull/76043.

[Online; accessed 10-Oct-2021].

[5] Ansible. 2021. Fix Subversion Test. https://github.com/ansible/ansible/pull/76041.

[Online; accessed 10-Oct-2021].

[6] Ansible. 2021.

https://github.com/ansible/ansible/blob/
a077bca5d5866603cdc4a2a13aef8f416860aacb/hacking/backport/README.md.
[Online; accessed 10-Oct-2021].

Readme.md.

[7] Muhammad Ilyas Azeem, Sebastiano Panichella, Andrea Di Sorbo, Alexander Sere-
brenik, and Qing Wang. 2020. Action-Based Recommendation in Pull-Request De-
velopment. Association for Computing Machinery, New York, NY, USA, 115–124.
https://doi.org/10.1145/3379177.3388904

[8] Sebastian Baltes and Paul Ralph. 2020. Sampling in software engineering research:

A critical review and guidelines. arXiv preprint arXiv:2002.07764 (2020).

[9] bitcoin. 2021.

Contributing.md.

7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/CONTRIBUTING.md.
accessed 10-Oct-2021].

https://github.com/bitcoin/bitcoin/blob/
[Online;

[10] Hudson Borges and Marco Tulio Valente. 2018. What’s in a GitHub Star? Under-
standing Repository Starring Practices in a Social Coding Platform. Journal of Sys-
tems and Software 146 (2018), 112–129. https://doi.org/10.1016/j.jss.2018.09.016
[11] Jordi Cabot, Javier Luis Cánovas Izquierdo, Valerio Cosentino, and Belén Rolandi.
2015. Exploring the use of labels to categorize issues in Open-Source Software
projects. In 2015 IEEE 22nd International Conference on Software Analysis, Evolu-
tion, and Reengineering (SANER). 550–554. https://doi.org/10.1109/SANER.2015.
7081875

[12] Debasish Chakroborti, Kevin Schneider, and Chanchal Roy. 2022. Backport Dataset.

https://doi.org/10.5281/zenodo.5866189

[13] Di Chen, Kathryn T. Stolee, and Tim Menzies. 2019. Replication Can Improve
Prior Results: A GitHub Study of Pull Request Acceptance. In Proceedings of
the 27th International Conference on Program Comprehension (Montreal, Quebec,
Canada) (ICPC ’19). IEEE Press, 179–190. https://doi.org/10.1109/ICPC.2019.00037
[14] Cmssw. 2021. Pull request template.md. https://github.com/cms-sw/cmssw/blob/
6d2f66057131baacc2fcbdd203588c41c885b42c/pull_request_template.md. [On-
line; accessed 10-Oct-2021].

[15] Flávia Coelho, Nikolaos Tsantalis, Tiago Massoni, and Everton LG Alves. 2021.
An Empirical Study on Refactoring-Inducing Pull Requests. arXiv preprint
arXiv:2108.10994 (2021).

[16] CPython. 2021. Fail to Restart the Target. https://github.com/python/cpython/

pull/24323. [Online; accessed 10-Oct-2021].

[17] CPython. 2021. Fail to Restart the Target. https://github.com/python/cpython/

pull/23412. [Online; accessed 10-Oct-2021].

[18] Javier Luis Cánovas Izquierdo, Valerio Cosentino, Belén Rolandi, Alexandre
Bergel, and Jordi Cabot. 2015. GiLA: GitHub label analyzer. In 2015 IEEE 22nd In-
ternational Conference on Software Analysis, Evolution, and Reengineering (SANER).
479–483. https://doi.org/10.1109/SANER.2015.7081860

[19] Manoel Limeira de Lima Júnior, Daricélio Moreira Soares, Alexandre Plastino, and
Leonardo Murta. 2015. Developers Assignment for Analyzing Pull Requests. In
Proceedings of the 30th Annual ACM Symposium on Applied Computing (Salamanca,
Spain) (SAC ’15). Association for Computing Machinery, New York, NY, USA,
1567–1572. https://doi.org/10.1145/2695664.2695884

[20] Manoel Limeira de Lima Júnior, Daricélio Moreira Soares, Alexandre Plastino, and
Leonardo Murta. 2018. Automatic assignment of integrators to pull requests: The
importance of selecting appropriate attributes. Journal of Systems and Software
144 (2018), 181 – 196. https://doi.org/10.1016/j.jss.2018.05.065

[21] Alexandre Decan, Tom Mens, Ahmed Zerouali, and Coen De Roover. 2021. Back
to the Past – Analysing Backporting Practices in Package Dependency Networks.
IEEE Transactions on Software Engineering (2021), 1–1. https://doi.org/10.1109/
TSE.2021.3112204

[22] Joao P Diniz, Daniel Cruz, Fabio Ferreira, Cleiton Tavares, and Eduardo Figueiredo.
2020. GitHub Label Embeddings. In 2020 IEEE 20th International Working Confer-
ence on Source Code Analysis and Manipulation (SCAM). IEEE, 249–253.

[23] Elastic. 2021. pull request template.md. https://github.com/elastic/elasticsearch/

blob/9958c3c2fc49a3e253b04e96cfec2e653c39d2e7/.github/PULL_REQUEST_
TEMPLATE.md. [Online; accessed 10-Oct-2021].

[24] Elastic. 2021.

https://github.com/elastic/kibana/blob/
fd5883b4654ce574837f79c529d38b5f976232e8/x-pack/plugins/infra/README.
md. [Online; accessed 10-Oct-2021].

Readme.md.

[25] Electron. 2021.

Support.md.

265474882c839c8fdeed1917cf3b6671221aa468/docs/tutorial/support.md.
line; accessed 10-Oct-2021].

https://github.com/electron/electron/blob/
[On-

[26] GitHub. 2021. About Branches. https://docs.github.com/en/github/collaborating-
with-pull-requests/proposing-changes-to-your-work-with-pull-requests/
about-branches. [Online; accessed 10-Oct-2021].

[27] GitHub. 2021.

https://docs.github.com/en/github/
collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-
requests/about-pull-requests. [Online; accessed 10-Oct-2021].

About Pull-requests.

[28] Georgios Gousios, Margaret-Anne Storey, and Alberto Bacchelli. 2016. Work
Practices and Challenges in Pull-Based Development: The Contributor’s Perspec-
tive. In Proceedings of the 38th International Conference on Software Engineering
(Austin, Texas) (ICSE ’16). Association for Computing Machinery, New York, NY,
USA, 285–296. https://doi.org/10.1145/2884781.2884826

[29] Georgios Gousios, Andy Zaidman, Margaret-Anne Storey, and Arie van Deursen.
2015. Work Practices and Challenges in Pull-Based Development: The Integra-
tor’s Perspective. In Proceedings of the 37th International Conference on Software
Engineering - Volume 1 (Florence, Italy) (ICSE ’15). IEEE Press, 358–368.

[30] John A Hartigan and Manchek A Wong. 1979. Algorithm AS 136: A k-means
clustering algorithm. Journal of the royal statistical society. series c (applied
statistics) 28, 1 (1979), 100–108.

[31] Thong Hoang, Julia Lawall, Richard J. Oentaryo, Yuan Tian, and David Lo. 2019.
PatchNet: A Tool for Deep Patch Classification. In Proceedings of the 41st Inter-
national Conference on Software Engineering: Companion Proceedings (Montreal,
Quebec, Canada) (ICSE ’19). IEEE Press, 83–86. https://doi.org/10.1109/ICSE-
Companion.2019.00044

[32] T. Hoang, J. Lawall, Y. Tian, R. J. Oentaryo, and D. Lo. 2019. PatchNet: Hierarchical
IEEE
Deep Learning-Based Stable Patch Identification for the Linux Kernel.
Transactions on Software Engineering (2019), 1–1. https://doi.org/10.1109/TSE.
2019.2952614

[33] Jing Jiang, Qiudi Wu, Jin Cao, Xin Xia, and Li Zhang. [n. d.]. Recommending tags
for pull requests in GitHub. Information and Software Technology 129 ([n. d.]),
106394.

[34] Jing Jiang, Yun Yang, Jiahuan He, Xavier Blanc, and Li Zhang. 2017. Who should
comment on this pull request? Analyzing attributes for more accurate commenter
recommendation in pull-based development. Information and Software Technology
84 (2017), 48 – 62. https://doi.org/10.1016/j.infsof.2016.10.006

[35] JuliaLang. 2021.

https://github.com/JuliaLang/julia/blob/
9e7e23d7bde3c0181cb17265e6eab0363ae75611/doc/build/distributing.md. [On-
line; accessed 10-Oct-2021].

distributing.md.

[36] Rafael Kallis, Andrea Di Sorbo, Gerardo Canfora, and Sebastiano Panichella. 2021.
Predicting issue types on GitHub. Science of Computer Programming 205 (2021),
102598. https://doi.org/10.1016/j.scico.2020.102598

[37] Takashi Kokubun. 2014. Gitstar Ranking. https://gitstar-ranking.com/repositories.

[Online; accessed 19-August-2021].

[38] O. Kononenko, T. Rose, O. Baysal, M. Godfrey, D. Theisen, and B. de Water. 2018.
Studying Pull Request Merges: A Case Study of Shopify’s Active Merchant. In
2018 IEEE/ACM 40th International Conference on Software Engineering: Software
Engineering in Practice Track (ICSE-SEIP). 124–133.

[39] Oleksii Kononenko, Tresa Rose, Olga Baysal, Michael Godfrey, Dennis Theisen,
and Bart de Water. 2018. Studying Pull Request Merges: A Case Study of Shopify’s
Active Merchant. In Proceedings of the 40th International Conference on Software
Engineering: Software Engineering in Practice (Gothenburg, Sweden) (ICSE-SEIP
’18). Association for Computing Machinery, New York, NY, USA, 124–133. https:
//doi.org/10.1145/3183519.3183542

[40] Julia Lawall, Derek Palinski, Lukas Gnirke, and Gilles Muller. 2017. Fast and
Precise Retrieval of Forward and Back Porting Information for Linux Device
Drivers. In Proceedings of the 2017 USENIX Conference on Usenix Annual Technical
Conference (Santa Clara, CA, USA) (USENIX ATC ’17). USENIX Association, USA,
15–26.

[41] Olaf Leβenich, Janet Siegmund, Sven Apel, Christian Kästner, and Claus Hunsen.
2018. Indicators for Merge Conflicts in the Wild: Survey and Empirical Study.
Automated Software Engg. 25, 2 (June 2018), 279–313. https://doi.org/10.1007/
s10515-017-0227-0

[42] Yi Li, Chenguang Zhu, Julia Rubin, and Marsha Chechik. 2018. Semantic Slicing
of Software Version Histories. IEEE Transactions on Software Engineering 44, 2
(2018), 182–201. https://doi.org/10.1109/TSE.2017.2664824

[43] Zhixing Li, Gang Yin, Yue Yu, Tao Wang, and Huaimin Wang. 2017. Detect-
ing Duplicate Pull-Requests in GitHub. In Proceedings of the 9th Asia-Pacific
Symposium on Internetware (Shanghai, China) (Internetware’17). Association
for Computing Machinery, New York, NY, USA, Article 20, 6 pages. https:
//doi.org/10.1145/3131704.3131725

[44] Zhixing Li, Gang Yin, Yue Yu, Tao Wang, and Huaimin Wang. 2017. Detect-
ing Duplicate Pull-Requests in GitHub. In Proceedings of the 9th Asia-Pacific
Symposium on Internetware (Shanghai, China) (Internetware’17). Association
for Computing Machinery, New York, NY, USA, Article 20, 6 pages. https:
//doi.org/10.1145/3131704.3131725

ICPC ’22, May 16–17, 2022, Virtual Event, Pittsburgh, USA

Chakroborti and Schneider, et al.

IEEE International Conference on Software Maintenance and Evolution (ICSME).
222–232. https://doi.org/10.1109/ICSME.2016.71

[67] E. v. d. Veen, G. Gousios, and A. Zaidman. 2015. Automatically Prioritizing
Pull Requests. In 2015 IEEE/ACM 12th Working Conference on Mining Software
Repositories. 357–361.

[68] Laurens Van der Maaten and Geoffrey Hinton. 2008. Visualizing data using t-SNE.

Journal of machine learning research 9, 11 (2008).

[69] Qingye Wang, Bowen Xu, Xin Xia, Ting Wang, and Shanping Li. 2019. Duplicate
Pull Request Detection: When Time Matters. In Proceedings of the 11th Asia-Pacific
Symposium on Internetware (Fukuoka, Japan) (Internetware ’19). Association
for Computing Machinery, New York, NY, USA, Article 8, 10 pages. https:
//doi.org/10.1145/3361242.3361254

[70] Cheng Yang, Xun-hui Zhang, Ling-bin Zeng, Qiang Fan, Tao Wang, Yue Yu, Gang
Yin, and Huai-min Wang. 2018. RevRec: A two-layer reviewer recommendation
algorithm in pull-based development model. Journal of Central South University
25, 5 (2018), 1129–1143.

[71] S. Yu, L. Xu, Y. Zhang, J. Wu, Z. Liao, and Y. Li. 2018. NBSL: A Supervised Classi-
fication Model of Pull Request in Github. In 2018 IEEE International Conference
on Communications (ICC). 1–6.

[72] Y. Yu, H. Wang, V. Filkov, P. Devanbu, and B. Vasilescu. 2015. Wait for It: De-
terminants of Pull Request Evaluation Latency on GitHub. In 2015 IEEE/ACM
12th Working Conference on Mining Software Repositories. 367–371.
https:
//doi.org/10.1109/MSR.2015.42

[73] Y. Yu, H. Wang, G. Yin, and C. X. Ling. 2014. Who Should Review this Pull-
Request: Reviewer Recommendation to Expedite Crowd Collaboration. In 2014
21st Asia-Pacific Software Engineering Conference, Vol. 1. 335–342. https://doi.
org/10.1109/APSEC.2014.57

[74] Yue Yu, Huaimin Wang, Gang Yin, and Tao Wang. 2016. Reviewer recommen-
dation for pull-requests in GitHub: What can we learn from code review and
bug assignment? Information and Software Technology 74 (2016), 204 – 218.
https://doi.org/10.1016/j.infsof.2016.01.004

[75] F. Zampetti, G. Bavota, G. Canfora, and M. D. Penta. 2019. A Study on the Interplay
between Pull Request Review and Continuous Integration Builds. In 2019 IEEE
26th International Conference on Software Analysis, Evolution and Reengineering
(SANER). 38–48.

[76] F. Zampetti, L. Ponzanelli, G. Bavota, A. Mocci, M. Di Penta, and M. Lanza.
2017. How Developers Document Pull Requests with External References. In
2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC).
23–33. https://doi.org/10.1109/ICPC.2017.30

[45] Zhixing Li, Yue Yu, Gang Yin, Tao Wang, Qiang Fan, and Huaimin Wang. 2017.
Automatic Classification of Review Comments in Pull-based Development Model.
In SEKE.

[46] Zhixing Li, Y. Yu, G. Yin, T. Wang, and H. Wang. 2017. What Are They Talking
About? Analyzing Code Reviews in Pull-Based Development Model. Journal of
Computer Science and Technology 32 (2017), 1060–1075.

[47] A. Mohamed, L. Zhang, J. Jiang, and A. Ktob. 2018. Predicting Which Pull Requests
Will Get Reopened in GitHub. In 2018 25th Asia-Pacific Software Engineering
Conference (APSEC). 375–385. https://doi.org/10.1109/APSEC.2018.00052
[48] Amit Kumar Mondal, Banani Roy, and Kevin A Schneider. 2019. An Exploratory
Study on Automatic Architectural Change Analysis Using Natural Language
Processing Techniques. In 2019 19th International Working Conference on Source
Code Analysis and Manipulation (SCAM). 62–73.

[49] Sristy Sumana Nath and Banani Roy. 2021. Automatically Generating Release
Notes with Content Classification Models. International Journal of Software Engi-
neering and Knowledge Engineering 31, 11n12 (2021), 1721–1740. https://doi.org/
10.1142/S0218194021400192 arXiv:https://doi.org/10.1142/S0218194021400192

[50] Sristy Sumana Nath and Banani Roy. 2022. Exploring Relevant Artifacts of Release
Notes: The Practitioners’ Perspective. In 2022 IEEE International Conference on
Software Analysis, Evolution and Reengineering (SANER).

[51] NixOS. 2021.

https://github.com/NixOS/nixpkgs/blob/
740ecbc162789b7038cedcbee4e6b543e050e597/CONTRIBUTING.md. [Online;
accessed 10-Oct-2021].

Contributing.md.

[52] Owncloud. 2021. Changelog.md.

https://github.com/owncloud/core/blob/

eebd754771a99bc44820eb67a6d57cea238e6b86/apps/files_external/3rdparty/
monolog/monolog/CHANGELOG.md. [Online; accessed 10-Oct-2021].

[53] Python. 2021. Pull request template.md. https://github.com/python/cpython/
blob/2fc857a5721a5b42bcb696c9cae1bbcc82a91b17/.github/PULL_REQUEST_
TEMPLATE.md. [Online; accessed 10-Oct-2021].

[54] Mohammad Masudur Rahman and Chanchal K. Roy. 2014. An Insight into
the Pull Requests of GitHub. In Proceedings of the 11th Working Conference on
Mining Software Repositories (Hyderabad, India) (MSR 2014). Association for
Computing Machinery, New York, NY, USA, 364–367. https://doi.org/10.1145/
2597073.2597121

[55] Rails. 2021. contributing to ruby on rails.md. https://github.com/rails/rails/blob/
9fb53e0673ed0f563b45b0f5948a1de376547516/guides/source/contributing_to_
ruby_on_rails.md. [Online; accessed 10-Oct-2021].

[56] John W Ratcliff and David E Metzener. 1988. Pattern-matching-the gestalt ap-

proach. Dr Dobbs Journal 13, 7 (1988), 46.

[57] Baishakhi Ray and Miryung Kim. 2012. A Case Study of Cross-System Porting in
Forked Projects. In Proceedings of the ACM SIGSOFT 20th International Symposium
on the Foundations of Software Engineering (Cary, North Carolina) (FSE ’12).
Association for Computing Machinery, New York, NY, USA, Article 53, 11 pages.
https://doi.org/10.1145/2393596.2393659

[58] Baishakhi Ray, Miryung Kim, Suzette Person, and Neha Rungta. 2013. Detect-
ing and characterizing semantic inconsistencies in ported code. In 2013 28th
IEEE/ACM International Conference on Automated Software Engineering (ASE).
367–377. https://doi.org/10.1109/ASE.2013.6693095

[59] Luyao Ren. 2019. Automated Patch Porting across Forked Projects. In Proceedings
of the 2019 27th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (Tallinn, Estonia)
(ESEC/FSE 2019). Association for Computing Machinery, New York, NY, USA,
1199–1201. https://doi.org/10.1145/3338906.3342488

[60] Luis R. Rodriguez and Julia Lawall. 2015. Increasing Automation in the Back-
porting of Linux Drivers Using Coccinelle. In 2015 11th European Dependable
Computing Conference (EDCC). 132–143. https://doi.org/10.1109/EDCC.2015.23
[61] Ridwan Shariffdeen, Xiang Gao, Gregory J. Duck, Shin Hwei Tan, Julia Lawall, and
Abhik Roychoudhury. 2021. Automated Patch Backporting in Linux (Experience
Paper). In Proceedings of the 30th ACM SIGSOFT International Symposium on
Software Testing and Analysis (Virtual, Denmark) (ISSTA 2021). Association for
Computing Machinery, New York, NY, USA, 633–645. https://doi.org/10.1145/
3460319.3464821

[62] Marcelino C.O. Silva, Marco Tulio Valente, and Ricardo Terra. 2016. Does Techni-
cal Debt Lead to the Rejection of Pull Requests? (SBSI 2016). Brazilian Computer
Society, Porto Alegre, BRA, 248–254.

[63] Daricélio M. Soares, Manoel L. de Lima Júnior, Alexandre Plastino, and Leonardo
Murta. 2018. What factors influence the reviewer assignment to pull requests?
Information and Software Technology 98 (2018), 32 – 43. https://doi.org/10.1016/j.
infsof.2018.01.015

[64] Symfony. 2021. Changelog.md. https://github.com/symfony/symfony/blob/
4868dd0504b1af58e8a1cc464709c443131c5d16/src/Symfony/Bridge/Monolog/
CHANGELOG.md. [Online; accessed 10-Oct-2021].

[65] Josh Terrell, Andrew Kofink, Justin Middleton, Clarissa Rainear, Emerson Murphy-
Hill, Chris Parnin, and Jon Stallings. 2017. Gender differences and bias in open
source: Pull request acceptance of women versus men. PeerJ Computer Science 3
(2017), e111.

[66] Ferdian Thung, Xuan-Bach D. Le, David Lo, and Julia Lawall. 2016. Recommend-
ing Code Changes for Automatic Backporting of Linux Device Drivers. In 2016

