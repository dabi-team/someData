2
2
0
2

n
u
J

4
1

]
E
S
.
s
c
[

1
v
0
8
1
7
0
.
6
0
2
2
:
v
i
X
r
a

Integrating deduction and model ﬁnding in a
language independent setting

Carlos G. Lopez Pombo1,2 and Agustín Eloy Martinez Suñé1

1 CONICET-Universidad de Buenos Aires. Instituto de Investigación en Ciencias de
la Computación (ICC)
2 Department of Computing, FCEyN, Universidad de Buenos Aires
{clpombo,aemartinez}@dc.uba.ar

Abstract. Software artifacts are ubiquitous in our lives being an essen-
tial part of home appliances, cars, cel phones, and even in more critical
activities like aeronautics and health sciences. In this context software
failures may produce enormous losses, either economical or, in the ex-
treme, in human lives. Software analysis is an area in software engineering
concerned on the application of diﬀerent techniques in order to prove the
(relative) absence of errors in software artifacts.
In many cases these methods of analysis are applied by following certain
methodological directives that ensure better results. In a previous work
we presented the notion of satisﬁability calculus as a model theoretical
counterpart of Meseguer’s proof calculus, providing a formal foundation
for a variety of tools that are based on model construction.
The present work shows how eﬀective satisﬁability sub-calculi, a special
type of satisﬁability calculi, can be combined with proof calculi, in order
to provide foundations to certain methodological approaches to software
analysis by relating the construction of ﬁnite counterexamples and the
absence of proofs, in an abstract categorical setting.

1 Introduction and motivation

Software artifacts are ubiquitous in our lives being an essential part of home
appliances, cars, cel phones, and even in more critical activities like aeronau-
tics and health sciences. In this context software failures may produce enormous
losses, either economical or, in the extreme, in human lives. In the latter context,
compliance with certain quality standards might be mandatory. Software anal-
ysis is an area in software engineering concerned on the application of diﬀerent
techniques in order to prove the (relative) absence of errors in software artifacts.
Software analysis, usually (if not always) requires that a formal description of
the behaviour of the system, known as its speciﬁcation, must be available. Then,
it is possible to check wether a given property of interest follows from it.

Logics have often been used as formal systems suitable for the speciﬁcation of
software artifacts. Moreover, logical speciﬁcations, due to its formal nature, have

 
 
 
 
 
 
contributed towards the application of sound veriﬁcation techniques. Several
formalisms have been developed to cope with these aspects and most of them
are eﬀective in describing some particular characteristics of software systems.
Among many examples, one can mention:

– linear-time temporal logics, both propositional [1,2] and ﬁrst-order [3], for

describing properties about single executions,

– branching-time temporal logics [4], for describing properties of the class of

potential executions from a given state of the system,

– CTL∗ [5] as a compromise sitting in between linear-time and branching-time

logics,

– the many versions of dynamic logics [6,7], formalising properties of (imper-

ative) sequential programs,

– dynamic linear temporal logic [8], for embedding the dynamic characterisa-

tion of programs within the temporal operators linear temporal logics,

– higher-order logics [9] for capturing several notions like higher-order func-

tions,

– equational logic [10] for capturing abstract data types [11], and the list con-

tinues.

The usefulness of logic in software design and development has always been
some form of universal, and well-documented, truth in computer science. From
Turing’s initial observations, already in [12], stating that “the state of progress
of a computation” is completely determined by a single expression, referred to as
“state formulae”; through Hoare’s “Axiomatic Basis for Computer Programming”
[13], Burstall’s “Proving Properties of Programs by Structural Induction” [14]
and Floyd’s “Assigning meaning to programs” [15], in the 60’s; to Parnas’ “A
Technique for Software Module Speciﬁcation with Examples” [16] and Dijkstra’s
“Guarded Commands, Nondeterminacy and Formal derivation of Programs” [17],
in the 70’s; just to start with.

Formalising a software artefact by resorting to a logical language requires
people involved in the development process to agree on how such descriptions
are to be interpreted and understood, so that the systems can be built in accor-
dance to its description and, therefore, have the expected behaviour. Semantics
plays a central role in this endeavour as it is a way of substituting the perhaps
drier and more esoteric forms provided by syntactic descriptions, by the more
intuitive modes of understanding appealing to some naive form of set theory, but
the metalogical relation between these two inherent aspects of logical languages,
syntax and semantics, might reveal certain discordance with signiﬁcant impact
regarding the appropriateness of the use of one or the other.

Back in the second half of the 70’s, when formal software speciﬁcation was
booming due to the appearance of Abstract Data Types [18] as the main driver in
programming, logic ended up in a privileged position in computer science. Tom
Maibaum, and a group of Brazilian logicians leaded by Paulo Veloso, realised that

the use abstract semantics for interpreting data types speciﬁcations, and thinking
about their representations, was not appropriate. In such a setting, either implicit
or explicit in many diﬀerent approaches at that time [19,20,21,22,23,24,25,26],
not every model is reachable (i.e., those built from objects that cannot be named
by syntactic terms) and, even among those that are, there are some that are
not minimal in the sense that they might satisfy properties other than those
provable from the axioms. They also observed that such minimality was a direct
consequence from requiring models to be initial, as the ADJ group, leaded by
Joseph Goguen, was pushing forward for algebraic speciﬁcation languages [11,27].

Maibaum’s commitment with this view on semantics in computer science is

best understood in his words:

“It cannot be emphasized enough that it is this concept of initiality
which gives rise to the power of the method. Once the requirement of
initiality is relaxed, many of the results and proof methods associated
with the concept disappear.”

Such a strong standpoint motivated him, and his colleagues, to pursue a
research program [28]3 aiming at producing a theory of initiality for ﬁrst order
predicate logic, thus, reproducing ADJ’s results about equational logic, but for
a logical language expressive enough to capture the behaviour of complex data
structures and, therefore, more suitable to software systems speciﬁcation.

In [30] Maibaum cites [31], a seminal paper by Hans-Dieter Ehrich, as an
important source for the motivations behind the foundational notions of the
approach, outstandingly summarised by the former as:

“Why did correct implementations not compose correctly in all cases?
What were the engineering assumptions on which the technical develop-
ments were based? What results were dependent on the formalism used
(some variant of equational logic or FOL4 or whatever) and which were
’universal’?”

Such questions reveal that Maibaum was committed with the provision of a
tool for practical software development, and not just the capricious deﬁnition of
a well-founded theory of software speciﬁcation. Truth be said, while Ehrich and
Maibaum had the same motivations, the work of the former was still focussed on
the equational axiomatisation of abstract data types, while the latter’s program
was moving further to a more expressive logical framework, ﬁrst order predicate
calculus. Much of the progress was documented as technical reports of the in-
stitutions to which the authors were aﬃliated at the time [32,33,34] and later
published in [35,36]. While the main objectives were preserved, the speciﬁcation
language adopted was Lω1,ω [37, Sec. 11.4] (i.e., ﬁrst-order predicate logic with

3 A shorter version was published later in [29].
4 As usual, FOL refers to the ﬁsrt order predicate calculus, or ﬁrst order logic.

equality, admitting conjunctions and disjunctions of denumerable sets of formu-
lae), due to the technical need of what the authors call “namability axioms” (i.e.,
n∈Name(T ) x =T n), for each sort T ) for ensuring
formulae of the shape (∀x : T )(
that any model, from the traditional model theoretic perspective, is reachable.

W

Also in the mid 80’s, Goguen and Burstall introduced Institutions [38] as
a categorical framework aiming at providing a formal framework for deﬁning
the notion of logical system, from a model-theoretic perspective. Thanks to its
categorical presentation, Institutions were key in revealing more elaborate views
on software speciﬁcations (see, for example, those focussed on compositional
speciﬁcations [39,40,41], software development by reﬁnement of speciﬁcations
[42,43] and heterogenous speciﬁcations [44,45,46,47,48,49], among many others)
and elegantly supporting many features pursued in Maibaum’s endeavour, like
well-behaved composition mechanisms, semantically consistent parameterisation
procedures, etc. What for some researchers, like the authors of this work, was
interpreted as a source of mathematical beauty, by enabling a ﬂexible way of for-
malising the notion of satisfaction associated to an arbitrary class of models of
interest, for Maibaum was a deal breaker, Goguen’s departure from mandatory
initial semantics ended the tactical alliance forever.

The theory of Institutions evolved in many directions being General logics
[50] of speciﬁc interest to this work. In it, Meseguer, complemented the deﬁnition
of a logical system from a semantical point of view, provided by institutions, with
a categorical characterisation for the notions of entailment system (also referred
to as π-institutions by Fiadeiro and Maibaum [51]). Such a syntactical view of
a logical system allowed for a more balanced deﬁnition of the notion of Logic,
integrating both formalisations. Thereafter, the author sharply observes that
there might be “a reasonable objection” regarding the abstractness of the notion
of entailment as it hides out the internal structure the entailment relation (i.e.,
the mere notion of proofs). Such an abstract view of the notion of entailment
might be considered more a virtue that a defect, as it enables the possibility
of deﬁning many plausible proof systems, for a single entailment relation (for
example, the same abstract entailment relation between sets of formulae and
formulae can be deﬁned as a Hilbert-style calculus, a natural deduction calculus
or by other means). Then, Meseguer completes his view on logics by proposing
categorical characterisations of the notions of Proof calculus, Proof subcalculus
(the restriction of a proof calculus obtained from identifying the subcategory
of theories and the subset of conclusions that can be drawn from that theory),
and Eﬀective proof subcalculi (a proof subcalculus whose proving method is
guarantied to be eﬀective by requiring sentences, axioms, conclusions and proofs
to be structured in a space [52]).

The reader may have noticed that Meseguer’s viewpoint induced a new, and
further, imbalance towards syntax leaving the semantic aspects of a logical sys-

tem too abstract with respect to the syntactic ones.

Model theoretic-based reasoning techniques constitute an important stream
of research in logic; in particular, these methods play an important role in au-
tomated software validation and veriﬁcation. The origin of this type of logical
reasoning tools can be traced back to the works of Beth [53,54], Herbrand [55]
and Gentzen [56]; Beth’s ideas were used by Smullyan to formulate the tableau
method for ﬁrst-order predicate logic [57]. Herbrandt’s and Gentzen’s work in-
spired the formulation of resolution systems presented by Robinson [58]. Methods
like those based on resolution and tableaux are strongly related to the semantics
of a logic; therefore, they can often be used as the mechanics behind the con-
struction of models. Such a use is not possible in pure deductive methods, such
as natural deduction or Hilbert systems, as formalized by Meseguer.

In [59], Lopez Pombo and some colleagues, forced Maibaum into stretching
his views trying to reach common ground. This was done by introducing a frame-
work, analogous to Meseguer’s mechanisation of the notion of proof, but serving
the purpose of formalising how models are constructed from the sentences they
have to satisfy, and how these “canonically” deﬁned structures relate to the ab-
stract notion of satisfaction formalised by the institution for which the calculus
is being deﬁned. The formalisation of such a constructive view of model theory
received the name of Satisﬁability calculus and was later extended, in analogy
to Meseguer’s presentation of proof systems, to Satisﬁability subcalculus and Ef-
fective satisﬁability subcalculus.

Formal methods are usually divided into two categories: heavyweight and
lightweight. These names refer to the amount of mathematical expertise needed
during the process of proving a given property. For many speciﬁcation languages
a lower degree of involvement equates to a higher degree of automation and,
consequently, to less certainty regarding the satisfaction of the property. Thus
lightweight formal methods, like Alloy [60], cannot usually be entirely trusted
when dealing with models of mission critical systems. An alternative is the use
of heavyweight formal methods, as for instance semi-automatic theorem provers
[61,62,63]. Theorem provers also exhibit limitations, for instance, they usually
require a high level of expertise and strong mathematical skills, that many times
discourages their use. More modern analysis methodologies departed from the
idea that either heavyweight or lightweight formal methods are applied, disre-
garding the relation between these tools. Our claim is that formally enforcing
certain methodological directives as part of the process of software analysis pro-
duces better results in practice. An example of this is Dynamite [64]. Dynamite
is a theorem prover for Alloy in which the critical parts of the proof are assisted
by the Alloy Analyzer with the aim of reducing both the workload and the error
proneness introduced by the human interaction with the tool. Another use of
model theoretic tools in relation to the use of theorem provers is the fact that
they provide an eﬃcient method for: a) gaining conﬁdence in the hypothesis

brought into a proof, b) the elimination of superﬂuous formulae appearing in a
sequent, c) the removal of minor modelling errors, and even d) the suggestion of
potential witnesses for existential quantiﬁers.

Another example of the synergy between deduction and model ﬁnding is
Nitpick [65], an automatic counterexample ﬁnder for Isabelle [63], implemented
using Kodkod [66]. The integration between Nitpick and Isabelle provides the
command nitpick [67] that, when it is applied, ﬁrst translates the current se-
quent to a Kodkod problem consisting of: 1) the type declarations (including
bounds for the amount of atoms to be considered for each one), and 2) a ﬁrst-
order relational logic [68] formula equivalent to the conjunction of the hypothesis
and the negation of the thesis; and then invoques the latter in order to ﬁnd a
model of such a formula.

Nitpick also provides an automatic mode in which the command is applied

every time the user inputs a rule in Isabelle’s command prompt.

In this work we aim at providing a formal link supporting the methodological
interaction between bounded model checkers and theorem provers by connecting
the concrete structures over which models and proofs are represented in their
formalisation as eﬀective satisﬁability sub-calculi and proof calculi, respectively.

The paper is organized as follows. In Sec. 2 we present the deﬁnitions and
results we will use throughout this paper. In Sec. 3 we present a categorical
formalization of satisﬁability sub-calculus and prove relevant results underpin-
ning the deﬁnitions leading to the formalisation of a methodology for software
analysis. In Sec. 4 we present examples in enough detail to exemplify the ideas.
Finally, in Sec. 5, we present some conclusions drawn from the contribution and
propose a direction in which this research can be continued.

2 General logics: the category-theoretic formalisation of

logical systems

From now on, we assume the reader has a nodding acquaintance with basic
concepts from category theory [69,70]. We mainly follow the notation introduced
in [50].

An entailment system is deﬁned by identifying a family of syntactic con-
sequence relations indexed by the elements of a category assumed to be the
category of signatures. As usual, entailment relations are required to satisfy re-
ﬂexivity, monotonicity5 and transitivity.

5 The theory of institutions and general logics focus on monotonic logical systems.
The interested reader is referred to [71] for a presentation of entailment systems for
default logic, a well-known non-monotonic logical system introduced by Reiter in
[72] aiming at the formalisation of defeasible logical reasoning.

Deﬁnition 1 (Entailment system [50]). A structure
is said to be an entailment system if it satisﬁes the following conditions:

Sign, Sen, {⊢Σ}Σ∈|Sign|
(cid:10)

(cid:11)

– Sign is a category of signatures,
– Sen : Sign ! Set is a functor. Let Σ ∈ |Sign|; then Sen(Σ) returns the set

of Σ-sentences, and

– {⊢Σ}Σ∈|Sign|, where ⊢Σ⊆ 2Sen(Σ) × Sen(Σ), is a family of binary relations
such that for any Σ, Σ′ ∈ |Sign|, {φ} ∪ {φi}i∈I ⊆ Sen(Σ), Γ, Γ ′ ⊆ Sen(Σ),
the following conditions are satisﬁed:

• reﬂexivity: {φ} ⊢Σ φ,
• monotonicity: if Γ ⊢Σ φ and Γ ⊆ Γ ′, then Γ ′ ⊢Σ φ,
• transitivity: if Γ ⊢Σ φi for all i ∈ I and {φi}i∈I ⊢Σ φ, then Γ ⊢Σ φ,

• ⊢-translation: if Γ ⊢Σ φ, then for any morphism σ : Σ ! Σ′ in Sign,

and

Sen(σ)(Γ ) ⊢Σ′ Sen(σ)(φ).

Deﬁnition 2 (Theory presentations [50]). Let
be
an entailment system. Its category of theory presentations is Th = hO, Ai such
that:

Sign, Sen, {⊢Σ}Σ∈|Sign|
(cid:10)

(cid:11)

– O = { hΣ, Γ i | Σ ∈ |Sign| and Γ ⊆ Sen(Σ) }, and

– A =

(cid:26)

σ : hΣ, Γ i ! hΣ′, Γ ′i

hΣ, Γ i , hΣ′, Γ ′i ∈ O, σ : Σ ! Σ′ ∈ ||Sign||,
for all γ ∈ Γ, Γ ′ ⊢Σ′ Sen(σ)(γ).

(cid:27)

In addition, if a morphism σ : hΣ, Γ i ! hΣ′, Γ ′i satisﬁes Sen(σ)(Γ ) ⊆ Γ ′, it
is called axiom preserving. By retaining those morphisms of Th that are axiom
preserving, we obtain the subcategory Th0.

(cid:12)
(cid:12)
(cid:12)
(cid:12)

Note that, in the previous deﬁnition, the objects of Th are determined by a
signature and a set of axioms, which are not necessarily closed under entailment.
A theory is obtained from a theory presentations by requiring: 1) the former
to satisfy all the axioms appearing in the latter, and 2) to be closed under
entailment.

Deﬁnition 3 (Closure under entailment). Let
be
an entailment system and hΣ, Γ i ∈ |Th|. We deﬁne • : 2Sen(Σ) ! 2Sen(Σ) as
follows: Γ • =
. This function is extended to elements of Th, by
deﬁning it as follows: hΣ, Γ i• = hΣ, Γ •i. Γ • is called the theory generated by Γ .

Sign, Sen, {⊢Σ}Σ∈|Sign|

Γ ⊢Σ γ

γ

(cid:11)

(cid:10)

(cid:9)

(cid:8)

(cid:12)
(cid:12)

Roughly speaking, an institution is an abstract formalisation of the model
theory of a logic in such a way that the existing relations between signatures,
sentences over a signature and models for a signature are made explicit. These
aspects are reﬂected by introducing the category of signatures, deﬁning two
functors capturing the sets of sentences and the classes of models, the ﬁrst one
going from this category to the category Set and the second one going from this
category to Cat, and by requiring the satisﬁability relation to remain invariant
under signature change.

Deﬁnition 4 (Institution [38]). A structure
is said to be an institution if it satisﬁes the following conditions:

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

(cid:11)

– Sign is a category of signatures,
– Sen : Sign ! Set is a functor. Let Σ ∈ |Sign|, then Sen(Σ) is its corre-

sponding set of Σ-sentences,

– Mod : Signop ! Cat is a functor. Let Σ ∈ |Sign|, then Mod(Σ) is its

corresponding category of Σ-models,

– {|=Σ}Σ∈|Sign| is a family of binary relations |=Σ⊆ |Mod(Σ)| × Sen(Σ), for

all Σ ∈ |Sign|

such that for all σ : Σ ! Σ′ ∈ ||Sign||, φ ∈ Sen(Σ) and M′ ∈ |Mod(Σ′)|, the
following |=-invariance condition holds:

M′ |=Σ′

Sen(σ)(φ)

iﬀ Mod(σop)(M′) |=Σ φ .

Intuitively, the last condition of the previous deﬁnition says that truth is invari-
ant with respect to notation change. Given hΣ, Γ i ∈ |Th|, Mod : Thop ! Cat is
the extension of the functor Mod : Signop ! Cat such that Mod(hΣ, Γ i) denotes
the full subcategory of Mod(Σ) determined by those models M ∈ |Mod(Σ)|
such that M |=Σ γ, for all γ ∈ Γ . The relation |=Σ between sets of formulae
and formulae is deﬁned in the following way: given Σ ∈ |Sign|, Γ ⊆ Sen(Σ) and
α ∈ Sen(Σ),

Γ |=Σ α if and only if M |=Σ α, for all M ∈ |Mod(hΣ, Γ i)|.

Now, from Defs. 1 and 4, it is possible to give a deﬁnition of logic by relating
both its model-theoretic and proof-theoretic characterisations. In this respect,
coherence between the semantic and syntactic entailment relations is required,
reﬂecting the standard concepts of soundness and completeness of logical sys-
tems.

Deﬁnition 5 (Logic [50]).
A structure
if it satisﬁes the following conditions:

(cid:10)

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|

is said to be a logic

(cid:11)

–
–
– the following soundness condition is satisﬁed: for any Σ ∈ |Sign|, φ ∈

Sign, Sen, {⊢Σ}Σ∈|Sign|
Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)
(cid:10)
Sen(Σ), Γ ⊆ Sen(Σ):

is an entailment system,

is an institution, and

(cid:11)

(cid:11)

Γ ⊢Σ φ implies Γ |=Σ φ .

In addition, a logic is complete if the following condition is satisﬁed: for any
Σ ∈ |Sign|, φ ∈ Sen(Σ), Γ ⊆ Sen(Σ):

Γ |=Σ φ implies Γ ⊢Σ φ.

Deﬁnition 1 associates deductive relations to signatures. As already discussed,
it is important to analyse how these relations are obtained. The next deﬁnition
formalises the notion of proof calculus by associating a proof-theoretic structure
to the deductive relations introduced by the deﬁnitions of entailment systems.

Deﬁnition 6 (Proof calculus [50]).
A structure
it satisﬁes the following conditions:

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π

(cid:10)

is said to be a proof calculus if

(cid:11)

is an entailment system,
–
– P : Th0 ! StructP C is a functor. Let T ∈ |Th0|, then P(T ) ∈ |StructP C | is

Sign, Sen, {⊢Σ}Σ∈|Sign|
(cid:10)
the proof-theoretical structure of T 6,

– Pr : StructP C ! Set is a functor. Let T ∈ |Th0|, then Pr(P(T )) is the set
of proofs of T ; the composite functor Pr ◦ P : Th0 ! Set will be denoted by
proofs, and

(cid:11)

– π : proofs ⇒ Sen is a natural transformation such that for each T =
hΣ, Γ i ∈ |Th0| the image of πT : proofs(T ) ! Sen(T ) is the set Γ •. The
map πT is called the projection from proofs to theorems for the theory T .

The use of the category Th0 for indexing proof structures responds to a tech-
nical need. Whenever we relate two theories with a morphism, say σ : hΣ, Γ i !
hΣ′, Γ ′i, the previous deﬁnition imposes a need for extending that relation to
proofs of the form π : ∅ ! α ∈ |proofs(hΣ, Γ i)|. If theories are taken from Th,
we know that there exists π′ : ∅ ! Sen(σ)(α) ∈ |proofs′(hΣ′, Γ ′i)|, but there is
no obvious way to obtain it from π. If theories are taken from Th0, this problem
no longer exists as the proof π′ is obtained by applying exactly the same proof
rules, obtaining the same proof structure (recall the inclusion Sen(σ)(Γ ) ⊆ Γ ′
in the deﬁnition of Th0).

Meseguer’s categorical formulation of a proof calculus is a means of providing
structure for the abstract relation of entailment deﬁned in an entailment system.
The next deﬁnition provides a categorical formalisation of a satisﬁability calculus
as it was presented in [77]. A satisﬁability calculus is the formal characterization
of a method for constructing models of a given theory, thus providing the se-
mantic counterpart of that proof calculus. In the same way Meseguer proceeded
in order to deﬁne a proof calculus, the deﬁnition of a satisﬁability calculus relies
on the possibility of assigning, to each theory presentation, a structure capable
of expressing how its models are constructed.

6 The reader should note that StructP C strongly depends on the structure needed to
formalise the concept of proof for a speciﬁc proof calculus. For example, while in [50,
Ex. 11] the formalisation of natural deduction for ﬁrst-order logic requires the use
of multicategories [50, Def. 10], in [73, §3] the formalisation of the proof calculus for
ω-closure fork algebras with urelements [74, Def. 7] (a variant of fork algebras [75,76]
with a reﬂexive and transitive closure operator) requires the use of strict monoidal
categories [69, Ch. VII, §1] whose monoid of objects is given by the (not necessarily
ﬁnite) subsets of the corresponding class of equations.

Deﬁnition 7 (Satisﬁability calculus [59]).
A structure
ﬁability calculus if it satisﬁes the following conditions:

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:10)

(cid:11)

is said to be a satis-

(cid:11)

–
– M : Thop ! StructSC is a functor. Let T ∈ |Thop|, then M(T ) ∈ |StructSC |

is an institution,

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)
is the model structure of T ,

– Mods : StructSC ! Cat is a functor. Let T ∈ |Thop|, then Mods(M(T )) is
the set of canonical models of T ; the composite functor Mods ◦ M : Thop !
Cat will be denoted by models, and

– µ : models ⇒ P ◦ Mod is a natural transformation such that, for each
T = hΣ, Γ i ∈ |Thop|, the image of µT : models(T ) ! P ◦ Mod(T ) is the
subcategory of Mod(T ) corresponding to each canonical representation of a
class of models in |models(T )|. The map µT is called the projection of the
category of models of the theory T .

The intuition behind the previous deﬁnition is the following. For any theory
T , the functor M assigns a structure in the category StructSC representing the
class of models for T . Notice that the target of functor M, when applied to a
theory T is not necessarily a model but a structure representing the category of
models of T . The reader may have already noticed that the functor M is con-
travariant with respect to category Th, reﬂecting the existing opposite direction
of morphisms between categories of models with respect to those between signa-
tures found in institutions (see Def. 4). The functor Mods maps the structure
representing the class of models of a theory T = hΣ, Γ i to a category whose
objects are canonical representations of models of Γ . Finally, for any theory T ,
the functor µT relates each of these structures to the corresponding subcategory
of Mod(T ).

Example 1 (Tableau Method for First-Order Predicate Logic). Let us start by
presenting the well-known tableaux method for ﬁrst-order logic [57]. Let us de-
note by IF OL =
the institution of ﬁrst-order
predicate logic [38, Exs. 2 and 3]. Let Σ ∈ |Sign| and S ⊆ Sen(Σ); then a
tableau for S is a tree such that:

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

(cid:11)

1. the nodes are labeled with sets of formulae (over Σ) and the root node is

labeled with S,

2. if u and v are two connected nodes in the tree (u being an ancestor of v),
then the label of v is obtained from the label of u by applying one of the
following rules:

X ∪ {A ∧ B}
X ∪ {A ∧ B, A, B}

[∧]

X ∪ {A ∨ B}

X ∪ {A ∨ B, A}

X ∪ {A ∨ B, B}

[∨]

X ∪ {¬¬A}
X ∪ {¬¬A, A}

[¬1]

X ∪ {A}
X ∪ {A, ¬¬A}

[¬2]

X ∪ {A, ¬A}
Sen(Σ)

[false]

X ∪ {¬(A ∧ B)}
X ∪ {¬(A ∧ B), ¬A ∨ ¬B}

[DM1]

X ∪ {¬(A ∨ B)}
X ∪ {¬(A ∨ B), ¬A ∧ ¬B}

[DM2]

[t is a ground term.]

[c is a new constant.]

X ∪ {(∀x)P (x)}
X ∪ {(∀x)P (x), P (t)}

X ∪ {(∃x)P (x)}
X ∪ {(∃x)P (x), P (c)}

[∀]

[∃]

τ α1
1−−! s2

τ α0
0−−! s1

τ α2
2−−! . . . is a branch if: a) s0 is the
A sequence of nodes s0
root node of the tree, and b) for all i ≤ ω, si ! si+1 occurs in the tree, τ αi
i
is an instance of one of the rules presented above, and αi are the formulae
τ α2
2−−! . . .
of si to which the rule was applied. A branch s0
in a tableau is saturated if there exists i ≤ ω such that si = si+1. A branch
τ α2
2−−! . . . in a tableau is closed if there exists i ≤ ω and

τ α0
0−−! s1

τ α1
1−−! s2

τ α1
1−−! s2

τ α0
0−−! s1

s0
α ∈ Sen(Σ) such that {α, ¬α} ⊆ si.

Let s0

τ α0
0−−! s1

τ α1
1−−! s2

τ α2
2−−! . . . be a branch in a tableau. Examining the rules
presented above, it is straightforward to see that every si, with i < ω, is a set of
formulae. In each step, we have either the application of a rule decomposing one
formula of the set into its constituent parts with respect to its major connective,
while preserving satisﬁability, or the application of the rule [false] denoting the
fact that the corresponding set of formulae is unsatisﬁable. Thus, the limit set
of the branch is a set of formulae containing subformulae (and “instances” in
the case of quantiﬁers) of the original set of formulae for which the tableau was
built. As a result of this, every open branch represents, by means of the set of
formulae occurring in the leaf, the class of models satisfying them.

In order to deﬁne the tableau method as a satisﬁability calculus, we have to
provide formal deﬁnitions for the categories supporting tableaux structures, for
the functors M and Mods and for the natural transformation µ.

First, given Σ ∈ |Sign| and Γ ⊆ Sen(Σ), we deﬁne Str Σ,Γ = hO, Ai such
that O = 2Sen(Σ) and A = {α : {Ai}i∈I ! {Bj}j∈J | α = {αj}j∈J }, where for
all j ∈ J , αj is a branch in a tableau for Γ ∪ {Bj} with leaves ∆ ⊆ {Ai}i∈I
Str Σ,Γ can be proved to be a category (see Lemma 7 for a detailed proof). Then,
, where ∪ : Str Σ,Γ × Str Σ,Γ ! Str Σ,Γ is the
we can prove that
typical bi-functor on sets and functions, and ∅ is the neutral element for ∪, is a
(cid:11)
strict monoidal category (see Lemma 8 for details).

Str Σ,Γ , ∪, ∅
(cid:10)

Second, using the previous deﬁnition we can introduce the class of legal
tableaux (denoted by StructSC ), together with a class of arrows, and prove it
is a category. StructSC is deﬁned as hO, Aiop where O = {
| Σ ∈
Str Σ,Γ , ∪, ∅
|Sign| ∧ Γ ⊆ Sen(Σ)}, and A = {
| σ :
hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th||}, the homomorphic extensions of the morphisms in
(cid:10)
||Th|| to sets of formulae preserving the application of rules (i.e., the structure
of the tableaux) (see Lemma 9 for a detailed proof).

Str Σ,Γ , ∪, ∅
Str Σ′,Γ ′
(cid:11)
(cid:10)
, ∪, ∅
E
D

σ :

!

b

(cid:11)

Third, the functor M must be understood as the relation between a the-
ory in |Th| and its corresponding category of structures representing legal
tableaux. So, for every theory hΣ, Γ i, M associates to it the strict monoidal
Str Σ,Γ , ∪, ∅
category [69, Sec. 1, pp. 157]
, and for every theory morphism
σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th|| observed in the opposite direction, M as-
(cid:11)
(cid:10)
σ : Str Σ,Γ ! Str Σ′,Γ ′
which is the homomor-
sociates to it a morphism
phic extension of σ to the structure of the tableaux, also observed in the
opposite direction. Then, M : Thop ! StructSC is deﬁned as M(hΣ, Γ i) =
Str Σ,Γ , ∪, ∅
σop, where
(cid:10)
is the homomorphic extension of σ to the
σ :

and for any σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th||, M(σop) =

Str Σ,Γ , ∪, ∅

, ∪, ∅

!

b

(cid:11)

b

Str Σ′,Γ ′
D

E

(see Lemma 10 for a detailed proof).

(cid:10)

structures in
b

(cid:11)

Str Σ,Γ , ∪, ∅
(cid:10)

(cid:11)

Fourth, the functor Mods provides the means for obtaining theory pre-
sentations characterising classes of models from structures of the form Str Σ,Γ
by identifying the sets of formulae in the leaves of the open branches of a
tableau. To this eﬀect, Mods : StructSC ! Cat is deﬁned on objects as
Str Σ,Γ , ∪, ∅
Mods(
(cid:10)

) = hO, Ai where:
(cid:11)

– O =

hΣ,∆i∈|Th|

S

Σ,

∆

∈ |Th|

D

E

e





(∃α : ∆ ! ∅ ∈ ||Str Σ,Γ ||)
(∀α′ : ∆′ ! ∆ ∈ ||Str Σ,Γ ||)

(∆′ = ∆) ∧ (
¬(∃ϕ)({¬ϕ, ϕ} ⊆

∆ ! ∅ ∈ α)∧
∆)}

e

,





(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(i.e., 1. the existentially quantiﬁed α : ∆ ! ∅ ∈ ||Str Σ,Γ || is a tableau,
2. stating that for any α′ : ∆′ ! ∆ ∈ ||Str Σ,Γ ||, the equation ∆′ = ∆ holds,
∆ ! ∅ is a
expresses that α is saturated, and 3. requesting that
branch of α, is not inconsistent, expresses that it is the set of formulae at
the leaf of an open branch), and

∆, where

e

e

e

– A = {idT : T ! T | T ∈ O}, (i.e., only the identities);

and on morphisms as for all σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th||, Mods(
σop)(hΣ, δi) =
hΣ′, Sen(σ)(δ)i. This is proved to be a functor (see Lemma 11 for a detailed
proof).

b

Finally, µ has to relate the structures representing saturated tableaux with
the model satisfying the set of formulae denoted by the source of the morphism;
then we can deﬁne µhΣ,∆i : models(hΣ, ∆i) ! P ◦ Mod(hΣ, ∆i) as for all
hΣ, δi ∈ |models(hΣ, ∆i)|, µhΣ,∆i(hΣ, δi) = Mod(hΣ, δi) and prove it to be a
natural transformation (see Lemma 12 for details).

Therefore, we conclude that

a satisﬁability calculus.

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:10)

(cid:11)

is

Deﬁnition 8. Let Σ ∈ |Sign| and Γ ⊆ Sen(Σ), then we deﬁne Str Σ,Γ = hO, Ai
such that O = 2Sen(Σ) and A = {α : {Ai}i∈I ! {Bj}j∈J | α = {αj}j∈J }, where
for all j ∈ J , αj is a branch in a tableau for Γ ∪ {Bj} with leaves ∆ ⊆ {Ai}i∈I.
It should be noted that ∆ |=Σ Γ ∪ {Bj}.

Lemma 1. Let Σ ∈ |Sign| and Γ ⊆ Sen(Σ); then
, where ∪ :
Str Σ,Γ × Str Σ,Γ ! Str Σ,Γ is the typical bi-functor on sets and functions, and ∅
(cid:11)
is the neutral element for ∪, is a strict monoidal category.

Str Σ,Γ , ∪, ∅
(cid:10)

Proof. The proof can be found in Lemma 8.

Using this deﬁnition we can introduce the category of legal tableaux, denoted

by StructSC.

Deﬁnition 9. StructSC is deﬁned as hO, Ai where O = {Str Σ,Γ | Σ ∈ |Sign| ∧
σ : Str Σ,Γ ! Str Σ′,Γ ′
| σ : hΣ, Γ i ! hΣ′, Γ ′i ∈
Γ ⊆ Sen(Σ)}, and A = {
||Th||}, the homomorphic extension of the morphisms in ||Th||.

b

Lemma 2. StructSC is a category.

Proof. The proof can be found in Lemma 9.

The functor M must be understood as the relation between a theory in
|Th| and its category of structures representing legal tableaux. So, for every
theory T , M associates the strict monoidal category [69]
, and
for every theory morphism σ : hΣ, Γ i ! hΣ′, Γ ′i, M associates a morphism
(cid:11)
σ : Str Σ,Γ ! Str Σ′,Γ ′
which is the homomorphic extension of σ to the structure
of the tableaux.
b
Deﬁnition 10. M : Thop ! StructSC is deﬁned as M(hΣ, Γ i) =
and M(σ : hΣ, Γ i ! hΣ′, Γ ′i) =

Str Σ,Γ , ∪, ∅
Str Σ′,Γ ′
(cid:10)
(cid:11)
, the

Str Σ,Γ , ∪, ∅

, ∪, ∅

σ :

!

(cid:10)

Str Σ,Γ , ∪, ∅
(cid:10)

(cid:11)

D
Str Σ,Γ , ∪, ∅
(cid:10)

E

.
(cid:11)

homomorphic extension of σ to the structures in

b

Lemma 3. M is a functor.

Proof. The proof can be found in Lemma 10.

In order to deﬁne Mods, we need the following auxiliary deﬁnition, which

provides the maximal consistent sets of formulae for a given set of formulae.

Deﬁnition 11. Let Σ ∈ |Sign|, ∆ ⊆ Sen(Σ), then Cn(∆) is deﬁned as follows:

Cn(∆) = {∆ | (∀α ∈ Sen(Σ))(α 6∈ ∆ =⇒ |Mod({α} ∪ ∆)| = ∅)}

Given hΣ, Γ i ∈ |Th|, the functor Mods provides the means for obtaining the
category containing all the possible maximal consistent extensions of those struc-
tures in Str Σ,Γ representing the closure of the branches in saturated tableaux.

Deﬁnition 12. Mods : StructSC ! Cat is deﬁned as

Str Σ,Γ , ∪, ∅
– Mods(
(cid:10)

) =
α ∧ (∀α′ : ∆′ ! ∆ ∈ ||Str Σ,Γ ||)(∆′ = ∆))}, and
(cid:11)

S
– forall σ : hΣ, Γ i ! hΣ′, Γ ′i such that M(σ) =

{Cn(

e

∆) | (∃α : ∆ ! ∅ ∈ |Str Σ,Γ |)(

∆ ! ∅ ∈

σ, Mods(

e
σ)(∆) =

b

b

Sen(σ)(∆).

Lemma 4. Mods is a functor.

Proof. The proof can be found in Lemma 11.

Finally, the natural transformation µ relates the structures representing sat-
urated tableaux with the model satisfying the set of formulae denoted by the
source of the morphism.

Deﬁnition 13. Let T ∈ |Th|, then we deﬁne µT : models(T ) ! Cat as
µT (∆) = Mod(hSign(∆), ∆i)7.

then we deﬁne µΣ : modelsop(hΣ, Γ i) !
Fact 21 Let hΣ, Γ i ∈ |Th|,
Mod(hΣ, Γ i) deﬁned as in Def. 29. Let Σ ∈ |Sign| and Γ ⊆ Sen(Σ), then
µhΣ,Γ i is a functor.

Lemma 5. µ is a natural transformation.

Proof. The proof can be found in Lemma 12.

Now, from Lemmas 3, 4, and 5, and considering the hypothesis that IF OL is

an institution, the following corollary follows.

Corollary 1.
calculus.

(cid:10)

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|, M, Mods, µ

is a satisﬁability

(cid:11)

The reader interested in the details of the proofs is pointed to [59, Ex. 3.2].

As we mentioned in the introduction, model theory and proof systems are
closely related and, in general, logical properties such as soundness and com-
pleteness are established by relating the families of entailment and satisfaction
relations as we showed in Def. 5. As a consequence of having reﬁned the notions
of entailment and satisfaction by introducing concrete representations (i.e. proof
calculus and satisﬁability calculus, respectively), soundness and completeness
can be reformulated in terms of the structures used for representing proofs and
models.

The following proposition gives an alternative deﬁnition of soundness and

completeness.

7 Sign : Th ! Sign is the forgetful functor that projects the signature from theory

presentations.

Proposition 1. Let the structure
be a logic, the structure
Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|, M, Mods, µ
and the structure
a satisﬁability calculus. Therefore, if T = hΣ, Γ i ∈ |Th0| and α ∈ Sen(Σ):

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|
(cid:11)
(cid:10)
be a proof calculus
be

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:10)

(cid:11)

(cid:10)

(cid:11)

[Soundness] If there exists τ ∈ |proof(T )| such that πT (τ ) = α, then for all
M ∈ |models(T )| and M ∈ |µT (M )|, M |=Σ α.

[Completeness] If for all M ∈ |models(T )| and M ∈ |µT (M )|, M |=Σ α,
then there exists τ ∈ |proof (T )| such that πT (τ ) = α.

Therefore, soundness can be reformulated in order to support the known fact
stating that the evidence of the existence of a counterexamples is a suﬃcient
fact to conclude that there cannot exists a proof.

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|

Corollary 2. Let the structure
be
be a proof calculus and
a logic, the structure
the structure
be a satisﬁability cal-
culus. Therefore, for all T = hΣ, Γ i ∈ |Th0| and α ∈ Sen(Σ), if there exists
M ∈ |models(T )| and M ∈ |µT (M )| such that M |=Σ α does not hold, then
there is no τ ∈ |proof (T )| such that πT (τ ) = α.

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:10)

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:10)

(cid:10)

(cid:11)

(cid:11)

(cid:11)

Now, on the one hand, Def. 7 provides the means for deﬁning speciﬁc mech-
anisations of the satisﬁability relation |=Σ, with Σ ∈ |Sign|, but, on the other
hand, being able to use Coro. 3 requires asserting that a model M does not
satisﬁes a formula α, written above as “M |=Σ α does not hold”. Luckily, most
of the logical languages have some form of negation in their syntax that, from a
semantical point of view, translates into a complementation of the notion of satis-
faction. This notion is usually referred to as for an institution to “have negation”,
understood as, for the language of that institution, to have a syntactic device
whose behaviour, from a model-theoretic perspective, is that of a negation. The
next deﬁnition formalises this notion.

Deﬁnition 14. Given a institution I, we say that I has negation if for every
signature Σ ∈ |Sign|, α ∈ Sen(Σ), there exists a formula in Sen(Σ), usually
denoted as ¬α, such that for all M ∈ Mod(Σ),

M |=Σ ¬α iﬀ M |=Σ α does not hold.

Therefore, Coro. 2 can be reformulated as follows.

Corollary 3. Let the structure
a logic, the structure

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|

be
be a proof calculus and

(cid:11)

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:10)

(cid:10)

(cid:11)

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|, M, Mods, µ
the structure
be a satisﬁability cal-
(cid:10)
has negation. Therefore, for all
culus such that
T = hΣ, Γ i ∈ |Th0| and α ∈ Sen(Σ), if there exists M ∈ |models(T )| and
M ∈ |µT (M )| such that M |=Σ ¬α, then there is no τ ∈ |proof (T )| such that
πT (τ ) = α.

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

(cid:11)

(cid:11)

3 Satisﬁability subcalculus, eﬀectiveness and the

foundations for combining deduction and model ﬁnding

In the introduction we mentioned the tool Dynamite [64] as the result from com-
bining the capabilities of the bounded model checker Alloy [60] and a theorem
prover for the language of ﬁrst-order relational logic [68], implemented on top
of the theorem prover PVS. In this section we present the formal elements un-
derlying this way of combining (bounded) counterexample ﬁnding with theorem
proving from a language independent setting.

As we mentioned in Sec. 1, in [50], Meseguer not only developed the idea of
formalising the notion of proof calculus as an “implementation” of an entailment
system, but also explored the possibility of restricting a proof calculus in such a
way that the result is a subcalculus for a restriction of the language with speciﬁc
properties. The next deﬁnition, introduced in [59] presentes a model-theoretic
counterpart of Meseguer’s deﬁnitions of proof subcalculus.

Deﬁnition 15 (Satisﬁability subcalculus). A satisﬁability subcalculus is
Sign, Sen, Mod, Sign0, ax, {|=Σ}Σ∈|Sign|, M, Mods, µ
a structure of the form
satisfying the following conditions:
(cid:10)

(cid:11)

–
– Sign0 is a subcategory of Sign called the subcategory of admissible signatures;

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)
the restriction of the functor Sen to Sign0 will be denoted by Sen0,

is an institution,

(cid:11)

– ax : Sign0

! Set is a subfunctor of the functor obtained by composing
Sen0 with the powerset functor, i.e., there is a natural inclusion ax(Σ) ⊆
P(Sen0(Σ)) for each Σ ∈ Sign0. Each Γ ∈ ax(Σ) is called a set of admis-
sible axioms. This deﬁnes a subcategory Thax of Th whose objects are theory
presentations T = hΣ, Γ i with Σ ∈ Sign0 and Γ ∈ ax(Σ), and whose mor-
phisms are axiom-preserving theory morphisms H such that H is in Sign0.
op|, then M(T ) ∈

op ! StructSC is a functor. Let T ∈ |Thax

– M : Thax

|StructSC | is the model structure of T ,

– Mods : StructSC ! Cat is a functor. Let T ∈ |Thax

the set of canonical models of T ; the composite functor Mods◦M : Thax
Cat will be denoted by models, and

– µ : models ⇒ P ◦ Mod is a natural transformation such that, for each
op|, the image of µT : models(T ) ! P ◦ Mod(T ) is the
T = hΣ, Γ i ∈ |Thax
subcategory of Mod(T ) corresponding to each canonical representation of a

op|, then Mods(M(T )) is
op !

class of models in |models(T )|. The map µT is called the projection of the
category of models of the theory T .

There are no major diﬀerences with respect to [50, Def. 14], except for the
lack of restriction on the possible conclusions that the sub-calculus can draw.
Notice that in the case of proof theoretic approaches, the introduction of a func-
tor restricting the conclusions, as a sub functor of Sen, is a key element of the
deﬁnition introduced for restricting the set of theorems of interest, in contrast
with satisﬁability calculi, where models only relate to a given theory presenta-
tion, there is not such need.

Example 2 (Tableau Method as a satisﬁability subcalculus for the quantiﬁer-free
and ground fragment of ﬁrst-order predicate logic). This example strongly relays
on Ex. 1 as the language for which we present a satisﬁability subcalculus is a
restriction of the language of ﬁrst-order predicate logic.

We ﬁrst proceed to deﬁne the basic restriction of the language of ﬁrst order

predicate logic by determining Sign0 and ax:

– Sign0 = Sign,
– ax is the composition of a functor Qf

! Set yielding, for each
Σ ∈ |Sign|, the restriction of Sen(Σ) to the quantiﬁer-free sentences, with
Pﬁn .

: Sign0

Once we established the restriction of the language, M is deﬁned exactly as
in Ex. 1 but considering only those tableaux that do not contain any application
of rules [∀] and [∃]. Notice that these rules are not required as they can only
be applied to sets of formulae containing a quantiﬁed formula which, by the
restriction stated before, do not exists.

Finally, Mods and µ are deﬁned exactly as in Ex. 1.

The next deﬁnition introduces the notion of eﬀectiveness of the procedure
for constructing structures characterising models for sets of sentences over a
logical (sub)language. To this end, we follow Meseguer’s approach [50, Def. 16],
which, in turn, adopts the axiomatic view of computability outlined by Shoenﬁeld
in [52]. The elementary notions are those of a ﬁnite object, a space of ﬁnite
objects, and recursive functions. In Shoenﬁeld’s own words, a ﬁnite object is
an “object which can be speciﬁed by a ﬁnite amount of information”, a space
is “an inﬁnite class X of ﬁnite objects such that, given a ﬁnite object x, we
can decide whether or not x belongs to X”. Now, given spaces X and Y , a
recursive function f : X ! Y is then a total function that can be computed
by an algorithm (i.e., by a terminating program, disregarding space and time
limitations); spaces and recursive functions form a category Space. Eﬀectiveness
is then obtained by restricting sentences and axioms over selected signatures to
be organised in a space.

Deﬁnition 16 (Eﬀective
subcalculus
fective
Sign, Sen, Mod, Sign0, Sen0, ax, {|=Σ}Σ∈|Sign|, M, Mods, µ
following conditions:
(cid:10)

satisﬁability
is

subcalculus).
structure Q of

satisﬁability

a

(cid:11)

An

the
satisfying

ef-
form:
the

–
– Sign0 is a subcategory of Sign called the subcategory of admissible signatures;

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)
let J : Sign0 ֒! Sign be the inclusion functor.

is an institution.

(cid:11)

– Sen0 : Sign0

! Space is a functor such that U ◦ Sen0 = Sen ◦ J, where

U : Space ! Set is the obvious forgetful functor.

– ax : Sign0

! Space is a subfunctor of the functor obtained by composing
Sen0 with the functor Pﬁn : Space ! Space, that sends each space to the
space of its ﬁnite subsets. This deﬁnes a subcategory Thax of Th whose objects
are theories T = hΣ, Γ i with Σ ∈ Sign0 and Γ ∈ ax(Σ), and whose mor-
phisms are axiom-preserving theory morphisms H such that H is in Sign0.
op|, then M(T ) ∈

op ! StructSC is a functor. Let T ∈ |Thax

– M : Thax

|StructSC | is the model structure of T .

– Mods : StructSC ! Space is a functor. Let T ∈ |Thax

op|, then Mods(M(T ))
is the set of canonical models of T ; the composite functor Mods ◦ M :
Thax

op ! Space will be denoted by models.

– µ : models ⇒ P ◦ Mod is a natural transformation such that, for each
op|, the image of µT : models(T ) ! P ◦ Mod(T ) is the
T = hΣ, Γ i ∈ |Thax
subcategory of Mod(T ) corresponding to each canonical representation of a
class of models in |models(T )|. The map µT is called the projection of the
category of models of the theory T .

– U(Q) =

Sign, Sen, Mod, Sign0, U ◦ ax, {|=Σ}Σ∈|Sign|, M, U ◦ Mods, µ ◦ U
is a satisﬁability subcalculus, where µ ◦ U denotes the natural transformation
(cid:11)
(cid:10)
formed by {µT ◦ U : U ◦ models(T ) ! P ◦ Mod}T ∈|Thax

op|.

Notice that the only diﬀerences between Def. 15 and Def. 16 are that: a) the
restriction Sen0 of the functor Sen must satisfy U ◦ Sen0 = Sen ◦ J, and b) all
occurrences of the category Set involved in the deﬁnition are replaced by Space.
! Space of the functor
Condition a establishes that the restriction Sen0 : Sign0
Sen : Sign ! Set is coherent with the inclusion functor J and the forgetful
functor U, and Cond. b ensures decidability.

Example 3 (Truth tables as an eﬀective satisﬁability subcalculus for the quantiﬁer-
free and ground fragment of ﬁrst-order predicate logic). Let X be a set of ﬁrst-
order variables and IFOL be the institution for ﬁrst-order predicate logic. Let Σ
be a set of propositional variables then, the set of propositional sentences over
those variables (denoted as LΣ) is deﬁned as follows:

LΣ := p | ¬α | α ∨ β where p ∈ Σ and α, β ∈ LΣ

an assignment for Σ is a function val Σ : Σ ! {⊥, ⊤}. Given α ∈ LΣ , we say
that an assignment val satisﬁes α (denoted as val |= α) if and only if:

val |= p iﬀ val (p) = ⊤

val |= ¬α iﬀ val |= α does not hold

val |= α ∨ β iﬀ val |= α or val |= β

Given a set of formulae Γ ∈ 2LΣ we say that a formula α can be obtained

from Γ if and only if at least one of the following conditions hold:

– α ∈ Γ
– α is of the form ¬β1
– α is of the form β1 ∨ β2

where β1 and β2 can be obtained from Γ .

The reader should note that, if we deﬁne Γ as a set of propositional variables
then a formula α can be obtained from Γ if and only if α ∈ LΓ ; furthermore, we
can tell if a truth assignment val Γ satisﬁes the formula α (noted val Γ |= α).

Given Γ1, Γ2 ∈ LΣ, if all formula α ∈ Γ2 can be obtained from Γ1, then we
! assigns Γ2 .
can deﬁne a Truth table from Γ1 to Γ2 as a function t : assigns Γ1
Each set assigns Γ is the set of all functions with type Γ ! {⊤, ⊥}; in particular,
the set assigns Σ is the set of all possible truth assignments for Σ. In order for t
to be a Truth table the following condition must also hold:

t(val Γ1 )(α) = ⊤ if and only if val Γ1 |= α, for all val Γ1 ∈ assigns Γ1 , for α ∈ Γ2.

Note that given two Truth tables t : assigns Γ1

!
! assigns Γ2 and t′ : assigns Γ2
! assigns Γ3 is also a Truth table.
assigns Γ3 , the composition t′ ◦ t : assigns Γ1
Next, we have to provide formal deﬁnitions for the categories supporting Truth
table structures. Given a set of propositional variables Σ and a set of formulae
Γ ∈ 2LΣ , we deﬁne Str Σ,Γ = hO, Ai such that O = 2Γ ′
where Γ ′ is the set of all
subformulae of the formulae in Γ , and A = {t : Γ1 ! Γ2 | Γ1, Γ2 ⊆ 2Γ ′
}, where
all formula α ∈ Γ2 can be obtained from Γ1 and t is the Truth table from Γ1 to
Γ2. Note that a structure Str Σ,Γ has identities and composition, and it can be
proved to be a category.

Now we can deﬁne the eﬀective satisﬁability subcalculus for IFOL as follows:

1. In this case any signature is an admissible signature, therefore Sign0 = Sign.
Then, Sen0 is the restriction of the functor Sen to the category Sign0. Note
that Sen0(Σ) is a recursive inﬁnite set of ﬁnite objects, and therefore, it can
be proved that the image of Sen0 is a space. Since Sen0 is a subfunctor of
Sen it is easy to observe that U ◦ Sen0 = Sen ◦ J.

2. ax is the composition of a functor Qf

! Set yielding, for each
Σ ∈ |Sign|, the restriction of Sen0(Σ) to the quantiﬁer-free sentences, with
Pﬁn .

: Sign0

3. In order to deﬁne M we ﬁrst need to map each ﬁrst order formula to a
boolean combination of propositional variables and then introduce the class
of legal Truth tables for those formulas. We will call prop(Σ) = {vp | p is a
formula in Γ , with Γ ∈ ax(Σ)} for Σ ∈ Sign0. Then, we deﬁne the function
Tr : Qf (Σ) ! Lprop(Σ) as follows:

Tr(P (t1, . . . , tk)) = v“P (t1, . . . , tk)”
Tr(t = t′) = v“t = t′” ,
Tr (¬α) = ¬Tr (α),

Tr (α ∨ β) = Tr (α) ∨ Tr (β).

where P is a predicate symbol and t, t′, t1 . . . tk are terms.
We will also note Tr as its extension to sets of formulae (i.e., Tr (Γ ) with
Γ ∈ ax(Σ)). Now we can deﬁne StructSC as hO, Ai where

– O = {

Str prop(Σ),Tr(Γ ), ∪, ∅

– A = {

D
σ :

Str prop(Σ),Tr (Γ ), ∪, ∅

E

| Σ ∈ |Sign0| ∧ Γ ∈ ax(Σ)}, and
Str prop(Σ′),Tr (Γ ′), ∪, ∅

!

E

D

E

| σ : hΣ, Γ i !

D
hΣ′, Γ ′i ∈ ||Th||}.

b

Finally, we can deﬁne M in the following way:

– M(hΣ, Γ i) =
– M(σop) =

D

Str prop(Σ),Tr(Γ ), ∪, ∅

, for each hΣ, Γ i ∈ |Thax|.

σop, for each theory morphism σ : hΣ, Γ i ! hΣ′, Γ ′i ∈
Str prop(Σ′),Tr (Γ ′), ∪, ∅

!

E

||Thax||, where
σ :
c
is the homomorphic extension of σ.
b

Str prop(Σ),Tr (Γ ), ∪, ∅
D

E

D

E

4. Mods provides the means for obtaining the set of canonical models from
structures of the form Str prop(Σ),Tr(Γ ) by identifying the "rows" of the
truth table that satisfy each formula in Γ (i.e. , the truth assignments
of the propositional variables for which the truth assignments for each
formula is ⊤). Mods : StructSC ! Space is deﬁned on objects as
Mods(
) = hO, Ai where:
E
val prop(Σ) ∈ assigns prop(Σ),
t : ∅ ! Tr (Γ ) ∈ ||Str prop(Σ),Tr(Γ )||,
(∀α ∈ Tr (Γ )) t(val prop(Σ))(α) = ⊤

(cid:12)
(cid:12)
Tr (Γ ) is the restriction of the function val prop(Σ) to the

where val prop(Σ)
set of propositional variables that appear in Tr (Γ ).

Tr (Γ ) (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Str prop(Σ),Tr(Γ ), ∪, ∅

– O = 


val prop(Σ)








D

as

– A = {id v : v ! v | v ∈ O}.
and on morphisms
for
∈
σop)(val prop(Σ′)
||Thax||, Mods(
such that
val prop(Σ)(vp) = val prop(Σ′)(σ(vp)) for all the variables vp that appear in
Tr (Γ ). Each object hO, Ai is a set of functions with a ﬁnite ﬁxed domain,
therefore there is at most a ﬁnite amount of functions, thus we can prove
that hO, Ai is a space.

hΣ, Γ i ! hΣ′, Γ ′i
Tr (Γ ),

:
Tr (Γ ′)) = val prop(Σ)

all σ

c

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

5. µ has to relate the structures representing truth assignments with the ﬁrst or-
der models satisfying the set of formulae denoted by those truth assignments;
then we can deﬁne µhΣ,∆i : models(hΣ, ∆i) ! P ◦Mod(hΣ, ∆i) as for each

E

D

∆

Σ,

val prop(Σ) ∈ |models(hΣ, ∆i)|, µhΣ,∆i(val prop(Σ)) = Mod(
), where
∆ = {P (t1, . . . , tk) | val prop(Σ)(v“P (t1, . . . , tk)” ) = ⊤} ∪ {¬P (t1, . . . , tk) |
val prop(Σ)(v“P (t1, . . . , tk)” ) = ⊥} ∪ {t = t′ | val prop(Σ)(v“t = t′” ) = ⊤} ∪
b
{¬t = t′ | val prop(Σ)(v“t = t′” ) = ⊥}. In order to prove that µ is a natural
family of functors we have to show that µhΣ,∆i ◦ models(σop)(val prop(Σ′)) =
(P ◦ Mod(σop)) ◦ µhΣ′,∆′i(val prop(Σ′)), for σ : hΣ, ∆i ! hΣ′, ∆′i. It is easy
to observe that:
– µhΣ,∆i ◦ models(σop)(val prop(Σ′)) = Mod(
D
– (P ◦ Mod(σop)) ◦ µhΣ′,∆′i(val prop(Σ′)) = Mod(
b
D

E
Σ,

Σ,

∆

∆

).

).

E

b

∆, as deﬁned above, is the set of ﬁrst order predicates that correspond
where
to the truth assignment val prop(Σ), and val prop(Σ) is the map of val prop(Σ′) to
b
the signature Σ.

b

The notion of eﬀective satisﬁability subcalculus provides the theoretical foun-
dations for those analysis commands relying on model ﬁnding, much in the same
way that proof calculus provide theoretical support for the proof commands; the
combination results from applying Coro. 3. Applying such a corollary requires
the language to have negation, in the sense of Def. 14 which, even when it might
be satisﬁed by the institution underlying the eﬀective satisﬁability subcalculus,
there is no guarantee that it is satisﬁed by the restriction of the language for
which the subcalculus is eﬀective.

Proposition 2.
Let the structure

Sign, Sen, Mod, Sign0, Sen0, ax, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:11)
(cid:10)
Σ}Σ∈|Sign0|
be an eﬀective satisﬁability subcalculus, then
is an institution, where Mod0 stands for the functor Mod restricted to the sub-
Σ for the restriction of
category Sign0
|=Σ to the models in Mod0(Σ) and the formulae in Sen0(Σ) (usually denoted
as |=0

D
op (usually denoted as Mod | Sign0

Sign0, Sen0, Mod0, {|=0

Σ = |=Σ | Mod0×Sen0 ).

op) and |=0

E

We already shown how Coro. 3 can be used to conclude the unprovability of
a given formula α from a theory presentation T , by using a satisﬁability calculus
in order to construct a structure M ∈ |models(T )| and then, having to ﬁnd a
model M such that M |= T and M |= α does not hold which, under the presence
of negation in the syntax of the logical language (see Def. 14), is equivalent to
construct a model M such that M |= T and M |= ¬α. Eﬀectiveness, as it was
introduced by Def. 16, states that M is the result of a constructive push-button
process but, for that to hold, the language of the eﬀective satisﬁability subcalcu-
Σ}Σ∈|Sign0|
lus must have negation (i.e. the institution
has to have negation).

Sign0, Sen0, Mod0, {|=0
D

E

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|

Corollary 4. Let the structure
a logic, the structure
the structure

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:10)

(cid:10)

Sign, Sen, Mod, Sign0, Sen0, ax, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:10)

(cid:11)
Sign0, Sen0, Mod0, {|=0

(cid:11)
Σ}Σ∈|Sign|
eﬀective satisﬁability subcalculus such that
E
has negation. Therefore, for all T = hΣ, Γ i ∈ |Th0| and α ∈ |Sen0(Σ)|, if there
exists M ∈ |models(T )| and M ∈ |µT (M )| such that M |=Σ ¬α, then there is
no τ ∈ |proof (T )| such that πT (τ ) = α.

D

be
(cid:11)
be a proof calculus and
be an

As we mentioned at the beginning of this section, our focus is in combining
automatic model ﬁnding capabilities as part of the process of analysis of software
descriptions. While Def. 16 provides the formal framework for describing such
eﬀective procedures and, as we said before, Coro. 4 expose the link between
the result of such procedures and the unprovability of a formula, there is still
a missing piece in the puzzle in order to guarantee automatic counterexample
ﬁnding.

Corollary 4 properly connects the existence of a model satisfying the negation
of a formula with the impossibility of proving the formula itself, but it provides
no guide on how to use the eﬀective procedure for building a model structure
M ∈ |models(T )| for ﬁnding a model M ∈ |µT (M )| such that M |=Σ ¬α.
To solve that, ¬α has to be involved in the process of building M in a way
that every model M ∈ |µT (M )| satisﬁes ¬α. In general, the mechanism used to
internalise ¬α in the process for building models for T strongly depend on the
speciﬁc procedure for building model structures and, under certain conditions,
it can be done by simply adding ¬α to the axioms in T . Such a condition is
know, analogous to what we did for requiring an institution to have negation,
as to “have conjunction”, formally deﬁned below.

Deﬁnition 17. Given a institution I, we say that I has conjunction if for every
signature Σ ∈ |Sign|, {αi}i∈I ⊆ Sen(Σ), there exists a formula in Sen(Σ),
i∈I αi, such that for all M ∈ Mod(Σ),
usually denoted as

V
M |=Σ

^i∈I

αi iﬀ M |=Σ αi, for all i ∈ I

Remark 1. Notice that given a institution I, Σ ∈ |Sign| and Γ ⊆ Sen(Σ), for all
M ∈ Mod(Σ),

M |=Σ Γ iﬀ M |=Σ

α

^α∈Γ

Therefore, Coro. 4 can be stated as follows.

Corollary 5. Let the structure
a logic, the structure
the structure

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:10)

Sign, Sen, Mod, Sign0, Sen0, ax, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:10)

(cid:10)

(cid:11)

(cid:11)

be
(cid:11)
be a proof calculus and
be an

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|

Σ}Σ∈|Sign0|
eﬀective satisﬁability subcalculus such that
E
has negation and conjunction. Therefore, for all T = hΣ, Γ i ∈ |Th0| and α ∈
|Sen0(Σ)|, if there exists M ∈ |models(hΣ, Γ ∪ {¬α}i)|, then there is no τ ∈
|proof (T )| such that πT (τ ) = α.

Sign0, Sen0, Mod0, {|=0
D

So far, we managed to provide the means for understanding how an eﬀective
procedure for building models can be used for short-cutting a proving attempt
by deducing that no such proof exists but such usage is conﬁned to theories and
propositions consisting exclusively of formulae from the sublanguage formalised
for which such an ef-
as the institution
fective procedure exists. We would like to get as much value as possible from
the, usually big, eﬀort invested in developing tools supporting speciﬁc eﬀective
satisﬁability calculi.

Sign0, Sen0, Mod0, {|=0

Σ}Σ∈|Sign0|

D

E

I =

The typical way of doing so is as follows: given an institution of interest
and an eﬀective satisﬁability subcalculus
0, ax′, {|=′Σ}Σ∈|Sign′|, M′, Mods′, µ′

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)
(cid:11)
0, Sen′
Sign′, Sen′, Mod′, Sign′
preserving

,
E
to
, the institution underlying the decidable

translation

semantics

from I

Σ}Σ∈|Sign′
0|

Q =
we

D
a
consider
0, Mod′
0, Sen′
0, {|=′
0
D
fragment of Q.

Sign′

E

The usual notion of morphism between institutions consists of three arrows
between the components of the source and target institutions: 1) an arrow re-
lating the categories of signatures, 2) an arrow relating the grammar functors,
and 3) an arrow relating the models functors. Several notions of morphisms be-
tween institutions, and their properties, were investigated in [78,50,44]. More
recently, in [79], all these notions of morphism were scrutinised in more detail by
observing how the direction of the arrows modify its interpretation. Institution
comorphisms can be used as a vehicle for borrowing proofs along logic translation
[44]; for deﬁning heterogeneous development environments for software speciﬁ-
cation and design [80,81], which provides the foundations of tools like HETS
[82] and CafeOBJ [83]; for providing structured speciﬁcations in general [40],
for providing semantics to speciﬁc features of formal languages [84]; for deﬁning
proof systems for structured speciﬁcations [85,86,87]; and for formalising data
and speciﬁcation reﬁnements in [39,88,89], just to give a few examples.

Sign, Sen, {⊢Σ}Σ∈|Sign|
(cid:10)

Let us start by recalling some notions about mapping entailment systems. In
and E′ =
general, given two entailment systems E =
Sign′, Sen′, {⊢′Σ}Σ∈|Sign|
, if we aim at mapping sentences in E to sentences in
D
E′ by using a natural transformation α : Sen ⇒ Sen′◦Φ in a way that provability
is preserved (i.e. Γ ⊢Σ φ if and only if αΣ(Γ )⊢′Φ(Σ)αΣ(φ)), a functor Φ : Sign !
Sign′ will not be enough. The reason is that for preserving provability, the proof
′ might require certain basic axioms for characterising
theoretic structure of E
the behaviour of its own logical symbols. Solving this issue requires resorting
to a functor Φ : Sign ! Th′
0 that, in turn, can be easily extended to a functor

E

(cid:11)

0, the α-extension to theories of Φ, as Φ(hΣ, Γ i) =

Φ : Th0 ! Th′
Σ′, Γ ′
such that Φ(Σ) = hΣ′, Γ ′i and Γ ′ = Γ ′ ∪ αΣ(Γ ). Notice also that the natural
(cid:11)
(cid:10)
transformation α : Sen ⇒ Sen′ ◦ Φ can be extended to α : Sen ⇒ Sen′ ◦ Φ
! Set as αhΣ,Γ i = αΣ.
between the functors Sen : Th0 ! Set and Sen′ ◦ Φ : Th′
0

Let
Deﬁnition 18 (Sensibility
Sign, Sen, {⊢Σ}Σ∈|Sign|
entailment
and
(cid:11)
(cid:10)
systems, Φ : Th0 ! Th′
0 be a functor and α : Sen ⇒ Sen′ ◦ Φ a natural
transformation. Φ is said to be α-sensible if the following conditions are
satisﬁed:

and
Sign′, Sen′, {⊢′Σ}Σ∈|Sign′|

[50]).
be

simplicity

D

E

1. there is a functor Φ⋄ : Sign ! Sign′ such that sign′ ◦ Φ = Φ⋄ ◦ sign, where
sign : Th ! Sign and sign′ : Th′ ! Sign′ are the forgetful functors from
theory presentations to signatures, and

2. if hΣ, Γ i ∈ |Th| and hΣ′, Γ ′i ∈ |Th′| such that Φ(hΣ, Γ i) = hΣ′, Γ ′i, then

(Γ ′)• = (∅′ ∪ αΣ(Γ ))•, where ∅′ = αΣ(∅)8.

Φ is said to be α-simple if, instead of satisfying (Γ ′)• = (∅′ ∪ αΣ(Γ ))• in Con-
dition 2, the stronger condition Γ ′ = ∅′ ∪ αΣ(Γ ) is satisﬁed.

It is straightforward to see, based on the monotonicity of •, that α-simplicity
implies α-sensibility. An α-sensible functor has the property that the associated
natural transformation α depends only on signatures. This is a consequence of
the following lemma.

Lemma 6 (Lemma 22, [50]).
Sign, Sen, {⊢Σ}Σ∈|Sign|
(cid:10)

Sign′, Sen′, {⊢′Σ}Σ∈|Sign′|

be entailment sys-
Let
tems and Φ : Th0 ! Th′
0 a functor satisfying Cond. 1 of Def. 18. Then any
natural transformation α : Sen ⇒ Sen′ ◦Φ can be obtained from a natural trans-
formation α⋄ : Sen(Σ) ⇒ Sen′ ◦ Φ⋄ by horizontally composing with the functor
sign : Th ! Sign.

and

D

E

(cid:11)

The next deﬁnition introduces institution comorphism.

Deﬁnition 19 (Institution comorphism [44]).
ρSign, ρSen, ρMod
Let I and I′ be institutions. Then,
comorphism if and only if:
(cid:10)

(cid:11)

: I −! I′ is an institution

– ρSign : Sign ! Sign′ is a functor,
– ρSen : Sen ⇒ Sen′ ◦ρSign is a natural transformation, (i.e., a natural family
Σ : Sen(Σ) ! Sen′(ρSign(Σ))), such that for each Σ1, Σ2 ∈
of functions ρSen
|Sign| and σ : Σ1 ! Σ2 morphism in Sign, the following diagram commutes

8 ∅′ is not necessarily the empty set of axioms. This fact will be clariﬁed later on.

Sen(Σ2)
✻

Sen(σ)

Sen(Σ1)

ρSen
Σ2

✲

Sen′(ρSign(Σ2))
✻
Sen′(ρSign(σ))

ρSen
Σ1

✲

Sen′(ρSign(Σ1))

Σ2
✻
σ

Σ1

– ρMod : Mod′ ◦ρSignop
⇒ Mod9 is a natural transformation, (i.e., the family
(Σ)) ! Mod(Σ) is natural), such that for
of functors ρMod
each Σ1, Σ2 ∈ |Sign| and σ : Σ1 ! Σ2 a morphism in Sign, the following
diagram commutes

: Mod′(ρSign op

Σ

Mod′(ρSign op

(Σ2))

ρMod
Σ2

✲

Mod(Σ2)

Mod′(ρSignop

(σop))

❄

Mod′(ρSignop

(Σ1))

ρMod
Σ1

✲

Mod(σop)
❄
Mod(Σ1)

Σ2
✻
σ

Σ1

such that for any Σ ∈ |Sign|, the function ρSen
and the functor ρMod
satisfaction condition: for any α ∈ Sen(Σ) and M′ ∈ |Mod′(ρSignop

: Sen(Σ) ! Sen′(ρSign(Σ))
(Σ)) ! Mod(Σ) preserves the following

: Mod′(ρSignop

(Σ))|,

Σ

Σ

M′|=′ρSign(Σ)ρSen

Σ (α) iﬀ ρMod

Σ (M′) |=Σ α .

Intuitively, an institution comorphism ρ : I −! I′ expresses how the sat-
isﬁability in a (potentially) less expressive institution I ca be encoded into a
(potentially) more expressive institution I′. In [44, Sec. 5.2], Tarlecki shows that
institution comorphisms compose in a rather obvious component wise way, and
that it can be proved that institutions together with institution comorphisms
form a category, denoted as coIns.

The following results, presented in [44], characterise the relation between the

satisfaction relation of I and I′, in the presence of an institution comorphism.

I′

be

of

the

I
Proposition 3 (Preservation
and
and
Sign′, Sen′, Mod′, {|=′Σ}Σ∈|Sign′|
, respectively. Let ρ : I ! I′ be an in-
D
stitution comorphism. Then, for all Σ ∈ |Sign|, Γ ⊆ Sen(Σ) and ϕ ∈ Sen(Σ),
if Γ |=Σ ϕ, then ρSen
Σ (ϕ).

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

Σ (Γ )|=′ρSign(Σ)ρSen

consequence

institutions

[44]).

Let

E

(cid:11)

9 The functor ρSignop

: Sign′op ! Signop is the same as ρSign : Sign′ ! Sign but

considered between the opposite categories.

In some cases institution comorphisms can be extended to what Meseguer
introduced under the name map of institutions [50, Def. 27], and were more
recently renamed by Goguen and Roşu as theoroidal comorphism [79, Def. 5.3],
by reformulating the functor mapping signatures to act on theory presentations
(i.e. ρT h : Th ! Th′).

This extension can be done in many ways being one of them when ρT h is
ρSen-sensible (see Def. 18) with respect to the entailment system induced by the
consequence relations of the institutions I and I′. In this way, the natural trans-
formation ρSign relating the categories of signatures of both logical languages,
can be extended to ρT h : Sign ! Th′ enabling the restriction of the target
class of models over which the consequence is preserved, and then, to a functor
ρT h : Th ! Th′ deﬁned in the following way: let Σ ∈ |Sign|, Γ ∈ |Sen(Σ)|,
ρT h(hΣ, Γ i) =
Σ (Γ )
. Additionally, given an institution co-
: I −! I′ we say it is plain if and only if ρT h is
morphism
(cid:11)
ρSen-plain, and similarly we say it is simple if and only if ρT h is ρSen-simple.

ρSign(Σ), ∅′ ∪ ρSen

ρSign, ρSen, ρMod

(cid:10)

(cid:10)

(cid:11)

The interested reader is pointed to [50, Sec. 4], [44, Sec. 5] and [79, Sec. 5]

for a thorough discussion on the matter.

Therefore, the combination of Prop. 3 and Coro. 5 results in the ﬁnal state-
ment of how soundness enables the use of an eﬀective satisﬁability subcalculus
for a logical language, as a counterexample ﬁnder for a (potentially) diﬀerent
one.

Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|

Corollary 6. Let the structure
a logic, the structure

Sign′, Sen′, Mod′, Sign′

(cid:10)

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:10)
0, Sen′
satisﬁability

structure
be

Sign′

D
an
0, Mod′
0, Sen′
D
and ρ =
0, Sen′

eﬀective
0, {|=′

Σ}Σ∈|Sign′
0|

0
ρSign, ρSen, ρMod
(cid:10)
0, Mod′

E
:

(cid:11)

be
be a proof calculus, the
(cid:11)
0, ax′, {|=′Σ}Σ∈|Sign′|, M′, Mods′, µ′
E
that
conjunction
!

has
Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

subcalculus
negation

such

and

(cid:11)
Σ}Σ∈|Sign′
Sign′
0, {|=′
a comorphism between institutions,
0|
0
D
being ρT h : Th0 ! Th′
0 the theoroidal extension of ρSign : Sign ! Sign′
0.
Therefore, for all T = hΣ, Γ i ∈ |Th0| and α ∈ |Sen0(Σ)|, if there exists
M ∈ |models′(ρT h(hΣ, Γ ∪ {¬α}i))|, then there is no τ ∈ |proof (T )| such that
πT (τ ) = α.

E

(cid:11)

Corollary 6 provides the formal support for using a model ﬁnder to look
for counterexamples of judgements of the shape Γ ⊢Σ α at any point of a
proof, enabling the capability to check whether the application of a given proof
command has modiﬁed the provability of α from Γ .

The reader should note that Coro. 6 only guaranties that, given a theory
presentation T = hΣ, Γ i and a formula α, whenever a model structure M is
built for ρT h(hΣ, Γ ∪ {¬α}i) using an eﬀective satisﬁability subcalculus, we

can conclude the impossibility of constructing a proof structure for α from
Γ ; but not being able to do so does not provide any solid information about
its existence, because there could still be a model in the source institution
satisfying the axioms in T and not satisfying α. That, of course, does not
invalidate the conﬁdence gained in the validity of the judgement γ |=Σ α, by
not founding a counterexample.

Depending on how precise the natural transformation ρMod is, regarding the
representation of the target category of models over the source one, we can derive
stronger conclusion.

be

the

over

I and I′

expansion
institutions

Deﬁnition 20 (Model
Let
Sign′, Sen′, Mod′, {|=′Σ}Σ∈|Sign′|
D
I
comorphism. Then, I has the ρ-expansion property if for all hΣ, Γ i ∈ |Th
0|,
M ∈ |ModI
(ρT h(hΣ, Γ i))| such that
M = ρMod(M′).

translation).
model
Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
and
(cid:10)
, respectively. Let ρ : I ! I′ be an institution

E
(hΣ, Γ i)|, there exists M′ ∈ |ModI′

(cid:11)

The intuition behind the previous deﬁnition is that, given a theoroidal in-
′, I has the ρ-expansion property whenever
′-models, in a way that the satisfaction of

stitution comorphism ρ : I
every I-model is the target of some I
I-formulae is reﬂected in I

!

′.

I

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

Theorem 1 (Reﬂection of consequence [44]). Let I and I′ be the institu-
and
tions
,
E
respectively. Let ρ : I ! I′ be an institution comorphism. Then, for all Σ ∈ |Sign|,
Γ ⊆ Sen(Σ) and ϕ ∈ Sen(Σ), if every M ∈ Mod(hΣ, Γ i) has the ρ-expansion
property, then Γ |=Σ ϕ if and only if ρSen

Sign′, Sen′, Mod′, {|=′Σ}Σ∈|Sign′|

Σ (Γ ) |=ρSign(Σ) ρSen

Σ (ϕ).

D

(cid:11)

I

!

Finally, Thm. 1 states that, given a theoroidal

institution comorphism
′, such that I has the ρ-expansion property, then an eﬀective satis-
ρ : I
′ is the fragment of the language of the eﬀective
ﬁability subcalculus for I
satisﬁability subcalculus for which the procedure is indeed eﬀective) constitutes
a semantics-based decision procedure for I.

′ (i.e. I

4 Case-study: ﬁrst-order predicate logic

First-order predicate logic provides a well-known, and simple, example for
showing the value of using theoroidal comorphisms as a tool
for reusing
tools designed for one language in the analysis of software speciﬁcations
written in “another”. Let us consider the eﬀective satisﬁability subcalculus,
for the quantiﬁer-free and ground fragment of FOL.
presented in Ex. 3,

Intuitively, the theories for which we are capable of constructing models
for, are those that do not resort to any quantiﬁcation and, of course, have
no free variables (i.e. all terms appearing in the formulae are ground), but
Coro. 6 provides the mathematical machinery needed for using oﬀ-the-shelve
constraint-solving tools in order to enable counterexample searching capabilities.

The reader might note that such a semantics preserving translation contra-
dicts the intuition mentioned after Def. 19 where we slide the misleading, but
widely spread, idea that the source logical system of an institution comorphism
is less expressive than the target one. A more precise interpretation is to consider
institution comorphisms as encodings that,
in general, satisfy the intuition
mentioned before but, under some speciﬁc conditions, might loose expressivity /
representation capability, while, as we will show in the forthcoming section, still
preserve the satisfaction condition. A more thorough study of the conditions
under which this type of institution comorphisms can be deﬁned will be left for
further investigation.

X

be

Let

a
Sign, Sen, Mod, {⊢Σ}Σ∈|Sign|, {|=Σ}Σ∈|Sign|
(cid:10)
order predicate logic over X and PFOL =
a proof calculus for L.

ﬁrst

variable,

order
=
be the structure formalising ﬁrst-
be

Sign, Sen, {⊢Σ}Σ∈|Sign|, P, Pr, π
(cid:11)
(cid:10)

LFOL

set

of

(cid:11)

D

Let

QProp

eﬀective

satisﬁability

the
0, ax′, {|=′Σ}Σ∈|Sign′|, M′, Mods′, µ′

be
Sign′, Sen′, Mod′, Sign′
0, Sen′
Sign′, Sen′, Mod′, {|=′Σ}Σ∈|Sign′|
is the institution of propositional logic10.
D
Then, we can deﬁne a theoroidal comorphism from the underlying institution of
LFOL to the underlying institution of QProp by parameterising the translation
of ﬁrst-order formulae with a natural number used to enforce ﬁnite bounds to
the domains of interpretation of ﬁrst-order formulae.

subcalculus

where

E

E

,

Deﬁnition 21. γSign : Sign ! Sign′ is deﬁned as the functor such that:

– for all Σ ∈ |Sign|, γSign(Σ) = {vp|p is a ground atomic formula in Sen(Σ)},

and

– for all σ : Σ ! Σ′ ∈ ||Sign||, γSign(σ) = τ , where τ (vp) = vSen(σ)(p).

Proposition 4. γSign is a functor.

Proof. Note that γSign(σ) is deﬁned in terms of Sen(σ). Since Sen is a functor
it can be proved that γSign preserves identities and composition.

10 Note

that

in this particular
0, {|=′Σ
D
to the fact that propositional logic is decidable.

0 }Σ∈|Sign′
0|

0, Mod′

0, Sen′

Sign′

case

D

E

Sign′, Sen′, Mod′, {|=′Σ}Σ∈|Sign′|

and

E

can be assumed to be the same institution due

Deﬁnition 22. Let n ∈ N, Σ = h{fi}i∈I, {Pj}j∈J i and Σ′ =
h{fi}i∈I ∪ {ck}1≤k≤n, {Pj}j∈J i such that Σ, Σ′ ∈ |Sign|.

1. First, we deﬁne Tr n

v : Sen(Σ) ! Sen(Σ′) for mapping ﬁrst-order logic
sentences into quantiﬁer-free and ground ﬁrst-order logic sentences. This
will be done by turning existencial quantiﬁers into ﬁnite disjunctions over
Σ′ in a way that the fresh new constant symbols {ck}1≤k≤n play the role of
the only elements in the domain of interpretation.
Let v : X ! {ck}1≤k≤n be a function mapping the ﬁrst-order variable symbols
in X to constant symbols in {ck}1≤k≤n, then Tr n

v is deﬁned as follows11:

Tr n

v (P (t1, . . . , tk)) = P (Tr n

v (t1), . . . , Tr n

v (tk)) , for all P ∈ {Pj}j∈J

Tr n

v (α ∨ β) = Tr n
v (¬α) = ¬Tr n
Tr n
v ((∃x)α) =

v (α) ∨ Tr n
v (α)
i=1 Tr n

n

Tr n

v{x7!ci}(α)

v (β)

W

Tr n

v (f (t1, . . . , tk)) = f (Tr n

v (x) = v(x) , for all x ∈ X
v (t1), . . . , Tr n

Tr n

v (tk)) , for all f ∈ {fi}i∈I

2. Second, we deﬁne a partial function Tr Int : Sen(Σ′) ! Sen(Σ′) mapping
quantiﬁer-free and ground ﬁrst-order sentences by interpreting the terms as
the fresh new constant symbols {ck}1≤k≤n.
Let α ∈ Sen(Σ′) and Term(α) be the set of terms mentioned in α, excluding
those in {ck}1≤k≤n, then Tr Int is deﬁned as follows:

Tr Int (α) =



Tr Int f (α) ∧

t = f (t)

_
f ∈[Term(α)!{ck}1≤k≤n]



^t∈Term(α)



Tr Int f (P (t1, . . . , tk)) = P (f (t1), . . . , f (tk)), for all P ∈ {Pj}j∈J ,

Tr Int f (t = t′) = f (t) = f (t′),
Tr Int f (¬α) = ¬Tr Int f (α),

Tr Int f (α ∨ β) = Tr Int f (α) ∨ Tr Int f (β).

3. Third, we deﬁne a partial function Tr Prop : Sen(Σ′) ! Sen′(γSign(Σ′)) for
mapping quantiﬁer-free and ground ﬁrst-order sentences, whose only terms
are in {ck}1≤k≤n, to propositional sentences, as follows:

Tr Prop(P (c1, . . . , ck)) = v“P (c1, . . . , ck)” , for all P ∈ {Pj}j∈J ,

Tr Prop(c = c′) = v“c = c′” ,

Tr Prop(¬α) = ¬Tr Prop(α),

Tr Prop(α ∨ β) = Tr Prop(α) ∨ Tr Prop(β).

11 Let v : X ! {ck}1≤k≤n be a function mapping the ﬁrst-order variable symbols in X

to constant symbols in {ck}1≤k≤n, then v{x 7! ci}(y) =

v(y) ; if x 6= y.
; if x = y.
ci

.

(cid:26)

Then γSen

Σ : Sen(Σ) ! Sen′(γSign(Σ′)) is deﬁned as follows:

Σ (α) = Tr Prop (Tr Int (Tr n
γSen

∅ (α)))

In the previous deﬁnition γSen

eliminates quantiﬁers replacing them with
ﬁnite disjunctions and produces all the possible interpretations of the terms over
the domain {c1, . . . , cn}. Then, the last stage in the translation, replaces all
atomic formulae (in which there are no term other than those in {c1, . . . , cn})
by propositional variables labeled with the atomic formula they represent.

Σ

Proposition 5. γSen is a natural family of functions.

Proof. The proof follows by ﬁrst observing that given Σ ∈ |Sign|, γSen
(see
Def. 22) is a function. Therefore, we need to prove that the following diagram
commutes:

Σ

Sen(Σ2)
✻

Sen(σ)

Sen(Σ1)

γSen
Σ2

✲

Sen′(γSign(Σ2))
✻
Sen′(γSign(σ))

γSen
Σ1

✲

Sen′(γSign(Σ1))

Σ2
✻
σ

Σ1

where σ : Σ1 ! Σ2 ∈ ||Sign|| is an homomorphism between two ﬁrst-order
signatures. Note that:

– each γSen
formulae,

Σ is the function mapping ﬁrst-order Σ-formulae into propositional

– given σ : Σ ! Σ′ ∈ ||Sign||, Sen(σ) is a function mapping ﬁrst-order Σ-

formulae to ﬁrst-order Σ′-formulae, and

– given σ : Σ ! Σ′ ∈ ||Sign||, Sen′(γSign(σ)) is a function mapping proposi-

tional γSign(Σ)-formulae to propositional γSign(Σ′)-formulae.

Then, the proof follows by observing that translating a ﬁrst-order formulae across
signatures and then mapping them to propositional formulae yields the same
result as ﬁrst mapping the ﬁrst-order formula to a propositional one, and then
translating the propositional formula.

Deﬁnition 23. Let n ∈ N, γSign : Sign ! Sign′ be the functor of Def. 21 and
γSen : Sen ! Sen′ ◦ γSign be the natural family of functions of Def. 22. Then,
we deﬁne γTh0 : Th0 ! Th′

0 as:

γTh0(hΣ, Γ i) =

γSign(Σ), {γSen
(cid:10)

Σ (α)|α ∈ Γ }

.

(cid:11)

Proposition 6. The functor γTh0 : Th0 ! Th′

0 is γSen-sensible.

Proof. It follows directly from the deﬁnition of γTh0 by observing it is explicitly
constructed in terms of γSign and γSen.

The next deﬁnition provides the usual deﬁnition of model for propositional
logic. A model is a function assigning a truth value from {⊤, ⊥} to each ex-
tralogical (also referred to as rigid) symbol, appearing in the signature. It is
easy to note that for such a model, not depending on any domain of discourse
for interpreting objects, there is no possible notion of homomorphism that can
be regarded as an arrow between two models thus, forcing us to consider them
as organised as a discrete category.

Deﬁnition 24. Let n ∈ N and Σ = h{fi}i∈I, {Pj}j∈J i ∈ |Sign|. Then we
: Mod′(γSign(Σ)) ! Mod(Σ) as follows: for all val : γSign(Σ) !
deﬁne γMod
{⊥, ⊤} ∈ |Mod′(γSign(Σ))|, γMod
Σ (val ) = hS, F , Pi such that:

Σ

– S = {c1, . . . , cn},
– F =

f |f ∈ {fk}k∈K

, where

– P =

hc1, . . . , cki 7! c

(cid:8)
(cid:9)
f =
(cid:8)
P |P ∈ {Pj}j∈J
hc1, . . . , cki

(cid:8)
P =

c1, . . . , ck, c ∈ S, val
(cid:12)
, where
(cid:12)

(cid:9)
c1, . . . , ck ∈ S, val

(cid:8)

(cid:12)
(cid:12)

and for all Id val : val ! val ∈ ||Mod′(γSign(Σ))||, γMod

vc=f (c1,...,ck)
(cid:0)
vP (c1,...,ck)
(cid:0)

= ⊤

= ⊤

.
(cid:9)

(cid:1)
, and

(cid:9)

(cid:1)
Σ (Id val ) = Id γM od

Σ (val)

Proposition 7. γMod

Σ

is a functor.

Proof. γMod
compositions are trivially preserved.

Σ

preserves identities and, since the source category is discrete, the

Proposition 8. γMod is a natural transformation and the functors γMod
serve the satisfaction condition.

Σ

pre-

Proof. We need to prove that Mod(σop) ◦ γMod
with σ : Σ1 ! Σ2 ∈ ||Sign||. It follows from observing that:

Σ2 = γMod

Σ1

◦ Mod′(γSign op

(σop)),

– Mod(σop)(M) yields a ﬁrst-order model obtained by capturing elements of

M according to the signature morphism σ.

– Mod′(γSign op

(σop))(M′) yields a propositional valuation obtained by cap-

turing the values in M′ according to the signature morphism γSign (σ).
– γSign (σ), as it was deﬁned in Def. 21, is the signature morphism in the

category of signatures of propositional logic obtained from σ.

With these observations it can also be proved that the functor γMod
the satisfaction condition.

Σ

preserves

Proposition 9. For all n ∈ N,
theoroidal comorphism between institutions.

γTh0 , γSen, γMod
(cid:10)

(cid:11)

: IFOL(X ) ! Prop is a

Proof. The proof follows directly from Props. 4, 5, 6, 7 and 8.

Finally, the institution comorphism

, together with γTh0 ,
the theoroidal extension of γSign, presented above, satisfy the hypothesis of
(cid:10)
(cid:11)
Coro. 6, thus providing an eﬀective procedure, formalised in QProp, for bounded
counterexample ﬁnding that can be applied in the critical parts of a proof being
developed within the proof calculus formalised in PFOL.

γSign, γSen, γMod

5 Conclusions

In this work we showed how eﬀective satisﬁability sub-calculi, a special type of
satisﬁability calculi, all of which were presented in [59], can be combined with
proof calculi, as they were presented in the context of General logics by Meseguer
in [50], in order to provide the foundations for methodological approaches to
software analysis. This was done by relating, in an abstract categorical setting,
the construction of counterexamples, using model ﬁnders, with the absence of
proofs.

This methodology is based on the fact that searching of counterexamples is
usually entangled with theorem proving in software analysis. As we mentioned
in the preceding sections, there are many uses for counterexample ﬁnding capa-
bilities, among which we ﬁnd: 1) gaining conﬁdence on the correctness of the
speciﬁcation and the satisfaction of the property, 2) understanding the relevance
of each hypothesis in the a proof, and 3) the analysis of the appropriateness of
the addition of new hypothesis that might not be provable from the current set
of hipothesis. This was exempliﬁed by formalising a bounded counterexample
ﬁnder as an eﬀective satisﬁability subcalculus for propositional logic, and then
combining it with a proof calculus for ﬁrst order logic with equality by means
of a semantics preserving translation.

In [90] we presented the tool HeteroGenius as an implementation of a frame-
work based on the (initially intuitive) notion of heterogeneous hybrid analysis.
The idea behind HeteroGenius is to consider software analysis as a task devel-
oped by combining diﬀerent techniques, following certain methodology. This can
be done by considering an analysis structure where nodes are judgements of the
form Γ ⊢Σ α and arrows relate judgements by applying a speciﬁc technique
thus, providing some insight on its validity. The reader should note that the
formalisation of both, proof calculi and satisﬁability calculi, are not suitable for
the implementation of analysis structures as the latter requires diﬀerent tools to
operate over the same structure, thus internalising their combination.

References

1. Pnueli, A.: The temporal logic of programs.

In: Proceedings of 18th. Annual
IEEE Symposium on Foundations of Computer Science, Los Alamitos, CA, USA,
IEEE Computer Society, IEEE Computer Society (1977) 46–57

2. Pnueli, A.: The temporal semantics of concurrent programs. Theoretical Com-

puter Science 13(1) (1981) 45–60

3. Manna, Z., Pnueli, A.: Temporal Veriﬁcation of Reactive Systems. Springer-

Verlag, New York, NY, USA (1995)

4. Ben-Ari, M., Manna, Z., Pnueli, A.: The temporal logic of branching time. In:
Proceedings of the 8th. ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, Williamsburg, Virginia, Association for the Computer
Machinery, ACM Press (1981) 164–176

5. Emerson, E.A., Halpern, J.Y.: “sometimes” and “not never” revisited: on branch-
ing versus linear time temporal logic. Journal of the ACM 33(1) (1986) 151–178
6. Fischer, M.J., Ladner, R.E.: Propositional modal logic of programs. In Hopcroft,
J.E., Friedman, E.P., Harrison, M.A., eds.: Proceedings of the 9th. annual ACM
symposium on theory of computing. STOC, Boulder, Colorado, United States,
ACM Press (1977) 286–294

7. Harel, D., Kozen, D., Tiuryn, J.: Dynamic logic. Foundations of Computing. The

MIT Press, Cambridge, MA, USA (2000)

8. Henriksen, J.G., Thiagarajan, P.: Dynamic linear time temporal logic. Annals of

Pure and Applied Logic 96(1–3) (1999) 187–207

9. van Benthem, J., Doets, K.: Higher-order logic. In Gabbay, D., Guenthner, F.,
eds.: Handbook of Philosophical Logic. Volume 1. second edn. Kluwer Academic
Publishers (2001) 275–329

10. Henkin, L.A.: The logic of equality. The American Mathematical Monthly 84(8)

(1977) 597–612

11. Goguen, J.A., Thatcher, J.W., Wagner, E.G., Wright, J.B.: Abstract data types as
initial algebras and the correctness of data representations. In: Computer Graph-
ics, Pattern Recognition and Data Structure with the IEEE Computer Society
and in cooperation with the ACM Special Interest Group on Computer Graphics,
IEEE Computer Society (May 1975) 89–93

12. Turing, A.M.: On computable numbers, with an application to the entschei-
dungsproblem. Proceedings of the London Mathematical Society s2-42(1) (1937)
230–265

13. Hoare, C.A.R.: An axiomatic basis for computer programming. Communications

of the ACM 26(1) (1969) 53–56

14. Burstall, R.M.: Proving properties of programs by structural induction. The

Computer Journal 12(1) (1969) 41–48

15. Floyd, R.W.: Assigning meaning to programs. In Schwartz, J.T., ed.: Proceed-
ings of Symposia Applied Mathematics of the American Mathematical Society –
Mathematical Aspects of Computer Science. Volume 19., American Mathematical
Society (April 1966) 19–32 Reprinted in [91].

16. Parnas, D.L.: A technique for software module speciﬁcation with examples. Com-

munications of the ACM 15(5) (1972) 330–336

17. Dijkstra, E.W.: Guarded commands, nondeterminacy and formal derivation of

programs. Communications of the ACM 18(8) (1975) 453–457

18. Liskov, B.H.: A design methodology for reliable software systems. In: Proceedings
of American Federation of Information Processing Societies ’72 Fall Joint Com-
puter Conference - Part I. Volume 41 of AFIPS Conference Proceedings., AFIPS
/ ACM / Thomson Book Company, Washington D.C. (December 1972) 191–199
19. Hoare, C.A.R. In: Chapter II: Notes on data structuring. Volume 8 of A.P.I.C.

Studies in data processing. Academic Press (1972) 94–185

20. Hoare, C.A.R.: Proof of correctness of data representations. Acta Informatica

1(4) (1972) 271–281

21. Hoare, C.A.R.: Recursive data structures.

and Information Science 4(2) (1975) 105–132

International Journal of Computer

22. Liskov, B.H., Zilles, S.N.: Programming with abstract data types. ACM SIG-

PLAN Notices 9(4) (1974) 50–59 Also in [92].

23. Liskov, B.H., Zilles, S.N.: Speciﬁcation techniques for data abstractions. ACM

SIGPLAN Notices 10(6) (1975) 72–87 Also in [93].

24. Liskov, B.H.

In: Chapter 1: An introduction to formal speciﬁcations of data
abstractions. Volume 1 of Current trends in programming methodology. Prentice
Hall (1977) 1–32

25. Guttag, J.V.: Abstract data types and the development of data structures. Com-

munications of the ACM 20(6) (1977) 396–404

26. Guttag, J.V., Horowitz, E., Musser, D.R.: Abstract data types and software

validation. Communications of the ACM 21(12) (1978) 1048–1064

27. Goguen, J.A., Thatcher, J.W., Wagner, E.G. In: Chapter 5: An initial algebra
approach to the speciﬁcation, correctness, and implementation of abstract data
types. Volume 4 of Current trends in programming methodology. Prentice Hall
(1977) 80–149

28. de Carvalho, R.L., Maibaum, T.S.E., Pequeno, T.H.C., Pereda, A.A., Veloso,
P.A.S.: A model theoretic approach to the theory of abstract data types and
data structures. Research Report CS-80-22, Department of Computer Science,
University of Waterloo (April 1980)

29. de Carvalho, R.L., Maibaum, T.S.E., Pequeno, T.H.C., Pereda, A.A., Veloso,
P.A.S.: A model theoretic approach to the theory of abstract data types and data
structures. In Yau, S.S., ed.: Proceedings of International Computer Symposium
– (ICS’82), IEEE Computer Society (December 1982)

30. Maibaum, T.S.E.: Conservative extensions, interpretations between theories and
all that!
In Bidoit, M., Dauchet, M., eds.: Proceedings of CAAP/FASE – 7th
International Joint Conference Theory and Practice of Software Development
(TAPSOFT’97). Volume 1214 of Lecture Notes in Computer Science., Springer-
Verlag (1997) 40–66

31. Ehrich, H.D.: On the theory of speciﬁcation, implementation, and parametrization

of abstract data types. Journal of the ACM 29(1) (1982) 206–227

32. Maibaum, T.S.E., Veloso, P.A.S.: A logical approach to abstract data types.
Technical report, Department of Computing, Imperial College, and Departamento
de Informatica, PUC/RJ (1981)

33. Maibaum, T.S.E., Sadler, M.R., Veloso, P.A.S.: Logical speciﬁcation and imple-
mentation. Technical report, Department of Computing, Imperial College (1983)
34. Maibaum, T.S.E., Sadler, M.R., Veloso, P.A.S.: A straightforward approach to pa-
rameterised speciﬁcations. Technical report, Department of Computing, Imperial
College (1983)

35. Maibaum, T.S.E., Sadler, M.R., Veloso, P.A.S.: Logical speciﬁcation and imple-
In Joseph, M., Shyamasundar, R., eds.: Proceedings of the Fourth

mentation.

Conference on Foundations of Software Technology and Theoretical Computer
Science. Volume 181 of Lecture Notes in Computer Science., Springer-Verlag (De-
cember 1984) 13–30

36. Maibaum, T.S.E., Veloso, P.A.S., Sadler, M.R.: A theory of abstract data types
for program development: Bridging the gap? In Ehrig, H., Floyd, C., Nivat,
M., Thatcher, J.W., eds.: Proceedings of Mathematical Foundations of Software
Development – International Joint Conference on Theory and Practice of Soft-
ware Development (TAPSOFT’85), Volume 2: Colloquium on Software Engineer-
ing (CSE). Volume 186 of Lecture Notes in Computer Science., Springer-Verlag
(March 1985) 214–230

37. Karp, C.C.: Languages with expressions of inﬁnite length. North Holland, Ams-

terdam (1964)

38. Goguen, J.A., Burstall, R.M.: Introducing institutions. In Clarke, E.M., Kozen,
D., eds.: Proceedings of the Carnegie Mellon Workshop on Logic of Programs.
Volume 184 of Lecture Notes in Computer Science., Springer-Verlag (1984) 221–
256

39. Tarlecki, A.: Bits and pieces of the theory of institutions. In Pitt, D.H., Abramsky,
S., Poigné, A., Rydeheard, D.E., eds.: Proceedings of the Category Theory and
Computer Programming, tutorial and workshop. Volume 240 of Lecture Notes in
Computer Science., Springer-Verlag (1986) 334–363

40. Sannella, D., Tarlecki, A.: Speciﬁcations in an arbitrary institution. Information

and computation 76(2–3) (1988) 165–210

41. Durán, F., Meseguer, J.: Structured theories and institutions. Theoretical Com-

puter Science 1–3(309) (2003) 357–380

42. Sannella, D., Tarlecki, A.: Toward formal development of programs from algebraic
speciﬁcations: Implementations revisited. Acta Informatica 25(3) (1988) 233–281
See also [94].

43. Sannella, D., Tarlecki, A.: Toward formal development of programs from algebraic
speciﬁcations: model-theoretic foundations.
In Kuich, W., ed.: Proceedings of
the 19th. Colloquium on Automata, Languages and Programming. Volume 623
of Lecture Notes in Computer Science., Vienna, Austria, Springer-Verlag (July
1992) 656–671 See also [95].

44. Tarlecki, A.: Moving between logical systems. [96] 478–502
45. Arrais, M., Fiadeiro, J.L.: Unifying theories in diﬀerent institutions. [96] 81–101
46. Mossakowski, T.: Diﬀerent types of arrow between logical frameworks. In Meyer,
F., Monien, B., eds.: Proceedings of 23rd International Colloquium on Automata,
Languages and Programming (ICALP ’96). Volume 1099 of Lecture Notes in
Computer Science., Springer-Verlag (1996) 158–169

47. Tarlecki, A.: Towards heterogeneous speciﬁcations.

In Gabbay, D., de Rijke,
M., eds.: Frontiers of Combining Systems. Volume 2 of Studies in Logic and
Computation. Research Studies Press (2000) 337–360

48. Bernot, G., Coudert, S., Gall, P.L.: Towards heterogeneous formal speciﬁcation.
In Wirsing, M., Nivat, M., eds.: Proceedings of the 5th. International Conference
Algebraic on Methodology and Software Technology – AMAST 1996. Volume
1101 of Lecture Notes in Computer Science., Munich, Germany, Springer-Verlag
(July 1996) 458–472

49. Mossakowski, T.: Foundations of heterogeneous speciﬁcation. In Wirsing, M., Pat-
tinson, D., Hennicker, R., eds.: Proceedings of the 16th. International Workshop
on Recent Trends in Algebraic Development Techniques WADT 2002. Volume
2755 of Lecture Notes in Computer Science., Frauenchiemsee, Germany, Springer-
Verlag (September 2002) 359–375

50. Meseguer, J.: General logics. In Ebbinghaus, H.D., Fernandez-Prida, J., Garrido,
M., Lascar, D., Artalejo, M.R., eds.: Proceedings of the Logic Colloquium ’87.
Volume 129., Granada, Spain, North Holland (1989) 275–329

51. Fiadeiro, J.L., Maibaum, T.S.E.: Generalising interpretations between theories in
the context of π-institutions. In Burn, G., Gay, D., Ryan, M., eds.: Proceedings
of the First Imperial College Department of Computing Workshop on Theory and
Formal Methods, London, UK, Springer-Verlag (1993) 126–147

52. Schoenﬁeld, J.R.: Degrees of unsolvability. Number 2 in Mathematical studies.

North Holland (1971)

53. Beth, E.W.: The Foundations of Mathematics. North Holland (1959)
54. Beth, E.W.: Semantic entailment and formal derivability. In Hintikka, J., ed.:
The Philosophy of Mathematics. Oxford University Press (1969) 9–41 Reprinted
from [97].
55. Herbrand, J.:

In Goldfarb, W.D., ed.: Logical
Writings. Harvard University Press (1969) 44–202 Translated to english from
[98].

Investigation in proof theory.

56. Gentzen, G.: The collected papers of gerhard gentzen.

In Szabo, M.E., ed.:
Investigation into logical deduction. North Holland (1969) 68–131 Translated to
english from [99].

57. Smullyan, R.M.: First-order Logic. Dover Publishing (1995)
58. Robinson, J.A.: A machine-oriented logic based on the resolution principle. Jour-

nal of the ACM 12(1) (1965) 23–41

59. Lopez Pombo, C.G., Castro, P., Aguirre, N.M., Maibaum, T.S.E.: Satisﬁabil-
ity calculus: An abstract formulation of semantic proof systems. Fundamenta
Informaticae 166(4) (2019) 297–347

60. Jackson, D.: Alloy: a lightweight object modelling notation. ACM Transactions

on Software Engineering and Methodology 11(2) (2002) 256–290

61. Owre, S., Rajan, S., Rushby, J.M., Shankar, N., Srivas, M.: PVS: Combining
speciﬁcation, proof checking, and model checking. In Alur, R., Henzinger, T.A.,
eds.: Proceedings of the 9th. Computer Aided Veriﬁcation (CAV). Volume 1102
of Lecture Notes in Computer Science., New Brunswick, NJ, Springer-Verlag
(July/August 1996) 411–414

62. Dowek, G., Felty, A., Herbelin, H., Huet, G., Murthy, C., Parent, C., Paulin-
Mohring, C., Werner, B.: The coq proof assistant user’s guide (version 5.8).
Technical Report 154, INRIA, Rocquencourt, France (1993)

63. Nipkow, T., Paulson, L.C., Wenzel, M.:

Isabelle/HOL – A proof assistant for
higher-order logic. Volume 2283 of Lecture Notes in Computer Science. Springer-
Verlag, Berlin, Germany (2002)

64. Frias, M.F., Lopez Pombo, C.G., Moscato, M.M.: Alloy Analyzer+PVS in the

analysis and veriﬁcation of Alloy speciﬁcations. [100] 587–601

65. Blanchette, J.C., Nipkow, T.: Nitpick: A counterexample generator for higher-
order logic based on a relational model ﬁnder. In Kaufmann, M., Paulson, L.C.,
eds.: Proceedings of First International Conference on Interactive Theorem Prov-
ing (ITP 2010). Volume 6172 of Lecture Notes in Computer Science., Berlin,
Heidelberg, Springer-Verlag (July 2010) 131–146

66. Torlak, E., Jackson, D.: Kodkod: A relational model ﬁnder. [100] 632–647
67. Blanchette, J.C.: Picking Nits: A User’s Guide to Nitpick for Isabelle/HOL.
Institut für Informatik, Technische Universität München. (April 2020) Available
https://isabelle.in.tum.de/doc/nitpick.pdf.

68. Jackson, D.: Automating ﬁrst-order relational logic. In: Proceedings of the 8th
ACM SIGSOFT international symposium on Foundations of software engineering,
San Diego, California, United States, Association for the Computer Machinery,
ACM Press (2000) 130–139

69. Mac Lane, S.: Categories for working mathematician. Graduate Texts in Mathe-

matics. Springer-Verlag, Berlin, Germany (1971)

70. Fiadeiro, J.L.: Categories for software engineering. Springer-Verlag (2005)
71. Cassano, V., Lopez Pombo, C.G., Maibaum, T.S.E.: Entailment systems for
default reasoning. In Martí-Oliet, N., Palomino Tarjuelo, M., eds.: Proceedings
of 21st International Workshop on Algebraic Development Techniques (WADT
2012), Salamanca, Spain (June 2012) 28–30

72. Reiter, R.: A logic for default reasoning. Artiﬁcial Intelligence 13(1-2) (1980)

81–132

73. Lopez Pombo, C.G.: Fork algebras as a tool for reasoning across heterogeneous
speciﬁcations. PhD thesis, Departamento de Computación, Facultad de Ciencias
Exactas y Naturales, Universidad de Buenos Aires (2007) Promotor: Marcelo F.
Frias.

74. Frias, M.F., Baum, G.A., Maibaum, T.S.E.:

Interpretability of ﬁrst-order dy-
namic logic in a relational calculus. In de Swart, H., ed.: Proceedings of the 6th.
Conference on Relational Methods in Computer Science (RelMiCS) - TARSKI.
Volume 2561 of Lecture Notes in Computer Science., Oisterwijk, The Netherlands,
Springer-Verlag (October 2002) 66–80

75. Haeberer, A.M., Veloso, P.A.S.: Partial relations for program derivation: ade-
quacy, inevitability and expressiveness.
In: Proceedings of IFIP TC2 working
conference on constructing programs from speciﬁcations, IFIP TC2: Software:
Theory and Practice, North Holland (1991) 310–352

76. Frias, M.F.: Fork algebras in algebra, logic and computer science. Volume 2 of

Advances in logic. World Scientiﬁc Publishing Co., Singapore (2002)

77. Lopez Pombo, C.G., Castro, P., Aguirre, N.M., Maibaum, T.S.E.: Satisﬁability
calculi: the semantic counterpart of proof calculi in general logics. In Martí-Oliet,
N., Palomino Tarjuelo, M., eds.: Proceedings of 21st International Workshop on
Algebraic Development Techniques (WADT 2012) and IFIP International Feder-
ation for Information Processing (2013). Volume 7841 of Lecture Notes in Com-
puter Science., Salamanca, Spain, Springer-Verlag (June 2013) 195–211

78. Goguen, J.A., Burstall, R.M.: Institutions: abstract model theory for speciﬁcation

and programming. Journal of the ACM 39(1) (1992) 95–146

79. Goguen, J.A., Roşu, G.: Institution morphisms. Formal Aspects of Computing

13(3-5) (2002) 274–307

80. Mossakowski, T., Tarlecki, A.: Heterogeneous logical environments for distributed
speciﬁcations. In Corradini, A., Montanari, U., eds.: Proceedings of 19th Interna-
tional Workshop in Algebraic Development Techniques. Volume 5486 of Lecture
Notes in Computer Science., Pisa, Italy, Springer-Verlag (June 2009) 266–289
81. Lopez Pombo, C.G., Castro, P., Aguirre, N.M., Maibaum, T.S.E.: A heteroge-
neous characterisation of component-based system design in a categorical setting.
In Ciobanu, G., Ipate, F., eds.: Proceedings of 11th International Colloquium
Theoretical Aspects of Computing - ICTAC 2014. Volume 8687 of Lecture Notes
in Computer Science., Springer-Verlag (September 2014) 314–332

82. Mossakowski, T., Maeder, C., Luttich, K.: The heterogeneous tool set, Hets. [100]

519–522

83. Diaconescu, R., Futatsugi, K.: Logical foundations of CafeOBJ. Theoretical

Computer Science 285(2) (2002) 289–318

84. Castro, P., Aguirre, N.M., Lopez Pombo, C.G., Maibaum, T.S.E.: Categorical
foundations for structured speciﬁcations in Z. Formal Aspects of Computing
27(5-6) (2015) 831–865

85. Borzyszkowski, T.: Logical systems for structured speciﬁcations. Theoretical

Computer Science 286 (2002) 197–245

86. Mossakowski, T., Tarlecki, A.: A relatively complete calculus for structured
heterogeneous speciﬁcations.
In Muscholl, A., ed.: Proceedings of 17th Inter-
national Conference on Foundations of Software Science and Computation Struc-
tures (FOSSACS 2014), held as Part of the European Joint Conferences on Theory
and Practice of Software. Volume 8412 of Lecture Notes in Computer Science.,
Springer-Verlag (2014) 441–456

87. Lopez Pombo, C.G., Frias, M.F.: 16. In: (Heterogeneous) Structured Speciﬁca-
tions in Logics Without Interpolation. Volume 17 of Outstanding Contributions
to Logic. Springer International publishing (2018)

88. Castro, P., Aguirre, N.M., Lopez Pombo, C.G., Maibaum, T.S.E.: Towards man-
aging dynamic reconﬁguration of software systems in a categorical setting.
In
Cavalcanti, A., D’eharbe, D., Gaudel, M.C., Woodcock, J., eds.: Proceedings of
Theoretical Aspects of Computing - ICTAC 2010, 7th International Colloquium.
Volume 6255 of Lecture Notes in Computer Science., Natal, Rio Grande do Norte,
Brazil, Springer-Verlag (September 2010) 306–321

89. Castro, P., Aguirre, N.M., Lopez Pombo, C.G., Maibaum, T.S.E.: A categori-
cal approach to structuring and promoting Z speciﬁcations. In Pasareanu, C.S.,
Salaün, G., eds.: Proceedings of 9th International Symposium Formal Aspects of
Component Software – FACS 2012. Volume 7684 of Lecture Notes in Computer
Science., Springer-Verlag (2013) 73–91

90. Gimenez, M., Moscato, M.M., Lopez Pombo, C.G., Frias, M.F.: HeteroGenius:
a framework for hybrid analysis of heterogeneous software speciﬁcations.
In
Aguirre, N.M., Ribeiro, L., eds.: Proceedings of Latin American Workshop on
Formal Methods 2013. (August 2013) 1045–1058 Workshop aﬃliated to [101].
91. Floyd, R.W. In: Assigning meaning to programs. Volume 14 of Studies in Cogni-

tive Systems. Springer-Verlag (1993) 65–81 Reprint of [15].

92. Liskov, B.H., Zilles, S.N.: Programming with abstract data types. In: Proceedings
of ACM SIGPLAN Symposium on Very High Level Languages, Association for
the Computer Machinery, ACM Press (1974) 50–59 Also in [22].

93. Liskov, B.H., Zilles, S.N.: Speciﬁcation techniques for data abstractions.

In
Shooman, M.L., Yeh, R.T.Y., eds.: Proceedings of the International Conference
on Reliable Software, Los Angeles, California, ACM Press (1975) 72–87 Also in
[23].

94. Sannella, D., Tarlecki, A.: Toward formal development of programs from algebraic
speciﬁcations: implementations revisited. Technical Report 17, Laboratory for
foundations of computer science, The University of Edinburgh (1986) Preliminar
version of [42].

95. Sannella, D., Tarlecki, A.: Toward formal development of programs from algebraic
speciﬁcations: model-theoretic foundations. Technical Report 204, Laboratory for
foundations of computer science, The University of Edinburgh (1992)

96. Haveraaen, M., Owe, O., Dahl, O.J., eds.

In Haveraaen, M., Owe, O., Dahl,
O.J., eds.: Selected papers from the 11th Workshop on Speciﬁcation of Abstract
Data Types Joint with the 8th COMPASS Workshop on Recent Trends in Data
Type Speciﬁcation. Volume 1130 of Lecture Notes in Computer Science., Springer-
Verlag (1996)

97. Beth, E.W.: Semantic entailment and formal derivability. Mededlingen van de
Koninklijke Nederlandse Akademie van Wetenschappen, Afdeling Letterkunde
18(13) (1955) 309–342 Reprinted in [54].

98. Herbrand, J.: Recherches sur la theorie de la demonstration. PhD thesis, Univer-

sité de Paris (1930) English translation in [55].

99. Gentzen, G.: Untersuchungen tiber das logische schliessen. Mathematische

Zeitschrijt 39 (1935) 176–210 and 405–431 English translation in [56].

100. Grumberg, O., Huth, M., eds. In Grumberg, O., Huth, M., eds.: Proceedings of the
13th. International Conference on Tools and Algorithms for the Construction and
Analysis of Systems (TACAS 2007). Volume 4424 of Lecture Notes in Computer
Science., Braga, Portugal, Springer-Verlag (April 2007)

101. D’Argenio, P.R., Melgratti, H., eds. In D’Argenio, P.R., Melgratti, H., eds.: Pro-
ceedings of 24th International Conference on Concurrency Theory – CONCUR
2013. Volume 8052 of Lecture Notes in Computer Science., Springer-Verlag (2013)

A Selected proofs

In this section we will present detailed explanations, deﬁnitions and proofs of
the results supporting the examples we presented in Sections 2 and 3.

A.1 Example 1: Tableau method for ﬁrst-order predicate logic

In Ex. 1 we presented the tableau method for ﬁrst-order predicate logic and
the intuitions for how it ﬁts into the deﬁnition of a satisﬁability calculus. In
this section we will provide the formal deﬁnitions and the results proving it. Let
IF OL =
, the institution of ﬁrst-order predicate
logic.

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|
(cid:10)

(cid:11)

Deﬁnition 25. Let Σ ∈ |Sign| and Γ ⊆ Sen(Σ), we deﬁne Str Σ,Γ = hO, Ai
such that O = 2Sen(Σ) and A = {α : {Ai}i∈I ! {Bj}j∈J | α = {αj}j∈J }, where
for all j ∈ J , αj is a branch in a tableau for Γ ∪ {Bj} with leaves ∆ ⊆ {Ai}i∈I;
∆ |=Σ Γ ∪ {Bj} follows as a direct consequence of the deﬁnition.

Lemma 7. Let Σ ∈ |Sign| and Γ ⊆ Sen(Σ), then Str Σ,Γ deﬁned as in Deﬁni-
tion 25 is a category.

Proof. Let us prove that Str Σ,Γ = hO, Ai is a category. For any set {Ai}i∈I ∈ O,
the identity is given by the collection of branches αi : {Ai} (of length 1), i.e., no
rule is applied.

Now, given α : {Ai}i∈I ! {Bj}j∈J , β : {Bj}j∈J ! {Cq}q∈Q ∈ A, their
composition β ◦ α = γ is deﬁned as follows: let {αj : {Bj} ! · · · ! S ∪
{Ai}i∈I }j∈J and {βq : {Cq} ! · · · ! S′ ∪ {Bj}j∈J }q∈Q be branches; then,
{γq : {Cq} ! · · · ! {Bj}j∈J ∪ S′ ! · · · ! {Ai}i∈I ∪ S ∪ S′}q∈Q is the branch
obtained by extending each branch in β with the corresponding branches in α.

It remains to prove that ◦ has identities and is associative. Both proofs are
straightforward by observing that ◦ is deﬁned to be the concatenation of se-
quences of sets of formulae.

Lemma 8. Let Σ ∈ |Sign| and Γ ⊆ Sen(Σ); then
, where ∪ :
Str Σ,Γ × Str Σ,Γ ! Str Σ,Γ is the typical bi-functor on sets and functions, and ∅
(cid:11)
is the neutral element for ∪, is a strict monoidal category.

Str Σ,Γ , ∪, ∅
(cid:10)

Proof. Consider the bifunctor ∪ : Str Σ,Γ × Str Σ,Γ ! Str Σ,Γ which behaves
as follows: Given sets A and B A ∪ B is their union. Given a pair of arrows
α : A ! B and β : C ! D, where α = {αi}i∈I and β = {βj}j∈J , their union is
α ∪ β = {αi}i∈I ∪ {βj}j∈J . Note that this functor is well deﬁned: the union of
the identities id{Ai}i∈I ∪ id{Bj }j∈J is a set of branches of length 1 and so is an
identity too; and the composition is preserved, since it is built point wise. On
the other hand, the identity object of the monoidal category is ∅ and the natural
isomorphisms are given by the identity which trivially makes the associativity
and identity diagrams commute.

is

Deﬁnition 26. StructSC
{

hO, Aiop
deﬁned
=
!
Str Σ,Γ , ∪, ∅
| Σ ∈ |Sign| ∧ Γ ⊆ Sen(Σ)}, and A = {
Str Σ′,Γ ′
(cid:11)
(cid:10)
| σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th||}, the homomorphic extensions
, ∪, ∅
D
E
of the morphisms in ||Th|| to sets of formulae preserving the application of rules
(i.e., the structure of the tableaux).

Str Σ,Γ , ∪, ∅
(cid:10)

where O

σ :

as

b

(cid:11)

Lemma 9. Let StructSC be deﬁned as in Def. 26. Then, StructSC is a category.

Proof. First we prove that hO, Ai where O = {

Str Σ,Γ , ∪, ∅
Γ ⊆ Sen(Σ)}, and A = {
(cid:10)
hΣ′, Γ ′i ∈ ||Th||} is a category.

σ :

b

!

(cid:11)

D

Str Σ,Γ , ∪, ∅
Str Σ′,Γ ′
(cid:10)
, ∪, ∅

| Σ ∈ |Sign| ∧
| σ : hΣ, Γ i !

(cid:11)
E

b

Morphisms

σ ∈ A are the homomorphic extension of the morphisms σ ∈
||Th|| to the structure of the tableaux, translating sets of formulae and preserv-
σ2 ∈ A,
ing the application of the rules. Following this, the composition of
the homomorphic extension of σ1, σ2 ∈ ||Th||, not only exists, but it is the ho-
momorphic extension of the morphism σ1 ◦ σ2 ∈ ||Th||. The associativity of the
composition is also trivial to prove by considering that the morphisms are homo-
morphic extensions, and by the associativity of the composition of morphisms
in Th. The identity morphism is the homomorphic extension of the identity
morphism for the corresponding signature.

σ1,

c

c

Then, as a direct consequence we obtain that StructSC is a category.

Deﬁnition 27. M : Thop ! StructSC is deﬁned as M(hΣ, Γ i) =
and for any σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th||, M(σop) =
Str Σ,Γ , ∪, ∅
(cid:10)
tures in

Str Σ,Γ , ∪, ∅
σ :
(cid:11)
(cid:10)
is the homomorphic extension of σ to the struc-

σop where

Str Σ′,Γ ′

, ∪, ∅

!

D

E

b

b

(cid:11)

Str Σ,Γ , ∪, ∅
(cid:10)

.
(cid:11)

Lemma 10. Let M : Thop ! StructSC be deﬁned as in Deﬁnition 27. Then M
is a functor.

Proof. Let idhΣ,Γ i : hΣ, Γ i ! hΣ, Γ i ∈ ||Th|| be the identity morphism for
op) = idhStr Σ,Γ ,∪,∅i
op because, by Def. 26, id hStr Σ,Γ ,∪,∅i
hΣ, Γ i ∈ |Th|. M(id hΣ,Γ i
is the homomorphic extension of idhΣ,Γ i to the structures in Str Σ,Γ .

Let σ1 : hΣ1, Γ1i ! hΣ2, Γ2i , σ2 : hΣ2, Γ2i ! hΣ3, Γ3i ∈ ||Th||; now, as
composition of homomorphisms is a homomorphism, then M((σ1 ◦ σ2)op) =
op) by deﬁnition of opposite category. Thus, it is the composition
M(σ2
M(σ2

op ◦ σ1
op) ◦ M(σ1

op).

Deﬁnition 28. Mods : StructSC ! Cat is deﬁned as:

Str Σ,Γ , ∪, ∅
– Mods(
(cid:10)
∅ ∈ |Str Σ,Γ |)(
¬(∃ϕ)({¬ϕ, ϕ} ⊆
e

) = hO, Ai where O =
(cid:11)

| (∃α : ∆ !
∆
: ∆′ ! ∆ ∈ ||Str Σ,Γ ||)(∆′ = ∆) ∧
e

∆ ! ∅ ∈ α ∧ (∀α′

Σ,

S

D

E

{

∆))} and A = {idT : T ! T | T ∈ O}, and

– for all σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ ||Th||, Mods(

σop)(hΣ, δi) = hΣ′, Sen(σ)(δ)i.

e

Lemma 11. Let Mods : StructSC ! Cat deﬁned as in Deﬁnition 28. Then,
Mods is a functor.

b

(cid:11)

!

, ∪, ∅

Str Σ′,Γ ′

Str Σ,Γ , ∪, ∅

Str Σ,Γ , ∪, ∅
(cid:10)

Proof. As for each theory
)
is a discrete category containing theory presentations whose models are mod-
(cid:11)
els of hΣ, Γ i, thus the only property that must be proved is that for all
σ :
)|,
(cid:11)
) =

∈ ||StructSC||, o ∈ |Mods(
(cid:10)
)|. By deﬁnition, Mods(

∈ |StructSC |, Mods(
(cid:10)

Str Σ,Γ , ∪, ∅
(cid:10)
Mods(
b

(cid:11)
σ)(o) ∈ |Mods(

D
. Observe that, as a consequence of the fact that

E
σ is the
D
homomorphic extension of Sen(σ) to the tree-like structure of tableaux, the
theory presentation obtained by applying Mods(
σ) to a particular element of
Str Σ,Γ , ∪, ∅
Mods(
) is a theory presentation whose set of axioms is a leaf of a
b
(cid:11)
(cid:10)

Σ′, Sen(σ)(
b

Str Σ,Γ , ∪, ∅

Str Σ′,Γ ′

E
, ∪, ∅

σ)(

∆)

Σ,

∆

E

D

D

E

b

e

b

e

branch of a tableau in

Str Σ′,Γ ′

, ∪, ∅

D

.
E

Deﬁnition 29. Let hΣ, ∆i ∈ |Th|, then we deﬁne µhΣ,∆i : models(hΣ, ∆i) !
ModF OL(hΣ, ∆i) as for all hΣ, δi ∈ |models(hΣ, ∆i)|, µhΣ,∆i(hΣ, δi) =
ModF OL(hΣ, δi).

Fact A1 Let hΣ, Γ i ∈ |Th| and µhΣ,∆i : models(hΣ, ∆i) ! ModF OL(hΣ, ∆i)
deﬁned as in Def. 29. Let Σ ∈ |SignF OL| and Γ ⊆ SenF OL(Σ), then µhΣ,Γ i is a
functor.

: models(hΣ, ∆i) !
Lemma 12. Let
ModF OL(hΣ, ∆i) deﬁned as in Deﬁnition 29. Then, µ is a natural family of
functors.

hΣ, Γ i ∈ |Th| and µhΣ,∆i

Proof. Let hΣ, Γ i , hΣ′, Γ ′i ∈ |Th| and σ : hΣ, Γ i ! hΣ′, Γ ′i ∈ |Th0|. Then, the
naturality condition for µ can be expressed in the following way:

hΣ′, ∆′i

models(σ)

/ hΣ, ∆i

µhΣ′ ,∆′i

µhΣ,∆i

ModF OL(hΣ′, ∆′i)

ModF OL(σ)

/ ModF OL(hΣ, ∆i)

It is trivial to check that this condition holds by observing that canonical models
are closed theories, thus behaving as theory presentations in Th.

Now, from Lemmas 10, 11, and 12, and considering the hypothesis that IF OL

is an institution, the following corollary follows.

Corollary 7.
calculus.

(cid:10)

Sign, Sen, Mod, {|=Σ}Σ∈|Sign|, M, Mods, µ

is a satisﬁability

(cid:11)

A.2 Example 3: Eﬀectiveness of the satisﬁability subcalculus for

ﬁnite presentations over the term-free restriction of ﬁrst-order
modal logic

In Example 3 we presented an argument of how the satisﬁability subcalcu-
lus of the term-free fragment of ﬁrst-order modal logic of Ex. 2 ﬁts the def-
inition of an eﬀective satisﬁability subcalculus. In this section we will pro-
vide the formal deﬁnitions and the results proving it. Let us denote by
Q =
a satisﬁabil-
ity subcalculus for ﬁrst-order modal logic.

Sign, Sen, Mod, Sign0, Sen0, ax, {|=Σ}Σ∈|Sign|, M, Mods, µ
(cid:10)

(cid:11)
Sign0 is a complete subcategory of Sign so we assume J : Sign0

! Sign to be
the functor that for all Σ ∈ |Sign0|, J(Σ) = Σ and for all σ ∈ ||Sign0||, J(σ) = σ.

Deﬁnition 30. Sen0 is deﬁned as the subfunctor of Sen resulting from restrict-
ing the latter to the objects and morphisms in Sign0.

Lemma 13. Sen0 : Sign0

! Space is a functor.

! Space is a functor, we need to prove that:
Proof. To prove that Sen0 : Sign0
1. given Σ ∈ |Sign0|, Sen0(Σ) is a space, 2. given σ : Σ ! Σ′ ∈ ||Sign0||,
Sen0(σ) is a total function between Sen0(Σ) and Sen0(Σ′), and 3. Sen0 pre-
serves identities and composition.

The ﬁrst condition is trivial Σ ∈ |Sign0|, Sen0(Σ) = Sen(Σ) which is the
inﬁnite set of ﬁnite formulae recognised by the regular grammar presented in

(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
Ex. 2 for ﬁrst-order modal logic. Thus, Sen0(Σ) is a space. The second con-
dition also results trivial because Sen0(σ) is the homomorphic extension of σ
along the grammar mentioned before, so it is a function mapping formulae in
space Sen0(Σ) to formulae in space Sen0(Σ′). Finally, it is easy to observe
that whenever Sen0 is applied to an identity morphism, the result is an identity
function between formulae of the corresponding space. The preservation of com-
position also follows easily by checking that the composition of the homomorphic
extensions of two morphisms results in the same function that the homomorphic
extension of the composition of the morphisms.

Lemma 14. Let U : Space ! Set be the obvious forgetful functor projecting the
underlying set of objects of the space and the total functions between them as
morphisms; then U ◦ Sen0 = Sen ◦ J.

Proof. The proof follows by observing that: 1) J : Sign0 ֒! Sign is the identity
inclusion functor, 2) the nature of U : Space ! Set, and 3) Sen0 is the subfunctor
of Sen restricted to the objects and morphisms of Sign0

Let Σ ∈ |Sign0|, then, as J is the identity inclusion functor, J(Σ) = Σ. Then,
as Σ ∈ |Sign0|, Sen(Σ) = U(Sen0(Σ)) because Sen0 is the subfunctor of Sen.
The case of morphisms is analogous but considering sets, instead of functions.

Lemma 15. ax : Sign ! Space is a functor

Proof. The proof is analogous to the one of Lemma 13 but considering the exten-
sion of the functor Sen0, which operates on formulae, to ﬁnite sets of formulae.

Lemma 16. Mods : StructSC ! Space is a functor.

Proof. The proof is analogous to the one of Lemma 15 but considering the exten-
sion of the functor ax, which operates on ﬁnite sets formulae, to ﬁnite tree-like
structures whose nodes are ﬁnite sets of formulae.

