arXiv

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi
Interpolation

ENRICO BERTOLAZZI, Dipartimento di Ingegneria Industriale Universit`a degli Studi di Trento.
ANTONELLA FALINI, Dipartimento di Informatica, Universit`a degli Studi di Bari Aldo Moro, Italy.
FRANCESCA MAZZIA, Dipartimento di Informatica, Universit`a degli Studi di Bari Aldo Moro, Italy.

The library QIBSH++ is a C++ object oriented library for the solution of Quasi Interpolation problems. The

library is based on a Hermite Quasi Interpolating operator, which was derived as continuous extensions

of linear multistep methods applied for the numerical solution of Boundary Value Problems for Ordinary

Diﬀerential Equations. The library includes the possibility to use Hermite data or to apply a ﬁnite diﬀerence

scheme for derivative approximations, when derivative values are not directly available. The generalization

of the quasi interpolation procedure to surfaces and volumes approximation by means of a tensor product

technique is also implemented. The method has been also generalized for one dimensional vectorial data,

periodic data, and for two dimensional data in cylindrical coordinates, periodic with respect to the angular

argument. Numerical tests show that the library could be used eﬃciently in many practical problems.

Categories and Subject Descriptors: G.1.1 [Numerical Analysis]: Interpolation

General Terms: Algorithms, Theory, Design

Additional Key Words and Phrases: Quasi Interpolation, B-splines

1. INTRODUCTION

There has been a lot of study in constructing good software for interpolation and data ﬁtting
using spline. The ﬁrst package pppack of de Boor, was available in Netlib from 1992 but the
ﬁrst release was dated 1971 [de Boor, 1972; de Boor, 2001]. The Matlab package for spline
interpolation and ﬁtting data is based on the de Boor subroutines. Later on in 1973, the
algorithm numbered 461, was published on ACM Transaction of mathematical software and
it was related to he computation of a cubic spline approximation to the solution of a linear
second order boundary value ordinary diﬀerential equations [Burkowski and Hoskins, 1973].
The same journal published in 2016 a B-spline Adaptive Collocation software for PDEs with
Interpolation-Based Spatial Error Control [Pew et al., 2016]. Both algorithms use spline
functions for the solution of diﬀerential problems with collocation. In 1993 the tspack
package for tension spline curve-ﬁtting package [Renka, 1993] and in 2009 its extension
for curve design and data ﬁtting [Renka, 2009] have been published. Nowadays, a lot of

Author’s addresses:
E. Bertolazzi, Dipartimento di Ingegneria Industriale, Universit`a degli Studi di Trento, Via Sommarive 9,
Trento (ITaly) email:enrico.bertolazzi@unitn.it
and
A. Falini, Dipartimento di Informatica, Universit`a degli Studi di Bari Aldo Moro, Via Orabona 4, 70125
Bari (Italy). email:antonella.falini@uniba.it
and
F. Mazzia, Dipartimento di Informatica, Universit`a degli Studi di Bari Aldo Moro, Via Orabona 4, 70125
Bari (Italy). email:francesca.mazzia@uniba.it

2
2
0
2

g
u
A
5

]

A
N
.
h
t
a
m

[

1
v
0
6
2
3
0
.
8
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
arXiv 2

E. Bertolazzi and A. Falini and F. Mazzia

wrappers or re-implementations of the pppack library are available in diﬀerent languages
like C, C++, Python, Matlab. Other functions for scattered data are available. We recall
the Fortran package fitpack of Paul Dierks available in Netlib [Dierckx, 1993] and the C
package TSFIT for two-stage scattered data ﬁtting [Davydov and Zeilfelder, 2005]; the C++
library G+SMO [J¨uttler et al., 2014; Mantzaﬂaris, 2019] and the GeoPDEs package [De Falco
et al., 2011; V´azquez, 2016], both for iso-geometric analysis. Other libraries and software’s
available for spline ﬁtting and geometric spline constructions are [Elber, 1990; Schumaker,
2018; Grimstad et al., 2015; Walker et al., 2019] .

The library we present here is based on the so called Hermite BS quasi-interpolant (BSH
QI in short) introduced in [Mazzia and Sestini, 2009a], derived from a class of linear mul-
tistep boundary value methods based on spline collocation [Mazzia et al., 2006a].

Univariate spline Quasi Interpolants (QIs) are operators for function approximations with

the following form:

Qd (f ) =

(cid:88)

j∈J

µj(f )Bj,

(1)

where {Bj, j ∈ J} is the B-spline basis of a given degree d, and µj(f ) are local linear
functionals. One of the main properties of QIs is that the coeﬃcients µj(f ) depend locally
on the data, making them competitive with respect to global approximation methods.

The library QIBSH++ is an object oriented extension of the C library QIBSH presented
in [Iurino and Mazzia, 2013], [Iurino, 2014] and includes all the procedures for the BSH Quasi
Interpolation scheme, a generalization of the former to be used when derivative values are
not available, and an extension of the BSH QI operator to bivariate and trivariate functions,
which uses a suitable tensor product technique. Moreover, Matlab and Octave interfaces
have been implemented for all the objects, in order to make them available in this well
known numerical computing environment. This is an important feature, since some of the
procedures in QIBSH++ will be also part of the Matlab code TOM for the numerical solution of
Boundary Value Problem for Ordinary Diﬀerential Equations [Mazzia et al., 2006b; Mazzia
et al., 2006c; Mazzia et al., 2009a].

The aim of this library is to make available to a wider audience quasi-interpolation pro-
cedures that could be useful when interpolation is not necessary and the error in the data is
negligible. In many applications, moreover, the ﬁrst derivative is a known data and so Her-
mite quasi-interpolation could give more accurate results than standard quasi-interpolation.
We experienced a lack of general purpose codes based on high order quasi-interpolation, es-
pecially for two and three dimensional data and in many applications where is required in
output continuity for higher derivatives and for which codes that are based on radial basis
functions, or bi-variate splines are not suited.

In Section 2 we give a brief description of the BSH QI in one dimension, introducing also the
approximated BSH, where derivative values are not directly used in the operator, but derived
using suitable ﬁnite diﬀerence schemes. In Section 3 the BSH Quasi Interpolant is extended

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 3

to the approximation of tensor product surfaces and volumes. In Section 4 we describe the
implementation details of the algorithm. Finally, in Section 5 we provide some numerical
examples giving an idea of the performance of the QIBSH++ library. The behavior of QIBSH++
is compared to the QI method [Sablonni`ere, 2005], and QI linear, both implemented by the
authors and to the spline interpolation routines from Matlab, on standard test functions
from the literature. We also show how to improve the time eﬃciency of the TOM code for
BVP problems using the QIBSH++ library. Moreover, a surface parameterization with high
smoothness for complex geometries is presented in subsection 5.4. We conclude the work
showing that the QIBSH++ library can be applied for the solution of two real data problems:
a continuous digital elevation model and a biomedical application.

2. BSH QUASI INTERPOLANTS IN ONE DIMENSION

Diﬀerential quasi interpolants (DQI) [de Boor, 1976; de Boor, 2001] are linear approximat-
ing operators where the coeﬃcients of the approximating splines are computed by linear
combinations or averages of derivative values of f , a continuous function deﬁned on an in-
terval [a, b]. The idea of applying a Hermite Quasi Interpolating technique to our problem
comes from a diﬀerent area, since BS methods are a class of Boundary Value Methods for
ODEs [Brugnano and Trigiante, 1998; Mazzia et al., 2006b]. Using this class of BS methods
it is possible to determine a spline s = (cid:80)
i∈I ciBi on the mesh deﬁned by the knot vector
π = [x0, . . . , xN ], where a = x0 < x1 < . . . < xN = b, satisfying the Hermite interpolation
conditions s(xi) = fi, s(cid:48)(xi) = f (cid:48)
N are
i ∈ Rp ∀i,
respectively the values of the function f and of the ﬁrst derivative f (cid:48) and both, fi, f (cid:48)
with p > 1 for the multidimensional case.

i for all i = 0, . . . , N , where f0, . . . , fN and f (cid:48)

0, . . . , f (cid:48)

Here, the set {Bi : i ∈ I} is the B-spline basis for the space Sd,π of d-degree splines
on the knots π. The BS Hermite Quasi Interpolation scheme approximates a function
f on an interval [a, b] starting from its values, and from those of the ﬁrst derivative
on N + 1 mesh points π. We want an approximating function in the space Sd,π of the
splines of degree d with knots π. Usually, we work with an extended knot set consid-
ering a total of 2d additional boundary knots. The new knot set is then deﬁned as
τ = {τi}Nτ
i=1 = {x−d, . . . , x−1, x0, . . . , xN , xN +1, . . . , xN +d}, where Nτ = N + 2d + 1. The
auxiliary boundary knots are commonly chosen equal to the ending points of the interval.
The Quasi Interpolating spline is then:

Q(BS)
d

(f ) =

N −1
(cid:88)

j=−d

µ(BS)
j

(f )Bj,

(2)

arXiv 4

E. Bertolazzi and A. Falini and F. Mazzia

with the coeﬃcients µ(BS)

j

(f ) expressed by

µ(BS)
j

(f ) =

d
(cid:88)

i=1






ˆαi

ˆαi

ˆαi

(−1,j+d+1)fi−1 − hk1

ˆβi

(−1,j+d+1)

f (cid:48)
i−1

j = −d, . . . , −2,

(j,d)fi+j − hj+k1+1

ˆβi

(j,d)

f (cid:48)
i+j

j = −1, . . . , ˜N ,

(3)

( ˜N ,j+d− ˜N )f ˜N +i − hN −k2

ˆβi

( ˜N ,j+d− ˜N )

f (cid:48)
˜N +i

j = ˜N + 1, . . . , N − 1,

(cid:16)

(cid:17)T

ˆα(j,r)
1

, . . . , ˆα(j,r)

where ˜N = N − d, ˆα(j,r) =
are
d
solutions of local linear systems of size 2d × 2d, whose coeﬃcient matrix depends on the
values of the B-splines Bi (see [Mazzia et al., 2006b]). The functionals µ(BS)
(f ) in (2) depend
locally on the values (fi, f (cid:48)
i denote the exact function and
ﬁrst derivative values, respectively. Following the notation used in [Mazzia and Sestini,
2012], we write the coeﬃcients in the form:

i ), i = 0, . . . , N , where fi and f (cid:48)

and ˆβ(j,r) =

, . . . , ˆβ(j,r)

d

1

j

(cid:16) ˆβ(j,r)

(cid:17)T

µ(BS) = ( ˆA ⊗ Ip)f − ( ˆH ˆB ⊗ Ip)f (cid:48),

(4)

where ˆA and ˆB are banded matrices in RN +d×N +1 containing the local coeﬃcients ˆα(j,r)
and ˆβ(j,r), while ˆH = diag(ˆh1, . . . , ˆhN +d), with

ˆhi =






hk1 ,
hk1+i−d,
hN −k2 ,

if i ≤ d

if d + 1 ≤ i ≤ N

if i ≥ N + 1,

(5)

and f = (cid:0)f (cid:62)
p.

0 , . . . , f (cid:62)
N

(cid:1)(cid:62)

, f (cid:48) = (f (cid:48)
0

(cid:62), . . . , f (cid:48)
N

(cid:62))(cid:62), and Ip is the identity operator of dimension

The coeﬃcient determination of the Quasi Interpolant Q(BS)

(f ) in the B-spline rep-
resentation, requires the solution of local linear systems for j = −1, r = 1, . . . , d, for
0 ≤ j ≤ N − d − 1, r = d, and for j = N − d, r = d, . . . , 2d − 1. The computational cost is
the one for solving N +d linear systems of dimension 2d×2d. They are solved by the eﬃcient
and stable algorithm presented in [Mazzia et al., 2006c]. When low degree polynomials are
used, we can give explicit expressions of the coeﬃcient vectors. Note that for a uniform knot
mesh π, the inner coeﬃcient vectors ˆα(j,d) and ˆβ(j,d), for j = −1, . . . , N − d do not depend
on j, so the expressions of coeﬃcients µ(BS)

(f ) may be derived beforehand.

d

j

The Quasi Interpolation procedure described so far is of Hermite type, since it depends
on the function and its ﬁrst derivative values. Often in applications, we do not have such
information, and only approximate values of f and f (cid:48) are available. In some cases, we may
be given only the values of the function at mesh knots, and in order to construct the QI
we must use approximate values for the ﬁrst derivatives. For this reason, we combine the
Quasi Interpolation scheme with a symmetric ﬁnite diﬀerence scheme approximating the

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 5

derivatives of f at the mesh points. In order to distinguish it from the original one, we refer
to the original BSH as Q(BS)

, and to the one using approximate values of f (cid:48), as Q(BSa)

.

d

d

Indeed, we can approximate the ﬁrst derivative values of a suﬃciently smooth function
f on a grid x0 < . . . < xN , using the l-step ﬁnite diﬀerence scheme used in [Mazzia and
Sestini, 2012]. So we have the following scheme:






l
(cid:88)

i=0
l
(cid:88)

i=0
l
(cid:88)

i=0

γ(n)
i fi = f (cid:48)(xn) + O(hl),

n = 0, . . . , l1 − 1,

γ(n)
i fn−l1+i = f (cid:48)(xn) + O(hl), n = l1, . . . , N − l2,

(6)

γ(n)
i fN −l+i = f (cid:48)(xn) + O(hl), n = N − l2 + 1, . . . , N,

where l1 = (cid:98)l/2(cid:99), l2 = l − l1, hi = xi − xi−1, i = 1, . . . , N , and h = max1≤i≤N hi. The coef-
ﬁcients γ(n)
are computed imposing that the local truncation error of the resulting method
is O(hl). The derivative approximation scheme is modiﬁed in order to have a symmetric
global approximation when the mesh is symmetric. It can be written as

i

(Γ(l) ⊗ Ip)













f (x0)
...
f (xN )

=













f (cid:48)(x0)
...
f (cid:48)(xN )

+ O(hl),

(7)

where the banded matrix Γ(l) ∈ R(N +1)×(N +1) has the following structure:

· · ·

· · ·

0
...

0
. . .

Γ(l) =


























γ(0)
0
...
γ(l1−1)
0

0
...
...
...
...
0

· · ·

γ(0)
l
...
· · · γ(l1−1)
l
. . .
. . .

γ(j)
0
. . .

· · ·

· · ·

0
...
...
...
...


























.

(8)

. . .
γ(j)
l

· · ·
. . .
0 γ(N −l2+1)
...
...
γ(N )
0
0

0

0

. . .
. . .
· · · γ(N −l2+1)
l
...
γ(N )
l

· · ·

The ﬁrst derivative approximation on the mesh points is ˜f (cid:48) = (Γ(l) ⊗ Ip)f . Combining this

scheme with the BSH formula for the QI coeﬃcients we get the Quasi Interpolant:

Q(BSa)
d

(f ) =

N −1
(cid:88)

j=−d

˜µ(BSa)
j

(f )Bj,

(9)

arXiv 6

E. Bertolazzi and A. Falini and F. Mazzia

It can be proven that the following error bound holds:

(cid:107)f − Q(BSa)

d

(f )(cid:107)∞ ≤ Lhd+1(cid:107)Dd+1f (cid:107)∞ + ˜L hl+1,

(10)

where L and ˜L depends on the spline degree d, on the smoothness of f and on the geometric
properties, like quasi-uniformity, of the underlying knot mesh. For more details we refer
to [Falini et al., 2022]. Note that a similar error bound holds also for the operator Q(BS)
,
see [Mazzia and Sestini, 2009b] for the details.

d

3. BSH QUASI INTERPOLANTS AND TENSOR PRODUCT

The general tensor product framework can be used with the BSH QI from the previous
section. Applying the one dimensional operators either ﬁrst along the x-direction and then
the y-direction, or vice-versa, we compute the approximating surface. Suppose we are given
a function f : R2 → R f = f (x, y) deﬁned on a rectangular planar domain R = [a, b] × [c, d].
We choose the spline degrees to be dx and dy and select m1 = N + 1 and m2 = M + 1 knots
respectively on x and y directions. Consider the partitions with the additional boundary
knots deﬁned as:

τx = x−dx ≤ · · · ≤ x0 = a < · · · xi · · · < b = xN ≤ xN +1 ≤ · · · ≤ xN +dx ,

(11)

τy = y−dy ≤ · · · ≤ y0 = c < · · · yj · · · < d = yM ≤ yM +1 ≤ · · · ≤ yM +dy .

We denote the extended knot vectors as τx and τy, with sizes respectively Nτx and Nτy .
The dimension of the spline spaces are n1 = N + dx and n2 = M + dy respectively for each
knot partition. Any spline s in the tensor product space is written in the form:

s(x, y) =

n1(cid:88)

n2(cid:88)

p=1

q=1

cpqφp(x)ψq(y) ∀(x, y) ∈ R2,

(12)

where φp and ψq are the B-splines elements. Also, the exact values of the function f and
of its partial derivatives fx,fy and fxy are assigned on the grid points given in matrix form
respectively as F = (f )i,j, Fx = (fx)i,j, Fy = (fy)i,j, and Fxy = (fxy)i,j ∈ Rm1×m2 , where
fi,j = f (xi, yj) for all indices. The aim is to ﬁnd a function g = g(x, y) in the tensor product
space (12) aproximating f , ﬁnding the coeﬃcient matrix C = (cpq) ∈ Rn1×n2. The tensor
product technique applied to the BSH follows a very simple idea: the grid is divided into
knot lines according to its knot partitions, and a speciﬁc number of one dimensional QI
problems is solved along the two directions.
The coeﬃcients of the spline function s(x, y) are computed using the QI BSH tensor product
algorithm, which is summarized by the following steps.

(1) For each j = 1, ..., m2, pick up the function and the x partial derivatives of the j-th
. Solve m2 one

line in the grid, and use them applying the one dimensional BSH Q(BS)

dx

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 7

dimensional QI problems, storing the resulting coeﬃcients into the matrix D = (dpj) ∈
Rn1×m2 .
In matrix formulation we have

D = ˆAxF − ˆHx ˆBxFx,

(13)

where the subscript in the matrices ˆAx, ˆBx and ˆHx, speciﬁes the equation (4) for the local
coeﬃcients on the x-direction with p = 1.

(2) For each j = 1, ..., m2, pick up the y and the mixed xy partial derivatives of the
function f on the j-th line in the grid, and apply the one dimensional operator Q(BS)
. As in
the previous step, m2 one dimensional QI problems are solved, saving the coeﬃcients into
D(cid:48) = (d(cid:48)

pj) ∈ Rn1×m2. In matrix formulation:

dx

D(cid:48) = ˆAxFy − ˆHx ˆBxFxy.

(14)

(3) Now, simply switch the direction, and consider the quasi interpolant operator Q(BS)
along the y direction. For each p = 1, . . . , n1 pick up the values in the p-th rows of the
matrices D = (dp,j) and D(cid:48) = (d(cid:48)
p,j), and apply to these values the one dimensional BSH
Q(BS)
. So, after solving n1 one dimensional QI problems in the y direction, the matrix
dy
C = (cp,q) containing the coeﬃcients of the tensor product form (12) is built. Note that in
this last step we are using the BSH quasi interpolating scheme Q(BS)
on the y-direction,
replacing the function and derivative values by the elements from the matrices D and D(cid:48),
namely in matrix form:

dy

dy

C = D ˆAT

y − D(cid:48)( ˆHy ˆBy)T =

(cid:16) ˆAxF − ˆHx ˆBxFx

(cid:17) ˆAT

y −

(cid:16) ˆAxFy − ˆHx ˆBxFxy

(cid:17) (cid:16) ˆHy ˆBy

(cid:17)T

. (15)

When only function values are available, approximations for partial derivatives in both
directions are computed using the scheme (7), that is

Fx ≈ Γ(lx)

x F, Fy ≈ F(Γ(ly)

y

)T , Fxy ≈ Fx(Γ(ly)

y

)T ≈ Γ(lx)

x Fy ≈ Γ(l)

x F(Γ(ly)

y

)T .

(16)

Matrix expressions (13) and (14) from the tensor product scheme are now

D(a) = ˆAxF − ˆHx ˆBxΓ(lx)

x F,

and D(cid:48)(a) = ˆAxF(Γ(ly)

y

and they satisfy

D(cid:48)(a) = D(a)(Γ(ly)

y

)T .

)T − ˆHx ˆBxΓ(ly)

x F(Γ(ly)

y

)T ,

(17)

(18)

This proves it is theoretically equivalent, to compute the approximation of partial derivatives
starting from F, and then apply the tensor product of BSH QI, or apply the ﬁnite diﬀerence
scheme to the elements in D(a). The latter way has been used in our library implementation,
since it reduces the computational cost. The coeﬃcients matrix of the representation (12)

arXiv 8

E. Bertolazzi and A. Falini and F. Mazzia

is obtained in this case as

C(a) = ( ˆAx − ˆHx ˆBxΓ(lx)

x

or, in a more compact form:

)F ˆAT

y − ( ˆAx − ˆHx ˆBxΓ(l)

x )F(Γ(ly)

y

)T ( ˆHy ˆBy)T ,

(19)

C(a) = ( ˆAx − ˆHx ˆBxΓ(lx)

x

)F( ˆAy − ˆHy ˆByΓ(ly)

y

)T .

(20)

In the following, we address the extension of the operator Q(BSa)
to the approximation
of a three valued function f = f (x, y, z), with f : R3 → R deﬁned on a domain R =
[ax, bx] × [ay, by] × [az, bz].

d

Consider the partitions with the additional boundary knots deﬁned as:

τx = x−dx ≤ . . . ≤ x0 = ax < . . . xi . . . < bx = xNx ≤ xNx+1 ≤ . . . ≤ xNx+dx ,

τy = y−dy ≤ . . . ≤ y0 = ay < . . . yj . . . < by = yNy ≤ yNy+1 ≤ . . . ≤ yNy+dy .

(21)

τz = z−dz ≤ . . . ≤ z0 = az < . . . zj . . . < bz = zNz ≤ zNz+1 ≤ . . . ≤ zNz+dz .

To explain better the application of the quasi-interpolant on a multi dimensional space it
is convenient to express the data using a three dimensional tensor

F ∈ RN x×N y×N z,

fijk = f (xi, yj, zk)

and the coeﬃcients of the spline using n-mode product between a tensor X ∈ RI1×I2×I3
and a matrix A ∈ Rn×Ij as deﬁned in [Kolda and Bader, 2009]:

Y = X ×j A ⇔ Yj = AXj

where Yj, Xj are the mode-j unfolding of Y and X .

Here we report only the version of the quasi-interpolant using approximate derivative,
because it is less expensive from a computational point of view. The coeﬃcient of the
approximated BSH QI version can been in fact calculated, like for the bi-dimensional case,
by applying the one dimensional quasi-interpolant along the three directions. We obtain
that:

C(a) = F ×1 ( ˆAx − ˆHx ˆBxΓ(lx)

x

) ×2 ( ˆAy − ˆHy ˆByΓ(ly)

y

)T ×3 ( ˆAz − ˆHz ˆBzΓ(lz)

z

)T .

(22)

Additional details can be found in [Falini et al., 2022].

Remark 3.1. Note that by using the n-mode product we can express the coeﬃcient ma-

trix of equation (20) as,

C (a) = F ×1 ( ˆAx − ˆHx ˆBxΓ(lx)

x

) ×2 ( ˆAy − ˆHy ˆByΓ(ly)

y

)T .

With this operation also the generalization to any dimension can be easily derived.

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 9

4. IMPLEMENTATION DETAILS

The library QIBSH++ is a collection of C++ procedures managing the Hermite Quasi Inter-
polation for functions of one (scalar and vectorial functions), two and three variables. A
Matlab toolbox is also available, that allow to handle all the procedure in Matlab.

This library is an improved version of the C version of QIBSH library described in [Iurino,
2014; Iurino and Mazzia, 2013]. The new implementation use more eﬃciently memory and
dynamic memory usage. The C++ classes are mapped in Matlab classes using MEX interfac-
ing mechanism. In practice each Matlab class instance store a pointer to the corresponding
C++ class instance and each method for the Matlab class call a method of the corresponding
C++ class.

This approach permits to develop and test algorithm using QIBSH in Matlab. This remap-
ping introduce an overhead that is small and acceptable for the proposed applications. In
any case, for best performance it is easy to translate to Matlab to C++.

4.1. C++ classes

The library is organized as a set of classes that interact together for the Quasi interpolant
build and evaluation.

— B-spline basis computation

— Bspline

This class implement the classical B-spline as described in [de Boor, 2001; Schumaker,
2007]. Recurrence formula for derivative and integral, standard knot placements, tensor
product B-spline evaluation given the support polygon.

— Finite Diﬀerence

— FiniteDifferenceUniformD1
— FiniteDifferenceD1

This two classes implement the ﬁnite diﬀerence approximation of derivative given a list
(xi, yi) of interpolation points. The class FiniteDifferenceUniformD1 do the same
computation more eﬃciently when coordinated xi are uniformly distributed.

— Derivative approximation

— ApproximateDerivative
— ApproximateDerivative2D

This classes uses FiniteDifferenceUniformD1 and FiniteDifferenceD1 to build
the ﬁnite diﬀerence approximation of a set of one dimensional (xi, yi) or two dimensional
(xij, yij, zij) function sampling. In 2D cases mixed derivatives are obtained by applying
ﬁnite diﬀerence in the y direction to the approximate x derivative. The classes manages
cyclic data approximation if required.

— Quasi Hermite 1D
— QuasiHermite

arXiv 10

E. Bertolazzi and A. Falini and F. Mazzia

— QuasiHermiteApprox

The classes compute the B-spline polygon corresponding to the QIBSH approximation.
The ﬁrst class uses points and analytical derivative at the corresponding points. The
second class approximate the derivative using ﬁnite diﬀerence from class Approximat-
eDerivative.+
— Quasi Hermite 2D

— QuasiHermite2D

This is the base class that compute the polygon for the B-spline that correspond to the
QIBSH approximation of 2D surface data. The 2D points are passed to the class with
x, y and mixed xy derivatives at the points.

— QuasiHermite2Dapprox

This class is derived from QuasiHermite2D and compute the polygon for the B-spline
that correspond to the QIBSH approximation of 2D surface data. The derivative respect
to x, y and mixed xy needed for base class are approximated using ﬁnite diﬀerence
with class ApproximateDerivative2D.

— QuasiHermite2Dsurface

This class is derived from QuasiHermite2D. In addition the class store the computed
B-spline polygon so that can be evaluated at any points without the requirement to
pass the B-spline polygon.

— QuasiHermite2DapproxSurface

This class is derived from QuasiHermite2Dapprox. In addition the class store the
computed B-spline polygon so that can be evaluated at any points without the require-
ment to pass the B-spline polygon.

4.2. Matlab classes

QIBSH++ library is connected with Matlab using MEX interface. The mapping is not one to
one but is a little bit of higher level.

— B-spline basis computation

— Bspline

This is a one-to-one remap of the corresponding C++ class.

— Bspline1D

This Matlab class remap the C++ class QuasiHermite and QuasiHermiteApprox.
It stores in the Matlab class data the B-spline polygon and can use analytical derivative
or use ﬁnite diﬀerence approximation.

— Approximation of derivatives using ﬁnite diﬀerence

— ApproximateDerivative1D
— ApproximateDerivative2D

This is a one-to-one remap of the corresponding C++ class.

— Spline build using quasi interpolation

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 11

— QIBSH1D
— QIBSH2D

This are high level remaps of the C++ classes QuasiHermite, QuasiHermiteApprox,
QuasiHermite2D, QuasiHermiteApprox2D with the storage in the Matlab class
of the resulting B-spline polygon.

The Matlab usage of the QIBSH library is particularly simple:

f o r 1D Quasi

I n t e r p o l a n t

i n t e r p o l a n t

1 % I n s t a n t i a t e i n Q a MATLAB c l a s s
2 Q = QIBSH1D( ’ Qhermite ’ ) ;
3 % B u i l d a q u a s i
4 % d
5 % ( x ( i ) , y ( i ) ) = q u a s i
6 % yprime ( i )
7 % f i f t h argument
8 Q. b u i l d ( d , x , y , yprime ,

= d e r i v a t i v e a t

= d e g r e e o f

i f

f a l s e ) ;

t h e i n t e r p o l a n t

i n t e r p o l a t i o n p o i n t s

t r u e b u i l d a p e r i o d i c q u a s i

t h e q u a s i

i n t e r p o l a t i o n p o i n t
i n t e r p o l a n t

after build is easy to compute points and derivative on the B-spline:

1 % E v a l u a t e y = Q( x )
2 y = Q. e v a l ( x ) ;
3 % E v a l u a t e y = Q’ ( x )
4 Dy = Q. e v a l ( x , 1 ) ;
5 % E v a l u a t e y = Q’ ’ ( x )
6 DDy = Q. e v a l ( x , 2 ) ;

The interface is very intuitive with few example it is easy to practice with the library. Here

is a example of quasi-interpolation of a set of points taken from a sampling of a function:

1 % s e t

t h e f u n c t i o n t o be approximated

e f f e = @( x ) exp(−x ) . ∗ s i n ( 5 ∗ p i ∗x ) ;
e f f e 1 = @( x )
[ a , b ] = d e a l ( −1 ,1) ; % r a n g e o f

2

3

4

t h e f u n c t i o n

( ( 5 ∗ p i ∗ c o s ( 5 ∗ p i ∗x ) ) − s i n ( 5 ∗ p i ∗x ) ) . ∗ exp(−x ) ;

= 4 ;
= 1 4 ;
= 1 0 0 0 ;

5 d
6 N
7 m
8 % p l o t
9 xx = l i n s p a c e ( a , b ,m) ; yy = e f f e ( xx ) ;
10 p l o t ( xx , yy ,

’ LineWidth ’ , 3 ,

t h e f u n c t i o n

% d e g r e e o f q u a s i
% number o f
% number o f e v a l u a t i o n p o i n t s

s a mp li n g p o i n t s

i n t e r p o l a n t

’ b l a c k ’

) ;

’ C o l o r ’ ,

f o r p l o t t i n g

11

12 % Sample f u n c t i o n and e v a l u a t e f and f ’ a t sample p o i n t s
13 x = l i n s p a c e ( a , b ,N) ; y = e f f e ( x ) ; yprime = e f f e 1 ( x ) ;

14

arXiv 12

E. Bertolazzi and A. Falini and F. Mazzia

15 % C r e a t e a QIBSH o b j e c t
16 Q = QIBSH1D( ’ Qhermite ’ ) ;
i n t e r p o l a n t
17 % b u i l d q u a s i
18 Q. b u i l d ( d , x , y , yprime ,

f o r 1D q u a s i −i n t e r p o l a t i o n

( x , y ) data , no c y c l i c data .

f o r
f a l s e ) ;

19

20 % p l o t
21 h o l d on ;
22 p l o t ( x , y ,

t h e s am pl i ng p o i n t s

’ ob ’ ,

’ Ma rk e r Si ze ’ , 1 0 ,

’ MarkerFaceColor ’ ,

’ r e d ’

) ;

23

24 % p l o t
25 p l o t ( xx , Q. e v a l ( xx ) ,

t h e approximated i n t e r p o l a n t

’ : ’ ,
l e g e n d ( ’ f u n c t i o n ’ , ’ sample−p o i n t s ’ , ’Q−i n t e r p o l a n t ’ ) ;

’ LineWidth ’ , 3 ,

’ C o l o r ’ ,

26

’ b l u e ’

) ;

The output of the script is shown in Fig. 1.

Fig. 1. Output of quasi-interpolant for function e−x sin(5πx) with 14 equally spaced sample points in the
interval [−1, 1].

4.3. Procedures for Quasi Interpolation of Function of One Variable

Using the library we can solve the one dimensional problem of Quasi Interpolation. Given
the values of a function and of its ﬁrst derivatives at some points, provided a knot set and the
desired spline degree, the user can ﬁnd the Hermite spline quasi interpolating the data. The
ﬁnal approximation of the QI (BS) is given in terms of its B-spline coeﬃcients. Optionally,
function and derivative evaluations can also be returned. When ﬁrst derivative values are

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 13

not available, their approximations are ﬁrst computed and the QI (BSa) quasi-interpolant is
used.

In addition, speciﬁc procedures for the treatment of periodic functions are available.
These functions specializes the QI procedures for the coeﬃcients and for the ﬁnite diﬀerence
scheme, when periodic knots are used.

4.4. Procedures for Tensor Product Quasi Interpolation

The computation of two dimensional BSH QI in the tensor product form follows the scheme
from Section 3. For data organized on regular grids, the idea is to split the process into
one dimensional problems along the axes directions, quasi interpolating the values of the
function and of partial derivatives given in matrix form. When partial derivatives are not
available, we combines the tensor product of BSH QI with the ﬁnite diﬀerence scheme (6).
The implementation to reduce the computational costs is based on the computation of x-
partial derivatives values of the matrix F and generating the approximations for Fx. Then,
one dimensional QI problems along the x axis are solved storing the coeﬃcients into an
auxiliary matrix D(a). Now, the approximate derivative of D(a) are computed and stored
in the matrix D(cid:48)(a). These two matrices are used for the last step: the solutions of QI
problems along the y axis, having D(a) and D(cid:48)(a) as inputs, returns the spline coeﬃcients.
Computational cost is reduced since the aprroximation of the derivatives are related to
two function calls rather than three. Moreover, for the matrix case, the computation of the
coeﬃcients γ(n)
in (6), and of the matrix Γ(l) in (7) is done only once.Finally we remark that
also the tensor product case has been generalized and adapted for function domains which
can easily be described in polar coordinates in the plane. Hence, we can use the library to
compute the QI or derivative approximations for a periodic function f = f (ρ, θ) of period
T > 0 with respect to its second argument θ.

i

In the mD case the quasi interpolant is implemented only when the derivatives are ap-
proximated, using a generalization of the 2D procedure. In this case the computational
costs remain related to the dimension m. The use of the exact derivatives has a higher
computational cost, so it has not be considered.

5. NUMERICAL TESTS

5.1. Functions of One Variable

We report the convergence results for the BSH Quasi Interpolant on the test function

f1(x) = e−x sin(5πx) x ∈ [−1, 1]

(23)

from [Mazzia and Sestini, 2009a]. Numerical examples are performed using the Matlab
Toolbox QIBSH++.

The Table I shows the errors and the estimated orders of convergence of the Quasi In-
and

terpolant. For spline degree d = 3 we apply to the function test the operators Q(BS)

d

arXiv 14

E. Bertolazzi and A. Falini and F. Mazzia

Fig. 2. Work precision diagram for the function f1. On the left d = 3 is used, while on the right d = 5 is
adopted.

Fig. 3. Convergence plots for the function f (x) = sin(x), varying the adopted QI degree.

Fig. 4. Convergence plots for the function f2 with a non uniform knot partition, varying the used QI degree.

Q(BSa)
, deﬁned respectively in (2) and (9). For the sake of comparison, we use also a discrete
d
Quasi Interpolant of the same degree d, here denoted as QIS, described in [Sablonni`ere,

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 15

Table I. Convergence Analysis : function f1, spline degree 3, GBDF order 4.

N
16
32
64
128
256
512
1024

N
16
32
64
128
256
512
1024

Error
1.7 × 10−1
8.8 × 10−3
3.1 × 10−4
2.4 × 10−5
9.1 × 10−7
7.5 × 10−8
4.2 × 10−9

Error
5.2 × 10−1
1.1 × 10−2
2.6 × 10−4
2.2 × 10−5
9.0 × 10−7
7.5 × 10−8
4.2 × 10−9

QIBSH
Order
∗∗
4.3
4.8
3.7
4.7
3.6
4.2

Matlab
Order
∗∗
5.6
5.3
3.6
4.6
3.6
4.1

t
1.4 × 10−5
1.6 × 10−5
1.4 × 10−5
1.4 × 10−5
1.8 × 10−5
2.8 × 10−5
5.3 × 10−5

t
6.5 × 10−4
1.2 × 10−3
2.3 × 10−3
3.8 × 10−3
6.1 × 10−3
1.4 × 10−2
3.3 × 10−2

Error
8.5 × 10−1
7.3 × 10−3
1.5 × 10−4
1.8 × 10−5
8.3 × 10−7
7.4 × 10−8
4.2 × 10−9

Error
4.9 × 10−1
5.1 × 10−2
4.0 × 10−3
2.7 × 10−4
1.6 × 10−5
1.1 × 10−6
6.5 × 10−8

QIBSHa
Order
∗∗
6.9
5.6
3.1
4.4
3.5
4.1

QIS
Order
∗∗
3.3
3.7
3.9
4.1
3.9
4.0

t
2.4 × 10−5
2.7 × 10−5
2.0 × 10−5
2.4 × 10−5
3.6 × 10−5
6.0 × 10−5
1.1 × 10−4

t
1.3 × 10−4
1.3 × 10−4
1.9 × 10−4
1.3 × 10−4
1.5 × 10−4
1.5 × 10−4
1.8 × 10−4

2005] and the spline interpolant spapi from Matlab [MATLAB, 2012]. As usual, N is the
number of mesh steps between uniformly spaced N +1 spline knots, and errors are estimated
by the inﬁnity norm on 1000 points uniformly spaced in the domain of the functions, the
timing t is computed as the averaged time over 40 runs (in secs.) for approximating the
test functions and evaluating the spline using an Intel Core I7-6500U 2.50GHz with Matlab
R2020a for Windows (64 bit). The error values conﬁrm the expected rate of convergence
for Q(BS)
, as d + 1. We also report the convergence behaviour for the operator
d
QI (BS) and QI (BSa) for d ranging between 2 and 5 in Figure 3. Moreover, since the described
quasi-interpolant operator can also be applied with a non-uniform knot partition, in Figure
e−x/s − e(x−2)/s
1 − e−2/s

4 we show the convergence behavior for this case with the function f2 =

and Q(BSa)
d

,

and s = 10−3/2.

Note that as N increases, the error using Q(BS)

becomes similar, especially
for the choice l = d+1. To preserve the order of convergence it is enough to choose l = d, but
the part of the error due to the derivative approximation is dominant in this case. These
results suggest that the use of Q(BSa)
can be competitive with other DQI interpolants,
especially when the approximation of higher order derivatives is required.

and Q(BSa)
d

d

d

Moreover, comparing the computational time (expressed in secs.) in the Table I and in
Figure 2 top for d = 3 and in Figure 2 bottom, for d = 5, conﬁrms the eﬃciency of the QI
BSH with respect to the other methods.

5.2. Numerical solution of Boundary Value Problems

The main aim of the library QIBSH is to improve the performance of the Matlab code TOM
for the numerical solution of Boundary Value Problems (BVPs) that are assumed to have

arXiv 16

E. Bertolazzi and A. Falini and F. Mazzia

the ﬁrst order system form,

y(cid:48)(x) = f (x, y),

a ≤ x ≤ b,

(24)

where y ∈ Rm, f : R × Rm → Rm, with boundary conditions,

g(y(a), y(b)) = 0.

Fig. 5. Work-precision diagram. Linear problem bvpT6 with diﬀerent values of λ.

Fig. 6. Work-precision diagram. Non linear problem bvpT30 with diﬀerent values of λ.

The ﬁrst release of the code has been described in [Mazzia and Trigiante, 2004] whereas
the update release that include the BS linear multistep method is described in [Mazzia et al.,
2009b]. One of the main characteristic of the code is that it implements an hybrid mesh
selection based on conditioning. With the inclusion of the BS-scheme the code was able to
solve very diﬃcult singularly perturbed BVPs, giving in output a continuous approximation
of the solution, but was not able to have an eﬃcient execution time for general problem, the
Matlab code spending most of the time in computing the variable coeﬃcients of the linear
multistep methods. We do not describe here the new release of the code but we just show
how the use of the library QIBSH make this code faster with respect to the original Matlab
version and competitive with the Matlab codes bvp4c and bvp5c and the code bvptwp [Cash

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 17

et al., 2013]. The library has been integrated with the code TOM for both the evaluation
of the coeﬃcients of the linear multistep BS method and the evaluation of the continuous
extensions, needed for nonlinear problems when the mesh is changed. The quasi-interpolant
is also used when the multistep method is the Top Order Method, or another class of
Boundary Value Method, as quasi-interpolation scheme.

Here we report some numerical experiment on two singularly perturbed boundary value
problems used in [Cash et al., 2013] and available in [Mazzia and Cash, 2015]. We choose
two examples in this class that require changes of the mesh in order to compute the numer-
ical solution and need a variable step-size. All the examples in this section have been run
using Matlab R2021b on iMac with a 3.6 GHz Intel core i9, 10 core.

The ﬁrst numerical test chosen is the problem bvpT6, the second is the nonlinear problem

bvpT30. Both are singular perturbed problems with a turning point.

We use diﬀerent values of the parameter λ and we select input tolerances atol = rtol
as 10−3, 10−4, · · · , 10−8. The code TOM is used with the BS method of order 6 and the
hybrid mesh selection denoted NSSE [Mazzia, 2022], designed for the solution of non stiﬀ
problems. The work precision diagrams are reported in Figures 5-6. The two codes called
TOM and TOM QIBSH++ denote the code TOM with and without the use of the library QIBSH,
we compare them with the codes bvp4c, bvp5c, twpbvpc l, twpbvpc m and twpbvp m. The
last are some of the available codes in the package bvptwp, the ﬁrst one use the conditioning
in the mesh selection and the Lobatto schemes, the second is based on Monoimplicit Runge-
Kutta schemes. It is interesting to see that in all the experiments the use of the library QIBSH
reduce considerable the time and make the code TOM comparable with the other available
codes. We observe that for the nonlinear problem bvpT30 with parameter λ = 10−3 only
the codes with a mesh selection based on conditioning are able to compute a solution. In
this case Figure 6 clearly show the eﬃciency of the code TOM QIBSH++. Further experiments
using the code can been found in [Mazzia and Settanni, 2021; Mazzia, 2022].

5.3. Functions of Two Variables

We use the BSH tensor product on the well known Franke function from the test suite in
[Franke, 1982; Renka and Brown, 1999].

The Table II summarizes the results on the test function for the tensor product spline
of degrees dx = dy = 3, and the choice l = dx + 1 = dy + 1 for the order of the ﬁnite
diﬀerence scheme. Again, we are comparing the behavior of the tensor product formulation
of the operators Q(BS)
, to the tensor product of the DQI QIS, and to the one
from Matlab spapi. Inﬁnity norm errors are computed against the exact values on a uniform
grid of 101 × 101 points in the unit square. The numerical experiments are carried out on a
personal computer Intel Core I7-6500U 2.50GHz with Matlab 2020a for Windows (64 bit).

and Q(BSa)
d

d

arXiv 18

E. Bertolazzi and A. Falini and F. Mazzia

Table II. Convergence Analysis for test function Franke: bivariate tensor product spline
of degrees 3 × 3 GBDF order 4.

N
16
32
64
128
256
512
1024

N
16
32
64
128
256
512
1024

Err
2.9 × 10−3
1.1 × 10−4
5.2 × 10−6
2.9 × 10−7
1.6 × 10−8
1.1 × 10−9
7.2 × 10−11

Err
2.1 × 10−3
7.9 × 10−5
4.6 × 10−6
2.9 × 10−7
1.6 × 10−8
1.1 × 10−9
4.1 × 10−14

QIBSH
Ord
∗ ∗ ∗
4.7
4.4
4.1
4.2
3.9
3.9
Matlab
Ord
∗ ∗ ∗
4.7
4.1
4.0
4.2
3.9
14.7

t
9.6 × 10−4
9.8 × 10−4
1.1 × 10−3
1.4 × 10−3
2.8 × 10−3
1.1 × 10−2
4.5 × 10−2

t
4.4 × 10−3
6.6 × 10−3
9.5 × 10−3
1.8 × 10−2
3.2 × 10−2
9.4 × 10−2
3.7 × 10−1

Err
1.8 × 10−3
1.3 × 10−4
2.2 × 10−6
2.4 × 10−7
1.5 × 10−8
1.1 × 10−9
7.2 × 10−11

Err
9.3 × 10−3
7.9 × 10−4
5.2 × 10−5
3.4 × 10−6
2.2 × 10−7
1.4 × 10−8
8.5 × 10−10

QIBSHa
Ord
∗ ∗ ∗
3.9
5.9
3.2
4.0
3.8
3.9
QIS
Ord
∗ ∗ ∗
3.6
3.9
3.9
4.0
4.0
4.0

t
9.7 × 10−4
1.0 × 10−3
1.1 × 10−3
1.5 × 10−3
3.6 × 10−3
1.2 × 10−2
5.7 × 10−2

t
2.3 × 10−3
2.3 × 10−3
3.2 × 10−3
3.4 × 10−3
7.8 × 10−3
2.6 × 10−2
8.5 × 10−2

d

When fewer knots are available, it is convenient to use the operator Q(BSa)

, choosing
at least l = d1otherwise the error for the ﬁrst derivatives approximations gets larger. On
the contrary, as N increases, and a larger number of knots is available, the user can use
a ﬁnite diﬀerence scheme increasing the approximation order l. Indeed, for N ≥ 256, the
approximation for BSH gives the same results. In particular they tend to have the same
behavior of BSH, as if the partial derivatives values would have been available. The Hermite
Quasi Interpolant in these cases has smoothed all the ﬁrst partial derivative approximating
errors. Note that the computational time between Q(BS) and Q(BSa) does not diﬀer so
much. In fact, this is due to the eﬃcient approximation for the derivatives, which is not
adding any signiﬁcant computational cost to the one of the QI.
Indeed, comparing the time eﬃciency of the QIBSH++ tensor product operator to the other
interpolants tested, conﬁrms its good behaviour as an approximating method for functions
of two variables in terms of goodness of ﬁt and timing. In Figure 7 we also report the work
precision diagrams for the Franke function with biddegree d = 3 and d = 5. This motivates
once more the use of the Hermite Quasi Interpolant even when partial derivatives are not
directly available, a situation often occurring in real applications, as it will be shown later.
Also for the 2D case, we analyze an example where the convergence can beneﬁt from
a non uniform mesh partition. In particular, we approximate the Schrek’s ﬁrst surface

(cid:19)

(cid:18) cos(y)
cos(x)

restricting our-self to the square domain

(cid:104)

−

π
2

+ η,

π
2

(cid:105)2

− η

, with

f (x, y) = log

η = 10−2. As shown in Figure 8, the considered example is a minimal area surface which
exhibits a high variation along each side of the deﬁnition domain. Therefore, a uniform
knot partition will not guarantee a suitable error reduction at the boundary layers. The

1since in the following tests we always adopt dx=dy, we simplify the notation by using the letter d = dx = dy
and denoting the used tensor product of bidegree d.

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 19

Fig. 7. Work precision diagram for the Franke function. On the left the used bidegree d = 3. On the right,
the used bidegree d = 5.

Fig. 8. Scherk’s ﬁrst surface.

convergence results are shown in Figure 9 also considering the spline bidegree d varying
from 2 to 5.

5.4. Surface parameterization with high smoothness for complex geometries

In this example we demonstrate how the tensor product BSH QI can be useful to pro-
duce spline parameterizations of complex geometries with the desired smoothness in any
direction. We construct a complex geometric model by assembling together three primitive
shapes: hollow hemisphere, cylinder and conical frustum. The resulting object is a glass ge-
ometry shape, see Figure 10. In order to construct a continuous spline approximation of the
considered object we need to reparametrize every shape in such a way to obtain conforming
parameter domains. More in detail, we consider a hollow hemisphere S with radius r = 2
described by a parameterization FS(θ, φ) : ΩS → S with ΩS := [0, 2π] × [−π, −0.2) with

arXiv 20

E. Bertolazzi and A. Falini and F. Mazzia

Fig. 9. Convergence analysis for the approximation of the Scherk’s ﬁrst surface. On the top, the results
obtained with the operators QI (BS) and QI (BSa) and a uniform knot partition. At the bottom, the achieved
results with the same operators but a non uniform knot partition. In both cases the spline bidegree d varies
from 2 to 5.

the following coordinates representation:

XS =r cos(θ) sin(−φ);

YS =r sin(θ) sin(−φ);

ZS =r cos(φ).

We consider only the values for ZS > 0. The cylinder C considered here can be described
by the following FC(θ, h) : ΩC → C, with ΩC = [0, 2π] × [−0.2, 6]. The physical coordinates
can be expressed as:

XC = rC cos(θ);

YC = rC sin(θ);

ZC =

(6 − r cos(−0.2))
(6 + 0.2)

(h + 0.2) + r cos(−0.2);

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 21

with r = 2 and rC = r sin(0.2). Finally the conical frustum V is deﬁned with FV (θ, v) :
ΩV → V , with ΩV = [0, 2π] × (6, 10]. The physical coordinates are computed as:

XV = a

v cos(θ)
10

;

YV = a

v sin(θ)
10

;

ZV = v;

with a uniformly varying from |rchf |/6 to 3. The three shapes are parameterized in
such a way that the resulting geometries can be physically joined with C 0 continuity
and their parameter domains can be assembled to form a unique domain Ω deﬁned as:
Ω = ΩS ∪ ΩC ∪ ΩV where we deﬁne our quasi-interpolant spline approximation F . In
this case Ω = [0, π] × [−π, 10]. If we are interested in constructing a C 0 representation F ,
at this stage we only need to call the constructor for the 2D object QIBSH and we can
compute a spline representation F with a chosen bidegree d, periodic along with the ﬁrst
direction, by approximating the Fx, Fy and Fxy with a ﬁnite diﬀerence scheme of order
(cid:96) = max{dx, dy} + 1. Although the resulting surface has in principle C d−1 smoothness,
its derivatives might present sharp variation and/or unwanted oscillations, see Figure 11,
left, where we plotted the ﬁrst derivative proﬁle with respect to the y direction. To get
an improved parametric representation, we therefore proceed as follows. Firstly the desired
smoothness for the ﬁnal approximation F is ﬁxed. For practical purposes we limit our-self
to the case of constructing a C 1 spline parameterization. Hence, the chosen degree should
be dx, dy ≥ 2. Secondly, since for this example the derivatives with respect to x direction
are almost zero, we will tackle only the derivatives with respect to the y direction.

Fig. 10.
joined with C0 continuity.

Initial surface. The primitive shapes of a hollow hemisphere, a cylinder and a conical frustum are

The proposed algorithm can be summarized with the following steps,

(1) A discrete approximation ˜Fyy of the second derivatives in the y direction is constructed,

by using ﬁnite centered diﬀerences.

(2) A continuous model of ˜Fyy is provided by applying the Q(BSa) operator, thus obtaining

˜Fyy ≈ QAyy.

arXiv 22

E. Bertolazzi and A. Falini and F. Mazzia

Fig. 11. First derivative proﬁle with respect to y direction. Left: the original construction. Right: the
regularized function after integration.

(3) The ﬁrst derivative QAy in y direction is now computed as,

QAy(ˆx, yz) :=

(cid:90) yz

c

QAyy(ˆx, z) dz,

where yz, z = 0, . . . , M , knots of the mesh.

The output of this procedure can be seen in Figure 11, right. We can visually appreciate
how the function results more regularized. Some oscillations are still visible, in fact, the
steps (1)-(3) can be performed by starting from any order of derivation and then can be
backward iterated till the computation of the approximant surface for the original one.

5.5. Functions of three Variables

We consider the following volume:

f (x, y, z) =

(cid:112)64 − 81((x − 1/2)2 + (y − 1/2)2 + (z − 1/2)2)
9

−

1
2

x, y, z ∈ [0, 1].

d

In Table III we report the maximum error and the estimated order of convergence for the
operator Q(BSa)
, by varying the used degree d for each direction and the number of mesh
steps N between uniformly spaced N + 1 knots. In the following test dx = dy = dz = d and
the approximation order (cid:96) for the derivatives is computed as d + 1 for d odd and as d + 2
for d even, in order to produce a symmetric output in line with the original function f . The
order of convergence d + 1 is reached in all the considered cases.

Table III. Convergence Analysis for the volume f in Section 5.5.

QIBSHa d = 2
Err
2.3 × 10−3
3.7 × 10−4
2.8 × 10−5
1.9 × 10−6
2.8 × 10−7

Ord
∗∗
2.6
3.8
3.9
2.8

QIBSHa d = 3
Err
1.7 × 10−3
2.7 × 10−4
1.6 × 10−5
5.8 × 10−7
1.4 × 10−8

Ord
∗∗
2.7
4.1
4.8
5.4

QIBSHa d = 4
Err
9.5 × 10−4
1.1 × 10−4
4.4 × 10−6
8.8 × 10−8
3.1 × 10−9

Ord
∗∗
3.1
4.7
5.6
4.9

QIBSHa d = 5
Err
9.6 × 10−4
1.2 × 10−4
4.3 × 10−6
6.7 × 10−8
9.2 × 10−10

Ord
∗∗
3.1
4.7
6.0
6.2

N
16
32
64
128
256

-4-20246810-0.500.511.522.5Derivative profile-4-20246810-0.500.511.522.5After int Derivative profileThe Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 23

5.6. Real World Data Tests

In this Section we report two real applications where the use of the library QIBSH gave
interesting results and improvements with respect to other usual techniques.

5.6.1. Continuous Digital Elevation Models. We consider data-sets available to produce Digi-
tal Elevation Models (DEM). DEM is a digital model or a 3D representation of a terrain’s
surface altitude with respect to the mean sea level. Technically DEM contains only the ele-
vation information without taking into account possible vegetation, buildings, or other types
of objects. DEM are generated by using the elevation information from points spaced either
at regular or irregular intervals. In the ﬁrst case, when the points are collected in regular
grids, we talk about raster DEM, in the latter case, the points are arranged in triangular
irregular networks, hence, we refer to vector DEM. In this example we use the NASADEM2: a
modernization of Global Digital Elevation Models. The satellite data are preprocessed ac-
cording to several optimization and interpolation algorithms and they are provided in grid
form. NASADEM products are freely available through the Land Processes Distributed Active
Archive Center (LP DAAC) at 1 arc-second spacing ( ∼ 30 meters). Data were collected
from February 11, 2000 to February 22, 2000. In order to produce a continuous model of
the discrete dataset, since the given samples are uniformly spaced (raster DEM), it is rea-
sonable to adopt a tensor product approach. In addition, the produced continuous model
should still be able to capture the abrupt changes in the terrain shape, so it is reasonable
to require up to C 2 smoothness.

Among the many application of DEM a continuous model might be used for 3D rendering
visualization purposes, hydrological and geomorphological investigations, rectiﬁcation of
satellite imagery, terrain correction and so on.

Fig. 12. NASADEM in the central Italian Appenini.

2NASA JPL (2021). NASADEM Merged DEM Global 1 arc second V001. Distributed by OpenTopography.
https://doi.org/10.5069/G93T9FD9Accessed:2021-08-22dataset

arXiv 24

E. Bertolazzi and A. Falini and F. Mazzia

In this example we select a terrain matrix of size 1197 × 2347 in the Italian Appenini
mountain region, see Fig. 12. In Table IV we report the root mean square error (RMSE)
and the normalized RMSE (NRMSE) on the quasi-interpolation nodes.

Table IV. RMSE and NRMSE on the quasi-
interpolation nodes.

QIBSHa
d = 2
6.32 × 10−1
4.22 × 10−4

QIBSHa
d = 3
7.54 × 10−2
5.03 × 10−5

RMSE
NRMSE

Since usually DEM involve a large amount of data, downsampling is a widely used tech-
nique to reduce the storage requirements. Our goal is to construct a quasi-interpolant spline
surface on half of the given data, and then to evaluate the produced output on the other
half of samples. The obtained results are compared with the available Matlab routines for
gridded interpolation: linear, cubic, nearest neighbour (N-N), cubic spline (Spline), modiﬁed
Akima (M-Akima). The RMSE and the NRMSE are reported in Table V.

Table V. RMSE and NRMSE results for the downsampling DEM, comparisons with the available Matlab routines..

Linear
d = 1

Cubic
d = 3

Spline
d = 3

2.63

2.10

2.04

1.76 × 10−3

1.41 × 10−3

1.36 × 10−3

N-N
d = 0
RMSE
8.97
NRMSE
6.00 × 10−3

M-Akima
d = 3

QIBSHa
d = 2

QIBSHa
d = 3

2.13

1.85

2.05

1.42 × 10−3

1.23 × 10−3

1.37 × 10−3

5.6.2. Curvature Inpainting of Corneal Topographer Data with Missing Regions. We present an-
other application of the tensor product BSH QI to a real problem. The main goal here
is to recover the elevation and the radial curvature data of a real eye, processing data
with missing points. Sometimes during the topographer acquisition phase it is impossi-
ble to detect data points in some regions: these are called inpainting regions and have
to be ﬁlled in by some numerical techniques. We apply the TV-H−1 inpainting model
[Burger et al., 2009; Sch¨onlieb and Bertozzi, 2011], implemented in the Matlab function
bvnegh inpainting convs[Sch¨onlieb, 2011]. Applying only this inpainting model to the
elevation data was not so succesfull, hence we apply it to the radial curvature values, com-
bining it with a regularizing phase given by the BSH QI interpolant. We start from the
elevation data of the surface in the regions where they are available, we approximate the
radial curvature, and then apply digital inpainting to the curvature values with missing
data. The curvature is computed along each radial direction approximating the radial par-
tial derivatives using the scheme (6). After the curvature of the missing regions is recovered
using the TV-H−1 inpainting, the elevations data of the eye are computed radially, solving a
second order ODE. The tensor product of the BSH QI is applied using its polar coordinates
form, when, during a ﬁnal step, we regularize the ﬁnal eye surface. Extended discussion,
details and numerical results can be found in [Andrisani et al., 2019].

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 25

6. CONCLUSIONS

The C++ library QIBSH++ for the approximate solution of several applicative problems pro-
vides the implementation of a Hermite type quasi-interpolant operator, with the possibility
to approximate the derivatives, with ﬁnite diﬀerence methods, when they are not avail-
able. A brief discussion on the theoretical convergence properties of the method is included,
together with some implementation details. Numerical tests show the convergence prop-
erties of the method, even when derivatives are not available and they are approximated.
Computational times and approximation errors make the BSH QI method competitive with
other well-known interpolations and quasi interpolation methods. Moreover, the use of the
Matlab C-MEX interfaces for some QIBSH++ procedures, leads to performance optimization
of the code TOM in terms of computational time. The use of the library is also suggested
in several applicative ﬁelds when high smoothness and high degree splines are required.

7. ACKNOWLEDGMENTS

The research of Antonella Falini
is founded by PON Project AIM 1852414 CUP
H95G18000120006 ATT1. The authors Antonella Falini and Francesca Mazzia thank the
Italian National Group for Scientiﬁc Computing (Gruppo Nazionale per il Calcolo Scien-
tiﬁco) for its valuable support under the INDAM-GNCS project CUP E55F22000270001.

REFERENCES

Andrisani, A., Mininni, R. M., Mazzia, F., Settanni, G., Iurino, A., Tangaro, S., Tateo, A., and Bellotti, R.
(2019). Applications of pdes inpainting to magnetic particle imaging and corneal topography. Opuscula
Mathematica, 39(4):453–482.

Brugnano, L. and Trigiante, D. (1998). Solving Diﬀerential Problems by Linear Multistep Initial and Bound-
ary Value Methods. Stability and Control Ser.: Theory, Methods and Applications. Gordon and Breach.

Burger, M., He, L., and Sch¨onlieb, C. (2009). Cahn-Hilliard inpainting and a generalization for grayvalue

images. SIAM Journal on Imaging Sciences, 2(4):pp. 1129–1167.

Burkowski, F. J. and Hoskins, W. (1973). Algorithm 461: cubic spline solutions to a class of functional

diﬀerential equations. Communications of the ACM, 16(10):635–637.

Cash, J. R., Hollevoet, D., Mazzia, F., and Nagy, A. (2013). Algorithm 927: the matlab code bvptwp.m
for the numerical solution of two point boundary value problems. ACM Transactions on Mathematical
Software (TOMS), 39(2):1–12.

Davydov, O. and Zeilfelder, F. (2005). TSFIT package. http://personal.strath.ac.uk/oleg.davydov/

tsfit/index.html.

de Boor, C. (1972). On calculating with B-splines. J. Approximation Theory, 6:pp. 50–62.

de Boor, C. (1976). Splines as Linear Combinations of B-splines: A Survey. MRC technical summary report:

Mathematics Research Center. Defense Technical Information Center.

de Boor, C. (2001). A practical guide to splines, volume 27 of Applied Mathematical Sciences. Springer-

Verlag, New York.

De Falco, C., Reali, A., and V´azquez, R. (2011). Geopdes: a research tool for isogeometric analysis of pdes.

Advances in Engineering Software, 42(12):1020–1034.

Dierckx, P. (1993). FITPACK package. http://www.netlib.org/dierckx/.

arXiv 26

E. Bertolazzi and A. Falini and F. Mazzia

Elber, G. (1990). IRIT. https://www.cs.technion.ac.il/ irit/.

Falini, A., Mazzia, F., and Sestini, A. (2022). Error estimates for spline BS Hermite Quasi-Interpolation. in

preparation.

Franke, R. (1982). Scattered data interpolation: Tests of some method. Mathematics of Computation,

38(157):pp. 181–200.

Grimstad, B. et al. (2015). SPLINTER: a library for multivariate function approximation with splines.

http://github.com/bgrimstad/splinter. Accessed: 2015-05-16.

Iurino, A. (2014). BS Hermite Quasi-Interpolation Methods for Curves and Surfaces. PhD thesis, Diparti-

mento di Matematica, Universit`a degli Studi di Bari.

Iurino, A. and Mazzia, F. (2013). The c library qibsh for hermite quasi interpolation of curves and surfaces.

Technical Report 11, Department of Mathematics, University of Bari ALDO MORO.

J¨uttler, B., Langer, U., Mantzaﬂaris, A., Moore, S. E., and Zulehner, W. (2014). Geometry+ simulation

modules: Implementing isogeometric analysis. PAMM, 14(1):961–962.

Kolda, T. G. and Bader, B. W. (2009). Tensor decompositions and applications. SIAM Review, 51(3):455–

500.

Mantzaﬂaris, A. (2019). An overview of geometry plus simulation modules. In International Conference on

Mathematical Aspects of Computer and Information Sciences, pages 453–456. Springer.

MATLAB (2012). version 7.14.0 (R2012a). The MathWorks Inc., Natick, Massachusetts.

Mazzia, F. (2022). Mesh selection strategies of the code tom for boundary value problems. Annali

dell’Universit`a di Ferrara. submitted.

Mazzia, F. and Cash, J. R.

for boundary value problem solvers.
AIP Conference Proceedings, 1648(1):020009. website:https://archimede.dm.uniba.it/~bvpsolvers/
testsetbvpsolvers/.

(2015). A fortran test

set

Mazzia, F. and Sestini, A. (2009a). The BS class of Hermite spline quasi-interpolants on nonuniform knot

distributions. Bit Numerical Mathematics, 49(3):pp. 611–628.

Mazzia, F. and Sestini, A. (2009b). The BS class of hermite spline quasi-interpolants on nonuniform knot

distributions. BIT, 49(3):611–628.

Mazzia, F. and Sestini, A. (2012). Quadrature formulas descending from BS Hermite spline quasi-

interpolation. Journal of Computational and Applied Mathematics, 236(16):4105–4118.

Mazzia, F., Sestini, A., and Trigiante, D. (2006a). B-spline linear multistep methods and their continuous

extensions. SIAM J. Numer. Anal., 44(5):1954–1973 (electronic).

Mazzia, F., Sestini, A., and Trigiante, D. (2006b). BS linear multistep methods and their continuous exten-

sions. SIAM Journal on Numerical Analysis, 44(5):1954–1973.

Mazzia, F., Sestini, A., and Trigiante, D. (2006c). BS linear multistep methods on non-uniform meshes.

JNAIAM J. Numer. Anal. Indust. Appl. Math, 1(1):131–144.

Mazzia, F., Sestini, A., and Trigiante, D. (2009a). The continuous extension of the B-spline linear multistep

methods for BVPs on non-uniform meshes. Applied Numerical Mathematics, 59(3-4):723–738.

Mazzia, F., Sestini, A., and Trigiante, D. (2009b). The continuous extension of the B-spline linear multistep

methods for BVPs on non-uniform meshes. Applied Numerical Mathematics, 59(3-4):723–738.

Mazzia, F. and Settanni, G. (2021). Bvps codes for solving optimal control problems. Mathematics, 9(20).

Mazzia, F. and Trigiante, D. (2004). A hybrid mesh selection strategy based on conditioning for boundary

value ODE problems. Numer. Algorithms, 36(2):169–187.

Pew, J., Li, Z., and Muir, P. (2016). Algorithm 962: Bacoli: B-spline adaptive collocation software for pdes
with interpolation-based spatial error control. ACM Transactions on Mathematical Software (TOMS),
42(3):1–17.

The Object Oriented C++ library QIBSH++ for Hermite spline Quasi Interpolation

arXiv 27

Renka, R. and Brown, R. (1999). Algorithm 792: accuracy test of ACM algorithms for interpolation of
scattered data in the plane. ACM Transactions on Mathematical Software (TOMS), 25(1):78–94.

Renka, R. J. (1993). Algorithm 716: Tspack: Tension spline curve-ﬁtting package. ACM Transactions on

Mathematical Software (TOMS), 19(1):81–94.

Renka, R. J. (2009). Algorithm 893: Tspack: tension spline package for curve design and data ﬁtting. ACM

Transactions on Mathematical Software (TOMS), 36(1):1–8.

Sablonni`ere, P. (2005). Univariate spline quasi-interpolants and applications to numerical analysis. Rend.

Semin. Mat. Univ. Politec. Torino, 63(3):211–222.

Sch¨onlieb, C. (2011). Higher-order total variation inpainting. http://it.mathworks.com/matlabcentral/

fileexchange/34356-higher-order-total-variation-inpainting.

Sch¨onlieb, C. and Bertozzi, A. (2011). Unconditionally stable schemes for higher order inpainting. Commu-

nications in Mathematical Sciences, 9(2):pp. 413–457.

Schumaker, L. (2018). SPLINEPAK. https://archive.siam.org/books/ot142/.

Schumaker, L. L. (2007). Spline functions: basic theory. Cambridge Mathematical Library. Cambridge Uni-

versity Press, Cambridge, third edition.

V´azquez, R. (2016). A new design for the implementation of isogeometric analysis in octave and matlab:

Geopdes 3.0. Computers & Mathematics with Applications, 72(3):523–554.

Walker, P., Krohn, U., and Carty, D. (2019). Arbtools: A tricubic spline interpolator for three-dimensional

scalar or vector ﬁelds. Journal of open research software., 7(1):12.

