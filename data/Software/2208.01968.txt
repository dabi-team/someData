2
2
0
2

g
u
A
3

]

R
C
.
s
c
[

1
v
8
6
9
1
0
.
8
0
2
2
:
v
i
X
r
a

Our fingerprints don’t fade from the Apps we touch:
Fingerprinting the Android WebView

Abhishek Tiwari∗
abhishek.tiwari@uni-passau.de
Faculty of Computer Science and Mathematics,
University of Passau, Germany

Alimerdan Rahimov
rahimo01@ads.uni-passau.de
Faculty of Computer Science and Mathematics,
University of Passau, Germany

Jyoti Prakash∗
jyoti.prakash@uni-passau.de
Faculty of Computer Science and Mathematics,
University of Passau, Germany

Christian Hammer
christian.hammer@uni-passau.de
Faculty of Computer Science and Mathematics,
University of Passau, Germany

ABSTRACT
Numerous studies demonstrated that browser fingerprinting is detri-
mental to users’ security and privacy. However, little is known
about the effects of browser fingerprinting on Android hybrid apps
– where a stripped-down Chromium browser is integrated into
an app. These apps expand the attack surface by employing two-
way communication between native apps and the web. This paper
studies the impact of browser fingerprinting on these embedded
browsers. To this end, we instrument the Android framework to
record and extract information leveraged for fingerprinting. We
study over 20,000 apps, including the most popular apps from the
Google play store. We exemplify security flaws and severe informa-
tion leaks in popular apps like Instagram. Our study reveals that
fingerprints in hybrid apps potentially contain account-specific
and device-specific information that identifies users across mul-
tiple devices uniquely. Besides, our results show that the hybrid
app browser does not always adhere to standard browser-specific
privacy policies.

ACM Reference Format:
Abhishek Tiwari, Jyoti Prakash, Alimerdan Rahimov, and Christian Hammer.
2022. Our fingerprints don’t fade from the Apps we touch: Fingerprinting the
Android WebView. In Proceedings of ACM Conference (Conference’17). ACM,
New York, NY, USA, 11 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION
Browser fingerprinting is an effective method to identify individuals
based on information accessible through browser settings without
storing information locally, e.g., in cookies. Web pages capture
information about the user and the environment, such as the time-
zone, locale, and other distinguishable information. Several websites
leverage browser fingerprinting to detect botnets and other harmful

∗Joint First Author

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
Conference’17, July 2017, Washington, DC, USA
© 2022 Association for Computing Machinery.
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn

activity, such as an account accessed from a different place or device
than usual. On the flip side, online entities exploit fingerprinting
to develop targeted advertisements, price inflation for identified
individuals, and targeted malware for particular browser/operating
system versions.

Multiple studies [7, 9–12, 15, 20, 24, 25] acknowledged the pri-
vacy and security implication of this topic in the last decade. The
majority of these studies targeted desktop browsers, however, re-
cent years have seen a technological shift towards mobile devices
rather than desktop PCs for internet browsing. A recent study [22]
explored fingerprinting on mobile browsers and demonstrated fin-
gerprinting to be quite effective on mobile browsers. However, to
the best of our knowledge, there are no studies to understand the
impact of fingerprinting on hybrid apps.

Hybrid mobile apps integrate native and web components into a
single mobile application. Hybrid apps, on the surface, are native ap-
plications combined with web technologies such as JavaScript. Hy-
brid apps offer advantages to developers as they facilitate reusability
across multiple platforms: Existing web apps, e.g., login pages, may
effortlessly be integrated into multiple mobile platforms (e.g., iOS
and Android) to save time and development costs. In this work,
we explore the implications of browser fingerprinting on Android
hybrid apps. Android framework provides the WebView [4] class
to integrate hybrid apps. WebView embeds web applications into a
view of the Android app and displays webpages in a Chromeless
browser [13].

WebView also provides an active communication channel be-
tween the native Android app component and JavaScript in the
browser. JavaScript can access the Android app’s functionality
through shared objects. This grants web components strong ca-
pabilities of accessing native Android APIs without having to ask
for the Android permissions individually. In contrast to Android’s
permission system, where users can authorize permissions just once
(perhaps in a completely different context), on the web, users must
approve sensitive access (e.g., location access) or grant it for one day.
However, a hybrid app’s inbuilt browser inherits this permission (if
the shared Android component has this permission) without further
user interference. There have been multiple studies [19, 21, 23, 28]
to understand the security and privacy implications of Hybrid apps
in Android. These studies demonstrated multiple scenarios where
hybrid apps are insecure with respect to users’ security and privacy.

 
 
 
 
 
 
Conference’17, July 2017, Washington, DC, USA

Abhishek Tiwari, Jyoti Prakash, Alimerdan Rahimov, and Christian Hammer

Many hybrid apps use insecured protocols and send private infor-
mation to third-parties. Unfortunately, the impact of fingerprinting
the hybrid app’s inbuilt browser is still unknown.

In this work, we bridge the gap in understanding the impact
of hybrid apps’ browser fingerprinting. We perform a large-scale
study of fingerprints generated by hybrid Android apps. In par-
ticular, we are interested in information leakage, user tracking,
and security implications arising from the bridge communication
capabilities of hybrid apps. The bridge communication provides
(potentially untrusted) web components of hybrid apps access to
the trusted native app’s data and functionality. In this work, we
explore how the web counterparts of a hybrid app exploit these
capabilities to expose information via fingerprinting. Besides, we
identify the differences in fingerprinting between the stand-alone
and the browser in hybrid apps. To this end, we study over 20,000
apps, including the most popular apps from the Google play store.
To obtain the fingerprint of the hybrid app’s browser, we employ
dynamic instrumentation of WebView using the Frida instrumen-
tation framework [5]. Frida provides a dynamic instrumentation
toolkit to inject code into the Android Framework programmati-
cally. In particular, Frida supports overloading of existing methods
of the Android Framework. We develop a tool, WVProfiler , based
on Frida to identify and collect the browser fingerprints. WVPro-
filer instruments the Android framework to overload the loadUrl,
postUrl methods of the WebView class, and the onLoadResource
method of WebViewClient. In particular, the instrumentation is tar-
geted to collect three key pieces of information; User Agent String,
custom headers, and URLs. URLs help identify the unencrypted
traffic originating from loadUrl. Custom headers and the User Agent
String help identify privacy leaks and unique identifiers associated
with the web request. Finally, we exemplify the security flaws and
information leaks on popular apps like Instagram. In summary, our
study reveals that some apps’ fingerprints contain account-specific
and device-specific information that can be used to identify and link
their users over multiple devices uniquely. Besides, our results show
that the hybrid app browser does not always adhere to standard
browser-specific privacy policies.

To summarize, this study contributes the following:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

21
22
23
24
25
26

27
28
29
30
31
32
33
34
35
36
37
38
39

// Android side : exposing functionality to JavaScript
public class BridgedClass {

public String name ;

@JavascriptInterface

public void setValue ( String x) {

this . name = x;

}

public String getValue () {

return this . name ;

}

}
// Activity implementing WebView
@Override
protected void onCreate ( Bundle savedInstanceState ) {
// some

code

WebView wv = ( WebView ) findViewById (R. id . webview );
WebSettings webSettings =

wv . getSettings () . setUserAgentString (" My User
agent ");

webSettings . setJavaScriptEnabled ( true );
BridgedClass bClass = new BridgedClass () ;

// share the bridge object to JavaScript

wv . addJavascriptInterface ( bClass , " sharedJavaObject ") ;

// JavaScript invoking Android via the shared object

wv . loadUrl (" javascript :" +

" sharedJavaObject . setValue (\" Hello World \") " );

// Invoking JavaScript methods

wv . loadUrl (" javascript : set () ");

// Loading a url

wv . loadUrl (" http :// www . dummy . com ");

// JavaScript side
set () {

x = new Object () ;
const str = new String () ;
x.f = str . concat ( "x " , "y");
v = x.f;
sharedJavaObject . setValue (v)

}

Listing 1: Android Hybrid app communication

• A Large-scale analysis of Hybrid app’s browser fingerprint-
ing We perform a large-scale analysis of the Hybrid app’s
browser fingerprinting. Our analysis helps to understand the
privacy and security implications of fingerprinting on An-
droid hybrid apps. We explore that the hybrid app browser
does not adhere to standard browser-specific privacy policies
due to customization inability. Besides, many popular apps’
fingerprints contain account-specific and device-specific in-
formation that can be used to identify their users over mul-
tiple devices uniquely.

• WVProfiler We develop a tool, WVProfiler , based on
Frida to identify and collect the browser fingerprints. We
make our tool public [6] for the researchers to reuse and
build upon it.

• Dataset We open-source all the datasets [6] used in our study
to help the researchers and developers to reproduce and un-
derstand the implication of fingerprinting on hybrid Android
apps.

2 MOTIVATION AND BACKGROUND
Before delving into the details of our core framework and the im-
plications of browser fingerprinting in Android hybrid apps, we
provide a brief background of the techniques utilized in our study.

2.1 Hybrid Apps
Android hybrid applications embody native Android parts along
with web components. These apps enable developers to reuse their
existing web applications in their Android apps. To enable hybrid
apps, Android provides a set of APIs to facilitate the communication
among Android native app components (primarily written in Java
or Kotlin) and web components. These APIs are composed via the
Android WebView class, which allows the developer to display web
pages as a part of the app’s activity (e.g., login screen).

WebView provides two styles of communication channels be-
tween Android and the web. In the first type, an app can invoke
a webpage/script without sharing any Android functionality with
them. In the second, more interesting two-way communication

Our fingerprints don’t fade from the Apps we touch: Fingerprinting the Android WebView

Conference’17, July 2017, Washington, DC, USA

channel, an app actively communicates with a webpage/script by
sharing Android-side functionality to the WebView. The example in
Listing 1 contains both of these cases. Line 22 and Line 24 present
the code (using the addJavascriptInterface API) to share an Android
object to JavaScript. In our example, Line 3 to Line 12 describe a class
BridgeClass shared with JavaScript. By default, none of the meth-
ods in a class are exposed to JavaScript. The Android framework
provides the @JavascriptInterface annotation to specify the shared
methods of a bridge class. For example, BridgeClass does not share
the getValue method to JavaScript. Line 17 to Line 30 present an An-
droid activity code that creates a WebView. Line 19 and Line 20 pro-
vide a general configuration for creating a WebView. By default, the
execution of JavaScript is disabled in a WebView. Developers need
to manually enable JavaScript by utilizing setJavaScriptEnabled(true)
(e.g., Line 21). Once enabled, the JavaScript can be invoked using
the loadUrl method. Line 26 to Line 28 describe two ways to achieve
this. Finally, loadUrl can also be used to invoke normal URLs, e.g.,
Line 30.

WebView APIs. WebView provides the following APIs to fetch
URLs and execute JavaScript scripts.

• loadUrl(Url): It loads the specified Url in the WebView. load-
Url can also execute JavaScript code. JavaScript script strings
are prepended with javascript:.

• loadUrl(Url, HttpHeaders): It has the same functionality as
loadUrl with additional HTTP headers. Developers can spec-
ify the HTTP headers they want to bundle with the request.
• postUrl(Url, postData): It loads the specified network Url

using the POST method along with the post data.

• WebViewClient.onLoadResource(webView, Url) It notifies the
host application that WebView webView will load the speci-
fied Url.

WebView User Agent Settings. WebView provides an API to set
custom user-agent settings for the WebView browser. Developers
can override the user-agent settings, which can be intercepted by
the loaded URL. For example, Listing 1 sets the user agent settings
to “My User agent” (Line 20).

User-agent settings are useful for user’s security, as well as noto-
rious for breaking it. However, the user agent settings in WebView
are a bit different from those on browsers. Recently, desktop and
mobile browsers, such as Chrome, Mozilla, and others, allow users
to hide sensitive information to evade fingerprinting. However,
this provision is lacking in the case of WebView browsers. Here,
the control is directly in the hands of the developer. This makes
WebView browsers a lucrative option for fingerprinting since these
may inherit privacy-sensitive data with the shared native Android
app’s functionality. Our study shows that developers have leveraged
these features to collect users’ device fingerprints.

2.2 Browser Fingerprinting
Browser fingerprinting is a technique to profile users to uniquely
identify them based on passive information, known as a browser
fingerprint, obtained from the browser. Browser fingerprint uses
the information collected from browsers, such as HTTP headers
(such as User Agents and Accept), Flash plugins, JavaScript cookies,

and many others. Recent advances in the web, such as browser ex-
tensions, canvas elements, and WebGL components are also known
to be sources of fingerprints [7, 17]. We explain three approaches
here: (1) User Agents, (2) Accept and Content-Language, and (3)
browser extensions to aid the understanding of this paper for our
readers. Interested readers may refer to Laperdrix et al. [17] for a
detailed survey of browser fingerprinting.

The HTTP protocol is meant to be platform-independent, and
therefore, browsers rely on the information from HTTP headers
to identify the browser of an incoming request. The information
is encoded in the standard HTTP semantics (RFC 9110 [16]) called
as User-Agent request headers or User Agent strings. User-Agent
strings specify the system characteristics such as browser, operating
system, architecture, and many others, and are used by web servers
to identify the client information. As of now, User-Agent strings are
complex and add a plethora of information other than the browser.
Developers can override the existing user-agent headers and inject
information into these headers. For example, JavaScript facilitates
developers to modify these strings and add more information, such
as timezone, screen-specific attributes (such as resolution, depth),
platform, and many others. This information is a source of finger-
prints as shown by earlier works [10, 17].

Accept headers are used to specify the file types accepted
by the browsers is another source of fingerprintg [10, 17].
It is a comma-separated list of content types and their sub-
types. For example, a browser can set the accept headers
to text/html, application/xhtml+xml, which indicates the
browser can accept the type text of sub-type html. Content-
Language attribute specifies the localization information of the
browsers, such as de-DE, en-US, en-IN. Content-language is also
a source of localization information for fingerprinting [18].

Browser extensions are browser-based applications that enhance
the browsing experience. Although these improve browser experi-
ence, such as by reducing ads, they are also a source of fingerprint-
ing information. Starov and Nikiforakis [25] identified 14.10% of
users via fingerprints obtained from their browser extensions. They
used the changes in the DOM model introduced by the browsers to
detect extensions. A similar study from Sanchez-Rola et al. showed
the possibility of extension enumeration attack on browsers, thus
identifying 56.28% users from 204 users. To this end, they mea-
sure the timing difference between querying resources of fake and
benign extensions.

Large scale studies on browser fingerprinting. Browser finger-
prints can compromise users’ privacy. It was first demonstrated
in the experiment Panoptclick [10] by Peter Eckersley from the
Electronic Frontier Foundation, where he fetched around 470,000
fingerprints, of which around 84% were unique. His experiment
shows the gravity of the problem, i.e., browser fingerprints can
uniquely determine a majority subset of the users on the web. Fol-
lowing up on these experiments, researchers revealed many other
sources of browser fingerprinting generation techniques to profile
users and break their privacy. We list these techniques in the related
work of this paper.

The evolution of the Web from desktop to mobile browsers
has affected users’ privacy from browser fingerprinting. Earlier
research [22] shows that fingerprints from mobile browsers reveal

Conference’17, July 2017, Washington, DC, USA

Abhishek Tiwari, Jyoti Prakash, Alimerdan Rahimov, and Christian Hammer

1
2

3
4

5

6
7

8
9

var WebView = Java . use (" android . webkit . WebView ") ;
WebView . loadUrl . overload ( ' java . lang . String '). implementation

= function ( url ) {

this . loadUrl ( url );
const ActivityThread =

Java . use ( ' android . app . ActivityThread ');

var context = ActivityThread . currentApplication () .

getApplicationContext () ;

var packagename = context . getPackageName () ;
send ({ |

packageName : packagename ,
method : " loadUrl " ,
Url : url ,
Header : "" ,
userAgent : this . getSettings () . getUserAgentString ()

}) ;
console . log (" WebView . loadUrl url :" + url );

}
Listing 2: Instrumenting the WebView– Overloading the
loadUrl(Url)

Android dynamic instrumentation framework, Frida [5]. Frida pro-
vides a dynamic instrumentation toolkit to inject code into the
Android Framework programmatically. In particular, Frida supports
overloading the existing methods of the Android Framework. We
develop a tool, WVProfiler , based on Frida to identify and collect
the browser fingerprints. WVProfiler instruments the Android
framework to overload the loadUr, postUrl methods of the WebView
class, and onLoadResource of WebViewClient. In particular, the in-
strumentation is targeted to collect three key pieces of information;
User Agent String, custom headers, and URLs. URLs help to identify
the unencrypted traffic originated from loadUrl. Custom headers
and the User Agent String help to identify privacy leaks and unique
identifiers associated with the transmission. To navigate through
various Android activities, we leverage the Android automated
tester Monkey [14]. Monkey can produce pseudo-random streams
of user events such as mouse movements and gestures and generate
various system-level events to help in the automatic navigation of
the Android apps.

Listing 2 presents the pseudocode for instrumenting the loadUrl
method with a single parameter. Line 1 creates an object WebView
pointing to the Android Framework’s WebView class. In the next
line, the loadUrl method is overloaded to extract browser finger-
prints. In Line 6, the app’s unique identifier (package name) is
extracted to associate it with the fingerprints. Finally, custom head-
ers, the user-agent string, and URL are extracted and logged in
Line 7 and 8.

4 EVALUATION

Dataset. We conducted our study on over 20,000 apps from the
AndroZoo [8] dataset. AndroZoo contains a compilation of Android
apps from several sources, including the Google Play store. In our
study we are interested in hybrid apps, which contain at least one
instance of WebView. Thus, to filter for hybrid apps, we first decom-
piled the apps in the dataset and examined the decompiled code
for WebView-related method signatures. To further validate that
these apps are hybrid, we applied our instrumentation framework
to them and logged WebView-related method calls. We ended up

Figure 1: Workflow of WVProfiler

a lot more sensitive information than from desktop browsers. To
tackle the problem of fingerprinting, web browsers have started in-
troducing policies to minimize browser fingerprints. Unfortunately,
these policies do not apply to the hybrid app’s in-built browser,
leaving the control in the hands of the developers. We study this
aspect in this paper.

Uniqueness of a fingerprint. To compare the strength of the in-
formation revealed by the fingerprints obtained in our study, we
compare it against a larger dataset of the Cover your tracks. It shows
the bits of unique information revealed by the fingerprint, which
matches with the fingerprint obtained in our database. Cover your
tracks shows this information in terms of the number of browsers
having the same fingerprint. In this paper, we refer to it as unique-
ness.

3 METHODOLOGY
Unlike fingerprinting in traditional browsers, fingerprinting hybrid
apps has inherent technical challenges. With traditional browsers,
it is feasible to attach scripts/plugins to a web page and rely on
cookies to gather information, which is, unfortunately, not possible
with hybrid apps. The hybrid app browser is provided as a part of
the Android Framework, and it displays web pages as a part of the
app’s activity. In this work, we perform runtime instrumentation of
the WebView class to intercept the fingerprinting data. Generally,
network analysis tools such as Wireshark could also obtain parts of
the required data. However, for a large scale analysis, instrumenting
the WebView class gives us more control over the data we collect,
e.g., Wireshark does not associate the apps’ identifier to the net-
work traffic containing fingerprinting data. Besides, instrumenting
WebView enables us to capture the direct traffic from the particular
app, while Wireshark captures all traffic, including noise from other
apps and Android Framework.

Figure 1 provides an overview of our instrumentation frame-
work. There are two potential ways to instrument WebView. First,
modifying the Android framework by integrating the required code
changes directly into the Android Open Source project, and then
running the apps on this custom Android OS. Second, achieving the
desired modifications with the help of dynamic instrumentation.
In this work, we opt for the latter path; we leverage an existing

Instrument.jspostURLloadUrlWebViewWebViewClientonLoadResourceFrida-InstrumentationInjectFrida ServerEmulatorTarget AppAndroid FrameworkOverload WebViewFingerPrintsMonkey TesterOur fingerprints don’t fade from the Apps we touch: Fingerprinting the Android WebView

Conference’17, July 2017, Washington, DC, USA

between the stand-alone and the hybrid apps’ browser. In summary,
we find that hybrid apps reveal more information about the user
than traditional browsers. We exemplify the research findings in
the form of the following case studies:

Case Study 1: Privacy leakage unique to hybrid apps’
browser. Fingerprints in WebView are a good source of (poten-
tially) privacy-sensitive information. For example, the hybrid app
browser’s fingerprint contains sensitive information such as the
phone model and build number. The latter is sensitive informa-
tion that can be leveraged to determine vulnerable devices and
craft operating-system-specific attacks as observed by security an-
alysts [2] and acknowledged by Google [3]. The desktop Chrome
browser removed the build number in 2018 whereas the hybrid
apps’ browser includes this information in the user agent string up
to this date.

To further improve user privacy, Chrome contains a privacy
sandbox since version 93 (released on August 31, 2021). It allows the
user to manually limit1 leaking of sensitive information to protect
against passive fingerprinting. However, no such configuration can
be activated in hybrid apps’ in-built browser. Table 2 shows the
uniqueness of the fingerprints obtained on hybrid apps’ in-built
browser, the standalone Chrome browser, and the Chrome browser
with sandboxing. The uniqueness brought by the privacy sandbox
is 259 times lower than the unmasked fingerprint: The higher the
uniqueness number, the worse it is for users’ privacy.

To obtain the uniqueness of a browser fingerprint, we leverage
Cover Your TRACKS [1], a research project to understand the unique-
ness of browser fingerprints. It provides a uniqueness score to a
fingerprint based on a large fingerprint database. We observed
that fingerprints including the build number are highly unique;
the uniqueness decreases significantly when removing the build
number, and again drastically when limiting the phone model in-
formation.

Finding 1: Hybrid apps’ built-in browser permits more sensitive
information leakage than the stand-alone browser. All hybrid apps
in our dataset expose the build number and phone model in their fin-
gerprints. This permissiveness stems from the inability to configure
system-wide privacy policies.

Case study 2: Information leak by Instagram app. Like tra-
ditional browsers, Android allows WebView to transmit a user-
agent HTTP header to the server, which can derive information
from it. It is the app developers’ responsibility to control the infor-
mation they want to share with the server. As is, the web compo-
nents (WebView) of hybrid apps indirectly inherit the same level of
permissions as the shared components of the native side of the apps.
Thus, by using the shared APIs, they potentially have access to sen-
sitive device/user-specific information. During our manual analysis
of the most popular apps from the Google play store, we observed
an interesting mechanism to profile users based on the HTTP head-
ers in the well-known social media app Instagram. Instagram’s
Android app leverages WebView to open an in-app URL/link, i.e., a
link shared in a chat. We crafted a scenario where a curious (or ma-
licious) user, Bob, wants to get some personal information such as

1Via chrome://flags/#reduce-user-agent

Figure 2: Apps by Categories

with 5,145 apps that use at least one instance of WebView’s APIs.
We were also interested in the app store categories of these apps,
so we created a script that automatically determines the category
of an app in the Google play store based on its package name. This
categorization was successful for approximately 1000 apps, the
remaining apps are not/no longer listed in the Google play store,
which precludes automated classification. Thus, the pie chart in
Figure 2 provides the distribution of categories for the more than
1000 apps (still) available in the Google play store only.

On top of this dataset, we selected the ten popular apps from
the Google Play store (as of April 2022) for automatic as well as
manual analysis. In particular, we created multiple (fake) accounts
and observed http headers like cookies, user-agent strings, and
URLs for these accounts. The manual analysis aims to determine
information that can help identify a user uniquely over multiple
devices or platforms. Table 1 lists these ten apps, along with the
sensitive information they expose in their user agent, cookies, and
custom headers.

All of these applications were subsequently instrumented as de-
scribed in Section 3 to collect the user agent strings, custom headers,
and URLs. We further created scripts to automate the data collection
process: All of our scripts are publicly available to researchers for
replication purposes. Our experiments were performed on a per-
sonal laptop with 16 GB RAM and a fourth-gen Intel Core i7-4500U
processor running Windows 10.

Case Studies. Multiple studies have been proposed for browser
fingerprinting [10, 12, 17, 22] and Android hybrid app analy-
sis [19, 21, 23, 28]. The most relevant recent work [22] performed
a preliminary investigation on fingerprinting of mobile browsers.
However, their work focused on full-fledged mobile browsers. In
contrast, we aim to perform a large-scale study of fingerprints gen-
erated by hybrid Android apps. In particular, we are interested in
information leakage, user tracking, and security implications aris-
ing from the bridge communication capabilities of hybrid apps. The
bridge communication provides access from (potentially untrusted
web components of a hybrid app to the trusted native app’s data
and functionality. In this work, we explore how the web component
of a hybrid app exploits these capabilities to expose information via
fingerprinting. Besides, we identify the differences in fingerprinting

Social2,3%Productivity2,2%Puzzle2,4%Health & Fitness3,7%Entertainment5,7%Maps & Navigation2,2%Finance3,5%Personalization3,0%Lifestyle6,5%Photography2,6%Sports3,9%Education9,5%Travel & Local3,9%Shopping3,2%Music & Audio4,5%Business7,7%Tools4,6%News & Magazines6,0%Word1,0%Books & Reference6,5%Conference’17, July 2017, Washington, DC, USA

Abhishek Tiwari, Jyoti Prakash, Alimerdan Rahimov, and Christian Hammer

Table 1: Manually Analyzed Apps

App Name

Version

Category

Cookie User agent

Custom headers

Instagram

229.0.0.17.118

Social

Facebook
Alibaba
Twitter
LinkedIn
UBer

359.0.0.30.118
7.48.1
9.31.1
4.1.629.1
4.361.10001

QuuBe - Wholesale

6.5.1

flipboard
Youtube
DW Learn German

4.2.97
17.08.32
1.0.1

Social
Shopping
Social
Social
Cab

Shopping

Shopping
Video Players & Editors
Education

no

no
yes
no
no
no

yes

no
no
no

Phone model, build number,
localization info, SDK,
Android version, processor
Phone model, build number
Phone model, build number
Phone model, build number
Phone model, build number
Phone model, build number
Phone model, build number,
UUID in the user agent
Phone model, build number
Phone model, build number
Phone model, build number

no

no
unique ID
no
no
no

UUID

no
no
no

Table 2: Fingerprints from Various Browsers

Platform
Hybrid apps’ Browser

Chrome Browser

Fingerprint
{Mozilla/5.0 (Linux; Android 9; SM-A505FN Build/PPR1.180610.011;
like Gecko) Version/4.0
(KHTML,
wv) AppleWebKit/537.36
Chrome/99.0.4844.88 Mobile Safari/537.36}
{Mozilla/5.0 (Linux; Android 9; SM-A505FN) AppleWebKit/537.36
(KHTML, like Gecko) Chrome/98.0.4758.87 Mobile Safari/537.36}

Uniqueness (1/X)
X= 218256

X = 218112

Chrome Browser with sandboxing {Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like

X=838.98

Gecko) Chrome/93.0.0.0 Mobile Safari/537.36}

the phone model, language, or ethnicity of a user Alice. Bob owns a
server that can create account-specific links (e.g., server.com/Alice)
and sends this link to Alice, and once Alice clicks on this link,
it is displayed in the built-in WebView browser. Figure 3 shows
the fingerprint and the sensitive information shared with Bob’s
server; Bob is able to obtain Alice’s personal information, such as
phone model and language preferences. In particular, this attack is
plausible in any app that uses WebView to open in-app URLs.

As discussed in case study 1, the Instagram app, by default,
sends the phone’s model and build number, already providing more
uniquely identifiable information than the stand-alone Chrome
browser. On top of that, it also reveals the Android version (both
OS and SDK), phone resolution, processor name, and localization
information. Localization information is very sensitive for profiling
users. We observed that the uniqueness of this information is very
high (217923), which is detrimental to users’ privacy.

This fine-grained information in the user-agent header renders
the app vulnerable to passive fingerprinting, where an attacker
can infer these user-agent headers by simply observing the traffic
coming from a malicious URL shared through the chat. To miti-
gate the problem of passive fingerprinting, RFC9110 [16, ch. 10.1.5]
disallows “generate advertising or other nonessential information
within the product identifier”. Instagram adds personally identi-
fiable information to the contrary. In contrast to the stand-alone
browser where the user can choose to hide this information, the
user has no control over which information is shared once certain
permissions are given to the Instagram app.

Finding 2: Hybrid apps are susceptible to passive fingerprinting
and often violate standard privacy policies. Famous apps like In-
stagram provide less to no control to their users over the amount of
sensitive information released via web components.

Case study 3: Profiling Users via a combination of cookies
In the previous case studies, we demonstrated
and user-agent.
how users could be profiled based on user-agent strings. The sit-
uation becomes more severe when this information is combined
with other mediums such as cookies; the combined information
helps obtain a fine-grained profile of the user. For example, in the
Alibaba app, the user’s account ID (unique over multiple devices)
is added to the cookies; thus, one can intercept the user ID and the
phone model information obtained from the user-agent string to
profile users’ phone buying behavior. Note that the user’s account
ID stays the same over various devices/browsers, i.e., users can be
uniquely identified over different service providers. Besides, the
server can concretely infer sensitive information on the user, e.g.,
how many devices a user owns, how frequently users change their
phone, and what the financial situation of a user is.

User profiling is also possible through HTTP ACCEPT-language
headers. ACCEPT-language headers are used to determine the lan-
guage preferences of the client. Generally, these headers are derived
from the language preference of the user. For example, a user lo-
cated in Switzerland and speaking German would have the accept
language CH-de. Unfortunately, a user can be profiled based on

Our fingerprints don’t fade from the Apps we touch: Fingerprinting the Android WebView

Conference’17, July 2017, Washington, DC, USA

Mozilla/5.0 (Linux; Android 9; SM-A505FN Build/PPR1.180610.011; wv) AppleWebKit/537.36(KHTML, like Gecko)
Version/4.0 Chrome/99.0.4844.88 Mobile Safari/537.36 Instagram 229.0.0.17.118
Android (28/9; 420dpi; 1080x2131; samsung; SM-A505FN; a50; exynos9610;en_DE; 360889116)

Instagram Version (Instagram 229.0.0.17.118, 360889116), Platform (Android)
Android SDK (28) and version (9), Phone model (samsung; SM-A505FN;),
DPI and Resolution (420dpi; 1080x2131), Locale (en_DE)

Proccessor name (exynos9610)

(a) Fingerprints

(b) Identifying Information

Figure 3: Fingerprint from Instagram

her language preferences, e.g., identifying the user’s origin, eth-
nicity, or nationality. Worse, if the user speaks more languages,
with the combination of other fingerprintable information, the user
can be uniquely identified. For example, a user speaking a com-
bination of Russian and Turkmen languages could be profiled as
Turkmenistan origin. However, users can hide this information on
regular browsers through their settings or, better, use a privacy-
compliant browser. Unfortunately, this is not possible for the hybrid
browser as users cannot control the settings of this browser.

Furthermore, we observed that various applications attach
unique device IDs to the user-agent string, resulting in the direct
identification of a user. To observe this behavior, we logged into
the apps with multiple user accounts and observed the differences
in the fingerprints. This manual analysis confirms this miscon-
duct [16, ch. 10.1.5] in at least ten apps in our dataset. Table 3
presents the list of these apps alongside their categories. Apps
with a similar name, e.g., Qoo10 Indonesia and Qoo10 APK 3.2.7,
are from the same manufacturer but belong to different countries
and have different privacy policies. Owing to the sheer volume of
the dataset, it was not feasible to create multiple accounts for all
the apps and relate fingerprints for this unique information. Ta-
ble 4 shows a sample of the fingerprints obtained from the devices
containing unique device IDs. As is, the unique IDs are attached
to the devices; they remain unchanged after even reinstalling the
apps. Along with the unique device ID, these devices contain fine-
grained information about the device attributes, such as build num-
ber, phone model, and Android version. Thus, one can directly
relate a device to its attributes, and also build a temporal profile
of the particular device, in case the device is used by another user.
Finding 3: The combination of cookies and user agents links
sensitive device and user-specific information. This information can
be exploited to profile a user uniquely, such as identifying the origin
and estimating the personal financial status. Besides, a few apps
in our dataset attach their users’ account IDs (unique for a user)
to the cookies making their users uniquely identified over different
devices.

Case Study 4: JavaScript modifying Android objects. As a
part of our instrumentation framework, we instrument the loadUrl
method to extract the originating URLs. On top of loading URLs
loadUrl also provides functionality to load/execute a JavaScript
code snippet directly. We also intercepted many cases where

JavaScript : if ( window . Application )
{

Application . setDeviceUid ("" APA91bG956w4WPzLIh
DCHdcnIdbigwApzJzX - WFCkrKRcpJMr9Xw0kbAAxjBYj -
f6UnVrfeMWRhuPlQIiv8np8733GgHzHm6QHLMeK1
- InIkhWvxq9yjGb_i2a5WdxIQmaAl - QP3aHHIqK9XTGJiiPpJo
_dXqkVNzQ "");

}

Listing 3: Setting device IDs through JavaScript

JavaScript modifies Java objects using bridge objects. A recent
study [28] exposed instances of potentially untrusted JavaScript
code interfering with Android objects. However, in several cases,
the aim of such interference was unknown in that study. In this
work, we identify a number of patterns where JavaScript trans-
mits unique IDs to native Android objects. These unique IDs
can be used as fingerprints for devices. For example, an app
com.a2stacks.apps.app57191abb7ab09 sets the user ID of the user as
shown in listing 3, violating multiple security policies. First, the (po-
tentially) unsafe web component violates the integrity of the native
app by modifying its object, i.e., writing the device UID into a field.
Second, the app may violate the Android privacy policies by assign-
ing a unique device identifier without having asked for permissions.
Finding 4:
(Potentially) Unsafe web components infringe the
integrity of a native app’s object. Hybrid app web components
(JavaScript) assign unique identifiers to the device for (potential)
fingerprinting purposes via the Android bridge communication.

Case Study 5: Unencrypted communication. During our
analysis of extracted URLs, we find various instances where unen-
crypted protocols such as HTTP are used to communicate secret
information such as device IDs, IP addresses, Google ads user iden-
tifiers, and many other sensitive data. This is a severe problem, and
unfortunately, 1646 applications from our dataset contain this flaw.
Related work [28] has shown that the use of unencrypted communi-
cation is susceptible to simple man-in-middle attacks: An attacker
can alter the server’s response to an attacker-controlled web page
without the user noticing any difference. Besides, the attacker learns
the user’s sensitive information by just observing the traffic; 281
apps share Google ads IDs, and 132 out of them also add IP ad-
dresses to the URLs. Interestingly, 214 of these 281 apps use URLs
from the domain http://splash.appsgeyser.com domain, 28 from
http://splash.appioapp.com, and 39 from http://ads.appioapp.com.

Conference’17, July 2017, Washington, DC, USA

Abhishek Tiwari, Jyoti Prakash, Alimerdan Rahimov, and Christian Hammer

Table 3: Apps including unique IDs into user-agent string

Package Name
com.oddm.adpick
net.giosis.shopping.id
net.giosis.shopping.cn.nonepush
Net.giosis.shopping.sg
xyz.quube.mobile
xyz.quube.shopping.tablet
mobile.qoo10.qpostpro
mobile.qoo10.qstl20
com.alibaba.intl.android.apps.poseidon Alibaba
Com.accelainc.ihou.fr.droid

App Name
Adpick
Qoo10 Indonesia
Qoo10 APK 3.2.7
Qoo10 - Online Shopping 6.5.1
QuuBe - Wholesale by Qoo10
QuuBe for Tablet
Qpost Pro 1.4.1
Style Club 6.4.0

Illegal Romance 1.0.2

Category
Office
Shopping
Shopping
Shopping
Shopping
Shopping
Shopping
Shopping
Shopping
Adventure

Table 4: Fingerprint showing unique ID

App
com.oddm.adpick

Category
Office

Fingerprint

Mozilla/5.0 (Linux; Android 10; Android SDK built for x86 Build/QSR1.210802.001;

wv)AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 Chrome/74.0.3729.185

Mobile Safari/537.36 AdpickEncrypted:GDPViCyiXnbcQgWnvAmIBusjAV43FvgPeawc

/Xc5ayQW0rBy/oA8BUz4Vdmy9ITgwRQDnaI7BmZB#nXG5+MzNecK3 HyqXv7P5/2u9yqMmkwrA/leTfsNeUZbmjvzj9D9m

ECLyuBwl3lA8Sz 2dt4Ue1H1tT#n4mWgFssSh2n/eR1qpgnGRhc1cB2jqXtWuTW/cNQC#n

net.giosis.shopping.id

Shopping

Mozilla/5.0 (Linux; Android 11; Android SDK built for x86 Build/RSR1.210210.001.A1;

wv)AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 Chrome/83.0.4103.106 Mobile

Safari/537.36 Android_Gmarket Qoo10 ID_3.6.2_133(GMKTV2_ZlRnG1XAIzgwoC3OBe0hNjV4PfmyaC5RAIBqY+

mkcipUGsSIiB19AyfIHQY1msEafG/xGz9RIS4=;Android SDK built for x86;11;en_US;2000010476)

net.giosis.shopping. cn.nonepush

Shopping

Mozilla/5.0 (Linux; Android 10; Android SDK built for x86 Build/QSR1.210802.001;

wv)AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 Chrome/74.0.3729.185 Mobile Safari/537.36

Android_Gmarket Qoo10 CN NOPUSH_3.6.6_137(GMKTV2_/E/eowDAPJdLOH3or4b6kUZaqiQ9445kf5

0bcLzkkQeoFvJmnsEzdFnnyGmoyagfCYHYKlwCWP4=;Android SDK built for x86;10;en_US;2000000134)

net.giosis.shopping.sg

Shopping

Mozilla/5.0 (Linux; Android 10; Android SDK built for x86 Build/QSR1.210802.001;

com.accelainc.ihou.fr. droid

Adventure

2NSsaFdT 60D1F74326F469CB__5DC12396C15AB57696B4A 69152169D 1.0.1 & Mozilla/5.0 (Linux; Android

10; Android SDK built for x86 Build/QSR1.210802.001; wv)AppleWebKit/537.36 (KHTML, like

Gecko)Version/4.0 Chrome/74.0.3729.185 Mobile Safari/537.36

wv)AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 Chrome/74.0.3729.185 Mobile Safari/537.36

Android_Gmarket Qoo10 SG_6.5.1_269(GMKTV2_yQ+4mthiJO62KzrgMNh9rwIUgQVt5Aax6jISAX Y3h++KFBJ4DO5

/YZdeiP3jYmD+hnf246qDDdk=;Android SDK built for x86;10;en_US;200007873;US;)

Note that, all of these URLs belong to platforms (AppsGeyser and
Appio) for creating Android apps and the use of unencrypted com-
munication is susceptible to many other apps (not in our dataset).
Table 5 shows a list of twenty apps that load at least one instance
of an unencrypted URL. Figure 4 provides the distribution of apps2
using unencrypted URLs based on categories.
Finding 5: 32% of the apps in our dataset leak sensitive information
via unencrypted communication protocols like HTTP. These URLs
contain sensitive data such as device IDs, IP addresses, ad identifiers,
locale information, and other sensitive data.

5 LIMITATIONS
WVProfiler is a dynamic instrumentation tool and relies on the
instrumentation framework Frida to instrument the Android Frame-
work and record the fingerprinting data. It inherits all the limita-
tions of Frida, e.g., it is known to crash for the older version of
Android apps 3. Besides, to navigate through various app activities,
i.e., for coverage, WVProfiler relies on the automated Android
tester Monkey [14], and its coverage is limited to the activities vis-
ited by Monkey. Thus, WVProfiler misses the WebView-related
Android components that Monkey does not explore.

6 THREATS TO VALIDITY
In this section, we discuss the threats to internal and external va-
lidity of our experiment.

2Over 200 apps that we could categorize.

3https://frida.re/docs/android/

Our fingerprints don’t fade from the Apps we touch: Fingerprinting the Android WebView

Conference’17, July 2017, Washington, DC, USA

Table 5: Twenty Apps with Unencrypted URLs

App Name
Welcome to Purnia
PBALogistics APK
KPU Kab Kepulauan Selayar
Smile APK 1.1

Package Name
com.wWelcometoPurnia
com.wPBALogistics
com.wKPUKabKepulauanSelayar
com.wsmile2
com.wAnEssayonManmoralessaysandsatires An Essay on Man APK
com.cultplaces
com.wTrendyBotswana
com.wProfDrMustafaKaratasSoruCevap
com.wTanksDecades
com.wRapKlayBBJ
com.wCaringForYourCat4
com.wMayankCreation
com.wSwiftSpaceship
com.wTamilNaduSSLCResult2016
com.seuksa.khmeredu
com.wFashionCentral
com.wiOfferchinawholesale
com.wRichMamaDating
com.wDigitalindia
com.wFitterBooks

Cult Places
Trendy Botswana
Mustafa Karataş ile Soru Cevap
Tanks Decades
Rap Klay BB.J
Caring For Your Cat 1.0
Mayank Creation 0.1
Swift Spaceship
Tamil Nadu SSLC Result 2016 0.9
Seuksa 0.2
Fashion Central 0.1
iOffer china wholesale 0.1
Rich Mama Dating 3.4
Digital india 2.1
Fitter Books 4.1

Category
Hash
Lifestyle
004BDEAF41
Office
0094D388AB
Communication
005F8F4E97
Communication
00F784BF5B
Books & Reference
0183B4DF5C
Travel & Local
0665508043
News & Magazines
067999FD77
Lifestyle
06F06AFCB9
06F781FF93
Arcade Games
0711A4A1AE Music & Audio
03BA1A25F1
03EB88AF
047AE609BB
04DB332396
05A0858F83
05EA49ADAA Lifestyle
Shopping
0603403D90
Social
0ECBD904
Productivity
091E97F669
Education
09E527B22F

Books & Reference
Lifestyle
Arcade
Education
Education

External Validity. Threats to external validity relate to the gener-
alization of our results, i.e., our results may not hold beyond the
apps in our dataset. To mitigate this, we performed our study on a
large set of apps from the widely accepted AndroZoo dataset and
the most popular apps from the Google play store. Besides, the apps
in our dataset belong to various categories, and the distribution
over these categories is even.

7 RELATED WORK
Fingerprinting in browsers has been studied for a little more than
a decade. To the best of our knowledge, three large-scale studies
have been conducted on browser fingerprints. The first study [10]
showed how user-agents, list of plugins, and fonts available on a sys-
tem can be used to fingerprint mobile devices. Their results showed
that 83.6 of the user-agents strings are unique, hence, susceptible
to fingerprinting. They coined the term browser fingerprinting, re-
ferring to the use of system information obtained from web clients
as fingerprints. AmIUnqiue took it a step further and identified
new attributes for fingerprint such as HTML canvas elements. It
also identified the most common attributes in fingerprinting for
mobile devices. Oliver’s thesis [22] showed that fingerprinting is
“quite-effective” on mobile devices based on a preliminary investi-
gation in susceptibility of mobile browsers towards fingerprinting.
Our work is placed in the context of browsers embedded in hybrid
apps. Hybrid-app browsers are customized by the developer and,
in contrast to standalone browsers, users have little to no influence
on its security and privacy policies. Therefore, these browsers are
a fertile ground for profiling users through fingerprinting.

In a contrasting study, HidingInTheCrowd [12] studied the evolu-
tion of browser fingerprints over time. Their study shows that the

Figure 4: Unencrypted URLs by App Categories

Internal Validity. WVProfiler relies on existing dynamic analy-
sis tools, and there are many automated Android testing tools. In
particular, WVProfiler uses the Monkey tester, which might result
in section bias. We choose the Monkey tester as the research com-
munity widely uses it, and official Android documents support it.
Another threat is related to the selection of our dataset, i.e., whether
the chosen apps favor WVProfiler . We mitigate this threat by
selecting a large set of apps from the widely used AndroZoo dataset.
Besides, we choose the most popular apps from the Google play
store for manual analysis. One final threat is validating the results
for the manually analyzed apps. To mitigate this threat, at least two
authors of the paper independently performed the manual analysis
and cross-validated the results.

Casual games2,6%Video Players & 4,3%LifeStyle2,6%Finance4,3%Social2,6%Entertainment6,8%Productivity2,6%Music & Audio6,8%Travel & Local4,3%Shopping3,4%Tools1,7%Lifestyle6,0%Office1,7%Books & Reference5,1%News & Magazines7,7%Education15,4%Business2,6%Arcade Games4,3%Conference’17, July 2017, Washington, DC, USA

Abhishek Tiwari, Jyoti Prakash, Alimerdan Rahimov, and Christian Hammer

number of unique fingerprints has reduced from the previous stud-
ies — more in the case of mobile browsers than desktop browsers.
The fingerprints obtained from mobile browsers, in their study,
present attributes having unique values and primarily use user-
agent settings and HTML canvas elements. It conforms to Oliver’s
study [22], where it shows that a majority of mobile fingerprints
are unique due to the presence of an unique identifier. This ob-
servervation also conforms with our study, where we have also
obtained fingerprints which are also unique to users and devices.
As ours is the first studing fingerprinting in hybrid browsers to the
best of our knowledge, it is difficult to comment on the evolution
of fingerprinting in hybrid browsers.

Apart from these, earlier studies have also focussed on the
sources of fingerprints. Acar and others’ study [7] on fingerprint-
ing showed the use of HTML canvas elements in fingerprinting.
Sources of fingerprinting also includes, WebGL [9, 20], Web Audio
API [11], browser extensions [15, 24, 25], and CSS querying [26],
among many others. Therefore, browser fingerprinting techniques
have diversified their sources keeping in pace with evolution of the
web. In comparison, we have confined to features in HTTP-headers
in hybrid apps in to our study. Hybrid apps do not support browser
extensions, and therefore, we have not considered these in our
study. Also, we did not find other sources, such as canvas elements,
WebGL resources in our study and choose to ignore these features.
The paper also overlaps with studies on privacy leakage in hy-
brid apps. Tiwari et al. [27, 28] profiled privacy information leaked
through the bridge interface. Rizzo et al. [23] studied the use of
code injection attacks in WebView. Lee et al. [19] discovered the
vulnerability of AdSDKs leaking sensitive information via loadUrl.
Mutchler [21] conduced a large-scale study on the Android app
ecosystem to detect vulnerabilities in hybrid apps. Their findings
suggest that hybrid apps have at least one security vulnerability
in the Android app ecosystem. Zhang [29] performed a large-scale
study of Web resource manipulation in both Android and iOS We-
bViews. They discovered 21 apps with malicious intents such as
collecting user credentials and impersonating legitimate parties.
In comparison to all these works, we analyze the fingerprints ob-
tained from the hybrid-browsers, and manually analyze the privacy-
leakage thereof.

8 CONCLUSION
In this paper, we studied the fingerprints obtained in hybrid apps. To
this end, we developed an instrumentation-based tool to record the
user-agent strings and HTTP headers used in the webpage of the
hybrid apps. Our study shows that hybrid apps are as susceptible
to fingerprints as websites accessed on mobile browsers. However,
the absence of mechanisms to enforce privacy policies makes it
harder, if not impossible, for users to protect their privacy. There-
fore, the recent advances in protecting privacy via fingerprinting
do not translate into the realm of hybrid apps as the configuration
remains in the hands of developers. Our study highlights the need
for research into mechanisms to enforce privacy policies in hybrid
apps.

REFERENCES
[1] 2014. Coveryourtracks. https://coveryourtracks.eff.org/.

[2] 2015.

Research: Chrome For Android Reveals Phone Model and Build.
https://wwws.nightwatchcybersecurity.com/2015/09/30/research-chrome-for-
android-reveals-phone-model-and-build/.

[3] 2015. Webview privacy issue. https://bugs.chromium.org/p/chromium/issues/

detail?id=494452.
[4] 2021. Webview.

WebView/.

https://developer.android.com/reference/android/webkit/

[5] 2022. Dynamic instrumentation toolkit for developers, reverse-engineers, and

security researchers. https://frida.re/docs/android/.

[6] 2022. Tool and dataset for fingerprinting the Android hybrid web apps.

https://doi.org/10.5281/zenodo.6779325.

[7] Gunes Acar, Christian Eubank, Steven Englehardt, Marc Juarez, Arvind
Narayanan, and Claudia Diaz. 2014. The Web Never Forgets: Persistent Track-
ing Mechanisms in the Wild. In Proceedings of the 2014 ACM SIGSAC Con-
ference on Computer and Communications Security (Scottsdale, Arizona, USA)
(CCS ’14). Association for Computing Machinery, New York, NY, USA, 674–689.
https://doi.org/10.1145/2660267.2660347

[8] Kevin Allix, Tegawendé F Bissyandé, Jacques Klein, and Yves Le Traon. 2016.
Androzoo: Collecting millions of android apps for the research community. In
2016 IEEE/ACM 13th Working Conference on Mining Software Repositories (MSR).
IEEE, 468–471.

[9] Yinzhi Cao, Song Li, and Erik Wijmans. 2017. (Cross-)Browser Fingerprinting

via OS and Hardware Level Features. In NDSS.

[10] Peter Eckersley. 2010. How Unique is Your Web Browser?. In Proceedings of the
10th International Conference on Privacy Enhancing Technologies (Berlin, Germany)
(PETS’10). Springer-Verlag, Berlin, Heidelberg, 1–18.

[11] Steven Englehardt and Arvind Narayanan. 2016. Online Tracking: A 1-Million-
Site Measurement and Analysis. In Proceedings of the 2016 ACM SIGSAC Con-
ference on Computer and Communications Security (Vienna, Austria) (CCS ’16).
Association for Computing Machinery, New York, NY, USA, 1388–1401. https:
//doi.org/10.1145/2976749.2978313

[12] Alejandro Gómez-Boix, Pierre Laperdrix, and Benoit Baudry. 2018. Hiding in the
Crowd: An Analysis of the Effectiveness of Browser Fingerprinting at Large Scale.
In Proceedings of the 2018 World Wide Web Conference (Lyon, France) (WWW ’18).
International World Wide Web Conferences Steering Committee, Republic and
Canton of Geneva, CHE, 309–318. https://doi.org/10.1145/3178876.3186097
[13] Google. 2022. Chromium WebView Browser. https://developer.chrome.com/docs/

multidevice/webview/.

[14] Google. 2022. Monkey Tester. https://developer.android.com/studio/test/other-

testing-tools/monkey.

[15] Gabor Gyorgy Gulyas, Doliere Francis Some, Nataliia Bielova, and Claude Castel-
luccia. 2018. To Extend or Not to Extend: On the Uniqueness of Browser Ex-
tensions and Web Logins. In Proceedings of the 2018 Workshop on Privacy in
the Electronic Society (Toronto, Canada) (WPES’18). Association for Computing
Machinery, New York, NY, USA, 14–27. https://doi.org/10.1145/3267323.3268959
[16] Internet Engineering Task Force (IETF). 2022. RFC 9110: HTTP Semantics. https:

//www.rfc-editor.org/rfc/rfc9110#name-user-agent.

[17] Pierre Laperdrix, Nataliia Bielova, Benoit Baudry, and Gildas Avoine. 2020.
Browser Fingerprinting: A Survey. ACM Trans. Web 14, 2, Article 8 (apr 2020),
33 pages. https://doi.org/10.1145/3386040

[18] Pierre Laperdrix, Walter Rudametkin, and Benoit Baudry. 2016. Beauty and the
Beast: Diverting Modern Web Browsers to Build Unique Browser Fingerprints.
In 2016 IEEE Symposium on Security and Privacy (SP). 878–894. https://doi.org/
10.1109/SP.2016.57

[19] Sungho Lee and Sukyoung Ryu. 2019. Adlib: Analyzer for Mobile Ad Platform
Libraries. Association for Computing Machinery, New York, NY, USA, 262–272.
https://doi.org/10.1145/3293882.3330562

[20] Keaton Mowery and Hovav Shacham. 2012. Pixel Perfect : Fingerprinting Canvas

in HTML 5.

[21] Patrick Mutchler, Adam Doupé, John C. Mitchell, Christopher Kruegel, and
Giovanni Vigna. 2015. A Large-Scale Study of Mobile Web App Security.
[22] John Oliver. 2018. Fingerprinting the Mobile Web. Ph. D. Dissertation. Master

Thesis. London, UK: Imperial College London.

[23] Claudio Rizzo, Lorenzo Cavallaro, and Johannes Kinder. 2018. Babelview: Evalu-
ating the impact of code injection attacks in mobile webviews. In International
Symposium on Research in Attacks, Intrusions, and Defenses. Springer, 25–46.
[24] Iskander Sanchez-Rola, Igor Santos, and Davide Balzarotti. 2017. Extension
Breakdown: Security Analysis of Browsers Extension Resources Control Policies.
In 26th USENIX Security Symposium (USENIX Security 17). USENIX Association,
Vancouver, BC, 679–694. https://www.usenix.org/conference/usenixsecurity17/
technical-sessions/presentation/sanchez-rola

[25] Oleksii Starov and Nick Nikiforakis. 2017. XHOUND: Quantifying the Finger-
printability of Browser Extensions. In 2017 IEEE Symposium on Security and
Privacy (SP). 941–956. https://doi.org/10.1109/SP.2017.18

[26] Naoki Takei, Takamichi Saito, Ko Takasu, and Tomotaka Yamada. 2015. Web
Browser Fingerprinting Using Only Cascading Style Sheets. In 2015 10th Inter-
national Conference on Broadband and Wireless Computing, Communication and
Applications (BWCCA). 57–63. https://doi.org/10.1109/BWCCA.2015.105

Our fingerprints don’t fade from the Apps we touch: Fingerprinting the Android WebView

Conference’17, July 2017, Washington, DC, USA

[27] A. Tiwari, J. Prakash, S. GroB, and C. Hammer. 2019. LUDroid: A Large Scale
Analysis of Android – Web Hybridization. In 2019 IEEE 19th International Working
Conference on Source Code Analysis and Manipulation (SCAM). IEEE Computer
Society, Los Alamitos, CA, USA, 256–267. https://doi.org/10.1109/SCAM.2019.
00036

[28] Abhishek Tiwari, Jyoti Prakash, Sascha Groß, and Christian Hammer. 2020. A
Large Scale Analysis of Android — Web Hybridization. Journal of Systems and

Software 170 (2020), 110775. https://doi.org/10.1016/j.jss.2020.110775

[29] Xiaohan Zhang, Yuan Zhang, Qianqian Mo, Hao Xia, Zhemin Yang, Min Yang,
Xiaofeng Wang, Long Lu, and Haixin Duan. 2018. An Empirical Study of Web
Resource Manipulation in Real-World Mobile Applications. In Proceedings of the
27th USENIX Conference on Security Symposium (Baltimore, MD, USA) (SEC’18).
USENIX Association, USA, 1183–1198.

