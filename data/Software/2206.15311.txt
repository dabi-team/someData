IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

1

Performance Analysis of Optimized Versatile Video
Coding Software Decoders on Embedded Platforms

Anup Saha ID , Wassim Hamidouche ID , Miguel Chavarr´ıas ID , Guillaume Gautier ID , Fernando Pescador ID , Senior
Member, IEEE,, Ibrahim Farhat ID

2
2
0
2

n
u
J

0
3

]

V

I
.
s
s
e
e
[

1
v
1
1
3
5
1
.
6
0
2
2
:
v
i
X
r
a

Abstract—In recent years,

the global demand for high-
resolution videos and the emergence of new multimedia appli-
cations have created the need for a new video coding standard.
Hence, in July 2020 the Versatile Video Coding (VVC) standard
was released providing up to 50% bit-rate saving for the same
video quality compared to its predecessor High Efﬁciency Video
Coding (HEVC). However, this bit-rate saving comes at the
cost of a high computational complexity, particularly for live
applications and on resource-constraint embedded devices. This
paper presents two optimized VVC software decoders, named
OpenVVC and Versatile Video deCoder (VVdeC), designed for
low resources platforms. They exploit optimization techniques
such as data level parallelism using Single Instruction Multi-
ple Data (SIMD) instructions and functional level parallelism
using frame, tile and slice-based parallelisms. Furthermore, a
comparison in terms of decoding run time, energy and memory
consumption between the two decoders is presented while tar-
geting two different resource-constraint embedded devices. The
results showed that both decoders achieve real-time decoding
of Full High-deﬁnition (FHD) resolution over the ﬁrst platform
using 8 cores and High-deﬁnition (HD) real-time decoding for
the second platform using only 4 cores with comparable results
in terms of average consumed energy: around 26 J and 15 J
for the 8 cores and 4 cores platforms, respectively. Regarding
the memory usage, OpenVVC showed better results with less
average maximum memory consumed during run time compared
to VVdeC.

Index Terms—VVC, SIMD, embedded systems, decoder, mul-

ticore, real-time.

I. INTRODUCTION

A new era of information and communication technologies

is emerging, where video communication plays an essen-
tial role in internet trafﬁc. In particular, the signiﬁcant increase
in video trafﬁc supported by the COVID19 global health
situation and the emerging video formats and applications
have lead to the development of a new video coding standard,
named Versatile Video Coding (VVC)/H.266. This latter was
standardized in July 2020 by the Joint Video Experts Team
(JVET) of the VCEG working group of ITU-T and the MPEG
working group of ISO/IEC JTC 1/SC 29 [1]. VVC enables
bit-rate savings of up to 50% [2] with respect to the previous

Anup Saha, Miguel Chavarr´ıas and Fernando Pescador were with CITSEM
at Universidad Polit´ecnica de Madrid, Madrid, Spain, e-mail: (anup.saha;
miguel.chavarrias; fernando.pescador)@upm.es.

Wassim Hamidouche, Guillaume Gautier and Ibrahim Farhat were with
Univ. Rennes, INSA Rennes, CNRS, IETR - UMR 6164, Rennes, France, e-
mail: (wassim.hamidouche; guillaume.gautier; ibrahm.farhat)@insa-rennes.fr.
This work was supported by both the Energy Efﬁcient Enhanced Media
Streaming (3EMS) project funded by the Brittany Region and TALENT
project (PID2020-116417RB-C41), funded by the Spanish Ministerio de
Ciencia y Innovaci´on.

standard High Efﬁciency Video Coding (HEVC)/H.265 [3] for
the same video quality. However, this achievement comes at
the cost of 10× and 2× more complexity compared to HEVC
for the encoder and decoder contexts, respectively [4]. In this
scenario, the main challenge is to develop real-time VVC
codecs that take into account resource-constrained consumer
devices frequently used in consumer electronics based on
embedded platforms.

Each coding standard is released with a reference software
implementation available for the scientiﬁc community. These
solutions incorporate all the basic features of the standard but
offer a very limited speed performance. In the case of VVC,
the reference software is the VVC Test Model (VTM) [5].
Taking this as a starting point, research groups and companies
develop their own real time software and hardware solutions.
Depending on the targeted architecture, these solutions mainly
exploit the intrinsic parallelism of the algorithms, both at the
data and functional levels, to enhance their performance in
terms of speed and energy consumption. In the ﬁrst case, some
data operations included in the source code are optimized
by using Single Instruction Multiple Data (SIMD) type in-
structions [6]. Here, vectorized operations are used to perform
mathematical operations with more than one operator using a
single processor instruction. The other potential optimisation
route is to take advantage of the intrinsic parallelism of
independent processing of pictures [7], or smaller parts of the
picture, such as slices [8] or tiles [9]. In the latter case, it is
necessary that the coding is done by activating these normative
tools that break dependencies between adjacent regions.

In this work, two open source VVC decoders are presented
and compared against each other. These solutions, named
OpenVVC [11], [12] and Versatile Video deCoder (VVdeC)
[13] decoders, are optimized using data and functional level
parallelism techniques. In this paper, we evaluate their per-
formance in terms of decoding run time, power consumption
and memory usage targeting two different embedded plat-
forms. The results showed that both decoders have achieved
15 to 34 Frame Per Second (fps) for Ultra High-deﬁnition
(UHD) sequences with Quantization Parameter (QP) 27 and
37, and achieved real-time decoding of Full High-deﬁnition
(FHD) and High-deﬁnition (HD) sequences over the ﬁrst target
platform using 8 cores. Furthermore, 16 to 28 fps have been
obtained for FHD sequences with QPs 27 and 37, and real-
time decoding has been reached for all HD sequences by
OpenVVC and VVdeC when targeting the second embedded
platform with 4 cores. In terms of energy consumption and
maximum memory usage, the experimental results showed that

 
 
 
 
 
 
IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

2

VVdeC has consumed ×2 more memory with respect to the
consumption of OpenVVC over both target platforms. On the
other hand, OpenVVC consumed the same energy as VVdeC
on the Embedded System-on-Chip (ESoC)1 platform with 8
cores and around 1.25× VVdeC’s energy consumption when
targeting ESoC2 embedded platform with 4 cores.

The rest of the paper is structured as follows. Section II
give a short introduction to the VVC standard. Section III
describes the optimizations included in the VVC decoders
using speciﬁc parallelization techniques along with the state-
of-the-art of VVC decoders. Section IV details the proposed
optimizations techniques included in the OpenVVC decoder.
The obtained results and comparison between OpenVVC and
VVdeC performance are provided in Section V. Finally, Sec-
tion VI concludes the paper.

II. INTRODUCTION TO VVC

Similar to its predecessors, VVC was designed based upon
a hybrid coding scheme using intra/inter-prediction coding and
transform coding. In Figure 1, the decoding process scheme of
VVC is presented. Here, the encoded bit-stream is the input,
the decoded video is the output, and each decoding phase is
presented by one block.

A. Entropy decoding

Bit-stream decoding begins with this process integrated
with similar but advanced context adaptive binary arithmetic
coding (CABAC) [14] with respect to HEVC. Here, an updated
multihypothesis probability estimation model was adapted and
the computed look-up table was eliminated for enhancing
the accuracy. The coefﬁcient coding has been improved by
allowing 1×16, 2×8, 8×2, 2×4, 4×2, and 16×1 coefﬁcients
group size for transform block size.

[15] tool used to encode the residual inter and intra coding
blocks. MTS allows three transforms of the rectangle blocks
with the height and width of ≤ 64 for Discrete Cosine
Transform (DCT)-II, ≤ 32 for DCT-VIII and Discrete Sine
Transform (DST)-VII. Moreover, the coefﬁcients of high fre-
quency are zeroed when the height and or width is equal to 64
for DCT-II and 32 for DCT-VIII and DST-VII. In addition,
Low Frequency Non-Separable Transform (LFNST) [16] is
used on the low frequency coefﬁcients of the transform domain
after DCT-II for further signal decorrelation.

C. Intra prediction

In VVC intra-prediction module, 32 additional directional
intra-prediction modes were added with respect to HEVC.
Moreover, it allows a wide-angle intra modes for rectangular
blocks, which improves the prediction accuracy. In addition,
the matrix weighted intra-prediction tool was used a new intra
prediction mode by taking above and left neighbouring lines of
the prediction block. Besides, VVC adapted cross-component
linear model [17] tool, which applied to the prediction of
chroma components from the luma components.

D. Inter prediction

Inter-prediction takes advantage of the temporal redundancy
of the video by removing the correlation in the temporal
domain [18]. Here, the motion compensation estimates the
current coding unit samples according to the samples recorded
in the decoded picture buffer. In addition, 8-tap ﬁlter is used to
luma samples for creating motion-compensated prediction and
4-tap ﬁlter is used to chroma samples for interpolation [19].
Furthermore, VVC achieved improved prediction accuracy
using decoder-side motion vector reﬁnement [20] and bi-
directional optical ﬂow prediction reﬁnement [21].

B. Inverse quantization and transform

E. Luma mapping with chroma scaling

The spatial domain coefﬁcients are retrieved from the fre-
quency domain by inverse quantization and inverse transfor-
mation. VVC introduces Multiple Transform Selection (MTS)

Fig. 1: Block diagram of a VVC decoder.

Forward Luma Mapping with Chroma Scaling (LMCS) is a
new tool introduced in VVC and comes after inter-prediction
stage. It has two parts: Luma Mapping (LMP), used to modify
luma predicted samples, and Chroma Scaling (CSP), used to
modify chroma residues. LMP makes the most use of the range
of luma code values and provides an efﬁcient reallocating
process of luma code values in the coding domain. Therefore,
CSP changes the value of the chroma residual samples in the
chroma coding block for mitigating the defect coming from
the interaction between luma and luma corresponding chroma
signals [22].

F. In-loop Filters

VVC in-loop ﬁlters consist of inverse Inverse Luma Map-
ping Chroma Scaling (ILMCS) [23], Deblocking Filter (DBF),
Sample Adaptive Offset (SAO) ﬁlter and Adaptive Loop
Filter (ALF). First, ILMCS is a new addition to VVC which
enhances the decoding performance by inverse mapping the
luma code to the reconstructed block. DBF and SAO in VVC
are very similar to HEVC [24]. DBF is used to detect and ﬁlter
the artifacts of the pixels at the block boundaries and SAO is

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

3

used to minimize sample distortion over the pixels ﬁltered by
DBF. In addition, unlike HEVC, VVC includes ALF [23] for
reducing mean-squared error of the decoded pixels. Therefore,
undesired artifacts obtained by the previous decoding modules
including blurring, blocking, ﬂickering, ringing, and colour
shift are mitigated using in-loop ﬁlters and the decoded video
is obtained.

III. OPTIMIZED AND REAL TIME SOFTWARE DECODERS

There are three levels of parallelism that can be exploited
to speedup the video decoding process: data-level, frame-
level and high-level. In this section we ﬁrst describe these
three levels of parallelism, then we give a brief description of
existing optimised decoders with an introduction to the recent
software and real time VVC decoders including OpenVVC
and VVdeC.

A. Task level parallelism

1) Single instruction multiple data: SIMD is a data-level
parallel processing technique that loads multiple data in single
register to operate with. The x86-based architectures offer
Streaming SIMD Extensions (SSE) and Advanced Vector
Extensions (AVX) based SIMD intrinsics. Embedded general
purpose processor (EGPP) based platforms support ARM
Neon suite instead of SSE and AVX based SIMD intrinsic.
ARM Neon is an advanced SIMD technology designed for
mobile devices that support up to 128-bit register. Neon-based
SIMD technology can be used following 4 ways [25]: a) using
Neon intrinsics, b) Neon-enabled libraries, c) compiler auto-
vectorization, and d) hand-coded Neon assembler.

2) Frame-level parallelism: Simultaneous processing of
multi-frames is performed in frame-level parallelism while de-
pendencies of the motion compensation are also satisﬁed. The
length of the motion vector is, in this case, the deterministic
factor [8]. Video sequences with large motion would imply
large dependencies between frames which may create a major
disadvantage for frame-level parallelism. Hence, sequences in
all intra conﬁguration are the most beneﬁted by frame-level
parallelism due to the fact that there are no motion com-
pensation dependencies. Moreover, in frame-level parallelism,
additional picture buffer and local buffers should be stored for
each thread used to decode in parallel. As a result, it demands
higher memory than sequential decoding.

B. High level parallelism

1) Wave-front parallel processing: Wave-front Parallel Pro-
cessing (WPP) allows virtual picture partitioning into Coding
Tree Unit (CTU) rows [8]. In WPP, the coding dependency
is kept unchanged during the picture partitioning while the
entropy engine is initialized at the start of each CTU line.
Therefore, at the beginning of each CTU row, the CABAC
context is re-intialized and it depends at least on the data from
ﬁrst CTU of the previous row. As a result, the decoding of
rows could not completed at the same time and slightly limits
parallelisation efﬁciency of WPP.

2) Tiles parallelism: VVC supports tiles of rectangular
shape consisting of CTUs [26]. An example of tile partition
is shown in Fig. 2. Here, four tiles are labelled with A, B,
C, and D. Tiles are separated by boundaries, which eliminates
the prediction dependencies. Therefore, for all the tiles, the
entropy encoding step is reinitialized, which allows to decode
tiles independently. It allows decoding a picture concurrently
using multiple threads. However, the in-loop ﬁltering process
can only be carried out at the tile boundaries when pixels are
reconstructed from both sides.

Fig. 2: Illustration of tile partitioning in VVC decoder.

C. Codec optimisations

Various parallelization methods have been used to accelerate
video codecs on Central Processing Unit (CPU), Graphics
Processing Unit (GPU), and combination of both based ar-
chitectures. Yan et al. accelerated a HEVC decoder by ×4
compared to HM 4.0 using SIMD technologies over a x86 pro-
cessor in [27]. Authors in [28] and [29] proposed GPU-based
implementation of HEVC that satisﬁed real-time requirements
for the decoding of UHD 4k sequences. S. Gudumas et al.
in [8] discussed various optimization techniques to implement
VVC using multiple CPU cores on heterogeneous platforms
with the purpose of achieving real-time decoding [8]. Here, the
decoding tasks were redesigned and parallelized with task par-
allelization based on load balancing and data parallelization, at
the level of CTU. The authors in [30] presented a GPU-based
motion compensation system to accelerate the VVC decoder
that exploits the partition of the different Coding Unit (CU)
and proper thread organisation. Furthermore, Wieckowski et
al. in [2] described an optimized VVC decoder that achieved
real-time decoding on general purpose CPUs. Here, SIMD
operations-based optimisation and multi-threading based op-
timisation were adapted. The authors in [31] demonstrated
an optimized real-time VVC decoder that takes advantage of
SIMD instruction extensions on x86 based CPU. Moreover,
the authors discussed the implementation of frame, CTU, sub-
CTU, and task level parallelization. An optimized VVC soft-
ware decoder on mobile platforms is presented in [18],. The
presented decoder was generated from VTM-11.0 reference
software. Here, the decoder achieved real-time decoding for
HD video sequences using SIMD and multi-threading on ARM
[24] based platform.

There are a handful of software open-source decoders
available that are compliant with the VVC standard. Firstly,
the already mentioned reference VVC test model, or VTM.

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

4

Secondly, VVdeC [13], an implementation proposed by Fraun-
hofer Institute, is an optimized decoder based on VTM. It
includes SIMD and multi-threads parallelisation for an optimal
performance. Thirdly, O266dec [32], a real
time decoder
proposed by Tencent Media Lab. O266dec also uses the SIMD
and multithreading parallelisation techniques. Unfortunately
this decoder has not been updated in the last 14 months.
Finally, OpenVVC is a lightweight open source software
decoder that
is designed to target
different operating systems and hardware architectures. Similar
to VVdeC and O266dec, OpenVVC uses data and functional
level parallelism to optimize the decoding performance. For
more details on VVC codecs, Sullivan
[10] provides a
complete list of available VVC encoder and decoder imple-
mentations.

is available in [11]. It

1) Introduction to OpenVVC: OpenVVC is an open source
software VVC decoder written in C programming language.
It is compiled as a cross-platform library and is compatible
with most-used operating systems and optimized for x86 and
ARM processors. The last version of the decoder is compliant
with VVC Main proﬁle. In addition, it is integrated with VLC
[33], GPAC [34], and FFplay [35] video players. OpenVVC
provides high decoding speed by using as little memory as
possible. It exploits tiles and frames paralelization based on
multi-CPU cores, and SIMD optimisations for accelerating
the decoding process. The decoding process of OpenVVC
starts by parsing the parameters of the sequence. Therefore,
reconstruction tasks consisting of Inverse Quantization and
Transform (TX), LMCS, Inter Prediction (EP) and Intra Pre-
diction (IP) decoding blocks, are performed at the CU level.
Then, DBF is performed immediately after the reconstruction
process is completed at the level of CTU. This approach helps
to optimize memory usage by avoiding massive storage of
quantization parameter map and CU dimension that is essential
for the DBF process. Finally, ALF is applied after the SAO
at the level of CTU line and this process delivers the decoded
frame as output.

2) Introduction to Versatile Video Decoder: VVdeC [13]
is an open source software VVC decoder optimized for
x86 architectures and developed by Fraunhofer Institute for
Telecommunications, Heinrich Hertz Institute, HHI. Unlike
OpenVVC, VVdeC has been developed from VTM reference
software [36]. It supports VVC Main 10 proﬁle and it is
capable to decode all conformance VVC bitstreams [37]. In
addition, VVdeC comes with SIMD optimisations and multi-
threading parallelisation over x86 architectures. The paralleli-
sation of VVdeC decoding begins by parsing multiple frames
concurrently. Therefore, in the reconstruction process, tasks
are split based on CTU lines and CTUs. Here, a stage is given
to each CTU for tracking the following stage and process tasks
in parallel after the dependencies are satisﬁed. It allows task
coordination where a task worker is assigned to each CTU.
Task workers are scanned by a thread-pool for assigning the
available task. VVdeC has achieved decoding time reduction
up to 90% [2] with respect to VTM.

IV. DECODER OPTIMIZATIONS

This section describes the implementation of frames, tiles,
and Neon-based SIMD parallelisms in OpenVVC over EGPP-
based platforms.

A. Frames and Tiles parallelization in OpenVVC

In frame-level parallelism of OpenVVC, a main thread is
used to parse the Picture Parameter Set (PSP), Sequence Pa-
rameter Set (SPS), picture/slice header and schedule decoding
threads with a thread pool. Then, the main thread provides the
data and updates the internal structure of the available threads
in the thread-pool for decoding the frame. Therefore, motion
compensation synchronisation between threads is performed
for sequences with inter-coding conﬁguration after starting the
decoding process. In fact, this latter is the most challenging
step in frame-level parallelism, where the available thread has
to wait for motion compensation before starting the pixels
processing. When pixels are ready, the available thread is able
to perform the decoding process. This process is applied at
the CTU line level since OpenVVC performs decoding and
in-loop ﬁltering at CTU line basis. Once the decoding process
is completed, the decoding threads signal their availability to
the main thread and return to the thread-pool.

On the other hand,

tiles level parallelism is applied at
a portion of a frame. In fact, every frame is decomposed
into rectangular regions of the picture containing multiple
CTUs [26]. The main challenge of tile level parallelism is
that tiles could have different run time complexities. Therefore,
the time required to ﬁnish one frame is the time to ﬁnish the
longest tile. In this case, at a certain processing time, some
threads are free, without a task, waiting to ﬁnish processing
the current frame. For more details about this issue, a quality-
driven dynamic frame partitioning for efﬁcient parallel pro-
cessing is explained by Amestoy et al. in [38]. A dynamic
tile and rectangular slice partitioning solution enables the best
partitioning conﬁguration that minimizes the trade-off between
multi-thread encoding time and quality loss. This is performed
by taking into account both spatial texture of the content and
encoding times of previously encoded frames. Experiments
prove that the proposed solution, compared to uniform par-
titioning, signiﬁcantly decreases multi-thread encoding time,
with slightly better quality.

The proposed solution integrated in OpenVVC aims to
efﬁciently activating all threads at all times. In order to do so, it
applies thread pipelining technique that overlooks frames and
focuses only on tiles. Figure 3 illustrates tile pipelining. The
tile partitioning forms a 2×2 grid. They are labeled A, B, C
and D for the ﬁrst frame and A’, B’, C’ and D’ for the second
frame and delimited by the thicker black lines. Prediction
dependencies across tile boundaries are broken and entropy
encoding state is reinitialized for each tile. These restrictions
ensure that tiles are independently decoded, allowing several
threads to decode simultaneously the same picture. As it can
be observed, regardless of the tile position, as soon as a thread
is available from the thread pool, the tile is processed. Thread
2 for example does not work on any tiles of the second frame
since it took the entire time working on tile D of the ﬁrst frame.

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

5

This fact does not restraint threads 0 and 1 from working
on the tiles of the second frame. However, adopting this
technique creates some sort of a combination between frame
and tile parallelism, as a result, dependencies between frames
for inter prediction and motion compensation should be taken
into account. This latter is handled by OpenVVC. Moreover,
since OpenVVC processes tiles independently of their frame
afﬁliation, tile size and load optimization at the encoder side
do not actually impact the performance of OpenVVC. At the
end, tiles are pipelined regardless of their size or load without
waiting to ﬁnish processing the current frame.

TABLE I: Main functions optimized with SIMD.

VVC Block

Module

TX

IP

EP

DST-VII, DCT-II, DCT-VIII
Inter-component transform
Low-frequency non-separable transform

Luma 8-tap ﬁlters
Chroma 4-tap ﬁlters
Bi-directional optical ﬂow
Decoder side motion vector reﬁnement
Prediction reﬁnement with optical ﬂow

DC, Planar
Cross-component linear model
Matrix-based intra prediction module

In-loop
ﬁlters

Edge and band ﬁlter of SAO
ALF 7×7 diamond shape ﬁlters for the luma component
ALF 5×5 diamond shape ﬁlters for the chroma component
Block classiﬁcation of ALF

using SIMD intrinsics based on logical and mathematical
operations: vand, veor, vadd, and vmul. The most beneﬁting
modules of EP block by SIMD parallelisation are luma 8-tap
ﬁlters, chroma 4-tap ﬁlters, bi-directional optical ﬂow, decoder
side motion vector reﬁnement, and prediction reﬁnement with
optical ﬂow. These functions contain various mathematical and
clipping operations which were handled by vadd, vsub, vmin,
and vmax instructions. In addition, loading and storing data
in larger SIMD registers helped to accelerate EP, because the
prediction information of the pixels is needed multiple times
in different EP functions. Then, the pixel prediction inside the
picture of IP block was effectively managed by storing masks,
clipped, and offset value using SIMD intrinsics. Further, the
edge and band ﬁlter of SAO use vceq, vadd, and vsub
instructions to handle mathematical operations. Finally, ALF
ﬁlters are parallelized by concurrently storing ﬁlter parameters
using shufﬂe intrinsic. Moreover, it exploits the full capacity
of SIMD register of 128 bit using load and store intrinsic
instructions.

V. EXPERIMENTAL RESULTS

In this section, the experimental setup, test bench used in
this study and the experimental results obtained are presented
for two open source optimized decoders VVdeC V1.3 and
OpenVVC V1.0 on two EGPP-based embedded platforms.

A. Experimental Setup

This study focuses on low-cost mobile embedded heteroge-
neous platforms. Therefore, two ESoC platforms, ESoC1 [40]
and ESoC2 [41] have been used. ESoC1 processor consists
of eight EGPP cores running with a maximum clock speed
of 2.26 GHz and 512 embedded GPU (EGPU) cores running
with a maximum clock speed of 1.37 GHz. In addition, ESoC1
has 8MB of L2 cache memory, 4MB of L3 cache memory and
32GB 256-Bit random access memory with 137 GB/s speed.
ESoC2 has 4 EGPP cores and 128 EGPU cores running with a
maximum clock speed of 1.48GHz and 0.92GHz, respectively.
Moreover, it has 2MB L2 cache memory and 4MB 64 bit
random access memory with 25.6 GB/s speed. This work is
only based on EGPP cores and GPU cores could be used in

Fig. 3: Illustration of tile pipelining in OpenVVC decoder.

B. SIMD optimisation in OpenVVC

In this study, ARM Neon-based SIMD optimisations were
adapted to accelerate OpenVVC targeting EGPP-based plat-
forms. First, the x86 architecture-based SIMD intrinsics used
in OpenVCC are replaced by the ARM Neon-based SIMD
intrinsics. Therefore, additional adjustment was adapted due
to the fact that Neon-based intrinsics are not as powerful and
complete as compared to SSE or AVX intrinsics. In particular,
for some cases, one SIMD instruction for x86-based was
replaced with multiple Neon-based SIMD instructions. For
instance, two Neon intrinsics vmull s16 for multiply operation
and vpaddq s32 for add operation are needed to replace
madd epi16.

ESoCs used in this study support up to 128-bit SIMD
registers. A 128-bit register can be loaded with 16 8-bit, 8 16-
bit, 4 32-bit, or 2 64-bit data. This fact allows concurrent data
processing to achieve a theoretical speedup of up to ×16 on 8-
bit data. In this study, Neon-based SIMD instructions are used
to optimize the high computational demanding VVC decoder
modules presented in Table I by adapting the SIMD [39]
library. Here, DST-VII, DCT-II, DCT-VIII, inter-component
transform and LFNST module of TX block of VVC decoder
was accelerated using SIMD registers. TX involves several
matrix operations including matrix multiplication for the in-
verse transformations. These matrix operations were tackled

ABCDA'B'C'D'Frame 0Frame 1Thread 0 Thread 1Thread 2ABCDA'B'C'D'IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

6

TABLE II: Features of the considered VVC test sequences.

Class

Sequence

Resolution

# Frames

Bitdepth

Framerate

A1

A2

B

E

Tango2
FoodMarket4
Campﬁre

CatRobot1
DaylightRoad2
ParkRunning3

MarketPlace
RitualDance
Cactus
BasketballDrive
BQTerrace
ArenaOfValor

FourPeople
Johnny
KristenAndSara

3840×2160
3840×2160
3840×2160

3840×2160
3840×2160
3840×2160

1920×1080
1920×1080
1920×1080
1920×1080
1920×1080
1920×1080

1280×720
1280×720
1280×720

294
300
300

300
300
300

300
300
300
300
300
300

300
300
300

10
10
10

10
10
10

10
10
10
10
10
10

10
10
10

60
60
30

60
60
50

60
60
50
50
60
60

60
60
60

future works to further speedup the decoder. In both platforms
a gcc compiler version 7.5 with -O3 ﬂag activated and Cmake
version 3.16.5 have been used alongside an Ubuntu 18.04
operating system.

B. Test video sequences

Table II presents the different features of the ﬁfteen JVET
common test sequences [42] used in this study. The following
sequences, grouped by resolution classes, have been encoded
by the VTM-11.0 reference software with 10-bit random
access and 3 × 3 tile conﬁguration at two QP 27 and 37.
Three HD sequences from class E are used: FourPeople,
Johnny, and KristenAndSara alongside six FHD sequences of
class B: MarketPlace, RitualDance, Cactus, BasketballDrive,
BQTerrace, and ArenaOfValor. We also considered six UHD
sequences from class A1: Tango2, FoodMarket4, and Campﬁre
and class A2: CatRobot1, DaylightRoad2, and ParkRunning3.

C. Results and analyses

Since this study focuses on analysing the decoding per-
formance over embedded platforms, the average energy con-
sumption and the maximum memory usage have been also
measured. To do so, two open source optimized VVC de-
coders: VVdeC and OpenVVC over the two already mentioned
platforms have been used.

1) Decoding performance: Firstly,

the decoding perfor-
mance of OpenVVC has been studied for four combinations of
frame-tile parallelization by taking advantage of the 8 physical
cores integrated in the ESoC1 architecture:

• 1-frame and 8-tile per frame in parallel (f1/t8).
• 2-frame and 4-tile per frame in parallel (f2/t4).
• 4-frame and 2-tile per frame in parallel (f4/t2).
• 2-frame and 8-tile per frame in parallel (f2/t8).
This study has been performed to do a fair comparison

between the best conﬁguration of OpenVVC and VVdeC.

Fig.4 shows the average decoding performance in frames
per second (fps) for HD and FHD test sequences with QP27
and QP37 on ESoC1 using OpenVVC decoder.

It can be seen from Fig.4 that the least performing conﬁg-
uration is f1/t8 and the best performing conﬁguration is f4/t2

ESoC1

5
.
8
0
3

1
.
8
5
2

3
.
3
9
2

1
.
3
4
2

5
.
5
7

7
.
9
7

8
.
4
0
1

2
.
9
9

4
.
6
0
1

3
.
1
1
1

4
6
2

4
.
9
1
2

6
.
9
8

4
9

)
s
p
f
(

400

e
t
a
r

300

e
m
a
r
f

200

5
.
2
4
2

1
.
2
0
2

100

g
n
i
d
o
c
e
D

0

f1/t8

f2/t4

f4/t2

f2/t8

Threading conﬁguration

HD-QP27 HD-QP37

FHD-QP27

FHD-QP37

Fig. 4: Average decoding performance (fps) of OpenVVC for
QP 27 and 37 sequences on the ESoC1 platform.

for all QPs, HD, and FHD sequences. f4/t2 conﬁguration has
achieved in average ×1.4 and ×1.3 fps compared to the f1/t8
conﬁguration for FHD and HD sequences, respectively. These
results mainly illustrate the gain brought considering both
frame and tile parallelism compared to only frame parallelism
which is constrained by the inter coding dependency.

Fig.5 presents the average decoding performance in fps
obtained over ESoC2 for HD sequences using both QPs.
ESoC2 has four physical cores. For this reason, only three
combinations of frame-title parallelization have been studied:

• 1-frame and 4-tile per frame in parallel (f1/t4).
• 2-frame and 2-tile per frame in parallel (f2/t2).
• 2-frame and 4-tile per frame in parallel (f2/t4).

ESoC2

5
.
4
7

6
.
2
6

6
.
0
7

7
.
9
5

100

2
.
5
6

6
.
5
5

80

60

40

20

0

)
s
p
f
(

e
t
a
r

e
m
a
r
f

g
n
i
d
o
c
e
D

f1/t4

f2/t2
Thread conﬁguration

f2/t4

HD-QP27 HD-QP37

Fig. 5: Average decoding performance (fps) of the OpenVVC
decoder for QPs 27 and 37 sequences on the ESoC2 platform.

In this case, and as shown in Fig.5, the f2/t2 conﬁguration
has achieved 62.6 fps for QP27 and 74.5 fps for QP37, which
is higher in average by 8.1 fps and 3.4 fps than f1/t4 and f2/t4
conﬁgurations for HD sequences, respectively.

The decoding performance and speedup of VVdeC and
f4/t2 conﬁguration of OpenVVC decoders for QPs 27 and
37 over ESoC1 are presented in Table III for all considered
video sequences. It can be seen that the obtained decoding

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

7

TABLE III: Decoding performance (fps) for the considered test sequences at QP27 (top) and QP37 (bottom) on the ESoC1
platform with 1, 2, 4, 6 and 8 cores.

Seq.:QP

# cores

Tango2:27
FoodMarket4:27
Campﬁre:27
Average

CatRobot1:27
DaylightRoad2:27
ParkRunning3:27
Average

MarketPlace:27
RitualDance:27
Cactus:27
BasketballDrive:27
BQTerrace:27
ArenaOfValor:27
Average

FourPeople:27
Johnny:27
KristenAndSara:27
Average

Tango2:37
FoodMarket4:37
Campﬁre:37
Average

CatRobot1:37
DaylightRoad2:37
ParkRunning3:37
Average

MarketPlace:37
RitualDance:37
Cactus:37
BasketballDrive:37
BQTerrace:37
ArenaOfValor:37
Average

FourPeople:37
Johnny:37
KristenAndSara:37
Average

1

3.3/1.0
3.3/1.0
3.7/1.0
3.4/1.0

3.3/1.0
3.1/1.0
2.4/1.0
2.9/1.0

12.5/1.0
13.9/1.0
16.6/1.0
12.2/1.0
12.9/1.0
15.5/1.0
13.9/1.0

52.2/1.0
54.3/1.0
52.0/1.0
52.8/1.0

4.1/1.0
4.0/1.0
4.8/1.0
4.3/1.0

4.1/1.0
4.1/1.0
3.0/1.0
3.8/1.0

16.9/1.0
18.0/1.0
21.7/1.0
14.7/1.0
15.8/1.0
19.9/1.0
17.8/1.0

59.2/1.0
64.2/1.0
60.0/1.0
61.1/1.0

VVdeC (fps)/speedup

OpenVVC (fps)/speedup

4

6

8

2

6.3/1.9
5.9/1.8
6.8/1.9
6.4/1.9

6.4/1.9
6.0/1.9
4.3/1.8
5.6/1.9

23.8/1.9
26.3/1.9
30.7/1.8
22.5/1.8
24.3/1.9
28.5/1.8
26.0/1.9

12.4/3.8
12.4/3.8
13.6/3.7
12.8/3.8

12.7/3.8
11.7/3.8
8.5/3.6
11.0/3.7

46.0/3.7
51.3/3.7
59.0/3.6
43.7/3.6
47.4/3.7
55.0/3.6
50.4/3.6

18.1/5.6
18.2/5.6
19.5/5.3
18.6/5.5

18.5/5.5
17.2/5.5
12.4/5.2
16.0/5.5

66.5/5.3
73.2/5.2
85.1/5.1
63.5/5.2
68.7/5.3
79.2/5.1
72.7/5.2

98.7/1.9
104.4/1.9
97.3/1.9
100.1/1.9

185.5/3.6
196.7/3.6
184.0/3.5
188.8/3.6

257.1/4.9
272.2/5.0
257.5/5.0
262.3/5.0

8.2/2.0
7.9/2.0
9.0/1.9
8.4/1.9

8.2/2.0
8.0/2.0
5.8/1.9
7.3/2.0

33.2/2.0
34.9/1.9
40.3/1.9
28.1/1.9
30.6/1.9
38.5/1.9
34.3/1.9

16.0/3.9
15.8/3.9
17.8/3.7
16.5/3.8

16.1/3.9
16.0/3.9
11.5/3.8
14.5/3.9

64.3/3.8
67.2/3.7
77.3/3.6
55.0/3.7
59.7/3.8
74.4/3.7
66.3/3.7

116.7/2.0
123.2/1.9
115.4/1.9
118.4/1.9

219.1/3.7
231.5/3.6
217.5/3.6
222.7/3.6

23.2/5.6
22.9/5.7
25.8/5.4
24.0/5.6

23.3/5.7
23.4/5.7
16.9/5.6
21.2/5.6

92.6/5.5
97.0/5.4
111.0/5.1
79.6/5.4
87.4/5.5
106.6/5.4
95.7/5.4

299.4/5.1
319.5/5.0
302.1/5.0
307.0/5.0

22.8/7.0
23.0/7.0
24.0/6.5
23.3/6.8

23.3/7.0
21.5/7.0
15.7/6.7
20.2/6.9

82.7/6.6
91.0/6.5
103.0/6.2
77.5/6.4
82.6/6.4
96.8/6.3
88.9/6.4

271.0/5.2
288.2/5.3
294.4/5.7
284.5/5.4

29.7/7.2
29.2/7.2
31.9/6.7
30.3/7.0

29.4/7.1
29.6/7.2
21.3/7.1
26.8/7.1

109.9/6.5
119.8/6.6
133.0/6.1
98.2/6.7
104.1/6.6
128.7/6.5
115.6/6.5

314.5/5.3
355.0/5.5
338.2/5.6
335.9/5.5

1

3.1/1.0
3.0/1.0
3.5/1.0
3.2/1.0

3.2/1.0
2.8/1.0
2.1/1.0
2.7/1.0

11.1/1.0
13.0/1.0
15.4/1.0
11.1/1.0
11.7/1.0
14.0/1.0
12.7/1.0

45.8/1.0
48.9/1.0
47.6/1.0
47.5/1.0

4.1/1.0
3.9/1.0
4.7/1.0
4.3/1.0

4.2/1.0
3.8/1.0
2.8/1.0
3.6/1.0

16.0/1.0
16.6/1.0
20.5/1.0
13.7/1.0
15.5/1.0
19.1/1.0
16.9/1.0

55.5/1.0
57.8/1.0
52.9/1.0
55.4/1.0

2

6.1/2.0
6.1/2.0
7.5/2.1
6.6/2.0

6.3/2.0
5.7/2.0
4.1/2.0
5.3/2.0

21.8/2.0
25.2/1.9
29.6/1.9
21.5/1.9
23.1/2.0
27.3/1.9
24.7/1.9

88.8/1.9
92.6/1.9
89.6/1.9
90.3/1.9

8.2/2.0
7.8/2.0
9.7/2.0
8.6/2.0

8.3/2.0
7.8/2.0
5.5/2.0
7.2/2.0

31.0/1.9
32.4/1.9
39.5/1.9
26.6/1.9
30.3/2.0
37.9/2.0
33.0/1.9

4

6

8

12.1/3.9
12.0/4.0
14.7/4.2
12.9/4.0

12.4/3.9
11.2/4.0
8.1/3.9
10.5/3.9

43.2/3.9
49.8/3.8
57.9/3.8
42.8/3.9
45.7/3.9
53.8/3.8
48.9/3.8

17.9/5.8
17.6/5.8
21.7/6.2
19.0/6.0

18.1/5.7
16.4/5.9
11.9/5.7
15.5/5.8

63.3/5.7
73.7/5.7
82.6/5.4
63.2/5.7
67.4/5.8
78.9/5.6
71.5/5.6

22.7/7.4
22.6/7.5
27.3/7.8
24.2/7.6

22.9/7.2
20.9/7.5
15.1/7.3
19.7/7.3

79.6/7.2
90.4/7.0
94.3/6.1
79.6/7.2
85.2/7.3
96.8/6.9
87.6/6.9

175.4/3.8
180.7/3.7
177.5/3.7
177.9/3.7

252.1/5.5
238.1/4.9
250.0/5.3
246.7/5.2

285.7/6.2
252.1/5.2
272.7/5.7
270.2/5.7

15.1/3.7
15.3/3.9
19.0/4.0
16.5/3.9

16.2/3.9
15.4/4.0
10.8/3.9
14.2/3.9

61.2/3.8
64.7/3.9
76.9/3.8
52.9/3.9
60.1/3.9
74.6/3.9
65.1/3.8

23.7/5.8
22.5/5.7
28.1/5.9
24.8/5.8

23.8/5.7
22.6/5.9
16.1/5.8
20.8/5.8

89.8/5.6
95.8/5.8
111.1/5.4
77.5/5.6
88.2/5.7
108.3/5.7
95.1/5.6

306.1/5.5
297.0/5.1
294.1/5.6
299.1/5.4

30.0/7.3
28.2/7.2
34.3/7.2
30.8/7.2

30.0/7.2
28.5/7.4
20.6/7.4
26.4/7.3

107.1/6.7
117.2/7.0
124.0/6.0
97.1/7.1
109.1/7.0
130.4/6.8
114.2/6.7

344.8/6.2
319.1/5.5
322.6/6.1
328.9/5.9

108.3/2.0
113.2/2.0
103.8/2.0
108.4/2.0

211.3/3.8
219.0/3.8
204.1/3.9
211.4/3.8

speed by both VVdeC and OpenVVC decoders are close to
real-time for UHD sequences and achieve real-time for all
FHD and HD sequences over ESoC1 using 8 cores. Therefore,
the experiment for FHD and HD sequences are presented in
the following part of this study that achieves real-time over
ESoC1. Moreover, it can be noticed that VVdeC has obtained
slightly better fps than OpenVVC on single core conﬁguration
for all sequences at different quantiﬁcation parameters QPs.
However, speedup shows that OpenVVC has provided better
parallelism compared to VVdeC when the number of threads
has increased, which compensates the ﬁrst limitation.

In Table IV,

the decoding performance of VVdeC and
OpenVVC (f2/t2 conﬁguration) decoders for all considered
FHD and HD sequences with QPs 27 and 37 over ESoC2
platform is shown. Here, both VVdeC and OpenVVC decoders
have achieved real-time for HD sequences over ESoC2 using
4 cores. Therefore, in the upcoming part of this study, the
results are presented for HD sequences over ESoC2.
The average decoding performance with respect

to the

number of cores is presented in the Fig. 6. Here, the decoding
frame rates have been recorded for OpenVVC and VVdeC
decoders over ESoC1 and ESoC2. For both QPs, the average
results in fps of OpenVVC and VVdeC are similar for one
to four cores over ESoC2. Moreover, VVdeC has achieved
up to ×1.08 fps with respect to OpenVVC on ESoC1 and
it has reached the saturation point with 7 cores for HD
sequences. However, for FHD sequences,
the performance
results of OpenVVC and VVdeC are comparable on ESoC1.
The performance results follow the same pattern for both
considered QPs.

2) Memory usage: Memory usage is one of the most
limiting factors and a likely bottleneck for video decoding
over resource-constrained embedded hardware. This part of
the study presents the maximum memory (in MB) consumed
by OpenVVC and VVdeC over ESoC1 and ESoC2 for the
FHD/HD sequences with two QPs (27, 37). In Fig. 7, the
average maximum memory usage for different OpenVVC
conﬁgurations and VVdeC is shown. Here, for both FHD

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

8

TABLE IV: Decoding performance (in fps) for the considered
HD and FHD test sequences at QP27 (top) and QP37 (bottom)
on the ESoC2 platform with 1, 2, 3 and 4 cores.

Seq.:QP

# cores

MarketPlace:27
RitualDance:27
Cactus:27
BasketballDrive:27
BQTerrace:27
ArenaOfValor:27
Average

FourPeople:27
Johnny:27
KristenAndSara:27
Average

MarketPlace:37
RitualDance:37
Cactus:37
BasketballDrive:37
BQTerrace:37
ArenaOfValor:37
Average

FourPeople:37
Johnny:37
KristenAndSara:37
Average

VVdeC (fps)

OpenVVC (fps)

1

4.6
5.4
6.4
4.6
4.8
6.0
5.3

21.3
21.9
20.7
21.3

6.3
7.0
8.2
5.6
5.9
7.8
6.8

24.8
25.6
23.8
24.7

2

8.8
10.0
11.6
8.6
9.0
10.9
9.8

39.0
40.4
38.1
39.2

12.1
13.1
15.4
10.7
11.4
14.7
12.9

46.2
48.1
44.5
46.2

3

12.9
14.6
17.0
12.5
13.2
15.9
14.3

56.4
57.9
55.1
56.5

17.6
17.7
22.5
15.7
16.6
21.4
18.6

65.7
68.6
63.8
66.0

4

16.5
18.7
21.5
16.2
17.1
20.1
18.4

69.4
71.4
68.3
69.7

22.5
24.5
28.4
20.3
21.4
26.1
23.9

80.9
83.6
77.9
80.8

1

4.3
5.0
5.8
4.3
4.6
5.5
4.9

18.3
18.1
18.0
18.1

5.9
6.4
7.7
5.2
5.8
7.5
6.4

21.8
21.9
20.6
21.4

2

8.2
9.7
11.3
8.5
8.9
10.7
9.6

35.4
34.7
34.8
34.9

11.5
12.4
14.9
10.3
11.4
14.5
12.5

42.1
42.3
39.6
41.3

3

12.0
14.1
16.4
12.4
13.0
15.7
13.9

50.9
50.5
50.3
50.6

16.9
18.0
21.4
14.9
16.6
21.0
18.1

61.0
60.9
57.0
59.6

4

15.5
18.2
21.0
16.1
16.7
20.0
17.9

64.4
63.2
64.0
63.8

21.7
23.1
27.6
19.2
21.4
26.7
23.3

77.3
76.9
72.6
75.6

350

300

250

200

150

100

50

)
s
p
f
(

e
t
a
r

e
m
a
r
f

g
n
i
d
o
c
e
D

0

1

2

3

4

5

6

7

8

Number of cores

QP 27 QP 37

OpenV V C : ESoC1 − HD
OpenV V C : ESoC2 − HD
OpenV V C : ESoC1 − F HD
V V deC : ESoC1 − HD
V V deC : ESoC2 − HD
V V deC : ESoC1 − F HD

Fig. 6: Average decoding performance (in fps) of OpenVVC,
in brown QP 27 and blue QP 37, and VVdeC, in black QP27
and red QP37, for 1 to 8 number of cores.

and HD sequences, f1/t8 and f2/t8 conﬁgurations have used
the least and the most memory, respectively. These behavior
is expected that with the increase of the number of frames

ESoC1

400

300

200

100

)

B
M

(

y
r
o
m
e
M

2
.
3
9

7
.
1
9

1
.
5
5

9
.
5
5

4
.
1
0
1

7
.
0
0
1

5
.
9
5

1
.
0
6

4
.
7
1
1

4
.
8
1
1

1
.
7
6

8
6

9
.
2
2
1

3
.
3
2
1

2
.
1
8

9
.
0
8

0
OpenVVC: f1/t8

f2/t4

f4/t2
Thread conﬁguration

f2/t8

8
.
8
3
3

1
.
9
2
3

7
.
2
7
1

2
.
6
7
1

VVdeC

HD-QP27 HD-QP37

FHD-QP27

FHD-QP37

ESoC2

200

150

100

50

)

B
M

(

y
r
o
m
e
M

3
.
4
4

2
.
4
4

6
.
8
4

9
.
7
4

5
.
9
5

9
.
9
5

8
.
3
4
1

7
.
1
4
1

0
OpenVVC: f1/t4

f2/t2

f2/t4

VVdeC

Thread conﬁguration

HD-QP27 HD-QP37

Fig. 7: Average maximum memory (in MB) used for QPs 27
and 37 sequences over ESoC1 (top) and ESoC2 (bottom).

decoded in parallel, the memory usage increases since the large
part memory of the decoder is related to the decoded frame.
However, VVdeC requires in average ×2.1 more memory for
HD sequences and ×2.7 more memory for FHD sequences
than the OpenVVC f2/t8 conﬁguration over ESoC1. In ad-
dition, the scenario is the same over ESoC2 platform where
f2/t4 conﬁguration requires in average a maximum memory
of 59.7MB for HD sequences. Moreover, VVdeC requires
in average ×2.4 more memory for HD sequences than the
OpenVVC f2/t4 conﬁguration on ESoC2 platform. It can be
concluded from the results that OpenVVC requires notably
less memory compared to VVdeC. Therefore, OpenVVC
provides a great advantage and thus suitable for resource-
constrained embedded platforms.

3) Energy consumption: Energy consumption is another
important factor for video processing operation over embed-
ded platforms. In this study, the energy consumption was
calculated as follows: 1) the power consumption is taken
(in mW) after decoding each frame using the built-in power
monitor of both ESoC, 2) the average power consumption
of the entire sequence is multiplied by the total
time in
second spent for decoding the sequence, and 3) convert the
energy consumption to Joule. The average energy consumption
in J with different conﬁgurations of OpenVVC and VVdeC
decoders is shown in Fig. 8. Here, OpenVVC and VVdeC

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

9

ESoC1

TABLE V: Average performance (fps) of OpenVVC and
VVdeC decoders on ESoC1 platform with 1 and 8 cores.

60

50

40

30

20

10

)
e
l
u
o
J
(

y
g
r
e
n
E

2
.
5
4

9
.
3
3

2
.
3
4

5
.
3
3

9
.
2
4

4
.
3
3

9
.
3
4

1
.
4
3

9
.
5
4

6
.
3
3

1
.
3
1

8
.
1
1

3
1

3
.
1
1

8
.
2
1

4
.
1
1

8
.
2
1

2
.
1
1

7
.
4
1

6
.
3
1

0
OpenVVC: f1/t8

f2/t4

f4/t2
Thread conﬁguration

f2/t8

VVdeC

HD-QP27 HD-QP37

FHD-QP27

FHD-QP37

ESoC2

4
.
6
1

4
.
4
1

1
.
6
1

1
.
4
1

5
.
6
1

5
.
4
1

4
.
3
1

6
.
1
1

20

15

10

5

)
e
l
u
o
J
(

y
g
r
e
n
E

VVdeC (fps)

OpenVVC (fps)

VVdeC/OpenVVC

# cores

UHD:QP27
UHD:QP37

FHD:QP27
FHD:QP37

HD:QP27
HD:QP37

1

3.17
4.02

13.94
16.66

52.81
61.14

8

21.72
28.52

88.94
115.62

284.53
335.90

1

2.94
3.93

12.72
16.92

47.45
55.39

8

1

21.95
28.59

87.64
114.15

270.18
328.85

108%
102%

110%
98%

111%
110%

8

99%
100%

101%
101%

105%
102%

TABLE VI: Average performance (fps) of OpenVVC and
VVdeC decoders on ESoC2 platform with 1 and 4 cores.

VVdeC (fps)

OpenVVC (fps)

VVdeC/OpenVVC

# cores

UHD:QP27
UHD:QP37

FHD:QP27
FHD:QP37

1

1.20
1.51

5.29
6.81

HD:QP27
HD:QP37

21.31
24.72

4

4.29
5.49

18.36
23.85

69.74
80.78

1

1.15
1.49

4.93
6.43

18.12
21.43

4

4.20
5.43

17.92
23.31

63.83
75.63

1

104%
101%

107%
106%

118%
115%

4

102%
101%

102%
102%

109%
107%

0
OpenVVC: f1/t4

f2/t2

f2/t4

VVdeC

Thread conﬁguration

HD-QP27 HD-QP37

Fig. 8: Average energy (J) consumed for QP 27 and 37
sequences on ESoC1 (top) and ESoC2 (bottom) platforms.

have consumed comparable average energy over ESoC1 for
all conﬁgurations. VVdeC has consumed on average ×1.17
higher energy for HD sequences and ×1.04 higher energy
for FHD sequences with respect to the f4/t2 conﬁguration of
OpenVVC consumption on ESoC1 platform. Similar to the
implementation over ESoC1, the f2/t2 conﬁguration has used
the least amount of average energy over ESoC2. Moreover, the
average energy consumption of OpenVVC is slightly higher
than VVdeC consumption over ESoC2.

4) Comparison between OpenVVC and VVdeC decoders:
Both open-source optimized video decoders OpenVVC and
VVdeC have reached real-time for FHD and HD sequences
over ESoC1 using 8 cores. In addition, both solutions present
results near to real-time performance for UHD sequences on
ESoC1 platform. Moreover, OpenVVC and VVdeC decoders
achieved an average of 22 fps for QP27 and 28.5 fps for
QP37 using 8 cores. Table V and Table VI show the average
performance (in fps) of OpenVVC and VVdeC using different
number of threads on ESoC1 and ESoC2, respectively. The
complexity overhead of OpenVVC with respect to VVdeC is
around 3% for UHD, 5% for FHD and 12% for HD sequences
in both platforms.

To summarize, there are three important parameters to take
into consideration to select a video decoder for an embedded
platform with limited hardware resources: the performance

(fps), the energy consumed to decode a video and the memory
used. The performance of the decoders compared in this paper
(VVdeC and OpenVVC) is very similar and only a small
improvement is achieved in VVdeC while the number of cores
remains low. The energy consumed to decode a sequence is
also very similar between both decodes. Finally, OpenVVC
consumes less memory than VVdeC with a factor higher
than ×2.11. This signiﬁcant reductions makes OpenVVC
decoder as the best option to implement a VVC video decoder
conformance in a multi core platform with limited resources.

VI. CONCLUSION

This paper presents two open source VVC decoders:
OpenVVC and VVdeC, optimized for low-cost resource-
constrained embedded platforms. Here, OpenVVC and VVdeC
have been optimized at the level of data processing using
SIMD operations. In addition, tile and frame based paralleliza-
tions have been implemented in OpenVVC. Both decoders
have achieved 15 to 34 respectively fps for UHD sequences
with QP 27 and 37, and achieved real-time decoding for all
conﬁgurations of FHD and HD sequences over ESoC1 using 8
cores. Furthermore, 16 to 28 fps have been obtained for FHD
sequences for QPs 27 and 37, and real-time decoding has been
obtained for all HD sequences by OpenVVC and VVdeC on
ESoC2 using 4 cores. Moreover, the experimental results for
the two most important factors of the embedded platform: the
average energy consumption and maximum memory usage by
both decoders were presented for ESoC1 and ESoC2. VVdeC
has consumed on average ×2.74 and ×2.96 memory compared
to the OpenVVC f4/t2 conﬁguration on ESoC1 and the f2/t2
conﬁguration on ESoC2, respectively. For average energy us-
ages, VVdeC consumed on average ×1.11 energy with respect
to the OpenVVC f4/t2 conﬁguration on ESoC1 and ×0.83

IEEE TRANSACTIONS ON CONSUMER ELECTRONICS, PAPER UNDER REVIEW

10

[23] M. Karczewicz et al., ”VVC In-Loop Filters,” in IEEE Transactions on
Circuits and Systems for Video Technology, vol. 31, no. 10, pp. 3907-
3925, Oct. 2021, doi: 10.1109/TCSVT.2021.3072297.

[24] A. Saha, M. Chavarr´ıas, F. Pescador, ´A.M. Groba, K. Chassaigne, P.L.
Cebri´an, ”Complexity Analysis of a Versatile Video Coding Decoder over
Embedded Systems and General Purpose Processors,” Sensors 2021, 21,
3320.

[25] “ARM Developer, Neon,” [Online]. Available: https://developer.arm.

com/architectures/instruction-sets/simd-isas/neon.

[26] B. Bross et al., ”Overview of the Versatile Video Coding (VVC)
Standard and its Applications,” in IEEE Transactions on Circuits and
Systems for Video Technology, vol. 31, no. 10, pp. 3736-3764, Oct. 2021.
[27] L. Yan, Y. Duan, J. Sun and Z. Guo, ”Implementation of HEVC decoder
on x86 processors with SIMD optimization,” 2012 Visual Communica-
tions and Image Processing, 2012, pp. 1-6.

[28] D. F. de Souza, A. Ilic, N. Roma and L. Sousa, ”HEVC in-loop
ﬁlters GPU parallelization in embedded systems,” 2015 International
Conference on Embedded Computer Systems: Architectures, Modeling,
and Simulation (SAMOS), 2015, pp. 123-130.

[29] D. F. de Souza, A. Ilic, N. Roma and L. Sousa, ”GPU-assisted HEVC
intra decoder,” Journal of Real-Time Image Processing, 2016, vol. 12,
Issue 2, pp. 531- 547.

[30] X. Han, S. Wang, S. Ma and W. Gao, ”Optimization Of Motion
Compensation Based On GPU And CPU For VVC Decoding,” 2020
IEEE International Conference on Image Processing (ICIP), 2020, pp.
1196-1200.

[31] B. Zhu et al., ”A Real-Time H.266/VVC Software Decoder,” 2021 IEEE
International Conference on Multimedia and Expo (ICME), 2021, pp. 1-6,
doi: 10.1109/ICME51207.2021.9428470.

[32] “Tencent O266dec decoder library,” [Online]. Available: https://github.

com/TencentCloud/O266player.

[33] ”VLC media player: VideoLAN, a project and a non-proﬁt organization,”

[Online]. Available: https://www.videolan.org/.

[34] ”GPAC: Multimedia Open Source Project,” [Online]. Available: https:

//gpac.wp.imt.fr/.

[35] ”Ffmpeg: A complete, cross-platform solution to record, convert and

stream audio and video,” [Online]. Available: https://ffmpeg.org/.

[36] J. Boyce, E. Alshina, F. Bossen, K. Kawamura, I. Moccagatta and W.
Wan, ”Conformance testing for versatile video coding (Draft 6),” Doc.
JVET-U2008 of ITUT/ISO/IEC Joint Video Experts Team (JVET), 21st
JVET meeting: January 2021.

[37] A. Wieckowski, C. Lehmann, B. Bross, D. Marpe, T. Biatek, M. Raulet,
and J. Le Feuvre, ”A Complete End to End Open Source Toolchain
for the Versatile Video Coding (VVC) Standard,” 2021 Proceedings of
the 29th ACM International Conference on Multimedia, Association for
Computing Machinery, New York, NY, USA, 3795–3798.

[38] T. Amestoy, W. Hamidouche, C. Bergeron and D. Menard, ”Quality-
Driven Dynamic VVC Frame Partitioning for Efﬁcient Parallel Process-
ing,” 2020 IEEE International Conference on Image Processing (ICIP),
2020, pp. 3129-3133.

[39] E. Nemerson, ”Transitioning SSE/AVX code to NEON with SIMDe,”
[Online]. Available: https://simd-everywhere.github.io/blog/2020/06/22/
transitioning-to-arm-with-simde.html.

December

[40] ”NVIDIA Jetson AGX Xavier Developer Kit, User Guide,”
DA 09403 003,
Available:
17,
https://developer.nvidia.com/jetson-agx-xavier-developer-kit-user-guide.
[41] ”NVIDIA Jetson Nano Developer Kit, User Guide,” DA 09402 004,
[Online]. Available: https://developer.nvidia.com/

January 15, 2020,
embedded/dlc/Jetson Nano Developer Kit User Guide.

[Online].

2019,

[42] F. Bossen, J. Boyce, X. Li, V. Seregin, and K. S¨uhring, ”JVET Common
Test Conditions and Software Reference Conﬁgurations for SDR Video,”
Document JVET-N1010, JVET of ITU-T, Geneva, Mar 2019.

energy with respect to the OpenVVC f2/t2 conﬁguration on
ESoC2.

REFERENCES

[1] ”Fraunhofer HHI is proud to present the new state-of-the-art in global
video coding: H.266/VVC brings video transmission to new speed,”
[Online]. Available: https://newsletter.fraunhofer.de/-viewonline2/17386/
465/11/14SHcBTt/V44RELLZBp/1.

[2] A. Wieckowski et al., ”Towards A Live Software Decoder Implementation
For The Upcoming Versatile Video Coding (VVC) Codec,” 2020 IEEE
International Conference on Image Processing (ICIP), 2020, pp. 3124-
3128.

[3] ”High Efﬁciency Video Coding,” Recommendation ITU–T H.265; 2013.
[4] C. Feldmann, ”Versatile Video Coding hits major milestone,” [Online].

Available: https://bitmovin.com/compression-standards-vvc-2020.

[5] ”VVC test model,” [Online]. Available: https://mpeg.chiariglione.org/

standards/mpeg-i/versatile-video-coding/

[6] C. C. Chi, M. Alvarez-Mesa, B. Bross, B. Juurlink and T. Schierl,
”SIMD Acceleration for HEVC Decoding,” in IEEE Trans. on Circuits
and Systems for Video Technology, vol. 25, no. 5, pp. 841-855, May
2015.

[7] T. Amestoy, W. Hamidouche, C. Bergeron and D. Menard, ”Quality-
Driven Dynamic VVC Frame Partitioning for Efﬁcient Parallel Process-
ing,” 2020 IEEE International Conference on Image Processing (ICIP),
2020, pp. 3129-3133.

[8] S. Gudumasu, S. Bandyopadhyay, and Y. He, ”Software-based versatile
video coding decoder parallelization,” in Proceedings of the 11th ACM
Multimedia Systems Conference (MMSys ’20), Association for Comput-
ing Machinery, New York, NY, USA, 202–212, 2020.

[9] Koziri, Maria and Papadopoulos, Panos K. and Tziritas, Nikos and
Dadaliaris, Antonios N. and Loukopoulos, Thanasis and Khan, Samee
U. and Xu, Cheng-Zhong, ”Adaptive Tile Parallelization for Fast Video
Encoding in HEVC,” 2016 IEEE International Conference on Internet
of Things (iThings) and IEEE Green Computing and Communications
(GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom)
and IEEE Smart Data (SmartData), 2016, pp. 738-743.

[10] Gary Sullivan, ”Deployment status of the VVC standard,” ISO/IEC
JTC1/SC29/WG11 JVET document Y0021 (JVET-Y0021), Teleconfer-
ence, January, 2022.

[11] ”OpenVVC software repository,” [Online]. Available: https://github.com/

OpenVVC/OpenVVC.

[12] Thomas Amestoy, Pierre-loup Cabarat, Guillaume Gautier, Wassim
Hamidouche and Daniel Menard, ”OpenVVC: a Lightweight Software
Decoder
the Versatile Video Coding Standard,” arXiv preprint
for
arXiv:2205.12217, 2022.

[13] ”Fraunhofer HHI VVdeC software repository,” [Online]. Available:

https://github.com/fraunhoferhhi/vvdec.

[14] D. Karwowski, ”Precise Probability Estimation of Symbols in VVC
CABAC Entropy Encoder,” in IEEE Access, vol. 9, pp. 65361-65368,
2021.

[15] M. J. Garrido, F. Pescador, M. Chavarr´ıas, P. J. Lobo, C. Sanz and P. Paz,
”An FPGA-Based Architecture for the Versatile Video Coding Multiple
Transform Selection Core,” in IEEE Access, vol. 8, pp. 81887-81903,
2020.

[16] Z. Hong, J. Lin, D. Jiang and J. Yin, ”Improve the Efﬁciency of Low
Frequency Non-Separable Secondary Transform Based on Implicit Mul-
tiple Transform Selection,” 2019 International Conference on Artiﬁcial
Intelligence and Advanced Manufacturing (AIAM), 2019, pp. 148-151.
[17] R. Ghaznavi-Youvalari and J. Lainema, ”Joint Cross-Component Linear
Model For Chroma Intra Prediction,” 2020 IEEE 22nd International
Workshop on Multimedia Signal Processing (MMSP), 2020, pp. 1-5.
[18] Y. Li et al., ”An Optimized H.266/VVC Software Decoder On Mobile
Platform,” 2021 Picture Coding Symposium (PCS), 2021, pp. 1-5.
[19] F. Bossen, K. S¨uhring, A. Wieckowski and S. Liu, ”VVC Complexity
and Software Implementation Analysis,” in IEEE Transactions on Circuits
and Systems for Video Technology, vol. 31, no. 10, pp. 3765-3778, Oct.
2021.

[20] D. Fedorov. ”Decoder-Side Motion Vector Reﬁnement (DMVR) in
VVC,” July. 2021 [Online]. Available: https://vicuesoft.com/blog/titles/
DMVR in VVC/.

[21] D. fedorov. ”Bi-directional Optical Flow (BDOF) Prediction Reﬁnement
in VVC,” Oct. 2021 [Online]. Available: https://vicuesoft.com/blog/titles/
bi directional optical ﬂow bdof prediction reﬁnement in vvc/.

[22] T. Lu et al., ”Luma Mapping with Chroma Scaling in Versatile Video
Coding,” 2020 Data Compression Conference (DCC), 2020, pp. 193-202.

