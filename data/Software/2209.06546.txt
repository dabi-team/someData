2
2
0
2

p
e
S
4
1

]
E
S
.
s
c
[

1
v
6
4
5
6
0
.
9
0
2
2
:
v
i
X
r
a

The Role of Executable Abstract Programs in
Software Development and Documentation

Egon B¨orger

Universit`a di Pisa, Dipartimento di Informatica, I-56125 Pisa, Italy
boerger@di.unipi.it;egon.boerger@gmail.com

Abstract. 1 We present Executable Abstract Programs and analyse
their role for software development and documentation. The intuitive
understanding of these programs ﬁts the computational mindset of soft-
ware system engineers and is supported by a simple but precise be-
havioural deﬁnition. Therefore, they can be smoothly integrated in the
practitioner’s daily work to rigorously formulate every design and im-
plementation decision taken on the path from the Executable Abstract
Program for the requirements to the targeted and eﬃciently runnable
code.
The Executable Abstract Programs of the resulting system documen-
tation represent deﬁnitions of implementation steps one can check and
justify by testing (due to their executable character) or by reasoning (due
to the mathematical deﬁnition of their behaviour). For complex systems
the implementation involves multiple (orthogonal or successive) imple-
mentation steps which represent instances of a practical computational
reﬁnement concept. Such a system development process is driven by com-
putational reﬁnements and is strictly limited to explicitly formulate and
justify—besides the requirements—only the necessary implementation
steps. As a consequence, it produces as side-eﬀect a corpus of docu-
mentation that facilitates the understandability of the ﬁnal code and
improves its reliability and resilience; it also enhances the maintenance
process (including reuse and change of abstract programs and code) and
reduces maintenance cost.

1

Introduction

Nobody would think that it could be viable, and for reasons of time pressure
even desirable, to build a skyscraper without constructing a great variety of de-
tailed documentation and mathematical model analysis of a) what to build, b)
what the environmental conditions that need to be respected are (static equilib-
rium, soil pressure, wind exposure, etc.), and c) how the building is realized: nu-
merous blueprints of various parts (‘components’)—including their composition

1 This paper had been prepared for and accepted by the International Sympo-
sium On Leveraging Applications of Formal Methods, Veriﬁcation and Validation
(ISoLA2022). Since it turned out that I could not present the contribution in person
I decided to withdraw it from the conference Proceedings (a Springer LNCS volume).

 
 
 
 
 
 
(‘architecture’)—and of diﬀerent functions and views of the building, at diﬀer-
ent development stages, at diﬀerent levels of detail, and with diﬀerent purposes.
And yet, still nowadays it is not rare to hear software engineers claim exactly
that (just replace the word ‘skyscraper’ by ‘software system’)2. In Sect. 2 we ob-
serve that historically this widespread attitude among practitioners may be the
result of a too narrow understanding of ‘software speciﬁcation’ and its relation
to code.3

In Sect. 3 we explain the basic constituents of a practical notion of abstract
yet executable programs for software-intensive systems. The concept assigns a
precise computational meaning to pseudo-code (hence the term ‘program’) and
can be used in practice to document via a checkable chain of implementation
steps every design and coding decision taken during the code development. This
documentation starts with a precise abstract yet executable program of the re-
quirements (called ground model, see Sect. 3.2) and leads to compilable code.
A ground model supports a rigorous inspection; that is, it makes it possible to
check the appropriateness of the executable abstract program with respect to the
initial verbal or pictorial description of the requirements. All abstract executable
programs support experimental validation (by testing) and mathematical veriﬁ-
cation (by proving desired system properties) of every single design decision. We
point out that this improves not only the understandability and reliability of the
code, but also enhances the maintenance process, including reuse and change of
the abstract programs and the code, and reduces its cost.

It is important that these abstract executable programs, in addition to the
typical application domain notions that appear in the requirements, are for-
mulated using only constructs and concepts that are familiar to the software
engineer and in one way or another appear during any software development
process: during the discussions in the minds of the designers and programmers,
in their words or their sketches on the whiteboard, or as comments in the code.
Due to their abstract nature, these constructs can be instantiated (we say ‘reﬁned
by implementation details’) to express and document every design and coding
decision taken during the development process. We explain why executable ab-
stract programs are not speciﬁcations to be thrown away once the ﬁnal code is
available, but constitute an indispensable part of the documentation of the ﬁnal
code with which they must remain synchronized to eﬃciently support its under-
standing, the analysis of its well-functioning behaviour, and its maintenance. An
authoritative quote aﬃrms the practical relevance of such a code documentation:

2 This note is not about simple algorithms or similar single-agent programs. The term
‘software system’ refers to reactive software-intensive systems where multiple agents
interact with each other and with a possibly physical environment in distributed
concurrent (also called reactive) runs.

3 The read who is not interested in this purely theoretical and rather restricted un-
derstanding of the term ‘speciﬁcation’ may skip this section or come back to it after
having see the notion of executable speciﬁcations we propose in Sect.3 to be used
for practcial code development by stepwise reﬁnements.

A natural, comprehensive, and understandable description of the behavioural
aspects of a system is a must in all stages of the system’s development cycle,
and, for that matter, after it is completed too. [38, p. 480]

2 Executable Abstract Programs are not Declarative

The idea that software can be developed and maintained without an extensive—
let alone rigorous—documentation (except the initial requirements and inline
comments of the running code) seems to be related to the widespread belief in the
Formal Methods community that software speciﬁcations must be declarative, i.e.
expressed by axioms, functional equations or logical formulae stating ‘what’ the
code should do but not ‘how’. We explain in this section why such speciﬁcations
have only a limited range of applicability, often require to start again from scratch
when it comes to building the desired runnable system, and thus not surprisingly
are treated by many software engineers as a throw-away product: once the code
is there the speciﬁcation (if there is any at all) is not used anymore. Often it
is even claimed that the code represents the only authoritative deﬁnition of the
system so that speciﬁcations are not needed at all.

The bias toward declarative speciﬁcations as the good ones, as opposed to
operational (the ‘distasteful’) ones, is held by eminent and inﬂuential theoreti-
cians and for decades has had and still has numerous followers in the Formal
Methods community. To give just one outstanding example standing for many
others, we quote what Tony Hoare stated recently in his contribution Forty years
with Edsger in [1]:

I shared his distaste for operational semantics. An axiomatic semantics can
explain (maybe indirectly) the purpose of a concept and how it can be properly
used (e.g., a chair is for sitting in). An operational semantics would have to
give instructions for building a chair.

The reader can ﬁnd in [9] a precise technical criticism of this conception that
underlies Dijkstra’s understanding and use of formal methods for code design
and veriﬁcation. That criticism is still valid today. Hoare’s example illustrates
a characteristic point of this predilection for axiomatic statements, expressed
in some ﬁxed logic: the axioms specify properties of a static object (a chair)
and its ‘proper use’. To see this in practical terms, replace ‘chair’ with ‘software
system’ and consider as example Z [60,28], one of the earliest and best-known
formal methods. It is declarative, and is based on classical (ﬁrst-order predicate)
logic and the axiomatic set theory of Zermelo-Fraenkel. Z speciﬁcations typically
describe programs statically, as abstract data types not involving any notion of
run. This is considered to be ‘the most important characteristic of Z’:

The most important characteristic of Z ... is that it is completely independent
of any idea of computation. [37, p. 89]

In fact, classical logic was devised (by Frege and others, long before the ap-
pearance of computing machines) to derive from axioms statements that are true

in all Tarski structures (which represent the states of Z speciﬁcations). Action
systems (in particular computer programs) have been devised to dynamically
trigger changes of system states. The question is in which way logical state-
ments that describe static states-of-aﬀairs can be used to describe dynamic state
changes. Classical ﬁrst-order logic is a logic for inﬁnity, well-suited for standard
mathematical investigations which are about static functions, predicates and re-
lations in a world of inﬁnite sets. But the world where programs run is ﬁnite
and dynamic, in continuous evolution. Furthermore, to statically express a state
change, declarative methods need some logical detour.

A simple example is the x /x (cid:48) notation of Z to declaratively describe that the
value of x is changed to a new value indicated by x (cid:48); the semantics of Z must
guarantee that this value is then retrievable in the next state as the value of x .
This triggers the frame problem of axiomatic descriptions, namely that one has
to axiomatize in detail not only the relation between x and x (cid:48) but also which
variables y (or more generally which memory locations) do NOT change their
value. Since the new value is typically the value of some term op(t), computed
by applying a function or operation op to the value v of the term t in the
current state, a direct operational description of the state change that avoids
the x /x (cid:48) notation and the frame problem uses a simple assignment x := op(v ).
If such abstract assignments f (t1, . . . , tn ) := t (with arbitrary terms t, t1, . . . , tn )
because of their operational form are considered as ‘distasteful’ and therefore
should be avoided then, indeed, at least for the software developer, “Z is in
trouble” [37, p. 89].4

The idea that a speciﬁcation should not be executable is held also outside
the Z community; see the inﬂuential paper [39] for arguments brought forward
against the idea to execute speciﬁcations. We will come back to this in the next
section and here remark only that the real issue is not any dichotomy between
declarative (static) and operational (dynamic) descriptions, but the appropriate
level of abstraction at which a description is given. If an operational description
M contains an abstract (e.g. declaratively deﬁned) condition cond or functional
term t, for executions of M for testing purposes one can replace cond (resp.
t) randomly by possible values (for cond one of the two true or false) without
computing cond (resp. t) in the simulated state. There is nothing wrong in pro-
viding an abstract declarative (typically a classical equational) deﬁnition for the
input/output relation of a static mathematical function (for arguments and val-
ues of an inﬁnite domain). Transformational methods as developed in functional
or logic programming can be very helpful in obtaining code to compute such an
equation or a logical axiomatization: if the specifying logical formulae are ‘close’
to clauses of a target logic program or if the specifying equations are ‘close’ to
functions in the target functional programming language, one is not “completely

4 Note that we are discussing the appropriateness of description methods for code
development and not arguing against proof-theoretical investigations of program
behaviour, using various logics, among them extensions of ﬁrst-order logic for ﬁnite
structures or modal logics for (dynamic logic) reasoning about computer programs.
For a logic tailored to reason about Executable Abstract Programs see [61,48,33,34].

independent of any idea of computation” [37, p. 89]. But the situation changes
when it comes to describing dynamical behaviour in a ﬁnite computational world.
The following observations on Z apply to many transformational result-directed
formal methods:

A Z schema can specify a functional system—one that produces an output in
response to an input ... Z by itself is inadequate for specifying reactive systems.
[45]

A reactive system, in general, does not compute or perform a function, but is
supposed to maintain a certain relationship ... with its environment. ... Such
systems do not lend themselves naturally to descriptions in terms of functions
and transformations. [38, p. 479]

Reactive systems exhibit patterns of collaborative actions of multiple agents
working concurrently in (and stimulated by) a possibly complex computing
and/or physical environment. The focus here is on how a state changes by com-
putational steps, and much less on invariants (properties that do not change
during a run). In such a context the operational form allows one to directly
describe what does change due to an action, at its level of abstraction, the un-
touched parts remaining unchanged. Computational models for reactive systems
lead directly to our theme in the next section, namely a computational concept of
Abstract and Executable speciﬁcations that allows the practitioner to document
every design and coding decision by a piece of (pseudo-) code.

3 Documenting the Implementation of Abstractions by

Executable Abstract Programs

In this section we are looking for a concept of Executable Abstract Program that
can replace the widespread narrow interpretation of the term ‘speciﬁcation’. The
abstract character of such programs should allow the software engineer to reﬁne
them to directly reﬂect and thereby document any design or implementation
idea—with the practical consequence of facilitating the understanding of the
ﬁnal code and of enhancing its maintenance process (including code changes
and extensions) in terms of reliability and cost.

3.1 ASMs are Executable Abstract Programs

The restricted applicability of purely declarative and not executable speciﬁca-
tions discussed in Sect. 2 leads us to deﬁne Executable Abstract Programs as
abstract and executable pseudo-code. To complete this deﬁnition two things must
be deﬁned:

the abstract objects, properties and relations—the abstract states—Executa-
ble Abstract Programs operate on,
the abstract operations (their form and their computational meaning) that
can be executed on those objects and form the pseudo-code.

Abstract states. Z made an appropriate proposal for the deﬁnition of ab-
stract states: an abstract state is given by a set U together with a ﬁnite number
of functions and relations deﬁned on elements of U .5 In mathematics they ap-
pear as models of theories, where the interest is to ﬁnd statements that are true
in a model. In logic they appear as Tarski structures and serve to semantically
interpret formulae of ﬁrst-order predicate logic (formalizations of statements).
The models of mathematical theories and Tarski structures are static, and so are
the abstract data types in traditional Z speciﬁcations. What is needed for com-
puting is a dynamic view of abstract states, i.e. of structures that evolve due
to the application of operations—namely the pseudo-code operations deﬁned
below—to some of their objects, functions and relations.

Pseudo-code components. An appropriate deﬁnition of abstract opera-
tions pseudo-code executes on elements of any state should directly reﬂect the
dynamic change of the value of the involved objects, described by relational or
functional terms, say change of the value of a function f for arguments t1, . . . , tn
to the value of a term t. This is what the fundamental computational

Assignment Operation:

f (t1, . . . , tn ) := t

does, abstractly for any terms and functions in any given state. This includes as
special case the usual assignment of a value v to an individual variable x (viewed
as 0-ary dynamic function) in programming languages, denoted x := v .

The assignment operation forms the basis of the following inductive deﬁnition
of six further kinds of abstract pseudo-code operations. Software practitioners
know these operations: they use them in their daily work with a well-known intu-
itive computational meaning that has a simple recursive deﬁnition (see [22,16])
we do not repeat here.

Bounded Parallel and Guarded Operations:

a bounded parallel operation

par (Op1, . . . , Opn )

executing simultaneously ﬁnitely many already inductively deﬁned opera-
tions Op1, . . . , Opn ; the term ‘bounded’ refers to the fact that the number
of simultaneously to be executed operations Opi is bounded by the parallel
operation.6

5 For notational simplicity but without loss of generality we represent relations P by
their characteristic predicate CP so that an atomic formula P (x1, . . . , xn ) is viewed
as an equation CP (x1, . . . , xn ) = true and states are given by a set U together with
ﬁnitely many functions deﬁned on elements of U .

6 The par construct breaks with the prevailing sequential tradition of executing in-
structions one after the other. It turned out that the par construct helps to avoid any
semantically irrelevant execution order, as for example in the Swap(a, b) operation
par (a := b, b := a). Oﬀering a parallel operator to describe simultaneous instead of
sequential execution helps to make independencies explicit that may become useful
for parallel implementations.

a guarded (also called conditional) operation

if α then Op

where α is a Boolean combination of equations between ﬁrst-order logic
terms and Op is an already inductively deﬁned operation.

Call Operations7:

a call-by-value operation

let x = t in Op

where Op is an already inductively deﬁned operation where x may occur and
t is a term,8
a call-by-reference operation (also known as ‘call-by-name’)

Op(t1, . . . , tn )

to trigger the execution of an instance (with terms t1, . . . , tn ) of an opera-
tiondeﬁned by a declaration of the form Op(x1, . . . , xn ) = Q, where Q is an
already inductively deﬁned operation.

Logic Operations choose / forall:
an unbounded9 parallel operation

forall x with α do Op,

where α is an arbitrary (usually ﬁrst-order) condition and Op is an already
inductively deﬁned operation where x may occur,
an unbounded choice operation

choose x with α do Op

to describe non-deterministic behaviour,10 where α is an arbitrary (usually
ﬁrst-order) condition and Op is an already inductively deﬁned operation
where x may occur.

7 These two operations support the composition of complex operations out of simpler
ones. They are deﬁnable in terms of sequential operations and substitution but for
pragmatic reasons are included as basic operations.

8 This construct is also written with x = t do Op.
9 The term ‘unbounded’ refers to the fact that the number of elements x involved in
the Operation is not bounded by the size of the program but by the possibly inﬁnite
set of elements satisfying α for which the Operation is executed.

10 The choose operator is typically used to abstract from particular scheduling mech-
anisms when selecting an element to execute an operation. Similarly to the par
operation, choose helps to make it explicit (and thereby separately reﬁnable by dif-
ferent selection strategies) when any execution order for the possible choices yields
the desired behavioural eﬀect.

If one works in a special application domain, it is often an advantage to add
to these seven constructs some fundamental domain-speciﬁc operations with ap-
propriately described behavioural meaning, thereby turning Executable Abstract
Programs into a customized Domain-Speciﬁc Language (DSL).

Abstract State Machines. Each of the above seven general pseudo-code oper-
ations describes an Abstract State Machine (ASM [16,22]). Therefore, we identify
Executable Abstract Programs with ASMs. For the formal deﬁnition of the intu-
itive semantics of ASMs explained above, we refer to the textbooks and mention
here only that multi-agent ASMs—any ﬁnite set of agents each equipped with
a pseudo-code operation as its program (called also ASM rule)—are reactive
systems where each single-agent component ASM executes a loop of its rule.

Since the late 1980s, the operations listed above have been used with success
to faithfully model all kinds of computational systems,11 which highlighted the
practical industrial-strength usefulness of these Abstract Executable Programs.
Epistemological side remark. The operations also have an interesting
epistemological property, more speciﬁcally concerning the concept of algorithms.
Let PGA (standing for Parallel Guarded Assignment machine) denote
ASMs one can deﬁne applying only assignment, bounded parallel and guarded
operations. PGAs characterize ‘sequential algorithms’ in the sense of the ax-
iomatic description of the concept in [36].12 The characterization implies that
PGA operations have a simple normal form, namely par (Op1, . . . , Opn ), where
each Opi is a conditional operation of form if condi then assigni with guard
condi and an assignment operation assigni . Other classes S of computational
systems—synchronous parallel [32], concurrent (reactive) [20], recursive [21],
reﬂective [40], etc.—could be characterized in terms of corresponding classes
ASM (S) of ASMs, deﬁned by constraints on their states and rules. More pre-
cisely, an axiomatic machine-independent deﬁnition Def (S) of elements of S is
provided together with a deﬁnition of a class ASM (S) of ASMs and a proof that
a) every machine M in ASM (S) satisﬁes the axioms Def (S), and b) for every
system that satisﬁes the axioms Def (S) its runs can be simulated step-by-step
by the runs of a corresponding ASM in ASM (S).

Note that the combination of abstractness with executability is an intellectual
concept of performing runs of state changes by applying in each step abstract
operations to abstract objects; this run concept ﬁts a computational mindset
and becomes a purely mechanical feature by an appropriate implementation
(typically involving some reﬁnement steps, see Sect. 3.3 below) that translates
abstract operations into concrete physical machine operations.

Before explaining how such a practical reﬁnement relation supports an eﬃ-
cient code documentation, let us consider some main reasons for the desirability
of the executability of abstract models.

11 See [10] for an early survey (until 2003) and for recent work https://abz-conf.

org/method/asm/ and [16].

12 As a result, in the literature PGAs are called sequential ASMs although their deﬁni-
tion invites to think in terms of parallel execution wherever behaviourally possible.

3.2 Reasons for Executability

There are many reasons to require the executability of abstract programs. A
pragmatic one is that a program that runs ﬁts the computational mind of the
engineers; not surprisingly, today a large community of practitioners use ex-
ecutable UML [46] for software speciﬁcations.13 We mention here only three
more reasons that are related to the documentation issue.

A practical reason is due to the fact that the requirements may be given
only in terms of scenarios, describing example behaviours the code is expected
to handle. As an example we can mention the industrial FALKO project [15],
where the requirements for a railway timetable validation and construction pro-
gram were given by a set of concrete schedules and data of train runs in two
major German local transportation areas; the goal was to design and implement
the railway process model component in such a way that it could handle the sce-
narios indicated. Various ASM models were built and extensively tested using
the ASM Workbench [29] to run the scenarios before compiling the ﬁnal model
using an Asm2C++ compiler [57]. The ﬁnal ASM model was documented as a
precise model of the requirements and as an abstract model of the C++ code.
This allowed us to reuse the ASM model when a change request appeared: we
reﬁned the model to integrate the additional requirement and recompiled the
new model so that the new code was again in sync with the reﬁned requirements
model. In such maintenance and change usage of models (not of the ﬁnal code)
it is important, as one reviewer observed, that the generated code is ok as gener-
ated, without need of any further ‘improvements’ (‘optimizations’). The program
worked without failure for years in the Vienna local transportation system, and
no maintenance cost was incurred.

A second reason for executability of abstract programs is to use them for rapid
prototyping, i.e. as prototypical or as reference implementation of a system. As
recent example we can point to the well-known Subject-oriented Business Process
Modeling (S-BPM) approach where the ASM interpreter CoreASM [27] is used
for a reference implementation [3,4] of an industrial-strength workﬂow engine
programmed in C # (see [47, p. 298]).

A third, and perhaps the most important, methodological reason for exe-
cutability of abstract programs is that it provides a basis for early correctness
checks by testing (validation), long before reaching the detailed level of compi-
lable code. It is well-known that abstraction helps to ﬁnd conceptual problems
that are more diﬃcult to detect in compiled code and typically remain unrec-
ognized by standard debugging techniques. Executability helps to document at
a high level of abstraction the conceptual role of dynamic concepts. This holds
in full generality and is well illustrated by an example from a famous author’s
hand, where a well-known Termination Detection Protocol was developed “to
demonstrate how the algorithm can be derived in a number of steps” [31]. When
this algorithm was chosen in a Dagstuhl seminar14 for a formalization test with

13 ASMs add rigour to UML notations, see [52,53,44,43].
14 Seminar 13372 on “Integration of Tools for Rigorous Software Construction and

Analysis”, 2013.

various formal methods, it turned out that exactly the operational character of
the ASM model [35], which permitted to run it in CoreASM [27] (or in ASMeta
[2]), revealed a certain number of problems concerning the correctness of the
algorithm; typically these were hidden assumptions that also other declarative
speciﬁcations (produced during the seminar) made without noticing.15

Validation of Ground Models An important subcase of model validation
concerns what we call ground models [11]. These models constitute a precise
and complete description of the requirements (and of the domain assumptions
the software developers can rely upon), i.e. of the system behaviour as seen at
the level of abstraction of the application domain. Thus, a ground model ex-
plains how the intended system behaviour “relates to the aﬀairs of the world it
helps to handle” [49, p. 254]. By this (epistemological, not formal!) deﬁnition,
ground models cannot be proved (in the mathematical sense) to be correct and
complete, given that they represent the only initial precise description of the
requirements. But inspection can help provide conﬁdence in the model’s cor-
rectness and completeness—if the model is formulated in terms both parties
understand: the application domain experts and the software designers.16

This comprehensibility of ground models implies that the language in which
they are formulated must embrace a most general notion of state and state
change (‘abstraction’ concept) so that the inspection can rely upon a direct (in
Aristotelian terms an evident) correspondence between the application domain
real-world-view and the ground model (i.e. the application domain) concepts. A
reviewer pointed out a to-be-mentioned instance where such a correspondence
appears: when domain features or concepts are modeled using (hierarchies of)
types or classes, these types and classes do appear in the ground model. A
characteristic example are the various submodels of the ground model ASM
Java deﬁned in [22]; notably, most of their description is about static features
concerning types, classes and their structural (hierarchical) relations, the crucial
dynamic features constitute only a small part of the entire abstract executable
ASM model. In the concurrent ASM JavaThread (where every agent executes
an instance of the ASM Java) the universe Thread represents the domain of
objects that belong to the Java class Thread. In a recent doctoral dissertation
[51, Ch.5] a new ASM construct is described and implemented that allows one
to deﬁne a new type abstraction by specifying a signature-and-rule pair; this
permits to modularize ASMs.

Furthermore, for validation purposes the inspection process must be sup-
ported by the possibility to run the ground model, whether intellectually or
mechanically (by some execution mechanism). ASMs satisfy this condition. The
behaviour-driven development (BDD) method [59] even advocates the use of
executable speciﬁcations to provide a common ground for application domain

15 For a detailed exposition see [16, Ch.3.2].
16 The understandability requirement is satisﬁed for ASMs by their form—the con-
structs are close to natural-language expressions—and by their natural intuitive
meaning that has a simple precise foundation, see the seven constructs in Sect. 3.1.

experts and software designers to agree on what to build.17 To play its role well,
the ground model must be fully documented because it must be in sync with the
ﬁnal code, a property that must be maintained in every implementation step.18
This leads us to explain the role of reﬁnement for documentation.

3.3 ASM Reﬁnements to Implement Abstractions

Scientiﬁc purpose of ASM reﬁnements. The idea to develop programs by a
series of reﬁnement steps is over 50 years old by now (see [63,30]). The deﬁnition
of ASM reﬁnements in [12] generalizes and simpliﬁes other (mostly syntactically
or proof-theoretically) restricted reﬁnement concepts. It exploits the operational
and abstract character of ASMs which allows the practitioner to formulate at
any level of abstraction implementation steps that introduce details for some
abstract data and, where necessary, also for some abstract operations. Among
others it includes vertical reﬁnements (implementations of some abstract data
or actions) and horizontal reﬁnements (extensions by introduction of new func-
tionality, typically involving new data and new actions). The deﬁnition of ASM
reﬁnements is made in such a way that any implementation idea can be directly
reﬂected by an ASM reﬁnement step. This close relation between an abstract pro-
gram M and a more detailed program M ∗ allows the practitioner to justify the
implementation step that led from M to M ∗ by checking that corresponding
runs of M and M ∗ are in the desired behavioural implementation correctness
relation.19

Declarative models oﬀer a special reﬁnement use. For example, a functional
deﬁnition f (x1, . . . , xn ) = t allows one to separate the interface use of f from its
implementation. However, in such a deﬁnition the data are ﬁxed. What ASM
reﬁnements add is that also the data, not only the operations, can be reﬁned
together. Program libraries for static or dynamic functions support executable
ASMs where these functions are part of the background.

Documentation role of ASM reﬁnements. When using ASMs, the jus-
tiﬁcation that an implementation step is ‘correct’—i.e. that runs of the reﬁned
machine M ∗ reﬂect the corresponding runs of the more abstract machine M
in the intended way—can be given by an experimental validation (exploiting
the executability) or by a mathematical veriﬁcation (exploiting the mathemat-
ical character of ASMs), or both. The important point is that M and M ∗ are
not throw-away products but part of the documentation of how the speciﬁc
implementation of (some of the concepts and behavioural features of) M by
M ∗ contributes to the overall implementation, namely of the requirements (as
speciﬁed in the ground model) by the to-be-developed compilable code. The

17 As observed in [50, Sect. 4.4], the ASMeta toolset oﬀers to generate C++ executable

BDD scenarios from ASM (scenario) models.

18 In successful systems, requirements and the implementing code may evolve, but each
time one set of requirements is reﬁned to one implementation, which for brevity we
call ‘ﬁnal code’.

19 See diagram 2.1 (p. 24) in [22] and the deﬁnition on p. 111 we do not repeat here.

documentation of the—in complex cases anyway stepwise20—implementation
process supports the important software engineering principles known as design-
for-change and design-for-reuse: changes can be easily obtained at any level of
abstraction the implementation went through, just change M ∗! Obviously, the
documentation of (the set or sequence of) implementation steps also facilitates
the comprehension (often called ‘readability’) and the analysis of the ﬁnal code
(if the intermediate programs are kept in sync with it). It also reduces the cost
of software maintenance. These are two pragmatic reasons that economically
justify the eﬀort—really an intellectual discipline—to keep the documentation
and in particular the relation between the ground model and the ﬁnal code con-
sistent. When evaluating the development cost, the cost for the documentation
should be compared not only with the cost for maintenance, but also with the
cost system failures may trigger: cost of downtime and recovery work, cost of
safety violations, cost of damage by security breaches, etc.

Scalability. The notion of ASM reﬁnement as expression of implementa-
tion steps proved capable of scaling to industrial-size systems, supporting the
splitting of a complex design task into the design of an (often hierarchically
structured) set of simpler, piecemeal testable or veriﬁable and reusable compo-
nents. Reﬁnement is thus a pillar of the ASM method for rigorous system design
and analysis [22,16] and via the documentation of the ground and the interme-
diate models supports design-for-change, design-for-reuse, and component-based
system engineering. To trigger the reader’s interest we mention two industrial
examples of hierarchies of implementation steps, handled (speciﬁed, tested and
veriﬁed) as ASM reﬁnements.

The ﬁrst example illustrates the use of ASMs to test and verify program-
ming language and compiler properties. In [13] (streamlined in [17]), an ASM
tree model for the ISO standard of Prolog was deﬁned by a core ASM for user-
deﬁned predicates together with successive stepwise reﬁnements by components
for control constructs, database operations, solution collecting predicates, error
handling features, and the box model for debugging.21 In [18] this machine was
further reﬁned to a stack model (with choicepoint reuse), to which successively
the following implementation steps were applied to reach the level of WAM
code22: predicate structure compilation (look-ahead optimization, switching),
clause structure compilation (sharing the continuation stack), term structure
compilation (heap, push-down list, uniﬁcation, putting, getting, substitution and
trail stack for bindings, environment trimming, last call optimization), and WAM
(temporary variable optimizations and cut). For every reﬁnement step a precise
formulation of what its correctness means was given and was proven in [18] to

20 No work is done twice, every reﬁnement step describes a concrete implementation

step

21 In [41,42] the world-wide ﬁrst machine to physically execute sequential ASMs was
implemented in Prolog and extended in [26] by a stream-based communication par-
allelism for a time- and security-critical coal mining application in Germany. The
same year D. Bowen [24] implemented B¨orger’s Prolog model in [8] and used it at
Quintus for experiments.

22 https://en.wikipedia.org/wiki/Warren_Abstract_Machine

hold. Later this proof was mechanically veriﬁed using the KIV theorem prover
[54,55]. However, such a mechanical veriﬁcation comes at a cost. A software en-
gineer may well be able to ‘justify’ his design steps by appropriate (possibly
mathematical) arguments, but turning them into machine-supported proofs in
some logic may need a deep expertise with the underlying (implementation of)
logic and therefore require help from a logician or mechanical theorem proving
specialist. For example, the work in [18] to reﬁne the given Prolog speciﬁcation to
WAM code and to mathematically prove the correctness of the reﬁnement steps
took 6 person-months, whereas the reﬁnement to KIV took 24 person-months
of work. This example shows that, from the engineering point of view, for such
a complex enterprise it is better to separate the two steps involved: software
engineers design and verify the system (here the models for Prolog, the WAM
and the compiler), while veriﬁcation experts enrich the speciﬁcation and proof
steps with those details the prover needs to know to handle the proofs.

The second example is about the reuse of ASMs. The Prolog and WAM
ASMs in [17,18] were reused to deﬁne interpreters for various other logic pro-
gramming languages, including IBM’s languages PROTOS-L [7,6] and CLP (R)
[19] (see [22, p. 346-347] for more references). In [62] operational models for Java
and for the JVM were developed by stepwise reﬁnement23 together with a step-
wise deﬁned and proven-to-be-correct compilation scheme of Java programs to
JVM bytecode. These interpreters come with executable AsmGofer [56,58] ver-
sions that have been extensively used for testing.24 By comparing test runs of
the ASMs (for Java, the compiler and the JVM) with runs of Sun’s machines, we
discovered various bugs, all of which were reported to and corrected by Sun.25
The Java model was reused, on the request of Microsoft Research Cambridge, to
deﬁne the ECMA semantics of C # (see [14]) and later to deﬁne an ASM model
for the semantics of an object-oriented programming language of which both
Java and C # are reﬁnement instances, see [23].

For numerous other examples of hierarchies of stepwise-reﬁned executable

ASMs see [22,16] and https://abz-conf.org/method/asm/.

Tool support. ASM reﬁnement chains can be documented using some stan-
dard Version Control (VC) system in combination with an appropriate ASM
editor and a cooperative work supporting tool. VC systems provide sequences
of backtrackable project states. A project-history-focussed version management
can be enhanced by taking precise behavioural criteria into account: deﬁne the
project’s ground model and each ASM reﬁnement as a separate version. Then
possible fork (and correspondingly merge) points document diﬀerent implemen-
tation steps of some intermediate machines, at some intermediate level of ab-
straction. This allows the developers to move between high-level and low-level

23 The deﬁnition works even instructionwise and can be used in connection with soft-

ware product lines, as has been observed in [5].

24 AsmGofer has been used also in an industrial ASIC design and veriﬁcation project

at Siemens, together with a compiler from ASM to VHDL.

25 Practitioners may be interested to see some notable details to be found in the ap-

pendix.

system views, in both directions along the reﬁnement hierarchy, to examine
details, to operate changes, to continue the development with further implemen-
tation steps, etc. Such a use of VC produces also a structural big-picture of the
behavioural interdependence of the components of the system under construc-
tion.

Also “Agile methods” and “Extreme Programming” (XP) can be used and
enhanced, deﬁning the incremental ‘intermediate’ programs (read: still abstract
but executable programs) by a practical but rigorously analysable reﬁnement
concept (‘practical speciﬁcations of design decisions’), as oﬀered by ASMs and
their reﬁnement notion. As a result the program increments are linked in a
behaviourally consistent way one can verify (mathematically) and validate (ex-
perimentally by testing methods).

Iterative reﬁnement character. It is a well-known experience that the
development process that leads from the requirements (read: a ground model)
to compilable code is by no means linear.

Fig. 1. Iterative Character of ASM Development Method

An implementation step may reveal that some condition is missing or not
stated clearly enough in the requirements. Or the customer formulates a new
requirement to be included, a phenomenon known as evolution of requirements
(see the FALKO example mentioned in Sect. 3.2). In such cases the customer
must be involved to clarify the issue, leading to a modiﬁed ground model and
corresponding changes in some reﬁned models that are aﬀected by the change;
the documentation serves to precisely identify the locations involved and to keep

TESTCASESdomainstransition systemstepwiserefinementreflectingdesigndynamic functionsexternal functionsdecisionsmanualmechanizedPROVERadding assumptionsadding definitionsSIMULATORusing data fromapplication domainVerificationApplication Domain KnowledgeGround ModelInformal RequirementsCodeValidation+track of the additions or changes, instead of erasing after the discussion what
had been written on the whiteboard. The same can happen with respect to
intermediate levels of implementation and makes the programs resilient. The
back and forth is needed to keep the intermediate implementation models in
sync with the ﬁnal compilable code. This does not mean that a speciﬁcation is
written twice, it means that during the development process it turned out that
the understanding of what to build was not complete and had to be made more
precise. Thus, the documentation helps detect mistakes as early as possible.

To conclude we illustrate by Fig. 1 (taken from [22]26) the iterative, not
necessarily linear, character of developing a system by stepwise implementation.
Stepwise reﬁnements establish a kind of ﬂight of stairs that enables walking
between diﬀerent levels of abstraction; a typical reuse application creates a new
branch at the level of abstraction where the change is formulated. Only very
skilled tightrope walkers can ﬂy between multiple levels of abstraction without
securing their balance via some concrete and well-documented abstraction level
where to put one’s feet for the dance from requirements to binary code.

4 Conclusion

We have explained why Abstract State Machines, a rigorous form of Executable
Abstract Programs, can help the practitioner in his daily work to rigorously
formulate and document one by one all design and implementation decisions that
bridge the gap between requirements and eﬃciently runnable code. To evaluate
the quality of the documentation produced by the stepwise design we refer the
reader to the indicated projects. More of that can be found on the ASM website
https://abz-conf.org/method/asm/ and in the bibliography of the two books
[22,16]. We would be interested if somebody knowledgeable about the uniﬁed
speciﬁcation/modeling and programming approach [25] compares it with the
ASM method.

Acknowledgment. Thanks to the following colleagues who generously helped
with critical comments and suggestions: Don Batory, Paolo Dini, Flavio Fer-
rarotti, Albert Fleischmann, Uwe Gl¨asser, Philipp Paulweber, Alexander Raschke,
Elvinia Riccobene, Klaus-Dieter Schewe and two anonymous referees who ac-
cepted the paper for presentation in and publication by the International Sym-
posium On Leveraging Applications of Formal Methods, Veriﬁcation and Vali-
dation (ISoLA2022).

5 Appendix: Mixing Runs of AsmGofer/Sun Machines

Figure 2 (taken from [62]27) shows how the AsmGofer machines for Java/JVM
(i.e. mechanically executable reﬁnements of the ground models for Java and the
JVM developed in the Jbook [62]) can be run together with Sun’s JVM, using
both our and Sun’s compiler.

26 © 2003 Springer-Verlag Berlin Heidelberg, reused with permission.
27 © 2001 Springer-Verlag Berlin Heidelberg, reused with permission.

Fig. 2. AsmGofer and Sun Machines for Java/JVM

For better readability we adopted a textual representation of the ASMs, using
converters Jasmin (from textual to binary) and BCEL (from binary to textual).

Java-ASM reads and executes Java source code (suﬃx .java). Sun has no
counterpart for this ground model. We submitted it to a careful inspection,
using the Java/JVM manuals as description of the requirements, and added
an extensive validation by examples whenever an unclear situation showed
up.
Compiler-ASM compiles from source code .java to bytecode .j in Jasmin
syntax (textual representation).
Sun-Compiler generates .class ﬁles (binary class ﬁle representation).
JVM-ASM resp.Sun-JVM read input in Jasmin syntax resp. class ﬁles.

For the validation of the AsmGofer machines and our compiler, using the con-
verters we could mix the diﬀerent machines and compilers and compare the
runs. Any inconsistency revealed by the comparison showed a bug either in our
deﬁnitions or in Sun’s code.

References

1. K. R. Apt and T. Hoare. Edsger W. Dijkstra: a commemoration. CoRR,

abs/2104.03392, 2021.

Compiler−ASMSun−CompilerJasmin.j.class.javaSun−JVMJava−ASMJVM−ASMBCEL2. The asmeta tool set. https://asmeta.github.io/, since 2006.
3. A.Wolski, S.Borgert, and L.Heuser. A CoreASM based reference implementation
for subject oriented business process management execution semantics. In S.Betz,
M.Elstermann, and M.Lederer, editors, S-BPM ONE 2019. Association of Com-
puting Machinery (ACM Digital Library), 2019.

4. A.Wolski, S.Borgert, and L.Heuser. An extended subject-oriented business pro-
cess management execution semantics. In S.Betz, M.Elstermann, and M.Lederer,
editors, S-BPM ONE 2019. Association of Computing Machinery (ACM Digital
Library), 2019.

5. D. Batory and E. B¨orger. Modularizing theorems for software product lines: The

Jbook case study. J. Universal Computer Science, 14(12):2059–2082, 2008.

6. C. Beierle and E. B¨orger. Reﬁnement of a typed WAM extension by polymorphic

order-sorted types. Formal Aspects of Computing, 8(5):539–564, 1996.

7. C. Beierle and E. B¨orger. Speciﬁcation and correctness proof of a WAM extension
with abstract type constraints. Formal Aspects of Computing, 8(4):428–462, 1996.
8. E. B¨orger. A logical operational semantics for full Prolog. Part I: Selection core
and control. In E. B¨orger, H. Kleine B¨uning, M. M. Richter, and W. Sch¨onfeld,
editors, CSL’89. 3rd Workshop on Computer Science Logic, volume 440 of Lecture
Notes in Computer Science, pages 36–64. Springer-Verlag, 1990.

9. E. B¨orger. Review of E. W. Dijkstra and C. S. Scholten Predicate Calculus and
Program Semantics (Springer-Verlag 1989). Science of Computer Programming,
23:1–11, 1994. An abridged version appeared in J. Symbolic Logic 59:673–678,
1994.

10. E. B¨orger. The origins and the development of the ASM method for high-level
system design and analysis. J. Universal Computer Science, 8(1):2–74, 2002.
11. E. B¨orger. The ASM ground model method as a foundation of requirements engi-
neering. In N.Dershowitz, editor, Veriﬁcation: Theory and Practice, volume 2772
of LNCS, pages 145–160. Springer-Verlag, 2003.

12. E. B¨orger. The ASM reﬁnement method. Formal Aspects of Computing, 15:237–

257, 2003.

13. E. B¨orger and K. D¨assler. Prolog: DIN papers for discussion.

ISO/IEC JTCI
SC22 WG17 Prolog Standardization Document 58, National Physical Laboratory,
Middlesex, England, 1990.

14. E. B¨orger, G. Fruja, V. Gervasi, and R. St¨ark. A high-level modular deﬁnition of
the semantics of C#. Theoretical Computer Science, 336(2–3):235–284, 2005.
15. E. B¨orger, P. P¨appinghaus, and J. Schmid. Report on a practical application of
ASMs in software design. In Y. Gurevich, P. Kutter, M. Odersky, and L.Thiele,
editors, Abstract State Machines: Theory and Applications, volume 1912 of Lecture
Notes in Computer Science, pages 361–366. Springer-Verlag, 2000.

16. E. B¨orger and A. Raschke. Modeling Companion for Software Practitioners.
Springer, 2018. ISBN 978-3-662-56641-1. See http://modelingbook.informatik.
uni-ulm.de.

17. E. B¨orger and D. Rosenzweig. A mathematical deﬁnition of full Prolog. Science

of Computer Programming, 24:249–286, 1995.

18. E. B¨orger and D. Rosenzweig. The WAM – deﬁnition and compiler correctness.
In C. Beierle and L. Pl¨umer, editors, Logic Programming: Formal Methods and
Practical Applications, volume 11 of Studies in Computer Science and Artiﬁcial
Intelligence, chapter 2, pages 20–90. North-Holland, 1995.

19. E. B¨orger and R. Salamone. CLAM speciﬁcation for provably correct compilation
of CLP(R) programs. In E. B¨orger, editor, Speciﬁcation and Validation Methods,
pages 97–130. Oxford University Press, 1995.

20. E. B¨orger and K.-D. Schewe. Concurrent Abstract State Machines. Acta
http://link.springer.com/article/10.1007/s00236-
Notable
see

Informatica, 53(5), 2016.
015-0249-7,
Article
in
www.computingreviews.com/recommend/bestof/notableitems.cfm?bestYear=2016.

as
COMPUTING,

DOI
ACM 21th

10.1007/s00236-015-0249-7.

BEST OF

Annual

Listed

21. E. B¨orger and K.-D. Schewe. A behavioral theory of recursive algorithms. Funda-
menta Informaticae, 177(1):1–37, 2020. DOI 10.3233/FI-2020-1915. A preliminary
version is available at http://arxiv.org/abs/2001.01862.

22. E. B¨orger and R. F. St¨ark. Abstract State Machines. A Method for High-Level

System Design and Analysis. Springer, 2003.

23. E. B¨orger and R. F. St¨ark. Exploiting Abstraction for Speciﬁcation Reuse. The
Java/C# Case Study. In M. Bonsangue, editor, Formal Methods for Components
and Objects: Second International Symposium (FMCO 2003 Leiden), volume 3188
of Lecture Notes in Computer Science (ISBN 3-540-22942-6, ISSN 0302-9743),
pages 42–76. Springer, 2004. .

24. D. Bowen. Implementation at Quintus of B¨orger’s Prolog ASM. Personal Commu-
nication to B¨orger at Quintus in Palo Alto on November 5 and e-mail of November
11, 1990.

25. M. Broy, K. Havelund, and R. Kumar. Towards a uniﬁed view of modeling and

programming. In ISoLA, 2016.

26. W. Burgard, A. B. Cremers, D. Fox, M. Heidelbach, A. M. Kappel, and
S. L¨uttringhaus-Kappel. Knowledge-enhanced CO-monitoring in coal mines. In
Proc. Int. Conf. on Industrial and Engineering Applications of Artiﬁcial Intelli-
gence and Expert Systems (IEA-AIE), pages 511–521, Fukuoka, Japan, 4–7 June
1996.

27. The CoreASM Project.

https://www.uni-ulm.de/coreasm/ and https://

github.com/coreasm/, since 2005.

28. J. Davies and J. Woodcock. Using Z: Speciﬁcation, Reﬁnement, and Proof. Prentice

Hal, 1996.

29. G. Del Castillo. The ASM Workbench. A Tool Environment for Computer-Aided
Analysis and Validation of Abstract State Machine Models. PhD thesis, Universit¨at
Paderborn, Germany, 2001.

30. E. W. Dijkstra. Notes on structured programming. In O.-J. Dahl, E. W. Dijkstra,
and C. A. R. Hoare, editors, Structured Programming, pages 1–82. Academic Press,
1972.

31. E. W. Dijkstra, W.H.J.Feijen, and A. van Gasteren. Derivation of a termination
detection algorithm for distributed computations. Information Processing Letters,
16:217–219, 1983. Known also as EWD 840.

32. F. Ferrarotti, K.-D. Schewe, L. Tec, and Q. Wang. A new thesis concerning syn-
chronised parallel computing – simpliﬁed parallel ASM thesis. Theor. Comp. Sci.,
649:25–53, 2016.

33. F.Ferrarotti, K.-D. Schewe, L. Tec, and Q. Wang. A complete logic for database

abstract state machines1. Logic Journal of the IGPL, 25(5):700–740, 2017.

34. F.Ferrarotti, K.-D. Schewe, L. Tec, and Q. Wang. A unifying logic for non-
deterministic, parallel and concurrent Abstract State Machines. Annals of Math-
ematics and Artiﬁcial Intelligence, 83(3-4):321–349, 2018.

35. V. Gervasi and E. Riccobene.

From English to ASM: On the process of
deriving a formal speciﬁcation from a natural
In Integra-
language one.
tion of Tools for Rigorous Software Construction and Analysis, volume 3(9)
of Dagstuhl Report, pages 85–90, 2014. Dagstuhl Seminar 13372 organized

by Uwe Gl¨asser, Stefan Hallerstede, Michael Leuschel, Elvinia Riccobene,
08.–13.9.2013. DOI: 10.4230/DagRep.3.9.74, URN: urn:nbn:de:0030-drops-43584,
URL: http://drops.dagstuhl.de/opus/volltexte/2014/4358/.

36. Y. Gurevich. Sequential Abstract State Machines capture sequential algorithms.

ACM Trans. Computational Logic, 1(1):77–111, July 2000.

37. J. A. Hall. Taking Z seriously.

In ZUM’97, volume 1212 of Lecture Notes in

Computer Science, pages 89–91. Springer-Verlag, 1997.

38. D. Harel and A. Pnueli. On the development of reactive systems. In K. R. Apt,
editor, Logics and models of concurrent systems, pages 477–498. Springer-Verlag,
1985.

39. I. J. Hayes and C. Jones. Speciﬁcations are not (necessarily) executable. Software
Engineering Journal, 4(6):330 –339, 1989. DOI: 10.1049/sej.1989.0045 , Print ISSN
0268-6961, Online ISSN 2053-910X.

40. K.-D.Schewe and F.Ferrarotti. Behavioural theory of reﬂective algorithms i: Re-

ﬂective sequential algorithms. arXiv:2001.01873.

41. A. M. Kappel. Implementation of dynamic algebras with an application to Prolog.

Diplom thesis, Computer Science Dept., Universit¨at Dortmund, Germany, 1990.

42. A. M. Kappel.

In
A. Voronkov, editor, Logic Programming and Automated Reasoning, volume 698
of Lecture Notes in Artiﬁcial Intelligence, pages 229–240. Springer-Verlag, 1993.

Executable speciﬁcations based on dynamic algebras.

43. J. Kohlmeyer. Eine formale Semantik f¨ur die Verkn¨upfung von Verhaltensbeschrei-

bungen in der UML 2. PhD thesis, Universit¨at Ulm (Germany), 2009.

44. J. Kohlmeyer and W. Guttmann. Unifying the semantics of uml 2 state, activity
and interaction diagrams. In A. Pnueli, I. Virbitskaite, and A. Voronkov, editors,
7th International Andrei Ershov Memorial Conference (Perspectives of Systems
Informatics 2009), volume 5947 of Lecture Notes in Computer Science, pages 206–
217. Springer, 2010.

45. L.Lamport. TLZ.

In J. P. Bowen and J. A. Hall, editors, Z User Workshop,

Cambridge 1994, pages 267–268, London, 1994. Springer London.

46. S. Mellor and M. J. Balcer. Executable UML: A Foundation for Model-Driven

Architecture. Addison-Wesley, 2002.

47. M.Elstermann, A.Wolski, A.Fleischmann, C.Stary, and S.Borgert. The combined
use of the web ontology language (OWL) and Abstract Sate Machines (ASM) for
In A.Raschke,
the deﬁnition of a speciﬁcation language for business processes.
E.Riccobene, and K.-D.Schewe, editors, Logic, Computation and Rigorous Meth-
ods: Essays Dedicated to Egon B¨orger on the Occasion of His 75th Birthday, pages
283–300, Cham, 2021. Springer International Publishing.

48. S. Nanchen and R. F. St¨ark. A logic for secure memory access of Abstract State

Machines. Theoretical Computer Science, 336(2-3):311–342, 2005.

49. P. Naur. Programming as theory building. Microprocessing and Microprogram-

ming, 15:253–261, 1985.

50. P.Arcaini, A.Bombarda, S.Bonfanti, A.Gargantini, E.Riccobene, and P.Scandurra.
The ASMeta approach to safety assurance of software systems.
In A.Raschke,
E.Riccobene, and K.-D.Schewe, editors, Logic, Computation and Rigorous Meth-
ods: Essays Dedicated to Egon B¨orger on the Occasion of His 75th Birthday, pages
215–238, Cham, 2021. Springer International Publishing.

51. P.Paulweber. The evolving of CASM: Modern Compiler Engineering and Empir-
ical Guided Language Design for a Rigorous State-Based Method. PhD thesis,
Universit¨at Wien, 2022.

52. S. Sarstedt. Semantic Foundation and Tool Support for Model-Driven Development

with UML 2 Activity Diagrams. PhD thesis, Universit¨at Ulm, 2006.

53. S. Sarstedt and W. Guttmann. An ASM semantics of token ﬂow in UML 2 activity
diagrams. In Ershov Memorial Conference, volume 4378 of LNCS, pages 349–362.
Springer-Verlag, 2007.

54. G. Schellhorn and W. Ahrendt. Reasoning about Abstract State Machines: The

WAM case study. J. Universal Computer Science, 3(4):377–413, 1997.

55. G. Schellhorn and W. Ahrendt. The WAM case study: Verifying compiler cor-
rectness for Prolog with KIV.
In W. Bibel and P. Schmitt, editors, Automated
Deduction – A Basis for Applications, volume III: Applications, pages 165–194.
Kluwer Academic Publishers, 1998.

56. J. Schmid. Executing ASM speciﬁcations with AsmGofer. Web pages at https:

//tydo.eu/AsmGofer.

57. J. Schmid. Compiling Abstract State Machines to C++. J. Universal Computer

Science, 7(11):1069–1088, 2001.

58. J. Schmid. Reﬁnement and Implementation Techniques for Abstract State Ma-
chines. PhD thesis, University of Ulm, Germany, 2002. Electronic version available
at http://www.tydo.org/files/papers/dissJS.pdf.

59. J. Smart. BDD in Action: Behavior-Driven Development for the Whole Software

Lifecycle. Manning Publications, 2014. ISBN 9781617291654.

60. J. Spivey. The Z Notation, Reference Manual. Prentice Hall International, 1992.

2nd edition,.

61. R. F. St¨ark and S. Nanchen. A logic for Abstract State Machines. J. Universal

Computer Science, 7(11):981–1006, 2001.

62. R. F. St¨ark, J. Schmid, and E. B¨orger. Java and the Java Virtual Machine: Deﬁ-

nition, Veriﬁcation, Validation. Springer-Verlag, 2001.

63. N. Wirth. Program development by stepwise reﬁnement. Commun. ACM, 14(4),

1971.

