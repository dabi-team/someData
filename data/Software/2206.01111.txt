2
2
0
2

n
u
J

2

]
E
S
.
s
c
[

1
v
1
1
1
1
0
.
6
0
2
2
:
v
i
X
r
a

MorphQ: Metamorphic Testing of Quantum Computing
Platforms

Matteo Paltenghi
University of Stuttgart
Department of Computer Science
Germany
mattepalte@live.it

Michael Pradel
University of Stuttgart
Department of Computer Science
Germany
michael@binaervarianz.de

ABSTRACT
As quantum computing is becoming increasingly popular, the under-
lying quantum computing platforms are growing both in ability and
complexity. This growth may cause bugs in the platforms, which
hinders the adoption of quantum computing. Unfortunately, testing
quantum computing platforms is challenging due to the relatively
small number of existing quantum programs and because of the
oracle problem, i.e., a lack of specifications of the expected behavior
of programs. This paper presents MorphQ, the first metamorphic
testing approach for quantum computing platforms. Our two key
contributions are (i) a program generator that creates a large and
diverse set of valid (i.e., non-crashing) quantum programs, and
(ii) set of program transformations that exploit quantum-specific
metamorphic relationships to alleviate the oracle problem. Evalu-
ating the approach by testing the popular Qiskit platform shows
that the approach creates over 50k program pairs within two days,
many of which expose crashes. Inspecting the crashes, we find
twelve bugs, eight of which have already been confirmed. MorphQ
widens the slim portfolio of testing techniques of quantum comput-
ing platforms, helping to create a reliable software stack for this
increasingly important field.

1 INTRODUCTION
Quantum software engineering is seeing an increasing interest from
the research community and industry thanks to the continuous
hardware improvements. Quantum computing platforms, such as
Qiskit by IBM, Circ by Google, and Q# by Microsoft, are for this
emerging field what traditional compilers and execution environ-
ments are for traditional programs. Ensuring the correctness of
these platforms is crucial for the correct execution of quantum
programs, whereas bugs in the platforms may undermine other
advancements, such as in algorithms and hardware. A recent empir-
ical study [21] has shown that quantum computing platforms are
still plagued with bugs, many of which are due to quantum-specific
bug patterns not present in traditional software. The increasing
importance of these platforms hence calls for automated testing
techniques targeted at them.

Effectively testing quantum computing platforms currently faces
two important challenges. (C1) The first challenge is that there
currently are only relatively few quantum programs, as the field
is emerging and developers are only beginning to exploit its po-
tential. From a testing perspective, this means that test inputs are
a scarce resource. (C2) The second challenge is the well-known
oracle problem [3], i.e., the problem of not having a specification
of the expected behavior triggered by an input. In our context, the
oracle problems is about determining what behavior the execution

1

of a given quantum program should expose, which is particularly
challenging since programs are composed of low-level operations,
represented by gates, that translate to sometimes unintuitive and
highly abstract operations on the inputs.

This paper presents MorphQ, the first metamorphic testing ap-
proach targeted at quantum computing platforms. The approach
addresses challenge C1 by proposing the first automatic generator
of quantum programs. The generator combines template-based and
grammar-based code generation to produce programs that use a
diverse set of quantum gates and options for compiling and execut-
ing them. To be effective, the generation must carefully consider
domain-specific constraints typical of quantum computing, such
as not applying any operation after a measurement gate because
it would destroy the quantum state. MorphQ respects these con-
straints and generates valid programs, in the sense that they execute
without crashing.

The approach addresses challenge C2 through a novel set of ten
metamorphic transformations. Following the idea of metamorphic
testing [6, 7], these transformations change a given source program
into a follow-up program in such a way that the two programs
have an expected output relationship, e.g., that they should expose
the same behavior. If the expected output relationship does not
hold, e.g., because the follow-up program crashes or otherwise
exposes different behavior, the approach reports a warning. The
metamorphic transformations are quantum-specific. For example,
they change the order of qubits, add null-effect operations by ex-
ploiting the reversable nature of quantum computation, partition
a circuit that contains unrelated subcircuits, or change the set of
hardware gates a program is compiled to.

While testing tradition compilers has received significant at-
tention [5], we are aware of only one piece of prior work, called
QDiff [31], on automatically testing quantum computing platforms.
MorphQ conceptually differs in multiple ways. One difference is
that QDiff starts from a small set of manually written programs,
whereas MorphQ generates a large and diverse set of quantum
programs from scratch. Another difference is that QDiff is based
on differential testing that compares executions with different opti-
mization levels and backends, whereas MorphQ is the first to pro-
pose metamorphic transformations for quantum programs. Beyond
conceptual contributions, we also empirically show our approach
to complement prior work by finding bugs that previous testing
work failed to find.

Our evaluation applies MorphQ to Qiskit [1], a popular quantum
computing platform backed by IBM. Over a two-day testing period,
the approach generates, executes, and compares over 50k pairs of
quantum programs, many of which expose crashing bugs in the
platform under test. Manually inspecting a subset of the warnings

 
 
 
 
 
 
ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Paltenghi and Pradel

# Hadamard gate

# Control Not Gate

1 # Create circuit
2 circ = QuantumCircuit (2)
3 circ .h (0)
4 circ . cx (0 , 1)
5 circ . measure_all ()
6 # Transpile for simulator
7 simulator = Aer . get_backend ( ' aer_simulator ')
8 circ = transpile ( circ , simulator )
9 # Run and get counts
10 result = simulator . run ( circ , shots =1024) . result ()
11 counts = result . get_counts ( circ )
12 # output : { '00 ': 530 , '11 ': 494}

Figure 1: Example of a circuit to create entanglement.

Figure 2: Visual representation of Figure 1 (left) and example
of measurement result (right).

reported by the approach, we find and report twelve bugs. So far,
eight of them have been confirmed by the Qiskit developers. For
example, these bugs are caused by incorrectly implemented opti-
mization passes, missing support for specific kinds of programs, and
mistakes in code that exports a program to QASM, an assembly-
like language that allows for sharing quantum programs across
different platforms. Studying the relative importance of our ten
metamorphic relationships shows that each of them is involved in
triggering at least some warnings reported by MorphQ and that
applying multiple transformations in sequence is useful to detect
otherwise missed bugs.

In summary, this work makes the following contributions:

â€¢ We introduce a novel template and a grammar, which repre-
sent valid quantum programs of the popular Qiskit platform.
â€¢ We introduce a template-based and grammar-based program
generator that creates valid quantum programs to use for
testing purposes.

â€¢ We design ten quantum-specific metamorphic relationships
to enable the first metamorphic testing framework for quan-
tum computing platforms.

â€¢ We integrate our approach with the popular Qiskit platform
and provide empirical evidence that MorphQ reveals twelve
real-world, crashing bugs.

Open science. Our implementation and all experimental results

are being made freely available. 1

2 BACKGROUND ON QUANTUM

COMPUTING

Unlike classical computing, which is based on classical physics,
quantum computing exploits the laws of quantum mechanics to
perform computation. Whereas in classical computing the minimal
unit of information is a bit, which is either 0 or 1, in quantum
computing the base unit is the qubit, which can be a superposition
of 0 and 1 at the same time, representing a quantum state as |ğœ™âŸ© =
ğ›¼ |0âŸ© +ğ›½ |1âŸ©. This superposition is maintained and manipulated along
the computation and at the very last stage, each qubit is measured
and it results in either a 0 or a 1, with probability respectively ğ›¼ 2
and ğ›½2. Another important property is called entanglement, which
means that the outcome of a measurement of two or more qubits
shows some correlation.

1The code and data are available at the anonymous repo: https://anonymous.4open.
science/r/MorphQ/

2

Figure 1 shows a simple quantum program, which creates an
entanglement between two qubits. It consists of the application of
a Hadamard gate to the first qubit (line 3), which creates a super-
position in the first qubit |ğœ™âŸ© = 1âˆš
|1âŸ©, and then a control
2
not gate (line 4), which creates the entanglement between the first
and second qubits, leading to the state |ğœ“ âŸ© = 1
2 (|00âŸ© + |11âŸ©). The
sequence of gates of a program is also called a quantum circuit, or
simply circuit.

|0âŸ© + 1âˆš
2

Figure 2, on the left, shows a pictorial representation of the
program in this gate model. The figure also shows two measurement
gates, shown in black, which measure and store the result into a
classical register of two bits. Once the circuit has been defined, it is
executed for some number of shots (e.g, 1024, see line 10 of Figure 1)
to account for the probabilistic nature of quantum programs. The
execution produces a distribution of output bit-strings of two bits,
shown on the right of Figure 2. For the example program, the only
two outcomes possible are bit-strings with either both 0 or both 1.
The ability to describe and execute quantum programs is pro-
vided by a quantum computing platform. The above example is
based on Qiskit [1], open-sourced by IBM, and popular among prac-
titioners and researchers [20, 31, 39]. In Qiskit, quantum programs
are expressed using a Python API. The platform then compiles and
executes the program on a backend, i.e., either a real quantum hard-
ware or a simulator. Part of the compilation is implemented in a
transpiler, which optimizes the circuit and prepares it for the target
execution environment. Because different quantum computers offer
different hardware gates, called the gate set, the platform translates
the program to sequences of gates available on the target environ-
ment. How a program gets mapped to hardware is also influenced
by the physical connections between qubits, which are represented
in the so-called coupling map in Qiskit.

3 APPROACH
The following presents our MorphQ approach for metamorphic
testing of quantum computing platforms. We start with an overview
and the overall algorithm of the approach (Section 3.1), followed
by a description of the three main steps: program generation (Sec-
tion 3.2), applying metamorphic transformations (Section 3.3), and
comparing the behavior of program executions (Section 3.4).

3.1 Overall Algorithm
Figure 3 gives a high-level overview of MorphQ and its three main
steps. The first step is a program generator, which creates the initial

q0q12measH0100110.000.150.300.450.60Probabilities0.5100.490MorphQ: Metamorphic Testing of Quantum Computing Platforms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Algorithm 1: MorphQ Approach
Input : Program generator ğº

Metamorphic relationships ğ‘€
Behavior comparison component ğ¶
Result: Likely bug-revealing pairs ğµ of programs

1 ğµ â† âˆ…
2 while time budget ğ‘¡ğ‘ğ‘¢ğ‘‘ğ‘”ğ‘’ğ‘¡ not up do
ğ‘–ğ‘›ğ‘  â† ğº .ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’ğ‘ƒğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š();
3
ğ‘›ğ‘¡ğ‘œğ´ğ‘ğ‘ğ‘™ ğ‘¦ â† ğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘œğ‘š(1, ğ‘šğ‘ğ‘¥ğ‘€ );
ğ‘–ğ‘›ğ‘“ â† ğ‘–ğ‘›ğ‘  ;
while ğ‘›ğ‘ğ‘ğ‘ğ‘™ğ‘–ğ‘’ğ‘‘ < ğ‘›ğ‘¡ğ‘œğ´ğ‘ğ‘ğ‘™ ğ‘¦ do

6

4

5

/* STEP 1 */
/* STEP 2 */

Figure 3: Overview of our approach.

quantum programs, referred as source programs. Then by applying
a sequence of one or more metamorphic program transformations,
we derive a follow-up program that is in a specific relationship
with the source program. Finally, the third step is to execute two
quantum programs, compare their behavior, and check whether
their behavior conforms to the output relationship expected for
the input relationship. If the output relationship differs from the
expected relationship, then MorphQ reports a warning to the user.
Algorithm 1 describes how MorphQ composes the three main
steps. As input, the algorithm expects a program generator ğº, a set
of metamorphic relationships ğ‘€, and a component ğ¶ for comparing
the behavior two quantum programs. Our approach is designed as a
framework that allows for replacing and extending each component.
The main loop of the algorithm continuously generates and checks
new pairs of source and follow-up programs until running out of a
configurable time budget. After each loop iteration, both programs
are discarded, making each iteration independent from the previous
one and preventing MorphQ from mutating previously crashed
programs. Finally, the algorithm returns a set ğµ of pairs of programs
that are likely to reveal a bug in the tested quantum computing
platform.

As the first step in the main loop of the algorithm, the program
generator ğº creates a new quantum program ğ‘–ğ‘›ğ‘  using a combina-
tion of template-based and grammar-based code generation (line 3).
A â€œprogramâ€ here means source code that defines the quantum
circuit and its execution setting, e.g., the type of backend to use
or the transpilerâ€™s settings. Then, the second step of the algorithm
applies a sequence of transformations sampled from the metamor-
phic relationships ğ‘€ to create a follow-up program ğ‘–ğ‘›ğ‘“ (lines 4
to 15). Each metamorphic relationship has a precondition under
which its transformation may be applied. Most of the transforma-
tions are designed to be semantically preserving, in which case the
algorithm may continue to apply further transformations. The ap-
proach also includes two transformations that do not preserve the
semantics, because they rearrange the qubits and execute only parts
of the circuit to check some properties. Once such a transformation
gets applied, the algorithm stops applying further transformations,

7

8

9

10

11

12

13

14

15

16

17

18

ğ‘š â† ğ‘ ğ‘ğ‘šğ‘ğ‘™ğ‘’ (ğ‘€);
if ğ‘š.ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›(ğ‘–ğ‘›ğ‘“ ) then

ğ‘–ğ‘›ğ‘“ â† ğ‘š.ğ‘ğ‘ğ‘ğ‘™ğ‘¦ (ğ‘–ğ‘›ğ‘“ );
ğ‘›ğ‘ğ‘ğ‘ğ‘™ğ‘–ğ‘’ğ‘‘ â† ğ‘›ğ‘ğ‘ğ‘ğ‘™ğ‘–ğ‘’ğ‘‘ + 1;

end
if ğ‘š is not semantics-preserving then

break;

end

end
ğ‘œğ‘¢ğ‘¡ğ‘ , ğ‘œğ‘¢ğ‘¡ğ‘“ â† ğ¶.ğ‘’ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ (ğ‘–ğ‘›ğ‘ , ğ‘–ğ‘›ğ‘“ );
if ğ¶.ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘…ğ‘’ğ‘™ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(ğ‘šğ‘™ğ‘ğ‘ ğ‘¡ , ğ‘œğ‘¢ğ‘¡ğ‘ , ğ‘œğ‘¢ğ‘¡ğ‘“ ) then

/* STEP 3 */

ğµ â† ğµ âˆª {(ğ‘–ğ‘›ğ‘ , ğ‘–ğ‘›ğ‘“ )};

end

19
20 end
21 return ğµ

which has the benefit that only the last transformation determines
the expected output relationship. Finally, the third step compares
the behavior of the source program ğ‘–ğ‘›ğ‘  and the final follow-up
program ğ‘–ğ‘›ğ‘“ (lines 16 to 19). The outcome of executing a program
may be a program crash or non-crashing behavior. In the latter
case, the platform repeatedly executes the circuit and summarizes
the output into a distribution of bit-strings.

3.2 Program Generation
The first step of the approach generates quantum programs from
scratch. A naive approach to this problem might consider all ele-
ments offered by the quantum programming language, e.g., all APIs
offered by Qiskit, and combine them at random. However, such an
approach would yield mostly invalid programs that crash and do
not deeply test the platform. The reason is that quantum programs
need to follow a particular structure and consider domain-specific
constraints when combining the elements offered by the language.
The program generator in MorphQ is a combination of template-
based and grammar-based code generation. The template-based
part ensures that the created programs follow the typical structure
of quantum programs, which is necessary to reach deep into the
platforms under test. The grammar-based part is designed to cover
a diverse range of possible programs by randomly combining gates
with each other. The template and the grammar of our program
generator are based on concepts available across different quantum

3

ROUTPUT?RINPUTinsinfoutsoutfExecution & CheckBehavior0001101100011011ACBDEq0q1Exec. SettingsACBDEq0q1XXABDEExec. Settings123Program GenerationSourceFollow-UpMetamorphic TransformationESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Paltenghi and Pradel

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

# SECTION : PROLOGUE
< ALL_IMPORTS >
# SECTION : CIRCUIT
qr = QuantumRegister (< N_QUBITS > , name = ' qr ')
cr = ClassicalRegister (< N_QUBITS >, name = 'cr ')
qc = QuantumCircuit (qr , cr , name = 'qc ')
< GATE_OPS >
# SECTION : MEASUREMENT
qc . measure (qr , cr )
# SECTION : TRANSPILATION / COMPILATION
qc = transpile (qc ,

basis_gates =< TARGET_GATE_SET >,
optimization_level =< OPT_LEVEL >,
coupling_map =< COUPLING_MAP >)

# SECTION : EXECUTION
simulator = Aer . get_backend (< BACKEND_NAME >)
counts = execute (qc , backend = simulator ,

shots =< N_SHOTS >) . result () . get_counts ( qc )

Figure 4: Template to generate quantum programs.

âŸ¨GATE_OPSâŸ© ::= âŸ¨INSTRâŸ©âŸ¨EOLâŸ©âŸ¨GATE_OPSâŸ© | âŸ¨EOLâŸ©

âŸ¨INSTRâŸ© ::= âŸ¨INSTR_1QâŸ© | âŸ¨INSTR_2QâŸ© | ... | âŸ¨INSTR_5QâŸ©

âŸ¨INSTR_1QâŸ© ::= qc.append(âŸ¨GATE_1QâŸ©, qregs=[qr[âŸ¨INT âŸ©]])

âŸ¨INSTR_2QâŸ© ::= qc.append(âŸ¨GATE_2QâŸ©,
qregs=[qr[âŸ¨INT âŸ©],qr[âŸ¨INT âŸ©])

âŸ¨GATE_1QâŸ© ::= âŸ¨HGateâŸ© | âŸ¨RZGateâŸ© | ...

âŸ¨HGateâŸ© ::= HGate()

âŸ¨RZGateâŸ© ::= RZGate(âŸ¨FLOAT âŸ©)

âŸ¨GATE_2QâŸ© ::= âŸ¨CXGateâŸ© | âŸ¨CRZGateâŸ© | ...

âŸ¨CXGateâŸ© ::= CXGate()

âŸ¨CRZGateâŸ© ::= CRZGate(âŸ¨FLOAT âŸ©)

âŸ¨EOLâŸ© ::= \n

computing platforms, such as circuits, registers, gates and executing
programs with a specific backend.

Figure 4 shows the template MorphQ uses to generate quan-
tum programs. The placeholder âŸ¨ALL_IMPORTSâŸ© gets replaced by the
imports of all the dependencies used in a program. In the circuit
section, the template creates a quantum register and a classical
register of both of size âŸ¨N_QUBITSâŸ©, and assembles them in a quan-
tum circuit. The non-terminal âŸ¨GATE_OPSâŸ© is expanded using the
grammar described in Figure 5 to generate a valid sequence of gates,
i.e., they act on some qubits in the available quantum and classical
registers. Each instruction acts on a number of qubits between one
and five, and contains a suitable gate that operates on them. The
indices of the target qubits are selected randomly among the in-
tegers âŸ¨INTâŸ© compatible with the maximum number âŸ¨N_QUBITSâŸ© of
qubits available. Each gate receives a specific number of parameters,
which the generator chooses among the floating point numbers
âŸ¨FLOATâŸ©. For brevity, Figure 5 shows only an extract of the whole
grammar. Moving back to the template in Figure 4, in the transpi-
lation section the generator replaces âŸ¨OPT_LEVELâŸ© with an integer
from 0 to 3 indicating an optimization level, and âŸ¨TARGET_GATE_SETâŸ©
and âŸ¨COUPLING_MAPâŸ© with two None placeholders. Finally, in the ex-
ecution section of the program, it replaces âŸ¨BACKEND_NAMEâŸ© with a
backend and selects the number âŸ¨N_SHOTSâŸ© of shots to use in the
execution. For determining the right number of shots to run the
program, we use a sample estimation technique proposed in prior
work [31].

Our implementation of MorphQ targets the Qiskit platform,
which is highly popular and has been studied also by previous
work [12, 21, 38, 39], however we believe our approach could be
easily extended to other quantum computing platforms. The gener-
ator supports a total of 45 gates, i.e., all but three gates expressible
in Qiskit, excluded due to deprecation, presence of non-float pa-
rameters, or absence in the documentation. The 45 supported gates
have up to four parameters and can act on up to five qubits. We
limit the generation to maximum 30 consecutive gates to keep the
execution time of programs within reasonable limits.

4

Figure 5: Subset of the grammar to generate a sequence of
gate operations.

3.3 Metamorphic Testing Framework
A key technical contribution of MorphQ is a set of ten metamorphic
relationships. We classify their corresponding transformations into
three categories:

â€¢ Circuit transformations, which actively modify the circuit.
â€¢ Representation transformations, which change the intermedi-

ate representation used to represent the circuit.

â€¢ Execution transformations, which affect the execution envi-
ronment, e.g., by changing the backend, the optimizer, the
coupling map, or the target gates to use.

Table 1 summarizes all transformations. Some of them have a
precondition, as checked at line 8 of Algorithm 1, which ensures
that the resulting follow-up program is indeed expected to result in
behavior described by a specific output relationship. All transforma-
tions in Table 1 are semantics-preserving, except for Change qubit
order and Partitioned execution. For most of the transformations, the
expected output relationship is equivalence, i.e., the source program
and the follow-up program are expected to behave the same. We
implicitly mean the output relationship to be equivalence, unless
mentioned otherwise. In particular, this output relationships means
that MorphQ reports a warning when the source program runs
without crashing but the follow-up program produces a crash.

3.3.1 Circuit Transformations. These transformations exploit the
properties of the gate model of computation, such as the entan-
glement of qubits, the presence of registers and the properties of
reversible computing.

Change of qubit order. Inspired by the bug pattern â€œincorrect
qubit orderâ€ found in previous work [21], this transformation changes
the order of qubits in the quantum register. Specifically, the transfor-
mation maps the qubit indices of source program to new positions
and then creates a follow up program by adapting the sequence
of gates to the newly mapped qubit indices. With reference to the

MorphQ: Metamorphic Testing of Quantum Computing Platforms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Table 1: Metamorphic relationships and their preconditions.

Category

Name

Circuit
transformation

Change of qubit order
Inject null-effect operation

Add quantum register

Inject parameters

Partitioned execution

Precondition

-
-
Coupling map
not fixed
-
Non-interacting
subsets of qubits

Representation
transformation

Roundtrip conversion via
QASM

-

Execution
transformation

Change of coupling map
Change of gate set
Change of optimiz. level
Change of backend

No added register
-
-
-

grammar in Figure 5, the transformation hence consists in apply-
ing a bijective mapping between the âŸ¨ğ¼ ğ‘ğ‘‡ âŸ© values of the source
program and those of the follow-up program.

For example, consider the source circuit of Figure 6a, which has a
two-qubit gate between qubit 1 and qubit 2. Applying the transfor-
mation with the qubit mapping ğ‘š = {0 â†’ 2; 1 â†’ 0; 2 â†’ 1} results
in Figure 6b, where the two-qubit gate now is between qubit 0 and
qubit 1. The final measurement gates are not affected by the qubit
mapping. Instead, the approach applies a function to all the output
bit-strings of the follow-up program that applies the inverse of ğ‘š
to the order of measured qubits. In the example, suppose we obtain
an output bit-string 001 by the follow-up program. The approach
will turn it into a bit-string 100, because the bit at index 2 in the
follow-up program corresponds to be at index 0 in the source pro-
gram. After this re-mapping of the measurements, the two resulting
output distributions are expected to be equivalent.

Inject null-effect operations. Quantum computing is an instance
of reversible computing, i.e., performing any operation or gate,
with the exception of the measurement gate, on a set of qubits
never looses any information, and hence, can be reverted back
with a suitable inverse operation. This metamorphic transformation
exploits this property by inserting into the main circuit a sub-circuit
that performs a sequence of gate operations followed by its inverse,
so that the overall effect is null. Referring to the grammar in Figure 5,
the transformation consists in injecting new code in between the
sequence of gates generated by âŸ¨ğºğ´ğ‘‡ ğ¸_ğ‘‚ğ‘ƒğ‘†âŸ©. The sub-circuit may
include an arbitrary number of gates and act on an arbitrary number
of available qubits. The only restriction is that no measurement is
introduced, because otherwise it would destroy the quantum state
and change the result with respect to the source program. In our
implementation, we limit the application of this transformation to
program with a single main circuit, however in principle, it could
also be applied with an arbitrary number of sub-circuits.

Figure 7 gives a concrete example of injected code. The inverse
is produced via a function, typically called inverse (line 5), which
is present on most quantum computing platforms and can be used
to reverse the effect of a sub-circuit.

5

Add quantum register. Enlarging the set of available qubits by
adding a new and unused quantum register should not affect the
computation on the existing qubits. This transformation exploits
this property by randomly adding new quantum registers to the cir-
cuit of the follow-up program. Referring to our template (Figure 4),
the new register is added right before of after the measurement
section, thus before the circuit is executed or even transpiled. This
transformation cannot be performed when the coupling map has
been specified before via the Change of coupling map transforma-
tion, since the addition of a register would make the coupling map
too small.

Inject parameters. Given the recent interest in quantum machine
learning, quantum computing platforms offer abstractions to sup-
port the parametrization of quantum circuits [24]. One of the sub-
fields of quantum machine learning aims to use quantum circuits
and the parameters of their gates as a quantum version of arti-
ficial neural networks [23]. This transformation creates such pa-
rameterized circuits by replacing one or more concrete floating
point literals âŸ¨ğ¹ ğ¿ğ‘‚ğ´ğ‘‡ âŸ© in the source program with a correspond-
ing Parameter(â€™aâ€™) object. Then, before the transpilation stage, the
transformation binds all the free parameters to the original literal
values of the source circuit. In analogy to non-quantum programs,
this transformation resembles moving a literal value into a variable
and then using the variable instead of the literal.

Partitioned execution. Some generated source programs might
have two subsets of qubits that never interact with each other,
i.e., there is no gate operation that involves the qubits of the two
subsets. In this case, the source program performs two completely
independent computations that can be executed in parallel. Given
such a source program, this transformation separates the circuit
into two sub-circuits, executes them individually, and then post-
processes the result of the two sub-circuits to derive the distribution
of the overall program.

The output distribution of the source program has bit-strings
of size âŸ¨ğ‘ _ğ‘„ğ‘ˆ ğµğ¼ğ‘‡ ğ‘†âŸ©, whereas the result of the follow-up con-
sists of two distributions with bit-strings of sizes ğ‘ and ğ‘, where
âŸ¨ğ‘ _ğ‘„ğ‘ˆ ğµğ¼ğ‘‡ ğ‘†âŸ© = ğ‘ + ğ‘. To reconstruct an output distribution of
size âŸ¨ğ‘ _ğ‘„ğ‘ˆ ğµğ¼ğ‘‡ ğ‘†âŸ© also for the follow-up program, the approach
computes the Cartesian product of the output distributions of the
two sub-circuits. That is, each individual bit-string of length ğ‘ is
concatenated to all bit-strings of length ğ‘ to obtain the full output
distribution of the follow-up program. More formally, the relation-
ship between the output of the two sub-circuits and the output of
the original source program is:

ğ‘ˆğ‘  |ğœ™âŸ© = ğ‘ˆğ‘“ _ğ‘ğ‘ğ‘Ÿğ‘¡ 1|ğœ™âŸ©1 âŠ— ğ‘ˆğ‘“ _ğ‘ğ‘ğ‘Ÿğ‘¡ 2|ğœ™âŸ©2
where ğ‘ˆğ‘  represents the gates of the source program and |ğœ™âŸ© repre-
sents all qubits, whereas ğ‘ˆğ‘“ _ğ‘ğ‘ğ‘Ÿğ‘¡ 1 and ğ‘ˆğ‘“ _ğ‘ğ‘ğ‘Ÿğ‘¡ 1 correspond to the
two sub-circuits, and |ğœ™âŸ©1 and |ğœ™âŸ©2 are the two subset of qubits. The
correct ordering of qubits is ensured by a mapping, similarly to the
change of qubit order. In principle, this transformation can be ap-
plied to ğ‘› arbitrary independent sets of qubits, our implementation
focuses on two partitions for simplicity.

Figure 6c shows two separate partitions derived from the circuit
in Figure 6a, the first partition with a single qubit and an â€œrxâ€ gate,
and the second with two qubits and the remaining gates.

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Paltenghi and Pradel

(a) Source program.

(b) Follow-up program after â€œchange of
qubit orderâ€.

(c) Follow-up program after â€œPartitioned Execu-
tionâ€.

Figure 6: Examples of metamorphic transformations.

1 subcircuit = QuantumCircuit (qr , cr , name = ' subcircuit ')
2 subcircuit . append ( RXGate (6.12) , qargs =[ qr [0]] , cargs =[])
3 # ... sequence of additional gates
4 qc . append ( subcircuit , qargs =qr , cargs = cr )
5 qc . append ( subcircuit . inverse () , qargs =qr , cargs = cr )

Figure 7: Example of code inserted by the â€œinject null-effect
operationâ€ transformation.

1 OPENQASM 2.0;
2 include " qelib1 . inc ";
3 qreg q0 [3];
4 creg c0 [3];
5 rx ( pi ) q0 [2];
6 x q0 [0];
7 h q0 [1];
8 cx q0 [0] , q0 [1];
9 barrier q0 [0] , q0 [1] , q0 [2];
10 measure q0 [0] -> c0 [0];
11 measure q0 [1] -> c0 [1];
12 measure q0 [2] -> c0 [2];

3.3.2 Representation Transformations. We include in this category
a transformation that acts on the representation of the quantum
program, without affecting its computation or execution environ-
ment. We present one such transformation, but envision that others
could be added for other intermediate representations of quantum
programs.

Roundtrip conversion via QASM. OpenQASM [8], or short QASM,
is the de-facto standard assembly language for quantum programs.
Many quantum computing platforms offer API calls to convert to
and from it. Although limited in its representational power, vir-
tually all circuits can be expressed in the QASM format. Because
correctly converting to and from QASM is an important prereq-
uisite for the interoperability of quantum computing platforms,
MorphQ comes with a transformation designed to exercise these
parts of the platform under test. The transformation converts the
quantum circuit to the QASM format and then parses the QASM
code again to reconstruct the original circuit. Figure 8 shows the
QASM code of the example in Figure 6a. To implement the roundtrip
conversion in Qiskit, the transformation uses these API calls: qc
= qc.from_qasm_str(qc.qasm()). The approach performs this trans-
formation right before the execution section of the template in
Figure 4, reflecting a realistic usage pattern of an interoperable
format like QASM.

3.3.3 Execution Transformations. The third category of transfor-
mations is about adapting the execution environment. Given the
currently available quantum hardware, called â€œnoisy intermediate-
scale quantumâ€ (NISQ) devices [22], executing many generated
programs on quantum hardware results in many noise-induced
behavioral differences [31]. To avoid false positives caused by the
limitations of todayâ€™s hardware, while still being able to find bugs
in the software stack of quantum computing, MorphQ focuses on

Figure 8: Example of QASM code of Figure 6a.

executing programs on simulators. We present four metamorphic
transformations aimed at exercising the implementation of sim-
ulators, optimizations, and other aspects of executing quantum
programs.

Change of coupling map. This transformation replaces the place-
holder âŸ¨ğ¶ğ‘‚ğ‘ˆ ğ‘ƒğ¿ğ¼ ğ‘ğº_ğ‘€ğ´ğ‘ƒâŸ© in the program template with a ran-
domly created coupling map to test whether the transpiler is able
to adapt the quantum program to the new coupling map and still
return an equivalent result. The coupling map represents the phys-
ical connections between bit pairs, and it is a simple list of pairs
of integers. Note that MorphQ enforces the coupling map to be
fully connected, i.e., no qubit is isolated, to ensure that every qubits
can eventually interact with all the others at least indirectly via
intermediate connections. An example of linear coupling map for
our program in Figure 6a is: [[0,1],[1,2]], where the qubits 0 and
1 are connected with each other, whereas there is no connection
between qubits 0 and 2.

Change of gate set. During transpilation, a given quantum pro-
gram is converted to be compatible with a specific target device,
and this often involves translating the program gates to the natively
supported gates. This transformation exercise this translation step
by replacing the âŸ¨ğ‘‡ ğ´ğ‘…ğºğ¸ğ‘‡ _ğºğ´ğ‘‡ ğ¸ğ‘†âŸ© in the program template with
a universal gate set, such as ["rx", "ry", "rz", "p", "cx"] gates
which has been shown to be universal [34]. This transformation
considers three gate sets, however MorphQ easily supports the
extension with other universal gate sets.

6

qreg0qreg1qreg23cregRXXH012qreg0qreg1qreg23cregRXXH012part_1_01cregRX0part_2_0part_2_12cregXH01MorphQ: Metamorphic Testing of Quantum Computing Platforms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Change of optimization level. The final two transformations are
inspired by work on compiler testing [4]. One transformation re-
places the âŸ¨ğ‘‚ğ‘ƒğ‘‡ _ğ¿ğ¸ğ‘‰ ğ¸ğ¿âŸ© in the program template with another
level between 0 and 3, which correspond to no optimization and
heavy optimization. Similar to modifying the optimization level of
a traditional compiler, this change is not expected to affect the final
output of a program.

Change of backend. This transformation replaces the non-terminal
âŸ¨ğµğ´ğ¶ğ¾ğ¸ğ‘ ğ·_ğ‘ ğ´ğ‘€ğ¸âŸ© in the program template with another avail-
able backend. Different simulators typically have completely differ-
ent implementations, such as one based on state vectors or density
matrices. A single simulator often offers two variants, running
on a CPU and GPU respectively, which we treat as two separate
backends. In total MorphQ supports eight different backends. In
analogy to testing traditional compilers, changing the backend
roughly corresponds to comparing the behavior across different
target platforms.

3.4 Comparing Execution Behavior
The third and final step of MorphQ is to execute both the source
program and the follow-up program derived via our metamorphic
framework, and to compare their behavior. If the two programs
expose different behaviors, MorphQ adds them to the set of likely
bug-revealing pairs of programs.

We perform this comparison at two levels. The first level identi-
fies cases where one program runs without any crash, but the other
program crashes. Our program generator (Section 3.2) is designed
to create source programs that do not crash. However, applying
the metamorphic transformations may trigger some bugs in the
tested platform that manifest through a crash. We call pairs of a
non-crashing and a crashing program a crash difference.

The second level applies when both programs run without any
crash, where MorphQ compares the measured output bits. Due
to the probabilistic nature of quantum programming, precisely
comparing the output bit-strings would be misleading. Instead,
the platform repeatedly executes each circuit for the specified
number of shots and then returns the output distributions. Mor-
phQ then compares the distribution of two programs. We use the
Kolmogorov-Smirnov test [15, 26] to assess the statistical signifi-
cance of the difference between the two distributions, as done in
previous work [31], using a significance level of ğ›¼ = 5%. We call any
pair of programs with a p-value below ğ›¼ a statistically significant
distribution difference.

4 EVALUATION
Our evaluation focuses on the following research questions:

â€¢ RQ1: How many warnings does MorphQ produce?
â€¢ RQ2: What real-world bugs does the approach find in Qiskit?
â€¢ RQ3: How does MorphQ compare to prior work on testing

quantum computing platforms [31].

â€¢ RQ4: To what extent do the different metamorphic relations

contribute to the warnings and bugs found?

â€¢ RQ5: How efficient is MorphQ and what are the most time-

consuming components?

7

Table 2: Distribution of warnings produced over two days.

Tested program pairs

â†©â†’ Crashes in source program
â†©â†’ Crashes in follow-up program
â†©â†’ Successful executions

â†©â†’ Distribution differences

Number

Percentage

50,591
0
14,651
35,940
537

100.0%
0.0 %
29.0 %
71.0 %
1.1 %

Comparing the two kinds of differences that MorphQ reports
during preliminary experiments, we find that crash differences
typically point to actual problems in the tested platform, whereas
distribution differences mostly correspond to false positives. The
reason for the false positives is that the statistical test misreports
distributions as different even though they are the same, which
is expected to happen in a small percentage (ğ›¼) of all cases. As
manually inspecting differences and understanding their root cause
involves significant human effort, we focus our detailed evaluation
on crash differences. An effective way to identify distribution differ-
ences that are likely true positives will be interesting future work,
which then can be easily plugged into MorphQ.

To further motivate our focus on crash differences, we refer to
the results of QDiff [31], i.e., the closest work existing work. Out of
33 divergent cases found by QDiff, the authors were able to spot and
report bugs only for four crashing differences. All divergent cases
due to distribution differences were attributed to possible hardware
instabilities, which are frequent given the immature stage of real
quantum computers.

4.1 Software Architecture and Extensibility
MorphQ is implemented in Python and tested on the latest Qiskit
0.19.1 version at the time of performing the evaluation. The imple-
mentation is designed in a modular way with four main components:
(1) the MorphQ core, which is responsible for the orchestration of
the various steps of the approach, (2) a program generator, which
produces valid programs according to the API of the platform, (3)
an extensible set of metamorphic transformations, which apply
lightweight program transformations based on the API of the plat-
form, (4) a divergence detector, which is responsible for spotting
any distribution difference based on a statistical test by comparing
the execution results. Note that only the program generator and the
metamorphic transformations are platform-specific, whereas the
MorphQ core and the divergence detector are cross-platform, mak-
ing the approach modular and easily extensible. MorphQ currently
supports Qiskit as a first target platform, but could be extended to
other quantum computing platforms.

All experiments are run on a machine with 48 CPU cores (Intel
Xeon Silver, 2.20GHz), two NVIDIA Tesla T4 GPUs with 16GB
memory each, and 252GB of RAM, which is running Ubuntu 18.04.5.

4.2 RQ1: Warnings Produced by MorphQ
This research question evaluates MorphQâ€™s effectiveness at finding
surprising behavior in a quantitative way. We run the approach for
a total of 48 hours and summarize the results in Table 2. Over this
period, the program generator produces a total of 50,591 programs.

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Paltenghi and Pradel

All these program execute without crashing, which confirms that
our template-based and grammar-based generation technique is
successful at generating valid quantum programs. Applying meta-
morphic relations to these programs leads to a program crash in
29.0% of the cases, and hence, is reported as a crash difference. Out
of the non-crashing executions, a small percentage of a total of 537
programs exposes a distribution difference.

Answer to RQ1: The program generation successfully creates only
valid quantum programs, and MorphQ is effective in producing
numerous warnings by inducing 29.0% of all follow-up programs
to crash.

4.3 RQ2: Real-World Bugs Found
To evaluate MorphQâ€™s ability to find real-world bugs, we inspect
a sample of warnings produced over a period of about 30 days.
Because crash-inducing bugs are the most critical, as they impede
developers from running their programs at all, and due to the diffi-
culties in identifying true positives among the distribution differ-
ences, we focus our detailed inspection on crashing differences.

Before inspecting the program pairs, we semi-automatically clus-
ter the warnings based on their crash message. To this end, we
abstract program-specific references, such as line numbers, variable
names, and file names, and then assign all warnings with the same
abstracted message into a cluster. For example, â€œDuplicate declara-
tion for gate â€™ryyâ€™, line 4, fileAâ€ and â€œDuplicate declaration for gate
â€™ryyâ€™, line 5, fileBâ€ are assigned to the same cluster. We then ran-
domly select a few failing follow-up programs from each cluster for
manual inspection. The inspection procedure consists in manually
reversing each transformation in the follow-up program, one at
the time, until we find which transformation is responsible for the
crash. Then, once detected which transformation or combination of
transformations is responsible, we reduce the gate operations in the
program in a delta debugging [36]-like manner until we identify the
minimal sequence of operations to trigger the crash. This manual
process is feasible since the programs have at most 30 operations
and four transformations. Automating the crash clustering and the
minimization is left for future work.

Table 3 summarizes the results of our manual inspection. For
each warning, we report the reference to the bug report2, its status,
whether it was a new or duplicated bug report, the crash message,
and what metamorphic transformation(s) are required to trigger the
bug. Over the course of this study, we have filed a total of twelve
bug reports in the Qiskit repository. So far, eight of the reports have
been confirmed by the developers as bugs. The following describes
some representative examples of the inspected warnings.

4.3.1 Confirmed Bugs. Commutation analysis fails with â‰¥ 11
qubits (Bug 6). This bug is detected thanks to two different meta-
morphic transformations applied simultaneously, showing the im-
portance of combining multiple transformations. The transforma-
tions involved are: change of optimization level and inject null-effect
operations. Figure 9 shows the minimized follow-up program con-
sisting of a main circuit with eleven qubits, a subcircuit with ten
qubits, and an optimization pass of level 2. This program triggers a

2Removed for double-blind review. See supplementary material for anonymized ver-
sions of the bug reports.

1 qr = QuantumRegister (11 , name = 'qr ')
2 cr = ClassicalRegister (11 , name = ' cr ')
3 qc = QuantumCircuit (qr , cr , name = 'qc ')
4 subcircuit = QuantumCircuit (qr , cr , name = ' subcirc ')
5 subcircuit .x (3)
6 qc . append ( subcircuit , qargs =qr , cargs = cr )
7 qc .x (3)
8 qc = transpile (qc , optimization_level =2)
9 # ValueError : too many subscripts in einsum

Figure 9: Minimal follow-up program to trigger Bug 6.

1 qr = QuantumRegister (2 , name = ' qr ')
2 cr = ClassicalRegister (2 , name = 'cr ')
3 qc = QuantumCircuit (qr , cr , name = 'qc ')
4 subcircuit = QuantumCircuit (qr , cr , name = ' subcirc ')
5 subcircuit .x( qr [0])
6 qc . append ( subcircuit , qargs =qr , cargs = cr )
7 qc = QuantumCircuit . from_qasm_str ( qc . qasm () )
8 # QasmError : ' subcirc ' uses 4 qubits but is declared for

2 qubits

Figure 10: Minimal follow-up program to trigger Bug 8.

generic Numpy error message. As confirmed by a Qiskit developer,
the bug is in a specific analysis part of the optimization, called the
CommutationAnalysis. The goal of this analysis is to find operation
nodes that can commute in the direct acyclic graph representing
the program. The problem is that the implementation of this analy-
sis relies on matrix multiplications with ğ‘›_ğ‘ğ‘¢ğ‘ğ‘–ğ‘¡ğ‘  Ã— 3 dimensions,
which in the case of eleven qubits is 33, whereas the maximum
dimension supported by Numpy is 32 (numpy.MAXDIM).

Identity gate hinders gate conversion (Bug 1). This bug is
discovered by the transformation Change of gate set. Whenever
the transpiler has to convert a circuit that, among the other gates,
includes an identity gate, then the transpiler fails. The reason is
that the identity gate is treated as a delay by the scheduler, since
an identity gate operation is equivalent to a no-operation. As a
consequence, there is no translation rule for the identity gate which
leads to an exception in the translation process. The developers
confirmed the bug, which had already been detected independently,
and proposed a patch to fix it.

QASM exporter creates invalid output for subcircuits with
classical registers (Bug 8) This bug is triggered by a combination
of two transformations: Roundtrip conversion via QASM and Inject
null-effect operations. Figure 10 shows a minimized circuit that trig-
gers the bug. It contains a subcircuit with a classical register, which
is then converted to QASM and back to a quantum circuit. Running
this code makes the QASM importer call to qasm_from_str produce
an error caused by parsing invalid QASM code. The root cause of the
error is actually in the QASM exporter, which produces the faulty
QASM code shown in Figure 11. A Qiskit developer confirmed this
bug by saying it should have been rejected by the exporter, since it
is not possible to represent sub-circuits with classical registers in
QASM.

False Positives. Beyond actual bugs, MorphQ may also report
4.3.2
false positive warnings in case the assumptions of our metamor-
phic relations do not hold. We are aware of one such case, which

8

MorphQ: Metamorphic Testing of Quantum Computing Platforms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Table 3: Real-world bugs and warnings found by MorphQ.

ID Report

Status

Novelty

Crash message

Metamorphic transformations

1
2
3
4
5
6
7

8

9

#7641
#7326
#7756
#7749
#7694
#7700
#7748

confirmed
confirmed
confirmed
confirmed
confirmed
confirmed
confirmed

#7750

confirmed

#7769

reported

10

#7771

reported

11

#7772

reported

12

#7773

reported

-

-

-

-

Instruction id not found
duplicate
duplicate Mismatch between parameter_binds
duplicate Cannot find gate definition for â€˜c3sxâ€™
duplicate Duplicate declaration for gate â€˜rzxâ€™
qargs not in this circuit
new
new
too many subscripts in einsum (numpy) Change of optimization level, Inject null-effect operations
Inject parameters
Cannot bind parameters not present in
new
the circuit
Gate or opaque call to â€˜subcircuitâ€™

Change of gate set
Inject parameters
Roundtrip conversion via QASM
Roundtrip conversion via QASM
Change of optimization level, Change of coupling map

new

Cannot find gate definition for â€˜rzxâ€™

Duplicate declaration for gate â€˜ryyâ€™

Roundtrip conversion via QASM, Inject null-effect opera-
tions
Roundtrip conversion via QASM, Inject null-effect opera-
tions
Roundtrip conversion via QASM, Inject null-effect opera-
tions

Cannot find gate definition for unitary Change of optimization level, Roundtrip conversion via

Cannot find gate definition for â€˜rcccxâ€™

QASM, Inject null-effect operations
Roundtrip conversion via QASM, Inject null-effect opera-
tions

1 include " qelib1 . inc ";
2 gate subcircuit q0 , q1 { x q0 ; }
3 qreg qr [2];
4 creg cr [2];
5 subcircuit qr [0] , qr [1] , cr [0] , cr [1];

Figure 11: Wrong QASM code produced because of Bug 8.

happens during the Change of gate set transformation. The trans-
formation assumes that that any circuit can be transformed into an
equivalent circuit that uses only gates inside one of the universal
gate sets. While this assumption holds in theory, the implementa-
tion in Qiskit uses the A* algorithm to find an equivalent sequence
of gates because exploring all possible sequences is computation-
ally expensive and impractical. Because this search may fail in the
computational budget provided by Qiskit, the follow-up program
sometimes crashes with a â€œUnable to map source basis to target
basisâ€ crash message, which does not point to a bug in the platform,
but simply a limitation of its implementation.

Answer to RQ2: MorphQ has discovered twelve bugs in the latest
version of Qiskit, eight of which have already been confirmed by
the developers.

4.4 RQ3: Comparison with Prior Work
We compare with QDiff [31], which is the only other automated
technique for testing quantum computing platforms that we are
aware of, by comparing to the results reported in their paper. For
a fair comparison, RQ1 uses the same approach as in their work,
i.e., to measure the number of warnings produced in a fixed time
budget. Like in their evaluation, we set the time budget to two days.

9

During its evaluation on Qiskit, i.e., the target platform of our
evaluation, QDiff has reported distribution differences due to hard-
ware characteristics, not software bugs. In contrast, MorphQ has
discovered several software bugs in Qiskit, as described in detail in
RQ2. None of the bugs reported in Table 3 has been found by QDiff.

Answer to RQ3: MorphQ has revealed new bugs not found by
prior work [31], showing that it complements the state of the art.

4.5 RQ4: Contribution of Metamorphic

Transformations

To better understand to what extent the different metamorphic
transformations in MorphQ contribute to its effectiveness, we check
which transformations are involved in reporting warnings. We ad-
dress this question from a qualitative and a quantitative perspective.
For a qualitative answer, the last column in Table 3 shows for each
of the manually inspected warnings which metamorphic transfor-
mations are essential to expose the unexpected behavior. Finding
these twelve warnings involves a total of six metamorphic trans-
formations. The most prevalent transformation is Roundtrip QASM
conversion. We also find that seven out of the twelve warnings re-
quire at least two transformations, underlining the importance of
combining them.

From a more quantitative perspective, Figure 12 reports the meta-
morphic transformations involved in the 50,591 pairs of programs
from RQ1. For each transformation, the figure shows how many
program pairs with that transformation exhibit the same behavior, a
crash difference, or a distribution difference. If a pair is the result of
applying multiple transformations in sequence, we count it multiple
times. The transformation leading to most crashes is Change of gate
set, which leads to the false positive discussed in Section 4.3.2. The
second highest crash-inducing transformation is Roundtrip QASM
Conversion, which shows that QASM exporter and importer is a

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Paltenghi and Pradel

5 THREATS TO VALIDITY
There are some threats to the validity of our results and the conclu-
sions to draw from them. First, the results might be influenced by
the non-deterministic, randomized nature of the program generator
and the selection of transformations. We mitigate this threat via
long-running experiments, which compensate for any bias in the
results one might observe with only a few generated programs.
Second, the number of warnings gives only a partial view of the ef-
fectiveness of MorphQ due to the presence of duplicates [4]. To mit-
igate this threat we cluster warnings and inspect a sample, showing
that there are at least twelve unique bugs. Finally, our experiments
focus on a single target platform and we cannot claim that our
results will generalize beyond it. We believe the approach could
also be applied to other quantum computing platforms that use a
circuit-based computational model, provide similar programming
abstractions, and offer QASM compatibility, such as Pytket [25] and
Cirq [9].

6 RELATED WORK

Quantum computing platforms. A study by Paltenghi and Pradel
[21] identifies ten quantum-specific bug patterns in quantum com-
puting platforms, such as incorrect qubit order and incorrect interme-
diate representation, which inspired some metamorphic transforma-
tions of MorphQ. Another study [39] gathers a dataset of 36 bugs
in Qiskit and identifies crashes and wrong outputs as the most com-
mon manifestation of bugs, which is exactly what MorphQ focuses
on. Sodhi and Kapur [27] study quality attributes of these platforms
and discuss challenges faced by platform developers. All these stud-
ies motivate work on testing quantum computing platforms. Prior
to our work, there has been only one other approach addressing this
challenge [31] (see Section 4.4 for a detailed comparison), showing
that MorphQ addresses an important problem.

Wang et al. [31] propose QDiff, a differential testing technique
for quantum computing platforms. In contrast to our work, QD-
iff does not generate programs from scratch, but starts from six
hand-written programs. Moreover, QDiff performs differential test-
ing across different backends and optimization levels of quantum
computing platforms, whereas our work is based on a novel set of
metamorphic transformations, only two of which (change of op-
timization level and change of backend) are similar to QDiff. See
Section 4.4 for our empirical comparison with QDiff.

Testing and manipulating quantum programs. A problem related
to that addressed here is how to test quantum programs. Several
approaches have been proposed, including a search-based tech-
niques [30, 33], statistical assertion checks that try to limit the
effects on the actual computation [14, 18, 19], combinatorial test-
ing [32], and coverage-based methods [2]. In contrast to our work,
these techniques test specific programs, not the platform that pro-
grams are running on. CutQC [28] breaks a quantum circuit into
smaller parts so that the resulting sub-circuits can be executed
on the limited NISQ devices [22]. Our partitioned execution trans-
formation also splits a circuit in sub-circuits, but only when the
qubits are not entangled, whereas CutQC handles entanglement by
classical postprocessing that approximates the output distribution.
Thus, unlike CutQC, our transformation does not introduce any
approximation.

Figure 12: Involvement of metamorphic transformations in
different kinds of execution behavior.

complex, error-prone component of the platform under test. Inject
null-effect operations and Inject Parameters also induce a sizable set
of crashes, which we attribute to the fact that they exercise recently
added code. Notably, each of the transformations leads to at least
some unexpected behavior, showing that they all contribute to the
overall effectiveness.

Answer to RQ4: All the metamorphic transformations in MorphQ
contribute to detecting unexpected behavior, and often more then
one transformation is needed to detect a warning.

4.6 RQ5: Time Cost per Component
The following studies how efficient the different steps of MorphQ
are and which step takes most time. We measure the time spent in
the three main components, namely (i) generating source programs,
(ii) creating follow-up programs via a series of transformations, and
(iii) executing programs on simulators and compare their behavior.
Figure 13 reports the time per component, on average for a single
pair of programs, during the two-day experiment from RQ1. The
by far most time-consuming step is to execute the programs, as
executing larger circuits in a simulator running on classical hard-
ware is known to be slow. In contrast, generating and transforming
programs take only 6.2ms and 30.6ms, respectively.

Figure 13: Time spent per component of MorphQ.

Answer to RQ5: Program generation and performing metamor-
phic transformations are efficient, together taking only 36.9ms per
program pair, whereas executing the programs on simulators is the
most time-consuming step of the approach.

10

05000100001500020000No. program pairsChange of qubit orderChange of coupling mapAdd quantum registerChange of optimization levelInject parametersChange of backendInject null-effect operationsRoundtrip conversion via QASMChange of gate setMetamorphic transformationPair behaviorSameCrash diff.Distrib. diff.101102103Average time (ms) in log scaleGeneration (source)Transformation (follow-up)ExecutionStageMorphQ: Metamorphic Testing of Quantum Computing Platforms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Testing of probabilistic systems. ProbFuzz [11] is a testing tech-
nique targeted at probabilistic systems, such as probabilistic mod-
eling libraries. While both those libraries and quantum comput-
ing platforms output probabilistic distributions, the latter is more
deeply connected to hardware constraints, e.g., via a coupling map
and the gate set, which our approach considers.

Testing compilers and other developer tools. The critical role of
compilers for overall software reliability has motivated a stream
of work on compiler testing. We refer to a recent survey [4] for a
comprehensive overview. Quantum computing platforms play a
similarly critical role in the quantum computing domain, which
motivates our work. Our program generator relates to work on gen-
erating traditional programs, e.g., via randomized code generation
combined with static and dynamic checks to avoid undefined behav-
ior [35], code fragment-based fuzzing [13], and systematic program
enumeration [37]. Metamorphic testing has also been applied in
compiler testing, e.g., by deleting and inserting code in the dead
regions of a program [16, 17], and via domain-specific transforma-
tions for graphics shading compilers [10]. Other developer tools,
e.g., debuggers, can also be subject to metamorphic testing [29].
None of the above approaches addresses the unique challenges of
quantum computing platforms, for which MorphQ contributes a
novel program generator and a novel set of metamorphic transfor-
mations.

7 CONCLUSION
Motivated by the increasing popularity of quantum computing
paired with the slim portfolio of techniques for testing its software
stack, this paper presents the first metamorphic testing approach for
quantum computing platforms. Our two key contributions are a pro-
gram generator that efficiently creates a diverse set of non-crashing
quantum programs, and a novel set of metamorphic transforma-
tions to create pairs of programs to compare with each other. Our
evaluation shows MorphQâ€™s effectiveness, e.g., in the form of twelve
detected bugs in Qiskit. We envision our two key contributions
to enable future work beyond MorphQ. For example, the program
generator provides a starting point for other testing techniques, e.g.,
coverage-guided fuzzing, and the metamorphic transformations
could be adapted to other platforms. Overall, the presented work
takes an important step toward further increasing the reliability of
software in this still young field.

REFERENCES
[1] 2021. Qiskit/Qiskit. https://github.com/Qiskit/qiskit.
[2] Shaukat Ali, Paolo Arcaini, Xinyi Wang, and Tao Yue. 2021. Assessing the Effec-
tiveness of Input and Output Coverage Criteria for Testing Quantum Programs.
In 2021 14th IEEE Conference on Software Testing, Verification and Validation (ICST).
13â€“23. https://doi.org/10.1109/ICST49551.2021.00014

[3] Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo.
2015. The Oracle Problem in Software Testing: A Survey. IEEE Trans. Software
Eng. 41, 5 (2015), 507â€“525.

[4] Junjie Chen, Wenxiang Hu, Dan Hao, Yingfei Xiong, Hongyu Zhang, Lu Zhang,
and Bing Xie. 2016. An Empirical Comparison of Compiler Testing Techniques.
In Proceedings of the 38th International Conference on Software Engineering (ICSE
â€™16). Association for Computing Machinery, New York, NY, USA, 180â€“190. https:
//doi.org/10.1145/2884781.2884878

[5] Junjie Chen, Jibesh Patra, Michael Pradel, Yingfei Xiong, Hongyu Zhang, Dan
Hao, and Lu Zhang. 2020. A Survey of Compiler Testing. Comput. Surveys 53, 1
(May 2020), 1â€“36. https://doi.org/10.1145/3363562

11

[6] Tsong Y Chen, Shing C Cheung, and Shiu Ming Yiu. 1998. Metamorphic testing: a
new approach for generating next test cases. Technical Report. Technical Report
HKUST-CS98-01, Department of Computer Science, Hong Kong.

[7] Tsong Yueh Chen, Fei-Ching Kuo, Huai Liu, Pak-Lok Poon, Dave Towey, T. H.
Tse, and Zhi Quan Zhou. 2018. Metamorphic Testing: A Review of Challenges
and Opportunities. Comput. Surveys 51, 1 (Jan. 2018), 4:1â€“4:27. https://doi.org/
10.1145/3143561

[8] Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. 2017.
Open Quantum Assembly Language. arXiv:1707.03429 [quant-ph] (July 2017).
arXiv:1707.03429 [quant-ph]

[9] Cirq Developers. 2021. Cirq. Zenodo. https://doi.org/10.5281/zenodo.5182845
[10] Alastair F Donaldson, Hugues Evrard, Andrei Lascu, and Paul Thomson. 2017.
Automated testing of graphics shader compilers. Proceedings of the ACM on
Programming Languages 1, OOPSLA (2017), 1â€“29.

[11] Saikat Dutta, Owolabi Legunsen, Zixin Huang, and Sasa Misailovic. 2018. Testing
Probabilistic Programming Systems. In Proceedings of the 2018 26th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering (ESEC/FSE 2018). Association for Computing Ma-
chinery, New York, NY, USA, 574â€“586. https://doi.org/10.1145/3236024.3236057
[12] Mark Fingerhuth, TomÃ¡Å¡ Babej, and Peter Wittek. 2018. Open Source Software
in Quantum Computing. PLOS ONE 13, 12 (Dec. 2018), e0208561. https://doi.
org/10.1371/journal.pone.0208561

[13] Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code

Fragments.. In USENIX Security Symposium. 445â€“458.

[14] Yipeng Huang and Margaret Martonosi. 2019. Statistical Assertions for Validating
Patterns and Finding Bugs in Quantum Programs. (May 2019). https://doi.org/
10.1145/3307650.3322213

[15] A. L. KOLMOGOROV. 1933. Sulla Determinazione Empirica Di Una Legge Di

Distribuzione. G. Ist. Ital. Attuari 4 (1933), 83â€“91.

[16] Vu Le, Mehrdad Afshari, and Zhendong Su. 2014. Compiler validation via equiv-

alence modulo inputs. ACM Sigplan Notices 49, 6 (2014), 216â€“226.

[17] Vu Le, Chengnian Sun, and Zhendong Su. 2015. Finding Deep Compiler Bugs via
Guided Stochastic Program Mutation. In Proceedings of the 2015 ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA 2015). ACM, 386â€“399.

[18] Gushu Li, Li Zhou, Nengkun Yu, Yufei Ding, Mingsheng Ying, and Yuan Xie.
2020. Projection-Based Runtime Assertions for Testing and Debugging Quantum
Programs. Proceedings of the ACM on Programming Languages 4, OOPSLA (Nov.
2020), 150:1â€“150:29. https://doi.org/10.1145/3428218

[19] Ji Liu, Gregory T. Byrd, and Huiyang Zhou. 2020. Quantum Circuits for Dynamic
Runtime Assertions in Quantum Computation. In Proceedings of the Twenty-Fifth
International Conference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS â€™20). Association for Computing Machinery, New
York, NY, USA, 1017â€“1030. https://doi.org/10.1145/3373376.3378488

[20] EÃ±aut Mendiluze, Shaukat Ali, Paolo Arcaini, and Tao Yue. 2021. Muskit: A

Mutation Analysis Tool for Quantum Software Testing.

[21] Matteo Paltenghi and Michael Pradel. 2021.
puting Platforms: An Empirical Study.
arXiv:2110.14560 [cs]

Bugs in Quantum Com-
arXiv:2110.14560 [cs] (Nov. 2021).

[22] John Preskill. 2018. Quantum Computing in the NISQ Era and Beyond. Quantum

2 (Aug. 2018), 79. https://doi.org/10.22331/q-2018-08-06-79 arXiv:1801.00862

[23] Maria Schuld, Ilya Sinayskiy, and Francesco Petruccione. 2014. The Quest for a
Quantum Neural Network. Quantum Information Processing 13, 11 (Nov. 2014),
2567â€“2586. https://doi.org/10.1007/s11128-014-0809-8

[24] Maria Schuld, Ilya Sinayskiy, and Francesco Petruccione. 2015. An Introduction
to Quantum Machine Learning. Contemporary Physics 56, 2 (April 2015), 172â€“185.
https://doi.org/10.1080/00107514.2014.964942

[25] Seyon Sivarajah, Silas Dilkes, Alexander Cowtan, Will Simmons, Alec Edgington,
and Ross Duncan. 2020. T|ketâŸ©: A Retargetable Compiler for NISQ Devices.
Quantum Science and Technology 6, 1 (Nov. 2020), 014003. https://doi.org/10.
1088/2058-9565/ab8e92

[26] N. Smirnov. 1948. Table for Estimating the Goodness of Fit of Empirical Dis-
tributions. The Annals of Mathematical Statistics 19, 2 (June 1948), 279â€“281.
https://doi.org/10.1214/aoms/1177730256

[27] Balwinder Sodhi and Ritu Kapur. 2021. Quantum Computing Platforms: As-
sessing the Impact on Quality Attributes and SDLC Activities. In 2021 IEEE
18th International Conference on Software Architecture (ICSA). 80â€“91. https:
//doi.org/10.1109/ICSA51549.2021.00016

[28] Wei Tang, Teague Tomesh, Martin Suchara, Jeffrey Larson, and Margaret
Martonosi. 2021. CutQC: Using Small Quantum Computers for Large Quan-
tum Circuit Evaluations. In Proceedings of the 26th ACM International Conference
on Architectural Support for Programming Languages and Operating Systems (AS-
PLOS 2021). Association for Computing Machinery, New York, NY, USA, 473â€“486.
https://doi.org/10.1145/3445814.3446758

[29] Sandro Tolksdorf, Daniel Lehmann, and Michael Pradel. 2019. Interactive Meta-
morphic Testing of Debuggers. In Proceedings of the 28th ACM SIGSOFT Interna-
tional Symposium on Software Testing and Analysis. Association for Computing
Machinery, New York, NY, USA, 273â€“283.

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Paltenghi and Pradel

[30] Jiyuan Wang, Fucheng Ma, and Yu Jiang. 2021. Poster: Fuzz Testing of Quan-
tum Program. In 2021 14th IEEE Conference on Software Testing, Verification and
Validation (ICST). 466â€“469. https://doi.org/10.1109/ICST49551.2021.00061
[31] Jiyuan Wang, Qian Zhang, Guoqing Harry Xu, and Miryung Kim. 2021. QD-
iff: Differential Testing of Quantum Software Stacks. In 2021 36th IEEE/ACM
International Conference on Automated Software Engineering (ASE). 692â€“704.
https://doi.org/10.1109/ASE51524.2021.9678792

[32] Xinyi Wang, Paolo Arcaini, Tao Yue, and Shaukat Ali. 2021. Application of
Combinatorial Testing to Quantum Programs. In 2021 IEEE 21st International
Conference on Software Quality, Reliability and Security (QRS). 179â€“188. https:
//doi.org/10.1109/QRS54544.2021.00029

[33] Xinyi Wang, Paolo Arcaini, Tao Yue, and Shaukat Ali. 2021. Generating Fail-
ing Test Suites for Quantum Programs With Search. In Search-Based Soft-
ware Engineering (Lecture Notes in Computer Science), Una-May Oâ€™Reilly and
Xavier Devroey (Eds.). Springer International Publishing, Cham, 9â€“25. https:
//doi.org/10.1007/978-3-030-88106-1_2

[34] Colin P. Williams. 2011. Quantum Gates. In Explorations in Quantum Computing,
Colin P. Williams (Ed.). Springer, London, 51â€“122. https://doi.org/10.1007/978-
1-84628-887-6_2

[35] Xuejun Yang, Yang Chen, Eric Eide, and John Regehr. 2011. Finding and Under-
standing Bugs in C Compilers. ACM SIGPLAN Notices 46, 6 (June 2011), 283â€“294.
https://doi.org/10.1145/1993316.1993532

[36] Andreas Zeller. 2002. Isolating Cause-Effect Chains from Computer Programs.
ACM SIGSOFT Software Engineering Notes 27, 6 (Nov. 2002), 1â€“10. https://doi.
org/10.1145/605466.605468

[37] Qirun Zhang, Chengnian Sun, and Zhendong Su. 2017. Skeletal Program Enu-

meration for Rigorous Compiler Testing. In PLDI.
[38] Pengzhan Zhao, Jianjun Zhao, and Lei Ma. 2021.

Identifying Bug Pat-
arXiv:2103.09069 [quant-ph] (March 2021).

terns in Quantum Programs.
arXiv:2103.09069 [quant-ph]

[39] Pengzhan Zhao, Jianjun Zhao, Zhongtao Miao, and Shuhan Lan. 2021. Bugs4Q:
A Benchmark of Real Bugs for Quantum Programs. arXiv:2108.09744 [cs] (Aug.
2021). arXiv:2108.09744 [cs]

12

