2
2
0
2

l
u
J

2
1

]

A
N
.
h
t
a
m

[

1
v
9
8
5
5
0
.
7
0
2
2
:
v
i
X
r
a

MULTISHAPE: A SPECTRAL ELEMENT METHOD,
WITH APPLICATIONS TO DYNAMIC DENSITY FUNCTIONAL
THEORY AND PDE-CONSTRAINED OPTIMIZATION

JONNA C. RODEN∗, RORY D. MILLS-WILLIAMS† , JOHN W. PEARSON‡ , AND
BENJAMIN D. GODDARD§

Abstract. A numerical framework is developed to solve various types of PDEs on compli-
cated domains, including steady and time-dependent, non-linear and non-local PDEs, with diﬀerent
boundary conditions that can also include non-linear and non-local terms. This numerical framework,
called MultiShape, is a class in Matlab, and the software is open source. We demonstrate that Mul-
tiShape is compatible with other numerical methods, such as diﬀerential–algebraic equation solvers
and optimization algorithms. The numerical implementation is designed to be user-friendly, with
most of the set-up and computations done automatically by MultiShape and with intuitive operator
deﬁnition, notation, and user-interface. Validation tests are presented, before we introduce three
examples motivated by applications in Dynamic Density Functional Theory and PDE-constrained
optimization, illustrating the versatility of the method.

Key words. Spectral element method, Dynamic density functional theory, PDE-constrained

optimization

AMS subject classiﬁcations. 35Q70; 35Q93; 65M70; 82C22; 82M22

1. Introduction. Many problems in the applied sciences,

including biology,
chemical engineering, and physics can be described by (integro-) partial diﬀerential
equation (PDE) models. These include wide-ranging applications of industrial rele-
vance, including those in drug delivery [39], manufacturing [26, Chapter 2], and the
food industry [15]. Often in these applications, such models need to be solved on com-
plicated domains, to include relevant features of the problem setup, for example in
microﬂuidics [7] and milling processes in the pharmaceutical industry [46]. Therefore,
eﬃcient numerical methods for solving integro-PDEs on complicated domains are of
ever-increasing interest to academic and industrial communities [41, 9, 33, 32, 17, 56].
Perhaps the most popular numerical scheme for such problems is the ﬁnite element
method (FEM) [6], which is both an active area of applied mathematics research and
frequently used in a wide range of applications [41], with several commercial and open-
source software solutions available, such as FEniCS [3, 30] and Abaqus [47]. However,
for a large class of PDE models, there is another eﬀective numerical method—the
pseudospectral method—which, in particular for modelling problems that involve non-
local phenomena, can be more eﬃcient and accurate than the FEM for a comparable
computational cost. We are particularly interested in applications in which non-local
phenomena enter the model through, for example, convolution terms, on which we
focus here, or fractional operators. For these models, FEM becomes computationally
expensive because one of its key advantages, the frequently obtained sparse matrix
structures, is generally lost. Pseudospectral methods, however, do not rely on sparsity
and non-local terms can be treated without signiﬁcant additional computational cost.

∗The School of Mathematics and Maxwell Institute for Mathematical Sciences, The University of

Edinburgh, Edinburgh, EH9 3FD, UK (J.C.Roden@sms.ed.ac.uk)

†University of Edinburgh, Heinrich Heine Universit¨at D¨usseldorf
‡The School of Mathematics and Maxwell Institute for Mathematical Sciences, The University of

Edinburgh, Edinburgh, EH9 3FD, UK (j.pearson@ed.ac.uk)

§The School of Mathematics and Maxwell Institute for Mathematical Sciences, The University of

Edinburgh, Edinburgh, EH9 3FD, UK (b.goddard@ed.ac.uk)

1

 
 
 
 
 
 
2

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

Moreover, pseudospectral methods exhibit exponential convergence in the number of
collocation points for smooth functions and can exploit any smoothness of the PDE
solution [5, Chapter 1]. For many models that include diﬀusion and suﬃciently ‘nice’
interactions, smooth solutions can be expected, even if such results have not yet been
rigorously proven. Any potential such proofs are expected to be highly challenging.
For example, even with periodic boundary conditions, non-local problems of the form
studied here may not have a unique equilibrium, depending on the relative strengths
of diﬀusion and interaction [10], which can provide signiﬁcant numerical challenges in
regions of parameter space that lead produce ‘phase transitions’.

In [36], a pseudospectral scheme has been introduced to eﬃciently solve non-local
PDEs, including complicated non-local boundary conditions on simple domains. The
authors provided an open-source software implementation of their method, 2DCheb-
Class, which applies to 1D problems and simple domains in two dimensions, such as
rectangles, wedges (sections of an annulus, in polar coordinates), and semi-inﬁnite
boxes. Features of this implementation include the straightforward computation of
convolution integrals and the user-friendly implementation of complicated, often non-
local, boundary conditions, which cannot easily be tackled by standard methods, such
as boundary bordering (see e.g., [5, Chapter 6] and [50, Chapter 7]).

A natural extension of pseudospectral methods is the spectral element method
(SEM), which can be seen as combining a pseudospectral method with a higher-order
ﬁnite element method. The basis functions used by SEM, such as Chebyshev or
Lagrange polynomials, are typically of higher order than those used in FEM. Addi-
tionally, SEM generally uses Chebyshev–Lobatto collocation grids on each element, as
compared to a more standard equispaced grid in FEM. At the intersections between
the elements, continuity is enforced by imposing two matching conditions, usually
continuity of the solution and its ﬁrst derivative normal to the intersection, for PDE
problems that are second order in space; see [5, Chapter 22]. There are a number of
diﬀerent, but related, spectral element methods. One can consider the strong form of
the PDE and apply matching conditions on the intersections of the elements directly.
This is called the patching method, and was ﬁrst introduced by Orszag [37]. The
Galerkin spectral element method solves the weak form of a PDE model, and was
pioneered by Patera [38] using Chebyshev polynomials as basis functions, and later
adapted to Lagrange polynomials by Komatitsch and Vilotte [27], which is now the
standard choice [5, Chapter 22]. As shown in [21], for elliptic PDEs this approach is
essentially equivalent to the patching formulation. A third method for solving a PDE
using SEM is based on overlapping elements and was introduced by Morchoisne [35].
Spectral element methods have been applied to solve a range of problems. Some
of the earlier applications were in (classical) ﬂuid dynamics (see [8, Chapter 13] and
[9, Chapter 5]) and geosciences [27, 20]. Further applications of SEM include frac-
tional PDEs [29], relativity [40, 23], ﬁnancial modelling [57, 55, 56], and optimal
control problems with elliptic PDE constraints [11, 54, 12]. Often SEM is applied as
a higher-order ﬁnite element method, using a large number of elements with low de-
gree polynomials. However, some work has been done on domain decomposition and
‘multidomain’ methods, e.g., [40], that actively apply SEM to describe domains that
are more complicated. Examples of these include modelling blood ﬂow in veins, air-
craft engines, or ﬂows around airfoils [9, Chapter 5], ﬂows around obstacles [33], ﬂows
in petroleum reservoirs [48], seismic waves [27, 20], and sound propagation [28]. While
most existing work does not include non-local integral terms, some advances have been
made, see e.g., [33, 56, 17, 18]. These works consider diﬀerent, mostly one dimen-
sional, integral terms, which were tackled in the context of the (weak form) Galerkin

MULTISHAPE: A SPECTRAL ELEMENT METHOD

3

SEM formalism, using either Gaussian quadrature or Fast Fourier Transforms. Ad-
ditionally, the chosen boundary conditions do not involve convolution integral terms,
unlike those for the problems considered here.

The present work develops a multidomain spectral element method, called Multi-
Shape1, including an open-source software package [43], which is able to solve various
(integro-)PDE problems on complicated domains. This implementation includes the
application of complicated boundary conditions, such as (non-linear, non-local) no-
ﬂux conditions, as well as the eﬃcient solution of integro-PDEs, involving the eval-
uation of convolution integrals. For the problems considered in the present work,
this is a signiﬁcant improvement to the approaches taken in the previous works men-
tioned above. The work follows from the pseudospectral code library 2DChebClass
[36], extending this framework to a spectral element method, with minimal additional
eﬀort for the user. The ﬂexibility of the method is illustrated by a range of numerical
examples in Sections 3 and 5, demonstrating one of the main advantages of the imple-
mentation: its compatibility with various other numerical methods such as standard
ordinary diﬀerential equation (ODE) and state-of-the-art optimization algorithms. In
line with previous work, see [36, 1], we present examples that originate from Dynamic
Density Functional Theory (DDFT), which describes dynamic properties of systems
involving particles suspended in a ﬂuid. Applications of this theory range from math-
ematical biology, such as in bird ﬂocking or bacteria dynamics [34], through medicine,
such as in drug delivery [19], to social sciences, such as in opinion dynamics [22]. In
DDFT, complicated domains are often modelled by imposing steep potential gradi-
ents in parts of the domain, e.g., to model ﬂow through a constriction [58], or around
obstacles [42, 2], which can be computationally expensive due to large gradients in
the system. Here we demonstrate that spectral element methods are a valuable alter-
native to this method and solutions to DDFT-like problems on complicated domains
using SEM are illustrated in Section 5.

In summary, the present work makes the following signiﬁcant contributions:

• Open-source software for the computation of a broad range of (integro-)PDE

problems on complicated domains.

• Straightforward to interface with with other numerical schemes, including
diﬀerential–algebraic equation (DAE) solvers and optimization algorithms,
with problem set-ups being independent of the domain; one may readily re-
solve on a range of domains with essentially no additional coding eﬀort.
• User-friendly set-up, compatible with the 2DChebClass library and easily

adapted to new model problems.

• Easy application of naturally-arising complicated, non-linear, non-local bound-
ary conditions, which do not have to be written by the user in a problem-
speciﬁc way.

• Automated constructions of multishapes, whose elements can be deﬁned by

a combination of Cartesian and polar coordinates.

• Eﬃcient evaluation of convolution integrals on complicated domains, easily

applicable to a wide range of kernels.

The paper is structured as follows. In Section 2, the numerical method is introduced
In Section 3 the code is validated with some numerical tests. Section
in detail.
4 introduces the three applications considered in detail: an equilibrium model, an
integro-PDE model for particle dynamics, and a PDE-constrained optimal control

1We apply the convention that ‘MultiShape’, with capital letters, refers to our methodology as

a whole, while a lower-case ‘multishape’ refers to an individual shape (i.e., domain).

4

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

model. Furthermore, the numerical methods that are used in combination with SEM
are introduced. Section 5 presents some numerical results before we close with some
remarks in Section 6.

2. Construction of Numerical Methods. In this section a numerical method-
ology, called MultiShape, is developed to solve various types of PDEs on complicated
domains, including steady and time-dependent, non-linear and non-local PDEs, with
diﬀerent boundary conditions that can also include non-linear and non-local terms.
Other problems involving diﬀerentiation, interpolation, integration, or convolution,
such as ODEs or integral equations, can also be tackled using this framework. Multi-
Shape is a class in Matlab, and is based on 2DChebClass, an object oriented library
for solving PDEs on single elements. A multishape domain is deﬁned by a number
ne of simple elements, denoted by ei, i = 1, ..., ne. In the present work, quadrilateral
and wedge (section of an annulus) elements can be combined to construct the multi-
shape domain (a discretization of the problem-speciﬁc physical domain); see Figure
1 for an illustration. This can be straightforwardly extended to other shapes that
can be mapped (conformally) from/to the unit square (i.e., those used in standard
pseudospectral approaches).

Fig. 1. A multishape consisting of a quadrilateral and a wedge element. Displayed are collo-
cation points, highlighted boundary points, the intersection boundary between the two shapes, and
outward normal vectors.

Section 2.1 introduces an illustrative model and demonstrates how it is deﬁned
on a multishape. In Section 2.2 some of the important features of the 2DChebClass
library are outlined, relevant for the MultiShape library. Section 2.3 discusses the
diﬀerent class methods of the MultiShape implementation and Section 2.4 explains the
user interface and demonstrates how to solve a problem of the form (2.1), introduced
in Section 2.1, on a multishape domain.

2.1. Model Equations. The MultiShape framework applies to a broad range of
PDE models, some of which are introduced in Sections 3 and 4. In order to illustrate
some of the complexities that are successfully addressed by the MultiShape framework,

MULTISHAPE: A SPECTRAL ELEMENT METHOD

5

in this section we consider a system of non-linear, time-dependent (integro-)PDEs
with (non-local) no-ﬂux boundary conditions. This model is motivated by DDFT
applications, which account for diﬀerent species of interacting particles, and which
were also used as illustrative examples in previous work, see [36, 1]. For a system of
ns species with densities ρa, a = 1, ..., ns, conﬁned to a domain Ω ⊂ R2, the general
problem statement consists of a system of ns PDEs of the form

∂tρa((cid:126)x, t) = −∇ ·(cid:126)ja({ρb})

(2.1)

(cid:126)ja({ρb}) · (cid:126)n = 0

ρa((cid:126)x, t) = ρa,0((cid:126)x)

in Ω × (0, T ),

on ∂Ω × (0, T ),

at t = 0,

where(cid:126)ja is a ﬂux term and the notation(cid:126)ja({ρb}), b = 1, ..., ns, denotes that the ﬂux of
species a depends on the densities of all of the species. Note that the boundary condi-
tion is often referred to as ‘no-ﬂux’ and, in particular, enforces conservation of mass.
For DDFT applications, a common choice is to treat particle–particle interactions via
the mean-ﬁeld approximation [49], resulting in a ﬂux of the form

(cid:126)ja({ρb}) = −∇ρa((cid:126)x, t) − ρa((cid:126)x, t)∇Vext((cid:126)x, t) −

ns(cid:88)

b=1

ρa((cid:126)x, t)

(cid:90)

Ω

ρb((cid:126)x(cid:48), t)∇(cid:126)xVa,b(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48),

where Vext is an external potential and Va,b are interaction potentials between species
a and b.

We solve the strong form of (2.1) on each of the elements. Matching conditions
(patching) are applied at the intersection between two elements, and the PDE bound-
ary conditions applied on the multishape domain boundary. The matching conditions
between elements are

ρa,i((cid:126)x, t) = ρa,j((cid:126)x, t)
−(cid:126)ja,i · (cid:126)ni =(cid:126)ja,j · (cid:126)nj

on ∂Ωi,j × (0, T ),

on ∂Ωi,j × (0, T ),

where ∂Ωi,j denotes the intersection boundary between elements ei and ej, i, j =
1, ..., ne, and quantities of the form fa,i denote the value of f for species a on element
i. In line with work on SEM for (classical) ﬂuid dynamics problems, e.g., [9, Chapter
5], and since the system (2.1) is of interest in complex ﬂuid dynamics, it is a natural
choice to match the ﬂux (cid:126)ja({ρb}) at the intersection of two elements, as compared
to directly matching the ﬁrst derivative of ρa. For problems of the form (2.1) these
two approaches are essentially equivalent. The minus sign in the the ﬂux matching
condition arises due to the opposite orientation of (outward) normals for adjoining
elements. Note that particle species are denoted by subscripts a, b, while elements
have subscripts i, j.

2.2. 2DChebClass. The code library 2DChebClass, developed in [36], supports
the solution of systems of PDEs of the form (2.1), as well as other PDE models, in-
cluding the application of complicated boundary conditions, on individual elements.
Note that in the 2DChebClass library these elements are referred to as shapes. The
choice to solve the strong form of a PDE model and the use of a patching method
in MultiShape is motivated by the fact that 2DChebClass provides a strong solution
of a PDE on the individual elements. It is also advantageous for the end user, since
the weak form of the PDE problem does not have to be derived in order to use this
method; the PDE can be inputted directly as stated, e.g., in (2.1). The choice of

6

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

operator deﬁnitions and notation in MultiShape ensures that writing a PDE and the
corresponding boundary conditions can be done in a ‘natural’ way within the frame-
work. Additionally, as will be demonstrated in Section 2, extra care has been taken
to ensure that the implementation of (complicated, non-linear, non-local) boundary
conditions, as well as matching conditions between the elements, is straightforward
for the user and comparable to the 2DChebClass library. We brieﬂy outline some of
the features of 2DChebClass that are carried forward to the MultiShape library, and
which are explained in detail in [36]. In particular, the MultiShape implementation
aims to be intuitive for both 2DChebClass and new users.

Whilst pseudospectral methods are well suited to periodic problems, such domains
are not directly applicable in a spectral element setting. Hence, here we restrict
ourselves here to discussing the case in which each dimension of a square, [−1, 1], is
discretized using Gauss–Lobatto–Chebyshev collocation points, deﬁned as

xi = cos

(cid:19)

,

(cid:18) iπ
2

for i = 0, 1, ..., N − 1. In the two-dimensional domain [−1, 1]2, Kronecker products
are used to create a two-dimensional grid in the standard way [50, Chapter 7]. The
domain [−1, 1]2 is referred to as the computational domain and, using a bi-linear
map, it can be associated with a quadrilateral (in the case of 2DChebClass, only a
rectangular box is provided by default) or wedge element, which is referred to as the
physical domain. Note that for wedge elements, both the computational and physical
domain are deﬁned in polar coordinates. The interpolation polynomial on an element
is deﬁned using barycentric Lagrange interpolation [4]. In the 2DChebClass imple-
mentation ﬁrst and second (and, optionally, higher) order diﬀerentiation matrices are
constructed automatically on the discretized shape, as well as gradient, divergence,
and Laplacian operators for two-dimensional problems. These operators are construc-
ted on the computational domain [−1, 1]2 and then mapped onto the physical domain
using the aforementioned (inverse of the) bi-linear map, making it easy to deﬁne op-
erators on diﬀerent physical domains [5, Chapter 22]. For the evaluation of integrals,
Clenshaw–Curtis quadrature [13] is applied. For further details on the pseudospectral
implementation in 2DChebClass, we refer to [36].

2.3. Class Methods. In this section, technical aspects of the MultiShape im-
plementation, as a class in Matlab, are discussed, such as the construction of diﬀer-
entiation and interpolation matrices, integration vectors, convolution operators, and
the application of intersection conditions, all of which are deﬁned as class methods.
While many quantities can be computed on the individual elements ﬁrst, a key part
of the implementation is that all operators can be applied to the whole multishape
domain simultaneously, which is described in the following. Note that, since quadri-
lateral and wedge elements are deﬁned in two diﬀerent coordinate systems, Cartesian
and polar, the corresponding operators are deﬁned in terms of two diﬀerent coordinate
systems as well.

In line with the philosophy of the MultiShape code, it draws on the 2DChebClass
implementation for single shapes. Discretizing a function f on a multishape domain
is done by discretizing f on each element individually through 2DChebClass, and
stacking the resulting vectors into a vector of size M × 1. Here M = (cid:80)ne
1 N (i)
2 ,
where N (i)
are the number of points for element ei in the the x1 and x2 direc-
tions, respectively, and ne the number of elements in the multishape. The resulting

1 , N (i)

i=1 N (i)

2

MULTISHAPE: A SPECTRAL ELEMENT METHOD

7

discretized function is

fM ×1 =

















f1
f2
...
fne

,

where fi is a N (i)
2 × 1 vector, for i = 1, ..., ne. The same approach is taken when
constructing the integration vector for the multishape, which is a row vector of size
1 × M .

1 N (i)

The gradient, divergence, and Laplacian operators for a multishape are construc-
ted by computing the operators on each individual element, using 2DChebClass, and
arranging them in a block diagonal matrix, as demonstrated below for an operator D
acting on a function (vector) f

D1









Df =

D2

. . .









Dne









f1
f2
...
fne









.

Note that empty blocks in the above denote zeros. Computations can then be carried
out directly on the multishape, instead of on each element individually, since the
stacking ensures that the order of elements is preserved. A matrix Di corresponding
to element ei is applied only to fi, corresponding to the same element, within the
matrix–vector multiplication. Note that Di and Dj could be deﬁned in two diﬀerent
coordinate systems, depending on whether, for example, ei and ej are quadrilateral
or wedge elements.

Interpolating a function f from one grid onto another is another crucial function
of the MultiShape implementation. Accurate interpolation is relevant for plotting of
results, computation of convolutions with ﬁnite support, and evaluation of quantities
on subdomains, as well as comparing results evaluated on diﬀerent grids. Many
of these applications only require the interpolation matrices in computational space
[−1, 1]2 for each element individually, which can simply be stacked, as illustrated
above for the matrix D, and applied to a vector f . However, mapping a function f
from a set of points xin onto another arbitrary set of points xout, which is deﬁned in
physical (not computational) space, is more complicated than stacking the individual
interpolation matrices and applying these to f (xin). The reason for this is that it is
not clear a-priori in which element of the multishape the diﬀerent points within xout
lie. The code is equipped to determine this automatically for the user, by identifying
which of the xout lie in which shape. Once this is established, the interpolation matrix
for each element ei can be used to interpolate onto the set of points in that element,
xi,out.

In order to apply boundary and matching conditions we need to identify the
boundaries of the multishape and the intersections between individual elements. To
aid illustration, Figure 1 displays a multishape, consisting of two elements, with
marked intersection boundary, multishape boundary, and normal vectors to the bound-
ary. 2DChebClass is able to automatically compute the boundaries of a single element
ei, i = 1, ..., ne. It furthermore distinguishes the four parts, or faces, of the boundary,
i.e., ‘top’, ‘bottom’, ‘left’, and ‘right’ for a quadrilateral; inner and outer radial and

8

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

maximum and minimum angular boundaries for a wedge. We denote these faces by
fi,k, k = 1, 2, 3, 4. In order to ﬁnd the intersections between two elements, we have
to check whether the points on face fi,k of element ei are equal to those of face fj,l of
element ej for each possible combination of elements and faces. The ordering of the
points lying on face fi,k can also be the reverse of the order of points on fj,l, which
MultiShape checks automatically. Then, the multishape boundary can be found by
subtracting those intersection boundaries from the union of boundaries of the individ-
ual elements, leaving only those parts of the element boundaries that are not adjacent
to another element. In this way, the patching method is implemented – note that, in
principle, it is possible to modify this approach and admit the intersecting faces of
two elements to have diﬀerent numbers of points, then use MultiShape’s interpolation
function to match these. However, since a similar number of points is generally ex-
pected in neighbouring elements, this additional complexity is omitted in the current
implementation.

Constructing the normal vectors on the boundary of the multishape, which are
needed to compute no-ﬂux boundary conditions and intra-element matching condi-
tions, is a little more complicated. The starting point is again to consider the normals
for each individual element, provided by 2DChebClass, and in particular those lying
on the boundary of the multishape. However, at the intersection corners between
two elements, these normal vectors are not deﬁned consistently. In this case the code
considers the normal vectors on the multishape boundary to both sides of the inter-
section corner and averages them. In order to do this correctly, all normals ﬁrst have
to be converted into Cartesian coordinates, averaged, and converted back into polar
coordinates where appropriate. When the discretization of the multishape is more
complicated, taking the average of adjacent normals may not be suﬃcient, and the
resulting outward normal may not be sensible. Since this can be very speciﬁc to the
discretization at hand, the option to override any of the normal vectors manually is
given. Such a case is demonstrated in Figure 2.

Fig. 2. Overriding the normal vectors at intersection corners, which are automatically con-
structed by MultiShape, to ensure they are deﬁned in the normal direction to the multishape face on
which the intersection corner is located.

MULTISHAPE: A SPECTRAL ELEMENT METHOD

9

The computation of convolution integrals is the ﬁnal part of the MultiShape
implementation that we discuss here. Since computing a convolution integral is a
global operation, we cannot rely on reusing the computations on individual elements.
However, the general steps are equivalent to the approach for a single element and it
is therefore recommended to refer to [36] for details. A brief outline of constructing
the convolution matrix is given below. A convolution integral is deﬁned as

(ρ (cid:63) χ) ((cid:126)y) =

(cid:90)

Ω

χ ((cid:126)y − (cid:126)z) ρ ((cid:126)z) d(cid:126)z,

for a density ρ and a weight function, or kernel, χ. In the system (2.1), χ = ∇Va,b.
Given the integration vector, Int, for the multishape and deﬁning (cid:126)y − (cid:126)z := (cid:126)x, the
convolution matrix can be computed by

Convm,n = Intn χ

(cid:16)

1 − x(n)
x(m)

1 , x(m)

2 − x(n)

2

(cid:17)

,

where the subscripts 1 and 2 refer to the two dimensions of the domain, and m, n ∈
{1, ..., M }, with M the total number of points in the multishape. If the function χ
only takes one input, we consider

Convm,n = Intn χ

(cid:16)

(cid:107)d(m,n)
1

, d(m,n)
2

(cid:107)2

(cid:17)

,

1

2

:= x(m)

:= x(m)

1 − x(n)

2 − x(n)

1 , d(m,n)

where d(m,n)
2 , and (cid:107) · (cid:107)2 denotes the standard
Euclidean distance. The convolution integral is now deﬁned as a matrix–vector multi-
plication, by applying the matrix Conv to a density vector ρ. The convolution matrix,
which is independent of the density ρ, can be applied to diﬀerent functions, without
needing to be recomputed.
In particular, signiﬁcant computation time is saved in
outer routines, such as ODE solvers and optimization algorithms, in which the same
convolution matrix can be applied to an updated ρ at each step of the sub-routine.
This is contrasted by the fast Fourier transform (FFT) approach for solving convolu-
tion integrals [44]. Here, at each step in time a Fourier transform of ρ is taken, and
the convolution theorem is applied to yield

(ρ (cid:63) χ) ((cid:126)y) = F −1{F {ρ} · F {χ}}((cid:126)y).

It is clear that the present approach does not exhibit these complications, and there-
fore can lead to noticeable computational advantages when used within a sub-routine.

2.4. User Interface. This section illustrates how a multishape is set up by the
user and describes the information that needs to be provided in order to solve PDE
problem (2.1) on the multishape using the DAE solver ode15s in Matlab.

In order to set up a multishape, each element has to be deﬁned, as well as an
order in which they are arranged, from 1 to ne, although this ordering is essentially
arbitrary. For each element the number of discretization points, N1 in the x1-direction,
N2 in the x2-direction, needs to be speciﬁed. To uniquely determine a shape, for a
quadrilateral element it suﬃces to specify the corners; a wedge element is deﬁned in
polar coordinates, by specifying an inner and outer radius, a minimum and maximum
angle, and the location of the origin.

In PDE problems such as (2.1), matching conditions (see Section 2.1) are applied
at the intersections between two elements ei and ej. However other conditions can be
applied at the intersection boundary between two elements. For example, the Mul-
tiShape library additionally supports the application of no-ﬂux boundary conditions

10

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

between elements, modelling a hard wall, and the inclusion of other matching options
into the code library is straightforward. Which condition to apply on each intersec-
tion between elements ei and ej, can be speciﬁed simply by setting a ﬂag. The code
demonstrating how to set up a multishape, and provide the necessary geometrical
and numerical information, is found in Listing 1. The resulting multishape can be
seen in Figure 1. Note that, in order to create a functioning multishape, the number
of points of the neighbouring faces of two elements have to match, as discussed in
Section 2.3. Once the multishape is set up, required operators and properties, such as
diﬀerentiation matrices or the location of boundary points, can be simply extracted
from the multishape structure, as demonstrated in Listing 2.

Using MultiShape to discretize a PDE and apply boundary and intersection con-
ditions is straightforward. A discretized version of problem (2.1) can be deﬁned by
stacking ns discretized equations of the form

M ρ(cid:48)

a(t) = f ({ρb(t)}, t),

where the mass matrix M for a collocation method is diagonal, and f is the dis-
cretization of the right hand side of the PDE. The boundary and matching conditions
are applied by setting the relevant (diagonal) entries in the mass matrix to zero.
Discretizing the right-hand side of the PDE, f ({ρb(t)}, t), is illustrated in Listing 3.
The diﬀerentiation and convolution matrices are constructed automatically by the
MultiShape library and can be applied to a vector ρa using matrix–vector multiplica-
tion. The intersection conditions are applied via an inbuilt function, which uses the
intersection boundaries that are automatically identiﬁed during construction of the
multishape. The quantities to be provided are the solution, ρa, and the ﬂux, j({ρb}),
that are to be matched. Similarly, the code automatically identiﬁes the boundary of
the multishape, so that the boundary conditions of the PDE can be applied in the
same way as for single shapes in 2DChebClass. Note that the non-local no-ﬂux bound-
ary conditions of problem (2.1) are applied in Listing 3 in a single line of code (line
23), demonstrating the ease of implementation of complicated boundary conditions.
Additionally, this line can be replaced to apply other boundary conditions, such as
Dirichlet or Robin conditions. Note that several ‘helper functions’ are deﬁned within
MultiShape, which support straightforward implementation. These include masks to
access individual elements of the multishape, computation of inner products between
two vectors, and the application of intersection boundary conditions, as discussed in
Section 2.3.

In order to solve the model problem (2.1) using the Matlab DAE solver ode15s,
one needs to specify the right-hand-side of the discretized PDE as illustrated above, an
initial condition, a time interval, and a mass matrix, as well as the solver tolerances.
This is illustrated in Listing 4. Note that the codes in Listings 2, 3, and 4 are
independent of the speciﬁc multishape deﬁned in Listing 1. If one were to compute
the same PDE system on a diﬀerent multishape, the only part of the code that needed
to be amended would be in Listing 1, demonstrating the modularity of the code.

Listing 1
Setting up a multishape

1
2 % Number of points (note N2x1 = N1x1 since the numbers of points need
3 % to match at intersection boundaries)
4 N1x1 = 12; N1x2 = 15; N2x1 = N1x1; N2x2 = 15;

5

MULTISHAPE: A SPECTRAL ELEMENT METHOD

11

6 % For a quadrilateral:
7 % − specify corners and number of points
8 x1Min = 0; x2Min = 0; x1Max = 3; x2Max = 3;
9 geom1.Y = [x1Min,x2Min;x1Min,x2Max;x1Max,x2Max;x1Max,x2Min];
10 geom1.N = [N1x1;N1x2];
11 % − assign the geometry to be shape 1; specify that it is a quadrilateral
12 shapes(1).geom = geom1; shapes(1).shape = 'Quadrilateral';

13
14 % For a wedge:
15 % − specify inner/outer radius, minimum/maximum angle, and origin
16 rMin = 1; rMax = 4; thetaMin = 0; thetaMax = pi;
17 geom2.R in = rMin; geom2.R out = rMax;
18 geom2.th1 = thetaMin; geom2.th2 = thetaMax;
19 geom2.Origin = [4,3];
20 geom2.N = [N2x1;N2x2];
21 % − assign the geometry to be shape 2; specify that it is a wedge
22 shapes(2).geom = geom2; shapes(2).shape = 'Wedge';

23
24 % Match intersections between shape 1 and shape 2
25 BCs = struct; BCs(1,2).function = 'BCmatch';
26 % Construct multishape, given the shapes
27 MS = MultiShape(shapes);

Listing 2
Extracting operators

1 % Extract pre−computed operators from multishape MS: this improves
2 % performance of the ODE solve, since accessing structures in MATLAB
3 % is comparatively slow
4 grad = MS.Diff.grad; div = MS.Diff.div; Lap = MS.Diff.Lap; Int = MS.Int;
5 bound = MS.Ind.bound; normal = MS.Ind.normal;
6 intersections = MS.Ind.intersections;
7 x1 = MS.Pts.y1 kv; x2 = MS.Pts.y2 kv;

8
9 % Compute convolution matrix, for a kernel defined by a function V2Fun
10 Conv = MS.ComputeConvolutionMatrix(@V2Fun,true);

Listing 3
Discretizing the right-hand side of the PDE system

1 % Right−hand side function, including boundary & intersection conditions
2 function drhodt = drho dt(t,rhoab)

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

% Extract the individual species
rhoa = rhoab(1:end/2,:); rhob = rhoab(end/2+1:end,:);

% Define discretized PDE using known external potential vector
% (Vext), differentiation matrices (grad, div), and convolution
% matrices between species a and b (Convaa, Convab, Convbb, Convba)
rhoaflux = Flux(rhoa,rhob,Convaa,Convab);
drhoadt
rhobflux = Flux(rhob,rhoa,Convbb,Convba);
drhobdt

= −div*rhoaflux;

= −div*rhobflux;

% Apply matching conditions at intersections
dataa.rho = rhoa; dataa.flux = rhoaflux;
drhoadt = MS1.ApplyIntersectionBCs(drhoadt,dataa,BCs);
datab.rho = rhob; datab.flux = rhobflux;
drhobdt = MS1.ApplyIntersectionBCs(drhobdt,datab,BCs);

% Apply no flux boundary conditions at boundary

12

21

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

drhoadt(bound) = normal*rhoaflux; drhobdt(bound) = normal*rhobflux;
drhodt = [drhoadt;drhobdt];

22
23 end
24 function rhoFlux = Flux(rhoa,rhob,Convaa,Convab)

25

26

27

28

29 end

% Stack rho − this is now a size 2M x 1 vector
rhoa2 = MS.MakeVector(rhoa,rhoa); rhob2 = MS.MakeVector(rhob,rhob);

rhoFlux = −(grad*rhoa + rhoa2.*(grad*Vext) + ...

rhoa2.*(grad*(Convaa*rhoa)) + rhoa2.*(grad*(Convab*rhob)));

Listing 4
Solving a PDE system on a multishape using Matlab’s DAE solver

1 % Solving a system of PDEs using MATLAB's inbuilt DAE solver
2 % Set the mass matrix
3 mM = ones(size(x1));

4
5 mM(bound) = 0;
6 mM(intersections) = 0; % set to zero at intersections
7 MIn = diag([mM;mM]);

% vector of ones, of size M x 1
% M = length of discretized spatial domain
% set to zero at boundaries

% diagonal matrix to account for system of 2 PDEs

8
9 % Set options for ODE solver: relative & absolute tolerance, mass matrix
10 opts = odeset('RelTol',10ˆ−9,'AbsTol',10ˆ−9,'Mass',MIn);
11 % Solve ODE, given the following:
12 % − vector of time points comp times
13 % − initial condition rhoab ic
14 % − right−hand side function 'drho dt', computed in Listing 3
15 [outTimes, rhoab t] = ode15s(@drho dt,comp times,rhoab ic,opts);

3. Validation of MultiShape Methodology. This section contains validation
tests for our MultiShape implementation, investigating the accuracy of the diﬀerenti-
ation, integration, interpolation, and convolution operations. We further validate our
methodology by computing the solution to a Poisson equation with Dirichlet bound-
ary conditions. All of these tests have been carried out by comparing the numerical
results to analytic solutions. In all tests exponential convergence is observed, until a
certain threshold is reached, which is mostly dictated by machine precision, and to a
lesser extent by compounding precision or interpolation errors.

Most errors in this section are calculated using a relative numerical L2 norm

deﬁned as

(3.1)

E =

||fNum − fEx||L2
||fEx||L2 + 10−10 ,

where fNum and fEx correspond to numerical and exact solutions, and the additional
(arbitrary) small term in the denominator is added to avoid the possibility of division
by zero – the results do not change signiﬁcantly for other reasonable values. The inter-
polation error is calculated in the same way but replacing the L2 norm by a (vector)
(cid:96)∞ norm. This is because the error is calculated on a uniform grid and not a Cheby-
shev grid, so that computation of the L2 norm would require numerical integration in
uniform space, which would introduce larger integration errors than the Clenshaw–
Curtis integration formula [13] implemented in MultiShape. Since integration results
in a single number, for such computations, the L2 norm in (3.1) is replaced by taking
absolute values, with fNum and fEx the numerical and exact integrals, respectively.

MULTISHAPE: A SPECTRAL ELEMENT METHOD

13

3.1. Validation of Discretized Operators. The multishapes considered in
this validation section are discretizations of boxes and wedges. This is so that com-
parisons can be made with the 2DChebClass implementation for a single shape. The
diﬀerent discretizations considered for a variety of test cases can be seen in Figures 3
and 4. The four discretizations of a box in Figure 3 include a reference multishape,
discretizations with varying number of elements, uneven splits of the domain, as well
as a discretization that contains an interior point, at which four elements intersect,
(d). The wedge discretizations in Figure 4 include a reference multishape, a multi-
shape that is discretized in the radial direction as well as one in the angular direction,
and a discretization containing three elements.

Fig. 3. Diﬀerent multishape discretizations of a box (a–d).

The three diﬀerentiation operators, that is gradient, divergence, and Laplacian,
are validated by comparing against an exact solution. The test function considered is

(cid:32)

g1(x1, x2) = exp

−

(x1x2 − 1)2
20

(cid:33)

sin

(cid:18) x1x2
4

(cid:19)

,

which is also used to test the accuracy of the interpolation matrix. This is tested
by interpolating g1(x1, x2) onto a (uniform) target grid deﬁned by x1,U , x2,U and
comparing the result to g1 evaluated directly on the target grid. The choice of g1 is
largely arbitrary; similar results were obtained for a wide range of functions. This is
also the case with the functions chosen below for other validation tests. For integration
we choose the (Gaussian) test function

g2(x1, x2) = exp

(cid:16)

−x2

1 − x2
2

(cid:17)

.

14

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

Fig. 4. Diﬀerent multishape discretizations of a wedge (e–h).

To test the convolution operator we have two diﬀerent test functions

χC((cid:126)x) = exp

(cid:32)

(cid:33)

,

x2
1 − x2
2
10

nC((cid:126)z) = z2

1 + z1z2,

χP ((cid:126)x) = exp(x1 + x2),

nP ((cid:126)z) = exp

(cid:16)

−z2

1 − z2

2 + z1 + z2

(cid:17)

,

where χC, nC are considered for Cartesian discretizations and χP , nP are the test
functions on polar multishapes. This is to facilitate the analytical computation of the
convolutions.

The convergence resulting from computations with the Laplacian, divergence,
gradient, and interpolation matrices on diﬀerent discretizations can be seen in Fig-
ure 5. As expected, convergence to the exact solution is observed as the number of
discretization points is increased. For each discretization, the total number of points
in each of the x1 and x2 directions (over the whole multishape), denoted by NΣ,
remains the same. Since the overall number of points for each multishape is the
same, the computational cost for each discretization is ﬁxed and so the performance
of each discretization choice can be compared. For each multishape, the NΣ points are
equally distributed among the diﬀerent elements. However, as the following compari-
son demonstrates, a minimum number of points has to be allocated in each the x1 and
x2 directions and on each element of the multishape, in order to achieve optimal con-
vergence. Multishape (c) in Figure 3 is discretized into three elements in such a way
that the number of points in the x1 coordinate is split three ways, resulting in each
element only having NΣ/3 points in the x1 coordinate, and subsequently a poorer
overall convergence than, for example, in multishape (d). While multishape (d) is

MULTISHAPE: A SPECTRAL ELEMENT METHOD

15

discretized into four shapes, the x1 and x2 coordinate are only divided once, so that
each element has NΣ/2 points in each direction, improving convergence considerably.

Fig. 5. The error, as deﬁned by (3.1), in the numerical diﬀerentiation, integration, interpola-
tion, and convolution operators. Errors are computed for varying numbers of discretization points
NΣ and measured against an exact solution.

3.2. Poisson Equation. Having validated the convergence of diﬀerent opera-
tors on diﬀerent multishapes, for the next test we solve a Poisson equation. This
demonstrates that applying the intersection matching conditions between the ele-
ments of a multishape works as expected, without adding further complexities, such
as PDE solvers or integral terms. We solve the Poisson equation

(3.2)

∇2ρ((cid:126)x) = f ((cid:126)x)
ρ((cid:126)x) = u((cid:126)x)

in Ω,

on ∂Ω.

16

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

Fig. 6. The error, as deﬁned by (3.1), in computing the solution to the Poisson equation
on diﬀerent discretizations of a box and a wedge. Errors are computed for varying numbers of
discretization points NΣ and measured against an exact solution. [Note that for (c), with NΣ = 6
no interior points in x1 are present, so this data point is omitted.]

Fig. 7. The error, deﬁned by (3.1), in solving the Poisson equation on a multishape, against
computation time, for varying numbers of discretization points in the two coordinate directions, N1
and N2, for each element.

The right-hand side of the PDE,

(cid:18)(cid:16)

f ((cid:126)x) =

x2
1 − x1 − 0.75

(cid:16)

(cid:17)

+

x2
2 − x2 − 0.75

(cid:17)(cid:19)

(cid:16)

−0.5(x1 − 0.5)2 − 0.5(x2 − 0.5)2(cid:17)

,

exp

is chosen such that the Poisson equation on an inﬁnite domain

∇2u((cid:126)x) = f ((cid:126)x)
u((cid:126)x) → 0

in Ω,

as |(cid:126)x| → ∞.

has an exact solution, u((cid:126)x) = exp(−0.5(x1 − 0.5)2 − 0.5(x2 − 0.5)2). This can then
be used to test the accuracy for the numerical solution to the Poisson problem (3.2),
by enforcing the non-constant Dirichlet boundary conditions ρ((cid:126)x) = u((cid:126)x) on the
multishape boundary. As in Section 3.1, we test the convergence on the diﬀerent
discretizations of the box (Figure 3) and wedge (Figure 4), for varying number of
discretization points, as displayed in Figure 6. Similarly, the solution to the Poisson

MULTISHAPE: A SPECTRAL ELEMENT METHOD

17

equation on a multishape, which combines a quadrilateral and a wedge element, as
in Figure 1, is computed. Intersection matching conditions are applied between the
two elements as illustrated in Section 2.3. Note that the two elements are not deﬁned
in the same coordinate system, which MultiShape automatically takes into account
when applying the intersection condition. The three test cases considered involve
taking equal numbers of points in both coordinate directions, half the number of
points in the ﬁrst coordinate direction (x1 and r, respectively), and half the number
of points in the second coordinate direction (x2 and θ, respectively). We compare
the error in the numerical solution to the Poisson problem (3.2) with the resulting
computational timings. Figure 7 showcases the convergence of the numerical result to
the exact solution with increasing time, which correlates with increasing total numbers
of discretization points. The results in Figure 7 demonstrate that the distribution
of points among the coordinate directions does not result in a large diﬀerence in
computation time taken for comparable accuracy in the resulting solution. However,
the most eﬃcient discretization for the particular choice of multishape and Poisson
problem appears to be distributing double the points in the x2 and angular directions
than in the x1 and radial directions.

4. Applications and Model Equations. An important motivation for devel-
oping this MultiShape methodology is its application to Dynamic Density Functional
Theory and optimal control problems. For simple shapes, using 2DChebClass, some
such applications were tackled successfully in previous work [36, 1]. In the following
subsections, we will introduce the necessary theory, relevant models, and additional
numerical methods used in combination with the MultiShape implementation.

4.1. A Dynamic Density Functional Theory Model. Dynamic Density
Functional Theory (DDFT) describes how a one-body particle density ρ changes de-
pending on time and the free energy of the system F. This results in, often compli-
cated, integro-PDE models. A good overview of the various applications of the theory
is provided in [49]. In this work we focus on a DDFT model that includes particle
interactions via a mean-ﬁeld model, and leave more complex formulations that de-
scribe eﬀects such as (hard-core) volume exclusion for future study. This idea is easily
extended to a system with more than one particle species. The ns integro-PDEs that
describe the dynamics of a system with ns species of particles, with densities ρa, for
a = 1, ..., ns, are of gradient ﬂow form

(4.1)

∂ρa
∂t

(cid:18)

= ∇ ·

ρa∇

δF({ρb})
δρa

(cid:19)

,

where F is the Helmholtz free energy functional depending on all species b = 1, .., ns.2
The free energy of a system is composed of an ideal gas contribution, as well as con-
tributions from an external potential and from particle–particle interactions. Under
the mean-ﬁeld approximation, such a system has a free energy functional given by

F({ρb}) =

ns(cid:88)

(cid:90)

a=1

Ω

ρa(ln ρa − 1)d(cid:126)x +

(cid:90)

Ω

ρaVextd(cid:126)x

+

1
2

ns(cid:88)

ns(cid:88)

(cid:90)

(cid:90)

a=1

b=1

Ω

Ω

ρa((cid:126)x)ρb((cid:126)x(cid:48))Va,b(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48)d(cid:126)x,

2For consistency with the cost functional (4.5), we adopt the notation F ({ρb}). However, we note
that F [{ρb}] is the standard notation in the DDFT community, explicitly denoting the functional
dependence on {ρb}.

18

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

where Vext is an external potential and Va,b a potential, describing the interactions
between species a and b. Eq. (4.1) is exactly (2.1) introduced in Section 2.1, with
−ja = ρa∇ δF
δρa

. In this work, the interaction potential is given by

(4.2)

Va,b(x) = κa,b exp

(cid:16)

−(x/σa,b)2(cid:17)

,

where σa,b represents half of the distance between the centres of particle a and particle
b and with interaction strength κa,b. If a = b, this can be thought of as the particle
radius. Again, the results of the method are highly robust under diﬀerent choices of
Va.b (not shown here). Note that here the de Broglie wavelength Λ = 1, and kBT = 1.
After inserting the free energy into (4.1) we get a system of PDEs of the form

(4.3)

∂ρa
∂t

= ∇2ρa + ∇ · (ρa∇Vext) +

ns(cid:88)

b=1

∇(cid:126)x ·

(cid:90)

Ω

ρa((cid:126)x)ρb((cid:126)x(cid:48))∇(cid:126)x(cid:48)Va,b(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48),

with appropriate initial and boundary conditions. We focus here on no-ﬂux bound-
ary conditions, since they are some of the most complicated conditions to apply, in
particular for non-local problems, and are highly relevant for applications. These are
deﬁned as

ρa∇

δF
δρa

· (cid:126)n =

∂ρa
∂n

+ ρa

∂Vext
∂n

+

ns(cid:88)

(cid:90)

b=1

Ω

ρa((cid:126)x)ρb((cid:126)x(cid:48))

∂Va,b
∂n

(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48) = 0

on ∂Ω, where (cid:126)n is the outward normal and ∂
∂n denotes the partial derivative with
respect to this normal. To add some additional complexity, we consider the particle
dynamics of two species; the generalisation to more species is straightforward. This
system of integro-PDEs will be solved using Matlab’s inbuilt DAE solver ode15s,
which is demonstrated in detail in Listing 4. An illustrative numerical experiment for
a DDFT problem is shown in Section 5.2.

4.2. Equilibrium Solution of a DDFT Model. Often one is interested not
(only) in the time-dependent solution to the DDFT equations, but (also) in the long-
time, equilibrium solution. We would like to ﬁnd such a solution on multishape
domains. There are two equivalent approaches to ﬁnding these steady states; inves-
tigating the behaviour of (4.1) for large t, such that ∂ ρa
∂t ≈ 0, or minimizing F with
respect to ρa. Focusing on the latter approach, we solve the system of equations
δF
δρa

= 0, resulting in the non-linear equation

(4.4)

ρa = Z −1 exp

−Vext −



ρb((cid:126)x(cid:48))Va,b(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48)



 ,

ns(cid:88)

(cid:90)

b=1

Ω

where Z −1 is a normalization constant, enforcing that the mass of, and therefore the
number of particles in, the system is ﬁxed. This system of equations is of the form
ρa = Ga(ρ1, ..., ρns) and can be solved self-consistently using, for example, iterative
methods. As above, in this work, we are considering a system of two species, which
demonstrates all relevant features of the numerical solution, but this can can easily
be extended to systems with more species. In order to ﬁnd the solution to the self-
consistent system of equations (4.4), we use an iterative scheme, known as Picard
iteration in the DDFT community [44]. Algorithm 4.1 illustrates this scheme, given

MULTISHAPE: A SPECTRAL ELEMENT METHOD

19

initial guesses for the particle distributions ρ1,ig, ρ2,ig, an error tolerance to terminate
the algorithm, and a mixing parameter λ for the Picard step. The Picard step takes
a linear combination of the previous and new guesses for ρ1, ρ2, which is designed to
stabilize the algorithm. The error measure in this algorithm is deﬁned as the maximum
of the error across all species, individually computed using (3.1). A numerical example
of this formulation can be seen in Section 5.1.

Algorithm 4.1 Picard Equilibrium Solver
1: Set ρ1,ig, ρ2,ig, Tol, and λ.
2: Set ρ1,old = ρ1,ig, ρ2,old = ρ2,ig.
3: while E < Tol do
4:
5:
6:

Compute ρ1,new = G1(ρ1,old, ρ2,old), ρ2,new = G2(ρ1,old, ρ2,old).
Compute error E, deﬁned in (3.1).
if E ≥ Tol then

Set ρ1,update = (1 − λ)ρ1,old + λρ1,new, ρ2,update = (1 − λ)ρ2,old + λρ2,new.
Update ρ1,old = ρ1,update, ρ2,old = ρ2,update.

7:
8:
9:
10: end while

end if

Note that problems in equilibrium Density Functional Theory (DFT) also require
ﬁnding a minimum of a free energy F, and can therefore be tackled by such variational
approaches. An implementation is discussed in [44], while overviews of DFT are given
in, e.g., [16, 31, 52, 53].

4.3. Optimal Control with Non-Local PDE Constraints. Finally, we are
interested in solving an optimal control problem involving a system of two interact-
ing species of particles, such as in (4.3). Here the challenge is to apply a control to
the system, which is governed by the set of PDEs, so that the state approximates a
desired ‘target’ state, whilst also balancing the ‘cost’ of the control. This leads to
a particularly complicated system of four PDEs, with several convolution integrals
describing the diﬀerent interactions. This can be solved by combining MultiShape
with a recently-developed Newton–Krylov algorithm [24] for non-linear optimization
problems. The extended formalism to tackle non-local problems has been introduced
in [1] for single species systems on rectangular domains and is extended in this section
to multiple species on a multishape domain. Overviews of PDE-constrained optimiza-
tion are given in, e.g., [25, 14, 51]. For a system of ns species, we can formulate the
following optimal control problem

(4.5)

min
{ρa}, (cid:126)w

J ({ρa}, (cid:126)w) :=

1
2

ns(cid:88)

(cid:90) T

(cid:90)

a=1

0

Ω

(ρa − (cid:98)ρa)2 d(cid:126)xdt +

β
2

(cid:90) T

(cid:90)

0

Ω

| (cid:126)w|2d(cid:126)xdt,

subject to the following system of ns PDE constraints, for a = 1, ..., ns:

∂ρa
∂t

= ∇2ρa − ∇ · (ρa (cid:126)w) + ∇ · (ρa∇Vext)

+

ns(cid:88)

b=1

∇(cid:126)x ·

(cid:90)

Ω

ρa((cid:126)x)ρb((cid:126)x(cid:48))∇(cid:126)x(cid:48)Va,b(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48)

in Ω × (0, T ),

∂ρa
∂n

− ρa (cid:126)w · (cid:126)n + ρa

∂Vext
∂n

+

ns(cid:88)

(cid:90)

b=1

Ω

ρa((cid:126)x)ρb((cid:126)x(cid:48))

∂Va,b
∂n

(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48) = 0

on ∂Ω × (0, T ),

ρa((cid:126)x, 0) = ρa,0((cid:126)x)

at t = 0,

20

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

where T > 0. Note that the diﬀerence between the system of PDE constraints above
and the system (4.3) is the additional term involving (cid:126)w. This term models how a
particle distribution ρa may be inﬂuenced by a background ﬂow (cid:126)w. In this optimal
control problem, the aim is to drive the particle distributions ρa closer to some desired
states (cid:98)ρa, which can be achieved by modifying (cid:126)w, the control variable. Note that
in DDFT, (cid:126)w is generally of the form (cid:126)w = ∇V , where V is an external potential,
see [49] for a discussion on considerations of other forms of (cid:126)w and their limitations.
Enforcing this condition in an optimal control setting is more complicated, however,
since enforcing the gradient of the quantity we aim to control is a problem without a
unique solution. At present, we restrict ourselves to control via a general (cid:126)w as a test
case for the methodology. The regularization parameter β describes how much the use
of control is penalized when solving the system and consequently how close each ρa can
be driven to the targets (cid:98)ρa. This minimization is subject to the physical constraints
described by the system of PDEs and the corresponding boundary conditions. Such
an optimization problem can be solved by considering the corresponding ﬁrst-order
optimality system, applying the working in [1, Section 3]. It consists of the system of
PDE constraints and the adjoint PDE system where, for each species a, we have the
following PDE for the adjoint variable qa:

∂qa
∂t

= − ∇2qa − (cid:126)w · ∇qa + ∇Vext · ∇qa + (cid:98)ρa − ρa

ns(cid:88)

(cid:90)

+

b=1

Ω

ρb((cid:126)x(cid:48)) (cid:0)∇qa((cid:126)x) − ∇qb((cid:126)x(cid:48))(cid:1) · ∇Va,b(|(cid:126)x − (cid:126)x(cid:48)|)d(cid:126)x(cid:48),

with boundary condition ∂qa
part of the ﬁrst-order optimality system is a single gradient equation

∂n = 0 and ﬁnal time condition qa((cid:126)x, T ) = 0. The ﬁnal

(cid:126)w = −

1
β

ns(cid:88)

a=1

ρa∇qa.

This system of PDEs for the densities and adjoints (ρa and qa) is solved by com-
bining the MultiShape methodology with a Newton–Krylov algorithm, introduced in
[24] and extended to non-local problems with non-linear controls in [1] – we refer to
these references for detailed descriptions. The idea of the algorithm is that a residual
vector function is constructed based on the integral in time of the residuals of the
state and adjoint equations, deﬁned at every time step. The integrals are approx-
imated using Chebyshev interpolation on the time grid (also using 2DChebClass),
whereupon the residual vector is supplemented by the misﬁt between the computed
and exact initial/ﬁnal-time conditions. This allows us to construct the Jacobian via
spatial discretization at each time step, whereupon the resulting Newton systems are
approximately solved using the GMRES method [45] in combination with a Kronecker-
product based preconditioner for the Schur complement matrix. We show numerical
results for such a problem in Section 5.3.

5. Numerical Examples. In this section, problems involving the models intro-
duced in Section 4 are solved numerically on a multishape, with appropriate intersec-
tion conditions applied between multishape elements. Throughout this section, initial
conditions for ρa, a = 1, 2, are of the form

(5.1)

ρa,ic =

cM fa,ic
(cid:82)
Ω fa,icd(cid:126)x

.

MULTISHAPE: A SPECTRAL ELEMENT METHOD

21

Note that the model problems considered in this section are presented in order of
increasing computational complexity instead of in the order in which the models were
introduced in Section 4. All tests are carried out on Dell PowerEdge R430 running
Scientiﬁc Linux 7, four Intel Xeon E5-2680 v3 2.5GHz, 30M Cache, 9.6 GT/s QPI
192 GB RAM and are tested using Matlab Versions 2020a–2021b.

5.1. Equilibrium Solution of a DDFT Model. We ﬁrst solve an example
involving the model equations introduced in Section 4.2, describing the equilibrium
properties of a system with two interacting particle species. For this example, a
multishape is deﬁned using three elements: two quadrilaterals and one wedge, see
Figure 8. The number of points on each shape is N1 = N2 = 20, chosen as a bal-
ance between accuracy and computation time, as informed by the validation tests
presented in Section 3. We choose the parameters of the problem as follows.
In-
teraction strengths, for an interaction potential of the form (4.2), are κ1,1 = −7,
κ2,2 = −3, κ1,2 = κ2,1 = 2, with σ1,1 = 0.1, σ2,2 = 1, σ1,2 = σ2,1 = 0.55. This simu-
lates Species 1 being signiﬁcantly smaller than Species 2, with intra-species attractive
potentials and inter-species repulsion. We furthermore impose an external potential
Vext = 0.1x2, simulating gravitational forces acting on the particles. While the equi-
librium results are robust for diﬀerent choices of initial conditions, we choose ρ1,ic,
ρ2,ic of the form (5.1), with cM = 1 and f1,ic = exp (cid:0)−0.5(x1 − 1)2 − 0.5(x2 − 3.3)2(cid:1),
f2,ic = exp (cid:0)−0.3(x1 − 1.8)2 − 0.3(x2 − 2)2(cid:1), since they are relatively far from both
the equilibrium and each other. With this choice of initial conditions, Algorithm 4.1,
with λ = 0.5 and a termination tolerance of 10−8, converges to an equilibrium state
within 266 iterations, taking 6 seconds. The initial conditions, the equilibrium so-
lution, as well as the convergence of the free energy of the system, are displayed in
Figure 8. In the equilibrium solution, the interplay between the gravitational forces
and particle interactions can be observed. Since Species 1 and 2 repel each other,
they are found to separate within the domain. Furthermore, since Species 1 is smaller
in size than Species 2, it clusters at the boundary of the domain, while Species 2
accumulates in the middle. The eﬀect of the gravitational potential is evident when
considering the proportion of Species 1 at the top and bottom of the domain. Since
gravity is acting on the particles, it is more natural for the particles to accumulate
near the bottom of the domain. Species 2 is also subject to gravitational forces, since
without gravity it would be located in the top part of the domain. Increasing the
gravitational force, while keeping the interactions the same, forces Species 2 down-
wards towards Species 1, while causing a steeper accumulation of particles of Species
1 in the bottom corner. However, this is not shown in Figure 8 in the interest of
brevity.

5.2. Time-Dependent Solution of a DDFT Model. We now consider an
example of the dynamic model introduced in Section 4.1, which models a funnel
through which particles of diﬀerent sizes are passing. There are two types of particles
in the system, one species being larger than the other. We expect that smaller particles
should pass through the narrow part of the funnel more easily than the larger particles.
We introduce an external potential Vg = cgx2, modelling gravity, with cg = 0.15.
The left and right walls of the funnel are repulsive; a simple way to approximate
volume exclusion eﬀects. Since the two species are of diﬀerent sizes, the repulsion is
of diﬀerent strengths. The external potential, modelling the repulsive walls, is deﬁned
, where dL and dR are the shortest
as Vrep = (cid:15)
(Euclidean) distances to the left and right boundary of the multishape respectively.

exp (cid:0)−(dL/α)2(cid:1) + exp (cid:0)−(dR/α)2(cid:1)(cid:17)

(cid:16)

22

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

Fig. 8. Equilibrium solution for a two species system on a multishape. Bottom right: Con-
vergence of the free energy F , measuring the log change in F shifted by the ﬁnal value of the free
energy Fﬁn in order to compare the diﬀerences in free energy rather than absolute values.

We choose (cid:15) = 0.6, α1 = 0.5 for Species 1, α2 = 2 for Species 2. The interactions
between particles are again described by the potential (4.2), with κ1,1 = κ2,2 = κ1,2 =
κ2,1 = 0.1 and corresponding σ1,1 = 0.5, σ2,2 = 2, σ1,2 = σ2,1 = 1.25. The choice of
σ2,2 is motivated by the fact that the narrow channel in the multishape has width 2.
The initial conditions for each species are of the form (5.1), with f1,ic = f2,ic = x1 + 5
and cM = 20. The time interval for this simulation is t ∈ [0, 20], and each element in
the multishape is discretized using N1 = N2 = 20 points. The DAE solver ode15s,
with absolute and relative tolerances set to 10−9, takes around 20 seconds to solve this
problem and the result is displayed in Figure 9. It is evident that the behaviour of the
two species is qualitatively diﬀerent. Due to their size, the larger particles gather in
the middle of the funnel, while the smaller particles gather at the boundaries. Both
species experience the repulsion from the funnel boundary, but Species 2 accumulates
noticeably further away from the walls than Species 1, due to their larger size. This
arrangement causes the larger particles to be blocked by the smaller particles in
entering the narrow part of the funnel, exacerbated by the fact that the particles repel
each other. Both species are aﬀected by gravitational forces, so that sedimentation
can be observed and, over time, more particles accumulate in the bottom part of the
domain. However, since the ﬁrst part of the narrow channel is curved, some particles
accumulate in this section of the domain before travelling downwards.

5.3. Optimal Control with Non-Local PDE Constraints. Finally, we com-
pute results for a ﬂow control problem of the form introduced in Section 4.3 on
four elements, with N1 = N2 = 14 discretization points in space on each element
and n = 10 points in the time interval t ∈ [0, 5]. Note that the normal vec-
tor at the intersection of the four elements (see Figure 10 for reference) has to be
correctly deﬁned in a manual fashion, as illustrated for a simpler test case in Fig-
ure 2. We choose two interacting particle species with σ1,1 = 0.5, σ2,2 = 1, with
κ1,1 = −0.8, κ1,2 = 0.6, κ2,1 = 0.2, κ2,2 = −0.3. External potentials are imposed
(cid:1) and Vext,2 =
for each species: Vext,1 = 0.05 (cid:0)exp (−0.1(x1 − 2)2 − 0.1(x2 − 1)2) − x2

MULTISHAPE: A SPECTRAL ELEMENT METHOD

23

Fig. 9. Dynamics of two interacting species of diﬀerent size in a funnel under the inﬂuence of

gravitational forces.

0.1 (cid:0)exp (−0.3(x1 − 3)2 − 0.3(x2 − 4)2) + 2x2
(cid:1). The initial conditions for ρ1 and ρ2
are deﬁned by (5.1), where f1,ic = f2,ic = exp (−0.15(x1 + 0.5)2 − 0.15(x2 − 5)2) and
cM = 1. We choose β = 10−3, allowing a signiﬁcant amount of control to be in-
troduced into the system, so that we expect to get reasonably close to the target
states (cid:98)ρ1 and (cid:98)ρ2. The targets are deﬁned by a forward problem with the same initial
conditions and external potential, with a background ﬂow of strength 0.1 in the x1
direction (along the channel in the wedge case). Without imposing control (i.e., with
(cid:126)w = (cid:126)0), we can evaluate the cost functional (4.5), which results in Juc = 0.0038 (‘uc’
referring to ‘uncontrolled’). The value of the cost functional for the optimized sys-
tem is Jc = 1.7571 × 10−4, showcasing that the overall cost obtained is signiﬁcantly
reduced when the optimal control is introduced. We can observe that both species of
particles are carried along by the background ﬂow ﬁeld (optimal control) over time.
Since Species 1 experiences an upward force, it accumulates in the top-right part of
the channel system at later times. Equivalently, since Species 2 experiences a down-
ward acting force, it accumulates in the bent part of the channel on the bottom right
at later times of the simulation. It takes around 3 hours to solve this optimal control
problem, which converges within 10 iterations of the Newton–Krylov algorithm, to a
residual error of order 10−13 and 10−15 for the state and adjoint variable, respectively.

6. Conclusions. In this paper, we have presented a new spectral element imple-
mentation, which allows for the eﬃcient solution of (integro-)PDE models on compli-
cated domains, including the application of non-linear and non-local boundary condi-
tions. A general numerical framework has been introduced, building on the existing
code library 2DChebClass for pseudospectral methods, and with a speciﬁc emphasis
on user-friendly features, such as the simple application of matching and boundary
conditions. After successful validation of the MultiShape methodology, various nu-
merical examples were discussed, ranging from steady state problems, through solving
(integro-)PDE models, to optimal control problems. These examples have been cho-
sen in view of their relevance to Dynamic Density Functional Theory, which describes

24

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

Fig. 10. Optimal states ρ1 and ρ2 with superimposed optimal control (cid:126)w.

various industrial processes, as well as phenomena in physics and biology. There are
many possible extensions to this work, such as applying the MultiShape methodology
to solve more complicated DDFT models, capturing eﬀects such as sedimentation, hy-
drodynamic interactions, or inertia. Further future challenges include modelling and
optimization of industrial processes, for example in manufacturing and production.
Other areas of research, which could potentially beneﬁt from applying the MultiShape
methodology, include models of pedestrian dynamics, brewing, and spread of diseases
on complicated domains.

Acknowledgments. JCR is supported by The Maxwell Institute Graduate School

in Analysis and its Applications (EPSRC grant EP/L016508/01), the Scottish Fund-
ing Council, Heriot-Watt University, and The University of Edinburgh. BDG acknowl-
edges support from EPSRC grant EP/L025159/1; RM-W was funded by EPSRC IAA
PIII075; JWP from EPSRC grant EP/S027785/1. BDG and RM-W would like to
thank Tim Hurst, Andreas Nold, and Seraﬁm Kalliadasis for helpful discussions.

REFERENCES

[1] M. Aduamoah, B. D. Goddard, J. W. Pearson, and J. C. Roden, Pseudospectral meth-
ods and iterative solvers for optimization problems from multiscale particle dynamics, to
appear in BIT Numerical Mathematics, 2021, https://arxiv.org/abs/2009.09850.
[2] L. Almenar and M. Rauscher, Dynamics of colloids in conﬁned geometries, Journal of

Physics: Condensed Matter, 23 (2011), p. 184115.

[3] M. S. Alnaes, J. Blechta, J. Hake, A. Johansson, B. Kehlet, A. Logg, C. Richardson,
J. Ring, M. E. Rognes, and G. N. Wells, The FEniCS project Version 1.5, Archive of
Numerical Software 3, (2015).

[4] J.-P. Berrut and L. N. Trefethen, Barycentric Lagrange interpolation, SIAM Review, 46

(2004), pp. 501–517.

[5] J. P. Boyd, Chebyshev and Fourier Spectral Methods, Dover Publications, Inc., 2000.
[6] S. C. Brenner and L. R. Scott, The Mathematical Theory of Finite Element Methods, Texts

in Applied Mathematics; 15, Springer, New York, N.Y, 3rd ed., 2008.

[7] H. Bridle, B. Miller, and M. P. Desmulliez, Application of microﬂuidics in waterborne

pathogen monitoring: A review, Water Research, 55 (2014), pp. 256–271.

[8] C. Canuto, M. Y. Hussaini, A. Quarteroni, and T. A. Zang, Spectral Methods in Fluid

Dynamics, Springer Berlin Heidelberg, 1988.

MULTISHAPE: A SPECTRAL ELEMENT METHOD

25

[9] C. Canuto, A. Quarteroni, M. Y. Hussaini, and T. A. Zang, Spectral Methods: Evolution
to Complex Geometries and Applications to Fluid Dynamics, Springer Berlin Heidelberg,
Berlin, Heidelberg, 2007.

[10] J. Carrillo, R. Gvalani, G. Pavliotis, and A. Schlichting, Long-time behaviour and phase
transitions for the McKean–Vlasov equation on the torus, Archive for Rational Mechanics
and Analysis, 235 (2020), pp. 635–690.

[11] Y. Chen and F. Huang, Spectral method approximation of ﬂow optimal control problems with
H 1-norm state constraint, Numerical Mathematics: Theory, Methods and Applications,
10 (2017), pp. 614–638.

[12] Y. Chen, N. Yi, and W. Liu, A Legendre–Galerkin spectral method for optimal control prob-
lems governed by elliptic equations, SIAM Journal on Numerical Analysis, 46 (2008),
pp. 2254–2275.

[13] C. W. Clenshaw and A. R. Curtis, A method for numerical integration on an automatic

computer, Numerische Mathematik, 2 (1960), pp. 197–205.

[14] J. C. De los Reyes, Numerical PDE-constrained optimization, SpringerBriefs in Optimization,

Springer, 2015.

[15] F. Erdogdu, F. Sarghini, and F. Marra, Mathematical Modeling for Virtualization in Food

Processing, vol. 9, Food Engineering Reviews, 2017.

[16] R. Evans, The nature of the liquid-vapour interface and other topics in the statistical mechanics

of non-uniform, classical ﬂuids, Advances in Physics, 28 (1979), pp. 143–200.

[17] F. Fakhar-Izadi and M. Dehghan, Space–time spectral method for a weakly singular parabolic
partial integro-diﬀerential equation on irregular domains, Computers & Mathematics with
Applications, 67 (2014), pp. 1884–1904.

[18] F. Fakhar-Izadi and M. Dehghan, A spectral element method using the modal basis and its
application in solving second-order nonlinear partial diﬀerential equations, Mathematical
Methods in the Applied Sciences, 38 (2015), pp. 478–504.

[19] F. Fang, J. Satulovsky, and I. Szleifer, Kinetics of protein adsorption and desorption on
surfaces with grafted polymers, Biophysical Journal, 89 (2005), pp. 1516–1533.
[20] A. Fichtner, H. Igel, H.-P. Bunge, and B. L. Kennett, Simulation and inversion of seismic
wave propagation on continental scales based on a spectral-element method, Journal of
Numerical Analysis, Industrial and Applied Mathematics, 4 (2009), pp. 11–22.
[21] D. Funaro, A multidomain spectral approximation of elliptic equations, Numerical Methods

for Partial Diﬀerential Equations, 2 (1986), pp. 187–205.

[22] B. D. Goddard, B. Gooding, H. Short, and G. Pavliotis, Noisy bounded conﬁdence models
for opinion dynamics: the eﬀect of boundary conditions on phase transitions, IMA Journal
of Applied Mathematics, 87 (2022), pp. 80–110.

[23] P. Grandcl´ement and J. Novak, Spectral methods for numerical relativity, Living Reviews

in Relativity, 12 (2009), pp. 1–103.

[24] S. G¨uttel and J. W. Pearson, A spectral-in-time Newton–Krylov method for nonlinear PDE-

constrained optimization, IMA Journal of Numerical Analysis, 42 (2022), p. 1478–1499.

[25] M. Hinze, R. Pinnau, M. Ulbrich, and S. Ulbrich, Optimization with PDE Constraints,

Mathematical Modelling – Theory and Applications; vol. 23, Springer, 2009.
[26] Y. Jaluria, Advanced Materials Processing and Manufacturing, Springer, 2018.
[27] D. Komatitsch and J.-P. Vilotte, The spectral element method: An eﬃcient tool to simulate
the seismic response of 2D and 3D geological structures, Bulletin of the Seismological
Society of America, 88 (1998), pp. 368–392.

[28] W. H. Lin, A least-squares spectral element method for sound propagation in acoustic ducts,

The Journal of the Acoustical Society of America, 104 (1998), pp. 3111–3114.

[29] A. Lischke, M. Zayernouri, and Z. Zhang, Spectral and spectral element methods for frac-
tional advection–diﬀusion–reaction equations, in vol. 3, Numerical Methods, G. E. Karni-
adakis, ed., De Gruyter, 2019, pp. 157–184.

[30] A. Logg, K.-A. Mardal, and G. N. Wells, eds., Automated Solution of Diﬀerential Equa-

tions by the Finite Element Method: The FEniCS Book, Springer, 2012.

[31] H. L¨owen, Melting, freezing and colloidal suspensions, Physics Reports, 237 (1994), pp. 249–

324.

[32] A. Lozinski and C. Chauviere, A fast solver for Fokker–Planck equation applied to viscoelas-
tic ﬂows calculations: 2D FENE model, Journal of Computational Physics, 189 (2003),
pp. 607–625.

[33] A. Lozinski, C. Chauvi`ere, J. Fang, and R. G. Owens, Fokker–Planck simulations of fast
ﬂows of melts and concentrated polymer solutions in complex geometries, Journal of Rhe-
ology, 47 (2003), pp. 535–561.

[34] A. M. Menzel, A. Saha, C. Hoell, and H. L¨owen, Dynamical density functional theory for

26

J. C. RODEN, R. D. MILLS-WILLIAMS, J. W. PEARSON, AND B. D. GODDARD

microswimmers, The Journal of Chemical Physics, 144 (2016), p. 024115.

[35] Y. Morchoisne, Inhomogeneous ﬂow calculations by spectral methods: mono-domain and

multi-domain techniques, SIAM-CBMS, 181 (1984).

[36] A. Nold, B. D. Goddard, P. Yatsyshin, N. Savva, and S. Kalliadasis, Pseudospectral
methods for density functional theory in bounded and unbounded domains, Journal of Com-
putational Physics, 334 (2017), pp. 369–664.

[37] S. A. Orszag, Spectral methods for problems in complex geometries, Journal of Computational

Physics, 37 (1980), pp. 70–92.

[38] A. T. Patera, A spectral element method for ﬂuid dynamics: Laminar ﬂow in a channel

expansion, Journal of Computational Physics, 54 (1984), pp. 468–488.

[39] N. A. Peppas and B. Narasimhan, Mathematical models in drug delivery: How modeling has
shaped the way we design new drug delivery systems, Journal of Controlled Release, 190
(2014), pp. 75–81.

[40] H. P. Pfeiffer, L. E. Kidder, M. A. Scheel, and S. A. Teukolsky, A multidomain spec-
tral method for solving elliptic equations, Computer Physics Communications, 152 (2003),
pp. 253–273.

[41] S. S. Rao, The Finite Element Method in Engineering, Butterworth-Heinemann, Oxford,

5th ed., 2010.

[42] M. Rauscher, A. Dom´ınguez, M. Kr¨uger, and F. Penna, A dynamic density functional
theory for particles in a ﬂowing solvent, The Journal of Chemical Physics, 127 (2007),
p. 244906.

[43] J. C. Roden, R. D. Mills-Williams, J. W. Pearson, and B. D. Goddard, MultiShape.

https://bitbucket.org/bdgoddard/multishapepublic/src/master/, 2022.

[44] R. Roth, Fundamental measure theory for hard-sphere mixtures: a review, Journal of Physics:

Condensed Matter, 22 (2010), p. 063102.

[45] Y. Saad and M. H. Schultz, GMRES: A generalized minimal residual algorithm for solving
nonsymmetric linear systems, SIAM Journal on Scientiﬁc and Statistical Computing, 7
(1986), pp. 856–869.

[46] K. D. Seibert, P. C. Collins, C. V. Luciani, and E. S. Fisher, Milling operations in the
pharmaceutical industry, in Chemical Engineering in the Pharmaceutical Industry: Active
Pharmaceutical Ingredients, D. J. am Ende and M. T. am Ende, eds., Wiley Online Library,
2019, pp. 861–879.

[47] M. Smith, ABAQUS/Standard User’s Manual, Version 6.9, Dassault Syst`emes Simulia Corp,

United States, 2009.

[48] A. Taneja and J. Higdon, A fully-coupled discontinuous Galerkin spectral element method
for two-phase ﬂow in petroleum reservoirs, Journal of Computational Physics, 352 (2018),
pp. 341–372.

[49] M. te Vrugt, H. L¨owen, and R. Wittkowski, Classical dynamical density functional theory:
from fundamentals to applications, Advances in Physics, 69 (2020), pp. 121–247.

[50] L. N. Trefethen, Spectral Methods in MATLAB, SIAM, Philadelphia, PA, 2000.
[51] F. Tr¨oltzsch, Optimal Control of Partial Diﬀerential Equations : Theory, Methods and Ap-
plications., Graduate Studies in Mathematics; vol. 112, American Mathematical Society,
2010.

[52] J. Wu, Density functional theory for chemical engineering: From capillarity to soft materials,

AIChE Journal, 52 (2006), pp. 1169–1193.

[53] J. Wu and Z. Li, Density-functional theory for complex ﬂuids, Annual Review of Physical

Chemistry, 58 (2007), pp. 85–112.

[54] J. Zhou and D. Yang, Spectral mixed Galerkin method for state constrained optimal control
problem governed by the ﬁrst bi-harmonic equation, International Journal of Computer
Mathematics, 88 (2011), pp. 2988–3011.

[55] W. Zhu and D. A. Kopriva, A spectral element approximation to price European options. II.
The Black-Scholes model with two underlying assets, Journal of Scientiﬁc Computing, 39
(2009), pp. 323–339.

[56] W. Zhu and D. A. Kopriva, A spectral element method to price European options. I. Single
asset with and without jump diﬀusion, Journal of Scientiﬁc Computing, 39 (2009), pp. 222–
243.

[57] W. Zhu and D. A. Kopriva, A spectral element approximation to price European options with
one asset and stochastic volatility, Journal of Scientiﬁc Computing, 42 (2010), pp. 426–446.
[58] U. Zimmermann, F. Smallenburg, and H. L¨owen, Flow of colloidal solids and ﬂuids through
constrictions: dynamical density functional theory versus simulation, Journal of Physics:
Condensed Matter, 28 (2016), p. 244019.

