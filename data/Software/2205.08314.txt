2
2
0
2

n
u
J

2

]
E
S
.
s
c
[

2
v
4
1
3
8
0
.
5
0
2
2
:
v
i
X
r
a

Self-Sovereign Identity as a Service:
Architecture in Practice

Yepeng Ding
The University of Tokyo
Tokyo, Japan
youhoutei@satolab.itc.u-tokyo.ac.jp

Hiroyuki Sato
The University of Tokyo
Tokyo, Japan
schuko@satolab.itc.u-tokyo.ac.jp

Under the assumption of the cryptographic veriﬁability of
identities and associated information, the only trust in SSI is
that veriﬁers trust issuers managing identities in an impartial
manner. Therefore, it naturally forms a decentralized architec-
ture. However, SSI has not been completely standardized and
requires to be optimized for different scenarios in practice.
Although the conceptual aspects of SSI have been intensively
discussed, the architectural aspects and implementations are
still in infancy.

Abstract—Self-sovereign identity (SSI) has gained a large
amount of interest. It enables physical entities to retain own-
ership and control of their digital identities, which naturally
forms a conceptual decentralized architecture. With the support
of the distributed ledger technology (DLT),
it is possible to
implement this conceptual decentralized architecture in prac-
tice and further bring technical advantages such as privacy
protection, security enhancement, high availability. However,
developing such a relatively new identity model has high costs
and risks with uncertainty. To facilitate the use of the DLT-
based SSI in practice, we formulate Self-Sovereign Identity as
a Service (SSIaaS), a concept that enables a system, especially
a system cluster, to readily adopt SSI as its identity model for
identiﬁcation, authentication, and authorization. We propose a
practical architecture by elaborating the service concept, SSI, and
DLT to implement SSIaaS platforms and SSI services. Besides,
we present an architecture for constructing and customizing
SSI services with a set of architectural patterns and provide
corresponding evaluations. Furthermore, we demonstrate the
feasibility of our proposed architecture in practice with Selﬁd,
an SSIaaS platform based on our proposed architecture.

Index Terms—self-sovereign identity, distributed ledger tech-
identity management,

software engineering, digital

nology,
blockchain, architectural pattern

I. INTRODUCTION

Self-sovereign identity (SSI) uses a user-centric mechanism
that enables users to retain ownership of their identities and
have full control of using them. Besides, users cannot append,
modify, or remove any identity information without being
detected. Hence, we conventionally call users as holders.
Authorities, also called issuers, play the role of issuing,
updating, and revoking identities. Third parties requesting to
verify the issued identities are called veriﬁers. We depict
a conceptual diagram in Figure 1. In SSI, holders obtain
endorsed credentials, i.e., a set of claims associated with their
identities, from issuers. Whenever holders are required to
prove their identities or credentials by veriﬁers, they select and
present a subset of credentials with proofs to veriﬁers after
proving their identities. With or without directly interacting
with issuers, veriﬁers can verify the validity of presented
credentials based on proofs. All
types of participants are
centered around identities owned and controlled by holders.

This is the preprint version of the conference paper ”Self-Sovereign Identity
as a Service: Architecture in Practice” in 2022 IEEE 46th Annual Computers,
Software, and Applications Conference (SAPSE 2022 Workshop).

Fig. 1: Conceptual diagram of self-sovereign identity (SSI).

Distributed ledger technology (DLT) has been widely used
to enhance the security and privacy of systems in many ﬁelds
such as ﬁnance [1], Internet of Things [2], data engineering
[3], and smart health [4] on account of its decentralization
characteristics. It enables immutable data persistence and
processing without central entities. Particularly, there has been
a growing interest in the adoption of blockchain technology,
a type of DLTs, since the launch of the ﬁrst cryptocurrency
named Bitcoin. Furthermore,
the blockchain has been put
into industrial production as a service to facilitate the use of
DLTs in practice, which is called Blockchain as a Service
(BaaS). According to speciﬁc demands, both permission-
less blockchains and permissioned blockchains are available
through the service. Although the permissioned blockchain
service is usually based on cloud infrastructure, it still im-
proves the security of internal business services by decentral-
izing the conventional central entities, preventing the single
point of failure, and ensuring integrity. Therefore, the adoption
of DLTs, especially blockchain technology, has become a
remarkable architectural decision to construct decentralized
systems, including SSI systems.

However, the application of the DLT-based SSI has not been

 
 
 
 
 
 
widely accepted in the industry due to its architecture risk and
high implementation complexity. Motivated by standardizing
the architecture of the DLT-based SSI, advocating its appli-
cation in practice, and making it adapt to various scenarios
with minimized efforts, we formulate and practicalize Self-
Sovereign Identity as a Service (SSIaaS), a concept
that
promotes SSI to a service level, to facilitate the interoperable,
customizable and scalable use of SSI as an identity model in
systems. We summarize our main contributions as follows.

• We propose a novel SSIaaS architecture that elaborates
the service concept, SSI, and DLT for the implementation
of SSIaaS platforms;

• We formulate a technical architecture for SSI services
with a collection of architectural patterns for SSI service
components and evaluate them in detail to provide in-
sights on architectural decisions;

• We show Selﬁd, an SSIaaS platform based on our archi-

tecture to demonstrate the feasibility in practice.

II. RELATED WORK

DLTs have been used to support decentralized authentication
and authorization of digital identities in recent years. In [5],
a blockchain-based IAMs is proposed to provide identity
authentication and reputation management functionalities. In
the context of the Internet of Things, an identity authentication
scheme [6] is proposed for multi-WSN based on a hybrid
blockchain model consisting of a private blockchain and a
public blockchain. Bloccess [7] is proposed as an authorization
framework based on a consortium blockchain to provide strong
access control for distributed systems.

Besides, signiﬁcant efforts have been made to implement
SSI based on DLTs. For instance, Sovrin [8] is a public
and permissioned identity network operational on the Hyper-
ledger Indy. It implements selective disclosure based on zero-
knowledge proof (ZKP) techniques to enhance privacy. The
SSI model in Sovrin is implemented based on permissioned
blockchains. Therefore, although it is open to the public, its
trust is addressed by the reputations and non-collusion of
nodes.

Different from Sovrin, uPort [9] is an identity management
identities are
system based on Ethereum and IPFS. uPort
implemented by smart contracts deployed on the Ethereum
while the credentials and proﬁle data are stored on the IPFS.
And a Registry Contract offers a cryptographic link between
an on-chain identiﬁer and its corresponding off-chain data.
Furthermore, uPort provides wallets for users to facilitate the
management of their identities.

From these SSI implementations, we ﬁnd that a higher level
can be abstracted by deconstructing them and aggregating
functionally similar components only with different patterns.
After the abstraction, we can regard each implementation as
a service.

For the architectural perspective of services, BaaS is an-
alyzed in a comprehensive way ranging from techniques to
trust considerations in [10]. And in [11], NutBaas is proposed
and developed as a BaaS platform that provides blockchain

services over cloud computing environments such as network
deployment, system monitoring, as well as smart contracts
analysis and testing.

To the best of our knowledge, self-sovereign identity as
a service has not been systematically studied. Our work
formulates this concept and focuses on its architectural aspect.

III. SELF-SOVEREIGN IDENTITY AS A SERVICE

A. Overview

SSIaaS encapsulates SSI-based functionalities as a service
and presents as a platform that provides application program-
ming interfaces (APIs) for external invocation. The conceptual
architecture of SSIaaS is depicted in Figure 2.

There are four types of roles: service provider, service
consumer, user, and veriﬁer. Different from the conventional
service providers, SSIaaS providers may not deploy all ser-
vices in their cloud infrastructures. In extreme cases, they
simply act as mediators who provide middlewares to facilitate
interactions between service consumers and distributed ledgers
hosting actual services. Service consumers are subscribers of
SSI services. Although the concrete business model may affect
the interaction between providers and consumers, it is out of
the scope of this paper. Notably, service consumers in SSIaaS
can also be service providers providing other types of services
for their user groups. Users can be regarded as consumers of
the services provided by service consumers in SSIaaS. The
mapping from user group set to user set is surjective, i.e.,
each user belongs to at least one user group served by its
corresponding service consumer. Nevertheless, the mappings
from user group set to service consumer set and from service
consumer set to service set are bijective. Hence, a service
consumer can only manage the identities and credentials of
its served user group. Veriﬁers play the same role as in SSI
to verify credentials presented by users.

As we can see in Figure 2, running services are managed
by a service provider through an SSIaaS platform and interact
with distributed ledgers. A service is more like a gateway and
a front-end, while a distributed ledger is the actual execution
environment for SSI functionalities. Therefore,
the service
provider and platform are not always necessary for service
consumers to use SSI functionalities, though they seem to be
in the central place of all relations. According to the concrete
scenario, a service needs either a permissionless distributed
ledger or a permissioned distributed ledger. Hence, the relation
is general,
between service set and distributed ledger set
i.e., non-surjective and non-injective. For instance, a public
blockchain, as a type of permissionless distributed ledger, can
theoretically host a ﬁnite set of services.

B. Self-Sovereign Identity Architecture

We formulate a technical SSI architecture for service con-
struction that is depicted in Figure 3. The architecture contains
all three roles of SSI: holder, issuer, and veriﬁer. Technically,
a holder is represented by an agent that facilitates register-
ing decentralized identiﬁers (DIDs) and veriﬁable credentials
(VCs), requesting VCs from issuers, storing VCs, composing

Fig. 2: The conceptual architecture of self-sovereign identity as a service (SSIaaS).

veriﬁable presentations (VPs), and presenting VPs to veriﬁers.
Therefore, a holder agent acts as a client. Similarly, an issuer
(or veriﬁer) agent, either a DID issuer agent or a VC issuer
agent, provides interfaces for issuers (or veriﬁers) to interact
with holder agents and the veriﬁable data registry (VDR),
which also acts as a client. Besides, a VDR is responsible
for creating, modifying, revoking, and verifying DIDs and
VCs, which acts as a server. It is notable that if the VDR
is controlled by the issuer with a centralized mechanism, then
this architecture can be regarded as a variant of the client-
server architecture, which will not be discussed further in this
paper. Mainly, public-key cryptography is used to generate and
verify proofs of VCs.

and veriﬁes them through the VDR on behalf of a veriﬁer.

Therefore, we can build various services based on this SSI
architecture by customizing the technical parts: holder agent,
issuer agent, veriﬁer agent, and VDR.

C. Service Architecture

An SSI service is a minimal element in SSIaaS, which
serves a service consumer and is uniformly managed by the
service provider. As shown in Figure 4, an SSI service consists
of four components: Data Component (D), Wallet Component
(W), Endorsement Component (E), and Veriﬁcation Compo-
nent (V). Each component corresponds to a technical part of
the SSI architecture illustrated in Section III-B.

Fig. 3: Self-sovereign identity architecture for service con-
struction.

We can map concepts in this architecture to concepts in
SSIaaS. A user is abstracted as a holder who controls VCs
issued by service consumers via a holder agent. A service
consumer not only has issuer functionalities to issue VCs
but also has the additional responsibility to link DIDs to
corresponding physical
identities via an issuer agent. The
actual execution of the management functions is handled by
the subscribed running service that provides full functionalities
of the VDR. The concepts of the veriﬁer in SSI and SSIaaS are
equivalent. A veriﬁer agent authenticates users, requests VPs,

Fig. 4: Self-sovereign identity service architecture.

1) DID Registration Protocol: This protocol implements
that a user U with an identity Iu obtains a DID Du from a
service consumer S and registers Du in D.

1) U generates a pair of keys (PKu, SKu) via W;
2) U sends proof documents that support Iu and PKu to

S;

3) If Iu is approved, S uses E to generate Du together
with the DID document R(Du) that includes PKu, DID

controller of S, and veriﬁcation methods. Then Du is
returned to U ;

4) U uses W to invoke DIDRegistration(Du, [Sigu]) func-
tion of D through W, where Sigu = S(Du) is a
signature signed with SKu and an optional parameter
only needed for delegated registration purposes;

5) D authenticates U by checking whether U can re-
cover challenging message M from its encoded form
E(M, PKu) or authenticates the DID subject in delega-
tion scenarios by verifying Sigu with PKu in R(Du);

6) If

the

authentication

succeeds, D stores

tuple
(Du, H(R(Du))) to the underlying distributed ledger.
Then a ﬁnalized transaction is returned to U and saved
in W.

2) VC Registration Protocol: This protocol is executed by
a user U with a credential Cu to obtain a VC VCu from a
service provider S and register VCu in D.

1) U sends proof documents of Cu to S;
2) E of S authenticates U by PKu in R(Du);
3) If the authentication succeeds and Cu is approved, E
generates VCu with proof Pu = P(H(VCu)) signed
with SKs. Then VCu and Pu are returned to U ;

4) U uses W to sign H(VCu) with SKu and get a signature
Sigu, and invoke VCRegistration(Du, VCu, Pu, Sigu)
function of D through W;

5) D authenticates U in the same manner as in the DID
Registration Protocol. Additionally, D checks the equiv-
alence of the authenticated Du and the DID in the VC
subject to verify that U is the subject of VCu;

6) If the authentication succeeds, D veriﬁes the integrity of
VCu by checking the existence of S and Pu with PKs
obtained from VCu;

7) If the integrity checking succeeds, D stores H(VCu)
to the underlying distributed ledger. Then a ﬁnalized
transaction is returned to U and saved in W.

s, SK(cid:48)

Any direct modiﬁcation of Cu in VCu will be easily detected
by checking Pu under the trust of the cryptography. We discuss
two cases that bypass the integrity veriﬁcation: proof forgery
and issuer masquerade. In the ﬁrst case, U tampers with Cu,
PKs, and Pu at the same time with a self-generated key
pair (PK(cid:48)
s). However, VCu will be rejected because PK(cid:48)
s,
points to an unrecognized service consumer. In the second
case, U uses a service consumer S(cid:48) to masquerade as S to
bypass the existence checking. Although the execution of the
VC Registration Protocol succeeds, veriﬁers can still detect the
masquerade by the VC Veriﬁcation Protocol illustrated next
and reject VCu issued by a falsiﬁed S.

3) VC Veriﬁcation Protocol: A veriﬁer V uses this protocol
to verify a presented VC VCu issued by a service provider S
and from a user U .

1) V of V checks the status of VCu by querying the
existence of H(VCu) in the distributed ledger and con-
ﬁrming the non-existence of a revoking mark;

2) If the status checking succeeds, V authenticates U by
checking whether U can recover challenging message

M from its encoded form E(M, PKu) where PKu is
obtained from the presented VCu;

3) If the authentication succeeds, V checks the equivalence
of PKs in VCu and the one obtained from S to verify
that VCu is issued by the actual S;

4) If the existence checking succeeds, V veriﬁes the in-

tegrity of VCu by checking Pu with PKs;

5) If the integrity checking succeeds, V can admit the

validity of VCu.

For the existence checking of the VC Veriﬁcation Protocol,
V obtains the real PKs by a name service, a module of service
management controlled by the service provider, which will be
illustrated in Section III-E3. Besides, S can provide a double-
check method by making PKs public in a trustworthy manner
(e.g., hosting an ofﬁcial web application).

D. Service Architectural Patterns

All four components are decoupled but follow common
interfaces and generalized protocols, which infers that any
architectural changes within a component do not affect the
others. Therefore, services can be constructed from all kinds
of combinations of feasible architectures of these interoperable
components, enabling services to have heterogeneous archi-
tectures while preserving the same SSI functionalities. We
formulate and analyze a set of architectural patterns for each
component and make all components customizable to adapt to
a wide range of scenarios.

1) Data Component: As a fundamental component, D is
responsible for implementing functionalities of the VDR that
facilitates to register, update, revoke, and query DIDs and VCs.
• The registering functionalities are implementations of the
DID Registration Protocol and VC Registration Protocol
in Section III-C. Data required to be stored in the
distributed ledger such as hash values are included in
emitted DID (VC) Registered Events.

• The updating functionalities use similar protocols to
store modiﬁed information about DIDs and VCs in the
distributed ledger and emit DID (VC) Updated Events.
Since users cannot modify DIDs and VCs without being
detected, the updating protocols are executed by service
consumers to make authorized updates.

• The revoking functionalities are also used by service
consumers to store revoking marks that indicate the in-
validation of the target DIDs or VCs by emitting Revoked
Events in the distributed ledger.

• The query functionality is implemented based on a linear
search protocol in timestamp-reverse order to return the
latest information and status of the target DIDs and VCs.
We formulate three architectural patterns: permissionless
pattern, permissioned pattern, and sub-ledger pattern. An SSI-
aaS platform supporting all types of patterns can distinguish
them by the identiﬁers of DID methods.

a) Permissionless Pattern: In this pattern, D implements
the VDR functionalities by interacting with a permissionless
distributed ledger such as a public blockchain with a proof-

c) Sub-Ledger Pattern: A sub-ledger is a slave dis-
tributed ledger that interacts with a permissionless distributed
ledger as its master ledger. Sub-ledgers are usually permis-
sioned distributed ledgers that afford a certain amount of
computing work for their master chains. Consequently, this
pattern has a hybrid architecture that inherits merits from both
permissioned and permissionless distributed ledgers.

We depict this pattern in Figure 6. This pattern uses a sub-
ledger as an interface for external interactions. The sub-ledger
implements functionalities of the VDR in a similar way as the
permissioned pattern. Besides, a cross-ledger communicator is
responsible for packaging a set of operations enforced on the
sub-ledger into a bundle and periodically storing its metadata
on the master ledger.

based consensus mechanism. The abbreviation of the adopted
blockchain deﬁnes the identiﬁer for the DID method.

For instance, smart contracts that implement data and event
persistence can be deployed on Ethereum during the initial-
ization of D. In this manner, D can use application binary
interfaces (ABIs) to interact with these smart contracts to
implement full functionalities of the VDR.

b) Permissioned Pattern: This pattern constructs the
VDR based on a permissioned distributed ledger such as a
consortium blockchain or a private blockchain with a voting
or multi-party consensus mechanism. Platform-speciﬁc smart
contracts are implemented to support the same VDR function-
alities. However, the CDL-based and PDL-based architectures
have signiﬁcant differences compared to the permissionless
distributed ledger.

For the adoption of a CDL, the service provider manages a
global authorization system to authorize third parties to hold
nodes that contribute computing power to the CDL, which is
shown in Figure 5a. This architecture implements the VDR for
all provided SSI services based on one CDL. Since this pattern
is mainly managed by the service provider, the identiﬁer for
the DID method is deﬁned as the abbreviation of the name of
the service provider.

If a service consumer chooses to use a PDL for a service,
then the service provider allocates computing resources in-
cluding a local authorization system and nodes. In other words,
each SSI service has its unique VDR and authorization system,
which is shown in Figure 5b. The identiﬁer for the DID method
is deﬁned as the abbreviation of the name of the service.

Fig. 6: Sub-ledger pattern.

Evaluation of Patterns for Data Component: The Per-
missionless Pattern has better security properties, including
integrity and availability, compared to the Permissioned Pat-
tern due to its proof-based consensus mechanisms that are
fully decentralized and not controlled by service providers.
However, these consensus mechanisms have low transaction
throughput and lead to low efﬁciency of writing protocols
of D such as Registering, Updating, and Revoking. Besides,
permissionless distributed ledgers are usually large and contain
vast amounts of irrelevant data, which causes low efﬁciency
of reading protocols such as Querying.

The Permissioned Pattern makes trade-offs between security
and efﬁciency. It has higher transaction throughput than the
Permissionless Pattern. Since the consortium blockchain is
governed by service providers, it requires trust between the
consumer and provider. As for the private blockchain, com-
puting resources are provided by service consumers. Hence,
service consumers have full control of the security of D. In
each case, integrity and availability are potentially vulnerable
due to the existence of centralized entities.

The Sub-Ledger Pattern makes the balance between the
Permissionless Pattern and the Permissioned Pattern by adopt-
ing a hybrid architecture. It improves the efﬁciency of the

(a)

(b)

Fig. 5: Permissioned Pattern with a consortium ledger in
Figure 5a or a private distributed ledger in Figure 5b.

Permissionless Pattern and enhances the integrity of the Per-
missioned Pattern. However,
it has lower availability than
the Permissionless Pattern and costs higher computing power
consumption than the Permissioned Pattern.

2) Wallet Component: W is encapsulated into a holder
agent. Its main function is to facilitate holders to manage
DIDs and VCs including requesting, registering, composing
VPs, and presenting VPs. We formulate two architectural
patterns: online pattern and ofﬂine pattern. Both patterns share
the common interface to interact with the other components,
though their implementations are signiﬁcantly different.

a) Online Pattern: This pattern uses an online storage
system to store a DID and VCs for a holder. With the holder’s
permission, W stores the DID document and the obtained VCs
to an online storage system, retrieves them to compose VPs,
and presents them to the veriﬁer on demand. An online storage
system can be a cloud storage system or a decentralized
storage system such as IPFS.

Notably, both will be vulnerable without cryptographic
measurements to protect security and privacy. A cloud storage
system has a centralized mechanism that faces issues such as
single point of failure and data tampering. A decentralized
storage system is transparent, i.e., anyone with a correct link
can retrieve the corresponding data from the system, which
can cause privacy violations and credential leakage. Therefore,
it requires cryptographic algorithms and carefully formulated
protocols [12]. Two types of cryptographic algorithms are
commonly available. Symmetric cryptography (e.g., Advanced
Encryption Standard) can be used to generate a secret key
for encryption. The key is locally protected by W, and only
encrypted data are stored on an online storage system. By
using asymmetric cryptography (e.g., Elliptic Curve Digital
Signature Algorithm), a holder can use the public key to
encrypt data and store them online while keeping the private
key in W.

b) Ofﬂine Pattern: The ofﬂine pattern uses a native
management system that stores a DID and VCs for a holder.
A holder has complete control of the system. Besides, the
system can protect DIDs and VCs by introducing authentica-
tion mechanisms such as password authentication, public-key
cryptography, and biometric authentication.

Evaluation of Patterns for Wallet Component: The Online
Pattern has good scalability, recoverability, and portability for
both cloud-based storage and decentralized storage solutions.
A cloud-based storage solution is more extensible than a
decentralized storage solution because it can support other
types of computing services besides storage. Nevertheless, a
centralized mechanism lowers its availability and integrity.
On the contrary, a decentralized storage solution has better
security properties but lacks extensibility.

The Ofﬂine Pattern shifts the security problem of protecting
DIDs and VCs to holders. It has better privacy than the Online
Pattern but requires extra efforts to scale up and recover stored
data. Without the backup functionality, it is impossible to
recover data if the ofﬂine device is lost. Furthermore, the

implementation of the native management system could be
platform-speciﬁc, which leads to poor potability.

Notably, private key protection plays a critical role in
authentication security in either case. If a private key associ-
ated with a DID is leaked, then the identity proved by that
key can be stolen together with all credentials. Therefore,
enabling multi-factor authentication in W is a good option for
service consumers to enhance authentication security. Service
providers can use fast IDentity Online (FIDO) techniques to
provide customizable multi-factor authentication functionali-
ties.

3) Endorsement Component: E serves DID issuers and
VC issuers to facilitate issuing DIDs and VCs, as well as
managing them. It functions partially when integrated into a
DID Issuer Agent or a VC Issuer Agent. In the case where
service consumers issue and manage both DIDs and VCs, E
works with full functionalities.

An issuer can consist of one or multiple entities. For the
multi-entity case, the trust of an endorsement can be enhanced
by a multi-review mechanism. A DID or a VC can only be
issued when a set of entities have reviewed and approved it. We
formulate two architectural patterns for the multi-entity case:
multisignature pattern and secret-sharing pattern. For brevity,
we take E for VC issuers for example, while E for DID issuers
works in the same manner.

a) Multisignature Pattern: This pattern implements a
controller that dispatches a credential decoded from a VC
request with proof documents to a set of randomly selected
entities and collects their signatures. If all signatures are
aggregated, the controller will sign a VC for the credential
and notify W. Otherwise, the controller will reject the VC
issuing process. This mechanism is based on a multisignature
scheme [13]. The signing power of VCs is shared amongst all
entities. In a t-threshold scheme, a subset of t + 1 entities can
jointly sign VCs, but a smaller subset cannot.

b) Secret-Sharing Pattern: A secret-sharing scheme is
implemented in this pattern, such as Shamir’s Secret Sharing
[14]. Assume an issuer consists of n entities. In the initial
stage, the controller encrypts the private key for signing VC
with a secret key and divides the secret key into n parts, and
dispatches a random part to each entity. In a (t, n)-threshold
scheme, to sign a VC for a credential with the encrypted
private key, at least t issuers have to review and approve that
credential by submitting their parts of the key to the controller.
By collecting t parts of the secret key, the controller can
reconstruct the private key to sign a VC.

Evaluation of Patterns for Endorsement Component:

The Multisignature Pattern protects the private key of signing
VCs in a decentralized manner. All issuing entities hold and
protect their individual private keys for signing. A VC is
signed if and only if a certain amount of signatures are
aggregated. Therefore, this pattern is resilient to key leakage.
Nevertheless, the multisignature scheme is limited to speciﬁc
digital signature algorithms (DSAs).

The Secret-Sharing Pattern protects the private key of
signing VCs by encryption. Each issuing entity holds a part

of the secret key for decryption. Only when a certain amount
of parts is collected, a VC can be signed with the decrypted
private key reconstructed from collected parts. It can support
various DSAs, but its security highly depends on the secret
safety.

4) Veriﬁcation Component: V encapsulates interactions
with W and D to facilitate veriﬁers to verify the validity of
DIDs and VPs, which is an essential part of a veriﬁer agent.
We present two architectural patterns for V: service pattern
and host pattern.

a) Service Pattern: In this pattern, a service provider pro-
vides a veriﬁcation service that implements functionalities of
V. Service consumers can subscribe to the veriﬁcation service
and delegate functionalities of V to the service provider. In this
manner, veriﬁers verify obtained VPs via veriﬁcation services
provided by service providers.

b) Host Pattern: Software development kits (SDKs) im-
plemented with full functionalities of V are distributed to ser-
vice consumers in this pattern. Service consumers can develop
a customized veriﬁcation system based on the provided SDKs.
The developed veriﬁcation systems are used to serve veriﬁers
to verify VPs.

Evaluation of Patterns for Endorsement Component:

The Service Pattern is ready-to-use for service consumers to
provide veriﬁcation functionalities for veriﬁers without de-
velopment and computing resources. Correspondingly, service
consumers have limited control of veriﬁcation requests and
can hardly extend functionalities.

On the contrary, the Host Pattern gives service consumers
full control of veriﬁcation requests and ﬂexibility of adding
new functionalities such as authenticating veriﬁers. However,
it requires service consumers to make extra efforts to develop
and deploy veriﬁcation systems based on SDKs.

E. Service Management

From the perspective of service providers, an SSIaaS
platform needs to support customizing service components,
mapping requests to corresponding functionalities or services,
monitoring service status. We illustrate four main modules
including Parser, Gateway, Name Service, and Monitor.

1) Parser: As illustrated in Section III-D, there are many
kinds of service architectures derived from combinations of
architectural patterns. To instantiate a customized service, a
service consumer creates a speciﬁcation ﬁle that contains a
collection of selected architectural patterns for each compo-
nent with concrete parameters in YAML format, and sends an
encapsulated request to Gateway.

After receiving a request from Gateway, Parser executes a
parsing algorithm to generate a build program according to
the parsed speciﬁcation. Then the generated build program
is executed to build all components, generate client and
server applications based on the components, create execution
environments (e.g., isolated networks and containers), deploy
the server applications to the environments, and return the
client applications.

requests.

requests:

requests and external

2) Gateway: There are two types of

inter-
nal
requests are
management-level requests sent from service consumers and
service providers, while external requests are service-level
requests sent from users and veriﬁers. The Gateway recog-
nizes legitimate requests and dispatch them to corresponding
functionalities or services.

Internal

The internal requests are sent to internal modules such as
Parser and Monitor. Gateway allocates a speciﬁc channel to
pass these requests and isolate them from external requests.

A service provider can manage numerous services that are
distributed in many networks. And the physical addresses of
these services may not be static. Therefore, these requests only
contain service identiﬁers assigned to running services. To map
service identiﬁers to their latest IP addresses, Name Service is
required.

3) Name Service: Name Service is used to identify service
consumers and services. It provides various query function-
alities for querying identity information of service consumers
such as DIDs, public keys, public service identiﬁers, and meta-
information about their real identities. Typical usage is for the
veriﬁcation of the existence of service consumers. Besides, it
serves the Gateway to support queries of service information
such as service IP addresses based on service identiﬁers.

4) Monitor: As a service platform, both service providers
and consumers have demands of monitoring running services
for the purposes such as data analysis and exception catching.
Monitor provides functionalities of collecting service data such
as requests and status of nodes in speciﬁc services. These data
can also be used for security audits, especially regarding the
use of Permissioned Pattern.

IV. SELFID

Selﬁd is an SSIaaS platform with full-ﬂedged features
and functionalities illustrated in Section III. As a platform,
Selﬁd provides full support for service providers to manage,
maintain, and extend all types of functionalities. Although the
implementations of different modules vary in programming
languages and tech stacks (e.g., Parser implemented in Java,
Gateway in C++, Name Service in Rust, and Monitor in Go),
all modules concretize our proposed service protocols with
the same speciﬁcation of data exchange and communication
protocols. Furthermore, Selﬁd provides uniﬁed JSON-style
application programming interfaces (APIs) for service con-
sumers. Therefore, the whole platform can be regarded as an
interoperable service that can be integrated into existing sys-
tems to provide ﬂexible and scalable SSI-based functionalities.
For each SSI service, we deﬁne common interfaces and gen-
eralized protocols for all components to make them interopera-
ble and independent of their internal architectures. Besides, all
architectural patterns formulated in Section III-D are uniﬁed in
our SSIaaS platform to enable customizability. In this manner,
service consumers can individualize their services and adopt
optimal combinations without considering implementation de-
tails and integration compatibility. Selﬁd also allows service
consumers to transfer data from an existing service to another

with a different service architecture while preserving SSI-
related functionalities. In principle, each service is assigned
to a unique network location where its server applications are
deployed to a Docker container after being built by Parser.
Consequently, services are relatively isolated from each other
but uniformly managed by a container orchestration system
(Kubernetes in our case). With the support of Gateway and
Name Service, services are also portable and independent of
their physical environments.

Particularly, we adopt Ethereum as the underlying dis-
tributed ledger in the Permissionless Pattern and implement
a collection of smart contracts in Solidity. In Permissioned
Pattern, both CDL and PDL are developed based on the Hy-
perLedger Fabric with customizable consensus mechanisms.

V. DISCUSSION

We discuss our SSIaaS architecture with respect to interop-

erability, customizability, and scalability.

a) Interoperability: Identities registered in an SSI service
are globally usable and can cross various system implemen-
tations. Besides, each SSI service consists of four relatively
independent components that are low in coupling and high in
cohesion. As illustrated in Section III-C, components commu-
nicate with each other without the requirement of obtaining
the internal status of the target. We demonstrate syntactic in-
teroperability by implementing common interfaces via JSON-
style APIs in Selﬁd. Furthermore, semantic interoperability is
also achieved in our architecture, which can be seen by the
generalized protocols in Section III-C and service management
modules in Section III-E.

b) Customizability: As shown in Section III-D, a col-
lection of architectural patterns are available for service con-
sumers to customize their services. Thanks to interoperability,
architectural decisions can adapt customized SSI services to
speciﬁc scenarios without changing SSI functionalities.

c) Scalability: Theoretically, an SSI service has better
scalability than centralized identity services due to the non-
necessity of storing and maintaining identities controlled by
users. As the number of users increases, the cost should at
most increase linearly. But in practice, additional factors need
to be taken into consideration. In our SSIaaS architecture, the
Data Component dominates the cost owning to the adoption of
the DLT. Therefore, the scalability is also signiﬁcantly affected
by the consensus mechanism of distributed ledgers, especially
in the Permissionless Pattern and Sub-Ledger Pattern.

VI. CONCLUSION

As a promising identity model, SSI is changing the way
of digital identity management and well suits Web3 [15].
By combining with the DLT, SSI systems present attractive
advantages such as privacy protection, security enhancement,
high availability.

In this paper, we have formulated the self-sovereign identity
as a service to facilitate the interoperable, customizable, and
scalable use of the DLT-based SSI in practice. We have also
practicalized SSIaaS with a novel architecture by elaborating

the service concept, SSI, and DLT. Besides, we have proposed
an architecture for SSI services and formulated a collection of
architectural patterns for SSI service components. For each
component, we have provided evaluations for its architectural
patterns as the insights of making architectural decisions.
Selﬁed, an SSIaaS platform, has been developed based on our
architecture to demonstrate the feasibility in practice. Further-
more, we have discussed the interoperability, customizability,
and scalability of our architecture.

Our next research direction is to conduct an in-depth secu-
rity analysis for SSIaaS and extract more architectural patterns
for SSI service components. We also plan to explore new
methods of practicalizing the DLT-based SSI.

REFERENCES

[1] Y. Chen and C. Bellavitis, “Blockchain disruption and decentralized
ﬁnance: The rise of decentralized business models,” Journal of Busi-
ness Venturing Insights, vol. 13, p. e00151, 2020, iSBN: 2352-6734
Publisher: Elsevier.

[2] H.-N. Dai, Z. Zheng, and Y. Zhang, “Blockchain for Internet of Things:
A survey,” IEEE Internet of Things Journal, vol. 6, no. 5, pp. 8076–8094,
2019, iSBN: 2327-4662 Publisher: IEEE.

[3] Y. Ding and H. Sato, “Dagbase: a decentralized database platform
Using DAG-based consensus,” in 2020 IEEE 44th Annual Computers,
Software, and Applications Conference (COMPSAC).
IEEE, 2020, pp.
798–807.

[4] ——, “Derepo: a distributed privacy-preserving data repository with
decentralized access control for smart health,” in 2020 7th IEEE
International Conference on Cyber Security and Cloud Computing
(CSCloud)/2020 6th IEEE International Conference on Edge Computing
and Scalable Cloud (EdgeCom).

IEEE, 2020, pp. 29–35.

[5] Y. Liu, Z. Zhao, G. Guo, X. Wang, Z. Tan, and S. Wang, “An
identity management system based on blockchain,” in 2017 15th Annual
Conference on Privacy, Security and Trust (PST).
IEEE, 2017, pp. 44–
4409.

[6] Z. Cui, X. U. E. Fei, S. Zhang, X. Cai, Y. Cao, W. Zhang, and J. Chen,
“A hybrid blockchain-based identity authentication scheme for multi-
WSN,” IEEE Transactions on Services Computing, vol. 13, no. 2, pp.
241–251, 2020, iSBN: 1939-1374 Publisher: IEEE.

[7] Y. Ding and H. Sato, “Bloccess: towards ﬁne-grained access control us-
ing blockchain in a distributed untrustworthy environment,” in 2020 8th
IEEE International Conference on Mobile Cloud Computing, Services,
and Engineering (MobileCloud).

IEEE, 2020, pp. 17–22.

[8] A. Tobin and D. Reed, “The inevitable rise of self-sovereign identity,”

The Sovrin Foundation, vol. 29, no. 2016, 2016.

[9] N. Naik and P. Jenkins, “uPort open-source identity management system:
An assessment of self-sovereign identity and user-centric data platform
built on blockchain,” in 2020 IEEE International Symposium on Systems
Engineering (ISSE).

IEEE, 2020, pp. 1–7.
[10] J. Singh and J. D. Michels, “Blockchain as a service (BaaS): Providers
and trust,” in 2018 IEEE European Symposium on Security and Privacy
Workshops (EuroS&PW).

IEEE, 2018, pp. 67–74.

[11] W. Zheng, Z. Zheng, X. Chen, K. Dai, P. Li, and R. Chen, “Nutbaas:
A blockchain-as-a-service platform,” Ieee Access, vol. 7, pp. 134 422–
134 433, 2019, iSBN: 2169-3536 Publisher: IEEE.

[12] Y. Ding and H. Sato, “Sunspot: A Decentralized Framework En-
abling Privacy for Authorizable Data Sharing on Transparent Public
Blockchains,” in International Conference on Algorithms and Architec-
tures for Parallel Processing. Springer, 2021.

[13] R. Gennaro, S. Goldfeder, and A. Narayanan, “Threshold-optimal
DSA/ECDSA signatures and an application to Bitcoin wallet security,”
in International Conference on Applied Cryptography and Network
Security. Springer, 2016, pp. 156–174.

[14] A. Shamir, “How to share a secret,” Communications of the ACM,
vol. 22, no. 11, pp. 612–613, 1979, iSBN: 0001-0782 Publisher: ACm
New York, NY, USA.

[15] S. Voshmgir, Token Economy: How the Web3 reinvents the Internet.

Token Kitchen, 2020, vol. 2.

