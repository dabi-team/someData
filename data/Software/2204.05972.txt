S-DABT: Schedule and Dependency-Aware Bug Triage in Open-Source
Bug Tracking Systems

Hadi Jahanshahia, Mucahit Cevika

aData Science Lab at Ryerson University, Toronto, Canada

2
2
0
2

r
p
A
2
1

]
E
S
.
s
c
[

1
v
2
7
9
5
0
.
4
0
2
2
:
v
i
X
r
a

Abstract

Context: In software engineering practice, ﬁxing bugs in a timely manner lowers various potential

costs in software maintenance. However, manual bug ﬁxing scheduling can be time-consuming,

cumbersome, and error-prone.

Objective: In this paper, we propose the Schedule and Dependency-aware Bug Triage (S-DABT),

a bug triaging method that utilizes integer programming and machine learning techniques to assign

bugs to suitable developers.

Method: Unlike prior works that largely focus on a single component of the bug reports, our

approach takes into account the textual data, bug ﬁxing costs, and bug dependencies. We further

incorporate the schedule of developers in our formulation to have a more comprehensive model for

this multifaceted problem. As a result, this complete formulation considers developers’ schedules

and the blocking eﬀects of the bugs while covering the most signiﬁcant aspects of the previously

proposed methods.

Result: Our numerical study on four open-source software systems, namely, EclipseJDT, Li-

breOffice, GCC, and Mozilla, shows that taking into account the schedules of the developers

decreases the average bug ﬁxing times. We ﬁnd that S-DABT leads to a high level of developer

utilization through a fair distribution of the tasks among the developers and eﬃcient use of the

free spots in their schedules. Via the simulation of the issue tracking system, we also show how

incorporating the schedule in the model formulation reduces the bug ﬁxing time, improves the

assignment accuracy, and utilizes the capability of each developer without much comprising in the

model run times.

Conclusion: We ﬁnd that S-DABT decreases the complexity of the bug dependency graph by

Email address: hadi.jahanshahi@ryerson.ca (Hadi Jahanshahi)

Preprint submitted to

April 13, 2022

 
 
 
 
 
 
prioritizing blocking bugs and eﬀectively reduces the infeasible assignment ratio due to bug de-

pendencies. Consequently, we recommend considering developers’ schedules while automating bug

triage.

Keywords: bug triage, optimization, bug dependency graph, repository mining, issue tracking

system, software quality

1. Introduction

In software engineering, ﬁxing a bug as soon as possible lowers the associated costs with

software development and maintenance [13]. As manually determining the bug ﬁxing decisions

is time-consuming and error-prone, many researchers have been looking into the feasibility of

automating each step of the procedure. As a bug is reported to an issue tracking system (ITS),

triagers investigate its validity and determine the best course of action. If a bug report does not

include enough information for reproducibility, or if it is not relevant, it will be ﬂagged as an invalid

bug. However, for valid bugs, triagers may ﬁnd a proper developer to assign a new bug. In many

open software systems, developers themselves may claim a bug’s possession and start ﬁxing it. This

decision is mainly made by checking the bug’s information, e.g., its title, component, description

and severity. While claiming the possession of a bug, a developer considers their available schedule

and currently assigned bugs. Hence, both the bug’s attributes and the developer’s competency

and free schedule are crucial in a proper bug assignment.

Previous studies mainly concentrate on the importance of textual information in the bug triag-

ing process [4, 16, 18]. Considering the assignment task as a classical classiﬁcation problem, some

researchers explored the eﬀect of considering diﬀerent bug report features – e.g., title, description,

and tag – on assigning a proper developer. However, such approaches fail to address the issue of

longer ﬁxing times of some bugs that are automatically assigned, e.g., due to the busy schedule

of the assigned developer. Other works also considered the combination of bug-ﬁxing time (cost)

and selecting the proper developer (accuracy) [12, 19]. They use a regulatory term/parameter and

suggest that their approach reduces the ﬁxing time without compromising the accuracy. However,

the algorithms still suﬀer from task concentration, i.e., assigning an unmanageable number of bugs

to the highly expert developers. A recent study by Kashiwa and Ohira [12] proposes setting an

upper limit on the number of tasks that each developer can address given a predeﬁned period

2

of time. Their method alleviated the problem of imbalanced bug distribution and reduced the

number of overdue bugs. However, in their objective function, they do not consider the bug ﬁxing

time. Also, similar to many other previous works, their model does not consider the signiﬁcant

eﬀect of blocking bugs in the prioritization task [2].

Jahanshahi et al. [11] proposed a Dependency-aware Bug Triaging method (DABT) that con-

siders the bug dependency and the ﬁxing time during the bug triage process. DABT employs

machine learning algorithms and integer programming models to determine the suitable develop-

ers given the bug ﬁxing times and dependencies. Nevertheless, the issue with developers’ schedules

and the ability to ﬁx multiple bugs simultaneously is yet to be addressed. We propose Schedule

and Dependency-Aware Bug Triage (S-DABT) as an extension of DABT by considering the de-

velopers’ schedules, i.e., their working days, assigned bugs, holidays, and capacities for ﬁxing

bugs simultaneously. We also further expand dependency-awareness considerations by taking into

account the dependency of the bugs assigned but not solved yet.

Research Questions. We propose S-DABT that assigns the bug to the most appropriate developer

while considering the workload of available developers and the dependency between the bugs. In

particular, we explore the following research questions.

(RQ1) How can S-DABT prevent task concentration on developers?

(RQ2) How can S-DABT reduce the ﬁxing time and the overdue bugs at the same

time?

(RQ3) How can S-DABT help developers postpone the blocked bugs?

(RQ4) How can S-DABT utilize the capacity of the developers compared to other

baselines?

(RQ5) How can S-DABT enhance the performance of its predecessor, DABT?

Extensions from Previous Work. A preliminary version of this study appeared as a conference

proceeding, which proposed DABT as a bug triaging method [11]. The important extensions

made in the current paper include the following:

3

• We revise the model formulation such that each developer has its own simultaneous task

capacity j. This capacity indicates the number of simultaneous bug ﬁxes a developer can

have. It is estimated based on the history of the ITS.

• We deﬁne an IP model for the ﬁrst time that considers developers’ availability while assigning

bugs. Moreover, we embed the dependency of the bugs that are assigned but not solved yet.

Those bugs may delay the ﬁxing of the blocked bugs until they get ﬁxed.

• We incorporate a new dataset, GNU Compiler Collection (GCC), to further examine the

generalizability of the model.

• We discuss developers’ utilization and eﬀective use of all available developers. It is reported

as a new research question in the extended version. Moreover, in the online supplement1,

we explore the possible enhancement to the classiﬁcation model.

Paper Organization. We organized the rest of the paper as follows. Section 2 brieﬂy discusses the

background of relevant methods used on our proposed bug triage algorithm, which is followed by

a motivating example in Section 3. Section 4 describes the S-DABT methodology and bug report

datasets used in our analysis. Section 5 investigates the research questions while highlighting

the importance of taking into account the bug dependency and developers’ schedules. Finally,

Section 6 discusses the study limitations and threats to validity, and Section 8 concludes the

paper by summarizing our work and elaborating on future research directions.

2. Background

In this section, we brieﬂy discuss the models employed in our proposed approach. Speciﬁcally,

we adopt Latent Dirichlet allocation (LDA) for topic modeling over bug descriptions and Integer

Programming (IP) for bug triaging. Note that, to identify the suitability for the developer assign-

ment task, we use Support Vector Machines (SVM), details of which were skipped as it is a widely

used model in the domain.

1The online supplement can be found on the GitHub repository of the paper.

4

2.1. LDA

LDA is a probabilistic topic modeling method [6]. It is an unsupervised learning approach that

can identify the topics in given documents or corpus based on their word clusters and frequencies.

LDA assumes that the document is a mixture of topics, and each word is attributed to one of

the topics. In the process of bug triaging, LDA is typically used to identify the bug type given

a bug report, where the latter refers to documents, and the former refers to a topic. That is,

we extract bug description and summary from a bug report and create a bag of words (BOW)

after removing the stop words. Then, given the BOW of each bug report, LDA arbitrarily assigns

each word of the report to one of the topics (i.e., bug types). Next, it iteratively reassigns each

word, assuming that other words are accurately allocated. Accordingly, it computes the two

conditional probabilities, the proportion of words in document d that are assigned to topic t –i.e.,

p(topict|documentd)– and proportion of assignments to topic t over all documents that come from

this word as p(wordw|topict). The product of these conditional probabilities gives a probability

distribution based on which a new topic is assigned.

2.2. IP Modeling

Integer programming is a mathematical modeling framework for optimization problems where

certain decision variables need to be integer-valued. Thanks to major advances in integer program-

ming solution methodologies and their integration into commercial and noncommercial solvers, it

has become an increasingly popular approach for various application problems over time. Inte-

ger programming is particularly suited for scheduling problems, which typically require various

integer and binary decisions and a long list of constraints to be satisﬁed. For instance, Sung and

Lee [23] formulated an IP model for the problem of resource-constrained triage in a mass casualty

incident, where the priority of the patients is identiﬁed for deploying limited emergency medical

service resources so that the maximum number of patients beneﬁt from the response eﬀorts.

IP modeling can be similarly employed for the bug triaging problem, which involves identifying

the priority of the bugs and the most suitable developers to assign those bugs. That is, through an

appropriate mathematical model, various problem constraints (e.g., blocking bugs and schedule

availability for the developers) can be handled while optimizing over a particular objective, such

as maximizing the match between the bug descriptions and the developers. This way, the bug

triaging can be automated to a certain extent while the overall eﬃciency of the process is enhanced.

5

2.3. Overview of the Existing Methods

In a typical issue tracking system, after a bug is validated, the ﬁrst step is to assign it to

an appropriate developer. Accordingly, the bug assignment is usually considered a critical task

which prompted many researchers to work towards its automation. The proposed methods for

this problem can be categorized as content-based recommendation (CBR), cost-aware bug triaging

(CosTriage), release-aware bug triaging (RABT), and dependency aware bug triage (DABT). We

compare our proposed approach with the representative methods from these categories.

2.3.1. Content-based Recommendation

CBR approach aims to assign the most appropriate developer to the incoming bug through

analyzing its content. Anvik et al. [4] used machine learning techniques to build a semi-automated

bug triager. They trained a multi-class classiﬁer on the bug history by using SVM, Naive Bayes,

and C4.5 trees, where bug title and description were converted into a feature vector as the input

data, and the assigned developers were taken as the labels. The resulting classiﬁer analyzes

the textual contents of a given report and estimates each developer’s score for the new bug by

extracting its feature vector and applying the classiﬁer. Therefore, it can recommend suitable

developers for any newly-reported bugs. As they reported SVM to show the best performance,

we use it as the baseline classiﬁer in our study. Nonetheless, some CBR studies followed the same

concepts by training deep learning algorithms [16, 18, 30]. As these studies revolve around the

same idea while reporting modest accuracy improvements, we consider the most commonly used

approach in our analysis. We further examine the possible extensions to improve accuracy of the

SVM classiﬁer.

2.3.2. Cost-aware Recommendation

CosTriage considers both the accuracy and the cost of an assignment. Park et al. [19] proposed

a bug-triage method combining an existing CBR with a collaborative ﬁltering recommender (CF).

They model the developer proﬁle that denotes their estimated cost for ﬁxing a particular bug

type. To create these developer proﬁles, they quantiﬁed their proﬁle values as the average bug

ﬁxing time per bug type, where bug types are determined by applying the LDA to bug summary

and description. Next, they estimated the suitability of each developer using CBR. They trained

SVM on the textual information of the bugs and tested it for new bugs in the system. Finally, by

6

combining the cost and the CBR predictions, a bug is assigned to a developer with the highest

score.

2.3.3. Release-aware Recommendation

Kashiwa and Ohira [12] proposed the RABT method that primarily focuses on increasing

the number of bugs resolved by the following release. RABT considers the time available before

the next release and simultaneously keeps track of the bug ﬁxing load on a developer. They

formulated bug triage as a multiple knapsack problem to optimize the assignment task. In the

standard knapsack problem, for a given set of items, each with a weight and a value, the objective

is to determine the number of each items to include in a collection (i.e., knapsack) so that the

total weight is less than or equal to a given limit (i.e., knapsack capacity), and the total value is

as large as possible. Similarly, the problem of assigning bugs to the developers can be considered

as a variant of the knapsack problem. That is, RABT pairs the best possible combination of bugs

and developers to maximize the bug-ﬁxing eﬃciency given a time limit. They used SVM and LDA

to compute the preferences and costs for each bug and developer, respectively. LDA, similar to

CosTriage, categorizes the bug and calculates the average time taken for each developer to ﬁx bugs

in each category. For a new bug, SVM computes developers’ preferences, whereas LDA calculates

their expected ﬁxing time. Then, RABT determines the available time slot T d

t for developer d based

on their bugs at hand and the project horizon L (predetermined for each developer). Ultimately,

bugs are assigned to the most suitable developers such that their preferences are maximized, while

their ﬁxing cost does not exceed their available time slots.

2.3.4. Research Gaps

The existing methods discussed above have certain limitations. While CBR [4] is reportedly

a highly accurate approach, it is prone to over-specialization, recommending only bugs similar to

what a developer has solved before. Thus, it concentrates the task on some experienced developers

and slowing down the bug ﬁxing process.

In addition, it only considers the accuracy as the

performance metric, ignoring all other parameters such as bug-ﬁxing time, the developer’s interest,

and expertise. The CosTriage [19] method addresses the drawbacks of CBR and aims to optimize

both the accuracy and bug ﬁxing cost.

It estimates the bug ﬁxing time using the LDA and

overcomes its sparseness through a hybrid approach and collaborative ﬁltering recommender. As

a result, CosTriage improves the bug ﬁxing time without substantial degradation of accuracy.

7

However, both methods disregard the number of bugs a developer can ﬁx in a given time frame.

They may assign more bugs to experienced developers than they can address in the available time.

Moreover, they do not consider the number of bugs that a developer can ﬁx before the next release.

Kashiwa and Ohira [12] focus on increasing the number of ﬁxed bugs before the next release by

setting an upper limit on the available time for each developer. Accordingly, RABT mitigates the

task concentration, assigns a more achievable number of bugs that a developer can ﬁx in a given

time, and reduces the bug ﬁxing time. Also, the order of assigned bugs impacts the number of

bugs ﬁxed by the release. If the model initially triages a time-consuming bug, it can decrease the

number of bugs ﬁxed by the next release. RABT also prioritizes the developers with fewer tasks

as they are available to handle new bugs. However, it reduces the accuracy of bug assignments.

Besides, setting the proper upper limit can be challenging. If the model is desired to focus on

the number of bugs ﬁxed before the next release, it should determine a dynamic threshold on

developers’ available times. Practically, by setting a constant value, the model does not become

linked to the release dates.

3. Motivating Example

A reported bug possesses diﬀerent attributes, some of which are documented at the date of

reporting while others are determined later in the ﬁxing phase. With regards to a triager assigning

a bug to a developer or a developer claiming its possession, the developer’s schedule is typically

as important as the suitability of the bug based on its attributes. Therefore, a proper bug triage

should consider the currently assigned bugs to the developer, availability in the developer’s schedule

within the planning horizon, and the suitability of the new bug based on its characteristics.

3.1. Developers’ Schedules

To the best of our knowledge, this is the ﬁrst work that takes into account the schedules of the

developers while assigning a bug. Figure 1 shows a typical example of two developers’ schedules

and a new arriving bug. Based on the bug ﬁxing history of each developer, we can see that the

ﬁrst developer can work on two bugs simultaneously, whereas the second developer may work on

three bugs at a time. Moreover, the schedule of each developer can be estimated for the upcoming

days according to the approximate ﬁxing time of the currently assigned bugs. Here, “0” means

that the schedule is occupied by an assigned bug, whereas “1” represents the availabilities of a

8

developer. Thus, the binary parameter T d

jt denotes whether slot j of developer d is available at

day t. For instance, the ﬁrst slot of the second developer is preoccupied for the third day (i.e.,

T 2
13 = 0). Similarly, while assigning a bug, we may exclude the days for which a developer is not

available, e.g., days 8 and 9 of developer 1.

Figure 1: Developers’ schedule used for bug assignment (The bugs’ color indicates their type/component).

Assume a new bug i comes to the system, and a triage model is employed to automate the

bug assignment process.

It ﬁrst checks the suitability of the bug for each developer based on

their previous experience in handling similar bugs. The ﬁxing time of a bug may vary from one

developer to another [12, 19]. Accordingly, the model should consider how suitable the bug is for

each developer, how long the bug may take to be ﬁxed by each developer, and how the availability

of the developers will be during the planning horizon. For instance, assume that bug i in Figure 1

takes six days for developer d1, and three days for developer d2 to be ﬁxed. Then, the model

cannot assign the bug i to developer d1 as there are no six-day-long availability in her schedule.

On the other hand, since the third slot of developer d2 is almost free, the model may assign the

bug i to this developer.

3.2. Bug Dependency

The bug dependency information can play an important role during the bug assignment pro-

cess [2]. Blocking bugs are typically regarded as severe bugs that prevent some other bugs from

being ﬁxed [21]. Not only do they delay ﬁxing blocked bugs, but also their ﬁxing times are usually

longer than non-blocking bugs [25]. Valdivia-Garcia et al. [25] noted that, in terms of cohesion,

coupling complexity, and size, ﬁles aﬀected by blocking bugs are worse than the ones aﬀected by

9

non-blocking issues. Therefore, identifying and resolving them as early as possible is crucial in

issue-tracking systems.

b1

[sd

1, cd
1]

b2

[sd

2, cd
2]

b9

[sd

9, cd
9]

b3

[sd

3, cd
3]

b4

[sd

4, cd
4]

b7

[sd

7, cd
7]

b5

[sd

5, cd
5]

b6

[sd

6, cd
6]

b8

[sd

8, cd
8]

Figure 2: A typical BDG (bi: bug i, sd

i : suitability of bug i for developer d, cd

i : ﬁxing time of bug i for developer d)

Figure 2 shows the dependencies among various bugs together with bug attributes such as

ﬁxing cost c and developers’ suitability s. For example, regarding bug dependency, b3 is the

blocking bug for b5 and b6. Thus, ﬁxing those two bugs is constrained by ﬁxing the parent node

(i.e., the blocking bug). Moreover, the resolution of b3 should be postponed until its blocking

bug b1 is resolved. Such dependencies may raise maintenance costs, lower overall quality, and

cause the software systems’ release to be delayed. We note that solo bugs are dominant and

omnipresent in such dependency graphs (e.g., see b9), neither blocking nor being blocked by other

bugs. Accordingly, a proper bug assignment model should consider the bug dependency while

assigning the bugs to each developer. It should prioritize the ones blocking other bugs to reduce

their negative impact in the long run.

4. Methodology

We examine the bug evolution in software repositories and its eﬀect on the triaging process. We

consider four open software systems, namely, EclipseJDT, LibreOffice, GCC, and Mozilla.

We extract reported bugs’ information from their Issue Tracking System, covering a decade from

January 2010 to December 2019. In the triaging process, we consider both textual information of

the reported bugs and their dependencies. We construct a bug dependency graph (BDG), where

the reported bugs are its nodes, and the blocking information, i.e., “depends on” and “blocks”

forms its arcs. A BDG is a directed acyclic graph (DAG) in which bugs cannot block other bugs

while they are simultaneously blocked by the same bugs in a loop (see Figure 2). Bug dependencies

10

are usually identiﬁed during the ﬁxing process; hence, we assume the BDG is constantly evolving

by the changes in its nodes – i.e., ﬁxing a bug or introducing a new bug – and its arcs – i.e., ﬁnding

a new dependency or removing an existing dependency.

As we discussed in Section 2.3, the textual information and the ﬁxing time of the bugs are of

importance in automating the bug triage processes. Previous studies focusing on CosTriage-based

methods claim that merely looking for the textual information may increase the accuracy; however,

such an approach leads to longer bug ﬁxing times. Therefore, they deﬁne a control parameter, α,

to make a trade-oﬀ between accuracy and the ﬁxing cost/time. Still, both CBR and CosTriage

approaches ignore the impact of the imbalanced distribution of the ﬁxing tasks among developers.

The release-aware bug triaging method enriches the triaging process with a predeﬁned constraint

on developers’ workload to minimize overdue bugs.

4.1. Assumptions

We make the following assumptions in order to formulate an integer programming model for

the problem:

• Similar to previous works [4, 20, 12], we only consider active developers in the ITS, and

exclude inactive developers as we do not have suﬃcient information on them. Considering

interquartile range (IQR) as a measure of central distribution, we deﬁne active developers

as the ones whose bug ﬁx number is higher than the IQR of bug ﬁx numbers of all devel-

opers. We acknowledge that the deﬁnition of active developers is time-dependant in the

agile software industry. That is, even an active developer may leave the job at some point.

Accordingly, the list of active developers requires constant updates in practice [33].

• We consider a ﬁxed number of developers, d ∈ {d1, d2, . . . , dD} working on resolving bugs by

taking into account their schedule. We obtain the list of developers using predeﬁned condi-

tions on active developers. Speciﬁcally, we take D as 16, 48, 47, and 121 for EclipseJDT,

LibreOffice, GCC and Mozilla, respectively.

• We do not incorporate the severity and priority information of the bugs into the bug assign-

ment decisions as they were reported to be unreliable and subjective [2, 10].

• Bug i has ﬁxing time of cd
i

if it is solved by developer d. Also, ci = {cd1

i , cd2

i , . . . , cdD

i } is

used to denote the set of cost values of bug i for all the active developers. For our analysis

11

to be consistent and comparable with those of previous studies [12, 19], we estimate the

ﬁxing time using the same approach reported in those works. We apply LDA for topic

modeling, use Arun’s method to obtain the optimal number of categories, ﬁnd the average

ﬁxing time of each developer given the category, and ﬁnally, estimate the missing values using

a collaborative ﬁltering recommender. Arun’s method determine the optimal number of bug

types as 8, 18, 5, 5 for EclipseJDT, LibreOffice, GCC and Mozilla, respectively.

• Bug i has a suitability sd

i when assigned to developer d. Also, si = {sd1
the set of suitability values of bug i for all developers. The notion of suitability implies

i } denotes

i , . . . , sdD

i , sd2

that, in the triage process, we should assign the bugs to the most compatible developer.

To calculate the suitability, we train a model on textual information (i.e., bug title and

description) obtained from the history of resolved bugs. A TF-IDF model converts the

merged textual data to numeric values and makes those ready for the classiﬁer. We adopt

an SVM classiﬁer that employs the output of TF-IDF as the independent features and the

developers’ names as the class labels. We ﬁt the model at the end of the training phase.

Then, it can predict the suitability of each developer given the textual information of a new

bug. We adopt SVM implementation from the scikit-learn library in Python with a linear

kernel and the regularization parameter C = 1000. Note that these settings are compatible

with the previous works. We use default values for other SVM parameters. Figure 3 shows

the process of estimating sd

i values.

Figure 3: Suitability estimation process [12]

• Similar to Kashiwa and Ohira [12], we solve the IP model and other baseline methods at

the end of each testing day. Accordingly, developers are assigned bugs once a day (i.e., the

interval between bug assignments is 24 hours).

12

• Each bug cannot be assigned to more than one developer at the same time.

• Bug dependency is updated at the time of ﬁnding a dependency or removing one. Therefore,

dependency updates are instantaneous, separate from the model runs and are done by the

Wayback Machine simulator [10].

• Each developer may work on a ﬁxed number of bugs on a given day, which depends on the

“capacity” of each developer. We estimate developers’ capacity according to the history of

bug assignments (i.e., how many bugs have been historically assigned to each developer on

a single day.). We refer to this capacity parameter as schedule slots, which is denoted by j.

4.2. Estimating Developers’ Schedules

Estimating the developers’ capacity in the OSS systems according to their previous schedule can

be cumbersome since particular developers can be part-time employees or volunteer contributors.

However, this is typically feasible in proprietary software projects in which the work schedules

of developers are largely predetermined.

In the OSS systems, there are still many employed

developers whose working hours are known. Accordingly, our proposed model can be fed with

the actual schedules of the recruited staﬀ, and it can associate each bug with one of the available

developers. Note that, in this work, we do not have access to the actual schedules of the developers;

instead, we estimate their working hours based on the available information in the OSS repository.

In practice, a scheduling system can be incorporated into the bug triage routine in which each

developer may report or modify their available schedules for the upcoming week. As the assignment

is done at the end of each day, they may adjust their schedules at the end of the working day to

have an appropriate bug assignment for the next day.

We assume that, based on the proﬁciency and experience of each developer, they may handle

j ≥ 1 bugs simultaneously. We estimate the number of slots (i.e., capacity to address multiple

bugs at the same time) of each developer according to our observations in the training phase.

Speciﬁcally, we track the number of assigned bugs to each developer and report the number

of daily bugs they work on during the training period. Through such approximation, we can

estimate the capability of a certain developer in handling multiple bugs. Using the third quartile

and interquartile range of previous simultaneous tasks, we approximate the developer capacity,

i.e., j ≤ (cid:98)Q3 + (1.5 × IQR)(cid:99). We acknowledge that having access to the exact schedule of

13

the developers results in more accurate parameters for our models. However, our approach to

incorporating developers’ schedules into the bug triaging process remains valid even with this

estimated parameter set for their schedules.

We also note that having a binary vector representation of the developers’ schedules (e.g.,

[1, 0, 0, 1, 0] indicating the developer being available only at 1st and 4th time steps) enables the

project managers to insert the exact working hours or oﬀ days for the developers to have appro-

priate bug assignments. Moreover, although we apply the model on a daily basis, the granularity

of the schedules may vary. The model can also accommodate other schedule breakdowns (e.g.,

hourly or weekly). Since we estimate the ﬁxing times of the bugs on a daily basis, we split the

developers’ schedules according to their daily availability. The deﬁnition of the breakdowns can

be easily adjusted based on the triagers’ preferences.

4.3. Dependency-aware Bug Triage

We ﬁrst explain the DABT model that we originally proposed to incorporate bug dependency

relations into bug triage decisions [11]. Let xd

i be a binary variable that takes value 1 if bug i is

solved by developer d, and 0 otherwise. In addition, let T d

t denote the time limit of developer d at

time t. Speciﬁcally, at time step t, developers’ time limit is updated according to their schedule

and previously assigned bugs. We deﬁne an identical upper limit L for all developers on their T d
t

values. This upper limit is equivalent to the maximum planning horizon for a project and can

change according to the project size. We set L to the third quartile value of the bug ﬁxing times

according to the previous study [12]. DABT model is formulated as follows:

maximize

(cid:88)

(cid:88)

(cid:16)(cid:0)α ×

subject to

d

i

i ≤ xd
xd
p

(cid:88)

i xd
cd

i ≤ T d
t

i
(cid:88)

d

xd
i ≤ 1

sd
i
max(si)

(cid:1) + (cid:0)(1 − α) ×

1/cd
i
1/min(ci)

(cid:1)(cid:17)

xd
i

∀d, ∀i (cid:54)= root, p ∈ P (i)

∀d

∀i

xd
i ∈ {0, 1} ∀i

(1a)

(1b)

(1c)

(1d)

(1e)

The objective function maximizes the suitability of the solved bugs while reducing the cost

(i.e., solving time). The trade-oﬀ between suitability and estimated ﬁxing time is determined by

14

α. Diﬀerent from Kashiwa and Ohira [12]’s model, we incorporate the ﬁxing time in the objective

function since ignoring the solving time might cause over-specialization. It also helps to reduce

bug ﬁxing time. Constraints (1b) ensure that the precedence constraints are imposed, that is,

blocking bugs xd

p are solved before the blocked bug xd

i . Constraints (1c) enforce total time limit

requirements. Lastly, constraints (1d) guarantee that a single bug cannot be assigned to more

than one developer simultaneously.

4.4. Schedule- and Dependency-aware Bug Triage

DABT extended previous approaches by adding a bug dependency constraint and minimizing

bug ﬁxing times in the objective function. However, the bug dependency is only restricted to the

unassigned bugs. Blocking bugs that are currently assigned can still impede the blocked bugs.

Therefore, a comprehensive model should consider those blocking bugs to be able to realize the

full potential of dependency-aware bug triage. Another salient point of bug assignment is the

developers’ schedule. Not all developers have the same capacity for solving bugs, and especially in

open-source software (OSS) systems, some are more active, and some are freelancers. Therefore,

their dedicated time to address the bugs may diﬀer. Our proposed model deﬁnes developers’ sched-

ules based on their bug ﬁxing history. That is, they can handle one or more bugs simultaneously,

depending on their schedule availability.

We deﬁne our Schedule and Dependency-aware bug triage (S-DABT) model as an extension

of DABT. S-DABT determines the assignment of the bugs to the developers based on developers’

schedule and competency together with bugs’ ﬁxing cost and dependency. Let xd

ijt be a binary

variable that takes value 1 if bug i is assigned to slot j of developer d starting from day t, and

0 otherwise. The bug takes cd

for this assignment. In addition, let T d

i days to be solved and has the preference (i.e., suitability) of sd
i
jt denote a binary parameter that represent developer d’s

availability, which take value 1 if slot j at day t is free, and 0 otherwise. Speciﬁcally, at each time

step, developers’ schedule is updated according to previously assigned bugs, possible holidays, and

oﬀ days. The number of days that we plan ahead for has the upper limit L for all developers

(i.e., t ∈ {1, 2, . . . , L}). This upper limit is equivalent to the maximum planning horizon for a

project and can change according to the software project speciﬁcations and size. We set L to the

third quartile value of the bug ﬁxing times, as reported in previous studies [12]. The values of

L for EclipseJDT, LibreOffice, GCC and Mozilla are 9, 3, 15, and 10 days, respectively.

15

Also, we use P (i) to denote the list of parents for bug i. The integer programming model for bug

assignment can then be formulated as follows.

maximize

subject to

(cid:88)

(cid:88)

(cid:88)

(cid:88)

i

d

j

t

(cid:16)(cid:0)α ×

sd
i
max(si)

(cid:1) + (cid:0)(1 − α) ×

1/cd
i
1/min(ci)

(cid:1)(cid:17)

xd
ijt

(cid:88)

(cid:88)

(cid:88)

d

j

t

xd
ijt ≤ 1

∀i,

(cid:88)

i
(cid:88)

(cid:0)1 −

(cid:88)

(cid:88)

(cid:88)

xd
ijt

(cid:1)M +

ijt ≤ T d
xd
jt(cid:48)
xd
ijt = 0

∀i, d, j, t, t(cid:48) ∈ [t, . . . , t + cd
∀i, d, j, t if t + cd

i − 1 ≥ L,

i − 1],

t
(cid:88)

xd
ijt(cid:48) ≤ 1

∀d, j, t; if T d

jt(cid:48) = 1,

i +1

t(cid:48)=t−cd
(cid:88)
(cid:88)

(xd

ijtt) >

(cid:88)

(cid:88)

(cid:88)

(cid:0)xd

pjt(cid:48)(t(cid:48) + cd

p − 1)(cid:1)

d

j

t

d

j

t

d

j

t(cid:48)

(cid:0)1 −

(cid:88)

(cid:88)

(cid:88)

xd
ijt

(cid:1)M +

(cid:88)

(cid:88)

(cid:88)

(xd

ijtt) > τp

∀i (cid:54)= root, if p ∈ P (i), P (i) (cid:54)= ∅,

∀i (cid:54)= root, p ∈ P (cid:48)(i), if P (cid:48)(i) (cid:54)= ∅,

d

j

t

d

j
(cid:88)

t
(cid:88)

(cid:88)

xd
ijt ≤

(cid:88)

(cid:88)

(cid:88)

xd
pjt

d

j

t

d

j

t

∀i (cid:54)= root, p ∈ P (i), if P (i) (cid:54)= ∅,

xd
ijt ∈ {0, 1} ∀i, j, t, d

(2a)

(2b)

(2c)

(2d)

(2e)

(2f)

(2g)

(2h)

(2i)

The objective function of the model maximizes the suitability of the solved bugs while reducing

the cost (i.e., solving time). The trade-oﬀ between suitability and estimated ﬁxing time is deter-

mined by the parameter α. Diﬀerent from Kashiwa and Ohira [12]’s model, we incorporate the

ﬁxing time in the objective function since ignoring the solving time might cause over-specialization.

It also helps to reduce bug ﬁxing time. Constraints (2b) guarantee that a single bug cannot be

assigned to more than one developer simultaneously. Equations (2c) ensure that if bug i is assigned

to developer d, then the developer has suﬃcient available days in the schedule (i.e., T d

jt(cid:48) =1) until

the bug is completely ﬁxed (i.e., the end of the ﬁxing period (from t to t + cd

i − 1)). Moreover,

constraints (2d) restrict assignments to developers if the ﬁxing date exceeds the project horizon

(t + cd

i − 1 ≥ L). On the other hand, when bug i is assigned to slot j of developer d, equations (2e)

ensure that no other bug can be assigned to the same slot until bug i is ﬁxed.

Regarding the blocking bugs, the model is required to formulate dependencies both among

unassigned bugs and between unassigned and assigned bugs. Hence, we deﬁne three constraints

16

to account for all diﬀerent cases. Assume p is one of the parents of bug i (i.e., p blocks bug i).

Constraints (2f) ensure that the blocked bug can only be solved after its parent is resolved. In that

case, if bug i is assigned to be solved starting at time t (i.e., xd

ijt = 1), its blocking bug p should

have ﬁnished its ﬁxing period (t > t(cid:48) + cd

p − 1). If the bug is not yet assigned (i.e., xd

ijt = 0), the

Big-M parameter assures that the constraint always holds. We set Big-M parameter to L, which

is the length of the maximum project horizon (i.e., t(cid:48) + cd

p − 1 cannot be greater than L). Beside

the importance of assigning a bug and its parent at the same time, there might be cases in which

the parent (blocking bug) is assigned, but it is yet to be ﬁxed. Equation (2g) guarantees that

ﬁxing the blocking bug that is already assigned is earlier than the assignment time of the blocked

bug (i.e., τp < t). Lastly, constraints (2h) condition the assignment of bug i to the assignment of

its blocking bug p. We note that our model does not impose any constraints to assign a blocking

bug to the same developer as the blocked one. That is, a set of dependent bugs can be solved

by multiple developers according to the solution sequence of the blocking bugs. On the other

hand, if, in a particular setting, it is desired that a set of dependent bugs need to be solved by

a single developer, a corresponding set of constraints can be added to our model to satisfy this

requirement.

The proposed IP formulation incorporates all the previous criteria while it improves dependency

constraints and accounts for the schedules of the developers. Accordingly, the IP formulation

proposed by Kashiwa and Ohira [12] is diﬀerent than ours in that it disregards the bug dependency

and the schedule of the developers, the blocking eﬀect of already assigned bugs, and the exact

timing and order for the assignments. We provide an illustrative example of our proposed model

in the online supplement2.

4.5. Bug Triage Mechanism

We design a mechanism to recreate all the past events. Unlike the previous studies that worked

on the static datasets (typically stored in CSV or JSON ﬁles), we reconstruct the history of events

and apply each algorithm in real-time. The online exploration enables us to examine the outcome

of bug assignments given other elements in the system. Therefore, we build a pipeline of the past

events and replace the assignment task with our proposed algorithm. The ﬂow and time of the bug

2The online supplement can be found on the GitHub repository of the paper.

17

reports, bug reopening, and bug dependency discovery remain the same. To this end, we adopt

the Wayback Machine, the suggested pipeline by Jahanshahi et al. [10], to recreate past events.

We ﬁrst extract bug ﬁxing information from Bugzilla. Then, we revisit past events in the

system during the training time and keep track of the information related to active developers

and feasible bugs. When the training phase is completed, SVM and LDA learn the suitability and

cost values accordingly. Afterwards, we continue recording the incoming bugs and their possible

dependencies during the testing phase. Once in a day, we query the currently feasible bugs’

information in the system and apply our IP model to those. The outcome of the model is a

list of developers and assigned bugs. A few bugs may remain unassigned based on the imposed

constraints. For instance, they might be blocked by a bug that is not yet ﬁxed, or the schedule of

the suitable developer is currently full. We call back those bugs in the upcoming days until they

meet the criteria. The steps of the full procedure is provided below.

(Step 0): Setting hyper-parameters: We use the third quartile of bug ﬁxing times as the value

for upper limit L. All T d

jt values have the length of L and cannot exceed this limit during

the process. Furthermore, SVM and LDA hyperparameters are deﬁned similar to the

previous studies.

(Step 1): Constructing SVM and LDA: To estimate the suitability sd

i and the ﬁxing time cd
i

for developer d and bug i, we train SVM and LDA at the end of the training phase.

(Step 2): Estimating the number of schedule slots: Each developer may work on j bugs

simultaneously. The number of slots (i.e., capacity) of developer d is estimated based on

the developer’s history of ﬁxing bugs during the training phase. We use the third quartile

and interquartile range of previous simultaneous tasks of the developers to determine the

value, i.e., j ≤ (cid:98)Q3 + (1.5 × IQR)(cid:99).

(Step 3): Predicting suitability and costs: At the end of each day, we predict the suitability

and cost values for all feasible, unassigned bugs.

(Step 4): Calling S-DABT: By solving the IP model, we determine the assigned bugs and their

associated developers. Based on the constraints, the model postpones certain bugs while

prioritizing others.

18

(Step 5): Updating T d

jt: At the end of each day, we increment T d

jt by 1 for developer d while

ensuring it does not exceed L. At the same time, we decrease T d

jt of slot j of developer

d by sum of their estimated cd

i values for all assigned bugs to the slot j of the developer.

(Step 6): Continuing to the next day (to Step 3): Once the assignment at day t ﬁnishes, we

move to the next day and repeat the process from Step 3. We also keep track of the BDG

statistics as well as all assigned and unassigned bugs of the day. These steps continue

until the end of the testing phase.

We assume that our method and baselines are implemented once a day. However, the process

is generalizable, and the granularity of the time steps can be modiﬁed as needed (e.g., from daily

to weekly).

4.6. Dataset

We consider four large OSS projects in our analysis. They are well-established projects with

a suﬃcient number of bug reports. These projects were also adopted in the previous studies [5,

12, 16, 18], making them suitable for comparative analysis. We collect the raw data from the

repository using the Bugzilla REST API3. It includes general attributes of the bugs and their

metadata change history. Table 1 shows the summary information for the extracted datasets. We

use bug reports for the past two years as the testing set and the older ones as the training set.

Table 1: Summary information for the extracted datasets. The training phase starts from Jan. 1st, 2010 to Dec.
31st, 2017, whereas the testing phase covers Jan. 1st, 2018 to Dec. 31st, 2020.

EclipseJDT

LibreOffice

GCC

Mozilla

Training Testing Training Testing Training Testing Training Testing

Total bugs reported
Total bug dependencies found
Total relevant changes in the bugs’ history
Mean and Median ﬁxing time (days)
Minimum, Maximum ﬁxing time (days)

12,598
2,169
55,109
(41.2, 3)
(1, 1,753)

3,518
970
15,505
(15.7, 1)
(1, 423)

55,554
28,472
267,310
(18.3, 1)
(1, 1,484)

14,582
21,894
94,682
(9.4, 2)
(1, 428)

34,635
4,462
138,580
(42.3, 3)
(1, 2,396)

9,998
3,268
42,117
(42.0, 3)
(1, 681)

90,178
71,549
410,010
(27.2, 5)
(1, 2,172)

22,353
19,223
114,778
(12.6, 4)
(1, 550)

After cleaning

0. Bugs that are not META bugs
1. Bugs with resolved status
2. Bugs assigned to active developers
3. Bugs with known assignment date
4. Bugs with acceptable ﬁxing time

12,598
11,296
3,795
3,021
2,372

3,518
2,619
1,491
1,348
1,201

54,907
46,905
5,035
4,345
3,462

14,416
11,114
1,888
1,749
1,428

34,634
29,057
27,088
8,628
7,166

9,996
7,195
6,719
3,072
2,459

89,354
79,108
10,948
6,768
5,618

21,912
18,720
6,365
3,947
3,547

Similar to previous studies [12, 19], we consider only the bugs that meet the following ﬁve

criteria.

3https://wiki.mozilla.org/Bugzilla:REST_API

19

1. Jahanshahi et al. [10] showed that META bugs mimic blocking bugs by providing links

to other bugs via “depends on/blocks” mechanism. Therefore, their main aim is to group

similar bugs and do not have testcases of their own. We exclude them as they are not a real

bug reported by users to the system.

2. Not all bugs have ﬁxing time information available. For instance, some bugs are still open,

or in some cases, the exact ﬁxing date is not available in history. Hence, we only consider

the FIXED or CLOSED bugs with suﬃcient information.

3. The assignment date is not available for some bugs, or the assignment time is after their

resolution. We eliminate them as invalid bugs.

4. We deﬁne active developers as the ones with bug ﬁx numbers greater than the IQR of bug

ﬁx numbers of all developers. Only the bugs assigned to active developers of the training

phase are considered for the testing phase.

5. Some bugs took years to get solved in the ITS. We remove outlier bugs whose ﬁxing time is

greater than the threshold of Q3 + (1.5 × IQR), where Q3 is the third quartile of the ﬁxing

time, and IQR is the interquartile range, i.e.,

IQR = (the third quartile) − (the ﬁrst quartile).

The maximum acceptable ﬁxing times that we found for EclipseJDT, LibreOffice, GCC

and Mozilla are 21, 22, 38.5, and 6 days, respectively.

Table 1 shows the eﬀect of applying each ﬁltering step on the number of feasible bugs in the

system. Similar to previous studies [12, 17, 20], we preprocess the textual information through

lemmatization, stop words, numbers and punctuation removal, and lengthy word elimination (i.e.,

longer than 20 characters). Finally, we merge titles and descriptions of the bugs and tokenize

them.

5. Numerical Study

We compare S-DABT and DABT with the well-known bug triage methods from the literature,

namely, CBR using SVM, CosTriage, and RABT as well as the actual bug assignment, which is

20

taken as a baseline. We implemented all the methods in Python and used Gurobi 9.5 to solve the

IP models.

5.1. Performance Discussion

We deﬁne diﬀerent metrics for the comparison as shown in Table 2. We observe that S-DABT

and DABT have few unassigned bugs at the end of the testing phase due to multiple constraints

imposed in their formulations. This number is negligible compared to the total bugs that are

addressed. One of the main diﬀerences between the algorithms is in their usage of available

developers. Considering three larger projects (LibreOffice, GCC and Mozilla), we observe

that actual assignment, RABT, DABT, and S-DABT use more developers than the other two

methods. The similarity between the manual assignment and IP-based solutions indicates that

they all enforce some constraints on developers’ available times. CBR and CosTriage do not

incorporate task concentration in their formulation, and they are still prone to over-specialization.

We further explore this ﬁnding by reporting the average and standard deviation of the number

of bugs assigned among developers. RABT, DABT, and S-DABT maintain the level of fair bug

distribution among developers by utilizing more developers. DABT and S-DABT achieve an

almost similar distribution to that of RABT although they use a smaller number of developers

during the testing phase. That is, they do not employ superﬂuous developers to achieve such a

fair distribution (e.g., see Mozilla’s assigned developers and task distribution in Table 2).

We further investigate the eﬀect of task concentration by examining the top-5 active developers

of each algorithm. Figure 4 shows the number of ﬁxing days for each developer. Note that if a

developer has more than a slot to solve the bugs, the number of ﬁxing days is the sum of the active

days in all the slots. As CBR and CosTriage do not consider the bug ﬁxing loads, they assign bugs

to their top developer up to six times their capacity (see Figure 4d). Although RABT, DABT, and

S-DABT never over-assign bugs during the two-year testing time, S-DABT has a much lower ﬁxing

time for each developer by incorporating the ﬁxing time minimization to the objective function

and prioritizing blocked bugs. Accordingly, our method both meets the schedule criterion and

reduces the ﬁxing time.

21

Table 2: Comparison of diﬀerent algorithms

Metrics

Actual

CBR CosTriage

RABT

DABT S-DABT

T
D
J
e
s
p
i
l
c
E

e
c
ﬃ
O
e
r
b
i
L

C
C
G

a
l
l
i
z
o
M

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (µ ± σ)
Mean ﬁxing days per bug
Percentage of overdue bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean depth of the BDG
Mean degree of the BDG
Assignment divergence (µ ± σ)
Utilization
Running time (hrs.)

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (µ ± σ)
Mean ﬁxing days per bug
Percentage of overdue bugs
Percentage of un-ﬁxed bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean depth of the BDG
Mean degree of the BDG
Assignment divergence (µ ± σ)
Utilization
Running time (hrs.)

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (µ ± σ)
Mean ﬁxing days per bug
Percentage of overdue bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean depth of the BDG
Mean degree of the BDG
Assignment divergence (µ ± σ)
Utilization
Running time (hrs.)

# of assigned bugs
# of un-assigned bugs
# of assigned developers
Task distribution among developers (µ ± σ)
Mean ﬁxing days per bug
Percentage of overdue bugs
Accuracy of assignments
Infeasible assignment w.r.t. bug dependency
Mean depth of the BDG
Mean degree of the BDG
Assignment divergence (µ ± σ)
Utilization
Running time (hrs.)

1,231
0
13
94.7±149
5.5
71.3
96.9
5.6
0.05
0.05
82.2±235
0.35
0.1

1,406
0
17
82.7±228
2.1
39
39
99.2
0.1
0.01
0.01
73.3±148
0.030
1

2,490
0
32
77.8±176
5.3
57.0
97.1
0.9
0.11
0.11
35.2±157
0.348
0.4

3,536
0
58
61.0±243
6.3
73.8
62.6
10.8
0.1
0.09
24.4±94
0.07
1.5

1,231
0
12
102.6±152
5.2
68.2
97.0
5.5
0.05
0.05
82.2±235
0.33
0.1

1,406
0
17
82.7±237
2.1
52.2
52.2
99.3
0
0.01
0.01
73.3±148
0.028
1.1

2,490
0
30
83.0±181
5.0
54.4
96.9
0.8
0.11
0.11
35.2±157
0.331
0.6

3,536
0
59
59.9±232
6.1
69.5
61.7
10.3
0.1
0.09
25.4±94
0.07
1.5

1,231
0
15
80.0±92
6.4
27.8
97.8
4.2
0.05
0.05
0.0±0
0.47
0.1

1,406
0
51
27.5±71
2.6
8.7
8.7
93.4
0.1
0.01
0.01
0.0±0
0.053
1

2,490
0
47
52.3±87
6.3
28.9
98.2
1.1
0.11
0.11
0.0±0
0.369
0.6

3,536
0
127
27.7±49
6.7
50.6
77.6
9.8
0.09
0.08
0.0±0
0.16
1.5

22

1,231
0
15
82.1±98
4.8
10.6
94.6
3.9
0.05
0.04
75.41±233
0.37
0.1

1,406
0
60
23.4±92
2.0
5.1
5.1
93.5
0.1
0.01
0.01
73.1±148
0.031
1.1

1,224
7
15
81.6±94
4.6
9.2
90.5
0.7
0.04
0.04
74.0±233
0.34
0.2

1,226
5
15
81.7±89
4.3
12.3
91.1
0.6
0.04
0.04
75.9±234
0.38
0.2

1,406
0
56

1,406
0
60
25.1±96 23.4±101
1.9
7.2
7.2
93.0
0
0.01
0.01
73.2±148
0.032
1.1

1.9
4.8
4.8
92.4
0
0.01
0.01
73.1±148
0.027
1.1

2,482
8
47

2,490
0
47

2,482
8
43
53.0±121 52.8±123 57.7±124
4.4
12.5
86.2
0.3
0.11
0.11
35.0±155
0.364
0.7

4.4
7.5
87.1
0.3
0.11
0.11
35.0±155
0.278
0.6

5.3
9.5
92.4
0.8
0.11
0.11
35.0±156
0.352
0.6

3,536
0
111
31.9±70
5.8
14.3
56.2
4.7
0.09
0.08
25.4±94
0.10
1.5

3,525
11
73
48.3±88
3.2
9.5
38.4
2.3
0.09
0.08
23.9±94
0.07
1.5

3,527
9
69
51.1±82
3.2
12.5
40.6
1.6
0.09
0.08
24.1±94
0.13
1.7

RQ1- In general, S-DABT is able to alleviate the task concentration of the developers (i.e., we

do not observe any sign of overspecialization). Not only does it decrease the workload of expert

developers, but it also reduces the total working time of developers, with S-DABT having the

lowest mean ﬁxing time.

(a) EclipseJDT

(b) LibreOffice

(c) GCC

(d) Mozilla

Figure 4: The number of ﬁxing days spent by top-5 active developers during the two-year testing phase.

Table 2 shows that the average ﬁxing days of the bugs signiﬁcantly decrease when using DABT

and S-DABT. They both consistently have the lowest ﬁxing duration for diﬀerent projects. We

ﬁnd that S-DABT outperforms its predecessor, DABT, in EclipseJDT project. This ﬁnding

indicates the signiﬁcance of using the developers’ entire capacity (i.e., schedule-aware bug triage)

while assigning the bugs. The tweak in the objective function of DABT and S-DABT compared

to RABT, which enables prioritizing the bugs with shorter ﬁxing times during bug assignments,

leads to shorter bug ﬁxing times. Overall, we ﬁnd that DABT has the lowest rate of overdue bugs.

When considering accumulated ﬁxing time in the bug triage process, many bugs remain unresolved

due to task concentration on particular developers. It explains why CBR and CosTriage have a

high percentage of overdue bugs, as also indicated in Figure 4. By setting the hyperparameter L,

DABT does not allow the system to assign more bugs than the developers’ capacity. On the other

23

12345Developers05001000150020002500300035004000Fixing DaysActualCBRCosTriageRABTDABTS-DABT12345Developers01000200030004000500060007000Fixing DaysActualCBRCosTriageRABTDABTS-DABT      ' H Y H O R S H U V0500100015002000250030003500 ) L [ L Q J  ' D \ VActualCBRCosTriageRABTDABTS-DABT12345Developers020004000600080001000012000Fixing DaysActualCBRCosTriageRABTDABTS-DABThand, unlike RABT, it also emphasizes the signiﬁcance of the bug ﬁxing time, leading to a lower

rate of overdue bugs. Our proposed model, S-DABT, has a higher number of overdue bugs. This

can be explained by the fact that S-DABT is the only model that can create detailed schedules

(i.e., it assigns bugs and determines the exact ﬁxing day). Therefore, when we assign bugs that

should be ﬁxed a few days later, they may exceed the release date and be counted as overdue

bugs. However, in practice, if the ratio of delayed bugs is of importance, we recommend triagers

setting a dynamic value for L, updated by the remaining time until the next release. Accordingly,

both DABT and S-DABT will not have any unresolved bugs until the upcoming release.

RQ2- DABT has the lowest ratio of overdue bugs by considering an upper limit on the project

horizon and reducing the ﬁxing time. On the other hand, S-DABT has the potential to outperform

this number if the parameter L gets dynamic values based on the remaining time to the release.

Accordingly, it leads to a smoother bug ﬁxing process and addressing more bugs before the release

date.

Similar to previous works [12, 19], we deﬁne an accurate assignment as recommending a bug

to a developer who has experience in the same component. Therefore, a proper bug assignment

does not mean assigning to the same developer. According to this deﬁnition, even the manual

bug assignment case fails to achieve an accuracy of 100% when compared to the training phase.

In practice, some developers might attempt to address a bug related to a new component for the

ﬁrst time. The component might be similar but not the same as their previous ones. Hence, even

the actual assignment achieves an accuracy of 77.6% for Mozilla.

It shows that expecting a

high model accuracy may cause incorrect assignment based on the ground truth values. DABT

has a lower accuracy for all projects compared to its counterparts. S-DABT slightly improves the

accuracy of DABT by adding the concept of developers’ schedules to the assignment task and

relaxing the constraint on total time at hand by adding extra working slots for some developers.

We also note that there is a trade-oﬀ between the accuracy and speed of the bug ﬁxing process.

The parameter α in our model regulates the accuracy of the assignments and the bug ﬁxing

time. Moreover, we impose an upper limit on the project time horizon that may reduce the

accuracy but leads to fewer overdue bugs and prevent overspecialization. We further investigate

the model sensitivity to parameter choices to examine whether the low accuracy values are due to

the regulation parameter.

24

Figure 5 shows how the accuracy and the percentage of overdue bugs are impacted by the

α parameter. As we increase α, the model tends to give a higher weight to the developers’

suitability than the bug ﬁxing cost. Therefore, DABT achieves more accurate assignments at

the expense of longer ﬁxing times.

In practice, the triager may decide on how much accuracy

is needed, and accordingly, can set a proper value for α. Similar to the previous studies, we

use the α = 0.5 and give the same weight to the bug ﬁxing time and the accuracy. We note

that increasing the accuracy while ignoring the associated cost may result in over-specialization

and task-concentration. Figure 5d shows that the accuracy of S-DABT can even improve by

20% through compromising its ability to reduce the ratio of overdue bugs. We can also observe

that the elbow eﬀect of the α level occurs in diﬀerent values. Speciﬁcally, α can be set to 0.6,

0.4, 0.5, and 0.5 for EclipseJDT, LibreOffice, GCC, and Mozilla, respectively. Thus, we

recommend ﬁnding the ideal value for the regulation parameter based on the software project in

consideration. We further explored the possibility of improving the bug assignment accuracy. We

examined diﬀerent classiﬁcation algorithms together with SVM as the baseline. Similar to Mani

et al. [18]’s work, we found a better prediction performance of deep learning algorithms, including

LSTM and BERT4

One of S-DABT’s key characteristics is its capability to postpone the blocked bugs and schedule

bugs beforehand. Whether the triager assigns a bug or a developer wants to take possession of

a bug from a lengthy list of open bugs, prioritizing the blocking bugs that may increase BDG

complexity is prudent. Therefore, S-DABT includes a constraint on the infeasible bug assignment

with respect to bug dependency. Consequently, it postpones bugs until their blocking bugs are

resolved. Compared to DABT, S-DABT considers the dependency between the in-progress bugs

(i.e., bugs already assigned but not solved) and the potential bugs to be assigned. This additional

constraint helps the algorithm to reduce the infeasible assignment due to the bug dependency.

Table 2 shows the better performance of S-DABT in terms of addressing blocked bugs. The

reason why S-DABT still suﬀers few infeasible assignments due to the bug dependency is that

there is an uncertainty in ﬁnding bug dependency [2]. Some dependencies might be discovered

after a bug is assigned and is in the ﬁxing process. We consider this problem as an open question

to be addressed in future works.

4The result can be found on our GitHub page: https://github.com/HadiJahanshahi/SDABT

25

(a) EclipseJDT

(b) LibreOffice

(c) GCC

(d) Mozilla

Figure 5: Sensitivity of the accuracy and the percentage of overdue bugs of S-DABT to the α parameter.

We observe that DABT and S-DABT reduce the complexity of the BDG, i.e., its mean degree

and depth. Surprisingly, RABT also shows similar performance in terms of graph complexity.

Figure 6 explores the average degree of the bugs in the BDG during the two-year testing phase.

We note that the mean degree of the BDG is already low since there are many solo bugs in the

BDG. Nonetheless, a small reduction in these values can be signiﬁcant since it can be considered

as eliminating a few high-degree bottlenecks in the ITS. RABT, DABT, and S-DABT keep the

degree and the depth of the graph low, given all algorithms solve the same list of bugs. For the

exceptional case of LibreOffice, our ﬁndings are consistent with that of [10], which reported

few bug dependencies in the project. Therefore, based on the other projects, we conclude that

even when addressing the same list of bugs, the proper timing will reduce both the complexity of

the BDG and the number of overdue bugs. Particularly, we further explore the signiﬁcance of the

diﬀerence in graph complexity between DABT and S-DABT in Section 5.2. We note that lower

26

BDG complexity is beneﬁcial in the long run when the rate of incoming bugs is increasing while

many bugs are still blocked by the older ones.

RQ3- S-DABT, similar to DABT and RABT is able to reduce the complexity of the bug depen-

dency graph through the proper timing of bug assignment. It mitigates the risk of having a high

number of blocking bugs in the long run.

(a) EclipseJDT

(b) LibreOffice

(c) GCC

(d) Mozilla

Figure 6: The eﬀect of diﬀerent strategies on the degree of the BDG during the testing phase.

Table 2 shows the assignment divergence, deﬁned as the diﬀerence between the actual assign-

ment time and the models’ assignment time. It indicates a considerable gap in the literature in

determining the exact assignment date for a bug. On average, the models are early/late in assign-

ing the bugs by approximately 78, 73, 35, and 24 days for EclipseJDT, LibreOffice, GCC,

and Mozilla, respectively. None of the models formulates or estimates the assignment date of

the bugs. Therefore, future research may explore the feasibility of estimating the bug assignment

timing.

27

2018-012018-042018-072018-102019-012019-042019-072019-102020-010.0350.0400.0450.0500.0550.060Mean Degree of the BDGActualCBRCosTriageRABTDABTS-DABT2018-012018-042018-072018-102019-012019-042019-072019-102020-010.007750.008000.008250.008500.008750.009000.009250.00950Mean Degree of BDGActualCBRCosTriageRABTDABTS-DABT                                                                                    0 H D Q  ' H J U H H  R I  W K H  % ' * $ F W X D O & % 5 & R V 7 U L D J H 5 $ % 7 ' $ % 7 6  ' $ % 72018-012018-042018-072018-102019-012019-042019-072019-102020-010.0750.0800.0850.0900.095Mean Degree of the BDGActualCBRCosTriageRABTDABTS-DABTWe deﬁne developer utilization as the percentage of possible developers who are active each

day. Assuming we have 100 developers, if three of them are working on the assigned bugs for the

day t, then the developer utilization will be 3 percent. Utilization values in Table 2 show that

when we have fewer developers and a higher number of reported bugs, as in EclipseJDT, the

utilization is higher (most of them are busy addressing the new bugs). We note that using all

the available resources in a project can be crucial. Among all models, S-DABT is more similar

to the actual case in terms of developer utilization (i.e., it has the highest utilization rate). Con-

sidering developers’ schedules in the model formulation makes it a suitable algorithm in terms

of utilization.

It enhances DABT by expanding the variable deﬁnition to embrace developers’

slots. This modiﬁcation leads to an increased model complexity; however, our experimental re-

sults indicate no signiﬁcant diﬀerence in the running time of DABT and S-DABT (see Table 2).

RQ4- S-DABT considers developers’ schedule, making it a proper algorithm in terms of develop-

ers’ utilization. It results in a fair distribution of the task in the system and the highest utilization

rate compared to the previous algorithms.

5.2. Comparison of DABT and S-DABT

S-DABT has a more intricate structure compared to its predecessor, DABT, since it encom-

passes developers’ schedules and a more sophisticated version of bug dependency checks. In this

section, we discuss whether this additional level of complexity practically enhances the perfor-

mance of the bug triage task.

Impact on bug ﬁxing costs. During the bug triage process, the capacity of each developer may

impact the bug assignment decisions. If a triager assigns a bug to someone who is not currently

available or has many previously unresolved bugs, this might lead to bug accumulation in the

system. Accordingly, the ﬁxing cost of a lingering bug may increase over time as it remains

unaddressed in the issue tracking system. Such a cost does not only involve software development

costs but also involves the opportunity cost of leaving the bug open in the system [1]. Thus,

S-DABT better addresses the actual decisions in the ITS by considering the real-time schedules

of the developers.

Previous studies approximated the bug ﬁxing costs according to the time it takes to ﬁx a bug

28

since it is reported to the ITS. However, a developer might have been working on more than one

bug while ﬁxing this particular bug. Accordingly, the bug ﬁxing times are aﬀected by simultaneous

bug ﬁxing. Zaidi et al. [31] argue that the bug triaging methods such as DABT are limited by the

assumption that each developer can only work on one bug report at a time, which is not a realistic

scenario in practice. As such, we enhance DABT by incorporating the capability of the developers

in ﬁxing multiple bugs simultaneously. S-DABT formulates the capacity of each developer based

on their number of slots, and accordingly, its estimation of bug-ﬁxing time becomes more realistic.

Automating the entire assignment process. One of the issues with DABT is its manual reordering

of the assignments after the bugs are assigned to developers. As the integer programming model

in DABT does not determine the exact assignment time (e.g., day t) in its formulation, if the

model delegates more than a bug to a developer, it does not specify which one should get ﬁxed

ﬁrst. Hence, while using DABT, we are required to sort the bugs after the assignment, leading

to an increase in task complexity. Decision variables xd

ijt in the S-DABT model directly account

for such decisions and help determine the exact day on which a bug ﬁxing should get started.

Therefore, the new model automates the bug assignment in one step without a need for further

manual post-processing.

Eﬃciently utilizing developers’ time. We deﬁne a developer’s utilization as the percentage of as-

signed slots out of their whole capacity. Assuming a developer can address more than a bug

simultaneously, we evaluate whether our new model is capable of fully utilizing one’s capacity or

not. The utilization values range between 0 and 1. The higher the utilization value is, the more

eﬃcient the model is in exploiting developers’ time. We track the capacity of the developers and

their assigned tasks during the testing phase. Figure 7 shows how S-DABT and DABT leverage

the developers’ capacity during the testing period. We average the utilization of the developers

and plot them weekly. These results indicate higher utilization values for S-DABT compared to

DABT. In addition, we perform a statistical test to understand whether this diﬀerence is signiﬁ-

cant. As the p-values of the Shapiro-Wilk test show, the data do not follow a normal distribution.

Therefore, we utilize the non-parametric paired Wilcoxon signed-rank test with the alternative hy-

pothesis that S-DABT has a greater utilization than DABT. Small p-values for the four projects

29

indicate a signiﬁcant utilization enhancement for S-DABT over DABT (p =4.8e-18, p =4.4e-19,

p =3.9e-19, and p =1.9-19 for Eclipse, LibreOffice, GCC, and Mozilla, respectively).

(a) EclipseJDT

(b) LibreOffice

(c) GCC

(d) Mozilla

Figure 7: Utilization values for DABT and S-DABT

Planning ahead. One of the main characteristics of the S-DABT is its ability to assign bugs ahead

of time. As the model distinctively formulates both the start time of bug ﬁxing and developers’

capacities, it can assign a bug based on the future availability of a developer.

In such a case,

developers know which bug should be ﬁxed each day, and also, the bug reporters (i.e., users)

are aware of the assignees even before the bug ﬁxing period gets started. Such transparency in

the system enhances its reliability from both user and developer standpoints. Unlike previous

models, S-DABT is designed to handle such situations; nevertheless, we test if it delivers the same

experience in practice. We track the number of assigned bugs on a daily basis in the system

and observe whether these values are higher for S-DABT compared to DABT. We use the non-

30

                                                                                                                                       6 ' $ % 7 ' $ % 7                                                                                                                                          6 ' $ % 7 ' $ % 7                                                                                                                                    6 ' $ % 7 ' $ % 7                                                                                                                                                     6 ' $ % 7 ' $ % 7parametric paired Wilcoxon signed-rank test to assess the statistical signiﬁcance of diﬀerences

between DABT and S-DABT. During the testing phase, we ﬁnd a signiﬁcantly greater number of

assigned bugs by S-DABT than DABT (with the p-values of 1.1e-37, 1.3e-68, 0.0003, and 5.1e-111

for Eclipse, LibreOffice, GCC, and Mozilla, respectively). Hence, the new formulation

reduces the number of unassigned bugs in the system, indicating that the model plans ahead in

bug assignment and provides a longer-term planning perspective.

Lowering the BDG complexity. S-DABT imposes an intricate set of constraints on bug dependen-

cies, including both assigned and open bugs. Therefore, it models the complex bug dependency

network more comprehensively. Using the non-parametric paired Wilcoxon signed-rank test, we

examine whether the degree of the BDG decreases when S-DABT is used instead of DABT. We

ﬁnd that, as also shown in Figure 6, there is a signiﬁcant reduction in the number of dependencies

in all projects (with the p-values of 8.3e-11, 1.19e-07, 0.03, and 0.0006 for Eclipse, GCC, and

Mozilla, respectively). Thus, we conclude that S-DABT is able to lower the BDG complexity

given that the number of reported dependencies is large enough. That is, in the LibreOffice

project, where the number of reported dependencies is lower [10], we do not ﬁnd any signiﬁcant

diﬀerence between the two models.

Impacts on other performance metrics. We do not ﬁnd any signiﬁcant improvement in other per-

formance metrics for S-DABT compared to DABT. Both models have the same objective function;

therefore, it may not be possible to achieve a signiﬁcant enhancement in terms of the suitability

of the assigned bugs or the bug ﬁxing costs. We note that they both indirectly lower the task

concentration, and DABT and S-DABT do not dominate each other across the projects. DABT

reduces the overdue bugs compared to S-DABT as it does not plan ahead. However, if we dynam-

ically set the S-DABT’s project horizon to match the release dates, we expect to achieve similar

results in this aspect. As a result, we do not observe a signiﬁcant diﬀerence between these two

models based on these standard metrics.

31

RQ5- S-DABT is able to plan ahead by determining the exact ﬁxing day of each assigned bug.

It does not require manual adjustment after the assignment as needed in DABT; thus, it fully

automates the bug assignment process. Our numerical results indicate a better utilization of the

developers by S-DABT and a reduction in the BDG complexity compared to DABT.

6. Threats to Validity

Threats to the validity of our empirical study are as follows.

6.1. Construct Validity

We estimate the performance of the models using a train-test split. The ﬁrst eight years are

adopted as the training set and the last two years as the test. However, the evolving nature of

the bug repository may have an impact on the results. In some cases, developers become inactive

after some time or become more focused on a speciﬁc project component. Therefore, the deﬁnition

of the active developer might be required to get updated from time to time. However, to make

our results comparable with those of previous studies, we choose to rely on its common practice

and deﬁnition. We recommend a rolling approach for the train-test split to overcome outdated

decisions for future research.

Although we study textual information as our independent feature, other bug characteristics

–e.g., the number of comments, keywords, and the number of CC’ed developers– can be added

to the prediction models. We plan to expand our independent variables and include additional

external factors in future works.

To the best of our knowledge, this work is the ﬁrst study to consider developers’ schedules (i.e.,

simultaneous working slots) in the modeling. Accordingly, comparing the S-DABT’s performance

with that of previous algorithms is a challenging task. For IP models (e.g., RABT and DABT), we

assume the capacity of a developer is equal to the maximum available time in all the developer’s

slots. For other models, we distribute the assigned bugs to the slot with the maximum available

free days. Accordingly, our model and previous ones become comparable since all can use all

developers’ slots. Regarding the accuracy of the capacity estimation based on the bugs’ history,

we acknowledge the lack of data availability related to the developers’ actual schedule. The same

threat applies to bug ﬁxing time estimation as well. The ground truth for bug ﬁxing time does

not include the real eﬀort a developer invests in its resolution. A developer may work on multiple

32

bugs at the same time, but it may increase the ﬁxing time of all the bugs for that developer.

Accordingly, since our model simultaneously utilizes bug ﬁxing cost, suitability, and capacity,

the issue of a developer having a higher capacity (i.e., solving multiple bugs at a time) can be

mitigated due to potentially having a higher ﬁxing time. As the model does not solely rely on

schedule availability, the beneﬁts of assigning multiple simultaneous bugs to a single developer are

weighed against suitability and cost objectives.

6.2. Internal Validity

The bug information is extracted from the Bugzilla using the REST API5. We incorporate all

the bug records between January 2010 and December 2019 to have updated bug report information.

However, the API is limited for ordinary users, and access to the information of several bugs is

not feasible. Accordingly, we extract all bug comments at hand and complete our dataset using

regular expressions. We ensure that our dataset incorporates all publicly available bugs for all

four projects.

We do not consider the severity and priority of the bugs in our model formulation as they

are typically considered to be subjective [2, 9, 24, 29]. Furthermore, we note that solely focusing

on priority/severity would lead to assigning a high-impact bug to a non-expert developer from a

particular category. However, our model indirectly accounts for priority and severity using two

parameters in the objective function: cost and suitability. We expect to observe high cost and low

suitability values for a case in which a developer is not an expert in a particular domain. Therefore,

the model may postpone these bugs to future decision epochs until a more suitable developer

becomes available. Another salient point to note is the relation between severity, priority, and

ﬁxing time. Previous studies pointed to faster average ﬁxing times for those bugs with higher

severity and priority [22, 32]. Therefore, priority and severity considerations are in a way taken

into account in our models using the bug ﬁxing times (e.g., with high priority/severity leading to

shorter ﬁxing times as observed in the OSS).

Previous studies indicated that blocking bugs may take longer to get ﬁxed compared to non-

blocking ones [26]. This might imply that any automated bug triage method such as DABT and

S-DABT would prioritize ﬁxing solo bugs over bugs with dependencies. However, our model has

5https://wiki.mozilla.org/Bugzilla:REST_API

33

strict constraints for blocking bugs that help prioritize them over the blocked bugs or solo bugs. In

addition, the ﬁxing cost is only one of the parameters in the model that contributes to prioritizing

bugs with a shorter ﬁxing time; that is, the assignment variables should satisfy all the constraints

to assign a bug to a particular developer. Note that even if a blocking bug has a long ﬁxing time,

the suitability objective would still help prioritize such a bug so that the blocked bugs would be

eligible to be resolved in future time steps. In addition, shorter ﬁxing times for the blocked bugs

might push for solving the blocking bugs ﬁrst. In summary, our model has several mechanisms to

prevent a bug backlog for the bugs with dependencies. This is also in line with our observations

through numerical study, and we do not observe blocking bugs lingering in the system for a long

time in any studied projects.

6.3. External Validity

We consider four well-established projects in Bugzilla. Although it is compatible with the

previous works, our result may not be generalizable to all other open software systems. However,

the selected projects are large, long-lived systems, mitigating the likelihood of bias in our report.

The replication of our study using diverse projects may prove useful. We report diﬀerent metrics

to cover all advantages and disadvantages of the methods. Also, we use SVM as the text classiﬁer

following the previous works; however, other classiﬁers may result in diﬀerent classiﬁcation per-

formances. We investigate the possibility of improvement in prediction performance using deep

learning algorithms. The result is reported on the GitHub page of the paper.

7. Related Work

Several studies have been conducted to automate the bug triage process and decrease the

cost of manual bug triage. Diﬀerent techniques have been employed to address this problem, e.g.,

text categorization, tossing graph, fuzzy set-based automatic bug triaging, role analysis-based

automatic bug triage, information retrieval, and deep learning techniques.

Automatic bug triage using text classiﬁcation is proposed by Alenezi et al. [3], Anvik et al.

[4], Xuan et al. [28] wherein they trained diﬀerent classiﬁers such as SVM, Naive Bayes, and C4.5

on the history of bug ﬁxes. Xuan et al. [28] proposed improvements for the Naive Bayes classiﬁer

by utilizing expectation-maximization based on the combination of labeled and unlabeled bug

reports. They trained a classiﬁer with a fraction of labeled bug reports. Then, they iteratively

34

classiﬁed the unlabeled reports and ﬁtted a new classiﬁer with the labels of all the bug reports.

These methods only aim to optimize the accuracy, ignoring many other aspects of the bug triaging

process.

Park et al. [19] proposed a method to optimize not only the accuracy but also the cost. This

method combines the CBR model with a collaborative ﬁltering recommender (CF) model, enhanc-

ing the recommendation quality of either approach alone. Alenezi et al. [3] presented a text mining

approach to reduce the time and cost of bug triaging. They examined the use of four-term selec-

tion methods, namely, log odds ratio, chi-square, term frequency relevance frequency, and mutual

information on the accuracy of bug assignment. They aimed to choose the most discriminating

terms that describe bug reports. They then built the classiﬁer using the Naive Bayes classiﬁer on

bug reports. They also incorporated cost to re-balance the load between developers considering

their experience. Kashiwa and Ohira [12] also emphasized the distribution of the loads among

developers. Their method aims to increase the number of bugs ﬁxed by the next release. They

formulated the bug triaging process as a multiple knapsack problem that maximizes the develop-

ers’ preferences given a time limit. Consequently, it mitigates the task concentration to particular,

experienced developers.

Lee and Seo [15] presented a method that addresses the issues related to LDA ﬁxing time

calculation using a multiple LDA-based topic set. Their method improved the existing models by

building two additional topic sets, partial topic set (PTS) and feature topic set (FTS). They showed

that improved LDA has better classiﬁcation accuracy. Also, Xia et al. [27] recommended a bug

triaging method enhanced by specialized topic modeling, named multi-feature topic model (MTM),

which extends LDA by considering bugs’ components and products. Their proposed approach,

TopicMiner, considers the topic distribution of a new bug report to make recommendations based

on a developer’s aﬃnity to the topics and the feature combination. Although these works rely

on textual information, they do not consider developer engagement. Ge et al. [7] proposed a

method that overcomes this drawback. They build a high-quality dataset by combining the feature

selection and instance selection and studied the impact of developer engagement on bug triage.

They considered the product information along with the textual information in the bug report to

recommend the best developer for a new bug report.

Many recent studies investigated automating the bug triage using deep learning techniques.

35

Lee et al. [16] suggested using a Convolutional Neural Network (CNN) and word embedding to

build an automatic bug triage. Mani et al. [18] utilized an attention-based deep bi-directional

RNN model (DBRNN-A) to automate bug triage. Their approach enables the model to learn the

context representation over a long word sequence, as in a bug report. Their results show DBRNN-

A, along with the softmax classiﬁer, outperforms bag-of-words models. Guo et al. [8] proposed a

developer activity-based CNN method for bug triage that recommends a list of developers. They

combined CNN with batch normalization and pooling to learn from the word vector representation

of bug reports generated by Word2vec.

A signiﬁcant characteristic of bug reports is their dependency. However, its importance is

rarely acknowledged in the bug triage domain. Kumari et al. [14] developed a bug dependency-

based mathematical model to develop software reliability growth models. They interpreted the bug

summary description and comments in terms of entropy that also measures the uncertainty and

irregularity of the bug tracking system. In the bug triaging process, the incoming bugs are dynamic

that makes the bug dependency graph uncertain. To address this issue, Akbarinasaji et al. [2]

constructed a bug dependency graph considering two graph metrics, i.e., depth and degree. They

proposed a Partially Observable Markov Decision Process model for sequential decision making

to prioritize incoming bugs based on the bug ﬁxing history and use Partially Observable Monte

Carlo Planning to identify the best policies for prioritizing the bugs.

Diﬀerent from the previous studies, our proposed model, S-DABT, is a comprehensive model

that captures the most important aspects of the bug triage task that are speciﬁed by the domain

experts [2, 12, 19]. It uses textual information to estimate the bug ﬁxing time. Also, the infor-

mation is fed into a classiﬁer (e.g., SVM) to ﬁnd the appropriate developers. However, instead

of simply combining these values, S-DABT considers the importance of developers’ available time

slots. It uses developers’ schedule and their ability to address multiple bugs at a time in its formu-

lation. Given that constraint, it also postpones the bugs blocked by others and cannot be solved

currently, regardless of whether the blocking bug is an unassigned or assigned bug. Accordingly,

it covers the objectives of the previous works subject to its novel constraints.

8. Concluding Remarks

In this paper, we proposed a schedule and dependency-aware bug triage method (S-DABT)

that aims to reduce bug ﬁxing time and infeasible assignment of blocked bugs while considering the

36

developers’ schedule and determining the exact assignment date. S-DABT also takes into account

the workloads of the developers in the bug triage process and alleviates task concentration on a

small portion of developers. Accordingly, it reduces the number of overdue bugs before the next

release.

Although S-DABT is primarily a triaging method, it also prioritizes the bugs such that both

the complexity of the bug dependency graph and the total ﬁxing time are reduced. It extends

DABT’s awareness of bug dependencies by incorporating the constraint on blocked bugs that are

assigned and yet to be ﬁxed. This enhancement lowers the number of infeasible bug ﬁxings due

to bug dependencies in the long run. Through our experiments with four open-source software

systems, S-DABT demonstrates a robust result in terms of the reduced overdue bugs, the improved

ﬁxing time of the assigned bugs, and the decreased complexity of the bug dependency graph. The

model has lower accuracy compared to the other baselines. However, it improves the accuracy

of its predecessor, DABT. Through sensitivity analysis, we further demonstrate that it achieves

higher assignment accuracy for diﬀerent hyperparameter settings, which comes at the expense of

increased average ﬁxing time.

In this work, we assume that each developer may work on one or more bugs simultaneously.

Unlike previous works that did not consider developers’ diﬀerent characteristics, this assumption is

akin to the actual case where each developer has a diﬀerent number of working days and diﬀerent

tendencies on being focused on single or multiple tasks. A relevant venue for future research would

be to formulate an IP model in which bug assignments to developers are restricted by the software

release dates. Accordingly, it minimizes the possibility of overdue bugs. Another possible future

research direction is to incorporate constraints that explicitly order the bug assignments in the

IP model. Currently, our model reorders bugs based on their importance (e.g., ﬁxing time) as a

post-processing step. However, it can be incorporated in the model formulation, with the caveat

that it may increase the complexity of the model.

Supplementary Materials

To make the work reproducible, we publicly share our originally extracted dataset of one-

decade bug reports, scripts, and analysis on GitHub.

37

References

[1] Shirin Akbarinasaji, Ayse Bener, and Adam Neal. 2017. A Heuristic for Estimating the
Impact of Lingering Defects: Can Debt Analogy Be Used as a Metric?. In Proceedings of the
8th Workshop on Emerging Trends in Software Metrics (WETSoM ’17). IEEE Press, Buenos
Aires, Argentina, 36–42.

[2] Shirin Akbarinasaji, Can Kavaklioglu, Ay¸se Ba¸sar, and Adam Neal. 2020. Partially observable
Markov decision process to generate policies in software defect management. Journal of
Systems and Software 163 (2020), 110518.

[3] Mamdouh Alenezi, Kenneth Magel, and Shadi Banitaan. 2013. Eﬃcient Bug Triaging Using

Text Mining. JSW 8, 9 (2013), 2185–2190.

[4] John Anvik, Lyndon Hiew, and Gail C. Murphy. 2006. Who Should Fix This Bug?. In
Proceedings of the 28th International Conference on Software Engineering (Shanghai, China)
(ICSE ’06). Association for Computing Machinery, New York, NY, USA, 361–370.

[5] P. Bhattacharya and I. Neamtiu. 2010. Fine-grained incremental learning and multi-feature
tossing graphs to improve bug triaging. In 2010 IEEE International Conference on Software
Maintenance. IEEE, Timi oara, Romania, 1–10.

[6] David M Blei, Andrew Y Ng, and Michael I Jordan. 2003. Latent dirichlet allocation. the

Journal of machine Learning research 3 (2003), 993–1022.

[7] Xin Ge, Shengjie Zheng, Jiahui Wang, and Hui Li. 2020. High-Dimensional Hybrid Data
Reduction for Eﬀective Bug Triage. Mathematical Problems in Engineering 2020 (2020),
5102897.

[8] Shikai Guo, Xinyi Zhang, Xi Yang, Rong Chen, Chen Guo, Hui Li, and Tingting Li. 2020. De-
veloper activity motivated bug triaging: via convolutional neural network. Neural Processing
Letters 51, 3 (2020), 2589–2606.

[9] Viral Gupta, Deepak Kumar, and P. K. Kapur. 2019. Optimizing the Defect Prioritization in
Enterprise Application Integration. In Software Engineering, M. N. Hoda, Naresh Chauhan,
S. M. K. Quadri, and Praveen Ranjan Srivastava (Eds.). Springer Singapore, Singapore, 585–
597.

[10] Hadi Jahanshahi, Mucahit Cevik, Jos´e Navas-S´u, Ay¸se Ba¸sar, and Antonio Gonz´alez-Torres.
2022. Wayback Machine: A tool to capture the evolutionary behaviour of the bug reports
and their triage process in open-source software systems. Journal of Systems and Software -
(2022), 111308.

[11] Hadi Jahanshahi, Kritika Chhabra, Mucahit Cevik, and Ay¸se Ba¸sar. 2021. DABT: A
Dependency-Aware Bug Triaging Method. In Evaluation and Assessment in Software En-
gineering (Trondheim, Norway) (EASE 2021). Association for Computing Machinery, New
York, NY, USA, 221–230.

38

[12] Yutaro Kashiwa and Masao Ohira. 2020. A Release-Aware Bug Triaging Method Considering
Developers’ Bug-Fixing Loads. IEICE TRANSACTIONS on Information and Systems 103,
2 (2020), 348–362.

[13] Chandan Kumar and Dilip Kumar Yadav. 2017. Software defects estimation using metrics of
early phases of software development life cycle. International Journal of System Assurance
Engineering and Management 8, 4 (2017), 2109–2117.

[14] Madhu Kumari, Ananya Misra, Sanjay Misra, Luis Fernandez Sanz, Robertas Damasevicius,
and VB Singh. 2019. Quantitative quality evaluation of software products by considering
summary and comments entropy of a reported bug. Entropy 21, 1 (2019), 91.

[15] Dong-Gun Lee and Yeong-Seok Seo. 2020. Improving bug report triage performance using
artiﬁcial intelligence based document generation model. Human-centric Computing and In-
formation Sciences 10, 1 (2020), 1–22.

[16] Sun-Ro Lee, Min-Jae Heo, Chan-Gun Lee, Milhan Kim, and Gaeul Jeong. 2017. Applying
Deep Learning Based Automatic Bug Triager to Industrial Projects. In Proceedings of the
2017 11th Joint Meeting on Foundations of Software Engineering (Paderborn, Germany)
(ESEC/FSE 2017). Association for Computing Machinery, New York, NY, USA, 926–931.

[17] Jin Liu, Yiqiuzi Tian, Xiao Yu, Zhijiang Yang, Xiangyang Jia, Chuanxiang Ma, and Zheng Xu.
2016. A multi-source approach for bug triage. International Journal of Software Engineering
and Knowledge Engineering 26, 09n10 (2016), 1593–1604.

[18] Senthil Mani, Anush Sankaran, and Rahul Aralikatte. 2019. DeepTriage: Exploring the
Eﬀectiveness of Deep Learning for Bug Triaging. In Proceedings of the ACM India Joint
International Conference on Data Science and Management of Data (Kolkata, India) (CoDS-
COMAD ’19). Association for Computing Machinery, New York, NY, USA, 171–179.

[19] Jin-woo Park, Mu-Woong Lee, Jinhan Kim, Seung-won Hwang, and Sunghun Kim. 2011.
CosTriage: A Cost-Aware Triage Algorithm for Bug Reporting Systems. Proceedings of the
AAAI Conference on Artiﬁcial Intelligence 25, 1 (Aug. 2011), 139–144.

[20] Jin-woo Park, Mu-Woong Lee, Jinhan Kim, Seung-won Hwang, and Sunghun Kim. 2016.
Cost-aware triage ranking algorithms for bug reporting systems. Knowledge and Information
Systems 48, 3 (2016), 679–705.

[21] Hao Ren, Yanhui Li, and Lin Chen. 2020. An Empirical Study on Critical Blocking Bugs. In
Proceedings of the 28th International Conference on Program Comprehension (Seoul, Republic
of Korea) (ICPC ’20). Association for Computing Machinery, New York, NY, USA, 72–82.

[22] Reza Sepahvand, Reza Akbari, and Sattar Hashemi. 2020. Predicting the bug ﬁxing time
IET Software 14, 3 (2020),

using word embedding and deep long short term memories.
203–212.

[23] Inkyung Sung and Taesik Lee. 2016. Optimal allocation of emergency medical resources in
a mass casualty incident: Patient prioritization by column generation. European Journal of
Operational Research 252, 2 (2016), 623–634.

39

[24] Yuan Tian, David Lo, Xin Xia, and Chengnian Sun. 2015. Automated prediction of bug report
priority using multi-factor analysis. Empirical Software Engineering 20, 5 (2015), 1354–1383.

[25] Harold Valdivia-Garcia, Emad Shihab, and Meiyappan Nagappan. 2018. Characterizing and
predicting blocking bugs in open source projects. Journal of Systems and Software 143 (2018),
44–58.

[26] Harold Valdivia-Garcia, Emad Shihab, and Meiyappan Nagappan. 2018. Characterizing and
predicting blocking bugs in open source projects. Journal of Systems and Software 143 (2018),
44–58.

[27] Xin Xia, David Lo, Ying Ding, Jafar M Al-Kofahi, Tien N Nguyen, and Xinyu Wang. 2016.
Improving automated bug triaging with specialized topic model. IEEE Transactions on Soft-
ware Engineering 43, 3 (2016), 272–297.

[28] Jifeng Xuan, He Jiang, Zhilei Ren, Jun Yan, and Zhongxuan Luo. 2017. Automatic Bug

Triage using Semi-Supervised Text Classiﬁcation. arXiv:1704.04769 [cs.SE]

[29] Geunseok Yang, Seungsuk Baek, Jung-Won Lee, and Byungjeong Lee. 2017. Analyzing Emo-
tion Words to Predict Severity of Software Bugs: A Case Study of Open Source Projects.
In Proceedings of the Symposium on Applied Computing (Marrakech, Morocco) (SAC ’17).
Association for Computing Machinery, New York, NY, USA, 1280–1287.

[30] S. F. A. Zaidi, F. M. Awan, M. Lee, H. Woo, and C. G. Lee. 2020. Applying Convolutional
Neural Networks With Diﬀerent Word Representation Techniques to Recommend Bug Fixers.
IEEE Access 8 (2020), 213729–213747.

[31] Syed Farhan Alam Zaidi, Honguk Woo, and Chan-Gun Lee. 2022. A Graph Convolution
Network-Based Bug Triage System to Learn Heterogeneous Graph Representation of Bug
Reports. IEEE Access 10 (2022), 20677–20689.

[32] Hongyu Zhang, Liang Gong, and Steve Versteeg. 2013. Predicting bug-ﬁxing time: An empir-
ical study of commercial software projects. In 2013 35th International Conference on Software
Engineering (ICSE). IEEE, San Francisco CA USA, 1042–1051.

[33] Wei Zhang. 2020. Eﬃcient Bug Triage For Industrial Environments. In 2020 IEEE Interna-
tional Conference on Software Maintenance and Evolution (ICSME). IEEE, Adelaide, Aus-
tralia, 727–735.

40

