2
2
0
2

r
p
A
3

]
E
S
.
s
c
[

2
v
6
9
5
9
0
.
3
0
2
2
:
v
i
X
r
a

Prioritized Variable-length Test Cases Generation
for Finite State Machines

Vaclav Rechtberger
Dept. of Computer Science, FEE
Czech Technical University in Prague
Prague, Czechia
rechtva1@fel.cvut.cz

Miroslav Bures
Dept. of Computer Science, FEE
Czech Technical University in Prague
Prague, Czechia
miroslav.bures@fel.cvut.cz

Bestoun S. Ahmed
Dept. of Mathematics and Computer Science
Karlstad University, Sweden &
Czech Technical University in Prague
bestoun@kau.se

Youcef Belkhier
Dept. of Computer Science, FEE
Czech Technical University in Prague
Prague, Czechia
youcef.belkhier@fel.cvut.cz

Jiri Nema
Faculty of Military Health Sciences
University of Defence
Hradec Kralove, Czechia
jiri.nema@unob.cz

Hynek Schvach
Faculty of Military Health Sciences
University of Defence
Hradec Kralove, Czechia
hynek.schvach@unob.cz

Abstract—Model-based Testing (MBT) is an effective approach
for testing when parts of a system-under-test have the character-
istics of a ﬁnite state machine (FSM). Despite various strategies
in the literature on this topic, little work exists to handle special
testing situations. More speciﬁcally, when concurrently: (1) the
test paths can start and end only in deﬁned states of the FSM, (2)
a prioritization mechanism that requires only deﬁned states and
transitions of the FSM to be visited by test cases is required,
and (3) the test paths must be in a given length range, not
necessarily of explicit uniform length. This paper presents a
test generation strategy that satisﬁes all these requirements. A
concurrent combination of these requirements is highly practical
for real industrial testing. Six variants of possible algorithms to
implement this strategy are described. Using a mixture of 180
problem instances from real automotive and defense projects
and artiﬁcially generated FSMs, all variants are compared with
a baseline strategy based on an established N-switch coverage
concept modiﬁcation. Various properties of the generated test
paths and their potential to activate ﬁctional defects deﬁned
in FSMs are evaluated. The presented strategy outperforms the
baseline in most problem conﬁgurations. Out of the six analyzed
variants, three give the best results even though a universal best
performer is hard to identify. Depending on the application of
the FSM, the strategy and evaluation presented in this paper are
applicable both in testing functional and non-functional software
requirements.

Index Terms—Model-based Testing, Finite State Machine, Test

Automation, Path-based Testing

I. INTRODUCTION

Paper accepted at the 6th International Workshop on
Testing Extra-Functional Properties and Quality Charac-
teristics of Software Systems (ITEQS) workshop of the
15th IEEE International Conference on Software Testing,
Veriﬁcation and Validation (ICST) 2022 conference, April
4, 2022 – April 13, 2022, https://icst2022.vrain.upv.es/

Finite State Machine (FSM) character is available in various
parts of most of the modern systems, like software, electronics,
or the Internet of Things (IoT). To test these systems, a usual

approach is to exercise sequences of transitions (test paths) in
FSMs to model those parts of the System Under Test (SUT)
[1]. The goal is to create test paths (test path set) in an
optimal way, where various criteria can be considered, e.g.,
minimal test price or maximal probability to detect defects
in SUT. The satisfaction of a deﬁned test coverage criteria
is a standard prerequisite of such a process [2], [3]. The
Model-based Testing (MBT) approach renders as an effective
automated way to achieve this goal [1]–[3].

Current literature presents a variety of approaches to gener-
ate test paths from an FSM-based SUT model (e.g., [1], [4]–
[6]). However, fewer works exist for speciﬁc cases, in which
the following requirements have to be satisﬁed concurrently:
(1) test paths can start and end in deﬁned FSM states, which
are a subset of all FSM states, (2) test paths must visit only
deﬁned priority states and transitions of FSM; the rest of the
states and transitions are not required to be visited by a test
path set, and, (3) the length of the created test paths must
be in a deﬁned range (not explicitly of a certain uniform
length). Concurrent satisfaction of these three requirements
gives an FSM-based testing technique good ﬂexibility and
potential to serve the needs of industry projects. Formulation
of the requirements results from our active discussions with
industry testing experts in Rockwell, Siemens, Skoda Auto and
Electrolux companies, in which the needs for an FSM-based
testing technique were analyzed.

In practical testing, starting and ending a test in certain
states of FSM either is costly or not possible [7], [8]. The
length of the test paths also plays a signiﬁcant role. Exces-
sively long test paths might suffer from high maintenance.
Additionally, if a test path is interrupted by a defect present
in a SUT, it might be challenging to ﬁnish the test properly.
Opposite extreme, too short test paths might be burdened by
overhead that is caused by test initialization clean-up after the
test of related managerial efforts [9].

Hence, this paper proposes the Prioritized State Machine

 
 
 
 
 
 
Test (PSMT) strategy that generates sets of test paths that
satisfy the aforementioned requirements. The strategy employs
an FSM-based SUT model and two types of test coverage
criteria to model this problem. As a part of the strategy, we
present six algorithm variants that generate the test paths to
satisfy the given test coverage criteria. As a baseline, we use an
alternative N-Switch Reduction algorithm that is based on an
established N-switch coverage concept [9]–[11]. We compare
the results of the presented algorithms using 180 SUT models
that are partially derived from real automotive and defense
systems, and the parts are generated artiﬁcially.

On top of these rules, no additional requirements on how
Vts and Vte have to be chained or combined in the test paths
are given by PSMT Basic Coverage. Further, it is not required
that every vertex from Ve ∪ Vte must be present as an end
vertex of some p ∈ P . To satisfy PSMT Basic Coverage, it is
not necessary to visit neither whole E ∈ G nor even V ∈ G.
The PSMT Basic Coverage is suitable for lower intensity
tests when the situation does not require to conduct intensive
testing or there is a lack of testing resources.

P satisﬁes PSMT Extended Coverage, when all the fol-

lowing conditions are satisﬁed:

II. SUT MODEL

The SUT model G = (V, E, L, ε, vs, Ve, Vts, Vte) is a
directed multigraph, where V is a set of vertices representing
FSM states, E is a set of edges representing FSM transitions,
and L is a set of edge labels, edge e ∈ E deﬁned by
ε : E → {(s, f, l) | s, f ∈ V ∧ l ∈ L}, where s is a
start vertex of edge e, f is an end vertex of edge e, and l is
a label of edge e.

Vertex vs ∈ V is a start of the state machine, Ve ⊂ V is
a set of end vertices of the state machine, Vts ⊂ V is a set
of possible starts of test paths, Vte ⊂ V is a set of possible
end of test paths, vs ∈ Vts and Ve ⊂ Vte and Vts ∩ Vte can be
nonempty. Each edge e ∈ E has deﬁned its priority denoted as
priority(e) as well as each vertex v ∈ V has deﬁned its prior-
ity denoted as priority(v). This priority is a real number and
it holds that minP riority ≤ priority(e) ≤ maxP riority
and minP riority ≤ priority(v) ≤ maxP riority, where
minP riority and maxP riority denote minimal and maximal
level of priority, minP riority < maxP riority.

Test path p is a path in G that starts in a vts ∈ Vts and
ends in a vte ∈ Vte. A test path is a sequence of edges and P
is a set of all test paths.

III. TEST COVERAGE CRITERIA

We deﬁne two test coverage criteria that must be satisﬁed in
P . They differ by the number of test path transitions, giving
additional ﬂexibility to generate a test path set suitable for a
particular case.

P satisﬁes PSMT Basic Coverage, when all the following

conditions are satisﬁed:

1) Each of test paths p ∈ P must start in a vertex from

{vs} ∪ Vts and end in a vertex from Ve ∪ Vte,

2) for each p ∈ P , minLenght ≤ length(p) ≤
maxLength, where length(p) is length of a test path
p in number of its edges,

3) each vertex v ∈ V and edge e ∈ E with
priority(v) ≥ priority threshold and priority(e) ≥
priority threshold that can be part of some p ∈ P
which starts at some vertex from {vs}∪Vts, ends in some
vertex from Ve ∪ Vte and minLenght ≤ length(p) ≤
maxLength, where length(p) is length of p in number
of its edges, must be present in p, and,

1) P satisﬁes PSMT Basic Coverage, and,
2) each edge incoming and outgoing to each vertex v ∈
V with priority(v) ≥ priority threshold must be
present in at least one path p ∈ P , and,

3) each pair of adjacent edges (e1, e2), e1 ∈ E, e2 ∈
E, in which priority(e1) ≥ priority threshold or
priority(e2) ≥ priority threshold, must be part of
some p ∈ P .

When P satisﬁes PSMT Extended Coverage, it satisﬁes
also PSMT Basic Coverage criterion. The PSMT Extended
Coverage is designed for more intensive tests and more
transitions of FSM are executed during the tests. However,
to satisfy PSMT Extended Coverage, it is not required to visit
all transitions from E ∈ G nor all states V ∈ G.

A consequence of PSMT Basic Coverage and PSMT Ex-
tended Coverage is that for a certain G combined with certain
ranges of minLenght and maxLenght, P that satisﬁes the
test coverage criterion might not exist. This situation can be
solved by changing minLenght and maxLenght, adding
more Vts and Vte to G, or by a combination of both.

IV. ALGORITHMS

PSMT strategy is deﬁned by Algorithm 1. It accepts SUT
model G, minP riority, maxP riority, expected test path
length range minLength and maxLength,
test coverage
criterion denotes as testCoverage that can be PSMT Basic
Coverage and PSMT Extended Coverage, and test path set
reduction type denoted as reductionT ype that determines the
strategy variant. Requirement r ∈ R is a path in G or a vertex
v ∈ V (a zero length path) that must be present in a p ∈ P .
Moreover, each p ∈ P contains at least one r ∈ R. Moreover,
R must satisfy criteria as deﬁned in Section III for selected
testCoverage.

Algorithm 2 is a subroutine of the PSMT strategy and
creates an initial set of test paths P that are further reduced
by the following algorithms. As the test path set reduction
type (speciﬁed by reductionT ype), we analyzed six options,
starting with No reduction variant, followed by ﬁve reduction
variants as deﬁned by separate algorithms 3, 4, 5, 6 and 8.

These algorithms approach the problem of test path set
reduction as a well-known Set Cover Problem (SCP), where
a set of requirements R is an universe and P is as a set of
subsets of this universe, where each path p ∈ P represents a
subset of requirements Rc ⊆ R it covers.

4) any path p ∈ P is not a sub-path of other paths in P .

No reduction is a trivial variant that does not reduce P .

Algorithm 1 Generate P for G by PSMT strategy

Function: GenerateTestPathsPSMT
Input: G, minLength, maxLength, testCoverage,

minP riority, maxP riority, reductionT ype

Output: Set of test paths P

1: P ← ∅
(cid:46) an empty set of test paths
2: R ← generate requirements for testCoverage for ver-
tices v ∈ V with minP riority ≤ priority(v) ≤
maxP riority and edges e ∈ E with minP riority ≤
priority(e) ≤ maxP riority by speciﬁcation in Section
III.

3: for r ∈ R do
4:

p ← FindShortestPathInRange(r) (cid:46) Requirement r

is a path in G or vertex v ∈ V

P ← P ∪ {p}

5:
6: P ← Preduced returned by Test Path Reduction algorithm
accepting P and R that is speciﬁed by reductionT ype
(no reduction or Algorithms 3, 4, 5, 6, 8).

7: return P

end function

The simplest approach is Random speciﬁed by Algorithm
3. It iterates over all p ∈ P until all r ∈ R are covered.
If the iterated p covers some uncovered requirements, they
are marked as covered and the path is added to the ﬁnal set
Preduced, otherwise iterating continues. Finally, the reduced
set P is returned.

The variant Sorted is deﬁned in Algorithm 4. The test
path set P is ﬁrst sorted in a descendant order by a number
of covered requirements. The algorithm continues as in the
random variant (see Algorithm 3), but paths are taken in sorted
order.

Chvatal P reduction variant that bases on Chvatal’s al-
gortihm for SCP [12], [13] is deﬁned by Algorithm 5. For
performance reasons, the algorithm ﬁrst ﬁlters r ∈ R that
are sub-path of other requirements r ∈ R and removes paths
p ∈ P that do not cover any r. Chvatal’s SCP algorithm uses
R as a universe and P as a set of subsets where each path
p ∈ P represents a set of requirements Rc ⊆ R that covers.
During this SCP process, the reduced P is generated.

The next P reduction variant, Genetic Algorithm [14]
is employed to solve the SCP problem (Algorithm 6). In
the selection process, one population individual represents
a Pi ⊆ P . Besides P and R on input, the algorithm em-
ploys a set of input conﬁgurations (further GA conﬁguration),
whose particular values were determined during the experi-
ments as giving the best results. These are: initialProbability-
ToSetGene=0.2, probabilityToMutateOneGene=0.4, probabil-
ityToMutateZeroGene=0.6, maxGenerations=100, population-
Size=30, maxGenerationsWithoutImprovement=40.
In this variant, we designed our ﬁtness

f itness(individual)

is

which
(uncovered(individual)
where

individual

·
represents

function,
maxCost −
(|P | + 1) + |Pindividual|),
P ,

a Pindividual

⊆

=

Algorithm 2 Find the shortest path in range

Function: FindShortestPathInRange
Input: requirement, minLength, maxLength
Output: Path p

(cid:46) if no path is found then an empty

path is returned

1: Emap and Smap are empty maps of paths. Key in the map

is a path length.

2: Equeue and Squeue are empty queues of paths
3: pstart, pend ← ﬁrst and last vertex of requirement
4: push pend to Equeue;
5: push pstart to Squeue
6: while (Equeue is not empty) ∨ (Squeue is not empty) do
7:
8:

if Squeue is not empty then

pstart ← pull from Squeue
if |pstart| <= maxLength then
vf irst ← ﬁrst vertex of pstart
if vf irst ∈ Vts then

if Emap contains a path that can be joined
with pstart so that for the result path x, minLength ≤
length(x) ≤ minLength then

return pstart concatenated by the path

from Emap

if |pstart|+ length of shortest path from

Emap ≤ maxLength then

if Smap[|pstart|] does not exist then

Smap[|pstart|] ← pstart
if |pstart|+1 + length of the shortest path from

Emap ≤ maxLength then

for e ∈ edges incoming to vf irst do

put (e concatenate pstart) to Squeue

if Equeue is not empty then

pend ← pull from Equeue
if |pend| <= maxLength then
vlast ← last vertex of pend
if vlast ∈ Vte then

if Smap contains a path that can be joined
with pend so that for the result path x, minLength ≤
length(x) ≤ minLength then

return the path from Smap concate-

nated by pend

if |pend|+ length of shortest path from

Smap ≤ maxLength then

if Emap[|pend|] does not exist then

Emap[|pend|] ← pend

if |pend| + 1 + length of the shortest path from

Smap ≤ maxLength then

for e ∈ edges outgoing from vlast do

put (pstart concatenate e) to Equeue

9:
10:
11:
12:

13:

14:

15:
16:

17:

18:
19:

20:
21:
22:
23:
24:

25:

26:

27:

28:
29:

30:

31:
32:

33: return empty path
end function

Algorithm 3 Random P reduction

Function: Random
Input: P , R
Output: Reduced set of test paths Preduced

1: Runcovered ← R
2: Piterator ← P
3: Preduced ← an empty set of paths
4: while Runcovered (cid:54)= ∅ ∧ Piterator (cid:54)= ∅ do
pnext ← a random path from Piterator
5:
Piterator ← Piterator \ {pnext}
Rcovered ← previously uncovered requirements now

6:
7:

covered by pnext

if Rcovered (cid:54)= ∅ then

8:
9:
10:
11: return Preduced
end function

Runcovered ← Runcovered \ Rcovered
Preduced ← Preduced ∪ {pnext}

Algorithm 4 Sorted P Reduction

Function: Sorted
Input: P , R
Output: Reduced set of test paths Preduced

1: Runcovered ← R
2: Psorted ← P sorted in descending way by number of

covered requirements

3: Preduced ← an empty set of paths
4: Psorted
5: while Runcovered (cid:54)= ∅ ∧ Psorted (cid:54)= ∅ do
pnext ← ﬁrst path from Psorted
6:
Psorted ← Psorted \ {pnext}
7:
Rcovered ← requirements covered by pnext
8:
if Rcovered (cid:54)= ∅ then

Runcovered ← Runcovered \ Rcovered
Preduced ← Preduced ∪ {pnext}

9:
10:
11:
12: return Preduced
end function

maxCost = |R|·(|P |+1)+|P |, and uncovered(individual)
is a count of r ∈ R which are not a sub-path of any
p ∈ Pindividual. Crossover operation employed in the Genetic
Algorithm P reduction is further speciﬁed in Algorithm 7.

Algorithm 6 Genetic Algorithm based P reduction

Function: Genetic Algorithm
Input: P , R, populationSize,
initialP robabilityT oSetGene,
probabilityT oM utateZeroGene,
probabilityT oM utateOneGene, maxGenerations,
maxGenerationsW ithoutImprovement
Output: Reduced set of test paths Preduced

1: Rf iltered ← R from which ﬁlter requirements that are not

a sub-path of any p ∈ P are removed

2: initialize population

(cid:46) Each individual is represented
by an array of bits where each bit is set with probability
initialP robabilityT oSetGene

3: do
4:

of f springs

Crossover(population,
populationSize, |P |, probabilityT oM utateZeroGene,
probabilityT oM utateOneGene)

←

5:

6:

7:
8:

population ← population ∪ of f springs
survivals1 ← (populationSize/10) individuals from
population having the highest value of the ﬁtness function

population ← population \ survivals1
sutvivals2 ← (populationSize − |survivals1|) sur-
vivals using a roulette wheel [15] with same GA conﬁg-
uration from population

population ← survivals1 ∪ survivals2

9:
10: while terminate criteria are not met

(cid:46)
terminate criteria are met when maximal number of
generation maxGenerations is achieved, best possi-
ble individual is found or there is no improvement for
maxGenerationsW ithoutImprovement generations
11: Preduced ← test paths represented by selected best indi-

viduals

12: return Preduced
end function

Algorithm 5 Chvatal-SCP-based P reduction

Function: Chvatal
Input: P , R
Output: Reduced set of test paths Preduced

1: Rf iltered ← R\Rremove, where Rremove = {r1 | r1 ∈ R,

r1 is not a sub-path of other r2 ∈ R and r1 (cid:54)= r2 }

2: Pf iltered ← P from which all test paths that do not

contain any r ∈ Rf iltered are removed

3: Preduced ← reduce Pf iltered using Chvatal’s SCP algo-
rithm as deﬁned in [12] in such a way that R is as an
universe and P is a set of subsets, where each p ∈ P
represents a Rc ⊆ R that covers.

4: return Preduced
end function

The last variant to compare is P reduction done via Simu-
lated Annealing as speciﬁed by Algorithm 8. In the algorithm,
we have used a geometric annealing schedule. Hence, besides
P and R, the algorithm accepts the α coefﬁcient for this
schedule and, based on the experiment results, α = 0.8 was
used.

The N-Switch Reduction strategy bases on established N-
Switch Coverage concept used in FSM testing [9]–[11] and
is deﬁned by Algorithm 9. The algorithm accepts the same
inputs as the PSMT strategy (see Algorithm 1) and produces
P as an output. The algorithm ﬁrst generates all paths in G
of length n, where minLength ≤ n ≤ maxLength, which
are put to the initial P . Then, the algorithm reduces P to keep
only paths that starts in {vs} ∪ Vts and ends in some vertex
from Ve ∪ Vte. Then, paths of p are further analyzed if more

Algorithm 7 Crossover operation of Genetic Algorithm based
P reduction

Function: Crossover
Input: population, populationSize, chromosomeLegth,
probabilityT oM utateZeroGene,
probabilityT oM utateOneGene
Output: of f springs

1: of f springs ← init empty set of individuals
2: for n = 1 to (cid:98)populationSize/3(cid:99) do
3:

Choose parent1 and parent2 using the roulette wheel

4:

5:

6:

7:

using the GA conﬁguration

point1, point2 ← generate two random points such

that 0 < point1 < point2 < chromosomeLength

2

1

2

1

to point th

gene of parent1, point th

Create of f spring1 and of f spring2 by combination
of parents’ chromosomes, such that of f spring1 has zero
to point th
gene
of parent2 and point th
to the last gene of parent1. For
of f spring2 do the same process, only switch parent1
and parent2.
Mutate
of f spring1
ability
probabilityT oM utateZeroGene if
or not respectively
of f springs

gene
random
of f spring2
with
probabilityT oM utateOneGene

of
prob-
or
set

the gene is

of f springs

one
and

∪

←
{of f spring1, of f spring2}

8: return of f springs

end function

paths start in a particular vertex from {vs} ∪ Vts and if so,
only one of these paths is kept in P .

V. EXPERIMENTS

All presented algorithms are implemented in the developer
version of the Oxygen1 platform [16], [17]. The platform
allows for the creation of the SUT model in its graphical editor.
It also allows to import and export of the SUT models in open
XML-based formats. The selected algorithms can generate
test path sets for a set of SUT models. Test paths can then
visualized in the model and exported. An example of Oxygen
user interface with visualized test path in a SUT model is given
in Figure 1. SUT model states from Vts, |Vte| and |Vts∩Vte| are
highlighted by green, red and orange color, respectively. The
developer version of the platform allows for batch execution
of the present algorithms on multiple SUT models and export
of summary results for further analysis and evaluation.

A. Experiment set-up and method

For the experiments, we used 180 problem instances G.
These instances are composed of: (1) state machine models
of real industrial project, (2) modiﬁcations of the industrial
real models, and (3) problem instances generated artiﬁcially.
Regarding the industrial FSMs, six models describing various

Algorithm 8 Simulated Annealing P reduction

Function: Simulated Annealing
Input: P , R, coefﬁcient α for geometric annealing

schedule

Output: Preduced

1: pointactual ← a random point in the solution space

(cid:46)
Solution is represented by an array of bits of size |P |. A
point deﬁnes p ∈ P , that are used in the solution, if nth
bit is set then nth path of P is used. paths(point) denotes
a Ppoint ⊆ P that
is represented by point. Further,
covered(paths) denotes a Rcovered ⊆ R such that each
r ∈ Rcovered is a sub-path of a p ∈ P

2: pointbest ← pointactual
3: t ← |P |2.2 · 1.5
4: do
5:

t(cid:48) ← t
do

6:
7:

8:

9:
10:
11:

12:

13:

14:

15:

pointneighbour ← point with a random bit

switched

delta ← energy(pointneighbour)−energy(point)
(cid:46) energy(point) = |R \ covered(paths(point))| · (|P | +
1) + |paths(point)|

if delta < 0 then

pointactual ← pointneighbour
if
energy(pointbest) then
solution is the new best one

energy(pointneighbour)

<
(cid:46) Check whether the new

pointactual ← pointneighbour

else if Random(0, 1) < Exp(−delta/t) then
(cid:46) Exp(x) returns the natural exponential of x and
Random(a, b) returns random number n ∈ [a, b] of
uniform distribution

pointactual ← pointneighbour

while the loop is iterated (cid:100)t(cid:101)-times where t is actual
(cid:46) Equilibrium is reached
(cid:46) Geometric cooling schedule is used
(cid:46) Is frozen

temperature
t ← α · t
16:
17: while t < 0.000001
18: Preduced ← paths(pointbest)
19: return Preduced
end function

parts of tested Skoda cars were used. The Skoda Auto testing
team created these models in a special Skoda version of
the Oxygen tool supporting G. These models were further
modiﬁed by adding cycles to an FSM, adding possible test
starts and test ends, adding or removing a state, and adding and
removing a transition. In this paper, by a cycle, we mean a con-
ﬁguration of edges that allow non-empty trails in which only
the ﬁrst and last vertices are equal. The result was 24 problem
instances. Another 12 problem instances were created by the
same method for FSMs for data transmission protocols and
mission management in the Digital Triage Assistant project2,

1http://still.felk.cvut.cz/oxygen/

2https://www.natomultimedia.tv/app/asset/656263

Fig. 1. Example of Oxygen editor with visualization of a test path in a SUT model.

Algorithm 9 Generate test paths for SUT model by N-Switch
Reduction strategy

Function: N-Switch Reduction
Input: G, minLength, maxLength, minP riority,

maxP riority, testCoverage

Output: Set of test paths P

(cid:46) empty set of paths

1: Pf ull ← ∅; P ← ∅
2: for e ∈ E do
3:

Pe ← all paths in G such that for each p ∈ Pe
minLength ≤ length(p) ≤ minLength and e is the
ﬁrst edge in p

Pf ull ← Pf ull ∪ Pe

4:
5: R ← generate requirements for testCoverage for ver-
tices v ∈ V with minP riority ≤ priority(v) ≤
maxP riority and edges e ∈ E with minP riority ≤
priority(e) ≤ maxP riority by speciﬁcation in Section
III.

Rp ← requirements from R which are sub-path of p
if Rp (cid:54)= ∅ then

6: for each p ∈ Pf ull do
7:
8:
9:
10:

R ← R \ Rp; P ← P ∪ {p}
if R = ∅ then

11:
12: return P

break the loop

end function

a joint project of CTU in Prague, Johns Hopkins University,
University of Defence, NATO ACT IH and other partners.
Non-disclosure agreements and conﬁdentiality restrictions of
both projects allow making publicly available only abstracted
topology of FSMs without the names of states and transitions.

To create enough variety of possible FSMs, we generated
an additional set of 144 problem instances by a specialized
tool, developed as a master thesis by Richard Sadlon3, CTU in
Prague. The tool generates G problem instances by expected
properties of the graph entered as an input. In this process,
|V |, |E|, number of G cycles, |Vts|, |Vte|, |Vts ∩ Vte|, and |Ve|
can be speciﬁed.

Table I presents the selected properties of all problem
instances used in the experiments. In Table I, cycles denotes
number of G cycles, avg cycle length denotes average length
of these cycles, parallel edge groups denotes number of
groups of parallel edges present in G (in these groups, edges
start and end in the same vertex), parallel edges denotes
total number of parallel edges in G, avg D+ denotes average
node incoming degree, avgD− denotes average node outgoing
degree, and avg D denotes average node degree. Further,
|Vts ∩ Vte| denotes the state in which a test path can both
start and end.

Regarding the priorities deﬁned in the SUT model,
priority(v) as well as priority(e) were set to range 0 to
3 for all v ∈ V , resp. e ∈ E, for all problem instances. Then,
minP riority was set to 2 and maxP riority was set to 3 in
a uniﬁed way for the experiment. In Table I, priority vertices
denotes number of v ∈ V for which minP riority ≤
priority(e) ≤ maxP riority and I, priority edges denotes
number of e ∈ V for which minP riority ≤ priority(v) ≤
maxP riority.

To evaluate the effectiveness of the generated P to detect
defects,
the problem instances were extended by ﬁctional
defects of two types. Type 1 Defect is present at an edge e ∈ E
representing FSM transition and is considered to be activated

3https://dspace.cvut.cz/handle/10467/97079

when a p ∈ P visits e. In Table I, number of these defects in
problem instances is denoted as type 1 def ects.

Type 2 defect is present at two edges e1 ∈ E and e2 ∈ E,
where there is a path in G from e1 to e2. To consider Type
2 defect to be activated, a p ∈ P visits e1 and then visits
e2. Type 2 Defects simulate data consistency defects, when a
transition e1 induces an internal inconsistency to a SUT and
other transition (e2) causes a defective behavior of the SUT.
the number of Type 2 defects in problem
instances is denoted as type 2 def ects and average dis-
tance between e1 and e2 in number of edges is denoted as
e1 to e2 avg distance.

In Table I,

TABLE I
PROPERTIES OF PROBLEM INSTANCES USED IN THE EXPERIMENTS.

G property
|V |
|E|
cycles
avg cycle length
|Ve|
parallel edges
parallel edge groups
avg D+
avg D−
avg D
|Vts|
|Vte|
|Vts ∩ Vte|
priority nodes
priority edges
type 1 def ects
type 2 def ects
e1 to e2 avg distance

Mean Median MIN MAX
20.33
34.81
3.23
9.27
2.09
0.53
0.27
1.77
1.77
3.55
2.33
2.59
1.14
5.66
9.75
7.00
6.26
2.69

10
19
0
0
1
0
0
1.04
1.04
2.08
1
1
0
0
2
1
1
0.67

15
35
3
8
1
0
0
1.53
1.53
3.07
2
2
1
5
9
6
6
2.50

57
95
18
31
21
18
9
2.33
2.33
4.67
17
25
6
21
34
28
27
6.60

|P |,

We evaluated the following properties of P :

total
length of all p ∈ P in number of edges (denoted as steps),
average length of all p ∈ P in number of edges (denoted as
avg steps), number of unique edges in all p ∈ P (denoted as
unique steps). We also analyzed ut = len
unique that expresses
how many non-unique FSM transitions (G edges) need to
repeat in a test path to test the unique transitions. Higher ut
indicates higher ”edge duplication” in P .

To evaluate the defect detection potential of P , we analyzed
the number of simulated defects of Type 1 and Type 2 that
were activated by a p ∈ P , denoted as T ype 1 activated
and T ype 2 activated, respectively. The last property to
evaluate is averaged number of simulated defects activated
by one test path step, deﬁned as ef f1 = T ype 1 activated
and ef f2 = T ype 2 activated
for Type 1 and Type 2 simulated
defects, respectively.

steps

steps

We ran all presented algorithms for both PSMT Basic
Coverage and PSMT Extended Coverage criteria. In each of
these criteria, we present and discuss the results for two test
path length ranges: minLength = 2, maxLength = 6 and
minLength = 4, maxLength = 8. If no P was returned for
a particular problem instance for the individual conﬁguration
of test path length range and the coverage criterion by any of
the compared algorithms, the result record was not taken into
account for all algorithms for this problem instance. Because

of the non-deterministic nature of the Genetic Algorithm and
Simulated Annealing test path reduction variants of the PSMT
strategy, we ran all computations three times and averaged the
results.

B. Results

Table II presents the averaged results for all problem in-
stances for all compared algorithms and both coverage criteria
for the test path length range minLength = 2, maxLength =
6. The major properties we further analyze and discuss are
steps, ef f1 and ef f2. The best results for these properties
are marked by bold and the second-best result by italics in the
data. Regarding T ype1activated, T ype2activated, ef f1 and
ef f2 in Table II, particular simulated defect can be activated
more times by test paths from P and these multiple activation
are included in the results.

For PSMT Basic Coverage,

the Sort variant of PSMT
produced P with the lowest number of total steps (13.87 on
average), followed by Simulated Annealing variant (14.28 on
average). This is more than a twofold difference compared to
the No reduction variant and approximately one-third differ-
ence to N-Switch Reduction serving as a baseline. The most
important properties to evaluate are ef f1 and ef f2. The best
average value of ef f1 was achieved in P generated by the
Sort variant of PSMT (0.313 defects per one test path step),
followed by Simulated Annealing variant (0.304). This is 20%
better result than the baseline N-Switch Reduction. In the
case of ef f2, N-Switch Reduction (average ef f2 = 0.04)
outperforms Sort and Chvatal PSMT variants, the second-
best performers, by approximately 25%. However, a relatively
small portion of T ype2 defects is detected by generated P for
all algorithms, approx. ten-times less than for Type 1 defects.
Analyzing the same test coverage criteria for minLength =
4, maxLength = 8 test path length range (see Table III),
Genetic Algorithm variant of PSMT generated P with the
best steps (18.55), followed by Sort variant (18.58). Baseline
N-Switch Reduction produced P with the number of steps
56% higher than the Genetic Algorithm variant. Regarding
ef f1, the Genetic Algorithm and Sort variants yield the best
result (0.297), 30% better than N-Switch Reduction. For Type
2 defects (ef f2), N-Switch Reduction outperforms the other
algorithms, and the difference to the second-best performer,
the Simulated Annealing PSMT variant, is 10%.

For PSMT Extended Coverage criterion and minLength =
2, maxLength = 6 length range (second part of Table II), the
best average steps is achieved by Sort PSMT variant (51.29),
followed by Chvatal variant (56.3). The result of the N-Switch
Reduction baseline is 30% worse compared to the Sort variant.
In terms of ef f1, the Sort variant yields the best result (0.215),
followed by the Simulated Annealing variant (0.203). The
result of the Sort variant is better by 16% than for the N-Switch
Reduction baseline. Regarding ef f2, no signiﬁcant difference
between N-Switch Reduction and the second-best algorithm,
the Sort variant of PSMT is present in the data.

For the minLength = 4, maxLength = 8 length range,
the Sort PSMT variant gives the best average value of steps

TABLE II
PROPERTIES OF GENERATED P FOR minLength = 2, maxLength = 6, AVERAGE VALUE FOR ALL PROBLEM INSTANCES.

P property

No reduction

Random Sorted

Chvatal Genetic Algorithm Simulated Annealing

PSMT strategy variant

N-Switch Reduction
(baseline)

PSMT Basic Coverage

steps
|P |
avg steps
unique steps
ut
T ype 1 activated
T ype 2 activated
ef f1
ef f2

29.18
9.30
3.28
13.97
2.12
5.35
0.58
0.182
0.020

PSMT Extended Coverage

steps
|P |
avg steps
unique steps
ut
T ype 1 activated
T ype 2 activated
ef f1
ef f2

141.77
40.09
3.61
18.76
6.73
7.22
1.36
0.064
0.009

15.75
4.83
3.43
11.89
1.27
4.55
0.44
0.282
0.028

58.04
15.13
3.89
18.68
2.33
7.20
1.36
0.192
0.026

13.87
4.15
3.54
11.31
1.18
4.36
0.45
0.313
0.032

51.29
12.84
4.07
18.62
2.05
7.18
1.34
0.215
0.030

14.99
4.54
3.51
11.57
1.23
4.45
0.48
0.297
0.032

56.34
14.68
3.87
18.66
2.26
7.20
1.36
0.194
0.027

15.63
4.81
3.55
11.64
1.20
4.47
0.46
0.298
0.030

95.82
27.15
3.95
18.67
2.98
7.20
1.36
0.196
0.026

14.28
4.31
3.54
11.43
1.18
4.39
0.44
0.304
0.030

78.01
21.26
3.97
18.66
2.53
7.20
1.36
0.203
0.027

22.05
4.68
4.66
14.26
1.45
5.44
1.00
0.259
0.040

66.31
13.36
4.61
19.11
2.52
7.36
1.94
0.185
0.031

(61.03), and the baseline N-Switch Reduction result is 40%
higher (85.85). The second-best performer in steps is the
Chvatal variant (63.48). For ef f1, Sort PSMT variant per-
formed best with 0.198 defects per one P steps, a 20% differ-
ence to N-Switch Reduction baseline (0.164). The second-best
performers were Chvatal and Simulated Annealing variants,
ef f1 = 0.186. No signiﬁcant differences were observed for
ef f2 among the compared algorithms.

Generally, the differences in ef f1 between the best algo-
rithm and N-Switch Reduction baseline are higher for PSMT
Basic Coverage than for PSMT Extended Coverage. For ef f2,
N-Switch Reduction outperformed other algorithms for PSMT
Basic Coverage. No signiﬁcant differences were observed for
PSMT Extended Coverage criterion.

VI. DISCUSSION
Various properties of P can be evaluated. Property steps
can be considered as a reasonable proxy for the effort to
execute or automate the tests. When the goal is to satisfy the
given test coverage criteria, the reduction of steps makes good
sense from a test effort viewpoint. However, the reduction of
steps has to be analyzed in the context of defects that can be
found in SUT by P . More extensive P increases the chances
of activating defects present in SUT, and reducing steps can
decrease this chance. Hence, ef f1 and ef f2 values based on
ﬁctional defects in FSM and their activation by P have to be
analyzed as more objective indicators.

In the presented data, one distribution of Type 1 and Type
2 was used for each of the 180 problem instances. With the
other distribution of ﬁctional defects, the results might differ.
Moreover, the preferred test path length (< M inLength −
M axLength > interval) inﬂuences the results, as can be seen
in the comparison of Tables II and III.

Despite the general good performance of Sort variant of
PSMT in steps and ef f1, also Genetic Algorithm, Simulated

Annealing and Chvatal set cover variants performed well in
individual combinations of parameters, test coverage criteria
and test path length range (see Tables II and III). Moreover,
the baseline N-Switch Reduction gave the best results for ef f2
in three out of four evaluated combinations of test coverage
criteria and test path length range. However, in interpreting this
result, we need to consider that only a relatively small portion
of T ype2 defects is detected by generated P for all algorithms.
Here, the average number of defects detected by one P step
is approx. tenfold lower than this number for Type 1 defects.
Hence, the classical FSM-based technique, as discussed in this
paper, shows potentially ineffective to detect T ype2 defects
and shall be replaced by some specialized data consistency
testing techniques, e.g., [18].

To conclude, no ”universal clear winner” can be identiﬁed
among the analyzed algorithms. Sort variant of PSMT gives
the best results for steps and detection of Type 1 defects
on average. However, it has not produced the P with the
best ef f1 for all combinations of the problem instance, test
coverage criteria, and test path length range in the experiments.
N-Switch Reduction was the best option for Type 2 defects
for PSMT Basic Coverage criterion. But also, this result was
not achieved for all combinations of the problem instance,
test coverage criteria, and test path length range. For PSMT
Extended Coverage criterion, no signiﬁcant difference was
observed for the presented experiment conﬁguration.

Hence, a combination of the presented algorithms with a
portfolio strategy (e.g., [19]) seems like the best option to yield
close-to-optimum P . Such a strategy would compute P1..Pn
for particular G by individual algorithms and selection of P
having the best property which is given in input.

TABLE III
PROPERTIES OF GENERATED P FOR minLength = 4, maxLength = 8, AVERAGE VALUE FOR ALL PROBLEM INSTANCES.

P property

No reduction

Random Sorted

Chvatal Genetic Algorithm Simulated Annealing

PSMT strategy variant

N-Switch Reduction
(baseline)

PSMT Basic Coverage

steps
|P |
avg steps
unique steps
ut
T ype 1 activated
T ype 2 activated
ef f1
ef f2

45.92
9.73
4.89
16.58
2.81
6.36
1.11
0.144
0.025

PSMT Extended Coverage

steps
|P |
avg steps
unique steps
ut
T ype 1 activated
T ype 2 activated
ef f1
ef f2

203.10
42.33
5.02
20.22
9.25
7.76
1.96
0.045
0.009

20.86
4.37
5.05
14.26
1.41
5.46
0.89
0.271
0.042

66.38
13.53
5.19
20.06
2.51
7.71
1.85
0.183
0.034

18.58
3.85
5.14
13.58
1.32
5.26
0.82
0.297
0.042

61.03
12.32
5.33
19.99
2.33
7.69
1.85
0.198
0.037

20.33
4.24
5.08
14.04
1.39
5.43
0.84
0.280
0.042

63.48
12.89
5.25
20.07
2.42
7.73
1.85
0.186
0.035

18.55
3.85
5.14
13.63
1.30
5.30
0.81
0.297
0.042

115.35
24.76
5.25
20.06
3.43
7.72
1.89
0.184
0.033

20.07
4.21
5.13
13.79
1.33
5.35
0.84
0.295
0.043

95.50
20.16
5.25
20.05
2.93
7.71
1.88
0.186
0.034

29.02
4.40
6.45
16.03
1.69
6.14
1.33
0.229
0.047

85.85
12.41
6.50
20.40
3.04
7.83
2.55
0.164
0.035

VII. RELATED WORK

The number of algorithms generating a set of test paths
from an FSM-based model was published in the literature [1],
[4]–[6], [8], [20]. However, much fewer works exist on the
problem as deﬁned in this paper. Hence, we analyze algorithms
and approaches containing elements that overlap our problem
and can potentially be utilized for its solution.

Liu and Xu proposed a comparable approach to generate
a test path set for FSM [21]. As a SUT model, RFSM is
employed. RFSM extends FSM with a special notation of
labels that give the RFSM the ability to model more details
[22]. An algorithm is used to transform RFSM into a regular
expression and generate the test paths. In another proposal
by Alava et. al., FSM-based test path generation is used
to generate automated tests for web applications [23]. The
proposal practically supports Node Coverage Edge Coverage
criteria in FSM.

Devroey et al. generate test suites for software product lines
using a problem model that bases on FSM [24]. Authors use
a branch and bound approach and use heuristics for efﬁcient
test path search. The algorithm explores the graph using
a prioritization mechanism. Prioritization score is evaluated
using an accessibility matrix computed by a modiﬁed Warshall
algorithm. Klalil and Labiche presented an approach for gen-
erating test paths from FSM [25] that supports the Round Trip
Coverage criterion. Alternative test coverage criteria such as
Random, Depth Traversal and Breadth Traversal are discussed
as well and compared.

In the alternative approaches, Carvalho and Tsuchiya exploit
model checking to generate test paths for SUT parts described
as FSMs, as model checkers can generate counterexamples as a
proof when a model does not satisfy the speciﬁcation [26]. The
proposal practically supports Node Coverage, Edge Coverage
and Edge-pair Coverage criteria. Kilincceker et al. proposed

a test path generation method from an FSM, which is further
conversed to a regular expression [27]. In this approach, a
Context Table is used, and the source code of the algorithms
can be obtained freely [28]. Kilincceker et al. also presented
an approach for generating test paths using an FSM-based
SUT model that is derived from a speciﬁcation in Hardware
Description Language (HDL) language [29] and further trans-
formed to a regular expression, which is an extension of the
model by Liu et al. mentioned in [30]. To obtain the test paths,
the regular expression is parsed into a syntax tree from which
the test paths are ﬁnally generated using an algorithm speciﬁed
in the study. Fazli and Mohsen explore the generation of prime
test paths [31] and compare three approaches for prime path
generation for FSM. Their proposal outperforms the compared
alternatives in terms of memory consumption and processing
time.

Despite the fact that FSM testing is a well-established sub-
area of the system testing discipline, no work we have found
is concurrently and directly addressing (1) the possibility to
explicitly set the start and end of a test path in a SUT model,
(2) the possibility to prioritize the states and transitions of
FSM to be present in the test paths, and, (3) possibility to
determine expected length range of generated test paths [5],
[6], [8], [20].

VIII. CONCLUSION

The paper presents a PSMT strategy to generate test path
sets from an FSM-based SUT model, which concurrently
allows for (1) expression of FSM states in which test paths can
start and end, (2) selection of FSM priority states and transi-
tions that must be included in a set of test paths, whereas the
other can be neglected, and (3) speciﬁcation of a length range
that the generate test paths must ﬁt in. These requirements
result from the analysis of the FSM-based testing process in

four large companies, Rockwell, Siemens, Skoda Auto and
Electrolux. A concurrent combination of requirements (1)-(3)
gives the technique good ﬂexibility in real industrial testing
processes. Depending on the application of the FSM,
the
strategy is applicable for the testing of both functional and
non-functional software requirements.

Since addressing these three requirements concurrently is
under-explored in the literature, the presented ﬁndings are
useful for further research in this direction. Six variants of
the PSMT strategy were presented and compared with an N-
Switch Reduction baseline based on the established N-switch
coverage concept.

More extensive experiments and measurements have to be
done in the future to draw more conclusions, as the results
might vary by the distribution of artiﬁcial defects and the
distribution of priority FSM states and transitions in FSMs
employed as problem instances in the experiments. Out of
the compared alternatives, Sort variant, Simulated Annealing,
and Genetic Algorithm variants give promising results to be
the Sort variant was the
elaborated further. Out of these,
best performer overall. However, the results indicate that a
universal algorithm performing the best way for all possible
problem instances would be difﬁcult to formulate. Instead,
combining a few best performers with a portfolio strategy is
likely to obtain the best results.

ACKNOWLEDGMENT

The project is supported by CTU in Prague internal grant
SGS20/177/OHK3/3T/13 “Algorithms and solutions for au-
tomated generation of test scenarios for software and IoT
systems.” The authors acknowledge the support of the OP
VVV funded project CZ.02.1.01/0.0/0.0/16 019 /0000765
“Research Center for Informatics.” Bestoun S. Ahmed has
been supported by the Knowledge Foundation of Sweden
(KKS) through the Synergi Project AIDA - A Holistic AI-
driven Networking and Processing Framework for Industrial
IoT (Rek:20200067).

REFERENCES

[1] P. Ammann and J. Offutt, Introduction to software testing. Cambridge

University Press, 2016.

[2] M. Utting, A. Pretschner, and B. Legeard, “A taxonomy of model-based
testing approaches,” Software testing, veriﬁcation and reliability, vol. 22,
no. 5, pp. 297–312, 2012.

[3] T. Ahmad, J. Iqbal, A. Ashraf, D. Truscan, and I. Porres, “Model-
based testing using uml activity diagrams: A systematic mapping study,”
Computer Science Review, vol. 33, pp. 98–112, 2019.

[4] D. Lee and M. Yannakakis, “Principles and methods of testing ﬁnite
state machines-a survey,” Proceedings of the IEEE, vol. 84, no. 8, pp.
1090–1123, 1996.

[5] M. Aggarwal and S. Sabharwal, “Test case generation from uml state
machine diagram: A survey,” in 2012 Third International Conference on
Computer and Communication Technology.
IEEE, 2012, pp. 133–140.
[6] A. C. Dias Neto, R. Subramanyan, M. Vieira, and G. H. Travassos,
“A survey on model-based testing approaches: a systematic review,”
in Proceedings of the 1st ACM international workshop on Empirical
assessment of software engineering languages and technologies: held
in conjunction with the 22nd IEEE/ACM International Conference on
Automated Software Engineering (ASE) 2007, 2007, pp. 31–36.

[7] K. Derderian, R. M. Hierons, M. Harman, and Q. Guo, “Estimating
the feasibility of transition paths in extended ﬁnite state machines,”
Automated Software Engineering, vol. 17, no. 1, pp. 33–56, 2010.

[8] A. S. Kalaji, R. M. Hierons, and S. Swift, “Generating feasible transition
paths for testing from an extended ﬁnite state machine (efsm),” in 2009
international conference on software testing veriﬁcation and validation.
IEEE, 2009, pp. 230–239.

[9] M. Vroon, B. Broekman, T. Koomen, and L. van der Aalst, TMap next:

for result-driven testing. Uitgeverij kleine Uil, 2013.

[10] M. Pol, R. Teunissen, and E. Van Veenendaal, Software testing: A guide

to the TMap approach. Pearson Education, 2002.

[11] L. v. d. Aalst, R. Baarda, E. Roodenrijs, J. Vink, and B. Visser, “Tmap

next, business driven test managament,” 2008.

[12] V. Chvatal, “A greedy heuristic for

the set-covering problem,”
Mathematics of Operations Research, vol. 4, no. 3, pp. 233–235, Aug.
1979. [Online]. Available: https://doi.org/10.1287/moor.4.3.233

[13] N. E. Young, Greedy Set-Cover Algorithms. Boston, MA: Springer
US, 2008, pp. 379–381. [Online]. Available: https://doi.org/10.1007/
978-0-387-30162-4 175

[14] D. Whitley and A. M. Sutton, “Genetic algorithms-a survey of models
Springer Berlin

and methods,” in Handbook of natural computing.
Heidelberg, 2012, pp. 637–671.

[15] V. K. Verma and B. Kumar, “Genetic algorithm: an overview and its
application,” International Journal of Advanced Studies in Computers,
Science and Engineering, vol. 3, no. 2, p. 21, 2014.

[16] M. Bures, “Pctgen: Automated generation of test cases for application
workﬂows,” in New Contributions in Information Systems and Technolo-
gies. Springer, 2015, pp. 789–794.

[17] M. Bures, T. Cerny, and M. Klima, “Prioritized process test: More efﬁ-
ciency in testing of business processes and workﬂows,” in International
Conference on Information Science and Applications. Springer, 2017,
pp. 585–593.

[18] M. Bures and V. Rechtberger, “Dynamic data consistency tests using
a crud matrix as an underlying model,” in Proceedings of the 2020
European Symposium on Software Engineering, 2020, pp. 72–79.
[19] M. Bures and B. S. Ahmed, “Employment of multiple algorithms for
optimal path-based test selection strategy,” Information and Software
Technology, vol. 114, pp. 21–36, 2019.

[20] S. Mouchawrab, L. C. Briand, Y. Labiche, and M. Di Penta, “Assessing,
comparing, and combining state machine-based testing and structural
testing: A series of experiments,” IEEE Transactions on Software
Engineering, vol. 37, no. 2, pp. 161–187, 2010.

[21] P. Liu and Z. Xu, “Mttool: A tool for software modeling and test

generation,” IEEE Access, vol. 6, pp. 56 222–56 237, 2018.

[22] P. Liu and H. Miao, “A new approach to generating high quality test
cases,” in 2010 19th IEEE Asian Test Symposium, 2010, pp. 71–76.
[23] J. Alava, T. M. King, and P. J. Clarke, “Automatic validation of java
page ﬂows using model-based coverage criteria,” in 30th Annual Interna-
tional Computer Software and Applications Conference (COMPSAC’06),
vol. 1, 2006, pp. 439–446.

[24] X. Devroey, G. Perrouin, and P.-Y. Schobbens, “Abstract

test
lines,”
case generation for behavioural
in Proceedings of
the 18th International Software Product Line
Conference: Companion Volume for Workshops, Demonstrations and
Tools - Volume 2, ser. SPLC ’14. New York, NY, USA: Association
for Computing Machinery, 2014, p. 86–93.
[Online]. Available:
https://doi.org/10.1145/2647908.2655971

testing of software product

[25] H. Khalil and Y. Labiche, “State-based tests suites automatic generation
tool (stage-1),” in 2017 IEEE 41st Annual Computer Software and
Applications Conference (COMPSAC), vol. 1, 2017, pp. 357–362.
[26] C. de Souza Carvalho and T. Tsuchiya, “Coverage criteria for state
transition testing and model checker-based test case generation,” in 2014
Second International Symposium on Computing and Networking, 2014,
pp. 596–598.

[27] O. Kilincceker, A. Silistre, M. Challenger, and F. Belli, “Random test
generation from regular expressions for graphical user interface (gui)
testing,” in 2019 IEEE 19th International Conference on Software
Quality, Reliability and Security Companion (QRS-C), 2019, pp. 170–
176.

[28] Kilincceker, “Model-based ideal testing of gui programs,” https://github.

com/kilincceker/MBIT4SW, 2020.

[29] O. Kilinccceker, E. Turk, M. Challenger, and F. Belli, “Regular ex-
pression based test sequence generation for hdl program validation,” in
2018 IEEE International Conference on Software Quality, Reliability
and Security Companion (QRS-C), 2018, pp. 585–592.

[30] P. Liu, J. Ai, and Z. J. Xu, “A study for extended regular expression-
based testing,” in 2017 IEEE/ACIS 16th International Conference on
Computer and Information Science (ICIS), 2017, pp. 821–826.

[31] E. Fazli and M. Afsharchi, “A time and space-efﬁcient compositional
method for prime and test paths generation,” IEEE Access, vol. 7, pp.
134 399–134 410, 2019.

