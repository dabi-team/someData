Low-Code Programming Models

Martin Hirzel
IBM Research
USA

2
2
0
2

y
a
M
4

]
L
P
.
s
c
[

1
v
2
8
2
2
0
.
5
0
2
2
:
v
i
X
r
a

ABSTRACT
Traditionally, computer programming has been the preroga-
tive of professional developers using textual programming
languages such as C, Java, or Python. Low-code program-
ming promises an alternative: letting citizen developers cre-
ate programs using visual abstractions, demonstrations, or
natural language. While low-code programming is currently
getting a lot of attention in industry, the relevant research
literature is scattered, and in fact, rarely uses the term “low-
code”. This article brings together low-code literature from
various research fields, explaining how techniques work
while providing a unified point of view. Low-code has the
potential to empower more people to automate tasks by cre-
ating computer programs, making them more productive and
less dependent on scarce professional software developers.

1 INTRODUCTION
Low-code is the subject of much current enthusiasm stirred
by market research companies and confirmed by vendors
rushing to embrace the label [7, 32]. But it is cryptic exactly
what low-code programming means, let alone how it works,
and the scientific literature hardly uses the term. We can
decode the term by breaking it into its components. Program-
ming means developing computer programs, which comprise
instructions for a computer to execute. Traditionally, pro-
gramming means writing code in a textual programming
language, such as C, Java, or Python. In contrast, low-code
programming minimizes the use of a textual programming
language. Instead, it aims to use alternative techniques that
are closer to how users naturally think about their task.

Users of low-code range from professional developers to
so-called citizen developers. A citizen developer is an amateur
programmer with little professional programming education.
Citizen developers, having chosen a career different from
programming, tend to have more domain expertise. Low-
code enables domain experts to become citizen developers. At
the same time, low-code platforms should also strive to make
pro-developers (professionals with an education or career in
software development) more productive.

Whether used by a citizen developer or a pro-developer,
low-code programming aims to save the time and tedium
of performing a task by hand [35]. Further motivation for
individuals comes from the joy of creating something useful,
thinking about tasks in a computational way, and acquiring
programming skills that can advance their career. Besides

individuals, businesses may have their own motivation for
adopting low-code platforms. Low-code platforms can al-
leviate the shortage of pro-developers, reduce mistakes of
tedious manual tasks, and multiply the time savings from
one individual’s low-code program to their colleagues [32].
Another factor driving low-code is the rise of cloud-based
software as a service, providing both more interfaces to au-
tomate and a platform on which to deploy automations.

A few concepts are closely related to low-code program-
ming. No-code programming is more purist, with zero hand-
written code in a textual programming language. This term
mostly appears in marketing materials and analyst reports.
End-user programming (EUP) puts the emphasis on who
is doing the programming (the end-user as citizen devel-
oper) rather than on how they are not doing their program-
ming (not with textual code) [6]. This term is common in
the academic literature and overlaps with low-code, but does
not preclude the use of a textual programming language. An-
other gap between EUP and low-code is that the latter aims
to serve not just end users but also pro-developers [7, 32].

Bock and Frank [7] and Sahay et al. [32] recently compared
commercial low-code platforms, and Barricelli et al. recently
mapped the end-user programming literature [6]. In con-
trast, this article bridges the gap between low-code and the
academic literature and adds missing details and perspective.
Low-code encompasses more specialized techniques, such
as VPLs (visual programming languages), PBD (program-
ming by demonstration), PBE (programming by example),
RPA (robotic process automation), PBNL (programming by
natural language), and others. Surveys on these are more
specific and often dated [4, 8, 22, 35]. In contrast, this article
reviews recent literature across all above-listed techniques.
Given that low-code offers citizen developers a model to
create computer programs, this article explores low-code
from the perspective of programming models. A program-
ming model is a set of abstractions that supports developing
computer programs. Programming models can be low-code
or not, and they can be domain-specific or general-purpose.
Some programming models are languages; e.g., Java is a
general-purpose language and SQL is domain-specific, and
neither is low-code. Scratch is a low-code programming
model for kids that is media-centric [30], making it domain-
specific. The programming-model perspective helps this ar-
ticle highlight common techniques for writing, reading, and
executing programs. Furthermore, the programming-model

 
 
 
 
 
 
Martin Hirzel

2

perspective helps relate low-code to research into program
synthesis and domain-specific languages.

This article includes a deep-dive for three prominent low-
code techniques: visual programming, programming by de-
monstration, and programming by natural language. The
deep-dive focuses on fundamental building blocks and a uni-
fying framework common to all three. The citations in this
article cover both seminal work and recent advances in low-
code programming models, for instance, based on artificial
intelligence. Overall, this article aims to cut through the buzz
surrounding low-code so as to expose the technical founda-
tions underneath. We hope that doing so will foster better
development of the field through awareness of existing (al-
beit scattered) research. Ultimately, we hope this will lead to
even more empowered citizen developers.

2 PROBLEM STATEMENT
If low-code is the solution, then what is the problem? Given
the term low-code, it might seem that the answer is obvi-
ously code. Unfortunately, that answer is superficial and non-
constructive. Defining a thing solely by what it is not, as the
term low-code appears to do, causes confusion. Consider two
other recent similarly-named trends: NoSQL and serverless.
At the surface, one might think NoSQL was mostly about
rejecting SQL, but in fact, it was more about flexible data and
consistency models than about the query language. Similarly,
serverless computing was not about eliminating compute
servers, but about hiding them behind better abstractions.
Defining a new trend by rejecting an old one grabs attention
at the expense of being misleading. Just like serverless still
needs servers, low-code (and even no-code!) still needs code.
Instead, the three terms low-code, NoSQL, and serverless
have one thing in common: a desire to avoid specific bag-
gage while preserving core value. In NoSQL, the core value
is durable and consistent storage. In serverless, it is portable
and elastic compute. What then is the core value that low-
code aims to preserve? This article argues that it is computer
programming. Programming is to low-code what comput-
ing is to serverless. Low-code is about creating instructions
for a computer to execute or interpret. These instructions
form a computer program, typically in a domain-specific
language (DSL). For instance, low-code is often based on
search-based program synthesis, and synthesis usually tar-
gets a DSL carefully crafted for the purpose [2]. The program
may not be exposed to the user, but it is there.

One way to better understand the problem statement be-
hind low-code is to look at who it is for. The top portion of
Figure 1 shows the spectrum of low-code users. They range
from citizen developers at one end to pro-developers at the
other end, with intermediate stages here dubbed semi devel-
opers. In this simplified view, users at the citizen developer

Figure 1: Low-code users and techniques.

end of the spectrum tend to have the most domain knowledge
and users at the pro-developer end have the most program-
ming expertise. Low-code can enable citizen developers to
self-serve their programming needs instead of depending on
pro-developers. At the same time, low-code can make pro-
developers more productive, e.g., in a new domain. Finally,
low-code can break barriers between developers across the
spectrum and help them collaborate on common ground.

The middle portion of Figure 1 shows three representative
low-code techniques. Programming expertise induces a Venn
diagram over the users, with the smallest subset being able
to use the largest range of programming techniques. An edge
between a set of users and a low-code technique indicates
that the users write or read a program with that technique.
Specifically, all users can use programming by demonstra-
tion and programming by natural language (edges to the
outermost set of users encompassing citizen-, semi-, and pro-
developers). Only semi-developers and pro-developers can
readily use visual programming, though citizen developers
may be easily trained to do so, as evidenced by Scratch [30].
And only pro-developers are likely to directly use a domain-
specific language (DSL). Therefore, while low-code typically
targets a DSL, that DSL may not be exposed, or if it is, may
only be exposed to pro-developers. That is especially true in
the common case of a DSL that is embedded [18] in a general-
purpose textual programming language such as Python.

If the core value of low-code is to create computer pro-
grams, what exactly is it about created programs that is
deemed valuable? One way to shed more light on this ques-
tion is to look at a seemingly opposing trend, namely the
as-code movement. The as-code movement started with in-
frastructure as code, which automates standing up compute
resources and the services running on them from a source
code repository and a backup [19]. By treating this process

CitizenDeveloperProfessionalDeveloperGeneral-purpose Programming LanguageDomain Specific LanguageProgramming by DemonstrationProgramming by Natural LanguageVisual Programming LanguageSemiDeveloperLow-Code Programming Models

3

as code, organizations can speed it up, reduce mistakes, and
facilitate testing. Another instance of as-code is security as
code, where security policies, templates, and configuration
files all live in a source code repository [26]. By treating them
as code, they can be versioned, inspected by humans, and
checked by machines. To summarize, the as-code movement
sees value in programs that are repeatable, tested, versioned,
human-readable, and machine-checkable. These are also de-
sirable properties for low-code programs.

When citizen developers use low-code, it is typically to
create a program that saves time on a task they would other-
wise do by hand. We will round out the problem statement
by looking at what tasks low-code is good for. Generally
speaking, low-code helps if it shaves off more time from a
task than the time spent doing the low-code programming.
This is true for tasks that are repetitive or time-consuming.
Of course, the equation shifts when the program can be used
not just by the developer who created it, but also by others,
shaving time off of their tasks as well. In the extreme, pro-
developers create programs used by millions. Low-code is
most appropriate when it saves time, but not enough time to
make professional coding economically feasible. Low-code is
suitable for tasks that are rule-based and low on exceptions.
And besides the time savings, it can be even more beneficial
when the tedium of doing the task by hand causes errors.

3 TECHNIQUES
This section is a deep-dive into three representative tech-
niques for low-code programming: VPLs (visual program-
ming languages), PBD (programming by demonstration), and
PBNL (programming by natural language). These three are
a good set for the following reasons. Sahay et al.’s paper
declares low-code as synonymous with just one technique,
VPLs [32], but we found that perspective too narrow. Barri-
celli et al. list 14 different techniques for end-user program-
ming [6], but they are not clearly separated, and reviewing
them all in detail would get too long-winded. In the past, the
dominant low-code technique has been spreadsheets [9]. The
three techniques we chose instead align with present and
future trends: VPLs are central to current commercial low-
code platforms [32]; PBD is the back-bone of robotic process
automation (RPA), which often uses record-and-replay [35];
and PBNL is poised to grow thanks to advances in deep
learning based large language models [11, 34, 39].

Furthermore, the three techniques are well-suited for citi-
zen developers by drawing upon universal skills: VPLs draw
upon seeing, PBD draws upon the ability to use a computer
application, and PBNL draws upon speaking. In fact, low-
code can offer an alternative modality when some other
approach is impeded, such as using speech interfaces when a
user’s hands or eyes are unavailable. Finally, VPLs, PBD, and

PBNL are sufficient to span a set of building blocks that can
also be arranged differently for use with other low-code tech-
niques, such as spreadsheets, rules, wizards, or templates. Not
all building blocks appear in all techniques, but the following
blocks recur enough to warrant brief up-front definitions:

• code canvas: renders code, e.g., visually as a flow graph
• palette: offers components for drag-and-drop selection
• text box: holds natural-language text used for code

search, description, or generation

• player: has buttons for capture, replay, pause, or step
• stage: shows the effect of code execution
• configuration pane: lets the user customize compo-
nents, e.g., via graphical controls such as check-boxes
or sliders, or textually by typing small formulas
Low-code techniques support not just writing programs,
but also reading and executing them. Low-code techniques
differ in which of the above-listed building blocks are en-
gaged to read, write, or execute programs. Whereas Figure 1
blurred the read/write/execute distinction by using undi-
rected edges, the rest of this section explicates the distinction
by using directed edges and colors (orange for read, dark
blue for write, and purple for execute).

3.1 Visual Programming Languages

The user drags visual components from a palette
to a canvas, connects them, and configures them.

Figure 2: Visual programming languages.

Description. Visual programming languages let users write
programs by directly manipulating their visual representa-
tion. There is a plethora of possible visual representations [8],
often inspired by domain notation, such as electrical cir-
cuit diagrams. Two prominent domain-independent visual
representations are boxes-and-arrows (e.g., BPMN [28]) or
interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes
or puzzle pieces represent instructions in the program, and
arrows between boxes or the interlock of pieces represent
how data and control flows between instructions.

Despite the diversity in visual languages, their program-
ming environments tend to comprise similar building blocks,
as depicted in Figure 2. The central building block is the code

PaletteCode canvasStageConfig. paneMartin Hirzel

4

canvas, where the user can both read (red arrow from can-
vas to eye) and write (blue arrow from hand to canvas) the
program. Writing the program also involves dragging compo-
nents from the palette to the canvas and possibly configuring
them in a separate configuration pane. The programming en-
vironment also often includes a stage, which visually shows
a concrete program execution in progress. For example, in
Scratch, the stage shows sprites in a virtual world. Besides
making the environment more engaging, the stage is also
crucial for program understanding and debugging. To facili-
tate this, the stage is usually tightly connected to the canvas,
helping the user navigate back and forth.

Strengths, weaknesses, and mitigations. One strength of VPLs
is that they tend to be easy to read, either by reusing notation
that is already familiar to the domain expert or by using a
clean notation with general appeal [8]. Another strength is
that, in contrast to PBD or PBNL, VPLs are usually unam-
biguous, thus increasing programmer control and reducing
mistakes. Finally, compared to textual programming lan-
guages, visual languages can rule out syntax errors [37] and
even simple type errors [30] by construction.

In the context of low-code programming, the main weak-
ness of visual programming languages is that they are not
always self-explanatory; that is why Figure 1 connects them
to semi-developers. The mitigation for this need-to-learn is
user education, and for some VPLs, education is a primary
purpose [30]. The visual notation can take up a lot of screen
real estate; the mitigation for this is to elide detail, e.g., by
requiring a configuration pane or via modular language con-
structs [3, 27]. Even the palette can get too full, hindering
discoverability, which can be mitigated by search facilities. A
drawback of visual languages compared to textual languages
is that they tend to be co-dependent on their visual program-
ming environment, hindering the use of basic tools such as
diffing or search, or of third-party tools such as linters or
code generators. This can be mitigated by backing the visual
language with a textual domain-specific language [37].

Literature. Some seminal VPLs include Harel’s StateCharts
system specification language [16]; BPMN-on-BPEL for mod-
eling and executing business processes [28]; and the Scratch
language for teaching kids programming [30]. Boshernit-
san and Downes chronicle early VPLs and categorize them
into purely visual vs. hybrid (mixed with text), and complete
(sufficient procedural abstraction and data abstraction to be
self-hosting) or not [8].

Other papers address VPL implementation approaches,
such as meta-tools (tool used to implement other tools) and
the model-view-controller (MVC) pattern (which lets users
manipulate the same model through multiple synchronized
views). VisPro is a meta-tool for creating visual program-
ming environments [40]. VisPro advocates for a coordinated

set of visual and textual languages, using MVC to expose
the same program (model) via multiple languages (views).
More recently, Blockly is a meta-tool for creating VPLs with
interlocking puzzle pieces [29] like in Scratch. And mage is a
meta-tool for embedding VPLs in notebooks [21]. Some VPLs
target pro-developers and are embedded in professional pro-
gramming environments or languages. Projectional editing,
such as in MPS [37], doubles down on the MVC paradigm,
where even the textual language is projected into a view
that precludes syntax errors. More recent work has demon-
strated VPLs as libraries extending textual languages such
as Racket (a Lisp dialect) [3] and Elm (an ML dialect) [27].

3.2 Programming by Demonstration

The user demonstrates the behavior on a canvas,
with some configuration during or after recording.

Figure 3: Programming by demonstration.

Description. In programming by demonstration, the user
demonstrates how to perform a task by hand via the mouse
and keyboard, and the PBD system records a program that
can perform the same task automatically. As shown in Fig-
ure 3, the demonstration happens on a stage, which may be
a specific application like a spreadsheet, or a web browser
visiting a variety of sites and apps, or even a general com-
puter desktop or smart-phone screen. Ideally, the recorded
program abstracts from perceptions to a symbolic repre-
sentation, for instance, by mapping pixel coordinates to a
user-interface widget, or several keystrokes to a text string.
Besides the stage, most PBD systems have a player with but-
tons to record and replay, plus often additional buttons such
as pause or step (reminiscent of interactive debuggers).

The program is most useful if executing it does not yield
exactly the same behavior as the initial demonstration, but
rather, generalizes to different data. For example, a program
for ordering a taxi to any new location is more general and
more useful than a program for ordering a taxi to only a
single hard-coded location. Generalizing typically requires
identifying variables or parameters, and may even entail
adding conditionals, loops, or function calls. Unfortunately,
a single demonstration is an inherently ambiguous speci-
fication for such a more general program. Therefore, PBD

StagePlayerConfig. paneCode canvasLow-Code Programming Models

5

systems often also provide a configuration pane that allows
users to disambiguate the generalization either during or
after demonstration. Some PBD systems also have a code
canvas that renders the recorded program for the user to
read, e.g., visually or in natural language.

Strengths, weaknesses, and mitigations. The main strength of
programming by demonstration is that the user can work
directly with the software applications they are already fa-
miliar with from their day-to-day work [23]. This makes
PBD well-suited for citizen developers, as there is no indi-
rection between programming and execution. Furthermore,
a demonstration is more concrete than a program in a dif-
ferent paradigm, since it works on specific values and has a
straight-line flow of control and data.

Unfortunately, being so concrete is also PBD’s main weak-
ness: to turn a demonstration into a program, it must be gen-
eralized, and automatic generalization may not capture the
user’s intent [14]. Mitigations include hand-configuration [23]
or multi-shot demonstration [15]. PBD can be brittle with
respect to the graphical user interface of the application
on stage, especially when that changes; mitigations include
heuristics and specialized recorders that can map perception
to application-level concepts [33]. Generalization can also
overshoot, allowing a program to plow ahead even in unfore-
seen circumstances [17]. This can be mitigated by providing
guard-rails, such as an attended execution mode that asks
the user to confirm before certain actions. Finally, PBD can
result in programs that are hard to understand because they
include spurious steps or are too fine-grained, which is of
course a problem in low-code programming [10]. This can
be mitigated by pruning and by discovering macro-steps.

Literature. A good example of a PBD system is CoScripter,
where the stage is a web browser and the code canvas dis-
plays the program in natural language [23]. The CoScripter
paper describes interviews that informed its design, as well
as experiences from real-world usage in a business setting.
In Rousillon, the stage is also a web browser and the canvas
displays the program in a VPL, fusing sequences of several
low-level steps into a single puzzle piece [10]. In VASTA,
the stage is the display of a mobile phone, and the system
uses machine learning to reverse-engineer screenshots into
user interface elements [33]. In DIYA, the stage is a web
browser and users customize the program during recording
via voice input [14]. Robotic Process Automation applies PBD
to business processes, by letting a human business worker
demonstrate a process on the existing software and referring
to the automatic replay engine as a robot [35].

Programming by demonstration (PBD) is closely related
to programming by example (PBE), since a demonstration is
an elaborate example. FlashFill is a seminal PBE system that
uses example input and output columns in a spreadsheet to

synthesize a program for transforming inputs to outputs [15].
Both PBD and PBE are based on program synthesis [2]. Re-
cent work has harnessed novel machine-learning techniques
for program synthesis, such as learned search strategies in
DeepCoder [5] and learned libraries in DreamCoder [13].

PBD can be profitably combined with other low-code tech-
niques. The play-in / play-out approach is a PBD system co-
designed with its own VPL based on sequence diagrams [17].
And SwaggerBot is a PBD system embedded in a natural-
language conversational agent, enabling a form of PBNL [36].

3.3 Programming by Natural Language
The user enters natural language text via keyboard
or voice, and the system synthesizes a program.

Figure 4: Programming by natural language.

Description. In this low-code technique, the user enters text
in natural language, either by typing on the keyboard or via
speech-to-text. Figure 4 indicates these two possibilities via
blue arrows from the user’s hand or mouth to the text canvas.
The PBNL system translates the user’s text, or utterance, to
a program. The system can optionally render the program
on a code canvas for the user to read. This rendering might
use a VPL, or it might use a controlled natural language [22]
for a disambiguated version of the user’s utterance. The
PBNL system can execute the program immediately or save
it for later, and the user may choose to execute the program
multiple times, e.g., after changes to the program’s input
data. The system can also optionally show the effect of the
program’s execution on a stage. For example, if the program
is a query in a spreadsheet, the spreadsheet is the stage, and
the result can be shown as a new table.

Strengths, weaknesses, and mitigations. The main strength
of PBNL is that it is not just low-code, but more generally,
low on demands during programming. As shown in Fig-
ure 4, its programming environment has only three building
blocks (text canvas, code canvas, and stage), and all three are
optional. That means PBNL can in principle even be applied
in circumstances where the user’s hands and eyes are other-
wise occupied. PBNL makes it particularly easy for citizen
developers to create programs. Another strength of PBNL

StageText canvasCode canvasMartin Hirzel

6

is its expressiveness: natural language can express virtually
anything humans want to communicate. PBNL restricts nei-
ther the sophistication nor the domains of programs.

Unfortunately, while PBNL makes creating programs triv-
ial, those programs are often wrong [4]. Natural language is
ambiguous, since humans are often vague and tend to omit
context or assume common ground. On top of that, natural
language processing (NLP) technologies are imperfect. The
optional code canvas and stage mitigate this weakness, by
showing the user the synthesized program or its effect, thus
giving them a chance to correct it. Another mitigation is
to encourage users to keep their utterances short and not
take advantage of the full expressiveness of natural language,
since simpler programs are easier to get right [24]. Further-
more, some PBNL systems support hand-editing the program.
Another weakness of PBNL systems is that they often re-
quire an aligned corpus of utterances and programs to train
machine-learning models, and obtaining such a corpus is
expensive. Mitigating this is an active research topic in the
machine-learning research community [34, 38].

Literature. As an interdisciplinary field of research, PBNL is
best illuminated through multiple surveys. Androutsopoulos
et al. surveyed natural-language interfaces to databases, a
prominent form of PBNL going back to the 1960s [4]. A
common approach is to parse a natural-language utterance
into a tree and then map that tree to a database query. Kuhn
surveyed controlled natural languages (CNLs), which restrict
inputs to be unambiguous while preserving some natural
properties [22]. Compared to unrestricted natural language,
CNLs may make it harder for citizen developers to write
programs, but may make it easier to write correct programs.
Allamanis et al. surveyed machine learning for code, arguing
that code has a “naturalness” that makes it possible to adapt
various NLP technologies to work on code [1]. The survey
covers some code-generating models relevant to PBNL.

The most successful NLP technology applied to PBNL
is semantic parsers, which are machine-learning models
that translate from natural language to an abstract syntax
tree (AST) of a program. For instance, SILT learns rule-based
semantic parsers that have been demonstrated for programs
that coach robotic soccer teams or for programs that query
geographic databases [20]. The Overnight paper addresses
the problem of obtaining an aligned corpus for training a
semantic parser via synthetic data generation and crowd-
sourced paraphrasing [38]. Pumice tackles the ambiguity of
natural language by a dialogue, where the system prompts
for clarification which the user can provide via natural lan-
guage or demonstration [24]. And Shin et al. show how to
coax a pre-trained large language model into doing semantic
parsing without requiring fine-tuning [34].

Another approach to PBNL is program synthesis, which
typically searches a space of possible programs [2]. Desai et
al. describe a meta-synthesizer that, given a DSL grammar
and an aligned corpus, creates a synthesizer from natural
language to programs in the DSL [12]. PBNL is not limited
to domain-specific languages for citizen developers. Yin and
Neubig describe a semantic parser that uses deep learning to
encode a sequence of natural-language tokens, then decodes
that into a Python AST [39]. Codex is a pre-trained large
language model for natural language first fine-tuned on un-
labeled code, then fine-tuned again on an aligned corpus of
utterances and programs [11].

4 PERSPECTIVES

Table 1: Comparing low-code techniques.

Technique

Activity

Write

Read

Execute

Ambi-
guity

Need to
learn

Visual
programming
languages

code canvas,
palette,
config. pane

code
canvas

stage

low

medium

Programming
by demon-
stration

stage,
player,
config. pane

code
canvas

player,
stage

medium

low

Programming
by natural
language

text canvas

code
canvas

stage

high

low

While the previous section covered three low-code tech-
niques in depth, this section covers cross-cutting topics be-
yond any single technique. Table 1 compares the three tech-
niques from Section 3. The Activity columns indicate how
each technique supports the user in writing, reading, and
executing programs. The main difference is in the Write col-
umn: users write programs mainly on the code canvas for
VPLs, the stage for PBD, and a text canvas in PBNL. On the
other hand, there is little difference in the Read and Execute
columns: users read programs on a code canvas (if provided),
and watch them executing on the stage (if visible). That hints
at an opportunity for reusing building blocks across tools
for different techniques.

A core problem with low-code programming is ambiguity.
While visual programming languages can be rigorous and
unambiguous, there is ambiguity in how to generalize from
a demonstration to a program that works in different situ-
ations, and natural languages are inherently ambiguous as
well. More ambiguous techniques may only work reliably on
small and simple problems. Systems for PBD and PBNL must
guess at the user’s intent, and are likely to guess wrong when
programs get complicated. This motivates offering users an
option to read or even correct programs or their executions.

Low-Code Programming Models

7

A core goal of low-code programming is to reduce the
need to learn a programming language. Citizen developers
can demonstrate a program or describe it in natural lan-
guage without having been taught how to do so. Visual
programming, on the other hand, is often not quite as self-
explanatory, which is why Figure 1 associates it more with
semi-developers. On the other hand, depending on the user’s
attitude, the need-to-learn can also be a positive aspect, since
it grows computational thinking skills.

Artificial Intelligence for Low-Code. Does the ongoing rapid
progress in AI fuel progress in low-code? This article argues
that yes, it does, in proportion to the ambiguity of the low-
code technique. Out of the three techniques in Table 1, AI is
most prominent for PBNL, which is also the most ambigu-
ous. PBNL can hardly avoid AI except by using a controlled
natural language [22], but that would make it feel more like
code. Currently a rising AI approach for PBNL is to use
large language models with code generation [11, 34]. We
expect PBNL to grow along with relevant advances in AI.
AI is also prominent in PBD, which Table 1 characterizes
as medium ambiguity. For example, DeepCoder shows the
interplay between program synthesis for defining a space of
possible programs and checking whether a given program is
correct, and AI for guiding the search through that space [5].
As another example, VASTA uses speech recognition, ob-
ject recognition, and optical character recognition to better
understand a user’s demonstration of a task [33].

Communicating with Humans and Machines. Pro-developers
use code in textual programming languages to communicate
with a computer, telling it what to do. In addition, develop-
ers can also use programming languages to communicate
with each other or with their own future self. A low-level
programming language such as C gives developers more con-
trol, whereas a high-level language such as Python arguably
makes communication among humans more effective. Simi-
larly, low-code programs can also serve both to communicate
instructions to a computer and to communicate among low-
code users. Being even more high-level than, say, Python,
low-code can serve as a lingua franca to help citizen develop-
ers and pro-developers communicate more effectively with
each other. For instance, a citizen developer might use PBD
to communicate a desired behavior to a pro-developer to
flesh out [17]. Conversely, a pro-developer might use PBNL
or a VPL to communicate a proposed behavior to a domain
expert for explanation or approval [28].

Domain-Specific Languages for Low-Code. All three low-code
techniques from Section 3 are intrinsically related to domain-
specific languages (DSLs): most visual programming lan-
guages are DSLs (e.g. Scratch [30]), and both programming

by demonstration and programming by natural language usu-
ally target DSLs (e.g. DIYA targets its co-designed ThingTalk
2.0 DSL [14]). Mernik et al. list further benefits of DSLs: they
facilitate program analysis, verification, optimization, paral-
lelization, and transformation (AVOPT) [25].

While reviewing the low-code literature reveals a close tie
to DSLs, those DSLs are not always exposed to the user. For
instance, the DSL may manifest as a proprietary file format
or as an undocumented internal representation. If the DSL is
exposed, users can more easily read, test, and audit programs,
version them and store them in a shared repository, and
manipulate them with tools for program transformation or
generation. Also, an exposed DSL is less locked into a specific
programming environment or its vendor. When exposed,
the DSL should be designed for humans, possibly based on
interviews and user studies as role-modeled by Leshed et
al. [23]. On the other hand, a DSL that is not exposed will be
shaped by different factors, such as the ease of enumerating
valid programs, which can be improved by asymmetry [13].
DSLs (including DSLs for low-code) may be embedded in
a general-purpose language. Compared to a stand-alone DSL,
an embedded DSL is often easier to implement (e.g., due to
not requiring a custom parser) and easier to use (e.g., due to
syntax highlighting and auto-completion tools of the host
language). The approach to implementing an embedded DSL
depends on the facilities of the host language. One approach
is Pure Embedding, which uses higher-order functions and
lazy evaluation, such as in Haskell [18]. Another example is
Lightweight Modular Staging, which uses operator overload-
ing and dynamic compilation, such as in Scala [31].

Figure 5: Model-view-controller for low-code.

Model View Controller. The current state-of-the-art VPLs
and associated meta-tools are based on the model-view-
controller (MVC) pattern. And in PBD or PBNL, even though
the user does not use a code canvas to write a program, the
system may optionally provide a code canvas for reading it,
in which case they also use MVC. Figure 5 illustrates MVC

ModelControllerViews / ProjectionsCode canvas (visual)Code canvas (textual)StagePlayerConfiguration paneDomain-specific languageMartin Hirzel

8

with a superset of the components from each low-code tech-
nique. Low-code programming tools provide one or more
views of the program. Some of these views, or projections,
are read-only, while others are read-write views. When mul-
tiple views are present, the system keeps them in synch with
a single joint model, and through that, with each other. Edits
in one view are projected live to all other views. The model is
a program in a domain-specific language (DSL). As discussed
previously, the DSL may or may not be exposed to the user,
and may or may not be embedded in a host programming lan-
guage. Optionally, the system may even expose the textual
DSL as another view, for instance, in a structure editor [37].
Besides the model and the view, the third part of the MVC
pattern is the controller, which, for low-code, can contain a
player and/or a configuration pane.

Combining Multiple Low-Code Techniques. When users write
a program by demonstration or by natural language, the
system may let them read their program on a code canvas.
And once a system lets users read programs on a code can-
vas, a logical next step is to also let them write programs
there, such as, to correct mistakes from generalization or
from natural language processing. This yields a combination
of low-code techniques, where users can write programs in
multiple ways. Such combinations can compensate for weak-
nesses of techniques. For example, in Rousillon, the user first
writes a program by demonstrating how to scrape data from
web pages [10]; since one weakness of PBD is ambiguity,
Rousillon next shows the resulting program to the user in a
scratch-like VPL [10]. As another example, Pumice combines
PBD with PBNL: the user first writes a program via natural
language; since one weakness of PBNL is ambiguity, Pumice
next lets the user clarify with PBD [24].

Meta-tools and Meta-circularity. A meta-tool for low-code
is a tool that is used to implement low-code tools. In tradi-
tional programming languages, meta-tools (such as parser
generators) have long been an essential part of the tool-
writer’s repertoire. Similarly, meta-tools for low-code can
speed up the development of low-code tools by automat-
ing well-known but tedious pieces. Thus, meta-tools make
it easier to build several tools or variants, for instance, to
experiment with the user experience. There are examples
of meta-tools for all three low-code techniques discussed in
Section 3: Blockly is a VPL meta-tool [29], DreamCoder is a
PBD meta-tool [13], and Overnight is a PBNL meta-tool [38].
A meta-circular tool for low-code is a meta-tool for low-
code that is itself a low-code tool. Not all meta-tools are meta-
circular tools, as that requires them to be powerful enough
for serious software development. Supporting all that power
can compromise the tool’s low-code nature: complex features
can get in the way of learning easy ones. On the positive

side, meta-circular tools can democratize the creation of low-
code tools themselves. Furthermore, tool developers who
use their own tools may empathize more with their users’
needs. Examples for meta-circular low-code tools include
VisPRO [40] and Racket [3] (both for VPLs).

Low-Code Foundation. In addition to meta-tools, are there
other reusable modules that make it easier to build new low-
code tools? The beginning of Section 3 listed several reusable
building blocks for low-code programming interfaces: code
canvas, palette, text box, player, stage, and configuration
pane. Besides making it easier to create low-code tools, such
reuse can also give different tools a more uniform look-and-
feel, thus reducing the need-to-learn. In the case of multi-
ple low-code tools for the same domain, reusing the same
domain-specific language makes them more interoperable.
Of course, low-code tools in different domains will require
different DSLs, but they may still be able to reuse some sub-
language, such as expressions or formulas with basic arith-
metic and logical operators and a function library. There are
also AI components that can be reused across low-code tools,
such as speech recognition modules, a search-based program
synthesis engine, semantic parsers, or language models.

End-user Software Engineering. Most of the discussion on low-
code programming focuses on writing a program: it enables
citizen developers to rapidly create a prototype. But what
happens over time when these programs stick around, get
used in new circumstances that the developer did not foresee,
get modified or generalized, and proliferate? At that point,
users need end-user software engineering (EUSE) for quality
control, for instance, by showing test coverage, letting users
add assertions, and helping them localize faults directly in
their low-code programming environment [9]. Another way
to support EUSE is to expose the DSL, which makes it easier
to adopt established software development workflows and
the associated tools (such as version-controlled source code
repositories, regression tests, or issue trackers) for low-code.

5 CONCLUSION
This article reviews research relevant to low-code program-
ming models with a focus on visual programming, program-
ming by demonstration, and programming by natural lan-
guage. It maps low-code techniques to target users and dis-
cusses common building blocks, strengths, and weaknesses.
This article argues that domain-specific languages and the
model-view-controller pattern constitute a common back-
bone and unifying principle across low-code techniques.

Low-Code Programming Models

9

REFERENCES
[1] Miltiadis Allamanis, Earl T Barr, Premkumar Devanbu, and Charles
Sutton. 2018. A Survey of Machine Learning for Big Code and Natu-
ralness. ACM Computing Surveys (CSUR) 51, 4 (July 2018), 81:1–81:37.
https://doi.org/10.1145/3212695

[2] Rajeev Alur, Rishabh Singh, Dana Fisman, and Armando Solar-Lezama.
2018. Search-Based Program Synthesis. Communications of the ACM
(CACM) (Nov. 2018), 84–93. https://doi.org/10.1145/3208071

[3] Leif Andersen, Michael Ballantyne, and Matthias Felleisen. 2020.
Adding Interactive Visual Syntax to Textual Code. In Conference on
Object-Oriented Programming, Systems, Languages, and Applications
(OOPSLA). https://doi.org/10.1145/3428290

[4] Ion Androutsopoulos, Graeme D. Ritchie, and Peter Thanisch. 1995.
Natural Language Interfaces to Databases – An Introduction. Natural
https://doi.org/10.1017/
Language Engineering 1, 1 (1995), 29–81.
S135132490000005X

[5] Matej Balog, Alexander L. Gaunt, Marc Brockschmidt, Sebastian
Nowozin, and Daniel Tarlow. 2017. DeepCoder: Learning to Write Pro-
grams. In International Conference on Learning Representations (ICLR).
https://openreview.net/forum?id=ByldLrqlx

[6] Barbara Rita Barricelli, Fabio Cassano, Daniela Fogli, and Antonio
Piccinno. 2019. End-user development, end-user programming and
end-user software engineering: A systematic mapping study. Journal
of Systems and Software 149 (2019), 101–137. https://doi.org/10.1016/j.
jss.2018.11.041

[7] Alexander C. Bock and Ulrich Frank. 2021. Low-Code Platform. Busi-
ness & Information Systems Engineering (BISE) 63 (2021), 733–740.
https://doi.org/10.1007/s12599-021-00726-8

[8] Marat Boshernitsan and Michael Downes. 2004. Visual Programming
Languages: A Survey. Technical Report UCB/CSD-04-1368. Univer-
sity of California, Berkeley.
https://digitalassets.lib.berkeley.edu/
techreports/ucb/text/CSD-04-1368.pdf

[9] Margaret Burnett, Curtis Cook, and Gregg Rothermel. 2004. End-User
Software Engineering. Communications of the ACM (CACM) 47, 9 (Sept.
2004), 53–58. https://doi.org/10.1145/1015864.1015889

[10] Sarah E. Chasins, Maria Mueller, and Rastislav Bodik. 2018. Rousillon:
Scraping Distributed Hierarchical Web Data. In Symposium on User
Interface Software and Technology (UIST). 963–975. https://doi.org/10.
1145/3242587.3242661

[11] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde,
Jared Kaplan, Harri Edwards, Yura Burda, Nicholas Joseph, Greg Brock-
man, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy
Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick
Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad
Bavarian, Clemens Winter, Philippe Tillet, Felipe Such, Dave Cum-
mings, Matthias Plappert, Fotios Chantzis, Elizabeth Barnes, Ariel
Herbert-Voss, Will Guss, Alex Nichol, Igor Babuschkin, Suchir Balaji,
Shantanu Jain, Andrew Carr, Jan Leike, Josh Achiam, Vedant Misra,
Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira
Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam
McCandlish, Ilya Sutskever, and Wojciech Zaremba. 2021. Evaluating
Large Language Models Trained on Code. https://arxiv.org/abs/2107.
03374

[12] Aditya Desai, Sumit Gulwani, Vineet Hingorani, Nidhi Jain, Amey
Karkare, Mark Marron, Sailesh R, and Subhajit Roy. 2016. Program Syn-
thesis Using Natural Language. In International Conference on Software
Engineering (ICSE). 345–356. https://doi.org/10.1145/2884781.2884786
[13] Kevin Ellis, Catherine Wong, Maxwell Nye, Mathias Sablé-Meyer, Lu-
cas Morales, Luke Hewitt, Luc Cary, Armando Solar-Lezama, and
Joshua B. Tenenbaum. 2021. DreamCoder: Bootstrapping Inductive
Program Synthesis with Wake-Sleep Library Learning. In Conference
on Programming Language Design and Implementation (PLDI). 835–850.

https://doi.org/10.1145/3453483.3454080

[14] Michael H. Fischer, Giovanni Campagna, Euirim Choi, and Monica S.
Lam. 2021. DIY Assistant: A Multi-Modal End-User Programmable
Virtual Assistant. In Conference on Programming Language Design
and Implementation (PLDI). 312–327. https://doi.org/10.1145/3453483.
3454046

[15] Sumit Gulwani. 2011. Automating String Processing in Spreadsheets
using Input-Output Examples. In Symposium on Principles of Program-
ming Languages (POPL). 317–330. https://doi.org/10.1145/1926385.
1926423

[16] David Harel. 1987. StateCharts: a Visual Formalism for Complex
Systems. Science of Computer Programming 8, 3 (1987), 231–274. https:
//doi.org/10.1016/0167-6423(87)90035-9

[17] David Harel and Rami Marelly. 2003. Specifying and executing be-
havioral requirements: the play-in/play-out approach. Software and
Systems Modeling (SoSyM) 2 (2003), 82–107. https://doi.org/10.1007/
s10270-002-0015-5

[18] Paul Hudak. 1998. Modular domain specific languages and tools. In
International Conference on Software Reuse (ICSR). 134–142. https:
//doi.org/10.1109/ICSR.1998.685738

[19] Adam Jacob. 2010. Infrastructure as Code. In Web Operations: Keeping
the Data on Time, John Allspaw and Jesse Robbins (Eds.). O’Reilly,
Chapter 5, 65–80.

[20] Rohit J. Kate, Yuk Wah Wong, and Raymond J. Mooney. 2005. Learning
to Transform Natural to Formal Languages. In Conference on Artificial
Intelligence (AAAI). 1062–1068. http://www.aaai.org/Library/AAAI/
2005/aaai05-168.php

[21] Mary Beth Kery, Donghao Ren, Fred Hohman, Dominik Moritz, Kanit
Wongsuphasawat, and Kayur Patel. 2020. mage: Fluid Moves Between
Code and Graphical Work in Computational Notebooks. In Symposium
on User Interface Software and Technology (UIST). 140–151. https:
//doi.org/10.1145/3379337.3415842

[22] Tobias Kuhn. 2014. A Survey and Classification of Controlled Natural
Languages. Computational Linguistics 40, 1 (2014), 121–170. http:
//www.mitpressjournals.org/doi/pdf/10.1162/COLI_a_00168

[23] Gilly Leshed, Eben M. Haber, Tara Matthews, and Tessa Lau. 2008.
CoScripter: Automating & Sharing How-to Knowledge in the Enter-
prise. In Conference on Human Factors in Computing Systems (CHI).
1719–1728. https://doi.org/10.1145/1357054.1357323

[24] Toby Jia-Jun Li, Marissa Radensky, Justin Jia, Kirielle Singarajah,
Tom M. Mitchell, and Brad A. Myers. 2019. PUMICE: A Multi-Modal
Agent That Learns Concepts and Conditionals from Natural Language
and Demonstrations. In Symposium on User Interface Software and
Technology (UIST). 577–589. https://doi.org/10.1145/3332165.3347899
[25] Marjan Mernik, Jan Heering, and Anthony M. Sloane. 2005. When and
how to develop domain-specific languages. ACM Computing Surveys
(CSUR) 37, 4 (2005), 316–344. https://doi.org/10.1145/1118890.1118892
[26] Havard Myrbakken and Ricardo Colomo-Palacios. 2017. DevSecOps:
A Multivocal Literature Review. In Software Process Improvement and
Capability Determination (SPICE). 17–29. https://doi.org/10.1007/978-
3-319-67383-7_2

[27] Cyrus Omar, David Moon, Andrew Blinn, Ian Voysey, Nick Collins, and
Ravi Chugh. 2021. Filling Typed Holes with Live GUIs. In Conference
on Programming Language Design and Implementation (PLDI). 511–525.
https://doi.org/10.1145/3453483.3454059

[28] Chun Ouyang, Marlon Dumas, Arthur H.M. Ter Hofstede, and Wil M.P.
Van Der Aalst. 2006. From BPMN Process Models to BPEL Web Services.
In International Conference on Web Services (ICWS). https://doi.org/10.
1109/ICWS.2006.67

[29] Erik Pasternak, Rachel Fenichel, and Andrew N. Marshall. 2017. Tips
for Creating a Block Language with Blockly. In Blocks and Beyond
Workshop (B&B). https://doi.org/10.1109/BLOCKS.2017.8120404

Martin Hirzel

10

[30] Mitchel Resnick, John Maloney, Andrés Monroy-Hernández, Natalie
Rusk, Evelyn Eastmond, Karen Brennan, Amon Millner, Eric Rosen-
baum, Jay Silver, Brian Silverman, and Yasmin Kafai. 2009. Scratch:
Programming for All. Communications of the ACM (CACM) 52, 11 (Nov.
2009), 60–67. https://doi.org/10.1145/1592761.1592779

[31] Tiark Rompf and Martin Odersky. 2012. Lightweight Modular Staging:
A Pragmatic Approach to Runtime Code Generation and Compiled
DSLs. Communications of the ACM (CACM) 55 (2012), 121–130. Issue
6. https://doi.org/10.1145/2184319.2184345

[32] Apurvanand Sahay, Arsene Indamutsa, Davide Di Ruscio, and Alfonso
Pierantonio. 2020. Supporting the understanding and comparison of
low-code development platforms. In Euromicro Conference on Software
Engineering and Advanced Applications (SEAA). 171–178. https://doi.
org/10.1109/SEAA51224.2020.00036

[33] Alborz Rezazadeh Sereshkeh, Gary Leung, Krish Perumal, Caleb
Phillips, Minfan Zhang, Afsaneh Fazly, and Iqbal Mohomed. 2020.
VASTA: A Vision and Language-Assisted Smartphone Task Automa-
tion System. In Conference on Intelligent User Interfaces (IUI). 22–32.
https://doi.org/10.1145/3377325.3377515

[34] Richard Shin, Christopher H. Lin, Sam Thomson, Charles Chen, Subhro
Roy, Emmanouil Antonios Platanios, Adam Pauls, Dan Klein, Jason
Eisner, and Benjamin Van Durme. 2021. Constrained Language Models
Yield Few-Shot Semantic Parsers. In Conference on Empirical Methods
in Natural Language Processing (EMNLP). 7699–7715. https://doi.org/
10.18653/v1/2021.emnlp-main.608

[35] Wil M. P. van der Aalst, Martin Bichler, and Armin Heinzl. 2018.
Robotic Process Automation. Business & Information Systems En-
gineering (BISE) 60 (2018), 269–272. https://doi.org/10.1007/s12599-
018-0542-4

[36] Mandana Vaziri, Louis Mandel, Avraham Shinnar, Jérôme Siméon, and
Martin Hirzel. 2017. Generating Chat Bots from Web API Specifica-
tions. In Symposium on New Ideas, New Paradigms, and Reflections on
Programming and Software (Onward!). 44–57. http://doi.acm.org/10.
1145/3133850.3133864

[37] Markus Voelter and Sascha Lisson. 2014. Supporting Diverse No-
tations in MPS’ Projectional Editor.. In Workshop on The Globaliza-
tion of Modeling Languages (GEMOC). 7–16. https://hal.inria.fr/hal-
01074602/file/GEMOC2014-complete.pdf#page=13

[38] Yushi Wang, Jonathan Berant, and Percy Liang. 2015. Building a
semantic parser overnight. In Annual Meeting of the Association for
Computational Linguistics (ACL). 1332–1342. https://www.aclweb.org/
anthology/P15-1129.pdf

[39] Pengcheng Yin and Graham Neubig. 2017. A Syntactic Neural Model
for General-Purpose Code Generation. In Annual Meeting of the As-
sociation for Computational Linguistics (ACL). 440–450. http://dx.doi.
org/10.18653/v1/P17-1041

[40] K. Zhang, D.-Q. Zhang, and J. Cao. 2001. Design, construction, and
application of a generic visual language generation environment. IEEE
Transactions on Software Engineering (TSE) 27, 4 (2001), 289–307. https:
//doi.org/10.1109/32.917521

