2
2
0
2

r
p
A
4

]
E
S
.
s
c
[

1
v
9
4
4
1
0
.
4
0
2
2
:
v
i
X
r
a

Mining Precise Test Oracle Modelled by FSM

Omer Nguena Timo

Universit´e du Qu´ebec en Outaouais
Campus de Saint-J´erˆome, QC, Canada
omer.nguena-timo@uqo.ca

Abstract. Precise test oracles for reactive systems such as critical con-
trol systems and communication protocols can be modelled with deter-
ministic ﬁnite state machines (FSMs). Among other roles, they serve in
evaluating the correctness of systems under test. A great number of can-
didate precise oracles (shortly, candidates) can be produced at the system
design phase due to uncertainties, e.g., when interpreting their require-
ments expressed in ambiguous natural languages. Selecting the proper
candidate becomes challenging for an expert. We propose a test-driven
approach to assist experts in this selection task. The approach uses a non
deterministic FSM to represent the candidates, includes the partitioning
of the candidates into subsets of candidates via Boolean encodings and
requires the intervention of experts to select subsets. We perform an
empirical evaluation of the applicability of the proposed approach.

Keywords: Test oracle mining; ﬁnite state machine; uncertainty; dis-
tinguishing test; constraint solver

1

Introduction

Test oracles (simply called oracles) are usually used to evaluate the correctness
of systems’ responses to test data. In black-box testing approaches, test data
are usually generated from machine-readable speciﬁcations which can also be
used in automating the evaluation of responses and the production of verdicts
on the presence of faults. In white-box testing approaches [8], test data serve to
cover some artifacts during executions of a system and an expert which plays
the role of the oracle evaluates the responses. Devising automated proper oracles
is needed; however it is a tedious task which almost always requires the human
expertise. Eﬀorts are needed to facilitate this task [2, 20] and to alleviate the
intervention of experts in recurrent test activities.

Our work consider a typical conformance testing scenario [11], where an
oracle is a deterministic ﬁnite state machine (DFSM). However, uncertainty can
occur in devising oracles. E.g., it can be a consequence of misunderstanding
or misinterpretation of requirements of systems often described with natural
languages [3,6,7]. As a result of the uncertainty, a set of candidate oracles can be
proposed. For example, machine learning-based translation approaches [7,18] for
reactive systems return the most likely DFSM, but the latter may be undesired

 
 
 
 
 
 
2

O. Nguena Timo

due to decisions made by automated translation procedures. Instead, they could
automatically return a set of candidate oracles of which the likelihood is above a
certain threshold. On the other hand when a candidate oracle is available (e.g., it
can be in the form of a Program under test), a set of its versions can be produced
mutating it with operations mimicking the introduction or the correction of
faults. Such a set can compactly be represented by a non deterministic ﬁnite state
machine (NFSM) thus modelling an imprecise oracle. The candidate oracles are
called precise in the opposite of the imprecise oracle deﬁning them. Devising an
oracle then consists in mining the proper candidate from the imprecise oracle.

In this paper we propose an approach to mining the proper oracle from an
imprecise oracle represented with a NFSM. An expert can answer queries related
to the correctness of NFSM’s responses. An answer can be either yes or no. Based
on the answers, the proper DFSM is automatically mined. We assume that the
proper oracle is not available to the expert and the expert might have limited
time resources for answering the queries. In this context, the expert cannot check
the equivalence between a candidate oracle and the unavailable proper oracle; so,
polynomial time active learning approaches inspired by L∗ [1] are less adequate
for devising the proper DFSM. In our approach, distinct responses to the same
test data permit to distinguish between candidate oracles. Responses, as well
as the corresponding test data, are automatically computed. Our approach is
iterative and applies the ”divide and conquer” principle over a current set of
”good” candidates. At each iteration step, the current candidate set is divided
into a subset of ”good” candidates exhibiting ”expected” responses to test data
and the complementary subset of ”bad” ones. The approach uses a Boolean
encoding of the imprecise oracle; it takes advantage of the eﬃciency of constraint
solvers to facilitate the search of good candidates.

The paper is organized as follows. The next section provides preliminary
deﬁnitions. In Section 3, we describe the oracle mining problem and introduce
the steps of our solution to it. In Section 4 we propose a Boolean encoding for an
imprecise oracle and test-equivalent candidates; then we present the reduction
of an imprecise oracle based on the selection of expected responses by experts.
In section 5, we propose a procedure for verifying the adequacy of a test data
set for mining an oracle and a mining procedure based on automatic generation
of test data. Experiments for promoting the applicability of the approach are
presented in Section 6. In section 7, we present the related work. We conclude
our work in Section 8.

2 Preliminaries

A Finite State Machine (FSM) is a 5-tuple S = (S, s0, X, Y, T ), where S is a
ﬁnite set of states with initial state s0; X and Y are ﬁnite non-empty disjoint
sets of inputs and outputs, respectively; T ⊆ S × X × Y × S is a transition
relation and a tuple (s, x, y, s′) ∈ T is called a transition from s to s′ with
input x and output y. The set of transitions from state s is denoted by T (s).
T (s, x) denotes the set of transitions in T (s) with input x. For a transition

Mining Precise Test Oracle Modelled by FSM

3

t = (s, x, y, s′), we deﬁne src(t) = s, inp(t) = x, out(t) = y and tgt(t) = s′. The
set of uncertain transitions in an object A is denoted by U nctn(A). Transition
t is uncertain if |T (src(t), inp(t))| > 1, i.e., several transitions from the src(t)
have the same input as t; otherwise t is certain. The number Us,x = |T (s, x)|
is called the uncertainty degree of state s on input x. US = maxs∈S,x∈XUs,x
deﬁnes the uncertainty degree of S. We say that S is deterministic (DFSM) if it
has no uncertain transition, otherwise it is non-deterministic (NFSM). In other
words US ≤ 1 if S is deterministic. S is completely speciﬁed (complete FSM) if
for each tuple (s, x) ∈ S × X there exists transition (s, x, y, s′) ∈ T .

An execution of S in s, e = t1t2 . . . tn is a ﬁnite sequence of transitions
forming a path from s in the state transition diagram of S, i.e., src(t1) = s,
src(ti+1) = tgt(ti) for every i = 1...n − 1. Execution e is deterministic if every
ti is the only transition in e that belongs to T (src(ti), inp(ti)), i.e., e does not
include several uncertain transitions from the same state with the same input.
e is simply called an execution of S if s = s0. S is initially connected, if for any
state s′ ∈ S there exists an execution of S to s′. A DFSM has only deterministic
executions, while an NFSM can have both. A trace x/y is a pair of an input
sequence x and an output sequence y, both of the same length. The trace of e is
inp(t1)inp(t2) . . . inp(tn)/out(t1)out(t2) . . . out(tn). A trace of S in s is a trace of
an execution of S in s. Let T rS(s) denote the set of all traces of S in s and T rS
denote the set of traces of S in the initial state s0. Given a sequence β ∈ (XY )∗,
the input (resp. output) projection of β, denoted β↓X (resp. β↓Y ), is a sequence
obtained from β by erasing symbols in Y (resp. X); if β is the trace of execution
e, then β↓X = inp(e) (resp. β↓Y = out(e)) is called the input (resp. output)
sequence of e and we say that out(e) is the response of S in s to (the application
of) input sequence inp(e). |X| denotes the size of set X.

Two complete FSMs are distinguished with an input sequence for which they
produce diﬀerent responses. Given input sequence x ∈ X ∗, let outS(s, x) denote
the set of responses which can be produced by S when x is applied at state s,
that is outS(s, x) = {β↓Y | β ∈ T rS(s) and β↓X = x}. Given state s1 and s2
of an FSM S and an input sequence x ∈ X ∗, s1 and s2 are x-distinguishable,
denoted by s1 6≃x s2 if outS(s1, x) 6= outS(s2, x); then x is called a distinguishing
input sequence for s1 and s2. s1 and s2 are x-equivalent, denoted by s1 ≃x s2
if outS(s1, x) = outS(s2, x). s1 and s2 are distinguishable, denoted by s1 6≃ s2,
if they are x-distinguishable for some input sequence x ∈ X ∗; otherwise they
are equivalent. Let a ∈ X. A distinguishing input sequence xa ∈ X + for s1
and s2 is minimal if x is not distinguishing for s1 and s2. Two complete DFSMs
S1 = (S1, s0
2, X, Y, T2) over the same input and output
1 6≃x s0
alphabets are distinguished with input sequence x if s0
2.

1, X, Y, T1) and S2 = (S2, s0

Henceforth, FSMs and DFSMs are complete and initially connected.
Given a NFSM M = (M, m0, X, Y, N ), a FSM S = (S, s0, X, Y, T ) is a

submachine of M, denoted by S ∈ M if S ⊆ M , m0 = s0 and T ⊆ N .

We will use a NFSM to represent a set of candidate DFSMs. We let Dom(M)
denote the set of candidate DFSMs included in NFSM M. Later, we will be
interested in executions of M that are executions of a DFSM in Dom(M). Let

4

O. Nguena Timo

e be an execution of a NFSM M in m0. We say that e involves a submachine
S = (S, s0, X, Y, T ) of M if U nctn(e) ⊆ T , i.e., all the uncertain transitions in e
are deﬁned in S. The certain transitions are deﬁned in each DFSM in Dom(M),
but distinct DFSMs in Dom(M) deﬁne distinct sets of uncertain transitions.

3 The Oracle Mining Problem and Overview of the

Proposed Solution

Oracles play an important role in testing and veriﬁcation activities, especially
they deﬁne and evaluate the responses of implementations to given tests. The
evaluation serves to provide verdicts on the presence of faults in the implemen-
tations. Letting experts play the role of an oracle is expensive. The experts
will intervene in recurrent test campaigns for judging an important number of
responses. For these reasons, automated test oracles are preferred.

Devising precise oracles (shortly oracles) is a challenging task that might
require uncertainty resolution, as discussed in Section 1. Full automation of this
task might result in undesired oracles. Inspired by previous work [5, 12], we
represent oracles with DFSMs and a test with an input sequence.

We propose a semi-automated mining approach for devising oracles. First we
suggest modelling uncertainties with non deterministic transitions in a NFSM.
This latter NFSM represents an imprecise oracle and it deﬁnes conﬂicting out-
puts for the same input applied in the same state. It also deﬁnes a possibly big
number of candidate oracles (shortly candidates) which are the DFSM included
in it. Secondly, experts can take useful decisions for the resolution of uncer-
tainties and the automatic extraction of the proper candidate. The decisions
concern the evaluation and the selection of conﬂicting responses. The fewer are
the decisions, the less is the intervention of experts in the mining process and
the recurrent testing activities with the selected oracle.

Let a NFSM M = (M, m0, X, Y, N ) represent an imprecise oracle. We say
that S ∈ Dom(M) is the proper oracle w.r.t. experts if S always produces
the expected responses to every test, according to the point of view of experts;
otherwise S is inappropriate. Equivalent DFSMs represent an identical oracle. In
practice the uncertainty degree of M should be much smaller than its maximal
value |M ||Y |; we believe that it could be smaller than the maximum of |M | and
|Y |. The oracle mining problem is to select the proper oracle in M, with the
help of an expert. We assume that Dom(M) always contains the proper oracle.
The NFSM in Figure 1a represents an imprecise oracle. It deﬁnes eight candi-
date oracles with six uncertain transitions, namely t5, t6, t7, t8, t9, t10. Figure 1c
and Figure 1d present two candidates; one of them is proper.

Mining the proper oracle is challenging even with the help of an expert, es-
pecially when the NFSM for an imprecise oracle deﬁnes an important number of
candidates. The one-by-one enumeration of the candidates might not work be-
cause of the sheer number of candidates induced by an imprecise oracle. A naive
approach could consist to deactivate in each state of the NFSM, the transitions
producing outputs evaluated as unexpected by the expert. This naive approach

Mining Precise Test Oracle Modelled by FSM

5

a/0 [t2]

b/0 [t4]

a/0 [t8] a/1 [t7]

a/0 [t2]

b/0 [t4]

a/0 [t8] a/1 [t7]

b/0 [t1]

a/0 [t3]

2

1

3

1

b/0 [t1]

a/1 [t9]

a/1 [t10]

b/0 [t6]

b/0 [t5]

b/0 [t11]

4

a/0 [t3]

2
a/1 [t10]

3

a/1 [t9]

b/0 [t11]

4

b/0 [t5]

(a) An imprecise oracle M

(b) A reduced imprecise oracle M′

a/0 [t2]

b/0 [t4]

a/0 [t8]

b/0 [t1]

1

a/1 [t9]

b/0 [t11]

2

4

a/0 [t3]

3

b/0 [t5]

a/0 [t2]

b/0 [t4]

a/1 [t7]

b/0 [t1]

a/0 [t3]

2

3

1

b/0 [t6]

(c) The proper oracle S

(d) An inappropriate oracle

Fig. 1: An imprecise oracle and two plausible oracles

does not work. For example, the imprecise oracle in Figure 1 has four executions
with input sequence baba, namely t1t3t5t9, t1t3t5t10, t1t3t6t8 and t1t3t6t7. The
two plausible responses for these executions are 0000 and 0001. The latter is
expected as it is produced by the proper oracle in Figure 1c.

All but one executions produce the desired output 1 in state 3 on the last
input a. One could deactivate or remove the transition t8 based on the fact that it
produces the last undesired output in the unexpected response. In consequence
the reduction of the imprecise oracle will result in an oracle not deﬁning t8.
Any candidate not deﬁning t8 is not equivalent to the proper oracle. This naive
approach of selecting some transitions from transition sequences fails in mining
the proper oracle. This is because entire sequences of transitions used to reach
states (and so their input-output sequences) deﬁne the proper candidate.

Our oracle mining approach relies on the evaluation by experts of responses
(instead of isolated outputs) of the candidates to tests. The principle of the ap-
proach is iterative and quite simple. At each iteration step, ﬁrst we use pair of
candidates to generate tests. Next, we generate the plausible responses for gener-
ated tests. Then we let experts select expected responses. Eventually we remove
from the candidate set, the ones producing unexpected responses; this can be
done by deactivating transitions in imprecise oracle and removing candidates
from the set of solutions of the Boolean formulas. The iteration process con-

6

O. Nguena Timo

tinues if two remaining candidates are distinguishable. A lot of memory can be
needed to store each and every candidate, especially if a great number of them
is available. To reduce the usage of the memory, we encode candidates with
Boolean formulas and we use a solver to retrieve candidates from the Boolean
encodings. The Boolean encoding is also useful for representing the candidates
already used to generate distinguishing tests.

In the next section we propose Boolean encodings for the DFSMs including
in a NFSM and the test-equivalent DFSMs. We also present how to deacti-
vate/remove transitions in a NFSM for modelling reduced candidate sets.

4 Boolean Encodings

Let M = (M, m0, X, Y, T ) be an imprecise oracle. Dom(M) represents a set
of candidate oracles, i.e., a set of DFSMs. We encode candidates with Boolean
formulas over variables representing the transitions in M. A solution of a formula
determines the transitions corresponding to the variables it assigns to ”true”.
An FSM is determined (encoded) by a formula if exactly all its transitions are
determined by a solution of the formula.

4.1 Candidates in an imprecise oracle

Let τ = {t1, t2, . . . , tn} be a set of variables, each variable corresponds to a
transition in T . Let us deﬁne the Boolean expression ξτ as follows:

ξτ = ^

(¬tk ∨ ^

¬tj) ∧ _

tk

k=1..n−1

j=k+1..n

k=1..n

It holds that every solution of ξτ determines exactly one variable in τ . Indeed,
ξτ assigns True if both Vk=1..n−1(¬tk ∨ Vj=k+1..n ¬tj) and Wk=1..n tk are True.
Wk=1..n tk is True whenever at least one ti is True. If some ti is True, then every
tj, i 6= j must be False in order for Vk=1..n−1(¬tk ∨ Vj=k+1..n ¬tj ) to be True.
So every solution of ξτ determines exactly one transition in T ; this transition
corresponds to the only variable in τ that the solution assigns to T rue.

We encode the candidates in Dom(M) with the formula

ϕM = ^

ξT (m,x)

(m,x)∈M×X

For every state m ∈ M and every input x ∈ X, every solution of ϕM determines
exactly one transition in M, which entails that a solution of ϕM cannot deter-
mine two diﬀerent transitions with the same input from the same state. So ϕM
determines exactly the candidates in Dom(ϕM).

For the imprecise oracle M in Figure 1a, T (1, b) = {t1}, T (3, a) = {t7, t8},
ξT (1,b) = t1 and ξT (3,a) = (¬t7 ∨¬t8)∧(t7 ∨t8). Then, the formula ϕM := t1 ∧t2 ∧
t3∧t4∧t11∧((¬t7 ∨¬t8)∧(t7∨t8))∧((¬t5 ∨¬t6)∧(t5∨t6))∧((¬t9 ∨¬t10)∧(t9 ∨t10))
encodes all the DFSMs included in M. In other words, ϕM determines all the
candidates deﬁned by M. The DFSM in Figure 1c is determined by ϕM.

Mining Precise Test Oracle Modelled by FSM

7

4.2 Candidates involved in executions of an imprecise oracle

An execution e = t1t2 . . . tn of M involves a FSM S ∈ Dom(M) if every ti is
deﬁned in S. Recall that all the certain transitions are deﬁned in every candidate.
Let us deﬁne the formula ϕe = Vi=1..n,ti∈Unctn(e) ti. Clearly ξe determines every
uncertain transition in e, so it determines the deterministic and non deterministic
FSMs involved in e. However we are interested in DFSMs in Dom(M) only.
Remark that if DFSM S is involved in e, then e is deterministic. Conversely, e
is deterministic if Dom(M) includes a DFSM involved in e. An execution of M
must be deterministic for a DFSM to be involved in it. So ϕe determines the
DFSMs involved in e if e is deterministic. Let E = {e1, e2, . . . , em} be a set of
deterministic executions of M and let us deﬁne the formula ϕE = Wi=1..n ϕei .
The formula ϕE ∧ ϕM determines the DFSMs involved in an execution in E.

Consider the NFSM in Figure 1a and a set E = {e0 = t1t3t6t8t8t6, e1 =
t1t3t5t9t2, e2 = t1t3t5t10t3t5, e3 = t1t3t6t7t7t6} consisting of four executions
e0, e1, e2 and e3. Remark that the executions are deterministic and they have
the same input sequence babaab but distinct responses, namely 000000 for e0,
000100 for e1 and e2 and 000110 for e3. The formula ϕE = (t1 ∧ t3 ∧ t6 ∧ t8) ∨
(t1 ∧ t3 ∧ t5 ∧ t9 ∧ t2) ∨ (t1 ∧ t3 ∧ t5 ∧ t10) ∨ (t1 ∧ t3 ∧ t6 ∧ t7) ∧ ϕM encodes the
DFSMs involved in the three executions.

4.3 Test-equivalent candidate

Let x be a test. To determine the x-equivalent DFSMs, we can partition Dom(M)
into subdomains. The DFSMs in each subdomain produce the same response to
test x. Our encoding of each subdomain with a Boolean formula works as follows.
Let YM,x = {y1, y2, . . . yn} be the set of responses the DFSMs in Dom(M)
to test x. Each response yi, with i = 1...n, corresponds a maximal set of de-
terministic executions of M with input sequence x. We denote by Ex/yi =
{ei1, ei2 , . . . , eim } the set of deterministic executions producing yi on input se-
quence x. Clearly Ex/yi characterizes a subdomain of x-equivalent DFSMs. The
maximal size of YM,x equals |x||Y | and it is reached when the imprecise oracle is
the universe of all DFSMs, which is not the practical context of our work with
imprecise oracles having reasonable uncertainty degrees.

Let Px/yi denote the set of DFSM in M involved in an execution in Ex/yi . It
holds that Px/y1, Px/y2, . . . Px/yn constitutes a partition of Dom(M), i.e., every
deterministic submachine of M exactly belongs to one Px/yi , i = 1..n and every
DFSM in Px/yi is a submachine of M for every i = 1..n.

For each y ∈ YM,x, we deﬁne the formula ϕEx/y . It holds that ϕM ∧ ϕEx/y
encodes the maximal set of DFSMs indistinguishable by x. Indeed, ϕEx/y deter-
mines exactly the x-equivalent FSMs involved in deterministic executions in Ex/y
and ϕM determines the DFSMs in M. We can show that every DFSM included
in M is determined by the formula ϕM ∧ ϕEx/y for exactly one y ∈ YM,x. Fur-
thermore, if x is not distinguishing for the DFSMs in Dom(M), then ϕM ∧ϕEx/y
and ϕM are equivalent, i.e., they determine the DFSMs in Dom(M).

8

O. Nguena Timo

Table 1: Partitioning of M into Subdomains w.r.t input sequence x = babaab

Response y Subdomain for ϕM

size Precise oracles in the

000100

ϕx/000100 = ((t5 ∧ t9) ∨ (t5 ∧
t10))

000110

ϕx/000110 = t6 ∧ t7

000000

ϕx/000000 = t6 ∧ t8

subdomain Px/yi

4 {t1, t2, t3, t4, t5, t7, t10, t11},
{t1, t2, t3, t4, t5, t7, t9, t11},
{t1, t2, t3, t4, t5, t8, t9, t11},
{t1, t2, t3, t4, t5, t8, t10, t11}
2 {t1, t2, t3, t4, t6, t7, t10, t11},
{t1, t2, t3, t4, t6, t7, t9, t11}
2 {t1, t2, t3, t4, t6, t8, t9, t11},
{t1, t2, t3, t4, t6, t8, t10, t11}

where, ϕM =
t1 ∧ t2 ∧ t3 ∧ t4 ∧ t11 ∧ ((¬t7 ∨ ¬t8) ∧ (t7 ∨ t8)) ∧ ((¬t5 ∨ ¬t6) ∧ (t5 ∨ t6)) ∧ ((¬t9 ∨ ¬t10) ∧ (t9 ∨ t10))

Considering our running example and the test x = babaab, we have that
YM,babaab = {e0 = t1t3t6t8t8t6, e1 = t1t3t5t9t2, e2 = t1t3t5t10t3t5, e3 = t1t3t6t7t7t6}.
Since the four executions have distinct responses (i.e., output sequences), we get
Ebabaab/000000 = {e0}, Ebabaab/000100 = {e1, e2} and Ebabaab/000110 = {e3}. Ta-
ble 1 presents the corresponding subdomains and the number of oracles in each
subdomain. The two oracles in the subdomain for response 000000 are equiva-
lent. The same for response 000110. The subdomain for response 000100 deﬁnes
four babaab-equivalent candidate oracles. Later, experts are invited to select the
expected response that will serve to reduce the imprecise oracle.

4.4 Reducing an imprecise oracle

The selection of test-equivalent candidates renders useless transitions of the im-
precise oracle unused in the selected candidates. These transitions can be deac-
tivated for obtaining a reduced imprecise oracle.

Let M = (M, m0, X, Y, N ) be an input complete NFSM and x/y be a trace.
Dom(M) is partitioned into the set Dom(M)x/y of DFSMs producing y on x
and the set of DFSMs not producing y on x. We say that a transition t ∈ N is
eligible for a candidate involved in e if e uses t or t′ 6∈ N (src(t), inp(t)) for every
t′ used in e.

Lemma 1. There is a submachine Mx/y of M such that Dom(Mx/y) = Dom(M)x/y.

Proof. Let e be a deterministic execution e in Ex/y. Remark that all the tran-
sitions in e are eligible for the candidates involved in e. Moreover e is the only
execution with input sequence x and response y in each of these candidates.

We build Mx/y = (S, s0, X, Y, T ) with T ⊆ N by deactivating (deleting) non
eligible transitions for candidates in Dom(Mx/y). Formally t ∈ N belongs to T
if it is eligible for a candidate involved in some deterministic execution e ∈ Ex/y.
m ∈ M belongs to S if m is used in a transition in T . Clearly, Mx/y is a complete
and initially connected submachine of M; Mx/y is not necessarily deterministic

Mining Precise Test Oracle Modelled by FSM

9

because several executions in Ex/y can use several uncertain transitions deﬁned
in the same state and with the same input; these transitions belong to T .

First we show that Dom(Mx/y) ⊆ Dom(M)x/y by contradiction. Assume
that there is P in Dom(Mx/y) but not in Dom(M)x/y. P is deterministic and by
construction it deﬁnes all the transitions in a deterministic execution e ∈ Ex/y
of M. This implies the response of P on x is y, which is a contradiction with hy-
pothesis P 6∈ Dom(M)x/y. Secondly, we show that Dom(M)x/y ⊆ Dom(Mx/y).
Let P ∈ Dom(M)x/y. P produces y on x with exactly one of its execution e.
The transitions eligible for P are deﬁned in Mx/y. So P ∈ Dom(Mx/y).
⊓⊔

Consider Table 1 and assume experts choose the expected response 000100.
The reduced imprecise oracle for babaab/000100, Mbabaab/000100 is the imprecise
oracle in Figure 1b which was obtained by removing transition t6 from M in
Figure 1a. This is because among the two transitions t5 and t6 from state 3 with
input b, the executions in Ebabaab/000100 only use t5.

Reducing an imprecise oracle permits to speed up the computation of execu-
tions with given tests. Indeed, once it becomes clear that passing some transitions
in the imprecise oracle leads to the production of undesired responses, one does
not need to consider these transitions in determining new execution sets.
Let S be a candidate in Dom(M) and x/y be a test-response pair.

Lemma 2. S ∈ Dom(Mx/y) if and only if S is determined by ϕM ∧ ϕEx/y .

Remark that in some circumstances Mx/y is the same as M. This happens
when the union of eligible transitions over a set of executions equals the set
of transitions of M. Such a case will be presented in Section 5.2. Uncertain
transitions in M but not in Mx/y are not determined by ϕM ∧ ϕEx/y because
other uncertain transitions are determined by ϕEx/y and a solution of ϕM cannot
determine two uncertain transitions from the same state with the same input.

5 Mining an Oracle

To mine an oracle represented with a DFSM, we apply a test set T S on an
imprecise oracle M. We say that T S is adequate for mining the proper oracle
from M if T S is distinguishing for some S ∈ M and every other candidate in M
that is not equivalent to S; moreover S is proper. Verifying the mining adequacy
of T S is the ﬁrst step in mining the proper oracle. In case T S is not adequate,
new tests can be generated.

5.1 Verifying adequacy of a test set for mining the proper oracle

Our method of verifying the adequacy of a test is iterative. At each iteration
step, a test is randomly chosen and the corresponding plausible responses are
computed with the imprecise oracle. Then experts select an expected response
and send it to an automated procedure. The automated procedure reduces the
imprecise oracle, i.e., deactivates some transitions from the imprecise oracle. The

10

O. Nguena Timo

Algorithm 1: Verifying Test Adequacy For Mining an Oracle.

Input-Output: M an imprecise oracle
Input: ϕM the boolean encoding of DFSM included in NFSM M
Input: a test set T S
Input: a DFSM S emulating the expert for the response selection
Output: verdict, is true or f alse on whether T S enables mining a DFSM.
Output: ϕ the Boolean encoding of DFSM consistent with expert knowledge
Output: xd a test that distinguish two DFSM

1 Procedure verify test adequacy for mining (M, ϕM, T S, S):
2

Set ϕ = ϕM
Set verdict = true if ϕ does not select at least two non equivalent DFSMs;

otherwise set verdict = f alse

while T S 6= ∅ and verdict == f alse do

Let x be a test in T S.
Remove x from T S.
Determine YM,x the set of outputs of deterministic executions in Ex of

M with input x

Show YM,x to experts and let y ∈ YM,x be the output such that
y = outS(s0, x), (→ choice of the expected response by experts)
Determine Ex/y ⊆ Ex the deterministic executions of M which

produce y on test x

Determine Mx/y
Set ϕ = ϕ ∧ ϕEx/y the Boolean encoding of DFSMs in M which
produce y on test x

Set M = Mx/y
if ϕ encodes at two non equivalent DFSMs then

Set xd to a minimal distinguishing test for two non equivalent

DFSMs

else

Set verdict = true

return (verdict, M, ϕ, xd)

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

procedure stops when the responses for every test are examined or no imprecision
remains. The procedure verify test adequacy for mining scripted in Algorithm 1
returns a verdict of the veriﬁcation.

Procedure verify test adequacy for mining takes as inputs an imprecise oracle
represented by a NFSM, a test set and the expert knowledge about the expected
outputs for the tests. We represent the expert knowledge with a DFSM. It uses
Boolean encoding presented in the previous section. The procedure ends the
iteration if all the tests were visited or the Boolean encoding deﬁnes a single
DFSM. If the Boolean encoding of the test-equivalent DFSMs deﬁnes two non
equivalent DFSMs then the tests do not enable mining an oracle; otherwise one
of the remaining equivalent DFSMs is mined. The procedure also returns the
Boolean encoding of the selected DFSMs for the tests, i.e, the DFSMs which
produce the expected output on every test.

Mining Precise Test Oracle Modelled by FSM

11

Algorithm 2: Mining an Oracle by Test Generation.

Input: ϕM the boolean encoding of DFSM included in a NFSM M
Input: a test set T S
Input: a DFSM S emulating the expert for the response selection
Output: T S m a test set that enables mining a DFSM.
Output: P the proper oracle

1 Procedure precise oracle mining (M, T S, S):
2

Set ϕ = ϕM
Set T S m = T S
(verdict, M′, ϕ′, xd) = verify test adequacy for mining(M, ϕ, T S, S)
while verdict == f alse do
Set T S m = T S m ∪ {xd}
ϕ = ϕ′
M = M′
Set T S = {xd}
(verdict, M′, ϕ′, xd) = verify test adequacy for mining(M, ϕ, T S, S)

Let P be the DFSM obtained from a solution of ϕ′
return (T S m, P)

3

4

5

6

7

8

9

10

11

12

Consider the original imprecise oracle M in Figure 1a. For verifying whether
the test babaab is adequate for mining an oracle, verify test adequacy for mining
determines the plausible responses (see Table 1) for the deterministic execution
M on babaab. Assume that experts choose expected response 000100. The pro-
cedure determines Ebabaab/000100 as we discussed in Section 4.3; then it builds
ϕbabaab/000100 in Table 1 and the reduced imprecise oracle in Figure 1b as dis-
cussed in Section 4.4. The formula ϕ := ϕM ∧ ϕbabaab/000100 determines four
babaab-equivalent candidates presented in Table 1. Two of these candidates are
distinguished with test babaaa, namely the oracle in Figure 1c and the one
deﬁning the transition set {t1, t2, t3, t4, t5, t7, t10, t11}. This latter oracle provides
response 000101 whereas the former provides 000100 for test babaaa. In conclu-
sion the procedure returns verdict = f alse indicating that test babaab is not
adequate for mining the proper oracle in Figure 1c; it also returns the reduced
imprecise oracle and the encoding with ϕ of babaab-equivalent candidates.

5.2 Test generation in mining an oracle

Procedure precise oracle mining in Algorithm 2 mines an oracle from an im-
precise one by generating tests. The procedure makes a call to semi-automated
procedure verify test adequacy for mining in Algorithm 1. If given tests are not
adequate for the mining task, procedure verify test adequacy for mining returns
a Boolean encoding of a reduced set of test-equivalent candidates. Then, pro-
cedure precise oracle mining generates a distinguishing test for two candidates
in the reduced set. Such a test can correspond to a path to a sink state in
the distinguishing product [15] of two candidates. The test generation stops if
the generated test is adequate for mining the proper oracle in the reduced set of

12

O. Nguena Timo

candidates; otherwise another test is generated. Procedure precise oracle mining
always terminates because at each iteration step, the set of candidates is re-
duced after a call to procedure verify test adequacy for mining and the number
of DFSMs included in the original imprecise oracle is ﬁnite. On termination of
verify test adequacy for mining, the initial tests augmented with the generated
ones constitute adequate tests for mining the proper oracle determined by ϕ′.

Considering the running example, the ﬁrst call to verify test adequacy for mining

in the execution of Procedure precise oracle mining permits establishing that
the test babaab is not adequate for mining an oracle. This was discussed at the
end of the previous section where the test xd = babaaa was generated as a dis-
tinguishing test for two candidates determined by ϕ′ := ϕM ∧ ϕbabaab/000100
and included in the reduced imprecise oracle M′ in Figure 1b. In the ﬁrst it-
eration step of the while loop, Procedure precise oracle mining makes a sec-
ond call to verify test adequacy for mining for checking whether the generated
test babaaa is adequate for mining an oracle from the new context M = M′
and ϕ = ϕ′. Here is what happens within this second call. The plausible re-
sponses for babaaa belong to YM′,babaaa = {000100, 000101}; they are obtained
with deterministic executions of M′
in Ebabaaa = {e0 = t1t3t5t9t2t2, e1 =
t1t3t5t10t3t8, e2 = t1t3t5t10t3t7}. Computing executions having input sequence
babaaa and the plausible responses is more eﬃcient with M′ than with M; this is
because M′ does not deﬁne t6. Assume that 000100 is the expected response for
babaaa. Then Ebabaaa/000100 = {e0 = e1 = t1t3t5t9t2t2, e2 = t1t3t5t10t3t8} and
ϕbabaaa/000100 = t9 ∨ (t10 ∧ t8). Using M′ in Figure 1b, there are two candidates
involved in e0 and the eligible transitions for the two candidates include all the
transitions in M′ but t10. Remark that uncertain transitions t8, t7 are eligible
even if they are not used in e0. There is one candidate involved in e1 and the
eligible uncertain transitions for this candidate are t8, t10. So, the set of eligible
transitions for the candidates involved in executions in Ebabaaa/000100 are all the
transitions in M′. In this particular case, M′ is not reduced with test-response
pair babaaa/000100. However the {babaab, babaaa}-equivalent candidates are en-
coded with ϕ′ ∧ ϕEbabaaa/000100 = ϕM ∧ ϕEbabaab/000100 ∧ ϕEbabaaa/000100 . This latter
formula determines two candidates distinguishable with babaaba in the reduced
imprecise oracle obtained from M′ by deactivating transition t10. Eventually
precise oracle mining generates the test baa, terminates and returns adequate
test set {babaab, babaaa, babaaba, baa} for mining the oracle in Figure 1c.

6 Experimental Results

We evaluate whether the proposed approach is applicable for mining oracles from
imprecise oracles that deﬁne a big number of candidate oracles and whether it
requires a reasonable number of interventions of experts. For that purpose we
implemented a prototype tool, perform multiple atomic experiments, monitor
metrics and we compute some statistics. The prototype tool is implemented in
Java; it uses Java libraries of the solver Z3 version 4.8.4 and the compilation tool

Mining Precise Test Oracle Modelled by FSM

13

ANTLR version 4.7.2. The computer has the following settings: WINDOWS 10,
16 Go (RAM), Intel(R) Core i7-3770 @ 3.4 GHz.

An atomic experiment works as follows. We automatically generate a com-
plete DFSM S for given numbers of states, inputs and outputs denoted by
|M |, |X| and |Y | respectively. S emulates the experts during the experiments.
We set the uncertainty degree U . For a value of U we randomly add transi-
tions to S for generating an imprecise oracle M. Eventually, we extract a DFSM
equivalent to S from M by making a call to our implementation of procedure
precise oracle mining in Algorithm 2.

The metrics we monitor in each atomic experiments are: |Dom(M)| the max-
imum number of candidate oracles in M; |T S|min and |T S|max the minimum
and the maximum numbers of generated tests; Lmin and Lmax the minimum
and the maximum lengths of the generated tests; and Tmin, Tmax and Tmed the
minimal, maximal and median processing times (in milliseconds) for the mining
procedure. We assumed that it takes almost zero millisecond for emulated ex-
perts to select responses, which is insigniﬁcant in comparison to the processing
time for the plausible responses and solutions of Boolean formulas. We performed
30 atomic experiments to obtain the data in each row of Table 2 and Table 3.

In Table 2, we consider imprecise oracles with 10 states, 3 inputs and 2
outputs. We observe that the values of almost all the metrics augment when
the uncertainty degree U increases, especially Tmed. The generated imprecise
oracles in Table 3 have 3 inputs, 2 outputs and uncertainty degree equals to 3.
We also observe that almost all the metrics increase when the number of states
increases, especially Tmed. We notice that for (|M |, |X|, |Y |, U ) = (10, 3, 2, 3),
the gap between the values for Tmed in Table 2 and Table 3 is minor, which let
us believe that Tmed is signiﬁcant to evaluate the performance of our approach.
Let us provide a practical perspective on the results in Table 2 and Table 3.
Clearly, experts would have took more time than its emulation with a DFSM to
select expected responses. Let us assume that it takes on average 1 minute to
experts for selecting the expected response for a test. Under this assumption and
considering the last row of Table 2, the extraction of an oracle over the possible
2.21E23 candidates could last 106 minutes since the automated procedure only
lasts for 18.26 seconds. We advocate that if the extracted oracle serve in testing
a critical system, taking 106 minutes to extract the proper oracle is better than
using an undesired oracle. If the manual repair of the undesired oracle is not
trivial, mutation operations (taking inspiration from [10,19]) can apply to it for
generating an imprecise oracle and mining a proper oracle.

The proposed approach could also be lifted for the generation in a distributed
way of adequate test sets for mining each and every candidate. This can be done
by partitioning the candidate set into subsets, one subset per plausible response.
The constraints for each subset can be processed in parallel in other to generate
new tests. The generated test sets will be computed without any intervention of
experts. After the test set generation and the iterative partitioning of candidate
subsets, the experts could passively select expected responses for the generated
tests in a passive manner for mining the proper oracle.

14

O. Nguena Timo

Table 2: (|M |, |X|, |Y |) = (10, 3, 2)
U |Dom(M)| |T S|min |T S|max Lmin Lmax Tmin(ms) Tmax(ms) Tmed(ms)
2
3
4
5
6

1.07E9
2.06E14
1.15E18
9.31E20
2.21E23

1106.0
2865.0
4417.0
9618.0
18263.0

1619
115867
8626
35190
105994

871
2128
3313
6334
9903

32
55
78
100
106

21
33
40
55
64

5
5
5
5
5

8
8
7
7
7

Table 3: (|X|, |Y |, U ) = (3, 2, 3)
|M | |Dom(M)| |T S|min |T S|max Lmin Lmax Tmin(ms) Tmax(ms) Tmed(ms)

7
8
9
10
11
12
13

1.05E10
2.82E11
7.63E12
2.06E14
5.56E15
1.50E17
4.053E18

22
24
30
33
37
41
43

43
53
55
53
66
71
79

4
4
5
5
5
5
5

7
8
7
7
7
8
8

1008
1136
1575
1905
2109
2533
2837

2457
3199
4767
4237
4567
5588
7680

1220.0
2071.0
2056.0
2438.0
3053.0
5140.0
6381.0

7 Related Work

Metamorphic testing [4, 16, 17] applies in devising test oracle when it is diﬃcult
to compare an expected response of a system under test with an observed one.
It consists in mutating original test input data to build a test set that violates
metamorphic relations. These relations can play the role of coarse speciﬁcations
and can serve to derive test sets. Building the relations requires the expert knowl-
edge and extra-skills. Our approach exonerates testers to building such relations.
Candidate oracles allow focusing on revealing deviations in the responses.

In [10,19] a test-response set is used to repair a system when its formal spec-
iﬁcation is unavailable. The approach consists in analyzing mutated versions of
an implementation (C program) until one is found that retains required func-
tionality and avoids a defect located by the tests. Mutated versions are generated
using genetic programming. In our work, the speciﬁcation and the test-response
pairs are unavailable. We generate tests and we rely on experts and the imprecise
oracle to obtain the expected responses and to extract the oracle (speciﬁcation).
In [9], a test set is generated to detect whether a DFSM implementation is
a reduction (i.e., is trace included) of a NFSM speciﬁcation playing the role of
an oracle; if so the implementation conforms to the speciﬁcation. This work pre-
sumes that any of the traces of the speciﬁcation is expected. This diﬀers from
our settings where responses from non deterministic executions in the impre-
cise oracle NFSM cannot be produced by the proper candidate DFSM; so any
implementation exhibiting these responses must fail the tests.

The work in [1] addresses the problem of learning a DFSM by using out-
put and equivalence queries to a teacher. The proposed polynomial time active
learning algorithm often requires a certain number of queries so that it wont be

Mining Precise Test Oracle Modelled by FSM

15

eﬀective for experts to play the role of the teacher. In practice, the teacher is a
black-boxed implementation one wants to infer a DFSM model. In our work, we
want to mine a DFSM from a given NFSM by using the expert knowledge. Such
a situation happens, e.g., when one needs to choose among multiple implemen-
tation models of the same system. In our settings, there is no equivalence query
and expert responds few queries on the selection of expected responses.

The work in [13, 15] represents the fault domain for a DFSM speciﬁcation
with a NFSM. Each DFSM in the domain represents a version of the speciﬁcation
seeded with faults. The work addresses the problem of generating a test set [15]
or a single test [13] for distinguishing a the speciﬁcation from the other DFSMs.
In this paper we address a diﬀerent concern, which is selecting a yet unknown
oracle (speciﬁcation) from a set of candidate oracles.

In [14], experts play the role of an ultimate oracle to select one precise or-
acle from an imprecise oracle. The experts are requested to evaluate pairs of
responses produced from too many pairs of candidate oracles. In the current
work, candidate oracles having produced unexpected responses are neither anal-
ysed, nor compared to the others. The mining approach developed in this paper
is clearly more eﬃcient than the one in [14].

8 Concluding remarks

We have presented an approach to mining a precise oracle from an imprecise
one deﬁning a set of candidate oracles. Precise oracles are represented with DF-
SMs whereas NFSMs represent imprecise oracles. We compactly encoded candi-
date precise oracles with Boolean formulas. We presented a method of reducing
the imprecise oracle for eﬃcient computation of plausible response sets. The
proposed approach takes advantage of the eﬃciency of existing solvers and the
reduction of the imprecise oracle for eﬃcient search of distinguishable precise or-
acles, test generation. It requests experts to select one correct response per test.
The experimental results have demonstrated that few tests and few response sets
are needed for mining the proper precise oracle from many candidate precise or-
acles. This indicates that the number of experts’ interventions is reasonable and
the approach is applicable.

We plan to lift the proposed approach for mining extended ﬁnite state ma-
chines which are also used to represent test oracles. We also plan investigating
automatic construction of imprecise oracles from system requirements, e.g., by
modifying machine learning-based translation procedures or investigating muta-
tion operators to be applied on generated ”incorrect” oracles.

Acknowledgement

This work was partially supported by MEI (Minist`ere de l’´Economie et Innova-
tion) of Gouvernement du Qu´ebec. The author would like to thank Dr. Alexandre
Petrenko and anonymous reviewers for their valuable comments.

16

O. Nguena Timo

References

1. Angluin, D.: Learning regular sets from queries and counterexamples. Inf. Comput.

75(2), 87–106 (1987)

2. Barr, E.T., Harman, M., McMinn, P., Shahbaz, M., Yoo, S.: The oracle problem
in software testing: A survey. IEEE Transactions on Software Engineering 41(5),
507–525 (May 2015)

3. Brunello, A., Montanari, A., Reynolds, M.: Synthesis of ltl formulas from natural
language texts: State of the art and research directions. In: 26th International
Symposium on Temporal Representation and Reasoning (TIME 2019). Schloss
Dagstuhl-Leibniz-Zentrum fuer Informatik (2019)

4. Chen, T.Y., Cheung, S.C., Yiu, S.M.: Metamorphic testing: A new approach for
generating next test cases. Tech. Rep. HKUST-CS98-01, Department of Computer
Science, The Hong Kong University of Science and Technology (1998)

5. Chow, T.S.: Testing software design modeled by ﬁnite-state machines. IEEE Trans.

Software Eng. 4(3), 178–187 (1978)

6. Fantechi, A., Gnesi, S., Lami, G., Maccari, A.: Applications of linguistic techniques

for use case analysis. Requirements Engineering 8(3), 161–170 (2003)

7. Fantechi, A., Gnesi, S., Ristori, G., Carenini, M., Vanocchi, M., Moreschini, P.: As-
sisting requirement formalization by means of natural language translation. Formal
Methods in System Design 4(3), 243–263 (1994)

8. Fraser, G., Staats, M., McMinn, P., Arcuri, A., Padberg, F.: Does automated white-
box test generation really help software testers? In: Proceedings of the 2013 Inter-
national Symposium on Software Testing and Analysis. pp. 291–301. ISSTA 2013,
ACM, New York, NY, USA (2013)

9. Hierons, R.M.: Testing from a nondeterministic ﬁnite state machine using adaptive
state counting. IEEE Transactions on Computers 53(10), 1330–1342 (Oct 2004)

10. Le Goues, C., Dewey-Vogt, M., Forrest, S., Weimer, W.: A systematic study of
automated program repair: Fixing 55 out of 105 bugs for $8 each. In: Proceedings
of the 34th International Conference on Software Engineering. pp. 3–13. ICSE ’12,
IEEE Press, Piscataway, NJ, USA (2012)

11. Lee, D., Yannakakis, M.: Principles and methods of testing ﬁnite state machines-a

survey. Proceedings of the IEEE 84(8), 1090–1123 (Aug 1996)

12. Mavridou, A., Laszka, A.: Designing secure ethereum smart contracts: A ﬁnite state
machine based approach. In: Meiklejohn, S., Sako, K. (eds.) Financial Cryptogra-
phy and Data Security - 22nd International Conference, FC 2018, Nieuwpoort,
Cura¸cao, February 26 - March 2, 2018, Revised Selected Papers. Lecture Notes in
Computer Science, vol. 10957, pp. 523–540. Springer (2018)

13. Nguena Timo, O., Petrenko, A., Ramesh, S.: Checking sequence generation for
symbolic input/output fsms by constraint solving. In: Proceedings of 15th In-
ternational Colloquium on Theoretical Aspects of Computing. Lecture Notes in
Computer Science, vol. 11187, pp. 354–375. Springer (2018)

14. Nguena Timo, O., Petrenko, A., Ramesh, S.: Using imprecise test oracles modelled
by FSM. In: 2019 IEEE International Conference on Software Testing, Veriﬁcation
and Validation Workshops, ICST Workshops 2019, Xi’an, China, April 22-23, 2019.
pp. 32–39. IEEE (2019)

15. Petrenko, A., Nguena Timo, O., Ramesh, S.: Multiple mutation testing from FSM.
In: Albert, E., Lanese, I. (eds.) Proceedings of 36th IFIP WG 6.1 International
Conference on Formal Techniques for Distributed Objects, Components, and Sys-
tems. Lecture Notes in Computer Science, vol. 9688, pp. 222–238. Springer (2016)

Mining Precise Test Oracle Modelled by FSM

17

16. Saha, P., Kanewala, U.: Improving the eﬀectiveness of automatically generated test
suites using metamorphic testing. In: ICSE ’20: 42nd International Conference on
Software Engineering, Workshops, Seoul, Republic of Korea, 27 June - 19 July,
2020. pp. 418–419. ACM (2020)

17. Segura, S., Fraser, G., Sanchez, A.B., Ruiz-Cort´es, A.: A survey on metamorphic

testing. IEEE Transactions on Software Engineering 42(9), 805–824 (Sept 2016)

18. Stahlberg, F.: Neural machine translation: A review. Journal of Artiﬁcial Intelli-

gence Research 69, 343–418 (2020)

19. Weimer, W., Nguyen, T., Le Goues, C., Forrest, S.: Automatically ﬁnding patches
using genetic programming. In: Proceedings of the 31st International Conference
on Software Engineering. pp. 364–374. ICSE ’09, IEEE Computer Society, Wash-
ington, DC, USA (2009)

20. Weyuker, E.J.: On Testing Non-Testable Programs. The Computer Journal 25(4),

465–470 (Nov 1982)

