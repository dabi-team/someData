2
2
0
2

y
a
M
0
1

]
E
S
.
s
c
[

1
v
8
9
9
4
0
.
5
0
2
2
:
v
i
X
r
a

Metamorphic Testing and Debugging
of Tax Preparation Software

Saeid Tizpaz-Niari
University of Texas at El Paso
USA
saeid@utep.edu

Morgan Wagner
University of Texas at El Paso
USA
mrwagner@miners.utep.edu

Shiva Darian
University of Colorado Boulder
USA
shiva.darian@colorado.edu

Krystia Reed
University of Texas at El Paso
USA
kmreed2@utep.edu

Ashutosh Trivedi
University of Colorado Boulder
USA
ashutosh.trivedi@colorado.edu

ABSTRACT
This paper presents a data-driven debugging framework to improve
the trustworthiness of US tax preparation software. As the US tax
law evolves to adapt to ever-changing politico-economic realities,
tax preparation software plays a significant role in helping taxpayers
navigate these complexities. Given the legal implications of bugs
in such software on its users, ensuring the compliance and trust-
worthiness of tax preparation software is of paramount importance.
The key obstacles in developing debugging aids for tax preparation
systems, however, are the unavailability of explicit specifications
and the difficulty of obtaining oracles.

We posit that, since the US tax law adheres to the legal doctrine
of precedent, the specifications about the outcome of tax preparation
software for an individual taxpayer must be viewed in comparison
with individuals that are deemed similar. Consequently, these specifi-
cations are naturally available as properties on the software requiring
similar inputs provide similar outputs. Inspired by metamorphic test-
ing framework from software engineering, we dub these relations
metamorphic relations.

We explicated metamorphic relations for a set of properties by
carefully studying the US Form 1040 as implemented in an open-
source tax preparation software. We developed a randomized search
strategy to explore the space of metamorphic relations and explain
the behaviors of software with a classification tree algorithm. Our
tool revealed 4 types of failures in the software and provided intuitive
explanations to understand the failures.

KEYWORDS
Metamorphic Testing, Statistical Fault Localization, US 1040, Tax
Preparation Software

INTRODUCTION

1
The ever-increasing complexity of income tax laws in the United
States has rendered manual preparation of tax returns cumbersome
and error-prone. According to the IRS, 90 percent of tax filers filed
taxes electronically in 2020 [29]. Consequently, US tax preparation
has grown into a $11.2bn industry requiring the services of profes-
sional tax accountants or commercial tax preparation software. The
use of software is increasing, and in 2020, over 72 million peo-
ple prepared their taxes without the help of tax professionals, a 24
percent increase from 2019 [30].

Even though there are some freely available open-source alter-
natives [11, 12, 23], such tax preparation software and services are
provided on “AS-IS” bases and may not go through rigorous software
development process. The impact of bugs in software are aggravated
by the fact that, in the US tax courts, individuals are accountable for
any errors resulting from software bugs in such packages:

Langley v. Comm’r, T.C. Memo. 2013-22. The mis-
use of tax preparation software, even if unintentional
or accidental, is no defense to accuracy-related penal-
ties under section 6662.

However, users might not be aware of errors in the software. And few
checks currently exist to ensure the correctness of tax software [27].
To protect consumers in the this process, we develop validation and
debugging aids for open-source tax preparation software. Particularly
because this problem has the potential to compound financial stresses
of the lower income earners, who are more likely to use freely
available and unregulated software [27].

This paper presents a data-driven debugging framework to dis-
cover and explain bugs in tax preparation software systems. There
are three concrete obstacles to this framework.

– Absence of Oracle. The class of correctness requirements for
tax preparation systems are not explicitly available since the
correct tax-filing is highly subjective to individual taxpayers
(this is known as oracle problem [5]).

– Lack of trustworthy dataset. While, in the absence of such
explicit specification, one can recourse to data-driven ap-
proaches, it is difficult to obtain access to a valid dataset due
to obvious privacy and legal concerns.

– Computational infeasibility. Even when one can justify fab-
ricating such a dataset, the final challenge is computational
in nature: detecting and explaining the bug by comparing an
individual decision to others over a large dataset based on a
given similarity measure is computationally intractable.

Metamorphic testing [7] is a software testing paradigm that tack-
les the oracle problem by considering software properties where the
correctness of the software on an input does not require knowing the
“ground truth” for that input; rather, the correctness can be validated
by comparing the output of software for that input with the output
of a slightly metamorphosed one. For instance, consider a software
implementing a search engine: while there is no way to verify that

 
 
 
 
 
 
the results returned for a particular keyword are correct (oracle prob-
lem), it is reasonable to expect that a correct search engine should
return fewer results for a more restricted keyword.

This paper makes a case for the suitability of metamorphic spec-
ifications in testing and debugging tax preparation software (and
by extension for legal software systems). We address aforemen-
tioned challenges by integrating metamorphic specifications with
data-driven debugging as following:

– Metamorphic Specifications. The first obstacle in developing
the debugging framework is to explicate an appropriate no-
tion of correctness requirements. Note that, given the relevant
information about an individual, resolving the correct deci-
sion for that individual requires accounting and law expertise.
Hence, obtaining the oracle for testing and debugging pur-
poses is impractically expensive. Fortuitously, since the US
tax law is principally derived from the common law system, it
implements stare decisis, i.e. the legal doctrine of precedent:
similar cases must follow similar rulings. As a corollary, the
correctness of tax preparation software must also be viewed
in comparison with similar cases. In other words, the correct-
ness properties must be expressed as relations between two
individual taxpayers with similar situations. Following the
metamorphic testing [7], we call such properties metamorphic
specifications.
In collaboration with the tax experts, we reviewed some crit-
ical correctness properties of tax preparation outcomes and
observed that they are naturally expressible as metamorphic
specifications. One key contribution of this paper is to expli-
cate formal representations of these properties from the latest
Internal Revenue System (IRS) documents.

– Testcase Generation. While it is an arduous task to compare
an individual situation with the precedents, the availability
of software artifacts implementing the tax laws permit us to
query the tax outcomes for fictitious individuals similar to a
given individual. This combined with the metamorphic nature
of the requirements allows us validate the software system by
comparing the results for a given (source) individual with its
perturbed follow-ups. We developed a random search strategy
to sample source and follow-up test cases from the space of
metamorphic relations and label them as passed or failed. This
strategy provides statistical guarantees (hypothesis testing)
on the correctness.

– Lexicographic Classification Trees. Given a set of test cases
with ‘pass’ or ‘fail’ labels over a metamorphic relation, de-
cision tree classifiers, as a white-box ML model, are natural
choice to discriminate between the classes and synthesize
circumstances under which the software fails [28]. However,
the nature of metamorphic test cases makes it difficult to
adapt straightforward classification tree algorithms due to
dependencies between source and follow-up features. This
dependency, however, is lexicographical in order, and thus,
we modify standard algorithms to enforce the order during
the search, which results in more intuitive explanations.

The proposed framework is implemented as the tool TENFORTY
(named after the US individual tax return form 1040). We performed

2

experiments on OpenTaxSolver [23] (tax year of 2020), a popu-
lar open-source tax preparation software [8, 9], in five aspects of
disability/credits/deductions that are known to be challenging and
error-prone [14]. In particular, we explicated 16 metamorphic re-
lations in those areas and use them to generate test cases as well
as oracles. Our technique generates tens of thousands of random
test cases using metamorphic properties. We explain the failures
using the lexicographical decision trees implemented by modifying
standard CART tree [6] in scikit-learn library [21]. As a result, our
tool revealed four types of failures in OpenTaxSolver: missing some
eligibility conditions (e.g., married people filing separately are not
eligible to take earned income credits), credits are not applied in
extreme conditions when tax returns get close to zero, and itemized
deductions are not applied for some values of income and credits.

2 BACKGROUND
The US tax code is based on over 2,600 pages of legal statutes
from congress. These statutes are accompanied by IRS regulations,
rulings, and clarifications, together amounting to nearly 9,000 pages.
The structure of the US tax code has been extensively studied by
Lawsky [17, 22]. They pointing out the tax code is not adhered to as
intended and the growing needs for formal legal reasoning. While
they mentioned the difficulty to encode the tax code in first-order
logic (FOL), we show the feasibility with metamorphic relations.

Previously, a written statement of Nina E. Olson (National Tax-
payer Advocate) published by IRS [13] analyzed several (free) tax
filing software for the tax year of 2005. They designed four fictitious
scenarios, including some in which the taxpayer qualified for special
tax benefits enacted to help Hurricane Katrina victims (See [13, p.11-
p.19]). They found that several of the software did not prompt the
taxpayers about these provisions. Therefore, taxpayers ended up not
getting the benefits designed for them. Despite being hypothetical,
the approach showed the flaws in the programs and urged IRS to pay
more attentions to software quality, in addition to software security.
Our approach is geared towards automating these kind of discoveries
in tax preparation software using metamorphic relations.

Within tax domain, Merigoux et al. [20] developed a compiler
for the French tax code. They pointed out multiple limitations of 𝑀
programming language, developed by French Public Finances Di-
rectorate to write tax rules (available at [10]). Then, they developed
a domain-specific language that allows for specifying complicated
rules and lifting them to modern languages like Python. They also
used a dynamic random search to validate the software, as opposed
to formal verification, due to the large space of inputs, floating-
point computations, and various optimizations. In comparisons, the
US has much less automation in tax preparation with no available
specifications and regulated test cases.

In the absence of logical specifications in tax doamin, we turn
to metamorphic testing. Metamorphic testing [7] is primarily devel-
oped to overcome oracle problem [5] that decides given an input
whether the output of the system is correct or not. The idea is to
establish correctness by reasoning about relations between multi-
ple input-output behaviors [26]. For example, consider a program
that implements sin(x) function. While we do not know the exact
outcome of function for an arbitrary 𝑥, we can establish that for
any 𝑥1 and its metamorphosed 𝑥2 = 2 ∗ 𝜋 + 𝑥1, sin(𝑥1) = sin(𝑥2).

Figure 1: General Framework using EITC. Our approach specifies metamorphic properties from relevant tax policies. Then, it
generates random test cases and infers decision trees to localize circumstances under which the software fails to satisfy properties.

In this example, 𝑥1 is a source (base) test, and 𝑥2 is a follow-up
constructed by transforming the source to satisfy the metamorphic
relation between 𝑥1 and 𝑥2 and check the equality between outcomes.
Metamorphic properties have been used to validate machine learn-
ing classifiers [31], autonomous vehicle [32], Google/Yahoo search
engine [33], and social media apps like Facebook [4], but not used
for tax preparation software.

Tax preparation software are paradigmatic examples of legal-
critical software systems. As an example of legal-critical software
consider the work by Matthews el al. [18, 19] on forensic DNA
software to understand the role of the black-box forensic software in
moral decision making in criminal justice. They conduct independent
testing of Forensic Statistical Tool (FST), a forensic DNA system
developed in 2010 by New York City’s Office of Chief Medical
Examiner (OCME). Using a collection of over 400 mixed DNA
samples, they found that an undisclosed data-dropping method in
software impacts about 25% of the samples and leads to shifted
results toward false inclusion of individuals who were not present
in an evidence sample. We believe that the techniques developed in
this paper to reason with tax preparation software makes a case for
the suitability of metamorphic specifications in expressing, testing,
and debugging general legal-critical software systems.

3 OVERVIEW
As a demonstration of our framework (shown in Figure 1), this
section describes how we tested OpenTaxSolver [23] (version for tax
year 2020) in one of 5 domains considered in this paper: the Earned
Income Tax Credit (𝐸𝐼𝑇𝐶). The earned income tax credit is designed
to lower the tax burden for low and moderate income workers.

Extract Scenarios. The first step involves carefully examining the
rules and regulations. For the 𝐸𝐼𝐶, we extract scenarios from Work-
sheet 1 in Publication 596 [1].

Metamorphic properties. We specify 4 metamorphic relations for
𝐸𝐼𝐶, as shown in Table 1 (properties #3-#6). Property #3 specifies
that married filing separately (𝑀𝐹𝑆) is illegible to take 𝐸𝐼𝐶 cred-
its. Property #4 describes that individuals who are married filing
jointly (𝑀𝐹 𝐽 ) are illegible if their adjusted gross income (𝐴𝐺𝐼 ) is
over 56, 844. Property #5 says that an eligible individual with 𝐸𝐼𝐶
claim (Line 27 of IRS 1040) should have higher returns compared to
metamorphosed one who are not eligible due to their 𝐴𝐺𝐼 , depen-
dents, or zero claim. Finally, property #6 establishes that among two
similarly eligible individuals, the one with the higher 𝐸𝐼𝐶 claims
should have a higher tax return.

Random Test-Case Generations. We generate test cases from these
metamorphic properties. We encode each metamorphic property

as a search problem where the objective is to find an individual
and its metamorphosed one such that their deviants from expected
outcomes are maximum. We sample data points uniformly at random
to generate the source test case and perturb it to generate follow-ups
from its neighbors. Algorithm 1 shows the random search strategy.
For 𝐸𝐼𝐶, the random search generates over 61k, 62k, 64k, and 31k for
properties #3 to #6, respectively, in a 10 minutes run. OpenTaxSolver
failed for properties #3-#4 and passed for properties #5-#6.

Explaining Failure Circumstances. Given the set of passed and
failed inputs, we use a modified CART decision tree algorithm
(detailed in Section 5) to infer what conditions distinguish failed
test cases from passed ones. Since the software fails all test cases
for properties #3-#4, the premises of metamorphic relations simply
explain the failure circumstances. In these cases, the software misses
two eligibility conditions (married filing separately and AGI) and
consequently fails in relevant test cases. For illustrations, Figure 1
(right) shows these circumstances, as compared to properties #5-
#6. Beyond 𝐸𝐼𝐶, one of failures found in this paper pinpoint to
conditions where the tax returns get close to zero (see Figure 3). A
similar bug has been observed for the French tax software due to
rounding algorithms [20].

4 PROBLEM STATEMENT
The functional model of tax software consists of a tuple (𝑋, F )
where 𝑋 = {𝑋1, 𝑋2, . . . , 𝑋𝑛 } is the set of variables corresponding
to various fields about an individual in the tax return form and
F : D1 × D2 × · · · × D𝑛 → R≥0 is the federal tax return computed
by the software, where D𝑖 is the domain of variable 𝑋𝑖 . We write D
for D1 × D2 × · · · × D𝑛.

These variables correspond to intuitive labels such as age (numer-
ical variable), blind (Boolean variable), and sts (filing status with
values such as MFJ, married filing jointly, and MFS, married filing
separately). For an individual x ∈ D, we write x(𝑖) for the value of
𝑖-th variable, or x.lab for the value of variable lab. Let L be the set
of all labels.

For labels 𝐿 ⊆ L and inputs x ∈ D and y ∈ D, we say that y is
a metamorphose of x with the exceptions of labels 𝐿, and we write
x ≡𝐿 y if ∀ℓ ∉ 𝐿 we have that x.ℓ = y.ℓ. A metamorphic relation is a
first-order logic formula with variables in 𝑋 , constants from domains
in D, relation ≡𝐿, comparisons {<, ≤, =, ≥, >} over numeric vari-
ables, predicate ¬ (negation) for Boolean valued labels, real-valued
function for federal tax return F : D → R, Boolean connectives
∧, ∨, ¬, =⇒ , ⇐⇒ , and quantifiers ∃𝑥 .𝜙 (𝑥) and ∀𝑥 .𝜙 (𝑥) with
natural interpretations. W.l.o.g., we assume that the formulas are
given in the prenex normal form, i.e. a block of quantifiers followed

3

by a quantifier free formula. Using metamorphic relations, we can
express the property,

for two individuals that differ only in age, the federal
tax return of the older individual must be greater than
or equal to that of the younger one,

using the following metamorphic property 𝜙:

∀x, y (x ≡𝑎𝑔𝑒 y) ∧ (x.𝑎𝑔𝑒 ≥ y.𝑎𝑔𝑒) =⇒ (F (x) ≥ F (y)).

Falsification Problem. Given a tax preparation software (𝑋, F ) and
a metamorphic property 𝜙, the falsification problem is to explore
the input space of the software to discover inputs that falsify the
property. Metamorphic properties containing only one variable are
classical properties relating inputs to outputs; however for properties
with more than one quantified variables, multiple inputs are required
to evaluate the property. Observe that the metamorphic property
falsification problem is PSPACE-hard as it is expressive enough to
encode True Quantified Boolean formula (TQBF) problem (when
the input variables are Boolean and program logic encode Boolean
constraints). Hence, it is intractable to provide an exhaustive search
procedure. To overcome this challenge, we propose randomized
search-based testing approach.

Depending upon the number and nature of of quantifiers, multiple
inputs need to be sampled to ascertain the status of the property.
Moreover, when the input space is large or infinite, we may not
be able to falsify subformulae of the form ∃x.𝜙 (x) as it would
require testing the whole state space. To overcome this challenge
in practice, we recourse to statistical testing guided by randomized
exploration of the state space. In the next section, we present a
sampling strategy to falsify properties of the form ∀𝑥 .𝜙 (𝑥); this
procedure can be recursively invoked to provide the procedure for
metamorphic properties with arbitrary quantification.

5 APPROACH
We develop an efficient metamorphic testing and debugging to un-
cover bugs in the tax preparation software.

Algorithm 1 sketches different steps in our approach. We start
from some initial seed inputs 𝐼 . In each step, the search strategy
selects and perturbs inputs from the set of promising inputs (those
maximizing the deviant from the expect outcome) and generates a
base test case (line 4). Then, it perturbs the base to generate follow-
up cases (line 5). Next, it executes the base and follow-up inputs on
the target software and quantify the deviant between the outcomes
(line 6). If the deviant is more than a threshold, it adds the inputs
with ‘failed’ label (line 8). Furthermore, if the deviant is higher than
any previous ones, it adds the inputs as promising ones (line 9).
Otherwise, it adds the inputs with ‘passed’ label (line 12). However,
the absence of evidence for failures does not mean the correctness.
This is indeed an important shortcoming for metamorphic-based
random test generations. Our algorithm instead uses a statistical
hypothesis testing to provide statistical confidence on the absence
of failures, starting from the base test case. The null and alternative
hypotheses are

H0 : P(𝑥1) ≥ 𝜃, H1 : P(𝑥1) < 𝜃
where P(𝑥1) is the probability that follow-up test cases, starting
from 𝑥1 as the source test, are passed, 𝜃 is the lower-bound on the

Algorithm 1: RANDOMTESTCASEGENERATION
Input: Tax preparation software P, initial input seeds 𝐼 ,

metamorphic property 𝑝, a tolerance threshold 𝛿, a
Bayes factor 𝐵, a lower-bound on the confidence 𝜃 ,
and timeout 𝑇 .

Output: Passed/Failed, test cases, decision tree

1 (𝑥𝑚, Δ𝐹𝑇 𝑅, 𝑟𝑒𝑠) ← SAMPLE(𝐼 ), 0, True
2 while time() - 𝑠𝑡𝑎𝑟𝑡_𝑡𝑖𝑚𝑒 < T do
3

𝑘 ← 0
𝑥1 ← UNIFORMPERTURB(𝑥𝑚, 𝑝)
𝑥2 ← UNIFORMPERTURB(𝑥1, 𝑝)
Δ ← DIST(P (𝑥1), P (𝑥2))
if Δ > 𝛿 then

4

5

6

7

8

9

10

11

12

13

14

15

16

17

𝐼 .ADD (cid:0)(𝑥1,𝑥2),‘failed’(cid:1)
if Δ > Δ𝐹𝑇 𝑅 then
𝑥𝑚 ← 𝑥1
Δ ← Δ𝐹𝑇 𝑅

𝑟𝑒𝑠 ← False

else

𝐼 .ADD (cid:0)(𝑥1,𝑥2),‘passed’(cid:1)
𝑘 ← 𝑘 + 1
if 𝑘 < − log 𝐵
log 𝜃
Go to 5

then

18 if 𝐼 [‘passed’] = {} ∨ 𝐼 [‘failed’] = {} then
19

return 𝑝

20 else
21
22 return 𝑟𝑒𝑠, 𝐼 , 𝑡.

𝑡 ← LEXICOGRAPHICDTCLASSIFIER(𝐼 )

probability, H0 is null hypothesis, and H1 is the alternative. Our
goal is to witness enough passed test cases to accept H0 as opposed
to H1. There are multiple ways to conduct such statistical testing.
The sequential probability ratio test and a Bayes factor are examples.
We follow Jeffreys test [15, 24], a variant of Bayes factor, with a
uniform prior to find a lower-bound on the number of successive
samples 𝐾 that sufficient for us to convince H0:
𝜃 )⌉

𝐾 ≥ ⌈(− log2

𝐵)/(log2

where 𝐵 in numerator is Bayes factor and can be set to 100 for a very
strong evidence. For instance, to achieve a 𝜃 = 0.95, we are required
to set 𝐾 ≥ 90 to be highly confident on accepting H0. Lines 13-15
show this hypothesis testing.

After generating the test suite, our algorithm uses a data-driven ap-
proach to infer circumstances under which the software fails. Given
the set of test cases with ‘passed’ and ‘failed’ labels, the problem
appears to be a standard classification to discriminate between the
two labels [16]. However, the generated samples are not indepen-
dent as the follow-up samples are dependent on the base samples.
To overcome this challenge, we modified the classical CART tree
inference to enforce a lexicographical order between features. This
modified procedure is invoked in Algorithm 1 (line 19). Observe that
each test sample is a valuation for base and follow-up features. The

4

Table 1: Metamorphic properties for five domains in the US tax policies. F is federal tax return where negative values mean the
individual owns payment to the IRS, 𝑠𝑡𝑠 is filing status, 𝑠_𝑙𝑎𝑏 is spouse’s field 𝑙𝑎𝑏, 𝑀𝐹 𝐽 : married filing jointly, 𝑀𝐹𝑆 is married filing
separately, 𝐴𝐺𝐼 is adjusted gross income, 𝐿27 is line 27 of IRS 1040 for Earned Income Tax Credit (EITC), 𝑄𝐶 is the number of
qualified children, 𝑂𝐷 is the number of other dependents, 𝐶𝑇𝐶 is child tax credits, 𝐿29 is line 29 of IRS 1040 for Education Tax
Credit (𝐸𝑇𝐶), 𝑀𝐷𝐸 is medical/dental expenses, 𝑖𝑧 is to use itemized deductions (𝐼 𝐷) vs. standard deductions, and 𝐿12 is total itemized
deductions (𝐼𝐷) from schedule 𝐴.

Id
1
2

3
4
5

6
7
8

9
10
11
12

13
14
15
16

Domain
Disability
Disability

EITC
EITC
EITC

EITC
CTC
CTC

ETC
ETC
ETC
ETC

ID
ID
ID
ID

Metamorphic Property
∀x, y((x≡𝑎𝑔𝑒 y) ∧ (x.𝑎𝑔𝑒 ≥65) ∧ (y.𝑎𝑔𝑒<65)) ∨ ((x≡𝑏𝑙𝑖𝑛𝑑 y) ∧ (x.𝑏𝑙𝑖𝑛𝑑 ∧ ¬y.𝑏𝑙𝑖𝑛𝑑)) =⇒ F (x) ≥ F (y)
∀x(x.𝑠𝑡𝑠 = 𝑀𝐹 𝐽 ) =⇒ ∀y((x ≡𝑠_𝑎𝑔𝑒 y) ∧ (x.𝑠_𝑎𝑔𝑒 ≥ 65) ∧ (y.𝑠_𝑎𝑔𝑒 < 65)) ∨ ((x ≡𝑠_𝑏𝑙𝑖𝑛𝑑 y) ∧ (x.𝑠_𝑏𝑙𝑖𝑛𝑑 ∧
¬y.𝑠_𝑏𝑙𝑖𝑛𝑑)) =⇒ F (x) ≥ F (y)
∀x(x.𝑠𝑡𝑠 = 𝑀𝐹𝑆) =⇒ ∀y(x≡𝐿27y ∧ x.𝐿27 > 0.0 ∧ y.𝐿27 = 0.0) =⇒ F (x)=F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) ∧ (x.𝐴𝐺𝐼 >56, 844) =⇒ ∀y(x≡𝐿27y ∧ x.𝐿27>0.0 ∧ y.𝐿27=0.0) =⇒ F (x)=F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) =⇒ ∀y(x≡𝐴𝐺𝐼 y ∧ x.𝐴𝐺𝐼 ≤56, 844 ∧ y.𝐴𝐺𝐼 >56, 844) ∨ (x≡𝐿27y ∧ x.𝐿27>0.0 ∧ y.𝐿27=0.0) ∨ (x≡𝑄𝐶 y ∧
x.𝑄𝐶 ≥1 ∧ y.𝑄𝐶=0) =⇒ F (x)≥F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 )∧(x.𝐴𝐺𝐼 ≤56, 844)∧(x.𝑄𝐶 ≤3) =⇒ ∀y((x≡𝐿27y)∧x.𝐿27≥y.𝐿27) =⇒ F (x)≥F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 )∧(x.𝐴𝐺𝐼 ≤200𝑘)∀y((x≡𝐿19y)∧(x.𝐿19≥y.𝐿19)) =⇒ F (x)≥F (y))
∗ 0.05<x′.𝑄𝐶 ∗ 2𝑘 + x.𝑂𝐷 ∗
∀x, x′(x.𝑠𝑡𝑠=x′.𝑠𝑡𝑠=𝑀𝐹 𝐽 )∧(x.𝐴𝐺𝐼 <400𝑘)∧(x′.𝐴𝐺𝐼 ≥400𝑘)∧⌈x′.𝐴𝐺𝐼 −400𝑘⌉1𝑘
0.5𝑘 =⇒ ∀y, y′(x≡{𝑄𝐶,𝑂𝐷 }y)∧(x′≡{𝑄𝐶,𝑂𝐷 }y′) ∧ (0≤y.𝑄𝐶=y′.𝑄𝐶 ≤x.𝑄𝐶=x′.𝑄𝐶 ≤ 10) ∧ (0≤y.𝑂𝐷=y′.𝑂𝐷 ≤
x.𝑂𝐷=x′.𝑂𝐷 ≤ 10) =⇒ (F (x) − F (𝑦)) ≥ (F (𝑥 ′) − F (𝑦 ′))
∀x(x.𝑠𝑡𝑠 = 𝑀𝐹𝑆) =⇒ ∀y(x≡𝐿29y ∧ x.𝐿29 > 0.0 ∧ y.𝐿29 = 0.0) =⇒ F (x)=F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) ∧ (x.𝐴𝐺𝐼 >180𝑘) =⇒ ∀y(x≡𝐿29y ∧ x.𝐿29>0.0 ∧ y.𝐿29=0.0) =⇒ F (x)=F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) ∧ (x.𝐴𝐺𝐼 <160𝑘) =⇒ ∀y(x≡𝐿29y ∧ x.𝐿29≥y.𝐿29) =⇒ F (x)≥F (y)
∀x, x′(x.𝑠𝑡𝑠=x′.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) ∧ (x.𝐴𝐺𝐼 ≤160𝑘) ∧ (160𝑘 ≤x′.𝐴𝐺𝐼 ≤180𝑘) =⇒ ∀y, y′((x ≡𝐿29 y) ∧ (x′ ≡𝐿29 y′) ∧ (x.𝐿29 =
x′.𝐿29 ≥ y.𝐿29 = y′.𝐿29)) =⇒ (F (x) − F (𝑦)) ≥ (F (𝑥 ′) − F (𝑦 ′))
∀x(x.𝑀𝐷𝐸≤x.𝐴𝐺𝐼 ∗ 7.5%) =⇒ ∀y(x≡𝐿12y ∧ x.𝐿12>0.0 ∧ y.𝐿12=0.0) =⇒ F (x)=F (y)
∀x(¬x.𝑖𝑧) =⇒ ∀y(x≡𝐿12y ∧ x.𝐿12>0.0 ∧ y.𝐿12=0.0) =⇒ F (x)=F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) =⇒ ∀y((x≡𝑖𝑧,𝐿12y)∧(x.𝑖𝑧∧¬y.𝑖𝑧)∧(x.𝐿12≤24.8𝑘∧x′.𝐿12=0.0)) =⇒ F (x)≤F (y)
∀x(x.𝑠𝑡𝑠=𝑀𝐹 𝐽 ) =⇒ ∀y((x≡𝑖𝑧,𝐿12y)∧(x.𝑖𝑧∧¬y.𝑖𝑧)∧(x.𝐿12>24.8𝑘∧x′.𝐿12=0.0)) =⇒ F (x)≥F (y)

decision tree inference algorithm picks a feature and a split upon it
that minimize a selection criterion (e.g., impurity or entropy) among
all other features and splits in each step. To integrate lexicographic
ordering within features, we modified the split functionality and
calculated the amount of association between a follow-up feature
and its prefixes. Mutual information and linear correlations can be
used to quantify such associations.

6 EXPERIMENTS

Implementations. We implement test-case generations in Python us-
ing the XML parser library to define the tax field variables and their
domains. We implement the lexicographic decision trees in scikit-
learn framework [21]. In particular, we implement the modifications
in _splitter.pyx (a Cypthon class) in sklearn.tree direc-
tory as a part of node_split() function.

Tax Policies. We consider aspects in the US individual income tax
return that deal with credits/deductions and are notoriously challeng-
ing [14]. We focus on fields related to senior and disable individuals;
Earned Income Tax Credit (EITC) [1]; Child Tax Credit (CTC) that
reduces the taxes owed on each qualifying child under the age of
17 [2]; Educational Tax Credit (ETC) that help students with the
cost of higher education by lowering their owed taxes or increasing
their refund [3]; and itemized deductions (ID) that is an option to
taxpayers with significant tax deductible expenses [25].

5

Metamorphic Relations. We use scenarios and examples described
in these policies to synthesize metamorphic relations. Table 1 shows
16 metamorphic relations in 5 domains. Next, we provide a brief
explanation of some of these properties.

– Property #1. An individual with disability must receive simi-
lar or better tax benefits when compared with a person without
disability who is similar in every other aspect.

– Property #2. An individual with the married filing jointly
(𝑀𝐹 𝐽 ) status with disabled spouse must receive similar or
higher tax benefits compared to a similar individual but with-
out the disability of the spouse.

– Property #3. An individual with the married filing separately
(𝑀𝐹𝑆) status is not eligible for EITC. This is based on tax
year 2020. The eligibility has since changed, and 𝑀𝐹𝑆 with
EITC claims may be eligible for tax year 2021.

– Property #4. An individual with the married filing jointly
(𝑀𝐹 𝐽 ) status with 𝐴𝐺𝐼 over 56, 844 is ineligible for EITC in
tax year 2020. The 𝐴𝐺𝐼 threshold changes every tax years.
– Property #5. An individual who qualifies for EITC must re-

ceive a higher return than a similar unqualified one.

– Property #6. Among two qualified individuals with EITC, one
with higher EITC claims receives higher or equal benefits.
– Property #7. Among two qualified married filing jointly (𝑀𝐹 𝐽 )
individuals, one with higher child tax credits receives higher
or equal tax return benefits.

Figure 2: Left. Tax returns are clustered into 5 groups, varying values of variables in properties #1,#2; Right. DT explains the number
of yes answers to four senior/disability (age above 65, blindness, spouse age over 65, and spouse blindness) explains different returns.

– Property #8. This property requires a comparison between
four “similar” individuals since there is a relation between
two variables of interests: 𝐴𝐺𝐼 and the number of qualified
children/others to claim a CTC. A individual with more qual-
ified dependents must receive higher or similar tax return
benefits than an individual with fewer dependents after ad-
justing for the effects of income levels on the calculations of
both final return and the amounts of CTC claims. Expressing
this property requires holding the income of two individuals
same per each qualified number of children/others.

– Property #9. An individual with the married filing separately

(𝑀𝐹𝑆) status is is ineligible for ETC in tax year 2020.

– Property #10. An individual with the married filing jointly
(𝑀𝐹𝑆) status with 𝐴𝐺𝐼 over 180𝑘 is ineligible for ETC.
– Property #11. A qualified individual with 𝐴𝐺𝐼 below 160𝑘
who claims ETC received higher or similar tax return benefits
compared to a similar individual who is ineligibility or does
not claim ETC for tax year 2020.

– Property #12. This property requires a comparison between
four four similar individuals as the rule changes for individ-
uals with 𝐴𝐺𝐼 below 160𝑘 and between 160𝑘 and 18𝑘. By
holding 𝐴𝐺𝐼 constant between two individuals with 𝐴𝐺𝐼 be-
low 160𝑘 (varying the 𝐸𝑇𝐶 claims) and two individuals with
𝐴𝐺𝐼 between 160𝑘 and 180𝑘 (varying the 𝐸𝑇𝐶 claims with the
same rate), the property requires that individuals with income
below 160𝑘 receives higher or similar tax returns without the
influence of 𝐴𝐺𝐼 in the computation.

– Property #13. An individual who files with medical/dental
expenses (𝑀𝐷𝐸) below 7.5% of their 𝐴𝐺𝐼 and itemizes their
deductions receives the same return as a similar individual
with no 𝑀𝐷𝐸 claims.

– Property #14. When filing with a standard deduction, total
itemized deduction (Line 12) must have no effect on the tax
returns.

– Property #15. An individual who files with itemized deduc-
tions below the standard deductions receive a lower or similar
tax return benefits compared to a similar individual who used
the standard deductions.

– Property #16. An individual who files with itemized deduc-
tions above the standard deductions receive a higher or simi-
lar tax return benefits compared to a similar individual who
claims standard deductions.

Test-Case Generations. We employed our random test-case gen-
eration algorithm to generate base and follow-ups that satisfy the
relation between inputs and negate the relation between outcomes.
In Algorithm 1, we set 𝐵 to 100 and 𝛿 to 0.95. We run each exper-
iment for 10 mins. Table 2 shows the results of random test-case
generations. We report the number of passed and failed test cases as
well as the maximum observed differences in tax returns in failures.
Overall, we found evidences of failures for 7 properties out of 16.
Our search algorithm often finds the evidences for failure below 1
second, except one case that took close to 2 minutes (property #13).
The maximum deviant observed is $1, 000. We restricted the claimed
credits for EITC, CTC, and ETC to be at most $1, 000, and itemized
deductions to be up to $100, 000.

Decision Tree Explanations. Table 2 shows the scalability and per-
formance of DT for experiments with both failed and passed cases.
We only use DT explanations for cases with some passes and other
failures. We report the computation times, accuracy, the height of
tree, and the number of leaf nodes. Though software passes all test
cases for properties #1 and #2, we first use them to overview DT-
based explanatory model as a debugging tool in high-level. Then,
we show the efficacy for cases with failure and success test cases.
Figure 2 (left) shows 5 clusters of federal tax returns (FTR). The
next step is to find out what features (fields in tax filing) distin-
guish different clusters. Figure 2 (right) shows the corresponding
DT model for explanations. Each path from root nodes to the leaf
defines a predicate function per cluster. For example, the lowest
cluster (orange) is explained by a predicate where their age and their
spouse’s age are less than 65, and none of them are blind whereas
one higher cluster has exactly one ‘yes’ to these options.

We use a similar technique to explain circumstances under which
the software fails to satisfy the metamorphic properties. We label
failed test cases with orange colors and passed ones with green colors.
Note that if all test cases are failed or passed, we just report the
premises of corresponding metamorphic property. As we discussed
before, standard decision trees do not capture dependencies and
have poor explanatory features. Figure 3 (left) shows explanations
for property #13 with standard decision trees. As we can see, the
explanation is only based on follow-up cases (features end with
_2) and does not provide intuitions on how base tests contribute to
witness a failure. Figure 3 (middle) shows corresponding decision
tree for property #13. The decision tree shows that failures happened
when the base income is over 151k, the base cases have medical

6

Table 2: Experimental results on OpenTaxSolver using the 16 metamorphic relations. Test-case generation time-outs at 10 mins.

Property ID

Disability (1)
Disability (2)
EIC (3)
EIC (4)
EIC (5)
EIC (6)
CTC (7)
CTC (8)
ETC (9)
ETC (10)
ETC (11)
ETC (12)
ID (13)
ID (14)
ID (15)
ID (16)

#test cases
68,893
64,244
61,592
62,253
64,581
31,886
59,823
33,343
66,596
63,562
31,112
33,330
65,801
31,823
32,754
32,474

Random Test-Case Generations
1st failure(s)
N/A
N/A
0.1
0.1
N/A
N/A
N/A
N/A
0.1
0.1
0.3
N/A
114.4
N/A
N/A
0.8

#pass
68,893
64,244
0
0
64,581
31,886
59,823
33,343
0
0
28,756
33,330
64,912
31,823
32,754
31,689

#fail
0
0
61,592
62,253
0
0
0
0
66,596
63,562
2,356
0
889
0
0
785

Max. Δ𝐹𝑇 𝑅
0
0
1,000
1,000
0
0
0
0
1,000
1,000
177
0
245
0
0
160

type
FOL
FOL
FOL
FOL
FOL
FOL
FOL
FOL
FOL
FOL
DT
FOL
DT
FOL
FOL
DT

DT Models or FOL if all cases are passed/failed
Accuracy
Computation(s)
100%
0.0
100%
0.0
100%
0.0
100%
0.0
100%
0.0
100%
0.0
100%
0.0
100%
0.0
100%
0.0
100%
0.0
98%
5.2
100%
0.0
100%
5.4
100%
0.0
100%
0.0
98%
5.4

Height
2
3
2
4
3
5
4
13
2
4
5
8
4
3
5
9

#Leaf Nodes
2
2
1
1
3
1
1
1
1
1
12
1
5
1
1
22

Figure 3: Left. CART DT shows circumstances under which failed test cases (orange leaves) are distinguished from passed ones (green
leaves) for itemize deductions with medical expenses; Middle. Lexicographic trees provide richer information for the same task as
one in the left; Right. Failure circumstances in Education Tax Credits (ETC): failed cases have a federal tax return in an interval that
includes 0. Note that features ending with _1 and _2 are bases and ending with _3 and _4 are metamorphosed ones.

expenses below 13k, the itemized deductions are selected, and the
follow-up cases have medical expenses over 13k. Figure 3 (right)
shows DT model for failure circumstances for the property #11
where the failures correlate with an FTR interval that includes zero.
In summary, we found and explained four types of bugs: i) missing
eligibility conditions completely (properties #3-#4 and #9-#10); ii)
unexpected outcomes when the federal tax returns get close to zero
(property #11); iii) applying itemized deductions when expenses are
less than 7.5% of AGI (property #13); and iv) itemized deductions
slightly exceed a standard deduction, but result in a lower tax return
(property #16).

Performance of Lexicographic DT algorithm. We did not find a
significant performance degradation using the proposed decision
tree inferences. We performed experiments on growing number of
samples/features and observed that the computation times grow
from 2.69(s) to 5.15(s) for standard DT and from 2.72(s) to 5.23(s)
for lexicographic DT, a maximum slow-down of 100 ms.

7 CONCLUSION
Tax preparation software are increasingly indispensable in navigat-
ing the complex tax structure. Since the legal responsibilities of
bugs in such software rest on the end-users, most of whom cannot
afford expensive accountants or commercial software, developing
debugging aids for such systems is our social responsibility.

This paper presented a data-driven debugging framework for
metamorphic specifications expressed in a first-order logic. We hope
that our experience in capturing the tax-preparation software require-
ments convinced the reader that the first-order logic based metamor-
phic specifications are both intuitive and unambiguous in expressing
the comparative nature of legal requirements. The experimental
results also demonstrated that search-based software engineering
approaches are useful in uncovering and explaining bugs in a popular
open-source tax preparation software. We believe that the proposed
approach provides a blueprint for formal testing and debugging for
other legal-critical software systems.

7

[25] IRS Schedule-A. 2021. Itemized Deductions. https://www.irs.gov/pub/irs-pdf/

f1040sa.pdf. Online.

[26] S. Segura, G. Fraser, A. B. Sanchez, and A. Ruiz-Cortés. 2016. A Survey on
Metamorphic Testing. IEEE Transactions on Software Engineering 42, 9 (Sept
2016), 805–824.

[27] Jay A. Soled and Kathleen DeLaney Thomas. 2017. Regulating Tax Return

Preparation. Boston College Law Review 58 (2017), 152–204.

[28] Saeid Tizpaz-Niari, Pavol Cerny, Bor-Yuh Evan Chang, and Ashutosh Trivedi.
2018. Differential performance debugging with discriminant regression trees. In
Proceedings of the AAAI Conference on Artificial Intelligence, Vol. 32.

[29] US-IRS. 2020. Six reasons 90 percent of people will e-file their tax returns.

https://www.irs.gov/pub/irs-utl/oc-e-file.pdf/. online.

[30] US.IRS. [n.d.]. Filing statistics for week ending December 11 2020. filing-season-

statistics-for-week-ending-december-11-2020. online.

[31] Xiaoyuan Xie, Joshua W. K. Ho, Christian Murphy, Gail Kaiser, Baowen Xu, and
Tsong Yueh Chen. 2011. Testing and Validating Machine Learning Classifiers by
Metamorphic Testing. Journal of Systems and Software (JSS) (2011), 544–558.
https://doi.org/10.1016/j.jss.2010.11.920

[32] Zhi Quan Zhou and Liqun Sun. [n.d.]. Metamorphic Testing of Driverless Cars.

Commun. ACM 62, 3 ([n. d.]), 61–67.

[33] Zhi Quan Zhou, ShuJia Zhang, Markus Hagenbuchner, TH Tse, Fei-Ching Kuo,
and Tsong Yueh Chen. 2012. Automated functional testing of online search
services. Software Testing, Verification and Reliability (2012), 221–243.

REFERENCES
[1] IRS 596. 2021. Earned Income Credit (EIC). https://www.irs.gov/pub/irs-pdf/

p596.pdf. Online.

[2] IRS 8812. 2021. Credits for Qualifying Children and Other Dependents. https:

//www.irs.gov/forms-pubs/about-schedule-8812-form-1040. Online.

[3] IRS 8863. 2021. Education Credits. https://www.irs.gov/pub/irs-pdf/f8863.pdf.

Online.

[4] John Ahlgren, Maria Eugenia Berezin, Kinga Bojarczuk, Elena Dulskyte, Inna
Dvortsova, Johann George, Natalija Gucevska, Mark Harman, Maria Lomeli, Erik
Meijer, et al. 2021. Testing Web Enabled Simulation at Scale Using Metamorphic
Testing. In ICSE-SEIP. IEEE, 140–149.

[5] Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo.
2015. The Oracle Problem in Software Testing: A Survey. IEEE Transactions on
Software Engineering 41, 5 (2015), 507–525. https://doi.org/10.1109/TSE.2014.
2372785

[6] L. Breiman, J.H. Friedman, R.A. Olshen, and C.I. Stone. 1984. Classification and

regression trees. Wadsworth: Belmont, CA.

[7] T. Y. Chen, S. C. Cheung, and S.M. Yiu. 1998. Metamorphic Testing: A New
Approach for Generating Next Test Cases. Technical Report HKUST-CS98-01.
https://arxiv.org/abs/2002.12543

[8] Jessica Cherry. 2020. Use OpenTaxSolver as an open source alternative to Turbo-

Tax. https://opensource.com/article/20/2/open-source-taxes. Online.

[9] Reddit Linux Community. 2019. Open source alternative to turbotax called
Open-source Tax Solver. https://www.reddit.com/r/linux/comments/bhp3cq/open_
source_alternative_to_turbotax_called/. Online.

[10] Direction Générale des Finances Publiques (DGFiP). 2019. Les règles du moteur
de calcul de l’impôt sur le revenu et de l’impôt sur la fortune immobilière. https:
//gitlab.adullact.net/dgfip/ir-calcul. online.

[11] Antonin Garrone. 2021. Openfisca France. https://github.com/openfisca/openfisca-

france. Online.

[12] Aidan Grimshaw and Zak Patterson. 2021. UsTaxes: a free open-source tax filing

application. https://github.com/ustaxes/UsTaxes. Online.

[13] IRS. 2006. Written Statement of Nina E. Olson National Taxpayer Advocate
Before the Committee on Finance United States Senate Hearing on Tax Return
Preparation Options for Taxpayers. https://www.irs.gov/pub/tas/ntatestimonysfc_
tax_return_preparation_process040406.pdf. Online.

[14] US IRS. 2020.

Filing taxes 101: Common errors taxpayers should
avoid. https://www.irs.gov/newsroom/filing-taxes-101-common-errors-taxpayers-
should-avoid. Online.

[15] Sumit K Jha, Edmund M Clarke, Christopher J Langmead, Axel Legay, André
Platzer, and Paolo Zuliani. 2009. A bayesian approach to model checking biologi-
cal systems. In CMSB. Springer, 218–234.

[16] Alexander Kampmann, Nikolas Havrikov, Ezekiel O Soremekun, and Andreas
Zeller. 2020. When does my program do this? learning circumstances of software
behavior. In FSE. 1228–1239.

[17] Sarah B. Lawsky. 2017. Formalizing the Code. Northwestern Public Law Research

Paper (2017). https://doi.org/10.2139/ssrn.2987065

[18] Jeanna Matthews, Marzieh Babaeianjelodar, Stephen Lorenz, Abigail Matthews,
Mariama Njie, Nathaniel Adams, Dan Krane, Jessica Goldthwaite, and Clinton
Hughes. 2019. The Right To Confront Your Accusers: Opening the Black Box of
Forensic DNA Software. In Proceedings of the 2019 AAAI/ACM Conference on
AI, Ethics, and Society (AIES ’19). 321–327. https://doi.org/10.1145/3306618.
3314279

[19] Jeanna Neefe Matthews, Graham Northup, Isabella Grasso, Stephen Lorenz,
Marzieh Babaeianjelodar, Hunter Bashaw, Sumona Mondal, Abigail Matthews,
Mariama Njie, and Jessica Goldthwaite. 2020. When Trusted Black Boxes
Don’t Agree: Incentivizing Iterative Improvement and Accountability in Criti-
cal Software Systems. Association for Computing Machinery, 102–108. https:
//doi.org/10.1145/3375627.3375807

[20] Denis Merigoux, Raphaël Monat, and Jonathan Protzenko. 2021. A Modern
Compiler for the French Tax Code. In Proceedings of the 30th ACM SIGPLAN
International Conference on Compiler Construction (CC 2021). Association for
Computing Machinery, 71–82. https://doi.org/10.1145/3446804.3446850
[21] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M.
Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cour-
napeau, M. Brucher, M. Perrot, and E. Duchesnay. 2011. Scikit-learn: Machine
Learning in Python. Journal of Machine Learning Research (2011), 2825–2830.
[22] Marcos A. Pertierra, Sarah Lawsky, Erik Hemberg, and Una-May O’Reilly. 2017.
Towards Formalizing Statute Law as Default Logic through Automatic Semantic
Parsing. In Proceedings of the Second Workshop on Automated Semantic Analysis
of Information in Legal Texts. http://ceur-ws.org/Vol-2143/paper9.pdf

[23] Aston Roberts. 2021. Open Tax Solver.

https://sourceforge.net/projects/

opentaxsolver/. Online.

[24] Sriram Sankaranarayanan, Aleksandar Chakarov, and Sumit Gulwani. 2013. Static
analysis for probabilistic programs: inferring whole program properties from
finitely many paths. In PLDI. 447–458.

8

