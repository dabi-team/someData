Fast Computation of Zigzag Persistence∗

Tamal K. Dey†

Tao Hou‡

Abstract

Zigzag persistence is a powerful extension of the standard persistence which allows deletions
of simplices besides insertions. However, computing zigzag persistence usually takes considerably
more time than the standard persistence. We propose an algorithm called FastZigzag which
narrows this eﬃciency gap. Our main result is that an input simplex-wise zigzag ﬁltration can
be converted to a cell -wise non-zigzag ﬁltration of a ∆-complex with the same length, where the
cells are copies of the input simplices. This conversion step in FastZigzag incurs very little
cost. Furthermore, the barcode of the original ﬁltration can be easily read from the barcode of
the new cell-wise ﬁltration because the conversion embodies a series of diamond switches known
in topological data analysis. This seemingly simple observation opens up the vast possibilities
for improving the computation of zigzag persistence because any eﬃcient algorithm/software
for standard persistence can now be applied to computing zigzag persistence. Our experiment
shows that this indeed achieves substantial performance gain over the existing state-of-the-art
softwares.

2
2
0
2

l
u
J

4

]

G
C
.
s
c
[

2
v
0
8
0
1
1
.
4
0
2
2
:
v
i
X
r
a

∗This research is partially supported by NSF grant CCF 2049010.
†Department of Computer Science, Purdue University. tamaldey@purdue.edu
‡School of Computing, DePaul University. taohou01@gmail.com

 
 
 
 
 
 
1

Introduction

Standard persistent homology deﬁned over a growing sequence of simplicial complexes is a fundamen-
tal tool in topological data analysis (TDA). Since the advent of persistence algorithm [18] and its
algebraic understanding [30], various extensions of the basic concept have been explored [6, 8, 12, 13].
Among these extensions, zigzag persistence introduced by Carlsson and de Silva [6] is an important
one. It empowered TDA to deal with ﬁltrations where both insertion and deletion of simplices are
allowed. In practice, allowing deletion of simplices does make the topological tool more powerful.
For example, in dynamic networks [15, 21] a sequence of graphs may not grow monotonically but can
also shrink due to disappearance of vertex connections. Furthermore, zigzag persistence seems to be
naturally connected with the computations involving multiparameter persistence, see e.g. [16, 17].
Zigzag persistence possesses some key diﬀerences from standard persistence. For example, unlike
standard (non-zigzag) modules which decompose into only ﬁnite and inﬁnite intervals, zigzag modules
decompose into four types of intervals (see Deﬁnition 2). Existing algorithms for computing zigzag
persistence from a zigzag ﬁltration [8, 22, 23, 24] are all based on maintaining explicitly or implicitly
a consistent basis throughout the ﬁltration. This makes these algorithms for zigzag persistence
more involved and hence slower in practice than algorithms for the non-zigzag version though they
have the same time complexity [25]. We sidestep the bottleneck of maintaining an explicit basis and
propose an algorithm called FastZigzag, which converts the input zigzag ﬁltration to a non-zigzag
ﬁltration with an eﬃcient strategy for mapping barcodes of the two bijectively. Then, we can apply
any eﬃcient algorithm for standard persistence on the resulting non-zigzag ﬁltration to compute the
barcode of the original ﬁltration. Considering the abundance of optimizations [2, 3, 4, 5, 10, 11] of
standard persistence algorithms and a recent GPU acceleration [29], the conversion in FastZigzag
enables zigzag persistence computation to take advantage of any existing or future improvements
on standard persistence computation. Our implementation, which uses the Phat [4] software for
computing standard persistence, shows substantial performance gain over existing state-of-the-art
softwares [26, 28] for computing zigzag persistence (see Section 3.5). We make our software publicly
available through: https://github.com/taohou01/fzz.

To elaborate on the strategy of FastZigzag, we ﬁrst observe a special type of zigzag ﬁltrations
called non-repetitive zigzag ﬁltrations in which a simplex (or more generally, a cell ) is never added
again once deleted. Such a ﬁltration admits an up-down ﬁltration as its canonical form that can be
obtained by a series of diamond switches [6, 7, 8]. The up-down ﬁltration can be further converted
into a non-zigzag ﬁltration again using diamond switches as in the Mayer-Vietoris pyramid presented
in [8]. Individual switches are atomic tools that help us to show equivalence of barcodes, but we do
not need to actually execute them in computation. Instead, we go straight to the ﬁnal form of the
ﬁltration quite easily and eﬃciently. Finally, we observe that any zigzag ﬁltration can be treated as
a non-repetitive cell-wise ﬁltration of a ∆-complex [20] consisting of multisets of input simplices.
This means that each repeatedly added simplex is treated as a diﬀerent cell in the ∆-complex, so
that we can apply our ﬁndings for non-repetitive ﬁltrations to arbitrary ﬁltrations. The conversions
described above are detailed in Section 3.

1.1 Related works

Zigzag persistence is essentially an An-type quiver [14] in mathematics which is ﬁrst introduced to
the TDA community by Carlsson and de Silva [6]. In their paper [6], Carlsson and de Silva also
study the Mayer-Vietoris diamond used in this paper and propose an algorithm for computing zigzag
barcodes from zigzag modules (i.e., an input is a sequence of vector spaces connected by linear
maps encoded as matrices). Carlsson et al. [8] then propose an O(mn2) algorithm for computing

1

(a)

(b)

(c)

(d)

Figure 1: Examples of ∆-complexes with two triangles sharing 0, 1, 2, or 3 edges on their boundaries.

zigzag barcodes from zigzag ﬁltrations using a structure called right ﬁltration. In their paper [8],
Carlsson et al. also extend the classical sublevelset ﬁltrations for functions on topological spaces by
proposing levelset zigzag ﬁltrations and show the equivalence of levelset zigzag with the extended
persistence proposed by Cohen-Steiner et al. [12]. Maria and Outdot [22, 23] propose an alternative
algorithm for computing zigzag barcodes by attaching a reversed standard ﬁltration to the end of the
partial zigzag ﬁltration being scanned. Their algorithm maintains the barcode over the Surjective
and Transposition Diamond on the constructed zigzag ﬁltration [22, 23]. Maria and Schreiber [24]
propose a Morse reduction preprocessing for zigzag ﬁltrations which speeds up the zigzag barcode
computation. Carlsson et al. [9] discuss some matrix factorization techniques for computing zigzag
barcodes from zigzag modules, which, combined with a divide-and-conquer strategy, lead to a parallel
algorithm for computing zigzag persistence. Almost all algorithms reviewed so far have a cubic
time complexity. Milosavljevi´c et al. [25] establish an O(mω) theoretical complexity for computing
zigzag persistence from ﬁltrations, where ω < 2.37286 is the matrix multiplication exponent [1].
Recently, Dey and Hou [15] propose near-linear algorithms for computing zigzag persistence from
the special cases of graph ﬁltrations, with the help of representatives deﬁned for the intervals and
some dynamic graph data structures.

2 Preliminaries

∆-complex.
In this paper, we build ﬁltrations on ∆-complexes which are extensions of simplicial
complexes described in Hatcher [20]. These ∆-complexes are derived from a set of standard simplices
by identifying the boundary of each simplex with other simplices while preserving the vertex orders.
For distinction, building blocks of ∆-complexes (i.e., standard simplices) are called cells. Motivated
by a construction from the input simplicial complex described in Algorithm 3.1, we use a more
restricted version of ∆-complexes, where boundary cells of each p-cell are identiﬁed with distinct
(p − 1)-cells. Notice that this makes each p-cell combinatorially equivalent to a p-simplex. Hence, the
diﬀerence of the ∆-complexes in this paper from the standard simplicial complexes is that common
faces of two cells in the ∆-complexes can have more relaxed forms. For example, in Figure 1, two
‘triangles’ (2-cells) in a ∆-complex having the same set of vertices can either share 0, 1, 2, or 3 edges
in their boundaries; note that the two triangles in Figure 1d form a 2-cycle.

Formally, we deﬁne ∆-complexes recursively similar to the classical deﬁnition of CW-complexes [20]
though it need not be as general; see Hatcher’s book [20] for a more general deﬁnition. Note that
simplicial complexes are trivially ∆-complexes and therefore most deﬁnitions in this section target
∆-complexes.

Deﬁnition 1. A ∆-complex is deﬁned recursively with dimension:

1. A 0-dimensional ∆-complex K0 is a set of points, each called a 0-cell.

2

2. A p-dimensional ∆-complex Kp, p ≥ 1, is a quotient space of a (p − 1)-dimensional ∆-complex
Kp−1 along with several standard p-simplices. The quotienting is realized by an attaching map
h : ∂(σ) → Kp−1 which identiﬁes the boundary ∂(σ) of each p-simplex σ with points in Kp−1 so
that h is a homeomorphism onto its image. We term the standard p-simplex σ with boundary
identiﬁed to Kp−1 as a p-cell in Kp. Furthermore, we have that the restriction of h to each
proper face of σ is a homeomorphism onto a cell in Kp−1.

Notice that the original (more general) ∆-complexes [20] require specifying vertex orders when
identifying the cells. However, the restricted ∆-complexes deﬁned above do not require specifying
such orders because we always identify the boundaries of cells by homeomorphisms and hence the
vertex orders for identiﬁcation are implicitly derived from a vertex order of a seeding cell.

Homology. Homology in this paper is deﬁned on ∆-complexes, which is deﬁned similarly as for
simplicial complexes [20]. All homology groups are taken with Z2-coeﬃcients and therefore vector
spaces mentioned in this paper are also over Z2.

Zigzag ﬁltration and barcode. A zigzag ﬁltration (or simply ﬁltration) is a sequence of ∆-
complexes

F : K0 ↔ K1 ↔ · · · ↔ Km,
in which each Ki ↔ Ki+1 is either a forward inclusion Ki (cid:44)→ Ki+1 or a backward inclusion
Ki ←(cid:45) Ki+1. For computational purposes, we only consider cell-wise ﬁltrations in this paper, i.e.,
each inclusion Ki ↔ Ki+1 is an addition or deletion of a single cell; such an inclusion is sometimes
denoted as Ki

σ←→ Ki+1 with σ indicating the cell being added or deleted.

We call F as non-repetitive if whenever a cell σ is deleted from F, the cell σ is never added
again. We call F an up-down ﬁltration [8] if F can be separated into two parts such that the ﬁrst
part contains only forward inclusions and the second part contains only backward ones, i.e., F is of
the form F : K0 (cid:44)→ K1 (cid:44)→ · · · (cid:44)→ K(cid:96) ←(cid:45) K(cid:96)+1 ←(cid:45) · · · ←(cid:45) Km. Usually in this paper, ﬁltrations start
and end with empty complexes, e.g., K0 = Km = ∅ in F.

Applying the p-th homology functor on F induces a zigzag module:

Hp(F) : Hp(K0) ↔ Hp(K1) ↔ · · · ↔ Hp(Km),

in which each Hp(Ki) ↔ Hp(Ki+1) is a linear map induced by inclusion. It is known [6, 19] that
Hp(F) has a decomposition of the form Hp(F) (cid:39) (cid:76)
k∈Λ I [bk,dk], in which each I [bk,dk] is a special
type of zigzag module called interval module over the interval [bk, dk]. The (multi-)set of intervals
denoted as Persp(F) := {[bk, dk] | k ∈ Λ} is an invariant of F and is called the p-th barcode of F.
Each interval in Persp(F) is called a p-th persistence interval and is also said to be in dimension p.
Frequently in this paper, we consider the barcode of F in all dimensions Pers∗(F) := (cid:70)
p≥0 Persp(F).
Deﬁnition 2 (Open and closed birth/death). For a zigzag ﬁltration F : ∅ = K0 ↔ K1 ↔ · · · ↔
Km = ∅, the start of any interval in Pers∗(F) is called a birth index in F and the end of any interval
is called a death index. Moreover, a birth index b is said to be closed if Kb−1 (cid:44)→ Kb is a forward
inclusion; otherwise, b is open. Symmetrically, a death index d is said to be closed if Kd ←(cid:45) Kd+1 is
a backward inclusion; otherwise, d is open. The types of the birth/death ends classify intervals in
Pers∗(F) into four types: closed-closed, closed-open, open-closed, and open-open.

Remark 3. If F is a levelset zigzag ﬁltration [8], then the open and closed ends deﬁned above are
the same as for levelset zigzag.

Remark 4. An inclusion Ki ↔ Ki+1 in a cell-wise ﬁltration either provides i + 1 as a birth index
or provides i as a death index (but cannot provide both).

3

Mayer-Vietoris diamond. The algorithm in this paper draws upon the Mayer-Vietoris diamond
proposed by Carlsson and de Silva [6] (see also [7, 8]), which relates barcodes of two ﬁltrations
diﬀering by a local change:

Deﬁnition 5 (Mayer-Vietoris diamond [6]). Two cell-wise ﬁltrations F and F (cid:48) are related by a
Mayer-Vietoris diamond if they are of the following forms (where σ (cid:54)= τ ):

F :

F (cid:48) :

K0

· · ·

Kj−1

Kj

σ

τ

τ

σ

K(cid:48)
j

Kj+1

· · ·

Km

(1)

In the above diagram, F and F (cid:48) diﬀer only in the complexes at index j and F (cid:48) is derived from F by
switching the addition of σ and deletion of τ . We also say that F (cid:48) is derived from F by an outward
switch and F is derived from F (cid:48) by an inward switch.

Remark 6. In Equation (1), we only provide a speciﬁc form of Mayer-Vietoris diamond which is
suﬃcient for our purposes; see [6, 8] for a more general form. According to [6], the diamond in
Equation (1) is a Mayer-Vietoris diamond because Kj = Kj−1 ∪ Kj+1 and K(cid:48)

j = Kj−1 ∩ Kj+1.

We then have the following fact:

Theorem 7 (Diamond Principle [6]). Given two cell-wise ﬁltrations F, F (cid:48) related by a Mayer-
Vietoris diamond as in Equation (1), there is a bijection from Pers∗(F) to Pers∗(F (cid:48)) as follows:

Pers∗(F)

Pers∗(F (cid:48))

[b, j − 1]; b ≤ j − 1

(cid:55)→ [b, j]

[b, j]; b ≤ j − 1

(cid:55)→ [b, j − 1]

[j, d]; d ≥ j + 1

(cid:55)→ [j + 1, d]

[j + 1, d]; d ≥ j + 1

(cid:55)→ [j, d]

[j, j] of dimension p

(cid:55)→ [j, j] of dimension p − 1

[b, d]; all other cases

(cid:55)→ [b, d]

Note that the bijection preserves the dimension of the intervals except for [j, j].

Remark 8. In the above bijection, only an interval containing some but not all of {j − 1, j, j + 1}
maps to a diﬀerent interval or diﬀerent dimension.

3 FastZigzag algorithm

In this section, we show that computing barcodes for an arbitrary zigzag ﬁltration of simplicial
complexes can be reduced to computing barcodes for a certain non-zigzag ﬁltration of ∆-complexes.
The resulting algorithm called FastZigzag is more eﬃcient considering that standard (non-zigzag)
persistence admits faster algorithms [2, 3, 4, 5, 10, 11, 29] in practice. We conﬁrm the eﬃciency
with experiments in Section 3.5.

4

Figure 2: The ∆-complex resulting from performing an inward switch around ˆK4 for the example
shown in Figure 5.

3.1 Overview

Given a simplex-wise zigzag ﬁltration

F : ∅ = K0

σ0←−→ K1

σ1←−→ · · ·

σm−1←−−−→ Km = ∅

of simplicial complexes as input, the FastZigzag algorithm has the following main procedure:

1. Convert F into a non-repetitive zigzag ﬁltration of ∆-complexes.

2. Convert the non-repetitive ﬁltration to an up-down ﬁltration.

3. Convert the up-down ﬁltration to a non-zigzag ﬁltration with the help of an extended persistence

ﬁltration.

4. Compute the standard persistence barcode, which is then converted to the barcode for the input

ﬁltration based on rules given in Proposition 15 and 19.

Step 1 is achieved by simply treating each repeatedly added simplex in F as a new cell in the
converted ﬁltration (see also [25]). Throughout the section, we denote the converted non-repetitive,
cell-wise ﬁltration as

ˆσ0←−→ ˆK1

ˆF : ∅ = ˆK0

ˆσm−1←−−−→ ˆKm = ∅.

ˆσ1←−→ · · ·
Notice that each ˆKi in ˆF is homeomorphic to Ki in F, and hence Pers∗(F) = Pers∗( ˆF). However,
we get an important diﬀerence between F and ˆF by treating the simplicial complexes as ∆-complexes.
For example, in Figure 5 presented later in this section, the ﬁrst addition of edge c in F corresponds
to a cell c0 in ˆF and its second addition in F corresponds to a cell c1. Performing an inward switch
c1(cid:44)−−→) turns ˆK4 into a ∆-complex as shown in Figure 2. However,
around ˆK4 (switching
we cannot perform such a switch in F which consists of simplicial complexes, because diamond
switches require the switched simplices or cells to be diﬀerent (see Deﬁnition 5).

c0←−−(cid:45) and

In Section 3.2 and 3.3, we provide details for Step 2 and 3 as well as propositions for converting
barcodes mentioned in Step 4. We summarize the ﬁltration converting process in Section 3.4 by
providing pseudocodes (Algorithm 3.1) and examples (Figure 5 and 6).

3.2 Conversion to up-down ﬁltration
Proposition 9. For the ﬁltration ˆF, there is a cell-wise up-down ﬁltration

U : ∅ = L0 (cid:44)→ L1 (cid:44)→ · · · (cid:44)→ Ln ←(cid:45) Ln+1 ←(cid:45) · · · ←(cid:45) L2n = ∅

derived from ˆF by a sequence of inward switches. Note that m = 2n.

5

abc0c1Proof. Let ˆKi
That is, ˆF is of the form

ˆσi←−−(cid:45) ˆKi+1 be the ﬁrst deletion in ˆF and ˆKj

ˆσj
(cid:44)−−→ ˆKj+1 be the ﬁrst addition after that.

ˆF : ˆK0 (cid:44)→ · · · (cid:44)→ ˆKi

ˆσi←−−(cid:45) ˆKi+1

ˆσi+1

←−−−(cid:45) · · ·

ˆσj−2
←−−−(cid:45) ˆKj−1

ˆσj−1
←−−−(cid:45) ˆKj

ˆσj
(cid:44)−−→ ˆKj+1 ↔ · · · ↔ ˆKm.

Since ˆF is non-repetitive, we have ˆσj−1 (cid:54)= ˆσj. So we can switch
switch) to derive a ﬁltration

ˆσj−1

←−−−(cid:45) and

ˆσj

(cid:44)−−→ (which is an inward

ˆK0 (cid:44)→ · · · (cid:44)→ ˆKi

ˆσi←−−(cid:45) ˆKi+1

ˆσi+1

←−−−(cid:45) · · ·

ˆσj−2
←−−−(cid:45) ˆKj−1

ˆσj
(cid:44)−−→ ˆK(cid:48)
j

ˆσj−1
←−−−(cid:45) ˆKj+1 ↔ · · · ↔ ˆKm.

We then continue performing such inward switches (e.g., the next switch is on
derive a ﬁltration

ˆσj−2

←−−−(cid:45) and

ˆσj

(cid:44)−−→) to

ˆF (cid:48) : ˆK0 (cid:44)→ · · · (cid:44)→ ˆKi

ˆσj
(cid:44)−−→ ˆK(cid:48)

i+1

ˆσi←−−(cid:45) · · ·

ˆσj−3
←−−−(cid:45) ˆK(cid:48)

j−1

ˆσj−2
←−−−(cid:45) ˆK(cid:48)
j

ˆσj−1
←−−−(cid:45) ˆKj+1 ↔ · · · ↔ ˆKm.

Note that from ˆF to ˆF (cid:48), the up-down ‘preﬁx’ grows longer. We can repeat the above operations on
the newly derived ˆF (cid:48) until the entire ﬁltration turns into an up-down one.

Throughout the section, let

U : ∅ = L0

τ0(cid:44)−−→ · · ·

τn−1

(cid:44)−−−→ Ln

τn←−−(cid:45) · · ·

τ2n−1
←−−−−(cid:45) L2n = ∅

be the up-down ﬁltration for ˆF as described in Proposition 9, where m = 2n. We also let ˆK = Ln.
In a cell-wise ﬁltration, for a cell σ, let its addition (insertion) be denoted as ↓σ and its deletion
(removal) be denoted as ↑σ. From the proof of Proposition 9, we observe the following: during the
transition from ˆF to U, for any two additions ↓σ and ↓σ(cid:48) in ˆF (and similarly for deletions), if ↓σ is
before ↓σ(cid:48) in ˆF, then ↓σ is also before ↓σ(cid:48) in U. We then have the following fact:

Fact 10. Given the ﬁltration ˆF, to derive U, one only needs to scan ˆF and list all the additions
ﬁrst and then the deletions, following the order in ˆF.

Remark 11. Figure 3 gives an example of ˆF and its corresponding U, where the additions and
deletions in ˆF and U follow the same order.

Deﬁnition 12 (Creator and destroyer). For any interval [b, d] ∈ Pers∗( ˆF), if ˆKb−1
forward (resp. backward), we call ↓ˆσb−1 (resp. ↑ˆσb−1) the creator of [b, d]. Similarly, if ˆKd
is forward (resp. backward), we call ↓ˆσd (resp. ↑ˆσd) the destroyer of [b, d].

ˆσb−1←−−→ ˆKb is
ˆσd←−→ ˆKd+1

By inspecting the interval mapping in the Diamond Principle, we have the following fact:

Proposition 13. For two cell-wise ﬁltrations L, L(cid:48) related by a Mayer-Vietoris diamond, any
two intervals of Pers∗(L) and Pers∗(L(cid:48)) mapped by the Diamond Principle have the same set of
creator and destroyer, though the creator and destroyer may swap. This observation combined with
Proposition 9 implies that there is a bijection from Pers∗(U) to Pers∗( ˆF) s.t. every two corresponding
intervals have the same set of creator and destroyer.

Remark 14. The only time when the creator and destroyer swap in a Mayer-Vietoris diamond is
when the interval [j, j] for the upper ﬁltration in Equation (1) turns into the same interval (of one
dimension lower) for the lower ﬁltration.

6

Figure 3: An example of ﬁltration ˆF and its corresponding up-down ﬁltration U. For brevity, ˆF
does not start and end with empty complexes (which can be treated as a truncated case).

Consider the example in Figure 3 for an illustration of Proposition 13. In the example, [1, 2] ∈
Pers1( ˆF) corresponds to [1, 4] ∈ Pers1(U), where their creator is ↓a and their destroyer is ↑d.
Moreover, [4, 6] ∈ Pers0( ˆF) corresponds to [4, 5] ∈ Pers1(U). The creator of [4, 6] ∈ Pers0( ˆF) is ↑e
and the destroyer is ↓c. Meanwhile, [4, 5] ∈ Pers1(U) has the same set of creator and destroyer but
the roles swap.

For any ↓σ or ↑σ in ˆF, let id ˆF (↓σ) or id ˆF (↑σ) denote the index (position) of the addition or
ˆσi
(cid:44)−−→ ˆKi+1 in ˆF, id ˆF (↓ˆσi) = i. Proposition 13 indicates

deletion. For example, for an addition ˆKi
the following explicit mapping from Pers∗(U) to Pers∗( ˆF):

Proposition 15. There is a bijection from Pers∗(U) to Pers∗( ˆF) which maps each [b, d] ∈ Persp(U)
by the following rule:

Type

Condition

Type

closed-open

open-closed

closed-closed

-

-

(cid:55)→ closed-open

(cid:55)→ open-closed

id ˆF (↓τb−1) < id ˆF (↑τd)
id ˆF (↓τb−1) > id ˆF (↑τd)

(cid:55)→ closed-closed

(cid:55)→ open-open

Interval in Pers∗( ˆF)
(cid:2)id ˆF (↓τb−1) + 1, id ˆF (↓τd)(cid:3)
(cid:2)id ˆF (↑τb−1) + 1, id ˆF (↑τd)(cid:3)
(cid:2)id ˆF (↓τb−1) + 1, id ˆF (↑τd)(cid:3)
(cid:2)id ˆF (↑τd) + 1, id ˆF (↓τb−1)(cid:3)

Dim

p

p

p

p−1

Remark 16. Notice that Pers∗(U) contains no open-open intervals. However, a closed-closed interval
[b, d] ∈ Persp(U) turns into an open-open interval in Persp−1( ˆF) when id ˆF (↓τb−1) > id ˆF (↑τd). Such
a change happens when a closed-closed interval turns into a single point interval [j, j] during the
sequence of outward switches, after which the closed-closed interval [j, j] becomes an open-open
interval [j, j] with a dimension shift (see Theorem 7).

Remark 17. Although it may take O(m2) diamond switches to go from ˆF to U or from U to ˆF as
indicated in Proposition 9, we observe that these switches do not need to be actually executed in
the algorithm. To convert the intervals in Pers∗(U) to those in Pers∗( ˆF), we only need to follow the
mapping in Proposition 15, which takes constant time per interval.

7

ˆK0ˆK1ˆK2ˆK3ˆK4ˆK6L0L1L2L3L4L5L6L7ˆK7ˆK5a֒−→v֒−→b֒−→c֒−→d←−֓e←−֓b←−֓a֒−→v֒−→d←−֓e←−֓b֒−→b←−֓c֒−→ˆF:U:vabcavavavavabvavacavavabvabcvabcvabcvacdedededededeedededeeWe can take the example in Figure 3 for the mapping in Proposition 15. The interval [4, 5] ∈
Pers1(U) is a closed-closed one whose creator is ↓c and destroyer is ↑e. We have that id ˆF (↓c) = 6 >
id ˆF (↑e) = 3. So the corresponding interval in Pers0( ˆF) is

[id ˆF (↑e) + 1, id ˆF (↓c)] = [4, 6].

3.3 Conversion to non-zigzag ﬁltration

We ﬁrst convert the up-down ﬁltration U to an extended persistence [12] ﬁltration E, which is then
easily converted to an (absolute) non-zigzag ﬁltration using the ‘coning’ technique [12].

Inspired by the Mayer-Vietoris pyramid in [8], we relate Pers∗(U) to the barcode of the ﬁltration

E deﬁned as:

E : ∅ = L0 (cid:44)→ · · · (cid:44)→ Ln = ( ˆK, L2n) (cid:44)→ ( ˆK, L2n−1) (cid:44)→ · · · (cid:44)→ ( ˆK, Ln) = ( ˆK, ˆK)

where Ln = ˆK = ( ˆK, L2n = ∅). When denoting the persistence intervals of E, we let the increasing
index for the ﬁrst half of E continue to the second half, i.e., ( ˆK, L2n−1) has index n + 1 and ( ˆK, Ln)
has index 2n. Then, it can be veriﬁed that an interval [b, d] ∈ Pers∗(E) for b < n < d starts with the
complex Lb and ends with ( ˆK, L3n−d).

Remark 18. A ﬁltration in extended persistence [12] is originally deﬁned for a PL function f ,
where the ﬁrst half is the lower-star ﬁltration of f and the second half (the relative part) is derived
from the upper-star ﬁltration of f . The ﬁltration E deﬁned above is a generalization of the one
in [12].

Proposition 19. There is a bijection from Pers∗(E) to Pers∗(U) which maps each [b, d] ∈ Pers∗(E)
of dimension p by the following rule:

Type Condition

Type

Interv. in Pers∗(U) Dim

Ord

Rel

Ext

d < n

b > n

(cid:55)→ closed-open

[b, d]

(cid:55)→ open-closed

[3n − d, 3n − b]

b ≤ n ≤ d

(cid:55)→ closed-closed [b, 3n − d − 1]

p

p−1

p

Remark 20. The types ‘Ord’, ‘Rel’, and ‘Ext’ for intervals in Pers∗(E) are as deﬁned in [12],
which stand for intervals from the ordinary sub-barcode, the relative sub-barcode, and the extended
sub-barcode.

Remark 21. The above proposition can also be stated by associating the creators and destroyers as
in Proposition 13 and 15. The association of additions in the ﬁrst half of U and E is straightforward
and the deletion of a σ in U is associated with the addition of σ (to the second complex in the pair)
in E. Then, corresponding intervals in Pers∗(E) and Pers∗(U) in the above proposition also have the
same set of creators and destroyers. Combined with Proposition 13, we further have that intervals in
Pers∗(F) and Pers∗(E) can be associated by a bijection where corresponding intervals have the same
pairs of simplices though they may switch roles of being creators and destroyers. These switches
coincide with the shift in the degree of the homology by having an interval in Persp(E) correspond
to an interval in Persp−1(F).

8

(L4, L4)

τ4

(L4, L5)

τ5

E

(L4, L6)

τ6

(L4, L7)

τ7

(L4, L8)

τ4

τ4

τ4

τ4

(L5, L5)

τ5

(L5, L6)

τ6

(L5, L7)

τ7

(L5, L8)

τ5

τ5

τ5

(L6, L6)

τ6

(L6, L7)

τ7

(L6, L8)

U

τ6

τ6

(L7, L7)

τ7

(L7, L8)

τ7

(L8, L8)

Figure 4: A Mayer-Vietoris pyramid relating the second half of E and U for n = 4.

Proof. We can build a Mayer-Vietoris pyramid relating the second half of E and the second half
of U similar to the one in [8]. A pyramid for n = 4 is shown in Figure 4, where the second half of
E is along the left side of the triangle and the second half of U is along the bottom. In Figure 4,
we represent the second half of E and U in a slightly diﬀerent way considering that L4 = ˆK and
L8 = ∅. Also, each vertical arrow indicates the addition of a simplex in the second complex of the
pair and each horizontal arrow indicates the deletion of a simplex in the ﬁrst complex.

To see the correctness of the mapping, we ﬁrst note that each square in the pyramid is a (more
general version of) Mayer-Vietoris diamond as deﬁned in [8]. Then, the mapping stated in the
proposition can be veriﬁed using the Diamond Principle (Theorem 7). However, there is a quicker
way to verify the mapping by observing the following: corresponding intervals in Pers∗(E) and
Pers∗(U) have the same set of creator and destroyer if we ignore whether it is the addition or deletion
of a simplex. For example, an interval in Pers∗(E) may be created by the addition of a simplex σ
in the ﬁrst half of E and destroyed by the addition of another simplex σ(cid:48) in the second half of E.
Then, its corresponding interval in Pers∗(U) is also created by the addition of σ in the ﬁrst half but
destroyed by the deletion of σ(cid:48) in the second half. Note that the dimension change for the case
b > n is caused by the swap of creator and destroyer.

By Proposition 15 and 19, we only need to compute Pers∗(E) in order to compute Pers∗(F). The
barcode of E can be computed using the ‘coning’ technique [12], which converts E into an (absolute)
non-zigzag ﬁltration ˆE. Speciﬁcally, let ω be a vertex diﬀerent from all vertices in ˆK. For a p-cell σ
of ˆK, we let ω · σ denote the cone of σ, which is a (p + 1)-cell having cells {σ} ∪ {ω · τ | τ ∈ ∂σ} in
its boundary. The cone ω · Li of a complex Li consists of three parts: the vertex ω, Li, and cones of
all cells of Li. The ﬁltration ˆE is then deﬁned as [12]:

ˆE : L0 ∪ {ω} (cid:44)→ · · · (cid:44)→ Ln ∪ {ω} = ˆK ∪ ω · L2n (cid:44)→ ˆK ∪ ω · L2n−1 (cid:44)→ · · · (cid:44)→ ˆK ∪ ω · Ln

We have that Pers∗(E) equals Pers∗( ˆE) discarding the only inﬁnite interval [12]. Note that if a cell σ
is added (to the second complex) from ( ˆK, Li) to ( ˆK, Li−1) in E, then the cone ω · σ is added from
ˆK ∪ ω · Li to ˆK ∪ ω · Li−1 in ˆE.

9

3.4 Summary of ﬁltration conversion

We summarize the ﬁltration conversion process described in this section in Algorithm 3.1, in which
we assume that each simplex in F is given by its set of vertices. The converted standard ﬁltration ˆE
is represented by its boundary matrix D, whose columns (and equivalently the chains they represent)
are treated as sets of identiﬁers of the boundary cells. Algorithm 3.1 also maintains the following
data structures:

• cid denotes the map from a simplex σ to the identiﬁer of the most recent copy of cell corresponding

to σ.

• del list denotes the list of cell identiﬁers deleted in the input ﬁltration.

• cone id denotes the map from the identiﬁer of a cell to that of its coned cell.

Algorithm 3.1 Pseudocode for converting input ﬁltration

1: procedure ConvertFilt(F)
2:

initialize boundary matrix D, cell-id map cid, deleted cell list del list as empty
append an empty column to D representing vertex ω for coning

id ← 1
for each Ki

σi←→ Ki+1 in F do
if σi is being inserted then

cid[σi] = id
col ← CellBoundary(σi, cid)
append col to D
id ← id + 1

else

append cid[σi] to del list

(cid:46) variable keeping track of id for cells

(cid:46) get a new cell as a copy of simplex σi

initialize map cone id as empty
for each del id in del list (accessed reversely) do

cone id[del id] ← id
col ← ConedCellBoundary(del id, D, cone id)
append col to D
id ← id + 1

return D

(cid:46) cone id tracks id for coned cells

(cid:46) get a new coned cell

3:

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

19:

Subroutine CellBoundary in Line 8 converts boundary simplices of σi to a column of cell
identiﬁers based on the map cid. Subroutine ConedCellBoundary in Line 16 returns boundary
column for the cone of the cell identiﬁed by del id.

We provide an example of the up-down cell-wise ﬁltration U built from a given simplex-wise
ﬁltration F in Figure 5. In the example, edge c and triangle t are repeatedly added twice in F, and
therefore each correspond to two copies of cells in U. We provide another example of a complete
conversion from a given zigzag ﬁltration to a non-zigzag ﬁltration in Figure 6.

With the ConvertFilt subroutine, Algorithm 3.2 provides a concise summary of FastZigzag.
Given that for a ﬁltration F of length m, ConvertFilt takes O(m) time and ConvertBarcode
takes O(1) time per bar, we now have the following conclusion:

10

Figure 5: An example of an up-down cell-wise ﬁltration U built from a given simplex-wise ﬁltration
F. For brevity, F does not start and end with empty complexes. The ﬁnal conversion to ˆE is not
shown for this example due to page-width constraint. A complete conversion for a smaller example
is shown in Figure 6.

Figure 6: An example of converting a zigzag ﬁltration ˆF to a non-zigzag ﬁltration.

Algorithm 3.2 Pseudocode for FastZigzag

1: procedure FastZigzag(F)
2:

D ← ConvertFilt(F)
B ← ComputeBarcode(D)
B(cid:48) ← ConvertBarcode(B)
return B(cid:48)

3:

4:

5:

11

K0L0c0֒−→c֒−→F:U:abK1t֒−→abcK2t←−֓abctK3c←−֓abcK4c֒−→K5t֒−→abcK6cababL1t0֒−→abc0L3t1֒−→abc0t0c1L4t0←−֓abc0t0c1L2c1֒−→abc0t0L5c0←−֓ab0c1L6abt1c1ˆK2ˆK3ˆK4ˆK5ˆK6ˆK7ˆK8e0e1e0e0e1ωv0v1v0v1v0v1v0v1v0v1v0e0e1v0v1ωv0v1ωe1ωωe0e0֒−→e1֒−→ω·v0֒−−→ω·v1֒−−→ω·e1֒−−→ω·e0֒−−→e0֒−→e1֒−→e0←−֓e1←−֓v1←−֓v0←−֓e0֒−→e0←−֓e1֒−→e1←−֓v1←−֓v0←−֓L2L3L4L5L6L7L8ωωe0ˆF:U:ˆE:L2∪{ω}L3∪{ω}L4∪{ω}ˆK∪ω·L7ˆK∪ω·L6ˆK∪ω·L5ˆK∪ω·L4Theorem 22. Given a simplex-wise zigzag ﬁltration F with length m, FastZigzag computes
Pers∗(F) in time T (m) + O(m), where T (m) is the time used for computing the barcode of a
non-zigzag cell-wise ﬁltration with length m.
Remark 23. Theoretically, T (m) = O(mω) [25], where ω < 2.37286 is the matrix multiplication
exponent [1]. So the theoretical complexity of FastZigzag is O(mω).

3.5 Experiments

We implement the FastZigzag algorithm described in this section and compare the performance
with Dionysus2 [26] (implementing the algorithm in [8]) and Gudhi∗ [28] (implementing the
algorithm in [22, 24]). When implementing FastZigzag, we utilize the Phat [4] software for
computing non-zigzag persistence. Our implementation is publicly available through: https:
//github.com/taohou01/fzz.

To test the performance, we generate eleven simplex-wise ﬁltrations of similar lengths (5∼6
millions; see Table 1). The reason for using ﬁltrations of similar lengths is to test the impact of
repetitiveness on the performance for diﬀerent algorithms, where repetitiveness is the average times
a simplex is repeatedly added in a ﬁltration (e.g., repetitiveness being 1 means that the ﬁltration is
non-repetitive). We utilize three diﬀerent approaches for generating the ﬁltrations:
• The two non-repetitive ﬁltrations (No. 1 and 2) are generated by ﬁrst taking a simplicial complex
with vertices in R3, and then taking the height function h along a certain axis. After this, we
build an up-down ﬁltration for the complex where the ﬁrst half is the lower-star ﬁltration of
h and the second half is the (reversed) upper-star ﬁltration of h. We then randomly perform
outward switches on the up-down ﬁltration to derive a non-repetitive ﬁltration. Note that the
simplicial complex is derived from a triangular mesh supplemented by a Vietoris-Rips complex on
the vertices; one triangular mesh (Dragon) is downloaded from the Stanford Computer Graphics
Laboratory.

• Filtration No. 3 – 8 are generated from a sequence of edge additions and deletions, for which we
then take the clique complex (up to a certain dimension) for each edge set in the sequence. The
edge sequence is derived by randomly adding and deleting edges for a set of points.

• The remaining ﬁltrations (No. 9 – 11) are the oscillating Rips zigzag [27] generated from point
clouds of size 2000 – 4000 sampled from some triangular meshes (Space Shuttle from an online
repository†; Bunny and Dragon from the Stanford Computer Graphics Laboratory).

Table 1 lists running time of the three algorithms on all ﬁltrations, where the length, maximum
dimension (D), repetitiveness (Rep), and maximum complex size (MaxK) are also provided for
each ﬁltration. From Table 1, we observe that FastZigzag (TFZZ) consistently achieves the best
running time across all inputs, with signiﬁcant speedups (see column ‘SU’ in Table 1). The speedup
is calculated as the min-time of Dionysus2 and Gudhi divided by the time of FastZigzag. Notice
that since Gudhi only takes a sequence of edge additions and deletions as input (and builds clique
complexes on-the-ﬂy), we do not run Gudhi on the ﬁrst two inputs in Table 1, which are only
given as simplex-wise ﬁltrations. We also observe that the speedup of FastZigzag tends to be
less prominent as the repetitiveness increases. This is because higher repetitiveness leads to smaller
max/average complex size in the input zigzag ﬁltration, so that algorithms directly working on the
input ﬁltration could have less processing time [8, 22, 24]. On the other hand, the complex size in
the converted non-zigzag ﬁltration that FastZigzag works on is always increasing.

∗The code is shared by personal communication.
†Ryan Holmes: http://www.holmes3d.net/graphics/offfiles/

12

Table 1: Running time of Dionysus2, Gudhi, and FastZigzag on diﬀerent ﬁltrations of similar
lengths with various repetitiveness. All tests were run on a desktop with Intel(R) Core(TM) i5-9500
CPU @ 3.00GHz, 16GB memory, and Linux OS.

No.

Length

D Rep

MaxK

TDio2

TGudhi

TFZZ

SU

1

2

3

4

5

6

7

8

9

10

11

5,260,700

5,254,620

5,539,494

5,660,248

5,327,422

5,309,918

5,357,346

6,058,860

5,135,720

5,110,976

5,811,310

5

4

5

4

4

3

3

4

3

3

4

1.0

883,350

2h02m46.0s

1.0

1,570,326

19m36.6s

−

−

8.9s

11.0s

873

107

1.3

1,671,047

3h05m00.0s

45m47.0s

3m20.8s

13.7

2.0

1,385,979

2h59m57.0s

29m46.7s

4m59.5s

3.5

5.1

7.3

9.1

21.9

27.7

44.2

760,098

43m54.8s

10m35.2s

3m32.1s

523,685

5h46m03.0s

1h32m37.0s

19m30.2s

368,830

3h37m54.0s

57m28.4s

30m25.2s

331,211

53m21.2s

7m19.0s

3m44.4s

11,859

11,435

7,782

23.8s

36.2s

38.5s

15.6s

39.9s

36.9s

8.6s

8.5s

23.9s

6.0

3.0

4.7

1.9

2.0

1.9

4.3

1.5

Table 2 lists the memory consumption of the three algorithms. We observe that FastZigzag
tends to consume more memory than the other two on the non-repetitive ﬁltrations (No. 1 and 2)
and the random clique ﬁltrations (No. 3 – 8). However, FastZigzag is consistently achieving the
best memory footprint on the oscillating Rips ﬁltrations (No. 9 – 11) despite the high repetitiveness.

Table 2: Memory consumption (in gigabytes) of the three algorithms on all ﬁltrations.

No.

Length

Rep

MaxK MDio2 MGudhi MFZZ

5,260,700

1.0

883,350

5,254,620

1.0

1,570,326

3.23

3.93

−

−

5,539,494

1.3

1,671,047

15.52

13.49

0.59

0.61

9.76

5,660,248

2.0

1,385,979

1

2

3

4

5

6

7

8

9

5,327,422

5,309,918

5,357,346

6,058,860

3.5

5.1

7.3

9.1

5,135,720

21.9

10

11

5,110,976

27.7

5,811,310

44.2

7.64

3.27

4.94

4.03

2.12

0.92

0.88

0.95

8.43

11.04

3.40

6.22

5.27

10.23

3.91

1.48

0.47

0.48

0.60

8.19

3.68

0.50

0.47

0.51

760,098

523,685

368,830

331,211

11,859

11,435

7,782

13

4 Conclusions

In this paper, we propose a zigzag persistence algorithm called FastZigzag by ﬁrst treating
repeatedly added simplices in an input zigzag ﬁltration as distinct copies and then converting the
input ﬁltration to a non-zigzag ﬁltration. The barcode of the converted non-zigzag ﬁltration can
then be easily mapped back to barcode of the input zigzag ﬁltration. The eﬃciency of our algorithm
is conﬁrmed by experiments. This research also brings forth the following open questions:

• Parallel versions [9, 29] of the algorithms for computing standard and zigzag exist. While
the computation of standard persistence in our FastZigzag algorithm can directly utilize
the existing parallelization techniques, we ask if the conversions done in FastZigzag can be
eﬃciently parallelized. Such an extension can provide further speedups by harnessing multi-cores.

• While persistence intervals are important topological descriptors, their representatives also reveal
critical information (e.g., a recently proposed algorithm [16] for updating zigzag barcodes over
local changes uses representatives explicitly). Can the FastZigzag algorithm be adapted so
that representatives for the input zigzag ﬁltration are recovered from representatives for the
converted non-zigzag ﬁltration?

Acknowledgment:

We thank the Stanford Computer Graphics Laboratory and Ryan Holmes for providing the triangular
meshes used in the experiment of this paper.

References

[1] Josh Alman and Virginia Vassilevska Williams. A reﬁned laser method and faster matrix
multiplication. In Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms
(SODA), pages 522–539. SIAM, 2021.

[2] Ulrich Bauer. Ripser: Eﬃcient computation of vietoris–rips persistence barcodes. Journal of

Applied and Computational Topology, 5(3):391–423, 2021.

[3] Ulrich Bauer, Michael Kerber, and Jan Reininghaus. Clear and compress: Computing persistent
homology in chunks. In Topological methods in data analysis and visualization III, pages 103–117.
Springer, 2014.

[4] Ulrich Bauer, Michael Kerber, Jan Reininghaus, and Hubert Wagner. Phat – persistent

homology algorithms toolbox. Journal of Symbolic Computation, 78:76–90, 2017.

[5] Jean-Daniel Boissonnat, Tamal K. Dey, and Cl´ement Maria. The compressed annotation matrix:
An eﬃcient data structure for computing persistent cohomology. Algorithmica, 73(3):607–619,
2015.

[6] Gunnar Carlsson and Vin de Silva. Zigzag persistence. Foundations of Computational Mathe-

matics, 10(4):367–405, 2010.

[7] Gunnar Carlsson, Vin de Silva, Sara Kaliˇsnik, and Dmitriy Morozov. Parametrized homology

via zigzag persistence. Algebraic & Geometric Topology, 19(2):657–700, 2019.

14

[8] Gunnar Carlsson, Vin de Silva, and Dmitriy Morozov. Zigzag persistent homology and real-
valued functions. In Proceedings of the Twenty-Fifth Annual Symposium on Computational
Geometry, pages 247–256, 2009.

[9] Gunnar Carlsson, Anjan Dwaraknath, and Bradley J. Nelson. Persistent and zigzag homology:

A matrix factorization viewpoint. arXiv preprint arXiv:1911.10693, 2019.

[10] Chao Chen and Michael Kerber. Persistent homology computation with a twist. In Proceedings
27th European Workshop on Computational Geometry, volume 11, pages 197–200, 2011.

[11] Chao Chen and Michael Kerber. An output-sensitive algorithm for persistent homology. Comput.

Geom.: Theory and Applications, 46(4):435–447, 2013.

[12] David Cohen-Steiner, Herbert Edelsbrunner, and John Harer. Extending persistence using
Poincar´e and Lefschetz duality. Foundations of Computational Mathematics, 9(1):79–103, 2009.

[13] Vin de Silva, Dmitriy Morozov, and Mikael Vejdemo-Johansson. Dualities in persistent

(co)homology. Inverse Problems, 27(12):124003, 2011.

[14] Harm Derksen and Jerzy Weyman. Quiver representations. Notices of the AMS, 52(2):200–206,

2005.

[15] Tamal K. Dey and Tao Hou. Computing zigzag persistence on graphs in near-linear time. In
37th International Symposium on Computational Geometry, SoCG 2021, volume 189 of LIPIcs,
pages 30:1–30:15. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2021.

[16] Tamal K. Dey and Tao Hou. Updating zigzag persistence and maintaining representatives over

changing ﬁltrations. arXiv preprint arXiv:2112.02352, 2021.

[17] Tamal K. Dey, Woojin Kim, and Facundo M´emoli. Computing generalized rank invariant for 2-
parameter persistence modules via zigzag persistence and its applications. In 38th International
Symposium on Computational Geometry, SoCG 2022, volume 224 of LIPIcs, pages 34:1–34:17,
2022.

[18] Herbert Edelsbrunner, David Letscher, and Afra Zomorodian. Topological persistence and
simpliﬁcation. In Proceedings 41st Annual Symposium on Foundations of Computer Science,
pages 454–463. IEEE, 2000.

[19] Peter Gabriel. Unzerlegbare Darstellungen I. Manuscripta Mathematica, 6(1):71–103, 1972.

[20] Allen Hatcher. Algebraic Topology. Cambridge University Press, 2002.

[21] Petter Holme and Jari Saram¨aki. Temporal networks. Physics Reports, 519(3):97–125, 2012.

[22] Cl´ement Maria and Steve Y. Oudot. Zigzag persistence via reﬂections and transpositions. In
Proceedings of the Twenty-Sixth Annual ACM-SIAM Symposium on Discrete Algorithms, pages
181–199. SIAM, 2014.

[23] Cl´ement Maria and Steve Y. Oudot. Computing zigzag persistent cohomology. arXiv preprint

arXiv:1608.06039, 2016.

[24] Cl´ement Maria and Hannah Schreiber. Discrete morse theory for computing zigzag persistence.

In Workshop on Algorithms and Data Structures, pages 538–552. Springer, 2019.

15

[25] Nikola Milosavljevi´c, Dmitriy Morozov, and Primoz Skraba. Zigzag persistent homology in
In Proceedings of the Twenty-Seventh Annual Symposium on

matrix multiplication time.
Computational Geometry, pages 216–225, 2011.

[26] Dmitriy Morozov. Dionysus2. URL: https://www.mrzv.org/software/dionysus2/.

[27] Steve Y. Oudot and Donald R. Sheehy. Zigzag zoology: Rips zigzags for homology inference.

Foundations of Computational Mathematics, 15(5):1151–1186, 2015.

[28] The GUDHI Project. GUDHI User and Reference Manual. GUDHI Editorial Board, 2015.

URL: http://gudhi.gforge.inria.fr/doc/latest/.

[29] Simon Zhang, Mengbai Xiao, and Hao Wang. GPU-accelerated computation of Vietoris-Rips
persistence barcodes. In 36th International Symposium on Computational Geometry (SoCG
2020). Schloss Dagstuhl-Leibniz-Zentrum f¨ur Informatik, 2020.

[30] Afra Zomorodian and Gunnar Carlsson. Computing persistent homology. Discrete & Computa-

tional Geometry, 33(2):249–274, 2005.

16

