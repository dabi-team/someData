MANDO: Multi-Level Heterogeneous Graph Embeddings for
Fine-Grained Detection of Smart Contract Vulnerabilities

Hoang H. Nguyen†, Nhat-Minh Nguyen‡, Chunyao Xie†, Zahra Ahmadi†, Daniel Kudendo†,
Thanh-Nam Doan§, Lingxiao Jiang‡
†L3S Research Center, Leibniz Universit¨at Hannover, Hannover, Germany
‡Singapore Management University, Singapore
§Independent Researcher, Atlanta, Georgia, USA
{ehoang,xie,ahmadi,kudendo}@l3s.de, {nmnguyen,lxjiang}@smu.edu.sg, me@tndoan.com

2
2
0
2

p
e
S
7

]
E
S
.
s
c
[

2
v
2
5
2
3
1
.
8
0
2
2
:
v
i
X
r
a

Abstract—Learning heterogeneous graphs consisting of differ-
ent types of nodes and edges enhances the results of homogeneous
graph techniques. An interesting example of such graphs is
control-ﬂow graphs representing possible software code execution
ﬂows. As such graphs represent more semantic information of
code, developing techniques and tools for such graphs can be
highly beneﬁcial for detecting vulnerabilities in software for its
reliability. However, existing heterogeneous graph techniques are
still insufﬁcient in handling complex graphs where the number
of different types of nodes and edges is large and variable. This
paper concentrates on the Ethereum smart contracts as a sample
of software codes represented by heterogeneous contract graphs
built upon both control-ﬂow graphs and call graphs containing
different types of nodes and links. We propose MANDO, a new
heterogeneous graph representation to learn such heterogeneous
contract graphs’ structures. MANDO extracts customized meta-
paths, which compose relational connections between different
types of nodes and their neighbors. Moreover,
it develops a
multi-metapath heterogeneous graph attention network to learn
multi-level embeddings of different types of nodes and their
metapaths in the heterogeneous contract graphs, which can
capture the code semantics of smart contracts more accurately
and facilitate both ﬁne-grained line-level and coarse-grained
contract-level vulnerability detection. Our extensive evaluation of
large smart contract datasets shows that MANDO improves the
vulnerability detection results of other techniques at the coarse-
grained contract level. More importantly, it is the ﬁrst learning-
based approach capable of identifying vulnerabilities at the ﬁne-
grained line-level, and signiﬁcantly improves the traditional code
analysis-based vulnerability detection approaches by 11.35% to
70.81% in terms of F1-score.

Index Terms—heterogeneous graphs, graph embedding, graph
contracts,

neural networks, vulnerability detection,
Ethereum blockchain

smart

I. INTRODUCTION

Graph learning has been an active research area for a long
time. Learning heterogeneous graphs that consist of nodes
and edges of different types has recently attracted extensive
attention since such graphs contain richer information from the
application domains than homogeneous graphs and, therefore,
can achieve better learning results [1]. However, when it
comes to complex heterogeneous graphs, where the graph

Acknowledgment. This work was supported by the European Union’s
Horizon 2020 research and innovation program under grant agreement No.
833635 (project ROXANNE: Real-time network, text, and speaker analytics
for combating organized crime, 2019-2022) and by the Singapore Ministry of
Education (MOE) Academic Research Fund (AcRF) Tier 1 grant.

structures have particular properties and the number of node
types and edge types can be arbitrarily large and changing,
it is still unclear if existing techniques can handle them well.
Examples of such graphs can be found in control-ﬂow graphs
or call graphs representing possible software code execution
ﬂows and call relations. A control-ﬂow graph depicts all
possible sequences of statements or lines of code that might
be traversed in one function during program executions. In
contrast, a call graph represents every possible call relation
among functions in a program.

This paper aims to develop a new approach for learning
such complex and dynamic heterogeneous graphs and apply
them to address critical software quality assurance problems,
such as detecting vulnerabilities in software code that can be
represented as control-ﬂow graphs and call graphs. Expressly,
we represent software code as a combination of heterogeneous
graphs of multiple granularity levels that capture the control-
ﬂow and call relations in code. Then, we extract specially
deﬁned metapaths for such graphs that acquire relations be-
tween different types of nodes and their neighbors, and fuse
various kinds of graph neural networks together to learn both
of the node-level and graph-level embeddings. Further, we
use the embeddings to train networks to recognize graphs
or nodes that may contain vulnerabilities and thus identify
the vulnerable code functions or lines. Last but not least, we
apply our approach to the Ethereum smart contracts written
in the Solidity programming language. We choose smart
contracts from distributed blockchains [2] as they become
increasingly popular in various domains that involve payments
and contracts. Different techniques are essential to detect their
potential bugs and ensure correct executions of the payments
and contracts. In short, our approach enables novel multi-
level graph embeddings for ﬁne-grained detection of smart
contract vulnerabilities, and thus we name it as MANDO.
in its graph neural network structure
MANDO is novel
that fuses topological GNN and node-level attentions with
heterogeneous GNN to generate both node-level and graph-
level embeddings that can capture structural information of
graphs more accurately. It is also novel in enabling both node-
level and graph-level classiﬁcations to detect ﬁne-grained line-
level vulnerabilities in smart contract source code in addition
to coarse-grained contract-level vulnerabilities.

 
 
 
 
 
 
Fig. 1: A sample Ethereum smart contract code snippet (Part A), its corresponding heterogeneous call graph (CG) (Part B), and a sample
heterogeneous control-ﬂow graph (CFG) for the function CashOut in the contract PrivateBank (Part C). Line 15 in Part A is the root
cause of a Reentrancy bug; the nodes in CG and CFG containing the Reentrancy bug are highlighted with red text

.

For our empirical evaluation, we have curated a mixed
dataset containing 493 Solidity vulnerable contracts from mul-
tiple data sources from previous studies. There are seven types
of vulnerabilities in the dataset; each has between 50 to 80
instances. Our evaluation results show that MANDO achieves
a heightened F1-score from 81.98% to 90.51% for detecting
the vulnerabilities at the ﬁne-grained line-level, while previous
deep learning and embedding-based techniques can only detect
the vulnerabilities at the contract ﬁle/function level. We also
show that, compared to a few different graph embedding
models (such as node2vec [3], LINE [4], GCN [5], and
metapath2vec [6]) and traditional program analysis techniques
(such as Securify [7], Mythril [8], Slither [9], Manticore [10],
Smartcheck [11], and Oyente [12]) that can detect vulnerabil-
ities at the line level, our method improves their F1-score by
11.35% to 70.81% for various bug types.

To summarize, our main contributions are as follows:

• We propose a new technique for representing Ethereum
smart contracts written in Solidity as heterogeneous contract
graphs that combines heterogeneous control-ﬂow graphs
(CFGs) and call graphs (CGs) of multiple levels of granular-
ity. This new technique allows us to represent the semantic
relation of node and edge types that the previous approaches
could not capture with only using the homogeneous forms
of these CFGs and CGs separately.

• We propose a novel architecture for the Heterogeneous
Graph Neural Network using Node-Level Attention (Fig-
ure 2 and 3), which ﬁts our customized metapaths, to build
embeddings of multiple granularity levels for heterogeneous
contract graphs.

• We employ the multi-level embeddings of heterogeneous
graphs and labeled instances of vulnerable smart contracts
to detect new vulnerabilities accurately at the line-level and

contract-level, achieving better results than prior state-of-
the-art bug detection techniques for smart contracts.

• We also publicize the dataset and our graph embedding

models for the research community1.
The rest of the paper is organized as follows: Section II
deﬁnes our main research problem and objective with a
motivating example. Section III describes the detailed structure
of MANDO. Section IV presents the experimental settings
and results to show the effectiveness of our method. Section V
reviews the related studies. Section VI concludes our paper
with some discussions on its limitations and future outlook.

II. MOTIVATION AND PROBLEM DEFINITION

Motivating Example: Figure 1 (Part A) shows a sample
code snippet of a smart contract written in Solidity. Part B
shows the corresponding call graph (CG) of the contract.
Part C shows a partial sample control-ﬂow graph (CFG) for
the CashOut function containing a vulnerability whose root
cause is at Line 15 as msg.sender.call can repeatedly
trigger calls to CashOut before balances is deducted at
Line 16, which means msg.sender can receive more values
than what is speciﬁed by _am. In order to catch this so-called
reentrance vulnerability, the control-ﬂow and call relations
among msg.sender, balances, and _am should be con-
sidered. We aim to automatically capture such vulnerabilities’
properties via our new graph embedding techniques.

Problem Statement: Our high-level problem is to develop
more effective heterogeneous graph learning techniques, and
use them to detect ﬁne-grained line-level software vulnera-
bilities and their types. More speciﬁcally, our objective for
smart contracts written in Solidity based on our unique graph
representation and embedding techniques is to: (1) Represent

1https://github.com/MANDO-Project/ge-sc

1    pragma solidity ^0.4.19; 2 3    contract PrivateBank { 4          mapping (address => uint) public balances; 5           uint public MinDeposit = 1 ether; 6            Log TransferLog; 7 8            function Deposit() public payable { 9                  if(msg.value >= MinDeposit) { 10                     balances[msg.sender]+=msg.value; 11                     TransferLog.AddMessage(msg.sender,msg.value,"Deposit"); } } 12   13           function CashOut(uint _am) { 14               if(_am<=balances[msg.sender]) {             15                    if(msg.sender.call.value(_am)()) { 16                        balances[msg.sender]-=_am; 17                        TransferLog.AddMessage(msg.sender,_am,"CashOut"); } } } 18    } 19 20    contract Log { 21           struct Message {address Sender; string  Data; uint Val; uint  Time;} 22           Message[] public History; 23           Message LastMsg; 24           function AddMessage(address _adr,uint _val,string _data) public { 25                  LastMsg.Sender = _adr; 26                  LastMsg.Time = now; 27                  LastMsg.Val = _val; 28                  LastMsg.Data = _data; 29                  History.push(LastMsg); } 30    } Part APart BPart CTrue edgeFalse edgeNext edgeENTRY_POINT NodeEXPRESSION NodeIF NodeEND_IF NodeFUNCTION_NAME NodePrivateBankDepositCashOutExternal_CallExternal_CallAddMessageLogPrivateBankNode Type: IF Expression: _am <= balance[mgs.sender]PrivateBank_CashOutNode Type: IF Expression: msg.sender.call.value(_am)()Node Type: EXPRESSION EXPRESSION: balance[msg.sender] -= _amNode Type: EXPRESSION Expression: TransferLog.AddMessage(msg.sender,_am,CashOut)Node Type: ENTRY_POINTNode Type: END_IFNode Type: END_IFFig. 2: Overview of the MANDO framework.

it as a heterogeneous contract graph that combines its control-
ﬂow graph and call graph like the example in Figure 1; (2)
Learn the embeddings of the graphs and the nodes at multiple
levels of granularity to capture the syntactical and semantic
information of smart contract code; (3) Accurately identify the
nodes that contain certain types of vulnerabilities and locate
them in the contract code.

Usage Scenarios: Such accurate vulnerability detection can
be useful for smart contract quality assurance under various
situations. For example:
• During the contract development in an Integrated Develop-
ment Environment (IDE), it can help to identify early if the
contract contains any vulnerability of known types.

• When a developer is reusing a contract from a third party,
the vulnerability detection can check if it contains any
known vulnerabilities and warns the developer about po-
tential risks in reusing the contract directly.

• Whenever a new type of vulnerability is discovered, we
may want to audit all existing contracts again to check if
they contain the new type of vulnerability. The vulnerability
detection can then be easily applied to all the contracts on
a large scale for this purpose.

We believe that MANDO can be adapted to other software as
long as their control-ﬂow and call graphs can be constructed
and there are vulnerability datasets available for training.

III. THE MANDO APPROACH

A. Overview

This section gives an overview of our proposed approach
consisting of four main components presented in the four
grey boxes in Figure 2 and describe each component in the
following subsections. The input of our approach is the source
code of one or many Ethereum smart contract source ﬁles
written in Solidity. The output is the bug prediction and the
bug line in the source code if there is one.

First, the source code is processed by the Heterogeneous
Contract Graph Generator component and translated into
two heterogeneous graphs based on call graphs and control-
ﬂow graphs corresponding to two levels of granularity: con-

tract level and statement (line) level, respectively. Then, the
two heterogeneous graphs are fed into the second component:
Multi-Metapaths Extractor. Based on the type of each node
and the types of its associated edges, the component extracts
their corresponding metapaths. This component is novel in
the sense that it can handle dynamic numbers of node and
edge types in metapaths from the automatically generated
heterogeneous contract graphs. The third component, Multi-
Level Graph Neural Networks, contains two steps. The ﬁrst
step takes metapaths or graph topology of the contract graphs
from the previous component as input and generates node
embeddings. Then, in the second step, the node embeddings
are used as node features and fused with metapaths using
heterogeneous attention mechanisms at the node level. Two-
Phase Vulnerability Detector, the last component, uses the
embeddings to train multi-layer perceptron (MLP) to perform
either graph classiﬁcation or node classiﬁcation, depending
on the kind of the input heterogeneous contract graphs.
In Coarse-Grained Detection,
the heterogeneous contract
graphs embeddings are used to classify graphs if their re-
is clean or vulnerable. In Fine-Grained
spective contract
Detection, the heterogeneous contract graphs embeddings of
the vulnerable contracts, classiﬁed in the ﬁrst phase, are used
to classify a node of a contract graph as to whether it is clean
or vulnerable. The classiﬁed nodes can then be used to ﬁnd
the exact locations of the vulnerabilities in speciﬁc contracts
(i.e., contract-level) and speciﬁc statements or lines of code
(i.e., line-level).

B. Heterogeneous Contract Graph Generator

Our approach uses Slither [9] to traverse and analyze the
source code of each Ethereum smart contract for generating the
basic control-ﬂow graphs and call graphs with homogeneous
structures where nodes and edges have no types or labels.
Then, we transform these constructed graphs into heteroge-
neous forms to represent the semantics of graph structures
and the relation of different node and edge types:

Deﬁnition III-B.1 (Heterogeneous Graph). A heterogeneous

Control FlowGraphsCall GraphsHeterogeneous ContractGraph GeneratorHeterogeneousRepresentationHeterogeneousControl-Flow GraphsMulti-Metapaths ExtractorHeterogeneousCall Graphs Metapath Metapath ...Topological GraphNeural NetworkNodeEmbeddingsNode-Level Attention HeterogeneousGraph Neural NetworkNode Features Metapath Self-Attention Layerper NodeType Self-Attention Layerper NodeType Metapath Metapath Metapath  Node Embeddingsper NodeType Node Embeddingsper NodeType Multi-LayerPerceptron............Ethereum Smart Contract Source CodesGraph Structure Multi-Level Graph Neural Networks Graph Classification for Heterogeneous  Contract GraphsPhase 1: Coarse-GrainedDetection Phase 2: Fine-GrainedDetection Node Classification for Heterogeneous  Contract GraphsClean SmartContracts Buggy SmartContracts Clean Lines inSmart ContractSource Codes Buggy Lines inSmart ContractSource Codes Two-Phase Vulnerability Detector HeterogeneousGraphs FusionHeterogeneousContract Graphs graph is a directed graph G = (V, E, φ, ψ), consisting of a
vertex set V and an edge set E. φ : V → A is a node-type
mapping function and ψ : E → R is an edge-type mapping
function. A and R denote the sets of node types and edge
types, and |A| ≥ 2 and |R| ≥ 1.

Heterogeneous Control-Flow Graphs

(HCFGs). A
control-ﬂow graph of a function is an intermediate repre-
sentation of all possible sequences of statements or lines of
code that might be traversed when the function is executed,
which is widely used in program analysis methods. Recent
approaches on smart contract vulnerability detection use such
graph representations of code when applying graph neural
networks [13], [14], but they mostly normalize and convert
those representations into homogeneous graphs before apply-
ing graph models. In particular, they only keep the major nodes
and eliminate some normal nodes to normalize graphs since
using nodes of diverse code semantics brings difﬁculties in
training their graph neural networks. Thus, these approaches
tend to lose valuable information regarding the source code
semantics in smart contracts. In contrast, MANDO focuses
on retaining most of the structure and semantics of the source
code through heterogeneous representations where a variety of
node types and edge types are preserved, called heterogeneous
control-ﬂow graphs.

The set of all node types in control-ﬂow graphs is denoted
as ACF . Some typical node types include ENTRY POINT,
EXPRESSION, NEW VARIABLE, RETURN, IF, END IF,
IF LOOP, and END LOOP. Additionally, diverse types of
connections among nodes are used to describe statements’
sequential or branching structure through edge types such
as NEXT, TRUE, FALSE. The set of all edge types in
control-ﬂow graphs is RCF . Figure 1 (Part C) shows a
sample heterogeneous control-ﬂow graph generated for the
CashOut function of contract PrivateBank. A Solidity parser
(e.g., Slither) produces the complete sets of ACF and RCF
based on the grammar of the Solidity language. GCF =
{VCF , ECF , φCF , ψCF } denotes an HCFG with VCF and
ECF as its vertex and edge sets, respectively. Each node
i ∈ VCF can be viewed as a tuple of (i, φi
CF ), where i is the
index of node and φi
CF ∈ ACF is the type of node i. Similarly,
each edge (i, j) ∈ ECF has an edge type ψi,j
CF ∈ RCF . Each
function in a smart contract can have an HCFG generated for
it, and the HCFG has an entry node corresponding to the entry
point/header of the function. A smart contract may be viewed
as a set of HCFGs as it may contain more than one function.
Heterogeneous Call Graphs (HCGs). Call graphs are
an intermediate representation of invocation relations among
functions from the same smart contract or different smart
contracts. A call graph generated via static program analysis
often represents every possible call relation among functions
in a program. Our study focuses on two major types of calls
in smart contracts: internal calls for function calls inside one
smart contract and external calls for function calls from a
contract to others, represented by the two respective edge
types INTERNAL CALL and EXTERNAL CALL. In addi-

tion, Solidity fallback functions are important in Ethereum
blockchain, executed when a function identiﬁer does not
match any of the available functions in a smart contract or
if no suitable data was provided for the function call. Many
vulnerabilities in Ethereum smart contracts are directly or
indirectly related to such fallback functions [15]. Therefore,
we represent such fallback functions with a particular node
type, called FALLBACK NODE, besides the typical function
node type FUNCTION NAME.

One HCG is generated from each smart contract. GC =
{VC, EC, φC, ψC} denotes a heterogeneous call graph with
VC and EC as its node and edge sets, respectively. Each node
i in VC can be viewed as a tuple (i, φi
C) where i is the index
of node, φi
C ∈ AC is the type of the node i and AC is the set
of all node types in GC. Similarly, each edge (i, j) ∈ EC has
an associate edge type ψi,j
C ∈ RC.

Heterogeneous Contract Graphs: Fusion of Hetero-
geneous Call Graphs and Heterogeneous Control-Flow
Graphs. The structures of these two graphs for a smart
contract can be shared or combined into a global graph to
enrich information for learning. In MANDO, we design a
core for HCGs and HCFGs fusion. Accordingly, the HCG
edges of the smart contract act as bridges to link the discrete
HCFGs of the smart contract functions into a global fused
graph. Speciﬁcally, the fusion graph of the heterogeneous CG
and the heterogeneous CFGs for a smart contract is denoted
by GF usion = {VF , EF , φF , ψF }, where VF = VC ∪ V 1
CF ∪
... ∪ V N
CF , and N is number
of the HCFGs for the contract. Intuitively, for each and every
function node i in the call graph, the function control-ﬂow
graph Gi
CF is attached to the function node i at the entry
node of Gi
CF , and thus the call graph is expanded with control-
ﬂow graphs to produce the heterogeneous contract graph. For
example, in Figure 1, the red arrow between CashOut in
Part B and PrivateBank_CashOut in Part C indicates a
sample fusion between CGs and CFGs.

CF and EF = EC ∪ E1

CF ∪ ... ∪ EN

C. Multi-Metapaths Extractor

R1−−→ A2

Deﬁnition III-C.1 (Metapath). A metapath θ is a path in
R2−−→ ... Rl−→ Al+1, which deﬁnes a
the form of A1
composite relation R = R1 ◦ R2 ◦ ... ◦ Rl between type A1 and
Al+1, and ◦ denotes the composition operator on relations.
Note that, the length of θ is the number of relations in θ.

The number of node type in our generated graphs is
dynamic, and can reach sixteen, with three distinct connection
types per node type, especially in the heterogeneous control-
ﬂow graphs. Pre-deﬁning all possible metapaths with any
length according to all possible node types and edge types is a
challenge, as it would lead to exponential explosion of meta-
paths, increased data sparsity, and reduced training accuracy.
For example, in Figure 1, between a node of ENTRY POINT
type and a node of EXPRESSION type, several different
node types can be included, such as IF and END IF, and
in other smart contracts, NEW VARIABLE, IF LOOP, and
END LOOP can also be included. Besides, the order of these

graph topology, while the latter weights the importance of the
metapaths in the graph.

1) Topological Graph Neural Network: The main goal of
this building block is to capture the graph topology. Each node
i has a node embedding ei such that ei and the embedding
vector ej of the neighboring nodes j of i are near in the
embedding space. Various state-of-the-art neural network tech-
niques can be used to generate node embeddings of graphs.
For a more comprehensive comparison of their effectiveness,
we employ both embedding techniques for homogeneous
graphs (e.g., node2vec [3]) and embedding techniques for
heterogeneous graphs (e.g., metapath2vec [6]) in our empirical
evaluation (see Section IV).

2) Node-Level Attention Heterogeneous Graph Neural Net-
work: There are two kinds of input sources for this building
block: the node embeddings from the previous topological
graph neural network and the metapaths from the Multi-
Metapaths Extractor.

Node-Level Attention Graph Neural Network. Inspired
by the node-level attention mechanism proposed by HAN [1],
we also learn to weigh the importance of every metapath and
node. However, unlike HAN, our novel approach can handle
multiple dynamic customized metapaths without pre-deﬁning
the list of input metapaths (see Figure 3 and the summary of
notations in Table I). The previous topological graph neural
network produces a node embedding eφk
for each node i
i
whose type is φk; then, we construct a corresponding weighted
node feature e(cid:48)φk

by the following linear transformation:

i

i

,

(1)

e(cid:48)φk
i = Wφk eφk
where Wφk is the transformation matrix associated to the type
φk of node i. Each node type φk has a speciﬁc matrix Wφk
to increase the ﬂexibility of the transformation by projecting
each type into a separated weight space.

We measure the weight of the t-th metapath Φφk
t

according
to the node type φk of (i, j) pair by leveraging the self-
φk
attention mechanism [17] between i and j. The weight aΦ
t
ij
is deﬁned as follows:
aΦ
ij = softmaxj(ATT([e(cid:48)φk

, e(cid:48)φk
j

]; Φφk

t )),

(2)

φk
t

i

i

and e(cid:48)φk

where ATT is a multi-layer perceptron [18] whose values of pa-
rameters are automatically learned through back-propagation.
The input of such perceptron is the concatenation of two
vectors e(cid:48)φk
. We then normalize the output of ATT
into the range between 0 and 1 by all neighbors of j in
metapaths. The t-th metapath embedding M φk
of node i
it
whose node type is φk is a weighted sum of the node
features of its neighbors with corresponding weights deﬁned
in Equation (2). The formula is as follows:

j

M φk
it

= σ






(cid:88)

Φk
j∈N
i



φk
aΦ
t
ij

· e(cid:48)φk
j


 ,

(3)

where σ is the activation function, and N Φk
neighbors of the node i according to the metapath Φk.

i

denotes the

Fig. 3: Our Novel Architecture for Node-Level Attention Heteroge-
neous Graph Neural Network in the MANDO Framework.

Notation
i
φk
eφk
i
e(cid:48)φk
i
Wφk
Φφk
t
M φk
it
M φk
i
N φk
Jk

Explanation
Node i
Node type k
Node embedding of i whose type is φk
Linear transformation of eφk
Matrix transformation for node i with type φk
t-th metapath of node type φk
t-th metapath embedding of node i whose node type is φk
Embedding of node type φk of node i
A set of metapath of node type φk
Total index of node type φk

i

TABLE I: Table of Notation

node types can change dynamically, depending on the input
contracts’ structures.

In order to address the problem of exploding and changing
metapaths, our method focuses on length-2 metapaths through
reﬂective connections between adjacent nodes to extract multi-
ple metapaths. For instance, the relation between two adjacent
nodes of the types ENTRY POINT and IF in Figure 1 can be
described by a length-2 metapath: EN T RY P OIN T next−−−→
IF back−−−→ EN T RY P OIN T . HCFGs are mostly tree-like,
having very few of their own back-edges induced by the
LOOP-related statements in the source code. This can lead
to the lack of metapaths connecting many leaf-node types in
the graphs. Adding the “back” relations helps alleviate the lack
and improves the completeness of the extracted metapaths.

Previous studies [1], [16] also used length-2 in their evalu-
ation, and a length-N metapath can be decomposed into (N -
1) length-2 metapaths. Thus, we follow those studies by using
length-2 to capture the unique semantic between each node
types pair and their neighbors and leave longer metapaths for
future evaluations. Similar to the methods used in HAN [1],
we extract the set of length-2 metapaths of each node types
pair in a smart contract.

D. Multi-Level Graph Neural Networks

This component has two major building blocks: Topological
Graph Neural Network and Node-Level Attention Heteroge-
neous Graph Neural Network. The former learns an input

AVG...NodeAttention NodeAttention AVGMLPNode  type  Node  type  .....................Metapaths  ...Metapaths  To overcome the obstacle of high variance of data in
heterogeneous graphs, we propose to aggregate multi-metapath
embeddings with different types of nodes. Particularly, the
metapath embedding M φk
of each node in Equation (3) is
it
calculated N times and then concatenated to create a ﬁnal
embedding M (cid:48)φk
it

for each metapath.

After extracting the metapath embedding, we calculate the
corresponding embedding of node i by averaging all metapath
embedding related to i, noted AVG in Figure 3. Speciﬁcally,
the embedding of node i with node type φk is:

M φk

i =

(cid:80)

t M φk
it
|N φk |

,

(4)

where N φk is a set of metapaths of the node type φk, and the
total index of the node type φk is equal to the size of this set
i.e., |N φk |.

i

For ﬁne-grained detection, we concatenate all node embed-
ding M φk
corresponding to all node type φk of all node i to
generate a uniﬁed embedding vector for a node. We get the
average of all node embeddings belonging to the graph for
coarse-grained detection.

3) Optimization for Detection: We employ the multi-layer
perceptron (MLP) with a softmax activation function for the
graph and node classiﬁcation tasks. The input of such a layer
is dependent on the type of prediction tasks. The loss function
for the training process is cross-entropy, and the parameters
of our model are learned through back-propagation.

E. Two-Phase Vulnerability Detector

This component has two main phases: Coarse-Grained De-
tection and Fine-Grained Detection. The ﬁrst phase classiﬁes
clean versus vulnerable smart contracts at the coarse-grained
contract level; the second phase identiﬁes the actual locations
of the vulnerabilities in the smart contract source code at the
ﬁne-grained line level. Providing line-level locations of the
vulnerabilities is one of our primary contributions, while the
previous graph learning-based methods [13], [19] only report
vulnerabilities at the contract or function level.

1) Phase 1: Coarse-Grained Detection: This phase clas-
siﬁes if a smart contract contains a vulnerability. We use
the fused heterogeneous call graphs and control-ﬂow graphs
(i.e., heterogeneous contract graphs) and their embeddings
to represent each input smart contract, and train the MLP
(Section III-D3) to predict clean or vulnerable contracts. As
there can be many clean smart contracts, this classiﬁcation
assists in reducing the search space by ﬁltering out those clean
contracts and reducing noisy data before the second phase of
ﬁne-grained vulnerability detection at the line level.

2) Phase 2: Fine-Grained Detection: For the vulnerable
smart contracts identiﬁed in the ﬁrst phase, we apply node
classiﬁcation on the node embeddings of their Heterogeneous
Contract Graphs to identify the nodes that may contain vul-
nerabilities, which correspond to statements or lines of code
and allow us to detect the locations of the vulnerabilities at
the ﬁne-grained line level in smart contract source code.

IV. EMPIRICAL EVALUATION

This section presents our experimental settings and results
to answer these research questions: RQ1: The performance of
our models compared to several state-of-the-art baselines on
contract-level vulnerability classiﬁcation, and RQ2: The per-
formance of our models on line-level vulnerability detection.

A. Datasets

Our evaluation is carried out on a mixed dataset from three
datasets: (1) Smartbugs Curated [20], [21] is a collection of
vulnerable Ethereum smart contracts organized into nine types.
This dataset is one of the most used real datasets for research in
automated reasoning and testing of smart contracts written in
Solidity. It contains 143 annotated contracts having 208 tagged
vulnerabilities. (2) SolidiFI-Benchmark [22] is a synthetic
dataset of vulnerable smart contracts. There are 9369 injected
vulnerabilities in 350 distinct contracts, with seven different
vulnerability types. To ensure consistency in the evaluation, we
only focus on the seven types of vulnerabilities that are joint
in both datasets, including: Access Control, Arithmetic, Denial
of Service, Front Running Reentracy, Time manipulation, and
Unchecked Low Level Calls. (3) Clean Smart Contracts
from Smartbugs Wild [20], [21] is a collection of 47,398
unique smart contracts from the Ethereum network. Based on
the results of eleven integrated detection tools, the Smartbugs
framework reports 2,742 contracts that do not contain any
bugs, out of the 47,398 contracts. Thus, we use the 2,742
contracts as a set of clean contracts.

For the coarse-grained contract-level vulnerability classiﬁ-
cation tasks, we randomly take some smart contracts from the
clean set and then mix them with the Smartbugs Curated and
SolidiFi-Benchmark sets. We keep a ratio of 1:1 between clean
and buggy contracts since this helps us create more balanced
train/test sets for the tasks since there are only from 44 to
95 buggy contracts labeled per each bug type (see Table III).
For the ﬁne-grained line-level vulnerability detection tasks, we
use the dataset containing vulnerable smart contracts only, i.e.,
the union of SmartBugs Curated and SolidiFI-Benchmark sets.
We do not use other datasets such as the ones of Zhuang et
al. [13], Liu et al. [19] and eThor [23] because they do not
have ﬁne-grained line-level labels for the vulnerabilities.

Note that the Slither parser we use does not automatically
generate the clean or vulnerable labels for a node. Instead, the
nodes are labeled based on the lines of vulnerable code either
manually by Smartbugs authors or injected by the SolidiFI
tool. For example, Line 15 in Figure 1 contains a Reentrancy
bug labeled by Smartbugs; then, the nodes with red text in the
Heterogeneous CFG and CG are labeled vulnerable.

B. Comparison Methods

1) Comparison to Graph-based neural network Meth-
ods: We use the four state-of-the-art methods,
including:
node2vec [3] learns node embeddings by minimizing the cross-
entropy loss between the embedding of two nodes belonging to
the same random walk with negative sampling; LINE [4] only

differs from node2vec in the exact formulations of the loss
functions and optimizing strategies; Graph Convolutional Net-
work (GCN) [5] generalizes the convolutional neural network
by using the Laplacian matrix as a ﬁrst-order approximation
for the propagation among the layers of spectral graph con-
volutions; and metapath2vec [6] maximizes the likelihood of
retaining the structures and semantics of the node/edge labels
using the embedding of each node in heterogeneous graphs.
Note that the original architectures of node2vec, LINE, GCN,
and metapath2vec only focus on graph topology and do not
have any components to handle node features.

Although HAN [1] inspired some idea for our Node-Level
Attention Heterogeneous Graph Neural Network, our approach
has novelty in resolving the challenges of ﬁtting with the
customized metapaths that the original HAN model could not
handle effectively. In particular, HAN requires a predeﬁned
list of metapaths and each HAN model only serves one
or some predeﬁned node types. However,
the MANDO’s
Heterogeneous CFGs and CGs have dynamic types of nodes
and edges, leading to difﬁculties in predeﬁning metapaths like
the original HAN model, and thus we did not use HAN as a
baseline in our evaluation.

The output embeddings of the homogeneous and hetero-
geneous graph neural networks are used in two ways in our
evaluation. First, we use them directly as the baselines for
the coarse-grained graph classiﬁcation tasks and ﬁne-grained
node classiﬁcation tasks. Second, each of the graph neural
networks is plugged into MANDO as the topological graph
neural network. The generated embeddings are then considered
as the node features fed to MANDO’s Node-Level Attention
Heterogeneous Graph Neural Network. Besides, we use fully-
connected layers as the multi-layer perceptron in node and
graph classiﬁcation tasks. In addition,
the one-hot vectors
based on the Node-Type is also used as the node features,
which allows MANDO to perform independently without
relying on any added-in topological graph neural network.

Parameter Settings: The node embedding size is set to 128
for all models. We use adaptive learning rate from 0.0005 to
0.01 in coarse-grained tasks and from 0.0002 to 0.005 in ﬁne-
grained tasks when training. For each GAT layer [24] of each
metapath that feeds to the MANDO’s Self-Attention Layer per
Node Type, we set 8 multi-heads whose hidden size is 32. The
numbers of learning epochs of coarse-grained and ﬁne-grained
tasks are 50 and 100, respectively, to reach converging. For
node2vec, LINE, GCN, and metapath2vec, we use the authors’
recommended settings to ensure the highest performance.

2) Comparison with Conventional Detection Tools: We also
compare our method to six common smart contract vulnera-
bility detection tools based on traditional software engineering
approaches: Manticore [10] analyzes the symbolic execution
of smart contracts and binaries; Mythril [8] uses symbolic
execution, SMT solving, and taint analysis to ﬁnd out the se-
curity vulnerabilities of smart contracts; Oyente [12] analyzes
symbolic execution to detect bugs in the Ethereum blockchain;
Securify [7] can prove if the behavior of a smart contract is safe
or not according to given predicates and by checking its graph

dependencies; Slither [9] reduces the complexity of instruction
sets with the intermediate representation of Ethereum smart
contract called SlithIR, while retaining much of the semantic
to increase the accuracy of bug detection; Smartcheck [11]
converts smart contracts into XML-based representation and
ﬁnds possible bugs along executive paths.

C. Evaluation Metrics

Since our prediction results are based on binary classiﬁca-
tion of a node or a graph, we use F1-score and Macro-F1
scores to measure the prediction performance. The former is
a measure of a model’s performance by balancing between
precision and recall, while the latter is used to assess the
quality of problems with multiple binary labels or multiple
classes. In our evaluation,
the F1-score metric is used to
evaluate the models’ performance when ﬁnding vulnerabilities
in the graphs, and we also call it Buggy-F1. Macro-F1 is
considered to avoid biases in the clean and vulnerability labels.

D. Empirical Results

Table III shows the statistics of the mixed dataset. In the
initial experiments, we split the dataset into 60%/20%/20%
for the corresponding train/validation/test sets. However, some
bug types in our mixed dataset have less than 100 contracts,
which leads to a lack of enough samples for training. Besides,
we realized that the loss value remains stable after a ﬁxed
number of epochs (100 and 50 epochs for Fine-Grained for
Coarse-Grained tasks, respectively). Hence, we decided to
split the dataset to 70%/30% to increase the train/test set
sizes and maintain the vulnerable nodes’ ratio in each set
corresponding to the whole dataset. To get robust results for
each dataset, each embedding method, and each vulnerability
type, we run the experiment twenty times independently, each
time with a different random seed, and report the average
results. Besides, our approach shows impressive capabilities
in training and inference time. It takes around 30 seconds for
over ten thousand nodes and edges in the node classiﬁcation
task and under 10 seconds for about 100–200 contracts in the
graph classiﬁcation task. Also, it requires under 1 second for
all inferences.

1) Coarse-Grained Contract-Level Vulnerability Detection
(RQ1): In this experiment, we want to measure MANDO’s
performance with various node feature generator components
in detecting vulnerable smart contracts (see Section III-E1). It
illustrates the ﬂexibility of our method working with different
graph neural networks. Table II presents MANDO’s perfor-
mance via several different graph neural methods on various
vulnerability types. Accordingly, we have some observations:
• MANDO generally outperforms baseline GNNs in contract-
level detection. For instance, the Buggy-F1 and Macro-
F1 of MANDO are over 88.66%, while the maximum
performance of the baselines is 64.77% in detecting the
Front-Running vulnerability type.

• It is unclear which node feature generation method is the
best among the heterogeneous and homogeneous GNNs
and the node-type one-hot vectors. However, integrating

Methods

Heterogeneous GNN

metapath2vec

GCN

Homogeneous GNNs

LINE

MANDO with
Node Features
Generated by

node2vec

NodeType One
Hot Vectors

metapath2vec

GCN

LINE

node2vec

Metrics

Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1

Access
Control

62.90%
42.55%

Arithmetic

56.46%
46.32%

-
60.63%
-
48.45%
33.41%
61.45%
33.47%
40.88%
58.59%
62.63%
50.80%
48.83%
71.19% 66.85%
74.57% 71.04%
52.84%
57.70%
55.06%
55.60%
-
49.26%
-
52.75%
54.91%
65.12%
65.36%
70.15%
64.11%
55.71%
70.23%
64.70%

Denial of
Service

Front
Running

Reentrancy

Time
Manipulation

Unchecked Low
Level Calls

55.17%
44.49%

60.12%
45.65%
59.61%
35.77%
56.41%
40.63%
87.37%
86.68%
60.16%
64.12%
53.19%
60.26%
89.15%
89.46%
83.86%
83.40%

63.40%
43.03%

-
-
62.61%
34.29%
64.77%
46.08%
87.31%
85.65%
62.19%
64.80%
-
-
89.86%
88.66%
86.05%
84.95%

61.79%
47.26%

-
-
66.23%
37.91%
58.29%
45.80%
76.09%
75.80%
55.06%
60.96%
-
-
71.04%
74.97%
71.39%
72.31%

66.29%
45.94%

59.60%
46.60%
66.65%
40.84%
63.03%
46.78%
85.03%
83.35%
59.47%
57.74%
49.50%
57.31%
87.71%
86.41%
73.38%
74.36%

55.22%
49.05%

-
-
60.51%
40.08%
61.69%
49.91%
72.08%
74.52%
51.37%
55.58%
-
-
59.44%
66.16%
66.10%
71.02%

TABLE II: Average Performance Comparison of the Coarse-Grained Contract-Level Detection over 20 Runs. We use the Heterogeneous
Contract Graphs of both Clean and Buggy Smart Contracts as the MANDO framework inputs. Buggy- F1 means the F1-score of the buggy
graph label. ‘–’ denotes not applicable due to the insufﬁciency of GPU memory to handle the input graphs for the GCN model.

Bug Types

Access
Control
Arithmetic
Denial of
Service
Front
Running
Reentrancy
Time
Manipulation
Unchecked
Low Level
Calls

# Total / Buggy
Contracts

# Total
Nodes

# Total
Edges

# Buggy
Nodes

114 / 57

120 / 60

92 / 46

88 / 44

142 / 71

100 / 50

13014

17372

13968

22824

18898

16765

10721

14271

11997

19761

17614

15550

7500

10110

8280

10008

11238

10051

190 / 95

17756

14858

7583

TABLE III: Statistics of the Mixed Dataset

these types of GNNs inside MANDO outperforms all
the baselines. Hence, we believe that the architecture of
MANDO for combining different GNNs is suitable for
classifying vulnerable smart contracts.

• MANDO is reliable in determining whether an unknown
smart contract contains vulnerabilities, especially for the
vulnerability types of Denial of Service, Front Running, and
Time Manipulation with Buggy-F1 over 87.7%. MANDO
is highly compatible with different solidity versions based
on the Slither tool [9], and its trained models can be applied
in practice to audit newly-appeared smart contracts that
previous studies using graph learning [13], [14] have not
been able to do effectively (see Section V-A).
2) Fine-Grained Line-Level Vulnerability Detection (RQ2):
To help smart contract developers to locate vulnerabilities
more easily, vulnerability detectors should be able to identify
the vulnerabilities at the more ﬁne-grained line level (see Sec-
tion III-E2). In this experiment, we examine the performance
of our method with respect to various state-of-the-art methods
for line-level detection.

• Generally, MANDO outperforms conventional detection
tools signiﬁcantly. Remarkably, an improvement is up to
63.4% of MANDO compared to the best performance of the
tools in detecting Reentrancy bugs. We argue the signiﬁcant
improvement is from two sources: First, our constructed
heterogeneous graphs retain more CFGs’ aspects than other
analysis tools. Secondly, our node-level attention module is
ﬂexible enough for GNNs to learn the exact locations of
vulnerabilities within contracts.

• Our method beats the results of the baseline GNNs. Remark-
ably, the macro-F1 scores of the baseline GNNs are up to
60.5%, while our models can reach up to 80.78%. Hence,
it is evident modeling the smart contracts as Heterogeneous
Contract Graphs can beneﬁt vulnerability prediction.

• Conventional detection tools perform well

in detecting
arithmetic bugs. The phenomenon is reasonable since these
tools mostly use symbolic execution and such technique
is suitable for detecting arithmetic bugs [25]. However,
MANDO performance is still on par with the tools and
our future work will improve the graph models to learn
arithmetic operations better. Besides, some conventional
detection tools in Table IV barely work (with Buggy-
F1=0%) for some vulnerability types due to their intrinsic
limits in relying on predeﬁned expert patterns that could not
capture these vulnerabilities.

Expanded Experiments. We also ran the experiments in
Tables II and IV with only Heterogeneous CFGs and CGs
separately. Overall, these results are worse than the fusion form
in the heterogeneous contract graphs reported in the paper. The
expanded experiments can be found in our Git repository link.

V. RELATED WORKS

A. Graph Embedding Neural Networks

Table IV shows the performance of our method trained with
different models for Topological Graph Neural Network and
the baselines methods, including graph-based neural networks
and the conventional detection tools based on various software
engineering techniques. From the table, we observe:

A few studies have detected smart contract vulnerabilities
using neural network-based embedding techniques. Zhuang
et al. [13] represent each function’s syntactic and semantic
structures in smart contracts as a contract graph and propose
a degree-free graph convolutional neural network with ex-

Methods

securify

mythril

slither

manticore

smartcheck

oyente

Conventional
Detection Tools

Heterogeneous GNN

metapath2vec

GCN

Homogeneous GNNs

LINE

MANDO with
Node Features
Generated by

node2vec

NodeType One
Hot Vectors

metapath2vec

GCN

LINE

node2vec

Metrics

Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1

Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1
Buggy F1
Macro-F1

Access
Control

Arithmetic

Denial of
Service

Front
Running

Reentrancy

Time
Manipulation

Unchecked Low
Level Calls

13.0%
52.3%
34.0%
61.1%
32.0%
61.5%
30.0%
61.1%
20.0%
56.0%
21.0%
57.3%

0.0%
45.2%
73.0%
84.1%
0.0%
45.2%
30.0%
61.0%
22.0%
56.1%
71.0%
82.8%

68.70%
35.46%
47.08%
48.52%
65.69%
43.92%
53.42%
54.20%
68.61%
53.59%
48.53%
57.75%
67.84%
44.94%
52.92%
54.73%
81.62%
77.21%
76.01%
74.89%
74.84%
67.97%
65.92%
67.87%
76.47%
69.00%
66.75%
66.77%
81.19%
81.58%
80.93% 77.80%
81.98% 84.35%
79.10%
79.23%

18.0%
52.0%
41.0%
60.1%
13.0%
42.7%
12.0%
48.0%
52.0%
69.9%
48.0%
67.2%

60.64%
48.67%
64.06%
54.81%
62.28%
51.63%
63.92%
54.83%
79.83%
76.22%
67.22%
62.90%
70.88%
64.26%
82.12%
79.00%
82.09%
77.84%

53.0%
72.2%
63.0%
77.8%
26.0%
56.9%
7.0%
46.9%
0.0%
46.2%
0.0%
44.8%

80.65%
49.88%
81.09%
56.21%
83.06%
42.27%
81.84%
56.17%
88.19%
68.70%
86.08%
65.22%
87.15%
65.71%
90.47%
78.43%
90.51%
78.60%

23.0%
58.4%
19.0%
55.3%
15.0%
49.4%
9.0%
51.2%
22.0%
57.8%
20.0%
56.1%

71.66%
49.15%
71.76%
53.00%
74.78%
38.26%
71.52%
53.45%
84.24%
75.89%
76.03%
66.04%
77.57%
65.85%
86.27%
80.43%
86.40%
80.78%

24.0%
52.4%
23.0%
50.8%
44.0%
57.3%
24.0%
55.1%
44.0%
64.2%
24.0%
52.4%

67.51%
49.00%
68.70%
52.74%
70.76%
42.40%
67.81%
53.19%
86.64%
82.72%
73.81%
71.04%
77.73%
73.94%
89.21%
86.17%
90.29%
86.76%

11.0%
54.1%
14.0%
55.7%
10.0%
53.3%
4.0%
50.6%
11.0%
54.1%
8.0%
52.6%

26.06%
49.91%
38.13%
53.57%
7.10%
44.31%
34.26%
53.09%
65.95%
75.01%
50.71%
64.73%
52.95%
65.75%
83.37%
85.40%
84.81%
86.74%

TABLE IV: Average Performance Comparison of the Fine-Grained Line-Level Detection over 20 Runs. We use the Heterogeneous Contract
Graphs of the Buggy Smart Contracts as the inputs for MANDO framework. Buggy- F1 means the F1-score of the buggy node label. A
total of ﬁfteen methods are examined in the comparisons. The best performance in each vulnerability category is highlighted.

pert patterns to learn the normalized graphs for vulnerability
detection. They also provide more interpretable weights by
extracting vulnerability-speciﬁc expert patterns for encoding
graphs [14]. In their Peculiar tool [26], Wu et al. present a
pretraining technique based on customized data ﬂow graphs of
smart contract functions to identify reentrance vulnerabilities.
However, their methods face various limitations: Relying on
expert patterns, their graph generator only works with some
pre-deﬁned Major and Secondary functions before generat-
ing the contract graphs, leading to poor performance in the
graph generation process compared to MANDO. Besides, pre-
deﬁned patterns also restrict them to detect only two speciﬁed
bugs, Reentrancy and Time Manipulation, in Solidity source
code. In contrast, the heterogeneous graph structure allows
MANDO to be more general and ﬂexible in exploring differ-
ent vulnerability types without requiring any pre-deﬁnitions.
Other studies use other forms of embeddings: Zhao et
al. [27] use word embedding together with similarity detec-
tion and Generative Adversarial Networks (GAN) to detect
reentrance vulnerabilities dynamically. SmartConDetect [28]
treats code fragments as unique sequences of tokens and uses
a pre-trained BERT model to identify vulnerable patterns.
SmartEmbed [29] employs serialized structured syntax trees to
train word2vec and fastText models to recognize vulnerabili-
ties. Different from such existing techniques, our unique graph
encodings can accurately capture the vulnerability patterns and
locate ﬁne-grained vulnerabilities at the line level.

B. Code Representation and Learning

Software programs have explored learning from heteroge-
neous graphs for vulnerability detection, code search, and

other tasks. For example, VulDeePecker [30] uses both syntax
structures and dependency slices to represent programs and
employ commonly used neural network models to learn the
programs’ embedding and identify vulnerability patterns for
C/C++ programs. VulDeeLocator [31] extends the work by
adding attention-based granularity reﬁnement to identify ﬁne-
grained line-level vulnerability locations. BGNN4VD [32] also
uses combined code representations in the abstract syntax trees
and control- and data-ﬂow graphs to learn vulnerability pat-
terns via bilateral graph neural networks for C/C++ programs.
However, no such study has been done for Solidity smart
contracts and our study is the ﬁrst one.

C. Bug Detection & Smart Contracts

Several studies detect speciﬁc types of bugs or vulnera-
bilities using traditional program analysis and software en-
gineering and security techniques. For example, OYENTE
[12] uses symbolic execution to explore execution paths in
smart contracts as much as possible and search for four
types of bugs. SmartCheck [11] uses static analysis techniques
to check smart contract code for patterns that match pre-
deﬁned rules about vulnerabilities and code smells. Several
other studies use formal veriﬁcation to check smart contracts’
safety and functional correctness according to certain human-
deﬁned speciﬁcations [33]. In addition, many studies are based
on abstract interpretation, fuzz testing, enhanced compilation,
dynamic consistency checking, and other techniques [15], [34].
However, in contrast to our automatic bug pattern detection
method, such security analysis techniques are built to discover
speciﬁc vulnerabilities according to manually deﬁned patterns
or speciﬁcations, limiting their scalability and accuracy.

VI. CONCLUSION AND FUTURE WORK

The popularity and importance of smart contracts in
blockchain platforms are increasing. Therefore, it is highly
desirable to ensure the quality and security of smart contract
programs. In this paper, we proposed a new method, based
on multi-level graph embeddings of control-ﬂow graphs and
call graphs of Solidity smart contracts, to train more accurate
vulnerability detection models that can identify vulnerabilities
in smart contracts at ﬁne-grained line level and contract
level of granularity. Our evaluation of a large-scale dataset
curated from real-world Solidity smart contracts shows that our
method is promising and outperforms several baselines. Our
method is thus a valuable complement to other vulnerability
detection techniques and contributes to smart contract security.
However, with all the achievements, our method and evaluation
can still be improved further. The embedding techniques can
further fuse more semantic properties of the smart contract
source code, such as data dependencies, and adapt newer
and more sophisticated graph neural networks. We can also
adapt our method to cases where only compiled smart contract
bytecode is available without source code to expand. The
evaluation can further compare with vulnerability detection
techniques developed for other programming languages (e.g.,
C/C++, Java) to check the generalizability of our method.

REFERENCES

[1] X. Wang, H. Ji, C. Shi, B. Wang, Y. Ye, P. Cui, and P. S. Yu,
“Heterogeneous graph attention network,” in The World Wide Web
Conference, 2019, pp. 2022–2032.

[2] G. Wood et al., “Ethereum: A secure decentralised generalised trans-
action ledger,” Ethereum project yellow paper, vol. 151, no. 2014, pp.
1–32, 2014.

[3] A. Grover and J. Leskovec, “node2vec: Scalable feature learning for
networks,” in the 22nd ACM SIGKDD International Conference on
Knowledge Discovery and Data Mining, 2016, pp. 855–864.

[4] J. Tang, M. Qu, M. Wang, M. Zhang, J. Yan, and Q. Mei, “Line: Large-

scale information network embedding,” in WWW, 2015.

[5] T. N. Kipf and M. Welling, “Semi-supervised classiﬁcation with graph
convolutional networks,” arXiv preprint arXiv:1609.02907, 2016.
[6] Y. Dong, N. V. Chawla, and A. Swami, “metapath2vec: Scalable
representation learning for heterogeneous networks,” in the 23rd ACM
SIGKDD International Conference on Knowledge Discovery and Data
Mining, 2017, pp. 135–144.

[7] P. Tsankov, A. Dan, D. D. Cohen, A. Gervais, F. Buenzli, and M. Vechev,
“Securify: Practical security analysis of smart contracts,” in 25th ACM
Conference on Computer and Communications Security, 2018.

[8] B. Mueller, “Smashing smart contracts for fun and real proﬁt,” in 9th

annual HITB Security Conference, pp. 2–51.

[9] J. Feist, G. Grieco, and A. Groce, “Slither: a static analysis framework
for smart contracts,” in IEEE/ACM 2nd International Workshop on
Emerging Trends in Software Engineering for Blockchain, 2019, pp.
8–15.

[10] M. Mossberg, F. Manzano, E. Hennenfent, A. Groce, G. Grieco, J. Feist,
T. Brunson, and A. Dinaburg, “Manticore: A user-friendly symbolic
execution framework for binaries and smart contracts,” in the 34th
IEEE/ACM International Conference on Automated Software Engineer-
ing, 2019, pp. 1186–1189.

[11] S. Tikhomirov, E. Voskresenskaya,

Ivanitskiy, R. Takhaviev,
E. Marchenko, and Y. Alexandrov, “SmartCheck: Static analysis of
ethereum smart contracts,” in the 1st International Workshop on Emerg-
ing Trends in Software Engineering for Blockchain, 2018, pp. 9–16.

I.

[12] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making smart
contracts smarter,” in the ACM SIGSAC conference on computer and
communications security, 2016, pp. 254–269.

[13] Y. Zhuang, Z. Liu, P. Qian, Q. Liu, X. Wang, and Q. He, “Smart contract
vulnerability detection using graph neural network.” in IJCAI, 2020, pp.
3283–3290.

[14] Z. Liu, P. Qian, X. Wang, L. Zhu, Q. He, and S. Ji, “Smart contract
vulnerability detection: From pure neural network to interpretable graph
feature and expert pattern fusion,” arXiv preprint arXiv:2106.09282,
2021.

[15] H. Chen, M. Pendleton, L. Njilla, and S. Xu, “A survey on ethereum sys-
tems security: Vulnerabilities, attacks, and defenses,” ACM Computing
Surveys (CSUR), vol. 53, no. 3, pp. 1–43, 2020.

[16] Y. Sun, J. Han, X. Yan, P. S. Yu, and T. Wu, “Pathsim: Meta path-
based top-k similarity search in heterogeneous information networks,”
the VLDB Endowment, vol. 4, no. 11, pp. 992–1003, 2011.

[17] A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez,
Ł. Kaiser, and I. Polosukhin, “Attention is all you need,” in Advances
in neural information processing systems, 2017, pp. 5998–6008.
[18] Y. LeCun, Y. Bengio, and G. Hinton, “Deep learning,” nature, vol. 521,

no. 7553, pp. 436–444, 2015.

[19] Z. Liu, P. Qian, X. Wang, Y. Zhuang, L. Qiu, and X. Wang, “Com-
bining graph neural networks with expert knowledge for smart contract
vulnerability detection,” IEEE Transactions on Knowledge and Data
Engineering, 2021.

[20] T. Durieux, J. F. Ferreira, R. Abreu, and P. Cruz, “Empirical review
of automated analysis tools on 47,587 ethereum smart contracts,” in
the ACM/IEEE 42nd International Conference on Software Engineering,
2020, pp. 530–541.

[21] J. F. Ferreira, P. Cruz, T. Durieux, and R. Abreu, “Smartbugs: a
framework to analyze solidity smart contracts,” in the 35th IEEE/ACM
International Conference on Automated Software Engineering, 2020, pp.
1349–1352.

[22] A. Ghaleb and K. Pattabiraman, “How effective are smart contract
analysis tools? evaluating smart contract static analysis tools using bug
injection,” in the 29th ACM SIGSOFT International Symposium on
Software Testing and Analysis, 2020.

[23] C. Schneidewind, I. Grishchenko, M. Scherer, and M. Maffei, “ethor:
Practical and provably sound static analysis of ethereum smart con-
tracts,” in the 2020 ACM SIGSAC Conference on Computer and Com-
munications Security, 2020, pp. 621–640.

[24] P. Veliˇckovi´c, G. Cucurull, A. Casanova, A. Romero, P. Li`o, and
Y. Bengio, “Graph attention networks,” in International Conference on
Learning Representations, 2018.

[25] R. Baldoni, E. Coppa, D. C. D’Elia, C. Demetrescu, and I. Finocchi, “A
survey of symbolic execution techniques,” ACM Comput. Surv., vol. 51,
no. 3, 2018.

[26] H. Wu, Z. Zhang, S. Wang, Y. Lei, B. Lin, Y. Qin, H. Zhang, and X. Mao,
“Peculiar: Smart contract vulnerability detection based on crucial data
ﬂow graph and pre-training techniques,” in the 32nd International
Symposium on Software Reliability Engineering, 2021.

[27] H. Zhao, P. Su, Y. Wei, K. Gai, and M. Qiu, “Gan-enabled code em-
bedding for reentrant vulnerabilities detection,” in Knowledge Science,
Engineering and Management, 2021, pp. 585–597.

[28] S. Jeon, G. Lee, H. Kim, and S. S. Woo, “Smartcondetect: Highly
accurate smart contract code vulnerability detection mechanism using
bert,” in KDD Workshop on Programming Language Processing, 2021.
[29] Z. Gao, L. Jiang, X. Xia, D. Lo, and J. Grundy, “Checking smart con-
tracts with structural code embedding,” IEEE Transactions on Software
Engineering, 2020.

[30] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, and Y. Zhong,
“VulDeePecker: A deep learning-based system for vulnerability detec-
tion,” in The Network and Distributed System Security Symposium, 2018.
[31] Z. Li, D. Zou, S. Xu, Z. Chen, Y. Zhu, and H. Jin, “VulDeeLocator: a
deep learning-based ﬁne-grained vulnerability detector,” IEEE Transac-
tions on Dependable and Secure Computing, 2021.

[32] S. Cao, X. Sun, L. Bo, Y. Wei, and B. Li, “Bgnn4vd: Constructing bidi-
rectional graph neural-network for vulnerability detection,” Information
and Software Technology, vol. 136, p. 106576, 2021.

[33] I. Garfatta, K. Klai, W. Gaaloul, and M. Graiet, “A survey on formal
veriﬁcation for solidity smart contracts,” in 2021 Australasian Computer
Science Week Multiconference, 2021, pp. 1–10.

[34] Y. Wang, J. He, N. Zhu, Y. Yi, Q. Zhang, H. Song, and R. Xue, “Security
technologies for smart contracts in the blockchain: A
enhancement
survey,” Transactions on Emerging Telecommunications Technologies,
2021.

