2
2
0
2

p
e
S
6

]
E
S
.
s
c
[

1
v
9
8
1
2
0
.
9
0
2
2
:
v
i
X
r
a

Object-Oriented Requirements: a Uniﬁed Framework for
Speciﬁcations, Scenarios and Tests

Maria Naumchevaa,b, Sophie Ebersolda, Alexandr Naumchevb, Jean-Michel
Bruela, Florian Galinierc, Bertrand Meyerd

aIRIT, University of Toulouse, Toulouse, France
bInnopolis University, Innopolis, Russia
cSpilen Corporation, Toulouse, France
dSchaﬀhausen Institute of Technology, Schaﬀhausen, Switzerland

Abstract

A paradox of requirements speciﬁcations as dominantly practiced in the industry
is that they often claim to be object-oriented (OO) but largely rely on procedural
(non-OO) techniques. Use cases and user stories describe functional ﬂows, not
object types. To gain the beneﬁts provided by object technology (such as
extendibility, reusability, reliability), requirements should instead take advantage
of the same data abstraction concepts – classes, inheritance, information hiding –
as OO design and OO programs.

Many people ﬁnd use cases and user stories appealing because of the simplicity
and practicality of the concepts. Can we reconcile requirements with object-
oriented principles and get the best of both worlds?
This article proposes a uniﬁed framework.

It shows that the concept of
class is general enough to describe not only “objects” in a narrow sense but also
scenarios such as use cases and user stories and other important artifacts such
as test cases and oracles.

Having a single framework opens the way to requirements that enjoy the
beneﬁts of both approaches:
like use cases and user stories, they reﬂect the
practical views of stakeholders; like object-oriented requirements, they lend
themselves to evolution and reuse.

Keywords: Software requirements, use cases, scenarios, scenario-based testing,
object-oriented requirements, speciﬁcations

1. Introduction

A good software system is an eﬀective solution to a well-understood problem.
As software engineering has progressed, it has become increasingly clear that
achieving software quality involves achieving quality on both the solution side
and the problem side: together with excellent design, implementation and project
management techniques, a successful project requires an excellent description of
the problem, known as the requirements of the system.

September 7, 2022

 
 
 
 
 
 
While a considerable body of knowledge exists about requirements engineering,
the discipline as practiced in industry has not yet experienced the considerable
progress that object-oriented (OO) concepts, methods, languages and tools have
brought to solution-side tasks. The purpose of this article is to help advance the
state of the art in requirements engineering through the application of OO ideas,
and to show that this approach subsumes other widely applied techniques such
as use cases and user stories. The research questions we tackle in this paper are
(i) how to specify OO requirements? (ii) how to unify them with scenarios?

The modeling power of object technology has played a large part in its success
for design and implementation, and can be even more useful for requirements. It
comes in particular from the OO decision to deﬁne the architecture of systems
on the basis of object types connected by well-deﬁned relations (“client” and
“inheritance”), using structuring principles such as information hiding and Design
by Contract. These notions are clear and simple, and help ensure that the
structure of the software is closely related to the structure of the problem
description. For example, a library-management system will have such classes as
LIBRARY, BOOK, PATRON and CATALOG, directly reﬂecting concepts of the problem
domain and their mutual relations. This property, known as direct mapping,
helps achieve goals of reliability, extendibility and reusability. It is even more
useful for requirements, which are all about modeling external systems and their
environments.

In practice, however, requirements engineering does not widely apply OO
techniques. The phrase “object-oriented requirements” itself is used (sometimes as
“object-oriented analysis”), but often to describe techniques such as use cases and
user stories, which are procedural (the accepted term for “non-object-oriented”).
The relationship between OO and procedural techniques can be one of
complementarity rather than confrontation. The core observation is that data
abstraction, the idea at the heart of OO technology, has so much power that some
of it remains untapped. One does not need to treat such techniques as scenarios,
use cases, user stories and test scripts as independent of the OO framework
or even antagonistic to it; they can instead ﬁnd their natural place in it. The
result is a uniﬁed approach to requirements engineering. which has the potential
to bring to this discipline the same remarkable advances that have proved so
beneﬁcial to solution-side aspects of software development. The ﬁrst contribution
of this paper is the evidence of scenarios limitations and how OO paradigm could
address them; the following is the description of OO requirements. The third
contribution is a framework supporting OO requirements speciﬁcation; the last
one is the application of the approach to the case study of a Roborace, which
can serve as a guide for practitioners who want to use the uniﬁed framework.
These contributions allow requirements engineers to beneﬁt from the advantages
of conceptual consistency and uniﬁcation of notations, and from the potential of
scalability and extendibility of OO requirements.

Section 2 presents common approaches to requirements and their limitations.
Section 3 describes fundamental OO techniques, that form the basis of the
Uniﬁed Approach. Section 4 introduces the notion of object-oriented requirement.
Section 5 describes in details a uniﬁed framework, based on OO requirements.

2

Section 6 constitutes a proof of concept by applying the framework to a real-case
application. Section 7 compares the approach with related works and describes
limitations of the approach and of the case study. Finally, section 8 summarizes
the contributions, outlines future work directions, and concludes the paper.

2. Scenarios and tests

Requirements in industry generally rely on diﬀerent techniques, particularly
use cases and user stories. In modern software development approaches, tests
are viewed also as requirements artifacts.

2.1. Use cases

Use cases have become one of the major formalisms for expressing require-
ments thanks to Ivar Jacobson’s work and his 1992 book [6]. Their spread
happened at about the same time as the spread of OO methods for programming
and design. A use case describes a unit of requirements in the form of a possible
scenario of user interaction with the system.

There are several use case notations; the examples in this article will rely
on a notation due to Cockburn [3]. Table 1 presents an example, related to a
library system. It speciﬁes a scenario whereby a library user borrows a book
from the library, with such steps as placing the book on hold, then checking it
out, and returning it by the speciﬁed deadline.

The core part is the main success scenario, giving the sequence of steps
of the use case. Additional possibilities of the notation, not used in the example,
include:

• Steps consisting of several sub-steps, similar to calling routines in programming.
• Conditional steps, in which the use case follows either of two sub-scenarios

depending on the outcome of a certain condition.
Such mechanisms suggest a strong analogy between a use case and an algo-
rithm or a program. The two concepts also have diﬀerences: a use case (and other
kinds of scenario such as user stories, reviewed next) describes the interaction
between a human actor and the system, whereas an algorithm or program is
meant to be carried out by a computer.

The level entry characterizes the level of abstraction. A use case can describe
a process at many levels, from the highest (a bird’s eye view of an overall business
process, meant to be complemented by further use cases for the details) down to
the detailed descriptions of the system’s actual operation.

A precondition is a limiting condition governing the applicability of the

use case.

A trigger is an event that starts the use case.
Note the diﬀerence between the last two concepts: a precondition is a
condition that must hold for the use case to be applicable, but does not by itself
cause its execution; a trigger does. (The precondition is necessary, the trigger is
suﬃcient.)

3

Main success
scenario

Success guar-
antee
Extensions

Borrow_a_book
System
Business summary
Patron

Name
Scope
Level
Primary actor
Context of use The patron wants to check out a book
The book is available
Preconditions
The patron ﬁnds in a library catalogue the book he wants to borrow
Trigger
and requests the system to place a hold on this book
* The system changes the book status to on_hold
* The patron checks out the book
* The patron returns the book
The patron has borrowed the book and returned it within the
checkout duration.
A. The book is not available
*The system denies placing hold on the book
B. The hold expires due to exceeding maximum hold duration.
* The system changes the hold status to “expired” and the book
becomes available
C. The patron cancels the hold
* The book status changes to available
D. The patron does not return the book within the maximum check
out duration
* The book status changes to overdue
* The patron returns the book
Patron (borrows a book)
Library personnel (enforces adherence to library policies)

Stakeholders
and interests

Table 1: Use Case description for Borrow_a_book

The success guarantee characterizes the state resulting from successful
execution of the use case, for the “main success scenario”. In the terminology
of mathematical software veriﬁcation, from which the term “precondition” is
borrowed, it would be called a “postcondition”.

An extension describes a departure from the “main success scenario”. Ex-

tensions serve two separate purposes:
• As in the example, an extension can specify an alternative to the “main success
scenario”, to be applied when that scenario hits a condition that prevents it
from proceeding normally.

• Extensions also support reuse of elements common to several use cases, which
can then be divided into a base use case, covering the common elements, and
speciﬁc extensions.

The use case lists, towards the beginning, the main actor responsible for
carrying out instances of the scenario. It concludes with a list of stakeholders:
others who may be aﬀected.

4

2.2. User stories

A use case is a complete path taken by an actor through the system. User
stories [7] also express a typical interaction with the system, but at a much
smaller level of granularity. They play an important role for requirements in
agile methods, which promote incremental program construction: the basic
agile development iteration involves a developer picking the next item from a
list of functions to be implemented, implementing it, and moving on to the next
one. A use case is generally too complex for such atomic units of development.

The standard format for a user story includes three elements:
• A role (“As a...”), corresponding to the main actor of a use case.
• A desired function (“I want to...”), part of the system’s behavior.
• A business purpose (“so that...”), corresponding to one of the goals of a

system.

An example user story in a library system is:
As a patron, I want to check out a book so that I can read it at home.

An alternative way of expressing it is in tabular form as presented in Table 2.

Role
Desired function
Business purpose

Patron
Check out a book
Read at home

Table 2: User Story Example

2.3. Use case 2.0 and use case slices

Use Case 2.0 [18], a revision of the original use case methodology, combines
ideas of use cases and user stories through the notion of use case slice. A use
case slice is a selected part of a use case, which is also a unit of testing (usable in
a test-driven design methodology). Breaking down a use case into slices makes
it possible to consider it at diﬀerent phases of development and to build the
system incrementally.

As an example, a slice of the use case Borrow_a_book is Overdue_checkout
(Table 3). It outlines its narratives as a set of ﬂows: the basic ﬂow of Bor-
row_a_book and one of its extensions (Alternative Flow D), “The patron does
not return the book within the maximum check out duration.”

The standard format of a use case slice includes:

• A name, used to track it through the development cycle.
• A state, with possible values scoped, prepared, analysed, implemented or

veriﬁed.

• A priority, expressed by the MoSCoW acronym: Must, Should, Could, Would.
• References: ﬂows and tests
• An estimate of the work needed to implement the slice.

5

Name
State
Priority
Flows

Tests
Estimate

Overdue_checkout
Scoped
Should
BF: “Borrow a book ” + AF D: “The patron does not return the
book within the maximum check-out duration”
The checkout duration exceeds the limit
3/20

Table 3: Use case slice description of Overdue_checkout

2.4. Unit tests

An important development of software engineering in the past two decades,
fostered in particular by agile methods, has been the recognition of test cases
as essential artifacts of the software process. The various “xUnit” frameworks,
where “x” represents a target programming language (for example, JUnit for
Java), describe a test case in the form of a small program element listing a
condition to be tested and an “oracle” specifying the correct expected result.

In a traditional, “waterfall” view of software engineering, requirements and
test cases play entirely diﬀerent roles and appear at opposite ends of the lifecycle:
requirements at the beginning, tests at the end (in a ﬁnal “veriﬁcation and
validation” step, often called V&V). The only relationship between them is
that a test case, devised in a late stage of the project, will typically exercise a
particular requirement, speciﬁed much earlier.

With modern views of software development, iterative and incremental, the
concepts move closer to each other. In the extreme view (coming from the
“Extreme Programming” approach to development) of test-driven development
[2], unit tests actually become the requirements, pushing aside more traditional
forms of requirements. Even in less radical approaches, tests share many of the
properties expressed as use cases or user stories.

The following example is a Java test for the example library system (it

corresponds to a requirement given in section 3.5 below).

public c l a s s H o l d i n g A v a i l a b l e B o o k s T e s t {

private Book b ;
private Patron p1 , p2 ;
private LibraryBranch l b ;
private L i b r a r y l ;

$@$BeforeEach
public void setUp ( ) {

b = new Book ( " Crime and Punishment " , " Fedor Dostoyevsky " , " 978 −1703766172 " ) ;
p1 = new Patron ( "Ted" ) ; p2 = new Patron ( " Fred " ) ;
l b = new LibraryBranch ( " S q u i r r e l H i l l " ) ;
l = new L i b r a r y ( " C a r n e g i e L i b r a r y o f P i t t s b u r g h " ) ;
l . addPatron ( p2 ) ;
l . addPatron ( p1 ) ;
l . addBranch ( l b ) ;

}

6

$@$Test
public void t e s t H o l d i n g ( ) {
l . placeBookOnHold ( b , p1 ,
l . placeBookOnHold ( b , p2 ,
a s s e r t T r u e ( l . bookIsOnHold ( b , p1 ,
a s s e r t F a l s e ( l . bookIsOnHold ( b , p2 ,

l b ) ;
l b ) ;

l b ) ) ;
l b ) ;

} }

The setUp() method instantiates concrete input objects for the test. Then
testHolding() executes the method under test and checks correctness of the
objects in the resulting state. The @BeforeEach annotation directs the unit
testing framework to execute the setUp() method before running any tests,
decorated with @Test annotations.

The role of tests extends beyond requirements (the focus of this article); note
in particular the widely accepted role of the regression test suite, which collects
all tests run on versions of a system since the project’s inception. Another
idea that has gained wide acceptance under the inﬂuence of agile methods is a
milder form of Test-Driven Development: the rule that every addition to the
code must also include a new test (even if we avoid misconstruing that test for a
speciﬁcation). Some agile approaches go so far as to accept only code and tests
are legitimate artifacts.

2.5. Beneﬁts and limitations of scenarios and tests for requirements

The techniques reviewed above have gained front-row seats in modern software
development. Use cases and user stories are important as checks on requirements,
to verify that the requirements, expressed in any form, do cover the most
important cases. They are not, however, a substitute for these requirements.

A good mathematical textbook presents, along with every important theorem,
examples of its consequences. A good physics textbook presents, along with every
important property, examples of its applications. They help make the theorem
or property more concretely understandable. No one, however, would accept the
examples as a replacement for the theorem. Use cases are to a requirement what
an example is to a theorem and a test to a speciﬁcation.

A scenario or test describes only one path of system usage; the number of
actual paths is, for any signiﬁcant system, staggeringly large or theoretically
inﬁnite. Requirements should specify the system’s behavior in all cases, not just
the inevitably small subset of cases that have been foreseen.

The diﬃculty of software and particularly of software requirements comes
from the myriad of variants that a system must be prepared to handle. One of
the prime goals of requirements is to help ensure the system’s correctness. In
practice, the most serious bugs (violations of correctness) do not generally arise
from the common example scenarios typically included in use cases, user stories
and unit tests, since the testing phase will naturally focus on them; they arise
out of less obvious cases, which such examples often leave out. Only by trying

7

for a more abstract form of speciﬁcation, covering all cases, can one expect to
identify such problematic cases.

Even use cases, the most advanced form of scenario, suﬀer from this limitation.
A use case describes only one path of interaction with the system, or a set of
related cases if it takes advantage of conditional branching and extensions. In
practice, use cases tend to focus on the most desirable cases, in particular the
“main success scenario” and possibly some of its variants as illustrated earlier
in section 2.1) . While one can add extensions covering such situations, or
write new use cases to address them, there are so many combinations for any
non-trivial system that it is impossible to include all such extensions, or even a
representative subset. These observations also apply to user stories and tests.

Scenario-based techniques suﬀer from another limitation: their exaggerated
reliance on time ordering, which often leads to overspeciﬁcation. A use case will
often specify a sequential contract (step B must occur after step A) when in
fact a logical constraint would suﬃce (step B requires a certain condition, which
step A ensures). Turning logical constraints into sequential ones is often too
restrictive. Section 5.1 discusses this point further. (Also note Glinz’s critical
analysis of use cases [5].)

The preceding analysis leaves two questions open:

• Is a more general form of requirement available, focusing on abstract properties

rather than examples?

• Can we express use cases, user stories and tests in the same framework as

those requirements?

For answers, we may turn to the object-oriented mode of speciﬁcation.

3. Object-oriented fundamentals

To reach the level of abstraction that scenarios do not provide, we look into
object-oriented techniques, which have been widely applied to programming and
design.

3.1. OO principles

The core OO concepts are listed below.

• Type-based modular decomposition: capture the properties of the key “things”
manipulated by a system, better called objects, by abstracting them into
types, or classes, and deﬁne the modular structure of a system as a set of
interconnected classes.

• Data abstraction: describe each class not by implementation properties (what
the corresponding objects “are”) but by the applicable operations, or features
(what the objects “have”).

• Contracts: in such descriptions, include not only structural properties, such as
the types of arguments handled by each operation, but also abstract semantic
properties (preconditions, postconditions, class invariants).

• Inheritance: organize classes into taxonomies to take advantage of common
traits. Techniques of polymorphism and dynamic binding, which follow from
inheritance, enhance the architectural quality of OO systems.

8

The main beneﬁts pursued by these techniques are extendibility (ease of
modifying software, by keeping the various elements of a system isolated from
changes in others), reusability (ease of applying elements of a system to the
development of a new system) and reliability (correctness of solutions, robustness
in the presence of errors, and security). These goals are just as desirable for
requirements as they are for design and programming.

The next subsections examine some of the principal OO concepts in more
depth, with an eye on their application to requirements. The examples use the
Eiﬀel notation, which includes built-in mechanisms of Design by Contract and
was designed to cover requirements and design in addition to programming.

3.2. Classes and their mutual relations

The central concept of object-oriented approaches to system modeling and
structuring is the class, deﬁned as a system unit specifying a type of objects
with the associated operations and their properties. A class has operations of
three kinds, which we may illustrate through the example of a class describing
the concept of book in a library system:
• Queries, providing information about the book: is_available, isbn, author.
• Commands, to update the corresponding objects: hold, checkout.
• Creators (or “constructors”), yielding objects of the type from other information,

for example a book object deﬁned by an author and title.

OO system descriptions are simple, relying on classes and only two relations
between these classes: client and inheritance. For example, operations on a
book (see the use case presented in section 2.1) involve, among other objects, a
patron and a library branch. The class representing a book will be a client of
the classes representing the other three concepts.

A class inherits from another if it represents a specialized or extended
version of the other’s concept. For example book and magazine both belong
to the general category of library item, which can be represented by a class
LIBRARY_ITEM. BOOK and MAGAZINE are “descendants” of LIBRARY_ITEM through
the inheritance relation shown in Fig. 1.

Figure 1: Examples of the two kinds of inter-class relations

9

3.3. Deferred classes

In an OO program, most of the commands and queries of a class are “eﬀective”,
meaning that the class speciﬁes an algorithm for their implementation. A
class whose features are all eﬀective is itself called an eﬀective class.
In
some cases, however, including classes describing requirements, it is useful to
deﬁne features without providing an implementation. Features speciﬁed but not
implemented are called deferred; and a non-eﬀective class (one that has at least
one deferred feature) is a deferred class. In requirements for the library example,
LIBRARY_ITEM will most likely be a deferred class (as marked by “*” in Fig. 1)
since it describes an abstract concept with several possible concrete realizations.
In requirements, declaring classes and features deferred makes it possible
to specify that some functionality must exist while staying away from any
consideration of implementation and hence from the risk of overspeciﬁcation.

Even without an implementation, it will be possible in such cases to specify
abstract properties of the desired behavior thanks to contracts, as discussed in
section 3.4 below. It might seem that in requirements all classes and features
should be deferred, but that would be too restrictive. As we will see in section 5,
requirements classes can specify scenarios, such as use cases or tests; such
classes and their features will, in general, be eﬀective since they prescribe precise
sequences of operations.

3.4. Contracts

Information hiding implies that modules of a system’s description (in OO
modeling, classes) can refer to others in terms of their abstract speciﬁcation. To
be useful, such speciﬁcations should not just be structural, giving the types of
arguments and results of the operations in a class, but also semantic, describing
the abstract properties of these operations and the class as a whole. Design by
Contract techniques [10] provide this semantic speciﬁcation for both operations
(preconditions and postconditions) and classes (class invariants).

As an example, the class extract below expresses the requirement that a
public library allows patrons to place books on hold at its various library branches:

class LIBRARY feature

place_book_on_hold (b: BOOK; p: PATRON; lb: LIBRARY_BRANCH)

require

has_patron (p)
has_branch (lb)

do -- Future implementation
ensure

book_is_on_hold (b, p, lb)

end

end

The require clause introduces a precondition, and the ensure clause a

postcondition.

Contracts have many applications, including as documentation of the software
and as a guide to both exception handling and the proper use of inheritance.

10

When applied to code, they also provide a systematic approach to testing and
debugging (in a development environment that provides the ability to evaluate
contract elements at run time). The application of most direct relevance to
requirements, as illustrated by the LIBRARY example sketch above, is to model
the System or Environment by providing not only structural properties (object
types and the applicable operations) but also through precise semantics (the
properties of these types and operations).

Such semantic models lend themselves to automatic veriﬁcation. Beyond
run-time monitoring of contracts, which only applies to executable code, classes
equipped with contracts can be veriﬁed using automatic tools such as JML [9]
and the AutoProof veriﬁer for Eiﬀel [20].

3.5. Speciﬁcation drivers

The object-oriented style of modeling has modular units (classes) each orga-
nized around one type of objects. Correspondingly, contract techniques apply
within a class, making it possible for example to express the requirement that
“after a patron returns a book, it is considered available” as a postcondition of
an operation return in a class BOOK.

Some properties apply to several objects, possibly of diﬀerent types. An
example is “available books can be placed on hold by only one patron at any given
time”.

While the OO style would seem to break down in such cases, it actually
handles it in a simple way through the introduction of “speciﬁcation drivers”
[12]. The idea (generalizing techniques already present in some classic Design
Patterns such as Visitor [4]) is to express such cross-object properties through
classes designed speciﬁcally for speciﬁcation purposes.

In the last example, we may use the following speciﬁcation-driver assertion,
which describes a generic scenario of using the relevant features and speciﬁes its
eﬀect through the postcondition:

holding_available_books (b: BOOK; p1, p2: PATRON; lb: LIBRARY_BRANCH; l:

LIBRARY)
require

b.is_available; p1 (cid:54)= p2
l.has_patron (p1); l.has_patron (p2); l.has_branch (lb)

do

l.place_book_on_hold (b, p1, lb)

l.place_book_on_hold (b, p2, lb)
ensure

l.book_is_on_hold (b, p1, lb)
not l.book_is_on_hold (b, p2, lb)

end

Speciﬁcation drivers retain the OO style of requirements speciﬁcation but
make it more general by covering arbitrary properties, not necessarily expressible
within a single class of the original OO model.

11

4. Object-oriented requirements

The scope of object-oriented concepts as described in the previous section is
broad enough to encompass all tasks of software construction, from requirements
to design, implementation of course, and even veriﬁcation. Of direct interest in
this article is the application to requirements.

4.1. OO requirements basics

Discussing a system as a set of object types (classes) characterized by the
applicable operations yields a number of potential beneﬁts, which have been
widely recognized in the programming world but can apply to requirements as
well. They include the following:
• Stability through the evolution of the software. Changes aﬀect individual

modules, not the architecture.

• Information hiding. With classes, we may declare, as part of the speciﬁcation
of a class, that some of the properties are for internal use only, within the
class, and not accessible outside; limiting the eﬀect of changes.

• Reuse. If we are trying to apply the results of one project to another, reusing
individual operations will generally not work. Operations such as “place a
hold on a book”, “checkout a book”, “cancel a checkout” and others are closely
connected. The notion of a book (as a class which includes all these operations)
is a more realistic unit for reuse.

• Classiﬁcation. Inheritance makes it possible to describe new classes as exten-
sions or specializations of existing ones, without repeating common properties.
Along with information hiding, inheritance is a key tool in harnessing system
complexity.

• Modeling power (“direct mapping principle”, as noted in section 1). OO
concepts can yield system descriptions that are clear and intuitive, since the
notions of object, class and inheritance are easy to grasp. Some classes have
immediately tangible counterparts in the system environment. They are called
“Environment classes”, Concrete and Abstract, in the classiﬁcation presented
in a subsequent section (4.2).

• Abstraction. Deferred classes and features make it possible to specify the
presence of certain types of objects and of certain operations on them, without
giving implementation details (but with abstract behavioral properties through
contracts).

4.2. Modeling the system and its environment

Requirements in their general sense involve four aspects (called the “Four
PEGS” in [11]): Project (human eﬀort to produce a system), Environment (the
material or virtual reality in which the system will operate), Goals (objectives
set by the organization), and System (the set of functionality elements that will
be provided). OO modeling is applicable to all four aspects.

The application to the System part is the traditional focus of OO ideas.
When the project reaches the design and implementation stages, System classes

12

will include both concrete classes describing implementation elements and more
abstract design classes, corresponding for example to design patterns such as
Visitor or Observer.

At the requirements stage, it is not too early to use classes to identify the
major components of the system and describing them through classes. Many of
these classes will be deferred (abstract), but they may already include operational
elements, including speciﬁcation drivers and (as explained below) scenarios.

Of particular relevance are Environment classes; OO modeling is indeed
appropriate to describe components of the environment. A typical example is
the description of interfaces to and from other systems, through interface classes
describing such elements as sensors, actuators, buttons and control panels. The
corresponding objects are not part of software under development, but they are
directly monitored or controlled by the software.

Contract elements are particularly useful here, to describe delicate properties

of the environment. Such properties include:

• Constraints: conditions imposed by the environment, such as a physical limit
(in a cyber-physical system) or a legal obligation (for a business system).
• Eﬀects: changes to the environment produced by the system (such as the

triggering of an actuator, or a change in payroll processes).

• Assumptions (posited properties of the environment, making the system’s

construction easier).

• Invariants (properties that are both constraints and eﬀects, as they can be

assumed but must be preserved).

4.3. An example OO speciﬁcation

The class text below is an example of how we can use an object-oriented
formalism to describe requirements speciﬁcations, independently of any design
or implementation consideration.
It describes a notion of book in a library
system. The following section will discuss some of its most important features
distinguishing it from other types of speciﬁcations such as use cases.

class BOOK feature

-- Boolean queries (is_available initialized to True;
-- is_on_hold, is_checked_out initialized to False)

is_available, is_on_hold, is_checked_out: BOOLEAN
place_hold (patron: PATRON)

-- Place a hold on a book. Set is_on_hold

require

is_available

deferred
ensure

is_on_hold
not is_available

end

checkout (patron: PATRON)
-- Check out the book

13

require

is_on_hold

deferred
ensure

is_checked_out

end
return

-- Return the book to the library
require

is_checked_out

deferred
ensure

is_available

end

invariant

is_on_hold implies not is_available
is_checked_out implies not is_available
is_checked_out implies not is_on_hold
is_available implies not is_checked_out

end

5. Object-oriented requirements as the unifying framework

The object-oriented approach is a structuring discipline, which models systems
— at all levels: requirements, design, implementation — as collections of classes
equipped with contracts and related to each other through client and inheritance
links. This framework is general enough to encompass all aspects of requirements
and provides room for the various non-OO techniques (scenarios and tests)
reviewed earlier. The following sections show how to use an OO model as such
an all-encompassing host for various applications.

5.1. Logical rather than sequential constraints

A distinctive feature of the above BOOK class sketch is its reliance on logical
constraints (through contracts) in lieu of a strict speciﬁcation (or overspeciﬁca-
tion) of sequencing constraints.

OO techniques avoid premature time-ordering decisions. While it is possible
for an OO speciﬁcation to express a time-ordered scenario such as a use case,
object technology also supports a more general and abstract speciﬁcation style,
based on contracts.

The comparison of class BOOK with the use case speciﬁcation of books in
section 2.1 provides a good illustration. The use case version speciﬁes the order
in which operations will get executed; for example, in the “main success scenario”:
• The system changes the book status to on_hold
• The patron checks out the book
• The patron returns the book

14

Enforcing such an ordering speciﬁcation at the level of requirements is often
a premature decision. In reality, the order of the steps is not cast in stone. Using
a preset ordering is convenient to describe desirable scenarios, or more generally
the expected ones. But what happens in life is not always what we hope for, or
expect. What if the customer returns a damaged book? Should the book not
remain unavailable until it is repaired?

To specify scenarios that depart from the standard ones, we saw that it is
possible to use extensions. But this solution does not scale. Writing ever more
use case extensions to cover all such situations leads to an explosion of special
cases which soon becomes be intractable. In practice, it is possible to write use
cases to cover the most common scenarios, but they are only a small subset of
the possible ones, in the same way that, in programming, tests can only cover a
minute subset of possible inputs.

To get out of this predicament, we note that while constraints between the
operations do exist, it is often more general and eﬀective, instead of timing
constraints, to rely on logical constraints.

The preceding example scenario provides a good illustration. As a speciﬁca-
tion, it is trying to express a few useful things; for example, the patron should
place a hold on a book before checking it out. But it states them in the form of
a strict sequence of operations which does not cover the wide range of possible
scenarios.

In the same way, a user story such as “As a patron, I want to check out a
book so that I can read it at home" describes the interaction between a human
actor and the system,. Describing a few such scenarios is useful as part of
requirements elicitation, but to express the resulting requirements it is more
eﬀective to express the logical constraints.

Class BOOK (from section 4.3) speciﬁes these logical constraints in the form of
contracts. Notice the interplay between the preconditions and postconditions and
the various boolean-valued queries they involve (is_available, is_on_hold,
is_checked_out). It is possible to specify a strict order of operations o1, o2,
..., as in a use case, by having a sequence of assertions pi such that operation
oi has the contract clauses require pi and ensure pi + 1; but assertions also
make it possible to specify a much broader range of allowable orderings. Logical
constraints are more general than sequential orderings.

The speciﬁc sequence of actions described in the use case (“Main scenario”)

is compatible with the logical constraints: one can check that in the sequence

-- The following is the "Main scenario":

place_hold (patron: PATRON)
checkout (patron: PATRON)
return (patron: PATRON)

the postcondition of each step implies the precondition of the next one
(the ﬁrst has no precondition). Prescribing this order strictly is, however,
overspecifying. For example it may be possible to perform additional operations
between place_hold and check_out.

15

The contract-based speciﬁcation does cover the fundamental sequencing
constraints; for example, the pre- and postcondition combinations imply that
investigation must come before evaluation and that resolution must be preceded
by either negotiation or imposition. But they avoid the non-essential constraints
which, in the use case, were only an artifact of the sequential style of speciﬁcation,
not a real feature of the problem [15].

5.2. Integrating scenarios into an OO model

The preceding discussion shows how a speciﬁcation through classes and their
contracts beats a scenario-style speciﬁcation in precision and generality. Use cases,
user stories and other scenarios do retain their attractive features mentioned in
section 2, in particular their intuitive appeal to stakeholders, who can relate them
easily to business processes, and their value as ways to validate the completeness
of speciﬁcations. There is no need, however, to sacriﬁce scenarios – in particular
use cases, retained as example for this discussion – in an OO approach. A use
case is simply a certain pattern of exercising the features (operations) of one or
more classes; it can easily be expressed as a routine (method) of an appropriate
class.

Here for example is the expression of the use case from 2.1 as a routine that

calls features of the class BOOK:

class BOOK feature
.. .

borrow_and_return_book (p: PATRON, lb: LIBRARY_BRANCH)

require

book_is_available: is_available

do

end

place_hold (p)
checkout (p)
return (p)

end

This use case is simply a routine, calling features of the appropriate class.
Where should such use case routines appear? Two possibilities are available:
• In the case of a use case characterizing a single data abstraction and applying
to a single object, such as one book, it can be expressed as a routine of the
corresponding class, in this case BOOK. Then it simply describes a speciﬁc be-
havior of the instances of the class, expressed in terms of the more fundamental
operations of the class.

• A more general solution, and the one that ﬁts the case of a use case involving
several objects of possibly diﬀerent types (hence, routines in diﬀerent classes),
is to group use cases into a separate class.

In the second case, the use case is a typical instance of the concept of
speciﬁcation driver (3.5): a class speciﬁcally devoted to speciﬁcation purposes,
exercising the features of other classes. The speciﬁcation drivers as described in

16

[12] were intended for veriﬁcation purposes (proofs and tests); use case classes
are intended for requirements speciﬁcation purposes, but are essentially the same
concept.

Here is a general use case class exercising features of classes BOOK and LIBRARY.

class LIBRARY_BOOK_USAGE feature

borrow_and_return_book

do .. . as given above .. . end

decommission_book

do .. . Specification of decommission use case .. . end

renew_book

do .. . end

-- Other use cases

end

5.3. Relation of OO requirements to test cases

Test cases ﬁt in the general OO framework just as use cases do. In modern
“xUnit" approaches to software testing (section 2.4), the basic scheme is already
there since, as noted in the earlier discussion, these frameworks require writing
test cases as routines. The earlier example, HoldingAvailableBooksTest, takes
the form of the class HOLDING_AVAILABLE_BOOKS_TEST depicted below.

class HOLDING_AVAILABLE_BOOKS_TEST feature

test_holding

local

b: BOOK
p1, p2: PATRON
lb: LIBRARY_BRANCH
l: LIBRARY

do

create b.make("Crime and Punishment", "Fyodor Dostoyevsky", "

978−1703766172");

create p1.make("Ted"); create p2.make("Fred");
create lb.make("Squirrel Hill");
create l.make("Carnegie Library of Pittsburgh");
holding_available_books (b, p1, p2, lb, l)

end
.. .

end

As suggested by the ﬁnal ‘...’, the given routine test_holding does not need
to be the only in its class. Having one testing routine per testing class is, in
fact, the typical xUnit style as used in practice, but this practice misses the
advantages of OO modularization. (It is a general rule of OO methodology that
a class with just one routine is a “design smell”, a sign of probably bad OO
design.) In the context deﬁned by the present discussion, the testing harness for

17

a system should consist of a set of testing class, each exercising some features of
a system or environment class (or of a closely related group of such classes).

Like use cases, such test classes are example of “speciﬁcation drivers”.
HOLDING_AVAILABLE_BOOKS_TEST, containing one or more routines related to
book borrowing, is a typical example.

5.4. Premature design?

An object-oriented requirements speciﬁcation, as presented, uses an object-
oriented notation, borrowed from an OO programming language. This notational
resemblance may give the wrong impression of a speciﬁcation involving premature
choices of design and implementation. Such criticism is not justiﬁed; in fact,
a proper OO requirements speciﬁcation is more abstract, and less prone to
overspeciﬁcation, than a use-case or other scenario-based form of requirements.
The classes used in an OO speciﬁcation are purely descriptive; they specify
concepts (in particular, system and environment concepts) in an abstract way,
using the OO style of specifying object types through the applicable operations
and their abstract properties (contracts). In contrast, use cases are of a sequential,
operational nature, presenting a risk of premature design, particularly as they
make it tempting to write programs following the same ordering patterns, justiﬁed
or not.

While free from design and implementation considerations, the classes written
for requirements purposes are still classes and can be expressed in an object-
oriented language that also supports design and implementation classes. The
beneﬁt here is to avoid harmful changes of concepts and notations when going
through successive steps of the software lifecycle. This approach is known as
seamless development. One of its consequences is reversibility: having everything
expressed in the same notation makes it easier to update the requirements at
any stage in the project, even deep into design, implementation or veriﬁcation.

6. A case study – the Roborace software

This section illustrates the application of the suggested approach to a real-
world case study: the Roborace [16]. The code excerpts used in this section are
available at [13]. Although the complete requirements speciﬁcation is beyond
the scope of the article, we illustrate the implementation of the key concepts of
the framework.

6.1. Project Description

Roborace [16] is a global championship between autonomous cars. The
hardware (the race cars) is the same for all participating teams; each gets access
to an autonomous race car called Devbot 2.0, and develops software to drive it
in races, in a completely autonomous way. Each season sees changes in the goals
and rules, and the introduction of new conditions.

The race takes place on a circuit. The cars start at a designated spot on
a starting grid and have to accomplish a given number of laps faster than the

18

Figure 2: Devbot 2.0 – all-electric vehicle currently used in the Roborace competition (source:
https://roborace.com/)

competing teams. The competitors race independently and their racing time is
compared after all teams have ﬁnished the race.

No physical objects other than the competing race cars are present on a
racetrack, but there can be virtual objects, of three kinds: static obstacles, loots
and ghost cars. Cars get bonus time for collecting loots and penalty time for
hitting obstacles or ghost cars. The total time is deﬁned as the race time minus
bonus time plus penalty time.

6.2. Requirements classes

The OO model of the system and its domain includes classes representing
the system’s modules (CONTROL_MODULE, PERCEPTION_MODULE, etc.) and its
environment (RACETRACK, MAP, OBSTACLE, etc.).

class RACECAR
feature

control_module: CONTROL_MODULE
perception_module: PERCEPTION_MODULE
planning_module: PLANNING_MODULE
localization_and_mapping_module:

LOCALIZATION_AND_MAPPING_MODULE

end

During the development process, elements of the system’s functionality are
assigned as features of respective modules’ classes and are enriched with contracts.
Below is an implementation of the requirement “At every position on a
raceline the speed in the velocity proﬁle shall not exceed the maximum racecar’s
speed”:

class PLANNING_MODULE
feature

car: RACECAR
calculate_raceline (t: RACETRACK)

--Calculate optimal raceline for a given racetrack

19

do
ensure

across t.raceline.velocity_profile as rl all rl.item <car.

max_speed end

end

end

6.3. Roborace scenarios as speciﬁcation drivers

A list of use cases has been elicited for the Roborace system

• Race without obstacles
• Avoid obstacles or stop
• Update speed limit
• Race with virtual obstacles
• Race with virtual race cars
• Move to pit
• Perform an emergency stop
• Perform a safe stop.

This article will focus on the key usage scenario, which is described as a use

case “Race without obstacles” (table 4).

Table 4: A detailed description of the “race without obstacles” use case

Race_no_obstacles
System
Business summary
Race car Operator
Roborace Operator

Name
Scope
Level
Primary actor
Secondary ac-
tor
Context of use Race car has to obey an instruction
Preconditions

Trigger

Main success
scenario

Success guar-
antee
Extensions

* Race car is on the racetrack grid
* Race car is not moving
* The global plan (trajectory and velocity proﬁle) minimizing the
race time is calculated
* The green ﬂag is shown by the Roborace
The system receives a request from the race car operator to start
the race
* The system calculates the local plan (path and velocity proﬁle)
during the race trying to follow the global plan as close as possible
* The race car follows the local plan
* After ﬁnishing the required number of laps the race car performs
a safe stop
The race car has completed the required number of laps and
stopped.
A. The red ﬂag received during the race
* The race car recalculates a global plan to perform an emergency
stop
* The race car performs an emergency stop

20

B. The yellow ﬂag is received during the race
* The system sets the speed limit according to the received value
* The race car ﬁnishes the race following the global trajectory and
not exceeding the new speed limit
C. The diﬀerence between the calculated (desired) location and real
(according to the sensors) location is more than a given threshold
* The race car recalculates a global plan to perform an emergency
stop
* The race car performs an emergency stop
Race car Operator (requests the car to start the race)
Roborace Manager (sets the race goals and policies)
Roborace Operator (shows the green, yellow, red ﬂags)

Stakeholders
and interests

This use case can be implemented as a routine of a use case class ROBORACE_USE_CASES.

The routine race_no_obstacles relies on conditional expressions to consider
the use case alternative ﬂows.

race_no_obstacles

Note

Callers: car_operator

require

not car.is_moving
car.global_plan_is_calculated
car.green_flag_is_shown
car.is_on_starting_grid
local local_plan: RACELINE
do

from --Sequence of system actions in use case main flow
until car.race_is_finished or
car.red_flag_is_shown or
car.location_error_is_detected

loop

if car.yellow_flag_is_shown then

update_speed

end

local_plan := car.planning_module.calculate_local_plan
car.control_module.move (local_plan.speed,

local_plan.orientation)

end
if car.red_flag_is_shown or car.location_error_is_detected

then

emergency_stop
else safe_stop end

ensure

not car.is_moving
car.is_in_normal_mode implies car.race_is_finished

end

21

The race_no_obstacles routine relies on implementing the routines update_speed,

safe_stop, and emergency_stop: the respective features are called inside the
use case. These features are implementation of the respective use cases, and such
dependency corresponds to «include» and «extend» relationships between use
cases.

The ROBORACE_USE_CASES class is thus a collection of routines corresponding

to the system’s use cases.

class ROBORACE_USE_CASES
feature

car: RACECAR

safe_stop

require

‘ car.is_in_normal_mode

do

car.control_module.safe_stop

ensure

not car_is_moving

end

emergency_stop
require

car.red_flag_is_shown or car.location_error_is_detected

do

car.control_module.emergency_stop

ensure

not car.is_in_normal_mode
not car.is_moving

end

update_speed
require

car.yellow_flag_is_shown

do

car.update_max_speed (car.yellow_flag_speed)

ensure

car.max_speed = car.yellow_flag_speed

end

race_no_obstacles

do

--implementation is listed above

end

22

avoid_obstacle_or_stop

do
end

race_with_virtual_obstacles

do
end

race_with_virtual_race_cars

do
end

move_to_pit

do
end

end

6.4. Relation between Roborace use cases and test cases

Use case stories deﬁne test cases for use cases [8]. ROBORACE_USE_CASE_STORIES

class inherits from ROBORACE_USE_CASES class. It includes a collection of routines
corresponding to use case stories.

When a use case takes the form of a routine with contracts, extracting use
case stories from such a routine becomes a semi-automated task. For example,
the emergency_stop use case accepts two options in its precondition — (1) when
the red ﬂag is shown or (2) when a location error is detected. These options
map to the following use case stories written in the uniﬁed approach / with OO
requirements:

emergency_stop_red_flag_story

require car.red_flag_is_shown
do emergency_stop end

emergency_stop_location_error_story

require car.location_error_is_detected
do emergency_stop end
These routines represent the two diﬀerent paths through the emergency_stop
use case, characterized by their preconditions. The connection with the parent
use case is visible because the stories call the routine encoding the use case. The
two routines must be exercised at least once with test input that meets their
preconditions.

A similar analysis makes it possible to extract 5 use case stories from the

race_no_obstacles use case:
• 3 for each possible loop exit condition.

23

• 1 corresponding to the true antecedent of the implication in the second

postcondition assertion.

• 1 corresponding to the true consequent and false antecedent of the said

implication.

The full collection of the extracted use case stories may be found in a publicly

available repository [13].

6.5. Logical vs. time constraints

The diﬀerence between contract-based and scenario-based speciﬁcation, pre-
sented in section 5.1, can be illustrated in the “main scenario” of “Race without
obstacles” use case of section 6.3.

As a speciﬁcation, this scenario expresses, for example, that the system
calculates local plan and then follows it. But the scenario-based speciﬁcation
deﬁnes it in the form of a strict sequence of operations which does not cover
the wide range of possible scenarios. Only three extensions are listed, yet the
number should not be misleading. In fact, they can coincide in many diﬀerent
variations. For example, the green ﬂag can be shown some time after the yellow
ﬂag is displayed. The green ﬂag is not even listed in the extensions as it is not an
extension to a main ﬂow. Yet this scenario is possible. In the same way, the red
ﬂag can be shown after a yellow ﬂag and so on. Many unexpected events may
occur in an arbitrary order and combinations, making it very hard to capture
them with a standard use case template. Describing a few such scenarios is
useful as part of requirements elicitation, but it is more eﬀective to deﬁne the
logical constraints to express the resulting requirements. We can formulate the
desired and permissible sequences of operations using contracts. The listing
below demonstrates that the local plan must be calculated before a car can move.

class CONTROL_MODULE
feature

car: RACECAR

move

-- Move at the calculated path and velocity

require car.local_plan_is_calculated
deferred end

end

7. Discussion

7.1. Related work

In Object-Oriented Analysis and Design (OOAD) use cases along with object
models are the techniques used for requirements analysis, from a while or
more recently [14, 17, 6, 1, 21]. Unlike the Uniﬁed approach, in the OOAD
approach the process of software development is not seamless and involves several
notations (natural language, UML, possibly formal languages). Some methods

24

for conversion between notations have been proposed [22, 1, 19, 21]. However, the
process of conversion is prone to errors and its outcome is only probabilistically
correct [22]. As a result, the source code cannot be statically veriﬁed against
the requirements. Another distinction is that the uniﬁed approach facilitates
specifying abstract properties which are less restrictive than scenarios.

7.2. Limitations

The work presented here is a conceptual contribution to the area of require-
ments and design methodology, and has not had undergone any systematic
empirical validation. The case study of section 6 serves as an illustration of the
approach on a signiﬁcant ongoing project.

In the absence of validation this article makes no claim that the approach
presented here increases productivity or decreases the defects in released products.
The claims that it does make are on the level of logical analysis: that object-
oriented technology is powerful enough to encompass many techniques that are
typically presented as separate. Many seminal ideas in the progress of software
methodology, from structured programming to object-oriented programming and
design patterns, were all introduced ahead of any empirical validation. Without
implying any comparison value, the present work is in that tradition of presenting
methodological ideas and making them open to validation.

We do plan a series of experiments designed to assess the eﬀects on directly
measurable attributes of the software process and products. In the meantime,
the next section summarizes the conceptual arguments.

8. Conclusion

Two of the central problems of software engineering, as relevant to require-
ments as for design and implementation, are size and change. Software systems
can be large and complex; they must adapt to modiﬁcation. Any approach to
software construction must be judged by its ability to help address these issues.
On the design and implementation side, object-oriented techniques meet
this criterion: thanks to techniques of class-based modularity, information
hiding, genericity and inheritance, they have shown that they can support the
development of large, evolving systems.

This article has presented the application of object-oriented ideas to require-
ments, where we may expect that they yield the same beneﬁts. The key result is
that we do not need to treat object-oriented requirements as a competitor to
other popular requirements techniques such as use cases, use case slices and user
stories. Object-oriented decomposition is at a higher level of generality than
such procedural techniques and encompasses them. More speciﬁcally:
• The core idea of object-oriented decomposition is to use classes as the basic

modular unit.

• The most intuitively appealing view of a class is that it describes a set of
objects. For requirements, this concept of object is already rich in possibilities,
since it makes it possible to describe, in a simple and natural way, concrete

25

and abstract objects from a system’s environment, such as a library book or a
car-racing schedule (in the examples of this paper).

• Beyond this initial view of objects, however, the full notion of object is more
general: the most important characteristic of a class is that it gathers a group of
operations (commands and queries) applicable to a given abstraction. Beyond
environment objects, such an abstraction can describe a system concept, such
as elements of a design pattern.

• An object can also, in this spirit, describe a group of scenarios (use cases, user
stories) relative to a set of abstractions, or a group of tests exercising these
abstractions.

Applying these ideas results in a scheme that encompasses all the major re-
quirements techniques in a general framework, with the advantages of conceptual
consistency (as everything proceeds from a single overall idea, object technology)
and uniﬁcation of notations, and the potential of transferring the OO beneﬁts of
scalability and extendibility to the crucial discipline of requirements engineering.

8.1. Future work

One direction of future work is to apply the approach to several case studies
to provide more evidence for method validation. Another direction is to enrich
the approach with tools that will improve its usability. Finally, we aim to perform
a user study to evaluate the approach’s usability and eﬀectiveness.

References

[1] A. Anda and D. Amyot. An optimization modeling method for adaptive
systems based on goal and feature models. In 2020 IEEE Tenth International
Model-Driven Requirements Engineering (MoDRE), pages 11–20, 2020.

[2] K. Beck. Test-driven development: by example. Addison-Wesley Professional,

2003.

[3] A. Cockburn. Writing Eﬀective Use Cases. Addison-Wesley Longman

Publishing Co., Inc., 2000.

[4] E. Gamma, R. Helm, R. Johnson, and J. M. Vlissides. Design Patterns: El-
ements of Reusable Object-Oriented Software. Addison-Wesley Professional,
Boston MA, 1 edition, 1994.

[5] M. Glinz. Problems and deﬁciencies of UML as a requirements speciﬁcation
language. In Tenth International Workshop on Software Speciﬁcation and
Design. IWSSD-10 2000, pages 11–22, 2000.

[6] I. Jacobson, M. Christerson, P. Jonsson, and G. Övergaard. Object Oriented
Software Engineering: A Use Case Driven Approach. Addison-Wesley,
Boston MA, 1992.

26

[7] I. Jacobson, I. Spence, and K. Bittner. USE-CASE 2.0 The Guide to
Succeeding with Use Cases. Ivar Jacobson International SA., Alexandria,
Virginia, Dec. 2011.

[8] I. Jacobson, I. Spence, and B. Kerr. Use-case 2.0: The hub of software

development. Queue, 14(1):94–123, jan 2016.

[9] G. T. Leavens, A. L. Baker, and C. Ruby. Jml: A notation for detailed
design. In behavioral speciﬁcations of Businesses and Systems, pages 175–188.
Springer, 1999.

[10] B. Meyer. Object-oriented software construction, volume 2. Prentice hall

Englewood Cliﬀs, 1997.

[11] B. Meyer. Handbook of Requirements and Business Analysis. Springer, New

York, NY, 1 edition, 2022 (to appear).

[12] A. Naumchev and B. Meyer. Complete contracts through speciﬁcation
drivers. In 10th Int. Symp. on Theoretical Aspects of Software Engineering
(TASE), pages 160–167. IEEE Comp. Society, 2016.

[13] M. Naumcheva. Roborace repository. https://github.com/mnaumcheva/

Roborace_requirements_code, 2022.

[14] O. Pastor, E. Insfrán, V. Pelechano, J. Romero, and J. Merseguer. Oo-
method: an oo software production environment combining conventional
and formal methods. In International Conference on Advanced Information
Systems Engineering, pages 145–158. Springer, 1997.

[15] M. Petre. UML in practice. In 2013 35th International Conference on

Software Engineering (ICSE), pages 722–731, 2013.

[16] Roborace. https://roborace.com, 2022.

[17] J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, W. E. Lorensen, et al.
Object-oriented modeling and design, volume 199. Prentice-hall Englewood
Cliﬀs, NJ, 1991.

[18] R. Schaaf. Use-case slice based product backlog - an example. https://xebi
a.com/blog/use-case-slice-based-product-backlog-an-example/,
2012.

[19] M. Soavi, N. Zeni, J. Mylopoulos, and L. Mich. From legal contracts to for-
mal speciﬁcations: A progress report. In Joint Proceedings of REFSQ 2021
Workshops with the 27th International Conference on Requirements Engi-
neering: Foundation for Software Quality (REFSQ 2021), Essen, Germany,
April 12, 2021, volume 2857 of CEUR Workshop Proceedings. CEUR-WS.org,
2021.

27

[20] J. Tschannen, C. A. Furia, M. Nordio, and N. Polikarpova. Autoproof: Auto-
active functional veriﬁcation of object-oriented programs. In International
conference on tools and algorithms for the construction and analysis of
systems, pages 566–580. Springer, 2015.

[21] P. von Olberg and L. Strey. Approach to generating functional test cases
from bpmn process diagrams. In 2022 IEEE 30th International Requirements
Engineering Conference Workshops (REW), pages 1–5, 2022.

[22] T. Yue and et al. atoucan: an automated framework to derive uml analysis
models from use case models. ACM Trans. on Soft. Eng. and Methodology
(TOSEM), 24(3):1–52, 2015.

28

