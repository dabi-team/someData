AvaliaÃ§Ã£o dos impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o
monolÃ­tica para microsserviÃ§os: Um estudo de caso

Tulio Ricardo Hoppen Barzotto
Universidade do Vale do Rio do Sinos (Unisinos)
SÃ£o Leopoldo, Rio Grande do Sul, Brasil
tulio.barzotto@gmail.com

Kleinner Farias
PPGCA, Universidade do Vale do Rio do Sinos (Unisinos)
SÃ£o Leopoldo, Rio Grande do Sul, Brasil
kleinnerfarias@unisinos.br

2
2
0
2

g
u
A
2

]
E
S
.
s
c
[

2
v
8
7
8
3
1
.
3
0
2
2
:
v
i
X
r
a

ABSTRACT
AplicaÃ§Ãµes monolÃ­ticas estÃ£o sendo decompostas para uma arquite-
tura de microsserviÃ§os, visando melhorar a manutenabilidade, per-
fomance e modularizaÃ§Ã£o. Embora tais decomposiÃ§Ãµes tenham sido
amplamente realizadas atualmente na indÃºstria, pouco Ã© reportado
na literatura sobre os impactos destas decomposiÃ§Ãµes. Este trabalho,
portanto, reporta um estudo de caso realizado para investigar os
impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o real da indÃºstria para a
arquitetura de microsserviÃ§os. A aplicaÃ§Ã£o alvo do estudo refere-se
a uma operaÃ§Ã£o de saque, realizada por uma instituiÃ§Ã£o financeira,
a qual foi extraÃ­da de uma aplicaÃ§Ã£o monolÃ­tica para uma aplicaÃ§Ã£o
baseada em microsserviÃ§os. Em particular, mÃ©tricas foram aplicadas
nas aplicaÃ§Ã£o monolÃ­tica e na baseada em microsserviÃ§os, visando
quantificar o acoplamento, coesÃ£o, consumo de CPU e consumo
de memÃ³ria. Os resultados obtidos apontam que a arquitetura de
microsserviÃ§os gerou melhores resultados para as mÃ©tricas de mod-
ularidade de software, alÃ©m de menor consumo de memÃ³ria e CPU.
Por fim, este trabalho traz reflexÃ£o e aponta para desafios e direÃ§Ãµes
futuras de pesquisa que precisam ser exploradas pela academia e a
indÃºstria.

KEYWORDS
Arquitetura monolÃ­tica; Arquitetura de microsserviÃ§os; Modular-
izaÃ§Ã£o; Estudo de caso; Performance

1 INTRODUÃ‡ÃƒO
As aplicaÃ§Ãµes monolÃ­ticas podem ser caracterizadas como um Ãºnico
artefato de software executÃ¡vel, tendo seus mÃ³dulos altamente
acoplados e os requisitos implementados de forma entrelaÃ§ada e
espalhada entre os mÃ³dulos da aplicaÃ§Ã£o [46]. Atualmente, a ar-
quitetura monolÃ­tica vem perdendo espaÃ§o para a arquitetura de mi-
crosserviÃ§os, evidenciando a popularidade, atravÃ©s de como as apli-
caÃ§Ãµes sÃ£o entendidas, concebidas e desenhadas [14, 39]. Em partic-
ular, as constantes modificaÃ§Ãµes dos requisitos e volatilidade dos am-
bientes de negÃ³cio provocam mudanÃ§as constantes das aplicaÃ§Ãµes
monolÃ­ticas [34, 40], dificultando as realizaÃ§Ãµes das manutenÃ§Ãµes,
aumentado as estimativas de esforÃ§o [11], elevando o esforÃ§o cog-
nitivo de desenvolvedores na compreensÃ£o de cÃ³digo [25]. AlÃ©m
disso, a ausÃªncia de documentaÃ§Ã£o das aplicaÃ§Ãµes monolÃ­ticas nas
empresas aumenta o desafio da realizaÃ§Ã£o das manutenÃ§Ãµes [20, 29].
Com o uso da arquitetura de microsserviÃ§os, que divide a apli-
caÃ§Ã£o em um conjunto de serviÃ§os, que gera bases de cÃ³digos
menores, que podem ser compreendidos mais facilmente pelos
desenvolvedores, permite o desenvolvimento contÃ­nuo, sem afe-
tar a aplicaÃ§Ã£o como um todo, assim como uma sÃ©rie de outros
benefÃ­cios, nÃ£o encontrados na arquitetura monolÃ­tica. Nesta linha,

Ã© salientada a importÃ¢ncia dos temas â€œmicrosserviÃ§osâ€ e â€œdecom-
posiÃ§Ã£o de aplicaÃ§Ãµes monolÃ­ticasâ€, uma vez que possibilita ciclos
de desenvolvimento de software menores, caracterizando aumento
de performance e implantaÃ§Ãµes mais Ã¡geis, times menores e mais
especializados. Destaca-se que a arquitetura monolÃ­tica possui uma
forte desvantagem, jÃ¡ que, alteraÃ§Ãµes na base de cÃ³digo ou implan-
taÃ§Ãµes afetam a aplicaÃ§Ã£o como um todo, seja por alteraÃ§Ãµes de
cÃ³digo ou disponibilidade durante novas implantaÃ§Ãµes. Em con-
trapartida, a arquitetura de microsserviÃ§os possui uma estrutura
modular que facilita as mudanÃ§as, tornando alteraÃ§Ãµes de cÃ³digos e
implantaÃ§Ãµes pontuais, sem necessariamente afetar toda a aplicaÃ§Ã£o
ou necessidade de avisar todos os desenvolvedores sobre o novo
cÃ³digo inserido.

Alguns trabalhos foram propostos, com finalidade de discussÃ£o
do tema, por meio de anÃ¡lise comparativa. Autores como [14, 31]
e outros, serviram como base para embasar o desenvolvimento do
presente trabalho. Os trabalhos citados serviram especialmente para
anÃ¡lise comparativa do tema, de acordo com critÃ©rios comparativos,
como contexto de avaliaÃ§Ã£o, domÃ­nio da aplicaÃ§Ã£o, mÃ©todos de
estudo empÃ­rico e tipos de mÃ©tricas.

Ressalta-se que a problemÃ¡tica do tema em questÃ£o, Ã© escassa na
literatura, visto que a arquitetura de microsserviÃ§os Ã© relativamente
recente, especialmente carece de estudos que propunham a decom-
posiÃ§Ã£o de aplicaÃ§Ãµes monolÃ­ticas, como base para a arquitetura de
microsserviÃ§os. AlÃ©m disso, costuma-se dar Ãªnfase na arquitetura
monolÃ­tica na maioria dos artigos e trabalhos sobre temas similares,
com exceÃ§Ã£o de trabalhos como [8, 26, 41, 43, 47], onde Ã© realizada
uma revisÃ£o sistemÃ¡tica, tanto da arquitetura monolÃ­tica, quanto
na arquitetura de microsserviÃ§os e suas respectivas aplicaÃ§Ãµes.

Neste sentido, essa pesquisa executa um estudo experimental,
visando avaliar o impacto das mÃ©tricas de consumo de CPU, con-
sumo de memÃ³ria e modularidade de software. Para isso foi execu-
tado um estudo empÃ­rico em que uma aplicaÃ§Ã£o real da empresa
hipotÃ©tica Cooperativa Utile, onde foi analisada a versÃ£o da apli-
caÃ§Ã£o monolÃ­tica em comparaÃ§Ã£o com a sua versÃ£o equivalente,
seguindo a arquitetura baseada em microsserviÃ§os. A modularidade
de software foi analisada sob os atributos de acoplamento e coesÃ£o,
usando 5 mÃ©tricas voltadas para aplicaÃ§Ãµes que utilizam linguagem
orientada a objetos. As mÃ©tricas de consumo de CPU e consumo
de memÃ³ria foram analisadas atravÃ©s de testes de carga, simulando
a execuÃ§Ã£o do fluxo de negÃ³cio equivalente em ambas versÃµes da
aplicaÃ§Ã£o.

O presente trabalho se encontra estruturado da seguinte forma.
SeÃ§Ã£o 2 apresenta a fundamentaÃ§Ã£o teÃ³rica do tema dividido em
subtÃ³picos; SeÃ§Ã£o 3 traz os trabalhos relacionados ao tema para
anÃ¡lise comparativa, assim como a metodologia exposta de cada
trabalho e subtÃ³picos com a evidenciaÃ§Ã£o das oportunidades do

 
 
 
 
 
 
presente trabalho; SeÃ§Ã£o 4 traz Ã  luz, a metodologia utilizada no
trabalho e subtÃ³picos que salientam os objetivos e as questÃµes de
pesquisa explÃ­citas, hipÃ³teses, seleÃ§Ã£o da aplicaÃ§Ã£o alvo, variÃ¡veis
e mÃ©todos de quantificaÃ§Ã£o, mÃ©tricas selecionadas, procedimento
de anÃ¡lise e experimental; SeÃ§Ã£o 5 traz os resultados obtidos; Por
fim, a SeÃ§Ã£o 6 aborda as conclusÃµes e os trabalhos futuros. JÃ¡ na
estruturaÃ§Ã£o pÃ³s-textual, encontram-se as referÃªncias bibliogrÃ¡ficas
utilizadas.

2 FUNDAMENTAÃ‡ÃƒO TEÃ“RICA
Esta seÃ§Ã£o aborda os conceitos teÃ³ricos usados durante a con-
struÃ§Ã£o e desenvolvimento do estudo. A SeÃ§Ã£o estÃ¡ dividida da
seguinte forma: a SeÃ§Ã£o 2.1 descreve os conceitos sobre a arquite-
tura monolÃ­tica; a SeÃ§Ã£o 2.2 descreve os conceitos sobre a arquite-
tura de microsserviÃ§os; a SeÃ§Ã£o 2.3 descreve os conceitos sobre a
performance de software; por fim a SeÃ§Ã£o 2.4 descreve os conceitos
sobre a modularizaÃ§Ã£o de software.

2.1 Arquitetura monolÃ­tica
Para um melhor entendimento sobre a arquitetura de microsserviÃ§os
e como a tecnologia evoluiu para isto, serÃ¡ preciso primeiramente
entender a arquitetura monolÃ­tica tradicional.

Na arquitetura monolÃ­tica, todas as funcionalidades estÃ£o en-
capsuladas em uma Ãºnica aplicaÃ§Ã£o, fazendo com que os mÃ³dulos
nÃ£o possam ser executados independentemente [14]. Este tipo de
arquitetura torna a aplicaÃ§Ã£o altamente acoplada e toda a lÃ³gica
para processar a requisiÃ§Ã£o Ã© executada em um Ãºnico processo, que
usam os mesmos recursos de hardware, como memÃ³ria RAM, CPU
e armazenamento de dados. Devido ao fato de todo o desenvolvi-
mento estar em um Ãºnico executÃ¡vel, uma Ãºnica alteraÃ§Ã£o de cÃ³digo
pode afetar todos os recursos que a aplicaÃ§Ã£o provÃª, gerando neces-
sariamente um novo build e um redeploy de toda a aplicaÃ§Ã£o [38].
Enquanto a arquitetura monolÃ­tica Ã© uma boa escolha para iniciar
um projeto, jÃ¡ que isso permite que vocÃª explore a complexidade de
um sistema e os limites de seus componentes [21]. Entretanto, os
benefÃ­cios vÃ£o desaparecendo, conforme o cÃ³digo fonte da aplicaÃ§Ã£o
fica maior. Quanto maior o tamanho da aplicaÃ§Ã£o, maior a complex-
idade, resultando em um grande nÃºmero de dependÃªncias, o que
causa alto acoplamento [14, 38]. Com o objetivo de modernizaÃ§Ã£o
destas aplicaÃ§Ãµes, o processo de decomposiÃ§Ã£o surge como atividade
central, visando utilizar tecnologias emergentes e de arquiteturas
de software distribuÃ­das e de alta disponibilidade [27].

2.2 Arquitetura de microsserviÃ§os
De acordo com [4], os microsserviÃ§os sÃ£o resultados de uma abor-
dagem arquitetÃ´nica, focada na decomposiÃ§Ã£o de aplicaÃ§Ãµes em
serviÃ§os, com propÃ³sito Ãºnico e com baixo acoplamento, sendo
gerenciadas por equipes multifuncionais, para entrega e manutenÃ§Ã£o
de sistemas de software complexos rapidamente. Para [23], a ar-
quitetura de microsserviÃ§os consiste em uma abordagem para de-
senvolver um Ãºnico aplicativo, como um conjunto de pequenos
serviÃ§os, cada um sendo executado de forma isolada e se comuni-
cando de forma leve, geralmente uma API de recursos HTTP.

Barzotto and Farias

Segundo [23], nÃ£o existe em particular uma definiÃ§Ã£o do que
seja arquitetura de microsserviÃ§os, mas existem certas caracterÃ­s-
ticas que o tornam sujeitos a classificar como arquitetura de mi-
crosserviÃ§os, "Como acontece com qualquer definiÃ§Ã£o que descreve
caracterÃ­sticas comuns, nem todas as arquiteturas de microsserviÃ§os
tÃªm todas as caracterÃ­sticas, mas esperamos que a maioria das
arquiteturas de microsserviÃ§os exibam a maioria das caracterÃ­sti-
cas" [23, Traduzido pelo autor]. Para [33], essas caracterÃ­sticas sÃ£o
mais como princÃ­pios da arquitetura de microsserviÃ§os, os quais
sÃ£o definidos como:

(1) â€œModelar em torno de conceitos de negÃ³ciosâ€, para serem rep-
resentados como contextos limitados e modelos de domÃ­nio
de acordo com padrÃµes do Domain-Driven Design (DDD) [16].
(2) â€œAdotar uma cultura de automaÃ§Ã£oâ€ em testes e implantaÃ§Ã£o;

praticar entrega contÃ­nua.

(3) â€œOcultar detalhes da implementaÃ§Ã£o internaâ€, como bancos
de dados; definir Interfaces de programaÃ§Ã£o de aplicativos
(APIs) independentes de tecnologia.

(4) â€œDescentralizar todas as coisasâ€: por exemplo, aplicar a gov-
ernanÃ§a compartilhada, prefira o serviÃ§o de coreografia ao
invÃ©s de orquestraÃ§Ã£o, use middleware burro, mas endpoints
inteligentes.

(5) Tornar os serviÃ§os â€œimplantÃ¡veis de forma independenteâ€,
por exemplo, deixar versionado (serviÃ§o) endpoints coexis-
tem; implantar apenas um serviÃ§o por host (virtual).

(6) â€œIsolar falhaâ€, por exemplo, introduz disjuntores para tornar

os serviÃ§os robustos.

(7) Ser â€œaltamente observÃ¡velâ€, por exemplo, por meio de moni-

toramento semÃ¢ntico com dados de agregaÃ§Ã£o.

Para fins de conceituaÃ§Ã£o dos diferentes autores, evidencia-se
que ao contrÃ¡rio das nove caracterÃ­sticas que [23] expÃµem, para [33],
apenas sete princÃ­pios sÃ£o vÃ¡lidos para definir a arquitetura de mi-
crosserviÃ§os. PorÃ©m, tanto os princÃ­pios de [33] quanto Ã s caracterÃ­s-
ticas de [23], mesclam-se, seja atravÃ©s da modelagem da aplicaÃ§Ã£o
em torno do negÃ³cio, como a descentralizaÃ§Ã£o da governanÃ§a.

2.3 Performance
Segundo [36], a performance Ã© um fator crucial, pois ela impacta
diretamente na experiÃªncia do usuÃ¡rio ao utilizar um determinado
sistema. A performance estÃ¡ invariavelmente atrelada a capacidade
da mÃ¡quina e sua composiÃ§Ã£o arquitetural, podendo ser medida em
vÃ¡rios parÃ¢metros, como taxa de transferÃªncia, latÃªncia e largura
de banda do sistema [13]. Para fins de catalogaÃ§Ã£o de mediÃ§Ã£o da
performance, Ã© inerente que o desempenho da CPU, sendo a taxa
de transferÃªncia utilizada como quesito para medir a saÃ­da de carga
de trabalho, o desempenho da memÃ³ria que tem como parÃ¢metro a
mediÃ§Ã£o da largura da banda na velocidade de acesso Ã  memÃ³ria e
operaÃ§Ãµes, assim como o desempenho da rede, de disco e outros, os
quais estÃ£o ligados Ã  performance, tanto da arquitetura, quanto da
mÃ¡quina, sendo usados como atributos para conceituaÃ§Ã£o [13].

De acordo com [39], sÃ£o os recursos utilizados sob condiÃ§Ãµes esta-
belecidas que representam o desempenho/performance da arquite-
tura. Esses mesmos recursos estÃ£o ligados Ã  eficiÃªncia do desem-
penho em caracterÃ­sticas, como comportamento do tempo (tempo de
resposta), utilizaÃ§Ã£o de recursos (tipos de recursos utilizados por um
produto), dentre outros. TambÃ©m sÃ£o atributos usados para mediÃ§Ã£o

AvaliaÃ§Ã£o dos impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica para microsserviÃ§os: Um estudo de caso

de performance, ou ao menos caracterizaÃ§Ã£o e conectividade deste
desempenho, a compatibilidade, usabilidade, confiabilidade, segu-
ranÃ§a, manutenibilidade e portabilidade [39]. A arquitetura de mi-
crosserviÃ§os traz complexidade aos testes de desempenho, que sÃ£o
classificados como: tipo caixa preta, portanto, o tipo de teste mais
compatÃ­vel Ã© o end-to-end [10]. Segundo os preceitos de [44], sÃ£o
os testes de desempenho que tÃªm como finalidade a verificaÃ§Ã£o do
software e o cumprimento dos requisitos prÃ©-estabelecidos, como o
tempo de resposta, vazÃ£o e disponibilidade.

2.4 ModularizaÃ§Ã£o
A conceituaÃ§Ã£o de modularizaÃ§Ã£o se dÃ¡ atravÃ©s do compartilhamento
de que Ã© uma atividade na qual a estruturaÃ§Ã£o em mÃ³dulos Ã© ado-
tada, portanto, um sistema complexo Ã© estruturado em vÃ¡rios subsis-
temas independentes (mÃ³dulos) [37]. Ressalta-se a importÃ¢ncia da
diferenciaÃ§Ã£o entre mÃ³dulo (relacionado a uma unidade funcional
independente em relaÃ§Ã£o ao propÃ³sito do produto), modularizaÃ§Ã£o
(estruturaÃ§Ã£o em vÃ¡rios subsistemas) e modularidade (concepÃ§Ã£o
de produtos complexos a partir da combinaÃ§Ã£o de mÃ³dulos relati-
vamente simples) [37]. Para [45], a modularizaÃ§Ã£o se dÃ¡ atravÃ©s de
duas caracterÃ­sticas inerentes ao conceito: 1) similaridade entre a
arquitetura fÃ­sica e funcional do produto; 2) minimizaÃ§Ã£o do grau
de interaÃ§Ã£o entre os componentes fÃ­sicos.

A partir do conceito de modularizaÃ§Ã£o, surge o termo bad smells,
que segundo [22] smells sÃ£o estruturas no cÃ³digo que sugerem a pos-
sibilidade de refatoraÃ§Ã£o. JÃ¡ [35], conceitua smells como "symptoms
of poor design and implementation choices", sendo descrito na liter-
atura, uma catalogaÃ§Ã£o de 104 smells, sendo os mais importantes
duplicate code (DC), large class (LC), feature envy (FE) e outros.
Alguns nÃ£o apresentam tÃ©cnicas, ou atÃ© mesmo ferramentas para
identificaÃ§Ã£o de suas instÃ¢ncias, tornando assim o uso de estratÃ©-
gias, uma opÃ§Ã£o para identificaÃ§Ã£o de alguns bad smells, portanto,
basicamente os bad smells, descrevem possÃ­veis problemas em de-
terminado cÃ³digo, possibilitando oportunidades de refatoraÃ§Ã£o [37].
A evidenciaÃ§Ã£o de bad smells, reforÃ§a a necessidade de exposiÃ§Ã£o
da divida tÃ©cnica.

A dÃ­vida tÃ©cnica Ã© nada mais do que reflexÃ£o dos compromissos
tÃ©cnicos, que podem resultar em benefÃ­cios a curto prazo, mas
em contrapartida, podem causar danos e prejuÃ­zos Ã  qualidade de
um sistema de software a longo prazo [9]. Segundo ressalta [3], a
dÃ­vida tÃ©cnica Ã© inevitÃ¡vel, sendo assim, o enfoque principal nÃ£o
Ã© tentar eliminÃ¡-la, mas mantÃª-la sob controle, por meio de seu
gerenciamento. Ã‰ por conta disso que, a dÃ­vida tÃ©cnica Ã© causada
a partir de uma tomada de decisÃ£o, ou um processo, uma aÃ§Ã£o,
ou falta dela, resultando pela pressÃ£o de uma programaÃ§Ã£o, ou de
cronograma, pela indisponibilidade de uma pessoa chave, ou pela
falta de informaÃ§Ãµes sobre um recurso tÃ©cnico [6].

3 TRABALHOS RELACIONADOS
Esta SeÃ§Ã£o realiza uma anÃ¡lise comparativa dos trabalhos relaciona-
dos. A anÃ¡lise tem por objetivo identificar, destacar as caracterÃ­sticas
comuns e as diferenÃ§as entre os estudos jÃ¡ realizados e o trabalho
proposto. A seÃ§Ã£o estÃ¡ divido da seguinte forma: a SeÃ§Ã£o 3.1 descreve
a metodologia utilizada para escolha dos trabalhos relacionados; a
SeÃ§Ã£o 3.2 Ã© realizada a anÃ¡lise de cinco artigos que satisfazem os

critÃ©rios de seleÃ§Ã£o; a SeÃ§Ã£o 3.3 realiza a comparaÃ§Ã£o dos trabal-
hos, mediante critÃ©rios definidos; por Ãºltimo as oportunidades de
pesquisa identificadas.

3.1 Metodologia para escolha dos trabalhos
Este trabalho utilizou como base de dados o Google Scholar. Foi
utilizada a query de pesquisa com as seguintes palavras-chave:

("microservice*" OR "micro-service") AND ("monolith*") AND

("comparative study" OR "empirical study" OR "performance")

Com base nos resultados obtidos na busca, foram selecionados

cinco artigos pela similaridade com o tema em estudo.

3.2 AnÃ¡lise dos trabalhos relacionados
Nesta seÃ§Ã£o, serÃ¡ realizada uma anÃ¡lise comparativa de cinco trabal-
hos que abordam o tema de anÃ¡lise de performance entre aplicaÃ§Ãµes
com arquitetura monolÃ­tica e microsserviÃ§os.

Gos and Zabierowski (2020) [26]. Neste estudo, os autores
propÃµem uma anÃ¡lise comparativa, entre uma aplicaÃ§Ã£o desen-
volvida em uma arquitetura monolÃ­tica e outra equivalente desen-
volvida em uma arquitetura baseada em microsserviÃ§os. A aplicaÃ§Ã£o
alvo Ã© um sistema de aluguel de carros, contendo as funcionalidades
de consulta, cadastro, aluguel e atualizaÃ§Ã£o do status. A aplicaÃ§Ã£o
monolÃ­tica foi desenvolvida em Java utilizando Spring e um Ãºnico
banco de dados PostgreSQL. A aplicaÃ§Ã£o baseada em arquitetura
de microsserviÃ§os tambÃ©m foi desenvolvida em Java utilizando
Spring, sendo composta por quatro serviÃ§os autÃ´nomos e indepen-
dentes. Os testes de carga foram realizados utilizando a ferramenta
Gatling, onde foram separados em dois cenÃ¡rios, o primeiro visa
simular 1000 requisiÃ§Ãµes feitas por 30 usuÃ¡rios simultaneamente,
jÃ¡ no segundo cenÃ¡rio Ã© um total de 10000 requisiÃ§Ãµes feitas por
30 usuÃ¡rios simultaneamente. Ambos cenÃ¡rios foram aplicados em
requisiÃ§Ãµes GET e requisiÃ§Ãµes POST. Os autores concluem que a ar-
quitetura baseada em microsserviÃ§os Ã© mais eficiente em lidar com
um nÃºmero grande de requisiÃ§Ãµes simultÃ¢neas, alÃ©m de permitir
construir um software de alta qualidade, fÃ¡cil de escalar, confiÃ¡vel
e a longo prazo mais fÃ¡cil de manter. TambÃ©m consideram que a
arquitetura monolÃ­tica Ã© mais eficiente em cargas mais baixas e
mais fÃ¡cil de ser desenvolvida.

Villamizar et al. (2015) [47]. Neste estudo, os autores buscam
avaliar em um cenÃ¡rio real as implicaÃ§Ãµes de uso de uma arquite-
tura baseada em microsserviÃ§os. A aplicaÃ§Ã£o alvo Ã© um sistema de
gestÃ£o de emprÃ©stimos realizados por uma instituiÃ§Ã£o financeira
aos seus clientes. O estudo selecionou apenas dois dos serviÃ§os mais
utilizados, o primeiro serviÃ§o intitulado ğ‘†1 Ã© responsÃ¡vel por gerar
um plano de pagamento, contendo as parcelas do emprÃ©stimo con-
tratado, o segundo serviÃ§o ğ‘†2 Ã© responsÃ¡vel por retornar um plano
de pagamento existente com o respectivo conjunto de parcelas. O
ğ‘†1 utiliza algorÃ­timos para gerar cada plano de pagamento, usando
excessivamente recursos da CPU, o ğ‘†2 realiza a consulta do plano
de pagamento atravÃ©s de um identificador Ãºnico na base de dados.
Considerando a aplicaÃ§Ã£o desenvolvida na arquitetura monolÃ­tica
onde ambos serviÃ§os estÃ£o implementados na mesma aplicaÃ§Ã£o
e expostos via endpoints, temos os seguintes tempos mÃ©dios de
respostas, ğ‘†1 com 3.000 milissegundos e ğ‘†2 em torno de 300 milisse-
gundos. Na versÃ£o da aplicaÃ§Ã£o desenvolvida utilizando arquitetura
baseada em microsserviÃ§os, foram criados dois microsserviÃ§os, um

para implementar as regras do ğ‘†1 e outro as regras do ğ‘†2. Ambas
abordagens da aplicaÃ§Ã£o foram desenvolvidas com Java, utilizando
o framework Play e hospedados em uma soluÃ§Ã£o cloud da Amazon
Web Services (AWS). Utilizaram o JMeter para realizar os testes de
carga e avaliar a performance, onde foram criados dois cenÃ¡rios de
teste aplicados, nas duas aplicaÃ§Ãµes, sendo que o primeiro cenÃ¡rio
de teste Ã© focado no ğ‘†1 executando 30 requisiÃ§Ãµes por minuto, no
segundo cenÃ¡rio de teste focado no ğ‘†2 foram executados 1.100 req-
uisiÃ§Ãµes por minuto. Os autores concluem que os microsserviÃ§os
nÃ£o impactam consideravelmente na latÃªncia de resposta usando
mais instÃ¢ncias, no entanto, a granularidade dos microsserviÃ§os
permite escalonar pontos especÃ­ficos da aplicaÃ§Ã£o, reduzindo os
custos de infraestrutura. TambÃ©m consideram que hÃ¡ benefÃ­cio no
desenvolvimento de software utilizando arquitetura baseada em
microsserviÃ§os, permitindo com que pequenas equipes trabalhem
em pequenos microsserviÃ§os de forma independente. Os autores
identificaram desafios de sistemas distribuÃ­dos ao introduzirem a
arquitetura baseada em microsserviÃ§os, os quais sÃ£o gerenciados
de maneira mais simples, em uma arquitetura monolÃ­tica.

Rudrabhatla (2020) [41]. Este estudo aborda trÃªs tÃ©cnicas de
decomposiÃ§Ã£o de aplicaÃ§Ãµes monolÃ­ticas para microsserviÃ§os e real-
iza uma comparaÃ§Ã£o de performance e latÃªncia entre elas. A apli-
caÃ§Ã£o alvo Ã© um mÃ³dulo de uma aplicaÃ§Ã£o e-commerce, composta
inicialmente por trÃªs entidades de negÃ³cios. Na primeira tÃ©cnica
de decomposiÃ§Ã£o abordada, sugere o uso da tÃ©cnica Domain-Driven
Design, onde usando Common Closure Principle sÃ£o identificadas as
classes que sÃ£o impactadas pela mesma regra de negÃ³cio, devem
estar no mesmo pacote em um Ãºnico microsserviÃ§o. No sentido de
que cada microsserviÃ§o seja autÃ´nomo, cada um possui uma base
dados prÃ³pria e isolada dos demais. A segunda tÃ©cnica aborda a
decomposiÃ§Ã£o baseada em Business capability onde as principais
entidades sÃ£o normalizadas e os microsserviÃ§os sÃ£o construÃ­dos
considerando a transaÃ§Ã£o de negÃ³cio. A granularidade das enti-
dades sÃ£o definidas atÃ© o ponto em que possam ser consideradas
autÃ´nomas e operaÃ§Ãµes de CRUD sÃ£o criadas para gerenciamento.
Na terceira e Ãºltima tÃ©cnica abordada, a decomposiÃ§Ã£o Ã© baseada em
uma abordagem hÃ­brida, combinando as duas primeiras tÃ©cnicas,
onde sÃ£o identificados subdomÃ­nios utilizando Business capability
gerando microsserviÃ§os unificados. O autor realiza uma compara-
Ã§Ã£o de desempenho e latÃªncia entre as trÃªs abordagens, observando
os tempos de respostas para persistÃªncia dos dados em banco de
dados. Como resultado da anÃ¡lise comparativa, o autor pode demon-
strar que a tÃ©cnica Domain-Driven Design foi superior a Business
capability, mas que em uma aplicaÃ§Ã£o real time a abordagem hÃ­brida
produziu melhores resultados.

Tapia et al. (2020) [43]. Este estudo propÃµe uma anÃ¡lise com-
parativa de performance entre arquitetura monolÃ­tica e arquitetura
baseada em microsserviÃ§os. A aplicaÃ§Ã£o alvo de estudo Ã© um fÃ³rum,
contendo trÃªs entidades de negÃ³cio. Primeiramente sÃ£o descritas
as estruturas tÃ©cnicas, onde aplicaÃ§Ã£o monolÃ­tica Ã© desenvolvida
utilizando a linguagem Node.js, contendo as entidades de negÃ³cio
implementadas na mesma aplicaÃ§Ã£o, hospedada em uma mÃ¡quina
virtual. A aplicaÃ§Ã£o equivalente em arquitetura baseada em mi-
crosserviÃ§os tambÃ©m Ã© desenvolvida utilizando a linguagem Node.js.
As entidades de negÃ³cios estÃ£o separadas em aplicaÃ§Ãµes distintas,
conteinerizadas, utilizando Docker e hospedadas na estrutura de
cloud da Amazon. O processo de coleta de dados Ã© feito atravÃ©s de

Barzotto and Farias

testes de estresse, separados por dois cenÃ¡rios, onde o primeiro
realiza requisiÃ§Ãµes via HTTP para gerar dados no banco de dados, o
segundo cenÃ¡rio realiza requisiÃ§Ãµes via HTTP para selecionar dados
persistidos no banco de dados. O estudo tambÃ©m aplica o modelo
matemÃ¡tico Non-Parametric Regression Model para relacionar da-
dos de recursos computacionais utilizados e assim poder avaliar
os dados coletados. Os autores concluem que o uso da arquitetura
baseada em microsserviÃ§os Ã© mais vantajosa em relaÃ§Ã£o aos recursos
de hardware e reduÃ§Ã£o de custos.

BjÃ¸rndal et al. (2020) [8]. Neste estudo os autores procuram
verificar os benefÃ­cios de migraÃ§Ã£o de uma arquitetura monolÃ­tica
para uma arquitetura baseada em microsserviÃ§os, realizando exper-
imentos de benchmarking. A aplicaÃ§Ã£o alvo Ã© um sistema fictÃ­cio
de biblioteca, contendo as funcionalidades necessÃ¡rias para login
e emprÃ©stimo de livros. A aplicaÃ§Ã£o com arquitetura monolÃ­tica
foi desenvolvida utilizando ASP.NET Core e base de dados central-
izada utilizando SQL Server, jÃ¡ a aplicaÃ§Ã£o com arquitetura baseada
em microsserviÃ§os gerou quatro serviÃ§os, representando as enti-
dades de domÃ­nio, cada um com seu contexto limitado e base de
dados prÃ³pria. Foram aplicados dois experimentos de benchmark-
ing, onde a aplicaÃ§Ã£o foi executada em uma estrutura local e outra
hospedada no Azure Cloud. As mÃ©tricas utilizadas em ambos ex-
perimentos foram Throughput, Latency, Scalability e recursos de
hardware (CPU, Memory, Network). Os experimentos sÃ£o compostos
por uma execuÃ§Ã£o simples e outra complexa, todos eles executados
utilizando JMeter. Os autores concluem que a arquitetura monolÃ­tica
foi melhor em todas mÃ©tricas, exceto na escalabilidade, entretanto
consideram pontos em que o ambiente e aplicaÃ§Ã£o podem ter lev-
ado a este resultado, como o tamanho reduzido da aplicaÃ§Ã£o, se
comparado a uma aplicaÃ§Ã£o real, assim como gargalos de uso entre
kubernetes, Docker e os prÃ³prios bancos de dados. Concluem tam-
bÃ©m que apesar das consideraÃ§Ãµes anteriores, a arquitetura baseada
em microsserviÃ§os se torna uma melhor alternativa, considerando
uma grande quantidade de usuÃ¡rios simultÃ¢neos, devido a mÃ©trica
de escalabilidade ter sido melhor.

3.3 AnÃ¡lise comparativa dos trabalhos

relacionados

Nesta seÃ§Ã£o serÃ¡ realizada a comparaÃ§Ã£o dos trabalhos selecionados
no item 3.2 com base nos critÃ©rios comparativos definidos:

â€¢ Contexto de AvaliaÃ§Ã£o: Este critÃ©rio irÃ¡ avaliar se a pro-
posta do trabalho foi avaliada em um ambiente acadÃªmico
ou na indÃºstria.

â€¢ DomÃ­nio da aplicaÃ§Ã£o: Este critÃ©rio irÃ¡ avaliar qual o domÃ­nio
da aplicaÃ§Ã£o alvo: automotivo, comunicaÃ§Ã£o, financeiro, liter-
atura, varejo.

â€¢ MÃ©todos de estudo empÃ­rico: Este critÃ©rio irÃ¡ avaliar qual
o mÃ©todo de avaliaÃ§Ã£o foi utilizado para avaliar as arquite-
turas propostas pelos trabalhos: estudo de caso, experimento
ou levantamento.

â€¢ Tipos de MÃ©tricas: Este critÃ©rio irÃ¡ avaliar quais mÃ©tricas
de avaliaÃ§Ã£o foram utilizadas pelos trabalhos: custos, disponi-
bilidade, escalabilidade, performance, qualidade de cÃ³digo, se-
guranÃ§a.

Sobre as principais contribuiÃ§Ãµes, apenas o trabalho [47] foi apli-
cado na indÃºstria. Os trabalhos [26], [41], [43] e [8] foram aplicados

AvaliaÃ§Ã£o dos impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica para microsserviÃ§os: Um estudo de caso

Table 1: ComparaÃ§Ã£o dos trabalhos relacionados

CritÃ©rios

Contexto de avaliaÃ§Ã£o

DomÃ­nio da aplicaÃ§Ã£o

MÃ©todos de estudo empÃ­rico

Tipo de MÃ©tricas

AcadÃªmico
IndÃºstria
Automotivo
ComunicaÃ§Ã£o
Financeiro
Literatura
Varejo
Estudo de caso
Experimento controlado
Survey (Levantamento)
Custos
Disponibilidade
Escalabilidade
Performance
Qualidade de cÃ³digo
SeguranÃ§a

Trabalhos

]
6
2
[

)
0
2
0
2
(

i
k
s
w
o
r
e
i
b
a
Z
d
n
a

s
o
G
+
-
+
-
-
-
-
+
-
-
-
-
-
+
-
-

]
7
4
[

)
5
1
0
2
(

.
l
a

t
e

r
a
z
i
m
a
l
l
i

V
-
+
-
-
+
-

+
-
-
+
-
+
+
-
-

]
1
4
[

)
0
2
0
2
(

a
l
t
a
h
b
a
r
d
u
R
+
-
-
-
-
-
+
+
-
-
-
-
-
+
-
-

]
3
4
[

)
0
2
0
2
(

.
l
a

t
e

a
i
p
a
T
+
-
-
+
-
-
-
+
-
-
-
-
+
+
-
-

]
8
[

)
0
2
0
2
(

.
l
a

t
e

l
a
d
n
r
Ã¸
j
B
+
-
-
-
-
+
-
+
-
-
-
-
+
+
-
-

Legenda: (+) Aplicado (-) NÃ£o aplicado

na acadÃªmia. O domÃ­nio da aplicaÃ§Ã£o alvo no estudo [26] foi auto-
motivo, no estudo [47] foi financeiro, no estudo [41] foi varejo, no
estudo [43] foi comunicaÃ§Ã£o e no estudo [8] foi literatura. Como
mÃ©todos de avaliaÃ§Ã£o dos trabalhos selecionados, todos os trabal-
hos apresentaram um estudo de caso de suas proposta. Dos estudos
selecionados apenas o [47] considerou os custos como mÃ©trica. Os
estudos [43] e [8] avaliaram como mÃ©trica a escalabilidade. No en-
tanto, todos os estudos consideraram a mÃ©trica de performance
para avaliaÃ§Ã£o.

Oportunidades de pesquisa. ApÃ³s a anÃ¡lise dos artigos, as
seguintes oportunidades de pesquisa foram identificadas: (1) avali-
aÃ§Ã£o entre ambas arquiteturas considerando a performance; e (2)
avaliaÃ§Ã£o da complexidade de cÃ³digo considerando mÃ©tricas de
modularidade de software;

Destas oportunidades, este trabalho procura gerar conhecimento
empÃ­rico sobre os impactos da arquitetura monolÃ­tica e da arquite-
tura baseada em microsserviÃ§os na modularidade e na performance.

4 METODOLOGIA
Esta seÃ§Ã£o apresenta as principais decisÃµes que fundamentam a
anÃ¡lise comparativa do estudo de caso [7, 24]. Para comeÃ§ar, sÃ£o
apresentados os objetivos e as questÃµes de pesquisa (SeÃ§Ã£o 4.1).

Em seguida, sÃ£o descritas as hipÃ³teses (SeÃ§Ã£o 4.2). Na sequÃªncia
a seleÃ§Ã£o da aplicaÃ§Ã£o alvo (SeÃ§Ã£o 4.3). As variÃ¡veis e mÃ©todos
de quantificaÃ§Ã£o considerados, tambÃ©m sÃ£o discutidos em detal-
hes (SeÃ§Ã£o 4.4). A seleÃ§Ã£o de mÃ©tricas Ã© abordada na sequÃªncia
(SeÃ§Ã£o 4.5). A descriÃ§Ã£o do procedimento de anÃ¡lise (SeÃ§Ã£o 4.7).
Finalmente, o procedimento experimental Ã© apresentado (SeÃ§Ã£o 4.6).
Todas essas etapas metodolÃ³gicas foram baseadas em diretrizes
prÃ¡ticas em estudos empÃ­ricos [19].

4.1 Objetivo e QuestÃµes de Pesquisa
Este estudo tenta essencialmente avaliar os efeitos do estilo de
arquitetura de microsserviÃ§os na performance e modularidade de
software. Busca-se investigar os efeitos da performance de hard-
ware, atravÃ©s de duas mÃ©tricas: consumo de memÃ³ria e consumo de
CPU [8]. No entanto, busca-se investigar os efeitos na modularidade
de software atravÃ©s de duas variÃ¡veis [12]: acoplamento e coesÃ£o.
Esses efeitos sÃ£o investigados no contexto de uma aplicaÃ§Ã£o real
do sistema financeiro (SeÃ§Ã£o 4.3), a qual foi construÃ­da seguindo
o estilo arquitetural de microsserviÃ§os, resultado de um processo
de decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica (SeÃ§Ã£o 4.3.1). Com
isso em mente, o objetivo deste estudo Ã© estabelecido com base no
modelo GQM [42].

analisar estilos arquiteturais
com o propÃ³sito de investigar seus efeitos
com relaÃ§Ã£o Ã  modularidade de software e performance
da perspectiva dos desenvolvedores
no contexto da evoluÃ§Ã£o tecnolÃ³gica

Este estudo tem como foco principalmente avaliar os efeitos da
decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica em uma arquitetura
de microsserviÃ§os. Desta forma, o foco serÃ¡ em duas questÃµes de
pesquisa:

â€¢ QP1: Qual seria o efeito na modularidade de software de apli-
caÃ§Ãµes monolÃ­ticas em comparaÃ§Ã£o com aplicaÃ§Ãµes baseadas
em microsserviÃ§os?

â€¢ QP2: Qual seria o efeito na performance de aplicaÃ§Ãµes monolÃ­ti-

cas em comparaÃ§Ã£o com aplicaÃ§Ãµes baseadas em microsserviÃ§os?

4.2 HipÃ³teses
HipÃ³tese 1. Conjectura-se que a arquitetura monolÃ­tica tende a gerar
aplicaÃ§Ãµes maiores, com um grande nÃºmero de dependÃªncias, o
que causa alto acoplamento do software [14, 38]. No entanto, o
estilo arquitetural de microsserviÃ§os separa a aplicaÃ§Ã£o em serviÃ§os
independentes [16], promovendo o baixo acoplamento e a alta co-
esÃ£o [33]. Consequentemente, conjectura-se que os microsserviÃ§os
resultantes da decomposiÃ§Ã£o irÃ£o possuir maior modularizaÃ§Ã£o do
software. Desta forma, declarando as hipÃ³teses nula e alternativa
da seguinte forma:

HipÃ³tese Nula 1, H1â€“0: NÃ£o hÃ¡ diferenÃ§a entre as
mÃ©tricas de modularidade de software utilizando
arquitetura de microsserviÃ§os em comparaÃ§Ã£o com
a arquitetura monolÃ­tica.

ğ» 1â€“0 : ğ‘€ğ‘œğ‘‘ğ‘¢ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ (ğ‘€ğ‘–ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘–ğ‘ğ‘œ) = ğ‘€ğ‘œğ‘‘ğ‘¢ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ (ğ‘€ğ‘œğ‘›ğ‘œğ‘™ğ‘–ğ‘¡ğ‘–ğ‘ğ‘)

(1)

HipÃ³tese alternativa 1, H1â€“1: A arquitetura de
microsserviÃ§os possui maior modularidade de soft-
ware em comparaÃ§Ã£o com a arquitetura monolÃ­tica.

ğ» 1â€“1 : ğ‘€ğ‘œğ‘‘ğ‘¢ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ (ğ‘€ğ‘–ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘–ğ‘ğ‘œ) > ğ‘€ğ‘œğ‘‘ğ‘¢ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ (ğ‘€ğ‘œğ‘›ğ‘œğ‘™ğ‘–ğ‘¡ğ‘–ğ‘ğ‘)

(2)

Testando esta primeira hipÃ³tese, serÃ¡ confirmado (ou nÃ£o) o au-
mento da modularidade de software, atravÃ©s de mÃ©tricas avaliando
cada aspecto do software gerado.

HipÃ³tese 2. Conforme mencionado anteriormente, a arquitetura
de microsserviÃ§os gera serviÃ§os independentes entre si, comunicando-
se de maneira leve, com recursos de hardware prÃ³prios. Entretanto,
a arquitetura monolÃ­tica segue uma abstraÃ§Ã£o dos componentes que
depende do compartilhamento de recursos do mesmo servidor onde
os componente nÃ£o sÃ£o executÃ¡veis de forma independente [33]. No
entanto, os ganhos de performance provenientes do uso de cada ar-
quitetura nÃ£o sÃ£o evidentes [8]. Consequentemente, conjectura-se
que a arquitetura baseada em microsserviÃ§os exigirÃ¡ um menor con-
sumo de memÃ³ria e menor uso de CPU. No entanto, nÃ£o Ã© de forma
alguma Ã³bvio que esta hipÃ³tese seja vÃ¡lida. Talvez, a quantidade de
requisiÃ§Ãµes simultÃ¢neas gere um consumo menor de memÃ³ria e CPU
entre os microsserviÃ§os; ou ambas arquiteturas obtenham resulta-
dos semelhantes. Com base nesta declaraÃ§Ã£o, declaro as hipÃ³teses
nula e alternativa da seguinte forma:

Barzotto and Farias

HipÃ³tese Nula 2, H2â€“0: NÃ£o hÃ¡ diferenÃ§a no uso
dos recursos de hardware utilizando arquitetura de
microsserviÃ§os em comparaÃ§Ã£o com a arquitetura
monolÃ­tica.

ğ» 2â€“0 : ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ¶ğ‘ƒğ‘ˆ (ğ‘€ğ‘–ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘–ğ‘ğ‘œ) = ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ¶ğ‘ƒğ‘ˆ (ğ‘€ğ‘œğ‘›ğ‘œğ‘™ğ‘–ğ‘¡ğ‘–ğ‘ğ‘)
ğ» 2â€“0 : ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ‘€ğ‘’ğ‘šğ‘œğ‘Ÿğ‘–ğ‘(ğ‘€ğ‘–ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘–ğ‘ğ‘œ) = ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ‘€ğ‘’ğ‘šğ‘œğ‘Ÿğ‘–ğ‘(ğ‘€ğ‘œğ‘›ğ‘œğ‘™ğ‘–ğ‘¡ğ‘–ğ‘ğ‘)

HipÃ³tese alternativa 2, H2â€“1: HÃ¡ uma reduÃ§Ã£o
do consumo de memÃ³ria e CPU utilizando arquite-
tura de microsserviÃ§os em comparaÃ§Ã£o com a ar-
quitetura monolÃ­tica.

ğ» 2â€“1 : ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ¶ğ‘ƒğ‘ˆ (ğ‘€ğ‘–ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘–ğ‘ğ‘œ) < ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ¶ğ‘ƒğ‘ˆ (ğ‘€ğ‘œğ‘›ğ‘œğ‘™ğ‘–ğ‘¡ğ‘–ğ‘ğ‘)
ğ» 2â€“1 : ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ‘€ğ‘’ğ‘šğ‘œğ‘Ÿğ‘–ğ‘(ğ‘€ğ‘–ğ‘ğ‘Ÿğ‘œğ‘ ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘–ğ‘ğ‘œ) < ğ¶ğ‘œğ‘›ğ‘ ğ‘¢ğ‘šğ‘œğ‘€ğ‘’ğ‘šğ‘œğ‘Ÿğ‘–ğ‘(ğ‘€ğ‘œğ‘›ğ‘œğ‘™ğ‘–ğ‘¡ğ‘–ğ‘ğ‘)

(3)

(4)

(5)

(6)

Testando esta segunda hipÃ³tese, serÃ¡ possÃ­vel avaliar o uso dos
recursos de hardware, comparando os recursos utilizados em ambas
abordagens arquiteturais.

4.3 SeleÃ§Ã£o da AplicaÃ§Ã£o Alvo
Para a execuÃ§Ã£o do estudo de caso, foram selecionados projetos
no repositÃ³rio de cÃ³digo fonte da Cooperativa Utile. A coleta dos
projeto considerou algumas caracterÃ­sticas:

(1) AplicaÃ§Ã£o ser caracterizada como monolÃ­tica;
(2) AplicaÃ§Ã£o escrita utilizando linguagem Java;
(3) DecomposiÃ§Ã£o da aplicaÃ§Ã£o estar finalizada ou em etapa de

finalizaÃ§Ã£o;

ApÃ³s a conclusÃ£o da busca dos projetos, obteve-se uma amostra
inicial de 3 projetos. Os 3 projetos foram avaliados, tanto em qual
etapa de entrega estava quanto sua complexidade. Os projetos em
etapa de execuÃ§Ã£o intermediÃ¡ria ou anÃ¡lise da decomposiÃ§Ã£o foram
descartados. A aplicaÃ§Ã£o selecionada foi projetada para atender
diversos recursos dos terminais de autoatendimento aos clientes da
instituiÃ§Ã£o financeira, o objeto de estudo serÃ¡ focado no mÃ³dulo de
saque em dinheiro.

Esta aplicaÃ§Ã£o atualmente atende diversos tipos de terminais de
autoatendimento, alguns dos recursos sÃ£o: extrato de conta corrente,
extrato e antecipaÃ§Ã£o de cota capital, seguro veicular, transferÃªncia
eletrÃ´nica, depÃ³sito de cheque, pagamento de DOC, entre outras
funcionalidades.

AvaliaÃ§Ã£o dos impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica para microsserviÃ§os: Um estudo de caso

arquiteturas da aplicaÃ§Ã£o. Os cenÃ¡rios serÃ£o escritos utilizando a
linguagem Scala, o que torna necessÃ¡rio conhecer o bÃ¡sico da lin-
guagem. Contudo, ao final dos testes Ã© gerado um relatÃ³rio contendo
informaÃ§Ãµes como: usuÃ¡rios ativos durante a simulaÃ§Ã£o, requisiÃ§Ãµes
por segundo, respostas por segundo e uma variedade de percentuais
sobre os tempos de resposta das requisiÃ§Ãµes. A execuÃ§Ã£o do teste
de carga simulou 4 quantidades diferentes de requisiÃ§Ãµes por se-
gundo durante determinado perÃ­odo. A Table 2 lista as simulaÃ§Ãµes
executadas para o teste de carga.

Table 2: Tabela simulaÃ§Ãµes do teste de carga

Quantidade requisiÃ§Ãµes
por segundo
10
20
30
40

DuraÃ§Ã£o

10 minutos
10 minutos
10 minutos
10 minutos

4.4 VariÃ¡veis e MÃ©todo de QuantificaÃ§Ã£o
VariÃ¡vel dependente na primeira hipÃ³tese. A variÃ¡vel dependente na
primeira hipÃ³tese serÃ¡ a de mÃ©tricas de modularidade de software
descritas na Table 3, onde o cÃ³digo serÃ¡ avaliado sob diversos aspec-
tos da modularidade de software. O cÃ¡lculo dessa variÃ¡vel permite
estudar o impacto variÃ¡vel de cada mÃ©trica.

VariÃ¡vel dependente na segunda hipÃ³tese. A variÃ¡vel dependente
na segunda hipÃ³tese serÃ¡ a de mÃ©tricas de performance descritas
na ??. O cÃ¡lculo dessa variÃ¡vel permite estudar o impacto no uso
de recursos de hardware em ambas abordagens arquiteturais, de
acordo com uma carga de uso definida.

VariÃ¡vel independente. A variÃ¡vel independente dos hipÃ³teses
1 e 2 serÃ¡ o estilo arquitetural monolÃ­tico e o baseado em mi-
crosserviÃ§os.

4.5 MÃ©tricas Selecionadas
Neste estudo serÃ£o utilizados os conjuntos de mÃ©tricas Acoplamento
e CoesÃ£o para avaliar a modularidade de software. Para avaliaÃ§Ã£o de
performance serÃ£o utilizadas mÃ©tricas Consumo de CPU e Consumo
de memÃ³ria.

A Table 3 apresenta as mÃ©tricas selecionadas para quantificar
variÃ¡veis de modularidade, sendo acoplamento e coesÃ£o. A seleÃ§Ã£o
das mÃ©tricas foi feita com base em estudos empÃ­ricos anteriores [24,
28] que comprovam a validade destas mÃ©tricas para anÃ¡lise de
modularidade de software. As mÃ©tricas utilizadas foram:

â€¢ CBO: Esta mÃ©trica mede quantas classes uma determinada
classe depende. Em OrientaÃ§Ã£o a Objetos, o baixo acopla-
mento entre objetos indica um bom grau de modularidade [12].
â€¢ DIT: Esta mÃ©trica Ã© definida como o comprimento mÃ¡x-
imo do nÃ³ atÃ© a raiz da Ã¡rvore. Quanto mais profunda uma
classe estÃ¡ na hierarquia, maior o nÃºmero de mÃ©todos que
ela provavelmente herdarÃ¡, tornando mais complexo prever
seu comportamento [12].

â€¢ WMC: MÃ©trica que mede a complexidade da classe, obtida
em termos da complexidade de cada um de seus mÃ©todos.
Valor maior indica maior tempo e esforÃ§o para desenvolver

Figure 1: Diagrama geral da arquitetura monolÃ­tica

4.3.1 DecomposiÃ§Ã£o. Para realizar o processo de decomposiÃ§Ã£o
da aplicaÃ§Ã£o monolÃ­tica foram utilizados os princÃ­pios do Domain-
Driven Design [16], desta forma serÃ£o definidos os domÃ­nios junta-
mente com os seus delimitadores. A aplicaÃ§Ã£o alvo possui um alto
nÃ­vel de criticidade, desta forma serÃ¡ preciso realizar uma migraÃ§Ã£o
gradativa na utilizaÃ§Ã£o dos microsserviÃ§os decompostos. HaverÃ¡
um chaveamento por tipo de terminal de atendimento e nÃºmeros
de contas, desta forma serÃ¡ possÃ­vel ter um controle maior sobre
os possÃ­veis clientes impactados. Os microsserviÃ§os resultantes da
decomposiÃ§Ã£o foram construÃ­dos utilizando a linguagem Java e
o framework Spring. A escolha das tecnologias utilizadas se deu
atravÃ©s do conhecimento e experiÃªncia comum entre os membros
da equipe tÃ©cnica. A comunicaÃ§Ã£o entre os microsserviÃ§os Ã© feita
atravÃ©s do protocolo HTTP, seguindo o padrÃ£o REST.

Para a decomposiÃ§Ã£o da base de dados, foi utilizado o SQL Server,
onde a estrutura de dados foi implementada para ser migrada par-
cialmente, tendo em vista a grande dependÃªncia dos demais sistemas
com as tabelas da aplicaÃ§Ã£o alvo.

4.3.2 Testes de carga. Os testes de cargas serÃ£o aplicados utilizando
a ferramenta Gatling, a qual Ã© uma ferramenta de alta performance,
uso simples e fÃ¡cil manutenÃ§Ã£o. A ferramenta Gatling suporta pro-
tocolo HTTP, a qual serÃ¡ a forma de comunicaÃ§Ã£o presente nas duas

e manter a classe. Quanto maior o nÃºmero de mÃ©todos de
uma classe, maior serÃ¡ o impacto potencial sobre os filhos,
pois estes herdarÃ£o os mÃ©todos da classe pai [12].

â€¢ NOC: MÃ©trica que mede a largura da hierarquia de uma
classe. Quanto maior o nÃºmero, maior o reaproveitamento,
entretanto quanto maior o nÃºmero de filhos, maior a prob-
abilidade de abstraÃ§Ã£o inadequada da classe pai, alÃ©m da
possibilidade de necessitar de mais testes dos mÃ©todos dessa
classe [12].

â€¢ LCOM: MÃ©trica que mede a falta de coesÃ£o de uma classe,
selecionando todos os pares de mÃ©todos de uma classe e
verificando se esses compartilham algum atributo. Quanto
maior o nÃºmero, maior Ã© a falta de coesÃ£o, aumentando assim
a complexidade, levando a um provÃ¡vel aumento do nÃºmero
de defeitos injetados no software [12].

Para comparaÃ§Ã£o de performance entre a arquitetura monolÃ­tica
e a arquitetura baseada em microsserviÃ§os, foram selecionadas as
mÃ©tricas de consumo de CPU e consumo de memÃ³ria, visando
determinar o desempenho de cada arquitetura [43]. O consumo de
CPU se refere Ã  porcentagem de unidade do recurso CPU virtual
que estÃ¡ sendo usado pelo Kubernetes [1]. O consumo de memÃ³ria
se refere Ã  porcentagem de memÃ³ria que foi utilizada na execuÃ§Ã£o
do processo [2].

4.6 Processo Experimental
O processo experimental definido foi baseado em estudos empÃ­ri-
cos publicados [15, 17â€“19], onde Ã© identificado um conjunto de
atividades, organizadas em trÃªs fases (Figura 2).

A Figura 2 mostra atravÃ©s de um processo experimental como as
trÃªs fases foram organizadas. As atividades sÃ£o descritas a seguir:

â€¢ Buscar projetos: foi realizada a busca de projetos no repositÃ³rio

de cÃ³digos da Cooperativa Utile.

â€¢ Avaliar projetos: foi realizada a avaliaÃ§Ã£o dos projetos, para
averiguar quais seriam os mais aptos a serem utilizados no es-
tudo de caso. A seleÃ§Ã£o se baseou nas caracterÃ­sticas definidas
na SeÃ§Ã£o 4.3.

â€¢ Mapear fluxo da aplicaÃ§Ã£o: identificado o fluxo da apli-

caÃ§Ã£o alvo e criaÃ§Ã£o dos testes de carga.

â€¢ Executar testes de carga: testes de carga executados e os

dados resultantes foram coletados.

â€¢ Avaliar resultados: avaliaÃ§Ã£o dos resultados dos testes de
carga usando o mÃ©todo de quantificaÃ§Ã£o descrito na SeÃ§Ã£o 4.4.

4.7 Procedimento de AnÃ¡lise
A anÃ¡lise quantitativa dos dados de modularidade de software, serÃ¡
realizada atravÃ©s dos dados coletados pela ferramenta Understand1.
Onde para a anÃ¡lise de distribuiÃ§Ã£o dos dados de cada mÃ©trica, serÃ£o
utilizados os seguintes mÃ©todos estatÃ­sticos: desvio padrÃ£o, valor
mÃ¡ximo, mediana, mÃ©dia e percentual de variaÃ§Ã£o entre as mÃ©dias.
Outros estudos usam desta abordagem para analisar mÃ©tricas de
software [28].

1Understand: https://www.scitools.com/

Barzotto and Farias

A anÃ¡lise quantitativa dos dados refentes Ã  anÃ¡lise de perfor-
mance, serÃ¡ realizada atravÃ©s da estatÃ­stica descritiva para anal-
isar sua distribuiÃ§Ã£o normal [48] e inferÃªncia estatÃ­stica para tes-
tar as hipÃ³teses. O nÃ­vel de significÃ¢ncia dos testes de hipÃ³tese
serÃ£o ğ›¼ = 0,05. Para testar as hipÃ³teses, serÃ¡ aplicado o teste T das
amostras [32].

Figure 2: Processo experimental

5 RESULTADOS
Esta seÃ§Ã£o tem como objetivo apresentar os resultados referentes as
questÃµes de pesquisas formuladas na section 4. A SeÃ§Ã£o 5.1 discute
os resultados obtidos referentes a performance de hardware. Na
SeÃ§Ã£o 5.2 discute-se os resultados obtidos referentes a modularidade
de software. Por fim a SeÃ§Ã£o 5.3 apresenta uma discussÃ£o adicional
sobre os resultados obtidos.

5.1 AnÃ¡lise de performance
A aplicaÃ§Ã£o alvo da empresa hipotÃ©tica Cooperativa Utile, do ramo
financeiro, foi projetada para atender operaÃ§Ãµes realizadas no ter-
minal de autoatendimento. Considerando as aplicaÃ§Ãµes monolÃ­ticas
jÃ¡ existentes na empresa, o valor mÃ©dio para consumo de CPU Ã© de
2,5 vCPU, jÃ¡ o valor mÃ©dio de consumo de memÃ³ria Ã© de 1536 MiB.

5.1.1 Consumo de MemÃ³ria. EstatÃ­stica descritiva. A Table 5 ap-
resenta os dados referentes a variÃ¡vel do consumo de memÃ³ria. Em-
bora esse valor baixo, Ã© necessÃ¡rio verificar se esse valor obtido pos-
sui diferenÃ§a estatisticamente relevante ao limite aceitÃ¡vel hipoteti-
camente definido pela Cooperativa Utile. Para isso serÃ¡ testada a
hipÃ³tese no parÃ¡grafo Ã  frente.

AvaliaÃ§Ã£o dos impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica para microsserviÃ§os: Um estudo de caso

Table 3: Tabela mÃ©tricas de modularidade de software [24]

Atributos

MÃ©tricas

Coupling betweenobjects (CBO)

Acoplamento

Depth inheritancetree(DIT)

Weighted Methods
per Class (WMC)

Number of Children
(NOC)

Lack of Cohesion
in Methods
(LCOM/LOCM)

CoesÃ£o

DefiniÃ§Ãµes
Esta mÃ©trica mede quantas classes uma
determinada classe depende.
Esta mÃ©trica Ã© definida como o
comprimento mÃ¡ximo do nÃ³ atÃ© a raiz
da Ã¡rvore.
MÃ©trica que mede a complexidade da
classe, obtida em termos da complexidade
de cada um de seus mÃ©todos.
MÃ©trica que mede a largura da hierarquia
de uma classe.
Esta mÃ©trica mede a falta de coesÃ£o de
uma classe, selecionando todos os pares
de mÃ©todos de uma classe e verificando
se esses compartilham algum atributo.

Table 5: Tabela resultados consumo de MemÃ³ria (medidas
em MebiByte - MiB)

Teste de hipÃ³tese questÃ£o de pesquisa 1.

Tamanho da
amostra

Menor Maior MÃ©dia Desvio padrÃ£o

84

479,75

788,84

627,68

95,09

Teste de hipÃ³tese questÃ£o de pesquisa 1.

Resultados observados 1: O consumo mÃ©dio de memÃ³ria
(M = 627,68, SD = 95,09) foi menor do que o consumo mÃ©dio
padrÃ£o das aplicaÃ§Ãµes monolÃ­ticas de 1536,00, uma diferenÃ§a
mÃ©dia estatisticamente significativa de 908,32, IC de 95%
[607,05, 648,32], t (84) = -87,54, p-value = 0,001.

5.1.2 Consumo de CPU. EstatÃ­stica descritiva. A Table 6 apre-
senta os dados referentes Ã  variÃ¡vel do consumo de CPU. Embora
esse valor seja baixo, Ã© necessÃ¡rio verificar se esse valor obtido pos-
sui diferenÃ§a estatisticamente relevante ao limite aceitÃ¡vel hipoteti-
camente definido pela Cooperativa Utile. Para isso, serÃ¡ testada a
hipÃ³tese no parÃ¡grafo Ã  frente.

Table 6: Tabela resultados consumo de CPU (medidas em
vCPU)

Tamanho da
amostra

Menor Maior MÃ©dia Desvio padrÃ£o

84

0,14

0,92

0,45

0,16

A Tabela 5.1.2 apresenta os resultados do teste de hipÃ³tese para
anÃ¡lise do consumo de CPU. Os valores apontam que o p < 0,05
indicando que hÃ¡ uma diferenÃ§a estatisticamente relevante, onde
o uso da arquitetura baseada em microsserviÃ§os apresenta uma
diferenÃ§a significativa, entre o valor de limite aceitÃ¡vel e o valor
apresentado. Portanto, a arquitetura baseada em microsserviÃ§os se
configura como sendo uma arquitetura promissora, corroborando
com outros estudos [8, 43] que evidenciam menor consumo dos
recursos de hardware.

Resultados observados 2: O percentual de consumo mÃ©dio
de CPU (M = 0,45, SD = 0,16) foi menor do que o percentual
de consumo mÃ©dio padrÃ£o dos microsserviÃ§os de 2,50, uma
diferenÃ§a mÃ©dia estatisticamente significativa de 2,05, IC de
95% [0,42, 0,49], t (84) = -116,7, p-value = 0,001.

5.2 AnÃ¡lise das mÃ©tricas de modularidade de

software

A Tabela 7 traz os indicadores estatÃ­sticos sobre o resultado das
mÃ©tricas coletadas, referentes Ã  modularidade de software. Ap-
resenta os resultados dos efeitos da arquitetura baseada em mi-
crosserviÃ§os em comparaÃ§Ã£o Ã  arquitetura monolÃ­tica, atravÃ©s dos
atributos de Acoplamento e CoesÃ£o, incluindo o desvio padrÃ£o, me-
diana, mÃ©dia e percentual de variaÃ§Ã£o entre as mÃ©dias. Este conjunto
de mÃ©tricas visa identificar a modularidade do software, jÃ¡ a Table 8
apresenta valores de referÃªncia para as mÃ©tricas [12], tendo como
categorias: Baixo, Alto e Anomalia.

Table 8: Valores referÃªncia para as mÃ©tricas CK em softwares
desenvolvidos na linguagem Java [28]

DIT NOC CBO RFC LCOM WMC

Baixo
Alto
Anomalia

0
2,5
3

0
6,4
8

0
13,6
18

0
35,5
46

0
92,7
120

230
253,1
329

A categoria de Acoplamento traz as seguintes mÃ©tricas para
comparaÃ§Ã£o: CBO, DIT, WMC e NOC. A arquitetura baseada em
microsserviÃ§os apresentou resultados melhores em comparaÃ§Ã£o Ã  ar-
quitetura monolÃ­tica. Isso pode ser identificado atravÃ©s da diferenÃ§a
entre as mÃ©dias de cada arquitetura, representada pelo percentual de
variaÃ§Ã£o, sendo 30,76%, 76,67%, 209,85% e 121,35% respectivamente.
CBO. O percentual de variaÃ§Ã£o de 30,76% para a arquitetura
de microsserviÃ§os, indica um melhor grau de modularidade do
cÃ³digo, onde os princÃ­pios da OrientaÃ§Ã£o a Objetos foram melhores
aplicados. Ambas arquiteturas obtiveram mÃ©dias classificadas entre

Table 7: Tabela resultados das mÃ©tricas de modularidade de software

Barzotto and Farias

Atributos

MÃ©tricas

Acoplamento

CBO

DIT

WMC

NOC

CoesÃ£o

LCOM

Arquitetura
MonolÃ­tica
MicrosserviÃ§os
MonolÃ­tica
MicrosserviÃ§os
MonolÃ­tica
MicrosserviÃ§os
MonolÃ­tica
MicrosserviÃ§os
MonolÃ­tica
MicrosserviÃ§os

Desvio PadrÃ£o MÃ¡ximo Mediana MÃ©dia
10,06
7,70
1,62
0,92
19,34
6,24
0,51
0,23
48,49
21,15

12,53
7,22
0,92
0,51
82,81
15,79
4,60
0,62
37,84
30,02

121
38
4
3
2327
231
86
4
100
100

5
6
1
1
7
2,5
0
0
61
0

% de variaÃ§Ã£o

30,76%

76,67%

209,85%

121,35%

129,32%

Baixo e Alto, segundo os valores de referÃªncia da Table 8. Entretanto,
ambas arquiteturas tiverem classes com valores categorizados como
Anomalia.

DIT. A arquitetura de microsserviÃ§os tendo um percentual de
variaÃ§Ã£o menor, indica menos complexidade e tambÃ©m a possibili-
dade de menos reutilizaÃ§Ã£o de cÃ³digo por meio de heranÃ§a. Ambas
arquiteturas obtiveram mÃ©dias classificadas entre Baixo e Alto, se-
gundo os valores de referÃªncia da Table 8. Contudo, os resultados
obtidos indicam que ambas arquiteturas tiveram classes com val-
ores acima do categorizado como Anomalia, indicando que ambos
projetos possuem classes problemÃ¡ticas.

WMC. A arquitetura monolÃ­tica teve percentual de variaÃ§Ã£o
superior em 209,85%, indicando classes com maior nÃºmero de mÃ©to-
dos e complexidades entre eles. AlÃ©m do percentual de variaÃ§Ã£o em
comparaÃ§Ã£o Ã  arquitetura de microsserviÃ§os, esta mÃ©trica obteve
classes com valores superiores ao categorizado como Anomalia.

NOC. A arquitetura monolÃ­tica apresentou um nÃºmero maior
desta mÃ©trica, a qual obteve classes com valor mÃ¡ximo de 86. Um alto
valor desta mÃ©trica indica que hÃ¡ probabilidade da classe apresentar
defeitos, devido Ã  grande hierarquia das classes [28].

LCOM. Os resultados coletados desta mÃ©trica trazem uma re-
duÃ§Ã£o de 129,32% para a arquitetura de microsserviÃ§os em compara-
Ã§Ã£o com a arquitetura monolÃ­tica. Entretanto, ambas arquiteturas
obtiveram valores mÃ¡ximos de 100, podendo ser classificadas com
categoria Alto, segundo a Table 8 com valores de referÃªncia.

Estes resultados eram esperados, pois a aplicaÃ§Ã£o monolÃ­tica
apresentou um nÃºmero elevado de classes e linhas de cÃ³digos. Isso
pode ser explicado pelo fato da aplicaÃ§Ã£o monolÃ­tica possuir um con-
junto de funcionalidades maiores, consequentemente necessitando
de um nÃºmero maior de classes e linhas de cÃ³digo, outros estu-
dos indicam estes resultados [5]. Entretanto, a aplicaÃ§Ã£o baseada
em microsserviÃ§os foi resultado de um processo de decomposiÃ§Ã£o
da aplicaÃ§Ã£o monolÃ­tica, onde foram extraÃ­das as funcionalidades
necessÃ¡rias para o produto, isso facilitou um melhor entendimento
do domÃ­nio deste produto [16], onde foram melhor aplicados os con-
ceitos da linguagem orientada a objetos, diminuindo a complexidade
do cÃ³digo. Esta Ãºltima afirmaÃ§Ã£o se fundamenta principalmente
atravÃ©s dos melhores resultados para as mÃ©tricas WMC e CBO,
as quais foram utilizadas com maior chance de acerto em outros
estudos [28] para prever classes com propensÃ£o a erros.

Resultados observados 3: As mÃ©tricas de acoplamento e
coesÃ£o obtiveram valores mÃ©dios considerados baixos para
ambas arquiteturas [28]. No entanto, a aplicaÃ§Ã£o com ar-
quitetura baseada em microsserviÃ§os, obteve valores menores
em todas as mÃ©tricas, evidenciando um menor acoplamento
e maior coesÃ£o.

5.3 DiscussÃ£o
Modularidade de software. A arquitetura monolÃ­tica obteve bons
resultados considerando os valores de referÃªncia. Entretanto, ao
analisar os resultados obtidos atravÃ©s dos conjuntos de mÃ©tricas
definidas, identificou-se que a arquitetura baseada em microsserviÃ§os
obteve melhores resultados de forma geral. O baixo acoplamento
indica um aumento na qualidade do software e possivelmente maior
reuso dos componentes [30].

AnÃ¡lise de performance. A arquitetura monolÃ­tica obteve val-
ores elevados em comparaÃ§Ã£o com a arquitetura baseada em mi-
crosserviÃ§os. Os valores de consumo de memÃ³ria para os microsserviÃ§os
indicam uma reduÃ§Ã£o considerÃ¡vel, tendo em vista o contexto de
software reduzido e uma menor dependÃªncia de outros softwares.
O consumo de CPU e memÃ³ria, inferiores na aplicaÃ§Ã£o com arquite-
tura baseada em microsserviÃ§os, indicam menor carga de processa-
mento computacional.

5.4 LimitaÃ§Ãµes do Estudo
O estudo de caso reportado se trata de um estudo inicial que ex-
plora um assunto pouco investigado na literatura. Desta forma, o
estudo possui algumas limitaÃ§Ãµes que devem ser consideradas. A
aplicaÃ§Ã£o monolÃ­tica considerada, possui diversas funcionalidades
implementadas, alÃ©m da funcionalidade alvo do estudo, podendo
ter distorcido os resultados coletados. Tal consideraÃ§Ã£o corrobora
com o fato de ser uma aplicaÃ§Ã£o antiga, onde nÃ£o adotaram boas
prÃ¡ticas e todos os conceitos da orientaÃ§Ã£o a objetos. Sendo esse
um dos motivos pelo qual houve um grande percentual de variaÃ§Ã£o
entre as mÃ©tricas de modularidade de software. Outra dificuldade
foi encontrada para coletar as mÃ©tricas de consumo de memÃ³ria e
consumo de CPU, pela aplicaÃ§Ã£o monolÃ­tica, onde nÃ£o foi possÃ­vel
coletar devido a problemas tÃ©cnicos no servidor onde os testes de
carga foram executados. Neste caso, foram considerados valores
baseados na experiÃªncia da equipe de desenvolvimento.

6 CONCLUSÃƒO E TRABALHOS FUTUROS
A arquitetura de microsserviÃ§os vem sendo adotada na indÃºstria
como forma de modernizaÃ§Ã£o de aplicaÃ§Ãµes legadas. Surge como

AvaliaÃ§Ã£o dos impactos da decomposiÃ§Ã£o de uma aplicaÃ§Ã£o monolÃ­tica para microsserviÃ§os: Um estudo de caso

alternativa para a arquitetura monolÃ­tica pois, traz maior escalabili-
dade e manutenibilidade da aplicaÃ§Ã£o. No entanto, nÃ£o hÃ¡ muitos
estudos evidenciando os impactos da adoÃ§Ã£o deste estilo arquitetu-
ral em relaÃ§Ã£o ao monolÃ­tico. Neste sentido, o estudo atual reportou
um estudo de caso inicial com o propÃ³sito de comparar a arquitetura
monolÃ­tica e a arquitetura de microsserviÃ§os. O estudo reportado
procurou avaliar os impactos da utilizaÃ§Ã£o de ambas arquiteturas,
atravÃ©s de mÃ©tricas computacionais como, consumo de CPU, con-
sumo de memÃ³ria, alÃ©m de mÃ©tricas para medir a modularidade do
software.

No estudo atual, as mÃ©tricas selecionadas sÃ£o avaliadas em uma
aplicaÃ§Ã£o financeira real, que atende as operaÃ§Ãµes de saque, dos
terminais de autoatendimento, da empresa fictÃ­cia Cooperativa Utile.
As descobertas indicam que o uso da arquitetura de microsserviÃ§os,
apresentou bons resultados quanto as mÃ©tricas de acoplamento e co-
esÃ£o. Contudo, ficou evidente a necessidade de um conjunto maior
de mÃ©tricas, para avaliar outros aspectos das aplicaÃ§Ãµes, como por
exemplo o acoplamento entre microsserviÃ§os.

As mÃ©tricas computacionais para avaliar a performance tiveram
valores hipotetizados para as mÃ©tricas de consumo de CPU e con-
sumo de memÃ³ria. Novamente a arquitetura de microsserviÃ§os teve
bons resultados em comparaÃ§Ã£o a arquitetura monolÃ­tica. No en-
tanto, mostrou-se necessÃ¡rio novas mÃ©tricas para melhor avaliar a
performance, como por exemplo a latÃªncia e a taxa de transferÃªn-
cia [8].

A realizaÃ§Ã£o deste estudo, trouxe contribuiÃ§Ãµes cientÃ­ficas ref-
erentes ao tema de decomposiÃ§Ã£o de aplicaÃ§Ãµes monolÃ­ticas em
microsserviÃ§os. O uso de uma aplicaÃ§Ã£o real como estudo de caso,
aumentou o conhecimento empÃ­rico gerado sobre o tema.

Como trabalhos futuros, pretende-se: (1) definir um conjunto
maior de mÃ©tricas, visando aumentar a perspectiva de anÃ¡lise da
modularidade do software e performance; (2) coletar mais dados
em ambas arquiteturas, para realizar uma analise estatÃ­stica sem a
necessidade de hipotetizar os valores. Este trabalho pode ser tido
como sendo um estudo inicial, de uma sequÃªncia de estudos de
caso mais robustos, relacionados aos impactos da decomposiÃ§Ã£o de
aplicaÃ§Ãµes monolÃ­ticas para microsserviÃ§os.

REFERENCES
[1] 2021. Managing Resources for Containers. https://kubernetes.io/docs/concepts/

configuration/manage-resources-containers/#meaning-of-cpu

workshop on Future of software engineering research. 47â€“52.

[10] AndrÃ© Stangarlin de Camargo et al. 2016. Uma abordagem para testes de desem-

penho de microservices. (2016).

[11] Carlos Eduardo Carbonera, Kleinner Farias, and Vinicius Bischoff. 2020. Software
development effort estimation: a systematic mapping study. IET Software 14, 4
(2020), 328â€“344.

[12] Shyam R Chidamber and Chris F Kemerer. 1994. A metrics suite for object
oriented design. IEEE Transactions on software engineering 20, 6 (1994), 476â€“493.
[13] Prashant Ramchandra Desai. 2016. A survey of performance comparison between
virtual machines and containers. Int. J. Comput. Sci. Eng 4, 7 (2016), 55â€“59.
[14] Nicola Dragoni, Saverio Giallorenzo, Alberto Lluch Lafuente, Manuel Mazzara,
Fabrizio Montesi, Ruslan Mustafin, and Larisa Safina. 2017. Microservices: yes-
terday, today, and tomorrow. Present and ulterior software engineering (2017),
195â€“216.

[15] Leandro Ferreira Dâ€™Avila, Kleinner Farias, and Jorge Luis VictÃ³ria Barbosa. 2020.
Effects of contextual information on maintenance effort: a controlled experiment.
Journal of Systems and Software 159 (2020), 110443.

[16] Eric Evans. 2009. Domain-driven design: atacando as complexidades no coraÃ§Ã£o do

software. Alta Books.

[17] Kleinner Farias. 2016. Empirical evaluation of effort on composing design models.

arXiv preprint arXiv:1610.09012 (2016).

[18] Kleinner Farias, Alessandro Garcia, and Carlos Lucena. 2014. Effects of stability
on model composition effort: an exploratory study. Software & Systems Modeling
13, 4 (2014), 1473â€“1494.

[19] Kleinner Farias, Alessandro Garcia, Jon Whittle, Christina von Flach Garcia
Chavez, and Carlos Lucena. 2015. Evaluating the effort of composing design
models: a controlled experiment. Software & Systems Modeling 14, 4 (2015),
1349â€“1365.

[20] Kleinner Farias, Lucian GonÃ§ales, Vinicius Bischoff, Bruno Carreiro da Silva,
Everton T GuimarÃ£es, and Jacob Nogle. 2018. On the UML use in the Brazilian
industry: A state of the practice survey (S).. In SEKE. 372â€“371.

[21] Martin Fowler. 2015. Monolith First.

https://martinfowler.com/bliki/

MonolithFirst.html

[22] Martin Fowler, Kent Beck, and W Roberts Opdyke. 1997. Refactoring: Improving
the design of existing code. In 11th European Conference. JyvÃ¤skylÃ¤, Finland.
[23] Martin Fowler and James Lewis. 2014. Microservices, a definition of this new
architectural term. https://martinfowler.com/articles/microservices.html
[24] Alessandro Garcia, ClÃ¡udio Santâ€™Anna, Eduardo Figueiredo, UirÃ¡ Kulesza, Carlos
Lucena, and Arndt von Staa. 2006. Modularizing design patterns with aspects: a
quantitative study. In Transactions on Aspect-Oriented Software Development I.
Springer, 36â€“74.

[25] Lucian GonÃ§ales, Kleinner Farias, and Bruno C da Silva. 2021. Measuring the
cognitive load of software developers: An extended Systematic Mapping Study.
Information and Software Technology (2021), 106563.

[26] Konrad Gos and Wojciech Zabierowski. 2020. The Comparison of Microservice
and Monolithic Architecture. In 2020 IEEE XVIth International Conference on
the Perspective Technologies and Methods in MEMS Design (MEMSTECH). IEEE,
150â€“153.

[27] Michael Gysel, Lukas KÃ¶lbener, Wolfgang Giersche, and Olaf Zimmermann. 2016.
Service cutter: A systematic approach to service decomposition. In European
Conference on Service-Oriented and Cloud Computing. Springer, 185â€“200.
[28] Renato Correa Juliano, Bruno AN TravenÃ§olo, and Michel S Soares. 2014. Detec-
tion of Software Anomalies Using Object-oriented Metrics. In ICEIS (2). 241â€“248.
[29] Ed JÃºnior, Kleinner Farias, and Bruno Silva. 2021. A Survey on the Use of UML in
the Brazilian Industry. In Brazilian Symposium on Software Engineering. 275â€“284.
[30] Rick Kazman, Gregory Abowd, Len Bass, and Paul Clements. 1996. Scenario-based

[2] 2021. Managing Resources for Containers. https://kubernetes.io/docs/concepts/

analysis of software architecture. IEEE software 13, 6 (1996), 47â€“55.

configuration/manage-resources-containers/#meaning-of-memory

[31] Holger Knoche and Wilhelm Hasselbring. 2018. Using microservices for legacy

[3] Eric Allman. 2012. Managing technical debt. Commun. ACM 55, 5 (2012), 50â€“55.
[4] Arun. 2015. A First Look at Microservices. Java Magazine sep/oct (2015).
[5] Tugrul Asik and Yunus Emre Selcuk. 2017. Policy enforcement upon software
based on microservice architecture. In 2017 IEEE 15th International Conference on
Software Engineering Research, Management and Applications (SERA). 283â€“287.
https://doi.org/10.1109/SERA.2017.7965739

[6] Paris Avgeriou, Philippe Kruchten, Ipek Ozkaya, and Carolyn Seaman. 2016.
Managing technical debt in software engineering (dagstuhl seminar 16162). In
Dagstuhl Reports, Vol. 6. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.
[7] Andrew Baumann, Paul Barham, Pierre-Evariste Dagand, Tim Harris, Rebecca
Isaacs, Simon Peter, Timothy Roscoe, Adrian SchÃ¼pbach, and Akhilesh Singhania.
2009. The Multikernel: a New OS Architecture for Scalable Multicore Systems.
In Proc. of the 22nd ACM SIGOPS Symposium on Operating Systems Principles. Big
Sky, Montana, USA, 29â€“44. https://doi.org/10.1145/1629575.1629579

[8] N BjÃ¸rndal, Antonio Bucchiarone, Manuel Mazzara, Nicola Dragoni, and
Schahram Dustdar. 2020. Migration from Monolith to Microservices : Bench-
marking a Case Study. (03 2020). https://doi.org/10.13140/RG.2.2.27715.14883

[9] Nanette Brown, Yuanfang Cai, Yuepu Guo, Rick Kazman, Miryung Kim, Philippe
Kruchten, Erin Lim, Alan MacCormack, Robert Nord, Ipek Ozkaya, et al. 2010.
Managing technical debt in software-reliant systems. In Proceedings of the FSE/SDP

software modernization. IEEE Software 35, 3 (2018), 44â€“49.

[32] David J Lilja. 2005. Measuring computer performance: a practitionerâ€™s guide. Cam-

bridge university press.

[33] Sam Newman. 2015. Building microservices: designing fine-grained systems. "

Oâ€™Reilly Media, Inc.".

[34] Anderson Oliveira, Vinicius Bischoff, Lucian JosÃ© GonÃ§ales, Kleinner Farias, and
Matheus Segalotto. 2018. BRCode: An interpretive model-driven engineering
approach for enterprise applications. Computers in Industry 96 (2018), 86â€“97.

[35] Fabio Palomba, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto, Andrea
De Lucia, and Denys Poshyvanyk. 2013. Detecting bad smells in source code using
change history information. In 2013 28th IEEE/ACM International Conference on
Automated Software Engineering (ASE). IEEE, 268â€“278.

[36] Masoud Rafighi, Yaghoub Farjami, and Nasser Modiri. 2015. Studying the deficien-
cies and problems of different architecture in developing distributed systems and
analyze the existing solution. In 2015 2nd International Conference on Knowledge-
Based Engineering and Innovation (KBEI). IEEE, 826â€“834.

[37] Cesar Coutinho Ramos. 2016. AnÃ¡lise e aplicaÃ§Ã£o de mÃ©todos de modularizaÃ§Ã£o

no desenvolvimento do produto. (2016).

[38] Chris Richardson. 2018. Microservices patterns. Manning Publications Company,.

Barzotto and Farias

[39] Diego Pereira da Rocha. 2018. MonÃ³lise: Uma tÃ©cnica para decomposiÃ§Ã£o de

aplicaÃ§Ãµes monolÃ­ticas em microsserviÃ§os.

[40] Maluane Rubert and Kleinner Farias. 2021. On the Effects of Continuous Delivery
on Code Quality: A Case Study in Industry. Computer Standards and Interfaces
(2021), 103588.

[41] Chaitanya Rudrabhatla. 2020. Impacts of Decomposition Techniques on Perfor-
mance and Latency of Microservices. International Journal of Advanced Computer
Science and Applications 11 (01 2020). https://doi.org/10.14569/IJACSA.2020.
0110803

[42] Dag IK Sjoberg, Bente Anda, Erik Arisholm, Tore Dyba, Magne Jorgensen, Amela
Karahasanovic, Espen Frimann Koren, and Marek VokÃ¡c. 2002. Conducting realis-
tic experiments in software engineering. In Proceedings international symposium
on empirical software engineering. IEEE, 17â€“26.

[43] Freddy Tapia, Miguel Ãngel Mora, Walter Fuertes, HernÃ¡n Aules, Edwin Flores,
and Theofilos Toulkeridis. 2020. From Monolithic Systems to Microservices: A
Comparative Study of Performance. Applied Sciences 10, 17 (2020), 5797.

[44] Sheetal Thakare, Savita Chavan, and PM Chawan. 2012. Software Testing Strate-
gies and Techniques. International Journal of Emerging Technology and Advanced
Engineering 2 (2012), 980â€“986.

[45] Karl Ulrich. 1994. Fundamentals of product modularity. In Management of Design.

Springer, 219â€“231.

[46] Roger GonÃ§alves Urdangarin, Kleinner Farias, and Jorge Barbosa. 2021.
Mon4Aware: A multi-objective and context-aware approach to decompose mono-
lithic applications. In XVII Brazilian Symposium on Information Systems. 1â€“9.
[47] Mario Villamizar, Oscar GarcÃ©s, Harold Castro, Mauricio Verano, Lorena Sala-
manca, Rubby Casallas, and Santiago Gil. 2015. Evaluating the monolithic and
the microservice architecture pattern to deploy web applications in the cloud. In
2015 10th Computing Colombian Conference (10CCC). IEEE, 583â€“590.

[48] Claes Wohlin, Per Runeson, Martin HÃ¶st, Magnus C Ohlsson, BjÃ¶rn Regnell, and
Anders WesslÃ©n. 2012. Experimentation in software engineering. Springer Science
& Business Media.

