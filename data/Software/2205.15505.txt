DNA Pattern Matching Acceleration with Analog
Resistive CAM

Jinane Bazzi, Jana Sweidan, Mohammed E. Fouda, Rouwaida Kanj, and Ahmed M. Eltawil

1

2
2
0
2

y
a
M
1
3

]

R
A
.
s
c
[

1
v
5
0
5
5
1
.
5
0
2
2
:
v
i
X
r
a

Abstract—DNA pattern matching is essential for many widely
used bioinformatics applications. Disease diagnosis is one of
these applications, since analyzing changes in DNA sequences
can increase our understanding of possible genetic diseases. The
remarkable growth in the size of DNA datasets has resulted in
challenges in discovering DNA patterns efﬁciently in terms of
run time and power consumption. In this paper, we propose
an efﬁcient hardware and software codesign that determines
the chance of the occurrence of repeat-expansion diseases using
DNA pattern matching. The proposed design parallelizes the
DNA pattern matching task using associative memory realized
with analog content-addressable memory and implements an
algorithm that returns the maximum number of consecutive
occurrences of a speciﬁc pattern within a DNA sequence. We
fully implement all the required hardware circuits with PTM
45-nm technology, and we evaluate the proposed architecture on
a practical human DNA dataset. The results show that our design
is energy-efﬁcient and signiﬁcantly accelerates the DNA pattern
matching task compared to previous approaches described in the
literature.

Index Terms—DNA sequencing, Disease diagnosis, Pattern

matching, Associative memory, Analog CAM (aCAM).

I. INTRODUCTION

Deoxyribonucleic acid (DNA) pattern matching is the
workhorse for several bioinformatics applications. Disease
diagnosis is the most popular among them [1]. Scientists
rely heavily on DNA pattern matching to explore and detect
possible diseases that can arise due to changes in DNA
sequences.

A DNA molecule contains the information needed for the
development and functioning of organisms. DNA has four
basic nucleotide characters: adenine (A), cytosine (C), guanine
(G), and thymine (T). A combination of these characters forms
a DNA sequence that is unique to each organism. Genes are
subsequences of DNA that carry information about an organ-
ism’s physical traits. It is important to understand and analyze
gene sequences since changes in these sequences, referred to
as mutations, may have harmful effects on the organism in
which they occur, for example, by causing a genetic disorder.
One of the major changes is nucleotide repeats, in which a
speciﬁc DNA pattern repeat is expanded abnormally within a
region of DNA. More than 40 repeat-expansion diseases are

J. Bazzi and A. Eltawil are with King Abdullah University of Science and

Technology (KAUST), Thuwal 23955, Saudi Arabia.

J. Sweidan and R. Kanj are with ECE Dept., American University of Beirut,

Lebanon, 1107 202

M. Fouda is with the Center for Embedded & Cyber-physical Sys-
tems, University of California-Irvine, Irvine, CA, USA 92697-2625. Email:
foudam@uci.edu

Manuscript received xxx, xxx; revised xxxx, xxx.

known, most of which primarily affect the nervous system.
Expanded trinucleotide-repeat disorders, which are caused
by the unstable expansion of three nucleotides consecutively
repeated, were the ﬁrst to be discovered, and they remain the
most frequent. Recently, the list of repeat-expansion diseases
has increased to include tetra-, penta-, hexa-, and even dodeca-
nucleotide repeat expansions [2]. Table I shows some examples
of diseases and their corresponding genes and pattern counts.
DNA pattern matching can be used to detect these diseases
by identifying the number of consecutive occurrences of the
corresponding pattern.

Datasets of DNA sequences require a huge amount of
storage. For instance, the human genome has around 3.1647
billion DNA base pairs [5]. This signiﬁcant volume of DNA
data imposes a challenge in performing DNA pattern matching
efﬁciently. Many high-speed DNA pattern matching algo-
rithms have been proposed in the literature. For example,
to accelerate search operations with large DNA sequences,
in [6], the authors proposed three efﬁcient algorithms: ﬁrst-
last, processor-aware, and least frequency pattern matching.
Although these algorithms showed an improvement in terms
of time cost compared to existing algorithms (brute force [7],
Boyer–Moore [8], and divide and conquer pattern matching
[9]), they still need to be further accelerated by hardware.
Other researchers have developed acceleration systems using
parallel computing platforms, for instance GPU [10] and
FPGA [11], to accelerate DNA pattern matching. However,
they do not provide a signiﬁcant improvement, as the existing
algorithms utilize slow sequential data processing. As such,
there is a need not only to accelerate DNA pattern matching
algorithms using hardware accelerators but also to develop
efﬁcient hardware-friendly algorithms for this task.

Associative memory (AM) is a powerful tool for in-memory
computing. It is a form of storage device that can be searched
in a parallel manner [12]. The address of any content that
matches an input data word is returned. The fast parallel
search offered by AM means that this type of memory is
used in a variety of applications with big data workloads, for
instance, genomic analysis, for which the amount of data has
experienced exponential growth in recent years [13]. Content-
addressable memory (CAMs) is one way to implement AMs.
CAMs can be realized with different technologies, for instance,
digital CAMs are implemented using standard CMOS and ﬂip-
ﬂops [14]. However, these types of architecture have high
power consumption and low density. Accordingly, various
emerging resistive device technologies have been used to
implement some recently proposed CAMs, beneﬁting from
their non-volatility and high packing density [15]. Examples

 
 
 
 
 
 
2

TABLE I
EXAMPLES OF NUCLEOTIDE-REPEAT DISORDERS [3], [4].

Disease

Gene

Pattern

Normal
range

Disease
range

Ataxia syndrome
Friedreich’s ataxia
Huntington’s disease
Fragile XE syndrome
Myotonic dystrophy 2
Spinocerebellar ataxia 1
Huntington’s disease-like 2
Spinal and bulbar muscular atrophy
Dentatorubral-pallidoluysian atrophy
Oculopharyngeal muscular dystrophy

FMR1
FXN
HTT
AFF2
DMPK
ATXN1
JPH3
AR
ATN1
PABPN1

CGG
GAA
CAG
CCG
CCTG
CAG
CTG
CAG
CAG
GCG

6–54
5–33
≤26
6–25
11–26
6–35
6–28
11–24
7–25
≤10

55–200
66–1300
>40
>200
75–11000
≥39
4–60
40–62
49–88
12–17

of resistive devices include ReRAM, phase change memory,
magnetic tunneling junctions, and ferroelectric devices [16].
Resistive-based CAMs have an order of magnitude improve-
ment in power consumption and area. Moreover, they can store
wide intervals, thereby enabling continuous search ranges for
analog applications. In this work, we study memristor-based
analog CAM (aCAM), which has a higher memory density
and lower power intake. aCAM could accelerate existing
applications and may enable potential new uses [17].

In this paper, we propose a hardware architecture that
can perform DNA pattern matching efﬁciently with low cost
in terms of latency and power consumption. The proposed
hardware accelerator uses AM and implements a hardware-
friendly version of
the processor-aware pattern matching
(PAPM) algorithm [6], in which input words are compared to
the entire pattern simultaneously using AM. Our objective is to
detect the presence of possible trinucleotide repeat-expansion
diseases. The contributions of this paper are summarized in
the following points:

• We propose a hardware-friendly version of the PAPM
algorithm [6] so that DNA pattern matching task can
be executed efﬁciently on a hardware accelerator. The
algorithm returns the maximum number of consecutive
repeats of a speciﬁc length-3 pattern.

• We propose the full architecture for a hardware accel-
erator. It uses AM to enable fast parallel searches and
matching. We design all the circuits needed to implement
the proposed algorithm.

• We evaluate the performance of the proposed design by
testing it with human DNA sequences and reporting the
overall energy and latency.

The remainder of the paper is organized as follows. Sec-
tion II discusses DNA pattern matching, the PAPM algorithm
proposed in [6], and our proposed hardware-friendly match-
ing algorithm. Section III describes the proposed hardware
architecture and its implementation. Section IV presents the
experimental setup. Section V reports the simulation results
in terms of latency and energy. Finally, Section VI concludes
the work.

II. DNA PATTERN SEARCH

Pattern matching is the process of ﬁnding all occurrences of
a pattern in a text. In DNA pattern matching, a DNA sequence

is scanned to detect the instances of a pattern of nucleotides
within it.

A. Related Work

In [6], the authors proposed three efﬁcient algorithms to
accelerate searches of large DNA sequences. The PAPM
algorithm is a word-based algorithm, in which two words
consisting of several characters are compared concurrently.
The word length (word_len) depends on the number of bits
per register in the processor. For instance, a 32-bit processor
can simultaneously compare length-4 words.

In this algorithm, the text to be searched is a DNA sequence
of length n, which is stored in an array t[0 . . . n−1]. The search
pattern has length m and is stored in an array p[0 . . . m − 1].
The operation of this algorithm has two phases:

• Preprocessing phase: The algorithm scans the interval
t[0 . . . n − m] of the text from left to right, searching
for the ﬁrst word in the pattern p[0 . . . word_len − 1].
In each iteration, it moves forward one character. When
an instance is found, the window of m characters starting
with this word is recognized as a potential interval of the
text that needs to be matched with the pattern in the next
phase.

• Matching phase: The remaining words in the identiﬁed
windows are precisely compared with those of the pattern
to detect the matches.

B. Proposed Hardware-friendly Matching Algorithm

In our work, we propose a hardware accelerator that uses
AM to analyze DNA data more efﬁciently in parallel. We also
propose a modiﬁed version of the PAPM algorithm [6] that is
executed by this accelerator. The proposed algorithm returns
the maximum number of consecutive pattern repeats instead
of the total number of occurrences, because our objective is
to detect possible repeat-expansion diseases where a speciﬁc
pattern is abnormally expanded.

As AM allows parallel searches, we store the DNA data in
an AM array, so that in each cycle, we compare a pattern
of length p to p cells simultaneously across all rows. For
the pattern occurrences found, if any, we store a 1 in the
corresponding binary memory cells. Then, we move one
character (one cell) and re-compare. As the pattern may be

3

strong candidate for DNA pattern matching since its ability
to store discrete multi-bit ranges enables the search for DNA
characters.

A. aCAM Cell

A recent study [18] compared different types of switching
devices including memristors, phase change, magnetorsistors,
and FeFET devices. Memristor devices have key properties,
such as a high number of distinguishable states, fast switching
speed, and good endurance and retention, thereby qualifying
them as good candidates for aCAM applications. Several
types of memristor-based aCAM have been proposed in the
literature. In [19], the authors analyzed and compared different
memristor-based aCAM cells. They found that the 8T2M cell
was the most energy-efﬁcient and offers low latency, low
failure probability, and small area compared to other types
of aCAM. Thus, the 8T2M design is a suitable candidate for
DNA pattern matching.

An 8T2M aCAM cell is shown in Fig. 2(a). The circuit
is mainly divided into two voltage divider subcircuits that
determine the lower and upper bounds of the stored interval,
respectively, depending on the programmed resistance value
in each of them. The lower-bound subcircuit consists of a
transistor connected in series to a variable resistance RLB,
followed by an inverter that controls the voltage VG1 at
the gate of a PMOS transistor T1. The lower-bound match
threshold of the aCAM cell (LB) is determined by tuning the
resistance RLB. Similarly, the upper-bound match threshold

(a)

(b)

Fig. 2. (a) Schematic of a complete 8T2M aCAM cell. (b) Plot of the transient
behavior of an 8T2M aCAM cell with match interval [0.35 V, 0.45 V] at
three different LDL = UDL inputs: matching, lower-bound mismatching, and
upper-bound mismatching.

Fig. 1. Proposed high-level design for comparing a pattern of length 3.

split between two rows, at the end of each row, we use (p − 1)
additional cells to store the ﬁrst (p − 1) characters of the row
below it, as illustrated in Fig. 1. For the last row, the additional
cells store a dummy character that will be explained later.
We then use a pattern detector to ﬁnd the maximum number
of consecutive pattern instances in the stored DNA data.
Algorithm 1 illustrates the steps in the proposed procedure.
The pattern detector algorithm is described in Section III-D3.

Algorithm 1: Matching phase
Input: DNA data text[1...t] and pattern P[1...p]
Output: Memory array mem(M, N-(p-1))

1 AM = zeros(M, N)
2 mem = zeros(M, N-(p-1))
/* Loading Data
/* Except last row

3 count=1
4 for i ← 1 to N − 1 do
5

AM(i, 1:N-(p-1)) = text(count:count+N-p)
count = count+N-(p-1)

6

/* Last row
/* Remaining characters

7 r = t - (M-1)*(N-(p-1))
8 AM(M, 1:r) = text((M-1)*(N-(p-1)+1:t))
/* Replication of characters

9 AM[(1:M-1), (N+1:N+p-1)] = AM[(2:M), (1:p-1)]

/* N-(p-1) cycles
10 for i ← 1 to N − (p − 1) do
11

mem[(1:M), i] = (AM[(1:M), (i:i+p-1)] == P)

/* Run pattern detector

12 Pattern Detector(mem)

*/
*/

*/
*/

*/

*/

*/

III. HARDWARE ARCHITECTURE

To perform binary and ternary search operations more
efﬁciently, researchers have recently suggested replacing the
CMOS devices in AM with memristors. More recently, the
authors in [17] proposed a form of memristor-based aCAM
that can store a range of values, which can be matched or
not
to an analog input. In addition to its ability to store
wide continuous intervals, an aCAM can store multiple narrow
ranges as discrete levels, allowing the storage of at least 3 bits
per cell. aCAM can replace digital CAM while improving both
storage density and power consumption. As such, aCAM is a

(UB) is conﬁgured with an independent voltage divider using a
variable resistance RU B and an inverter to generate the voltage
VG2 at the gate of the pull-down NMOS transistor T2. We
modiﬁed the aCAM cell such that the input for the lower-
bound subcircuit VLDL is different from that of the upper-
bound subcircuit VU DL, for reasons that we explain later.

An aCAM search operation consists of two phases: pre-
charge and evaluate. First, the match line (ML) is pre-charged
to a high logic level trough a pull-up PMOS transistor by
setting its gate voltage nPC to low, as illustrated in Fig. 2(b).
Then, the evaluation phase starts by setting the VSLHI signal
to high and VN S to 0. The arrival of the low NS signal is
delayed to give time for G1 to evaluate and prevent it from
falsely discharging the ML.

If VLDL is less than the lower bound, a low voltage, smaller
than VP C − |Vtp|, builds on G1, where VP C is the ML pre-
charge voltage. This yields a mismatch because T1 will turn
on and discharge the ML. On the other hand, if VU DL is
greater than the upper bound, a high voltage, greater than the
threshold voltage Vtn, builds on G2, turning T2 on, and the
ML is discharged to a low level through T2. Thus, the ML
stays high only when the search input belongs to the interval
stored in the cell (match), set by the resistance values of RLB
and RU B.

Fig. 3 illustrates the voltage transfer characteristics for
VG versus VDL. Based on these curves, for a given pair of
RLB and RU B resistances, the corresponding lower and upper
bounds of the stored interval can be determined based on
the VDL values, which results in VG1 = VP C − |Vtp| and
VG2 = Vtn.

B. DNA Pattern Encoding

As discussed previously, DNA sequences are combinations
of four nucleotides: A, C, G, and T. Thus, if one aCAM cell
stores one DNA character, four discrete levels are needed to
represent the DNA characters. Using the aCAM design shown
in Fig. 2(a), four intervals are obtained for the resistance
conﬁgurations shown in Table II. Such an encoding guarantees
zero failure. Squeezing more than one character per interval
would lead to some failure, especially if there was variability
[19]. Each DNA character can be mapped into one interval
deﬁned by a lower and an upper bound, corresponding to
resistances RLB and RU B, respectively (explained in Sec-
tion III-A). Fig. 4 shows the transient ML voltage measured
at 1 ns vs VDL for the four intervals. Note that we added a
buffer of two inverters after which we read VM L, as will be
discussed later. The intervals are no longer symmetric because
of the gain after the inverters.

TABLE II
NUCLEOTIDE CHARACTER ENCODING

Programmed resistances
Stored
character RLB (kΩ) RU B (kΩ)

Stored interval
[LB, UB] (V)

A
C
G
T

2500
163.3
24.9
8.9

186.32
27.6
9.69
5.06

[0.19, 0.31]
[0.32, 0.44]
[0.46, 0.59]
[0.63, 0.79]

4

(a)

(b)

Fig. 3. Voltage transfer characteristics (a) VG1 vs VLDL and (b) VG2 vs
VU DL for R ∈ [5 kΩ, 2.5 MΩ].

Fig. 4. VM L measured at 1 ns vs VDL for the four DNA character intervals
deﬁned in Table II.

C. Row Matching

To search for a speciﬁc character in an aCAM cell, we apply
to its inputs a voltage equal to the average of the lower and
upper bounds of the corresponding interval deﬁned in Table II.
The cell matches only if its stored character is equal to the
one searched for.

An aCAM cell can be deactivated to give a match, regardless
of its stored character, by applying to its lower-bound subcir-
cuit a voltage VLDL = VDD and to its upper-bound subcircuit
a voltage VU DL = 0. Based on Fig. 3(a), if the input VLDL
is equal to VDD for any resistance value in the range, the
resulting VG1 is high, greater than VP C − |Vtp|, thus T1 will
remain off and the lower-bound subcircuit matches. Similarly,
Fig. 3(b) shows that for an input VU DL = 0, the obtained VG2
is less than Vtn for all resistance values. Hence, T2 remains off

TABLE III
DIFFERENT COMBINATIONS OF SEARCHED AND STORED DATA THAT
RESULT IN EITHER A MATCH OR MISMATCH STATE.

Search data

Mask

{VLDL, VU DL} (V)

Stored character

Output state

0

1

–

A

C

G

T

{VDD, 0}

{0.25, 0.25}

{0.38, 0.38}

{0.53, 0.53}

{0.71, 0.71}

X

A
C / G / T

C
A / G / T

G
A / C / T

T
A / C / G

Match

Match
Mismatch

Match
Mismatch

Match
Mismatch

Match
Mismatch

and the upper-bound subcircuit matches. Table III shows the
different combinations of searched and stored data that result
in either a match or mismatch state. A full match occurs when
all the aCAM cells match within the same row, otherwise, a
mismatch is recorded, as illustrated in Fig. 5. An additional
interval, MM, is needed to give a mismatch for any input. This
interval is stored in the extra aCAM cells of the last row of
the array, as discussed earlier. We set its RLB to RU B of the
last interval and its RU B to RLB of the ﬁrst interval.

Fig. 5. aCAM search operation example. Blue cells are matched, red cells
are mismatched, and black cells are deactivated.

D. Proposed Architecture

Fig. 6 is an overview of the proposed architecture. The
architecture consists of three main building blocks, as dis-
cussed earlier: (1) AM, which stores the DNA sequence,
(2) matching-index memory, which stores the index of the
pattern matches, and (3) the pattern detector, which ﬁnds the
maximum number of consecutive pattern repeats. The details
of the full implementation of each block are described in this
section.

1) Associative Memory: The designed AM consists mainly
of three blocks: aCAM array, block selector, and tag registers.
a) aCAM array: The DNA data are stored in an M ×
N aCAM array. Since we are looking for the occurrences of
a speciﬁc pattern of length equal to p, then, in our search,
we activate a window of only p cells to check if this pattern
exists. As the comparison can be done in parallel across the
rows, p cells are activated per row in each cycle, and these

5

are compared to the pattern. The input to the activated cells
is set corresponding to the pattern characters, as deﬁned in
Table III, whereas the aCAM cells of the deactivated columns
will have VLDL set to VDD and VU DL set to 0, so that they
result in a match, regardless of the characters they are storing,
as discussed earlier. The window of p activated cells is shifted
by one cell in each cycle till the end of the row, where there
are special cases, since the pattern may be split between two
rows. To handle these cases, we replicate (p − 1) characters.
Thus, at the end of each row, we replicate and add the ﬁrst
(p − 1) aCAM cells from the row below it. If the DNA data
are not a multiple of the row length N , the extra cells store
the interval MM so that they always result in a mismatch.

b) Block selector: In nucleotide-repeat diseases, the lo-
cation of the pattern repeats is important. In fact, for each
disease, the repeats must be in a speciﬁc gene. For example,
for Huntington’s disease, the CAG repeats must be in the
HTT gene, which is a portion of the entire DNA sequence.
To allow the detection of different diseases, we store multiple
critical genes in the aCAM array. We divide the array into
eight blocks, so that for each disorder, we activate the blocks
containing the corresponding gene. To select or activate spe-
ciﬁc blocks, we designed a block selector. Its implementation
is explained in Supplementary Note 1. The block selector
activates the desired blocks by connecting its output to the
aCAM cells as follows. Fig. 2(b) shows the signaling for the
8T2M aCAM design. In the evaluate phase, VN S is set to 0.
An aCAM cell can, therefore, be deactivated by keeping its
VN S high during this cycle. As such, the aCAM cells of an
activated block should have VN S = 0 during the evaluation,
whereas those included in a deactivated block should always
have VN S high. Therefore, the block selector output should be
inverted before it is connected to the NS of an aCAM cell.

c) Drivers: The output of each block selector is con-
nected to several chains of three inverters with an increasing
width size, and their output is connected to the NS of the
aCAM cells.

d) Tag registers: In each cycle, the ML result of each
row is stored in the tag, which is written to memory. The tag
consists of a buffer (two inverters) connected to a ﬂip-ﬂop that
stores the ML value.

2) Match-Index Memory: In each cycle, after we have the
values ready at the tag, we write them to a 1T1R memory
array, so that we can later read the memory and input the
values to the pattern detector to detect the patterns. The role of
each 1T1R cell is to store either a low-resistive state or a high-
resistive state (HRS) corresponding to whether the pattern in
the aCAM array is a match or mismatch. This is done during
the memory write operation. After the array is populated, the
next step is to read the array. The pattern detector counts
how many consecutive patterns there are and determines the
length of the sequence. After these operation are complete, we
reset the memory array to HRS so that it is for the next use.
The control unit generates the read, write, and reset signals to
organize the sequential functions of the memory.

Each 1T1R cell consists of a memristor and an NMOS
transistor, connected as shown in Fig. 7. The values of the
signals at each node (SL, X, and Y) vary depending on the

C0.32 ~ 0.44MatchMismatchMismatchA0.19 ~ 0.3C0.32 ~ 0.44A0.19 ~ 0.3T0.63 ~ 0.79G0.46 ~ 0.59G0.46 ~ 0.59C0.32 ~ 0.44T0.63 ~ 0.79T0.63 ~ 0.79G0.46 ~ 0.59A0.19 ~ 0.3T0.63 ~ 0.79A0.19 ~ 0.3C0.32 ~ 0.440.380.250.5300.800.8MLC    A    GDeactivated CellsActivated CellsPatternLDLUDL………………6

Fig. 6. Full hardware architecture for the proposed design.

write, read, or reset mode of the memory, as summarized in
Supplementary Table III.

a) Memory write: During the memory write operation,
the rows of the 1T1R memory array are ﬁlled in parallel based
on the values received from the tag in each cycle. Each tag
output is connected to a corresponding row (X), which is
determined by the signal C, as illustrated in Fig. 7. This is
then followed by drivers with four inverters, which drive the
current. As all rows are written in parallel, a column selector
circuit is needed to write the columns (Y) of the memory array
sequentially.

As shown in Supplementary Table III, to write a column,
the corresponding Y node must be 0 and all the others 1 to
avoid creating a current path between Y and SL (since SL =
Vset) and thus, to avoid writing them as well. To achieve this
functionality, we need a counter followed by a decoder and
transmission gates. In this way, the transmission gate outputs
a 0 only for the targeted column that is to be written. All the
other columns are high. The transmission gates are controlled
by the signal A (Fig. 7), which passes the ground value for
the speciﬁc column chosen by the decoder (z = 1). Note that
while writing the memory, the read circuitry is disconnected
using the transmission gates controlled by the read signal.

For an n-column memory, the column selector circuit has a
log2 n-bit counter, then a log2 n to n-bit decoder, followed
by n transmission gates to get the desired Y value. This
architecture is illustrated for a 128 × 128 memory in Fig. 7.
b) Memory read: When all the write cycles are complete,
then the 1T1R memory array is fully written. We need to read
the values and input them, one by one, to the pattern detector
circuit, which counts and detects the maximum sequence
length. Reading the whole memory requires a row selector
to traverse the rows and a multiplexer to connect the columns
to a current sense ampliﬁer sequentially to sense the stored
values.

To avoid traversing the whole memory cell by cell and
thus, increasing the delay, we will read every eight consecutive
cells in parallel and save them in an 8-bit parallel-in serial-out
(PISO) register, which will output them serially, one by one,
to the pattern detector circuit. To do so, we need eight n/8-bit
multiplexers, which are a chain of transmission gates whose
function is to select the eight columns and connect them to
the corresponding current sense ampliﬁer. Thus, we need eight
current sense ampliﬁers for the eight columns selected. Their
output will be passed to the 8-bit PISO register, as shown in
Fig. 7. The selectors of the multiplexers are determined by a
log2 n/8-bit counter. The outputs of this counter are AND’ed
and connected as the clock to the row selector circuit counter,
which ensures that we read the next row only when all the
current columns are read. Note that during the read operation,
the column selector circuit is disconnected.

For an m×n memory array, the row selector circuit consists
of a log2 m-bit counter, which is followed by a log2 m-
to m-bit decoder, then drivers to drive the current and m
transmission gates to get the desired X node value.

c) Memory reset: Finally, as shown in Fig. 7, to reset
the memory after each memory read, the columns (Y) must
be connected to Vreset, SL to the ground, and the rows (X) to
the reset signal to turn on the NMOS transistors and allow the
current to ﬂow from Y to SL, thus resetting the 1T1R cell to
a HRS. During this mode, the column and row selectors and
the read circuits are all disconnected.

3) Pattern Detector: The output of the PISO register is
input, bit by bit, into the pattern detector, which ﬁnds the max-
imum number of consecutive instances of a speciﬁc pattern. A
bit equal to 1 indicates that an occurrence of the pattern was
found. Thus, for patterns consisting of different characters, for
example CAG, every 1 should be followed by (p−1) zeros. As
such, whenever a 1 is received, the pattern detector can skip
(p − 1) bits and check again. If the input is 1, the number of

....................................7

Fig. 7. Full memory architecture for a 128 × 128 match-index array.

Fig. 8. Three pointers traversing the sequence of memory bits.

repeats is incremented. If it is a 0, the maximum is updated,
and the count restarts from 0 and the sequence of inputs is
traversed, bit by bit, until a new 1 is found, after which we
can skip (p − 1) bits and check again. Note that for DNA
pattern detection, the maximum length of a pattern consisting
of different characters is 4, as there are only four nucleotides.
To generalize the pattern matching procedure to any DNA
pattern, more than one pointer must traverse the sequence,
because a 1 is not necessarily followed by (p − 1) zeros.
Without loss of generality, for length-3 patterns, three pointers
are needed to scan the inputs received from the PISO register.
The ﬁrst one checks the inputs having an index modulo 3 = 1.
The second pointer scans the inputs with index modulo 3 = 2,
and ﬁnally, the third pointer traverses the inputs with index
modulo 3 = 0, as illustrated in Fig. 8. Pointer 1 starts from
the ﬁrst input, then it skips 2 bits to check the fourth input,
and so on, and similarly for pointers 2 and 3. Each pointer
has its own counter and maximum register, which saves the
number of consecutive repeats.

Algorithm 2 shows at a high level the pattern detection

procedure for a length-p pattern. Fig. 9 is a block diagram
of the full pattern detector. In addition to the input X from
the PISO register, another input, D, is needed so that the
pattern detector can determine the end of the sequence. The
pattern detector consists of a ﬁnite state machine, three pointer
blocks, a comparator, and a global maximum register. The
ﬁnite state machine, which takes inputs X and D, outputs
the signals C and R needed for each pointer block. A clear
output (CLR) is also used to reset the counters of the pointer
blocks in the initial and exit states, as will be explained later.
Fig. 10 is a state diagram of the ﬁnite state machine. Each
pointer has a block consisting of a counter, a comparator, and
a maximum register. The counters are initially reset. Whenever
a 1 is received from the PISO, the counter of the corresponding
pointer is incremented by 1 (C = 1), whereas if the input is
0, the corresponding maximum register is compared to the
counter value and updated if needed, and the counter is then
reset (R = 1). When the sequence ends, indicated by the D
input, all the counters are reset and the maximum of the three
maximum registers is found and stored in the global maximum
register.

As an example, let us assume that the input sequences for
X and D are “1 0 1 1 1 0 0 0 0” and “0 0 0 0 0 0 0 0 1”,
respectively. Table IV shows the current state starting from the
initial state and each subsequent state depending on the input
xD, along with the required action in that state. The last state
is the exit state, which returns the global maximum.

4) Control Unit: The role of the control unit is to gen-
erate the control signals required by each block of the full

111128. . . .2288. . . .1128. . . .. . . .. . . .. . . .. . . .. . . .. . . .. . . .. . . .. . . ........ . . .101010000100….Pointer 1Pointer 3Pointer 2Algorithm 2: Pattern detection phase
Input: Memory array mem(m, n)
Output: Global max: maximum number of

consecutive pattern occurrences

1 ctr = zeros(1, p)
2 max = zeros(1, p)
3 for i ← 1 to m do
4

for j ← 1 to n do
idx = (i-1)n + j
x = (idx mod p)
if mem[i, j] == 1 then

5

6

7

8

9

10

11

ctr[x]++

else

/* Update the maximum
max[x] = ctr[x]
/* Reset the counter
ctr[x] = 0

*/

*/

12 Global max = maximum(max)

Fig. 9. Block diagram of a pattern detector for comparing a length-3 pattern.

Fig. 10. State diagram of the ﬁnite state machine.

architecture to organize the phases and ensure the correct
sequential ﬂow of the data. For example, it generates the read,
write, and reset signals in the match-index memory depending
on the different memory modes to ensure the operations are
correct. The control unit can be realized on software running
on a coprocessor. Hence, we have not discussed its circuit
implementation.

Timing considerations: When an input equal

to 0 is
received from the PISO register,
two actions need to be
done: (1) Comparing and updating the maximum register and
(2) resetting the counter of the corresponding pointer. It is
important to separate the comparison and reset steps in time to

8

TABLE IV
PATTERN DETECTOR ACTIONS BASED ON THE EXAMPLE INPUT SEQUENCE.

Current state; Input

Next state

Action in next state

Initial; 10

S2; 00

S3; 10

S6; 10

S2; 10

S4; 00

S5; 00

S1; 00

S3; 01

S2

S3

S6

S2

S4

S5

S1

S3

Exit

Increment ctr1 (C1=1): ctr1=1

Update max2: max2:=0Reset ctr2 (R2=1): ctr2=0

Increment ctr3 (C3=1): ctr3=1

Increment ctr1 (C1=1): ctr1=2

Increment ctr2 (C2=1): ctr2=1

Update max3: max3:=0Reset ctr3 (R3=1): ctr3=0

Update max1: max1:=2Reset ctr1 (R1=0): ctr1=0

Update max2: max2:=0Reset ctr2 (R2=0): ctr2=0

Global max = 2

ensure that the comparison happens before the counter is reset.
Since every pointer is activated every three cycles, we delayed
the comparison by one clock cycle and the reset by two clock
cycles, so that both are completed before the same pointer
hits another input. When the sequence of bits is ﬁnished, the
pattern detector should read four extra zeros to ensure that all
the maximum registers are updated. An additional 0 is needed
to move it to the exit state, when all the counters are reset
and the three maximum registers are compared to determine
the maximum among them. Hence, we delayed the end of the
sequence signal by four clock cycles. Since the reset is delayed
by two clock cycles, we used the CLR signal, which we set
to 1 in the initial and exit states so that the counters are reset
in those states.

We consider that the DNA data are loaded to AM at t1
seconds. The aCAM cells can be programmed row by row, so
within the same row, the cells that store the same character
can be programmed simultaneously. Since there are four DNA
characters and two memristors in each aCAM cell, the time
to load each row is 8Tw where Tw is the memristor write
time. Hence, loading the data into M rows takes 8M Tw.
Note that loading the data is done only once. Then, for each
block in the aCAM array, the memory write can happen in
parallel with the pattern search phase, starting after a 1/2 clock
cycle. After that, we read the match-index memory, and the
pattern detection starts one clock cycle later. Finally, we have
to reset the memory, which is done in one clock cycle. This
functionality is illustrated in Fig. 11 and can be expressed by
the following set of deﬁnitions:

t1 = 8M Tw

∆t12 = (N − (p − 1) + 0.5)T

∆t23 = 0.125 (m n + 5)T

∆t34 = T

ts,k = (t1 + K ∆t14)T

(1a)

(1b)

(1c)

(1d)

(1e)

where T is the clock period and ts,k is the total search time
for reading K blocks.

S1S2S3R2S4C2S5S6C3001000100000100000101010X1X1X1X1X1X1XXExitCLR0010C1InitialCLRR1R39

Fig. 11. Complete timing diagram for a full load and search cycle.

IV. EXPERIMENTAL SETUP

Fig. 3 in Supplementary Note 2.

We built a simulation framework with MATLAB and
HSPICE for both circuit and system simulations. In the circuit
simulations, we relied on predictive technology models for 45-
nm high-k/metal gate CMOS devices [20] to study the design
metrics. We set VDD = 0.8 V.

The AM has a block selector, drivers, aCAM array, and
tag. We implemented the block selector using CMOS gates,
as explained in Supplementary Note 1. The output of each
block selector is connected to 64 drivers with three inverters
each, which are connected to the rows of the aCAM array. We
used an 512 × 130 aCAM array to store the DNA data, which
we divided into eight blocks, each consisting of 64 rows. The
ML of each row is connected to a driver with two inverters,
followed by a ﬂip-ﬂop that stores the ML result.

For our memory simulations, we adopted a linear memristor
model. We studied a 64 × 128 memory array. Accordingly the
memory components were as follows. For a write operation
to a 64 × 128 memory array, the column selector circuit has
a 7-bit counter, then a 7- to 128-bit decoder followed by 128
inverters and 128 transmission gates. To read the memory, the
row selector circuit consists of a 6-bit counter, followed by
a 6- to 64-bit decoder, then 64 transmission gates. To read
every eight consecutive cells in parallel, we used eight 16-
bit multiplexers connected to eight current sense ampliﬁers,
whose outputs are passed to an 8-bit PISO register. The circuit
connections are as shown in Fig. 7. For the column and row
selector circuits, we used synchronous master–slave JK-ﬂip-
ﬂop up counters to minimize the delays and avoid glitches.
For the current sense ampliﬁer, we used the circuit presented
in [21]. We modiﬁed the Ron, Roff, and Rref parameters to meet
the speciﬁcations of our circuit: Ron = 5 kΩ, Roff = 2.5 MΩ,
and Rref = 14 kΩ. For the pattern detector, ﬁrst, for the
ﬁnite state machine, we used dynamic ﬂip-ﬂops to represent
the states, which enhanced performance and speeded up the
latching. Then, for each pointer block, we used an 8-bit D-
ﬂip-ﬂop counter, an 8-bit comparator, and an 8-bit maximum
register, as shown in Fig. 2 in Supplementary Note 2. The
comparison logic, which returns the maximum value among
all the maximum registers, was implemented using two 8-bit
comparators, two multiplexers, and an 8-bit global maximum
register, which stores the global maximum, as illustrated in

V. RESULTS AND DISCUSSION

In this section, we evaluate the performance of our circuit in
terms of key metrics, namely latency, energy, and area. First,
for the delay, by applying the time equations in the timing
considerations under Section III-D4 and based on Fig. 11,
assuming Tw = 1 cycle, the amount of overhead needed to
load the data into the aCAM array is 8M T = 4.096 µs.
The memory write and pattern search time is 128.5 ns. The
memory read and pattern detection time is 1024.625 ns, and
the memory reset time is 1 ns. As such, in total, ignoring
the time overhead, the pattern matching task for one aCAM
block takes around 1.15 µs. Therefore, our design signiﬁcantly
reduces the time required for DNA pattern matching.

Energy values were obtained from simulations, except for
writing the memory, since we adopted a linear resistor model,
so we assumed that the memristor SET energy is 1 pJ. We
calculated that the full write energy of the 1T1R memory array
is 1.228 nJ. The reset energy is the same as the write energy,
since all the SET cells need to be reset. The memory read
energy is 0.82 nJ, the pattern search energy is 1.1769 nJ, and
the pattern detection energy is 0.7709 nJ. Thus, the total search
energy per character is 0.61 pJ.

Fig. 12 shows the distributions of both time and energy
among the different operations. Note that the read memory
and pattern detection modes as well as memory write and
pattern search are combined in the latency ﬁgure since they
operate in parallel.

The active area estimates are based on the calculations
presented in Supplementary Note 4. Accordingly, the AM area
was calculated to be 47.78 mm2, the match-index memory area
as 0.155 mm2, and the pattern detector area as 0.0926 mm2.
To determine the effect of increasing the pattern length on
run time and energy, we consider the example of a DNA
sequence of 1 million characters. For a pattern of length 3,
there are two replicated cells in each row, so 16 aCAM arrays
are needed to store the DNA data, each consisting of eight
blocks. Assuming that we have one shared memory for all
the blocks of the aCAM arrays, for p = 3, ignoring the time
overhead in Equation (1e), the total run time for the pattern
matching task is 147.7 µs. On the other hand, for a pattern

........................10

[7] “T. h. cormen c. e. leiserson, r. l. rivest, and c. stein, introduction to
algorithms (computer science). cambridge, ma, usa: Mit press, 2009.
[8] R. S. Boyer and J. S. Moore, “A fast string searching algorithm,”
Communications of the ACM, vol. 20, no. 10, pp. 762–772, 1977.
[9] S. V. Raju, K. Reddy, and C. S. Rao, “Parallel string matching with
linear array, butterﬂy and divide and conquer models,” Annals of Data
Science, vol. 5, no. 2, pp. 181–207, 2018.

[10] S. P. Adey, “Gpu accelerated pattern matching algorithm for dna
sequences to detect cancer using cuda dissertation,” Coll. Eng. Pune,
2013.

[11] S. Lei, C. Wang, H. Fang, X. Li, and X. Zhou, “Scadis: A scalable
accelerator for data-intensive string set matching on fpgas,” in 2016
IEEE Trustcom/BigDataSE/ISPA.

IEEE, 2016, pp. 1190–1197.

[12] I. Arsovski, T. Chandler, and A. Sheikholeslami, “A ternary content-
addressable memory (tcam) based on 4t static storage and including
a current-race sensing scheme,” IEEE Journal of Solid-State Circuits,
vol. 38, no. 1, pp. 155–158, 2003.

[13] E. Garz´on, R. Golman, Z. Jahshan, R. Hanhan, N. Vinshtok-Melnik,
M. Lanuzza, A. Teman, and L. Yavits, “Hamming distance tolerant
content-addressable memory (hd-cam) for dna classiﬁcation,” IEEE
Access, 2022.

[14] Z. Kokosi´nski and W. Sikora, “An fpga implementation of a multi-
comparand multi-search associative processor,” in International Confer-
ence on Field Programmable Logic and Applications. Springer, 2002,
pp. 826–835.

[15] M. E. Fouda, H. E. Yantır, A. M. Eltawil, and F. Kurdahi, “In-memory
associative processors: Tutorial, potential, and challenges,” IEEE Trans-
actions on Circuits and Systems II: Express Briefs, 2022.

[16] X. Yin, C. Li, Q. Huang, L. Zhang, M. Niemier, X. S. Hu, C. Zhuo,
and K. Ni, “Fecam: A universal compact digital and analog content
addressable memory using ferroelectric,” IEEE Transactions on Electron
Devices, vol. 67, no. 7, pp. 2785–2792, 2020.

[17] C. Li, C. E. Graves, X. Sheng, D. Miller, M. Foltin, G. Pedretti, and
J. P. Strachan, “Analog content-addressable memories with memristors,”
Nature communications, vol. 11, no. 1, pp. 1–8, 2020.

[18] Z. Wang, H. Wu, G. W. Burr, C. S. Hwang, K. L. Wang, Q. Xia, and
J. J. Yang, “Resistive switching materials for information processing,”
Nat Rev Mater, pp. 173–195, 2020. [Online].

[19] J. Bazzi, J. Sweidan, M. E. Fouda, R. Kanj, and A. M. Eltawil, “Efﬁcient

analog cam design,” arXiv preprint arXiv:2203.02500, 2022.

[20] http://ptm.asu.edu/.
[21] X. Sun, S. Yin, X. Peng, R. Liu, J.-s. Seo, and S. Yu, “Xnor-rram: A
scalable and parallel resistive synaptic architecture for binary neural
networks,” in 2018 Design, Automation Test
in Europe Conference
Exhibition (DATE), 2018, pp. 1423–1428.

(a)

(b)

Fig. 12. Simulation results: (a) latency breakdown and (b) energy breakdown.

of length p = 5, we still need 16 aCAM arrays. However, in
this case, there are four replicated cells in each row, hence
130 − 4 = 126 cycles instead of 128. The total run time is
144.4 µs. Increasing the pattern length to 10, and following
the same logic, the total run time is 148.393 µs. Moreover,
we estimated the energy per cycle for each block in our
design based on our simulations. For each pattern length, we
multiplied the energy values per cycle by the corresponding
number of cycles. Accordingly, for p = 3, the total energy is
5.2 nJ. For p = 5, it decreases slightly to 5.09 nJ, and for
p = 10, it is 4.9 nJ.

VI. CONCLUSION

In this paper, we propose a hardware accelerator for DNA
pattern matching. The proposed design stores the DNA char-
acters in AM and accelerates a hardware-friendly algorithm in
a highly parallelized way. The algorithm counts the maximum
number of consecutive repeats of a speciﬁc pattern, which can
be used to detect the presence of possible trinucleotide repeat-
expansion genetic disorders. The proposed design is energy-
efﬁcient, and it showed a remarkable improvement in terms
of time cost compared to software implementations of DNA
pattern matching. The fabrication of this hardware accelerator
is left for future work. Moreover, we are planning to test
the proposed design on practical datasets containing human
genome sequences.

REFERENCES

[1] S. U. Mane and K. H. Pangu, “Disease diagnosis using pattern matching
algorithm from dna sequencing: a sequential and gpgpu based approach,”
in Proceedings of
the International Conference on Informatics and
Analytics, 2016, pp. 1–5.

[2] H. Paulson, “Repeat expansion diseases,” Handbook of clinical neurol-

ogy, vol. 147, pp. 105–123, 2018.

[3] E. Lalonde, S. Rentas, F. Lin, M. C. Dulik, C. M. Skraban, and N. B.
Spinner, “Genomic diagnosis for pediatric disorders: revolution and
evolution,” Frontiers in Pediatrics, vol. 8, p. 373, 2020.

[4] K. Usdin, “The biological effects of simple tandem repeats: lessons from
the repeat expansion diseases,” Genome research, vol. 18, no. 7, pp.
1011–1019, 2008.

[5] D. Adjeroh, Y. Zhang, A. Mukherjee, M. Powell, and T. Bell, “Dna
sequence compression using the burrows-wheeler transform,” in Pro-
ceedings. IEEE Computer Society Bioinformatics Conference.
IEEE,
2002, pp. 303–313.

[6] P. Neamatollahi, M. Hadi, and M. Naghibzadeh, “Simple and efﬁcient
pattern matching algorithms for biological sequences,” IEEE Access,
vol. 8, pp. 23 838–23 846, 2020.

