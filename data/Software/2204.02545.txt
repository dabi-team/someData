2
2
0
2

y
a
M
6
1

]

R
C
.
s
c
[

3
v
5
4
5
2
0
.
4
0
2
2
:
v
i
X
r
a

Stateful Greybox Fuzzing

Jinsheng Ba1, Marcel Böhme2,3, Zahra Mirzamomen2, and Abhik Roychoudhury1

1National University of Singapore, 2Monash University, 3MPI-SP

Abstract

Many protocol implementations are reactive systems,
where the protocol process is in continuous interaction with
other processes and the environment. If a bug can be exposed
only in a certain state, a fuzzer needs to provide a speciﬁc
sequence of events as inputs that would take protocol into
this state before the bug is manifested. We call these bugs as
“stateful" bugs. Usually, when we are testing a protocol imple-
mentation, we do not have a detailed formal speciﬁcation of
the protocol to rely upon. Without knowledge of the protocol,
it is inherently difﬁcult for a fuzzer to discover such stateful
bugs. A key challenge then is to cover the state space with-
out an explicit speciﬁcation of the protocol. Finding stateful
bugs in protocol implementations would thus involve partially
uncovering the state space of the protocol. Fuzzing stateful
software systems would need to incorporate strategies for
state identiﬁcation. Such state identiﬁcation may follow from
manual guidance, or from automatic analysis.

In this work, we posit that manual annotations for state
identiﬁcation can be avoided for stateful protocol fuzzing.
Speciﬁcally, we rely on a programmatic intuition that the
state variables used in protocol implementations often ap-
pear in enum type variables whose values (the state names)
come from named constants. In our analysis of the Top-50
most widely used open-source protocol implementations, we
found that every implementation uses state variables that are
assigned named constants (with easy to comprehend names
such as INIT, READY) to represent the current state. In this
work, we propose to automatically identify such state vari-
ables and track the sequence of values assigned to them during
fuzzing to produce a "map" of the explored state space.

Our experiments conﬁrm that our stateful fuzzer discovers
stateful bugs twice as fast as the baseline greybox fuzzer that
we extended. Starting from the initial state, our fuzzer exer-
cises one order of magnitude more state/transition sequences
and covers code two times faster than the baseline fuzzer.
Several zero-day bugs in prominent protocol implementations
were found by our fuzzer, and 8 CVEs have been assigned.

Figure 1: Dynamically constructed state transition tree (STT)
for an HTTP2 protocol implementation (H2O).

1

Introduction

Protocol implementations are stateful software systems that
require input messages to be sent in a certain expected order.
Conventional greybox fuzzing approaches consider structured
program inputs, which are subject to random mutations for ex-
ploring the space of program inputs. However, for protocols,
the input needed to trigger a behavior is a sequence of mes-
sages, events, or actions. Thus for exposing corner cases or
bugs in such systems, which we call stateful bugs, the fuzzing
technique needs to explore an unknown state space by con-
structing and navigating suitable event sequences. We design,
implement and evaluate such a fuzzer in this paper.

Existing coverage-guided greybox fuzzers (CGF) [1, 23]
have been very successful at ﬁnding bugs, but they cannot ef-
fectively deal with a state space. For instance, the HTTP2 pro-
tocol requires a HEADER frame to be sent before the DATA
frame. In the H2O implementation (Figure 1), a state variable
is set to a certain value when the HEADER frame is received.
The same state variable is checked when the DATA frame is
received. Suppose, there is a bug in the response to a correctly

1

IDLERECV_HEADERSRECV_BODYREQ_PENDINGSEND_HEADERSSEND_BODYBODY_IS_FINALEND_STREAMEND_STREAMEND_STREAMEND_STREAMREQ_PENDINGSEND_HEADERSSEND_BODYBODY_IS_FINALEND_STREAM 
 
 
 
 
 
processed DATA frame. As there is a speciﬁc sequence of
input messages needed to reveal the bug, we call this a stateful
bug. Suppose also that the ﬁrst generated input sends a DATA
frame and then a HEADER frame. Clearly, the DATA frame
cannot be processed; yet the code for the HEADER frame
handler is already covered. A coverage-guided fuzzer has no
information on the traversed state space. It is oblivious to the
fact that the correct processing of the DATA frame is "un-
locked" only when the requisite state is visited ﬁrst (during
the processing of the HEADER frame).

The main objective of a stateful greybox fuzzer should be
to chart out and efﬁciently explore an unknown state space to
discover stateful bugs. To this end, a stateful fuzzer (i) con-
structs a lightweight abstraction of the observed state space
from the state feedback—in our case from the sequence of ob-
served state variable values, and (ii) navigates this state space
abstraction to maximize the probability of visiting unobserved
states. In line with most existing efforts in greybox fuzzing,
we assume that no external information is available, neither in
the form of protocol speciﬁcations nor in the form of human
annotations [2]. A stateful greybox fuzzer is pointed to the
protocol implementation, fuzzes it, and reports any bugs that
it ﬁnds. So, how can we enable a greybox fuzzer to effectively
navigate an unknown state space?

Identifying state space. In this paper, we argue that proto-
cols are often explicitly encoded using state variables that
are assigned and compared to named constants.1 State vari-
ables allow developers to implement state transitions by as-
signing the corresponding named constant, and to implement
state-based program logic as if- or switch-statements. More
speciﬁcally, using pattern matching, we identify state vari-
ables using enumerated types (enums). An enumerated type
is a group of named constants that speciﬁes all possible val-
ues for a variable of that type. Our instrumentation injects a
call to our runtime at every program location where a state
variable is assigned to a new value. Our runtime efﬁciently
constructs the state transition tree (STT). The STT captures
the sequence of values assigned to state variables across all
fuzzer-generated input sequences, and as a global data struc-
ture, it is shared with the fuzzer. An example of the STT
constructed for the H2O implementation of the HTTP2 proto-
col is shown in Figure 1. Our in-memory fuzzer uses the STT
to steer the generated input sequences towards under-explored
parts of the state space.

Stateful greybox fuzzing. We discuss several heuristics to
increase the coverage of the state space via greybox fuzzing.
First, we propose to add generated inputs to the seed corpus
that exercise new nodes in the STT. As we will demonstrate,
code coverage alone is insufﬁcient to capture the order across
different requests. Instead, we should capture the states in
which the code is covered. Hence we argue, adding inputs

1We found that this observation holds for all of the top-50 most widely
used protocol implementations as well as for every stateful protocol in the
ProFuzzbench protocol testing benchmark [19].

that discover a new node in the STT facilitates a better cov-
erage of the state space. Secondly, we propose to focus on
the seeds which traverse the rarely visited nodes of the STT
or whose offsprings are more likely to take a different path
through the STT. We hypothesize that these heuristics will
help the fuzzer to explore the state space. Finally, we pro-
pose an approach to focus particularly on the bytes in the
seed, whose mutations trigger new nodes in the STT. The
state space corresponding to the newly added nodes can be
efﬁciently explored by mutating these bytes.

Results. We implemented our stateful greybox fuzzing ap-
proach into LIBFUZZER [1] and call our tool SGFUZZ (State-
ful Greybox Fuzzer). We evaluated SGFUZZ against LIB-
FUZZER and AFLNET on eight widely used protocol imple-
mentations. The state sequence for an input is determined by
the sequence of values assigned to the state variables during
the execution of the protocol implementation. In our experi-
ments, starting from the initial state, our stateful fuzzer exer-
cises 33x more state sequences than LIBFUZZER 15x more
than IJON, and 260x more than AFLNET. Observing that
some code can be covered only in certain states, we found
that SGFUZZ achieves the same branch coverage more than
2x faster than LIBFUZZER. By reproducing existing stateful
bugs, we also found SGFUZZ exposes stateful bugs about
twice as fast as LIBFUZZER and IJON, more than 155x faster
than AFLNET. Most of all, SGFUZZ found 12 new bugs in
widely used stateful systems, 8 of which were assigned CVEs.
Our analysis further shows that stateful bugs are prevalent: ev-
ery four in ﬁve bugs reported among our subjects are stateful.
We have made our data set publicly available for review and
will make an open-source release of our fuzzer to researchers
and practitioners upon publication of the work.

In summary, we make the four key contributions:

• We propose an automatic method to identify and capture
the explored state space of a protocol implementation.

• We present the design and implementation of SGFUZZ, a
stateful greybox fuzzer that found 12 new bugs in widely-
used and well-fuzzed programs.

• We conduct and present a comprehensive evaluation of
SGFUZZ against the state-of-the-art and the baseline
stateful greybox fuzzers.

• We make all data, scripts, and tools publicly available to

facilitate reproducibility.

2 Motivating Example

We believe that current greybox or stateful fuzzers are inef-
fective in detecting stateful bugs. We use the stream state
machine of HTTP2 protocol and the H2O implementation to
explain the main reasons for their inefﬁciency to motivate our
approach for stateful greybox fuzzing.

2

frames are received and responses are sent. H2O uses a dedi-
cated variable to store the current protocol state (i.e., a state
variable; here the enumeration variable stream->state).
The eight implemented HTTP2 stream states are deﬁned as
enumerated type with the following named constants:

• State (0). H2O_HTTP2_STREAM_STATE_IDLE

• State (1). H2O_HTTP2_STREAM_STATE_RECV_HEADERS

• State (2). H2O_HTTP2_STREAM_STATE_RECV_BODY

• State (3). H2O_HTTP2_STREAM_STATE_REQ_PENDING

• State (4). H2O_HTTP2_STREAM_STATE_SEND_HEADERS

• State (5). H2O_HTTP2_STREAM_STATE_SEND_BODY

• State (6). H2O_HTTP2_STREAM_STATE_SEND_BODY_IS_FINAL

• State (7). H2O_HTTP2_STREAM_STATE_END_STREAM

At the start, the server is in the idle State (0) and waits for
incoming requests. Depending on the frames received within
the stream, the following states are visited: receiving request
header (1), request body (2), sending response header (4),
response body (5), and end of stream (7). State (3) is an
intermediate state in which an incoming frame has not been
assigned a handler, yet. State (6) is reached only when the
client has indicated the end of the stream but there are still
pending frames to be sent from the server.

H2O uses named constants to keep track of the current
HTTP2 protocol state. We use this insight to identify
states.

2.3 Challenges of Fuzzing Stateful Software

If the protocol speciﬁcation is unavailable, how can we au-
tomatically ﬁgure out the conditions required to exercise the
state-dependent code? We make the following observations.
Uninformative Response Codes. The observable response
code is unrelated to the current HTTP2 stream state. This ren-
ders ineffective the state-of-the-art fuzzer AFLNet [20] which
depends on the response code to identify the current state.

Coverage is insufﬁcient. In Figure 3, the function handle-
_request_body_chunk 4(cid:13) is executed only if the current
value of stream->state is ..RECV_BODY when the data
frame is handled 3(cid:13). However, stream->state is set to
..RECV_BODY 2(cid:13) only when the handler for the header frame
is called beforehand with a valid header frame 1(cid:13). Code cov-
erage does not capture the required ordering. It is possible to
cover both handler functions ( 1(cid:13) and 3(cid:13)) by sending a data
frame ﬁrst and a header frame next. However, this sequence
of frames cannot be easily modiﬁed to cover the function
handle_request_body_chunk 4(cid:13). On the contrary, if the
header frame is sent ﬁrst and the data frame next, the same han-
dler functions would be covered, but this latter sequence can
be modiﬁed much more easily to cover the function handle-
_request_body_chunk 4(cid:13) (if it was not already). For exist-

Figure 2: The HTTP2 stream state machine as per RFC 7540.

2.1 The HTTP2 Protocol

HTTP2 is a multiplexing protocol, in which each HTTP re-
quest is split into several frames corresponding to the HTTP
header, HTTP body, and so on. A frame is the minimal data
unit that is passed along the HTTP2 protocol. For instance,
an HTTP2 request message may be split into a header frame
and a few data frames. All frames belonging to the same
HTTP request constitute a stream, having to be processed by
the server in order. The HTTP2 protocol deﬁnes the stream
state machine, which regulates the processing order of frames.
When different frames are being processed, the server visits
different states, e.g., the “receiving header” state when it re-
ceives the header frame and the “receiving body” state when
receiving data frames.

Figure 2 shows the HTTP2 stream state machine as per
the ofﬁcial speciﬁcation (RFC 7540)2. In the initial idle state,
the current or remote participant can send / receive a push
promise frame (PP) or a header frame (H). A push promise
frame simply marks a stream as reserved while a header frame
marks the stream as open. In the open state, all frames are
processed including data frames. An end stream (ES) frame
will mark an open stream as half-closed and a half-closed
stream as closed. In any state, if a reset (R) frame is sent /
received, the stream is marked as closed.

2.2 The H2O Implementation

H2O is a new generation HTTP server that is very fast. H2O
supports the HTTP, HTTP2, and HTTP3 protocols and is
written in C programming language. We focus on HTTP2
implementation.

State Variables. H2O implementation uses a much ﬁner-
grained HTTP2 stream state machine than speciﬁed in Fig-
ure 2. Speciﬁcally, H2O tracks the different stages in which

2https://datatracker.ietf.org/doc/html/rfc7540

3

(cf. Section A.4)4 of stateful protocols as indicated in a search
on Shodan5 or by Github stars. We found that all of them
use named constants assigned to special state variables to
keep track of the current state. Of those, 44 use enum type
while 6 use #define statements to deﬁne the named constants.
Unlike the state-of-the-art [20], which requires manual effort
to write protocol-speciﬁc drivers that extract state information
from the server responses, our state variable identiﬁcation is
entirely automatic.

An example of a state variable is given in Section 2. Using
state variables, developers of protocol implementations can
maintain a direct mapping between protocol states given in
the protocol speciﬁcation (cf. Figure 2) and the protocol states
in the implementation (cf. Section 2.2). State transitions are
implemented by assigning another named constant to the state
variable. Protocol logic that is based on the current state can
be implemented as switch-statements or if-conditions where
the current state variable value guards the corresponding state-
based protocol logic (c.f. Figure 3).

To identify state variables, we look for all variables of
enumerated type (enum in C/C++). An enumerated type is a
list of named constants used in computer programming to map
a set of names to numeric values. Variables of enumerated
type can only be assigned constants from the speciﬁed list of
named constants. In our case, this list represents all states that
the state variable can represent (e.g., IDLE to END_STREAM
in Section 2.2). Speciﬁcally, we use regular expressions to
automatically extract all deﬁnitions of enumerated types and
then use the deﬁnitions to return the list of all enum variables
that have been assigned at least once.

As we can see in Table 1, not all variables of enumerated
type need to be state variables. The second category is enu-
merated types that represent all possible response or error
codes. The third category is enumerated types that represent
all possible conﬁguration options for a conﬁguration variable.
However, in practice, our heuristic remains very effective. Re-
sponse and error code variables are already indirectly used
for state identiﬁcation by the state-of-the-art AFLNET. Con-
ﬁguration variables are usually assigned once and only when
the server starts (i.e., before we start recording the state tran-
sitions for each message sequence), or at the beginning of the
session. If we record conﬁguration variables at the beginning
of the sessions, they appear at the beginning of each state tran-
sition sequence and will never be identiﬁed as “rare” states
(which we focus on in Section 4.2).

3.2 State Transition Tree Data Structure

To capture the protocol state transitions exercised by gener-
ated sequences of inputs, we monitor the sequences of values

4We also conﬁrmed our observation for all stateful protocol implementa-

tions in the ProFuzzBench protocol fuzzing benchmark [19].

Figure 3: H2O handlers for header and data frames. A handler
processes inputs as they arrive. Depending on the sequence
in which header and data frames arrive, the value of the state
variable is set and checked. Certain code is reachable only if
the state variable carries a certain value.

ing coverage-guided fuzzers, there would be no distinction
between these two scenarios in terms of coverage3.

By adding generated message sequences to the corpus that
exercise a new sequence of states (i.e., add a new node to
the state transition tree), we can capture both scenarios.

3 Methodology

Our main objective is to capture the protocol state space
without any knowledge of the protocol. Our key observation is
that the current protocol states are often explicitly represented
using so-called state variables.

3.1 Ofﬂine State Variable Identiﬁcation

Our ﬁrst step is to automatically identify state variables in the
program code. If the reader is tasked to implement a stateful
protocol that contains explicitly named protocol states and
a well-speciﬁed protocol logic that proceeds based on the
current protocol state, how would the reader keep track of the
current protocol state in his implementation? We examined
the top-50 most widely used open-source implementations

3As both handlers are called in a loop, there does not exist a direct edge

5Shodan is a search engine for various types of servers connected to the

between both handlers that could be covered.

internet: https://www.shodan.io/.

4

static void handle_request_body_chunk(   ...   if (stream->req.write_req.cb(stream->req.write_req.ctx, payload,       is_end_stream) != 0) {       ...   }static int handle_data_frame(...h2o_http2_stream_t *stream...){    ...    if (stream->state != H2O_HTTP2_STREAM_STATE_RECV_BODY && ...) {      ...      return 0;      }    handle_request_body_chunk(...);     ... }static int handle_incoming_request(...h2o_http2_stream_t *stream...){    ...    h2o_http2_stream_set_state(conn, stream,                                    H2O_HTTP2_STREAM_STATE_RECV_BODY);    ...}static int handle_headers_frame(...h2o_http2_frame_t *frame...){    ...    if ((frame->flags & H2O_HTTP2_FRAME_FLAG_END_HEADERS) != 0) {        /* request headers are complete, handle it */        return handle_incoming_request(conn, stream, ...);    }    ...    return 0;  }4321Enum. Type
State variables

Error or response
codes

Example(s)
stream->state,
sender_state
error, status

Conﬁguration
variables

priority,
run_mode

Explanation
Explicit representation of the protocol states. These are the enum-type variables, the values of which we aim to
record in the state transition tree. In H20, 22 of 43 enum-type variables are actual state variables.
Response codes or error codes are explicitly deﬁned in the protocol and provide quick information to the client
about the processing of the last message. These enum-type variables correspond to the existing response-code-based
state identiﬁcation in AFLNET. In H2O, 2 of 43 enum-type variables are response or error codes.
These variables represent the concrete choices from a set of conﬁguration options. Those options are read either
from a conﬁguration ﬁle or the command line. In H2O, 19 of 43 enum-type variables are conﬁguration variables.

Table 1: Kinds of variables with enumerated types and their impact on the state transition tree.

assigned to state variables. All observed sequences of values
across all state variables in all threads are stored in the same
state transition tree, a data structure that represents the entire
state space that has been explored by the fuzzer. An example
is shown in Figure 1.

State Transition Tree. A node in the state transition tree
represents the value of a state variable during program execu-
tion. Each node has only one parent node and zero or more
children nodes. If there is only one state variable, the parent
and the children nodes of a speciﬁc node respectively repre-
sent the state variable’s value before and after the creation of
that node. If there are multiple state variables, a node’s par-
ent or children nodes can represent values of different state
variables. Each edge from a node to its children represents
a value change of any state variable, indicating a state tran-
sition. From a global perspective, the tree has only one root
node which represents the initial state, and each path from the
root node to a leaf node represents a unique state transition
sequence during program execution on an input.

We use the motivating example from Section 2 to explain
the state transition tree (STT). Figure 1 shows the STT for
the stream->state state variable after getting ﬁve execution
traces. The root node is the idle State (0). After getting valid
requests in stipulated order, the following nodes are recorded:
receiving request header State (1), request body State (2),
sending response header State (4), response body State (5),
and end of stream State (7). If any request has malformed data,
the state directly transitions to the end of stream State (7) as
shown in the left three branches. Another situation is that the
request body is empty. In this situation, it will go through the
right branch, bypassing the receiving request body State (2).
Figure 4 shows a compact representation of the automati-
cally constructed STT as a directed graph. Visual comparison
to the ofﬁcial state machine in Figure 2 reveals a striking sim-
ilarity with the speciﬁed protocol. Speciﬁcally, to construct
the directed graph, we merge all nodes with the same val-
ues of enumeration variables, such as merging all leaf nodes
which have the same State (7). Like the ofﬁcial state machine,
our extracted state machine also starts at the idle state. After
receiving a valid header frame, our extracted state machine
transitions to the receiving request header State (1) while the
ofﬁcial state machine transitions to the open state. Next, when
traversing States (2)(3)(4)(5), the ofﬁcial state machine is still
in the same open state. Finally, when the connection is ready

Figure 4: The state machine extracted from the State Transi-
tion Tree of H2O (node name preﬁxes omitted).

to close, our extracted state machine transitions to State (6)
and State (7) which corresponds to the half-closed (local) and
closed states in the ofﬁcial state machine, respectively. There-
fore, we not only accurately recover parts of the ofﬁcial state
machine, using a simple but highly effective approach, but
we also get a more ﬁne-grained state machine as it is actually
implemented. Together with our greybox fuzzing algorithm,
we aim to gradually recover more and more states on the ﬂy.

3.3 State Transition Tree Construction

To construct the state transition tree (STT), we automatically
inject a runtime into the program binary during compilation.
The runtime gradually constructs the STT along with program
executions on the inputs generated during fuzzing campaign.
Compile-time instrumentation. We developed a Python
script that injects a call to our runtime before every assign-
ment of a named constant to a state variable in the protocol
implementation. Given the list of state variables extracted
during our ofﬂine state variable identiﬁcation, we use regu-
lar expressions to ﬁnd all instructions in the code where the
state variables are assigned new values. The injected function
calls pass the state variable names and the value of the named
constant to our runtime. To make the instrumentation more
ﬂexible and accurate, we also provide an option to allow users
to block some variables extracted from ofﬂine state variable
identiﬁcation. We did not choose LLVM to instrument the pro-

5

IDLERECV_HEADERSRECV_BODYREQ_PENDINGSEND_HEADERSSEND_BODYBODY_IS_FINALEND_STREAMtocol implementation because enum-values will be replaced
by integer-type constant values in the LLVM intermediate
language (LLVM-IR).

Runtime derivation of State Transition Tree. Across all
executions of a protocol implementation during a fuzzing
campaign, the runtime uses the information passed by the
injected calls, to gradually construct the STT. The STT data
structure is implemented in the runtime component with a
pointer that points to the last visited node (initially root). Each
node in the STT is distinguished by the variable name and
its corresponding value, passed from the instrumented calls
to the runtime. Once called, the runtime checks whether a
matching node already exists among the child nodes of the
last visited node. If not found, a new child node is created
for it. Then the last-visited-node pointer is set to point to the
already existing or the newly created child node, whichever
applies. After execution of the program on each input, the last-
visited-node pointer is reset to the root node waiting for the
next execution. To support multi-threading, which is common
for protocol implementations, we leverage a mutex to protect
the code for updating the state transition tree from concur-
rency issues. To avoid that the STT grows to an unreasonable
size, we provide an option to limit the maximum number of
state repetitions along with a single execution. Whenever a
state is repeated more often than allowed (along a path in the
STT), subsequent states are ignored (and that particular path
is truncated). This allows us to efﬁciently manage the state
transitions as a tree, rather than a graph, during the fuzzing
campaign. In our experiments,we chose the same threshold
for all subjects, generally so that the number of nodes does
not exceed 10k nodes.

3.4 Handling Implicit States

In addition to the explicit states that are captured using state
variables, like for any software system, there exist implicit
states: databases and ﬁle systems are changed; some memory
is allocated but never freed. While explicit states are reset
whenever the connection is closed after a message exchange,
implicit states aggregate over time and survive various con-
nection resets.6 The STT can only keep track of explicit states
but not of such implicit states. To explore the implicit state
space, we let the implicit states aggregate without reset. This
allows us to ﬁnd other types of stateful bugs.

Our in-memory stateful greybox fuzzer lives in the same
process as the protocol implementation. Hence, the protocol
implementation under test does not need to be restarted for
every message exchange. This gives a substantial performance
boost but also allows us to aggregate implicit states across
message exchanges. To facilitate reproducing this type of
bug, we enable an option to save the list of all the inputs on
which the program has been executed. After getting a crash
report from the fuzzer, we gradually minimize the list until a

6A connection includes multiple requests and responses.

minimal list triggers this crash. This minimal list can be used
for further manual analysis.

4 Stateful Greybox Fuzzing Algorithm

To efﬁciently explore the state space, we propose to use the
State Transition Tree (STT), described in section (3.2), as a
guide for the stateful greybox fuzzer. SGFUZZ incrementally
constructs the STT at runtime and employs it as follows:

1. Generated inputs that increase coverage of the STT are

added to the seed corpus.

2. Within the seed corpus, SGFUZZ prioritizes the seeds
that have a greater potential to increase the coverage of
the STT.

3. Within the chosen seed, SGFUZZ prioritizes bytes asso-
ciated with newly added STT nodes which have more
potential to increase the coverage of the STT.

Algorithm 1 Stateful Greybox Fuzzing
Input: Seed Corpus T

Crashing inputs Tx = /0
for each t ∈ T do

Et = 1

// initial energy

end for
State transition tree ST T = /0
repeat

t = choose_next(T, E)
t(cid:48) = mutate(t, ST T )
ST T = execute(t(cid:48), ST T )
if t(cid:48) crashes then

return t(cid:48)

else if is_interesting(t(cid:48), ST T ) then

add t(cid:48) to T
t(cid:48) = identi f y_bytes(t(cid:48), ST T )
for each ti ∈ T do

Eti = assign_energy(ti, ST T )

end for

end if

until timeout reached or abort-signal

Output: Crashing Input tx

Algorithm 1 shows the general workﬂow of our fuzzing
algorithm. We implemented this algorithm into LIBFUZZER
and call our fuzzer SGFUZZ (Stateful Greybox Fuzzer). Start-
ing with an initial seed corpus T and until a timeout is reached
or the user aborts the campaign, the following steps are re-
peated. Firstly, SGFUZZ samples t according to the energy
distribution E which represents the likelihood of each seed in
T to be chosen (choose_next). The chosen seed t is then mu-
tated (mutate) to generate a new input t(cid:48) (Section 4.3). Then
we execute the protocol implementation on t(cid:48) and update the

6

STT (Section 3.3). If t(cid:48) causes a crash SGFUZZ returns the
crashing input, else if t(cid:48) exercises new code branch or new
STT nodes (is_interesting), t(cid:48) is added to the corpus T , and
otherwise t(cid:48) is discarded (Section 4.1). Whenever new STT
nodes added, SGFUZZ identiﬁes the bytes in input t(cid:48) (iden-
tify_bytes) that contributed to the coverage of the new STT
nodes (Section 4.3) and updates the energy Eti of all seeds
ti ∈ T in the current corpus (assign_energy) (Section 4.2).
The portions of LIBFUZZER we changed are highlighted in
red in Algorithm 1.

4.1 State Coverage Feedback

Our ﬁrst heuristic is to add generated inputs to the seed cor-
pus that exercise new nodes in the STT (is_interesting in
Alg. 1) as the augmentation of the original branch coverage
feedback. The rationale is to maximize the coverage of the
STT data structure to maximize the coverage of the state
space. Each new node in the STT represents a new value in
the current sequence of state variable values indicating a new
state under the current sequence of state transitions. Like in
code-coverage-guided greybox fuzzing, inputs that increase
coverage are added to the seed corpus, as well.

4.2 Energy Schedule

Our second heuristic is to assign more energy to seeds that
have a greater potential to lead to new states (assign_energy
in Alg. 1). Compared to existing works[5, 31] that prioritize
inputs that execute rarely executed code blocks, our algorithm
additionally assigns more energy to the seeds that execute the
valid state transitions which correspond to the valid protocol
behaviors.

Firstly, we assign more energy to the seeds that traverse the
rarely visited nodes in the STT. We set up an attribute called
hit count for each node in the STT to record the number of
inputs that traverse that node. We expect that STT nodes with
low hit count have more unexplored states in their "neighbor-
hood". Given the STT, we consider a node n ∈ ST T to be rare
if it has a below-average hit count.

rare(n) =

(cid:40)
1

0

if hits(n) < ∑n(cid:48)∈ST T hits(n(cid:48))
otherwise

|ST T |

(1)

where hits(n) returns the hit count of node n.

Let path(t) represent the set of nodes that are traversed
by input t in STT. Given an input t in corpus T , our power
schedule assigns energy e1(t) of t as the proportion of rare
nodes that are visited during program execution on t added to
the original energy of t:

e1(t) = e(cid:48)(t) + e(cid:48)(t)

∑n∈path(t) rare(n)
|path(t)|

(2)

where e(cid:48)(t) is the existing power schedule.

Secondly, we assign more energy to the seeds whose off-
spring are more likely to take a different path through the STT.
By Equation 2, all nodes in STT have similar opportunities
to be executed. However, not all state transitions are equally
important, and valid state transitions are more attractive. Our
intuition is that the valid state transitions, which correspond
to the expected protocol behaviors, are usually easy to be
mutated to other invalid state transitions, which represent the
error handling of the protocol. The change on any byte may
incur error handling logic. This is also a challenge of previous
stateful greybox fuzzing techniques. Thus, we identify this
type of seed and assign more energy to it. Given an input t
and a set of inputs tm that are mutated from t, we calculate the
inverse proportion of its offspring that traverse the same paths
as path(t). We extend our power schedule e2(t) as follows:

e2(t) = e1(t) ·

|tm|
∑c∈tm(path(c) == path(t))

(3)

Finally, to avoid assigning too much energy, we limit our
power schedule e(t) to no more than ten times (empirically
works best than other numbers) the original energy e(cid:48)(t).
Given the seed input t ∈ T in seed corpus T , our power sched-
ule assigns the new energy e(t) to t.

e(t) = min(e2(t), 10 · e(cid:48)(t))

(4)

4.3 Fuzzing Individual Bytes

We deﬁne a simple heuristic to fuzz parts of the seed ﬁrst that
might have more impact on increasing state (STT) coverage.
When an input seed is chosen to be mutated, its individual
bytes to be mutated are selected based on the bytes’ priorities.
Bytes have higher priority if they are deemed to have more
impact on the STT’s coverage (mutate and identify_bytes in
Alg. 1). Recent works on input probing [3, 11, 29] establish
the information ﬂow from particular input bytes to a given
sink in a very lightweight manner. We leverage these ideas
to explore state space. If program execution on a mutated
input triggers new nodes in the STT and hence, that input
is causing new unexplored nodes to be visited for the ﬁrst
time, it may have a great potential to increase the coverage of
the state space. The idea is to identify the individual bytes in
such an input whose mutation has contributed to the increase
in the STT’s coverage. Once identiﬁed, those bytes will be
assigned higher priority to be chosen for mutation. It makes
fuzzing more efﬁcient by enabling earlier exploration of the
"neighbor" states around the newly created nodes that have
not been visited, yet.

Given an input t and a mutated input t(cid:48) derived from t, if
the program execution on input t(cid:48) creates new nodes in STT, t(cid:48)
is saved by SGFUZZ. Then SGFUZZ computes the set differ-
ence of bytes di f f (t,t(cid:48)) between t and t(cid:48) and records the set
of newly added STT nodes N exercised by t(cid:48). We annotate the
mutation range as Rt(cid:48) = di f f (t,t(cid:48)) if |N| > 0, or set Rt(cid:48) to the

7

H2O

Subject Protocol

Fuzz Driver Commit

HTTP h2o-fuzzer-http2
dtlsserver
curl_fuzzer
gst-discoverer
netdriver
netdriver 21.Aug’08
netdriver
netdriver

Share
Size
1e7344 337k LoC
12k IPs
e483a7 138k LoC
8m IPs
aab3a7 202k LoC
-
44bdad 235k LoC
15k IPs
1e08f3 673k LoC >10m IPs
12k IPs
17k LoC
774d7c 37k LoC
10k IPs
24ebf4 38k LoC
3k IPs

MbedTLS SSL/TLS
Several
Curl
Custom
Gstreamer
OpenSSL SSL/TLS
RTSP
Live555
DAAP
OwnTone
DCMTK DICOM

Table 2: Protocol implementations used for comparison.

entire seed t(cid:48) (Rt(cid:48) = (cid:104)t(cid:48)(cid:105)), otherwise (identify_bytes in Alg. 1).
Later, when t(cid:48) is chosen to be mutated for fuzzing (mutate
in Alg. 1), we only mutate the bytes under the range Rt(cid:48). If
it does not bring any interesting behavior (is_interesting in
Alg. 1), we gradually enlarge Rt(cid:48) until it spans the entire seed
t(cid:48). This helps us build an efﬁcient fuzz campaign.

5 Experimental Setup

5.1 Research Questions

Our main hypothesis is that stateful greybox fuzzing allows
for more effective fuzzing of stateful programs, such as proto-
col implementations. We investigated this hypothesis along
with the following research questions.

RQ.1 (State Transition Coverage) How many more differ-
ent sequences of state transitions does SGFUZZ exer-
cise? By mapping out the state space, SGFUZZ aims
to penetrate deeper into the program’s state space. The
number of different sequences of states exercised by a
fuzzer indicates how deep the fuzzer reaches into the
state space.

RQ.2 (Branch Coverage) How much more branch coverage
does SGFUZZ achieve? We cannot ﬁnd bugs in code that
is not covered.

RQ.3 (State Identiﬁcation Effectiveness) Identifying state
variables, what is the false positive / false negative rate?
How does it affect the mapping of the state space (STT)?

RQ.4 (Bug Finding Effectiveness) How much faster does
SGFUZZ expose stateful bugs in our benchmark?

RQ.5 (New Bugs) How many previously unknown bugs can
SGFUZZ ﬁnd in widely used stateful programs? How
many are stateful?

5.2 Subject Programs Studied

Benchmarks. We constructed our set of subjects from two
mature benchmarks. PROFUZZBENCH [19] is a benchmark
for stateful fuzzing of network protocols and facilitates com-
parison to AFLNET [20] (i.e., the current state-of-the-art

8

stateful fuzzer). PROFUZZBENCH includes a suite of repre-
sentative open-source network servers for popular protocols.
OSS-FUZZ7 is an open-source continuous fuzzing framework
that builds more than 500 open source projects for fuzzing.
FUZZBENCH [18] is an open-source fuzzer evaluation infras-
tructure that automatically conducts fuzzing experiments and
produces coverage graphs. FUZZBENCH supports integrating
benchmarks from the OSS-FUZZ.

Selection Criteria. We selected 8 real-world target pro-
grams as subjects for our experiments as shown in Table 2.
We opted for the programs that 1) work on distinct and well-
known protocols aiming to provide diverse state machines, 2)
are widely used (as indicated by a search on the Shodan), 3)
are used in security-critical industries, such as medical and
ﬁnance, in which any bug can have serious consequences. At
the time of writing, they represent the most recent version
(cf. commit column) of eight programs implementing more
than 30 different well-known protocols (curl includes multiple
protocol implementations). These programs are widely used
across many machines on the internet (cf. #IPs in the Share
column). PROFUZZBENCH needs socket communication and
we use netdriver8 to enable it for in-memory fuzzers. Un-
fortunately, netdriver does not support the UDP protocol or
the fork system call because a fork will spawn a new process
that prevents fuzzers from measuring branch coverage. We
selected all programs in PROFUZZBENCH which are compat-
ible with in-memory fuzzers.

Selected Subjects. H2O is a popular web server; MbedTLS
and OpenSSL are security-critical encryption libraries; Curl9
is a utility to communicate via multiple protocols and im-
plements many state machines; Gstreamer implements a
real-time streaming protocol;10 Live555 and OwnTone are li-
braries for streaming media; and DCMTK is used for the medical
data exchange between hospitals (where bugs can be literally
fatal). Three quarter of those protocol implementations are
running on more than 10 thousand different machines (IPs),
according to a recent query of the Shodan search engine.

5.3 Fuzzers

We implemented our stateful greybox fuzzing approach into
LIBFUZZER (the most recent version at the time of our exper-
iment) and call it Stateful Greybox Fuzzer (SGFUZZ). In our
experiments, SGFUZZ is compared against LIBFUZZER as
the baseline and AFLNET and IJON as the state-of-the-art.
Stateful greybox fuzzer (SGFUZZ). To implement our al-
gorithm into LIBFUZZER, we extended the Fuzzer::RunOne
function with the heuristic described in Section 4.1, changed

7https://google.github.io/oss-fuzz/
8https://github.com/google/honggfuzz/tree/master/

libhfnetdriver

9Curl implements 26 client-side protocols which Shodan cannot identify.
10However, the OSS-Fuzz fuzz driver targets the custom protocol which

retrieves information about a remote media ﬁle.

the InputCorpus::UpdateCorpusDistribution function to im-
plement the heuristics discussed in Section 4.2, and added
a ﬁlter to the MutationDispatcher::Mutate function for the
heuristics discussed in Section 4.3. As for the construction
of the STT discussed in Section 3.3, we implemented a stan-
dalone python script for the instrumentation component which
is static and does not rely on any compiler infrastructure. The
runtime component is embedded in the fuzzer.

Baseline. LIBFUZZER is in-memory, coverage-guided, evo-
lutionary fuzzer and serves as the baseline fuzzer we used to
implement SGFUZZ.

State-of-the-art. AFLNET is the current state-of-the-art
stateful fuzzer for protocol implementations that uses the
concept of state-feedback. IJON is another state-of-the-art
stateful fuzzer which needs manual annotation for states. We
used both to evaluate if SGFUZZ gains an advantage over
the state-of-the-art stateful fuzzer. Because IJON does not
support FUZZBENCH or PROFUZZBENCH and to facilitate a
fair comparison to our baseline and our implementation, we
re-implemented IJON in LIBFUZZER and ported its anno-
tation function ijon_push_state11 for IJON-based state-
feedback. To maximize the beneﬁt for IJON, we assume a hu-
man annotator would annotate the same state variables as iden-
tiﬁed by SGFUZZ. AFLNET does not support FuzzBench.

Benchmark Integration. All fuzzers were integrated into
FUZZBENCH or PROFUZZBENCH using equivalent setups
and build processes. All fuzzers are provided the same setup,
environment, seeds, and resources. For all fuzzers, Address-
Sanitizer was enabled to detect memory corruption bugs.
While PROFUZZBENCH uses the gcov tool, FUZZBENCH
uses the llvm-cov tool to measure the number of branches
covered in a fuzzing campaign in 15-minute intervals.

5.4 Experimental Infrastructure

Computational Resources. After the integration of SGFUZZ
and our benchmarks into FuzzBench, we received assistance
from the FuzzBench team to run the branch and state transi-
tion coverage experiments on the Google Cloud Service [18].
For the other four subjects in the ProFuzzBench, we ran the
branch and state transition coverage experiments on our local
machine with an Intel Xeon Gold 6258R CPU that has 128
logical cores running at 2.70GHz. The machine runs Ubuntu
20.04.2 LTS and has access to 128GB of main memory.

Experiment conﬁgurations. As for the initial seed corpus,
we selected one valid input for each subject as the initial
seed for RQ1, RQ2, and RQ3, and selected all seeds provided
FuzzBench or ProFuzzBench as the initial seed for RQ4 and
RQ5. In order to mitigate the impact of randomness, we re-
peated every 23 hours fuzzing campaign 20 times. The 23

11https://github.com/RUB-SysSec/ijon/blob/

56ebfe34709dd93f5da7871624ce6eadacc3ae4c/llvm_mode/
afl-llvm-rt.o.c#L75

Subject AFLNET LIBFUZZER

H2O

MbedTLS

Curl

Gstreamer

OpenSSL

Live555

OwnTone

DCMTK

-
-
-
-
-
-
-
-
13.25
(33.97%)
138.27
(11.42%)
1.00
(0.10%)
68.10
(0.92%)

70.80
(3.61%)
22.80
(39.31%)
150.25
(0.98%)
49.40
(1.08%)
23.95
(61.41%)
184.15
(15.21%)
46.40
(4.82%)
189.25
(2.55%)

IJON SGFUZZ
1849.30
91.85
(94.26%)
(4.68%)
50.80
32.45
(87.59%)
(55.95%)
14630.80
375.75
(95.55%)
(2.45%)
4067.30
134.20
(88.96%)
(2.94%)
33.10
29.60
(84.87%)
(75.90%)
1162.30
405.3
(95.98%)
(33.75%)
930.15
426.00
(96.69%)
(44.28%)
6737.05
267.50
(90.87%)
(3.93%)

ˆA12

U Factor

1.00 <0.01

26.1

1.00 <0.01

2.2

1.00 <0.01

97.3

1.00 <0.01

82.3

0.81 <0.01

1.00 <0.01

1.4

6.3

0.71

0.03

20.0

1.00 <0.01

35.6

Avg: 33.9x

Table 3: Average state transition coverage for 20 campaigns
of 23 hours. The percentage shows this number as a propor-
tion of distinct transition sequences exercised by any run of
any fuzzer. Vargha-Delaney ( ˆA12) measures the magnitude
of the difference in transition coverage at 23 hours between
SGFUZZ and LIBFUZZER (effect size) while Wilcoxon rank-
sum test (U) measures the degree to which these results may
be explained by randomness (statistical signiﬁcance). Factor
shows the factor improvement compared to LIBFUZZER.

hours timeout is the default for the FuzzBench team. To make
the results consistent, we use the same time budget.

6 Evaluation Results

RQ.1 State Transition Coverage

For all fuzzers, subjects, and campaigns, we measured state
transition coverage as the number of paths in the STT which
is constructed across the execution of the subject on all seeds
generated throughout the campaign and from the initial corpus.
Each path represents a unique sequence of state transitions
during the execution of the subject on an input. If a fuzzer
exercises more such succinct sequences, it penetrates deeper
into the protocol’s state space.

Presentation. Table 3 shows the average number of state
transition sequences for 20 campaigns of 23 hours experi-
ments. To assess the "completeness" of the state space cov-
erage, we counted the number of distinct sequences for any
run of any fuzzer and consider this as 100% for all fuzzers
and the average percentage of state transitions exercised by
each fuzzer is shown in the brackets. Factor represents the
factor improvement of SGFUZZ to LIBFUZZER in terms of
average #state sequences. Vargha Delaney ˆA12 measures the
effect size and gives the probability that a random fuzzing
campaign of SGFUZZ achieves more state transition cover-
age than a random fuzzing campaign of LIBFUZZER (i.e.,
ˆA12 > 0.5 means SGFUZZ is better). The Wilcoxon rank sum
test U is a non-parametric statistical hypothesis test to assess
whether the coverage differs across both fuzzers. We reject

9

the null hypothesis if U < 0.05, i.e., SGFUZZ outperforms
LIBFUZZER with statistical signiﬁcance. AFLNET does not
support FuzzBench. We annotated the same states as in SG-
FUZZ to IJON which needs manual state annotations.

Results. For all subjects, SGFUZZ covers substantially
more state transitions than AFLNET, LIBFUZZER, and IJON.
Compared to baseline LIBFUZZER, SGFUZZ exercises 34x
more state transitions on average (20x median) across all
eight subjects, owing to the STT guided fuzzing approach.
Especially for Curl, Gstreamer, and DCMTK, SGFUZZ in-
creases the state transition coverage signiﬁcantly. Those have
much more state variables than others. SGFUZZ even exe-
cutes 97x more state transitions than LIBFUZZER on Curl
and 930x more state transitions than AFLNET on OwnTone.
An extended discussion about about the contribution of the
individual heuristics in SGFUZZ can be found in Section A.1.

AFLNET vastly underperforms. We believe the reasons are
1) AFLNET identiﬁes state by a different method (using the
response code) and 2) AFLNET restarts the tested program
after each generated message sequence which incurs a big
performance loss. In contrast, other fuzzers leverage the same
in-memory architecture for high throughput.

IJON exercises 2.75x more state transitions than LIB-
FUZZER on average as it adds state feedback, but SGFUZZ
still exercises 15.29x more state transitions than IJON. As a
proportion of all sequences exercised in any run of any fuzzer,
SGFUZZ covers 92% of state transitions, on average (99%
on the sum of 20 campaigns). This shows that SGFUZZ can
cover almost all state transitions covered by other fuzzers
and more. 1% sequences are executed by LIBFUZZER only
because of the randomness of fuzzing.

LIBFUZZER, as the only stateless fuzzer, performs well
only on OpenSSL where the total number of distinct state
transition sequence is relatively low (39). We found that LIB-
FUZZER explores states mostly near the initial states or end
states (cf. Section A.3).

For subjects MbedTLS and OpenSSL, we found that SG-
FUZZ has smaller state transition increase than for the other
subjects. For those subjects, the number of distinct sequences
explored by any fuzzer is relatively low. For instance, in
OpenSSL, st->hand_state variable is an enum-type vari-
able used for tracking handshake states of TLS protocol.
From state TLS_ST_SR_CLNT_HELLO12, it needs at least
four more conditions to reach state DTLS_ST_SW_HELLO-
_VERIFY_REQUEST, and at least two more conditions to
reach state TLS_ST_OK. Some of the conditions need a spe-
ciﬁc external state. For instance, SSL_IS_DTLS(s) is true when
the trafﬁc comes via UDP protocol rather than TCP.

12https://github.com/openssl/openssl/blob/c74188e/ssl/

statem/statem_srvr.c#L585

On average, SGFUZZ covers 33x more sequences of state
transitions than LIBFUZZER, 15x more than IJON, and
260x more than AFLNET. By tracking the state space via
the STT, SGFUZZ is able to cover more of the state space.

RQ.2 Branch Coverage

Presentation. Table 4 shows the branch coverage result af-
ter 23 hours. Improvement represents the percentage im-
provement of SGFUZZ to LIBFUZZER based on the average
branch coverage. time-to-coverage measures the time it takes
AFLNET, IJON, and SGFUZZ, respectively to achieve the
same coverage that LIBFUZZER achieves in 23 hours. Factor
represents the factor improvement of SGFUZZ to LIBFUZZER
based on time-to-coverage. ˆA12 represents the Vargha Delaney
effect size while U represents Wilcoxon signed rank statistical
signiﬁcance.

Results. Although AFLNET also aims to explore the state
space of the program, there are substantial inefﬁciencies that
prevent AFLNET from achieving good coverage on most
subjects. IJON performs slightly worse than LIBFUZZER
because it introduces performance cost for state tracing. How-
ever, with our algorithm, in general, SGFUZZ overcomes the
performance cost caused by the STT and outperforms both
LIBFUZZER and IJON to reach more state-dependent code.
The seeds are valid but only execute few state transition se-
quences. LIBFUZZER seems to be stuck in "shallow" states,
and IJON explores more state space with state tracing, while
SGFUZZ explores much more states that reach much "deeper"
by both state tracing and heuristic algorithms. More discus-
sions about our algorithm’s contribution to the branch cov-
erage can be found in Section A.1 and the growth trend of
branch coverage can be found in Section A.2.

One exception is the Gstreamer. We explain the rea-
son with the huge state space in Gstreamer which cor-
responds to a small code space. The enum-type variable
best_probability, which ranges from 1 to 100, represents
the certainty about the media type of that stream. When
Gstreamer receives a stream, it gradually updates the value of
best_probability as more information becomes available.
This state variable has 100 states and is updated frequently
to seemingly random values, so SGFUZZ generates much
more inputs to explore the state space despite not achieving
much more branch coverage. To conﬁrm our hypothesis, we
removed best_probability, repeated this experiment, and
saw a good improvement in the coverage results for SGFUZZ.
LIBFUZZER would take 23 hours to achieve about the same
coverage as SGFUZZ achieves in 12 hours.

Table 4 (left) shows that, on average, SGFUZZ achieves
2.20% more branch coverage than LIBFUZZER, 4.41% more
than IJON, and 38.73% more than AFLNET. Table 4 (right)
shows that SGFUZZ achieves the same branch coverage 2.3x
faster than LIBFUZZER in the 23 hours, on average. For state-

10

Branch Coverage
IJON SGFUZZ

Subject

2820.25

-
H2O
-
MbedTLS
-
Curl
Gstreamer
-
OpenSSL 11342.00
2179.87
Live555
OwnTone
991.00
DCMTK 5763.00

ˆA12
AFLNET LIBFUZZER
3050.68 0.84 <0.01
2879.20
0.43
11929.60 11885.65 12057.68 0.58
19262.16 16892.55 19942.39 0.71
0.03
63280.06 60993.58 61698.56 0.11 <0.01
0.02
12463.14 12456.00 12610.50 0.72
0.02
2278.10 0.73
2244.63
2312.60 0.65
2184.64
0.15
6100.50 0.77 <0.01
6042.15

2214.38
2299.20
5997.05

ˆA12
U Improvement AFLNET LIBFUZZER
IJON SGFUZZ
6.69h 0.98 <0.01
23.00h
14.04h
17.86h 0.75 <0.01
23.00h >23.00h
12.23h 0.95 <0.01
23.00h
21.89h
-
-
23.00h >23.00h >23.00h
1 <0.01
10.08h
23.00h >23.00h
15.86h 0.95 <0.01
23.00h >23.00h
5.04h
23.00h
1 <0.01
6.14h
14.40h 0.93 <0.01
23.00h >23.00h

-
5.96%
-
1.07%
-
3.53%
-2.50%
-
1.18% >23.00h
1.49% >23.00h
5.86% >23.00h
0.97% >23.00h

Time-to-Coverage

U Factor
3.4
1.3
1.9
-
2.3
1.5
4.6
1.6
Avg: 2.3x

Avg: 2.20%

Table 4: Average branch coverage (left) and average time to coverage (right) for 20 campaigns of 23 hours. The time to coverage
measures the time it takes AFLNET, IJON, and SGFUZZ to achieve the same coverage that LIBFUZZER achieves in 23 hours
(0.25h accuracy). Vargha-Delaney ( ˆA12) measures the magnitude of the difference (effect size) while Wilcoxon rank-sum test (U)
measures the degree to which these results may be explained by randomness (statistical signiﬁcance). Factor shows the factor
improvement compared to LIBFUZZER.

dependent code, this is either because SGFUZZ takes much
shorter time than LIBFUZZER to reach the same coverage,
(Time-to-coverage), or SGFUZZ reaches parts of the code that
LIBFUZZER has been unable to reach (Branch coverage and
RQ2 demonstrated in Figure 3). Looking at RQ1 and RQ2
together, there is a greater increase in transition coverage
than in branch coverage. This further supports our hypothesis
that conventional branch coverage feedback is insufﬁcient to
measure the state space coverage of programs.

We recall our example at Section 2 to explain the branch
coverage gap between SGFUZZ and LIBFUZZER. The func-
tion sequences 1(cid:13) 2(cid:13) 3(cid:13) and 3(cid:13) 1(cid:13) 2(cid:13) would result in the same
branch coverage, but they are different regarding the value of
the state variable (stream->state). This difference is cap-
tured by the STT in SGFUZZ and hence, both two correspond-
ing seeds are saved for further exploration, while LIBFUZZER
is unable to distinguish between these function call sequences
and hence only the ﬁrst input seed that result in one of these
function calls will be saved. Consequently, as the function
4(cid:13) is easier to be explored from mutating the seed resulting
to 1(cid:13) 2(cid:13) 3(cid:13) than from the other seed, LIBFUZZER has a high
chance of missing the corresponding precious seed and be-
coming unable to cover the function 4(cid:13). In our experiments,
the function 4(cid:13) is always explored by SGFUZZ faster than
LIBFUZZER, or is unexplored for LIBFUZZER in 23 hours.
There are more state-dependent code that produces the branch
coverage gap.

On average, SGFUZZ achieves 2.20% more branch cover-
age than LIBFUZZER, 4.41% more than IJON, and 38.73%
more than AFLNET. SGFUZZ achieves the same branch
coverage about 2x faster than LIBFUZZER.

RQ.3 State Identiﬁcation Effectiveness

To evaluate how well our heuristic is able to identify true state
variables, we manually examined the valid identiﬁed variables
of enumerated type for all subjects as well as the correspond-

Subject

Enum
All State Percentage
43
H2O
36
MbedTLS
Curl
81
Gstreamer 218
64
OpenSSL
11
Live555
OwnTone
51
DCMTK 145

All
51.16% 6418
91.67%
167
54.32% 35690
69.27% 11240
62.50%
817
90.91% 17446
72.55% 3671
55.17% 27178
68.44%

22
33
44
151
40
10
37
80
Avg:

STT

State Percentage RFC
(cid:88)
6417
99.98%
(cid:88)
167
100.00%
(cid:88)
99.83%
35629
99.86% NA
11224
(cid:88)
96.57%
789
(cid:55)
100.00%
17446
100.00% NA
3671
99.75% NA
27109
Avg:
99.50%

Table 5: [Left] The number of identiﬁed (All) and actual state
variables (State) among enum-type variables. [Right] The
number of nodes (All) and state-related nodes (State) in the
STT constructed in 23 hours.

ing Request for Comments (RFC) documents, which contain
technical speciﬁcations and organizational notes for the In-
ternet. To evaluate false positives, we classiﬁed the identiﬁed
variables into 1) configuration variables if their values
are got from static sources (conﬁguration ﬁles, command-
line parameters), 2) state variables if their values are got
from inputs and affect the program execution by the if- or
switch-statements, 3) error or response codes if their
values are assigned as the return value of functions. To evalu-
ate the impact on state space exploration, we measured the
percentage of nodes in the STT that are actually state vari-
ables. To evaluate false negatives, we checked if the STT
covers the protocol states as discussed in the corresponding
RFCs. Speciﬁcally, we checked a) if an RFC exists, b) if the
speciﬁed state machine is represented as enumeration type
in the protocol implementation, and c) if STT covers these
variables.

Presentation. Table 5 shows the results of the state iden-
tiﬁcation analysis. All represents the number of enum-type
variables or of nodes in STT. State represents the number of
state variables in enum-type variables or state nodes in STT.
RFC represents that if the protocol state machines stipulated
in the Request for Comments(RFC) documents are covered

11

by the STT. NA represents Not Applicable.

Results. On average, 68.44% of variables that were iden-
tiﬁed using our enum-based heuristic are actually state vari-
ables. However, the 32% false positive rate has a low impact
on the State Transition Tree (STT) construction. On average,
99.5% of nodes in the STT are state variable values. The
value of state variables change several times during the exe-
cution which is reﬂected in the growing STT. The remaining
0.5% of nodes are related to non-state variables. For instance,
conﬁguration variables are usually assigned once and often
appear at the beginning of an execution (e.g., when the pro-
tocol exchange is conﬁgured). Error or response codes are
usually written to log ﬁles or returned back to users once per
execution and without any change in value. This means non-
state-variables rarely appear in the STT and thus do not affect
our algorithm in Section 4 or the achieved branch coverage.

While an average of 32% of identiﬁed variables are not
actually state variables, an average 99.5% of nodes in
the STT constructed in 23 hours are referring to values
of actual state variables. This is explained by the STT
tracking changes in variable values.

We also investigated whether protocol states speciﬁed in
the Request for Comments (RFC), if any, are reﬂected as
enumeration-type state variables, and whether they appear
in the STT. In other words, we investigated false negatives.
There is one false negative among our eight subjects. As
we can see in the last column of Table 5, three of the eight
protocol implementations are proprietary protocols and no
RFC exists, and the implementation (using state variables)
already provides the ground-truth.13 Four of the remaining
ﬁve protocols implement the speciﬁed states as enumeration-
type state variables.14. For the Live555 implementation of the
RTSP protocol, the corresponding RFC-2326 does specify the
RTSP protocol state machine but it is implicitly represented
by state variables related to data transport or parsing, which
imply the protocol state machine. For instance, the enum-type
variable fCurrentParseState maintains the states of the media
ﬁle parser, which must be the initial state under the READY
state of RTSP protocol and must not be the initial states under
the PLAY state of the RTSP protocol. However, as there is no
explicit state variable, we count this as a false positive.

To evaluate state coverage regarding true state variables,
we recorded the number of distinct values of true state vari-
ables in our experiments, as shown in Table 6. On average,
SGFUZZ covers 88.98% more states than LIBFUZZER in 23
hours. For Gstreamer, which has the best improvement, there
is a huge state space in which some states are easier to be
explored, such as best_probability variable (explained in
RQ2). For H2O, which has least improvement, we found that

H2O
MbedTLS
Curl
Gstreamer
OpenSSL
Live555
OwnTone
DCMTK

Subject AFLNET LIBFUZZER IJON SGFUZZ
12
21
75
113
47
19
27
12
Avg:

12
17
67
31
44
17
23
7

12
14
55
23
40
15
18
5

-
-
-
-
40
15
10
6

Improvement
+0.00%
+50.00%
+36.36%
+391.30%
+17.50%
+26.67%
+50.00%
+140.00%
+88.98%

Table 6: The average number of distinct state variable values
observed in campaigns of length 23 hours (for enumeration
variables that we know for sure represent states).

the RFC-related variable stream->state only has eight pos-
sible values and all eight values are covered by all the fuzzers
in 23 hours, and hence, there has been less room for state
coverage improvement. In general, exercising new states is
more challenging because speciﬁc inputs or external environ-
ment are usually needed, but SGFUZZ still outperforms other
fuzzers in state coverage.

We should also note that our automatic state identiﬁca-
tion is much more complete than a manual annotation, as
in IJON [2]. For the protocol-implementation-related
example15 in the paper, the authors annotated the message
type in TPM to represent state (Listing.D&Section.V.D).
IJON can generate more “distinct sequences” of message
types. SGFUZZ would identify the state variables 16 of each
TPM subsystem and track the state 17 of these subsystems. We
examined the experiment data of IJON and found that the mes-
sage sequences with the same message types may correspond
to different subsystem states. For example, for the same mes-
sage type sequence 32 and 34 (integers used in TPM to mark
message type), the subsystem’s state may be SU_RESTART or
SU_RESET. It is because the subsystem’s states are affected
by previous execution results, not the message type. This
shows how SGFUZZ can automatically annotate state in a
more ﬁne-grained manner than human.

RQ.4 Bug Finding Effectiveness

Among known bugs from OSS-Fuzz and ProFuzzBench, we
selected seven stateful bugs to evaluate if SGFUZZ exposes
stateful bugs faster, and three stateless bugs to evaluate if SG-
FUZZ hinders the ﬁnding of stateless bugs. In ProFuzzBench,
we selected the stateful bug CVE-2019-7314 in Live555
which was found by AFLNET. In OSS-Fuzz, we used the bug
tracker that contains fuzzer-generated bug reports to chose
the other seven bugs. Among stateful bugs, we take the bugs

15https://github.com/RUB-SysSec/ijon-data/blob/master/

tpm_fuzzing/src/CommandDispatcher.c#L396

13It is interesting to point out that these protocols cannot be tested by

16https://github.com/RUB-SysSec/ijon-data/blob/master/

traditional speciﬁcation-guided protocol testing tools.

tpm_fuzzing/src/CommandAudit.c#L100

14H2O(rfc7540), MbedTLS (rfc8446), Curl (rfc959, rfc3501, etc.), and

17https://github.com/RUB-SysSec/ijon-data/blob/master/

OpenSSL (rfc8446)

tpm_fuzzing/src/Global.h#L369-L374

12

Subject

Bug

Stateful:

H2O 12096
OpenSSL 4528
Curl 16907
Gstreamer 20912

-
-
-
-

Live555 CVE 7.78h

H2O 3303
Curl 22874

Stateless:
H2O
554
Curl 17954
OpenSSL 3122

-
-

-
-
-

AFLNET LIBFUZZER
Avg Num Avg Num Avg Num Avg Num

SGFUZZ

IJON

Factor

-
-
-
-
20
-
-

-
-
-

4.17h
>23h
6.29h
0.07h
0.05h
>23h
>23h

4.69h
0.18h
>23h

12
0
19
20
20
0
0

20
20
0

4.89h
14.28h
4.92h
0.07h
0.05h
>23h
>23h

4.48h
0.21h
>23h

18
6
11
20
20
0
0

16
20
0

2.20h
7.09h
1.98h
0.03h
0.05h
>23h
>23h

3.86h
0.15h
>23h

19
10
19
20
20
0
0

1.9
∞
3.2
2.3
1.0
-
-
Avg: 2.1x

20
20
0

1.2
1.2
-
Avg: 1.2x

Table 7: Time to expose existing bugs: 20 campaigns, 23 hr.

that require at least two state transitions to be exercised before
they can be exposed. Stateless bugs are the bugs that can be
executed without any state transition.

Presentation. Table 7 shows the average time to expose
all bugs in 20 campaigns of 23 hours. Num is the number of
campaigns in which the bugs were exposed. Factor represents
the factor improvement of SGFUZZ to LIBFUZZER based on
the average time-to-bug. Bug shows the bug identiﬁer in the
OSS-Fuzz issue tracker (for Live555, CVE-2019-7314).

Results. For stateful bugs, SGFUZZ is never slower than the
competition in exposing the bugs. For OpenSSL, which has
a more complicated state machine than others, LIBFUZZER
cannot trigger the bug in 23 hours, while IJON and SGFUZZ
trigger it in 6 and 10 out of 20 fuzzing campaigns of 23 hours,
respectively. For Live555, LIBFUZZER, IJON, and SGFUZZ
expose the bug much faster than AFLNET because of the
high throughput. In general, IJON outperforms LIBFUZZER,
but it is worse than SGFUZZ. These known stateful bugs were
originally found by LIBFUZZER because few state transitions
are needed (cf. Section A.3).

For stateless bugs, SGFUZZ shows a slight advantage over
LIBFUZZER and IJON. We found that these stateless bugs
are usually in the functions which are executed together with,
but do not depend on state transitions, such as message pars-
ing functions must be executed before state transitions (bug
#554). Our algorithms explore the state space more efﬁciently,
facilitating the stateless bug ﬁnding as well.

On average, SGFUZZ exposes stateful bugs about twice
(2x) as fast as LIBFUZZER and IJON, and about 155x
faster than AFLNET.

RQ.5 New Bugs Found

We found 12 unique bugs in three of four subjects from Pro-
FuzzBench. All new bugs are listed in Table 8. All of these
bugs can be exploited remotely and have serious safety risks.
So far, we have received 8 CVE IDs (we are in the process of
applying for CVEs for the remaining 4 bugs). Out of the 12

new bugs we found, 10 are stateful. Of those, 7 exist in the
states represented by explicit state variables of enumerated
type, while the other 3 stateful bugs result from aggregated
implicit states (cf Section 3.4). Two stateful bugs (the ﬁrst and
tenth line in Table 7) can also be triggered by LIBFUZZER
because they depend on implicit states. One stateless bug
(the eighth line in Table 7) can also be triggered by LIB-
FUZZER. With the same state variables identiﬁed by SGFUZZ,
IJON additionally expose two bugs (the second and third line
in Table 7). All 12 new-found bugs cannot be triggered by
AFLNET in 23 hours.

Case study: CVE-2021-3928318 in Live555 (stateful bug
in explicit state). This bug is exposed with the following
minimal preﬁx of RTSP states (cid:104)INIT =⇒ READY =⇒
PLAY =⇒ READY =⇒ PLAY (cid:105) and requires the following
state transition in the MPEG parser (i.e., enum-type state vari-
able MPEGParseState) (cid:104)PARSING_PACK_HEADER =⇒
PARSING_PACK_HEADER(cid:105), all of which are tracked in the
STT. After the ﬁrst SETUP command, the ﬁrst PLAY com-
mand starts the parsing process and sets the parser state for
the media ﬁle header to PARSING_PACK_HEADER. The
second set of SETUP and PLAY commands stops and restarts
the parsing process, setting the parser state again to PARS-
ING_PACK_HEADER. However, the number of bytes read
in the ﬁrst round is not reset properly, such that in the second
round the media ﬁle header is parsed incorrectly which incurs
an assertion error.

SGFUZZ found 12 new bugs in three widely-used and
well-fuzzed stateful programs within 23 hours fuzzing. 10
of 12 bugs are stateful bugs.

7 Related Work

State Space Inference. The most closely related works em-
ploy learning algorithms to infer state machines. There are
two different ways to infer the state machine from a protocol
implementation. Passive learning based approaches [8, 12,
13, 14, 22, 30] infer a state machine by analyzing a corpus
of protocol messages observed from network trafﬁc. A fun-
damental restriction to this kind of approach is the inability
to learn protocols that communicate over an encrypted chan-
nel. Active learning based approaches [7, 9] actively query a
protocol implementation with generated message sequences
and inference a state machine using Angluin’s L∗ algorithm.
HVlearn [21] infers DFA-models of SSL/TLS hostname veri-
ﬁcation implementations via learning algorithms. In contrast,
we do not infer the state machine from a protocol implemen-
tation but derive the STT structure from execution traces to
identify the state space (Sec 3.2). The construction of the
STT requires no analysis of protocol messages or learning
algorithms. We provide a new perspective of stateful system

18ﬁfth line in Table 8.

13

Subject
Live555
Live555
Live555
Live555
Live555
Live555
Live555
OwnTone
DCMTK
DCMTK
DCMTK
DCMTK

version
1.08
1.08
1.08
1.08
1.08
1.08
1.08
28.2
3.6.6
3.6.6
3.6.6
3.6.6

Type
Stack-based overﬂow in liveMedia/MP3FileSource.cpp
Heap use after free in liveMedia/MatroskaFile.cpp
Heap use after free in liveMedia/MPEG1or2Demux.cpp
Memory leak in liveMedia/AC3AudioStreamFramer.cpp
Assertion in UsageEnvironment/UsageEnvironment.cpp
Heap-based overﬂow in BasicUsageEnvironment/BasicTaskScheduler.cpp
Memory leak in liveMedia/MPEG1or2Demux.cpp
Heap use after free in src/misc.c
Memory leak in dcmnet/libsrc/dulparse.cc
Memory leak in dcmnet/libsrc/dulparse.cc
Heap use after free in dcmqrdb/libsrc/dcmqrsrv.cc
Heap-based overﬂow in dcmnet/libsrc/diutil.cc

Stateful
True
True
True
True
True
True
True
False
False
True
True
True

State Variable
Implicit
Explicit
Explicit
Explicit
Explicit
Explicit
Implicit
-
-
Implicit
Explicit
Explicit

CVE
CVE-2021-38380
CVE-2021-38381
CVE-2021-38382
CVE-2021-39282
CVE-2021-39283
CVE-2021-41396
CVE-2021-41397
CVE-2021-38383
CVE Requested
CVE Requested
CVE Requested
CVE Requested

Table 8: The 0–day security vulnerabilities found by SGFUZZ. Eight CVEs were assigned. Four CVEs are under application.

testing, in which protocol state transitions can be identiﬁed
by changes on state variables.

8 Discussion

Blackbox and Whitebox Protocol Fuzzing. Blackbox
fuzzers [4, 15, 16, 17, 24, 25, 26, 27, 28] take the protocol
server under test as a black box and keep generating mes-
sage sequences to the server for discovering bugs or security
ﬂaws. Despite being simple and easy to be deployed, black-
box fuzzers are completely unaware of the internal structure
of the program, perform random testing, and are thus ineffec-
tive. Whitebox fuzzers use program analysis and constraint
solving to synthesize inputs that exercise different program
paths. MACE [7] combines concolic execution and active
state machine learning for protocol fuzzing. MACE uses con-
crete execution and symbolic execution to iteratively infer and
reﬁne an abstract model of a protocol so as to explore the pro-
gram states more effectively. However, these techniques suffer
from scalability issues arising from the heavy machinery of
symbolic execution.

Greybox fuzzers for protocols. These fuzzers observe pro-
gram states in the execution and use coverage- and state-
feedback to guide input generation for discovering program
states. IJON [2] uses human code annotations to annotate
states. INVSCOV [10] uses the likely invariants to partition
program states. AFLNet [20] uses response codes as states
and evolves a corpus of protocol message sequences based
on coverage- and state-feedback from executed sequences.
For each run, AFLNet selects one of the states and fuzzes
the entire sequence of messages which reach the state. To im-
prove performance, [6] uses fork mechanism to snapshot the
states which are under fuzzing to avoid executing the whole
protocol messages from the start. However, the fork points
need to be speciﬁed manually in the code which demands the
knowledge of the protocol state machine. Our approach comes
under greybox fuzzing. SGFUZZ does not require knowledge
of the protocol state machine. Instead, we use state variables
to identify the explored state space. In contrast to AFLNet,
SGFUZZ does not identify states by response codes.

14

The contribution of our work is in fuzzing reactive and state-
ful software systems. We propose to capture the exercised
state space using a highly efﬁcient dynamic construction of
a state transition tree (STT). We developed a greybox fuzzer
SGFUZZ for stateful systems. Our experimental results show
that SGFUZZ discovered stateful bugs about twice as fast
as LIBFUZZER, the baseline greybox fuzzer that SGFUZZ
was implemented into. SGFUZZ covers 33x more sequences
of state transitions than LIBFUZZER, 15x more than IJON,
and 260x more than AFLNET. At the same time, SGFUZZ
achieves the same branch coverage about 2x faster than LIB-
FUZZER. Finally, SGFUZZ found 12 new bugs. Our tool
SGFUZZ has been released open source.

https://github.com/bajinsheng/SGFuzz

We followed a responsible disclosure policy for the bugs we
found, and all reported bugs in this paper have now been
ﬁxed by developers. We feel that tools like SGFUZZ have
signiﬁcant practical usage since the security of the internet-
facing protocol implementations is of paramount importance.

References

[1] libfuzzer-a ibrary for coverage-guided fuzz testing.
https://llvm.org/docs/LibFuzzer.html, 2020.

[2] Cornelius Aschermann, Sergej Schumilo, Ali Abbasi,
and Thorsten Holz. Ijon: Exploring deep state spaces via
fuzzing. In IEEE Symposium on Security and Privacy,
2020.

[3] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko,
Robert Gawlik, and Thorsten Holz. Redqueen: Fuzzing
with input-to-state correspondence. In NDSS, volume 19,
pages 1–15, 2019.

[4] Vaggelis Atlidakis, Patrice Godefroid, and Marina Pol-
ishchuk. Restler: Stateful rest api fuzzing. In Proceed-
ings of the 41st International Conference on Software
Engineering, pages 748–758, 2019.

[5] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoud-
hury. Coverage-based greybox fuzzing as markov chain.
In Proceedings of the 2016 ACM SIGSAC Conference on
Computer and Communications Security, pages 1032–
1043, 2016.

[16] Rauli Kaksonen, Marko Laakso, and Ari Takanen. Soft-
ware security assessment through speciﬁcation muta-
tions and fault injection. In Communications and Multi-
media Security Issues of the New Century, pages 173–
183, 2001.

[6] Yurong Chen, Tian lan, and Guru Venkataramani. Ex-
ploring effective fuzzing strategies to analyze commu-
In Proceedings of the 3rd ACM
nication protocols.
Workshop on Forming an Ecosystem Around Software
Transformation, FEAST’19, page 17–23, New York, NY,
USA, 2019. Association for Computing Machinery.

[7] Chia Yuan Cho, Domagoj Babic, Pongsin Poosankam,
Kevin Zhijie Chen, Edward XueJun Wu, and Dawn
Song. Mace: Model-inference-assisted concolic explo-
ration for protocol and vulnerability discovery. In 20th
USENIX Security Symposium, 2011.

[8] P. M. Comparetti, G. Wondracek, C. Kruegel, and
E. Kirda. Prospex: Protocol speciﬁcation extraction. In
30th IEEE Symposium on Security and Privacy, pages
110–125, 2009.

[9] Joeri De Ruiter and Erik Poll. Protocol state fuzzing of
tls implementations. In 24th USENIX Security Sympo-
sium, pages 193–206, 2015.

[10] Andrea Fioraldi, Daniele Cono D’Elia, and Davide
Balzarotti. The use of likely invariants as feedback for
fuzzers. In 30th USENIX Security Symposium (USENIX
Security 21), pages 2829–2846. USENIX Association,
August 2021.

[11] Shuitao Gan, Chao Zhang, Peng Chen, Bodong Zhao,
Xiaojun Qin, Dong Wu, and Zuoning Chen. Greyone:
Data ﬂow sensitive fuzzing. In 29th USENIX Security
Symposium, pages 2577–2594, 2020.

[12] Hugo Gascon, Christian Wressnegger, Fabian Yam-
aguchi, Daniel Arp, and Konrad Rieck. Pulsar: State-
ful black-box fuzzing of proprietary network protocols.
In Security and Privacy in Communication Networks,
pages 330–347, 2015.

[17] T. Kitagawa, M. Hanaoka, and K. Kono. Aspfuzz: A
state-aware protocol fuzzer based on application-layer
protocols. In The IEEE symposium on Computers and
Communications, 2010.

[18] Jonathan Metzman, László Szekeres, Laurent Simon,
Read Sprabery, and Abhishek Arya. Fuzzbench: an
open fuzzer benchmarking platform and service. In Pro-
ceedings of the 29th ACM Joint Meeting on European
Software Engineering Conference and Symposium on
the Foundations of Software Engineering, pages 1393–
1403, 2021.

[19] Roberto Natella and Van-Thuan Pham. Profuzzbench: A
benchmark for stateful protocol fuzzing. In Proceedings
of the 30th ACM SIGSOFT International Symposium on
Software Testing and Analysis, 2021.

[20] Van-Thuan Pham, Marcel Boehme, and Abhik Roy-
choudhury. Aﬂnet: A greybox fuzzer for network proto-
cols. In IEEE International Conf. on Software Testing
Veriﬁcation and Validation, 2020.

[21] S. Sivakorn, G. Argyros, K. Pei, A. D. Keromytis, and
S. Jana. Hvlearn: Automated black-box analysis of
In
hostname veriﬁcation in ssl/tls implementations.
IEEE Symposium on Security and Privacy, 2017.

[22] Yipeng Wang, Zhibin Zhang, and L. Guo.

Inferring
protocol state machine from real-world trace. In Pro-
ceedings of the 13th International Conference on Recent
Advances in Intrusion Detection, 2010.

[23] Website.

American fuzzy lop (aﬂ)

fuzzer.

http://lcamtuf.coredump.cx/afl/technical_
details.txt, 2017. Accessed: 2017-05-13.

[13] Serge Gorbunov and Arnold Rosenbloom. Autofuzz:
Automated network protocol fuzzing framework. 2010.

[24] Website. beSTORM Black Box Testing. https://www.

beyondsecurity.com/bestorm.html, 2017.

[14] Y. Hsu, G. Shu, and D. Lee. A model-based approach
to security ﬂaw detection of network protocol imple-
mentations. In 2008 IEEE International Conference on
Network Protocols, 2008.

[15] W. Johansson, M. Svensson, U. E. Larson, M. Almgren,
and V. Gulisano. T-fuzz: Model-based fuzzing for ro-
In
bustness testing of telecommunication protocols.
IEEE Seventh International Conference on Software
Testing, Veriﬁcation and Validation, pages 323–332,
2014.

15

[25] Website.

Boofuzz: A fork and successor of the
https://github.com/

sulley fuzzing framework.
jtpereyda/boofuzz, 2017. Accessed: 2019-08-12.

[26] Website. Codenomicon Intelligent Fuzz Testing. http:
//www.codenomicon.com/index.html, 2017. Ac-
cessed: 2017-05-13.

[27] Website.

Peach Fuzzer Platform.
peachfuzzer.com/products/peach-platform/,
2017. Accessed: 2017-05-13.

http://www.

[28] Website. Sulley: A pure-python fully automated and
https://github.

unattended fuzzing framework.
com/OpenRCE/sulley, 2017. Accessed: 2019-08-12.

[29] Wei You, Xueqiang Wang, Shiqing Ma, Jianjun Huang,
Xiangyu Zhang, XiaoFeng Wang, and Bin Liang. Pro-
fuzzer: On-the-ﬂy input type probing for better zero-day
vulnerability discovery. In 2019 IEEE Symposium on
Security and Privacy (SP), pages 769–786. IEEE, 2019.

[30] Yingchao Yu, Zuoning Chen, Shuitao Gan, and Xiaofeng
Wang. Sgpfuzzer: A state-driven smart graybox protocol
IEEE
fuzzer for network protocol implementations.
Access, 8:198668–198678, 2020.

[31] Tai Yue, Pengfei Wang, Yong Tang, Enze Wang, Bo Yu,
Kai Lu, and Xu Zhou. EcoFuzz: Adaptive Energy-
Saving greybox fuzzing as a variant of the adversarial
Multi-Armed bandit. In 29th USENIX Security Sympo-
sium (USENIX Security 20), pages 2307–2324. USENIX
Association, August 2020.

A Appendix

Due to the space limit, we present some of the evaluation
results here.

A.1 Sensitivity Analysis

We conducted sensitivity analysis to evaluate the effectiveness
of each heuristic in Section 4. To do this, we conﬁgured three
new fuzzers at the FUZZBENCH framework: a) SGFUZZx,
a speciﬁc conﬁguration of SGFUZZ that does not have the
algorithms of energy schedule in Section 4.2 and prioritizing
input bytes in Section 4.3. b) SGFUZZy, another conﬁguration
of the SGFUZZ that does not have prioritizing input bytes
in Section 4.3. c) HONGGFUZZ, a stateless fuzzers similar
to LIBFUZZER. The experiments were carried out with the
identical conﬁgurations as our main experiments: 23 hours
and 20 runs.

Table 9 shows the average state transition coverage. Similar
to LIBFUZZER, HONGGFUZZ is a stateless fuzzer, so its state
transition coverage is little and close to LIBFUZZER. This
demonstrates that other stateless fuzzers are inefﬁcient in state-
space exploration as well. From SGFUZZx, to SGFUZZy, un-
til SGFUZZ, the state transition increase factor to LIBFUZZER
are 4.43x, 21.95x, and 33.92x on average which represent the
contributions of each algorithm in Section 4.1, Section 4.2,
and Section 4.3, respectively. It demonstrates that our heuris-
tic algorithms (Section 4.2 and Section 4.3) promote around
33x state transition coverage. Looking together with Table 3,
SGFUZZx, which only has STT feedback, still slightly out-
performs IJON. We explain that IJON only records the last

Subject HONGGFUZZ LIBFUZZER SGFUZZx SGFUZZy SGFUZZ
1849.30
50.80
14630.80
4067.30
33.10
1162.30
930.15
6737.05

1693.45
49.40
8899.00
2399.10
31.03
825.25
748.32
3755.05

114.50
32.55
456.70
186.50
30.00
594.33
675.45
1233.45

H2O
MbedTLS
Curl
Gstreamer
OpenSSL
Live555
OwnTone
DCMTK

70.80
22.80
150.25
49.40
23.95
184.15
46.40
189.25

82.65
18.95
144.60
48.70
25.34
179.65
49.71
183.22

Table 9: Average state transition coverage for 20 campaigns
of 23 hours.

Subject HONGGFUZZ LIBFUZZER SGFUZZx SGFUZZy SGFUZZ

H2O
MbedTLS
Curl
Gstreamer
OpenSSL
Live555
OwnTone
DCMTK

BRANCH COVERAGE:
3207.90
11735.15
19987.30
63235.45
13003.46
2197.85
2104.13
6087.33
TIME-TO-COVERAGE:
3.60h
>23.00h
14.25h
>23.00h
5.54h
>23.00h
>23.00h
20.11h

H2O
MbedTLS
Curl
Gstreamer
OpenSSL
Live555
OwnTone
DCMTK

2879.20
11929.60
19262.16
63280.06
12463.14
2244.63
2184.64
6042.15

23.00h
23.00h
23.00h
23.00h
23.00h
23.00h
23.00h
23.00h

2885.50
11890.35
16665.80
61807.94
12598.24
2223.15
2124.75
5992.25

12.41h
>23.00h
22.58h
>23.00h
15.44h
>23,00h
>23.00h
>23,00h

3042.70
11902.05
19619.77
62551.20
12596.10
2270.00
2292.00
6033.70

7.16h
>23.00h
13.88h
>23.00h
16.32h
19.33h
8.18h
>23.00h

3050.68
12057.68
19942.39
61698.56
12610.50
2278.10
2312.60
6100.50

6.69h
17.86h
12.23h
>23.00h
10.08h
15.86h
5.04h
14.40h

Table 10: Average branch coverage for 20 campaigns of 23
hours (top), and the time it takes each fuzzer to achieve the
same coverage that LIBFUZZER achieves in 23 hours (0.25h
accuracy; bottom)

four states in a state sequence for high throughput, while we
capture all states of a sequence in the STT.

Table 10 shows the average branch coverage in 23 hours
and the time it takes HONGGFUZZ, SGFUZZx, SGFUZZy, and
SGFUZZ, respectively to achieve the same coverage that LIB-
FUZZER achieves in 23 hours. HONGGFUZZ excels at subjects
H2O, Curl, and OpenSSL and fails miserably at MbedTLS and
OwnTone. The reason for this is that SGFUZZx, SGFUZZy,
and SGFUZZ are all based on LIBFUZZER, while HONGG-
FUZZ is an entirely different fuzzer. In general, SGFUZZx
slightly performs worse than LIBFUZZER as it introduces per-
formance cost for state tracing, and our heuristic algorithms
overcome the performance cost as in SGFUZZy and SGFUZZ.
For Gstreamer which has a big state space in small code space,
SGFUZZy performs better than SGFUZZ as the latter puts too
much effort on the state space exploration. Time-to-coverage
improvement is substantially greater than branch coverage
improvement, which is consistent with our major results in
Table 4.

A.2 Growth Trend of Branch Coverage

Figure 5 shows the average branch coverage with time for all
fuzzers in Table 4 and HONGGFUZZ in Table 10. All fuzzers’
branch coverage is nearly saturated after the 12 hours, al-

16

Subject Total Stateful
6
3
0

H2O
OpenSSL
MBedTLS

9
4
0

Subject Total
34
26

Gstreamer
Curl

Stateful
28
20

Total:

73

57 (78.08%)

Table 11: Prevalence of stateful bugs in OSS-Fuzz as of
Sep’21.

are stateful.

Every four in ﬁve bugs that are reported in OSS-Fuzz for
protocol implementations among our subjects are stateful.

To understand the nature of bugs in protocol implemen-
tations, let us discuss all the bugs in H2O, our motivating
example in Section 2.

Stateful bugs in H2O. All 6 stateful bugs in H2O happen af-
ter speciﬁc state transitions on the state variable stream->state
explained in Section 2. Each stream in HTTP2 protocol has
a weight value to represent the priority of the stream to be
handled and H2O deﬁnes a scheduling component to main-
tain it. Bugs #12093, #12096, #12127, and #12100 have the
same root reason that they happen in the END_STREAM state
of stream->state within the scheduling component, so we
only explain bug #12096 here. To trigger it, the H2O ﬁrstly
needs to set a higher priority for the current stream, (e.g.,
via the header frame or a dedicated priority frame), and then
close the stream (e.g., via a "reset stream" or an "end stream"
frame to trigger a scheduler relocation). At the same time,
the value of stream->state will be changed from IDLE until
END_STREAM representing a sequence of state transitions.
The scheduling component only works for active streams, not
closed streams. Lastly, when we assign a new priority to the
closed stream, the bug 12096 is triggered because it does not
check if the stream is closed. Bug #2623 and #3303 have the
same root reason that they happen under the END_STREAM
state of stream->state, but not within the scheduling com-
ponent. We explain the bug #2623 here. To trigger it, H2O
ﬁrstly receives a header frame with the end-of-stream attribute
which indicates that no more frames for the stream. Then the
stream will be closed as the corresponding stream->state is
changed to END_STREAM. Lastly, when receiving another
frame called trailing header for the closed stream, H2O may
trigger the bug #2623 because of incomplete checking.

Stateless bugs in H2O. The 3 stateless bugs in H2O are ob-
served before processing requests where no state transitions
execute. Bug #2695 #2923 happens in the response genera-
tion component. H2O deﬁnes an object called generator to
maintain related operations of response generation, but the
generator is used without checking if it is NULL incurring
unexpected behaviors. Bug #37023 happens in the socket con-
nection functions which is also executed before processing
inputs without state transitions.

Totally, 6 out of 9 bugs in H2O are stateful. Although

Figure 5: Average branch coverage over time for SGFUZZ
and LIBFUZZER across all eight subjects in 23 hours.

though their state transition coverage is vastly varied. The
slowing growth rate of branch coverage further explains why
the time-to-coverage improvement is more signiﬁcant than
branch coverage improvement and branch coverage alone
isn’t enough to examine program state space. AFLNET is
substantially slower than other fuzzers, especially on Own-
Tone. On OwnTone, AFLNET ’s throughput is less than 10
inputs/second, while SGFUZZ ’s throughput is above 1000 in-
puts/second. Therefore AFLNET achieves much fewer branch
coverage than others.

A.3 Prevalence of Stateful Bugs

To investigate the prevalence of stateful bugs, we stud-
ied the bugs that were reported in OSS-Fuzz against
our subjects. We use the keyword subject/fuzz_driver
status:Verified -Type=Build-Failure to search avail-
able bugs on the OSS-Fuzz platform19. These bugs were
reported against previous versions, and these reports are pub-
licly available. A bug report links the bug ﬁx and a crash-
reproducing test case. We used this test case to debug these
crashes and to determine whether these bugs are stateful. Ta-
ble 11 illustrates the prevalence of stateful bugs. We classify
a bug as stateful if the crash location is reached after at least
one state transition. We ﬁnd that 57 (78.08%) of all 73 bugs

19https://bugs.chromium.org/p/oss-fuzz/issues/list

17

OwnToneDCMTKGstreamerOpenSSLLive555H2OMbedTLSCurl0612182306121823061218231250015000175002000020002100220010500110001150012000105001100011500120001250013000500052505500575060002000225025002750300032505100054000570006000063000120016002000Time (in hours)fuzzerAFLNetHonggfuzzIJONLibFuzzerSGFuzzexisting fuzzer can ﬁnd stateful bugs, the stateful bugs they
found only happen at the END_STREAM state of the stream-
>state which represents the endpoint of the stream state. No
bug is found during the state transitions except for the start
and end states. It provides further evidence to support that the
existing fuzzer cannot efﬁciently explore the state space of
the protocol programs. On the other hand, even if the state
space of the protocol program has not been explored enough,
the number of stateful bugs is still greater than stateless bugs.
Therefore, we claim that the stateful bugs are prevalent in
protocol implementations.

A.4 Top-50 most widely used open-source pro-

tocol implementations.

To investigate how states are tracked in the programs, We
reviewed the code of top-50 widely used protocol implemen-
tations that are open-sourced. We used the same criterion
as in Section 6 to examine the state variables: the values of
state variables are got from the input and affect the program
execution by the switch or if statements. We only show the
ﬁrst state variables if several state variables exist in a subject.
Table 12 shows the results. It includes more than 16 pro-
tocols and 50 corresponding subjects. We marked the cor-
responding protocol of the state variable in the Protocols
column or noted Customized if the state variables are used
for customized states, such as connection and data processing
states, not protocol states. Although some subjects (Sendmail,
Postﬁx, e.g.,) are protocol implementations, the state variables
we found in them are about customized states, not protocol
states. This result explains that developers usually design
many customized states in programs, and these states can not
be found by protocol documents. The column of Variable
Types/Values Examples represent the state variable types: enu-
merated type or macro deﬁnition (#deﬁne), and an example
of state variable values. All 50 subjects implement their states
by named constants, of which 44 subjects use enum-type vari-
ables.

Case study. We used OpenSSL to explain how the program
states are manipulated by the corresponding state variables.
Openssl has a handshake state machine to maintain
the state during the negotiation process between the two
parties to establish a connection. OpenSSL deﬁnes ﬁfty
state values20, partially ordered, to implement it. We focus
on the states on the server-side. At ﬁrst, it is in the idle
State (TLS_ST_BEFORE). When receiving HELLO message
from the client, it enters State (TLS_ST_SR_CLNT_HELLO),
sends
in
(DTLS_ST_SW_HELLO_VERIFY_REQUEST
States
to
it
(TLS_ST_SW_SRVR_DONE).
is

TLS_ST_SW_CERT_REQ),
State
done

other optional messages

indicates

one

and

one

by

by

20https://github.com/openssl/openssl/blob/

5811387bac39cdb6d009dc0139b56e6896259cbd/include/openssl/
ssl.h.in#L1026

18

the

them in

server checks

is ready and sends back op-
Then when the client
tional messages,
these
States (TLS_ST_SR_CERT to TLS_ST_SR_FINISHED,
TLS_ST_SW_CERT_VRFY). At last, it sends ﬁnal mes-
sages in States (TLS_ST_SW_SESSION_TICKET to
TLS_ST_SW_ENCRYPTED_EXTENSIONS) to conﬁrm the
server is ready too. States (TLS_ST_SW_KEY_UPDATE,
up-
TLS_ST_SR_KEY_UPDATE)
dating
connec-
establishing
(TLS_ST_SR_KEY_UPDATE,
tion.
TLS_ST_SR_END_OF_EARLY_DATA) are about the early
data feature introduced in TLS1.3 for the fast connection
between client and server who share the same pre-shared key
(PSK).

used
the

States

after

keys

are

for

Protocols

FTP

SFTP

TLS/SSL

SMTP

HTTP/2

RDP

NTP
IMAP
IRC
SMB
DAAP
SIP
DICOM

VNC

RTSP

MQTT

Customized

Subjects
Bftpd
LightFTP
vsftpd
ProFTPd
BoringSSL
libssh2
MbedTLS
OpenSSL
WolfSSL
Botan
Exim
OpenSMTPD
aolserver
H2O
httpd
LiteSpeed httpd
NgHttp2
Nginx
Tengine
thttpd
WebSocket++
Lighttpd
FreeRDP
xrdp
NTP
Dovecot
UnreadIRCd
Squid
OwnTone
Kamailio
DCMTK
libvncserver
TigerVNC
ffmpeg
VideoLAN
Mosquitto
aria2
inetutils
Gstreamer
OpenSSH
Pure-FTPd
libgcrypt
Postﬁx
Sendmail
Boa HTTPd
WebServer
tevent
Live555
OpenMQTTGateway
Curl

Variables Types/ Values Examples
enum / STATE_CONNECTED
macro / FTP_ACCESS_NOT_LOGGED_IN
macro / PRIV_SOCK_LOGIN
macro / SFTP_SESS_STATE_HAVE_AUTH
enum / state13_send_hello_retry_request
enum / libssh2_NB_state_idle
enum / MBEDTLS_SSL_HELLO_REQUEST
enum / TLS_ST_BEFORE
enum / SERVER_HELLOVERIFYREQUE..
enum / HELLO_REQUEST
enum / FF_DELIVERED
enum / STATE_HELO
enum / SOCK_ACCEPT
enum / H2O_HTTP2_STREAM_STATE_IDLE
enum / H2_SS_IDLE
enum / STREAM_FIN_RECVD
enum / NGHTTP2_STREAM_INITIAL
enum / NGX_HTTP_INITING_REQUEST...
enum / NGX_HTTP_TFS_STATE_WRITE...
macro / CHST_FIRSTWORD
enum / READ_HTTP_REQUEST
enum / LI_CON_STATE_DEAD
enum / DRDYNVC_STATE_INITIAL
enum / WMLS_RESET
macro / EVNT_UNSPEC
enum / AUTH_REQUEST_STATE_NEW
enum / CLIENT_STATUS_TLS_STAR...
enum / SMB_State_NoState
enum / PLAY_STOPPED
enum / H_SKIP_EMPTY
enum / DIMSE_StoreBegin
enum / RFB_INITIALISATION_SHARED
enum / RFBSTATE_UNINITIALISED
enum / RTSP_STATE_IDLE
enum / VLC_PLAYER_STATE_STOPPED
enum / mosq_ms_invalid
enum / STATUS_ALL
marco / TS_DATA
enum / GST_STATE_READY
enum / MA_START
enum / FTPWHO_STATE_IDLE
enum / STATE_POWERON
enum / STRIP_CR_DUNNO
enum / SM_EH_PUSHED
enum / READ_HEADER
enum / STATE_PARSE_URI
enum / TEVENT_REQ_INIT
enum / PARSING_VIDEO_SEQUENCE...
enum / OFF
enum / MSTATE_INIT

Table 12: The top-50 most widely used open-source protocol
implementations and their state variables.

