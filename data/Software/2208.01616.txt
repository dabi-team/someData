1

MaRCoS, an open-source electronic control system
for low-ﬁeld MRI
Vlad Negnevitsky∗, Yolanda Vives-Gilabert†, Jos´e M. Algar´ın‡, Lincoln Craven-Brightman§, Rub´en
Pellicer-Guridi¶, Thomas O’Reilly(cid:107), Jason P. Stockmann§, Andrew Webb(cid:107), Joseba Alonso‡ and Benjamin
Menk¨uc∗∗
∗Oxford Ionics Ltd, Oxford, OX5 1PF, UK
†Intelligent Data Analysis Laboratory, Department of Electronic Engineering, Universitat de Val`encia, Valencia, Spain
‡MRILab, Institute for Molecular Imaging and Instrumentation (i3M), Spanish National Research Council (CSIC) and Universitat
Polit`ecnica de Val`encia (UPV), Valencia, Spain
§Massachusetts General Hospital, A. A. Martinos Center for Biomedical Imaging, Charlestown, MA, USA
¶Asociaci´on de investigaci´on MPC, Donostia-San Sebasti´an, Spain
(cid:107)Department of Radiology, Leiden University Medical Center, Leiden, Netherlands
∗∗University of Applied Sciences and Arts Dortmund, Dortmund, Germany

Abstract

Every magnetic resonance imaging (MRI) device requires an electronic control system that handles pulse sequences and signal
detection and processing. Here we provide details on the architecture and performance of MaRCoS, a MAgnetic Resonance COntrol
System developed by an open international community of low-ﬁeld MRI researchers. MaRCoS is inexpensive and can handle
cycle-accurate sequences without hard length limitations, rapid bursts of events, and arbitrary waveforms. It can also be easily
adapted to meet further speciﬁcations required by the various academic and private institutions participating in its development.
We describe the MaRCoS hardware, ﬁrmware and software that enable all of the above, including a Python-based graphical user
interface for pulse sequence implementation, data processing and image reconstruction.

I. INTRODUCTION

The electronic control system or “console” is an indispensable component of any MRI scanner. This handles the sequences
of electromagnetic pulses (both radiofrequency and gradient) in a time-synchronous fashion, as well as the acquisition and
digitisation of MR signals, so they can be processed for image reconstruction. At a higher level, the control system also serves
as an interface between the user and the scanner itself.

MRI makes use of pulses in different regimes of the electromagnetic spectrum, radiofrequency in the MHz to hundreds
of MHz range, and gradient in the low kHz range, which are combined to fulﬁll the requirements for imaging: the creation
of phase coherent precessing magnetization using a resonant transmit coil, and spatial encoding, with the encoded signals
being detected via Faraday induction by a resonant receiver coil [1]. These tasks necessitate a high degree of phase coherence
between the various pulses, placing strong constraints on the time control. Modern ﬁeld-programmable gate-array (FPGA)
modules are perfectly suited for fast, time-synchronous tasks and are thus often at the core of MRI consoles.

The consoles provided by the major scanner manufacturers tend to be tailored to their speciﬁc setups [2], [3], but there exist
also more generic concepts that are somewhat hardware-agnostic and could be used in a wide range of scanners. Although a
number of relatively low cost consoles have been developed for MRI, e.g. Pure Devices GmbH (Rimpar, Germany), Magritek
Ltd (Wellington, New Zealand) or Niumag Corporation (Suzhou, China), these inevitably comprise much proprietary hardware
and software, and so do not lend themselves to open source development. In developing an open solution, it is also important to
note that many low-ﬁeld systems actually require quite sophisticated operation to overcome the speciﬁc challenges of low-ﬁeld
MRI [4]–[17].

Among the projects opened to the community [2], [18]–[24], the Open-source Console for Real-time Acquistion (OCRA
[21]) is notable for its ﬂexibility, inexpensive off-the-shelf components, community focus, and real-time capabilities. The
MAgnetic Resonance COntrol System (MaRCoS [3]) uses the same versatile hardware, however its software, ﬁrmware and
FPGA ﬁrmware have been replaced to go beyond the limitations of OCRA.

In this article we discuss the MaRCoS rationale and its main performance advances, then present the MaRCoS hardware,
ﬁrmware and desktop software. We then discuss the directions in which MaRCoS development is proceeding, and provide
some information for readers interested in trying MaRCoS out.

MaRCoS was started by a partnership of low-ﬁeld MRI academic groups [3] aiming to replace a range of proprietary

consoles with a uniﬁed, inexpensive yet high-performance platform suitable for some unconventional experiments.

II. SYSTEM GOALS AND OVERVIEW

Corresponding author: V. Negnevitsky (vnegnev@gmail.com).

2
2
0
2

g
u
A
2

]
h
p
-
d
e
m

.
s
c
i
s
y
h
p
[

1
v
6
1
6
1
0
.
8
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
2

The main project goals were to use open-source or off-the-shelf hardware, be easily programmable, have no hard limitations
on the sequence length or complexity, and to be scalable to multiple channels in the future. Additional goals were to allow the
transmit and receive modulation frequencies to be independently varied, and to support sampling rates up to several megahertz
for the purpose of investigating highly oversampled data acquisition [25]. Initially the existing OCRA platform was used and
extended1, however its limitations on sequence length, complexity and timing precision, as well as the low-level ‘assembly’-
style sequence programming, led to a complete rewrite of the server, FPGA ﬁrmware, and client software to create the MaRCoS
system.

The core of MaRCoS is the Red Pitaya SDRLab 122-16 [26], a commercial board with two analog inputs for digitising
received data and two analog outputs for generating the RF transmit waveforms, with a bandwidth of around 50 MHz making it
suitable for proton MRI at ﬁeld strengths of up to 1.17 Tesla. Two receive/transmit channels are run in parallel, with frequency
up/down-conversion and the bulk of the ﬁltering handled digitally. Three digital outputs can be used for controlling RF switches
or other peripherals, and one input is used for externally triggering acquisitions2. The SDRLab also controls either a GPA-
FHDO [27] or an OCRA1 [28] four-channel gradient board. The MaRCoS hardware is controlled from a PC over Ethernet.
Fig. 1 shows the overall system architecture.

Fig. 1. MaRCoS system architecture showing the main components in the desktop software stack and the embedded hardware and software on the SDRLab.
There are various ways to program a sequence, including a graphical user interface (GUI), direct Numpy arrays and PulSeq, which all control the marcos client
library. This communicates with the SDRLab, executing the sequence and returning the acquired data.

On the SDRLab, sequence and acquisition data are streamed to and from an FPGA, allowing for sequences of arbitrary
length. MaRCoS does not use raster clocks or impose any timing constraints on events beyond that of the hardware clock; the
architecture permits any change in an internal or external parameter to occur at any time with cycle-accuracy. This includes
changing the RF modulator/demodulator frequencies, RF envelope amplitudes and phases, gradient channel voltages, receiver
sampling rates and acquisition timing, and digital outputs. Sequences are programmed at a low level using simple arrays of
times and values for each parameter, which are converted to hardware instructions by the marcos client Python library. There
are several intermediate text-based interfaces to suit different styles of programming, as well as a GUI for running a range of
calibrations and predeﬁned acquisition routines.

To our knowledge MaRCoS is the ﬁrst inexpensive system that is capable of handling unlimited, cycle-accurate sequences,
handling rapid bursts of events, creating arbitrary waveforms, treating RF and gradients in a uniform way, independently
controlling the frequency, phase and amplitude of the different TX and RX channels in each TR, and meeting several other
speciﬁcations that were required for the experiments being planned when MaRCoS was begun. The hardware, ﬁrmware and
software are described in more detail below.

1The authors rewrote the OCRA server and client to use a msgpack-based protocol, support the open-source PulSeq hardware-agnostic sequencing language,

and support the newly-developed GPA-FHDO gradient board.

2It will also be used for synchronizing multiple devices during multi-channel operation, which is currently under development.

marcos_client library (Python)User-defined calibration, acquisitionDesktop PCVarious sequence descriptionsText-baseddescription orNumpy arraysGUI(see Section V)Red PitayaSDRLabPython or MATLABdata/filesCustom analysisGUI display window(see Section V)Low-level controlData analysisImage reconstruction/displayFPGA firmwareDigital I/OGradient controlTX controlRX controlLinux environmentmarcos_server (C++)Ethernet StreamingTX/RX gatesTrigger I/OSPI tograd. boards2x 14-bit DAC122.88 MHz2x 16-bit ADC122.88 MHzTR switchTriggersOCRA1 orGPA-FHDOgradient ampsRF amps,transmit coilsReceive coils,amps, filters3

A. SDRLab-based console

III. MARCOS HARDWARE

The core of the SDRLab is a Xilinx Zynq-7020 system-on-chip (SoC), integrating two embedded ARM processors and
a ﬁeld-programmable gate array (FPGA). MaRCoS runs Linux and a custom C++ server on the processors, which controls
the sequencing and digital signal processing (DSP) on the FPGA as well as digital and analog I/O. The Linux OS handles
networking and provides various standard services such as SSH.

The FPGA part of the Zynq communicates with a dual-channel 16-bit analog-digital converter (ADC) and a dual-channel 14-
bit digital-analog converter (DAC), which together provide two independent channels for MRI3. The system is clocked from a
122.88 MHz crystal oscillator4, providing an analog baseband bandwidth of ∼ 50 MHz. The Zynq also controls multiple digital
outputs and inputs, which communicate with the gradient board and external devices such as TR switches.

Fig. 2. MaRCoS hardware components. a) Red Pitaya SDRLab with a GPA-FHDO adapter PCB, b) GPA-FHDO board, and c) rendering of the OCRA1
board.

B. GPA-FHDO and OCRA1 gradient boards

MaRCoS currently supports two gradient DAC boards, the GPA-FHDO and the OCRA1, shown in Fig. 2. The GPA-FHDO
is a gradient DAC that also includes a linear power stage that can deliver ±10 A on four channels. The 4-channel 16-bit DAC5
supports serial-peripheral interface (SPI) clocks up to 50 MHz. Due to limitations of the SPI isolator6 on the GPA-FHDO, the
maximum SPI clock is around 40 MHz, which results in an effective sample rate of around 100 kSPS if the four channels are
updated in parallel7. The GPA-FHDO also monitors the current of each channel, which can be used to automatically calibrate
non-linearities and offsets in the analog circuitry. The ADC8 has a maximum sample rate of 500 kSPS for each channel. This
is limited by the SPI isolator in the same way as the DAC sample rate, however since the ADC is mainly used for calibrating
the system during the prescan, the sample rate of the ADC is not a critical factor. An adapter PCB for the SDRLab is available
to easily connect to the GPA-FHDO. It includes a buffer for the TX-gate signal and a connector for an optional fan. A plugin
module is also available for the GPA-FHDO to generate a ±12 V bipolar output, so that external analog gradient ampliﬁers
can be used. The GPA-FHDO and adapter PCB designs are fully open-source [27], and a set of PCBs can be manufactured
and assembled for below $400.

3ADC: Analog Devices LTC2185. DAC: Analog Devices AD9767
4Abracon ABLNO-122.880MHz
5Texas Instruments DAC80504
6Analog Devices ADUM4150
7The SPI bandwidth can be used to update the channels unevenly, e.g. one channel at 400 kSPS while the others are idle.
8Texas Instruments ADS8684

b)a)c)4

The OCRA1 is a gradient board with ±10 V single-ended and ±20 V differential voltage outputs on four channels. The
manufacturing ﬁles and schematics are available at [28]. It uses four 18-bit DACs9. The OCRA1 DACs can be run at their
maximum SPI clock frequency of 35 MHz, which results in an effective sample rate of ∼ 400 kSPS. The effective sample rate
for the OCRA1 is higher than the GPA-FHDO, mainly because the OCRA1 uses four separate SPI interfaces for its DACs
rather than a single four-channel DAC. Unlike the GPA-FHDO, the OCRA1 does not have a power stage. Hence, it requires
external analog gradient power ampliﬁers, which users can choose according to their needs. Another difference between the
two boards is that the OCRA1 has an on-board RF attenuator that could be used for ﬂip-angle calibration instead of varying
the RF amplitude directly from the SDRLab (MaRCoS does not currently support controlling the attenuator). The OCRA1
also has an onboard TX gate buffer similar to the SDRLab adapter PCB for the GPA-FHDO.

IV. MARCOS SERVER AND FPGA FIRMWARE

The MaRCoS architecture was designed from the ground up to achieve the goals in Sec. II. The FPGA ﬁrmware receives
instructions from the MaRCoS server and translates them into hardware commands, as well as down-converting, ﬁltering and
storing the receive data. The server in turn receives instruction binaries and control commands from the client PC, and sends
back acquired data. Fig. 3 shows the tightly coupled server-ﬁrmware architecture, which relies on the server streaming data
to and from the ﬁrmware in real time, and the ﬁrmware converting between the asynchronous data streams and synchronous
(precisely timed) input and output data using several layers of buffering.

Fig. 3. MaRCoS server and FPGA ﬁrmware architecture on the SDRLab. The server receives a sequence from the client PC via Ethernet and streams it to
the FPGA ﬁrmware, where it is translated into time-synchronous hardware operations including RF and gradient outputs. The ﬁrmware receives data from
the ADCs, demodulates and ﬁlters it, and saves it into RX buffers, from which it is read by the server and sent to the PC.

A. MaRCoS embedded server

The MaRCoS embedded server10 is tightly coupled to the FPGA ﬁrmware and has ﬁve major roles: receiving sequences
from the client PC, controlling the system at a high level (e.g. running or stopping sequences and checking the ﬁrmware

9Analog Devices AD5781B
10The server is a Linux user-space executable written in C++ running on the SDRLab, and is started/stopped, recompiled, etc. via SSH.

MaRCoSC++ serverFPGA firmwareCompiledsequenceRaw I/Qinput datastreamedinstructionsstreamedRX dataraw data(async.)RX channels (2x)Instructiondecoder, bufferand sequencer(131072 deep)CIC filterComplexmultiplierNumericallycontrolledoscillatorsCIC filterOutput & timingbuffers (FIFOs)8.14 ns buffertiming resolutionreadtimingwritetimingTo PC(Ethernet)From PC(Ethernet)RX windowsRX ratesfreq,phasesin/cossin/cosI dataQ dataI/QenvelopesGradientDAC wordsComplexmultipliersDigitalcontrollersOCRA1serialiserGPA-FHDOserialiserBuffer monitor(flow control,load balancing)Externalhardwareasynchronous datato/from external hardwaresynchronous data(exact timing)I RX buffer (32768 deep)Q RX buffer (32768 deep)TX/RX gatesTrigger I/OSPI lines tograd. boards2x 14-bit DAC122.88 MHz2x 16-bit ADC122.88 MHzTR switchTriggersOCRA1 orGPA-FHDOgradient ampsRF amps,transmit coilsReceive coils,amps, lowpass filters5

status), streaming a steady supply of instructions to the FPGA, regularly reading the FPGA receive buffers and streaming the
raw input data into large arrays in the system memory, and sending these arrays back to the client PC once the sequence
is ﬁnished. When a sequence is executing, the server tries to balance keeping the FPGA instruction buffer near-full against
keeping the receive buffers near-empty, since failing to supply enough instructions would result in an unpredictable timing
delay, and failing to read the received data would result in a buffer overﬂow and data loss. The server continuously tracks the
free space in the various buffers and allocates its time based on what is most urgent, and the ﬁrmware records ’buffer-full’ and
’buffer-empty’ events so that the user is always alerted if (and at what point) their sequence overloaded the server. The server
can sustain a steady rate of ∼ 1.5 million combined reads plus writes per second, which is enough for arbitrary-waveform
RF envelopes, gradient outputs and acquisition rates with bandwidths of several hundred kHz. Bursts of ∼ 20 000 output
instructions or acquisition samples are possible with several-MHz bandwidths owing to the large buffers11

The server currently receives a sequence from the client PC, executes it, and returns the data in three separate stages.
Sequences can be hundreds of megabytes in size12, however large amounts of sequence and acquisition data can take tens of
seconds to transfer to and from the SDRLab. This could be improved by transferring and executing the sequences in stages,
or streaming them from the PC in a similar way to the streaming between the server and FPGA ﬁrmware. The Python-based
client software is currently the performance bottleneck, however, so optimising the data transfer is not yet critical. The client
is discussed in Subsec. V-A.

B. FPGA ﬁrmware structure

The FPGA ﬁrmware executes the transmit, gradient, digital I/O and control instructions sent from the PC while simultaneously
acquiring ADC data, ﬁltering it and storing it in the receive buffers. The central ﬁrmware module is an instruction decoder
and sequencer, whose role is to interpret instructions from the circular instruction buffer which is kept ﬁlled by the server.
The decoder controls 24 output/timing ﬁrst-in ﬁrst-out (FIFO) buffers, which can store 8 words each. Most instructions tell
a particular FIFO to output a data word at a precise time, and these time-synchronous data words control the synchronous
ﬁrmware modules as shown in Fig. 3. These include the various transmit/receive cores, the gradient DAC controllers and digital
I/O, as well as cores whose properties are typically controlled asynchronously in other MRI consoles, such as the numerically-
controlled oscillator frequency and phase and the cascaded integrator-comb (CIC) ﬁlter decimation13. The uniformity of the
FIFOs allows each instruction simply to specify a FIFO index, time delay and output word; the complexity of choosing the
delays and values is handled entirely in the client software on the PC. This neatly decouples complex sequence timing and
design from low-level hardware or ﬁrmware details, since virtually any pattern of FIFO outputs could be executed with no
low-level changes.

C. Receive and transmit RF signal processing

The FPGA ﬁrmware performs both the down-conversion and low-pass ﬁltering of the received signal, and the up-conversion
of the transmitted signal envelope. These are traditionally done with external analog components, however can be performed
digitally in MaRCoS because the Larmor frequency of LF-MRI systems falls below the 61 MHz Nyquist frequency of the
SDRLab. On the receive path, the analog signal is digitized by a 16-bit ADC at 122.88 MHz. This results in a data rate of
2 Gbps per channel, which is challenging to transfer from the FPGA to the client PC using inexpensive hardware.

The data rate can be greatly reduced by digitally down-converting, lowpass-ﬁltering and downsampling. The down-conversion
is carried out by multiplying the signal from the ADC by the I and Q outputs of a quadrature oscillator operating at the Larmor
frequency. The numerically-controlled oscillator (NCO) uses a direct digital synthesizer (DDS), whose frequency and phase
can be altered during runtime through the output FIFOs. The ﬁrmware has three independent NCOs, and the NCO used by
each of the four TX and RX complex multipliers can be independently selected and switched mid-sequence.

In order to avoid aliasing, low-pass ﬁltering is needed before downsampling. An efﬁcient way to combine decimation and
ﬁltering is to use a CIC ﬁlter, which consists of a decimator and a moving average low-pass ﬁlter. The decimation rate of the
CIC is conﬁgured using output FIFOs, in a similar way to the NCO properties.

The aliased noise of a CIC increases towards the edge of the passband. The frequency response is also not perfectly ﬂat
across the passband, thus it is not ideal to use the entire bandwidth of the CIC ﬁlter. Instead, usually a second decimation and
ﬁltering stage follows the CIC with a small decimation factor, usually 2-4. In the case of MaRCoS, the data rate is already
greatly reduced after the CIC, and the second decimation stage is not implemented inside the FPGA. It is good practice to use
a ﬁnite-impulse-response (FIR) ﬁlter as the second decimation stage, which is also tuned to compensate the falling frequency
response of the CIC passband. These ﬁlters are called CIC compensation ﬁlters. In order to improve the aliasing performance

11Once sustained rates in the MHz range are required, however, MaRCoS must be modiﬁed to support direct-memory access (DMA) in the ﬁrmware and

server and/or extended with ﬁrmware-level data compression. This is well beyond current experimental demands.

12The total size of the MR sequence plus acquired data is limited by the memory that the server can reserve within Linux, which is around 500 MB.
13Controlling these with the same timing precision as the RF envelopes and gradients allows in-sequence alterations to the oscillator frequency, acquistion

rate, etc. and guarantees that the behaviour of a sequence is reproducible down to the clock cycle.

6

and stop-band suppression, multiple CIC ﬁlters can be cascaded. The MaRCoS ﬁrmware uses a CIC ﬁlter with six cascaded
stages.

MaRCoS can use either proprietary (Xilinx) or open-source cores for the complex multiplier, NCO and CIC. The three latter
cores were written for MaRCoS, and to the authors’ knowledge are among the most feature-complete open-source cores that
implement this functionality. They are available at [29]–[31].

The transmit chain is simpler than the receive chain, because no ﬁltering is needed. The complex baseband envelope data,
supplied by several output FIFOs, is up-converted by multiplying the signal by the I output of a quadrature oscillator, in a
reverse process to the down-conversion. The real part of the up-converted signal is then sent to the DAC. A low-pass ﬁlter is
usually applied in the analog RF chain after the RF power ampliﬁer, in order to remove higher harmonics.

D. Gradient control and digital I/O

To control the gradient boards, data from the FIFOs is serialized by dedicated modules for the GPA-FHDO and the OCRA1.
The OCRA1 module sends data over four parallel SPI links sharing a clock and enable line, to control the four DACs on the
OCRA1 board. The GPA-FHDO module has a single, bidirectional SPI link, which either controls the four-channel DAC or
reads the four-channel current-sensing ADC. Both modules have adjustable SPI clock frequencies, to optimize the gradient
update rate based on the experimental setup and cabling. They also report errors to the sequencer if they cannot serialize the
data they are being provided in time.

The general digital outputs are handled by a single FIFO, and mapped directly to output pins on the SDRLab. Eight LEDs
are controlled in the same way, for debugging and monitoring purposes. Digital inputs are read at precise times by a special
‘read’ instruction, and a ‘trigger’ instruction can pause the sequencer until a particular digital input changes its state14.

E. Electronic performance and stability

The electronic noise levels, amplitude and voltage ﬂuctuations, and timing jitter of MaRCoS should be low enough that they

never limit the quality of reconstructed images or cause artefacts/ghosting.

The FPGA ﬁrmware is clock cycle-accurate, and residual jitter in the ADCs or DACs comes from the phase noise of the
crystal oscillator as well as voltage and temperature ﬂuctuations. Based on its datasheet [32] the oscillator has a phase noise of
-162 dBc/Hz at a 10 kHz offset, and a maximum RMS jitter of 125 fs over a 12 kHz bandwidth; this level of jitter is not easily
measurable with common laboratory equipment. A pair of RF pulses 100 ms apart was sampled using a 1 GSPS oscilloscope,
and the timing jitter between them was below the measurement resolution of 1 ns. This measurement is likely too coarse by
orders of magnitude to capture the jitter, however it sets an upper bound.

We have also run a phase stability experiment using a CPMG pulse sequence [33], [34], with 100 repetitions of an echo train
with 50 echoes, 10 ms echo spacing and 1 s repetition time. The phase of the acquired echoes was stable down to 180 mrad
(standard deviation) for all echoes in the train, and down to ∼ 60 mrad for 20% of them.

The SDRLab ADC and DAC can be characterized by their spurious-free dynamic range (SFDR), which are 90 dBc and
75 dBc from their datasheets. We have not independently measured this, although informal online discussions by SDRLab
users indicate the ADC performance is better than the DAC, due to the DAC clock coming from the FPGA whereas the ADC
is clocked directly from the crystal oscillator [35].

Additionally we have measured the GPA-FHDO voltage drift over several hours to be below 10 µV, which is well below

what would affect typical MRI experiments.

The phase and magnitude of control pulses, as well as their timing, is sufﬁciently stable for demanding MRI applications
[3]. Although more thorough characterization is required, the MaRCoS hardware is sufﬁciently stable for imaging with a range
of sequences including gradient echo, turbo spin echo or inversion recovery, with different sampling trajectories like Cartesian
or radial [3].

A. MaRCoS client library

V. DESKTOP SOFTWARE PLATFORM

As discussed in Subsec. IV-A, the SDRLab executes sequences sent from the client PC, which runs the marcos client Python
library. This provides a class for creating and sending sequences from the PC, and various helper routines for controlling the
SDRLab hardware, calibrating the GPA-FHDO and testing various aspects of the MaRCoS system. At the marcos client level, a
sequence is speciﬁed by supplying pairs of (time, value) arrays for each hardware output and control, such as the TX envelope,
gradient waveforms, etc.15. The library scales and rounds the arrays to machine units, applies time offsets to cancel out latencies
in the gradient serialisers and other hardware, and compiles these values and times into binary instructions. These are encoded
via the msgpack protocol and sent to the MaRCoS server, which executes the sequence and returns the acquired data. The

14This will be used for multi-device synchronization in the future.
15For example, to specify two pulses of 70% full-scale amplitude starting at 20 µs and 100 µs from the beginning of the sequence, each with a duration of

30 µs, one would supply the array pair ([20, 50, 100, 130], [0.7, 0, 0.7, 0]).

7

acquired data is then scaled and passed to the user code, where it can be decimated, ﬁltered, then analysed or reconstructed
into an image.

The marcos client library is the foundation for the higher-level interfaces of MaRCoS, including text-based interfaces such
as PulSeq and a graphical interface. Internally marcos client is not yet optimized, and takes tens of seconds to compile when
sequences consisting of hundreds of complex TRs are run. As this becomes a bottleneck, the code can be sped up in a range of
ways, or ported to a language such as C++ or Rust for further performance gains – these will become increasingly important
as MaRCoS is scaled to handle more than two TX and RX channels. As mentioned previously the client-server architecture
can also be modiﬁed to support streaming sequences, which will further improve performance from the user’s perspective.

The MaRCoS server-FPGA ﬁrmware stack can be emulated on a PC by using the Verilator tool [36] to create a clock cycle-
accurate C++ model of the FPGA ﬁrmware, and compiling the MaRCoS server on desktop Linux so that it directly interacts
with the model. The emulated stack behaves like a virtual SDRLab on the network. It accepts MaRCoS binary sequences and
can produce plots of the emulated hardware outputs, as well as complete debugging information from the FPGA ﬁrmware,
and is useful for new users to learn the MaRCoS software without requiring any hardware. The marcos client library also has
a unit test suite that checks the behaviour of the emulated stack against pre-deﬁned reference outputs, which greatly simpliﬁes
development and debugging of the MaRCoS server and FPGA ﬁrmware.

B. Text-based interfaces

We have created a wrapper that enables MaRCoS users to program pulse sequences in the open-source PulSeq language in
either Matlab [37] or Python [38]. The wrapper converts pulse sequences from the PulSeq text ﬁle format (which describes
RF pulses, gradient pulses, and other sequence events) into Numpy arrays that marcos client takes as inputs, and is available
at [39]. Advantages of PulSeq are its comparative simplicity and its ability to compile the same script to generate sequences
for multiple platforms (including Siemens, GE, and Bruker), helping enable reproducible research across sites. The MaRCoS
console is now part of this PulSeq pulse sequence programming ecosystem. PulSeq also provides an easy-to-use tool for
students in university courses. Some tools built on top of this include basic scripts for ﬁnding the center frequency, calibrating
the RF transmit power, calibrating the gradient amplitudes, and basic B0 shimming [40].

Another MaRCoS wrapper, included with the marcos client library, provides a domain-speciﬁc language that is similar
to Magritek consoles, offering another style of programming. Due to the ﬂexibility of the array-style format accepted by
marcos client, new text-based wrappers are easy to write.

C. Graphical User Interface (GUI)

A GUI was designed and developed to facilitate the interaction between the users and MaRCoS. It is available to download
at the PhysioMRI github repository [41]. We note that the GUI is intended to be used in laboratory environments and not
yet for clinical purposes due to lack of required certiﬁcation. It offers highly customizable sequences through numerous input
parameters that can be modiﬁed by the user.

The GUI was designed and developed using Python, which allows for fast application development and execution, and relies
on the PyQt5 library. PyQt5 is a Python wrapper of Qt, which is a widely used GUI toolkit written in C++. The current version
of the GUI has been tested on Ubuntu 20.04.4 LTS and Windows 10, and it is expected to work under MacOS systems.

When the GUI starts, the latest FPGA ﬁrmware and MaRCoS server are installed onto the SDRLab. The MaRCoS server is
immediately run afterwards and the ﬁrst window of the GUI appears, called the Session Window. The Session Window allows
the user to select the kind of element that is going to be scanned, which can be a human subject or phantom, and to introduce
an ID related to it. Other information can also be introduced for subjects and phantoms, i.e. demographic data such as sex,
height and weight in the case of subjects. The acquisitions made in the subsequent windows will be related to this session ID:
however, the user can change it at any time by clicking the corresponding icon to come back to the session window. After
that, the GUI main window is launched (Fig. 4).

The GUI main window was developed combining two methodologies: 1) graphically by manually placing the different
layouts in the window by means of Qt Designer [42], which generates a ui ﬁle; and 2) hand-coding the dynamic addition of
elements and widgets speciﬁc to the selected sequence into the previously deﬁned layouts.

The communication between the GUI and the marcos client library is performed through the sequences, also written in
Python, which act as intermediate layer (Fig. 4). This intermediate layer provides some advantages: 1) the GUI can be safely
modiﬁed or even substituted by a new one while preserving sequences unchanged; and 2) users can run sequences even without
executing the GUI, especially useful while debugging new sequences. Experiments are run with a predeﬁned 6-fold oversampling
factor applied to the acquisition bandwidth required by the sequence. Once the acquired data is received, the decimation FIR
ﬁlter implemented in Scipy is applied to extract the signal with the originally required bandwidth. This oversampling factor
compensates the non-ﬂat frequency response of the CIC ﬁlter applied in the FPGA, as explained above in Subsec. IV-C.

A number of sequences have already been developed and introduced into the GUI repository, which are [43]: 3D turbo spin
echo, 3D gradient echo, and 2D HASTE, while new sequences can be integrated very easily. In order to facilitate this, a Python

8

Fig. 4. MaRCoS GUI overview. a) Communication and software hierarchy between the GUI and the MaRCoS server on the SDRLab. b) Main window of
the GUI.

class for each new sequence has to be created. These sequence classes inherit from a parent class (mriBlankSequence)
that contains many methods common to all sequences, e.g. RF pulses, gradient pulses, readout or save data.

It is essential that new sequence classes include three basic elements: the input parameters, their corresponding default
values and the associated labels that will be displayed in the GUI main window. Moreover, they have to include four methods:
sequenceInfo, which displays information related to the author of the sequence as well as any useful information related
to the sequence itself; sequenceTime, which estimates the duration of the acquisition every time that a GUI input parameter
is changed and it prints the result into the console; sequenceRun, which contains the deﬁnition of the pulses and timings of
the sequence; and sequenceAnalysis, which processes the acquired data and deﬁnes the plots that the GUI will display.
The GUI also integrates a calibration window with useful functions that helps to calibrate the scanner. At the moment, the
calibration functions already developed are: Rabi ﬂops for ﬂip angle calibration, inversion recovery sequence to measure T1,
resonant frequency to compensate for any ﬁeld drift, noise measurement to characterize the system in new environments, a
CPMG pulse sequence to measure T2, shimming and generic slice selection. The calibration window was designed following
the same procedure as the main window and its appearance is very similar.

Other functionalities implemented in the GUI main window cover the export of the selected sequence and loading and
saving input parameters from and to ﬁles. The export is also useful for the batch acquisition functionality, which performs
multiple measurements sequentially without human intervention. In this case, the user exports the parameters of the different
experiments to be performed and uploads them in the desired order to the batch window. The GUI also includes the possibility
to linearly sweep two parameters for any image or calibration sequence.

Finally, the GUI is linked to an XNAT server [44]. XNAT is an open source imaging informatics platform that facilitates
common management, productivity, and quality assurance tasks for imaging and associated data. By enabling the corresponding
icon in the GUI main window, it is possible to automatically upload the recently acquired MRIs to the XNAT if it is operational
in the PC. Data is saved in Matlab ﬁles (.mat) and NIfTI format.

The GUI is routinely used at i3M. However, there are a number of developments which we wish to add, such as an automatic
method that checks if the sequence parameters are within hardware limits and avoids executing sequences that are out of bounds,
the use of sequences that offer the possibility to manage multiple TX or RX channels, and the use of different frequencies for
TX and RX.

Additional sequences such as balanced steady state free precession, echo planar imaging or zero echo time, as well as new
sampling trajectories beyond Cartesian trajectories, will enrich the possibilities offered by the GUI. Other useful utilities, which
are often featured in commercial imaging systems, include the possibility to set the ﬁeld of view directly from a scout image,
or be able to select a region of interest and show the mean value and standard deviation to get a quick estimation of the

marcos_client library (Python)Sequences (Python)RARE, GRE, Rabi flops,inversion, recovery etcGUIInput parameters,parameter sweepssequence plotting,sequence execution,image displaymarcos_server (C++)on SDRLabb)a)Ethernet 9

signal-to-noise ratio. Another longer-term aim is to make the GUI accessible to non-expert users, i.e. to develop protocols to
generate a standardized set of images from different sequences.

VI. CONCLUSION

This paper has described the design and initial performance of MaRCoS, an open-source MRI electronic control system
based on a Red Pitaya SDRLab platform and custom gradient boards. The system has two transmit channels, two receive
channels, and can drive three gradient DACs with another channel also available. The control and testing can be performed in
readily available open-source software. Critical measures of phase stability, timing accuracy, and data transfer rates have been
evaluated. The receiver channel can directly digitize the MR signal, with signiﬁcant over-sampling enabling the minimization
of quantization noise. CIC ﬁlters are used in the ﬁnal stage of signal processing. A graphical user interface has been designed
in Python, which provides a critical interface in being able to write new imaging sequences and to assess image performance.
The development of the MaRCoS system is just beginning, and a number of future advances and desirable extensions have
also been listed. The low cost means that interested readers can be up-and-running for around $1000 (for the SDRLab and
gradient board). There are a number of constantly upgraded and interactive resources to get started, including a wiki page
[45] and Slack channel [46].

AUTHOR CONTRIBUTIONS

J. Alonso, A. Webb and V. Negnevitsky conceived and planned the MaRCoS project, with major technical contributions and
advice from B. Menk¨uc and J. P. Stockmann. B. Menk¨uc wrote the GPA-FHDO serializer, CIC ﬁlter, complex multiplier and
NCO modules of the MaRCoS ﬁrmware, and V. Negnevitsky wrote the rest of the ﬁrmware. L. Craven-Brightman wrote the
MaRCoS-PulSeq library. Y. Vives-Gilabert and J. M. Algar´ın wrote the MaRCoS GUI. V. Negnevitsky wrote the MaRCoS
server, client and auxiliary tools. B. Menk¨uc, J. M. Algar´ın, R. Pellicer-Guridi, T. O’Reilly, Y. Vives-Gilabert and L. Craven-
Brightman tested and characterized the system, in the research laboratories of J. Alonso, B. Menk¨uc, A. Webb and J. P.
Stockmann. V. Negnevitsky, B. Menk¨uc, J. Alonso, Y. Vives-Gilabert, J. M. Algar´ın, J. P. Stockmann and A. Webb prepared
the manuscript, with input from all authors.

ACKNOWLEDGEMENTS

Enormous credit goes to Thomas Witzel, Marcus Prier, Suma Anand and David Schote for their work on the OCRA system
as well as many fruitful discussions. Thanks to Danny Park for preparing the original SDRLab Linux image used in both OCRA
and MaRCoS, and Maxim Zaitsev for fruitful discussions on rounding and timing in PulSeq. This work was supported by the
Ministerio de Ciencia e Innovaci´on of Spain through research grant PID2019-111436RB-C21. The work was co-ﬁnanced by
the European Union through the Programa Operativo del Fondo Europeo de Desarrollo Regional (FEDER) of the Comunitat
Valenciana (IDIFEDER/2018/022 and IDIFEDER/2021/004) and ERC Advanced Grant 101021218 PASMAR, the National
Institutes of Health NIBIB under grant number U24-EB028984, and the HIFF program of the University of Applied Sciences
and Arts Dortmund.

REFERENCES

[1] E. M. Haacke, R. W. Brown, M. R. Thompson, R. Venkatesan et al., Magnetic resonance imaging: physical principles and sequence design. Wiley-liss

New York:, 1999, vol. 82.

[2] P. P. Stang, S. M. Conolly, J. M. Santos, J. M. Pauly, and G. C. Scott, “Medusa: A scalable MR console using USB,” IEEE Transactions on Medical

Imaging, vol. 31, no. 2, pp. 370–379, feb 2012.

[3] T. Guallart-Naval et al., “Benchmarking the performance of a low-cost Magnetic Resonance Control System at multiple sites in the open MaRCoS

community,” arXiv preprint arXiv:2203.11314, 2022.

[4] P. C. McDaniel, C. Z. Cooley, J. P. Stockmann, and L. L. Wald, “The MR Cap: A single-sided MRI system designed for potential
point-of-care limited ﬁeld-of-view brain imaging,” Magnetic Resonance in Medicine, vol. 82, no. 5, pp. 1946–1960, nov 2019. [Online]. Available:
https://onlinelibrary.wiley.com/doi/full/10.1002/mrm.27861

[5] M. Nakagomi, M. Kajiwara, J. Matsuzaki, K. Tanabe, S. Hoshiai, Y. Okamoto, and Y. Terada, “Development of a small car-mounted magnetic resonance

imaging system for human elbows using a 0.2 T permanent magnet,” Journal of Magnetic Resonance, vol. 304, pp. 1–6, jul 2019.

[6] C. Z. Cooley, P. C. McDaniel, J. P. Stockmann, S. A. Srinivas, S. F. Cauley, M. ´Sliwiak, C. R. Sappo, C. F. Vaughn, B. Guerin, M. S. Rosen, M. H.
Lev, and L. L. Wald, “A portable scanner for magnetic resonance imaging of the brain,” Nature Biomedical Engineering 2020 5:3, vol. 5, no. 3, pp.
229–239, nov 2020. [Online]. Available: https://www.nature.com/articles/s41551-020-00641-5

[7] T. O’Reilly, W. M. Teeuwisse, D. Gans, K. Koolstra, and A. G. Webb, “In vivo 3D brain and extremity MRI at 50 mT using a permanent magnet Halbach
array,” Magnetic Resonance in Medicine, p. mrm.28396, jul 2020. [Online]. Available: https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.28396
[8] K. N. Sheth, M. H. Mazurek, M. M. Yuen, B. A. Cahn, J. T. Shah, A. Ward, J. A. Kim, E. J. Gilmore, G. J. Falcone, N. Petersen, K. T. Gobeske,
F. Kaddouh, D. Y. Hwang, J. Schindler, L. Sansing, C. Matouk, J. Rothberg, G. Sze, J. Siner, M. S. Rosen, S. Spudich, and W. T. Kimberly,
“Assessment of Brain Injury Using Portable, Low-Field Magnetic Resonance Imaging at the Bedside of Critically Ill Patients,” JAMA Neurology,
vol. 78, no. 1, pp. 41–47, jan 2021. [Online]. Available: https://jamanetwork.com/journals/jamaneurology/fullarticle/2769858

[9] M. H. Mazurek, M. M. Yuen, B. A. Cahn, M. S. Rosen, K. T. Gobeske, E. J. Gilmore, D. Hwang, F. Kaddouh, J. A. Kim, G. Falcone, N. Petersen,
J. Siner, S. Spudich, G. Sze, W. T. Kimberly, and K. N. Sheth, “Low-Field, Portable Magnetic Resonance Imaging at the Bedside to Assess Brain Injury
in Patients with Severe COVID-19 (1349),” Neurology, vol. 96, no. 15 Supplement, 2021.

[10] Y. Liu, A. T. L. Leong, Y. Zhao, L. Xiao, H. K. F. Mak, A. Chun, O. Tsang, G. K. K. Lau, G. K. K. Leung, E. X. Wu, and X. . Linfang, “A low-cost
and shielding-free ultra-low-ﬁeld brain MRI scanner,” Nature Communications 2021 12:1, vol. 12, no. 1, pp. 1–14, dec 2021. [Online]. Available:
https://www.nature.com/articles/s41467-021-27317-1

10

[11] T. Guallart-Naval, J. M. Algar´ın, R. Pellicer-Guridi, F. Galve, Y. Vives-Gilabert, R. Bosch, E. Pall´as, J. M. Gonz´alez, J. P. Rigla, P. Mart´ınez, F. J. Lloris,
J. Borreguero, A. Marcos-Perucho, V. Negnevitsky, L. Mart´ı-Bonmat´ı, A. R´ıos, J. M. Benlloch, and J. Alonso, “Portable magnetic resonance imaging
of patients indoors, outdoors and at home,” arXiv preprint arXiv:2203.03455, 2022.

[12] T. O’Reilly and A. G. Webb, “In vivo T1 and T2 relaxation time maps of brain tissue, skeletal muscle, and lipid measured in healthy volunteers at 50 mT,”
Magnetic Resonance in Medicine, vol. 87, no. 2, pp. 884–895, feb 2021. [Online]. Available: https://onlinelibrary.wiley.com/doi/full/10.1002/mrm.29009
[13] M. Sarracanie, “Fast Quantitative Low-Field Magnetic Resonance Imaging With OPTIMUM - Optimized Magnetic Resonance Fingerprinting
Using a Stationary Steady-State Cartesian Approach and Accelerated Acquisition Schedules,” Investigative Radiology, 2021. [Online]. Available:
https://journals.lww.com/investigativeradiology/Fulltext/9000/Fast Quantitative Low Field Magnetic Resonance.98659.aspx

[14] J. M. Algar´ın, E. D´ıaz-Caballero, J. Borreguero, F. Galve, D. Grau-Ruiz, J. P. Rigla, R. Bosch, J. M. Gonz´alez, E. Pall´as, M. Corber´an, C. Gramage,
S. Aja-Fern´andez, A. R´ıos, J. M. Benlloch, and J. Alonso, “Simultaneous imaging of hard and soft biological tissues in a low-ﬁeld dental MRI
scanner,” Scientiﬁc Reports, vol. 10, no. 1, p. 21470, 2020. [Online]. Available: https://doi.org/10.1038/s41598-020-78456-2

[15] J. M. Gonz´alez, J. Borreguero, E. Pall´as, J. P. Rigla, J. M. Algar´ın, R. Bosch, F. Galve, D. Grau-Ruiz, R. Pellicer, A. R´ıos, J. M. Benlloch, and J. Alonso,

“Prepolarized MRI of Hard Tissues and Solid-State Matter,” arXiv preprint arXiv:2110.03417, 2021.

[16] J. Borreguero, F. Galve, J. M. Algar´ın, J. M. Benlloch, and J. Alonso, “Slice-selective Zero Echo Time imaging of ultra-short T2 tissues based on

spin-locking,” arXiv preprint arXiv:2201.06305, 2022.

[17] C. Z. Cooley, J. P. Stockmann, T. Witzel, C. LaPierre, A. Mareyam, F. Jia, M. Zaitsev, Y. Wenhui, W. Zheng, P. Stang, G. Scott, E. Adalsteinsson, J. K.
White, and L. L. Wald, “Design and implementation of a low-cost, tabletop MRI scanner for education and research prototyping,” Journal of Magnetic
Resonance, vol. 310, p. 106625, jan 2020.

[18] W. Tang, W. Wang, W. Liu, Y. Ma, X. Tang, L. Xiao, and J. H. Gao, “A home-built digital optical MRI console using high-speed serial links,”

Magnetic Resonance in Medicine, vol. 74, no. 2, pp. 578–588, aug 2015. [Online]. Available: https://onlinelibrary.wiley.com/doi/10.1002/mrm.25403

[19] C. J. Hasselwander, Z. Cao, and W. A. Grissom, “gr-MRI: A software package for magnetic resonance imaging using software deﬁned radios,” Journal

of Magnetic Resonance, vol. 270, pp. 47–55, sep 2016.

[20] S. Anand, J. P. Stockmann, L. L. Wald, and T. Witzel, “A low-cost (<$500 USD) FPGA-based console capable of real-time control,” in Proceedings

of the 2018 ISMRM & SMRT annual meeting and exhibition in Paris.

ISMRM, 2018, p. 948.

[21] “OCRA MRI.” [Online]. Available: https://openmri.github.io/ocra/
[22] K. Takeda, “Chapter 7 - Highly Customized NMR Systems Using an Open-Resource, Home-Built Spectrometer,” ser. Annual Reports on NMR
Spectroscopy, G. A. Webb, Ed. Academic Press, 2011, vol. 74, pp. 355–393. [Online]. Available: https://www.sciencedirect.com/science/article/pii/
B9780080970721000078

[23] C. A. Michal, “A low-cost multi-channel software-deﬁned radio-based NMR spectrometer and ultra-affordable digital pulse programmer,”
[Online]. Available:

in Magnetic Resonance Part B: Magnetic Resonance Engineering, vol. 48B, no. 3, p. e21401, 2018.

Concepts
https://onlinelibrary.wiley.com/doi/abs/10.1002/cmr.b.21401

[24] A. Ang, M. Bourne, S. Obruchkov, and R. Dykstra, “Construction of a pxie platform for instrumentation development,” in 2017 Eleventh International

Conference on Sensing Technology (ICST), 2017, pp. 1–4.

[25] F. Galve, J. Alonso, J. M. Algar´ın, and J. M. Benlloch, “Magnetic Resonance Imaging method with zero echo time and slice selection,” ES Patent

P202 030 504, 2020.

[26] “Red Pitaya SDRLab,” https://redpitaya.com/sdrlab-122-16/.
[27] B. Menk¨uc, “GPA-FHDO GitHub project website,” https://github.com/menkueclab/GPA-FHDO.
[28] M. Prier, “OCRA1 introduction,” https://zeugmatographix.org/ocra/2020/11/27/ocra1-spi-controlled-4-channel-18bit-dac-and-rf-attenutator/.
[29] “Complex multiplier core Git repository.” [Online]. Available: https://github.com/catkira/complex multiplier
[30] “CIC core Git repository.” [Online]. Available: https://github.com/catkira/CIC
[31] “DDS core Git repository.” [Online]. Available: https://github.com/catkira/DDS
[32] “Abracon ABLNO-122.880MHz datasheet.” [Online]. Available: https://abracon.com/Precisiontiming/ABLNO.pdf
[33] H. Y. Carr, “Steady-state free precession in nuclear magnetic resonance,” Physical Review, vol. 112, no. 5, pp. 1693–1701, dec 1958.
[34] S. Meiboom and D. Gill, “Modiﬁed spin-echo method for measuring nuclear relaxation times,” Review of Scientiﬁc Instruments, vol. 29, no. 8, pp.

688–691, 1958.

[35] “STEMlab 16-122.88 - TX composite noise measurements [German].” [Online]. Available: https://saure.org/phpBB 04/viewtopic.php?f=35&t=519
[36] “Verilator, a fast open-source Verilog/SystemVerilog simulator.” [Online]. Available: https://www.veripool.org/verilator/
[37] K. J. Layton, S. Kroboth, F. Jia, S. Littin, H. Yu, J. Leupold, J. F. Nielsen, T. St¨ocker, and M. Zaitsev, “Pulseq: A rapid and hardware-independent
[Online]. Available:

pulse sequence prototyping framework,” Magnetic Resonance in Medicine, vol. 77, no. 4, pp. 1544–1552, apr 2017.
https://onlinelibrary.wiley.com/doi/10.1002/mrm.26235

[38] K. S. Ravi, S. Geethanath, and J. T. Vaughan, “PyPulseq: A Python package for MRI pulse sequence design,” Journal of Open Source Software, vol. 4,

no. 42, p. 1725, 2019. [Online]. Available: https://doi.org/10.21105/joss.01725

[39] “FLOCRA-PulSeq Git repository.” [Online]. Available: https://github.com/stockmann-lab/ﬂocra-pulseq
[40] “MGH MARCOS Project.” [Online]. Available: https://github.com/stockmann-lab/mgh marcos
[41] “PhysioMRI Git repository.” [Online]. Available: https://github.com/yvives/PhysioMRI GUI
[42] “Qt Designer.” [Online]. Available: https://doc.qt.io/qt-6/qtdesigner-manual.html
[43] M. Bernstein, K. King, and X. Zhou, Handbook of MRI Pulse Sequences. Elsevier Academic Press, 2004.
[44] “XNAT.” [Online]. Available: https://www.xnat.org/
[45] “MaRCoS Git repository and wiki.” [Online]. Available: https://github.com/vnegnev/marcos extras/wiki
[46] “MaRCoS Slack group.” [Online]. Available: https://marcos-system.slack.com

