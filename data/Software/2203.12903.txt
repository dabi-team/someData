Identifying Boundary Conditions with the Syntax and Semantic
Information of Goals
Jianwen Li
East China Normal University
Shanghai, China
lijwen2748@gmail.com

Yechuan Xia
East China Normal University
Shanghai, China
xiaozi465@gmail.com

Shengping Xiao
East China Normal University
Shanghai, China
shengping.xiao98@gmail.com

2
2
0
2

r
a

M
5
2

]
E
S
.
s
c
[

2
v
3
0
9
2
1
.
3
0
2
2
:
v
i
X
r
a

Weikai Miao
Shanghai Key Lab for Trustworthy
Computing
East China Normal University
Shanghai, China
wkmiao@sei.ecnu.edu.cn

Geguang Pu
East China Normal University
Shanghai, China
ggpu@sei.ecnu.edu.cn

ABSTRACT
In goal-oriented requirement engineering, boundary conditions
(BC) are used to capture the divergence of goals, i.e., goals cannot
be satisfied as a whole in some circumstances. As the goals are
formally described by temporal logic, solving BCs automatically
helps engineers judge whether there is negligence in the goal re-
quirements. Several efforts have been devoted to computing the
BCs as well as to reducing the number of redundant BCs as well.
However, the state-of-the-art algorithms do not leverage the logic
information behind the specification and are not efficient enough
for use in reality. In addition, even though reducing redundant BCs
are explored in previous work, the computed BCs may be still not
valuable to engineering for debugging.

In this paper, we start from scratch to establish the fundamental
framework for the BC problem. Based on that, we first present a new
approach SyntacBC to identify BCs with the syntax information
of goals. The experimental results show that this method is able
to achieve a >1000X speed-up than the previous state-of-the-art
methodology. Inspired by the results, we found the defects of BCs
solved by our method and also by the previous ones, i.e., most of
BCs computed are difficult for debugging. As a result, we leverage
the semantics information of goals and propose an automata-based
method for solving BCs, namely SemanticBC, which can not only
find the minimal scope of divergence, but also produce easy-to-
understand BCs without losing performance.

1 INTRODUCTION
The requirement process is a crux stage in the whole life-cycle
of software engineering, only based on which the system design,
testing, and verification/validation can be completed properly in
order [21]. Requirements written in natural languages are often
considered to be ambiguous, which can potentially affect the qual-
ity of further stages in software development. The goal-oriented
requirement engineering (GORE) is a promising direction to avoid
the ambiguity in the requirements, as each goal (a piece of require-
ment) is written in formal languages like Linear Temporal Logic
(LTL) [31], which is rigorous in mathematics. Moreover, the re-
quirement written in LTL, which is normally called specification,
enables its correctness checking in an automatic way, saving a lot
of artificial efforts [6].

The conflict analysis is a common check to guarantee the correct-
ness of the GORE specification. Since the specification is written by
LTL, such analysis can be achieved by reducing it to LTL satisfiabil-
ity checking [23, 24]. If the specification formula is unsatisfiable, it
indicates there is a conflict among different goals which consist of
the specification. Because of the superior performance of modern
LTL satisfiability solvers [9, 22], the conflict analysis in GORE can
be accomplished successfully. However, there are more stubborn
defects that cannot be detected by satisfiability checking directly.
For example, even though all goals together are satisfiable, there are
some certain circumstances in which the goals cannot be satisfied
as a whole any more. Such circumstances are called the boundary
conditions (BC).

Given a set of domain properties ğ·ğ‘œğ‘š and goals ğº, both of which
consist of LTL formulas, a BC ğ‘ğ‘ satisfies (1) the conjunction of ğ‘ğ‘
and all elements in ğ·ğ‘œğ‘š and ğº is unsatisfiable, and (2) after remov-
ing an element from ğº, the above conjunction becomes satisfiable,
and (3) ğ‘ğ‘ cannot be semantically equivalent to the negation of ele-
ments in ğº. Details see below. Informally speaking, a BC captures
the divergence of goals, i.e., the satisfaction of some goals inhibits
the satisfaction of others.

Several efforts have been devoted to computing the BCs for the
given goals and domain properties. The most recent one is based
on a genetic algorithm in which a chromosome represents an LTL
formula ğœ‘ and each gene of the chromosome characterises a sub-
formula of ğœ‘ [6]. After setting the initial population and fitness
function, the algorithm utilizes two genetic operators, i.e., crossover
and mutation, to compute the BC with respect to the input goals and
domains. Since the genetic algorithm is a heuristic search strategy,
using this approach to compute BCs is not complete. Also, the BCs
computed by such algorithm seems to be redundant, i.e., it is often
the case that two generated BCs ğœ‘1, ğœ‘2 satisfy ğœ‘1 â‡’ ğœ‘2, which
indicates that the BC ğœ‘2 is redundant.

To solve this problem, Luo et. al. presented the concept of con-
trastive BCs to reduce the number of redundant BCs generated from
the above genetic approach [26]. The motivation comes from that
two BCs ğœ‘1, ğœ‘2 are contrastive if ğœ‘1 âˆ§ Â¬ğœ‘2 is not a BC and ğœ‘2 âˆ§ Â¬ğœ‘1
is not a BC. Once a BC is computed, the algorithm adds the negation
of it into the domain properties such that the next computed BC is

 
 
 
 
 
 
contrastive to the previous ones. The literature shows that, com-
puting only the contrastive BCs saves many efforts of engineers to
locate the defects revealed by the BCs in the specification.

From our preliminary results, the efficiency of the genetic ap-
proach to compute BCs seems modest and has to be improved
to meet the requirement from the industry. Also, the computed
BCs from this approach may not be quite useful for debugging.
Let ğº = {â–¡(â„ â†’ â—¦ğ‘), â–¡(ğ‘š â†’ â—¦Â¬ğ‘)} be the set of goals and
assume the set of domain properties is empty. It is not hard to
see that â„ âˆ§ ğ‘š is a BC, which means once the pre-conditions â„
and ğ‘š are true together, the two goals cannot be met as a whole.
But boundary conditions are not unique, and the LTL formulas
ğœ“1 = (â„ âˆ§â—¦Â¬ğ‘) âˆ¨ (cid:94)(ğ‘š âˆ§â—¦ğ‘) and ğœ“2 = (ğ‘š âˆ§â—¦ğ‘) âˆ¨ (cid:94)(â„ âˆ§â—¦Â¬ğ‘) are
also BCs. Obviously, the BC â„ âˆ§ğ‘š is more helpful for engineers than
the other two, as they do not explicitly show the events causing
the divergence.

The observation is that,ğœ“1 andğœ“2 consist of disjunctive operators
(âˆ¨), each element of which only captures a single circumstance that
falsifies one goal. We argue that a meaningful and valuable BC shall
not consist of the disjunctive operator. However, current approaches
seems to compute mostly the BCs less helpful, i.e., with the form of
(cid:212)ğœ“ . Even the contrastive BCs computed in [26] cannot avoid such
problem. Take the above example again, ğœ“1 and ğœ“2 are contrastive
BCs, but they are less helpful than â„ âˆ§ ğ‘š. Therefore, the better
algorithms to generate more helpful BCs are still in demand.

In this paper, we start from scratch to establish a fundamental
framework to compute the BCs in GORE. We first present a general
but efficient algorithm SyntacBC to compute the BC based on the
syntax information of goals. We prove in a rigorous way that by
simply negating the goals and domains, i.e., Â¬(ğ·ğ‘œğ‘š âˆ§ ğº), and
replacing some ğ‘”ğ‘– âˆˆ ğº with ğ‘”â€²
ğ‘– â‡’
ğ‘”ğ‘– , the constructed formula is a BC. Such algorithm performs much
better than all other existing approaches, even though it generates
the BC with disjunctive operators, which is less helpful.

ğ‘– in the negated formula where ğ‘”â€²

To compute different kinds of BC that are not in the form of (cid:212)ğœ“ ,
we leverage the semantics of goals and present an automata-based
approach in which the BCs can be extracted from the accepting
languages of an automata. The motivation comes from the well-
known fact that there is a (BÃ¼chi) automaton for every LTL formula
such that they accept the same languages [13]. Since the inputs and
output of the BC problem are all LTL formulas, it is straightforward
to consider this problem by reducing it to the automata construction
problem. Briefly speaking, we first reduce the BC computation for a
set of goals whose length is greater than 2 to that for a set of goals
whose length is exactly 2, making the problem easier to handle.
Secondly, given a goal set ğº = {ğ‘”1, ğ‘”2} and a domain set ğ·ğ‘œğ‘š, we
construct the automata for the formulas ğœ™1 = ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2 and
ğœ™2 = ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2. Then we define the synthesis production (âˆ§âˆ—)
on the automata for the purpose to compute the BCs. We prove
that under the synthesis production, the produced automaton of
includes necessary information to extract BCs.
Ağœ™ = Ağœ™1
In summary, the contribution of this paper are listed as follows:

(cid:211)âˆ—Ağœ™2

â€¢ We present SyntacBC and SemanticBC, the two new ap-
proaches to identify boundary conditions based on the syn-
tax and semantics information of goals (LTL formulas);

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

â€¢ The experimental evaluation shows that SyntacBC is able to
achieve a >1000X speed-up than the previous state-of-the-
art methodology. Moreover, SemanticBC is able to provide
more helpful BCs than previous work;

â€¢ The solutions shown in this paper provide a promising di-
rection to reconsider the problem of identifying boundary
conditions from the theoretic foundations.

We continue in the next section with preliminaries. A motivating
example is presented in Section 3. Section 4 presents the SyntacBC
approach and Section 5 presents the SemanticBC approach. Finally,
Section 6 and 7 discuss and conclude the paper.

2 PRELIMINARIES
2.1 LTL and BÃ¼chi Automata
Linear Temporal Logic (LTL) is widely used to describe the discrete
behaviors of a system over infinite trace. Given a set of atomic
propositions ğ´ğ‘ƒ, the syntax of LTL formulas is defined by:

ğœ™ ::= âŠ¤ | ğ‘ | Â¬ğœ™ | ğœ™ âˆ§ ğœ™ | â—¦ğœ™ | ğœ™ U ğœ™
where âŠ¤ represents the true formula, ğ‘ âˆˆ ğ´ğ‘ƒ is an atomic proposi-
tion, Â¬ is the negation, âˆ§ is the and, â—¦ is the Next and U is the Until
operator. We also have the corresponding dual operators âŠ¥ (false)
for âŠ¤, âˆ¨ (or) for âˆ§, and R (Release) for U. Moreover, we use the no-
tation ğœ™1 â†’ ğœ™2 (imply), â–¡ğœ™ (Global), and (cid:94)ğœ™ (Future) to represent
(Â¬ğœ™1) âˆ¨ ğœ™2, âŠ¥ R ğœ™, and âŠ¤ U ğœ™, respectively. A literal ğ‘™ is an atom ğ‘
or its negation Â¬ğ‘. We use ğ›¼ to denote propositional formulas, and
ğœ™,ğœ“ for LTL formulas.

LTL formulas are interpreted over infinite traces of propositional
interpretations of ğ´ğ‘ƒ. A model of a formula ğœ™ is an infinite trace
ğœŒ âˆˆ (2ğ´ğ‘ƒ )ğœ” (i.e., ğœŒ : N â†’ 2ğ´ğ‘ƒ ). Given an infinite trace ğœŒ, ğœŒ [ğ‘–] (âˆˆ
2ğ´ğ‘ƒ ) denotes the propositional interpretation at position ğ‘–; ğœŒğ‘– is the
prefix ending at position ğ‘–; and ğœŒğ‘– is the suffix starting at position ğ‘–.
Given an LTL formula ğœ™ and an infinite trace ğœŒ, we inductively
define the satisfaction relation ğœŒ |= ğœ™ (i.e., ğœŒ models ğœ™) as follows:

â€¢ ğœŒ |= âŠ¤;
â€¢ ğœŒ |= ğ‘ iff ğ‘ âˆˆ ğœŒ [0];
â€¢ ğœŒ |= Â¬ğœ™ iff ğœŒ Ì¸|= ğœ™;
â€¢ ğœŒ |= (ğœ™1 âˆ§ ğœ™2) iff ğœŒ |= ğœ™1 and ğœŒ |= ğœ™2;
â€¢ ğœŒ |= â—¦ğœ™ iff ğœŒ1 |= ğœ™;
â€¢ ğœŒ |= ğœ™1 U ğœ™2 iff there exists ğ‘— â‰¥ 0, ğœŒ ğ‘—

0 â‰¤ ğ‘– < ğ‘—, ğœŒğ‘– |= ğœ™1.

|= ğœ™2 and for all

The set of infinite traces that satisfy LTL formula ğœ™ is the lan-
guage of ğœ™, denoted as L (ğœ™) = {ğœŒ âˆˆ (2ğ´ğ‘ƒ )ğœ” | ğœŒ |= ğœ™ }. The two LTL
formulas ğœ™1 and ğœ™2 are semantically equivalent, denoted as ğœ™1 â‰¡ ğœ™2,
iff the languages of them are the same, i.e., L (ğœ™1) = L (ğœ™2). Given
two formulas ğœ™ and ğœ“ , we denote with ğœ™ â‡’ ğœ“ if all the models of
ğœ‘ are also models of ğœ“ .

A BÃ¼chi automaton is a tuple A = (2ğ´ğ‘ƒ , ğ‘„, Î”, ğ‘0, ğ¹ ) where
â€¢ 2ğ´ğ‘ƒ is the alphabet;
â€¢ ğ‘„ is the set of states;
â€¢ Î” : ğ‘„ Ã— 2ğ´ğ‘ƒ â†’ 2ğ‘„ is the transition function;
â€¢ ğ‘0 âˆˆ ğ‘„ is the initial state;
â€¢ ğ¹ âŠ† ğ‘„ is the set of accepting conditions.

A run ğ‘Ÿ of A on an infinite trace ğœŒ is an infinite sequence, ğ‘Ÿ =
ğ‘0, ğ‘1, . . . , ğ‘ğ‘–, . . . , such that ğ‘0 is the initial state of A and ğ‘ğ‘–+1 âˆˆ

Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Î”(ğ‘ğ‘–, ğœŒ [ğ‘–]) holds for ğ‘– â‰¥ 0. Moreover, a run ğ‘Ÿ is accepting iff there
exists an accepting state ğ‘“ âˆˆ ğ¹ such that ğ‘“ appears infinitely often.
An infinite trace ğœŒ is accepted by A iff there exists an accepting run
on ğœŒ. The set of infinite traces that accepted by A is the language
of A, denoted as L (A).

The following theorem states the well-known relationship be-

tween LTL formulas and the BÃ¼chi automata.

Theorem 1 ([13]). Given an LTL formula ğœ™, there exists a BÃ¼chi

automaton Ağœ™ such that L (ğœ™) = L (Ağœ™ ).

2.2 Goal-Conflict Analysis
In GORE, goals are used to describe the properties that the system
has to satisfy, and the domain properties to describe the properties
of the systemâ€™s operating environment. In this article, we call such
a set of goals and domain properties as a requirement scene.

Definition 1 (Requirement Scene). A requirement scene ğ‘† con-
sists of a set of domain properties ğ·ğ‘œğ‘š = {ğ‘‘1, ğ‘‘2, . . . , ğ‘‘ğ‘š } and a set
of goals ğº = {ğ‘”1, ğ‘”2, . . . , ğ‘”ğ‘› }, i.e., ğ‘† = ğ·ğ‘œğ‘š âˆª ğº.

In the process of building goals, inconsistencies may inevitably
occur in the scene. For example, the conflicts in the scene means that
it is impossible to construct a system that satisfies the goals and the
domain properties, which means ğ‘‘1 âˆ§ğ‘‘2 âˆ§Â· Â· Â·âˆ§ğ‘‘ğ‘š âˆ§ğ‘”1 âˆ§ğ‘”2 âˆ§Â· Â· Â·âˆ§ğ‘”ğ‘›
is unsatisfiable. In this article, we focus on a weaker but harder-to-
catch inconsistency, which is called divergence. We call a scene is
divergent if there is a boundary condition (BC) in it.

Definition 2 (Boundary Condition). An LTL formula ğœ™ is a
boundary condition of scene ğ‘†, if ğœ™ satisfies the following conditions:

(1) (logical inconsistency) ğ·ğ‘œğ‘š âˆ§ ğº âˆ§ ğœ™ is unsatisfiable,
(2) (minimality) ğ·ğ‘œğ‘š âˆ§ğºâˆ’ğ‘– âˆ§ ğœ™ is satisfiable for 1 â‰¤ ğ‘– â‰¤ |ğº |, and
(3) (non-triviality) ğœ™ (cid:46) Â¬ğº, i.e., ğœ™ is not semantically equivalent

to Â¬ğº,

where ğ·ğ‘œğ‘š = (cid:211)1â‰¤ğ‘– â‰¤ğ‘š ğ‘‘ğ‘– , ğº = (cid:211)1â‰¤ğ‘– â‰¤ğ‘› ğ‘”ğ‘– , and ğºâˆ’ğ‘– = (cid:211)1â‰¤ ( ğ‘—â‰ ğ‘–) â‰¤ğ‘› ğ‘”ğ‘— .
Intuitively, a BC is a situation in which the goals can not be
satisfied as a whole due to the potential divergence between the
goals [32]. That is, in the situation of BC, the goals are logical
inconsistency. The minimality condition means that when any one
of the goals is removed, the boundary condition no longer causes
the inconsistency among the remaining goals. The non-triviality
means that the boundary condition should not be the negation of
the goal, which simply means trivial situations.

In this paper, we mix-use the meanings of symbol ğº and
ğ·ğ‘œğ‘š. When ğº is supposed to be an LTL formula, it represents the
logical and result of the goals, otherwise it represents the set of
goals, which is the same for ğ·ğ‘œğ‘š and ğºâˆ’ğ‘– .

According to the identify-assess-control methodology to resolve
inconsistencies, we first identify the BCs that lead to inconsistencies,
then assess and prioritize the identified BCs according to their
likelihood and severity, and finally resolve the inconsistences by
providing appropriate countermeasures. In order to assess the BC
more effectively, the generality metric and contrasty metric are used
to reduce the number of BCs during the identifying process.

Definition 3 (Generality Metric [6]). Given two different BCs

ğœ™1, ğœ™2 of the scene ğ‘†, ğœ™1 is more general than ğœ™2 if ğœ™2 â‡’ ğœ™1.

From the definition above, a more general BC can capture all
the divergences that can be captured by the less general ones. For
requirements engineers, it is more useful to assess the most general
BCs to detect the cause of divergence, rather than assessing the less
general ones that capture only partial situations.

Definition 4 (Witness, Contrasty Metric [26]). Let ğ‘“ be an
LTL formula and ğœ™ a BC of the given scene ğ‘†. ğ‘“ is a witness of ğœ™ iff
ğœ™ âˆ§ Â¬ğ‘“ is not a BC of ğ‘†.

The contrasty metric is another metric that can reduce the num-
ber of BCs. Similar to the general metric, if a BC ğœ™1 is the witness of
another one ğœ™2, ğœ™1 is considered as the â€œbetterâ€ BC than ğœ™2. Since
ğœ™2 âˆ§ Â¬ğœ™1 is not a BC, it means that after removing the divergence
captured by ğœ™1, ğœ™2 is no longer a BC, i.e., ğœ™1 includes the key part
of ğœ™2 which causes the divergence. For two BCs that are witnesses
to each other, it is always better to choose the BC with the shorter
formula length, as the conflict analysis would become easier. Com-
pared to the generality metric, the contrasty metric can reduce
more BCs [26], so that the requirement engineers can resolve the
divergence more efficiently.

3 MOTIVATING EXAMPLE
In this section, we illustrate the shortcomings of the BCs generated
by the current methods through a widely used example, i.e., the goal-
oriented requirement case of a simplified Mine Pump Controller
(MPC) [20]. This actually reveals the flaws of the current definition
of BC. Therefore, we give more stringent restrictions on BC and
propose our solutions.

MPC describes the behavior of a water pump controller system
in a mine. MPC has two sensors, one is used to sense the water
level in the mine, and the other is used to sense the presence of
methane in the pump environment. The propositional variable â„ is
used to represent the situation that the water reaches a high level,
ğ‘š is used to represent the presence of methane in the environment,
and ğ‘ to represent that the system turns the pump on. The goals
that the MPC expects to achieve are as follows:

Goal: ğ‘ğ‘œ ğ¹ğ‘™ğ‘œğ‘œğ‘‘ğ‘–ğ‘›ğ‘” [ğ‘”1]

FromalDef: â–¡(â„ â†’ â—¦ğ‘)

InfromalDef: ğ‘Š â„ğ‘’ğ‘› ğ‘¡â„ğ‘’ ğ‘¤ğ‘ğ‘¡ğ‘’ğ‘Ÿ ğ‘™ğ‘’ğ‘£ğ‘’ğ‘™ ğ‘–ğ‘  â„ğ‘–ğ‘”â„, ğ‘¡â„ğ‘’ ğ‘ ğ‘¦ğ‘ ğ‘¡ğ‘’ğ‘š ğ‘ â„ğ‘œğ‘¢ğ‘™ğ‘‘

ğ‘¡ğ‘¢ğ‘Ÿğ‘› ğ‘œğ‘› ğ‘¡â„ğ‘’ ğ‘ğ‘¢ğ‘šğ‘.

Goal: ğ‘ğ‘œ ğ¸ğ‘¥ğ‘ğ‘™ğ‘œğ‘ ğ‘–ğ‘œğ‘› [ğ‘”2]

FromalDef: â–¡(ğ‘š â†’ â—¦Â¬ğ‘)

InfromalDef: ğ‘Š â„ğ‘’ğ‘› ğ‘¡â„ğ‘’ğ‘Ÿğ‘’ ğ‘–ğ‘  ğ‘šğ‘’ğ‘¡â„ğ‘ğ‘›ğ‘’ ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘’ğ‘›ğ‘£ğ‘–ğ‘Ÿğ‘œğ‘›ğ‘šğ‘’ğ‘›ğ‘¡, ğ‘¡â„ğ‘’

ğ‘ğ‘¢ğ‘šğ‘ ğ‘ â„ğ‘œğ‘¢ğ‘™ğ‘‘ ğ‘ğ‘’ ğ‘¡ğ‘¢ğ‘Ÿğ‘›ğ‘’ğ‘‘ ğ‘œ ğ‘“ ğ‘“ .

First of all, ğ‘”1 and ğ‘”2 do not conflict with each other. They are two
goals that can be met at the same time in some situations, for ğ‘”1 âˆ§ğ‘”2
is satisfiable. But when ğœ™ = â„ âˆ§ğ‘š occurs, the goals become logically
inconsistent. In this certain state, the system detects the presence of
methane in the environment while detecting the high water level.
In this situation, the system cannot meet both two requirements

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

â„ âˆ§ ğ‘š, ğ‘ âˆ¨ Â¬ğ‘, (1)ğœ” , which is called synthesis product, and generate
the below automaton in Figure 1. For trace ğœŒ, we can clearly observe
that when event â„ âˆ§ ğ‘š occurs, the goals will diverge for variable ğ‘.

4 IDENTIFYING BOUNDARY CONDITIONS

BASED ON LTL SYNTAX

In this section, we present an efficient method to compute boundary
conditions that leverages LTL syntax. Starting from the definition
of the problem, we discuss the conditions that need to be met for
the existence of BC, and give the algorithm to solve BC if it exists.

4.1 Conditions for the Existence of BC

Property 1. If ğœ™ is a boundary condition, then ğœ™ â‡’ Â¬(ğ·ğ‘œğ‘š âˆ§ğº).

It can be directly derived from the logical inconsistency condition.
Since ğ·ğ‘œğ‘š âˆ§ ğº âˆ§ ğœ™ is unsatisfiable, so ğœ™ implies Â¬(ğ·ğ‘œğ‘š âˆ§ ğº).
Property 1 means that if an LTL formula ğ‘“ does not imply Â¬(ğ·ğ‘œğ‘š âˆ§
ğº), ğ‘“ can not be a BC. From the perspective of requirements, the
divergence captured by BC must be against the requirement ğ·ğ‘œğ‘š âˆ§
ğº. And if we consider the generality metric for BCs reduction,
Â¬(ğ·ğ‘œğ‘š âˆ§ ğº) shall be the most general BC if it is. So it is reasonable
to take Â¬(ğ·ğ‘œğ‘š âˆ§ ğº) as a potential BC, and see if it can satisfy the
conditions.

For the convenience of description, we call Â¬(ğ·ğ‘œğ‘š âˆ§ ğº) NGD
(the Negation of Domain properties and Goals) below. And
to prove whether NGD is a BC, we need to introduce the definitions
of extra goal and influential domain properties as below.

Definition 5 (Extra Goal). For a goal ğ‘”ğ‘– in the scene ğ‘†, ğ‘”ğ‘– is an

extra goal if (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– ) â‡’ ğ‘”ğ‘– .

In Definition 5, ğ·ğ‘œğ‘š âˆ§ğºâˆ’ğ‘– implies ğ‘”ğ‘– is equivalent to that ğ·ğ‘œğ‘š âˆ§
ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘– is unsatisfiable. The product automata of all domain
properties and goals except ğ‘”ğ‘– , i.e., A (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– ), contains the
expected event traces of scene ğ‘†, and the unsatisfiability means
there is no trace against ğ‘”ğ‘– . Intuitively, the goals in the scene have
already deduced the goal ğ‘”ğ‘– before including ğ‘”ğ‘– . Therefore, adding
and removing ğ‘”ğ‘– will not affect the goalsâ€™ expectation of the system.
But we may still take it as a goal for the purpose of prompting the
requirements engineer. So we call ğ‘”ğ‘– an extra goal.

Definition 6 (Influential Domain Properties). A scene ğ‘† has
influential domain properties if the domain properties set ğ·ğ‘œğ‘š is not
empty and ğº â‡’ ğ·ğ‘œğ‘š does not hold.

In contrary to Definition 5, the influential domain properties could
further restrict the expected system behaviors and have influence
on the system besides goals. So the automaton composed of ğº
should not already conform to the domain properties.

Theorem 2. If the scene ğ‘† has extra goals, then ğ‘† has no BC.

Proof. Assume ğ‘”ğ‘˜ is the extra goal in ğ‘†. If there is a BC ğ‘ğ‘ of ğ‘†,
according to the minimality condition, it holds that ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§
ğ‘ğ‘ is satisfiable for every 1 â‰¤ ğ‘– â‰¤ |ğº |. Now let ğ‘– = ğ‘˜, because
(ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘˜ ) â‡’ ğ‘”ğ‘˜ is true, we have that ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘˜ = ğ·ğ‘œğ‘š âˆ§ ğº.
Therefore, ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘˜ âˆ§ ğ‘ğ‘ = ğ·ğ‘œğ‘š âˆ§ ğº âˆ§ ğ‘ğ‘, which is unsatisfiable:
the contradiction occurs. As a result, there is no BC for ğ‘† if ğ‘† has
â–¡
extra goals.

Figure 1: An illustration of the ideas on how to compute a
meaningful BC for the MPC example. The automaton above
is constructed from the formula Â¬(ğ‘”1 âˆ§ ğ‘”2), in which each
of the two (infinite) traces falsifies one of the goal (ğ‘”1 or ğ‘”2).
Meanwhile, the automaton below represents the synthesis
product (automaton) of the two traces in the one above.

at the same time, that is to say, ğœ™ âˆ§ ğ‘”1 âˆ§ ğ‘”2 is unsatisfiable. But if
we ignore any one of the goals, the system can meet the remaining
goal, formally, ğœ™ âˆ§ ğ‘”1 and ğœ™ âˆ§ ğ‘”2 are satisfiable. Therefore, â„ âˆ§ ğ‘š is
a BC in the scene ğ‘†ğ‘€ğ‘ƒğ¶ .

In previous literature, according to the strategy for reducing
the number of BCs, ğœ™1 = (cid:94)(â„ âˆ§ ğ‘š) is considered to be a BC that
describes a more general situation than ğœ™. But by using the Syn-
tacBC method in this article, we can solve that ğœ™2 = (cid:94)Â¬(â„ â†’
â—¦ğ‘) âˆ¨ Â¬(ğ‘š â†’ â—¦Â¬ğ‘) and ğœ™3 = Â¬(â„ â†’ â—¦ğ‘) âˆ¨ (cid:94)Â¬(ğ‘š â†’ â—¦Â¬ğ‘) are
two BCs at an extremely fast speed. Moreover, according to the
reduction strategy (whether the generality metric or the contrasty
metric), ğœ™2 and ğœ™3 are considered to be the more worth-keeping
BCs than ğœ™1, for they describe the even more general divergence
situations. And our BCs with this strong generality also have the
theoretical basis, indicating that it is difficult to find a BC that is
more general than them.

By observing ğœ™2 and ğœ™3, we can find that they are obtained from
making some mutations on Â¬(ğ‘”1 âˆ§ğ‘”2). Although they meet the non-
triviality condition of BC, it is difficult to explain why Â¬(ğ‘”1 âˆ§ ğ‘”2) is
considered trivial but they are not. And because of this suspiciously
trivial nature, it is actually difficult to understand ğœ™2 and ğœ™3, that
is, what event causes the divergence indeed.

Here we take Â¬(ğ‘”1 âˆ§ ğ‘”2) as an example and try to analyze it as
a BC, it can be transformed to the automaton above in Figure 1.
Intuitively, a word accepted by the automaton should be a sequence
of events leading to divergence of goals, however it is not. For ex-
ample, the two traces ğœŒ1 = ğ‘š, ğ‘, (1)ğœ” and ğœŒ2 = â„, Â¬ğ‘, (1)ğœ” accepted
by the automaton only violate one goal respectively1. The ideal
BC we really want, like â„ âˆ§ ğ‘š, is implicitly present in these traces.
This leads to the fact that computing such a BC does not help the
engineers.

After theoretically studying the conditions of BC, We believe
that the non-triviality condition is not enough to ensure that the
solved BCs have a clear meaning. We therefore define a new form
of BC which is transformed from a run of an automaton. Intuitively,
our approach is to fuse together two conflicting traces. For example,
for the two traces ğœŒ1 and ğœŒ2, we fuse them into the trace ğœŒ =

1 (1)ğœ” represents the trace with infinitely many 1 (true).

Â¬ğ‘ğ‘ğ‘šâ„âˆ§ğ‘šâ„ğ‘âˆ¨Â¬ğ‘111Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Theorem 2 states a prerequisite for the existence of BC: there is
no extra goal in ğ‘†. The existence of extra goals makes the logical
inconsistency and minimality conditions unable to be met at the
same time. After providing this conditions for the existence of BC,
we propose the first way to identify the BC in this article.

Theorem 3. If the scene ğ‘† with influential domain properties has

no extra goal, then ğ‘ğºğ· is a BC of ğ‘†.

Proof. To prove this theorem, we check whether NGD can sat-

isfy all three conditions.

â€¢ logical inconsistency: NGD satisfy Property 1, so it meets the

condition.

â€¢ minimality: If the formula ğœ™ = ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ ğ‘ğºğ· is satisfi-
able for each ğ‘–, NGD can be the boundary condition. After
expanding into the disjunctive normal form (DNF), ğœ™ is equiv-
alent to (cid:212)1â‰¤ğ‘¥ â‰¤ğ‘š (ğ·ğ‘œğ‘š âˆ§ğºâˆ’ğ‘– âˆ§Â¬ğ‘‘ğ‘¥ ) âˆ¨(cid:212)1â‰¤ğ‘¦ â‰¤ğ‘› (ğ·ğ‘œğ‘š âˆ§ğºâˆ’ğ‘– âˆ§
Â¬ğ‘”ğ‘¦), which is equivalent to (cid:212)1â‰¤ğ‘¥ â‰¤ğ‘š (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘‘ğ‘¥ ) âˆ¨
(cid:212)1â‰¤ğ‘¦ â‰¤ğ‘› (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘¦) âˆ¨ (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘– ). Also,
(cid:212)1â‰¤ğ‘¥ â‰¤ğ‘š (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘‘ğ‘¥ ) âˆ¨ (cid:212)1â‰¤ğ‘¦ â‰¤ğ‘› (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘¦)
equals to false, because ğ‘‘ğ‘¥ âˆˆ ğ·ğ‘œğ‘š and ğ‘”ğ‘¦ âˆˆ ğºâˆ’ğ‘– must be
true. So ğœ™ = ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘– is true. Finally, since ğ‘† has
no extra goal, there is no ğ‘”ğ‘– such that ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– â‡’ ğ‘”ğ‘– , so
ğœ™ = ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘– is satisfiable.

â€¢ non-triviality: From the definition, ğ‘ğºğ· = Â¬(ğ·ğ‘œğ‘š âˆ§ ğº) =
Â¬ğ·ğ‘œğ‘š âˆ¨ Â¬ğº. Then ğ‘ğºğ· â‰¡ ğº is true implies that (Â¬ğ·ğ‘œğ‘š âˆ¨
Â¬ğº) â‡’ Â¬ğº is true (The other direction is true straightfor-
ward.), which implies (Â¬ğ·ğ‘œğ‘š âˆ¨ Â¬ğº) âˆ§ ğº = Â¬ğ·ğ‘œğ‘š âˆ§ ğº is
unsatisfiable. However, it is contract to the fact that ğ‘† has
influential domain properties, i.e., Â¬ğ·ğ‘œğ‘š âˆ§ ğº is satisfiable
as ğº can not imply ğ·ğ‘œğ‘š. Therefore, Â¬ğº (cid:46) ğ‘ğºğ· is true.

â–¡

We have obtained the single boundary condition that can reduce
any other BCs through the generality metric, which means ğ‘ğºğ·
catches all the possible divergences. This is also in line with the
meaning of the LTL formula representing ğ‘ğºğ·.

Although ğ‘ğºğ· does not violate the non-triviality condition, it is
obviously more trivial than Â¬ğº, for Â¬ğº â‡’ ğ‘ğºğ· is true. As a result,
the divergence described by ğ‘ğºğ· is too general and we should
generate the BC ğœ™ to satisfy ğœ™ â‡’ Â¬ğº. The method to generate such
BCs will be described in next subsection.

4.2 Generation of BCs
In this section, we will narrow the scope of BC into Â¬ğº by the
contrasty metric. Then we introduce the algorithm for generating
BCs by further manipulating Â¬ğº on the syntactical level. We first
show the theorem below to describe a â€œbetterâ€ BC than NGD.

Theorem 4. Let ğœ™ be a BC of the scene ğ‘† = (ğº, ğ·ğ‘œğ‘š) and Â¬ğœ™ â‡’
ğ‘”ğ‘¥ for some 1 â‰¤ ğ‘¥ â‰¤ |ğº |. Then ğœ™ is a witness of ğ‘ğºğ· = Â¬(ğ·ğ‘œğ‘š âˆ§ğº).

Proof. We prove the theorem by showing that ğœ“ = ğ‘ğºğ· âˆ§ Â¬ğœ™
is not a BC of ğ‘†, because ğœ“ does not satisfy the minimality condition
of Definition 2. In fact,
ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ ğœ“

= ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ (Â¬(ğ·ğ‘œğ‘š âˆ§ ğº) âˆ§ Â¬ğœ™)
= ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğº âˆ§ Â¬ğœ™

= ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”ğ‘– âˆ§ Â¬ğœ™
Since Â¬ğœ™ â‡’ ğ‘”ğ‘¥ for some 1 â‰¤ ğ‘¥ â‰¤ |ğº | is true, so Â¬ğœ™ âˆ§ Â¬ğ‘”ğ‘¥ is unsat-
isfiable. Let ğ‘– = ğ‘¥ and we know that ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘¥ âˆ§ğœ“ is unsatisfiable,
â–¡
which violates the minimality condition of Definition 2.

Theorem 4 indicates that, for any BC ğœ™ satisfying ğœ™ â‡’ ğ‘”ğ‘¥ for
some 1 â‰¤ ğ‘¥ â‰¤ |ğº |, ğœ™ is a better BC than ğ‘ğºğ·, according to Defi-
nition 4. Such observation inspires us to construct such ğœ™ as the
target BC. In order to achieve that, we introduce at first the concept
of special case as follows.

Definition 7 (Special Case). Let ğœ™ and ğœ“ be LTL formulas. ğœ™ is

a special case of ğœ“ , if (ğœ™ â‡’ ğœ“ ) and (ğœ“ â‡ ğœ™).

Definition 7 can be understood more clearly from the perspective
of automata. For ğœ™ being a special case of ğœ“ , we expect ğ´ğœ“ is a part
of Ağœ™ , i.e., traces accepted by Ağœ“ should be accepted by ğ´ğœ™ as well.
Note that the negation of the set of goals, i.e., Â¬ğº can be written
as a disjunctive form of Â¬ğ‘”1 âˆ¨ Â¬ğ‘”2 âˆ¨ Â· Â· Â· âˆ¨ Â¬ğ‘”ğ‘›. Now we have the
following definition.

Definition 8 (Syntactical Substitution). Let ğº = {ğ‘”ğ‘–

| 1 â‰¤
ğ‘– â‰¤ |ğº |} be the set of goals. The notation Â¬ğº (ğ‘–,ğœ“ ) is defined to
represent the formula Â¬ğ‘”1 âˆ¨Â¬ğ‘”2 âˆ¨. . .âˆ¨Â¬ğ‘”ğ‘–âˆ’1 âˆ¨ğœ“ âˆ¨Â¬ğ‘”ğ‘–+1 âˆ¨. . .âˆ¨Â¬ğ‘” |ğº |.
Informally speaking, Â¬ğº (ğ‘–,ğœ“ ) represents the formula by substi-
tuting Â¬ğ‘”ğ‘– with ğœ“ in the formula Â¬ğº. Then we have the following
theorem.

Theorem 5. Let ğœ™ = Â¬ğº (ğ‘–,ğœ“ ) where ğœ“ is a special case of Â¬ğ‘”ğ‘– ,

and ğœ™ is a BC if ğœ“ âˆ§ ğ·ğ‘œğ‘š âˆ§ ğº is satisfiable.

Proof. The potential BC ğœ™ is Â¬ğ‘”1 âˆ¨ Â· Â· Â· âˆ¨ ğœ“ âˆ¨ Â· Â· Â· âˆ¨ Â¬ğ‘”ğ‘› after
replacing Â¬ğ‘”ğ‘¥ by ğœ“ , (ğœ“ â‡’ ğ‘”ğ‘¥ ) and (ğ‘”ğ‘¥ â‡ ğœ“ ). And now we prove
ğœ™ can satisfy all three conditions of Definition 2.

â€¢ logical inconsistency: From Definition 8, ğœ™ â‡’ Â¬ğº is true.

Therefore, ğ·ğ‘œğ‘š âˆ§ ğº âˆ§ ğœ™ is unsatisfiable.

â€¢ minimality: We now prove ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ ğœ™ is satisfiable for

each 1 â‰¤ ğ‘– â‰¤ |ğº |. For the situation of ğ‘– â‰  ğ‘¥, (cid:212)1â‰¤ ğ‘— â‰¤ğ‘›,ğ‘—â‰ ğ‘–,ğ‘—â‰ ğ‘¥ (ğ·ğ‘œğ‘šâˆ§
ğºâˆ’ğ‘– âˆ§Â¬ğ‘”ğ‘— )âˆ¨(ğ·ğ‘œğ‘šâˆ§ğºâˆ’ğ‘– âˆ§Â¬ğ‘”ğ‘– )âˆ¨(ğ·ğ‘œğ‘šâˆ§ğºâˆ’ğ‘– âˆ§ğœ“ ) is satisfiable,
because the pruned scenario guaranteed that ğ·ğ‘œğ‘šâˆ§ğºâˆ’ğ‘– âˆ§Â¬ğ‘”ğ‘–
is always satisfiable. And in the situation of ğ‘– = ğ‘¥, the result
of (cid:212)1â‰¤ ğ‘— â‰¤ğ‘›,ğ‘—â‰ ğ‘– (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ Â¬ğ‘”ğ‘— ) âˆ¨ (ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ ğ‘ ) is de-
cided by ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ ğœ“ . So if ğœ“ âˆ§ ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– is satisfiable,
the condition of minimality is satisfied.

â€¢ non-triviality: ğœ™ is assured to not be semantically equal to
Â¬ğº, because it is just obtained by changing the semantics of
Â¬ğº, or more accurately, by narrowing the scope of Â¬ğº.

â–¡

Definition 8 conducts our first approach to identify boundary
conditions and Theorem 5 shows the guarantee of correctness. We
replace one item (Â¬ğ‘”ğ‘– ) in Â¬ğº with its special case ğœ“ . If the special
case satisfies the condition ğœ“ âˆ§ ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– , then we have already
generated a BC, and there is no need to check whether it satisfies
the conditions.

According to the contrasty metric, all the filtered BCs should
imply Â¬ğº, which allow the generated BCs firstly meet the logical-
inconsistency condition. Secondly, the constructed special cases
should make the minimality condition satisfied. Finally, by the

substitution on the syntax of Â¬ğº, we also make BC satisfy the
non-triviality condition.

Finally, we make the following statement to show the effec-
tiveness of SyntacBC, which can be guaranteed by Theorem 4,
Definition 8 and Theorem 5.

Remark. The BCs computed from SyntacBC are â€œbetterâ€ than

NGD, according to Definition 4.

4.3 Implementation
In this section, we describe the detailed implementation of the BC
quick generation algorithm that is based on Definition 8.

Algorithm 1 SyntacBC: Computing BC based on Syntactical Sub-
stitution

1: procedure SyntacBC( ğ‘†ğ‘ğ‘’ğ‘›ğ‘’ ğ‘†)
2:

ğµğ¶ â† âˆ…
if ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğºğ‘œğ‘ğ‘™ğ‘–ğ‘›(ğ‘†) then

3:

4:

5:

6:

7:

8:

9:

10:

11:

return ğµğ¶

for each ğ‘”ğ‘– âˆˆ ğ‘”ğ‘œğ‘ğ‘™ğ‘  do

ğ‘ ğ‘ = ğºğ‘’ğ‘¡ğ‘†ğ‘ğ‘’ğ‘ğ‘–ğ‘ğ‘™ğ‘ğ‘ğ‘ ğ‘’ğµğ‘¦ğ‘‡ ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ (Â¬ğ‘”ğ‘–, ğ‘†)
if ğ‘†ğ´ğ‘‡ (ğ‘ ğ‘ âˆ§ ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– ) then

ğºâˆ’ğ‘– â† (cid:211)ğ‘—â‰ ğ‘–
1â‰¤ ğ‘— â‰¤ğ‘› ğ‘”ğ‘—
ğµğ¶ â† ğµğ¶ âˆª {ğ‘ ğ‘ âˆ¨ Â¬ğºâˆ’ğ‘– }
ğµğ¶ â† ğ¶ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘ğ‘ ğ‘¡ğ‘¦ğ‘€ğ‘’ğ‘¡ğ‘Ÿğ‘–ğ‘ğ‘…ğ‘’ğ‘‘ğ‘¢ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(ğµğ¶)
return ğµğ¶

Algorithm 1 details the execution process of SyntacBC. It accepts
a scene ğ‘† as the input and outputs the reduced BCs. In line 3, if we
find that there are extra goals in ğ‘†, then the program can return
empty directly, for no BC is in ğ‘†.

In line 6, for each ğ‘”ğ‘– in the goal set, we find the special case of
Â¬ğ‘”ğ‘– . We use the method of formula templates to get special cases,
which is implemented in the ğºğ‘’ğ‘¡ğ‘†ğ‘ğ‘’ğ‘ğ‘–ğ‘ğ‘™ğ‘ğ‘ğ‘ ğ‘’ğµğ‘¦ğ‘‡ ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ function
in the algorithm. Table 1 lists all the corresponding special cases
according to the LTL syntaxs. For example, the special case of ğ‘ âˆ¨ ğ‘
can be ğ‘ or ğ‘. However, when the semantics represented by the
formula itself are very limited, other atomic propositions are needed
for further reduction. For example, when the Â¬ğ‘”ğ‘– formula is ğ‘ âˆ§ ğ‘,
we find an atomic proposition ğ‘ that exists in ğºâˆ’ğ‘– but does not exist
in ğ‘”ğ‘– , and let the special case be ğ‘ âˆ§ ğ‘ âˆ§ ğ‘.

Table 1: LTL formula and the corresponding special cases

Â¬ğ‘”ğ‘–
ğ‘¡ğ‘¡
ğ‘
Â¬ğ‘
ğ‘ âˆ§ ğ‘

special case
ğ‘
ğ‘ âˆ§ ğ‘
Â¬ğ‘ âˆ§ ğ‘
ğ‘ âˆ§ ğ‘ âˆ§ ğ‘

Â¬ğ‘”ğ‘–
ğ‘ âˆ¨ ğ‘
â–¡ğ‘
ğ‘ğ‘ˆ ğ‘
ğ‘ğ‘…ğ‘

special case
ğ‘, ğ‘
â–¡ğ‘ âˆ§ ğ‘
ğ‘, ğ‘ âˆ§ â—¦ğ‘
ğ‘ âˆ§ â—¦ğ‘, ğ‘

Then we check whether the obtained special case satisfies that
ğ‘ ğ‘âˆ§ğ·ğ‘œğ‘šâˆ§ğºâˆ’ğ‘– is satisfiable at line 7. For ğ‘ ğ‘ that meets the conditions,
we can directly construct one BC ğ‘ ğ‘ âˆ¨ Â¬ğºâˆ’ğ‘– . Finally, we use the
contrasty metric to reduce the redundant BCs.

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

4.4 Results and Evaluation
In this section, we evaluated our SyntacBC method and compared
it with the previous method.

Setups. We built our BC solver according to Algorithm 1.
4.4.1
We used Spot [8] as the LTL satisfiability (LTL-SAT) solver. It first
translates the LTL formula to the corresponding automaton, and
then checks whether the automaton is empty to determine the
satisfiability of formula. All experiments were carried out on a
system with AMD Ryzen 9 5900HX and 16 GB memory under
Linux WSL (Ubuntu 20.04).

4.4.2 Benchmarks. We compare and evaluate our method on the
15 different cases introduced in [6]. We compare our method with
JFc (Joint framework to interleave filtering based on the contrast
metric) proposed in [26], which is the state-of-art BC solver.

4.4.3 Evaluation. Table 2 shows the comparison between our Syn-
tacBC method and JFc on the 15 requirement cases.

The way we compared the JFc to SyntacBC is described as fol-
lows: we run the solvers, JFc and SyntacBC, on the same case. |ğµğ¶ |
represents the number of solved ğµğ¶ before filtering. |ğµğ¶ğ‘ | repre-
sents the number of BCs after filtering by using the contrasty metric,
and time consumption for solving and filtering of two solvers is
represented by ğ‘¡. For JFc, we run the learning algorithm 10 times,
#ğ‘ ğ‘¢ğ‘. represents the number of learning times that BC can be suc-
cessfully solved, so the |ğµğ¶ğ‘ |, ğ‘¡ represents the average result of 10
times run.

Both tools output a set of BCs, we let {ğµğ¶ ğ‘— } as the set solved by
JFc and {ğµğ¶ğ‘  } by SyntacBC, we use the contrasty metric introduced
in the previous study to further reduce the number of BCs in the
set {ğµğ¶ ğ‘— , ğµğ¶ğ‘  }. Column ğ‘(coverage) represents what percentage of
BCs in set {ğµğ¶ ğ‘— } will be computed to be redundant because of the
BCs in set {ğµğ¶ğ‘  }. In detail, let ğ‘ğ‘ ğ‘— and ğ‘ğ‘ğ‘  be one BC in set {ğµğ¶ ğ‘— }
and {ğµğ¶ğ‘  } correspondingly, then ğ‘ equals to (the number of ğ‘ğ‘ğ‘  is
the witness of ğ‘ğ‘ ğ‘— but ğ‘ğ‘ ğ‘— is not that of ğ‘ğ‘ğ‘  )/(the number of ğ‘ğ‘ ğ‘— ).
First of all, the SyntacBC method has significant advantages in
time cost. On larger scale cases, a certain time cost comes from using
Spot to perform LTL-SAT check, but overall, SyntacBC achieves a
>1000X speed-up than JFc.

For the last two examples LB and LC, because there are extra
goals in the examples, our method judges that there is no BC in
them according to Theorem 2. But JFc solves the BC out incorrectly
because of the bug of the LTL-SAT checker it uses.

Notably, the ğ‘ğ‘ğ‘  obtained by the SyntacBC is always the
witness of the ğ‘ğ‘ ğ‘— obtained by the JFc, which means that ğ‘ğ‘ğ‘  can
capture all the divergences captured by ğ‘ğ‘ ğ‘— . And column ğ‘(coverage)
shows that, in the cases of larger scale, it is difficult for JFc to solve
ğ‘ğ‘ ğ‘— , which can not be filtered by ğ‘ğ‘ğ‘  . But in all cases, ğ‘ğ‘ğ‘  cannot be
filtered out.

4.5 Discussion
The results prove the superiority of SyntacBC in speed and the
quality of the solved BCs. The advantage on time cost benefits
from our theoretical-based method, which significantly reduces
the number of calls to the LTL-SAT solver compared to the genetic
algorithm-based method. The BCs solved by the SyntacBC method
is difficult to be filtered because we construct BC according to the

Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Table 2: Comparison on the performance beween JFc and SyntacBC.

case

RP1
RP2
Ele
TCP
AAP
MP
ATM
RRCS
Tel
LAS
PA
RRA
SA
LB
LC

|ğµğ¶ğ‘ |
1.5
1.5
2.9
1.8
2.4
2
2
0.9
0.2
0
0.1
1.1
0.2
0.4
1

JFc
ğ‘¡ (ğ‘ )
851.6
823.5
1610.4
1510.1
1875.9
1318.2
1908.4
43.5
223.6
201.4
703.2
1653.6
749
1809.8
4150.2

#ğ‘ ğ‘¢ğ‘.
9
9
10
8
10
9
10
9
9
0
1
9
2
4
10

|ğµğ¶ |
4
4
4
4
4
4
4
3
4
10
12
6
7
0
0

SyntacBC
|ğµğ¶ğ‘ |
2
1
2
2
1
1
1
2
2
4
3
3
2
0
0

ğ‘¡ (ğ‘ )
0.002
0.003
0.003
0.004
0.006
0.005
0.006
0.008
0.007
0.020
0.144
0.040
0.075
0.140
3.580

ğ‘
0.467
0.733
0.81
1
0.875
0.85
0.8
0
1
1
1
1
1
n/a
n/a

SemanticBC
|ğµğ¶ğ‘¤ |
0
0
0
0
0
10
0
0
0
0
176
42
93
0
436

ğ‘¡ (ğ‘ )
0.003
0.006
0.005
0.010
0.023
0.050
0.013
0.036
0.075
0.047
37.379
6.260
8.134
2.128
283.639

|ğµğ¶ğ‘¡ |
1
2
2
5
10
5
0
0
6
1
262
0
1
13
0

definition of BC, and ensure that it satisfies the definition to a lesser
extent.

Even though SyntacBC is very efficient to solve BCs, when we
want to understand what events implied by those BCs can lead
to the divergence of goals, we find it very difficult to interpret
them. The reason is because these BCs can be thought of as simply
combining the negation of each goal with the â€˜âˆ¨â€™ operator.

By studying the definition of BC and results, we believe that
the non-triviality condition is not enough to ensure that the solved
BC has a definite meaning. After observing the BCs sovled by
two methods, we found that some BCs obtained by the genetic
algorithm-based method are easy to understand. So in Section 5,
by summarizing their common properties in form of formula, we
define a new form of BCs and design a new method to sovle them.

5 IDENTIFYING BOUNDARY CONDITIONS

BASED ON LTL SEMANTICS

In this section, we describe how to confirm BC with definite mean-
ing between two goals, which leverages the semantic information of
LTL formulas. The approach is named SemanticBC. We first reduce
the problem of solving BC into a set of two goals, then we define
the trace formula be the form of meaningful BC and the method
of Synthesis of trace formula to solve BC. Section 5.1 presents the
theoretic foundations of SemanticBC, Section 5.2 gives the detailed
implementation, and Section 5.3 shows the experimental results of
our method on the benchmarks.

5.1 SemanticBC
We first show the fact in Theorem 6 that the ğµğ¶ computation for
the goal set ğº, whose size is greater than 2, can be always reducible
to that for the goal set ğº â€² whose size is exactly 2.

Theorem 6 (ğµğ¶ Reduction). Let ğº be a goal set with |ğº | > 2
and ğ·ğ‘œğ‘š be a domain set. Then ğœ™ is a BC of ğº under ğ·ğ‘œğ‘š implies

that there is ğº â€² âŠ† ğº with |ğº â€²| = 2 and ğœ™ is the BC of ğº â€² under
ğ·ğ‘œğ‘š âˆª (ğº\ğº â€²).

Proof. We prove by the induction over the size of ğº.
(1) Basically, let ğ‘˜ = |ğº | > 2 and we know ğœ™ is a BC of ğº.
Therefore, we have 1) ğ·ğ‘œğ‘š âˆ§ ğº âˆ§ ğœ™ is unsatisfiable; and 2)
ğ·ğ‘œğ‘š âˆ§ ğºâˆ’ğ‘– âˆ§ ğœ™ is satisfiable for each 1 â‰¤ ğ‘– â‰¤ ğ‘›; and 3) ğœ™ is
not syntactically equivalent to Â¬ğº.

(2) Inductively, for ğº â€² âŠ† ğº with |ğº â€²| = ğ‘˜ âˆ’ 1 â‰¥ 2, we prove that
ğœ™ is a BC of ğº â€² under ğ·ğ‘œğ‘š âˆª (ğº\ğº â€²). Assume ğº\ğº â€² = {ğ‘”ğ‘— },
i.e., ğº â€² is acquired by removing ğ‘”ğ‘— (1 â‰¤ ğ‘— â‰¤ |ğº |) from ğº. As a
result, ğº â€² = ğºâˆ’ğ‘— . From the assumption hypothesis, we have
that 1) (ğ·ğ‘œğ‘š âˆ§ğ‘”ğ‘— ) âˆ§ğºâˆ’ğ‘— âˆ§ ğœ™ = ğ·ğ‘œğ‘š âˆ§ğº âˆ§ ğœ™ is unsatisfiable;
and 2) (ğ·ğ‘œğ‘šâˆ§ğ‘”ğ‘— )âˆ§ğºâˆ’ğ‘— âˆ’ğ‘– âˆ§ğœ™ = ğ·ğ‘œğ‘šâˆ§ğºâˆ’ğ‘– âˆ§ğœ™ is satisfiable for
1 â‰¤ ğ‘– â‰¤ |ğº | and ğ‘– â‰  ğ‘—; and 3) ğœ™ is not syntactally equivalent to
Â¬ğºâˆ’ğ‘— , as it cannot be a BC of ğº under ğ·ğ‘œğ‘š. From Definition
2, ğœ™ is a BC of ğº â€² under the domain ğ·ğ‘œğ‘š âˆª (ğº\ğº â€²).
Now we have proved that ğœ™ is a BC of ğº with |ğº | = ğ‘˜ > 2 under
ğ·ğ‘œğ‘š implies ğœ™ is also the BC of ğº â€² with |ğº â€²| = ğ‘˜ âˆ’ 1 â‰¥ 2 and
ğº â€² âŠ† ğº under ğ·ğ‘œğ‘š âˆª (ğº\ğº â€²). Continue the above process until
â–¡
ğ‘˜ = 2 and we can prove the theorem.

In principle, Theorem 6 provides a simpler way to compute the
BC of some goal set ğº, whose size is greater than 2, under a domain
set ğ·ğ‘œğ‘š, by spliting ğº to two sets ğº1, ğº2 such that |ğº1| = 2 and
ğ·ğ‘œğ‘šâ€² = ğ·ğ‘œğ‘š âˆª ğº2, and then compute the BC of ğº2 under the new
domain ğ·ğ‘œğ‘šâ€².

Theorem 7. Let ğº = {ğ‘”1, ğ‘”2} be a goal set and ğ·ğ‘œğ‘š be the

domain,

(1) (ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨ (ğ·ğ‘œğ‘š âˆ§ ğ‘”2 âˆ§ Â¬ğ‘”1) is a BC of ğº under

ğ·ğ‘œğ‘š; and

(2) For any other BC ğœ™ of ğº under ğ·ğ‘œğ‘š, (ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨
(ğ·ğ‘œğ‘š âˆ§ğ‘”2 âˆ§ Â¬ğ‘”1) is the witness of ğœ™ holds, i.e., ğœ™ âˆ§ Â¬((ğ·ğ‘œğ‘š âˆ§
ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨ (ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2)) is not a BC of ğº under ğ·ğ‘œğ‘š.

Proof. Let ğœ“ = (ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨ (ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2),

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

(1) Firstly, ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ ğ‘”2 âˆ§ ğœ“ is unsatisfiable; Secondly, it is
trivial to check ğ·ğ‘œğ‘š âˆ§ğ‘”ğ‘– âˆ§ğœ“ is satisfiable for ğ‘– = 1, 2; Thirdly,
ğœ“ Â¬ â‰¡ (Â¬ğ‘”1 âˆ¨ Â¬ğ‘”2) is also true. As a result, ğœ“ is a BC of ğº
under ğ·ğ‘œğ‘š.

(2) To prove that ğœ™ âˆ§ Â¬ğœ“ is not a BC, we show it does not satisfy

the minimality condition in Definition 2. In fact,
ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ ğœ™ âˆ§ Â¬ğœ“
â‰¡ ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ ğœ™ âˆ§ (Â¬ğ·ğ‘œğ‘š âˆ¨ Â¬ğ‘”1 âˆ¨ ğ‘”2) âˆ§ (Â¬ğ·ğ‘œğ‘š âˆ¨ ğ‘”1 âˆ¨ Â¬ğ‘”2)
â‰¡ ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ ğœ™ âˆ§ (Â¬ğ·ğ‘œğ‘š âˆ¨ (Â¬ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨ (ğ‘”1 âˆ§ ğ‘”2))
â‰¡ false

So from Definition 2, ğœ™ âˆ§ Â¬ğœ“ is not a BC. The proof is done.

â–¡

Figure 2: The synthesis ğœ™ of two trace formulas ğœ™1 and ğœ™2.

Theorem 7 indicates thatğœ“ = (ğ·ğ‘œğ‘šâˆ§ğ‘”1âˆ§Â¬ğ‘”2)âˆ¨(ğ·ğ‘œğ‘šâˆ§Â¬ğ‘”1âˆ§ğ‘”2)
is the so-called â€œgoodâ€ BC satisfying Definition 4, since it is the
witness of any other BC. However, ğœ“ is an âˆ¨ formula such that
each disjunctive element captures only the circumstance of one
goal, which does not reflect the divergence in the system level. As
a result, ğœ“ is not considered as a â€œmeaningfulâ€ BC. Next, we define
a form of BC which we consider is â€œmeaningfulâ€.

Definition 9 (Trace Formula). A trace formula ğœ™ = ğ‘ğ‘Ÿğ‘’ ğ‘“ ğ‘–ğ‘¥ (ğœ™)âˆ§

ğ‘™ğ‘œğ‘œğ‘ (ğœ™) is an LTL formula such that

â€¢ ğ‘ğ‘Ÿğ‘’ ğ‘“ ğ‘–ğ‘¥ (ğœ™) has the form of (cid:211)0â‰¤ğ‘– â‰¤ğ‘› â—¦ğ‘–ğ‘ğ‘– (ğ‘› â‰¥ 0), where ğ‘ğ‘–
is a conjunctive formula of literals, â—¦0 (ğ‘) = ğ‘ and â—¦ğ‘–+1ğ‘ =
â—¦(â—¦ğ‘–ğ‘) for ğ‘– â‰¥ 0;
â€¢ ğ‘™ğ‘œğ‘œğ‘ (ğœ™) = â—¦ğ‘›+1â–¡ğ‘ğ‘›+1.
From the perspective of automata theory, a trace formula rep-
resents an infinite trace of an automaton, which is identified by
both the prefix and loop parts such that the length of the prefix is
finite and the loop is just the single self-loop for the trace ending.
As shown in Figure 2, ğœ™, ğœ™1, ğœ™2 are all trace formulas. For such for-
mulas, their behaviors are easy for users to check, and we argue
that they can be â€œmeaningfulâ€ BCs.

Remark. A BC ğœ™ is considered to be meaningful if it is a trace

formula.

Now we introduce the operation of synthesis on two given trace
formulas, essentially a BC constructed from the two trace formulas
that are not BCs. Before that, we first define ğ‘“ ğ‘¢ğ‘ ğ‘’ (ğ‘1, ğ‘2) = ğ‘1 âˆ§ ğ‘2
if ğ‘1 = ğ‘1 âˆ§ ğ‘ and ğ‘2 = ğ‘2 âˆ§ Â¬ğ‘, i.e., ğ‘1, ğ‘2 have only one different
literal; Otherwise, ğ‘“ ğ‘¢ğ‘ ğ‘’ (ğ‘1, ğ‘2) = false.

Definition 10 (Synthesis of Trace Formulas). Given two trace
1 and ğœ™2 = (cid:211)0â‰¤ğ‘– â‰¤ğ‘› â—¦ğ‘–ğ‘ğ‘–
1âˆ§â—¦ğ‘›+1â–¡ğ‘ğ‘›+1

2âˆ§
2, the synthesis of ğœ™1, ğœ™2 is a trace formula ğœ™ = (cid:211)0â‰¤ğ‘– â‰¤ğ‘› â—¦ğ‘–ğ‘ğ‘– âˆ§

formulas ğœ™1 = (cid:211)0â‰¤ğ‘– â‰¤ğ‘› â—¦ğ‘–ğ‘ğ‘–
â—¦ğ‘›+1â–¡ğ‘ğ‘›+1
â—¦ğ‘›+1â–¡ğ‘ğ‘›+1 such that
â€¢ ğ‘ ğ‘— = ğ‘“ ğ‘¢ğ‘ ğ‘’ (ğ‘ ğ‘—
1 âˆ§ ğ‘ğ‘–
â€¢ ğ‘ğ‘– = ğ‘ğ‘–
â€¢ ğ‘ğ‘– (cid:46) false for every 0 â‰¤ ğ‘– â‰¤ ğ‘› + 1.

1, ğ‘ ğ‘—
2) for some 0 â‰¤ ğ‘— â‰¤ ğ‘› + 1; and
2 for every 0 â‰¤ (ğ‘– â‰  ğ‘—) â‰¤ ğ‘› + 1; and

As illustrated in Figure 2, ğœ™ is the systhesis of two trace formulas
ğœ™1 and ğœ™2. Below shows the insight why we need the synthesis of
two trace formulas for BC computation.

Proof. (Sketch) Firstly, from Definition 10 it is not hard to prove
that ğœ™ â‡’ (ğœ™1 âˆ¨ ğœ™2), which implies that ğœ™ â‡’ ((ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨
(ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2)) holds. Based on Theorem 7, we know (ğ·ğ‘œğ‘š âˆ§
ğ‘”1 âˆ§ Â¬ğ‘”2) âˆ¨ (ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2) is a BC of ğº under ğ·ğ‘œğ‘š. As a result,
ğ·ğ‘œğ‘šâˆ§ğ‘”1âˆ§ğ‘”2âˆ§ğœ™ is unsatisfiable. Secondly, we show that ğ·ğ‘œğ‘šâˆ§ğ‘”1âˆ§ğœ™
is satisfiable, as from Definition 10 there is ğœ™ â€² â‡’ ğœ™ such that
ğœ™ â€² â‡’ ğ‘”1. The same applies to the proof that ğ·ğ‘œğ‘š âˆ§ ğ‘”2 âˆ§ ğœ™ is
satisfiable. Thirdly, it is easy to check that ğœ™ (cid:46) ğº is true. Therefore,
â–¡
ğœ™ is a BC of ğº under ğ·ğ‘œğ‘š.

5.2 Implementation
We first define the Synthesis Product operation to implement the
synthesis of trace formulas efficiently.

Definition 11 (Synthesis Product). Given two BÃ¼chi automata
A1 = (2ğ´ğ‘ƒ , ğ‘„1, Î”1, ğ‘1
0, ğ¹2), the syn-
thesis product is defined as A = A1 âˆ§âˆ— A2 = (2ğ´ğ‘ƒ , ğ‘„, Î”, ğ‘0, ğ¹ ),
where:

0, ğ¹1) and A2 = (2ğ´ğ‘ƒ , ğ‘„2, Î”2, ğ‘2

â€¢ ğ‘„ = ğ‘„1 Ã— ğ‘„2 Ã— {1, 2};
â€¢ Î”3 = Î”â€² âˆª Î”â€²â€²:
â€“ Î”â€² = {((ğ‘1, ğ‘2, 1), ğ‘, (ğ‘1 â€², ğ‘2 â€², ğ‘–)) | (ğ‘1, ğ‘1, ğ‘â€²

1) âˆˆ Î”1, (ğ‘2, ğ‘2, ğ‘â€²
2)
âˆˆ Î”2, if ğ‘1 âˆˆ ğ¹1 then ğ‘– = 2 else ğ‘– = 1, and ğ’Šğ’‡ ğ’‚1 = ğ’‚2 ğ’•ğ’‰ğ’†ğ’ ğ’‚ =
ğ’‚1 = ğ’‚2 ğ’†ğ’ğ’”ğ’† ğ’‚ = ğ’‡ ğ’–ğ’”ğ’†(ğ’‚1, ğ’‚2) },

â€“ Î”â€²â€² = {((ğ‘1, ğ‘2, 2), ğ‘, (ğ‘1 â€², ğ‘2 â€², ğ‘–)) | (ğ‘1, ğ‘, ğ‘â€²

1) âˆˆ Î”1, (ğ‘2, ğ‘, ğ‘â€²
2)
âˆˆ Î”2, if ğ‘2 âˆˆ ğ¹2 then ğ‘– = 1 else ğ‘– = 2, and ğ’Šğ’‡ ğ’‚1 = ğ’‚2 ğ’•ğ’‰ğ’†ğ’ ğ’‚ =
ğ’‚1 = ğ’‚2 ğ’†ğ’ğ’”ğ’† ğ’‚ = ğ’‡ ğ’–ğ’”ğ’†(ğ’‚1, ğ’‚2) };

â€¢ ğ‘0 = ğ‘1
â€¢ ğ¹ = {(ğ‘1, ğ‘2, 2) | ğ‘2 âˆˆ ğ¹2}.

0 Ã— {1};

0 Ã— ğ‘2

Synthesis Product is the ordinary BÃ¼chi automata product with
little manipulation. For the calculation of each transition, a new
transition that ğ‘ = ğ‘“ ğ‘¢ğ‘ ğ‘’ (ğ‘1, ğ‘2) is added. Therefore, there are two
kinds of transitions in the product result automaton, (1) transitions
calculated by intersection, and (2) transitions calculated by fusion.

Theorem 8. Given ğº = {ğ‘”1, ğ‘”2} be a goal set, ğ·ğ‘œğ‘š be the do-
main and trace formulas ğœ™1, ğœ™2 that ğœ™1 â‡’ ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2, ğœ™2 â‡’
ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2. Let A = Ağ·ğ‘œğ‘šâˆ§Â¬ğ‘”1âˆ§ğ‘”2 âˆ§âˆ— Ağ·ğ‘œğ‘šâˆ§ğ‘”1âˆ§Â¬ğ‘”2 . If ğœ™ is
the synthesis of ğœ™1 and ğœ™2, then L (ğœ™) âŠ† L (A).

Lemma 1. Given two trace formulas ğœ™1, ğœ™2 such that ğœ™1 â‡’
(ğ·ğ‘œğ‘š âˆ§ ğ‘”1 âˆ§ Â¬ğ‘”2) and ğœ™2 â‡’ (ğ·ğ‘œğ‘š âˆ§ Â¬ğ‘”1 âˆ§ ğ‘”2) hold, let ğœ™ be
the synthesis of ğœ™1 and ğœ™2. It is true that ğœ™ is a BC of ğº = {ğ‘”1, ğ‘”2}
under ğ·ğ‘œğ‘š.

Proof. (Sketch) According to Definition 11 and Definition 10,
a trace formula ğœ™ satisfying L (ğœ™) âŠ† A is a synthesis of two trace
formulas ğœ™1 satisfying L (ğœ™1) âŠ† L (A1) and ğœ™2 satisfying L (ğœ™2) âŠ†
â–¡
L (A2).

â€¦â€¦ğ‘ğ‘—+1=ğ‘“ğ‘¢ğ‘ ğ‘’(ğ‘ğ‘—+11,ğ‘ğ‘—+12)ğ‘ğ‘—=ğ‘ğ‘—1âˆ§ğ‘ğ‘—2ğ‘ğ‘›+1ğœ™â€¦â€¦ğ‘ğ‘—+11ğ‘ğ‘—1ğ‘ğ‘›+11ğœ™1â€¦â€¦ğ‘ğ‘—+12ğ‘ğ‘—2ğ‘ğ‘›+12ğœ™2Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Algorithm 2 SemanticBC: Identifying BC by Synthesis Product

1: procedure semanticBC( ğ‘†ğ‘ğ‘’ğ‘›ğ‘’ ğ‘†)
2:

ğµğ¶ğ‘  â† âˆ…, ğº â€²ğ‘  â† âˆ…
for each two goals ğ‘”ğ‘–, ğ‘”ğ‘— âˆˆ ğº do

3:

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

Ağ‘– â† ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ğ‘™ğ‘ğ‘¡ğ‘’ (ğ·ğ‘œğ‘š âˆª (ğº\ğ‘”ğ‘– ) âˆª Â¬ğ‘”ğ‘– )
A ğ‘— â† ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ğ‘™ğ‘ğ‘¡ğ‘’ (ğ·ğ‘œğ‘š âˆª (ğº\ğ‘”ğ‘— ) âˆª Â¬ğ‘”ğ‘— )
Ağœ™ â† Ağ‘– âˆ§âˆ— A ğ‘—
for each fusion transition ğ‘¡ğ‘– in A do

Delete all fusion transitions in A except ğ‘¡ğ‘–
if there is a run ğ‘Ÿ in A then

ğµğ¶ğ‘  â† ğµğ¶ğ‘  âˆª ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘  ğ‘“ ğ‘’ğ‘Ÿğ‘‡ğ‘œğ¹ğ‘œğ‘Ÿğ‘šğ‘¢ğ‘™ğ‘(ğ‘Ÿ )
ğº â€²ğ‘  â† ğº â€²ğ‘  âˆª {ğ‘”ğ‘–, ğ‘”ğ‘— }

Restore all fusion transitions in A

return ğµğ¶ğ‘ , ğº â€²ğ‘ 

With Theorem 8, we design Algorithm 2 to identify BCs by the
Synthesis Product. It accepts a scene ğ‘† as input, and outputs BCs
and their corresponding scope ğº â€².

and Ağ·ğ‘œğ‘šâˆ§ğ‘”ğ‘— âˆ§Â¬ğ‘”ğ‘–

For any two goals ğ‘”ğ‘– and ğ‘”ğ‘— in the goals set, we solve their BCs.
We first get two automata Ağ·ğ‘œğ‘šâˆ§ğ‘”ğ‘– âˆ§Â¬ğ‘”ğ‘—
, and
then get the automaton Ağœ™ through Synthesis Product. According
to Definition 10, we need to identify the trace formulas that have
only performed the fusion operation once during the run. Thus,
we pick a transition edge ğ‘¡ğ‘– generated by fusion, and then delete
the others. Then we check whether the automaton A still has an
accepting run. If there is a run and it can be converted into an LTL
formula, then we get a BC.

In the process of Synthesis Product, some edges in A are sup-
plemented by the fuse operation, which ignores a conflict atomic
proposition. We record all these edges, and we can also decide
which conflict of atomic propositions can be fused. For example, in
the MPC example, high water level(â„) and methane existing(ğ‘š) are
the environment variables, and it is meaningless to pay attention
to their contradictions. We are concerned with whether the system
should turn on pump(ğ‘) at some moment. Therefore, before run-
ning Synthesis Product, we can set ğ‘ be the literal that could be
fused.

In the whole process of SemanticBC, LTL-SAT checking is not
required, nor do the solved BCs need to be validated. The following
theorem guarantees that the output of Algorithm 2 is a BC of ğ‘†.

Theorem 9 (Correctness). Every element of the output ğµğ¶ğ‘  in

Algorithm 2 is a BC of ğ‘†.

Proof. First from Theorem 8, we know the synthesis ğœ™ of ğœ™1 =
ğ·ğ‘œğ‘šâˆ§ğ‘”1âˆ§Â¬ğ‘”2 and ğœ™2 = ğ·ğ‘œğ‘šâˆ§Â¬ğ‘”1âˆ§ğ‘”2 satisfies that L (ğœ™) âŠ† L (A),
where A = Ağœ™1 âˆ§âˆ— Ağœ™2
. However, A does not only contains
languages which can be represented by the synthesis of two trace
formulas from Ağœ™1
. Line 8 guarantees that the algorithm
deletes all other languages that are not a synthesis trace formula,
i.e., ğµğ¶ğ‘  stores all synthesis trace formulas. Finally, Lemma 1 shows
that a synthesis trace formula is a BC of ğ‘†. The proof is done. â–¡

and Ağœ™2

5.3 Evaluation
We use two research questions to guide our result evaluation. The
experimental setup and benchmarks are the same as in Section 4.4.

5.3.1 ğ‘…ğ‘„1. Can SemanticBC find the BCs represented by a trace for-
mula? To answer ğ‘…ğ‘„1, we compare the performance of SemanticBC
to that of both the JFc and SyntacBC.

Table 2 shows the number of BC solved by SemanticBC and
the time required. |ğµğ¶ğ‘¡ | represents the number of solved BCs in
the form of trace formula, |ğµğ¶ğ‘¤ | represents the number of words
accepted by the automaton Ağœ™ but cannot be transformed into an
LTL formula2, and ğ‘¡ represents the time required.

SemanticBC solves BCs on all instances excluding the ATM and
RRCS. For the LAS case where JFc cannot solve BC after 10 runs,
SemanticBC successfully computes one BC. For the cases LB and
LC, we know that they do not contain BC on the original setting of
ğ·ğ‘œğ‘š and ğº for extra goals. But the SemanticBC will reduce the goal
set for solving, so as to solve the BC that exists in the ğº â€² âŠ‚ ğº. The
time cost of SemanticBC has a certain correlation with the scale of
the case, and when a large number of BCs could be solved, the time
consumption also become larger.

We also list |ğµğ¶ğ‘¤ | here because we believe that although they
cannot be transformed into LTL formulas, they actually contain the
semantics of boundary conditions, and by analyzing them, traces
of events leading to divergence can also be learnt, so they are also
valuable. In the cases of RRA, SA and LC, it may be difficult to solve
a regular BC formula, but there are many accepting words that can
capture the behavior of divergence.

In summary, SemanticBC is able to solve BCs with a relatively
small cost of time consumption. Moreover, the cases whose BCs
are solved by SemanticBC not only include cases whose BCs are
difficult to be solved by other methods, but also include those cannot
be solved by other methods.

5.3.2 ğ‘…ğ‘„2. Is the BC solved by SemanticBC easy to understand
i.e. meaningful? To answer ğ‘…ğ‘„2, we take two case studies on Ele
and ATM, comparing the BCs solved by other methods to those
represented by trace formula, and decipher their meaning.

The elevator control system is an example with two goals, the for-
mal definition of the goals and the BCs solved by different methods
are as follows:
Goal: â–¡(ğ‘ğ‘ğ‘™ğ‘™ â†’ (cid:94)ğ‘œğ‘ğ‘’ğ‘›)
Informal Definition: The elevator will open the door after received
a call.
Goal: â–¡(â—¦ğ‘œğ‘ğ‘’ğ‘› â†’ ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ )
Informal Definition: The elevator should reach the corresponding
floor before opening the door.
BCs:

â€¢ SyntacBC: 1. (ğ‘ğ‘ğ‘™ğ‘™ âˆ§ â–¡Â¬ğ‘œğ‘ğ‘’ğ‘›) âˆ¨ Â¬â–¡(â—¦ğ‘œğ‘ğ‘’ğ‘› â†’ ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ ) 2.

(Â¬ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ âˆ§ â—¦ğ‘œğ‘ğ‘’ğ‘›) âˆ¨ Â¬â–¡(ğ‘ğ‘ğ‘™ğ‘™ â†’ (cid:94)ğ‘œğ‘ğ‘’ğ‘›)

â€¢ JFc(genetic algorithm): 1. â–¡(ğ‘ğ‘ğ‘™ğ‘™ âˆ§Â¬ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ ) 2. â—¦(Â¬ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ âˆ§

â–¡ğ‘œğ‘ğ‘’ğ‘›) âˆ¨ (ğ‘ğ‘ğ‘™ğ‘™ âˆ§ â–¡Â¬ğ‘œğ‘ğ‘’ğ‘›)

â€¢ SemanticBC: 1. Â¬ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ âˆ§ â—¦ğ‘ğ‘ğ‘™ğ‘™ âˆ§ â—¦â—¦â–¡(Â¬ğ‘ğ‘ğ‘™ğ‘™ âˆ§ Â¬ğ‘œğ‘ğ‘’ğ‘›)

[transition from state 2 to state 3 has conflict: ğ‘œğ‘ğ‘’ğ‘›]
2. (Â¬ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ âˆ§ ğ‘ğ‘ğ‘™ğ‘™ âˆ§ Â¬ğ‘œğ‘ğ‘’ğ‘›) âˆ§ â—¦â—¦â–¡(Â¬ğ‘ğ‘ğ‘™ğ‘™ âˆ§ Â¬ğ‘œğ‘ğ‘’ğ‘›) [tran-
sition from state 2 to state 3 has conflict: ğ‘œğ‘ğ‘’ğ‘›]

2In theory, there is not always an LTL formula which can accept the same language as
a given BÃ¼chi automaton [13].

We first try to understand two BCs solved by the SyntacBC,
which are simple mutation after negating the goals. They actu-
ally describe the violation of two goals that occurred, however we
cannot tell exactly what event caused the divergence.

Take the first BC solved by JFc as JFc.1, it satisfies the definition 9
of trace formula, which we believe is meaningful, and it is simple
to interpret such BCs. â€˜When the elevator received a call but it has
not reached the corresponding floor. And it happens forever.â€™ When
this happens, both goals cannot be satisfied, because the opening
of the elevator door requires it to reach the floor as a premise.
Solving such a BC is beneficial, which means that an additional
goal, e.g. â€˜â–¡(ğ‘ğ‘ğ‘™ğ‘™ â†’ (cid:94)ğ‘ğ‘¡ ğ‘“ ğ‘™ğ‘œğ‘œğ‘Ÿ )â€™, may need to be added to complete
the requirement. However genetic algorithms are not guaranteed
to generate such a meaningful BC, and in most cases BCs like JFc.2
are solved by the JFc framework. JFc.2 is similar to BCs solved
by SyntacBC, except that they are two different special case of
violations of the goals combined with âˆ¨ operation.

For SemanticBC.1, it is a trace formula describing a run that can
be accepted by automaton. â€˜In the first state, the elevator did not
reach the floor, and in the second state, the elevator received a call, and
then the elevator was never called nor the door opened.â€™ Furthermore,
we can also know that the goals have a divergence on whether to
open the door in the second state, it will violate either goal anyway.
Interpreted in the same way, SemanticBC.2 actually captures the
same divergence as JFc.2.

The second example is about ATM containing three goals:

Goal: â–¡((ğ‘ğ‘ğ‘ ğ‘ ğ‘œğ‘˜ âˆ§ Â¬ğ‘™ğ‘œğ‘ğ‘˜) â†’ ğ‘šğ‘œğ‘›ğ‘’ğ‘¦)[ğ‘”1]
Informal Definition: When the password is correct and the account
is not locked, money can be withdrawn normally.
Goal: â–¡(Â¬ğ‘ğ‘ğ‘ ğ‘ ğ‘œğ‘˜ â†’ (Â¬ğ‘šğ‘œğ‘›ğ‘’ğ‘¦ âˆ§ â—¦ğ‘™ğ‘œğ‘ğ‘˜ğ‘’ğ‘‘))[ğ‘”2]
Informal Definition: A wrong password is entered, then with-
drawals are not allowed and the account will be locked.
Goal: â–¡(ğ‘™ğ‘œğ‘ğ‘˜ğ‘’ğ‘‘ â†’ (cid:94)Â¬ğ‘™ğ‘œğ‘ğ‘˜ğ‘’ğ‘‘)[ğ‘”3]
Informal Definition: Accounts are unlocked after being locked for
a period of time.
BCs:(for brevity, ğ‘ stands for ğ‘ğ‘ğ‘ ğ‘ ğ‘œğ‘˜, ğ‘š for ğ‘šğ‘œğ‘›ğ‘’ğ‘¦, ğ‘™ for ğ‘™ğ‘œğ‘ğ‘˜)

â€¢ SyntacBC: 1. (Â¬ğ‘™ âˆ§ Â¬ğ‘š âˆ§ ğ‘) âˆ¨ Â¬â–¡Â¬ğ‘ â†’ (Â¬ğ‘š âˆ§ â—¦ğ‘™)
â€¢ JFc(genetic algorithm): 1. (cid:94)(Â¬ğ‘™ âˆ§ Â¬ğ‘š âˆ§â—¦Â¬ğ‘™) 2. (cid:94)(Â¬ğ‘™ âˆ§ Â¬ğ‘š âˆ§

ğ‘) âˆ¨ â–¡(Â¬ğ‘™ âˆ§ Â¬ğ‘)

â€¢ SemanticBC: 1. (Â¬ğ‘™ âˆ§Â¬ğ‘š) âˆ§â—¦(Â¬ğ‘™ âˆ§ğ‘š âˆ§ğ‘) âˆ§â—¦â—¦â–¡(Â¬ğ‘™ âˆ§ğ‘š âˆ§ğ‘)
[transition from state 0 to state 1 has conflict: ğ‘, conflict
between ğ‘”1, ğ‘”2]

SyntacBC.1 and JFc.2 obviously belong to that kind of trivial
BC, though JFc.1 seems like an easy-to-understand BC for its not
containing the âˆ¨ operator. JFc.1 describes the situation that â€˜the
account is unlocked, no money out and account still unlocked at the
next stateâ€™. And SemanticBC.1 actually captures the same divergence
as JFc.1, and we could know this BC cause conflicts between ğ‘”1 and
ğ‘”2. The divergence happens because when the â—¦Â¬ğ‘™ at the second
state, then there is ğ‘ at first state. And since the ğ‘ âˆ§ Â¬ğ‘™, there should
be ğ‘š, however it is Â¬ğ‘š.

Although we are able to interpret the divergence in Seman-
ticBC.1, it is actually meaningless to solve for it, because in the
ATM, ğ‘ğ‘ğ‘ ğ‘ ğ‘œğ‘˜ is a variable determined by the environment and does
not need to care whether it diverges or not. Therefore, in the results

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

shown in Table 2, we have ignored the conflict of the environment
variables in all cases.

By comparing the meaning of BCs obtained by SemanticBC and
BCs obtained by other methods, we can summarize three advan-
tages of BCs solved by SemanticBC: 1. They contain a clear meaning
and are definitely valuable for analysis. 2. They can narrow down
the scope of the analysis by specifying which two goals the diver-
gence occurs between. 3. They will not contain the meaningless
conflict about the environment variables.

6 RELATED WORK
The problem of how to deal with inconsistencies in requirements,
i.e., inconsistency management, has been studied extensively from
different perspective [10, 11, 14, 14â€“19, 25, 27, 29, 30]. Goal-conflict
analysis has been widely used to detect requirement errors in GORE.
It is particularly driven by the identify-assess-control cycle, which
concentrates on identifying, assessing and resolving inconsistencies
that may falsify the satisfaction of expected goals. Another relevant
topic is the obstacle analysis [1â€“4, 33], which captures the situation
where only one goal is inconsistent with the domain properties.
Notably, since obstacles only capture the inconsistency for single
goals, these approaches cannot handle the case when multiple goals
are inconsistent.

In this paper, we focus on the inconsistencies that are captured
by boundary conditions and present novel approaches to identify
meaningful BCs. Extant solutions mainly fall into two kinds of
categories, i.e., the construct-based and search-based strategies. For
construct-based approaches, Van Lamsweerde et al. [32] proposed
a pattern-based approach which only returns a BC in a pre-defined
limited form. Degiovanni et al. [7] utilizes a tableaux-based way
to generate general BCs but that approach only works on small
specifications because constructing tableaux is time consuming.
For the search-based approach, Degiovanni et al. [6] presented a
genetic algorithm to identify BCs such that their algorithm can han-
dle specifications that are beyond the scope of previous approaches.
Moreover, Degiovanni et al. [6] first proposed the concept of gener-
ality to assess BCs. Their work filtered out the less general BCs to
reduce the set of BCs. However, the generality is a coarse-grained
assessment metric. As the number of identified inconsistencies in-
creases, the assessment stage and the resolution stage become very
expensive and even impractical. Recently, the assessment stage
in GORE has been widely discussed to prioritize inconsistencies
to be resolved and suggest which goals to drive attention to for
refinements.

Meanwhile, some of the work [2â€“4] assume that certain proba-
bilistic information on the domain is provided so as to detect simpler
kinds of inconsistencies (obstacles). In order to automatically assess
BCs, Degiovanni et al. [5] recently have proposed an automated
approach to assess how likely conflict is, under an assumption that
all events are equally likely. They estimated the likelihood of BCs
by counting how many models satisfy a circumstance captured by a
BC. However, the number of models cannot accurately indicate the
likelihood of divergence, because not all the circumstances captured
by a BC result in divergence.

Last year, Luo et al. [26] pointed out the shortages of the likelihood-

based method and proposed a new metric called contrastive BC to

Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

avoid evaluation mistakes for the likelihood. For the resolution of
conflicts, Murukannaiah et al. [28] resolved the conflicts among
stakeholder goals of system-to-be based on the Analysis of Com-
peting Hypotheses technique and argumentation patterns. Related
works on conflict resolution also include [12] which calculates the
personalized repairs for the conflicts of requirements with the prin-
ciple of model-based diagnosis. However, these approaches assume
that the conflicts have been already identified, which relies heavily
on the efficiency of the BC construction.

Compared to previous approaches for the BC construction, ours
are distinguished as follows. We make full usage of the syntax and
semantics information of the BC, and present a simple but very
efficient way to construct BCs by replacing some ğ‘”ğ‘– âˆˆ ğº with a
weaker property ğ‘”â€²
ğ‘– â†’ ğ‘”ğ‘– . Moreover, we introduce
the automata-based construction to construct BCs that contain the
system information as a whole, rather than the trivially combination
of local ones using the disjunctive operator.

ğ‘– such that ğ‘”â€²

7 CONCLUSION
In this paper, we revisit the problem of computing boundary condi-
tions in GORE and present two different approaches to construct
BCs based on the theoretical foundations. Our experimental results
show that, the syntactical approach can perform >1000X speed-up
on the BC construction, and the semantics one is able to construct
more meaningful BCs without losing performance. The success of
our approaches affirms that, the problem of identifying BCs should
be reconsidered in the theoretical instead of the algorithmic way.

REFERENCES
[1] Dalal Alrajeh, Jeff Kramer, Axel van Lamsweerde, Alessandra Russo, and Se-
bastiÃ¡n Uchitel. 2012. Generating Obstacle Conditions for Requirements Com-
pleteness. IEEE Press, 705â€“715.

[2] Antoine Cailliau and Axel van Lamsweerde. 2012. A probabilistic framework
for goal-oriented risk analysis. In 2012 20th IEEE International Requirements
Engineering Conference (RE). 201â€“210. https://doi.org/10.1109/RE.2012.6345805
[3] Antoine Cailliau and Axel van Lamsweerde. 2014. Integrating exception han-
dling in goal models. In 2014 IEEE 22nd International Requirements Engineering
Conference (RE). 43â€“52. https://doi.org/10.1109/RE.2014.6912246

[4] Antoine Cailliau and Axel van Lamsweerde. 2015. Handling knowledge uncer-
tainty in risk-based requirements engineering. In 2015 IEEE 23rd International
Requirements Engineering Conference (RE). 106â€“115. https://doi.org/10.1109/RE.
2015.7320413

[5] Renzo Degiovanni, Pablo Castro, Marcelo Arroyo, Marcelo Ruiz, Nazareno
Aguirre, and Marcelo Frias. 2018. Goal-Conflict Likelihood Assessment Based
on Model Counting. In 2018 IEEE/ACM 40th International Conference on Software
Engineering (ICSE). 1125â€“1135. https://doi.org/10.1145/3180155.3180261

[6] Renzo Degiovanni, Facundo Molina, GermÃ¡n Regis, and Nazareno Aguirre. 2018.
A genetic algorithm for goal-conflict identification. In Proceedings of the 33rd
ACM/IEEE International Conference on Automated Software Engineering. 520â€“531.
[7] Renzo Degiovanni, NicolÃ¡s Ricci, Dalal Alrajeh, Pablo Castro, and Nazareno
Aguirre. 2016. Goal-conflict detection based on temporal satisfiability checking. In
2016 31st IEEE/ACM International Conference on Automated Software Engineering
(ASE). IEEE, 507â€“518.

[8] Alexandre Duret-Lutz, Alexandre Lewkowicz, Amaury Fauchille, Thibaud
Michaud, Etienne Renault, and Laurent Xu. 2016. Spot 2.0 â€” a framework for LTL
and ğœ”-automata manipulation. In Proceedings of the 14th International Symposium
on Automated Technology for Verification and Analysis (ATVAâ€™16) (Lecture Notes
in Computer Science, Vol. 9938). Springer, 122â€“129.

[9] N. EÃ©n and N. SÃ¶rensson. 2003. An Extensible SAT-solver. In SAT. 502â€“518.
[10] Christian Ellen, Sven Sieverding, and Hardi Hungar. 2014. Detecting Consisten-
cies and Inconsistencies of Pattern-Based Functional Requirements. In Formal
Methods for Industrial Critical Systems, FrÃ©dÃ©ric Lang and Francesco Flammini
(Eds.). Springer International Publishing, Cham, 155â€“169.

[11] Neil A. Ernst, Alexander Borgida, John Mylopoulos, and Ivan J. Jureta. 2012. Agile
Requirements Evolution via Paraconsistent Reasoning. Springer-Verlag, Berlin,
Heidelberg, 382â€“397.

[12] Alexander Felfernig, Gerhard Friedrich, Monika Schubert, Monika Mandl, Markus
Mairitsch, and Erich Teppan. 2009. Plausible Repairs for Inconsistent Require-
ments. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 791â€“796.
[13] R. Gerth, D. Peled, M.Y. Vardi, and P. Wolper. 1995. Simple on-the-fly auto-
matic verification of linear temporal logic. In Protocol Specification, Testing, and
Verification, P. Dembiski and M. Sredniawa (Eds.). Chapman & Hall, 3â€“18.
[14] David Harel, Hillel Kugler, and Amir Pnueli. 2005. Synthesis Revisited: Generating
Statechart Models from Scenario-Based Requirements. Springer Berlin Heidelberg,
Berlin, Heidelberg, 309â€“324.

[15] Jan Hendrik Hausmann, Reiko Heckel, and Gabi Taentzer. 2002. Detection of
Conflicting Functional Requirements in a Use Case-Driven Approach: A Static
Analysis Technique Based on Graph Transformation. In Proceedings of the 24th
International Conference on Software Engineering. Association for Computing
Machinery, New York, NY, USA, 105â€“115. https://doi.org/10.1145/581339.581355
[16] Sebastian J.I. Herzig and Christiaan J.J. Paredis. 2014. A Conceptual Basis for
Inconsistency Management in Model-based Systems Engineering. Procedia CIRP
21 (2014), 52â€“57. https://doi.org/10.1016/j.procir.2014.03.192 24th CIRP Design
Conference.

[17] Ivan J. Jureta, Alex Borgida, Neil A. Ernst, and John Mylopoulos. 2010. Techne:
Towards a New Generation of Requirements Modeling Languages with Goals,
Preferences, and Inconsistency Handling. In 2010 18th IEEE International Require-
ments Engineering Conference. 115â€“124. https://doi.org/10.1109/RE.2010.24
[18] Massila Kamalrudin. 2009. Automated Software Tool Support for Checking the
Inconsistency of Requirements. In 2009 IEEE/ACM International Conference on
Automated Software Engineering. 693â€“697. https://doi.org/10.1109/ASE.2009.38
[19] Massila Kamalrudin, John Hosking, and John Grundy. 2011. Improving require-
ments quality using essential use case interaction patterns. In 2011 33rd Interna-
tional Conference on Software Engineering (ICSE). 531â€“540. https://doi.org/10.
1145/1985793.1985866

[20] Jeff Kramer, Jeff Magee, Morris Sloman, and Andrew Lister. 1983. Conic: an
integrated approach to distributed computer control systems. IEE Proceedings
E-Computers and Digital Techniques 130, 1 (1983), 1.

[21] Phillip A. Laplante. 2007. What Every Engineer Should Know about Software
Engineering (What Every Engineer Should Know). CRC Press, Inc., USA.
[22] Jianwen Li, Yinbo Yao, Geguang Pu, Lijun Zhang, and Jifeng He. 2014. Aalta: An
LTL Satisfiability Checker over Infinite/Finite Traces. In Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software Engineering.
Association for Computing Machinery, New York, NY, USA, 731â€“734. https:
//doi.org/10.1145/2635868.2661669

[23] Jianwen Li, Shufang Zhu, Geguang Pu, and Moshe Y. Vardi. 2015. SAT-Based
Explicit LTL Reasoning. In Hardware and Software: Verification and Testing, Nir
Piterman (Ed.). Springer International Publishing, Cham, 209â€“224.

[24] Jianwen Li, Shufang Zhu, G. Pu, Lijun Zhang, and Moshe Y. Vardi. 2019. SAT-
based explicit LTL reasoning and its application to satisfiability checking. Formal
Methods in System Design (2019), 1â€“27.

[25] Chi-Lun Liu. 2010. Ontology-Based Conflict Analysis Method in Non-functional
Requirements. In 2010 IEEE/ACIS 9th International Conference on Computer and
Information Science. 491â€“496. https://doi.org/10.1109/ICIS.2010.26

[26] Weilin Luo, Hai Wan, Xiaotong Song, Binhao Yang, Hongzhen Zhong, and Yin
Chen. 2021. How to Identify Boundary Conditions with Contrasty Metric?. In
2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE).
IEEE, 1473â€“1484.

[27] Dewi Mairiza and Didar Zowghi. 2011. Constructing a Catalogue of Conflicts
among Non-functional Requirements. In Evaluation of Novel Approaches to Soft-
ware Engineering, Leszek A. Maciaszek and Pericles Loucopoulos (Eds.). Springer
Berlin Heidelberg, Berlin, Heidelberg, 31â€“44.

[28] Pradeep K. Murukannaiah, Anup K. Kalia, Pankaj R. Telangy, and Munindar P.
Singh. 2015. Resolving goal conflicts via argumentation-based analysis of com-
peting hypotheses. In 2015 IEEE 23rd International Requirements Engineering
Conference (RE). 156â€“165. https://doi.org/10.1109/RE.2015.7320418

[29] T. Nguyen, Q. B. Vo, M. Lumpe, and J. Grundy. 2013. KBRE: a framework for
knowledge-based requirements engineering. Software Quality Journal 22 (2013),
87â€“119.

[30] Bashar Nuseibeh and Alessandra Russo. 1999. Using Abduction to Evolve Incon-
sistent Requirements Specification. Australasian Journal of Information Systems
6 (1999).

[31] A. Pnueli. 1977. The temporal logic of programs. In 18th Annual Symposium on
Foundations of Computer Science (sfcs 1977). 46â€“57. https://doi.org/10.1109/SFCS.
1977.32

[32] Axel Van Lamsweerde, Robert Darimont, and Emmanuel Letier. 1998. Managing
conflicts in goal-driven requirements engineering. IEEE transactions on Software
engineering 24, 11 (1998), 908â€“926.

[33] A. van Lamsweerde and E. Letier. 2000. Handling obstacles in goal-oriented
IEEE Transactions on Software Engineering 26, 10

requirements engineering.
(2000), 978â€“1005. https://doi.org/10.1109/32.879820

