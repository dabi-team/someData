Identifying Boundary Conditions with the Syntax and Semantic
Information of Goals
Jianwen Li
East China Normal University
Shanghai, China
lijwen2748@gmail.com

Yechuan Xia
East China Normal University
Shanghai, China
xiaozi465@gmail.com

Shengping Xiao
East China Normal University
Shanghai, China
shengping.xiao98@gmail.com

2
2
0
2

r
a

M
5
2

]
E
S
.
s
c
[

2
v
3
0
9
2
1
.
3
0
2
2
:
v
i
X
r
a

Weikai Miao
Shanghai Key Lab for Trustworthy
Computing
East China Normal University
Shanghai, China
wkmiao@sei.ecnu.edu.cn

Geguang Pu
East China Normal University
Shanghai, China
ggpu@sei.ecnu.edu.cn

ABSTRACT
In goal-oriented requirement engineering, boundary conditions
(BC) are used to capture the divergence of goals, i.e., goals cannot
be satisfied as a whole in some circumstances. As the goals are
formally described by temporal logic, solving BCs automatically
helps engineers judge whether there is negligence in the goal re-
quirements. Several efforts have been devoted to computing the
BCs as well as to reducing the number of redundant BCs as well.
However, the state-of-the-art algorithms do not leverage the logic
information behind the specification and are not efficient enough
for use in reality. In addition, even though reducing redundant BCs
are explored in previous work, the computed BCs may be still not
valuable to engineering for debugging.

In this paper, we start from scratch to establish the fundamental
framework for the BC problem. Based on that, we first present a new
approach SyntacBC to identify BCs with the syntax information
of goals. The experimental results show that this method is able
to achieve a >1000X speed-up than the previous state-of-the-art
methodology. Inspired by the results, we found the defects of BCs
solved by our method and also by the previous ones, i.e., most of
BCs computed are difficult for debugging. As a result, we leverage
the semantics information of goals and propose an automata-based
method for solving BCs, namely SemanticBC, which can not only
find the minimal scope of divergence, but also produce easy-to-
understand BCs without losing performance.

1 INTRODUCTION
The requirement process is a crux stage in the whole life-cycle
of software engineering, only based on which the system design,
testing, and verification/validation can be completed properly in
order [21]. Requirements written in natural languages are often
considered to be ambiguous, which can potentially affect the qual-
ity of further stages in software development. The goal-oriented
requirement engineering (GORE) is a promising direction to avoid
the ambiguity in the requirements, as each goal (a piece of require-
ment) is written in formal languages like Linear Temporal Logic
(LTL) [31], which is rigorous in mathematics. Moreover, the re-
quirement written in LTL, which is normally called specification,
enables its correctness checking in an automatic way, saving a lot
of artificial efforts [6].

The conflict analysis is a common check to guarantee the correct-
ness of the GORE specification. Since the specification is written by
LTL, such analysis can be achieved by reducing it to LTL satisfiabil-
ity checking [23, 24]. If the specification formula is unsatisfiable, it
indicates there is a conflict among different goals which consist of
the specification. Because of the superior performance of modern
LTL satisfiability solvers [9, 22], the conflict analysis in GORE can
be accomplished successfully. However, there are more stubborn
defects that cannot be detected by satisfiability checking directly.
For example, even though all goals together are satisfiable, there are
some certain circumstances in which the goals cannot be satisfied
as a whole any more. Such circumstances are called the boundary
conditions (BC).

Given a set of domain properties 𝐷𝑜𝑚 and goals 𝐺, both of which
consist of LTL formulas, a BC 𝑏𝑐 satisfies (1) the conjunction of 𝑏𝑐
and all elements in 𝐷𝑜𝑚 and 𝐺 is unsatisfiable, and (2) after remov-
ing an element from 𝐺, the above conjunction becomes satisfiable,
and (3) 𝑏𝑐 cannot be semantically equivalent to the negation of ele-
ments in 𝐺. Details see below. Informally speaking, a BC captures
the divergence of goals, i.e., the satisfaction of some goals inhibits
the satisfaction of others.

Several efforts have been devoted to computing the BCs for the
given goals and domain properties. The most recent one is based
on a genetic algorithm in which a chromosome represents an LTL
formula 𝜑 and each gene of the chromosome characterises a sub-
formula of 𝜑 [6]. After setting the initial population and fitness
function, the algorithm utilizes two genetic operators, i.e., crossover
and mutation, to compute the BC with respect to the input goals and
domains. Since the genetic algorithm is a heuristic search strategy,
using this approach to compute BCs is not complete. Also, the BCs
computed by such algorithm seems to be redundant, i.e., it is often
the case that two generated BCs 𝜑1, 𝜑2 satisfy 𝜑1 ⇒ 𝜑2, which
indicates that the BC 𝜑2 is redundant.

To solve this problem, Luo et. al. presented the concept of con-
trastive BCs to reduce the number of redundant BCs generated from
the above genetic approach [26]. The motivation comes from that
two BCs 𝜑1, 𝜑2 are contrastive if 𝜑1 ∧ ¬𝜑2 is not a BC and 𝜑2 ∧ ¬𝜑1
is not a BC. Once a BC is computed, the algorithm adds the negation
of it into the domain properties such that the next computed BC is

 
 
 
 
 
 
contrastive to the previous ones. The literature shows that, com-
puting only the contrastive BCs saves many efforts of engineers to
locate the defects revealed by the BCs in the specification.

From our preliminary results, the efficiency of the genetic ap-
proach to compute BCs seems modest and has to be improved
to meet the requirement from the industry. Also, the computed
BCs from this approach may not be quite useful for debugging.
Let 𝐺 = {□(ℎ → ◦𝑝), □(𝑚 → ◦¬𝑝)} be the set of goals and
assume the set of domain properties is empty. It is not hard to
see that ℎ ∧ 𝑚 is a BC, which means once the pre-conditions ℎ
and 𝑚 are true together, the two goals cannot be met as a whole.
But boundary conditions are not unique, and the LTL formulas
𝜓1 = (ℎ ∧◦¬𝑝) ∨ (cid:94)(𝑚 ∧◦𝑝) and 𝜓2 = (𝑚 ∧◦𝑝) ∨ (cid:94)(ℎ ∧◦¬𝑝) are
also BCs. Obviously, the BC ℎ ∧𝑚 is more helpful for engineers than
the other two, as they do not explicitly show the events causing
the divergence.

The observation is that,𝜓1 and𝜓2 consist of disjunctive operators
(∨), each element of which only captures a single circumstance that
falsifies one goal. We argue that a meaningful and valuable BC shall
not consist of the disjunctive operator. However, current approaches
seems to compute mostly the BCs less helpful, i.e., with the form of
(cid:212)𝜓 . Even the contrastive BCs computed in [26] cannot avoid such
problem. Take the above example again, 𝜓1 and 𝜓2 are contrastive
BCs, but they are less helpful than ℎ ∧ 𝑚. Therefore, the better
algorithms to generate more helpful BCs are still in demand.

In this paper, we start from scratch to establish a fundamental
framework to compute the BCs in GORE. We first present a general
but efficient algorithm SyntacBC to compute the BC based on the
syntax information of goals. We prove in a rigorous way that by
simply negating the goals and domains, i.e., ¬(𝐷𝑜𝑚 ∧ 𝐺), and
replacing some 𝑔𝑖 ∈ 𝐺 with 𝑔′
𝑖 ⇒
𝑔𝑖 , the constructed formula is a BC. Such algorithm performs much
better than all other existing approaches, even though it generates
the BC with disjunctive operators, which is less helpful.

𝑖 in the negated formula where 𝑔′

To compute different kinds of BC that are not in the form of (cid:212)𝜓 ,
we leverage the semantics of goals and present an automata-based
approach in which the BCs can be extracted from the accepting
languages of an automata. The motivation comes from the well-
known fact that there is a (Büchi) automaton for every LTL formula
such that they accept the same languages [13]. Since the inputs and
output of the BC problem are all LTL formulas, it is straightforward
to consider this problem by reducing it to the automata construction
problem. Briefly speaking, we first reduce the BC computation for a
set of goals whose length is greater than 2 to that for a set of goals
whose length is exactly 2, making the problem easier to handle.
Secondly, given a goal set 𝐺 = {𝑔1, 𝑔2} and a domain set 𝐷𝑜𝑚, we
construct the automata for the formulas 𝜙1 = 𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2 and
𝜙2 = 𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2. Then we define the synthesis production (∧∗)
on the automata for the purpose to compute the BCs. We prove
that under the synthesis production, the produced automaton of
includes necessary information to extract BCs.
A𝜙 = A𝜙1
In summary, the contribution of this paper are listed as follows:

(cid:211)∗A𝜙2

• We present SyntacBC and SemanticBC, the two new ap-
proaches to identify boundary conditions based on the syn-
tax and semantics information of goals (LTL formulas);

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

• The experimental evaluation shows that SyntacBC is able to
achieve a >1000X speed-up than the previous state-of-the-
art methodology. Moreover, SemanticBC is able to provide
more helpful BCs than previous work;

• The solutions shown in this paper provide a promising di-
rection to reconsider the problem of identifying boundary
conditions from the theoretic foundations.

We continue in the next section with preliminaries. A motivating
example is presented in Section 3. Section 4 presents the SyntacBC
approach and Section 5 presents the SemanticBC approach. Finally,
Section 6 and 7 discuss and conclude the paper.

2 PRELIMINARIES
2.1 LTL and Büchi Automata
Linear Temporal Logic (LTL) is widely used to describe the discrete
behaviors of a system over infinite trace. Given a set of atomic
propositions 𝐴𝑃, the syntax of LTL formulas is defined by:

𝜙 ::= ⊤ | 𝑎 | ¬𝜙 | 𝜙 ∧ 𝜙 | ◦𝜙 | 𝜙 U 𝜙
where ⊤ represents the true formula, 𝑎 ∈ 𝐴𝑃 is an atomic proposi-
tion, ¬ is the negation, ∧ is the and, ◦ is the Next and U is the Until
operator. We also have the corresponding dual operators ⊥ (false)
for ⊤, ∨ (or) for ∧, and R (Release) for U. Moreover, we use the no-
tation 𝜙1 → 𝜙2 (imply), □𝜙 (Global), and (cid:94)𝜙 (Future) to represent
(¬𝜙1) ∨ 𝜙2, ⊥ R 𝜙, and ⊤ U 𝜙, respectively. A literal 𝑙 is an atom 𝑎
or its negation ¬𝑎. We use 𝛼 to denote propositional formulas, and
𝜙,𝜓 for LTL formulas.

LTL formulas are interpreted over infinite traces of propositional
interpretations of 𝐴𝑃. A model of a formula 𝜙 is an infinite trace
𝜌 ∈ (2𝐴𝑃 )𝜔 (i.e., 𝜌 : N → 2𝐴𝑃 ). Given an infinite trace 𝜌, 𝜌 [𝑖] (∈
2𝐴𝑃 ) denotes the propositional interpretation at position 𝑖; 𝜌𝑖 is the
prefix ending at position 𝑖; and 𝜌𝑖 is the suffix starting at position 𝑖.
Given an LTL formula 𝜙 and an infinite trace 𝜌, we inductively
define the satisfaction relation 𝜌 |= 𝜙 (i.e., 𝜌 models 𝜙) as follows:

• 𝜌 |= ⊤;
• 𝜌 |= 𝑎 iff 𝑝 ∈ 𝜌 [0];
• 𝜌 |= ¬𝜙 iff 𝜌 ̸|= 𝜙;
• 𝜌 |= (𝜙1 ∧ 𝜙2) iff 𝜌 |= 𝜙1 and 𝜌 |= 𝜙2;
• 𝜌 |= ◦𝜙 iff 𝜌1 |= 𝜙;
• 𝜌 |= 𝜙1 U 𝜙2 iff there exists 𝑗 ≥ 0, 𝜌 𝑗

0 ≤ 𝑖 < 𝑗, 𝜌𝑖 |= 𝜙1.

|= 𝜙2 and for all

The set of infinite traces that satisfy LTL formula 𝜙 is the lan-
guage of 𝜙, denoted as L (𝜙) = {𝜌 ∈ (2𝐴𝑃 )𝜔 | 𝜌 |= 𝜙 }. The two LTL
formulas 𝜙1 and 𝜙2 are semantically equivalent, denoted as 𝜙1 ≡ 𝜙2,
iff the languages of them are the same, i.e., L (𝜙1) = L (𝜙2). Given
two formulas 𝜙 and 𝜓 , we denote with 𝜙 ⇒ 𝜓 if all the models of
𝜑 are also models of 𝜓 .

A Büchi automaton is a tuple A = (2𝐴𝑃 , 𝑄, Δ, 𝑞0, 𝐹 ) where
• 2𝐴𝑃 is the alphabet;
• 𝑄 is the set of states;
• Δ : 𝑄 × 2𝐴𝑃 → 2𝑄 is the transition function;
• 𝑞0 ∈ 𝑄 is the initial state;
• 𝐹 ⊆ 𝑄 is the set of accepting conditions.

A run 𝑟 of A on an infinite trace 𝜌 is an infinite sequence, 𝑟 =
𝑞0, 𝑞1, . . . , 𝑞𝑖, . . . , such that 𝑞0 is the initial state of A and 𝑞𝑖+1 ∈

Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Δ(𝑞𝑖, 𝜌 [𝑖]) holds for 𝑖 ≥ 0. Moreover, a run 𝑟 is accepting iff there
exists an accepting state 𝑓 ∈ 𝐹 such that 𝑓 appears infinitely often.
An infinite trace 𝜌 is accepted by A iff there exists an accepting run
on 𝜌. The set of infinite traces that accepted by A is the language
of A, denoted as L (A).

The following theorem states the well-known relationship be-

tween LTL formulas and the Büchi automata.

Theorem 1 ([13]). Given an LTL formula 𝜙, there exists a Büchi

automaton A𝜙 such that L (𝜙) = L (A𝜙 ).

2.2 Goal-Conflict Analysis
In GORE, goals are used to describe the properties that the system
has to satisfy, and the domain properties to describe the properties
of the system’s operating environment. In this article, we call such
a set of goals and domain properties as a requirement scene.

Definition 1 (Requirement Scene). A requirement scene 𝑆 con-
sists of a set of domain properties 𝐷𝑜𝑚 = {𝑑1, 𝑑2, . . . , 𝑑𝑚 } and a set
of goals 𝐺 = {𝑔1, 𝑔2, . . . , 𝑔𝑛 }, i.e., 𝑆 = 𝐷𝑜𝑚 ∪ 𝐺.

In the process of building goals, inconsistencies may inevitably
occur in the scene. For example, the conflicts in the scene means that
it is impossible to construct a system that satisfies the goals and the
domain properties, which means 𝑑1 ∧𝑑2 ∧· · ·∧𝑑𝑚 ∧𝑔1 ∧𝑔2 ∧· · ·∧𝑔𝑛
is unsatisfiable. In this article, we focus on a weaker but harder-to-
catch inconsistency, which is called divergence. We call a scene is
divergent if there is a boundary condition (BC) in it.

Definition 2 (Boundary Condition). An LTL formula 𝜙 is a
boundary condition of scene 𝑆, if 𝜙 satisfies the following conditions:

(1) (logical inconsistency) 𝐷𝑜𝑚 ∧ 𝐺 ∧ 𝜙 is unsatisfiable,
(2) (minimality) 𝐷𝑜𝑚 ∧𝐺−𝑖 ∧ 𝜙 is satisfiable for 1 ≤ 𝑖 ≤ |𝐺 |, and
(3) (non-triviality) 𝜙 (cid:46) ¬𝐺, i.e., 𝜙 is not semantically equivalent

to ¬𝐺,

where 𝐷𝑜𝑚 = (cid:211)1≤𝑖 ≤𝑚 𝑑𝑖 , 𝐺 = (cid:211)1≤𝑖 ≤𝑛 𝑔𝑖 , and 𝐺−𝑖 = (cid:211)1≤ ( 𝑗≠𝑖) ≤𝑛 𝑔𝑗 .
Intuitively, a BC is a situation in which the goals can not be
satisfied as a whole due to the potential divergence between the
goals [32]. That is, in the situation of BC, the goals are logical
inconsistency. The minimality condition means that when any one
of the goals is removed, the boundary condition no longer causes
the inconsistency among the remaining goals. The non-triviality
means that the boundary condition should not be the negation of
the goal, which simply means trivial situations.

In this paper, we mix-use the meanings of symbol 𝐺 and
𝐷𝑜𝑚. When 𝐺 is supposed to be an LTL formula, it represents the
logical and result of the goals, otherwise it represents the set of
goals, which is the same for 𝐷𝑜𝑚 and 𝐺−𝑖 .

According to the identify-assess-control methodology to resolve
inconsistencies, we first identify the BCs that lead to inconsistencies,
then assess and prioritize the identified BCs according to their
likelihood and severity, and finally resolve the inconsistences by
providing appropriate countermeasures. In order to assess the BC
more effectively, the generality metric and contrasty metric are used
to reduce the number of BCs during the identifying process.

Definition 3 (Generality Metric [6]). Given two different BCs

𝜙1, 𝜙2 of the scene 𝑆, 𝜙1 is more general than 𝜙2 if 𝜙2 ⇒ 𝜙1.

From the definition above, a more general BC can capture all
the divergences that can be captured by the less general ones. For
requirements engineers, it is more useful to assess the most general
BCs to detect the cause of divergence, rather than assessing the less
general ones that capture only partial situations.

Definition 4 (Witness, Contrasty Metric [26]). Let 𝑓 be an
LTL formula and 𝜙 a BC of the given scene 𝑆. 𝑓 is a witness of 𝜙 iff
𝜙 ∧ ¬𝑓 is not a BC of 𝑆.

The contrasty metric is another metric that can reduce the num-
ber of BCs. Similar to the general metric, if a BC 𝜙1 is the witness of
another one 𝜙2, 𝜙1 is considered as the “better” BC than 𝜙2. Since
𝜙2 ∧ ¬𝜙1 is not a BC, it means that after removing the divergence
captured by 𝜙1, 𝜙2 is no longer a BC, i.e., 𝜙1 includes the key part
of 𝜙2 which causes the divergence. For two BCs that are witnesses
to each other, it is always better to choose the BC with the shorter
formula length, as the conflict analysis would become easier. Com-
pared to the generality metric, the contrasty metric can reduce
more BCs [26], so that the requirement engineers can resolve the
divergence more efficiently.

3 MOTIVATING EXAMPLE
In this section, we illustrate the shortcomings of the BCs generated
by the current methods through a widely used example, i.e., the goal-
oriented requirement case of a simplified Mine Pump Controller
(MPC) [20]. This actually reveals the flaws of the current definition
of BC. Therefore, we give more stringent restrictions on BC and
propose our solutions.

MPC describes the behavior of a water pump controller system
in a mine. MPC has two sensors, one is used to sense the water
level in the mine, and the other is used to sense the presence of
methane in the pump environment. The propositional variable ℎ is
used to represent the situation that the water reaches a high level,
𝑚 is used to represent the presence of methane in the environment,
and 𝑝 to represent that the system turns the pump on. The goals
that the MPC expects to achieve are as follows:

Goal: 𝑁𝑜 𝐹𝑙𝑜𝑜𝑑𝑖𝑛𝑔 [𝑔1]

FromalDef: □(ℎ → ◦𝑝)

InfromalDef: 𝑊 ℎ𝑒𝑛 𝑡ℎ𝑒 𝑤𝑎𝑡𝑒𝑟 𝑙𝑒𝑣𝑒𝑙 𝑖𝑠 ℎ𝑖𝑔ℎ, 𝑡ℎ𝑒 𝑠𝑦𝑠𝑡𝑒𝑚 𝑠ℎ𝑜𝑢𝑙𝑑

𝑡𝑢𝑟𝑛 𝑜𝑛 𝑡ℎ𝑒 𝑝𝑢𝑚𝑝.

Goal: 𝑁𝑜 𝐸𝑥𝑝𝑙𝑜𝑠𝑖𝑜𝑛 [𝑔2]

FromalDef: □(𝑚 → ◦¬𝑝)

InfromalDef: 𝑊 ℎ𝑒𝑛 𝑡ℎ𝑒𝑟𝑒 𝑖𝑠 𝑚𝑒𝑡ℎ𝑎𝑛𝑒 𝑖𝑛 𝑡ℎ𝑒 𝑒𝑛𝑣𝑖𝑟𝑜𝑛𝑚𝑒𝑛𝑡, 𝑡ℎ𝑒

𝑝𝑢𝑚𝑝 𝑠ℎ𝑜𝑢𝑙𝑑 𝑏𝑒 𝑡𝑢𝑟𝑛𝑒𝑑 𝑜 𝑓 𝑓 .

First of all, 𝑔1 and 𝑔2 do not conflict with each other. They are two
goals that can be met at the same time in some situations, for 𝑔1 ∧𝑔2
is satisfiable. But when 𝜙 = ℎ ∧𝑚 occurs, the goals become logically
inconsistent. In this certain state, the system detects the presence of
methane in the environment while detecting the high water level.
In this situation, the system cannot meet both two requirements

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

ℎ ∧ 𝑚, 𝑝 ∨ ¬𝑝, (1)𝜔 , which is called synthesis product, and generate
the below automaton in Figure 1. For trace 𝜌, we can clearly observe
that when event ℎ ∧ 𝑚 occurs, the goals will diverge for variable 𝑝.

4 IDENTIFYING BOUNDARY CONDITIONS

BASED ON LTL SYNTAX

In this section, we present an efficient method to compute boundary
conditions that leverages LTL syntax. Starting from the definition
of the problem, we discuss the conditions that need to be met for
the existence of BC, and give the algorithm to solve BC if it exists.

4.1 Conditions for the Existence of BC

Property 1. If 𝜙 is a boundary condition, then 𝜙 ⇒ ¬(𝐷𝑜𝑚 ∧𝐺).

It can be directly derived from the logical inconsistency condition.
Since 𝐷𝑜𝑚 ∧ 𝐺 ∧ 𝜙 is unsatisfiable, so 𝜙 implies ¬(𝐷𝑜𝑚 ∧ 𝐺).
Property 1 means that if an LTL formula 𝑓 does not imply ¬(𝐷𝑜𝑚 ∧
𝐺), 𝑓 can not be a BC. From the perspective of requirements, the
divergence captured by BC must be against the requirement 𝐷𝑜𝑚 ∧
𝐺. And if we consider the generality metric for BCs reduction,
¬(𝐷𝑜𝑚 ∧ 𝐺) shall be the most general BC if it is. So it is reasonable
to take ¬(𝐷𝑜𝑚 ∧ 𝐺) as a potential BC, and see if it can satisfy the
conditions.

For the convenience of description, we call ¬(𝐷𝑜𝑚 ∧ 𝐺) NGD
(the Negation of Domain properties and Goals) below. And
to prove whether NGD is a BC, we need to introduce the definitions
of extra goal and influential domain properties as below.

Definition 5 (Extra Goal). For a goal 𝑔𝑖 in the scene 𝑆, 𝑔𝑖 is an

extra goal if (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ) ⇒ 𝑔𝑖 .

In Definition 5, 𝐷𝑜𝑚 ∧𝐺−𝑖 implies 𝑔𝑖 is equivalent to that 𝐷𝑜𝑚 ∧
𝐺−𝑖 ∧ ¬𝑔𝑖 is unsatisfiable. The product automata of all domain
properties and goals except 𝑔𝑖 , i.e., A (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ), contains the
expected event traces of scene 𝑆, and the unsatisfiability means
there is no trace against 𝑔𝑖 . Intuitively, the goals in the scene have
already deduced the goal 𝑔𝑖 before including 𝑔𝑖 . Therefore, adding
and removing 𝑔𝑖 will not affect the goals’ expectation of the system.
But we may still take it as a goal for the purpose of prompting the
requirements engineer. So we call 𝑔𝑖 an extra goal.

Definition 6 (Influential Domain Properties). A scene 𝑆 has
influential domain properties if the domain properties set 𝐷𝑜𝑚 is not
empty and 𝐺 ⇒ 𝐷𝑜𝑚 does not hold.

In contrary to Definition 5, the influential domain properties could
further restrict the expected system behaviors and have influence
on the system besides goals. So the automaton composed of 𝐺
should not already conform to the domain properties.

Theorem 2. If the scene 𝑆 has extra goals, then 𝑆 has no BC.

Proof. Assume 𝑔𝑘 is the extra goal in 𝑆. If there is a BC 𝑏𝑐 of 𝑆,
according to the minimality condition, it holds that 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧
𝑏𝑐 is satisfiable for every 1 ≤ 𝑖 ≤ |𝐺 |. Now let 𝑖 = 𝑘, because
(𝐷𝑜𝑚 ∧ 𝐺−𝑘 ) ⇒ 𝑔𝑘 is true, we have that 𝐷𝑜𝑚 ∧ 𝐺−𝑘 = 𝐷𝑜𝑚 ∧ 𝐺.
Therefore, 𝐷𝑜𝑚 ∧ 𝐺−𝑘 ∧ 𝑏𝑐 = 𝐷𝑜𝑚 ∧ 𝐺 ∧ 𝑏𝑐, which is unsatisfiable:
the contradiction occurs. As a result, there is no BC for 𝑆 if 𝑆 has
□
extra goals.

Figure 1: An illustration of the ideas on how to compute a
meaningful BC for the MPC example. The automaton above
is constructed from the formula ¬(𝑔1 ∧ 𝑔2), in which each
of the two (infinite) traces falsifies one of the goal (𝑔1 or 𝑔2).
Meanwhile, the automaton below represents the synthesis
product (automaton) of the two traces in the one above.

at the same time, that is to say, 𝜙 ∧ 𝑔1 ∧ 𝑔2 is unsatisfiable. But if
we ignore any one of the goals, the system can meet the remaining
goal, formally, 𝜙 ∧ 𝑔1 and 𝜙 ∧ 𝑔2 are satisfiable. Therefore, ℎ ∧ 𝑚 is
a BC in the scene 𝑆𝑀𝑃𝐶 .

In previous literature, according to the strategy for reducing
the number of BCs, 𝜙1 = (cid:94)(ℎ ∧ 𝑚) is considered to be a BC that
describes a more general situation than 𝜙. But by using the Syn-
tacBC method in this article, we can solve that 𝜙2 = (cid:94)¬(ℎ →
◦𝑝) ∨ ¬(𝑚 → ◦¬𝑝) and 𝜙3 = ¬(ℎ → ◦𝑝) ∨ (cid:94)¬(𝑚 → ◦¬𝑝) are
two BCs at an extremely fast speed. Moreover, according to the
reduction strategy (whether the generality metric or the contrasty
metric), 𝜙2 and 𝜙3 are considered to be the more worth-keeping
BCs than 𝜙1, for they describe the even more general divergence
situations. And our BCs with this strong generality also have the
theoretical basis, indicating that it is difficult to find a BC that is
more general than them.

By observing 𝜙2 and 𝜙3, we can find that they are obtained from
making some mutations on ¬(𝑔1 ∧𝑔2). Although they meet the non-
triviality condition of BC, it is difficult to explain why ¬(𝑔1 ∧ 𝑔2) is
considered trivial but they are not. And because of this suspiciously
trivial nature, it is actually difficult to understand 𝜙2 and 𝜙3, that
is, what event causes the divergence indeed.

Here we take ¬(𝑔1 ∧ 𝑔2) as an example and try to analyze it as
a BC, it can be transformed to the automaton above in Figure 1.
Intuitively, a word accepted by the automaton should be a sequence
of events leading to divergence of goals, however it is not. For ex-
ample, the two traces 𝜌1 = 𝑚, 𝑝, (1)𝜔 and 𝜌2 = ℎ, ¬𝑝, (1)𝜔 accepted
by the automaton only violate one goal respectively1. The ideal
BC we really want, like ℎ ∧ 𝑚, is implicitly present in these traces.
This leads to the fact that computing such a BC does not help the
engineers.

After theoretically studying the conditions of BC, We believe
that the non-triviality condition is not enough to ensure that the
solved BCs have a clear meaning. We therefore define a new form
of BC which is transformed from a run of an automaton. Intuitively,
our approach is to fuse together two conflicting traces. For example,
for the two traces 𝜌1 and 𝜌2, we fuse them into the trace 𝜌 =

1 (1)𝜔 represents the trace with infinitely many 1 (true).

¬𝑝𝑝𝑚ℎ∧𝑚ℎ𝑝∨¬𝑝111Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Theorem 2 states a prerequisite for the existence of BC: there is
no extra goal in 𝑆. The existence of extra goals makes the logical
inconsistency and minimality conditions unable to be met at the
same time. After providing this conditions for the existence of BC,
we propose the first way to identify the BC in this article.

Theorem 3. If the scene 𝑆 with influential domain properties has

no extra goal, then 𝑁𝐺𝐷 is a BC of 𝑆.

Proof. To prove this theorem, we check whether NGD can sat-

isfy all three conditions.

• logical inconsistency: NGD satisfy Property 1, so it meets the

condition.

• minimality: If the formula 𝜙 = 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ 𝑁𝐺𝐷 is satisfi-
able for each 𝑖, NGD can be the boundary condition. After
expanding into the disjunctive normal form (DNF), 𝜙 is equiv-
alent to (cid:212)1≤𝑥 ≤𝑚 (𝐷𝑜𝑚 ∧𝐺−𝑖 ∧¬𝑑𝑥 ) ∨(cid:212)1≤𝑦 ≤𝑛 (𝐷𝑜𝑚 ∧𝐺−𝑖 ∧
¬𝑔𝑦), which is equivalent to (cid:212)1≤𝑥 ≤𝑚 (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑑𝑥 ) ∨
(cid:212)1≤𝑦 ≤𝑛 (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑔𝑦) ∨ (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑔𝑖 ). Also,
(cid:212)1≤𝑥 ≤𝑚 (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑑𝑥 ) ∨ (cid:212)1≤𝑦 ≤𝑛 (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑔𝑦)
equals to false, because 𝑑𝑥 ∈ 𝐷𝑜𝑚 and 𝑔𝑦 ∈ 𝐺−𝑖 must be
true. So 𝜙 = 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑔𝑖 is true. Finally, since 𝑆 has
no extra goal, there is no 𝑔𝑖 such that 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ⇒ 𝑔𝑖 , so
𝜙 = 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑔𝑖 is satisfiable.

• non-triviality: From the definition, 𝑁𝐺𝐷 = ¬(𝐷𝑜𝑚 ∧ 𝐺) =
¬𝐷𝑜𝑚 ∨ ¬𝐺. Then 𝑁𝐺𝐷 ≡ 𝐺 is true implies that (¬𝐷𝑜𝑚 ∨
¬𝐺) ⇒ ¬𝐺 is true (The other direction is true straightfor-
ward.), which implies (¬𝐷𝑜𝑚 ∨ ¬𝐺) ∧ 𝐺 = ¬𝐷𝑜𝑚 ∧ 𝐺 is
unsatisfiable. However, it is contract to the fact that 𝑆 has
influential domain properties, i.e., ¬𝐷𝑜𝑚 ∧ 𝐺 is satisfiable
as 𝐺 can not imply 𝐷𝑜𝑚. Therefore, ¬𝐺 (cid:46) 𝑁𝐺𝐷 is true.

□

We have obtained the single boundary condition that can reduce
any other BCs through the generality metric, which means 𝑁𝐺𝐷
catches all the possible divergences. This is also in line with the
meaning of the LTL formula representing 𝑁𝐺𝐷.

Although 𝑁𝐺𝐷 does not violate the non-triviality condition, it is
obviously more trivial than ¬𝐺, for ¬𝐺 ⇒ 𝑁𝐺𝐷 is true. As a result,
the divergence described by 𝑁𝐺𝐷 is too general and we should
generate the BC 𝜙 to satisfy 𝜙 ⇒ ¬𝐺. The method to generate such
BCs will be described in next subsection.

4.2 Generation of BCs
In this section, we will narrow the scope of BC into ¬𝐺 by the
contrasty metric. Then we introduce the algorithm for generating
BCs by further manipulating ¬𝐺 on the syntactical level. We first
show the theorem below to describe a “better” BC than NGD.

Theorem 4. Let 𝜙 be a BC of the scene 𝑆 = (𝐺, 𝐷𝑜𝑚) and ¬𝜙 ⇒
𝑔𝑥 for some 1 ≤ 𝑥 ≤ |𝐺 |. Then 𝜙 is a witness of 𝑁𝐺𝐷 = ¬(𝐷𝑜𝑚 ∧𝐺).

Proof. We prove the theorem by showing that 𝜓 = 𝑁𝐺𝐷 ∧ ¬𝜙
is not a BC of 𝑆, because 𝜓 does not satisfy the minimality condition
of Definition 2. In fact,
𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ 𝜓

= 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ (¬(𝐷𝑜𝑚 ∧ 𝐺) ∧ ¬𝜙)
= 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝐺 ∧ ¬𝜙

= 𝐷𝑜𝑚 ∧ ¬𝑔𝑖 ∧ ¬𝜙
Since ¬𝜙 ⇒ 𝑔𝑥 for some 1 ≤ 𝑥 ≤ |𝐺 | is true, so ¬𝜙 ∧ ¬𝑔𝑥 is unsat-
isfiable. Let 𝑖 = 𝑥 and we know that 𝐷𝑜𝑚 ∧ 𝐺−𝑥 ∧𝜓 is unsatisfiable,
□
which violates the minimality condition of Definition 2.

Theorem 4 indicates that, for any BC 𝜙 satisfying 𝜙 ⇒ 𝑔𝑥 for
some 1 ≤ 𝑥 ≤ |𝐺 |, 𝜙 is a better BC than 𝑁𝐺𝐷, according to Defi-
nition 4. Such observation inspires us to construct such 𝜙 as the
target BC. In order to achieve that, we introduce at first the concept
of special case as follows.

Definition 7 (Special Case). Let 𝜙 and 𝜓 be LTL formulas. 𝜙 is

a special case of 𝜓 , if (𝜙 ⇒ 𝜓 ) and (𝜓 ⇏ 𝜙).

Definition 7 can be understood more clearly from the perspective
of automata. For 𝜙 being a special case of 𝜓 , we expect 𝐴𝜓 is a part
of A𝜙 , i.e., traces accepted by A𝜓 should be accepted by 𝐴𝜙 as well.
Note that the negation of the set of goals, i.e., ¬𝐺 can be written
as a disjunctive form of ¬𝑔1 ∨ ¬𝑔2 ∨ · · · ∨ ¬𝑔𝑛. Now we have the
following definition.

Definition 8 (Syntactical Substitution). Let 𝐺 = {𝑔𝑖

| 1 ≤
𝑖 ≤ |𝐺 |} be the set of goals. The notation ¬𝐺 (𝑖,𝜓 ) is defined to
represent the formula ¬𝑔1 ∨¬𝑔2 ∨. . .∨¬𝑔𝑖−1 ∨𝜓 ∨¬𝑔𝑖+1 ∨. . .∨¬𝑔 |𝐺 |.
Informally speaking, ¬𝐺 (𝑖,𝜓 ) represents the formula by substi-
tuting ¬𝑔𝑖 with 𝜓 in the formula ¬𝐺. Then we have the following
theorem.

Theorem 5. Let 𝜙 = ¬𝐺 (𝑖,𝜓 ) where 𝜓 is a special case of ¬𝑔𝑖 ,

and 𝜙 is a BC if 𝜓 ∧ 𝐷𝑜𝑚 ∧ 𝐺 is satisfiable.

Proof. The potential BC 𝜙 is ¬𝑔1 ∨ · · · ∨ 𝜓 ∨ · · · ∨ ¬𝑔𝑛 after
replacing ¬𝑔𝑥 by 𝜓 , (𝜓 ⇒ 𝑔𝑥 ) and (𝑔𝑥 ⇏ 𝜓 ). And now we prove
𝜙 can satisfy all three conditions of Definition 2.

• logical inconsistency: From Definition 8, 𝜙 ⇒ ¬𝐺 is true.

Therefore, 𝐷𝑜𝑚 ∧ 𝐺 ∧ 𝜙 is unsatisfiable.

• minimality: We now prove 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ 𝜙 is satisfiable for

each 1 ≤ 𝑖 ≤ |𝐺 |. For the situation of 𝑖 ≠ 𝑥, (cid:212)1≤ 𝑗 ≤𝑛,𝑗≠𝑖,𝑗≠𝑥 (𝐷𝑜𝑚∧
𝐺−𝑖 ∧¬𝑔𝑗 )∨(𝐷𝑜𝑚∧𝐺−𝑖 ∧¬𝑔𝑖 )∨(𝐷𝑜𝑚∧𝐺−𝑖 ∧𝜓 ) is satisfiable,
because the pruned scenario guaranteed that 𝐷𝑜𝑚∧𝐺−𝑖 ∧¬𝑔𝑖
is always satisfiable. And in the situation of 𝑖 = 𝑥, the result
of (cid:212)1≤ 𝑗 ≤𝑛,𝑗≠𝑖 (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ ¬𝑔𝑗 ) ∨ (𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ 𝑠) is de-
cided by 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ 𝜓 . So if 𝜓 ∧ 𝐷𝑜𝑚 ∧ 𝐺−𝑖 is satisfiable,
the condition of minimality is satisfied.

• non-triviality: 𝜙 is assured to not be semantically equal to
¬𝐺, because it is just obtained by changing the semantics of
¬𝐺, or more accurately, by narrowing the scope of ¬𝐺.

□

Definition 8 conducts our first approach to identify boundary
conditions and Theorem 5 shows the guarantee of correctness. We
replace one item (¬𝑔𝑖 ) in ¬𝐺 with its special case 𝜓 . If the special
case satisfies the condition 𝜓 ∧ 𝐷𝑜𝑚 ∧ 𝐺−𝑖 , then we have already
generated a BC, and there is no need to check whether it satisfies
the conditions.

According to the contrasty metric, all the filtered BCs should
imply ¬𝐺, which allow the generated BCs firstly meet the logical-
inconsistency condition. Secondly, the constructed special cases
should make the minimality condition satisfied. Finally, by the

substitution on the syntax of ¬𝐺, we also make BC satisfy the
non-triviality condition.

Finally, we make the following statement to show the effec-
tiveness of SyntacBC, which can be guaranteed by Theorem 4,
Definition 8 and Theorem 5.

Remark. The BCs computed from SyntacBC are “better” than

NGD, according to Definition 4.

4.3 Implementation
In this section, we describe the detailed implementation of the BC
quick generation algorithm that is based on Definition 8.

Algorithm 1 SyntacBC: Computing BC based on Syntactical Sub-
stitution

1: procedure SyntacBC( 𝑆𝑐𝑒𝑛𝑒 𝑆)
2:

𝐵𝐶 ← ∅
if 𝑒𝑥𝑡𝑟𝑎𝐺𝑜𝑎𝑙𝑖𝑛(𝑆) then

3:

4:

5:

6:

7:

8:

9:

10:

11:

return 𝐵𝐶

for each 𝑔𝑖 ∈ 𝑔𝑜𝑎𝑙𝑠 do

𝑠𝑐 = 𝐺𝑒𝑡𝑆𝑝𝑒𝑐𝑖𝑎𝑙𝑐𝑎𝑠𝑒𝐵𝑦𝑇 𝑒𝑚𝑝𝑙𝑎𝑡𝑒 (¬𝑔𝑖, 𝑆)
if 𝑆𝐴𝑇 (𝑠𝑐 ∧ 𝐷𝑜𝑚 ∧ 𝐺−𝑖 ) then

𝐺−𝑖 ← (cid:211)𝑗≠𝑖
1≤ 𝑗 ≤𝑛 𝑔𝑗
𝐵𝐶 ← 𝐵𝐶 ∪ {𝑠𝑐 ∨ ¬𝐺−𝑖 }
𝐵𝐶 ← 𝐶𝑜𝑛𝑡𝑟𝑎𝑠𝑡𝑦𝑀𝑒𝑡𝑟𝑖𝑐𝑅𝑒𝑑𝑢𝑐𝑡𝑖𝑜𝑛(𝐵𝐶)
return 𝐵𝐶

Algorithm 1 details the execution process of SyntacBC. It accepts
a scene 𝑆 as the input and outputs the reduced BCs. In line 3, if we
find that there are extra goals in 𝑆, then the program can return
empty directly, for no BC is in 𝑆.

In line 6, for each 𝑔𝑖 in the goal set, we find the special case of
¬𝑔𝑖 . We use the method of formula templates to get special cases,
which is implemented in the 𝐺𝑒𝑡𝑆𝑝𝑒𝑐𝑖𝑎𝑙𝑐𝑎𝑠𝑒𝐵𝑦𝑇 𝑒𝑚𝑝𝑙𝑎𝑡𝑒 function
in the algorithm. Table 1 lists all the corresponding special cases
according to the LTL syntaxs. For example, the special case of 𝑎 ∨ 𝑏
can be 𝑎 or 𝑏. However, when the semantics represented by the
formula itself are very limited, other atomic propositions are needed
for further reduction. For example, when the ¬𝑔𝑖 formula is 𝑎 ∧ 𝑏,
we find an atomic proposition 𝑝 that exists in 𝐺−𝑖 but does not exist
in 𝑔𝑖 , and let the special case be 𝑎 ∧ 𝑏 ∧ 𝑝.

Table 1: LTL formula and the corresponding special cases

¬𝑔𝑖
𝑡𝑡
𝑎
¬𝑎
𝑎 ∧ 𝑏

special case
𝑝
𝑎 ∧ 𝑝
¬𝑎 ∧ 𝑝
𝑎 ∧ 𝑏 ∧ 𝑝

¬𝑔𝑖
𝑎 ∨ 𝑏
□𝑎
𝑎𝑈 𝑏
𝑎𝑅𝑏

special case
𝑎, 𝑏
□𝑎 ∧ 𝑝
𝑏, 𝑎 ∧ ◦𝑏
𝑏 ∧ ◦𝑎, 𝑎

Then we check whether the obtained special case satisfies that
𝑠𝑐∧𝐷𝑜𝑚∧𝐺−𝑖 is satisfiable at line 7. For 𝑠𝑐 that meets the conditions,
we can directly construct one BC 𝑠𝑐 ∨ ¬𝐺−𝑖 . Finally, we use the
contrasty metric to reduce the redundant BCs.

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

4.4 Results and Evaluation
In this section, we evaluated our SyntacBC method and compared
it with the previous method.

Setups. We built our BC solver according to Algorithm 1.
4.4.1
We used Spot [8] as the LTL satisfiability (LTL-SAT) solver. It first
translates the LTL formula to the corresponding automaton, and
then checks whether the automaton is empty to determine the
satisfiability of formula. All experiments were carried out on a
system with AMD Ryzen 9 5900HX and 16 GB memory under
Linux WSL (Ubuntu 20.04).

4.4.2 Benchmarks. We compare and evaluate our method on the
15 different cases introduced in [6]. We compare our method with
JFc (Joint framework to interleave filtering based on the contrast
metric) proposed in [26], which is the state-of-art BC solver.

4.4.3 Evaluation. Table 2 shows the comparison between our Syn-
tacBC method and JFc on the 15 requirement cases.

The way we compared the JFc to SyntacBC is described as fol-
lows: we run the solvers, JFc and SyntacBC, on the same case. |𝐵𝐶 |
represents the number of solved 𝐵𝐶 before filtering. |𝐵𝐶𝑐 | repre-
sents the number of BCs after filtering by using the contrasty metric,
and time consumption for solving and filtering of two solvers is
represented by 𝑡. For JFc, we run the learning algorithm 10 times,
#𝑠𝑢𝑐. represents the number of learning times that BC can be suc-
cessfully solved, so the |𝐵𝐶𝑐 |, 𝑡 represents the average result of 10
times run.

Both tools output a set of BCs, we let {𝐵𝐶 𝑗 } as the set solved by
JFc and {𝐵𝐶𝑠 } by SyntacBC, we use the contrasty metric introduced
in the previous study to further reduce the number of BCs in the
set {𝐵𝐶 𝑗 , 𝐵𝐶𝑠 }. Column 𝑐(coverage) represents what percentage of
BCs in set {𝐵𝐶 𝑗 } will be computed to be redundant because of the
BCs in set {𝐵𝐶𝑠 }. In detail, let 𝑏𝑐 𝑗 and 𝑏𝑐𝑠 be one BC in set {𝐵𝐶 𝑗 }
and {𝐵𝐶𝑠 } correspondingly, then 𝑐 equals to (the number of 𝑏𝑐𝑠 is
the witness of 𝑏𝑐 𝑗 but 𝑏𝑐 𝑗 is not that of 𝑏𝑐𝑠 )/(the number of 𝑏𝑐 𝑗 ).
First of all, the SyntacBC method has significant advantages in
time cost. On larger scale cases, a certain time cost comes from using
Spot to perform LTL-SAT check, but overall, SyntacBC achieves a
>1000X speed-up than JFc.

For the last two examples LB and LC, because there are extra
goals in the examples, our method judges that there is no BC in
them according to Theorem 2. But JFc solves the BC out incorrectly
because of the bug of the LTL-SAT checker it uses.

Notably, the 𝑏𝑐𝑠 obtained by the SyntacBC is always the
witness of the 𝑏𝑐 𝑗 obtained by the JFc, which means that 𝑏𝑐𝑠 can
capture all the divergences captured by 𝑏𝑐 𝑗 . And column 𝑐(coverage)
shows that, in the cases of larger scale, it is difficult for JFc to solve
𝑏𝑐 𝑗 , which can not be filtered by 𝑏𝑐𝑠 . But in all cases, 𝑏𝑐𝑠 cannot be
filtered out.

4.5 Discussion
The results prove the superiority of SyntacBC in speed and the
quality of the solved BCs. The advantage on time cost benefits
from our theoretical-based method, which significantly reduces
the number of calls to the LTL-SAT solver compared to the genetic
algorithm-based method. The BCs solved by the SyntacBC method
is difficult to be filtered because we construct BC according to the

Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Table 2: Comparison on the performance beween JFc and SyntacBC.

case

RP1
RP2
Ele
TCP
AAP
MP
ATM
RRCS
Tel
LAS
PA
RRA
SA
LB
LC

|𝐵𝐶𝑐 |
1.5
1.5
2.9
1.8
2.4
2
2
0.9
0.2
0
0.1
1.1
0.2
0.4
1

JFc
𝑡 (𝑠)
851.6
823.5
1610.4
1510.1
1875.9
1318.2
1908.4
43.5
223.6
201.4
703.2
1653.6
749
1809.8
4150.2

#𝑠𝑢𝑐.
9
9
10
8
10
9
10
9
9
0
1
9
2
4
10

|𝐵𝐶 |
4
4
4
4
4
4
4
3
4
10
12
6
7
0
0

SyntacBC
|𝐵𝐶𝑐 |
2
1
2
2
1
1
1
2
2
4
3
3
2
0
0

𝑡 (𝑠)
0.002
0.003
0.003
0.004
0.006
0.005
0.006
0.008
0.007
0.020
0.144
0.040
0.075
0.140
3.580

𝑐
0.467
0.733
0.81
1
0.875
0.85
0.8
0
1
1
1
1
1
n/a
n/a

SemanticBC
|𝐵𝐶𝑤 |
0
0
0
0
0
10
0
0
0
0
176
42
93
0
436

𝑡 (𝑠)
0.003
0.006
0.005
0.010
0.023
0.050
0.013
0.036
0.075
0.047
37.379
6.260
8.134
2.128
283.639

|𝐵𝐶𝑡 |
1
2
2
5
10
5
0
0
6
1
262
0
1
13
0

definition of BC, and ensure that it satisfies the definition to a lesser
extent.

Even though SyntacBC is very efficient to solve BCs, when we
want to understand what events implied by those BCs can lead
to the divergence of goals, we find it very difficult to interpret
them. The reason is because these BCs can be thought of as simply
combining the negation of each goal with the ‘∨’ operator.

By studying the definition of BC and results, we believe that
the non-triviality condition is not enough to ensure that the solved
BC has a definite meaning. After observing the BCs sovled by
two methods, we found that some BCs obtained by the genetic
algorithm-based method are easy to understand. So in Section 5,
by summarizing their common properties in form of formula, we
define a new form of BCs and design a new method to sovle them.

5 IDENTIFYING BOUNDARY CONDITIONS

BASED ON LTL SEMANTICS

In this section, we describe how to confirm BC with definite mean-
ing between two goals, which leverages the semantic information of
LTL formulas. The approach is named SemanticBC. We first reduce
the problem of solving BC into a set of two goals, then we define
the trace formula be the form of meaningful BC and the method
of Synthesis of trace formula to solve BC. Section 5.1 presents the
theoretic foundations of SemanticBC, Section 5.2 gives the detailed
implementation, and Section 5.3 shows the experimental results of
our method on the benchmarks.

5.1 SemanticBC
We first show the fact in Theorem 6 that the 𝐵𝐶 computation for
the goal set 𝐺, whose size is greater than 2, can be always reducible
to that for the goal set 𝐺 ′ whose size is exactly 2.

Theorem 6 (𝐵𝐶 Reduction). Let 𝐺 be a goal set with |𝐺 | > 2
and 𝐷𝑜𝑚 be a domain set. Then 𝜙 is a BC of 𝐺 under 𝐷𝑜𝑚 implies

that there is 𝐺 ′ ⊆ 𝐺 with |𝐺 ′| = 2 and 𝜙 is the BC of 𝐺 ′ under
𝐷𝑜𝑚 ∪ (𝐺\𝐺 ′).

Proof. We prove by the induction over the size of 𝐺.
(1) Basically, let 𝑘 = |𝐺 | > 2 and we know 𝜙 is a BC of 𝐺.
Therefore, we have 1) 𝐷𝑜𝑚 ∧ 𝐺 ∧ 𝜙 is unsatisfiable; and 2)
𝐷𝑜𝑚 ∧ 𝐺−𝑖 ∧ 𝜙 is satisfiable for each 1 ≤ 𝑖 ≤ 𝑛; and 3) 𝜙 is
not syntactically equivalent to ¬𝐺.

(2) Inductively, for 𝐺 ′ ⊆ 𝐺 with |𝐺 ′| = 𝑘 − 1 ≥ 2, we prove that
𝜙 is a BC of 𝐺 ′ under 𝐷𝑜𝑚 ∪ (𝐺\𝐺 ′). Assume 𝐺\𝐺 ′ = {𝑔𝑗 },
i.e., 𝐺 ′ is acquired by removing 𝑔𝑗 (1 ≤ 𝑗 ≤ |𝐺 |) from 𝐺. As a
result, 𝐺 ′ = 𝐺−𝑗 . From the assumption hypothesis, we have
that 1) (𝐷𝑜𝑚 ∧𝑔𝑗 ) ∧𝐺−𝑗 ∧ 𝜙 = 𝐷𝑜𝑚 ∧𝐺 ∧ 𝜙 is unsatisfiable;
and 2) (𝐷𝑜𝑚∧𝑔𝑗 )∧𝐺−𝑗 −𝑖 ∧𝜙 = 𝐷𝑜𝑚∧𝐺−𝑖 ∧𝜙 is satisfiable for
1 ≤ 𝑖 ≤ |𝐺 | and 𝑖 ≠ 𝑗; and 3) 𝜙 is not syntactally equivalent to
¬𝐺−𝑗 , as it cannot be a BC of 𝐺 under 𝐷𝑜𝑚. From Definition
2, 𝜙 is a BC of 𝐺 ′ under the domain 𝐷𝑜𝑚 ∪ (𝐺\𝐺 ′).
Now we have proved that 𝜙 is a BC of 𝐺 with |𝐺 | = 𝑘 > 2 under
𝐷𝑜𝑚 implies 𝜙 is also the BC of 𝐺 ′ with |𝐺 ′| = 𝑘 − 1 ≥ 2 and
𝐺 ′ ⊆ 𝐺 under 𝐷𝑜𝑚 ∪ (𝐺\𝐺 ′). Continue the above process until
□
𝑘 = 2 and we can prove the theorem.

In principle, Theorem 6 provides a simpler way to compute the
BC of some goal set 𝐺, whose size is greater than 2, under a domain
set 𝐷𝑜𝑚, by spliting 𝐺 to two sets 𝐺1, 𝐺2 such that |𝐺1| = 2 and
𝐷𝑜𝑚′ = 𝐷𝑜𝑚 ∪ 𝐺2, and then compute the BC of 𝐺2 under the new
domain 𝐷𝑜𝑚′.

Theorem 7. Let 𝐺 = {𝑔1, 𝑔2} be a goal set and 𝐷𝑜𝑚 be the

domain,

(1) (𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2) ∨ (𝐷𝑜𝑚 ∧ 𝑔2 ∧ ¬𝑔1) is a BC of 𝐺 under

𝐷𝑜𝑚; and

(2) For any other BC 𝜙 of 𝐺 under 𝐷𝑜𝑚, (𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2) ∨
(𝐷𝑜𝑚 ∧𝑔2 ∧ ¬𝑔1) is the witness of 𝜙 holds, i.e., 𝜙 ∧ ¬((𝐷𝑜𝑚 ∧
𝑔1 ∧ ¬𝑔2) ∨ (𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2)) is not a BC of 𝐺 under 𝐷𝑜𝑚.

Proof. Let 𝜓 = (𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2) ∨ (𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2),

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

(1) Firstly, 𝐷𝑜𝑚 ∧ 𝑔1 ∧ 𝑔2 ∧ 𝜓 is unsatisfiable; Secondly, it is
trivial to check 𝐷𝑜𝑚 ∧𝑔𝑖 ∧𝜓 is satisfiable for 𝑖 = 1, 2; Thirdly,
𝜓 ¬ ≡ (¬𝑔1 ∨ ¬𝑔2) is also true. As a result, 𝜓 is a BC of 𝐺
under 𝐷𝑜𝑚.

(2) To prove that 𝜙 ∧ ¬𝜓 is not a BC, we show it does not satisfy

the minimality condition in Definition 2. In fact,
𝐷𝑜𝑚 ∧ 𝑔1 ∧ 𝜙 ∧ ¬𝜓
≡ 𝐷𝑜𝑚 ∧ 𝑔1 ∧ 𝜙 ∧ (¬𝐷𝑜𝑚 ∨ ¬𝑔1 ∨ 𝑔2) ∧ (¬𝐷𝑜𝑚 ∨ 𝑔1 ∨ ¬𝑔2)
≡ 𝐷𝑜𝑚 ∧ 𝑔1 ∧ 𝜙 ∧ (¬𝐷𝑜𝑚 ∨ (¬𝑔1 ∧ ¬𝑔2) ∨ (𝑔1 ∧ 𝑔2))
≡ false

So from Definition 2, 𝜙 ∧ ¬𝜓 is not a BC. The proof is done.

□

Figure 2: The synthesis 𝜙 of two trace formulas 𝜙1 and 𝜙2.

Theorem 7 indicates that𝜓 = (𝐷𝑜𝑚∧𝑔1∧¬𝑔2)∨(𝐷𝑜𝑚∧¬𝑔1∧𝑔2)
is the so-called “good” BC satisfying Definition 4, since it is the
witness of any other BC. However, 𝜓 is an ∨ formula such that
each disjunctive element captures only the circumstance of one
goal, which does not reflect the divergence in the system level. As
a result, 𝜓 is not considered as a “meaningful” BC. Next, we define
a form of BC which we consider is “meaningful”.

Definition 9 (Trace Formula). A trace formula 𝜙 = 𝑝𝑟𝑒 𝑓 𝑖𝑥 (𝜙)∧

𝑙𝑜𝑜𝑝 (𝜙) is an LTL formula such that

• 𝑝𝑟𝑒 𝑓 𝑖𝑥 (𝜙) has the form of (cid:211)0≤𝑖 ≤𝑛 ◦𝑖𝑝𝑖 (𝑛 ≥ 0), where 𝑝𝑖
is a conjunctive formula of literals, ◦0 (𝑝) = 𝑝 and ◦𝑖+1𝑝 =
◦(◦𝑖𝑝) for 𝑖 ≥ 0;
• 𝑙𝑜𝑜𝑝 (𝜙) = ◦𝑛+1□𝑝𝑛+1.
From the perspective of automata theory, a trace formula rep-
resents an infinite trace of an automaton, which is identified by
both the prefix and loop parts such that the length of the prefix is
finite and the loop is just the single self-loop for the trace ending.
As shown in Figure 2, 𝜙, 𝜙1, 𝜙2 are all trace formulas. For such for-
mulas, their behaviors are easy for users to check, and we argue
that they can be “meaningful” BCs.

Remark. A BC 𝜙 is considered to be meaningful if it is a trace

formula.

Now we introduce the operation of synthesis on two given trace
formulas, essentially a BC constructed from the two trace formulas
that are not BCs. Before that, we first define 𝑓 𝑢𝑠𝑒 (𝑐1, 𝑐2) = 𝑝1 ∧ 𝑝2
if 𝑐1 = 𝑝1 ∧ 𝑎 and 𝑐2 = 𝑝2 ∧ ¬𝑎, i.e., 𝑐1, 𝑐2 have only one different
literal; Otherwise, 𝑓 𝑢𝑠𝑒 (𝑐1, 𝑐2) = false.

Definition 10 (Synthesis of Trace Formulas). Given two trace
1 and 𝜙2 = (cid:211)0≤𝑖 ≤𝑛 ◦𝑖𝑝𝑖
1∧◦𝑛+1□𝑝𝑛+1

2∧
2, the synthesis of 𝜙1, 𝜙2 is a trace formula 𝜙 = (cid:211)0≤𝑖 ≤𝑛 ◦𝑖𝑝𝑖 ∧

formulas 𝜙1 = (cid:211)0≤𝑖 ≤𝑛 ◦𝑖𝑝𝑖
◦𝑛+1□𝑝𝑛+1
◦𝑛+1□𝑝𝑛+1 such that
• 𝑝 𝑗 = 𝑓 𝑢𝑠𝑒 (𝑝 𝑗
1 ∧ 𝑝𝑖
• 𝑝𝑖 = 𝑝𝑖
• 𝑝𝑖 (cid:46) false for every 0 ≤ 𝑖 ≤ 𝑛 + 1.

1, 𝑝 𝑗
2) for some 0 ≤ 𝑗 ≤ 𝑛 + 1; and
2 for every 0 ≤ (𝑖 ≠ 𝑗) ≤ 𝑛 + 1; and

As illustrated in Figure 2, 𝜙 is the systhesis of two trace formulas
𝜙1 and 𝜙2. Below shows the insight why we need the synthesis of
two trace formulas for BC computation.

Proof. (Sketch) Firstly, from Definition 10 it is not hard to prove
that 𝜙 ⇒ (𝜙1 ∨ 𝜙2), which implies that 𝜙 ⇒ ((𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2) ∨
(𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2)) holds. Based on Theorem 7, we know (𝐷𝑜𝑚 ∧
𝑔1 ∧ ¬𝑔2) ∨ (𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2) is a BC of 𝐺 under 𝐷𝑜𝑚. As a result,
𝐷𝑜𝑚∧𝑔1∧𝑔2∧𝜙 is unsatisfiable. Secondly, we show that 𝐷𝑜𝑚∧𝑔1∧𝜙
is satisfiable, as from Definition 10 there is 𝜙 ′ ⇒ 𝜙 such that
𝜙 ′ ⇒ 𝑔1. The same applies to the proof that 𝐷𝑜𝑚 ∧ 𝑔2 ∧ 𝜙 is
satisfiable. Thirdly, it is easy to check that 𝜙 (cid:46) 𝐺 is true. Therefore,
□
𝜙 is a BC of 𝐺 under 𝐷𝑜𝑚.

5.2 Implementation
We first define the Synthesis Product operation to implement the
synthesis of trace formulas efficiently.

Definition 11 (Synthesis Product). Given two Büchi automata
A1 = (2𝐴𝑃 , 𝑄1, Δ1, 𝑞1
0, 𝐹2), the syn-
thesis product is defined as A = A1 ∧∗ A2 = (2𝐴𝑃 , 𝑄, Δ, 𝑞0, 𝐹 ),
where:

0, 𝐹1) and A2 = (2𝐴𝑃 , 𝑄2, Δ2, 𝑞2

• 𝑄 = 𝑄1 × 𝑄2 × {1, 2};
• Δ3 = Δ′ ∪ Δ′′:
– Δ′ = {((𝑞1, 𝑞2, 1), 𝑎, (𝑞1 ′, 𝑞2 ′, 𝑖)) | (𝑞1, 𝑎1, 𝑞′

1) ∈ Δ1, (𝑞2, 𝑎2, 𝑞′
2)
∈ Δ2, if 𝑞1 ∈ 𝐹1 then 𝑖 = 2 else 𝑖 = 1, and 𝒊𝒇 𝒂1 = 𝒂2 𝒕𝒉𝒆𝒏 𝒂 =
𝒂1 = 𝒂2 𝒆𝒍𝒔𝒆 𝒂 = 𝒇 𝒖𝒔𝒆(𝒂1, 𝒂2) },

– Δ′′ = {((𝑞1, 𝑞2, 2), 𝑎, (𝑞1 ′, 𝑞2 ′, 𝑖)) | (𝑞1, 𝑎, 𝑞′

1) ∈ Δ1, (𝑞2, 𝑎, 𝑞′
2)
∈ Δ2, if 𝑞2 ∈ 𝐹2 then 𝑖 = 1 else 𝑖 = 2, and 𝒊𝒇 𝒂1 = 𝒂2 𝒕𝒉𝒆𝒏 𝒂 =
𝒂1 = 𝒂2 𝒆𝒍𝒔𝒆 𝒂 = 𝒇 𝒖𝒔𝒆(𝒂1, 𝒂2) };

• 𝑞0 = 𝑞1
• 𝐹 = {(𝑞1, 𝑞2, 2) | 𝑞2 ∈ 𝐹2}.

0 × {1};

0 × 𝑞2

Synthesis Product is the ordinary Büchi automata product with
little manipulation. For the calculation of each transition, a new
transition that 𝑎 = 𝑓 𝑢𝑠𝑒 (𝑎1, 𝑎2) is added. Therefore, there are two
kinds of transitions in the product result automaton, (1) transitions
calculated by intersection, and (2) transitions calculated by fusion.

Theorem 8. Given 𝐺 = {𝑔1, 𝑔2} be a goal set, 𝐷𝑜𝑚 be the do-
main and trace formulas 𝜙1, 𝜙2 that 𝜙1 ⇒ 𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2, 𝜙2 ⇒
𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2. Let A = A𝐷𝑜𝑚∧¬𝑔1∧𝑔2 ∧∗ A𝐷𝑜𝑚∧𝑔1∧¬𝑔2 . If 𝜙 is
the synthesis of 𝜙1 and 𝜙2, then L (𝜙) ⊆ L (A).

Lemma 1. Given two trace formulas 𝜙1, 𝜙2 such that 𝜙1 ⇒
(𝐷𝑜𝑚 ∧ 𝑔1 ∧ ¬𝑔2) and 𝜙2 ⇒ (𝐷𝑜𝑚 ∧ ¬𝑔1 ∧ 𝑔2) hold, let 𝜙 be
the synthesis of 𝜙1 and 𝜙2. It is true that 𝜙 is a BC of 𝐺 = {𝑔1, 𝑔2}
under 𝐷𝑜𝑚.

Proof. (Sketch) According to Definition 11 and Definition 10,
a trace formula 𝜙 satisfying L (𝜙) ⊆ A is a synthesis of two trace
formulas 𝜙1 satisfying L (𝜙1) ⊆ L (A1) and 𝜙2 satisfying L (𝜙2) ⊆
□
L (A2).

……𝑝𝑗+1=𝑓𝑢𝑠𝑒(𝑝𝑗+11,𝑝𝑗+12)𝑝𝑗=𝑝𝑗1∧𝑝𝑗2𝑝𝑛+1𝜙……𝑝𝑗+11𝑝𝑗1𝑝𝑛+11𝜙1……𝑝𝑗+12𝑝𝑗2𝑝𝑛+12𝜙2Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

Algorithm 2 SemanticBC: Identifying BC by Synthesis Product

1: procedure semanticBC( 𝑆𝑐𝑒𝑛𝑒 𝑆)
2:

𝐵𝐶𝑠 ← ∅, 𝐺 ′𝑠 ← ∅
for each two goals 𝑔𝑖, 𝑔𝑗 ∈ 𝐺 do

3:

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

A𝑖 ← 𝑡𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑒 (𝐷𝑜𝑚 ∪ (𝐺\𝑔𝑖 ) ∪ ¬𝑔𝑖 )
A 𝑗 ← 𝑡𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑒 (𝐷𝑜𝑚 ∪ (𝐺\𝑔𝑗 ) ∪ ¬𝑔𝑗 )
A𝜙 ← A𝑖 ∧∗ A 𝑗
for each fusion transition 𝑡𝑖 in A do

Delete all fusion transitions in A except 𝑡𝑖
if there is a run 𝑟 in A then

𝐵𝐶𝑠 ← 𝐵𝐶𝑠 ∪ 𝑡𝑟𝑎𝑛𝑠 𝑓 𝑒𝑟𝑇𝑜𝐹𝑜𝑟𝑚𝑢𝑙𝑎(𝑟 )
𝐺 ′𝑠 ← 𝐺 ′𝑠 ∪ {𝑔𝑖, 𝑔𝑗 }

Restore all fusion transitions in A

return 𝐵𝐶𝑠, 𝐺 ′𝑠

With Theorem 8, we design Algorithm 2 to identify BCs by the
Synthesis Product. It accepts a scene 𝑆 as input, and outputs BCs
and their corresponding scope 𝐺 ′.

and A𝐷𝑜𝑚∧𝑔𝑗 ∧¬𝑔𝑖

For any two goals 𝑔𝑖 and 𝑔𝑗 in the goals set, we solve their BCs.
We first get two automata A𝐷𝑜𝑚∧𝑔𝑖 ∧¬𝑔𝑗
, and
then get the automaton A𝜙 through Synthesis Product. According
to Definition 10, we need to identify the trace formulas that have
only performed the fusion operation once during the run. Thus,
we pick a transition edge 𝑡𝑖 generated by fusion, and then delete
the others. Then we check whether the automaton A still has an
accepting run. If there is a run and it can be converted into an LTL
formula, then we get a BC.

In the process of Synthesis Product, some edges in A are sup-
plemented by the fuse operation, which ignores a conflict atomic
proposition. We record all these edges, and we can also decide
which conflict of atomic propositions can be fused. For example, in
the MPC example, high water level(ℎ) and methane existing(𝑚) are
the environment variables, and it is meaningless to pay attention
to their contradictions. We are concerned with whether the system
should turn on pump(𝑝) at some moment. Therefore, before run-
ning Synthesis Product, we can set 𝑝 be the literal that could be
fused.

In the whole process of SemanticBC, LTL-SAT checking is not
required, nor do the solved BCs need to be validated. The following
theorem guarantees that the output of Algorithm 2 is a BC of 𝑆.

Theorem 9 (Correctness). Every element of the output 𝐵𝐶𝑠 in

Algorithm 2 is a BC of 𝑆.

Proof. First from Theorem 8, we know the synthesis 𝜙 of 𝜙1 =
𝐷𝑜𝑚∧𝑔1∧¬𝑔2 and 𝜙2 = 𝐷𝑜𝑚∧¬𝑔1∧𝑔2 satisfies that L (𝜙) ⊆ L (A),
where A = A𝜙1 ∧∗ A𝜙2
. However, A does not only contains
languages which can be represented by the synthesis of two trace
formulas from A𝜙1
. Line 8 guarantees that the algorithm
deletes all other languages that are not a synthesis trace formula,
i.e., 𝐵𝐶𝑠 stores all synthesis trace formulas. Finally, Lemma 1 shows
that a synthesis trace formula is a BC of 𝑆. The proof is done. □

and A𝜙2

5.3 Evaluation
We use two research questions to guide our result evaluation. The
experimental setup and benchmarks are the same as in Section 4.4.

5.3.1 𝑅𝑄1. Can SemanticBC find the BCs represented by a trace for-
mula? To answer 𝑅𝑄1, we compare the performance of SemanticBC
to that of both the JFc and SyntacBC.

Table 2 shows the number of BC solved by SemanticBC and
the time required. |𝐵𝐶𝑡 | represents the number of solved BCs in
the form of trace formula, |𝐵𝐶𝑤 | represents the number of words
accepted by the automaton A𝜙 but cannot be transformed into an
LTL formula2, and 𝑡 represents the time required.

SemanticBC solves BCs on all instances excluding the ATM and
RRCS. For the LAS case where JFc cannot solve BC after 10 runs,
SemanticBC successfully computes one BC. For the cases LB and
LC, we know that they do not contain BC on the original setting of
𝐷𝑜𝑚 and 𝐺 for extra goals. But the SemanticBC will reduce the goal
set for solving, so as to solve the BC that exists in the 𝐺 ′ ⊂ 𝐺. The
time cost of SemanticBC has a certain correlation with the scale of
the case, and when a large number of BCs could be solved, the time
consumption also become larger.

We also list |𝐵𝐶𝑤 | here because we believe that although they
cannot be transformed into LTL formulas, they actually contain the
semantics of boundary conditions, and by analyzing them, traces
of events leading to divergence can also be learnt, so they are also
valuable. In the cases of RRA, SA and LC, it may be difficult to solve
a regular BC formula, but there are many accepting words that can
capture the behavior of divergence.

In summary, SemanticBC is able to solve BCs with a relatively
small cost of time consumption. Moreover, the cases whose BCs
are solved by SemanticBC not only include cases whose BCs are
difficult to be solved by other methods, but also include those cannot
be solved by other methods.

5.3.2 𝑅𝑄2. Is the BC solved by SemanticBC easy to understand
i.e. meaningful? To answer 𝑅𝑄2, we take two case studies on Ele
and ATM, comparing the BCs solved by other methods to those
represented by trace formula, and decipher their meaning.

The elevator control system is an example with two goals, the for-
mal definition of the goals and the BCs solved by different methods
are as follows:
Goal: □(𝑐𝑎𝑙𝑙 → (cid:94)𝑜𝑝𝑒𝑛)
Informal Definition: The elevator will open the door after received
a call.
Goal: □(◦𝑜𝑝𝑒𝑛 → 𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 )
Informal Definition: The elevator should reach the corresponding
floor before opening the door.
BCs:

• SyntacBC: 1. (𝑐𝑎𝑙𝑙 ∧ □¬𝑜𝑝𝑒𝑛) ∨ ¬□(◦𝑜𝑝𝑒𝑛 → 𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 ) 2.

(¬𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 ∧ ◦𝑜𝑝𝑒𝑛) ∨ ¬□(𝑐𝑎𝑙𝑙 → (cid:94)𝑜𝑝𝑒𝑛)

• JFc(genetic algorithm): 1. □(𝑐𝑎𝑙𝑙 ∧¬𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 ) 2. ◦(¬𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 ∧

□𝑜𝑝𝑒𝑛) ∨ (𝑐𝑎𝑙𝑙 ∧ □¬𝑜𝑝𝑒𝑛)

• SemanticBC: 1. ¬𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 ∧ ◦𝑐𝑎𝑙𝑙 ∧ ◦◦□(¬𝑐𝑎𝑙𝑙 ∧ ¬𝑜𝑝𝑒𝑛)

[transition from state 2 to state 3 has conflict: 𝑜𝑝𝑒𝑛]
2. (¬𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 ∧ 𝑐𝑎𝑙𝑙 ∧ ¬𝑜𝑝𝑒𝑛) ∧ ◦◦□(¬𝑐𝑎𝑙𝑙 ∧ ¬𝑜𝑝𝑒𝑛) [tran-
sition from state 2 to state 3 has conflict: 𝑜𝑝𝑒𝑛]

2In theory, there is not always an LTL formula which can accept the same language as
a given Büchi automaton [13].

We first try to understand two BCs solved by the SyntacBC,
which are simple mutation after negating the goals. They actu-
ally describe the violation of two goals that occurred, however we
cannot tell exactly what event caused the divergence.

Take the first BC solved by JFc as JFc.1, it satisfies the definition 9
of trace formula, which we believe is meaningful, and it is simple
to interpret such BCs. ‘When the elevator received a call but it has
not reached the corresponding floor. And it happens forever.’ When
this happens, both goals cannot be satisfied, because the opening
of the elevator door requires it to reach the floor as a premise.
Solving such a BC is beneficial, which means that an additional
goal, e.g. ‘□(𝑐𝑎𝑙𝑙 → (cid:94)𝑎𝑡 𝑓 𝑙𝑜𝑜𝑟 )’, may need to be added to complete
the requirement. However genetic algorithms are not guaranteed
to generate such a meaningful BC, and in most cases BCs like JFc.2
are solved by the JFc framework. JFc.2 is similar to BCs solved
by SyntacBC, except that they are two different special case of
violations of the goals combined with ∨ operation.

For SemanticBC.1, it is a trace formula describing a run that can
be accepted by automaton. ‘In the first state, the elevator did not
reach the floor, and in the second state, the elevator received a call, and
then the elevator was never called nor the door opened.’ Furthermore,
we can also know that the goals have a divergence on whether to
open the door in the second state, it will violate either goal anyway.
Interpreted in the same way, SemanticBC.2 actually captures the
same divergence as JFc.2.

The second example is about ATM containing three goals:

Goal: □((𝑝𝑎𝑠𝑠𝑜𝑘 ∧ ¬𝑙𝑜𝑐𝑘) → 𝑚𝑜𝑛𝑒𝑦)[𝑔1]
Informal Definition: When the password is correct and the account
is not locked, money can be withdrawn normally.
Goal: □(¬𝑝𝑎𝑠𝑠𝑜𝑘 → (¬𝑚𝑜𝑛𝑒𝑦 ∧ ◦𝑙𝑜𝑐𝑘𝑒𝑑))[𝑔2]
Informal Definition: A wrong password is entered, then with-
drawals are not allowed and the account will be locked.
Goal: □(𝑙𝑜𝑐𝑘𝑒𝑑 → (cid:94)¬𝑙𝑜𝑐𝑘𝑒𝑑)[𝑔3]
Informal Definition: Accounts are unlocked after being locked for
a period of time.
BCs:(for brevity, 𝑝 stands for 𝑝𝑎𝑠𝑠𝑜𝑘, 𝑚 for 𝑚𝑜𝑛𝑒𝑦, 𝑙 for 𝑙𝑜𝑐𝑘)

• SyntacBC: 1. (¬𝑙 ∧ ¬𝑚 ∧ 𝑝) ∨ ¬□¬𝑝 → (¬𝑚 ∧ ◦𝑙)
• JFc(genetic algorithm): 1. (cid:94)(¬𝑙 ∧ ¬𝑚 ∧◦¬𝑙) 2. (cid:94)(¬𝑙 ∧ ¬𝑚 ∧

𝑝) ∨ □(¬𝑙 ∧ ¬𝑝)

• SemanticBC: 1. (¬𝑙 ∧¬𝑚) ∧◦(¬𝑙 ∧𝑚 ∧𝑝) ∧◦◦□(¬𝑙 ∧𝑚 ∧𝑝)
[transition from state 0 to state 1 has conflict: 𝑝, conflict
between 𝑔1, 𝑔2]

SyntacBC.1 and JFc.2 obviously belong to that kind of trivial
BC, though JFc.1 seems like an easy-to-understand BC for its not
containing the ∨ operator. JFc.1 describes the situation that ‘the
account is unlocked, no money out and account still unlocked at the
next state’. And SemanticBC.1 actually captures the same divergence
as JFc.1, and we could know this BC cause conflicts between 𝑔1 and
𝑔2. The divergence happens because when the ◦¬𝑙 at the second
state, then there is 𝑝 at first state. And since the 𝑝 ∧ ¬𝑙, there should
be 𝑚, however it is ¬𝑚.

Although we are able to interpret the divergence in Seman-
ticBC.1, it is actually meaningless to solve for it, because in the
ATM, 𝑝𝑎𝑠𝑠𝑜𝑘 is a variable determined by the environment and does
not need to care whether it diverges or not. Therefore, in the results

Yechuan Xia, Jianwen Li, Shengping Xiao, Weikai Miao, and Geguang Pu

shown in Table 2, we have ignored the conflict of the environment
variables in all cases.

By comparing the meaning of BCs obtained by SemanticBC and
BCs obtained by other methods, we can summarize three advan-
tages of BCs solved by SemanticBC: 1. They contain a clear meaning
and are definitely valuable for analysis. 2. They can narrow down
the scope of the analysis by specifying which two goals the diver-
gence occurs between. 3. They will not contain the meaningless
conflict about the environment variables.

6 RELATED WORK
The problem of how to deal with inconsistencies in requirements,
i.e., inconsistency management, has been studied extensively from
different perspective [10, 11, 14, 14–19, 25, 27, 29, 30]. Goal-conflict
analysis has been widely used to detect requirement errors in GORE.
It is particularly driven by the identify-assess-control cycle, which
concentrates on identifying, assessing and resolving inconsistencies
that may falsify the satisfaction of expected goals. Another relevant
topic is the obstacle analysis [1–4, 33], which captures the situation
where only one goal is inconsistent with the domain properties.
Notably, since obstacles only capture the inconsistency for single
goals, these approaches cannot handle the case when multiple goals
are inconsistent.

In this paper, we focus on the inconsistencies that are captured
by boundary conditions and present novel approaches to identify
meaningful BCs. Extant solutions mainly fall into two kinds of
categories, i.e., the construct-based and search-based strategies. For
construct-based approaches, Van Lamsweerde et al. [32] proposed
a pattern-based approach which only returns a BC in a pre-defined
limited form. Degiovanni et al. [7] utilizes a tableaux-based way
to generate general BCs but that approach only works on small
specifications because constructing tableaux is time consuming.
For the search-based approach, Degiovanni et al. [6] presented a
genetic algorithm to identify BCs such that their algorithm can han-
dle specifications that are beyond the scope of previous approaches.
Moreover, Degiovanni et al. [6] first proposed the concept of gener-
ality to assess BCs. Their work filtered out the less general BCs to
reduce the set of BCs. However, the generality is a coarse-grained
assessment metric. As the number of identified inconsistencies in-
creases, the assessment stage and the resolution stage become very
expensive and even impractical. Recently, the assessment stage
in GORE has been widely discussed to prioritize inconsistencies
to be resolved and suggest which goals to drive attention to for
refinements.

Meanwhile, some of the work [2–4] assume that certain proba-
bilistic information on the domain is provided so as to detect simpler
kinds of inconsistencies (obstacles). In order to automatically assess
BCs, Degiovanni et al. [5] recently have proposed an automated
approach to assess how likely conflict is, under an assumption that
all events are equally likely. They estimated the likelihood of BCs
by counting how many models satisfy a circumstance captured by a
BC. However, the number of models cannot accurately indicate the
likelihood of divergence, because not all the circumstances captured
by a BC result in divergence.

Last year, Luo et al. [26] pointed out the shortages of the likelihood-

based method and proposed a new metric called contrastive BC to

Identifying Boundary Conditions with the Syntax and Semantic Information of Goals

avoid evaluation mistakes for the likelihood. For the resolution of
conflicts, Murukannaiah et al. [28] resolved the conflicts among
stakeholder goals of system-to-be based on the Analysis of Com-
peting Hypotheses technique and argumentation patterns. Related
works on conflict resolution also include [12] which calculates the
personalized repairs for the conflicts of requirements with the prin-
ciple of model-based diagnosis. However, these approaches assume
that the conflicts have been already identified, which relies heavily
on the efficiency of the BC construction.

Compared to previous approaches for the BC construction, ours
are distinguished as follows. We make full usage of the syntax and
semantics information of the BC, and present a simple but very
efficient way to construct BCs by replacing some 𝑔𝑖 ∈ 𝐺 with a
weaker property 𝑔′
𝑖 → 𝑔𝑖 . Moreover, we introduce
the automata-based construction to construct BCs that contain the
system information as a whole, rather than the trivially combination
of local ones using the disjunctive operator.

𝑖 such that 𝑔′

7 CONCLUSION
In this paper, we revisit the problem of computing boundary condi-
tions in GORE and present two different approaches to construct
BCs based on the theoretical foundations. Our experimental results
show that, the syntactical approach can perform >1000X speed-up
on the BC construction, and the semantics one is able to construct
more meaningful BCs without losing performance. The success of
our approaches affirms that, the problem of identifying BCs should
be reconsidered in the theoretical instead of the algorithmic way.

REFERENCES
[1] Dalal Alrajeh, Jeff Kramer, Axel van Lamsweerde, Alessandra Russo, and Se-
bastián Uchitel. 2012. Generating Obstacle Conditions for Requirements Com-
pleteness. IEEE Press, 705–715.

[2] Antoine Cailliau and Axel van Lamsweerde. 2012. A probabilistic framework
for goal-oriented risk analysis. In 2012 20th IEEE International Requirements
Engineering Conference (RE). 201–210. https://doi.org/10.1109/RE.2012.6345805
[3] Antoine Cailliau and Axel van Lamsweerde. 2014. Integrating exception han-
dling in goal models. In 2014 IEEE 22nd International Requirements Engineering
Conference (RE). 43–52. https://doi.org/10.1109/RE.2014.6912246

[4] Antoine Cailliau and Axel van Lamsweerde. 2015. Handling knowledge uncer-
tainty in risk-based requirements engineering. In 2015 IEEE 23rd International
Requirements Engineering Conference (RE). 106–115. https://doi.org/10.1109/RE.
2015.7320413

[5] Renzo Degiovanni, Pablo Castro, Marcelo Arroyo, Marcelo Ruiz, Nazareno
Aguirre, and Marcelo Frias. 2018. Goal-Conflict Likelihood Assessment Based
on Model Counting. In 2018 IEEE/ACM 40th International Conference on Software
Engineering (ICSE). 1125–1135. https://doi.org/10.1145/3180155.3180261

[6] Renzo Degiovanni, Facundo Molina, Germán Regis, and Nazareno Aguirre. 2018.
A genetic algorithm for goal-conflict identification. In Proceedings of the 33rd
ACM/IEEE International Conference on Automated Software Engineering. 520–531.
[7] Renzo Degiovanni, Nicolás Ricci, Dalal Alrajeh, Pablo Castro, and Nazareno
Aguirre. 2016. Goal-conflict detection based on temporal satisfiability checking. In
2016 31st IEEE/ACM International Conference on Automated Software Engineering
(ASE). IEEE, 507–518.

[8] Alexandre Duret-Lutz, Alexandre Lewkowicz, Amaury Fauchille, Thibaud
Michaud, Etienne Renault, and Laurent Xu. 2016. Spot 2.0 — a framework for LTL
and 𝜔-automata manipulation. In Proceedings of the 14th International Symposium
on Automated Technology for Verification and Analysis (ATVA’16) (Lecture Notes
in Computer Science, Vol. 9938). Springer, 122–129.

[9] N. Eén and N. Sörensson. 2003. An Extensible SAT-solver. In SAT. 502–518.
[10] Christian Ellen, Sven Sieverding, and Hardi Hungar. 2014. Detecting Consisten-
cies and Inconsistencies of Pattern-Based Functional Requirements. In Formal
Methods for Industrial Critical Systems, Frédéric Lang and Francesco Flammini
(Eds.). Springer International Publishing, Cham, 155–169.

[11] Neil A. Ernst, Alexander Borgida, John Mylopoulos, and Ivan J. Jureta. 2012. Agile
Requirements Evolution via Paraconsistent Reasoning. Springer-Verlag, Berlin,
Heidelberg, 382–397.

[12] Alexander Felfernig, Gerhard Friedrich, Monika Schubert, Monika Mandl, Markus
Mairitsch, and Erich Teppan. 2009. Plausible Repairs for Inconsistent Require-
ments. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 791–796.
[13] R. Gerth, D. Peled, M.Y. Vardi, and P. Wolper. 1995. Simple on-the-fly auto-
matic verification of linear temporal logic. In Protocol Specification, Testing, and
Verification, P. Dembiski and M. Sredniawa (Eds.). Chapman & Hall, 3–18.
[14] David Harel, Hillel Kugler, and Amir Pnueli. 2005. Synthesis Revisited: Generating
Statechart Models from Scenario-Based Requirements. Springer Berlin Heidelberg,
Berlin, Heidelberg, 309–324.

[15] Jan Hendrik Hausmann, Reiko Heckel, and Gabi Taentzer. 2002. Detection of
Conflicting Functional Requirements in a Use Case-Driven Approach: A Static
Analysis Technique Based on Graph Transformation. In Proceedings of the 24th
International Conference on Software Engineering. Association for Computing
Machinery, New York, NY, USA, 105–115. https://doi.org/10.1145/581339.581355
[16] Sebastian J.I. Herzig and Christiaan J.J. Paredis. 2014. A Conceptual Basis for
Inconsistency Management in Model-based Systems Engineering. Procedia CIRP
21 (2014), 52–57. https://doi.org/10.1016/j.procir.2014.03.192 24th CIRP Design
Conference.

[17] Ivan J. Jureta, Alex Borgida, Neil A. Ernst, and John Mylopoulos. 2010. Techne:
Towards a New Generation of Requirements Modeling Languages with Goals,
Preferences, and Inconsistency Handling. In 2010 18th IEEE International Require-
ments Engineering Conference. 115–124. https://doi.org/10.1109/RE.2010.24
[18] Massila Kamalrudin. 2009. Automated Software Tool Support for Checking the
Inconsistency of Requirements. In 2009 IEEE/ACM International Conference on
Automated Software Engineering. 693–697. https://doi.org/10.1109/ASE.2009.38
[19] Massila Kamalrudin, John Hosking, and John Grundy. 2011. Improving require-
ments quality using essential use case interaction patterns. In 2011 33rd Interna-
tional Conference on Software Engineering (ICSE). 531–540. https://doi.org/10.
1145/1985793.1985866

[20] Jeff Kramer, Jeff Magee, Morris Sloman, and Andrew Lister. 1983. Conic: an
integrated approach to distributed computer control systems. IEE Proceedings
E-Computers and Digital Techniques 130, 1 (1983), 1.

[21] Phillip A. Laplante. 2007. What Every Engineer Should Know about Software
Engineering (What Every Engineer Should Know). CRC Press, Inc., USA.
[22] Jianwen Li, Yinbo Yao, Geguang Pu, Lijun Zhang, and Jifeng He. 2014. Aalta: An
LTL Satisfiability Checker over Infinite/Finite Traces. In Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software Engineering.
Association for Computing Machinery, New York, NY, USA, 731–734. https:
//doi.org/10.1145/2635868.2661669

[23] Jianwen Li, Shufang Zhu, Geguang Pu, and Moshe Y. Vardi. 2015. SAT-Based
Explicit LTL Reasoning. In Hardware and Software: Verification and Testing, Nir
Piterman (Ed.). Springer International Publishing, Cham, 209–224.

[24] Jianwen Li, Shufang Zhu, G. Pu, Lijun Zhang, and Moshe Y. Vardi. 2019. SAT-
based explicit LTL reasoning and its application to satisfiability checking. Formal
Methods in System Design (2019), 1–27.

[25] Chi-Lun Liu. 2010. Ontology-Based Conflict Analysis Method in Non-functional
Requirements. In 2010 IEEE/ACIS 9th International Conference on Computer and
Information Science. 491–496. https://doi.org/10.1109/ICIS.2010.26

[26] Weilin Luo, Hai Wan, Xiaotong Song, Binhao Yang, Hongzhen Zhong, and Yin
Chen. 2021. How to Identify Boundary Conditions with Contrasty Metric?. In
2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE).
IEEE, 1473–1484.

[27] Dewi Mairiza and Didar Zowghi. 2011. Constructing a Catalogue of Conflicts
among Non-functional Requirements. In Evaluation of Novel Approaches to Soft-
ware Engineering, Leszek A. Maciaszek and Pericles Loucopoulos (Eds.). Springer
Berlin Heidelberg, Berlin, Heidelberg, 31–44.

[28] Pradeep K. Murukannaiah, Anup K. Kalia, Pankaj R. Telangy, and Munindar P.
Singh. 2015. Resolving goal conflicts via argumentation-based analysis of com-
peting hypotheses. In 2015 IEEE 23rd International Requirements Engineering
Conference (RE). 156–165. https://doi.org/10.1109/RE.2015.7320418

[29] T. Nguyen, Q. B. Vo, M. Lumpe, and J. Grundy. 2013. KBRE: a framework for
knowledge-based requirements engineering. Software Quality Journal 22 (2013),
87–119.

[30] Bashar Nuseibeh and Alessandra Russo. 1999. Using Abduction to Evolve Incon-
sistent Requirements Specification. Australasian Journal of Information Systems
6 (1999).

[31] A. Pnueli. 1977. The temporal logic of programs. In 18th Annual Symposium on
Foundations of Computer Science (sfcs 1977). 46–57. https://doi.org/10.1109/SFCS.
1977.32

[32] Axel Van Lamsweerde, Robert Darimont, and Emmanuel Letier. 1998. Managing
conflicts in goal-driven requirements engineering. IEEE transactions on Software
engineering 24, 11 (1998), 908–926.

[33] A. van Lamsweerde and E. Letier. 2000. Handling obstacles in goal-oriented
IEEE Transactions on Software Engineering 26, 10

requirements engineering.
(2000), 978–1005. https://doi.org/10.1109/32.879820

