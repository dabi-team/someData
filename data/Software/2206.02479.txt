2
2
0
2

n
u
J

6

]
E
S
.
s
c
[

1
v
9
7
4
2
0
.
6
0
2
2
:
v
i
X
r
a

Easy, adaptable and high-quality Modelling with
domain-speciﬁc Constraint Patterns

Sophia Saller1[0000−0003−4817−8601] and Jana Koehler1,2[0000−0001−9000−9188]

1 Deutsches Forschungszentrum f¨ur K¨unstliche Intelligenz, Saarland Informatics
Campus, Saarbr¨ucken, Germany, firstname.lastname@dfki.de
2 Universit¨at des Saarlandes, Saarland Informatics Campus, Saarbr¨ucken, Germany

Abstract. Domain-speciﬁc constraint patterns are introduced, which
form the counterpart to design patterns in software engineering for the
constraint programming setting. These patterns describe the expert knowl-
edge and best-practice solution to recurring problems and include ex-
ample implementations. We aim to reach a stage where, for common
problems, the modelling process consists of simply picking the applica-
ble patterns from a library of patterns and combining them in a model.
This vastly simpliﬁes the modelling process and makes the models sim-
ple to adapt. By making the patterns domain-speciﬁc we can further
include problem-speciﬁc modelling ideas, including speciﬁc global con-
straints and search strategies that are known for the problem, into the
pattern description. This ensures that the model we obtain from patterns
is not only correct but also of high quality. We introduce domain-speciﬁc
constraint patterns on the example of job shop and ﬂow shop, discuss
their advantages and show how the occurrence of patterns can automat-
ically be checked in an event log.

1

Introduction

Design patterns are widely used in software engineering to describe solutions
to recurring problems. Such recurring problems do not, however, only occur in
software engineering; they also appear in constraint programming. We do not
want to constantly have to ﬁnd new solutions to problems that have already been
tackled, but would instead like to reuse methods that have worked successfully
in the past. To this end, we introduce the notion of domain-speciﬁc constraint
patterns: patterns for the constraint programming setting. A pattern describes
a recurring problem, gives a solution approach to this problem, and highlights
consequences of choosing this approach. The solution approach describes the
best practice or expert knowledge of how to model the problem. By making
the patterns domain-speciﬁc, problem speciﬁc modelling ideas, including global
constraints and search strategies that are known for the problem, can be included
into the pattern description. This allows for a simpliﬁcation of the modelling
process, as well as making high-quality models easier to obtain. The domain-
speciﬁc constraint patterns introduced here form an extension of the general
constraint patterns introduced by Toby Walsh in [26]. The patterns introduced

 
 
 
 
 
 
2

S. Saller, J. Koehler

there are general modelling techniques for which no speciﬁc implementation is
given. Next to introducing the notion of domain-speciﬁc constraint patterns, we
discuss their potential advantages and give examples of patterns for scheduling
problems by formalizing and describing them. Over time, we intend to build up
a pattern library containing patterns from further scheduling as well as non-
scheduling problems, such as timetabling, permutation or travelling salesman
problems.

2 Why Domain-speciﬁc Constraint Patterns?

Easy Modelling: Making use of domain-speciﬁc constraint patterns has many
advantages. It has the potential to simplify the modelling process. We aim to
reach a stage where, for common problems, the modelling process consists of a
human modeller simply picking the applicable patterns from a large library of
patterns and combining them in a model. Each pattern further includes code
examples from which a complete model can simply be assembled once the set of
patterns occurring in the problem is known. If further, less common, constraints
occur in the problem, the human modeller can simply add these to the basic
model structure given by the pattern implementation. This makes past solutions
to recurring problems reusable. Furthermore, by either using the explicit and
automatically checkable conditions included in the pattern description, or by
directly checking whether the constraints are satisﬁed, an event log can auto-
matically be classiﬁed according to the patterns. Informally, an event log is a
collection of events, where each event corresponds to an activity that was ex-
ecuted. A formal deﬁnition is given in Deﬁnition 2. This means that, if a past
event log of a problem exists, the event log can automatically be classiﬁed ac-
cording to the patterns, and a constraint model can be assembled by a human
modeller from the explicit implementations of the occurring patterns. This ap-
proach to acquiring a constraint model using patterns is further developed in
Section 5.

Adaptable Modelling: In real world problems the problem we wish to
model may frequently change to some small extent, sometimes referred to as
concept drift [24]. As an example, in automotive production it may be the case
that usually only one car is allowed to wait between two machines, but on busy
days this might be relaxed to two or more waiting cars to allow for a greater
throughput. On these occasions, the constraint model has to be adapted to ﬁt
the new situation. By specifying constraint patterns and relating the constraints
directly to the patterns, all that needs to be done to adapt the model is to check
which patterns no longer hold and which new patterns do, and adapt the model
accordingly using the implementation speciﬁed in the patterns. This results in
easy adaptations of constraint models.

High-quality Modelling: The use of patterns ensures that the resulting
model is of high quality. For a constraint model to be useful in practice, the
model needs to not only be correct, but also be of high quality to help the solver
ﬁnd solutions quickly. Constraint programming experts use their vast experience

Domain-speciﬁc Constraint Patterns

3

and best practices when trying to model new problems in a way that simpliﬁes
the solution-ﬁnding process for the solver. However, this expert knowledge is
usually not accessible to others. Harvesting domain-speciﬁc constraint patterns
makes this expert knowledge easy to obtain, which will result in it being more
widely applied. In the pattern description we give explicit information on how
the pattern is to be best modelled and which search strategies are known to work
well for this problem.

Explainable Modelling: Finally, patterns can help the explainability of the
constraint model. While domain experts have an in-depth understanding of the
problem at hand, they are usually not well-versed in constraint programming
or the mathematical description of constraints. The proposed formalisation of
each domain-speciﬁc constraint pattern contains an explanation of the intent
of the pattern and examples in plain English. This makes it easier to discuss
the modelling of the problem with domain-experts, since, instead of having to
discuss at the abstraction level of variables and constraints, discussions can be
held at the abstraction level of patterns.

3 Related Work

Design patterns were originally introduced in the domain of building architecture
to describe best-practice or expert solutions to recurring problems [3]. Several
years later, the idea of applying design patterns was extended to the world of
programming for designing reusable solutions to common software engineering
problems [13]. The importance of high-quality modelling in constraint program-
ming has long been recognized [10,22], which emphasises the importance of mak-
ing expert knowledge accessible in this setting. Constraint patterns, as design
patterns for constraint programming, were ﬁrst introduced by Walsh [26] to
help constraint programmers spot commonly occurring antipatterns which make
models ineﬃcient and describe expert knowledge on how to best resolve these
issues. However, the patterns introduced by Walsh are not domain-speciﬁc and
instead are general modelling techniques for which no speciﬁc implementation is
given. By making constraint patterns domain-speciﬁc, we allow for the inclusion
of problem speciﬁc modelling ideas, which further improve the quality of the
ﬁnal model.

Next to resulting in high-quality models, the use of domain-speciﬁc constraint
patterns also simpliﬁes the modelling process. Other approaches to simplifying
the modelling process exist in the literature as so-called constraint acquisition
(CA) systems, which automatically obtain constraints from a set of examples.
One has to distinguish between active and passive CA systems. Active CA sys-
tems may ask queries to the user, for example ask the user to classify an as-
signment as either valid or invalid. Examples of active CA systems can be found
in [4,7,9,11,20,23]. Passive CA systems, on the other hand, cannot interact with
the user and instead learn exclusively from a set of examples, which may consist
of just positive (satisfying assignments), or negative (invalid assignments) and

4

S. Saller, J. Koehler

positive examples. Examples of passive CA systems can be found in [6,9,17]. CA
systems for scheduling problems are introduced in [16,21].

In [21], a passive CA system learning a constraint model from event logs,
meaning from exclusively positive examples, is proposed. In this, the authors
restrict their acquisition to basic scheduling problems. They eﬃciently check
whether the given event log is such a problem by checking whether the Petri
Net, which is mined from the event log using a process mining algorithm, is
an activity resource petri net (ARPN). This work proposes an end-to-end so-
lution for a speciﬁc subclass of scheduling problems and suggest extensions to
further classes of scheduling problems in future work. However, extensions to
other classes are laborious as a new Petri Net class must be deﬁned for each new
problem class. For this reason, we propose an extension of their work using a
more modular approach by introducing domain-speciﬁc constraint patterns. By
choosing this modular approach, we additionally attempt to tackle the problem
of obtaining not just valid, but good constraint models. Initial experiments of
this show promising results and are introduced in Section 6. Moreover, instead
of checking whether a CP model for an a priori known problem class can be
constructed from an event log using a specialized algorithm, we propose declar-
atively formulated conditions, which can also be veriﬁed in polynomial time. In
both cases, the checking of the conditions is linear in the size of the event log.
While the system introduced in [21] gracefully fails if the event log does not
correspond to a basic scheduling problem, we can provide further explanations
by returning which patterns do or do not hold and for those that do not hold,
give speciﬁc events which violate the conditions of the pattern.

The proposed library of constraint patterns complements two other impor-
tant libraries related to constraint problems and constraint programming, CSPlib
and the global constraint catalog. CSPlib [1] is an extensive library of constraint
problems, which was initially published with the purpose of providing a range of
hard and realistic problems that can be used to benchmark algorithms. Some of
the problems in the library include example implementations in diﬀerent mod-
elling languages, such as Essence [12] and MiniZinc [19]. The goal of CSPlib
is thus very diﬀerent to that of the constraint pattern repository introduced
here, which aims to simplify the modelling process and make high-quality mod-
els more easily obtainable. We also take one step further and try to break down
the problems by analysing the structure behind them. In doing so, the domain-
speciﬁc constraint patterns can easily be reused in diﬀerent application scenarios.
Our goal for the constraint pattern library is to eventually cover all problems
introduced in the CSPlib library and provide links from patterns to relevant
problems in CSPlib where applicable. The global constraint catalog [5], on the
other hand, is a collection of global constraints. A global constraint is a high-
level modelling abstraction which typically aids the propagation of the constraint
solver as many solvers have special, eﬃcient inference algorithms implemented
for them. For each global constraint, the global constraint catalog contains its
semantic and, when available, typical usage and ﬁltering algorithms. Constraint
patterns operate on a higher modelling level compared to global constraints. As

Domain-speciﬁc Constraint Patterns

5

such, the modelling variants included in the description of domain-speciﬁc con-
straint patterns may include global constraints, but they may also include other
constraints as well as information on how the variables of the problem are to be
best chosen and modelled.

4 Describing Domain-speciﬁc Constraint Patterns

We introduce domain-speciﬁc constraint patterns on the example domain of
production scheduling, which we use as a starting point to build up the pattern
repository due to its practical relevance. Scheduling problems can be classiﬁed
according to three characteristics: the machine environment, the processing char-
acteristics and the objective function, using the classiﬁcation schema by Graham
et al. [14]. This schema also inspired the introduction of constraint patterns, with
the idea of having a pattern for each machine environment and each processing
characteristic, and where the modelling of the processing characteristic pattern
depends on the machine environment that occurs. In order to illustrate the idea
of a pattern library, we discuss two selected patterns, the job shop and ﬂow shop
patterns, see Tables 1 and 2.

A domain-speciﬁc constraint pattern is a general, reusable solution to a com-
monly recurring problem within a given domain. In the following, we propose
key elements for the description of domain-speciﬁc constraint patterns based on
the examples of the Job Shop Pattern (Table 1) and the Flow Shop Pattern
(Table 2). We base these key elements on the established pattern template from
[13], which we adapt to the constraint pattern setting. It includes the Intent,
explaining what the constraint pattern does, the Motivation behind the pattern,
and the Applicability explaining in which situations the pattern can be applied.
In the Participants entry, the variables participating in the pattern are listed,
and the Collaborations entry explains how these participants collaborate. In the
Diagram entry, a visual representation of the pattern is given. In some cases,
applying the pattern has certain Consequences which need to be considered.
The “Implementation” entry of the original design pattern template has been
adapted for the constraint pattern setting to the new entry Modelling variants.
This entry gives variants of the best-practice modelling of the pattern for dif-
ferent constraint modelling languages. Inspired by [27], the original “See Also”
entry is reﬁned for the constraint pattern setting to ﬁve entries: Forces (patterns
that must hold if this pattern holds), Enables (patterns that have this pattern
as a prerequisite), Incompatible with (patterns that can not be applied with this
pattern), Compatible with (patterns that can be applied with this pattern), and
Similar to (patterns that are similar to this pattern). Note that some of these
relationships can also be directly checked. For example, if two incompatible pat-
terns are combined in a model, the model will become unsatisﬁable. Finally,
a further entry is added to the template which is important in the constraint
pattern setting: The Search strategies entry, which lists search strategies which
work well in the setting of this pattern.

6

S. Saller, J. Koehler

In the Applicability element of the pattern description, we give information
about the pattern’s applicability by giving conditions which must be satisﬁed
by corresponding event logs. The applicability is described through necessary
and suﬃcient conditions. Necessary conditions are other patterns which are pre-
requisites for the occurrence of this pattern. Suﬃcient conditions are further
conditions that an event log must satisfy to display this pattern. We require
the pattern conditions to be sound and complete. The pattern conditions are
sound if the behaviour corresponding to any event log satisfying the conditions
of the pattern, also satisﬁes the constraints of the pattern. The pattern condi-
tions are complete if any pattern occurring (as sets of constraints) in a model
also occurs (as satisﬁed conditions) in any event log obtained from taking a
solution of the model and executing it. For the example patterns given in this
paper, we describe the suﬃcient conditions based on the sequence of operations
ops(j) = hop1(j), . . . i of each job j ∈ JE in the event log and the sequence of
operations ops(m) = hop1(m), . . . i on each machine m ∈ ME in the event log.
Formal deﬁnitions can be found in Deﬁnitions 3 and 4 in Section 5.

4.1 Job Shop and Flow Shop Pattern

We give part of the description of two domain-speciﬁc constraint patterns corre-
sponding to machine environments here: The Job Shop Pattern in Table 1 and
the Flow Shop Pattern, a specialisation of the Job Shop Pattern, in Table 2.
Since there are more restrictions on the operations of each job in the Flow Shop
Pattern when compared to the Job Shop Pattern, the Flow Shop Pattern allows
for a more streamlined implementation of the variables in the modelling variants.
The Modelling variants entry in the pattern description speciﬁes how to best
model the pattern in diﬀerent modelling languages. In the case of the Flow Shop
Pattern we give two implementation variants, one for the OPL language for the
IBM ILOG CPLEX CP solver [15] and one for the MiniZinc language [19].

– OPL language (see Figure 3): For each job, exactly M interval decision vari-
ables are introduced, where M is the number of machines. Further, for each
job, a precedence constraint ensures that each operation of this job can only
start being processed once all the predecessor operations of this job have
ﬁnished processing. A sequence decision variable is introduced for each ma-
chine, containing all interval variables corresponding to operations processed
on said machine. A noOverlap constraint on this sequence variable ensures
that each machine only ever processes one job at a time.

– MiniZinc language (see Figure 2): For each operation of a job an integer
variable for the start time is introduced. For each job, a precedence constraint
ensures that each operation of this job can only start being processed once all
the predecessor operations of this job have ﬁnished processing. Further, each
machine can only ever process one job at once. For this reason, a disjunctive
constraint between all the operations intervals on this machine is introduced.

Note further that if several patterns hold at the same time, the implementa-
tions of the diﬀerent patterns can depend on one another. Consider for example

Domain-speciﬁc Constraint Patterns

7

the Machine Setup Pattern, which states that each machine needs a certain
amount of setup time between two operations. The Machine Setup Pattern has
the Job Shop Pattern as a prerequisite. The implementation for this pattern is
diﬀerent depending on whether the Flow Shop Pattern also holds or not.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

1
2
3
4
5

int numberJobs = ...;
int numberMachines = ...;
range allJobs = 1..numberJobs;
range allMachines = 1..numberMachines;

tuple Operation {

string id; // Operation id
int jobId; // Job id
int pos; // Position in job
int machine; // Machine
int pt; // Processing time

};
{Operation} allOperations = ...;

dvar interval operations[op in allOperations] size op.pt;
dvar sequence machineSequence[m in allMachines] in all

(op in allOperations: op.machine == m) operations[op];

forall (j in Jobs, op1 in allOperations, op2 in allOperations: op1.jobId==j &&

op2.jobId == j && op2.pos > op1.pos)
endBeforeStart(operations[op1],operations[op2]);

forall (m in allMachines) noOverlap(machineSequence[m]);

Fig. 1. OPL implementation of the variables and constraints for the Job Shop Pattern
(Table 1).

8

S. Saller, J. Koehler

Table 1. Job Shop Pattern.

Job Shop Pattern

Intent

Motivation

Applicability
(Necessary and
suﬃcient conditions)

A set of jobs is to be processed on a set of machines. Each job
is to be processed on some of the machines (potentially mul-
tiple times) in a predetermined order which might be diﬀerent
for each of the jobs. No two operations of the same job are to
be processed simultaneously, and no machine is to process two
operations simultaneously.
Job shop machine environments regularly occur in manufactur-
ing scenarios such as car manufacturing.
Suﬃcient conditions: For all j ∈ JE and all m ∈ ME,
(a) Jobs cannot be processed without a machine, so for all
i (j)) 6= ⊥. (see Def. 3)

i ∈ {1, . . . , |opsp(j)|}: #mach(opp

(b) No two operations of a job j can be processed at the same

time, so for all i ∈ {1, . . . , |opsp(j)| − 1}:
#end(opp

i (j)) ≤ #start(opp

i+1(j)).
(c) No machine can process two operations at the same time, so

for all i ∈ {1, . . . , |opsp(m)| − 1}:
i (m)) ≤ #start(opp
#end(opp

i+1(m)). (see Def. 4)

(j2))

(j2)) then

(d) Each activity occurs on a ﬁxed machine, so for all j2 ∈ J
and all i1 ∈ {1, . . . , |opsp(j)|} and i2 ∈ {1, . . . , |opsp(j2)|}:
if #act(opp
(j)) = #act(opp
i1
i2
(j)) = #mach(opp
#mach(opp
i2
i1
A set of jobs consisting of operations, and a set of machines.
Each operation of a job has to be processed on a predetermined
machine. The operations of a job have to be processed in a prede-
termined order. The operations and route through the machines
can diﬀer between jobs.
Gantt chart showing four jobs being processed on three ma-
chines:

Participants
Collaborations

Diagram

...
Modelling Variants
...
Search strategies

...
(1) OPL for IBM ILOG CPLEX CP: See Figure 1, . . .
...
Makespan optimisation: Set start times by choosing the job that
can start earliest and setting it to that time. If the total end time
is not ﬁxed, we set it to its minimal possible value [18, Section
2.5.2.].

Intent

...
Applicability

...
Consequences

Domain-speciﬁc Constraint Patterns

9

Table 2. Flow Shop Pattern.

Flow Shop Pattern

A set of jobs is to be processed on a set of machines. Each job is to be
processed on each of the machines exactly once in a predetermined
order and the order is the same for all jobs.
...
Necessary conditions: Job Shop Pattern (Table 1).
Suﬃcient conditions: ...
...
The decision variables deﬁne that each job consist of exactly as many
operations as there are machines.
Job Shop Pattern (Table 1), ...
No Wait Pattern, ...

Forces
Enables
Compatible with Distinguishable Resources Pattern, Indistinguishable Resources Pat-

tern, ...

include "disjunctive.mzn";
int: horizon; % time horizon
set of int: Time = 0..horizon;
int: numMachines;
int: numJobs;

array[1..numJobs, 1..numMachines] of int: productionTimeMatrix;
int: maxd = max([productionTimeMatrix[j,m] | j in 1..numJobs, m in 1..numMachines

]);

array[1..numJobs, 1..numMachines] of var Time : s;
array[1..numJobs, 1..numMachines] of 0..maxd : d = productionTimeMatrix;

constraint
forall(j in 1..numJobs, m1 in 1..numMachines, m2 in m1+1..numMachines)(

d[j, m1] <= s[j, m2] ˜- s[j, m1]);

constraint
forall(m in 1..numMachines)(

disjunctive(s[1..numJobs, m], d[1..numJobs, m]));

Fig. 2. MiniZinc implementation of the variables and constraints of the Flow Shop
Pattern.

1
2
3
4
5
6
7
8

9
10
11

1
2
3
4
5
6
7

10

S. Saller, J. Koehler

1
2
3
4
5

1
2
3
4

int operationDurations[allJobs][allMachines] = ...;
dvar interval operations[j in allJobs][m in allMachines]

size operationDuration[j][m];

dvar sequence machineSequence[m in allMachines] in all(j in allJobs)

operations[j][m];

forall(j in allJobs, m1 in allMachines, m2 in allMachines: m1<m2)

endBeforeStart(operations[j][m1], operations[j][m2]);

forall(m in allMachines) noOverlap(machineSequence[m]);

Fig. 3. OPL implementation of the variables and constraints of the Flow Shop Pattern.

5 Automatic pattern detection in event logs: Towards a

DevOps Chain for Constraint Programming

As part of the description of patterns, we give information about the applicability
of the pattern, meaning the situation in which the pattern can be applied. We
describe these conditions as necessary and suﬃcient conditions on an event log.
To formally state these, we make some deﬁnitions for event logs below using the
formalisation by Wil van der Aalst in [25]. To automatically check the presence
of patterns in an event log, the event log needs to be brought into this standard
form. Note that we do not make any assumptions on the quality of the event log
with respect to the objective function or about the structure of the process or
problem class to which the process described by the event log belongs.

We now deﬁne what we mean by an event and an event log, which may be
given in the XES Standard for event logs [2]. Table 3 shows a small example of
a scheduling event log. 3

Deﬁnition 1 (Event, attribute). [25] Let E be the event universe. Events may
be characterized by various attributes. Let AN be the set of attribute names. For
any event e ∈ E and name n ∈ AN , #n(e) is the value of attribute n for event
e. If event e does not have an attribute named n, then #n(e) = ⊥ (null value).

We can now deﬁne an event log. An event log contains data related to a single
process and consists of events. Each event refers to a single process instance, also
referred to as case. For a set A, let A∗ denote the set of ﬁnite sequences over A.

Deﬁnition 2 (Event Log E). [25] Let C be the case universe. For any case
c ∈ C and name n ∈ AN , deﬁne #n(c) to be the value of attribute n for case c
(#n(c) = ⊥ if case c has not attribute n). Each case has a special attribute trace,
where #trace(c) = E ∗. A trace is a ﬁnite sequence of events such that each event
appears only once. An event log is then a set of cases E ⊆ C such that each event
appears at most once in the entire log.

3 Further examples of event logs, including logs from non-scheduling domains, are

available at www.processmining.org/event-data.html.

Domain-speciﬁc Constraint Patterns

11

Events that belong to the same activity instance, for example the start process-
ing and complete processing event of one activity, may be identiﬁed as belonging
together through the activity instance attribute or the activity name. We also
call an activity instance an operation. In the following, we will restrict our at-
tention to the attributes necessary to describe the applicability of the patterns
introduced in this paper. Note that the same process might be described by dif-

Table 3. Example of an event log with jobs as cases.

Case Event
(j)
j1

j2

Timestamp

Activity

Transaction

start processing

30-12-2010:00.00:00 heating
30-12-2010:00.01:30 heating complete processing
rolling
30-12-2010:00.02:00
30-12-2010:00.10:00
rolling complete processing
30-12-2010:00.01:30 heating
30-12-2010:00.03:30 heating complete processing
rolling
30-12-2010:00.11:10
rolling complete processing
30-12-2010:00.14:00

start processing

start processing

start processing

Machine Activity
instance
1
1
2
2
3
3
4
4

(m)
m1
m1
m2
m2
m1
m1
m2
m2

1
2
5
6
3
4
7
8

ferent event logs. For the example of scheduling problems, an event log might be
using the jobs as cases, or the machines as cases. While some events will occur in
both logs, other events such as machine setup will only occur in one of the logs.
From an event log, we can obtain, by matching all events of the same activity
instance, a sequence of operations for each job and each machine. If a pattern has
suﬃcient conditions stated over for example the machine sequences, but they are
empty in this case, the pattern is clearly not satisﬁed. These sequences can be
obtained even if the log looks diﬀerent, for example if it contains start time and
duration information of each operation instead of start and completion time. In
these cases, a suitable adapter needs to be implemented for the given event log
structure.

Deﬁnition 3 (Job operation sequence ops(j)). For each job j ∈ JE in
the event log E, the job operation sequence ops(j) = hop1(j), . . . , op|ops(j)|(j)i
is the sequence of operations corresponding to grouped events of the trace of
the job ordered by ascending start times (if these exist), where each operation
opi(j) may have any number of attributes. Attributes can for example be the
following: the activity #act(opi(j)), the start time #start(opi(j)), the completion
time #end(opi(j)) and the machine #mach(opi(j)) of the operation.

For example, taking the event log from Table 3, op1(j1) corresponds to the
ﬁrst two rows in the table, meaning the start time is #start(op1(j1)) = 30-12-
2010:00.00:00, the end time is #end(op1(j1)) = 30-12-2010:00.01:30 and the ma-
chine is #mach(op1(j1)) = m1. We deﬁne operation sequences for machines anal-
ogously to the operation sequences for jobs.

12

S. Saller, J. Koehler

Deﬁnition 4 (Machine operation sequence ops(m)). For each machine
m ∈ ME, the machine operation sequence ops(m) = hop1(m), . . . , op|ops(m)|(m)i
is the sequence of operations corresponding to grouped events of the trace of m
ordered by ascending start times (if these exist), where each operation opi(m)
may have any number of attributes. Attributes can for example be the follow-
ing: the activity #act(opi(m)), the start time #start(opi(m)), the completion time
#end(opi(m)), and the job #job(opi(m)) of the operation.
Note that, as for events and cases, we use the notation ⊥ to denote that an
operation does not have an attribute. Further, we may restrict these operation
sequences to events of a certain type, such as processing events, where the trans-
action type is either start processing or end processing, also called ﬁltering. We
denote the processing subsequences of ops(j) and ops(m) by opsp(j) and opsp(m)
respectively.

Note that event logs often contain some amount of error, caused for example
by noise in the sensory data. Since we have stated the conditions separately from
the constraints, we can allow for small margins of errors in the conditions without
aﬀecting the pattern or constraints. This is the main reason why we separate
conditions from the implementations and do not directly check the constraints,
which is, of course, possible, too. As an example, we could allow for a margin of
error δ in condition (b) of the Job Shop Pattern in Table 1: Let j1 ∈ JE. For all
j2 ∈ JE and all i ∈ {1, . . . , |opsp(j2)|} we have
i (j2)) ≤ #start(opp

i+1(j2)) + δ.

#end(opp

By using the conditions on the event logs together with the explicit imple-
mentations of the patterns, we can detect which patterns occur in an event log
and then assemble a model from the explicit implementations of the occurring
patterns. In reality, though, the obtained model does not remain statically true,
but often needs to be revised over time. There can be several reasons for this.
For example, external events may have impacted the problem and thus modiﬁed
its characteristics, which is sometimes referred to as problem drift or concept
drift [24], or the original model did not correctly capture all aspects of the prob-
lem. It is therefore important to keep observing the execution of the solutions
to correct, improve or adapt the model. We can do so by detecting changes in
the patterns that are currently present, by either checking the conditions given
in the description of the patterns, or by directly checking if the corresponding
set of constraints is satisﬁed.

We wish to achieve a stage where when and how the problem changes, and
how the model should change to ﬁt the current situation, is continuously auto-
matically detected. While the detection of changes in the occurring patterns is
to be automated, the new model is to be assembled from the explicit implemen-
tations in the patterns by a human modeller, who reuses expertise available in
the patterns. However, one can also arrive at a fully automatic solution similar
to the one proposed by Senderovic et al. in [21] when the problem falls into a
designated problem class, for which the conﬁguration and parametrization of the
patterns is straightforward.

Domain-speciﬁc Constraint Patterns

13

We describe this agile constraint modelling and deployment as CPDevOps,
the DevOps for constraint programming, leading to the circular dependencies
shown in Figure 4.

Fig. 4. Workﬂow between event log, patterns, constraint model, solution and execution,
consisting of the following four steps: a) Automatically detecting which patterns occur
in the problem. b) Assembling a parametrised constraint model from the patterns
by using the explicit implementations of the patterns. c) Finding solutions to future
instances of the problem by using the model and a constraint solver. d) Executing a
solution schedule to again obtain an event log.

A similar loop was proposed in [8] as the inductive constraint programming
loop. In this the main focus is however on acquiring values of parameters from
past data, rather than new or changing constraint patterns. This continuous
estimation of parameter values should also be included in the CPDevOps cycle
to further automate the process of continuous adaption and improvement of the
constraint model to capture any drift in the problem.

6 Experiments

In [21], the authors evaluate their constraint model acquisition system on two
domains: simulated event logs generated using publicly available Job Shop bench-
marks and real-world event logs from an outpatient cancer hospital in the United
States. While the second data set is not publicly available, the ﬁrst is avail-
able under https://github.com/mnmlist/JobShopScheduling. In the following,
we compare the performance of the model acquired from the event log using
the method proposed in [21], referred to here as ARPN Model, with the model
obtained using domain-speciﬁc constraint patterns, referred to here as Pattern

14

S. Saller, J. Koehler

Model, on this Job Shop data set. As no information about the hardware used
for the experiments is given in [21], we ran all the experiments using the ARPN
model again to make the results comparable. We were in touch with the authors
to obtain their original model, however did not receive their model in time. The
ARPN Model was thus assembled using the model description available in [21].
The dataset comprises 53 job shop instances. Each instance ﬁle contains
information about the jobs to be scheduled, the machines assignments for each
operation, the order of the operations within a job, and the operation durations.
The number of jobs in an instance ranges from 6 to 30 and the number of
machines from 5 to 15.

The CP model experiments were run in the IDE of IBM ILOG CPLEX
Optimization Studio using an OPL script, on a Windows 10 machine with four
1.99 GHz processors and 16 GB memory. Further, the default solver settings were
used for all experiments. As in [21], we use Version 12.8 of IBM ILOG CPLEX
and a 10-minute time limit was set for the experiments. We performed several
runs of the experiments and noticed only very minor diﬀerences in the runtime
and solution costs between the runs. We thus felt that presenting numbers from
a single run gives a better impression of the results than the average from several
runs.

In our experiments, the solver could solve all instances with both models.
Using the Pattern Model, 49 of the 53 instances could be solved to optimality
compared to 48 instances using the ARPN Model. Further, all instances that
were solved to optimality with both models, were solved quicker using the Pat-
tern Model compared to the ARPN Model. On average (across all instances
solved to optimality using both models) the optimal solution was found after
8.4655s using the Pattern Model, and after 21.4560s using the ARPN Model.
The diﬀerence in performance is even more signiﬁcant when looking at instances
that could not be solved to optimality in less than 30s using either model, but
were solved to optimality within the time limit. Across these 5 more diﬃcult in-
stances, the optimal solution was found on average after 49.08s using the Pattern
Model, and after 135.58s using the ARPN Model. An overview of the quantiles
of the solution times is given in Table 4. We further ran experiments with a 2min
and a 5min time limit on the ﬁve instances that could not be solved to optimality
using the ARPN model. As can be seen in Table 5, the solver converges to good
solutions only slightly quicker using the Pattern Model when compared to the
ARPN model and after 10min only small diﬀerences in the solution quality can
be seen.

Table 4. Solving time of instances solved optimally using both models.

Pattern Model ARPN Model

1st Quantile
2nd Quantile
3rd Quantile

0.1725s
2.0450s
6.4545s

0.2185s
2.9695s
13.6168s

Domain-speciﬁc Constraint Patterns

15

Table 5. Objectives of instances solved suboptimally using both models.

Model

Pattern Model

ARPN Model

2min 5min 10min 2min 5min 10min
670
682
696
1164
1201

676
681
686
1165
1196

677
681
689
1167
1201

670
679
696
1164
1201

670
674
696
1164
1196

679
683
701
1170
1201

abz7
abz8
abz9
la29
la38

7 Conclusion and Future Work

We introduce the idea of a repository of domain-speciﬁc constraint patterns that
can automatically be checked, even on noisy event logs of processes, without a
priori knowledge of the problem class into which a process falls. The patterns
satisﬁed by an event log can be easily assembled and parametrised by human ex-
pertise, or a fully automatic construction for speciﬁc problem classes and pattern
combinations, to obtain high-quality constraint models. Finally, CPDevOps, a
DevOps for constraint programming, was introduced to automatically detect the
constraint patterns in event logs. This enables the continuous recognition of any
problem drift and the adaption of the model to ﬁt this drift. An online pattern
library is available at www.constraintpatterns.com and open for contributions
by the constraint programming community of researchers and practitioners.

References

1. CSPLib: A problem library for constraints. http://www.csplib.org, 1999.
2. IEEE Standard for eXtensible Event Stream (XES) for achieving interoperability

in event logs and event streams. IEEE Std 1849-2016, pages 1–50, 2016.

3. Christopher Alexander. A pattern language: towns, buildings, construction. Oxford

University Press, 1977.

4. Robin Arcangioli, Christian Bessiere, and Nadjib Lazaar. Multiple constraint aqui-
sition. In IJCAI: International Joint Conference on Artiﬁcial Intelligence, pages
698–704, 2016.

5. Nicolas Beldiceanu, Mats Carlsson, and Jean-Xavier Rampon. Global constraint

catalog. 2005.

6. Nicolas Beldiceanu and Helmut Simonis. A model seeker: Extracting global con-
straint models from positive examples. In International Conference on Principles
and Practice of Constraint Programming, pages 141–157. Springer, 2012.

7. Christian Bessiere, Remi Coletta, Emmanuel Hebrard, George Katsirelos, Nadjib
Lazaar, Nina Narodytska, Claude-Guy Quimper, and Toby Walsh. Constraint ac-
quisition via partial queries. In IJCAI: International Joint Conference on Artiﬁcial
Intelligence, pages 475–481, 2013.

8. Christian Bessiere, Luc De Raedt, Tias Guns, Lars Kotthoﬀ, Mirco Nanni, Siegfried
Nijssen, Barry O’Sullivan, Anastasia Paparrizou, Dino Pedreschi, and Helmut Si-
monis. The inductive constraint programming loop. IEEE Intelligent Systems,
32(5):44–52, 2017.

9. Christian Bessiere, Fr´ed´eric Koriche, Nadjib Lazaar, and Barry O’Sullivan. Con-

straint acquisition. Artiﬁcial Intelligence, 244:315–342, 2017.

16

S. Saller, J. Koehler

10. James E Borrett and Edward PK Tsang. A context for constraint satisfaction

problem formulation selection. Constraints, 6(4):299–327, 2001.

11. Eugene C Freuder and Richard J Wallace. Suggestion strategies for constraint-
based matchmaker agents. International Journal on Artiﬁcial Intelligence Tools,
11(01):3–18, 2002.

12. Alan M Frisch, Warwick Harvey, Chris Jeﬀerson, Bernadette Martinez-Hernandez,
and Ian Miguel. E ssence: A constraint language for specifying combinatorial
problems. Constraints, 13(3):268–306, 2008.

13. Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, and Design Patterns.
Elements of reusable object-oriented software, volume 99. Addison-Wesley Reading,
Massachusetts, 1995.

14. Ronald Lewis Graham, Eugene Leighton Lawler, Jan Karel Lenstra, and AHG Rin-
nooy Kan. Optimization and approximation in deterministic sequencing and
scheduling: a survey.
In Annals of discrete mathematics, volume 5, pages 287–
326. Elsevier, 1979.

15. IBM.

Cplex

12.10.

https://www.ibm.com/products/

ilog-cplex-optimization-studio/, Last accessed 14 May 2021.

16. Mohit Kumar, Stefano Teso, Patrick De Causmaecker, and Luc De Raedt. Au-
tomating personnel rostering by learning constraints using tensors. In 2019 IEEE
31st International Conference on Tools with Artiﬁcial Intelligence (ICTAI), pages
697–704. IEEE, 2019.

17. Arnaud Lallouet, Matthieu Lopez, Lionel Martin, and Christel Vrain. On learning
constraint problems. In 2010 22nd IEEE International Conference on Tools with
Artiﬁcial Intelligence, volume 1, pages 45–52. IEEE, 2010.

18. The MiniZinc Handbook 2.5.5.

https://www.minizinc.org/doc-2.5.5/en/index.

html, Last accessed 14 May 2021.

19. Nicholas Nethercote, Peter J Stuckey, Ralph Becket, Sebastian Brand, Gregory J
Duck, and Guido Tack. MiniZinc: Towards a standard CP modelling language.
In Int. Conference on Principles and Practice of Constraint Programming, pages
529–543. Springer, 2007.

20. Sarah O’Connell, Barry O’Sullivan, and Eugene C Freuder. A study of query
In Applications and

generation strategies for interactive constraint acquisition.
Science in Soft Computing, pages 225–232. Springer, 2004.

21. Arik Senderovich, Kyle EC Booth, and J Christopher Beck. Learning schedul-
In Proceedings of the International Conference on

ing models from event data.
Automated Planning and Scheduling, volume 29, pages 401–409, 2019.

22. Barbara M Smith. Modelling. In Foundations of Artiﬁcial Intelligence, volume 2,

pages 377–406. Elsevier, 2006.

23. Dimosthenis C Tsouros and Kostas Stergiou. Eﬃcient multiple constraint acquisi-

tion. Constraints, pages 1–46, 2020.

24. Alexey Tsymbal. The problem of concept drift: deﬁnitions and related work. Com-

puter Science Department, Trinity College Dublin, 106(2):58, 2004.

25. Wil Van Der Aalst. Data science in action. In Process mining, pages 3–23. Springer,

2016.

26. Toby Walsh. Constraint patterns. In International Conference on Principles and

Practice of Constraint Programming, pages 53–64. Springer, 2003.

27. Olaf Zimmermann, Jana Koehler, Frank Leymann, Ronny Polley, and Nelly Schus-
ter. Managing architectural decision models with dependency relations, integrity
constraints, and production rules. Journal of Systems and Software, 82(8):1249–
1267, 2009.

