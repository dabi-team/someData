2
2
0
2

r
p
A
5
2

]

R
C
.
s
c
[

1
v
2
7
9
1
1
.
4
0
2
2
:
v
i
X
r
a

1

Gate-Level Side-Channel Leakage Assessment
with Architecture Correlation Analysis

Pantea Kiaei, Student Member, IEEE, Yuan Yao, Zhenyuan Liu, Student Member, IEEE,
Nicole Fern, Cees-Bart Breunesse, Jasper Van Woudenberg, Kate Gillis, Alex Dich, Peter Grossmann,
and Patrick Schaumont, Senior Member, IEEE

Abstract—While side-channel leakage is traditionally evaluated from a fabricated chip, it is more time-efﬁcient and cost-effective to do
so during the design phase of the chip. We present a methodology to rank the gates of a design according to their contribution to the
side-channel leakage of the chip. The methodology relies on logic synthesis, logic simulation, gate-level power estimation, and gate
leakage assessment to compute a ranking. The ranking metric can be deﬁned as a speciﬁc test by correlating gate-level activity with a
leakage model, or else as a non-speciﬁc test by evaluating gate-level activity in response to distinct test vector groups. Our results
show that only a minority of the gates in a design contribute most of the side-channel leakage. We demonstrate this property for
several designs, including a hardware AES coprocessor and a cryptographic hardware/software interface in a ﬁve-stage pipelined
RISC processor.

Index Terms—Pre-silicon, Side-channel leakage, Power estimation, Hardware security

(cid:70)

1 INTRODUCTION

Power-based side-channel leakage occurs when a secure
chip performs operations that depend on an internal secret
value such as a secret key. An adversary who observes the
chip power consumption can derive the internal secret value
through differential analysis techniques that correlate a
power model of the secret activity with the observed power
consumption. In recent years, side-channel vulnerabilities
have risen to prominence and successful side-channel at-
tacks have been demonstrated on a wide range of devices
from small IoT devices to large cloud computing systems.
Therefore, the evaluation of the power-based side-channel
leakage has become a critical component in the design ﬂow
of secure chips. It is particularly helpful to perform side-
channel leakage assessment prior to manufacturing because
it reduces the cost of post-manufacturing testing, and it
reduces the probability of side-channel vulnerabilities in the
chip tape-out.

Fig. 1 compares the Side-channel Leakage Assessment
(SLA) process of a post-silicon assessment ﬂow with a pre-
silicon assessment ﬂow. The starting point is identical in
both cases and assumes that a Register-transfer Level (RTL)
description of the design under consideration is available.

• P. Kiaei, Z. Liu, and P. Schaumont are with the Department of Electrical
and Computer Engineering, Worcester Polytechnique Institute, Worcester,
MA, 01609.
E-mail: {pkiaei,zliu12,pschaumont}@wpi.edu

• Y. Yao was with the Bradley Department of Electrical and Computer En-
gineering, Virginia Polytechnique Institute and State University, Blacks-
burg, VA 24061.
E-mail: yuan9@vt.edu

• N. Fern, C.-B. Breunesse, and J. Van Woudebberg are with Riscure North

America, San Francisco, CA, 94108.

• K. Gillis, A. Dich, and P. Grossmann are with Intrinsix Corp.,

Marlborough, MA, 01752.

Fig. 1. (a) Post-silicon side-channel leakage assessment ﬂow. (b) Pro-
posed ﬂow.

With a post-silicon SLA ﬂow, the RTL design is ﬁrst proto-
typed into a physical implementation. Power measurements
are then collected from the design and statistically tested
to conﬁrm the presence of side-channel leakage or to esti-
mate the quantity of side-channel leakage. In a pre-silicon
strategy, the RTL design is synthesized into a gate-level
netlist including optional parasitic effects from place-and-
route. Next, power traces are simulated and then statistically
tested to conﬁrm the presence of side-channel leakage.

These two ﬂows appear similar from a macro-level objec-
tive, but they have very different properties. A post-silicon
ﬂow is expensive because of the extra prototyping step,
which slows down the veriﬁcation cycle. The statistical tests
are applied globally on the measured leakage of the overall
design. In a large and complex design, it therefore remains
difﬁcult to pinpoint the leakage source.

In contrast, a pre-silicon ﬂow makes use of simulated
power traces, and it is able to perform side-channel leakage

Tape‐out(a)(b)Verification Cycle, e.g.Add CountermeasuresVerification Cycle, e.g.Add CountermeasuresSynthesisBackend DesignRTLSynthesisRTLPower SimulationPower MeasurementLeakage AssessmentGL Leakage AssessmentBackend DesignTape‐out 
 
 
 
 
 
assessment at a ﬁne granularity. In this paper, we present a
side-channel leakage assessment methodology with a reso-
lution of a single gate. The simulated traces of the pre-silicon
ﬂow are noiseless, and therefore they represent the attacker
with the best possible observation. Due to the absence of
noise, a pre-silicon ﬂow can work with a fraction of the
number of power traces compared to a post-silicon ﬂow.
On the downside, a pre-silicon ﬂow must make a trade-off
between accuracy and simulation speed. We use a gate-level
power simulation methodology that is able to capture many
technology-dependent effects (such as glitches [1] and static
leakage [2]). Some side-channel leakage effects, including
those based on coupling [3] or the long-wire effect [4],
require a simulation accuracy beyond what gate-level power
simulation can offer. Our proposed ﬂow offers gate-level
side-channel leakage assessment but makes no assertion of
leakage below that abstraction level.

This paper presents the following contributions. We de-
scribe a methodology called Architecture Correlation Analysis
(ACA) which determines the side-channel leakage of a de-
sign at the granularity of a single gate. The basic principle of
ACA has been initially proposed in our previous work [5],
[6]. This paper serves as an extension to our original pub-
lication. In this extended work, we propose two different
side-channel leakage assessment techniques for use in ACA.
The ﬁrst one is based on a speciﬁc test and it demonstrates
the presence of correlation between a speciﬁc power model
and individual logic gates. The second is based on a non-
speciﬁc test that ranks a gate’s power according to its
ability to distinguish between two distinct groups of test
vectors. The speciﬁc test is used to identify the gates that
enable a speciﬁc side-channel attack, while the non-speciﬁc
test is used to make a generic assessment on how much
potentially harmful leakage can be produced by a gate. We
apply our proposed ACA leakage assessment technique to
two case studies: a cryptographic AES coprocessor, and the
driver software for that coprocessor when running on a ﬁve-
stage pipelined RISC processor. The side-channel leakage
properties of AES are already well understood, and our
experiments are speciﬁcally aimed at the ability of pre-
silicon leakage assessment to identify the source of side-
channel leakage.

The remainder of the paper is organized as follows. The
next section describes related work. Section 3 provides the
overall methodology of Architecture Correlation Analysis
(ACA), highlighting both the speciﬁc and the non-speciﬁc
testing strategy. We also discuss a prototype implementa-
tion of the ﬂow. Section 4 applies our proposed method-
ology to a cryptographic coprocessor. Section 5 applies the
methodology to cryptographic driver software running on a
RISC processor. Section 6 evaluates the performance of the
proposed methodology. We then conclude the paper.

2 RELATED WORK

Gate-level side-channel leakage assessment is built on two
components of design automation: (a) power simulation
under a set of selected test vectors, and (b) identiﬁcation
of a leakage source at the sub-module level or gate level. We
discuss related work on each of these two aspects.

2

2.1 Power simulation for side-channel leakage analysis

To simulate a design’s power consumption, one needs a
model of the design implementation details to estimate the
power of the physical implementation under a set of test
vectors. The model can be constructed at different abstrac-
tion levels, and there is a trade-off between modeling detail
and simulation performance. Buhan et al. review many of
the recent proposals to simulate side-channel leakage [7]
and here we only describe the most representative ones.

The origin of side-channel leakage power simulation is
found in simulators for smart cards, starting with PINPAS
[8]. The objective of these instruction-level simulations is
to generate a power trace corresponding to a software ap-
plication running on an embedded micro-controller. These
simulators are processor-speciﬁc, and require knowledge of
the internal design of the processor. Recent research efforts
have addressed power model construction techniques to
handle the case when the internal design is unknown. This
includes ELMO [9] and ROSITA [10] for power, and EMSIM
[11] for Electromagnetic Radiation. In our approach, we
build on the basic assumption that the hardware source code
is available.

It is now commonly understood that instruction-level
power modeling by itself is inadequate to accurately capture
all aspects of power-based side-channel leakage, and that
additional modeling detail is required to capture circuit-
level effects. The CASCADE power simulation ﬂow aims
at a comprehensive simulation of power traces at the gate-
level [12], while making the argument that gate-level power
simulation hits a sweet spot for the known power-based
side-channel leaks. A similar ﬂow (and argument) is found
in SCRIPT [13]. However, transistor-level power simula-
tion has been investigated as well to address speciﬁc side-
channel leakage assessments with a limited scope in time
and in design size [14]. More recently, power simulation for
side-channel analysis is starting to appear in commercial
tooling.

2.2 Identiﬁcation of the leakage source

By simulating power with a structural model, it becomes
feasible to identify the source component of side-channel leak-
age. In traditional measurement-based side-channel leakage
analysis, this type of analysis is not possible because the
design under test remains a black box. We review several
recent proposals aimed at identifying the structural source
of side-channel leakage, starting at low abstraction levels.

Karna partitions the gates of a design according to a spa-
tial grid over the circuit layout [15]. A gate-level simulation
leads to a power trace per grid cell. A leakage metric then
ranks different cells according to their contribution to the
side-channel leakage. The resolution of the Karna method
depends on the granularity of the grid cells on the layout,
since all logic cells within the same grid cell receive the same
leakage score. The Karna authors include around 150 logic
cells in one grid cell. Another tool, RTL-PSC. works at the
register-transfer level of abstraction [16]. RTL-PSC analyzes
the power in terms of transitions on the state variables of
a design, while sub-cycle effects such as glitches and the
effects of physical routing are abstracted out. The leakage
metric ranks the different modules of a design. A similar
register-transfer level analysis tool is PARAM [17], where

the authors identify the sources of side-channel leakage in a
processor’s micro-architecture.

Another view on the problem of leakage source identiﬁ-
cation is to formally prove that a design meets a predeﬁned
side-channel leakage criteria. This technique works well
for designs based on masking, a countermeasure based
on secret-sharing. One example is Coco, which combines
event-driven simulation with a SAT-solver-based veriﬁca-
tion of the statistical distribution of the secret shares [18].
Strictly speaking, these tools do not simulate the power
consumption, but they verify the statistical properties of
design activity.

Compared to this related work, ACA creates a ranking
of the cells in the design according to their contribution to
side-channel leakage, with a user-deﬁned leakage metric.
ACA can handle both speciﬁc and non-speciﬁc leakage test-
ing. ACA is processor-independent as well as technology-
independent. ACA builds a ﬂow on commercially available
synthesis and power simulation tooling. To the best of our
knowledge, no such tool has been presented by earlier work.

3 ARCHITECTURE CORRELATION ANALYSIS
In this section, we outline the strategy of Architecture Corre-
lation Analysis. The objective of ACA is to identify a ranking
among the cells1 of a design according to their contribution
to side-channel leakage. The cell ranking does not have to
reﬂect the absolute level of side-channel leakage generated
by a cell. Knowing just a relative ranking already provides
critical insight into the parts of a design that are most prone
to side-channel attacks.

Traditional side-channel

leakage assessment uses the
overall power consumption of a design to make an assess-
ment on the global design. In contrast, ACA uses not only
the overall power consumption but also the internal design
construction details to make an assessment of leakage on a
part of a design and to rank these local assessments. ACA
uses gate-level power simulation in order to capture power
events with sub-cycle accuracy as well as structural effects
such as wire-loading and static leakage. The challenge of
ACA is to perform such a gate-level side-channel leakage as-
sessment with reasonable accuracy but without exhaustively
generating the power consumption trace for each individual
cell in the design.

Side-channel leakage assessment aims to minimize as-
sumptions regarding the speciﬁc strength and know-how of
the attacker. This leads to the use of speciﬁc and non-speciﬁc
tests. A speciﬁc test for side-channel leakage uses a high-level
power model that the adversary would presumably use in
a Differential Power Analysis. A non-speciﬁc test uses two
groups of inputs and aims to demonstrate a statistically dis-
tinguishable power consumption difference between those
two groups. The Test Vector Leakage Assessment (TVLA)
methodology provides guidance on the selection of the two
groups of input vectors [19]. Both speciﬁc and non-speciﬁc
tests have their merits and limitations. Speciﬁc tests are
limited by speciﬁc assumptions on the capabilities and ac-
tivities of the attacker, but provide speciﬁc assertions on the

1. We use the term cell over gate as it reﬂects better the technology
encountered in standard-cell based IC design. A single cell often
corresponds to multiple primary gates.

3

Fig. 2. ACA Phase 1: Stimuli and Trace Generation for ACA

existence of a side-channel attack. Non-speciﬁc tests avoid
such assumptions, but they are unable to assert the existence
of a side-channel attack that can exploit the leakage. We,
therefore, present an ACA methodology for either approach.

3.1 Overall Methodology

The ACA methodology includes three phases: (a) activity
trace and power trace generation, (b) leakage time interval
selection, and (c) leakage impact factor evaluation. The ﬁrst
phase is common to speciﬁc and non-speciﬁc tests, while
the second and third phases differ according to the testing
strategy. We will discuss each phase separately.

Fig. 2 describes the common ﬁrst phase of speciﬁc
and non-speciﬁc ACA, covering logic synthesis, gate-level
simulation, and gate-level power simulation. The design
parameters, shown in italic, include the testing strategy, the
target technology, the target cycle period, and the frame size.
The frame size is the time step used in the traces of the
power simulator. All of the intermediate results of the ﬂow
are used by later phases of ACA.

Logic synthesis transforms the input RTL under a
given performance constraint (speed/area) into a gate-level
netlist. Next, the gate-level netlist is simulated for a set of
test vectors while recording the circuit activity for each net
in the design over the simulation time window of interest.
The type and number of test vector stimuli depend on the
assessment type (speciﬁc/non-speciﬁc) and the acceptable
statistical uncertainty of the leakage assessment result. We
will address the selection of test vectors in the next subsec-
tions.

Two factors greatly help in reducing the number of test
vectors for a side-channel leakage assessment. The ﬁrst
factor is that power simulation is noiseless so that each

Logic SynthesisRTLgate‐level circuittest‐vectorstimuliGate Level Simulation(per‐vector)circuit activityGate Level Power Sim(per‐vector)power traces(per‐vector)averagegate powertestingstrategytechtechcycle periodtechframe sizeOutput To phase 2 (LTI)Output To phase 3 (ACA)Input Design ParametersPhase1:ActivityTraceandPowerTraceGeneration4

TABLE 1
Normalized complexity of power estimation time for three different
design sizes and four different frame widths.

Samples/cycle

# Frames

1 SBOX

4 SBOX

16 SBOX

1/256
1
2
4

1
256
512
1000

1.0
6.9
11.1
13.17

1.72
23.5
37.1
45.6

4.54
93.8
149.4
184.8

Skywater 130nm power simulation with Cadence Joules

cells. The cycle time of this design is 10ns, and after each
up-going clock edge, there is about 5ns of activity as the
combinational cells settle to the new register output. In
this simulation, there are about 10,000 events in the ﬁrst
clock cycle, and 6,500 events in the second clock cycle.
To estimate the power, we select 8 frames per clock cycle
(as an example). The power simulator will then compute
the power per frame by analyzing the events within that
frame. The power trace will thus contain 8 points per clock
cycle, and side-channel leakage must be detected by power
variations on any of these points. Clearly, with a smaller
frame size, fewer events will contribute to that frame, so
that it becomes easier to identify which events (and which
cells) are a root cause of side-channel leakage.

On the other hand, a large frame size is beneﬁcial because
it improves simulation time. We demonstrate this effect with
the following experiment. A design containing 1, 4 resp. 16
AES S-boxes is driven by a set of counters that each count
from 0 to 255. We determine the power estimation cost
for a 256-cycle test-bench under various frame sizes. The
total simulated time remains 256 cycles for each case, and
therefore a smaller frame size requires more frames to be
computed. Table 1 demonstrates that the power simulation
cost signiﬁcantly depends not only on the design size, but
also on the number of frames.

In a practical assessment of hardware, we over-sample
the clock cycle at least several times, in order to run the
analysis on sub-cycle events. However, with long-running,
complex simulations, we have already successfully down-
sampled the frame size to as much as 80 clock cycles per
frame, while still being able to demonstrate side-channel
leaks [20]. Successfully ﬁnding side-channel leaks in an
under-sampled power trace is due to the averaged sampling
technique employed by power simulation tools [21].

In Phase 2 and Phase 3 of the ACA ﬂow, we aim to
identify the cells’ individual contribution to side-channel
leakage. The challenge is to complete this task using
only the global power traces. Indeed, the generation of
per-cell power traces has quadratic complexity (namely
design size×f rame count) and is therefore not scalable to
large applications. We solve this with a two-step approach.
First, using the global power traces, we identify the leakage
time interval, the time window within which a design leaks
information. Next, within the leakage time interval, we
use the activity traces to identify the contribution of an
individual cell to a design-level leak. Therefore, Phase 2 and
Phase 3 of the ACA ﬂow are deﬁned as Leakage Time Interval
Selection and Leakage Impact Factor Computation respectively.
Leakage Time Interval Selection uses design-global power
traces, while Leakage Impact Factor computation uses per-
cell event traces.

To test individual cells for side-channel leakage, we can

Fig. 3. Event Density for two cycles of an 9,640-cell hardware AES
design

test vector and internal design state needs to be simulated
only once. The second factor is that each simulation run
can be isolated from the next by re-initializing the design in
between simulation runs. In a typical side-channel leakage
assessment, we gather between a few hundred and a few
thousand simulated traces and we aim for a turn-around of
all three phases of ACA in less than 24 hours.

The gate-level power simulation estimates the time-
varying power consumption of the design for each test
vector as follows. First, the simulation time window is
partitioned into frames. Next, for each frame, the gate-level
power simulator computes the average power of a gate as a
combination of the switching power, the internal power, and
the leakage power. The gate switching power depends on
the per-frame output toggle rate and the capacitive loading
at the gate output. The gate internal power depends on the
per-frame, per-pin input toggle rate. The gate leakage power
depends on the per-frame state-dependent leakage power.
All these factors are scaled by the technology selection and
by the gate type. The sum of all these factors for all active
gates within the frame determines the average frame power.
The frame size is an important selection parameter of
the gate-level power simulation. The frame size determines
the smallest time interval analyzed by the ACA ﬂow for
side-channel leakage. Each single cell in a design typically
switches over a time interval much smaller than the clock
cycle, and much smaller than the frame size. A single
frame will thus contain the leakage of many different cells.
A smaller frame size helps in detecting power variations
caused by a speciﬁc cell. Fig. 3 illustrates this point in further
detail. The top half of the ﬁgure is an event density plot for
two cycles from a hardware AES design containing 9,640

1020304050607080Event DensityTime (ns)530535540545550555560565clockper‐cellpower modelFrameAverage Powerin‐frame eventsin‐frame Pavg5

TABLE 2
Pearson Correlation Threshold Levels as a function of test vectors m
and conﬁdence

Conﬁdence Level

m=600

m=1000 m=2000

99%
95%
90%

± 0.105 ± 0.081
± 0.080 ± 0.062
± 0.067 ± 0.052

± 0.058
± 0.044
± 0.037

Fig. 4. Phase 2 (Leakage Time Interval) and Phase 3 (Leakage Impact
Factor) computation for speciﬁc ACA

use two different testing scenarios. In the following sections,
we clarify each testing scenario separately.

Fig. 5. (left) Leakage Time Interval Detection (right) Architecture Corre-
lation Analysis

3.2 ACA for Speciﬁc Testing

Fig. 4 describes the two steps to apply ACA using a speciﬁc
test. The speciﬁc test requires the deﬁnition of a leakage
model, similar to the leakage model used in Differential
Power Analysis or Correlation Power Analysis. The leakage
model is correlated with the simulated power consumption
to identify a window of high correlation as the Leakage
Time Interval (LTI), the time window during which a design
leaks. Next, each individual cell is ranked by computing its
correlation to the leakage model within the LTI.

3.2.1 Leakage Time Interval for Speciﬁc Testing
Given a cipher which computes an internal result Vk =
f (K, Ck) with a partial key K and a controlled input Ck
from k-th test vector, a possible leakage model L(Vk) is
the Hamming Weight HW (Vk). Alternately, for an internal
tuple (V 1k, V 2k) = f (K, Ck), the leakage model can be
expressed as the Hamming Distance HD(V 1k, V 2k). We
then compute the correlation between the leakage model
L(Vk) or L(V 1k, V 2k) and the simulated power Pk[n] for
each frame n of the simulated power traces:

ρ[n] =

cov(L(Vk), Pk[n])
σLσP

(1)

The LTI consists of the set of frames for which the

absolute correlation is above a given threshold.

LT I = {n} : abs(ρ[n]) > ρthreshold

(2)

The choice of the threshold is a sensitivity parameter
that must be chosen such that the LTI covers design activity
that contains a likely correlation peak. Table 2 shows several
examples of threshold levels as a function of the number
of test vectors m and the conﬁdence level. As expected,
a requirement for higher conﬁdence or the use of fewer
traces will increase the conﬁdence interval, which means
that stronger correlation peaks must be identiﬁed before the
frame is ﬂagged as leaky and added to the LTI.

3.2.2 Leakage Impact Factor for Speciﬁc Testing

Within the LTI, we compute the contribution of each indi-
vidual cell to the leakage. This contribution is quantiﬁed in
the Leakage Impact Factor (LIF), which is a dimensionless
number that expresses the relative amount of side-channel
leakage from a cell.

The LIF of a cell is computed as the correlation of cell
output activity and leakage model activity. The LTI is a
set of frames that are considered leaky (Fig. 5, left). To
investigate the cell leakage, the LTI is superimposed over
the activity trace. For each net (or each net-driving cell),
we then compute a toggle trace as follows. When a given
net switches during the LTI, then that transition is counted
as a +1 toggle. When a given net does not include such a
transition in the LTI, then that is counted as a -1 toggle.
Hence, the activity of each net i under test vector j is
converted to a bi-valued signal Kij with values {-1, +1}.
To compute the architecture correlation Ci of net i, Kij is
multiplied with the toggle trace Hj of the leakage model
L(V ) (Fig. 5, right).

(cid:88)

Ci =

Kij.Hj

stimuli

(3)

This correlation can be computed for every frame within
the LTI. A high value in Ci indicates a strong correlation
between the cell activity and the leakage model, and hence
a strong indication that the cell contributes side-channel
leakage. All cells in the design are ranked according to
their Ci from most leaky to least leaky. We also include an
additional weighing factor for each Ci, deﬁned as the ratio
of the cells’ average power consumption Pi during the LTI
over the total average power consumption of all gates PT .
This increases the weight of high-drive cells with a high
correlation. This leads to the weighed per-cell LIF Fi:

Fi = Ci

Pi
PT

(4)

Phase 2: Leakage Time Interval SelectionPhase 3: Leakage Impact Factor Computation(per‐vector)power tracesspecificleakage modelSpecific Teste.g. DPA, CPAleakage time intervalSpecific ACAleakage time interval(per‐vector)circuit activitygate‐level correlationWeight FactorsLeakage Impact FactorSpecific testFrameAverage PowerCorrelationthresholdthresholdLeaky Frame(s)Leakage Time Interval (LTI)Event TraceLTIL(V) Toggle TraceHEvent Toggle Trace(s)KiArchitecture Correlation cell iCi = Ki.HLeakage Impact FactorFi= CiPi/ PT6

Fig. 7. Block diagram of the AES encryption/decryption unit

Fig. 6. Phase 2 (Leakage Time Interval) and Phase 3 (Leakage Impact
Factor) computation for nonspeciﬁc ACA

The LTI is then deﬁned using the same method as in

Equation 2.

Unlike computing a gates’ power for every frame, com-
puting a gates’ average power over all frames is relatively
quick (Table 1). Therefore, the weighing process is scaleable.
Each LIF factor is bound to a speciﬁc cell within a speciﬁc
frame in the LTI. Hence, for a design with G gates and J
leaky frames, the list of LIF factors contains G × J entries.
These entries are sorted by LIF value to determine the
overall leakage ranking.
3.3 ACA for Non-speciﬁc Testing

When a speciﬁc test is hard to apply, or when the number
of leakage models L(V ) becomes too numerous, it may be
helpful to apply a more generic non-speciﬁc test for leakage.
We can run ACA using a non-speciﬁc leakage model fol-
lowing a strategy as in Fig. 6. Similar to TVLA, non-speciﬁc
ACA requires the deﬁnition of two groups of stimuli. These
two groups are should exhibit some systematic difference
in the design behavior. For example, Goodwill et al. sug-
gest AES test vectors that are random for group 1, while
introducing a speciﬁc bias within a middle-round state for
group 2. Using these two vector groups, ACA then follows
the same two-step strategy as for speciﬁc testing. First, the
LTI is computed to bound the leakage in time, and next the
LIF per gate is computed. The testing statistic is adjusted to
a non-speciﬁc test.

3.3.1 Leakage Time Interval for Non-Speciﬁc Testing
The test-statistic compares the distribution of power values
at a speciﬁc frame between two test vector groups. One so-
lution is to use a Welch-t statistic, which tests the difference
between the mean values of both groups. Another solution
is to measure the correlation of the power value to the group
number. We use the leakage model N = groupid, with
groupid equal to -1 for vectors from group 1, and +1 for
vectors from group 2. With this leakage model, we can com-
pute a non-speciﬁc test statistic as a correlation value that
can be compared against a threshold value ρthreshold. With
P [n] the power consumed during frame n, the correlation is
given by:

3.3.2 Leakage Impact Factor for Non-Speciﬁc Testing

Once the LTI is ﬁxed, we proceed with computing the LIF
using a similar strategy as for the speciﬁc test. The LTI is
superimposed over the activity trace of the design. A net
transition during the LTI counts as a +1 toggle, and an
absence of transition counts as a -1 toggle. We compute the
architecture correlation Ci of net i by correlating the toggle
trace Kij with the groupid Nj.

(cid:88)

Ci =

Kij.Nj

stimuli

(6)

Again, a high value in Ci indicates a strong correlation
between the cell activity and the non-speciﬁc leakage model,
and hence ﬂags the cell Ci as leaky. To ﬁnd a cell’s non-
speciﬁc leakage impact factor Fi, a weighing factor is intro-
duced as in Equation 4.

The advantage of the non-speciﬁc test over the speciﬁc
test is that no high-level leakage model is necessary. For
example, we have used non-speciﬁc tests based on one
or more state bytes at a middle round being 0 or else
random. In the experimental results, we will demonstrate
the selectivity of both the speciﬁc as well as the non-speciﬁc
ACA method.

3.4 Implementation

Our ﬂow is fully realized in commercial tooling along
with customized scripting to implement the statistical post-
processing. We use Cadence Genus 20.1 for logic synthesis
from RTL, Cadence XCelium 20.09 for functional simulation,
and Cadence Joules 10.1 for gate-level power simulation.
Computation of ACA LIF and LTI is scripted on top of the
Jlsca toolbox2. We have used Skywater 130nm standard cells
as technology targets during experiments.

4 ACA ON A CRYPTOGRAPHIC COPROCESSOR

In this section, we describe the application of ACA on an
AES encryption/decryption coprocessor. The architecture
selected for analysis is typical for a medium-throughput
accelerator residing in an embedded SoC. The coprocessor

ρ[n] =

cov(N, P [n])
σN σP

(5)

2. https://github.com/Riscure/Jlsca

Phase 2:Leakage Time Interval SelectionPhase 3:Leakage Impact Factor Computationgroup 1power tracesSpecific Teste.g. DPA, CPAleakage time intervalNon‐Specific ACAgate‐level correlationWeight FactorsLeakage Impact FactorNon‐Specific testgroup 2power tracesleakage time interval(per‐vector)circuit activityEncryptionKeymemDecryptionSBOX4FSM12832inputIVoutputkeyBus InterfacectlTABLE 3
Cell type and area for AES coprocessor

Type

Cell Count

Area (%)

Sequential
Logic
Total

2,479
7,161
9,640

51.8
48.2
100.0

7

Fig. 9. (left) CPA on AES Coprocessor traces reveals a correlation peak
at about 75 traces (right) CPA on modiﬁed AES Coprocessor traces
signiﬁcantly delays correlation peak disclosure to at least 250 traces.

illustrates the strength of noiseless simulation and outlines
each clock cycle of operation as well as the location of power
variations. In this simulation, there are 512 frames in each
power trace.

We next ran ACA using a speciﬁc leakage model on
the Hamming Weight of the SBOX output of the ﬁrst key
byte. We selected a speciﬁc leakage model on the Hamming
Weight of the SBOX output of the ﬁrst state byte. We identify
the LTI with a ρthreshold of 0.2, which ﬂags 230 frames out
of the 512 frames as containing potentially leaky samples.
By correlating the transitions by cells within LTI with the
speciﬁc leakage models, 412 cells are then ﬂagged as leaky.
This group represents 4.3 % of the total number of 9,640
cells. We will analyze the relation of these 412 cells to the
overall AES coprocessor in subsection 4.2.

4.1.2 Result Veriﬁcation

The assertion made by ACA is that the side-channel leakage
under the selected leakage model is primarily caused by
these 412 cells. To verify the correctness of the selection,
we performed the following veriﬁcation. We re-ran the
simulation while collecting individual power traces for each
cell for all vectors and all frames. The per-cell power traces
of the 412 selected leaky cells are then subtracted from the
overall power traces to construct a modiﬁed set of power
traces. Next, we apply a Correlation Power Analysis (CPA)
on the original trace set as well as on the modiﬁed trace
set, with the results summarized in Fig. 9(left: unmodiﬁed
set, right: modiﬁed set). For the modiﬁed set, the number of
measurements to disclosure increases with a factor of 3.

We emphasize that this CPA experiment only veriﬁes the
selection of leaky cells. ACA is not a countermeasure but a
detection tool. One cannot remove an arbitrary cell from a
netlist without substituting it with an equivalent cell with
identical functionality. However, ACA is useful in conjunc-
tion with countermeasure tools that protect individual cells
or subsets of cells, such as Karna [15] or STELLAR [22]. A
second observation is that a power simulation that collects
an individual power trace for every gate is extremely com-
plex both in disk space and in time. We found the overhead
of single-gate power tracing (compared to standard ACA)
to be around 4 orders of magnitude in disk storage and
one order of magnitude in simulation time, and worsening
with design size. The high cost of per-gate power tracing

Fig. 8. Average Power Trace and Standard Deviation of AES Coproces-
sor in ﬁrst round

handles encryption and decryption and uses an ofﬂine key
schedule, which computes the roundkeys once upon load-
ing of the key. A single round takes 5 clock cycles. In the
ﬁrst four cycles, the coprocessor computes 16 Sbox lookups
in sets of 4, and in the ﬁfth clock cycle, the remainder of
the round is computed. The encryption/decryption core is
encapsulated by a bus interface which contains software-
accessible registers and a controller. The bus interface han-
dles various modes of operation for the coprocessor. We
synthesized this coprocessor for SkyWater 130nm standard
cell technology and a 50MHz clock. Table 3 reports the type
and number of cells used in the design, as well as their
relative area.
4.1 Architecture Correlation Analysis

Stimuli selection plays an important role in ACA, as it
enables a designer to choose which part of a design will
be exercised. In this analysis, we will focus on Architecture
Correlation Analysis for a single key byte in the AES co-
processor. The objective of the ACA is to determine which
cells, among the 9,640 cells in the design, contribute to side-
channel leakage of this key byte. We explicitly differentiate
this objective (ﬁnding leaky gates) from a more traditional
side-channel analysis of the hardware. There is no doubt
that there is side-channel leakage in this design. However,
the object of this experiment is to ﬁnd what cells are most
responsible for this leakage?

4.1.1 Results

We performed ACA as follows. We selected a set of 1024
vectors under a random plaintext and a constant key. Next,
we ran a gate-level simulation and a gate-level power simu-
lation for ACA. Fig. 8 shows the average power trace of the
ﬁrst round at 64 frames per clock cycle, as well as the (sign-
ﬂipped) standard deviation. The clarity of this power trace

Round 1Cycle 1Round 1Cycle 2Round 1Cycle 3Round 1Cycle 4Round 1Cycle 5AverageStdev0501001502002503003504000.20.40.60.8CPA on original AES traces0501001502002503003504000.20.40.60.81.0CPA on AES traces with leaky-gate power removed8

TABLE 4
Leaky Gate Identiﬁcation for AES Coprocessor

Module

File

# Cells

Sequential

Top-level
Decryption
Encryption
Keymem
SBOX
Bus Interface

aes_comp_core.v
aes_comp_decipher_block.v
aes_comp_encipher_block.v
aes_comp_key_mem.v
comp_sbox.v
picoaes.v

5
29
204
1
130
22

0
0
26
0
0
10

Fig. 10. Comparison of a power trace at 64 frames per cycle to a power
trace at 2 frames per cycle. At lower frame counts, the power sample
converges to average power, and the frame size increases.

highlights the strength of ACA to use per-gate activity
traces, which are a byproduct of functional veriﬁcation.

4.1.3 Impact of Frame Size

We also performed an ACA analysis at a frame size of 2
frames per cycle rather than 64 frames per cycle. Fig. 10
shows the effect on the power trace. At wide frame size,
the power converges to the average of the smaller frame
size. In our experiments, we found that a wide frame size is
less precise to pick out leaky gates. For the same trace set as
the previous experiment, the 2-frame-per-cycle version ﬂags
only 122 cells (as opposed to 412 cells) as leaky.

However, the use of a wider frame size may still have
advantages. The 122 cells that are found at a wider frame
size are a subset of the 412 cells found at a smaller frame
size, with an exception of a single cell. Furthermore, there is
a signiﬁcant performance gain in power simulation time at
wider frame sizes (Section 6). We can thus think of power
simulations at wide frame sizes as a quick assessment to
determine the LTI and to scan the overall properties of side-
channel leakage in the design.
4.2 Leaky Gate analysis

We analyzed the type and nature of the 412 cells that are
being ﬂagged as leaky by ACA, under the speciﬁc leakage
model of the SBOX output. The direct analysis of the gate-
level netlist is cumbersome because the synthesized netlist
is ﬂattened, and because most gates have non-descriptive
names such as g136941. However, it is possible to direct
the synthesis tool to keep track of the originating line of
RTL code that results in a speciﬁc gate. This way, we found
that the 412 cells come from 47 unique sites in the RTL code.
This allows the user to identify the RTL source code location
of the leakage, and Table 4 summarizes the identiﬁed gates
by RTL source ﬁle. 21 leaky cells are not identiﬁed by their
RTL origin and are not listed in the table.

The list of cells in Table 4 is intriguing. ACA is able to
identify non-trivial leakage, often occurring as a result of
the integration of cryptographic functions. The following
example illustrates this point. In the Bus interface, the IV
register is ﬂagged as a source of leakage, which is unex-
pected. However, upon inspection of the code, it can be
shown that the IV register senses every output value of
the encryption module. Furthermore, due to the sequential

Fig. 11. Leaky frames in round 6 for a non-speciﬁc test on all state bits
concurrently.

nature of the computation, the encryption module reﬂects
intermediate round values, including each individual SBOX
output. The results in SBOX-related leakage appear at the IV
register. The identiﬁcation of individual RTL ﬁles and line
numbers as leaky, based on a gate-level simulation, is an
important debugging tool in the hands of the designer.
4.3 Non-speciﬁc ACA

We illustrate how ACA identiﬁes leaky cells with a non-
speciﬁc leakage model. In the following example, we create
a non-speciﬁc test on the state variable in round 6 of the
encryption. We use two sets of test vectors, and both contain
random plaintext and key values. However, the second
group contains specially selected (plaintext, key) pairs that
create an all-zero round-6 state variable. Such pairs are easy
to create: select a random key, and decrypt an all-zero state
starting at round 4 of the decryption. The resulting plaintext
is the sought starting value.

Using non-speciﬁc ACA we can identify the gates that
are most affected by this bias, and thus the gates that are
responsible for side-channel leakage. Fig. 11 illustrates the
LTI on round 6, where the bias occurs. The majority of the
frames (251 out of 385 in the trace) are ﬂagged as part of
LTI. Furthermore, after ranking the cells, we identify 2,812
unique cells as correlated with the round-6 state bias. This
is much more than the 412 cells selected using a speciﬁc
leakage model on the ﬁrst key byte. However, this result is
not unexpected: zero-forcing an entire state word (128 bits)
where the expected value would be random is a very sig-
niﬁcant bias, which has an impact throughout the datapath.
Table 5 shows the distribution of the 2,812 cells over the
design.

Among the ﬂagged leaky cells 2,498 gates were traced
back to their RTL design ﬁles. Fig. 12 illustrates the rank
of ﬂagged leaky gates from each design ﬁle with rank=1
belonging to the leakiest gate in the design.

TABLE 5
Leaky Gate Identiﬁcation using non-speciﬁc round-6 state bias

Module

File

# Cells

Sequential

Top-level
Decryption
Encryption
Keymem
SBOX
Bus Interface

aes_comp_core.v
aes_comp_decipher_block.v
aes_comp_encipher_block.v
aes_comp_key_mem.v
comp_sbox.v
picoaes.v

79
351
1172
0
870
277

0
0
128
0
0
0

9

Fig. 13. Block diagram of the RISC-V based SoC including the AES
coprocessor

TABLE 6
Cell type and area for RISC-V based SoC

Type

Cell Count

Area (%)

Sequential
Logic
Total

8,091
21,484
29,575

51.5
48.5
100.0

from software to the hardware coprocessor. Fig. 14 shows a
portion of the driver software. In a 32-bit architecture, a 128-
bit block is loaded using 4 consecutive memory-mapped
writes. The driver ﬁrst loads 4 plaintext words, followed
by 4 key words. Next, the coprocessor control register is
conﬁgured to run a single block encryption. The software
then goes into a polling loop waiting for the coprocessor to
complete operation, about 50 clock cycles later.

5.1.1 Results

We selected a set of 1024 vectors under a random plaintext
and a constant key. We then ran a gate-level simulation
and a gate-level power simulation at 5 frames per clock
cycle. Fig. 15 shows a sample power trace from the sim-
ulation. The testbench covers software activity as well as
hardware activity. The hardware activity uses considerably
more power than software because of the higher parallelism
of the hardware coprocessor implementation. However, be-
cause of the noiseless simulation, the overall operation is
visible with remarkable clarity. The trace starts with the
software transmitting a key value, followed by a plaintext
value. Fig. 15 shows a series of 8 notches in the power
trace which correspond to reduced power consumption.
These are caused by pipeline stall operations on the RISC-V
processor (Fig. 14 lines 3, 5, 7, 9, 12, 14, 16, 18). Next, the
software triggers the hardware AES execution, which runs
the key schedule followed by 10 rounds. Finally, the RISC-V
software retrieves the ciphertext.

We next ran ACA using the aforementioned speciﬁc leak-
age model on the Hamming Weight of the input of round 1.
We identify the LTI with a ρthreshold of 0.2, which ﬂags 91
frames out of the 710 frames as containing potentially leaky
samples. By correlating the transitions by cells within LTI
with the speciﬁc leakage model, 1,298 cells are then ﬂagged
as leaky. This group represents 4.38 % of the total number
of 29,575 cells.

5.2 Leaky Gate Analysis

Fig. 16 shows the distribution of leaky frames over the
testbench. The leakage model is HW (key⊕pt). Remarkably,
the bulk of the leaky frames occurs during the software driver

Fig. 12. Leaky gate ranks identiﬁed by non-speciﬁc test in ACA on AES
coprocessor sectioned into RTL design ﬁles.

We caution that a strongly biased test, such as this all-
zero round-6 non-speciﬁc test, always results in aggressive
leaky cell selection. However, a weaker form of the test is
easy to deﬁne, for example by biasing only a single state
byte of round 6. The non-speciﬁc ACA test lets a user
evaluate the impact of an arbitrarily chosen bias in the
cipher.

5 ACA ON RISC-V BASED SOC
To investigate the scalability of ACA we also applied the
methodology on the SoC shown in Fig. 13. A 5-stage
pipelined RISC-V core (fetch, decode, execute, memory,
write-back) integrates a collection of peripherals including
the memory-mapped AES coprocessor discussed in Sec-
tion 4. In a typical access sequence, the RISC-V software
uploads a key and a block of plaintext to the coprocessor,
and then uses the control/status register of the coprocessor
to start the encryption and monitor the completion ﬂag. The
RISC-V software then retrieves a block of ciphertext. This
design is considerably more complicated than the stand-
alone AES design, and covers a software and a hardware
component. Table 6 shows synthesis results for SkyWater
130nm standard cells at 50MHz clock. The overall design is
three times larger than the AES coprocessor by itself.

5.1 Architecture Correlation Analysis

In this test, we are investigating the hardware/software
interface between the RISC-V software and the AES copro-
cessor. Therefore, we apply ACA with a speciﬁc leakage
model using the Hamming Weight on the output of the pre-
whitening round. This will enable the monitoring of any
interactions between the plaintext and the key on the path

05001000150020002500Gate index05001000150020002500Leaky gate rankaes_comp_core.vaes_comp_encipher_block.vcomp_sbox.vaes_comp_decipher_block.vpicoaes.vAESRISC‐VUARTDMAMemory InterfaceTimerExternalMemoryGPIOFig. 14. RISC-V driver software for AES Coprocessor

10

l i
lw
sw
lw
sw
lw
sw
lw
sw
l i
lw
sw
lw
sw
lw
sw
lw
sw
l i
sw
l i
sw
l i
. L121 :
lw
bne

a4 , 8
a3 , 0 ( a4 )
a3 , 4 ( a5 )
a3 , 4 ( a4 )
a3 , 8 ( a5 )
a3 , 8 ( a4 )
a3 , 1 2 ( a5 )
a4 , 1 2 ( a4 )
a4 , 1 6 ( a5 )
a4 , 2 4
a3 , 0 ( a4 )
a3 , 2 0 ( a5 )
a3 , 4 ( a4 )
a3 , 2 4 ( a5 )
a3 , 8 ( a4 )
a3 , 2 8 ( a5 )
a4 , 1 2 ( a4 )
a4 , 3 2 ( a5 )
a4 , 6
a4 , 0 ( a5 )
a4 , 4
a4 , 0 ( a5 )
a3 , 1

a4 , 6 8 ( a5 )
a4 , a3 , . L121

load p l a i n t x t [ 0 ]

load p l a i n t x t [ 1 ]

load p l a i n t x t [ 2 ]

load p l a i n t x t [ 3 ]

;
; STALL
;
; STALL
;
; STALL
;
; STALL

;
; STALL
;
; STALL
;
; STALL
;
; STALL

load key [ 0 ]

load key [ 1 ]

load key [ 2 ]

load key [ 3 ]

;

;

c o n t r o l

s t a r t

Fig. 15. Power trace of the RISC-V based SoC

activity, while the key is being loaded into the coprocessor.
In addition, there is also leakage during the ﬁrst round of
the encryption, which is expected.

ACA demonstrates that the RISC-V processor, the mem-
ory bus, and the memory-mapped AES coprocessor are all
potential contributors to side-channel leakage. The origin
of such leakage is caused by the interaction of values over
shared storage and interconnect. The leakage occurs in the
processor micro-architecture because the driver software
writes the key after the plaintext. There is a minor hint of
this issue in the software driver itself. The ﬁrst key byte
is loaded in register a3, which still contains a portion of
plaintext. This leads to distance-based leakage conforming
to the leakage model.

Table 7 shows the distribution of the 1,298 leaky cells
over the design. There are indeed a large number of leaky
gates located within the RISC-V processor. We analyze two
examples below.

The highest-ranked leaky gate (with a correlation of
0.463) in the SoC is the pipeline register of the memory stage
which, in its data-path components, transfers the contents of
the second source register and the result of the ALU from
the execute to the memory stage. Even for instructions that
do not need ALU operation, the ALU result is written with

Fig. 16. Leaky Frame Selection in ACA on RISC-V based SoC

TABLE 7
Leaky Gate Identiﬁcation for RISC-V based SoC

Module

File

# Cells

Seq

AES Coprocessor
AES top
Decryption
Encryption
KeyMem
Bus Interface
SBOX

aes_comp_core.v
aes_comp_decipher_block.v
aes_comp_encipher_block.v
aes_comp_key_mem.v
aes_top.v
comp_sbox.v

RISC-V
ALU
Control
Control
Memory
Memory
Pipeline
Regﬁle

Peripherals
GPIO
DMA Bus Control
UART
DMA
DMA
DMA
DMA
DMA
DMA

ALU.v
control_unit.v
controller.sv
memory_arbiter.v
memory_interface.v
pipeline_register.v
regFile.v

gpio_top.v
s_axi_controller.sv
simpleuart.v
transposer.sv
ca_prng.v
dma_top.v
fifo_dma.sv
fifo.v
tDMA.sv

2
21
27
1
130
108

332
2
10
11
3
66
248

3
3
3
3
4
6
3
2
2

0
0
14
0
112
0

0
0
0
0
0
31
248

0
0
0
0
0
0
0
0
0

the addition of the two source operands. Therefore the same
transitional leakage discussed for a3 register can occur for
the ALU result register.

The leakage from the peripherals is caused by the trans-
mission of key and plaintext on the memory interface.
At the connection point of each peripheral module to the
memory interface there are multiplexers to decide whether
the transmitted data should be admitted to the current
peripheral. Such interconnect logic can manifest Hamming
weight leakage of the plaintext and key.

These examples demonstrate that ACA is a powerful
debugging tool, as it can highlight side-channel leakage of
the gate-level implementation at the RTL level.

Load KEYRound 1TABLE 8
ACA Performance for various steps in the ﬂow. Performance numbers
in user seconds∗ for 1024 Vectors.
AES Coprocessor

RISC-V based SoC

Gate-level Synthesis
Simulation
Power Estimation

64 frames/cycle
2 frames/cycle
5 frames/cycle
Correlation Analysis

392
2,436

7,862
1,557

<60

1,201
6,996

31,201
<60

∗Xeon Gold 6248 CPU @ 2.50GHz, 384G Workstation

6 ACA PERFORMANCE CONSIDERATIONS

ACA adds a new design step to the overall design ﬂow, and
thus the cost of running ACA in comparison to other tools in
the design ﬂow must be considered. Table 8 summarizes the
runtime performance of ACA analysis. There are three major
components that consume the bulk of the execution time:
logic synthesis, functional gate-level simulation, and gate-
level power simulation. The ACA correlation component is
minor and typically takes less than a minute to complete.
Overall, we observe that gate-level power simulation is
a dominant factor that is more complex than gate-level
synthesis and gate-level simulation. The overall runtime is
strongly affected by the design size and the total number
of frames per trace. On the plus side, the power simulation
step is embarrassingly parallel. Each test vector can be run
independently from the other. In our experiments, we did
not use any parallel execution.

7 CONCLUSIONS

Gate-level leakage assessment is a tool that supports a
designer to identify leaky gates in a pre-silicon design
context. Our methodology relies on industry-standard tools
including logic synthesis, gate-level simulation, and gate-
level power estimation, together with scripting on the inter-
mediate results. Architecture Correlation Analysis, the un-
derlying detection technique to support gate-level leakage
assessment, can serve as a veriﬁcation technique as well
as as a basis for countermeasure design. In particular, by
moving the leaky gates ﬂagged by ACA into a separate
power domain, a low-cost countermeasure may be enabled
that requires only selective replacement of cells in a design.

REFERENCES

[1]

S. Nikova, C. Rechberger, and V. Rijmen, “Threshold implemen-
tations against side-channel attacks and glitches,” in International
conference on information and communications security.
Springer,
2006, pp. 529–545.

[2] A. Moradi, “Side-channel leakage through static power - should
in practice?” in Cryptographic Hardware and
we care about
Embedded Systems - CHES 2014 - 16th International Workshop,
Busan, South Korea, September 23-26, 2014. Proceedings, ser. Lecture
Notes in Computer Science, L. Batina and M. Robshaw, Eds.,
vol. 8731.
[Online]. Available:
https://doi.org/10.1007/978-3-662-44709-3 31

Springer, 2014, pp. 562–579.

[3] Z. Chen, S. Haider, and P. Schaumont, “Side-channel leakage
in masked circuits caused by higher-order circuit effects,” in
Advances in Information Security and Assurance, Third International
Conference and Workshops, ISA 2009, Seoul, Korea, June 25-27,
2009. Proceedings, ser. Lecture Notes in Computer Science, J. H.
Park, H. Chen, M. Atiquzzaman, C. Lee, T. Kim, and S. Yeo,
Eds., vol. 5576. Springer, 2009, pp. 327–336. [Online]. Available:
https://doi.org/10.1007/978-3-642-02617-1 34

11

[4]

I. Giechaskiel, K. Eguro, and K. B. Rasmussen, “Leakier wires:
Exploiting fpga long wires for covert- and side-channel attacks,”
ACM Trans. Reconﬁgurable Technol. Syst., vol. 12, no. 3, aug 2019.
[Online]. Available: https://doi.org/10.1145/3322483

[5] Y. Yao, T. Kathuria, B. Ege, and P. Schaumont, “Architecture
correlation analysis (aca): identifying the source of side-channel
leakage at gate-level,” in 2020 IEEE International Symposium on
Hardware Oriented Security and Trust (HOST).
IEEE, 2020, pp.
188–196.

[7]

[6] Y. Yao, T. Tufan, T. Kathuria, B. Ege, U. Guler, and P. Schaumont,
“Pre-silicon architecture correlation analysis (paca): Identifying
and mitigating the source of side-channel leakage at gate-level.”
IACR Cryptol. ePrint Arch., vol. 2021, p. 530, 2021.
I. Buhan, L. Batina, Y. Yarom, and P. Schaumont, “Sok: Design
tools for side-channel-aware implementations,” Cryptology ePrint
Archive, Report 2021/497, 2021, https://ia.cr/2021/497.
J. den Hartog, J. Verschuren, E. P. de Vink, J. de Vos, and
W. Wiersma, “PINPAS: a tool for power analysis of smartcards,”
in SEC, 2003, pp. 453–457.

[8]

[9] D. McCann, E. Oswald, and C. Whitnall, “Towards practical tools
for side channel aware software engineering: ‘grey box’ modelling
for instruction leakages,” in USENIX Security Symposium, 2017, pp.
199–216.

[10] M. A. Shelton, N. Samwel, L. Batina, F. Regazzoni, M. Wagner,
and Y. Yarom, “Rosita: Towards automatic elimination of power-
analysis leakage in ciphers,” in NDSS, 2021.

[11] N. Sehatbakhsh, B. B. Yilmaz, A. G. Zajic, and M. Prvulovic,
“EMSim: A microarchitecture-level simulation tool for modeling
electromagnetic side-channel signals,” in HPCA, 2020, pp. 71–85.
[12] D. Sijacic, J. Balasch, B. Yang, S. Ghosh, and I. Verbauwhede,
“Towards efﬁcient and automated side-channel evaluations at
design time,” J. Cryptogr. Eng., vol. 10, no. 4, pp. 305–319, 2020.

[13] A. Nahiyan,

J. Park, M. He, Y.

Iskander, F. Farahmandi,
D. Forte, and M. Tehranipoor, “Script: A cad framework for
power side-channel vulnerability assessment using information
ﬂow tracking and pattern generation,” ACM Trans. Des. Autom.
Electron. Syst., vol. 25, no. 3, may 2020. [Online]. Available:
https://doi.org/10.1145/3383445

[14] F. Regazzoni, S. Badel, T. Eisenbarth, J. Großsch¨adl, A. Poschmann,
Z. T. Deniz, M. Macchetti, L. Pozzi, C. Paar, Y. Leblebici, and
P. Ienne, “A simulation-based methodology for evaluating the
dpa-resistance of cryptographic functional units with application
to CMOS and MCML technologies,” in Proceedings of
the
2007 International Conference on Embedded Computer Systems:
Architectures, Modeling and Simulation (IC-SAMOS 2007), Samos,
Greece, July 16-19, 2007, 2007, pp. 209–214. [Online]. Available:
https://doi.org/10.1109/ICSAMOS.2007.4285753

[15] P. SLPSK, P. K. Vairam, C. Rebeiro, and K. Veezhinathan, “Karna:
A gate-sizing based security aware eda ﬂow for improved power
side-channel attack protection,” in Proceedings of the International
Conference on Computer-Aided Design, ICCAD 2019, Westminster,
CO, USA, November 04-07, 2019.

[16] M. T. He, J. Park, A. Nahiyan, A. Vassilev, Y. Jin, and M. M.
Tehranipoor, “RTL-PSC: automated power side-channel leakage
assessment at register-transfer level,” in VTS, 2019, pp. 1–6.
[17] M. A. K. F, V. Ganesan, R. Bodduna, and C. Rebeiro, “PARAM:
A microprocessor hardened for power
side-channel attack
resistance,” in 2020 IEEE International Symposium on Hardware
Oriented Security and Trust, HOST 2020, San Jose, CA, USA,
December 7-11, 2020.
IEEE, 2020, pp. 23–34. [Online]. Available:
https://doi.org/10.1109/HOST45689.2020.9300263

[18] B. Gigerl, V. Hadzic, R. Primas, S. Mangard, and R. Bloem,
“Coco: Co-design and co-veriﬁcation of masked software
implementations on cpus,” in 30th USENIX Security Symposium,
USENIX Security 2021, August 11-13, 2021, M. Bailey and
R. Greenstadt, Eds. USENIX Association, 2021, pp. 1469–
1468. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity21/presentation/gigerl

[19] G. Goodwill, B. Jun, J. Jaffe, P. Rohatgi et al., “A testing method-
ology for side-channel resistance validation,” in NIST non-invasive
attack testing workshop, vol. 7, 2011, pp. 115–136.

[20] P. Kiaei, Z. Liu, R. K. Eren, Y. Yao, and P. Schaumont, “Saidoyoki:
Evaluating side-channel leakage in pre- and post-silicon setting,”
Cryptology ePrint Archive, Report 2021/1235, 2021, https://ia.cr/
2021/1235.

[21] P. Kiaei, Z. Liu, and P. Schaumont, “Leverage the average: Aver-

aged sampling in pre-silicon side-channel leakage assessment,” in
Proceedings of the 2022 on Great Lakes Symposium on VLSI, 2022.
[22] D. Das, M. Nath, B. Chatterjee, S. Ghosh, and S. Sen, “STELLAR:
A generic EM side-channel attack protection through ground-up
root-cause analysis,” in IEEE International Symposium on Hardware
Oriented Security and Trust, HOST 2019, McLean, VA, USA,
May 5-10, 2019.
IEEE, 2019, pp. 11–20. [Online]. Available:
https://doi.org/10.1109/HST.2019.8740839

Pantea Kiaei (Student Member, IEEE) is a Ph.D. student in Electrical
and Computer Engineering at Worcester Polytechnic Institute. She re-
ceived her MS degree in Computer Engineering from Virginia Tech in
2019 and prior to that received her BS degree in Electrical Engineering
from Sharif University of Technology, Iran, in 2017. She has reviewed
papers for ACM TECS, ACM JETC, and IEEE TVLSI journals. Her re-
search interests include secure hardware design, computer architecture,
and trustworthy secure systems.

Yuan Yao received her bachelor’s degree in Electronic Engineering from
Northwestern Polytechnical University, Xi’an, China in 2014. She got her
Master’s Degree in Electrical and Computer Engineering from Cornell
University, Ithaca, US in 2016. Currently she is a Ph.D. candidate at the
Bradley Department of Electrical and Computer Engineering, Virginia
Tech. She serves as reviewer for several IEEE and ACM journals. Her
research area include pre-silicon side-channel analysis, side-channel at-
tacks and countermeasures, fault attacks and countermeasures, secure
hardware design.

Zhenyuan Liu (Student Member, IEEE) is a Ph.D. student in Electri-
cal and Computer Engineering at Worcester Polytechnic Institute. She
received her MS degree in Electrical and Computer Engineering from
Worcester Polytechnic Institute in 2020 and prior to that received her BS
degree in Engineering of Science from Trinity University, San Antonio,
Texas, in 2019. Her research interests include side-channel attacks,
leakage assessments and micro-architectural hardware security.

Nicole Fern is a Senior Security Analyst at Riscure. She received her
undergraduate degree in Electrical Engineering from The Cooper Union
for the Advancement of Science and Art (2011) and her PhD degree in
Electrical & Computer Engineering from University of California, Santa
Barbara (2016). She continued her research in hardware security as
a post-doc before joining industry in 2018. She previously worked at
Tortuga Logic, a hardware security startup, for 2.5 years before joining
Riscure in June of 2021.

12

In the past, Jasper worked for a penetration testing ﬁrm, where he
performed source code review, binary reverse engineering and tested
application and network security.

At Riscure, Jasper’s expertise has grown to include various aspects
of hardware security; from design review and logical testing, to side-
channel analysis and perturbation attacks.

Jasper has spoken at many security conferences including BlackHat
brieﬁngs and trainings, Intel Security Conference, RWC, RSA, EDSC,
BSides SF, Shakacon, ICMC, Inﬁltrate, has presented scientiﬁc research
at SAC, WISSEC, CT-RSA, FDTC, ESC Design West,East, ARM Tech-
Con, has reviewed papers for CHES and JC(rypto)EN, and has given
invited talks at Stanford, NPS, GMU and the University of Amsterdam.

Kate Gillis received a B.S. in Electrical and Computer Engineering from
Worcester Polytechnic Institute (WPI) in 2016. She has been at Intrinsix
Corp. in Marlborough, MA since the same year, where she is currently
a Veriﬁcation Engineer and has worked to design and implement block-
level, SoC and mixed signal veriﬁcation on a variety of ASIC designs.
Her awards and honors include the Provost’s MQP (senior capstone)
Award and the Salisbury Prize, both at WPI.

Alex Dich received a B.S. in electrical and computer engineering from
Worcester Polytechnic Institute, Worcester, MA in 2014. He has been
at Intrinsix Corp., Marlborough, MA since 2014, where he is a Senior
Design Engineer focused on front-end digital ASIC design. His interests
include digital signal processing, cryptography, hardware acceleration,
and processor architecture.

Peter J. Grossmann received a B.S. in engineering from Harvey Mudd
College, Claremont, CA in 2001, an M.S. in electrical engineering from
the University of Washington, Seattle, WA in 2006, and a PhD in com-
puter engineering from Northeastern University, Boston, MA in 2013.
He has been at Intrinsix Corp., Marlborough, MA since 2019, where
he is currently a Solutions Architect focused on advanced research. He
worked as Associate Staff and Technical Staff at MIT Lincoln Laboratory
from 2007 to 2019, and as an ASIC Design Engineer at Zilog, Inc. from
2001 to 2004. His research interests include architecture and CAD for
ﬁeld programmable gate arrays, low power digital circuit design, and
enhancing electronic design automation ﬂows for security. Dr. Gross-
mann’s awards and honors include the 2017 MIT Lincoln Laboratory
Best Invention award and the University of Washington Top Scholar
award.

Cees-Bart Breunesse is a principal security analyst at Riscure North
America. He received his Ph.D. in Computer Science from Radboud Uni-
versity, Netherlands, in 2005. Prior to that, he received his MSc degree
in Computer Science in 2000 from Utrecht University, Netherlands. His
research interests include security of embedded devices, side-channel,
and fault injection.

Jasper van Woudenberg (@jzvw) currently is CTO for Riscure North
America and half of the authors of the ”Hardware Hacking Handbook:
Breaking Embedded Security with Hardware Attacks”. He works with
Riscure’s San Francisco based team to improve embedded device se-
curity through innovation.

Patrick Schaumont (Senior Member, IEEE) is a Professor in Computer
Engineering at WPI. He received the Ph.D. degree in Electrical Engi-
neering from UCLA in 2004 and the MS degree in Computer Science
from Ghent University in 1990. He was a staff researcher at IMEC,
Belgium from 1992 to 2000. He was a faculty member with Virginia Tech
from 2005 to 2019. He joined WPI in 2020. He was a visiting researcher
at the National Institute of Information and Telecommunications Technol-
ogy (NICT), Japan in 2014. He was a visiting researcher at Laboratoire
d’Informatique de Paris 6 in Paris, France in 2018. He is a Radboud Ex-
cellence Initiative Visiting Faculty with Radboud University, Netherlands
from 2020. His research interests are in design and design methods of
secure, efﬁcient and real-time embedded computing systems.

