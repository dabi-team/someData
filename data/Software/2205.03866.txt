2
2
0
2

y
a
M
8

]
h
p
-
t
n
a
u
q
[

1
v
6
6
8
3
0
.
5
0
2
2
:
v
i
X
r
a

isQ: Towards a Practical Software Stack for
Quantum Programming

Jingzhe Guo∗, Huazhe Lou†, Riling Li‡, Wang Fang‡, Junyi Liu‡, Peixun Long‡, Shenggang Ying‡,
and Mingsheng Ying‡∗
∗Department of Computer Science and Technology
Tsinghua University
Beijing, China.
Email: gjz20@mails.tsinghua.edu.cn, yingmsh@tsinghua.edu.cn
†Arclight Quantum Computing Inc.
Beijing, China.
Email: louhz@arclightquantum.com
‡State Key Laboratory of Computer Science
Institute of Software, Chinese Academy of Sciences
Beijing, China.
Email: {lirl,fangw,liujy,longpx,yingsg,yingms}@ios.ac.cn

Abstract—We introduce isQ, a new software stack for
quantum programming in an imperative programming lan-
guage, also named isQ. The aim of isQ is to make the
programmers write quantum programs as conveniently as
possible. In particular:

1) The isQ language and its compiler contain many
features, including some not well supported by (most)
other quantum programming platforms, e.g. classical
control ﬂow such as recursion; decomposition of self-
deﬁned unitary gates; and oracle programming and its
circuit realization.

2) To make it ﬂexible, an isQ program can be compiled
into several kinds of intermediate representation, in-
cluding OpenQASM 3.0, QIR and QCIS (specially
tailored for the superconducting quantum hardware at
USTC).

3) Besides interfacing isQ with true superconducting
hardware, a QIR simulator is also developed for
demonstration and testing of isQ programs.

Index Terms—quantum programming, compiler, quantum

circuit.

I. INTRODUCTION

Recent progress in quantum hardware convinces peo-
ple of
the possibility that quantum computers out-
perform their classical predecessors in solving some
important problems [1–4]. We have entered a noise-
intermediate-scale-quantum (NISQ) era as the quantum
hardware keeps advancing. However, just like classical
computers, quantum hardware cannot unleash its full
power unless equipped with a series of quantum com-
puting software, including but not limited to:

Jingzhe Guo and Huazhe Lou contribute equally to this paper.
Riling Li and Mingsheng Ying are the corresponding authors.

• quantum programming language(s)

for writing

quantum programs;

• quantum compilers for optimization and transfor-
mation of quantum programs, as well as compil-
ing quantum programs to different hardwares, e.g.
trapped-iron and superconducting devices;

• quantum simulators

for debugging small-scale

quantum programs, etc.

In this paper, we present isQ, a software stack for

quantum programming towards practical use.

isQ was ﬁrst proposed as an experimental and edu-
cational language [5]. The ﬁrst version of its compiler
was implemented in Python using PLY [6] module,
converting abstract syntax tree (AST) from the input isQ
programs directly into a kind of modiﬁed Quil IR [7].
Whereas the original isQ language has limited features,
and the compiler is not extensible, e.g.
it’s hard to
implement sophisticated compiler optimizations [8]. To
design a truly practical and extensible software stack that
permits more language features and various compiler
optimizations, we extended isQ language and reimple-
mented the compiler based on MLIR [9] infrastructure.
Speciﬁcally, we designed isQ-IR, an MLIR dialect as
our compiler frontend target, and implemented vari-
ous transformation passes that are useful for compiling
quantum programs, e.g. gate decomposition and qubit
mapping, as well as code generators that convert isQ-IR
to different kinds of low-level intermediate representa-
tion (IR) including QIR [10], OpenQASM 3.0 [11] and
QCIS [12].

Main Contributions: More explicitly, the contributions

of this paper are:

• We propose isQ, an imperative quantum program-

 
 
 
 
 
 
Languages/Projects
Q#
Scaffold
Qiskit/OpenQASM 2.01
OpenQASM 3.02
Silq
Quingo
QCOR
isQ

√
√
√

?
?
√
√
√

Complete compiler Hardware connection Auto decomposition
?

Partial

Classical control ﬂow Oracle programming

√

√
√

√

?
√
√
√

√
√
√
√
√

√

√

√

√

TABLE I
Comparison of several quantum programming languages/compiler projects. We list ﬁve features. Some of the features belong to the language
speciﬁcation, and others belong to the compiler functions. Speciﬁcally, ’complete compiler’ means whether the developers have designed a
complete compiler for such language; ’auto decomposition’ indicates the ability to decompose from high-level gate deﬁnitions like unitary
matrices down to basic gates like U3 and CNOT; ’hardware connection’ means whether such language could be compiled into a practical
hardware instruction set or interfaced with some hardware backends; ’oracle programming’ means whether it permits deﬁning quantum
oracles on the language level. The question mark ”?” means the feature might have been already implemented/in progress in corresponding
languages, but we ﬁnd no open and rigorous materials as evidence.

own QIR simulator that can execute QIR pro-
grams compiled by isQ compiler. The simulator
provides an interface for supporting different
backends, as well as a built-in CPU backend and
a built-in CUDA backend.

– isQ programs without feedback control can be
compiled to QCIS assembly, which can be ex-
ecuted on the superconducting quantum hard-
ware at USTC (University of Science and Tech-
nology of China).

– isQ-IR can also be compiled into OpenQASM
3.0, while most high-level structures in isQ can
be preserved and converted to OpenQASM 3.0
control ﬂow.

II.

ISQ LANGUAGE SPECIFICATION

In this section, we introduce quantum programming
language isQ, the basis of our software stack. isQ is an
imperative quantum programming language that sup-
ports oracle deﬁnition, arbitrary unitary gate deﬁnition,
classical control ﬂow and other underlying features.

A. Grammar

To give an overall picture of isQ syntax, we summarize
it in Backus-Naur form (BNF) in Figure 2. Let us further
describe notable features of isQ in detail:

1) Decorated gates and gate deriving notation: Controlled
and/or adjoint quantum gates have been proved useful
in the construction of quantum circuits. isQ supports
using quantum gates in their decorated form, i.e. in
(multi-)controlled or adjoint (inverse) version:

• “ctrl(cid:104)N(cid:105)” can be added before gate calling to add
N controller bits to the gate. (cid:104)N(cid:105) can be omitted for
N = 1.

• “nctrl(cid:104)N(cid:105)” can be added to add N negated-
controller bits to the gate, i.e. appending X gates

1The control ﬂow in Qiskit is mainly on the Python level. In

OpenQASM 2.0 the control ﬂow is not well supported.

2To our knowledge, Qiskit has not fully supported OpenQASM 3.0

yet.

Fig. 1. The structure of isQ compilation stack. The compiler will
ﬁrst compile the input programs into isQ-IR, and then generate the
target codes such as QCIS, OpenQASM 3.0 and QIR. Optimizations
are permitted throughout the whole compilation process. Finally the
output QCIS and QIR codes could be executed on corresponding
hardware and simulators.

ming language that provides a handful of useful
language features that simplify the construction of
quantum programs.

• We propose isQ-IR, an intermediate representation
for quantum programs, by leveraging MLIR [9] di-
alect infrastructure and representing qubit dataﬂow
in SSA form, thus allowing easy transformation of
quantum programs.

• We built a versatile software stack around isQ and
isQ-IR. In particular, we implement a compiler that
can compile and optimize isQ programs into isQ-
IR, and thus onto multiple backends including QIR,
OpenQASM 3, and real-device QCIS:

– For debugging purposes, we implemented our

Syntax & Grammar CheckType checkMLIR GenerationClassical SimplificationsDecompose controlled U3Pauli-rotation to U3Fold decorated gatesRecognize famous gatesDecompose known matricesRemove trivial gatesReg2mem, lower to QIRRun on isQ SimulatorReg2mem, lower to QIRQubit mappingCheck & Retarget to QCISOpenQASM 3.0 codegenQCIS code generationisQ Source codeisQ-IRisQ-IRFront-endMLIR-basedoptimizerBackend code generationQCIS AssemblyRun on QCISsuperconducting devicesOpenQASM 3.0Source code(cid:104)program(cid:105) ::= (cid:104)topDefStmt(cid:105) ;

| (cid:104)topDefStmt(cid:105) ; (cid:104)program(cid:105)

(cid:104)topDefStmt(cid:105) ::= (cid:104)varDefStmt(cid:105) | (cid:104)gateDefStmt(cid:105) | (cid:104)oracleDefStmt(cid:105) | (cid:104)procedure(cid:105)
(cid:104)varDefStmt(cid:105) ::= (cid:104)type(cid:105) IDENTIFIER (cid:104)varDefInit(cid:105)
(cid:104)varDefInit(cid:105) ::= = (cid:104)expr(cid:105) | [ (cid:104)expr(cid:105) ] | (cid:101)

(cid:104)gateDefStmt(cid:105) ::= defgate IDENTIFIER = [ (cid:104)matrix(cid:105) ]

(cid:104)matrix(cid:105) ::= (cid:104)list(cid:105) | (cid:104)matrix(cid:105) ; (cid:104)list(cid:105)
(cid:104)list(cid:105) ::= (cid:104)expr(cid:105) | (cid:104)list(cid:105) , (cid:104)expr(cid:105)

(cid:104)oracleDefStmt(cid:105) ::= oracle IDENTIFIER ( NATURAL , NATURAL ) = [ (cid:104)list(cid:105) ]

(cid:104)procReturnType(cid:105) ::= (cid:104)type(cid:105) | procedure

(cid:104)procedure(cid:105) ::= (cid:104)procReturnType(cid:105) IDENTIFIER ( (cid:104)procArgs(cid:105) ) { (cid:104)procBody(cid:105) } (cid:104)procDerive(cid:105)
(cid:104)procArgs(cid:105) ::= (cid:104)procArg(cid:105) | (cid:104)procArgs(cid:105) , (cid:104)procArg(cid:105) | (cid:101)
(cid:104)procArg(cid:105) ::= (cid:104)type(cid:105) IDENTIFIER | (cid:104)type(cid:105) IDENTIFIER [ ] | (cid:104)type(cid:105) IDENTIFIER [ (cid:104)expr(cid:105) ]

(cid:104)procDerive(cid:105) ::= (cid:101) | deriving gate

(cid:104)procBody(cid:105) ::= (cid:101) | (cid:104)procStmt(cid:105) ; (cid:104)procBody(cid:105)
(cid:104)procStmt(cid:105) ::= (cid:104)ifStmt(cid:105) | (cid:104)forStmt(cid:105) | (cid:104)whileStmt(cid:105) | (cid:104)varDefStmt(cid:105) | (cid:104)callStmt(cid:105)

| (cid:104)assignStmt(cid:105) | (cid:104)returnStmt(cid:105) | (cid:104)measureStmt(cid:105) | (cid:104)resetStmt(cid:105) | (cid:104)printStmt(cid:105)
| continue | break | pass

(cid:104)ifStmt(cid:105) ::= if (cid:104)expr(cid:105) { (cid:104)procBody(cid:105) } | if (cid:104)expr(cid:105) { (cid:104)procBody(cid:105) } else { (cid:104)procBody(cid:105) }

(cid:104)forStmt(cid:105) ::= for IDENTIFIER in (cid:104)range(cid:105) { (cid:104)procBody(cid:105) }
(cid:104)range(cid:105) ::= (cid:104)expr(cid:105) : (cid:104)expr(cid:105) | (cid:104)expr(cid:105) : (cid:104)expr(cid:105) : (cid:104)expr(cid:105)

(cid:104)whileStmt(cid:105) ::= while (cid:104)expr(cid:105) { (cid:104)procBody(cid:105) }

(cid:104)callStmt(cid:105) ::= (cid:104)gateDecoration(cid:105) IDENTIFIER ( (cid:104)listMaybe(cid:105) )

(cid:104)gateDecoration(cid:105) ::= (cid:101) | (cid:104)gateDecoration(cid:105) ctrl (cid:104) NATURAL (cid:105) | (cid:104)gateDecoration(cid:105) ctrl

| (cid:104)gateDecoration(cid:105) nctrl (cid:104) NATURAL (cid:105) | (cid:104)gateDecoration(cid:105) nctrl | (cid:104)gateDecoration(cid:105) inv

(cid:104)assignStmt(cid:105) ::= (cid:104)expr(cid:105) = (cid:104)expr(cid:105)
(cid:104)returnStmt(cid:105) ::= return (cid:104)expr(cid:105)
(cid:104)measureStmt(cid:105) ::= M ( (cid:104)expr(cid:105) )
(cid:104)resetStmt(cid:105) ::= (cid:104)expr(cid:105) = |0(cid:105)
(cid:104)printStmt(cid:105) ::= print (cid:104)expr(cid:105)

(cid:104)expr(cid:105) ::= NATURAL | IDENTIFIER | REALFLOAT | IMAGFLOAT | BOOLEAN

| (cid:104)expr(cid:105) (cid:104)bop(cid:105) (cid:104)expr(cid:105) | (cid:104)uop(cid:105) (cid:104)expr(cid:105) | ( (cid:104)expr(cid:105) ) | (cid:104)expr(cid:105) [ (cid:104)expr(cid:105) ]
| (cid:104)expr(cid:105) ( (cid:104)expr(cid:105) ) | (cid:104)resetStmt(cid:105)

(cid:104)type(cid:105) ::= int | qbit | double
(cid:104)bop(cid:105) ::= + | − | ∗ | / | (cid:62) | (cid:54) | > | < | = | ! = | ∗ ∗
(cid:104)uop(cid:105) ::= + | −

IDENTIFIER ::= [a − zA − Z][a − ZA − Z0 − 9_]∗

NATURAL ::= 0 | [1 − 9][0 − 9]∗

REALFLOAT ::= N ATURAL (\. [0 − 9]∗)?([eE][\ − \+][0 − 9]+)?
IMAGFLOAT ::= REALFLOAT j

Fig. 2. The grammar structure of isQ in BNF. Here the productions of IDENTIFIER, NATURAL, REALFLOAT and IMAGFLOAT are not in
strict BNF (they are regular expressions instead), but we put them into the overall grammar structure for reading convenience.

before and after controller bits. (cid:104)N(cid:105) can be omitted
for N = 1.

• “inv” can be added to use the adjoint (inverse)

version of the gate.

Specially,

isQ allows user-deﬁned gates by adding
“deriving gate” notation to a procedure deﬁnition. The
procedure must satisfy the following conditions:

• The parameters of the procedure must start with
zero or more classical (i.e. boolean, ﬂoating, integer)
parameters, and then zero or more qbit parameters.
No qbit arrays are allowed. Thus all user-deﬁned
gates are ﬁxed-sized.

• The procedure should have no return value.
• If an adjoint version of the gate is used, no clas-
sical control ﬂow statements should appear in the
procedure body.

• No measurement or side effects are allowed in the
procedure body. While ancilla qubit allocation is
allowed, the programmer should guarantee that all
ancilla qubits are reset to |0(cid:105) when released.

When decorated forms of user-deﬁned gates are used,
isQ will automatically generate controlled and adjoint
versions of these gates. For controlled gates, new qubit
parameters are inserted after the classical parameters
and before original qbit parameters. For example, using
ctrl RZ gate, which has argument types (double, qbit)
requires parameters to be passed in as (double, qbit,
qbit) where controller qubit is the second argument.

2) Classical computation support: isQ provides support
for classical computation. Useful integer and ﬂoating-
point arithmetic are provided for programmers to ac-
complish common classical computing tasks, e.g. calcu-
lating gate parameter and counting measurement out-
comes. isQ also provides full classical control ﬂow sup-
port, including if-statement, for-and-while-loops, and
procedure calls. These classical computation infrastruc-
tures allow programmers to write quantum-classic hy-
brid programs easily without having to use another host
language.

3) Oracle support: Quantum oracles are important con-
structs in quantum algorithms like Grover search [13] or
recursive Fourier sampling [14]. Currently, isQ language
permits oracle deﬁnition by writing out the truth table
of oracle functions with type f : {0, 1}m → {0, 1}n. For
example,

oracle F(2,1) = [0,0,1,0];
// In procedure:
qbit a[2],b;
F (a[0],a[1],b)

In the code fragment above, an oracle F with two input
bits and one output bit is deﬁned. The oracle F is deﬁned
to be F |a0a1b(cid:105) = |a0a1(cid:105) |b ⊕ (a0 ∧ ¬a1)(cid:105).

B. Operational Semantics

In this subsection, as a theoretical basis, we formally
deﬁne the operational semantics of isQ language. To sim-
plify the analysis, we focus on an imperative quantum
programming model with the language being a subset
of the complete syntax of isQ. Since the language per-
mits recursion, let us introduce the notions of quantum
program schemes and declaration ﬁrst.

We assume a ﬁnite (or countably inﬁnite) set V of
classical variables, and a ﬁnite (or countably inﬁnite) set
QV of quantum variables. Quantum program schemes
are deﬁned in the following:

Deﬁnition II.1. Quantum program schemes are generated
by the syntax:

P ::= X | skip | (x1, ..., xn) := (t1, ..., tn) | P1; P2

| if ϕ then P1 else P2 ﬁ
| while ϕ do P od
| q := |0(cid:105) | q := U[q] | x := M[q]
where X is a procedure identiﬁer, x, x1, ..., xn ∈ V are classical
variables, t1, ..., tn are (classical) expressions, q ∈ QV is a
quantum variable, and q ⊆ QV is a quantum register, i.e. a
family of distinct quantum variables.

(1)

The

statement

(x1, ..., xn)

:=
skip, assignment
(t1, ..., tn), sequential composition P1; P2, conditional
if ϕ then P1 else P2 ﬁ and loop while ϕ do P od
are the same as in a classical programming language.
Initialisation q := |0(cid:105) sets quantum variable q to a
basis state |0(cid:105). Statement q := U[q] means that unitary
transformation U is performed on quantum register q,
leaving the states of the variables not in q unchanged. In
executing statement x := M[q], quantum measurement
M = {Mm} is performed on q, and an outcome is stored
into classical variable x.

Now we have some procedure identiﬁers in a program
scheme. Given these procedure identiﬁers, we can deﬁne
a declaration to specify their procedure bodies.

Deﬁnition II.2. Let X1, ..., Xn be different procedure identi-
ﬁers. A declaration for X1, ..., Xn is a system of equations:

D :






X1 ⇐ P1,
......
Xn ⇐ Pn,

(2)

where for every 1 ≤ i ≤ n, Pi ≡ Pi[X1, ..., Xn] is a quantum
program scheme.

With Deﬁnition II.1 and Deﬁnition II.2 together, we

give a formal deﬁnition for quantum programs.

Deﬁnition II.3. A quantum program (possibly with recur-
sion) consists of:

1) a quantum program scheme P ≡ P[X1, ..., Xn], called

the main statement; and
2) a declaration D for X1, ..., Xn.

For each quantum variable q ∈ QV, let Hq be its
Hilbert space. Then the tensor product H = (cid:78)
q∈QV Hq
is the state space of all quantum variables. A classical-
quantum state is a pair (cid:104)σ, ρ(cid:105), where σ is a state of
classical variables, and ρ is a density operator in H,
denoting a state of quantum variables. We use ↓ to
denote termination. A classical-quantum conﬁguration is
a triple (cid:104)P, σ, ρ(cid:105), where P is a program scheme or P = ↓,
and (cid:104)σ, ρ(cid:105) is a classical-quantum state. The operational
semantics describes the probabilistic transition between
conﬁgurations.

Deﬁnition II.4 (Operational Semantics). Let D be a given
declaration. The operational semantics of quantum programs
with respect to D is the probabilistic transition relation
p
→D between conﬁgurations deﬁned by the transition rules
presented in Figure 3, where probability p in transition
p
→D (cid:104)P(cid:48), σ(cid:48), ρ(cid:48)(cid:105) is dropped whenever p = 1.
(cid:104)P, σ, ρ(cid:105)

The denotational semantics of our quantum program-
ming model can be deﬁned based on the above oper-
ational semantics by generalizing the techniques devel-
oped in Section 3.4 of [15] where only purely quantum
programs without classical variables are considered. We
omit it here due to the limitation of space.

III.

ISQ COMPILER ARCHITECTURE

In this section, we describe the design of our com-
piler. The compiler is based on MLIR [9] infrastructure,
a highly-extensible compiler framework that supports
representation, transformation and code generation for
domain-speciﬁc computing, e.g. neural network, circuit
logic, etc. Speciﬁcally for our purpose:

• We deﬁned isQ-IR, an MLIR dialect supporting
certain quantum operations, as our intermediate
representation for representing and transforming
quantum programs. Our isQ frontend can generate
isQ-IR directly.

• Based on MLIR’s powerful general IR transforma-
tion framework, we utilized both existing general
transformation passes provided by MLIR, as well as
our own quantum-speciﬁc transformation passes, to
transform and optimize quantum programs.

• By utilizing MLIR’s code generation and lowering
infrastructure, we are able to generate different
types of output code, including both high-level rep-
resentations like QIR and OpenQASM 3.0 [11], and
low-level real-device instruction sets like QCIS.

A. Dialect deﬁnition of isQ-IR

The principles for deﬁning our isQ-IR dialect include:
• Allowing easy reuse of compilation infrastructures
provided by MLIR, including compilation infras-
tructures originally designed for transforming clas-
sical programs. We designed our dialect in inte-
gration with existing MLIR dialects (scf, afﬁne,

memref, etc.) and only added minimum number of
required operations enough for quantum programs,
while preserving necessary properties for quantum-
agnostic transformation passes to transform cor-
rectly.

• Facilitating gate-level optimizations. We adopted an
SSA form of representing qubit fragments, which
allows local quantum-circuit fragments to be ex-
posed as def-use chains by a memory dependency
analysis. MLIR’s powerful rewrite framework also
simpliﬁes the deﬁnition of gate identities and trans-
formations.

• Preserving high-level program structures. isQ-IR al-
lows high-level program information, e.g. decorated
gates, built-in gate optimization hints, gate deﬁni-
tion by matrices and oracles, to be represented. We
can both perform high-level optimizations (e.g. can-
celing out user-deﬁned UU†) and ﬁnally transform
them into lower-level gate primitives easily.

• Allowing extension for future features. Our dialect
itself is designed to be extensible so that we can add
more features easily, e.g. new compilation passes
and new ways of deﬁning gates.

1) New MLIR types:

for describing quantum programs:
!isq.gate(cid:104)N, hints(cid:105).

isQ-IR deﬁned two new types
!isq.qstate and

!isq.qstate represents an intermediate state of a sin-
gle qubit, which can be seen as an open wire in a
quantum circuit fragment. We do not deﬁne new types
for representing qubits or qubit arrays;
instead, we
model them using memref(cid:104)n × !isq.qstate(cid:105): qubit alloca-
tion/deallocation are represented by memref.alloc and
memref.free; for quantum operations, we need to use
memref.load operation (or afﬁne.load) to extract the
!isq.qstate value out, perform operations to obtain a new
value, and use memref.store to store it back.

Using quantum SSA representation poses additional

requirements for legality:

• Every !isq.qstate value must be stored in the exact
memory location where it was loaded from. This is
guaranteed by our input IR.

• Two !isq.qstate values that are both “alive” at a
certain point of a program must belong to two
different qubits. They can be seen as distinct “open
wires” in a quantum circuit, on which we can safely
perform multi-qubit gates or freely switch two gates
on disjoint qubits.

• Passes should not introduce !isq.qstate values that
are not ﬁnally stored back to its memref, or store an
invalid qstate back. This condition ensures that there
are no extra unused !isq.apply statements. To satisfy
this, our gate rewrite passes remove redundant SSA
values as well as store operations using them.

!isq.gate(cid:104)N, hints(cid:105) represents a pure quantum N-qubit
gate as an SSA value that can be decorated, applied

(SK)

(AS)

(UN)

(C1)

(RE)

(cid:104)skip, σ, ρ(cid:105) →D (cid:104)↓, σ, ρ(cid:105)

(SE)

(cid:104)P1, σ, ρ(cid:105)
(cid:104)P1; P2, σ, ρ(cid:105)

p
→D (cid:104)P(cid:48)
p
→D (cid:104)P(cid:48)

1, σ(cid:48), ρ(cid:48)(cid:105)
1; P2, σ(cid:48), ρ(cid:48)(cid:105)

(cid:104)(x1, ..., xn) := (t1, ..., tn), σ, ρ(cid:105) →D (cid:104)↓, σ[σ(t1)/x1, ..., σ(tn)/xn], ρ(cid:105)

(cid:104)q := U[q], σ, ρ(cid:105) →D (cid:104)↓, σ, U[q]ρU†[q](cid:105)

(ME)

(cid:104)x := M[q], σ, ρ(cid:105)

pm→D (cid:104)↓, σ[m/x], 1

pm

Mm[q]ρM†

m[q](cid:105)

σ |= ϕ
(cid:104)if ϕ then P1 else P2 ﬁ, σ, ρ(cid:105) →D (cid:104)P1, σ, ρ(cid:105)

(C2)

σ |= ¬ϕ
(cid:104)if ϕ then P1 else P2 ﬁ, σ, ρ(cid:105) →D (cid:104)P2, σ, ρ(cid:105)

(cid:104)Xi, σ, ρ(cid:105) →D (cid:104)Pi, σ, ρ(cid:105)

if Xi ⇐ Pi is in the declaration D.

Fig. 3. Operational Semantics of Quantum Programs.
which ﬁnally updates σ. In (ME), pm = tr(M†

In (AS), σ[σ(t1)/x1, ..., σ(tn)/xn] means assigning the value of ti under σ to xi, 1 ≤ i ≤ n,

m[q]Mm[q]ρ) for every m ∈ spec(M). In (SE), we use the convention that ↓; P2 = P2.

to qubits, and passed around. hints on the gate type
describes special properties about the gate. Currently
supported hints include:

• hermitian,
CNOT, H.

indicating the gate is Hermitian, e.g.

• diagonal, indicating the gate has a diagonal matrix

form, e.g. CZ, RZ.

• antidiagonal, indicating the single-qubit gate is anti-

diagonal, e.g. X.

• symmetric,

indicating the order of gate operands

does not matter, e.g. SWAP and CZ gates.

• phase,

indicating the gate is in the form Un =
∑0(cid:54)i<2n−1 |i(cid:105) (cid:104)i| + eiθ |111 · · · 1(cid:105) (cid:104)111 · · · 1|. All phase
gates are naturally diagonal and symmetric.

2) New operations: Table II lists isQ-IR-deﬁned MLIR

operations.

Instead of deﬁning a builtin basic gate set, all gates are
deﬁned by isq.defgate. Both non-parametric gate and
parametric gate families can be deﬁned. The operation
is attached with an attribute “deﬁnition”, allowing spec-
ifying multiple ways of deﬁning the operation:

• “qir”, deﬁnition by a QIR function.
• “unitary”, specifying a unitary matrix deﬁnition.
• “oracle”, specifying an oracle truth-table deﬁnition.
• “decomposition”, specifying a gate decomposition

by a builtin.func.

A builtin.func can be used to describe a decomposi-

tion of a gate only if:

• The function accepts gate parameters and n qstates

as arguments exactly.

• The function returns an n-qstate tuple exactly.
• Returned qstates correspond to argument qstates in

exact order.

• For auto-generation of adjoint version, the function
should only consist of one basic block and contains
no operations with sub-regions.

These requirements above allow us to automatically

generate a controlled (and adjoint) version of a gate.

A deﬁned gate can be referenced using isq.use oper-
ation. If the gate has classical parameters, they need to
be speciﬁed as operands of isq.use. A gate can then be
applied to qstates using isq.apply operation, returning
new SSA qstate values that can be applied on by the next
gates or stored back.

isq.decorate is added to represent decorated (con-
trolled and adjoint) operations. An isq.decorate opera-
tion is attached with two attributes, ctrl and adjoint. The
ctrl attribute is a list of boolean values, where “false”
indicates corresponding controller bit is negated. The
operand of isq.decorate is an !isq.gate, and the result
is also an !isq.gate with correct size and hints:

• Adding controller bits increases the gate size.
• Adjoint version of Hermitian gate is equivalent to

non-adjoint version.

• Adjoint version of diagonal is still diagonal. The

same is true for antidiagonal and symmetric.

• Controlled diagonal gates are still diagonal gates.
The same is true for positively-controlled phase
gates.

isq.declare_qop represents external quantum opera-
tions other than pure gates (e.g. measurements) that
can be called by isq.call_qop that operates on zero or
more qubits, zero or more classical input, interacts with
external environment, and return zero or more classical
output.

We use signature [n](input) → output to represent a
quantum operation that works on n qstates and classical
values input, yielding n qstates and classical values
output. For example, (computational basis) measurement
is an operation that operates on one qubit and yields an
i1 value, and thus has signature [1]() → i1. This is equiv-
alent to traditional function signature (!isq.qstate) →

Operation
isq.defgate

isq.use

isq.apply

isq.decorate

Usage
Global deﬁnition of a gate that can be
used.
Use a globally deﬁned gate as a value.

Apply a gate value onto qubit states.

Extend control qubits onto a gate or in-
verting a gate.

isq.downgrade

Auxiliary operation for removing hints.

isq.declare_qop
isq.call_qop

Deﬁne an external quantum operation.
Calls an external quantum operation.

isq.apply_gphase
isq.accumulate_gphase Auxiliary operation for “moving” global

Applying global phase.

phase out of local system.

Example
isq .defgate @X {deﬁnition = #X_DEF} : !
isq.gate<1, hermitian>
%X = isq.use @X : !isq.gate<1, hermitian
>
%b = isq.apply %X(%a) : !isq.gate<1,
hermitian>
%CNOT = isq.decorate (%X: !isq.gate<1,
hermitian>) {ctrl = [true], adjoint = true}
:
%H2 = isq.downgrade (%H: !isq.gate<1,
hermitian>) : !isq.gate<1>
isq .declare_qop @measure : [1]()−>i1
%b, %outcome = isq.call_qop @measure
(%a): [1]()−>i1
isq .apply_gphase %g : !isq.gate<0>
isq .accumulate_gphase %q : memref<1x!
isq.qstate>

! isq .gate<2>

TABLE II
New MLIR operations deﬁned by isQ-IR.

(!isq.qstate, i1). The signature for qubit reset is [1]() → (),
and for print-int [0](index) → ().

Auxiliary operations: isq.downgrade is deﬁned to re-
move hints from gate type signature, so that the gate
ﬁts into other operations requiring a different yet com-
patible type of gate as arguments. isq.apply_gphase and
isq.accumulate_gphase are deﬁned as side-effective for
applying global phase. While global phases themselves
have no effect, generating controlled versions of user-
deﬁned gates requires a global phase to be exact.

Example III.1. Consider the following function deﬁnition.
The gates on ancilla qubits %Q introduces global phase (−1)
to the system and can be optimized out. However, if we try
to generate a controlled version of this function, eliminating
them early will result in error in relative phase.

func @error_1(%q: !isq.qstate)->!isq.qstate {

%Q = memref.alloc() : memref<1x!isq.qstate>
%q = affine.load %Q[%0]: memref<1x!isq.qstate>
%X = isq.use @X : !isq.gate<1>
%Z = isq.use @Z : !isq.gate<1>
%q2 = isq.apply %X(%q) : !isq.gate<1>
%q3 = isq.apply %Z(%q2) : !isq.gate<1>
%q4 = isq.apply %X(%q3) : !isq.gate<1>
affine.store %q4, %Q[0]: memref<1x!isq.qstate>
memref.dealloc(%Q) : memref<1x!isq.qstate>
return %q: !isq.qstate

}

isq.apply_gphase accepts an !isq.gate(cid:104)0(cid:105), indicating
applying the speciﬁed global phase to the system;
when “controlled” they will be converted to isq.apply
operations. isq.accumulate_gphase operates on mem-
ref(cid:104)? × !isq.qstate(cid:105) so that the corresponding local qubits

are considered “alive” and will not be optimized out.

Global phase operations can be simply removed after
generating all controlled versions of gates. In the exam-
ple above, in the function for the original gate, we can
safely remove %Q and corresponding gates, while in the
function for the controlled-gate %Q will be preserved.

3) Reused transformation passes: Our deﬁnition of isQ-
IR allows for multiple transformation passes provided
by MLIR to be reused without modiﬁcation.

• Canonicalization, CSE, Symbol-DCE: these are use-
ful SSA transformations that could be used to sim-
plify code and remove unnecessary computation.
• Memref subview folding: recognized as “fold-
memref-subview-ops” in MLIR. This pass removes
probable redundant memref.subview ops generated
by our front-end, thus removing unnecessary po-
tential memory aliasing and simplifying store-load
forwarding.

• Store-load forwarding:

recognized as “afﬁne-
scalrep” in MLIR. This pass can be used to forward
afﬁne.store-d SSA values to following afﬁne.load,
thus exposing the use-def chain that we need for
gate cancellation.

• Loop unrolling: recognized as “afﬁne-loop-unroll”
in MLIR. This pass unrolls loops in the program,
and is useful for cancelling more gates when target-
ing real devices.

• MLIR builtin lowering passes: these are useful
passes for lowering other MLIR dialects to QIR.
4) New transformation passes: Leveraging MLIR’s
rewrite framework, we implemented a handful of trans-
formations that decomposes and transforms the quan-
tum part of the program.

Canonicalization: several useful local peephole op-
timization patterns are added to MLIR’s canonicalizer,
which is executed after every transformation pass.

• Decorate-op folding: a rewriter pattern that folds
two consecutive isq.decorate operations into one.
• Gate cancellation: rewrite pattern that cancels out

pairs of Hermitian gates and UU† gate pairs.

• Symmetric operand rearranging: when all inputs
of a symmetric gate are from outputs of one gate,
reorder the operands to match the output order of
previous gate. This is useful for cancelling two CZ
gates in “reverse” directions.

Recognize famous gates: this pass inserts deﬁnition
of isQ builtin gates, including Paulis, Pauli rotations, U3,
CNOT and Toffoli.

Pauli-rotation to U3: this pass converts all parametric

Pauli rotations into parametric U3 gates.

Fold decorate gates: this pass folds all isq.decorate

operations:

• Negated controller bits are eliminated by inserting

X gates.

• For matrix-deﬁned gates, a new matrix deﬁnition of

the decorated gate is generated.

• For decomposition-deﬁned gates, the builtin.func
is cloned and modiﬁed by adding controller bits
and/or inverting the gate sequence.

After this pass, global phase auxiliary operations can be
removed.

Decompose controlled U3: this pass decomposes con-
trolled, parametric U3 gate using AXBXC rule [16],
resulting in controlled-X, controlled-GPhase (controlled
phase shift), RZ and RY operations. Controlled-X and
controlled-GPhase are decomposed recursively accord-
ing to [16]. This pass eliminates all controlled parametric
gates.

Decompose known matrices: this pass decomposes
unitary-matrix-deﬁned gates into a bunch of basic gates
using quantum Shannon decomposition [17]. Till now all
gates are basic gates.

Remove trivial gates: this pass removes constant gates

that are very close to the identity.

5) Lower to QIR: After these passes, we deﬁned low-

ering passes to convert isQ-IR to QIR.

Expand decomposition: replace all gates deﬁned by
decomposition with builtin.call to decomposition func-
tion or QIR stub.

Reg2mem: ﬁnally we convert !isq.qstate to auxiliary
type !isq.qir.qubit and gate applications to QIR calls.
Measurements, resets and print operations, represented
by isq.call_qop, are converted to corresponding QIR
functions.

Lower to LLVM: lower auxiliary type !isq.qir.qubit to
llvm.struct(cid:104)“Qubit”, opaque(cid:105), the corresponding type
in QIR. Applying lowering rules of other dialects (afﬁne,
scf, etc.) results in legal QIR.

6) Codegen to QCIS: Our isQ compiler supports gener-
ating QCIS assembly that can execute on superconduct-
ing hardware. Challenges for targeting QCIS supercon-
ducting hardware include:

• QCIS hardware uses a different instruction set: for
single-qubit parametric gate QCIS supports RZ; for
two-qubit gate, QCIS provides CZ instead of CNOT.
Retargeting gates in the program is required.

• QCIS hardware does not support classical control
ﬂow or feedback control. The “quantum” part of our
program needs to be extracted and ﬂattened.

• Superconducting hardware has qubit connectivity
constraints. Qubit mapping is required to map log-
ical qubits in isQ program onto real qubits.

To solve these problems, we proposed new passes to
convert isQ program into valid QCIS assembly that can
execute on real devices.

• We ﬁrst check input isQ-IR to make sure there are
no reset statements or uses of measurement results.
This prevents feedback control in our program.
• We retarget gates in the program into QCIS instruc-
tion set, by converting CNOT into H-CZ-H triples
and U3 into RZ, X2P, X2M[12, 18].

• We can extract all quantum gates by executing the
program on our simulator and collecting every gate
call. This effectively ﬂattens high-level control ﬂow
structures in the program (loops and conditional
branches) into a gate list.

• We perform qubit mapping on the collected gate list
by our qubit mapper based on [19], generating QCIS
assembly executable on superconducting hardware.
7) Codegen to OpenQASM 3.0: We implemented direct
code generator from isQ-IR to logical-level OpenQASM
3.0, a high-level quantum assembly language with con-
trol ﬂow support. Since the control ﬂow primitives
in OpenQASM3 are high-level ones (e.g. if-statement,
while-statements) instead of low-level ones (e.g. goto
statements, basic blocks), we map structured MLIR
control-ﬂow operations directly to OpenQASM3, e.g.
scf.if onto if-statements, afﬁne.for onto for-statements,
etc.

IV. EXAMPLES

In this section, we present several illustrative imple-
mentations of some interesting quantum algorithms that
can clearly manifest the main features of isQ.

A. A pure quantum program

We use a simple example, Fourier sampling, also
called Bernstein-Vazirani algorithm, to show the main
workﬂow of isQ software stack, from isQ language to
hardware-supported QCIS assembly. It is a pure quan-
tum program without classical variables.

Example IV.1 (Bernstein-Vazirani algorithm). We ﬁrst
give the implementation of a small-scale Bernstein-Vazirani
algorithm on 5 qubits, with secret string "1101".

q[0]

q[1]

q[2]

q[3]

H •

H

H

H

•

H

H

H

• H

q[4] X H X X X H

Fig. 4. 5-qubit Bernstein-Vazirani circuit.

procedure main(){
qbit q[5];
X(q[4]);
for i in 0:5{

H(q[i]);

}
CNOT(q[0], q[4]);
CNOT(q[1], q[4]);
CNOT(q[3], q[4]);
for i in 0:5{

H(q[i]);

}
for i in 0:5{

M(q[i]);

}

}

This isQ program represents a 5-qubit circuit in Fig-
ure 4. After canonicalization and constant folding, the
program above can be compiled to the following isQ-IR:

func @__isq__main() {

%0 = memref.alloc() : memref<5x!isq.qstate>
%X = isq.use @X : !isq.gate<1>
%2 = affine.load %0[4] : memref<5x!isq.qstate>
%3 = isq.apply %X(%2) : !isq.gate<1>
affine.store %3, %0[4] : memref<5x!isq.qstate>
affine.for %arg0 = 0 to 5 {

%H = isq.use @H : !isq.gate<1>
%15 = affine.load %0[%arg0] : memref<5x!isq.

qstate>

%16 = isq.apply %H(%15) : !isq.gate<1>
affine.store %16, %0[%arg0] : memref<5x!isq.

qstate>

}
/* omitted */
memref.dealloc %0 : memref<5x!isq.qstate>
return

}

First we perform loop unrolling to obtain unrolled

loop kernel, and obtain the snippet:

%2 = affine.load %0[4] : memref<5x!isq.qstate>
%3 = isq.apply %X(%2) : !isq.gate<1> // X(q[4])
affine.store %3, %0[4] : memref<5x!isq.qstate>
%5 = affine.load %0[0] : memref<5x!isq.qstate>
%6 = isq.apply %H(%5) : !isq.gate<1> // H(q[0])
affine.store %6, %0[0] : memref<5x!isq.qstate>
/* omitted */
%13 = affine.load %0[4] : memref<5x!isq.qstate>

%14 = isq.apply %H(%13) : !isq.gate<1> // H(q[4])
affine.store %14, %0[4] : memref<5x!isq.qstate>

Applying load-store forwarding is able to recover the

dataﬂow on q[4] and other qubits:

%2 = affine.load %0[%c4] : memref<5x!isq.qstate>
%3 = isq.apply %X(%2) : !isq.gate<1> // X(q[4])
%13 = isq.apply %B(%3) : !isq.gate<1> // H(q[4])

Now qubit data dependency is exposed by use-def
chain upon which our quantum passes can take ef-
fects: a conversion pass converts CNOT into CZ and H
supported by QCIS, while the canonicalizer eliminates
consecutive H gate pairs. After all conversions, isQ-IR is
lowered to auxiliary QIR form:

%0 = memref.alloc() : memref<5x!isq.qir.qubit>
scf.for %arg0 = 0 to 5 step 1 {

%5 = call @__quantum__rt__qubit_allocate() : ()

-> !isq.qir.qubit

memref.store %5, %0[%arg0] : memref<5x!isq.qir.

qubit>

}
%1 = memref.load %0[4] : memref<5x!isq.qir.qubit>
call @__quantum__qis__x__body(%1) : (!isq.qir.qubit

) -> ()

%2 = memref.load %0[0] : memref<5x!isq.qir.qubit>
call @__quantum__qis__h__body(%2) : (!isq.qir.qubit

) -> ()

The snippet will be further lowered to QIR, com-
piled by LLVM, and linked with our
simulator.
We implemented a special backend in the sim-
ulator
to code-generation calls, e.g.
__quantum__qis__x__body(i) generating a “X Qi” QCIS
instructions. These instructions will be collected and
mapped to real hardware using our qubit mapping pass:

that converts

q[1] H

• H

q[4] X • •

• H • H •

q[0] H • H H • H • H • H •

q[3] H

• H

q[1]

q[0]

q[4]

q[3]

B. Recursion and oracles

Next we give an example including both recursion and

oracle deﬁnitions.

Example IV.2 (Recursive Fourier Sampling). Recursive
Fourier sampling (RFS) [14, 20] is the recursive version of
Fourier sampling. The height-h RFS problem is deﬁned to be
a h-depth tree with each subtree of the root corresponding
to a height-(h − 1) RFS. The RFS problem could be solved
recursively. Below is an instance for RFS of height-2.

oracle A(4,1) = [0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1];
oracle g(2,1) = [1,0,1,0];

int a;
qbit q[4], p[3];

procedure recursive_fourier_sampling(int k){

if (k == 2){

A(q[0], q[1], q[2], q[3], p[2]);

}else{

H(q[2*k]);
H(q[2*k+1]);
X(p[k+1]);
H(p[k+1]);

recursive_fourier_sampling(k+1);

H(q[2*k]);
H(q[2*k+1]);
g(q[2*k],q[2*k+1], p[k]);
H(q[2*k]);
H(q[2*k+1]);

recursive_fourier_sampling(k+1);

H(q[2*k]);
H(q[2*k+1]);
H(p[k+1]);
X(p[k+1]);

}

}

procedure main(){

a = 0;
recursive_fourier_sampling(a);
int g = M(p[0]);
print g;

}

The secret string s for this instance is "11", thus the
expected print output should be g(s) = 0, which could be
validated in our simulator.

C. A quantum-classical hybrid program

We further give another complicated example, itera-
tive phase estimation, a quantum-classical hybrid algo-
rithm that requires real-time feedback control.

Example IV.3 (Iterative phase estimation). Iterative phase
estimation (IPE) [21] is a kind of phase estimation algorithm
requiring only one ancilla qubit[11, 22]. IPE requires real-
time intermediate measurement and feedback control: for every
iteration, the ancilla qubit is operated on, measured and reset;
the parameter of RZ gate in each iteration is determined by
previous measurement outcomes; all gates and measurements
must be ﬁnished within decoherence time. Below is our isQ
program for a two-qubit, 20-bit precision IPE instance:

/* the phase angle is

2*pi*867893/(2**20) = 2*pi*0.8276872 */

int x=867893;
double theta(){

double y = 2**20;
return 2*pi*x / y;

}
procedure U(double theta, qbit q){

nctrl GPhase(theta, q);

} deriving gate

procedure pow2_ctrlU(int n, qbit anc, qbit ev){

double t = theta() * (2**n);
ctrl U(t, anc, ev);

}
double ipe_U(int n, qbit ev){

qbit anc;
double phi = 0;
for i in 0:n{

H(anc);
pow2_ctrlU(n - i - 1, anc, ev);
Rz(- phi * 2 * pi, anc);
H(anc);
int res = M(anc);
phi = (phi + (res / 2.0)) / 2.0;
anc = |0>;

}
return (phi * 2.0);

}
procedure main(){
qbit ev;
ev = |0>; // eigen vector of U
double phi = ipe_U(20, ev);
print (phi * (2**20)); // should be x=867893.

}

We created two examples, IPE the example above, and
IPE-9, an IPE instance but U is a 9-qubit gate. We write
two examples in both isQ and Q#, compile and simulate
them to compare the compilation and simulation perfor-
mance. All experiments are carried out on a same PC
with an Intel i9-11900K CPU.

Time/s
Q# compile
Q# simulate
isQ compile
isQ simulate

IPE
4.31 ± 0.14
1.25 ± 0.01
0.40 ± 0.02
0.003 ± 0.000
TABLE III
Evaluation results between isQ and Q#.

IPE-9
5.24 ± 0.09
1.41 ± 0.05
1.70 ± 0.06
2.11 ± 0.02

Table III shows that our toolchain has much smaller
overhead for both compilation and execution for IPE.
While Q# toolchain compiles the controlled-U in IPE-9
into mutil-qubit controlled gates and run such controlled
gates directly on the simulator, we are able to compile
the program into ﬁner-grain CNOT and U3 gates and
simulate them with a low overhead while preserving
overall performance.

V. RELATED WORK

A. Quantum programming languages and compilers

There have already been a series of work in quan-
tum programming languages and compilers [18, 23–28]
targeting at different levels of abstraction. For example,
Qiskit [18] proposed by IBM is a popular Pythonic circuit
construction framework for OpenQASM 2 [29], which
can run on IBM’s hardware backends but has only lim-
ited support for classical control ﬂow. Languages like Q#
[25] and Silq [26] support powerful language features;
however, Q# can only run on limited hardware with
limited features, while Silq can only run on its simulator.

ﬁnally compiled to and tested out on different backends,
both simulated environment and real superconducting
hardware, and also allow cooperation with lower-level
compilation toolchains.

A. Future Work

Potential future works include further extending the
isQ programming stack and adding more optimization
passes, resource analysis and adding assertion functions,
etc. Targeting isQ to more different kinds of quantum
hardware, e.g. trapped-ion quantum devices, is also one
of the future tasks.

A closely related previous work is QCOR [28], also
aiming at building a practical and versatile quantum
programming software stack. QCOR modiﬁed Clang so
that quantum kernels could be interleaved with C++
source code, allowing existing C++ libraries to be im-
ported out of convenience for quantum programmers,
e.g. the gradient descent methods in variational quantum
algorithms. Instead of depending on a host language,
our work proposes to use one uniﬁed language for both
classical and quantum parts of a hybrid program. Both
QCOR and isQ are able to target multiple backends.

B. Quantum Intermediate Representations

Many quantum compilers employed their own IR for
the transformation and optimization of quantum pro-
grams. For example, XACC [30] deﬁnes a general IR for
representing quantum programs compiled from various
languages executing on various backends. ScaffCC [31]
extended LLVM IR to represent quantum operations
to leverage LLVM framework for analyzing quantum
programs, as well as relying on LLVM enable fast
code generation (instrumentation-driven approach). QIR
[10], one compilation target of our toolchain, is another
LLVM-based IR that introduces quantum functionality
by using LLVM’s opaque struct mechanism. Quantum
MLIR dialect [32] is proposed to ﬁll the gap between
quantum languages and QIR.

There have also been several works on using SSA
for representing quantum programs. QIRO [33] is pro-
posed as an MLIR dialect that allows exposure of quan-
tum dataﬂow as use-def chains, thus allowing quantum
dataﬂow analysis and optimizations. QSSA [34] further
proposed a single-use analysis to statically check if
no-cloning theorem is obeyed in the program. Com-
pared with them, isQ-IR is designed with extensibility
in mind: no built-in gates are deﬁned in the dialect,
allowing transformations based on “general properties”
(gate hints) to be widely used. isQ-IR also seeks tighter
integration with existing MLIR infrastructure, for ex-
ample, by leveraging existing “memref” and “afﬁne”
dialects and corresponding built-in analysis passes for
dependency analysis (instead of re-implementing array
operations).

VI. CONCLUSION

This paper describes a software stack for quantum
programming, including a high-level quantum program-
ming language and tools to compile and simulate the
language. The isQ programming language provides a
series of high-level language features to facilitate writ-
ing quantum programs. By leveraging MLIR infrastruc-
ture, we deﬁned isQ-IR, an MLIR dialect for represent-
ing quantum-classical hybrid programs, and built isQ
compiler, allowing some powerful transformations and
optimizations of isQ programs. Finally, backend code-
generators and simulators allow isQ programs to be

REFERENCES

sity Press, 2000.

[1] F. Arute, K. Arya, R. Babbush, D. Bacon, J. C. Bardin,
R. Barends, R. Biswas, S. Boixo, F. G. Brandao,
D. A. Buell et al., “Quantum supremacy using a
programmable superconducting processor,” Nature,
vol. 574, no. 7779, pp. 505–510, 2019.

[2] H.-S. Zhong, H. Wang, Y.-H. Deng, M.-C. Chen, L.-
C. Peng, Y.-H. Luo, J. Qin, D. Wu, X. Ding, Y. Hu
et al., “Quantum computational advantage using
photons,” Science, vol. 370, no. 6523, pp. 1460–1463,
2020.

[3] Q. Zhu, S. Cao, F. Chen, M.-C. Chen, X. Chen, T.-
H. Chung, H. Deng, Y. Du, D. Fan, M. Gong et al.,
“Quantum computational advantage via 60-qubit
24-cycle random circuit sampling,” Science Bulletin,
vol. 67, no. 3, pp. 240–245, 2022.

[4] “February 23, 2022 | IonQ Aria Furthers Lead As
World’s Most Powerful Quantum Com.” [Online].
Available: https://ionq.com/news/february-23-20
22-ionq-aria-furthers-lead

[5] the isQ team, “The isq software website.” [Online].

Available: http://124.16.138.151/i

[6] D. M. Beazley, “Python Lex-Yacc.” [Online].

Available: http://www.dabeaz.com/ply/ply.html

[7] R. S. Smith, M. J. Curtis, and W. J. Zeng, “A practical
quantum instruction set architecture,” arXiv preprint
arXiv:1608.03355, 2016.

[8] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman,
Pearson

Compilers: principles, techniques, & tools.
Education India, 2007.

[9] C. Lattner, M. Amini, U. Bondhugula, A. Cohen,
A. Davis,
J. Pienaar, R. Riddle, T. Shpeisman,
N. Vasilache, and O. Zinenko, “MLIR: A compiler
infrastructure for the end of Moore’s law,” arXiv
preprint arXiv:2002.11054, 2020.

[10] Q. Alliance, “Qir speciﬁcation,” https://github.com

/qir-alliance/qir-spec, 2022.

[11] A. W. Cross, A.

Javadi-Abhari, T. Alexander,
N. de Beaudrap, L. S. Bishop, S. Heidel, C. A. Ryan,
J. Smolin, J. M. Gambetta, and B. R. Johnson, “Open-
qasm 3: A broader and deeper quantum assembly
language,” arXiv preprint arXiv:2104.14722, 2021.

[12] “QCIS instruction set

introduction.” [Online].
Available: https://quantumcomputer.ac.cn/Us
erBook.html

[13] L. K. Grover, “Fixed-point quantum search,” Physi-

cal Review Letters, vol. 95, no. 15, p. 150501, 2005.

[14] E. Bernstein and U. V. Vazirani, “Quantum
complexity theory,” SIAM J. Comput., vol. 26,
no. 5, pp. 1411–1473, 1997.
[Online]. Available:
https://doi.org/10.1137/S0097539796300921
[15] M. Ying, Foundations of quantum programming. Mor-

gan Kaufmann, 2016.

[16] M. A. Nielsen and I. L. Chuang, Quantum Computa-
tion and Quantum Information. Cambridge Univer-

[17] V. V. Shende, S. S. Bullock, and I. L. Markov, “Syn-
thesis of quantum logic circuits,” IEEE Transactions
on Computer-Aided Design of Integrated Circuits and
Systems, vol. 25, no. 6, pp. 1000–1010, 2006.

[18] “Qiskit: An open-source sdk for working with
quantum computers at the level of pulses, circuits,
and algorithms.” [Online]. Available: https://gith
ub.com/Qiskit

[19] X. Zhou, S. Li, and Y. Feng, “Quantum circuit
transformation based on simulated annealing and
heuristic search,” IEEE Transactions on Computer-
Aided Design of
Integrated Circuits and Systems,
vol. 39, no. 12, pp. 4683–4694, 2020.

[20] S. Aaronson, “Quantum lower bound for recursive
fourier sampling,” Quantum Information & Computa-
tion, vol. 3, no. 2, 2002.

[21] M. Dobšíˇcek, G.

Johansson, V. Shumeiko, and
G. Wendin, “Arbitrary accuracy iterative quantum
phase estimation algorithm using a single ancillary
qubit: A two-qubit benchmark,” Physical Review A,
vol. 76, no. 3, pp. 399–406, 2007.

[22] A. D. Córcoles, M. Takita, K. Inoue, S. Lekuch, Z. K.
Minev, J. M. Chow, and J. M. Gambetta, “Exploiting
dynamic quantum circuits in a quantum algorithm
with superconducting qubits,” Phys. Rev. Lett., vol.
127, p. 100501, Aug 2021.
[Online]. Available:
https://link.aps.org/doi/10.1103/PhysRevLett.127
.100501

[23] A. J. Abhari, A. Faruque, M. J. Dousti, L. Svec,
O. Catu, A. Chakrabati, C.-F. Chiang, S. Vander-
wilt, J. Black, and F. Chong, “Scaffold: Quantum
programming language,” Princeton Univ NJ Dept
of Computer Science, Tech. Rep., 2012.

[24] A. S. Green, P. L. Lumsdaine, N. J. Ross, P. Selinger,
and B. Valiron, “Quipper: a scalable quantum pro-
gramming language,” in Proceedings of the 34th ACM
SIGPLAN conference on Programming language design
and implementation, 2013, pp. 333–342.
[25] K. Svore, A. Geller, M. Troyer,

J. Azariah,
Kliuchnikov,
C.
M. Mykhailova, A. Paz,
and M. Roetteler,
“Q#: enabling scalable quantum computing and
development with a high-level dsl,” in Proceedings
of the real world domain speciﬁc languages workshop
2018, 2018, pp. 1–10.

B. Heim,

Granade,

V.

[26] B. Bichsel, M. Baader, T. Gehr, and M. Vechev, “Silq:
A high-level quantum language with safe uncom-
putation and intuitive semantics,” in Proceedings of
the 41st ACM SIGPLAN Conference on Programming
Language Design and Implementation, 2020, pp. 286–
300.

[27] X. Fu, J. Yu, X. Su, H. Jiang, H. Wu, F. Cheng,
X. Deng, J. Zhang, L. Jin, Y. Yang et al., “Quingo:
a programming framework for heterogeneous
quantum-classical computing with nisq features,”

ACM Transactions on Quantum Computing, vol. 2,
no. 4, pp. 1–37, 2021.

[28] A. Mccaskey, T. Nguyen, A. Santana, D. Claudino,
T. Kharazi, and H. Finkel, “Extending c++ for het-
erogeneous quantum-classical computing,” ACM
Transactions on Quantum Computing, vol. 2, no. 2, pp.
1–36, 2021.

[29] A. W. Cross, L. S. Bishop, J. A. Smolin, and J. M.
Gambetta, “Open quantum assembly language,”
arXiv preprint arXiv:1707.03429, 2017.

[30] A. J. McCaskey, D. I. Lyakh, E. F. Dumitrescu, S. S.
Powers, and T. S. Humble, “XACC: A system-level
software infrastructure for heterogeneous quantum-
classical computing,” CoRR, vol. abs/1911.02452,
2019. [Online]. Available: http://arxiv.org/abs/19
11.02452

[31] A. JavadiAbhari, S. Patil, D. Kudrow, J. Heckey,
A. Lvov, F. T. Chong, and M. Martonosi, “Scaffcc:
Scalable compilation and analysis of quantum
programs,” Parallel Comput., vol. 45, pp. 2–17, 2015.
[Online]. Available: https://doi.org/10.1016/j.parc
o.2014.12.001

[32] A. McCaskey and T. Nguyen, “A MLIR dialect for
quantum assembly languages,” in IEEE International
Conference on Quantum Computing and Engineering,
QCE 2021, Broomﬁeld, CO, USA, October 17-22, 2021,
H. A. Müller, G. Byrd, C. Culhane, and T. Humble,
IEEE, 2021, pp. 255–264. [Online]. Available:
Eds.
https://doi.org/10.1109/QCE52317.2021.00043
[33] D. Ittah, T. Häner, V. Kliuchnikov, and T. Hoeﬂer,
“Enabling dataﬂow optimization for quantum pro-
grams,” CoRR, vol. abs/2101.11030, 2021. [Online].
Available: https://arxiv.org/abs/2101.11030

[34] A. Peduri, S. Bhat, and T. Grosser, “QSSA: an
ssa-based IR for quantum computing,” in CC
’22: 31st ACM SIGPLAN International Conference
on Compiler Construction, Seoul, South Korea, April
2 - 3, 2022, B. Egger and A. Smith, Eds.
ACM, 2022, pp. 2–14. [Online]. Available: https:
//doi.org/10.1145/3497776.3517772

