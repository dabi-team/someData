2
2
0
2

r
a

M
4
1

]
E
S
.
s
c
[

1
v
7
6
2
7
0
.
3
0
2
2
:
v
i
X
r
a

Development Frameworks for Microservice-based Applications:
Evaluation and Comparison

Hai Dinh-Tuan
hai.dinhtuan@tu-berlin.de
Technische Universität Berlin
Berlin, Germany

Felix Beierle
beierle@tu-berlin.de
Technische Universität Berlin
Berlin, Germany

Maria Mora-Martinez
m.moramartinez@tu-berlin.de
Technische Universität Berlin
Berlin, Germany

Sandro Rodriguez Garzon
sandro.rodriguezgarzon@tu-berlin.de
Technische Universität Berlin
Berlin, Germany

ABSTRACT
The microservice architectural style has gained much attention
from both academia and industry recently as a novel way to de-
sign, develop, and deploy cloud-native applications.This concept
encourages the decomposition of a monolith into multiple indepen-
dently deployable units. A typical microservices-based application
is formed of two service types: functional services, which provide
the core business logic, and infrastructure services, which provide
essential functionalities for a microservices ecosystem. To improve
developers’ productivity, many software frameworks have been de-
veloped to provide those reusable infrastructure services, allowing
programmers to focus on implementing microservices in arbitrary
ways. In this work, we made use of four open source frameworks to
develop a cloud-based application in order to compare and evaluate
their usability and practicability. While all selected frameworks
promote asynchronous microservice design in general, there are
differences in the ways each implements services. This leads to
interoperability issues, such as message topic naming convention.
Additionally, a key finding is the long startup times of JVM-based
services that might reduce application’s resiliency and portabil-
ity. Some other advantages come directly from the programming
language, such as the ability of Go to generate native binary exe-
cutables, which results in very small and compact Docker images
(up to 78% smaller compared to other languages).

CCS CONCEPTS
• Software and its engineering → Software design tradeoffs;
Software design engineering; Development frameworks and
environments.

KEYWORDS
microservices, software engineering, framework-based software
development

1 INTRODUCTION
The microservice architectural style emerged from the Service-
oriented architecture and the Domain-Driven Design architectural
patterns with a strong focus on DevOps practices [1]. Not only
has it been successfully adopted in multimillion-user companies
such as Netflix or Amazon, but also received significant attention
from the academia as a robust and scalable method to build cloud

applications. In short, the microservice architecture advocates a
new software design, in which the application is structured into
services. Theses services are independently developed, updated,
and deployed, thus significantly improving the flexibility of the
application. Similarly, the overall scalability and fault tolerance of
the application are enhanced. However, these advantages also come
at a cost. Applications get more complex and latency increases
because the communication channel is more susceptible to network
delays.

To reduce the burdens created by distributed systems’ complexi-
ties, several frameworks have been developed specifically for mi-
croservices. They provide boilerplate code and abstractions to allow
the developers to focus on the business logic. By exploring imple-
mentation options for an example application, this paper proposes
three criteria for evaluating and comparing frameworks. For fea-
tures, we compare frameworks across three main categories, which
are maturity, development supports, and built-in features. For de-
sign patterns, we categorized supported ones into six groups. Lastly,
for performance, we relied on two main criteria, which are end-to-
end latency performance and resource consumption. This paper
therefore delivers a three-fold contribution:

(1) A review of different approaches to implement microservices,
which is exhibited in four microservice frameworks selected.
(2) A comparison model for microservices frameworks, based
on three main criteria: features, design patterns, and perfor-
mance.

(3) The implications of adopting a framework in developing

microservices.

In the remainder of this paper, Section 2 gives a brief account
of the evaluations and comparisons have been done so far for mi-
croservices. Then, we introduce the motivating use case and the
architecture for a toll system’s prototype in Section 3. Section 5
presents a feature-wise comparison while Section 6 shows practical
performance results. We discuss the results in Section 7, draw the
overall conclusion in Section 8, and list future research directions
in Section 9.

2 RELATED WORK
One of the most well known definitions of software framework
proposed by Johnson describes it as "a reusable design of all or part
of a system that is represented by a set of abstract classes and the

 
 
 
 
 
 
way their instances interact" or "the skeleton of an application that
can be customized by an application developer" [2]. With a software
framework, developers are able to reuse both design and code to
focus on solving business specific needs [3]. Therefore, framework-
based software development can be seen as an activity to modify and
extend the framework [4]. In addition, a framework can improve
programmer productivity and enhance the quality, performance,
reliability and interoperability of software [5, 6, 3]. However, a
software framework can also lead to prolonged development time,
as developers have to learn and get familiar with the framework
[7]. Also, adopting a framework might result in more complicated
code structure and larger software footprints.

As frameworks are usually designed to solve a narrow set of prob-
lems by targeting a certain type of applications [8], there are more
and more frameworks specialized to ease, speed up and improve
development of applications with a microservice-based architec-
tural design. There have been several works study the performance
of microservices. [9, 10]. Others propose criteria to evaluate mi-
croservices such as [11, 12]. However, to the best of our knowledge,
there is no research article that compares the performance and
approaches by using different programming languages and frame-
works to build the same application. This paper addresses this exact
gap to compare and evaluate different framework-based develop-
ment approaches for microservices.

3 MOTIVATING USE CASE
One of the biggest issues in urban areas is the decline of air quality,
which causes 4.2 million premature deaths every year, according
to a recent report by the World Health Organization (WHO) [13].
In the same report, human mobility activities has been identified
as the major sources of outdoor air pollution, including fossil fuels
combustion from motor vehicles.

In many countries, policy-makers have introduced various reg-
ulations to address these problems, one of them is to implement
a pollution toll. However, current toll schemes charge fixed fees
based on static criteria such as vehicle type or toll area [14]. In this
work, inspired by [15], we propose a novel fine-grained system
to calculate toll fee proportionally to the pollution level of each
area. This means the more polluted an area is, the higher fee per
driven kilometre is applied for all vehicle in that area. One obvious
advantage of this approach is that this system allows a dynamic
toll rate based on real-time air pollution level. In addition, this is
very scalable, as it only uses location data of the vehicle in short
intervals to calculate the toll fee. The fairness of this system can be
further improved by adding information about the vehicle’s model
and speed (estimated from the location data).

The hypothetical toll system adopts the event-driven microser-
vice architecture, in which each microservice is responsible for a
specific task and data is exchanged as JSONs through a message
broker using the publish-subscribe asynchronous messaging pat-
tern. Fig. 1 illustrates the architecture, in which the arrows among
microservices are not direct communication but rather an indirect
communication via a message broker. The processing pipeline is
explained in detail below:

• The vehicles update their GPS coordinates information by
sending JSON-based messages via the message broker.

Figure 1: Overview architecture of
pollution-aware toll system.

the proposed air

• The Map Matcher Service subscribes to Location update mes-
sages from the vehicles. Then it uses the APIs provided by
a local instance of OSRM (Open Source Routing Machine)
[16] to map the reported coordinates to a route on streets.
Then the driven route will be sent to the message broker in
the Route Messages.

• The Pollution Matcher Service receives the Route messages
and compares them with an air pollution database. In this
PostGIS database, polluted areas are stored as polygons with
corresponding pollution levels. The received route is matched
against these polygons and in case the route crosses multiple
areas with different pollution levels, it will be broken down
into several segments. These segments together with corre-
sponding pollution levels are sent by the Pollution Matcher
Service to the message broker via Segment Messages.

• The Toll Calculator Service calculates the fare for each vehi-
cle based on the Segment Messages. It calculates the travel
distance of each segment and, based on the pollution level,
returns the accumulative toll fee for each vehicle. Those
values are sent to the message broker as Toll Messages.
• Upon receipt of the Toll Messages, the Dashboard displays the
cumulative toll fee for each car and visualizes each vehicle’s
route on an interactive map.

4 FRAMEWORKS
There is a large availability of frameworks for different program-
ming languages. For the implementation of the toll system, we
selected four different microservices frameworks: Go Micro (Go),
Moleculer (JavaScript with Node.js), Lagom (Scala), and Spring
Boot/Spring Cloud (Java). They are chosen to reflect the variety of
tools that can be used to develop microservices. With respect to
programming languages, Java is consider an “old" language while
Scala and Go both have been introduced in the last decade, and
Node.js is a new run-time environment for JavaScript. In terms
of framework design philosophy, although Spring Boot is widely
used for microservices, it is not designed specifically for such ap-
plications like the other three. Each framework provides a different
approach to build microservice-based applications. In this section,
we briefly discuss the main differences.

Go Micro. provides an abstraction for distributed systems de-
velopment using Remote Procedure Call (RPC) and Event-driven
communication written in Go. This opinionated framework is pro-
vided as a set of pluggable building blocks that can be included
or excluded in a project depending on the application’s specific
requirements. This design reduces the complexity in development.

2

MapMatcherServicePolutionMatcherServiceTollCalculatorServiceDashboardOpen SourceRoutingMachinePollutionAreaDatabaseVehiclesThey cover a wide range of functionalities, from sync/async messag-
ing, message encoding, service discovery, to dynamic configuration.
To define a microservice with Go Micro, the framework emcourages
developers to firstly define the interfaces (default by ProtoBuf), and
then implement them. Afterwards, the service can be initialized
and registered with the built-in service registry.

As observed in the four implementations, there are two main ap-
proaches from the different frameworks: they can either implement
their own services or provide integration with existing solutions.
In addition, as open source projects, besides the official code, they
can provide community-maintained plugins and modules such as
in Go Micro and Moleculer.

Lagom. is another opinionated microservice framework to build
reactive microservices in Scala or Java. Developed and maintained
by the same company behind Akka and Play Framework, Lagom
is built to be easily integrated into these two technologies. Lagom
supports and encourages using Event sourcing and Command Query
Responsibility Segregation (CQRS) for data persistence. Lagom rec-
ommends developers to separate the service interface and service
implementation, which are organized as sub-projects within the
same build. While the former contains the interface descriptions,
along with data models, the latter implements the service logic.

Moleculer. is a microservice framework for JavaScript using
Node.js runtime built on Chrome’s V8 JavaScript engine. The main
design philosophy of this framework is to produce low latency
event-driven applications. Moleculer also provides pluggable mod-
ules for various functions such as gateways, database, serialization,
etc. The framework consists of three main components: the trans-
porter, the service and the service broker. While the service defines
the general structure for each microservice, the transporter is an
abstraction for the communication bus, and the service broker binds
service with transporter.

Spring Boot & Spring Cloud. are two projects from the Spring
ecosystem. While Spring Boot is an opinionated way to build stand-
alone Spring applications, Spring Cloud provides a set of tools to
quickly build several common patterns in distributed systems such
as service discovery, configuration management, etc. That means
Spring Boot is not specifically designed for developing microser-
vices but rather a full stack development environment. Spring Boot
has to rely on Spring Cloud for microservices-specific capabilities.

5 FEATURE COMPARISON
In this section, we provide an extensive evaluation of those frame-
works with respect to 2 main criteria: feature features and design
patterns. For the former, we further sub-categorize it into (1) Ma-
turity, (2) Supports for microservice development, and (3) Built-in
features. All of these details will be summarized in Table 1 and
Table 2. Note that, a "N/A" does not necessary mean that the frame-
work lacks a certain feature, but rather that the feature requires
external libraries, which has not yet been officially integrated into
the framework.

5.1 Main features and design philosophy
All four microservice frameworks focus on providing infrastructure
services for microservice-based applications. In fact, the separation
between infrastructure ser vices and functional services has been
well discussed in the literature [17]. While infrastructure services
provide essential capability such as service registry or service dis-
covery, functional services are the ones that provide actual business
logic.

3

5.2 Maturity
To quantify the maturity of a open sourced software framework, we
take a look at the release cycle and metrics from open source web-
sites for code hosting such as GitHub as used in previous research
[18, 19].

Given that Spring Boot has been initially releases in 2014, while
Lagom’s first release was in 2016 and both Go Micro and Moleculer
in 2017, Spring Boot has become one of the most mature frame-
works. That also explains how the amount of releases from Spring
outperforms the others twice, as seen in Table 1. However, as Spring
Boot is also a popular framework to build generic Java applications,
this might not fully reflect the maturity of Spring in developing
microservices specifically.

5.3 Supports for microservice development
Given the difference in maturity among the selected frameworks,
one can expect different levels of support and learning curves. In-
deed, the documentation of Spring Boot is very extensive compared
to the others. With a huge community and long existence on the
market, it is easy to find support from developer communities such
as StackOverflow. Besides, Spring and Lagom are backed by Pivotal
and Lightbend respectively, so they can offer commercial support
for large organizations, while Moleculer and Go Micro must rely
on community-based supports.

Build tools and dependency management solution plays an im-
portant roles to significantly improve the productivity. Boilerplate
codes for new microservices can be quickly generated following
certain templates, however each framwework supports different
level of customization. For example, Lagom and Moleculer only
allow to set up project name and service name, while the other
two allow specifying dependency packages. In addition, features
such a hot reloading or interactive development console can further
shorten development cycles, as they help developers to immediately
see the effects of new code at runtime.

5.4 Design patterns
To achieve robustness in microservices, there are certain recom-
mendations to follow, such as minimizing service dependencies
or separating data storage [20]. These non-functional properties
materialize in different design patterns. To understand how each
selected framework design philosophy differs from each other, we
briefly discuss them in this section and provide a summary in Table
2.

To provide API access for external users, all four frameworks
support the API Gateway pattern. In this design pattern accesses
to individual microservices are not directly provided to the user.
Instead, a gateway is used as a single entry point for the application,
exposing APIs, routing messages to responsible microservices, or

even translating messaging between different protocols, such as in
Go Micro.

Another design pattern advocated by all frameworks is the Data-
base per service design pattern. Microservice design helps decou-
pling services as they can be developed, deployed, and updated

Table 1: Features of microservices frameworks

y
t
i
r
u
t
a
M

s
t
r
o
p
p
u
s

t
n
e
m
p
o
l
e
v
e
D

GitHub stats

Documentation

Supported
guages

lan-

Community supports

Commercial supports

Development
environment

lan-

Initial release date
Releases
Commits
Watch
Star
Contributors
Documentation
Sample code
Supported
guages
Stack
tags
Chat platform
Forum
GitHub
Training course
Certification
Build tool & Depen-
dency Management
Hot reload

OverFlow

Template generator

Spring Boot
July 10th 2014
146
25357
3348
45626
656
Very Extensive
Yes
Java,
Groovy, Beanshell
162688

Kotlin,

Gitter
Yes
Yes
Yes
Yes
Maven
Gradle, Ant
Yes, but not by de-
fault
Spring
(web-based)

(default),

Initialzr

Interactive develop-
ment console

N/A

API Gateway
Service discovery
Service registry
Load balancing

Serialization

Yes
Yes
Yes
Spring Cloud Load
Balancer
JSON by Jackson

s Essential services

e
r
u
t
a
e
f
n
i
-
t
l
i
u
B

Lagom
March 3rd 2016
76
2397
165
2370
126
Extensive
Yes
Java, Scala

296

Gitter
Yes
Yes
Yes
Yes
sbt

Yes, supported by
default with sbt
Lagom Tech Hub
Project
Starter
(web-based)
sbt
console,
for
purposes

development
only
development

Yes
Yes
Yes
Relies on underly-
ing Akka
JSON (defualt), Pro-
toBuf, Apache Avro,
Kryo

Other features

Integration with
Slack
Interactive CLI
Web dashboard
Caching

N/A

sbt
N/A
N/A

N/A

Spring Boot CLI
N/A
JCache,EhCache
2.x, Hazelcast, Infin-
ispan, Couchbase,
Redis, Caffeine, etc.

4

Go Micro

Moleculer
February 16th 2017 December 6th 2017
86
3222
123
3322
65
Less extensive
Yes
Javascript/NodeJs

70
2700
452
11748
77
Limited
Yes
Go

38

29

Slack
Yes
Yes
No
No
Default to Go Build

N/A

micro new com-
mand

Interactive Micro
CLI, to manage the
services

Yes
Yes
Yes
proxy package

JSON or ProtoBuf

bot package

Micro CLI package
web package
N/A

Gitter
Yes
Yes
No
No
Default to npm

Yes, enabled by de-
fault
moleculer-cli com-
mand

REPL console: list
nodes, services, ac-
tions, events, envi-
ronment variables,
etc.
Yes
Yes
Yes
server-side load bal-
ancing by default
(default),
JSON
Avro,
MsgPack,
Notepack, ProtoBuf,
Thrift, and custom
modules
N/A

moleculer REPL
N/A
cache,
built-in
heap
memory,
LRU cache module,
or
Redis-based,
custom cacher

without breaking other services. However, data can create hidden
dependencies among services. Therefore, each microservice should
manage its own data and no service can modify data belonging
to another service. In contrast, shared databases among multiple
services is not encouraged by any framework. A more advanced
pattern, such as Command-Query Responsibility Segregation with
Event Sourcing, is even part of the framework philosophy like in
the case of Lagom.

In a environment with multiple services being independently
deployed, it is crucial for the operators to have an overview of the
application and insights into underlying operations [21]. Therefore,
all four frameworks provide extensive integration with different
logging tools. However, when it comes to metrics collecting, while
Moleculer has a built-in module collecting and publishing metrics
to various outputs, Spring Boot and Go Micro provide a metrics col-
lector as a pluggable module; Lagom has to rely on Lightbend cloud
platform for those capabilities. This is because Lagom has been
designed to simplifying microservices application development and
deployment on Lightbend’s current offer in cloud platform.

Similarly, a technique used for monitoring and analyzing dis-
tributed systems called Distributed Tracing is also supported by
all frameworks. In this technique, as a request travels through the
system, a unique identifier is added, allowing details about the path,
time spend spent in each services to be centrally captured and visu-
alized. Although no framework provides its own implementation of
a monitoring service supporting Distributed Tracing, Spring Boot,
Moleculer, and Go Micro are fully integrated with external solutions
such as Prometheus. In contrast, Lagom microservices have to rely
again on Lightbend’s platform.

With the recent growth of container-based cloud platforms,
Docker and Docker-based orchestration platforms like Kubernetes,
Mesosphere DC/OS, OpenShift, etc., have become the de facto stan-
dard. All of the frameworks have supports for Docker deployment,
except Moleculer’s support for Kubernetes still missing. Both Spring
Boot and Lagom can build executables that can be deployed on
Heroku, Azure, etc.

Regarding the communication patterns among microservices, all
of the frameworks encourage using asynchronous messaging as the
main way for exchanging information. Asynchronous messaging
can decouple services, minimizing dependencies, and improve the
fault tolerance of the application as a whole [22]. In fact, being
able to operate asynchronously is one of the design criteria to get
the most out of the microservice architectural style [23]. While
most of the widely used protocols such as AMQP, MQTT, are fully
supported by all, each framework implements the communication
channel differently: Spring, Lagom, and Go Micro provides dif-
ferent integration modules for message brokers, while Moleculer
differentiates two communication types. Local services use an in-
memory local bus for exchanging messages. Remote services relies
on an abstraction layer called Transporter, which can deliver events,
requests, and responses. By default, NATS is used as the broker,
however, other implementations cannot be added directly, because
Moleculer automatically adds prefixes to messages topics.

In a microservices environment with a large number of dis-
tributed services, it is utmost crucial to prevent cascading failures.
All four frameworks support the Circuit Breaker pattern. In this

Figure 2: Long latency for first messages in Lagom.

design, in case of failure, requests are rejected immediately, thus
avoiding errors.

6 PERFORMANCE EVALUATION
6.1 Test setup
We implemented the pipeline as described in section 3 with each
framework. For the evaluation test, the following versions of the
tools and frameworks have been used: Spring Boot 2.2.4 (Java 1.8),
Go Micro 1.18.0, (Go 1.13), Moleculer 0.13.0 (Node.js 13.1.4), Lagom
1.6.0 (Scala 2.12.8), NATS 2.1.2. To ensure the consistency of input
data across tests, we built a Traffic Simulator to simulate vehi-
cles. This component is based on the Simulation of Urban MObility
(SUMO) [24], and provides a traffic simulation in a European city
using data from the OpenStreetMap. From the Dashboard, the simu-
lation can be configured by the number of simulated vehicles and
update frequency. The results presented in this paper is from sim-
ulations with 10 vehicles, and they update their location every 5
seconds.

The machine where the tests were carried out has an Intel Core
i5 processor and 16GB of RAM. All microservices are containerized
using Docker and deployed using Docker Compose, as this is a
popular choice to achieve platform-independent deployment strat-
egy [9]. We have considered latency and resource consumption as
the key criteria to measure the performance of the different frame-
works. Another resource metric is the footprint of the application,
given by the size of the Docker images.

The selected usecase represents some typical microservices types,
which should be taken into account when application being evalu-
ated. The Map Matcher portrays a service which consumes external
API, the Pollution Matcher constantly exchanges data with an exter-
nal database, while the Toll Calculator performs all the calculation
internally.

6.2 Slow start of JVM-based implementations
We noticed long latencies in the first messages processed in Spring
Boot and Lagom implementations compared to subsequent requests
as illustrated in Fig. 2.

The reason for such a strange behavior, which is not found in
other implementations, lies in the Java Virtual Machine (JVM) warm

5

up phase [25]. In this test, to reduce the effects of the warm up phase,
we only evaluate the framework performance after five message
iterations, i.e. skipping the first 50 messages.

Table 2: Design patterns of microservice frameworks

Spring

Lagom

Moleculer

Go Micro

n
o
i
t
a
r
g
e
t
n
I

API Gateway

e Database per service

Spring Cloud Gateway,
built on top of Spring
MVC, Netty
Supported

s
a
b
a
t
a
D

Shared database
CQRS/Event Sourcing

y Log Aggregation

Performance Metrics

Distributed Tracing

Health Check

s External configuration
n
r
e
c
n
o
c

Service Registry

t
i
l
i
b
a
v
r
e
s
b
O

g
n
i
t
t
u
c
-
s
s
o
r
C

Client-side service dis-
covery

Server-side service dis-
covery
Deployment platform

n Synchronous messaging
o
i
Asynchronous messag-
t
a
c
ing
i
n
u
m
m
o
C

Remote Procedure Invo-
cation
Circuit Breaker

e
c
n
a
r
e
l
o
T
t
l
u
a
F

Retry

Timeout

Supported
Supported
Logback(default),
Util Logging, Log4J2

Java

Prometheus, Datadog,
Netflix Atlas
Supported with Spring
Cloud Sleuth

supported with Spring
Actuator
Spring Cloud Netflix for
client and server-side,
Netflix Archaius
Netflix Eureka. Also
Consul,
Kubernetes,
Apache
Zookeeper,
Alibaba Nacos
Client-side load balanc-
ing supported with Rib-
bon
N/A

Kubernetes,
Docker,
Cloud Foundry, Azure,
Heroku, Amazon AWS,
OpenShift, Boxfuse
Supported
RabbitMQ,
Apache
Kafka, Amazon Kinesis,
Google PubSub
RMI, Spring’s HTTP In-
voker, Hessian, Burlap
Supported with Netflix
Hystrix
Spring-retry, Retryable
annotation
For HTTP components

Default
embedded
gateway based on Akka
HTTP
Cassandra,
MySQL,
Oracle,
PostgreSQL,
Couchbase, Microsoft
SQL, H2
Discouraged
Supported by default
SLF4J based on Logback
(default), Log4J2

Provided by Lightbend
platform
Provided by Lightbend,
which supports Open-
Tracing
N/A

N/A

Provided by default

moleculer-web for re-
quest routing

MySQL,
SQLite,
to

MongoDB,
PostgreSQL,
MSSQL. Default
CRUD actions
Discouraged
N/A
Console output, Pino,
Bunyan,
Winston,
Log4js, Datadog
Prometheus,
Datadog
Built-in tracing module
works with Zipkin,
Jaeger, Datadog
Built-in

StatsD,

External configuration
files can be loaded via
moleculer-runner
Built-in service registry

Go API libraries for pro-
tocol translation and re-
quest routing
Only provides a Store
interface for additional
storage in the future

N/A
N/A
Logrus, Zap, Zerolog

Prometheus.

Amazon AWS X-Ray,
UUID plugin to trace
messages manually
sidecar implementation
via RPC
Supported via Go Config

Built-in, can be accessed
via a Web Dashboard

Provided in the Service-
Locator

N/A

mdns, etcd

Supported

Default

mdns, etcd

Docker,
OpenShift,
sphereDC/OS

Kubernetes,
Meso-

Docker/Docker Com-
pose, Kubernetes under
development

Local, Docker, Kuber-
netes

Supported
Message Broker API for
Kafka

Supported
Preferred: NATS, Kafka,
Redis, MQTT, AMQP

gRPC library

Akka
HTTP/JSON
Used for all service calls
by default
N/A

Circuit breaker: call and
reset timeouts

6

threshold-

RPC is implemented by
default
Built-in,
based
Exponential
retry
Set timeout values for re-
quests

back-off

Supported
PubSub is preferred. De-
fault embedded NATS
server
Supports gRPC.

Plugins.

Resend the requests to
another node
N/A

Figure 3: Comparison of latency performance.

6.3 End-to-end latency performance
Fig. 3 summarizes the end-to-end latency of each framework. All
four implementations show similar behavior in regard to latency, al-
though to different extents. There are still some noticeable patterns
shared by all implementation. For example, the slowest microser-
vice is always the Pollution Matcher that has to access the PostGIS
database, it accounts from 73.27% in Lagom to 90.59% of the total
time in Go Micro implementation. By contrast the Toll Calculator
has a minimal contribution to the total end-to-end time since it can
perform all the processes internally. From the results, it is clear that
database access is very slow compared to other I/O bound tasks.
This illustrates difficulties in managing service’s state, in which
the they should be externalized into a database to create totally
stateless services. In many designs, the microservices are forced to
follow the 12-factor app principle, i.e. stateless, but generally it is
either very difficult or not optimized to build applications solely
from stateless microservices.

Communication overhead is more dispersed for Lagom and
Spring, while Go Micro and Moleculer have a more consistent de-
lay. Even with slower communication, Lagom performs in general
better than Go Micro.

6.4 Resource consumption

Docker images size. We evaluated the Docker image size pro-
duced by each framework, as smaller images can be deployed and
created quickly, leading to faster update cycles [26]. In this setup, we
used Alpine-based images: Spring uses openjdk:8-jre-alpine, Lagom
uses openjdk:8-jre-alpine, Moleculer uses mhart/alpine-node:10,
and Go Micro uses golang base image as build image and scratch
as deployment container. The results are summarized in Fig. 4. As
Go applications can be built as binary files, they can use scratch - a
minimal empty Docker image. Therefore services developed with
this language are very compact compared to others, for example,
the Pollution Matcher written in Go Micro is 78% smaller the im-
plementation with Lagom (33.6 MB vs. 156 MB). Moleculer also

Figure 4: Docker images size comparison.

Figure 5: CPU and memory consumption of microservices
implemented by different frameworks.

has the ability to create smaller Dockerized services compared to
Lagom or Spring Boot, as these two frameworks require a JVM to
run the source code.

CPU and memory usage. As visible in Fig. 5, Lagom and Spring
yield much higher resource consumption than the other two frame-
works. It is interesting that while Lagom has a higher CPU usage
on the Map Matcher service than Spring, and lower than for the
Pollution Matcher, in the case of memory usage the results are re-
versed. Looking again at Fig. 3, the latency for the Map Matcher is
the lowest with Spring, but this framework also shows the highest
latency in the Pollution Matcher. Lagom obtains a slightly lower
total end-to-end latency than Go Micro, but with a much higher
resource consumption, so it is important to look at both aspects
when deciding for a framework.

The lower CPU and memory consumption and small image size
of the Go Micro services make it the most efficient framework in
resource usage out of the four.

7

7 DISCUSSION
Three out of four frameworks studied in this work (Lagom, Moleculer,
and Go Micro) encourage developers to structure the communica-
tion protocol before developing actual microservices. In contrast,
Spring Boot doesn’t force developers to follow a certain code style
to define application’s API. One of the possible reasons is that
Spring Boot is a general-purpose framework, not designed specif-
ically for microservices. This fact emphasizes the importance of
communication pattern in distributed systems in general and in
microservices in particular.

In theory, service decoupling is described as one of the most
important features of microservices. However, in reality, there are
several challenges to realize total independence among microser-
vices. For example, shared libraries among microservices improve
productivity of developers but also create dependencies. In our
implementation, JSON is selected as the message format exchanged
among services because it doesn’t create specific requirements for
microservices in serialization/deserialization. If Protocol Buffer is
used instead, it forces every microservice to use ProtoBuf. However,
given that ProtoBuf implementations are available for many pro-
gramming languages, developers still have many options to develop
their services. In another extreme end, using some platform-specific
protocols such as Spring HTTP Invoker forces both server and client
to be written in a JVM language.

For a cloud native architecture such as microservices, interoper-
ability is becoming more significant than ever. Adopting a microser-
vice framework using standards or popular tools can be much more
beneficial for an organization in the long run. In this regard, as
one of the most popular software frameworks, Spring Boot/Spring
Cloud provides developers a clear advantage to build microservices
as this framework has an extensive level of support and integration
available. Both Go Micro and Moleculer provide less opinionated
approach to build microservices. Lagom relies heavily on Lightbend
platform and Akka, so it might require additional efforts to deploy
on other platforms.

The development of microservices in particular, or cloud native
applications in general, relies on many different levels of abstrac-
tion, which can degrade the performance significantly. Software
architects and developers should also keep that in mind when se-
lecting a technology stack for an application. For example, our
results show that Moleculer can achieve a good end-to-end latency
performance, but when deploying using Docker, Go Micro can pro-
duce much smaller images, which could be beneficial on limited
resources. Similarly, JVM-based languages can lead to bigger Docker
images, and higher resource consumption. Together with the JVM
warm-up issue, it might not be the best choice for latency-sensitive
application.

8 CONCLUSION
In this work, we presented an evaluation of microservice frame-
works through the development of an example application, which
includes both internal and external communication, data query
from external database, and uses Docker for deployment. We de-
fined three main comparison categories: For features, we examined
three categories, which are maturity, development supports, and
built-in features; for design patterns, we categorized them into six

8

groups as presented in Table 2; for performance, we relied on two
main criteria, which are end-to-end latency performance and re-
source consumption. The criteria mentioned in our evaluation can
be extended to use as a comparison framework for selecting a de-
velopment stack for a microservice-based application.

From the results presented in this work, it is clear that there is
no one-size-fits-all solution when choosing a microservice frame-
work. It depends a lot on application’s specific functional and non-
functional requirements. All of the frameworks mentioned in this
paper as well as most of other options available can provide ab-
straction and boilerplate code to help developers deal with the
complexities commonly found in distributed systems such as mi-
croservices. As shown in the evaluation section, interoperability
is one of the most important criteria to maximize the flexibility
in tool selection. For example, the fact that Lagom is designed to
heavily rely on Akka and Lightbend platform, or Moleculer uses a
custom naming convention for message queues, might cause inte-
gration issues with other microservices. Regarding design patterns,
all frameworks follow asynchronous, event-driven architecture
with supports for other capabilities such as distributed tracing or
fault tolerance. When it comes to performance comparison, our
results show how using JVM-based languages can result in heavier
Docker images and higher resource consumption.

The design of our test is, however, still limited to provide a
comprehensive comparison among selected frameworks. Although
we have tried our best to have a similar implementation in different
frameworks/languages, there are still some specific features that
cannot be easily translated into other implementations. In addition,
the interaction among microservices of our design is only a simple
chain, which cannot convey more complicated interaction schemes.

9 FUTURE WORK
As mentioned in the conclusions, an evaluation scenario with more
complicated interaction patterns instead of chained microservices
can produce more insights into the application performance. Other
possibilities are to evaluate on the effects of data persistence strate-
gies on microservices performance and scaling of the system, with
multiple instances of each microservice where also load balancing
could be tested.

REFERENCES
[1]

James Lewis and Martin Fowler. 2014. Microservices. Mart-
inFowler.com.

[2] Ralph E Johnson. 1997. Components, frameworks, patterns.
In Proceedings of the 1997 symposium on Software reusability,
10–17.

[3] Ralph E Johnson and Brian Foote. 1988. Designing reusable
classes. Journal of object-oriented programming, 1, 2, 22–35.
[4] Maurizio Morisio, Daniele Romano, and Ioannis Stamelos.
2002. Quality, productivity, and learning in framework-based
development: an exploratory case study. IEEE Transactions
on Software Engineering, 28, 9, 876–888.

[5] Mohamed Fayad and Douglas C Schmidt. 1997. Object-oriented
application frameworks. Communications of the ACM, 40, 10,
32–38.

[21] Kapil Bakshi. 2017. Microservices-based software architec-
ture and approaches. In 2017 IEEE Aerospace Conference. IEEE,
1–8.

[22] Daniel Richter, Marcus Konrad, Katharina Utecht, and An-
dreas Polze. 2017. Highly-available applications on unreliable
infrastructure: microservice architectures in practice. In 2017
IEEE International Conference on Software Quality, Reliability
and Security Companion (QRS-C). IEEE, 130–137.

[23] Martin Garriga. 2017. Towards a taxonomy of microservices
architectures. In International Conference on Software Engi-
neering and Formal Methods. Springer, 203–218.

[24] Michael Behrisch, Laura Bieker, Jakob Erdmann, and Daniel
Krajzewicz. 2011. Sumo–simulation of urban mobility: an
overview. In Proceedings of SIMUL 2011, The Third Interna-
tional Conference on Advances in System Simulation. Think-
Mind.

[25] David Lion, Adrian Chiu, Hailong Sun, Xin Zhuang, Nikola
Grcevski, and Ding Yuan. 2016. Don’t get caught in the cold,
warm-up your {jvm}: understand and eliminate {jvm} warm-
up overhead in data-parallel systems. In 12th {USENIX} Sym-
posium on Operating Systems Design and Implementation
({OSDI} 16), 383–400.
Jaewook Kim, Tae Joon Jun, Daeyoun Kang, Dohyeun Kim,
and Daeyoung Kim. 2018. Gpu enabled serverless computing
framework. In 2018 26th Euromicro International Conference
on Parallel, Distributed and Network-based Processing (PDP).
IEEE, 533–540.

[26]

[6] Michael Mattsson. 1999. Effort distribution in a six year in-
dustrial application framework project. In Proceedings IEEE
International Conference on Software Maintenance-1999 (ICSM).
IEEE, 326–333.
Savitha Srinivasan. 1999. Design patterns in object-oriented
frameworks. Computer, 32, 2, 24–32.

[7]

[8] Mohamed E Fayad, David S Hamu, and Davide Brugali. 2000.
Enterprise frameworks characteristics, criteria, and chal-
lenges. Communications of the ACM, 43, 10, 39–46.

[9] Takanori Ueda, Takuya Nakaike, and Moriyoshi Ohara. 2016.
Workload characterization for microservices. In 2016 IEEE in-
ternational symposium on workload characterization (IISWC).
IEEE, 1–10.

[10] Marcelo Amaral, Jorda Polo, David Carrera, Iqbal Mohomed,
Merve Unuvar, and Malgorzata Steinder. 2015. Performance
evaluation of microservices architectures using containers.
In 2015 IEEE 14th International Symposium on Network Com-
puting and Applications. IEEE, 27–34.

[11] Carlos M Aderaldo, Nabor C Mendonça, Claus Pahl, and
Pooyan Jamshidi. 2017. Benchmark requirements for mi-
croservices architecture research. In 2017 IEEE/ACM 1st In-
ternational Workshop on Establishing the Community-Wide
Infrastructure for Architecture-Based Software Engineering
(ECASE). IEEE, 8–13.

[12] Akshitha Sriraman and Thomas F Wenisch. 2018. 𝜇 Suite: a
benchmark suite for microservices. In 2018 IEEE International
Symposium on Workload Characterization (IISWC). IEEE, 1–
12.

[13] World Health Organization. 2018. Ambient (outdoor) air
pollution. Retrieved 01/22/2020 from https://www.who.int/
en/news-room/fact-sheets/detail/ambient-(outdoor)-air-
quality-and-health.

[15]

[14] Ying Wang, Su Song, SHIYONG QIU, Lu Lu, Yilin Ma, Xiaoyi
Li, and Ying Hu. 2017. Study on international practices for
low emission zone and congestion charging. Beijing, World
Research Institute.
Sandro Rodriguez Garzon and Axel Küpper. 2019. Pay-per-
pollution: towards an air pollution-aware toll system for
smart cities. In 2019 IEEE International Conference on Smart
Internet of Things (SmartIoT). IEEE, 361–366.
Stephan Huber and Christoph Rust. 2016. Calculate travel
time and distance with openstreetmap data using the open
source routing machine (osrm). The Stata Journal, 16, 2, 416–
423.

[16]

[17] Hai Dinh-Tuan, Felix Beierle, and Sandro Rodriguez Garzon.
2019. Maia: a microservices-based architecture for indus-
trial data analytics. In 2019 IEEE International Conference on
Industrial Cyber Physical Systems (ICPS). IEEE, 23–30.
[18] Nora McDonald and Sean Goggins. 2013. Performance and
participation in open source software on github. In CHI’13
Extended Abstracts on Human Factors in Computing Systems,
139–144.

[19] Mikhail G Dozmorov. 2018. Github statistics as a measure of
the impact of open-source bioinformatics software. Frontiers
in bioengineering and biotechnology, 6, 198.

[20] Claus Pahl and Pooyan Jamshidi. 2016. Microservices: a sys-

tematic mapping study. In CLOSER (1), 137–146.

9

