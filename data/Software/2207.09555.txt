2
2
0
2

l
u
J

9
1

]

C
D
.
s
c
[

1
v
5
5
5
9
0
.
7
0
2
2
:
v
i
X
r
a

Xronos: Predictable Coordination for Safety-Critical
Distributed Embedded Systems

Soroush Bateni∗, Marten Lohstroh∗, Hou Seng Wong∗, Rohan Tabish†, Hokeun Kim‡,
Shaokai Lin∗, Christian Menard§, Cong Liu¶, Edward A. Lee∗
∗EECS Department, UC Berkeley, USA
{soroush, marten, housengw, shaokai, eal}@berkeley.edu
†Department of Computer Science, UIUC, USA
rtabish@illinois.edu
‡Department of Electronic Engineering, Hanyang University, Korea
hokeun@hanyang.ac.kr
§Chair for Compiler Construction, TU Dresden, Germany
christian.menard@tu-dresden.de
¶Department of Computer Science, UT Dallas, USA
cong@utdallas.edu

Abstract—Asynchronous frameworks for distributed embed-
ded systems,
like ROS and MQTT, are increasingly used in
safety-critical applications such as autonomous driving, where the
cost of unintended behavior is high. The coordination mechanism
between the components in these frameworks, however, gives rise
to nondeterminism, where factors such as communication timing
can lead to arbitrary ordering in the handling of messages. In this
paper, we demonstrate the signiﬁcance of this problem in an open-
source full-stack autonomous driving software, Autoware.Auto
1.0, which relies on ROS 2. We give an alternative: Xronos, an
open-source framework for distributed embedded systems that
has a novel coordination strategy with predictable properties
under clearly stated assumptions. If
these assumptions are
violated, Xronos provides for application-speciﬁc fault handlers
to be invoked. We port Autoware.Auto to Xronos and show that
it avoids the identiﬁed problems with manageable cost in end-to-
end latency. Furthermore, we compare the maximum throughput
of Xronos to ROS 2 and MQTT using microbenchmarks under
different settings, including on three different hardware conﬁgu-
rations, and ﬁnd that it can match or exceed those frameworks
in terms of throughput.

I. INTRODUCTION

Frameworks such as the Robot Operating System (ROS) [1]
and MQTT [2], [3] are widely used in safety-critical, concur-
rent, and often distributed applications such as autonomous
driving and industrial automation [4], [5], [6]. These frame-
works are convenient, modular, and their underlying asyn-
chronous coordination mechanism, called publish-subscribe
(pub-sub), is easy to use and not prone to deadlocks. This
paper empirically shows that pub-sub is ill-suited for such
applications and offers an alternative: an open-source middle-
ware called Xronos built on top of an open-source coordination
language, LINGUA FRANCA (LF) [7]. LF, based on the reactor
model [8], is a polyglot coordination language that borrows
the best semantic features of established models of compu-
tation, such as actors [9], logical execution time (LET) [10],
synchronous reactive languages [11], and discrete event sys-

tems [12] such as DEVS [13] and SystemC [14]. LF furthers
the state of the art by making time a ﬁrst-class citizen in the
programming model and by enabling deterministic interactions
between multiple physical and logical timelines [7].

The Xronos runtime system is implemented in C to ensure
efﬁciency. Xronos applications are modular, just like ROS
and MQTT, allowing independent processes to be deployed
to distributed embedded hardware. This property is crucial for
complex distributed robotics applications such as autonomous
driving. Xronos enables predictable coordination between soft-
ware components using explicit temporal semantics that is
realistic about the inability to perfectly control timing and
to perfectly synchronize clocks. It
is also realistic about
the unavoidability of faults. Things will go wrong, so the
emphasis in Xronos is on detecting timing faults and enabling
application logic to react to them. Xronos does not require
real-time network services such as TSN [15] nor real-time
operating system services, but it can beneﬁt from them to
reduce the frequency of faults,
to reduce latencies, or to
increase throughput.

We start with an open-source self-driving car application
called Autoware.Auto and identify subtle problems that arise
due to the use of ROS’s pub-sub coordination fabric. We
then port Autoware.Auto to Xronos, demonstrating that it is
equally convenient, modular, and easy to use, and that ROS
apps are not hard to convert. We show that some of the
identiﬁed problems disappear and that previously undetectable
faults caused by violations of timing requirements, become de-
tectable, enabling the addition of application logic for dealing
with such faults.

Xronos uses logical time to provide deterministic concur-
rency, achieving better repeatability than pub-sub. Xronos
aligns its logical timeline with measurements of physical time
to facilitate real-time interactions with sensors and actuators. It
supports asynchronous injection of external events, and once a

1

 
 
 
 
 
 
logical time has been assigned to such events, their handling is
deterministic. We show that this determinism does not incur a
signiﬁcant performance cost on three test platforms, a PC, an
NVIDIA Jetson AGX Xavier, and a heterogeneous two-node
distributed embedded system.

For distributed embedded systems speciﬁcally, how to deal
with faults and degradations is application-dependent. If com-
munication latency increases, for example, some applications
will require timely reactions even with incorrect or inconsis-
tent data, whereas for other applications the correctness of
responses is more important than their timeliness. For example,
an emergency braking system may prefer to apply the brakes
with incomplete sensor data, whereas a car may prefer to delay
entering an intersection when sensor data is incomplete or
inconsistent.

Brewer’s CAP theorem [16] shows that no system can
have both consistency (here, conformance with the application
speciﬁcations) and availability (here, timely reactions) when
the network is partitioned. This paper proposes two distributed
coordination mechanisms, both implemented in Xronos. One
emphasizes availability over consistency, and the other empha-
sizes consistency over availability when the network fails or
degrades. The ﬁrst mechanism, our decentralized coordinator,
is an extension of PTIDES [17], a real-time technique also
implemented in Google Spanner [18], a globally distributed
database. This coordinator is also inﬂuenced by Lamport [19],
and Chandy and Misra [20], [21].

The second mechanism, our centralized coordinator,
is
an extension of the High-Level Architecture (HLA) [22], a
distributed discrete-event simulation standard. Our extensions
adapt HLA’s techniques to make them usable not just for
simulation, but also for distributed real-time deployment where
unpredictable asynchronous events are injected via sensors.

The decentralized coordinator ensures software components
continue to react even if the communication latencies increase,
whereas the centralized coordinator ensures the software com-
ponents behave as speciﬁed even if their inputs are delayed.
Hence, the decentralized coordinator emphasizes availability
over consistency, whereas the centralized coordinator empha-
sizes consistency over availability when the network degrades.

The rest of this paper is organized as follows: We give
background on state-of-the-art
frameworks for distributed
embedded systems, Autoware.Auto, and LF in Sec. II. We
demonstrate three speciﬁc issues in Autoware.Auto with em-
pirical evidence in Sec. III. We explain the design of Xronos
and detail our extensions to LF in Sec. IV and offer im-
plementation details in Sec. V. Finally, we evaluate Xronos
on microbenchmarks and Autoware.Auto in Sec. VI, give
an overview of related work in Sec. VII, and conclude in
Sec. VIII.

II. BACKGROUND

A. Pub-Sub Frameworks for Distributed Embedded Systems
ROS1 is a collection of tools and libraries that facilitate the
development of robotics applications. Developers can pack-
age software modules as independent entities called nodes.
Each node will live in its own separate process on a host
operating system. Nodes can co-exist on a single machine
or be distributed across multiple and communicate over the
network. Irrespective of physical location, nodes communicate
using a pub-sub model, in which publishers advertise topics
and subscribers bind a speciﬁc callback function to a topic.
ROS 2, which we use in this paper, utilizes a DDS-compliant
communication framework [23] to implement
the pub-sub
mechanism. We identify this underlying pub-sub as a potential
source of concurrency errors that affect the application logic
and are hard to detect and remedy (see Sec. III). MQTT [24]
is a TCP/IP-based pub-sub protocol with similar properties
that is widely used in Internet of Things applications.

B. Autoware

Autoware is an open-source software for autonomous vehi-
cles based on ROS. Autoware.Auto2 is the current generation
of Autoware, and is a successor to the previous version called
Autoware.AI. Autoware.Auto is based on ROS 2 and features
a modular design, consisting of a variety of nodes that are
capable of perception, localization, planning, and control.

Fig. 13 shows the collection of nodes that are present
in Autoware.Auto release 1.0 (black edges portray pub-sub
“topics,” blue edges delineate actions, and red edges illustrate
services). These nodes together form a pipeline that is capable
of “autonomous valet parking,” where the vehicle can go and
park autonomously anywhere in a parking lot.

Autoware.Auto’s modular design enables execution on a va-
riety of platforms in a distributed manner. For communication
among distributed nodes, Autoware.Auto mainly uses pub-sub
messages and asynchronous callbacks. The distributed design
of Autoware.Auto allows concurrent execution of various tasks
on dedicated hardware; however, this also makes it challenging
to achieve reproducible system behavior.

C. LINGUA FRANCA

LINGUA FRANCA (LF) is an open-source polyglot coor-
dination language that emphasizes deterministic interaction
between concurrent reactive components called reactors [7],
[25], [8]. We have chosen LF as the basis for our work because
of its deterministic semantics. Events in LF are tagged and can
be sent from a port of one reactor to the port of another. Every
event occurs at a logical tag g drawn from a totally-ordered
set G and every reactor processes events in tag order. Each
tag is a pair of numbers, a timestamp t ∈ T and a microstep
m ∈ N (to realize superdense time [26]). A timestamp t ∈ T
represents a measure of time.

1https://www.ros.org/
2https://www.autoware.org/autoware-auto/
3Produced based on output from the rqt-graph ROS package.

2

Fig. 1: Architecture of Autoware.Auto 1.0 capable of Autonomous Vehicle Parking (AVP).

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

target L;
reactor class {

input name:type
output name:type
state name:type(init)
timer name(offset, period)
logical action(offset) name:type
physical action name:type
...
reaction(trigger, ...) source, ... -> effect, ...
{=

... code in language L ...

=}
... more reactions ...

}
...
main reactor {

instance = new class()
...
instance.name -> instance.name after delay
...

}

Fig. 2: Structure of LF programs in target language L

The functionality of a reactor is encoded by its reactions,
which are triggered by events and can produce new ones. LF is
polyglot in the sense that reactions are written in one of several
target languages (currently C, C++, Python, TypeScript, or
Rust), and an LF program is compiled into a program in that
target language.

The LF syntax is mostly concerned with the deﬁnition
of reactor classes, their instantiation, and their composition.
Lst. 2 sketches an LF program written in a ﬁctional target
language L (keywords are in bold, metavariables are italicized),
showing a reactor deﬁnition (Ln. 2) with various kinds of
class members, and a main reactor (Ln. 17) showing syntax
for instantiating and composing reactor instances. Inputs and
outputs allow one reactor instance to be connected to another
(Ln. 20). The -> operator on Ln. 20, which creates a logical
connection between an upstream port and a downstream one,
has an optional after clause that adds a delay offset to the tag
of relayed events. Alternatively, the ∼> operator can be used
to specify a physical connection, which discards event tags
and replaces them with a measurement of physical time. State
variables are local to a reactor instance, and can be read or
written to by any reaction of that instance. Timers generate
periodic events, while actions provide sporadic events that are
scheduled dynamically through a runtime API. Asynchronous
external events can be injected into the system with the use of

3

a physical action. The events of a physical action are assigned
a tag based on a measurement of physical time.

Time is a ﬁrst-class data type in LF, and application code
has access to both the logical clock (tags) and the physical
clock on the local platform. By default, logical time “chases”
physical time in a program execution, so that events with a
logical time t occur close to (but never before) physical time
T = t. Reactions may have deadlines that guide an earliest
deadline ﬁrst (EDF) scheduler. Application code can provide
a deadline handler, fault-handling code to be invoked instead
of a regular reaction when a deadline is violated.

Execution of an LF program must ensure that each reactor
reacts to events (input messages, timer events, and actions) in
tag order. If two events have the same tag, they are logically
simultaneous, and no reaction at that tag can observe one
event as present and the other as absent. Moreover, along any
communication channel between reactors and for any timer or
action, there can be at most one event with any given tag g.
Our main contribution in this paper is to extend these
thereby preserving
properties across a distributed system,
determinism. We extend LF to allow top-level reactors to be-
come independent processes (federates), deployable to remote
machines. This extension includes handling of a multiplicity
of physical clocks and permitting federates to independently
advance their local tags. Our extensions enable all existing
valid LF programs that use the C target (where reactions are
written in C/C++) or the Python target to be transparently
converted to federated programs. It also supports speciﬁcation
of fault handling code that is invoked when communication
latencies increase enough to make it impossible to enforce
the consistency requirements speciﬁed in the program while
keeping the program responsive.

III. MOTIVATIONAL CASE STUDY: AUTOWARE.AUTO

To demonstrate the degree to which pub-sub-based com-
munication methods can undermine conﬁdence in safety-
critical applications, we consider Autoware.Auto, a full-stack
autonomous driving framework that uses ROS.

A. Node-to-Node Inconsistency

Consider

the subsystem of Autoware.Auto depicted in
Fig. 3a. The State Report topic includes state information
about
including the current gear. Consecutive
messages published by the LGSVL Interface (the interface to

the vehicle,

LocalizationLidarPerceptionControlVehiclePlanningNDT MapPublisherP2D NDT Localizer  NDT Maptf2Robot State PublisherFront LidarFilter&TransformRear LidarFilter&TransformPoint Cloud FusionFiltered PointsFiltered PointsVoxel GridDownsamplerPoints FusedDownsampledFused  Ray GroundClassifierPoints FusedEuclidean ClusterDetectorPointsNonground  Off MapObstacles Filter  Lidar BoundingBoxesObject CollisionEstimatorFiltered Lidar  Bounding BoxesMPCControllerBehaviorPlannerGlobalPlannerGPSLGSVLInterfaceVehicleKinematicStateState ReportVehicleKinematicStateVehicleKinematicStateCANVehicle CommandModifyTrajectoryState CommandTrajectoryModifyTrajectoryLanePlannerAction:RequestParkingPlannerActions:Request Global PathAction:FeedbackAction:Feedback(a) Communication pattern.

(b) Periodic tests with wide gaps.

(c) Periodic tests with small gaps.

Fig. 3: Node-to-node inconsistency in Autoware.Auto.

the vehicle, a simulator in our case) on this topic are always
delivered in the order they were sent. For example, if the gear
is reported as “drive” in one message and as “reverse” in
the next, then the Behavior Planner will see that the vehicle
has been in the “drive” gear and subsequently switched to
“reverse.” This order is crucial for the Behavior Planner to
correctly keep track of the current state of the vehicle and to
make accurate safety-critical decisions in general.

Notice that the LGSVL Interface node also publishes mes-
sages on the Vehicle Kinematic State topic, which includes
information such as the current velocity (positive for forward
movement and negative for reverse) and the wheel angle of the
vehicle, among other details. However, messages published
on these distinct topics may be delivered in arbitrary order;
the pub-sub semantics provides no built-in means to order
messages across the two independent message ﬂows.

The Behavior Planner simply stores the gear information
upon receiving the State Report. Upon receiving the Vehicle
Kinematic State, it then uses the stored gear data to calculate
and publish a new trajectory for the vehicle. The output of
the Behavior Planner depends on the order in which these
messages arrive. Imagine the following test scenario, where the
LGSVL Interface publishes messages in the following order:
(1) “drive” on State Report; (2) Vehicle Kinematic State with a
positive velocity; (3) “reverse” on State Report; and (4) Vehicle
Kinematic State with a negative velocity.

The Behavior Planner can observe the produced message
sequence in any permutation that preserves the ordering of
messages within the same topic, which we conﬁrmed em-
pirically. Fig. 3b shows the incidence of observed message
sequence permutations as a percentage of the total number of
complete message sequences published. In our experiments,
we varied the rate at which the LGSVL Interface node pro-
duces sequences of (1) → (2) → (3) → (4). The period after
which the sequence repeats is shown on the y-axis. We chose
periods that correspond to the frequency at which sensors
typically produce data in the real world. We ran each test
3×105 times on an Ubuntu PC with an AMD Ryzen 5800X
CPU and 32GB of DDR4 memory running ROS 2 Foxy.4

One would normally expect the message sequence observed
at the Behavior Planner to be the same as it was published by

4The DDS runtime used here is Eclipse Cyclone. Other DDS implemen-
tations could give more repeatable behavior. However, our goal is not just
repeatable behavior, but a deterministic semantics.

the LGSVL Interface. It would only be reasonable to expect
the vehicle interface and the planner to agree on the state
trajectory of the vehicle. However, disagreement about the
order of events can lead to inconsistent views on the state
of the system, and can make the outcome of tests misleading.
Consider the sequence (1) → (2) → (4) → (3), which can
be observed under minimal stress on the ROS 2 infrastructure.
In this permutation of the published message sequence, the
vehicle is in the “drive” gear (1) and reports a positive velocity
(2). However, before the state of gear can be updated to
“reverse” (3), the Behavior Planner will receive a negative
velocity state (4). This state has to be treated by the application
developer either as a genuine fault condition, or be dismissed
as an inconsequential inconsistency introduced by the ROS
framework. In the former case, tests will transiently fail. In
the latter case, tests will not fail, but this comes at the cost of
not being able to detect a dangerous system state that might
occur while the system is operating.

Even if the dangerous state is treated as a legitimate error,
without any stress on ROS, a test that checks for this condition
will pass 99.8% of the time. This can lull the application
designer into a false sense of conﬁdence in the safety of
the application. Of course, infrequent errors due to message
sequence permutations can be made more frequent by applying
stress on the ROS 2 framework. We also ran our test scenario
under stress, depicted in Fig. 3c with periods smaller than 1
millisecond. This test puts pressure on the underlying message
delivery infrastructure by ﬂooding it with messages.5 Under
stress, the ROS framework buckles, and delivers messages
across topics in a multitude of seemingly unpredictable per-
mutations. While the expected observation order is still in the
majority, the error rate is two orders of magnitude higher than
in Fig. 3b. We also observe messages being dropped due to
limited buffering capacity in the DDS framework, causing odd
message patterns such as (3) → (1) → (2) → (3).

One solution to the node-to-node inconsistency problem is
to consolidate topics. But this severely impairs the modularity
of the application and the reusability of components. In the
case of Autoware.Auto, the State Report gets published in a su-
perclass of the LGSVL Interface, which publishes the Vehicle
Kinematic State. The two topics have different uses, and their
data are sourced from different subsystems entirely (the CAN
bus and GPS/GNSS, respectively). Another solution would be

5This method is somewhat inspired by chaos engineering techniques [27].

4

VehiclePlanningLGSVLInterfaceBehaviorPlannerState ReportVehicleKinematicState 0 0.05 0.1 0.15 0.21ms10ms30ms100ms 0 150 300 450 600Cropped at 0.2%% of total# out of 300k testsPeriod(1)->(2)->(3)->(4)(2)->(1)->(4)->(3)(1)->(2)->(4)->(3)(2)->(1)->(3)->(4) 0 20 40 601ns1us10us100us% of totalPeriod(1)->(2)->(3)->(4)(4)->(1)->(2)->(3)(3)->(4)->(1)->(2)(2)->(3)->(4)->(1)(2)->(1)->(4)->(3)(3)->(1)->(2)->(3)OtherConsider the subsystem shown in Fig. 4b. Whenever the Be-
havior Planner decides that it is time to brake and start backing
up into a parking space, it notiﬁes the MPC Controller with
a Trajectory that tells it to stop the vehicle. Simultaneously,
the Behavior Planner sends the LGSVL Interface a “reverse
gear” State Command. It would certainly be dangerous if
the vehicle interface were to attempt to change gear before
reaching a full stop. To prevent a serious error like this, the
Autoware.Auto designers use a complicated state machine in
the implementation of the LGSVL Interface that ensures that
all Vehicle Command messages are handled before performing
the gear change requested in the State Command. In our
opinion,
this needlessly clutters the application logic with
error-prone code. It would be much better if the underlying
framework would automatically provide proper alignment.

IV. DESIGN OF XRONOS

The issues raised in Sec. III can be automatically avoided
if the semantics of LF are honored in a multi-process or
there are several non-trivial
distributed setting. However,
challenges involved in making a transition from the cur-
rently implemented multi-threaded LF runtimes to multi-
process/distributed ones. In this section, we discuss the design
of our main innovation, the Xronos federated runtime for
LF. We establish a transparent workﬂow that takes ordinary
LF programs and turns them into federated ones, in which
reactors are mapped to processes that can be deployed to
remote machines, jointly constituting a federation.

A. Startup and Shutdown

Startup: In LF, there exists a start tag gs such that all
logical timelines for all reactors of a program start at gs.
In non-federated LF implementations, gs is set to a reading
of a shared physical clock. This approach does not extend
well to a distributed system without access to a shared clock,
where clock synchronization is imperfect and communication
delays have to be accounted for. Instead, we implement a
distributed consensus in which, during a startup stage, a
central coordinator called the RunTime Infrastructure (RTI, the
name adopted from HLA [22]) is started. Each federate ﬁrst
synchronizes its physical clock with the RTI (see Sec. V-C for
details). Next, each federate reports a reading from its physical
clock and shares it with the RTI. The RTI collects a list Φg
of proposed start times and chooses max(Φg) + d as the start
time for all federates, where d is a value chosen automatically
based on measured communication delay and federation size.
Shutdown: A deterministic shutdown is especially important
in safety-critical applications where external factors might
require a timely, but deterministic shutdown of the system
(think of an advanced autopilot system being turned off). Since
a federation is already running, the shutdown problem can be
formulated as a logical consensus. If a federate decides to
stop the execution, it ceases to advance its tag and notiﬁes the
RTI. The RTI will then ask other federates for an appropriate
ﬁnal tag (which in turn causes the other federates to pause
processing events). After receiving all tags, the RTI picks the

(a)

(b)

Fig. 4: Multi-node inconsistency in Autoware.Auto.

to explicitly tag each message (e.g., using sequence numbers)
within the LGSVL Interface and do manual alignment. This
approach, however, carries signiﬁcant overhead and is error-
prone. We propose to solve the problem in the communication
layer, where it can be done more robustly and efﬁciently while
keeping the application simple and modular.

B. Multi-node Inconsistency

The asynchrony of pub-sub communication poses further
challenges. Consider another subsystem of Autoware.Auto,
depicted in Fig. 4a. In it,
the MPC Controller produces
a Vehicle Command (not depicted) on the basis of several
inputs, including a Trajectory and a Vehicle Kinematic State.
Upon receiving any input, the MPC Controller will try to
recompute the Vehicle Command. The problem of multi-node
inconsistency concerns the alignment of the observed inputs.
To compute an accurate Vehicle Command, all inputs must
relate to the same frame of reference [28], but due to the
asynchronous communication between nodes, they typically
do not.

In our experimental setup, the Behavior Planner takes an
average of 75 milliseconds to compute a new Trajectory upon
receiving a Vehicle Kinematic State. The Vehicle Kinematic State
is produced with a frequency of 30 Hz, resulting, on average,
in 2.48 messages being received at the MPC Controller for
each Trajectory. As a consequence, the latest Vehicle Kinematic
State is always newer than the latest Trajectory. Therefore, the
MPC Controller attempts to transform the last received Vehicle
Kinematic State to the frame of reference of the last received
Trajectory, a costly operation that could be eliminated if proper
alignment was ensured by an underlying framework.

One could argue that

transforming inputs to match the
desired frame of reference is a satisfactory solution [28].
While this may be true for variables such as velocity, which
only marginally change over the span of a few seconds, it
is not the case for variables that encode modes and thus are
subject to discrete changes. The presence of these kinds of
variables raises potential for “mode confusion” [29] in the
control system, a situation where the system executes invalid
logic with respect to its current mode. We found that such
scenario can also occur in Autoware.Auto.

5

VehiclePlanningControlLGSVLInterfaceBehaviorPlannerVehicleKinematicStateMPCControllerVehicleKinematicStateTrajectoryVehiclePlanningControlLGSVLInterfaceBehaviorPlannerStateCommandMPCControllerTrajectory   VehicleCommand maximum tag and sends it to all federates, which will then
process all remaining events up to and including this tag.

B. Advancing Logical Time

To honor the semantics of reactors, each federate must
see events in tag order and not start processing events with
a tag larger than events that could later be produced by
upstream federates. In ordinary LF programs, all reactors
must ﬁnish processing events with tag g before any reactor
may start processing an event with tag g(cid:48) > g. Such a
barrier synchronization would be very costly in a federated
implementation. We instead have realized two more loosely
coupled coordination methods: our centralized and decentral-
ized coordinators.

1) Centralized Coordination: For each federate f , the RTI

keeps track of the following information:
1. LTCf : Logical Tag Complete. A record of the most
recently received tag from federate f notifying the RTI
that it has completed all computation and sent all outgoing
messages with that tag or less. The value of LTCf is initially
−∞, a special tag smaller than all other tags.

2. NETf : Next Event Tag. This is the most recently received
tag from a federate f reporting the earliest event in its event
queue. If a federate’s event queue is empty, it will send
∞, a special maximal tag. If the RTI has not received a
NET message from the federate, the value is −∞.

3. TAGf : Tag Advance Grant. This is the tag most recently
sent to federate f to permit f to advance its current tag to
TAGf . The value of TAGf is initially −∞.

Each federate f conveys the ﬁrst two quantities to the RTI
in a Next Message Request (NMRf ) message at the start of
execution and at the completion of each tag. The payload of
the message is (LTCf , NETf ), where LTCf < NETf . The
very ﬁrst NMR message will carry LTCf = −∞ because no
event has been processed. The TAGf is sent by the RTI to
each federate f to permit it to advance its tag. At all times,
the RTI and the federates may have only partial information,
and messages conveying these quantities may be in ﬂight and
not have been recorded.

When the RTI receives an NMR message from federate f ,
it may respond with a Tag Advance Grant (TAGf ) message,
possibly not immediately. It may also send TAG messages
to downstream federates. Let D(f ) be the set of immediate
downstream federates (those that receive messages directly
from f ), and let U (f ) be the set of immediate upstream
federates (those that send messages directly to f ). Suppose
the RTI receives an NMR message from f with payload
(LTCf , NETf ). First, it updates its data structure to register
these two new values. Then it does two things:
1. For all d ∈ D(f ), let

gd = min
u∈U (d)

(LTCu + aud),

where aud is the minimum “after” annotation on connec-
tions from federate u to d. If gd > TAGd, then the RTI
sets TAGd = gd and sends a TAG message to federate d
with payload gd. This tells the downstream federate d that

it may advance its current tag to gd and process any events
or inputs that it has received with that tag or any earlier tag.
The RTI is sure to have forwarded all messages to d with
tags equal to or less than gd because all federates upstream
of d, including f , have reported completion of execution at
logical tag gd or larger.

2. The RTI determines whether it can grant a tag advance
to f , in which case it will send it a TAG message. If
TAGf ≥ NETf , then there is nothing to do because the RTI
has already granted such a tag advance to f . Otherwise, if
TAGf < NETf , then the RTI needs to compute the Earliest
Incoming Message Tag (EIMTf ) for federate f . This is
deﬁned as follows:

EIMTf = min
u∈U (f )

(min(EIMTu, NETu) + auf ).

If U (f ) = ∅, then we deﬁne EIMTf = ∞. Note that
because EIMT appears on both sides, this is a system of
equations. As long as the logical delays satisfy auf ≥ 0, it
is easy to prove that there is a maximal solution (which may
have ∞ for some federates), even in the presence of cycles,
and we have implemented a simple iterative procedure for
ﬁnding that maximal solution. If EIMTf ≥ NETf , then let
TAGf = NETf and send a TAG message to f with payload
NETf . Otherwise, the RTI does not reply. The federate will
have to wait until it gets a TAG as a consequence of (1).
When a federate f sends to the RTI an NMR with payload

(LTCf , NETf ), it is stating that:

• It will never again send a message with tag g ≤ LTCf , and
it would be an error for it to receive any incoming message
with such a tag (such a message is said to be tardy, and a
main task of the centralized controller is to guarantee that
no tardy messages occur).

• Until the federate receives a TAGf > LTCf , it will not
send an outgoing message with tag g < NETf . Once it
receives a TAGf > LTCf , then it can advance its current
tag to TAGf and send a message with tag g ≥ TAGf (it
can be TAGf + af d, where af d is the “after” delay on the
connection to d).

If federate f has no physical actions, then NETf is simply
the tag of the earliest event on its event queue, or ∞ if the
event queue is empty. However, if f has physical actions, it
can make no such promise until Tf > NETf , where Tf is
the current physical time at federate f , since an event might
appear with timestamp Tf . In this case, in order to permit
downstream federates to advance time, federate f needs to
repeatedly send NMR messages as its physical time advances.
Here there is an inherent tradeoff between network bandwidth
and time granularity. These messages need to be frequent, but
not too frequent.

Fig. 5 shows the sequence of messages under centralized
coordination that ensures alignment for the sub-architecture
of Autoware in Fig. 4a. The MPC Controller will not
process the received vehicle kinematic state message Vg until
it receives a TAG(g) message from the RTI. The RTI in
turn ensures that the MPC Controller receives the TAG(g)

6

NET(g)

Vg

LTC(g)

NET(g)

Safe to process Vg and Tg

NET(g)

LTC(g)

Tg

TAG(g)

TAG(g)

TAG(g)

LGSVL

MPC
Controller

Behavior
Planner

RTI

Fig. 5: Message sequence under centralized coordination that
ensures alignment of vehicle kinematic state Vg and trajectory
Tg for the architecture of Fig. 4a. NMR messages are split
into LTC and NET messages for the sake of clarity.

message only after it has received the trajectory message Tg,
allowing the MPC Controller to process Vg and Tg logically
simultaneously at tag g.

2) Decentralized Coordination: We give here a realization

of PTIDES [17], [30] with substantial extensions.

For each federate fi, we will derive Si ∈ T, a safe-to-
process (STP) offset. Given Si, a federate will not be able
to advance to any tag g = (t, m) until its physical time Ti
satisﬁes

Ti ≥ t + Si.
(1)
where Ti is a measurement of physical time on the platform
executing fi. If fi includes any physical action, then Si ≥ 0.
Otherwise, it can be positive, negative, or zero. The purpose
of Si is to ensure that by the time the physical clock satisﬁes
(1), all events that may have originated on some other federate
with tags less than g have previously arrived at fi. This ensures
that events can be processed in tag order.

Next, we discuss the assumptions needed to calculate Si.

a) Launch Deadline: Assume that a reaction r invoked
at tag g in fi is able to send a message to another federate
fj. It does this simply by writing to an output port of fi.
We assume that r is invoked before physical time Ti exceeds
t + Dij, where Dij is the launch deadline. As mentioned in
Sec. II-C, violation of such a deadline can be detected using
existing semantics of LF. It is worth noting that our runtime
interprets a lower deadline as having a higher priority. Also
note that it must be true that Dij ≥ Si because no reaction
in LF can be invoked at tag g = (t, m) before physical time
Ti ≥ t + Si.

b) Launch Lag: We deﬁne the launch lag as

Lij = Dij − Si.
(2)
The launch lag Lij represents the physical time that elapses
between the start of execution of the step at tag g and the
invocation of reaction r. It must include the execution time of
any reaction(s) that are invoked before r at this tag plus any
scheduling overhead, and hence it must be nonnegative. The
launch lag may be zero if this overhead is negligible.

c) Communication latency bound: We also need to as-
sume a bound Nij on communication (either inter-process or
network) latency. This is deﬁned as the maximum physical
time (by the clock at federate fi) that passes between the

invocation of the reaction r that sends the message and the
receipt of the message at federate fj. This time includes not
just the propagation time through the communication channel
(sockets in our case), but also the execution time of r and any
overhead in the network stack.

d) Clock synchronization error bound: Finally, we also
need to assume a bound Eij on the clock synchronization error
between federates fi and fj. That is, the physical clocks of fi
and fj do not drift apart by more than Eij.
Calculating the Safe To Process Offset. Assume that fi ∈ F
sends an event to federate fj ∈ F with tag g = (t, m). With
the aforementioned bounds, fj will receive the message before
fi’s physical clock reaches t + Dij + Nij and before its own
physical clock reaches t + Dij + Nij + Eij.

The connection from fi

to fj may alter the tag (using
the after keyword), incrementing it by aij ≥ 0. Since the
event is launched by a reaction invoked at t, the event with
timestamp t(cid:48) = t+aij will be received by fj before its physical
clock exceeds t+Dij +Nij +Eij. Equivalently, fj receives an
event with tag g(cid:48) = (t(cid:48), m(cid:48)) before its physical clock exceeds
Tj = t(cid:48) + Dij + Nij + Eij − aij.
(3)
If aij is large enough, it can even be true that Tj < t(cid:48), in
which case, at physical time Tj, the receiving federate will
have received all messages with timestamps t ≤ Tj.

We can now generalize to any number of federates. First,
let αij be the minimum delay (speciﬁed using after) over
all connections from fi to fj. Let

Mji = max(0, Dij + Nij + Eij − αij).
(4)
Here, if i = j, Eij = 0, and Nij is a bound on the latency
with which the federate sends messages to itself (this could
be zero as well). If there is no connection from fi to fj, then
αij = ∞. Mji represents a relative safe-to-process offset for
fj with respect to fi.

We can now write down an expression for the safe-to-

process offset Sj,

Sj = max
i∈F

(Mji).

(5)

However, from (2), we have

Dij = Si + Lij,
so the safe to process offsets appear on both sides of this
equation. Therefore, we have a system of equations that must
be solved. Rewriting (4) to make this explicit, we get,
Mji = max(0, Si + Lij + Nij + Eij − αij).

To simplify this, let

and write

Xij = Lij + Nij + Eij − αij

Mji = max(0, Si + Xij).

We can now write
Sj = max
i∈F

(Mji) = max(0, max
i∈F

(Si + Xji)).

(6)

We now have n equations in n unknowns.
Max-Plus Formulation. Equation (6) can be written com-
pactly and solved easily using a Max-Plus formulation [31].
Let X be a matrix where the i, j-th element (row i, column

7

j) is Xij. Let S be a column vector where the i-th element is
Si. Then note that in Max-Plus algebra,

J = XS
is a column vector where the j-th element is maxi∈F (Si +
Xji). Let O be a column vector where the j-th element is 0.
Then note that (6) can be rewritten in Max-Plus algebra as
S = O ⊕ J = O ⊕ XS.
(7)
From [31] (Theorem 3.17), if every cycle of the matrix X has
weight less than zero, the unique solution of this equation is
S = X∗O,

where the Kleene star is (Theorem 3.20)
X∗ = I ⊕ X ⊕ X2 ⊕ · · ·

and that this reduces to

X∗ = I ⊕ X ⊕ · · · ⊕ Xn−1,
where n is the number of federates. If there are cycles with
zero weight, but all weights are nonpositive, then there is a
solution and a unique minimal solution.

The requirement that the cycle weights be nonpositive is

Fig. 6: Xronos and LF: compilation process.

Python, TypeScript, and Rust as targets. Any LF program
using the C/C++ or Python targets can run on Xronos. The
functionality for this gets enabled simply by changing the
main keyword to federated. Support for Xronos in the
TypeScript target is under development. Fig. 6 illustrates the
integration between Xronos and LF as well as the steps
involved in constructing a federated program.

present in the original PTIDES.

A. Additions to the Language

For a federate j, Xronos will optimistically replace Xij with
Tj − t for a given tag g = (t, m) if the status of events for all
connections from i are known at g.

C. Fault Handling

Without exception, the correctness of a system implementa-
tion is predicated on certain assumptions. For example, oper-
ating conditions, such as temperature or humidity, need to be
within a certain range. Typically, violation of the assumptions
leads to a fault condition. In LF, with its sophisticated model
of time, special attention is given to faults related to broken
assumptions regarding time. Speciﬁcally, one can associate a
deadline with a particular reaction, along with a fault handler.
The fault handler gets invoked instead of the reaction in case
it is not ready to execute by the speciﬁed deadline. When
the centralized coordinator is used in Xronos, the deadline
fault handler can be used by the user to detect and react
if the underlying communication channel is partitioned or
assumptions about execution times are violated.

When the decentralized coordinator is used in Xronos,
there is another type of time-related fault
that can occur.
Speciﬁcally, a message from one federate to another could
be tardy, meaning it arrives after the receiving federate has
already advanced to a tag greater than the incoming message.
This can only happen, of course, if the asserted STP offset was
not large enough to account for upstream delays, meaning that
an STP violation occurred. To allow the user to react to such a
violation, we added a new syntax to LF for the speciﬁcation of
the STP, along with a handler to be invoked when it is violated,
emulating the style of the existing deadline construct.

V. IMPLEMENTATION

Xronos is a runtime implementation for LINGUA FRANCA,
an open-source coordination language built on the basis of the
reactor model. At the time of writing, LF supports C, C++,

The example LF code in Fig. 7 highlights our additions
target properties,
to the LF grammar. We added several
which are meant to conﬁgure a program and its execution
environment in various ways. For instance, we added an option
to select a coordination type, an option to create Docker
images, and several conﬁguration options pertaining to the
clock synchronization mechanism provided by Xronos. We
further add the serializer keyword to the language to allow
the programmer to specify a serialization mechanism for data
exchanged between federates. The at keyword was introduced
for mapping federates to speciﬁc hosts. Finally, we added a
reserved reactor parameter called stp_offset that can be
used to specify an STP offset, as well as syntax for deﬁning
STP violation handlers.

B. Federated Runtime

The federated runtime is written in C and uses sockets
for communication. The entire runtime is approximately 8100
lines of code. Xronos works in conjunction with our modiﬁed
C and Python code generators that automatically treat reactor
instances in the top-level reactor as federates and map them
to independent processes. The code generators also transform
connections between federates such that the communication
gets routed through a socket connection using special sender
and receiver reactions. Depending on the coordination type,
communication will either happen directly between federates
(decentralized) or through the RTI (centralized). For logical
connections, the receiver reaction is triggered by a logical
action that is scheduled by the federated runtime upon message
receipt. The tag of the event that triggers the receiver reaction
is determined by the tag that is sent along with the incoming
message. For physical connections, the receiver reaction is
triggered by a physical action. The tag associated with the
triggering event is thus based on physical time as measured by
the receiver. Hence, messages sent along physical connections

8

ModifiedlfcCompiler.docker*.lff1f2fnAutowarelibsrclrclcppCode generatedfor each federateRun/distribute scriptsOptionalLibrariesbinf1XronOsbinf2binfnBinaries foreach federateDocker images3

4

5

6

7

8

9

10

11

22

23

24

25

1 target C {
2

coordination: decentralized,
clock-sync: on,
clock-sync-options: {

// Or "centralized"
// Turn on runtime clock sync

period: 5 msec, // Clock sync period
trials: 10,
attenuation: 10 // Stabilize clock sync
... other parameters

// Num. of msgs used in clock sync

},
docker: true,
timeout: 10 secs,
tracing: true

12
13 }
14 reactor Source {
output out:int
15
reaction(startup) -> out {=

16

// Produce a docker image
// Distributed timeout
// Distributed tracing

17

SET(out, 1);

// Send data over socket

=}

18
19 }
20 reactor Destination (stp_offset: time(7 usec)) {
21

input in:int;
reaction(in) {=

info_print("%d", out); // Print the received data

=} STP {=

// Handle input that violates tag order

=}

26
27 }
28 federated reactor Example at user1@host1 {
29

at user2@host2
c = new Source()
d = new Destination() at user3@host3
c.out -> d.in serializer "native" // Or ros2, proto

30

31
32 }

Fig. 7: An example federated program.

do not carry a tag. This type of connection is the closest
equivalent to the connections used in ROS and MQTT.

C. Physical Clock Synchronization

Xronos can work with clock synchronization based on NTP
(default in most systems) or the higher precision PTP [32],
[33]. We also provide a built-in clock synchronization imple-
mentation realized using the technique of Geng et al. [34].
This ensures that federated execution initializes as expected
even if the host system lacks proper conﬁguration or means
of clock synchronization. Xronos also optionally corrects for
clock drift during execution.

D. Reusing MQTT and ROS Libraries and Nodes

LF is already designed to seamlessly incorporate (legacy)
target code and reuse existing libraries. To ease the transition
to Xronos, we have prepared a number of examples6 that
demonstrate how to integrate existing ROS or MQTT appli-
cations into Xronos-based federations. We also added cmake
build support to the C target of our modiﬁed lfc compiler
and introduced target properties for customizing the cmake
build conﬁguration to allow for more convenient integration
with the colcon build system used by ROS 2.

Fig. 8: Relationship between
STP offset and error rate un-
der decentralized coordina-
tion for the sub-architecture
of Fig. 3a.

Fig. 9: Cumulative distribu-
tion function (CDF) of end-
to-end latencies for calculat-
ing a new lane trajectory in
Autoware.Auto under ROS 2
and Xronos.

data to the byte-array that
is sent over the socket. This
method of serialization can be dangerous and only works
if the data type is Plain Old Data (POD) [35] and if the
memory format and endianness are the same for the sender
and receiver. Nonetheless, this method is fast, and thus useful
the pickle7
for some embedded applications. In Python,
module is used to perform native serialization. The proto
serializer uses Protobufs,8 where libproto or its variants are
automatically used to serialize and deserialize data. As with
any proto-based serialization, the data format is expected to
be stored in a .proto ﬁle which is then compiled and made
accessible in the program. Lastly, ros2 uses the serialization
framework of rclcpp.9 Only ROS 2 messages, services, and
actions are supported as a data format. This functionality is
particularly important for porting legacy code from ROS 2
to Xronos, enabling developers to reuse ROS 2 message and
service data types (e.g., PointCloud2).

F. Deployment

We added support for a deployment strategy based on
Docker [36] by generating Docker images for each federate,
if requested, and a Docker compose ﬁle that simpliﬁes the
task of starting the federation, even in a hybrid heterogeneous
system.

VI. EVALUATION

We ﬁrst discuss our port of Autoware.Auto and measure
the error rates under Xronos for the scenarios that were
discussed in Sec. III. We also compare the end-to-end latency
of Autoware.Auto in ROS 2 against our port
to Xronos.
Subsequently, we supplement our performance evaluations
with a set of microbenchmarks to measure the impact of
different subsystems in Xronos, such as the built-in Protobufs
serialization mechanism, on maximum throughput.

E. Serialization

A. Autoware.Auto

To send data from one federate to another, the data must
be converted to a byte stream (it must be serialized) and
converted back to the appropriate data type at the receiver
(it must be deserialized). Xronos currently supports three
serialization schemes: native, proto, and ros2. In C, the
native technique directly copies the memory map of the

6In a private repository to keep anonymity.

We ported Autoware.Auto release 1.0 to Xronos, including
its autonomous valet parking functionality. We use our port to
measure error rates under both realistic and unrealistic periods
for the sub-architecture of Fig. 3a. First, we veriﬁed that

7https://docs.python.org/3/library/pickle.html
8https://developers.google.com/protocol-buffers/
9https://github.com/ros2/rclcpp

9

 0 10 20 30 40 0 2 4 6 8 10 12 14 16 18 20Errors out of 300kSTP Oﬀset (in seconds)1ns1us10us100us1ms10ms30ms100ms 0 0.2 0.4 0.6 0.8 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8CDFLatency (in seconds)ROS 2DecentralizedCentralizedPhysicalcentralized coordination yields zero errors over 300k test runs.
With decentralized coordination, errors become possible, but
we found no errors for periods down to one millisecond (with
an STP offset of 5 ms). With periods below one millisecond,
errors begin to appear, but, unlike the ROS 2 implementa-
tion, they are detectable (as STP violations). Moreover, by
increasing the STP offset, the error rate can be reduced. We
found, however, that with periods of 100 µs and below, the
STP offset had to become quite large (several seconds) for the
error rate to drop to zero, as shown in Fig. 8. Such periods
are unrealistic for this application. For applications with such
periods, more specialized hardware and networking may be
required to eliminate errors.

We would expect that such an improvement in reliability
would incur a cost, and, indeed, under centralized coordi-
is signiﬁcant for this application. Under
nation,
decentralized coordination, we ﬁnd that the cost in end-to-end
latency is considerably lower.

the cost

To evaluate the cost for this application, we measured the
end-to-end latency from sensor measurements (at the interface
to the LGSVL simulator) through the production of a new
trajectory in the lane planner to the construction of a vehicle
command to feed back to the LGSVL simulator. First, we
note that our evaluation still involves two unported ROS 2
components, the LGSVL simulator itself and the built-in tf2
library, which performs frame transformations. These com-
ponents are not part of Autoware.Auto, but they are needed
to construct a full simulation. Also, note that the end-to-end
latency includes not just communication overhead, but also the
computations needed for planning. The goal of the experiment
is to compare the overall behavior of Xronos compared to ROS
2 for a realistic application.

In Fig. 9, we have plotted a cumulative distribution function

(CDF) as a function of latency.

Under centralized coordination, the latency is much higher,
suggesting that centralized coordination would not be a good
choice for this application. This is not surprising because, with
centralized coordination, multiple control messages need to be
exchanged for transmission of each useful data message, and
all communication between federates goes through the RTI.
The microbenchmarks, which we consider next, also show
that the communication overhead of centralized coordination
is quite high, suggesting that this strategy would only be
acceptable if occasional errors cannot be mitigated.

However, under decentralized coordination, the cost in end
to end latency becomes considerably more manageable, but not
negligible. Nonetheless, we conjecture that for safety-critical
distributed embedded applications, the overall reduction in the
error rate could justify this cost.

To further clarify the source of the additional overhead in
Xronos, we measured the end-to-end latency of our port using
all physical connections, where, as previously explained in
Sec. II-C, the inherent determinism of LF is sacriﬁced. As
depicted in Fig. 9, the resulting latency roughly matches that
of the decentralized coordination. This suggests that the added
logic in decentralized coordination that ensures determinism

Fig. 10: Microbenchmark communication patterns.

Fig. 11: Comparison of maximum throughput (averaged over
30 runs) for MQTT, ROS, and Xronos (decentralized).

Fig. 12: Maximum throughput (in Mbps) of Xronos under
centralized and decentralized coordination.

is not the main source of the added latency. We leave further
optimizations of the Xronos runtime as future work.

B. Microbenchmarks

To supplement our results, we consider three distinct com-
munication patterns, shown in Fig. 10, inspired by patterns
introduced by Lee and Lohstroh [37], to evaluate the through-
put of Xronos as a middleware. We develop microbenchmarks
for these patterns in Xronos, ROS 2, and MQTT and measure
the maximum throughput, comparing our decentralized coor-
dinator against the state-of-the-art to establish a baseline for
comparison. We also measure the throughput of Xronos under
the centralized coordinator and measure the impact of various
features in Xronos on throughput. We run our tests on three
platforms, a desktop PC (the same system used to obtain the
results in Sec. III), an NVIDIA Jetson AGX, and a hybrid
scenario where nodes/federates are distributed across the PC
and the AGX.

Comparison with baseline: Fig. 11 shows the maximum
throughput (in Mbps) under Xronos using decentralized coor-
dination compared against ROS 2 and MQTT. For this series
of comparisons, the data size is 4 bytes and the STP offset in
Xronos is statically calculated for each benchmark (all in the
order of a few milliseconds). These measurements are obtained
by forcing each benchmark to ﬂood the network and measuring
the total physical time at the receiver for the total messages
received after running the test for 10 seconds (logical in the
case of Xronos and physical for ROS 2 and MQTT, giving an
advantage to the latter). Each test is run at least 30 times. For
these microbenchmarks, we observe that Xronos can provide

10

 0 0.5 1 1.5 2-1-0.5 0 0.5 1 1.5 2 2.5 3PCAGXPC + AGX0.02.04.06.08.0XronosROS2MQTTThroughput (Mbps)Scenario S10.00.51.01.52.02.5XronosROS2MQTTThroughput (Mbps)Scenario S20.00.51.01.52.0XronosROS2MQTTThroughput (Mbps)Scenario S3 0 0.5 1 1.5 2-1-0.5 0 0.5 1 1.5 2 2.5 3PCAGXPC + AGX0.02.04.06.08.0CentralizedDecentralizedThroughput (Mbps)Scenario S10.00.51.01.52.02.5CentralizedDecentralizedThroughput (Mbps)Scenario S20.00.51.01.52.0CentralizedDecentralizedThroughput (Mbps)Scenario S3TABLE I: Maximum throughput (in Mbps) of physical con-
nections under different coordinations.

TABLE III: Maximum throughput with and without clock
synchronization for S1 (in Mbps).

Coordination

S1-PC

S2-PC

S3-PC

Coordination

Clock Sync Mode Max. Throughput

Decentralized
Centralized

8.16 Mbps
5.81 Mbps

2.35 Mbps
1.34 Mbps

2.66 Mbps
1.54 Mbps

TABLE II: Maximum throughput for each supported serializa-
tion method, measured over 30 runs, for S1 (in Mbps).

Serialization

Avg

Max

Min

Std

Native
ROS 2
Proto

4.04 Mbps
1.19 Mbps
2.50 Mbps

4.27 Mbps
1.22 Mbps
2.57 Mbps

3.88 Mbps
1.17 Mbps
2.41 Mbps

0.11 Mbps
0.2 Mbps
0.05 Mbps

a higher throughput than ROS 2. Xronos also has a higher
throughput than MQTT for S1 and S2, but falls short in S3
due to the strict alignment requirement at the Sink.

Centralized vs. Decentralized: While the centralized co-
ordinator imposes a strict global ordering of events, it does
so with additional overhead both in terms of extra control
messages and inserting the RTI as a bottleneck for message
communication. Our decentralized coordination mechanism
instead relies on assumptions about the latencies in the system
to ensure correctness. Fig. 12 shows the comparison between
our coordinators. The results show that our decentralized coor-
dinator performs better overall, particularly for the challenging
pattern of S3.

Physical vs. Logical: Not all parts of the system need a
strict tag ordering in order to function well. To allow ﬂexibility,
we have also added support for physical connections across
federates, as explained in Sec. V-B. This communication
mechanism is the closest match to ROS 2 or MQTT that
Xronos offers. Results are shown in Table I. We ﬁnd that
physical connections for these microbenchmarks have up to
7x higher throughput compared to logical connections.

Overhead of Serialization: A beneﬁt of Xronos is that
the serialization method used is ﬂexible. Table. II shows
the overhead per message for the three currently supported
serialization methods. We ﬁnd that while our native method
allows for the highest throughput, Protobufs serialization is
also substantially more performant than ROS 2 serialization.
Overhead of Clock Synchronization: We measured the
throughput of Xronos with and without the built-in clock
synchronization mechanism. The results, shown in Table. III,

Decentralized

Centralized

Disabled

Startup-only

Enabled

Disabled

Startup-only

Enabled

10.14 Mbps

8.16 Mbps

7.54 Mbps

6.48 Mbps

5.81 Mbps

5.26 Mbps

indicate that the impact on throughput of our built-in clock
synchronization is relatively low. We also found that the clock
synchronization error in our method is generally below 10
microseconds.

Federation Scalability: Finally, we tested the scalability of
Xronos when number of nodes and message size is increased.
The trends that we observed are depicted in Fig. 13. We ﬁnd
that throughput roughly scales down linearly with the number
of nodes and message size.

VII. RELATED WORK

Distributed coordination is a decades-old research topic.
Classic solutions include Chandy and Misra [20], Jeffer-
son [38], and HLA [22]. PTIDES [30] offers a decentralized
approach,
later independently developed by Google Span-
ner [18]. Loosely time-triggered architectures (LTTA) [39],
[40] provides a programming model built upon the strictly
synchronous TTA model [41], generalizing to distributed en-
vironments. System-Level LET (SL LET) [42] extends Logical
Execution Time (LET) [10] to distributed settings by relaxing
the synchronization requirements. The reactor model can also
be viewed as a generalization of the LET principle, enabling
combinations of logical execution time with the zero execution
time semantics of synchronous languages while preserving the
ability to precisely control the timing of interactions with the
physical environment.

Runtime systems are further developed based on these coor-
dination schemes. The PRISE project implements a distributed
real-time simulation system based on HLA [43]. Ptolemy-HLA
framework [44] provides distributed simulation for cyber-
physical systems. TipFrame [45] and LETT [46] are examples
of LET-based frameworks. DEAR [47] is a discrete-event
framework for AUTOSAR [48], an emerging industry standard
for automotive software based on reactors. Our work has
overlaps with all of these, as any system solution would,
but contributes novel extensions to distributed coordination
mechanisms that preserve determinacy under clearly-stated
assumptions, provide for detection of violations of the as-
sumptions, and provide for handling of the resulting fault
conditions.

VIII. CONCLUSION AND FUTURE WORK

Fig. 13: Scalability of throughput (in Mbps) in Xronos for central-
ized and decentralized coordination for S1.

We have shown that nondeterminism in widely-used pub-
sub communication frameworks is potentially dangerous and

11

 0 2 4 6 8220100Throughput (in Mbps)Number of Federates4KB40KB512KBDecentralized 0 0.2 0.4 0.6220100Throughput (in Mbps)Number of Federates4KB40KB512KBCentralizedcan lower the conﬁdence in safety-critical distributed embed-
ded applications.

We have extended the LINGUA FRANCA coordination lan-
guage to support federations while preserving its deterministic
semantics, and we have shown that the cost in performance
is manageable. We give two distributed coordination mech-
anisms: a centralized one that emphasizes preserving the
program semantics even in the presence of network failures,
and a decentralized one that emphasizes being able to continue
to make forward progress in the presence of network failures.
We provide a mechanism for specifying fault handlers that are
triggered by violations of safe-to-process bounds.

Xronos is under active development. There are two main
areas for future work: (1) Federate recovery, where if a feder-
ate fails, the federation would have the capacity to continue to
operate, and (2) Mutation, where the structure of the federation
would be allowed to change at runtime.

REFERENCES

[1] M. Quigley, K. Conley, B. Gerkey, J. Faust, T. Foote, J. Leibs,
R. Wheeler, A. Y. Ng et al., “Ros: An open-source robot operating
system,” in ICRA workshop on open source software, vol. 3. Kobe,
Japan, 2009, p. 5.

[2] A. Stanford-Clark and U. Hunkeler, “Mq telemetry transport (mqtt),”
Online]. http://mqtt. org. Accessed September, vol. 22, p. 2013, 1999.
[3] R. A. Light, “Mosquitto: server and client implementation of the mqtt
protocol,” Journal of Open Source Software, vol. 2, no. 13, p. 265, 2017.
[4] S. Kato, S. Tokunaga, Y. Maruyama, S. Maeda, M. Hirabayashi, Y. Kit-
sukawa, A. Monrroy, T. Ando, Y. Fujii, and T. Azumi, “Autoware on
board: Enabling autonomous vehicles with embedded systems,” in 2018
ACM/IEEE 9th International Conference on Cyber-Physical Systems
(ICCPS).

IEEE, 2018, pp. 287–296.

[5] I. Malavolta, G. Lewis, B. Schmerl, P. Lago, and D. Garlan, “How do
you architect your robots? state of the practice and guidelines for ros-
based systems,” in 2020 IEEE/ACM 42nd International Conference on
Software Engineering: Software Engineering in Practice (ICSE-SEIP).
IEEE, 2020, pp. 31–40.

[6] B. Mishra and A. Kertesz, “The use of MQTT in M2M and IoT systems:

A survey,” IEEE Access, vol. 8, pp. 201 071–201 086, 2020.

[7] M. Lohstroh, C. Menard, S. Bateni, and E. A. Lee, “Toward a lingua
franca for deterministic concurrent systems,” ACM Transactions on Em-
bedded Computing Systems (TECS), Special Issue on FDL’19, vol. 20,
no. 4, p. Article 36, May 2021.

[8] M. Lohstroh, “Reactors: A deterministic model of concurrent com-
putation for reactive systems,” Ph.D. dissertation, EECS Department,
University of California, Berkeley, Dec 2020. [Online]. Available: http:
//www2.eecs.berkeley.edu/Pubs/TechRpts/2020/EECS-2020-235.html
[9] G. A. Agha, “Abstracting interaction patterns: A programming paradigm
for open distributed systems,” in Formal Methods for Open Object-based
Distributed Systems, IFIP Transactions, E. N. Stefani and J.-B., Eds.
Chapman and Hall, 1997, Conference Proceedings.

[10] C. M. Kirsch and A. Sokolova, “The logical execution time paradigm,”
in Advances in Real-Time Systems. Springer, 2012, pp. 103–120.
[11] A. Benveniste and G. Berry, “The synchronous approach to reactive
and real-time systems,” Proceedings of the IEEE, vol. 79, no. 9, pp.
1270–1282, 1991.

[12] E. A. Lee, J. Liu, L. Muliadi, and H. Zheng, “Discrete-event models,”
in System Design, Modeling, and Simulation using Ptolemy II, C. Ptole-
maeus, Ed. Ptolemy.org, 2014.

[13] B. P. Zeigler, Y. Moon, D. Kim, and G. Ball, “The devs environment
for high-performance modeling and simulation,” IEEE Computational
Science and Engineering, vol. 4, no. 3, pp. 61–71, 1997.

[14] S. Liao, S. Tjiang, and R. Gupta, “An efﬁcient

implementation of
reactivity for modeling hardware in the Scenic design environment,”
in Design Automation Conference.
ACM, Inc., 1997, Conference
Proceedings.

[15] L. Lo Bello and W. Steiner, “A perspective on ieee time-sensitive
networking for industrial communication and automation systems,”
Proceedings of the IEEE, vol. 107, no. 6, pp. 1094–1120, 2019.
[16] E. Brewer, “CAP twelve years later: How the ”rules” have changed,”

IEEE Computer, vol. 45, no. 2, pp. 23–29, February 2012.

[17] Y. Zhao, E. A. Lee, and J. Liu, “A programming model for time-
synchronized distributed real-time systems,” in Real-Time and Embed-
ded Technology and Applications Symposium (RTAS).
IEEE, 2007,
Conference Proceedings, pp. 259 – 268.

[18] J. C. Corbett, J. Dean, M. Epstein, A. Fikes, C. Frost, J. Furman,
S. Ghemawat, A. Gubarev, C. Heiser, P. Hochschild, W. Hsieh, S. Kan-
thak, E. Kogan, H. Li, A. Lloyd, S. Melnik, D. Mwaura, D. Nagle,
S. Quinlan, R. Rao, L. Rolig, Y. Saito, M. Szymaniak, C. Taylor,
R. Wang, and D. Woodford, “Spanner: Google’s globally-distributed
database,” in OSDI, 2012, Conference Proceedings.

[19] L. Lamport, “Using time instead of timeout for fault-tolerant distributed
systems,” ACM Transactions on Programming Languages and Systems,
vol. 6, no. 2, pp. 254–280, 1984.

[20] K. M. Chandy and J. Misra, “Distributed simulation: A case study
in design and veriﬁcation of distributed programs,” IEEE Trans. on
Software Engineering, vol. 5, no. 5, pp. 440–452, 1979.

[21] J. Misra, “Distributed discrete event simulation,” ACM Computing

Surveys, vol. 18, no. 1, pp. 39–65, 1986.

[22] J. S. Dahmann, R. M. Fujimoto, and R. M. Weatherly, “The department
of defense high level architecture,” in Proceedings of the 29th conference
on Winter simulation, 1997, pp. 142–149.

[23] D. Thomas, W. Woodall,

“Next-generation
ROS: Building on DDS,” in ROSCon Chicago 2014. Mountain
View, CA: Open Robotics, sep 2014.
[Online]. Available: https:
//vimeo.com/106992622

and E. Fernandez,

[24] O. Standard, “MQTT Version 5.0,” Retrieved June, vol. 22, p. 2020,

2019.

[25] M. Lohstroh, ´I. ´Incer Romeo, A. Goens, P. Derler, J. Castrillon, E. A.
Lee, and A. Sangiovanni-Vincentelli, “Reactors: A deterministic model
for composable reactive systems,” in 8th International Workshop on
Model-Based Design of Cyber Physical Systems (CyPhy’19), vol. LNCS
11971. Springer-Verlag, 2019, Conference Proceedings, p. 27.
[26] Z. Manna and A. Pnueli, “Verifying hybrid systems,” in Hybrid Systems,

vol. LNCS 736, 1993, Conference Proceedings, pp. 4–35.

[27] C. Rosenthal and N. Jones, Chaos engineering.

O’Reilly Media,

Incorporated, 2020, vol. 1005.

[28] T. Foote, “tf: The transform library,” in 2013 IEEE Conference on
Technologies for Practical Robot Applications (TePRA), 2013, pp. 1–
6.

[29] G. L¨uttgen and V. Carreno, “Analyzing mode confusion via model
checking,” in International SPIN Workshop on Model Checking of
Software. Springer, 1999, pp. 120–135.

[30] J. Zou, S. Matic, E. A. Lee, T. H. Feng, and P. Derler, “Execution
strategies for Ptides, a programming model for distributed embedded
systems,” in Real-Time and Embedded Technology and Applications
Symposium (RTAS).

IEEE, 2009, Conference Proceedings.

[31] F. Baccelli, G. Cohen, G. J. Olster, and J. P. Quadrat, Synchronization
and Linearity, An Algebra for Discrete Event Systems. New York:
Wiley, 1992.

[32] J. C. Eidson, Measurement, Control, and Communication Using IEEE

1588. Springer, 2006.

[33] J. C. Eidson and K. B. Stanton, “Timing in cyber-physical systems:
the last inch problem,” in IEEE International Symposium on Precision
Clock Synchronization for Measurement, Control, and Communication
(ISPCS).
IEEE, 2015, Conference Proceedings, pp. 19–24.

[34] Y. Geng, S. Liu, Z. Yin, A. Naik, B. Prabhakar, M. Rosenblum, and
A. Vahdat, “Exploiting a natural network effect for scalable, ﬁne-grained
clock synchronization,” in 15th USENIX Symposium on Networked
Systems Design and Implementation (NSDI 18), 2018, pp. 81–94.
[35] P. E. Black et al., Dictionary of algorithms and data structures.

Addison-Wesley, 1998.

[36] D. Merkel et al., “Docker: lightweight linux containers for consistent
development and deployment,” Linux journal, vol. 2014, no. 239, p. 2,
2014.

[37] E. A. Lee and M. Lohstroh, “Time for all programs, not just real-time
programs,” in International Symposium on Leveraging Applications of
Formal Methods. Springer, 2021, pp. 213–232.

[38] D. Jefferson, “Virtual time,” ACM Trans. Programming Languages and

Systems, vol. 7, no. 3, pp. 404–425, 1985.

12

[39] G. Baudart, A. Benveniste, and T. Bourke, “Loosely time-triggered
architectures: improvements and comparisons,” ACM Transactions on
Embedded Computing Systems (TECS), vol. 15, no. 4, pp. 1–26, 2016.
[40] S. Tripakis, C. Pinello, A. Benveniste, S.-V. A., P. Caspi, and M. Di Na-
tale, “Implementing synchronous models on loosely time triggered
architectures,” IEEE Transactions on Computers, vol. 57, no. 10, pp.
1300–1314, 2008.

[41] H. Kopetz and G. Bauer, “The time-triggered architecture,” Proceedings

of the IEEE, vol. 91, no. 1, pp. 112–126, 2003.

[42] R. Ernst, L. Ahrendts, and K.-B. Gemlau, “System level let: Mastering
cause-effect chains in distributed systems,” in IECON 2018-44th Annual
Conference of the IEEE Industrial Electronics Society.
IEEE, 2018,
pp. 4084–4089.

[43] J.-B. Chaudron, D. Saussi´e, P. Siron, and M. Adelantado, “Real-time
distributed simulations in an hla framework: Application to aircraft
simulation,” Simulation, vol. 90, no. 6, pp. 627–643, 2014.

[44] J. Cardoso and P. Siron, “Ptolemy-hla: A cyber-physical system dis-
Springer,

tributed simulation framework,” in Principles of Modeling.
2018, pp. 122–142.

[45] B. Wan, H. Luo, K. Zhou, X. Li, C. Wang, X. Chen, and X. Zhou, “A
time-aware programming framework for constructing predictable real-
time systems,” in 2017 IEEE 19th International Conference on High
Performance Computing and Communications; IEEE 15th International
Conference on Smart City; IEEE 3rd International Conference on Data
Science and Systems (HPCC/SmartCity/DSS).
IEEE, 2017, pp. 578–
585.

[46] W. Baron, A. Arestova, C. Sippl, K.-S. Hielscher, and R. German, “Lett:
An execution model for distributed real-time systems,” in 2021 IEEE
94th Vehicular Technology Conference (VTC2021-Fall).
IEEE, 2021,
pp. 1–7.

[47] C. Menard, A. Goens, M. Lohstroh, and J. Castrillon, “Achieving
derterminism in adaptive AUTOSAR,” in Design, Automation and Test
in Europe (DATE 20), Grenoble, France, March 2020.

[48] S. F¨urst, J. M¨ossinger, S. Bunzel, T. Weber, F. Kirschke-Biller,
P. Heitk¨amper, G. Kinkelin, K. Nishikawa, and K. Lange, “Autosar–a
worldwide standard is on the road,” in 14th International VDI Congress
Electronic Systems for Vehicles, Baden-Baden, vol. 62, 2009, p. 5.

13

