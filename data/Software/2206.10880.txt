2
2
0
2

n
u
J

2
2

]
h
p
-
t
n
a
u
q
[

1
v
0
8
8
0
1
.
6
0
2
2
:
v
i
X
r
a

VeriQBench: A Benchmark for Multiple Types of
Quantum Circuits

Kean Chen1,3, Wang Fang1,3, Ji Guan1,∗, Xin Hong4, Mingyu
Huang1,3, Junyi Liu1,3, Qisheng Wang2, and Mingsheng Ying1,2,†

1State Key Laboratory of Computer Science, Institute of Software,
Chinese Academy of Sciences, China
2Department of Computer Science and Technology, Tsinghua
University, China
3The University of Chinese Academy of Sciences, China
4Centre for Quantum Software and Information, University of
Technology Sydney, Australia

June 23, 2022

Abstract

In this paper, we introduce VeriQBench — an open source benchmark
for quantum circuits. It oﬀers high-level quantum circuit abstractions of
various circuit types, including: 1) combinational, 2) dynamic, 3) sequen-
tial, and 4) variational quantum circuits, which cover almost all existing
types of quantum circuits in the literature. Meanwhile, VeriQBench is
a versatile benchmark which can be used in verifying quantum software
for diﬀerent applications, as is evidenced by the existing works includ-
ing quantum circuit veriﬁcation (e.g., equivalence checking [Hon+21a;
WLY21] and model checking [Yin21]), simulation (e.g., fault simulation),
testing (e.g., test pattern generation [CY22]) and debugging (e.g., run-
time assertions [Li+20b]). All the circuits are described in OpenQASM
and are validated on Qiskit and QCOR simulators. With the hope that
it can be used by other researchers, VeriQBench is released at: https://
github.com/Veri-Q/Benchmark.

∗guanj@ios.ac.cn
†yingms@ios.ac.cn

1

 
 
 
 
 
 
Contents

1 Introduction

2 Combinational Quantum Circuits

2.1 Quantum Algorithms . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 Bernstein-Vazirani Algorithm . . . . . . . . . . . . . . . .
2.1.2 Quantum Fourier Transform . . . . . . . . . . . . . . . .
2.1.3 Quantum Phase Estimation . . . . . . . . . . . . . . . . .
2.1.4 Grover’s Algorithm . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
2.1.5 Quantum Adder
2.2 Reversible Circuits . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Qubit Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Random Circuits . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1 Random Cliﬀord Circuits
. . . . . . . . . . . . . . . . . .
2.4.2 Quantum Volume . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . .
2.4.3

Supremacy Circuits

3 Dynamic Quantum Circuits

3.1 Quantum Teleportation . . . . . . . . . . . . . . . . . . . . . . .
3.2 Semiclassical Fourier Transform . . . . . . . . . . . . . . . . . . .
Iterative Phase Estimation . . . . . . . . . . . . . . . . . . . . . .
3.3
3.4 Quantum Error correction . . . . . . . . . . . . . . . . . . . . . .
3.5 State Injection . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4 Sequential Quantum Circuits

4.1 Repeat-Until-Success . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Quantum Walk . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Classical Control

5 Variational Quantum Circuits

5.1 Variational Quantum Eigensolver . . . . . . . . . . . . . . . . . .

6 Validation

7 Example Applications

1 Introduction

2

4
4
4
6
7
8
10
11
13
14
14
15
17

17
18
18
19
21
22

23
23
25
26

27
27

28

29

Quantum circuits are the basic components in quantum computing. With the
rapid development in hardware implementation of quantum circuits in experi-
ments, there also emerge many approaches to characterise and evaluate quan-
tum computing models by simulating and comparing quantum circuits, such as
quantum noise eﬀects [Liu+21], variational circuit training [Bro+20] and (ap-
proximate) equivalence checking [VMH07; YM10; BW20b; BW20a; Hon+21a].
In particular, quantifying the practical performance of some carefully chosen

2

quantum circuits is a common way to evaluate the performance of quantum
devices, especially in the current NISQ (Noisy Intermediate-Scale Quantum)
era, where quantum noise from the surrounding environment is unavoidable.
These quantum circuits are generated from diﬀerent ﬁelds, such as random
protocols [Aru+19], quantum algorithms [NC02; Chi17], including variational
quantum algorithms [Per+14; FGG14; Had+19; Til+21; Cer+21] and classi-
cal reversible circuits [AD16]. Subsequently, in the recent years, diverse quan-
tum circuit benchmarks have been proposed with diﬀerent evaluation metrics,
such as QASMBench [Li+20a], quantum LINPACK benchmark [DL21], Super-
marQ [Tom+22] and the quantum volume protocol [Cro+19].

In this paper, we present a new quantum circuit benchmark, called VeriQBench,

for a diﬀerent purpose. It was initially designed for testing our own QDA (De-
sign Automation for Quantum Computing) tool series VeriQ. But we hope it
can be applicable in various ﬁelds, given the following features:

• Diversity: It includes the most commonly-used quantum circuits, namely
combinational quantum circuits, dynamic quantum circuits, sequential
quantum circuits, and variational quantum circuits. These circuits cover
all types of quantum circuits existing in the literature. Furthermore, the
quantum circuits in our benchmark are diverse in structure (e.g. the layout
of 2-qubit circuits) and complexity (e.g. circuit size and depth).

• Scalability: The circuit scales in our benchmark vary widely, ranging
from 2 qubits up to > 50 qubits, which are divided into three classes, i.e.
small-scale (< 20 qubits), medium-scale (20
50 qubits) and large-scale
(> 50 qubits).

−

• Easy-to-use: All the circuits in our benchmark are described using the
OpenQASM quantum assembly language and provided as “.qasm” ﬁles.
Furthermore, most of them can be converted to other representations such
as Q#, PyQuil, Cirq, etc. through q-convert tool, which is available online:
http://quantum-circuit.com/qconvert.

• Evolvement: For most of the quantum circuits in our benchmark, we
provide a series of scripts for users to generate quantum circuits of an
arbitrary number of qubits. This ensures that our benchmark can evolve
as the available circuit scales of quantum technologies increase.

Our benchmark can work with diﬀerent evaluation metrics to verify quantum
software — comparing and assessing the eﬀectiveness and eﬃciency of quan-
tum and classical (simulation) algorithms designed for quantum circuits. The
circuits in our benchmark are collected from researches in a variety of ﬁelds,
including equivalence checking [Hon+21a; WLY21], circuit testing [CY22] and
circuit optimizing [AMM14; Nam+18]. This improves the diversity and prac-
tical feasibility of the benchmark. On this basis, the circuit types and scales
are further extended and standardized to form a scalable and evolvable bench-
mark. To demonstrate the validity, all quantum circuits in our benchmark are
implemented and validated by Qiskit [Qis] — an open source SDK for quantum

3

computation, and QCOR [Ngu+20] — a programming language and a compiler
for the heterogeneous quantum-classical model of computation.

This paper is organised as follows: we start from the basic type of quantum
circuits, namely combinational quantum circuits in Section 2, which includes
some fundamental quantum algorithms, reversible circuits, qubit mapping and
random quantum circuits. Then dynamic, sequential and variational quantum
circuits are presented in Sections 3, 4 and 5, respectively.
In Section 6, we
validate all quantum circuits on Qiskit and QCOR. In the last section, we discuss
some example applications of the benchmarks. Of course, we hope that this
benchmark can be used by other researchers. The benchmark VeriQBench is
released at: https://github.com/Veri-Q/Benchmark.

2 Combinational Quantum Circuits

The most basic and commonly used type of quantum circuit is the combina-
tional quantum circuit, with examples including some of the popular quantum
algorithms such as the Bernstein-Vazirani algorithm, quantum Fourier trans-
form and quantum phase estimation. In our benchmark, we include the most
commonly used combinational circuits and divide them into four categories:
quantum algorithms, reversible circuits, circuits for qubit mapping, and ran-
dom quantum circuits.

2.1 Quantum Algorithms

2.1.1 Bernstein-Vazirani Algorithm

= s0x0 ⊕

Description. Bernstein-Vazirani algorithm [BV97] is an algorithm that can be
used to ﬁnd the hidden string s given a boolean function f (x), where f (x) =
s, x
snxn. For the classical algorithm, it normally needs
h
i
(n) times to complete this task using a bit-by-bit inquiring method. But, it
O
only needs
(1) times using the Bernstein-Vazirani algorithm suppose that you
are given an orcle Os, where Os |

s1x1 ⊕ · · · ⊕

y
.
i
to change the
0
i · · · |
. Then, applying the oracle, the state will

⊕
First, apply a series of Hadamard gates to state
0

state to

f (x)

1
i

i |

i |

i |

O

=

x

x

x

1

0

y

i

i

|

|

|

1
√2n
1
√2n

2n
1
−
x=0 |
2n
P
1
x=0 (
−

i ⊗
1)h

s,x

i−|
√2
x

become
i−|
√2
P
gates, and the ﬁnal state will change to
n qubits gives the value of s.

i ⊗

−

|

i

|

0

1
i

. Finally, apply a series of Hadamard
. At the end, measuring the ﬁrst
s
i

i |

1

|

0

to

For s = 101 and s = 111, the corresponding circuits are shown in Figure 1.
In these two circuits, an X gate is added at the last qubit to change the initial
, and the CN OT gates are used for implementing the oracle.
state from
1
i
For these circuits, setting input state
and measuring at the end will
give the hidden string s.
OpenQASM Code. The following gives the description of the circuit for
s = 101 using OpenQASM 2.0.

i · · · |

0

0

i

i

|

|

|

4

•

H
H
H
X H

H
H
H
H

•

(a)

✌✌✌
✌✌✌
✌✌✌

•

H
H
H
X H

H
H
H
H

•

•

(b)

✌✌✌
✌✌✌
✌✌✌

Figure 1: Two examples of the Bernstein-Vazirani algorithm, where (a) s = 101
and (b) s = 111.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [4];
creg c [4];
h q [0];
h q [1];
h q [2];
x q [3];
h q [3];
cx q [0] , q [3];
cx q [2] , q [3];
h q [0];
h q [1];
h q [2];
h q [3];

Generation Script. The circuit for arbitrary hidden string s can be generated
using the following code. For this circuit, the number of qubits is expected to
be one more than the length of the hidden string.

def gen_bv ( qubits , hiddenString ):

cir = QuantumCircui t ( qubits , qubits )

for i in range ( qubits - 1):

cir . h ( i )

cir . x ( qubits - 1)
cir . h ( qubits - 1)
hiddenString = list ( hiddenString )
for i in range ( len ( hiddenString )):
if hiddenString [ i ] == ” 1 ” :

cir . cx (i , qubits - 1)

for i in range ( qubits ):

cir . h ( i )

return cir . qasm ()

5

2.1.2 Quantum Fourier Transform

Description. Quantum Fourier transform [NC02] is a commonly used algo-
rithm in quantum computing. It turns an input state
to its Fourier trans-
form.

j

i

|

QF T

=

j

|

i

N

1

−

1
√N

e2πijk/N

.

k

|

i

Xk=0
The circuit for 3-qubit quantum Fourier transform is shown in Figure 2. It
is easy to observe from this circuit that the quantum Fourier transform can be
implemented using a series of Hadamard gates and a set of Control-Rk gates,
where

Rk =

(cid:20)

0

1
0 e2πi/2k

.

(cid:21)

|

j1i
j2i
|
j3i

|

H

•
R2

•

R3

H

•
R2 H

0

0

0

|

|

|

i

i

i

1

i

|
1

i

+ e0.j1j2j3

+ e0.j2j3

+ e0.j3

|

|
1

i

Figure 2: Quantum circuit for Fourier Transform.

OpenQASM Code. The OpenQASM 2.0 description of this circuit is shown
below.

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [3];
creg c [3];
h q [0];
cu1 ( pi /2) q [0] , q [1];
cu1 ( pi /4) q [0] , q [2];
h q [1];
cu1 ( pi /2) q [1] , q [2];
h q [2];

Generation Script. The circuit for arbitrary number of qubits quantum
Fourier transform can be generated using the following code. This code ex-
tended the circuit shown in Figure 2 to arbitrary qubits.

def gen_qft ( qubits ):

cir = QuantumCircui t ( qubits , qubits )
for q in range ( qubits ):

cir . h ( q )
for tar in range ( q + 1 , qubits ):

theta = np . pi / 2 ** ( tar - q )
cir . cu1 ( theta , q , tar )

return cir . qasm ()

6

1
2
3
4
5
6
7
8
9
10

1
2
3
4
5
6
7
8
9
10

2.1.3 Quantum Phase Estimation

Description. Phase estimation [NC02] is an algorithm that can be used to
estimate the phase ϕ in an eigenvalue of a unitary U , where U
ψ
for some

. The corresponding circuit is shown in Figure 3.
i

= e2πiϕ

ψ

ψ

i

i

|

|

|

0

|

i

0

i

|
φ
i

|

H

H

/

•

U 2

•
U

H

•
R†2 H

✌✌✌
✌✌✌

Figure 3: Quantum circuit for phase estimation.

The process can be conducted by ﬁrst constructing an superposition state
and then applying a series of controlled-U 2k
gates. Then, an inverse quantum
Fourier transform can be used to extract the corresponding value of the phase.
OpenQASM Code. The following gives the OpenQASM 2.0 description of
this circuit. In this circuit, we suppose that U is a single qubit diagonal matrix

U =

1
0
(cid:20)

0
e2πiϕ(cid:21)

,

and here we take ϕ = 1/1024 as an example.

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [4];
creg c [4];
h q [0];
h q [1];
h q [2];
cu1 ( pi /512) q [2] , q [3];
cu1 ( pi /256) q [1] , q [3];
cu1 ( pi /128) q [0] , q [3];
h q [0];
cu1 ( - pi /2) q [0] , q [1];
cu1 ( - pi /4) q [0] , q [2];
h q [1];
cu1 ( - pi /2) q [1] , q [2];
h q [2];

Generation Script. The python code for generating the circuits is as follows.
You can assign the number of qubits of the circuit and also the phase ϕ. Then,
running this circuit will give the estimation of the phase to a precision restricted
by the number of qubits.

def gen_pe ( qubits , the_phase ):

cir = QuantumCircui t ( qubits +1 , qubits +1)

7

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

1
2
3

4
5
6
7
8
9
10
11
12
13
14
15
16

for q in range ( qubits ):

cir . h ( q )

for q in range ( qubits -1 , -1 , -1):

cir . cu1 ( np . pi * the_phase *2**( qubits - q ) ,q , qubits )

for q in range ( qubits ):

cir . h ( q )
for tar in range ( q +1 , qubits ):

cir . cu1 ( - np . pi /(2**( tar - q )) , q , tar )

return cir . qasm ()

2.1.4 Grover’s Algorithm

Description. Grover’s algorithm [Gro96] is one of the most commonly used
algorithms in quantum computing to search the solution of an integer function.
, then
,
x
i

Suppose you are given an oracle O such that O
x
i
|
initialise the state to be the equal superposition state
|
and iteratively apply the Grover operator

x
i
1
N
−
x=0 |

= (
ψ

−
= 1

1)f (x)

N 1/2

i

|

P

i h
and ﬁnally measure all the qubits, you will get a solution of the function f (x)
with a probability close to 1.

| −

|

G = (2

ψ

ψ

I)O,

x2,
Figure 4 gives an example of the Grover’s algorithm. Here, f (x) = x1 ·
running this circuit and measuring at the end will obtain 11, which is the solution
of this function.

H

H

H

•

•

H X

•

X H

H X H

H X H

H

Figure 4: An example of Grover’s algorithm. Here, f (x) is a 2-bit function and
f (x) = x1 ·

x2.

OpenQASM Code. The OpenQASM 2.0 description of this circuit is as fol-
lows.

1
2
3
4
5
6
7

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [3];
creg c [3];
h q [0];
h q [1];
h q [2];

8

8
9
10
11
12
13
14
15
16
17
18
19
20

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

ccx q [0] , q [1] , q [2];
h q [0];
h q [1];
x q [0];
x q [1];
h q [1];
cx q [0] , q [1];
h q [1];
x q [0];
x q [1];
h q [0];
h q [1];
h q [2];

Generation Script. The python code for generating circuits for arbitrary
qubits Grover’s search is as follows. In this code, you can assign the number of
n. Then there will be
qubits n of the search space, where the solution is
one qubit serving as oracle workspace and n
2 qubits as ancilla qubits. Thus,
1 qubits and the Cn(X) will be decomposed
the circuit will totally have 2n
−
to a series of CCX (i.e. Toﬀoli) gates using the ancilla qubits.

⊗
i

−

1

|

def gen_grover ( qubits , r ):

cir = QuantumCircui t (2 * qubits - 1)
# add H
for q in range ( qubits ):

cir . h ( q )

cir . h (2 * qubits - 2)
for k in range ( r ):

# add t o f o l l i
cir . ccx (0 , 1 , qubits )
for q in range (2 , qubits ):

cir . ccx (q , q + qubits - 2 , q + qubits - 1)

for q in range ( qubits - 2 , 1 , -1):

cir . ccx (q , q + qubits - 2 , q + qubits - 1)

if qubits > 2:

cir . ccx (0 , 1 , qubits )
# add H

for q in range ( qubits ):

cir . h ( q )

# add X
for q in range ( qubits ):

cir . x ( q )
cir . h ( qubits - 1)
if qubits == 2:

cir . cx (0 , 1)

elif qubits == 3:

cir . ccx (0 , 1 , 2)

else :

cir . ccx (0 , 1 , qubits )
for q in range (2 , qubits - 2):

9

30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46

cir . ccx (q , q + qubits - 2 , q + qubits - 1)

cir . ccx ( qubits - 2 , 2 * qubits - 4 , qubits - 1)

for q in range ( qubits - 3 , 1 , -1):

cir . ccx (q , q + qubits - 2 , q + qubits - 1)

if qubits > 2:

cir . ccx (0 , 1 , qubits )

cir . h ( qubits - 1)
# add X
for q in range ( qubits ):

cir . x ( q )
# add H

for q in range ( qubits ):

cir . h ( q )

cir . h (2 * qubits - 2)
return cir . qasm ()

2.1.5 Quantum Adder

Description. Quantum adder is a quantum circuit to implement add operation
on two bit strings. For example, if we compute ’2+3=5’, then we represent the
input string as ’010’ and ’011’, and the expected output bit string is ’101’. The
implementation of the quantum adder circuit is illustrated as follows, and the
additional qubits are used to store the carry bit [CS08].
OpenQASM Code. The OpenQASM description of 3-bit adder circuit is
shown as follows.

q0 :

q1 :

q2 :

q3 :

q4 :

q5 :

q6 :

q7 :

q8 :

q9 :

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

Figure 5: Circuit of 3-bit adder

10

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [10];
ccx q [1] , q [2] , q [3];
cx q [1] , q [2];
ccx q [4] , q [5] , q [6];
cx q [4] , q [5];
ccx q [7] , q [8] , q [9];
cx q [7] , q [8];
ccx q [0] , q [2] , q [3];
ccx q [3] , q [5] , q [6];
ccx q [6] , q [8] , q [9];
cx q [0] , q [2];
cx q [3] , q [5];
cx q [6] , q [8];

Generation Script. The python code for generating an adder circuit is as
follows, the function takes the number of qubits as the input and outputs the
OpenQASM text of the circuit.

def header ( nq ):
str = ” ”
str += ”OPENQASM 2 . 0 ; \ n”
str += ” i n c l u d e \” q e l i b 1 . i n c \ ” ; \ n”
str += ” q r e g q[%d ] ; \ n” %( nq )
return str

def carry_gate ( s ):

str = ’ ’
str += ” c c x q[%d ] , q[%d ] , q[%d ] ; \ n” %( s +1 , s +2 , s +3)
str += ” cx q[%d ] , q[%d ] ; \ n” %( s +1 , s +2)
return str

def adder ( numq ):

str = ” // Adder w i t h %d q u b i t s
str += header (3* numq +1)
for i in range ( numq ):

str += carry_gate (3* i )

for i in range ( numq ):

i n p u t . \ n” % numq

str += ” c c x q[%d ] , q [%d ] , q[%d ] ; \ n” %(3* i , 3* i +2 , 3* i +3)

for i in range ( numq ):

str += ” cx q[%d ] , q[%d ] ; \ n” %(3* i , 3* i +2)

return str

2.2 Reversible Circuits

Description. A classical n-bit reversible gate is a bijective mapping f from
n of n-bit data onto itself. Thus the vector of input states can
the set
always be reconstructed from the vector of output states. A combinational
logic circuit is reversible if it only contains reversible gates and has no fan-out.

0, 1

{

}

11

Classical reversible circuits may be implemented in quantum technology and
have important applications in many quantum algorithms such as the arithmetic
module of Shor’s Algorithm and the oracle of Grover’s Algorithm.

We collect the classical reversible circuits in the Reversible Logic Synthesis

Benchmarks Page [Mas]. The following are the elementary gates they used:

Deﬁnition 1 A generalized Toﬀoli gate TOF(x1, x2, ..., xn; xn+1) is a gate
which maps a Boolean pattern (x1, x2, ..., xn, xn+1) to (x1, x2, ..., xn, xn+1 +
x1x2 . . . xn), where ”+” is a modula-2 addition.

Examples:

1. NOT gate is a TOF(
∅

; a) gate.

2. CNOT gate is a TOF(a; b) gate.

3. Original Toﬀoli gate is a TOF(a, b; c).

Deﬁnition 2 A generalized Fredkin gate FRE(x1, x2, ..., xn; xn+1, xn+2) is
a gate which maps Boolean pattern (x1, x2, ..., xn, xn+1, xn+2) to (x1, x2, ...,
xn, xn+2, xn+1) if and only if Boolean product x1x2 . . . xn = 1, otherwise the
pattern is unchanged.

Examples:

1. SWAP gate is a FRE(
∅

; a, b) gate.

2. Original Fredkin gate is a FRE(a; b, c) gate.

OpenQASM Code. We translate their circuit description into the Open-
QASM 2.0 format. The following gives an example of the reversible 5-bit adder
circuit.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [11];
cx q [3] , q [2];
cx q [5] , q [4];
cx q [7] , q [6];
cx q [9] , q [8];
cx q [9] , q [10];
cx q [7] , q [9];
cx q [5] , q [7];
cx q [3] , q [5];
ccx q [0] , q [1] , q [3];
ccx q [2] , q [3] , q [5];
ccx q [4] , q [5] , q [7];
ccx q [6] , q [7] , q [9];
ccx q [8] , q [9] , q [10];
cx q [9] , q [8];
ccx q [6] , q [7] , q [9];

12

19
20
21
22
23
24
25
26
27
28
29
30
31
32

cx q [7] , q [6];
ccx q [4] , q [5] , q [7];
cx q [5] , q [4];
ccx q [2] , q [3] , q [5];
cx q [3] , q [2];
ccx q [0] , q [1] , q [3];
cx q [3] , q [5];
cx q [5] , q [7];
cx q [7] , q [9];
cx q [1] , q [0];
cx q [3] , q [2];
cx q [5] , q [4];
cx q [7] , q [6];
cx q [9] , q [8];

2.3 Qubit Mapping

Description. On the current superconducting quantum processors, 2-qubit
gates are usually unavailable for arbitrary pairs of qubits but only for a small
part of them. In order to make all the 2-qubit gates in a circuit available on
a speciﬁc quantum chip, we have to map the qubits in the circuit to those on
the quantum chip and insert some SWAP gates. Meanwhile, we want to make
sure that the modiﬁed circuit is optimal on depth or the number of inserted
SWAP gates. However, since the above problem, known as the qubit mapping
problem, is NP-complete, it is diﬃcult to theoretically evaluate the performance
of diﬀerent algorithms.
Instead, the performance can be evaluated through
[TC20b] presents an algorithm to generate benchmarks of the
benchmarks.
qubit mapping problems on speciﬁc quantum processors along with optimal
solutions. We have implemented the generating algorithm in Python. The
input and output of the implementation are described below:

The set of qubit pairs which are available for 2-qubit gates is given by the
edge set E of a graph G. Given depth d, gate count N and the proportion of
2-qubit gates p2, a random quantum circuit which can be executed on the graph
G is generated along with an optimal qubit mapping of depth d.
Generation Script. An example of our implementation of QUEKO is shown
below:

edges = [(0 , 1) , (1 , 2) , (1 , 3) , (3 , 4)]
prob = QUEKO ( edges = edges , depth =5 , gateCount =10 , p2 =0.3)

from QUEKO import QUEKO

1
2
3
4
5
6 # p r i n t
7
8
9 # p r i n t
10 # s h o u l d b e mapped t o t h e $ i $ −t h e l e m e n t o f
11

print ( ” // ” + prob . optimalMappi n g )

t h e g e n e r a t e d OpenQASM program

print ( prob . qasm2 )

t h e o p t i m a l

s o l u t i o n , where t h e $ i $ −t h q u b i t

t h e

l i s t .

13

OpenQASM Code. A sample output of the above program is:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [5];
cx q [1] , q [2];
t q [4];
x q [1];
h q [0];
z q [3];
cx q [1] , q [3];
y q [3];
cx q [4] , q [2];
h q [3];
y q [2];

//[2 , 3 , 1 , 4 , 0]

Note that the gate cx q[4], q[2] is not available on the graph given by

edges. However, if we apply the map

2, 1

0

7→

7→

3, 2

7→

1, 3

7→

4, 4

0

7→

to the qubits in the above program, all the cx are then available on the

graph.

2.4 Random Circuits

2.4.1 Random Cliﬀord Circuits

Description. Cliﬀord operation plays an important role in quantum error
correction, randomized benchmarking protocols and quantum circuit simula-
tion. By deﬁnition, Cliﬀord operation is a unitary operation taking elements
of Gn to elements of Gn, where Gn is the Pauli group on n qubits. Any n-
qubit Cliﬀord operation can be simulated using O(n2) Hadamard, phase and
controlled-NOT gates. Cliﬀord group elements are important and frequently en-
countered subsets of physical-level and fault-tolerant quantum circuits [Bra+21],
and sometimes an entire quantum algorithm can be a Cliﬀord circuit (e.g., Bern-
stein–Vazirani [NC02]).

The Cliﬀord group is a unitary 2-design. That is, a random uniformly dis-
tributed element of the Cliﬀord group has exactly the same second order mo-
ments as the Haar random unitary operation. This means the random Cliﬀord
operations can serve as a substitute for Haar random unitaries in any application
that depends only on the second order moments. In Qiskit, the random Cliﬀord
is sampled using the method of [BM21]. Then the Cliﬀord circuit is synthesized
by the method in [AG04] and optimized by the method in [Bra+21].
Generation Script. The script for generating random Cliﬀord circuit is as
follows.

14

1
2
3
4
5
6
7
8
9

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

from qiskit import quantum_info

def gen_rand_cli f f ( n ):

cliff = quantum_info . random_cliff or d ( n )
AG = quantum_info . decompose_c l if f or d ( cliff , method = ’AG ’ )
GD = quantum_info . decompose_c l if f or d ( cliff , method = ’ g r e e d y ’ )

return AG . qasm () , GD . qasm ()

OpenQASM Code. The following gives a 3-qubit random Cliﬀord circuit in
OpenQASM 2.0 format.

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [3];
s q [0];
h q [0];
s q [1];
h q [1];
s q [1];
h q [2];
cx q [2] , q [1];
cx q [1] , q [0];
cx q [0] , q [2];
h q [1];
s q [2];
h q [2];
cx q [2] , q [1];
s q [2];
x q [0];
z q [1];

2.4.2 Quantum Volume

Description. Quantum volume [Cro+19] is a metric that can be used to mea-
sure the capabilities and error rates of a quantum computer. It quantiﬁes the
largest random circuit of equal width and depth that the computer can success-
fully implement. The circuit model used for measuring quantum volume is as
follows.

π

SU (4)

SU (4)

SU (4)

π

SU (4)

SU (4)

SU (4)

π

· · ·
· · ·
· · ·
· · ·
· · ·
· · ·

SU (4)

SU (4)

SU (4)

Figure 6: The circuit model for quantum volume.

Here, π is a permutation of qubits, and every SU (4) represents a 2-qubit

15

unitary gate sampled from the Haar measure on SU(4). There will be d layers
of this module if the depth of the circuit is d, and if the number of qubits in the
circuit is odd, then every layer will have an idle qubit.

In our benchmark, we give a series of circuits for quantum volume con-
structed on basic quantum gates. And the SU (4) gates are decomposed using
qiskit.
OpenQASM Code. The following is an example of the quantum volume
circuit with qubits 2 depth 2, and these circuits are decomposed to cx and u3
gate using the standard QASM representation.

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [2];
creg c [2];
u3 (0.10690831 , -1.8026866 ,0.78825838) q [0];
u3 (2.4950187 , -3.5814199 ,2.5427764) q [1];
cx q [0] , q [1];
u3 (0.82807016 , -3* pi /2 , pi /2) q [0];
u3 ( pi /2 , - pi , -2.8687452) q [1];
cx q [0] , q [1];
u3 (0.20800243 ,0 , -3* pi /2) q [0];
u3 ( pi /2 ,0 , -3* pi /2) q [1];
cx q [0] , q [1];
u3 (2.0104954 ,1.3664259 , -1.5218768) q [0];
u3 (0.94734104 , -0.84662394 ,3.2456914) q [1];
u3 (1.143506 , -3.1351223 , -0.55632777) q [0];
u3 (1.3587079 , -3.1777958 ,0.27175853) q [1];
cx q [0] , q [1];
u3 (1.0096868 , -3* pi /2 , pi /2) q [0];
u3 ( pi /2 , - pi , -3.0848291) q [1];
cx q [0] , q [1];
u3 (0.61517883 ,0 , -3* pi /2) q [0];
u3 ( pi /2 ,0 , -3* pi /2) q [1];
cx q [0] , q [1];
u3 (0.09341401 , -1.4199754 ,4.7299314) q [0];
u3 (0.45442386 , -2.4437295 ,1.2711765) q [1];

Generation Script. The script for generating circuit for arbitrary qubits and
arbitrary depth is as follows.

from qiskit . quantum_info . synthesis \
import t w o _ q u b i t _ c n o t _ d e c o m p o s e
def random_SU ( n ):

X = ( np . random . randn (n , n ) + 1 j * np . random . randn (n , n ))
Q , R = linalg . qr ( X )
Q /= pow ( linalg . det ( Q ) , 1/ n )
return Q

def gen_qv ( qubits , depth ):

cir = QuantumCircui t ( qubits , qubits )

16

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

1
2
3
4
5
6
7
8
9
10

11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

for j in range ( depth ):

perm = np . random . permutation ( qubits )
for k in range ( qubits // 2):

q = [ int ( perm [2 * k ]) , int ( perm [2 * k + 1])]
SU = random_SU (4)
decomposed_SU = t w o _ q u b i t _ c n o t _ d e c o m p o s e( SU )
for gate in decomposed_SU :

i0 = q [ gate [1][0]. index ]
if gate [0]. name == ” cx ” :

i1 = q [ gate [1][1]. index ]
qv . cx ( i0 , i1 )

elif gate [0]. name == ” u1 ” :

qv . u1 ( gate [0]. params [2] , i0 )

elif gate [0]. name == ” u2 ” :

qv . u2 ( gate [0]. params [1] , \

gate [0]. params [2] , i0 )

elif gate [0]. name == ” u3 ” :

qv . u3 ( gate [0]. params [0] , \
gate [0]. params [1] , gate [0]. params [2] , i0 )

elif gate [0]. name == ” i d ” :

return cir . qasm ()

pass

2.4.3 Supremacy Circuits

Random circuits have been widely used in works related to the quantum supremacy
[Boi+18]. Since there are already some benchmarks with such circuits, we just
include the existing and commonly used circuits directly in our benchmark. One
of such benchmark is GRCS 1. GRCS provides a lot of random circuits, but all
in a ’.txt’ format and not given in the standard OpenQASM language. In our
benchmark, we give the OpenQASM version of the random circuits shown in
GRCS.

3 Dynamic Quantum Circuits

Dynamic quantum circuit is a model of quantum computation, in which quan-
tum algorithms can be executed in a more ﬂexible classical-quantum hybrid
way, which can sometimes reduce the costs of quantum resources. The dynamic
quantum circuit is adopted as an alternative and beneﬁcial way for executing
quantum algorithms on NISQ devices. Our benchmark includes a series of dy-
namic quantum circuits.

The biggest diﬀerence between dynamic quantum circuits and conventional
quantum circuits is that measurements will usually appear in the middle of the
circuit, and a series of classically controlled gates will be applied according to
the results of the measurements.
1https://github.com/sboixo/GRCS

17

3.1 Quantum Teleportation

Description. One of the simplest examples of dynamic quantum circuits is
teleportation. Teleportation is a protocol for transmitting a qubit between two
users by sending two classical bits of information [Ben+93].
OpenQASM Code. The corresponding circuit and the OpenQASM 2.0 de-
scription are as follows. The ﬁrst qubit belongs to Alice and the last qubit
belongs to Bob. By ﬁrst applying a series of quantum gates and sending the
measurement result to Bob, Bob can obtain the state of the ﬁrst qubit of Alice
by applying a series of gates according to the measurement information.

|

ϕ
i
0

i

|

H

•

✌✌✌
✌✌✌
X

•

Z

0

H

i

|
Figure 7: Dynamic quantum circuit for Teleportation.

•

|

ϕ
i

1
2
3
4
5
6
7
8
9
10
11
12
13
14

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [3];
creg c0 [1];
creg c1 [1];
creg c2 [1];
h q [2];
cx q [2] , q [1];
cx q [0] , q [1];
h q [0];
measure q [1] -> c1 [0];
if ( c1 ==1) x q [2];
measure q [0] -> c0 [0];
if ( c0 ==1) z q [2];

3.2 Semiclassical Fourier Transform

Description. The quantum Fourier transform can also be represented as a
dynamic quantum circuit form [GN96]. The following gives the detailed infor-
mation of the dynamic version of the quantum Fourier transform. From Figure
2 and Figure 8 you can see that all the controlled-Rk gates are replaced by a
measurement and classically controlled Rk gates.

The advantage of using this dynamic quantum circuit is that there is no need
to apply 2-qubit gates during the process, all the 2-qubit gates can be replaced
by single-qubit gates chosen according to the measurement results.
OpenQASM Code. Following gives the OpenQASM description of the dy-
namic version of quantum Fourier transform.

18

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

1
2
3
4
5
6
7
8
9
10
11
12
13
14

H

✌✌✌
R2 H

j1i
j2i
j3i

|

|

|

•

✌✌✌
R3 R2 H

✌✌✌

Figure 8: Dynamic quantum circuit for Fourier transform.

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [3];
creg c0 [1];
creg c1 [1];
creg c2 [1];
h q [0];
measure q [0] -> c0 [0];
if ( c0 ==1) u1 ( pi /2) q [1];
if ( c0 ==1) u1 ( pi /4) q [2];
h q [1];
measure q [1] -> c1 [0];
if ( c1 ==1) u1 ( pi /2) q [2];
h q [2];
measure q [2] -> c2 [0];

Generation Script. Similar to the conventional quantum circuit, the corre-
sponding circuit can be generated as follows.

def gen_dqc_qft ( qubits ):

cir = QuantumCircui t ( qubits )

for q in range ( qubits ):

cir . h ( q )
c = ClassicalRe g is t er (1 , ’ c ’ + str ( q ))
cir . add_register ( c )
cir . measure (q , c )
for tar in range ( q + 1 , qubits ):

theta = np . pi / 2 ** ( tar - q )
cir . u1 ( theta , tar ). c_if (c , 1)

return cir . qasm ()

3.3

Iterative Phase Estimation

Description. Since the quantum phase estimation uses the inverse quantum
Fourier transform as a subroutine, it can also be executed as a dynamic quantum
circuit. The dynamic version of quantum phase estimation is as follows.

The advantage of the phase estimation implemented by the dynamic quan-
tum circuit is that the circuit can be executed with only 2-qubit gates, and more

19

0

|

i

0

i

|
ϕ
i

|

H

H

/

•

U 2

•
U

H

✌✌✌
R†2 H

✌✌✌

Figure 9: Quantum circuit for phase estimation.

details are shown in [C´or+21].
OpenQASM Code. The following gives the dynamic version of 3-qubit phase
estimation.

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [3];
creg c0 [1];
creg c1 [1];
h q [0];
h q [1];
cu1 ( pi /512) q [1] , q [2];
cu1 ( pi /256) q [0] , q [2];
h q [0];
measure q [0] -> c0 [0];
if ( c0 ==1) u1 ( - pi /2) q [1];
h q [1];
measure q [1] -> c1 [0];

Generation Script. The code for generating dynamic quantum phase estima-
tion circuit of any qubit number is as follows.

def gen_dqc_pe ( qubits , the_phase ):

cir = QuantumCircui t ( qubits + 1)

for q in range ( qubits ):

cir . h ( q )

for q in range ( qubits - 1 , -1 , -1):

cir . cu1 ( np . pi * the_phase *2**( qubits - q ) ,q , qubits )

for q in range ( qubits ):

cir . h ( q )
c = ClassicalRe g is t er (1 , ’ c ’ + str ( q ))
cir . add_register ( c )
cir . measure (q , c )
for tar in range ( q + 1 , qubits ):

theta = np . pi / 2 ** ( tar - q )
cir . u1 ( - theta , tar ). c_if (c , 1)

return cir . qasm ()

20

1
2
3
4
5
6
7
8
9
10
11
12
13
14

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

3.4 Quantum Error correction

Description. Another example of dynamic quantum circuits is the circuit for
quantum error correction, where a quantum state must ﬁrst experience a period
of syndrome measurement, and then be recovered according to the measurement
result.
OpenQASM Code. The following gives the circuit model of error correction
as well as the OpenQASM 2.0 description of the bit-ﬂip and phase-ﬂip code
[NC02].

•

•

•

•

•

•

0

0

0

|

|

|

i

i

i

R

•

•

•

✌✌✌
✌✌✌
✌✌✌

Figure 10: A circuit model for Quantum Error correction.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

1
2
3
4
5
6
7
8
9
10

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [6];
creg c [6];
cx q [0] , q [3];
cx q [1] , q [3];
cx q [1] , q [4];
cx q [2] , q [4];
cx q [0] , q [5];
cx q [2] , q [5];
measure q [3] -> c [3];
measure q [4] -> c [4];
measure q [5] -> c [5];
if ( c ==5) x q [0];
if ( c ==6) x q [1];
if ( c ==3) x q [2];

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [6];
creg c [6];
h q [0];
h q [1];
h q [2];
cx q [0] , q [3];
cx q [1] , q [3];
cx q [1] , q [4];

21

11
12
13
14
15
16
17
18
19
20
21
22

cx q [2] , q [4];
cx q [0] , q [5];
cx q [2] , q [5];
measure q [3] -> c [3];
measure q [4] -> c [4];
measure q [5] -> c [5];
if ( c ==5) x q [0];
if ( c ==6) x q [1];
if ( c ==3) x q [2];
h q [0];
h q [1];
h q [2];

3.5 State Injection

Description. State injection is the technique for implementing some quantum
gates using a dynamic scheme. The basic idea is that the eﬀect of this gate
can be implemented by using a special state and a series of gates that can be
implemented more simply.
OpenQASM Code. The following gives the circuit and the OpenQASM
scripts for the dynamic implementation of the S and T gate [Rya+17].

|
+ i

ψ

i
1

i

|

0

|

i

ψ

|

1

|

i

i

iπ
4

+ e

0

|

i

S

ψ

|

i

T

ψ

|

i

•

•

Z

✌✌✌

(a)

S

✌✌✌

(b)

Figure 11: The quantum circuits for state injection, (a) implementation of S
gate, (b) implementation of T gate.

1
2
3
4
5
6
7
8
9
10

1
2

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;
qreg q [2];
creg c0 [1];
creg c1 [1];
h q [0];
h q [0];
cx q [0] , q [1];
measure q [1] -> c1 [0];
if ( c1 ==1) z q [0];

OPENQASM 2.0;
include ” q e l i b 1 . i n c ” ;

22

3
4
5
6
7
8
9
10

qreg q [2];
creg c0 [1];
creg c1 [1];
h q [0];
h q [0];
cx q [0] , q [1];
measure q [1] -> c1 [0];
if ( c1 ==1) u1 ( pi /2) q [0];

4 Sequential Quantum Circuits

Sequential quantum circuits [LP09; WLY21] are a new breed of quantum circuits
that incorporate a clock signal. They can be understood as a generalization of
classical (synchrounous) logic circuits. From another point of view, sequential
quantum circuits are a special type of dynamic quantum circuits, since interme-
diate measurements are intended to perform at the end of each time step.

Sequential quantum circuits are useful in describing algorithms with loops
and quantum feedback, e.g., Repeat-Until-Success circuits [PS14] and quantum
walks [Kem03]. In this section, we select some of the examples of sequential
quantum circuits and explain how we benchmark them in OpenQASM.

4.1 Repeat-Until-Success

Description. Repeat-Until-Success circuits [PS14] are a bunch of eﬃcient im-
plementations of quantum logic gates which make good use of intermediate
measurements as feedback. Figure 12 shows a sequential quantum circuit for
repeat-until-success implementation of quantum gate

V3 =

I + 2iZ
√5

.

On this basis, we design several benchmarks.

q =

p =

i

0

|
ψ

>

i

|

❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴
T † H T

H T H

H T H

✌✌✌

•
Z

•
Z Z

❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴

Figure 12: A sequential quantum circuit for repeat-until-success implementation
of V3. This ﬁgure is taken from [WLY21].

OpenQASM Code. In Figure 12, q is the only input variable (qubit) while
p is the only internal variable (qubit). At each time step, the qubit q will be
measured in the computational basis indicating whether the implementation

23

✤
✤
✤
✤
✤
✤
✤
✤
succeeds. We abstract the main process of the repeat-until-success implemen-
tation of V3 in OpenQASM as follows.

def qrus () qubit :q , qubit : p
{

h q ;
t q ;
h q ;
ctrl @ z q , p ;
inv @ t q ;
h q ;
t q ;
ctrl @ z q , p ;
h q ;
t q ;
h q ;
z p ;
bit result ;
result = measure q ;

}

Next, we will show how to use the function above to execute the sequential
quantum circuit for one time step. Before the main process of the sequential
circuit, we need to initialize the internal variable, which is qubit p in our case.
The following code sets p to

.

+
i

|

qubit p ;
h p ; // p = |+ >

Every time before calling the function qrus(), we need to prepare input

qubit q beforehand.

qubit q ;
reset q ; // q = |0 >

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

1
2

1
2

Now we are ready to call qrus().

1

qrus (q , p );

After calling qrus(q, p), you can obtain the measurement outcome of the

sequential quantum circuit as follows.

1
2

bit x ;
x = measure q ;

Here, we note that qubit q has already been measured in the execution of
qrus(p, q) before that of x = measure q;. Nevertheless, the measurement
outcome is always retrieved from a correct probability distribution. The reason
we encapsulate measurements in the main process of the sequential circuit (i.e.,
qrus() in our case) is to ensure that a measurement must be performed at each
time step.

24

4.2 Quantum Walk

Description. Quantum walks [ADZ93; Kem03; Amb+01] are quantum gener-
alizations of classical random walks, and have many applications in quantum
algorithms. As an illustrative example (see Figure 13), we consider a quantum
ip ,
walk on a circle (with positions
ip) with an absorbing boundary
ip ,
|
ip. Here, Toss is the toss operator
3

ip ,

3

2

0

1

|

|

|

|

Toss :

ip ,
ic |
ip ,
ic |
which translates the position conditioned on the coin state.

ip → |
ip → |

(i + 1) mod 4

1) mod 4

ic |
ic |

−

(i

1

1

0

0

i

i

|

|

d

c

p1

p2

❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴

✌✌✌

> H

>

>

Toss

•

❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴

•

Figure 13: A sequential quantum circuit for quantum walk. This ﬁgure is taken
from [WLY21].

OpenQASM Code.

In Figure 13, d is the only input variable (qubit),
and c, p1, p2 are the output variables (qubits). The OpenQASM code for the
sequential quantum circuit in Figure 13 is as follows.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

OPENQASM 3.0;

include ” s t d g a t e s . i n c ” ;

gate coin q
{

h q ;

}

gate shift0 p1 , p2
{

ctrl @ x p2 , p1 ;
x p2 ;

}

gate shift1 p1 , p2
{

25

✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

x p2 ;
ctrl @ x p2 , p1 ;

}

gate toss c , p1 , p2
{

x c ;
ctrl @ shift0 c , p1 , p2 ;
x c ;
ctrl @ shift1 c , p1 , p2 ;

}

def qwalk () qubit :d , qubit :c , qubit : p1 , qubit : p2
{

coin c ;
toss c , p1 , p2 ;
ctrl @ ctrl @ x p1 , p2 , d ;
bit result ;
result = measure d ;

}

Similar to the use of the code in repeat-until-success circuits, after initializing
qubit d, a call to qwalk(d, c, p1, p2) will result in one step of quantum walk.

4.3 Classical Control

Description. For the convenience to control the behaviour of quantum systems,
we consider a class of sequential quantum circuits with their input variables in
the computational basis. For example, in Figure 14, the input variables q1 and
q2 control which kind of quantum gates is performed on p1, p2, p3.
In order
to retrieve some information from the sequential quantum circuit, we use a
detective qubit (an input variable) d with it being initialized to

0

OpenQASM Code. The OpenQASM code for the sequential quantum

.
i

|

circuit in Figure 14 is as follows.

OPENQASM 3.0;

include ” s t d g a t e s . i n c ” ;

def qctrl () qubit :d , qubit : q1 , qubit : q2 , qubit : p1 , qubit : p2 , qubit : p3
{

ctrl (4) @ x q1 , q2 , p1 , p2 , p3 ;
negctrl (2) @ q1 , q2 , p1 ;
negctrl @ ctrl @ h q1 , q2 , p2 ;
ctrl @ negctrl @ q1 , q2 , p3 ;
cx p1 , d ;
bit result [3];
result [0] = measure d ;
result [1] = measure q1 ;
result [2] = measure q2 ;

26

d =

0

|
i
q1

q2

p1

p2

p3

✌✌✌

✌✌✌

✌✌✌

❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴

•

•

•

•

H

•

H

•

•

❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴ ❴

H

>

>

>

Figure 14: A sequential quantum circuit for classical control. This ﬁgure is
taken from [WLY21].

16

}

After initializing input variables d, q1, q2, we can call qctrl(d, q1, q2,

d1, d2, d3) for one time step of the computation.

5 Variational Quantum Circuits

The benchmark on variational quantum circuits (VQCs, or parameterized quan-
tum circuits) aims to provide VQC templates of variational quantum algorithms,
including variational quantum eigensolver (VQE).

5.1 Variational Quantum Eigensolver

Description. Solving the ground state energy (minimum eigenvalue) of a
Hamiltonian is fundamental in quantum chemistry and condensed matter physics.
By using various VQCs to model wavefunctions, VQE converts the minimum
eigenvalue problem into optimization over parameters of VQCs. The reader can
refer to a review [Til+21] for comprehensive knowledge.
Generation Script.
In the benchmark, we provide a Python script named
BenchmarkVQE.py to generate OpenQASM ﬁles for VQCs used in VQE lit-
erature. The diﬀerent types of VQCs (ansatz) we currently support and the
corresponding arguments are as follows:

• Hardware-eﬃcient ansatz, --ansatz hea .

• Unitary coupled cluster (UCC) ansatz, --ansatz ucc .

• Symmetry-preserving ansatz, --ansatz spa .

27

✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
✤
After specifying the ansatz, there are some arguments (e.g., number of
qubits) left to set. For detailed usage, please refer to our repository in GitHub.

For example, the following command

1

python benchmark_vqe . py -- ansatz hea -- num_qubits 2

will generate an OpenQASM ﬁle output.qasm for hardware-eﬃcient ansatz
with 2 qubits and all parameters randomly.
OpenQASM Code. An example is as follows.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

OPENQASM 2.0;
include ” q e l i b . i n c ” ;

qreg qs [2];

// Rotation
rz (2.352804 51 3 96 5 6 47 7 ) qs [0];
rx (5.0564683 4 0 91 0 66 6 ) qs [0];
rz (4.8302621 5 4 31 1 05 4 ) qs [0];
rz (5.8263691 1 4 27 9 52 7 ) qs [1];
rx (0.664031 00 1 64 5 0 32 7 ) qs [1];
rz (4.3501967 4 0 81 4 40 3 ) qs [1];
// Entangling
cx qs [0] , qs [1];
// Rotation
rz (1.230064 69 0 18 3 8 26 1 ) qs [0];
rx (4.347686 78 7 22 7 9 68 5 ) qs [0];
rz (4.0491688 1 46 5 23 1 ) qs [0];
rz (3.123558 94 1 89 1 4 61 8 ) qs [1];
rx (3.513696 39 4 78 7 0 35 4 ) qs [1];
rz (2.6569980 1 1 18 3 73 4 ) qs [1];
// Entangling
cx qs [0] , qs [1];
// Rotation
rz (1.722460 77 5 39 7 0 84 9 ) qs [0];
rx (5.5616094 0 8 65 9 55 1 ) qs [0];
rz (4.5877986 1 66 0 49 1 ) qs [0];
rz (6.272733 17 1 68 6 1 24 5 ) qs [1];
rx (4.7112243 5 1 66 4 87 5 ) qs [1];
rz (4.8726544 7 3 63 1 72 5 ) qs [1];

6 Validation

All our benchmark circuits are validated by Qiskit [Qis] and QCOR [Ngu+20].
For OpenQASM 2.0 descriptions, Qiskit is used. To run an example named
in file.qasm, simply navigate to its directory and execute the codes in python:

1
2

qc = qiskit . QuantumCircu it . from_qasm_fi le ( ’ . / i n f i l e . qasm ’ )
simulator = qiskit . Aer . get_backend ( ’ a e r s i m u l a t o r ’ )

28

Table 1: Example Applications

Example Applications

Used VeriQBench Benchmark Circuits

Equivalence Checking [BW20b; Hon+21b]

QFT, Grover, Dynamic (Section 3)

Fault Simulation

BV, QFT

Circuit Optimization [Nam+18; AMM14]

QFT, Reversible (Section 2.2)

ATPG [Ber17; CY22]

Grover, BV, QFT, QV

Qubit Mapping [TC20b; TC20a]

Generated Circuits (Section 2.3)

Model Checking [GNP05]

Teleportation

3
4

1
2

1
2

qc = qiskit . transpile ( qc , simulator )
result = simulator . run ( qc , shots =1 , memory = True ). result ()

For OpenQASM 3.0 descriptions, QCOR is used. To run an example named
in file.qasm, simply navigate to its directory and execute:

qcor - shots 1024 in_file . qasm
./ a . out

The simulation can be accelerated using TNQVM [McC+18], which leverages
tensor network theory to simulate quantum circuits. To run the above example
with TNQVM acceleration, simply execute:

qcor - qpu tnqvm [ tnqvm - visitor : exatn ] - shots 1024 in_file . qasm
./ a . out

For more details, we refer the readers to the oﬃcial documentation and user
guides [AID].

7 Example Applications

To demonstrate the utility, in this section, we discuss some example applications
and point out how the benckmark circuits of VeriQBench are used there. A
summary of these applications is presented in Table 1.

• Equivalence Checking of Quantum Circuits: Equivalence checking is to
check if two quantum circuits are functionally equivalent [VMH07; YM10;
BW20b; BW20a; Hon+21b; Hon+21a; WLY21]. The circuits for quan-
tum Fourier transform and Grover’s algorithms have been used in work
[BW20b] to demonstrate the eﬀectiveness of their equivalence checking
methods. Also, the circuits given in Section 3 have been used in testing
the algorithm developed in [Hon+21b] for checking equivalence of dy-
namic quantum circuits, and the circuits such as Bernstein-Vazirani and
quantum Fourier transform and quantum volume have been used in the
approximate equivalence checking of noisy quantum circuits [Hon+21a].

29

The circuits given in Section 4 have been used in equivalence checking of
sequential quantum circuits [WLY21].

• Fault Simulation of Quantum Circuits: Given a quantum circuit and its
faulty implementation, fault simulation is to calculate the ﬁdelity between
the expected output state and the actually obtained output state [Hua+21;
Che+21; Isa+21; Hua]. The work is performed on combinational quan-
tum circuits, including Bernstein-Vazirani and Quantum Fourier Trans-
form with realistic fault models proposed in [Hsi+20].

• Circuit Optimization: Quantum circuit optimization [Mas+08; Pra+06;
SM13; AMM14; Nam+18] aims to reduce the complexity of a quantum
circuit, where the complexity, depending on the scenario, can be quantiﬁed
by the size, depth, T-count or T-depth of the quantum circuit. The re-
versible circuits such as divisibility checkers have been used to benchmark
the quantum circuit optimization algorithms [Nam+18; AMM14].

• Automatic Test Pattern Generation (ATPG): Quantum ATPG algorithms
[PPH12; Ber17; CY22] aim to generate speciﬁc test patterns based on
the structure and fault model of the quantum circuit, where the test
patterns include a set of input vectors and corresponding outputs vec-
tors. The Combinational Quantum Circuits including Grover’s algorithm,
Bernstein-Vazirani, Quantum Fourier Transform and Quantum Volume
with the unitary fault model have been used to demonstrate the eﬀective-
ness of the ATPG algorithms in [Ber17; CY22].

• Qubit Mapping: The target of qubit mapping is to assign a physical qubit
on a quantum chip to every logical qubit in a quantum circuit, while op-
timizing the performance of the circuit [Mas+08; SSP14; LSJ14; WLD14;
PS16; Sir+18; ZPW18; CSU19; WBZ19; LDX19; Bha+19; Mur+19; TQ19;
Siv+20]. One of the most important performance metrics of quantum cir-
cuits is the depth of the circuit. The method for generating qubit mapping
problems with optimal solutions for depth in this benchmark was proposed
in [TC20b], and was used to evaluate the qubit mapping tools in [TC20a].

• Model Checking Quantum Systems: Model-checking is one of the most
successful veriﬁcation techniques with numerous applications in hardware
and software industries.
It has been generalised to check various prop-
erties of quantum systems, including quantum cryptographic protocols
[GNP08], quantum programs [YF21] and quantum circuits [Yin21]. The
teleportation circuit in Section 3.1 has been used in probabilistic model
checking algorithm of quantum protocols [GNP05].

Acknowledgments

We would like to thank Zhicheng Zhang, Minbo Gao and Riling Li for their
insightful discussions. This work was partly supported by the National Key

30

R&D Program of China (Grant No: 2018YFA0306701), the National Natural
Science Foundation of China (Grant No: 61832015).

References

[AD16]

[ADZ93]

[AG04]

[AID]

Nabila Abdessaied and Rolf Drechsler. “Reversible and Quantum
Circuits”. In: Google Scholar Google Scholar Digital Library Digital
Library (2016).

Y. Aharonov, L. Davidovich, and N. Zagury. “Quantum ran-
dom walks”. In: Physical Review A 48.2 (1993), p. 1687. doi:
10.1103/PhysRevA.48.1687.

Scott Aaronson and Daniel Gottesman. “Improved simulation of
stabilizer circuits”. In: Physical Review A 70.5 (2004), p. 052328.

AIDE-QC. AIDE-QC: Documentation and User Guides. https://
aide-qc.github.io/deploy/.

[Amb+01] A. Ambainis et al. “One-dimensional quantum walks”. In: Pro-
ceedings of the Thirty-Third Annual ACM Symposium on Theory
of Computing. 2001, pp. 37–49. doi: 10.1145/380752.380757.

[AMM14] Matthew Amy, Dmitri Maslov, and Michele Mosca. “Polynomial-
time T-depth optimization of Cliﬀord+ T circuits via matroid par-
titioning”. In: IEEE Transactions on Computer-Aided Design of
Integrated Circuits and Systems 33.10 (2014), pp. 1476–1489.

[Aru+19]

[Ben+93]

[Ber17]

[Bha+19]

Frank Arute et al. “Quantum supremacy using a programmable
superconducting processor”. In: Nature 574.7779 (2019), pp. 505–
510.

Charles H Bennett et al. “Teleporting an unknown quantum
state via dual classical and Einstein-Podolsky-Rosen channels”. In:
Physical review letters 70.13 (1993), p. 1895.

Debajyoti Bera. “Detection and diagnosis of single faults in quan-
tum circuits”. In: IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems 37.3 (2017), pp. 587–600.

Debjyoti Bhattacharjee et al. “MUQUT: Multi-constraint quan-
tum circuit mapping on NISQ computers”. In: 2019 IEEE/ACM
International Conference on Computer-Aided Design (ICCAD).
IEEE. 2019, pp. 1–7.

[BM21]

Sergey Bravyi and Dmitri Maslov. “Hadamard-free circuits expose
the structure of the Cliﬀord group”. In: IEEE Transactions on
Information Theory 67.7 (2021), pp. 4546–4563.

[Boi+18]

Sergio Boixo et al. “Characterizing quantum supremacy in near-
term devices”. In: Nature Physics 14.6 (2018), pp. 595–600.

31

[Bra+21]

Sergey Bravyi et al. “Cliﬀord circuit optimization with templates
and symbolic pauli gates”. In: arXiv preprint arXiv:2105.02291
(2021).

[Bro+20] Michael Broughton et al. “Tensorﬂow quantum: A software
framework for quantum machine learning”. In: arXiv preprint
arXiv:2003.02989 (2020).

[BV97]

[BW20a]

[BW20b]

Ethan Bernstein and Umesh Vazirani. “Quantum complexity the-
ory”. In: SIAM Journal on Computing 26.5 (1997), pp. 1411–1473.

Lukas Burgholzer and Robert Wille. “Advanced equivalence check-
ing for quantum circuits”. In: IEEE Transactions on Computer-
Aided Design of Integrated Circuits and Systems 40.9 (2020),
pp. 1810–1824.

Lukas Burgholzer and Robert Wille. “Improved DD-based equiva-
lence checking of quantum circuits”. In: 2020 25th Asia and South
Paciﬁc Design Automation Conference (ASP-DAC). IEEE. 2020,
pp. 127–132.

[Cer+21] Marco Cerezo et al. “Variational quantum algorithms”. In: Nature

Reviews Physics 3.9 (2021), pp. 625–644.

[Che+21]

[Chi17]

[C´or+21]

[Cro+19]

[CS08]

[CSU19]

[CY22]

Song Cheng et al. “Simulating noisy quantum circuits with matrix
product density operators”. In: Phys. Rev. Research 3 (2 Apr.
2021), p. 023005. doi: 10.1103/PhysRevResearch.3.023005.
url:
https://link.aps.org/doi/10.1103/PhysRevResearch.
3.023005.

Andrew M Childs. “Lecture notes on quantum algorithms”. In:
Lecture notes at University of Maryland (2017).

Antonio D C´orcoles et al. “Exploiting dynamic quantum circuits in
a quantum algorithm with superconducting qubits”. In: Physical
Review Letters 127.10 (2021), p. 100501.

Andrew W Cross et al. “Validating quantum computers using
randomized model circuits”. In: Physical Review A 100.3 (2019),
p. 032328.

Amlan Chakrabarti and Susmita Sur-Kolay. “Designing quantum
adder circuits and evaluating their error performance”. In: 2008
International Conference on Electronic Design. 2008, pp. 1–6. doi:
10.1109/ICED.2008.4786689.

Andrew M Childs, Eddie Schoute, and Cem M Unsal. “Circuit
transformations for quantum architectures”. In: arXiv preprint
arXiv:1902.09102 (2019).

Kean Chen and Mingsheng Ying. “Automatic Test Pattern Gen-
eration for Robust Quantum Circuit Testing”. In: arXiv preprint
arXiv:2202.10697 (2022).

32

[DL21]

[FGG14]

[GN96]

[GNP05]

[GNP08]

[Gro96]

[Had+19]

Yulong Dong and Lin Lin. “Random circuit block-encoded matrix
and a proposal of quantum LINPACK benchmark”. In: Physical
Review A 103.6 (2021), p. 062412.

Edward Farhi, Jeﬀrey Goldstone, and Sam Gutmann. “A quan-
tum approximate optimization algorithm”. In: arXiv preprint
arXiv:1411.4028 (2014).

Robert B Griﬃths and Chi-Sheng Niu. “Semiclassical Fourier
transform for quantum computation”. In: Physical Review Letters
76.17 (1996), p. 3228.

Simon Gay, Rajagopal Nagarajan, and Nikolaos Papanikolaou.
“Probabilistic Model–Checking of Quantum Protocols”. In: arXiv
preprint quant-ph/0504007 (2005).

Simon J Gay, Rajagopal Nagarajan, and Nikolaos Papanikolaou.
“QMC: A model checker for quantum systems”. In: Interna-
tional Conference on Computer Aided Veriﬁcation. Springer. 2008,
pp. 543–547.

Lov K Grover. “A fast quantum mechanical algorithm for database
search”. In: Proceedings of the twenty-eighth annual ACM sympo-
sium on Theory of computing. 1996, pp. 212–219.

Stuart Hadﬁeld et al. “From the quantum approximate optimiza-
tion algorithm to a quantum alternating operator ansatz”. In: Al-
gorithms 12.2 (2019), p. 34.

[Hon+21a] Xin Hong et al. “Approximate equivalence checking of noisy quan-
tum circuits”. In: 2021 58th ACM/IEEE Design Automation Con-
ference (DAC). IEEE. 2021, pp. 637–642.

[Hon+21b] Xin Hong et al. “Equivalence Checking of Dynamic Quantum Cir-
cuits”. In: arXiv preprint arXiv:2106.01658 (2021).

[Hsi+20]

[Hua]

[Hua+21]

Cheng-Yun Hsieh et al. “Realistic Fault Models and Fault Sim-
ulation for Quantum Dot Quantum Circuits”. In: 2020 57th
ACM/IEEE Design Automation Conference (DAC). 2020, pp. 1–6.
doi: 10.1109/DAC18072.2020.9218573.
Mingyu Huang. Fault Simulation Repository. https://github.
com/hmy98213/Fault-Simulation.

Yipeng Huang et al. “Logical Abstractions for Noisy Variational
Quantum Algorithm Simulation”. In: Proceedings of the 26th
ACM International Conference on Architectural Support for Pro-
gramming Languages and Operating Systems. ASPLOS 2021. Vir-
tual, USA: Association for Computing Machinery, 2021, pp. 456–
472. isbn: 9781450383172. doi: 10.1145/3445814.3446750. url:
https://doi.org/10.1145/3445814.3446750.

33

[Isa+21]

[Kem03]

[LDX19]

[Li+20a]

[Li+20b]

[Liu+21]

[LP09]

[LSJ14]

[Mas]

[Mas+08]

Isakov et al. Simulations of Quantum Circuits
Sergei V.
with Approximate Noise using qsim and Cirq. 2021. doi:
10.48550/ARXIV.2111.02396. url: https://arxiv.org/abs/
2111.02396.

J. Kempe. “Quantum random walks: an introductory overview”.
In: Contemporary Physics 44.4 (2003), pp. 307–327. doi:
10.1080/00107151031000110776.

Gushu Li, Yufei Ding, and Yuan Xie. “Tackling the qubit map-
ping problem for NISQ-era quantum devices”. In: Proceedings of
the Twenty-Fourth International Conference on Architectural Sup-
port for Programming Languages and Operating Systems. 2019,
pp. 1001–1014.

Ang Li et al. “Qasmbench: A low-level qasm benchmark
suite for nisq evaluation and simulation”. In: arXiv preprint
arXiv:2005.13018 (2020).

Gushu Li et al. “Projection-based runtime assertions for testing
and debugging quantum programs”. In: Proceedings of the ACM
on Programming Languages 4.OOPSLA (2020), pp. 1–29.

Yunchao Liu et al. “Benchmarking near-term quantum computers
via random circuit sampling”. In: arXiv preprint arXiv:2105.05232
(2021).

M. Lukac and M. Perkowski. “Quantum Finite State Machines as
Sequential Quantum Circuits”. In: Proceedings of the 39th Interna-
tional Symposium on Multiple-Valued Logic. 2009, pp. 92–97. doi:
10.1109/ISMVL.2009.46.

Chia-Chun Lin, Susmita Sur-Kolay, and Niraj K Jha. “PAQCS:
Physical design-aware fault-tolerant quantum circuit synthesis”.
In: IEEE Transactions on Very Large Scale Integration (VLSI)
Systems 23.7 (2014), pp. 1221–1234.

Dmitri Maslov. Reversible Logic Synthesis Benchmarks Page.
https://reversiblebenchmarks.github.io.

Dmitri Maslov et al. “Quantum circuit simpliﬁcation and level
compaction”. In: IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems 27.3 (2008), pp. 436–444.

[McC+18] Alexander McCaskey et

al.

programming models with
In: PLOS ONE
10.1371/journal.pone.0206704.
10.1371/journal.pone.0206704.

13.12

(Dec.

tensor

“Validating quantum-classical
simulations”.
network
1–19. doi:
pp.
https://doi.org/

2018),
url:

[Mur+19]

Prakash Murali et al. “Full-stack, real-system quantum computer
studies: Architectural comparisons and design insights”. In: 2019
ACM/IEEE 46th Annual International Symposium on Computer
Architecture (ISCA). IEEE. 2019, pp. 527–540.

34

[Nam+18] Yunseong Nam et al. “Automated optimization of large quantum
circuits with continuous parameters”. In: npj Quantum Informa-
tion 4.1 (2018), pp. 1–12.

[NC02]

[Ngu+20]

[Per+14]

[PPH12]

[Pra+06]

[PS14]

[PS16]

Michael A Nielsen and Isaac Chuang. Quantum computation and
quantum information. 2002.

Thien Nguyen et al. “Extending C++ for Heterogeneous Quantum-
Classical Computing”. In: arXiv e-prints, arXiv:2010.03935 (Oct.
2020), arXiv:2010.03935. arXiv: 2010.03935 [quant-ph].

Alberto Peruzzo et al. “A variational eigenvalue solver on a pho-
tonic quantum processor”. In: Nature communications 5.1 (2014),
pp. 1–7.

Alexandru Paler, Ilia Polian, and John P Hayes. “Detection and
diagnosis of faulty quantum circuits”. In: 17th Asia and South Pa-
ciﬁc Design Automation Conference. IEEE. 2012, pp. 181–186.

Aditya K Prasad et al. “Data structures and algorithms for sim-
plifying reversible circuits”. In: ACM Journal on Emerging Tech-
nologies in Computing Systems (JETC) 2.4 (2006), pp. 277–293.

A. Paetznick and K. M. Svore. “Repeat-until-success: non-
deterministic decomposition of single-qubit unitaries”. In: Quan-
tum Information & Computation 14.15–16 (2014), pp. 1277–1301.
doi: 10.26421/QIC14.15-16-2.
Massoud Pedram and Alireza Shafaei. “Layout optimization for
quantum circuits with linear nearest neighbor architectures”. In:
IEEE Circuits and Systems Magazine 16.2 (2016), pp. 62–74.

[Qis]

Qiskit. Qiskit. https://qiskit.org.

[Rya+17]

[Sir+18]

[Siv+20]

[SM13]

[SSP14]

Colm A Ryan et al. “Hardware for dynamic quantum computing”.
In: Review of Scientiﬁc Instruments 88.10 (2017), p. 104703.

Marcos Yukio Siraichi et al. “Qubit allocation”. In: Proceedings of
the 2018 International Symposium on Code Generation and Opti-
mization. 2018, pp. 113–125.

Seyon Sivarajah et al. “t— ket¿: a retargetable compiler for
NISQ devices”. In: Quantum Science and Technology 6.1 (2020),
p. 014003.

Mehdi Saeedi and Igor L Markov. “Synthesis and optimization
of reversible circuits—a survey”. In: ACM Computing Surveys
(CSUR) 45.2 (2013), pp. 1–34.

Alireza Shafaei, Mehdi Saeedi, and Massoud Pedram. “Qubit place-
ment to minimize communication overhead in 2D quantum archi-
tectures”. In: 2014 19th Asia and South Paciﬁc Design Automation
Conference (ASP-DAC). IEEE. 2014, pp. 495–500.

35

[TC20a]

[TC20b]

Bochen Tan and Jason Cong. “Optimal layout synthesis for quan-
tum computing”. In: 2020 IEEE/ACM International Conference
On Computer Aided Design (ICCAD). IEEE. 2020, pp. 1–9.

Bochen Tan and Jason Cong. “Optimality study of existing quan-
tum computing layout synthesis tools”. In: IEEE Transactions on
Computers 70.9 (2020), pp. 1363–1373.

[Til+21]

Jules Tilly et al. The Variational Quantum Eigensolver: a review of
methods and best practices. 2021. arXiv: 2111.05176 [quant-ph].

[Tom+22] Teague Tomesh et al. “SupermarQ: A Scalable Quantum Bench-

mark Suite”. In: arXiv preprint arXiv:2202.11045 (2022).

[TQ19]

[VMH07]

[WBZ19]

[WLD14]

[WLY21]

[YF21]

[Yin21]

[YM10]

Swamit S Tannu and Moinuddin K Qureshi. “Not all qubits are
created equal: a case for variability-aware policies for NISQ-era
quantum computers”. In: Proceedings of the Twenty-Fourth In-
ternational Conference on Architectural Support for Programming
Languages and Operating Systems. 2019, pp. 987–999.

George F Viamontes, Igor L Markov, and John P Hayes. “Checking
equivalence of quantum circuits and states”. In: 2007 IEEE/ACM
International Conference on Computer-Aided Design. IEEE. 2007,
pp. 69–74.

Robert Wille, Lukas Burgholzer, and Alwin Zulehner. “Mapping
quantum circuits to IBM QX architectures using the minimal num-
ber of SWAP and H operations”. In: 2019 56th ACM/IEEE Design
Automation Conference (DAC). IEEE. 2019, pp. 1–6.

Robert Wille, Aaron Lye, and Rolf Drechsler. “Optimal SWAP
gate insertion for nearest neighbor quantum circuits”. In: 2014
19th Asia and South Paciﬁc Design Automation Conference (ASP-
DAC). IEEE. 2014, pp. 489–494.

Q. Wang, R. Li, and M. Ying. “Equivalence Checking of Sequential
Quantum Circuits”. In: IEEE Transactions on Computer-Aided
Design of Integrated Circuits and Systems (2021), Early Access.
doi: 10.1109/TCAD.2021.3117506.
Mingsheng Ying and Yuan Feng. Model Checking Quantum Sys-
tems: Principles and Algorithms. Cambridge University Press,
2021.

Mingsheng Ying. “Model Checking for Veriﬁcation of Quan-
tum Circuits”. In: International Symposium on Formal Methods.
Springer. 2021, pp. 23–39.

Shigeru Yamashita and Igor L Markov. “Fast equivalence-checking
for quantum circuits”. In: 2010 IEEE/ACM International Sympo-
sium on Nanoscale Architectures. IEEE. 2010, pp. 23–28.

36

[ZPW18]

Alwin Zulehner, Alexandru Paler, and Robert Wille. “An eﬃcient
methodology for mapping quantum circuits to the IBM QX ar-
chitectures”. In: IEEE Transactions on Computer-Aided Design of
Integrated Circuits and Systems 38.7 (2018), pp. 1226–1236.

37

