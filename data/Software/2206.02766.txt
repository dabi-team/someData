Complexity of Eccentricities and All-Pairs Shortest Paths
in the Quantum CONGEST Model

Changsheng Wang ∗

Xudong Wu †

Penghui Yao ‡

June 7, 2022

Abstract

Computing the distance parameters of a network, including the diameter, radius, eccentrici-
ties and the all-pairs shortest paths (APSP) is a central problem in distributed computing. This
paper investigates the distance parameters in the quantum CONGEST models and establishes
almost linear lower bounds on eccentricities and APSP, which match the classical upper bounds.
Our results imply that there is not quantum speedup for these two problems. In contrast with
the diameter and radius, exchanging quantum messages is able to save the communication when
the networks have low diameters [GM18, MN20]. We obtain the lower bounds via a reduction
from the two-way quantum communication complexity of the set intersection [Raz03].

2
2
0
2

n
u
J

6

]
h
p
-
t
n
a
u
q
[

1
v
6
6
7
2
0
.
6
0
2
2
:
v
i
X
r
a

∗State Key Laboratory for Novel Software Technology, Nanjing University, email: wangcs@smail.nju.edu.cn
†State Key Laboratory for Novel Software Technology, Nanjing University, email: xdwu@smail.nju.edu.cn
‡State Key Laboratory for Novel Software Technology, Nanjing University, email: pyao@nju.edu.cn

1

 
 
 
 
 
 
1

Introduction

In distributed computing, the graph G = (V, E) represents the topology of the network, each node
represents a processor with an unique ID, and messages can be transferred directly through the
edges connecting two nodes. In the classical CONGEST model, the computation proceeds with
round-based synchrony and each node can send one O(log n)-bit message to each adjacent node
per round, where n denotes the number of nodes. More speciﬁcally, protocols in the model are
executed round by round. In each round, each node can send/receive a message of O(log n) bits
to/from each of its neighbours, i.e., each pair of neighbours can exchange a message of O(log n)
bits. After that, all nodes implement local computation and enter the next round simultaneously.
As for the quantum version deﬁned in [EKNP14], the only diﬀerence is that each node can send
qubits instead of classical bits. The round complexity of a distributed problem f in the CONGEST
model (both classical and quantum version) denotes the smallest number of communication rounds
needed to compute f .

The diameter of a graph, denoted by D, is deﬁned as the maximum distance between any two
nodes. It is a fundamental parameter of the network since in at least D rounds, every two nodes
are possible to know each other. The eccentricity with respect to some node v is deﬁned as the
maximum distances from v to any other node. So the diameter is the maximum eccentricities
over all nodes. The radius of a graph is deﬁned to be the minimum eccentricities over all nodes.
Diameters, radius and eccentricities are three basic distance parameters in distributed network.

We study the distance computation in the quantum CONGEST model and focus on investigat-
ing whether introducing quantum communication can speed up distributed computation compared
to the classical setting.
Related works. Elkin, Klauck, Nanongkai and Pandurangan [EKNP14] proved that quantum
communication does not oﬀer signiﬁcant advantages over classical communication for many fun-
damental problems in distributed computing, including minimum spanning tree (MST), minimum
cut, s-source distance, shortest path tree (SPT) and shortest s-t paths.

However, based on distributed Grover’s search [Gro96], Le Gall and Magniez [GM18] proposed
a ˜O(√nD)-round quantum algorithm to exactly compute the diameter in the CONGEST model
when the graph has a low diameter, where D is the diameter of the underlying network graph,
exhibiting a quantum advantage in the CONGEST model, as the classical round complexity is
Ω (n). They also proved a tight lower bound ˜Ω(√nD) for any distributed quantum algorithms if
each node can use only poly(log n) quantum bits. An unconditional quantum lower bound ˜Ω(√n)
for diameters was also proved in [GM18], which was later improved to Ω( 3√nD2 + √n) by Magniez
and Nayak [MN20].

In the classical CONGEST model, there is a series of studies on distance computation. Ear-
lier, Frischknecht, Holzer and Wattenhofer [FHW12] showed that computing the diameter of an
unweighted graph in CONGEST model requires ˜Ω(n) rounds, which is tight up to a logarithmic
factors since even the All-Pairs Shortest Path problem(APSP) on an unweighted graph can be
resolved in O(n) rounds [PRT12, HW12]. Abboud, Censor-Hillel and Khoury [ACK16] later gave a
same lower bound of ˜Ω(n) on diameters even in sparse networks. As a result, the round complexities
of computing diameter, radius eccentricities and APSP in the classical CONGEST model are all in
˜Θ(n) regime.

Regarding the approximate distance computation, an ˜Ω(n) lower bound holds even for (3/2
(cid:15))-approximate radius, and (5/3

(cid:15))-
(cid:15))-approximate eccentricities in

approximate diameter, (3/2

−

−

−

2

[ACK16], where (cid:15) > 0 is a constant. For larger approximation ratios, Holzer , Peleg, Roditty and
Wattenhofer [HPRW14] and Ancona et al. [ACHD+20] present ˜O(√n + D)-round distributed algo-
rithms for 3/2-approximate diameter, 3/2-approximate radius, and 5/3-approximate eccentricities.
Main results. Le Gall and Magniez [GM18] showed that quantum computation can speed up
computing diameter (and radius by similar argument). We focus on the round complexity of
eccentricities and APSP , completing the picture on the complexity of distance computation in
quantum CONGEST models.

Theorem 1.1. Any quantum protocol computing all-pairs shortest paths in the CONGEST model
requires Ω( n

log n ) rounds.

Theorem 1.2. Any quantum protocol computing the exact eccentricities of all nodes in the CON-
GEST model requires Ω( n

log2 n ) rounds.

Theorem 1.3. For all constant 0 < ε < 2
of all eccentricities in the CONGEST model requires Ω( n

3 , any quantum protocol computing a ( 5

3 −

log3 n ) rounds.

ε)-approximation

Remark 1.4. The lower bounds on eccentricities and APSP we establish still hold even if the
networks have constant diameters. Thus there is no quantum advantages even for the networks with
constant diameters. However, for such networks, it is known that the quantum round complexities
of the diameter and radius are quadratically smaller than the classical round complexities in the
CONGEST model [FHW12, GM18, MN20].

Our lower bounds are tight up to a logarithmic factor. Thus quantum computation cannot
speedup the eccentricities and APSP computation substantially. Our results and related works are
collected in Table 1.

Problem

Approx.

Upper Bound ˜O(·)

Lower Bound ˜Ω(·)

Classical

Quantum

Classical

Quantum

APSP

Exact

n [PRT12, HW12]

n

n

n

n (Theorem 1.1)

n (Theorem 1.2)

n [ACK16]

n (Theorem 1.3)

n

√

n + D [ACHD+20]

Exact

Eccentricities

5/3 − ε

5/3

Exact

Diameter

3/2 − ε

3/2

Exact

n

√

nD [GM18]

n [FHW12]

n [ACK16]

√

n + D [HPRW14]

3√

nD + D [GM18]

3√

√

nD2 +

n [MN20]

n

√

nD

n [ACK16]

3√

√

nD2 +

n (Theorem 3.3)

Radius

3/2 − ε

3/2

√

n + D [ACHD+20]

Table 1: Upper and Lower bounds of distance computation in the classical and quantum CONGEST
model. ε > 0 is a constant.

3

Techniques overview. A well-known technique to prove lower bounds on CONGEST models is
via two-party communication complexity. The best lower bounds on the classical round complex-
ity of computing the distances are induced from the two-party communication complexity of the
disjointness function DISJk.

The lower bounds on the number of rounds needed to compute the diameter/radius exactly and
approximately in quantum CONGEST model can be obtained by simply using the the quantum
communication complexity of DISJk. However, it seems diﬃcult to obtain tight lower bounds on
the round complexities eccentricities and APSP via a reduction from disjointness.

We construct a reduction from the intersection function INTk,ρ to APSP, where the INTk,ρ is
a Boolean function that counts the number of intersecting elements and disjointness function is
a special case of INTk,ρ when ρ = 1. Razborov [Raz03] showed a tight bound on the quantum
communication complexity of the INTk,ρ. Assuming that there exists a quantum distributed al-
gorithm that computes APSP, we can use the algorithm to construct a protocol that computes
the intersection function, which implies a lower bound on APSP. To the best of our knowledge,
this is the ﬁrst time that the intersection function is used to prove the lower bound on quantum
distributed computation. Analogously, we are able to prove a tight bound of eccentricities via the
quantum communication complexity of the intersection function.

2 Preliminaries

2.1 Classical and quantum CONGEST model

In the classical CONGEST model, the communication network can be seen as a graph G = (V, E).
Usually we assume that there are n nodes and m edges in G, and the nodes are assigned with
unique identiﬁers. Each node represents a processor with unlimited computational power, i.e., the
consumption of any local computation in a single processor is ignored. Each edge connecting two
nodes represents a communication channel with O(log n) bits of bandwidth.

In the quantum CONGEST model, adjacent nodes are allowed to exchange quantum bits
(qubits), i.e., the classical channels are replaced by quantum channels with the same bandwidth
O(log n). And naturally each node can locally do some quantum computation. Nodes may own
qubits which are entangled with the qubits owned by other nodes. In this paper, we assume that
initially distinct nodes do not share entanglement. But they can, for example, locally create a pair
of entangled qubits, and send one to other nodes.

For both classical and quantum CONGEST models, the algorithm is implemented round by
round in a synchronous manner. In each round, every node sends/receives a message of O(log n)
bits to/from each neighbour, then implements local computation. At the end of the algorithm,
every node has its own output (maybe empty). The round complexity of an algorithm is deﬁned to
be the number of communication rounds in the process in the worst case. And the round complexity
of a problem is the least round complexity of any algorithm solving this problem.

2.2 Graph notation and problem deﬁnition

For a graph G = (V, E), the distance between two nodes u and v is the length of the shortest path
between u and v. We use d(u, v) to denote the distance between u and v. The eccentricity with

4

respect to some node u is denoted by

e(u) = max
v∈V

d(u, v).

The diameter of a graph G, denoted by D, is the maximum eccentricities over all nodes, i.e., the
maximum distance between any two nodes; while the radius of a graph G, denoted by R, is the
minimum eccentricities over all nodes:

D = max
u∈V

e(u) = max
u,v∈V

d(u, v) and R = min
u∈V

e(u).

Any node with the minimum eccentricity is called a center of the graph, so the radius is the
eccentricity of any center node.

Before describing problems of distance computation in the distributed setting, recall the deﬁ-

nition of approximation for optimization problems.

Given a maximization problem

solution of the instance x, and SOLA(x) denotes the solution that the algorithm
instance x. For any ρ
if 1
of
OP T (x)
ρ ·
P
and ρ
problem
P
ρ
SOLA(x)

and an instance x, OP T (x) denotes the value of the optimal
obtains for
computes a ρ-(multiplicative) approximation
OP T (x) for any instance x. Similarly for a minimization

1, we say that the algorithm
SOLA(x)

computes a ρ-approximation of

OP T (x) for any instance x.

1, we say that an algorithm

if OP T (x)

≤

≥
≤

A

A

A

≤

≥

P

P

≤

·

Deﬁnition 2.1 (Diameter/radius). Given a network with underlying graph G = (V, E), the diam-
eter computation, which is a maximization problem, requires that all nodes should have the same
output, which is the exact value (or an approximation) of the diameter of G. Similarly the radius
computation, which is a minimization problem, requires nodes to output the same value, which is
the exact value (or an approximation) of the radius of G.

Deﬁnition 2.2 (Eccentricities). Given a network with the underlying graph G = (V, E), the
eccentricities computation requires each node u to output its eccentricity, or an approximation.

Remarks.
ρ-approximation of the eccentricity if

If an algorithm

A

has node u outputs ˆe(u), we say that, for ρ

1,

≥

A

computes a

u

∈

∀

V,

1
ρ ·

e(u)

ˆe(u)

≤

≤

e(u).

Deﬁnition 2.3 (APSP). Given a network with the underlying graph G = (V, E), the APSP
computation requires each node u to output the distance between u and v for each node v.

2.3 Two-party communication complexity

A main tool to obtain lower bounds in the CONGEST model is via reductions to two-way communi-
cation complexity and apply the various existing methods proving lower bounds on communication
complexity.

Communication complexity was ﬁrst introduced by Yao in [Yao79]. Consider two players, usu-
k, respectively.
0, 1
ally called Alice and Bob, and assume that Alice and Bob receives inputs x, y
}
The players want to compute a Boolean function f :
by exchanging mes-
sages. At the end of the protocol, both Alice and Bob output f (x, y). The minimum communication
required for the players to compute the function is the communication complexity of f .

∈ {
0, 1
}

0, 1
}

0, 1
}

→ {

× {

{

k

k

5

In [Yao93], Yao introduced the model of quantum communication complexity, where the players
are allowed to communicate with qubits. The communication cost of a quantum protocol is the
maximum (over all inputs) number of qubits that the players exchange. The quantum communica-
tion complexity of a function f is the minimum communication cost of any quantum protocol that
computes f with probability at least 2/3.

Deﬁnition 2.4 (Disjointness). For any integer k
0, 1
0, 1
{
}
}
with xp = yp = 1, where [k] =

0, 1
{
is the function such that DISJk(x, y) = 0 if and only if there exists an index p

1, the disjointness function DISJk :

→ {

, k

≥

k

.

k
}
∈

×
[k]

1,
{

· · ·

}

It is well known that the (randomized) classical communication complexity of the disjointness
function is Θ(k) [Raz92], while its quantum communication complexity is Θ(√k) [AA03, Raz03].
Braverman, Garg, Ko, Mao and Touchette further proved an almost tight lower bound on the
bounded-round quantum communication complexity of disjointness.

Lemma 2.5 ([BGK+18]). The r-round quantum communication complexity of disjointness DISJk
is Ω

(cid:16) k

(cid:17)

.

r log8 r + r

The classical lower bound of the disjointness has been widely applied to obtain numerous tight
lower bounds in the classical CONGEST model. However, its quantum lower bound seems to not
always have enough capability to capture the hardness in the quantum CONGEST model. We
further introduce the intersection function and its quantum communication complexity.

Deﬁnition 2.6 (Intersection). For an integer k
k
INTk,ρ :
× {
{
number of indices p

0, 1
}
[k] with xp = yp = 1 is less than ρ.

0, 1
}

0, 1
}

→ {

≥

k

k, the intersection function
≤
is the function such that INTk,ρ(x, y) = 0 if and only if the

1 and 1

≤

ρ

∈

Lemma 2.7 ([Raz03]). The quantum communication complexity of the intersection function INTk,ρ
is Ω(√kρ) if ρ

ρ) if ρ > k/2.

k/2, and Ω(k

≤

−

3 Warm up

Based on Grover’s search for the maximum eccentricities over all nodes, Le Gall and Magniez [GM18]
proposed a distributed quantum algorithm of computing the exact diameter within ˜O(√nD) rounds
in the CONGEST model, where D is the diameter of the network. Similarly, apply Grover’s search
for the minimum eccentricities over all nodes, we can obtain an ˜O(√nD)-round distributed algo-
rithm to compute the exact radius of the network.

The diameter is the maximum eccentricities over all nodes and the radius is the minimum
eccentricities over all nodes. These two parameters have many similar properties. Before we
introduce the lower bound of radius computation, we should know about how to prove the lower
bound of the diameter computation.

G

Let

d be a line network, which consists of d + 1 nodes, denoted by A0, . . . , Ad. Here A0 and
d is a
Ad are the two end points and A1, . . . , Ad−1 are the intermediate nodes. Each edge of
G
k,
0, 1
quantum channel of bandwidth B qubits. The nodes A0 and Ad receive k-bit inputs x, y
}
∈ {
respectively. The disjointness on a line Lk,d is a computational problem over the network
d that
G
requires to compute the DISJk(x, y). We say an algorithm solves Lk,d with probability p, if there
exists a node outputs the right answer with probability at least p. The following lemma relates the
round complexity of Lk,d to the two-party communication complexity of DISJk(x, y).

6

Lemma 3.1 ([GM18]). Let d and r be any positive integers. If there exists an r-round quantum
distributed algorithm, in which each intermediate node uses at most s qubits of memory, that com-
putes function Lk,d over
d with probability p, then there exists a O(r/d)-round two-party quantum
protocol computing DISJk with probability p using O(r(B + s)) qubits of communication, where
bandwidth B = Θ(log n) in the CONGEST model.

G

Le Gall and Magniez [GM18] showed that any quantum distributed algorithm that computing
nD/s) rounds if each node uses at most s qubits of

the diameter of the network requires ˜Ω(
memory where D is the diameter of the network via a reduction from disjointness on a line Lk,d

(cid:112)

In [ACK16], the authors also exhibited a reduction from disjointness to diameter computation
[ACK16]. Thus Lemma 2.5 implies that computing the diameter need ˜Ω(√n) rounds without
memory restriction.

Magniez and Nayak [MN20] proved a new lower bound of the disjointness on a line (lemma
3.2) and established a new lower bound ˜Ω( 3√nD2 + √n) for the diameter in the CONGEST model
without memory restriction.

Lemma 3.2 ([MN20]). Any quantum communication protocol with error probability at most 1/3
for the disjointness on the line Lk,d requires Ω( 3(cid:112)
kD2/B) rounds, where B is the the bandwidth of
each communication channel.

Based on the approach of proving the lower bound of computing the diameter, we can directly

obtain the the following theorem.

Theorem 3.3. The number of rounds needed for any quantum protocol to compute the radius of
a sparse network in the CONGEST model is ˜Ω(√n + 3√nD2), where D denotes the diameter of
the network. If each node uses at most s qubits of memory, computing the radius of the network
requires ˜Ω(

nD/s) rounds.

(cid:112)

0, 1

∈ {

∈ {

0, 1
}

n and y

Proof. First of all, there exists a graph G reducing DISJn(x, y) to radius computation [ACK16],
where the graph G has Θ(n) nodes. The graph G has two parts, one is simulated by Alice (denoted
by Ga) and the other is simulated by Bob (denoted by Gb), which has Θ(log n) edges connecting
Ga and Gb. Assume that there exists a r-round quantum distributed algorithm
that computes
the radius, we can use the algorithm to construct a protocol that computes the DISJn(x, y), where
n are Alice’s input and Bob’s input, respectively.
x
}
The protocol works as follows. Alice and Bob can jointly simulate the graph G: Alice simulates
Ga(which depends on x), while Bob simulates Gb(which depends on y). To simulate the r-round
, Alice and Bob need to exchange messages corresponding to the
quantum distributed algorithm
communication occurring along the Θ(log n) edges between Ga and Gb. Because there are Θ(log n)
channels(edges) and the bandwidth of each channel is O(log n), one round of communication in
can be replaced with two messages of O(log2 n) qubits. Finally, Alice and Bob can
algorithm
compute the radius of G, thus compute DISJn(x, y). From lemma 2.5, we conclude that r log2 n =
˜Ω( n

r + r), which implies r = ˜Ω(√n).
Replacing each edges connecting Ga and Gb with a path of length d, we obtain an instance for

A

A

A

radius computation, which is reduced from Ln,d with d = Θ(D).

We consider the following two cases.

• There is no upper bound on the memory of each node. Assume that there exists an r-round
quantum distributed algorithm that computes the radius, we can obtain an r-round protocol
for Lk,d. By Lemma 3.2, we obtain an lower bound ˜Ω( 3√nD2) as desired.

7

1. To construct an instance G = (V, E), the vertex set V are partitioned into two disjoint

sets Va and Vb;

2. Edge set E includes several edges that are independent of x and y, such as edges between

Va and Vb;

3. A set of edges between nodes in Va (resp. Vb) is created according to x (resp. y), denoted

by Ea (resp. Eb).

Figure 1: Construction of reduction graph

• Each node uses at most s qubits. By Lemma 3.1, there exists an O(r/d)-round quantum
communication protocol for DISJn(x, y) with the communication cost O(r(log2 n + s)). By
Lemma 2.5, r(log2 n + s) = ˜Ω( n
r/d + r/d), which implies r = ˜Ω(

nD/s).

(cid:112)

4 Lower bounds

We brieﬂy outline the reductions from two-party communication complexity to the computation in
the CONGEST model. And thus the lower bound on communication complexity implies the lower
bound in the CONGEST model.
Given a distributed problem

P

. For a Boolean function f :

ity to
f . The reduction is via a construction of instance G = (V, E) of
shown in Figure 1.

P

, we brieﬂy describe the reduction from communication complex-
k be the input of
}
, which consists of three steps

, let x, y

0, 1
}

0, 1
}

→ {

k
}

× {

∈ {

0, 1

0, 1

{

k

P

P

P

P

A

A

solving

If f (x, y) can be inferred from the solution of

on G for each node in Va (resp. Vb); 3) Alice and Bob obtain the solution of

on G, then the lower bound on the complexity
can be obtained from the following argument. 1) Assume that there is a r-round distributed
of
; 2) the player Alice (resp. Bob) knows x (resp. y) and simulate the execution
algorithm
of
on G and compute
f (x, y). The communication between Alice and Bob is exactly the same with the communication
between nodes in Va and Vb during running
on G. Suppose there are s edges between nodes in
Va and Vb. Recall that edges have bandwidth O(log n) in CONGEST model. The communication
complexity of f is O(rs
log n), which should be beyond any lower bound of the communication
complexity of f .

A

P

·

4.1 APSP

We follow the above framework to prove a nearly tight lower bound on the round complexity
of APSP in the quantum CONGEST model, i.e., to prove theorem 1.1 via a reduction from the
intersection functions in two-party communication setting.
, k = s(s
(cid:99)

k. Alice and Bob are
−
≥
k of the intersection function. Alice and Bob who receive
given an instance (x, y)
binary string x, y of length k respectively, are supposed to compute INTk,ρ (x, y). We establish the

5 be an integer. Set s =

(n
(cid:98)
0, 1
}

1)/2 and ρ

0, 1
}

Let n

1)/2

× {

∈ {

≤

−

k

8

{

}

· · ·

(cid:93)
, bs

a0, a1, a2,

Vb where Va =

V
|
and Vb =

reduction by ﬁrst constructing an instance G = (V, E) of APSP. Let
= n. In the ﬁrst step of
Figure 1, partition V = Va
if n
}
is even, or Vb =
b1, b2,
if n is odd. Next, if n is even, we include all (a0, ai), (b0, bi) and
{
[s]. If n is odd, we include all (a0, ai) and (ai, bi) in E. The rest of edges are
(ai, bi) in E for i
∈
k. Notice that k = s(s
1)/2. There are k pairs
0, 1
constructed according to the inputs x, y
}
of distinct indices in [s]. Each pair (i, j) with 1
s is associated with an unique index
≤
p
[k], and the existence of the edge (ai, aj) (resp. (bi, bj)) is determined by xp (resp. yp). More
precisely, suppose these pairs (i, j) are sorted in lexicographic order, and (ip, jp) denotes the pth
[k], if xp = 0, Alice adds an edge between aip and ajp into E. If yp = 0, Bob adds an
pair. For p
edge (bip, bjp). Formally, we have

b0, b1, b2,

i < j

∈ {

, as

, bs

· · ·

· · ·

−

≤

∈

∈

}

{

|

E =

(cid:91)

{

i∈[s]

(ai, bi), (a0, ai), (b0, bi)

} ∪

(cid:91)

{
p∈[k]:xp=0

(aip, ajp)

} ∪

(cid:91)

(bip, bjp)
}
{
p∈[k]:yp=0

.

An example for n = 8 (and thus k = 3), x = (0, 1, 0) and y = (1, 1, 0) can be found in ﬁgure 2.

Figure 2: An example of reduction graph (APSP)

Proposition 4.1. For 1
(ip, jp) = (i, j). If xp = yp = 1, d(ai, bj) = 3, otherwise d(ai, bj) = 2.

i < j

≤

≤

s, suppose (i, j) is the pth pair in lexicographic order, i.e.,

Proof. We use the graphical notation u
v to denote an edge (u, v) traversed in a path. There is
always a path of the form (ai
3. If xp = yp = 1, ai and bj share no
aj
common neighbour, and thus d(ai, bj) = 3. Otherwise they share a common neighbour aj if xp = 0,
or bi if yp = 0, and thus d(ai, bj) = 2.

bj), so d(ai, bj)

→

→

→

→

a0

≤

So the number of (i, j) such that 1

[k] with xp = yp = 1, or the size of the intersection of x and y.

s and d(ai, bj) = 3 is the same with the number
of p
can be inferred from
the solution of APSP, and so does INTk,ρ(x, y) for any ρ. We are now ready to prove the quantum
lower bound of APSP.

i < j

≤

≤

∈

∩

x

y

|

|

Proof of Theorem 1.1. Let
5,
we set parameters s =
1)/2. Alice and Bob, respectively receiving
x and y, compute INTk,ρ(x, y) by exchanging quantum messages. They construct the instance
G = (Va
on the nodes of Va. Bob
(cid:93)
does the same for Vb.

be an r-round quantum protocol which computes APSP. For n
1)/2
(cid:99)

Vb, E) described above. We will show how Alice simulates

and k = s(s

A
−

(n

A

−

≥

At the tth round, for each message sent to a node in Vb by some node in Va while executing the
, Alice sends the same message to Bob along with the ID of the receiver. For each

tth round of

(cid:98)

A

9

a0a1a2a3b0b1b2b3message received from Bob, Alice “virtually” allocate it to the corresponding node. Communication
inside Va and local computation on nodes of Va can be done without communicating with Bob.

≤

≤

A

, Alice knows d(ai, bj) for i, j

s and d(ai, bj) = 3 to obtain

After simulating
i < j

[s]. She counts the number of (i, j) such that
1
and decide INTk,ρ(x, y) for any ρ. The quantum
|
communication complexity between Alice and Bob is basically the same with the number of qubits
passing over edges between Va and Vb while simulating
. The set of edges between Va and Vb
A
is of r rounds and edges have bandwidth
is
log n). By
O(log n) qubits. For any ρ, the quantum communication complexity of INTk,ρ is O(rs
setting ρ =
log n ) as
(cid:98)
s = Θ(n) and k = Θ(n2).

, Lemma 2.7 gives a lower bound Ω(k). Therefore, r = Ω(
(cid:99)

, which is of size s. Recall that

s·log n ) = Ω( n

(ai, bi) : i

[s]
}

k/2

x
|

A

∈

∈

∩

{

y

k

·

4.2 Eccentricities

To prove the quantum lower bounds of computing the exact and approximate eccentricities shown
in Theorem 1.2 and Theorem 1.3, we again establish a reduction from the intersection function,
and construct an underlying network graph following the idea of [ACK16].

4.2.1 Exact eccentricities

≥

23 be an integer, we construct an instance G = (V, E) of n nodes. In the ﬁrst step of

Let n
construction in Figure 1, we set k to be the maximum integer satisfying 3k+4(
n, and set s =

+ 1, n(cid:48) = 3k + 4s + 6, V = Va

log2(k
(cid:98)

1)
(cid:99)

−

+1)+6

≤

Vb where

log2(k

(cid:98)

−

1)
(cid:99)
(cid:91)

Va =

Vb =

p∈[k]
(cid:91)

p∈[k]

ap

{

} ∪

bp

{

} ∪

(cid:91)

i∈[s]
(cid:91)

i∈[s]

i , a1
a0

i } ∪ {

{

1, a(cid:48)
a(cid:48)

3} ∪

(cid:91)

a(cid:48)(cid:48)
,
i }
{

(cid:93)
2, a(cid:48)

i , b1
b0
{

i } ∪ {

1, b(cid:48)
b(cid:48)

2, b(cid:48)

3} ∪

i∈[n−n(cid:48)]
(cid:91)
b(cid:48)(cid:48)
p}
{

.

p∈[k]

the edges independent of x and y. For each p

We include some additional nodes a(cid:48)(cid:48)
1,

, a(cid:48)(cid:48)
For convenience, let B(p, i) denote the ith bit in binary expression of integer p

n−n(cid:48) in V so that

= n.

V
|

· · ·

|

∈

[s]. Moreover, ap and a(cid:48)

are added according to binary expression of integer p
1, a(cid:48)
i
are linked in a similar way except that bp is connected to b(cid:48)(cid:48)
connected to a(cid:48)(cid:48)
[n
∈
i and b0
are added. a0
i are connected for each i

i for each i
i , a1

i and b1

2 and a(cid:48)

1 and a(cid:48)

2, a(cid:48)

−

[s].

∈

−

[k], edges between ap and nodes in (cid:85)

1. We describe
i , a1
a0
i }
for each
3 are all connected. Edges between nodes of Vb
1 is
3 and b(cid:48)
3

1, i.e., ap is connected to a

[k]. In addition, a(cid:48)

p for each p

B(p,i)
i

i∈[s]{

−

∈

n(cid:48)]. As for edges between Va and Vb, an edge linking a(cid:48)

Given inputs x and y, Alice and Bob construct the rest of edges. For p

∈

[k], Alice adds an

∈

edge (ap, a(cid:48)

3) if xp = 1, and Bob adds an edge (bp, b(cid:48)

3) if yp = 1.

10

Formally, we have E = Ea

(cid:93)

Eb

Ec where

Ea =

Eb =

(cid:91)

{
p∈[k]:xp=1
(cid:91)

∪

p∈[k]
(cid:91)

{
p∈[k]:yp=1
(cid:91)

∪

p∈[k]

(cid:93)
(ap, a(cid:48)
3)

} ∪

(ap, a(cid:48)
1)
{

} ∪ {

(cid:91)

B(p,i)
(ap, a
i

)

{

}

p∈[k],i∈[s]
2), (a(cid:48)
1, a(cid:48)
(a(cid:48)

2, a(cid:48)
3)

(cid:91)

i∈[n−n(cid:48)]

(a(cid:48)

1, a(cid:48)(cid:48)
i )
}

,

{

} ∪

(bp, b(cid:48)
3)

} ∪

(cid:91)

B(p,i)
(bp, b
i
{

)
}

p∈[k],i∈[s]
2), (b(cid:48)
1, b(cid:48)
(b(cid:48)

2, b(cid:48)
3)

(bp, b(cid:48)
1)
{

} ∪ {

(cid:91)

{

p∈[k]

(bp, b(cid:48)(cid:48)
p)

,
}

} ∪

Ec =

(cid:91)

{

i∈[s]

(a0

i , b1

i ), (a1

i , b0
i )

(a(cid:48)

3, b(cid:48)
3)
}

.

} ∪ {

See also Figure 3 for better understanding. The set of red lines is an example of edges added
according to x and y.

Figure 3: Reduction graph (eccentricity)

Proposition 4.2. For p

∈
Proof. There are paths (ap
aq) for each q
(ap

a(cid:48)
1 →

→

→
∈
(cid:91)

a(cid:48)
1 →
p
[k]
}
\ {
1, a(cid:48)
a(cid:48)

aq

{

} ∪ {

q∈[k]

v

∀

∈

[k], d(ap, b(cid:48)(cid:48)
p)

≤

6 and d(ap, v)

5 for v

≤
b(cid:48)
2), (ap

a(cid:48)
1 →

→

∈

[V ]

\ {

b(cid:48)(cid:48)
.
p}
a(cid:48)(cid:48)
i ) for each i

a(cid:48)
2 →
. Hence,

a(cid:48)
3 →

b(cid:48)
3 →

[n

−

∈

n(cid:48)] and

2, a(cid:48)

3, b(cid:48)

3, b(cid:48)

2} ∪

(cid:91)

i∈[n−n(cid:48)]

a(cid:48)(cid:48)
i }

{

, d(ap, v)

5.

≤

0,
Since s =
∈ {
the ith bit in binary expression of x (y) is 0 (1). And thus indices q0 = x + 1

[s], one can always ﬁnd integers x, y

+ 1, for i

log2(k

1)
(cid:99)

−

∈

(cid:98)

, k

1
}
[k], q1 = y + 1

such that
[k]

−

· · ·
∈

∈

11

a01a11a02a12b11b01b12b02......a0sb1sa1sb0sa2akb2bka1b1......a001a002···a01a02a03b03b02b01b001b002b00k...satisfying B(q0, i) = 0 and B(q1, i) = 1. There are paths (ap
(ap

b0
i ). Hence,

aq1

a(cid:48)
1 →

→

a1
i →

→

a(cid:48)
1 →

→

aq0

a0
i →

→

b1
i ) and

v

∀

∈

(cid:91)

i∈[s]

i , a1
a0
{

i , b0

i , b1
i }

, d(ap, v)

4.

≤

[s] such that B(p, i)

= B(q, i). There is a path

For q
(ap

[k]
B(p,i)
i

\ {

∈
a

→

p

, one can always ﬁnd an index i
}
B(q,i)
b(cid:48)
b
1 →
i
→
→
3, d(ap, b(cid:48)
1)

→
d(ap, bq)

→

bp

bq

∈
b(cid:48)(cid:48)
p) and thus

4, d(ap, bp)

≤

≤

Since b(cid:48)(cid:48)

q is a neighbour of bq, d(ap, b(cid:48)(cid:48)
q )

4.

Proposition 4.3. For p

∈

≤
[k], d(ap, b(cid:48)(cid:48)
p) < 6 if and only if xp = yp = 1.

5, d(ap, b(cid:48)(cid:48)
p)

6.

≤

≤

For q

p and d(ap, b(cid:48)(cid:48)

p) = d(ap, bp) + 1. If xp = yp = 1, there is a path (ap

Proof. It is equivalent to prove d(ap, bp) < 5 if and only if xp = yp = 1 because bp is the only
neighbour of b(cid:48)(cid:48)
bp)
and thus d(ap, bp)

3. We now only need to prove the necessity.
≤
, obviously d(ap, aq) = d(bp, bq) = 2. Furthermore, d(ap, bq) = 3 because there
p
}
is a path of length 3 between ap and bq, and they share no neighbour. d(aq, bp) = 3 by symmetry.
We use the graphical notation u (cid:59) v to denote any shortest path from u to v. If edge (a(cid:48)
3, b(cid:48)
3)
is excluded from E, the shortest path between ap and bp will be of the form (ap (cid:59) aq (cid:59) bp) or
(ap (cid:59) bq (cid:59) bp) for some q

a(cid:48)
3 →

b(cid:48)
3 →

\ {

[k]

[k]

→

∈

p

Now we consider paths between ap and bp where edge (a(cid:48)

3, b(cid:48)
(cid:59) bp). We use the following fact: d(ap, a(cid:48)

3) is involved. Such paths are of the
3) = 3 if xp = 0 and d(ap, a(cid:48)
3) = 1 if
3) = 1 if yp = 1. Thus, such paths have length less than 5

form (ap (cid:59) a(cid:48)
xp = 1; d(bp, b(cid:48)
if and only if xp = yp = 1.

b(cid:48)
3

3 →
3) = 3 if yp = 0 and d(bp, b(cid:48)

. Such paths are of length 5.
}

∈

\ {

A corollary of Proposition 4.2 and Proposition 4.3 tells that for any p

[k], ap has eccentricity
[k] such
less than 6, i.e., e(ap) < 6, if xp = yp = 1, and e(ap) = 6 otherwise. So the number of p
that e(ap) < 6 is the same with the number of p
[k] with xp = yp = 1. And for any ρ, INTk,ρ(x, y)
∈
can be inferred by computing eccentricities. We are ready to prove the quantum lower bound of
computing exact eccentricities.

∈

∈

A

on the instance G = (Va

Proof of Theorem 1.2. Let
be any r-round quantum protocol which computes the exact eccen-
tricity for each node. By the same argument mentioned in the proof of Theorem 1.1, Alice and Bob
Ec) described above. After that, Alice knows
simulate
Eb
A
e(ap) for p
.
|
∈
Recall that k = Θ(n) and the set of edges between nodes simulated by Alice and those simulated by
Bob, which is Ec, is of size Θ(s) = Θ(log k) = Θ(log n). The quantum communication complexity
of INTk,ρ is O(r

(cid:93)
[k] satisfying e(ap) < 6, she can obtain

log2 n) for any ρ. Combining Lemma 2.7, r = Ω(

(cid:93)
[k]. By counting the number of p

Vb, Ea

(cid:93)

∈

∩

x

y

k

|

log2 n ) = Ω( n

log2 n ).

·

4.2.2 Approximate eccentricities

The above argument can be extended to prove a more general quantum lower bound of approxi-
mating eccentricities by introducing a parameter (cid:96) and replacing some edges of instance G = (V, E)
with paths of length (cid:96). More speciﬁcally, except for edges between Va and Vb, i.e., edges in Ec,
and edges between a(cid:48)
n−n(cid:48), other edges (including the edges added

1 and additional nodes a(cid:48)(cid:48)
1,

, a(cid:48)(cid:48)

· · ·

12

(cid:54)
according to x and y) are all replaced with paths containing (cid:96)
3k + 2ks + 4 +
|
of nodes, we redeﬁne some parameters.

1 intermediate nodes. There are
edges needed to be replaced. Since the replacement may change the number

x
|

−

+

y

|

|

Let n

31(cid:96)
maximum integer satisfying

−

≥

8 be an integer where (cid:96)

1)
(cid:99)

−

+ 1) + 6 + ((cid:96)

3k + 4(

log2(k
(cid:98)
log2(k
(cid:98)

and set s =
−
n(cid:48) additional nodes to make sure
n
|
except that intermediate nodes are added.

1)
(cid:99)

V
|

−

+ 1, n(cid:48) = 3k + 4s + 6 + ((cid:96)

1 is an undetermined parameter. We set k to be the

1)(3k + 2k(

log2(k
(cid:98)

1)
(cid:99)

−

+ 1) + 4 + 2k)

n,

≤

(1)

≥

−

). We again include
x
|
|
= n. The instance G is constructed in the same way

1)(3k + 2ks + 4 +

y
|

−

+

|

By following the argument in the proof of Proposition 4.2, for p

[k], we have:

∈

q
v
i
i
q
q

∀
∀
∀
∀
∀
∀

[k],
∈
1, a(cid:48)
a(cid:48)
∈ {
[n
−
∈
[s], v
∈
[k]
∈
[k]
∈

\ {
\ {

,

3, b(cid:48)

2, a(cid:48)
n(cid:48)],

3}
i , b0
i , a1
a0
∈ {
,
p
}
,
p
}

i , b1
i }

d(ap, aq)
≤
d(ap, v)
≤
d(ap, a(cid:48)(cid:48)
i )
≤
, d(ap, v)
≤
d(ap, bq)
≤
d(ap, b(cid:48)(cid:48)
q )
≤
d(ap, b(cid:48)
1)
≤
4(cid:96) + 1 and d(ap, b(cid:48)(cid:48)
p) = d(ap, bp) + 1

2(cid:96);
3(cid:96) + 1;
(cid:96) + 1;
3(cid:96) + 1;
2(cid:96) + 1;
3(cid:96) + 1;
3(cid:96) + 1.

Moreover, d(ap, b(cid:48)

d(ap, b(cid:48)
By following the argument in proving Proposition 4.3, we have:

2), d(ap, bp)

1) + 1

≤

≤

5(cid:96) + 1.

≤

if xp = yp = 1, d(ap, b(cid:48)
d(ap, b(cid:48)(cid:48)
otherwise

2) = d(ap, bp) = 2(cid:96) + 1, d(ap, b(cid:48)(cid:48)
p) = 5(cid:96) + 1.

p) = 3(cid:96) + 1;

Thus, e(ap) = 3(cid:96) + 1 if xp = yp = 1 and e(ap) = 5(cid:96) + 1 otherwise. We omit intermediate nodes
because the eccentricity of ap cannot be achieved by any intermediate nodes. The ratio of the
eccentricity of ap in the case xp = 0 or yp = 0 and the one in the case xp = yp = 1 is 5(cid:96)+1
ε
when (cid:96) is suﬃciently large. Thus, an algorithm of eccentricities with an approximation ratio better
than 5
3 will induce a quantum communication protocol for the intersection function with inputs x
and y.

3(cid:96)+1 = 5

3 −

Proof of Theorem 1.3. For any constant 0 < ε < 2
be any r-round quantum
protocol which computes a ( 5
on the
ε)-approximation of the eccentricity
instance G described above, Alice knows, for each p
of ap, which is denoted by ˆe(ap). As e(ap) = 3(cid:96) + 1 if xp = yp = 1 and e(ap) = 5(cid:96) + 1 otherwise, we
have:

(cid:100)
ε)-approximation of the eccentricities. After simulating

3 set (cid:96) =

[k], a ( 5

2
9ε (cid:101)

3 −

, let

3 −

A

A

∈

if xp = yp = 1,
otherwise

1
5/3−ε ·
1
5/3−ε ·

(3(cid:96) + 1)
(5(cid:96) + 1)

ˆe(ap)
ˆe(ap)

≤
≤

≤
≤

3(cid:96) + 1;
5(cid:96) + 1.

Note that 3(cid:96) + 1 < 1
. Thus
y
x
|
|
log n) for
we obtain a quantum communication protocol for INTk,ρ with communication cost O(rs
cn
any ρ > 0. Combining Lemma 2.7, r = Ω(
log n for some
absolute constant c. We conclude that r = Ω( n

(5(cid:96) + 1) for the choice of (cid:96). Alice and Bob are able to output

log k·log n ). From Eq. (1) k

5/3−ε ·

∩
·

≥

k

k

s·log n ) = Ω(
log3 n ).

13

5 Summary and Open Problems

In this paper, we give nearly tight bounds on the complexity of the eccentricities and all pairs
shortest paths in the quantum CONGEST model and prove that there is no quantum speedup
In contrast, the computation of diameter and radius have lower round
for these two problems.
complexity in the quantum CONGEST model than classical CONGEST model when the diameter
is small [GM18]. It is interesting that quantum communication plays diﬀerent role for diﬀerent
distance parameters.

For now we only consider the round complexity of the distance parameters of the unweighted
network in the quantum CONGEST models. Whether there is quantum speedup for diameter
computation in weighted network is still an open problem.

Acknowledgment

This work is supported by the National Key R&D Program of China 2018YFB1003202, National
Natural Science Foundation of China (Grant No. 61972191), the Program for Innovative Talents
and Entrepreneur in Jiangsu and Anhui Initiative in Quantum Information Technologies Grant No.
AHY150100.

14

References

[AA03]

S. Aaronson and A. Ambainis. Quantum search of spatial regions. In Proceedings of the
44th Annual IEEE Symposium on Foundations of Computer Science, pages 200–209,
2003.

[ACHD+20] Bertie Ancona, Keren Censor-Hillel, Mina Dalirrooyfard, Yuval Efron, and Vir-
arXiv preprint

ginia Vassilevska Williams. Distributed distance approximation.
arXiv:2011.05066, 2020.

[ACK16]

Amir Abboud, Keren Censor-Hillel, and Seri Khoury. Near-linear lower bounds for
distributed distance computations, even in sparse networks.
In Cyril Gavoille and
David Ilcinkas, editors, Distributed Computing - 30th International Symposium, DISC
2016, Paris, France, September 27-29, 2016. Proceedings, volume 9888 of Lecture
Notes in Computer Science, pages 29–42. Springer, 2016.

[BGK+18] Mark Braverman, Ankit Garg, Young Kun Ko, Jieming Mao, and Dave Touchette.
Near-optimal bounds on the bounded-round quantum communication complexity of
disjointness. SIAM Journal on Computing, 47(6):2277–2314, 2018.

[EKNP14] Michael Elkin, Hartmut Klauck, Danupon Nanongkai, and Gopal Pandurangan. Can
In Proceedings of the
quantum communication speed up distributed computation?
2014 ACM Symposium on Principles of Distributed Computing(PODC), pages 166–
175, 2014.

[FHW12]

Silvio Frischknecht, Stephan Holzer, and Roger Wattenhofer. Networks cannot com-
pute their diameter in sublinear time. In Proceedings of the 23rd Annual ACM-SIAM
Symposium on Discrete Algorithms(SODA), pages 1150–1162, 2012.

[GM18]

[Gro96]

Fran¸cois Le Gall and Fr´ed´eric Magniez. Sublinear-time quantum computation of the
diameter in CONGEST networks. In Proceedings of the 2018 ACM Symposium on
Principles of Distributed Computing(PODC), pages 337–346, 2018.

Lov K. Grover. A fast quantum mechanical algorithm for database search. In Pro-
ceedings of the 28th Annual ACM Symposium on the Theory of Computing(STOC),
pages 212–219, 1996.

[HPRW14] Stephan Holzer, David Peleg, Liam Roditty, and Roger Wattenhofer. Distributed 3/2-
approximation of the diameter. In Proceedings of the 28th International Symposium
on Distributed Computing(DISC), pages 562–564, 2014.

[HW12]

[MN20]

Stephan Holzer and Roger Wattenhofer. Optimal distributed all pairs shortest paths
and applications. In Proceedings of the 2012 ACM symposium on Principles of Dis-
tributed Computing(PODC), pages 355–364, 2012.

Fr´ed´eric Magniez and Ashwin Nayak. Quantum distributed complexity of set disjoint-
ness on a line. In Artur Czumaj, Anuj Dawar, and Emanuela Merelli, editors, 47th
International Colloquium on Automata, Languages, and Programming, ICALP 2020,
July 8-11, 2020, Saarbr¨ucken, Germany (Virtual Conference), volume 168 of LIPIcs,
pages 82:1–82:18. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2020.

15

[PRT12]

[Raz92]

[Raz03]

[Yao79]

David Peleg, Liam Roditty, and Elad Tal. Distributed algorithms for network diameter
and girth. In Proceedings of the International Colloquium on Automata, Languages,
and Programming(ICALP), pages 660–672, 2012.

A. A. Razborov. On the distributional complexity of disjointness. Theoretical Com-
puter Science, 106(2):385–390, 1992.

Alexander A. Razborov. Quantum communication complexity of symmetric predi-
cates. Izvestiya Mathematics, pages 159–176, 2003.

Andrew Chi-Chih Yao. Some complexity questions related to distributive computing
(preliminary report). In Proceedings of the 11th annual ACM Symposium on Theory
of Computing(STOC), pages 209–213, 1979.

[Yao93]

A Chi-Chih Yao. Quantum circuit complexity. In Proceedings of 34th Annual IEEE
Symposium on Foundations of Computer Science(FOCS), pages 352–361, 1993.

16

