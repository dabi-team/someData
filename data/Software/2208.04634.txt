On Composing Communicating Systems*

Franco Barbanera
Dept. of Mathematics and Computer Science, University of Catania (Italy)

Ivan Lanese
Focus Team, University of Bologna/INRIA (Italy)

Emilio Tuosto
Gran Sasso Science Institute (Italy)

Communication is an essential element of modern software, yet programming and analysing com-
municating systems are difﬁcult tasks. A reason for this difﬁculty is the lack of compositional mech-
anisms that preserve relevant communication properties.

This problem has been recently addressed for the well-known model of communicating systems,
that is sets of components consisting of ﬁnite-state machines capable of exchanging messages. The
main idea of this approach is to take two systems, select a participant from each of them, and derive
from those participants a pair of coupled gateways connecting the two systems. More precisely, a
message directed to one of the gateways is forwarded to the gateway in the other system, which
sends it to the other system. It has been shown that, under some suitable compatibility conditions
between gateways, this composition mechanism preserves deadlock freedom for asynchronous as
well as symmetric synchronous communications (where sender and receiver play the same part in
determining which message to exchange).

This paper considers the case of asymmetric synchronous communications where senders decide
independently which message should be exchanged. We show here that preservation of lock free-
dom requires sequentiality of gateways, while this is not needed for preservation of either deadlock
freedom or strong lock freedom.

1

Introduction

Communication is an essential constitutive element of modern software due to the fact that applications
are increasingly developed in distributed architectures (e.g., service-oriented architectures, microser-
vices, cloud, etc.). In practice, APIs and libraries featuring different communication mechanisms are
available for practically any programming language.

Reasoning on and developing communicating systems are difﬁcult endeavours. Indeed, several mod-
els have been used to study interactions between systems (e.g., process algebras, transition systems,
Petri nets, logical frameworks, etc.). The so-called business logic, necessary to determine what has to be
communicated, needs to be complemented with the so-called application level protocol specifying how
information spreads across a system. Conceptual and programming errors may occur in the realisation of
application level protocols. For instance, it may happen that some components in a system are prevented
to communicate because all the expected partners terminated their execution (deadlock). Other typical
errors occur when a system is not lock-free, that is when some components cannot progress because
all their partners are perpetually involved in other communications. These kinds of problems can arise

* Research partly supported by the EU H2020 RISE programme under the Marie Skłodowska-Curie grant agreement No
778233, by the MIUR project PRIN 2017FTXR7S “IT-MaTTerS” (Methods and Tools for Trustworthy Smart Systems) and by
the Progetto di Ateneo “Piaceri”. The authors have also been partially supported by INdAM as members of GNCS (Gruppo
Nazionale per il Calcolo Scientiﬁco). The authors thanks the reviewers for their helpful comments and also Mariangiola Dezani
for her support.

C. Aubert, C. Di Giusto, L. Saﬁna & A. Scalas (Eds.):
15th Interaction and Concurrency Experience (ICE 2022)
EPTCS 365, 2022, pp. 53–68, doi:10.4204/EPTCS.365.4

© F. Barbanera, I. Lanese, E. Tuosto
This work is licensed under the
Creative Commons Attribution License.

54

OnComposing Communicating Systems

when a system can evolve in different ways depending on some conditions and components have incon-
sistent “views” of the state of the system. If this happens, some components may reach a state no longer
“compatible” with the state of their partners and therefore communications do not happen as expected.

We illustrate these problems with some simple examples for deadlock freedom (similar examples
may be given for lock freedom). Suppose we want to model a client-server system where clients’ requests
are acknowledged either with an answer or with “unknown” from servers. Due to its popularity, we
choose CCS [17] to introduce this scenario, so take the following agents:

C = ¯r.a + ¯r.u

and

D = r.¯a + r.¯u

(1)

where ports r, a, and u are respectively used to commmunicate requests, answers, and unknowns. (Recall
that in CCS a. and + represent respectively preﬁx and non-deterministic choice.) The common
interpretation of agents in (1) is that x and ¯x respectively represent an input and an output on port x. It is
a simple observation that the system C | D where C and D run in parallel can evolve to e.g., the deadlock
state a | ¯u where each party is waiting for the other to progress. The problem is that the choice of what
communication should happen after a request is taken independently by C and D instead of letting D to
take the decision and drive C “on the right” branch. This is attempted in the next version:

C = ¯r.(a + u)

and

D = r.(¯a + ¯u)

(2)

A key difference with the agents in (1) is that the server D in (2) decides what to reply to the client
C, which becomes aware of the choice through the interaction with D after the request has been made.
Assume now that D acts as a proxy to another server, say D′. When D cannot return an answer to the
client C it interacts with D′ on port p. Answers are sent directly to C if D′ can compute them, otherwise
D′ returns an unknown on port u′ to D which forwards it to C. This is modelled by the agents

D = r.(¯a + ¯p.u′.¯u)

and

D′ = p.(¯a + ¯u′)

(3)

Note that this change is completely transparent to agent C, which in fact stays as in (2). It is now more
difﬁcult to ascertain if these choices may lead to a deadlock since the decision of D may involve also D′.
Indeed, the parallel composition of agents in (3) may deadlock because, when C and D interact on port
a, D′ hangs on port p and, likewise, if C and D′ interact on port a then D hangs on port u′.

A reason for this difﬁculty is that it is hard to deﬁne compositional mechanisms that preserve relevant
communication properties such as deadlock or lock freedom. Recently, an approach to the composition
of concurrent and distributed systems has been proposed in [2, 3] for the well-known model of systems
of communicating ﬁnite-state machines (CFSMs) [12], that is sets of ﬁnite-state automata capable of
exchanging messages. The compositional mechanism is based on the idea that two given systems, say S
and S′, are composed by transforming two CFSMs, say H in S and K in S′, into “coupled forwarders”.
Basically, each message that H receives from a machine in S is forwarded to K and vice versa. It has
been shown that, under suitable compatibility conditions between H and K, this composition mechanism
preserves deadlock freedom for asynchronous as well as symmetric synchronous communications (where
sender and receiver play the same part in determining which message to exchange). The compatibility
condition identiﬁed in [2, 3] consists in exhibiting essentially dual behaviours: gateway H is able to
receive a message whenever gateway K is willing to send one and vice versa. As observed in [4], a
remarkable feature of such an approach is that it enables the composition of systems originally designed
as closed systems. As far as two compatible machines can be found, any two systems can be composed
by transforming as hinted above the compatible machines.

F.Barbanera, I.Lanese, E.Tuosto

55

The results in [2, 3] are developed in the asynchronous semantics of CFSMs. These results have been
transferred in [5] to a setting where CFSMs communicate synchronously much like as the communication
mechanisms considered for instance in process algebras like CCS, ACP, etc. This model assumes a
perfect symmetry between sender and receiver in synchronous communications. Let us again discuss
this with an example. Consider the agents

T = ¯a.P + ¯b.Q

and

R = a.P′ + b.Q′

(4)

According to the standard semantics of CCS [17], system (T | R) \ { a, b } has two possible evolutions:

(T | R) \ { a, b }

τ
−→ P | P′

and

(T | R) \ { a, b }

τ
−→ Q | Q′

namely, either both T and R opt for the “leftmost” branch (synchronising on a) or they both choose the
“rightmost” one (synchronising on b). (Recall that in CCS \ X is the hiding of ports in the set X and
that τ represents an internal action.) This means that, the resolution of the choice is implicit in the com-
munication mechanism: a branch is taken as soon as T and R synchronise on the corresponding port.
Intuitively, no distinction is made between sender and receiver (formally they are indeed interchange-
able); this implies that the communication mechanism is at the very core of choice resolution [5].

Interestingly, for synchronous communications an alternative interpretation is actually possible. In-
deed, this perfect symmetry is not assumed so that sender and receiver play different roles in choice
resolution while still relying on synchronous communication. Let us explain this interpretation using
again CCS. Consider a variant of CCS where outputs must be enabled before being ﬁred. One could
formally specify that with the following reduction rules:

¯a.P + P′ τ

−→ ¯¯a.P

and

¯¯a.P | (a.Q + Q′)

τ
−→ P|Q

(5)

whereby the leftmost rule chooses one of the possible outputs of the sender (the chosen output is marked
by the double bar in our notation) and the rightmost rule actually synchronises sender and receiver. This
semantics is an abstract model of asymmetric communications (used e.g., in [8, 18]), where silent steps
taken using the left rule model some internal computation of the sender to decide what to communicate
to the partner. In other words, now the choice is entirely resolved on “one side” while the communication
is a mere interaction of complementary actions, the output and the input. This asymmetry, at the core of
asynchronous communication, can therefore also carry for synchronous communication.

It is worth observing that asymmetric communications abstract a rather common programming pat-
tern where sending components may choose the output to execute depending on some internal computa-
tion. For instance, elaborating on the proxy scenario in (3), D could decide to directly send unknowns to
normal clients while reserving the use of D′ only for “privileged” clients.

Contributions. This paper transfers the composition by gateway mechanism of [2, 3] to the case of
asymmetric synchronous communication of CFSMs. The main technical results are that, in the asym-
metric case, gateway composition

• preserves deadlock freedom (as well as a strong version of lock freedom) provided that systems are
composable (the relation of compatibility – one of the requirements for systems to be composable
– in the present paper is less restrictive than the one used in [5]);

• preserves lock freedom if systems are composable and gateways are sequential, namely each state

has at most one outgoing transition.

Interestingly, preservation of deadlock freedom can be guaranteed under milder conditions than in the
symmetric case. In fact, sequentiality of gateways is not necessary to preserve deadlock freedom in the
asymmetric case, while it is in the symmetric one.

56

OnComposing Communicating Systems

Structure of the paper. Section 2 introduces systems of (asymmetric synchronous) CFSMs, related
notions and communication properties. Composition by gateways is introduced and discussed in Sec-
tion 3 together with the compatibility relation. Section 4 discusses the issues that prevent gateway compo-
sition to preserve communication properties. Section 5 is devoted to the preservation of communication
properties. Conclusions, related and future work are discussed in Section 6. For space limitation, full
proofs are reported in [6].

2 Background

Communicating Finite State Machines (CFSMs) [12] are Finite State Automata (FSAs) where transitions
are labelled by communications. We recall basic notions on FSAs.

A ﬁnite state automaton (FSA) is a tuple A = hS , q0, L , →i where
• S is a ﬁnite set of states (ranged over by lowercase italic Latin letters);
• q0 ∈ S is the initial state;
• L is a ﬁnite set of labels
• → ⊆ S × (L ∪ {τ}) × S is a set of transitions.

Hereafter, we let λ range over L ∪ {τ} when it is immaterial to specify the set of labels or it is under-
λ
−→ q2 for the transition (q1,λ, q2) ∈ −→ , and q1 −→ q2 when there
stood. We use the usual notation q1
· be the concatenation operation on labels and write p π
exists a label λ such that q1
−→ q
λ2−→ . . . λn−→ pn = q. We let π,ψ, . . . range over L ⋆ (i.e.,
where π = λ1·λ2· . . . ·λn whenever p
sequences of labels) and deﬁne the set of reachable states in A from q as

λ
−→ q2. Let

λ1−→ p1

R(A, q) = { p (cid:12)

(cid:12) there is π ∈ L ⋆ such that q π

−→ p }

The set of reachable states in A is R(A) = R(A, q0). For succinctness, q λ
−→ q′ ∈ A means that the
transition belongs to (the set of transitions of) A; likewise, q ∈ A means that q belongs to the states of
A. We say that q λ
−→ q′ is an outgoing (resp. incoming) transition of q (resp. q′). Since we use FSAs to
formalise communicating systems, accepting states are disregarded (as also done in [12]).

We adapt the deﬁnitions in [12] to cast CFSMs in our context. Let P be a set of participants (or
roles, ranged over by A, B, etc.) and M a set of messages (ranged over by m, n, etc.). We take P and
M disjoint. An output label is written as A B!m and represents the willingness of A to send message m
to B; likewise, an input label is written as A B?m and represents the willingness of B to receive message
m from A. The subjects of an output label A B!m and of an input label A B?m are A and B, respectively.
Deﬁnition 2.1 (CFSMs). Let Lact = {A B!m, A B?m | A 6= B ∈ P, m ∈ M }. A communicating ﬁnite-
state machine (CFSM) is an FSA M with labels Lact ∪ {τ} such that, for any transition p λ

−→ q of M,

• if λ is an output label then p 6= q and p has exactly one incoming transition, and such transition

is labelled by τ;

• if λ = τ then p 6= q and q has exactly one outgoing transition, and such transition is labelled by

an output label.

A state of M is

• terminal, if it has no outgoing transition; we deﬁne T(M) = { p ∈ M (cid:12)

(cid:12) p is terminal in M }

F.Barbanera, I.Lanese, E.Tuosto

57

• sending, if it is not terminal and all its outgoing transitions have output labels

• receiving, if it is not terminal and all its outgoing transitions have input labels

• mixed, if it has a silent outgoing transition and an outgoing transition with an input label.

A CFSM is A-local if all its non τ transitions have subject A.

Unlike in [5], the transitions of our CFSMs can also be labelled by the silent action τ. Deﬁnition 2.1
can be looked at as the CFSM counterpart of the τC contracts described in [7]. Imposing the no-mixed
state condition on our CFSM, turns them into the communicating automata counterpart of the processes
(contracts) called “session behaviours”1 in e.g., [11, 1, 8]. These processes are in turn the process coun-
terpart of (binary) session types [14]. As we shall see below (and also shown in [3] and [5]), the absence
of mixed states is necessary in order to get the preservation of properties by composition. As a matter of
fact, we could drop the conditions related to τ-transitions in case a transition like p X Y!z
−−−→ q is the only
outgoing transition from p, namely when no actual choice of output actions is possible in p. We however
prefer to avoid this distinction because (i) our uniform treatment of transitions allows us to immedi-
ately adapt deﬁnitions in a more abstract setting and (ii) secondly, uniformity allows us to simplify some
technicalities. Said that, all proofs in the present paper could easily be adapted to the above mentioned
alternative deﬁnition of CFSM.

Deﬁnition 2.2 (Communicating systems). A (communicating) system over P is a map S = (MA)A∈P
assigning an A-local CFSM MA to each participant A ∈ P where P ⊆ P is ﬁnite and any participant
occurring in a transition of MA is in P.

Note that Deﬁnition 2.2 requires that any input or output label does refer to participants belonging to

the system itself. In other words, Deﬁnition 2.2 restricts to closed systems.

We deﬁne the synchronous semantics of communicating systems as an FSA (differently from the
asynchronous case, where the set of states can be inﬁnite). Hereafter, dom( f ) denotes the domain of a
function f and f [x 7→ y] denotes the update of f in a point x ∈ dom( f ) with the value y.

Deﬁnition 2.3 (Asymmetric synchronisations). Let S be a communicating system. A conﬁguration of S
is a map s = (qA)A∈dom(S) assigning a local state qA ∈ S(A) to each A ∈ dom(S).

The asymmetric synchronisations of S is the FSA JSK = hS , s0, Lint ∪ {τ}, →i where
• S is the set of synchronous conﬁgurations of S, as deﬁned above;

• s0 = (q0A)A∈dom(S) ∈ S is the initial conﬁguration where, for each A ∈ dom(S), q0A is the initial

state of S(A);

• Lint = {A−→B : m | A 6= B ∈ P and m ∈ M } is a set of interaction labels;
• s A−→B : m
• s τ

−−−−−→ s[A 7→ q, B 7→ q′] ∈ JSK if s(A)

A B!m
−−−→ q ∈ S(A) and s(B)

−→ s[A 7→ q] ∈ JSK if s(A)

τ
−→ q ∈ S(A);

A B?m
−−−−→ q′ ∈ S(B);

Conﬁguration s enables A in S if s(A) has at least an outgoing transition.

As expected, an interaction A−→B : m occurs when A performs an output A B!m (which has been

previously chosen) and B the corresponding input A B?m.

1Actually different variations of this name are used in the listed references.

58

OnComposing Communicating Systems

Example 2.4. Let us consider the communicating system S = (MX)X∈{ K,C,D,E }, where

K

0

τ

τ

n

?

D

1

K

0
0

D

K

C!m

3

D ! n

K

1

2

τ

D

E!d

2

3

E D?s

C

E

? m

C

d

?

E

K

0

D

0

C

E?c

1

1

4

τ

C

E!c

2

E C?s

3

τ

τ

2

5

E

C!s

3

D ! s

E

A sequence of transitions of JSK out of s0 is, according to Deﬁnition 2.3,

s0 = (0K, 0C, 0D, 0E)

τ
−→ (1K, 0C, 0D, 0E)
τ
−→ (3K, 2C, 0D, 0E)
τ
−→ (3K, 3C, 0D, 5E)

K−→C : m
−−−−−→ (3K, 1C, 0D, 0E)
C−→E : c
−−−−−→ (3K, 3C, 0D, 4E)
E−→D : s
−−−−−→ (3K, 3C, 3D, 3E)

⋄

The symmetric synchronisation in [5] for systems without τ-transitions can be readily obtained from

the above deﬁnition by disregarding the clause for the τ-transitions.

In the following, ptp(τ) = /0 and ptp(A−→B : m) = ptp(A B!m) = ptp(A B?m) = { A, B } and, for a

sequence π = λ1· · · · ·λn, we let ptp(π) = ∪1≤i≤nptp(λi).

As discussed in Section 1, we shall study the preservation of communication properties under com-
position. We shall consider the following relevant properties: deadlock freedom, lock freedom and
strong lock freedom. The deﬁnitions below adapt the ones in [13] to a synchronous setting (as done also
in [16, 19, 5]).

Deﬁnition 2.5 (Communication properties). Let S be a communicating system on P. We say that a
λ1−→ s1 . . . λn−→ sn of S if there is 1 ≤ i ≤ n such that either
participant A ∈ P is involved in a run s
τ
A ∈ ptp(λi) or λi = τ, si(A)
−→ q in S(A), and si+1 = si[A 7→ q].
Deadlock freedom A conﬁguration s ∈ R(JSK) is a deadlock if
• s has no outgoing transitions in JSK and
• there exists A ∈ P such that s(A) enables A in S.

A system is deadlock-free if none of its conﬁgurations is a deadlock.
Lock freedom Let A ∈ P. A conﬁguration s ∈ R(JSK) is a lock for A if

• s(A) has outgoing transitions; and
• A is not involved in any run from s.

A system is lock-free if none of its conﬁgurations is a lock for any of its participants.

Strong lock freedom System S is strongly lock-free for A ∈ P if for each s ∈ R(JSK) enabling A in S

then A is involved in all maximal sequences from s.
A system is strongly lock free if it is strongly lock free for each of its participants.

Proposition 2.6.

1. Lock-freedom implies deadlock-freedom;

2. Strong lock freedom implies lock freedom.

F.Barbanera, I.Lanese, E.Tuosto

59

Example 2.7. Let us consider the system S of Example 2.4. The only other maximal transition sequence
in JSK out of s0, besides the one described in Example 2.4, is

s0 = (0K, 0C, 0D, 0E)

τ−→ (2K, 0C, 0D, 0E)
τ−→ (3K, 0C, 2D, 0E)
τ−→ (3K, 0C, 3D, 2E)

K−→D : n
−−−−→ (3K, 0C, 1D, 0E)
D−→E : d
−−−−→ (3K, 0C, 3D, 1E)
E−→C : s
−−−−→ (3K, 3C, 3D, 3E)

These two sequences are both maximal and contain all the elements of R(JSK). By the above observa-
⋄
tions it is possible to check S to be strongly lock free.

3 Composition via Gateways

We now discuss the composition of systems of CFSMs via gateways (cf. [2, 3]) and study its properties
under asymmetric synchronisation. The main idea is that two systems of CFSMs, say S1 and S2, can be
composed by transforming one participant in each of them into gateways connected to each other.

3.1 Building gateways

Hereafter, H and K denote the selected participant in S1 and S2 respectively selected for the composition.
The gateways for H and K are connected to each other and act as forwarders: each message sent to the
gateway for H by a participant from the original system S1 is now forwarded to the gateway for K, that
in turn forwards it to the same participant to which K sent it in the original system S2. The dual will
happen to messages that the gateway for K receives from S2. A main advantage of this approach is that
no extension of the CFSM model is needed to transform systems of CFSMs, which are normally closed
systems, into open systems that can be composed. Another advantage is that the composition is fully
transparent to all participants different from H and K.

We will now deﬁne composition via gateways on systems of CFSMs, following the intuition above.
Deﬁnition 3.1 (Gateway). Given a H-local CFSM M and a participant K, the gateway of M towards K
is the CFSM gw(M, K) obtained by replacing in M
• each pair of consecutive transitions p τ

−→ q H A!m

−−−→ r with

p K H?m

−−−−→ p′ τ

−→ q H A!m

−−−→ r

• each transition p A H?m

−−−−→ r with

p A H?m

−−−−→ p′ τ

−→ p′′ H K!m

−−−→ r

for some fresh state p′

for some fresh states p′ and p′′

(6)

(7)

We shall call external the states like p and r and internal the states like p′, p′′ and q.

Note that gateways execute “segments” of the form described in (6) and (7) in the above deﬁnition.

Also, by very construction, we have the following
Fact 3.2. Given a H-local CFSM M and a participant K, each state of gw(M, K) has at most one incom-
ing or outgoing τ transition.

We compose systems with disjoint participants taking all the participants of the original systems but

H and K, whereas H and K are replaced by their respective gateways.

Given two functions f and g such that dom( f ) ∩ dom(g) = /0, we let

f + g denote the function

behaving as function f on dom( f ) and as function g on dom(g).

60

OnComposing Communicating Systems

Deﬁnition 3.3 (System composition). Let S1 and S2 be two systems with disjoint domains. The compo-
sition of S1 and S2 via H ∈ dom(S1) and K ∈ dom(S2) is deﬁned as

S1H↔K S2 = S1[H 7→ gw(S1(H), K)] + S2[K 7→ gw(S2(K), H)]

(Note that dom(S1H↔K S2) = dom(S1) ∪ dom(S2).)

We remark that, by the above approach for composition, we do not actually need to formalise the
notion of open system. In fact any closed system can be looked at as open by choosing two suitable
participants in the “to-be-connected” systems and transforming them into two forwarders. Also, note
that the notion of composition above is structural: corresponding notions of behaviourals composition
have been studied in [4] and in [15] for multiparty session types.
Example 3.4. Let us take the following two communicating systems.

1

A

H

!

m

2

2

B H!n

τ

0

0

S1 =

A

B

τ

1

The system S1

H↔K S2 is

H

0

1

B
H
?
n

A
H
?
m

S2 =

K

0

τ

τ

? m

C

1

K

0

C

gw(MH, K)

gw(MK, H)

1

2

τ

K

C!m

3

D ! n

K

E

C

E!c

2

3

D

E C?s

d

?

E

D

0

C

E?c

n

?

D

K

0
0

1

4

1

τ

τ

τ

E D?s

2

5

2

E

C!s

3

D ! s

E

D

E!d

3

1

A

H

!

m

0

B

H

?

n

0
0

H

K

?

n

τ

0

0

A

B

τ

1

A H ? m

2

τ

4

2

2

B H!n

H K ? m

5

τ

1

3

τ

5

H K!n

H

K

!

m

1

K

C
!

m

3

C

D

E

? m

C

n

d

?

D

?

E

K

0

K

0
0

D

0

C

E?c

1

1

1

4

τ

C

E!c

2

E C?s

τ

E D?s

τ

τ

3

D

E!d

2

3

2

5

E

C!s

3

D ! s

E

4

τ

2

K D!n

Note that the CFSMs A, B, C, D, and E remain unchanged.

⋄

3.2 Compatibility
A few simple auxiliary notions are useful. Let Li/o = { ?m, !m (cid:12)
io : Lact → Li/o and (·) : Li/o → Li/o as follows

(cid:12) m ∈ M } and deﬁne the functions

io(A B?m) = ?m

io(A B!m) = !m

and

?m = !m

!m = ?m

These functions extend to CFSMs in the obvious way: given a CFSM M = hS , q0, Lact, →i we deﬁne
io(M) = hS , q0, Li/o, →′i where →′= { q
−→ q′ ∈ M }
and likewise for M.

−→ q′ ∈ M,λ ∈ Lact } ∪ { q τ

io(λ)
−−−→ q′ (cid:12)

−→ q′ (cid:12)

(cid:12) q λ

(cid:12) q τ

Informally, two CFSMs M1 and M2 are compatible if each output of M1 has a corresponding input in

M2 and vice versa once the identities of communicating partners are blurred away.

F.Barbanera, I.Lanese, E.Tuosto

61

Deﬁnition 3.5 (Compatibility). Let M and M′ be two FSAs on Li/o. An io-correspondence is a relation
R between states of M and those of M′ such that whenever (q, q′) ∈ R:

• q ∈ T(M) if, and only if, q′ ∈ T(M′) (cf. Deﬁnition 2.1)
• if q !m
−−→ r ∈ M then there is q′
−−→ r′ ∈ M′ then there is q ?m
!m
−→ r ∈ M then (r, q′) ∈ R

?m
−−→ r′ ∈ M′ such that (r, r′) ∈ R

−−→ r ∈ M such that (r, r′) ∈ R

• if q′
• if q τ
• if q′ τ

−→ r′ ∈ M′ then (q, r′) ∈ R

Two CFSMs M and M′ are compatible (in symbols M≍M′) if there is an io-correspondence relating the
initial states of io(M1) and io(M′).
Example 3.6 (Compatibility). The machines H and K of Example 3.4 are compatible. For a more
complex example, consider the following CFSMs

τ

H

0

τ

1

7

H A!m

H B!m

2

8

τ

τ

3

9

H C!y

τ

4

5

H

B

!

m

6

H A!m

H C!x

10

11

τ

D K ? m

K

0

E

K

?

m

1

4

D K?x

E K?z

E K?y

2

5

D

K

?

m

3

E K ? m

The above H and K are compatible. Apart for τ actions preceding them, H can only perform output
actions, whereas K can only perform input actions. By disregarding the names of the receivers in the
actions of H, and of the senders in those of K, any output action after its corresponding τ can ﬁnd a
matching input in K. The vice versa does not hold, since none of the possible output actions that can
occur after a τ from 0 (i.e. the outputs from 1 and 7 in H) can actually match the input action E K?z from
⋄
0 in K. Such a possibility is in fact allowed by our deﬁnition of compatibility.
Deﬁnition 3.5 transfers the notion of compatibility given in [4] for processes in multiparty sessions.
Also, Deﬁnition 3.5 differs from the notions of compatibility in [5] and in [2, 3] which are deﬁned as
bisimulations and do not involve τ-transitions.

Deﬁnition 3.7. An A-local CFSM M is:

1. ?-deterministic if p X A?m
2. !-deterministic if p τ
−→
3. ?!-deterministic if it is both ?-deterministic and !-deterministic;

−−−−→ q and p Y A?m
A X!m
−−−→ q and p τ
−→

−−−−→ r ∈ M implies q = r;

A Y!m
−−−→ r ∈ M implies q = r;

A non-terminal state q ∈ M is asymmetric sending (resp. receiving) if all its outgoing transitions have
τ (resp. receiving) labels; q is a asymmetric mixed state if it is neither asymmetric sending nor receiving.

Example 3.8. Machines H and K in Example 3.6 are, respectively non !-deterministic and non ?-
deterministic. In particular, conditions (2) and (1) of Deﬁnition 3.7 fail for, respectively, state 0 of H
and state 0 of K.

We require a stronger condition then compatibity for two systems to be composable.

Deﬁnition 3.9 ((H, K)-composability). Let S1 and S2 be two systems with disjoint domains. We say that
S1 and S2 are (H, K)-composable if H ∈ dom(S1) and K ∈ dom(S2) are two compatible ?!-deterministic
machines with no asymmetric mixed states.

62

OnComposing Communicating Systems

4 Composition Related Issues

It is known that under symmetric synchronisation composition spoils deadlock-freedom; this is shown
by the example below, borrowed from [5].

Example 4.1 (Symmetric synchronisation spoils deadlock-freedom preservation). Take the systems

A

S1 =

0

1

A
H
m

!

H

A
H
?
x

0

1

m
?
H
A

and

S2 =

K

K
B

!
x

0

1

!

m
B
K

B

0

1

K
B
?
x

Clearly, S1 and S2 are (H, K)-composable and deadlock-free, yet their composition S = S1H↔K S2 has
a deadlock. In fact, when the gateway for K receives m, it tries to synchronise with participant B on
message m while B is waiting only for x. For S2 in isolation, this is not a deadlock, since B and K
⋄
synchronise on x under the symmetric semantics.
Notice that the counterexample of Example 4.1 does not apply in an asynchronous setting. Indeed,
S2 could deadlock due to the fact that K could send m without synchronising with B. Likewise, the
counterexample of Example 4.1 does not apply in our asymmetric setting. Even if communication is still
synchronous, the τ-transitions introduced to resolve internal choices (i.e., those preﬁxing outputs) allow
S2 to reach a deadlock conﬁguration by choosing the τ-transition leading to the output K B!m.

Now, one may think that analogously to what happens in [2, 3], if two systems are (H, K)-composable

and deadlock-free then their composition is deadlock-free too.

In Section 5 we shall prove that in our setting lock-freedom is preserved by composition, without
any further condition beside (H, K)-composability. Before doing that, we give examples showing the
necessity of our conditions for deadlock freedom preservation.

Let us begin with compatibility. Properties cannot be preserved under composition without compat-

ibility, as shown in the next example.

Example 4.2 (Lack of compatibility spoils deadlock freedom preservation). The systems

S1 =

A

0

0

τ

H

H A?x

1

H A!x

1

2

and

S2 =

K

0

0

τ

C K?y

1

C K!y

1

2

C

are trivially deadlock free. However, H and K are not compatible, since there is no corresponding input
in K for the output from H. The composition of S1 and S2 via H and K yields

H A?x

0

K H?x

3

A

0

1

τ

H A!x

1

2

gw(S2(K), H)

C

C K?y

τ

τ

C K!y

2

1

3

2

0

0

K H!y

1

gw(S1(H), K)

Starting from the initial conﬁguration of S1H↔K S2, the following transitions are possible in JS1H↔K S2K

(0A, 0H, 0K, 0C)

τ
−→ (0A, 0H, 0K, 1C)

C−→K : y
−−−−−→ (0A, 0H, 2K, 2C)

τ
−→ (0A, 0H, 3K, 2C) 6 −→

where (0A, 0H, 3K, 2C) is a deadlock conﬁguration for JS1H↔K S2K since K wishes to send y to H, which
⋄
is instead waiting for message x.

F.Barbanera, I.Lanese, E.Tuosto

63

The following example, casting in our setting an example given in [3] for the asynchronous seman-
tics, illustrates that asymmetric mixed states must be avoided to preserve properties under composition.

Example 4.3 (Asymmetric mixed-states spoil deadlock freedom preservation). Let S1 and S2 be

B

A

0

τ

0

τ

1

S1 =

H A?x

1

B H!y

1

2

H A!x

S2 =

2

5

B

H

?

y

3

H A!x

H

0

B

H

?

y

4

τ

D

C

0

D K ?x

K

0

τ

0

τ

1

4

K C?y

1

K D!x

2

2

5

K

C
!

y

3

D K ?x

1

τ

K C!y

Noticeably, the initial states are asymmetric mixed and H and K are compatible. The gateways are

τ

H A!x

1

6

gw(S1(H), K)

K H ?x

0

B

H

?

y

9

10

τ

H K!y

2

4

B H?y

τ

7

K H?x

11

τ

8

5

H

K

!

y

3

H A!x

D K ?x

0

τ

6

K H!x H K?y
1

8

7

gw(S2(K), H)

H

K

?

y

9

τ

4

5
K C!y D K?x

10

τ

τ

2

K

C
!

y

3

K H!x

11

The composed system S1H↔K S2 deadlocks when gw(S1(H), K) receives from B while gw(S2(K), H) re-
⋄
ceives from D since both gateways reach an output state (respectively states 10 and 7).

The following example shows that!?-nondeterminism is problematic too.

Example 4.4. Consider the two deadlock-free systems

S1 =

A

0

1

H
A
?
m

B

0

1

H
B
?
m

C

0

1

y
?
C
H

H
C
?
x

0

H

τ

H
B
m

!

7

8

τ

9

H
C
!
x

10

τ

11

H

A
!

m

6

τ

1

2

!

m
A
H

τ

3

4

y
!
C
H

τ

5

H B! m

and

S2 =

K

0

z
?
K
E

E K ? m

E
K
?
y

4

5

D

K

?

m

1

2

x
?
K
D

E

K

?

m

3

D K ? m

E

0

D

τ

τ

τ

0

1

2

3

4

5

6

D
K
m

!

D
K

!
x

D
K
m

!

The deadlock freedom of S1 follows from the fact that, from its initial conﬁguration (0A, 0B, 0C, 0H),
S1 can only branch over the two τ-transitions of H reaching either of the following conﬁgurations
(0A, 0B, 0C, 7H) or (0A, 0B, 0C, 1H). From the former (resp.
latter) conﬁguration S1 can only reach
conﬁgurations where H synchronises with C and then with A (resp. B). In either case S1 reaches the

64

OnComposing Communicating Systems

terminal conﬁguration (1A, 1B, 1C, 6H). Let us take a look at S2. The only possible transitions of S2 can
involve K and D only since E cannot synchronise being it terminated. We therefore have that

(0K, 0D, 0E)

τ
−→ (0K, 1D, 0E)
τ
−→ (2K, 5D, 0E)

D−→K : m
−−−−−−→ (1K, 2D, 0E)
D−→K : m
−−−−−−→ (3K, 6D, 0E)

τ
−→ (1K, 3D, 0E)

D−→K : x
−−−−−→ (2K, 4D, 0E)

is the only possible execution from the initial conﬁguration (0K, 0D, 0E) of S2, leading to the terminal
⋄
conﬁguration (3K, 6D, 0E).
The next example shows that the compositions of the systems S1 and S2 in Example 4.4 can deadlock.

Example 4.5 (?!-determinism is necessary). The CFSMs H and K in Example 4.4 are compatible as seen
in Example 3.6. Hence, we can build the composed system S1

H↔K S2 through the gateways

τ

13

K H ? m

gw(MH, K)

0

K

H

?

m

12

τ

1

7

H A!m

H B!m

2

8

K H?y

τ

15

K H?x

14

τ

3

9

H C!y

K H?m

4

17

τ

5

H

B

!

m

H C!x

10

K H?m

16

11

τ

and

6

H A!m

D K ? m

gw(MK, H)

0

E

K

?

m

8

6

τ

K H!m

9

E K?z

τ

7

K H!m

1

4

D K?x

14

τ

15

K H!x

τ

19

18

E K?y

10

11

τ

K H!y

2

5

D K?m

16

τ

17

K

H

!

m

K H!z

E K?m

3

K H!m

12

τ

13

Now, from the initial conﬁguration s0 = (0A, 0B, 0C, 0gw(MH,K), 0gw(MK,H), 0D, 0E) of S1H↔K S2 we have
the following run

s0
D−→K : m
−−−−−−→
K−→H : m
−−−−−−→

τ
−→ (0A, 0B, 0C, 0gw(MH,K), 0gw(MK,H), 1D, 0E)
τ
−→ (0A, 0B, 0C, 0gw(MH,K), 9gw(MK,H), 2D, 0E)
τ
−→ (0A, 0B, 0C, 13gw(MH,K), 1gw(MK,H), 3D, 0E)

D−→K : x
−−−−−→ (0A, 0B, 0C, 13gw(MH,K), 14gw(MK,H), 4D, 0E)
τ
τ
τ
−→ (0A, 0B, 0C, 1gw(MH,K), 15gw(MK,H), 5D, 0E)
−→
−→
H−→A : m
−−−−−−→ (1A, 0B, 0C, 2gw(MH,K), 15gw(MK,H), 5D, 0E)

(8)

(9)

where the τ-transition of D enables the synchronisation of gw(MK, H) and D with label D−→K : m that
leads the gateway in state 9 after its τ-transition from state 8. Now, the two gateways can communicate
and exchange message m. Due to ?!-nondeterminism of S1, from state 0 gw(MH, K) can move either to
state 12 or to state 13. Fatally, transition (8) leads to a deadlock: after gw(MK, H) and D synchronise
to exchange message x the system goes into a conﬁguration from where gw(MH, K) forwards m to A and
reaches the last conﬁguration (9). This is a deadlock for S1H↔KS2, since no CFSM can do a τ-transitions,
the only enabled output action is from gw(MK, H) which tries to send message x to gw(MH, K); however,
⋄
gw(MH, K) can only receive message y from K and hence these actions cannot synchronise.

F.Barbanera, I.Lanese, E.Tuosto

65

5 Preserving Properties by Composition

Composition via gateways does not ensure the preservation of communication properties. We provide
below sufﬁcient conditions for this to happen. Recall that (H, K)-composability requires absence of
asymmetric mixed states and ?!-determinism.

Theorem 5.1 (Deadlock freedom preservation). Let S1 and S2 be two (H, K)-composable and deadlock-
free systems. Then the composed system S1H↔K S2 is deadlock-free.

Proof sketch. The proof relies on the fact that the reachable conﬁgurations of S1H↔K S2 can be projected
on reachable conﬁgurations of S1 and S2. This implies that a deadlock in S1H↔K S2 corresponds to a
deadlock in S1 or in S2. See the appendix for the detailed proof.

Example 5.2. We can infer deadlock-freedom of the system S = S1H↔K S2 of Example 3.4 by the result
above, since S1 and S1 are (H, K)-composable and deadlock-free.

Somehow surprisingly, in the symmetric case preservation of deadlock freedom requires stricter con-
ditions on gateways than in the asymmetric case. In fact, in the asymmetric case, deadlock freedom
preservation requires only absence of asymmetric mixed states and ?!-determinism while the symmetric
case requires the (stronger) condition of sequentiality.

Deﬁnition 5.3 (Sequential CFSM). A CFSM is sequential if each of its states has at most one outgoing
transition. A participant A of a system S is sequential if S(A) is so.

As we will see (cf. Theorem 5.5), sequentiality is necessary to preserve lock-freedom also in
the asymmetric case. We note that sequentiality implies absence of asymmetric mixed states and ?!-
determinism, while the converse does not hold.

As mentioned before, the property of lock freedom is not preserved in general by composition, as

shown by the following example.

Example 5.4 (Composability does not preserve lock-freedom). Take the communicating systems

S1 =

A

0

A
H
m

!

1

τ

H

0

1

A
H
?
x

A
H
?
m

and S2 =

K

0

τ

1

K C! m

τ

x
!
C
K

2

3

B

0

1

C
B
?
s
t
o
p

C

0

K

C

?

x

3

C

B

!

s

t

o

K C?m

1

τ

2

p

Note that both S1 and S2 are lock-free and that H and K are compatible. The gateways are

H K!x

5

A H ?x

gw(MH, K)

0

τ

1

HK!m

A

H

?

m

2

τ

3

4

τ

4

H K ?x

and

gw(MK, H)

0

KC!m

H

K

?

m

5

τ

K B!x

3

2

1

Hence, the composed system S1H↔K S2 is non lock-free because e.g. the conﬁguration

s = (0A, 0gw(MH,K), 0gw(MK,H), 0B, 0C)

66

OnComposing Communicating Systems

A−→H : m
−−−−−−→ (0A, 2gw(MH,K), 0gw(MK,H), 0B, 0C)

is a lock for B, since the only outgoing transition from 0B could be ﬁred only in case the transition
C B!stop is enabled. However, this is impossible since gw(MH, K) forwards only message m; hence,
A−→H : m
the run s τ
−−−−−−→ s · · · (which does not involve B) is
−→
⋄
perpetually executed.
We show that the problem of Example 5.4 cannot happen in case we restrict to sequential gateways,
as done for deadlock freedom in the symmetric case (cf. [5]). As usual, f |X denotes the restriction of a
function f on a subset X of its domain.

τ
−→

Theorem 5.5 (Lock-freedom preservation). Let S1 and S2 be two (H, K)-composable and lock-free sys-
tems with H and K sequential. Then the composed system S1H↔K S2 is lock-free.

Proof sketch. The proof goes as the one of Theorem 5.1 noticing that we have to reconstruct “backward”
the sequence of interactions. This exploits sequentiality and lock-freedom of S1 and S2 in order to
guarantee the reconstruction when we “cross” the two composed systems through the gateways.

We turn now our attention to strong lock-freedom. In this case, as for deadlock freedom, (H, K)-
composability sufﬁces for preservation by composition; we shall see that this is not the case for lock
freedom preservation.

Theorem 5.6 (Strong lock freedom preservation). Let S1 and S2 be two (H, K)-composable and strongly
lock free systems. Then the composed system S1H↔K S2 is strongly lock free.

Proof sketch. The proof is similar to the one of Theorem 5.5 but for the use of strong lock freedom of S1
and S2 instead of their deadlock freedom.

6 Conclusions and Future Work

We introduce an asymmetric synchronous semantics of communicating systems which breaks the sym-
metry between senders and receivers.
In fact, our semantics decouples communication from choice
resolution as in standard semantics of communicating systems (and other models). We then adapted the
gateway composition mechanism deﬁned in [2, 3] to our asymmetric semantics and gave conditions for
the preservation of some communication properties under this notion of composition.

In contract automata [10, 9] transitions express “requests” and “offers” among participants. The
composition mechanism is based on “trimming” a product of contract automata according to relevant
agreement properties. This yields controllers that preserve deadlocks. Contract automata do not con-
sider asymmetric synchronous semantics. Our composition mechanism does not introduce orchestrators
which, under some conditions, can be avoided also for contract automata [10, 9].

Modular approaches to the development of concurrent systems can be exploited even for systems
designed using formalisms intrinsically dealing with closed systems. Indeed, given two systems, any
two components – one per system – exhibiting compatible behaviours can be replaced by two coupled
forwarders (gateways) connecting the systems, as investigated initially in [2, 3] for an asynchronous in-
teraction model. The investigation on the composition-by-gateways technique was shifted in [5] towards
synchronous symmetric interactions. We pushed a step forward such an investigation, by considering
asymmetric synchronous interactions. Interestingly, deadlock freedom preservation in the synchronous
asymmetric case we consider does not require sequentiality of gateways, like in the asynchronous case,
and differently from the synchronous symmetric case. Notably, sequentiality is needed here for lock-
freedom preservation, but not for strong-lock freedom preservation.

F.Barbanera, I.Lanese, E.Tuosto

67

While the path of investigation above is quite homogeneous, the different analyses present some
methodological differences. For instance, [5] considers also another form of composition, where one
single gateway (interacting with both the composed systems) is used. On the other side, [5] focused only
on deadlocks, disregarding other properties we consider. A ﬁrst item of future research consist in ﬁlling
the bits missing due to the mismatches above.

A more challenging direction for future work is looking for reﬁned composition mechanisms in order

to get preservation of relevant properties under weaker conditions.

References

[1] F. Barbanera & U. de’Liguoro (2015): Sub-behaviour relations for session-based client/server systems.

MSCS 25(6), pp. 1339–1381, doi:10.1017/S096012951400005X.

[2] Franco Barbanera, Ugo de’Liguoro & Rolf Hennicker (2018): Global Types for Open Systems. In Massimo

Bartoletti & Sophia Knight, editors: ICE, EPTCS 279, pp. 4–20, doi:10.4204/EPTCS.279.4.

[3] Franco Barbanera, Ugo de’Liguoro & Rolf Hennicker (2019): Connecting open systems of communicating

ﬁnite state machines. JLAMP 109, doi:10.1016/j.jlamp.2019.07.004.

[4] Franco Barbanera, Mariangiola Dezani-Ciancaglini, Ivan Lanese & Emilio Tuosto (2021): Composition and

decomposition of multiparty sessions. JLAMP 119, p. 100620, doi:10.1016/j.jlamp.2020.100620.

[5] Franco Barbanera, Ivan Lanese & Emilio Tuosto (2020): Composing Communicating Systems, Syn-
In Tiziana Margaria & Bernhard Steffen, editors: ISoLA 2020, LNCS 12476, Springer, pp.

chronously.
39–59, doi:10.1007/978-3-030-61362-4 3.

[6] Franco Barbanera, Ivan Lanese & Emilio Tuosto (2022): On Composing Communicating Systems. Full Ver-

sion. Available at https://emwww.github.io/home/slides/ice22TR.pdf.

[7] Massimo Bartoletti, Tiziana Cimoli & Roberto Zunino (2015): Compliance in Behavioural Contracts:
A Brief Survey.
In Chiara Bodei, Gian Luigi Ferrari & Corrado Priami, editors: Programming Lan-
guages with Applications to Biology and Security - Essays Dedicated to Pierpaolo Degano on the
Occasion of His 65th Birthday, Lecture Notes in Computer Science 9465, Springer, pp. 103–121,
doi:10.1007/978-3-319-25527-9 9.

[8] Massimo Bartoletti, Alceste Scalas & Roberto Zunino (2014): A Semantic Deconstruction of Session
In Paolo Baldan & Daniele Gorla, editors: CONCUR 2014, LNCS 8704, Springer, pp. 402–418,

Types.
doi:10.1007/978-3-662-44584-6 28.

[9] Davide Basile, Maurice H. ter Beek & Rosario Pugliese (2020): Synthesis of Orchestrations and Chore-
ographies: Bridging the Gap between Supervisory Control and Coordination of Services. LMCS 16(2),
doi:10.23638/LMCS-16(2:9)2020.

[10] Davide Basile, Pierpaolo Degano, Gian Luigi Ferrari & Emilio Tuosto (2016): Playing with Our CAT
and Communication-Centric Applications. In Elvira Albert & Ivan Lanese, editors: FORTE, LNCS 9688,
Springer, pp. 62–73, doi:10.1007/978-3-319-39570-8 5.

[11] G. Bernardi & M. Hennessy (2012): Modelling session types using contracts. In: Proceedings of the 27th
Annual ACM Symposium on Applied Computing, SAC ’12, ACM, New York, NY, USA, pp. 1941–1946,
doi:10.1145/2231936.2232097.

[12] Daniel Brand & Pitro Zaﬁropulo (1983): On Communicating Finite-State Machines. J. ACM 30(2), pp.

323–342, doi:10.1145/322374.322380.

[13] G´erard C´ec´e & Alain Finkel (2005): Veriﬁcation of programs with half-duplex communication. I&C 202(2),

pp. 166–190, doi:10.1016/j.ic.2005.05.006.

[14] K. Honda, V. T. Vasconcelos & M. Kubo (1998): Language Primitives and Type Disciplines for Structured
Communication-based Programming. In Chris Hankin, editor: ESOP, LNCS 1381, Springer, pp. 22–138,
doi:10.1007/BFb0053567.

68

OnComposing Communicating Systems

[15] H. H¨uttel et al. (2016): Foundations of Session Types and Behavioural Contracts. ACMComput.Surv.49(1),

pp. 3:1–3:36, doi:10.1145/2873052.

[16] Julien Lange, Emilio Tuosto & Nobuko Yoshida (2015): From Communicating Machines to Graphi-
In Sriram K. Rajamani & David Walker, editors: POPL, ACM, pp. 221–232,

cal Choreographies.
doi:10.1145/2676726.2676964.

[17] Robin Milner

(1980):

A Calculus of Communicating Systems.

LNCS 92, Springer, Berlin,

doi:10.1007/3-540-10235-3.

[18] L. Padovani (2010): Contract-Based Discovery of Web Services Modulo Simple Orchestrators. Theoretical

ComputerScience 411, pp. 3328–3347, doi:10.1016/j.tcs.2010.05.002.

[19] Emilio Tuosto & Roberto Guanciale (2018): Semantics of global view of choreographies. JLAMP 95, pp.

17–40, doi:10.1016/j.jlamp.2017.11.002.

