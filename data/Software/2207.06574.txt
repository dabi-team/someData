2
2
0
2

l
u
J

5
1

]
L
P
.
s
c
[

2
v
4
7
5
6
0
.
7
0
2
2
:
v
i
X
r
a

Bringing Iris into the Veriﬁed Software Toolchain

William Mansky1

University of Illinois Chicago, USA

Abstract. The Veriﬁed Software Toolchain (VST) is a system for proving cor-
rectness of C programs using separation logic. By connecting to the veriﬁed com-
piler CompCert, it produces the strongest possible guarantees of correctness for
real C code that we can compile and run. VST included concurrency from its
inception, in the form of reasoning about lock invariants, but concurrent sep-
aration logic (CSL) has advanced by leaps and bounds since then. In this pa-
per, we describe eﬀorts to integrate advancements from Iris, a state-of-the-art
mechanized CSL, into VST. Some features of Iris (ghost state and invariants) are
re-implemented in VST from the ground up; others (Iris Proof Mode) are im-
ported from the Iris development; still others (proof rules for atomic operations)
are axiomatized, with the hope that they will be made foundational in future ver-
sions. The result is a system that can prove correctness of sophisticated concurrent
programs implemented in C, with ﬁne-grained locking and non-blocking atomic
operations, that yields varying soundness guarantees depending on the features
used.

Keywords: program veriﬁcation, concurrent separation logic, Veriﬁed Software Toolchain,
Iris

1 Introduction

Soon after O’Hearn observed that separation logic could be naturally extended to con-
currency [19], Gotsman et al. [8] and Hobor et al. [9] independently came up with
variants that used C-style dynamically created locks and threads, where each lock was
associated with a lock invariant describing the resources protected by the lock. Hobor et
al.’s variant was incorporated into the Veriﬁed Software Toolchain (VST) [1], a system
for proving correctness of C programs in Coq using separation logic, giving it the power
to verify (well-synchronized) concurrent C programs. This power then went largely un-
used for several years. In the meantime, there was a boom in sophisticated concurrent
separation logics, including FCSL [23], TaDA [6], and Iris [12], that could prove more
interesting correctness properties and address more interesting synchronization patterns
(especially ﬁne-grained and/or lock-free patterns). Iris in particular synthesized several
streams of prior work with the claim that “ghost states and invariants are all you need”,
allowing it to deﬁne features like the atomic Hoare triples of TaDA in terms of more
primitive constructs (even invariants turned out to be expressible using ghost state [13]).
Iris has since been the focus of many exciting developments in CSL, including a custom
proof mode that provides separation-logic analogues to Coq tactics [15], a derived logic

 
 
 
 
 
 
2

W. Mansky

for reasoning about relaxed-memory atomics [14], a proof system for the core language
of Rust [11], and even a reﬁnement type system for verifying C programs [22].

The fundamental logic of Iris is language-agnostic, but it is usually applied to simple
functional programming languages extended with features of interest (weak memory
models, lifetimes, communication primitives, etc.). ReﬁnedC [22], which includes an
extensive C semantics, is a notable exception, but its semantics is not yet validated by
any other C-related tools, and it forgoes tactics for reasoning about C code in favor of
fully automated type checking. If we want the strong guarantees of VST’s connection
to the CompCert veriﬁed compiler [17], or need to do interactive veriﬁcation beyond
the reach of automated type systems, we may still want to take advantage of VST’s
infrastructure. This led us to ask: how much of the separation logic innovation of Iris
can be used in VST? Where do the foundations overlap, and where do they diﬀer?
Where can results be transferred directly, and where do they need to be adapted? The
rest of this paper describes the answers. In summary:

1. The foundational logical model of Iris is diﬀerent from that of VST. In particular, in
Iris everything down through the basic points-to assertion is ghost state, describing
logical ownership of portions of a monolithic physical state. VST takes a more
traditional approach in which the points-to assertion is primitive, and the notion
of ownership of memory by threads persists through the CompCert proofs down
to assembly. Thus, to begin, we extend the heaps of VST with Iris-style ghost
state. Once we have done this, we can recapitulate the construction of ghost state
assertions and global invariants in VST.

2. Most of the client-facing features of Iris operate not on the logic of Iris per se, but
on a typeclass of separation logics that describes the basic rules most such logics
provide. The logic of Iris is then proved to be an instance of this typeclass. We
prove that VST’s logic is another instance of this typeclass, and then immedi-
ately gain the ability to use Iris Proof Mode in VST proofs, without changing
the behavior of any of VST’s tactics. This is a remarkable illustration of the ﬂex-
ibility of the Iris development, although it comes with some caveats: VST supports
only a signiﬁcantly less useful version of the “persistent” modality, and its sym-
bolic execution engine is not compatible with that of Iris. Even so, Iris Proof Mode
is very useful for proving complex separation logic implications, such as commonly
arise when reasoning with invariants.

3. Unlike the lock invariants of VST, which we only interact with when acquiring
or releasing locks, the global invariants of Iris can be accessed at any time be-
tween steps of a program, and also during the execution of atomic operations—
either physically atomic operations (reads, writes, etc.) or more complex functions
proved to be logically atomic. In C, ordinary reads and writes cannot be assumed
to be atomic: data races on them have undeﬁned behavior, allowing compilers and
hardware to aggressively optimize them. For atomic access to shared memory, C11
includes a syntax for designated atomic memory operations. We axiomatize the
behavior of the C11 atomics as instances of Iris’s rule for physical atomics,
and use this to prove correctness of programs that use C11 atomics in sequen-
tially consistent mode. We can also use the same pattern to deﬁne logically
atomic triples in VST, and use them to prove the most general speciﬁcations

Bringing Iris into the Veriﬁed Software Toolchain

3

for C implementations of linearizable data structures. The axioms added here
are not yet proved sound down to assembly: the proof connecting VST’s original
lock operations to the correctness guarantees of CompCert is already a consider-
able and unﬁnished eﬀort [5], and would have to be further extended to handle
atomic operations. Still, the work of Lahav et al. [16] gives us conﬁdence that the
axiomatization is correct, and we hope to complete the proof in future work.

The work described here does not allow us to take advantage of every innovation in
Iris, nor does it give us guarantees down to assembly for every sophisticated concurrent
program we are able to verify, but it goes a long way towards bringing VST up to date
with the latest tools in concurrent separation logic. It also lays a path for adding fur-
ther Iris features to VST (for instance, we could imagine axiomatizing relaxed-memory
atomics along the same lines as our SC atomics, though their soundness question is
even trickier), and should provide some guidance to developers of other systems who
want to take advantage of the latest developments in Iris. In the rest of this paper, we
will describe each of these steps in detail, and show examples of the C programs we are
now able to verify in VST. The features described are present in VST as of version 2.8,
released in June 2021.

2 Ghost State in VST

2.1 Adding Ghost State to the Model

An assertion in separation logic is ultimately a predicate on some model of program
state. In a simple logic, the model may be just a map from memory addresses to values,
but this model quickly becomes insuﬃcient when we want to add interesting features
like fractional ownership or “predicates in the heap” (used for function pointers and
invariants). Instead, most separation logics use some form of annotated or extended
heap model, and then erase the annotations when relating proofs to the behavior of
actual programs. The model used by VST is based on the work of Hobor et al. [10], and
takes the form of a map from locations to resources that include share information, lock
invariants, and function pointers as well as values. In Iris, on the other hand, the actual
physical memory is almost completely absent from the model: assertions are interpreted
on a generic “camera” that includes all the kinds of ghost state used to verify a particular
program, which always includes a piece set aside to track ownership of heap locations.
The “erasure” then throws away the entire model, leaving only the monolithic physical
state (the complete map of locations to concrete values).

Though re-engineering VST’s model to more closely match that of Iris would be an
interesting challenge, it turns out to be important to VST’s soundness proof that we do
not erase ownership of heap locations when we erase the annotations. In the proofs that
lift CompCert’s sequential compiler correctness properties to a concurrent setting [5],
annotations are erased in the ﬁrst step (to the “juicy” machine), while ownership is
translated into CompCert permissions and used to guarantee race-freedom in the lower
levels of the soundness proof. As a result, moving VST to an Iris-style model while
retaining correctness guarantees down to assembly may be impossible, and is certainly
beyond the scope of this paper. Instead, we extend VST’s model to include Iris-style

4

W. Mansky

ghost state as an additional component, and re-derive laws for manipulating it that are
almost (but not quite) identical to those of Iris. The foundational ghost state described
in this section has been part of VST for several years, and is used in developments such
as the connection to CertiKOS by Mansky et al. [18].

The program logic of VST, called Veriﬁable C, is proved sound with respect to a
semantic model in which assertions are modeled as predicates over resource maps, of
type rmap. An rmap is a step-indexed map from CompCert memory locations to the
associated separation-logic values: either partial ownership of a value in memory, or
a “predicate in the heap” representing a separation logic assertion, such as a global
assertion (e.g., the speciﬁcation of a function pointer) or a lock invariant. The step
index breaks the circularity in the mutual dependence between assertions and rmaps; all
assertions must be preserved under a decrease in step index, and the step index serves
as an “approximation level” for all the assertions in the rmap [1].

As described by Jung et al. [13], a collection of disjoint ghost states drawn from a
range of diﬀerent algebras1 can be combined into a single, top-level ghost state M, a
ﬁnite map from each of a set of indices to an element of the ghost algebra at that index.
We add ghost state to the rmap type precisely by adding such a map: where rmap was
originally a step-indexed construction applied to the type address→ resource, the same
construction is now applied to the type (address→ resource)* ghost, where ghost is
a ﬁnite map from indices (natural numbers) to dependent pairs (G, {a : car(G) | valid a})
of a ghost algebra G and a valid element a of that algebra. While in Iris the map from
indices to ghost algebras is itself a ghost algebra, the construction we use in VST is
not sophisticated enough to prove this without universe inconsistencies; as we will see
below, this limits the kinds of higher-order ghost state we can deﬁne in VST, although
it is suﬃcient for the common case of the agreement algebra used to derive invariants
(see section 2.4).

Next, we must show that our augmented rmaps are still a suitable model for sep-
aration logic. Fortunately, VST’s core separation logic (of which Veriﬁable C is an
instance) is designed to be agnostic to its language and model: in particular, it is ap-
plicable to any resource that is a separation algebra [3]. More precisely, following the
terminology of Cao et al. [4], the underlying separation algebra is assumed to be asso-
ciative, commutative, functional, positive, and unital, and indeed the algebra of rmaps
has all of these properties2. We can show that as long as every ghost algebra in the ghost
of our extended rmaps meets these requirements, then the induced separation algebra
on the rmaps themselves also meets the requirements, making rmaps with ghost state
a valid model for VST’s separation logic. This immediately gives us deﬁnitions of the

1 In separation logics with generic ghost state, each piece of ghost state is drawn from a particu-
lar algebra describing the ways in which that resource can be combined and manipulated. De-
pending on the logic, these algebras may be called “resource algebras”, “partial commutative
monoids”, or various other names; for clarity, we refer to them as “ghost algebras” throughout.
2 In prior versions of VST, the separation algebra was also assumed to be cancellative, which is
not true of some useful forms of ghost state. As part of our extension, we relaxed this require-
ment; the algebra of heap resources is still assumed to be cancellative, but the combination of
heap and ghost state need not be. We then re-proved all the separation logic rules of Veriﬁable
C without assuming cancellativity.

Bringing Iris into the Veriﬁed Software Toolchain

5

basic separation logic operators, and guarantees that they satisfy the usual introduction
and elimination rules.

2.2 Ghost State in the Logic

own alloc

valid a
emp ⇛ ∃g. own g a pp

own dealloc

own g a pp ⇛ emp

own op

a1 · a2 = a3
own g a3 pp = own g a1 pp ∗ own g a2 pp

own valid 2

own g a1 pp ∗ own g a2 pp ⇛ ∃a3. a1 · a2 = a3 ∧ valid a3

own update

fp update a b
own g a pp ⇛ own g b pp

Fig. 1: The separation logic rules for ghost state

The next step is to deﬁne the separation logic assertions that make use of ghost state:
most importantly, the own assertion, which asserts that a thread owns a piece of ghost
state. We do this using the same construction as Jung et al. [13]: we ﬁrst deﬁne a larger
Own predicate that describes the entire index-to-ghost-state map of an rmap, and then
own is deﬁned as ownership of a singleton map at the indicated index. Interestingly,
while Iris makes the type of the total ghost state map M a parameter, we hide the type
inside the rmap using the dependent pair construction described above, which allows
us to introduce new types of ghost state dynamically in our logic: practically speaking,
this means that we do not need to declare that a particular type of ghost state is going to
be used (in Iris, this is done with inG assumptions that state that the global ghost state
includes the desired algebras) before introducing it in a proof. Aside from this small im-
provement, and VST’s diﬀerent approach to rmaps and step-indexing, our construction
parallels that of Iris.

We can then prove the inference rules for own shown in Figure 1. In the assertion
own g a pp, g is an identiﬁer (analogous to a location in the heap), a is an element of
a ghost algebra, and pp is a separation logic predicate. In Iris, the element a can in-
clude predicates in its own right; in VST, because of simpliﬁcations to avoid universe
inconsistencies, we instead keep the predicate component (if any) in a separate argu-
ment, so that we can e.g. store separation logic assertions in ghost state to implement
global invariants, without being able to express fully general higher-order ghost state.
Otherwise, our own assertion functions in the same way as that of Iris. The key prop-
erty of own is that separating conjunction on it corresponds to the join operator · of the
underlying algebra (see rule own op). Furthermore, ghost state can be modiﬁed at any
time via a frame-preserving update: an element a can be replaced with an element b as

6

W. Mansky

long as any third party’s ghost state c that is consistent with a is also consistent with b,
formally expressed as

fp update a b , ∀c, a · c ⇒ b · c
where we write a · b to mean ∃d. a · b = d, i.e., a and b are compatible pieces of
ghost state. This frame-preserving update is embedded into the logic via the view-shift
operator ⇛, as shown in rule own update. In the next section, we will extend VST’s
program logic to allow us to do view shifts at any point in a program, so that we can
create, modify, and destroy ghost state as necessary in our veriﬁcations.

2.3 Soundness of VST with Ghost State

The last step in adding ghost state to VST is to redeﬁne Hoare triples and re-prove their
soundness. VST’s Hoare triples are deﬁned in terms of an inductive safety property, as
follows:

Deﬁnition 1 (Safety). A conﬁguration (c, h) is safe for n steps with postcondition Q if:

– n is 0, or
– c has terminated and Q(h) holds to approximation (step-index) n, or
– (c, h) → (c′, h′) and (c′, h′) is safe for n − 1 steps with Q.

{P} c {Q} then means that ∀n h. P(h) ⇒ (c, h) is safe for n steps with Q. We redeﬁne
this notion of safety to include ghost state that can undergo arbitrary frame-preserving
updates between steps.

Deﬁnition 2 (Safety with Ghost State). A conﬁguration (c, h, g) is safe for n steps with
postcondition Q if:

– n is 0, or
– c has terminated and Q(h, g) holds to approximation n, or
– (c, h) → (c′, h′) and ∀gframe. g · gframe ⇒ ∃g′. (g′ · gframe ∧ (c′, h′, g′) is safe for n − 1

steps with Q).

After each program step, we quantify over a frame ghost state gframe consistent with
our current ghost state, which represents ghost state held by other threads, the outside
world, etc. We can then update our own ghost state to any g′ that is also consistent with
the frame, and show that the rest of the program is safe with g′.

We then re-prove each of the separation logic rules of Veriﬁable C (for assignment,
load, store, function calls, etc.) using this new deﬁnition of safety, as well as proving
the usual enhanced rule of consequence:

P ⇛ P′

{P′} C {Q′}
{P} C {Q}

Q′ ⇛ Q

In standard VST veriﬁcations, the rule of consequence is often applied via a tactic
replace_SEP that allows the user to replace a separating conjunct of the precondition
with a new assertion entailed by that conjunct; accordingly, we deﬁne a new tactic
viewshift_SEP that replaces a conjunct with an assertion that follows from it via a
view shift. We also provide a tactic ghost_alloc that creates new ghost state with the
requested initial value, making the use of ghost state in proof scripts as seamless as
possible.

Bringing Iris into the Veriﬁed Software Toolchain

7

int main (void ) {

ctr = 0;
makelock (& ctr_lock );
release (& ctr_lock );
makelock (& thread_lock );
spawn (& thread_func );

lock_t ctr_lock ;
lock_t thread_lock ;
unsigned ctr ;

void incr () {

acquire (& ctr_lock );
ctr = ctr + 1;
release (& ctr_lock );

}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

void thread_func () {

lock_t *l = & thread_lock ;
incr ();
release (l);

}

}

incr ();

acquire (& thread_lock );
acquire (& ctr_lock );
// ctr should be 2
freelock (& thread_lock );
freelock (& ctr_lock );

Fig. 2: Parallel increment of a locked counter

Example: Parallel Increment We illustrate the use of ghost state in VST with the clas-
sic parallel increment example (code shown in Figure 2). The ctr variable is only mod-
iﬁed when ctr lock is held, and is incremented by two threads (main and a spawned
thread running thread func ) before being reclaimed. Without ghost state, we can prove
that this program is safe (using a lock invariant ∃n. ctr 7→ n), but not that ctr is 2 at
the end of the program (because the invariant does not allow threads to record changes
to ctr ). We overcome this in the traditional way, by adding ghost variables shared be-
tween each thread and the lock invariant, where the lock invariant maintains the fact
that the current value is the sum of the contributions: R , ∃n. (n = n1 + n2) ∧ ctr 7→
n ∗ ghost var.5 n1 g1 ∗ ghost var.5 n2 g2, where ghost var is the own predicate instanti-
ated with an algebra of share-annotated values. The heart of the proof is the speciﬁcation
of incr :

{ctr lock ‚ R ∗ ghost var.5 n gi} incr() {ctr lock ‚ R ∗ ghost var.5 (n + 1) gi}
Every time we increment ctr , we also increment one of the ghost variables, so once
main rejoins with the spawned thread and collects its ghost variable, we can tell that
ctr is exactly 2. The new features of VST show up in only a few places in the proof:
the ghost var predicate in the lock and incr speciﬁcations, a viewshift_SEP tactic in
the proof of incr that updates the ghost state (using the fact, derived from own update,
that ghost var1 n g ⇛ ghost var1 (n + 1) g), and two uses of the ghost_alloc tactic
in the proof of main to initialize the ghost variables. Because the extensions described
so far are foundational, we obtain VST’s usual soundness guarantee for the program:
when we compile it with CompCert and run it, the value of ctr will actually be 2.

2.4 Deﬁning Invariants

One of the most surprising and elegant results of Jung et al. [13] is that invariants, ini-
tially presented as one of the main primitives of the Iris logic, can in fact be constructed

8

W. Mansky

out of higher-order ghost state. Although VST’s ghost state is not fully higher-order, we
demonstrate in this section that it is suﬃcient to construct invariants, giving us access
to one of the most powerful and versatile reasoning techniques in modern concurrent
separation logic.

The earliest revisions of concurrent separation logic [8,9] centered on the use of lock
invariants, where each lock is associated with the resources it protects. A lock invariant
is expressed as an assertion ℓ ‚ R, where ℓ is the location of the lock and R is an
arbitrary separation logic assertion describing resources that can only be accessed by a
thread that holds the lock. The rules governing the invariant are generally of the form:

{ℓ ‚ R} acquire(ℓ) {ℓ ‚ R ∗ R}

{ℓ ‚ R ∗ R} release(ℓ) {ℓ ‚ R}

In combination with ghost state, these rules can be used to prove many useful cor-
rectness properties of lock-based programs. However, they also enforce a one-to-one
association between synchronization object (the lock ℓ) and protected resource (the in-
variant R). We can use ghost state to develop more complicated patterns, but if we have
a program where threads can write to a pointer when they hold either of two locks (with
some other protocol ensuring that both locks are not in use at the same time), or one
that uses an entirely lock-free synchronization mechanism, we will struggle to specify
it using lock invariants. Iris’s solution is to generalize lock invariants away from locks
entirely: an invariant is simply a property that is true before and after every step of
to assert that I is an invariant for the current program. We can
execution. We write I
recover lock invariants with a property like (ℓ 7→ 0 ∗ R) ∨ (ℓ 7→ 1) , which says that
either the lock is not held by any thread (value 0) and the resources R are owned by the
invariant, or the lock is held (value 1) and, implicitly, R is owned by some thread.

Invariants are constructed as a form of higher-order ghost state using the agreement
ghost algebra, in which elements are assertions of the separation logic and two elements
join if they express the same predicate. In fact, the algebra in Iris is somewhat more
complicated—it can be used to capture agreement on any type, not just assertions, and
is carefully designed to respect step-indexing and avoid circular reference. We deﬁne
a more constrained version in VST, for the sole purpose of deﬁning invariants. In fact,
agreement is already baked into our own assertion, since own g a p ∗ own g b q can
only hold when p = q, so we can deﬁne agree g R as simply own g tt R.

The core of the invariant construction is a “world satisfaction” assertion wsat that
captures the contents and current state of every invariant in a program. Our construction
is slightly modiﬁed from that of Iris, and consists of three parts:

– A list of ghost names gi for all deﬁned invariants, wrapped in the master-snapshot
algebra [25] so that threads can remember the fact that a particular name has been
deﬁned: wsat holds a master copy of the list, and any thread with access to it can
create a snapshot recording the existence of one or more invariant names.

– A set of “enabled” tokens and a set of “disabled” tokens, one for each deﬁned
invariant. For each invariant, exactly one of these two is always present in wsat; an
invariant is considered disabled when wsat holds its enabled token (and the thread
modifying its contents holds its disabled token), and vice versa.

– For each invariant i, either agree gi Ri if it is disabled, or Ri ∗ agree gi Ri if it is

enabled.

Bringing Iris into the Veriﬁed Software Toolchain

9

We can then deﬁne R g as snapshot g ∗ agree g R, i.e., the knowledge that g is the
name of some invariant and R is the assertion in that invariant. In Iris, the ﬁrst and
third items are collapsed into a single piece of agreement ghost state that holds the full
map from names to assertions, and an invariant assertion is a snapshot of that map; our
more complicated construction is a workaround for the fact that our agreement algebra
can only capture assertions, not maps of assertions. The rules for allocating invariants
and the deﬁnition of “fancy” updates (ghost updates that open and close invariants) are
derived as in Iris.

So far, we have reimplemented the ghost state and invariants of Iris in VST rather
than importing their deﬁnitions. This is necessary, since we have made slight modiﬁ-
cations to the foundational model, and also useful, since it means that the typical VST
user can still build the toolchain (and even do interesting proofs about concurrent pro-
grams) without installing or understanding Iris. Users looking to verify sophisticated
ﬁne-grained concurrent programs, however, may well be familiar with Iris already and
want to take advantage of its features. In the next section, we stop retracing Iris’s steps
and start integrating Iris directly into VST.

3 Iris Proof Mode in VST

Iris Proof Mode (IPM) provides separation-logic analogues of Coq tactics—iDestruct,
iAssert, etc.—so that users can manipulate separation logic hypotheses and goals in
more or less the same way as pure Coq propositions. The most recent iteration of IPM,
called MoSeL [15], decouples this system from the base logic of Iris by providing a
typeclass of logics of bunched implications (BI): any logic that supports the basic rules
of a BI logic, either as axioms or derived properties, can be targeted by the IPM/MoSeL
tactics. In this section, we brieﬂy summarize this interface, and then describe how we
show that VST’s logic is an instance of it, allowing us to use Iris tactics to prove sepa-
ration logic assertions in VST.

The ﬁrst stage of the interface, called BiMixin, consists mostly of the usual prop-
erties of logical connectives: ∧, ∨, ∀, ∃, and the separating conjunction ∗ and implica-
tion −∗. There are also two more specialized operators: pPq, which injects a pure Coq
proposition P into the separation logic, and the persistence modality ⊡. The persistence
operator must satisfy the rule ⊡ P ⊢ P ∗ ⊡ P, i.e., a persistent assertion can be duplicated
any number of times. A persistent assertion may simply not take up any resources in the
state—like the empty heap assertion emp or a pure proposition—but it may also refer
to a resource that is inherently duplicable, like ghost state asserting that some operation
has occurred. Because assertions under the ⊡ operator are arbitrarily duplicable and in-
teract well with other operators, they are exempt from the usual linearity requirements
of separation logic: if we learn ⊡ P in the process of proving Q ∗ R, then we can use it
in proving both Q and R. Because of this, MoSeL treats persistent assertions more like
pure Coq propositions than separation logic assertions: they are kept in a separate list of
hypotheses that do not need to be explicitly invoked or allocated to particular branches
in the course of a proof.

The implementation of ⊡ in the Iris logic is based on the core operation of its re-
source algebras: each element a of an algebra may have a core element |a| such that

10

W. Mansky

|a| · a = a, and ⊡ P holds on a when P holds on |a|. Using this deﬁnition, many com-
mon features of CSL proofs—invariants, snapshots of ghost state, protocol assertions
for weak memory—can be shown to be persistent, and so qualify for special treatment
in the proof mode. VST also has a notion of core in its separation algebras, but the
notion is slightly diﬀerent. In particular, VST requires that if a (cid:22) b then |a| = |b| (where
we write a (cid:22) b to mean ∃c. a · c = b), while in Iris a (cid:22) b only implies that |a| (cid:22) |b|.
We can see the implications of this diﬀerence, for instance, in an algebra of states in a
ﬁnite state machine: if there is a transition q1 → q2 in the state machine, then in Iris
it may be the case that |q2| = q2, while in VST we must have |q2| = |q1|. If we inter-
pret |q| as “the knowledge that we have at least reached state |q|”, the Iris core provides
signiﬁcantly more information than the VST core, allowing us to remember facts that
were not true when we started the state machine but are guaranteed to be true from now
on. Both notions of core are based on the work of Pottier [20], but Iris intentionally
weakens Pottier’s axioms to gain more useful cores, as acknowledged in section 9.3 of
Jung et al. [13]. The upshot is that VST’s core can be used to deﬁne a ⊡ modality that
satisﬁes all the axioms of BiMixin, but invariants and many other ghost state constructs
are not persistent in this instance. As a result, while we can prove that VST’s logic is an
instance of the BI typeclass, we do not get the full utility of the tactics when it comes
to persistent hypotheses. We have not yet determined whether it is possible to weaken
VST’s core axiom without invalidating the rest of the separation logic.

The second stage of MoSeL’s interface, called BiLaterMixin, introduces the “later”
operator ⊲ and its properties. The ⊲ operator is a common feature of step-indexed sys-
tems, used to ensure that recursive constructions are well founded. Fortunately, Iris and
VST are both built on the same concept of step-indexing (due to Appel and McAllester [2]),
and VST’s ⊲ operator satisﬁes all of the same properties. Once we have shown that
VST’s operators satisfy the properties of both stages, we gain full access to the MoSeL
tactics in VST, with the above-mentioned caveat that assertions that are persistent in Iris
cannot always be treated as persistent in VST.

It is worth noting that there are two layers of tactics used in Iris proofs of Hoare
triples for programs: the MoSeL tactics iDestruct, iAssert, etc. for proving sepa-
ration logic implications in the style of Coq, and tactics like wp rec, wp if, etc. that
do symbolic execution on programs in the target language. VST has its own symbolic
execution tactics (forward, forward if, etc.) which are specialized to C, have similar
eﬀects, and are arguably more powerful, so there is no reason to port these tactics to
VST. We use Iris tactics only to prove separation logic entailments, such as those that
arise when proving loop invariants and function preconditions. They are particularly
useful for complicated implications involving multiple modalities and changes to ghost
state, which are common when reasoning with invariants and especially with logical
atomicity. In the next section, we examine atomicity proofs in VST in more detail.

4 C11 Atomics and Logical Atomicity

4.1 Accessing Invariants with Atomic Operations

Iris allows two main ways of interacting with established invariants. The ﬁrst is to open
and close an invariant in between steps of execution. The second and more powerful is

Bringing Iris into the Veriﬁed Software Toolchain

11

to open an invariant for the duration of an atomic step of execution, using a rule of the
form3:

atomic(e)

{⊲ I ∗ P} e {⊲ I ∗ Q}

{ I ∗ P} e { I ∗ Q}
In base Iris, atomic simply means that the expression computes in a single step of the
underlying small-step semantics, and so ordinary memory loads and stores are consid-
ered to be atomic. This is distinct from the notion of atomicity in weak memory models,
in which distinguished atomic operations perform synchronized memory access, while
concurrent access through ordinary loads and stores leads to data races and possibly
undeﬁned behavior. For example, in base Iris, the program p ← 3 || p ← 4 could be
successfully veriﬁed (using an invariant such as p 7→ 3 ∨ p 7→ 4), while the corre-
sponding program in C/Rust/etc. has undeﬁned behavior and cannot guarantee that p is
either 3 or 4. In weak-memory Iris developments [14,7], this is addressed by working
with a more complex model of memory in which ordinary points-to assertions (referred
to as “non-atomic”, although they are still atomic in the sense of the rule above) are
implicitly tagged with per-thread views of memory, and threads wishing to access them
through invariants must explicitly reason about views in order to ensure suﬃcient syn-
chronization.

VST’s concurrent soundness proof is closely tied to CompCert’s memory model [5],
and modifying it to support relaxed-memory reasoning will be a signiﬁcant undertak-
ing. In the meantime, we support sequentially consistent (SC) atomic memory accesses
(plus ordinary non-synchronized accesses), which allows a much simpler model. In-
variants can be accessed using the rule above, except that atomic is only true of those
operations that are atomic in the C sense, i.e., the built-in operations atomic load,
atomic store, etc. As per the C11 speciﬁcation, these operations can only be per-
formed on pointers that have been declared to have an atomic type, and so we intro-
duce a special points-to assertion p 7→a v for atomic pointers. We have not yet updated
VST’s soundness proof for this model—it will require adding the atomic operations to
the Concurrent Permission Machine that serves as an interface between concurrent VST
and the sequential semantics of CompCert—but we do not expect it to be signiﬁcantly
more diﬃcult than the original soundness proof (in which the only synchronization op-
erations are lock acquire and release). In the meantime, we can reason about C programs
that use non-atomic and SC atomic memory accesses with a fairly high degree of conﬁ-
dence, and allow SC atomics to access Iris-style invariants. Instantiating the atomic rule
with speciﬁc atomic operations gives us rules such as:

P ∗ I ⇛ ∃v. p 7→a v ∗ (x = v ∗ p 7→a v ⇛ I ∗ Q(v))
{ I ∗ P} x = atomic load(p) { I ∗ Q(v)}

P ∗ I ⇛ p 7→a ∗ (p 7→a v ⇛ I ∗ Q)
{ I ∗ P} atomic store(p, v) { I ∗ Q}

If the points-to assertion p 7→a v is somewhere inside an invariant I, then we can access
p with an atomic operation, read or modify its value, and then return the assertion, re-

3 The actual rule in Iris uses fancy updates to allow opening any number of named invariants

around e, while only opening each invariant at most once.

12

W. Mansky

establishing the invariant and retaining any leftover resources in the postcondition Q.
The nested view shifts in the premises of these rules are exactly the sort of goal that is
most easily proved with the IPM/MoSeL tactics described in the previous section.

4.2 Logical Atomicity in VST

The true power of Iris’s invariants comes from the extension of atomicity to logical
atomicity. Logical atomicity originally appeared in the TaDA logic [6] in the form of
atomic triples hPi c hQi, which were then deﬁned in Iris in terms of view shifts [12].
If a function is proved to satisfy a logically atomic speciﬁcation, then its eﬀects are
guaranteed to appear to take eﬀect at a single point in time, and other threads will never
observe an intermediate state of the function. This means that logically atomic functions
can be treated as atomic in the sense above, and can access the contents of invariants.
Logical atomicity gives us canonical speciﬁcations for data structure operations that
can then be specialized with diﬀerent ghost state and invariants depending on the task
at hand: for instance, if a data structure is linearizable, we can combine its atomic spec-
iﬁcations with an invariant that its current state is derivable from a sequential history of
observed operations, and then do linearizability-based reasoning in a client proof.

| Pp(a)i c hQl

The general form of an atomic triple is ha. Pl

| Qp(a)i, where Pl
and Ql are the local or private pre- and postconditions and Pp and Qp are the public
pre- and postconditions. The public pre- and postconditions describe the state of an ab-
stract object a that can vary freely until the linearization point of c, at which point it
must transition from a state satisfying Pp to a state satisfying Qp. (Note that despite its
placement, the quantiﬁcation of a scopes over both the postcondition and the precon-
dition.) For example, an atomic enqueue operation for a queue might be speciﬁed as
hq. IsQueue(p) | Queue(p, q)i enqueue(p, v) hIsQueue(p) | Queue(p, v :: q)i, assert-
ing that the caller must hold a reference to the queue at location p (IsQueue(p)), and
enqueue atomically updates the contents of that queue from q to v :: q at some point
during the execution of the function.

In Iris, atomic triples are derived forms, deﬁned as:

ha. Pl | Pp(a)i c hQl | Qp(a)i , ∀Q. {Pl ∗ atomic shift(Pp, Qp, Q)} c {Ql ∗ Q}

where atomic shift is deﬁned as roughly4:

atomic shift(α, β, Q) , ∃P. ⊲ P ∗ (cid:3)(⊲ P ⇛ ∃x. α(x) ∗ ((α(x) ⇛ ⊲ P) ∧ (β(x) ⇛ Q)))

This is a rather complicated deﬁnition, but it captures the essence of an atomic update to
the abstract state: we have a black-box resource P that can be used to temporarily obtain
the public precondition α on some state x, but we must always either make no visible
changes and restore α(x), or (at the linearization point) satisfy the public postcondition
β and obtain Q instead. When we prove that a function satisﬁes an atomic speciﬁcation,
P and Q are black boxes, and so the only way to obtain Q in the postcondition is by
satisfying the public postcondition Qp at some linearization point during the function.

4 The precise deﬁnition in Iris has gone through several revisions. The one presented here is a

simpliﬁed version of the deﬁnition from the original Iris paper [12].

Bringing Iris into the Veriﬁed Software Toolchain

13

When we call a function with an atomic speciﬁcation, we can give it any arbitrary
postcondition Q, as long as that postcondition can be shown to result from an atomic
shift from Pp to Qp.

Embedding this deﬁnition in VST’s notation for function speciﬁcations is tricky in
practice but simple in theory. A higher-order function speciﬁcation in VST has the form

TYPE a WITH x1, ..., xn
PRE [ty1, ..., tyk]

PROP (P) PARAMS (R) GLOBALS (G) SEP (S )

POST [ty]

PROP (P′) RETURN (R′) SEP (S ′)

where x1, ..., xn are parameters of the speciﬁcation whose type is given by a, ty1, ..., tyk
and ty are the C types of the function’s arguments and return value, and the pre- and
postcondition are broken up into pure Coq assertions (PROP), assertions about program
variables (PARAMS/GLOBALS/RETURN), and separation logic assertions (SEP). For logi-
cally atomic speciﬁcations, we deﬁne a notation

ATOMIC TYPE a OBJ o WITH x1, ..., xn
PRE [ty1, ..., tyk]

PROP (P) PARAMS (R) GLOBALS (G) SEP (S ) | (S p)

POST [ty]

PROP (P′) RETURN (R′) SEP (S ′) | (S ′
p)

where the abstract object o corresponds to the a in ha. Pl | Pp(a)i c hQl | Qp(a)i, S p and
S ′
p correspond to Pp and Qp respectively, and the rest of the conditions correspond to
Pl and Ql. This notation is desugared into

TYPE a ∗ mpred WITH x1, ..., xn, Q
PRE [ty1, ..., tyk]

PROP (P) PARAMS (R) GLOBALS (G) SEP (atomic shift(S p, S ′

p, Q) ∗ S )

POST [ty]

PROP (P′) RETURN (R′) SEP (Q ∗ S ′)

In other words, we add the desired postcondition Q as another parameter to the spec-
iﬁcation, convert the public pre- and postcondition into an atomic shift added to the
ordinary precondition, and add Q to the postcondition, mirroring the Iris deﬁnition of
atomic triples. (This notation was quite hard to implement, especially the extension of
the type of the WITH clause, and beneﬁted from the advice of Jason Gross.)

This gives us a way to write atomic function speciﬁcations in the usual VST style,
after which we can prove that they are satisﬁed by implementations, and use them in
client programs, with the existing tactics of VST. The key diﬀerences are that 1) when
proving that a function meets an atomic speciﬁcation, we can only access the resources
in S p via the atomic shift, and must then either restore it as is or, at a linearization point,
obtain Q by satisfying the public postcondition S ′
p; and 2) when calling a function with
an atomic speciﬁcation, we must provide the desired postcondition Q as an extra param-
eter, and prove that the atomic shift from S p to S ′
p causes Q to hold. By construction,

14

W. Mansky

we can access the contents of invariants when proving the atomic shift, thus fulﬁlling
the promise of atomic triples: when calling a function with an atomic speciﬁcation,
we can access invariants around it as if it were a single atomic instruction. In the next
section, we will illustrate this with a concrete example.

4.3 Example: The World’s Simplest Lock-Free Hash Table

With ghost state, invariants, atomic memory operations, and logically atomic speciﬁca-
tions at our disposal, we can now prove strong speciﬁcations for C implementations of
lock-free data structures in VST. In this section, we consider a C adaptation of Presh-
ing’s World’s Simplest Lock-Free Hash Table [21]. The hashtable is implemented as an
array of key-value pairs, where both keys and values are atomically accessed integers
(type atom int). The code for the set item function is shown in Figure 3. We hash the
target key key to get an index idx into the array, and atomically read the key at idx (line
5) to see if it it matches our key. If it does, we atomically store the target value value
at idx (line 20). If there is some other key at idx, we “chain” by simply incrementing
idx by 1 and trying again (line 10). If we ﬁnd an empty slot (indicated by key 0), we
attempt to CAS it to key (line 11). If the CAS fails (i.e., the key at idx has been set
since our initial read), then we check again whether the current key is equal to key, and
either set the value or move to the next index as appropriate. The get item function
(Figure 4) simply moves through the keys until it ﬁnds either the target key (in which
case it returns the associated value), or an empty entry (in which case the key is not in
the table). We also include an add item function that adds a key only if it is not found
in the table.

To specify the hashtable functions, we begin by describing the relationship between
the abstract state of the hashtable as a map from keys to values, and its concrete state as
a collection of atomically accessed integers. An individual hashtable entry is a pair of
atomic integers pk, pv with values k, v and a ghost state g, deﬁned as follows:

entry (pk, pv) (k, v) g , (k = 0 → v = 0) ∧ pk 7→a k ∗ pv 7→a v ∗ ghost master k g

Each entry maintains the invariant that if its key is empty, its value is also empty. We
also include a piece of ghost state from the master-snapshot pattern [25] with value k,
with a simple order in which 0 is less than any non-zero number. This allows a client to
take a snapshot that records the key it has seen at an entry, with the knowledge that any
non-zero key will remain at that entry indeﬁnitely (but a 0 value may be replaced with
a non-zero key). A hashtable of size size is simply a collection of these entries:

hashtable H p g , ∃e, (e implements H) ∧∗i∈sizeentry pi ei gi

where e is the list of key-value pairs that appear in the table, and the abstract state of
the hashtable is a Coq-level map from keys to values H that is consistent with e.

We can use a sequence of snapshots of the entries to precisely determine where a

key should appear in the hashtable. Speciﬁcally, we prove the following lemma:

Lemma 1. For any key k, if we have snapshots of the keys from entries with indices in
the range [hash(k), hash(k) +i) (modulo size) such that none of the snapshots are either

Bringing Iris into the Veriﬁed Software Toolchain

15

void set_item (int key , int value){

int ref = 0;
for (int idx = integer_hash (key );; idx ++) {

idx &= ARRAY_SIZE - 1;
atom_int *i = m_entries [idx ]. key ;
int probed_key = atom_load (i);
if( probed_key != key ){

//The entry was free, or contained another key.
if ( probed_key != 0)

continue ;

int result = atom_CAS (i, &ref , key );
if (! result ){

//CAS failed, so a key has been added. Is it our key?
probed_key = atom_load (i);
if( probed_key != key )

continue ; //This slot has been taken for another key.

}

}
i = m_entries [idx ]. value;
atom_store (i, value);
return ;

}

}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

Fig. 3: The set function for the lock-free hashtable

0 or k, and the key at index hash(k) + i is either 0 or k, then hash(k) + i is the unique
index in the hashtable where key k can be found or inserted.

The proof involves a good deal of modular arithmetic, but the intuition is simple: be-
cause our chaining function is simply “move to the next index”, the key k will always
appear at the end of a (possibly empty) sequence of non-empty, non-k keys starting
from the index hash(k).

Now we can state the speciﬁcations of the hashtable functions. On paper, these

speciﬁcations are a fairly intuitive collection of logically atomic triples:

hH. h 7→ p | k , 0 ∧ hashtable H p gi
set item(h, k, v)
hh 7→ p | hashtable H[k 7→ v] p gi

hH. h 7→ p | k , 0 ∧ hashtable H p gi
get item(h, k)
hv. h 7→ p | H(k) = v ∧ hashtable H p gi

hH. h 7→ p | k , 0 ∧ hashtable H p gi
add item(h, k, v)
hb. h 7→ p | (k < H ∧ b = true ∧ hashtable H[k 7→ v] p g) ∨ (k ∈ H ∧ b = false ∧ hashtable H p g)i

16

W. Mansky

1
2
3
4
5
6
7
8
9
10
11
12
13

int get_item (int key ){

for (int idx = integer_hash (key );; idx ++) {

idx &= ARRAY_SIZE - 1;
atom_int *i = m_entries [idx ]. key ;
int probed_key = atom_load (i);
if( probed_key == key ){

i = m_entries [idx ]. value;
return atom_load (i);

}
if ( probed_key == 0)

return 0;

}

}

Fig. 4: The get function for the lock-free hashtable

The caller requires a reference to the location of the hashtable entries (h 7→ p), and each
function performs its operation atomically on the abstract state H of the hashtable. In
practice, VST requires more annotations and side conditions, so that the speciﬁcation
of the get item function looks like:

Program Definition get_item_spec := DECLARE _get_item

ATOMIC TYPE ( ConstType (Z * globals * share * list ( val *

val ) * gname * list gname))
OBJ H WITH k, gv , sh , entries , g, lg
PRE [ tint ]

PROP ( readable_share sh; repable_signed k; k <> 0;

Forall (fun ’(pk , pv) ⇒ isptr pk ∧ isptr pv) entries

;

Zlength lg = size )

PARAMS (vint k) GLOBALS (gv)
SEP ( data_at sh ( tarray tentry size ) entries (gv
_m_entries )) | ( hashtable H g lg entries )

POST [ tint ]

EX v : Z,
PROP ()
LOCAL (temp ret_temp (vint v))
SEP ( data_at sh ( tarray tentry size ) entries (gv

_m_entries )) |
(!!( if eq_dec v 0 then H k = None else H k = Some v)

&& hashtable H g lg entries ).

The data_at predicate represents the points-to assertion (the global variable m entries
holds the hashtable entries, represented by the list of pointer pairs entries ). The caller
need only hold a readable share of this assertion, so it can be divided among multiple
threads. The key k must be non-zero, but it must also be representable as a machine
integer (i.e., it must be between the minimum and the maximum integer), a detail we
would ignore in a less concrete language model.

Bringing Iris into the Veriﬁed Software Toolchain

17

The proof that get item satisﬁes this spec begins as a conventional VST proof, with
the atomic shift as an extra SEP clause in the precondition, and the extra assertion Q in
the postcondition (representing the postcondition requested by the caller, and treated as
a black box in the proof). The invariant for the main loop is that we have not passed the
location of the target key or an empty slot, which we express through a list of snapshots
of the ghost state for each key seen (initially empty), as described in Lemma 1. The
new features of VST ﬁrst come into play at the ﬁrst atomic load at line 5. When we
call atomic load, we also supply the desired postcondition for the load, which as seen
in section 4.1 is a predicate on the returned value v. In this case, we have two possible
results. If we read a 0, then we have reached the end of the hashtable without ﬁnding
the key k, and this load is our linearization point: k is not currently in H, and 0 is the
correct return value. If we read a nonzero value, line 5 is not the linearization point,
and we instead record a snapshot of the observed key (copied from ghost master in
the entry) and continue executing. So the postcondition we request is Q1 = (λv. if v =
0 then Q(v) else P ∗ ghost snap v gi), where Q is the black-box assertion received from
fulﬁlling the atomic shift at the linearization point. We pass this postcondition as an
argument to the forward call tactic, and receive the premise of the atomic load
rule as a proof obligation: P ∗ I ⇛ ∃v. p 7→a v ∗ (x = v ∗ p 7→a v ⇛ I ∗ Q1(v)), where
I = hashtable H p g.

At this point, our goal is an implication between two separation logic formulae
involving ghost state and atomic shifts—exactly where Iris Proof Mode is most useful.
We switch into IPM simply by applying the iIntros tactic used to start Iris proofs, and
now we have the features of Iris at our disposal: named premises, the iMod tactic for
handling ghost updates, and so on. The proof of this implication proceeds entirely by
Iris and base Coq tactics, with no VST-speciﬁc reasoning. When the key is 0, we use our
snapshots and lemma 1 to show that the target key k must not be in the hashtable, and so
we can discharge our atomic shift and obtain the black-box postcondition Q with value
0 (key not found). Otherwise, we take a snapshot of the current entry’s key and add it to
our list of snapshots. Note that in the “key not found” case, we do not yet return from
the function, but we have the postcondition Q in our current state, representing the fact
that we have reached the linearization point and will do no further atomic operations.

Once we ﬁnish the proof obligation of the atomic load, we are back in a VST
proof state, and can resume using VST tactics to step through the C code. We have three
cases left to consider. First, when probed key == key, we do another atomic load
(line 8) to read the value associated with that key. This is always a linearization point,
and the value we read will be the return value for the function, so the desired postcondi-
tion is simply Q. Again we shift into IPM to manage the ghost state and invariant opera-
tions, use the collected snapshots to show that the current index must be the unique loca-
tion of the key k, and discharge the atomic shift to obtain Q. Second, when probed key
== 0, we already have the postcondition Q(0) from our earlier atomic load, and we
can simply return 0 (line 11) and satisfy the postcondition of get item . Finally, if neither
is the case, we continue to the next index and repeat the process.

The complete veriﬁcation of the hashtable consists of 2kLoC in Coq, and is in-

cluded in VST at https://github.com/PrincetonUniversity/VST/blob/master/atomics/verif_hashtable_atomic.v.
In addition to the proofs of the hashtable operations, it includes a simple client that de-

18

W. Mansky

rives linearizability from the atomic speciﬁcations by associating the hashtable with a
ghost history of operations, and demonstrates that if three threads each try to add the
same three keys to the hashtable, then exactly three keys are added. In summary, we use
the extensions to VST in the following ways in the veriﬁcation process:

1. In the speciﬁcations, we use ghost state to deﬁne the abstract state of the hashtable,
and logical atomicity (the ATOMIC keyword) to describe the desired behavior of the
data structure operations.

2. In the proofs of the functions with atomic speciﬁcations, we automatically receive
an atomic shift describing the global state and the requirements on the linearization
point, and a black-box postcondition Q that we must obtain from the atomic shift
in order to satisfy the function’s postcondition.

3. When we call atomic memory operations like atomic load, we automatically
make use of the new speciﬁcations for these operations. The preconditions of these
operations include proof obligations that we use Iris Proof Mode to discharge: we
open invariants to access the current global state of the data structure, update ghost
state as needed, and then either restore the invariants or (at linearization points) sat-
isfy the public postcondition. These proofs appear as IPM subsections within the
VST proof scripts for the data structure operations, and we shift seamlessly back to
VST tactics once the relevant subgoals are discharged.

4. Similarly, in proofs of clients of the data structure we use ordinary VST tactics to
reason about the C code, and drop into IPM to prove the preconditions of functions
with logically atomic speciﬁcations (like get item ).

5 Conclusion

We have now seen how several features of Iris can be variously reconstructed, incor-
porated, or axiomatized in VST. The result is a veriﬁcation system for concurrent C
programs that beneﬁts from the advances of modern separation logic: custom ghost
state, global invariants, Coq-style tactics for SL reasoning, and logically atomic speciﬁ-
cations. More work remains to foundationally verify some of these features (speciﬁcally
the proof rules for atomic operations and their interaction with global invariants), but for
the time being we have an eﬀective system for program veriﬁcation whose unveriﬁed
axioms have been shown to be sound in other (non-C-speciﬁc) logics. The speciﬁcations
and proofs of this system appear as fairly simple extensions to the usual VST style, and
undergraduate and masters students have been able to learn the system well enough to
verify simple ﬁne-grained concurrent data structures [24].

Aside from closing the soundness gap, there are several areas for future extensions.
Iris proofs make heavy use of the persistence modality, which allows “information”-
style resources like global invariants to be freely duplicated with minimal eﬀort, but
diﬀerences in the underlying separation algebra mean that most of these resources are
not persistent in VST. We intend to investigate whether VST’s “core” axiom can be
weakened to match the one in Iris, which would give us the full power of persistence
in VST. We are also very interested in doing weak-memory reasoning in VST, and Iris
has already been used as a base for several powerful weak-memory logics [14,7]. These
would involve much more careful analysis (if we want to add their rules as axioms) or

Bringing Iris into the Veriﬁed Software Toolchain

19

larger changes to VST’s foundations and soundness proofs (if we want to foundationally
verify the rules), but the results would be well worth it—a system for directly proving
correctness of real C implementations of weak-memory algorithms and data structures.

Acknowledgements With thanks to Robbert Krebbers and Joseph Tassarotti, for con-
vincing me that Iris tactics were necessary for atomicity proofs; Shengyi Wang, for
merging new features into the main branch of VST; and Jason Gross, for invaluable
advice on notations for atomic speciﬁcations.

References

1. Appel, A.W., Dockins, R., Hobor, A., Beringer, L., Dodds, J., Stewart, G., Blazy, S.,
Leroy, X.: Program Logics for Certiﬁed Compilers. Cambridge University Press (2014),
http://www.cambridge.org/de/academic/subjects/computer-science/programming-languages-and-applied-logic/program-logics-certified-compilers?format=HB

2. Appel, A.W., McAllester, D.: An

proof-carrying

foundational
23(5),
2001).
https://doi-org.proxy.cc.uic.edu/10.1145/504709.504712

657–683

code.

(Sep

indexed model
ACM Trans.

for
Syst.
https://doi.org/10.1145/504709.504712,

of
Program.

recursive

Lang.

types

3. Calcagno, C., O’Hearn, P.W., Yang, H.: Local action and abstract separation logic. In: 22nd
IEEE Symposium on Logic in Computer Science (LICS) 2007, 10-12 July 2007, Wroclaw,
Poland, Proceedings. pp. 366–378 (2007). https://doi.org/10.1109/LICS.2007.30,
https://doi.org/10.1109/LICS.2007.30

4. Cao, Q., Cuellar, S., Appel, A.W.: Bringing order to the separation logic jungle. In: Chang,
B.Y.E. (ed.) Programming Languages and Systems. pp. 190–211. Springer International Pub-
lishing, Cham (2017)

5. Cuellar, S., Giannarakis, N., Madiot, J.M., Mansky, W., Beringer, L., Cao, Q., Appel, A.:
Compiler correctness for concurrency: from concurrent separation logic to shared-memory
assembly language. Tech. rep., Princeton University (2020)

6. da Rocha Pinto, P., Dinsdale-Young, T., Gardner, P.: TaDA: A logic for

time
and data abstraction.
(ed.) ECOOP’14: 28th European Conference
on Object-Oriented Programming. LNCS, vol. 8586, pp. 207–231. Springer (2014).
https://doi.org/10.1007/978-3-662-44202-9_9

In: Jones, R.

7. Dang, H.H., Jourdan, J.H., Kaiser, J.O., Dreyer, D.: RustBelt meets relaxed memory.
Proc. ACM Program. Lang. 4(POPL) (Dec 2019). https://doi.org/10.1145/3371102,
https://doi-org.proxy.cc.uic.edu/10.1145/3371102

8. Gotsman, A., Berdine, J., Cook, B., Rinetzky, N., Sagiv, M.: Local reasoning for storable
locks and threads. In: Proceedings of the 5th Asian Conference on Programming Languages
and Systems. p. 19–37. APLAS’07, Springer-Verlag, Berlin, Heidelberg (2007)

9. Hobor, A., Appel, A.W., Nardelli, F.Z.: Oracle semantics for concurrent separation logic. In:
Proceedings of the Theory and Practice of Software, 17th European Conference on Program-
ming Languages and Systems. pp. 353–367. ESOP’08/ETAPS’08, Springer-Verlag, Berlin,
Heidelberg (2008), http://dl.acm.org/citation.cfm?id=1792878.1792914

10. Hobor, A., Dockins, R., Appel, A.W.: A theory of indirection via approximation. In:
Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages. p. 171–184. POPL ’10, Association for Computing Ma-
chinery, New York, NY, USA (2010). https://doi.org/10.1145/1706299.1706322,
https://doi.org/10.1145/1706299.1706322

20

W. Mansky

11. Jung, R., Jourdan, J.H., Krebbers, R., Dreyer, D.: RustBelt: Securing the foundations
of the rust programming language. Proc. ACM Program. Lang. 2(POPL) (dec 2017).
https://doi.org/10.1145/3158154, https://doi.org/10.1145/3158154

12. Jung, R., Krebbers, R., Birkedal, L., Dreyer, D.: Higher-order ghost

In:
the 21st ACM SIGPLAN International Conference on Functional
ICFP 2016, ACM, New York, NY, USA (2016).

Proceedings of
Programming. pp. 256–269.
https://doi.org/10.1145/2951913.2951943

state.

13. Jung, R., Krebbers, R., Jourdan, J.H., Bizjak, A., Birkedal, L., Dreyer, D.: Iris from the
ground up: A modular foundation for higher-order concurrent separation logic (2017)
14. Kaiser, J., Dang, H., Dreyer, D., Lahav, O., Vafeiadis, V.: Strong logic for weak memory:
Reasoning about release-acquire consistency in Iris. In: ECOOP’17: 31st European Confer-
ence on Object-Oriented Programming. LIPIcs, vol. 74, pp. 17:1–17:29 (2017)

15. Krebbers, R.,

J.H.,

Jourdan,

J.O., Timany, A.,
Jung, R., Tassarotti,
Chargu´eraud, A., Dreyer, D.: Mosel: A general, extensible modal framework for in-
teractive proofs in separation logic. Proc. ACM Program. Lang. 2(ICFP) (Jul 2018).
https://doi.org/10.1145/3236772, https://doi.org/10.1145/3236772

J., Kaiser,

16. Lahav, O., Vafeiadis, V., Kang, J., Hur, C.K., Dreyer, D.: Repairing sequential consistency in
C/C++11. In: Proceedings of the 38th ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation. p. 618–632. PLDI 2017, Association for Computing Ma-
chinery, New York, NY, USA (2017). https://doi.org/10.1145/3062341.3062352,
https://doi.org/10.1145/3062341.3062352

17. Leroy, X.: Formal veriﬁcation of a realistic compiler. Communications of the ACM 52(7),
107–115 (2009), http://gallium.inria.fr/˜xleroy/publi/compcert-CACM.pdf
18. Mansky, W., Honor´e, W., Appel, A.W.: Connecting higher-order separation logic to a ﬁrst-
order outside world. In: M¨uller, P. (ed.) Programming Languages and Systems. pp. 428–455.
Springer International Publishing, Cham (2020)

19. O’Hearn, P.W.: Resources, concurrency, and local reasoning. Theor. Comput. Sci. 375(1-3),

20. Pottier,

271–307 (2007). https://doi.org/10.1016/j.tcs.2006.12.035
soundness
Journal

of
Functional

Syntactic

F.:

proof

sys-
38–
https://doi.org/10.1017/S0956796812000366,

type-and-capability
23(1),

Programming

of

hidden

tem with
144
https://hal.inria.fr/hal-00877589

state.
2013).

(Jan

a

J.:

simplest

lock-free

21. Preshing,

The world’s

2013),
http://preshing.com/20130605/the-worlds-simplest-lock-free-hash-table/
22. Sammler, M., Lepigre, R., Krebbers, R., Memarian, K., Dreyer, D., Garg, D.: ReﬁnedC:
Automating the foundational veriﬁcation of C code with reﬁned ownership types. In: Pro-
ceedings of the 42nd ACM SIGPLAN International Conference on Programming Lan-
guage Design and Implementation. p. 158–174. PLDI 2021, Association for Computing Ma-
chinery, New York, NY, USA (2021). https://doi.org/10.1145/3453483.3454036,
https://doi.org/10.1145/3453483.3454036

table

hash

(Jun

23. Sergey, I., Nanevski, A., Banerjee, A.: Specifying and verifying concurrent algorithms with
histories and subjectivity. In: Vitek, J. (ed.) Proceedings of the 24th European Symposium
on Programming (ESOP 2015). Lecture Notes in Computer Science, vol. 9032, pp. 333–358.
Springer (2015). https://doi.org/10.1007/978-3-662-46669-8_14

24. Sharma, R.: Formal Veriﬁcation of Concurrent Binary Search Tree. Master’s thesis, Univer-
sity of Illinois at Chicago (Apr 2021). https://doi.org/10.25417/uic.15261939.v1,
https://indigo.uic.edu/articles/thesis/Formal_Verification_of_Concurrent_Binary_Search_Tree/15261939/1

25. Tassarotti, J., Dreyer, D., Vafeiadis, V.: Verifying read-copy-update in a logic for
the 36th ACM SIGPLAN Conference on Pro-
’15, ACM,

weak memory.
gramming Language Design and Implementation. pp. 110–120. PLDI

In: Proceedings of

Bringing Iris into the Veriﬁed Software Toolchain

21

New York, NY, USA (2015).
http://doi.acm.org/10.1145/2737924.2737992

https://doi.org/10.1145/2737924.2737992,

