Haoxian Chen
University of Pennsylvania
USA
hxchen@seas.upenn.edu

Declarative Smart Contracts
Gerald Whitters
University of Pennsylvania
USA
whitters@seas.upenn.edu

Mohammad Javad Amiri
University of Pennsylvania
USA
mjamiri@seas.upenn.edu

Yuepeng Wang
Simon Fraser University
Canada
yuepeng@sfu.ca

Boon Thau Loo
University of Pennsylvania
USA
boonloo@seas.upenn.edu

2
2
0
2

l
u
J

7
2

]
E
S
.
s
c
[

1
v
7
2
8
3
1
.
7
0
2
2
:
v
i
X
r
a

ABSTRACT
This paper presents DeCon, a declarative programming language
for implementing smart contracts and specifying contract-level
properties. Driven by the observation that smart contract opera-
tions and contract-level properties can be naturally expressed as
relational constraints, DeCon models each smart contract as a set
of relational tables that store transaction records. This relational
representation of smart contracts enables convenient specification
of contract properties, facilitates run-time monitoring of potential
property violations, and brings clarity to contract debugging via
data provenance. Specifically, a DeCon program consists of a set
of declarative rules and violation query rules over the relational
representation, describing the smart contract implementation and
contract-level properties, respectively. We have developed a tool
that can compile DeCon programs into executable Solidity pro-
grams, with instrumentation for run-time property monitoring.
Our case studies demonstrate that DeCon can implement realistic
smart contracts such as ERC20 and ERC721 digital tokens. Our eval-
uation results reveal the marginal overhead of DeCon compared to
the open-source reference implementation, incurring 14% median
gas overhead for execution, and another 16% median gas overhead
for run-time verification.

CCS CONCEPTS
‚Ä¢ Software and its engineering ‚Üí Domain specific languages.

KEYWORDS
Smart contracts, Declarative programming, Run-time verification

1 INTRODUCTION
Smart contracts are programs stored and executed on blockchains.
They have been used in a wide range of blockchain-enabled dis-
tributed applications to manage digital assets, including auctions
[34], financial contracts [22], elections [46], trading platforms [49],
and permission management [18]. Unfortunately, today‚Äôs smart
contracts are error-prone and this has led to significant financial
losses resulting from attacks such as Dice2win [50], King of Ether
[13], Parity Multisig Bug [60], Accidental [23] and DAO [12, 57].

Over the past few years, different analysis and verification tech-
niques have been proposed for known vulnerabilities of smart
contracts, such as re-entrancy attacks and transaction-order de-
pendency [16, 31, 51, 55, 62]. However, when it comes to high-level

‚àóTo appear at ESEC/FSE ‚Äô22.

properties specific to individual smart contracts, programmers typ-
ically have to rely on hand-written assertions [7], which is hard to
maintain and error-prone. For example, for a smart contract that
manages digital tokens, one may want to ensure that all account
balances add up to the total supply of tokens. To monitor this prop-
erty during run-time, one has to instrument the code to maintain
a state that keeps track of the sum of all account balances, and
add assertions about their equivalence wherever either account
balances or token supplies are updated. There are third-party tools
that support high-level property specification and verification for
Solidity, e.g., temporal logic [51], formula with extended opera-
tors [43], etc., but counter-examples are returned in the form of
Ethereum bytecode traces or transaction sequences, which may not
be easy for programmers to understand and localize bugs in the
original implementation.

To make smart contracts easier to analyze and verify, we intro-
duce DeCon, a declarative programming language for smart con-
tract implementation and property specification. DeCon is based on
Datalog [14], a logic programming language. Datalog frees program-
mers from low-level implementation details, e.g., data structures,
algorithms, etc., and allows them to reason about the contract on
the specification level, via inference rules [21]. In addition, such
relational representation serves as a high-level abstraction of the
contract, which enables efficient formal analysis and verification
[58, 63].

A typical smart contract provides two kinds of interfaces: trans-
actions and views. Transactions are function calls that alter the
contract states, e.g., a token transfer that updates both sender and
recipient balances. Views are read-only functions that return par-
ticular states of the contract, e.g., the balance of an account.

Smart contract properties and operations can be naturally mapped
to relational logic. For example, transactions, the main element in
smart contracts, can be modeled as relational tables, where table
schema contains transaction parameters, e.g., sender, recipient, and
amount. Similarly, the balance of each account can be expressed as
sum aggregation on transaction records and looking up an account
balance can be expressed as a constraint on the address column of
the balance table.

Given this relational view of transactions, committing a transac-
tion can be interpreted as appending a new row to the correspond-
ing table. The commit and abortion logic of a pending transaction
is specified by declarative rules based on Datalog. Views can be
specified as declarative queries on these tables. For example, an

 
 
 
 
 
 
ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

Haoxian Chen, Gerald Whitters, Mohammad Javad Amiri, Yuepeng Wang, and Boon Thau Loo

account balance is its total income subtracted by total expense, each
of which is a query on relevant transaction records.

Contract properties are also specified as inference rules. They are
interpreted as property violation queries, a special kind of views,
and are expected to be always empty during correct executions.
For example, if a smart contract forbids overspending, then a query
on accounts with negative balances should always be empty. Such
unification of implementation and property specification language
saves programmers‚Äô effort to learn another language to formally
specify properties.

DeCon complies declarative specifications into executable So-
lidity [8] programs that run on blockchains, e.g., Ethereum, and
monitor the specified properties at run-time. When a property
(violation) view is derived non-empty after executing a pending
transaction, the transaction is aborted. Such automatic code gen-
eration not only saves implementation effort, but also eliminates
the gap between the program specification and implementation,
providing a stronger guarantee of the verification result.

The key insight to generate efficient executable code from declar-
ative specifications is that smart contract transactions are executed
in sequence. In other words, new rows are appended to the trans-
action tables one at a time. Therefore, DeCon borrows the idea of
incremental view maintenance in databases [33] to generate effi-
cient update procedures. On committing a new transaction, instead
of evaluating the queries on the whole tables, only the differences
in query results are computed and applied to existing views.

In addition, DeCon is easy to debug with data provenance [24].
Provenance is a mechanism for explaining how certain tuples or
facts are derived, right down to the input values. In an imperative
language like Solidity [8], dependency information is difficult to be
captured automatically (through data-flow analysis). In contrast,
inference rules in DeCon give explicit dependency information,
where each tuple can be directly attributed to one rule, thus pro-
viding more clarity to the execution process.

The key contributions of the paper are as follows:

‚Ä¢ We design DeCon, a declarative language that unifies smart
contract implementation and specification. We demonstrate
its expressiveness via case studies on representative smart
contracts and their high-level correctness properties.

‚Ä¢ We design an algorithm to compile these high-level specifi-
cations into executable Solidity programs, with instrumen-
tation for run-time verification.

‚Ä¢ We implement and experimentally evaluate DeCon. Our
evaluation shows that the generated executable code has
comparable efficiency with the equivalent open-source im-
plementation of the same contract (14% median gas over-
head), and the overhead of run-time verification is moderate
(16% median gas overhead). The prototype implementation
and evaluation benchmarks are open-sourced [2] for future
studies and comparisons.

The rest of this paper is organized as follows. Section 2 motivates
DeCon using a Wallet example. The declarative smart contract
language is presented in Section 3. Section 4 demonstrates how to
translate declarative rules into an executable Solidity program. The
expressiveness of DeCon is demonstrated in Section 5 using two

balanceOf (p ,m) , n <= m.

1 // Transaction event triggers
2 . decl recv_mint (p: address , amount : int )
3 . decl recv_burn (p: address , amount : int )
4 . decl recv_transfer ( from : address , to : address , amount : int )
5
6 // Views
7 . decl * totalSupply (n: int )
8 . decl balanceOf (p: address , n: int ) [0]
9 . public totalSupply , balanceOf
10
11 // Transaction rules
12 . decl mint (p: address , amount : int )
13 . decl burn (p: address , amount : int )
14 . decl transfer ( from : address , to : address , amount : int )
15 r1 : mint (p ,n):- recv_mint (p ,n) , msgSender (s) , owner ( s) ,n >0.
16 r2 : burn (p ,n):- recv_burn (p ,n) , msgSender (s) , owner ( s) ,
17
18 r3 : transfer (s ,r , n ): - recv_transfer (s ,r ,n) , balanceOf (s , m ) ,
19
20
21 // View rules
22 r4 : totalSupply (n ):- allMint (m) , allBurn (b) ,n := m -b .
23 r5 : balanceOf (p ,s): - totalOut (p ,o) , totalIn (p ,i ) ,s :=i - o.
24
25 // Auxiliary relations and rules ...
26 . decl totalMint (p: address , n : int ) [0]
27 . decl totalBurn (p: address , n : int ) [0]
28 r6 : transfer (0 ,p , n ) :- mint (p ,n).
29 r7 : transfer (p ,0 , n ) :- burn (p ,n).
30 r8 : totalOut (p ,s) :- transfer (p ,_ ,_ ) ,
31
32 r9 : totalIn (p ,s): - transfer (_ ,p ,_) ,
33
34 . decl * allMint (n: int )
35 . decl * allBurn (n: int )
36 r10 : allMint (s) :- s = sum n: mint (_ , n) .
37 r11 : allBurn (s) :- s = sum n: burn (_ , n) .

s= sum n: transfer (p ,_ ,n).

s= sum n: transfer (_ ,p ,n).

n >= m.

Listing 1: Wallet smart contract

case studies. Section 6 experimentally evaluates DeCon. Section 7
discusses related work, and Section 8 concludes the paper.

2 ILLUSTRATIVE EXAMPLE
In this section, we show how to use DeCon to implement a smart
contract, specify its properties, and debug via provenance using a
Wallet smart contract that manages digital tokens.

2.1 Contract Implementation
A smart contract offers two kinds of interfaces: transactions and
views. Transactions are the function calls that update the contract
states. Views, on the other hand, are read-only functions that return
one or more contract states.

In declarative smart contracts, transaction records are the only
states. Transactions are modeled as relational tables. A new row is
appended to the table when a new transaction is committed, with
column entries storing the transaction parameters. Transaction
rules, i.e., the condition on which a new transaction can be commit-
ted, are specified as declarative rules. Finally, views are specified as
declarative queries over the transaction tables.

We use the Wallet example, shown in Listing 1, to explain how
relational tables and declarative rules can be specified. The Wallet
contract manages token transactions between Ethereum addresses,
where the contract owner can mint or burn tokens to addresses,
and different addresses can transfer tokens to each other.
Relations and interfaces. Lines 1 to 14 declare the relations, with
schema in the parenthesis, and, optionally, primary key indices in

Declarative Smart Contracts

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

the bracket (e.g., balanceOf on line 8). Primary keys uniquely identify
a row in the table. For instance, balanceOf records the balance of each
account, and thus has unique account column. Without explicit
specification, all columns are treated as primary keys. Relation
totalSupply (line 7) is a singleton relation, a kind of relation that
contains only one row and is annotated by a star symbol.

Given these relation declarations, transaction and view inter-
faces are generated. First, transaction interfaces are generated from
relations with recv_ prefix, where the the input parameters define
the schema and a boolean return value indicates the success of the
transaction. For example, relation recv_mint is translated into the
following interface in Solidity, the target executable language:

function mint ( address p , int amount ) returns ( bool );

Second, view functions are generated from the relations that appear
in the public interface annotations (line 9). The input parameters
are the primary keys, and output is the remaining values. Note that
a singleton relation, e.g., totalSupply, becomes a function without
parameters since it has no primary keys. If all columns are pri-
mary keys, then the function returns a boolean value indicating the
existence of the row. For example, balanceOf(p:address, n:int)[0] is
translated into the following function interface:

function balanceOf ( address p) returns ( int );

Rules and functions. The rest of the program shows the rules
that process transactions and define the views. Each rule is of the
form <head> :- <body>, interpreted as follows. For all valuation of
the variables that satisfies all constraints in the body, generate a
row as specified in the head. For example, r1 on line 15 says that
a mint transaction can only be sent by the contract owner, and the
amount should always greater than 0. This rule is compiled into
the following Solidity code (with simplification):

function mint ( address p , int n) ( returns bool ) {

bool ret = false ;
if ( msg . sender == owner && n >0) {

// call functions to update dependent views ...
ret = true ;

}
return ret ;

}

When a mint transaction is committed, r5 will be triggered through
a chain of rules (r1->r6->r9->r5). It specifies the balance of an account
p, as the total income totalIn(p,i) subtracted by the total expense
totalOut(p,o), with totalIn and totalOut further defined by r8 and r9,
respectively. This rule is compiled into two Solidity functions, each
updates balanceOf[p] when either totalIn or totalOut is updated.

function updateBalanceOfOnTotalIn ( address p , int i) {

int o = totalOut [p ];
balanceOf [p] = i -o;

}
function updateBalanceOfOnTotalOut ( address p , int o) {

int i = totalIn [p ];
balanceOf [p] = i -o;

}

To get the balance of a given account, one could call balanceOf,
a view function that takes the account address as parameter, and
returns an integer value as the account balance. In DeCon, rela-
tional tables are stored in maps, mapping primary keys to values
in remaining columns. This view function is generated as follows.

function balanceOf ( address p) public view returns ( int ) {

// Read the row by primary key p
BalanceOfTuple memory balanceOfTuple = balanceOf [ p ];
// Return the value
return balanceOfTuple . n;

}

2.2 Specification and Run-time Verification
In DeCon, properties are specified the same way as views, but with
additional annotation in order for DeCon to know what to monitor
at run-time. For example, in the Wallet contract, one may want
to make sure that all account balances are always non-negative,
which can be specified as follows.

. decl negativeBalance (p: address ,n : int ) [0]
. violation negativeBalance
r14 : negativeBalance (p ,n) :- balanceOf (p , n) , n < 0.

Rule r14 specifies the violation instance of the property: for each
row in balanceOf table with n<0, insert a row (p,n) in negativeBalance
table. During the execution of the transaction, the negativeBalance
table is incrementally updated when its dependent relations are
updated, the same as other views.

A property is satisfied if and only if the violation table is empty.
The keyword .violation annotates that every row in the negativeBalance
table is a property violation instance. Given such annotations, De-
Con instruments the program to check the emptiness of all violation
tables before each transaction is committed.

Note that properties are monitored on the granularity of trans-
actions. As we show in Section 4, due to the underlying update
procedure, transient violations could occur during the execution
of a transaction, but disappear at the end. Therefore, instead of
aborting right after a violation tuple is derived, a transaction is only
aborted if, at the end of its execution, any violation table remains
non-empty. Such interpretation allows programmers to reason at
the transaction level, without worrying about the underlying up-
date procedure.

The violation checking procedure is generated and performed
at the end of each transaction. In this example, the negativeBalance
violation is checked as follows:

function checkViolations () {

if negativeBalance is not empty :

revert (" Negative ‚ê£ balance .")

// check other violations ...

}

2.3 Debugging via Provenance
Data provenance is a feature of declarative programs that records
the data flow from input to output and enables rule-wise debugging.
It allows counter-example traces to be presented in the context of
the original specification, instead of the low-level EVM instructions,
thus making the debugging process more intuitive.

Suppose the original program has an incorrect ùëü 2, which misses
a predicate to check that the account has enough balance to be
burnt. The incorrect version of ùëü 2 is shown as ùëü 2‚Ä≤ in the following.

r2 ': burn (p ,n):- recv_burn (p ,n) , msgSender ( s) , owner ( s).

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

Haoxian Chen, Gerald Whitters, Mohammad Javad Amiri, Yuepeng Wang, and Boon Thau Loo

(ùëáùë¶ùëùùëí) ùëá
(ùëÜùëê‚Ñéùëíùëöùëé) ùëÜ

:= ùëñùëõùë° | ùë¢ùëñùëõùë° | ùëèùëúùëúùëô | ùëéùëëùëëùëüùëíùë†ùë†
:= ùëê1 : ùëá 1, ùëê2 : ùëá 2, ...

(ùëÉùëüùëñùëöùëéùëüùë¶ ùëòùëíùë¶ùë†) ùêæ := ùëò1, ùëò2, ...

(ùëÖùëíùë†ùëíùëüùë£ùëíùëë ùëüùëíùëôùëéùë°ùëñùëúùëõ) ùëÖùëÜ
(ùëÜùëñùëõùëîùëôùëíùë°ùëúùëõ ùëüùëíùëôùëéùë°ùëñùëúùëõ) ùëÜùê∫ := .ùëëùëíùëêùëô ‚àó ùëü (ùëÜùëê‚Ñéùëíùëöùëé)

(ùëÜùëñùëöùëùùëôùëí ùëüùëíùëôùëéùë°ùëñùëúùëõ) ùëÜùëÉ
(ùëá ùëüùëéùëõùë†ùëéùëêùë°ùëñùëúùëõ ùëüùëíùëôùëéùë°ùëñùëúùëõ) ùëá ùëÖ
(ùëÖùëíùëôùëéùë°ùëñùëúùëõ) ùëÖ

:= .ùëëùëíùëêùëô ùëü (ùëÜùëê‚Ñéùëíùëöùëé) [ùêæ]
:= .ùëëùëíùëêùëô ùëüùëíùëêùë£_[ùëü ] (ùëÜùëê‚Ñéùëíùëöùëé)
:= ùëÖùëÜ | ùëÜùê∫ | ùëÜùëÉ

(ùê¥ùëõùëõùëúùë°ùëéùë°ùëñùëúùëõ) ùê¥ := .ùëùùë¢ùëèùëôùëñùëê ùëÖ | .ùë£ùëñùëúùëôùëéùë°ùëñùëúùëõ ùëÖ

Figure 2: Syntax of relation declarations and annotations

(ùëâ ùëéùëüùëñùëéùëèùëôùëí) ùë•

(ùê¥ùëîùëîùëüùëíùëîùëéùë°ùëñùëúùëõ) ùê¥ùëîùëî := ùë†ùë¢ùëö | ùëöùëéùë• | ùëöùëñùëõ | ùëêùëúùë¢ùëõùë°

(ùêπùë¢ùëõùëêùë°ùëñùëúùëõ) ùêπ := +| ‚àí | √ó |√∑
(ùê∂ùëúùëõùëëùëñùë°ùëñùëúùëõ) ùê∂ := > | < | >= | <= | == |! =

(ùëá ùëüùëéùëõùë†ùëéùëêùë°ùëñùëúùëõ ùëüùëíùëôùëéùë°ùëñùëúùëõ) ùëá ùëÖ := ùëüùëíùëêùë£_[ùëü ]

(ùëÇùë°‚Ñéùëíùëü ùëüùëíùëôùëéùë°ùëñùëúùëõ) ùëÖ

(ùêªùëíùëéùëë ùëôùëñùë°ùëíùëüùëéùëô) ‚Ñé := ùëÖ( ¬Øùëã )
(ùêµùëúùëëùë¶ ùëôùëñùë°ùëíùëüùëéùëô) ùëè := ùëÖ( ¬Øùëã ) | ùê∂ ( ¬Øùëã ) | ùë¶ = ùêπ ( ¬Øùëã )

| ùë¶ = ùê¥ùëîùëî ùë• : ùëÖ( ¬Øùëã )

(ùëá ùëüùëéùëõùë†ùëéùëêùë°ùëñùëúùëõ ùëÖùë¢ùëôùëí) ùëá ùë• := ‚Ñé : ‚àí ùëá ùëÖ( ¬Øùëã ), ùëè1, ..., ùëèùëõ
(ùëâ ùëñùëíùë§ ùëÖùë¢ùëôùëí) ùëâ := ‚Ñé : ‚àí ùëè1, ..., ùëèùëõ

Figure 3: Syntax of rules

On inserting a new row, if an existing row has the same primary
key, the existing row is replaced by the new row.
Singleton relations are relations with only one row, which are
annotated with ‚àó in the specification. When a new row of a singleton
relation is inserted, it replaces the existing row.
Transaction relations are relations with prefix recv_. As explained
in the next section, when used in a rule, these relations are treated
as an event trigger, and are compiled into smart contract interfaces
that handle incoming transaction requests.
Reserved relations. The following relations are reserved to handle
smart contract specific constructs:
‚Ä¢ msgSender(a:address) stores the address of message sender.
‚Ä¢ msgValue(v:uint) stores the values of Ethers sent along a message.
‚Ä¢ send(to:address, n:uint32) triggers a transaction that sends ùëõ Ethers

to another account.

‚Ä¢ constructor(*) is translated into the constructor function, with

schema being function parameters.

3.2 Rules
As shown in Figure 3, we distinguish two kinds of rules: transac-
tion rules and view rules. A transaction rule contains a transaction
relation in its body. Transaction relations are relations with a prefix

Figure 1: Provenance of a violation of negative balance

An account with balance ùëõ would have negative balance if more
than ùëõ tokens are burnt. Suppose during an execution, the account
0ùë•01 is detected to have negative balance of ‚àí20. To understand
why this violation happens, one could query the violation tuple‚Äôs
provenance tree, as shown in Figure 1. The provenance tree is
read from top to bottom. On the top is a tuple balanceOf(0x01,-20)
that triggers the violation in negativeBalance. Below shows that it
is derived by r5, based on totalIn(0x01,100) and totalOut(0x01,120),
which are the total tokens received and sent by address 0x01. The
tuple totalOut(0x01,120) is further derived by r8. This back tracing
continues for another step until one finds the derivation of r2'
is incorrect, which suggests that the condition balanceOf(p,m),m>=n
should be added. With this provenance, programmers can debug
contracts in a visual and interactive manner.

3 LANGUAGE
A DeCon contract consists of three elements: relations, rules, and
relation annotations. A relation declaration specifies the name of
a relational table and its schema. Each relational table can store
either transaction records, with the transaction parameters being
the column values, or views, the summary information of these
transaction records. A rule specifies either the conditions on which
a new transaction gets approved or the derivation of a view from the
transaction records. Finally, relation annotations specify whether
a relational table is a public view or a violation. Public views are
compiled into public interfaces that take the relation‚Äôs primary keys
as parameters, and return the remaining values in the matching row.
Violation will be monitored during run-time, and a transaction is
reverted if the violation relation is non-empty after the transaction
execution.

3.1 Relation Declarations and Annotations
The formal syntax of relation declarations and annotations is de-
fined in Figure 2.
Schema. Schema of a relation is specified as a list of ùëêùëñ : ùëáùëñ , where
ùëêùëñ is the column name for the ùëñth column, and ùëáùëñ is the data type.
Primary keys. Primary keys ùêæ are a list of indices in the relation
schema. Primary key specification is optional. If a simple relation
is specified without primary keys, then all columns are treated as
primary keys. Primary keys uniquely identify a row in each table.

balanceOf(0x01,-20)totalIn(0x01,100)totalOut(0x01,120)r5r8burn(0x01,50)totalOut(0x01,70)r2'recv_burn(0x01,50)Declarative Smart Contracts

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

ùëüùëíùëêùë£_ in names. These rules are only fired on receiving the corre-
sponding transaction request, and the transaction is approved if
the rest of the constraints in the rule body are satisfied. A view rule,
on the other hand, does not contain any transaction relations. It is
evaluated whenever one of the relations in the body is updated.
Syntax restrictions. DeCon does not support recursions. That is,
no dependency loop exists between any two relations. The depen-
dency relationship in DeCon is defined as follows.

Definition 3.1 (Relation dependency). Relation ùëÖùëé is dependent
on relation ùëÖùëè , if there exists a view rule where ùëÖùëé is in the head
and ùëÖùëè is in the body, or a transaction rule where ùëÖùëé is in the head,
and ùëÖùëè is a transaction relation (with a prefix recv_) in the body.

Rule semantics. A rule is evaluated as follows. For each variables
valuation ùúã that satisfies the rule constraint, generate the head
tuple with all variables assigned to its corresponding values in ùúã.
A variable valuation is a mapping from the set of variable names
ùëâ to the variable domain ùê∑ (ùúã : ùëâ ‚Üí ùê∑). Rule constraint is a
conjunction of all body literal constraints. As described in Figure 3,
there are four kinds of body literals. For literals in the form of
relational tuples ùëÖ( ¬Øùëã ), the constraint is satisfied if row ¬Øùëã exists
in the relational table ùëÖ. Other kinds of literals (i.e., conditions,
functions, and aggregations) are directly interpreted as constraints
on the variables.

Take r5 in the Wallet example (listing 1) for instance.

r5 : balanceOf (p ,s ):- totalOut (p , o) , totalIn (p ,i) ,s :=i -o.

This rule is interpreted as follows: "for all values of variable ùëù, ùëú, ùëñ
such that there exists a tuple ùë°ùëúùë°ùëéùëôùëÇùë¢ùë° (ùëù, ùëú) and ùë°ùëúùë°ùëéùëôùêºùëõ(ùëù, ùëñ), derive
the head tuple ùëèùëéùëôùëéùëõùëêùëíùëÇ ùëì (ùëù, ùë†), where ùë† = ùëñ ‚àí ùëú".
Aggregation literal ùê¥ùëîùëî ùë• : ùëÖ( ¬Øùëã ) computes the aggregate for all
rows in relation ùëÖ that satisfy the rule constraint. For example, in
the Wallet example (listing 1), line 31 shows a rule with aggregation.

r8 : totalOut (p ,s) :- transfer (p ,_ , _) ,s= sum n: transfer (p ,_ ,n)

For each unique value of ùëù in the first column of transfer table, this
rule computes the sum of the third column for rows in transfer table
that has the value ùëù in the first column. In other words, this rule
groups the table by the first column, and then computes the sum of
the third column within each group.
Limitations in expressiveness. DeCon forbids recursions in or-
der to keep the gas consumption predictable and affordable. In fact,
recursion is not recommended by the Solidity documentation for
stack space issues [4].

In addition, there are functions lie outside of relational logic,
e.g. cryptographics, randomized functions, etc. Such functions can
be implemented in DeCon by linking the contract with external
libraries. However, we recognize that analyzing such functions is a
challenging problem, and would need substantial future research.
Other unsupported features including contract inheritance and
dynamic dispatching, and checking interfaces of another contract,
but they can be incorporated into DeCon in future compiler designs.

4 COMPILATION TO SOLIDITY
DeCon translates a set of declarative rules into an executable Solid-
ity program that (1) processes transactions following the conditions

in transaction rules, (2) updates views incrementally as new trans-
actions are committed, and (3) monitors property violations.

The compilation process involves three major steps.

(1) Abstract update functions. First, each rule is translated into
a set of abstract update functions, each of which performs incre-
mental updates to the head relation when one of the body relations
is updated. These functions are abstract in that they do not imple-
ment concrete data structures. For example, recall that in the Wallet
contract in Section 2, the following rule processes mint transactions:

r1 : mint (p ,n):- recv_mint (p ,n) , msgSender (s) , owner ( s) ,n >0.

It is translated into the following abstract update function:

1
2
3
4
5
6
7

on insert recv_mint (p ,n) {

search owner where

{

address s = owner .p;
search msgSender where s == msg . sender {

if (n >0) {

insert mint (p ,n)

}}}}

This update function is triggered when a mint transaction is received,
as indicated by the event trigger tuple recv_mint(p,n). The remaining
two relational literals, owner(s) and msgSender(s), are translated into
nested search statements (line 2 and line 4). A search statement has
the form (search R where C do S), where ùëÖ is the relational table, ùê∂ is
the set of constrains on rows, and ùëÜ is the statement to execute for
each row that satisfies the constraints in ùê∂. The condition literal
(n>0) is translated into an if statement (line 5). If all prior conditions
are satisfied, we arrive at line 6, where the rule head is inserted.
(2) Data structures. These abstract functions are then translated
into concrete Solidity statements, where the search statements be-
come efficient join algorithms on concrete data structures, and
update functions for dependent views are called after an insert
statement.
(3) Instrumentation. In the last step, the Solidity program is in-
strumented to monitor property violations, and abort the transac-
tion if any violation has been detected by the end of transaction
execution.

4.1 Abstract Update Function Generation
There are two kinds of updates that could trigger a rule: tuple inser-
tion and tuple deletion. We use ùêºùëõùë†ùëíùëüùë° (ùëí) and ùê∑ùëíùëôùëíùë°ùëí (ùëí) to denote
the update trigger on inserting and deleting a tuple ùëí, respectively.
Note that both a tuple and a literal have the form ùëÖ( ¬Øùëã ). It is called a
tuple when ¬Øùëã has concrete values, and called literal in a rule, where
¬Øùëã is symbolic. In the following discussion of update triggers we
use literal and tuple interchangeably.

Given a rule ùëü , let ùêµ(ùëü ) be the set of all relational literals in ùëü ‚Äôs
body, and ùëí be the transaction relation in ùëü if ùëü is a transaction rule,
the set of update triggers ùëá (ùëü ) are defined as:

ùëá (ùëü ) (cid:66)

{ùêºùëõùë†ùëíùëüùë° (ùëô), ùê∑ùëíùëôùëíùë°ùëí (ùëô)}

(cid:208)
ùëô ‚ààùêµ (ùëü )
{ùêºùëõùë†ùëíùëüùë° (ùëí)}

ùëü is View

ùëü is Tx rule

(1)

Ô£±Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥
Ô£≥

If ùëü is a view rule, then it can be triggered by updates of any relation
in its body. Otherwise, ùëü is a transaction rule, and it is only triggered
on receiving a transaction request.

For each rule ùëü , and for each update triggers in ùëá (ùëü ), an abstract
update function is generated by UpdateFunction(r, t), presented

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

Haoxian Chen, Gerald Whitters, Mohammad Javad Amiri, Yuepeng Wang, and Boon Thau Loo

Algorithm 1 UpdateFunction(ùëü, ùë°). Given a rule ùëü , and a trigger ùë°,
returns an update object.

‚Ä¢ A relational literal ùëÖ( ¬Øùëã ). Given the set of grounded variables ùê∫,
the search constraints for rows in ùëÖ is generated as follows.

(1) Initialize the set of grounded variables ùê∫ (cid:66) ùë° .ùë£ùëéùëüùëñùëéùëèùëôùëíùë†.
(2) Literals other than the trigger ùêø (cid:66) {ùëü .ùëèùëúùëëùë¶ \ ùë° }.
(3) Update procedure ùëÜ (cid:66) Update(ùëü .‚Ñéùëíùëéùëë, ùêø, ùë°, ùê∫).
(4) Return (on t do S)

in algorithm 1. It first initializes the set of grounded variables by
variables in the trigger literal. Grounded variables are variables that
are constrained to a constant value. Variables in a trigger literal
are considered grounded because the update function is always
triggered by the insertion or deletion of a concrete tuple. In step(3),
update procedure ùëÜ is generated by a sub-routine Update, which
is presented in algorithm 2. Finally, it returns the abstract update
function in the form of (on t do S), where ùë° is the update trigger and
ùëÜ is the update procedure.

Algorithm 2 Update(‚Ñé, ùêø, ùë°, ùê∫). Given a rule head ‚Ñé, a list of body
literals ùêø, an update trigger ùë°, and the set of grounded variables ùê∫,
return statements that perform the incremental update.

match ùêø:

case ùëÅ ùëñùëô => match t

case Insert => return Insert(h)
case Delete => return Delete(h)

case ‚Ñéùëíùëéùëë :: ùë°ùëéùëñùëô =>

Add grounded variables ùê∫ ‚Ä≤ (cid:66) ùê∫ ‚à™ {ùë• |ùë• ‚àà ‚Ñéùëíùëéùëë}
Inner statements ùëÜ (cid:66) Update(h, tail, t, G‚Äô)
match head:

case ùëÖ( ¬Øùëã ) =>

Derive constraints ùê∂ (cid:66) Constraint(ùëÖ( ¬Øùëã ), ùê∫)
return (Search R where C do S)
case ùê∂ ( ¬Øùëã ) => return (If C Then S)
case ùë¶ = ùêπ ( ¬Øùëã ) => return (ùë¶ = ùêπ ( ¬Øùëã ) :: ùëÜ)
case ùë¶ = ùê¥ùëîùëî ùë• : ùëÖ( ¬Øùëã ) =>

return (ùë¶ = ùê¥ùëîùëî ùë• : ùëÖ( ¬Øùëã ) :: ùëÜ)

As shown in Algorithm 2, Update(h, L, t, G) performs recursion
on ùêø, the list of literals in the rule body, with every recursion
translating one literal to a layer of code block, nested within the
code block generated by the previous literals.

In particular, it performs pattern matching on input ùêø, a list
of literals to be translated. If ùêø is empty, which means all body
literals have been translated, an update statement consistent with
the update trigger is returned. Otherwise, ùêø has the form ‚Ñéùëíùëéùëë ::
ùë°ùëéùëñùëô. It first adds all variables in ‚Ñéùëíùëéùëë into the set of grounded
variables, and then generates the inner code blocks ùëÜ by recursively
calling itself on ùë°ùëéùëñùëô and the updated set of grounded variables ùê∫ ‚Ä≤.
Depending on the form of ‚Ñéùëíùëéùëë, the current layer of code block
is generated in different ways. By the syntax of the language in
Section 3, ‚Ñéùëíùëéùëë could take one of the following forms:

ùê∂ùëúùëõùë†ùë°ùëüùëéùëñùëõùë°ùë† (ùëÖ( ¬Øùëã ), ùê∫) (cid:66) (cid:219)

{(ùëÖ [ùëñ] == ùë£)|ùë£ ‚àà ùê∫, ùë£ ‚àà ¬Øùëã,
ùëñ = ¬Øùëã . indexOf (ùë£)}

where ùëÖ [ùëñ] == ùë£ means filtering rows in table ùëÖ whose ùëñ-th
column equals to ùë£.

‚Ä¢ A condition literal ùê∂ ( ¬Øùëã ), in which case, the condition is directly
used in the same way as an If condition, with the inner code
block ùëÜ placed within the If statement.

‚Ä¢ A function or aggregation. In either case, the literal is directly
translated into an assignment statement, followed by the inner
code block ùëÜ.

Aggregations. The evaluation results of aggregation functions are
maintained incrementally. Sums are incremented by ùëõ when a row
with aggregate value ùëõ is inserted, and decremented by ùëõ when
a row is deleted. Similarly, counts are incremented by 1 on row
insertion, and decremented by 1 on row deletion. Maximums and
minimums are slightly different. When a new row is inserted with
value ùëõ, if ùëõ is greater than the current maximum, the maximum is
updated to ùëõ. When the current maximum row is deleted, the maxi-
mum is updated as the second maximum value. Thus, it requires
maintaining a sorted list of values. Minimum is maintained in a
similar fashion.

4.2 Concrete Data Structures and Instructions
Given the abstract functions generated from each rule, the next
step is to generate concrete and efficient data structures and search
algorithms in the Solidity language.
Data structures. Each relational table ùëÖ, except singleton relations,
is translated into a mapping from its primary keys to a structure
that stores the rest of the column values:

struct RTuple {
bool valid ;
T1 field1 ;
T2 field2 ;
...

};
mapping ( k1 => k2 = > ... => kn => RTuple ) R ;

Note that hash-maps in Solidity by default map all keys to zero.
Therefore, a valid bit (valid) is introduced to indicate the existence
of a tuple. Columns other than primary keys are the structure
members. If all columns are primary keys, then its structure only
contains a valid bit.

Singleton relations are directly stored in a structure with columns

being the structure members.
Join index. Join index is built for each search statement in the
abstract update program. Given a search statement Search R where
C do S in the abstract update program, if all primary keys of ùëÖ
are constrained to constant values, no join index is generated. The
matching entry can be directly looked up by primary keys.

On the other hand, if, in some rules, not all primary keys of ùëÖ
are constrained to constant values, a join index is built as a map
from the constrained keys to a list of unconstrained keys.

Suppose relation ùëÖ1 (ùëò1, ùëò2, ùë£1) has two primary keys ùëò1 and
ùëò2. As described above, table ùëÖ1 is stored as a map from primary

Declarative Smart Contracts

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

keys to remaining values (mapping(k1=>k2=>R1Tuple)). Given a search
statement Search R1 where R1[0]==k1 do S, where only one primary
key ùëò1 is constrained, the join index for ùëÖ1 is built as the following.

view is non-empty, the transaction is aborted. Note that a Solidity
mapping does not record its domain. So a separate array of mapping
keys are maintained and iterated for valid violation tuples.

struct R1KeyTuple {
bool valid ;
T2 k2 ;

}
mapping ( k1 => R1KeyTuple []) R1Index ;

where R1Index maps ùëò1 to a list of ùëÖ1ùêæùëíùë¶ùëáùë¢ùëùùëôùëí, which stores
value of the other primary key ùëò2. During the join execution, to
iterate all rows in ùëÖ1 that satisfy ùëÖ1 [0] == ùëò1, it first looks up all ùëò2
in R1KeyTuple[k1], and then for each ùëò2, get the value in R1[k1][k2].

Update dependent views. An insert or delete statement in the
abstract update function is translated into two sets of Solidity in-
structions: (1) update the corresponding data structure; and (2) call
the update functions for the dependent relations (Definition 3.1).
Inserting a relational tuple ùë°1 directly updates the map, as well
as the join index if one exists. If a tuple ùë°0 with the same primary
keys exists, all dependent views are updated by first calling deletion
updates on ùë°0, and then the insertion updates on ùë°1. Insertion update
refers to functions triggered by tuple insertion, and deletion update
refers to functions triggered by tuple deletion. Otherwise, insertion
updates are directly called. Since a Solidity mapping maps all keys
to value zero by default, a tuple exists if its valid bit is set to true.
Deleting a relational tuple resets its valid bit to false. Then dele-

tion updates are called for all dependent relations.

In this way, when a new transaction is committed, all depen-
dent views are updated through this chain of update propagation.
Since there is no recursion, i.e., dependency loop between relations,
allowed in DeCon, update propagation is guaranteed to terminate.

Logging. Committed transactions are logged as Solidity Events [9],
a more gas efficient storage than global memory, but can only be
read offline. These events constitute all states of a DeCon contract,
which enable offline analysis for further insights and potential bugs.

4.3 Run-time Verification
Properties are specified as declarative rules that derive violation
instances. Such relations are annotated with the keyword violation.
As introduced in Section 2.2, transient violations that occur dur-
ing the transaction execution are not counted. To see why transient
violations can occur, consider again the Wallet contract in Section 2,
and a property that all account balances add up to the total supply.
The property can be specified as shown in Listing 2.

. violation unequalTotalSupply
r12 : totalBalance (s) :- sum n: balanceOf (_ ,n).
r13 : unequalTotalSupply (n ,m):- totalSupply (n) ,

totalBalance (m) ,n != m.

Listing 2: All account balances add up to total supply.

During the execution of a mint transaction, the totalSupply and
the totalBalance are updated in sequence, which leads to a violation
when one is updated before another, but the violation disappears
when both are updated.

Given this notion of transient violations, instead of aborting the
transaction right after a violation tuple is derived, the checking
procedure is deferred to the end of transaction. If any violation

4.4 Provenance Generation
To debug a violation, programmers can use data provenance to
visualize the derivation process of a violation tuple. As shown in
Figure 1, provenance is a directed graph with two kinds of vertices:
tuples and rules. Edges from a tuple vertex to a rule vertex denote
tuple reads, and edges from a rule vertex to a tuple vertex denote
tuple derivations.

To generate this provenance graph during the rule evaluation
procedure, two kinds of additional records are logged: tuple read
Read(tuple, rid) and tuple derivation Write(rid,tuple), where rid is
a unique identifier for each rule. Read(tuple,rid) is interpreted as an
edge from tuple to the rule indexed by rid, and, conversely, Write(
rid,tuple) is an edge from rule rid to tuple.

Note that in Solidity, a failed transaction reverts all instructions,
including logging. When a transaction is reverted due to a property
violation, the provenance logs would also be reverted. Therefore,
to generate provenance for a violation tuple, the transaction needs
to be executed in a local debugging environment instead of the
deployment blockchain. This practice also saves storage space on
the public blockchain.

4.5 Optimizations
To improve gas and storage efficiency, two optimizations have been
applied to the generated codes.

Join order. Body literals in a rule are sorted by their iteration cost
in an increasing order. First are reserved relations and singleton
relations, since they need no iteration. Second are the relations
whose primary keys have all appeared in proceeding literals. These
literals can be searched via a direct mapping look-up, thus requiring
no iterations either. Next are the rest of the relations, which are
translated into loops. Finally come condition and function literals.

Storage space. Storage space on a blockchain is precious due to
the high synchronization cost. Deriving relations on-demand, that
is, delaying evaluating an inference rule until it is used, can save
storage space, but may incur performance overhead. To achieve a
balanced trade-off between time and space, DeCon only proactively
derives and stores relations annotated as public views or violations,
as well as relations that are read during their derivation. Other
relations are derived on-demand. For example, in the Wallet con-
tract in Section 2, relation mint only serves as an update trigger for
dependent rules, which is never queried during the update of public
views or violations. Therefore, when a mint tuple is generated by r1,
it only triggers the update for dependent rules, but it is not written
to the persistent storage.

5 CASE STUDIES
In this section we demonstrate the expressiveness of DeCon and the
explainability of data provenance via case studies on two typical
smart contracts. For brevity, only a subset of rules are discussed.
All contracts are available online [1].

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

Haoxian Chen, Gerald Whitters, Mohammad Javad Amiri, Yuepeng Wang, and Boon Thau Loo

5.1 ERC20
ERC20 [28] is a token standard for fungible tokens. Similar to the
Wallet contract in Section 2, it also supports token transfers between
users. In addition, it has an allowance mechanism, where users can
allow other users to transfer their tokens, up to a certain amount
called allowance. The allowance mechanism can be specified as
follows.

r1 : transferFrom ( sender , receiver , spender ,n) :-

recv transferFrom ( sender , receiver , n) ,
/* Sender has enough balance . */
balanceOf ( sender ,m) , m >=n ,
/* Operator has enough allowance . */
msgSender ( spender ) ,
allowance ( sender , spender ,l) ,l >= n.

On receiving a transferFrom transaction, in addition to checking
that the sender has enough balance (m>=n), the rule also requires the
spender to have enough allowance to spend tokens on sender‚Äôs behalf
(l>=n). The relation transferFrom represents transactions where the
spender sends ùëõ tokens from the sender to the receiver.

The allowance of a spender on an account is specified as follows.

r2 : spentTotal (o ,s ,m) :- transferFrom (o ,_ ,s ,_) ,

m = sum n: transferFrom (o ,_ ,s , n) .

r3 : allowance (o ,s ,n) :- allowanceTotal (o ,s ,m) ,

spentTotal (o ,s ,l) , n := m -l.

The relation spentTotal accounts the amount of tokens m that spender
s has spent on behalf of the sender o. And allowance is derived by
subtracting the total spending from the total allowance, an amount
approved by the sender (defined in another rule).

Given the definition of allowance and the spentTotal, we can spec-

ify a property that a spender never overspends as the following:

. violation overSpent
overSpent (o ,s ,n ,m) :- allowanceTotal (o ,s ,n) ,

spentTotal (o ,s ,m) , m >n.

DeCon then generates instrumentation to monitor this property at
run-time.
Explain allowance changes via data provenance. Suppose the
programmer made a mistake in specifying spentTotal:

r2 ': spentTotal (o ,s ,m):- transferFrom (o ,_ ,s ,_) ,

m = sum n: transferFrom (_ ,_ ,s ,n).

The error is in the sum literal, where transferFrom records should be
grouped by both sender o and spender s, instead of just the spender.
When a spender account ùë† wants to transfer 20 tokens from
account ùëé to ùëè, by submitting a transaction transferFrom(a, b, s, 20),
it is reverted. DeCon explains that it is because the condition ùëô >= ùëõ
in ùëü 1 is false, which means the spender ùë† does not have sufficient
allowance to transfer tokens on ùëé‚Äôs behalf.

To understand why the spender only have 10 allowance to ùëé‚Äôs
account, one could get the provenance of the tuple allowance(a,s,10),
as shown in Figure 4a. On top of the provenance tree, allowance(a,s
,10) is derived by r3, from the fact that the total allowance is 100
(allowanceTotal(a,s,100)), and that a has spent 90 already (spentTotal
(a,s,90)). To see why spentTotal(a,s,90) is derived, the programmer
continues expanding its provenance tree. A bug is revealed at this
step, where a transaction from address ùëè to ùëü is accounted for ùë†‚Äôs
allowance on address ùëé, which points to the bug in ùëü 2‚Ä≤.

(a) allowance(a,s,10)

(b) transferFrom(a,s,r,tokenId)

Figure 4: Provenance tree for tuples.

5.2 ERC721
ERC721 [27] is a smart contract standard for non-fungible tokens
(NFTs). A main transaction for ERC721 tokens is transfer, which
records the transfer of a token from sender to recipient at a particular
time. The transaction time is included to specify the following views.
First is the view function ownerOf. Given the transfer relation, the

owner of a token is defined as follows.

latestTransfer ( tokenId ,s ,r ,t) :- transfer ( tokenId ,s ,r ,t ) ,
t = max i: transfer ( tokenId ,_ ,_ , i ).

ownerOf ( tokenId , p):- latestTransfer ( tokenId ,_ ,p ,_) ,p !=0.

where the first rule selects the latest transfer record for tokenId, and
the next rule specifies that if the recipient of the latest transfer is
non-zero, it is the owner of the token.

Next is the exist relation. A token exists if it is minted and is not
burnt. In ERC721 contracts, burning a token emits a transfer record
from its owner to zero address. So exist is defined as:

exists ( tokenId , true ) :-

latestTransfer ( tokenId ,_ ,to ,_) , to !=0.

The rule checks that a token‚Äôs latest transfer recipient is a non-zero
address, which means it is not burnt.

To ensure every existing token has an owner, we could specify

the following property:

. violation tokenNoOwner
tokenNoOwner ( tokenId ) :- ownerOf ( tokenId ,o) , o ==0.

which defines a property violation as entries in the ownerOf table
with owner address 0.
Explain an unexpected token transfer via data provenance.
Suppose the owner wants to understand why one of her tokens has
been transferred away in a transaction transferFrom(a,s,r,tokenId),
where a is the operator, s is the sender, and r is the receiver, she
expands the provenance tree for the transaction, which is shown in
Figure 4b. On top of the provenance tree is a transferFrom tranaction,
approved by the following rule:

r4 : transferFrom ( operator , sender , receiver , tokenId ) :-

recv transferFrom ( operator , sender , receiver ,

tokenId ) ,

/* Sender owns the token . */
ownerOf ( tokenId , sender ) ,

allowance(a,s,10)r3allowanceTotal(a,s,100)spentTotal(a,s,90)r2'spent(a,s,80)transferFrom(b,s,r,10)transferFrom(a,s,r,tokenId)r4ownerOf(tokenId,a)approved(tokenId,a)r5approve(b,s,tokenId)Declarative Smart Contracts

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

/* Operator is approved to move the token . */
msgSender ( operator ) , approved ( tokenId , operator ).

where ùëéùëùùëùùëüùëúùë£ùëíùëë (ùë°ùëúùëòùëíùëõùêºùëë, ùëúùëùùëíùëüùëéùë°ùëúùëü ) means that the token tokenId
has been approved to use by operator. This approval is set by the
token owner.

Suspicious about the approved(tokenId,a) tuple, the owner contin-
ues to expand the provenance tree, and finds that it is derived from
the following rule:

r5 : approved ( tokenId , operator ) :-

approve (_ , operator , tokenId ).

and the tuple approve(b,s,tokenId), which means account b, a previ-
ous owner, has approved this token to operator s before transferring
this token to a. Here, she finds the bug: r5 does not check that the
address that approves the token should be the token owner. The
rule should have been updated as follows instead:

r5 ': approved ( tokenId , operator ):- ownerOf ( tokenId , owner ) ,

approve ( owner , operator , tokenId ).

6 EVALUATION
We implement a prototype compiler [2] for DeCon in Scala that
generates Solidity programs with instrumentation for run-time
verification. We first evaluate the compiler by comparing its output,
without instrumentation, with reference contract written in Solidity.
Next, we evaluate the overhead of run-time verification on these
contracts and their properties.

6.1 Overhead to Reference Implementations

Reference smart contracts. We collect five reference smart con-
tract implementations from public repositories and prior research.
Wallet is the example shown in Section 2. CrowdSale is from prior
research paper [51]. Auction is from Solidity documentation [6].
ERC20 (fungible tokens) and ERC721 (non-fungible tokens) are two
of the most popular kinds of smart contract deployed on Ethereum,
1 and we use the implementation from the OpenZepplin library [3].

Declarative smart contract implementation. We implement
declarative counter-parts for all reference contracts with the same
interfaces and functionalities without instrumentation for run-time
verification or provenance. These contracts consist of 10 to 18 rules
(column #Rules in Table 1).

Although DeCon can specify all the high-level logic of the these
contracts, we note that the generated Solidity code has the following
difference from the reference implementations. First, the reference
CrowdSale contract is implemented as two separate contracts. As
DeCon does not yet support contract composition, the compiler
outputs a stand-alone smart contract with all the functionalities.
For the ERC721 contract, there is a safeTransferFrom interface, which
wraps the transferFrom function with a check: if the recipient is also
a smart contract, it should implement the onERC721Received interface.
The current implementation of DeCon does not yet support such
checking procedure, which relies on calling the built-in functions
of Solidity, so this interface is omitted.

1According to https://etherscan.io, at the time of writing this paper, there are about
502,000 ERC20 tokens and 50,000 ERC721 tokens on Ethereum.

Measurement metrics. We measure two metrics: (1) the size of
EVM byte-code deployed on the blockchain; and (2) the gas cost for
each transaction. EVM byte-code is generated by the Truffle [10]
compiler. To measure gas cost, we first deploy the smart contract
on Truffle‚Äôs local blockchain, and then populate the smart contract
states by sending transactions from ùëÅ test accounts, which results
in ùëÅ entries in the contract states. Then we call each transaction
interface again and record gas cost reported by Truffle. We find that
ùëÅ (10 to 1000) does not impact gas cost. This is because all contracts
use hash-maps to store contract states. If the hash-collision rate
is low, the number of instructions is constant to the size of the
hash-map, and thus the gas cost remains constant. Therefore, we
report the gas cost measured with ùëÅ = 10.
Results. As shown in Table 1, the median gas overhead to reference
implementation is 14% across 16 transactions, with 3 of them have
even lower gas cost between ‚àí28% to ‚àí12%. In the extreme case, the
withdraw transaction from SimpleAuction shows 101% gas overhead.

We identify two sources of extra gas cost: (1) long function invo-
cation chain, and (2) inefficient use of data structures. For example,
in the Wallet example (Section 2), mint transaction updates the
variable totalMint, which further updates totalSupply, thus adding
extra cost than directly incrementing totalSupply as done by the
reference implementation. For data structures, relational tables are
directly maintained as arrays of tuples, with extra information like
valid bits and timestamps. Such extra information takes up addi-
tional space than their counterparts in Solidity implementations.
Mitigating such overhead borrowing ideas in SQL execution plan
optimization would be an interesting direction for future research.
DeCon consumes less gas in some transactions. In Wallet, the
DeCon contract has less read / write to the global memory. In Crow-
funding, the reference contract invokes an external call to another
contract, whereas DeCon implements everything in one monolithic
contract, thus eliminating the inter-contract transaction cost. In
ERC721, DeCon has fewer condition checks because some condi-
tions are specified as rules and therefore automatically maintained
by the contract.

In terms of byte-code size, DeCon‚Äôs compiler output is slightly
greater than the reference programs, with a 2KB (SimpleAuction) max-
imum increase. Note that on CrowSale, DeCon‚Äôs output is smaller
than the reference contract. This is because the reference imple-
ments two separate contracts, while the program generated by
DeCon compiler has all functions implemented in one contract.

Contract features that are not yet supported. During the search
of benchmarks, we find some contracts use features that are not yet
supported by DeCon. For example, the voting contract from Solid-
ity documentation [11] checks voting loop in a recursive manner.
Although recursion can be naturally expressed in DeCon language,
the execution of recursion functions requires non-trivial reasoning
to ensure termination and gas efficiency, and is therefore not yet
supported by DeCon. In addition, certain functions that lie outside
of relational logic, including checking interfaces of another contract
(e.g. safeTransferFrom in ERC721), and cryptographic functions[5],
are not yet supported, but they can be incorporated into DeCon via
user-defined functions in the future.

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

Haoxian Chen, Gerald Whitters, Mohammad Javad Amiri, Yuepeng Wang, and Boon Thau Loo

Contract

LOC # Functions

# Rules

Byte-code size (KB)
Reference DeCon

Transaction

Wallet

57

Crowdsale

70

SimpleAuction

139

ERC721

ERC20

447

383

6

5

3

9

6

12

11

13

13

18

3

4

2

10

5

3

3

4

11

6

mint
burn
transfer
invest
close
withdraw
claimRefund
bid
withdraw
auctionEnd
transferFrom
approve
setApprovalForAll
transfer
approve
transferFrom

Gas cost (K)

Reference Compiled Diff
70%
62
36
29%
47
36
-26%
38
52
-12%
33
38
25%
47
38
14%
29
26
13%
33
29
66%
115
69
101%
47
24
4%
56
54
-28%
42
59
53%
75
49
2%
27
27
6%
55
52
7%
50
47
15%
50
43
14%
median:

Table 1: Overhead of Solidity programs generated by DeCon, compared to reference implementations. Column #ùëÖùë¢ùëôùëíùë† shows
the number of rules in the declarative smart contracts.

Contract

Property

Wallet

No negative
balance

Crowdsale

No missing
funds

Simple
Auction

ERC721

ERC20

Refund once

Every token
has owner

Account
balances add up
to total supply

2

2

Size Transaction
mint
burn
transfer
invest
close
withdraw
claimRefund
bid
withdraw
auctionEnd
transferFrom
approve
setApprovalForAll
transfer
approve
transferFrom
median:

2

1

1

Gas
14%
14%
17%
50%
24%
22%
33%
2%
60%
4%
5%
3%
8%
96%
13%
109%
16%

Table 2: Run-time verification overhead. Column ùëÜùëñùëßùëí and
ùê∫ùëéùë† show the overhead in byte-code size (KB) and gas cost
(K) respectively, compared to the DeCon contract without
instrumentation.

6.2 Run-time Verification Overhead
We measure run-time verification overhead by first specifying prop-
erties for each contract, which are generated as instrumentation
in the output Solidity program. These instrumented programs are
then compared to DeCon programs without instrumentation, on
byte-code size and gas usage.

Contract properties are specified as follows. First, as shown in the
example in Section 2, the Wallet contract is monitored for negative
account balances. The Crowdsale contract allows participants to

invest in a crowd funding project with a particular funding target.
The property specifies that the total amount of raised fund should
equal to all participants‚Äô investments. In simple auction, bidders
transfer their fund on every bid, and get refunds when the auction
is ended. A property specifies that every bidder can claim refund
at most once. In ERC721, the property specifies that all existing
tokens should have a valid owner (non-zero address). In ERC20, all
account balances should add up to the total supply of tokens.
Results. Table 2 shows the overhead of run-time verification. Byte-
code sizes are increased by no more than 2 KB. Gas usage overhead
varies across different transactions, with the median being 16%.
Wallet and ERC721 contracts show small overhead, where trans-
action gas consumption increases by no more than 17% and 8%,
respectively. Crowdsale and Simple Auction contract come with
larger overhead. The highest increase in their transaction gas usage
are 50% and 60%. The ERC20 contract shows the biggest overhead,
where the transferFrom transaction shows 109% increase.

7 RELATED WORK
In this section, we survey several lines of research that are related
to our work.

Run-time verification. Similar to DeCon, Solythesis [43] also
specifies properties as invariants and generates instrumentation
for run-time monitoring. It applies to general smart contracts im-
plemented in Solidity, whereas DeCon targets declarative contracts
only. By restricting the scope on declarative contracts, both spec-
ification and monitoring can be performed in a more straightfor-
ward manner. Invariants become violation queries, where joins are
analogous to existential quantifiers, and aggregations to universal
quantifiers. Detection becomes query evaluation, which reuses the
same procedure for contract execution.

SODA [26] is a framework for implementing generic attack de-
tection algorithms. Unlike DeCon, where the monitoring procedure

Declarative Smart Contracts

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

is automatically generated from specification, the detection algo-
rithms in SODA are implemented manually.

(Section 4.3), which is essential since smart contracts are managing
a lot of digital assets.

Sereum [53] monitors reentrancy attacks online via taint analysis.
Azzopardi et al. [19] monitors contract execution against legal
contract logic. These two work targets specific vulnerabilities and
properties on Solidity smart contracts, whereas DeCon monitors
user-specified properties on declarative contracts.

Static analysis and verification. Static analysis has been applied
to detect generic vulnerabilities such as reentrancy attacks [32, 44],
integer bugs [59, 61], trace vulnerability [48], and event-ordering
bugs [41]. Securify [62] translates the EVM byte-code into strati-
fied Datalog, and checks vulnerability patterns using off-the-shelf
Datalog solvers.

Alt et al. [17] translates Solidity program into SMT formulas and
use off-the-shelf SMT solver to verify contract properties. Zeus [40]
leverages abstract interpretations and symbolic model checking to
verify correctness and fairness of smart contracts.

Symbolic execution [15, 16, 25, 42, 45, 47, 51, 62] is another pop-
ular technique for smart contract verification. Oyente [45] detects
generic predefined vulnerabilities including reentrancy, transac-
tion order dependency, mishandled exceptions, etc. Verx [51], on
the other hand, allows programmers to specify contract-specific
properties in temporal logic.

Fuzzing has also been applied to smart contracts. For example,
ContractFuzzer [37] tests smart contracts for security vulnerabili-
ties. Echidna [30] generates tests that triggers assertion violations.
ILF [35] and Harvey [64] focus on improving code coverage.

Unlike these work, DeCon monitors properties online, which
incurs run-time overhead, but does not suffer from false-positives
or false-negatives. In addition, DeCon targets declarative smart
contracts, while these tools analyze Solidity or EVM byte-code.
Although targeting different languages, the underlying verification
techniques can also be applied to DeCon and benefit from its higher-
level abstraction. We believe this is an exciting direction for future
research.

Domain-specific languages for financial contracts. Scilla [56]
is a intermediate-level language for smart contracts that offers type
safety and support for verification. KEVM [36] defines the formal
semantics of EVM, and has been used to verify contracts against
ERC20 standards. In contrast, DeCon focuses on the high level
abstraction of smart contracts and specification of contract-specific
properties. Jones et al. [38] uses functional programming language
to write financial contracts. BitML [20] is a high-level language
for Bitcoin smart contracts. Based on process calculus, it translates
contracts into Bitcoin transactions. DeCon, on the other hand, is
based on relational logic and targets Ethereum smart contracts.

Datalog languages. DeCon shares similar syntax with general
Datalog languages like Souffle [39], and is inspired by incremental
evaluation techniques in systems like DDlog [54]. DeCon however
is specific to Ethereum smart contracts in the following aspects.
First, DeCon has a number of domain-specific language extensions
necessary for capturing execution semantics in Smart Contracts
(Section 3). Second, DeCon compiles Datalog to Solidity, with sev-
eral domain-specific optimizations (Section 4.5). Finally, DeCon
offers a property specification and run-time monitoring feature

Deontic logic for normative knowledge. Gabbay et al. [29] presents
a historical overview of deontic logic for normative knowledge.
Based on similar principles, Prakken et al. [52] overviews logic-
based approaches for legal applications. DeCon is a logical system
representing knowledge in the domain of smart contracts, which
enables efficient communication and automatic reasoning.

8 CONCLUSION AND FUTURE WORK
We present DeCon, a declarative programming language for smart
contract implementation and property specification. In DeCon,
smart contracts are specified in a high-level and executable manner,
thus providing opportunities for efficient analysis and verification,
bringing clarity to transaction execution via data provenance. Con-
tracts implemented in DeCon demonstrate comparable efficiency
to open-source reference implementation. Furthermore, run-time
verification adds moderate gas overhead.

Our initial experience with DeCon suggests a few exciting future
directions. First, we find interesting contracts that require addi-
tional language features, including contract composition, recursion,
user-defined functions, etc. Second, there are extreme cases where
DeCon compiler generates contracts with non-negligible overhead
to the reference hand-written code. DeCon compiler needs further
optimization to generate more efficient executable code. Third, to
save the overhead of run-time verification, we can leverage the
high-level abstraction of DeCon programs to perform static verifi-
cation.

REFERENCES
[1] Declarative smart contract benchmarks. https://github.com/HaoxianChen/

declarative-smart-contracts/tree/master/benchmarks.

[2] Declarative smart contracts. https://github.com/HaoxianChen/declarative-smart-

contracts.

[3] Openzeppelin contracts.

https://github.com/OpenZeppelin/openzeppelin-

contracts/tree/master/contracts/token.

[4] Recursions in solidity. https://docs.soliditylang.org/en/v0.8.13/control-structures.

html?highlight=recursion.

[5] Safe remote purchase.

https://docs.soliditylang.org/en/v0.5.3/solidity-by-

example.html#safe-remote-purchase.

[6] Simple auction.

https://docs.soliditylang.org/en/v0.5.3/solidity-by-example.

html#simple-open-auction.

[7] Smtchecker and formal verification. https://docs.soliditylang.org/en/v0.8.12/

smtchecker.html#assert.

[8] Solidity. https://docs.soliditylang.org.
[9] Solidity events. https://docs.soliditylang.org/en/v0.8.13/abi-spec.html?highlight=

events#events.

[10] Truffle. https://trufflesuite.com.
[11] Voting. https://docs.soliditylang.org/en/v0.5.3/solidity-by-example.html#voting.
[12] The dao. https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413,

2016.

[13] King of the ether throne ‚Äî post-mortem investigation.

https://www.

kingoftheether.com/postmortem.html, 2016.

[14] Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases: The

Logical Level. Pearson, 1st edition, 1994.

[15] Elvira Albert, Jes√∫s Correas, Pablo Gordillo, Guillermo Rom√°n-D√≠ez, and Albert
Rubio. Safevm: a safety verifier for ethereum smart contracts. In ACM SIGSOFT
Int. Symposium on Software Testing and Analysis (ISSTA), pages 386‚Äì389, 2019.

[16] Elvira Albert, Pablo Gordillo, Benjamin Livshits, Albert Rubio, and Ilya Sergey.
Ethir: A framework for high-level analysis of ethereum bytecode. In Int. sympo-
sium on automated technology for verification and analysis (ATVA), pages 513‚Äì520.
Springer, 2018.

[17] Leonardo Alt and Christian Reitwiessner. Smt-based verification of solidity smart
contracts. In Int. Symposium on Leveraging Applications of Formal Methods, pages
376‚Äì388. Springer, 2018.

ESEC/FSE ‚Äô22, November 14‚Äì18, 2022, Singapore, Singapore

Haoxian Chen, Gerald Whitters, Mohammad Javad Amiri, Yuepeng Wang, and Boon Thau Loo

[18] Asaph Azaria, Ariel Ekblaw, Thiago Vieira, and Andrew Lippman. Medrec: Using
blockchain for medical data access and permission management. In Int. Conf. on
Open and Big Data (OBD), pages 25‚Äì30. IEEE, 2016.

[19] Shaun Azzopardi, Gordon J Pace, and Fernando Schapachnik. On observing
In Legal Knowledge and

contracts: deontic contracts meet smart contracts.
Information Systems. IOS Press, 2018.

[20] Massimo Bartoletti and Roberto Zunino. Bitml: a calculus for bitcoin smart
contracts. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security, 2018.

[21] Aaron Bembenek, Michael Greenberg, and Stephen Chong. Formulog: Datalog
for smt-based static analysis. Proceedings of the ACM on Programming Languages,
4(OOPSLA):1‚Äì31, 2020.

[22] Alex Biryukov, Dmitry Khovratovich, and Sergei Tikhomirov. Findel: Secure
derivative contracts for ethereum. In International Conference on Financial Cryp-
tography and Data Security, pages 453‚Äì467. Springer, 2017.

[23] Ryan Browne. ‚Äôaccidental‚Äô bug may have frozen $ 280 million worth of digital coin
ether in a cryptocurrency wallet. https://www.cnbc.com/2017/11/08/accidental-
bug-may-have-frozen-280-worth-of-ether-on-parity-wallet.html, 2017.
[24] Peter Buneman, Sanjeev Khanna, and Tan Wang-Chiew. Why and where: A
In International conference on database

characterization of data provenance.
theory. Springer, 2001.

[25] Jialiang Chang, Bo Gao, Hao Xiao, Jun Sun, Yan Cai, and Zijiang Yang. scompile:
In Int. Conf. on

Critical path identification and analysis for smart contracts.
Formal Engineering Methods, pages 286‚Äì304. Springer, 2019.

[26] Ting Chen, Rong Cao, Ting Li, Xiapu Luo, Guofei Gu, Yufei Zhang, Zhou Liao,
Hang Zhu, Gang Chen, Zheyuan He, et al. Soda: A generic online detection
framework for smart contracts. In NDSS, 2020.

[27] William Entriken, Dieter Shirley, Jacob Evans, and Nastassia Sachs. Eip-721:

Non-fungible token standard. https://eips.ethereum.org/EIPS/eip-721.

[28] Vitalik Buterin Fabian Vogelsteller. Eip-20: Token standard. https://eips.ethereum.

org/EIPS/eip-20.

[29] Dov Gabbay, Jeff Horty, Xavier Parent, Ron van der Meyden, and Leon van der

Torre. Handbook of deontic logic and normative systems. 2013.

[30] Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce. Echidna:
effective, usable, and fast fuzzing for smart contracts. In Proceedings of the 29th
ACM SIGSOFT Int. Symposium on Software Testing and Analysis, pages 557‚Äì560,
2020.

[31] Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. Foundations and tools
for the static analysis of ethereum smart contracts. In Int. Conf. on Computer
Aided Verification, pages 51‚Äì78. Springer, 2018.

[32] Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, Noam
Rinetzky, Mooly Sagiv, and Yoni Zohar. Online detection of effectively callback
free objects with applications to smart contracts. Proceedings of the ACM on
Programming Languages, 2(POPL):1‚Äì28, 2017.

[33] Ashish Gupta, Inderpal Singh Mumick, and Venkatramanan Siva Subrahmanian.

Maintaining views incrementally. ACM SIGMOD Record, 1993.

[34] Adam Hahn, Rajveer Singh, Chen-Ching Liu, and Sijie Chen. Smart contract-
based campus demonstration of decentralized transactive energy auctions. In
2017 IEEE Power & energy society innovative smart grid technologies conference
(ISGT), pages 1‚Äì5. IEEE, 2017.

[35] Jingxuan He, Mislav Balunoviƒá, Nodar Ambroladze, Petar Tsankov, and Martin
Vechev. Learning to fuzz from symbolic execution with application to smart
contracts. In Proceedings of the 2019 ACM SIGSAC Conf. on Computer and Com-
munications Security, pages 531‚Äì548, 2019.

[36] Everett Hildenbrandt, Manasvi Saxena, Nishant Rodrigues, Xiaoran Zhu, Philip
Daian, Dwight Guth, Brandon Moore, Daejun Park, Yi Zhang, Andrei Stefanescu,
and Grigore Rosu. Kevm: A complete formal semantics of the ethereum virtual
machine. In 2018 IEEE 31st Computer Security Foundations Symposium (CSF), 2018.
[37] Bo Jiang, Ye Liu, and WK Chan. Contractfuzzer: Fuzzing smart contracts for
vulnerability detection. In 2018 33rd IEEE/ACM Int. Conf. on Automated Software
Engineering (ASE), pages 259‚Äì269. IEEE, 2018.

[38] SL Peyton Jones and Jean-Marc Eber. How to write a financial contract. 2003.
[39] Herbert Jordan, Bernhard Scholz, and Pavle Subotiƒá. Souffl√©: On synthesis of
program analyzers. In International Conference on Computer Aided Verification,
pages 422‚Äì430. Springer, 2016.

[40] Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. Zeus: analyzing

safety of smart contracts. In Ndss, pages 1‚Äì12, 2018.

[41] Aashish Kolluri, Ivica Nikolic, Ilya Sergey, Aquinas Hobor, and Prateek Saxena.
Exploiting the laws of order in smart contracts. In ACM SIGSOFT Int. symposium

on software testing and analysis (ISSTA), pages 363‚Äì373, 2019.

[42] Johannes Krupp and Christian Rossow. {teEther}: Gnawing at ethereum to
automatically exploit smart contracts. In USENIX Security Symposium, pages
1317‚Äì1333. USENIX, 2018.

[43] Ao Li, Jemin Andrew Choi, and Fan Long. Securing smart contract with runtime
validation. In Proceedings of the 41st ACM SIGPLAN Conference on Programming
Language Design and Implementation, 2020.

[44] Chao Liu, Han Liu, Zhao Cao, Zhong Chen, Bangdao Chen, and Bill Roscoe.
Reguard: finding reentrancy bugs in smart contracts. In Int. Conf. on Software
Engineering: Companion (ICSE-Companion), pages 65‚Äì68. IEEE, 2018.

[45] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.
Making smart contracts smarter. In ACM SIGSAC Conf. on computer and commu-
nications security (CCS), pages 254‚Äì269, 2016.

[46] Patrick McCorry, Siamak F Shahandashti, and Feng Hao. A smart contract for
boardroom voting with maximum voter privacy. In International conference on
financial cryptography and data security, pages 357‚Äì375. Springer, 2017.
[47] Mark Mossberg, Felipe Manzano, Eric Hennenfent, Alex Groce, Gustavo Grieco,
Josselin Feist, Trent Brunson, and Artem Dinaburg. Manticore: A user-friendly
symbolic execution framework for binaries and smart contracts. In 2019 34th
IEEE/ACM Int. Conf. on Automated Software Engineering (ASE), pages 1186‚Äì1189.
IEEE, 2019.

[48] Ivica Nikoliƒá, Aashish Kolluri, Ilya Sergey, Prateek Saxena, and Aquinas Hobor.
Finding the greedy, prodigal, and suicidal contracts at scale. In computer security
applications Conf., pages 653‚Äì663, 2018.

[49] Benedikt Notheisen, Magnus G√∂dde, and Christof Weinhardt. Trading stocks on
blocks-engineering decentralized markets. In International Conference on Design
Science Research in Information System and Technology, pages 474‚Äì478. Springer,
2017.

[50] Zhiniang Peng. Not a fair game ‚Äì fairness analysis of dice2win. https://blogs.

360.net/post/Fairness_Analysis_of_Dice2win_EN.html, 2018.

[51] Anton Permenev, Dimitar Dimitrov, Petar Tsankov, Dana Drachsler-Cohen, and
Martin Vechev. Verx: Safety verification of smart contracts. In symposium on
security and privacy (SP), pages 1661‚Äì1677. IEEE, 2020.

[52] Henry Prakken and Giovanni Sartor. Law and logic: A review from an argumen-

tation perspective. Artificial intelligence, 2015.

[53] Michael Rodler, Wenting Li, Ghassan O Karame, and Lucas Davi. Sereum: Pro-
tecting existing smart contracts against re-entrancy attacks. In Network and
Distributed Systems Security (NDSS), 2019.

[54] Leonid Ryzhyk and Mihai Budiu. Differential datalog. Datalog, 2019.
[55] Clara Schneidewind, Ilya Grishchenko, Markus Scherer, and Matteo Maffei. ethor:
Practical and provably sound static analysis of ethereum smart contracts. In ACM
SIGSAC Conf. on Computer and Communications Security (CCS), pages 621‚Äì640,
2020.

[56] Ilya Sergey, Vaivaswatha Nagaraj, Jacob Johannsen, Amrit Kumar, Anton Trunov,
and Ken Chan Guan Hao. Safer smart contract programming with scilla. Pro-
ceedings of the ACM on Programming Languages, (OOPSLA), 2019.

[57] David Siegel. Understanding the dao attack. 2016.
[58] Yannis Smaragdakis and Martin Bravenboer. Using datalog for fast and easy
program analysis. In International Datalog 2.0 Workshop, pages 245‚Äì251. Springer,
2010.

[59] Sunbeom So, Myungho Lee, Jisu Park, Heejo Lee, and Hakjoo Oh. Verismart: A
highly precise safety verifier for ethereum smart contracts. In Symposium on
Security and Privacy (SP), pages 1678‚Äì1694. IEEE, 2020.

[60] Parity Technologies. Parity security alert. 2017.
[61] Christof Ferreira Torres, Julian Sch√ºtte, and Radu State. Osiris: Hunting for
In Proceedings of the 34th Annual

integer bugs in ethereum smart contracts.
Computer Security Applications Conf., pages 664‚Äì676, 2018.

[62] Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian
Buenzli, and Martin Vechev. Securify: Practical security analysis of smart con-
tracts. In ACM SIGSAC Conf. on Computer and Communications Security (CCS),
pages 67‚Äì82, 2018.

[63] John Whaley, Dzintars Avots, Michael Carbin, and Monica S Lam. Using datalog
with binary decision diagrams for program analysis. In Asian Symposium on
Programming Languages and Systems, pages 97‚Äì118. Springer, 2005.

[64] Valentin W√ºstholz and Maria Christakis. Harvey: A greybox fuzzer for smart
contracts. In ACM Joint Meeting on European Software Engineering Conf. and
Symposium on the Foundations of Software Engineering (ESE/SFSE), pages 1398‚Äì
1409, 2020.

