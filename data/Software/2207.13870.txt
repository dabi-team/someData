2
2
0
2

l
u
J

8
2

]
S
D
.
s
c
[

1
v
0
7
8
3
1
.
7
0
2
2
:
v
i
X
r
a

Engineering faster double-array Ahoâ€“Corasick automata

Shunsuke Kanda1, Koichi Akabe1, and Yusuke Oda1,2

1LegalForce Research, Japan
2Center for Data-driven Science and Artiï¬cial Intelligence, Tohoku University, Japan

Abstract

Multiple pattern matching in strings is a fundamental problem in text processing applications such as regular ex-
pressions or tokenization. This paper studies eï¬ƒcient implementations of double-array Ahoâ€“Corasick automata
(DAACs), data structures for quickly performing the multiple pattern matching. The practical performance of DAACs
is improved by carefully designing the data structure, and many implementation techniques have been proposed thus
far. A problem in DAACs is that their ideas are not aggregated. Since comprehensive descriptions and experimental
analyses are unavailable, engineers face diï¬ƒculties in implementing an eï¬ƒcient DAAC.

In this paper, we review implementation techniques for DAACs and provide a comprehensive description of
them. We also propose several new techniques for further improvement. We conduct exhaustive experiments through
real-world datasets and reveal the best combination of techniques to achieve a higher performance in DAACs. The
best combination is diï¬€erent from those used in the most popular libraries of DAACs, which demonstrates that their
performance can be further enhanced. On the basis of our experimental analysis, we developed a new Rust library
for fast multiple pattern matching using DAACs, named Daachorse, as open-source software at https://github.com/
daac-tools/daachorse. Experiments demonstrate that Daachorse outperforms other AC-automaton implementations,
indicating its suitability as a fast alternative for multiple pattern matching in many applications.

1 Introduction

Multiple pattern matching in strings is a fundamental problem in text and natural language processing [33]. Given a
set of patterns and a text, the goal of this problem is to report all occurrences of patterns in the text. A representative
application is regular expressions, which provide a powerful way to express a set of search patterns. Another is
tokenization in unsegmented natural languages such as Japanese and Chinese, which partitions a sentence into shorter
units called tokens or words. Multiple pattern matching is essential in these applications, and its time eï¬ƒciency is
crucial.

The Ahoâ€“Corasick (AC) algorithm [1] is a fast solution for multiple pattern matching. It uses an AC automaton and
performs the matching with ğ‘‚ (ğ‘›) character comparisons, where ğ‘› is the length of an input text. Despite the theoretical
guarantee, the practical performance of the AC algorithm is signiï¬cantly aï¬€ected by its internal data structure used
to represent the AC automaton [35]. Thus, carefully designing the internal data structure is vital to achieve faster
matching.

Double-array AC automata (DAACs) are AC-automaton representations for fast matching. The core component
is the double-array [2], a data structure to implement transition lookups in an optimal time. Prior experiments
[35] demonstrated that DAACs performed the fastest compared to various other representations. Thanks to their
time eï¬ƒciency, double-array structures are used in a wide range of applications such as dictionary lookups [28, 46],
compressed string dictionaries [26], tokenization [27, 43], language models [36, 44], classiï¬cation [52], and search
engines [9].

To achieve a higher performance in DAACs, it is essential to carefully design the data structure with regard to the
target applications and data characteristics. In the three decades since the original idea of the double-array was proposed
by Aoe [2], many implementation techniques have been developed from diï¬€erent points of view, such as scalability

1

 
 
 
 
 
 
[18, 25, 26], cache eï¬ƒciency [24, 49], construction speed [32, 37, 47], and specializations [36, 44, 47]. In addition
to these academic studies, many open-source libraries have been developed, e.g., [20, 28, 40, 46], which sometimes
contain original techniques. The problem is that their ideas are not aggregated. Speciï¬cally, the comprehensive
descriptions and experimental analyses are unavailable, which makes it diï¬ƒcult for engineers to implement an eï¬ƒcient
DAAC.

Our contributions
In this paper, we review various implementation techniques in DAACs and provide a compre-
hensive description of them, including categorization for facilitating comparison (as summarized in Table 2). We also
propose several new techniques for further improvement. We provide an exhaustive experimental analysis through
real-world datasets and reveal the best combination of implementation techniques. The best combination is diï¬€erent
from those used in the most popular libraries of DAACs [20, 40], demonstrating that their performance can be further
enhanced.

On the basis of our experimental analysis, we develop a new Rust library for fast multiple pattern matching using
DAACs, named Daachorse, as open-source software at https://github.com/daac-tools/daachorse under the Apache-2.0
or MIT license. Our experiments demonstrate that Daachorse outperforms other AC-automaton implementations,
indicating its suitability as a fast alternative for multiple pattern matching in many applications. Daachorse has been
plugged into Vaporetto [10], a Japanese tokenizer written in Rust. Vaporetto is a fast implementation of the pointwise
prediction method [34, 41, 42] that determines token boundaries using a discriminative model. The core step of
this method is feature extraction performed with the AC algorithm. Its running time signiï¬cantly aï¬€ects the entire
processing time, and the fast pattern matching provided by Daachorse assures the time eï¬ƒciency of Vaporetto. For
example, Daachorse performs tokenization 2.6Ã— faster than other implementations, as demonstrated in this paper.

2 Preliminaries

2.1 Basic deï¬nition and notation

A string is a ï¬nite sequence of characters over a ï¬nite integer alphabet Î£ = {0, 1, . . . , |Î£| âˆ’ 1}. Our strings always start
at position zero. The empty string ğœ€ is a string of length zero. Given a string ğ‘ƒ of length ğ‘› â‰¥ 1, ğ‘ƒ[ğ‘–.. ğ‘—) denotes the
substring ğ‘ƒ[ğ‘–], ğ‘ƒ[ğ‘– + 1], . . . , ğ‘ƒ[ ğ‘— âˆ’ 1] for 0 â‰¤ ğ‘– â‰¤ ğ‘— â‰¤ ğ‘›. Specially, ğ‘ƒ[0..ğ‘–) is a preï¬x of ğ‘ƒ, and ğ‘ƒ[ğ‘–..ğ‘›) is a suï¬ƒx of ğ‘ƒ
for 0 â‰¤ ğ‘– â‰¤ ğ‘›. Let |ğ‘ƒ| := ğ‘› denote the length of ğ‘ƒ. The same notation is applied to arrays. We denote the cardinality
of a set ğ´ by | ğ´|.

2.2 Multiple pattern matching
Given a set of strings D = {ğ‘ƒ1, ğ‘ƒ2, . . . , ğ‘ƒ | D | } and a string ğ‘‡, the goal of multiple pattern matching is to report all
occurrences {(ğ‘˜, ğ‘–, ğ‘—) : ğ‘ƒğ‘˜ âˆˆ D, ğ‘ƒğ‘˜ = ğ‘‡ [ğ‘–.. ğ‘—)}, where an occurrence (ğ‘˜, ğ‘–, ğ‘—) consists of the index ğ‘˜ of the matched
pattern ğ‘ƒğ‘˜ and the starting and ending positions ğ‘–, ğ‘— appearing in ğ‘‡. Throughout this paper, we refer to D as a
dictionary, ğ‘ƒğ‘˜ as a pattern, and ğ‘‡ as a text.

Table 1 shows an example of a dictionary D consisting of six patterns. In all examples throughout this paper, we
denote indices of patterns by upper-case letters instead of numbers and integer elements in Î£ by lower-case letters.
Given the dictionary and text ğ‘‡ [0..6) = abacdd, the occurrences are (A, 0, 2), (B, 1, 2), (D, 1, 4), and (F, 4, 6).

2.3 Ahoâ€“Corasick algorithm

The AC automaton [1] is a ï¬nite state machine to ï¬nd all occurrences of patterns in a single scan of a text. The AC
automaton for a dictionary D is deï¬ned as the 5-tuple (ğ‘†, Î£, ğ›¿, ğ‘“ , â„):

â€¢ ğ‘† = {0, 1, . . . , |ğ‘†| âˆ’ 1} is a ï¬nite set of states, where each state is identiï¬ed by an integer, and the initial state is

indicated by 0;

â€¢ Î£ = {0, 1, . . . , |Î£| âˆ’ 1} is the alphabet;

2

Table 1: A dictionary D of six patterns (used in examples throughout this paper). Patterns are indexed with upper-case
letters A, B, C, . . . instead of numbers in the examples. Elements in the integer alphabet Î£ are denoted with lower-case
letters. Î£ = {a = 0, b = 1, c = 2, d = 3}.

Index
A
B
C
D
E
F

Pattern
ab
b
bab
bac
db
dd

(a) AC automaton

(b) Trie

Figure 1: Examples of (a) an AC automaton for the dictionary of Table 1 and (b) its trie part. Transitions are depicted
by solid line arrows. ğ›¿(0, b) = 2, ğ›¿(2, a) = 5, and ğ›¿(2, c) = âˆ’1. We depict the mappings of the failure function (except
ğ‘“ (4) = 2, ğ‘“ (5) = 1, ğ‘“ (6) = 2, ğ‘“ (7) = 3, ğ‘“ (8) = 4, and ğ‘“ (ğ‘ ) = 0 for
ones to the initial state) by dotted line arrows.
the other states ğ‘ . Output states are shaded and associated with pattern indices (drawn from A, B, C, . . . ). â„(2) = {B},
â„(4) = {A,B}, â„(6) = {E,B}, â„(7) = {F}, â„(8) = {C,A,B}, â„(9) = {D}, and â„(ğ‘ ) = âˆ… for the other states ğ‘ .

â€¢ ğ›¿ : ğ‘† Ã— Î£ â†’ ğ‘† âˆª {âˆ’1} is a transition function, where âˆ’1 is an invalid state id;

â€¢ ğ‘“ : ğ‘† \ {0} â†’ ğ‘† is a failure function; and

â€¢ â„ : ğ‘† â†’ P ({1, 2, . . . , |D|}) is an output function, where P (Â·) is the power set.

Figure 1a shows an example of the AC automaton.

The transition function ğ›¿ is built on a trie for the dictionary D. The trie [16] is a tree automaton formed by merging
the preï¬xes of patterns in D. Figure 1b shows the trie in the AC automaton. A state ğ‘  in the trie represents any preï¬x
of patterns in D, and the preï¬x can be extracted by concatenating transition labels from the initial state to state ğ‘ . We
denote by ğœ™(ğ‘ ) the string represented by state ğ‘ . For example, ğœ™(4) = ab and ğœ™(5) = ba in Figure 1b. The initial
state always represents the empty string ğœ€, i.e., ğœ™(0) = ğœ€. We call states satisfying ğœ™(ğ‘ ) âˆˆ D output states. If a state
ğ‘  does not indicate any other state with character ğ‘, ğ›¿(ğ‘ , ğ‘) = âˆ’1 is deï¬ned using the invalid state id âˆ’1. There is one
diï¬€erence in the deï¬nition of ğ›¿ between the AC automaton and trie: the AC automaton redeï¬nes special transitions
ğ›¿(0, ğ‘) := 0 for labels ğ‘ such that ğ›¿(0, ğ‘) = âˆ’1 in the trie.

The failure function ğ‘“ maps a state ğ‘  âˆˆ (ğ‘† \ {0}) to another state ğ‘¡ âˆˆ (ğ‘† \ {ğ‘ }) such that ğœ™(ğ‘¡) is a longer suï¬ƒx
of ğœ™(ğ‘ ) than ğœ™(ğ‘¡ (cid:48)) for ğ‘¡ (cid:48) âˆˆ (ğ‘† \ {ğ‘ , ğ‘¡}). Note that, since the empty string ğœ€ is a suï¬ƒx of any string, the initial state is
always one of the candidates. Let ğ¹ (ğ‘ ) be a set of output states reached through only the failure function from state
ğ‘ . For example, ğ¹ (8) = {8, 4, 2} in Figure 1a. The output function â„(ğ‘ ) is the set of pattern indices associated with
output states in ğ¹ (ğ‘ ), i.e., â„(ğ‘ ) = {ğ‘˜ : ğ‘ƒğ‘˜ âˆˆ D, ğ‘ƒğ‘˜ = ğœ™(ğ‘¡), ğ‘¡ âˆˆ ğ¹ (ğ‘ )}.

3

Algorithm 1: Multiple pattern matching using AC automaton.

: Text ğ‘‡ of length ğ‘›

Input
Output : All occurrences of patterns {(ğ‘˜, ğ‘–, ğ‘—) : ğ‘ƒğ‘˜ âˆˆ D, ğ‘ƒğ‘˜ = ğ‘‡ [ğ‘–.. ğ‘—)}

1 ğ‘  â† 0
2 for ğ‘— = 0, 1, . . . , ğ‘› âˆ’ 1 do
for ğ‘˜ âˆˆ â„(ğ‘ ) do
3
ğ‘– â† ğ‘— âˆ’ |ğ‘ƒğ‘˜ |
Output an occurrence (ğ‘˜, ğ‘–, ğ‘—)

5

4

ğ‘  â† ğ›¿âˆ— (ğ‘ , ğ‘‡ [ ğ‘—])

6
7 for ğ‘˜ âˆˆ â„(ğ‘ ) do
8

ğ‘– â† ğ‘› âˆ’ |ğ‘ƒğ‘˜ |
Output an occurrence (ğ‘˜, ğ‘–, ğ‘›)

9

Figure 2: BASE and CHECK implementing the transition function ğ›¿ of Figure 1b. Î£ = {a = 0, b = 1, c = 2, d = 3}.
The state ids are assigned to satisfy Equation (2). ğ›¿(0, b) = 2 is simulated by BASE[0] + b = 2 and CHECK[2] = 0.
ğ›¿(2, d) = âˆ’1 is simulated by BASE[2] + d = 8 and CHECK[8] â‰  2. The state id 7 is a vacant id because its element
does not represent any state of the original trie.

Matching algorithm Algorithm 1 shows the AC algorithm that performs multiple pattern matching using the AC
automaton. The algorithm uses the extended transition function ğ›¿âˆ—:

ğ›¿âˆ—(ğ‘ , ğ‘) =

(cid:40)ğ›¿(ğ‘ , ğ‘)
ğ›¿âˆ— ( ğ‘“ (ğ‘ ), ğ‘)

if ğ›¿(ğ‘ , ğ‘) â‰  âˆ’1
otherwise.

(1)

Given a text ğ‘‡, the AC algorithm scans ğ‘‡ character by character, visits states from the initial state ğ‘  = 0 with ğ›¿âˆ—,
and reports occurrences where patterns in â„(ğ‘ ) are associated with each visited state ğ‘ . For example, assume we are
scanning text ğ‘‡ [0..6) = abacdd with the AC automaton in Figure 1a. We ï¬rst move with ab from state 0 to state 4 by
ğ›¿âˆ— (0, a) = 1 and ğ›¿âˆ— (1, b) = 4, and then report two occurrences, (A, 0, 2) and (B, 1, 2), associated with â„(4). Next, we
move to state 9 by ğ›¿âˆ— (4, a) = 5 and ğ›¿âˆ— (5, c) = 9 and report occurrence (D, 1, 4) associated with â„(9). Last, we move
to state 7 with ğ›¿âˆ—(9, d) = 3 and ğ›¿âˆ—(3, d) = 7 and report occurrence (F, 4, 6) associated with â„(7).

In the scanning, the number of states visited with ğ›¿ and ğ‘“ is bounded by 2ğ‘› for a text of length ğ‘›. The algorithm

runs in ğ‘‚ (ğ‘› + ğ‘œğ‘ğ‘) time in the most eï¬ƒcient case, where ğ‘œğ‘ğ‘ is the number of occurrences.

2.4 Double-array Ahoâ€“Corasick automata (DAACs)

The double-array [2] is a data structure to implement the transition function ğ›¿ using two one-dimensional arrays:
BASE and CHECK (see Figure 2). The double-array arranges original states in ğ‘† onto BASE and CHECK and assigns
new state ids to the original states. An element of BASE and CHECK corresponds to an original state, and its array

4

12558001024455012345678910BASECHECKAlgorithm 2: Construction of BASE and CHECK from an original trie using a queue.

: Original trie

Input
Output : BASE and CHECK arrays representing the original trie

1 Reserve enough elements of BASE and CHECK
2 ğ‘„ â† {(0, 0)}
3 while ğ‘„ â‰  âˆ… do
4

Pop (ğ‘ , ğ‘ (cid:48)) from ğ‘„
ğ¸ â† a set of labels of outgoing transitions from state ğ‘ 
if ğ¸ â‰  âˆ… then

âŠ² Queue to traverse the original trie, initialized with the initial state ids

âŠ² ğ‘  and ğ‘ (cid:48) denote state ids in the original trie and double-array, respectively

BASE[ğ‘ (cid:48)] â† integer ğ‘ such that ğ‘ + ğ‘ is a vacant id for each ğ‘ âˆˆ ğ¸
for ğ‘ âˆˆ ğ¸ do

âŠ² Vacant search

5

6

7

8

9

10

11

3

4

5

6

(ğ‘¡, ğ‘¡ (cid:48)) â† (ğ›¿(ğ‘ , ğ‘), BASE[ğ‘ (cid:48)] + ğ‘)
CHECK[ğ‘¡ (cid:48)] â† ğ‘ (cid:48)
Push (ğ‘¡, ğ‘¡ (cid:48)) to ğ‘„

12 Output BASE and CHECK

Algorithm 3: Implementation of ğ›¿âˆ—(ğ‘ , ğ‘) using DAAC.
1 repeat
2

ğ‘¡ â† BASE[ğ‘ ] + ğ‘
if CHECK[ğ‘¡] = ğ‘  then

return ğ‘¡
else if ğ‘  = 0 then
return 0
ğ‘  â† FAIL[ğ‘ ]

7
8 until

oï¬€sets indicate new state ids. The BASE and CHECK arrays are constructed so that new state ids satisfy the following
equations when ğ›¿(ğ‘ , ğ‘) = ğ‘¡ (except for ğ‘¡ = âˆ’1):

BASE[ğ‘ ] + ğ‘ = ğ‘¡ and CHECK[ğ‘¡] = ğ‘ .

(2)

Equation (2) enables us to look up a transition ğ›¿(ğ‘ , ğ‘) in two very simple steps: (i) computing ğ‘¡ := BASE[ğ‘ ] + ğ‘

and (ii) returning ğ‘¡ if CHECK[ğ‘¡] = ğ‘ or âˆ’1 otherwise. The time complexity is ğ‘‚ (1).

Let ğ‘†BC = {0, 1, . . . , |ğ‘†BC| âˆ’ 1} be a set of state ids in a resulting double-array structure. The space complexity
of BASE and CHECK is ğ‘‚ (|ğ‘†BC|), where |ğ‘†BC| = |ğ‘†| in the best case and |ğ‘†BC| = |ğ‘†||Î£| in the worst case, as ğ‘†BC can
contain unused ids to satisfy Equation (2). For example, state id 7 is unused in Figure 2. We call such state ids vacant
ids. Constructing BASE and CHECK as few vacant ids as possible is important for space eï¬ƒciency.

Construction algorithm Constructing BASE and CHECK requires traversing an original trie from the root and
searching for values of BASE[ğ‘ ] for each state ğ‘  to satisfy Equation (2). More formally, for a state ğ‘  having outgoing
transitions with ğ‘˜ labels ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜ , we search for a BASE value ğ‘ such that ğ‘ + ğ‘ ğ‘— is a vacant id for each 1 â‰¤ ğ‘— â‰¤ ğ‘˜
and deï¬ne BASE[ğ‘ ] = ğ‘ and CHECK[ğ‘ + ğ‘ ğ‘— ] = ğ‘ , which we call a vacant search. Algorithm 2 shows the construction
algorithm of BASE and CHECK. In Section 3.5, we will discuss approaches to accelerate vacant searches.

Extension to AC automaton We can extend the double-array to DAACs by introducing components for failure and
output functions. Figure 3 shows an example DAAC for the AC automaton in Figure 1a. The failure function ğ‘“ is
implemented with array FAIL such that FAIL[ğ‘ ] = ğ‘“ (ğ‘ ). Using the arrays BASE, CHECK, and FAIL, the extended
transition function ğ›¿âˆ— is implemented as Algorithm 3.

The output function â„ is implemented with three arrays: OUTPUT arranges values in â„(ğ‘ ) for output states ğ‘ , TERM
stores bit ï¬‚ags to identify terminals of each set â„(ğ‘ ) in OUTPUT, and OUTPOS[ğ‘ ] stores the starting positions of each

5

Figure 3: DAAC for the AC automaton in Figure 1a.

set â„(ğ‘ ) in OUTPUT. Using these arrays, we can extract â„(ğ‘ ) by scanning OUTPUT[ğ‘–.. ğ‘—] from the starting position
ğ‘– = OUTPOS[ğ‘ ] until encountering TERM[ ğ‘—] = 1.

3 Implementation techniques in DAACs

In this section, we review implementation techniques to improve the DAAC performance and describe them based on
our categorization (summarized in Table 2).

3.1 Management of output sets

We ï¬rst describe how to manage output sets eï¬ƒciently. Figure 3 shows a simple approach that arranges values in â„(ğ‘ )
in an array. We call this approach Simple. An advantage of Simple is the locality of reference that can extract â„(ğ‘ ) by a
sequential scan. However, Simple can maintain many duplicate values in OUTPUT. For example, value B appears four
times in the OUTPUT of Figure 3. The length of OUTPUT is bounded by ğ‘‚ (|D| Â· ğ¾), where ğ¾ is the average length of
patterns in the dictionary. In the following, we present two additional approaches, Shared and Forest, to improve the
memory eï¬ƒciency of Simple.

Shared arrangement To design Shared, we exploit the fact that â„(ğ‘¡) âŠ† â„(ğ‘ ) when state ğ‘¡ can be reached from state
ğ‘  through only failure links. For example, â„(2) âŠ† â„(3) âŠ† â„(9) in Figure 3. This fact indicates that values in â„(ğ‘¡)
can be represented as a part of the values in â„(ğ‘ ). Shared implements the OUTPUT and TERM arrays while merging
such common parts. Figure 4a shows an example of Shared, where â„(2) and â„(3) are represented in the rear parts
of OUTPUT[3..5] for â„(9). Shared can extract â„(ğ‘ ) in the same manner as Simple and does not lose the locality of
reference.

Forest representation A drawback of Shared is that it cannot remove all duplicate values, and the space complexity
of OUTPUT and TERM is not improved. For example, value B still appears twice in Figure 4a. Forest is an alternative
approach that maintains only unique pattern indices [7].

Multiple trees, or a forest, can be constructed from an AC automaton by chaining output states through the failure
function, which we call an output forest. The left part of Figure 4b shows such an output forest constructed from the
AC automaton in Figure 3. In the output forest, we can extract values in â„(ğ‘ ) by climbing up the corresponding tree to
the root.

Forest constructs an output forest whose nodes are indexed by numbers from {0, 1, . . . , |D| âˆ’ 1}. Our data
structure represents the forest using two arrays, OUTPUT and PARENT, such that OUTPUT stores pattern indices and
PARENT stores parent positions. Also, OUTPOS[ğ‘ ] stores the node index corresponding to an output state ğ‘  in the

6

125580010244550002012430013569012345678910BASECHECKFAILOUTPOS10101100110123456789OUTPUTTERM(a) Shared

(b) Forest

Figure 4: Examples of approaches to store output sets of Figure 3.

AC automaton. â„(ğ‘ ) is extracted by visiting OUTPUT[ğ‘–] from node ğ‘– := OUTPOS[ğ‘ ] while updating ğ‘– := PARENT[ğ‘–]
until encountering the root. The right part of Figure 4b shows the data structure.

The advantage of Forest is that the space complexity of OUTPUT and PARENT is bounded by ğ‘‚ (|D|). However,
traversing an output forest requires random accesses, which sacriï¬ces the locality of reference in Simple and Shared.
Also, the pointer array PARENT consumes a larger space than the bit array TERM.

3.2 Byte- and character-wise automata

When handling strings consisting of multibyte characters, there are two representations of strings:

â€¢ Bytewise represents strings as sequences of bytes in the UTF-8 format and uses byte values for transition labels.

The maximum value in the alphabet Î£ is the maximum byte value appearing in input patterns.

â€¢ Charwise represents strings as sequences of code points in Unicode and uses code-point values for transition
labels. The maximum value in the alphabet Î£ is the maximum code-point value appearing in input patterns.

For example, the Japanese string â€œä¸–ç•Œâ€ (meaning â€œthe worldâ€) is represented as a sequence of six bytes â€œ0xE4,
0xB8, 0x96, 0xE7, 0x95, 0x8Câ€ in Bytewise and a sequence of two code points â€œU+4E16, U+754Câ€ in Charwise. The
alphabet Î£ in Bytewise is {0x00, 0x01, . . . , 0xE7}, and the alphabet Î£ in Charwise is {U+0000, U+0001, . . . , U+754C}.
In the following, we ï¬rst describe the advantages and disadvantages when constructing DAACs from strings in
the Bytewise or Charwise scheme; then, we present an approach called Mapped to overcome the disadvantages in the
Charwise scheme.

Advantages and disadvantages There is a trade-oï¬€ between the alphabet size (or |Î£|) and the number of automaton
states (or |ğ‘†|): the alphabet size in Bytewise is bounded by 28 and is smaller than that in Charwise bounded by 221

7

540236012345678910OUTPOS01100110123456OUTPUTTERM010012345OUTPUTPARENT013524012345678910OUTPOS(since code points are drawn up to U+10FFFF), and the number of states in Charwise is lower than that in Bytewise.
For example, consider an AC automaton for the single pattern â€œä¸–ç•Œâ€. The alphabet size in Bytewise is 232 (i.e., 0xE7
plus 1) while that in Charwise is 30029 (i.e., U+754C plus 1); thus, the number of states in Bytewise is seven while
that in Charwise is three.

Smaller alphabets enable DAACs to achieve faster construction because the possible number of outgoing transitions
from a state is suppressed, which facilitates vacant searches. Fewer states enable DAACs to achieve faster matching
because of suppressing the number of random memory accesses during a matching. Therefore, Bytewise is beneï¬cial
for faster construction, and Charwise is beneï¬cial for faster matching.

The memory usage of DAACs depends on the number of resulting double-array states |ğ‘†BC|, which is the sum of
the number of original states |ğ‘†| and that of vacant ids. Although Charwise can construct an AC automaton with fewer
states, its large alphabet can produce more vacant ids because of the diï¬ƒculty in vacant searches. Thus, we can achieve
memory eï¬ƒciency by constructing a DAAC with fewer vacant ids in the Charwise scheme.

Code mapping The Mapped approach can overcome the disadvantages in Charwise by mapping code points to
smaller integers [29]. This approach assigns code values to characters ğ‘ âˆˆ Î£ with a certain frequency to assign smaller
code values to more frequent characters.

We give a formal description of Mapped. Let us denote by #(ğ‘) the number of occurrences of character ğ‘ âˆˆ Î£ in

patterns of D. We construct the mapping function ğœ‹ : Î£ â†’ Î£ ğœ‹ such that:

â€¢ Î£ ğœ‹ = {âˆ’1, 0, 1, . . . , ğœ âˆ’ 1}, where ğœ is the number of characters ğ‘ such that #(ğ‘) â‰  0;

â€¢ ğœ‹(ğ‘) = âˆ’1 for characters ğ‘ when #(ğ‘) = 0; and

â€¢ ğœ‹(ğ‘) is the number of other characters ğ‘(cid:48) such that #(ğ‘) < #(ğ‘(cid:48)) (breaking ties arbitrarily).

We call ğœ the mapped alphabet size.

Also, Equation (2) is modiï¬ed into

BASE[ğ‘ ] + ğœ‹(ğ‘) = ğ‘¡ and CHECK[ğ‘¡] = ğ‘ .

(3)

Note that characters ğ‘ such that ğœ‹(ğ‘) = âˆ’1 are not used in transitions because (i) during construction, the characters do
not appear, and (ii) during pattern matching, we can immediately know whether transitions with the characters fail.

If Î£ includes many characters ğ‘ such that #(ğ‘) = 0, the mapped alphabet size ğœ becomes much smaller than |Î£|.
Moreover, occurrences of real-world characters are often skewed following Zipfâ€™s law [51], indicating that most of the
characters in D are represented with small code values via the mapping ğœ‹. Prior works have empirically demonstrated
that mapping ğœ‹ reduces the resultant vacant ids and shortens the construction time [29, 36, 44].

However, we need to store an additional data structure for implementing the mapping ğœ‹. We implement ğœ‹ with an
array of length |Î£| such that the ğ‘-th element stores the value of ğœ‹(ğ‘). When the array consists of 221 four-byte integers,
it takes 8 MiB of memory.

3.3 Memory layout of arrays

This paper says that the data structure of DAACs consists of four arrays: BASE, CHECK, FAIL, and OUTPOS. In the
following, we describe the two memory layouts of the four arrays: Individual and Packed.

Individual layout The Individual layout maintains the four arrays individually, as shown in Figure 5a.

Packed layout Since the values of BASE[ğ‘ ], CHECK[ğ‘ ], FAIL[ğ‘ ], and OUTPOS[ğ‘ ] are accessed consecutively during
a matching, we should be able to improve the locality of reference by placing these values in a consecutive memory
array. The Packed layout represents states using a one-dimensional array STATE, where each element consists of the
four ï¬elds base, check, fail, and outpos corresponding to each array. Figure 5b illustrates the Packed layout.

8

(a) Individual

(b) Packed

Figure 5: Illustrations of memory layouts of arrays.

3.4 Array formats

Double-array implementations often use 4-byte integers to represent an oï¬€set of arrays (e.g., [28, 46]). When BASE,
CHECK, FAIL, and OUTPOS are implemented as arrays of 4-byte integers, we call this format Basic. In the following,
we describe a more memory-eï¬ƒcient format that implements CHECK as a byte array in the Bytewise scheme, called
Compact.

Compact format The Compact format stores transition labels in CHECK instead of array oï¬€sets [49]. In other words,
CHECK[ğ‘¡] stores ğ‘ instead of ğ‘  when ğ›¿(ğ‘ , ğ‘) = ğ‘¡, and Equation (2) is modiï¬ed into

However, for every state pair (ğ‘ , ğ‘ (cid:48)), the following must be satisï¬ed to avoid deï¬ning invalid transitions:

BASE[ğ‘ ] + ğ‘ = ğ‘¡ and CHECK[ğ‘¡] = ğ‘.

BASE[ğ‘ ] â‰  BASE[ğ‘ (cid:48)].

(4)

(5)

In the Bytewise scheme, the alphabet size is bounded by 256, and CHECK can be implemented as a byte array.
The Compact format can reduce the memory consumption of CHECK to 25% while maintaining the time eï¬ƒciency in
matching. In the Packed layout, we assign three bytes to base, one byte to check, and four bytes to fail and outpos for
avoiding extra memory padding on a 4-byte aligned memory structure, following the original implementation [49].1

A drawback of Compact is that it makes it harder for vacant searches to avoid the duplication of BASE values for
satisfying Equation (5); indeed, this restriction can produce vacant ids that never satisfy Equation (5). For example, a
vacant id ğ‘  never satisï¬es Equation (5) when BASE values ğ‘ , ğ‘  âˆ’ 1, . . . , ğ‘  âˆ’ |Î£| + 1 are already used. In Section 4.5, we
observe that such vacant ids can signiï¬cantly slow the running times of vacant searches.

3.5 Acceleration of vacant searches
Given a state having ğ‘˜ outgoing transitions with labels ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜ , a naÃ¯ve vacant search is performed to verify if
ğ‘ + ğ‘ ğ‘— for 1 â‰¤ ğ‘— â‰¤ ğ‘˜ are vacant ids for each integer ğ‘ â‰¥ 0 until ï¬nding such a value ğ‘. However, for a maximum state
id ğ‘, this approach veriï¬es ğ‘‚ (ğ‘) integers in the worst case, resulting in slow construction for a large automaton. In
the following, we describe three acceleration techniques for vacant searches: Chain, SkipForward, and SkipDense.

Chaining vacant ids The Chain technique constructs a linked list on vacant ids [32]. Let us denote ğ‘€ vacant ids
by ğ‘1, ğ‘2, . . . , ğ‘ ğ‘€ , where 0 < ğ‘1 < ğ‘2 < Â· Â· Â· < ğ‘ ğ‘€ < ğ‘. Given a state having ğ‘˜ outgoing transitions with labels

1This modiï¬cation limits the maximum state id to 224 âˆ’ 1. To represent state ids up to 229 âˆ’ 1 with the same space usage, we can employ a
technique used in the Darts-clone library [46] that utilizes two types of oï¬€set values to represent exact and rough positions. We did not use this
technique in our experiments because three bytes are enough to store the automata we tested.

9

B0...BN-1C0...CN-1F0...FN-1O0...ON-1BASECHECKFAILOUTPOSB0C0F0O0B1C1F1O1...BN-1CN-1FN-1ON-1STATE[0]STATE[1]STATE[N-1]Figure 6: BASE and CHECK implementing the transition function ğ›¿ of Figure 1b based on Equation (6). The block
size ğµ is four, since |Î£| = 4 and ğµ = 2 (cid:100)log2 4(cid:101). Destination states 5 and 7 from state 1 are placed in the same block, i.e.,
(cid:98)5/4(cid:99) = (cid:98)7/4(cid:99) = 1.

ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜ , Chain veriï¬es only BASE values ğ‘ğ‘– such that ğ‘ğ‘– = ğ‘ğ‘– âˆ’ min{ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜ } for ğ‘– = 1, 2, . . . , ğ‘€ while
visiting only vacant ids using the linked list. The number of veriï¬cations is bounded by ğ‘‚ (ğ‘€).

If there are few vacant ids, ğ‘€ becomes much smaller than ğ‘, and vacant searches can be performed faster than with
the naÃ¯ve approach. The resultant double-array structure with Chain is always identical to that with the naÃ¯ve approach.

Skipping search blocks Before introducing SkipForward and SkipDense, we present a technique to partition array
elements into ï¬xed-size blocks [24, 46, 52]. The partitioning modiï¬es Equation (2) into

BASE[ğ‘ ] âŠ• ğ‘ = ğ‘¡ and CHECK[ğ‘¡] = ğ‘ .

(6)

In other words, the bitwise-XOR operation (âŠ•) is used instead of the plus operation (+).

We introduce a constant parameter ğµ and partition array elements into blocks of size ğµ, where the ğ‘ -th element is

placed in the (cid:98)ğ‘ /ğµ(cid:99)-th block. We obtain the following theorem.

Theorem 1. Let ğµ = 2 (cid:100)log2 |Î£|(cid:101).2 When state ids are deï¬ned using Equation (6), all destination states from a state are
always placed in the same block.

Proof. Computing BASE[ğ‘ ] âŠ• ğ‘ is implemented by modifying the least signiï¬cant (cid:100)log2 |Î£|(cid:101) bits of BASE[ğ‘ ]. For all
characters ğ‘ âˆˆ Î£, the results of BASE[ğ‘ ] âŠ• ğ‘ have the same binary representation except the least signiï¬cant (cid:100)log2 |Î£|(cid:101)
bits. Computing (cid:98)ğ‘¥/ğµ(cid:99) for an integer ğ‘¥ is implemented by shifting (cid:100)log2
ğµ(cid:101) = (cid:100)log2 |Î£|(cid:101) bits right, and the least
signiï¬cant (cid:100)log2 |Î£|(cid:101) bits of ğ‘¥ are omitted from the result. Therefore, (cid:98)(BASE[ğ‘ ] âŠ• ğ‘)/ğµ(cid:99) = (cid:98)BASE[ğ‘ ]/ğµ(cid:99) for all
(cid:3)
characters ğ‘ âˆˆ Î£, and all destination states ğ‘¡ from a state ğ‘  are placed in the (cid:98)BASE[ğ‘ ]/ğµ(cid:99)-th block.

Figure 6 shows an example of BASE and CHECK constructed using Equation (6). The partitioning allows us
to perform vacant searches for blocks individually and set up conditions if we search each block. SkipForward and
SkipDense each use a diï¬€erent approach to select which blocks to be searched.

SkipForward searches for only the last ğ¿ blocks with a constant parameter ğ¿ [46], as shown in Figure 7a. This idea
is inspired by the fact that backward state ids are more likely to be vacant when performing vacant searches from the
forward [32]. SkipForward can bound the number of veriï¬cations in a vacant search by ğ‘‚ (ğ¿ Â· |Î£|) = ğ‘‚ (|Î£|), since ğ¿
is constant. A drawback of SkipForward is that blocks containing many vacant ids might be skipped, which degrades
the memory eï¬ƒciency.

SkipDense introduces a constant threshold ğœ âˆˆ [0, 1] and categorizes blocks into two classes: if the proportion of
vacant ids in a block is no less than ğœ, the block is categorized to the sparse class; otherwise, the block is categorized
to the dense class. SkipDense performs vacant searches for only sparse blocks, as shown in Figure 7b. SkipDense

2In the Mapped scheme, ğœ is used instead of |Î£ |.

10

2456900021316601234567891011BASECHECK(a) SkipForward

(b) SkipDense

Figure 7: Illustrations of skipping techniques.

does not skip blocks that contain many vacant ids and is thus more memory-eï¬ƒcient than SkipForward. However, the
number of veriï¬cations is not bounded by the alphabet size.3

The ideas of both SkipForward and SkipDense do not conï¬‚ict with Chain. We therefore apply the technique of

Chain to SkipForward and SkipDense.

3.6 Traversal orders in construction

BASE and CHECK are constructed by traversing an original trie from the root and performing vacant searches, as
shown in Algorithm 2. Although this algorithm traverses the original trie using a queue in the breadth-ï¬rst order, we
can take an arbitrary order to traverse the trie. We can also take an arbitrary scan order of outgoing transitions for each
visited state (i.e., the loop order of ğ¸ at Line 8 in Algorithm 2).

The orders are related to the resultant arrangement of states in BASE and CHECK, and the arrangement aï¬€ects the
cache eï¬ƒciency in transitions: a transition ğ›¿(ğ‘ , ğ‘) = ğ‘¡ can be looked up quickly when states ğ‘  and ğ‘¡ are placed close
together (e.g., on the same cache line). Selecting the traversal order that improves the locality of reference during a
matching is crucial. In the following, we describe the four approaches: LexBFS, LexDFS, FreqBFS, and FreqDFS.

Breadth- and depth-ï¬rst searches There are two types of data structures to traverse the original trie. One uses a
queue and visits states with a breadth-ï¬rst search (as Algorithm 2), which we denote by BFS. The other uses a stack
and visits states with a depth-ï¬rst search, which we denote by DFS.

We consider performing vacant searches from the forward (i.e., attempting to use smaller state ids ï¬rst). The
resultant arrangements of states using BFS and DFS are expected to be as follows. With BFS, it is expected that
shallower states (i.e., ones around the initial state) are placed around the head of BASE and CHECK. If we often visit
shallow states during a matching, BFS can perform cache-eï¬ƒciently. With DFS, in contrast, it is expected that deeper
states are placed close together. If we often visit deep states during a matching, DFS can perform cache-eï¬ƒciently.

Figure 8 shows toy examples of resultant BASE and CHECK arrays with BFS and DFS. In BFS, shallower states
have smaller state ids (see Figure 8a), while in DFS, states whose depth is no less than two have adjacent ids with their
destination states (see Figure 8b). These examples show that BFS and DFS have better locality of reference when we
visit shallower and deeper states, respectively.

Lexicographical and frequency orders There are two orders to traverse outgoing transitions for each visited state:
Lex visits transitions in the lexicographical order of their labels, and Freq visits transitions in the decreasing order

3SkipDense is inspired by the idea in the Darts library [28], which skips forward elements in which the proportion of vacant ids is not less than a
certain threshold. SkipDense is a minor modiï¬cation of the Darts technique combined with block partitioning and enables vacant searches to select
target blocks more ï¬‚exibly.

11

The last      blocksVacant searchSparseSparseSparseSparseVacant searchVacant searchVacant search(a) BFS

(b) DFS

Figure 8: Examples of resultant BASE and CHECK arrays constructed with BFS and DFS for a dictionary of four
patterns aa, bbb, cccc, and ddddd. Î£ = {a = 0, b = 1, c = 2, d = 3}. The state ids are determined based on Equation
(2). In the construction, vacant searches are performed from the forward to use smaller state ids ï¬rst. A set of outgoing
transition labels (or ğ¸) is scanned in the lexicographical order (i.e., the ï¬gures show the results of LexBFS and LexDFS
more precisely). In both cases, the initial state and its destination states have identical ids (i.e., states 0 to 4). This is
because the initial state id is always ï¬xed to 0, and its destination state ids are ï¬xed to BASE[0] to satisfy Equation (2).
The deeper states have diï¬€erent ids in accordance with the order of visiting states.

12

155558881010110000123467810111301234567891011121314BASECHECK15568678910110000126389411121301234567891011121314BASECHECKTable 2: Summary of implementation techniques in DAACs. â€œSelectedâ€ indicates the techniques selected to be the
best through our experiments in Section 4 and are used in our Daachorse library.

(a) Approaches to store output sets (Section 3.1)

Technique

Simple
Shared
Forest

Brief description
Arranging pattern indices in a simple manner
Merging some common parts of pattern indices in Simple
Storing pattern indices in a forest structure

References
Conventional
This study
[7]

Selected

(cid:88)

(b) Schemes to handle strings of multibyte characters (Section 3.2)

Technique

Bytewise
Charwise
Mapped

Brief description
Slicing multibyte characters into byte sequences
Handling multibyte characters as code points in Unicode
Mapping code points in the frequency order

References
Conventional
Conventional
[29, 36]

Selected
(cid:88)

(cid:88)

(c) Memory layouts of double-arrays (Section 3.3)

Technique

Individual
Packed

Brief description
Maintaining arrays BASE, CHECK, FAIL, and OUTPOS individually
Arranging values in the arrays cache-eï¬ƒciently

References
Conventional
e.g., [32, 49]

Selected

(cid:88)

(d) Formats of double-arrays in Bytewise scheme (Section 3.4)

Technique

Basic
Compact

Brief description
Implementing BASE, CHECK, FAIL, and OUTPOS as arrays of four-byte integers
Compressing CHECK into a byte array

References
Conventional
[49]

Selected

(cid:88)

(e) Approaches to accelerate vacant searches (Section 3.5)

Technique

Chain
SkipForward
SkipDense

Brief description
Visiting only vacant ids with a linked list
Searching for only the last ğ¿ blocks
Searching for only blocks in which the vacant proportion is no less than ğœ

References
[32]
[32, 46]
This study

Selected

(cid:88)

(f) Traversal orders in construction (Section 3.6)

Technique

LexBFS
FreqBFS
LexDFS
FreqDFS

Brief description
Visiting states with breadth-ï¬rst search and transition labels in the lexicographical order
Visiting states with breadth-ï¬rst search and transition labels in the frequency order
Visiting states with depth-ï¬rst search and transition labels in the lexicographical order
Visiting states with depth-ï¬rst search and transition labels in the frequency order

References
Conventional
Conventional
Conventional
Conventional

Selected

(cid:88)

of the frequencies of their labels in D. In the Freq order, ids of states incoming with frequent transition labels are
determined earlier, and it is expected that those states are placed at the head of the array.

Possible combinations There are four possible combinations in the traversal order:

â€¢ LexBFS is BFS with Lex,

â€¢ FreqBFS is BFS with Freq,

â€¢ LexDFS is DFS with Lex, and

â€¢ FreqDFS is DFS with Freq.

3.7 Summary of implementation techniques

Table 2 summarizes the implementation techniques described in this section.

13

Table 3: Basic statistics of dictionaries.

(a) Average pattern length in bytes

(b) Average pattern length in characters

(c) Alphabet size in the Bytewise scheme

Dataset

EnWord
JaWord
JaChars

1K
5.0
5.7
4.9

10K
6.6
6.7
6.3

100K
7.1
8.7
7.3

1M
7.5
14.5
8.0

Dataset

EnWord
JaWord
JaChars

1K
5.0
1.9
1.8

10K
6.6
2.3
2.3

100K
7.1
3.0
2.7

1M
7.5
5.2
2.9

Dataset

EnWord
JaWord
JaChars

1K
226
233
233

10K
226
238
233

100K
239
239
238

1M
239
244
239

(d) Alphabet size in the Charwise scheme

(e) Mapped alphabet size in the Mapped scheme

Dataset

EnWord
JaWord
JaChars

1K
8,226
39,640
39,640

10K
9,632
57,345
40,845

100K
63,289
64,017
57,345

1M
65,532
1,048,766
64,017

Dataset

EnWord
JaWord
JaChars

1K
83
669
483

10K
104
2,262
1,648

100K
177
4,806
2,990

1M
472
10,809
4,773

Table 4: The number of occurrences in pattern matching per sentence.

Dataset

EnWord
JaWord
JaChars

1K
47.2
25.8
36.6

10K
93.4
38.0
54.6

100K
126.2
46.7
69.7

1M
150.8
49.0
79.9

4 Experimental analyses of DAAC techniques

4.1 Setup

We conducted all experiments on one core of a hexa-core Intel i7-8086K CPU clocked at 2.80 GHz in a machine with
64 GB of RAM (L1 cache: 32 KiB, L2 cache: 256 KiB, L3 cache: 12 MiB), running the 64-bit version of CentOS 7.5
based on Linux 3.10. All data structures were implemented in Rust. We compiled the source code by rustc 1.60.0 with
optimization ï¬‚ag opt-level=3.

Datasets We use three real-world natural language datasets:

â€¢ EnWord is English word uni-grams in the Google Web 1T 5-Gram Corpus [8];

â€¢ JaWord is Japanese word uni-grams in the Nihongo Web Corpus 2010 [45]; and

â€¢ JaChars is Japanese character uni-, bi-, and tri-grams in the Nihongo Web Corpus 2010 [45].

In these datasets, each N-gram has its own frequency. We extract the most frequent ğ¾ N-grams from each dataset
and produce dictionaries D of ğ¾ patterns. We test ğ¾ = 103, 104, 105, 106 to observe scalability. Table 3 lists the basic
statistics of the dictionaries.

We evaluate the running times of pattern matching and the construction and memory usage of an AC automaton.
We use an English text from the Pizza&Chili Corpus [15] and a Japanese text from 13 diï¬€erent subcorpora in the
Balanced Corpus of Contemporary Written Japanese (BCCWJ, version 1.1) [30] to measure pattern matching times for
the English and Japanese dictionaries, respectively. We randomly sample one million sentences (separated by lines)
from each text and produce a sequence of search texts ğ‘‡. Table 4 shows the number of occurrences during a pattern
matching for each dataset. Throughout the experiments, we report the total running time of a pattern matching for all
sentences, averaged on ten runs.

4.2 Analysis on approaches to store output sets

Table 5 shows the experimental results on the Simple, Shared, and Forest approaches presented in Section 3.1, while
ï¬xing the other settings to Bytewise, Packed, Basic, Chain, and LexDFS.

14

Table 5: Experimental results for approaches to store output sets: Simple, Shared, and Forest. For memory usage, the
total of OUTPUT and TERM is reported in Simple and Shared, and the total of OUTPUT and PARENT is reported in
Forest. The last two rows in Tables (a)â€“(c) show the diï¬€erent ratios for each result.

(a) Length of OUTPUT (Ã—103)

EnWord

JaWord

JaChars

Approach

Simple
Shared
Forest
Shared/Simple
Forest/Simple

1K
1.60
1.46
1.00
0.92
0.63

10K
29.2
26.2
10.0
0.90
0.34

100K
412
362
100
0.88
0.24

1M
4,988
4,377
1,000
0.88
0.20

1K
1.46
1.31
1.00
0.89
0.68

10K
18.7
16.7
10.0
0.89
0.53

100K
247
218
100
0.88
0.40

1M
3,615
3,132
1,000
0.87
0.28

1K
1.68
1.40
1.00
0.83
0.60

10K
21.6
17.7
10.0
0.82
0.46

100K
252
217
100
0.86
0.40

1M
2,779
2,497
1,000
0.90
0.36

(b) Memory usage (KiB)

EnWord

JaWord

JaChars

Approach

Simple
Shared
Forest
Shared/Simple
Forest/Simple

1K
12.5
11.4
11.7
0.92
0.94

10K
228
205
117
0.90
0.51

100K
3,219
2,830
1,172
0.88
0.36

1M
38,968
34,192
11,719
0.88
0.30

1K
11.4
10.2
11.7
0.89
1.02

10K
146
131
117
0.89
0.80

100K
1,932
1,703
1,172
0.88
0.61

1M
28,244
24,473
11,719
0.87
0.41

1K
13.1
10.9
11.7
0.83
0.89

10K
168
139
117
0.82
0.70

100K
1,971
1,692
1,172
0.86
0.59

1M
21,707
19,507
11,719
0.90
0.54

(c) Matching time (ms)

EnWord

JaWord

JaChars

Approach

Simple
Shared
Forest
Shared/Simple
Forest/Simple

1K
525
525
533
1.00
1.01

10K
609
613
596
1.01
0.98

100K
693
719
697
1.04
1.00

1M
1,088
1,148
1,088
1.06
1.00

1K
469
457
446
0.98
0.95

10K
646
653
626
1.01
0.97

100K
919
923
871
1.00
0.95

1M
1,266
1,304
1,259
1.03
0.99

1K
448
415
427
0.92
0.95

10K
700
668
663
0.95
0.95

100K
1,073
1,044
1,027
0.97
0.96

1M
2,853
2,822
2,796
0.99
0.98

(d) Average cardinality of â„ (ğ‘ )

Dataset

EnWord
JaWord
JaChars

1K
1.37
1.42
1.63

10K
2.07
1.76
2.06

100K
3.16
2.20
2.42

1M
4.15
3.02
2.73

15

Table 6: Experimental results on memory eï¬ƒciency in the Bytewise, Charwise, and Mapped schemes. The memory
usage is the total of BASE, CHECK, FAIL, and OUTPOS (and the mapping ğœ‹ in Mapped). The last rows in Tables (a)
and (d) show the diï¬€erent ratios for each result.

(a) Number of original states (Ã—103)

Scheme

Bytewise
Charwise
Charwise/Bytewise

1K
2.74
2.74
1.00

EnWord

10K
25.6
25.6
1.00

100K
237
237
1.00

1M
2,129
2,124
1.00

1K
2.96
1.43
0.48

JaWord

10K
27.9
13.0
0.47

100K
305
142
0.46

1M
4,899
2,155
0.44

1K
1.73
1.12
0.65

JaChars

10K
18.5
10.9
0.59

100K
186
107
0.58

1M
1,790
1,052
0.59

(b) Proportion of vacant ids (%)

Scheme

Bytewise
Charwise
Mapped

EnWord

1K
2.6
66.6
2.7

10K
0.9
0.2
0.9

100K
0.1
0.0
0.2

1M
0.0
0.0
0.0

1K
3.7
96.4
30.2

JaWord

10K
0.8
77.3
20.5

100K
0.2
16.3
3.9

1M
0.1
0.7
1.1

1K
15.3
97.2
27.1

JaChars

10K
0.8
84.1
24.1

100K
0.2
68.0
12.6

1M
0.0
71.8
27.0

(c) Average number of outgoing transitions for an internal state.

Scheme

Bytewise
Charwise

1K
1.41
1.41

EnWord

10K
1.40
1.41

100K
1.44
1.44

JaWord

1M
1.50
1.50

1K
1.41
2.54

10K
1.43
2.79

100K
1.37
2.40

1M
1.20
1.60

1K
1.87
3.58

JaChars

10K
1.68
3.25

100K
1.75
3.83

1M
1.91
5.33

(d) Memory usage (KiB)

EnWord

JaWord

JaChars

Scheme

Bytewise
Charwise
Mapped
Charwise/Bytewise
Mapped/Bytewise
Mapped/Charwise

1K
44
128
76
2.91
1.73
0.59

10K
404
401
442
0.99
1.09
1.10

100K
3,712
3,707
3,959
1.00
1.07
1.07

1M
33,276
33,193
33,456
1.00
1.01
1.01

1K
48
619
187
12.89
3.89
0.30

10K
440
896
480
2.04
1.09
0.54

100K
4,780
2,646
2,554
0.55
0.53
0.97

1M
76,596
33,922
38,145
0.44
0.50
1.12

1K
32
619
179
19.34
5.59
0.29

10K
292
1,067
384
3.65
1.31
0.36

100K
2,908
5,240
2,144
1.80
0.74
0.41

1M
27,972
58,318
22,778
2.08
0.81
0.39

We ï¬rst focus on the statistics related to memory eï¬ƒciency. Table 5a shows the length of OUTPUT, i.e., the
number of pattern indices stored in the data structure. The length in Forest is essentially the same as the number of
patterns and is much smaller than that in Simple, indicating that Simple maintains many duplicate values in OUTPUT.
Shared also reduces such duplicate values in Simple. Comparing Shared and Forest on their reduction ratios from
Simple, the diï¬€erence becomes larger as the number of patterns increases, and Forest is more memory eï¬ƒcient for
large dictionaries. Table 5b shows the memory usage of the data structures. Shared is the smallest when the number
of patterns is 1K, and Forest is the smallest in the other cases.

We next focus on the statistics related to the time eï¬ƒciency of the AC algorithm. Table 5c reports the elapsed
time during a pattern matching, and as we can see, there is no signiï¬cant diï¬€erence between the approaches. These
results indicate that the cache-eï¬ƒcient scanning in Simple and Shared is unimportant. To clarify this, Table 5d shows
the average cardinality of â„(ğ‘ ) for each dictionary. These results imply that only a few random accesses can arise in
Forestâ€™s extraction and do not create a bottleneck.

4.3 Analysis on byte-wise and character-wise schemes

We evaluate the performances of the Bytewise, Charwise, and Mapped schemes presented in Section 3.2, while ï¬xing
the other settings to Forest, Packed, Basic, Chain, and LexDFS.

Table 6 shows the results on memory eï¬ƒciency, where Table 6a lists the number of original states (i.e., |ğ‘†|) and
Table 6b reports the proportion of vacant ids (i.e., |ğ‘†|/|ğ‘†BC|), which we call vacant proportion. On JaWord and

16

Table 7: Experimental results on time eï¬ƒciency in the Bytewise, Charwise, and Mapped schemes. The last rows in
Tables (a) and (c) show the diï¬€erent ratios for each result.

(a) Number of visiting states during matching (Ã—106)

Scheme

Bytewise
Charwise
Charwise/Bytewise

1K
108
108
1.00

EnWord

10K
104
104
1.00

100K
107
107
1.00

1M
111
111
1.00

1K
128
57
0.44

JaWord

10K
128
61
0.48

100K
129
61
0.47

JaChars

1M
129
61
0.47

1K
129
59
0.45

10K
129
62
0.48

100K
129
62
0.48

1M
131
62
0.48

Scheme

Bytewise
Charwise
Mapped
Charwise/Bytewise
Mapped/Bytewise
Mapped/Charwise

Scheme

Bytewise
Charwise
Mapped
Charwise/Bytewise
Mapped/Bytewise
Mapped/Charwise

1K
527
550
563
1.04
1.07
1.02

1K
0.12
0.14
0.09
1.18
0.80
0.68

(b) Matching time (ms)

EnWord

JaWord

JaChars

10K
597
628
654
1.05
1.10
1.04

100K
689
720
741
1.04
1.08
1.03

1M
1,057
1,098
1,135
1.04
1.07
1.03

1K
454
362
315
0.80
0.69
0.87

10K
644
444
407
0.69
0.63
0.92

100K
896
563
533
0.63
0.59
0.95

1M
1,254
809
762
0.65
0.61
0.94

1K
406
356
304
0.88
0.75
0.85

10K
648
507
424
0.78
0.65
0.84

100K
1,021
661
625
0.65
0.61
0.94

1M
2,735
1,812
1,677
0.66
0.61
0.93

(c) Construction time (ms)

EnWord

JaWord

JaChars

10K
1.34
0.79
0.81
0.59
0.60
1.03

100K
21
18
18
0.86
0.86
1.01

1M
244
199
204
0.81
0.83
1.03

1K
0.13
0.32
0.06
2.51
0.44
0.17

10K
1.44
1.09
1.50
0.76
1.04
1.37

100K
27
163
102
6.03
3.77
0.62

1M
387
1,829
1,251
4.72
3.23
0.68

1K
0.09
0.29
0.08
3.14
0.83
0.26

10K
1.2
2.3
1.4
1.92
1.22
0.64

100K
20
134
45
6.72
2.25
0.33

1M
275
21,184
9,107
77.1
33.1
0.43

JaChars, whose strings consist of multibyte characters, Charwise deï¬nes fewer states than Bytewise but more vacant
ids. Especially in JaChars, the vacant proportion in Charwise is always more than 68%. The large vacant proportions
are related to the average number of outgoing transitions from an internal state, as reported in Table 6c. The more
outgoing transitions there are, the easier it is for vacant searches to fail and the number of vacant ids to increase. The
large vacant proportions of Charwise, however, can be improved with the code mapping ğœ‹, as the result of Mapped
demonstrates.

Table 6d reports the total memory usage of BASE, CHECK, FAIL, and OUTPOS (and the mapping ğœ‹ in Mapped).
On EnWord, there is no signiï¬cant diï¬€erence between the schemes when the number of patterns is no less than 10K.
On JaWord and JaChars, Mapped is always the ï¬rst or second smallest because of its fewer states and smaller vacant
proportions.

Table 7 shows the experimental results on time eï¬ƒciency, where Table 7a reports the number of visiting states
during matching with ğ›¿ and ğ‘“ . On EnWord, whose characters are mostly single-byte ones, there is no signiï¬cant
diï¬€erence between the schemes. On JaWord and JaChars, whose strings consist of multibyte characters, Charwise
(or Mapped) achieves half as many as Bytewise, resulting in halving the number of random accesses during a pattern
matching. Table 7b lists the elapsed time during a pattern matching. On JaWord and JaChars, Charwise and Mapped
are faster than Bytewise because of their fewer random accesses. Comparing Charwise and Mapped, there is no large
diï¬€erence, although Mapped requires additional computations for the code mapping ğœ‹.

Table 7c shows the elapsed time to compute two arrays, BASE and CHECK, from an original trie. On EnWord,
Charwise and Mapped are faster than Bytewise in most cases. On JaWord and JaChars, Charwise is much slower than
Bytewise, and its time performance is improved by the code mapping of Mapped; nevertheless, Mapped is still much
slower than Bytewise for large dictionaries. The time ineï¬ƒciency of Charwise and Mapped is caused by their large
vacant proportion (as shown in Table 6b): Chain does not perform well when there are many vacant ids.

17

(a) Matching time (ms)

(b) Number of L3 cache misses occurring during a pattern matching

Figure 9: Comparison results on matching time for the Individual and Packed layouts.

4.4 Analysis on memory layouts

Figure 9 shows the experimental results for the Individual and Packed layouts presented in Section 3.3, while ï¬xing
the other settings to Forest, Bytewise, Basic, Chain, and LexDFS. Figure 9a shows the matching time. The greater the
number of patterns, the faster Packed becomes. Packed is â‰ˆ20% faster than Individual when the number of patterns is
106. The time eï¬ƒciency of Packed stems from its cache-eï¬ƒciency. Figure 9b shows the number of L3 cache misses
occurring during a pattern matching. When the number of patterns is no greater than 105, cache misses infrequently
occur because the data structure ï¬ts in the cache memory. However, when the number of patterns is 106, Packed
achieves 38â€“47% cache misses compared to Individual.

4.5 Analysis on array formats

Table 8 shows the experimental results for the Basic and Compact formats presented in Section 3.4, while ï¬xing the
other settings to Forest, Bytewise, Packed, Chain, and LexDFS.

Table 8a reports the total memory usage of BASE, CHECK, FAIL, and OUTPOS. In all cases, the memory usage in
Compact is 75% of that in Basic because there is no diï¬€erence in the resulting number of vacant ids (although Equation
(5) has to be satisï¬ed). There is no signiï¬cant diï¬€erence in the matching time, as Table 8b shows.

Table 8c reports the construction time. Compact is always slower because of Equation (5), especially on JaWord of
1M patterns. To clarify the slowdown, we investigated vacant ids for which vacant searches were mostly unsuccessful
and found that the top-ï¬ve vacant ids could only accept the ï¬ve transition labels 0xC0, 0xCF, 0xD0, 0xD1, and 0xFF
to satisfy Equation (5). Because these labels did not appear or were very few in the dictionary, vacant searches for the
vacant ids were unsuccessful many times, resulting in the slow construction. Consequently, while the Compact format
does not produce a particularly high number of vacant ids, some of them can signiï¬cantly slow down vacant searches
when using Chain.

18

103104105106Number of patterns020040060080010001200Matching time (ms)EnWord, BytewiseIndividualPacked103104105106Number of patterns0250500750100012501500Matching time (ms)JaWord, BytewiseIndividualPacked103104105106Number of patterns0500100015002000250030003500Matching time (ms)JaChars, BytewiseIndividualPacked103104105106Number of patterns02468Number of cache missesÃ—106EnWord, BytewiseIndividualPacked103104105106Number of patterns0.00.20.40.60.81.01.2Number of cache missesÃ—107JaWord, BytewiseIndividualPacked103104105106Number of patterns02468Number of cache missesÃ—107JaChars, BytewiseIndividualPackedTable 8: Experimental results for the Basic and Compact formats. The memory usage is the total of BASE, CHECK,
FAIL, and OUTPOS. The last row in each table shows the diï¬€erent ratios for each result.

(a) Memory usage (KiB)

Format

Basic
Compact
Compact/Basic

1K
44.0
33.0
0.75

EnWord

10K
404
303
0.75

100K
3,712
2,784
0.75

JaWord

JaChars

1M
33,276
24,957
0.75

1K
48.0
36.0
0.75

10K
440
330
0.75

100K
4,780
3,585
0.75

1M
76,544
57,408
0.75

1K
32.0
24.0
0.75

10K
292
219
0.75

100K
2,908
2,181
0.75

1M
27,972
20,979
0.75

(b) Matching time (ms)

EnWord

Format

Basic
Compact
Compact/Basic

1K
523
545
1.04

10K
600
606
1.01

100K
696
712
1.02

1M
1,082
1,052
0.97

1K
447
473
1.06

JaWord

10K
632
633
1.00

100K
879
893
1.02

1M
1,234
1,226
0.99

1K
406
415
1.02

JaChars

10K
651
609
0.94

100K
1,038
1,028
0.99

1M
2,733
2,439
0.89

(c) Construction time (ms)

EnWord

Format

Basic
Compact
Compact/Basic

1K
0.11
0.14
1.25

10K
1.06
1.30
1.23

100K
19.2
23.5
1.22

1M
207
249
1.20

1K
0.13
0.14
1.09

JaWord
100K
22.4
32.7
1.46

10K
1.19
1.39
1.17

JaChars

1M
331
182,015
549

1K
0.08
0.09
1.09

10K
0.81
0.91
1.12

100K
14.8
16.0
1.08

1M
200
226
1.13

Table 9: The average number of veriï¬cations per vacant search when using Chain. The number of patterns in each
dictionary is one million.

Method
Bytewise + Basic
Bytewise + Compact
Mapped

EnWord

JaWord

JaChars

2.8
4.6
2.5

2.8
5383.3
84.4

6.6
7.4
4934.5

4.6 Analysis on acceleration techniques for vacant searches

We ï¬rst investigate problematic cases in DAAC construction when using Chain. Table 9 shows the average number
of veriï¬cations per vacant search when using Chain. In the combination of Bytewise and Basic, the number is always
several, indicating that it is hard to improve vacant searches further even using SkipForward or SkipDense. However,
the number is signiï¬cantly higher in the cases of (i) Compact on JaWord and (ii) Mapped on JaChars. Case (i) is
because of Equation (5), as discussed in Section 4.5. Case (ii) is because of many vacant ids, as discussed in Section
4.3.

We next test SkipForward and SkipDense to improve the two cases. We test parameters ğ¿ = 4, 8, 12, 16, 20, 24
in SkipForward and ğœ = 0.05, 0.1, 0.2, 0.3, 0.4, 0.5 in SkipDense. Figure 10a shows the experimental results for
the average number of veriï¬cations per vacant search. The left ï¬gure corresponds to case (i), where we can see
that SkipForward achieves several veriï¬cations with any parameter ğ¿ while maintaining similar vacant proportions.
SkipDense also achieves several veriï¬cations, although the vacant proportions increase depending on the parameter ğœ.
In the right ï¬gure corresponding to case (ii), both SkipForward and SkipDense achieve fewer veriï¬cations than Chain.
SkipForward and SkipDense plot similar curves, and their performances have no signiï¬cant diï¬€erence.

Figure 10b shows the experimental results for the construction times. The plots are similar to those in Figure 10a,
and both SkipForward and SkipDense achieve construction times within several seconds. These results indicate that we
should choose SkipForward or SkipDense in accordance with the desired purpose: if we want to control construction
times, SkipForward is best, and if we want to control memory usage, SkipDense is more suitable.

19

(a) The average number of veriï¬cations per vacant search

Figure 10: Experimental results for veriï¬cations and construction times when using Chain, SkipForward, or SkipDense.

(b) Construction time in seconds

20

020406080100Proportion of vacant elements (%)22242628210212Average number of verifications JaWord (Bytewise+Compact)ChainSkipForwardSkipDense020406080100Proportion of vacant elements (%)2829210211212Average number of verifications JaChars (Mapped)ChainSkipForwardSkipDense020406080100Proportion of vacant elements (%)20222426Construction time (sec)JaWord (Bytewise+Compact)ChainSkipForwardSkipDense020406080100Proportion of vacant elements (%)2120212223Construction time (sec)JaChars (Mapped)ChainSkipForwardSkipDenseFigure 11: Matching times in milliseconds for diï¬€erent traversal orders.

4.7 Analysis on traversal orders

Figure 11 shows the experimental results of matching times for LexBFS, FreqBFS, LexDFS, and FreqDFS presented in
Section 3.6. In the Bytewise scheme, we ï¬x the other settings to Forest, Packed, Compact, and SkipForward (ğ¿ = 16).
In the Mapped scheme, we ï¬x the other settings to Forest, Packed, and SkipForward (ğ¿ = 16).

We compare the DFS and BFS orders. DFS is faster than BFS for JaWord and JaChars in Bytewise. To investigate
the reason, we show the number of times states are visited in each depth during a pattern matching in Figure 12. As we
can see, deeper states are often visited for JaWord and JaChars in Bytewise. The number of L3 cache misses occurring
during a pattern matching is shown in Table 10, where we can see that DFS is cache-eï¬ƒcient in most cases. These
observations indicate that DFS enables cache-eï¬ƒcient traversals on deeper states and is suitable for long patterns.

Comparing Lex and Freq, there is no signiï¬cant diï¬€erence. Although we also tested other orders, such as a random
order, we did not observe any signiï¬cant diï¬€erences. The reason is explained by the average number of outgoing
transitions for an internal state reported in Table 6c. The average number is the average size of ğ¸ (â‰  âˆ…) in Algorithm
2. In all cases, the average number is several, indicating that the order to visit elements in ğ¸ is insigniï¬cant.

Figure 12: The number of visiting states at each depth during a pattern matching.

21

103104105106Number of patterns02004006008001000Matching time (ms)EnWord, BytewiseLexBFSLexDFSFreqBFSFreqDFS103104105106Number of patterns0200400600800100012001400Matching time (ms)JaWord, BytewiseLexBFSLexDFSFreqBFSFreqDFS103104105106Number of patterns050010001500200025003000Matching time (ms)JaChars, BytewiseLexBFSLexDFSFreqBFSFreqDFS103104105106Number of patterns020040060080010001200Matching time (ms)EnWord, MappedLexBFSLexDFSFreqBFSFreqDFS103104105106Number of patterns0200400600800Matching time (ms)JaWord, MappedLexBFSLexDFSFreqBFSFreqDFS103104105106Number of patterns02505007501000125015001750Matching time (ms)JaChars, MappedLexBFSLexDFSFreqBFSFreqDFS024681012141618Depth of visited state0.00.51.01.52.02.53.0#times of visiting statesÃ—107EnWord,BytewiseEnWord,MappedJaWord,BytewiseJaWord,MappedJaChars,BytewiseJaChars,MappedTable 10: The number of L3 cache misses occurring during a pattern matching with diï¬€erent traversal orders (Ã—103).
The number of patterns is ï¬xed to 106. The last row shows the diï¬€erent ratios for each result.

Order

LexBFS
LexDFS
LexDFS/LexBFS

EnWord

JaWord

JaChars

Bytewise

Mapped

Bytewise

Mapped

Bytewise

Mapped

2,485
2,303
0.93

2,967
2,888
0.97

4,301
3,209
0.75

3,157
2,944
0.93

31,999
28,804
0.90

17,719
17,917
1.01

4.8 Comparison with other AC automata

On the basis of the above experimental analyses, we determine the best combinations of techniques and develop a new
Rust library, called Daachorse, containing the following two variants:

â€¢ Bytewise-Daachorse = Forest + Bytewise + Packed + Compact + SkipForward (ğ¿ = 16) + LexDFS

â€¢ Charwise-Daachorse = Forest + Mapped + Packed + SkipForward (ğ¿ = 16) + LexDFS

We compare Daachorse with the Aho-corasick library [19], which is the most popular implementation of AC
automata in Rust. This library provides two types of implementations: NFA-AC is a standard AC automaton (as
described in Section 2.3), and DFA-AC is a deterministic ï¬nite automaton compiled from NFA-AC. DFA-AC is an option
for faster matching, although it consumes a huge amount of memory.

Figure 13 shows the comparison results. For the matching times reported in Figure 13a, Bytewise-Daachorse
is always the fastest on EnWord, and Charwise-Daachorse is always the fastest on JaWord and JaChars. Although
DFA-AC is also fast when the number of patterns is 103, its performance degrades as the number of patterns increases.
For the construction times reported in Figure 13b, NFA-AC is always the fastest, and Bytewise and Charwise-Daachorse
approach NFA-AC. DFA-AC is always the slowest because compiling from NFA-AC takes time. For the memory usages
reported in Figure 13c, Bytewise- and Charwise-Daachorse are often the smallest; however, when the number of
patterns is 103, Charwise-Daachorse is larger than NFA-AC because of the memory consumption of the mapping ğœ‹.

5 Application example: Japanese tokenization

Vaporetto [10], a supervised Japanese tokenizer written in Rust, is an application example of AC automata. Vaporetto
is an eï¬ƒcient implementation of the pointwise prediction algorithm [31] and leverages the AC algorithm in its feature
extraction phase. To demonstrate the ability of Daachorse, we integrated the Daachorse and Aho-corasick libraries
with Vaporetto and evaluated the tokenization speeds.

We conducted these experiments in the same environment as the experiments in Section 4. To train the Vaporetto
model, we used 60K sentences with manually annotated short-unit-word boundaries in BCCWJ (version 1.1) [30] and
667K unique words in UniDic (version 3.1.0) [11], while specifying default parameters in Vaporetto. We performed
tokenization for 5.9M sentences in BCCWJ that are not used for the training and then measured the running time.

The experimental result showed that:

â€¢ Bytewise-Daachorse performed in 3.3 microseconds per sentence,

â€¢ Charwise-Daachorse performed in 2.9 microseconds per sentence,

â€¢ NFA-AC performed in 7.5 microseconds per sentence, and

â€¢ DFA-AC performed in 7.3 microseconds per sentence.

Daachorse was at most 2.6Ã— faster than the Aho-corasick library. This result indicates that the time eï¬ƒciency of

the AC algorithm is critical in Vaporettoâ€™s tokenization, demonstrating the utility of our Daachorse.

22

(a) Matching time (ms)

(b) Construction time (ms)

(c) Memory usage (KiB)

Figure 13: Comparison results with the Daachorse and Aho-corasick libraries. (a) The matching time is plotted in a
linear scale because the time complexity is not linear over the number of patterns. (b) The construction time and (c)
the memory usage are plotted in a logarithmic scale because the complexities are linear over the number of patterns.

23

103104105106Number of patterns0500100015002000250030003500Matching time (ms)EnWordBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns01000200030004000Matching time (ms)JaWordBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns02000400060008000Matching time (ms)JaCharsBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns100101102103Construction time (ms)EnWordBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns100101102103104Construction time (ms)JaWordBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns100101102103Construction time (ms)JaCharsBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns102103104105106Memory usage (KiB)EnWordBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns102103104105106107Memory usage (KiB)JaWordBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC103104105106Number of patterns102103104105106Memory usage (KiB)JaCharsBytewise-DaachorseCharwise-DaachorseNFA-ACDFA-AC6 Related works

Double-array The two most popular implementations of DAACs are the Java library by hankcs [20] and the Go
library by Ruohang [40]. Both libraries are implemented in a similar manner and employ the same techniques: Simple
(although the memory layout is not identical), Charwise, Individual, SkipDense (ğœ = 0.05, without Chain and the block
partitioning), and LexBFS. As demonstrated in Section 4, these techniques do not provide the best performances in
most cases, and the implementations could be improved.

Some studies have represented the integers of BASE and CHECK in a compressed space other than Compact
(described in Section 3.4). Fuketa et al. [18] proposed partitioning one double-array structure into several smaller ones
to implement BASE and CHECK consisting of 2-byte integers; however, as this approach produces many structures for
a large trie, many pointers must be maintained to connect the structures. Fuketa et al. [17] proposed eliminating BASE
by introducing additional character mappings, although its applications are limited to ï¬xed-length keywords such as zip
codes. Kanda et al. [25, 26] proposed approaches to compress the integers of BASE and CHECK through diï¬€erential
encoding; however, time eï¬ƒciency can degrade because of more computations.

Another approach to compress the double-array is to employ compact trie forms. The minimal-preï¬x (MP) trie
[3, 13] is an often-used form [2, 26, 49], and various methods to eï¬ƒciently implement the MP-trie using the double-
array have been proposed [12, 24, 48, 50]. However, the MP-trie is specialized for dictionary lookups, which are done
by traversing a trie from the root to a leaf. Other compact forms such as double-tries [4] and directed acyclic word
graphs [47] cannot be applied to AC automata in principle.

Liu et al. [29] showed that double-array structures resulting from large alphabets (e.g., multibyte characters) can
include many vacant ids and are thus memory ineï¬ƒcient. They proposed several approaches to address this problem
and demonstrated that code mapping with the frequency of characters is eï¬€ective on Chinese strings. The eï¬ƒciency
of the code mapping was also demonstrated on ğ‘-gram sequences [36, 44].

Alternative trie representations Tries [16] have been studied since the 1960s, and there are many data structures
to represent. Since the AC automaton is a simple extension of the trie, we have many alternatives to the double-array.
The conventional data structures are a matrix form and a list form [6]. The matrix form uses a transition matrix of size
|ğ‘†| Ã— |Î£| and performs a transition lookup in ğ‘‚ (1) time, while consuming a large space of ğ‘‚ (|ğ‘†||Î£|). The list form
stores a set of transition labels from each state in a sorted array and performs a transition lookup by binary search in
ğ‘‚ (log |Î£|) time, while consuming a smaller space of ğ‘‚ (|ğ‘†|). The matrix and list forms have a time-space trade-oï¬€,
and the double-array harnesses both advantages by compressing the matrix form.

There are other data structures that utilize both advantages of the matrix and list forms. One is a hybrid approach that
uses the matrix form for states with many outgoing transitions and the list form for states with few outgoing transitions.
The aho-corasick library [19] employs the hybrid approach and is outperformed by Daachorse, as we demonstrated.
Another approach is hashing [6], which stores mappings from states to outgoing transitions in hash tables. This
approach can perform a transition lookup in ğ‘‚ (1) expected time while consuming ğ‘‚ (|ğ‘†|) space. However, searching
in the hash table often requires more computations than transition lookups in the double-array. Prior experiments [35]
demonstrated that DAACs outperformed AC automata with the hashing approach.

Compressed representations of tries have recently been proposed to store massive datasets in main memory.
Succinct tries [5] are representative data structures. Their memory usage achieves |ğ‘†| log2 |Î£| + ğ‘‚ (|ğ‘†|) bits of space
and is close to the information-theoretic lower bound [23]. However, the succinct tries employ many bit manipulations
in tree navigational operations, and their time eï¬ƒciency is not competitive with that of double-arrays [25, 26]. More
compressed data structures, such as XBW [14] and Elias-Fano tries [38, 39], also have similar time bottlenecks and are
not suited to design fast AC automata.

Compressed representations of AC automata Another line of research proposes data structures to represent AC
automata (i.e., transition, failure, and output functions) in a compressed space. Belazzougui [7] proposed the ï¬rst
compressed data structure that supports a matching in optimal ğ‘‚ (ğ‘› + ğ‘œğ‘ğ‘) time, while achieving |ğ‘†| log2 |Î£| + ğ‘‚ (|ğ‘†|)
bits of space. Hon et al. [21] achieved an entropy compressed space while matching time remains optimal. I et al. [22]
designed a matching algorithm working on grammar-based compressed AC automata. However, these studies were
accomplished through theoretical discussions, and we are unaware of any actual implementation.

24

7 Conclusion

In this paper, we provided a comprehensive description of implementation techniques in DAACs and experimentally
revealed the most eï¬ƒcient combinations of the techniques to achieve higher performance. We also designed a
data structure of DAACs and developed a new Rust library for faster multiple pattern matching, called Daachorse.
Our experiments showed that, compared to other implementations of AC automata, Daachorse oï¬€ered a superior
performance in terms of time and space eï¬ƒciency. As we demonstrated in the integration test with Vaporetto,
Daachorse has signiï¬cant potential to improve applications that employ multiple pattern matching. Our future work
will incorporate Daachorse in other applications to enable faster text processing.

Acknowledgement

We thank Shinsuke Mori for his cooperation and Keisuke Goto for his insightful review.

References

[1] Alfred V Aho and Margaret J Corasick. Eï¬ƒcient string matching: An aid to bibliographic search. Communications

of the ACM, 18(6):333â€“340, 1975.

[2] Junâ€™ichi Aoe. An eï¬ƒcient digital search algorithm by using a double-array structure. IEEE Transactions on

Software Engineering, 15(9):1066â€“1077, 1989.

[3] Junâ€™ichi Aoe, Katsushi Morimoto, and Takashi Sato. An eï¬ƒcient implementation of trie structures. Software:

Practice and Experience, 22(9):695â€“721, 1992.

[4] Junâ€™ichi Aoe, Katsushi Morimoto, Masami Shishibori, and Ki-Hong Park. A trie compaction algorithm for a

large set of keys. IEEE Transactions on Knowledge and Data Engineering, 8(3):476â€“491, 1996.

[5] Diego Arroyuelo, Rodrigo CÃ¡novas, Gonzalo Navarro, and Kunihiko Sadakane. Succinct trees in practice. In

Proceedings of the 12th Workshop on Algorithm Engineering and Experiments (ALENEX), pages 84â€“97, 2010.

[6] Nikolas Askitis. Eï¬ƒcient data structures for cache architectures. PhD thesis, RMIT University, 2007.

[7] Djamal Belazzougui. Succinct dictionary matching with no slowdown.

In Proceedings of the 21st Annual

Symposium on Combinatorial Pattern Matching (CPM), pages 88â€“100, 2010.

[8] Thorsten Brants and Alex Franz. Web 1T 5-gram Version 1. Linguistic Data Consortium, 2006.

[9] Brazil Inc. Groonga: An open-source fulltext search engine and column store (12.0.3). https://groonga.org/,

2022.

[10] daac-tools. Vaporetto: Very Accelerated POintwise pREdicTion based TOkenizer (0.4.0). https://github.com/

daac-tools/vaporetto, 2022.

[11] Yasuharu Den, Toshinobu Ogiso, Hideki Ogura, Atsushi Yamada, Nobuaki Minematsu, Kiyotaka Uchimoto, and
Hanae Koiso. The development of an electronic dictionary for morphological analysis and its application to
Japanese corpus linguistics (in japanese). Japanese linguistics, 22:101â€“123, 2007.

[12] Tshering C Dorji, El-sayed Atlam, Susumu Yata, Mahmoud Rokaya, Masao Fuketa, Kazuhiro Morita, and Junâ€™ichi
Information

Aoe. New methods for compression of MP double array by compact management of suï¬ƒxes.
Processing & Management, 46(5):502â€“513, 2010.

[13] John A Dundas. Implementing dynamic minimal-preï¬x tries. Software: Practice and Experience, 21(10):1027â€“

1040, 1991.

25

[14] Paolo Ferragina, Fabrizio Luccio, Giovanni Manzini, and S Muthukrishnan. Structuring labeled trees for optimal
succinctness, and beyond. In Proceedings of the 46th Annual IEEE Symposium on Foundations of Computer
Science (FOCS), pages 184â€“193, 2005.

[15] Paolo Ferragina and Gonzalo Navarro. Pizza&Chili Corpus. http://pizzachili.dcc.uchile.cl/texts.html, 2005.

[16] Edward Fredkin. Trie memory. Communications of the ACM, 3(9):490â€“499, 1960.

[17] Masao Fuketa, Hiroya Kitagawa, Takuki Ogawa, Kazuhiro Morita, and Jun-ichi Aoe. Compression of double
array structures for ï¬xed length keywords. Information processing & management, 50(5):796â€“806, 2014.

[18] Masao Fuketa, Kazuhiro Morita, Toru Sumitomo, Shinkaku KashÄ³i, Elsayed Atlam, and Jun-Ichi Aoe. A new
compression method of double array for compact dictionaries. International Journal of Computer Mathematics,
81(8):943â€“953, 2004.

[19] Andrew Gallant. aho-corasick: A fast implementation of Aho-Corasick in Rust (0.7.18). https://github.com/

BurntSushi/aho-corasick, 2021.

[20] hankcs. AhoCorasickDoubleArrayTrie: An extremely fast implementation of Aho Corasick algorithm based on

Double Array Trie (1.2.2). https://github.com/hankcs/AhoCorasickDoubleArrayTrie, 2020.

[21] Wing-Kai Hon, Tsung-Han Ku, Rahul Shah, Sharma V Thankachan, and Jeï¬€rey Scott Vitter. Faster compressed

dictionary matching. Theoretical Computer Science, 475:113â€“119, 2013.

[22] Tomohiro I, Takaaki Nishimoto, Shunsuke Inenaga, Hideo Bannai, and Masayuki Takeda. Compressed automata

for dictionary matching. Theoretical Computer Science, 578:30â€“41, 2015.

[23] Guy Jacobson. Space-eï¬ƒcient static trees and graphs. In Proceedings of the 30th IEEE Symposium on Foundations

of Computer Science (FOCS), pages 549â€“554, 1989.

[24] Shunsuke Kanda, Yuma Fujita, Kazuhiro Morita, and Masao Fuketa. Practical rearrangement methods for

dynamic double-array dictionaries. Software: Practice and Experience, 48(1):65â€“83, 2018.

[25] Shunsuke Kanda, Masao Fuketa, Kazuhiro Morita, and Junâ€™ichi Aoe. A compression method of double-array

structures using linear functions. Knowledge and Information Systems, 48(1):55â€“80, 2016.

[26] Shunsuke Kanda, Kazuhiro Morita, and Masao Fuketa. Compressed double-array tries for string dictionaries

supporting fast lookup. Knowledge and Information Systems, 51(3):1023â€“1042, 2017.

[27] Taku Kudo, Kaoru Yamamoto, and Yuji Matsumoto. Applying conditional random ï¬elds to Japanese morpho-
logical analysis. In Proceedings of the 2004 Conference on Empirical Methods in Natural Language Processing
(EMNLP), pages 230â€“237, 2004.

[28] Takuu Kudo. Darts: Double-ARray Trie System (0.32). http://chasen.org/~taku/software/darts/, 2008.

[29] Huidan Liu, Minghua Nuo, Long-Long Ma, Jian Wu, and Yeping He. Compression methods by code mapping
and code dividing for chinese dictionary stored in a double-array trie. In Proceedings of the 5th International
Joint Conference on Natural Language Processing (Ä²CNLP), pages 1189â€“1197, 2011.

[30] Kikuo Maekawa, Makoto Yamazaki, Toshinobu Ogiso, Takehiko Maruyama, Hideki Ogura, Wakako Kashino,
Hanae Koiso, Masaya Yamaguchi, Makiro Tanaka, and Yasuharu Den. Balanced corpus of contemporary written
Japanese. Language resources and evaluation, 48(2):345â€“371, jun 2014.

[31] Shinsuke Mori, Yosuke Nakata, Graham Neubig, and Tatsuya Kawahara. Morphological Analysis with Pointwise

Predictors (in Japanese). Journal of Natural Language Processing, 18(4):367â€“381, 2011.

[32] Kazuhiro Morita, Masao Fuketa, Yoshihiro Yamakawa, and Junâ€™ichi Aoe. Fast insertion methods of a double-array

structure. Software: Practice and Experience, 31(1):43â€“65, 2001.

26

[33] Gonzalo Navarro and Mathieu Raï¬ƒnot. Flexible pattern matching in strings: Practical on-line search algorithms

for texts and biological sequences. Cambridge university press, 2002.

[34] Graham Neubig, Yosuke Nakata, and Shinsuke Mori. Pointwise prediction for robust, adaptable Japanese
In Proceedings of the 49th Annual Meeting of the Association for Computational

morphological analysis.
Linguistics: Human Language Technologies, pages 529â€“533, 2011.

[35] Janne Nieminen and Pekka KilpelÃ¤inen. Eï¬ƒcient implementation of Ahoâ€“Corasick pattern matching automata

using unicode. Software: Practice and Experience, 37(6):669â€“690, 2007.

[36] Junâ€™ya Norimatsu, Makoto Yasuhara, Toru Tanaka, and Mikio Yamamoto. A fast and compact language model
implementation using double-array structures. ACM Transactions on Asian and Low-Resource Language Infor-
mation Processing, 15(4):27, 2016.

[37] Masaki Oono, El-Sayed Atlam, Masao Fuketa, Kazuhiro Morita, and Junâ€™ichi Aoe. A fast and compact elimination
method of empty elements from a double-array structure. Software: Practice and Experience, 33(13):1229â€“1249,
2003.

[38] Giulio Ermanno Pibiri and Rossano Venturini. Eï¬ƒcient data structures for massive n-gram datasets. In Proceed-
ings of the 40th International ACM SIGIR Conference on Research and Development in Information Retrieval,
pages 615â€“624, 2017.

[39] Giulio Ermanno Pibiri and Rossano Venturini. Handling massive N-gram datasets eï¬ƒciently. ACM Transactions

on Information Systems, 37(2), feb 2019.

[40] Feng Ruohang. ac: Aho-Corasick Automaton with Double Array Trie. https://github.com/Vonng/ac, 2019. The

latest version at May 24, 2022.

[41] Manabu Sassano. An empirical study of active learning with support vector machines for Japanese word
In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics

segmentation.
(ACL), pages 505â€“512, 2002.

[42] Hiroyuki Shinnou. Deterministic japanese word segmentation by decision list method. In Proceedings of the 6th

Paciï¬c Rim International Conference on Artiï¬cial Intelligence (PRICAI), pages 822â€“822, 2000.

[43] Xinying Song, Alex Salcianu, Yang Song, Dave Dopson, and Denny Zhou. Fast wordpiece tokenization. In
Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages
2089â€“2103, 2021.

[44] Makoto Yasuhara, Toru Tanaka, Jun ya Norimatsu, and Mikio Yamamoto. An eï¬ƒcient language model using
double-array structures. In Proceedings of the Conference on Empirical Methods in Natural Language Processing
(EMNLP), pages 222â€“232, 2013.

[45] Susumu Yata. Nihongo Web Corpus 2010 (NWC 2010). http://www.s-yata.jp/corpus/nwc2010/, 2010.

[46] Susumu Yata. A clone of Darts. https://github.com/s-yata/darts-clone, 2018. The latest version at May 24, 2022.

[47] Susumu Yata, Kazuhiro Morita, Masao Fuketa, and Junâ€™ichi Aoe. Fast string matching with space-eï¬ƒcient word
graphs. In Proceedings of the 4th International Conference on Innovations in Information Technology (IIT), pages
79â€“83, 2008.

[48] Susumu Yata, Masaki Oono, Kazuhiro Morita, Masao Fuketa, and Junâ€™ichi Aoe. An eï¬ƒcient deletion method for

a minimal preï¬x double array. Software: Practice and Experience, 37(5):523â€“534, 2007.

[49] Susumu Yata, Masaki Oono, Kazuhiro Morita, Masao Fuketa, Toru Sumitomo, and Junâ€™ichi Aoe. A compact
static double-array keeping character codes. Information Processing & Management, 43(1):237â€“247, 2007.

27

[50] Susumu Yata, Masaki Oono, Kazuhiro Morita, Toru Sumitomo, and Junâ€™ichi Aoe. Double-array compression
by pruning twin leaves and unifying common suï¬ƒxes. In Proceedings of the 1st International Conference on
Computing & Informatics (ICOCI), pages 1â€“4, 2006.

[51] Zhou Yihan. Meaningfulness and unit of Zipfâ€™s law: evidence from danmu comments. In Proceedings of the

20th Chinese National Conference on Computational Linguistics, pages 1046â€“1057, August 2021.

[52] Naoki Yoshinaga and Masaru Kitsuregawa. A self-adaptive classiï¬er for eï¬ƒcient text-stream processing.

In
Proceedings of the 24th International Conference on Computational Linguistics (COLING), pages 1091â€“1102,
2014.

28

