To What Extent Cognitive-Driven Development
Improves Code Readability?

Leonardo Barbosa
leonardopfb@gmail.com
UFPA
Bel√©m, PA, Brazil

2
2
0
2

n
u
J

1
2

]
E
S
.
s
c
[

1
v
5
5
6
0
1
.
6
0
2
2
:
v
i
X
r
a

Alberto Luiz Oliveira Tavares de Souza
alberto.tavares@zup.com.br
Zup Innovation
Bel√©m, PA, Brazil

ABSTRACT
Cognitive-Driven Development (CDD) is a coding design technique
that aims to reduce the cognitive effort that developers place in
understanding a given code unit (e.g., a class). By following CDD de-
sign practices, it is expected that the coding units to be smaller, and,
thus, easier to maintain and evolve. However, it is so far unknown
whether these smaller code units coded using CDD standards are,
indeed, easier to understand. In this work we aim to assess to what
extent CDD improves code readability. To achieve this goal, we
conducted a two-phase study. We start by inviting professional
software developers to vote (and justify their rationale) on the most
readable pair of code snippets (from a set of 10 pairs); one of the
pairs was coded using CDD practices. We received 133 answers.
In the second phase, we applied the state-of-the art readability
model on the 10-pairs of CDD-guided refactorings. We observed
some conflicting results. On the one hand, developers perceived
that seven (out of 10) CDD-guided refactorings were more readable
than their counterparts; for two other CDD-guided refactorings,
developers were undecided, while only in one of the CDD-guided
refactorings, developers preferred the original code snippet. On
the other hand, we noticed that only one CDD-guided refactorings
have better performance readability, assessed by state-of-the-art
readability models. Our results provide initial evidence that CDD
could be an interesting approach for software design.

CCS CONCEPTS
‚Ä¢ Software and its engineering ‚Üí Designing software.

KEYWORDS
readability, cognitive-driven development, cognitive load

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-XXXX-X/18/06. . . $15.00
https://doi.org/XXXXXXX.XXXXXXX

1

Victor Hugo Santiago
victor.santiago@ufpa.br
UFPA
Bel√©m, PA, Brazil

Gustavo Pinto
gustavo.pinto@zup.com.br
UFPA & Zup Innovation
Bel√©m, PA, Brazil

ACM Reference Format:
Leonardo Barbosa, Victor Hugo Santiago, Alberto Luiz Oliveira Tavares de
Souza, and Gustavo Pinto. 2022. To What Extent Cognitive-Driven Develop-
ment Improves Code Readability?. In Proceedings of Make sure to enter the
correct conference title from your rights confirmation emai (ESEM ‚Äô22). ACM,
New York, NY, USA, 11 pages. https://doi.org/XXXXXXX.XXXXXXX

1 INTRODUCTION
Cognitive-Driven Development (or CDD for short) is a novel coding
design technique that aims to reduce code complexity by limiting
the number of language constructs that could be used at once in a
given source code file [4, 18, 19]. CDD aims at developing strategies
that reduce the developer cognitive load.

Instead of being based on anecdotal experience, CDD has its
roots in two well-known psychology theories: the Magical Number
Seven Theory [13] and the Cognitive Load Theory (CLT) [22, 23].
In Miller‚Äôs work [13] known as ‚ÄúMagical Number Seven‚Äù, it is ex-
plained that we probably have a hard limitation in simultaneous
processing information. Experimental studies.[13] have suggested
that humans generally hold only seven plus or minus two informa-
tion units in short-term memory. CLT [22, 23], on the other hand,
explains that any material has an intrinsic complexity depending
on the amount and arrangement of the elements that compose it.
CLT is an instructional design theory that reflects our ‚Äúcognitive
architecture‚Äù, an important aspect to presenting information at a
pace that learners can fully understand. According to Sweller [22],
knowing the number of information elements and their interactivity
is crucial to support learners.

In terms of source code, it may not be a surprise that a high
number of information elements, e.g., control structures and lan-
guage constructs, can harden ones understanding. CDD focuses on
directing developers to create and maintain code units respecting
the limited human cognition capacity. Therefore, the more elements
are concentrated in the same code unit, the greater the effort devel-
opers will have to place to understand it. While the practice of CDD
could indeed ease software maintenance (since CDD-guided source
code uses less code elements), little is known whether the code that
was developed using CDD has also better readability. Therefore, the
goal of this work is to provide answers to the following research
questions:

RQ1. Do CDD-guided refactorings improves code readability, ac-

cording to professional software developers?

 
 
 
 
 
 
ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

Barbosa et al.

RQ2. Do CDD-guided refactorings improves code readability, ac-

cording to the state-of-the-art readability model?

To answer these questions, we performed a two-phase study. To
answer RQ1, in the first phase of this work we started by surveying
133 professional developers. We present to them 10 pairs of code
snippets (pre and pos CDD-guided refactorings) and ask our sub-
jects to vote on which code snippet they believe is more readable.
We also asked them to offer their rationale behind their vote. To
answer RQ2, in the second phase, we leverage the state-of-the-art
readability model proposed by Posnett et al. [20]. For each pair
of code, we studied whether the CDD-guided refactorings might
have, indeed, improved code readability. Among the 10 pairs of
code snippets evaluated, we observed that in seven of them, our
participants concur that the CDD-guided refactorings improved
readability (in two pairs the results were balanced, while in just
one the participants preferred the original code). However, when
performing the state-of-the-art readability model, we noticed a dif-
ferent figure. In this case, just one of the CDD-guided refactorings
was considered as more readable, according to the model. This work
makes the following contributions.

(1) We curated a set of 10 CDD-guided refactorings (along with
their original versions), created by professional software
developers;

(2) We conducted a survey with 133 professional software de-
velopers to assess their perception about the 10 pairs of code
snippets.

(3) We applied the state-of-the-art readability model in the 10

pairs of code snippets.

(4) We made available all data used in this research, to facilitate

further replication.

2 HOW DOES CDD WORK?
Complexity is part of the software and CDD recognizes that the
intrinsic load effects from code units are different for people. Sup-
pose we have two developers analyzing the same program. They
will likely disagree on the difficulty of understanding. Nonetheless,
when code needs to evolve, the difference in observed complexity
will likely impact the maintenance cost. CDD aims to create an
unified concept for intrinsic complexity for the code units.

The first step of the CDD approach is to define the ‚ÄúIntrinsic
Complexity Points‚Äù (ICPs) [4], which are the elements inside the
code that can affect the understanding according to their usage
frequency. Example of such elements are for instance: code branches
(if-else, loops, when, switch-case, do-while, try-catch and
etc.), functions as an argument, contextual coupling (i.e., coupling
with specific project classes), and inheritance. CDD is not limited
to those code elements, though. Indeed, developers can include
any other code elements, from SQL instructions, to annotations, to
assertions, etc. Any programming construct that the team consider
relevant can be considered as ICP.

After the selection of ICPs, a constraint should be defined for
all code units. CDD can contribute to a practical perspective of
what makes understanding compromised for a given context. For
example, how many if statements should I have in a given code
unit? As everyone is involved in creating the code, a complexity
limit can be defined collaboratively for the code units regardless

of the specialization degree of developers. Therefore, development
teams can adopt the CDD method according to their interest, the
project nature and experience, i.e., the cognitive complexity limit
needs to be customized; this is also true for the elements included
in this constraint. The main reward of this strategy is that the code
units can be kept under a limit even with the exponential growth
of the software complexity.

3 RESEARCH METHODOLOGY
This work was built upon the work of Pinto et al.[18] and Santos
and Gerosa [5]. Regarding the work of Pinto et al.[18], we relied
on the refactoring produced by developers from industry that took
part of the experiment (more in Section 3.1). After cleaning and
filtering representative refactoring examples, we adopted the survey
approach presented by Santos and Gerosa [5] to gather developers‚Äô
opinion on which code snippets have better readability (more in
Section 3.2). We though extend the Santos and Gerosa work by
applying the state-of-the-art readability model, proposed by Posnett
et al. [20] (more in Section 3.3).

3.1 Curating refactoring examples
Pinto et al. [18] carried out an experimental study to determine
whether refactoring using cognitive driven constraints leads to
better software than traditional style refactoring. The authors have
conducted the experiment in an industrial setup and evaluated
software quality via software quality metrics. Nonetheless, since
the industry participants performed several scattered changes, the
authors were unable to understand the impact of isolated CDD-
guided refactorings on code readability. We started by selecting
refactorings that were produced from this research. The authors
invited 18 industry participants to refactor three classes of two well-
known Java projects, namely SSP1 and feign2. The participants were
divided in two groups: the first group performed their refactorings
using their own intuition, whereas the second group followed a
disciplined CDD approach. To carry out their work, both groups
should meet the following requirements:

(1) The original project‚Äôs packages should not be modified;
(2) New packages should not be created during refactorings;
(3) Automated tests should continue working without changes,

and;

(4) Public, protected, or package private methods from original

class should not be modified.

Additionally, the participants in the CDD group had to adhere
with the following set of ICPs: code branches (i.e., if-else, loops,
when, switch/case, do-while blocks), exception handling (i.e.,
try-catch blocks), functions as an argument, and contextual cou-
pling. It is important to highlight that the participants of the CDD
group were free to define a feasible complexity constraint for the
code units based on possible ICPs. According to the authors, a sin-
gle recommendation to define this constraint is that it could be
equivalent to twice the number of ICPs chosen for accounting.

This group was encouraged to follow a progressive reduction
strategy of ICPs. For instance, such participants were trained to
manually identify the aforementioned set of ICPs in the classes to be

1https://github.com/Jasig/SSP
2https://github.com/OpenFeign/feign

2

To What Extent Cognitive-Driven Development Improves Code Readability?

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

restructured. After that, the participants had to refactor the classes
in order to reduce the total number of ICPs to satisfy the constraint
previously defined. According to the authors, their hypothesis was
that the CDD-guided refactorings could lead to more quality in
terms of static metrics. The authors though used CK metrics [3]
(namely CBO, LCOM, RFC and WMC) as a proxy of readability.

In this work we extend the work of Pinto et al. [18] by focusing on
understanding to readability of isolated CDD-guided refactorings.
We asked the authors their dataset, which they gently provided.
The tool named Meld 3 was adopted to compare files and visualize
the changes performed by the participants.

When we started visualizing the code changes, we quickly no-
ticed that not all code changes were performed following CDD
guidelines. For example, some changes were targeted to streamline
methods and remove code duplication. We then focused our search
on ‚Äúisolated CDD-guided refactorings‚Äù, that is, code changes that
we could assure that were guided by CDD. We used the following
approach to identify the ‚Äúisolated CDD-guided refactorings‚Äù:

(1) We searched for code changes that could match with the
CDD requirements employed. For example, if the changes
tried to reduce the if, for or try-catch statements, chances
are that they were guided by CDD;

(2) We sought to observe indications that an intrinsic complexity
constraint was defined to guide the refactorings. For example,
when the target classes for refactorings were changed and
the new classes were created following a clear definition for
a complexity limit considering the basic control structures
aforementioned;

(3) We focused on code changes that adhere with the seminal
refactoring definition: code changes that preserve external
behavior [16]. If the refactored source code introduced ad-
ditional code elements that could potentially change the
program‚Äôs behavior, we discarded that code change.

This process was independently performed by two researchers
and was revised by a third researcher. This process took about
six weeks. We limited the number of CDD-guided refactorings to
10 pairs, 20 at total (10 before and 10 after the refactoring). This
number is similar to the number of examples used in the work of
Santos and Gerosa [5], which chose 11 examples.

The selected pairs have are fairly small (on average, 25 lines of
code); more at Table 3). This is aligned with the goals of our work.
For our RQ1, we intended to ask developers about their perceptions
of each refactoring example ‚Äî and having a high number of ex-
amples would potentially tire the respondent (which in turn could
lead to survey dropouts). For RQ2, our applied model have better
performance for small code snippets (the authors conducted their
work with code snippets ranging from 4 to 11 lines of code; code
snippets with 200+ lines of code were all ranked as less readable.

3.2 Designing and Deploying the survey
Our survey design was inspired by the work of Santos and Gerosa [5].
In their work, the authors asked developers about their perceptions
regarding 10 pairs of code snippets. Since the authors were inter-
ested in visually assessing the pairs of code examples, they were not
not able to rely on tools such as Google Form or Survey Monkey,

3https://meldmerge.org/

3

because they do not offer such visual features. Instead, they opted
to built their own survey tool. The survey participants were mostly
composed by students (55 respondents), in addition to seven pro-
fessional developers. In the next, we discuss how our work differs
from theirs. Also, our survey was based on the recommendations of
Kitchenham et al.[10], we followed the phases prescribed: planning,
creating the questionnaire, defining the target audience, evaluating,
conducting the survey, and analyzing the results. We discuss each
one of these phases next.

Planing. We identified 12 representative refactoring examples.
However, as aforementioned, we had to discard two examples to
avoid occupying too much the participants. Therefore, we group the
refactoring examples into categories and discarded those from most
common categories. We ended up with 10 pairs of code snippets.
Moreover, we decided not to mention that the refactorings were
CDD-guided since this could lead to biases for (or against) CDD. In-
stead, we just asked the participant about their preference without
further information about the pairs of examples. We also decided
to randomly alternate the sides of the examples, otherwise partic-
ipants could naively favor one of the sides (left or right). Finally,
since readability is a subjective concept and that different factors
can influence code readability, before presenting to developers the
pairs of examples, we present to them our definition of readability:
‚ÄúReadability is a human judgment about the cognitive effort required
to understand a source code. Visual features such as spacing, inden-
tation, capitalization, function names, language constructs, among
others, can affect the readability and, thus, the understanding of a
code snippet.‚Äù. This definition is inspired by the works of Oliveira et
al [15], which describes that readability is ‚Äúwhat makes a program
easier or harder to read and apprehend by developers‚Äù.

Creating the questionnaire. In this work, we relied on TypeForm,
which is an online survey service that allows dynamic forms. Using
TypeForm, we were able to present developers with two images
and ask them their preference. We used this feature to present our
pairs of examples, as Figure 1 shows. Knowing that syntax highlight
could improve code comprehension [9], different than Santos and
Gerosa [5], we used the carbon.now.sh tool to create code snippets
with syntax highlight in dark mode (which offer better contrasts
to the figures). After the participant vote of their preferable code
snippet, we asked their rationale for this decision.

Our survey had 27 questions (25 were required, 12 were open).
We asked five demographic questions (Technical Profile {Developer,
QA, Manager, etc}, Technical Level {Novice, Intermediate, Senior,
Principal, etc}, Age { <20y, 21‚Äì30y, 31‚Äì40y, 41‚Äì50y, >50y }, Years
of experience { <1y, 1‚Äì5y, 6‚Äì10y, 10‚Äì15y, >15y }, Experience with
Java {1‚Äì10}). Since we had to separate the questions regarding
the refactorings preference from the developers rationale for their
choice, we ended up with 20 questions for the 10 refactorings. In the
end of the survey, we had two final open questions: one whether
the participant had any questions/comments regarding our study
and the other if she is interested in participating in a follow up
interview. The estimated time to complete the survey was 10‚Äì15
minutes.

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

Barbosa et al.

Table 1: Participants roles & programming experience.

Role

Population <1y

1‚Äì5y

6‚Äì10y

10‚Äì15y >15y

125
Development
Management
6
Testing & QA 1
1
Infrastructure

133

22
1
0
0

23

32
0
0
0

32

34
2
1
1

38

19
1
0
0

20

18
2
0
0

20

as novice developers, 45% are intermediate developers, and 33%
are senior developers. The remaining 13% play different roles, such
as Tech lead and C-level. As for their ages, 49% have between 21
and 30 years old, 38% have between 31 and 40 years old, 11% have
between 41 and 50 years old, and only 1.4% have more than 50
years old. As for their software development experience, 22% have
up to 1 year, 29% have between 2 to 5 years of experience, 23.3%
have between 6 and 10 years, another 12% have between 11 to 15
years, and 14% have more than 15 years of software development
experience. In a scale from 0 to 10, where 0 means no knowledge
at all and 10 means being an expert, our participants averaged 7.8
in Java programming (Figure 2).

Figure 2: Java Experience.

Analyzing the results. We performed both quantitative and qual-
itative analysis methods. For the quantitative method, we used the
Chi-Square (ùúí 2) statistical test. ùúí 2 is a nonparametric test (i.e., it
does not require normality). The test indicates whether our hypoth-
esis holds or not. We defined the ùõº level to the conventional level
of 0.05. For the qualitative method, one of the authors followed
qualitative coding techniques to categorize the respondents‚Äô per-
ception. This approach was performed by one author and revised
by another author. The most interesting observations are discussed
throughout Section 4 along with quotes from the survey. Among
similar observations, we chose to quote only the one we considered
the most representative for each case.

3.3 Applying Posnett et al. readability model
Although it is consensus that code readability is a subjective matter,
in the last decades, researchers have proposed several metrics, tools,
and models to assess code readability [1, 2, 8, 12, 20, 21].

In this work we leverage the model proposed by Posnett and
colleagues [20]. This model is a simplified mix of two other ap-
proaches: the Buse model [1] and the Hastead metrics [7]. Posnett

4

Figure 1: Most readable snippet selection screen.

Evaluating the survey. Before deploying the actual survey, we
conducted a pilot with professional software developers and re-
searchers. These developers and researchers were close personal
contact to the authors of this work. The goal of this pilot survey
was to assess the clarity of the questions and the quality of the
refactorings examples. The participants of this pilot survey were
instructed that their feedback regarding the questions and the code
snippets was more important than the answers themselves. After a
period of one week, we received 8 answers to the survey and a few
comments requesting clarifications. We applied the suggestions
and removed the 8 answers from the database.

Conducting the survey. After incorporating improvements sug-
gested in the pilot survey, we administered the actual survey. To do
this, we created two online questionnaires. The first questionnaire
was deployed at a large Brazilian software producing company,
while the other questionnaire was shared in two social platforms:
Twitter and LinkedIn.

For the first questionnaire, one of the author work as a researcher
in the company and had access to the company communication‚Äôs
channels. However, instead of sending the questionnaire to all ‚àº3.5k
company‚Äôs employees (which is against the company privacy cul-
ture), we shared the link of the questionnaire in the company‚Äôs gen-
eral Google space (similar to a Slack channel). Periodic reminders
were sent at that same Google space.

The second questionnaire that was shared in social networks
had exactly the same questions and options of the first one, but a
different URL address. We decided to have two questionnaires be-
cause we had to report the perception of the company‚Äôs employees.
Given the nature of the approach we used to invite participants, we
were unable to track the number of participants that received the
questionnaire. However, Typeform tracks the number of access to
the questionnaire. For instance, (255+328) participants opened the
questionnaire and (210+201) started filling the questionnaire. After
a period of two weeks, we received a total of 133 responses, 73 for
the first questionnaire (34.8% of completion rate), and 60 for the
second one (30% of completion rate). For both surveys, participation
was voluntary.

Target audience. The target audience of our work are profes-
sional software developers. Table 1 summarizes our participants
demographics. Regarding their seniority, 9% consider themselves

To What Extent Cognitive-Driven Development Improves Code Readability?

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

and colleagues proposed a simplification of these two other works
that consider only three variables: lines of code, volume, and entropy.
Volume and Entropy are two similar metrics. The author differs vol-
ume and entropy as the follows: ‚ÄúEntropy calculations depend on the
relative distribution of the tokens/characters in the code body under
consideration, with uniform distributions giving the highest entropy,
and highly skewed distributions yielding lower entropy; whereas vol-
ume attempts to determine the number of bits needed to represent all
operators and operands multiplied by the total number of tokens.‚Äù

To calculate the Posnett [20] model, we used the Java-based
implementation provided by Mendon√ßa and colleagues [11]. To run
the tool, we have to create the files for each code snippet (20 files
at total). According to the tool documentation, ‚ÄúThe content of the
file should be just a Java method body (and not an entire Java class)‚Äù.
If the source code contained a class definition, the tool raised an
exception and finished execution. This limitation might be due to
the fact that the seminal work of Posnett and colleagues [20] did not
include class definition in their evaluated code snippets. Therefore,
we could only calculate Posnett et al. readability model for methods
(more details in Section 4).

3.4 Dataset availability
In order to foster replications of our work, we made available all
data used in this research online at https://bit.ly/3LG0eIm. It in-
cludes 1) the curated sample of 10 pairs of code snippets, 2) the
online questionnaire, and 3) the answers anonymized. We encour-
age others to replicate our work.

4 RESULTS
We organize our results in terms of the research questions.

RQ1. Do CDD-guided refactorings improves code
readability, according to professional software
developers?
Table 2 presents the overview of our survey results. As one could
observe, for the majority of pairs, participants agreed that the CDD-
guided refactorings were more readable. In particular, P3, P10, P4,
P2, and P6 were fairly well-voted (they acquired 93%, 92%, 89%,
86%, and 80% of the votes, respectively). For two of the pairs (P1
and P7), we were unable to derive consensus. Finally, for only P5,
participants voted against CDD. The results for and against CDD
were statistically significant. Given this scenario, we were unable
to reject null hypothesis.

To better understand the reasons behind developers intuition
of readability, after presenting each pair, we asked their rationale
for their votes. We now present the results of the analysis of these
comments. We summarize their opinions for each pair next.

P1: Encapsulating error handling (50% / 50%). In this example,
the original code had a try-catch block handling the SendFailedException
exception. The CDD-refactored version of this code extracted the
exception handling responsibility and moved the try-catch block
into a new method called sendMessageToAdvisor. Figure 3 shows
this pair. We noted a remarkable similarity in the votes; 66 par-
ticipants preferred the original code, whereas other 66 preferred
CDD-guided version. When analyzing the comments of this pair,

5

public void method() {

final EarlyAlert saved = getDao().save(earlyAlert);
try {

sendMessageToAdvisor(saved, earlyAlert.getEmailCC());
} catch (final SendFailedException e) {
LOGGER.warn("Could not send Early Alert message to

advisor.", e);

throw new ValidationException("Early Alert was NOT

created.", e);

}

}

‚áì

public void method() {

final EarlyAlert saved = getDao().save(earlyAlert);

sendMessageToAdvisorService.sendMessageToAdvisor(

saved, earlyAlert.getEmailCC(), LOGGER);

}

Figure 3: P1: Encapsulating error handling

we noticed that developers that favored the original code have a
certain habit with this coding practice, as one respondent argued:
‚ÄúLogging with try-catch is so common that I didn‚Äôt even need to
read the code to understand the purpose.‚Äù. Another participant men-
tioned that ‚Äúthere is more visibility of the actions performed in the
code, what is being executed is more explicit." On the other hand, the
participants that favored the CDD-refactored version pointed out
that the refactored code is closed to plain English, as one respon-
dent mentioned: ‚Äúthe code is shorter and with a language closer to
the natural one‚Äù. Other respondents mentioned that the code has a
clear purpose: ‚Äúthe removal of try-catch avoids distraction from
the most important part of the code", and ‚ÄúIsolating error handling
within a method gives me a partial view, according to the responsibil-
ity of each method". The decoupling leaves the most important part
in the main code and therefore easier to understand, in addition to
the method created having a name well suited to its purpose makes
it easier to understand.

P2: Encapsulating business rules (14% / 86%). This pair is some-
how similar to P1, although com rather different developers‚Äô per-
ception. The original version had three ifs statements testing con-
ditions and raising an exception message if the conditions were met.
The refactored version encapsulated each condition into a specific
method, abstracting away the business logic. There were 19 votes in
favor of the original version. One of these respondents mentioned
that it is important to known which exception could be raise, while
another respondent did not see any value in creating an specific
validation class. On the other hand, the participants that favored the
CDD version pointed out that the refactored version is simpler and
intuitive. For instance, one respondent highlighted that the method
signature is clear and it makes it easy to understand its behavior",
whereas another respondent said that ‚ÄúThe second snippet, besides
being leaner, may represent an opportunity for code reuse". Indeed,
several participants that the CDD version creates room for code
reuse. Participants also highlighted the importance of the method

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

Barbosa et al.

Table 2: Received Votes per Code Snippet Pair.

Pairs

Short Description

Original CDD-guided % Original % CDD-guided

P1
P2
P3
P4
P5
P6
P7
P8
P9
P10

Encapsulating error handling
Encapsulating business rules
Concatenating logical expressions
Extracting class
Listing all imports
Encapsulating business rules
Asserting conditions
Functional checking style
Extracting class
Encapsulating for loops

67
19
9
14
45
27
60
95
44
10

66
114
124
119
88
106
73
38
89
123

50%
14%
7%
11%
34%
20%
45%
71%
33%
8%

50%
86%
93%
89%
66%
80%
55%
29%
67%
92%

ùúí 2

0.9309
0.0000
0.0000
0.0000
0.0001
0.0000
0.2596
0.0000
0.0000
0.0000

public EarlyAlert create(@NotNull final EarlyAlert

earlyAlert) {

if (earlyAlert.getPerson() == null) {

throw new ValidationException("Person is missing.");

}

if (earlyAlert.getCreatedBy() == null) {

throw new ValidationException("CreeatedBy is missing.");

}

if (earlyAlert.getCampus() == null) {

throw new ValidationException("Campus is missing.");

}

}

‚áì

public Map<String, Object> fillTemplateParameters(

@NotNull final EarlyAlert earlyAlert) {

EarlyAlertValidation.checkIsNull(earlyAlert);
EarlyAlertValidation.checkCreatedBy(earlyAlert);
EarlyAlertValidation.checkCampus(earlyAlert);

}

Figure 4: P2: Encapsulating business rules

signatures to be consistent with their operation, since it makes the
code much simpler and intuitive.

P3: Concatenating logical expressions (7% / 93%). In this prac-
tice, we present a method with four if statements (three nested
ones). In the CDD-version, the logical expressions of these four ifs
were grouped into a single if statement. A total of 124 participants
(93%) voted for the CDD version as the most readable one. One
CDD voter commented that this was the ‚ÄúClassic example of cy-
clomatic complexity. I couldn‚Äôt understand the example with several
nested if‚Äôs‚Äù. Other respondents also commented that the excessive
indentation of the nested ifs hinders readability. However, one
participant that voted in the original version brought an interesting
perspective: ‚Äúit is easier to debug the code when ifs are separated [...]
It also eases the use of InteliJ features such as ‚Äòevaluate expression‚Äô‚Äù.

6

P4: Extracting class (11% / 89%). In this practice, in the original
code, we presented the implementation of a Comparator abstract
class within the body method. On the other hand, in the CDD
version, we introduced a new class, MessageParamsComparator,
that implemented the Comparator behavior. The new class is ac-
cessed by using MessageParamsComparator::compare in the orig-
inal method. The vast majority of the voters (89%) favored the CDD
version. One CDD voter commented that ‚ÄúThe separation into a
new method, with a suitable name, makes the code more consistent
and easier to understand‚Äù. Another respondent commented that
the CDD version ‚ÄúDecreased cognitive complexity after extracting
business logic‚Äù, which is in sharp alignment with the CDD purpose.
Still, one CDD voter also highlighted the potential for code reuse:
‚ÄúBesides being more readable, it can be reusable‚Äù. Regarding the com-
ments in favor of the original code, one respondent mentioned that
‚ÄúIt‚Äôs the way I‚Äôm most used to do. But I consider it a ‚Äòless elegant‚Äô way‚Äù.
Other respondent thought that ‚Äúthe first option is clearer for those
who don‚Äôt know lambda functions‚Äù.

P5: Listing all imports (34% / 66%). Here we compared a code
snippet in which the imports are implicit (when we used (*) wild-
card to hidden classes of the same package) and another (the CDD
version) where the imports are explicit (when we listed all imports).
This question had some interesting comments. Most of voters fa-
voring the original code believed that the implicit imports bring
better readability because it uses fewer lines of code and, then, it
makes it easier to identify groups of imports. In this regard, re-
spondent mentioned that ‚ÄúThe shorter list is clearly more readable,
although it might be importing classes that will not be used.‚Äù. On the
other hand, developers that advocate in favor of the CDD design
argue that it is important to understand what is being imported, as
one respondent said: ‚ÄúDespite making the files more extensive, it is
preferable to import classes individually, since it eases their location
and understanding. Also, it does not import unnecessary things to the
code‚Äù. Some developers also mentioned that the explicit approach
eases code maintenance, since it reduces the chances of importing
the wrong class.

P6: Encapsulating business rules (34% / 66%). This is the same
kind of practice reported in P2. The original code had two con-
ditionals to check if an array is not empty and, if not, inserts
several elements at once in the array, using the addAll method.

To What Extent Cognitive-Driven Development Improves Code Readability?

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

The CDD approach encapsulated the two if statements into two
methods. Similar to the results of P2, in this practice, the major-
ity of the respondents (106 of them) also preferred the CDD ver-
sion. The reasons for (and against) CDD were also similar, as the
ones provided in P2. For instance, those that favored the CDD
approach commented that ‚ÄúThe reduction (or even encapsulation)
of ifs improves a lot the code readability‚Äù and ‚ÄúThe [newly intro-
duced] method‚Äôs name is self-explanatory‚Äù. One final interesting
observation was regarding the negation in the condition (i.e., if
(!requestTemplate.queries().isEmpty())), as one participant
highlighted: ‚ÄúThe negation used in the original condition increases
cognitive complexity and hinders the code‚Äôs understanding‚Äù.

public Request request() {
if (!this.resolved) {

throw new IllegalStateException("template has not been

resolved.");

}
return Request.create(method, url(), headers(), body,

this);

}

‚áì

public Request request() {

Asserts.booleanStateMustBeTrue(this.resolved, "template

has not been resolved.");

return Request.create(method, url(), headers(), body,

this);

}

Figure 5: P7: Asserting conditions

P7: Asserting conditions (45% / 55%). This practice is somewhat
similar to P2 and P6, in the sense that the if statement is encap-
sulated, but in here the CDD-approach used a native Java Assert
method to perform the comparison and throw the exception (if
needed). Developers were undecided, with a slight advantage for
the code refactored with CDD. Regarding the comments in favor
of the original code, one developer mentioned that the ‚ÄúAssert
methods are more conventional to testing code‚Äù. Another one said
that ‚ÄúThe if is simple, I don‚Äôt see the need to extract it into a separate
method". On the other hand, those that favored CDD commented,
once again, on the reuse opportunity (‚ÄúCode reuse is guaranteed".
Another respondent complemented that ‚ÄúThe assertion makes ex-
plicit the expected condition (and what will happen if it isn‚Äôt met).".

P8: Functional checking style (71% / 29%). Here we present a
validation using a ternary operator and the CDD-version that fol-
lowed a functional style using Optional. This was the only case in
which the original code was vastly preferred. Those that voted for
CDD mentioned that (‚ÄúReflects more the OO paradigm‚Äù) Regarding
the original code, developers commented that the map function
was brought too much complexity (‚ÄúThe ternary is an easy resource
and there was no complex logic to justify a .map‚Äù). One respondent
also mentioned that the ternary operator was of better use ‚Äúthan
chaining ifs statements‚Äù.

public String method() {

return (method != null) ? method.name() : null;

}

‚áì

public String method() {

return Optional.ofNullable(method)

.map(HttpMethod::name)
.orElse(null);

}

Figure 6: P8: Functional checking style

public String url() {

StringBuilder url = new StringBuilder(this.path());
if (!this.queries.isEmpty()) {
url.append(this.queryLine());

}
if (fragment != null) {
url.append(fragment);

}

return url.toString();

}

‚áì

public String url() {

return PathBuilder.withAllQueryParameters(this);

}
...
public class PathBuilder {
public static String

withAllQueryParameters(RequestTemplate
requestTemplate) {
StringBuilder url = new

StringBuilder(requestTemplate.path());

if (!requestTemplate.getQueriesTemplate().isEmpty()) {

url.append(requestTemplate.queryLine());

}
if (requestTemplate.getFragment().isPresent()) {

url.append(requestTemplate.getFragment().get());

}

return url.toString();

}

}

Figure 7: P9: Extracting class

P9: Extracting class (33% / 67%). This is the second occurrence of
this kind of pair. In here, the original code used a StringBuilder
and if statements to concatenate URL elements. The CDD version
moved the StringBuilder and the if statements into a newly in-
troduced class (called PathBuilder), and the URL is built using
PathBuilder.withAllQueryParameters(this) (Figure 7). The
results of the questionnaires showed a slight advantage for the
code refactored with CDD version (89/133 developers voted for this

7

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

Barbosa et al.

solution). One of the participants that favored the CDD version said
that this version ‚Äúencapsulates the logic, and makes it easier to read.
If necessary I enter the method to understand what it does.‚Äù. Interest-
ingly, one developer that favored the original code had the opposite
idea: ‚ÄúUnless there is PathBuilder reuse, the code in url() will end
up the same way inside the withAllQueryParameters method. The
developer, in a sense, will need to go inside this method to see what is
being done. It just increased one more layer to get to the code, since
the url() method wouldn‚Äôt have any other logic or flow."

P10: Encapsulating for loops (8% / 92%). In this final example,
the original code concatenated added elements into a list using
two for loops and one if statement, whereas the CDD version
abstracted the two fors by using one native method of the List
interface. Those in favor of the CDD approach mentioned that ‚ÄúEven
not knowing the whole API, just by the name of the method it is easy
to understand its purpose‚Äù and Concatenating lists makes more sense
and it is cleaner to use a lambda and an addAll than doing a for or
foreach. The idea is the same, we use less line, and, we don‚Äôt have to
maintain this piece of code‚Äù.

In general, when considering the 10 pairs of code snippets chosen
for this study it is possible to observe the influence of a cognitive
constraint on reducing the presence of ICPs in all refactored classes.
It is important to note that CDD focuses on improving code units,
i.e., the classes (in object-oriented languages) are the main struc-
tures to apply the CDD principles. For this reason, we do not count
in such code snippets the number of ICPs before and after refactor-
ings because we would need to consider the whole class. However,
this reduction can be perceived as if the CDD soft-forced the devel-
opers to restructure the classes to meet a satisfactory understanding
threshold.

RQ2. Do CDD-guided refactorings improves code
readability, according to the state-of-the-art
readability model?
In here we present our findings regarding our second research ques-
tion. Table 3 describes the results after applying Posnett model. In
this table there are some √ó symbols that indicate that we were un-
able to calculate the metric. This happened due to two reasons. First,
the pairs P4 and P9 moved part of the code to a newly introduced
class. As we mentioned in Section 3.3, the tool we used to calculate
Posnett model does not process an entire Java class, only method
bodies. Since P4 and P9 contains class declarations, we were unable
to run the tool on them. We were also unable to run the tool in P5
(which compares two approaches for listing imports), because Java
methods do not accept imports declarations.

This table shows a couple of interesting observations. First, we
could perceived that for 9 out of the 10 CDD-guided refactorings,
the CDD version had fewer lines of code, when compared to the
original version; on average, the CDD versions used 37% less lines
of code. The only exception is P5, which doubled the number of
lines of code used. This happened because the CDD version adopted
the explicit approach (which lists all imports), while the original
version used the implicit approach (which hide some of the imports),
using the asterisk (*) wildcard.

8

Table 3: The results of Posnett model. We calculate the num-
ber of lines of code (LOC column) using the wc UNIX tool
(considering blank lines). The symbol √ó indicates when it
was not possible to calculate it.

Pairs

LOC Before

LOC After

Posnett Before

Posnett After

P1
P2
P3
P4
P5
P6
P7
P8
P9
P10

9
13
16
16
5
12
5
2
10
9

5
6
11
16
10
7
3
2
10
5

0.0208
0.0013
0.1205
0.7029
√ó
0.0053
0.0192
0.0149
0.0066
0.0127

0.0174
0.0023
0.3368
√ó
√ó
0.0092
0.0304
0.0276
√ó
0.0253

Moreover, regarding the results of the Posnett model, we noticed
that CDD excelled in only one out of the seven pairs that we were
able to calculate the metric; P1, in that case (the model performance
was 0.0174, when compared to 0.0208 of the original version). For
the all other pairs of code snippets, the original version had better
performance then the CDD-guided refactorings. For this metric,
the lower the value, the better readability the code snippet has.

However, when taking a closer look at this result, we could ob-
serve that the model performance did not varied much between the
pairs of code snippets. For instance, for P1, P2, P6, P8, and P10, the
performance variation was less than ‚àº0.01. On the other hand, P3
and P7 showed a larger performance variation. For P3, in particular,
the CDD-guided refactorings combined four if statements into a
single if with several logical expressions. It is important to note
that the Posnett model is, in part, based on the diversity of the
code vocabulary, that is, the sum of unique operators and unique
operands. Since the CDD-refactored version reduced the number
of if statements, the operands were not reused anymore among
the if statements. This might have worsened its performance due
to the higher number of unique operators and operands.

5 DISCUSSIONS
Cognitive-Driven Development (CDD) is a coding technique that
aims to reduce code complexity by always aiming to reduce the
developer‚Äôs cognitive load. These strategies are not fixed and can
be adapted to each development team. The research in question
evaluates refactorings based on CDD. However, although most of
the practices are favorable to refactoring, we cannot affirm that
CDD by itself is responsible for improving readability. However,
it favors using other refactoring practices and good practices of
Object-Oriented Programming.

The P2 is evidenced in Figure 4, where the name of the method,
being self-explanatory, proved to be a very efficient practice, being
mentioned by approximately 30 of the 124 participants in favor of
the CDD approach. They highlighted in their comments that the
method‚Äôs name made all the difference in refactoring, making the
language very natural and easy to understand. On the other hand,
practice P2 (Figure 4) fostered reuse and was a point identified by

To What Extent Cognitive-Driven Development Improves Code Readability?

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

the research participants. Similarly, the use of stable classes such as
List and Assert favor the use of CDD as they naturally decrease
the number of ICPs. We also observed that CDD-inspired code
snippets are smaller than the original ones.

As a final observation, we noticed that CDD makes the code
more horizontally aligned. It happens because most of the refac-
torings in the code result in new methods or classes that, when
reaching a limit, continue to be modified to fit the human mind, i.e.,
a satisfactory understanding degree.

6 RELATED WORK
We group our works in terms of 1) empirical studies that aims to
assess code readability (Section 6.1) and 2) early work on CDD
(Section 6.2).

6.1 Assessing Code Readability
Several researches have been working on the topic of code read-
ability. While some proposed coding standards and conventions to
assess code readable, others related readability to the cognitive and
complexity metrics. We next discuss some of the closest works to
ours.

Empirical studies on code readability. Works evaluating the
readability of code snippets have already been done by researchers.
Gerosa et al. [5] conducted a survey with software developers eval-
uating coding convention patterns and showed that most of these
patterns positively influence the readability perceived by devel-
opers. A survey was conducted with 55 students of the software
engineering course of the Computer Science course and another
smaller group formed by 7 professional programmers of a large
Brazilian software company. Buse and Weimer‚Äôs [1] practices and
the Scalabrino‚Äôs model [21] were evaluated. At the end of the anal-
ysis it was identified that 8 out of 11 coding practices affected the
readability perceived by the research participants. In our study, 10
pairs of code snippets were chosen from a previous study involv-
ing refactorings based on CDD. Sivaprakasam et al. [8] provided a
tool to support their proposed method, which takes java methods
themselves as input and returns refactored, readable source code by
inserting blank lines after each block of valid code. Experimental
results of the research showed that the automatic insertion of blank
lines left the code with relevant lightness and a better understand-
ing of the snippet due to the standardized organization and spacing
of the parts with less cognitive load leaving the code more pleasant
to read.

Descriptive model for code readability In the study by Buse
and Weimer [1], readability was defined as the human understand-
ing of the ease of understanding a text and that the readability of
a program is related to its maintainability. The hypothesis of the
study is that programmers have some intuitive notion to point out
program features and characteristics that will be good indicators
for readability. With this, a descriptive model of software read-
ability based on programmers‚Äô opinions and notions of software
quality was presented. To construct the model Buse and Weimer
they conducted a study with 120 students of different levels of
coding experience, asking participants to provide subjective rating
scores of reading code snippets. A Survey was conducted where

9

each participant was given the same set of snippets. Participants
could select a number close to five for ‚Äúmost readable‚Äù snippets
or close to one for ‚Äúleast readable‚Äù snippets, with a score of three
indicating neutrality. The result of this study was a set of code
snippets accompanied by 12,000 evaluations on readability.

Posnett et al. [20] extended the Buse and Weimer‚Äôs model [1]
providing a simple and intuitive readability theory based on code
size and entropy. They also point out some details that may have
negatively influenced the Buse and Weimer model. They performed
an extraction of code snippets longer than 200 lines and compared
the two models addressed. As a result, it was possible to show that
the proposed model outperforms the Buse and Weimer model as a
readability classifier in small code snippets.

In 2018, Mannan et al. [24] used Posnett‚Äôs readability metric
to evaluate readability in large open-source projects. However,
the results found a very low correlation between source code bad
smells and readability. Considering the results and that Posnett‚Äôs
model was initially evaluated with small projects, Mannan et al.
concluded that there are deficiencies in current readability models
and therefore, there is a need to identify better metrics to evaluate
readability.

In 2018 Fakhoury et al.[6], explored the effect of poor source
code lexicon and readability on cognitive load as measured by a
state-of-the-art minimally invasive functional imaging technique
called functional near-infrared spectroscopy (fNIRS). The research
results evidenced a significant increase in participants‚Äô cognitive
load when anti-linguistic patterns and structural inconsistencies
were introduced to the source code; for passages considered more
readable, there was a decrease in cognitive load overload.

Programming language features and code elements In a work
by Mendon√ßa et al.[11], the impact of lambdas functions on JAVA
programmers‚Äô understanding is evaluated. There is a common un-
derstanding that code refactoring with lambdas functions, in ad-
dition to other potential benefits, simplifies code and improves
program understanding. A survey was carried out with 158 pairs of
code snippets extracted from GitHub. As a result of the work after
comparing with the Buse and Weimer model [1] and Posnett.[20] a
contradictory result was found, both models suggested that refac-
toring by lambda functions does not improve the understandability
of the source code, however in the qualitative result (survey) indi-
cated that the introduction of lambda expressions in legacy code
improves the understanding of the code in particular cases.

6.2 Early Work on CDD
Souza and Pinto [4] described the concepts that support the CDD.
Continuous expansion is part of the complex nature of software.
However, the understandability cannot follow in the same propor-
tion. The lack of a clear relationship between software complex-
ity and program comprehension contributes to the software not
evolving healthy. As a consequence, software developers spend
a considerable part of their time on program understanding [14].
Developers must know when to restructure the code and possibly
improve the separation of responsibilities. According to the authors,
when we do not have a well-defined rule for intrinsic complexity
for source code, it will be increasingly common to find classes that
contribute to a cognitive overload for developers.

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

Barbosa et al.

Pinto at al.[18] (detailed in 3.1) reached the conclusion that refac-
torings using conventional practices guided by a complexity con-
straint were better evaluated when they were compared with the
refactoring clusters (all classes created or modified) without such
rule.

Pereira at al. [17] provided a tool called ‚ÄúCognitive Load An-
alyzer‚Äù to support the CDD, a plugin for IntelliJ IDEA and Java
language. The intrinsic complexity of the code is calculated through
static analysis during programming, and the tool observes the limit
of complexity. When the complexity limit is reached for some code
unit, a notification is displayed to suggest possible refactorings.

In recent research, Pinto and Souza [19] evaluated the effects of
adopting a complexity constraint in the early stages of software
development. Three projects adopted by some companies for hir-
ing new software engineers were selected to be developed by 44
experienced developers, divided into Non-CDD and CDD groups.
Both groups were aware of the importance of quality metrics and
the need to produce high-quality code for other developers to un-
derstand. The CDD group received different training that included
practices guided by a cognitive complexity limit, including sugges-
tions for elements to set a constraint. The result suggested that
CDD can guide the developers to achieve lower dispersion for the
quality metric measures (CK metrics).

The concept of Cognitive-Driven Development opens the door
for extensive experimental research to measure the effectiveness
of this strategy regarding the measurement of complexity from
source code. Although most of the works discussed here involve the
program understanding, qualitative studies involving readability
criteria have not yet been carried out.

7 LIMITATIONS
As any empirical work, our also have limitations and threats to
validity.

First, we spent several weeks cleaning and filtering the data pro-
vided by Pinto and colleagues [18]. Despite our best efforts to find
representative CDD-guided refactorings (see details at Section 3.1),
we may not have selected a diverse set of code snippets. To mitigate
this threat, after grouping the code snippets into categories, we
sought to have at most two code snippets per category.

Some participants also pointed out that some of our examples
were very simple and, thus, not adequate. It is worth noting that
such simplicity was intentional to make the survey feasible and
less tiring. If we provide more complex examples that require more
cognitive effort, we could potentially discourage participants from
answering the survey. Still regarding the code snippets, manually
selecting and formatting the code snippets may have, in some way,
influenced the opinions of the participants. For example, by showing
the code snippet as an image instead of a text, we may have limited
the way our participants interacted with the examples (for instance,
there were not able to copy the code to their IDEs), negatively
influencing the opinions of some research participants.

Another limitation is regarding the way we present the code
snippets. In the daily development routine, developers rarely have
to spend time reading short methods without further navigation
and navigation. Therefore, our experiment hardly assembles the
real world development routine. We believe that experiments such

10

as this one could help researchers and tool builders create better
models that could, in turn, be used to guide developers in writing
software of better quality.

Finally, our data is based on the responses provided by 133 pro-
fessional software developers. Although these developers belong
to a group of great interest to our researcher, that is, professional
developers with extensive software development experience, these
developers pertain to a relatively restricted group of professional
programmers with experience in Java. Therefore, it is not possi-
ble to generalize the conclusions obtained to general groups of
programmers.

8 CONCLUSIONS
In this paper we evaluate the extent to which CDD improves code
readability. To achieve this goal, we conducted a two-phase study.
We conducted a survey with professional software developers in-
vited to vote (and justify their reasoning) for the most readable
pair of code snippets (out of a set of 10 pairs); one of the pairs
was coded using CDD practices. We received 133 responses. In the
second phase, we applied the state-of-the-art readability model to
the 10 pairs of CDD-guided refactorings. We observed some with
conflicting results.

The results allowed us to answer the research question RQ1, the
developers perceived that seven (out of 10) CDD-guided refactor-
ings were more readable than their counterparts; for two other
CDD-guided refactorings the developers were undecided, while for
only one of the CDD-guided refactorings did the developers prefer
the original code snippet. Regarding research question RQ2, we
note that only two CDD-driven refactorings show better readability,
as evaluated by state-of-the-art readability models [20].

We conclude that by following CDD design practices, coding
units are expected to be smaller and thus easier to maintain and
evolve and thus easier to understand. It is important to stress that
CDD only indicates a decrease in intrinsic Class complexity, so
other refactoring methods are combinatorial and favor readability
from CDD.Our results provide initial evidence that CDD may be
an interesting approach to software design.

As perspectives for future work, we can perform the analysis by
other readability methods and serve as a basis for their evolution,
because our results demonstrate sometimes conflicting positions
about some situations on the same piece of code and sometimes a
near unanimity in favor of a piece of code. This information can be
valuable to encourage other studies in the area.

REFERENCES
[1] Raymond PL Buse and Westley R Weimer. 2009. Learning a metric for code
readability. IEEE Transactions on software engineering 36, 4 (2009), 546‚Äì558.
[2] W. R. Edwards C. M. Chung and M. G. Yang. 2010. Static and Dynamic Data Flow

Metrics. In Policy and Information, Vol. 13. IEEE, 1‚Äì6.

[3] Shyam R Chidamber and Chris F Kemerer. 1994. A metrics suite for object
oriented design. IEEE Transactions on software engineering 20, 6 (1994), 476‚Äì493.
[4] Alberto Luiz Oliveira Tavares de Souza and Victor Hugo Santiago Costa Pinto.
2020. Toward a Definition of Cognitive-Driven Development. In IEEE Interna-
tional Conference on Software Maintenance and Evolution, ICSME 2020, Adelaide,
Australia, September 28 - October 2, 2020. IEEE, 776‚Äì778. https://doi.org/10.1109/
ICSME46990.2020.00087

[5] Rodrigo Magalh√£es dos Santos and Marco Aur√©lio Gerosa. 2018.

Impacts of
coding practices on readability. In Proceedings of the 26th Conference on Program
Comprehension, ICPC 2018, Gothenburg, Sweden, May 27-28, 2018, Foutse Khomh,
Chanchal K. Roy, and Janet Siegmund (Eds.). ACM, 277‚Äì285.

To What Extent Cognitive-Driven Development Improves Code Readability?

ESEM ‚Äô22, September 19‚Äì23, 2022, Helsinki, Finland

[6] Ma Y. Arnaoudova V. & Adesope-O. Fakhoury, S. 2018. The effect of poor source
code lexicon and readability on developers‚Äô cognitive load. In In Proceedings of
the 26th Conference on Program Comprehension - ICPC ‚Äô18 New York, New York,
USA: ACM Press. ACM, 286‚Äì296.

[7] Maurice H Halstead. 1977. Elements of Software Science (Operating and program-

ming systems series). Elsevier Science Inc.

[8] Christoph Hannebauer, Marc Hesenius, and Volker Gruhn. 2012. An accurate
model of software code readability. International Journal of Engineering Research
and Technology. ESRSA Publications 1, 6 (2012).

[9] Christoph Hannebauer, Marc Hesenius, and Volker Gruhn. 2018. Does syntax
highlighting help programming novices? Empirical Software Engineering 23, 5
(2018), 2795‚Äì2828.

[10] Barbara A Kitchenham and Shari L Pfleeger. 2008. Personal opinion surveys. In

Guide to advanced empirical software engineering. Springer, 63‚Äì92.

[11] Walter Lucas Monteiro Mendon√ßa, Jos√© Fortes, Francisco Vitor Lopes, Diego
Marc√≠lio, Rodrigo Bonif√°cio de Almeida, Edna Dias Canedo, Fernanda Lima, and
Jo√£o Saraiva. 2020. Understanding the Impact of Introducing Lambda Expressions
in Java Programs. Journal of Software Engineering Research and Development 8
(Oct. 2020), 7:1 ‚Äì 7:22. https://doi.org/10.5753/jserd.2020.744

[12] Keung J. Xiao Y. Mensah S.& Gao Y. Mi, Q. 2018. Improving code readability clas-
sification using convolutional neural networks. In Information and Software Tech-
nology,. 60‚Äì71. https://linkinghub.elsevier.com/retrieve/pii/S0950584918301496
[13] George A Miller. 1956. The magical number seven, plus or minus two: Some
limits on our capacity for processing information. Psychological review 63, 2
(1956), 81.

[14] Roberto Minelli, Andrea Mocci, and Michele Lanza. 2015. I know what you did
last summer-an investigation of how developers spend their time. In 2015 IEEE
23rd International Conference on Program Comprehension. IEEE, 25‚Äì35.

[15] Delano Oliveira, Reydne Bruno, Fernanda Madeiral, and Fernando Castor. 2020.
Evaluating Code Readability and Legibility: An Examination of Human-centric
Studies. In IEEE International Conference on Software Maintenance and Evolution,
ICSME 2020, Adelaide, Australia, September 28 - October 2, 2020. IEEE, 348‚Äì359.
https://doi.org/10.1109/ICSME46990.2020.00041

[16] William F Opdyke. 1990. Refactoring: An aid in designing application frameworks
and evolving object-oriented systems. In Proc. SOOPPA‚Äô90: Symposium on Object-
Oriented Programming Emphasizing Practical Applications.

[17] Jherson Haryson A. Pereira, Alberto Luiz Oliveira Tavares de Souza, and Victor
Hugo Santiago C. Pinto. 2021. Cognitive Load Analyzer: A Support Tool for
Cognitive-Driven Development. In SBES ‚Äô21: 35th Brazilian Symposium on Soft-
ware Engineering, Joinville, Santa Catarina, Brazil, 27 September 2021 - 1 October
2021, Cristiano D. Vasconcellos, Karina Girardi Roggia, Vanessa Collere, and
Paulo Bousfield (Eds.). ACM, 468‚Äì473. https://doi.org/10.1145/3474624.3476011
[18] Victor Hugo Santiago C. Pinto, Alberto Luiz Oliveira Tavares de Souza, Yuri
Matheus Barboza de Oliveira, and Danilo Monteiro Ribeiro. 2021. Cognitive-
Driven Development: Preliminary Results on Software Refactorings. In Proceed-
ings of the 16th International Conference on Evaluation of Novel Approaches to
Software Engineering, ENASE 2021, Online Streaming, April 26-27, 2021, Raian
Ali, Hermann Kaindl, and Leszek A. Maciaszek (Eds.). SCITEPRESS, 92‚Äì102.
https://doi.org/10.5220/0010408100920102

[19] Victor Hugo Santiago C. Pinto and Alberto Luiz Oliveira Tavares. 2022. Effects
of Cognitive-driven Development in the Early Stages of the Software Develop-
ment Life Cycle. In Proceedings of the 24th International Conference on Enterprise
Information Systems - Volume 2, Online Streaming, April 25-27, 2022. SCITEPRESS,
40‚Äì51.

[20] Daryl Posnett, Abram Hindle, and Premkumar T. Devanbu. 2011. A simpler
model of software readability. In Proceedings of the 8th International Working
Conference on Mining Software Repositories, MSR 2011 (Co-located with ICSE),
Waikiki, Honolulu, HI, USA, May 21-28, 2011, Proceedings, Arie van Deursen, Tao
Xie, and Thomas Zimmermann (Eds.). ACM, 73‚Äì82.

[21] C. Vendome M. Linares-Vasquez D. Poshyvanyk S. Scalabrino, G. Bavota and R.
Oliveto. 2010. Automatically assessing code understandability: How far are we?
in 32nd IEEE/ACM International Conference on Automated Software Engineering
(ASE) (2010), 417‚Äì427.

[22] John Sweller. 1988. Cognitive load during problem solving: Effects on learning.

Cognitive science 12, 2 (1988), 257‚Äì285.

[23] John Sweller. 2010. Cognitive load theory: Recent theoretical advances. (2010).
[24] I. Ahmed U. A. Mannan and A. Sarma. 2011. Towards understanding code
readability and its impact on design quality. In in Proceedings of the 4th ACM
SIGSOFT International Workshop on NLP for Software Engineering. IEEE, 18‚Äì21.
https://doi.org/10.1145/3283812.3283820

11

