2
2
0
2

n
u
J

1

]
P
S
.
s
s
e
e
[

1
v
8
7
7
0
0
.
6
0
2
2
:
v
i
X
r
a

Efﬁcient and Self-Recursive Delay Vandermonde Algorithm for
Multi-Beam Antenna Arrays

S. M. Perera*

A. Madanayake†

R. J. Cintra‡

Abstract

This paper presents a self-contained factorization for the delay Vandermonde matrix (DVM), which is
the super class of the discrete Fourier transform, using sparse and companion matrices. An efﬁcient DVM
algorithm is proposed to reduce the complexity of radio-frequency (RF) N-beam analog beamforming systems.
There exist applications for wideband multi-beam beamformers in wireless communication networks such as
5G/6G systems, system capacity can be improved by exploiting the improvement of the signal to noise ratio
(SNR) using coherent summation of propagating waves based on their directions of propagation. The presence
of a multitude of RF beams allows multiple independent wireless links to be established at high SNR, or
used in conjunction with multiple-input multiple-output (MIMO) wireless systems, with the overall goal of
improving system SNR and therefore capacity. To realize such multi-beam beamformers at acceptable analog
circuit complexities, we use sparse factorization of the DVM in order to derive a low arithmetic complexity
DVM algorithm. The paper also establishes an error bound and stability analysis of the proposed DVM
algorithm. The proposed efﬁcient DVM algorithm is aimed at implementation using analog realizations. For
purposes of evaluation, the algorithm can be realized using both digital hardware as well as software deﬁned
radio platforms.

Delay Vandermonde matrix, Efﬁcient algorithms, Self-recursive algorithms, Complexity and performance of algorithms,
Approximation algorithms, Wireless communications, Beamforming, Software deﬁned radio

Keywords

1 Introduction

The demand for wireless data communication networks having increased capacity and data transfer rates is

growing at a tremendous rate. The wireless networks are on the verge of rolling out their newest generation

of mobile networks; the so-called ﬁfth generation (5G) network, which is expected to be the underlying data

transfer network of emerging technologies such as the wireless internet of things (IoT), networks on chip,

body-area networks and cyberphysical systems (CPS). Exponentially growing demands for capacity require

exponentially growing bandwidth for a given SNR level. Emerging 5G and 6G wireless networks are built

on mm-wave (mmW) bands (typically, 20-600 GHz), which are of sufﬁciently high frequencies to allow the

necessary growth in system bandwidth. A 5G wireless data connection may operate around 60 GHz (indoors)

and operate at about 200-1000 MHz of bandwidth, which shows 10- to 25-fold growth in capacity [29]. Such

*S. M. Perera is with the Department of Mathematics, Embry-Riddle Aeronautical University, Daytona Beach, Florida 32114, USA

(e-mail: pereras2@erau.edu).

†A. Madanayake is with Department of Electrical and Computer Engineering, Florida International University, Miami, FL 33174,

USA (e-mail: amadanay@ﬁu.edu).

‡R. J. Cintra is with the Signal Processing Group, UFPE, Brazil (e-mail: rjdsc@de.ufpe.br).

1

 
 
 
 
 
 
levels of growth are typical of a new generation of wireless networks. In this paper, we address the problem of

obtaining a multitude of directional mmW RF beams using digital signal processing. The paper aims to reduce

to arithmetic complexity of the beamforming operation that is based on multiplication of a Vandermonde

matrix with an input vector obtained from the array of antennas. The proposed multi-beam signal processor

is uses a low-complexity algorithm that enables acceptable digital circuit complexity in order to achieve multi-

beam RF beams for a base-station.

The paper is organized as follows. Section 2 introduces the concept of wideband multi-beam beamforming

for wireless communications. Section 3 proposes a self-contained factorization for the DVM and an efﬁcient

DVM algorithm, while Section 4 contains the derivation of arithmetic complexity and elaborate numerical

results of the proposed DVM algorithm. Section 5 furnishes the derivation of a theoretical error bound, estab-

lishes numerical results, and addresses the numerical stability of the proposed DVM algorithm. In Section 6,

applications of the DVM matrix factorization in the engineering discipline will be discussed. Finally, Section 7

concludes the paper.

2 Multi-Beam Wideband Array Signal Processing

2.1 Review of Antenna Beamforming

The coherent combination of multiple antennas is known as beamforming [15, 30]. Fig.1 shows an overview

of an array processing receiver that operates on an N-element array of antennas by applying a spatial lin-
ear transform AN across the array outputs xk(t), k = 1, 2, · · · , N in continuous-time to produce a number of
continuous-time outputs yk(t) corresponding to the RF beams.

The linear transform typically takes the form of a spatial discrete Fourier transform, implemented via

spatial FFT, and leads to N number of RF beams corresponding to directions pertaining to spatial frequencies
of the incident waves that match DFT bin frequencies 2πk/N. The use of an FFT produces beams that have a

frequency dependent axis because it can be shown that the beam orientation is a function of wavelength.

By progressively delaying each antenna by a multiple of a constant time delay, the RF energy can be di-
rected in a particular direction in a frequency independent manner. For example, let X k(e jω) be the Fourier
transform of the input xk(t) for the array outputs k = 1, 2, · · · , N. The application of a linear delay of duration
τ causes a corresponding phase rotation by ωτ. In the frequency domain, the output of the delay becomes
X k(e jω)e− jωτ. The application of delays τkl to the kth antenna, where l ∈ (cid:90) is an integer causes signal com-
ponents to be rotated by the frequency dependent phase ωτkl. Delay and sum operations - described by

a Vandermonde matrix (DVM) by input vector product- leads to N RF beams that have beam orientations
ψk, k = 1, 2, · · · , N that have no dependence on the wavelength.

Example beamformers for arrays can be found in [2, 3, 17, 18, 26, 32, 39, 40, 43–45]. These systems are lim-

ited in number of beams, although they do possess relatively high numbers of antennas, due to the inherent

computational/circuit complexity of such multi-beam systems. Unlike DFT beamformers, delay-based Vander-

monde matrix multi-beam beamformers have frequency independent beam angles- a property that is desired

in wideband basestations.

2

Figure 1: A linear array with analog antenna outputs xk(t) for achieving N-beam wideband multi-beam beam-
former using left) an analog DVM circuit that realizes a spatial linear transform y = AN x employing true time
delay analog blocks for RF beams yk(t); and right) the digital signal ﬂow graph for a parallel digital hardware
or software deﬁned radio approach in which an M-point discrete Fourier transform (DFT) is computed along
the temporal dimension for binning the sampled wideband signals in temporal frequency domain. Each signal
component temporal frequency bin is applied to the DVM algorithm by computing the efﬁcient DVM algorithm
for M separate values of α = e− jωτ where ω = 2πm
M . In both cases, the DVM algorithm leads to N-beams by co-
herently combining radio waves in N discrete directions ψk = 1, 2, · · · , N. Here, temporal sample blocks consist
of M samples for the fast Fourier transforms (FFTs).

3

FFTFFTFFTFFTA/DA/DA/DA/DA/DA/DA/Dψkψky0(t)y1(t)yN−1(t)yyxxAnalogDVMFastAlgorithmy=ANxSoftwareDe(cid:28)nedRadioDigitalDVMFastAlgorithmy=ANxy0(e−j2πMm,∆TMn)y1(e−j2πMm,∆TMn)y2(e−j2πMm,∆TMn)x0(e−j2πMm,∆TMn)x1(e−j2πMm,∆TMn)x2(e−j2πMm,∆TMn)xN−1(e−j2πMm,∆TMn)mthFFTbinyN−1(e−j2πMm,∆TMn)SoftwareDe(cid:28)nedRadiox0(t)x1(t)x2(t)xN−1(t)x0(t)x1(t)x2(t)xN−1(t)2.2 Wideband N-Beam Algorithms

For a linear-array with inter-element spacing ∆x and speed of light c, the marginal time-difference of ar-
rival between antennas for direction ψ is τ = ∆x
c sin ψ. The kth true-time-delay RF beam can be real-
ized by coherently summing the antenna signals l = 0, 1, · · · , N − 1 such that the beam output is yk(t) =
x0(t) + x1(t − kτ) + · · · + x(t − k(N − 1)τ).

Assuming inter-element spacing ∆x = λmin/2, the N simultaneous RF beams in the discrete domain can
be written as the product of an N × N DVM containing the frequency-dependent phase-rotations and an input

signal vector with elements xk(t) consisting of the spatial signals from the uniform linear array of antennas.

The wideband multi-beam beamforming algorithm therefore consists of the computation of a DVM-vector
product y = AN x at time t ∈ (cid:82) where x and y are input and output vectors containing signals xk(t) and yk(t)
respectively. In our previous work [26], we have proposed a low-complexity DVM algorithm using the product

of complex 1-band upper and lower matrices. The DVM algorithm in [26] extends the results in [21, 22, 42]

utilizing complex nodes without considering quasiseparability and displacement equations as in [12, 13, 23].

Moreover, we have addressed error bounds and stability of the DVM algorithm in [26] by ﬁlling the gaps in [21,

22,42]. There are several mathematical techniques available to derive radix-2 and split-radix FFT algorithms,

as described in [5, 9, 16, 28, 33, 38]. On the other hand, among the known approximation algorithms which run

in quadratic arithmetic time to compute Vandermonde matrices by a vector, the author in [25] presented linear

arithmetic time approximation algorithm to compute Vandermonde matrices by vector. But our main intention

in this paper is to propose an exact algorithm with self-contained factors not an approximation algorithm.

Even though the derivation of size N DFT into two size N

2 DFTs can be done easily, the extension of this
idea to the DVM is cumbersome as the useful DFT properties are not necessarily present in the DVM case.

However, one could still derive an efﬁcient algorithm for the delay Vandermonde matrix as an polynomial

evaluation problem.

For wideband analog inputs where ω spans a continuous range of values, the phase rotations are to be

realized using analog delay lines. In analog realizations the DVM fast algorithm is realized in an analog

circuit consisting of wideband delays, ampliﬁers and adders. The low arithmetic complexity of the proposed

algorithms will result in correspondingly low circuit complexity for wideband analog multi-beam beamforming

circuits. For purposes of fast veriﬁcation using software models, the proposed DVM algorithms assumes a
particular input frequency (i.e., a constant ω) for the incident waves. Such a simpliﬁcation allows us to compute

the relevant matrix-vector product using a computer based numerical simulation model.

During software-based numerical veriﬁcation, we assume the input signals are over-sampled in time. This

is because all computer models much be discrete in time. For sampled digital signal processing systems, the
algorithms can be applied at a particular value of ω in the temporal frequency domain by ﬁrst computing

temporal FFTs for the antenna channels, and then applying the DVM algorithm for each bin of a tempo-

ral M-point DFTs. In such temporally-sampled software/digital implementations, each input xk(t) becomes
xk(e− j2πm/M, t), m = 0, 1, · · · , M − 1 and corresponding outputs yk(e− j2πm/M, t) where t = M∆T n for temporal
sample period T and M-point temporal FFT block number n. There needs to be M parallel digital circuits,

or M calls to the DVM algorithm in software realizations of the fast algorithm to process all of the temporal
frequency bins. There will be call to the DVM algorithm for each temporal FFT output bin at e− j2πm/M) in
order to support wideband operation, and therefore M number of calls to the algorithm in order to process

wideband signals transformed by M-point temporal FFTs. In our analysis, the code implementations assume

4

M = 1 because the aim is to numerically model the efﬁcient DVM algorithm.

The reported arithmetic complexities scale linearly with M for ﬁner temporal M-point DFTs. For notational

simplicity, we will simply use xk(t) and yk(t) for describing the efﬁcient DVM algorithm keeping in mind the
above mentioned details when considering analog circuit or software/digital implementations.

3 Self-Contained Factorizations and fast DVM Beamforming Algo-

rithm

The DVM AN = [e−τkl]N,N−1
k=1,l=0, is a Vandermonde structured matrix with complex entries. Here, we deﬁned
α ≡ e− jωτ for notational convenience. Recall τ = ∆x/c is a time delay. On the other hand, the DFT matrix is
also a well known Vandermonde structured matrix having Nth roots of unity as nodes. In contrast to the DFT,

however, the DVM does not necessarily possess nice properties, such as unitary, periodicity, symmetry, and

circular shift.

The DVM is deﬁned using distinct complex nodes α, α2, . . . , αN and hence it is non-singular. The matrix AN
k=0 . In the following, we will provide a

can be scaled as AN = ˜AN DN , where ˜AN = [αkl]N−1
self-contained sparse factorization for ˜AN followed by the DVM (i.e. AN ) over complex nodes α, α2, . . . , αN .

k,l=0 and DN = diag[αk]N−1

Lemma 3.1. Let
{1, α, α2, . . . , αN−1} ∈ (cid:67) and N = 2t (t ≥ 1). Then ˜AN,α can be factored into

scaled delay Vandermonde matrix

the

˜AN,α = [αkl]N−1

k,l=0 be deﬁned by nodes

˜AN,α = PT
N





˜A N

2 ,α2













I N
2

˜D N

2

C

α N

2 C









,

N
2
N
2

N
2
N
2

˜D N

2

˜A N

2 ,α2

(1)

where PN is the even-odd permutation matrix, ˜A N
and C N
2

2 ,α2 = (cid:163)α2kl(cid:164) N
= diag[αl]
is the companion matrix deﬁned by the monic polynomial p(z) = (z − 1)(z − α2)(z − α4) · · · (z − αN−2)

is the identity matrix, ˜D N

−1
k,l=0, I N

2

2

2

N
2

−1
l=0 ,

Proof: We show (1) by divide-and-conquer technique. We ﬁrst permute rows of ˜AN by multiplying with PN
and then write the result as the block matrices:

PN ˜AN,α =








(cid:163)α2kl(cid:164) N

−1
2
k,l=0

(cid:183)

(cid:179) N
2

+l

α2k

(cid:180)(cid:184) N
2

−1

(cid:163)α(2k+1)l(cid:164) N

−1
2
k,l=0

(cid:183)
α(2k+1)

(cid:179) N
2

+l

k,l=0
(cid:180)(cid:184) N
2

−1

k,l=0









(2)

Now, we consider (1,2), (2,1), and (2,2) blocks of PN ˜AN,α (2) and represent each of these by ˜A N
product of diagonal matrices.

2 ,α2 and the

For (1,2) block of (2) we get:

(cid:183)
α2k

(cid:179) N
2

+l

(cid:180)(cid:184) N
2

−1

k,l=0

= diag(αkN )

N
−1
2
k=0

(cid:104)

·

5

α2kl(cid:105) N

−1

2
k,l=0

.

(3)

For (2,1) block of (2) we get:

(cid:104)

For (2,2) block of (2) we get:

α(2k+1)l(cid:105) N

−1

2
k,l=0

(cid:104)

=

α2kl(cid:105) N

−1

2
k,l=0

· diag(αl)

N
2

−1
l=0 .

(4)

(5)

(cid:183)
α(2k+1)

(cid:179) N
2

+l

(cid:180)(cid:184) N
2

−1

k,l=0

= α N

2 diag(αkN )

(cid:104)

N
−1
2
k=0

α2kl(cid:105) N

−1

2
k,l=0

diag(αl)

N
2

−1
l=0 .

Thus by (3), (4), and (5) we can state (2) as:

PN ˜AN,α =







˜A N

2 ,α2

ˆD N

2

˜A N

2 ,α2

˜A N

2 ,α2

˜D N

2

α N

2 ˆD N

2

˜A N

2 ,α2

˜D N

2







,

= diag(αkN )

where ˆD N
where wi ∈ (cid:67). The following equality holds

−1
k=0 and ˜D N

= diag(αl)

2

2

N
2

N
2

−1
l=0 .Set p(z) = (z−1)(z−α2)(z−α4) · · · (z−αN−2) = z

N
2 +(cid:80)

N
2

−1

i=0 wi ·zi

˜A N

2 ,α2 C N

2

= ˘D N

2

˜A N

2 ,α2 ,

where

=

C N
2













0 0 · · ·
1 0 · · ·
0 1 · · ·
...
...
. . .
0 0 · · ·

0

0

−w0
−w1
−w2
0
...
...
1 −w N
2

−1

(6)

(7)













is the companion matrix of the polynomial p(z) with coefﬁcients wi(i = 0, 1, · · · , N
2
By using (6), non-singularity of ˜A N
2 ,α2 , and induction on N, one can easily show

− 1) and ˘D N

2

= diag(α2k)

N
2

−1
k=0 .

˜A N

2 ,α2 C

N
2
N
2

= ˘D

N
2
N
2

˜A N

2 ,α2

for any even number N. Note that, ˘D

N
2
N
2

= ˆD N

2

. Thus

PN ˜AN,α =









˜A N

2 ,α2

˜A N

2 ,α2

˜D N

2

and we get the result.

˜A N

2 ,α2 C

N
2
N
2

α N

2 ,α2 ˜A N

2 ,α2 C

N
2
N
2

˜D N

2









(8)

(cid:228)

Corollary 3.2. Let the delay Vandermonde matrix AN,α = [αkl]N,N−1

k=1,l=0 be deﬁned by nodes {α, α2, · · · , αN } and

6

N = 2t(t ≥ 1). Then the DVM can be factored into

AN,α = PT
N













A N

2 ,α2

I N
2

˜D N

2

where A N

2 ,α2 = [α2kl]

N

−1

2 , N
k=1,l=0 and ¯D N

2

2

= diag

(cid:104) 1
α2k

−1

(cid:105) N
2
k=0

.





¯D N

2





¯D N

2





A N

2 ,α2
N
2
N
2

C

α N

2 C

N
2
N
2

˜D N

2









DN

(9)

(cid:228)

.

Proof: This can easily be seen through the scaling of (1) by DN and ¯D N
Note that in order to compute the companion matrix C N
2

2

p(z) = (z − 1)(z − α2)(z − α4) · · · (z − αN−2) = z

N
2 + (cid:80)

(z − α2k)p(k)

N
2

for k = 0, 1, . . . , N
2

− 1. Then take p

( N
2 )
N
2

we have to compute the coefﬁcients of the polynomial

N
2

−1
i=0 wi · zi. One can do this by setting p(0)

(z) = 1 and p(k+1)

N
2

=

N
2

(z) which is p(z). The following lemma gives this procedure.

Lemma 3.3. Let N be an even number, W = {1, z2, z4, · · · , zN−2}, and q(z) = (cid:80)k
the coefﬁcients of z2 · q(z) = (cid:80)k+1

i=1 wi · z2i can be computed by

i=1 vi · z2i, where k ≤ N

2

















w0
...
wk+1
0
...
0





















=

Z

e N
2

−1





−1

O N
2
0

































v0
...
vk
0
...
0

− 2. Then

(10)















0

1

0

0

· · ·

0

where Z =

0
1
...
. . .
0 · · ·
= zeros (cid:161) N
2

0
. . .
0
− 1, 1(cid:162)

O N
2

−1

0

. . .
. . .
1















0
...
...

0

0

is the lower shift matrix of size (cid:161) N
2

− 1(cid:162)×(cid:161) N
2

− 1(cid:162), e N

2

−1

(cid:104)

=

zeros (cid:161)1, N
2

(cid:105)
− 2(cid:162) 1

,

Proof: It is obvious that polynomials in W satisfy the recurrence relation zk = z2 · zk−1 for k = 1, 2, · · · , N
2
with z0 = 1. By matrix multiplication we can easily get:

− 1

z2 (cid:104)

1

z2

z4

· · ·

zN−2(cid:105)

(cid:104)

1

−

z2

z4

· · ·

(cid:104)

=

0 · · ·

0

zN (cid:105)

zN−2(cid:105)





Z

e N
2

−1





−1

O N
2
0

7

(11)

(cid:228)
Multiplying (11) by the column of the coefﬁcients we get the result.
Lemma 3.3 can be used to compute the coefﬁcients of the polynomial p(z) = (z −1)(z − α2)(z − α4) · · · (z − αN−2) =

N
2 +(cid:80)

z

N
2

−1

i=0 wi ·zi efﬁciently. Hence the companion matrix C N

2

can be computed efﬁciently using the Lemma 3.3.

To compute the self-contained DVM factorization, ﬁrst we calculate the powers of the companion matrix.
N
2
N
2

We will use the following result for the calculation of C

.

Corollary 3.4. Let N = 2t(t ≥ 2), m = 2k(k ≥ 2), and C N
2

=

puted via

for 2 ≤ m ≤ N

2 , where wi for i = 0, 1, · · · , N

2

= C

Cm

N
2

m
2
N
2

· C

m
2
N
2

,

− 1 are computed as in Lemma 3.3.

Proof: One can easily use induction for k ≥ 2 to show (12).













0 0 · · ·
1 0 · · ·
0 1 · · ·
...
...
. . .
0 0 · · ·

0

0

−w0
−w1
−w2
0
...
...
1 −w N
2

−1



. Then C











N
2
N
2

can be com-

(12)

(cid:228)

Remark 3.5. Although the factorization for the DVM can be stated as in Corollary 3.2, we should recall here

that the classical Vandermonde matrix V is extremely ill-conditioned and in fact the condition number of the

matrix V grows exponentially with the size [11, 24, 37]. In this paper, we will study how bad the complex

structured DVM can be in terms of the choices for nodes in Section 5.

We will ﬁrst state the following algorithm based on Lemma 3.3 to compute the coefﬁcients of the polynomial

p(z) = (z − 1)(z − α2)(z − α4) · · · (z − αN−2)

= z

N
2 +

N
−1
2
(cid:88)

i=0

wi · zi.

(13)

Later, the coefﬁcients of p(z) will be used to construct the companion matrix C N
2

deﬁned in (7).

Algorithm 3.6. (com(N, α))
Input: Even N, and α ∈ (cid:67)

1. Set

(cid:104)

w(0)
0

w(0)
1

2. For k = 1 : N1 − 1,

· · · w(0)

N
2

−1

(cid:105)

(cid:104)

=

1 0 · · ·

(cid:105)

0



















w(k)
0
w(k)
1
...
w(k)

N1−1

(cid:195)(cid:34)

=

Z

eN1−1

ON1−1
0

(cid:35)

(cid:33)

− α2(k−1) · I



















w(k−1)
0
w(k−1)
1
...
w(k−1)
N1−1

8

(cid:104)

3. Take

w0 w1

· · · wN1−1

(cid:105)

(cid:104)

=

w(N1−1)
0

w(N1−1)
1

· · · w(N1−1)
N1−1

(cid:105)

Output: Coefﬁcients of p(z) (except the leading coefﬁcient as p(z) is monic) i.e. {w0, w1, w2, · · · , wN1−1} satisfying
13.

We will use the output of algorithm 3.6 (i.e. com(N, α)) to construct the companion matrix CN1 (7). Fol-
lowing the self-contained DVM factorization (9), one has to compute the powers of the companion matrix CN1
(7). Corollary 3.4 suggests the following algorithm to compute Cm
N1

for 2 ≤ m ≤ N1, where m = 2t1 (t1 ≥ 1).

Algorithm 3.7. (comp(N, α))
Input: N = 2t(≥ 1), N1 = N

2 , and α ∈ (cid:67)

1. Set w =

(cid:104)

w0 w1

· · · wN1−1

(cid:105)

and CN1

=

(cid:34) (cid:34)

(cid:35)

Z

eN1−1

(cid:35)

−w

2. for m = 2 : N1
= C
C

m
2
N1

m
2
N1

Cm
N1
end

Output: CN1
N1

.

comp(N, α)) to construct

˜CN s.t.

˜CN =

We will use the output of the Algorithm 3.7 (i.e.
IN1



CN1
N1











˜DN1

αN1 CN1
N1

˜DN1

for all N ≥ 4. The self-contained factorization for the scaled DVM i.e. Lemma 3.1

together with algorithms 3.6 and 3.7 lead us to establish a recursive radix-2 scaled DVM algorithm to compute
˜AN,α = [αkl]N−1

k,l=0 as stated next.

Algorithm 3.8. (sdvm(N, α, z))
Input: N = 2t(t ≥ 1), N1 = N

2 , α ∈ (cid:67), and z ∈ (cid:82)n or (cid:67)n.

1. Set ˜CN .

2. If N = 2, then
(cid:34)
1
1
1 α

y =

z.

(cid:35)

3. If N ≥ 4, then
u := ˜CN z,
v1 := sdvm

(cid:179)

v2 := sdvm

(cid:179)

(cid:180)

N1, α2, [ui]N1−1
i=0
(cid:180)
N1, α2, [ui]N
,

,

i=N1

y := PT
N

(cid:161)v1T , v2T (cid:162)T

.

Output: y = ˜AN,αz.

Remark 3.9. Recall that the delay Vandermonde matrix (i.e. AN,α) and scaled delay Vandermonde matrix (i.e.
˜AN,α) is related via AN,α = ˜AN,α · DN , where DN = diag(αk)N−1
k=0 . Thus, once the algorithm 3.8 is executed, we
can scale the output of the algorithm by DN to obtain a DVM algorithm. Although the computational cost of
the DVM algorithm reduces in this fashion, the resulting DVM algorithm won’t be self-recursive.

9

In the following we will state a recursive radix-2 DVM algorithm with the help of Corollary 3.2, algo-

(cid:34) ¯DN1

(cid:35)

for all N ≥ 4.

¯DN1

rithms 3.6, and 3.7. For notation convenience, we deﬁne ¯¯DN =

Algorithm 3.10. (dvm(N, α, z))
Input: N = 2t(t ≥ 1), N1 = N

2 , α ∈ (cid:67), and z ∈ (cid:82)n or (cid:67)n.

1. Set DN , ˜CN , and ¯¯DN .

2. If N = 2, then
(cid:35)
(cid:34)

y =

1 α
1 α2

z.

3. If N ≥ 4, then
u := DN z,
v := ˜CN u,
r := ¯¯DNv,
s1 := dvm

(cid:179)

s2 := dvm

(cid:179)

(cid:180)
,

N1, α2, [r i]N1−1
i=0
(cid:180)
N1, α2, [r i]N

i=N1

,

y := PT
N

(cid:161)s1T , s2T (cid:162)T

.

Output: y = AN,αz.

4 Complexity of DVM Algorithms

The number of additions and multiplications required to carry out a computation is called the arithmetic

complexity. In this section the arithmetic complexities of the proposed self-recursive scaled DVM and DVM

algorithms are established.

4.1 Arithmetic Complexity of DVM Algorithms

Here we analyze the arithmetic complexity of the self-recursive scaled DVM and DVM algorithms presented

in Section 3. Let #a and #m denote the number of complex additions and complex multiplications, respectively,
required to compute y = ˜AN,αz or y = AN,αz for scaled DVM and DVM. Note that we do not count multiplication
by ±1, ±

−1, and permutation.

(cid:112)

Lemma 4.1. Let N = 2t(t ≥ 2) be given. The arithmetic complexity on computing the scaled DVM algorithm 3.8

is given by

#a(sDV M, N) =

#m(sDV M, N) =

1
2
3
2

(cid:161)N t + 4t − N(cid:162) ,

N t +

1
2

4t − 2N.

Proof: Referring to the sdvm(N, α, z) algorithm, we get

#a(sDVM, N) = 2 · #a

(cid:181)
sDVM,

(cid:182)

N
2

+ #a (cid:161) ˜CN

(cid:162) .

10

(14)

(15)

N
The matrix ˜C is constructed using ˜D and C
2 . Moreover, to compute the powers of the Companion matrix
N
2 we have used the divide-and-conquer technique via algorithm comp(N, α). Since m = 2t in algorithm
C
comp(N, α), by solving a homogeneous ﬁrst order linear difference equation with respect to t(t ≥ 1) (i.e. for m =
2t(t ≥ 1) solving #a/#m (cid:161)Cm, 2t(cid:162) − 2 · #a/#m (cid:161)Cm, 2t−1(cid:162) = 0 with initial condition #a (Cm, 2) = m − 1 or #m (Cm, 2) =
m respectively), we could obtain #a (Cm) = m2
2 . This fact together with the construction
2
of ˜C using ˜D and C

2 and #m (Cm) = m2

2 , and m = N

− m

N

2 gives us:

#a (cid:161) ˜CN

(cid:162) = N2
4

+ N

2 , #m (cid:161) ˜CN

(cid:162) = N2
4

+ 3N
2

(16)

Using the above result we can write (15) as

#a(sDVM, N) = 2 · #a

(cid:181)
sDVM,

(cid:182)

+

N
2

N2
4

+

N
2

Since N = 2t, the above simpliﬁes to the ﬁrst order difference equation with respect to t ≥ 2

#a(sDVM, 2t) − 2 · #a (cid:161)sDVM, 2t−1(cid:162) = 4t−1 + 2t−1.

Solving the above difference equation using the initial condition #a(sDVM, 2) = 2, we can obtain

#a(sDVM, 2t) =

1
2

N t +

4t −

1
2

1
2

N.

Referring the scaled DVM algorithm 3.8 and (16), we could obtain another ﬁrst order difference equation with
respect to t ≥ 2

#m(sDVM, 2t) − 2 · #m (cid:161)sDVM, 2t−1(cid:162) = 4t−1 + 3 · 2t−1.

Solving the above difference equation using the initial condition #m(sDVM, 2) = 1, we can obtain

#m(sDVM, 2t) =

3
2

N t +

1
2

4t − 2N.

Lemma 4.2. Let N = 2t(≥ 2), The arithmetic complexity on computing the DVM algorithm 3.10 is given by

#a(DV M, N) =

#m(DV M, N) =

1
2
7
2

(cid:161)N t + 4t − N(cid:162) ,

N t +

4t −

1
2

7
2

N.

Proof: Referring to the dvm(N, α, z) algorithm, we get

#a(DVM, N) = 2 · #a

+ #a (DN ) +

(cid:181)
DVM,

(cid:182)

N
2
(cid:179) ¯¯DN
(cid:162) + #a

(cid:180)

#a (cid:161) ˜CN

11

(cid:228)

(17)

(18)

By following the structures of DN and ¯¯DN we get

#a (DN ) = 0,
(cid:180)
(cid:179) ¯¯DN
#a

= 0, #m

#m (DN ) = N
(cid:179) ¯¯DN
= N

(cid:180)

(19)

Thus by using the above and (16), we could state (18) as the ﬁrst order difference equation with respect to t ≥ 1

#a(DVM, 2t) − 2 · #a (cid:161)DVM, 2t−1(cid:162) = 4t−1 + 2t−1.

Solving the above difference equation using the initial condition #a(DVM, 2) = 2, we can obtain

#a(DVM, 2t) =

1
2

N t +

4t −

1
2

1
2

N.

Now by using the dvm(N, α, z) algorithm, (16), and (19), we could obtain another ﬁrst order difference equation
with respect to t ≥ 2

#m(DVM, 2t) − 2 · #m (cid:161)DVM, 2t−1(cid:162) = 4t−1 + 7 · 2t−1.

Solving the above difference equation using the initial condition #m(DVM, 2) = 2, we can obtain

#m(DVM, 2t) =

7
2

N t +

4t −

1
2

7
2

N.

(cid:228)

4.2 Numerical Results for the Complexity of DVM Algorithms

Numerical results for the arithmetic complexity of the proposed algorithms derived via Lemma 4.1 and 4.2 will

be shown in this section. Figure 2 shows the arithmetic complexity of the proposed algorithms vs the direct
matrix-vector computations with the matrix size varying from 4 × 4 to 4096 × 4096. We consider the direct
computation of the matrix ˜AN by the vector z cost N(N − 1) additions and multiplications (refer to Direct
sDVM in Figure 2) and, the matrix AN by the vector z cost N(N − 1) additions and N2 multiplications (refer
to Direct DVM in Figure 2).

Following the Figure 2, the scaled DVM and DVM algorithms have the same addition counts and the

similar multiplication counts. When the size of the matrices increases the proposed algorithms require fewer

addition and multiplication counts as opposed to the direct matrix-vector computation. Moreover, for large N,
the proposed algorithms have saved ≈ 50% of addition and multiplication counts as opposed to the direct brute-

force matrix-vector calculation. As we couldn’t distinguish the explicit addition and multiplication counts

between the proposed algorithms through the Figure 2, we have included the explicit counts using the Tables 2

and 3 in Appendix A. These counts are based on the results obtained in Lemma 4.1 and 4.2.

12

Figure 2: Addition and multiplication counts in computing the scaled DVM and DVM algorithms vs the direct
matrix-vector computation.

13

5 Analytic and Numerical Error Bounds of DVM Algorithms

5.1 Theoretical Bounds

Error bounds of computing the scaled DVM and DVM algorithms is the main concern in this section. To
do so, we use the perturbation of the product of matrices (stated in [14]). Following the sdvm(N, α, z) and
dvm(N, α, z) algorithms, we have to compute weights αk for k = 0, 1, . . . , N − 1. These weights affect the accu-
αk are used and satisfy for all
racy of the DVM algorithms. Thus, we will assume that the computed weights (cid:98)
k = 0, 1, . . . , N − 1

αk = αk + (cid:178)k, |(cid:178)k| ≤ µ,
(cid:98)

(20)

where µ := cu, u is the unit roundoff, and c is a constant that depends on the method [38].

Let’s recall the perturbation of the product of matrices stated in [14, Lemma 3.7] i.e. if Ak + ∆Ak ∈ (cid:82)N×N

satisﬁes |∆Ak| ≤ δk|Ak| for all k, then

(cid:175)
(cid:175)
(cid:175)
(cid:175)

m
(cid:89)

k=0

(Ak + ∆Ak) −

m
(cid:89)

k=0

(cid:175)
(cid:175)
(cid:175)
(cid:175)

Ak

(cid:181) m
(cid:89)

≤

k=0

(1 + δk) − 1

(cid:182) m
(cid:89)

k=0

(cid:175)
(cid:175)
(cid:175)
(cid:175)

Ak

(cid:175)
(cid:175)
(cid:175)
(cid:175)

,

=: γN and γk + u ≤ γk+1, γk + γ j +

where |δk| < u. Moreover, recall

(1 + δk)

±1 = 1 + θN where |θN | ≤ N u
1−N u

N
(cid:89)

k=1

γkγ j ≤ γk+ j from [14, Lemma 3.1 and Lemma 3.3], and for x, y ∈ (cid:67), f l(x ± y) = (x + y)(1 + δ) where |δ| ≤ u,
f l(x y) = (x y)(1 + δ) where |δ| ≤

2γ2 from [14, Lemma 3.5].

(cid:112)

In the following, we will prove the error bound on computing the scaled DVM and DVM algorithms.

Theorem 5.1. Let (cid:98)y = f l( ˜AN z), where N = 2t(t ≥ 2), be computed using the sdvm(N, α, z) algorithm, and
assume that (20) holds. Then

|y −

(cid:98)y| ≤

tη
1 − tη

|P(0)| |P(1)| · · · |P(t − 2)| (cid:175)

(cid:175) ˜A(t − 1)(cid:175)
(cid:175)

(cid:175) ˜C(t − 2)(cid:175)
(cid:175)

(cid:175) · · · (cid:175)

(cid:175) ˜C(1)(cid:175)
(cid:175)

(cid:175) ˜C(0)(cid:175)
(cid:175)

(cid:175) |z| ,

(21)

where η = (µ + γ2t (1 + µ)).

Proof: Using the sdvm(N, α, z) algorithm and the computed matrices (cid:98)˜C(s) at the step numbers (number of
αk for k = 0, 1 · · · , N − 1,
executions/iterations of the algorithm) s = 0, 1, 2, · · · , t − 2 in terms of computed weights (cid:98)
we get

(cid:181)
P(0) P(1) · · · P(t − 2) (cid:98)˜A(t − 1)

(cid:98)y = f l

(cid:182)
(cid:98)˜C(t − 2) · · · (cid:98)˜C(2) (cid:98)˜C(1) (cid:98)˜C(0) z

= P(0) P(1) · · · P(t − 2)

(cid:179)

(cid:98)˜A(t − 1) + ∆ (cid:98)˜A(t − 1)

(cid:180)

(cid:179)

(cid:98)˜C(t − 2) + ∆ (cid:98)˜C(t − 2)
(cid:179)

(cid:98)˜C(1) + ∆ (cid:98)˜C(1)

(cid:180) (cid:179)

(cid:180)

(cid:179)

· · ·

(cid:180)
(cid:98)˜C(2) + ∆ (cid:98)˜C(2)
(cid:180)
(cid:98)˜C(0) + ∆ (cid:98)˜C(0)

z,

where P(s) := 2s block diagonal matrices of PT
Using the fact that each ˜C(s) is computed using the powers of companion matrix C

2t−s and (cid:98)˜C(s) := 2s computed block diagonal matrices of ˜C2t−s .
2 with 2t−1−s non-zero

N

14

entry per row, ˜D with each one having one non-zero entry per row, and weight αk, we get

(cid:175)
(cid:175)
(cid:175)

(cid:175)
∆ (cid:98)˜C(s)
(cid:175)
(cid:175)

≤ γ

2t−1−s+3

(cid:175)
(cid:175)
(cid:175) (cid:98)˜C(s)
(cid:175) for s = 0, 1, . . . , t − 2.
(cid:175)
(cid:175)

(22)

with the use of complex arithmetic. By considering the computed weights (cid:98)
in each step i.e. using (20);

αk and evaluation at the weight α2

(cid:98)˜C(s) = ˜C(s) + ∆ ˜C(s),

|∆ ˜C(s)| ≤ µ| ˜C(s)|.

(23)

Since (cid:98)˜A(t − 1) has 2t−1 block diagonal matrices of

(cid:34)

(cid:35)

1
1
1 α

, we get

(cid:175)
(cid:175)
(cid:175)

∆ (cid:98)˜A(t − 1)

(cid:175)
(cid:175)
(cid:175)

≤ γ3

(cid:175) ˜A(t − 1)(cid:175)
(cid:175)
(cid:175) .

By evaluating (cid:98)˜A(t − 1) at the weight α2 in each step, we obtain

(cid:98)˜A(s) = ˜A(s) + ∆ ˜A(s),

|∆ ˜A(s)| ≤ µ| ˜A(s)|.

Thus overall,

(cid:98)y = P(0) P(1) · · · P(t − 2)( ˜A(t − 1) + E(t − 1))

( ˜C(t − 2) + E(t − 2)) · · · ( ˜C(1) + E(1))( ˜C(0) + E(0))z,

where |E(s)| ≤ (µ+γ2t (1+µ))| ˜C(s)| for s = 0, 1, . . . , (t−2) and |E(t−1)| ≤ (µ+γ3(1+µ))| ˜A(t−1)|. Let η = (µ+γ2t (1+µ)).
Hence

|y −

(cid:98)y| ≤ (cid:163)(1 + η)t − 1(cid:164) |P(0)| |P(1)| · · · |P(t − 2)|
(cid:175) ˜A(t − 1)(cid:175)
(cid:175) ˜C(1)(cid:175)
(cid:175) ˜C(t − 2)(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(0)(cid:175)
(cid:175)
(cid:175) |z|
(cid:175)
(cid:175)
tη
(cid:175) ˜A(t − 1)(cid:175)
|P(0)| |P(1)| · · · |P(t − 2)| (cid:175)
(cid:175)
1 − tη
(cid:175) ˜C(t − 2)(cid:175)
(cid:175)

(cid:175) ˜C(0)(cid:175)
(cid:175)

(cid:175) ˜C(1)(cid:175)
(cid:175)

(cid:175) · · · (cid:175)

(cid:175) · · · (cid:175)

(cid:175) |z|

≤

Hence the result.

(cid:228)

Theorem 5.2. Let (cid:98)y = f l(AN z), where N = 2t (t ≥ 2), be computed using the dvm(N, α, z) algorithm, and
assume that (20) holds. Then

|y −

(cid:98)y| ≤

|P(0)| |P(1)| · · · |P(t − 2)|

(3t − 2)η
1 − (3t − 2)η
(cid:175)
(cid:175)
|A(t − 1)|
(cid:175)
(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(1)(cid:175)
(cid:175) ˜C(t − 2)(cid:175)
(cid:175)
(cid:175)
|D(t − 2)| · · · |D(1)| |D(0)| |z|

(cid:175)
(cid:175)
¯¯D(1)
(cid:175)
(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(0)(cid:175)
(cid:175)
(cid:175)

¯¯D(t − 2)
(cid:175) · · · (cid:175)

(cid:175)
¯¯D(0)
(cid:175)
(cid:175)

· · ·

(cid:175)
(cid:175)
(cid:175)

(24)

where η = (µ + γ2t (1 + µ)).

Proof: Using the dvm(N, α, z) algorithm and the computed matrices (cid:98)¯¯D(s), (cid:98)˜C(s), and (cid:98)D(s) at the step numbers
αk for k = 0, 1 . . . , N −1,
(execution/iteration step of the algorithm) s = 0, 1, . . . , t−2 in terms of computed weights (cid:98)

15

we get

(cid:181)
P(0) P(1) · · · P(t − 2) (cid:98)A(t − 1)

(cid:98)y = f l

(cid:98)¯¯D(t − 2) · · · (cid:98)¯¯D(2) (cid:98)¯¯D(1) (cid:98)¯¯D(0)
(cid:98)˜C(t − 2) · · · (cid:98)˜CN (2) (cid:98)˜C(1) (cid:98)˜C(0)

(cid:98)D(t − 2) · · · (cid:98)DN (2) (cid:98)D(1) (cid:98)D(0) z

(cid:182)

= P(0) P(1) · · · P(t − 2) (cid:161)
(cid:180)
(cid:179)
(cid:98)¯¯D(t − 2) + ∆ (cid:98)¯¯D(t − 2)
(cid:179)

(cid:98)¯¯D(1) + ∆ (cid:98)¯¯D(1)

(cid:180) (cid:179)

(cid:179)

(cid:161)

(cid:98)˜C(t − 2) + ∆ (cid:98)˜C(t − 2)
(cid:179)

(cid:180) (cid:179)

(cid:98)˜C(1) + ∆ (cid:98)˜C(1)
(cid:98)D(t − 2) + ∆ (cid:98)D(t − 2)(cid:162) · · · (cid:161)
(cid:98)D(1) + ∆ (cid:98)D(1)(cid:162) (cid:161)
(cid:161)

· · ·

(cid:98)A(t − 1) + ∆ (cid:98)A(t − 1)(cid:162)
(cid:180)
(cid:179)
(cid:98)¯¯D(2) + ∆ (cid:98)¯¯D(2)
(cid:180)
(cid:98)¯¯D(0) + ∆ (cid:98)¯¯D(0)
(cid:179)

(cid:180)
(cid:98)˜C(2) + ∆ (cid:98)˜C(2)
(cid:180)
(cid:98)˜C(0) + ∆ (cid:98)˜C(0)

· · ·

(cid:180)

(cid:98)D(2) + ∆ (cid:98)D(2)(cid:162)

(cid:98)D(0) + ∆ (cid:98)D(0)(cid:162) z.

2t−s , (cid:98)¯¯D(s) := 2s computed block diagonal matrices of ¯¯D2t−s , (cid:98)˜C(s) :=
where P(s) := 2s block diagonal matrices of PT
2s computed block diagonal matrices of ˜C2t−s , and (cid:98)D(s) := 2s computed block diagonal matrices of D2t−s . Using
the fact that each ¯¯D(s) and D(s) have one non-zero entry per row and following complex arithmetic, we get

(cid:175)
(cid:175)
(cid:175)

(cid:175)
∆ (cid:98)¯¯D(s)
(cid:175)
(cid:175)

≤ γ2

(cid:175)
(cid:175)
(cid:175)

(cid:175)∆ (cid:98)D(s)(cid:175)
(cid:175)

(cid:175) ≤ γ2

(cid:175)
(cid:98)¯¯D(s)
(cid:175) for s = 0, 1, . . . , t − 2.
(cid:175)
and
(cid:175) for s = 0, 1, . . . , t − 2.

(cid:175)
(cid:175) (cid:98)D(s)(cid:175)

By considering the computed weights (cid:98)

αk and evaluation at the weight α2 in each step i.e. using (20), we have

(cid:98)¯¯D(s) = ¯¯D(s) + ∆ ¯¯D(s),
and

|∆ ¯¯D(s)| ≤ µ| ¯¯D(s)|

(cid:98)D(s) = D(s) + ∆D(s),

|∆D(s)| ≤ µ|D(s)|.

Since (cid:98)A(t − 1) has 2t−1 block diagonal matrices of

(cid:34)

1 α
1 α2

(cid:35)

, we get

(cid:175)∆ (cid:98)A(t − 1)(cid:175)
(cid:175)

(cid:175) ≤ γ4 |A(t − 1)| .

By evaluating (cid:98)A(t − 1) at the weight α2 in each step, we obtain

(cid:98)A(s) = A(s) + ∆A(s),

|∆A(s)| ≤ µ| ˜A(s)|.

16

Together with (22) and (23) and overall,

(cid:98)y = P(0) P(1) · · · P(t − 2)(A(t − 1) + E(t − 1))
( ¯¯D(t − 2) + E1(t − 2)) · · · ( ¯¯D(0) + E1(0))
( ˜C(t − 2) + E2(t − 2)) · · · ( ˜C(0) + E2(0))

(D(t − 2) + E3(t − 2)) · · · (D(0) + E3(0))z,

where |E1(s)| ≤ (µ + γ2(1 + µ))| ¯¯D(s)|, |E2(s)| ≤ (µ + γ2t (1 + µ))| ˜C(s)|, and |E3(s)| ≤ (µ + γ2(1 + µ))|D(s)| for s =
0, 1, 2, · · · (t − 2) and |E(t − 1)| ≤ (µ + γ4(1 + µ))|A(t − 1)|. Let η = (µ + γ2t (1 + µ)) and η1 = (µ + γ4(1 + µ)). Hence

|y −

(cid:175)
(cid:175)
(cid:175)

(cid:175)
¯¯D(0)
(cid:175)
(cid:175)

¯¯D(t − 2)
(cid:175) · · · (cid:175)

(cid:175)
(cid:175)
¯¯D(1)
(cid:175)
(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(0)(cid:175)
(cid:175)
(cid:175)

(cid:98)y| ≤ (cid:163)(1 + η)t−1(1 + η1)2t−1 − 1(cid:164) |P(0)| · · · |P(t − 2)|
(cid:175)
(cid:175)
|A(t − 1)|
· · ·
(cid:175)
(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(t − 2)(cid:175)
(cid:175)
(cid:175) ˜C(1)(cid:175)
(cid:175)
|D(t − 2)| · · · |D(1)| |D(0)| |z|
(3t − 2)η
1 − (3t − 2)η
(cid:175)
(cid:175)
¯¯D(t − 2)
|A(t − 1)|
(cid:175)
(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(1)(cid:175)
(cid:175) ˜C(t − 2)(cid:175)
(cid:175)
(cid:175) · · · (cid:175)
(cid:175)
|D(t − 2)| · · · |D(1)| |D(0)| |z|

(cid:175)
(cid:175)
¯¯D(1)
(cid:175)
(cid:175)
(cid:175)
(cid:175)
(cid:175) ˜C(0)(cid:175)
(cid:175)
(cid:175)

|P(0)| |P(1)| · · · |P(t − 2)|

(cid:175)
¯¯D(0)
(cid:175)
(cid:175)

· · ·

(cid:175)
(cid:175)
(cid:175)

≤

Hence the result.

(cid:228)

Lemma 5.1 shows that the forward error bound of the proposed scaled DVM algorithm depends on the size
of the matrices N, norms of the matrices ˜C(k) for k = 0, 1, · · · , t − 2, and the computed weights. Also, Lemma
5.2 shows that the forward error bound of the proposed DVM algorithm depends on the size of the matrices
N, norms of the matrices ¯¯D(k), ˜C(k), and D(k) for k = 0, 1, · · · , t − 2, and the computed weights. Thus, the error
bound of the proposed scaled DVM and DVM algorithms rapidly increase with the size of the matrices, norms
of the powers of matrices, and powers of α’s. Hence, the proposed algorithms can not be computed stably for

large matrices. This will further be shown through the numerical results in section 5.2.

5.2 Numerical Results

In this section, we state numerical results in connection to the stability of the proposed algorithm 3.10 using

MATLAB (R2014a version) with machine precision 2.2204e-16. Forward error results are presented by taking

the exact solutions as the output of the scaled DVM or DVM algorithm computed with the double precision
and the computed value as the output of the proposed sdvm(N, α, z) or dvm(N, α, z) algorithms with single
precision. We will show numerical results for matrix sizes from 4 × 4 to 128 × 128 with |α| = 1.

We compare the relative forward error e of the proposed scaled DVM and DVM algorithms deﬁned by

where y = ˜AN z or y = AN z is the exact solution computed using the scaled DVM or DVM algorithm, respec-

e =

(cid:107)y − ˆy(cid:107)
(cid:107)y(cid:107)

2

2

,

17

tively, with double precision and ˆy is the computed solution of the algorithms sdvm(N, α, z) or dvm(N, α, z),

respectively, with single precision.

Table 1 shows numerical results for the forward error of the proposed sdvm(N, α, z) and dvm(N, α, z)
algorithms with |α| = 1, and random real and complex inputs z1 and z2, respectively, of the scaled DVM and
DVM, say Err-sDVM and Err-DVM, respectively.

Table 1: Forward error in calculating the scaled DVM and DVM algorithms with α = e− πi
32 , uniformly dis-
tributed random input in the interval (0,1), say z1 for each N, and uniformly distributed random input with
real and imaginary parts in the interval (0,1) for each N, say z2.

N

4
8
16
32
64
128

Err-sDVMA Err-DVM Err-sDVM Err-DVM
with z2
6.855e-08
6.820e-08
7.449e-08
1.279e-07
1.373e-07
NaN

with z2
3.577e-08
5.959e-08
1.010e-08
1.067e-08
1.568e-07
NaN

with z1
5.648e-08
4.952e-08
5.529e-08
1.262e-07
1.138e-07
NaN

with z1
2.367e-08
6.118e-08
4.676e-08
1.022e-08
7.008e-08
NaN

As shown in Table 1, when α = e− πi

32 and N ≥ 128, the MATLAB output will produce NaN for the forward

error of the proposed algorithms. This is because the nodes will be repeated and hence the resulting singular
matrices while the proposed algorithms are executed for N > 64. Even if α (cid:54)= e− πi
32 , but |α| = 1 and not a root of
unity, we have to compute very large powers of matrices (recall that we compute powers of companion matrices
having large powers of α’s) and differences of close numbers. Thus, the entries resulting from such operations

cannot be represented as conventional ﬂoating-point values and hence lead to undeﬁned numerical values

through MATLAB output. This is also evident from the theoretical error bounds obtained in section 5.

6 Future Engineering Tasks

6.1 Analog and/or Digital Circuits that Realize the DVM Algorithm

Engineering applications require the real-time implementation of the DVM algorithm using a variety of com-

putational platforms. High-speed applications revolving around wireless communications and radar systems

typically necessitate analog implementations, which operate on analog signals from an array of sensors, such

as antennas. These analog implementations typically employ approximations to ideal time delays in the signal

ﬂow graphs, using techniques such as transmission line segments, passive resistor-capacitor lattice ﬁlters, or

other types of analog delays. Analog realizations, in their most direct form, utilize microwave transmission

lines to implement the delays. A microwave transmission line of length l approximates to sufﬁcient accuracy
the time delay T where T = αl/c for which α ≤ 1 is the velocity factor of the transmission line. Typically, these

transmission lines can be a length of cable of copper track (coplanar waveguide) on a printed circuit board.

When the physical size requirements necessitate smaller circuits, transmission lines can be approximated

using analog all-pass ﬁlters that can be implemented using integrated circuits [1, 41].

Unlike analog DVM circuits requiring delays, digital DVM implementations, may either be in software,

using computer software realizations where the speeds of operation are relatively low (for example, graphics

18

processor units), or in custom digital hardware integrated circuits, for high-speed realizations based on very

large scale integration. In both cases, the true time delays found as a basic building block of the DVM algo-

rithm will be approximated using discrete time interpolation ﬁlters [27]. For example, various time delays can

be rational fractions of the digital systems clock sample period, and can therefore be approximately realized

using both ﬁnite impulse response digital interpolation ﬁlters as well as inﬁnite impulse response digital in-

terpolation ﬁlters. A detailed discussion of the possible approaches for real-time implementation of the DVM

algorithms, albeit analog or digital, remains for a future exploration.

6.2 Low-complexity Algorithms based on Matrix Approximation

In several applied contexts, the physics of the problem admits an appreciable level of error tolerance. For

instance, this is illustrated in the context of still image compression [6], video encoding [7], beamforming [34],

motion tracking [10], and biomedical image processing [8]. Therefore, the exact operation of a given matrix

computation can be relaxed into an approximate calculation that is carefully tailored to demand a lower arith-

metic complexity when compared to the original exact computation. This can be accomplished by deriving an

approximate matrix based on the exact matrix.

Approximate matrices can be designed by several methods, including rough inspection, number represen-

tation in dyadic rationals, and integer optimization, to cite a few. Integer optimization is often the method of

choice due to its generality. The general framework is described as follows:

ˆT

∗ = arg min

ˆT∈MP (N)

error( ˆT, T)

(25)

where T is the matrix to be approximated and ˆT is a candidate matrix deﬁned over a low-complexity matrix
set [35]. The error function is closely linked to the physics of the context where the approximation is intended

to be applied. Common error functions are the Frobenius norm or the mean square error [7]. The search
space MP (N) is the set of N × N matrices with entries deﬁned over the low-complexity integer set P. A
particular common choice for the set P includes the set of trivial multiplicands P1 = {0, ±1, ±2} [5] or P2
1 for
approximations over complex integers [34].

For the DVM matrices, there are two major approaches for deriving approximations: (i) directly approx-

imating the non-factorized delay Vandermonde matrix by means of solving (25) and (ii) approximating only

the non-trivial multipliers in the DVM factorized form (Corollary 3.2). The former approach has the advan-

tage of being less restrictive, but a fast algorithm (factorization) of the obtained approximation is left to be

derived. On the other hand, by approximating from the factorized form, one has the fast algorithm readily

available by construction, however the derived approximation is tied to the particular structure of the consid-

ered factorization. As demonstrated in the context of trigonometric discrete transforms, approximations lead

to a tunable trade-off between performance and arithmetic complexity, often resulting in dramatic reductions

in computational cost. DVM matrices could beneﬁt from similar strategies.

7 Conclusion

We have proposed an efﬁcient and self-recursive DVM algorithm having sparse factors. Arithmetic complexi-

ties of the proposed algorithm are provided to show that the proposed algorithm is much more efﬁcient than

19

the direct computation of DVM by a vector. The theoretical error bound on computing the proposed algorithm is

established. Numerical results of the forward relative error are utilized to analyze the stability of the proposed

algorithm. The proposed algorithm lowers the computational complexity of the computation of N parallel RF

beams using an array of antennas as detailed in the preceding analysis. Engineering approaches to real-time

implementation of the proposed fast algorithms generally take two forms: 1) analog implementations, em-

ploying signals which are continuous in time, continuous in their range, and free of aliasing and quantization

effects, and 2) digital implementations, employing signals which are discrete in time (i.e., sampled sequences),

discrete in their range (e.g., quantized to be in a set of known values), and therefore susceptible to both aliasing

and quantization noise. Typically, discrete domain signals are processed using digital electronics and software,

while analog signals are processed using RF integrated circuits, microwave- and mm-wave passive circuits, or

photonic integrated circuits. The algorithms proposed here are agnostic to the type of implementation and lend

themselves to all types of engineering approaches based on photonics, analog circuits and digital systems, and

hybrids thereof. The potential applications of such systems span emerging 5G/6G wireless networks, wireless

IoT, CPS, radio astronomy instrumentation, radar and wireless sensing systems, among others.

Acknowledgments

The authors would like to thank Austin Ogle for his valuable time and help that allowed to improve the

exposition of the manuscript.

A Addition and Multiplication Counts

The explicit addition and multiplication counts of the proposed scaled DVM and DVM algorithms (proved in

Lemma 4.1 and 4.2) opposed to the direct matrix-vector (which we call as the Direct Add and Direct Multi)

computation are shown in Tables 2 and 3).

Table 2: Arithmetic complexity of the scaled DVM algorithm vs Direct computation

N

4
8
16
32
64
128
256
512
1024
2048
4096

Direct Add

#a(sDV M, N) Direct Multi

#m(sDV M, N)

12
56
240
992
4032
16256
65280
261632
1047552
4192256
16773120

10
40
152
576
2208
8576
33664
133120
528896
2107392
8411136

12
56
240
992
4032
16256
65280
261632
1047552
4192256
16773120

12
52
192
688
2496
9280
35328
136960
537600
2126848
8454144

20

Table 3: Arithmetic complexity of the DVM algorithm vs Direct computation

N

4
8
16
32
64
128
256
512
1024
2048
4096

Direct Add

#a(DV M, N) Direct Multi

#m(DV M, N)

12
56
240
992
4032
16256
65280
261632
1047552
4192256
16773120

10
40
152
576
2208
8576
33664
133120
528896
2107392
8411136

16
64
256
1024
4096
16384
65536
262144
1048576
4194304
16777216

22
88
296
960
3168
10880
39040
145408
556544
2168832
8546304

B Frequently used Abbreviations and Notations

B.1 Abbreviations

Cyberphysical systems

Delay Vandermonde matrix

Discrete Fourier transform

Fast Fourier transform

CPS

DVM

DFT

FFT

Forward error of the DVM algorithm

Err-DVM

Forward error of the scaled DVM algorithm Err-sDVM

Integrated circuit

Internet of things

mm wave

multiple-input multiple-output

radio-frequency

Scaled delay Vandermonde matrix

Signal to noise ratio

IC

IoT

mmW

MIMO

RF

sDVM

SNR

21

B.2 Notations

Circular frequency

ω

Companion matrix of p(z) C N
2

Diagonal matrix

DVM

DVM algorithm

Node

Number of additions

in computing

DVM algorithm

Number of additions

−1

N
2
l=0

2

= diag[αl]

˜D N
AN := AN,α = [αkl]N,N−1
k=1,l=0
dvm(N, α, z)
α ≡ e− jωτ

#a(DV M, N)

in computing

#a(sDV M, N)

scaled DVM algorithm

Number of multiplications

in computing

DVM algorithm

#m(DV M, N)

Number of multiplications

in computing

#m(sDV M, N)

scaled DVM algorithm
Polynomial with zeros α2k

Scaled DVM

Scaled DVM algorithm

p(z)
˜AN := ˜AN,α = [αkl]N−1
k,l=0
sdvm(N, α, z)

Speed of light

Temporal frequency

true-time-delay

c

f
τ

References

[1] P. Ahmadi, B. Maundy, A. S. Elwakil, L. Belostotski, and A. Madanayake, A New Second-Order All-Pass

Filter in 130-nm (CMOS), IEEE Transactions on Circuits and Systems II: Express Briefs 63(3):249-253,

2016.

[2] A. H. Aljuhani, T. Kanar, S. Zihir, and G. M. Rebeiz, A Scalable Dual-Polarized 256-Element Ku-Band

SATCOM Phased-Array Transmitter with 36.5 dBW EIRP Per Polarization, 2018 48th European Mi-

crowave Conference (EuMC): 938-941, 2018.

[3] A. H. Aljuhani, T. Kanar, S. Zihir, and G. M. Rebeiz, A Scalable Dual-Polarized 256-Element Ku-Band
Phased-Array SATCOM Receiver with ±70◦ Beam Scanning, 2018 IEEE/MTT-S International Microwave
Symposium - IMS: 1203-1206, 2018.

[4] V. Ariyarathna, A. Madanayake, X. Tang, D. Coelho, R. J. Cintra, L. Belostotski, S. Mandal, and T.

S. Rappaport, Analog Approximate-FFT 8/16-Beam Algorithms, Architectures and CMOS Circuits for

22

5G Beamforming MIMO Transceivers, IEEE Journal on Emerging and Selected Topics in Circuits and

Systems 8(3):466-479, 2018.

[5] R. E. Blahut, Fast Algorithms for Signal Processing, Cambridge University Press, 2010.

[6] S. Bouguezel, M. O. Ahmad, and M. N. S. Swamy, Low-complexity 8×8 transform for image compression,

Electronics Letters 44: 1249-1250, 2008.

[7] V. Britanak, P. Yip, and K. R. Rao, Discrete Cosine and Sine Transforms, Academic Press, 2007.

[8] R. J. Cintra, F. M. Bayer, Y. Pauchard, and A. Madanayake, Signal Processing and Machine Learning for

Biomedical Big Data, ch. Low-Complexity DCT Approximations for Biomedical Signal Processing in Big

Data: 151-176, 2018.

[9] J. W. Cooley and J. W. Tukey, An algorithm for the machine calculation of complex Fourier series, Math.

Comp. 19:297-301, 1965.

[10] V. A. Coutinho, R. J. Cintra, and F. M. Bayer, Low-complexity multidimensional DCT approximations for

high-order tensor data decorrelation, IEEE Transactions on Image Processing 26: 2296-2310, 2017.

[11] W. Gautschi and G. Inglese, Lower bounds for the condition number of Vandermonde matrix, Numerische

Mathematik 52:241-250, 1988.

[12] I. Gohberg and V. Olshevsky Complexity of multiplication with vectors for structured matrices, Linear

Algebra Appl., 202:163-192, 1994.

[13] I. Gohberg and V. Olshevsky. Fast algorithms with preprocessing for matrix-vector multiplication prob-

lems, Journal of Complexity 10:411-427, 1994.

[14] N. J. Higham, Accuracy and Stability of Numerical Algorithms, SIAM Publications, Philadelphia, USA,

1996.

[15] J. Hu and Z. Hao, A two-dimensional beam-switchable patch array antenna with polarization-diversity

for 5G applications, 2018 IEEE MTT-S International Wireless Symposium (IWS):1-3, 2018.

[16] S. G. Johnson and M. Frigo, A modiﬁed split-radix FFT with fewer arithmetic operations, IEEE Trans.

Signal Processing 55 (1):111-119, 2007.

[17] K. Kibaroglu, M. Sayginer, and G. M. Rebeiz, An ultra low-cost 32-element 28 GHz phased-array

transceiver with 41 dBm EIRP and 1.0–1.6 Gbps 16-QAM link at 300 meters, 2017 IEEE Radio Frequency

Integrated Circuits Symposium (RFIC): 73-76, 2017.

[18] H. Krishnaswamy and H. Hashemi, A 4-channel 4-beam 24-to-26 GHz spatio-temporal RAKE radar

transceiver in 90nm CMOS for vehicular radar applications, 2010 IEEE International Solid-State Cir-

cuits Conference - (ISSCC): 214-215, 2010.

[19] X. Li, Z. Cherr, S. Sun, C. Zhao, H. Liu, Y. Wu, N. Zhang, K. Lin, S. Sun, J. Zhao, and K. Kang, A 39 GHz

MIMO Transceiver Based on Dynamic Multi-Beam Architecture for 5G Communication with 150 Meter

Coverage, 2018 IEEE/MTT-S International Microwave Symposium - IMS: 489-491, 2018.

23

[20] T. Okuyama, S. Suyama, J. Mashino, S. Yoshioka, Y. Okumura, K. Yamazaki, D. Nose, and Y. Maruta,

Experimental evaluation of digital beamforming for 5G multi-site massive MIMO, 2017 20th International

Symposium on Wireless Personal Multimedia Communications (WPMC): 476-480, 2017.

[21] H. Oruc and H. K. Akmaz, Symmetric functions and the Vandermonde matrix, Journal of Computational

and Applied Mathematics 172:49-64, 2004.

[22] H. Oruc and G. M. Phillips, Explicit factorization of the Vandermonde matrix, Linear Algebra and its

Applications 315:113-123, 2000.

[23] V. Y. Pan, Fast approximate computations with Cauchy matrices and polynomials, Math. of Computation

86: 2799-2826, 2017.

[24] V. Y. Pan, How Bad Are Vandermonde Matrices?, SIAM Journal of Matrix Analysis 37(2): 676-694, 2016.

[25] V. Y. Pan, Transformations of Matrix Structures Work Again, Linear Algebra and Its Applications 465:1-

32, 2015.

[26] S. M. Perera, V. Ariyarathna, N. Udayanga, A. Madanayake, G. Wu, L. Belostotski, Y. Wang, S. Mandal,

R. J. Cintra, and T. S. Rappaport, Wideband N-beam Arrays with Low-Complexity Algorithms and Mixed-

Signal Integrated Circuits, IEEE Journal of Selected Topics in Signal Processing 12(2):368-382, 2018.

[27] J. G. Proakis and D. K. Manolakis, Digital Signal Processing, Pearson, 2007.

[28] K. R. Rao, D.N. Kim, J. J. Hwang, Fast Fourier Transform: Algorithm and Applications, Springer, New

York, USA, 2010.

[29] T. S. Rappaport, S. Sun, R. Mayzus, H. Zhao, Y. Azar, K. Wang, G. N. Wong, J. K. Schulz, M. Samimi,

and F. Gutierrez, Millimeter Wave Mobile Communications for 5G Cellular: It Will Work!, IEEE Access

1:335-349, 2013.

[30] B. Sadhu, Y. Tousi, J. Hallin, S. Sahl, S. Reynolds, Ö. Renström, K. Sjögren, O. Haapalahti, N. Mazor,

B. Bokinge, G. Weibull, H. Bengtsson, A. Carlinger, E. Westesson, J. Thillberg, L. Rexberg, M. Yeck,

X. Gu, D. Friedman, and A. Valdes-Garcia, 7.2 A 28 GHz 32-element phased-array transceiver IC with

concurrent dual polarized beams and 1.4 degree beam-steering resolution for 5G communication, 2017

IEEE International Solid-State Circuits Conference (ISSCC):128-129, 2017.

[31] B. Sadhu, Y. Tousi, J. Hallin, S. Sahl, S. K. Reynolds, Ö. Renström, K. Sjögren, O. Haapalahti, N. Mazor,

B. Bokinge, G. Weibull, H. Bengtsson, A. Carlinger, E. Westesson, J. Thillberg, L. Rexberg, M. Yeck, X. Gu,

M. Ferriss, D. Liu, D. Friedman, and A. Valdes-Garcia, A 28-GHz 32-Element TRX Phased-Array IC With

Concurrent Dual-Polarized Operation and Orthogonal Phase and Gain Control for 5G Communications,

IEEE Journal of Solid-State Circuits 52(12):3373-3391, 2017.

[32] M. Sayginer and G. M. Rebeiz, An 8-element 2–16 GHz phased array receiver with reconﬁgurable number

of beams in SiGe BiCMOS, 2016 IEEE MTT-S International Microwave Symposium (IMS): 1-3, 2016.

[33] G. Strang, Introduction to Applied Mathematics, Wesley-Cambridge Press, USA, 1986.

24

[34] D. Suarez, R. J. Cintra, F. M. Bayer, S. Kulasekera, and A. Madanayake, Multi-beam RF aperture using

multiplierless FFT approximation, Electronics Letters 50:1788-1790, 2014.

[35] C. J. Tablada, F. M. Bayer, and R. J. Cintra, A class of DCT approximations based on the Feig-Winograd

algorithm, Signal Processing 113: 38-51, 2015.

[36] N. Tawa, T. Kuwabara, Y. Maruta, M. Tanio, and T. Kaneko, 28 GHz Downlink Multi-User MIMO Ex-

perimental Veriﬁcation Using 360 Element Digital AAS for 5G Massive MIMO, 2018 48th European Mi-

crowave Conference (EuMC): 934-937, 2018.

[37] E. E. Tyrtyshnikov, How Bad Are Hankel Matrices?, Numerische Mathematik 67(2): 261-269, 1994.

[38] C. Van Loan, Computational Frameworks for the Fast Fourier Transform, SIAM Publications, Philadel-

phia, USA, 1992.

[39] H. L. Van Trees, Optimum Array Processing: Part IV of Detection, Estimation, and Modulation Theory,

WILEY Publications, New York, USA, 2002.

[40] B. Ustundag, K. Kibaroglu, M. Sayginer, and G. M. Rebeiz, A Wideband High-Power Multi-Standard
23–31 GHz 2×2 Quad Beamformer Chip in SiGe with > 15 dBm OP1dB Per Channel, 2018 IEEE Radio

Frequency Integrated Circuits Symposium (RFIC): 60-63, 2018.

[41] C. Wijenayake, Y. Xu, A. Madanayake, L. Belostotski, and L. T. Bruton, RF Analog Beamforming Fan

Filters Using CMOS All-Pass Time Delay Approximations, IEEE Transactions on Circuits and Systems

I: Regular Papers 59(5): 1061-1073, 2012.

[42] S. L. Yang, On the LU factorization of the Vandermonde matrix, Discrete Applied Mathematics 146:102-

105, 2005.

[43] Y. Yang, O. Gurbuz, and G. M. Rebeiz, An 8-element 400 GHz phased-array in 45 nm CMOS SOI, 2015

IEEE MTT-S International Microwave Symposium: 1-3, 2015.

[44] L. Zhang and H. Krishnaswamy, 24.2 A 0.1-to-3.1 GHz 4-element MIMO receiver array supporting

analog/RF arbitrary spatial ﬁltering, 2017 IEEE International Solid-State Circuits Conference (ISSCC):

410-411, 2017.

[45] S. Zihir, O. D. Gurbuz, A. Karroy, S. Raman, and G. M. Rebeiz, A 60 GHz 64-element wafer-scale phased-

array with full-reticle design, 2015 IEEE MTT-S International Microwave Symposium: 1-3, 2015.

25

