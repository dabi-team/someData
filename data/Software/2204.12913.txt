International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13  

      www.ijaceeonline.com  ISSN: 2456 - 3935   

A Survey on Formal Verification Approaches 
for Dependable Systems 

Fayhaa Hameedi Khlaif 
 PG Scholar, College of Engineering, Department of Computer Engineering, Mosul University, Iraq 
Email: fayhaa.20enp14@student.uomosul.edu.iq  

Shawkat Sabah Khairullah  
Lecturer, College of Engineering, Department of Computer Engineering, Mosul University, Iraq  
Email: shawkat.sabah@uomosul.edu.iq 

Abstract: The complexity of digital embedded systems has been increasing in different safety-critical applications 
such as industrial automation, process control, transportation, and medical digital devices. The correct operation 
of these systems relies too heavily on the behavior of the embedded digital device. As a result, any mistake or 
error made during the design stage of the embedded device can change the overall functionality of the critical 
system and cause catastrophic consequences. To detect these errors and eliminate their effects on the system, new 
error detection approaches must be innovated and used in the design of the digital system. However, these methods 
require enormous costs and time. One of these methods being employed to solve this issue is called Verification 
and Validation (V&V) which confirms that the system behavior meets the requirements early in the development 
process, before moving on to the implementation phase. Because of their benefits and importance in the building 
of complex digital systems, the employment of formal V&V methods has recently attracted a lot of attention. This 
paper focuses on presenting various studies on formal verification approaches and how the V&V can be achieved 
for developing high dependable digital embedded systems. 

Keyword: safety-critical, embedded device, error, formal verification, verification and validation. 

1.  INTRODUCTION 

A digital device is a piece of cyber-physical equip-
ment that uses digital data or an electronic device that 
can create, generate, send, or process information. The 
core of the digital devices is Embedded system, which 
is a microprocessor-based computer hardware system 
with software that is intended to execute a specific task, 
either independently or as part of a larger system. Em-
bedded system applications range from simple digital 
devices such as watches and microwaves to digital de-
vices in large and complex systems such as hybrid ve-
hicles and avionics. 

The  systems  that  combine  cybernetic  aspects  with 
physical processes are described as cyber-physical sys-
tems  (CPSs).  Physical  processes  are  monitored  and 
controlled  by  embedded  computers,  which  usually 
have  feedback  loops,  and  physical  processes  impact 
computations. Sensors in the system allow it to sense 
the physical environment around it and any event sens-
ing by it will react to it using control and actuator mod-
ules in response to a physical change in the system. As 
a result, a CPS is made up of a collection of modules 

Cite this paper: 

Fayhaa Hameedi Khlaif, Shawkat Sabah Khairulla, "A Survey on 
Formal  Verification  Approaches  for  Dependable  Systems", 
International  Journal  of  Advances  in  Computer  and  Electronics 
Engineering, Vol. 7, No. 2, pp. 1-13, February 2022. 

that work together. Those modules normally run con-
currently,  allowing  numerous  operations  to  be  per-
formed at the same time [1].   

Different  applications  and  systems  are  used  CPS 
such  as  driverless  vehicles,  biomedical  systems, 
healthcare systems, smart grids, and a variety of indus-
trial applications. Systems and control engineers have 
made great progress in developing methodologies and 
tools  for  system  science  and  engineering  throughout 
the  years  (e.g.,  time  and  frequency  domain  methods, 
state space analysis, filtering, prediction, optimization, 
robust control, and stochastic control). Simultaneously, 
researchers in computer science and software engineer-
ing have made significant advances in program verifi-
cation and validation. Validation ensures that a system 
fits  the  needs  of  clients,  whereas  verification  deter-
mines whether a system meets its specification.  

The complexity of representing both the cyber (e.g., 
software,  network,  and  computing  hardware)  and  the 
physical  (e.g.,  the  environment)  aspects  of  any  CPS 
makes  it  even  more  difficult  to  model  (physical  pro-
cesses  and  their  interactions).  If  we  don't  expect  the 
physical and logical components to fail in tandem, sim-
plified models are easily invalidated[2]. As a result, it 
is necessary to verify the specification before moving 
on to the next stage of system development, especially 
when  developing  a  reliable  and  safe  system.  As  re-
sulted, the errors will be discovered early, therefore the 

 
 
 
 
  
 
 
   
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

speed of correction will be faster as well as reducing 
costs. To achieve that in the early stage of system de-
velopment, formal methods are applied, whereby using 
model  checking  technique,  specifications  can  be 
checked against some user-defined requirements given 
as temporal logical formulas. This answers the question 
of  whether  the  requirements  are  fulfilled,  and  if  they 
aren't,  appropriate  counterexamples  are  generated  to 
hunt down the undesirable state[3].  

The remainder of this paper is organized as follows: 
Section  2  introduced  the  concept  CPS  and  its  basic 
building modules. Also, this section discussed the ver-
ification  and  validation  fundamentals.  Modeling  sys-
tems and modeling languages are illustrated in section 
3, while section 4 discusses the formal verification and 
focuses  on  explaining  the  model  checking  technique. 
Section 5 demonstrates fault classification, categories 
of the fault, and normal testing, as well as the critical 
role of fault tolerance in dependability systems. Section 
6 illustrates the difference between normal testing and 
formal  verification.  The  differences  between  runtime 
and offtime verification are discussed in section  7. In 
section 8, a review of the literature on the verification 
and  validation  process  is  presented.  Section  9  is  de-
voted to the conclusion of the paper. 

2.  BASICS 
2.1  How  Can  Scientific  Computing  Achieve 
Credibility? 

The  term  "credibility  of  computational  results"  re-
fers  to  the  ability  to  believe or  trust  the  results  of  an 
analysis. The following are the basic aspects that must 
be considered in order to ensure the credibility of com-
putational results: 

2.4  V&V Process 

The  Verification  and  Validation  process  is  a  tech-
nical process of systems, software, and hardware engi-
neering. The relationship between these processes is in-
terconnected and can be expressed together as (V&V). 
When the organization applied V&V processes on its 
system, this will be assisted it to build quality into the 
system and obtain an objective evaluation of products 
and processes throughout the life cycle. This evaluation 
shows whether the specifications are correct, complete, 
accurate, testable, and consistent. The V&V processes 
determine  whether  the  development  products  of  a 
given activity conform to the requirements of that ac-
tivity and whether the product satisfies its intended use 
and user needs. The determination includes the assess-
ment, analysis, evaluation, review, inspection, and test-
ing  of  products  and  processes.  V&V  is  performed  in 
parallel with all life cycle  stages,  not at their conclu-
sion[5]. 

3. SYSTEM MODELING 

System  modeling  is  the  initial,  and  often  crucial, 
step-in  verification.  The  right  choice  of  model  and 
modeling language is important for both designers and 
users  of  verification  tools.  Modeling  Languages,  it  is 
useful  to  distinguish  between  formalisms,  which  are 
mathematical  objects,  and  concrete  modeling  lan-
guages (and tools) which support such formalisms. A 
plethora  of  modeling  languages  exist,  developed  for 
different purposes, including:  

•  Hardware description languages (HDLs).  
•  General-purpose  modeling  languages,  such  as 

UML and SysML.  

•  Architecture  Description  Languages  (ADLs), 

 The work quality of the analysts 

such as AADL.  

• 

• 

• 

• 

 The physics modeling quality 

 The verification and validation processes [4] 

 The qualification level of analyses and equip-

ment [2]. And 

• 

 Sensitivity analyses and uncertainty quantifica-

tion [1] 

2.2  Verification  

Is the process of evaluating the products of a soft-
ware development phase to provide assurance that they 
meet the requirements defined for them by the previous 
phase.[4] 

2.3  Validation 

Is  the  process  of  testing  a  computer  program  and 
evaluating the results to ensure compliance with spe-
cific requirements.[4] 

•  Simulation-oriented languages and tools, such as 
Matlab-Simulink  or  Modelica.  Simulink  and  re-
lated tools provide primarily simulation, but also 
code  generation  and  even  formal  verification  in 
some cases.  

•  Reactive  programming  languages,  such  as  the 
synchronous languages Lustre and Esterel. These 
languages  have  been  developed  specifically  for 
formal verification purposes, using model-check-
ing or theorem-proving techniques, including  sat-
isfiability solving[6].  

4.  FORMAL VERIFICATION 
4.1  Formal Verification (FV)  

Is the analysis of the behaviors of a design using 
mathematical  analysis  tools  instead  of  calculating 
results  for  specific  values.    This  means  that  rather 
than testing specific values, an FV tool will examine 
at  the  whole  space  of  possible  simulations.  Of 
course, it won't execute all potential simulations, but 
it will utilize advanced mathematical approaches to 

                                                                      www.ijaceeonline.com                                                                    2 

 
 
                                              
 
 
 
 
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

consider all their potential behaviors. The distinction 
between simulation and FV is that simulation exam-
ines individual points in the space of possible tests, 
whereas FV examines the entire space at once. You 
can  probably  already  see  the  incredible  power  we 
can get by employing this strategy from this simple 
definition[7]. Formal verification is a systematic ap-
proach  for validating  that  a  design  implementation 
meets the requirements of its specification using ex-
haustive algorithmic techniques  [8]. Figure 1 illus-
trate the formal verification process. 

 Figure 1 Formal verification process 

4.2  Formal Verification Methods 

Methods of formal verification can be accomplished 
in a variety of techniques, each with its own set of ad-
vantages  and  disadvantages.  Theorem  proving  and 
model checking is the most commonly used in the field 
of smart contracts. [8] 

4.3  Model Checking 

Is  a  computer-assisted  method  for  the  analysis  of 
dynamical systems that can be modeled by state-tran-
sition  systems.  Drawing  from  research  traditions  in 
mathematical logic, programming languages, hardware 
design, and theoretical computer science, model check-
ing is now widely used for the verification of hardware 
and software in industry. In addition, Uses of temporal 
logic  and  data-flow-analysis  techniques  have  also 
made model checking more naturally efficient[6]. 

Every embedded system must be designed to meet 
certain  requirements.  Such  system  requirements  are 
also called properties or specifications. A mathematical 
specification  of  system  properties  is  also  known  as  a 
formal  specification.  The  specific  formalism  will  be 
used  is  called  temporal  logic.  As  the  name  suggests, 
temporal logic is a precise mathematical notation with 
associated  rules  for representing  and  reasoning  about 
timing-related  properties  of  systems.  While  temporal 
logic has been used by philosophers and logicians since 

the times of Aristotle, it is only in the last thirty years 
that it has found application as a mathematical notation 
for  specifying  system  requirements.  One  of  the  most 
common kinds of system property is an invariant. It is 
also one of the simplest forms of a temporal logic prop-
erty[9]. 

An invariant is a property that holds for a system if 
it remains true at all times during operation of the sys-
tem. Put another way, an invariant holds for a system 
if it is true in the initial state of the system, and it re-
mains true as the system evolves, after every reaction, 
in every state. In practice, many properties are invari-
ants. [9] 

System properties may be safety or liveness, a safety 
property  guarantees  that  something  wrong  will  never 
happen, whereas a liveness property ensures that some-
thing good will eventually happen

.[10 ]

4.4  FORMAL MODELING OF FAULTS 

Reliability is one of the most important characteris-
tics of the system quality. It is defined as the probabil-
ity of failure-free operation of the system for a speci-
fied period of time in a specified environment. The sys-
tem reliability has become an important design aspect 
for computer-based system, and it is considered of pri-
mary importance in systems deployed in safety critical 
applications such as avionics, military, aerospace and 
transportation. In such systems, the cost of the unrelia-
bility is very high, a fault can damage the whole system 
and leads to catastrophic failures. There is a very large 
set of different failure  sources for the system compo-
nents[11].  

4.5   Fault Classification 

In  everyday  language,  the  terms  fault,  failure,  and 
error are  used interchangeably. In fault-tolerant com-
puting parlance, however, they have distinctive mean-
ings. A fault (or failure) can be either a hardware defect 
or a software/programming mistake (bug). In contrast, 
an error is a manifestation of the fault/failure/bug. Both 
faults and errors can spread through the system[12].In 
general, a failure represents the condition in which the 
system deviates from fulfilling its intended functional-
ity or the expected behavior [33]. A failure happens due 
to an error, that is, due to reaching an invalid system 
state.  The  hypothesized  cause  for  an  error  is  a  fault, 
which represents a fundamental impairment in the sys-
tem.  The  notion  of  faults,  errors,  and  failures  can  be 
represented using the following chain [34]. 

...Fault         Error           Failure         Fault         Error         

Failure... 

Each component of the system is susceptible to be 
affected  by  internal  faults  (fault  occurring  during  the 
system design, the system manufacturing or due to ag-
ing-effect) or external faults (faults due to environmen-

                                                                      www.ijaceeonline.com                                                                    3 

 
 
                                              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

tal perturbations). The fault can occur either at the soft-
ware layer or the hardware layer of the system. There-
fore, we differentiate two categories of faults. 

4.6  Fault Categories 
  The hardware faults are caused by physical phenom-
ena affecting the hardware components, such as envi-
ronmental  perturbations,  manufacturing  defects,  and 
aging-related phenomena. 
  The  software  faults  can  only  impact  the  software 
components. However, the hardware faults can propa-
gate  through  the  different  system  layers,  and  affect 
both the hardware and the software[11]. 

4.7  Fault Tolerance 

Fault tolerance is defined as the ability of the system 
to perform its function even in the presence of failures 
[34][36].  This  implies  that  it  is  utmost  important  to 
clearly understand and define what constitutes the cor-
rect system behavior so that specifications on its failure 
characteristics  can  be  provided  and  consequently  a 
fault tolerant system can be developed[13]. 

5.  NORMAL TESTING VERSUS FORMAL 

VERIFICATION  

Testing is a dynamic technique that involves running 
a (software) system under specific conditions (prede-
fined  environment/input  sequences)  and  determining 
whether  the  observed  behavior  differs  from  the  re-
quired behavior. The goal of model-based testing is to 
check that the implementation's behavior confirms that 
of  the  specification  model  through  execution[14].  In 
model-based testing (MBT), the aim is to check by ex-
ecution that the behavior of implementation conforms 
to that prescribed by the specification model. The pri-
mary  idea  behind  MBT  is  that  instead  of  manually 
building test cases, a chosen algorithm generates them 
from a model automatically. MBT is most commonly 
associated  with  the  automation  of  black-box  test  de-
sign, but it has lately been used to white-box tests as 
well  [15].  Formal verification differs from normal test-
ing in the following ways:  

It  occurs  during  the  design  phase,  whereas  testing 

occurs after the code has been created.  

It guarantees that there are no errors in the intended 

design after implementing it.  

Testing for every single input, a chain of inputs, un-
anticipated  events,  is  almost  too  difficult  [8].  To 
demonstrate this point, consider testing the functional-
ity of a simple 16-bit comparator, as illustrated in Fig-
ure 2. the specifications of this example is very simple: 

Y1 is always a logical 1 whenever X1 > X2.  
Y2 is always a logical 1 whenever X1 ==X2. 
Y3 is always a logical 1 whenever X1 < X2.  

Figure 2 16-bit comparator 

232 vectors are required to thoroughly test our com-
parator example via simulation. Assume that our simu-
lator can evaluate a single vector per microsecond. To 
finish this verification procedure using normal testing, 
it would take 1.2 hour, what if the inputs are 32 bits or 
64 bits, or if there are a lot of inputs? but when applying 
Formal verification technique, the vector set will be re-
duced because of removing redundancy and focusing 
on selecting targeted.  

6.  RUN TIME VERIFICATION VS 
OFFTIME VERIFICATION 

Runtime Verification (RV) has been referred to a va-
riety  of  names,  including  runtime  monitoring,  trace 
analysis, dynamic analysis, and so on. The term "veri-
fication" indicates that something is correct in terms of 
some property. This differs from the term monitoring, 
which simply implies that some type of behavior is be-
ing observed. Some people consider monitoring to be 
more particular than verification because it implies in-
teraction with the system, whereas verification is a pas-
sive  process.  RV  is  a  simple,  yet  rigorous,  formal 
method that complements traditional exhaustive verifi-
cation  techniques  (such  as  model  checking  and  theo-
rem proving) with a more practical approach that ana-
lyzes a single system execution trace. RV can provide 
very  detailed  information  on the  runtime  behavior of 
the monitored system at the price of restricted execu-
tion coverage[16]. The general scheme [17] is given in 
Fig. 3. The property can be expressed as a set of rules, 
a program, or a formal specification language (autom-
ata, logic formula, grammar) [17]. 

A  runtime  verification  framework's  monitor  is  a 
key  component.  A  component  executed  along  with 
the system for the purposes of the runtime verifica-
tion process is referred to as a monitor[18].  

A monitor is made up of a set of properties. The 
monitor's job is to observe the system's operation and 
generate a verdict, or a statement if the observation 
meets  the  properties.  A  series  of  system  states  or  a 
series of input and output events could be observed. 
Monitoring is done either step by step while the sys-
tem is running or over a log that records the observa-
tions[17]. 

                                                                      www.ijaceeonline.com                                                                    4 

 
 
                                              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

generating the appropriate train velocity and accelera-
tion  commands.  This  algorithm  specified  the  safety 
property.  Based  on  this  algorithm,  [19]  modeled  the 
system in AF3 (AutoFocus3) to verify system opera-
tion before generating code. The AF3-modeled system 
includes a monitor block that represents the position, 
velocity, and acceleration of the trains. 

if 

This block contains the system's simulation and 
verification processes. In simulation, the train's initial 
position is calculated in a way that avoids violating 
safety regulations. In verification, the property is veri-
the train's initial position is greater than the 
fied 
Worst Case Scenario Distance (WCSD) to the heading 
obstacle.  Finally,  the  train  control  algorithm  was  im-
plemented  on  an  ARM  CORTEX  -M4  platform  after 
the verification model confirmed that the system spec-
ification  was  not  violated.  They  concluded  that  their 
method can be used to verify and implement another 
system of high complexity.  

Also, CPS is considered complex system and needs 
to use formal verification method that achieve verifica-
tion and validation objectives. Kang et al. (2017) [20], 
have presented an approach to guarantee that CPS op-
erates in safety and effectively in the automotive  do-
main.  They  used  EAST-ADL  language  for  architec-
tural specification and timing behavior constraints for 
automotive  embedded  systems.  Formal  analysis  on 
both functional- and non-functional properties, is per-
formed  using  Simulink  Design  Verifier  (SDV)and 
UPPAAL-SMC 
tool).  They 
demonstrate  their  approach  by  using  the  autonomous 
traffic sign recognition vehicle as case study.  

(formal  verification 

In  SDV,  each  property  is  modeled  as  a  Simulink 
block or embedded MATLAB function (EML) which 
can be  valid or invalid. After analyzing the  counter-
examples that generated by Both SDV and UPPAAL-
SMC, Kang et al. (2017) [20], have discovered the rea-
son of errors. Therefore, the invalid property and sys-
tem model have been refined based on the error traces. 
After the change, the invalid property became valid. 

Due to the lack of stochastic modeling notations and 
descriptive blocks required during proof creation, SDV 
provides limited support for modeling and analysis of 
XTC  and  energy  constraints.  For  the  verification  of 
those restrictions, they have been used UPPAAL-SMC, 
and then the results were validated in 95% confidence.  
CPSs  handle  discrete  and  continuous  signals,  so 
modeling the behavior of such systems needs a method 
that can cope with both: continuous and discrete sys-
tems. As a result, hybrid models are required to capture 
both  discrete  and  dynamic  characteristics  in  Cyber 
Physical  Systems.  Kumar  and  Kumar.  (2016)  [21], 
used PROMELA which is used to model timed autom-
ata  and  verify  them  using  the  Spin  model  checker. 
Timed automata can be used to effectively illustrate the 
behavior of CPS protocols. SPIN comes very handy for 
protocols  that  operate  in  lossy  settings.  SPIN  model 
checker in its original form cannot simulate passage of 

Figure 3 General scheme of runtime verification[17] 

Instrumentation is the process of probing and ex-
tracting signals, traces of events, and other relevant 
information  from  a  software  or  hardware  system 
though  it  is  executing.  Instrumentation  is  a  crucial 
part  of  a  runtime  verification  setup  since  it  allows 
monitors to be hooked to the system. 

The type of system to be monitored influences the 
instrumentation techniques used. For example, mon-
itoring  hardware  systems  may  include  probing 
mixed-analog signals with physical cables, but soft-
ware  instrumentation  is  strictly  related  to  the  pro-
gramming language used to implement the software 
or the low-level language used to compile it [16]. 

7.  LITERATURE REVIEW  
     In Table I we can see a summary of approaches that 
have been used for verifying system properties. Askari 
Hemmat  et  al.  (2015)  [19],  proposed  an  approach  to 
verify and implement complex system design. The ab-
straction models must be used to verify functionality in 
order to decrease the number of potential bugs in the 
implementation stage. Then one of the formal verifica-
tion methods should be utilized to ensure that the de-
sign of a complex system is implemented with limited 
risks, such as the model checking technique, which de-
termines whether the design meets the desired proper-
ties automatically.  

They utilized a train control system as an example 
for  a  complex  system  and  showed  how  to  model  the 
system. [19] determines the limits of the safe speed and 
acceleration in the modeling system and they used the 
NuSMV  technique  to  verify  the  correctness  of  the 
model  properties.  After  that, the  verified model  was 
implemented on an ARM Cortex processor.  

The system is controlled automatically as well as on-
board drivers have a limited role to play during normal 
operation. The trains are controlled in their velocity by 
a  station  computer  that  is  part  of  the  Advance  Auto-
matic Train Control (AATC) system, which uses an al-
gorithm  to  adjust  the  speed  and  acceleration  of  each 
train.  [19]  described  an  algorithm  for  modeling  train 
operation that is based on another algorithm that is em-
ployed by the station computer and is responsible for 

                                                                      www.ijaceeonline.com                                                                    5 

 
 
                                              
 
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

time, which is crucial for modeling timed automata. As 
a result, [21] proposes a validation model for timed au-
tomaton-based  systems  that  uses  the  Spin  model 
checker and applies it to a timed automaton-based traf-
fic  controller.  A  timed  automaton  is  a  hybrid  system 
that combines a clock that keeps track of the passage of 
time with a discrete pure signal. Kumar and Kumar at-
tempted to model this system using PROMELA's basic 
constructs and attempted to verify the safety and valid-
ity properties of a traffic controller modeled as a hybrid 
system. Using Spin Model Checker, this work gives an 
easy  and  effective  approach  to  build  protocols  for 
timed automaton-based systems. Eventually, this work 
will help protocol designers and software developers to 
model and verify bug-free protocols for Timed Autom-
ata-based Hybrid Systems. 
It is also very important to assure that the safety-critical 
system (SCS) is working correctly. The SCS requires 
fault tolerance [22], which ensures that the system con-
tinues to function properly even if one or more compo-
nents fail. Redundancy can provide tolerance for a sin-
gle failure. If one of the redundant subsystems fails, the 
remaining redundant subsystems will continue to per-
form the required functions. 
Pakonen  and  Buzhinsky.  (2019)  [22],  provided  a 
method  for  employing  model  checking  to  verify  the 
fault  tolerance  for  instrument  and  control  systems 
(I&C). As an example for a SCS, [22]utilizes the reac-
tor protection system of the projected US.EPR nuclear 
power plant. The protection system for a fault-tolerant 
I&C system is arranged into four redundant independ-
ent divisions and is located in separate buildings.  

They have been modeled the function block diagram 
design by using the graphical editor of the MODCHK 
tool, and by the text editor of this tool, they could spec-
ify  the  properties.  As  well,  this  tool  has  another  ad-
vantage that is producing the necessary input files for 
NuSMV and visualizing the counterexample generated 
by  NuSMV  with  an  animation  view  of  the  function 
block diagram. The formal property of (un)desired be-
havior is stated using temporal logic languages such as 
LTL,  CTL,  and  PSL,  and  the  system  model  is  ex-
pressed as a finite states machine. 

The verification procedure in safety systems is criti-
cal, so [22] focused on verifying single fault tolerance 
in open-loop models rather than describing a full fail-
ure  model.  The  failure  model  is  implemented  in 
NuSMV by adding modules to all signals on one divi-
sion. They've made a list of several functional require-
ments, some of them have been formulated using CTL, 
which  have  been  specified  as  non-deadlock  require-
ments, and the remaining requirements have been for-
mulated using LTL/PCL and CTL. In case of exception 
delays,  the  requirements  have  been  formulated  in 
LTL/PCL. Because of a huge number of states in the 
I&C system, [22] needed to use Bounded model check-
ing (BMC) which is a feature of NuSMV that limits the 
length  of  the  checked  state  transition  sequences,  and 

they  focused  on  avoiding  the  explosion  state  space, 
which is the primary challenge in the case example. Af-
ter  model  checking  runs,  the results  demonstrate  that 
the cases without delays were best handled by BDD –
based  model  checking  algorithm  than  BMC  and 
showed that the absence of deadlock requirements can 
be  proven  via  CTL  model  checking,  whereas  only 
BMC was able to check the requirements in the case of 
delays. As a result, in the case of delays, checking for 
the absence of deadlock requirements was impossible. 
Dependability analysis such as safety, reliability, ef-
ficiency, etc. is necessary for evaluating the design of 
the safety-critical system to ensure that it was modeled 
correctly and verified before being deployed in a real-
time  scenario.  Therefore,  it  needs  to  model  it  using 
Various modeling techniques such as unified modeling 
language (UML), fault tree, failure mode effect analy-
sis, and reliability block diagrams (RBDs), which are 
suitable  for  modeling  all  static  properties,  while  they 
would  fail  when  used  to  model  dynamic  properties. 
The extension of RBD which is named as dynamic re-
liability block diagram DRBD can be used for model-
ing  the  dynamic  behaviour  system.  Kumar  et  al.  in 
2021[23], presented an approach for model-based ver-
ification using DRBD. To analyze, check and verify the 
features  of  safety  and  reliability  such  as  nonliveness, 
deadlock,  faulty  state,  or  error  design  that  cannot  be 
done manually using DRBM modeling, therefore they 
used  color  Petri  net  CPT  for  complete  proof  design. 
They  utilized  a  digital  feedwater  control  system 
(DFWCS)  of  a  nuclear  power  plant  (NPP)  as  case 
study. The DRBD for the DFWDS has been illustrated 
in detail in [23]. To analyze and verify the design of the 
DRBD model for DFWCS is correct, the components 
in DRBD must be represented in CPT as states which 
can take one of the following forms: active, failed, or 
standby.  The  CPT  model  representation  from  the 
DRBD model has been illustrated in detail in [23]. Af-
ter creating the CPT model for DFWCS, the simulation 
step has been performed using the CPT tool which pro-
vides a detailed report for the model system. This re-
port  introduces  information  about  the  state  space  for 
the CPT model in terms of statistics and liveness prop-
erties.  As  for  liveness,  it  demonstrated  that  there  are 
three dead marking states and two dead transitions. By 
this  analysis  that  verified  the  CPT  model,  the  design 
errors  in  the  DFWCS  have  been  discovered  and  this 
mean that there are errors in the DRBD model. To re-
move  the  deadlocks  that  have  been  stated  above,  the 
DRBD need to modify it then modified the CPT model. 
After simulating the modified DFWCS model, the re-
sult  showed  that  there  is  no  found  any  deadlock 
whether marking or transition instances this ensures the 
correctness  of  the  modified  CPT.  Eventually,  they 
found that the designed model is effectiveness model 
with full proof. 

It is preferable to employ formal methods to verify 
the model design for SCS and prove its complete cor-

                                                                      www.ijaceeonline.com                                                                    6 

 
 
                                              
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

rectness, which is lead to improving SCS's dependabil-
ity  qualities  (safety  and  reliability  are  the  more  im-
portant dependability parameters). Therefore [24] ap-
plied the NuSMV model checking technique on Mode 
Transition Logic MTL of an autopilot system to ana-
lyze the verification status of the model. NuSMV tool 
has been used for verifying the vertical mode function-
ality of the MTL (represents a very critical functional-
ity in aircraft). 

The properties of MTL that are required to verify it 
informal  method,  need  to  specify  it  using  temporal 
logic language such as Computation Tree Logic (CTL) 
or  Linear  Temporal  Logic  (LTL)  which  are  used  to 
check the model for properties. After carrying out the 
model State-space and getting a detailed analysis of the 
model in terms of numerous parameters from the test 
cases, the specifications are simultaneously provided to 
NuSMV in the form of an input code with the smv ex-
tension. The program's truth or falsity is determined by 
compiling and simulating the code. Then the results of 
the checked property which have been got by NuSMV, 
are compared to those received by Simulink. If any cor-
rections  are  found,  the  model  is  re-verified  and  ana-
lyzed. Otherwise, the model's efficiency is determined. 
EAST-ADL is targeted to the design of automotive 
embedded  systems,  with  a  particular  emphasis  on 
structural and functional modeling[25]. The behavior is 
defined in terms of functional blocks at the EAST-ADL 
component  abstraction  level  and,  because  a  compo-
nent's functional activity is represented using external 
notations like Simulink or UML, the capacity to create, 
verify, and transform EAST-ADL models using formal 
methods is limited. Furthermore, because many auto-
motive  functions  are  real-time,  formal  verification  of 
both functional and timely behavior is required at the 
architectural level to verify that real-time requirements 
have been met. As a result of the behavioral description 
not  being  integrated  into  the  execution  semantics, 
EAST-ADL models are more difficult to transform, an-
alyze,  and  verify  models.  Therefore,  [25]  presents  a 
way for integrating architectural description languages 
and verification methodologies (based on Eclipse plug-
ins)  by  implementing  it  in  the  tool  ViTAL,  which  is 
suited  for  EAST-ADL  models.  ViTAL  is  improving 
the  EAST-ADL 
language's  behavioral  definition, 
providing for formal modeling, simulation, and verifi-
cation of the requirements (functional and timing). The 
EAST-ADL  architectural  model  and  the  created  TA 
behavioral model are required artifacts for the formal 
analysis of the system. In [25], the information regard-
ing  model  transformation  to  UPPAAL  port  has  been 
covered in detail. Enoiu et al.  - 2012 have been inte-
grated such models into ViTAL, so that they can simu-
late and verify whether a certain requirement is satis-
fied,  by  model  verifying  the  TA  description  using 
UPPAAL PORT.  

They  conducted  a  case  study  in  a  Brake-By-Wire 
(BBW) system which was modeled in EAST-ADL to 
demonstrate the usage of ViTAL. 

In  the  tool  ViTAL,  they  modeled,  simulated,  and 
verified  the  BBW  system.  Papyrus  UML  Editor  was 
used to model the system, and a UML profile was cre-
ated  to  describe  the  architecture.  The  safety  and 
liveness properties of the BBW system, have been ver-
ified and the property of deadlock freedom is satisfied 
for all execution paths of the state-space. They used the 
CTL  specification  as  an  example  of  an  architectural 
property because the tool ViTAL provides simulation 
and  verification  of  architectural  properties.  The  CTL 
specification ensures the brake reaction delay stated in 
the BBW model. They point out that during verifica-
tion, ViTAL is indirectly utilizing the delay constraints 
information  from  EAST-ADL  models  so  they  found 
that this delay constraint information should be consid-
ered a transformation parameter and then verified au-
tomatically in UPPAAL PORT to handle automated in-
tegration during verification of TCTL (Timed Compu-
tation Tree Logic) properties. 

During  the  system's  design  cycle,  the  verification 
process  can  be  conducted  with  different  stages. 
Wisniewski et al. (2019) [26], verified the system's op-
eration in three stages before the final implementation 
in hardware. The stages have been represented as fol-
lows: specification stage, modeling stage (which repre-
sents software verification), and finally hardware veri-
fication  that  conducted after  the implementation  pro-
cess  in  a  programmable  device.  Khan  et  al.  applied 
their  approach  to  a  cyber-physical  system  (CPS)  and 
illustrated it using a direct matrix converter (MC) with 
transistor communication and space vector modulation 
(SVM).  In this case study as mentioned hereinabove, 
CPS is verified through a series of stages. 

Initially, the (SVM)algorithm was specified using a 
Petri-net,  which  can  be  live  and  safe.  This  stage  in-
volves creating a Petri-net based on the requirements. 
As a result, there are 49 places and 31 transitions in the 
net. To ensure that all places of the net are reachable, 
and the Petri net is live, the model checking technique 
should be applied in the next phase. In this phase the 
first  step  is  the  simple  rule-based  logical  model 
(RBLM) which is utilized to formally verify the net. To 
perform formal verification, the net is first written on 
(RBLM), where the variables are Petri-net places and 
all the Petri-net transitions are written as separate rules, 
each  one  contains  a  precondition  and  postcondition. 
Following the completion of the RBLM, the developed 
m2vs  tool  was  utilized  to  generate  an  automatically 
verifiable model in NUXMV format, as well as based 
on the RBLM, a synthesizable prototype model, is gen-
erated in  the VHDL  language.  After  formal  verifica-
tion, the initial Petri-net specification is analyzed such 
as liveness, safety, and the number of reachable states. 
When there are no formal errors or mistakes in the ini-
tial specification stage, The third step, which includes 

                                                                      www.ijaceeonline.com                                                                    7 

 
 
                                              
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

modeling the system using HDL, begins. In [26], Ver-
ilog  code  has  been  applied  to  implement  the  CPS 
model in hardware. 

To check the model functionality is correct, Matlab 
simulation has been used in the fourth step as a soft-
ware verification of the CPS model. In this step, all the 
signals should be implemented in a simulation system 
as numerical data (test scenario).  Testing the correct-
ness of the SVM algorithm required software simula-
tion  of  HDL  code  which  is  needed  to  use  a  tool  that 
verifies the  HDL code, so this paper used the  Active 
HDL  simulator  tool.  After  hardware  implemented, 
Wisniewski  et  al  verify  the  behaviour  of  the  imple-
mented  SVM  algorithm  and  ensure  that  operate  cor-
rectly by test the control signals on the I/O pins of the 
Field  Programmable  Gate  Array  (FPGA)  device. 
Wisniewski et al. concluded that the results of the final 
stage are identical to those of the software verification 
step, demonstrating that the design and implementation 
systems match all requirements. 

Also, Grobelna et al. (2017) [27], verified their ap-
proach in more than one stage. they have been applied 
their approach on the system for the real-life process 
which  must  be  carefully  and precisely  constructed  in 
order to operate flawlessly and meet the requirements 
of the users. To ensure the high quality of a final result, 
such a system requires verification methods to be ap-
plied at various stages of the system development. [27]  
represented a method that specifies the real-life process 
for distributed logic controllers using Petri-net. Petri-
net can be used as modeling formalism. This method-
ology covers the development of distributed logic con-
trollers, from the specification step to the final imple-
mentation stage.  

The key notion of [27] was that the system is decom-
posed  into  small  components  (modules)  that  perform 
distributed system. Grobelna et al. (2017)  [27], used 
model  checking  to  formally  verify  the  specification 
(before and after the decomposes process) against pre-
defined behavioral requirements. This means that the 
verification step is repeated twice to guarantee that the 
functionality of the designed distributed logic control-
ler functions is correct. [27] Uses the smart home sys-
tem as an example to show how to design and verify a 
real-world process.  The  system  should  first  be  speci-
fied using a control interpreter Petri-net.  To formally 
verify  the  primary  specification,  [27]  used model 
checking techniques. In this step, an interpreted Petri-
net  has  been  translated  to  a  rule-based  logical  model 
which is utilized to explain the core element of the Pe-
tri-net (places and transitions). The automatic genera-
tion of a verifiable model (VMOD) and synthesizable 
model (SMOD) are based on the algorithm outlined in 
[27]. Grobelna et al. (2017) [27], developed the m2vs 
tool to generate these models by using the rule-based 
logical  model.  The  Smod  is  a  VHDL  language,  and 
Vmod is compatible with the NuSMV model checker 
which  compares  Vmod  to  requirements  that  trans-

formed  to formal specifications using temporal logic, 
which is either LTL or CTL depending on the property 
type.  

The net splits into several concurrent modules called 
SMCs during the decomposition system stage. [27] em-
ploys the ILP technique to decompose the Petri-net of 
a specified system. This technique can be successfully 
applied to most Petri-nets. Each module is a sequential 
automaton that can be designed separately from the rest 
of the prototype system. But the decomposition process 
suffered from the synchronization of decomposes mod-
ules problem.   After the net has been decomposed and 
the  proper  synchronization  has  been  established,  the 
modules are written as distinct rule logical models that 
are  automatically  transformed  into  verified  modules 
and  then  combined  with  these  modules.  Finally,  [27] 
implemented the decomposition system in FPGA. 

The behavior definition, which specifies the proper-
ties and main functionality of embedded systems, is the 
most significant step in embedded systems design. Er-
rors can happen during the incoming phases, and to re-
move them, this process needs enormous costs. In the 
case of designing a dependable embedded system, if a 
tiny error occurred through a design stage may cause 
tragic  effects  and  change  the  behavior  of  the  overall 
system.  Therefore,  choosing  a  suitable  language  for 
modeling process is very important during the design 
system.  The  first  step  of  system  design  required  for 
gathering  requirements  and  needing  to  consultations 
with the client. The problems that may be faced by the 
designer, the client may not be professional in formu-
lating requirements. The UML language, which is sim-
ple  to  understand,  is  one  of  the  behavior  description 
languages. UML is also used in business areas, as well 
as in modeling of information flow behavioral software 
and  embedded  system  design,  also  Petri-net,  particu-
larly Control Interpreted Petri-Net (CIPN), is used for 
specifying hardware behavior, but it is not easily un-
derstandable  and  acceptable  for  non-engineers.  Petri-
net is even used to generate code for logic controllers. 
Although the UML activity diagram (version 2) can be 
used  to  model  hardware  behavior,  it  is  not  well  sup-
ported in implementation (code) creation. Grobelny et 
al.  (2012)    [28],  integrated  the  accessibility  of  UML 
with full support for formal verification of Petri-net to 
improve design  quality.  To  apply  this  approach,  [28] 
supported logic controller development, starting with a 
specification to formal verification and finishing with 
synthesis. By transforming UML activity diagrams to 
Petri-nets and verifying with the formal approach, Gro-
belny et al. employed one of the verification techniques 
to ensure greater quality for project. To improve pro-
ject quality, Grobelny et al.  used formal methods such 
as model checking with the NuSMV tool. After speci-
fying the properties (safety and liveness) from require-
ments  and  defining  them  by  temporal  logic  (CTL  or 
LTL), NuSMV tool has been used for checking  it. Gro-
belny  et  al.  state  that  their  proposed  approach  was 

                                                                      www.ijaceeonline.com                                                                    8 

 
 
                                              
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

tested using control interpreted Petri nets on many ex-
amples of industrial logic controller specifications. 

example which illustrates the errors that cause an inva-
lid property. 

 Another language that used for the building model 
is SysML which is the extension of UML developing 
software.  SysML  can  model  both  hardware  and  soft-
ware behaviors. SysML is made up of elements and as-
sociations which includes representations of elements, 
requirements,  behaviors,  test  cases,  parametrics,  and 
the  links  that  connect  them.  Khan  et  al.  (2012)  [29], 
used  SysML  to  model  avionics  electronics  and  soft-
ware. The approach was to extend model Based verifi-
cation  and  validation  to  electronics  and  software 
through functional and structural models implemented 
in SysML. SysML helps to simulate hardware and soft-
ware interactions. Khan et al.  directly derive simula-
tions  from  models  and  validate  simulations  against 
hardware test results. The simulation was then used to 
conduct  test  cases,  and  the  results  were  compared  to 
those obtained from identical tests run on a hardware 
testbed. When the simulation produced test results that 
were nearly identical to those of the avionics hardware, 
Khan et al.  found that SysML model simulation at a 
spacecraft subsystem level could be used to mimic de-
vice functionality, and that inputs could be passed to a 
more capable box and card-level simulators. 

As for EAST-ADL, is a language that describes the 
architecture  of  safety-critical  automotive  embedded 
system  design  (architectural  description  language). 
Kang et al. (2015) [30], presented a formal method for 
translating  EAST-ADL  behavior  description  control-
lers  into  UPPAAL  models.  This  approach  proposes 
an algorithm  for  translating  a  hierarchical  Stateflow 
model to a UPPAAL model. Kang et al. presented this 
approach  because  the  Stateflow  was  originally  de-
signed for the simulation of designs, it has limited sup-
port for formal analysis, and often suffers from incom-
plete coverage difficulties. As a result, it does not make 
the model suited for formal verification. In addition, a 
set  of  mapping  rules  supporting  an  algorithm  is  pre-
sented and validated to verify that the translation is cor-
rect, efficient, and applicable to real case studies. The 
Fault-Tolerant Fuel Control and Power Window were 
two automotive systems where they used in their ap-
proach. UPPAAL model checking tool has been used 
in [30] for real-time system modeling, validation, and 
verification. In UPPAAL, a subset of Timed Arithme-
tic Tree (TCTL) logic is used as a query language to 
define  system  requirements.  As  for  State  flow,  is  a 
graphical language similar to Statecharts in that it vis-
ualizes state machines, and the states are the primary 
components of it. 

When Kang et al. applied their approach to the fault-
tolerant  fuel  control  system,  noticed  that  the  invalid 
properties do not appear through the simulation in Sim-
ulink/State  flow  but  can  be discovered  directly  using 
the  UPPAAL  tool  which  generates  a  counterexample 
for  each  invalid  property.  Kang  et  al.  discovered  the 
cause of invalid property after analyzing the counter-

 As for Techniques and tools, NuSMV is a mature 
temporal  logic  model  checker  derived  from  SMV 
(symbolic model verification). It can verify specifica-
tions  written  in  Computation  Tree  Logic  (CTL)  and 
Linear Temporal Logic (LTL). Model checkers, such 
as NuSMV, are frequently used for test case generation 
in  addition  to  verification.  Arcaini  et  al.  (2017)  [31], 
proposed NuSeen, a tool framework that aids designers 
while utilizing the NuSMV model checker. NuSeen is 
a  set  of  tools  that  are  integrated  into  the  eclipse  IDE 
and  are  designed  to  assist  NuSMV  users  with  their 
V&V activities. It focuses on making the NuSMV eas-
ier to use by using graphical components like as but-
tons, menus, and text highlighting, among other things. 
It also includes various auxiliary tools that use graph-
ical elements to display model information (like tables, 
dependency graphs, etc.). NuSeen has a visualize coun-
terexample that displays traces in a more user-friendly 
manner than NuSMV's basic  text (or XML). The de-
signer can better understand if the bug is in the system 
behavior  or  the  temporal  property  by  looking  at  the 
counterexample. Variables in a NuSMV specification 
can also be analyzed to see whether they have any de-
pendencies. The dependency graph can be used to bet-
ter  understand  how  behaviors  are  related.  This  ap-
proach  also has  gaps  in  the  editor's  violation  and  the 
amount of the generated test. 
NuSMV  is  also  appropriate  for  large-scale  models. 
Fritzsch et al. (2021) [32], using the NuSMV to formal-
ize a Vehicle Control System. Several failure states had 
to be modeled based on the safety requirements. The 
required  properties  are  then  formalized  and  reported 
using CTL and LTL formulations. The model checking 
technique must be automated due to the system's com-
plexity. When they describe the architecture modeling 
procedure, they get a large-scale model. To avoid the 
state  explosion  problem,  automate  and  improve  the 
model checking procedure for use on multi-core CPUs, 
and  use  Bounded  Model  Checking.  To  do  this,  they 
for  partitioning, 
built 
parallelizing,  and  batch  processing  model  checking. 
They also discussed their thoughts on synchronous vs. 
asynchronous  timing,  as  well  as  their  decision  to  use 
NuSMV. They employed Bounded Model Checking to 
get an acceptable runtime and solve the state explosion 
problem. 

automated  method 

an 

8. CONCLUSION AND FUTURE WORKS 
  By reviewing previous research in the field of formal 
verification and dependable computing, we have found 
that it is extremely important to implement verification 
and validation approach at an early stage of the system 
design. This approach will make the embedded digital 
device  work  efficiently,  safely,  and  free  from  any 
interruptions,  errors,  or  malfunctions.  The  previous 
studies which have been clarified in this paper shows

                                                                      www.ijaceeonline.com                                                                    9 

 
 
                                              
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

No. 

Authors 

Model Language 

TABLE I A SUMMURY OF APPROACHES FOR VERIFYING SYSTEMS PROPERTIES

Modelling 

Verification 

Property 
Language 

LTL-CTL 

LTL 

LTL 

Technique 

Tool Support 

Objective 

Model 
checking 

Model 
checking 
/simulation 

Model 
checking 

NuSMV 

UPPAAL-SMC- 
Simulink/SDV 

automatically determining 
whether a design (model) 
satisfies desired properties 

perform V&V on (non)- 
functional properties of an 
autonomous vehicle system 
and support for Simulink 

SPIN 

model timed automata 
based hybrid systems 

AutoFocus3 
(AF3) 

EAST-ADL- 
Simulink/ 
stateflow 

PROMELA 
Timed Automaton 

Askari 
Hemmat et 
al. - 2015 
[19] 

Kang et al. 
- 2017[20] 

Kumar and 
Kumar - 
2016[21] 
Pakonen 
and 
Buzhinsky  
in [22] 

Kumar et 
al. in 2021 
[23] 

Shreya and 
Nanda - 
2016 - [24] 

1 

2 

3 

4 

5 

6 

MODCHK 

LTL, CTL and 
PSL 

Model 
checking 

NuSMV/BMC 

DRBD, colored 
Petri nets (CPN) 

------ 

Model 
checking 

DRBD, colored 
Petri nets (CPN) 

Matlab/Simulink 

LTL-CTL 

Model 
checking 

NuSMV 

7 

Enoiu et al. 
– 2012-[25] 

EAST-ADL 

CTL-TCTL 

Model 
checking 

UPPAAL 

Criteria 

Kind of 
Properties 

Application 

Level 
S.W  H.W 

a train control 
system 

√ 

√ 

autonomous traffic 
sign recognition 
vehicle 

TRAFFIC LIGHT 
CONTROLLER 

√ 

√ 

instrumentation 
and control (I&C) 

√ 

√ 

liveness 

safety and 
liveness 

digital feedwater 
control system 
(DFWCS) of a 
nuclear power 
plant (NPP) 

the Mode 
Transition Logic 
(MTL) of an 
autopilot system. 

safety and 
liveness 

Brake-By-Wire 
(BBW) system 

√ 

√ 

√ 

verifying the fault tolerance 
of I&C systems based on 
model checking 

Analyzing the (DFWCS) to 
locate and identify the 
critical aspects of reliability 
and safety such as 
nonliveness, deadlock, 
design errors, or faulty state 

achieve Reliability and 
safety property of designed 
system and enhance the 
efficiency by proper 
verification techniques. 
improving the EAST-ADL 
language's behavioral 
definition, providing for 
formal modeling, 
simulation, and verification 
of the functional and timing 
requirements 

                                                                      www.ijaceeonline.com                                                                    10 

 
 
                                              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

No. 

Authors 

Model Language 

Property 
Language 

Technique 

Tool Support 

Objective 

Modelling 

Verification 

Criteria 

Kind of 
Properties 

8 

9 

10 

11 

Wisniews
ki et al. – 
2019. [26] 

Grobelna et 
al - 2017 -
[27] 

Grobelny et 
al. - 2012 in 
[28] 

in [29], 
Khan et al. 
- 2012 

Petri nets 

------ 

Model 
checking 
/simulation 

M2vs 

Petri nets 

CTL 

Model 
checking 

NuSMV 

UML- Petri Nets 

LTL-CTL 

Model 
checking 

NuSMV 

SysML 

------ 

Simulation 

A Remote 
Engineering 
Unit (REU) 

12 

Kang et al. 
- 2015[30] 

TA—EAST-ADL 

TCTL 

Model 
checking 

UPPAAL 

13 

14 

Arcaini et 
al. - 2017 
[31] 

Fritzsch et 
al. - 2021 
[32] 

--- 

LTL-CTL 

Model 
checking 

NuSMV 

NuSMV 

LTL-CTL 

Model 
checking 

NuSMV 

Provide comprehensive 
verification for the control 
part of a CPS system by 
analyzing and verifying it in 
several times 

design and verification 
methods of distributed  
logic controllers 
supervising real-life 
processes 

transformation from UML 
activity diagrams into 
control interpreted Petri 
nets to Ensure higher 
quality of projects 

extends model-based V&V 

Extend the transforming 
timed behavioral constraints 
in EAST-ADL into the 
analyzable UPPAAL 
models by including 
support for Stateflow 
Perform a framework that 
assists a designer during the 
modeling and V&V 
activities when using 
NuSMV 

use the model checker 
NuSMV to check large-
scale models with great 
complexity. 

Application 

direct matrix 
converter (MC) 
with transistor 
commutation 

Level 
S.W  H.W 

√ 

√ 

Smart home 
system 

√ 

√ 

Embedded logic 
controller 

√ 

√ 

Spacecraft 
Avionics 

√ 

√ 

Fault-tolerant Fuel 
Control (FFC) 
system and Power 
Window 
Controller 

√ 

--- 

NuSMV tool 

√ 

Safety 

Vehicle Control 
System 

√ 

                                                                      www.ijaceeonline.com                                                                    11 

 
 
                                              
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

that  each  verification  approach  used  a  different 
modeling language. They also differ in the application 
of the formal verification in terms of the type of model 
checking technique being used, the number of stages of 
the verification process throughout the system, and the 
level of applying the verification whether on software 
level, or both software and hardware levels. From this 
survey paper, it can help the verification researchers to 
propose a more robust approach than those presented 
in  the  literature  review  and  provides  a  high  level  of 
verification and validation on the overall system. 
  Future  research  works  will  be  focusing  on  various 
topical  areas, 
formal 
verification  and  validation  methods,  such  as  hybrid 
fault-tolerant  techniques  and  run-time  verification  to 
ensure that the behavior of the designed digital system 
meets  its  intended  specification.  These  methods  are 
called  formal  in  its  operation  because  temporal 
language is used in the design and analysis of system 
complexity.  Also,  we  would  attempt  to  make  the 
designed  system  more  reliable,  safer,  and  operates 
under any potential fault by designing a fault-tolerant 
controller  system.  Finally,  these  designed  digital 
systems  will  be  verified  in  the  implementation  phase 
using FPGA technology. 

traditional 

including 

the 

REFERENCES 

[1]  Wisniewski,  Bazydło, 

Szcześniak,  Grobelna, 

and 
Wojnakowski,  “Design  and  Verification  of  Cyber-Physical 
Systems Specified by Petri Nets—A Case Study of a Direct 
Matrix Converter,” Mathematics, vol. 7, Issue. 9, p. 812, Sep. 
2019. 

[2]  X. Zheng, C. Julien, M. Kim, and S. Khurshid, “Perceptions 
on the State of the Art in Verification and Validation in Cyber-
Physical Systems,” IEEE Syst. J., vol. 11, Issue. 4, pp. 2614–
2627, Dec. 2017 

[3] 

I.  Grobelna,  “Formal  Verification  of  Control  Modules  in 
Cyber-Physical Systems,” Sensors, vol. 20, Issue. 18, p. 5154, 
Sep. 2020. 

[4]  W. L. Oberkampf and C. J. Roy, “Verification and Validation 

in Scientific Computing,” p. 791,2010. 

[5] 

[6] 

[7] 

“IEEE  Standard  for  System,  Software,  and  Hardware 
Verification and Validation,” IEEE,p.260,nov.2017. 

E. M. Clarke, T. A. Henzinger, H. Veith, and R. Bloem, Eds., 
Handbook of Model Checking. Cham: Springer International 
Publishing, 2018.  

P. S. Kaliappan and V. K. Kaliappan, “Deriving the behavioral 
properties from UML designs as LTL for model checking,” in 
2015  IEEE  International  Conference  on  Signal  Processing, 
Informatics, Communication and Energy Systems (SPICES), 
Kozhikode, India, Feb. 2015, pp. 1–5.  

[8]  Y. Murray and D. A. Anisi, “Survey of Formal Verification 
Methods  for  Smart  Contracts  on  Blockchain,”  in  2019  10th 
IFIP International Conference on New Technologies, Mobility 
and  Security  (NTMS),  CANARY  ISLANDS,  Spain,  Jun. 
2019, pp. 1–6. 

[9] 

E.  A.  Lee  and  S.  A.  Seshia,  “Embedded  Systems,”  p. 
124,2015. 

[10]  “Boulanger  J.-L.  (ed.)  -  Industrial  use  of  formal  methods_ 
formal verification-Wiley (2012).djvu.”,p.306,2012.  

[11]  M. Kooli, F. Kaddachi, G. D. Natale, A. Bosio, P. Benoit, and 
L. Torres, “Computing reliability: On the differences between 
software  testing  and  software  fault  injection  techniques,” 
Microprocess. Microsyst., vol. 50, pp. 102–112, May 2017. 

[12]  “Front Matter,” in Fault-Tolerant Systems, Elsevier, 2021, pp. 

i–iii.  

[13]  R.  Jhawar  and  V.  Piuri,  “Fault  Tolerance  and  Resilience  in 
Cloud Computing  Environments,”  in  Cyber Security  and  IT 
Infrastructure Protection, Elsevier, 2014, pp. 1–28.  

[14]  “Towards a Method for Combined Model-based Testing and 
Analysis:,” 
International 
Conference  on  Model-Driven  Engineering  and  Software 
Development, Lisbon, Portugal, 2014, pp. 609–618.  

in  Proceedings  of 

the  2nd 

[15]  D. J. Offutt, “Model-Based Testing for Embedded Systems,” 

p. 668. Apr.2017. 

[16]  E.  Bartocci,  Y.  Falcone,  A.  Francalanza,  and  G.  Reger, 
“Introduction  to  Runtime  Verification,”  in  Lectures  on 
Runtime Verification, vol. 10457, E. Bartocci and Y. Falcone, 
Eds. Cham: Springer International Publishing, 2018, pp. 1–33.  

[17] 

I. Kurtev, J. Hooman, and M. Schuts, “Runtime Monitoring 
Based  on  Interface  Specifications,”  in  ModelEd,  TestEd, 
TrustEd,  vol.  10500,  J.-P.  Katoen,  R.  Langerak,  and  A. 
Rensink, Eds. Cham: Springer International Publishing, 2017, 
pp. 335–356.  

[18]  Y. Falcone, S. Krstić, G. Reger, and D. Traytel, “A Taxonomy 
for Classifying Runtime Verification Tools,” p. 19,Sep.2018. 

[19]  M. H. Askari Hemmat, O. A. Mohamed, and M. Boukadoum, 
“Formal modeling, verification and implementation of a train 
control  system,”  in  2015  27th  International  Conference  on 
Microelectronics  (ICM),  Casablanca,  Morocco,  Dec.  2015, 
pp. 134–137.  

[20]  Eun-Young Kang, D. Mu, L. Huang, and Q. Lan, “Verification 
and Validation of a Cyber-Physical System in the Automotive 
Domain,” in 2017 IEEE International Conference on Software 
Quality,  Reliability  and  Security  Companion  (QRS-C), 
Prague, Czech Republic, Jul. 2017, pp. 326–333. 

[21]  N. S. Kumar and G. S. Kumar, “Modeling and verification of 
timed  automaton  based  hybrid  systems  using  spin  model 
India  Conference 
IEEE  Annual 
checker,” 
(INDICON), Bangalore, India, Dec. 2016, pp. 1–8.  

in  2016 

[22]  A. Pakonen and I. Buzhinsky, “Verification of fault tolerant 
safety  I&C  systems  using  model  checking,”  in  2019  IEEE 
International  Conference  on  Industrial  Technology  (ICIT), 
Melbourne, Australia, Feb. 2019, pp. 969–974.  

[23]  P.  Kumar,  L.  K.  Singh,  and  C.  Kumar,  “Model  Based 
Verification  of  Safety-Critical  Systems,”  in  2021  2nd 
International Conference for Emerging Technology (INCET), 
Belagavi, India, May 2021, pp. 1–9. NuSMV model checker,” 
in 2016 IEEE International Conference on Recent Trends in 
Electronics,  Information  &  Communication  Technology 
(RTEICT), Bangalore, India, May 2016, pp. 817–820.  

[25]  E.  P. Enoiu, R. Marinescu,  C.  Seceleanu,  and  P.  Pettersson, 
“ViTAL: A Verification Tool for EAST-ADL Models Using 
International 
UPPAAL  PORT,” 
Conference  on  Engineering  of  Complex  Computer  Systems, 
Paris, Jul. 2012, pp. 328–337.  

IEEE  17th 

in  2012 

[26]  Wisniewski, Bazydło, Szcześniak, Grobelna, and 

Wojnakowski, “Design and Verification of Cyber-Physical 
Systems Specified by Petri Nets—A Case Study of a Direct 
Matrix Converter,” Mathematics, vol. 7, Issue. 9, p. 812, 
Sep. 2019. 

[27] 

I.  Grobelna,  R.  Wisniewski,  M.  Grobelny,  and  M. 
Wisniewska, “Design and Verification of Real-Life Processes 
With  Application  of  Petri  Nets,”  IEEE  Trans.  Syst.  Man 
Cybern. Syst., vol. 47, Issue. 11, pp. 2856–2869, Nov. 2017. 

[28]  M.  Grobelny,  I.  Grobelna,  and  M.  Adamski,  “Hardware 
Behavioural Modelling, Verification and Synthesis with UML 

                                                                      www.ijaceeonline.com                                                                    12 

 
 
                                              
 
 
 
 
 
 
 
 
International Journal of Advances in Computer and Electronics Engineering 
Volume 7, Issue 2, February 2022, pp. 1 – 13   

ISSN: 2456 - 3935   

2.x Activity Diagrams,” IFAC Proc. Vol., vol. 45, Issue. 7, pp. 
134–139, 2012. 

Cite this paper: 

 Fayhaa Hameedi Khlaif, Shawkat Sabah Khairulla, "A Survey 
on Formal Verification Approaches for Dependable Systems", 
International Journal of Advances in Computer and Electronics 
Engineering, Vol. 7, No. 2, pp. 1-13, February 2022. 

[29]  M.  Khan,  M.  Sievers,  and  S.  Standley,  “Model-Based 
Verification  and  Validation  of  Spacecraft  Avionics,” 
presented  at  the  Infotech@Aerospace  2012,  Garden  Grove, 
California, Jun. 2012, p.13.  

[30]  E.-Y. Kang, L. Ke, M.-Z. Hua, and Y.-X. Wang, “Verifying 
Automotive  Systems 
in  EAST-ADL/Stateflow  Using 
UPPAAL,”  in  2015  Asia-Pacific  Software  Engineering 
Conference (APSEC), New Delhi, Dec. 2015, pp. 143–150.  

[31]  P. Arcaini, A. Gargantini, and E. Riccobene, “NuSeen: A Tool 
Framework for the NuSMV Model Checker,” in  2017 IEEE 
International  Conference  on  Software  Testing,  Verification 
and  Validation  (ICST),  Tokyo,  Japan,  Mar.  2017,  pp.  476–
483.  

[32]  J.  Fritzsch,  T.  Schmid,  and  S.  Wagner,  “Experiences  from 
Large-Scale  Model  Checking:  Verifying  a  Vehicle  Control 
System  with  NuSMV,”  in  2021  14th  IEEE  Conference  on 
Software Testing, Verification and Validation (ICST), Porto de 
Galinhas, Brazil, Apr. 2021, pp. 372–382. 

[33]      F.  N.  Kassab  Bashi  and  S.  S.  Khairullah,  “A  Survey  on 
Dependable Digital Systems using FPGAs: Current Methods 
and  Challenges,”  International  Journal  of  Advances  in 
Computer and Electrical Engineering., vol. 5, issue. 12, pp. 1–
8, December 2020.  

[34]        S.  S.  Khairullah  and  C.  R.  Elks,  “Self-repairing  hardware 
architecture  for  safety-critical  cyber-physical-systems,”  IET 
Cyber-Phys.  Syst.  Theory  Appl.,  vol.  5,  no.  1,  pp.  92–99, 
March 2020.  

[35]       S.  S. Khairullah and  A.  A. Mostfa,  “Reliability  and  Safety 
Modeling of a Digital Feed-Water Control System,” Journal 
of  University  of  Babylon  for  Pure  and  Applied  Sciences 
JUBPAS., vol. 28, no. 1, pp. 284–304, May 2020.  

 [36]      S.  Khairullah,  “Toward  Biologically-Inspired  SelfHealing, 
Resilient  Architectures  for  Digital  Instrumentation  and 
Control Systems and Embedded Devices,” Theses Diss., pp. 
1–144, December 2018.  

Authors Biography  

 Fayhaa Hameedi Khlaif, received the 
B.S.  degree  in  Computers  and  Infor-
mation Engineering from the University 
of Nineveh, college of electronics engi-
neering, Mosul, Iraq in 2010. Currently, 
she  is  working  for  M.Sc.  Degree  in 
Computer Engineering at Mosul’s Uni-
versity College of Engineering. Her re-
search interests include verification and 
validation, Formal methods, and fault-tolerant digital system 
design.  

Shawkat Sabah Khairullah, received 
the  B.S.  and  M.Sc.  degrees  in  com-
puter engineering from the University 
of Mosul, college of engineering, Mo-
sul,  Iraq  in  2006  and  2011.  He  re-
ceived  the  Ph.D. degree  in  Computer 
Engineering  from  Virginia  Common-
wealth University, Richmond, USA in 
2018. He is a Lecturer at the Univer-
sity  of  Mosul,  Iraq.  Dr.  Shawkat  research  interests  include 
dependable  digital  system  design,  VLSI,  bio-inspired  self-
healing hardware systems, and FPGA-based systems  

                                                                      www.ijaceeonline.com                                                                    13 

 
 
                                              
 
 
 
 
 
 
 
 
 
 
         
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
