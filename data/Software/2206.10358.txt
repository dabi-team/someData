Open Source Software: An Approach to Controlling Usage and
Risk in Application Ecosystems

Stan Zajdel
Stan.Zajdel@ibx.com
Independence Health Group
Philadelphia, PA, USA

Diego Elias Costa
diego.costa@concordia.ca
Concordia University
Montr√©al, Qu√©bec, Canada

Hafedh Mili
mili.hafedh@uqam.ca
LATECE lab, Universit√© du Qu√©bec √†
Montr√©al
Montr√©al, Qu√©bec, Canada

2
2
0
2

n
u
J

1
2

]
E
S
.
s
c
[

1
v
8
5
3
0
1
.
6
0
2
2
:
v
i
X
r
a

ABSTRACT
The Open Source Software movement has been growing exponen-
tially for a number of years with no signs of slowing. Driving this
growth is the wide-spread availability of libraries and frameworks
that provide many functionalities. Developers are saving time and
money incorporating this functionality into their applications re-
sulting in faster more feature-rich releases. Despite the growing
success and the advantages that open source software provides,
there is a dark side. Due to its community construction and largely
unregulated distribution, the majority of open source software
contains bugs, vulnerabilities and other issues making it highly
susceptible to exploits. The lack of oversight in general hinders the
quality of this software resulting in a trickle down effect in the ap-
plications that use it. Additionally, developers who use open source
tend to arbitrarily download the software into their build systems
but rarely keep track of what they have downloaded resulting in an
excessive amount of open source software in their applications and
in their ecosystem. This paper discusses processes and practices
that users of open source software can implement into their envi-
ronments that can safely track and control the introduction and
usage of open source software into their applications, and report
on some preliminary results obtained in an industrial context. We
conclude by discussing governance issues related to the disciplined
use and reuse of open source and areas for further improvements.

KEYWORDS
open source software, DevSecOps, SAST, SCA, Maven, NPM, PyPI,
SBOM, CI, pipeline automation

ACM Reference Format:
Stan Zajdel, Diego Elias Costa, and Hafedh Mili. 2022. Open Source Software:
An Approach to Controlling Usage and Risk in Application Ecosystems. In
Proceedings of ACM Conference (Conference‚Äô17). ACM, New York, NY, USA,
10 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION
The open source software industry has experienced an explosion
of growth in the last several years. It is predicted that the open

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
Conference‚Äô17, July 2017, Washington, DC, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn

source software market will continue to grow at a Compound An-
nual Growth Rate (CAGR) of 17% between 2021-27 and is expected
to reach USD $60 billion by 2026 (1). Fueling this growth is the
widespread adoption of open source software by businesses and
organizations [22].

The last several years have ushered in many changes in the way
organizations are approaching software development and deliv-
ery. To be more competitive, organizations have been increasingly
adopting practices such as Agile and DevOps to speed up develop-
ment and delivery of applications. The use of open source software
has enabled this growth by making available freely reusable capa-
bilities that can be easily integrated into applications thus reducing
time to market. Reports estimate that between 90% to 93% of all
businesses and organizations are using open source software in
their applications and systems [1, 5].

However, the unfettered use of open source software has a major
downside: organizations are increasingly relying, for their mis-
sion critical systems, on software of uncertain quality, developed
under processes of uneven quality. In his seminal‚Äìand much cited‚Äì
cathedral versus bazaar paper [29], Raymond argued convincingly
that several factors, characteristic of large and active open source
projects, contribute to the quality of the resulting software, includ-
ing the (very) large number of users, and the fact that these users
are themselves‚Äìoften sophisticate‚Äìdevelopers. While these condi-
tions held for Unix and its derivatives‚Äìthe textbook case of large,
complex, and successful open source software‚Äìthey are actually
the exception rather than the rule. Further, there is a qualitative
difference between functional and performance bugs, on the one
hand, and security vulnerabilities, on the other. Open source de-
velopers do not actively look for functional or performance bugs:
they encounter them in the context of their testing and produc-
tion. Security "bugs", on the other hand, are of a different nature:
malicious intent is needed to exploit what often amounts to an
implementation‚Äôs permissiveness beyond the original functional
specification. A recent study indicates that up to 40% of the Node.js
packages rely on code with known vulnerabilities [34], which can
affect the security and stability of the applications dependent on
this software (3).

While organizations cannot control the upstream processes used
to develop the reusable software they integrate in their own prod-
ucts, they can at least control downstream which reusable compo-
nents go into their products, based on documented or suspected
security vulnerabilities. The challenge is to do so in an efficient
manner, and in a way that does not break the agility of their own
software development processes. This paper reports on the efforts of
an organization‚Äìa sizable health insurance corporation‚Äìto address

 
 
 
 
 
 
Conference‚Äô17, July 2017, Washington, DC, USA

Zajdel et al.

this challenge, through a combination of automation, education, and
governance. Our strategy rests on the following hypotheses and
principles:

‚Ä¢ (ùêª1): open source software (OSS) is of uneven quality
‚Ä¢ (ùêª2): there is enough information out there, both direct, and

indirect, to assess the quality of available OSS

‚Ä¢ (ùëÉ1): we should strive to minimize the disruption to the work

flow of developers, but

‚Ä¢ (ùêª3): adequately ‚Äôeducated‚Äô developers can help reduce the

disruption.

Developers have come to rely on large ecosystems of OSS libraries
to deliver feature-rich applications in record times, by focusing
on domain functionality and reusing the rest. Principle ùëÉ1 says
that we should not break this agility in the process of improving
OSS quality. Our preliminary results show that this is possible (see
Section 4).

This paper focuses on the automation component of our strat-
egy, with education and governance briefly discussed in Section 5.
Per principle ùëÉ1, we let developers use whichever OSS library gets
the job done, and then flag problematic ones during the DevOps
pipeline‚Äìwe then talk about DevSecOps pipelines (see Section 3.1).
This is done by parsing build scripts to identify first order depen-
dencies (see Section 3.3), and querying a database that documents
OSS libraries that are known to the organization. This database
combines information gleaned from the (US) National Vulnerability
Database (NVD1), and from other sources, including the results of
our own investigations. Libraries entered into our database are in
one of three states: 1) allowed, if they are know to be of good quality,
with no or few security vulnerabilities, 2) disallowed, if they have
documented security vulnerabilities, and 2) under evaluation, with
self-explanatory meaning. The first time a library is encountered
in a build, it is put under evaluation, and the owner of the build is
notified (see Section 5.3). If a build includes a disallowed library, it
is given a reprieve, the first time it is submitted, with the owners of
the build notified and urged to remove or replace the faulty library
within a period of time, after which the build will fail (see Section
5.3), unless the developers present a very good argument of why it
should be allowed.

The next section provides an overview of the problems raised by
the extensive availability and use of OSS libraries in mission critical
applications (Section 2), and introduces the company context (Sec-
tion 2.3); to the extent that a single organization cannot control the
‚Äôsupply chain‚Äô of open source software (Section 2.1). Our solution
focuses on the developers‚Äô usage of OSS libraries (Section 2.2). Sec-
tion 3 presents our solution that relies on automation within the
context of a DevSecOps pipeline. Our DevSecOps pipeline, which
implements part of the vision described in Section 3), has been in
operation for X months and has shown great promise in reducing
the security exposure of our applications, with very little effect
on the productivity of developers; the preliminary results are pre-
sented in section 4. We discuss future steps towards completing
the DevSecOps pipeline (automation), but also towards developer
education and enhanced governance, in Section 5. Related work is
discussed in Section 6; we conclude in Section 7

1https://nvd.nist.gov

2 THE PROBLEMS WITH OPEN SOURCE
In this section, we describe two groups of problems related to open
source software. We start by describing the problems at the open
source supply chain level (Section 2.1) and then describe problems
with developer usage of that software (Section 2.2). Each are result-
ing in excessive risk to the security, quality and maintainability of
applications that use that software.

2.1 Problems at the Open Source Supply Chain

Level

The open source software community is generally an unregulated
industry. The majority of projects are maintained by either a single
developer or a small team of volunteer developers, motivated by
intrinsic and internalized motivators [13]. How often they actually
have the time and resources to properly test and maintain their
code is virtually unknown, and not subject to any formal process.
Many open source projects are not properly maintained [7, 17] and
lack formal testing [2], which puts the responsibility of ensuring
code quality on their users. The lack of documented proof that the
software has been rigorously tested for both security and quality
at the community level is contributing to many problems - some of
the major ones are described below:

(1) Bugs and Vulnerabilities: At the top of the list are the bugs
and vulnerabilities that are prevalent in any type of software.
The general lack or tailored security testing in open source
development exacerbates this problem. While it‚Äôs been ar-
gued that the sheer number of open source contributors are
actually limiting the number of bugs and vulnerabilities the
flip side of that argument is the fact that there are almost an
equal number of bad actors who are also downloading and
analyzing that code to discover ways to exploit and attack
the software [3, 10]. The recent log4shell issue, among many
others, is a prime example of this situation and it was fortu-
nate that the issue was discovered and prudently reported
by a researcher thus preventing a world-wide disaster [33].
(2) Intentional Sabotage: Another problem that is prevalent
in open source software is the intentional sabotaging of the
software by contributors [12]. One recent example of this
was the intentional sabotaging of two very popular libraries,
Color and Faker, by the maintainer who was disgruntled at
how profitable corporations were using open source soft-
ware. The maintainer deliberately added an endless loop
into the Colors library and it was subsequently downloaded
roughly 23 million times [31]. Another more recent example
of intentional sabotage happened on a popular library called
node-ipc [24]. The maintainer, in protest of the Russian in-
vasion of the Ukraine, maliciously added code to replace
files with a heart emoji and a peace-not-war module. The
malicious code was designed to specifically target users with
IP addresses located in Russia or Belarus. An act like this
could easily be targeted everywhere. This highlights, again,
the general lack of oversight and quality testing that would
have most likely caught these issue prior to being uploaded
into the public repository.

(3) Repository Poisoning: Repository poisoning is another
issue that has occurred in the repositories that house open

Open Source Software: An Approach to Controlling Usage and Risk in Application Ecosystems

Conference‚Äô17, July 2017, Washington, DC, USA

source code such as Maven, NPM and PyPI [12, 32, 34]. Bad
actors are known to create libraries that mimic valid libraries
and intentionally add vulnerable code in them [34]. The li-
braries are then renamed slightly different to closely match
the legitimate versions and uploaded to the repository. Devel-
opers arbitrarily download those poisoned libraries without
paying much attention to the name which results in the un-
noticed introduction of an exploitable library into their code
base.

(4) Inadequate Documentation: Additional issues include an
overall lack of adequate documentation for much of the open
source software. According to a recent GitHub survey, 93% of
the respondents noted that incomplete or outdated documen-
tation is a pervasive problem leading to misunderstandings
on how to use that software ultimately leading to application
bugs and instability [15].

(5) Software Bloat: The collaborative nature of open source
software, while a good thing, also has it‚Äôs drawbacks - one
of them being that it can lead to bloat. For many projects
there is no central authority to monitor which features are
being added to the software. This can lead to a number of
issues such as bloat or a drift from the intended requirement
for the software. This can lead to an increased attack surface,
unintentional bugs or an overall lack of quality that can
negatively affect the applications using this software [28].

2.2 Problems with Developer Usage of OSS
It has been our experience that developers who use OSS tend to ar-
bitrarily download the software into their build systems but rarely
keep track of what they have downloaded, and even when they do,
they hardly keep track of which versions they use [20]. This hap-
pens during normal feature development cycles where developers
are exploring the solutions space. Upon settling on a specific solu-
tion, they seldom go back and remove the other unused software
that they‚Äôve added. The result is unnecessary software being left
in an application which can potentially increase the risk of attack.
This problem is exacerbated when other developers are doing the
same thing in their projects ultimately leading to a lot of excess
software in the application ecosystem.

Developers also tend to favor the open source libraries that they
are comfortable in using or due to the popularity level of that
specific software [20, 23]. This leads to many different libraries that
provide similar capabilities that clutter the application ecosystem.
This also adds risk to the overall application environment and cost
of maintainability in that developers are required to support the
use of unfamiliar libraries.

The problems as described above are resulting in organizations
assuming tremendous security and stability risks as well as an
increase in overall maintenance costs. It is unrealistic to expect
organizations to abandon open source. On the contrary, the use
is going to continue to grow and correspondingly the number of
issues are going to increase as well therefore it falls upon the users
of open source to find solutions to reduce that risk. Automation is
the key.

Figure 1: DevOps automation pipeline

2.3 Company Context
The organization that is referenced in this paper is a large national
insurance firm with a diverse application portfolio. The majority of
the application portfolio has been written in house by a develop-
ment staff of 400 software developers. The organization has been
leveraging open source software for a number of years and have
recently adopted agile and DevSecOps practices. The adoption of
DevSecOps has lead to the widespread exposure of vulnerabilities
and other issues within the application ecosystem, hence the need
for a solution to control open source usage.

3 USING AUTOMATION TO REDUCE OPEN

SOURCE RISK

3.1 From DevOps to DevSecOps
Short of controlling the uncontrollable‚Äìthe way OSS is built and
its quality assured (see Sec. 2.1)‚Äìwe can control it use (see Sec.
2.2). Recall, from the introduction, that our approach rests on the
following hypotheses and principles:

‚Ä¢ (ùêª1): open source software (OSS) is of uneven quality
‚Ä¢ (ùêª2): there is enough information out there, both direct, and

indirect, to assess the quality of available OSS

‚Ä¢ (ùëÉ1): we should strive to minimize the disruption to the work

flow of developers, but

‚Ä¢ (ùêª3): adequately ‚Äôeducated‚Äô developers can help reduce the

disruption.

Per principle ùëÉ1, it is critical that we do not break the agility of
developers while they explore the solution space for their develop-
ment problems. Thus, we should not exert our control of OSS usage
downstream from the highly creative phase of coding, but upstream
from deployment. DevOps is a set of practices and tools that aims at
automating the continuous delivery of new software updates while
ensuring their correctness and reliability [21]. Automated build
and deployment pipelines are an integral part of a DevOps practice.
DevSecOps, as a practice, is an extension of DevOps that enables
development (Dev), operations (Ops) and security (Sec) teams, to
work jointly to ensure the continuous delivery of software updates
that are devoid of security vulnerabilities. Thus, we argue that the
proper place to control OSS usage is at the CI pipeline.

A typical continuous integration (CI) DevSecOps pipeline in

illustrated in Figure 1 and involves the following steps:

(1) Code is committed to a repository
(2) CI pipeline automatically detects the code commit and starts

a build

(3) After the Build completes, unit tests are run

CI Process kicks off after code commitSourceControlBuildUnit TestingSASTPackagingSCAEach Step in the CI pipeline results in a Pass or FailConference‚Äô17, July 2017, Washington, DC, USA

Zajdel et al.

(3) Based on its findings, it can apply organization-specific busi-

ness rules to take remedial actions.

Figure 2: Identifying dependencies in a build in the DevOps
pipeline

(4) Static Application Security Testing (SAST) is performed
(5) The code is packaged
(6) Source Composition Analysis (SCA) is performed on the

package

(7) The package is deployed to an internal repository

Static Application Security Testing (SAST) consists of checking
the code base against a set of coding rules that embody best secu-
rity practices‚Äìor conversely, ‚Äôsecurity smells‚Äô‚Äìas defined by the
tool. Popular tools on the market include SonarQube, Veracode,
Checkmarx and Synopsis.

Source Composition Analysis (SCA) provides visibility into the
open source components and libraries that are incorporated into
application build systems. Source composition analysis helps to
identify licensing issues and vulnerabilities by cross-referencing
the information in such sources as the National Vulnerability Data-
base (NVD) and others. Popular tools include Nexus IQ, Snyk and
Synopsis.

While such CI pipelines have been shown to be fairly effective at
exposing bugs, vulnerabilities and other issues, they suffer from one
major problem: the source composition analysis (SCA) is performed
way too late in the process, with two major consequences:

‚Ä¢ The process is wasteful. To the extent that the inclusion of
a given library, or a specific version thereof, with a critical
security vulnerability is usually a show-stopper, it seems
wasteful to work on passing the earlier gates (unit tests,
SAST, packaging), to have the work thrown away

‚Ä¢ Once an application is built, functional, and packaged, it
may be tempting to overlook security concerns and deploy
anyway, "until we can find the time to fix it".

Accordingly, we chose to modify the typical DevSecOps pipeline
by moving upstream the control of the usage of OSS: in fact, OSS
usage control is now the first step in the DevSecOps pipeline, as
illustrated in Figure 2.

Specifically, we envision a (RESTful) service that is triggered by
source control commits and that performs the following (see Figure
3):

(1) It analyzes the application being built to identify its depen-
dencies. It first identifies the build type, to then locate the
build configuration files from which it can read/retrieve the
dependencies.

(2) It checks the uncovered dependencies against a Dependency
Reference Database that contains information about known
libraries, including known vulnerabilities, their severity level,
and eventual remediation strategies.

Figure 3: Process of recording dependencies in the Depen-
dency Reference Database (RDR) during a Build

In the remainder of this section, we will elaborate on, 1) the
contents of Dependency Reference Database (DRD) (Section 3.2),
and 2) a web service used primarily to populate the Dependency
Reference Database (DRD), called the Dependency Reference Service
(DRS) (Section 3.3).

3.2 The Dependency Reference Database (DRD)
SBOM - A Software Bill of Materials. A software bill of mate-
3.2.1
rials (SBOM) is a list of components in a piece of software. Software
vendors often create products by assembling open source and com-
mercial software components. The SBOM describes the components
in a product. It is analogous to a list of ingredients on food packag-
ing where you might consult a label to avoid foods that may cause
an allergic reaction. SBOMs can help organizations or persons to
avoid consumption of software that could harm them [5].

Most source composition analysis (SCA) tools, which scan li-
braries for known vulnerabilities, keep track of an SBOM for the
applications that are being analyzed which usually includes both
direct and indirect, or transitive, dependencies. A transitive depen-
dency is a dependency that is introduced by the direct dependencies
that a developer physically includes in their software build config-
urations.

In this approach however, a different kind of SBOM is used -
only direct dependencies are tracked. The reason why this solution
is only concerned about direct dependencies is because a direct
dependency and it‚Äôs version are controlled by the developer whereas
a transitive dependency depends on library maintainers‚Äô decisions.
Hence, the SBOM, as defined by this solution, is designed to track
solely direct dependencies and the versions of those dependencies
that are in use. Figure 4 shows a typical Maven dependency tree
That displays both direct and transitive dependencies. The SBOM
for our solution is only concerned with the direct dependencies as
listed in Table 1.

Note that the SBOM is also designed to track internally-developed
libraries which are just as important and subject to the same risks
as an open source library. The ci-common dependency above is
an example of an internal dependency.

CI Process kicks off after code commitSourceControlBuildUnit TestingSASTPackagingSCADependency CheckEach Step in the CI pipeline results in a Pass or FailThe dependency check is performed before the build stepPipelineWeb ServiceDependencyReferenceDatabaseAccesses the build type and locates the build configurationParse appropriate file to extract  direct dependencies and versionsCheck each dependency and return list of not allowed dependenciesStep defined in the pipeline to send repo name and branch to the web serviceOpen Source Software: An Approach to Controlling Usage and Risk in Application Ecosystems

Conference‚Äô17, July 2017, Washington, DC, USA

(1) Dependency Group table stores the group or organization
name that created the dependency (library). Maven build de-
pendencies for example contain a group such as org.apache,
etc while NPM build configurations generally do not so a
default value can be substituted for all NPM dependencies.
(2) Dependency Category table stores the category of a depen-
dency. Dependencies can be categorized by functionality or
technology (JSON parser, File Utilities, MVC framework).
Categorizing dependencies can help users search and iden-
tify dependencies that can be used for specific purposes.
(3) Dependency table stores the name of the dependency and the
category that the dependency belongs to. (e.g. JSON Parsers,
XML Parsers, Date formatters, etc.).

(4) Dependency Version table stores the version of the depen-
dency, date that the dependency was introduced into the
ecosystem, status of the particular version of the dependency,
effective and end date to indicate the usage time frame of
the dependency version and the justification for why the
dependency was rejected.

(5) Dependency Status table stores the status of the dependency
and version. The status is used to determine if the depen-
dency and version is allowable into a build system. Initially
there are 4 statuses: Not Reviewed, Approved, Deprecated
and Rejected.

(6) Application Dependency table stores which applications use

the dependency.

3.3 Dependency Reference Service (DRS)
Figure 3 showed a web service that is triggered by commits in the
source control systems to analyze the application against a refer-
ence database of dependencies (DRD), with potential documented
vulnerabilities. This raises the question: how is the DRD populated?
In fact, the DRD is populated by two services:

(1) the web service described in Section 3.1 (Figure 3), which
acts synchronously to build requests/commits to source code
repositories, and

(2) an asynchronous service, whose job is to fill out the vulnera-

bility information (Fig . 6).

We explain the interplay in more detail below.

At time ùë° = 0, when the CI pipeline of Figure 2, the DRD is empty.
As new builds are requested and SBOMs are created (Section 3.2.1),
we encounter dependencies for the first time‚Äìe.g., a specific version
of the xerces XML parser‚Äìthat were not known to the DRD. Those
are thus entered in the DRD with status NotReviewed (see 3.2.2);
such dependencies may be given a reprieve of a predetermined time
duration until their vulnerability status is determined. In parallel,
our DRS service can regularly (daily, hourly, etc.) check external
sources for security information about the newly added dependency.
These include the National Vulnerability Database, as well as public
repositories that publish vulnerability information in consumable
format (see Figure 6). In case a query to the NVD, say, identified a
vulnerability, the status of the corresponding dependency is updated
in the DRD. Note that this does not only concern NotReviewed
dependencies: new vulnerabilities are found regularly in libraries
that were thought to be safe.

Accordingly, the DRS is invoked periodically to:

Figure 4: Maven Dependency Tree

Direct Dependencies
javax.servlet:javax.servlet-api:jar:3.1.0
org.json:json:jar:20160807
org.apache.maven:maven-model:jar:3.1.0
com.acme.deveops.ci.common:ci-common:jar:1.0-SNAPSHOT
io.jsonwebtoken:jjwt-api:jar:0.11.2
io.jsonwebtoken:jjwt‚Äìimpl:jar:0.11.2
io.jsonwebtoken:jjwt-jackson:jar:0.11.2
junit:junit:jar:4.12

Table 1: Direct Dependencies

Figure 5: Dependency Reference Database (DRD) entity dia-
gram

3.2.2 Dependency Reference Database (DRD) Schema. As described
above, the SBOM represents an inventory of direct dependencies
that are in an application build configuration. The dependency
reference database (DRD) is central to tracking and controlling the
use of open source and internal dependencies. At a minimum the
dependency reference database will consist of the following tables
(see Figure 5):

DependencyGroupDependencyStores the dependency nameStores the group that the dependency belongs toStores the dependency version, status, effective and termination datesStores a list of all categories that describe a dependencyDependencyVersionDependencyCategoryDependencyStatusStores a list of all statuses that a dependency version can beApplicationDependenciesStores all direct dependencies for each applicationConference‚Äô17, July 2017, Washington, DC, USA

Zajdel et al.

Table 2: Breakdown of Java libraries used in the company
application ecosystem per library domain

Library Domain
Web Frameworks
Logging
Database Connectivity
REST framework
SOAP
PDF
Email
ORM
XML Parser
Encryption
JSON Parser
Date/Time Parser
Charting
Caching

# of Different Libraries
60
54
52
43
30
34
21
21
18
16
12
8
7
6

Figure 6: Process of identifying new dependency versions
and vulnerabilities

(1) Pull the dependencies from the Dependency Reference Data-

base

(2) Search the public repositories (Maven, NPM, Nuget, etc.) for

the latest versions

(3) Search the National Vulnerability Database (NVD and other

sources) for the latest vulnerabilities

(4) Update the Dependency Reference Database with the latest

information and notify development teams

Upon notification of the updates the development teams can take
the necessary steps to assess and schedule the updates into their
applications.

4 PRELIMINARY RESULTS
In this section, we report on the preliminary results of applying the
initial steps of our approach. We focus on discussing 1) the current
state-of-affairs of open source code usage in the company applica-
tions‚Äô ecosystem, and 2) we describe two use-cases where better
open source control and governance has the potential to save costs
in security mitigation strategies and dependency management.

The organization where our approach is been implemented con-
tains a total of 780 software repositories. After the SBOM was
populated and analyzed, the SBOM helped identify approximately
1,000 reported vulnerabilities on the 450 versions of dependencies
used in the 780 repositories. Furthermore, an average of 3 to 5 new
vulnerabilities on those versions are being reported per day, indi-
cating a trend of increase overhead in dependency management.

Among the 780 repositories, the portfolio of the companies
project is divided into 527 Java repositories, 211 .NET repositories,
and 42 JavaScrip repositories. Taking only the 527 Java ecosystem
into account, once SBOM was put in place, we identified 1,986
different Java open source libraries versions, including solely di-
rect dependencies. Table 2 shows the breakdown of libraries for
the 15 most common library domains in the company application

ecosystem. One can observe a plethora of options currently main-
tained by the company developers. For instance, the SBOM showed
that across all Java projects, developers maintain 60 different Web
frameworks, 54 different logging libraries, and 52 different Data-
base connectivity libraries. This shows that open source usage, if
left unchecked, can lead multiple teams of developers maintaining
dozens of different libraries for the same purpose. Each library in-
curs in its own maintenance costs: each library contains its own API,
are maintained by different teams with potentially different update
policies, and are subject to their own set of reported vulnerabilities.
We present in Tables 3 and 4, a list of currently used Java libraries
for XML and JSON parsers per version, and their respective number
of Vulnerabilities, as reported by the company security tooling. We
highlight the dependencies that contain at least one vulnerability
in bold. The highlighted XML dependencies account for a total of
20 vulnerabilities affecting a total of 29 library versions. Notice
that the remaining XML parsers, used by the company applications,
contain no vulnerabilities. This outlines two problems: the use of
multiple dependencies that provide the same basic functionality and
several of them are vulnerable. It would make sense then that by
reducing the number of XML dependencies to possibly one or two
that are not vulnerable then that will eliminate the vulnerabilities
entirely. It would also reduce maintenance and training costs since
developers would not be required to know the intricacies of every
XML parser.

We found a similar picture when analyzing JSON parsers (see
Table 4). Two libraries reported 3 vulnerabilities across 11 different
versions, however, all other libraries used by the company applica-
tion ecosystem reported zero vulnerabilities, at the time of analysis.
There were many other similar occurrences across that organiza-
tion‚Äôs ecosystem. Without an SBOM and automated pipelines to
track the dependencies being introduced there would be no easy
way to identify and control open source usage.

PipelineServiceDependencyReferenceDatabaseService to coordinate the retrieval, updates and notification of new versions of dependencies and the latest vulnerabilitiesRetrieve the latest vulnerabilities from the NVDDaily service to identify new versions of dependenciesNationalVulnerabilityDatabaseRetrieve newest versions of artifacts from Maven, NPM, NuGet, etcPublicRepositoriesOpen Source Software: An Approach to Controlling Usage and Risk in Application Ecosystems

Conference‚Äô17, July 2017, Washington, DC, USA

Table 3: Java XML parser dependencies found in the applica-
tion ecosystem of studied company. The column ‚Äú# of Vulns‚Äù
showcases the total number of vulnerabilities affecting all
dependency versions.

XML and JSON Parsers

xstream
xmlsec
jackson-dataformat-xml
dom4j
jdom
xom
xmlbeans
xalan
xmlschema
xerces
sax
xml-aps
xmlpublic
aalto-xml
javax.xml.stream
xmlpull
xpp3_min
xmlsec

# Vulns
6
6
3
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0

# Versions
4
3
13
2
1
1
3
2
1
1
1
2
1
1
1
1
1
1

Table 4: Java JSON parser dependencies found in the applica-
tion ecosystem of studied company. The column ‚Äú# of Vulns‚Äù
showcases the total number of vulnerabilities affecting all
dependency versions.

JSON Parsers

json-smart
gson
json
json-lib
json-simple
json-path
javax.json-api
tapestry-json
wink-json4j
jakarta.json
json4s-core
jsonschema2pojo-core

# Vulns
2
1
0
0
0
0
0
0
0
0
0
0

# Versions
4
7
10
3
2
1
1
1
1
1
1
1

5 DISCUSSION
5.1 Where to from here?
The envisioned DevSecOps pipeline described in Section 3.1 is par-
tially implemented. The two services described in Figures 3 and
6 have been implemented and are fully operational, providing us
with the results described in Section 4. However, the policies that we
mentioned in sections 3.1 and 3.3 have not yet been implemented.

Example policies include deciding what to do when an applica-
tion is found that depends on a library with known vulnerabilities.
Alternatives include:

(1) Informing a designated representative of the team that com-
mitted the code triggering the dependency check of the se-
curity vulnerabilities, without failing the pipeline.

(2) Informing the designated representative of the vulnerabil-
ities, giving the build a reprieve to migrate to a different
library or to a patched library version, if one exists, possibly
blocking the OPS part of DevSecOps in the meantime.
(3) Informing the designated representative of the vulnerabili-

ties, and failing the build right away.

A similar range of alternatives may apply to dependencies encoun-
tered the first time (status NotVerified). For the time being, we
have not implemented such policies/rules, for several reasons:

(1) We have to design such policies, in a consensual way that

balances safety and agility,

(2) We have to educate developers about our DevSecOps ap-
proach, and the rationale behind any policies we might come
up with,

(3) The DRD has to have ‚Äôenough coverage‚Äô for the policies to

make sense,

(4) We have to set-up the appropriate processes and structures

to make this work.

In the remainder of this section, we will touch upon some of these
issues.

5.2 Developer Education
Needless to say, security is everybody‚Äôs business and developers
are prime stakeholders in the process. While we strive to minimize
the disruption to their work flow, having one‚Äôs build fail, after the
fact, because they used the wrong library, is wasteful and can be
frustrating to developers. Thus, it is important that developers be:
1) educated about the rationale between the process, and 2) perhaps
trained, to the extent that it is possible, to avoid having their builds
fail.

Thus, a series of training workshops need to be created to provide
the necessary education and awareness to the development teams.
Some of the topics to be covered included:

‚Ä¢ An introduction of the new policies and the reason why the
organization has undertaken this effort. The developers need
to understand the importance of controlling open source
software usage and why it will benefit the organization as a
whole.

‚Ä¢ A set of guidelines for development teams to follow and
ensure that all open source software that is introduced into
the application ecosystem is done in a responsible, systematic
and governed way.

‚Ä¢ How to use the dependency reference web application and to
always consult the web application to find the software and
versions that are sanctioned for use prior to looking outside.
‚Ä¢ Developers need to be taught to focus more attention to
what software they are using and to ensure that their build
configurations are always kept up to date.

Conference‚Äô17, July 2017, Washington, DC, USA

Zajdel et al.

5.3 A Software Vetting Process
The Dependency Reference Service (DRS) of Figure 6 was shown to
pull its information from the National Vulnerability Database (NVD)
as well as public repositories where OSS is maintained. However,
it is unrealistic to assume that all the quality-related information
about OSS can be found: 1) in public repositories, and 2) in query-
able fashion. First, the NVD cannot possibly be exhaustive. Second,
security vulnerabilities are but one reason, among many, for not
using an OSS library. Finally, we will likely not find direct quality
metrics, although machine learning techniques may be used to
correlate quality with available metrics. For these reasons, and for
the short/mid-term, the Dependency Reference Database (DRD)
will be populated partially manually, by a governance committee
whose job is to vet new dependencies or dependency versions that
are encountered for the first time in a build, and that may not have
been found in the NVD. Such a committee, which should include
subject matter experts and security specialists, will need to ask the
following questions about any new OSS component detected by
the build dependency service (Fig. 3):

(1) Is there an approved component that provides the same func-
tionality? One of the key functionalities of this effort is to
ensure that software with duplicate capabilities are kept out
of the ecosystem or at least kept to a minimum.

(2) How many vulnerabilities and what is the severity? Another
key functionality of this effort is to ensure that any new
software that is introduced into the ecosystem contains no
critical vulnerabilities. Source composition analysis tools,
if available, can easily provide that information otherwise
other sources such as the National Vulnerability Database
can be consulted.

(3) Is it actively maintained? There are many open source projects
that are not actively maintained resulting in outdated soft-
ware that in most cases can lead to unpatched vulnerabilities
and other quality issues. A thorough research on the commit
history of that software, if available, should be performed.
(4) Who is the maintainer? If the software is being maintained
by well-known organizations such as Google, The Apache
Foundation and IBM then there can be some assurance that
the development team has resources to respond to reports
of vulnerabilities, write extensive test suites, and respond to
the community feedback, than repositories maintained by
single developers.

(5) How do they view security? Viewing the commit logs and bug
reports for the software, if they exist, will shed light on how
the maintainer views security. Quick remediation strategies
and well-documented updated patches are a good indicator
that security and quality are important to the maintainer.
(6) What is their issue history? Viewing the bug logs, if they exist,
is a good indicator of the quality history of the software.

5.4 Research, Categorize, and Reduce
The preliminary results shown in Section 4 showed that we have
way too many OSS libraries in our application portfolio the perform
similar or identical functions, security vulnerabilities notwithstand-
ing. Recall from table 2 the number of web frameworks (60!), logging
frameworks (54), or database connectivity frameworks (52) in use
at the company. The multiplicity of libraries reduces knowledge
sharing between teams, and increases maintenance costs.

Thus, one of our goals is to research each dependency and version
that is found in our applications ecosystem, and reduce the number
to smaller (sub)set of approved components. This will be part of
the mandate of the governance committee mentioned above. Some
of the criteria that should be considered are:

(1) Identify and eliminate duplicate functionality: Identify the
software that provide the same functionality. For instance,
there may be two or three model, view, controller (MVB)
frameworks that are currently found to be used in the appli-
cations. The question should be asked: "Do we really need
multiple MVC frameworks in those software projects?". Af-
ter some amount of research has been performed the answer
may be "No" therefore one (or few) MVC framework should
be decided based on factors such as capabilities, best fit,
number of vulnerabilities, etc.

(2) Preference of native language features versus open source li-
braries: In some cases, the best architecture practice may be
to remove an open source or home-grown library altogether
in favor of the native functionality of a given software devel-
opment language. A common evolution in software language
development has seen elements incorporated into the native
language that may have been addressed in an open source
component. There are many instances where certain capa-
bilities in a language were either not included or was not
performant enough which resulted in it‚Äôs inclusion into open
source. If the functionality is the same then it is preferable
to use the native language rather than the open source thus
eliminating a possible open source risk.

(3) Choose the open source dependencies that are least vulnerable.
Source Composition Analysis (SCA) tools can help identify
the vulnerabilities and their respective severity levels which
will aid in choosing the best software to use.

Note that the SBOM in this solution not only contains open
source dependencies it also tracks internally-built dependencies
as well. Initially it might prove easier to identify and review the
internal dependencies as there may be multiple versions of these
dependencies in the ecosystem. Since this software is usually built
in-house it is much easier to consolidate and standardize on one
or two versions of these dependencies before reviewing the open
source which may be more challenging.

As new software versions are approved, older versions of an OSS
component may be put into a deprecated status. For high security
threat libraries, the deprecation process will happen in a rapid,
blacklisting effort blocking further use sooner rather than later as
determined by management. For lower threat libraries, the phase-
out process will happen within a carefully orchestrated process to
support those apps that need the library.

6 RELATED WORK
In this section, we discuss the related literature from two main
perspectives. First, we discuss works that have focused in describing
the challenges in open-source software usage. Then, we discuss
industrial reports that propose approaches for mitigating OSS usage
problems.

Open Source Software: An Approach to Controlling Usage and Risk in Application Ecosystems

Conference‚Äô17, July 2017, Washington, DC, USA

6.1 Challenges of Open Source Usage
A wide range of works have focused in challenges of open-source
dependency management, from selecting well-maintained software
libraries [2, 7, 8, 23], to establishing good update policies [6, 16, 30].
Abdalkareem et al. investigated why developers tend to select pack-
ages even to implement trivial programming tasks [2]. According
to the authors, developers select trivial packages because they per-
ceive them to be well implemented and tested, when in fact 45% of
the packages did not even have explicit tests. As developers tend to
select libraries based on their popularity in the community, Mujahid
et al. discuss the problems of current popularity metrics [23]. In
their work, they find that major popularity metrics (dependencies,
downloads) are not well-correlated to what the community actu-
ally uses, which could lead developers to selecting outdated legacy
packages for their projects. Similarly, Coelho et al. proposed a data-
driven approach to identify well-maintained projects in Github [7],
showing that 16% of studied projects tend to be unmaintained for
more than a year.

To effectively use open-source code, developers have to con-
stantly update their dependencies to get the latest big fixes and vul-
nerability patches. Kula et al. report that developers, in fact, do not
frequently update their dependencies, with 81% of studied projects
relying on outdated library versions [19]. On a similar note, Jafari
et al. discuss challenges of dependency management [16]. They
identify seven recurring dependency management issues, named
dependency smells, which can on the long term increase the num-
ber of bugs and vulnerabilities of a package. The authors quantified
the occurrence of such dependency smells and reported that the
vast majority of libraries (92%) has at least one dependency smell
in their manifest files. C√¥go et al.‚Äôs work on dependency down-
grades also provides great insights on the challenges of dependency
management and shows that dependency downgrades can be a
workaround for update-related issues in client code [30]. This is
partially explained by Bogart et al.‚Äôs survey with developers from
18 ecosystems which shows that updates in packages often break
the code of their client, requiring modifications in the client code
[6].

Many researchers have studied the presence of software vulner-
abilities in open source dependencies [3, 10, 11, 14, 18]. Decan et
al. investigated the life-cycle of vulnerabilities in npm, showing
that the number vulnerabilities are growing over time and take in
median 24 months to be discovered [10]. Alfadel et al. replicated
their study in the Python ecosystem and reported that Python vul-
nerabilities take even longer to be found (3 years in median), and
are frequently made public before there is no remediation strategy
in place, increasing the risk of exploitation [3]. To make matters
worse, Kula et al [19] also report that developers are frequently
unaware that their projects depend on vulnerable dependencies. In
their survey, 69% of the respondents were unaware their project
depended on vulnerable library. To account for this widespread
problem of software vulnerabilities, the open source community
has also proposed a few solutions [4]. Approaches such as Depend-
abot [4] have been well-received by the community as they help
developers keep their dependencies up-to-date and raise awareness
for the occurrence of software vulnerabilities.

All the above mentioned works have been conducted primarily
in the open source world. The authors focused on studying the
challenges of reusing open source code in open source projects.
Our work complements the above mentioned literature by bringing
an industrial perspective to the problem. We discuss a framework
that helps mitigate the risks of using open source code in a large
company, and each component of our DevOps pipeline can also be
employed by teams working in open source projects.

6.2 Industrial Approaches to Mitigate the Risks

of Using Open Source Code

While the interest on the challenges of open source usage in indus-
try has spiked in the last several months with the recent cases of
log4shell [33], we found that industrial reports on OSS control and
governance is still largely unexplored. Still, there are some recent
works that focuses on the challenges of using open source in an
industrial scale, which we describe next.

Plate et al. investigated how application vendors in industry de-
termine if a reported vulnerability puts their application at risk [27].
According to the authors, current decision making process relies
mostly on vulnerability descriptions and expert knowledge, hence,
being time-consuming and error-prone. Dann et al. evaluated the
robustness of popular code vulnerability scanners to changes in
code packaging strategies, commonly employed in industry [9]. The
study also showed that major technology companies, such as SAP,
rely extensively on open source code, with 86% of dependencies of
proprietary projects coming from open source projects. Ponta et al
discussed approaches for dealing with bloated dependencies [28].
They evaluated three approaches that use code analysis to iden-
tify redundant code (DepClean, Maven Shade, and Pro Guard) and
were all similarly effective in de-bloating applications. The authors
also report that such de-bloating strategies were effective in reduc-
ing the attack surface of two industrial applications. Pashchenko
et al. discussed the overhead of reported dependencies with un-
exploitable vulnerabilities in [25]. They also survey developers on
dependency management in [26] and find that most developers
find that software composition analysis (SCA) tools generate many
irrelevant and low-priority alerts.

Our study continues the thread of above mentioned works in
improving how open source code is used in an industrial environ-
ment. While still in its early phase, the proposed approach attempts
to cover multiple aspects of open source control and governance,
and can be employed on different industrial settings to mitigate the
risks that come with open source usage.

7 CONCLUSION
In this paper, we discussed the risks related to using open source
libraries and proposed an approach to help mitigate such risks, with
better control of OSS code reuse. Our approach focuses on using
automation to reduce open source risks, by including a control
mechanism in the DevOps pipeline to help document all the depen-
dencies used in a company‚Äôs software ecosystem and vet libraries
that are deemed risky by experts and stakeholders. This process
is currently being implemented by a large company with more
than 400 developers and we discuss the potential for saving costs
by reducing library redundancy and dependency overhead. The

Conference‚Äô17, July 2017, Washington, DC, USA

Zajdel et al.

[18] Riivo Kikas, Georgios Gousios, Marlon Dumas, and Dietmar Pfahl. 2017. Structure
and Evolution of Package Dependency Networks. In Proceedings of the 14th Inter-
national Conference on Mining Software Repositories (Buenos Aires, Argentina)
(MSR ‚Äô17). IEEE Press, 102‚Äì112. https://doi.org/10.1109/MSR.2017.55

[19] Raula Kula, Daniel German, Ali Ouni, Takashi Ishio, and Katsuro Inoue. 2018. Do
developers update their library dependencies? Empirical Software Engineering 23
(02 2018), 1‚Äì34. https://doi.org/10.1007/s10664-017-9521-5

[20] Raula Gaikovina Kula, Daniel M German, Ali Ouni, Takashi Ishio, and Katsuro
Inoue. 2018. Do developers update their library dependencies? Empirical Software
Engineering 23, 1 (2018), 384‚Äì417. https://doi.org/10.1007/s10664-017-9521-5

[21] Leonardo Leite, Carla Rocha, Fabio Kon, Dejan Milojicic, and Paulo Meirelles.
2019. A survey of DevOps concepts and challenges. Comput. Surveys 52 (2019).
Issue 6. https://doi.org/10.1145/3359981

[22] MarketsandMarkets. 2021. Open Source Services Market Size, Share and
Global Market Forecast to 2026. https://www.marketsandmarkets.com/Market-
Reports/open-source-services-market-27852275.html#utm_source=referral&
utm_medium=abnewswire&utm_campaign=paidpr. (Accessed on 04/20/2022).
[23] Suhaib Mujahid, Diego Elias Costa, Rabe Abdalkareem, Emad Shihab, Mo-
hamed Aymen Saied, and Bram Adams. 2021. Towards using package centrality
trend to identify packages in decline. IEEE Transactions on Engineering Manage-
ment Journal (Oct. 2021), 16. https://doi.org/10.1109/TEM.2021.3122012
[24] Pierluigi Paganini. 2022. node-ipc NPM Package sabotage to protest Ukraine
invasionSecurity Affairs. https://securityaffairs.co/wordpress/129174/hacking/
node-ipc-npm-package-sabotage.html. (Accessed on 04/20/2022).

[25] Ivan Pashchenko, Henrik Plate, Serena Ponta, Antonino Sabetta, and Fabio
Massacci. 2020. Vuln4Real: A Methodology for Counting Actually Vulnera-
ble Dependencies. IEEE Transactions on Software Engineering PP (09 2020), 1‚Äì1.
https://doi.org/10.1109/TSE.2020.3025443

[26] Ivan Pashchenko, Duc-Ly Vu, and Fabio Massacci. 2020. A Qualitative Study of
Dependency Management and Its Security Implications. Association for Computing
Machinery, New York, NY, USA, 1513‚Äì1531. https://doi.org/10.1145/3372297.
3417232

[27] Henrik Plate, Serena Elisa Ponta, and Antonino Sabetta. 2015. Impact assessment
for vulnerabilities in open-source software libraries. In 2015 IEEE International
Conference on Software Maintenance and Evolution (ICSME). 411‚Äì420. https:
//doi.org/10.1109/ICSM.2015.7332492

[28] Serena Elisa Ponta, Wolfram Fischer, Henrik Plate, and Antonino Sabetta. 2021.
The Used, the Bloated, and the Vulnerable: Reducing the Attack Surface of an
Industrial Application. In 2021 IEEE International Conference on Software Main-
tenance and Evolution (ICSME). 555‚Äì558. https://doi.org/10.1109/ICSME52107.
2021.00056

[29] Eric Raymond. 1999. The cathedral and the bazaar. Knowledge, Technology &

Policy 12, 3 (1999), 23‚Äì49. https://doi.org/10.1007/s12130-999-1026-0

[30] Filipe Roseiro C√¥go, Gustavo Oliva, and Ahmed E. Hassan. 2019. An Empirical
Study of Dependency Downgrades in the npm Ecosystem. IEEE Transactions on
Software Engineering PP (11 2019), 1‚Äì1. https://doi.org/10.1109/TSE.2019.2952130
[31] Ax Sharma. 2022. Dev corrupts NPM libs ‚Äôcolors‚Äô and ‚Äôfaker‚Äô breaking thousands
of apps. https://www.bleepingcomputer.com/news/security/dev-corrupts-npm-
libs-colors-and-faker-breaking-thousands-of-apps/. (Accessed on 04/20/2022).
[32] Duc-Ly Vu, Ivan Pashchenko, Fabio Massacci, Henrik Plate, and Antonino Sabetta.
2020. Typosquatting and Combosquatting Attacks on the Python Ecosystem. In
2020 IEEE European Symposium on Security and Privacy Workshops (EuroS PW).
509‚Äì514. https://doi.org/10.1109/EuroSPW51379.2020.00074

[33] Free Wortley, Chris Thompson, and Forrest Allison. 2021. Log4Shell: RCE 0-
day exploit found in log4j 2, a popular Java logging package | LunaSec. https:
//www.lunasec.io/docs/blog/log4j-zero-day/. (Accessed on 04/19/2022).

[34] Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, and Michael Pradel.
2019. Smallworld with High Risks: A Study of Security Threats in the Npm
Ecosystem. In Proceedings of the 28th USENIX Conference on Security Symposium
(Santa Clara, CA, USA) (SEC‚Äô19). USENIX Association, USA, 995‚Äì1010.

implementation of our approach, however, is still ongoing. There
are challenges pertaining to how to communicate this new process
to developers to increase awareness of the risks caused by the lack
of open source governance. In our future work, we plan to report on
a quantitative evaluation of the approach‚Äôs potential for mitigating
dependency management and its impact on cost savings; we will
also report on the qualitative feedback from software developers.

REFERENCES
[1] 2019. Eight key findings illustrating how to make open source work even better
for developers. https://cdn2.hubspot.net/hubfs/4008838/Resources/The-2019-
Tidelift-managed-open-source-survey-results.pdf

[2] Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and Emad
Shihab. 2017. Why Do Developers Use Trivial Packages? An Empirical Case
Study on Npm. In Proceedings of the 2017 11th Joint Meeting on Foundations of
Software Engineering (Paderborn, Germany) (ESEC/FSE 2017). Association for
Computing Machinery, New York, NY, USA, 385‚Äì395. https://doi.org/10.1145/
3106237.3106267

[3] Mahmoud Alfadel, Diego Elias Costa, and Emad Shihab. 2021. Empirical Anal-
ysis of Security Vulnerabilities in Python Packages. In 2021 IEEE International
Conference on Software Analysis, Evolution and Reengineering (SANER). 446‚Äì457.
https://doi.org/10.1109/SANER50967.2021.00048

[4] Mahmoud Alfadel, Diego Elias Costa, Emad Shihab, and Mouafak Mkhallalati.
2021. On the Use of Dependabot Security Pull Requests. In 2021 IEEE/ACM
18th International Conference on Mining Software Repositories (MSR). 254‚Äì265.
https://doi.org/10.1109/MSR52588.2021.00037

[5] Apereo. 2019. The Value of Open Source Software. https://www.apereo.org/

content/value-open-source-software. (Accessed on 04/20/2022).

[6] Christopher Bogart, Christian K√§stner, James Herbsleb, and Ferdian Thung. 2016.
How to break an API: cost negotiation and community values in three software
ecosystems. 109‚Äì120. https://doi.org/10.1145/2950290.2950325

[7] Jailton Coelho, Marco Tulio Valente, Luciano Milen, and Luciana L. Silva. 2020.
Is this GitHub project maintained? Measuring the level of maintenance activity
of open-source projects. Information and Software Technology 122 (2020), 106274.
https://doi.org/10.1016/j.infsof.2020.106274

[8] Diego Elias Costa, Suhaib Mujahid, Rabe Abdalkareem, and Emad Shihab. 2021.
Breaking Type-Safety in Go: An Empirical Study on the Usage of the unsafe
Package. IEEE Transactions on Software Engineering 01 (feb 2021), 1‚Äì1. https:
//doi.org/10.1109/TSE.2021.3057720

[9] Andreas Dann, Henrik Plate, Ben Hermann, Serena Elisa Ponta, and Eric Bodden.
2021. Identifying Challenges for OSS Vulnerability Scanners - A Study amp; Test
Suite. IEEE Transactions on Software Engineering (2021), 1‚Äì1. https://doi.org/10.
1109/TSE.2021.3101739

[10] Alexandre Decan, Tom Mens, and Eleni Constantinou. 2018. On the Impact of
Security Vulnerabilities in the Npm Package Dependency Network. In Proceedings
of the 15th International Conference on Mining Software Repositories (Gothenburg,
Sweden) (MSR ‚Äô18). Association for Computing Machinery, New York, NY, USA,
181‚Äì191. https://doi.org/10.1145/3196398.3196401

[11] Alexandre Decan, Tom Mens, and Philippe Grosjean. 2019. An Empirical Compar-
ison of Dependency Network Evolution in Seven Software Packaging Ecosystems.
Empirical Software Engineering 24 (02 2019). https://doi.org/10.1007/s10664-017-
9589-y

[12] Nicole Forsgren, Bas Alberts, Kevin Backhouse, Grey Baker, Greg Cecarelli,
Derek Jedamski, Scot Kelly, and Clair Sullivan. 2021. 2020 State of the Octoverse:
Securing the World‚Äôs Software. https://doi.org/10.48550/ARXIV.2110.10246
[13] Marco Gerosa, Igor Wiese, Bianca Trinkenreich, Georg Link, Gregorio Robles,
Christoph Treude, Igor Steinmacher, and Anita Sarma. 2021. The Shifting Sands
of Motivation: Revisiting What Drives Contributors in Open Source. In 2021
IEEE/ACM 43rd International Conference on Software Engineering (ICSE). 1046‚Äì
1058. https://doi.org/10.1109/ICSE43902.2021.00098

[14] Nasif Imtiaz, Seaver Thorn, and Laurie Williams. 2021. A comparative study of
vulnerability reporting by software composition analysis tools. Proceedings of
the 15th ACM / IEEE International Symposium on Empirical Software Engineering
and Measurement (ESEM) (10 2021). https://doi.org/10.1145/3475716.3475769
[15] Github Inc. 2017. Open Source Survey. https://opensourcesurvey.org/2017/.

(Accessed on 04/20/2022).

[16] Abbas Javan Jafari, Diego Elias Costa, Rabe Abdalkareem, Emad Shihab, and Niko-
laos Tsantalis. 2021. Dependency Smells in JavaScript Projects. IEEE Transactions
on Software Engineering (2021), 1‚Äì1. https://doi.org/10.1109/TSE.2021.3106247
[17] Eirini Kalliamvakou, Georgios Gousios, Kelly Blincoe, Leif Singer, Daniel M.
German, and Daniela Damian. 2014. The Promises and Perils of Mining GitHub.
In Proceedings of the 11th Working Conference on Mining Software Repositories
(Hyderabad, India) (MSR 2014). Association for Computing Machinery, New York,
NY, USA, 92‚Äì101. https://doi.org/10.1145/2597073.2597074

