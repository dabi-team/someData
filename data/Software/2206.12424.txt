2
2
0
2

n
u
J

4
2

]
h
p
-
t
n
a
u
q
[

1
v
4
2
4
2
1
.
6
0
2
2
:
v
i
X
r
a

Tangelo: An Open-source Python Package for End-to-end Chemistry
Workﬂows on Quantum Computers

Valentin Senicourt1,∗
, James Brown1, Alexandre Fleury1, Ryan Day3, Erika Lloyd1, Marc P.
Coons2, Krzysztof Bieniasz1, Lee Huntington1, Alejandro J. Garza2, Shunji Matsuura3, Rudi
Plesch1, Takeshi Yamazaki1, and Arman Zaribaﬁyan1

1Good Chemistry Company, 200-1285 West Pender Street Vancouver, BC, V6E 4B1, Canada
2Dow Inc., Core R&D, Chemical Science, 1776 Building, Midland, MI, 48674, USA
31QB Information Technologies (1QBit), 200-1285 West Pender Street Vancouver, BC, V6E
4B1, Canada

June 29, 2022

Abstract

Tangelo (https link) is an open-source Python software package for the development of end-to-end chemistry
workﬂows on quantum computers, released under Apache 2.0 license. It aims to support the design of successful
experiments on quantum hardware, and to facilitate advances in quantum algorithm development. The software
enables quick exploration of diﬀerent approaches by assembling reusable building blocks and algorithms, with the
ﬂexibility to let users introduce their own. Tangelo is backend-agnostic and enables switching between various
backends (Braket, Qiskit, Qulacs, Azure Quantum, QDK, Cirq...) with minimal changes in the code. The
package can be used to explore quantum computing applications such as open-shell systems, excited states, or
more industrially-relevant systems by leveraging problem decomposition at scale. This paper outlines the design
choices, philosophy, and main features of Tangelo.

1

Introduction

It is an exciting time to be working in the ﬁeld of quantum computing, as we are witnessing rapid advancements
in both software and hardware developments. The community still has to address many challenges before this
technology can be employed to reliably solve industrially-relevant problems. A potential area of promise is the
study of chemical systems and materials science, which is the main focus of Tangelo.

Indeed, many of the methods that will give quantum devices advantage over their classical counterparts are
yet to be identiﬁed. For this purpose, we need tools that facilitate the exploration and comparison of diﬀerent
approaches, as well as the design of successful experiments on quantum devices. We need to design practical end-
to-end workﬂows able to return an answer within acceptable accuracy while meeting the computational resource
constraints, such as number of qubits, quantum gates, or measurements.

Currently, studying basic molecular systems on quantum computers is impossible when naively embedding the
whole problem on quantum hardware and simply executing a straightforward quantum algorithm. Leveraging pre-
and post-processing techniques as well as insights from classical calculations remains necessary in order to make a
problem computationally tractable while maintaining accuracy. Assembling the diﬀerent building-blocks to form
and explore workﬂows that meet these constraints is where Tangelo strives to be of help. This document covers the
features, API, and philosophy of this software package.

Section 2 of this document presents an overview of what we mean by end-to-end workﬂows, and looks at what
challenges the diﬀerent building blocks present in this package attempt to tackle. Section 3 shows how Tangelo’s
API and data-structures work in practice, covering the diﬀerent steps of end-to-end workﬂows relating to hardware
experiments. Section 4 details our philosophy, as well as the various processes behind the open-sourcing, distribution,

∗Corresponding author: valentin@goodchemistry.com

1

 
 
 
 
 
 
Figure 1: Simpliﬁed representation of a quantum computing workﬂow for quantum chemistry problems, highlighting
the main steps of the process. Dotted arrows represent optional steps. A Problem decomposition methods can
be paired with quantum algorithms, in order to lower computational resource requirements of a use case. B Pre-
processing tools aiming at designing eﬃcient measurement protocols, or maximizing accuracy of results (circuit
compilation, optimizations, etc).

testing and development of Tangelo. Finally, section 5 elaborates on our goal to develop a community and engage
in collaborative work, providing examples of topics that could enrich these tools and an overview of our current
roadmap.

2 Overview of the End-to-end Workﬂow

Tangelo facilitates the design of quantum computing experiments, with chemical systems as the main target. An
overview of how end-to-end workﬂows are used for this purpose is illustrated in Figure 1. These workﬂow encompass
all steps in the simulation, from inputting the molecular data to returning post-processed experimental results. They
can be complex, and each step involves its own interesting opportunities for innovation, which can have strong impact
on resource requirements.

2.1 Deﬁning a Molecular System

Molecular systems can be deﬁned in Tangelo by providing the cartesian coordinates for the diﬀerent atoms com-
prising the system, as well as additional information such as the spin, charge or basis set considered. Cartesian
coordinates come in diﬀerent formats (XYZ, MOL2, PDB, ...) containing specialized features relevant to the simu-
lation method used (respectively quantum, atomistic or biochemical modelling). The XYZ format is the one used
in Tangelo inputs, although easy conversion from other molecular formats is possible through projects such as the
Open Babel initiative [1].

Most quantum algorithms take as input a Hamiltonian. The molecular electronic Hamiltonian can be written

in second-quantization as

H =

(cid:88)

pq

hpqa†

paq +

1
2

(cid:88)

pqrs

hpqrsa†

pa†

rasaq,

(1)

where ap is the fermionic lowering operator for orbital p and hpq, hpqrs are the 1- and 2-electron integrals in
chemist’s notation. One typically works in a ﬁnite basis of atomic orbitals and solves the mean-ﬁeld Hartree-Fock
problem to determine a suitable set of molecular orbitals (which can be expressed as a linear combination of the
atomic orbitals). The 1- and 2-electron integrals can then be transformed to this molecular orbital basis, which
then provides a suitable representation for the molecular electronic Hamiltonian in that basis. The Hartree-Fock
calculations and integral transformation steps are currently handled by third-party packages such as PySCF [2, 3].
Tangelo’s modular design allows us to support alternative packages in the future.

2

De(cid:1)nition of amolecular systemProblemDecompositionQuantum circuitssimulation / executionPost-processingError-mitigationQubit operators+Quantum circuitsQuantumalgorithmsHSCountsBitstringProbabilityEigenvalueAB2.2 Algorithms

This package contains implementations of both quantum and classical algorithms for quantum chemistry, built
upon the various lower-level functionalities designed in the toolboxes. They are further classiﬁed depending on
their nature, or the feature of a molecular system that they aim to compute. The goal of this module is to provide
a collection of algorithms that users can reuse, in order to quickly put together end-to-end chemistry workﬂows,
and combine and compare diﬀerent approaches.

Quantum algorithms attempt to solve a problem by recasting it into quantum circuits and qubit operators, and
running these circuits on a backend such as a simulator or a quantum device. The interface in Tangelo enables easy
estimation of computational resources (number of qubits, gates, etc.), ease of use by separating the initialization of
underlying data-structures from the execution of the algorithm, and also gives users the ability to pass customizing
options for low-level control. So far, Tangelo features various ﬂavours of the Variational Quantum Eigensolver (VQE)
[4, 5], such as ADAPT-VQE for iterative circuit building [6], and State-Averaging VQE with orbital optimization
for excited states [7]. It also features the Quantum Imaginary Time-Evolution (QITE) [8] algorithm to obtain an
eigenstate of a Hamiltonian. Other algorithms include (controlled) time-evolution and Quantum Fourier Transform
(QFT), which facilitate computing the energy of a state with phase estimation [9] or projecting a state onto a
certain symmetry [10] or energy [11]. Work on other quantum algorithms is underway.

Classical algorithms are provided for convenience, in order to acquire reference results and reﬂect on the per-
formance of quantum algorithms when applied to concrete use cases. As the capabilities of quantum devices and
simulators are currently limited, these classical algorithms tend to be able to deliver faster and more accurate
results, and scale to larger systems. The list so far includes Full-Conﬁguration Interaction (FCI), Coupled-Cluster
Singles and Doubles (CCSD) [12, 13] and the semi-empirical solver MINDO3 [14, 15].

The parameters for these algorithms can have signiﬁcant impact on their accuracy, or their compute require-
ments. For example, one could study how freezing some electronic orbitals impacts the accuracy of the solution
using the classical solvers available, before incorporating these insights into their quantum workﬂow. In general, we
designed our algorithms in a modular and ﬂexible way that provides users with a ﬁne level of control, and the ability
to integrate their own custom code. We hope to grow this collection of algorithms, in order to provide users with
the tools to investigate and tailor various approaches to their use cases, and support them in running successful
experiments on quantum devices.

2.3 Problem Decomposition

The main objective of problem decomposition (PD) techniques, also referred to as fragmentation techniques, is
to lower computational resource requirements by decomposing the initial problem instances into a collection of
subproblems. These are solved using fewer resources, and their results recombined to approximate the full solution.
Examples of such algorithms include Density-Matrix Embedding Theory (DMET)
[16, 17] and the Method of
Increments (MI) [18–34]. The subproblems can then be solved with a combination of the supported classical or
quantum algorithms described in the previous section.

Naively embedding a whole problem and throwing it at a quantum computer is not practical, due to the limited
capabilities of current quantum devices. Problem decomposition can allow users to go beyond toy problems and
explore the impact of quantum computing on more industrially-relevant instances. It can combine quantum and
classical algorithms, sometimes at diﬀerent levels of theory, in order to solve the diﬀerent subproblems generated,
allowing users to introduce and study quantum computation as part of more complex use cases.

Problem decomposition is a common technique in chemical modelling, and it covers a broad swath of methods.
The common theme in these methods is to partition the overall system into a system of interest, where an accurate
description of the interactions must be used, and subsystems where cruder approximations between particles is
suﬃcient. Some PD techniques are based on partitioning around electronic orbitals, taking into account electronic
correlation between subsystems (e.g. the method of increments). Other partition systems based on atoms and
bonds, creating molecular fragments, such as the well-known Quantum-Mechanical/Molecular-Mechanical methods
[35–38]. Finally, some PD techniques based on molecular fragments only treat the fragment in the system of interest
explicitly, with the low-level subsystems approximated as a continuum solvent, such as the Polarizable Continuum
Model (PCM) [39–41]

The impact of problem decomposition on both computational resource requirements and accuracy depends on
the use case, and is a topic of ongoing research [34, 42]. We describe in the following subsections a few of the PD
methods currently supported in Tangelo.

3

Figure 2: Problem decomposition aims at reducing computational resource requirements while maintaining the
accuracy of the results. Paired with quantum algorithms, it may in particular make metrics such as number of
qubits or quantum gates more tractable on existing hardware.

2.3.1 Density-Matrix Embedding Theory (DMET)

DMET [16, 17] is a quantum embedding technique that breaks the molecule into fragments, deﬁned by atoms and
the corresponding localized basis functions. Each fragment is solved as an open quantum system with the fragment
orbitals connected to the bath orbitals such that a new Hamiltonian is deﬁned for each fragment. The Hamiltonian
can be rewritten as

H =

(cid:34)

(cid:88)

pq

hpq +

(cid:88)

rs

[hpqrs − hpsrq] Denv,A

rs

a†
paq − µ

(cid:35)

(cid:88)

p

a†
pap +

(cid:88)

pqrs

hpqrsa†

pa†

qasar,

(2)

where Denv,A is the density matrix for the environment of fragment A, µ is the chemical potential updated after
each DMET cycle by a((cid:80)
A N A − N tot) where a is a positive number, N A and N tot are the number of electrons in
fragment A and the whole system respectively.

The DMET cycle can be described by the pseudocode shown in Figure 3. Solving each fragment Hamiltonian

can be achieved with a quantum computer (simulated or hardware) or with a classical solver.

COMPUTE the mean field
DECOMPOSE molecule into fragments
while (cid:80)

A N A (cid:54)= N tot

DETERMINE the chemical potential
for A ∈ fragments

CONSTRUCT bath orbitals LB for fragment A
CONSTRUCT the fragment Hamiltonian H
SOLVE Hamiltonian
COMPUTE 1- and 2-RDMs and N A

COMPUTE the total energy

Figure 3: The pseudocode for the DMET algorithm.

As DMET requires 2-RDMs for each fragment, a post Hartree-Fock method must be used for each fragment.
The user is in control of the diﬀerent atoms deﬁning each fragment, and other parameters deﬁning the behaviour
of the algorithm.

2.3.2 ONIOM

Another available problem decomposition technique is ONIOM [43–46], a hybrid approach breaking down a molecu-
lar system into subproblems that can be solved with diﬀerent levels of theory. In particular, this class of algorithms
enables users to tackle larger systems, targeting the most important parts of the system with expensive but accurate
algorithms using a high-level theory, while treating the rest of the system with a lower-level theory.

Eq. (1) is broken into fragments, and disregards the interaction terms between the fragments. The total energy

EONIOM is computed as

EONIOM = ELow

All +

N
(cid:88)

(EHigh

Fragmenti

− ELow

Fragmenti

),

(3)

i=1

4

Molecule• Number of qubitsNmolecule• Circuit depthDmolecule• Number of qubitsNsubproblem i ≤ Nmolecule• Circuit depthDsubproblem i ≤ DmoleculeSubproblem (x 2, 3, ...)DMETONIOMMI-FNO...is the energy of the whole system at a low level of theory, and EHigh

where ELow
is the energy
All
of fragment i at a high- and low-level of theory respectively. High- and low-level of theory are referring here to the
method’s accuracy towards computation of total molecular energy. A 2-RDM is not required to calculate the total
energy so Hartree-Fock or semi-empirical methods can be used for the low-level calculations.

and ELow

Fragmenti

Fragmenti

ONIOM use cases range from solution chemistry, as illustrated in the next section, to nanomaterials simulation,
biochemistry applications and beyond [46]. Computational scientists have taken this approach to study enzymatic
reaction mechanisms, visualize protein folding or tackle other problems that remain out of reach for pure quantum
chemistry methods.

2.3.3 Method of Increment with Frozen Natual Orbitals (MI-FNO)

The method of increments [18–34] (MI) can be used to express the correlation energy of a molecular system as a
truncated many-body expansion in terms of orbitals, atoms, molecules, or fragments. In Tangelo, the correlation
energy of the system is expanded in terms of occupied orbitals, and MI is employed to systematically reduce the
occupied orbital space. Namely, the correlation energy can be expressed in terms of n-body increments ((cid:15)i, (cid:15)ij, (cid:15)ijk,
(cid:15)ijkl), and so on, as

Ec = Eexact − EHF

(cid:88)

=

(cid:15)i +

i

(cid:88)

i>j

(cid:88)

(cid:15)ij +

(cid:15)ijk +

(cid:88)

(cid:15)ijkl + . . .

i>j>k

i>j>k>l

(4)

Here, (cid:15)i, (cid:15)ij, (cid:15)ijk, and (cid:15)ijkl are, respectively, the one-, two-, three-, and four-body increments which are deﬁned as

(cid:15)i = Ec(i),
(cid:15)ij = Ec(ij) − (cid:15)i − (cid:15)j,
(cid:15)ijk = Ec(ijk) − (cid:15)ij − (cid:15)ik − (cid:15)jk − (cid:15)i − (cid:15)j − (cid:15)k,
(cid:15)ijkl = Ec(ijkl) − (cid:15)ijk − (cid:15)ijl − (cid:15)jkl − · · · ,

...

(5)

(6)

(7)

(8)

in which Ec(i) denotes the correlation energy of the increment i, Ec(ij) denotes the correlation energy of the
increment i, j, and so on.

At the same time, the virtual orbital space is reduced by using the so-called frozen natural orbital (FNO)
approach [47–50]. Namely, in this scheme, the virtual space is spanned by natural orbitals of the one-particle density
matrix from second-order, many-body perturbation theory and the virtual orbitals whose occupation numbers (i.e.
eigenvalues of the density) fall below a threshold are discarded. In this way, a method referred to as the MI-FNO
approach is available for the systematic reduction of both the occupied space and the virtual space in quantum
chemistry simulations.

We refer the reader to our tutorial notebook for a gentle introduction to MI-FNO and how it can be leveraged

in Tangelo, and to [34] for a more comprehensive description of the approach.

2.4 Quantum Circuit Simulation and Execution

2.4.1 Backend-agnosticism

The idea of being backend-agnostic is that users only have to write their algorithm once, and can then easily run
it on various simulators and quantum devices with minimal changes. All quantum algorithms available in Tangelo
are written using generic data-structures that are backend-agnostic: they are thus not tied to a speciﬁc platform.
Assembling gates and forming complex circuits in Tangelo is very straightforward and pythonic, as we demonstrate
in section 3.

The cornerstone of our approach relies on format conversion functions, which are able to convert the generic
“abstract” format Tangelo uses to represent a quantum circuit into an object or simple string that can be used
by the target backends. Users are able to use these functions directly to export a quantum circuit in their desired
format (including QASM), or provide it as input to the API of the framework of their choice, such as local code or
quantum cloud services. This feature is particularly important, as it ensures compatibility with the growing number
of projects that study questions related to quantum circuits, such as their simulation, or compilation/optimization
for speciﬁc architectures.

5

Tangelo provides a uniﬁed interface to prominent quantum circuit simulation packages developed by the com-
munity, such as Cirq [51], Qiskit [52], Qulacs [53], Braket [54] and QDK [55]. By simply changing one word in
their code, users can switch between diﬀerent simulators. Likewise, other parameters enable users to run their
custom noisy simulations, or decide how many shots (measurements) should be used to compute the output of the
simulation. This layer of abstraction eﬀectively decouples quantum chemistry from quantum circuit simulation, and
allows users to focus on the former, by not requiring them to learn and write code speciﬁc to a particular platform.
We look forward to integrating new promising backends and platforms displaying outstanding performance or

unique features.

2.4.2 Connection to Quantum Devices

Tangelo can reach a variety of quantum devices, thanks to the format conversion functions it supports. This allows
users to access quantum cloud providers such as Braket or Azure Quantum, to directly use their favorite hardware
provider’s API, or to use the convenience functions in QEMIST Cloud, Good Chemistry’s platform enabling high-
accuracy quantum chemistry simulations in the cloud.

It is possible for users to extract objects such as quantum circuits or qubit operators at various steps of a
quantum algorithms, and use these as inputs for an experiment on a quantum device. Currently, the quantum
algorithms written in Tangelo only streamline simulators as backends. We are however open to providing support
for running whole algorithms on quantum devices in the future, as soon as the community deems it interesting.

2.5 Pre- and Post-processing for Quantum Experiments

The output of a quantum computer is a histogram of measurements corresponding to the diﬀerent outcomes ob-
served, usually expressed as bitstrings. The cost and duration of a quantum experiment is roughly linear with the
number of shots used to build such histograms, which also correlates with the accuracy of the results.

Pre-processing encompasses several steps preceding execution of the circuits on a quantum device, such as
deﬁning eﬃcient measurement protocols or compiling a quantum circuit for a particular architecture, among others.
Tangelo provides a collection of features to help users design eﬃcient measurement protocols, with the goal of
lowering the cost of an experiment while preserving accuracy as much as possible. For example, such features
encompass grouping strategies, which identiﬁes the smallest set of measurement bases in which circuits need to be
run in order to derive all the values required to compute the end results, while extracting the most information
from each measurement.

As devices only support a set of native quantum gates, it is also important that quantum circuits are com-
piled and optimized for the target architecture. The insights provided during this step may help further reduce
the amount of measurements needed for the experiment, or increase the accuracy of the end result. Due to its
backend-agnostic approach, Tangelo is compatible with third-party tools developed by the quantum community
and hardware providers, in order to tackle these challenges. We look forward to supporting better integration with
these frameworks, as well as providing features directly in Tangelo when relevant.

Post-processing takes as input histograms returned by the quantum device and can derive quantities of interest,
as well as their error bars to account for statistical eﬀects. This process may include noise-mitigation techniques,
which attempt to improve the derived values either by using insights of the molecular system, or characterized
properties of the quantum hardware. Tangelo provides general and chemistry-inspired post-processing techniques,
to assist users with obtaining successful experiment results, and aims to provide more in the near future.

3 API Overview Through End-to-end Examples

This section demonstrates how Tangelo’s API works, through some examples used in previous works, including an
end-to-end pipeline featured in reference [56]. We elaborate on the implementation and interface of the building
blocks used for each step. These buildings blocks can be low-level functions drawn from one of the many toolboxes
in the package, or more complex ones built on top of them, such as a whole quantum algorithm, combined with a
problem decomposition technique.

Tangelo currently contains high-level submodules listed in the table below, matching the folder hierarchy of the

package.

6

algorithms

problem decomposition

toolboxes

linq

helpers

3.1

Inputs

Quantum and classical algorithms for quantum chemistry, further subdivided depend-
ing on their nature and goal. Built upon the various functionalities designed in the
toolbox modules.
Methods for decomposing a molecular system into a collection of smaller subprob-
lems and reconstructing its properties by solving them. Designed to reduce resource
requirements of the input problem, to adhere to computational constraints. Can be
paired with the algorithms deﬁned in the algorithms module.
Low-level building blocks supporting the development of algorithms and end-to-end
workﬂows, covering topics such as frozen orbitals, qubit mappings, ansatz circuits,
error-mitigation, qubit terms grouping, etc.
Interface to backend-agnostic representation and operations on quantum circuits, for-
mat conversion and wrappers to facilitate connection to diverse simulators and quan-
tum devices.
Miscellaneous helper functions.

A molecular system can be deﬁned by passing its atoms’ cartesian coordinates (xyz), charge (q), spin, a basis set
and the list of frozen molecular orbitals.

In order to tackle this system with methods working in second quantization, such as the popular Variational
Quantum Eigensolver (VQE), we use this information to instantiate an object of the SecondQuantizedMolecule
class. Please note that Tangelo is not restricted to algorithms and data-structures operating in second quantization:
the API will be naturally extended as more approaches are introduced to the codebase, such as ﬁrst-quantization.

from tangelo import SecondQuantizedMolecule

xyz = [[’H’, (0.0, 1.780, 0.0)], [’H’, (-1.046, 1.44, 0.0)],

[’H’, (-1.693, 0.55, 0.0)], [’H’, (-1.693, -0.55, 0.0)],
[’H’, (-1.046, -1.44, 0.0)], [’H’, (0.0, -1.78, 0.0)],
[’H’, (1.046, -1.44, 0.0)], [’H’, (1.693, -0.55, 0.0)],
[’H’, (1.693, 0.55, 0.0)], [’H’, (1.046, 1.44, 0.0)]]

mol = SecondQuantizedMolecule(xyz, q=0, spin=0, basis="minao", frozen_orbitals=None)

This instantiation of SecondQuantizedMolecule includes the computation of the mean-ﬁeld solution. Currently,
these conventional quantum chemistry calculations rely on the PySCF [2, 3] python package; we may support other
computational chemistry packages in the future. Restricted closed- and open-shell Hartree-Fock are currently
supported automatically by changing the spin argument. This is the starting point for post-HF calculations for
introducing electronic correlation. Besides general molecular information, SecondQuantizedMolecule contains data
about (in)active molecular and spin orbitals.

3.2 Quantum Chemistry Algorithms

3.2.1 Classical Algorithms

Classical algorithms can be useful to obtain reference results, or to get quick insights about the system (conse-
quences of freezing orbitals, etc) that can be later leveraged during the exploration of quantum approaches. They
are here for convenience and support, and allow users to also combine classical and quantum solvers in more elab-
orate approaches. For instance, SecondQuantizedMolecule can be passed to instantiate classical solvers such as
FCISolver and CCSDSolver. The simulate method can then be used to compute the ground state energy.

from tangelo.algorithms import FCISolver, CCSDSolver

fci_energy = FCISolver(mol).simulate()
ccsd_energy = CCSDSolver(mol).simulate()

1

2

3

4

5

6

7

8

9

1

2

3

4

7

Figure 4: Main options for Tangelo VQESolver. VQE aims to approximate an eigenvalue by classically minimizing
an expectation value, with regards to variational parameters used in an arbitrary quantum circuit (the “ansatz”).
Users have access to various options to customize the behaviour of the algorithm, and can both compute and retrieve
values of interest by using the attributes and methods of the VQESolver object. For more details, check out our
VQE tutorial notebooks.

These classical solvers also allow you to obtain 1- and 2-RDMs easily with the get_rdm method. Both
CCSDSolver and FCISolver freeze orbitals as directed by the user when obtaining classical solutions. The im-
plementation of those solvers currently leverages PySCF [2, 3].

3.2.2 Quantum Algorithms

Tangelo provides implementations of diﬀerent quantum algorithms, including variational approaches such as VQE [4]
and ADAPT-VQE [6]. Tangelo is neither restricted to variational approaches nor second-quantization, and we look
forward to supporting a broader collection of methods. The API of quantum algorithms is similar to the one for
classical algorithms, with extra methods:

• build is a method that initializes all internal objects in the solver, according to the options passed by the

user.

• get_resources exposes a summary of computational resource requirements, such as metrics characterizing
the current underlying quantum objects (circuit, Hamiltonians...) and other quantities of interest (for VQE,
the number of variational parameters in the ansatz circuit gives us a sense of how diﬃcult the classical
optimization will be). It can be called right after build to let users access and assess the underlying objects
and metrics (such as computational resource requirements) for their quantum algorithm without having to
simulate it, or after simulation as well.

• simulate can be called after build has completed, and will run the quantum algorithm, simulating quantum
circuits on the backend of your choice. Currently, we do not streamline the process to run entire algorithms
on actual quantum devices.

The method get_resources can be called at any point after build has been called, and will return information
based on the current state of the solver object. For instance, if called right after build, it will report values related
to the initial objects used by the algorithm, before any quantum circuit has been simulated. If called after simulate
has been run, it will return something diﬀerent, such as the ﬁnal ansatz circuit and qubit operators used in VQE,
after classical optimisation is complete. Depending on the algorithm, more methods may be available. Such methods
may allow users to compute intermediary quantities, instead of simulating the whole algorithm. For instance, VQE
allows the direct computation of energy or RDMs, according to input variational parameters provided by the user
(i.e., a single energy estimation). Please refer to the API and the example notebooks to learn about some of these
useful features.

We strive to develop a very ﬂexible approach that can both be used “as-is”, but also provide users with the
ability to control the behaviour of algorithms through options dictionaries. These options can signiﬁcantly al-
ter the behaviour and computational cost of a given algorithm, provide users with ﬁne control over it, or even

8

Variational Quantum AlgorithmVQESolverAnsatzorCircuitMoleculeorQubit HamiltonianRequired inputsOptional inputsInitial variationalparametersPenalty termsClassicaloptimizationalgorithmBackend optionsQubit encodingoptionsVQESolver.methodsbuildsimulateget_rdmenergy_evaluationget_resourcesfacilitate drop-in of their own custom code. For VQE, some notable parameters include "qubit_mapping" (e.g
Jordan-Wigner, Bravyi-Kitaev, symmetry-conserving-Bravyi-Kitaev, Jiang-Kalev-Mruczkiewicz-Neven [57],...), ini-
tial variational parameters, or the choice of "ansatz". Tangelo provides BuiltInAnsatze such as UCCSD [58–60],
k-UpCCGSD [61], HEA [62], QCC [63], RUCC [64] and Variationally Scheduled Quantum Simulation (VSQS) [65],
but users can deﬁne and pass their own ansatz objects, or even simply pass any variational quantum circuit deﬁned
in Tangelo. We highlight some of these functionalities for the QCC ansatz with an illustrative example in the
following paragraphs, after brieﬂy reviewing the methodology. The details for utilizing the HEA ansatz and the
Ansatz class, the latter of which enables the user to deﬁne custom ansatz, are provided in a dedicated tutorial
notebook. More generally, each of the ansatz available in the ansatz_generator toolbox is documented.

The QCC method is a variational approach that augments a mean-ﬁeld wave function with electron correlation

eﬀects. The QCC energy is obtained by optimizing an energy functional,

EQCC(τ , Γ) = (cid:104)Ψ(τ , Γ)| ˆH |Ψ(τ , Γ)(cid:105) ,

(9)

for two sets of variational parameters τ and Γ, that describe the correlated and mean-ﬁeld wave functions, respec-
tively. In Eq. 9, |Ψ(τ , Γ)(cid:105) is the variational QCC wave function that takes form as

|Ψ(τ , Γ)(cid:105) = ˆU (τ ) |Ω(Γ)(cid:105) ,

(10)

and ˆH is a molecular Hamiltonian that has been mapped to qubits (i.e., a qubit Hamiltonian). For the QCC
method, electron correlation is derived from a mean-ﬁeld wave function |Ω(Γ)(cid:105) through application of a unitary
operator ˆU (τ ). The QCC unitary operator is constructed from a set of ng τ parameters together with a set of
Pauli word generators ˆPk, the form of which is

ˆU (τ ) =

(cid:32)

exp

−

(cid:33)

.

iτk ˆPk
2

ng
(cid:89)

k

(11)

The mean-ﬁeld wave function |Ω(Γ)(cid:105) is expressed as a tensor product of nq single-qubit states |ω(θj, φj)(cid:105) that are
each speciﬁed by a pair of Bloch sphere polar and azimuthal angles θj and φj:

|Ω(Γ)(cid:105) =

nq
(cid:79)

j

|ω(θj, φj)(cid:105) .

(12)

Each single-qubit state |ω(θj, φj)(cid:105) is represented as a linear combination of the canonical Bloch sphere basis vectors
|0(cid:105) and |1(cid:105):

|ω(θj, φj)(cid:105) = cos

|0j(cid:105) + eiφj sin

|1j(cid:105) .

(13)

(cid:19)

(cid:18) θj
2

(cid:19)

(cid:18) θj
2

The set of ng Pauli word generators ˆPk are selected based on the magnitude QCC energy derivative with respect
to τk,

∂EQCC
∂τk

(cid:12)
(cid:12)
(cid:12)
(cid:12)τ =0

i
2

=

(cid:104)Ω (Γopt)| [ ˆPk, ˆH] |Ω (Γopt)(cid:105) ,

(14)

and evaluated with all τk set to zero and using an optimal set of mean-ﬁeld parameters Γopt. Thus the QCC method
requires optimization of ng + 2nq variational parameters in order to obtain the correlated wave function and total
electronic energy.

Provided below is an example of how to instantiate a VQESolver object from a dictionary of options for the
QCC ansatz, then initialize the internal objects it needs by calling build, and ﬁnally calling get_resources and
simulate to obtain quantum resource estimations and execute the entire algorithm according to the user’s options.
For this particular example, we focus on a system comprising a ring of ten equidistant hydrogen atoms (H10), and
treat the electron correlation at the QCC/minimal basis set level of theory. Note that in the following example, we
are using the SecondQuantizedMolecule instance mol that was deﬁned in Section 3.1.

9

1

2

3

4

5

6

7

8

9

10

11

12

13

14

1

2

3

4

from tangelo.algorithms import BuiltInAnsatze, VQESolver

ansatz_options = {"qcc_tau_guess": 1e-2, "deqcc_dtau_thresh": 1e-3, "max_qcc_gens": None}

vqe_solver_options = {"molecule": mol, "ansatz": BuiltInAnsatze.QCC, "qubit_mapping": "jw",

"initial_var_params": "random", "ansatz_options": ansatz_options}

solver = VQESolver(vqe_solver_options)
solver.build()

vqe_resources = solver.get_resources()
optimal_vqe_energy = solver.simulate()
print(vqe_resources)
print(optimal_vqe_energy)

In the previous code snippet, we inform the VQESolver to utilize the QCC ansatz from BuiltInAnsatze with
the Jordan-Wigner encoding, and randomized variational parameters. Additionally, the mean-ﬁeld variational pa-
rameter set Γ is automatically selected so that |Ω (Γ)(cid:105) corresponds to the ground state Hartree-Fock reference
wave function. The dictionary ansatz_options is deﬁned and contains options speciﬁc to the QCC ansatz class:
"qcc_tau_guess", "deqcc_dtau_thresh", and "max_qcc_gens". The ﬁrst option "qcc_tau_guess", together with
the value "random" for the option "initial_var_params", results in uniform randomization of the QCC parameter
set τ over the range [−0.01, 0.01]. The second option "deqcc_dtau_thresh" determines the threshold of the mag-
nitude of the QCC energy gradient given by Eq. (14) for determining which sets of candidate Pauli word generators
should be considered for the ansatz given by Eq. (12). The third option "max_qcc_gens" sets the maximum number
of Pauli word generators ˆPk to utilize for constructing the QCC unitary ansatz in Eq. (12); this is the number of
variational parameters in τ , ng. Since this option is set to None, one Pauli word generator from each candidate set
that were characterized by QCC energy gradient magnitudes (Eq. (14)) larger than "deqcc_dtau_thresh" will be
employed to build the QCC unitary operator (Eq. (12)).

The output of the calls to get_resources and simulate from the previous code snippet are shown below:

{’qubit_hamiltonian_terms’: 3591, ’circuit_width’: 20,
’circuit_gates’: 2815, ’circuit_2qubit_gates’: 1110,
’circuit_var_gates’: 185, ’vqe_variational_parameters’: 185}

-5.392733992321686

While a number of existing devices based on diﬀerent technologies can accommodate this number of qubits (here
denoted by circuit_width), the number of quantum gates required is far beyond what current noisy systems can
faithfully execute. The number of variational parameters makes classical optimization challenging as well.

Overall, the features exposed by the API are designed to facilitate the exploration of diﬀerent approaches,
quantifying metrics of interest and partially or fully simulating an algorithm to obtain results, if relevant. The
highly modular design of algorithms, combined with an API that allows ﬁne control and easy computational
resource estimation can be a powerful tool to facilitate exploration, and discovering more promising approaches.
Meanwhile, classical solvers can be used to acquire reference values and get insights about the molecular system,
which we can use to inform our quantum approaches.

3.3 Problem Decomposition

Problem decomposition techniques can help with reducing computational resource requirements, and make use
cases more tractable on current devices. The API for problem decomposition techniques is similar to what is used
for quantum algorithms. Users ﬁrst pass a dictionary of options used at instantiation, the build method then
initializes all underlying objects, simulate runs the algorithm, and get_resources keeps track of computational
requirements. Beyond that, each problem decomposition class oﬀers its own additional methods. We illustrate the
DMET and ONIOM methods in the examples below.

10

3.3.1 DMET Example: A Ring of Ten Hydrogen Atoms

Our H10 use case is a strongly correlated system, which is something DMET may be appropriate for. In the example
below, we aggressively decompose the system into 10 fragments of size 1 atom each. Because each fragment plays
a symmetrical role, we decide to only consider one of them with a quantum approach and the others with the
CCSD classical solver, in the snippet below. This is done purely to speed up computation and avoid duplicating
calculations leading to the same results in this situation: DMET does not rely on symmetry.

from tangelo.algorithms import BuiltInAnsatze
from tangelo.problem_decomposition.electron_localization import meta_lowdin_localization
from tangelo.problem_decomposition import DMETProblemDecomposition

ansatz_options = {"qcc_tau_guess": 1e-2, "deqcc_dtau_thresh": 1e-3, "max_qcc_gens": None}

dmet_options = {"molecule": mol, "verbose": False,

"fragment_atoms": [1]*10,
"fragment_solvers": ["vqe"] + ["ccsd"]*9,
"electron_localization": meta_lowdin_localization,
"solvers_options": [{"ansatz": BuiltInAnsatze.QCC, "qubit_mapping": "scBK",

"initial_var_params": "random", "up_then_down": True,
"verbose": False, "ansatz_options": ansatz_options}]
+ [{}]*9}

dmet_solver = DMETProblemDecomposition(dmet_options)
dmet_solver.build()

A closer look at the main DMET options below:

• fragment_atoms dictates how atoms are assigned to fragments comprising our molecular system. This variable
can be a list of integers (each representing the number of atoms comprising a fragment), or as a nested list of
integers, where each sub-list groups together atom indices belonging in the same fragment.

• fragment_solvers pairs each of the fragment with a solver (“ccsd”, “vqe”, “fci”, ...), or just applies the same

solver to all fragments if only one of them is speciﬁed.

• electron_localization Available options for the electron localization scheme used, such as Meta-L¨owdin

localization [66] or Intrinsic Atomic Orbitals (IAO) localization [67].

• solvers_options provides the dictionary of options for the corresponding solver. Here we employ the QCC
method as in the previous H10 example in conjunction with the symmetry-conserving Bravyi-Kitaev encoding.
The spin-orbitals are arranged such that all α spin-orbitals are indexed ﬁrst followed by all β spin-orbitals.
The QCC variational parameters are initialized randomly.

The get_resources method shows that for a fragment containing a single hydrogen atom and treated with
VQE using the options above, the resource requirements are signiﬁcantly lower than a direct VQE approach for the
whole system shown in Section 3.2.2:

{’qubit_hamiltonian_terms’: 9, ’circuit_width’: 2,
’circuit_gates’: 11, ’circuit_2qubit_gates’: 2,
’circuit_var_gates’: 1, ’vqe_variational_parameters’: 1}

The simulate method simulates the quantum algorithms on the target simulator backend (which can be speciﬁed
as an option), runs the classical solvers as well, and returns the energy for this system. This provides an idea of
the attainable accuracy on “perfect” devices, and can help us decide if a particular experiment on an actual device
is relevant. This step is rather straightforward, as it assumes all relevant options have already been passed to the
dmet_solver object:

dmet_energy = dmet_solver.simulate()
print(dmet_energy)

11

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

1

2

3

1

2

Figure 5: The acetic acid interactions with water example. The high accuracy fragment is deﬁned using the seven
numbered atoms (blue region), excluding atom 0, while the low-accuracy fragment includes the non-numbered atoms
and atom 0. The broken link is repaired by adding a hydrogen atom at 0 to the high-accuracy fragment for the high
accuracy calculation. Similarly a hydrogen atom at 1 is added to the low-accuracy fragment for the low-accuracy
calculation.

which returns

1

-5.401626680694919

3.3.2 ONIOM Example: Acetic Acid Interactions with Water

Another decomposition strategy, ONIOM, may be used in cases where parts of a system can be decoupled almost
completely. Here, our use case is a single acetic acid molecule positioned in a pool of water molecules: our goal
is to determine the optimal heteroatom-hydrogen distance happening during solvation. The system is deﬁned in
Figure 5. Even though the system size is very far from the thermodynamic limit, computational resources remain a
constraint. With the help of ONIOM, we can target a speciﬁc interaction to compute with a high-accuracy method,
while considering an environment with a lower-cost electronic structure solver. This process facilitates an easier
link between simulation and experimental results by keeping compute time and quantum resources practical.

The deﬁnition of the problem is as simple as the following lines of code where "water_system.xyz" contains

the coordinates of the system depicted in Figure 5.

12

HFsto-3gVQE-UCCSD 6-31g(d,p)123 410981

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

1

2

from tangelo.problem_decomposition.oniom import ONIOMProblemDecomposition, Fragment, Link
from tangelo.algorithms import BuiltInAnsatze as Ansatze

# Coordinates file
with open("water_system.xyz",’r’) as f:

xyz = f.read()
# Removing first 2 lines (number of atoms and a comment line)
xyz = xyz.split("\n", 2)[2]

options_low = {"basis": "sto-3g"}
options_high = {"basis": "6-31G**",

"qubit_mapping": "jw",
"ansatz": Ansatze.UCC3,
"up_then_down": True,
"frozen_orbitals": [i for i in range(76) if i not in (16, 17)]}

# Whole system to be computed with a low-accuracy method (RHF, sto-3g)
system = Fragment(solver_low="rhf", options_low=options_low, charge=0)

# Fragment to be computed with a high-accuracy method (VQE-UCC3, 6-31G**).
links = [Link(0, 1, 0.709, ’H’)]
model = Fragment(solver_low="rhf", options_low=options_low,

solver_high="vqe", options_high=options_high,
selected_atoms=[1, 2, 3, 4, 8, 9, 10],
broken_links=links,
charge=0)

# Construction of the ONIOM solver.
oniom_solver = ONIOMProblemDecomposition({"geometry": xyz,

"fragments": [system, model],
"verbose": True})

The quantum resources information can be obtained with the method get_resources. For our chosen fragments,

frozen orbitals and ansatz, the result is the following:

{’qubit_hamiltonian_terms’: 27, ’circuit_width’: 4, ’circuit_gates’: 23,

’circuit_2qubit_gates’: 8, ’circuit_var_gates’: 3, ’vqe_variational_parameters’: 3}

The ONIOM energy can be obtained with the command oniom_solver.simulate(), which results in a value that
is approximately 4 Hartree lower than the Hartree-Fock solution. In a provided example notebook, the equilibrium
O-H distance was computed, and is in agreement with reference values.

3.4 Quantum Circuits

Tangelo’s API for deﬁning quantum gates and circuits is both straightforward and pythonic. It is handled by the
linq submodule, which also provides format conversion function to enable Tangelo to connect to various compute
platforms — hence the name “linq”. The Gate and Circuit classes in Tangelo allow us to express algorithms in
a backend-agnostic fashion, which can then be converted into the diﬀerent formats supported by computational
platforms (simulators, QPUs).

A Gate object is most accurately described as a dictionary, with a few extra methods provided for convenience.
It is entirely deﬁned by its name, indices of target and control qubits (indexing starts at 0 in Tangelo), values of
parameters if any, and a “variational” tag in order to easily ﬁnd it within a circuit, if relevant later.

13

1

2

3

4

5

6

7

8

9

10

11

12

from tangelo.linq import Gate

# Create a Hadamard gate acting on qubit 2
H_gate = Gate("H", 2)
# Create a CNOT gate with control qubit 0 and target qubit 1
CNOT_gate = Gate("CNOT", target=1, control=0)
# Create a parameterized rotation on qubit 1 with angle 2 radians
RX_gate = Gate("RX", 1, parameter=2.)
# Create a parameterized rotation on qubit 1, with undefined angle, tag as variational
RZ_gate = Gate("RZ", 1, parameter="an expression", is_variational=True)

print(RZ_gate)

outputs:

1

RZ

target : 1

parameter : an expression

(variational)

Likewise, a Circuit object can be pictured as a self-aware list of Gate objects, with a few useful methods and

operator overloading. There are several ways to create and modify circuits:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

1

2

3

4

5

6

7

8

9

from tangelo.linq import Circuit

# Here’s a list of abstract gates
mygates = [Gate("H", 2), Gate("CNOT", 1, control=0), Gate("CNOT", target=2, control=1),

Gate("Y", 0), Gate("RX", 1, parameter=2.)]

# Users can create empty circuit objects and use add_gate later on
circuit1 = Circuit()
for gate in mygates:

circuit1.add_gate(gate)

# Users can also directly instantiate a circuit with a list of gates (preferred)
circuit2 = Circuit(mygates)

# It is possible to concatenate circuit objects to form deeper circuits
circuit3 = Circuit(mygates) + Circuit([Gate("RZ", 4, parameter="alpha", is_variational=True)])

This code snippet highlights a few interesting methods and attributes:

# Examine properties of a circuit directly
print(f"The number of gates contained in circuit3 is {circuit3.size}")
print(f"The number of qubits in circuit3 is {circuit3.width}")
print(f"Does circuit have gates tagged as variational ? {circuit3.is_variational}")
print(f"Gate counts: {circuit3.counts}")

# Access and modify the variational gates (here the first one) in your circuit
circuit3._variational_gates[0].parameter = 777.
print(circuit3})

outputs:

14

1

2

3

4

5

6

7

8

9

10

11

12

13

"The number of gates contained in circuit3 is" 6
"The number of qubits in circuit3 is" 5
"Does circuit have gates tagged as variational ?" True
Gate counts: {’H’: 1, ’CNOT’: 2, ’Y’: 1, ’RX’: 1, ’RZ’: 1}

Circuit object. Size 6

H
CNOT
CNOT
Y
RX
RZ

target : 2
target : 1
target : 2
target : 0
target : 1
target : 4

control : 0
control : 1

parameter : 2.0
parameter : 777.0

(variational)

Some convenience operators have been deﬁned on the Circuit class, such as ==, !=, + (concatenation) and *

(repetition). Some additional methods are also available:

• inverse returns the inverse (“dagger”) of the unitary corresponding to the circuit.

• split identiﬁes non-entangled subsystems that can be simulated independently and breaks the initial circuit

into several “narrower” circuits, thus lowering resource requirements.

• stack combines several circuits to form a wider one, in order to ﬁll a quantum device as much as possible.
This can be used to run multiple shots in parallel, thus reducing cost of a quantum experiment. Executing it
accurately can however be a more challenging task for the device.

Tangelo performs a number of checks regarding qubit indices, but ultimately allows you to provide whatever
gate name or value for parameters you’d like, as long as it’s one of the supported types. This data only needs to
fully make sense once your circuit is converted into a backend-speciﬁc format: only then some error may arise if
you are attempting to use a gate name or parameter value that is not supported by Tangelo or the target backend.
The variable below returns a dictionary showing the available backends, as well as the gate names supported with
each of them.

1

from tangelo.linq import SUPPORTED_GATES

3.5 Measurement Protocols

The number of measurements of the qubit register correlates with both the cost of an experiment and the theoretical
accuracy of its results. DMET and VQE are both iterative procedures that would require a prohibitive amount of
measurements. In the following, we simply focus on the steps used to recompute the total energy of the H10 system
with the DMET approach used in 3.3.1, using the circuits with optimal variational parameters and qubit operators.
Extracting them from the DMET object is rather straightforward:

1

fragment, fragment_qb_ham, fragment_circuit = dmet_solver.quantum_fragments_data[0]

To obtain the 1- and 2-RDMs needed for the DMET energy calculation, we need to measure every term in
the Hamiltonian that yields a qubit operator with a non-imaginary coeﬃcient (the energy of a molecular system
is real, imaginary ones would not contribute to calculations). This is where various toolboxes come to the rescue,
and allow us to quickly put together custom code to identify these qubit operators. The FermionOperator and
QubitOperator classes are subclasses of the classes with the same name provided by the OpenFermion package,
while fermion_to_qubit_mapping is a uniﬁed interface to several diﬀerent qubit mappings.

15

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

from tangelo.toolboxes.operators import FermionOperator, QubitOperator
from tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping

# Find all the measurement bases that are needed to compute the RDMs.
# Accumulate them in a QubitOperator object to manipulate them afterwards.
qubit_op_rdm = QubitOperator()
bases_to_measure = set()

for term in fragment.fermionic_hamiltonian.terms:

fermionic_term = FermionOperator(term, 1.0)

qubit_term = fermion_to_qubit_mapping(fermion_operator=fermionic_term, mapping="scBK",

n_spinorbitals=fragment.n_active_sos,
n_electrons=fragment.n_active_electrons,
up_then_down=True)

qubit_term.compress()

for basis, coeff in qubit_term.terms.items():

if coeff.real != 0 and basis:

bases_to_measure.add(basis)
qubit_op_rdm.terms[basis] = coeff

Printing qubit_op_rdm shows that we have identiﬁed nine terms for this H10 ring, or equivalently nine measure-
ment bases, leading to nine slightly diﬀerent variations of our optimized quantum circuits, if we want to compute
the RDMs.

3.5.1 Term Grouping

Applying for example the idea of qubit-wise commutativity [68] to group terms, only ﬁve measurement bases (i.e.,
circuits) are needed. After a closer look, we see that the data obtained by running 5 of these circuits can be used
and agglomerated to generate even better data for the remaining 4 computational bases.

Figure 6: Grouping terms using qubit-wise commutativity tells us that collecting data for 5 measurements bases
provides us with data for the 4 others, whose expectation values can be computed more accurately by combining
the shots coming from several of them

Reducing the number of measurements while achieving satisfying accuracy is a challenge that increases with
problem size: the number of possible terms to measure scales exponentially (O(4N ) where N is the number of
qubits). Creating larger groups typically comes at the cost of running a longer circuit, which in most cases in
unfeasible due to device noise.

The measurements toolbox provides tools to help us apply some of these ideas. The function below returns a
dictionary where the information from measuring the parent term can be used to get the expectation value for each
term in the group. This particular grouping attempts to ﬁnd the Minimum Clique Cover: this problem may admit

16

1

2

3

4

5

6

7

8

9

10

1

2

3

4

5

6

7

8

9

10

several solutions, and what is returned by the algorithm depends on the value of the seed parameter, introducing
some randomness.

from tangelo.toolboxes.measurements import group_qwc

qwc_map = group_qwc(qubit_op_rdm, seed=0)

# Current value of qwc_map printed below
{((0, ’X’), (1, ’X’)): 0.25 [X0 X1],

((0, ’X’), (1, ’Z’)): 0.25 [X0] + 0.25 [X0 Z1] + 0.25 [Z1],
((0, ’Y’), (1, ’Y’)): -0.25 [Y0 Y1],
((0, ’Z’), (1, ’X’)): 0.25 [Z0] + 0.25 [Z0 X1] + 0.25 [X1],
((0, ’Z’), (1, ’Z’)): 0.25 [Z0 Z1]}

3.5.2 Measurement Estimation
To achieve a desired accuracy of a qubit Hamiltonian expressed as ˆH = (cid:80)
estimate for each Pauli word Pi by assuming its standard deviation scales as
magnitude of its coeﬃcient ci.

i ciPi, we can create a measurement
1√
. This is then weighted by the

nshots

from tangelo.toolboxes.measurements.estimate_measurements import get_measurement_estimate

measurements = {k: get_measurement_estimate(v, digits=2) for k,v in qwc_map.items()}

# Value of qwc_map
{((0, ’X’), (1, ’X’)): {((0, ’X’), (1, ’X’)): 62500},

((0, ’X’), (1, ’Z’)): {((0, ’X’),): 62500, ((0, ’X’), (1, ’Z’)): 62500, ((1, ’Z’),): 62500},
((0, ’Y’), (1, ’Y’)): {((0, ’Y’), (1, ’Y’)): 62500},
((0, ’Z’), (1, ’X’)): {((0, ’Z’),): 62500, ((0, ’Z’), (1, ’X’)): 62500, ((1, ’X’),): 62500},
((0, ’Z’), (1, ’Z’)): {((0, ’Z’), (1, ’Z’)): 62500}}

Beyond the examples above, emergent methods like classical shadows [69] are developed to mitigate the mea-
surement overhead by oﬄoading quantum tasks to the pre- and post-processing steps. This prediction protocol
exhibits logarithmic scaling with the number of shots to evaluate properties of a state. Tangelo users can leverage
this protocol by performing the relevant pre- and post-processing functions. We look forward to introducing more
grouping techniques and data-structures to help users devise eﬃcient measurement protocols within their target
budget.

3.6 Executing Quantum Circuits

Tangelo oﬀers several ways to submit an experiment to a quantum device or a noisy simulator that can approach
realistic behavior. The output of this step leads to a probability distribution, mapping bitstrings to how often they
have been observed for the speciﬁed number of shots. Depending on the platform used to run the experiment, some
additional data about the hardware and how it performed may be available.

3.6.1 Using QEMIST Cloud

The simplest way to submit an experiment to any device available on the supported quantum cloud services is
through QEMIST Cloud’s client library, allowing users to run quantum hardware experiments using their QEMIST
Cloud account credentials and credits. This is possible if you have access to QEMIST Cloud, and have installed
the qemist-client Python package. For more details about this feature, please refer to our dedicated notebook, and
reach out about QEMIST Cloud. Our convenience wrappers and functions can facilitate the submission and cost
estimation of experiments.

Below, a simple code snippet illustrating how to run 10,000 shots of the YY circuit on IonQ’s hardware, through

Amazon’s Braket quantum cloud services:

17

1

2

3

4

5

6

7

8

9

10

11

12

13

14

1

2

3

4

1

2

3

4

5

6

7

# Retrieve both these values from your QEMIST Cloud dashboard
import os
os.environ[’QEMIST_PROJECT_ID’] = "your_project_id_string"
os.environ[’QEMIST_AUTH_TOKEN’] = "your_qemist_authentication_token"

from tangelo.linq.qpu_connection import job_submit, job_status, job_result, job_estimate

# Estimate cost of task on different backends
price_estimates = job_estimate(circuit_YY, n_shots=n_shots)

# Submit task and retrieve results
backend = ’arn:aws:braket:::device/qpu/ionq/ionQdevice’
job_id = job_submit(circuit_YY, n_shots=n_shots, backend=backend)
freqs, raw_data = job_result(job_id)

3.6.2 Using a Quantum Cloud API and Format Conversion

The utility functions in tangelo.linq allow us to convert our generic circuit object into a variety of formats
supported by other open-source packages and services, such as Amazon’s Braket and Microsoft’s Azure Quantum.
You can thus convert a Circuit object into the desired format and use the API of those services directly in order to
reach a QPU or an online simulator.

If you convert a Circuit object into the Braket format, the submission process is pretty straightforward provided
that you have a Braket account, as demonstrated in the Braket documentation. Likewise, Azure Quantum supports
a number of formats. Our package provides similar “translation” functions allowing us to produce a Circuit object
into the Q#, qiskit or a cirq format, for example. Provided we have a working Azure Quantum environment, our
circuits can be submitted using their API. The code snippet below illustrate how straightforward the process is:

from tangelo.linq.translator import translate_braket, translate_cirq, translte_qiskit
braket_circuit = translate_braket(circuit_YY)
cirq_circuit = translate_cirq(circuit_YY)
qiskit_circuit = translate_qiskit(circuit_YY)

Some hardware providers rely on a speciﬁc format and may provide an API for directly submitting experiments
to their devices to their close collaborators. The format conversion functions can be used in all these cases as well;
check out what your favorite hardware providers oﬀer, we are happy to support new platforms users deem relevant.

3.6.3 Emulation on a Simulator Backend

The format conversion functions can be used to target the simulators of your choice, and are also useful if you need
to save or share a circuit in a particular format with your collaborators. The linq module provides the Simulator
class, which acts as a uniﬁed interface to the various backends we support. You can modify the behaviour of your
Simulator object by indicating the target backend, number of shots, or noise model.

The convenient simulate method allows you to immediately simulate your circuit: you do not have to write
any backend-speciﬁc code or explicitly use the format conversion functions. This is done automatically for you, you
only have to specify a backend.

# Noiseless simulator returning the state vector
sim_cirq = Simulator(target="cirq")
freqs, sv = sim_cirq.simulate(my_circuit, return_statevector=True))

# Noiseless simulator running multiple shots
sim_qulacs = Simulator(target="qulacs", n_shots=1000)
freqs, _ = sim_qulacs.simulate(my_circuit}

The simulate method returns a 2-tuple:

18

• A sparse histogram of frequencies associated to the diﬀerent observed states, in least-signiﬁcant qubit ﬁrst
order (e.g ’01’ means qubit 0 (resp. 1) measured in |0(cid:105) (resp. |1(cid:105)) state). That is, it is to be read “left-to-right”
in order to map each qubit to the basis state it was observed in.

• A representation of the quantum state (often a state vector), if available on the target backend and if the user

speciﬁes it using the return_statevector optional parameter. Otherwise, this returns None.

While we return frequency histogram keys in a standardized way, we do not alter the internal representa-
tion of the quantum state provided by the target backend. We however provide some information in variable
linq.backend_info, like the ordering of the entries of the state vector for example, which is helpful if you use
the initial_statevector option of simulate, to avoid re-simulating a sequence of gates leading to a known state
vector.

Below is an example of how you can use the generic NoiseModel object to perform noisy simulation. We show

an example applying a depolarization channel to speciﬁc gates, each with a given probability.

from tangelo.linq import Simulator
from tangelo.linq.noisy_simulation import NoiseModel

nmp = NoiseModel()
nmp.add_quantum_error("CNOT", "depol", 0.01)
nmp.add_quantum_error("RZ", "depol", 0.005)
nmp.add_quantum_error("H", "depol", 0.005)
backend_noisy = Simulator(target="cirq", n_shots=n_shots, noise_model=nmp)

3.7 Post-processing

3.7.1 Expectation Values

The Simulator class provides two methods to compute expectation values with regards to an object of type
QubitOperator.

The Simulator class method get_expectation_values_from_frequencies_oneterm computes expectation
values from a histogram of frequencies and a single-term qubit operator. This is useful for post-processing the
outcome of a quantum circuit executed on a device, or when separating simulation from post-processing. By
looping over the terms and corresponding frequencies, users are able to compute the expectation values of qubit
operators with an arbitrary number of terms.

If you are using a simulator, the get_expectation_value method is the fastest way to simulate a circuit and

compute its expectation value with regards to a qubit operator using a Circuit object.

# Openfermion operators can be used
from openfermion.ops import QubitOperator
op = 1.0 * QubitOperator(’Z0’)

# Directly through a simulator backend, providing the state-preparation circuit
# A single line regardless of the size of the qubit operator
sim = Simulator(target="cirq")
expval1 = sim.get_expectation_value(op, c)

# Or from a histogram computed separately beforehand, with a single-term qubit operator.
# Useful for post-processing results of an experiment on a quantum device
freqs, _ = sim.simulate(c) # This could happen on a quantum device instead
term, coef = tuple(op.terms.items())[0] # This yields ((0, ’Z’),), 1.0
expval2 = coef * Simulator.get_expectation_value_from_frequencies_oneterm(term, freqs)

3.7.2 Error Mitigation

Due to noise, the hardware produces a mixed state, which reduces the accuracy of our observables. Although error
correction is not currently available, we can use hardware-agnostic post-processing techniques to mitigate noise on
near-term hardware. Tangelo aims to provide, through its toolboxes, a collection of noise-mitigation techniques.

19

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

8

9

10

11

12

13

14

As an example of error mitigation for the DMET H10 ring use case, we use a density matrix puriﬁcation technique
based on McWeeny’s method [70] to purify our noisy state to the dominant eigenvector. For our particular use case,
we can use this method for the 2-RDM since our fragments consist of two electrons — thus the 2-RDM is the full
density matrix, and idempotency can be imposed. We can draw the required function from a toolbox and apply it
as follows:

1

2

from tangelo.toolboxes.post_processing.mc_weeny_rdm_purification import mcweeny_purify_2rdm
onerdm, twordm = mcweeny_purify_2rdm(twordm, conv=1e-2)

This method is however limited to systems with two electrons: in general, applying the technique to 2-RDMs of
higher electron systems would require the more sophisticated N-representability conditions. Application-agnostic
error mitigation methods such as error extrapolation are also available in Tangelo [71–73]. We are working on
integrating more error-mitigation techniques, chemistry-inspired or not.

3.8 Statistical Treatment

Experimental data requires a measure of its uncertainty. As it is often prohibitively expensive to collect large
amounts of data on quantum computers for the purpose of estimating uncertainty, we generate statistics from our
dataset using an established method called bootstrapping [74]. For each histogram obtained from our experiment,
we resample with replacement from that distribution to generate new histograms of the same sample size. We
then use these histograms to calculate a new set of expectation values, RDMs, and total energies. This process is
repeated many times to form a statistical series, from which we calculate the average energy and standard deviation
of our experiment.

We can put this together rather quickly by drawing the get_resampled_frequencies function in one of the

toolboxes in Tangelo, and combining it with others to arrive at the result.

from tangelo.toolboxes.post_processing.bootstrapping import get_resampled_frequencies

fragment_energies = list()

for n in range(10000): # 10000 samples

# Draw random bootstrap samples and construct new histograms.
resample_freq = {term: get_resampled_frequencies(freq, n_shots)

for term, freq in freq_dict.items()}

# Compute expectation values.
exp_vals = {term: Simulator.get_expectation_value_from_frequencies_oneterm(term, hist)

for term, hist in resample_freq.items()}

# Construct 1- and 2-RDMs, purify with Mcweeny.
onerdm, twordm, _, _ = compute_rdms(fragment, exp_vals)
onerdm_spinsum, twordm_spinsum = mcweeny_purify_2rdm(twordm, conv=1e-2)

# Calculate the total energy.
e_fragment = compute_electronic_fragment_energy(fragment, onerdm_spinsum, twordm_spinsum)

+ core_constant
fragment_energies.append(e_fragment)

# Calculate the mean and standard deviation.
mean = np.mean(fragment_energies)
stdev = np.std(fragment_energies, ddof=1)

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

In this situation, the reusable code found in the various toolboxes in Tangelo can help us quickly draw what we

need, and put together code to arrive at the relevant answers.

20

4 Open-source Management, Community and Philosophy

Tangelo was designed as a tool to empower both its developers and the community at large. The ﬁeld of quantum
computing is seeing a lot of innovation and moving at a fast pace: we decided to make this software open-source
and compatible with multiple frameworks to enable the community to make the most of this momentum.

By developing Tangelo, we aspire to support users from both academia and industry in designing successful
quantum chemistry applications and experiments on quantum devices. We hope to build a community around
these outcomes, and further develop this package with the contributions of our users, to the beneﬁt of the ﬁeld as
a whole.

4.1 Software Development Practices

Tangelo is a package written in Python 3, following the PEP8 coding guidelines [75]. It provides extensive doc-
umentation and descriptive names for classes and functions, in order to support usage and further developments
from the community. We rely on the Python unittest framework in order to systematically test that the code works
as intended, and guarantee reliable outcomes.

We strive to develop code that is easy to use, and as modular as possible in order to provide the community
with highly-reusable building blocks that can be assembled or tinkered with, to support our quantum explorations.
Tangelo is hosted on Github, at https://github.com/goodchemistryco/Tangelo. Users can contribute in various
ways detailed in the contribution ﬁle, including making feature requests and reporting bugs through the Issue tab.
It is possible for anyone to contribute code to this project by following the standard Pull Request (PR) process
available on Github, which is reviewed by at least one of the members of the Tangelo team before being integrated
into the code base. In order to ensure that Tangelo remains reliable, the package is automatically rebuilt, tested,
and the documentation updated after a pull request has been merged.

4.2 Distribution

There are several diﬀerent channels of distribution for Tangelo. Tangelo can be deployed over MacOS and Linux in
a straightforward way using tools such as git and pip, and also to Windows, using the Windows Linux Subsystem
(wsl), or Docker.

User can directly retrieve the source code of Tangelo on Github. This option is better suited for users who want
to beneﬁt from the latest changes and ongoing developments on the various branches of the repository, as well as
work collaboratively. It is then possible to install the package and its dependencies using pip, from the top directory
of Tangelo, containing the ﬁle setup.py.

Please refer to the latest installation instructions in the Github repository (README ﬁle), as the following

instructions may be outdated in the future.

Tangelo is distributed through the Python Package Index (PyPI) [76], which means users can directly install it

through the command

$ pip install tangelo-gc

After cloning the repository or downloading the ﬁles from Github, it is possible to install Tangelo from sources.
This may be helpful to developers, as well as users who wish to deploy Tangelo in speciﬁc environments, such as
High-Performance Computing systems or systems with no access to PyPI.

$ python -m pip install .

Finally, Tangelo can be deployed to various environments using Docker. The GitHub repository contains a ﬁle
called Dockerfile which can be used to build a Docker container and deployed in any environment, including
Windows.

Tangelo features a number of optional dependencies that can be installed separately (qiskit, qulacs, braket...),
following the instructions of their respective development teams. Most of them come in the form of Python packages
available on PyPI, and are straightforward to install. A number of these packages are related to the various quantum
circuit simulators and formats supported.

21

5 Closing remarks

It is our wish to expand the capability of this platform and develop a community around it, to further research
applications of quantum computing to materials science as well as providing the tools to design successful hardware
experiments.

The ﬁeld oﬀers an abundance of challenges to tackle, and we need to leverage the skills of people with various
backgrounds to overcome them. Although the primary areas of interest seem to be quantum computing and
advanced materials simulation, various domains of applied mathematics and software development play a crucial
role in the pace of innovation. You do not necessarily need to be a seasoned software-developer or a quantum
computing expert to contribute to this project. By sharing your ideas and your developments with the community,
you are creating an opportunity for us to learn and grow together, and take ideas to the ﬁnish line and beyond.

Please do not hesitate to reach out to report bugs or suggest new features for Tangelo.

Implementation of
state-of-the-art quantum chemistry algorithms, functions helping users to connect to new backends, reducing mea-
surement overhead, approaches based on ﬁrst quantization, and computing other properties of materials are just
a few of the many topics that are relevant to the community. Integration with other packages is also desirable,
including those focusing on quantum circuit optimization, compilation, and simulation.

What will you do with Tangelo?

6 Acknowledgments

The authors would like to thank our advisor Isaac Kim (UC Davis) for his continuous input and feedback. We
acknowledge the technical contributions from the ongoing research collaboration between the Good Chemistry
Company and Dow, Inc., which helped shape the foundation of Tangelo. We would also like to thank Nima
Alidoust for his advice and vision.

We would like to thank all the contributors to the various open-source projects this software and our research rely
on. Tangelo leverages various python packages, focusing on topics such as classical chemistry, quantum computing
applied to materials science, or quantum circuit emulators and interfaces connecting to quantum devices, among
others. [2, 3, 51–55, 77]

References

[1] Noel M. O’Boyle et al. “Open Babel: An open chemical toolbox”. In: Journal of Cheminformatics 3.1 (Oct.
2011), p. 33. issn: 1758-2946. doi: 10.1186/1758- 2946- 3- 33. url: https://doi.org/10.1186/1758-
2946-3-33.

[2] Qiming Sun et al. “PySCF: the Python-based simulations of chemistry framework”. In: WIREs Computational

Molecular Science 8.1 (2018), e1340. doi: https://doi.org/10.1002/wcms.1340.

[3] Qiming Sun et al. “Recent developments in the PySCF program package”. In: The Journal of Chemical

Physics 153.2 (2020), p. 024109. doi: 10.1063/5.0006074.

[4] Alberto Peruzzo et al. “A variational eigenvalue solver on a quantum processor”. In: Nat Commun 5.1 (Sept.
2014). arXiv: 1304.3061, p. 4213. issn: 2041-1723. doi: 10.1038/ncomms5213. (Visited on 10/26/2021).
[5] Jarrod R McClean et al. “The theory of variational hybrid quantum-classical algorithms”. In: New Journal

of Physics 18.2 (Feb. 2016), p. 023023. doi: 10.1088/1367-2630/18/2/023023.

[6] Harper R. Grimsley et al. “An adaptive variational algorithm for exact molecular simulations on a quantum
computer”. In: Nat Commun 10.1 (Dec. 2019). arXiv: 1812.11173, p. 3007. issn: 2041-1723. doi: 10.1038/
s41467-019-10988-2. (Visited on 07/21/2021).

[7] Saad Yalouz et al. “A state-averaged orbital-optimized hybrid quantum–classical algorithm for a democratic
description of ground and excited states”. In: Quantum Science and Technology 6.2 (Jan. 2021), p. 024004.
doi: 10.1088/2058-9565/abd334. url: https://doi.org/10.1088/2058-9565/abd334.

[8] Mario Motta et al. “Determining eigenstates and thermal states on a quantum computer using quantum
imaginary time evolution”. In: Nature Physics 16.2 (Nov. 2019), pp. 205–210. issn: 1745-2481. doi: 10.1038/
s41567-019-0704-4.

22

[9] James D. Whitﬁeld, Jacob Biamonte, and Al´an Aspuru-Guzik. “Simulation of electronic structure Hamiltoni-
ans using quantum computers”. In: Molecular Physics 109.5 (Mar. 2011), pp. 735–750. issn: 1362-3028. doi:
10.1080/00268976.2011.552441. url: http://dx.doi.org/10.1080/00268976.2011.552441.

[10] D. Lacroix. “Symmetry assisted preparation of entangled many-body states on a quantum computer”. In:
Phys. Rev. Lett. 125.23 (Dec. 2020). arXiv: 2006.06491, p. 230502. issn: 0031-9007, 1079-7114. doi: 10.1103/
PhysRevLett.125.230502. (Visited on 11/24/2021).

[11] Kenneth Choi et al. “Rodeo Algorithm for Quantum Computing”. In: Physical Review Letters 127.4 (July

2021). issn: 1079-7114. doi: 10.1103/physrevlett.127.040505.

[12] George D. Purvis and Rodney J. Bartlett. “A full coupled-cluster singles and doubles model: The inclusion

of disconnected triples”. In: J. Chem. Phys. 76.4 (1982), pp. 1910–1918.

[13] Rodney J. Bartlett and Monika Musia(cid:32)l. “Coupled-cluster theory in quantum chemistry”. In: Rev. Mod. Phys.
79 (1 Feb. 2007), pp. 291–352. doi: 10.1103/RevModPhys.79.291. url: https://link.aps.org/doi/10.
1103/RevModPhys.79.291.

[14] Richard C. Bingham, Michael J. S. Dewar, and Donald H. Lo. “Ground states of molecules. XXV. MINDO/3.
Improved version of the MINDO semiempirical SCF-MO method”. In: Journal of the American Chemical Soci-
ety 97.6 (1975), pp. 1285–1293. doi: 10.1021/ja00839a001. url: https://doi.org/10.1021/ja00839a001.
[15] Michael J. S. Dewar and Walter Thiel. “Ground states of molecules. 38. The MNDO method. Approximations
and parameters”. In: Journal of the American Chemical Society 99.15 (1977), pp. 4899–4907. doi: 10.1021/
ja00457a004. url: https://doi.org/10.1021/ja00457a004.

[16] Gerald Knizia and Garnet Kin-Lic Chan. “Density Matrix Embedding: A Simple Alternative to Dynamical
Mean-Field Theory”. In: Phys. Rev. Lett. 109 (18 Nov. 2012), p. 186404. doi: 10.1103/PhysRevLett.109.
186404.

[17] Gerald Knizia and Garnet Kin-Lic Chan. “Density Matrix Embedding: A Strong-Coupling Quantum Embed-
ding Theory”. In: Journal of Chemical Theory and Computation 9.3 (2013). PMID: 26587604, pp. 1428–1432.
doi: 10.1021/ct301044e.

[18] R. K. Nesbet. “Atomic Bethe-Goldstone Equations. I. The Be Atom”. In: Phys. Rev. 155 (1 Mar. 1967),

pp. 51–55. doi: 10.1103/PhysRev.155.51.

[19] R. K. Nesbet. “Atomic Bethe-Goldstone Equations. II. The Ne Atom”. In: Phys. Rev. 155 (1 Mar. 1967),

pp. 56–58. doi: 10.1103/PhysRev.155.56.

[20] R. K. Nesbet. “Atomic Bethe-Goldstone Equations. III. Correlation Energies of Ground States of Be, B, C,

N, O, F, and Ne”. In: Phys. Rev. 175 (1 Nov. 1968), pp. 2–9. doi: 10.1103/PhysRev.175.2.

[21] H. Stoll. “The correlation energy of crystalline silicon”. In: Chem. Phys. Lett. 191.6 (Apr. 1992), pp. 548–552.

[22] M. M¨odl et al. “Quantum chemical ab initio calculations of the magnetic interaction in alkalithioferrates(III)”.

In: J. Chem. Phys. 106.5 (Feb. 1997), p. 1836.

[23] Hermann Stoll, Beate Paulus, and Peter Fulde. “On the accuracy of correlation-energy expansions in terms

of local increments”. In: J. Chem. Phys. 123.14 (2019/11/30 2005), p. 144108.

[24] Joachim Friedrich, Michael Hanrath, and Michael Dolg. “Fully automated implementation of the incremental
scheme: Application to CCSD energies for hydrocarbons and transition metal compounds”. In: J. Chem. Phys.
126.15 (2019/02/13 2007), p. 154110.

[25] J. Friedrich and J. H¨anchen. “Incremental CCSD(T)(F12*)—MP2-F12: A Black Box Method To Obtain

Highly Accurate Reaction Energies”. In: J. Chem. Theory Comput. 9.12 (2013), pp. 5381–5394.

[26] J. Friedrich and K. Walczak. “Incremental CCSD(T)(F12*)—MP2-F12: A Method to Obtain Highly Accurate

CCSD(T) Energies for Large Molecules”. In: J. Chem. Theory Comput. 9.1 (2013), pp. 408–417.

[27] Ryan M. Richard and John M. Herbert. “A generalized many-body expansion and a uniﬁed view of fragment-
based methods in electronic structure theory”. In: J. Chem. Phys. 137 (2012/07/24 2012), p. 064113.

[28] Paul M. Zimmerman. “Incremental full conﬁguration interaction”. In: J. Chem. Phys. 146.10 (2017/10/04

2017), p. 104102.

[29] Paul M. Zimmerman. “Singlet–Triplet Gaps through Incremental Full Conﬁguration Interaction”. In: J. Phys.

Chem. A 121.24 (June 2017), pp. 4712–4720.

23

[30] P. M. Zimmerman and A. E. Rask. “Evaluation of full valence correlation energies and gradients”. In: J.

Chem. Phys. 150.24 (June 2019), p. 244117.

[31] J. J. Eriksen and J. Gauss. “Many-Body Expanded Full Conﬁguration Interaction. I. Weakly Correlated

Regime”. In: J. Chem. Theory Comput. 14.10 (2018), pp. 5180–5191.

[32] J. J. Eriksen and J. Gauss. “Many-Body Expanded Full Conﬁguration Interaction. II. Strongly Correlated

Regime”. In: J. Chem. Theory Comput. 15.9 (2019), pp. 4873–4884.

[33] J. J. Eriksen and J. Gauss. “Generalized Many-Body Expanded Full Conﬁguration Interaction Theory”. In:

The J. Phys. Chem. Letters 10.24 (2019), pp. 7910–7915.

[34] Prakash Verma et al. “Scaling up electronic structure calculations on quantum computers: The frozen natural
orbital based method of increments”. In: The Journal of Chemical Physics 155.3 (2021), p. 034110. doi:
10.1063/5.0054647.

[35] Arieh Warshel and Michael Levitt. “Theoretical studies of enzymic reactions: dielectric, electrostatic and
steric stabilization of the carbonium ion in the reaction of lysozyme”. In: Journal of molecular biology 103.2
(1976), pp. 227–249.

[36] Adrian J Mulholland, Paul D Lyne, and Martin Karplus. “Ab initio QM/MM study of the citrate synthase
mechanism. A low-barrier hydrogen bond is not involved”. In: Journal of the American Chemical Society
122.3 (2000), pp. 534–535.

[37] Hans Martin Senn and Walter Thiel. “QM/MM methods for biomolecular systems”. In: Angewandte Chemie

International Edition 48.7 (2009), pp. 1198–1229.

[38] Gerrit Groenhof. “Introduction to QM/MM simulations”. In: Biomolecular Simulations (2013), pp. 43–66.

[39] S. Miertus, E. Scrocco, and J. Tomasi. “Electrostatic interaction of a solute with a continuum. A direct
utilizaion of AB initio molecular potentials for the prevision of solvent eﬀects”. In: Chemical Physics 55.1
(1981), pp. 117–129. issn: 0301-0104. doi: https : / / doi . org / 10 . 1016 / 0301 - 0104(81 ) 85090 - 2. url:
https://www.sciencedirect.com/science/article/pii/0301010481850902.

[40] S. Miertus and J. Tomas. “Approximate evaluations of the electrostatic free energy and internal energy
changes in solution processes”. In: Chemical Physics 65.2 (1982), pp. 239–245. issn: 0301-0104. doi: https:
//doi.org/10.1016/0301-0104(82)85072-6. url: https://www.sciencedirect.com/science/article/
pii/0301010482850726.

[41] J. L. Pascual-Ahuir, E. Silla, and I. Tu˜non. “GEPOL: An improved description of molecular surfaces. III. A new
algorithm for the computation of a solvent-excluding surface”. In: Journal of Computational Chemistry 15.10
(1994), pp. 1127–1138. doi: https://doi.org/10.1002/jcc.540151009. eprint: https://onlinelibrary.
wiley.com/doi/pdf/10.1002/jcc.540151009. url: https://onlinelibrary.wiley.com/doi/abs/10.
1002/jcc.540151009.

[42] Takeshi Yamazaki et al. Towards the Practical Application of Near-Term Quantum Computers in Quantum

Chemistry Simulations: A Problem Decomposition Approach. 2018. arXiv: 1806.01305 [quant-ph].

[43] Mats Svensson et al. “ONIOM: A Multilayered Integrated MO + MM Method for Geometry Optimizations
and Single Point Energy Predictions. A Test for Diels-Alder Reactions and Pt(P(t-Bu)3)2 + H2 Oxidative
Addition”. In: The Journal of Physical Chemistry 100.50 (1996), pp. 19357–19363. doi: 10.1021/jp962071j.
url: https://doi.org/10.1021/jp962071j.

[44] Thom Vreven and Keiji Morokuma. “Chapter 3 Hybrid Methods: ONIOM(QM:MM) and QM/MM”. In: ed.
by David C. Spellmeyer. Vol. 2. Annual Reports in Computational Chemistry. Elsevier, 2006, pp. 35–51. doi:
https://doi.org/10.1016/S1574-1400(06)02003-2. url: https://www.sciencedirect.com/science/
article/pii/S1574140006020032.

[45] Stefan Dapprich et al. “A new ONIOM implementation in Gaussian98. Part I. The calculation of energies,
gradients, vibrational frequencies and electric ﬁeld derivatives1Dedicated to Professor Keiji Morokuma in
celebration of his 65th birthday.1”. In: Journal of Molecular Structure: THEOCHEM 461-462 (1999), pp. 1–
21. issn: 0166-1280. doi: https : / / doi . org / 10 . 1016 / S0166 - 1280(98 ) 00475 - 8. url: https : / / www .
sciencedirect.com/science/article/pii/S0166128098004758.

[46] Lung Wa Chung et al. “The ONIOM Method and Its Applications”. In: Chemical Reviews 115.12 (2015).

PMID: 25853797, pp. 5678–5796. doi: 10.1021/cr5004419.

[47] Tery L. Barr and Ernest R. Davidson. “Nature of the Conﬁguration-Interaction Method in Ab Initio Calcu-

lations. I. Ne Ground State”. In: Phys. Rev. A 1 (3 Mar. 1970), pp. 644–658.

24

[48] Carlos Sosa et al. “Selection of the reduced virtual space for correlated calculations. An application to the
energy and dipole moment of H2O”. In: Chem. Phys. Lett. 159.2 (1989), pp. 148–154. issn: 0009-2614.
[49] Andrew G. Taube and Rodney J. Bartlett. “Frozen Natural Orbitals: Systematic Basis Set Truncation for
Coupled-Cluster Theory”. In: Collect. Czech. Chem. Commun. 70.6 (Unspeciﬁed 2005), pp. 837–850.

[50] Andrew G. Taube and Rodney J. Bartlett. “Improving upon CCSD(T): Λ CCSD(T). I. Potential energy

surfaces”. In: J. Chem. Phys. 128.4 (2008), p. 044110.

[51] Cirq Developers. Cirq. Version v0.12.0. See full list of authors on Github: https://github .com/quantumlib/-

Cirq/graphs/contributors. Aug. 2021. doi: 10.5281/zenodo.5182845.

[52] MD SAJID ANIS et al. Qiskit: An Open-source Framework for Quantum Computing. 2021. doi: 10.5281/

zenodo.2573505.

[53] Yasunari Suzuki et al. “Qulacs: a fast and versatile quantum circuit simulator for research purpose”. In:
Quantum 5 (Oct. 2021). arXiv: 2011.13524, p. 559. issn: 2521-327X. doi: 10.22331/q- 2021- 10- 06- 559.
(Visited on 10/26/2021).

[54] Amazon Braket. 2021. url: https://aws.amazon.com/braket/.
[55] Microsoft Quantum Development Kit. 2017. url: https://microsoft.com/quantum.
[56] Yukio Kawashima et al. “Optimizing electronic structure simulations on a trapped-ion quantum computer
using problem decomposition”. In: Communications Physics 4.1 (Nov. 2021), p. 245. issn: 2399-3650. doi:
10.1038/s42005-021-00751-9.

[57] Zhang Jiang et al. “Optimal fermion-to-qubit mapping via ternary trees with applications to reduced quantum

states learning”. In: Quantum 4 (June 2020), p. 276. issn: 2521-327X. doi: 10.22331/q-2020-06-04-276.

[58] Panagiotis Kl Barkoutsos et al. “Quantum algorithms for electronic structure calculations: particle/hole
Hamiltonian and optimized wavefunction expansions”. In: Phys. Rev. A 98.2 (Aug. 2018). arXiv: 1805.04340,
p. 022322. issn: 2469-9926, 2469-9934. doi: 10.1103/PhysRevA.98.022322. (Visited on 07/15/2021).
[59] Yangchao Shen et al. “Quantum Implementation of Unitary Coupled Cluster for Simulating Molecular Elec-
tronic Structure”. In: Phys. Rev. A 95.2 (Feb. 2017). arXiv: 1506.00443, p. 020501. issn: 2469-9926, 2469-9934.
doi: 10.1103/PhysRevA.95.020501. (Visited on 07/20/2021).
Igor O. Sokolov et al. “Quantum Orbital-Optimized Unitary Coupled Cluster Methods in the Strongly Corre-
lated Regime: Can Quantum Algorithms Outperform their Classical Equivalents?” In: J. Chem. Phys. 152.12
(Mar. 2020). arXiv: 1911.10864, p. 124107. issn: 0021-9606, 1089-7690. doi: 10.1063/1.5141835. (Visited on
07/20/2021).

[60]

[61] Joonho Lee et al. “Generalized Unitary Coupled Cluster Wavefunctions for Quantum Computation”. In: J.
Chem. Theory Comput. 15.1 (Jan. 2019). arXiv: 1810.02327, pp. 311–324. issn: 1549-9618, 1549-9626. doi:
10.1021/acs.jctc.8b01004. (Visited on 07/20/2021).

[62] Abhinav Kandala et al. “Hardware-eﬃcient Variational Quantum Eigensolver for Small Molecules and Quan-
tum Magnets”. In: Nature 549.7671 (Sept. 2017). arXiv: 1704.05018, pp. 242–246. issn: 0028-0836, 1476-4687.
doi: 10.1038/nature23879. (Visited on 07/15/2021).
Ilya G. Ryabinkin et al. “Qubit Coupled Cluster Method: A Systematic Approach to Quantum Chemistry on
a Quantum Computer”. In: Journal of Chemical Theory and Computation 14.12 (Dec. 2018), pp. 6317–6326.
issn: 1549-9618. doi: 10.1021/acs.jctc.8b00932. url: https://doi.org/10.1021/acs.jctc.8b00932.

[63]

[64] Alexander J. McCaskey et al. “Quantum chemistry as a benchmark for near-term quantum computers”. In:
npj Quantum Inf 5.1 (Nov. 2019), pp. 1–8. issn: 2056-6387. doi: 10.1038/s41534-019-0209-0. (Visited on
07/20/2021).

[65] Shunji Matsuura et al. “Variationally scheduled quantum simulation”. In: Phys. Rev. A 103 (5 May 2021),
p. 052435. doi: 10.1103/PhysRevA.103.052435. url: https://link.aps.org/doi/10.1103/PhysRevA.
103.052435.

[66] Qiming Sun and Garnet Kin-Lic Chan. “Exact and Optimal Quantum Mechanics/Molecular Mechanics
Boundaries”. In: Journal of Chemical Theory and Computation 10.9 (2014). PMID: 26588523, pp. 3784–
3790. doi: 10.1021/ct500512f.

[67] Gerald Knizia. “Intrinsic Atomic Orbitals: An Unbiased Bridge between Quantum Theory and Chemical
Concepts”. In: Journal of Chemical Theory and Computation 9.11 (2013). PMID: 26583402, pp. 4834–4843.
doi: 10.1021/ct400687b.

25

[68] Vladyslav Verteletskyi, Tzu-Ching Yen, and Artur F. Izmaylov. “Measurement optimization in the variational
quantum eigensolver using a minimum clique cover”. In: The Journal of Chemical Physics 152.12 (Mar. 2020),
p. 124114. issn: 1089-7690. doi: 10.1063/1.5141458.

[69] Hsin Yuan Huang, Richard Kueng, and John Preskill. “Predicting many properties of a quantum system from
very few measurements”. In: Nature Physics 16.10 (Oct. 2020). Publisher: Nature Research, pp. 1050–1057.
doi: 10.1038/s41567-020-0932-7.

[70] Lionel A. Truﬂandier, Rivo M. Dianzinga, and David R. Bowler. “Communication: Generalized canonical
puriﬁcation for density matrix minimization”. In: The Journal of Chemical Physics 144.9 (2016), p. 091102.
doi: 10.1063/1.4943213.

[71] P´eter Pulay. “Convergence acceleration of iterative sequences. the case of scf iteration”. In: Chemical Physics
Letters 73.2 (1980), pp. 393–398. issn: 0009-2614. doi: https://doi.org/10.1016/0009-2614(80)80396-4.
url: https://www.sciencedirect.com/science/article/pii/0009261480803964.

[72] Abhinav Kandala et al. “Error mitigation extends the computational reach of a noisy quantum processor”.
In: Nature 567.7749 (Mar. 2019), pp. 491–495. issn: 1476-4687. doi: 10.1038/s41586- 019- 1040- 7. url:
https://doi.org/10.1038/s41586-019-1040-7.

[73] Kristan Temme, Sergey Bravyi, and Jay M. Gambetta. “Error Mitigation for Short-Depth Quantum Circuits”.
In: Phys. Rev. Lett. 119 (18 Nov. 2017), p. 180509. doi: 10.1103/PhysRevLett.119.180509. url: https:
//link.aps.org/doi/10.1103/PhysRevLett.119.180509.

[74] B. Efron and R.J. Tibshirani. An Introduction to the Bootstrap. Chapman & Hall/CRC Monographs on
Statistics & Applied Probability. Taylor & Francis, 1994. isbn: 9780412042317. url: https://books.google.
ca/books?id=gLlpIUxRntoC.

[75] PEP 8 – Style Guide for Python Code. url: https://www.python.org/dev/peps/pep-0008/.
[76] Python Package Index (PyPI). url: https://pypi.org/.
[77] Jarrod R McClean et al. In: Quantum Science and Technology 5.3 (June 2020), p. 034014. doi: 10.1088/2058-

9565/ab8ebc.

26

