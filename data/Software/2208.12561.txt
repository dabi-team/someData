2
2
0
2

g
u
A
6
2

]
E
S
.
s
c
[

1
v
1
6
5
2
1
.
8
0
2
2
:
v
i
X
r
a

Computing Maximum Fixed Point Solutions over Feasible Paths
in Data Flow Analyses

Komal Pathade

TCS Research, India

Uday Khedker

Indian Institute of Technology Bombay, India

Abstract

The control ﬂow graph (CFG) representation of a procedure used by virtually all ﬂow-sensitive
program analyses, admits a large number of infeasible control ﬂow paths i.e., these paths do not
occur in any execution of the program. Hence the information reaching along infeasible paths in
an analysis is spurious. This aﬀects the precision of the conventional maximum ﬁxed point (MFP)
solution of the data ﬂow analysis, because it includes the information reaching along all control
ﬂow paths. The existing approaches for removing this imprecision are either speciﬁc to a data
ﬂow problem with no straightforward generalization or involve control ﬂow graph restructuring
which may exponentially blow up the size of the CFG.

We lift the notion of MFP solution to deﬁne the notion of feasible path MFP (FPMFP) so-
lutions that exclude the data ﬂowing along known infeasible paths. The notion of FPMFP is
generic and does not involve CFG restructuring. Instead, it takes externally supplied information
about infeasible paths and lifts any data ﬂow analysis to an analysis that maintains the distinc-
tions between diﬀerent paths where these distinctions are beneﬁcial, and ignores them where
they are not. Thus it gets the beneﬁt of a path-sensitive analysis where it is useful without per-
forming a conventional path-sensitive analysis. Hence, an FPMFP solution is more precise than
the corresponding MFP solution in most cases; it is guaranteed to be sound in each case.

We implemented the proposed computation of feasible path MFP solutions for reaching def-
initions analysis and potentially uninitialized variable analysis. We evaluated the precision im-
provement in these two analyses by analyzing 30 benchmark applications selected from open
source, industry, and SPEC CPU 2006. The evaluation results indicate that the precision im-
provement in these two analyses respectively reduce the number def-use pairs by up to 13.6%
(average 2.87%, geometric mean 1.75%), and reduce the potentially uninitialized variable alarms
by up to 100% (average 18.5%, geo. mean 3%). We found that the FPMFP computation time
was 2.9× of the MFP computation time on average.

Keywords: Compilers, Data Flow Analysis, Infeasible Control Flow Paths, Static Program
Analysis, Maximum Fixed-Point Solution

Email addresses: komal.pathade@tcs.com (Komal Pathade), uday@cse.iitb.ac.in (Uday Khedker)

Preprint submitted to Elsevier

August 29, 2022

 
 
 
 
 
 
1. Introduction

The eﬀectiveness of techniques that optimize, verify, and debug computer programs depends
on the availability of accurate information describing the program behavior during various exe-
cutions. To this end, data ﬂow analysis gathers code level information that could answer either
a subset of queries over a program (demand-driven analyses) or all possible queries of a par-
ticular type over a program (exhaustive analyses) without executing the program.
It is well
known that computing highly precise exhaustive data ﬂow analysis solutions (like meet over
paths (MOP) [1]) is undecidable; even in the instances where it is computable, it does not scale
well to practical programs. On the other hand, scalable and widely used solutions (like maximum
ﬁxed-point (MFP) [1]) are not as precise.

1.1. The Context of This Work

In this work, we focus on exhaustive data ﬂow analyses because they compute information
that can be used to answer all queries of a particular type over all program executions. In partic-
ular, we compute MFP solutions (details in Section 4) and try to make them more precise.

A MFP solution includes the data ﬂow values that reach a program point along all control
ﬂow paths (CFPs) [1] which are paths in the control ﬂow graph (CFG) [1] representation of the
program. Experimental evidence [2] on Linux kernel code suggests that 9-40% of conditional
statements in a program lead to at least one infeasible CFP i.e., these CFPs do not occur in any
execution of the program. Additionally, we found in our benchmarks on average 60% (Geomet-
ric mean 29%) functions had at least one infeasible CFP in their CFG. Inclusion of data ﬂow
values reaching along such infeasible CFPs makes the computed data ﬂow information an over-
approximation of the actual data ﬂow information. This dilutes the usefulness of the information
for client analyses.

Various approaches reported in the literature detect infeasible CFPs [2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12]. Most of these approaches cater to the needs of program testing, in which the knowledge
of infeasible CFPs is used to reﬁne various test coverage criteria (like branch, path coverage)
leading to less testing overhead. However, not much attention has been given towards improv-
ing the precision of data ﬂow analysis by avoiding the data ﬂow values reaching along known
infeasible CFPs. A potential reason being that CFP based data ﬂow approaches like MOP com-
putation (that considers CFPs independently, and hence can inherently exclude infeasible CFPs)
are not scalable, because the number of CFPs as well as the number of data ﬂow values may be
very large or even unbounded. Hence, scalable approaches like MFP computation do not main-
tain a mapping between individual CFPs and the corresponding data ﬂow values, thus making it
non-trivial to identify (and discard) the data ﬂow values reaching along infeasible CFPs.

We name the MFP solutions computed by restricting the data ﬂow values at each program
point to those values that reach along feasible CFPs as feasible path MFP (FPMFP) solutions.
Existing approaches that attempt to compute such solutions are either unsuitable because they
involve CFG restructuring which can exponentially blow up the size of the CFG or are analysis
speciﬁc with no straightforward generalization.

1.2. Our Contributions

We observe that infeasible CFPs are a property of programs and not of any particular data
ﬂow analysis over programs. We use this observation to separate the identiﬁcation of infeasible
CFPs in the CFG of a program, from computation of FPMFP solutions that exclude data ﬂow
values reaching along known infeasible CFPs. These two phases are described below.

2

1. In the ﬁrst phase, we use the work done by Bodik et.al [2] to detect infeasible CFPs in the
CFG of a program. In their work, they identify minimal infeasible path segments (MIPS)
which are minimal length sub-segments of infeasible CFPs such that the following holds:
if a CFP σ contains a MIPS as a sub-segment then σ is infeasible. MIPS1 captures the
infeasibility property of CFPs in a concise form (illustrated in Section 3).

Given a set of MIPS as input, we do the following processing over them.

(i) We propose a novel criteria (called contains-preﬁx-of ) to cluster MIPS. This clus-
tering is necessary because treating each MIPS in isolation may lead to an imprecise
solution, if the MIPS are intersecting with each other (illustrated in Section 3.3).

(ii) We establish an equivalence relation over the clusters of MIPS, so that the clus-
ters that belong to the same equivalence class can be treated as a single unit dur-
ing FPMFP computation (illustrated in Section 6). This increases the scalability of
FPMFP computation without reducing the precision of the computed solution.

2. In the second phase, we automatically lift the existing MFP speciﬁcations of an analysis to
its FPMFP speciﬁcations using the processed MIPS from the ﬁrst phase. These speciﬁca-
tions are then used to compute the FPMFP solution. The computation of FPMFP solution
satisﬁes the following properties that distinguish FPMFP from existing approaches:

(i) Computation restricts the data ﬂow values at each program point to those values that
reach along feasible CFPs (data ﬂow values reaching along known infeasible CFPs
are identiﬁed and discarded).

(ii) Computation does not involve CFG restructuring and is generically applicable for all

MFP based data ﬂow analyses.

Items (i) and (ii) in each of the above phases describe the distinguishing features of FPMFP over
existing approaches. Moreover, separating the above two phases is an useful insight that avoids
the costly repetition involved in identifying infeasible CFPs for each diﬀerent data ﬂow analysis
over the same underlying program, which happens in analysis speciﬁc approaches [13, 14, 15,
16, 17, 18]. Instead, we perform the ﬁrst phase that involves identiﬁcation of infeasible CFPs
once for each program, and the second phase that involves computation of FPMFP is performed
once for each diﬀerent data ﬂow analysis.

The core ideas of FPMFP have been presented before [19, 20]. This paper enhances the core
ideas signiﬁcantly and provides a complete treatment. In particular, the following contributions
are exclusive to this paper.

1. We unify our earlier approaches [19, 20] by proposing a novel formalization for handling
infeasible paths in the MFP computations. This formalization is based on the contains-
preﬁx-of relation (explained in Section 3.3) that precisely distills the useful interactions
between MIPS from all possible interactions. The formalization is more intuitive to un-
derstand because of its declarative nature as opposed to the procedural formalization ear-
lier, and its correctness is easier to prove and verify. Moreover, the new formalization of
FPMFP is close to the standard MFP formalization. We believe this will ease the adoption
of the FPMFP technique in data ﬂow analysis.

1We use the acronym MIPS as an irregular noun, whose plural form is same as its singular form.

3

Traverses CFPs

Merges information

Solution

Infeasible Feasible Spurious

Across
CFPs

Across
program
points

Decidable Precision

MOFP
MOP
MFP
FI

No
Yes
Yes
Yes

Yes
Yes
Yes
Yes

No
No
No
Yes

No
No
Yes
Yes

No
No
No
Yes

No
No
Yes
Yes

Most

Least

Table 1: Solutions of a data ﬂow analysis. As we go down the rows, more entries become “Yes” leading to increased
eﬃciency and decreased precision.

2. We formalize the concept of FPMFP for inter-procedural setting. In particular, we extend
it to the functional approach [21] of inter-procedural data ﬂow analysis. We evaluate
our inter-procedural technique of FPMFP computation on an industry strength static pro-
gram analysis tool called TCS ECA [22]. Inter-procedural static analyses are known to be
desirable to software developer community [23].

3. We improve the practical applicability of the FPMFP by adding novel optimizations that
improve the scalability of the FPMFP computation by the factor of 2 without aﬀecting
soundness or precision of the computed solution. The approach has now scaled on the
codesets of size 150 KLOC.

4. We prove that the FPMFP computes an over-approximation of the most precise solution
of a data ﬂow problem. The most precise solution is called the meet over feasible paths
(MOFP) solution and is explained in Section 2.

1.3. Organization of the Paper

Section 2 describes the limitations of existing approaches of data ﬂow analysis. Section
3 describes the concept of Minimal Infeasible Path Segments that facilitate FPMFP solutions,
and illustrates the FPMFP solution using an example. Section 4 explains the computation of
FPMFP. Section 5 explains FPMFP computation in inter-procedural setting. Section 6 presents
the optimizations that improve the scalability of FPMFP computation and explains the worst-
case complexity of the FPMFP computation. Section 7 presents experimental evaluation and
Section 8 describes related work. Section 9 concludes the paper. The appendix (Section 10)
gives the proof of soundness of FPMFP solution.

2. Existing Approaches and Their Limitations

Table 1 lists the conventional solutions of a data ﬂow analysis and mentions their computabil-
ity and (relative) precision by describing the nature of paths traversed in computing the solutions.
These paths are illustrated in Figure 1. In particular, the paths that are traversed by a data ﬂow
analysis consist of CFG paths or spurious paths (described below) or both. CFG paths (CFPs)
that do not represent any possible execution of the program are infeasible; others are feasible.
Apart from feasible and infeasible CFPs, a data ﬂow analysis could also traverse spurious CFPs
which are paths that result from an over-approximation of CFPs—they do not appear in the CFG
4

All Paths

CFG
Paths

Spurious
Paths

Infeasible
Paths

Feasible
Paths

Figure 1: Paths Traversed During Data Flow Analyses

but are eﬀectively traversed by a speciﬁc method of data ﬂow analysis as shown in Table 1 and
as explained below.

• Meet Over Feasible Paths (MOFP) solution captures the information reaching a program
point along feasible CFPs only and does not merge information across CFPs. Since a
program could have inﬁnitely many CFPs, computing this solution is undecidable. The
information deﬁned by MOFP precisely represents the possible runtime information at
each program point because it does not include information reaching along infeasible and
spurious CFPs.

• Meet Over Paths (MOP) [1] solution captures the information reaching a program point
along feasible and infeasible CFPs. Since the information reaching along infeasible CFPs
is also considered, MOP is less precise compared to MOFP. Computing MOP is also
undecidable.

• Maximum Fixed Point (MFP) [1] solution diﬀers from MOP in that the information is
eﬀectively merged in the shared segments of CFPs because the solution is inductively
computed. Since only one piece of information is stored at a program point regardless of
the number of paths passing through it, computing MFP is decidable. MFP is less precise
than MOP because information across paths is merged and this over-approximation cannot
distinguish between feasible and infeasible paths. Spurious CFPs are not traversed in MFP
computation.

• Flow Insensitive (FI) [1] solution merges information across all program points by ignoring
the control ﬂow. Eﬀectively, it over-approximates the set of CFPs and hence includes
information along feasible, infeasible, and spurious CFPs.

We propose an approach to compute FPMFP solutions in which the computation at each
program point is restricted to those data ﬂow values that reach along feasible CFPs (data ﬂow
values reaching along known infeasible CFPs are excluded and spurious CFPs are not traversed).
Our work can be seen in the mould of trace partitioning [24] which tries to maintain some
disjunction over data ﬂow values based on path conditions that represent control ﬂow of val-
ues instead of merging the values indiscriminately across all paths to compute an MFP solution.

5

However, in trace partitioning, the desirable disjunctions (over data ﬂow values) are not generic,
instead, they need to be speciﬁed for each data ﬂow analysis separately which limits the useful-
ness of trace partitioning.

Towards this end, we use the infeasibility of control ﬂow paths—a property of programs and
not of any particular data ﬂow analysis over the program—as the criteria for trace partitioning.
This allows us to achieve a generic and practical trace partitioning that can be automatically
incorporated in any data ﬂow analysis to obtain a more precise solution.

The main challenge in achieving this automatic approach is that it is diﬃcult to eliminate the
eﬀect of an infeasible path when data ﬂow values are merged which happens in MFP computa-
tion. We meet this challenge by identifying MIPS (computed using existing approaches [2]) and
creating equivalence classes of CFPs; such that all CFPs in one equivalence class overlap with
the same set of MIPS. These classes allow us to lift any data ﬂow analysis to a data ﬂow analysis
that computes one data ﬂow value for each equivalence class. The resulting solution ignores data
ﬂow values corresponding to equivalence classes containing infeasible CFPs and hence is more
precise than MFP (and sometimes more precise than MOP and as precise as MOFP like in Figure
2).

Example 1. Figure 2 shows an example of diﬀerent solutions for an analysis that deter-
mines the values of variables. For MOP and MOFP, each data ﬂow value has a constraint
that represents the CFPs along which the value reaches the program point. Since MFP,
FPMFP, and FI solutions merge the values, they compute a range of values in terms of
lower and upper bounds. FPMFP solution is more precise than MOP and MFP because
it excludes the data ﬂow value a 7→ [0, 0] reaching along infeasible path at node n6 (the
infeasible path is shown by double lines).

3. Feasible Path MFP Solutions

In this section, we deﬁne minimal infeasible path segments and show how they allow us to

deﬁne the FPMFP solution. Section 4 describes how FPMFP solution is computed.

3.1. Background
Control Flow Paths

A control ﬂow path is a path in the control ﬂow graph representation of a procedure. The start
node of a CFP is always the start node of the CFG, however, the end node of a CFP can be any
node in the CFG. We use the term “CFPs that reach node n” to refer to all CFPs that have n as the
end node. All CFPs referred henceforth are intra-procedural, unless explicitly stated otherwise.

Infeasible Control Flow Paths

We use the following concepts related to infeasible paths [2].
e1−→ n2
We denote a CFP by ρ : n1

ep−→ np+1, p ≥ 2, where ni denotes the
node at the ith position in the path, and ei denotes its out edge. CFP ρ is an infeasible control ﬂow
path if there is some conditional node nk, k ≤ p such that the subpath from n1 to nk of ρ is a preﬁx

e3−→ . . . → np

e2−→ n3

6

n1

a = 0

{a 7→ 0 (true)}

e1

if (x ≥ 0)

n2
true

e2

false
e3

{a 7→ 0 (x ≥ 0)}

n3

a = a + 5

{a 7→ 0 (x < 0)}

n1

a = 0

{a 7→ [0, 0]}

e1

n2

if (x ≥ 0)

true

{a 7→ [0, 0]}
n3

a = a + 5

e2

false
e3

{a 7→ [0, 0]}

{a 7→ 5 (x ≥ 0)}

e4

{a 7→ [5, 5]}

e4

n4

print x

{a 7→ 5 (x ≥ 0),
a 7→ 0 (x < 0)}

e5

n4

print x

{a 7→ [0, 5]}

e5

n5

if (x == 5)

n5

if (x == 5)

true

e6

false
e7

{a 7→ 5 (x = 5 ∧ x ≥ 0),
a 7→ 0 (x = 5 ∧ x < 0)}
n6

assert (a ! = 0)

{a 7→ 5 (x = 5 ∧ x ≥ 0),
a 7→ 0 (x = 5 ∧ x < 0)}

e8

{a 7→ 5 (x , 5∧
x ≥ 0),
a 7→ 0 (x , 5∧
x < 0)}

true

{a 7→ [0, 5]}

e6

n6

assert (a ! = 0)

{a 7→ [0, 5]}

e8

false

e7

{a 7→ [0, 5]}

n7

print x

n7

print x

(a) The MOP solution. The MOFP sol-
ution discards the struck oﬀ values.

(b) The MFP solution. In FPMFP
solution, edges e6 and e8 have
the interval [5, 5].

Figure 2: Diﬀerent solutions of value analysis for an example program. The nodes in the CFG are numbered ni, and
the edges are numbered ei. A value a 7→ k (p) at edge e indicates that the variable a has value k at edge e along CFP
represented by condition p. The path reaching n6 shown by double lines is infeasible. For simplicity we have shown the
values for a alone. The FI solution merges values across all program points resulting in a single interval [0, 5].

ei−→ . . . → nk

of some execution path but the subpath from n1 to nk+1 is not a preﬁx of any execution path.2
ek−→ nk+1, ei , ek of CFP ρ above is a minimal infeasible path
A path segment µ : ni
segment (MIPS) if µ is not a subpath of any execution path but every subpath of µ is a subpath
of some execution path. Infeasibility occurs when inconsistent conditions are expected to hold
at two diﬀerent edges across a path segment. Hence every infeasible path must have at least two
edges.3

For MIPS µ of the previous paragraph, we call all nodes n j, i < j < k + 1 as the intermediate
nodes of µ. Additionally, we call the edges ei, ek as the start and the end edge of µ respectively,
while all edges e j, i < j < k are called as the inner edges of MIPS µ. As a rule, the end edge of

2Note that the subscripts used in the nodes and edges in a path segment signify positions of the nodes and edges in
the path segment and should not be taken as labels. By abuse of notation, we also use n1, e2 etc. as labels of nodes and
edge in a control ﬂow graph and then juxtapose them when we write path segments.

3We assume that the infeasible paths arising from the conditional statements of the form if (cond) where cond is

known to be either deﬁnitely zero or deﬁnitely non-zero, have been eliminated by the compiler in the CFG.

7

Let a be an integer variable, then the states representing pos-
sible value range for variable a at each edge over all execu-
tions are:

• states(e0, {a}) = {{a 7→ i} | −∞ ≤ i ≤ ∞}

• states(e1, {a}) = {{a 7→ 0}}

• states(e2, {a}) = {{a 7→ i} | −∞ ≤ i ≤ ∞}

• states(e3, {a}) = {{a 7→ i} | −∞ ≤ i ≤ ∞}

• states(e4, {a}) = {{a 7→ i} | 5 < i ≤ ∞}

e3−→ n4

• states(e5, {a}) = {{a 7→ i} | −∞ ≤ i ≤ 5}
e1−→ n3

e4−→ n5 is a MIPS be-
Path segment µ1 : n1
cause e4 cannot be reached from e1 in any execution al-
though it can be reached from e3 in some execution i.e.,
states(e1, {a}) ∩ states(e4, {a}) = Φ,
states(e3, {a}) ∩ states(e4, {a}) = {{a 7→ i} | 5 < i ≤ ∞}
The start,
start(µ1) = {e1}, inner(µ1) = {e3}, end(µ1) = {e4}

inner, and end edges of µ1 are given by,

z < 1

n0
e0
true

n1

a = 0

e1

e2
false

n3

use a

e3

n4

a > 5

true

e4

n5

use a

e5

false

use a

Figure 3: Illustrating minimal infeasible path segment (MIPS).

a MIPS is always a conditional edge, and inner edges exist only if a MIPS has at least 3 edges.
For the FPMFP computation, we only admit MIPS that do not contain cycles. All MIPS referred
henceforth are MIPS without cycles.

Example 1.
e0−→ n1
e1−→ n3
n0
a MIPS, µ1 : n1
infeasible.

Figure 3 illustrates infeasible paths and MIPS. Observe that the CFP ρ :
e4−→ n5 is infeasible but not minimal . However, its suﬃx µ1 is
e4−→ n5, because µ1 is infeasible but no sub-segment of µ1 is

e3−→ n4
e1−→ n3

e3−→ n4

3.2. Our Key Idea

We deﬁne the following notations that allow us to describe the key ideas. For a given MIPS
µ, let start(µ), inner(µ), and end(µ) denote the set of start, inner, and end edges of µ. Sets start(µ)
and end(µ) are singleton because each MIPS has exactly one start and one end edge. MIPS
exhibit the following interesting property:

Observation 3.1. CFPs that contain a MIPS µ as a sub-segment are infeasible. Consequently,
the data ﬂow values computed along CFPs that contain µ are unreachable at the end edge of µ,
so these values should be blocked at the end edge. Thus, if we deﬁne a data ﬂow analysis that
separates the data ﬂow values that are to be blocked, we can eliminate them thereby avoiding the
eﬀect of infeasible paths.

8

Data Flow Values

s
e
g
d
E

ﬂowing through µ1
⊤
⊤
z 7→ [−∞, 0]
z 7→ [−∞, 0]
⊤ z 7→ [−∞, 0]
z 7→ [−∞, 0]

not ﬂowing through µ1
z 7→ [−∞, 0]
z 7→ [1, ∞]
⊤
z 7→ [1, ∞]
z 7→ [1, ∞]
z 7→ [1, ∞]

e0
e2
e1
e3
e4
e5

Meet
⊓
z 7→ [−∞, 0]
z 7→ [1, ∞]
z 7→ [−∞, 0]
z 7→ [−∞, ∞]
z 7→ [1, ∞]
z 7→ [−∞, ∞]

Table 2: Separating the Values Flowing through MIPS µ1 for example in Figure 3: ⊤ represents top value of the lattice,
the last column contains the result of meet of all data ﬂow values present in a row at each edge, for simplicity values of
only z are shown.

Example 1.
contains MIPS µ1 : n1
(e.g., a 7→ [0, 0], z 7→ [−∞, 0]) is blocked at e4 (which is end edge of MIPS µ1).

e4−→ n5 is infeasible because it
e4−→ n5. Hence, the data ﬂow value that reaches along σ

In Figure 3, a CFP σ : n0
e1−→ n3

e1−→ n3

e3−→ n4

e3−→ n4

e0−→ n1

Observation 3.1 leads us to the following key idea to handle infeasible paths: at each program
point, we separate the data ﬂow values reaching along CFPs that contain a MIPS, from the data
ﬂow values reaching along CFPs that do not contain any MIPS. This allows us to discard these
values at the end of the MIPS (because these values are unreachable as per Observation 3.1).

For a MIPS µ, following is a suﬃcient condition to block the data ﬂow values that reach

along CFPs that contain µ.

C: At the end edge of µ, block the data ﬂow values that ﬂow through µ (i.e., values
that ﬂow along µ —from start edge of µ till the end edge of µ).

Example 2. For example in Figure 3, the values (of variable z) that ﬂow through MIPS
µ1 are shown in Table 2. The value z 7→ [−∞, 0] reaches the start edge (e1) of µ1, and
ﬂows through µ1. This value is separated from the values that do not ﬂow through µ1 e.g.,
z 7→ [1, ∞]. This separation allows us to identify and block the value z 7→ [−∞, 0] at the
end edge (e4) of µ1.

The ﬁnal value at each edge, except the end edge, is computed by taking a meet of
values that ﬂow through µ1, with values that do not ﬂow through µ1. However, the ﬁnal
value at end edge contains only the values that do not ﬂow through µ1. Thus, we get a
precise value range for z at edge e4 (i.e., z 7→ [1, ∞]) because value z 7→ [−∞, 0] is blocked
(a MFP solution that includes data ﬂow values along infeasible CFPs gives value range
z 7→ [−∞, ∞] at edge e4).

Note that the data ﬂow values that reach the start edge of a MIPS µ may change or get killed
at intermediate nodes or edges when they ﬂow through µ, depending on the type of data ﬂow
analysis. In this case, we block the updated data ﬂow value accordingly, as illustrated in example
3 below.

9

e3−→ n4 with e1, e2, e3 as the start, the
Example 3. Consider a MIPS µ: n1
inner, and the end edge respectively. Let x be an integer variable such that n1 : x = 0,
n2 : x = x + 1 be two assignment nodes, and nodes n3, n4 do not modify the value of the
variable x.

e1−→ n2

e2−→ n3

The data ﬂow value x 7→ [0, 0] at the start edge (e1) of µ will be changed to x 7→ [1, 1]

as it ﬂows through µ. Hence x 7→ [1, 1] is blocked at e3.

3.3. An Overview of FPMFP computation

We now brieﬂy explain the steps of FPMFP computation that ensure that condition C (from
the previous section) is satisﬁed for all MIPS in the program. The formal details of FPMFP
computation are presented in sections 3.4 and 4.

We ﬁrst explain the FPMFP computation in presence of single MIPS in the program. Later,
we introduce the necessary changes to handle multiple MIPS in the program. We use the example
in Figure 4a as a running example for explaining FPMFP computation. Two MIPS in Figure 4a
are µ1 : e3 → e4 → e5 and µ2 : e3 → e4 → e8 (They are marked with double arrows). For
simplicity of exposition, we restrict the discussion to computation of value range of variable l
only.

In FPMFP computation for the example in Figure 4a, we separate the value l 7→ [0, 0] that
ﬂows through µ1 from the value l 7→ [2, 2] that does not ﬂow through µ1 as shown in Figure 4b.
This allows us to block l 7→ [0, 0] at the end edge (e5) of µ1. Thus, the FPMFP solution —com-
puted by meet of data ﬂow values in each row at each edge —contains l 7→ [2, 2] (a precise value)
at edge e5.

The FPMFP computation explained in previous paragraph becomes imprecise if we addition-
ally separate the data ﬂow values that ﬂow through MIPS µ2, as explained below. For MIPS µ2:
e3 → e4 → e8, we separate the values that ﬂow through µ2 (i.e., l 7→ [0, 0]) as shown in Fig-
ure 4c. This allows us to block l 7→ [0, 0] at end edge (e8) of µ2. However, the FPMFP solution
(computed in Figure 4c) is imprecise because it includes the value l 7→ [0, 0] at edge e5 and e8.
In particular, at edge e5, l 7→ [0, 0] is blocked within µ1 but it is retained in µ2 because e5 is not
end edge of µ2. Similarly, at edge e8, l 7→ [0, 0] is blocked within µ2 but is retained in µ1.

We explicate the reasons for this imprecision below: we separate the data ﬂow values that
reach along CFPs that contain a MIPS, however, a MIPS can overlap with other MIPS in a way
that both MIPS follow the same CFP resulting in the same data ﬂow values ﬂowing through
them. In such a case, at the end edge of a MIPS, the data ﬂow along that MIPS will be blocked
but the ﬂow along the other overlapping MIPS will be allowed unless the edge is end edge of
both the MIPS. This leads to imprecision. Hence we need to handle the overlapping MIPS case
explicitly. For this purpose, we deﬁne a contains-preﬁx-of relation between MIPS below.

Deﬁnition 1. (Contains-preﬁx-of (CPO)) For a MIPS µ and an edge e in µ, let preﬁx(µ, e) be the
subsegment of µ from start(µ) to e. Then, we say that MIPS µ1 contains-preﬁx-of MIPS µ2 at e,
iﬀ µ1 contains preﬁx(µ2, e).

For example in Figure 4, the MIPS µ1 contains-preﬁx-of µ2

4 at edges e3 and e4. For a MIPS
µ1 and an edge e, all MIPS µ2 that satisfy µ1 CPO µ2 are obtained as follows: let U be the set of

4In this case µ2 also contains-preﬁx-of µ1 at e3 and e4, however in general contains-preﬁx-of may not be a symmetric

relation.

10

l=2
input c
if(p1 > 0)

false

e2

e1

true

l = 0
c = 0

e3

print l

e4

switch(c)

case 1

e5

assert
(l! = 0)

e7

t
l
u
a
f
e
d

case 2

e8

assert
(l! = 0)

e6

e9

exit

(a)

Paths and MIPS:
• MIPS µ1 : e3 → e4 → e5
• MIPS µ2 : e3 → e4 → e8
• start(µ1) = start(µ2) = e3
• inner(µ1) = inner(µ2) = e4
• end(µ1) = e5, end(µ2) = e8

s
e
g
d
E

e3
e4
e5
e8

s
e
g
d
E
e3
e4
e5
e8

Data Flow Values

not ﬂowing
through µ1

FPMFP
⊓

⊤ l 7→ [0, 0]
l 7→ [0, 2]
l 7→ [2, 2]
l 7→ [0, 2]

l 7→ [2, 2]
l 7→ [2, 2]
l 7→ [2, 2]

ﬂowing
through µ1
l 7→ [0, 0]
l 7→ [0, 0]
⊤
l 7→ [0, 0]

(b)

Data Flow Values

ﬂowing through
MIPS

µ1
l 7→ [0, 0]
l 7→ [0, 0]

l 7→ [0, 0]

µ2
l 7→ [0, 0]
l 7→ [0, 0]
⊤ l 7→ [0, 0]
⊤
(c)

FPMFP
⊓

not ﬂowing
through
MIPS

⊤ l 7→ [0, 0]
l 7→ [0, 2]
l 7→ [0, 2]
l 7→ [0, 2]

l 7→ [2, 2]
l 7→ [2, 2]
l 7→ [2, 2]

Figure 4: Computing the FPMFP solution for an example having overlapping MIPS.

all MIPS in the CFG of the program.

cpoe(µ1) = {µ2 | µ2 ∈ U, µ1 contains preﬁx(µ2, e)}

(1)

We observe the following property of cpoe(µ1).

Observation 3.2. Because of the preﬁx relation, all MIPS in cpoe(µ1) essentially follow the
same control ﬂow path till edge e although their start edges may appear at diﬀerent positions in
the path. Next, the values along this path ﬂow through each MIPS in cpoe(µ1). Hence, these
values should be blocked at the end edge of every MIPS in cpoe(µ1).

For an edge sequence e → e′, cpoe(µ) may be diﬀerent from cpoe′ (µ) because all MIPS that
reach e may not reach e′, and some new MIPS may start at e′. Hence, we deﬁne ext function
below that computes cpoe′ (µ) from cpoe(µ).

Let edges(µ) be the set of all edges in µ, and S = cpoe(µ) then

ext(S, e′) = {µ | µ ∈ S, e′ ∈ edges(µ)} ∪ {µ | µ ∈ U, e′ ∈ start(µ)}

(2)

At an edge e of MIPS µ, we associate the data ﬂow values that ﬂow through µ with cpoe(µ)
(instead of µ). These associations are abstractly illustrated in Figure 5a and instantiated to an
example in Figure 5b. We explain each of these below.

In Figure 5a, the data ﬂow values d, d′, d′′ reach edges e, e′, e′′ respectively, along the fol-
e′′
−−→ n3. The data ﬂow value d′ = fn1(d) and d′′ = fn2(d′) where

lowing CFP: σ : n0

e′
−→ n2

e
−→ n1

11

Edges
e1
e2
e3
e4
e5
e7
e8

Associations (hM, di)
h{}, l 7→ [2, 2]i
h{}, l 7→ [2, 2]i
h{µ1, µ2}, l 7→ [0, 0]i
h{µ1, µ2}, l 7→ [0, 0]i, h{}, l 7→ [2, 2]i
h{µ1}, l 7→ [0, 0] i, h{}, l 7→ [2, 2]i
h{}, l 7→ [0, 2]i
h{µ2}, l 7→ [0, 0] i, h{}, l 7→ [2, 2]i

FPMFP
l 7→ [2, 2]
l 7→ [2, 2]
l 7→ [0, 0]
l 7→ [0, 2]
l 7→ [2, 2]
l 7→ [0, 2]
l 7→ [2, 2]

MFP
l 7→ [2, 2]
l 7→ [2, 2]
l 7→ [0, 0]
l 7→ [0, 2]
l 7→ [0, 2]
l 7→ [0, 2]
l 7→ [0, 2]

Table 3: The FPMFP computation for example in Figure 4. A pair hM, di indicates that the data ﬂow value d ﬂows
through all MIPS in set of MIPS M. The ﬁnal FPMFP solution is computed by taking meet of values over all pairs at
each edge.

fni(x) computes the eﬀect of node ni on input data ﬂow value x. The corresponding associations
with sets of MIPS M, M′, M′′ are computed as follows:

M = ext({}, e)
M′ = ext(M, e′)
M′′ = ext(M′, e′′)

The idea is that a pair hM, di at edge e transforms into another pair hM′, d′i at a successor edge
e′ because

• the CPO relation between MIPS at e′ may be diﬀerent from that at e, and

• d′ is computed from d as d′ = fn1(d).

In Figure 5b, the data ﬂow values l 7→ [2, 2] at edge e1 is associated with {} because no MIPS
contains e. However, at edges e3, e4, the data ﬂow value l 7→ [0, 0] is associated with {µ1, µ2}
because µ1 CPO µ2 at these edges i.e., ext({µ1}, e3) = {µ1, µ2}, ext({µ1, µ2}, e4) = {µ1, µ2}. At
e5, l 7→ [0, 0] is associated with {µ1} because ext({µ1, µ2}, e5) = {µ1}. Since e5 is end edge of µ1,
l 7→ [0, 0] is blocked at e5. Similarly, l 7→ [0, 0] is blocked at e8. Rest of the associations at each
edge are presented in Table 3.

We now introduce the notations used in the FPMFP computation. We compute a set of pairs
of the form hM, di at each edge e where M is a set of MIPS, and d is the data ﬂow value that
ﬂows through all MIPS in M. For completeness, we have a pair hM′, di corresponding to each
possible subset M′ of U at each edge e, where d = ⊤ if the MIPS in M′ are not related with
each other by CPO relation i.e., there is no MIPS µ in M′ such that cpoe(µ) = M′.

At an edge e, presence of a pair hM, di, d , ⊤ indicates the data ﬂow value d ﬂows through
each MIPS contained in M, and for some µ ∈ M, M = cpoe(µ). Similarly, a pair h{}, d′i indicates
that the data ﬂow value d′ does not ﬂow through any MIPS at edge e.

Example 1. Figure 6 illustrates the FPMFP computation for the example in Figure 2. Since
µ is the only MIPS in the example, each data ﬂow value d is mapped with either {µ} or {}.
The data ﬂow value a 7→ [0, 0] reaches the start edge (e3) of µ, hence, a pair h{µ}, a 7→ [0, 0]i
is created at e3. Similarly, at edge e4, data ﬂow value a 7→ [5, 5] is mapped with {} i.e., a
pair h{}, a 7→ [5, 5]i is created.

Edge e6 is end edge of µ, hence, the data ﬂow value a 7→ [0, 0] that is mapped with µ

12

l=2
input c
if(p1 > 0)

e1

true

false

e2

h{}, l 7→ [2, 2]i

l = 0
c = 0

e3

h{µ1, µ2}, l 7→ [0, 0]i

print l

h{µ1, µ2}, l 7→ [0, 0]i

e4

switch(c)

h{µ1}, l 7→ [0, 0] i

h{µ2}, l 7→ [0, 0] i

case 1

assert
(l! = 0)

case 2

assert
(l! = 0)

e5

e8

t
l
u
a
f
e
d

e7

e6

exit

e9

n0

e

hM, di

n1

e′

hM′, d′i

n2

e′′

hM′′, d′′i

n3

(a) Generic view of
data ﬂow along a CFP.

(b) Illustrating the ﬂow of values for the example
in Figure 4. For brevity, only values of variable l
are shown along CFPs that start at edge e1.

Figure 5: Computing the FPMFP solution

in pair h{µ}, a 7→ [0, 0]i is discarded i.e., replaced with ⊤ (the resulting pair h{µ}, ⊤i at e6 is
not shown in ﬁgure for brevity).

For a program containing k MIPS, theoretically we need 2k pairs5 at each program point (one

5In Section 6.4, we prove that at any program point at most k pairs can contain the data ﬂow values other than ⊤,

13

pair corresponding to each possible subset of set of all MIPS present in the program). The pairs
computed in a FPMFP solution satisfy the following property:

At each program point, the meet of data ﬂow values over all pairs gives at least as
precise information as in MFP solution, and may give more precise information if
some pairs contain information reaching from infeasible CFPs because such infor-
mation is discarded. The precision is achieved only when the discarded information
has weaker value or incomparable value compared to rest of the information reach-
ing a node. Let Dn be the data ﬂow value in MFP solution at node n, and Sn be the
set of pairs computed in FPMFP analysis at node n then

Dn ⊑ l

d

hM, di∈Sn

Example 2. In Figure 6, at the edge e5 the meet of data ﬂow values over all pairs i.e.,

h{µ}, a 7→ [0, 0]i and h{}, a 7→ [5, 5]i is a 7→ [0, 5] which is same as given by MFP so-
lution in Figure 2; however, at the edge e6 the meet of data ﬂow values over all pairs i.e.,
h{µ}, ⊤i and h{}, a 7→ [5, 5]i is a 7→ [5, 5] which is more precise compared to a 7→ [0, 5]
given by MFP solution in Figure 2.

3.4. Deﬁning FPMFP solution

We now explain how these ideas are incorporated in a data ﬂow analysis. We compute the

FPMFP solution in the following two steps.

1. Step 1: we lift a data ﬂow analysis to an analysis that computes separate data ﬂow values
for diﬀerent MIPS (Equation 8 and 9 deﬁne the lifted analysis). The lifted analysis blocks
the data ﬂow values associated with each MIPS µ at the end edge of µ.

2. Step 2: we merge the data ﬂow values that are computed by the lifted analysis (over all
pairs at each program point) to obtain the FPMFP solution (Equation 3 and 4 deﬁne the
merging of data ﬂow values).

We describe each of these steps in detail now. Let L denote the lattice of data ﬂow values of
the underlying data ﬂow analysis. Then the MFP solution of the data ﬂow analysis for a program
is a set of values in L, represented by data ﬂow variables Inn/Outn (Equation 6 and 7) for every
node n of the CFG of the program, when the equations are solved using ⊤ as the initial value of
Inn/Outn. Assume we are given a set U that contains all MIPS in the CFG of the program, then
each M ⊆ U could be associated with any data ﬂow value d in L, if d ﬂows through each MIPS
contained in M. These associations are represented by the elements of the lattice L : P(U) → L,
where P(U) is the powerset of U.

We lift the underlying analysis that computes values Inn/Outn ∈ L to an analysis that com-
putes Inn/Outn ∈ L. Thus Inn, Outn are sets of pairs hM, di such that M ⊆ U, d ∈ L. Each

where k is the total number of input MIPS. Further, our empirical evaluation shows that the number of such pairs to be
much smaller than k. Moreover, ignoring the pairs that contain ⊤ value does not aﬀect the FPMFP solution (details are
given in Section 6.3).

14

of these sets represent a function that maps each value in P(U) to a value in L i.e., Inn/Outn
cannot contain two pairs hM, di and hM′, d′i where M = M′ but d , d′. This collection of pairs
gives us the distinctions required to achieve precision by separating the data ﬂow values along
infeasible paths from those along feasible paths.

For a data ﬂow value Inn, the meaning of association of a data ﬂow value d with a set of MIPS

M is as follows:

• Pair hM, di ∈ Inn, indicates that the data ﬂow value d ﬂows through all MIPS in M. If no

such value exists at n, then d = ⊤.

• Pair h{}, di ∈ Inn, indicates that the data ﬂow value d does not ﬂow through any MIPS at
node n. If no such value exists (i.e., every data ﬂow value ﬂows through some or the other
MIPS) then d = ⊤.

In Figure 6, the data ﬂow value a 7→ [0, 0] ﬂows through MIPS µ at edges
Example 1.
e3, e5, and e6. On the other hand, the data ﬂow value a 7→ [5, 5] does not ﬂow through any
MIPS. (Recall that ﬂow through a MIPS µ means ﬂow along µ —from start edge of µ till
end edge of µ).

Section 4 deﬁnes the data ﬂow equations to compute Inn/Outn. The FPMFP solution is a set
of values in L, represented by the data ﬂow variables Inn/Outn (Equation 3 and 4) for every node
n in the CFG of the program. They are computed from Inn/Outn using the following operations.

Inn = fold⊓(Inn)

Outn = fold⊓(Outn)

where, fold⊓(S) = l

d

hM, di∈S

(3)

(4)

(5)

The Inn/Outn values represent the FPMFP solution which represents the data ﬂow information
reaching node n along all CFPs excluding the ones that are known to be infeasible CFPs and are
given as input.

4. Computing the FPMFP Solution

We now illustrate how the data ﬂow equations for computing the FPMFP solution are derived
from that of the MFP speciﬁcations of a data ﬂow analysis. Section 4.1 explains this lifting by
deﬁning the data ﬂow equations, node ﬂow functions, and the meet operator. A key enabler for
this lifting is a set of specially crafted edge ﬂow functions6 (Section 4.2) that discard data ﬂow
values that reach a program point from infeasible CFPs.

6The edge ﬂow function for an edge m → n uses Outm to compute Inn in a forward analysis, and vice-versa in a

backward analysis.

15

e5−→ n5

e6
−→ n6

Paths and MIPS:

e3−→ n4

• MIPS µ : n2
• start(µ) = {e3}
• inner(µ) = {e5}
• end(µ) = {e6}

Lattices and data ﬂow values

• L =

{a 7→ [i, j]} |
−∞ ≤ i ≤ j ≤ +∞
(cid:8)

(cid:9)

• ⊤ = {a 7→ [+∞, −∞]}
• U = {µ}
• L : P(U) → L
• Inn6 =
(cid:8)
• Inn6 = {a 7→ [5, 5]}
• Inn6 = {a 7→ [0, 5]} (Figure 2(b))

h{}, a 7→ [5, 5]i
(cid:9)

n1

a = 0

h{}, a 7→ [0, 0]i
(cid:9)
(cid:8)
if (x ≥ 0)

n2

e1

true

e2

h{}, a 7→ [0, 0]i
(cid:9)
(cid:8)
a = a + 5

n3

h{}, a 7→ [5, 5]i
(cid:9)
(cid:8)

n4

e4

print x

false
e3

h{µ}, a 7→ [0, 0]i
(cid:9)
(cid:8)

e5

h{}, a 7→ [5, 5]i,
h{µ}, a 7→ [0, 0]i
(cid:8)
(cid:9)

n5

if (x == 5)

true

e6

false

h{}, a 7→ [5, 5]i
n6
assert (a ! = 0)
(cid:9)
(cid:8)

h{}, a 7→ [5, 5]i
(cid:9)
(cid:8)

n7

e8

print x

e7
h{}, a 7→ [0, 5]i
(cid:9)
(cid:8)

Figure 6: Computing FPMFP solution for the example of Figure 2. The lifted data ﬂow analysis computes a set of pairs
Inn/Outn at each node n such that a pair hM, di, indicates d ﬂows through each MIPS m ∈ M. if M = {} then d does not
ﬂow through any MIPS at node n. Figure 2 contains single MIPS µ, hence, two pairs are computed (corresponding to {µ}
and {}) at each program point, for brevity, we have only shown pairs where d , ⊤.

4.1. FPMFP Solution Speciﬁcation

Let Inn, Outn ∈ L be the data ﬂow values computed by a data ﬂow analysis at node n, where
L is a meet semi-lattice satisfying the descending chain condition. Additionally, it contains a ⊤
element—we add an artiﬁcial ⊤ value, if there is no natural ⊤.

Equations 6 and 7 (given below) represent the data ﬂow equations for computing MFP so-
lution over the CFG of a procedure, say p. For simplicity we assume a forward analysis. BI
represents the boundary information reaching procedure p from its callers. The meet operator
⊓ computes the glb (greatest lower bound) of elements in L. Function pred(n) returns the pre-
decessor nodes of node n in the CFG of p. The node ﬂow function fn and edge ﬂow function
gm → n compute the eﬀect of node n and edge m → n in the CFG respectively. Usually the edge
ﬂow functions are identity.

BI

Inn = 


Outn = fn(Inn)

d
m∈pred(n)

gm → n(Outm)

n = S tartp
otherwise

(6)

(7)

We lift Equations 6 and 7 to deﬁne a data ﬂow analysis that computes data ﬂow variables Inn, Outn
each of which is a set of pairs of the form hM, di. As explained in Section 3.4, Inn, Outn are
16

values in L, where L : P(U) → L such that U is the set of all MIPS in the program, and L is
the lattice of values computed by Equations 6 and 7.

(8)

(9)

(10)

n = S tartp

gm → n(Outm)

otherwise

BI

—
d
m∈pred(n)

Inn = 


Outn = f n(Inn)
h{}, BIi
(cid:9)
(cid:8)

BI =

∪

hM, ⊤i | M , {}, M ⊆ U
(cid:8)
The top value that is used for initialization is
pointwise application of fn to the pairs in the input set:

. The node ﬂow function ( f n) is
(cid:9)
f n(S) = {hM, fn(d)i | hM, di ∈ S}
The meet operator ( ⊓ ) is pointwise application of ⊓ to the pairs that contain the same set of
MIPS i.e.,

hM, ⊤i | M ⊆ U
(cid:8)

(11)

(cid:9)

S ⊓ S′ = {hM, d ⊓ d′i | hM, di ∈ S, hM, d′i ∈ S′}

(12)

Note that ⊓ is deﬁned for all values in In/Outbecause In/Outeach contain one pair correspond-
ing to each subset of U.

If the partial order between elements in L is ⊑ then the partial order between elements in L

is ⊑ and is given as follows.

S⊑S′ ⇐⇒ (hM, di ∈ S ∧ hM, d′i ∈ S′ =⇒ d ⊑ d′)

(13)

4.2. Deﬁning the Edge Flow Function

We now formally deﬁne the edge ﬂow function g(S). The edge ﬂow function performs the

following two operations over an input pair hM, di in S.

1. If e is end edge of some MIPS in M, then the data ﬂow value d is blocked,

2. Otherwise d is associated with a set of MIPS M′ where M′ = ext(M, e) (described in

Section 3).

The data ﬂow value d from multiple pairs in S can get associated with the same set of MIPS
M′. Hence in the output pair hM′, d′i, d′ is eﬀectively computed by taking meet of values of
d from individual pairs hM, di ∈ S where M′ = ext(M, e), as shown in Equation 15. Let the
function endof (M, e) be a boolean function that denotes if e is end edge of some MIPS in M or
not i.e.,

endof (M, e) =(∃µ ∈ M. e ∈ end(µ))

(14)

The ﬁrst term in the right hand side of the following edge ﬂow function corresponds to the Item
(1) in the list above, while the second term corresponds to the Item (2) of the list.

ge(S) =
(

hM′, ⊤i | M′ ⊆ U, endof (M′, e)
)

(15)

[
hM′, d′i | M′ ⊆ U, ¬endof (M′, e), d′ =

(

l
hM, di∈S, ext(M, e)=M′

d

)

17

Input Pair: hM, di, Output Pair: hM′, d′i

e is end edge of some MIPS in
ext(M, e)

True

False

M′ = ext(M, e), d′ = ⊤

M′ = ext(M, e), d′ = d

Figure 7: Computing output pair hM′, d′i from input pair hM, di in edge ﬂow function ge

5. Extending the FPMFP Computation to the Inter-procedural Level

In this section, we explain the FPMFP computation for inter-procedural data ﬂow analy-
sis [21] by describing the call node handling. Speciﬁcally, we formalize the FPMFP computation
for the functional approach [21] of inter-procedural data ﬂow analysis. First, we brieﬂy explain
the functional approach below. Next, we describe the class of inter-procedural MIPS (MIPS
that span across multiple procedures) that we admit for the FPMFP computation (Section 5.1).
Finally, we explain how FPMFP handles call nodes (Section 5.2).

The functional approach consists of two phases. The ﬁrst phase computes summaries of
procedures in a program, by traversing the callgraph in a bottom-up order (i.e., summaries for
callee procedures are computed before computing the summaries of the caller procedures). In
this phase, a non-recursive procedure is analyzed once, while a recursive procedure is analyzed
multiple times until a ﬁx-point of procedure summaries is reached. After the summary compu-
tation, a top-down traversal of the call-graph is performed to propagate data ﬂow values from
callers to callees. In this phase, a procedure is analyzed in an intra-procedural manner because
the eﬀect of call nodes is represented by the summaries of the callee procedures. Therefore,
explaining call node handling and procedure summary computation is suﬃcient to extend the
FPMFP computation at the inter-procedural level using the functional approach.

We ﬁrst state the types of inter-procedural MIPS that we admit (Section 5.1), followed by
the description of call node handling (Section 5.2), and procedure summary computation (Sec-
tion 5.3).

5.1. Inter-procedural MIPS

An inter-procedural MIPS can span across multiple procedures, unlike an intra-procedural
MIPS that remains inside a single procedure. We allow all intra-procedural MIPS as input for
a FPMFP computation. Additionally, we allow a speciﬁc class of inter-procedural MIPS in the
FPMFP computation. We describe this class of inter-procedural MIPS below.

We categorize an inter-procedural MIPS as shown in Figure 8. Here, we distinguish between
the two types of inter-procedural MIPS depending on if they start and end in the same procedure
or not. We admit a subclass of MIPS that belong to the former type; this subclass is deﬁned below.

18

All inter-procedural MIPS

MIPS that start and end
in the same procedure

MIPS that start and end
in diﬀerent procedures

Balanced MIPS

Non-balanced MIPS

Figure 8: Types of Inter-procedural MIPS

We refer these MIPS as balanced inter-procedural MIPS, because each call edge is matched by
a corresponding call-return edge.

Deﬁnition 2. (Balanced Inter-procedural MIPS) Let a MIPS µ be an inter-procedural MIPS and
V be the set of variables present in the condition on the end edge of µ. We say µ is a balanced
inter-procedural MIPS if it starts and ends in the same procedure in a non-recursive manner7, and
the variables in V are not modiﬁed inside the procedures called through the intermediate nodes
of µ8.

For example in Figure 9, MIPS µ1 : n1

e2−→ n2

e3−→ n3

e4−→ n4

e5−→ n5 is a balanced inter-

procedural MIPS. A balanced MIPS has the following interesting property.

For a balanced MIPS µ that starts and ends in a procedure p, the control ﬂow inside
the procedures called from intermediate nodes of µ can be abstracted out during the
FPMFP computation of p.

In Figure 9, MIPS µ1 : n1

e5−→ n5 goes through the call
e2−→ n2
Example 1.
node n3 that calls procedure q. However, the control ﬂow inside q is abstracted out during
a FPMFP computation of the caller procedure p. In particular, the edges in procedure q are
not marked as inner edges of µ1 (even though the call q() is part of µ1).

e3−→ n3

e4−→ n4

Henceforth, we assume all inter-procedural MIPS that are input to our analysis are balanced.
We now explain the handling of a call node followed by the procedure summary computation for
bit-vector frameworks.

5.2. Handling the Call Nodes

We now describe how the eﬀect of a call node is incorporated in a FPMFP computation. For
this, we assume summaries of all procedures are already computed. We explain the procedure
summary computation for bit-vector frameworks in Section 5.3.

7For each call edge there is a corresponding call return edge in the MIPS.
8In general, this may not hold for all inter-procedural MIPS that start and end in the same procedure. Speciﬁcally,
there could exist an inter-procedural MIPS µ1 such that the variables in the condition on the end edge of µ1 are modiﬁed
along some paths inside the procedures called from intermediate nodes of the MIPS.

19

l = 2

S p

e0

n1

a = 0

e1

e2

n2

use a

e3

n3

q()

e4

n4

a > 5

true

e5

n5

use a

e6

e7

false

Ep

use a

(a)

C pq

use a S q

• MIPS µ1 : e2 → e3 → e4 → e5

e8

l = 0 q1

e9

use a Eq

Rqp

The FPMFP solution

s
e
g
d
E
e3
e4
e8
e9

Sets of MIPS
{}
l 7→ [2, 2]
l 7→ [0, 0]
l 7→ [2, 2]
l 7→ [0, 0]

{µ1}
l 7→ [2, 2]
l 7→ [0, 0]

FPMFP
⊓
l 7→ [2, 2]
l 7→ [0, 0]
l 7→ [2, 2]
l 7→ [0, 0]

(b)

Figure 9: Computing FPMFP solution using the functional approach of inter-procedural analysis: S , E represent the start
and end nodes of a procedure respectively. C pq represents the transfer of control from procedure p to procedure q at a
call node and Rqp represents the return of control from q to p.

Figure 10 shows an abstract view of the handling of a call node in a FPMFP computation. At
a a call node q(), the output pair hM′, d′i corresponding to an input pair hM, di is computed as
follows:

• M′ = ext(M, e4), as explained in the edge ﬂow function in Section 4.2.

• d′ is obtained by using d and the procedure summary of q.

We now explain the complete eﬀect of a procedure call on the caller and callee procedures

using the example in Figure 9 as running example.

5.2.1. Eﬀect of a Caller Procedure on its Callee Procedure

The boundary information (BIq) for a callee procedure q is computed by taking the meet of
data ﬂow values present at all call sites of q. Next, BIq is used for solving the callee procedure q.
If Cq is the set of all call sites of q, and Uq is the set containing 1) intra-procedural MIPS of q,
and 2) balanced inter-procedural MIPS that start and end in q then BIq is computed as follows:

BIq =

h{}, xi
(cid:8)
x = l
n∈Cq

∪

hM, ⊤i | M ⊆ Uq, M , {}
(cid:8)
(cid:9)
fold⊓(Inn)

(cid:9)

,where

20

Procedure p

Procedure q

(C pq, d)

h{}, di

∪

hMi, ⊤i | Mi , {}, Mi ⊆ Uq

(cid:8)

(cid:9)

(cid:8)

(Context c1)

(cid:9)

q()

hM, di

e1

q()

hM′, d′i

e4

q()

q()

e2

q()

e3

q()

(Rqp, d′)

exitVal

d′ = l
d j

hM j, d j i∈exitVal

compute exitVal using context c1
and summary of procedure q

Figure 10: Generic view of call node handling in a FPMFP computation. C pq represents the transfer of control from
procedure p to procedure q at a call node and Rqp represents the return of control from q to p. Uq is the set containing
all i) intra-procedural MIPS of q, and ii) balanced inter-procedural MIPS that start and end in q.

h{}, l 7→ [2, 2]i
.
(cid:9)

In Figure 9, the data ﬂow information in Inn3 is used to compute the boundary information (BIq)
for procedure q i.e., BIq =

(cid:8)

Moreover, a single boundary is maintained for each procedure. If there is a change in the
data ﬂow information at any call site of a procedure q then the new boundary BI′
q is merged with
the existing boundary information of q (BIq). If this leads to a change in the resulting boundary
information of q, the procedure q is added to the worklist for solving. Later, the procedure
is solved in an intra-procedural manner using the new boundary information by the worklist
algorithm [21].

5.2.2. Eﬀect of a Callee Procedure on its Caller Procedure

The MFP computation (speciﬁed by equations 6 and 7 from Section 3.4) deﬁnes the node
ﬂow functions ( fn) for all nodes —including nodes that call other procedures. In the functional
approach of inter-procedural analysis [21], the call node ﬂow functions are deﬁned using sum-
maries of the corresponding callee procedures. We use these node ﬂow functions to compute the
eﬀect of a procedure call on the caller procedure using equation 11. For example, in Figure 9
the MFP analysis deﬁnes the node ﬂow function fn3 which incorporates the eﬀect of call q() i.e.,
q replaces the original value of l by 0. The FPMFP computation uses fn3 to compute f n3 using
equation 11 as follows:

f n3
=
=

h{}, l 7→ [2, 2]i, h{µ1}, l 7→ [2, 2]i
h{}, fn3(l 7→ [2, 2])i, h{µ1}, fn3(l 7→ [2, 2])i
(cid:0)(cid:8)
h{}, l 7→ [0, 0]i, h{µ1}, l 7→ [0, 0]i
(cid:8)
(cid:9)
(cid:9)
(cid:8)

(cid:9)(cid:1)

We elaborate the procedure summary computation for bit-vector frameworks in Section 5.3

21

5.3. Computing the feasible path GEN and KILL summaries for bit-vector frameworks

In this section, we state the MFP speciﬁcations used for the computation of procedure sum-
maries for bit-vector frameworks [1]. Next, we lift these speciﬁcations to the corresponding
FPMFP speciﬁcations.

We use the standard notions of a procedure summary computation for bit-vector frameworks
from [1]. In these frameworks, the node ﬂow functions are of the following form fn(X) = (X −
KILLn) ∪ GENn, where GENn and KILLn are constant for each node. Hence the procedure
summaries can be constructed by composing individual node ﬂow functions, independent of the
calling context information.

The meet operator in bit-vector frameworks is either the set-union or set-intersection. For
simplicity of exposition, we explain the procedure summary computation assuming the meet
operator is union, henceforth we refer these data ﬂow problems as union problems. We explain
the computation for forward data ﬂow analysis, a dual modeling exists for backward analysis
(like live variables analysis [1]).

Let GENn, KILLn be the constant GEN and KILL information at a non-call node n respec-
tively. Then GEN and KILL summaries for procedures are computed by solving corresponding
GEN and KILL data ﬂow problems as described below.

Solving the KILL data ﬂow problem. The kill summary for union problems is computed
using ∩ as the meet operator, indicating that a value is added to the kill summary of a procedure
iﬀ the value is killed along all CFPs that reach the exit of the procedure. Initially, kill summary
of all procedures is set to ⊤ which is the top value of the kill data ﬂow lattice. {} is used as the
boundary value. The MFP speciﬁcations of a KILL data ﬂow problem for a procedure p are as
follows.

{}

KInn = 



m∈pred(n)
T
KOutn = KInn ∪ nodekill(n)

KOutm

n = S tartp
otherwise

nodekill(n) =

KILLn
KOutExitq

n is not a call node
n calls a procequre q





(16)

(17)

(18)

nodekill(n) represents the kill information for the node n; the information is constant if n is not a
call node. Otherwise, nodekill(n) is the information at the exit the procedure called from n. For
simplicity of exposition, we assume at most one procedure can be called from a node (in practice,
more than one procedures can be called from a node through function pointers, in which case
the kill summary of the node is computed by doing intersection of kill information at exit of all
procedures that can be called from n).

Equations 16 to 18 are solved for each procedure chosen in a bottom up traversal of the
call graph of a program. In this, each non-recursive procedure is solved once, while a recursive
procedure is solved multiple times until the data ﬂow values at all points saturate.

The ﬁnal value in KOut at the exit of a procedure p is the KILL summary for procedure
p, as given by the MFP solution. This summary may include the KILL information reaching
from infeasible CFPs. Hence, to get a more precise summary, we lift the MFP speciﬁcations to
the FPMFP speciﬁcations for each procedure p in the program as follows. Let U p be the set
containing 1) intra-procedural MIPS of p, and 2) balanced inter-procedural MIPS that start and
end in procedure p.

22

The FPMFP speciﬁcations (obtained by lifting MFP speciﬁcations from equations 16 to 18):

KILLBI

n = S tartp

d
m∈pred(n)

gm→n(KOutm)

otherwise

∪

hM, ⊤i | M ⊆ U p, M , {}
h{}, {}i
(cid:8)
(cid:9)
(cid:8)
hM, D ∪ nodekill(n)i | hM, Di ∈ KInn
(cid:8)

(cid:9)

(cid:9)

n is not a call node

KILLn

D

n calls a procequre q

hM, Di∈KOutExitq
T

KInn = 



KILLBI =

KOutn =

nodekill(n) =






The ⊓ does a point-wise intersection of the kill data ﬂow values in the input set of pairs as
follows.

S1⊓S2 =

hM, D1 ∩ D2i | hM, D1i ∈ S1, hM, D2i ∈ S2

(23)

The ﬁnal kill summary of a procedure p is computed by doing intersection of the data ﬂow values
at the exit of p i.e.,

(cid:8)

(cid:9)

KSUMp =

D

\hM, Di∈KOutExit p

(24)

We now explain the GEN summary computation of a procedure below.

Solving the GEN data ﬂow problem. The GEN summary for union problems is computed
using ∪ as the meet operator, indicating that a data ﬂow value is added to GEN summary if it is
generated along atleast one CFP that reaches the exit of the procedure. Next, {} is used as the
boundary value. The corresponding MFP speciﬁcations are as follows.

The MFP speciﬁcations:

n = S tartp

GOutm

otherwise

{}
GInn = 



m∈pred(n)
S

GENn

GOutExitq



nodegen(n) =

GOutn = (GInn − nodekill(n)) ∪ nodegen(n)

n is not a call node
n calls a procedure q

23

Based on these MFP speciﬁcations, we derive the FPMFP speciﬁcations for each procedure p
in the program as follows. Let U p be the set containing 1) intra-procedural MIPS of p, and 2)
balanced inter-procedural MIPS that start and end in p.

(19)

(20)

(21)

(22)

(25)

(26)

(27)

The FPMFP speciﬁcations:

hM, {}i | M ⊆ U p

n = S tartp

′

(cid:9)

gm→n(GOutm) otherwise

l
m∈pred(n)

hM, (D − nodekill(n)) ∪ nodegen(n)i | hM, Di ∈ GInn
(cid:8)

n is not a call node

GENn

D

n calls a procedure q

[hM, Di∈GOutExitq

GInn =

GOutn =


(cid:8)




nodegen(n) =





S1⊓′S2 =

(cid:9)

(28)

(29)

(30)

(31)

⊓′

does a point-wise union of data ﬂow values in the set of input pairs as follows.

hM, D1 ∪ D2i | hM, D1i ∈ S1, hM, D2i ∈ S2
(cid:8)

(cid:9)

The ﬁnal gen summary of a procedure p is computed by doing the union of data ﬂow values at
the exit of the procedure p i.e.,

GSUMp =

D

[hM, Di∈GOutExitp

(32)

Substituting GEN and KILL summaries to compute the eﬀect of procedure calls.
The GEN and KILL summaries are computed for all procedures using the corresponding
constant boundary values. We call this summary computation phase. Later, these GEN and
KILL summaries are used to compute the eﬀect of procedure p at all callsites of p during the
actual FPMFP computation (using actual boundary values) as follows: Let n : p() be a callsite of
p then

fn(X) = (X − KSUMp) ∪ GSUMp
f n(S) = {hM, fn(D)i | hM, Di ∈ S}

(33)

(34)

6. Optimizations for Computing FPMFP Solutions

We now describe few optimizations that improve the scalability of a FPMFP computation.
First, we explicate a relation between eﬃciency of the FPMFP computation and the number of
pairs in the FPMFP computation. Next, we propose ideas to reduce the number of pairs. Our
empirical data shows the reduction obtained is signiﬁcant.

As evident from equations 8 to 15, the eﬃciency of a FPMFP computation is inversely pro-
portional to the number of pairs. Theoretically, the number of pairs needed is exponential in the
number of MIPS in U (set of all MIPS) because a diﬀerent pair is created corresponding to each
subset of U. However, at any program point the number of pairs that are evaluated is bounded by
|U| + 1 (explained in Section 6.4). Below, we describe the ideas to reduce the number of pairs by
either merging them or ignoring the ones that have no eﬀect on the ﬁnal FPMFP solution. These
optimizations are shown in Figure 11. We describe each of these optimizations below.

24

All Optimizations

Optimizations that involve
merging pairs

Optimizations that involve
ignoring a pair

Optimization 1
(Section 6.1)

Optimization 2
(Section 6.2)

Optimization 3
(Section 6.3)

Figure 11: Optimizations for scalability of the FPMFP computation: The leaf nodes describe a particular optimization,
and rest of the nodes describe the type of the optimization.

{}
z 7→ [1, 1]
⊤
⊤

Sets of MIPS
{µ1}
⊤
z 7→ [0, 0]
⊤

{µ2}
⊤
⊤
z 7→ [2, 2]

z 7→ [1, 1]

z 7→ [0, 0]

z 7→ [2, 2]

z 7→ [1, 1]

⊤

⊤

{µ1, µ2}
⊤
⊤
⊤

⊤

⊤

FPMFP
⊓
z 7→ [1, 1]
z 7→ [0, 0]
z 7→ [2, 2]

z 7→ [0, 2]

z 7→ [1, 1]

s
e
g
d
E

e3
e5
e6

e7

e9

Table 4: The FPMFP solution for example in Figure 12a. For brevity, only values of z are shown.

6.1. Merging Pairs

We now describe an optimization that allows us to merge some of the pairs present at a
program point. We observed that a large class of MIPS found in our benchmarks were satisfying
the following property.

P: The condition on the end edge of a MIPS µ evaluates to false at the start edge
of µ, and the variables present in the condition are not modiﬁed at the intermediate
nodes of µ.

We observe the following peculiarity of MIPS that satisfy P.

Observation 6.1. We do not need to distinguish between MIPS that satisfy P and have the same
end edge, because the condition on the end edge does not hold at the starts of these MIPS and
data ﬂow values associated with them are blocked at the same end edge. Hence, the data ﬂow
values associated with them can be merged.

We support Observation 6.1 with a proof in Section 10.4. Observation 6.1 allows us to merge

pairs at a program point as described below.

Optimization 1. We merge two pairs hM, di and hM′, d′i into a single pair hM ∪ M′, d ⊓ d′i

25

read a,b; z=1; d=1

e1

switch(b)

case 2

e2

case 1

e4

a=3;z=0

t
l
u
a
f
e
d

e3

a=5;z=2

e5

e6

print a

e7

a > 0

true

e8

false

e9

return -1

return a/z

Paths and MIPS:
• MIPS µ1 : e5 → e7 → e9
• MIPS µ2 : e6 → e7 → e9
• {µ1} end= {µ2} end= {µ1, µ2}

The FPMFP solution: MIPS {µ1}, {µ2},
and {µ1, µ2} are end edge equivalent so the
corresponding data ﬂow values are associated
with {µ1, µ2} only. For brevity, computation
of values for z is shown only.
Sets of MIPS
{}
z 7→ [1, 1]
⊤
⊤

{µ1, µ2}
⊤
z 7→ [0, 0]
z 7→ [2, 2]

FPMFP
⊓
z 7→ [1, 1]
z 7→ [0, 0]
z 7→ [2, 2]

e3
e5
e6

s
e
g
d
E

e7

e9

z 7→ [1, 1]

z 7→ [0, 2]

z 7→ [0, 2]

z 7→ [1, 1]

⊤

z 7→ [1, 1]

(a)

(b)

Figure 12: Equivalent MIPS

iﬀ the sets M and M′ are end edge equivalent (denoted by end= ) as deﬁned below:

M end= M′ ⇔

end(µ) =

end(µ′)

[µ∈M

[µ′∈M′

(35)

The FPMFP computation for the example in Figure 12 is shown in Table 4. Four pairs are
computed at each edge corresponding to each subset of {µ1, µ2}. However, MIPS µ1, µ2 have the
same end edge e9 and hence the following sets are end edge equivalent: {µ1}, {µ2}, {µ1, µ2}. We
obtain the FPMFP solution by merging these pairs as shown in Figure 12b where only two pairs
are maintained at each edge.

6.2. Removing Duplicate Data Flow Values Across Pairs

In this section, we explain how the same data ﬂow values can appear in more than one pairs at
a program point. Further, we propose an idea to remove this duplication of values while retaining
the precision and soundness of the FPMFP solution. This optimization has helped us to improve
the scalability of our approach to 150KLOC, whereas without this optimization scalability was
73KLOC.

In a FPMFP computation, at an edge e, two pairs can contain the same data ﬂow value d iﬀ d
reaches e along two or more CFPs (because in this case d may ﬂow through two diﬀerent MIPS
which are not related by CPO relation). In such case, if one of the CFP is a feasible CFP then the
two pairs can be merged into one as illustrated in Example 1 below.

26

Sets of MIPS
{}
⊤
d 7→ [1, 1]
d 7→ [1, 1]
d 7→ [1, 1]

{µ1}
d 7→ [1, 1]
⊤
⊤
⊤

FPMFP
⊓
d 7→ [1, 1]
d 7→ [1, 1]
d 7→ [1, 1]
d 7→ [1, 1]

e3
e5
e6
e7

s
e
g
d
E

Table 5: Removing Duplicates

Example 1. For example in Figure 13, the data ﬂow value d 7→ [1, 1] ﬂows through MIPS
µ, hence it is associated with {µ} at edges in µ i.e., e3, e5, e7. Next, the value associated with
{µ} is blocked at the end edge e7 of µ, because this value is reaching along the infeasible
CFP that contains µ i.e., e0 → e1 → e3 → e5 → e7.

On the other hand, d 7→ [1, 1] also reaches e7 along the following CFP that is not infea-
sible σ : e0 → e2 → e4 → e6 → e7, hence d 7→ [1, 1] is also associated with {}. Eﬀectively,
d 7→ [1, 1] is included at e7 in the FPMFP solution.

In such case, we can get the same FPMFP solution without associating d 7→ [1, 1] with
{µ} at e5, e7 as shown in Table 5. Observe that the corresponding FPMFP solution is same
to that in Figure 13.

We use the following general criteria to treat the pairs that contain the same data ﬂow value

at a program point.

If a data ﬂow value d reaches the end edge of a MIPS µ along a feasible CFP then
d need not be associated with µ, because even if d is blocked within µ, it reaches
along the feasible CFP and hence its association with µ is redundant.

To ﬁnd out if a data ﬂow value reaches the end edge of a MIPS along a feasible CFP, we

deﬁne the contains-suﬃx-of relation below.

Deﬁnition 3. (Contains-suﬃx-of (CSO)) For a MIPS µ and an edge e in µ, let suﬃx(µ, e) be the
sub-segment of µ from e to end(µ). Then, we say that “MIPS µ1 contains-suﬃx-of MIPS µ2 at
e”, iﬀ µ1 contains suﬃx(µ2, e).

csoe(µ1) = {µ2 | µ2 ∈ U, µ1 contains suﬃx(µ2, e)}

(36)

Observe that the CSO is a reﬂexive relation, and a dual of the CPO relation deﬁned in section 3.3
in the following sense: at an edge e, µ1 CPO µ2 means µ1 and µ2 follow the same CFP till edge
e whereas, µ1 CSO µ2 means µ1 and µ2 follow the same CFP after edge e however they may or
may not follow the same CFP before edge e.

The CSO relation has the following properties.

• Property 1: if a MIPS µ1 contains suﬃx of a MIPS µ2 at an edge e, then the data ﬂow value
associated with µ2 is blocked at or before reaching the end of µ1 (because after e, µ1 and
µ2 follow the same CFP on which µ2 ends at or before the end of µ1).

27

For example in Figure 14a, µ1 CSO µ2 at e5. Hence, l 7→ [0, 0] is
Example 2.
blocked at e6 in pair h{µ2}, l 7→ [0, 0]i as well as at e7 in h{µ1}, l 7→ [0, 0]i. Thus
l 7→ [0, 0] does not reach e7.

• Property 2: if two pairs hM1, di and hM2, di contain the same data ﬂow value d at an edge

e, and d is not killed along a MIPS µ2 in M2 then the following holds.

d reaches the end of µ2 along atleast one feasible CFP that passes through e,
provided that µ2 does not contain suﬃx of any MIPS in M1 at e. Speciﬁcally in
this case, the data ﬂow value d from pair hM1, di reaches the end of µ2 (proof
in Section 10.4). Hence the association of d with µ2 can be discarded.

Example 3. For example in Figure 14a, µ2 does not contain suﬃx of µ1. Further,
l 7→ [0, 0] ﬂows through µ1 and µ2 and is blocked at corresponding end edges as
shown in Figure 14b. However, l 7→ [0, 0] is included in the FPMFP solution at the
end edge e6 of µ2 because it reaches along the following feasible CFP: e0 → e3 →
e5 → e6 → e9.

In such case, we can get the same FPMFP solution without maintaining an association
with µ2.

Based on the above properties, we now formally describe the following criteria to merge two

pairs that have the same data ﬂow value.

Optimization 2. At an edge e, we shift the common data ﬂow value d from two pairs hM1, di
and hM2, di to a single pair hM3, di where M3 contains only those MIPS in M1 ∪ M2 that
contain suﬃx of at least one MIPS in M1 and at least one MIPS in M2

9 i.e.,

M3 ={µ1 | µ1 ∈ M1, ∃µ2 ∈ M2. µ1 CSO µ2 at e}

∪
{µ2 | µ2 ∈ M2, ∃µ1 ∈ M1. µ2 CSO µ1 at e}

Example 4. For example in Figure 14a, at edges e5 and e6 µ1 CSO µ2, hence we associate
l 7→ [0, 0] with µ1 only as shown in Figure 14c. Observe the corresponding FPMFP solution
is same as in Figure 14b.

Example 5. For example in Figure 15a, the data ﬂow value l 7→ [0, 0] ﬂows though two
MIPS µ1 and µ2. Further neither µ1 CSO µ2 nor µ2 CSO µ1, hence l 7→ [0, 0] reaches
end(µ1) and end(µ2) along the following feasible CFPs σ1 and σ2 respectively, σ1 : e0 →
e1 → e3 → e4 → e7, σ2 : e0 → e2 → e4 → e5. Hence, l 7→ [0, 0] is included in the FPMFP
solution at edges e7 and e5 as shown in Figure 15b.

9Note that CSO is a reﬂexive relation, hence if µ1 ∈ M1 then “µ1 contains suﬃx of at least one MIPS in M1” is

trivially true.

28

d=1

e0

c > 5

e2

e1

true

false

a = 0

h{}, d 7→ [1, 1]i
(cid:9)

(cid:8)

e5

e3

b > 5

e4

h{µ}, d 7→ [1, 1]i
(cid:9)

(cid:8)

h{}, d 7→ [1, 1]i
(cid:9)

(cid:8)
read a

h{}, d 7→ [1, 1]i, h{µ}, d 7→ [1, 1]i
(cid:9)
(cid:8)

e6

a > 5

h{}, d 7→ [1, 1]i
(cid:9)

(cid:8)

h{}, d 7→ [1, 1]i, h{µ}, d 7→ [1, 1] i
true
(cid:9)
(cid:8)
use a

e7

e8

h{}, d 7→ [1, 1]i
(cid:9)

false(cid:8)

use a

Figure 13: An example illustrating the FPMFP computation. The path segment µ : e3 → e5 → e7 is a MIPS. For
simplicity, we have only shown value range of variable d, and pairs hM, xi where x , ⊤.

We obtain the same FPMFP solution without associating l 7→ [0, 0] with µ1 or µ2 as

shown in Figure 15c.

6.3. Removing the pairs that contain ⊤ data ﬂow value

In a pair hM, di the data ﬂow value d remains ⊤ at edges that are outside a MIPS in M. We

use the following observation to eliminate such pairs.

Observation 6.2. Ignoring the pairs that contain ⊤ as data ﬂow value does not aﬀect the preci-
sion or the soundness of the FPMFP solution because the FPMFP solution is computed by taking
meet of the data ﬂow values in each pair at a program point.

Optimization 3. We eliminate the pairs that have ⊤ as the associated data ﬂow value, if the

total number of remaining pairs at the program point is more than one.

For example in Figure 12b, the pairs corresponding to {} at edges e5 and e6 contain ⊤ value
hence these pairs can be eliminated. Similarly, pairs corresponding to {µ1, µ2} at edges e3 and e9
can be eliminated.

With this modiﬁcation the node and edge ﬂow functions (Equations 11, 15) remain same
except that the meet operator (Equation 12) now assumes absence of a pair corresponding to
some M ⊆ U in the input sets as presence of a pair hM, ⊤i.

29

if (l == 0)

e0
true

if (d == 2)

e1
false

e3
false

e2

true

c=2, read d

Paths and MIPS:
• MIPS µ1 : e3 → e5 → e6 → e7(marked in blue)
• start(µ1) = {e3}, inner(µ1) = {e5, e6},
• end(µ1) = {e7}
• MIPS µ2 : e4 → e5 → e6(marked in red)
• start(µ2) = {e4}, inner(µ2) = {e5}, end(µ2) = {e6}
• At e5 and e6, µ1 CSO µ2

e4

print l

e5

if (c == 0)

e8
false

e6

true

if (d == 2)

e7
true

e9
false

exit

e10

print l

Sets of MIPS
{µ1}
⊤
l 7→ [0, 0]
⊤

s
e
g
{µ2}
{}
d
E
⊤
e1 l 7→ [1, ∞]
⊤
⊤
e3
l 7→ [0, 0]
⊤
e4
e5 l 7→ [1, ∞] l 7→ [0, 0] l 7→ [0, 0]
e6 l 7→ [1, ∞] l 7→ [0, 0] l 7→ [0, 0]
e7 l 7→ [1, ∞] l 7→ [0, 0]

⊤

(b)

FPMFP
⊓

{µ1, µ2}

⊤ l 7→ [1, ∞]
l 7→ [0, 0]
⊤
l 7→ [0, 0]
⊤
⊤ l 7→ [0, ∞]
⊤ l 7→ [0, ∞]
⊤ l 7→ [1, ∞]

FPMFP
⊓

{µ1, µ2}

{µ2}
⊤
⊤

Sets of MIPS
{µ1}
⊤
l 7→ [0, 0]
⊤

s
e
g
{}
d
E
e1 l 7→ [1, ∞]
⊤
e3
⊤
e4
e5 l 7→ [1, ∞] l 7→ [0, 0]
e6 l 7→ [1, ∞] l 7→ [0, 0]
e7 l 7→ [1, ∞] l 7→ [0, 0]

⊤ l 7→ [1, ∞]
l 7→ [0, 0]
⊤
l 7→ [0, 0]
l 7→ [0, 0] ⊤
⊤ l 7→ [0, ∞]
⊤ l 7→ [0, ∞]
⊤ l 7→ [1, ∞]

⊤
⊤
⊤

(a)

(c)

Figure 14: Illustrating pairs that have the same data ﬂow value and have CSO relation between constituent MIPS. Here l
is an unsigned int variable.

6.4. Complexity Analysis

The cost of the FPMFP computation is equivalent to computing k + 1 parallel MFP solutions,
where k is bounded by the maximum number of pairs at a program point that do not contain ⊤
as the associated data ﬂow value.

At an edge e, the maximum number of pairs that do not contain ⊤ value is same as the maxi-
mum number of distinct sets given by cpoe(µ) over all MIPS µ, plus 1 for the pair corresponding
to {}. In worst case, cpoe(µ) set for each µ is distinct. Hence the total number of such pairs (i.e.,
k value from previous paragraph) is bounded by the number of MIPS in the CFG. In practice
we found the k value to be much smaller where the FPMFP computation time was 2.9× of the
MFP computation time on average. This is because not all MIPS in a program overlap with each
other.

7. Experiments and Results

In this section, we empirically compare FPMFP solution with MFP solution with respect
to the precision of the solutions and the eﬃciency of their computation. Indeed, we did not
ﬁnd any other existing technique that is as generic as the MFP computation, and eliminates the
eﬀect of infeasible paths from exhaustive data ﬂow analysis (existing techniques are explained
in Section 8).

30

l=0
e0

if (c ! = 0)

e2
false

print l

e4

if (c == 0)

e7
false

e1

true

c=2

e3

e5

true

assert(l! = 0)

e6

exit

(a)

Paths and MIPS:
• MIPS µ1 : e2 → e4 → e7 (marked in blue)
• MIPS µ2 : e3 → e4 → e5 (marked in red)
• start(µ1) = e2
• start(µ2) = e3
• inner(µ1) = inner(µ2) = e4
• end(µ1) = e7, end(µ2) = e5

{}
⊤
⊤
⊤

Sets of MIPS
{µ1}
l 7→ [0, 0]
⊤

s
e
g
d
E
e2
e3
e4
e5 l 7→ [0, 0]
e7 l 7→ [0, 0] l 7→ [0, 0]

{µ2}
⊤
l 7→ [0, 0]
l 7→ [0, 0] l 7→ [0, 0]
l 7→ [0, 0]
⊤

⊤

FPMFP
⊓

{µ1, µ2}

⊤ l 7→ [0, 0]
⊤ l 7→ [0, 0]
⊤ l 7→ [0, 0]
⊤ l 7→ [0, 0]
⊤ l 7→ [0, 0]

(b)

{µ1} {µ2} {µ1, µ2}

Sets of MIPS

{}

s
e
g
d
E
e2 l 7→ [0, 0] ⊤ ⊤
e3 l 7→ [0, 0] ⊤ ⊤
e4 l 7→ [0, 0] ⊤ ⊤
e5 l 7→ [0, 0] ⊤ ⊤
e7 l 7→ [0, 0] ⊤ ⊤

⊤
⊤
⊤
⊤
⊤
(c)

FPMFP
⊓
l 7→ [0, 0]
l 7→ [0, 0]
l 7→ [0, 0]
l 7→ [0, 0]
l 7→ [0, 0]

Figure 15: Illustrating pairs that have the same data ﬂow value but do not have CSO relation between constituent MIPS.
l 7→ [0, 0] reaches end(µ1) and end(µ2) along the following feasible CFPs σ1 and σ2 respectively, σ1 : e0 → e1 → e3 →
e4 → e7, σ2 : e0 → e2 → e4 → e5.

The Section is organized as follows. First, we explain the experimental setup and benchmark
characteristics (Section 7.1). Next, we describe two client analyses on which we compared
precision of FPMFP and MFP solutions (Section 7.2), followed by comparing the performance
of FPMFP and MFP solutions (Section 7.5). Lastly, we discuss infeasible path patterns observed
in our benchmarks (Section 7.6)

7.1. Experimental Setup

We performed our experiments on a 64 bit machine with 16GB RAM running Windows 7
with Intel core i7-5600U processor having a clock speed of 2.6 GHz. We used 30 C programs of
up to 150KLoC size which contained 7 SPEC CPU-2006 benchmarks, 5 industry codesets, and
18 open source codesets [25, 26, 27]. These programs were randomly chosen to cover a range
of application areas with diﬀerent program characteristics. The number of distinct MIPS range
from 17 for the acpid benchmark to 2.1k for the h264ref benchmark. In these benchmarks, up
to 61% (geomertic mean 29%) functions had at least one MIPS in their CFG. On average 77%
MIPS were overlapping with at least one other MIPS.

We used the iterative ﬁx-point based data ﬂow analysis algorithm [28, 1] implemented in
Java in a commercial static analysis tool TCS Embedded Code Analyzer [22] for our data ﬂow
analysis. Initially, the tool transforms the source code to an intermediate representation, and
constructs CFGs for procedures in the program. Later, it runs some basic inbuilt analyses like
pointer analysis, alias analysis in ﬂow sensitive and context insensitive manner, followed by

31

Table 6: Benchmark properties: three types of benchmarks that we used include Open source [25, 26, 27], Industry, and
SPEC CPU 2006 benchmarks.

Benchmark Properties

Type

Name

KLOC #MIPS

#Overlapping
MIPS

#Balanced
MIPS

%Funcs
Impacted

1.acpid
2.polymorph
3.nlkain
4.spell
5.ncompress
6.gzip
7.stripcc
8.barcode-nc
9.barcode
10.archimedes
11.combine
12.httpd
13.sphinxbase
14.chess
15.antiword
16.sendmail
17.sudo
18.ﬀmpeg
19.mcf
20.bzip2
21.hmmer
22.sjeng
23.milc
24.h264ref
445.gobmk

26.NZM
27.IC
28.AIS
29.FRSC
30.FX

0.3
0.4
0.5
0.6
1
1.3
2.1
2.3
2.8
5
5.7
5.7
6.6
7.5
19.3
20.3
45.8
80

5.4
16
16.5
27
30
35.9
150

2.6
3.7
6
6
7.5

e
c
r
u
o
S
n
e
p
O

SPEC

Industry

6
24
33
14
30
49
107
60
76
118
234
226
213
262
669
726
250
1363

19
501
595
438
497
2189
1834

52
50
83
42
140

6
24
8
11
27
46
97
49
66
86
210
211
199
186
570
681
223
1201

17
485
522
379
375
1696
1435

43
29
56
21
78

6
17
3
12
16
40
74
22
28
53
124
88
109
112
306
349
148
891

4
184
270
198
141
526
756

34
13
21
1
39

7
11
58
23
30
25
30
25
24
38
29
16
16
39
32
32
15
9

20
40
20
33
38
31
13

43
15
14
15
34

constructing the program call graph. Since FPMFP just lifts the abstract operations given in the
input MFP speciﬁcation, it remains oblivious to and respects the analysis speciﬁc choices like
use of aliasing, pointers, and ﬁeld sensitivity. In our evaluation, we implemented the functional
approach of inter-procedural analysis (described in Section 5) for computing MFP and FPMFP
solutions for potentially uninitialized variable analysis and reaching deﬁnitions analysis. The

32

details of the same are discussed in Section 7.2.

Table 7: Reduction in the number of potentially uninitialized variable Alarms

Benchmarks

1.acpid
2.polymorph
3.nlkain
4.spell
5.ncompress
6.gzip
7.stripcc
8.barcode-nc
9.barcode
10.archimedes
11.combine
12.httpd
13.sphinxbase
14.chess
15.antiword
16.sendmail
17.sudo
18.ﬀmpeg
19.mcf
20.bzip2
21.hmmer
22.sjeng
23.milc
24.h264ref
25.gobmk
26.NZ
27.IC
28.AIS
29.FRSC
30.FX

e
c
r
u
o
S
n
e
p
O

C
E
P
S

y
r
t
s
u
d
n
I

MFP
1
4
4
3
7
0
27
0
2
61
63
117
46
16
18
103
62
124
5
72
636
19
188
52
1216
3
5
0
3
84

Uninitialized
Variable Alarms
FPMFP
1
4
0
3
7
0
1
0
0
56
63
117
43
16
18
102
58
112
5
35
629
19
168
48
1199
0
5
0
3
84

reduction(%)
0(0)
0(0)
4(100)
0(0)
0(0)
-
26(96.30)
-
2(100)
5(8.20)
0(0)
0(0)
3(6.52)
0(0)
0(0)
1(0.97)
4(6.45)
12(9.68)
0(0)
37(51.39)
7(1.10)
0(0)
20(10.64)
4(7.69)
17(1.39)
3(100)
0(0)
-
0(0)
0(0)

7.2. Comparing the Precision of FPMFP and MFP Solutions
7.3. Reduction in the Number of Potentially Uninitialized Variable Alarms

A potentially uninitialized variable analysis reports the variables that are used at a program
point but are not initialized along at least one path that reaches the program point. We com-
puted the potentially uninitialized variables as follows: ﬁrst, we implemented the must deﬁned
variables analysis that computes the set of non-array variables that are deﬁned along all CFPs
reaching a program point. Next, we take the complement of the must deﬁned data ﬂow results to

33

Table 8: Reduction in the number of def-use pairs: 1) MFP (resp. FPMFP) column shows the sum of number of def-use
pairs at all program nodes n in the CFG of a program for global and local variables.

Benchmarks

Reaching Deﬁnition Analysis

Type

Name

#def-use pairs

reduction(%)

MFP

FPMFP

1.acpid

2.polymorph

3.nlkain

4.spell

5.ncompress

6.gzip

7.stripcc

8.barcode-nc

9.barcode

10.archimedes

11.combine

12.httpd

13.sphinxbase

14.chess

15.antiword

156

228

1042

516

1201

3423

2703

3051

3709

44337

16618

10475

9641

31386

68889

156

228

965

515

1175

3401

2645

3007

3653

44216

15859

10072

0(0.00)

0(0.00)

77(7.39)

1(0.19)

26(2.16)

22(0.64)

58(2.15)

44(1.44)

56(1.51)

121(0.27)

759(4.57)

403(3.85)

8482

1159(12.02)

31303

60144

83(0.26)

8745(12.69)

e
c
r
u
o
S
n
e
p
O

16.sendmail

102812

101470

1342(1.31)

17.sudo

18.ﬀmpeg

19.mcf

20.bzip2

21.hmmer

SPEC

22.sjeng

23.milc

14391

89148

3570

82548

70597

77602

18133

14211

86607

3565

77967

70021

76959

17828

180(1.25)

2541(2.85)

5(0.14)

4581(5.55)

576(0.82)

643(0.83)

305(1.68)

24.h264ref

426346

409325

17021(3.99)

25.gobmk

213243

184142

29101(13.65)

26.NZ

Industry

27.IC

28.AIS

29.FRSC

30.FX

2651

3063

2414

1295

4925

1(0.04)

48(1.54)

61(2.46)

2(0.15)

46(0.93)

2652

3111

2475

1297

4971

34

Table 9: Comparing performance of MFP and FPMFP computation. Prep. represents the MIPS detection phase. Note
the analysis times are not comparable with gcc or clang, because our implementation is in Java.

Benchmarks

Analysis Time (Sec)

Memory Consumption (MB)

Prep MFP FPMFP

Incre-

ase(x)

Prep MFP FPMFP

Incre-

ase(x)

1.acpid

2.polymorph

3.nlkain

4.spell

5.ncompress

6.gzip

7.stripcc

8.barcode-nc

9.barcode

10.archimedes

11.combine

12.httpd

13.sphinxbase

14.chess

15.antiword

0

0

0

0

1

1

3

2

2

6

5

0

0

0

0

0

1

1

1

2

3

3

40

7

13

13

14

3

7

16

0

0

0

0

1

5

6

2

2

32

5

19

3

30

82

0

0

0

0

1(1)

4(4)

5(5)

1(1)

0

29(10)

2(0.6)

5(0.3)

0

23(3)

0

1

1

1

2

5

8

6

7

24

16

28

13

31

0

0

1

1

1

10

5

8

10

44

23

39

16

93

66(4)

47 101

0

0

1

0

4

24

21

6

8

0

0

0

0

2(2)

14(1.4)

15(3)

-1(-0.1)

-1(-0.1)

156

112(2.5)

19

-3(-0.1)

21 -18(-0.46)

7

-9(-0.56)

191

218

98(1)

117(1)

16.sendmail

110 142

2060 1918(13)

81 340

1548 1208(3.5)

17.sudo
18.ﬀmpeg

19.mcf

20.bzip2

21.hmmer

22.sjeng

23.milc

15

234

1

8

14

10

6

9

51

1

7

9

16

4

17

8(1)

35

71

19

-52(-0.7)

80 29 (0.5) 158 266

90 -175(-0.6)

1

69

23

62

7

0

62 (9)

14(1.5)

0

28

50

3

44

67

3

90

58

0

46(1)

-8(-0.1)

46(2.8)

27 122

215

92(0.75)

3(0.7)

25

25

14

-11(-0.4)

24.h264ref

60 115

451 336(2.9) 131 1003

1644

640(0.6)

25.gobmk

4218 1696

9818 8122(4.7) 390 9365 17392 8032(0.85)

e
c
r
u
o
S
n
e
p
O

6
0
0
2
C
E
P
S

y
r
t
s
u
d
n
I

26.NZM

27.IC

28.FRSC

29.AIS

30.FX

1

5

3

4

7

1

4

2

3

3

2

1(1)

3

3 -1(-0.25)

11

1

4

7

-1(-0.5)

-15

1(0.3)

9

4(1.3)

20

8

20

10

20

35

7

9

4

16

47

-1(-0.1)

-11(-0.5)

-6(-0.6)

-4(-0.2)

11(0.3)

35

Table 10: Impact of Optimization 1 on the FPMFP computation (in Optimization 1, we consider two MIPS with the same
end edge as equivalent, and subsequently merge the pairs that contain equivalent MIPS).

Benchmarks

1.acpid

2.polymorph 0.96

e
c
r
u
o
S
n
e
p
O

3.nlkain

4.spell

5.ncompress

6.gzip

7.stripcc

8.barcode-nc

9.barcode

10.archimedes

11.combine

12.httpd

13.sphinxbase

14.chess

Number of Distinct MIPS

Before and After Optimization 1

Before

After

Reduction(%)

83

65

35

99

14163

23524624

6

24

33

14

30

49

774751 107

208

3851

60

76

1054292 118

27061 234

77(92.77)

41(63.08)

2(5.71)

85(85.86)

14133(99.79)

23524575(99.99)

774644(99.99)

148(71.15)

3775(98.03)

1054174(99.99)

26827(99.14)

76591463106 226

76591462880(99.99)

6463 213

6250(96.70)

19701157845 262

19701157583(99.99)

15.antiword

1446759232593972 669 1446759232593303(99.99)

16.sendmail

94082730655046 726

94082730654320(99.99)

17.sudo
18.ﬀmpeg

19.mcf

20.bzip2

21.hmmer

22.sjeng

23.milc

24.h264ref

25.gobmk

6
0
0
2
C
E
P
S

y
r
t
s
u
d
n
I

26.NZM

27.IC

28.AIS

29.FRSC

30.FX

549565 250

549315(99.95)

5019442696182 1363

5019442694819(99.99)

44

19

25(56.82)

115451494 501

115450993(99.99)

8606721 595

8606126(99.99)

1508084297532741 438 1508084297532303(99.99)

2322 497

1825(78.60)

51269021916 2189
> 264 1834

51269019727(99.99)
> 264(99.99)

1012(95.11)

108(68.35)

93(52.84)

47(52.81)

564(80.11)

1064

158

176

89

52

50

83

42

704 140

36

Table 11: Impact of Optimization 2 on the FPMFP computation. Timeout indicates the analysis did not ﬁnish within 10K
seconds.

Benchmarks

1.acpid

2.polymorph 0.96

3.nlkain

4.spell

5.ncompress

6.gzip

7.stripcc

8.barcode-nc

9.barcode

10.archimedes

11.combine

12.httpd

13.sphinxbase

14.chess

15.antiword

16.sendmail

17.sudo
18.ﬀmpeg

19.mcf

20.bzip2

21.hmmer

22.sjeng

23.milc

24.h264ref

25.gobmk

26.NZM

27.IC

28.AIS

29.FRSC

30.FX

e
c
r
u
o
S
n
e
p
O

6
0
0
2
C
E
P
S

y
r
t
s
u
d
n
I

Analysis Time (in Seconds)

Before and After Optimization 2

Before After Reduction(%)

0

0

0

0

3

22

55

2

2

53

19

290

4

76

705

0

0

0

0

1

5

6

2

2

32

5

19

3

30

82

Timeout 2060

64

Timeout

1

931

143

501

11

17

80

1

69

23

62

7

0

0

0

0

2(66)

17(77)

49(89)

0

0

21(39)

14(73)

271 (93)

1(25)

46(60)

623(88)

-

47(73)

-

0

862 (92)

120(83)

439(87)

4(36)

2977

451

2526(84)

-

2(50)

3(50))

3(42)

2(66)

2(22)

Timeout 9818

4

6

7

3

9

2

3

4

1

7

37

report the variables that are used at a program point p but are not initialized along at least one
CFP that reaches p. We call such CFPs as witness CFPs.

As shown in Table 7, we computed two sets of potentially uninitialized variable alarms cor-
responding to the MFP and FPMFP solutions of must deﬁned variable analysis. In particular, the
potentially uninitialized variable analysis that used the FPMFP solution of must deﬁned analysis
reported up to 100% (average 18.5%, geo. mean 3%) fewer alarms compared to when it used the
MFP solution. In the reduced alarm cases, all the witness CFPs were found infeasible.

More speciﬁcally, in 14 out of 27 benchmarks the FPMFP solution helped achieve positive
reduction in the uninitialized variable alarms, while in 13 benchmarks there was no reduction in
the alarms. In the latter case the following two scenarios were observed: in the ﬁrst scenario,
the addresses of uninitialized variables are passed as parameter to library functions whose source
code is not available and hence its behavior is conservatively approximated (i.e, the analysis
assumed that the variables are not initialized inside the functions), and in the second scenario
a variable is conditionally initialized inside the callee procedure where the evaluation of the
condition depends on the calling context thereby necessitating a context sensitive analysis to
eliminate the false positive alarm (our implementation is context insensitive).

7.4. Reduction in the Number of Def-Use Pairs

We implemented the classic reaching deﬁnitions analysis [28, 1] (non SSA based) in which
for each program point, we compute the set of deﬁnitions that reach the point. We measured the
eﬀect of the reduction in the number of reaching deﬁnitions on Def-Use pair computation, which
is a client analysis of the reaching deﬁnitions analysis. In this, we pair the deﬁnition of a variable
with its reachable use point.

In the FPMFP computation, the def and use points that are connected with each other by only
infeasible paths are eliminated. However, we found that most def-use points are connected by at
least one feasible CFP, and hence a 100% reduction is not achievable by any technique.

As shown in Table 8, we found that up to 13.6% (average 2.87%, geometric mean 1.75%)
fewer def-use pairs were reported when using FPMFP solution in place of the MFP solution.
In particular, in 28 out of 30 benchmarks the FPMFP solution lead to fewer def-use pairs than
the MFP solution.
In general, we observed that the precision increased with increase in the
number of MIPS. For example, the gobmk benchmark contains a large number of MIPS (1.9k),
consequently we observed signiﬁcant (13%) reduction in the number of def-use pairs. On the
other hand, the acpid benchmark had only 17 MIPS, consequently we did not see any reduction
in the number of def-use pairs. As an outlier case, on the sphinxbase benchmark that had only
216 MIPS we observed 12% reduction in def-use pairs. Here, we observed that the end edges
of many MIPS are reachable only along infeasible CFPs, hence in FPMFP computation the data
ﬂow along these edges is completely blocked, thus all the corresponding def-use pairs (at the
program points pre-dominated by the end edges) are eliminated.

The def-use pairs have multifold applications; in particular, they are useful for program slic-
ing, program dependency graph creation, program debugging, and test case generation. For
example in program testing, some coverage criteria mandate that each def-use pair should be
covered by at least one test case. Here, up to 13.6% fewer def-use pairs means fewer manual test
cases need to be written to cover these pairs, which is a signiﬁcant reduction in the manual time
and eﬀorts.

38

7.5. Comparing the Performance of FPMFP and MFP Computations

Computation of the FPMFP solution was less eﬃcient than the corresponding MFP solutions.
The details of the relative memory and time consumption of both the analyses for reaching deﬁ-
nitions computation are presented in Table 9. The Prep. column represents the time and memory
consumption for infeasible path detection phase. This is performed once for each program.

The FPMFP analysis took 2.9 times more time than MFP analysis on average (geo. mean
1.6). In general, the analysis time increased with increase in the number of MIPS in the program.
Apart from this, the FPMFP analysis consumed 0.5 times more memory than the MFP analysis
on average. However, on 50% of the bechmarks the FPMFP analysis consumed less memory
than the MFP analysis because the deﬁnitions reaching along infeasible CFPs are ignored during
the analysis.

The eﬀect of optimizations for scalability on analysis time
Table 10 shows the reduction in the number of distinct MIPS after applying Optimization 1
(Section 6.1). Here, two MIPS are considered equivalent if they have the same end edge, in this
case we can merge two pairs if they contain equivalent MIPS. We found that if we count MIPS
with same end edge single time, then the total number of MIPS reduces by up to 99%(average
85%, geometric mean 78%). This leads to reduction in number of pairs at various program
points.

Table 11 shows the eﬀectiveness of optimization 2 (Section 6.2) on top of optimization 1.
In particular, it shows the analysis time before and after applying the optimization 2. We found
that 3 out of 30 applications timed out (i.e., did not ﬁnish within 10K seconds) when we dis-
abled optimization 2. Similarly, for remaining applications the analysis time increased by up to
99%(average 48.9%, geometric mean 19.8%) after disabling optimization 2.

If(...){
A: x = 5;
}
...
If(x < 5){
B: print(“%d”, &x)
}

Const int N = 100
A: x = 0;
While(x < N){
...
x + +;
}
B:

(a)

(b)

If(x < 5){
A:
}
...
If(x < 5){
...
}else{
B:
}

(c)

Figure 16: Illustrating the types of MIPS observed. In each of the example above there is a MIPS going from point A to
point B. The variable x is not modiﬁed in the code portion represented by three dots (. . .) .

7.6. Types of MIPS Observed

In general case, knowing whether a path is infeasible or not is undecidable. Nevertheless,
a large number of infeasible paths in a program can be identiﬁed using statically detectable
correlations between two branch conditions or between a branch condition and an assignment
statement. Indeed, in our work, we detected a large number of MIPS using Bodik’s approach
(described in Appendix A).

We observe that a lot of MIPS in our benchmarks belong to one of the following two types
resulting from correlation between an assignment statement and a branch statement or two branch
statements.

39

1. The ﬁrst type involves assignment of constant value to a variable along some node in a
path followed by the variable being used in some conditional expression that performs
either equality or less than or greater than check on the variable later in the path. Two
typical examples of this type are shown Figure 16a and 16b. In the ﬁrst example a variable
is assigned a constant value inside the if branch (point A) and subsequently used in other
branch condition that appears later in the path (point B). The second example contains a
loop that executes at least once hence the path that goes from point A to point B without
executing the loop is infeasible.

2. The second type involves two syntactically same conditions used in two branches at dif-
ferent places in a path and the variables in the conditions are not modiﬁed along the path
that connects the branches. For example in Figure 16c the path that goes from point A to
point B is infeasible.

7.7. Summary of Empirical Observations

Previous empirical evidence [2] on linux kernel code shows 9-40% of conditional statements
contribute to at least one infeasible CFP. In our benchmarks up to 61% (geometric mean 29%)
functions had at least one MIPS in their CFG. Precise elimination of data ﬂow values reaching
from infeasible CFPs has allowed us to reduce the number of def-use pairs by up to 13.6% with
an average of 2.87% and a geometric mean of 1.75% over MFP solution. Similarly, the reduction
in the potentially uninitialized variable alarms was up to 100% (average 18.5%, geo. mean 3%).

8. Related Work

In this section, we compare FPMFP with existing approaches of improving data ﬂow preci-
sion. In particular, we begin by classifying the existing approaches that improve the precision
of data ﬂow analysis into two categories. The approaches in the ﬁrst category avoid the eﬀect
of infeasible paths from data ﬂow analysis (Section 8.1), while the approaches in second cate-
gory avoid the join points (of two or more CFPs) that lead to imprecision in the analysis results
(Section 8.4). Lastly, we explain how FPMFP diﬀers from approaches in both the categories.

8.1. Approaches that Avoid Infeasible Paths

In general, presence of infeasible paths in programs is well known [29, 30, 12, 31, 32, 33, 34,
35]. Hedley et al. [30] presented a detailed analysis of the causes and eﬀects of infeasible paths
in programs. Malevris et al. [12] observed that the greater the number of conditional statements
contained in a path, the greater the probability of the path being infeasible. Bodik et al. [2]
found that around 9-40% of the conditional statements in programs show statically detectable
correlation with infeasible control ﬂow paths.

Many approaches have been proposed to eliminate the eﬀect of infeasible paths from data
ﬂow analysis. We classify these approaches in two categories as shown in Figure 17. The ﬁrst
category includes approaches that are analysis dependent (Section 8.2), while the second cate-
gory includes the approaches that are analysis independent (Section 8.3). We describe and relate
approaches in each of these categories with FPMFP below.

40

Approaches to Improve
Data Flow Precision

Avoid
Infeasible Paths

Avoid
Imprecise Joins

Analysis
Dependent
Approach

Analysis
Independent
Approach

CFG
Restructuring

Trace
Partitioning

Selective
Path Sensitivity

CFG
Restructuring

Our
Approach

Figure 17: Categorization of approaches that improve data ﬂow precision by either avoiding infeasible paths or imprecise
joins.

8.2. Analysis Dependent Approaches

In this section, we describe approaches that eliminate eﬀect of infeasible paths from data ﬂow
analysis in analysis dependent way. In particular, these approaches either depend on analysis
speciﬁc heuristics, or they detect infeasible paths on the ﬂy during a data ﬂow analysis (and
hence they detect infeasible paths separately for each diﬀerent data ﬂow analysis over the same
program thereby increasing the analysis cost). Speciﬁcally, these approaches use the idea of path
sensitive analysis to distinguish between the data ﬂow values reaching along diﬀerent classes of
CFPs [13, 14, 15, 16, 17, 18].

In a completely path sensitive analysis each path information is separately tracked along with
the corresponding path constraints. If the path constraint is found unsatisﬁable, the path infor-
mation is not propagated further. This approach does not scale to most practical programs due
to presence of loops and recursion leading to an unbounded number of program paths combined
with data ﬂow lattices containing possibly inﬁnite values.

The above limitations of a completely path sensitive analysis are avoided by adapting a selec-
tive approach to path sensitive analysis [18, 17, 16, 15, 14, 13, 36, 11]. Here, they use selective
path constraints governed by various heuristics for deciding which path information should be

41

kept separately and which path information can be approximated at join points. These heuristics
are often aligned with the end goal of the analysis. Our work diﬀers from these approaches in
that our work does not depend on analysis speciﬁc heuristics for eliminating the eﬀect of infeasi-
ble paths, and therefore can be generically applied to all MFP based data ﬂow analyses. Below,
we describe the approaches that use selective path sensitive analyses.

Dor et al [18] proposed a precise path sensitive value ﬂow analysis approach using value bit
vectors. Here, they symbolically evaluate a program by generating symbolic states that include
both the execution state and the value alias set. At merge points in the control ﬂow graph, if two
symbolic states have the same value alias set, they produce a single symbolic state by merging
their execution states. Otherwise, they process the symbolic states separately. Like our work,
they avoid the cost of full path sensitive analysis, yet capture relevant correlations. Their work
diﬀers from our work in that their work is applicable only to separable data ﬂow problems , while
our work is applicable to any data ﬂow problem that can be solved using MFP computation.

Chen et al. [5] proposed an algorithm for detecting infeasible paths by incorporating the
branch correlations analysis into the data ﬂow analysis technique. Next, the detected infeasible
paths are then used to improve the precision of structural testing by ignoring infeasible paths.

Hampapuram et al. [15] performed a symbolic path simulation approach in which they exe-
cuted each path symbolically and propagated the information along these paths. If a path is found
infeasible in simulation its information is not propagated. A lightweight decision procedure is
used to check the feasibility of a path during path simulation.

Dillig et al. [17] proposed a selective path sensitive analysis for modular programs. In this,
they ignored the unobservable variables that are the variables representing the results of unknown
functions (functions unavailable for analysis); hidden system states (e.g., the garbage collector’s
free list, operating system’s process queue, etc.), or imprecision in the analysis (e.g., selecting
an unknown element of an array). In particular, they observed that unobservable variables are
useful within their natural scope, for example, tests on unobservable variables can possibly be
proven mutually exclusive (e.g., testing whether the result of a malloc call is null, and then testing
whether it is non-null). However, outside of their natural scope unobservable variables provide
no additional information and can be eliminated. Ignoring unobservable variables allowed them
to reduce the number of distinctions that needs to be maintained in the path sensitive analysis,
for example, they did not distinguish between paths that diﬀer only in the values of unobservable
variables. They have applied their work for proving a ﬁxed set of program properties. In that,
they eliminate the eﬀect of infeasible paths while proving the properties because the analysis
is path sensitive. However, they detect infeasible paths separately for each diﬀerent data ﬂow
analysis on the same underlying program, which does not happen in our approach.

Xie et al. [16] focused on memory access errors (like array index out of bounds and null
pointer dereferences) because they may lead to non-deterministic and elusive crashes. They
proposed a demand-driven path sensitive inter-procedural analysis to bound the values of both
variables and memory sizes. For achieving eﬃciency, they restrict the computation to only those
variables and memory sizes that directly or indirectly aﬀect the memory accesses of interest.
They use the following observation about C programs: most of the times memory sizes are
passed as parameters to functions, along with the pointers to corresponding memory addresses;
further, these sizes are used in conditions that guard the memory accesses. Hence, by tracking the
actual values of the memory sizes the corresponding memory accesses can be evaluated as safe
or unsafe. Xie et al. were able to detect many memory access errors in real code sets using this
method. Moreover, they could eliminate the eﬀect of some of the infeasible paths that reach the
memory accesses of interest because they used a path sensitive analysis. Their work diﬀers from
42

our work on two fronts: ﬁrst, they do a demand driven analysis while our work is exhaustive;
second in their work the infeasible paths are detected on the ﬂy during a data ﬂow analysis, so the
same path may be detected multiple times for the same underlying program, while in our work
infeasible paths are detected only once for a program.

Das et al. [13] proposed a property speciﬁc path sensitive analysis. In this at ﬁrst, a set of
program properties of interest are identiﬁed. Next, a partial path sensitive analysis is performed
where two paths are separated iﬀ they contain diﬀerent values for the variables related to proper-
ties of interest.

On somewhat similar lines, Dhurjati et al. [13] proposed an iterative reﬁnement based ap-
proach to path sensitive data ﬂow analysis. Here, at ﬁrst, a path insensitive analysis is performed.
Next, if the analysis is not able to prove the properties of interest then the analysis results are used
to compute a set of predicates that are related to the property of interest . In the next iteration of
the analysis, these predicates are used to diﬀerentiate paths along which predicate evaluation is
diﬀerent. If this partially path sensitive analysis proves the properties of interest then the analy-
sis is terminated, else the analysis is repeated with a diﬀerent set of predicates discovered in the
recent iteration of the analysis. Thus, the analysis continues in multiple iterations.

Infeasible control ﬂow paths is a property of programs instead of any particular data ﬂow
analysis. We use this observation to ﬁrst detect infeasible paths in programs and propose an
approach to improve the precision of any data ﬂow analysis over the programs, unlike above
approaches that remove the impact of infeasible paths from a particular data ﬂow analysis.

8.3. Analysis Independent Approaches

We now describe approaches that eliminate eﬀect of infeasible paths from data ﬂow analysis
in analysis independent way. In particular, these approaches do not depend on analysis speciﬁc
heuristics, and they identify infeasible paths only once for a program. These approaches are clas-
siﬁed into two categories depending on whether they use CFG restructuring or not, as explained
below.

8.3.1. Approaches that Use CFG Restructuring

Bodik et al. [3] proposed an inter-procedural version of infeasible path detection and its ap-
plication to improve the data ﬂow precision. However, they use control ﬂow graph restructuring
which is not done in our approach. CFG restructuring may blow up the size of the CFG. More-
over, it does not take the advantage of analysis speciﬁc information, unlike FPMFP that uses
analysis speciﬁc information to dynamically discard the distinctions between MIPS, where they
do not lead to precision improvement as described in Optimization 2 (Section 6.2).

Balakrishna et al. [37] presented a technique for detecting infeasible paths in programs using
abstract interpretation. The technique uses a sequence of path-insensitive forward and backward
runs of an abstract interpreter to infer paths in the control ﬂow graph that cannot be exercised
in concrete executions of the program. Next, they reﬁned program CFG by removing detected
infeasible paths in successive iterations of a property veriﬁcation.

Marashdih et al. [38] proposed a CFG restructuring approach to eliminate infeasible paths
for PHP programs. In particular, they proposed a methodology for the detection of XSS (Cross
Site Scripting) from the PHP web application using static analysis. The methodology eliminates
the infeasible paths from the CFG thereby reducing the false positive rate in the outcomes. On
similar lines, we have found reduction in false positives in possibly uninitialized variable alarms
but without using CFG restructuring.

43

8.3.2. Our Approach

We used the work done by Bodik et al. [2] for detecting infeasible paths from the CFG of a
program. Next, we automatically lift any data ﬂow analysis to an analysis that separates the data
ﬂow values reaching along known infeasible CFPs from the values that do not reach along the
infeasible CFPs. This allows us to block the data ﬂow values that reach along infeasible CFPs
at a program point, thereby eliminating the eﬀect of detected infeasible paths from data ﬂow
analyses without using CFG restructuring and in a generic manner.

8.4. Approaches that Avoid Imprecise Joins

In this section, we discuss approaches that improve data ﬂow precision by avoiding imprecise
joins i.e., the merging of information at the nodes that are shared by two or more paths, and that
may lead to loss of precision.

8.5. Approaches that Use Trace Partitioning

In abstract interpretation, the trace partitioning approaches [39, 40, 24] partition program
traces where values of some variable or conditional expression diﬀer in two selected traces. The
variables or expressions are selected based on the alarms to be analyzed or some heuristic.

Mauborgne et al. [24] used trace partitioning to delay the merging of information at join
points in CFG where the join points lead to decrease in precision. They separate sets of traces
before the join points and merge traces after the join points. The separation and merge points for
traces are speciﬁed as input to the program in the form of pre-processing directives. Handjieva
et al. [39] proposed a restricted version of trace partitioning where merging of parts in partitions
was not allowed (Unlike Mauborgne et al.’s work).

The trace partitioning is similar to our approach because it keeps data ﬂow values separately
for each part (representing a set of traces) in partition. However, our approach does not rely
on alarms, does not need the designer of an analysis to decide a suitable heuristic, and is not
restricted to a particular analysis. We lift partitioning from within an analysis to the infeasibility
of control ﬂow paths which is a fundamental property of control ﬂow paths independent of an
analysis. This allows us to devise an automatic approach to implement a practical trace parti-
tioning. An interesting aspect of our approach is that although it is oblivious to any analysis, it
can be seen as dynamic partitioning that uses infeasibility of control ﬂow paths as criteria for
partitioning.

8.6. Approaches that Use CFG Restructuring

CFG restructuring has also been used to avoid imprecise joins. In particular, Aditya et al. [36]
proposed an approach in which at ﬁrst they identify join points that lead to loss of precision in
data ﬂow analysis. Next, they improve the data ﬂow precision by eliminating these join points
from control ﬂow graph through control ﬂow graph restructuring.

Ammon et al. [41, 42] proposed a CFG restructuring for avoiding information merging along
hot paths i.e., the paths that are more frequently executed in program compared to other paths.
They showed that this improves precision of various data ﬂow analysis and increases the oppor-
tunities of program optimizations. Their work diﬀers from our work in that they did not address
the imprecision added by infeasible control ﬂow paths.

44

9. Conclusions and Future Work

An exhaustive data ﬂow analysis answers all queries of a particular type over all possible
executions of a program. However, in practice it is hard to see an exhaustive analysis that is
eﬃcient and computes a precise result, because of the following issues that often have conﬂicting
solutions.

• Issue 1: to achieve eﬃciency, the analysis may need to merge the information reaching at
a program point along diﬀerent paths, because the number of paths as well as the corre-
sponding data ﬂow information may be very large or even unbounded.

• Issue 2: to achieve precision, the analysis may need to distinguish between the information
reaching from diﬀerent paths, in order to 1) discard the information reaching along infea-
sible paths, and 2) avoid potential loss of information because of merging that happens at
join points of two or more paths.

These issues have been handled in past as follows: the ﬁrst issue is handled by merging
the information reaching along diﬀerent paths at their shared path segments in a CFG (instead
of keeping the information separate). The approach achieves eﬃciency because it reduces the
amount of information computed. However, the computed information is usually weaker than
the actual possible information because of the information merging, and inclusion of information
reaching along infeasible paths.

To handle the second issue, two types of approaches have been proposed.

1. The ﬁrst type of approaches eliminate the eﬀect of infeasible paths from analysis in anal-
ysis dependent or analysis independent way. In particular, analysis dependent approaches
use selective path sensitive analysis that uses heuristics to selectively distinguish informa-
tion reaching along some paths, and subsequently discard the information along infeasible
paths thereby eliminating eﬀect of infeasible paths from the speciﬁc analysis. On the other
hand, analysis independent approaches use CFG restructuring to eliminate infeasible paths
from CFG itself thereby eliminating the eﬀect of infeasible paths from all analyses per-
formed on restructured CFG.

2. The second type of approaches eliminate the eﬀect of imprecise joins by using either CFG
restructuring or trace partitioning. More speciﬁcally, in CFG restructuring they eliminate
known imprecise joins points from CFG. On the other hand, in trace partitioning they cre-
ate equivalence classes of program traces using user speciﬁed criteria. Next, at imprecise
join points, only the information corresponding to traces in same class are merged, and
information from traces belonging to diﬀerent classes is kept separate. Thus, they reduce
the eﬀect of imprecise joins to some extent. Both the approaches of removing imprecise
joins rely on analysis speciﬁc heuristics because imprecise joins are analysis speciﬁc.

In this work, we proposed a generic approach to remove the eﬀect of infeasible paths from
exhaustive data ﬂow analyses.
In particular, we introduced the notion of feasible path MFP
solutions that separate and discard the data ﬂow values reaching along infeasible paths. A key
insight that enabled FPMFP is the following.

Infeasible paths is a property of programs and not of any particular data ﬂow analysis
over the programs. Hence, we can separate the identiﬁcation of infeasible paths in
the CFG of a program from discarding the corresponding data ﬂow values during a
data ﬂow analysis.

45

The above insight allows us to devise a generic technique that intuitively lifts a data ﬂow
analysis to multiple parallel and interacting data ﬂow analyses each of which eliminates the
eﬀect of a class of known infeasible paths. In particular, this is realized in FPMFP through a two
phase approach: in the ﬁrst phase, we detect minimal infeasible path segments from the input
program. In the second phase, we lift the input data ﬂow analysis so as to separate the values that
ﬂow through a MIPS from the values that do not ﬂow through the MIPS. Further, the analysis
blocks the values that ﬂow through the MIPS at the end of the MIPS thereby eliminating the
eﬀect of infeasible paths from data ﬂow analysis.

In our experiments on 30 Benchmarks (selected from Open Source, Industry, and SPEC CPU
2006), we compared precision and performance of FPMFP solutions with that of MFP solutions.
Here, we observed up to 13.6% (average 2.87%, geo. mean 1.75%) reduction in the number of
def-use pairs in the reaching deﬁnitions analysis, and up to 100% (average 18.5%, geo. mean
3%) reduction in the number of alarms in the possibly-uninitialized variables analysis, when
using FPMFP solution in place of MFP solution. Further, the FPMFP computation took 2.9×
more time compared to the MFP computation. In our experience, this cost-precision trade-oﬀ
is acceptable considering the corresponding reduction in the manual eﬀorts. Speciﬁcally, in
program testing testcases need to be written to ensure each def-use pair is covered by at least
one testcase. Similarly, for validating the possibly- uninitialized variable alarms requires manual
eﬀorts and is error prone.

In future, we see that the FPMFP solutions can be further improved both in terms of scal-
ability and precision. First, the scalability can be improved by identifying more optimizations
that can discard the pairs that do not lead to precision improvement. Second, the precision can
be improved by adding handling for wider class of inter-procedural MIPS. However, this should
be complemented by corresponding optimizations to keep the distinctions to bare minimum to
retain the eﬃciency of the approach.

Moreover, we see a possibility that the precision gain and scalability of FPMFP on a program
can be anticipated using a lightweight pre-analysis of the program. This can help decide whether
to apply FPMFP to the program or not. Similar approaches have been proved helpful in earlier
attempts of precise and scalable context sensitive program analyses [43, 44, 45, 46]. We believe
this will help for FPMFP also.

References

[1] U. Khedker, A. Sanyal, B. Sathe, Data ﬂow analysis: theory and practice, CRC Press, 2009.
[2] R. Bodik, R. Gupta, M. L. Soﬀa, Reﬁning data ﬂow information using infeasible paths, in: Software Engineer-

ing—ESEC/FSE’97, Springer, 1997, pp. 361–377.

[3] R. Bodik, R. Gupta, M. L. Soﬀa, Interprocedural conditional branch elimination, in: ACM SIGPLAN Notices,

Vol. 32, ACM, 1997, pp. 146–158.

[4] M. N. Ngo, H. B. K. Tan, Detecting large number of infeasible paths through recognizing their patterns, in: Pro-
ceedings of the the 6th joint meeting of the European software engineering conference and the ACM SIGSOFT
symposium on The foundations of software engineering, ACM, 2007, pp. 215–224.

[5] C. Rui, Infeasible path identiﬁcation and its application in structural test, Ph.D. thesis, Beijing: Institute of Com-

puting Technology of Chinese Academy of Sciences (2006).

[6] M. Delahaye, B. Botella, A. Gotlieb, Explanation-based generalization of infeasible path, in: 2010 Third Interna-

tional Conference on Software Testing, Veriﬁcation and Validation, IEEE, 2010, pp. 215–224.

[7] P. M. S. Bueno, M. Jino, Identiﬁcation of potentially infeasible program paths by monitoring the search for test data,
in: Automated Software Engineering, 2000. Proceedings ASE 2000. The Fifteenth IEEE International Conference
on, IEEE, 2000, pp. 209–218.

[8] X. Zhuang, T. Zhang, S. Pande, Using branch correlation to identify infeasible paths for anomaly detection, in: Pro-
ceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture, IEEE Computer Society,
2006, pp. 113–122.

46

[9] R. Yang, Z. Chen, B. Xu, W. E. Wong, J. Zhang, Improve the eﬀectiveness of test case generation on efsm via au-
tomatic path feasibility analysis, in: High-Assurance Systems Engineering (HASE), 2011 IEEE 13th International
Symposium on, IEEE, 2011, pp. 17–24.

[10] A. Bertolino, M. Marr´e, Automatic generation of path covers based on the control ﬂow analysis of computer

programs, IEEE Transactions on Software Engineering 20 (12) (1994) 885–899.

[11] T. Chen, T. Mitra, A. Roychoudhury, V. Suhendra, Exploiting branch constraints without exhaustive path enu-
meration, in: OASIcs-OpenAccess Series in Informatics, Vol. 1, Schloss Dagstuhl-Leibniz-Zentrum fr Informatik,
2007.

[12] N. Malevris, D. Yates, A. Veevers, Predictive metric for likely feasibility of program paths, Information and Soft-

ware Technology 32 (2) (1990) 115–118.

[13] M. Das, S. Lerner, M. Seigle, Esp: Path-sensitive program veriﬁcation in polynomial time, in: ACM Sigplan

Notices, Vol. 37, ACM, 2002, pp. 57–68.

[14] D. Dhurjati, M. Das, Y. Yang, Path-sensitive dataﬂow analysis with iterative reﬁnement, in: International Static

Analysis Symposium, Springer, 2006, pp. 425–442.

[15] H. Hampapuram, Y. Yang, M. Das, Symbolic path simulation in path-sensitive dataﬂow analysis, in: ACM SIG-

SOFT Software Engineering Notes, Vol. 31, ACM, 2005, pp. 52–58.

[16] Y. Xie, A. Chou, D. Engler, Archer: using symbolic, path-sensitive analysis to detect memory access errors, ACM

SIGSOFT Software Engineering Notes 28 (5) (2003) 327–336.

[17] I. Dillig, T. Dillig, A. Aiken, Sound, complete and scalable path-sensitive analysis, in: ACM SIGPLAN Notices,

Vol. 43, ACM, 2008, pp. 270–280.

[18] N. Dor, S. Adams, M. Das, Z. Yang, Software validation via scalable path-sensitive value ﬂow analysis, in: ACM

SIGSOFT Software Engineering Notes, Vol. 29, ACM, 2004, pp. 12–22.

[19] K. Pathade, U. P. Khedker, Computing partially path-sensitive mfp solutions in data ﬂow analyses, in: Proceedings

of the 27th International Conference on Compiler Construction, ACM, 2018, pp. 37–47.

[20] K. Pathade, U. P. Khedker, Path sensitive mfp solutions in presence of intersecting infeasible control ﬂow path
segments, in: Proceedings of the 28th International Conference on Compiler Construction, 2019, pp. 159–169.
[21] M. Sharir, A. Pnueli, et al., Two approaches to interprocedural data ﬂow analysis, New York University. Courant

Institute of Mathematical Sciences . . . , 1978.

[22] Tcs embedded code analyzer (2017).

URL https://www.tcs.com/product-engineering/tcs-embedded-code-analyzer

[23] S. Blackshear, N. Gorogiannis, P. W. O’Hearn, I. Sergey, Racerd: compositional static race detection, Proceedings

of the ACM on Programming Languages 2 (OOPSLA) (2018) 1–28.

[24] L. Mauborgne, X. Rival, Trace partitioning in abstract interpretation based static analyzers, in: European Sympo-

sium on Programming, Springer, 2005, pp. 5–20.

[25] W. Lee, W. Lee, K. Yi, Sound non-statistical clustering of static analysis alarms, in: International Workshop on

Veriﬁcation, Model Checking, and Abstract Interpretation, Springer, 2012, pp. 299–314.

[26] T. Muske, R. Talluri, A. Serebrenik, Repositioning of static analysis alarms, in: Proceedings of the 27th ACM

SIGSOFT international symposium on software testing and analysis, 2018, pp. 187–197.

[27] D. Zhang, D. Jin, Y. Gong, H. Zhang, Diagnosis-oriented alarm correlations, in: 2013 20th Asia-Paciﬁc Software

Engineering Conference (APSEC), Vol. 1, IEEE, 2013, pp. 172–179.

[28] A. V. Aho, Compilers: principles, techniques and tools (for Anna University), 2/e, Pearson Education India, 2003.
[29] H. Zhu, D. Jin, Y. Gong, Y. Xing, M. Zhou, Detecting interprocedural infeasible paths based on unsatisﬁable path

constraint patterns, IEEE Access 7 (2019) 15040–15055.

[30] D. Hedley, M. A. Hennell, The causes and eﬀects of infeasible paths in computer programs, in: Proceedings of the

8th international conference on Software engineering, IEEE Computer Society Press, 1985, pp. 259–266.

[31] E. W. S. Lee, Infeasible path detection and code pattern mining (2019).
[32] S. Jiang, H. Wang, Y. Zhang, M. Xue, J. Qian, M. Zhang, An approach for detecting infeasible paths based on a

smt solver, IEEE Access 7 (2019) 69058–69069.

[33] H. Gong, Y. Zhang, Y. Xing, W. Jia, Detecting interprocedural infeasible paths via symbolic propagation and
dataﬂow analysis, in: 2019 IEEE 10th International Conference on Software Engineering and Service Science
(ICSESS), IEEE, 2019, pp. 282–285.

[34] T. Sewell, F. Kam, G. Heiser, Complete, high-assurance determination of loop bounds and infeasible paths for wcet
analysis, in: 2016 IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS), IEEE, 2016,
pp. 1–11.

[35] F. Zeng, W. Liu, X. Gou, Type analysis and automatic static detection of infeasible paths, in: International Confer-

ence on Geo-Spatial Knowledge and Intelligence, Springer, 2017, pp. 294–304.

[36] A. Thakur, R. Govindarajan, Comprehensive path-sensitive data-ﬂow analysis, in: Proceedings of the 6th annual

IEEE/ACM international symposium on Code generation and optimization, ACM, 2008, pp. 55–63.

[37] G. Balakrishnan, S. Sankaranarayanan, F. Ivanˇci´c, O. Wei, A. Gupta, Slr: Path-sensitive analysis through infeasible-
47

path detection and syntactic language reﬁnement, in: International Static Analysis Symposium, Springer, 2008, pp.
238–254.

[38] A. W. Marashdih, Z. F. Zaaba, H. K. Omer, Web security: detection of cross site scripting in php web application
using genetic algorithm, International Journal of Advanced Computer Science and Applications (IJACSA) 8 (5)
(2017).

[39] M. Handjieva, S. Tzolovski, Reﬁning static analyses by trace-based partitioning using control ﬂow, in: SAS,

Vol. 98, Springer, 1998, pp. 200–214.

[40] L. H. Holley, B. K. Rosen, Qualiﬁed data ﬂow problems, IEEE Transactions on Software Engineering (1) (1981)

60–78.

[41] G. Ammons, J. R. Larus, Improving data-ﬂow analysis with path proﬁles, in: Proceedings of the ACM SIGPLAN

1998 conference on Programming language design and implementation, 1998, pp. 72–84.

[42] G. Ammons, J. R. Larus, Improving data-ﬂow analysis with path proﬁles, ACM SIGPLAN Notices 39 (4) (2004)

568–582.

[43] H. Oh, W. Lee, K. Heo, H. Yang, K. Yi, Selective context-sensitivity guided by impact pre-analysis, ACM SIG-

PLAN Notices 49 (6) (2014) 475–484.

[44] H. Oh, W. Lee, K. Heo, H. Yang, K. Yi, Selective x-sensitive analysis guided by impact pre-analysis, ACM Trans-

actions on Programming Languages and Systems (TOPLAS) 38 (2) (2015) 1–45.

[45] S. Wei, B. G. Ryder, Adaptive context-sensitive analysis for javascript, in: 29th European Conference on Object-

Oriented Programming (ECOOP 2015), Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2015.

[46] B. Hassanshahi, R. K. Ramesh, P. Krishnan, B. Scholz, Y. Lu, An eﬃcient tunable selective points-to analysis for
large codebases, in: Proceedings of the 6th ACM SIGPLAN International Workshop on State Of the Art in Program
Analysis, 2017, pp. 13–18.

10. Proof of Soundness:

In this section, we formally deﬁne the meet over feasible paths (MOFP) solution, and prove
that FPMFP computes an sound-approximation of MOFP solution. At ﬁrst, we state some auxil-
iary deﬁnitions which are useful for the proof of soundness.

10.1. Deﬁnitions
Deﬁnition 4. For an edge e : m → n, we refer the data ﬂow value ge(Outm) obtained by applying
the edge ﬂow function ge to the data ﬂow value Outm as “the data ﬂow value at e”.

Deﬁnition 5. Recall that all CFPs referred in our analysis are intra-procedural. We refer CFPs
that begin at start node of a CFG and end at a particular node n as “CFPs that reach n”.

Let U be the set of all MIPS that are input to a FPMFP computation, then we create the

following classes of CFPs that reach a node n; these CFPs are illustrated in Figure 18.

• paths(n): All CFPs that reach node n. This includes feasible as well as infeasible CFPs

that reach n.

• mpaths(n): All CFPs that reach node n and also contain atleast one MIPS of U (mpaths(n)
is a subset of paths(n)). All CFPs in mpaths(n) are infeasible CFPs because they contain a
MIPS.

• mpathsc(n): All CFPs that reach node n and do not contain any MIPS of U. This represents

a set complement of mpaths(n) i.e., mpathsc(n) = paths(n) − mpaths(n).

• fpaths(n): All CFPs that reach node n and are feasible. fpaths(n) is a subset of mpathsc(n).

48

paths(n)
mpathsc(n)

fpaths(n)

Figure 18: Paths that reach node n: paths(n) ⊇ mpathsc(n) ⊇ fpaths(n)

Deﬁnition 6. We refer CFPs that begin at start node of a CFG and end at a particular edge e as
“CFPs that reach e”. These are the same CFPs that reach the destination node of e and have e as
the last edge.

We create the following classes of CFPs that reach an edge e namely paths(e), mpaths(e),
mpathsc(e), fpaths(e). These classes are deﬁned similar to the corresponding classes of CFPs
that reach a node n. Also, if n is the destination node of an edge e then the following holds.

paths(e) ⊆ paths(n)
mpaths(e) ⊆ mpaths(n)
mpathsc(e) ⊆ mpathsc(n)
fpaths(e) ⊆ fpaths(n)

We deﬁned the notion of contains-preﬁx-of for a MIPS in deﬁnition 1, we now extend this to
CFPs as follows.

Deﬁnition 7. For a CFP σ that reaches an edge e, cpoe(σ) contains all MIPS µ such that preﬁx(µ, e)
is contained in σ i.e.,

cpoe(σ) = {µ | µ ∈ U, σ contains preﬁx(µ, e)}

(37)

Observation 10.1. Let σ.e′ be a path obtained by extending a path σ that reaches an edge e to
its successor edge e′. Then cpoe′(σ.e′) precisely contains two types of MIPS: 1) MIPS present
in cpoe(σ) which contain edge e′, and 2) MIPS that start at e′ i.e.,

cpoe′(σ.e′) =

Given σ ∈ mpathsc(e) ∧ e is predecessor edge of e′ then
µ | (µ ∈ cpoe(σ), e′ ∈ edges(µ)) ∨ e′ ∈ start(µ)
(cid:8)
. . . from 2

= ext(cpoe(σ), e′)

(cid:9)

(38)

(39)

We now formally state the meet over feasible paths (MOFP) solution. Next, we prove that

the FPMFP solution is an sound-approximation of MOFP solution.

10.2. The MOFP solution

Given a path σ ∈ paths(nk) consisting of nodes (n1, n2, ..., nk−1, nk), let fσ denote the com-
fσ =

position of functions corresponding to the nodes in σ excluding the last node nk i.e.,

49

fnk−1 ◦ fnk−2 ◦ . . . ◦ fn1. Note that fσ represents the eﬀect of a path that reaches at IN of node
nk, hence it excludes fnk . However, fσ includes the eﬀect of all edges in σ including the edge
from nk−1 to nk. For simplicity, we assume the edge ﬂow functions of the input MFP analysis
are identity functions for all edges. Observe that if σ contains a single node then fσ is identity
function.

The MOP solution is represented by variables Inn/Outn for all nodes n using the following

equation.

Inn = l

fσ(BI)

σ∈paths(n)

Outn = l

fn ◦ fσ(BI)

σ∈paths(n)

(40)

(41)

Similarly, the MOFP solution is obtained by taking meet over feasible paths that reach n (i.e.,

fpaths(n)) as follows.

Inn = l

fσ(BI)

σ∈fpaths(n)

Outn = l

fn ◦ fσ(BI)

σ∈fpaths(n)

(42)

(43)

10.3. Soundness Claim
Theorem 10.1. The FPMFP solution is a sound-approximation of the MOFP solution i.e., if N
is the set of all nodes in the CFG of a procedure then

Claim 1.

∀n ∈ N. Inn ⊑ l

fσ(BI)

(44)

σ∈fpaths(n)

Proof. The proof outline is illustrated in Figure 19. Below, we state Claim 2 and Claim 3 which
together prove Claim 1 i.e.,

Claim 2 ∧ Claim 3 =⇒ Claim 1

(45)

where,

• Claim 2: at any node n, Inn is a sound-approximation of the meet of data ﬂow values

reaching along paths in mpathsc(n) i.e.,

Claim 2.

∀n ∈ N. Inn ⊑ l

fσ(BI)

(46)

σ∈mpathsc(n)

• Claim 3: at any node n, the meet of data ﬂow values reaching along paths in mpathsc(n) is

a sound-approximation of the data ﬂow values reaching along paths in fpaths(n) i.e.,

Claim 3.

∀n ∈ N.

l
σ∈mpathsc(n)

(cid:0)

fσ(BI)
(cid:1)

⊑

l
σ∈fpaths(n)

(cid:0)

fσ(BI)
(cid:1)

(47)

50

Claim 1
(Theorem 10.1)

Claim 2
(Lemma 10.1)

Claim 3
(Lemma 10.2)

Claim 4
(Lemma 10.3)

Figure 19: Proof Outline. The claim at the root of the tree (claim 1) is the main proof obligation for soundness of FPMFP.
A claim at each node is derived using the claims at its child nodes.

Claim 2 and Claim 3 together imply Claim 1 by transitivity of ⊑. We prove the Claim 2 and

the Claim 3 in Lemma 10.1 and Lemma 10.2 respectively.

We ﬁrst state Claim 4 that will be used to prove Claim 2.
In the FPMFP computation, the data ﬂow value in each pair hM, di at an edge e : m → n
is a sound-approximation of the meet of the data ﬂow values reaching along each path σ where
σ ∈ mpathsc(e) and cpoe(σ) = M i.e.,

✷

Claim 4.

hM, di ∈ ge(Outm) =⇒ d ⊑

(cid:0)

l
σ ∈ mpathsc(e),
cpoe(σ) = M

fσ(BI)
(cid:1)

(48)

We prove Claim 4 in Lemma 10.3. We now show that Claim 2 follows from Claim 4 because
for a node n that is not the Start node of the CFG, mpathsc(n) is obtained by union of mpathsc(e)
corresponding to each edge e that is incident on n.

Lemma 10.1. At any node n in the CFG of a program the following holds

Claim 2.

∀n ∈ N. Inn ⊑

l
σ∈mpathsc(n)

(cid:0)

fσ(BI)
(cid:1)

(49)

Proof. We split the proof of Claim 2 in the following two cases which are mutually exclusive

and exhaust all possibilities.

• Case 1: n is the Start node of the CFG. In this case, mpathsc(n) contains a single path

containing the Start node only. Hence the following holds.

l
σ∈mpathsc(n)

(cid:0)

fσ(BI)
(cid:1)

= BI

51

(50)

Inn = BI

Inn ⊑

l
σ∈mpathsc(n)

(cid:0)

fσ(BI)
(cid:1)

from 8

from 51, 50

(51)

(52)

• Case 2: n is not the Start node of the CFG. In this case, the following holds.

Inn =

—

l
m∈pred(n)

hM1, d1i ∈ Inn =⇒ d1 ⊑

hM1, d1i ∈ Inn =⇒ d1 ⊑

gm→n(Outm)

. . . from 8

(53)

(cid:0)

(cid:0)

hM1, d′

l

d′
1
1i ∈ gm→n(Outm),
m ∈ pred(n)

. . . from 12

(54)

(cid:1)

l
σ ∈ mpathsc(n),
cpoe(σ) = M1

fσ(BI)
(cid:1)

. . . from 10.3

(55)

l
hM1, d1i∈Inn

(cid:0)

d1

⊑

(cid:1)

Inn ⊑

(cid:0)

(cid:0)

l
σ∈mpathsc(n)

l
σ∈mpathsc(n)

fσ(BI)
(cid:1)

fσ(BI)
(cid:1)

Equations 52 and 57 prove the lemma.

Lemma 10.2. At any node n in the CFG of a program the following holds

Claim 3.

fσ(BI)
(cid:0)
(cid:1)
Proof. The following holds from the deﬁnition of mpathsc(n) and fpaths(n)

l
σ∈mpathsc(n)

fσ(BI)
(cid:1)

l
σ∈fpaths(n)

∀n ∈ N.

⊑

(cid:0)

∀n ∈ N.

fpaths(n) ⊆ mpathsc(n)

. . . from 5

Claim 3 trivially follows from 59.

(56)

(57)

✷

(58)

(59)

✷
The following observation states some properties of a path of length 1 starting at Start of a

CFG. These properties are used for proving claim 4 subsequently.

Observation 10.2. Let σ1 : n0
and U be the set of all MIPS in the procedure, then σ1 has the following properties.

e
−→ n1 be a path of length one that begins at Start of a procedure,

1. e does not have a predecessor edge. Hence, e cannot be end edge of any MIPS i.e.,

∀M ⊆ U. ¬endof (M, e)

52

(60)

2. cpoe(σ1) only contains MIPS that start at e i.e.,

cpoe(σ1) = {µ | µ ∈ U, e ∈ start(µ)}
∀M ⊆ U. ext(M, e) = {µ | µ ∈ U, e ∈ start(µ)}
∀M ⊆ U. ext(M, e) = cpoe(σ1)

. . . from 37
. . . from 37

(61)

(62)
(63)

from 61 and 63 we get

(M′ ⊆ U) ∧ (M′ , cpoe(σ1)) =⇒ (∀M ⊆ U. ext(M, e) , M′)

(64)

3. There exists only one path of length 1 that begins at Start

mpathsc

1(e) = {σ1}

l
σ∈mpathsc

1(e)

(cid:0)

fσ(BI)
(cid:1)

= fσ1 (BI)

. . . from 65

= fn0(BI)

. . . fσ1 = fn0

(65)

(66)

(67)

4. Since n0 is the Start node of the procedure, Inn0 is the boundary value.

Inn0 = BI =

∪

hM, ⊤i | M , {}, M ⊆ U

. . . from 8

(68)

h{}, BIi
(cid:9)
(cid:8)

(cid:8)

Applying node ﬂow function f n0 and using 11 we get

(cid:9)

f n0(Inn0) =

hM, fn0(⊤)i | M , {}, M ⊆ U
(cid:8)
from 9 we have Outn0 = f n0(Inn0) hence

h{}, fn0(BI)i
(cid:9)

∪

(cid:8)

(cid:9)

Outn0 =

h{}, fn0(BI)i
(cid:9)

(cid:8)

∪

hM, fn0(⊤)i | M , {}, M ⊆ U
(cid:8)

(cid:9)

(69)

(70)

Lemma 10.3. In the FPMFP computation, the data ﬂow value in each pair hM, di at an edge
e : m → n is a sound-approximation of the meet of data ﬂow values reaching along each path σ
where σ ∈ mpathsc(e) and cpoe(σ) = M i.e.,

Claim 4.

hM, di ∈ ge(Outm) =⇒ d ⊑

(cid:0)

l
σ ∈ mpathsc(e),
cpoe(σ) = M

fσ(BI)
(cid:1)

(71)

Proof.

We prove this by induction on the length of paths reaching from Start to the edge e. Let
l (e) denote the paths of length l from mpathsc(e) (edges may be repeated in the path).

mpathsc

We re-write the proof obligation in the following equivalent form.

∀l ≥ 1. hM, di ∈ ge(Outm) =⇒ d ⊑

l

(cid:0)

σ ∈ mpathsc
l (e),
cpoe(σ) = M

fσ(BI)
(cid:1)

(72)

Basis. l = 1 There exists only one path of length 1 that begins from Start node. Let that
e
−→ n1, where n0 = Start. Observe that e cannot be an inner or end edge of any

path be σ1 : n0

53

MIPS because e does not have a predecessor edge. Consequently, cpoe(σ1) only contains MIPS
that start at e. We have stated these properties in Observation 10.2.

Proof obligation for the base case (obtained by substituting l = 1 and m = n0 in 72):

hM′, d′i ∈ ge(Outn0) =⇒ d′ ⊑

l

fσ(BI)

(73)

σ ∈ mpathsc
1(e),
cpoe(σ) = M′

We split the proof of the base case in the following two cases which are mutually exclusive

and exhaustive for each pair hM′, d′i in ge(Outn0).
• Case 1: There exists a path σ ∈ mpathsc

contains a single path σ1, Case 1 becomes M′ = cpoe(σ1).

1(e) such that M′ = cpoe(σ). Since mpathsc

1(e)

(cid:0)

hM′, d′i ∈ ge(Outn0)
=⇒ d′ =

∧

M′ = cpoe(σ1)
(cid:1)
(cid:1)
d
l
hM, di ∈ Outn0,
ext(M, e) = M′

(cid:0)

=⇒ d′ =

d

l
hM, di ∈ Outn0,
ext(M, e) = cpoe(σ1)

=⇒ d′ = l

d

hM, di∈Outn0

=⇒ d′ = fn0(BI) ⊓ fn0(⊤)
=⇒ d′ = fn0(BI)
=⇒ d′ =

l

fσ(BI)

from 15, 60

(74)

M′ = cpoe(σ1)

(75)

from 63

(76)

from 70
fn0(BI) ⊑ fn0(⊤)

from 66 and 67

(77)
(78)

(79)

σ ∈ mpathsc

1(e)

=⇒ d′ =

l

fσ(BI)

from 65

(80)

σ ∈ mpathsc

1(e),

cpoe(σ) = cpoe(σ1)

=⇒ d′ =

l

fσ(BI)

M′ = cpoe(σ1)

(81)

σ ∈ mpathsc
1(e),
cpoe(σ) = M′

• Case 2: There does not exists a path σ ∈ mpathsc

1(e) such that M′ = cpoe(σ). Since

mpathsc

1(e) contains a single path σ1, Case 2 becomes M′ 6= cpoe(σ1).
M′ 6= cpoe(σ1)
hM′, d′i ∈ ge(Outn0)
(cid:0)
(cid:0)
=⇒ d′ =

∧

(cid:1)

from 15, 60

(82)

(cid:1)
d
l
hM, di ∈ Outn0,
ext(M, e) = M′

=⇒ d′ = ⊤

from 64

(83)

54

=⇒ d′ = l
σ∈{}

fσ(BI)

Since {σ | σ ∈ mpathsc

1(e), cpoe(σ) 6= cpoe(σ1)} = Φ

=⇒ d′ =

l

fσ(BI)

σ ∈ mpathsc
1(e),
cpoe(σ) = M′

= ⊤

l
{}

from 65

from 65

(84)

(85)

(86)

From Case 1 and 2, we get equation 73

Induction Hypothesis. Let n be any arbitrary node in the CFG of a program such that there
exist a CFP of length l − 1 reaching n, and n has atleast one outgoing edge. We assume that
e′
Lemma 10.3 holds at each edge e′ that is incident on n (of the form m
−→ n) and is the last edge
of the path of length l − 1 reaching n i.e.,

hM, di ∈ ge′(Outm) =⇒ d ⊑

l

fσ(BI)

(87)

σ ∈ mpathsc

l−1(e′),

cpoe′ (σ) = M

Inductive Step. We prove that Lemma 10.3 holds for any successor edge of e′ w.r.t. paths of

length l i.e., if m

e′
−→ n

e′′
−−→ o then

hM′′, d′′i ∈ ge′′ (Outn) =⇒ d′′ ⊑

l

fσ(BI)

(88)

σ ∈ mpathsc
l (e′′),
cpoe′′ (σ) = M

Proof of the inductive step. We build the proof in two steps.

Let the function inEdges(n) return the set of incoming edges of a node n in the CFG, then in

step 1, we prove that the following holds at Outn.

hM, d′i ∈ Outn =⇒ d′ ⊑

l

fn ◦ fσ(BI)

(89)

σ ∈ mpathsc
l−1(e′),
e′ ∈ inEdges(n),
cpoe′ (σ) = M

In step 2, we prove that for any successor edge e′′ of e′, equation 88 holds.
Step 1:

Inn = l

gm→n(Outm)

. . . from 8

m∈pred(n)

hM, di ∈ Inn =⇒ d ⊑

d′

. . . from 90, 12

l
hM, d′i ∈ gm→n(Outm),
(m → n) ∈ inEdges(n)

hM, di ∈ Inn =⇒ d ⊑

l

fσ(BI)

. . . from 87

(90)

(91)

(92)

σ ∈ mpathsc
l−1(e′),
e′ ∈ inEdges(n),
cpoe′ (σ) = M
55

since fn is monotone

hM, di ∈ Inn =⇒ fn(d) ⊑

l

fn ◦ fσ(BI)

σ ∈ mpathsc
l−1(e′),
e′ ∈ inEdges(n),
cpoe′ (σ) = M
hM, d′i ∈ Outn =⇒ ∃hM, di ∈ Inn. fn(d) = d′
hM, d′i ∈ Outn =⇒ d′ ⊑

l

. . . from 9

fn ◦ fσ(BI)

. . . from 93, 94

σ ∈ mpathsc
l−1(e′),
e′ ∈ inEdges(n),
cpoe′ (σ) = M

Step 2: We now prove that at any successor edge e′′ : n → o of e′ the following holds:

hM′′, d′′i ∈ ge′′ (Outn) =⇒ d′′ ⊑

l

(cid:0)

σ ∈ mpathsc
l (e′′),
cpoe′′ (σ) = M′′

fσ(BI)
(cid:1)

(93)

(94)

(95)

(96)

We consider the following possibilities for any arbitrary pair hM′′, d′′i in ge′′ (Outn). These

cases are mutually exclusive and exhaustive.

• Case A: e′′ is end edge of some MIPS µ contained in M′′ i.e.,

endof (M′′, e′′)=true.
In this case, we prove that equation 96 holds because the following is true.

d′′ = ⊤

(97)

(98)

l

= ⊤

fσ(BI)
(cid:1)

(cid:0)

σ ∈ mpathsc
l (e′′),
cpoe′′ (σ) = M′′
d′′ = ⊤ follows from the deﬁnition of the edge ﬂow function (equation 15) i.e.,
hM′′, d′′i ∈ ge′′ (Outn) ∧ endof (M′′, e′′) =⇒ d′′ = ⊤ . . . from 15
Equation 98 follows from the fact that there cannot exist a path σ′ that satisﬁes the con-
straint σ′ ∈ mpathsc(e′′) ∧ endof (cpoe′′ (σ′), e′′) from the deﬁnition of mpathsc(e′′).
Hence the following holds,

(99)

l

(cid:0)

σ ∈ mpathsc
l (e′′),
cpoe′′ (σ) = M′′,
endof (M′′, e′′)

= ⊤

fσ(BI)
(cid:1)

From 99 and 100 we get

hM′′, d′′i ∈ ge′′(Outn) ∧ endof (M′′, e′′) =⇒ d′′ ⊑

56

(cid:0)

l

fσ(BI)
σ ∈ mpathsc
l (e′′),
(cid:1)
cpoe′′ (σ) = M′′

(100)

(101)

• Case B: e′′ is not end edge of any MIPS in M′′ i.e., endof (M′′, e′′)=false.

hM′′, d′′i ∈ ge′′ (Outn) ∧ ¬endof (M′′, e′′)
=⇒ d′′ =

d . . . from 15

l
hM, di ∈ Outn,
ext(M, e′′) = M′′

=⇒ d′′ ⊑

=⇒ d′′ ⊑

=⇒ d′′ ⊑

(cid:0)

(cid:0)

(cid:0)

fn ◦ fσ(BI)
(cid:1)

. . . from 95

fσ.e′′ (BI)
(cid:1)

. . . from 10.1

l

σ ∈ mpathsc
l−1(e′),
e′ ∈ inEdges(n),
cpoe′(σ) = M,
ext(M, e′′) = M′′

l

σ ∈ mpathsc
l−1(e′),
e′ ∈ inEdges(n),
cpoe′′ (σ.e′′) = M′′

l

σ ∈ mpathsc
l (e′′),
cpoe′′ (σ) = M′′

fσ(BI)
(cid:1)

From case A and B, we get equation 88.

(102)

✷

10.4. Soundness of the optimizations of scalability

In this section, we prove that the optimizations proposed in Section 6 retain the soundness
and precision of the computed FPMFP solution. Optimization 1 and Optimization 2 are proved
in sections 10.4.1 and 10.4.2 respectively.

10.4.1. Proof for Optimization 1

Optimization 1 is applied iﬀ the input MIPS satisfy the property P (Section 6.1) which is

restated as follows.

P: for a MIPS µ : e1 → e2 → . . . → en, if the condition on the end edge en is
cond(en) then cond(en) evaluates to false at the start edge e1 of µ and variables in
cond(en) are not modiﬁed along µ.

p

Formally, if

e represents the evaluation of a condition expression p at an edge e, and
K
modiﬁed(p, µ) is the set of variables in p that are modiﬁed at intermediate nodes of a MIPS µ
then

J

“µ is a MIPS” ⇐⇒

cond(en)
J

e1 = false) ∧ (modiﬁed(cond(en), µ) = φ)
K

(
(cid:0)

(cid:1)

(103)

57

We now prove that if two MIPS satisfy P10, and have the same end edge then they can be
considered equivalent. In particular, we prove that if two MIPS have the same end edge e, then
any CFP that extends from start edge of either MIPS till e by traversing edges in either MIPS is
an infeasible path. Hence, the data ﬂow values associated with such MIPS can be merged.

Theorem 10.2. If µ1, µ2 are two MIPS that have the same end edge en, and they intersect at some
node xk, then µ3, µ4—constructed as shown below using split and join of µ1, µ2 at the intersecting
node—are also MIPS.

µ1 :x1

µ2 :y1

ex1
−−→ x2 → . . . → xk → xk+1 → . . .
ey1
−−→ y2 → . . . → xk → y j → . . .

en−→ n

en−→ n

(104)

µ3 :x1

µ4 :y1

ex1
−−→ x2 → . . . → xk → y j → . . .
ey1
−−→ y2 → . . . → xk → xk+1 → . . .

en−→ n
en−→ n

Claim 5.

“µ1,µ2 are MIPS” =⇒ “µ3,µ4 are MIPS”

Proof.

We use the following fact to prove the claim 5: µ3 and µ4 are constructed using the edges and

the nodes from µ1 and µ2 so the following holds

(modiﬁed(cond(en), µ1) = φ) ∧ (modiﬁed(cond(en), µ2) = φ)
=⇒
(modiﬁed(cond(en), µ3) = φ) ∧ (modiﬁed(cond(en), µ4) = φ)

(105)

LHS : “µ1,µ2 are MIPS” =⇒ (

cond(en)
J

ex1 =
K
(modiﬁed(cond(en), µ1) = φ) ∧
(modiﬁed(cond(en), µ2) = φ)

cond(en)
J

ey1 = false) ∧
K

. . . from 103

=⇒ (

cond(en)
J

ex1 =
K
(modiﬁed(cond(en), µ3) = φ) ∧
(modiﬁed(cond(en), µ4) = φ)

cond(en)
J

ey1 = false) ∧
K

=⇒ “µ3,µ4 are MIPS”

. . . from 105

10.4.2. Proof of Optimization 2

At an edge, Optimization 2 (Section 6.2) merges pairs that contain the same data ﬂow value.
In this section, we prove that this optimization retains the precision and the soundness of the

10Note that we use algorithms given by Bodik et al for detecting MIPS which are presented in Appendix; they allow

us to track if a MIPS satisﬁes the property P or not.

58

FPMFP solution. A crucial diﬀerence between FPMFP and MFP is that in the FPMFP compu-
tation certain data ﬂow values are blocked at end edges of MIPS. We prove that the same set of
values are blocked at the same set of end edges with or without Optimization 2.

Theorem 10.3. If ge(Ine) contains two pairs hM1, di and hM2, di with the same data ﬂow value
d then shifting d to the pair corresponding to a set of MIPS M3 deﬁned below does not aﬀect
the soundness or precision of the resulting FPMFP solution. Speciﬁcally, it does not aﬀect the
blocking of d at the end edges of MIPS in M1 and M2.

M3 ={µ1 | µ1 ∈ M1, ∃µ2 ∈ M2. µ2 ∈ csoe(µ1)}

(106)

∪
{µ2 | µ2 ∈ M2, ∃µ1 ∈ M1. µ1 ∈ csoe(µ2)}

Proof. We consider the following two operations each indicating Optimization 2 is performed

or not. Next, we prove that the FPMFP solution is identical after both the operations:

1. Operation 1: pairs hM1, di and hM2, di are kept as it is in ge(Ine) (i.e., Optimization 2 is

not applied).

2. Operation 2: pairs hM1, di and hM2, di are replaced with hM3, di in ge(Ine) (i.e., Optimiza-
tion 2 is applied). For simplicity of exposition, we assume there is no value associated with
M3 initially, otherwise we add hM3, d′ ⊓ di where d′ is the value associated with M3 in
ge(Ine).

The possible cases for MIPS in M1 and M2 w.r.t. Operation 1 and 2 are shown in Table 12. Let
the data ﬂow value d is not killed along a MIPS µ1 in M1 (if it is killed then d does not reach
end(µ1) after either operation is performed). We prove that both the above operations achieve
similar eﬀect in the following two cases which are mutually exclusive and exhaustive for all
MIPS in M1 (similar argument holds for MIPS in M2):

1. Case 1: if µ1 ∈ M1 and µ1 ∈ M3, then d is blocked at end(µ1) after both the operations.

2. Case 2: if µ1 ∈ M1 and µ1 < M3, then d reaches end(µ1) after both the operations.

Proof of Case 1.
If µ1 ∈ M1 and µ1 ∈ M3, then d is blocked at end(µ1) after both the operations, as explained

below.

1. Operation 1: hM1, di,hM2, di are kept as it is in ge(Ine).

In this case, d is blocked within hM1, di at end(µ1) because µ1 ∈ M1. Also, d is blocked
within hM2, di because there exists a MIPS µ2 in M2 whose suﬃx is contained in µ1 i.e.,
(107)
(108)

µ1 ∈ M1 ∧ µ ∈ M3 =⇒ ∃µ2 ∈ M2.µ2 ∈ csoe(µ1)
µ2 ∈ M2 ∧ µ2 ∈ csoe(µ1) =⇒ end(µ2) ∈ edges(µ1) and

d is blocked within hM2, di at end(µ2)

(109)

Hence, in this scenario, d is blocked within both pairs before reaching end(µ1) or at
end(µ1).

59

s
e
s
a
C

1. µ ∈ M1, µ ∈ M3
2. µ ∈ M1, µ < M3
3. µ ∈ M2, µ ∈ M3
4. µ ∈ M2, µ < M3

is d blocked at the edge in end(µ) after
Operation 1
Yes
No
Yes
No

Operation 2
Yes
No
Yes
No

Table 12: Equivalence of Operation 1 and Operation 2 w.r.t. cases in Optimization 2. Optimization 2 involves shifting a
data ﬂow value d from pairs hM1, di and hM2, di to pair hM3, di. For simplicity, we assume d is not killed along µ.

2. Operation 2: hM1, ⊤i,hM2, ⊤i,hM3, di belong to ge(Ine) and µ1 ∈ M3.
In this case, d is blocked within hM3, di at end(µ1) because µ1 ∈ M3.

Proof of Case 2.
If µ1 ∈ M1 and µ1 < M3, then d reaches end(µ1) after both the operations.
1. Operation 1: hM1, di,hM2, di are kept in ge(Ine) as it is.

In this case, d is blocked within hM1, di at end(µ1). However, d in hM2, di is not blocked
at or before end(µ1) because µ1 does not contain suﬃx(µ2, e) for any MIPS µ2 in M2
(meaning µ2 either 1) does not follow the same CFP as µ1 after e, or 2) follows the same
CFP as µ1 but does not end before µ1 on the CFP). Thus, d in hM2, di reaches end(µ1)
along a CFP that goes through suﬃx(µ1, e).

2. Operation 2: hM1, ⊤i,hM2, ⊤i,hM3, di belong to ge(Ine).

In this case, µ1 does not contain suﬃx(µ3, e) for any MIPS µ3 in M3 i.e.,
µ1 ∈ M1 ∧ µ1 < M3 =⇒ ∀µ3 ∈ M3.µ3 < csoe(µ1)
This can be proved by proving that following is a contradiction.
µ1 ∈ M1 ∧ µ1 < M3 ∧ ∃µ3 ∈ M3.µ3 ∈ csoe(µ1)
=⇒ µ3 < M2
=⇒ µ3 ∈ M1 ∧ ∃µ2 ∈ M2.µ2 ∈ csoe(µ3)
=⇒ ∃µ2 ∈ M2.µ2 ∈ csoe(µ1)
=⇒ µ1 ∈ M3
=⇒ false

from 106

from 106
csoe(µ3) ⊆ csoe(µ1)
from 106

Hence d in hM3, di is not blocked at or before end(µ1). Thus, d in hM3, di reaches end(µ1)
along a CFP that goes through suﬃx(µ1, e).

Similar cases can be proved for MIPS in M2. Thus, the FPMFP solutions with or without
✷

Optimization 2 are equivalent.

11. Appendix: Bodik’s Approach for Detecting Minimal Infeasible Path Segments

In this section, we present the algorithms proposed by Bodik et al. [2] for detection of MIPS.
We have used these algorithms in the pre-processing stage of FPMFP computation to generate a
set of MIPS. The section is organized as follows. First, we give an overview of Bodik’s approach
of infeasible path detection (Section 11.1). Next, we describe the algorithms for detection of
infeasible paths in detail (Section 11.2).

60

11.1. Overview of Bodik’s Approach

Bodik et al. observed that many infeasible paths are caused by statically detectable correla-
tions between two branch conditions, or between a branch condition and an assignment statement
appearing on the paths. Hence, to ﬁnd infeasible paths arising from branch correlations, they use
the following criteria: if the constraint of a conditional edge evaluates to FALSE along any CFP
reaching the edge, then the CFP is infeasible.

In Figure 20a, the branch constraint (b > 1 = true) is in conﬂict with the
Example 1.
assignment statement b = 0, hence the path marked with double line arrows is infeasible.
Similarly, in Figure 20b the constraint (b > 1 = f alse) of the branch at bottom is in conﬂict
with constraint (b > 1 = true) of the branch at top. Hence the path marked with double line
arrows is infeasible.

Intuitively, the idea is to enumerate CFPs that reach a conditional edge and identify CFPs
along which the edge constraint evaluates to FALSE, because such CFPs are infeasible. In par-
ticular they proceed as follows. They start from a branch node, and backward propagate the
corresponding constraint (i.e., branch condition) along the incoming paths that reach the node.
Here, they evaluate the branch constraint using predeﬁned rules at nodes encountered in back-
ward propagation along a path. A path is labeled as infeasible if the assertions at a node and the
constraint have a conﬂict that is detectable using predeﬁned rules.

Example 2. For example in Figure 21, the branching node n7 : a > 1 is correlated with
node n1 in that the constraint a > 1 evaluates to FALSE at n1. Therefore, the following
e6−→
path σ that connects n1 to the TRUE branch of n7 is infeasible, σ : n1
e8−→ n8. Bodik’s approach detects this path by backward propagating the constraint
n6
(a > 1) from node n7 to n1 along σ.

e1−→ n2

e3−→ n5

e7−→ n7

61

b = 0

b = 0

b = 0

b > 1

b = 0

b > 1

false

true

b = 0

b = 0

b > 1

false

true

false

true

b = 0

b = 0

b = 0

b = 0

(a) Correlation between assignment
statement and branch statement.

(b) Correlation between two
branch statements.

Figure 20: Statically detectable correlations between program statements leading to infeasible paths.

62

Start[e1]= {qe8}

Inner[e1]= {}

End[e1]= {}

n1:int a=0,b=0

S T EP 1 →

A[e1, qe8] = {FALS E}

S T EP 2 →

e1

A[e1, qe9] = {T RUE}

Q[e1] = {qe8, qe9}

n2:nondet()

(true) e2

Q[e2] = {}

n3:b=3

e4

Q[e4] = {}

n4:scanf(“%d”,&a)

Start[e2]= {}

Inner[e2]= {}

End[e2]= {}

Start[e4]= {}

Inner[e4]= {}

End[e4]= {}

A[e5, qe8] = {UNDEF}

e5

A[e5, qe9] = {UNDEF}

Start[e5]= {}

Q[e5] = {qe8, qe9}

Inner[e5]= {}

End[e5]= {}

n5:printf(“%d”,b);

(false) e3

Start[e3]= {qe8}

Inner[e3]= {}

End[e3]= {}

Q[e3] = {qe8, qe9}

Q[e6] = {qe8, qe9}

e6

Q[e7] = {qe8, qe9}

n6:printf(“%d”,a);

e7

n7 : a > 1

Start[e6]= {}
Inner[e6]= {qe8}

End[e6]= {}

Start[e7]= {}
Inner[e7]= {qe8}

End[e7]= {}

Start[e9]= {}

Inner[e9]= {}

(true) e8

Q[e8] = {}
qe8: ((a > 1)==TRUE)

Start[e8]= {}

Inner[e8]= {}

End[e8]= {qe8}

End[e9]= {}

(false)e9

n8:assert(b!=0)

Q[e9] = {}

qe9: ((a > 1)==FALSE)

e10

Q[e10] = {}

Start[e10]= {}

Inner[e10]= {}

End[e10]= {}

n9:Exit

Figure 21: Example illustrating detection of MIPS using Bodik’s Approach

63

Algorithm 1 Step 1 to detect MIPS that end at a conditional edge e. Let the condition on e be
(v ≤ c) = x, where x is either {TRUE or FALSE}, and v ≤ c is the expression at the source node
of e. The comments are preﬁxed with //.

1: Initialize Q[e] to {} at each edge e; set worklist to {}.

//raise the initial query qe : ((v ≤ c) = x), at each immediate predecessor
//edge of e these are edges incident on source node of e, and
//are represented by predEdge(e)

2: For each em ∈ predEdge(e)
raiseQuery(em, qe)
3:
4: End For
5: While worklist not empty
6:

remove pair (e, q) from worklist
//assume unknown outcome of q at the entry edge
//(i.e., the outgoing edge of program entry).
If e is entry edge

A[e,q]:=UNDEF

Else

//answer q using assertions generated at source node of e.

answer := resolve(e, source(e), q)
If answer ∈ {T RUE, FALS E, UNDEF}

A[e, q] := answer

Else

For each em ∈ predEdge(e)

raiseQuery(em, q)

End For

7:
8:

9:
10:

11:

12:
13:

14:

15:
16:

End If

17:
End If
18:
19: End While

Procedure raiseQuery(Edge e, Query q)

20:

21:

22:
23:

If q < Q[e]

add q to Q[e]
add pair (e, q) to worklist

End If

64

Algorithm 2 Step 2: mark the edges with MIPS information

//begin analysis from the edges where any query was resolved to FALSE
//at lines 5 to 19 of Step1

1: worklist:={e | a query was resolved to FALSE at edge e}

//raise the initial query at the analyzed edge, to mark end of MIPS.

2: While worklist not empty
3:

remove an edge e from the worklist
//if query resolved to false at this edge then mark
//the edge as start for corresponding MIPS
For each query qex such that A[e, qex] = FALS E

add qex to S tart[e]
//mark e as start and ex as end edge for MIPS resulting from
//query qex resolving to FALSE at edge e.
add qex to End[ex]

End For
//determine answers for each query that was propagated backward
For each query q from Q[e] s.t. q was not resolved at e

//move the MIPS started along all predecessor edges of e
If (for all em ∈ predEdge(e), q ∈ S tart[em])

add q to S tart[e]
For each em ∈ predEdge(e)
remove q from S tart[em]

End For

Else

//make e as the inner edge of started MIPS

For each em ∈ predEdge(e)

copy S tart[em] to Inner[e]
copy Inner[em] to Inner[e]

End For

4:
5:

6:

7:

8:

9:

10:
11:

12:

13:
14:

15:

16:
17:

18:
19:

End If
End For
20:
21: End While

11.2. Detailed Explanation of Bodik’s Approach

The Bodik’s approach involves two steps as described below.

1. In the ﬁrst step, the constraints from branch nodes are propagated backwards (towards

CFG entry) to identify nodes (if any) at which these constraints evaluate to FALSE.

2. In the second step, a forward traversal of CFG is done to mark the infeasible paths using

data from Step 1.

We now explain each of these steps in detail below.

11.2.1. Step 1

The results of Step 1 for the example in Figure 21 are marked in blue. The details of Step 1

are given in Algorithm 1 and are described below.

At the beginning of Step 1, we raise a query qe at each conditional edge e such that the query

qe represents the constraint on e. Consequently e is visited in an execution only if qe is TRUE.

65

For example, the query for the edge e8 is qe8 : ((a > 1)=TRUE), and for
Example 1.
the edge e9 is qe9 : ((a > 1)=FALSE). This means the edge e8 (resp. e9) will be executed
only when qe8 (resp. qe9) evaluates to TRUE. Similarly, we raise queries qe2 and qe3 at
conditional edges e2 and e3 respectively.

Next, the query raised at an edge e is propagated along each predecessor edge of e say pe.
Here, we try to resolve the query at pe using the assertions generated at source of pe if the asser-
tions restrict the value of variables in the query, for example, because of assignment of values to
the variables, or branching out of a conditional expression that tests value of the variables. In the
former case, if there is an assignment to a variable present in the query then the query resolves
to either TRUE, FALSE, or UNDEF (meaning details are not suﬃcient to resolve the query to
TRUE or FALSE) 11.

In the latter case, if a variable present in the query is tested in a conditional at the source of pe
then the query may resolve to TRUE or FALSE or remain unresolved. If the query is unresolved
at pe then the query is back propagated to predecessors of pe and so on 12.

Example 2. For example, in Figure 21, we propagate queries qe8 and qe9 along edge e7,
since source node of e7 is a printf statement, none of the queries are resolved, and hence
they are back propagated to edge e6 and so on. Further, at the edge e5 both the queries qe8
and qe9 are resolved to UNDEF because of the statement scanf (“%d”,&a) at the source of
e5. Similarly, at the edge e1 the query qe8 evaluates to FALSE, and qe9 evaluates to TRUE
because of assignments at the source of e1.

At the end of Step 1 we have two arrays Q and A, where Q stores the queries raised or

backward propagated at an edge, and A stores queries resolution at an edge.

Recall that we deﬁned the query qex such that edge ex executes only if qex is TRUE. Conse-
quently, if in Step 1, a query qex is resolved to FALSE at the edge e, then this implies there is
an infeasible path segment from edge e to the edge ex. For example in Figure 21 at edge e1 the
query qe8 : ((a > 1)=TRUE) evaluates to FALSE, hence there is an infeasible path (marked by red
edges) that goes from e1 to e8. The infeasible path marking happens in Step 2 (Section 11.2.2).

11.2.2. Step 2

Step 2 marks the edges in the CFG with the corresponding infeasible paths that pass through
the edges. In particular, this is achieved by maintaining three sets namely Start, Inner, and End at
each edge e, indicating the MIPS that contain e as start, inner, or end edge respectively. For our
running example, the results of Step 2 obtained by using Algorithm 2 are marked in the green
color in Figure 21.

The Step 2 proceeds as follows. For each edge e where any query qex was resolved to FALSE
(in Step 1), we mark e as the start edge of an infeasible path segment (ips) that ends at ex . We
also mark ex (i.e., the edge at which query qex was raised in Step 1) as the end edge of the ips.
For example, in the Figure 21, edge e1 is marked as start edge, and the edge e8 is marked as end
edge for ips that ends at e8.

11In the UNDEF case, Bodik also proposes the idea of query substitution which is not described here.
12Note that only intra-procedural predecessor edges are considered. In case, the source of pe is a call node and the
variables present in the query are modiﬁed inside the callee function, then the query is not propagated to predecessor
edges of pe.

66

S p

l = 2

e0

a = 0

e2

e1

Start[e2] = {qe5}

Q[e2] = {qe5}

use a

Cpz

use a

S z

Inner[e3] = {qe5}

Q[e3] = {qe5}

e3

Inner[e4] = {qe5}

Q[e4] = {qe5}

z()

e4

a > 5

End[e5] = {qe5}

qe5 : (a > 5 == T RUE)
true

e5

e8

l = ∗

z1

e9

Rzp

use a Ez

use a

e6

false

e7

E p

use a

Figure 22: Detecting a balanced interprocedural MIPS. The variable a is not modiﬁed inside the procedure z, hence the
query (qe5 : a > 5 = TRUE) is back propagated from e4 to e3. S , E represent the start and end nodes of a procedure
respectively. C pz represents the transfer of control from procedure p to procedure z at a call node, and Rzp represents the
return of control from z to p. For brevity, cases where Q, S tart, Inner, or End is empty are not shown.

67

Next, if at some edge e query qex was propagated backwards (in Step 1) and all its predecessor
edges are marked as start edge for some ips that ends at ex (in Step 2) then e can also be marked
as start edge for the ips. This follows from the fact that the path segment from each predecessor
edge pe to ex is infeasible path segment but path segment from e to ex is also ips and is shorter
than the ips from pe to ex. Using this justiﬁcation, we mark edge e3 as the start edge for ips that
ends at e8 in our running example; observe that the ips that goes from e3 to e8 is shorter than the
one that goes from e1 to e8 (hence we un-mark e1 as start edge).

On the other hand, if at some edge e query qex was propagated backwards (in Step 1) and
only some of its immediate predecessor edges are marked as start edge or at least one of the
predecessor edge is marked as the inner edge for a ips that ends at ex then we mark e as inner
edge for the ips. For instance, we mark edges e6, e7 as inner edges for ips that ends at e8 in our
running example.

Finally, at the end of Step 2, each path segment σ : e1 → e2 → ... → en in CFG is a MIPS if

there exists a query q present in S tart[e1], End[en], and Inner[ei], 1 < i < n.

Example 1.
Figure 22 shows how balanced inter-procedural MIPS (deﬁnition 2 from
Chapter 5) are detected using Bodik’s approach. In particular, the variables in the query
qe5 are not modiﬁed inside the procedure z, hence qe5 is propagated from e4 to e3 to e2.
Subsequently, in Step 2, e2 → e3 → e4 → e5 is marked as a MIPS.

68

