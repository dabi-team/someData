2
2
0
2

r
a

M
3
2

]

M

I
.
h
p
-
o
r
t
s
a
[

1
v
2
4
6
2
1
.
3
0
2
2
:
v
i
X
r
a

pyobs - An observatory control system for
robotic telescopes
Tim-Oliver Husser 1,∗, Frederic V. Hessman 1, Sven Martens 1, Tilman Masur 1,
Karl Royen 1, and Sebastian Sch ¨afer1
1Institute for Astrophysics and Geophysics, G ¨ottingen University, G ¨ottingen,
Germany

Correspondence*:
Tim-Oliver Husser
thusser@uni-goettingen.de

ABSTRACT

We present a Python-based framework for the complete operation of a robotic telescope
observatory. It provides out-of-the-box support for many popular camera types while other
hardware like telescopes, domes, and weather stations can easily be added via a thin abstraction
layer to existing code. Common functionality like focusing, acquisition, auto-guiding, sky-ﬂat
acquisition, and pipeline calibration are ready for use. A remote-control interface, a “mastermind”
for truly robotic operations as well as an interface to the Las Cumbres Observatory observation
portal is included. The whole system is fully conﬁgurable and easily extendable. We are currently
running pyobs successfully on three different types of telescopes, of which one is a siderostat for
observing the Sun. pyobs uses open standards and open software wherever possible and is itself
freely available.

Keywords: methods: observational, telescopes, techniques: image processing, techniques: photometric, techniques: spectroscopic

1 INTRODUCTION

At the turn of the millennium, a major change was starting to take place in observational astronomy: at ﬁrst
unnoticed by most astronomers, many new telescopes were reﬁtted or newly built for remote or even fully
autonomous observations. While there were lots of discussions and even a few robotic telescopes in the
early 90s (see, e.g., Perlmutter et al., 1992; Alcock et al., 1992), their number grew signiﬁcantly in the
decades thereafter.

While most of the very early robotic telescopes simply monitored known variable stars (e.g., Henry
et al., 1995; Strassmeier et al., 1997), those that followed were designed to permit very rapid follow-up of
gamma-ray bursts – e.g., ROTSE-III (Akerlof et al., 2003), REM (Antonelli et al., 2003), and BOOTES
(Castro-Tirado et al., 2004) – or search for exoplanets (e.g., with SuperWASP, Street et al., 2003), or to
survey galaxies for supernovae (e.g. Filippenko et al., 2001; Lipunov et al., 2007). As automation became
easier and pipeline software more powerful, it was possible to survey automatically for any transients
or moving Solar System objects, e.g. with the Intermediate Palomar Transient Factory (iPTF, Law et al.,
2009), which later was reﬁtted to become the Zwicky Transient Facility (ZTF, Bellm et al., 2019; Riddle
et al., 2018). About the same time, Las Cumbres Observatory (LCO) started building a whole network of
robotic telescopes (Hidas et al., 2008), now one of the largest in the world.

1

 
 
 
 
 
 
Husser et al.

pyobs

Robotic telescopes can be used for many things – from the automated performance of a heterogeneous
list of independent observations to the dedicated performance of a particular scientiﬁc project. The unique
science that can be done with robotic telescopes almost exclusively concerns transients, i.e. changes over
time on the sky of any kind. The ultimate source for such targets in the near future will be the Legacy Survey
of Space and Time (LSST) at the Vera C. Rubin Observatory, an 8.4 m telescope designed for surveying the
sky for any kind of transients (Ivezi´c et al., 2019). When the LSST starts operating in late 2022, a legion of
other robotic telescopes will begin doing follow-up observations on the detected transients.

All truly robotic telescopes require a wide palette of hardware – e.g. computer-controlled telescopes,
cameras, ﬁlter wheels, enclosures, and weather stations – and software for autonomous operation of the
entire system. While this software can be rather basic (to avoid the fully unwarranted word ”simple”) for
surveys that just do the same thing over and over again, it gets immensely more complicated for all-purpose
telescopes. Unfortunately, this software almost never gets published or placed in a form which is useful for
another project, mostly for the reason that it is very speciﬁc to the hardware and the science case at hand.

Luckily, there is some software available that tries to be applicable to many different hardware devices
and kinds of observations. Especially popular with amateur astronomers is the Windows COM-based
ASCOM system1, which deﬁnes generic interfaces for different kinds of devices and can be used by several
client applications. A couple of years ago, a HTTP REST based interface called Alpaca was released,
which allows the use of ASCOM in Unix-like systems as well. Additional powerful software like ACP
from DC3.com can be used to help automate operations within an ASCOM network. A very different
system but with the same basic philosophy and breadth of support is the Instrument Neutral Distributed
Interface (INDI).2, which was designed for network transparency from the beginning and can be used
from any system and programmed in any language, although the core libraries are written in C++. The
2nd version of the Remote Telescope System (RTS2 for short; Kub´anek et al. (2004)) is widely used in a
variety of mostly scientiﬁc projects. It provides a complete framework – including a back-end database –
and is designed for fully autonomous operations. RTS2 is written in C++ and runs on Linux only.

For our own MONET telescopes (Hessman, 2004, see also Section 6) we ﬁrst successfully used the
robotic control software developed for their twins, the STELLA telescopes (Granzer, 2006; Granzer et al.,
2012) on Tenerife, operated by the AIP in Potsdam, which was thankfully made available to us by our
colleagues there. While the system itself is written in Java, over time we started to implement some
functionality using more familiar Python scripts. These scripts grew and at some point became pyobs, a
fully functional observation control system for robotic telescopes on its own. There was originally no other
good reason for developing pyobs than this; without pyobs and starting from scratch, we probably would
have chosen INDI. However, pyobs has now grown to a level where it is just as powerful as INDI, RTS2, or
ASCOM: it is highly ﬂexible, uses open standards, and is programmed in the language most commonly
used by astronomers. Indeed, it stands on the shoulders of giants that are the many amazing open source
Python projects used in computer science and astronomy. In this paper we will present its architecture and
the basic functionality.

We strongly believe in acknowledging the work other people put into publicly available (open-source)
software, and thus, references for all the third party software projects used in pyobs are listed in the

1 https://ascom-standards.org
2 https://indilib.org

This is a provisional ﬁle, not the ﬁnal typeset article

2

Husser et al.

pyobs

Acknowledgments. All pyobs packages themselves are published as open-source under the MIT license at
GitHub3, and its documentation is also available online.4

2 ARCHITECTURE

The astronomical community has spent the last two decades migrating from diverse programming languages
like IDL, FORTRAN, or C/C++ to a common denominator, which turned out to be Python. As a result,
today we have powerful scientiﬁc libraries available like NumPy, SciPy, and AstroPy. Following this
progress, Python was an easy pick as the language of choice for a new Observatory Control System (OCS).

Nevertheless, Python has some drawbacks for a large project like this, with the ”global interpreter lock”
(GIL) being the most signiﬁcant. The GIL is a multi-threading lock (or ”mutex”) that can only be acquired
by one thread at a time. So, although Python supports the creation and running of multiple threads, they
never run in parallel. The only way to achieve true parallelism is to use multi-processing, so a decision
was made to run pyobs in multiple processes, i.e. one process per block of functionality, which, in pyobs
terminology, is called a ”module”. A module can be everything from a controller for an actual hardware
device to routines for, e.g., an auto-focus series. With the OCS being split up into multiple processes, the
communication between them became one of the most important parts of pyobs.

2.1 Communication

Instead of inventing our own protocol for communication, we decided to use XMPP (Saint-Andre, 2004),
an XML-based chat protocol. With it being mainly used for instant messaging (e.g. by Jabber, WhatsApp,
Zoom, Jitsi, and others), it naturally supports multi-user chat, i.e. sending messages to multiple users. But
due to its wide variety of extensions (XMPP Extension Protocol, XEP), it also supports remote procedure
calls (RPC, calling methods on another client), and a feature called auto-discovery, which allows one client
to determine the capabilities of another.

The use of XMPP also frees us from writing and maintaining our own server software, since there
are multiple industrial-grade servers available, like ejabberd5 and Openﬁre6. They can run with tens of
thousands of users, compared to maybe a few dozen pyobs clients in a typical observatory. Although,
admittedly, pyobs sends more messages than even the most ambitious teenager in WhatsApp.

While we use the Python package Slixmpp for pyobs itself, there are also XMPP libraries available for
all major programming languages7. Therefore the ”py” (for ”Python”) in ”pyobs” refers only to the core
package, but extension modules can be written in any language that supports XMPP.

As Fig. 1 shows, the communication in pyobs is based on three pillars (remote procedure calls, interfaces,

events), which all will be discussed in more detail in the following.

2.1.1 Remote procedure calls

All methods within a module that are derived from an interface (see below) can be called remotely. The
easiest way to do so, is to get a Proxy object for another module from pyobs. These objects mimic the

3 https://github.com/pyobs
4 https://www.pyobs.org
5 https://www.ejabberd.im
6 https://www.igniterealtime.org/projects/openfire/
7 see, e.g., https://xmpp.org/software/libraries/

Frontiers

3

Husser et al.

pyobs

Figure 1. The three pillars of communication in pyobs. On the left, remote procedure calls are actively
called on another module. The list of interfaces, in the middle, is automatically retrieved after the connection
to the XMPP server has been established. And events can be sent at any time, as shown on the right. Only
those events can be handled in a module that it had registered before.

behavior of the original module and therefore any of their methods can be called directly as if they were
local.

For instance, a camera module might implement this method:

async def set_exposure_time(

self,
exposure_time: float,
**kwargs: Any

) -> None:

For another module, calling this method is a simple as:

camera = await self.proxy(name_of_camera_module)
await camera.set_exposure_time(2.0)

While some methods should usually return immediately (e.g. requesting a position), some might take a
longer time (e.g. exposing an image or moving a telescope). For the caller of a method it would be good
to have an estimate for the call duration in order to avoid waiting forever in case of an error. To achieve
this, pyobs extends the XEP-0009 extension for RPCs with a timeout mechanism: all methods can deﬁne a
time after which they should be ﬁnished. This time is sent back to the caller immediately after a method is
called. If this waiting time is exceeded, a timeout exception is raised and the caller can decide what to do
about this. If a method takes longer than 10 seconds, it should be decorated with the @timeout decorator,
which deﬁnes the maximum duration:

@timeout(1200)
async def move_radec(

self,
ra: float,
dec: float,
**kwargs: Any

This is a provisional ﬁle, not the ﬁnal typeset article

4

Husser et al.

) -> None:

pyobs

Calling a method like this works the same way as before, although it now raises an exception only after
1200 s, compared to 10 s for un-decorated methods.

2.1.2 Interfaces

The basis for all RPCs in pyobs are the interfaces in pyobs.interfaces, which describe methods
that a module must implement in order to provide a given functionality. For instance, all telescope modules
should implement the ITelescope interface. While not deﬁning any methods on its own, it inherits the
two methods move radec and get radec from IPointingRaDec (shortened for clarity):

class IPointingRaDec(Interface):

@abstractmethod
async def move_radec(

self,
ra: float,
dec: float,

) -> None:
...

@abstractmethod
async def get_radec(self, ) -> Tuple[float, float]:

...

class ITelescope(IPointingRaDec):

...

Therefore, in order to be a valid ITelescope, a module must implement these methods.

All interfaces implemented by a module are published via XMPP’s auto-discovery extension, so all
other modules can easily determine what functionality is available from a given module. This allows
for easy construction of Proxy objects for RPC. Furthermore, it is extremely simple for a module to
ﬁnd all other modules that implement a given interface. A good example for this are the interfaces
IFitsHeaderBefore and IFitsHeaderAfter. When a camera starts a new exposure, we usually
want to collect FITS headers from different modules. Instead of having this list pre-deﬁned, the camera can
just request all modules that implement these interfaces and call their respective methods before and after
the exposure:

clients = await self.comm.clients_with_interface(

IFitsHeaderBefore

)
for client in clients:

proxy = await self.proxy(client, IFitsHeaderBefore)
headers[client] = await proxy.get_fits_header_before()

This way, we can easily add a new module to the system that simply provides new headers for new FITS
ﬁles (e.g. with weather data).

Frontiers

5

Husser et al.

pyobs

Figure 2. Part of the interface inheritance for DummyTelescope (on the left in green), a simulated
telescope that accepts RA/Dec coordinates and offsets and has a ﬁlter wheel, a focus unit, and some
temperature sensors. All methods available for remote calls are deﬁned in the interfaces. ITelescope
does not deﬁne any method of its own, but is just a collection of other interfaces and can be used as a
device deﬁnition, i.e. ”this is a telescope”.

As an example, Fig. 2 shows parts of the inheritance for DummyTelescope, a simulated telescope that

can be used for testing.

2.1.3 Events

While RPC is an active process of communicating with other modules, there is also a passive one, which
is reacting to events. Each module can deﬁne types of events that itself creates and that it wants to receive
from other modules.

For instance, a camera might want to declare that it can send events, when a new image has been taken

await self.comm.register_event(

NewImageEvent

)

and can actually send those events:

await self.comm.send_event(

NewImageEvent(filename, image_type)

)

while another module might want to receive those events and handle them in a callback method:

await self.comm.register_event(

NewImageEvent,
self.on_new_image

)

This is a provisional ﬁle, not the ﬁnal typeset article

6

Husser et al.

[...]

async def on_new_image(

self,
event: Event,
sender: str

) -> bool:

print(event)

pyobs

The events can be chained by sending new events within a handler method. As an example, events on
new images from a camera could be handled by an image pipeline, which in turn sends events that are
handled by a module that measures seeing on the reduced images.

2.2 Conﬁguration

pyobs gets its high ﬂexibility from conﬁguration ﬁles in YAML format. The most simple conﬁguration

consists of only a single line like:

class: pyobs.modules.test.StandAlone

When running this conﬁguration via pyobs config.yaml from the command line, a new module is
created from the given class and started. The class to use is given by its full package name, the same as one
would use to import it in a Python shell. Therefore, its deﬁnition could be anywhere within the Python path
and not just in the pyobs package.

The example in the documentation is a little longer:

class: pyobs.modules.test.StandAlone
message: Hello world
interval: 10

Comparing this with the signature of the constructor of the given class:

class StandAlone(Module):
def __init__(
self,
message: str = "Hello world",
interval: int = 10,
**kwargs: Any

):

This makes it clear that all items in the conﬁguration are simply forwarded directly to the constructor of
the given class. pyobs goes even a step further and allows many parameters to be either an object or a
conﬁguration dictionary (mostly given in a YAML ﬁle as in the example above), describing an object of
the same type. For instance, every module class has also a parameter comm (derived from pyobs’ Object
class) for deﬁning its method for communication with other modules, given as this:

Frontiers

7

Husser et al.

pyobs

comm: Optional[Union[Comm, Dict[str, Any]]] = None

So this parameter accepts both a Comm object directly or a description thereof. A valid conﬁguration ﬁle
could therefore look like this:

class: pyobs.modules.test.StandAlone
comm:

class: pyobs.comm.slixmpp.XmppComm
jid: test@example.com
password: topsecret

Looking at the constructor of given class XmppComm explains the given parameters (shortened for clarity):

class XmppComm(Comm):
def __init__(
self,
jid: Optional[str] = None,
password: str = "",

):

Note that this makes it possible to replace the whole communication system via XMPP with another method
by just implementing a new class derived from Comm. In an environment, in which it is impossible to run
an XMPP server, this could simply be replaced by, e.g., direct socket communication or HTTP REST.

A similar conﬁguration style is used for names of remote modules, which are called within a module.

Here is the constructor of the default class for taking an auto-focus series (shortened):

class AutoFocusSeries(Module, IAutoFocus):

def __init__(
self,
focuser: Union[str, IFocuser],
camera: Union[str, IImageGrabber],

):

The class needs two remote modules to work, a camera for taking the images and a focus unit with which it
can change the actual focus value. Both are deﬁned to accept either a string or an object implementing
the interface that is actually required. While for testing, it might be easier to pass an actual object, at the
observatory we usually just set the name of the other module. From this name, a proxy object is being
created, which is checked for implementing the given interface. Therefore, in production, a conﬁguration
for a focus series might look like this:

class: pyobs.modules.focus.AutoFocusSeries
camera: fli230
focuser: telescope

Note that all this behavior is completely up to the class that you want to use. So it must implement the
ﬂexibility to accept both an object and a description or a remote name. This should be the case for all
modules from the core package and the additional packages.

This is a provisional ﬁle, not the ﬁnal typeset article

8

Husser et al.

pyobs

If possible, the conﬁguration even allows changing the core behavior of a module. Coming back to the
AutoFocusSeries class from above, this class itself only deﬁnes the functionality for taking a series
of images at different focus values. The actual analysis of the images and the calculation of the ﬁnal best
focus is delegated to an object of type FocusSeries as deﬁned as a parameter in the constructor:

series: Union[Dict[str, Any], FocusSeries]

The default implementation in pyobs (ProjectionFocusSeries in utils.focusseries)
collapses the images along their x and y axes, respectively, and calculates moments to get a rough
size of the stars. The ﬁnal best focus is calculated using a hyperbola ﬁt to the series of focus and size data.
But, given that this class is explicitly speciﬁed in the conﬁguration ﬁle, it can easily be changed to another
(custom) implementation that derives from FocusSeries.

A module might want to make some conﬁguration settings changeable during runtime. This can be
handled via the IConfig interface, which is implemented by default by all modules and calls internal
methods of the form set config <name> (if exists) for changing the given variable <name>.

2.3 asyncio

Given the already mentioned problems with multi-threading in Python, it is only logical to rethink the
use of threads in pyobs in the ﬁrst place. Most modules in pyobs do one thing most and foremost: waiting.
Waiting for a command to execute, waiting for an exposure to ﬁnish, waiting for the dome to move into
position. However, in pyobs many things still need to be run concurrently, e.g. a module should still
be accepting commands while moving a telescope. Luckily, Python introduced a new way of handling
concurrency in version 3.5 and improved it steadily in the years thereafter. The new asyncio package uses a
main loop and switches between tasks on request, all on a single CPU core and in a single thread. This
avoids typical problems in multi-threading like deadlocks and run conditions. However, calling a blocking
function in asyncio blocks all other tasks as well, so there is also an easy way for running single methods
in an extra thread and waiting for it.

Functions that are running within the asyncio loop are called coroutines and are deﬁned with the async

keyword, as shown before for the interfaces:

class IPointingRaDec(Interface):

async def move_radec(ra: float, dec: float):

...

Coroutines can only be called directly from other coroutines and always need to be ”awaited”:

async def test():

await telescope.move_radec(1., 2.)

They can also be called without actually waiting for them to ﬁnish. In those cases, a task should be created
which can be awaited later:

task = asyncio.create_task(telescope.move_radec(1., 2.))
...
await task

Frontiers

9

Husser et al.

pyobs

In pyobs, this is, for instance, used for requesting FITS headers from other modules before an exposure
is started. The module creates tasks for requesting the headers, but only awaits them after the image has
ﬁnished, in order not to delay the start of the exposure.

As mentioned above, asyncio heavily reduces the risk of multi-threading related problems. That is,
because tasks never run in parallel, but are only switched when one has ﬁnished or when something is
awaited. In multi-threading, parts of the code that should not be interrupted are often secured using a mutex
(or lock), which is mostly unnecessary when using asyncio.

With asyncio, one just needs to be careful with long running functions that are not deﬁned async, e.g.
the readout processes of some cameras. Those method calls would block the whole module, so asyncio
provides an easy way to run them in an extra thread:

loop = asyncio.get_running_loop()
data = await loop.run_in_executor(None, camera.read_out())

Altogether, pyobs make heavy use of asyncio. For instance, all interface methods and all event handlers
must be deﬁned async. Switching from multi-threading to asyncio massively reduced the number of
difﬁcult-to-debug errors and made developing a lot easier.

2.4 Virtual File System

In a simple pyobs system, all its modules might run on a single computer. In that case, a module storing
a ﬁle on a local disk can be certain that another module can access it at the same location. An easy
workaround for using this system with modules on different machines is to mount (e.g. via NFS or SMB)
the required directories on both machines, but even in that case one has to be careful to mount to the same
directory, otherwise ﬁlenames would not be the same on both.

This is where a virtual ﬁle system (VFS) becomes useful: if we could deﬁne a ”virtual” directory that
points to the correct location on all computers, the problem would be solved. pyobs provides a VFS in
pyobs.vfs and uses it wherever ﬁles are accessed. The VFS is automatically available in all modules,
although it needs to be conﬁgured. A simple VFS conﬁguration (within the module conﬁguration) might
look like this:

vfs:

class: pyobs.vfs.VirtualFileSystem
roots:

temp:

class: pyobs.vfs.LocalFile
root: /data/images

The VFS in pyobs uses the concept of ”roots” to deﬁne where a ﬁle is actually located. In this case, one
root, temp, is deﬁned as a LocalFile, which itself has a root parameter, pointing to a real directory
in the ﬁle system – note that root here has nothing to do with the roots system in pyobs’ VFS, but comes
from the term ”root directory”.

Now, within a pyobs module with this conﬁguration we can open a ﬁle like this:

fd = self.vfs.open_file("/temp/new/image.fits", "r")

This is a provisional ﬁle, not the ﬁnal typeset article

10

Husser et al.

pyobs

Figure 3. Some examples, how a VFS path (left) maps to a real path (right) with a given conﬁguration
(middle). Note that for the remote root the class SSHFile requires more parameters for the connection,
which have been omitted here for clarity.

Internally, pyobs maps the ﬁrst part of the path (the root), i.e. temp in this case, to the root of the same
name given in the conﬁguration, so it actually creates a LocalFile. When opening the ﬁle, the path
is changed accordingly to /data/images/new/image.fits. Following up on the example from
above, now the temp root can point to different directories on all computers, but still the same ﬁlenames
can be used on all.

Since the mounting of remote directories might not be possible in some cases, pyobs offers some more

classes for ﬁle access within the VFS:

• ArchiveFile connects to the pyobs-archive image archive (see Section 4.1). Currently only writing

is permitted, i.e. uploading an image to the archive.

• HttpFile represents a ﬁle on a HTTP server, e.g. the pyobs ﬁle cache (see Section 3.4.4).
• LocalFile is a local ﬁle on the machine the module is running on.
• MemoryFile stores a ﬁle in memory.
• SMBFile allows access to a ﬁle on a Windows share without mounting it.
• SSHFile accesses a ﬁle on a remote machine that is accessible via SSH.
• TempFile works on a temporary ﬁle that will be deleted after being closed.

A ﬁle opened via VFS almost works like a normal ﬁle-like object in Python, with the one difference that
all its methods are async, so they need to be awaited. pyobs also offers some convenience functions for
reading and writing FITS, YAML, and CSV ﬁles in the VFS.

Figure 3 shows some examples, how a VFS path maps to a real path with a given conﬁguration.

2.5 Image processors and pipelines

With the Image class in pyobs.images, pyobs offers a class for reading and writing images that also
has support for additional data like a good pixel mask, a star catalog and pixel uncertainties. It is a simple
wrapper around the FITS functionality in astropy and is used within pyobs whenever images need to be
passed along.

Frontiers

11

Husser et al.

pyobs

Building on this image class, pyobs has the concept of ”image processors” (deﬁned in
pyobs.images.processors), which simply take an image, process it in some way, and then return
it. Currently, these types of processors are available:

• An astrometry processor takes an existing catalog attached to the image and tries to plate-solve it.
• The detection processors try to detect objects in the image and write a catalog.
• The processors in exptime try to estimate a good exposure time from an image, the one existing

implementation is for star ﬁelds.

• In offsets are processors that calculate some kind of offsets, usually used for guiding and acquisition.
• The photometry processors perform photometry on the image (usually at positions determined using

a detection step) and write/extend the catalog.

• There are some more misc processors that can, e.g., add a good pixel mask, calibrate the image, or bin

it.

Since image processors take an image as input as well as returning one as output, they can easily be
chained into an image pipeline. This is done by many modules for pre-processing images in some (fully
customizable) way before working on them. Adding new image processors is easily done and provides a
perfect way for handling images.

pyobs also offers a full (ofﬂine) image pipeline (in utils.pipeline.Night) that is also based on

image processors, permitting the fully automatic processing of a night’s images.

2.6 Error handling

Handling errors in a single program is sometimes difﬁcult enough, but it can get rather complicated in a
distributed system like pyobs. The basic requirement for every module is that it should handle errors on its
own as well as possible (e.g., resolve errors states in hardware devices) but sometimes a calling module
needs to be informed about a problem, e.g. if a camera does not respond to requests anymore.

Since error handling can be very speciﬁc to the problem at hand, pyobs only provides a framework for
dealing with this, not a ﬁnal solution. It introduces its own set of exceptions that are all derived from
PyObsError in pyobs.utils.exceptions, and new exceptions can easily be added if required.

A module can call register exception() and deﬁne a callback that is called whenever a given
exception is raised and a given condition is met: the function accepts a limit of how often this can happen
(optionally in a given time span) before the problem is escalated. In that case, the raised exception is
changed into a SevereError, keeping the original exception as an attribute. That means, catching one
of these severe errors means that an error has occurred too often (in a given time span).

This gets more interesting in a real pyobs system with several modules. There are some cases, in which a
module should stop working at all and inform other modules about this. So, e.g., the BaseCamera, which
is the base class for all cameras it pyobs, registers an exception like this:

register_exception(
GrabImageError,
3,
timespan=600,
callback=self._default_remote_error_callback

)

This is a provisional ﬁle, not the ﬁnal typeset article

12

Husser et al.

pyobs

This deﬁnes that after three occurrences of the GrabImageError exception within 600 s, the given
method should be called, which is a default implementation in Module. It simply logs the error and sets
the module to an error state that prevents (almost) any of its methods to be invoked remotely. If another
module tries to call methods anyway, it receives a ModuleError.

If a method is invoked remotely and an exception is raised, this exception is wrapped in a RemoteError
with the original exception stored in an attribute. This is useful to register exceptions with the module
parameter, which only registers an exception on a given remote module. For instance, the FocusSeries
module uses this:

register_exception(

RemoteError,
3,
timespan=600,
module=camera,
callback=self._default_remote_error_callback

)

So, whenever the remote module camera raises too many exceptions, the FocusSeries module itself
goes into error state, which can be cleared remotely by calling reset error() – and of course might
reappear when the exception is raised again.

Note that registering an exception always also registers parent exceptions. So if exception B is derived

from A, all occurrences of B also count for the registered limits for A.

3 AVAILABLE MODULES

In general there are two types of modules coming with pyobs: those that control actual hardware and those
that do not. While the latter are part of the core package, the former are outsourced to separate packages,
since they will not be required by everyone and often need special drivers to be installed. All modules can
be found on the central GitHub page.

For developing your own modules, please refer to the documentation or just have a look at the existing
ones as examples. There is also a simulation available that can be used for ﬁrst tests. Please see the
documentation for details on how to set it up.

Table 1 lists all modules available in the core package and in external packages.

3.1 Cameras

pyobs knows two kinds of cameras: classic cameras (derived from the interface ICamera), for which
one actually starts and stops an exposure, and webcam-like cameras (interface IVideo, which constantly
provide a video (or a series of images) as output. In addition, spectrographs are also supported (interface
ISpectrograph), which output a spectrum instead of an image – therefore, most spectrographs would
be implemented as a camera, since they return an image, from which the spectrum needs to be extracted.

In the following those camera types are listed, for which stable modules exist and are available via
GitHub and PyPi. In addition, we also have modules for Andor and QHYCCD cameras, as well as normal
USB webcams (via Video4Linux2), but they are all not in a publishable state. If you need one of those,
please contact the author of this paper.

Frontiers

13

Husser et al.

3.1.1 SBIG

pyobs

The pyobs-sbig package builds on the SbigDevKit Linux driver for SBIG cameras. It is based on a Cython
wrapper around that library’s CSBIGCam and CSBIGImg classes. The different modules support SBIG
cameras with and without ﬁlter wheel. There is a additional implementation for the STXL-6303E, due to
its different gain at different binnings. Note that this special treatment of single models might be necessary
for other cameras. The module has been tested on STXL-6303E, STF-402M, and STF-8300M cameras.

3.1.2 Finger Lakes Instrumentation

A Cython wrapper around the ofﬁcial libfli8 library for FLI cameras is the core of the pyobs-ﬂi. The

module has been tested on a FLI ProLine 230.

3.1.3 ZWO ASI

pyobs-asi is a thin wrapper around the zwoasi package to support the cameras by ZWO ASI. It has been

tested on a ZWO ASI071MC Pro.

3.1.4 Aravis

Aravis9 is a library for Genicam cameras connected via gigabit ethernet or USB3. The module in pyobs-
aravis uses a modiﬁed version of the python-aravis package for communicating with the cameras. It has
been tested with several cameras from The Imaging Source10.

3.2 Other hardware

While astronomical cameras are often bought off the shelf and a few brands are most common between
observatories, this is mostly quite different for the other hardware in the dome – and the dome itself. Those
devices are often operated by custom controllers and need special treatment. However, if a driver of any
kind exists, it is very simple to write a wrapper for it to be used within a pyobs system.

An attempt to standardize the communication between all kinds of devices has been made with ASCOM.
A pyobs module for ASCOM will be described in detail below. Another of those attempts is INDI, for
which we do not have a pyobs wrapper yet. Interfaces to those two standards are an easy way to add
hardware to a pyobs system, for which ASCOM/INDI drivers already exist.

3.2.1 ASCOM

ASCOM is a standard for communicating with astronomical devices in Windows and is supported by a
wide range of cameras, telescopes, domes, etc. Furthermore, there a many client applications like ”The
Sky” or ”Stellarium” that can operate an ASCOM based system.

While pyobs can run on Windows, we made the experience that some things are a little more prone to
error on that operating system – pyobs processes sometimes quit without warning. There is a (private)
pyobs package for calling ASCOM interfaces directly on Windows, but due to these problems, we never
published it. However, we can provide access on request.

The restriction to Windows systems is due to the use of Windows COM as means for communication,
which is not available for other operating systems. Luckily, in 2018 ASCOM presented a new interface,

8 https://www.flicamera.com/downloads/FLI_SDK_Documentation.pdf
9 https://github.com/AravisProject/aravis
10 https://www.theimagingsource.de

This is a provisional ﬁle, not the ﬁnal typeset article

14

Husser et al.

pyobs

called Alpaca, which is based on HTTP REST requests, and therefore can also be accessed from Unix-like
systems. The pyobs-alpaca package provides modules for telescopes, domes and focus units via Alpaca.
However, in contrast to most other modules in the pyobs ecosystem, these ones are not meant to be used
directly, but more as some kind of inspiration for an observatory speciﬁc implementation. They are not
a general implementation of the ASCOM protocol, but tailored speciﬁcally for the use case of the 50cm
Cassegrain telescope based at the Institute for Astrophysics and Geophysics in G¨ottingen.

3.2.2 Pilar

Pilar is a telescope control software from ”4pi Systeme”11 based on the Open Telescope Software
Interface (OpenTSI), and currently used by our MONET telescopes via the pyobs-pilar package. While the
speciﬁc implementation of this module might not be of interest for most observatories, it shows an example
for a socket based communication protocol wrapped in a pyobs module.

3.3 Automating

While the modules described so far are all built around a speciﬁc piece of hardware, there are also those

that purely consist of software to automate the boring stuff.

3.3.1 Auto-focus

A common problem in astronomy is focusing the image on the camera sensor. In most cases this will
be done by moving either a mirror (mostly the secondary) or the camera back and forth until stars appear
sharp, i.e. with the smallest possible width. The AutoFocusSeries (in pyobs.modules.focus)
module accomplishes this by taking a series of images at different focus values (i.e. position of M2 or
camera), and tries to ﬁnd an optimal focus by ﬁtting a hyperbola through the estimated star widths in each
image as a function of focus value. For this, references to a camera and a focus unit must be speciﬁed so
that they can be controlled remotely.

The estimation of star sizes is fully conﬁgurable by injecting a class implementing the FocusSeries
(in pyobs.utils.focusseries) interface. Our current default implementation is deﬁned in
ProjectionFocusSeries, which projects the image along its x and y axis, respectively, and measures
moments on the resulting 1D data. Another possibility is to use a method for star detection/photometry for
estimating star widths, as used in PhotometryFocusSeries.

While especially smaller telescope will typically work well with a constant focus value throughout the
whole night, larger telescopes (with a steel structure) are constantly changing their size (and therefore the
position of the perfect focus) due to temperature changes. For these cases, pyobs provides a temperature
model for the focus, which is implemented in the modules.focus.FocusModel module and can
adjust the focus continuously throughout the night. The conﬁguration needs to specify a model function
like this:

model: -0.043*T1 - 0.03*T2 + 0.06*temp + 41.69

While the value for temp is automatically fetched from a given weather module (see Section 3.4.1), those
for T1 and T2 must also be speciﬁed in the conﬁguration. In this case they are mirror temperatures and are
supposed to be requested from the telescope module:

11 http://www.sonobs.de/company/company.html

Frontiers

15

Husser et al.

temperatures:

T1:

T2:

module: telescope
sensor: T1

module: telescope
sensor: T2

pyobs

For this to work, a module named telescope must exist and its get temperatures method must
return values for T1 and T2. With these values the module now calculates new focus values at a given
interval and sets them accordingly.

An AutoFocusSeries also sends an event, when it has successfully determined a new focus, which
can be handled by the FocusModel automatically to optimize its temperature model. For that to work,
the model function must be deﬁned with variables that can be ﬁtted:

model: a*T1 + b*T2 + c*temp + d

In this case, a set of default values must also be provided:

coefficients:
a: -0.043
b: -0.031
c: 0.062
d: 41.694

If this is set up correctly, a fully robotic system can perform multiple focus series during each night (e.g. if
there is nothing else to do) and automatically optimize the focus temperature model over time.

3.3.2 Flat-ﬁelding

A task that is prone to be automated as early as possible is ﬂat-ﬁelding. While this is quite simple in
a controlled environment with a closed dome, e.g. with a ﬂat-ﬁeld screen, it becomes more challenging
when done on-sky during twilight. In that case, exposure times have to be adjusted continuously to obtain
optimal count rates on the images.

To perform this task in a fully automatic way, it is best to ﬁrst measure optimal exposure times as a
function of solar altitude. For taking ﬂat-ﬁelds, we always point the telescope at the same sweet spot on the
sky, right opposite the sun at an altitude of 80◦ (see Chromey and Hasselbacher, 1996). That way, we get
comparable count rates for a given solar altitude and exposure time. We take a series of ﬂat-ﬁelds, for which
we try to get a constant ﬂux level – in our case 30, 000 counts –, and calculate the optimal exposure time
that would be required to get exactly the given level. Figure 4 shows this for a set of RGBC ﬁlters and three
different binnings as measured at the 50cm Cassegrain telescope based at the Institute for Astrophysics and
Geophysics in G¨ottingen.

As one can see, the measured points do not overlap perfectly over several nights, which can be caused,
e.g., by clouds. But the data is good enough to ﬁt exponential functions to it (see lines in plot), which we
can use to roughly estimate the optimal exposure time for a given solar altitude.

This is a provisional ﬁle, not the ﬁnal typeset article

16

Husser et al.

pyobs

Figure 4. An example for empirical models for ﬂatﬁeld exposure times. The points are optimal exposure
times for getting a mean ﬂux of 30,000 counts in the image as a function of solar altitude. The colors
indicate different ﬁlters and binnings. A ﬁt with an exponential function was performed and the best
coefﬁcients are given in the legend and plotted as lines.

During dusk twilight, a ﬂat-ﬁeld module picks a ﬁlter and binning combination and estimates the exposure
time t for the current solar altitude. If the time is shorter than a given minimum Tmin, it does nothing and
waits. When t reaches 0.5 · Tmin, test exposures are started, actually measuring the counts in the image,
and calculate a new best exposure time. Only when t ≥ Tmin the module starts taking actual ﬂat-ﬁelds
until either a given number of images has been taken or t gets larger than a given maximum Tmax. In
dawn twilight, the procedure can be performed accordingly with Tmin and Tmax swapped and opposite
comparisons. This is implemented in the FlatField module in modules.flatfield.

The class handling the actual ﬂat-ﬁelding is, again,

fully conﬁgurable. An example for the
flat fielder parameter of the module might look like this, deﬁning functions for the exposure
time for different binnings and ﬁlters:

class: pyobs.utils.skyflats.FlatFielder
pointing:

class: pyobs.utils.skyflats.pointing.SkyFlatsStaticPointing

combine_binnings: False
functions:

1x1:

Clear: exp(-1.22421*(h+4.06676))

2x2:

Clear: exp(-0.99118*(h+4.66784))

3x3:

Clear: exp(-1.14748*(h+5.38661))

Frontiers

17

Husser et al.

pyobs

The given class for pointing can also be used in the FlatFieldPointing module, which only
points the telescope to a speciﬁc position without taking ﬂat-ﬁelds. This can be useful, if multiple
instruments are supposed to be ﬂat-ﬁelded at the same time.

A twilight is usually long enough for taking ﬂat-ﬁelds in more than one ﬁlter/binning combination. The
FlatFieldScheduler module provides a way to run multiple ones as long as the twilight lasts. It can
also read priorities from a customizable source, which can be, e.g., an image archive, so that the priorities
are the larger the longer ago the last ﬂat-ﬁelds in this combination were taken.

3.3.3 Acquisition

After moving a telescope to a target, it is often off by some arcseconds or even arcminutes. Sometimes
this is unacceptable, especially when the light of a star, e.g., needs to be coupled into a small ﬁber. In those
cases, a ﬁne acquisition based on images from some camera is required. The Acquisition module (in
modules.pointing) takes images, runs them through a pipeline (see Section 2.5) to determine what
offset to move the telescope, and then applies this offset. This is repeated until the offset is smaller than a
given limit.

The conﬁguration for the pipeline typically consists of three steps:

pipeline:

- class: pyobs.images.processors.detection.SepSourceDetection
- class: pyobs.images.processors.astrometry.AstrometryDotNet

url: https://astrometry.example.com/
radius: 5

- class: pyobs.images.processors.offsets.AstrometryOffsets

First, a source detection is run on the images, followed by an attempt to plate-solve it using the service
of Astrometry.net (Lang et al., 2010), for which we provide a self-hosted solution (see Section 4.3). In
the last step, the found coordinates are compared to those from the pointing, and an offset is calculated.
Alternative methods are possible by simply changing the pipeline. For instance, an image processor could
ﬁnd the brightest star in the image and set the offset to move the telescope there.

Applying the offset to the telescope is also fully conﬁgurable. For a telescope that accepts RA/Dec offsets,

it might look like this:

apply:

class: pyobs.utils.offsets.ApplyRaDecOffsets
max_offset: 3600

The given class simply takes the offsets from the image (written by an image processor) and moves the
telescope accordingly.

3.3.4 Auto-guiding

The task of auto-guiding is quite similar to that of acquisition, so the conﬁguration is as well: it also
mainly consists of a pipeline and an apply step. But instead of running until the calculated offset is
small enough, the auto-guiding runs forever, or until stopped, to correct for any shift in pointing that the
telescope is doing over time.

In pyobs, two kinds of auto-guiding are ready to use:

This is a provisional ﬁle, not the ﬁnal typeset article

18

Husser et al.

pyobs

• Science-frame auto-guiding (module ScienceFrameAutoGuiding) uses the images of the
science camera for guiding. This works quite well if the exposure time is small enough to correct for
any shifts of the telescope over time.

• In contrast, what we just call auto-guiding (module AutoGuiding) requires an extra camera that is
mounted, e.g., at the same focal plane as the science camera or at an extra guiding telescope that moves
along with the main telescope. In this case, with a bright enough star in the ﬁeld, the auto-guiding can
perform its corrections, independently of the actual science taken, in intervals as short as required.

While the astrometric method used in the acquisition would also work for auto-guiding, it is usually too

slow. These alternative methods are provided with pyobs:

• A projection method as implemented by ProjectedOffsets projects the images separately along
x and y axis and cross-correlates both individually with a reference image. The resulting x/y pixel
offset can be translated into a RA/Dec or Alt/Az offset.

• Cross-correlating full images is usually too slow, so NStarOffsets uses star positions from a source
detection that needs to run before, and cross-correlates only small images around the N brightest stars
in the image.

3.4 Utilities

A couple of smaller utility modules for common tasks are provided for convenience.

3.4.1 Weather

For fully autonomous observatories, the most important task is not to get observations done, but to close
the roof on bad weather and to keep it closed – an expensive telescope and camera is worth nothing if
regularly rained on. With pyobs-weather (see Section 4.2) there is an afﬁliated project that acts as an
aggregator for data from several weather stations and evaluates some logic to determine, whether the
weather is good or bad, i.e. suitable for observations or not.

The Weather module connects to an instance of pyobs-weather and can provide several functions within

a pyobs network:

• It provides FITS header entries with weather information for science data.
• It has a simple is weather good() method returning a boolean, indicating whether the weather is

good or not.

• It sends events when the weather status changes, GoodWeatherEvent and BadWeatherEvent,

which other modules can handle and react accordingly.

Note that the safety net cast by this module is mainly for the robotic system to react on changes. It is not
a replacement for an emergency shutdown in case of, e.g., rain, which should work even without network.

3.4.2 Telegram

Even the best logging is only good, if someone reads it. Therefore, the module Telegram can forward
all messages of a given level (info, warning, error, ...) into a Telegram chat – the default conﬁguration
would be to have only error messages sent. That way the telescope administrator usually gets notiﬁed of a
problem within seconds.

Frontiers

19

Husser et al.

pyobs

The Telegram bot used for this provides several commands that can be issued to it by simply opening a
chat on the smart phone. For security reasons, every user has to login (/login command) before receiving
any logs and before being able to issue any other command. /loglevel changes the current log level
and /modules lists all online modules. The most powerful command is /exec, which allows the user to
issue any pyobs command to any module, similar to what is possible within a module or in the Shell of the
GUI (see Section 3.5). Using this, the administrator can easily shut the roof or abort an observation from
within a Telegram chat.

3.4.3 Trigger

Events are a powerful system in pyobs and for some of them a default action should be performed every
time they are encountered. Instead of writing a new module for this, one can simply use the existing
Trigger module. It deﬁnes events and the method on a given module that should be executed, when the
event is triggered. For example:

triggers:

- event: pyobs.events.GoodWeatherEvent

module: dome
method: init

- event: pyobs.events.RoofOpenedEvent

module: telescope
method: init

This conﬁguration calls dome.init() on a GoodWeatherEvent and telescope.init() on a
RoofOpenedEvent, thus opening roof and telescope when the weather changes from bad to good –
which, in case of pyobs-weather, is usually also the case after sunset for a night telescope. Note that there
is no trigger conﬁguration for the bad weather case, since all modules handle that on their own.

3.4.4 FileCache

While a camera module can be conﬁgured to store its ﬁles locally, that can be quite impractical, if it runs
on a different computer than the rest of the pyobs system, which might be the case quite often. So there
is need for a place to store the images that can be accessed from all modules – or at least those that need
access to the images.

A network mount using, e.g., SMB or NFS does the job well, but with HttpFileCache there is also
a module available for that in pyobs. It opens a web server on a given port, which can be used to upload
images from the camera and download them somewhere else. It can simply be accessed via the VFS (see
Section 2.4) using a HttpFile root.

3.4.5 ImageWriter and ImageWatcher

When the camera uploads its images to a FileCache (see above), they should still be stored somewhere,
since the cache only holds a limited amount of ﬁles. An easy way to do that is the ImageWriter module
that waits for NewImageEvents, downloads those images and stores them at a different VFS location.

To make this a little safer and reduce the risk of losing images, an ImageWriter should always write
images to a local disk. If they are supposed to be copied to a remote location, the preferred way is an
additional ImageWatcher, which watches a given path for new ﬁles, copies the ﬁles somewhere else, and
only deletes the original ﬁles if there was no error. So a typical setup would conﬁgure the ImageWriter

This is a provisional ﬁle, not the ﬁnal typeset article

20

Husser et al.

pyobs

to store its ﬁles into a local directory like this, assuming that the camera stores its images at /cache/ and
/some/temp/dir/ is some local temp directory:

class: pyobs.modules.image.ImageWriter
vfs:

class: pyobs.vfs.VirtualFileSystem
roots:

cache:

class: pyobs.vfs.HttpFile
download: http://somewhere:37075/

archive:

class: pyobs.vfs.LocalFile
root: /some/temp/dir/

Note that the root archive is used since the default value for the filenames parameter of the module
is /archive/FNAME.

After the images have been stored locally, an ImageWatcher should pick them up and copy them into
an archive (note that curly brackets in destinations indicate placeholders which are ﬁlled from FITS
header values):

class: pyobs_iagvt.filewatcher.FileWatcher
watchpath: /temp/
destinations:

- /archive/{FNAME}

vfs:

class: pyobs.vfs.VirtualFileSystem
roots:

temp:

class: pyobs.vfs.LocalFile
root: /some/temp/dir/

archive:

class: pyobs.vfs.ArchiveFile
url: https://archive.example.com/

Only after the images have been copied into the archive they will be deleted from the temp directory.

3.5 GUI

While all the other modules presented here are fully autonomous, pyobs also provides a graphical user
interface (GUI) for easy (remote) access to the system. Technically it is also just another module, which
opens a window for interaction with the user.

Figure 5 shows a screenshot of the GUI right after a bias image has been taken with the selected SBIG

camera. The main window of the GUI consists of three major parts:

• The list of module pages on the left, including the three special pages Shell, Events, and Status.

Frontiers

21

Husser et al.

pyobs

Figure 5. A screenshot of the graphical user interface (GUI) as provided by pyobs-gui. It shows the list of
connected modules that are supported by the GUI on the left. When selecting one, a custom widget for
each kind of module is shown in the main area right of it. Below is the logging area, which shows log
entries from all connected modules.

• The system log on the bottom, showing all log entries from all connected modules as well as a list of

all those modules on the lower right.

• The module page, ﬁlling the rest of the window, which changes depending on the selected module.

The three special pages mentioned above are:

• The Shell is an interactive command prompt, in which the user can execute any command on any
module in the form <module>.<method>(<params>). This makes the shell a very powerful
tool for admins and for debugging.

• The Events page shows a chronological list of all events that have been sent in the pyobs network. It

also allows to send events on its own with parameters deﬁned by the user.

• The Status page shows the current status of a module, e.g., whether it is in an error state. It also shows

the pyobs version of every module to keep track of updates.

In the list of modules on the left, not all modules are listed, but only those for which a graphical user
interface has been designed. The GUI is fully dynamic, which means that it changes according to the list of
connected modules. Single module pages also adapt to the capabilities of the associated module, e.g. the
camera page only shows options for window and binning, if the camera supports it.

This is a provisional ﬁle, not the ﬁnal typeset article

22

Husser et al.

pyobs

The customization of the GUI goes even further with user-deﬁned pages. For example, pyobs does not
provide a user interface for acquisition and guiding, but in the case of our solar telescope, a visual feedback
is important. So we created a new widget and deﬁned it in the conﬁguration of the GUI:

widgets:
- module: guiding
overwrite: True
widget:

class: pyobs_iagvt.guidingwidget.GuidingWidget
acquisition: acquisition

This tells the GUI to overwrite an existing widget for the guiding module with the given class. Using
custom widgets, one can adapt the GUI to work with any special requirements.

The other way around, restricting access in the GUI, can also be accomplished in the conﬁguration
via the show shell, show events, and show status parameters, which, if set to False, hide the
corresponding page. An explicit list of allowed module pages can be provided with the show modules
parameter. Here is an example for a very limited access to the camera only:

show_shell: False
show_events: False
show_status: False
show_modules: [camera]

Altogether, the GUI tries to allow access to all modules as well as it can, but it is also highly customizable
to match any requirements of an observatory. With ports for the XMPP server (and probably the ﬁle cache)
open to the public, this enables a safe and easy remote access to the pyobs system.

4 AFFILIATED PROJECTS

There are a few projects with ”pyobs” in their name that do not provide any new modules but some external
services that are essential for operating a fully-autonomous telescope.

4.1 Image archive

In classic astronomy an observation consists of three steps:

1. Planning an observation, i.e. ﬁnding targets, deﬁning ﬁlters and exposure times, evaluating best times

for the observation, etc.

2. Actually performing the observation at the telescope.
3. Calibrating and analyzing the data.

Nowadays it is absolutely possible to automate all three and avoid human interaction at all. While this
topic goes far beyond the scope of this paper, we want to mention that a full automation does not only
work for large surveys, but also for small telescopes in the middle of a town like G¨ottingen (see Masur
et al., in prep). However, for robotic observations at least the second step falls away from the observer’s
responsibility, but also parts of step one (deﬁning observing times) and three (calibrate data). In that case,

Frontiers

23

Husser et al.

pyobs

Figure 6. Screenshot of the pyobs-archive instance that we use for the MONET telescopes and the
IAG50cm telescope.

probably not knowing exactly when an observation was taken, an efﬁcient way to ﬁnd data becomes more
important.

This is where an image archive comes into play. There is the LCO science archive1213 to use, but it stores
the images in Amazon AWS S3, while we wanted to store data locally. So we developed our own backend,
which also supports the LCO API, and took parts of the LCO web frontend with permission and adapted it
to our needs. We also added a HTTP endpoint for uploading images. Within pyobs there are classes for
both an easy upload using the VFS (via ArchiveFile), and a full wrapper for accessing the archive in
PyobsArchive.

Figure 6 shows a screenshot of the archive that we use for the two MONET telescopes and the IAG50cm
telescope. On the left, there is a list of options to ﬁlter the data by. On the right is the list of images matching
the selected criteria. More details – including connected data (for calibrated images), a link to the FITS
headers and a thumbnail preview – can be accessed by clicking on the plus symbol. Single or multiple
images can also easily be downloaded using this web frontend.

4.2 Weather aggregator

In Section 3.4.1 we already mentioned a project for aggregating data from different weather stations and
evaluate the values in order to determine, whether the weather is good for observing. Figure 7 shows two
screenshots from pyobs-weather as used by the IAG50cm telescope.

On the left, the main page is shown, with average values from all sensor types as well as plots for the
current night (top), weather status (green and red shaded areas in the plot below, indicating good or bad)
and solar altitude (yellow line in same plot), and plots for all sensors, grouped by type (i.e.. temperature,
humidity, etc). On the right, the Sensors page is shown with current values for all sensors from all stations,

12 https://archive.lco.global/
13 https://github.com/observatorycontrolsystem/science-archive

This is a provisional ﬁle, not the ﬁnal typeset article

24

Husser et al.

pyobs

Figure 7. Two screenshots from the pyobs-weather web frontend for the IAG 50cm telescope. The main
page is shown on the left and the Sensors page on the right.

times of last changes (for evaluated sensors, see below) and comments on the current status. There is a
public API for the weather data, which can easily be accessed via the weather module (see Section 3.4.1).

The system is fully customizable. The basic unit in pyobs-weather is a station, which usually deﬁnes a
single physical weather station. There are some station classes already present, of which some are more
generic (getting data from a MySQL or CSV table) and some are speciﬁc to the observatories where our
telescopes are located (e.g. for the weather station on Mt. Locke at McDonald Observatory). Additional
classes for more stations can easily be added. There are three special stations that do not represent an actual
weather station: Current contains the current average values from all stations, while Average keeps a
ﬁve-minute average. Finally, Observer calculates current conditions, which, at the moment, is only the
solar altitude.

Every station then contains one or more sensors, which provide values for a sensor of a given type:
temperature, relative humidity, pressure, wind speed and direction, particle count, rain, sky temperatures,
or solar altitude. To each sensor, one or more evaluators can be attached, which take the current value and
decide whether it allows for observations or not. Currently, pyobs-weather offers four different kinds of
evaluators:

• A Boolean is a simple logic evaluator, which is True if the sensor value is True, and vice versa –

or the opposite, if invert is set to True.

• Switch is a simple switch, which is True, if the sensor value is above a given threshold, and

vice versa. And, again, the other way around, if invert is set to True.

• A Schmitt trigger is similar to a Switch, but it takes two values: for it to become True, the sensor
value must be below a given good value, but to become False again, it must rise above a given bad
value.

• Sensor values have a valid ﬂag, which is mostly used (and set to False), if the value is older than

ﬁve minutes. The Valid evaluator only evaluates to True, if the value is valid.

As an example, we assume getting relative humidities from two weather stations. For both we would
typically set a Schmitt evaluator with values like good=80 and bad=85, which means that the weather
is marked as bad, if the humidity rises above 85%, but is only marked good again, if the humidity falls
below 80%. It would not be a good idea to attach a Valid evaluator to both, since weather stations can
break. However, we still always want a valid reading for the humidity, so we assign it to the humidity
sensor in the Current station. That way, if we get no valid value at all, the weather is marked as bad.

Frontiers

25

Husser et al.

pyobs

Evaluators on the Average station are never evaluated, but they are used for color coding the plots, i.e.
mark areas that would mean bad weather.

4.3 Astrometry

Getting astrometric solutions for images (i.e. ”plate-solving” them) is a task required at multiple occasions
(see, e.g., Sections 2.5 & 3.3.3). For this we use a self-hosted version of Astrometry.net (Lang et al., 2010),
adding a HTTP interface for accessing its service. Similar to Astrometry.net’s own web service,14 it accepts
a list of X/Y positions of stars on an image, but in addition some parameters for the ﬁt can be provided, like
a ﬁrst guess for the coordinates and an estimate for the plate-scale. A successful call returns FITS header
entries that can be added to an existing ﬁle in order to get a valid world coordinate system (WCS). The
whole process usually takes well below one second. pyobs provides an image processor that uses this web
service for easy use in a pipeline (see Section 2.5).

5 FULL ROBOTIC MODE

With everything described so far, we already have a working observatory. We can control all devices,
automate some things, and remotely control the system with the GUI. All that is needed for a fully
autonomous telescope is some piece of software that coordinates everything. These robotic systems come
in all shapes and colors: from a rather simple survey mode, in which a pre-deﬁned list of targets is executed
from top to bottom, probably all to be done with the same settings, whenever the conditions are right, to a
system with user-deﬁned tasks, maybe multiple instruments, and a scheduler that tries to ﬁt all together.

5.1 Scheduling

The most simple robotic system imaginable is a simple list of targets that are to be observed one after the

other, top to bottom. An algorithm for that might look like this:

1. Select a target from a list, probably the ﬁrst one.

2. Move the telescope to the given coordinates.

3. Take an image and store it.

4. Repeat.

A system like this still has some other things to take care of, e.g. open up at dusk (for night observations)
and close down at dawn – or when the weather gets bad. Any interruption (like daylight or rain) would just
delay the selection of the next target. While very simple, this kind of system is suitable for many types of
observations. There is no module implementing a survey mode in pyobs, but it could easily be added with
very few lines of new code, specialized on the use case at hand.

This ”survey mode” is also easily extendable, e.g., add an exposure time and a ﬁlter to the table of targets
and set them before starting the exposure. However, the targets would still be observed in the order that they
appear in the table. Therefore, the next step might be to ﬁlter the table of targets by visibility and sort it by
some kind of priority. If we do that every time the system is idle, we get some kind of ”just-in-time” (JIT)
scheduler, always picking the next target when needed, but never planning further ahead. Some control
systems, like the one for STELLA on Tenerife (Granzer et al., 2012), developed this idea further and have
been using it successfully for years. A JIT scheduler can be very powerful, because it can easily adapt to
changing observing conditions like seeing or transparency and picks its next target accordingly.

14 http://nova.astrometry.net

This is a provisional ﬁle, not the ﬁnal typeset article

26

Husser et al.

pyobs

There is, however, one major disadvantage for these kind of systems: selecting only the next targets
means there is no full plan for the night (or day), so it may be difﬁcult to impossible to predict, whether
a speciﬁc target will be observed or not. It may even be difﬁcult to decide, which parameters need to
be changed in order to make sure the observation will take place. Furthermore, the selection of targets
may never be ”optimal”, i.e. it is challenging to ﬁll the observing time with the best possible targets. For
example, take an object A that can be observed at the beginning and at the end of the night (maybe a transit
event). Another object B can only be observed at the beginning of the night. Even if A has a higher priority,
it might be better to observe B ﬁrst and then A at the end of the night.

An astronomer, going on an observing run, would probably plan the nights in advance and make a
schedule, when to observe which target. This is an optimizing problem and so we can call these kinds of
schedules ”optimal”. This is a different approach to selecting targets and not as straightforward as the one
for JIT schedulers described before. Luckily, there are free schedulers available for use, e.g. the adaptive
scheduler developed by LCO15 and the Astropy-afﬁliated project astroplan, just to name two. In principle,
they all try to optimize the placement of observations for the whole night so that a given value is maximized,
e.g. the total observing time or something like the time-integrated priorities of the tasks.

While the LCO scheduler can run fully independent from pyobs, there is a module based on astroplan:
Scheduler. It takes schedulable tasks from a TaskArchive object, calculates a schedule, and writes
it to a TaskSchedule object. A TaskArchive simply holds a list of tasks (in the form of Task
objects) and returns them on request. The scheduler takes these tasks, converts them into astroplan’s
ObservingBlocks, applies given constraints, and starts the scheduler. The result is a time table, giving
start and end times for all scheduled tasks, which is passed to the TaskSchedule, storing it to be
accessed by the robotic telescope system.

All these three classes (TaskArchive, TaskSchedule, and Task) are abstract and need speciﬁc
implementations for a method to store tasks and schedule. The implementation coming with pyobs is one
tailored to be used with the LCO observing portal, but access to other task databases can easily be added.

Furthermore, this gives a simple framework for changing the used scheduler at a later time. The one
implemented in astroplan is a ”greedy” one, i.e. it schedules the task with the highest priority ﬁrst, then the
one with the next lower priority, and so on. While it ensures that the highest priority target is observed, this
is not true for all other targets. Thus, the result of a ”greedy” scheduler is still far away from an optimal
one. However, changing the actual scheduler will not affect the rest of the robotic system at all.

5.2 LCO observing portal

The central part of the LCO observing portal is a database, mainly storing tasks, schedules, and
observations, and a HTTP REST interface for accessing it – see details about the API on LCO’s developers
page16.

When the portal is set up correctly and running, a new account must be created with ”Staff” permissions to
access all the necessary endpoints. The security token for this account must be provided in the conﬁguration
of LcoTaskArchive and LcoTaskSchedule, which are the LCO-speciﬁc implementations of the
classes discussed above. They both make use of LcoTask that simply stores the JSON object returned
from the portal. These classes are enough to run the scheduler in connection with an LCO portal.

15 https://github.com/observatorycontrolsystem/adaptive_scheduler
16 https://developers.lco.global

Frontiers

27

Husser et al.

pyobs

Figure 8. Structure of a task in the LCO portal. While the green ﬁelds can occur only once, there can be
multiple entries for the yellow ﬁelds (Request, Conﬁguration, Window, InstrumentConﬁg).

Figure 8 shows the structure of a task in the LCO portal:

• The top-most element is a request group, which has a name and belongs to a proposal. It can contain

one or more requests.

• A request contains a location (i.e. the telescope to use), one or more observation windows and one or

more conﬁgurations.

• A conﬁguration stores settings for acquisition and guiding, observing constraints (airmass, moon

distance, etc.), the target information and one or more instrument conﬁgurations.

• Finally, an instrument conﬁguration holds information like exposure time and count, and ﬁlter to use,

all depending on the selected instrument.

Each of these elements also contains an extra params ﬁeld, which can be used for any extra information
that is not supported by the default parameters.

Conﬁgurations have a type parameter, which will be important for running the task. The default
value for an imaging camera would usually be EXPOSE, which just exposes as many images as given
in the instrument conﬁguration. Another possibility is REPEAT EXPOSE, which loops all instrument
conﬁgurations, until a given repeat duration is reached. There are also other, more speciﬁc types,
like AUTO FOCUS for performing an auto-focus series.

5.3 Running tasks

With the schedule in place, we actually need to observe the tasks. In pyobs this is done by a
TaskRunner, which only has two methods: can run() checks, whether a given task can run right
now, and run task() actually executes it. For this, pyobs uses the concept of ”scripts”, which can be
fully customized in the runner section of a conﬁguration for a task runner. While the following will
concentrate on running tasks from an LCO portal, implementations for other task archives should be easily
implemented.

In the case of the LCO portal, the script to use is deﬁned by the conﬁguration type. A possible

conﬁguration might look like this:

runner:

class: pyobs.robotic.TaskRunner
scripts:
BIAS:

This is a provisional ﬁle, not the ﬁnal typeset article

28

Husser et al.

pyobs

class: pyobs.robotic.lco.scripts.LcoDefaultScript
camera: sbig6303e

EXPOSE:

class: pyobs.robotic.lco.scripts.LcoDefaultScript
telescope: telescope
filters: sbig6303e
camera: sbig6303e
roof: dome
acquisition: acquisition
autoguider: autoguider

This uses the same script (LcoDefaultScript in robotic.lco.scripts) for two different
conﬁguration types. The script checks internally, what kind of observation to perform. As usual, all
parameters in the conﬁguration are forwarded to the constructor of the given class – in this case all of them
are names of modules handling speciﬁc tasks. Note that a request can contain multiple conﬁgurations, and
each might use a different script and might be observable or not.

An LcoTask checks and runs all conﬁgurations in a request. The procedure that

the

LcoDefaultScript runs for a single conﬁguration looks like this:

• If the conﬁguration type is EXPOSE, which is a science observation, move the telescope to the given

coordinates.

• If a ﬁne acquisition is requested, do it.

• If guiding is requested, start it.

• Now loop all instrument conﬁgurations and for each set the ﬁlter and binning and take the given

number of images.

If the conﬁguration type is BIAS or DARK, this procedure would simplify to just taking images.

In the case of this LcoDefaultScript, the script needs to know about internals of the task that are
not available via the public interface of Task, so an LCO speciﬁc script is required. The same is true for the
auto-focus script LcoAutoFocusScript. On the other hand, there are some scripts that do not need any
information from the task and can therefore be run in any system, e.g. the SkyFlats script. When using
this in a LCO environment, the conﬁguration type SCRIPT is required and a special script LcoScript,
which evaluates a script parameter in the extra params of the conﬁguration to delegate execution to
another script. It can be conﬁgured like this:

runner:

class: pyobs.robotic.TaskRunner
scripts:

SCRIPT:

class: pyobs.robotic.lco.scripts.LcoScript
scripts:

skyflats:

class: pyobs.robotic.scripts.SkyFlats
[...]

Frontiers

29

Husser et al.

pyobs

Now, whenever the conﬁguration type is SCRIPT and the script is set to skyflats, the given script
SkyFlats is executed. The whole script system is designed to be as ﬂexible as possible and should allow
for writing custom scripts for any requirement.

For our solar telescope we also use a (modiﬁed) LCO portal, but the robotic mode is a lot simpler: there is
no scheduler, but the task archive just requests the schedulable blocks and returns the one with the highest
priority. This is possible, because all positions on the solar disc are visible as soon as the sun is up in the
sky. There is also a different default script that just moves the telescope and triggers the spectrograph.

5.4 The mastermind

Using the scripts system, building a central module that runs them becomes very simple – we call this
module the ”mastermind”. It creates a TaskSchedule and a TaskRunner from its conﬁguration and
then continuously gets the tasks from the former and executes them via the latter. It also sends events when
starting and ﬁnishing a task and writes information about the task into the FITS headers of the images.

The whole system is ﬂexible enough that we run two 1.2m and one 0.5m night telescope with it, as
well as a 0.5m solar telescope – however, for the last one the default scripts are not used (they use, e.g., a
different coordinate system) and even the LCO portal had to be adapted for this use case. Nevertheless, the
changes were minimal and we can use the same code base for all telescopes.

6 TELESCOPES

The Institute for Astrophysics and Geophysics in G¨ottingen (IAG) operates four telescopes, of which two
are located within the faculty building, one is in Texas, and the last one is in South Africa. In this section
we will describe the hardware for each one and their level of automation with pyobs.

6.1 IAG 50cm

The IAG 50cm is a Cassegrain telescope located on the roof of the institute with a main mirror with 0.5 m
diameter and a focus length of 5 m (f/10), housed in a classical rotating dome. The telescope is mainly
used for educational purposes and public outreach. With the use of pyobs we now also use the rare days of
good weather in G¨ottingen for science observations, but it is mainly a testing platform for the two MONET
telescopes (see below). The main instrument is a SBIG STL-6303E with a pixel scale of 0.55 ”/px (with a
focal reducer). Attached to the the telescope is a smaller 110mm f/7 refracting telescope with a ZWO ASI
071MC camera.

Dome,

telescope and focusing unit are running with ASCOM and are connected to pyobs via
pyobs-alpaca. The two cameras use their respective modules (pyobs-sbig and pyobs-asi).
The other modules that we use perform the following tasks (for all see Section 3):

• Fine acquisition with both of the cameras,
• auto-focus for the main telescope and camera,

• ﬂat-ﬁelding for both cameras,

• ﬁle cache and image writer and watcher,

• scheduler and mastermind for robotic mode,
• telegram bot,
• weather from a connected pyobs-weather (see Section 4.2) page.

This is a provisional ﬁle, not the ﬁnal typeset article

30

Husser et al.

pyobs

Figure 9. Left: Mid-resolution resolved Sun ﬁber setup for the VVT: The full image of the Sun is re-
imaged onto the ﬁber pickup mirror that is hosting a 525µm ﬁber (corresponding to a 32 arcsec ﬁeld of
view). The ﬁber leads to a Fourier-Transform-spectrograph. Behind the pickup mirror the light is again
re-imaged, this time onto the guiding camera which is used by pyobs for both pointing and guiding.
Right: CAD-model of the ﬁber-guiding unit for the 50 cm telescope. Starlight is re-imaged onto a ﬁber-
pickup mirror and the remaining light is redirected into the guiding camera, allowing for nearby stars to act
as guidestars.

The main telescope runs fully robotically with a copy of the LCO portal (shared with the MONET
telescopes), while the smaller telescope is not yet supported in this mode. We are currently working on
guiding with the small telescope and on implementing the necessary pointing model in pyobs. We are also
currently adding a ﬁber pick-up to transfer the light from the main telescope to a spectrograph in the optical
lab (see next section). For this, the guiding uses a camera from The Imaging Source pointed at the ﬁber pin
hole in a 45◦ mirror, which has already been tested (see Fig. 9, right).

6.2 IAG VVT

The Vakuum-Vertikalteleskop (VVT) consists of a siderostat on the top of the faculty building, redirecting
the light two stories down into the building, where the 0.5 m primary mirror is reﬂecting the light back
up one story and into the optical lab. It provides both a f/11 primary focus and a Gregory f/50 secondary
output.

There are a total of six observing modes for the telescope, with ﬁve of them using pyobs for pointing and
guiding using a custom module via an interface to its control system. These modes include different spatial
resolved observing modes (with ﬁeld of views between about 4 and 100 arcsec) and Sun-as-a-star integrated
light modes. As an example, Fig. 9 (left) shows a Zemax raytracing of the mid-resolution resolved Sun
ﬁber setup. The light from the primary mirror is collimated and re-imaged onto a ﬁber pickup mirror and
re-imaged a second time onto the CCD guiding camera that is used for acquisition and guiding via detecting
the solar disk.

The light entering the ﬁber is sent to our Fourier-Transform-spectrograph (FTS), a Bruker IFS 125HR
with a maximum resolving power of > 700, 000 at 600 nm. For the FTS, another custom module is used
for HTTP communication with a LabView instance, which in turn is connected to the instrument software
OPUS. For more details on the resolved Sun setup – see Sch¨afer et al. (2020b), and for more details on the
coupling into the FTS see Sch¨afer et al. (2020a). We are currently commissioning the fully robotic mode,
based on a modiﬁed LCO portal, which now accepts coordinates in the Stonyhurst Heliographic system
(HGS).

Frontiers

31

Husser et al.

pyobs

Figure 10. List of all pyobs modules that are currently running at MONET/S and how they are distributed
to four different computers. Marked in green are those modules that are available in pyobs-core or one of
the additional packages. The three other modules are custom implementations for the given hardware.

6.3 MONET/N

The two MONET Alt/Az telescopes (Hessman, 2001; Bischoff et al., 2006) have (almost) identical
hardware with a 1.2 m main mirror at f/7. They were optimized for fast operations with up to 10◦/s on both
axes and therefore also have a clam-shell roof that opens completely. The northern telescope, MONET/N,
is located at McDonald Observatory in Western Texas, USA. Its science camera will soon be replaced
with a FLI KL4040 and we are in the process of designing a ﬁber-fed high resolution spectrograph for
high-precision radial velocity observations of G-type stars on the m/s-level.

The level of automation is about the same as for the IAG 50cm, with the exception of the piggyback

telescope.

6.4 MONET/S

With MONET/S, located at the South African Astronomical Observatory (SAAO) near Sutherland, South
Africa, having mostly the same hardware as MONET/N, there are still some differences. The science
camera is currently a FLI PL230 and there is a 0.25 m f/8 piggyback telescope mounted at the (unused)
second Nasmyth port, with a SBIG STX-8300M camera attached to Gemini derotator. Furthermore, outside
the ﬁeld of view of the main camera we installed a pickup for a ﬁber bundle leading to MORISOT, a
low-budget, low-resolution spectrograph.

Again, the level of automation is similar to its twin in Texas and the IAG 50cm. Figure 10 shows an
illustration of all pyobs module running at MONET/S, how they are distributed over several computers,
and how they are connected to the actual hardware. As one can see, there is an additional module for the
derotator of the piggyback telescope that we will publish as soon as it is fully tested. Acquisition (with an
offset) and guiding of the spectrograph is supposed to be done with the science camera, and we hope to be

This is a provisional ﬁle, not the ﬁnal typeset article

32

Husser et al.

pyobs

able to do parallel photometry of the target with the piggyback. The custom module for the roof simply
calls HTTP REST endpoints on our roof controller, and BonnShutter continuously checks the health of
our Bonn shutter, and resets it, if any error occurs.

When everything is ﬁnished, there will probably be three modules for acquisition (one for each instrument)
and three modules for guiding: science-frame auto-guiding on the main camera, guiding via piggyback, and
guiding via science camera for the spectrograph. There will also be auto-focusing for both telescopes and
ﬂat-ﬁelding for all three instruments. A challenge will be to calibrate all three instruments during twilight,
but with the ﬂexible scripts in the robotic part of pyobs, this should not be too much of a problem.

7 SUMMARY & OUTLOOK

In this paper we presented the observation control system pyobs. While pyobs itself is written in Python
and highly depends on third-party packages, it can easily be extended by any programming language that
supports the communication protocol XMPP. We showed that pyobs is highly customizable due to its
conﬁguration ﬁles, and provides a lot of functionality for robotic telescope operations out of the box: it has
support for common tasks like ﬂat-ﬁelding and auto-focus series and connects to the open-source LCO
observation portal for organizing tasks.

At the time of writing this paper, pyobs is available in version 0.17. As the leading zero suggests, we do
not believe that it has reached a stable state, in which no major changes to any of its system will happen in
the near future. However, at least the currently planned modiﬁcations are mostly minor, and we expect to
publish a ﬁrst release this year or soon thereafter – so this should not keep anyone from using pyobs before
that.

The list of planned improvements for the core of pyobs is long, but contains mostly minor items, which

probably will not affect running systems. Some of the more major ones are:

• The error handling (see Section 2.6) is quite new and not used everywhere. It is missing, especially, in

the robotic modules.

• Some access control will be added, so that a module can allow some of its methods to be called only

by authorized clients.

• There already exist a few unit tests for the core package, but they are not covering everything, not even

the most important parts.

• New interfaces (see Section 2.1.2) will be added – e.g. for supporting to track non-sidereal targets –,

which might make it necessary to change existing ones.

While these items are for the core system, future development will mainly concentrate on additional
modules. For instance, we would like to guide using a guiding telescope, which would require applying
some pointing model to the offsets in order to compensate for different movements of the telescopes like
bending and (thermal) stretching. We would also like to add a wrapper to the PHD2 guiding software,
which would allow us to use this well-tested package in addition to our own guiding modules. Furthermore,
as mentioned in Section 5.1, a new (non-greedy) scheduler is high up on the wish list.

Using existing software was the goal for pyobs from the beginning. Instead of developing code from
scratch it was built on top of widely used Python packages from the astronomical community and beyond.
With pyobs-alpaca we already showed that we can bridge towards other protocols, and there probably
will be a wrapper for INDI as well, which we can use to add devices for which an INDI driver already

Frontiers

33

Husser et al.

pyobs

exists. There is also a plan to add wrappers for client software like Stellarium17 or KStars,18 that will make
accessing a remote system easier, e.g. for students.

We will continue developing pyobs mainly for our own telescopes, but always trying to be as general as
possible, so that it can be used by other observatories. The documentation is a good place to start playing
around with pyobs and will be extended continuously. The author of this paper is looking forward to any
contribution to pyobs, any comment and suggestion for improvement, and any question via email or GitHub
issue tracker.

AUTHOR CONTRIBUTIONS

FVH, the former PI of MONET, developed a few of the device modules and gave helpful input for the big
picture. KR and SM worked on adapting pyobs for the solar telescope. TM implemented the auto-guiding
for single stars. SS is the PI of the FTS and responsible for a long list of feature requests and suggestions
for improvements.

ACKNOWLEDGMENTS

The development of pyobs and its modules was only possible by using several Python packages (in
alphabetical order):

• aiohttp, an asynchronous HTTP Client/Server for asyncio and Python.19
• astroplan, an open source Python package to help astronomers plan observations (Morris et al., 2018).
• Astropy,20 a community-developed core Python package for Astronomy (Astropy Collaboration et al.,

2013, 2018).

• Astroquery, a set of tools for querying astronomical web forms and databases (Ginsburg et al., 2019).
• asyncinotify, an async python inotify package.21
• ccdproc, an Astropy package for image reduction (Craig et al., 2017).
• Cython, an optimising static compiler for the Python programming language.22
• lmﬁt, Non-Linear Least-Squares Minimization and Curve-Fitting for Python.(Newville et al., 2021)
• matplotlib, a comprehensive library for creating static, animated, and interactive visualizations in

Python.23

• numpy, a fundamental package for scientiﬁc computing with Python (Harris et al., 2020).

• pandas, an open source data analysis and manipulation tool (pandas development team, 2020; Wes

McKinney, 2010).

• Paramiko, a pure-Python implementation of the SSHv2 protocol.24

17 http://stellarium.org
18 https://edu.kde.org/kstars/
19 https://docs.aiohttp.org/
20 http://www.astropy.org
21 https://asyncinotify.readthedocs.io/
22 https://cython.org
23 https://matplotlib.org
24 https://www.paramiko.org/

This is a provisional ﬁle, not the ﬁnal typeset article

34

Husser et al.

pyobs

• Photutils, an Astropy package for detection and photometry of astronomical sources (Bradley et al.,

2020).

• py-expression-eval, a Python mathematical expression evaluator.25
• PyQt5, a set of Python bindings for Qt application framework.26
• python-aravis, a Pythonic interface to the auto-generated aravis bindings.27
• python-daemon, Python library to implement a well-behaved Unix daemon process.28
• python-telegram-bot, a Python wrapper for using Telegram.29
• python-zwoasi, a Python binding to the ZWO ASI version 2 library..30
• PyYAML, a full-featured YAML framework for the Python programming language.31
• qasync, an implementation of the PEP 3156 event-loop to be used in PyQt applications.32
• scipy, a package for fundamental algorithms for scientiﬁc computing in Python (Virtanen et al., 2020).

• SEP, a Python and C library for Source Extraction and Photometry (Barbary, 2016; Barbary et al.,

2017), based on Source Extractor (Bertin and Arnouts, 1996).

• single-source, a single source of truth for version and name of a project.33
• Slixmpp, an XMPP library for Python 3.7+.34148 x 57 x 157

Some more packages are currently used by pyobs but not mentioned here, since they are going to be

replaced soon. The GUI uses icons from the ”Crystal Clear” set.35

Running our own instance of the LCO Observation Portal as well as connecting it to pyobs was made
possible with the help of the great team at Las Cumbres Observatory (LCO). We also use parts of the
frontend of their science archive. Both are parts of the LCO Observatory Control System (OCS).36

REFERENCES

Akerlof, C. W., Kehoe, R. L., McKay, T. A., Rykoff, E. S., Smith, D. A., Casperson, D. E., et al. (2003).

The ROTSE-III Robotic Telescope System. PASP 115, 132–140. doi:10.1086/345490

Alcock, C., Axelrod, T. S., Bennett, D. P., Cook, K. H., Park, H. S., Griest, K., et al. (1992). The search for
massive compact halo objects with a (semi) robotic telescope. In Robotic Telescopes in the 1990s, ed.
A. V. Filippenko. vol. 103 of Astronomical Society of the Paciﬁc Conference Series, 193–202

Antonelli, L. A., Zerbi, F. M., Chincarini, G., Ghisellini, G., Rodon`o, M., Tosti, G., et al. (2003).
The REM telescope: a robotic facility to monitor the prompt afterglow of gamma ray bursts.
Mem. Soc. Astron. Italiana 74, 304

25 https://github.com/AxiaCore/py-expression-eval/
26 https://www.riverbankcomputing.com/software/pyqt/
27 https://github.com/SintefManufacturing/python-aravis
28 https://pagure.io/python-daemon/
29 https://github.com/python-telegram-bot/python-telegram-bot
30 https://github.com/python-zwoasi/python-zwoasi
31 https://pyyaml.org
32 https://github.com/CabbageDevelopment/qasync
33 https://github.com/rabbit72/single-source
34 https://slixmpp.readthedocs.io/
35 https://commons.wikimedia.org/wiki/Crystal_Clear
36 https://observatorycontrolsystem.github.io/

Frontiers

35

Husser et al.

pyobs

Table 1. List of available modules in the core package and in external packages.

Core package (pyobs.modules.)

Package
Module
camera
DummyCamera
camera
DummySpectrograph
flatfield
FlatField
flatfield
FlatFieldPointing
flatfield
FlatFieldScheduler
focus
FocusModel
focus
FocusSeries
image
ImageWatcher
image
ImageWriter
image
Seeing
pointing
AutoGuiding
Acquisition
pointing
ScienceFrameGuiding pointing
pointing
DummyAcquisition
pointing
DummyGuiding
robotic
Mastermind
robotic
PointingSeries
robotic
Scheduler
roof
DummyRoof
telescope
DummyTelescope
utils
AutonomousWarning
utils
HttpFileCache
utils
Kiosk
utils
Telegram
utils
Trigger
weather
Weather

Description
Dummy camera for testing
Dummy spectrograph for testing
Taking a ﬂat-ﬁeld series
Pointing for ﬂat-ﬁelds
Scheduler for ﬂat-ﬁelds
Temperature model for focus
Auto-focus series
Watch directory for new images
Write new images to disk
Measure seeing in images
Auto-guiding with external camera
Fine acquisition
Auto-guiding with science camera
Dummy acquisition for testing
Dummy guiding for testing
Main robotic module
Automated pointing series
Task scheduler
Dummy roof for testing
Dummy telescope for testing
Acoustic warning in robotic mode
File cache
Take images and publish on website
Telegram interface
Event trigger
Connection to pyobs-weather

External packages

Module
AlpacaTelescope
AlpacaFocuser
AlpacaDome
AravisCamera
AsiCamera
AsiCoolCamera
FliCamera
GUI
Pilar
SbigCamera
SbigFilterCamera
Sbig6303eCamera

Description

Package
pyobs alpaca Telescope connected via ASCOM Alpaca
pyobs alpaca Focus unit connected via ASCOM Alpaca
pyobs alpaca Dome connected via ASCOM Alpaca
pyobs aravis Aravis network cameras
pyobs asi
pyobs asi
pyobs fli
pyobs gui
pyobs pilar
pyobs sbig
pyobs sbig
pyobs sbig

ZWO ASI cameras
ZWO ASI cameras with active cooling
FLI cameras
Graphical user interface for remote access
Pilar telescopes
SBIG cameras
SBIG cameras with ﬁlter wheel
SBIG 6303e

Astropy Collaboration, Price-Whelan, A. M., Sip˝ocz, B. M., G¨unther, H. M., Lim, P. L., Crawford, S. M.,
et al. (2018). The Astropy Project: Building an Open-science Project and Status of the v2.0 Core Package.
AJ 156, 123. doi:10.3847/1538-3881/aabc4f

Astropy Collaboration, Robitaille, T. P., Tollerud, E. J., Greenﬁeld, P., Droettboom, M., Bray, E., et al.
(2013). Astropy: A community Python package for astronomy. A&A 558, A33. doi:10.1051/0004-6361/
201322068

This is a provisional ﬁle, not the ﬁnal typeset article

36

Husser et al.

pyobs

Barbary, K. (2016). Sep: Source extractor as a library. Journal of Open Source Software 1, 58. doi:10.

21105/joss.00058

[Dataset] Barbary, K., Boone, K., Craig, M., Deil, C., and Rose, B. (2017). kbarbary/sep: v1.0.2.

doi:10.5281/zenodo.896928

Bellm, E. C., Kulkarni, S. R., Barlow, T., Feindt, U., Graham, M. J., Goobar, A., et al. (2019). The Zwicky

Transient Facility: Surveys and Scheduler. PASP 131, 068003. doi:10.1088/1538-3873/ab0c2a

Bertin, E. and Arnouts, S. (1996). SExtractor: Software for source extraction. A&AS 117, 393–404.

doi:10.1051/aas:1996164

Bischoff, K., Tuparev, G., Hessman, F. V., and Nikolova, I. (2006). MONET/North: a very fast 1.2m
robotic telescope. In Society of Photo-Optical Instrumentation Engineers (SPIE) Conference Series, eds.
D. R. Silva and R. E. Doxsey. vol. 6270 of Society of Photo-Optical Instrumentation Engineers (SPIE)
Conference Series, 62701Q. doi:10.1117/12.671433

[Dataset] Bradley, L., Sip˝ocz, B., Robitaille, T., Tollerud, E., Vin´ıcius, Z., Deil, C., et al. (2020).

astropy/photutils: 1.0.0. doi:10.5281/zenodo.4044744

Castro-Tirado, A. J., Jel´ınek, M., Mateo Sanguino, T. J., de Ugarte Postigo, A., and BOOTES Team (2004).
BOOTES: A stereoscopic robotic ground support facility. Astronomische Nachrichten 325, 679–679.
doi:10.1002/asna.200410333

Chromey, F. R. and Hasselbacher, D. A. (1996). The Flat Sky: Calibration and Background Uniformity in

Wide Field Astronomical Images. PASP 108, 944. doi:10.1086/133817

[Dataset] Craig, M., Crawford, S., Seifert, M., Robitaille, T., Sip˝ocz, B., Walawender, J., et al. (2017).

astropy/ccdproc: v1.3.0.post1. doi:10.5281/zenodo.1069648

Filippenko, A. V., Li, W. D., Treffers, R. R., and Modjaz, M. (2001). The Lick Observatory Supernova
Search with the Katzman Automatic Imaging Telescope. In IAU Colloq. 183: Small Telescope Astronomy
on Global Scales, eds. B. Paczynski, W.-P. Chen, and C. Lemme. vol. 246 of Astronomical Society of the
Paciﬁc Conference Series, 121

Ginsburg, A., Sip˝ocz, B. M., Brasseur, C. E., Cowperthwaite, P. S., Craig, M. W., Deil, C., et al. (2019).
astroquery: An Astronomical Web-querying Package in Python. AJ 157, 98. doi:10.3847/1538-3881/
aafc33

Granzer, T. (2006). STELLA and RoboTel - a prototype for a robotic network? Astronomische Nachrichten

327, 792. doi:10.1002/asna.200610635

Granzer, T., Weber, M., and Strassmeier, K. G. (2012). The STELLA control system. In Astronomical
Society of India Conference Series. vol. 7 of Astronomical Society of India Conference Series, 247
Harris, C. R., Millman, K. J., van der Walt, S. J., Gommers, R., Virtanen, P., Cournapeau, D., et al. (2020).

Array programming with NumPy. Nature 585, 357–362. doi:10.1038/s41586-020-2649-2

Henry, G. W., Fekel, F. C., and Hall, D. S. (1995). An Automated Search for Variability in

Chromospherically Active Stars. AJ 110, 2926. doi:10.1086/117740

Hessman, F. V. (2001). MONET: a MOnitoring NEtwork of Telescopes. In IAU Colloq. 183: Small
Telescope Astronomy on Global Scales, eds. B. Paczynski, W.-P. Chen, and C. Lemme. vol. 246 of
Astronomical Society of the Paciﬁc Conference Series, 13

Hessman, F. V. (2004). The MONET project and beyond. Astronomische Nachrichten 325, 533–536.

doi:10.1002/asna.200410274

Hidas, M. G., Hawkins, E., Walker, Z., Brown, T. M., and Rosing, W. E. (2008). Las Cumbres Observatory
Global Telescope: A homogeneous telescope network. Astronomische Nachrichten 329, 269. doi:10.
1002/asna.200710950

Frontiers

37

Husser et al.

pyobs

Ivezi´c, ˇZ., Kahn, S. M., Tyson, J. A., Abel, B., Acosta, E., Allsman, R., et al. (2019). LSST: From Science
Drivers to Reference Design and Anticipated Data Products. ApJ 873, 111. doi:10.3847/1538-4357/
ab042c

Kub´anek, P., Jel´ınek, M., Nekola, M., Topinka, M., ˇStrobl, J., Hudec, R., et al. (2004). RTS2 - Remote
Telescope System, 2nd Version. In Gamma-Ray Bursts: 30 Years of Discovery, eds. E. Fenimore and
M. Galassi. vol. 727 of American Institute of Physics Conference Series, 753–756. doi:10.1063/1.
1810951

Lang, D., Hogg, D. W., Mierle, K., Blanton, M., and Roweis, S. (2010). Astrometry.net: Blind astrometric

calibration of arbitrary astronomical images. AJ 137, 1782–2800. ArXiv:0910.2233

Law, N. M., Kulkarni, S. R., Dekany, R. G., Ofek, E. O., Quimby, R. M., Nugent, P. E., et al. (2009).
The Palomar Transient Factory: System Overview, Performance, and First Results. PASP 121, 1395.
doi:10.1086/648598

Lipunov, V. M., Kornilov, V. G., Krylov, A. V., Kuvshinov, D. A., Gorbovskoy, E. S., Tyurina, N. V., et al.
(2007). Observations of gamma-ray bursts and a supernovae search at the robotic telescope MASTER.
Astronomical and Astrophysical Transactions 26, 79–86. doi:10.1080/10556790701300462

Morris, B. M., Tollerud, E., Sip˝ocz, B., Deil, C., Douglas, S. T., Berlanga Medina, J., et al. (2018). astroplan:
An Open Source Observation Planning Package in Python. AJ 155, 128. doi:10.3847/1538-3881/aaa47e
[Dataset] Newville, M., Otten, R., Nelson, A., Ingargiola, A., Stensitzki, T., Allan, D., et al. (2021).

lmﬁt/lmﬁt-py: 1.0.3. doi:10.5281/zenodo.5570790

[Dataset] pandas development team, T. (2020). pandas-dev/pandas: Pandas. doi:10.5281/zenodo.3509134
Perlmutter, S., Muller, R. A., Newberg, H. J. M., Pennypacker, C. R., Sasseen, T. P., and Smith, C. K.
(1992). A doubly robotic telescope: the Berkeley Automated Supernova Search. In Robotic Telescopes
in the 1990s, ed. A. V. Filippenko. vol. 103 of Astronomical Society of the Paciﬁc Conference Series,
67–71

Riddle, R., Cromer, J., Hale, D., Henning, J., Baker, J., Milburn, J., et al. (2018). The zwicky transient
facility robotic observing system (conference presentation). In Observatory Operations: Strategies,
Processes, and Systems VII, eds. A. B. Peck, C. R. Benn, and R. L. Seaman (SPIE). doi:10.1117/12.
2312702

Saint-Andre, P. (2004). Extensible Messaging and Presence Protocol (XMPP): Core. RFC 3920, RFC

Editor

Sch¨afer, S., Huke, P., Meyer, D., and Reiners, A. (2020a). Fiber-coupling of Fourier transform
spectrographs. In Ground-based and Airborne Instrumentation for Astronomy VIII, eds. C. J. Evans, J. J.
Bryant, and K. Motohara. International Society for Optics and Photonics (SPIE), vol. 11447, 784 – 795.
doi:10.1117/12.2561599

Sch¨afer, S., Royen, K., Zapke, A. H., Ellwarth, M., and Reiners, A. (2020b). Observing the integrated and
spatially resolved Sun with ultra-high spectral resolution. In Ground-based and Airborne Instrumentation
for Astronomy VIII, eds. C. J. Evans, J. J. Bryant, and K. Motohara. International Society for Optics and
Photonics (SPIE), vol. 11447, 2187 – 2208. doi:10.1117/12.2560156

Strassmeier, K. G., Bartus, J., Cutispoto, G., and Rodono, M. (1997). Starspot photometry with robotic
telescopes: Continuous UBV and V(RI) C photometry of 23 stars in 1991-1996. A&AS 125, 11–63.
doi:10.1051/aas:1997369

Street, R. A., Pollaco, D. L., Fitzsimmons, A., Keenan, F. P., Horne, K., Kane, S., et al. (2003). SuperWASP:
Wide Angle Search for Planets. In Scientiﬁc Frontiers in Research on Extrasolar Planets, eds. D. Deming
and S. Seager. vol. 294 of Astronomical Society of the Paciﬁc Conference Series, 405–408

This is a provisional ﬁle, not the ﬁnal typeset article

38

Husser et al.

pyobs

Virtanen, P., Gommers, R., Oliphant, T. E., Haberland, M., Reddy, T., Cournapeau, D., et al. (2020).
SciPy 1.0: Fundamental Algorithms for Scientiﬁc Computing in Python. Nature Methods 17, 261–272.
doi:10.1038/s41592-019-0686-2

Wes McKinney (2010). Data Structures for Statistical Computing in Python. In Proceedings of the 9th
Python in Science Conference, eds. St´efan van der Walt and Jarrod Millman. 56 – 61. doi:10.25080/
Majora-92bf1922-00a

Frontiers

39

