2
2
0
2

r
a

M
1
3

]

O
L
.
s
c
[

1
v
9
7
1
7
1
.
3
0
2
2
:
v
i
X
r
a

4DL: a four-valued Dynamic logic and its
proof-theory(cid:63)

Diana Costa

LASIGE, Faculdade de Ciências, Universidade de Lisboa, PT
dfdcosta@fc.ul.pt

Abstract. Transition systems are often used to describe the behaviour
of software systems. If viewed as a graph then, at their most basic level,
vertices correspond to the states of a program and each edge represents a
transition between states via the (atomic) action labelled. In this setting,
systems are thought to be consistent so that at each state formulas are
evaluated as either True or False.
On the other hand, when a structure of this sort – for example a map
where states represent locations, some local properties are known and
labelled transitions represent information available about diﬀerent routes
– is built resorting to multiple sources of information, it is common to
ﬁnd inconsistent or incomplete information regarding what holds at each
state, both at the level of propositional variables and transitions.
This paper aims at bringing together Belnap’s four values, Dynamic
Logic and hybrid machinery such as nominals and the satisfaction oper-
ator, so that reasoning is still possible in face of contradicting evidence.
Proof-theory for this new logic is explored by means of a terminating,
sound and complete tableaux system.

1

Introduction

In Computer Science, when one is uniquely interested in a program’s input-output
behaviour, one tends to regard the computation steps as instantaneous, discrete
state changes. These transition systems are usually viewed as graphs, whose
vertices correspond to states and labelled edges represent the transitions be-
tween those states, which result from performing a certain program. This sort
of systems is frequently modelled with recourse to Modal Logics [3], where each
program is associated with a modality. Furthermore, the extension to Proposi-
tional Dynamic Logic (PDL) [8,10] is well-known for allowing the construction
of complex programs based on atomic actions. Namely, PDL includes sequential
programs – α; β – to perform ﬁrst α then β, choice programs – α ∪ β – for
non-deterministically choosing between α or β, iteration programs – α∗ – to run
α a non-deterministically chosen number of times, and test programs – ϕ? – to
check that the formula ϕ is satisﬁable before proceeding (keep in mind that α
and β may themselves be complex programs!). PDL has proved to be valuable
in theoretical CS, Computational Linguistics and Artiﬁcial Intelligence.

(cid:63) Preprint submitted to Journal of Logic and Computation. March 2022

 
 
 
 
 
 
As ordinary in Modal Logics, formulas in PDL are also evaluated locally and
can only take one of two values: True or False. Classically, as is well-known, the
concepts “not True” and “False” are equivalent; gluts such as “True and False”
lead to explosion and gaps such as “neither True nor False” are not allowed. The
proposal of Belnap and Dunn consisted in admitting these scenarios, therefore
allowing each formula to take one of four (4) values: (only) True, (only) False,
Neither (True nor False) or Both (True and False) [1]. Belnapian logics are both
paraconsistent and paracomplete: the Principle of Explosion and the Principle
of Excluded Middle are both dismissed.

In recent works on paraconsistent versions of Modal, Hybrid and Dynamic
Logics it is often the case that only propositional variables are allowed to be
4-valued [12,4,6,15]. Versions of Modal Logic where both propositional variables
and accessibility relations are 4-valued seem to misbehave in extensions to Hy-
brid Logic [2]. In its simplest conﬁguration, Hybrid Logic adds to Modal Logic
a new set of propositional variables, called nominals, such that each holds at a
single state, thus naming it, and the satisfaction operator @, with which we can
jump to a designated state. Namely the value of a formula of the form @iϕ is
independent from the state where it is being evaluated; its value is the value of
ϕ in the state that is named by i.

The reason to claim that extensions of 4-valued Modal Logics misbehave
has to do precisely with the role of nominals in modal formulas. Assuming that
nominals act classically, i.e., are two-valued and each holds in a single state as
described, it would be expected that the value of the accessibility relation in the
pair (w, w(cid:48)) is the same as the value of the formula @i(cid:51)j, where i and j name
the states w and w(cid:48), respectively; formally, R(w, w(cid:48)) = V(@i(cid:51)j, −). However,
that is not typically the case; an example of a Modal Logic that would fail this
property in an extension to Hybrid Logic can be found in [14].

Usually Modal Logics where accessibility relations are many-valued, such as
[14], preserve the duality between modal operators, making the formulas (cid:51)¬ϕ
and ¬(cid:50)ϕ equivalent. The approach to negation when it appears directly before
modal operators seems to be repeatedly the same: rather than focusing on the
transition, the negation is carried towards the non-modal part of the formula,
which raises the question: if, in a 4-valued setting for propositional variables and
accessibility relations, a propositional variable and its negation are evaluated
independently, why are not modal formulas and their negations?

A core point of this paper is precisely the introduction of this novel approach
to the semantics of modal formulas and their negation. The general idea is that
when negation occurs directly before a modal operator it will directly aﬀect the
interpretation of the transition. In particular, the negation of modal formulas
is associated with evidence about the absence of transitions, whereas modal
formulas not involving negation before the modal operator are interpreted using
evidence about the presence of transitions. In 4HL, introduced in Section 2, the
formula ¬@i(cid:51)j expresses that there is not a transition from the state named
by i to the state named by j. It will no longer be regarded as equivalent to
the formula @i(cid:50)¬j, which in 4HL expresses that all transitions starting from i

end in a state diﬀerent from j. Notice the shift in perspective: the former talks
about absence of transitions; the latter, in opposition, talks about the presence
of transitions. The duality between modal operators will thus be abandoned.

The presence or absence of transitions is captured by decoupling the acces-
sibility relation into positive and negative versions, in an analogous fashion to
what is commonly accepted for propositional variables, with positive and neg-
ative valuations being used to interpret p and ¬p, respectively. Thus positive
accessibility relations will be used for the interpretation of formulas of the form
(cid:51)ϕ and (cid:50)ϕ, and negative accessibility relations will be used for the interpreta-
tion of formulas of the form ¬(cid:51)ϕ and ¬(cid:50)ϕ.

The logic 4HL, which will serve as basis for the dynamic version that appears
later on, incorporates paraconsistency (and paracompleteness) at the level of
propositional variables and accessibility relations and is such that models may
satisfy @ip and @i¬p simultaneously (or neither), as well as they may satisfy
both @i(cid:51)j and @i¬(cid:51)j (or neither).

Moving forward, the paper presents a dynamic extension of 4HL. Section
3 discusses the interpretation of the composition of actions with associated
4-valued relations in order to obtain the relations associated with the programs
of sequence, choice, iteration and test. The interpretation of positive relations
for each composite program follows traditional steps. This does not constitute a
surprise given that “positive” modal formulas (where negation does not appear
directly before the modal operator) are interpreted resorting to the positive
accessibility relation. Curiously, negative relations for composite programs are
thought of in terms of their complement but are otherwise analogous in construc-
tion. This strategy of resorting to the complement of the negative relation has
already been used in the completeness proof of other versions of Hybrid Logic
with 4-valued relations and non-dual modal operators, such as [7].

On Section 4, one can ﬁnd a sound and complete tableaux system for 4DL,

which combines techniques from PDL and Hybrid Logic.

In summary, one of the central ideas of the paper is that in a paraconsis-
tent environment where information about transitions may be inconsistent or
incomplete, there is an unbreakable link between negation and modal opera-
tors when they occur in this order. This, however, involves a trade-oﬀ, as to
do so the classical duality between modal operators has to be discarded. The
presence of nominals and the satisfaction operator is crucial to enable reference
to the state where propositional inconsistencies are present, as well as to pin-
point which pairs of states have inconsistent transitions. Those are the building
blocks of a 4-valued Hybrid Logic which is later extended to a dynamic version
where actions are composed. The latter is accompanied by a sound and complete
tableaux system.

2 4HL: a four-valued Hybrid Logic with non-dual modal

operators

This section explores the logic 4HL, a version of Hybrid Logic with 4-valued
interpretations of propositional variables and accessibility relations. Two sorts
of negation are considered: a classical one, ∼, so that ∼ϕ is read as it is not the
case that ϕ; and a paraconsistent one, ¬, such that ¬ϕ is read as ϕ is false. In
a paraconsistent environment such as 4HL the satisﬁability of these statements
is independent.

The language L consists of a set of nominals Nom, a set of propositional vari-
ables Prop, a nullary connective ⊥, unary connectives ¬, [π], (cid:104)π(cid:105), where π ∈ Mod
and Mod is a set of modalities, and binary connectives ∧, ∨, →. The classical
negation of a formula, ∼ϕ, is deﬁned as ϕ → ⊥, (cid:62) is deﬁned as ∼⊥ and ϕ ↔ ψ
is deﬁned as (ϕ → ψ) ∧ (ψ → ψ); we will sometimes resort to these abbreviations
in order to simplify notation. Form is the set of formulas over L.

Deﬁnition 1 (Model). A model M is a tuple (W, (R+
V−), where:

π )π∈Mod, (R−

π )π∈Mod, N, V+,

π and R−

π are binary relations over W2, called respectively the positive/

W (cid:54)= ∅ is the domain of states (also known as worlds);
R+
negative π-accessibility relation, for each modality π;
N : Nom → W is a hybrid nomination, a function that assigns nominals to
elements in W; N(i) is the element of W named by i;
V+ and V− are hybrid valuations, both with domain Prop and range P(W),
such that V+(p) is the set of states where the propositional variable p holds,
and V−(p) is the set of states where ¬p holds.

(cid:22)
(cid:22)

(cid:22)

(cid:22)

To put it simply, V±(p) is the set of states where there is evidence that p
is the set of pairs of states for which there is

is true/false. Analogously, R±
π
evidence about the existence/absence of a π-transition.

Deﬁnition 2 (Satisfaction). A satisfaction relation |= between a model M, a
state w and a formula ϕ is deﬁned by structural induction on ϕ in Figure 1.

We say that a formula ϕ is globally satisﬁed if M |= ϕ, i.e., M, w |= ϕ for
all w ∈ W; a formula is valid, |= ϕ, if it is globally satisﬁed in all models. Two
formulas are equivalent, denoted ϕ ≡ ψ, if for every model M and every state
w, M, w |= ϕ if and only if M, w |= ψ; two formulas are 4-equivalent, denoted
ϕ ≡4 ψ if ϕ ≡ ψ and ¬ϕ ≡ ¬ψ.

We read M, w |= ϕ/¬ϕ as “in the model M there is information that at state w
π )c denotes the complement

the formula ϕ is true/false”. In terms of notation, (R±
of the relation R±
π

Observe that the classical duality between modal operators does not hold
for the paraconsistent negation ¬. A quick look at the semantics in Figure 1 is
enough to check that ¬(cid:104)π(cid:105)ϕ (cid:54)≡ [π]¬ϕ and (cid:104)π(cid:105)¬ϕ (cid:54)≡ ¬[π]ϕ. The reason behind
this is the fact that the semantics for what we will call positive modal formulas

in W2.

(i) M, w |= p ⇔ w ∈ V+(p); M, w |= ¬p ⇔ w ∈ V−(p);
(ii) M, w |= i ⇔ w = N(i); M, w |= ¬i ⇔ w (cid:54)= N(i);
(iii) M, w |= ⊥ never; M, w |= ¬⊥ always;
(iv) M, w |= ¬¬ϕ ⇔ M, w |= ϕ;
(v) M, w |= ϕ ∧ ψ ⇔ M, w |= ϕ and M, w |= ψ;

M, w |= ¬(ϕ ∧ ψ) ⇔ M, w |= ¬ϕ or M, w |= ¬ψ;
(vi) M, w |= ϕ → ψ ⇔ M, w |= ϕ implies M, w |= ψ;

M, w |= ¬(ϕ → ψ) ⇔ M, w (cid:54)|= ¬ϕ and M, w |= ¬ψ;

(vii) M, w |= ϕ ∨ ψ ⇔ M, w |= ϕ or M, w |= ψ

M, w |= ¬(ϕ ∨ ψ) ⇔ M, w |= ¬ϕ and M, w |= ¬ψ

(viii) M, w |= (cid:104)π(cid:105)ϕ ⇔ ∃w(cid:48)(wR+

π w(cid:48) and M, w(cid:48) |= ϕ);

M, w |= ¬(cid:104)π(cid:105)ϕ ⇔ ∀w(cid:48)(w(R−

π )cw(cid:48) implies M, w(cid:48) |= ¬ϕ);

(ix) M, w |= [π]ϕ ⇔ ∀w(cid:48)(wR+

π w(cid:48) implies M, w(cid:48) |= ϕ);

M, w |= ¬[π]ϕ ⇔ ∃w(cid:48)(w(R−

π )cw(cid:48) and M, w(cid:48) |= ¬ϕ);

(x) M, w |= @iϕ ⇔ M, w(cid:48) |= ϕ, where w(cid:48) = N(i);

M, w |= ¬@iϕ ⇔ M, w(cid:48) |= ¬ϕ, where w(cid:48) = N(i).
Fig. 1: Deﬁnition of the satisfaction relation M, w |= ϕ for 4HL.

– formulas of the form (cid:104)π(cid:105)ϕ or [π]ϕ – relies on evidence about the presence of
transitions, whereas for negative modal formulas – formulas of the form ¬(cid:104)π(cid:105)ϕ
or ¬[π]ϕ – it relies on evidence about the absence of transitions. In 4HL modal
formulas are interpreted roughly as follows:

(cid:22)

(cid:22)

(cid:22)

(cid:22)

π N(j).

(cid:104)π(cid:105)ϕ is intuitively interpreted as it is possible to reach ϕ at least true.
The formula @i(cid:104)π(cid:105)j holds in a model if and only if there is evidence of a
π-transition from the state named by the nominal i to the state named by
the nominal j, i.e., N(i)R+
[π]ϕ is intuitively interpreted as it is mandatory to reach ϕ at least true.
The formula @i[π]¬j holds if and only if all evidence about the existence of
π-transitions from the state named by the nominal i lead towards a state w(cid:48)
which is not named by j; therefore N(i)(R+
¬(cid:104)π(cid:105)ϕ is intuitively interpreted as it is not possible to reach ϕ at most true.
This formula holds when, for all states w where ¬ϕ does not hold (i.e. where
ϕ may be at most true) there is evidence about the absence of a π-transition
from the current state to w.
The formula @i¬(cid:104)π(cid:105)j holds if and only if there is evidence that there is no
π-transition from the state named by the nominal i to the state named by
the nominal j, i.e., N(i)R−
¬[π]ϕ is intuitively interpreted as it is not necessary to reach ϕ at most true.
This formula holds if there are states where, even though ϕ is false, there
is no evidence that the π-transition from the current state towards there is
missing.

π )cN(j).

π N(j).

The formula @i¬[π]¬j holds if and only if there is no evidence that there is
no π-transition from the state named by the nominal i to the state named
by the nominal j, i.e., N(i)(R−

π )cN(j).

It is however the case that ∼(cid:104)π(cid:105)ϕ ≡4 [π]∼ϕ and (cid:104)π(cid:105)ϕ ≡4 ∼[π]∼ϕ (keep this
observation in mind as it will play an important role soon). Furthermore, even
though the accessibility relations are 4-valued, 4HL is a normal logic, i.e. the
K-axiom [π](ϕ → ψ) → ([π]ϕ → [π]ψ) is valid.

In general, (cid:54)|= ∼ϕ → ¬ϕ and (cid:54)|= ¬ϕ → ∼ϕ, since the notions “not true” and
“false” are independent in this framework. The exception are pure formulas, i.e.
those which involve only nominals, which still behave classically. Also, in general,
∼¬ϕ (cid:54)≡ ϕ (if it is not the case that ϕ is false, then ϕ is not necessarily true) and
¬∼ϕ (cid:54)≡ ϕ; nonetheless ¬∼ϕ ≡4 ∼¬ϕ.

Let us at last brieﬂy address the choice for the connective →. While → is nei-
ther the strong implication nor the weak implication found in literature ([13,14]
among many others), it appears very naturally here. Note that M, w |= ϕ → ψ
is interpreted as an “actual” implication, i.e., if and only if M, w |= ϕ implies
M, w |= ψ. This is not an unusual approach; in fact, it mimics weak implica-
tion. Given that the “positive” implication is commonly accepted, observe that
M, w |= ∼ϕ if and only if M, w (cid:54)|= ϕ. Thus ϕ → ψ ≡ ∼ϕ ∨ ψ. If we force the
paraconsistent negation on both sides, we get ¬(ϕ → ψ) ≡ ¬(∼ϕ ∨ ψ), which by
simple inspection of the semantics and the previous comments about ∼ and ¬
yields that ¬(ϕ → ψ) ≡ ∼¬ϕ ∧ ¬ψ.

The use of both ∼ and ¬ allows us to express Belnap’s four truth-values of

a formula ϕ in a model M easily:

– ϕ is only True at w: M, w |= ϕ ∧ ∼¬ϕ;
– ϕ is only False at w: M, w |= ¬ϕ ∧ ∼ϕ;
– ϕ is Both true and false at w: M, w |= ϕ ∧ ¬ϕ;
– ϕ is Neither true nor false at w: M, w |= ∼ϕ ∧ ∼¬ϕ.

The presence of the satisfaction operator and nominals is enough to make
it possible to describe named models (where all states are named by at least
one nominal) in 4HL by the set of basic formulas that hold there, a method
known as diagram in classical Hybrid Logic. Since there is no direct relationship
between the satisﬁability of a propositional variable and its negation and between
evidence about the presence and absence of transitions, diagrams are required
to contain more than (Hybrid Logic’s) atoms. Formally:

Deﬁnition 3. Consider the set of irreducible information I = {@ip, @i¬p,
@i(cid:104)π(cid:105)j, @i¬(cid:104)π(cid:105)j, @ij | i, j ∈ Nom, p ∈ Prop, π ∈ Mod}. The diagram of a
named model M is the following set:

Diag(M) = {a ∈ I s.t. M |= a}.

The following example illustrates this notion:

Example 1. Consider
the model M = (W = {w1, w2, w3, w4, w5},
R+ = {(w1, w2), (w4, w3)}, R− = {(w1, w2), (w1, w3)}, N : (i (cid:55)→ w1, j (cid:55)→ w2,
k (cid:55)→ w3, l (cid:55)→ w4, m (cid:55)→ w5), V+ : (p (cid:55)→ {w2, w4}, q (cid:55)→ ∅), V− : (p (cid:55)→ {w4},
q (cid:55)→ {w3})), represented in Figure 2.

Fig. 2: A sketch of model M: full lines indicate info. about the presence of a
transition, dashed lines indicate info. about the absence of a transition.

The diagram of M comes as follows:

Diag(M) = {@i(cid:51)j, @l(cid:51)k,

@i¬(cid:51)j, @i¬(cid:51)k,
@jp, @k¬q, @lp, @l¬p,
@ii, @jj, @kk, @ll, @mm} info. about equalities between states

info. about presence of transitions
info. about absence of transitions
info. about local properties

We say that ψ is a global consequence of a set of formulas Γ , denoted Γ |=g ψ,
if for all models M, if M |= Γ then M |= ψ. We say that ψ is a local consequence
of a set of formulas Γ , denoted Γ |=(cid:96) ψ, if for every model M and state w, if
M, w |= Γ then M, w |= ψ. As is the case for the logic BK ([13]), the logic 4HL
does not enjoy the Deduction theorem for global consequence, i.e., it is not the
case that ϕ |=g ψ if and only if |= ϕ → ψ. However, note that both BK and
4HL enjoy the Deduction theorem for local consequence. For the remainder of
the paper, whenever it is mentioned that a formula is a consequence of a set of
formulas, we will be referring to the notion of global consequence.

The counter-example that serves to prove that BK is not closed under the
replacement rule is not a counter-example for 4HL (of course, it must be adapted
to the semantics in 4HL; the details are below). The replacement rule says that
if ϕ ↔ ψ is valid, then the formula χ(ϕ) ↔ χ(ψ) is valid as well. Both of the
formulas ¬(ϕ → ψ) ↔ (∼¬ϕ ∧ ¬ψ) and ¬¬(ϕ → ψ) ↔ ¬(∼ ¬ϕ ∧ ¬ψ) are valid
in 4HL. Clearly, this is a bi-product of the choice for the semantics of → that
has been made in this paper. Indeed, 4HL is closed under the replacement rule.
It is easier to check it under a 4-valued approach, so the details can be found in
the next subsection.

Recall also that, being a paraconsistent and paracomplete logic, the schemas
(ϕ ∧ ¬ϕ) → ⊥ and ϕ ∨ ¬ϕ are not valid. Nonetheless, the classical behaviour of

the negation ∼ makes it obvious that (ϕ ∧ ∼ϕ) → ⊥ and ϕ ∨ ∼ϕ are both valid
schemas.

A direct 4-perspective of 4HL

An alternative deﬁnition of model uses functions Rπ : W × W → 4 and
V : (Prop ∪ Nom) × W → 4, where 4 = {t, f, b, n} is the set of Belnapian truth
values: true, false, both true and false, and neither true nor false, respectively.
Formally:

Deﬁnition 4 (4-model). A 4-model M is a tuple (W, (Rπ)π∈Mod , V), where:

W (cid:54)= ∅ is the domain;
Rπ is an accessibility function such that Rπ : W ×W → 4 for each π ∈ Mod;
V is a valuation with domain (Prop ∪ Nom) × W and range 4 such that
V(i, w) = t for a unique w ∈ W and V(i, w(cid:48)) = f for every other state w(cid:48).

(cid:22)
(cid:22)
(cid:22)

Belnap’s four values may be arranged according to two partial orders: the
ﬁrst one, ≤t, reﬂects the “quality” of the information, whereas the second, ≤k,
reﬂects the “quantity” of information. The bilattice structure is represented in
Figure 3.

Fig. 3: The two orderings of Belnap’s bilattice.

Deﬁnition 5 (Satisfaction in 4-models). A satisfaction relation |=4 between a
4-model M, a state w and a formula ϕ is deﬁned as follows:

M, w |=4 ϕ ⇔ V(ϕ, w) ∈ {t, b}

where V is extended to all formulas as in Figure 4.

Globally satisﬁed and valid formulas are deﬁned as in Deﬁnition 2.

This direct approach puts in evidence the spontaneity of the choice for the se-
mantics of →-formulas. First, the semantics of diamond-formulas is structurally
the same as in the classical case. The semantics of box-formulas is constructed
resorting to the equivalence [π]ϕ ≡ ∼(cid:104)π(cid:105)∼ϕ (brieﬂy hinted at previously). By
analogy with the classical structure of the semantics of box-formulas, the use of

V(⊥, w) = f
V(¬ϕ, w) = ¬V(ϕ, w), where ¬t = f, ¬f = t, ¬b = b and ¬n = n
V(∼ϕ, w) = ∼V(ϕ, w), where ∼t = f, ∼f = t, ∼b = n and ∼n = b
V(ϕ ∧ ψ, w) = V(ϕ, w)

{V(ϕ, w), V(ψ, w)}

(cid:55)

V(ψ, w) = inf
≤t

V(ψ, w) = sup
≤t

V(ϕ ∨ ψ, w) = V(ϕ, w)

{V(ϕ, w), V(ψ, w)}

(cid:54)
V(ϕ → ψ, w) = V(ϕ, w) (cid:3) V(ψ, w) = ∼V(ϕ, w)
V(ψ, w)
V(@iϕ, w) = V(ϕ, w(cid:48)), where w(cid:48) is such that V(i, w(cid:48)) = t
V((cid:104)π(cid:105)ϕ, w) = sup
≤t
V([π]ϕ, w) = inf
≤t
= inf
≤t
= inf
≤t

(cid:55)
{∼(Rπ(w, w(cid:48))
{∼Rπ(w, w(cid:48))
{Rπ(w, w(cid:48)) (cid:3) V(ϕ, w(cid:48)), w(cid:48) ∈ W}

V(∼ϕ, w(cid:48))), w(cid:48) ∈ W}

V(ϕ, w(cid:48)), w(cid:48) ∈ W}

V(ϕ, w(cid:48)), w(cid:48) ∈ W}

{Rπ(w, w(cid:48))

(cid:55)

(cid:54)

(cid:54)

Fig. 4: Extension of a 4-valuation to formulas.

a new implication (as mentioned before, it diﬀers from the 4-valued weak and
strong implications in [13,14]) is thus justiﬁed. Obviously, → and ∧ constitute a
residuated pair in 4 with respect to ≤t.

Going back to the observation about the replacement rule, note that valid
formulas have value t. A formula ϕ ↔ ψ has value t if and only if the formulas
ϕ and ψ have exactly the same value (which is not the case for either weak nor
strong implication). Therefore, it is expected that χ(ϕ) ↔ χ(ψ) is valid as well.

Observe that for nominals i and j and an arbitrary state w,

where w(cid:48) and w(cid:48)(cid:48) are such that V(i, w(cid:48)) = V(j, w(cid:48)(cid:48)) = t.

V(@i(cid:104)π(cid:105)j, w) = Rπ(w(cid:48), w(cid:48)(cid:48)),

Deﬁnition 6 (Equivalent models). A model M and a 4-model M are equiva-
lent when their domains coincide and for all w, w(cid:48) ∈ W, π ∈ Mod, p ∈ Prop,
i ∈ Nom, the equivalences in Figure 5 hold.

Rπ(w, w(cid:48)) ∈ {t, b} ⇐⇒ (w, w(cid:48)) ∈ R+
π
Rπ(w, w(cid:48)) ∈ {f, b} ⇐⇒ (w, w(cid:48)) ∈ R−
π
V(p, w) ∈ {t, b} ⇐⇒ w ∈ V+(p)
V(p, w) ∈ {f, b} ⇐⇒ w ∈ V−(p)
V(i, w) = t
V(i, w) = f

⇐⇒ w = N (i)
⇐⇒ w (cid:54)= N (i)

Fig. 5: Requirements for the equivalence between a 4-model and a model.

The following result holds:

Lemma 1. For a model M and a 4-model M such that M and M are equivalent,
it is the case that:

M, w |=4 ϕ ⇔ M, w |= ϕ, for all ϕ ∈ Form.

4HL is closely related to the Double-Belnapian Hybrid Logic DBHL∗, for
which there is a terminating, sound and complete tableau system [7]. Even
though we will not provide details, we can construct an analogous system for
4HL by updating some of the rules of the calculus for DBHL∗.

3 4DL: a dynamic extension of 4HL

Usually what we call modalities in Modal and Hybrid Logics is designated as
atomic actions in a Dynamic Logic environment. We will follow that terminology
in this section and denote the set of atomic actions by Act and its elements by
a, b, c, etc. The language Ldyn is a variant of the language of 4HL, containing
two kinds of expressions, namely, programs α and formulas ϕ as follows:

α ::= a | α; α | α ∪ α | α∗ | ϕ?
ϕ ::= p | i | ⊥ | ¬ϕ | ϕ ∧ ϕ | ϕ ∨ ϕ | ϕ → ϕ | [α]ϕ | (cid:104)α(cid:105)ϕ

where a ∈ Act, p ∈ Prop, i ∈ Nom.

The program α; β is a sequential program that runs ﬁrst α, then β. The
program α ∪ β non-deterministically chooses between α and β. The program
α∗ iteratively runs α a non-deterministically chosen number of times. The test
program ϕ? veriﬁes if ϕ holds at the current state and if so, proceeds.

Deﬁnition 7 (Program interpretation). The positive interpretations of compos-
ite programs are built as follows:

R+
R+
R+
R+

α;β is the composition of R+
α∪β is the union of R+
α∗ is the reﬂexive transitive closure of R+
α ;
ϕ? is deﬁned as the set {(w, w) | M, w |= ϕ}.

α and R+
β ;
α and R+
β ;

As for negative interpretations, we deﬁne their complements; the following

(cid:22)
(cid:22)
(cid:22)
(cid:22)

constructions are actually analogous to the previous ones:

(R−
(R−
(R−
(R−

α;β)c is the composition of (R−
α∪β)c is the union of (R−
α∗ )c is the reﬂexive transitive closure of (R−
α )c;
ϕ?)c is deﬁned as the set {(w, w) | M, w (cid:54)|= ¬ϕ}.

α )c and (R−
β )c;

α )c and (R−

β )c;

(cid:22)
(cid:22)
(cid:22)
(cid:22)

It is straightforward to observe that the positive relations and the comple-
ment of negative relations associated with composite programs ; , ∪, −∗ are built
in exactly the same way as in classical PDL.

The positive and negative versions of the relation associated with the test pro-
gram however, hold a closer relation. These types of relation are not deﬁned with
respect to the accessibility relations, but instead depend on the local satisfaction
of a particular formula. Thus note that (R−

ϕ?)c = {(w, w) | w ∈ W}\R+

Semantics is easily adapted from Deﬁnition 2 to deal with the use of com-
posite programs in place of the modalities in modal formulas. So, for a model
a )a∈Act, N, V+, V−) (as in Deﬁnition 1, except that we update
(W, (R+
the terminology and use Act instead of Mod), semantics of modal formulas is
deﬁned as one would expect:

a )a∈Act, (R−

(¬ϕ)?

.

– M, w |= (cid:104)α(cid:105)ϕ ⇔ ∃w(cid:48)(wR+
– M, w |= ¬(cid:104)α(cid:105)ϕ ⇔ ∀w(cid:48)(w(R−
– M, w |= [α]ϕ ⇔ ∀w(cid:48)(wR+
– M, w |= ¬[α]ϕ ⇔ ∃w(cid:48)(w(R−

α w(cid:48) and M, w(cid:48) |= ϕ);

α )cw(cid:48) implies M, w(cid:48) |= ¬ϕ);

α w(cid:48) implies M, w(cid:48) |= ϕ);

α )cw(cid:48) and M, w(cid:48) |= ¬ϕ).
The interpretation of composite programs is such that the axioms of PDL

hold in 4DL, making it a truly Dynamic Logic.

Lemma 2. The following schemes hold in every model:

1. [α; β]ϕ ≡4 [α][β]ϕ
2. [α ∪ β]ϕ ≡4 [α]ϕ ∧ [β]ϕ
3. [ϕ?]ψ ≡4 ϕ → ψ
4. [α∗]ϕ ≡4 ϕ ∧ ([α][α∗]ϕ)

The derivations with (cid:104)−(cid:105) can also be veriﬁed:

1’. (cid:104)α; β(cid:105) ≡4 (cid:104)α(cid:105)(cid:104)β(cid:105)ϕ
2’. (cid:104)α ∪ β(cid:105)ϕ ≡4 (cid:104)α(cid:105)ϕ ∨ (cid:104)β(cid:105)ϕ
3’. (cid:104)ϕ?(cid:105)ψ ≡4 ϕ ∧ ψ
4’. (cid:104)α∗(cid:105)ϕ ≡4 ϕ ∨ ((cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ)
Proof. Let M be a model and w a state in W. Then:
1.

M, w |= [α; β]ϕ ⇐⇒ ∀w(cid:48)(wR+

α;βw(cid:48) implies M, w(cid:48) |= ϕ)

⇐⇒ ∀w(cid:48)(∃u(wR+
⇐⇒ ∀w(cid:48)(∀u(w(R+
⇐⇒ ∀u, w(cid:48)(w(R+
⇐⇒ ∀u(w(R+
⇐⇒ ∀u(wR+
⇐⇒ ∀u(wR+
⇐⇒ M, w |= [α][β]ϕ

α u and uR+
α )cu or u(R+
α )cu or u(R+
α )cu or ∀w(cid:48)(u(R+
α u implies ∀w(cid:48)(uR+
α u implies M, u |= [β]ϕ)

β w(cid:48)) implies M, w(cid:48) |= ϕ)
β )cw(cid:48)) or M, w(cid:48) |= ϕ)
β )cw(cid:48) or M, w(cid:48) |= ϕ)
β )cw(cid:48) or M, w(cid:48) |= ϕ))
β w(cid:48) implies M, w(cid:48) |= ϕ))

M, w |= ¬[α; β]ϕ ⇐⇒ ∃w(cid:48)(w(R−

α;β)cw(cid:48) and M, w(cid:48) |= ¬ϕ)
α )cu and u(R−
α )cu and u(R−
α )cu and ∃w(cid:48)(u(R−
α )cu and M, u |= ¬[β]ϕ)

⇐⇒ ∃w(cid:48)(∃u(w(R−
⇐⇒ ∃u, w(cid:48)(w(R−
⇐⇒ ∃u(w(R−
⇐⇒ ∃u(w(R−
⇐⇒ M, w |= ¬[α][β]ϕ

β )cw(cid:48)) and M, w(cid:48) |= ¬ϕ)
β )cw(cid:48) and M, w(cid:48) |= ¬ϕ)
β )cw(cid:48) and M, w(cid:48) |= ¬ϕ))

3.

4.

We skip 2. as it follows analogous steps.

M, w |= [ϕ?]ψ ⇐⇒ ∀w(cid:48)(wR+

ϕ?w(cid:48) implies M, w(cid:48) |= ψ)

⇐⇒ M, w |= ϕ implies M, w |= ψ
⇐⇒ M, w |= ϕ → ψ

M, w |= ¬[ϕ?]ψ ⇐⇒ ∃w(cid:48)(w(R−

ϕ?)cw(cid:48) and M, w(cid:48) |= ¬ψ)

⇐⇒ M, w (cid:54)|= ¬ϕ and M, w |= ¬ψ
⇐⇒ M, w |= ¬(ϕ → ψ)

M, w |= [α∗]ϕ ⇐⇒ ∀w(cid:48)(wR+

⇐⇒ (wR+

α∗ w(cid:48) implies M, w(cid:48) |= ϕ)
α∗ w implies M, w |= ϕ) and
α u and uR+

(∀w(cid:48)(∃u(wR+

α∗ w(cid:48)) implies M, w(cid:48) |= ϕ))

⇐⇒ M, w |= ϕ and ∀w(cid:48)(∃u(wR+
⇐⇒ M, w |= ϕ and ∀w(cid:48), u(w(R+
⇐⇒ M, w |= ϕ and ∀u(w(R+
⇐⇒ M, w |= ϕ and ∀u(wR+
⇐⇒ M, w |= ϕ and M, w |= [α][α∗]ϕ)
⇐⇒ M, w |= ϕ ∧ [α][α∗]ϕ)

α u and uR+
α )cu or u(R+
α )cu or ∀w(cid:48)(uR+
α u implies M, u |= [α∗]ϕ)

α∗ w(cid:48)) implies M, w(cid:48) |= ϕ)
α∗ )cw(cid:48) or M, w(cid:48) |= ϕ)
α∗ w(cid:48) implies M, w(cid:48) |= ϕ))

M, w |= ¬[α∗]ϕ ⇐⇒ ∃w(cid:48)(w(R−

α∗ )cw(cid:48) and M, w(cid:48) |= ¬ϕ)

⇐⇒ (w(R−

α∗ )cw and M, w |= ¬ϕ) or
α )cw(cid:48)(cid:48) and w(cid:48)(cid:48)(R−

∃w(cid:48), w(cid:48)(cid:48)(w(R−

⇐⇒ M, w |= ¬ϕ or ∃w(cid:48)(cid:48)(w(R−
⇐⇒ M, w |= ¬ϕ or M, w |= ¬[α][α∗]ϕ
⇐⇒ M, w |= ¬(ϕ ∧ [α][α∗]ϕ)

α∗ )cw(cid:48) and M, w(cid:48) |= ¬ϕ)
α )cw(cid:48)(cid:48) and M, w(cid:48)(cid:48) |= ¬[α∗]ϕ)

Consider the following example:

Example 2. Consider the model M represented in Figure 6. The following holds:

1. M |= @i[a ∪ b]p
2. M |= @i¬(cid:104)a; b(cid:105)(¬p ∧ q)
3. M |= @i(cid:104)a∗(cid:105)j
4. M |= @k¬[p?]q

The equivalences proved in Lemma 2 simplify the previous inferences as fol-

lows:

1. ⇐⇒ M |= @i[a]p ∧ @i[b]p
2. ⇐⇒ M |= @i¬(cid:104)a(cid:105)(cid:104)b(cid:105)(¬p ∧ q)
3. ⇐⇒ M |= @ij ∨ @i(cid:104)a(cid:105)(cid:104)a∗(cid:105)j
4. ⇐⇒ M |= @k¬(p → q)

Fig. 6: Graphic representation of the model M.

4 A tableau system for 4DL

This section introduces a terminating, sound and complete tableau system for
4DL and a decision procedure to verify if a formula is a (global) consequence
of a set of formulas. In particular, we can verify if a formula is valid if it is a
consequence of the empty set. But ﬁrst, it is necessary to ﬁx some notation. We
start by considering an extra-logical operator .− applied to formulas and which
acts on the satisfaction relation in the following sense: for a model M, a state w
and a formula ϕ ∈ Form(Ldyn),

and, analogously,

M, w (cid:13) ϕ− ⇔ M, w (cid:54)(cid:13) ϕ

M (cid:13) ϕ− ⇔ M (cid:54)(cid:13) ϕ.

It easy to check that M (cid:13) ϕ− if and only if ∃w ∈ W : M, w (cid:13) ϕ−.
For convenience we will call ϕ− a minus-formula, and the set Form•(Ldyn) =
Form(Ldyn) ∪ {ϕ− | ϕ ∈ Form(Ldyn)} the set of all signed formulas over Ldyn.
The tableau rules are clustered into two sets. First, we introduce rules for
regular and minus-formulas in Figure 7. Note that the rules directly dealing with
modal operators are only applicable if the program is atomic. The tableau rules
for modal formulas with composite programs can be found in Figure 8. Those
rules are written in a condensed format which should be interpreted as follows:
whenever the premise includes the red and/or blue parts, the conclusion should
include the red and/or blue parts accordingly. Take for example the condensed
rule (¬[α; β]−), from which we can extract the following four rules:

@i[α; β]ϕ
@i[α][β]ϕ

([α; β])

@i¬[α; β]ϕ
@i¬[α][β]ϕ

(¬[α; β])

(@i[α; β]ϕ)−
(@i[α][β]ϕ)− ([α; β]−)

(@i¬[α; β]ϕ)−
(@i¬[α][β]ϕ)− (¬[α; β]−)

The rules for the iteration program are an exception; they will play a crucial
role in determining the nature of a branch and require a special treatment which

shall be discussed in due time. These rules constitute our system, and a tableau
here is denoted by τ .

To put it simply, a tableau consists of a rooted tree, each node of which is
essentially a set of signed formulas. The initial (ﬁnite) set is constituted of what
we call root formulas. A branch is any path in the tree starting at the root. The
successors of a node result from the application of a rule to the formulas in the
branch to which it belongs. A node without successors is called a leaf. Branching
occurs when a rule splits the current branch into two.

The rules (@I), (Id), (Nom), ([a]), (¬(cid:104)a(cid:105)), ((cid:104)a(cid:105)−) and (¬[a]−) are called
non-destructive and the remaining ones are called destructive. This distinction is
made so that in the systematic tableau construction algorithm a destructive rule
is applied at most once to a formula (a destructive rule has exactly one formula
in the premise; the converse is not true). As in [5], the classiﬁcation of rules
as destructive and non-destructive corresponds to a classiﬁcation of formulas
according to their form.

Rules that introduce new nominals, ((cid:104)a(cid:105)), (¬[a]), (¬(cid:104)a(cid:105)−) and ([a]−), are

called existential rules.

Deﬁnition 8 (Fischer-Ladner closure). Let ϕ ∈ Form•(Ldyn). The Fischer-
Ladner closure of ϕ, denoted CL(ϕ), is the smallest set of formulas with the
following properties:

1. ϕ ∈ CL(ϕ) if ϕ ∈ Form(Ldyn);
2. if ϕ = ψ− then ψ ∈ CL(ϕ);
3. if ψ ∈ CL(ϕ) and ψ (cid:54)= ¬δ, then ¬ψ ∈ CL(ϕ);
4. if ¬ψ, ψ ∧ δ, ψ ∨ δ, ψ → δ, (cid:104)α(cid:105)ψ, [α]ψ, @iψ ∈ CL(ϕ) then ψ, δ ∈ CL(ϕ);
5. if (cid:104)α; β(cid:105)ψ ∈ CL(ϕ), respectively [α; β]ψ ∈ CL(ϕ), then (cid:104)α(cid:105)(cid:104)β(cid:105)ψ ∈ CL(ϕ),

respectively [α][β]ψ ∈ CL(ϕ);

6. if (cid:104)α ∪ β(cid:105)ψ ∈ CL(ϕ), respectively [α ∪ β]ψ ∈ CL(ϕ), then (cid:104)α(cid:105)ψ, (cid:104)β(cid:105)ψ ∈ CL(ϕ),

respectively [α]ψ, [β]ψ ∈ CL(ϕ);

7. if (cid:104)α∗(cid:105)ψ ∈ CL(ϕ), respectively [α∗]ψ ∈ CL(ϕ), then (cid:104)α(cid:105)(cid:104)α∗(cid:105)ψ ∈ CL(ϕ), re-

spectively [α][α∗]ψ ∈ CL(ϕ);

8. if (cid:104)δ?(cid:105)ψ ∈ CL(ϕ), respectively [δ?]ψ ∈ CL(ϕ), then ϕ∧ψ ∈ CL(ϕ), respectively

ϕ → ψ ∈ CL(ϕ).

Lemma 3 (Closure property). If @iψ ∈ τ , where ψ (cid:54)= j, (cid:104)a(cid:105)j, ¬[a]¬j for a ∈ Act,
j ∈ Nom, or if (@iψ)− ∈ τ , then either ψ ∈ CL(ϕ) or, in case ψ = ¬δ, δ ∈ CL(ϕ),
where ϕ is a root formula.

Proof. The proof can be obtained by checking each rule.

The following is a consequence of this result:

Corollary 1. For any tableau τ and nominal i, the following sets are ﬁnite:

Γi = {ϕ | @iϕ ∈ τ, where ϕ (cid:54)= (cid:104)a(cid:105)j, ¬[a]¬j, for j ∈ Nom, a ∈ Act}
Γ−
i = {ϕ | (@iϕ)− ∈ τ }

ϕ
@iϕ

(@I)(i)

@i@jϕ
@jϕ

(@E)

@i(ϕ ∧ ψ)
@iϕ
@iψ

(∧)

@i(ϕ ∨ ψ)
@iϕ @iϕ

(∨)

@i(ϕ → ψ)
(@iϕ)− @iψ

(→)

@i[a]ϕ, @i(cid:104)a(cid:105)j
@jϕ

([a])

@i¬@jϕ
@j¬ϕ

(¬@)

@i¬(ϕ ∧ ψ)
@i¬ϕ @i¬ψ

(¬∧)

((cid:104)a(cid:105))(ii)

@i(cid:104)a(cid:105)ϕ
@i(cid:104)a(cid:105)t
@tϕ

@i¬(ϕ ∨ ψ)
@i¬ϕ
@i¬ψ

(¬∨)

@i¬(ϕ → ψ)
(@i¬ϕ)−
@i¬ψ

(¬→)

@i¬[a]ϕ
@i¬[a]¬t
@t¬ϕ

(¬[a])(iii)

@i¬(cid:104)a(cid:105)ϕ, @i¬[a]¬j
@j¬ϕ

(¬(cid:104)a(cid:105))

@i¬¬ϕ
@iϕ

(¬¬)

@ij, @iϕ
@jϕ

(Nom)(iv)

(Id)(v)

@ii

(i) ϕ is not a satisfaction statement, i is in the branch;
(ii) ϕ /∈ Nom, t is a new nominal;
(iii) ϕ (cid:54)= ¬i for all i ∈ Nom, t is a new nominal;
(iv) for @iϕ a literal;
(v) for i in the branch.

ϕ−

(@tϕ)− (@−

I )(vi)

(a) Tableau rules for regular formulas.

(@i@jϕ)−
(@jϕ)− (@−
E )

(@i(ϕ ∧ ψ))−
(@iϕ)− (@iψ)− (∧−)

(@i(ϕ ∨ ψ))−
(@iϕ)−
(@iψ)−

(∨−)

(@i(ϕ → ψ))−
@iϕ
(@iψ)−

(→−)

(@i[a]ϕ)−
@i(cid:104)a(cid:105)t
(@tϕ)−

([a]−)(vii)

(@i(cid:104)a(cid:105)ϕ)−, @i(cid:104)a(cid:105)j
(@jϕ)−

((cid:104)a(cid:105)−)

(@i¬(@jϕ))−
(@j¬ϕ)−

(¬@−)

(@i¬(ϕ ∧ ψ))−
(@i¬ϕ)−
(@i¬ψ)−

(¬∧−)

(@i¬(ϕ ∨ ψ))−
(@i¬ϕ)− (@i¬ϕ)− (¬∨−)

(@i¬(ϕ → ψ))−
@i¬ϕ (@i¬ψ)− (¬→−)

(@i¬[a]ϕ)−, @i¬[a]¬j
(@j¬ϕ)−

(¬[a]−)

(@i¬(cid:104)a(cid:105)ϕ)−
@i¬[a]¬t
(@t¬ϕ)−

(¬(cid:104)a(cid:105)−)(vii)

(@i¬¬ϕ)−
(@iϕ)− (¬¬−)

(@iϕ)−
@i¬ϕ

(Id−)(viii)

(vi) ϕ is not a satisfaction statement, t is a new nominal;
(vii) t is a new nominal;
(viii) ϕ = j or ϕ = ¬j, where j ∈ Nom.

(b) Tableau rules for minus-formulas.

Fig. 7: Tableau rules. (1/2)

(@i¬([α; β]ϕ))−
(@i¬([α][β]ϕ))− (¬[α; β]−)

(@i¬((cid:104)α; β(cid:104)ϕ))−
(@i¬((cid:104)α(cid:105)(cid:104)β(cid:105)ϕ))− (¬(cid:104)α; β(cid:105)−)

(@i¬([α ∪ β]ϕ))−
(@i¬([α]ϕ ∧ [β]ϕ))− (¬[α ∪ β]−)

(@i¬((cid:104)α ∪ β(cid:105)ϕ))−
(@i¬((cid:104)α(cid:105)ϕ ∨ (cid:104)β(cid:105)ϕ))− (¬(cid:104)α ∪ β(cid:105)−)

(@i¬([ψ?]ϕ))−
(@i¬(ψ → ϕ))− (¬[ψ?]−)

(@i¬((cid:104)ψ?(cid:105)ϕ))−
(@i¬(ψ ∧ ϕ))− (¬(cid:104)ψ?(cid:105)−)

(@i¬([α∗]ϕ))−
(@i¬(ϕ))−
(@i¬([α][α∗]ϕ))−

([α∗]/¬[α∗]−)(ix)

@i¬[α∗]ϕ
@i¬ϕ (@i¬ϕ)−

@i¬[α][α∗]ϕ

(¬[α∗])

(@iϕ)−

(@i[α∗]ϕ)−
@iϕ
(@i[α][α∗]ϕ)−

([α∗]−)

@i(cid:104)α∗(cid:105)ϕ
@iϕ (@iϕ)−

@i(cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ

((cid:104)α∗(cid:105))

(@i¬ϕ)−

(@i¬(cid:104)α∗(cid:105)ϕ)−
@i¬ϕ
(@i¬(cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ)−

(¬(cid:104)α∗(cid:105)−)

(@i¬((cid:104)α∗(cid:105)ϕ))−
(@i¬(ϕ))−
(@i¬([α][α∗]ϕ))−

(¬(cid:104)α∗(cid:105)/(cid:104)α∗(cid:105)−)(x)

(ix) either both ¬ and − are present, or neither is present;
(x) one of ¬ or − is present, but not both.

Fig. 8: Tableau rules. (2/2)

We deﬁne a binary relation between nominals naming the same states and a

second one to establish the precedence of nominals as follows:

Deﬁnition 9. Let Θ be a branch of a tableau and let NomΘ be the set of nominals
occurring in the formulas of Θ. Deﬁne a binary relation ∼Θ on NomΘ by i ∼Θ j
if and only if the formula @ij ∈ Θ.

Deﬁnition 10. Let i and j be nominals occurring on a branch Θ of a tableau τ .
The nominal i is included in the nominal j with respect to Θ, denoted i ⊆Θ j,
if, for any formula ψ ∈ CL(ϕ), where ϕ is a root formula, the following holds:

– if (@i¬ψ)− ∈ Θ, then (@j¬ψ)− ∈ Θ, with the red and/or blue parts occurring

accordingly in the premise and conclusion; and

– the ﬁrst occurrence of j in Θ is before the ﬁrst occurrence of i.

A tableau is built according to the following algorithm:

Deﬁnition 11 (Tableau construction). Let ∆ be a ﬁnite set of signed formulas
in Form•(Ldyn). A tableau for ∆ is built inductively according to the following
rules:

– The one branch tableau τ 0 composed of the formulas in ∆ is a tableau for

∆;

– The tableau τ n+1 is obtained from the tableau τ n if it is possible to apply an

arbitrary rule to τ n which obeys the following three restrictions:
(1) If a formula that result from the application of a rule already occurs in

the branch, then its addition is simply omitted;

(2) A destructive rule is only applied once to the same formula in each

branch;

(3) An existential rule is not applied to @iϕ/(@iϕ)− (for an appropriate ϕ)

on a branch Θ if there exists a nominal j such that i ⊆Θ j.

Therefore a formula cannot occur more than once on a branch, a destructive
rule cannot be applied more than once to the same formula in a branch and the
introduction of new nominals is controlled.

Termination of the tableau construction algorithm is ensured using the same
approach as in [7]. A brief explanation follows: start by observing that new
nominals are introduced in the tableau by the application of one of the existential
rules or the (@−
I ) rule. The latter, classiﬁed as a destructive rule, is applied only
once to a minus-formula ϕ− as long as ϕ is not a satisfaction statement; given
that the set ∆ of root formulas is ﬁnite, so is the number of times that the rule
is applied overall and therefore the number of new nominals generated by this
particular rule.

We may classify the elements of NomΘ according to their origin: a nominal
is self-generated if it appears in a root formula or it appears as the product of
I ) rule; a nominal j is generated by i in Θ if it appears for the
applying the (@−
ﬁrst time after the application of one of the existential rules to a satisfaction
formula of the form @iϕ or a minus version in the branch (for appropriate ϕ).
If we denote the top “source” of nominals by (cid:63) we may consider an analogous
ordering <Θ on nominals given their origin, as the one from Deﬁnition 12 in [7]:

– i <Θ j, with i, j ∈ NomΘ, if and only if j is generated by i in Θ;
– (cid:63) <Θ j, with j ∈ NomΘ, if and only if @j appears in a root formula or the

nominal j is self-generated;
– x (cid:54)<Θ (cid:63), for all x ∈ NomΘ ∪ {(cid:63)}.

Then the graph (NomΘ ∪ {(cid:63)}, <Θ) can be showed to be a well-founded (with-
out inﬁnite descending chains), ﬁnitely branching tree. From that result, together
with the fact that the set ∆ is ﬁnite and that for each formula its Fisher-Ladner
closure set is ﬁnite, termination follows. Details may, once again, be checked on
the proof of Theorem 2 in [7], taking into account that the Subformula Property
mentioned there must be replaced with the Closure Property (Lemma 3 in this
paper).

Branches of a tableau τ can be classiﬁed into three categories: open, closed

or ignorable; a tableau can be either open or closed. The details follow:

Deﬁnition 12. A branch Θ is closed if for some nominal i, both @iϕ and
(@iϕ)− appear in Θ, or if either @i¬i, @i⊥ or (@i¬⊥)− appears in Θ;

A branch Θ is ignorable if it is terminal ( i.e., no more rules can be applied
to formulas in Θ according to Deﬁnition 11) and it ﬁts one of the four following
categories:

– ignorable branch of

type (cid:104)α∗(cid:105)ϕ:

there exists a nominal

i such that

@i(cid:104)α∗(cid:105)ϕ ∈ Θ and for every nominal j, @j(cid:104)α∗(cid:105)ϕ ∈ Θ implies (@jϕ)− ∈ Θ;

– ignorable branch of type ¬(cid:104)α∗(cid:105)ϕ−: there exists a nominal i such that
(@i¬(cid:104)α∗(cid:105)ϕ)− ∈ Θ and for every nominal j, (@j¬(cid:104)α∗(cid:105)ϕ)− ∈ Θ implies
@j¬ϕ ∈ Θ;

– ignorable branch of

i such that
(@i[α∗]ϕ)− ∈ Θ and for every nominal j, (@j[α∗]ϕ)− ∈ Θ implies @jϕ ∈ Θ;
or

there exists a nominal

type [α∗]ϕ−:

– ignorable branch of

i such that
@i¬[α∗]ϕ ∈ Θ and for every nominal j, @j¬[α∗]ϕ ∈ Θ implies (@j¬ϕ)− ∈ Θ.

there exists a nominal

type ¬[α∗]ϕ:

A branch Θ is open if it is terminal and neither closed nor ignorable.
A tableau is open if it has at least one open branch, otherwise it is closed.

We characterize a nominal as being terminal if it ﬁts the following deﬁnition:

Deﬁnition 13. A nominal t is called terminal for ϕ in the branch Θ if @tϕ ∈ Θ
and there exists a nominal s such that t ⊆Θ s.

The following result is immediate:

Proposition 1. Let Θ be an ignorable branch of type X (of appropriate form).
Then there is a terminal nominal t for X in Θ.

A branch Θ is globally satisﬁable in a model M = (W, (R+

a )a∈Act,
N, V+, V−) if for all ϕ in Θ, M |= ϕ, and for all ϕ− in Θ, M (cid:54)|= ϕ. A tableau is
globally satisﬁable if there is a model where one of its branches is so.

a )a∈Act, (R−

Global satisﬁability of a tableau is preserved under the application of tableau

rules:

Theorem 1. If τ is a globally satisﬁable tableau, then τ (cid:48), obtained by applying
one of the tableau rules to τ , is globally satisﬁable.

Proof. The proof can be obtained by checking each rule.

The correctness of rules in Figure 7 is immediate as they are closely connected

with the semantics provided in Deﬁnition 2: for any rule

Λ
Σ1 · · · Σn

, n ≥ 1, and

any model M, if M |= Λ then M |= Σ1 or . . . or M |= Σn, where Λ, Σ1, . . . , Σn ⊂
Form•(Ldyn). To illustrate the proof, take the case of rule (→−):

Assume that M |= (@i(ϕ → ψ))−. Then M (cid:54)|= @i(ϕ → ψ), i.e., for some
w ∈ W, M, w (cid:54)|= @i(ϕ → ψ), and equivalently, M, N(i) (cid:54)|= ϕ → ψ. Therefore,
by Deﬁnition 2, M, N(i) |= ϕ and M, N(i) (cid:54)|= ψ. Thus for any w, M, w |= @iϕ
and M, w (cid:54)|= @iψ. It follows that M |= @iϕ and M (cid:54)|= @iψ. The latter can be
rewritten as M |= (@iψ)−. This concludes the proof that the application of this
particular rule does not aﬀect global satisﬁability of the tableau. Other rules
follow an analogous approach.

As for the rules in Figure 8, they mimic the equivalences from Lemma 2. The
only cases worth mentioning are those concerning the iteration program where,
when the branch splits, the minus dual of the formula in the left sub-branch
is introduced in the right sub-branch. The introduction of this element plays

a major role in the deﬁnition of ignorable branches, as the reader may have
already noticed. This does not aﬀect in any way the result under appreciation;
nonetheless, the proof for the case of ((cid:104)α∗(cid:105)) is presented next as an example.
The other cases are analogous.

Let M be a model such that M |= @i(cid:104)α∗(cid:105)ϕ, equivalently M, N(i) |= (cid:104)α∗(cid:105)ϕ.
From Lemma 2, M, N(i) |= ϕ ∨ (cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ, which means that M, N(i) |= ϕ or
M, N(i) |= (cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ. Put another way, M, N(i) (cid:54)|= ϕ implies M, N(i) |= (cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ.
In addition, it is always the case that either M, N(i) |= ϕ or M, N(i) (cid:54)|= ϕ, the
latter equivalent to M, N(i) |= ϕ−. Combining these scenarios, either M |= @iϕ,
or M |= (@iϕ)− and M |= @i(cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ. Thus global satisﬁability of the branch Θ
is preserved by the application of the rule ((cid:104)α∗(cid:105)).

The next result allows us to safely discard ignorable branches in terminal

and globally satisﬁable tableaux:

Theorem 2. If τ is a terminal and globally satisﬁable tableau, then one of its
globally satisﬁable branches is not ignorable.

Proof. Let τ be a terminal and globally satisﬁable tableau whose globally satis-
ﬁable branches are all ignorable.

Take Θ to be a branch in τ which is globally satisﬁable and additionally is

also ignorable of type (cid:104)α∗(cid:105)ϕ. Let t be the terminal nominal for (cid:104)α∗(cid:105)ϕ in Θ.

By deﬁnition of ignorable branch, @t(cid:104)α∗(cid:105)ϕ, (@tϕ)− ∈ Θ and there exists a
nominal s such that t ⊆Θ s. Also, since τ is a terminal tableau, @t(cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ ∈ Θ.
Furthermore, and once again because τ is terminal, there is a branch Θ(cid:48) in

τ such that @t(cid:104)α∗(cid:105)ϕ, @tϕ ∈ Θ(cid:48). The branch Θ(cid:48) is clearly not (cid:104)α∗(cid:105)ϕ-ignorable.

If Θ(cid:48) were any other type of ignorable branch, we could apply an analogous
strategy to infer that there would be yet another branch which was not that type
of ignorable either. Since there is a ﬁnite number of possible kinds of ignorable
branch (due to Lemma 3), there will come to a point where we have in our hands
a branch which is not any type of ignorable. Let us assume that to be already
the case. Therefore, the branch Θ(cid:48) must not be globally satisﬁable (1).

Even though the introduction of a new nominal through the application of
the ((cid:104)α(cid:105))-rule on the formula @t(cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ ∈ Θ has been prevented in accordance
with the third restriction in the tableau construction algorithm (Deﬁnition 11),
we can still force it.

Let τ (cid:48) be the terminal tableau obtained from τ by applying the aforemen-
tioned existential rule followed by any other allowed rule according to the tableau
construction algorithm.

Then @t(cid:104)α(cid:105)n, @n(cid:104)α∗(cid:105)ϕ ∈ Θ, where n is a new nominal. The branch Θ is split
into two sub-branches: (L) (for left) and (R) (for right) such that @nϕ ∈ (L)
and (@nϕ)−, @n(cid:104)α(cid:105)(cid:104)α∗(cid:105)ϕ ∈ (R).

If (L) is a globally satisﬁable branch in M, then Θ(cid:48) is globally satisﬁable
t∼ N, where N(cid:48)(t) = N(n),
in the model M(cid:48) which is such that W(cid:48) = W, N(cid:48)
α }. However, this contradicts (1).
(R+
Therefore (L) cannot be globally satisﬁable. That implies that (R) must be so,
given that it derives from Θ which is globally satisﬁable.

α ∪ {(w, N(cid:48)(t)) | (w, N(t)) ∈ R+

α )(cid:48) = R+

Since Θ is globally satisﬁable,

there exists a model M such that
M, N(t) |= (cid:104)α∗(cid:105)ϕ. This means that there exists n ∈ N0, w ∈ W such that
M, w |= ϕ. Since M, N(t) (cid:54)|= ϕ, n > 0. Moreover, since (R) is globally satisﬁ-
able it follows that n > 1.

We can again force the application of the ((cid:104)α(cid:105))-rule in (R). The left sub-
branch that is created cannot be globally satisﬁable, otherwise (L) would be
globally satisﬁable too, which is a contradiction. It follows that n > 2. We can
apply this construction until n > n, which is again a contradiction.

If Θ were any other kind of ignorable branch, analogous steps would be used

and the same conclusion would arise.

Therefore not all globally satisﬁable branches of τ can be ignorable. So, if
τ is a terminal and satisﬁable tableau then there must be a globally satisﬁable
branch which is not ignorable.

Soundness is stated and proved as follows (observe that if ∆ is empty, then

the theorem shows that ϕ is valid):

Theorem 3 (Soundness). If the tableau with root ∆, ϕ− is closed, then ϕ is a
consequence of ∆.

Proof. Assume that the tableau τ with root ∆, ϕ− is closed. Then all of its
branches are either closed or ignorable; that means that none of its branches is
globally satisﬁable. By deﬁnition, there exists no model M such that M |= ∆ and
M |= ϕ−; i.e., for every model M, either M (cid:54)|= ∆ or M |= ϕ. Therefore, for every
model M, M |= ∆ implies M |= ϕ.

In order to prove completeness, we prove that if a terminal tableau has an
open branch Θ, then there exists a model MΘ where all root formulas are valid.
Suppose that Θ is an open branch of a terminal tableau. We extract a model

from Θ in the same fashion as in [7], and whose details follow:

Let U be the subset of NomΘ that contains every nominal i for which there is
no nominal j such that i ⊆Θ j. Let ≈ be the restriction of ∼Θ to U; observe that
both ∼Θ and ≈ are equivalence relations. Note also that U contains all nominals
i such that (cid:63) <Θ i.

Given a nominal i in U, we let [i]≈ denote the equivalence class of i with

respect to ≈ and we let U/≈ denote the set of equivalence classes.

We let R+
a

be the binary relation on U deﬁned by iR+

a j if and only if there

exists a nominal j(cid:48) ≈ j such that one of the following conditions is satisﬁed:

1. @i(cid:104)a(cid:105)j(cid:48) ∈ Θ; or
2. there exists a nominal k ∈ NomΘ such that @i(cid:104)a(cid:105)k ∈ Θ and k ⊆Θ j(cid:48).

On the other hand, we deﬁne the complement of the binary relation R−
a

on
a )cj if and only if there exists a nominal j(cid:48) ≈ j such that one of the

U as i(R−
following conditions is satisﬁed:

1. @i¬[a]¬j(cid:48) ∈ Θ; or
2. there exists a nominal k ∈ NomΘ such that @i¬[a]¬k ∈ Θ and k ⊆Θ j(cid:48).

Note that the nominal k referred to in the second items is not an element of
a )c are
U. It follows from Θ being closed under the rule (Nom) that R+
a
compatible with ≈ in the ﬁrst argument and it is trivial that they are compatible
with ≈ in the second argument. We let R+
(observe that
once again we deﬁne the complement of the relation), be the binary relation on
U/≈ deﬁned by [i]≈ R+
a j,
respectively i(R−

[j]≈, if and only if iR+

a [j]≈, respectively [i]≈

a , respectively

and (R−

R−
a

R−
a

(cid:17)c

(cid:17)c

(cid:16)

(cid:16)

Let N : U → U/≈ be deﬁned such that N(i) = [i]≈.
Let V+ be the function that to each ordinary propositional variable assigns
the set of elements of U where that propositional variable occurs, i.e., i ∈ V+(p)
if and only if @ip ∈ Θ. On the other hand, let V− be the function that to
each ordinary propositional variable assigns the set of elements of U where the
negation of that propositional variable occurs, i.e., i ∈ V−(p) if and only if
@i¬p ∈ Θ. We let V+ be deﬁned by V+(p) = {[i]≈ | i ∈ V+(p)}. We deﬁne V−
analogously.

a )cj.

Given a branch Θ, let MΘ =
R+
a
We will omit the reference to the branch in MΘ if it is clear from the context.

, N, V+, V−

U/≈,

R−
a

a∈Act

a∈Act

,

.

(cid:18)

(cid:16)

(cid:17)

(cid:16)

(cid:17)

(cid:19)

Theorem 4 (Model Existence). Let Θ be an open branch of a terminal tableau
τ . The model extracted from the branch, M, is such that the following conditions
hold:

(i) if @iϕ ∈ Θ, then M, [i]≈ |= ϕ;
(ii) if (@iϕ)− ∈ Θ, then M, [i]≈ (cid:54)|= ϕ.

whenever @iϕ contains only nominals from U.

Proof. First, consider the cases where @iϕ is a hybrid formula. The proof is done
by induction on the complexity of ϕ.

The base step concerns the cases where ϕ is either a nominal, a propositional
variable, ⊥, or the negation of one of those. Satisfaction of ϕ in M, [i]≈ is trivially
obtained by the construction of the model M.

We assume that the result holds for subformulas of ϕ and their negation
(I.H.). We illustrate the cases ϕ = ψ ∧ δ, ϕ = ¬(ψ ∧ δ) and ϕ = (cid:104)a(cid:105)ψ, ϕ = ¬(cid:104)a(cid:105)ψ,
for a ∈ Act:

– ϕ = ψ ∧ δ

(i) @i(ψ ∧ δ) ∈ Θ, then, by applying the rule (∧), @iψ, @iδ ∈ Θ. By I.H.,

M, [i]≈ |= ψ and M, [i]≈ |= δ. Therefore M, [i]≈ |= ψ ∧ δ.

(ii) (@i(ψ ∧ δ))− ∈ Θ, then, by applying the rule (∧−), (@iψ)− ∈ Θ or
(@iδ)− ∈ Θ. Hence, by I.H., M, [i]≈ (cid:54)|= ψ or M, [i]≈ (cid:54)|= δ. Therefore,
M, [i]≈ (cid:54)|= ψ ∧ δ.

– ϕ = ¬(ψ ∧ δ)

(i) @i¬(ψ∧δ) ∈ Θ, then, by applying the rule (¬∧), @i¬ψ ∈ Θ or @i¬δ ∈ Θ.

By I.H., either M, [i]≈ |= ¬ψ or M, [i]≈ |= ¬δ. Therefore, M, [i]≈ |= ¬(ψ ∧ δ).

(ii) (@i¬(ψ ∧ δ))− ∈ Θ, then, by applying the rule (¬∧−), (@i¬ψ)−,
(@i¬δ)− ∈ Θ. Hence, by I.H., M, [i]≈ (cid:54)|= ¬ψ and M, [i]≈ (cid:54)|= ¬δ. Therefore,
M, [i]≈ (cid:54)|= ¬(ψ ∧ δ).

– ϕ = (cid:104)a(cid:105)ψ

(i)

∗ if ψ = j, j ∈ Nom:

@i(cid:104)a(cid:105)j ∈ Θ, then [i]≈R+

a [j]≈ and by deﬁnition M, [i]≈ |= (cid:104)a(cid:105)j.

∗ if ψ is not a nominal:

@i(cid:104)a(cid:105)ψ ∈ Θ, then by the application of the rule ((cid:104)a(cid:105)), @i(cid:104)a(cid:105)t and
@tψ ∈ Θ, for a new nominal t. Then:

a [t]≈. By I.H., M, [t]≈ |= ψ, so M, [i]≈ |= (cid:104)a(cid:105)ψ.

· if t ∈ U, [i]≈R+
· if t /∈ U, ∃s such that t ⊆Θ s. Assume that there is no r such that
s ⊆Θ r, i.e., s ∈ U. Then by the deﬁnition of ⊆Θ, @sψ ∈ Θ. Ob-
serve also that ψ is a subformula of ϕ, thus by I.H., M, [s]≈ |= ψ.
a [s]≈. Therefore, M, [i]≈ |= (cid:104)a(cid:105)ψ.
By the construction of M, [i]≈R+
(ii) (@i(cid:104)a(cid:105)ψ)− ∈ Θ. We want to prove that M, [i]≈ (cid:54)|= (cid:104)a(cid:105)ψ, i.e., that for all

[k]≈ such that [i]≈R+
Let k be a nominal such that [i]≈R+
with k(cid:48)≈k that satisﬁes one of the following conditions:

a [k]≈, M, [k]≈ (cid:54)|= ψ.

a [k]≈; by deﬁnition there exists k(cid:48)

∗ @i(cid:104)a(cid:105)k(cid:48) ∈ Θ, which then by applying the rule ((cid:104)a(cid:105)−), implies that
(@k(cid:48)ψ)− ∈ Θ. By I.H., M, [k(cid:48)]≈ (cid:54)|= ψ. Since [k(cid:48)]≈ = [k]≈, follows that
M, [k]≈ (cid:54)|= ψ. Or:

∗ ∃s ∈ NomΘ such that @i(cid:104)a(cid:105)s ∈ Θ and s ⊆Θ k(cid:48), then by applying
((cid:104)a(cid:105)−) it follows that (@sψ)− ∈ Θ. Since s ⊆Θ k(cid:48), (@k(cid:48)ψ)− ∈ Θ. By
I.H., M, [k(cid:48)]≈ (cid:54)|= ψ. Since [k(cid:48)]≈ = [k]≈, then M, [k]≈ (cid:54)|= ψ.

It follows that M, [i]≈ (cid:54)|= (cid:104)a(cid:105)ψ.

– ϕ = ¬(cid:104)a(cid:105)ψ

(i) @i¬(cid:104)a(cid:105)ψ ∈ Θ. We want to prove that M, [i]≈ |= ¬(cid:104)a(cid:105)ψ, i.e., that for all

[k]≈ such that [i]≈

R−
a

[k]≈, M, [k]≈ |= ¬ψ.

(cid:16)

(cid:17)c

Let k be a nominal such that [i]≈
k(cid:48) with k(cid:48)≈k that satisﬁes one of the following two conditions:

[k]≈; by deﬁnition, there exists

R−
a

(cid:16)

(cid:17)c

∗ @i¬[a]¬k(cid:48) ∈ Θ which then by applying the rule (¬(cid:104)a(cid:105)) implies that
@k(cid:48)¬ψ ∈ Θ and by I.H., M, [k(cid:48)]≈ |= ¬ψ. Since [k(cid:48)]≈ = [k]≈, follows
that M, [k]≈ |= ¬ψ. Or:

∗ ∃s ∈ NomΘ such that @i¬[a]¬s ∈ Θ and s ⊆Θ k(cid:48), then by applying
the rule (¬(cid:104)a(cid:105)), @s¬ψ ∈ Θ. Since s ⊆Θ k(cid:48), @k(cid:48)¬ψ ∈ Θ. By I.H.,
M, [k(cid:48)]≈ |= ¬ψ. Since [k]≈ = [k(cid:48)]≈, M, [k]≈ |= ¬ψ.

Therefore M, [i]≈ |= ¬(cid:104)a(cid:105)ψ.

(ii) (@i¬(cid:104)a(cid:105)ψ)− ∈ Θ, thus by applying rule (¬(cid:104)a(cid:105)−), @i¬[a]¬t, (@t¬ψ)− ∈ Θ,

for a new nominal t. Then:

∗ if t ∈ U, [i]≈

(cid:17)c

(cid:16)

R−
a

[t]≈. By I.H., M, [t]≈ (cid:54)|= ¬ψ. Thus M, [i]≈ (cid:54)|=

¬(cid:104)a(cid:105)ψ.

∗ if t /∈ U, ∃s such that t ⊆Θ s. Assume that there is no r such that
s ⊆Θ r, i.e., s ∈ U. Since t ⊆Θ s, follows that (@s¬ψ)− ∈ Θ. By
[s]≈. It follows that
I.H., M, [s]≈ (cid:54)|= ¬ψ and by deﬁnition [i]≈
M, [i]≈ (cid:54)|= ¬(cid:104)a(cid:105)ψ.

R−
a

(cid:17)c

(cid:16)

Other cases follow an analogous approach.1

We present a detailed proof for the cases where ϕ is a modal formula of the

form (cid:104)α(cid:105)ψ or [α]ψ. The proof is by induction on the complexity of α.

The base cases, where α is an atomic program, reduces to a hybrid formula

and thus to one of the cases aforementioned.

Induction Hypothesis (I.H.): the result holds for formulas (cid:104)α(cid:105)δ, (cid:104)β(cid:105)δ, [α]δ,

[β]δ and δ in the Fischer-Ladner closure of ϕ (Deﬁnition 8).
We prove only the case (i) as the other is analogous.

– ϕ = (cid:104)α; β(cid:105)ψ

(i) @i(cid:104)α; β(cid:105)ψ ∈ Θ, then, by applying the rule ((cid:104)α; β(cid:105)), @i(cid:104)α(cid:105)(cid:104)β(cid:105)ψ ∈ Θ.
By I.H. on @i(cid:104)α(cid:105)δ, where δ = (cid:104)β(cid:105)ψ, follows that M, [i]≈ |= (cid:104)α(cid:105)(cid:104)β(cid:105)ψ;
equivalently, M, [i]≈ |= (cid:104)α; β(cid:105)ψ.

– The cases ϕ = [α; β]ψ, (cid:104)α ∪ β(cid:105)ψ, [α ∪ β]ψ, the negations of these and of the

previous bullet are similar.

– ϕ = (cid:104)χ?(cid:105)ψ

(i) @i(cid:104)χ?(cid:105)ψ ∈ Θ, then by applying the rule (cid:104)χ?(cid:105), @i(χ ∧ ψ) ∈ Θ. By I.H.,

M, [i]≈ |= χ ∧ ψ. Therefore M, [i]≈ |= (cid:104)χ?(cid:105)ψ.

– ϕ = [χ?]ψ is analogous, as are the cases with negation occurring before the

modal operator.

– ϕ = (cid:104)α∗(cid:105)ψ

(i) @i(cid:104)α∗(cid:105)ψ ∈ Θ, then by applying the rule ((cid:104)α∗(cid:105)), either @iψ ∈ Θ or
(@iψ)−, @i(cid:104)α(cid:105)(cid:104)α∗(cid:105)ψ ∈ Θ. By I.H., either M, [i]≈ |= ψ or
M, [i]≈ |= (cid:104)α(cid:105)(cid:104)α∗(cid:105)ψ. Anyway, M, [i]≈ |= (cid:104)α∗(cid:105)ψ.

– ϕ = [α∗]ψ and versions with negation occurring before the modal operator

are once again analogous.

Completeness can be easily proved now:

1 For the interested reader, the proof of Theorem 4 in [7] may serve as a guide for the
remaining cases. Observe that the cases for modal formulas (in this paper we proved
the (cid:104)a(cid:105) case) and implication deviate slightly given the diﬀerent semantics and, of
course, rules provided in that paper for these particular cases.

Theorem 5 (Completeness). If ϕ is a consequence of ∆, then the tableau with
root ∆, ϕ− is closed.

Proof. Assume that the tableau τ with root ∆, ϕ− is not closed. Then τ is such
that it has an open branch, which by Theorem 4 implies that there is a model
M where all formulas in ∆ and ϕ− are globally satisﬁable. That means that ϕ
is not globally satisﬁable in M. Therefore ϕ is not a consequence of ∆.

5 Conclusion

The purpose of this paper is to, ﬁrst and foremost, start a discussion about
the roles of negation and modal operators when combined in a paraconsistent
environment. Namely, it begins by presenting a four-valued Hybrid Logic, poste-
riorly used as the basis of a dynamic version, where the duality between modal
operators is not preserved. One of the reasons behind this choice stems from the
discussions of Fitting in [9], for the predicate abstraction of modal formulas in
models with varying domains. His ideas are, in some ways, related to the dis-
cussion about the fact that negation is always carried inside modal formulas by
making use of the classical duality between (cid:50) and (cid:51). However, as debated in
the present paper, by doing so the negation concerns only propositional variables
and/or nominals and completely ignores the transition involved in the semantics
of the whole modal formula. In cases where accessibility relations are classi-
cal this is a natural construction, but it fails to grasp the true meaning of the
assertion when the accessibility relations become four-valued functions.

The paraconsistent versions of Modal Logic available in literature and where
transitions are many-valued have been thought in ways that they keep the duality
between modal operators. In some cases, such as Modal Bilattice Logic [14], an
extension with nominals and the satisfaction operator is such that R(w, w(cid:48)) (cid:54)=
V(@i(cid:51)j, −) (i names the state w and j the state w(cid:48)), which is highly undesirable.

This paper aimed to provide a logic where inconsistent models can be (uniquely)

described resorting to diagrams, i.e., the set of all atomic formulas that hold in
the model. This can be achieved when all states in the model are named – which
justiﬁes the use of nominals – and there is special machinery to be able to refer to
each state in the model – the satisfaction operator @. Inconsistent models consist
of sets of states together with information about transitions and the absence of
transitions between states and information about the veriﬁcation and refutation
of local properties, hence our models incorporate both four-valued relations and
four-valued (local) valuations. A four-valued Hybrid Logic, 4HL, is the central
point of the ﬁrst section of the paper.

The second section introduces a dynamic version of 4HL. The concept of
modality is replaced by that of program, which can be composed. One can view
each relation Rα as the set of pairs of states (w, w(cid:48)) such that w is an input
state and w(cid:48) an output state of the program α. From a four-valued perspective,
α w(cid:48) if we have information that the program α runs in w and terminates at w(cid:48)
wR+
and wR−
α w(cid:48) if we have information that the program α does not run between w
and w(cid:48). The four-valued approach is a means to deal with information obtained

by collecting diﬀerent testimonies. The interpretations of R+
α∗ , R+
ϕ?
are analogous to those in Propositional Dynamic Logic; for the negative cases,
the interpretations resort to the complements of the underlying relations. The
axioms of PDL hold in 4DL, making the latter a truly Dynamic Logic, albeit
four-valued and with non-dual modal operators.

α∪β, R+

α;β, R+

The third and ﬁnal section of the paper introduces a terminating, sound and
complete tableau system for 4DL. Some of the techniques in [7] were repurposed.
But there were also some necessary additions, namely the introduction of the
notions of ignorable branch in order to deal with the iteration program and a
result to ensure that those branches make their own name justice and can be
indeed safely ignored.

Even though 4DL was created independently, it would be interesting to check,
in the future, its connection to a logic obtained by applying the technique in [11].
Another topic for further research is the study of bisimulation.

Remark. This work was developed and submitted while the author was a Re-
search Fellow at University College London.

References

1. N. D. Belnap. A useful four-valued logic. In J. M. Dunn and G. Epstein, editors,

Modern Uses of Multiple-Valued Logic. D. Reidel, 1977.

2. P. Blackburn. Representation, reasoning, and relational structures: A hybrid logic

manifesto. Log. J. IGPL, 8(3):339–365, 2000.

3. P. Blackburn, M. de Rijke, and Y. Venema. Modal logic. Cambridge: Cambridge

University Press, 2001.

4. T. Braüner. Axioms for classical, intuitionistic, and paraconsistent hybrid logic.

Journal of Logic, Language and Information, 15(3):179–194, 2006.

5. T. Braüner. Hybrid Logic and its Proof-Theory. Springer, 2010.
6. D. Costa and M. A. Martins. Paraconsistency in hybrid logic. Journal of Logic

and Computation, 27(6):1825–1852, 10 2016.

7. D. Costa and M. A. Martins. Non-dual modal operators as a basis for 4-valued
accessibility relations in hybrid logic. Journal of Logical and Algebraic Methods in
Programming, page 100679, 2021.

8. M. J. Fischer and R. E. Ladner. Propositional dynamic logic of regular programs.

Journal of Computer and System Sciences, 18(2):194 – 211, 1979.

9. M. Fitting. A modal herbrand theorem. Fundam. Inf., 28(1,2):101–122, Apr. 1996.
10. D. Harel. Dynamic Logic, pages 497–604. Springer Netherlands, Dordrecht, 1984.
11. A. Madeira, R. Neves, and M. A. Martins. An exercise on the generation of many-
valued dynamic logics. Journal of Logical and Algebraic Methods in Programming,
85(5, Part 2):1011 – 1037, 2016. Articles dedicated to Prof. J. N. Oliveira on the
occasion of his 60th birthday.

12. S. P. Odintsov and H. Wansing. Modal logics with belnapian truth values. Journal

of Applied Non-Classical Logics, 20(3):279–304, 2010.

13. S. P. Odintsov and H. Wansing. Disentangling FDE-based paraconsistent modal

logics. Studia Logica, 105(6):1221–1254, Dec 2017.

14. U. Rivieccio, A. Jung, and R. Jansana. Four-valued modal logic: Kripke semantics

and duality. Journal of Logic and Computation, 2015.

15. I. Sedlár. Propositional dynamic logic with belnapian truth values. 08 2016.

