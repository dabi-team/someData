Quantitative Analysis of Community Evolution in Developer
Social Networks Around Open Source Software Projects

Liang Wang, Ying Li, Jierui Zhang, Xianping Tao
State Key Laboratory for Novel Software Technology
Nanjing University, Nanjing, China
wl@nju.edu.cn,mg21070006@smail.nju.edu.cn,jieruizhang@smail.nju.edu.cn,txp@nju.edu.cn

2
2
0
2

y
a
M
0
2

]
E
S
.
s
c
[

1
v
5
3
9
9
0
.
5
0
2
2
:
v
i
X
r
a

ABSTRACT
Understanding the evolution of communities in developer social
networks (DSNs) around open source software (OSS) projects can
provide valuable insights about the socio-technical process of OSS
development. Existing studies show the evolutionary behaviors of
social communities can eﬀectively be described using patterns in-
cluding split, shrink, merge, expand, emerge, and extinct. However,
existing pattern-based approaches are limited in supporting quan-
titative analysis, and are potentially problematic for using the pat-
terns in a mutually exclusive manner when describing community
evolution. In this work, we propose that diﬀerent patterns can oc-
cur simultaneously between every pair of communities during the
evolution, just in diﬀerent degrees. Four entropy-based indices are
devised to measure the degree of community split, shrink, merge,
and expand, respectively, which can provide a comprehensive and
quantitative measure of community evolution in DSNs. The indices
have properties desirable to quantify community evolution includ-
ing monotonicity, and bounded maximum and minimum values
that correspond to meaningful cases. They can also be combined to
describe more patterns such as community emerge and extinct. We
conduct experiments with real-world OSS projects to evaluate the
validity of the proposed indices. The results suggest the proposed
indices can eﬀectively capture community evolution, and are con-
sistent with existing approaches in detecting evolution patterns in
DSNs with an accuracy of 94.1%. The results also show that the
indices are useful in predicting OSS team productivity with an ac-
curacy of 0.718. In summary, the proposed approach is among the
ﬁrst to quantify the degree of community evolution with respect
to diﬀerent patterns, which is promising in supporting future re-
search and applications about DSNs and OSS development.

CCS CONCEPTS
• Software and its engineering → Programming teams; Open
source model; • General and reference → Metrics.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
Conference’17, July 2017, Washington, DC, USA
© 2022 Association for Computing Machinery.
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn

KEYWORDS
Developer Social Networks, Community Evolution Patterns, Entropy-
Bases Indices, Open Source Software, Mining Software Reposito-
ries

ACM Reference Format:
Liang Wang, Ying Li, Jierui Zhang, Xianping Tao. 2022. Quantitative Anal-
ysis of Community Evolution in Developer Social Networks Around Open
Source Software Projects. In Proceedings of ACM Conference (Conference’17).
ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION
Building and maintaining healthy communities around open source
software (OSS) projects is crucial because of the socio-technical na-
ture of OSS development [11, 19, 25, 40, 48, 60, 66]. Cross-disciplinary
research on developer social networks (DSNs) that emerge from
the developers’ communication and cooperation activities in OSS
repositories has been conducted by scholars from various ﬁelds
ever since the early days of the OSS movement [37, 45]. Supported
by rich empirical evidences, it is now widely accepted that the so-
cial aspects of OSS communities have a strong correlation with,
and are important indicators of OSS projects’ productivity [65],
success [62], and survivability [44, 49, 64].

While a number of research is about the statistics and patterns
of static DSNs snapshots [7, 16, 29, 59, 68], there is a series of work
that pay special attentions to the evolution of DSNs around OSS
projects over time [9, 25, 66]. By understanding the evolution of
DSNs, we can not only retrospectively reveal the status of a DSN in
a given snapshot, but also predict the future trends of a DSN based
on a comprehensive view of its evolution history [9, 25, 48]. Given
the importance of social aspects in OSS development as discussed
above, and because OSS development is a “nature product of evolu-
tion” [40, 45], in this work, we study the problem of measuring the
evolution of social communities around OSS projects quantitatively
to support in-depth understanding of the socio-technical aspects
of OSS development.

Existing approaches to study community and network evolu-
tion can be categorized into two classes which we refer to as network-
level statistics and community-level patterns. The ﬁrst class of work
uses sequences of statistical metrics over series of temporally-aligned
snapshots of social networks to quantify their evolution. Frequently
adopted metrics include network diameter, shortest path between
nodes, node betweenness, modularity, hierarchy, centrality, and
etc [3, 25, 28, 30, 49, 54]. While most of the above metrics measure

 
 
 
 
 
 
Conference’17, July 2017, Washington, DC, USA

L. Wang, et al.

properties of social networks on a gross level, a natural phenom-
enon in social networks is that interacting individuals form com-
plex structures organized in communities1 [8, 46]. Understanding
the communities inside DSNs can provide valuable insights about
software development. For instance, the Conway’s law suggests
that a system’s architecture reﬂects the communication structure
of the organization designs it [6, 15]. Although some metrics such
as clustering coeﬃcient [25], group degree centrality [44], group
betweenness centrality [44], and etc, are related to measuring sub-
structures or communities [12] in social networks, these network-
level statistics are less expressive in revealing the structure and
evolution of communities in DSNs.

Diﬀerent from the above work, the second class of approaches
take the community perspective [3] to uncover the evolution pat-
terns of social networks. Six patterns, including growth (expand),
contraction (shrink), merge, split, birth (emerge), and death (extinct)
are used to describe the evolutionary behaviors of communities
inside social networks [3, 4, 10, 23, 27, 34, 46]. These patterns are
promising in bringing insights about OSS development for corre-
sponding to the evolution of OSS projects and members’ activities
[27]. However, the existing pattern-based approaches often assign
a single pattern to describe the evolution of a community, which
are limited for several reasons. First, the evolution of a community
can hardly be described by a single pattern. For example, a com-
munity can expand and merge simultaneously with new members
and members from other communities joining it. Choosing either
pattern can lead to information loss in the above case. In addition,
matching communities detected in diﬀerent time steps to identify
them as a single, evolving community before pattern assignment
is not a trivial task [46]. Second, the nominal patterns are promis-
ing in describing community evolution qualitatively, but are lim-
ited in supporting quantitative analysis. Third, these patterns are
restricted to describe the evolution of a single community. It is dif-
ﬁcult to extend the concepts to the network level, which is often
desirable to gain a comprehensive understanding of the evolution
of DSNs.

Our idea to tackle the above limitations can be described as: the
community evolution patterns can happen simultaneously between
all pairs of communities in consecutive time steps, only in diﬀerent
degrees. Following this idea, we propose in this paper to quantify
community evolutionary behaviors comprehensively by calculat-
ing how much the communities expand, shrink, merge, and split si-
multaneously. As introduced in Sec. 4, the calculation is done by
ﬁrst building a community member migration matrix which cap-
tures the dynamics of communities detected in Sec. 3. Based on the
matrix, we devise indices based on information entropy to mea-
sure the degree of community evolution with respect to the four
patterns above. Community extinct and emerge are represented by
special combinations of the indices. With this approach, the evo-
lution of a community is described by four indices in each step,
which addresses the challenge of ﬁnding a unique, most appropri-
ate pattern for community evolution. It is worth noting that our ap-
proach is compatible with existing work [27] for being capable of
ﬁnding the most appropriate evolution pattern with a simple set of

1For the rest of the paper, a community inside a social network refers to a group of
interconnected members of the network if not speciﬁed otherwise. Refer to Sec. 2.1
for details about the terms used in this paper.

rules as introduced later. We present the properties of the indices,
including the monotonicity, and the upper- and lower-bounds, to
show that the indices can correctly reveal complex, real-world com-
munity evolutionary behaviors quantitatively. We also aggregate
the community-level indices to describe the overall evolutionary
behaviors of communities at the network level, which can support
quantitative analysis of community evolution at various scales.

We conduct empirical studies using real-world data collected
from thirty-two projects hosted on GitHub to evaluate the validity
and usefulness of the proposed community evolution indices. More
speciﬁcally, we validate the construct validity of the proposed in-
dices in terms of concurrent and discriminant validity criteria [31].
The results for concurrent validity suggest that the community
evolution patterns detected with the proposed indices is consistent
with the ones detected following an exiting approach [27], with an
accuracy of 94%. By analyzing the properties of the indices, and by
calculating the Spearman’s Correlation Coeﬃcients of the indices,
we ﬁnd that the indices are capable in measuring diﬀerent aspects
of community evolution. We further demonstrate the usefulness
of the proposed indices by study the correlation between the mea-
sured community evolution with OSS project team productivity
measured by the count of commits [11, 63]. The results obtained
from regression analysis with linear mixed-eﬀects models suggest
that the indices are good predictors of team productivity with an
accuracy of 0.718 after log transformation.

The main contributions of this paper are as follows. First, we
bridge the gap between nominal, community evolution patterns
and quantitative measures with a set of entropy-based indices to
support quantitative analysis for community evolution. Second, we
demonstrate versatile ways of using the indices, e.g., aggregating
community-level indices to generate network-level quantities, and
ﬁnding the most appropriate pattern from the indices, which can
support various tasks. Finally, we conduct empirical studies with
data from real-world OSS projects to validate the proposed indices,
and demonstrate the usefulness of the indices in predicting OSS
team productivity.

2 OVERVIEW OF THE PROPOSED

APPROACH

This section presents an overview of the proposed approach.

2.1 Terminology
We ﬁrst introduce the concepts and terms used in this paper.

An OSS project or repository refers to a single repository hosted
on OSS platforms such as Github, e.g., tensorﬂow/tensorﬂow2. In
comparison, large projects, e.g., the Mozilla or GNOME projects
that include multiple sub-projects developed together [27, 39], are
considered as ecosystems or super-repositories following [36, 39]. In
this work, we focus on community evolution on the project level.
A developer social network (DSN) around an OSS project include
the participants of the project and their relationships, which is typ-
ically modeled using a graph model [3, 27] extracted from various
sources such as mailing lists [7, 39, 48, 66], version repositories
[39], issue and bug-tracking systems [3, 48], and etc.

2https://github.com/tensorﬂow/tensorﬂow

Quantitative Analysis of Community Evolution in Developer Social Networks Around Open Source Software Projects

Conference’17, July 2017, Washington, DC, USA

GraphQL
API
+

GHTorrent

Weighted, 
undirected 
graphs

Time

Legend: 

Key processing step

Extension
of CNM

Information 
entropy

Merge

Expand

Split & Shrink

(a) Obtain raw conversation data from 
issue and pull-requests in OSS 
repositories (Sec. 3, Sec. 6)

(b) Segment data, build snapshots of DSNs, and perform 
community detection in each snapshot (Sec. 3)

(c) Calculate indexes for community evolutionary 
behaviors (Sec. 4). Note: we assume multiple 
patterns can occur simultaneously.

Figure 1: An overview of the proposed approach.

A community inside a DSN means a group of members in the
DSN with strongly interconnected links [46], or share similar fea-
tures and actions [40, 52], which is also termed as a cluster [25, 52],
a clique [46, 54], an emerging team [48], or a social group [46] in the
literature. We do not use the term to refer to OSS communities in
the broad sense [56], e.g., the Apache community studied in [66].
The evolutionary behaviors of communities studied in this paper
correspond to the six community evolution patterns studied in [3,
27, 34, 46], which is diﬀerent from the general concept of ‘patterns
of community evolution’ used in [40, 66].

2.2 Overview
As shown in Fig. 1, the processing pipeline proposed in this work
involves three steps. First, as shown in Fig. 1(a) and as introduced
in Sec. 3 and Sec. 5, given an OSS repository, we retrieve data about
the conversations that take place in issues and pull-requests from
the GHTorrent data set [22] and the GitHub GraphQL API3. Par-
ticipants of the conversations are recorded to extract the joint dis-
cussion relationships between them. The records are used to build
DSNs and to perform community evolution analysis in the subse-
quent steps. Next, as shown in Fig. 1(b) and presented in Sec. 3, we
segment the records with a siding-window, and build snapshots of
DSNs from the segments using weighted, undirected graphs. Com-
munity detection is then performed by applying an extension of
the Clauset-Newman-Moore (CNM) algorithm for weighted graphs
to the snapshots. Finally, correspond to Fig. 1(c), we measure the
evolutionary behaviors, including the split, shrink, merge, and ex-
pand, of the communities detected in consecutive steps with the
information entropy-based indices proposed in Sec. 4. The index
values are aggregated to quantify community evolution at the net-
work level before we performing analysis in Sec. 5.

3 DSN AND COMMUNITY DETECTION
In this work, we use a weighted, undirected graph 𝐺 = h𝑉 , 𝐸, 𝑈 ,𝑊 i
to model the structure of a DSN, where a vertex 𝑣𝑖 ∈ 𝑉 represents
a user, and an edge 𝑒𝑖 𝑗 ∈ 𝐸 represents social interactions between
users 𝑣𝑖 and 𝑣 𝑗 . A positive, real-valued weight 𝑢𝑖 ∈ 𝑈 is assigned
to each vertex 𝑣𝑖 following Eq. (2) to quantify the user’s impor-
tance. And a weight 𝑤𝑖 𝑗 ∈ 𝑊 is assigned to each edge 𝑒𝑖 𝑗 following
Eq. (1) to quantify the strength of social interactions between the
users connected by the edge. The type of social interaction studied

3https://docs.github.com/en/graphql

in this paper is the joint discussion relationship between users on
OSS platforms such as GitHub. Platform users can post issues and
pull-requests to an OSS repository to ask questions and making
contributions [8, 59]. They can also provide responses by leaving
comments under posted issues and pull-requests. We use the term
a conversation to refer to the collection of the initial body and all
the comments to a single issue or pull-request. There is an edge 𝑒𝑖 𝑗
between two users, 𝑣𝑖 and 𝑣 𝑗 , if they join the same conversation.

3.1 Construct DSN Snapshots
We construct a series of DSN snapshots from the conversations of
an OSS repository.

3.1.1 Data Segmentation. Given a series of temporally ordered con-
versations obtained from a project’s repository, ®D = h𝑑1, 𝑑2, · · · , 𝑑𝑁 i,
where 𝑑𝑖 = h𝑡𝑖, 𝑉𝑖i, 𝑖 = 1 · · · 𝑁 , records the creation time 𝑡𝑖, and the
set of participants4 𝑉𝑖 of the 𝑖-th record, we apply a non-overlapping
sliding window of length 𝜔 to divide ®D into a series of segments
®S = h𝑠1, 𝑠2, · · · , 𝑠𝑇 i. The 𝑡-th segment in ®S include conversations
created in the 𝑡-th window, i.e., 𝑠𝑡 = {𝑑𝑖 |𝑡1 + (𝑡 − 1), 𝜔 ≤ 𝑡𝑖 <
𝑡1 + 𝑡𝜔)}, 𝑗 = 1 · · ·𝑇 , where 𝑡1 is the creation time of 𝑑1.

= h𝑉 𝐿

3.1.2 Build Local DSNs from Data Segments. For each segment
𝑠𝑡 ∈ ®S, we build its corresponding local DSN 𝐺𝐿
𝑡 ,𝑊 𝐿
𝑡 i
𝑡
by letting 𝑉 𝐿
to include all the participants of conversations in 𝑠𝑡 ,
𝑡
and 𝐸𝐿
𝑡 to include all the joint discussion relationships between the
users in 𝑉 𝐿
𝑡 , respectively. There is an edge between user 𝑣𝑖 and 𝑣 𝑗
if there is at least one conversation 𝑑𝑘 ∈ 𝑠𝑡 that both users are par-
ticipants of 𝑑𝑘 . 𝑈 𝐿
𝑡 and 𝑊 𝐿
include the weights of users and edges
𝑡
in the local DSN, which are calculated as follows.

𝑡 , 𝑈 𝐿

𝑡 , 𝐸𝐿

For each edge 𝑒𝑖 𝑗 ∈ 𝐸𝐿

𝑡 , there is a weight 𝑤𝑖 𝑗 ∈ 𝑊 𝐿
𝑡

that quan-
tiﬁes the strength of interactions between user 𝑣𝑖 and 𝑣 𝑗 . Let 𝑐𝑛𝑡𝑖 𝑗
be the count of conversations both 𝑣𝑖 and 𝑣 𝑗 participate in segment
𝑠𝑡 , we assign the weight 𝑤𝑖 𝑗 as follows.

𝑤𝑖 𝑗 = ln(𝑐𝑛𝑡𝑖 𝑗 + 1)

(1)

We take the natural logarithm of counts to prevent large counts to
overwhelm small ones. From Eq. (1), we have 𝑤𝑖 𝑗 = 0 if 𝑐𝑛𝑡𝑖 𝑗 = 0,
and 𝑤𝑖 𝑗 > 0 if 𝑐𝑛𝑡𝑖 𝑗 ≥ 0. Note we always have 𝑐𝑛𝑡𝑖 𝑗 = 0 if 𝑖 = 𝑗.
Further, we assign a weight 𝑢𝑖 ∈ 𝑈 𝐿
to
𝑡

for each user 𝑣𝑖 ∈ 𝑉 𝐿
𝑡

4The participants of a conversation include the author and the users leave comments
in the issue or pull-request.

Conference’17, July 2017, Washington, DC, USA

L. Wang, et al.

,

(cid:2869)

...

...

...

...

,

(cid:3037)

(cid:1855)(cid:3047)(cid:2878)(cid:2869)
,
…
(cid:3037)
(cid:1853)(cid:2869)

,

…
(cid:3037)
(cid:1853)(cid:3036)

,

…

...

...

...

,

(cid:3040)

(cid:1855)(cid:3047)(cid:2878)(cid:2869)
,
(cid:1840)(cid:1873)(cid:1864)(cid:1864)(cid:3047)(cid:2878)(cid:2869)
… …
(cid:3040)
(cid:1853)(cid:2869)
(cid:1854)(cid:2869)

,

… …
(cid:1853)(cid:3036)
(cid:1854)(cid:3036)

(cid:3040)

,

,

(cid:1855)(cid:3047)(cid:2878)(cid:2869)
,
… …
(cid:2869)
(cid:1853)(cid:2869)
(cid:1855)(cid:3047)

(cid:2869)

,

,

… …
(cid:1855)(cid:3047)
(cid:2869)
(cid:1853)(cid:3036)

(cid:3036)

,

,

...

...

(cid:1855)(cid:3047)

(cid:3041)

(cid:3037)

(cid:2869)

(cid:1853)(cid:3041)

(cid:1853)(cid:3041)
(cid:1856)(cid:3037)
(a)  Community member migration matrix 
to 

from time 

(cid:1856)(cid:3040)

(cid:1853)(cid:3041)

+ 1

(cid:1856)(cid:2869)

(cid:3040) (cid:1854)(cid:3041)

(cid:1840)(cid:1873)(cid:1864)(cid:1864)(cid:3047)

,

(cid:1855)(cid:3047)(cid:2878)(cid:2869)

(cid:2869)

,

(cid:2869)

(cid:2032)(cid:3036)

,

,

(cid:3036)

(cid:1855)(cid:3047)

(cid:2032)(cid:3036)

(cid:3037)
,

(cid:3040)

(cid:2032)(cid:3036)

(cid:2015)(cid:3036)

,

(cid:1855)(cid:3047)(cid:2878)(cid:2869)

(cid:3037)
…

,

(cid:1855)(cid:3047)(cid:2878)(cid:2869)

(cid:3040)

(cid:1840)(cid:1873)(cid:1864)(cid:1864)(cid:3047)(cid:2878)(cid:2869)

,

(cid:1855)(cid:3047)
(cid:3036)
…

,

(cid:3041)

(cid:1855)(cid:3047)

,

(cid:2869)

(cid:1855)(cid:3047)

,

(cid:3037)

(cid:2038)(cid:2869)

,

(cid:3037)

(cid:2038)(cid:3036)
,

(cid:3037)

(cid:2038)(cid:3041)

(cid:2020)(cid:3037)

(cid:1840)(cid:1873)(cid:1864)(cid:1864)(cid:3047)

,

(cid:1855)(cid:3047)(cid:2878)(cid:2869)

(cid:3037)

(b)  Members of a community 

migrate to 

,

(c)  Members of a community 

migrate from 

,

different communities in the next time step

(cid:3036)

(cid:1855)(cid:3047)

different communities in the previous time step

(cid:1855)(cid:3047)(cid:2878)(cid:2869)

(cid:3037)

(cid:1839)(cid:3047)

(cid:1872)

(cid:1872)

Figure 2: Migration of community members between consecutive time steps. With a slight abuse of notations, we omit the
time indicators 𝑡 and 𝑡 + 1 in the matrix shown in (a), and the weights shown in (b) and (c).

quantify the user’s importance in the DSN as follows.

𝑢𝑖 = ln(

|𝑉 𝐿
𝑡 |

Õ𝑗=1

𝑤𝑖 𝑗 + 1)

(2)

1 , 𝐺𝐿

2 , · · · , 𝐺𝐿

where |𝑉 𝐿
𝑡 | is the number of users in segment 𝑠𝑡 , and 𝑤𝑖 𝑗 is as de-
ﬁned in Eq. (1). Intuitively, a user with a large weight is a user who
actively interactions with many other users, who is considered im-
portant in the DSN. The minimal weight of a user 𝑣𝑖 is 𝑢𝑖 = 0 if the
user does not communicate with any other user in the segment.
With the above approach, we can extract a series of temporally
ordered local DSNs ®G𝐿 = h𝐺𝐿
𝑇 i from the segments ®S.
3.1.3 DSN Snapshots with Aggregated Local DSNs. While it is pos-
sible to perform subsequent community detection and evolution
analysis with the local DSNs above, it is not trivial to decide the op-
timal window size 𝜔 for segmentation [27]. A large window (e.g.,
from several months to a year [27]) allows us to take a compre-
hensive snapshot of the DSN with rich data. However, it keeps us
from performing ﬁne-grained community evolution analysis due
to the large time gap between consecutive windows. On the other
hand, a small window allows us to perform ﬁne-grained commu-
nity evolution analysis. But a short window may cover too few data
to generate a useful snapshot.

To support ﬁne-grained analysis with suﬃcient data, we gener-
ate DSN snapshots by aggregating multiple local DSNs built from
one week’s data. We empirically set each snapshot to contain twelve
local DSNs to cover data in three months. We assign more credits
to recent data than early data in the snapshot by multiplying a de-
caying factor to the edge weights of the local DSNs. Let 𝐺𝐿
𝑡−𝑖 be the
𝑖th local DSN being included in the snapshot for time 𝑡, we decay
its edge weights, 𝑊 𝐿
𝑡−𝑖 , with a factor 𝛾𝑖 , where 𝛾 is heuristically set
to 𝑒−1. With the above approach, we can obtain a series of DSN
snapshots ®G = h𝐺1, 𝐺2, · · · , 𝐺𝑇 i by aggregating local DSNs.

3.2 Detect Communities in DSN Snapshots
The communities studied in this work are groups of users with
close and intensive interactions among each other in a snapshot of
DSN. Given the 𝑡-th snapshot of a DSN, 𝐺𝑡 = h𝑉𝑡 , 𝐸𝑡 , 𝑈𝑡 ,𝑊𝑡 i ∈ ®G,
we adopt the extension [12, 42] of the Clauset-Newman-Moore

(CNM) greedy modularity maximization algorithm [41, 43] to de-
tect the communities within it. Developed from the traditional CNM
algorithm for unweighted graphs, the extended version of CNM
performs commnity detection on weighted graphs using the strength
of connections between nodes indicated by the edge weights.

The result of community detection for 𝐺𝑡 is a set of non-overlapping

communities 𝐶𝑡 = {𝑐𝑡,1, 𝑐𝑡,2, · · · , 𝑐𝑡,𝑛 }, where 𝑐𝑡,𝑖 ⊆ 𝑉𝑡 contains
a subset of users in the social network with strong internal joint
discussion relationships. Communities involve only a single mem-
ber are removed. By applying community detection to all the snap-
shots in ®G, we obtain a series of evolving communities over time
®C = h𝐶1, 𝐶2, · · · , 𝐶𝑡, · · · , 𝐶𝑇 i. In the next section, we propose met-
rics to measure community evolution in ®C.

4 COMMUNITY EVOLUTION INDICES
Based on the temporally ordered series of communities ®C detected
in the above section, this section presents the process and metrics
proposed to measure community evolution.

4.1 Community Member Migration Matrix
Given two consecutive sets of communities in ®C, e.g., 𝐶𝑡 and 𝐶𝑡+1,
we compute a community member migration matrix to quantify
member migration between the communities as shown in Fig. 2(a).
Let 𝑛 = |𝐶𝑡 | and 𝑚 = |𝐶𝑡+1| be the number of communities in 𝐶𝑡
and 𝐶𝑡+1 (without loss of generality, we assume 𝑛 ≥ 1 and 𝑚 ≥ 1),
respectively, we obtain a (𝑛 + 1) × (𝑚 + 1) matrix 𝑀𝑡 where the
𝑖 𝑗-th element 𝑎𝑖,𝑗 is the number of members migrate from 𝑐𝑡,𝑖 to
𝑐𝑡+1,𝑗 , calculated following Eq. (3), for 𝑖 ≤ 𝑛 and 𝑗 ≤ 𝑚.

𝑎𝑖,𝑗 = 𝑐𝑡,𝑖 ∩ 𝑐𝑡+1,𝑗 , 𝑖 = 1, 2, ..., 𝑛, 𝑗 = 1, 2, ..., 𝑚

(3)

where 𝑐𝑡,𝑖 ∩ 𝑐𝑡+1,𝑗 is the set of common users in 𝑐𝑡,𝑖 and 𝑐𝑡+1,𝑗 , i.e.,
the set of users in 𝑐𝑡,𝑖 who migrate to 𝑐𝑡+1,𝑗 . Member migration be-
tween exiting communities in consecutive time steps correspond
to the solid arrows in Fig. 2(b) and (c), respectively.

Two 𝑁𝑢𝑙𝑙 communities, 𝑁𝑢𝑙𝑙𝑡+1 and 𝑁𝑢𝑙𝑙𝑡, are added to 𝐶𝑡+1
and 𝐶𝑡 to include members not involved in these communities.
The 𝑁𝑢𝑙𝑙𝑡+1 community involves members of a community in 𝐶𝑡
who leave the project in time 𝑡 + 1, i.e., members of 𝐶𝑡 who do
not show in any community in 𝐶𝑡+1. And the 𝑁𝑢𝑙𝑙𝑡 community in-
clude newly joined members in a community in 𝐶𝑡+1 who do not

Quantitative Analysis of Community Evolution in Developer Social Networks Around Open Source Software Projects

Conference’17, July 2017, Washington, DC, USA

appear in any community in 𝐶𝑡 . Elements related to the 𝑁𝑢𝑙𝑙 com-
munities are in the last column and row of 𝑀𝑡 as illustrated in Fig.
2(a), which are calculated following Eq. (4).

𝑚

𝑏𝑖 = 𝑐𝑡,𝑖 \

𝑎𝑖,𝑗, 1 ≤ 𝑖 ≤ 𝑛

Ø𝑗=1
and 𝑑 𝑗 = 𝑐𝑡+1,𝑗 \

𝑛

𝑎𝑖,𝑗, 1 ≤ 𝑗 ≤ 𝑚

(4)

Ø𝑖=1

Ð

𝑚
where
𝑗=1 𝑎𝑖,𝑗 is the set of members in 𝑐𝑡,𝑖 who stay in the project
𝑛
(and join an arbitrary community) in time 𝑡 + 1, and
𝑖=1 𝑎𝑖,𝑗 is the
set of members in 𝑐𝑡+1,𝑗 who migrate from an existing community
in time 𝑡. As a result, members from 𝑐𝑡,𝑖 who leave the project (into
𝑁𝑢𝑙𝑙𝑡+1), and members in 𝑐𝑡+1,𝑗 who are new comers (from 𝑁𝑢𝑙𝑙𝑡 )
𝑚
𝑛
are contained in sets 𝑏𝑖 = 𝑐𝑡,𝑖 \
𝑗=1 𝑎𝑖,𝑗 and 𝑑 𝑗 = 𝑐𝑡+1,𝑗 \
𝑖=1 𝑎𝑖,𝑗 ,
which correspond to the dashed arrows in Fig. 2(b) and (c), respec-
Ð
tively. We omit time indicators for matrix elements, i.e., 𝑎𝑖,𝑗 , 𝑏𝑖 , and
𝑑 𝑗 , to keep it concise.

Ð

Ð

The weights on arrows in Fig. 2(b) quantify the distribution of
members migrate to diﬀerent communities from 𝑐𝑡,𝑖 with respect
to their weights at time 𝑡, which are obtained following Eq. (5).

𝜓𝑖,𝑗 =

𝑓𝑡 (𝑎𝑖,𝑗 )
𝑓𝑡 (𝑐𝑡,𝑖 )

, 𝑗 = 1, 2, ..., 𝑚, and 𝜂𝑖 =

𝑓𝑡 (𝑏𝑖 )
𝑓𝑡 (𝑐𝑡,𝑖)

(5)

where 𝑎𝑖,𝑗 and 𝑏𝑖 are sets of users as deﬁned in Eq. (3) and Eq. (4),
respectively; 𝑐𝑡,𝑖 is the set of the community’s members; let 𝑥 be a
set of users, function 𝑓𝑡 (𝑥) is the sum of weights for users in set 𝑥,
and the subscript 𝑡 indicate the weights are given by snapshot 𝐺𝑡 :

𝑓𝑡 (𝑥) =

𝑢𝑖, 𝑢𝑖 ∈ 𝑈𝑡 , 𝑥 ⊆ 𝑉𝑡

𝑣𝑖 ∈𝑥
Õ

Similarly, the weights in Fig. 2(c) are calculated following Eq.
(6) to quantify the distribution of members in 𝑐𝑡+1,𝑗 from diﬀerent
sources based on their weights in snapshot 𝐺𝑡+1 given by 𝑓𝑡+1 (·).

𝜙𝑖,𝑗 =

𝑓𝑡+1 (𝑎𝑖,𝑗 )
𝑓𝑡+1 (𝑐𝑡+1,𝑗 )

, 𝑖 = 1, 2, ..., 𝑛, and 𝜇 𝑗 =

𝑓𝑡+1 (𝑑 𝑗 )
𝑓𝑡+1 (𝑐𝑡+1,𝑗 )

(6)

4.2 Entropy-Based Community Evolution
Indices for A Single Community

In this section, we propose to measure the evolution of a single
community between consecutive time steps, i.e., time 𝑡 and 𝑡 +
1, based on the information entropy of the weight distributions
shown in Fig. 2(b) and (c). While existing works describe com-
munity evolution with six patterns including split, shrink, extinct,
merge, expand, and emerge [27], we omit the extinct and emerge
patterns because they are special cases of community evolution
studied in this work, as discussed in Sec. 4.2.4. More importantly,
diﬀerent from existing works [27, 46] that assign a single pattern
to each matched pair of communities, we propose that the evolu-
tionary behaviors take place in every pair of communities in con-
secutive time steps simultaneously, just a matter of degrees. As a
result, we do not require to ﬁnd the match between prior and post
communities.

4.2.1 The split and shrink indices of community 𝑐𝑡,𝑖 . We use a com-
munity detected in time 𝑡, i.e., 𝑐𝑡,𝑖 , as shown in Fig. 2(b) to explain
how the split and shrink indices are calculated.

Given the 𝑚 + 1 communities in the next time step (which in-
clude the 𝑚 detected communities in 𝐶𝑡+1, and 𝑁𝑢𝑙𝑙𝑡+1), and the
weight vector h𝜓𝑖,1, 𝜓𝑖,2, · · · ,𝜓𝑖,𝑚, 𝜂𝑖i, we obtain the distribution of
users’ weights who stay in the project by normalizing their actual
weights:

ˆ𝜓𝑖,𝑗 =

𝜓𝑖,𝑗
𝑚
𝑗=1 𝜓𝑖,𝑗

(7)

Clearly, we have
tion entropy [55] of the normalized weight vector by:

ˆ𝜓𝑖,𝑗 = 1. And we can calculate the informa-

𝑚
𝑗=1

Í

Í

H𝑐𝑡,𝑖

= −

𝑚

Õ𝑗=1

ˆ𝜓𝑖,𝑗 log2 ( ˆ𝜓𝑖,𝑗 )

(8)

With 𝑚 ﬁxed, the entropy H𝑐𝑡,𝑖 is upper-bounded by the following
maximum entropy obtained when ˆ𝜓𝑖,𝑗 = 1
𝑚 , 𝑗 = 1, 2, · · · , 𝑚:
1
𝑚

= − log2 (

𝑡→𝑡+1

H ∗

(9)

)

Intuitively, H𝑐𝑡,𝑖 measures the degree of 𝑐𝑡,𝑖 ’s members spread into
diﬀerent communities (excluding 𝑁𝑢𝑙𝑙𝑡+1) in the next step. And
H ∗
𝑡→𝑡+1 − H𝑐𝑡,𝑖 measures the degree of 𝑐𝑡,𝑖 ’s members gather to a
single community in the next step. Both H𝑐𝑡,𝑖 and H ∗
𝑡→𝑡+1 − H𝑐𝑡,𝑖
are equal or above zero. Based on the entropy in Eq. (8), we com-
pute community 𝑐𝑡,𝑖 ’s split and shrink indices as follows.

The split index of 𝑐𝑡,𝑖 , denoted as I𝜓

𝑐𝑡,𝑖 , measures the degree of
separation of its members into concrete communities detected in
the next step, which is calculated as:

I𝜓
𝑐𝑡,𝑖

= (1 − 𝜂𝑖)H𝑐𝑡,𝑖

(10)

where 𝜂𝑖 is deﬁned in Eq. (5).

The shrink index of 𝑐𝑡,𝑖 , denoted as I𝜂

𝑐𝑡,𝑖 , measures the degree of

its members move to the 𝑁𝑢𝑙𝑙𝑡+1 community in the next step:

I𝜂
𝑐𝑡,𝑖

= 𝜂𝑖 (H ∗

𝑡→𝑡+1 − I𝜓

𝑐𝑡,𝑖 + 𝜎𝜂𝑖 )

(11)

where 𝜎𝜂𝑖 is deﬁned as follows to guarantee that the shrink index
is always positive when 𝑚 ≥ 1 and 𝜂𝑖 > 0.

=

𝜎𝜂𝑖

0.5𝜂𝑖
0

(

, 𝑚 = 1,
, 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒.

(12)

4.2.2 Properties of the split and shrink indices. Fig. 3 illustrates the
curves of the indices under varying conditions. The proposed split
index, I𝜓
𝑐𝑡,𝑖 , have the following properties
that are desirable when measuring community evolution.

𝑐𝑡,𝑖 , and shrink index, I𝜂

I𝜓
𝑐𝑡,𝑖 and I𝜂

𝑐𝑡,𝑖 are strictly monotonic increasing functions of 𝑚,
given that 𝜂𝑖 is ﬁxed, and ˆ𝜓𝑖,𝑗 = 1/𝑚, 𝑗 = 1, 2, · · · , 𝑚. Intuitively,
the property states that when a ﬁxed portion of members in com-
munity 𝑐𝑡,𝑖 leave the project (i.e., 𝜂𝑖 ﬁxed), and the remaining mem-
bers of 𝑐𝑡,𝑖 who stay in the project migrate evenly to the commu-
nities detected in the next step (i.e., ˆ𝜓𝑖,𝑗 = 1/𝑚, 𝑗 = 1, 2, · · · , 𝑚),
the split and shrink indices increase with the increasing number
of communities detected in the next step (i.e., 𝑚).

I𝜂
𝑐𝑡,𝑖 / I𝜓

𝑐𝑡,𝑖 is a strictly monotonic increasing / decreasing func-
tion of 𝜂𝑖, respectively, given that 𝑚 > 1 and the distribution of
ˆ𝜓𝑖,𝑗, 𝑗 = 1, 2, · · · , 𝑚 ﬁxed. Intuitively, this property states that the

Conference’17, July 2017, Washington, DC, USA

L. Wang, et al.

2.2

2

1.8

1.6

1.4
(cid:3103)

(cid:3284)
(cid:3295)
(cid:3030)
(cid:1835)

1.2

1

0.8

0.6

0.4

0.2

0

)

,

(

x
e
d
n

I

t
i
l

p
S

= 4 even distribution
= 4 random distribution

= 3 even distribution

(cid:1865)

(cid:1865)

= 3 random distribution

= 2 even 
distribution
(cid:1865)

(cid:1865)

(cid:1865)

= 1

0

(cid:1865)

0.2

0.4

0.6

0.8

1

(a) Split Index

(cid:2015)(cid:3036)

= 4 random distribution

= 4 even distribution
(cid:1865)

= 3 random distribution

(cid:1865)

= 3 even distribution

(cid:1865)

= 2 random 

(cid:1865)
distribution
(cid:1865)

2.2

2

1.8

1.6

)

,

(cid:3086)

(cid:3284)
1.4
(cid:3295)
(cid:3030)
(cid:1835)

(

x
e
d
n

I
k
n
i
r
h
S

1.2

1

0.8

0.6

0.4

0.2

0

0

0.2

0.4

0.6

(b) Shrink Index
(cid:2015)(cid:3036)

= 1

1

0.8

(cid:1865)

Figure 3: Curves of the split and shrink indices under diﬀer-
ent conditions speciﬁed by 𝑚, 𝜂𝑖, and ˆ𝜓𝑖,𝑗 . The even distribu-
tion corresponds to case ˆ𝜓𝑖,𝑗 = 1
𝑚 , 𝑗 = 1, · · · , 𝑚. The random
distribution is obtained by randomly assigning ˆ𝜓𝑖,𝑗 ’s values.

shrink / split index increases / decreases with the increasing por-
tion of users who leave the project (i.e., 𝜂𝑖), respectively. A special
case is that when 𝑚 = 1, we have I𝜓
= 0, ∀𝜂𝑖 ∈ [0, 1], which is
𝑐𝑡,𝑖
intuitively correct that the community cannot split if there is only
one community detected in the next step. For the shrink index I𝜂
𝑐𝑡,𝑖 ,
we guarantee that I𝜂
𝑐𝑡,𝑖 is a strictly monotonic increasing function
of 𝜂𝑖 for 𝑚 ≥ 1 by introducing the term 𝜎 as deﬁned in Eq. (12).

= (1−𝜂𝑖)H ∗

Given 𝑚 and 𝜂𝑖, the maximum split index I𝜓
𝑐𝑡,𝑖

𝑡→𝑡+1
is obtained when the members of 𝑐𝑡,𝑖 migrate to the communities
detected in the next step with a even distribution, i.e., when we
have ˆ𝜓𝑖,𝑗 = 1/𝑚, 𝑗 = 1, 2, · · · , 𝑚. And the minimum split index
I𝜓
= 0 is obtained when all the members of 𝑐𝑡,𝑖 who stay in
𝑐𝑡,𝑖
the project migrate to a single community in the next step, i.e.,
there exists a 𝑗 ′-th community in time 𝑡 + 1 that ˆ𝜓𝑖,𝑗′ = 1 and
ˆ𝜓𝑖,𝑗 = 0, ∀𝑗 ≠ 𝑗 ′, resulting in H𝑐𝑡,𝑖

= 0.
Given 𝑚 > 1 and 𝜂𝑖, the maximum shrink index I𝜂
𝑐𝑡,𝑖

𝑡→𝑡+1
is obtained when the corresponding split index is minimized, i.e.,
all stayed members of community 𝑐𝑡,𝑖 migrate to a single com-
munity in the next step. And the minimum shrink index I𝜂
=
𝑐𝑡,𝑖
𝑖 H ∗
𝜂2
𝑡→𝑡+1 is obtained when the members of 𝑐𝑡,𝑖 migrate evenly to
communities in time 𝑡 + 1. For the special case of 𝑚 = 1, the shrink
index is only determined by 𝜂𝑖 and 𝜎𝜂𝑖 .

= 0 and I𝜓
𝑐𝑡,𝑖

= 𝜂𝑖H ∗

It is straightforward to proof the above properties given the in-
dices’ deﬁnitions and the properties of information entropy [55].
We omit the proof in this paper due to page limits.

4.2.3 The merge and expand indices of 𝑐𝑡+1,𝑗 . Next, to measure
community evolution on community 𝑐𝑡+1,𝑗 ’s side as shown in Fig.
2(c), we develop the merge and expand indices of 𝑐𝑡+1,𝑗 following
a similar framework as described above.
The merge index of 𝑐𝑡+1,𝑗 , denoted as I𝜙

𝑐𝑡 +1,𝑗 , measures the degree
of its members that come from diﬀerent source communities in the
previous time step, which is calculated as follows.

I𝜙
𝑐𝑡 +1,𝑗

= (1 − 𝜇 𝑗 )H𝑐𝑡 +1,𝑗

(13)

The expand index of 𝑐𝑡+1,𝑗 , denoted as I𝜇

where 𝜇 𝑗 and H𝑐𝑡 +1,𝑗 are deﬁned in Eq. (6) and Eq. (15), respectively.
𝑐𝑡 +1,𝑗 , measures the de-
gree of its members emerge from 𝑁𝑢𝑙𝑙𝑡 in the previous step as
follows.

I𝜇
𝑐𝑡 +1,𝑗

= 𝜇 𝑗 (H ∗

𝑡+1←𝑡 − I𝜙

𝑐𝑡 +1,𝑗 + 𝜎𝜇 𝑗 )

(14)

where 𝜎𝜇 𝑗 is as deﬁned similar to 𝜎𝜂𝑖 as follows.

𝜎𝜇 𝑗

=

0.5𝜇 𝑗
0

(

, 𝑛 = 1,
, 𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒.

The entropy values in the above equations are computed by:

𝑛

= −

1
𝑛

H ∗

𝑡+1←𝑡

= − log2 (

), and H𝑐𝑡 +1,𝑗

ˆ𝜙𝑖,𝑗 log2 ( ˆ𝜙𝑖,𝑗 )

(15)

Õ𝑖=1
where ˆ𝜙𝑖,𝑗 =
is the normalized weights. The merge and
expand indices have similar properties as split and shrink, respec-
tively. We omit the details to keep the paper concise.

𝜙𝑖,𝑗
𝑛
𝑖=1 𝜙𝑖,𝑗

Í

4.2.4 Community Extinction and Emergence. With the above in-
dices, community extinction and emerges are two special combi-
nations of index values as follows:

The extinction of a community 𝑐𝑡,𝑖 happens if all of its members
leave the project and migrate to 𝑁𝑢𝑙𝑙𝑡+1, which leads to the case
that 𝜂𝑖 = 1 and H𝑐𝑡,𝑖
= 0. In this case, the shrink index takes the
maximum value of I𝜂
5. And the split index takes
𝑐𝑡,𝑖
the minimum value of I𝜓
𝑐𝑡,𝑖

𝑡→𝑡+1 + 𝜎𝜂𝑖
= 0.

= H ∗

The emergence of a new community 𝑐𝑡+1,𝑗 happens if all its mem-
bers are from 𝑁𝑢𝑙𝑙𝑡, in which case we have 𝜇 𝑗 = 1, and H𝑐𝑡 +1,𝑗
= 0.
In this case, the expand index takes the maximum value of I𝜇
=
H ∗
𝑡+1←𝑡 + 𝜎𝜇 𝑗 . And the merge index takes the minimum value of
I𝜙
𝑐𝑡 +1,𝑗

= 0.

𝑐𝑡 +1,𝑗

There are more combinations of the index values that form mean-

ingful cases, which we leave for our future studies.

4.3 Aggregate Indices for All Communities
Following the above process, for each community we can obtain
indices that quantify its degree of split and shrink with respect
to the next step, and its degree of merge and expand with respect
to the previous step. We calculate the aggregated indices for the
four patterns across all communities in the snapshot by taking the
weighted average of the communities’ indices, where the weight
for a community is the sum of node weights in the community over
the total weight of nodes in all communities. We can then obtain
four aggregated indices that measure the overall, snapshot-level
community evolution for each time step.

5 EMPIRICAL STUDIES
In this section, we conduct empirical studies to evaluate the valid-
ity and usefulness of the proposed community evolution measures.

5.1 Preliminaries
5.1.1 Data Set. As summarized in Table 1, we collect a data set
involving thirty-two OSS projects on GitHub to conduct the stud-
ies. The projects are randomly selected from a candidate set of
popular (with #𝑠𝑡𝑎𝑟𝑠 ≥ 1000) projects with suﬃcient data (with
#𝐶𝑜𝑛𝑣. ≥ 800) that cover diﬀerent topics including programming

5When I𝜂
𝑐𝑡,𝑖 takes the maximum value, we have 𝜎𝜂𝑖
𝑚 > 1. Similar for the value of 𝜎𝜇 𝑗 in the case of emergence.

= 0.5 if 𝑚 = 1, and 𝜎𝜂𝑖

= 0 if

 
 
 
 
Quantitative Analysis of Community Evolution in Developer Social Networks Around Open Source Software Projects

Conference’17, July 2017, Washington, DC, USA

Table 1: Overview of the data set, where # Conv. is the count of conversations, #Weeks is the time duration of the project’s
data, and Status indicates whether the project is active by the end of May, 2019.

No. Project

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

angular-ui/bootstrap
apache/couchdb
beautify-web/js-beautify
boltdb/bolt
carrierwaveuploader/ carrierwave
celery/celery
Compass/compass
davezuko/react-redux-starter-kit
divio/django-cms
django-extensions/django-extensions
eczarny/spectacle
eventmachine/ eventmachine
facebookincubator/create-react-app
i3/i3
JakeWharton/ ActionBarSherlock
jcjohnson/neural-style

#Conv. #Weeks
34783
9211
6151
2830
10531
26594
2692
6138
27416
5716
4198
4565
28207
17286
4860
3328

342
522
475
221
528
521
484
156
526
528
456
526
79
532
341
191

jekyll/jekyll
jessesquires/ JSQMessagesViewController
jruby/jruby
junit-team/junit4
kevinzhow/PNChart

Status No. Project
17
inactive
18
active
19
active
20
inactive
21
active
22 mbleigh/acts-as-taggable-on
active
23
inactive
24
inactive
25
active
26
active
27
inactive
28
active
29
inactive
30
active
31
inactive
32
inactive

onevcat/VVDocumenter-Xcode
prawnpdf/prawn
Prinzhorn/skrollr
rails/rails
redis/redis-rb
sferik/twitter
Shopify/liquid
sinatra/sinatra
sparklemotion/nokogiri
thoughtbot/paperclip

#Conv. #Weeks
46354
10390
28347
2840
939
3786
854
5161
3729
196487
4000
3934
6125
6598
10516
13025

530
305
527
501
277
526
231
526
299
2578
523
521
526
531
530
524

Status
active
inactive
active
active
inactive
active
inactive
active
inactive
active
active
active
active
active
active
active

language (e.g., rails/rails), social networks (e.g., sferik/twitter), data-
base (e.g., apache/couchdb), mobile (e.g., Prinzhorn/skrollr), and etc.
Among the projects, twelve inactive projects–determined follow-
ing the process in [13]–are included to cover projects in diﬀer-
ent stages. For each project, we retrieve data starting from its ear-
liest record on the platform to the end of May, 2019 from two
sources: the GHTorrent database [22] and the Github GraphQL
API6. The data for issue and pull-request discussions are extracted
for community detection and calculating community evolution in-
dices. We also retrieve the commit history of the repositories to
support correlation analysis between community evolution and
team productivity.

5.1.2 Experiment Organization. We evaluate the construct valid-
ity of the proposed indices with the concurrent and discriminant
validity criteria following exiting work and guides [31, 38, 50]. As
deﬁned in [31], construct validity is “the extent to which your mea-
sure or instrument actually measures what it is theoretically sup-
posed to measure”. In this work, we aim at showing the proposed
indices are eﬀective in capturing and quantifying community evo-
lutionary behaviors of DSNs around OSS projects.

First, we adopt the concurrent validity criterion to validate the
proposed indices. Concurrent validity accesses the ability of a mea-
sure to distinguish between groups it should theoretically be able
to distinguish between [31, 50]. In this work, we compare the cate-
gorical evolution patterns detected following an existing approach
[27] with the patterns detected using the proposed indices.

Next, we evaluate the discriminant validity of the indices which
requires the dimensions to be independent or orthogonal to each
other. Based on the properties of the indices discussed in Sec. 4.2.2,
and by further evaluating the discriminant validity of the measures,
we aim at showing that the proposed indices are capable of mea-
suring diﬀerent aspects of community evolution.

Unfortunately, we are unable to assess the convergent validity
of the proposed indices because to the best of our knowledge, this
is the ﬁrst work that quantiﬁes the degree of community evolution
that include diﬀerent evolution patterns simultaneously.

Besides construct validity, we also show the usefulness of the
proposed indices by studying their correlations with projects’ team

6https://developer.github.com/v4/

Table 2: Rules to determine the evolution patterns of a com-
munity, e.g., the 𝑖th community at time 𝑡, 𝑐𝑡,𝑖 .

Pattern Existing Approach [27]
extinct

Community 𝑐𝑡,𝑖 has no matching
post community.

emerge

Community 𝑐𝑡,𝑖 has no matching
prior community.

split

shrink

merge

expand

Community 𝑐𝑡,𝑖 has at least two
communities in its post commu-
nity set.
Community 𝑐𝑡,𝑖 has only one com-
munity in its post community set,
and the size of the post commu-
nity is less than the size of 𝑐𝑡,𝑖 .†
Community 𝑐𝑡,𝑖 has at least two
communities in its prior commu-
nity set.
Community 𝑐𝑡,𝑖 has only one com-
munity in its prior community set,
and the size of the prior commu-
nity is less than the size of 𝑐𝑡,𝑖 .

Our Approach
I𝜓
𝑐𝑡,𝑖 ≤ 0.05( H∗
𝑡→𝑡 +1 + 𝜎𝜂𝑖 ) and
I𝜂
≥ 0.95( H∗
𝑡→𝑡 +1 +𝜎𝜂𝑖 ), i.e., split
𝑐𝑡,𝑖
index close to zero and shrink index
close to the maximum value.
I𝜙
𝑐𝑡,𝑖 ≤ 0.05( H∗
𝑡←𝑡 −1 + 𝜎𝜇𝑖 ) and
I 𝜇
𝑐𝑡,𝑖 ≥ 0.95( H∗
𝑡←𝑡 −1 + 𝜎𝜇𝑖 ), i.e.,
merge index close to zero and expand
index close to the maximum value.
I𝜓
> I𝜂
𝑐𝑡,𝑖
than shrink index.

𝑐𝑡,𝑖 , i.e., split index greater

< I𝜂

I𝜓
𝑐𝑡,𝑖
shrink index.

𝑐𝑡,𝑖 , i.e., split index less than

I𝜙
> I 𝜇
𝑐𝑡,𝑖
than expand index.

𝑐𝑡,𝑖 , i.e., merge index greater

< I 𝜇
I𝜙
𝑐𝑡,𝑖
than expand index.

𝑐𝑡,𝑖 , i.e., merge index less

undeﬁned Others.
† The size of a community is the sum of its members’ node weights. We also slightly
modify the rule for shrink in [27] to compare the size of 𝑐𝑡,𝑖 with its post community
to make the detection results comparable to ours.

Others.

productivity measured by the count of commits [11, 63]. Details of
the experiments and their results are as follows.

5.2 Concurrent Validity
We evaluate the concurrent validity of the proposed indices by
comparing the community evolution pattern detection results of
our approach and existing approaches. We adopt the process pro-
posed in [27] to detect community evolution patterns in DSNs which
serve as the ‘ground-truth’ for evaluation. More speciﬁcally, for
consecutive time steps 𝑡 and 𝑡 + 1, we ﬁrst calculate the similarity

Conference’17, July 2017, Washington, DC, USA

L. Wang, et al.

Evolution patterns detected with the proposed approach

split

shrink merge

expand

emerge

extinct

undefined

split

shrink

merge

expand

emerge

extinct

15145

221

3964

3603

0

0

0

0

0

0

0

4

0

0

0

136

14881

245

3745

4374

18

0

420

0

undefined

4379

3726

4035

7598

0

0

0

2

5068

0

492

0

3

0

0

0

5570

0

58

0

53

0

0

527

195197

d
e
t
c
e
t
e
d
s
n
r
e
t
t
a
p
n
o
i
t
u
o
v
E

l

h
c
a
o
r
p
p
a
g
n
i
t
s
i
x
e
h
t
i

w

Evolution patterns detected with the proposed approach

split

shrink merge

expand

emerge

extinct

undefined

split

shrink

merge

expand

emerge

extinct

20363

363

1211

3536

0

0

0

0

0

0

0

0

0

0

0

24

19536

722

1331

4261

0

0

31

0

undefined

1918

3816

1812

7709

0

0

0

4

5066

0

492

0

4

0

0

0

5569

0

64

0

80

0

0

527

195025

d
e
t
c
e
t
e
d
s
n
r
e
t
t
a
p
n
o
i
t
u
o
v
E

l

h
c
a
o
r
p
p
a
g
n
i
t
s
i
x
e
h
t
i

w

(a) Threshold = 0.3. Accuracy: 89.2%. Accuracy (w/o. ‘undefined’): 84.7%.

(b) Threshold = 0.1. Accuracy: 92.7%. Accuracy (w/o. ‘undefined’): 94.1%.

Figure 4: Confusion matrices that compares the community evolution patterns detected with existing approach [27] and the
proposed approach following rules speciﬁed in Table 2.

between each pair of communities detected in the two DSN snap-
shots. The generation of DSN snapshots and detection of commu-
nities are the same as introduced in Sec. 3 to conduct a fair com-
parison. Slightly diﬀerent from the original algorithm, the size of a
community is deﬁned as the sum of its members’ weights instead
of the count of its members. The similarity of two communities is
the sum of weights of their common nodes over the smaller value
of the two communities’ total weights. We take the threshold of
0.3 proposed in the original work to perform community matching.
Based on the matching results, we adopt rules in Table 2 to deter-
mine the evolution patterns for each community. We modify the
rule for determining community shrink by comparing a commu-
nity’s size with its matching community in the next step to make
the results comparable with ours. With these rules, for each com-
munity, we can assign two evolution patterns to it: 1) one to de-
scribe how it evolves towards the next step, which can be extinct,
split, or shrink; 2) the other to describe how it evolves from the
previous step, which includes emerge, merge, and expand. An un-
deﬁned pattern is added to label cases that are not included in the
existing set of rules.

For community evolution pattern detection using the indices
proposed in this paper, we simply compare the index values to de-
termine the patterns of community split, shrink, merge, and expand
as shown in Table 2. For a community, say community 𝑐𝑡,𝑖 , to ex-
tinct, the ideal case is that its split index is zero (I𝜓
= 0), and its
𝑐𝑡,𝑖
shrink index takes the maximum value (I𝜂
= H ∗
𝑡→𝑡+1 + 𝜎𝜂𝑖 ) as
𝑐𝑡,𝑖
discussed in Sec. 4.2.4. However, this condition is too stringent to
eﬀectively detecting community extinction in real-world data. As
a result, we relax the condition as shown in Table 2 that label a
community to extinct when its split index is close to zero, and its
shrink index is close to the maximum value. The same relaxation
also applies to the rule to detect community emerge.

The confusion matrix that compares the ground-truth and our
detection results is shown in Fig. 4(a). The overall accuracy of our
approach involving all six patterns and the undeﬁned pattern is
89.2%. Because the undeﬁned pattern is not clearly deﬁned in exist-
ing work [27, 46], we also evaluate the accuracy by removing the
undeﬁned label (i.e., by removing the last column and row in the
confusion matrix). Without the undeﬁned label, the overall accu-
racy is 84.7%. From Fig. 4(a), we can observe that 52% of the shrink

Table 3: Interpretation of correlation coeﬃcients (𝑟 ).

Levels
Perfect

Correlation Coeﬃcients (𝑟 )
𝑟 = 1 or 𝑟 = −1
0.7 ≤ 𝑟 < 1 or −1 < 𝑟 ≤ −0.7

Strong
Moderate 0.4 ≤ 𝑟 < 0.7 or −0.7 < 𝑟 ≤ −0.4
0.1 ≤ 𝑟 < 0.4 or −0.4 < 𝑟 ≤ −0.1
0 ≤ 𝑟 < 0.1 or −0.1 < 𝑟 ≤ 0

Weak

No

Symbols
P

S

M

W

N

cases are classiﬁed as split with our approach. And 45.8% of the ex-
pand cases are detected as merge. This is because there is a thresh-
old of 0.3 to ﬁlter out matching but less similar communities in the
exiting approach. As a result, the ground-truth is biased to shrink
and expand compared to our approach which does not perform ﬁl-
tering. Since there is no evidence showing that the threshold of 0.3
is the optimal one, we repeat the test by setting a threshold of 0.1
to increase the chance of community matching when obtaining the
ground-truth. As shown in Fig. 4(b), we can observe that the detec-
tion accuracy with and without the undeﬁned pattern increases to
92.7% and 94.1%, respectively.

The above results suggest that, with a simple set of rules, the
proposed indices can accurately distinguish between diﬀerent pat-
terns of community evolution which are consistent with the re-
sults obtained following the existing approach [27]. We conclude
that the proposed indices for community evolution are valid with
respect to the concurrent validity criterion.

5.3 Discriminant Validity
We calculate the Spearman’s Correlation Coeﬃcients of each pair
of the indices given a project. Spearman’s Correlation Coeﬃcients
are selected over the Pearson’s Correlation Coeﬃcients because
we ﬁnd that the indices do not always follow normal distributions.
We adopt the rule of thumb in [2, 18] to interpret the correlation
coeﬃcients, i.e., the 𝑟 values, as summarized in Table 3. It is worth
noting that a strong correlation alone does not invalidate the de-
sign of the proposed measure because the correlations between
community evolution indices are largely determined by the mem-
bers’ activities in real-world OSS repositories. The phenomenon
we would like to observe in this study is that whether there are
occasions that the indices are weakly correlated in the real-world.

 
 
 
 
 
 
 
 
 
 
Quantitative Analysis of Community Evolution in Developer Social Networks Around Open Source Software Projects

Conference’17, July 2017, Washington, DC, USA

Table 4: Pairwise correlation of the aggregated indices
(Spearman’s Correlation Coeﬃcient). Project No. follow Ta-
ble 1. Notations follow Table 3. The signiﬁcance levels are
shown without the 𝑝 values to make the table concise.

Table 5: Correlation between log transformed community
evolution indices and team productivity. The later is mea-
sured by 𝑙𝑜𝑔(count of commits + 0.5). Regression analysis
with linear mixed-eﬀects models.

Project No. split-shrink

split-merge

split-expand shrink-merge shrink-expand merge-expand

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

-0.05 ( N )

0.41 ( M )***

0.05 ( N )

-0.06 ( N )

0.50 ( M )***

0.12 ( W )*

0.23 ( W )***

0.73 ( S )***

0.53 ( M )***

0.23 ( W )***

0.20 ( W )***

0.54 ( M )***

-0.07 ( N )

0.20 ( W )***

0.14 ( W )*

-0.11 ( W )

0.06 ( N )

0.43 ( M )***

-0.10 ( W )

0.39 ( W )***

0.16 ( W )*

-0.10 ( W )

0.10 ( N )

0.23 ( W )***

0.08 ( N )

0.49 ( M )***

0.24 ( W )***

0.06 ( N )

0.26 ( W )***

0.33 ( W )***

0.17 ( W )***

0.59 ( M )***

0.25 ( W )***

0.28 ( W )***

0.31 ( W )***

0.26 ( W )***

0.32 ( W )***

0.64 ( M )***

0.53 ( M )***

0.35 ( W )***

0.39 ( W )***

0.56 ( M )***

0.06 ( N )

0.61 ( M )***

0.29 ( W )***

0.16 ( W )*

0.12 ( W )

0.29 ( W )***

-0.07 ( N )

0.52 ( M )***

-0.04 ( N )

-0.01 ( N )

0.10 ( N )*

0.07 ( N )

0.03 ( N )

0.32 ( W )***

0.19 ( W )***

0.09 ( N )*

0.15 ( W )***

0.34 ( W )***

0.09 ( N )

0.32 ( W )***

0.41 ( M )***

0.07 ( N )

0.15 ( W )**

0.43 ( M )***

0.08 ( N )

0.50 ( M )***

0.38 ( W )***

0.07 ( N )

0.08 ( N )

0.38 ( W )***

-0.20 ( W )

0.24 ( W )*

-0.22 ( W )

0.01 ( N )

0.09 ( N )

-0.19 ( W )

0.65 ( M )***

0.76 ( S )***

0.62 ( M )***

0.63 ( M )***

0.68 ( M )***

0.66 ( M )***

0.48 ( M )***

0.79 ( S )***

0.68 ( M )***

0.42 ( M )***

0.39 ( W )***

0.66 ( M )***

0.11 ( W )

0.66 ( M )***

0.33 ( W )***

0.15 ( W )*

0.24 ( W )***

0.43 ( M )***

0.03 ( N )

0.64 ( M )***

0.10 ( W )*

0.12 ( W )**

0.13 ( W )**

0.10 ( W )*

0.32 ( W )***

0.65 ( M )***

0.52 ( M )***

0.40 ( M )***

0.42 ( M )***

0.51 ( M )***

0.11 ( W )*

0.67 ( M )***

0.16 ( W )***

0.14 ( W )**

0.17 ( W )***

0.25 ( W )***

0.35 ( W )***

0.79 ( S )***

0.63 ( M )***

0.34 ( W )***

0.34 ( W )***

0.58 ( M )***

0.07 ( N )

0.50 ( M )***

0.34 ( W )***

0.06 ( N )

0.09 ( N )

0.37 ( W )***

0.04 ( N )

0.43 ( M )***

0.26 ( W )***

0.11 ( W )**

0.12 ( W )**

0.31 ( W )***

0.27 ( W )***

0.54 ( M )***

0.45 ( M )***

0.14 ( W )*

0.16 ( W )*

0.37 ( W )***

0.02 ( N )

0.48 ( M )***

0.30 ( W )***

-0.03 ( N )

0.07 ( N )

0.33 ( W )***

0.22 ( W )***

0.25 ( W )***

0.36 ( W )***

0.27 ( W )***

0.33 ( W )***

0.50 ( M )***

0.16 ( W )***

0.41 ( M )***

0.23 ( W )***

0.25 ( W )***

0.24 ( W )***

0.24 ( W )***

-0.00 ( N )

0.56 ( M )***

0.43 ( M )***

-0.01 ( N )

0.10 ( N )*

0.38 ( W )***

-0.03 ( N )

0.44 ( M )***

0.32 ( W )***

0.03 ( N )

0.14 ( W )**

0.34 ( W )***

0.28 ( W )***

0.75 ( S )***

0.48 ( M )***

0.26 ( W )***

0.19 ( W )***

0.51 ( M )***

-0.06 ( N )

0.50 ( M )***

0.31 ( W )***

-0.10 ( N )*

0.01 ( N )

0.37 ( W )***

0.07 ( N )

0.37 ( W )***

0.15 ( W )***

0.12 ( W )**

0.17 ( W )***

0.29 ( W )***

0.01 ( N )

0.54 ( M )***

0.15 ( W )***

0.03 ( N )

0.21 ( W )***

0.22 ( W )***

Overall

0.21 ( W )***

0.68 ( M )***

0.37 ( W )***

0.22 ( W )***

0.27 ( W )***

0.40 ( M )***

***p <0.001, **p <0.01, *p <0.05

Combining the results in this study and the properties of the in-
dices as discussed in Sec. 4, we aim at showing that the proposed
indices are measuring diﬀerent aspects of community evolution.

The Spearman’s Correlation Coeﬃcients together with their sig-
niﬁcance levels for all the projects are listed in Table 4. We also
append the results of mixing all projects’ data in the last row of
the table. It can be observed that among the thirty two projects
involved in our study, there are four projects, i.e., project 4, 10, 13,
31, show a weak or no correlation between all pairs of the indices,
which cover both active and inactive projects (refer to Table 1). And
over half of the projects only show a moderate correlation between
a single pair of indices. As summarized in the last row of Table 4,
most of the pairs show a weak, but signiﬁcant correlation with 𝑟
values below 0.4. The merge and expand indices show a moderate
correlation with a 𝑟 value of 0.4, which is at the borderline between
a moderate and weak correlation.

An interesting discovery made from the results is that the split
and merge indices show a moderate correlation for most of projects,
and even a strong correlation for ﬁve projects. The overall correla-
tion coeﬃcient between split and merge is 0.68, suggesting a posi-
tive, moderate correlation which is statistically signiﬁcant. Recall

Coeﬀs (Errors)
2.9307 (0.2287)***
1.1428 (0.04734)***
0.2593 (0.07427)***
1.0495 (0.04620)***
-0.9238 (0.08525)***

(Intercept)
𝑙𝑜𝑔 (split+0.5)
𝑙𝑜𝑔 (shrink+0.5)
𝑙𝑜𝑔 (merge+0.5)
𝑙𝑜𝑔 (expand+0.5)
AIC=50005.521; BIC=50057.839; Accuracy=0.718;
𝑅2
𝑚=0.139; 𝑅2
*** 𝑝 < 0.001, ** 𝑝 < 0.01, * 𝑝 < 0.05.

Sum Sq.

1565.28***
32.75***
1386.35***
315.46***

𝑐 =0.455; Num. obs.=13018; Num. groups: project name=32

the way we calculate community split and merge, and the results of
concurrent validity presented above, it is clear that the two indices
are capable of measuring diﬀerent patterns of community evolu-
tion. The correlation between split and merge is a natural result
emerges from the issue and pull-request discussion activities of the
community members. A possible explanation to this positive corre-
lation is that real-world communities often regroup themselves in
OSS projects studied in this paper. It is our future work to inspect
more patterns of community evolution based on the proposed in-
dices.

5.4 Correlation with Team Productivity
The last experiment demonstrates the usefulness of the proposed
indices in predicting OSS project teams’ productivity. We opera-
tionalize OSS team productivity by the count of commits pushed
to the repository following existing work [11, 63]. We perform re-
gression analysis with the linear mixed-eﬀects models (LMMs) to
study the correlation between the indices and team productivity.
Compared to simple linear models, LMMs allow random eﬀects to
be included in the analysis. In this study, the random eﬀects are the
eﬀects caused by the diﬀerences of OSS projects. For each snap-
shot extracted following Sec. 3.1, we obtain a sample consists of
six variables as follows. First, the outcome variable is the count of
commits in a snapshot. Second, the aggregated indices for commu-
nity split, shrink, merge and expand are used as the independent
variables. Log transformation is performed to the above variables
to stabilize variance and reduce heteroscedasticity [1, 33]. Finally,
the project name is included in each sample as the indicator for
random eﬀects.

The results are shown in Table 5. The variance inﬂation fac-
tors (VIFs) for predictors including split, shrink, merge, and expand
are below 1.5, which are well below the suggested threshold of
5 in existing guidelines [14, 33], suggesting that there is no strong
collinearity among the predictors. The conditional R-squared 𝑅2
is greater than the marginal R-squared 𝑅2
the adoption of LMMs for regression analysis is suitable.

𝑚=0.139, suggesting that

𝑐 =0.455

The results suggest, after log transformation, all the indices show
a signiﬁcant correlation with team productivity. Three indices in-
cluding split, shrink, and merge are positively correlated with team
productivity. It is surprising to ﬁnd that expand shows a negative
eﬀect. By further observing the coeﬃcients and ‘Sum Sq.’, we can
ﬁnd that split and merge are more important predictors than split

Conference’17, July 2017, Washington, DC, USA

L. Wang, et al.

and expand. A possible explanation to the eﬀects of split and merge
is that members of communities with high degrees of split and
merge are actively regrouping themselves to join issue and pull-
request discussions which results in productive teams. And a po-
tential reason for the negative eﬀects of expand is that team perfor-
mance are known to be inﬂuenced by many factors beyond team
size, e.g., team diversity [51, 63], developer synchronization [69],
and etc. Growth in team size potentially increases the communica-
tion and coordination costs which reduce the working eﬃciency.
The above results, together with the results in Sec. 5.3, inspire us
to explore diﬀerent combinations of the indices as meaningful pat-
terns, and to conduct more studies to understand the eﬀects of com-
munity evolution in team productivity and performance in our fu-
ture work.

In summary, the regression model achieves an accuracy (i.e., the
correlation coeﬃcient between the actual and the predicted value
of the outcome [35]) of 0.718, suggesting that the aggregated in-
dices of community evolution are useful predictors of team pro-
ductivity. A potential threat to the robustness of the results is that
non-normality and heteroscedasticity of the residuals are detected.
We consult the literature [21, 32, 53], and conclude that the above
results are trustworthy after carefully inspecting the Q-Q diagram.

6 THREATS TO VALIDITY
We present a discussion the threats to validity as follows.

Internal Validity. We conduct a data-driven approach to re-
veal the correlation between community evolution and OSS devel-
opment such as team productivity. However, there are many other
factors that are known to aﬀect or characterize the operation of
OSS teams [11, 54]. As a result, the conclusions made in this paper
do not fully explain how OSS teams behave or imply a causal re-
lationship. Instead, the proposed indices should be used as useful
supplements to existing measures of DSN and community evolu-
tion.

External Validity. We select thirty-two projects that cover var-
ious topics and status in our study. However, the collection of projects
is small compared to the number of projects hosted on GitHub and
other platforms. The conclusions made in this paper may not gen-
eralize well to other projects. It is our future work to include more
projects in our studies.

Construct Validity. The indices are designed on top of the well-
established theory of information entropy to measure community
evolution with clear properties about how their values respond to
parameter changes. We evaluate the construct validity of the pro-
posed indices in terms of concurrent and discriminant validity. We
plan to seek more criteria to validate our approach in the future.

7 RELATED WORK
From a general perspective, this work belongs to the series of re-
search about the social aspects of OSS development started since
the beginning of the OSS movement [24, 37, 60]. In this section, we
introduce work closely related to this paper.

OSS projects are developed and maintained by the collaborative
eﬀorts of OSS contributors over channels such as mailing lists [7],
and on “social coding platforms” [17, 61, 67] such as GitHub and

GitLab. The interactions of OSS contributors naturally generate so-
cial networks around OSS projects, which is refer to as the devel-
oper social networks (DSNs) in existing literature [27]. Diﬀerent
types of DSNs–including communication [3, 5, 7, 16, 20, 25, 27,
44, 48, 66], collaboration [24, 30, 56, 57, 65], and hybrid [47, 59]
networks–have been extracted by mining developer mailing lists
and OSS repositories to study the properties and evolution of DSNs.
The extracted DSNs are often modeled as graphs [3, 27]. In this
work, weighted, undirected graphs are used to model DSNs that
reveal the communication structures of OSS contributors, based
on which a series of indices are proposed to quantify the evolution
of communities inside DSNs. It should be noted that the proposed
approach can also be applied to DSNs of other types.

Technologies for social network analysis (SNA) are applied to
DSNs to understand the properties, the structures, and the evolu-
tion of DSNs. Readers can refer to [12, 26, 54] for comprehensive
surveys for social network and community analysis in DSNs. Dif-
ferent from work that performs analysis to static DSNs [7, 16, 29,
59, 68], this work focuses on understanding the dynamic evolu-
tion of DSNs over time. Many studies about DSN evolution are
conducted by analyzing the changes and trend in series of DSN
snapshots take over time [3, 25, 27, 28, 30, 39, 44, 65]. Network
metrics, such as network diameter, shortest path between nodes,
node betweenness, modularity, hierarchy, centrality, clustering co-
eﬃcient, and etc, are adopted in existing work [3, 12, 25, 28, 30, 49]
to assess the properties of DSNs. There are also metrics developed
exclusively to measure software communities [65]. Based on these
metrics, statistical and data mining technologies are applied to un-
derstand the evolution of DSNs [28, 58]. This work is related to the
above work in that we propose indices to quantify the evolution
of DSN communities which can support further analysis includ-
ing but not limited to regression analysis, and pattern detection
as shown in our experiments. Diﬀerent from the above work that
takes the network perspective, this work takes the community per-
spective [3] and analyzes the evolutionary behaviors of communi-
ties in DSNs.

The patterns adopted in this paper that describe the evolution-
ary behaviors of DSN communities are originally proposed in [46],
which involve six patterns as introduced in the rest of the paper.
These patterns are shown to be promising in describing the evo-
lution of communities in various types of social networks such as
co-authorship, phone call, and blog networks [34, 46]. In [27], the
authors adopt these patterns to characterize community evolution
in OSS projects including Firefox, and Bugzilla. Similar patterns are
also adopted in [3] to describe the evolution of DSNs at the com-
munity level. This work is closely related to the above work in that
we also adopt the patterns as the basis to describe community evo-
lution. Diﬀerent from these approaches that assign a unique, nom-
inal pattern to a matched pair of communities in consecutive time
steps, we quantify the degree of diﬀerent patterns which can occur
simultaneously during the evolution of the communities. Other dif-
ferences of this work from the above work include: 1) community
emerge and extinct are deﬁned by combinations of the indices. As
a result, we only include indices for four patterns as introduced in
the paper; and 2) we do not require to match communities detected

Quantitative Analysis of Community Evolution in Developer Social Networks Around Open Source Software Projects

Conference’17, July 2017, Washington, DC, USA

in diﬀerent time steps to recognize them as a single evolving com-
munity, which is a challenging task [46] that can lead to biases if
not treated with caution.

Finally, we note that the community evolution patterns studied
in this work are about the patterns introduced above, which are
diﬀerent from the general patterns of OSS evolution in existing
work, which include studies that characterize the process of pref-
erential attachment in OSS developers when forming DSNs [66],
or the stages of OSS project evolution [40], and etc.

8 CONCLUSION
In this paper, we present four entropy-based indices to measure
the degree of community evolutionary behaviors with respect to
patterns including split, shrink, merge, and expand to understand
the evolution of DSNs around OSS projects. This work bridges the
gap between pattern-based approaches which can provide mean-
ingful insights about the evolution of DSNs from the community
perspective, and metric-based social network analysis which can
support comprehensive and quantitative analysis. The construct
validity of the proposed indices are evaluated on a real-world data
set about the issue and pull-request discussions in thirty-two OSS
projects. The results suggest the indices can accurately capture dif-
ferent patterns of community evolution by achieving a detection
accuracy of 94.1% compared to existing work [27], and show weak
and moderate correlations. The results also show that the indices
can accurately predict OSS team productivity after log transforma-
tion with linear mixed-eﬀects models.

The proposed indices can be used and extended in many ways
to support future studies. For example, we can use the indices to as-
sess and predict the behavior and status of OSS teams and projects,
e.g., to assess the health of OSS teams, and to predict OSS projects’
sustainability [50]. More patterns of community evolution can be
developed based on combinations of the indices, e.g., community
regroup as discussed in Sec. 5.3, following the way we deﬁne com-
munity emerge and extinct. We can also apply the proposed frame-
work to other types of DSNs, e.g., collaboration networks [30], to
understand their evolution.

REFERENCES
[1] Abdelmonem A Aﬁﬁ, Jenny B Kotlerman, Susan L Ettner, and Marie Cowan.
2007. Methods for improving regression analysis for skewed continuous or
counted responses. Annu. Rev. Public Health 28 (2007), 95–111.

[2] Haldun Akoglu. 2018. User’s guide to correlation coeﬃcients. Turkish journal of

emergency medicine 18, 3 (2018), 91–93.

[3] Mohamed Abdelrahman Aljemabi and Zhongjie Wang. 2018. Empirical study on
the evolution of developer social networks. IEEE Access 6 (2018), 51049–51060.
[4] Sitaram Asur, Srinivasan Parthasarathy, and Duygu Ucar. 2009. An event-based
framework for characterizing the evolutionary behavior of interaction graphs.
ACM Transactions on Knowledge Discovery from Data (TKDD) 3, 4 (2009), 1–36.
[5] Nicolas Bettenburg. 2011. Mining development repositories to study the impact
of collaboration on software systems. In Proceedings of the 19th ACM SIGSOFT
symposium and the 13th European conference on Foundations of software engineer-
ing. 376–379.

[6] Stefanie Betz, Samuel Fricker, Andrew Moss, Wasif Afzal, Mikael Svahnberg,
Claes Wohlin, Jürgen Börstler, Tony Gorschek, et al. 2013. An evolutionary per-
spective on socio-technical congruence: The rubber band eﬀect. In 2013 3rd In-
ternational Workshop on Replication in Empirical Software Engineering Research.
IEEE, 15–24.

[7] Christian Bird, Alex Gourley, Prem Devanbu, Michael Gertz, and Anand Swami-
nathan. 2006. Mining email social networks. In Proceedings of the 2006 interna-
tional workshop on Mining software repositories. 137–143.

[8] Christian Bird, David Pattison, Raissa D’Souza, Vladimir Filkov, and Premkumar
Devanbu. 2008. Latent social structure in open source projects. In Proceedings

of the 16th ACM SIGSOFT International Symposium on Foundations of software
engineering. 24–35.

[9] Thomas Bock, Angelika Schmid, and Sven Apel. 2021. Measuring and Modeling
Group Dynamics in Open-Source Software Development: A Tensor Decompo-
sition Approach. ACM Transactions on Software Engineering and Methodology
(TOSEM) 31, 2 (2021), 1–50.

[10] Piotr Bródka, Stanisław Saganowski, and Przemysław Kazienko. 2013. GED: the
method for group evolution discovery in social networks. Social Network Anal-
ysis and Mining 3, 1 (2013), 1–14.

[11] Gemma Catolino, Fabio Palomba, Damian A Tamburri, Alexander Serebrenik,
and Filomena Ferrucci. 2019. Gender diversity and women in software teams:
How do they aﬀect community smells?. In 2019 IEEE/ACM 41st International
Conference on Software Engineering: Software Engineering in Society (ICSE-SEIS).
IEEE, 11–20.

[12] Tanmoy Chakraborty, Ayushi Dalmia, Animesh Mukherjee, and Niloy Ganguly.
2017. Metrics for community analysis: A survey. ACM Computing Surveys
(CSUR) 50, 4 (2017), 1–37.

[13] Jailton Coelho and Marco Tulio Valente. 2017. Why modern open source projects
fail. In Proceedings of the 2017 11th Joint Meeting on Foundations of Software En-
gineering. 186–196.

[14] Patricia Cohen, Stephen G West, and Leona S Aiken. 2014. Applied multiple
regression/correlation analysis for the behavioral sciences. Psychology press.
[15] Melvin E Conway. 1968. How do committees invent. Datamation 14, 4 (1968),

28–31.

[16] Kevin Crowston and James Howison. 2005. The social structure of free and open

source software development. First Monday (2005).

[17] Laura Dabbish, Colleen Stuart, Jason Tsay, and Jim Herbsleb. 2012. Social coding
in GitHub: transparency and collaboration in an open software repository. In
Proceedings of the ACM 2012 conference on computer supported cooperative work.
1277–1286.

[18] Christine P Dancey and John Reidy. 2007. Statistics without maths for psychology.

Pearson education.

[19] Nicolas Ducheneaut. 2005. Socialization in an open source software community:
A socio-technical analysis. Computer Supported Cooperative Work (CSCW) 14, 4
(2005), 323–368.

[20] Kate Ehrlich and Marcelo Cataldo. 2012. All-for-one and one-for-all? A multi-
level analysis of communication patterns and individual performance in geo-
graphically distributed software development. In Proceedings of the ACM 2012
Conference on Computer Supported Cooperative Work. 945–954.

[21] Andrew Gelman and Jennifer Hill. 2006. Data analysis using regression and mul-

tilevel/hierarchical models. Cambridge university press.

[22] Georgios Gousios and Diomidis Spinellis. 2012. GHTorrent: GitHub’s data from
a ﬁrehose. In 2012 9th IEEE Working Conference on Mining Software Repositories
(MSR). IEEE, 12–21.

[23] Derek Greene, Donal Doyle, and Padraig Cunningham. 2010. Tracking the evolu-
tion of communities in dynamic social networks. In 2010 international conference
on advances in social networks analysis and mining. IEEE, 176–183.

[24] Jungpil Hahn, Jae Yun Moon, and Chen Zhang. 2008. Emergence of new project
teams from open source software developer networks: Impact of prior collabo-
ration ties. Information Systems Research 19, 3 (2008), 369–391.

[25] Anna Hannemann and Ralf Klamma. 2013. Community dynamics in open source
software projects: Aging and social reshaping. In IFIP International Conference
on Open Source Systems. Springer, 80–96.

[26] Steﬀen Herbold, Aynur Amirfallah, Fabian Trautsch, and Jens Grabowski. 2021.
A systematic mapping study of developer social network research. Journal of
Systems and Software 171 (2021), 110802.

[27] Qiaona Hong, Sunghun Kim, Shing Chi Cheung, and Christian Bird. 2011. Un-
derstanding a developer social network and its evolution. In 2011 27th IEEE in-
ternational conference on software maintenance (ICSM). IEEE, 323–332.

[28] Hao-Yun Huang, Qize Le, and Jitesh H Panchal. 2011. Analysis of the structure
and evolution of an open-source community. Journal of Computing and Infor-
mation Science in Engineering 11, 3 (2011).

[29] Carlos Jensen, Scott King, and Victor Kuechler. 2011. Joining free/open source
software communities: An analysis of newbies’ ﬁrst interactions on project mail-
ing lists. In 2011 44th Hawaii international conference on system sciences. IEEE,
1–10.

[30] Mitchell Joblin. 2017. Structural and Evolutionary Analysis of Developer Networks.

Ph. D. Dissertation. Universität Passau.

[31] Arora Kanika et al. 2015. Research methods: The essential knowledge base. Cen-

gage learning.

[32] Ulrich Knief and Wolfgang Forstmeier. 2021. Violating the normality assumption
may be the lesser of two evils. Behavior Research Methods 53, 6 (2021), 2576–
2590.

[33] Zhixing Li, Yue Yu, Minghui Zhou, Tao Wang, Gang Yin, Long Lan, and Huaimin
Wang. 2020. Redundancy, context, and preference: An empirical study of dupli-
cate pull requests in OSS projects.
IEEE Transactions on Software Engineering
(2020).

Conference’17, July 2017, Washington, DC, USA

L. Wang, et al.

[59] Damian Andrew Andrew Tamburri, Fabio Palomba, and Rick Kazman. 2019. Ex-
ploring community smells in open-source: An automated approach. IEEE Trans-
actions on software Engineering (2019).

[60] Jason Tsay, Laura Dabbish, and James Herbsleb. 2014.

Inﬂuence of social and
technical factors for evaluating contribution in GitHub. In Proceedings of the
36th international conference on Software engineering. 356–366.

[61] Jason Tsay, Laura Dabbish, and James Herbsleb. 2014. Let’s talk about it: eval-
uating contributions through discussion in GitHub. In Proceedings of the 22nd
ACM SIGSOFT international symposium on foundations of software engineering.
144–154.

[62] Matthew Van Antwerp and Greg Madey. 2010. The importance of social network
structure in the open source software developer community. In 2010 43rd Hawaii
International Conference on System Sciences. IEEE, 1–10.

[63] Bogdan Vasilescu, Daryl Posnett, Baishakhi Ray, Mark G.J. van den Brand,
Alexander Serebrenik, Premkumar Devanbu, and Vladimir Filkov. 2015. Gen-
der and Tenure Diversity in GitHub Teams. In Proceedings of the 33rd Annual
ACM Conference on Human Factors in Computing Systems (Seoul, Republic of
Korea) (CHI ’15). Association for Computing Machinery, New York, NY, USA,
3789–3798. https://doi.org/10.1145/2702123.2702549

[64] Jing Wang. 2012. Survival factors for Free Open Source Software projects: A

multi-stage perspective. European Management Journal 30, 4 (2012), 352–371.

[65] Yi Wang, Defeng Guo, and Huihui Shi. 2007. Measuring the evolution of open
source software systems with their communities. ACM SIGSOFT Software Engi-
neering Notes 32, 6 (2007), 7–es.

[66] Michael Weiss, Gabriella Moroiu, and Ping Zhao. 2006. Evolution of open source
communities. In IFIP International Conference on Open Source Systems. Springer,
21–32.

[67] Mairieli Wessel, Bruno Mendes De Souza, Igor Steinmacher, Igor S Wiese, Ivanil-
ton Polato, Ana Paula Chaves, and Marco A Gerosa. 2018. The power of bots:
Characterizing and understanding bots in oss projects. Proceedings of the ACM
on Human-Computer Interaction 2, CSCW (2018), 1–19.

[68] Jin Xu, Yongqin Gao, Scott Christley, and Gregory Madey. 2005. A topological
analysis of the open souce software development community. In Proceedings of
the 38th Annual Hawaii International Conference on System Sciences. IEEE, 198a–
198a.

[69] Qi Xuan and Vladimir Filkov. 2014. Building it together: Synchronous devel-
opment in OSS. In Proceedings of the 36th International Conference on Software
Engineering. 222–233.

[34] Yu-Ru Lin, Hari Sundaram, Yun Chi, Junichi Tatemura, and Belle L Tseng. 2007.
Blog community discovery and evolution based on mutual awareness expansion.
In IEEE/WIC/ACM International Conference on Web Intelligence (WI’07). IEEE, 48–
56.

[35] Daniel Lüdecke. 2021.

Assessment of Regression Models Performance.

https://cran.r-project.org/web/packages/performance/performance.pdf.
[36] Mircea Lungu, Michele Lanza, Tudor Gîrba, and Romain Robbes. 2010. The small
project observatory: Visualizing software ecosystems. Science of Computer Pro-
gramming 75, 4 (2010), 264–275.

[37] Gregory Madey, Vincent Freeh, and Renee Tynan. 2002. The open source soft-
ware development phenomenon: An analysis based on social network theory. In
Americas Conference on Information Systems (AMCIS2002). 1806–1813.

[38] Andrew Meneely, Ben Smith, and Laurie Williams. 2013. Validating software
metrics: A spectrum of philosophies. ACM Transactions on Software Engineering
and Methodology (TOSEM) 21, 4 (2013), 1–28.

[39] Tom Mens and Mathieu Goeminne. 2011. Analysing the evolution of social as-
pects of open source software ecosystems. In Proceedings of the Workshop on
Software Ecosystems. Citeseer, 1–14.

[40] Kumiyo Nakakoji, Yasuhiro Yamamoto, Yoshiyuki Nishinaka, Kouichi Kishida,
and Yunwen Ye. 2002. Evolution patterns of open-source software systems and
communities. In Proceedings of the international workshop on Principles of soft-
ware evolution. 76–85.

[41] Mark EJ Newman. 2003. Mixing patterns in networks. Physical review E 67, 2

(2003), 026126.

[42] Mark EJ Newman. 2004. Analysis of weighted networks. Physical review E 70, 5

(2004), 056131.

[43] Mark EJ Newman and Michelle Girvan. 2004. Finding and evaluating community

structure in networks. Physical review E 69, 2 (2004), 026113.

[44] Kawin Ngamkajornwiwat, Dongsong Zhang, A Gunes Koru, Lina Zhou, and
Robert Nolker. 2008. An exploratory study on the evolution of OSS developer
communities. In Proceedings of the 41st Annual Hawaii International Conference
on System Sciences (HICSS 2008). IEEE, 305–305.

[45] Tim O’Reilly. 1999. Lessons from open-source software development. Commun.

ACM 42, 4 (1999), 32–37.

[46] Gergely Palla, Albert-László Barabási, and Tamás Vicsek. 2007. Quantifying so-

cial group evolution. Nature 446, 7136 (2007), 664–667.

[47] Sebastiano Panichella, Gabriele Bavota, Massimiliano Di Penta, Gerardo Can-
fora, and Giuliano Antoniol. 2014. How developers’ collaborations identiﬁed
from diﬀerent sources tell us about code changes. In 2014 IEEE International Con-
ference on Software Maintenance and Evolution. IEEE, 251–260.

[48] Sebastiano Panichella, Gerardo Canfora, Massimiliano Di Penta, and Rocco
Oliveto. 2014. How the evolution of emerging collaborations relates to code
changes: an empirical study. In Proceedings of the 22nd International Conference
on Program Comprehension. 177–188.

[49] Martin Pinzger, Nachiappan Nagappan, and Brendan Murphy. 2008. Can
developer-module networks predict failures?. In Proceedings of the 16th ACM
SIGSOFT International Symposium on Foundations of software engineering. 2–12.
[50] Uzma Raja and Marietta J Tretter. 2012. Deﬁning and evaluating a measure of
open source project survivability. IEEE Transactions on Software Engineering 38,
1 (2012), 163–174.

[51] Lionel Robert and Daniel M Romero. 2015. Crowd size, diversity and perfor-
mance. In Proceedings of the 33rd Annual ACM Conference on Human Factors in
Computing Systems. 1379–1382.

[52] Giulio Rossetti and Rémy Cazabet. 2018. Community discovery in dynamic net-

works: a survey. ACM Computing Surveys (CSUR) 51, 2 (2018), 1–37.

[53] Holger Schielzeth, Niels J Dingemanse, Shinichi Nakagawa, David F Westneat,
Hassen Allegue, Céline Teplitsky, Denis Réale, Ned A Dochtermann, László Zsolt
Garamszegi, and Yimen G Araya-Ajoy. 2020. Robustness of linear mixed-eﬀects
models to violations of distributional assumptions. Methods in Ecology and Evo-
lution 11, 9 (2020), 1141–1152.

[54] Roland Robert Schreiber and Matthäus Paul Zylka. 2020. Social Network Analy-
sis in Software Development Projects: A Systematic Literature Review. Interna-
tional Journal of Software Engineering and Knowledge Engineering 30, 03 (2020),
321–362.

[55] Claude Elwood Shannon. 1948. A mathematical theory of communication. The

Bell system technical journal 27, 3 (1948), 379–423.

[56] Param Vir Singh. 2010. The small-world eﬀect: The inﬂuence of macro-level
properties of developer collaboration networks on open-source project suc-
cess. ACM Transactions on Software Engineering and Methodology (TOSEM) 20,
2 (2010), 1–27.

[57] Didi Surian, David Lo, and Ee-Peng Lim. 2010. Mining collaboration patterns
from a large developer network. In 2010 17th Working Conference on Reverse En-
gineering. IEEE, 269–273.

[58] MM Mahbubul Syeed, Imed Hammouda, and Tarja Systä. 2013. Evolution of
open source software projects: A systematic literature review. Journal of Soft-
ware 8, 11 (2013), 2815–2829.

