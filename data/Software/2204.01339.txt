2
2
0
2

r
p
A
4

]

A
N
.
h
t
a
m

[

1
v
9
3
3
1
0
.
4
0
2
2
:
v
i
X
r
a

mVEM: A MATLAB Software Package for the Virtual

Element Methods

Yue Yu∗

School of Mathematical Sciences, Institute of Natural Sciences, MOE-LSC, Shanghai Jiao

Tong University, Shanghai, 200240, P. R. China.

Abstract

This paper summarizes the development of mVEM, a MATLAB software package containing

eﬃcient and easy-following codes for various virtual element methods (VEMs) published in the

literature. We explain in detail the numerical implementation of the mixed VEMs for the

Darcy problem and the three-dimensional linear VEMs for the Poisson equation. For other

model problems, we present the construction of the discrete methods and only provide the

implementation of the elliptic projection matrices. Some mesh related functions are also given

in the package, including the mesh generation and reﬁnement in two or three dimensions. mVEM

is free and open source software.

Keywords. Virtual element method, Polygonal meshes, Three dimensions, MATLAB

1 Introduction

Developing the mimetic ﬁnite diﬀerence methods, Beir˜ao and Brezzi et al. proposed the virtual

element method (VEM) in 2013, and established an abstract framework for error analysis [7]. This

method was further studied in [2] for an extension to reaction-diﬀusion problems, where a crucial
enhancement technique is introduced to construct a computable L2 projection. The computer

implementation has been further studied in [11]. The proposed ﬁnite dimensional space in [7] has

become the standard space for constructing conforming virtual element methods for second-order

elliptic problems on polygonal meshes. The word virtual comes from the fact that no explicit

knowledge of the basis functions is necessary since the shape functions are piecewise continuous

polynomials on the boundary of the element and are extended to the interior by assuming basis

functions as solutions of local Laplace equations. The construction of the VEMs for elliptic problems

is very natural and standard, which can be derived based on an integration by parts formula for

the underlying diﬀerential operator. As a matter of fact, this idea is used to devise conforming and

nonconforming VEMs for arbitrary order elliptic problems though the resulting formulation and

theoretical analysis are rather involved [27, 39].

∗terenceyuyue@sjtu.edu.cn

1

 
 
 
 
 
 
VEMs have some advantages over standard ﬁnite element methods. For example, they are

more convenient to handle partial diﬀerential equations on complex geometric domains or the

ones associated with high-regularity admissible spaces. Until now, they have been successfully

applied to solve various mathematical physical problems, such as the conforming and nonconforming

VEMs for second-order elliptic equations [2,6,7,25] and fourth-order elliptic equations [3,23,30,56],

the time-dependent problems [1, 36, 43, 46, 47], the mixed formulation of the Darcy and Stokes

problems [17, 22, 57] and the variational inequalities and hemivariational inequalities associated

with the frictional contact problems [48–51].

For second-order problems with variable coeﬃcients and convection terms, direct use of the

elliptic projection approximation of the gradient operator does not ensure the optimal convergence,

so the external projection approximation has been introduced in the literature, see [13, 14] for

example. This approximation technique is also commonly used for the construction of virtual

element methods for complex problems such as elastic or inelastic mechanics [4, 5, 10]. Since the

virtual element space contains at least k-th order polynomials, the number of the degrees of freedom

(d.o.f.s) in the virtual element space is generally higher than that in the classical ﬁnite element

space when the polygonal element is degenerated into a triangle. These extra d.o.f.s are usually

caused by internal moments and can be further reduced by exploiting the idea of building an

incomplete ﬁnite element or the serendipity ﬁnite element [21]. In fact, Beir˜ao et al. has proposed

the serendipity nodal VEM spaces in [12].

In this paper, we are intended to develop a MATLAB software package for the VEMs in two

or three dimensions, containing eﬃcient and easy-following codes for various VEMs published in

the literature. In particular, [11] provided a detailed explanation of the formulation of the terms

in the matrix equations for the high order virtual element method applied to such a problem in

two dimensions, and [44] presented a transparent MATLAB implementation of the conforming

linear virtual element method for the Poisson equation in two dimensions. The construction of the

VEMs for three-dimensional problems has been accomplished in many papers [9,15,16,28,31,34,35].

However, to the best of knowledge, no related implementation is publicly available in the literature.

As an extension of [44] to three spatial dimensions, we have provided a clear and useable MATLAB

implementation of the method for three-dimensional linear VEMs for the Poisson equation on

general polyhedral meshes in the package with the detailed implementation given in Section 10.

Although the current procedure is only for ﬁrst-order virtual element spaces, the design idea can

be directly generalized to higher-order cases.

The paper is organized as follows. In Section 2, we provide the complete and detailed imple-

mentation of the mixed VEMs for the Darcy problem as an example, which includes almost all of

the programming techniques in mVEM, such as the construction of the data structure for polygonal
meshes, the computation of elliptic and L2 projection matrices, the treatment of boundary condi-

tions, and examples that demonstrate the usage of running the codes, showing the solutions and

meshes, computing the discrete errors and displaying the convergence rates. Section 3 summarizes

the mesh related built-in functions, including the modiﬁed version of PolyMesher introduced in [45]

and generation of some special meshes for VEM tests. We also provide the generation of polygonal

2

meshes by establishing the dual mesh of a Delaunay triangulation and some basic functions to show

the polygonal meshes as well as a boundary setting function to identify the Neumann and Dirichlet

boundaries. Sections 4-9 discuss the construction of virtual element methods for various model

problems and the computation of the corresponding elliptical projections, including the conforming

and nonconforming VEMs for the Poisson equation or reaction-diﬀusion problems, the (locking-

free) VEMs for the linear elasticity problems in the displacement/tensor type, three VEMs for the

fourth-order plate bending problems, the divergence-free mixed VEMs for the Stokes problems, the

adaptive VEMs for the Poisson equation and the variational inequalities for the simpliﬁed friction

problem. The paper ends with some concluding remarks in Section 11.

2 Mixed VEMs for the Darcy problem

Considering that the implementation of conforming or nonconforming VEMs has been publicly

available in the literature [42,44], we in this paper present the detailed implementation of the mixed

VEMs for the Darcy problem to ﬁll the gap in this regard. The mixed VEM is ﬁrst proposed in [22]

for the classical model problem of Darcy ﬂow in a porous medium. Let’s brieﬂy review the method

in this section.

2.1 Construction of the mixed VEMs

2.1.1 The model problem

Given the (polygonal) computational domain Ω ⊂ R2, let f ∈ L2(Ω) and g ∈ H 1/2(∂Ω). The

Darcy problem is to ﬁnd p ∈ H 1(Ω) such that




−div(K∇p) = f

in Ω,



(K∇p) · n = g

on ∂Ω,

(1)

where K is a symmetric and positive deﬁnite tensor of size 2 × 2. For simplicity, we assume that K

is constant. The given data f and g satisfy the compatibility condition

(cid:90)

Ω

f dx =

(cid:90)

∂Ω

gds.

To remove an additive constant, we additionally require that

Introducing the velocity variable u = K∇p, the above problem can be rewritten in the mixed

(cid:90)

Ω

pdx = 0.

(2)

form

Deﬁne





u = K∇p

in Ω,

divu = −f

in Ω,

u · n = g

on ∂Ω.

Vg = {u ∈ H(div; Ω) : u · n = g on ∂Ω},

Q = L2

0(Ω),

V = V0.

3

The corresponding mixed variational problem is: Find (u, p) ∈ Vg × Q such that




a(u, v) + b(v, p) = 0,

v ∈ V,



b(u, q)

= −(f, q),

q ∈ Q,

(3)

where

a(u, v) = (K−1u, v),

b(v, q) = (divv, q).

Note that the boundary condition is now related to the variable u.

2.1.2 The virtual element space and the elliptic projection

The local virtual element space of V is

Vk(K) = {v ∈ H(div; K) ∩ H(rot; K) : v · n|e ∈ Pk(e),

divv|K ∈ Pk−1(K),

rotv|K ∈ Pk−1(K)},

(4)

where

divv = ∂1v1 + ∂2v2,

rotv = ∂1v2 − ∂2v1,

v = (v1, v2)T .

To present the degrees of freedom (d.o.f.s), we introduce a scaled monomial Mr(D) on a d-

dimensional domain D

Mr(D) :=

(cid:110)(cid:16) x − xD

(cid:17)s

,

|s| ≤ r

(cid:111)
,

hD
where hD is the diameter of D, xD the centroid of D, and r a non-negative integer. For the
multi-index s ∈ Nd, we follow the usual notation

xs = xs1

1 · · · xsd
d ,

|s| = s1 + · · · + sd.

Conventionally, Mr(D) = {0} for r ≤ −1.

The d.o.f.s can be given by

(cid:90)

e
(cid:90)

v · nqds,

q ∈ Mk(e), e ⊂ ∂K,

v · ∇qdx,

q ∈ Mk−1(K)\{1},

K

(cid:90)

K

rotvqdx,

q ∈ Mk−1(K).

(5)

(6)

(7)

We remark that the moments on edges or elements are not divided by |e| or |K| since aK(·, ·) is
associated with the L2 norm rather than the H 1 semi-norm for the case of Poisson equation.

For the Poisson equation, the elliptic projection maps from the virtual element space Vk(K)
into the polynomial space Pk(K) [2, 7, 11]. For convenience, the image space is referred to as the
elliptic projection space. For the Darcy problem, however, the elliptic projection space is now

replaced by

(cid:98)Vk(K) = {(cid:98)v ∈ Vk(K) : (cid:98)v = K∇(cid:98)qk+1 for some (cid:98)qk+1 ∈ Pk+1(K)}.

The elliptic projector (cid:98)ΠK : Vk(K) → (cid:98)Vk(K), v (cid:55)→ (cid:98)ΠKv is then deﬁned by

aK((cid:98)ΠKv, (cid:98)w) = aK(v, (cid:98)w),

(cid:98)w ∈ (cid:98)Vk(K).

(8)

4

We now consider the computability of the elliptic projection. In view of the symmetry of K,

the integration by parts gives
(cid:90)

aK(v, (cid:98)w) =

K−1v · (cid:98)wdx =

(cid:90)

v · (K−1

(cid:98)w)dx

K
(cid:90)

K

(cid:90)

K

=

v · ∇(cid:98)qk+1dx = −

(cid:98)qk+1divvdx +

(cid:90)

∂K

(cid:98)qk+1v · nds.

(9)

K

• For the second term, since v · n|e ∈ Pk(e) we expand it in the scaled monomials on e as

v · n|e(s) = c1me

1(s) + · · · + cnme

n(s).

Clearly, the coeﬃcients are uniquely determined by the d.o.f.s in (5).

• For the ﬁrst term, noting that divv|K ∈ Pk−1(K), we have

divv|K(x) = c1mK

1 (x) + · · · + cnmK

n (x).

Let q = mK

i (x) and take inner product on both sides with respect to q. We obtain
(cid:90)

(cid:90)

(cid:90)

divvqdx = −

v · ∇qdx +

v · nqds,

K

K

∂K

q = mK

i (x) ∈ Pk−1(K).

Hence the coeﬃcients are determined by the d.o.f.s in (5) and (6).

In this paper, we only consider the implementation of the lowest order case k = 1. At this

time, only the d.o.f.s of the ﬁrst and third types exist. The local d.o.f.s will be arranged as

χi(v) =

(cid:90)

ei

χNv+i(v) =

(v · n)ds,

i = 1, · · · , Nv,

(cid:90)

(v · n)

s − sei
hei

ds,

i = 1, · · · , Nv,

χ2Nv+1(v) =

rotvdx,

ei
(cid:90)

K

(10)

(11)

(12)

where Nv is the number of the vertices of K, he is the length of e, and s is the natural parameter
of e with se being the midpoint in the parametrization.

2.1.3 The discrete problem

In what follows, we denote the global virtual element space by Vh associated with Vk(K), and

Qh by the discretization of Q, given as

Qh := {q ∈ Q : q|K ∈ Pk−1(K), K ∈ Th.}

In particular, Qh is piecewise constant for k = 1.
The VEM approximation of aK(u, v) is

h (u, v) = aK((cid:98)ΠKu, (cid:98)ΠKv) + (cid:107)K−1(cid:107)SK(u − (cid:98)ΠKu, v − (cid:98)ΠKv),
aK

where (cid:107) · (cid:107) is the Frobenius norm and the stabilization term is

SK(v, w) =

χi(v)χi(w).

2Nv+1
(cid:88)

i=1

5

The discrete mixed variational problem is: Find (uh, ph) ∈ V g

h × Qh such that




ah(uh, vh) + b(vh, ph) = 0,

vh ∈ Vh,



b(uh, qh)

= −(f, qh),

qh ∈ Qh.

(13)

The constraint (2) is not naturally imposed in the above system. To this end, we introduce a
Lagrange multiplier and consider the augmented variational formulation: Find ((uh, ph), λ) ∈ V g
h ×
Qh × R such that






ah(uh, vh) + b(vh, ph) = 0,
(cid:90)

vh ∈ Vh,

b(uh, qh) + λ

qhdx = −(f, qh),

Ω

(cid:90)

µ

Ω

phdx

= 0, µ ∈ R.

qh ∈ Qh,

(14)

It should be pointed out that the virtual element space Vh cannot be understood as a vector
or tensor-product space, which is diﬀerent from the conforming or nonconforming VEMs for the

linear elasticity problem. In the computation, uh should be viewed as a scalar at this time. Let
ϕi, i = 1, · · · , N be the nodal basis functions of Vh, where N is the dimension of Vh. We can write

u =

N
(cid:88)

i=1

χi(u)ϕi =: ϕT χ(u).

The basis functions of Qh are denoted by ψl, l = 1, · · · , M :

ph =

M
(cid:88)

l=1

plψl.

Plug above equations in (13), and take vh = ϕj and qh = ψl. We have

N
(cid:80)
i=1
N
(cid:88)






ah(ϕi, ϕj)χi +

b(ϕi, ψl)χi + λ

i=1
M
(cid:88)

(cid:90)

l=1

Ω

ψldxpl

M
(cid:80)
l=1
(cid:90)

Ω

b(ϕj, ψl)pl = 0,

j = 1, · · · , N,

ψldx

= −(f, ψl),

l = 1, · · · , M,

= 0.

Let

dl =

(cid:90)

Ω

ψldx, d = [d1, · · · , dM ]T .

The linear system can be written in matrix form as







A B 0
BT O d
0T dT

0







χ

=













p

λ







,



0





f

0

(15)

(16)

where

A = (ah(ϕj, ϕi))N ×N , B = (b(ϕj, ψl))N ×M ,

f = (−(f, ψl))M ×1.

For the global d.o.f.s in the unknown vector χ in (16), we shall arrange the ﬁrst type in (10),

followed by the second and the third ones in (11) and (12).

6

2.2

Implementation

2.2.1 Overview of the code

We ﬁrst provide an overview of the test script.

1 % % Parameters

2 nameV = [32 , 64 , 128 , 256 , 512];

3 maxIt = length ( nameV ) ;

4 h = zeros ( maxIt ,1) ;

N = zeros ( maxIt ,1) ;

5 ErruL2 = zeros ( maxIt ,1) ;

6 ErrpL2 = zeros ( maxIt ,1) ;

7 ErrI = zeros ( maxIt ,1) ;

8

9 % % PDE data

10 pde = Darcydata ;

11

12 % % Virtual element method

13 for k = 1: maxIt

% load mesh
fprintf ( ' Mesh % d : \ n ' , k ) ;
load ( [ ' meshdata ' , num2str ( nameV ( k ) ) , '. mat '] ) ;
% get boundary information

bdStruct = setboundary ( node , elem ) ;

% solve the problem

[ uh , ph , info ] = Darcy_mixedVEM ( node , elem , pde , bdStruct ) ;

% record and plot

N ( k ) = length ( uh ) ;

h ( k ) = 1/ sqrt ( size ( elem ,1) ) ;

[ uhI , phI , nodeI , elemI ] = Projec ti onDar cy ( node , elem , uh , ph , info , pde ) ;

figure (1) ;

showresult ( nodeI , elemI , pde . uexact , uhI ) ;

% showresult ( nodeI , elemI , pde . pexact , phI ) ;

drawnow ; % pause (0.1) ;

% compute errors in discrete L2 norm

[ ErruL2 ( k ) , ErrpL2 ( k ) ] = getL2e rro r _Da r cy ( node , elem , uh , ph , info , pde ) ;

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30 end

31

32 % % Plot convergence rates and display error table

33 figure ,
34 showrateh (h , ErruL2 , 'r -* ' , ' || u - u_h || ' ,

ErrpL2 , 'b - s ' , ' || p - p_h || ')

35
36 fprintf ( '\ n ') ;
37 disp ( ' Table : Error ')
38 colname = { '# Dof ' , 'h ' , ' || u - u_h || ' , ' || p - p_h || ' };
39 disptable ( colname ,N ,[] , h , ' %0.3 e ' , ErruL2 , ' %0.5 e ' , ErrpL2 , ' %0.5 e ') ;

In the for loop, we ﬁrst load or generate the mesh data, which immediately returns the

matrix node and the cell array elem deﬁned later to the MATLAB workspace. Then we set up

the boundary conditions to get the structural information of the boundary edges. The subroutine

Darcy mixedVEM.m is the function ﬁle containing all source code to implement the VEM. When
obtaining the numerical solutions, we can visualize the piecewise elliptic projection (cid:98)ΠKuh by using
the subroutines ProjectionDarcy.m and showresult.m. We then calculate the discrete L2 error

deﬁned as

ErrL2 =



1/2

(cid:107)u − (cid:98)ΠKuh(cid:107)2

0,E



,





(cid:88)

K∈Th

7

(17)

through the subroutine getL2error Darcy.m. The procedure is completed by verifying the rate

of convergence through showrateh.m.

The overall structure of a virtual element method implementation will be much the same as

for a standard ﬁnite element method, as outlined in Algorithm 1.

Algorithm 1 An overall structure of the implementation of a virtual element method
Input: Mesh data and PDE data

1. Get auxiliary data of the mesh, including some data structures and geometric quantities;

2. Derive elliptic projections;

3. Compute and assemble the linear system by looping over the elements;

4. Apply the boundary conditions;

5. Set solver and store information for computing errors.

Output: The numerical DoFs

2.2.2 Data structure

We ﬁrst discuss the data structure to represent polygonal meshes so as to facilitate the imple-

mentation. There are two basic data structures node and elem, where node is a matrix with the

ﬁrst and second columns contain x- and y-coordinates of the nodes in the mesh, and elem is a cell

array recording the vertex indices of each element in a counterclockwise order as shown in Fig. 1.

The mesh can be displayed by using showmesh.m.

(a) mesh

(b) node

(c) elem

Fig. 1. Example of a polygonal mesh

Using the basic data structures, we can extract the topological or combinatorial structure of a

polygonal mesh. These data are referred to as the auxiliary data structures as given in Tab. 1. The

combinatorial structure will beneﬁt the implementation of virtual element methods. The idea stems

8

0.20.40.60.810.10.20.30.40.50.60.70.80.91 1 2 3 4 5 6 7 8 9101112from the treatment of triangulation in iFEM for ﬁnite element methods [26], which is generalized

to polygonal meshes with certain modiﬁcations.

Tab. 1. Auxiliary data structures

edge

elem2edge

bdEdge

edge2elem

neighbor

node2elem

Fig. 2. Illustration of the auxiliary data

structures.

edge. The d.o.f.s in (10) and (11) are edge-oriented. In the matrix edge(1:NE,1:2), the ﬁrst

and second rows contain indices of the starting and ending points. The column is sorted in the way

that for the k-th edge, edge(k,1)<edge(k,2). The indices of these edges are are marked with

purple boxes as shown in Fig. 2.

Following [26], we shall use the name convention a2b to represent the link form a to b. This

link is usually the map from the local index set to the global index set. Throughout this paper, we

use the symbols N, NT, and NE to represent the number of nodes, elements, and edges.

elem2edge. The cell array elem2edge establishes the map of local index of edges in each

polygon to its global index in matrix edge. For instance, elem2edge{1} = [13,7,6,3,5] for the

mesh in Fig. 2.

bdEdge. This matrix exacts the boundary edges from edge.

edge2elem. The matrix edge(1:NE,1:2) records the neighboring polygons for each edge. In

Fig. 2, edge(3,1:2)= [1,2]. For a boundary edge, the outside is speciﬁed to the element sharing

it as an edge.

neighbor. We use the cell array neighbor to record the neighboring polygons for each

element. For example, neighbor{4} = [5,1,2,3], where the i-th entry corresponds to the i-th

edge of the current element. Note that for a boundary edge, the neighboring polygon is speciﬁed

to the current element, for instance, neighbor{1} = [5,1,1,2,4].

node2elem. This cell array ﬁnds the elements sharing a common nodes. For example,

node2elem{2} = [1,2,4].

In addition, we provide a subroutine auxgeometry.m to compute some useful geometric quan-

tities, such as the barycenter centroid, the diameter diameter and the area area of each element.

9

0.20.40.60.810.10.20.30.40.50.60.70.80.91 1 2 3 4 5 6 7 8 910111212345 1 2 3 4 5 6 7 8 9101112131415162.2.3 Computation of the elliptic projection

Transition matrix

The shape functions of Vk(K) are written in the following compact notation

φT = (φ1, φ2, · · · , φNk

),

where Nk = 2Nv + 1 is the cardinality of the local basis set. The basis of (cid:98)Vk(K) is given by

(cid:99)mT = ((cid:99)m1, (cid:99)m2, · · · , (cid:99)m

).

(cid:98)Np

Noting that (cid:98)Vk(K) ⊂ Vk(K), we set (cid:99)mT = φT D, where D is referred to as the transition matrix
from the elliptic projection space (cid:98)Vk(K) to the virtual element space Vk(K). By the deﬁnition of
the d.o.f.s,

(cid:99)mα =

Nk(cid:88)

i=1

φiDiα, Diα = χi((cid:99)mα).

For every v ∈ (cid:98)Vk(K), by deﬁnition, v ∈ K∇Pk+1(K). For k = 1, the scaled monomials of

Pk+1(K) = P2(K) are

mT = (m1, m2, · · · , mNm), Nm = 6,

with

m1(x, y) = 1, m2(x, y) =

x − xK
hK

, m3(x, y) =

y − yK
hK

,

m4(x, y) =

(x − xK)2
h2
K

, m5(x, y) =

(x − xK)(y − yK)
h2
K

, m6(x, y) =

(y − yK)2
h2
K

,

where (xK, yK) and hK are the barycenter and diameter of K, respectively. We then choose

(cid:99)mα = K∇(hKmα+1), α = 1, · · · , (cid:98)Nm = Nm − 1 = 5,

(18)

with the explicit expressions given by

(cid:99)m1 = K

(cid:34)

(cid:35)

1

0

, (cid:99)m2 = K

(cid:34)

(cid:35)
0

1

, (cid:99)m3 = K

(cid:35)

(cid:34)

2m2
0

, (cid:99)m4 = K

(cid:35)

(cid:34)

m3
m2

, (cid:99)m5 = K

(cid:35)

.

(cid:34)

0

2m3

We now compute the transition matrix. For χi with i = 1, · · · , Nv in (10), noting that

v · n|e ∈ P1(e), the trapezoidal rule gives
1
2

(v · n)ds =

χi(v) =

(cid:90)

ei

(v(zi) + v(zi+1)) · (heinei),

v = (cid:99)mα.

(19)

For χNv+i with i = 1, · · · , Nv in (11), using the Simpson formula yields

χNv+i(v) =

=

=

=

=

ei
hei
6
(cid:16)
1
6
1
6
1
12

(cid:16)

(cid:90)

(v · n)

s − sei
hei

ds =

hei
6

(f (zi) + 4f (sei) + f (zi+1))

(f (zi) + f (zi+1)),

f = (v · n)

s − sei
hei

v(zi) · nei(si − sei) + v(zi+1) · nei(si+1 − sei)

(cid:17)

−1
2

v(zi) · nei
(cid:16)

hei + v(zi+1) · nei

v(zi+1) − v(zi)

· (neihei),

(cid:17)

hei

1
2
v = (cid:99)mα.

(cid:17)

10

(20)

For χ2Nv+1 in (12), the integration by parts gives
(cid:90)

(cid:90)

χ2Nv+1(v) =

rotvdx =

(∂1v2 − ∂2v1)dx

K

(cid:90)

K

(v2n1 − v1n2)ds =

(cid:90)

∂K

(v · t)ds

=

=

∂K

Nv(cid:88)

i=1

1
2

(v(zi) + v(zi+1)) · (heitei),

v = (cid:99)mα.

According to the above discussion, the transition matrix is calculated as follows.

1 K = pde . K ; % coefficient matrix

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

% ------- element information - - - - - - - - - -

index = elem { iel };

Nv = length ( index ) ;

xK = centroid ( iel ,1) ; yK = centroid ( iel ,2) ; hK = diameter ( iel ) ;

x = node ( index ,1) ; y = node ( index ,2) ;

v1 = 1: Nv ; v2 = [2: Nv ,1]; % loop index for vertices or edges

xe = ( x ( v1 ) + x ( v2 ) ) /2;

ye = ( y ( v1 ) + y ( v2 ) ) /2; % mid - edge points

Ne = [ y ( v2 ) -y ( v1 ) , x ( v1 ) -x ( v2 ) ]; % he * ne

Te = [ - Ne (: ,2) , Ne (: ,1) ]; % he * te

% ------- scaled monomials -- -- -- --

m2 = @ (x , y ) (x - xK ) ./ hK ;

m3 = @ (x , y ) (y - yK ) ./ hK ;

m4 = @ (x , y ) (x - xK ) .^2./ hK ^2;

m5 = @ (x , y ) (x - xK ) .*( y - yK ) ./ hK ^2;

m6 = @ (x , y ) (y - yK ) .^2./ hK ^2;

% \ hat { m } _a = K * grad ( hK * m_ { a +1})

mh1 = @ (x , y ) [ K (1 ,1) +0* x ; K (2 ,1) +0* x ];

mh2 = @ (x , y ) [ K (1 ,2) +0* x ; K (2 ,2) +0* x ];

mh3 = @ (x , y ) [2* K (1 ,1) * m2 (x , y ) ; 2* K (2 ,1) * m2 (x , y ) ];

mh4 = @ (x , y ) [ K (1 ,1) * m3 (x , y ) + K (1 ,2) * m2 (x , y ) ; K (2 ,1) * m3 (x , y ) + K (2 ,2) * m2 (x , y ) ];

mh5 = @ (x , y ) [2* K (1 ,2) * m3 (x , y ) ; 2* K (2 ,2) * m3 (x , y ) ];

mh = @ (x , y ) [ mh1 (x , y ) , mh2 (x , y ) , mh3 (x , y ) , mh4 (x , y ) , mh5 (x , y ) ];

% -------- transition matrix - - - - - - - - - -

NdofA = 2* Nv +1; Nmh = 5;

D = zeros ( NdofA , Nmh ) ;

for i = 1: Nv % loop of edges

% v at z_i , z_ { i +1} for v = [ mK1 ,... , mK5 ]

va = mh ( x ( v1 ( i ) ) ,y ( v1 ( i ) ) ) ; vb = mh ( x ( v2 ( i ) ) ,y ( v2 ( i ) ) ) ;

% chi_i , i = 1 ,... , Nv

D (i ,:) =

1/2* Ne (i ,:) *( va + vb ) ;

% chi_ { Nv + i } , i = 1 ,... , Nv

D ( Nv +i ,:) =

1/12* Ne (i ,:) *( vb - va ) ;

% chi_ {2 Nv +1}

D ( end ,:) = D ( end ,:) + 1/2* Te (i ,:) *( va + vb ) ;

end

Here, K is for K and mhat is for (cid:99)mT .

Elliptic projection matrices

We denote the matrix representation of the (cid:98)ΠK-projection by (cid:98)Π

K

in the sense that

(cid:98)ΠK(φ1, φ2, · · · , φNk

) = (φ1, φ2, · · · , φNk

K

) (cid:98)Π

K
or (cid:98)ΠKφT = φT (cid:98)Π

.

11

K

K

=
. The elliptic projection vector (cid:98)ΠKφT can be expanded in the basis (cid:99)mT of the el-

is the d.o.f vector of (cid:98)ΠKφj, i.e., (cid:98)Π

By the deﬁnition of d.o.f.s, the j-th column of (cid:98)Π
(cid:17)
(cid:16)
χi((cid:98)ΠKφj)
liptic projection space (cid:98)Vk(K) as (cid:98)ΠKφT = (cid:99)mT

K
∗ . It is easy to check that (cid:98)Π

= D (cid:98)Π

K
∗ .

(cid:98)Π

K

The deﬁnition 8 is equivalent to

aK((cid:99)m, (cid:98)ΠKφT ) = aK((cid:99)m, φT )

or

(cid:98)G (cid:98)Π

K
∗ = (cid:98)B,

where

(cid:98)G = aK((cid:99)m, (cid:99)mT ),
We also have the consistency relation (cid:98)G = (cid:98)BD.

(cid:98)B = aK((cid:99)m, φT ).

We now compute (cid:98)B. From (9) and (18), one has

(cid:98)Bαi = aK((cid:99)mα, φi) = −hK

(cid:90)

K

mα+1divφidx + hK

(cid:90)

∂K

mα+1φi · nds

=: −hKI1(α, i) + hKI2(α, i),

where

I1(α, i) =

(cid:90)

K

mα+1divφidx,

I2(α, i) =

(cid:90)

∂K

mα+1φi · nds.

For I1, noting that divφi is constant when k = 1, set divφi = cim1 = ci, which gives

ci = |K|−1

(cid:90)

K

divφidx = |K|−1

(cid:90)

∂K

φi · nds =




|K|−1,

i = 1, · · · , Nv,



0,

i > Nv,

and hence

I1(α, i) =

(cid:90)

K

mα+1divφidx = ci

(cid:90)

K

mα+1dx.

The ﬁrst term is now computed in MATLAB as follows.

1

2

3

4

5

6

7

% first term

nodeT = [ node ( index ,:) ; centroid ( iel ,:) ];
elemT = [( Nv +1) * ones ( Nv ,1) ,(1: Nv ) ' ,[2: Nv ,1] '];
m = @ (x , y ) [ m2 (x , y ) , m3 (x , y ) , m4 (x , y ) , m5 (x , y ) , m6 (x , y ) ]; % m_ { a +1} ,...

ci = zeros (1 , NdofA ) ; ci (1: Nv ) = 1/ area ( iel ) ;

Intm = integralTri (m ,3 , nodeT , elemT ) ;
I1 = Intm '* ci ;

The subroutine integralTri.m calculates the integral on a polygonal element which is triangulated

with the basic data structures nodeT and elemT.

For I2, since φi · n|ej ∈ P1(ej) (i = 1, · · · , 2Nv + 1), set

φi · nej |ej = ci

0 + ci
1

s − sej
hej

,

where s it the natural parameter of the edge ej and sej is the mid-point in the local parametrization.
Noting that

(cid:90)

e

(cid:16) s − se
he

(cid:17)α(cid:16) s − se

(cid:17)β

he

ds =

he
(α + β + 1)

(cid:16)

1
2α+β+1 −

1
(−2)α+β+1

(cid:17)

,

12

we then obtain






0 = (cid:82)

hej ci
1
12 hej ci

1 = (cid:82)

ej

φi · nds =: ri
j,
s−sej
ds =: si
j.
hej

φi · n

ej

By deﬁnition, the nonzero elements of ri

j and si

j are

We have

and hence

It is obvious that

rj
j = sj+Nv

j

= 1,

j = 1, · · · , Nv.

ci
0 =

1
hej

ri
j,

ci
1 =

12
hej

si
j,

j(s) := φi · (hej nej )|ej = ri
ri

j + 12si
j

s − sej
hej

.

j(sa) = ri
ri

j − 6si
j,

j(se) = ri
ri
j,

j(sb) = ri
ri

j + 6si
j,

where, sa, se and sb correspond to the starting point, middle point and ending point in the local
parameterization, respectively.

Observing that the Simpson formula is accurate for cubic polynomials, we have

I2(α, i) =

=

=

Nv(cid:88)

(cid:90)

ej

hej
6

j=1

Nv(cid:88)

j=1

mα+1φi · nds

(mα+1φi(zj) + 4mα+1φi(zej ) + mα+1φi(zj+1) · nej

1
6

Nv(cid:88)

j=1

mα+1(zj)ri

j(sa) + 4mα+1(zej )ri

j(se) + mα+1(zj+1)ri

j(sb)

or

I2(α, :) =

1
6

Nv(cid:88)

j=1

mα+1(zj)rj(sa) + 4mα+1(zej )rj(se) + mα+1(zj+1)rj(sb).

Then the second term and the matrices (cid:98)B and (cid:98)G can be computed as follows.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

% second term

rij = zeros ( Ndof , Nv ) ; rij (1: Nv ,:) = eye ( Nv ) ;

sij = zeros ( Ndof , Nv ) ; sij ( Nv +1:2* Nv ,:) = eye ( Nv ) ;

rija = rij - 6* sij ;

rije = rij ;

rijb = rij + 6* sij ;

I2 = zeros ( np , Ndof ) ;

for j = 1: Nv

ma = m ( x ( v1 ( j ) ) ,y ( v1 ( j ) ) ) ;

me = m ( xe ( j ) , ye ( j ) ) ;

mb = m ( x ( v2 ( j ) ) ,y ( v2 ( j ) ) ) ;
rja = rija (: , j ) ';
I2 = I2 + 1/6*( ma '* rja + 4* me '* rje + mb '* rjb ) ;

rje = rije (: , j ) ';

rjb = rijb (: , j ) ';

end

% \ hat { B } and \ hat { G }

Bs = hK *( - I1 + I2 ) ; Gs = Bs * D

13

2.2.4 Computation and assembly of the stiﬀness matrix and load vector

The stiﬀness matrix

The local stiﬀness matrix of A in (16) is AK = AK

1 + AK

2 , where

AK

1 (i, j) = aK((cid:98)ΠKφj, (cid:98)ΠKφi),
2 (i, j) = (cid:107)K−1(cid:107)SK(φj − (cid:98)ΠKφj, φi − (cid:98)ΠKφi)

AK

= (cid:107)K−1(cid:107)

Nk(cid:88)

i=1

χr(φj − (cid:98)ΠKφj)χr(φi − (cid:98)ΠKφi).

The ﬁrst term is written in matrix form as

A1

K
K = aK((cid:98)ΠKφ, (cid:98)ΠKφT ) = ( (cid:98)Π

∗ )T aK((cid:99)m, (cid:99)mT ) (cid:98)Π

K
∗ = ( (cid:98)Π

K
K
∗ )T (cid:98)G (cid:98)Π
∗ .

K
For the second term, from χr((cid:98)ΠKφi) = ( (cid:98)Π

)ri one has

A2

K
K = (cid:107)K−1(cid:107)(I − (cid:98)Π

K
)T (I − (cid:98)Π

).

Fig. 3. Illustration of the global and local basis functions

Note that the signs of the d.o.f.s in (10) vary with the edge orientation, which means the global

basis function ϕi restriction to the element may have the opposite sign with the local basis function
φi. As shown in Fig. 3, e is an interior edge with the global orientation given by the arrow. Let ϕ
be the global basis function, and let φ1 and φ2 be the local basis functions corresponding to the
left and right elements, respectively. Then one has

φ1 = −ϕ|K1, φ2 = ϕ|K2.

Obviously, the sign can be determined by computing the diﬀerence between the two indices of the

end points of e. For this reason, one only needs to compute the elementwise signs of the edges of

∂K. The code is given as

1 % % Get elementwise signs of basis functions

2 bdEdgeIdx = bdStruct . bdEdgeIdx ;

E = false ( NE ,1) ; E ( bdEdgeIdx ) = 1;

3 sgnBase = cell ( NT ,1) ;

4 for iel = 1: NT

index = elem { iel };

Nv = length ( index ) ;

NdofA = 2* Nv +1;

sgnedge = sign ( diff ( index ([1: Nv ,1]) ) ) ;

id = elem2edge { iel }; sgnbd = E ( id ) ; sgnedge ( sgnbd ) = 1;

sgnelem = ones ( NdofA ,1) ; sgnelem (1: Nv ) = sgnedge ;

sgnBase { iel } = sgnelem ;

5

6

7

8

9

10 end

14

Note that the positive signs of the boundary edges are recovered in the above code.

Since aK(±φi, ±φj) = ± · ±aK(φi, φj), we can introduce a signed stiﬀness matrix sgnK to add
the correct signs to the local stiﬀness matrix. The matrix AK can be computed in the following

way.

1

2

3

4

5

6

7

8

9

10

11

% -------- sign matrix and sign vector -------

sgnelem = sgnBase { iel };
sgnK = sgnelem * sgnelem ';

% - - - - - - - - - - - - - stiffness matrix - - - - - - - - - - - - -

% Projection

Pis = Gs \ Bs ;

Pi

= D * Pis ;

I = eye ( size ( Pi ) ) ;

% Stiffness matrix A

AK

= Pis '* Gs * Pis + norm ( inv ( K ) , ' fro ') *( I - Pi ) '*(I - Pi ) ;

% G = Gs

AK = AK .* sgnK ;
AK = reshape ( AK ' ,1 ,[]) ; % straighten as row vector for easy assembly

By the deﬁnition of Qh, on each element K, the basis function ψl ∈ Pk−1(K). Only one basis
ψl = m1 = 1 for k = 1. Hence, the element matrix BK of B in (16) is a column vector of size
Nk × 1 (Note that B is of size (2NE+NT) × NT), and

BK

j1 = bK(φj, m1) =

m1divφjdx =

(cid:90)

K

divφjdx

(cid:90)

=

∂K

φj · nds =

1,

1 ≤ j ≤ Nv,



0,

j > Nv.

(cid:90)

K



The sign of each entry is adjusted by using bK(±φi, ψj) = ±bK(φi, ψj).

1

2

3

4

% Stiffness matrix B

BK = zeros ( NdofA ,1) ; BK (1: Nv ) = 1;

BK = BK .* sgnelem ;
BK = reshape ( BK ' ,1 ,[]) ; % straighten as row vector for easy assembly

For k = 1, Qh is piecewise constant, and hence has NT basis functions given by

ψl(x) =




1,



0,

x ∈ Kl,

otherwise.

Obviously, the vector in (15) is

dl =

(cid:90)

Kl

dx = |Kl|,

l = 1, · · · , M = NT.

We compute the elliptic projections and provide the assembly index by looping over the ele-

ments. The assembly index for the matrices A and B is given by

1

2

3

4

5

6

7

8

9

% ------ assembly index for bilinear forms -- -- -- --

NdofA = 2* Nv +1; NdofB = 1;

indexDofA = [ elem2edge { iel } , elem2edge { iel }+ NE , iel +2* NE ];

indexDofB = iel ;

iiA ( idA +1: idA + NdofA ^2) = reshape ( repmat ( indexDofA , NdofA ,1) , [] , 1) ;

jjA ( idA +1: idA + NdofA ^2) = repmat ( indexDofA (:) , NdofA , 1) ;

ssA ( idA +1: idA + NdofA ^2) = AK (:) ;

idA = idA + NdofA ^2;

iiB ( idB +1: idB + NdofA * NdofB ) = reshape ( repmat ( indexDofA , NdofB ,1) , [] , 1) ;

15

10

11

12

jjB ( idB +1: idB + NdofA * NdofB ) = repmat ( indexDofB (:) , NdofA , 1) ;

ssB ( idB +1: idB + NdofA * NdofB ) = BK (:) ;

idB = idB + NdofA * NdofB ;

Afterwards, we can assemble the matrices A and B using the MATLAB functions sparse.

1 A = sparse ( iiA , jjA , ssA , NNdofA , NNdofA ) ;

2 B = sparse ( iiB , jjB , ssB , NNdofA , NNdofB ) ;

3 d = area ;

% for Lagrange multiplier

The load vector

For the right-hand side, in view of (16), we only need to compute f = (−(f, ψl)). For k = 1,

the local vector is

with the realization reading

f K = −(f, ψl)K = −

(cid:90)

K

f dx,

1

2

3

4

1

2

3

4

% -------- load vector f - - - - - - - - - -

fxy = @ (x , y ) pde . f ([ x , y ]) ; % f ( p ) = f ([ x , y ])
rhs = integralTri ( fxy ,3 , nodeT , elemT ) ; rhs = rhs ';
fK = - rhs ;

The assembly index for the vector f is given by

% ------- assembly index for rhs -------

elemb ( ib +1: ib + NdofB ) = indexDofB (:) ;

Fb ( ib +1: ib + NdofB ) = fK (:) ;

ib = ib + NdofB ;

Then f can be assembled using the MATLAB functions accumarray.

1

FB = accumarray ( elemb , ffB ,[ NNdofB 1]) ;

To sum up, the linear system without boundary conditions imposed is given by

1 % % Get block linear system

2 kk = sparse ( NNdof +1 , NNdof +1) ;

ff = zeros ( NNdof +1 ,1) ;

3 kk (1: NNdofA ,1: NNdofA ) = A ;

4 kk (1: NNdofA , (1: NNdofB ) + NNdofA ) = B ;
5 kk ((1: NNdofB ) + NNdofA , 1: NNdofA ) = B ';
6 kk ((1: NNdofB ) + NNdofA, end) = d ;
7 kk ( end , (1: NNdofB ) + NNdofA ) = d ';
8 ff ((1: NNdofB ) + NNdofA ) = FB ;

Note that the extra variable λ leads to NNdof+1 rows or columns.

2.2.5 Applying the boundary conditions

The boundary condition u · n = g is now viewed as a Dirichlet condition for u, which provides

the values of the ﬁrst two types of d.o.f.s, i.e.,

χi(u) =

(cid:90)

ei

χNv+i(u) =

(u · n)ds,

i = 1, · · · , Nv,

(cid:90)

ei

(u · n)

s − sei
hei

ds,

i = 1, · · · , Nv

The Simpson rule is used to approximate the exact ones as follows.

16

1 % % Apply Dirichlet boundary conditions

2 % bdDof , freeDof

3 bdEdge = bdStruct . bdEdge ;

bdEdgeIdx = bdStruct . bdEdgeIdx ;

4 id = [ bdEdgeIdx ; bdEdgeIdx + NE ];

5 isBdDof = false ( NNdof +1 ,1) ; isBdDof ( id ) = true ;

6 bdDof = ( isBdDof ) ; freeDof = (¬isBdDof ) ;

7 % bdval

8 u = pde . uexact ;

9 z1 = node ( bdEdge (: ,1) ,:) ; z2 = node ( bdEdge (: ,2) ,:) ; ze = ( z1 + z2 ) ./2;

10 e = z1 - z2 ;

% e = z2 - z1

11 Ne = [ - e (: ,2) ,e (: ,1) ];

12 chi1 = 1/6* sum (( u ( z1 ) +4* u ( ze ) + u ( z2 ) ) .* Ne ,2) ; % u * n = g

13 chi2 = 1/12* sum (( u ( z2 ) -u ( z1 ) ) .* Ne ,2) ;

14 bdval = [ chi1 ; chi2 ];

15 % sol

16 sol = zeros ( NNdof +1 ,1) ;

17 sol ( bdDof ) = bdval ;

18 ff = ff - kk * sol ;

19

20 % % Set solver

21 sol ( freeDof ) = kk ( freeDof , freeDof ) \ ff ( freeDof ) ;

22 uh = sol (1: NNdofA ) ; % u = [ u1 , u2 ]
23 ph = sol ( NNdofA +1:end -1) ;

24

25 % % Store information for computing errors

26 info . Ph = Ph ; info . elem2dof = elem2dof ;

27 info . kk = kk ; % info . freeDof = freeDof ;

To compute the discrete errors, one can store the matrix representation (cid:98)Π

K
∗ and the assembly

index elem2dof in the function ﬁle.

2.2.6 Numerical example

In this paper, all examples are implemented in MATLAB R2019b. Our code is available

from GitHub (https://github.com/Terenceyuyue/mVEM). The subroutine Darcy mixedVEM.m is

used to compute the numerical solutions and the test script main Darcy mixedVEM.m veriﬁes the

convergence rates. The PDE data is generated by Darcydata.m.

Example 2.1. Let K be the identity matrix. The right-hand side f and the boundary conditions

are chosen in such a way that the exact solution of (1) is p(x, y) = sin(πx) cos(πy).

Fig. 4. Numerical and exact results for the Darcy problem

17

To test the accuracy of the proposed method we consider a sequence of polygonal meshes,

which is a Centroidal Voronoi Tessellation of the unit square in 32, 64, 128, 256 and 512 polygons.

These meshes are generated by the MATLAB toolbox - PolyMesher introduced in [45]. we report
the nodal values of the exact solution and the piecewise elliptic projection (cid:98)ΠKuh in Fig. 4. The
convergence orders of the errors against the mesh size h are shown in Fig. 5. Generally speaking, h
is proportional to N −1/2, where N is the total number of elements in the mesh. The convergence
rate with respect to h is estimated by assuming ErrL2(h) = chα, and by computing a least squares

ﬁt to this log-linear relation. As observed from Fig. 5, the convergence rate of p is linear with
respect to the L2 norm, and the VEM ensures the quadratic convergence for u in the L2 norm,

which is consistent with the theoretical prediction in [8].

Fig. 5. The convergence rates for the Darcy problem

2.2.7 A lifting mixed virtual element method

We can obtain the second-order convergence of the variable p using the lifting technique. To

do so, we modify the original virtual element space to the following lifting space

Vk(K) = {v ∈ H(div; K) ∩ H(rot; K) : v · n|e ∈ Pk(e),

divv|K ∈ Pk(K),

rotv|K ∈ Pk−1(K)},

with the d.o.f.s given by

(cid:90)

e
(cid:90)

v · nqds,

q ∈ Mk(e), e ⊂ ∂K,

K

(cid:90)

K

v · ∇qdx,

q ∈ Mk(K)\{1},

rotvqdx,

q ∈ Mk−1(K).

18

6810121416182022log(1/h)10-310-210-1||u-uh||O (h2.02)||p-ph||O (h1.02)In the lowest order case k = 1, the local d.o.f.s are arranged as

χi(v) =

(cid:90)

ei

χNv+i(v) =

χ2Nv+1(v) =

χ2Nv+2(v) =

χ2Nv+3(v) =

ei
(cid:90)

K

(cid:90)

K

(cid:90)

K

(v · n)ds,

i = 1, · · · , Nv,

(cid:90)

(v · n)

s − sei
hei

ds,

i = 1, · · · , Nv,

1
hK
1
hK

(cid:90)

K

(cid:90)

K

v1dx,

v2dx,

v · ∇m2dx =

v · ∇m3dx =

rotvdx.

In this case, Qh will be replaced by the piecewise linear space.

We repeat the test in Example 2.1. The subroutine Darcy LiftingmixedVEM.m is used to

compute the numerical solutions and the test script main Darcy LiftingmixedVEM.m veriﬁes the

convergence rates. The exact and numerical solutions for the variable p are shown in Fig. 6. The

corresponding convergence rates are displayed in Fig. 7, from which we observe the second-order

convergence for both variables.

Fig. 6. ph and p for the lifting VEM of the Darcy problem

Fig. 7. The convergence rates for the lifting VEM of the Darcy problem

3 Polygonal mesh generation and reﬁnement

The polygonal meshes can be generated by using the MATLAB toolbox - PolyMesher intro-

duced in [45]. We provide a modiﬁed version in our package and give a very detailed description

19

6810121416182022log(1/h)10-310-210-1||u-uh||O (h2.04)||p-ph||O (h2.09)in the document. The test script is meshfun.m and we present a mesh for a complex geometry in

Fig. 8.

Fig. 8. A polygonal mesh generated by PolyMesher for a complex geometry.

We present some basic functions to show the polygonal meshes, including marking of the nodes,

elements and (boundary) edges, see showmesh.m, findnode.m, findelem.m and findedge.m. For

the convenience of the computation, some auxiliary mesh data are introduced (see Subsection 2.2.2).

The idea stems from the treatment of triangulation in iFEM, which is generalized to polygonal

meshes with certain modiﬁcations. We also provide a boundary setting function to identify the

Neumann and Dirichlet boundaries (See setboundary.m).

(a)

(b)

Fig. 9. A distorted mesh and a non-convex octagonal mesh.

The routine distortionmesh.m is used to generate a distorted mesh. Let (ξ, η) be the co-

ordinates on the original mesh. The nodes of the distorted mesh are obtained by the following

transformation

x = ξ + tc sin(2πξ) sin(2πη),

y = η + tc sin(2πξ) sin(2πη),

where (x, y) is the coordinate of new nodal points; tc, taken as 0.1 in the computation, is the
distortion parameter. Such an example is displayed in Fig. 9(a). In the literature of VEMs (see [25]

for example), one often ﬁnds the test for the non-convex mesh in Fig. 9(b), which is generated by

nonConvexMesh.m in our package.

The polygonal meshes can also be obtained from a Delaunay triangulation by establishing

its dual mesh. The implementation is given in dualMesh.m. Several examples are given in

main dualMesh.m as shown in Fig. 10.

Due to the large ﬂexibility of the meshes, researchers have focused on the a posterior error

analysis of the VEMs and made some progress in recent years [18–20,24,29]. We present an eﬃcient

20

00.20.40.60.8100.10.20.30.40.50.60.70.80.9100.20.40.60.8100.10.20.30.40.50.60.70.80.91(a)

(c)

(b)

(d)

Fig. 10. Dual meshes generated by dualMesh.m.

implementation of the mesh reﬁnement for polygonal meshes [52] (see PolyMeshRefine.m). To

the best of our knowledge, this is the ﬁrst publicly available implementation of the polygonal

mesh reﬁnement algorithms. We divide elements by connecting the midpoint of each edge to its

barycenter, which may be the most natural partition frequently used in VEM papers. To remove

small edges, some additional neighboring polygons of the marked elements are included in the

reﬁnement set by requiring the one-hanging-node rule:

limit the mesh to have just one hanging

node per edge. The current implementation requires that the barycenter of each element is an

interior point.

4 Poisson equation

In this section we focus on the virtual element methods for the reaction-diﬀusion problem




−∆u + αu = f

in Ω,



u = 0

on ∂Ω,

(21)

where α is a nonnegative constant and Ω is a polygonal domain.

4.1 Conforming VEMs

Consider the ﬁrst virtual element space [7]

Vk(K) := (cid:8)v ∈ H 1(K) : ∆v ∈ Pk−2(K) in K,

v|∂K ∈ Bk(∂K)(cid:9) ,

(22)

where

Bk(∂K) := {v ∈ C(∂K) : v|e ∈ Pk(e), e ⊂ ∂K} .

21

-1-0.500.51-1-0.500.51-1-0.500.51-1-0.500.51-8-6-4-202462468-8-6-4-202462468Equipped with the d.o.f.s in [7], a computable approximate bilinear form can be constructed by
using the elliptic projector Π∇
k . To ensure the accuracy and the well-posedness of the discrete
method, a natural candidate to approximate the reaction term (u, v)K in the local bilinear form is
k is the L2 projection onto Pk(K) and (·, ·)K the usual L2(K) inner product.
(Π0
Nevertheless, Π0
k can not be computed in terms of d.o.f.s attached to Vk(K). Therefore, Ahmad et

kv)K, where Π0

ku, Π0

al. [2] modiﬁed the VEM space (22) to a local enhancement space

Wk(K) =

(cid:110)
w ∈ (cid:101)Vk(K) : (w − Π∇

k w, q)K = 0, q ∈ Mk(K)\Mk−2(K)

(cid:111)

,

(23)

where the lifting space is

(cid:101)Vk(K) := (cid:8)v ∈ H 1(K) : v|∂K ∈ Bk(∂K), ∆v ∈ Pk(K) in K(cid:9) .

In this space, the operator Π0

k can be easily computed using Π∇

k and the local d.o.f.s related to

Wk(K):

• χa: the values at the vertices of K,

χi(v) = v(ai),

ai is a vertex of K.

• χk−2
e

: the moments on edges up to degree k − 2,

χe(v) = |e|−1(me, v)e, me ∈ Mk−2(e), e ⊂ ∂K.

• χk−2

K : the moments on element K up to degree k − 2,

χK(v) = |K|−1(mK, v)K, mK ∈ Mk−2(K).

In what follows, denote by Wk,h a ﬁnite dimensional subspace of V , produced by combining
k :

all Wk(K) for K ∈ Th in a standard way. We deﬁne a local H 1-elliptic projection operator Π∇
H 1(K) → Pk(K) by the relations

(∇Π∇

k v, ∇p)K = (∇v, ∇p)K,

p ∈ Pk(K).

(24)

Since (∇·, ∇·) is only semi-positive deﬁnite, the constraints

(cid:90)

(cid:90)

vds =

∂K

∂K

Π∇

1 vds,

k = 1;

(cid:90)

K

vdx =

(cid:90)

K

Π∇

k vdx,

k ≥ 2

should be imposed. The VEM is to ﬁnd uh ∈ Wk,h such that

ac
h(uh, vh) = (cid:104)fh, vh(cid:105),

vh ∈ Wk,h,

(25)

where

ac
h(uh, vh) :=

(cid:88)

K∈Th

ac,K
h (uh, vh)

and (cid:104)·, ·(cid:105) is the duality pairing between W (cid:48)

k,h and Wk,h. The local approximate bilinear form is

ac,K
h (v, w) = aK(Π∇

k v, Π∇

k w) + α(Π0

kv, Π0

kw)K + SK(v − Π∇

k v, w − Π∇

k w)

22

where aK(v, w) = (∇v, ∇w)K and the stabilization term is realized as

SK(v − Π∇

k v, w − Π∇

k w) := (1 + αh2

K)χ(v − Π∇

k v) · χ(w − Π∇

k w),

where χ is referred to as the d.o.f vector of a VEM function on K.

Let φT = (φ1, φ2, · · · , φNk ) be the basis of Wk(K) and let mT = (m1, m2, · · · , mNm) be the
scaled monomials. Then the transition matrix D can be deﬁned through mT = φT D. The matrix
expressions of Π∇

k φT in the basis φT and mT are deﬁned by

Π∇

k φT = φT Π∇

k , Π∇

k φT = mT Π∇
k∗.

One easily ﬁnds that Π∇

k∗. In vector form, the deﬁnition of (24) can be rewritten as

k = DΠ∇



aK(m, Π∇

k φT ) = aK(m, φT ),

where

Deﬁne

Then



P0(Π∇

k φT ) = P0(φT ),

P0(v) =

(cid:90)

∂K

vds,

k = 1;

P0(v) =

(cid:90)

K

vdx,

k ≥ 2.

G = aK(m, mT ), B = aK(m, φT ).

(26)






GΠ∇

k∗ = B,
P0(mT )Π∇

k∗ = P0(φT )

or

˜GΠ∇

k∗ = ˜B.

Note that one always has the consistency relations G = BD and ˜G = ˜BD.

We remark that in the implementation of the VEM, the most involved step is to compute the

boundary part of B resulted from the integration by parts:

B =

(cid:90)

K

∇m · ∇φT dx = −

(cid:90)

K

∆m · φT dx +

(cid:90)

(cid:88)

e⊂∂K

e

(∇m · ne)φT ds.

(27)

For the conforming VEMs, however, we can compute the second term of (27) by using the assem-

bling technique for ﬁnite element methods since the VEM function restriction to the boundary ∂K

is piecewise polynomial. For example, the computation for k = 2 reads

1 % second term

2 I2 = zeros ( Nm , Ndof ) ;

3 v1 = 1: Nv ; v2 = [2: Nv ,1];

4 elem1 = [ v1 (:) , v2 (:) , v1 (:) + Nv ];

5 for im = 1: Nm

gradmc = Gradmc { im };

F1 = 1/6* sum ( gradmc ( x ( v1 ) , y ( v1 ) ) .* Ne , 2) ;

F2 = 1/6* sum ( gradmc ( x ( v2 ) , y ( v2 ) ) .* Ne , 2) ;

F3 = 4/6* sum ( gradmc ( xe , ye ) .* Ne , 2) ;

F = [ F1 , F2 , F3 ];

I2 ( im , :) = accumarray ( elem1 (:) , F (:) , [ Ndof 1]) ;

6

7

8

9

10

11

12 end

23

Example 4.1. Let α = 1 and Ω = (0, 1)2. The Neumann boundary condition is imposed on x = 0

and x = 1 with the exact solution given by u(x, y) = sin(2x + 0.5) cos(y + 0.3) + log(1 + xy).

The test script is main PoissonVEMk3.m for k = 3. The optimal rate of convergence of the
H 1-norm (3rd order), L2-norm (4th order) and energy norm (3rd order) is observed for k = 3 from

Fig. 11.

(a) k = 1

(b) k = 2

(c) k = 3

Fig. 11. Convergence rates for Example 4.1.

Example 4.2. In this example, the exact solution is u(x, y) = y2 sin(πx). The domain Ω is taken

as a unit disk.

The Neumann boundary condition is imposed on the boundary of the upper semicircle. The

nodal values are displayed in Fig. 12.

Fig. 12. Numerical and exact solutions for Example 4.2 (k = 1)

4.2 Nonconforming VEMs

4.2.1 The standard treatment of the domain boundary

Now we consider the nonconforming VEMs proposed in [6] for the problem (21) with α = 0.

The local nonconforming virtual element space is deﬁned by

k (K) = (cid:8)v ∈ H 1(K) : ∆v ∈ Pk−2(K), ∂nv|e ∈ Pk−1(e), e ⊂ ∂K(cid:9) ,
V nc

k ≥ 1,

and the d.o.f.s can be chosen as

24

6810121416182022log(1/h)10-310-210-1||u-uh||O (h1.98)|u-hh|1O (h1.02)||uI-uh||EO (h1.26)6810121416182022log(1/h)10-610-510-410-310-2||u-uh||O (h3.03)|u-hh|1O (h2.04)||uI-uh||EO (h2.14)6810121416182022log(1/h)10-810-710-610-510-410-3||u-uh||O (h3.99)|u-hh|1O (h3.04)||uI-uh||EO (h2.96)-0.8-0.61-0.4-0.20.510u0.20.40.5y00.6x0.80-0.5-0.5-1-1-0.8-0.61-0.4-0.20.510ue0.20.40.5y00.6x0.80-0.5-0.5-1-1• χ∂K(v): the moments on edges up to degree k − 1,

χe(v) = |e|−1(me, v)e, me ∈ Mk−1(e), e ⊂ ∂K.

• χK(v): the moments on K up to degree k − 2,

χK(v) = |K|−1(mK, v)K, mK ∈ Mk−2(K).

The elliptic projection and the discrete problem can be constructed in the same way as before.

We brieﬂy discuss the implementation of k = 1. In this case, the ﬁrst term for the matrix B in

(27) vanishes and the second term is obtained from the Kronecher’s property χi(φj) = σij, which
is realized as follows.

1 % B

2 B = zeros ( Nm , Nv ) ;

3 for i = 1: Nv % loop of edges

gi = sum ( Gradm .* repmat ( Ne (i ,:) ,3 ,1) , 2) ; % gradm * Ne

B (: , i ) = gi ;

4

5

6 end

For completeness, we also present the application of the Neumann boundary conditions. Let e

be a boundary edge of the Neumann boundary ΓN . Then the local boundary term is approximated
as

Fe =

Π0

0,egN φeds,

(cid:90)

e

0,e is the L2 projection on e, and φe is the local basis function
where gN = ∂nu = ∇u · ne, Π0
associated with the d.o.f χe(v) = |e|−1(me, v)e. For problems with known explicit solutions, we
provide the gradient gN = ∇u in the PDE data instead and compute the true gN in the M-ﬁle.
Obviously, the L2 projection Π0
0,egN can be computed by the mid-point formula or the trapezoidal

rule. The computation reads

1 % % Assemble Neumann boundary conditions

2 bdEdgeN = bdStruct . bdEdgeN ;

bdEdgeIdxN = bdStruct . bdEdgeIdxN ;

3 if ¬isempty ( bdEdgeN )

g_N = pde . Du ;

z1 = node ( bdEdgeN (: ,1) ,:) ; z2 = node ( bdEdgeN (: ,2) ,:) ;

e = z1 - z2 ;

% e = z2 - z1

Ne = [ - e (: ,2) ,e (: ,1) ]; % scaled ne

F1 = sum ( Ne .* g_N ( z1 ) ,2) ;

F2 = sum ( Ne .* g_N ( z2 ) ,2) ;

FN = ( F1 + F2 ) /2;

ff = ff + accumarray ( bdEdgeIdxN (:) , FN (:) ,[ NNdof 1]) ;

4

5

6

7

8

9

10

11

12 end

Note that the structure data bdStruct stores all necessary information of boundary edges, which

is obtained by using the subroutine setboundary.m. In the above code, bdEdgeN gives the data

structure bdEdge in Subsection 2.2.2 for Neumann edges and bdEdgeIdxN provides their indices

in the data structure edge.

We still consider Example 4.1 and display the convergence rates in the discrete L2 and H 1

norms in Fig. 13. The optimal rate of convergence is observed for both norms and the test script

is main PoissonVEM NC.m.

25

Fig. 13. Convergence rates of the Poisson equation for the nonconforming VEM (k = 1)

4.2.2 A continuous treatment of the domain boundary

In some cases it may be not convenient to deal with the moments on the domain boundary

∂Ω. To do so, we can modify the corresponding local virtual element spaces to the following one

V ncb
k

(K) =

(cid:110)

v ∈ H 1(K) : ∆v ∈ Pk−2(K), ∂nv|e ∈ Pk−1(e), e is an interior edge

v|e ∈ Pk(e), e is a boudary edge,

e ⊂ ∂K

(cid:111)
.

We repeat the test in Fig. 13 and the discrete L2 and H 1 errors are listed in Tab. 2. Please

refer to main PoissonVEM NCb.m for the test script.

Tab. 2. The discrete errors for the modiﬁed nonconforming VEM

(cid:93)Dof

h

ErrL2

ErrH1

97

1.768e-01

1.17632e-02

1.51836e-01

193

383

760

1.250e-01

5.37635e-03

1.10077e-01

8.839e-02

3.14973e-03

7.82566e-02

6.250e-02

1.43956e-03

5.26535e-02

1522

4.419e-02

6.48454e-04

3.71405e-02

5 Linear elasticity problems

The linear elasticity problem is





−divσ = f

in Ω,

u = 0

σn = g

on Γ0,

on Γ1,

(28)

where n = (n1, n2)T denotes the outer unit vector normal to ∂Ω. The constitutive relation for
linear elasticity is

σ(u) = 2µε(u) + λ(divu)I,

26

6810121416182022log(1/h)10-310-210-1||u-uh||O (h2.16)|u-hh|1O (h1.02)where σ = (σij) and ε = (εij) are the second order stress and strain tensors, respectively, satisfying
εij = 1
2 (∂iuj + ∂jui), λ and µ are the Lam´e constants, I is the identity matrix, and divu =
∂1u1 + ∂2u2.

5.1 Conforming VEMs

5.1.1 The displacement type

The equilibrium equation in (28) can also be written in the form

− µ∆u − (λ + µ)grad(divu) = f in Ω,

(29)

which is referred to as the displacement type or the Navier type in what follows. In this case, we

only consider Γ0 = Γ := ∂Ω. The ﬁrst term ∆u can be treated as the vector case of the Poisson
equation, which is clearly observed in the implementation.

The continuous variational problem is to ﬁnd u ∈ V := H 1

0(Ω) such that

where the bilinear form restriction to K is

a(u, v) = (f , v),

v ∈ V ,

aK(u, v) = µ

(cid:90)

∇u · ∇vdx + (λ + µ)

(cid:90)

(divu)(divv)dx

K
∇ (u, v) + (λ + µ)aK
=: µaK

K
div(u, v)

with

aK
∇ (u, v) =

(cid:90)

K

∇u · ∇vdx,

aK
div(u, v) =

(cid:90)

K

(divu)(divv)dx.

The local virtual element space V k(K) can be simply taken as the tensor-product of Vk(K)
deﬁned in (22), i.e., V k(K) = (Vk(K))2. Let Π∇ : V k(K) → (Pk(K))2 be the elliptic projector
induced by aK

∇ . Then the approximate bilinear form can be split as

h (u, v) = µaK
aK

h,∇(u, v) + (λ + µ)aK

h,div(u, v),

where

aK
h,∇(u, v) = aK
h,div(u, v) = (Π0
aK

k−1divu, Π0

k−1divv)K,

∇ (Π∇u, Π∇v) + SK(u − Π∇u, v − Π∇v),

and the stabilization term for k = 1 is given by

SK(u, v) =

Nv(cid:88)

i=1

χi(u) · χi(v), χi(u) = [χi(u1), χi(u2)]T .

The discrete problem is: Find uh ∈ V h such that

ah(uh, vh) = (cid:104)f h, vh(cid:105),

vh ∈ V h,

(30)

where

ah(uh, vh) =

aK
h (uh, vh)

(cid:88)

K∈Th

27

and the approximation of the right hand side is given by [54]

(cid:104)f h, vh(cid:105) = (f , Phvh),

(31)

where

Phvh|K =

1
|∂K|

(cid:90)

∂K

vhds.

Let φ1, · · · , φN be the basis functions of the scalar space Vk(K). Then the basis functions of

the vector space V k(K) can be deﬁned by

where

φ1, · · · , φN , φ
1

, · · · , φ

N

,

φi =

(cid:35)

,

(cid:34)

φi
0

φ
i

=

(cid:35)

(cid:34)

0

φi

,

i = 1, · · · , N.

Similarly, we introduce the notation

mα =

(cid:35)

,

(cid:34)

mα
0

mα =

(cid:34)

(cid:35)

0

mα

, α = 1, · · · , Nm.

(32)

These vector functions will be written in a compact form as

mT = [m1, · · · , mNm, m1, · · · , mNm] =: [mT , mT ],

φT = [φ1, · · · , φNk

, φ
1

, · · · , φ

Nk

] =: [φ

T

, φT ].

We introduce the transition matrix D such that mT = φT D. One easily ﬁnds that D =
diag(D, D), where D is the transition matrix for the scalar case, i.e., mT = φT D. This block

structure is also valid for the elliptic projection matrices. That is,

G = diag(G, G), B = diag(B, B), G = BD,

where G and B are the same ones given in (26).

In the following, we consider the matrix expression of the L2 projector Π0

k−1div satisfying

(cid:90)

K

Π0

k−1(divv)pdx =

(cid:90)

K

(divv)pdx, p ∈ Pk−1(K).

The vector form can be written as

(cid:90)

K

m0Π0

k−1(divφT )dx =

(cid:90)

K

m0(divφT )dx,

where m0 is the vector consisting of the scaled monomials of order ≤ k − 1. Let Π0∗ be the matrix
expression of Π0

k−1(divφT ) in the basis (m0)T , i.e.,

Π0

k−1(divφT ) = (m0)T Π0∗.

Then H0Π0∗ = C0, where

H0 =

(cid:90)

K

m0(m0)

T

dx,

C0 =

(cid:90)

K

m0(divφT )dx.

28

For k = 1, one has m0 = m1 = 1 and

C0 =

(cid:90)

K

m0(divφT )dx =

(cid:90)

K

divφT dx =

(cid:90)

∂K

φT · nds,

where

(cid:90)

∂K

φT · nds =

(cid:90)

∂K

T

[φ

· n, φT · n]ds =

(cid:90)

∂K

[φT · nx, φT · ny]ds.

(33)

We remark that (33) can be assembled along the boundary ∂K using the technique in ﬁnite element

methods.

1 v1 = 1: Nv ;

v2 = [2: Nv ,1];

2 H0 = area ( iel ) ;

3 C0 = zeros (1 ,2* Nv ) ;

4 F = 1/2*[(1* Ne ) ; (1* Ne ) ]; % [ he * n1 , he * n2 ]

5 C0 (:) = accumarray ([ elem1 (:) ; elem1 (:) + Nv ] , F (:) , [2* Nv 1]) ;

Example 5.1. We consider a typical example to check the locking-free property of the proposed

method. The right-hand side f and the boundary conditions are chosen in such a way that the exact

solution is

u(x, y) =

(cid:34)

(−1 + cos 2πx) sin 2πy

(cid:35)

−(−1 + cos 2πy) sin 2πx

+

1
1 + λ

sin πx sin πy

(cid:34)

(cid:35)
1

1

.

One easily ﬁnds that the proposed VEM is exactly the P1-Lagrange element when the polygonal
mesh degenerates into a triangulation, in which case the method cannot get a uniform convergence

with respect to the Lam´e constant λ. However, for general polygonal meshes, the method seems to

be robust with respect to λ (see Fig. 14), and the optimal rates of convergence are achieved in the

nearly incompressible case as shown in Fig. 15, although we have not justiﬁed it in a theoretical way

or found a counter example. Please refer to main elasticityVEM Navier.m for the test script.

Fig. 14. The exact and numerical nodal values for the linear elasticity problem of displacement type
with λ = 108 and µ = 1.

5.1.2 The tensor type

Let f ∈ L2(Ω). For simplicity, we still consider Γ0 = ∂Ω. The tensor-type variational formu-

lation of (28) is to ﬁnd u ∈ V such that

where

a(u, v) = (f , v),

v ∈ V ,

a(u, v) = 2µ(ε(u), ε(v)) + λ(divu, divv),

29

(34)

(35)

Fig. 15. The performance of the VEM for the linear elasticity problem of displacement type with
λ = 108 and µ = 1.

and

(f , v) =

(cid:90)

Ω

f vdx.

For the ease of the presentation, we introduce the following notation

aµ(u, v) = (ε(u), ε(v)),

aλ(u, v) = (divu, divv).

The conforming VEM for (34) is proposed in [10], where a locking-free analysis is carried out for

the virtual element spaces of order k ≥ 2. The order requirement is to ensure the so-called discrete

inf-sup condition and the optimal convergence.

Introduce the elliptic projection

Πa : V k(K) → (Pk(K))2,

v (cid:55)→ Πav,

satisfying

µ (Πav, p) = aK
aK

µ (v, p), p ∈ (Pk(K))2.

(36)

Note that Πav is unique up to an additive vector in

K0 := RM = span

(cid:40)(cid:34)
1

(cid:35)

0

,

(cid:34)

(cid:35)
0

1

,

(cid:34)

−y

(cid:35)(cid:41)

x

.

For this reason, we can impose one of the following constraints:

Choice 1:

Choice 2:

Choice 3:

Nv(cid:88)

i=1

(Πav(zi), p(zi)) =

Nv(cid:88)

(v(zi), p(zi)), p ∈ K0,

(cid:90)

∂K

(Πav) · pds =

i=1

(cid:90)

∂K

v · pds, p ∈ K0.

(cid:90)

K

rot Π1

Kvdx =

(cid:90)

∂K

Π1

Kvds =

(cid:90)

K

(cid:90)

rotvdx,

vds,

∂K

30

(37)

(38)

(39)

6810121416182022log(1/h)10-210-1100101||u-uh||O (h1.94)|u-hh|1O (h0.99)where rotv = ∇ × v = ∂1v2 − ∂2v1. An integration by parts gives
(cid:90)

(cid:90)

rotvdx =

v · tKds,

where tK = (−n2, n1)T is the anti-clockwise tangential along ∂K.

K

∂K

It is evident that all the three choices can be computed by using the given d.o.f.s.

The discrete problem is the same as the one in (30) with the local approximate bilinear form

replaced by

where

h (v, w) = 2µaK
aK

µ,h(v, w) + λaK

λ,h(v, w),

aK
µ,h(v, w) = aK
λ,h(v, w) = (Π0
aK

µ (Πav, Πaw) + SK(v − Πav, w − Πaw),
k−1divv, Π0

k−1divw)K.

For the lowest-order case k = 1, an integration by parts gives

B = aK

µ (m, φT ) =

(ε(m) · n) · φT ds

(40)

(cid:90)

∂K

(cid:104)

=

ε11(m)

(cid:90)

φT nxds + ε12(m)

(cid:90)

∂K

φT nyds,
(cid:90)

∂K

ε21(m)

(cid:90)

∂K

φT nxds + ε22(m)

(cid:105)

φT nyds

∂K

with

ε11(m) = [0,

1
hK

, 0, 0, 0, 0]T ,

ε22(m) = [0, 0, 0, 0, 0,

1
hK

]T ,

ε12(m) = ε21(m) = [0, 0,

1
2hK

, 0,

1
2hK

, 0]T .

Using the assembling technique for FEMs, the computation of B in MATLAB reads

1 elem1 = [ v1 (:) , v2 (:) ];

2 C0 = zeros (1 ,2* Nv ) ;

3 F = 1/2*[(1* Ne ) ; (1* Ne ) ]; % [ he * n1 , he * n2 ]

4 C0 (:) = accumarray ([ elem1 (:) ; elem1 (:) + Nv ] , F (:) , [2* Nv 1]) ;

5 E = zeros (6 ,4) ;

6 E (2 ,1) = 1/ hK ;

E ([3 ,5] ,[2 ,3]) = 1/(2* hK ) ; E (6 ,4) = 1/ hK ;

7 B = [ E (: ,1) * C01x + E (: ,2) * C01y , E (: ,3) * C01x + E (: ,4) * C01y ];

Note that for the tensor type, we can consider the pure traction problem, i.e., Γ1 = ∂Ω.
The numerical results are similar to that of the VEM of displacement type. The test script is

main elasticityVEM.m.

It is worth pointing out that we proposed in [38] a novel conforming

locking-free method with a rigorous proof, where several benchmarks are tested and the test script

can be found in main elasticityVEM reducedIntegration.m.

5.2 Nonconforming VEMs

Nonconforming VEMs for the linear elasticity problems are ﬁrst introduced in [54] for the pure

displacement/traction formulation in two or three dimensions. The proposed method is robust with

respect to the Lam´e constant for k ≥ 2.

31

For k = 1, one easily ﬁnds that

(cid:90)

∂K

φT nxds = [he1n1,x, · · · , heNv

nNv,x],

where hei is the length of the edge ei and nei = (ni,x, ni,y)T . In this case, the computation of B in
(40) for the tensor type reads

C01y = Ne (: ,2) ';
1 C01x = Ne (: ,1) ';
2 B = [ E (: ,1) * C01x + E (: ,2) * C01y , E (: ,3) * C01x + E (: ,4) * C01y ];

We provide the implementation of the displacement type and tensor type in the original non-

conforming spaces with the results displayed in Fig. 16(a)(b). Similar to the Poisson equation, we

also present the realization of the tensor type in the modiﬁed nonconforming spaces and the con-
vergence rate is shown in Fig. 16(c). Here, we still consider the test in Example 5.1 with λ = 1010

and µ = 1. As again observed in Fig. 16, the optimal rates of convergence are obtained for all the

three methods with general polygonal meshes applied in the nearly incompressible case although

we cannot justify it or provide a counter example.

The test scripts are main elasticityVEM NavierNC.m, main elasticityVEM NC.m and

main elasticityVEM NCb.m, respectively.

(a) Displacement type

(b) Tensor type

(c) Tensor type with the continuous

treatment

Fig. 16. Convergence rates of the nonconforming VEMs for the linear elasticity.

5.3 Several locking-free VEMs

The authors in [41] present two kinds of lowest-order VEMs with consistent convergence, in

which the ﬁrst one is achieved by introducing a special stabilization term to ensure the discrete

Korn’s inequality, and the second one can be seen as an extension of the idea of Kouhia and

Stenberg suggested in [40] to the virtual element method. We provide the implementation of the

second method in elasticityVEM KouhiaStenberg.m. In this approach, the local space is taken

as

V (K) = V nc

1 (K) × V1(K),

where V nc

1 (K) and V1(K) are the lowest-order nonconforming and conforming virtual element

spaces, respectively. In this case, the computation for k = 1 reads

1 C01xe = Ne (: ,1) ';

C01ye = Ne (: ,2) ';

32

6810121416182022log(1/h)10-210-1100101||u-uh||O (h1.93)|u-hh|1O (h1.01)6810121416182022log(1/h)10-210-1100101||u-uh||O (h2.03)|u-hh|1O (h1.03)6810121416182022log(1/h)10-210-1100101||u-uh||O (h2.03)|u-hh|1O (h1.01)2 C01xv = 0.5*( Ne ( p1 ,1) + Ne ( p2 ,1) ) ';
3 C01yv = 0.5*( Ne ( p1 ,2) + Ne ( p2 ,2) ) ';
4 B = [ E (: ,1) * C01xe + E (: ,2) * C01ye , E (: ,3) * C01xv + E (: ,4) * C01yv ];

We also develop a lowest-order nonconforming virtual element method for planar linear elas-

ticity in [53], which can be viewed as an extension of the idea in [32] to the virtual element

method, with the family of polygonal meshes satisfying a very general geometric assumption. The

method is shown to be uniformly convergent for the nearly incompressible case with optimal rates

of convergence.

In addition, we provide a uniﬁed locking-free scheme both for the conforming

and nonconforming VEMs in the lowest order case. The implementation and the numerical test

can be found in [53]. The test scripts are main elasticityVEM NCreducedIntegration.m and

main elasticityVEM NCUniformReducedIntegration.m, respectively.

6 Plate bending problems

In this section we focus on the plate bending problem in the form of




−∂ijMij(w) = f

in Ω ⊂ R2,



w = ∂nw = 0

on ∂Ω,

where

Mij = D ((1 − ν)Kij + νKkkδij) ,

i, j = 1, 2, k ∈ {1, 2},

Kij = −∂ijw,

i, j = 1, 2, D =

Et3
12(1 − ν2)

.

Note that we have used the summation convention whereby summation is implied when an index

is repeated exactly two times. Please refer to [23, 30, 33] for details. The variational problem is to
ﬁnd w ∈ V := H 2

0 (Ω) such that

a(w, v) = (cid:96)(v),

v ∈ V,

where

a(w, v) =

(cid:90)

Ω

Mij(w)Kij(v)dx,

(cid:96)(v) =

(cid:90)

Ω

f vdx.

6.1 C 1-continuous VEMs

We ﬁrst recall the H 2-conforming virtual element space V 2,c

k (K) introduced in [23, 30]. For

k ≥ 3, deﬁne

V 2,c
k (K) = {v ∈ H 2(K) : ∆2v ∈ Pk−4(K), v|e ∈ Pk(e), ∂nv|e ∈ Pk−1(e), e ⊂ ∂K},

while for the lowest order k = 2, the space is modiﬁed as

V 2,c
2

(K) =

(cid:110)

v ∈ H 2(K) : ∆2v = 0, v|e ∈ P3(e), ∂nv|e ∈ P1(e), e ⊂ ∂K

(cid:111)
.

The d.o.f.s are:

• The values of v(z) at the vertices of K.

33

• The values of hz∂1v(z) and hz∂2v(z) at the vertices of K, where hz is a characteristic length
attached to each vertex z, for instance, the average of the diameters of the elements having

z as a vertex.

• The moments of v on edges up to degree k − 4,

χe(v) = |e|−1(me, v)e, me ∈ Mk−4(e).

• The moments of ∂nv on edges up to degree k − 3,

χne(v) = (me, ∂nv)e, me ∈ Mk−3(e).

• The moments on element K up to degree k − 4,

χK(v) = |K|−1(mK, v)K, mK ∈ Mk−4(K).

The elliptic projection can be deﬁned in vector form as





aK(m, ΠKφT ) = aK(m, φT ),

0 (ΠKφT ) = P 1
P 1
0 (∇ΠKφT ) = P 2
P 2

0 (φT ),

0 (∇φT ),

(41)

where

P 1

0 (v) =

1
Nv

Nv(cid:88)

i=1

v(ai), P 2

0 (v) =

(cid:90)

∂K

vds.

Introduce the following notation

Q3i = Mij,j, Q3n = Q3ini, Mnn = Mijninj, Mtn = Mijtinj,

with n = (n1, n2)T and t = (−n2, n1)T . We then have the integration by parts formula

aK(p, v) = −

+

+

(cid:90)

K

(cid:90)

Q3i,i(p)vdx

(Q3n(p) + ∂tMtn(p)) vds −

∂K

Nv(cid:88)

i=1

[Mtn(p)](zi)v(zi),

(cid:90)

∂K

Mnn(p)∂nvds

which implies the computability of the elliptic projection ΠKv for any v ∈ V 2,c
term is a jump at zi along the boundary ∂K, i.e.,

k (K), where the last

[Mtn(p)](zi) = Mtn(p)

z+
(cid:12)
i
(cid:12)
(cid:12)
z−
i

.

We now consider the computation of the elliptic projection matrices. In the lowest order case,

the d.o.f.s are

• The values of v at the vertices of K,

χa(v) = v(zi),

i = 1, · · · , Nv.

34

• The values of ∇v at the vertices of K,

χa1(v) = ∂xv(zi), χa2(v) = ∂yv(zi),

i = 1, · · · , Nv.

In the implementation, they are arranged as

χi(v) = v(zi),

i = 1, · · · , Nv,

χNv+i(v) = hξ∂xv(zi),

i = 1, · · · , Nv,

χ2Nv+i(v) = hξ∂yv(zi),

i = 1, · · · , Nv,

where hξ is the characteristic length attached to each vertex. To compute the transition matrix D,
we ﬁrst provide the characteristic lengths by using the data structure node2elem, given as

1 % characteristic length

2 hxi = cellfun ( @ ( id ) mean ( diameter ( id ) ) , node2elem ) ;

3 index = elem { iel };

4 hxiK = hxi ( index ) ;

Then the computation of the matrix D reads

1 % ------- scaled monomials -- -- - -- --
2 % m '
3 m = @ (x , y ) [1+0* x , (x - xK ) / hK , (y - yK ) / hK , (x - xK ) .^2/ hK ^2 , ...

(x - xK ) .*( y - yK ) / hK ^2 , (y - yK ) .^2/ hK ^2]; % m1 ,... , m6

4
5 % Dx (m ') , Dy (m ')
6 Dxm = @ (x , y ) [0* x , 1/ hK +0* x , 0* x , 2*( x - xK ) / hK ^2 , (y - yK ) / hK ^2 , 0* x ];

7 Dym = @ (x , y ) [0* x , 0* x , 1/ hK +0* x , 0* x , (x - xK ) / hK ^2 , 2*( y - yK ) / hK ^2];

8

9 % ------ transition matrix -- -- - -- --

10 D = zeros ( Ndof , Nm ) ;

11 D (1: Nv ,:) = m (x , y ) ;

12 D ( Nv +1:2* Nv ,:) = repmat ( hxiK ,1 , Nm ) .* Dxm (x , y ) ;
13 D (2* Nv +1:end ,:) = repmat ( hxiK ,1 , Nm ) .* Dym (x , y ) ;

For k = 2, one has

Bαj = aK(mα, φj) = −

(cid:90)

(cid:88)

e⊂∂K

e

Mnn(mα)∂nφjds +

Nv(cid:88)

i=1

[Mtn(mα)](zi)φj(zi)

=: J1(α, j) + J2(α, j).

(42)

Since ∂nφj|e ∈ P1(e), the trapezoidal rule gives

J1(α, j) = −

Nv(cid:88)

i=1

Mnn(mα)|ei

|ei|
2

(∂nφj(zi) + ∂nφj(zi+1)).

Noting that

χa1,i(v) = hξ∂xv(zi) ⇒ ∂xv(zi) =

1
hξ

χa1,i(v),

i = 1, · · · , N v,

we then compute the values of ∂nφj at the vertices as follows.

1 % Dx ( phi ') , Dy ( phi ') at z1 ,... , zNv ( each row )
2 Dxphi = zeros ( Nv , Ndof ) ; Dyphi = zeros ( Nv , Ndof ) ;

3 Dxphi (: , Nv +1:2* Nv ) = eye ( Nv ) ./ repmat ( hxiK ,1 , Nv ) ;
4 Dyphi (: ,2* Nv +1:end) = eye ( Nv ) ./ repmat ( hxiK ,1 , Nv ) ;

35

For J2 with the entry given by

J2(α, j) =

Nv(cid:88)

[Mtn(mα)](zi)φj(zi),

i=1

by the deﬁnition of the jump,

[Mtn(mα)](zi) = Mtn(mα)|

z+
i
z−
i

= Mtn(mα)(z+

i ) − Mtn(mα)(z−
i ),

where Mtn(mα)(z+
ation on the edge ei−1, and

i ) is the evaluation on the edge ei to the right of zi, Mtn(mα)(z−

i ) is the evalu-

φT (zi) = [ei, 0, 0],

where ei is a zero vector with i-th entry being 1.

The above discussion is summarized in the following code.

1 % - -- - -- - -- elliptic projection - - - - - - - - - - -

2 % \ partial_ij ( m )

3 D11 = zeros ( Nm ,1) ; D11 (4) = 2/ hK ^2;

4 D12 = zeros ( Nm ,1) ; D12 (5) = 1/ hK ^2;

5 D22 = zeros ( Nm ,1) ; D22 (6) = 2/ hK ^2;

6 % Mij ( m )

7 M11 = - para . D *((1 - para . nu ) * D11 + para . nu *( D11 + D22 ) ) ;

8 M12 = - para . D *(1 - para . nu ) * D12 ;

9 M22 = - para . D *((1 - para . nu ) * D22 + para . nu *( D11 + D22 ) ) ;

10 % Mnn ( m ) on e1 ,... , eNv

11 n1 = ne (: ,1) ;
12 Mnn = M11 *( n1 .* n1 ) ' + M12 *( n1 .* n2 + n2 .* n1 ) ' + M22 *( n2 .* n2 ) ';
13 % Mtn ( m ) on e1 ,... , eNv

n2 = ne (: ,2) ;

14 t1 = te (: ,1) ; t2 = te (: ,2) ;
15 Mtn = M11 *( t1 .* n1 ) ' + M12 *( t1 .* n2 + t2 .* n1 ) ' + M22 *( t2 .* n2 ) ';
16 % Dx ( phi ') , Dy ( phi ') at z1 ,... , zNv ( each row )
17 Dxphi = zeros ( Nv , Ndof ) ; Dyphi = zeros ( Nv , Ndof ) ;

18 Dxphi (: , Nv +1:2* Nv ) = eye ( Nv ) ./ repmat ( hxiK ,1 , Nv ) ;
19 Dyphi (: ,2* Nv +1:end) = eye ( Nv ) ./ repmat ( hxiK ,1 , Nv ) ;
20 % B , Bs , G , Gs

21 B = zeros ( Nm , Ndof ) ;

22 p1 = [ Nv ,1: Nv -1]; p2 = 1: Nv ;

23 for j = 1: Nv % loop of edges

% int [\ partial_n ( phi ') ] on ej
Dnphi1 = Dxphi ( v1 ( j ) ,:) * n1 ( j ) + Dyphi ( v1 ( j ) ,:) * n2 ( j ) ; % zj

Dnphi2 = Dxphi ( v2 ( j ) ,:) * n1 ( j ) + Dyphi ( v2 ( j ) ,:) * n2 ( j ) ; % z_ { j +1}

nphi = 0.5* he ( j ) *( Dnphi1 + Dnphi2 ) ;

% Jump ( m ) at zj

Jump = Mtn (: , p2 ( j ) ) - Mtn (: , p1 ( j ) ) ;
% phi ' at zj
phi = zeros (1 , Ndof ) ;

phi ( j ) = 1;

% B1 on e and at zj

B = B - Mnn (: , j ) * nphi + Jump * phi ;

24

25

26

27

28

29

30

31

32

33

34 end

The ﬁrst constraint in (41) is

˜B(1, :) = P 1

0 (φT ) =

1
Nv

[1, 0, 0].

36

The second constraint can be computed by using the integration by parts as

(cid:90)

∂K

∇vds =

(cid:90)

(cid:88)

e⊂∂K

e

∂nevneds +

(cid:90)

e

∂tevteds

(cid:88)

=

ne

e⊂∂K

(cid:90)

e

∂nvds +

Nv(cid:88)

i=1

tei(v(zi+1) − v(zi)),

(cid:90)

∂K

∇φjds = tej−1 − tej .

where

The computation reads

1 Bs = B ;

2 % first constraint

3 Bs (1 ,1: Nv ) = 1/ Nv ;

4 % second constraint

5 for j = 1: Nv % loop of edges

Bs (2:3 ,1: Nv ) = te ([ Nv ,1: Nv -1] ,:) ' - te ';
Dnphi1 = Dxphi ( v1 ( j ) , Nv +1:end) * n1 ( j ) + Dyphi ( v1 ( j ) , Nv +1:end) * n2 ( j ) ; % zj
Dnphi2 = Dxphi ( v2 ( j ) , Nv +1:end) * n1 ( j ) + Dyphi ( v2 ( j ) , Nv +1:end) * n2 ( j ) ; % z_ { j +1}
Nphi = 0.5* Ne (j ,:) '*( Dnphi1 + Dnphi2 ) ; % scaled
Bs (2:3 , Nv +1:end) = Bs (2:3 , Nv +1:end) + Nphi ;

6

7

8

9

10

11 end

Example 6.1. The exact solution is chosen as u = sin(2πx) cos(2πy) with the parameters t = 0.1,

E = 10920 and ν = 0.3.

We consider a sequence of meshes, which is a Centroidal Voronoi Tessellation of the unit

square in 32, 64, 128, 256 and 512 polygons. The results are shown in Fig. 17. The optimal
rate of convergence of the discrete H 2-norm (1st order), H 1-norm (2nd order) and L2-norm (2nd

order) is observed for the lowest order k = 2 when meshes are ﬁne enough. The test script is

main PlateBending C1VEM.m.

Fig. 17. Convergence rates of the plate bending problem for the C 1-continuous virtual elements

6.2 C 0-continuous VEMs

The Ref. [55] gives the C0-continuous nonconforming virtual element method for the plate

bending problem, with the local virtual element space deﬁned as

V 2,0
k

(K) = {v ∈ H 2(K) : ∆2v ∈ Pk−4(K), v|∂K ∈ Bk(∂K)},

37

354045505560log(1/h)10-310-210-1100101||u-uh||O (h2.02)|u-hh|1O (h1.91)|u-uh|2O (h1.03)where K is a convex polygon and

Bk(∂K) = {v ∈ C0(∂K) : v|e ∈ Pk(e), ∆v|e ∈ Pk−2(e), e ⊂ ∂K}.

A function in V 2,0

k

(K) is uniquely identiﬁed by the following degrees of freedom:

• The values at the vertices of K,

χi(v) = v(zi),

zi is a vertex of K.

• The moments of v on edges up to degree k − 2,

χe(v) = |e|−1(me, v)e,

v ∈ Mk−2(e).

• The moments of ∂nv on edges up to degree k − 2,

χne(v) = (me, ∂nv)e, m ∈ Mk−2(e).

• The moments of v on K up to degree k − 4,

χK(v) = |K|−1(mK, v)K,

v ∈ Mk−4(K).

Fig. 18. Local degrees of freedom for the C 0-continuous virtual elements (k = 2)

We only consider the lowest order case k = 2. The d.o.f.s contain the values at the vertices and

the following moments

χe(v) =

1
|e|

(cid:90)

e

vds, χne(v) =

(cid:90)

e

∂nvds,

as shown in Fig. 18. Note that the ﬁrst-type moments can also be replaced by the midpoint values

on edges and the second-type moment has diﬀerent signs when restricted to the left and right

elements of an interior edge. Let Nv be the number of vertices. Then there are Nk = 3Nv d.o.f.s
on each element, arranged as

• The values at the vertices of K,

χi(v) = v(zi),

i = 1, · · · , Nv.

• The mid-point values on each edge of K,

χi+Nv (v) = v(mi),

i = 1, · · · , Nv.

38

• The moments

χ2Nv+i(v) =

(cid:90)

ei

∂nvds,

i = 1, · · · , Nv.

Since

(cid:90)

∂nφT ds = [0, 0, ej], φT (zi) = [ei, 0, 0],

e
the matrix B for the elliptic projection can be realized as

1 B = zeros ( Nm , Ndof ) ;

2 p1 = [ Nv ,1: Nv -1]; p2 = 1: Nv ;

3 for j = 1: Nv % loop of edges

4

5

6

7

8

9

10

11

% nphi on ej

nphi = zeros (1 , Ndof ) ; nphi (2* Nv + j ) = 1;

% Jump at zj

Jump = Mtn (: , p2 ( j ) ) - Mtn (: , p1 ( j ) ) ;

% phi at zj

phi = zeros (1 , Ndof ) ; phi ( j ) = 1;

% B1

B = B - Mnn (: , j ) * nphi + Jump * phi ;

12 end

Noting that

(cid:90)

∂K

∇φjds = tej−1 − tej ,

(cid:90)

∂K

∇φNv+jds = 0,

(cid:90)

∂K

∇φ2Nv+jds = nej ,

we can compute the constraints as follows.

1 Bs = B ;

2 % first constraint

3 Bs (1 ,1: Nv ) = 1/ Nv ;

4 % second constraint
5 Bs (2:3 ,1: Nv ) = te ([ Nv ,1: Nv -1] ,:) ' - te ';
6 Bs (2:3 ,2* Nv +1:end) = ne ';

We repeat the test in Example 6.1 and display the result in Fig. 19.

In this case, we still

observe the optimal convergence rates. The test script is main PlateBending C0VEM.m.

Fig. 19. Convergence rates of the plate bending problem for the C 0-continuous virtual elements

39

354045505560log(1/h)10-210-1100101||u-uh||O (h1.98)|u-hh|1O (h1.85)|u-uh|2O (h1.18)||uI-uh||EO (h0.96)6.3 Morley-type VEMs

The fully H 2-nonconforming virtual element method was proposed in [3] for biharmonic prob-

lem. The local virtual element space is deﬁned by

k (K) = {v ∈ H 2(K) : ∆2v ∈ Pk−4(K),
V 2

Mnn(v)|e ∈ Pk−2(e), Qn(v)|e ∈ Pk−3(e), e ⊂ ∂K}.

The corresponding degrees of freedom can be chosen as:

• The values at the vertices of K.

• The moments of v on edges up to degree k − 3,

χe(v) = |e|−1(me, v)e, me ∈ Mk−3(e).

• The moments of ∂nv on edges up to degree k − 2,

χne(v) = (me, ∂nv)e, me ∈ Mk−2(e).

• The moments on element K up to degree k − 4,

χK(v) = |K|−1(mK, v)K, mK ∈ Mk−4(K).

If k = 2 and K is a triangle, one can prove that V 2

k (K) becomes the well-known Morley element.
We remark that the above Morley-type virtual element is also proposed in [56] with the same

d.o.f.s but diﬀerent local space, where the enhancement technique in [2] is utilized to modify the
C0-continuous spaces.

The test script is main PlateBending MorleyVEM.m. We repeat the test in Example 6.1 and

display the result in Fig. 20, from which we again observe the optimal rate of convergence in all

the discrete norms.

Fig. 20. Convergence rates of the plate bending problem for the fully nonconforming virtual elements

40

354045505560log(1/h)10-210-1100101||u-uh||O (h1.96)|u-hh|1O (h1.81)|u-uh|2O (h1.21)7 Stokes problem

The Stokes problem with homogeneous Dirichlet boundary conditions is to ﬁnd (u, p) such

that

Deﬁne





−ν∆u − ∇p = f

in Ω,

divu = 0

u = 0

in Ω,

on ∂Ω.

V = H 1

0(Ω), Q = L2

0(Ω).

The mixed variational problem is: Find (u, p) ∈ V × Q such that




a(u, v) + b(v, p) = (f , v),

v ∈ V ,



b(u, q)

= 0,

q ∈ Q,

where

a(u, v) = (ν∇u, ∇v),

b(v, q) = (divv, q).

7.1 The mixed VEMs

In this subsection, we review the divergence-free virtual elements proposed in [17] for the

Stokes problem.

7.1.1 Virtual element space and elliptic projection

The local virtual element space associated with V for k ≥ 2 is

(cid:110)

Vk(K) =

v ∈ H 1(K) : v|∂K ∈ [Bk(∂K)]2,



−ν∆v − ∇s ∈ Gk−2(K)⊥,
divv ∈ Pk−1(K),



for some s ∈ L2(K)

(cid:111)
,

where

Gk−2(K) = ∇(Pk−1(K)) ⊂ (Pk−2(K))2.

The ﬁnite dimensional space for Q is taken as Qk(K) = Pk−1(K).

The d.o.f.s for Vk(K) and Qk(K) can be chosen as

• DV1: the values at the vertices of K.

• DV2: k − 1 interior points on each edge e.

• DV3: the moments

• DV4: the moments

(cid:90)

K

v · g⊥

k−2dx,

k−2 ∈ Gk−2(K)⊥.
g⊥

(cid:90)

K

(divv)qk−1dx,

qk−1 ∈ Pk−1(K)/R.

41

• DQ: the moments

(cid:90)

K

qpk−1dx,

pk−1 ∈ Pk−1(K).

As usual, we deﬁne the elliptic projection ΠK : Vk(K) → (Pk(K))2, v (cid:55)→ ΠKv satisfying




aK(ΠKv, q) = aK(v, q),

q ∈ (Pk(K))2,



0 (ΠKv) = P K
P K

0 (v),

(43)

where P K
0

is the constant projector on K. One can check that the elliptic projection ΠKv is

computable by using the given d.o.f.s. In fact, the integration by parts gives

aK(v, q) =

(cid:90)

K

ν∇q · ∇vdx = −

(cid:90)

K

ν∆q · vdx +

(cid:90)

∂K

(ν∇qn) · vds,

where n = (n1, n2)T and

∇q =

(cid:35)

(cid:34)

=

(cid:34)

∇q1
∇q2

q1,x
q2,x

(cid:35)

.

q1,y
q2,y

Since ν∆q ∈ (Pk−2(K))2, there exists qk−1 ∈ Pk−1(K)/R and g⊥

k−2 ∈ Gk−2(K)⊥ such that

ν∆q = ∇qk−1 + g⊥

k−2.

Then

aK(v, q) = −

(cid:90)

=

(cid:90)

K

K

∇qk−1 · vdx −

(cid:90)

g⊥
k−2 · vdx +
(cid:90)

K
g⊥
k−2 · vdx +

∂K

(cid:90)

K

(cid:90)

∂K

(ν∇qn) · vds

(ν∇qn − qk−1n) · vds.

(44)

qk−1divvdx −

Obviously, the ﬁrst term and the second term are determined by DV4 and DV3, respectively, while
the boundary term can be computed by DV1 and DV2. Note that g⊥
k−2 = 0 in the lowest order case

k = 2.

7.1.2 The discrete problem

The bilinear form aK(u, v) is approximated by

h (u, v) = aK(ΠKu, ΠKv) + SK(u − ΠKu, v − ΠKv),
aK

with the stabilization term SK given by the l2-inner product of the d.o.f. vectors.

In what follows we use Vh to denote the global virtual element space of Vk(K). The discrete

space Qh of Q is

Qh := {q ∈ Q : q|K ∈ Pk−1(K), K ∈ Th.}

The discrete mixed problem is: Find (uh, ph) ∈ V g

h × Qh such that




ah(uh, vh) + b(vh, ph) = (f h, vh),

vh ∈ Vh,



b(uh, qh)

= 0,

qh ∈ Qh.

(45)

42

The constraint (cid:82)
Ω phdx is not naturally imposed in the above system. To this end, we introduce
a Lagrange multiplier and consider the augmented variational formulation: Find ((uh, ph), λ) ∈
V g
h × Qh × R such that

ah(uh, vh) + b(vh, ph) = (f h, vh),

vh ∈ Vh,






(cid:90)

b(uh, qh) + λ

(cid:90)

µ

Ω

phdx

qhdx = 0,

qh ∈ Qh,

Ω

= 0, µ ∈ R.

Let φi, i = 1, · · · , N be the basis functions of Vh. Then

u =

N
(cid:88)

i=1

χi(u)φi =: φT χ(u).

Similarly, the basis functions of Qh are denote by ψl, l = 1, · · · , M , with

ph =

M
(cid:88)

l=1

plψl.

Plugging these expansions in (13) and taking vh = φj and qh = ψl, we obtain

N
(cid:80)
i=1
N
(cid:88)






i=1
M
(cid:88)

(cid:90)

l=1

Ω

ψldxpl

ah(φi, φj)χi +

b(φi, ψl)χi + λ

M
(cid:80)
l=1
(cid:90)

b(φj, ψl)pl = (f h, φj),

j = 1, · · · , N,

ψldx

= 0,

l = 1, · · · , M,

Ω

= 0.

Let

dl =

(cid:90)

Ω

ψldx, d = [d1, · · · , dM ]T .

The linear system can be written in matrix form as







A B 0
BT O d
0T dT

0







χ





=









p

λ









f





0

0

,

(46)

(47)

where

A = (ah(φj, φi)), B = (b(φj, ψl)),

f = ((f h, φj)).

We only consider the lowest order case k = 2. In this case, the third-type d.o.f.s vanish and

the boundary part corresponds to a tensor-product space. We arrange the d.o.f.s in the following

43

order:

χi(v) = v1(zi),

i = 1, · · · , Nv,

χNv+i(v) = v1(mi),

i = 1, · · · , Nv,

χ2∗Nv+i(v) = v2(zi),

i = 1, · · · , Nv,

χ3Nv+i(v) = v2(mi),

i = 1, · · · , Nv,

χ4Nv+1(v) =

χ4Nv+2(v) =

(cid:90)

K

(cid:90)

K

divvm2(x, y)dx, m2(x, y) =

divvm3(x, y)dx, m3(x, y) =

x − xK
hK
y − yK
hK

,

.

Denote the basis functions of Bk(∂K) by φ1, · · · , φNv ; φNv+1, · · · , φ2Nv . Then the tensor-

product space (Bk(∂K))2 has the basis functions:

φ1, · · · , φ2Nv , φ
1

, · · · , φ

2Nv

,

which correspond to the ﬁrst 4Nv d.o.f.s. For convenience, we denote these functions by φ1, φ2, · · · , φ4Nv .
The basis functions associated with the last two d.o.f.s are then denoted by ϕ1 = φ4Nv+1, ϕ2 =
φ4Nv+2.

In the following, we only provide the details of computing the elliptic projection.

7.2 Computation of the elliptic projection

7.2.1 Transition matrix

We rewrite the basis of Vk(K) in a compact form as

φT = (φ1, φ2, · · · , φNk

),

where Nk = 4Nv + 2 is the number of the d.o.f.s. The basis of (Pk(K))2 can be denote by

mT = (m1, m2, · · · , mNp) = (m1, · · · , m6, m1, · · · , m6).

Since (Pk(K))2 ⊂ Vk(K), one has mT = φT D, where D is referred to as the transition matrix
from (Pk(K))2 to Vk(K). Let

mT = [m1, m2, m3, m1, m2, m3] =: [mT , mT ],

φT = [φ1, · · · , φN , φ
1

, · · · , φ

N

, ϕ1, ϕ2] =: [φ

T

, φT , ϕ1, ϕ2].

Blocking the matrix D as D =

(cid:35)

(cid:34)

D1
D2

, one has

m = [mT , mT ] = [φ

= [φ

T

T

, φT , 0, 0]D + [0T , 0T , ϕ1, ϕ2]D
(cid:35)

(cid:34)

, φT , 0, 0]

+ [0T , 0T , ϕ1, ϕ2]

D1
O

(cid:34)

O

(cid:35)

D2

.

44

Let mT = φT D. One easily ﬁnds that

(cid:34)

D

D1 =

(cid:35)

,

D

D2 =

(cid:34)
χ4Nv+1(mT ) χ4Nv+1(mT )
χ4Nv+2(mT ) χ4Nv+2(mT )

(cid:35)

We ﬁrst provide some necessary information.

% ------- element information - - - - - - - - - -

index = elem { iel };

Nv = length ( index ) ;

xK = centroid ( iel ,1) ; yK = centroid ( iel ,2) ; hK = diameter ( iel ) ;

x = node ( index ,1) ; y = node ( index ,2) ;

v1 = 1: Nv ; v2 = [2: Nv ,1]; % loop index for vertices or edges

xe = ( x ( v1 ) + x ( v2 ) ) /2;

ye = ( y ( v1 ) + y ( v2 ) ) /2; % mid - edge points

Ne = [ y ( v2 ) -y ( v1 ) , x ( v1 ) -x ( v2 ) ]; % he * ne

nodeT = [ node ( index ,:) ; centroid ( iel ,:) ];
elemT = [( Nv +1) * ones ( Nv ,1) ,(1: Nv ) ' ,[2: Nv ,1] '];

% - - - - - - - - - - - - - - - scaled monomials - - - - - - - - - - - - - - - - -

m1 = @ (x , y ) 1+0* x ;

m2 = @ (x , y ) (x - xK ) ./ hK ;

m3 = @ (x , y ) (y - yK ) ./ hK ;

gradm1 = @ (x , y ) [0+0* x , 0+0* x ];

gradm2 = @ (x , y ) [1/ hK +0* x , 0+0* x ];

gradm3 = @ (x , y ) [0+0* x , 1/ hK +0* x ];

m4 = @ (x , y ) (x - xK ) .^2/ hK ^2;

gradm4 = @ (x , y ) [2*( x - xK ) ./ hK ^2 , 0+0* x ];

m5 = @ (x , y ) (x - xK ) .*( y - yK ) ./ hK ^2;

gradm5 = @ (x , y ) [( y - yK ) ./ hK ^2 , (x - xK ) ./ hK ^2];

m6 = @ (x , y ) (y - yK ) .^2./ hK ^2;

gradm6 = @ (x , y ) [0+0* x , 2*( y - yK ) ./ hK ^2];

m = @ (x , y ) [ m1 (x , y ) , m2 (x , y ) , m3 (x , y ) , m4 (x , y ) , m5 (x , y ) , m6 (x , y ) ];

Gradm = { gradm1 , gradm2 , gradm3 , gradm4 , gradm5 , gradm6 };

divmm = @ (x , y ) [0+0* x , 1/ hK +0* x , 0+0* x , 2*( x - xK ) ./ hK ^2 , (y - yK ) ./ hK ^2 , 0+0* x , ...

0+0* x , 0+0* x , 1/ hK +0* x , 0+0* x , (x - xK ) ./ hK ^2 , 2*( y - yK ) ./ hK ^2];

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

Then the transition matrix can be realized as

1

2

3

4

5

6

7

8

9

% -------- transition matrix - - - - - - - - - -

NdofBd = 2* Nv ; NdofA = 2* NdofBd +2;

divmm2 = @ (x , y ) divmm (x , y ) .* repmat ( m2 (x , y ) ,1 , Nmm ) ;

divmm3 = @ (x , y ) divmm (x , y ) .* repmat ( m3 (x , y ) ,1 , Nmm ) ;

D = zeros ( NdofA , Nmm ) ;

Dbd = [ m (x , y ) ; m ( xe , ye ) ];

D (1:4* Nv , :) = blkdiag ( Dbd , Dbd ) ;

D ( end -1 ,:) = integralTri ( divmm2 ,4 , nodeT , elemT ) ;

D ( end ,:) = integralTri ( divmm3 ,4 , nodeT , elemT ) ;

7.2.2 Elliptic projection matrices

The elliptic projection satisﬁes






where

For k = 2,

GΠK

∗ = B,
0 (mT )ΠK
P K

∗ = P K

0 (φT )

or

˜GΠK

∗ = ˜B,

G = aK(m, mT ), B = aK(m, φT ).

Bαi = aK(mα, φi) =

qαdivφidx +

(cid:90)

K
=: I1(α, i) + I2(α, i),

(cid:90)

∂K

(ν∇mαn − qαn) · φids

45

where

and

I1(α, i) =

(cid:90)

K

qαdivφidx,

I2(α, i) =

(cid:90)

∂K

(ν∇mαn − qαn) · φids,

ν∆mα = ∇qα + 0,

qα ∈ P1(K)/P0(K).

First consider I1. By deﬁnition, let qα = νhK(c2,αm2 + c3,αm3). Then

(cid:35)

(cid:34)

c2,α
c3,α

←−

(cid:34)

∆mT
0T
0T ∆mT

(cid:35)

.

The Kronecher’s property gives

I1(α, i) = νhK

= νhK

(cid:16)

(cid:16)

(cid:90)

c2,α

m2divφidx + c3,α

K

K
c2,αδi,(4Nv+1) + c3,αδi,(4Nv+2)

(cid:90)

(cid:17)

m3divφidx
(cid:17)

.

The computation of I1 reads

1

2

3

4

5

% --- first term ---

Lapm = [0 , 0 , 0 , 2/ hK ^2 , 0 , 2/ hK ^2];

B = zeros ( Nmm , NdofA ) ;
B (1: Nm, end -1) = pde . nu * hK * Lapm ;
B ( Nm +1:end, end) = pde . nu * hK * Lapm ;

For the second term I2, let (gα

1 , gα

2 )T = ν∇mαn − qαn, Then

I2(α, i) =

(cid:90)

∂K

gα
1 φ1,ids +

(cid:90)

∂K

gα
2 φ2,ids =: J1(α, i) + J2(α, i).

Let φ be the basis of Bk(∂K). One has


J1(α, :)T =

J2(α, :)T =








(gα
(gα

1 , φ)∂K
1 , 0)∂K
1 , ϕ1,1)∂K
1 , ϕ2,1)∂K

(gα
(gα










(gα
(gα

2 , 0)∂K
2 , φ)∂K
2 , ϕ1,2)∂K
2 , ϕ2,2)∂K

(gα
(gα



















=

=



















(gα

1 , φ)∂K
0

0

0

0

0

(gα

2 , φ)∂K
0



















,

,

1 , φ)∂K and (gα

where (gα
example, for (gα

1 , φ)∂K there exist three integrals on e:

2 , φ)∂K can be computed using the assembling technique for FEMs. For

Fi =

(cid:90)

e

gα
1 φids,

i = 1, 2, 3,

where e = [ae, me, be] is an edge with ae and be being the endpoints and me the midpoint. By the
Simpson’s formula,

F =









F1
F2
F3

=





he
6







gα
1 (ae)
gα
1 (be)
4gα
1 (me)



.





The above discussion can be realized as follows.

46

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

% --- second term ---

elem1 = [ v1 (:) , v2 (:) , v1 (:) + Nv ]; % elem2dof for [ ae , be , me ]

Gradmm = cell (2 , Nmm ) ;

Gradmm (1 ,1: Nm ) = Gradm ;
Gradmm (2 , Nm +1:end) = Gradm ;
for im = 1: Nm

Gradmm {1 , im + Nm } = @ (x , y ) [0+0* x , 0+0* x ];

Gradmm {2 , im } = @ (x , y ) [0+0* x , 0+0* x ];

end

qmm = cell (1 , Nmm ) ;

% q = nu * hK ( c2 * m2 + c3 * m3 )

c2 = [ Lapm , zeros (1 , Nm ) ];

c3 = [ zeros (1 , Nm ) , Lapm ];

for im = 1: Nmm

qmm { im } = @ (x , y ) pde . nu * hK *( c2 ( im ) * m2 (x , y ) + c3 ( im ) * m3 (x , y ) ) ;

end

for s = 1:2

id = (1: NdofBd ) + (s -1) * NdofBd ;

for im = 1: Nmm

pm = @ (x , y ) pde . nu * Gradmm {s , im }( x , y ) ;

qa = @ (x , y ) qmm { im }( x , y ) ;

F1 = 1/6*( sum ( pm ( x ( v1 ) ,y ( v1 ) ) .* Ne , 2) - qa ( x ( v1 ) ,y ( v1 ) ) .* Ne (: , s ) ) ;

F2 = 1/6*( sum ( pm ( x ( v2 ) ,y ( v2 ) ) .* Ne , 2) - qa ( x ( v2 ) ,y ( v2 ) ) .* Ne (: , s ) ) ;

F3 = 4/6*( sum ( pm ( xe , ye ) .* Ne , 2) - qa ( xe , ye ) .* Ne (: , s ) ) ;

B ( im , id ) = accumarray ( elem1 (:) , [ F1 ; F2 ; F3 ] , [ NdofBd , 1]) ;

end

end

We ﬁnally consider the implementation of the constraint. At ﬁrst glance the L2 projection

is not computable since there is no zero-order moment on K. In fact, the computability can be
obtained using the decomposition of polynomial spaces. Let φi = [φ1,i, φ1,i]T . Then

φ1,i = φi ·

(cid:35)

(cid:34)
1

0

, φ2,i = φi ·

(cid:35)

(cid:34)
0

1

.

(cid:34)

(cid:35)
1

0

(cid:35)

(cid:34)
0

1

= ∇pk−1 + g⊥

k−2,

pk−1 = hKm2,

g⊥
k−2 = 0,

= ∇qk−1 + g⊥

k−2,

qk−1 = hKm3,

g⊥
k−2 = 0,

It is easy to get

which yield

0 (φ1,i) = |K|−1
P K

0 (φ2,i) = |K|−1
P K

(cid:90)

K

(cid:90)

K

φi · ∇pk−1dx = |K|−1hK

φi · ∇qk−1dx = |K|−1hK

(cid:16)

(cid:16)

−

−

(cid:90)

K

(cid:90)

K

divφim2dx +

divφim3dx +

(cid:90)

∂K

(cid:90)

∂K

m2φi · nds

(cid:17)

,

m3φi · nds

(cid:17)

.

(48)

As you can see, their computation is similar to the previous one for Bα,i with α ﬁxed. The resulting
two row vectors will replace the ﬁrst and seventh rows of B.

1

2

3

4

% constraint

P0K = zeros (2 , NdofA ) ;
P0K (1, end -1) = -1; P0K (2, end) = -1;
m23 = { m2 , m3 };

47

5

6

7

8

9

10

11

12

13

14

15

16

for s = 1:2

mc = m23 { s };

F1 = 1/6*( mc ( x ( v1 ) ,y ( v1 ) ) .* Ne ) ;

% [ n1 , n2 ]

F2 = 1/6*( mc ( x ( v2 ) ,y ( v2 ) ) .* Ne ) ;

F3 = 4/6*( mc ( xe , ye ) .* Ne ) ;

F = [ F1 ; F2 ; F3 ];

P0K (s , 1: NdofBd ) = accumarray ( elem1 (:) , F (: ,1) , [ NdofBd 1]) ;

P0K (s , NdofBd +1:2* NdofBd ) = accumarray ( elem1 (:) , F (: ,2) , [ NdofBd 1]) ;

end

P0K = 1/ area ( iel ) * hK * P0K ;

% Bs , G , Gs

Bs = B ;

Bs ([1 ,7] , :) = P0K ;

Example 7.1. Let Ω = (0, 1)2. We choose the load term f in such a way that the analytical

solution is

u(x, y) =

(cid:34)

− 1
2 cos(x)2 cos(y) sin(y)
1
2 cos(y)2 cos(x) sin(x)

(cid:35)

,

p(x, y) = sin(x) − sin(y).

The results are displayed in Fig. 21 and Tab. 3, from which we observe the optimal rates of

convergence both for u and p.

Fig. 21. Convergence rates of the divergence free VEM for the Stokes problem

Tab. 3. The discrete errors for the Stokes problem

(cid:93)Dof

390

774

h

1.768e-01

(cid:107)u − uh(cid:107)
1.07945e-04

|u − uh|1
3.25802e-03

(cid:107)p − ph(cid:107)
5.66765e-03

1.250e-01

5.16780e-05

1.55844e-03

2.84772e-03

1534

8.839e-02

2.13132e-05

7.72427e-04

1.45175e-03

3042

6.250e-02

1.00841e-05

3.84674e-04

7.33126e-04

6090

4.419e-02

5.69480e-06

1.93534e-04

3.68775e-04

8 Adaptive virtual element methods

Due to the large ﬂexibility of the meshes, researchers have focused on the a posterior error

analysis of the VEMs and made some progress in recent years [18–20, 24, 29, 37].

48

101520log(1/h)10-610-510-410-310-2||u-uh||O (h2.17)||Du-Duh||O (h2.03)101520log(1/h)10-410-310-2||Du-Duh||O (h2.03)||p-ph||O (h1.97)We consider the adaptive VEMs for the Poisson equation. The computable error estimator is

taken from [20, 37], given as

where

with

and

η(uh) =

(cid:16) (cid:88)

η2
K(uh)

(cid:17)1/2

,

K∈Th

η2
K(uh) =

4
(cid:88)

i=1

η2
i,K(uh),

1,K = h2
η2

K(cid:107)f − ΠK

0 f (cid:107)2

0,K,

2,K = h2
η2

K(cid:107)ΠK

0 f (cid:107)2

0,K,

3,K = (cid:107)χ(uh − Π∇
η2

1 uh)(cid:107)2
l2,

η2
4,K =

1
2

(cid:88)

e⊂∂K

he(cid:107)[∂nΠ∇

1 uh](cid:107)2

0,e.

Standard adaptive algorithms based on the local mesh reﬁnement can be written as loops of

the form

SOLVE → ESTIMATE → MARK → REFINE.

Given an initial polygonal subdivision T0, to get Tk+1 from Tk we ﬁrst solve the VEM problem
under consideration to get the numerical solution uk on Tk. The error is then estimated by using
uk, Tk and the a posteriori error bound. The local error bound is used to mark a subset of elements
in Tk for reﬁnement. The marked polygons and possible more neighboring elements are reﬁned
in such a way that the subdivision meets certain conditions, for example, the resulting polygonal

mesh is still shape regular. In the implementation, it is usually time-consuming to write a mesh

reﬁnement function since we need to carefully design the rule for dividing the marked elements to

get a reﬁned mesh of high quality. We have present such an implementation of the mesh reﬁnement

for polygonal meshes in [52].

Consider the Poisson equation with Dirichlet boundary condition on the unit square. The

exact solution is given by

u(x, y) = xy(1 − x)(1 − y)exp (cid:0)−1000((x − 0.5)2 + (y − 0.117)2)(cid:1) .

We employ the VEM in the lowest order case and use the D¨orﬂer marking strategy with parameter

θ = 0.4 to select the subset of elements for reﬁnement. The initial mesh and the ﬁnal adapted

meshes after 20 and 30 reﬁnement steps are presented in Fig. 22 (a-c), respectively. The detail

of the last mesh is shown in Fig. 22 (d). Clearly, no small edges are observed. We also plot the

adaptive approximation in Fig. 23, which almost coincides with the exact solution. The full code

is available from mVEM package. The subroutine PoissonVEM indicator.m is used to compute

the local indicator and the test script is main Poisson avem.m. As shown in Fig. 24, we see the

adaptive strategy correctly reﬁnes the mesh in a neighborhood of the singular point and there is a
good level of agreement between the H 1 error and error estimator.

9 Variational inequalities

We now focus on the the virtual element method to solve a simpliﬁed friction problem, which

is a typical elliptic variational inequality of the second kind.

49

(a)

(b)

(c)

(d)

Fig. 22. The initial and the ﬁnal adapted meshes. (a) The initial mesh; (b) After 20 reﬁnement steps;

(c) After 30 reﬁnement steps; (d) The zoomed mesh in (c)

(a) Exact

(b) Numerical

Fig. 23. The exact and numerical solutions

50

0.20.40.60.810.10.20.30.40.50.60.70.80.910.20.40.60.810.10.20.30.40.50.60.70.80.910.20.40.60.810.10.20.30.40.50.60.70.80.910.480.490.50.510.520.1050.110.1150.120.1250.130.1350.140.1450.150.155Fig. 24. Convergence rates of the error |u − Π∇

1 uh|1 and the error estimator η(uh)

9.1 The simpliﬁed friction problem

Let Ω ⊂ R2 be a bounded domain with a Lipschitz boundary Γ = ∂Ω that is divided into two

parts ΓC and ΓD. The problem is





−∆u + αu = f

in Ω,

∂nu ≤ g,

u∂nu + g|u| = 0,

on ΓC,

(49)

u = 0 on

ΓD,

where α > 0 is a constant, f ∈ L2(Ω), g ∈ L2(ΓC), ΓC is the frictional boundary part and ΓD is
the Dirichlet boundary part.

Deﬁne

V = {v ∈ H 1(Ω) : v|ΓD = 0}.

The variational inequality is [48]: Find u ∈ V such that

a(u, v − u) + j(v) − j(u) ≥ (cid:96)(v − u),

v ∈ V,

(50)

where

a(u, v) =

(cid:90)

Ω

(∇u · ∇v + αuv)dx,

(cid:96)(v) =

(cid:90)

Ω

f vdx,

j(v) =

(cid:90)

ΓC

g|v|ds.

9.2 The VEM discretization

We consider the lowest-order virtual element space. The local space is taken as the enhanced

virtual element space W1(K) deﬁned in (23). Let Vh be the global space. The virtual element
method for solving the simpliﬁed friction problem is: Find uh ∈ Vh such that

ah(uh, vh − uh) + j(vh) − j(uh) ≥ (cid:96)h(vh − uh),

vh ∈ Vh,

(51)

where

h (v, w) = (∇Π∇
aK

1 v, ∇Π∇

1 w)K + α(Π0

1v, Π0

1w)K + SK(v − Π∇

1 v, w − Π∇

1 w),

SK(v, w) := (1 + αh2

K)χ(v) · χ(w),

(cid:96)h(vh) =

(f, Π0

0vh)K.

(cid:88)

K∈Th

51

20304050607080log(1/h)10-310-210-1 (uh)O (h1.26)|u-uh|1O (h1.20)By introducing a Lagrangian multiplier

λ ∈ Λ = {λ ∈ L∞(ΓC) : |λ| ≤ 1

a.e. on ΓC},

the inequality problem (50) can be rewritten as






(cid:90)

a(u, v) +

gλvds = (cid:96)(v),

v ∈ V,

λu = |u|

ΓC
a.e. on ΓC.

For this reason, the discrete problem (51) can be recast as






ah(uh, vh) +

(cid:90)

ΓC

gλhvhds = (cid:96)h(vh),

vh ∈ Vh,

λhuh = |uh| a.e. on ΓC,

where λh ∈ L∞(ΓC) and |λh| ≤ 1. Then the Uzawa algorithm for solving the above problem
is [50, 51]: given any λ(0)

h ∈ Λ, for n ≥ 1, ﬁnd u(n)

h by solving

and λ(n)

h

ah(u(n)

h , vh) = (cid:96)h(vh) −

(cid:90)

ΓC

gλ(n−1)
h

vhds

(52)

and

where PΛ(µ) = sup{−1, inf{1, µ}} and ρ is a constant parameter.

h = PΛ(λ(n−1)
λ(n)

h

+ ρgu(n)

h ),

9.3 Numerical example

Let Ω = (0, 1)2 and suppose that the frictional boundary condition is imposed on y = 0. The

function g can be simply chosen as supΓC
exact solution is u = (sin(x) − x sin(1)) sin(2πy).

|∂nu|. The right-hand function f is chosen such that the

h)(cid:107)l2 ≤ tol or n ≥ maxIt.

The Uzawa iteration stops when (cid:107)χ(un+1

h − un
the problem (52) is exactly the VEM discretization for the reaction-diﬀusion problems, with the
Neumann boundary data replaced by gλ(n−1)
. In addition, we only need to assemble the integral on
ΓC in each iteration. Because of this, we will not give the implementation details. We set tol = 10−8,
maxIt = 500 and ρ = 10. The results are shown in Figs. 25 and 26, from which we see that the
lowest-order VEM achieves the linear convergence order in the discrete H 1 norm, which is optimal

It is evident that

h

according to the a priori error estimate in [48]. The test script is main PoissonVEM VI Uzawa.m.

10 Three-dimensional problems

In this section we are concerned with the implementation of 3-D VEMs proposed in [15] for

the Poisson equation in the lowest-order case. Considering the length of the article, we omit the

details of the introduction to the function spaces.

52

Fig. 25. Numerical and exact solutions for the simpliﬁed friction problem (α = 104)

Fig. 26. Convergence rates of the VEM for the simpliﬁed friction problem (α = 104)

10.1 Virtual element methods for the 3-D Poisson equation

Let Ω ⊂ R3 be a polyhedral domain and let Γ denote a subset of its boundary consisting of

some faces. We consider the following model problem





−∆u = r

in Ω,

u = gD

on Γ,

∂nu = gN

on Γ(cid:48) = ∂Ω\Γ,

(53)

where r ∈ L2(Ω) and gN ∈ L2(Γ(cid:48)) are the applied load and Neumann boundary data, respectively,
and gD ∈ H 1/2(Γ) is the Dirichlet boundary data function.

In what follows, we use K to represent the generic polyhedral element with f ⊂ ∂K being its

generic face. The vertices of a face f are in a counterclockwise order when viewed from the inside.
The virtual element method proposed in [15] for (53) is to ﬁnd uh ∈ V k

Γ such that

ah(uh, vh) = (cid:96)h(vh),

vh ∈ V k
0 ,

where

ah(uh, vh) =

(cid:88)

K∈Th

aK
h (uh, vh),

(cid:96)h(vh) =

(cid:90)

Ω

rhvhdx +

(cid:90)

Γ(cid:48)

ghvhds.

The local bilinear form is split into two parts:

h (v, w) = (∇Π∇
aK

1 v, ∇Π∇

1 w)K + hKSK(v − Π∇

1 v, w − Π∇

1 w),

53

6810121416182022log(1/h)10-410-310-210-1||u-uh||O (h2.34)|u-hh|1O (h1.10)where Π∇

1 : V 1(K) → P1(K) is the elliptic projector and SK is the stabilization term given as

SK(v, w) =

N K
(cid:88)

i=1

χi(v)χi(w),

where χi(v) = v(pi) and pi is the i-th vertex of K for i = 1, 2, · · · , NK. The local linear form of
the right-hand side will be approximated as

(cid:96)K
h (vh) =

(cid:90)

K

rΠ∇

1 vhdx +

(cid:88)

f ⊂Γ(cid:48)∩∂K

(cid:90)

f

gN Π∇

1,f vhds,

where Π∇

1,f : V 1(f ) → P1(f ) is the elliptic projector deﬁned on the face f .

For the detailed introduction of the virtual element spaces, please refer to Section 2 in [15]. In

this paper, we only consider the lowest-order case, but note that the hidden ideas can be directly

generalized to higher order cases.

10.2 Data structure and test script

We ﬁrst discuss the data structure to represent polyhedral meshes. In the implementation,

the mesh is represented by node3 and elem3. The N × 3 matrix node3 stores the coordinates of

all vertices in the mesh. elem3 is a cell array with each entry storing the face connectivity, for

example, the ﬁrst entry elemf = elem3{1} for the mesh given in Fig. 27(a) is shown in Fig. 27(b),

which is still represented by a cell array since the faces may have diﬀerent numbers of vertices.

(a) Polyhedral mesh

(b) Representation of the ﬁrst element

Fig. 27. Polyhedral mesh of a cube

All faces including the repeated internal ones can be gathered in a cell array as

allFace = vertcat(elem3{:}); %cell

By padding the vacancies and using the sort and unique functions to rows, we obtain the face

set face. The cell array elem2face then establishes the map of local index of faces in each

polyhedron to its global index in face set face. The above structural information is summarized in

the subroutine auxstructure3.m. The geometric quantities such as the diameter diameter3, the

54

barycenter centroid3 and the volume volume are computed by auxgeometry3.m. We remark

that these two subroutines may be needed to add more information when dealing with higher order

VEMs.

The test script is main PoissonVEM3.m listed as follows. In the for loop, we ﬁrst load the

pre-deﬁned mesh data, which immediately returns the matrix node3 and the cell array elem3 to

the MATLAB workspace. Then we set up the Neumann boundary conditions to get the structural

information of the boundary faces. The subroutine PoissonVEM3.m is the function ﬁle containing

all source code to implement the 3-D VEM. When obtaining the numerical solutions, we calculate
the discrete L2 errors and H 1 errors deﬁned as

ErrL2 =

(cid:88)

K∈Th

(cid:107)u − Π∇

1 uh(cid:107)0,K, ErrH1 =

(cid:88)

K∈Th

|u − Π∇

1 uh|1,K

by using respectively the subroutine getError3.m. The procedure is completed by verifying the

rate of convergence through showrateErr.m.

1 % % Parameters

2 maxIt = 5;

3 h = zeros ( maxIt ,1) ;

N = zeros ( maxIt ,1) ;

4 ErrL2 = zeros ( maxIt ,1) ;

ErrH1 = zeros ( maxIt ,1) ;

5

6 % % PDE data

7 pde = Poisson3data () ;
8 bdNeumann = 'x ==0 '; % string for Neumann

9

10 % % Virtual element method

11 for k = 1: maxIt

% load mesh
fprintf ( ' Mesh % d : \ n ' , k ) ;
load ( [ ' SimpleMesh3data ' , num2str ( k ) , '. mat '] ) ; % polyhedral mesh
% load ( [ ' mesh3data ' , num2str ( k ) , '. mat '] ) ; % polyhedral mesh
% [ node3 ,¬, elem3 ] = cubemesh ([0 1 0 1 0 1] , 1/(2* k ) ) ; % tetrahedral mesh

% get boundary information

bdStruct = setboundary3 ( node3 , elem3 , bdNeumann ) ;

% solve

[ uh , info ] = PoissonVEM3 ( node3 , elem3 , pde , bdStruct ) ;

% record

N ( k ) = length ( uh ) ;

h ( k ) = (1/ size ( elem3 ,1) ) ^(1/3) ;

% compute errors in discrete L2 , H1 and energy norms

kOrder = 1;

[ ErrH1 ( k ) , ErrL2 ( k ) ] = getError3 ( node3 , elem3 , uh , info , pde , kOrder ) ;

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26 end

27

28 % % Plot convergence rates and display error table

29 figure , showrateErr (h , ErrL2 , ErrH1 ) ;

30
31 fprintf ( '\ n ') ;
32 disp ( ' Table : Error ')
33 colname = { '# Dof ' , 'h ' , ' || u - u_h || ' , '|u - u_h | _1 ' };
34 disptable ( colname ,N ,[] , h , ' %0.3 e ' , ErrL2 , ' %0.5 e ' , ErrH1 , ' %0.5 e ') ;

In the following subsections, we shall go into the details of the implementation of the 3-D VEM

in PoissonVEM3.m.

55

10.3 Elliptic projection on polygonal faces

Let f be a face of K or a polygon embedded in R3. In the VEM computing, we have to get all
elliptic projections Π∇
f ready in advance, where φf is the nodal basis of the enhanced virtual
element space V 1(f ) (see Subsection 2.3 in [15]). To this end, it may be necessary to establish local

1,f φT

coordinates (s, t) on the face f .

Fig. 28. Local coordinate system of a face or polygon embedded in R3

As shown in Fig. 28, the boundary of the polygon is oriented in a counterclockwise order as

a1, · · · , an. Let e = a1a2 be the ﬁrst edge, and ne and te be the normal vector and tangential
vector, respectively. Then we can deﬁne a local coordinate system with a1 being the original point
by using these two vectors. Let ne = (n1, n2, n3) and te = (t1, t2, t3). For any a = (x, y, z) ∈ f , its
local coordinate (s, t) is related by

−→
Oa = s · ne + t · te,

or

(x − x1, y − y1, z − z1) = s · (n1, n2, n3) + t · (t1, t2, t3),

which gives

(s, t) = (x − x1, y − y1, z − z1)

(cid:34)

n1 n2 n3
t2
t2
t1

(cid:35)−1

,

with the inverse understood in the least squares sense. When converting to the local coordinate

system, we can compute all the matrices of elliptic projection in the same way for the Poisson

equation in two-dimensional cases. For completeness, we brieﬂy recall the implementation.

In

what follows, we use the subscript “f ” to indicate the locally deﬁned symbols.
f = [φf,1, · · · , φf,n] be the basis functions of V 1(f ) and mT

Let φT

f = [mf,1, mf,2, mf,3] the scaled

monomials on f given as

mf,1 = 1, mf,2 =

s − sf
hf

, mf,3 =

t − tf
hf

,

where (sf , tf ) and hf are the barycenter and the diameter of f , respectively. The vector form of
the elliptic projector Π∇

1,f can be represented as






where

(∇f mf , ∇f Π∇
1,f φT

1,f φT
f ) = P0(φT

P0(Π∇

f ).

f )f = (∇f mf , ∇f φT

f )f ,

(54)

P0(v) =

v(ai).

1
n

n
(cid:88)

i=1

56

Since P1(f ) ⊂ V 1(f ), we can write

mT

f = φT

f Df ,

Df = (Diα), Diα = χf,i(mf,α),

where χf,i is the i-th d.o.f associated with ai, and Df is referred to as the transition matrix. We
further introduce the following expansions

Π∇

1,f φT

f = φT

f Π∇

1,f ,

One easily ﬁnds that

Π∇

1,f φT

f = mT

f Π∇

1∗,f .

and (54) can be rewritten in matrix form as

Π∇

1,f = Df Π∇

1∗,f ,






where

Gf Π∇

P0(mT

1∗,f = Bf ,
f )Π∇

1∗,f = P0(φT
f )

,

or denoted by

˜Gf Π∇

1∗,f = ˜Bf ,

Gf = (∇f mf , ∇f mT

f )f , Bf = (∇f mf , ∇f φT

f )f .

Note that the following consistency relation holds

Gf = Bf Df ,

˜Gf = ˜Bf Df .

Let face be the face set with internal faces repeated once. Then using the local coordinates
f as in 2-D cases. It is not recommended to carry

we are able to derive all elliptic projections Π∇

1,f φT

out the calculation element by element in view of the repeated cost for the internal faces.

The above discussion is summarized in a subroutine with input and output as

Pifs = faceEllipticProjection(P),

where P is the coordinates of the face f and Pifs is the matrix representation Π∇
the basis mT

f . One can derive all matrices by looping over the face set face:

1∗,f of Π∇

1,f φT

f in

1 % % Derive elliptic projections of all faces

2 faceProj = cell ( NF ,1) ;

3 for s = 1: NF

% Pifs

faces = face { s };

P = node3 ( faces ,:) ;

Pifs = f a c e E l l i p t i c P r o j e c t i o n ( P ) ;

% sort the columns

[¬, idx ] = sort ( faces ) ;

faceProj { s } = Pifs (: , idx ) ;

4

5

6

7

8

9

10 end

Note that in the last step we sort the columns of Π∇

1∗,f in ascending order according to the numbers
of the vertices. In this way we can easily ﬁnd the correct correspondence on each element (see Lines

32-35 in the code of the next subsection).

The face integral is then given by

(cid:90)

f

Π∇

1,f φT

f dσ =

(cid:90)

f

mT

f dσΠ∇

1∗,f = (|f |, 0, 0)Π∇

1∗,f ,

(55)

where |f | is the area of f and the deﬁnition of the barycenter is used.

57

10.4 Elliptic projection on polyhedral elements

The 3-D scaled monomials mT = [m1, m2, m3, m4] are

m1 = 1, m2 =

x − xK
hK

, m3 =

y − yK
hK

, m4 =

z − zK
hK

,

where (xK, yK, zK) is the centroid of K and hK is the diameter, and the geometric quantities
are computed by the subroutine auxgeometry3.m. Similar to the 2-D case, we have the symbols
D, G, ˜G, B and ˜B. For example, the transition matrix is given by

D = (Diα), Diα = χi(mα) = mα(pi).

The most involved step is to compute the matrix

(cid:90)

B =

∇m · ∇φT dx = −

(cid:90)

K

∆m · φT dx +

(cid:90)

(cid:88)

f ⊂∂K

f

(∇m · nf )φT dσ

K

(cid:90)

(cid:88)

f ⊂∂K

f

=

(∇m · nf )φT dσ,

where φT = [φ1, φ2, · · · , φNK ] are the basis functions with φi associated with the vertex pi of K.
According to the deﬁnition of V 1(f ), one has

(cid:90)

f

(∇m · nf )φT dσ = (∇m · nf )

(cid:90)

f

φT dσ = (∇m · nf )

(cid:90)

f

Π∇

1,f φT dσ,

and the last term is available from (55). Obviously, for the vertex pi away from the face f there
holds Π∇
1,f φi = 0. In the following code, indexEdge gives the row index in the face set face for

each face of elemf, and iel is the index for looping over the elements.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

% ------- element information --- -- -- -

% faces

elemf = elem3 { iel };

indexFace = elem2face { iel };

% global index of vertices and local index of elemf

[¬, index3 ,¬, elemfLocal ] = f ace Tria n gu l a t i o n ( elemf ) ;

% centroid and diameter

Nv = length ( index3 ) ;

Ndof = Nv ;

V = node3 ( index3 ,:) ;

xK = centroid3 ( iel ,1) ; yK = centroid3 ( iel ,2) ; zK = centroid3 ( iel ,3) ;

hK = diameter3 ( iel ) ;

x = V (: ,1) ;

y = V (: ,2) ;

z = V (: ,3) ;

% ------- scaled monomials - - - - - - - - - -

m1 = @ (x ,y , z ) 1+0* x ;

m2 = @ (x ,y , z ) (x - xK ) / hK ;

m3 = @ (x ,y , z ) (y - yK ) / hK ;

m4 = @ (x ,y , z ) (z - zK ) / hK ;

m = @ (x ,y , z ) [ m1 (x ,y , z ) , m2 (x ,y , z ) , m3 (x ,y , z ) , m4 (x ,y , z ) ]; % m1 , m2 , m3 , m4

mc = { m1 , m2 , m3 , m4 };

gradmMat = [0 0 0; 1/ hK 0 0; 0 1/ hK 0; 0 0 1/ hK ];

% -------- transition matrix - - - - - - - - - -

D = m (x ,y , z ) ;

% - - - - - - - - - - - elliptic projection - - - - - - - - - - - - -

58

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

B = zeros (4 , Ndof ) ;

for s = 1: size ( elemf ,1)

% --- information of current face

% vertices of face

faces = elemf { s };

P = node3 ( faces ,:) ;

% elliptic projection on the face

idFace = indexFace ( s ) ;

Pifs = faceProj { idFace }; % the order may be not correct

[¬,¬, idx ] = unique ( faces ) ;

Pifs = Pifs (: , idx ) ;

% normal vector

e1 = P (2 ,:) -P (1 ,:) ;

en = P (1 ,:) -P ( end ,:) ;

nf = cross ( e1 , en ) ; nf = nf ./ norm ( nf ) ;

% area

areaf = polyarea3 ( P ) ;

% --- integral of Pifs

intFace = [ areaf ,0 ,0]* Pifs ;

% local

intProj = zeros (1 , Ndof ) ;

% global adjustment

faceLocal = elemfLocal { s };

intProj ( faceLocal ) = intFace ;

% add grad ( m ) * nf

Bf = dot ( gradmMat , repmat ( nf ,4 ,1) , 2) * intProj ;

B = B + Bf ;

end

% constraint

Bs = B ;

Bs (1 ,:) = 1/ Ndof ;

% consistency relation

G = B * D ;

Gs = Bs * D ;

10.5 Computation of the right hand side and assembly of the linear system

The right-hand side is approximated as

FK =

(cid:90)

K

f Π∇

1 φdx = (Π∇

1∗)T

(cid:90)

K

f mdx,

1 is the elliptic projector on the element K and Π∇

1∗ is the matrix representation in the

where Π∇
basis mT . The integral (cid:82)

K f mdx can be approximated by

(cid:90)

K

f mdx = |K|f (xK)m(xK) = |K|f (xK)[1, 0, 0, 0]T , xK = (xK, yK, zK).

One can also divide the element K as a union of some tetrahedrons and compute the integral using

the Gaussian rule. Please refer to the subroutine integralPolyhedron.m for illustration.

One easily ﬁnds that the stiﬀness matrix for the bilinear form is

AK = (Π∇

1∗)T GΠ∇

1∗ + hK(I − Π∇

1 )T (I − Π∇

1 ).

We compute the elliptic projections in the previous section and provide the assembly index element

by element. Then the linear system can be assembled using the MATLAB function sparse as

follows.

1 for iel = 1: NT

2

3

...

59

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

% - - -- -- - -- local stiffness matrix - - -- - - - - -

Pis = Gs \ Bs ;

Pi

= D * Pis ;

I = eye ( size ( Pi ) ) ;

AK

= Pis '* G * Pis + hK *( I - Pi ) '*(I - Pi ) ;

AK = reshape ( AK ,1 ,[]) ;

% straighten

% - - -- -- - -- load vector - - - - - - - - - - -
% fK = Pis '*[ pde . f ( centroid3 ( iel ,:) ) * volume ( iel ) ;0;0;0];
fun = @ (x ,y , z ) repmat ( pde . f ([ x ,y , z ]) ,1 ,4) .* m (x ,y , z ) ;

fK = in te g ra lP o ly h ed ro n ( fun ,3 , node3 , elemf ) ;
fK = Pis '* fK (:) ;

% - - -- -- - -- assembly index for ellptic projection - - - - - - - - - - -

indexDof = index3 ;

ii ( ia +1: ia + Ndof ^2) = reshape ( repmat ( indexDof , Ndof , 1) , [] , 1) ;

jj ( ia +1: ia + Ndof ^2) = repmat ( indexDof (:) , Ndof , 1) ;

ss ( ia +1: ia + Ndof ^2) = AK (:) ;

ia = ia + Ndof ^2;

% - -- - -- - -- assembly index for right hand side - - - - - - - - - - -

elemb ( ib +1: ib + Ndof ) = indexDof (:) ;

Fb ( ib +1: ib + Ndof ) = fK (:) ;

ib = ib + Ndof ;

% - -- - -- - -- matrix for L2 and H1 error evaluation

- - -- - -- --

Ph { iel } = Pis ;

elem2dof { iel } = indexDof ;

31 end

32 kk = sparse ( ii , jj , ss ,N , N ) ;

33 ff = accumarray ( elemb , Fb ,[ N 1]) ;

Note that we have stored the matrix representation Π∇

1∗ and the assembly index elem2dof in

the M-ﬁle so as to compute the discrete L2 and H 1 errors.

10.6 Applying the boundary conditions

We ﬁrst consider the Neumann boundary conditions. Let f be a boundary face with n vertices.

The local load vector is

Ff =

(cid:90)

f

gN Π∇

1,f φf dσ = (Π∇

1∗,f )T

(cid:90)

f

gN mf dσ,

where gN = ∂nf u = ∇u · nf . For simplicity, we provide the gradient gN = ∇u in the PDE
data instead and compute the true gN in the M-ﬁle. Note that the above integral can be trans-
formed to a 2-D problem by using the local coordinate system as done in the following code,

where localPolygon3.m realizes the transformation and returns some useful information, and

integralPolygon.m calculates the integral on a 2-D polygon.

1 % % Assemble Neumann boundary conditions

2 bdFaceN = bdStruct . bdFaceN ;

bdFaceIdxN = bdStruct . bdFaceIdxN ;

3 if ¬isempty ( bdFaceN )

4

5

6

7

Du = pde . Du ;
faceLen = cellfun ( ' length ' , bdFaceN ) ;
nnz = sum ( faceLen ) ;

elemb = zeros ( nnz ,1) ; FN = zeros ( nnz ,1) ;

60

ib = 0;

for s = 1: size ( bdFaceN ,1)

% vertices of face

faces = bdFaceN { s };

nv = length ( faces ) ;

P = node3 ( faces ,:) ;

% elliptic projection on the face

idFace = bdFaceIdxN ( s ) ;

Pifs = faceProj { idFace }; % the order may be not correct

[¬, idx ] = sort ( faces ) ;

Pifs = Pifs (: , idx ) ;

% 3 - D polygon -> 2 - D polygon

poly = localPolygon3 ( P ) ;

nodef = poly . nodef ;

% local coordinates

nf = poly . nf ;

% outer normal vector of face

centroidf = poly . centroidf ;

sc = centroidf (1) ; tc = centroidf (2) ;

hf = poly . diameterf ;

Coord = poly . Coord ; % (s , t ) ---> (x ,y , z )

% g_N

g_N = @ (s , t ) dot ( Du ( Coord (s , t ) ) , nf ) ;

fun = @ (s , t ) g_N (s , t ) *[1+0* s , (s - sc ) / hf , (t - tc ) / hf ];

Ff = integralPolygon ( fun ,3 , nodef ) ;
Ff = Pifs '* Ff (:) ;
% assembly index

elemb ( ib +1: ib + nv ) = faces (:) ;

FN ( ib +1: ib + nv ) = Ff (:) ;

ib = ib + nv ;

end

ff = ff + accumarray ( elemb (:) , FN (:) ,[ N 1]) ;

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37 end

The Dirichlet boundary conditions are easy to handle. The code is given as follows.

1 % % Apply Dirichlet boundary conditions

2 g_D = pde . g_D ;

bdNodeIdxD = bdStruct . bdNodeIdxD ;

3 isBdNode = false (N ,1) ; isBdNode ( bdNodeIdxD ) = true ;

4 bdDof = ( isBdNode ) ; freeDof = (¬isBdNode ) ;

5 nodeD = node3 ( bdDof ,:) ;

6 u = zeros (N ,1) ; uD = g_D ( nodeD ) ; u ( bdDof ) = uD (:) ;

7 ff = ff - kk * u ;

In the above codes, bdStruct stores all necessary information of boundary faces. We ﬁnally

derive the linear system kk*uh = ff, where kk is the resulting coeﬃcient matrix and ff is the
right-hand side. For small scale linear system, we directly solve it using the backslash command in

MATLAB, while for large systems the algebraic multigrid method is used instead.

1 % % Set solver
2 solver = ' amg ';
3 if N < 2 e3 , solver = ' direct '; end
4 % solve

5 switch solver

case ' direct '

u ( freeDof ) = kk ( freeDof , freeDof ) \ ff ( freeDof ) ;

case ' amg '

option . solver = ' CG ';
u ( freeDof ) = amg ( kk ( freeDof , freeDof ) , ff ( freeDof ) , option ) ;

6

7

8

9

10

11 end

61

Here, the subroutine amg.m can be found in iFEM — a MATLAB software package for the ﬁnite

element methods [26].

The complete M-ﬁle is PoissonVEM3.m. The overall structure of a virtual element method

implementation will be much the same as for a standard ﬁnite element method, as outlined in

Algorithm 2.

Algorithm 2 An overall structure of the implementation of a 3-D virtual element method
Input: Mesh data and PDE data

1. Get auxiliary data of the mesh, including some data structures and geometric quantities;

2. Derive elliptic projections of all faces;

3. Compute and assemble the linear system by looping over the elements;

4. Assemble Neumann boundary conditions and apply Dirichlet boundary conditions;

5. Set solver and store information for computing errors.

Output: The numerical DoFs

10.7 Numerical examples

It should be pointed out that all examples in this subsection are implemented in MATLAB
R2019b. The domain Ω is always taken as the unit cube (0, 1)3 with the Neumann boundary

condition imposed on x = 0. The implementation can be adapted to the reaction-diﬀusion equation

−∆u + αu = r with the details omitted in this article, where α is a nonnegative constant.

(a) Tetrahedral mesh

(b) Structured mesh

(c) CVT mesh

Fig. 29. Three types of discretizations

We solve the problem on three diﬀerent kinds of meshes. One is the uniform triangulation

shown in Fig. 29(a) and the others are the polyhedral meshes displayed in Fig. 29(b) and Fig. 29(c).

The structured polyhedral mesh in Fig. 29(b) is formed by translating a two-dimensional polygonal

mesh along the z-axis and connecting the corresponding vertices, hence all sides are quadrilaterals.

The CVT meshes refer to the Centroidal Voronoi Tessellations, which are obtained from a set of

seeds that coincide with barycenters of the resulting Voronoi cells. We generate such meshes via a

62

standard Lloyd algorithm by extending the idea in the MATLAB toolbox - PolyMesher introduced

in [45] to a cuboid.

Example 10.1. Let α = 1. The right-hand side f and the boundary conditions are chosen in such

a way that the exact solution is

u(x, y, z) = sin(2xy) cos(z).

The results are displayed in Fig. 30, from which we observe that the optimal rates of conver-
gence are achieved for all the three types of discretizations in the H 1 and L2 norms. Note that the

uniform triangulation is generated by cubemesh.m in iFEM.

(a) Tetrahedral mesh

(b) Structured mesh

(c) CVT mesh

Fig. 30. Convergence rates in L2 and H 1 norms for Example 10.1

Example 10.2. In this example, the exact solution is chosen as

u(x, y, z) = sin(πx) cos(πy) cos(πz).

(a) Tetrahedral mesh

(b) Structured mesh

Fig. 31. Convergence rates in L2 and H 1 norms for Example 10.2

We still consider the problem with the Neumann boundary condition imposed on x = 0

and repeat the numerical simulation in Example 10.1. The uniform triangulation is generated by

cubemesh.m and further reﬁned by uniformrefine3.m in iFEM. By default, the initial mesh

before reﬁning has mesh size h = 1. We display the rate of convergence and the discrete errors in

63

510152025log(1/h)10-310-210-1100||u-uh||O (h1.95)|u-hh|1O (h0.95)46810121416log(1/h)10-310-210-1||u-uh||O (h2.00)|u-hh|1O (h1.01)33.544.555.56log(1/h)10-210-1||u-uh||O (h1.93)|u-hh|1O (h0.97)10152025log(1/h)10-310-210-1100||u-uh||O (h1.87)|u-hh|1O (h0.96)44.555.566.577.5log(1/h)10-210-1100||u-uh||O (h1.81)|u-hh|1O (h0.99)Tab. 4. Discrete L2 and H 1 errors of Example 10.2 for polyhedral meshes

N

170

504

h

ErrL2

ErrH1

2.500e-01

6.32804e-02

7.63490e-01

1.647e-01

3.09424e-02

5.18111e-01

1024

1.307e-01

1.94670e-02

4.00026e-01

Fig. 32. Convergence rates in L2 and H 1 norms of Example 10.2 for the triangulation with smaller
mesh sizes

Fig. 31 and Tab. 4, respectively. It is evident that the code gives satisfactory accuracy and the
optimal rate of convergence is achieved for the H 1 norm. However, the order of the error in the
discrete L2 norm is not close to 2. In fact, this phenomenon is also observed for the classical linear

ﬁnite element methods under the same conditions. The reason lies in the coarse mesh. To get the

optimal convergence rate, one can run the code on a sequence of meshes with much smaller sizes.

For instance, Fig. 32 shows the result for the triangulation with initial size 0.25, in which case the

optimal rates of convergence are obtained for both norms. It should be pointed out that the linear

virtual element method on a triangulation is exactly the standard ﬁnite element method since in

this case the virtual element space happens to be the set of polynomials of degree k ≤ 1. Compared

to the vectorized code in iFEM for the ﬁnite element methods, the current implementation is less

eﬃcient due to the large for loop. For example, three uniform reﬁnements of the above initial

triangulation will yield a mesh of 196608 triangular elements, and hence 196608 loops over the

elements.

11 Concluding remarks

In this paper, a MATLAB software package for the virtual element method was presented

for various typical problems. The usage of the library, named mVEM, was demonstrated through

several examples. Possible extensions of this library that are of interest include time-dependent

problems, adaptive mixed VEMs, three-dimensional linear elasticity, polyhedral mesh generator,

and nonlinear solid mechanics. Various applications such as the Cahn-Hilliard problem, Stokes-

Darcy problem and Navier-Stokes are also very appealing.

64

152025303540455055log(1/h)10-310-210-1100||u-uh||O (h1.96)|u-hh|1O (h0.99)For three-dimensional problems, the current code can be further vectorized to achieve compara-

ble performance in MATLAB with respect to compiled languages, where the most time-consuming

part lies in the evaluation of the large number of face integrals and element integrals, for example,
the elementwise computation of the L2 projection matrices for the reaction-diﬀusion problems. To

spare the computational cost, one may divide the polyhedral element as a union of some tetrahe-

drons and compute the integrals on those elements with the same number of tetrahedrons. Such

a procedure can be vectorized in MATLAB with an additional eﬀort of the code design. In the

current version, we still do the elementwise loop as in [44] to make the code more transparent.

mVEM is free and open source software.

References

[1] D. Adak and S. Natarajan. Virtual element method for semilinear sine-Gordon equation over

polygonal mesh using product approximation technique. Math. Comput. Simulation, 172:224–

243, 2020.

[2] B. Ahmad, A. Alsaedi, F. Brezzi, L. D. Marini, and A. Russo. Equivalent projectors for virtual

element methods. Comput. Math. Appl., 66(3):376–391, 2013.

[3] P. F. Antonietti, G. Manzini, and M. Verani. The fully nonconforming virtual element method

for biharmonic problems. Math. Models Methods Appl. Sci., 28(2):387–407, 2018.

[4] E. Artioli, L. Beir˜ao da Veiga, C. Lovadina, and E. Sacco. Arbitrary order 2D virtual elements

for polygonal meshes: part I, elastic problem. Comput. Mech., 60(3):355–377, 2017.

[5] E. Artioli, L. Beir˜ao da Veiga, C. Lovadina, and E. Sacco. Arbitrary order 2D virtual elements

for polygonal meshes: part II, inelastic problem. Comput. Mech., 60(4):643–657, 2017.

[6] B. Ayuso de Dios, K. Lipnikov, and G. Manzini. The nonconforming virtual element method.

ESAIM Math. Model. Numer. Anal., 50(3):879–904, 2016.

[7] L. Beir˜ao da Veiga, F. Brezzi, A. Cangiani, G. Manzini, L. D. Marini, and A. Russo. Basic

principles of virtual element methods. Math. Models Meth. Appl. Sci., 23(1):199–214, 2013.

[8] L. Beir˜ao da Veiga, F. Brezzi, A. Cangiani, G. Manzini, L. D. Marini, and A. Russo. Basic

principles of mixed virtual element methods. ESAIM Math. Model. Numer. Anal., 48(4):1227–

1240, 2014.

[9] L. Beir˜ao da Veiga, F. Brezzi, F. Dassi, L. D. Marini, and A. Russo. Serendipity virtual ele-

ments for general elliptic equations in three dimensions. Chinese Ann. Math. Ser. B, 39(2):315–

334, 2018.

[10] L. Beir˜ao da Veiga, F. Brezzi, and L. D. Marini. Virtual elements for linear elasticity problems.

SIAM J. Numer. Anal., 51(2):794–812, 2013.

65

[11] L. Beir˜ao da Veiga, F. Brezzi, L. D. Marini, and A. Russo. The hitchhiker’s guide to the

virtual element method. Math. Models Meth. Appl. Sci., 24(8):1541–1573, 2014.

[12] L. Beir˜ao da Veiga, F. Brezzi, L. D. Marini, and A. Russo. Serendipity nodal VEM spaces.

Comput. & Fluids, 141:2–12, 2016.

[13] L. Beir˜ao da Veiga, F. Brezzi, L. D. Marini, and A. Russo. Virtual element implementation

for general elliptic equations.

In Building bridges: connections and challenges in modern

approaches to numerical partial diﬀerential equations, volume 114 of Lect. Notes Comput. Sci.

Eng., pages 39–71. Springer, [Cham], 2016.

[14] L. Beir˜ao da Veiga, F. Brezzi, L. D. Marini, and A. Russo. Virtual element method for

general second-order elliptic problems on polygonal meshes. Math. Models Methods Appl. Sci.,

26(4):729–750, 2016.

[15] L. Beir˜ao da Veiga, F. Dassi, and A. Russo. High-order virtual element method on polyhedral

meshes. Comput. Math. Appl., 74(5):1110–1122, 2017.

[16] L. Beir˜ao Da Veiga, F. Dassi, and G. Vacca. The Stokes complex for virtual elements in three

dimensions. Math. Models Methods Appl. Sci., 30(3):477–512, 2020.

[17] L. Beir˜ao da Veiga, C. Lovadina, and G. Vacca. Divergence free virtual elements for the Stokes

problem on polygonal meshes. ESAIM Math. Model. Numer. Anal., 51(2):509–535, 2017.

[18] L. Beir˜ao da Veiga and G. Manzini. Residual a posteriori error estimation for the virtual

element method for elliptic problems. ESAIM Math. Model. Numer. Anal., 49(2):577–599,

2015.

[19] L. Beir˜ao da Veiga, G. Manzini, and L. Mascotto. A posteriori error estimation and adaptivity

in hp virtual elements. Numer. Math., 143(1):139–175, 2019.

[20] S. Berrone and A. Borio. A residual a posteriori error estimate for the virtual element method.

Math. Models Methods Appl. Sci., 27(8):1423–1458, 2017.

[21] S. C. Brenner and L. R. Scott. The Mathematical Theory of Finite Element Methods. Springer,

New York, 3rd edition, 2008.

[22] F. Brezzi, R. S. Falk, and L. D. Marini. Basic principles of mixed virtual element methods.

ESAIM Math. Model. Numer. Anal., 48(4):1227–1240, 2014.

[23] F. Brezzi and L. D. Marini. Virtual element methods for plate bending problems. Comput.

Methods Appl. Mech. Engrg., 253:455–462, 2013.

[24] A. Cangiani, E. H. Georgoulis, T. Pryer, and O. J. Sutton. A posteriori error estimates for

the virtual element method. Numer. Math., 137(4):857–893, 2017.

[25] A. Cangiani, G. Manzini, and O. J. Sutton. Conforming and nonconforming virtual element

methods for elliptic problems. IMA J. Numer. Anal., 37(3):1317–1354, 2017.

66

[26] L. Chen. iFEM: an integrated ﬁnite element method package in MATLAB. Technical report,

University of California at Irvine, 2009.

[27] L. Chen and X. Huang. Nonconforming virtual element method for 2m-th order partial dif-

ferential equations in Rn. Math. Comput., 89(324):1711–1744, 2020.

[28] H. Chi, L. Beir˜ao da Veiga, and G. H. Paulino. Some basic formulations of the virtual element

method (VEM) for ﬁnite deformations. Comput. Methods Appl. Mech. Engrg., 318:148–192,

2017.

[29] H. Chi, L. Beir˜ao da Veiga, and G. H. Paulino. A simple and eﬀective gradient recovery scheme

and a posteriori error estimator for the virtual element method (vem). Comput. Methods Appl.

Mech. Engrg., 347:21–58, 2019.

[30] C. Chinosi and L. D. Marini. Virtual element method for fourth order problems: L2-estimates.

Comput. Math. Appl., 72(8):1959–1967, 2016.

[31] M. Cihan, B. Hudobivnik, F. Aldakheel, and P. Wriggers. 3D mixed virtual element formulation

for dynamic elasto-plastic analysis. Comput. Mech., 68(3):581–598, 2021.

[32] R. S. Falk. Nonconforming ﬁnite element methods for the equations of linear elasticity. Math.

Comp., 57(196):529–550, 1991.

[33] K. Feng and Z. Shi. Mathematical Theory of Elastic Structures. Springer-Verlag, Berlin, 1996.

[34] A. Gain, G. Paulino, S. Leonardo, and I. Menezes. Topology optimization using polytopes.

Comput. Methods Appl. Mech. Engrg., 293:411–430, 2015.

[35] A. L. Gain, C. Talischi, and G. H. Paulino. On the virtual element method for three-

dimensional linear elasticity problems on arbitrary polyhedral meshes. Comput. Methods Appl.

Mech. Engrg., 282:132–160, 2014.

[36] J. Huang and S. Lin. A C0P2 time-stepping virtual element method for linear wave equations

on polygonal meshes. Electron. Res. Arch., 28(2):911–933, 2020.

[37] J. Huang and S. Lin. A posteriori error analysis of a non-consistent virtual element method

for reaction diﬀusion equations. Appl. Math. Lett., 122:Paper No. 107531, 10, 2021.

[38] J. Huang, S. Lin, and Y. Yu. A novel locking-free virtual element method for linear elasticity

problems. arXiv:2112.13848, 2021.

[39] X. Huang. Nonconforming virtual element method for 2mth order partial diﬀerential equations

in Rn with m > n. Calcolo, 57(4):42, 2020.

[40] R. Kouhia and R. Stenberg. A linear nonconforming ﬁnite element method for nearly incom-

pressible elasticity and Stokes ﬂow. Comput. Methods Appl. Mech. Engrg., 124(3):195–212,

1995.

67

[41] D. Y. Kwak and H. Park. Lowest-order virtual element methods for linear elasticity problems.

Comput. Methods Appl. Mech. Engrg., 390:Paper No. 114448, 2022.

[42] A. Ortiz-Bernardin, C. Alvarez, N. Hitschfeld-Kahler, A. Russo, R. Silva-Valenzuela, and

E. Olate-Sanzana. Veamy: an extensible object-oriented C++ library for the virtual element

method. Numer. Algorithms, 82:1189–1220, 2019.

[43] K. Park, H. Chi, and G. H. Paulino. Numerical recipes for elastodynamic virtual element

methods with explicit time integration.

Internat. J. Numer. Methods Engrg., 121(1):1–31,

2020.

[44] O. J. Sutton. The virtual element method in 50 lines of MATLAB. Numer. Algorithms,

75(4):1141–1159, 2017.

[45] C. Talischi, G. H. Paulino, A. Pereira, and I. F. M. Menezes. Polymesher: a general-

purpose mesh generator for polygonal elements written in Matlab. Struct. Multidiscip. Optim.,

45(3):309–328, 2012.

[46] G. Vacca. Virtual element methods for hyperbolic problems on polygonal meshes. Comput.

Math. Appl., 74(5):882–898, 2017.

[47] G. Vacca and L. Beir˜ao da Veiga. Virtual element methods for parabolic problems on polygonal

meshes. Numer. Methods Partial Diﬀerential Equations, 31(6):2110–2134, 2015.

[48] F. Wang and H. Wei. Virtual element method for simpliﬁed friction problem. Appl. Math.

Lett., 85:125–131, 2018.

[49] F. Wang, B. Wu, and W. Han. The virtual element method for general elliptic hemivariational

inequalities. J. Comput. Appl. Math., 389:Paper No. 113330, 19, 2021.

[50] F. Wang and J. Zhao. Conforming and nonconforming virtual element methods for a Kirchhoﬀ

plate contact problem. IMA J. Numer. Anal., 41(2):1496–1521, 2021.

[51] B. Wu, F. Wang, and W. Han. Virtual element method for a frictional contact problem with

normal compliance. Commun. Nonlinear Sci. Numer. Simul., 107:Paper No. 106125, 13 pp.,

2022.

[52] Y. Yu. Implementation of polygonal mesh reﬁnement in MATLAB. arXiv:2101.03456, 2021.

[53] Y. Yu. A lowest-order locking-free nonconforming virtual element method based on the reduced

integration technique for linear elasticity problems. arXiv:2112.13378v2, 2021.

[54] B. Zhang, J. Zhao, Y. Yang, and S. Chen. The nonconforming virtual element method for

elasticity problems. J. Comput. Phys., 378:394–410, 2019.

[55] J. Zhao, S. Chen, and B. Zhang. The nonconforming virtual element method for plate bending

problems. Math. Models Methods Appl. Sci., 26(9):1671–1687, 2016.

68

[56] J. Zhao, B. Zhang, S. Chen, and S. Mao. The Morley-type virtual element for plate bending

problems. J. Sci. Comput., 76(1):610–629, 2018.

[57] J. Zhao, B. Zhang, S. Mao, and S. Chen. The divergence-free nonconforming virtual element

for the Stokes problem. SIAM J. Numer. Anal., 57(6):2730–2759, 2019.

69

