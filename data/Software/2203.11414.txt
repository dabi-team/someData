2
2
0
2

r
a

M
2
2

]

A
M

.
s
c
[

1
v
4
1
4
1
1
.
3
0
2
2
:
v
i
X
r
a

BESSIE: A BEHAVIOR AND EPIDEMIC SIMULATOR FOR USE WITH
SYNTHETIC POPULATIONS

HENNING S. MORTVEIT, STEPHEN ADAMS, FARAZ DADGOSTARI, SAMARTH SWARUP,
AND PETER BELING

Abstract. In this paper, we present BESSIE (Behavior and Epidemic Simulator for Syn-
thetic Information Environments), an open source, agent-based simulator for COVID-type
epidemics. BESSIE uses a synthetic population where each person has demographic at-
tributes, belong to a household, and has a base activity- and visit schedule covering seven
days. The simulated disease spreads through contacts that arise from joint visits to the lo-
cations where activities take place. The simulation model has a plugin-type programmable
behavioral model where, based on the dynamics and observables tracked by the simulator,
agents decide on actions such as wearing a mask, engaging in social distancing, or refraining
from certain activity types by staying at home instead. The plugins are supplied as Python
code. To the best of our knowledge, BESSIE is a unique simulator supporting this feature
set, and most certainly as open software.

To illustrate the use of BESSIE, we provide a COVID-relevant example demonstrating
some of its capabilities. The example uses a synthetic population for the City of Char-
lottesville, Virginia. Both this population and the Python plugin modules used in the ex-
ample are made available. The Python implementation, which can run on anything from a
laptop to a cluster, is made available under the Apache 2.0 license1. The example population
accompanying this publication is made available under the CC BY 4.0 license 2.

1. Introduction

Pandemics, such as COVID-19, are complex, behavior-driven phenomena [22]. Govern-
ments and other authorities all over the world have relied on many non-pharmaceutical
interventions (NPIs) for controlling the spread of diseases, especially before vaccines became
available. These interventions have included mandating business and school closures (or
reduced capacities), and promoting mask wearing, physical distancing, and working from
home [7]. Broadly, the goal is to restrict interactions between people by restricting mobility
and to reduce the probability of transmission when people do interact.

In the agent-based modeling and simulation community, many models and platforms have
been developed, with goals including understanding the spread of the epidemic, forecasting,
guiding policy-making, and evaluating counterfactuals [23, 10]. While diﬀerent goals may
require diﬀerent kinds of models, doing a detailed analysis of the eﬀects of NPIs requires two
main ingredients or components: adequate detail based on real data [24] and true agency
(adaptive coupling with the environment, normativity, etc. [1]). This is because interactions
in a population are contingent on, on the one hand, the demographics, activity patterns,
and built environment of a region, and on the other hand on human behavioral decisions,
which depend on descriptive and injunctive norms [2], perceptions of risk and severity, as well
as perceptions of the eﬃcacy of behaviors in risk-reduction [16]. In [23] human behavioral

Key words and phrases. Epidemics simulator, interventions, agent-based model, behavioral model, plu-

gins, programmable, synthetic population, COVID .

1

 
 
 
 
 
 
2

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

modeling is also identiﬁed as one of the main challenges in agent-based modeling of the
COVID-19 pandemic, as does the NSF in a recent Dear Colleague Letter [19].

While many epidemic simulation models exist (see the Related Work Section), all the ones

we know fail to satisfy at least one of the following aspects:

(1) the model is agent-based;
(2) it supports incorporating human behaviors through the notion of actions;
(3) uses a detailed visit schedule that the agent may dynamically update;
(4) the simulator and its source are made available and accessible for download under a

suitable license;

(5) has made input data available and accessible for at least one non-trivial case under

some suitable license;

While there are many reasons why other research and development eﬀorts omit one or more
of these elements, we remark that doing so certainly presents real challenges for peer review,
reproducibility, and independent validation of models.

Contributions. Here we present the integrated epidemic/behavior simulator BESSIE.
This computational tool integrates (i) detailed synthetic populations, with (ii) a completely
conﬁgurable behavioral model governing the use of personal protective equipment (PPE),
social distancing, and options for abstaining from certain activity types (e.g., non-essential
activities), and (iii) a COVID-like epidemic process where transmission may occur upon con-
tact arising when people simultaneously visit a common location. Since agents in our model
can base their behavior on observations of other agents and parts of their state (through the
notion of local observables) as they visit locations, this can clearly give rise to “clustered
behaviors”. As far as we know, this is a unique feature of BESSIE not present in
any other simulator as outlined in the Related Work section. We remark that BESSIE
was developed to support a machine learning (ML) environment, and incorporating local
observables in the actions decisions of agents was central to the model design. The BESSIE
simulator is implemented as a multi-process, shared memory, Python package that can run
on desktops and laptops, as well as on clusters. Along with this tool, two synthetic popula-
tion data sets are provided: the hypothetical “Smallville” with its three inhabitants that can
be used for testing, and the City of Charlottesville population which has about 41,000 peo-
ple. Both populations include a weekly visit schedule specifying what activities the citizens
conduct, when they do them, as well as where they take place.

Our intention is to provide the scientiﬁc community with an open simulator integrating
a completely conﬁgurable human behavioral model and an individual-based, location-based,
extended SEIR model whose parameters are conﬁgurable. BESSIE can run on a desktop,
laptop or a cluster taking advantage of the number of available cores. We think this can
provide a model for publishing that supports both reproducibility and peer review. BESSIE
is available for download under the Apache 2.0 license through its git repository, see [17].
Its accompanying data, the synthetic population of the City of Charlottesville (CoC), is
available for download under the CC-BY-4.0 license, see [18].

Paper organization. In the next section, we give background and an overview of related
work. This is followed by an overview of BESSIE, including the synthetic populations, the
epidemic model, as well as the behavioral model. We then describe the usage at a high
level, illustrate its use through several application examples, and close with a discussion of
applications and possible extensions. The appendix sections contain a detailed description

of the design of BESSIE, including plugin interfaces, input and output data formats, and
the details of the synthetic population structure.

BESSIE

3

2. Related Work

There have been many simulations that have been developed and published since the
early days of the COVID-19 epidemic, including a large number of agent-based simulations.
[15] provide a recent review. They point out that, of the 126 models they review, only
6 include adaptive human behavior. While several include detailed synthetic populations,
none include both detailed synthetic populations and adaptive human behavioral models.
Thus, BESSIE occupies a unique niche in the space of agent-based simulators for COVID-
19 (and for infectious disease epidemics in general). Our synthetic population is also the
most detailed of its kind, as it includes several demographic variables, household structure,
data-derived weekly activity schedules for all agents, and comprehensive activity location
data [?]. Here we brieﬂy describe some of the more popular agent-based simulators that are
comparable to our work, while also highlighting the diﬀerences.

The IDM Covasim simulator [14] is a widely used agent-based simulation of COVID-19.
It uses synthetic populations from http://synthpops.org, but works mainly on the agent
interaction networks induced by the synthetic population. These synthetic populations are
also relatively simple, in that they do not model activity and mobility patterns in the pop-
ulation or actual locations. They rely on data about age-stratiﬁed mixing in the population
to generate modeled contact networks for the simulation. This is, in fact, a micro-simulation
model as opposed to an agent-based model, since the “agents” in this simulation do not
make observations, or do any decision-making. Many kinds of interventions can be scripted,
however, allowing simulation of many kinds of programmed scenarios.

The OpenABM-Covid19 simulator [13] is another open source COVID-19 simulator that
has been widely used. It is also Python-based, though the core components of the model
are written in the C language for speed. It thus claims to simulate a population of 1 million
It is designed primarily to
interacting people in seconds for each day of the simulation.
support policy-making in the UK, by simulating a default population of one million agents
generated from demographic data from the UK Census. In this case, the model of interaction
in the population is somewhat stylized, as individuals move between networks representing
households, public transport, workplaces, schools, transient social gatherings, etc. These
locations do not appear to be based on data, though the average numbers of interactions
are set to match age-stratiﬁed mixing data. Once again, this is a micro-simulation, not a
true agent-based simulation, capable of evaluating various non-pharmaceutical interventions,
including manual and digital contact tracing.

ComoKit [9] is also a well-known COVID-19 simulator based on the GAMA platform.
It uses more sophisticated synthetic populations than the previous two simulators, e.g.,
populations created by the Gen* [4] synthetic population generator. [9] present a simulation
of the Son Loi Commune in Vietnam, which has about 10,600 people and 3000 buildings. In
their model, agents have week-long, hourly activity schedules, at various locations, which is
similar to our synthetic populations. They can also evaluate various policies such as social
distancing, and the simulator allows script-based editing of the types of agents, policies, and
activities that are included in the simulation. However, they also do not allow the individual
agents to do their own decision-making, thus making this essentially a micro-simulation.

4

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

While there are several other simulations (and simulators) that have been widely used
(see [15] for many examples), they largely share the characteristics of the ones described
above. BESSIE is thus diﬀerent from all of these in allowing for decision-making by indi-
vidual agents in a richly detailed environmental context. It thus opens the door to connecting
agent-based modeling eﬀorts in computational epidemiology with research in behavior and
decision-making from domains such as psychology, sociology, and public health.

3. BESSIE: Overview
The BESSIE tool implements an agent-based, time-stepped model for epidemic spread

that integrates the following features:

• A synthetic population with a visit schedule as detailed in the Synthetic Populations
sub-section below. Such a population has a set of people with demographic attributes,
and is partitioned into households. Each member of the population has an activity
sequence where each activity is mapped to a location. By executing their activity
sequence, people come into contact.

• An epidemic process taking place over the population, see the Epidemic Model sub-
section. Transmission can occur when susceptible persons come in contact with
infectious person(s) at one or more locations.

• A customizable behavioral model allowing each person to adopt a set of measures.
These include wearing a mask, engage in social distancing, and modifying their visit
schedule modiﬁcations to refrain from selected activities. Activities that are omitted
are replaced by staying-at-home. The behavioral model can use demographic infor-
mation about the person, as well as information about global observables (e.g., total
number symptomatic people), or local observables capturing things they have seen
at previous visits (e.g., number of symptomatic cases observed when shopping).

The following sub-sections provide details on the major BESSIE components.

3.1. Synthetic Populations. BESSIE uses the notion of a synthetic population (SP)
which is a statistically accurate representation of a population of a given region, see [6, 8]
for a detailed account. An SP for a given region R has the following components:

• The set of individuals P of R grouped into households. Each person is equipped
with demographic attributes such as age, gender, household income, and a simpliﬁed
version of the NAICS classiﬁcation.

• Each person has an activity sequence specifying what activity they perform and when.
The activity sequence covers a complete week and include the activity types covered
are home, work, shopping, other, school, college and religion.

• A set of locations L consisting of residence locations and general activity locations.

Each household is assigned a residence location.

• A location assignment Λ that for each person p and for each activity a of p assigns a

location (cid:96) ∈ L.

As one can see, the synthetic population allows one to deduce precisely who visits a location
at the same time at any point throughout the week. For BESSIE, this information is
assimilated into a person ﬁle and a visit ﬁle, see the appendix section on usage for a detailed
description of the data records.

3.2. Epidemic Model. The epidemic model used in BESSIE is an extended SEIR model
that includes the following states:

BESSIE

5

• S – susceptible;
• E – exposed;
• Is – infectious and symptomatic;
• Ia – infectious and asymptomatic;
• R – recovered;

We write X = {S, E, Is, Ia, R} for the set of health states. The dynamics of the disease are
split into two components: (i) disease transmission in which a susceptible person becomes
exposed when in contact with an infectious person, and (ii) disease progression covering
all other health state changes. One may regard transmission as the “between people” and
progression as the “within a person.”

Disease transmission. Transmissions may only occur when a susceptible person is in
contact with an infectious person. In general, we use the notion of a transmission conﬁgu-
ration to capture the situation where a susceptible person p changes his/her state from Xi
(the entry state) to Xj (the exit state) in contact with a person p(cid:48) in an infectious state Xk
(the contact state), and denote this conﬁguration by the triple (Xi, Xj, Xk). For our disease
model there are only two transmission conﬁgurations:

(S, E, Is) and (S, E, Ia).

For a general disease model, any entry state is called a susceptible state, any exit state
an exposed state, and any contact state an infectious state. Each transmission conﬁguration
(Xi, Xj, Xk) has an associated transmission weight ω(Xi, Xj, Xk) that represents the relative
weight of this particular transition. It assumes the default value 1.0. We remark that the
transmission conﬁgurations are disease properties independent of people. Each state Xi ∈ X
has an inherent infectivity ι(Xi) and susceptibility σ(Xi). Note again that these are person-
independent disease parameters. To capture individual factors (e.g., due to vaccinations
and/or wearing a mask), each person p is assigned an infectivity and a susceptibility scaling
factor, βι(p) and βσ(p) respectively. These have a default value of 1.0 but are generally time-
varying. The eﬀective susceptibility and infectivity of a person p in state Xi are modeled
as,

(1)

(2)

σp(Xi) = βσ(p) × σ(Xi),
ιp(Xi) = βι(p) × ι(Xi).

and

Finally, a disease model will have a transmissibility that we denote by τ . It may be regarded
as a scaling factor. With this, we can now deﬁne the propensity ρ of a contact conﬁguration
where persons p and p(cid:48) are in contact at a location (cid:96) ∈ L for a duration T :
(3) ρ(p, p(cid:48), (Xi, Xj, Xk), T, (cid:96)) = (cid:2)T τ (cid:3) × w(cid:96) × (cid:2)βs(p)σ(Xi)(cid:3) × (cid:2)βi(p(cid:48))ι(Xk)(cid:3) × ω(Xi, Xj, Xk).
We use the Direct Gillespie Method [12, 11] to determine if a disease transmission takes
place when visiting a location, and, if there are m > 1 transmission conﬁgurations for a
susceptible person, which of the contact persons at that location to whom one attributes the
transmission. Speciﬁcally, for each person p in state Xi we set,

(4)

A(P ) =

(cid:88)

p(cid:48),j,k

ρ(p, p(cid:48), (Xi, Xj, Xk), T, (cid:96)),

6

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

where the sum extends over all neighbors p(cid:48) of p and indices j and k for which a transition
may have taken place. Without loss of generality, the index set of triples K = {(P (cid:48), j, k)} is
well ordered. To determine whether we have a transition we sample a random number,

a = − log(uniform(0, 1))/A,

and if the inequality a ≤ T (the duration of the time step) holds, we select the actual
transition by sampling a uniform random number α ∈ [0, A] and determine the index κ ∈ K
for which,

(5)

(cid:88)

κ−1

ρ(p, p(cid:48), (Xi, Xj, Xk), T, (cid:96)) < α ≤

ρ(p, p(cid:48), (Xi, Xj, Xk), T, (cid:96)).

(cid:88)

κ

Finally, for each time step, all such candidate transitions from all locations are collected for
each person p, and the ﬁnal infector person p(cid:48) is determined using uniform random sampling
proportional to the single propensity returned for each location. The state transition for p
will take place at the end of the each time step (and will override any disease progression
that may have been scheduled for the current time step, see below.)

Disease Progression. We use a disease progression diagram to capture all possible
health state transitions that take place within a person in the absence of transmission pro-
cesses and interventions. The diagram has nodes all possible health states X = {Xi} and
directed edges e = (Xi, Xj) with assigned probability pe = prob(Xi, Xj) and a dwell time
distribution De. For each state Xi it is required that (cid:80)
j prob(Xi, Xj) = 1. The dwell time
distribution De is the probability density for the dwell time in health state Xi given that the
transition Xi −→ Xj will take place.

Algorithmically, the disease progression is determined upon entry to a new state: as
a person p enters a state Xi, the next state Xj is sampled according to the next state
distribution induced by the probabilities pe. Once the next state Xj is determined, the dwell
time ∆T (unit is simulation time steps) is computed by sampling from the associated dwell
time distribution D(Xi,Xj ), rounded to the nearest integer if necessary, and bounded below
by 0. If the current time step is T , the state transition is scheduled to take place at the end
of time step T + ∆T . Note that in particular, this means the transition can take place with
the current time step.

Example. For the SEIR model of BESSIE, we have shown the combined transmission
and progression diagram in Figure 1. Note that transitions corresponding to transmissions
are shown using dashed edges; edges corresponding to progression are shown as regular edges.
Disease parameters can be found in the git repository in the ﬁle
./src/disease_model_v_1_0.py.1

3.3. Behavioral Model. The behavioral model is formulated using the notion of actions.
Users may use the default model that is contained in action_default_v_1_0.py, or may
supply their own model as speciﬁed in Appendix B. Either way, at the beginning of each
time step, each person p will decide on what action(s) to take in that time step for each of
the following choices:

• Wear a mask (a1);
• Social-distance (a2);

1Currently, disease parameters are not exposed in the conﬁguration ﬁle, see the appendix sections.

BESSIE

7

S

Is,Ia

(cid:47) E

Is

p=0.67

p=0.33

Ia

R

Figure 1. The combined transmission- and propagation diagram of the
SEIR model used by BESSIE. Dashed edges are for transmissions; solid
edges are for propagation. The edges for transmission are decorated by the
respective contact states.

• For each of the activity types other (a3), college (a4), shopping (a5), religion (a6),
school (a7), and work (a8) decide whether or not each visit of that type for the given
time step should be replaced by staying at home;

Thus, for each person p and for each time step t, an action a(p, t) = a = (a1, a2, . . . , a8) is
selected. To decide on the actions to take, the following information is available for each
person:

• the current time step t;
• their own current health state sp(t) ∈ S;
• the static list of demographic variables of p (see the Usage section);
• the list of global observables containing the current total count n(s) and fractions
r(s) of people in each of the disease states s ∈ S (e.g., n(E) and r(E) for state E);
• the current local observables for p. These capture the following information for each
activity type α ∈ A, recorded at the beginning of the most recent of visit for p to a
location to conduct an activity a of type α:
– the time step t(cid:48) when a took place;
– the person ID (pid), the location ID (lid) (cid:96) ∈ L, and the activity type α;
– the total number of people present at (cid:96) at the start of that visit;
– the total count and fraction of people present at (cid:96) at the start of that visit of
that are (i) symptomatic, (ii) are wearing a mask, and/or (iii) are engaging in
social distancing.

We remark that the actions of wearing a mask and social distancing will be applied to all
activities of the given time step. One may argue that a person may decide that on an activity-
by-activity basis; we may add this in a future version of BESSIE. Clearly, refraining from
the activities of a given type will limit the exposure in that context, but one may still be
exposed to one’s own household members. Wearing a mask or engaging in social distancing
will cause the person’s infectivity and susceptibility scaling factors to be reduced, currently
as follows:

Value Scaling factor
Scaling factor
0.8
mask_inf_scale
distancing_inf_scale 0.8

Value
0.8,
mask_susc_scale
distancing_susc_scale 0.8

(cid:31)
(cid:31)
(cid:47)
(cid:63)
(cid:63)
(cid:31)
(cid:31)
(cid:63)
(cid:63)
8

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

4. Usage Overview

The git repository contains a ﬁle Readme.md with up-to-date instructions for how to invoke
BESSIE. For completeness, we include a terse version here with section pointers to ﬁles
and their precise formats. Running the BESSIE simulation tool requires having Python
version 3.8 or greater installed on the system. Assuming the computing environment is
appropriately conﬁgured, an invocation of BESSIE will need the following components, all
of which are detailed in the appendix sections:

• a conﬁguration ﬁle;
• a schema ﬁle;
• a person ﬁle and a visit ﬁle; and
• a Python action ﬁle containing a behavioral model.

The source distribution comes with a schema ﬁle, see the git repository and the ﬁle
./schema/schema.json. Using the provided example of Smallville, which has a conﬁguration
ﬁle
./config/smallville_config_1_0_0.json, one may invoke BESSIE from the terminal as
follows:

python -c smallville_config_1_0_0.json -s schema.json

If the user is computing on a cluster using a job submission system (e.g., qsub or slurm),
they may have to specify full paths for the command-line arguments. BESSIE accepts an
additional commandline argument -l <level> where level is one of info, debug, warning,
and error. This may be useful if there are problems running the code with a custom action
ﬁle.

The person- and visit ﬁles are speciﬁed in the conﬁguration ﬁle, as is the Python ﬁle
implementing the behavioral/action model. The distribution comes with a basic behavioral
model:

./src/action_default_v_1_0.py

This may be a convenient starting point for constructing custom versions. The user
will most likely have to edit a copy of smallville_config_1_0_0.json to specify correct
ﬁlenames and paths for their system. We recommend using full paths in all cases. The output
will be generated in a directory speciﬁed in the conﬁguration ﬁle (output_directory).

5. Application Examples
We provide two example populations along with the BESSIE simulator: (a) Smallville,
and (b) City of Charlottesville (or CoC). Smallville is provided as an example that one should
be able to run quickly on any machine. In this paper, we do not run analyses on Smallville,
but we give hints of parameter values that may be interesting for exploration and testing of
action modules.

5.1. Smallville. In Smallville, everything is small-scale. On the other hand, its citizens
only work and stay at home, so presumably they get a lot done. The person and visit ﬁles
are constructed from the following information:

• People: there are three citizens labeled 1, 2 and 3;
• Locations: there are three residences with location ID (or lid) of 11, 12 and 13.

Additionally, there are three work locations whose lids are 1, 2 and 3;

• Residence assignment: person i lives in the residence location with lid = i+10;

BESSIE

9

• Activity sequences: each person has the same weekly activity sequence, and every
day looks the same. Each person goes to work at midnight, work for one hour, and
then returns to their home where they spend the remaining 23 hours of the day.
People thus have only two activity types: home and work.

• Activity location assignment. The only part that varies from day to day is the

location where the citizens go for work:

– person 1: works at location 1 on Monday (day 0) through Sunday (day 6).
– person 2: works at location 1 on Monday through Wednesday. The remainder

of the week, they go to location 2 for work.

– person 3: works at location 1 on Mondays, location 3 on Tuesdays and Wednes-

days, and at location 2 on the remaining weekdays.

Thus the most mixing that happens is at location 1. The weekly contact network for the three
citizens of Smallville is a complete graph.2 Parameters: for the veriﬁcation and validation
runs using Smallville, we used the model parameters tau = 0.05 (transmissibility) and
contact_probability = 1.0. That way, simultaneous visits to the same location will imply
that the corresponding people are in contact (or are connected by an edge in the induced
contact network).

5.2. City of Charlottesville (CoC). This example demonstrates the use of BESSIE
using a synthetic population for the City of Charlottesville, Virginia. The accompanying
action- and conﬁguration ﬁles can be provided upon request (see [17]) as can the person-
and visit ﬁles [18].

Model parameters. Here we use tau = 0.0000015 and contact_probability = 0.33.
These particular values were set to generate an unmitigated attack rate in the range 60–70%,
see [3]. We remark that there are several BESSIE parameters in addition to transmissibility
and contact probability that can be used for calibration, and there are also other metrics
than attack rate that can be used on the dynamics, examples including time-to-peak, and
width-of-peak. Other calibration parameters include:

• State infectivity and state susceptibility, iota and sigma: each health state S, E, Is,
Ia, and R has associated a pair of such values. These disease parameters are set to
either 0 or 1 in BESSIE, but could potentially be any positive number. Currently,
these disease parameters are not exposed in the conﬁguration ﬁle.

• Dwell time distributions associated to the transitions E −→ Ia, E −→ Is, Is −→ R
and Ia −→ R. These are set in the ﬁle ./src/disease_model_v_1_0.py and are
currently not exposed in the conﬁguration ﬁle, but see the appendix section.

• When wearing a mask, infectivity and susceptibility are scaled by mask_inf_scale
and mask_susc_scale which are both set to 0.8 (parameters are not exposed).

• When doing social distancing, infectivity and susceptibility are scaled by

distancing_inf_scale and distancing_susc_scale which are both set to 0.8 (pa-
rameters are not exposed).

We consider four scenarios that demonstrate the capabilities of BESSIE, and that may also
give some insight into what it takes to construct successful interventions from a public policy
perspective. More complex examples can easily be constructed using the ones provided here

2Despite the somewhat monotonous daily routines, Smallville consistently rates high in best-places-to-live

reports.

10

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

as templates or starting points. The action and conﬁguration ﬁles used for these examples
are listed in Section 10.6.

Scenario 1. In this base scenario, everyone goes about their visits as if nothing happened,
not wearing masks nor doing any social distancing. As can be seen in the diagram of Figure 2,
the end result for this simulation instance is that 26, 644 people contract COVID during the
course of this outbreak, corresponding to about 65% of the population of CoC.

Figure 2. Scenario 1 (base): in the base scenario, people go about their lives
as if nothing happened. In this case, about 65% of the population get COVID
(black curve, recovered), comparable to values reported in [3].

Scenario 2. The second scenario demonstrates the case of wearing masks and doing social
distancing. In sub-scenario (a), a subset P (t) of size 70% of the population is chosen ran-
domly at each iteration t, and members of this set will wear a mask and do social distancing.
In sub-scenario (b), a ﬁxed but random subset P of the population is chosen. The members
of P will use a mask and do social distancing at each iteration. Epidemic trajectories for
each case are shown in Figure 3. We see that the epidemic is completely prevented for this
particular simulation instance in sub-scenario (b).

Figure 3. Scenario 2: the diagram on the left shows the case where the
subset is chosen at random at each iteration whereas the diagram on the right
shows the case where a ﬁxed random subset is chosen initially and used in
every iteration. The diﬀerence is quite dramatic.

010203040506070010000200003000040000DiseasestateSEIaIsR010203040506070010000200003000040000DiseasestateSEIaIsR010203040506070010000200003000040000DiseasestateSEIaIsRBESSIE

11

Scenario 3. In this case, we consider mandated drops of activities. Starting at day 8,
75% of people will re-route any visit where the activity type is not home or work to their
residence. In addition, people with household income greater than or equal to 100,000 will
conduct any work activity from their home. As for Scenario 2, we have two sub-scenarios
where (a) the subset P (t) is chosen randomly at each iteration and (b) is chosen as a ﬁxed
subset P that is used in each iteration. In none of the cases do people wear masks or do
social distancing. The epidemic curves are shown in Figure 4. The main diﬀerence that
emerges between these two sub-scenarios is that there is a delay in the onset of the epidemic
in sub-scenario (b). This is not unexpected: since there is no coordination among household
members, the disease can still propagate at people’s homes.

Figure 4. Scenario 3: the left diagram shows the case where a random subset
of size 75% is chosen at every iteration starting on day 8 and refrains from
activities as explained, whereas the diagram on the right shows the case with
a ﬁxed random subset being used across all iterations. As can be seen, case
(b) is virtually the same as case (a), except for a delay in the onsets.

Scenario 4. This scenario demonstrates a case where actions are based on a person’s local
observables. For this, each person, at each iteration will consider their local observables for
all non-home activities. For shopping, other, school, college and religion, if any of
these observables is (1) less than 7 days old and (2) contains at least 1 symptomatic case
(including themselves), then the person will re-route any visit to such activity locations to
their own residence. Additionally, a person whose household income is at least 100,000 will
conduct their work activity at their residence. For the latter, they also take into account the
local observable for activity work. Here the epidemic evolution is shown in Figure 5.

Summary. While some of the observed dynamics may appear surprising at ﬁrst glance,
there are many causes. For example, in the case of Scenario 4, while dropping activities and
staying at home may seem like it should have an impact, it does require coordination across
the household: unless all members of the household consistently stay home, it is easy to see
that even when one member does not observe symptomatic cases and do not modify their
visits, then that can easily cause the entire household to fall sick. Moreover, if somebody
records symptomatic cases in their observables, then very likely there are asymptomatic
cases which are not detected. Basing one’s actions on the cases one has observed in person
may be a bad idea.

010203040506070010000200003000040000DiseasestateSEIaIsR010203040506070010000200003000040000DiseasestateSEIaIsR12

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

Figure 5. Scenario 4 covers the case where people choose to remap certain
visits based on their recent observables. The outcome is quite similar to the
base case (Scenario 1).

While the point of the scenarios is to demonstrate the capabilities of the BESSIE simulator
(and these outcomes should certainly not be used to inform behavior or policy!), it does point
to the fact that for interventions to be eﬀective they require global planning and coordination.
Finally, we again want to emphasize that the epidemic parameters are not set by experts,
and do not correspond to carefully calibrated values. If this was used to advise on policy
formation then this step deﬁnitely would be included. The goal of showing these scenarios
is to demonstrate some of the range and ﬂexibility of the scenarios that can be handled by
BESSIE.

6. Discussion
In this paper we have introduced the BESSIE simulator and demonstrated some of its
capabilities of several scenarios related to COVID and its intervention for a detailed synthetic
population. As already alluded to in the Introduction, for a simulator to be able to address
the example scenarios of Section 5 at that level of detail, it would have to:

• use agents in the representation;
• have an explicit representation of the locations where transmission occurs;
• have a visit schedule for each person, and support dynamic changes to this visit
schedule based on conditions on local observables, global observables, and a person’s
demographic attributes; and

• track per-person local observables by activity across visits.

To the best of our knowledge, we are not aware of any tool that supports this, let alone oﬀers
up the code and the population data for download.

6.1. Validation. For the examples, we set contact probability and transmissibility to obtain
an unmitigated attack rate near 60–70%. While the focus of this work is to provide the
BESSIE simulator, we remark that BESSIE has several parameters for the epidemics that
can be used to calibrate to speciﬁc scenarios.
In addition, the user can also introduce
parameters in the action ﬁles they generate for the behavior models.

010203040506070010000200003000040000DiseasestateSEIaIsRBESSIE

13

6.2. Future directions. Speed and scaling. BESSIE was implemented using Python.
A main reason for this was to permit users to easily add action modules on their own
through the BESSIE plugin interface. The complexity of this would be quite diﬀerent with
a language like C++. The architecture design for BESSIE is as a shared memory application
running on multiple cores on a single compute node. This solution was used to work around
the Global Interpreter Lock (GIL) in Python: a threaded approach would have been used
in a language supporting concurrent threads. The current solution also targets laptops and
desktops which nowadays have at least two cores, and typically many more. If scaling and
speed become a focus, a re-design and re-implementation in C++ using, e.g., MPI [21] and/or
OpenMP [20] is a natural way to go. However, such a solution would eﬀectively only cater
to those who have access to a computing cluster or similar architectures.

Intervention features. As demonstrated in Application Examples section, it would be
useful to be able to coordinate interventions eﬀorts within a household, or more broadly,
introduce actions for groups of agents based on their collective state. This, while certainly
useful for epidemic simulations, would signiﬁcantly change the scope of BESSIE which
was to support learning for individual agents. In related work, the authors have built the
EpiHiper C++/OpenMP/MPI network-based, epidemics simulator [5] has an intervention
language that supports quite ﬂexible construction of sets of people using predicates on their
demographics and health state, and can then apply actions (i.e., state changes) to the mem-
bers of these set. Quarantining or self-isolation of all members of selected households is
therefore directly supported. If BESSIE were to be generalized in this direction, a similar
approach will be used.

Disease models. Currently, the BESSIE disease model is limited to an extended SEIR
model. While ﬂexible, there are certainly other or more reﬁned models that can be consid-
ered. If this is needed in the future, it will be approached using a plugin design similar to
that of the action/behavioral model that is already there.

Calibration support. Due to the scope of the design, several parameters are currently
not exposed in the conﬁguration ﬁle. Depending on future needs, a calibration framework can
be added that and that (a) would expose relevant BESSIE parameters, and (b) would allow
for eﬃcient user declaration and exposure of custom parameters deﬁned in their behavior
models (and possibly custom disease models).

6.3. Current limitations. For a list of limitations and updates, we refer to the git repos-
itory and the ﬁles README.md and ./src/notes.txt. The following are some known limi-
tations that can cause issues if the user pushes boundaries and/or has complex computing
environments.

• BESSIE requires Python version >=3.8 due to the use of the shared memory manager

functionality.

• The BESSIE simulator uses a ﬁxed port number (i.e., 50000) for its shared memory
manager. If multiple instances of BESSIE are run on the same compute node (not
unlikely if you use a cluster), a port conﬂict will arise. In this case, the behavior of
BESSIE is undeﬁned. It can easily be avoided through suitable queuing instructions
under job submission systems such as slurm and qsub. Similarly, there is a small risk
that a diﬀerent application is already running on one’s computer and that also uses
port 50000. This somewhat technical parameter may be exposed in the conﬁguration
ﬁle in a future version of BESSIE.

14

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

• Since the location assignment is dynamic (it depends on people’s actions), the size of
the shared memory buﬀers used by the sub-processes to report observables back to
the main process are not known ahead of time (see Figure 7). While it would be nice
to auto-determine these buﬀer sizes, this is currently done manually and speciﬁed
in the conﬁguration ﬁle. The current values were set of CoC and were speciﬁed
to permit even very skewed loads of people onto locations.
If the user introduces
other populations with visit schedules, they may have to adjust these memory buﬀer
sizes accordingly. The buﬀer size for the local observables, for example, will equal
the maximal number of observables reported back from each sub-process during any
iteration of the simulation: this number will depend on (a) the locations assigned
to each sub-process, and (b) the visitors to those locations, where the latter number
generally depends on the actions taken by all the members of the population.
6.4. DISCLAIMER. The BESSIE simulator, the code, and the synthetic populations
are provided as is, and the user assumes all responsibility for any use thereof. BESSIE is
provided under the Apache 2.0 license while the CoC synthetic populations is made available
under CC-BY-4.0.

7. Acknowledgments

The authors thank their collaborators in Network Systems Science and Advanced Com-
puting Division (BII) and in the Department of Engineering Systems and Environment for
many discussions. In particular we thank Stefan Hoops for discussions and advice related to
the software design and technologies used for BESSIE. This work was funded in part by the
grant FI00026 “Machine Learning Eﬃcient Behavioral Interventions for Novel Epidemics”
awarded by the the Global Infectious Diseases Institute at the University of Virginia.

8. Appendix A: BESSIE Design Details

In this section we describe details of the agent based model and the design of its imple-
mentation (i.e., the BESSIE simulator.) When preparing a detailed behavioral- or action
model, knowing the precise order of the model components will be important.

8.1. Organization of input data. In Figure 6, the input data and its organization is
shown. For the details of formats for the person ﬁle and the visit ﬁle, see the Person and
Visit sub-section of Appendix B. The conﬁguration ﬁle and the schema ﬁle are described
in the Conﬁguration File Format sub-section of Appendix B, while the requirements for the
action ﬁle are given in the Action File sub-section of Appendix B.

Figure 6. An overview of the input data to BESSIE and their organization,
including the conﬁguration ﬁle and the conﬁguration schema ﬁle.

8.2. Architecture design. A high level design of the simulator is given in Figure 7. Some
notable points include the following:

BESSIE

15

• Initialization: Currently, one can only specify the number of people initially set
to be in the exposed state E. All others will have their state set to susceptible,
or S. This subset of the population is chosen at random. More elaborate methods
for specifying the initial set of exposed people may be added later.

• Sub-process buﬀer sizes. The shared memory manager has one buﬀer for each
sub-process that is used for reporting back local observables. The minimal size
of this buﬀer depends on the assignment of people to locations, and the parti-
tion of locations onto sub-processes. Since people may choose actions that re-map
their visits to new locations, assessing a precise bound for this size is not straight-
forward. The current solution is to specify this through the conﬁguration keys
observable_max_items_per_iteration. The value found in the example ﬁles for
CoC are generously to make sure they work with 2 cores. A future version of BESSIE
may include auto-estimation of this quantity. The same applies to the buﬀer that
holds transmission events whose sizes are set by the key
transmission_event_max_items_per_iteration.

• All arrays in shared memory use numpy and user deﬁned types as speciﬁed in

./src/typedefs_v_1_0.py. When developing custom action plugins, you will need
to import this ﬁle. Examples are provided with the sources in the directory ./models.

Figure 7. An overview of the components in the design and the ﬂow of
computation for BESSIE. Dashed gray arrows indicate data dependencies as
well as points where shared memory is being used as a data exchange point
between the main BESSIE process and the sub-processes.

8.3. Notes about implementation. The following is a list or simulator notes require-
ments.

16

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

• BESSIE requires Python version >= 3.8 since it uses the SharedMemoryManager

component of multiprocessing.

• BESSIE has been tested on macOS Catalina, MS Windows, and on a Linux cluster

environment, including under slurm.

9. Appendix B: Description of BESSIE Usage and Data Formats
The input data and parameters to the BESSIE simulator are speciﬁed through a JSON
conﬁguration ﬁle. A JSON schema is used for validation, and is supplied with the source
code of BESSIE. The syntax for invoking BESSIE is as follows:

python -c <config-filename> -s <schema-filename> [-l <info-level>]

Where info-level is one of critical, error, warning, info, and debug. The schema

and conﬁguration ﬁle formats are described next.
9.1. Conﬁguration File Format. BESSIE is designed to use a JSON conﬁguration ﬁle
with a matching schema ﬁle as described in the Usage Overview section. In the case of the
supplied Smallville example, a conﬁguration ﬁle may look like the one below.

Notes.

• The num_procs parameter should be set based on your machine’s speciﬁcs and its
number of cores. For a laptop and desktop, you may want to start modestly (e.g.,
using 2 cores) as fully loading your cores can really tax your computer.

• You will have to update the paths (base_dir and pop_base_dir) of the examples to

match your computing environment.

{

" log_level " : " info " ,
" platform " : " rivanna " ,
" version " : " 1 _0_0 " ,

" config " : {

" run_parameters " : {

" executable " : " bessie_v_1_0 . py " ,
" source_directory " : " { base_dir }/ src " ,
" logging_filename " : " smallville . log " ,
" output_directory " : " ./ logs_ sm allvi ll e " ,

" input " : {

" person_filename " : " { pop_base_dir }/ smallville / s m a l l v i l l e _ p e r s o n _ g i d i . csv " ,
" visit_filename " : " { pop_base_dir }/ smallville / s m a l l v i l l e _ v i s i t s _ g i d i . csv "

} ,

" output " : {

" action_logfile " : " l o g_ a c t i o n _ l o g f i l e . txt " ,
" mo d el cl a ss _ lo gf i le " : " log_mo de l_cla ss . csv " ,
" l o c a l _ o b s e r v a b l e _ l o g f i l e " : " l o g _ l o c a l _ o b s e r v a b l e _ l o g f i l e . txt " ,
" g l o b a l _ o b s e r v a b l e _ l o g f i l e " : " l o g _ g l o b a l _ o b s e r v a b l e _ l o g f i l e . txt " ,
" e pid emi cs_l ogf ile " : " l o g _ e p i d e m i c s _ l o g f i l e . txt "

} ,

" o b s e r v a b l e _ m a x _ i t e m s _ p e r _ i t e r a t i o n " : 1000 ,
" t r a n s m i s s i o n _ e v e n t _ m a x _ i t e m s _ p e r _ i t e r a t i o n " : 1000 ,
" num_procs " : 2

BESSIE

17

} ,

" model_parameters " : {

" random_seed " : 1235 ,
" n u m _ i ni t i a l _ e x p os e d " : 2 ,
" num_days " : 5 ,

" tau " : 0.05 ,
" c o n t a ct _ p r o b a b i li t y " : 1.0 ,

" u s e r _ d e f i n e d _ a c t i o n _ f i l e n a m e " : " j a s s s _ e x a m p l e _ b a s e _ v _ 1 _ 0 " ,

" u s e r _ d e f i n e d _ a c t i o n _ d i r e c t o r y " : " { base_dir }/ models / " ,

" schedule_choice " : " week "

}

}

}

9.2. Schema File Format. The JSON schema used with BESSIE can be found in the git
repository as ./schema/schema.json. Please use the git schema for the most up-to-date
version. We have omitted the listing since it is nearly two pages long.

9.3. Action File. The action ﬁle is a BESSIE mechanism that permits the construction
and addition of custom action/behavioral models without any changes to the BESSIE core.
It functions as a plugin in a manner quite similar to, e.g., a MS Windows DLL except that
is is written in Python. The requirements for a plugin is that must contain the following
two functions with the speciﬁed signatures:

CreateModelClassFile(filename, person_np_rep, person_class_np_rep)

ActionSelection(action_np_rep_i,

time_step,
weekday,
person_np_rep_i,
state_np_rep_i,
visits_np_rep_i,
observables_np_rep,
global_observables_np_rep,
person_class_np_rep_i)

Arguments to the two functions rely on type deﬁnitions contained in typedefs_v_1_0 which
corresponds to the BESSIE ﬁle ./src/typedefs_v_1_0.py. Thus you likely will want to
add

import typedefs_v_1_0 as typedefs

near the beginning of your action action ﬁle. Your ﬁle may reference other ﬁles from your
action ﬁle as long as they are present in the same directory as the action ﬁle (BESSIE will
add the directory you specify for your action ﬁle to the search path – recommended) or if
you update your Python path accordingly.

CreateModelClassFile. This function provides the option to accomplish two things: (i)
it can assign a person class (integer) to each person based on their demographic attributes
as speciﬁed in the person ﬁle (provided in the person_np_rep argument), and (ii) it can
write out this person class to a CSV ﬁle as speciﬁed in the Output Data section. This ﬁle is
not used by BESSIE, but may be useful for analyzing the outcome. The generated person
class, however, will be passed to the ActionSelection (see below). This aspect may be

18

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

useful, since the plugin cannot (at least not easily) retain state across iterations. We refer
to the examples for use cases.

• filename: name of CSV ﬁle to construct (type: string)

• person_np_rep: a numpy array with elements of type person_dtype as deﬁned in
the repository ﬁle ./src/typedefs_v_1_0.py. The order is exactly the same as in
the supplied person ﬁle.

• person_class_np_rep: a numpy array with elements of type person_class_dtype
as deﬁned in the repository ﬁle ./src/typedefs_v_1_0.py. The order is exactly the
same as in the supplied person ﬁle.

ActionSelection. The action selection function is called at every iteration for each person
in the course of the simulation. This provides the mechanism that one can use to specify
which of the actions a person should (or should not) adopt at each iteration. Its argument
are as follows:

• action_np_rep_i: a single element of type action_dtype as deﬁned in

./src/typedefs_v_1_0.py. The function will set each element of this variable (they
correspond to the list of possible actions). These values will be passed back to
BESSIE.

• time_step: the current time step (or iteration) starting at t=0.
• weekday: the current weekday. Here Monday corresponds to 0, Tuesday to 1, and so

on.

• person_np_rep_i: as single element of type person_dtype holding the demographic

attributes of the person as speciﬁed in the person ﬁle.

• state_np_rep_i: the health state of the person.
• visits_np_rep: the complete array of visits for all people and all days. Each entry

is of type visit_dtype as deﬁned in ./src/typedefs_v_1_0.py

• observables_np_rep_i: the local observable array for person i. To reference for

example the current local observable for work, use
observables_np_rep_i[ typedefs.obs_work_index ].

• global_observables_np_rep: the global observables array. To access for example

the current number of symptomatic cases, use
global_observables_np_rep[time_step][’obs_Is_abs’]

• person_class_np_rep_i: the person class of person i as assigned in the

CreateModelClassFile function.

We recommend looking at the example ﬁle ./src/action_default_v_1_0.py from the
BESSIE repository.

9.4. Person and Visit Files. The representation of the synthetic population is captured
by two ﬁles, a person ﬁle and a visit ﬁle.

Person ﬁle. The person ﬁle contains demographic and household information for each
person, including details about their residence.3 The person ﬁle is a CSV ﬁle with the
following header, shown with two example rows of data.

3Note that in the accompanying data for CoC, coordinates are all set to (0.0, 0.0) due to license terms

that apply to the data that was used to construct this instance.

BESSIE

19

hid,pid,age,sex,employment_status,race,hispanic,designation,hh_size,hh_income,\
workers_in_family,lid,longitude,latitude,admin1,admin2,admin3,admin4
2208253,5586585,38,1,4,1,1,military,6,55000,1,1001018209,-78.4884675,38.0430255,\
51,540,201,1
2208253,5586586,37,2,6,6,1,none,6,55000,1,1001018209,-78.4884675,38.0430255,\
51,540,201,1

Data dictionary. Records with reference to PUMS have details described in [25].
hid: the household ID of the person (type: integer)
pid: the person ID of the person (type: unsigned integer)
age: the age of the person in years (type: integer)
sex: the sex of the person (type: enumeration { 1: male, 2: female})
employment_status: employed or not, civilian or armed forces (PUMS:ESR)
race: race of householder (PUMS RAC1P variable)
hispanic: a Boolean (PUMS HISP variable) (type: Boolean {0,1})
designation: a person designation derived from the PUMS NAICSP variable (type: string)
hh_size: number of persons in family (PUMS NPF variable);
hh_income: household income in the past 12 months in local currency (PUMS HINCP

variable);

workers_in_family: Workers in the family in the past 12 months (PUMS WIF variable)
lid: location ID of assigned residence (type: integer)
longitude: the longitude of the residence (type: ﬂoat; see footnote)
latitude: the latitude of the residence (type: ﬂoat; see footnote)
admin1: 2-digit US FIPS code for the state
admin2: 3-digit US FIPS code for the county
admin3: 6-digit US FIPS code for the census track
admin4: 1-digit US FIPS code for the block group

Visit ﬁle. The visit ﬁle captures the activity sequence and the baseline locations of
visit for each person. We say baseline since the locations of visit may change during the
In the case of CoC, the sequence spans a week,
simulation based on the actions chosen.
starting at midnight Sunday/Monday, a time point we will refer of as T0. The visit ﬁle uses
the CSV format with columns as follows, including two example rows:

daynum,pid,activity_number,activity_type,start_time,end_time,duration,lid
0,5586585,0,1,0,27900,27900,1001018209
0,5586585,2,2,28800,45900,17100,82246
0,5586585,4,4,46800,48000,1200,86726

Data dictionary.
daynum: the weekday on which the contact started (type: enumeration {0: Monday, 1: Tues-

day, ..., 6: Sunday})

pid: pid of person (see above)
activity_number: the activity number in the person’s activity sequence (type: integer)
activity_type: the activity conducted during the visit (type: enumeration {home: 1,
work: 2, shopping: 3, other: 4, school: 5, college: 6, religion: 7, transit: 0}; note that
all transit activities are omitted in the distributed data);

start_time: activity start time measured in seconds since T0 (type: integer)
end_time: activity end time measured in seconds since T0 (type: integer)

20

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

duration: activity duration measured in seconds (type: integer)
lid: ID of location visited (type: integer)

10. Output data
The BESSIE simulator generates ﬁve output ﬁles. These are all CSV ﬁles with column

headers and data dictionaries as described in the following.

10.1. Model class ﬁle. This is a classiﬁcation of people into model classes. The precise
semantics of this will depend on the behavioral model that you implement.

index,pid,model_class
0,5586585,1
1,5586586,1

Data dictionary.

index: the index used in the simulation for the numpy structures. It will equal the line
number of the person’s entry in the person ﬁle, not counting the header line (type: integer)

pid: the matching pid ﬁeld from the person ﬁle (see above)
model_class: the model class assigned to the person under the given behavioral model

speciﬁed in the action ﬁle (type: integer)

10.2. Local observables ﬁle. This ﬁle contains one record for each person for each non-
home activity type for each iteration. In the case where there are multiple local observations
for the same activity type within an iteration, this will contain the most recent local observ-
able that was reported. This is a CSV ﬁle with the following structure:
iteration,obs_iteration,pid,lid,activity_type,n_total,symp_abs,symp_rel,mask_abs,\
mask_rel,distancing_abs,distancing_rel
0,0,5586585,0,1,0,0,0.0,0,0.0,0,0.0
0,0,5586585,0,2,0,0,0.0,0,0.0,0,0.0
0,0,5586585,0,3,0,0,0.0,0,0.0,0,0.0

Data dictionary.
iteration: the iteration for the recorded observable (type: integer)
obs_iteration: the iteration for which the recorded observable took place (type: integer)
pid: see above
lid: see above
activity_type: see above
n_total: total number of people present at the location, including the person him/herself,

at the start of their visit (type: integer)

symp_abs: total number of people present at the location whose health state was Is, in-

cluding the person him/herself, at the start of their visit (type: integer)

symp_rel: the ratio symp_abs/n_total at the start of the visit (type: ﬂoat)
mask_abs: total number of people present at the location wearing a mask, including the

person him/herself, at the start of their visit (type: integer)

mask_rel: the ratio mask_abs/n_total at the start of the visit (type: ﬂoat)
distancing_abs: total number of people including the person him/herself) present at the
location that are social distancing (keeping a distance of 6ft to others), at the start of their
visit (type: integer)

distancing_rel: the ratio distancing_abs/n_total, at the start of their visit (type ﬂoat)

BESSIE

21

10.3. Global observables ﬁle. The ﬁle contains the list of global observables tracked at
each iteration, represented as a CSV ﬁle with the following structure:

iteration,S_abs,S_rel,E_abs,E_rel,Is_abs,Is_rel,Ia_abs,Ia_rel,R_abs,R_rel
0,41109,0.9997568130493164,10,0.0002431965694995597,0,0.0,0,0.0,\
0,0.0
1,41109,0.9997568130493164,8,0.0001945572585100308,0,0.0,\
2,4.86393146275077e-05,0,0.0
2,41074,0.998905599117279,36,0.000875507656019181,5,0.00012159828474977985,\
4,9.72786292550154e-05,0,0.0

Data dictionary.

iteration: see above
S_abs: total number of people in health state S (type: integer)
S_rel: fraction of of people in health state S (type: ﬂoat)
E_abs: total number of people in health state E (type: integer))
E_rel: fraction of of people in health state E (type: ﬂoat)
Is_abs: total number of people in health state Is (type: integer)
Is_rel: fraction of of people in health state Is (type: ﬂoat)
Ia_abs: total number of people in health state Ia (type: integer)
Ia_rel: fraction of of people in health state Ia (type: ﬂoat)
R_abs: total number of people in health state R (type: integer)
R_rel: fraction of of people in health state R (type: ﬂoat)

10.4. Action ﬁle. The action log tracks the actions chosen by each person at every iteration
across the possible actions described in Section 3.3.
It is a CSV ﬁle with the following
structure:

iteration,pid,mask,distancing,no_other,no_college,no_shopping,no_religion,\
no_school,no_work
0,5586585,1,1,1,1,0,1,1,1
0,5586586,1,1,1,1,0,1,1,1
0,5586587,1,1,0,0,1,1,0,1

Data dictionary.

iteration: see above
pid: see above
mask: wear a mask at all locations visited during the iteration (type: {0,1})
distancing: do social distancing (keep 6ft distance to all others) at all locations visited

during the iteration (type: {0,1})

no_other: replace each activity of type other by a visit to their residence for the given

iteration (type: {0,1})

no_college: replace each activity of type college by a visit to their residence for the

given iteration (type: {0,1})

no_shopping: replace each activity of type shopping by a visit to their residence for the

given iteration (type: {0,1})

no_religion: replace each activity of type religion by a visit to their residence for the

22

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

given iteration (type: {0,1})

no_school: replace each activity of type school by a visit to their residence for the given

iteration (type: {0,1})

no_work: replace each activity of type work by a visit to their residence for the given

iteration (type: {0,1})

10.5. Health state dynamics trajectory. This CSV log ﬁle contains a record of each
health state transition that took place for each person of the population in the course of
the simulation. Note that initialization is also considered as a state change event. As
explained in Section 3.2, there are transmission- and progression transitions. In the case of
a transmission, the pid of the infector (i.e., p2_pid) is included in the entry. For disease
progression, we have always have p2_pid = −1. This CSV ﬁle has the following header:

iteration,state,p1_pid,p2_pid
-1,1,5586585,-1
-1,1,5586587,-1
-1,1,5586591,-1
-1,1,5586599,-1

Data dictionary.

iteration: see above; note that -1 means initialization
state: the new health state (type: integer)
p1_pid: the pid of the person whose health state changed (type: same as pid)
p2_pid: the pid of the person deemed to have caused the state transition in the case of a

transmission (type: same as pid)

10.6. Example action ﬁles and their conﬁgurations. The following is the list of ﬁles
that were used as examples in this paper. We have listed both the action ﬁles (Python) and
the corresponding conﬁguration ﬁles (JSON). Note that you will have to adapt paths to ﬁt
your computing environment before trying the examples. Generally, you will ﬁnd that the
action ﬁle is the same across platforms; only the conﬁguration ﬁle will need to be updated.
In all the examples below, the conﬁguration ﬁles are located in the directory ./config/, the
the action ﬁles inside the directory ./models/. This part of the ﬁlenames have therefore
been omitted in the listing of Table 1.

References

[1] Xabier E. Barandiaran, Ezequiel Di Paolo, and Marieke Rohde. Deﬁning agency: Individuality, norma-

tivity, asymmetry, and spatio-temporality in action. Adaptive Behavior, 17(5):367–386, 2009.

[2] Cristina Bicchieri, Enrique Fatas, Abraham Aldama, Andres Casas, Ishwari Deshpande, Mariagiulia
Lauro, Cristina Parilli, Max Spohn, Paula Pereira, and Ruiling Wen. In science we (should) trust:
Expectations and compliance during the COVID-19 pandemic, 2020. Preprint - Available from Research
Square.

[3] Lewis F. Buss, Carlos A. Prete, Claudia M. M. Abrahim, Alfredo Mendrone, Tassila Salomon, Ce-
sar de Almeida-Neto, Rafael F. O. Fran¸ca, Maria C. Belotti, Maria P. S. S. Carvalho, Allyson G.
Costa, Myuki A. E. Crispim, Suzete C. Ferreira, Nelson A. Fraiji, Susie Gurzenda, Charles Whittaker,
Leonardo T. Kamaura, Pedro L. Takecian, Pedro da Silva Peixoto, Marcio K. Oikawa, Anna S. Nishiya,
Vanderson Rocha, Nanci A. Salles, Andreza Aruska de Souza Santos, Martirene A. da Silva, Brian
Custer, Kris V. Parag, Manoel Barral-Netto, Moritz U. G. Kraemer, Rafael H. M. Pereira, Oliver G.

BESSIE

23

Example 1 (base)

{ex}_base_v_1_0.py
{ex}_base_config_rivanna_1_0_0.json

Example 2a (mask/dist) {ex}_mask_distancing_v_1_0.py

Example 2b

Example 3a (visit drop)

Example 3b

{ex}_mask_distancing_rivanna_1_0_0.json
{ex}_mask_distancing_fixed_pid_set_v_1_0.py
{ex}_mask_distancing_fixed_pid_set_rivanna_1_0_0.json
{ex}_visit_drop_mandated_v_1_0.py
{ex}_visit_drop_mandated_rivanna_1_0_0.json
{ex}_visit_drop_mandated_fixed_pid_set_v_1_0.py
{ex}_visit_drop_mandated_fixed_pid_set_rivanna_1_0_0.json

Example 4 (observables) {ex}_visit_drop_observations_v_1_0.py

Smallville (default)

{ex}_visit_drop_observations_rivanna_1_0_0.json
action_default_v_1_0.py
smallville_config_rivanna_1_0_0.json

Table 1. The listing of example action ﬁles used in this paper along with
matching conﬁguration ﬁles. Here {ex} is short-hand for jasss example.

Pybus, Michael P. Busch, M´arcia C. Castro, Christopher Dye, V´ıtor H. Nascimento, Nuno R. Faria, and
Ester C. Sabino. Three-quarters attack rate of SARS-CoV-2 in the Brazilian Amazon during a largely
unmitigated epidemic. Science, 371(6526):288–292, 2021.

[4] Kevin Chapuis, Patrick Taillandier, Misslin Renaud, and Alexis Drogoul. Gen*: a generic toolkit to
generate spatially explicit synthetic populations. International Journal of Geographical Information
Science, 32(6):1194–1210, 2018.

[5] Jiangzhuo Chen, Stefan Hoops, Bryan L. Lewis, Henning S. Mortveit, Srini Venkatramanan, and
Amanda Wilson. EpiHiper: Modeling and implementation, 2019. NSSAC Technical Report Series: No.
2019–003.

[6] Jiangzhuo Chen, Anil Vullikanti, Stefan Hoops, Henning Mortveit, Bryan Lewis, Srinivasan Venkatra-
manan, Wen You, Stephen Eubank, Madhav Marathe, Chris Barrett, and Achla Marathe. Medical costs
of keeping the US economy open during COVID–19. Nature Scientiﬁc Reports, 10:18422, 2020.

[7] Am´elie Desvars-Larrive, Elma Dervic, Nils Haug, Thomas Niederkrotenthaler, Jiaying Chen, Anna Di
Natale, Jana Lasser, Diana S. Gliga, Alexandra Roux, Johannes Sorger, Abhijit Chakraborty, Alexandr
Ten, Alija Dervic, Andrea Pacheco, Ania Jurczak, David Cserjan, Diana Lederhilger, Dominika Bul-
ska, Dorontin¨e Berishaj, Erwin Flores Tames, Francisco S. ´Alvarez, Huda Takriti, Jan Korbel, Jenny
Reddish, Joanna Grzyma(cid:32)la-Moszczy´nska, Johannes Stangl, Lamija Hadziavdic, Laura Stoeger, Leana
Gooriah, Lukas Geyrhofer, Marcia R. Ferreira, Marta Bartoszek, Rainer Vierlinger, Samantha Holder,
Simon Haberfellner, Verena Ahne, Viktoria Reisch, Vito D. P. Servedio, Xiao Chen, Xochilt Mar´ıa
Pocasangre-Orellana, Zuzanna Garncarek, David Garcia, and Stefan Thurner. A structured open dataset
of government interventions in response to COVID-19. Scientiﬁc Data, 7(1), 2020.

[8] S. Eubank, H. Guclu, V. S. A. Kumar, M. V. Marathe, Srinivasan A., Z. Toroczkai, and N. Wang.
Modelling disease outbreaks in realistic urban social networks. Nature, 429(6988):180–184, May 13,
2004.

[9] Benoit Gaudou, Nghi Quang Huynh, Damien Philippon, Arthur Brugi`ere, Kevin Chapuis, Patrick
Taillandier, Pierre Larmande, and Alexis Drogoul. COMOKIT: A modeling kit to understand, analyze,
and compare the impacts of mitigation policies against the COVID-19 epidemic at the scale of a city.
Frontiers in Public Health, 8:563247, 2020.

[10] Philippe J. Giabbanelli, Jennifer Badham, Brian Castellani, Hamdi Kavak, Vijay Mago, Ashkan Ne-
gahban, and Samarth Swarup. Opportunities and challenges in developing COVID-19 computational
models: Lessons from six funded projects. In Proceedings of the Annual Simulation Symposium, Fairfax,
VA, USA, 2021.

24

HENNING S. MORTVEIT, S. ADAMS, F. DADGOSTARI, S. SWARUP, AND P. BELING

[11] Daniel T. Gillespie. Exact stochastic simulation of coupled chemical reactions. Journal of Physical

Chemistry, 81(25):2340–2361, 1977.

[12] D.T. Gillespie. A general method for numerically simulating the stochastic time evolution of coupled

chemical reactions. Journal of Computational Physics, 22:403–434, 1976.

[13] Robert Hinch, William J M Probert, Anel Nurtay, Michelle Kendall, Chris Wymant, Matthew Hall,
Katrina Lythgoe, Ana Bulas Cruz, Lele Zhao, Andrea Stewart, Luca Ferretti, Daniel Montero, James
Warren, Nicole Mather, Matthew Abueg, Neo Wu, Anthony Finkelstein, David G Bonsall, Lucie Abeler-
D¨orner, and Christophe Fraser. OpenABM-Covid19 - an agent-based model for non-pharmaceutical
interventions against COVID-19 including contact tracing. medRxiv, 2020.

[14] Cliﬀ C. Kerr, Robyn M. Stuart, Dina Mistry, Romesh G. Abeysuriya, Katherine Rosenfeld, Gregory R.
Hart, Rafael C. N´u˜nez, Jamie A. Cohen, Prashanth Selvaraj, Brittany Hagedorn, Lauren George, Micha(cid:32)l
Jastrzebski, Amanda Izzo, Greer Fowler, Anna Palmer, Dominic Delport, Nick Scott, Sherrie Kelly, Car-
oline S. Bennette, Bradley Wagner, Stewart Chang, Assaf P. Oron, Edward Wenger, Jasmina Panovska-
Griﬃths, Michael Famulare, and Daniel J. Klein. Covasim: an agent-based model of COVID-19 dynamics
and interventions. medRxiv, 2021.

[15] Fabian Lorig, Emil Johansson, and Paul Davidsson. Agent-based social simulation of the covid-19 pan-
demic: A systematic review. Journal of Artiﬁcial Societies and Social Simulation, 24(3):5, 2021.
[16] Daniel E. Monta˜no and Danuta Kasprzyk. Theory of reasoned action, theory of planned behavior, and
the integrated behavior model. In Karen Glanz, Barbara K. Rimer, and Kasisomayajula Viswanath,
editors, Health Behavior: Theory, Research, and Practice, chapter 6. Jossey-Bass, ﬁfth edition, 2015.

[17] Henning. S Mortveit. BESSIE source code, 2021. Source can be provided upon request.
[18] Henning S. Mortveit. Synthetic City of Charlottesville (CoC), 2021. Data can be provided upon request.
Incorporating human behavior in epidemiological models
[19] NSF. Nsf 22-054 dear colleague letter:

(IHBEM), 2022. Last accessed: 06 Mar 2022.
[20] OpenMP, 2021. Last accessed: 12 May 2021.
[21] Open MPI, 2021. Last accessed: 12 May 2021.
[22] Surya Singh, Mujaheed Shaikh, Katharina Hauck, and Marisa Miraldo. Impacts of introducing and
lifting nonpharmaceutical interventions on COVID-19 daily growth rate and compliance in the united
states. Proceedings of the National Academy of Sciences, 118(12):e2021359118, 2021.

[23] Flaminio Squazzoni, J Gareth Polhill, Bruce Edmonds, Petra Ahrweiler, Patrycja Antosz, Geeske Scholz,
˜A Chappin, Melania Borit, Harko Verhagen, Francesca Giardini, et al. Computational models that
matter during a global pandemic outbreak: A call to action. Journal of Artiﬁcial Societies and Social
Simulation, 23(2), 2020.

[24] Samarth Swarup. Adequacy: What makes a simulation good enough? In Proceedings of the Spring

Simulation Conference (SpringSim), Tucson, AZ, 2019.

[25] US Census. Public Use Microdata Sample (PUMS), 2021. Last accessed: 24 May 2021.

Department of Engineering Systems and Environment (SEAS) and Network Systems Sci-

ence and Advanced Computing (BII), University of Virginia
Email address, H. S. Mortveit: henning.mortveit@virginia.edu

Intelligent Systems Division, Virginia Tech National Security Institute
Email address, S. Adams: scadams21@vt.edu

Network Systems Science and Advanced Computing (BII), University of Virginia
Email address, F. Dadgostari: fd4cd@virginia.edu

Network Systems Science and Advanced Computing (BII), University of Virginia
Email address, S. Swarup: ss7rs@virginia.edu

Intelligent Systems Division, Virginia Tech National Security Institute and Department

of Industrial and Systems Engineering, Virginia Tech

Email address, P. Beling: beling@vt.edu

