Software Engineering for Quantum Programming: How Far Are We?

Manuel De Stefanoa, Fabiano Pecorellib, Dario Di Nuccia, Fabio Palombaa, Andrea De Luciaa

aSeSa Lab - University of Salerno, Italy
bTampere University, Finland

2
2
0
2

r
p
A
1
1

]
E
S
.
s
c
[

2
v
9
6
9
6
1
.
3
0
2
2
:
v
i
X
r
a

Abstract

Quantum computing is no longer only a scientiﬁc interest but is rapidly becoming an industrially available technology
that can potentially overcome the limits of classical computation. Over the last years, all major companies have provided
frameworks and programming languages that allow developers to create their quantum applications. This shift has led
to the deﬁnition of a new discipline called quantum software engineering, which is demanded to deﬁne novel methods
for engineering large-scale quantum applications. While the research community is successfully embracing this call, we
notice a lack of systematic investigations into the state of the practice of quantum programming. Understanding the
challenges that quantum developers face is vital to precisely deﬁne the aims of quantum software engineering. Hence, in
this paper, we ﬁrst mine all the GitHub repositories that make use of the most used quantum programming frameworks
currently on the market and then conduct coding analysis sessions to produce a taxonomy of the purposes for which
quantum technologies are used. In the second place, we conduct a survey study that involves the contributors of the
considered repositories, which aims to elicit the developers’ opinions on the current adoption and challenges of quantum
programming. On the one hand, the results highlight that the current adoption of quantum programming is still limited.
On the other hand, there are many challenges that the software engineering community should carefully consider: these
do not strictly pertain to technical concerns but also socio-technical matters.

Keywords: Quantum Computing; Software Engineering for Quantum Programming; Empirical Software Engineering.

1. Introduction

The dream has come true [1]: several physicians and
computer scientists agree that the quantum technology
is right around the corner [1, 2] and that the 21st cen-
tury will be recalled as the “quantum era” [3]. Speciﬁc
mechanic principles such as superposition, i.e., quantum
objects may assume diﬀerent states at the same time, and
entanglement, i.e., quantum objects may be deeply con-
nected without any direct physical interaction, promise to
revolutionize program computation compared to classical
computers [4]. Quantum computers could eventually lead
to resolving NP-complete problems [5, 6]—often referred
to as quantum supremacy [7], namely the point in time
when a programmable quantum device would be able to
solve problems that no classical computer can solve in any
feasible amount of time.

For this reason, all major software companies, like IBM
and Google, are currently investing hundreds of millions of
dollars every year to produce novel hardware and software
technologies that can support the execution of quantum pro-

∗Corresponding author
Email addresses: madestefano@unisa.it (Manuel De Stefano),
fabiano.pecoreli@tuni.fi (Fabiano Pecorelli), ddinucci@unisa.it
(Dario Di Nucci), fpalomba@unisa.it (Fabio Palomba),
adelucia@unisa.it (Andrea De Lucia)

grams.1 For instance, IBM Quantum2 has developed its
programming framework, which allows developers to design,
implement, and execute quantum applications on cloud-
based quantum computers. Companies and researchers
have also been developing several quantum programming
languages [8, 9, 10] and development toolkits [11, 12, 13]
that provide developers with oﬀ-the-shelf instruments and
APIs to create quantum programs.

While there have been already several promising ap-
plications of quantum programming to the resolution of
various problems in the ﬁelds of machine learning [14], op-
timization [15], cryptography [16], and chemistry [17], the
development of large-scale quantum software seems to be
still far from being a reality. In this respect, researchers
such as Piattini et al. [3, 18, 19], Moguel et al. [20], and
Zhao [21] advocated the need for a brand new scientiﬁc
discipline able to rework and extend the classical software
engineering into the quantum domain. This new ﬁeld that
should enable developers to design and develop quantum
programs with the same conﬁdence as classical programs
is what we call quantum software engineering (QSE) [21].
In response to the quantum software engineering call,
our research community has proposed thematic workshops,

1Boston Consulting Group report: shorturl.at/mINWY.
2IBM Quantum: https://www.ibm.com/quantum-computing/.

Preprint submitted to Journal of Systems and Software

April 12, 2022

 
 
 
 
 
 
like Q-Se3 and Q-SET,4 as well as devising novel pro-
cesses [22], modeling techniques [23], and debugging mech-
anisms [24]. Recognizing the initial eﬀort spent by the
research community, we notice a notable lack of empirical
investigations to provide a more comprehensive overview
of the current state of the practice on quantum software
engineering. Therefore, there is a need to analyze how quan-
tum programming is currently used and the key software
engineering challenges developers face when programming
quantum programs. An improved understanding of these
critical aspects might shed light on the limitations of the
state of the art and drive the next research steps that our
community should invest in.

To the best of our knowledge, El Aoun et al. [25] have
been the ﬁrst to work along these lines. They conducted
an empirical study on the questions asked by quantum
developers on Stack Exchange forums, as well as the
issues reported on GitHub. The authors performed quali-
tative coding analyses and automated topic modeling to
uncover the topics in quantum software engineering-related
posts and issue reports. According to the reported results,
knowledge of quantum theory and quantum program com-
prehension represent key engineering aspects hindering the
developer’s capabilities to develop quantum programs.

In this paper, we aim at complementing and extending
the work by El Aoun et al. [25]. Rather than analyzing
the traces left by developers over forums and issues, we
approach the understanding of the current state of the
practice on quantum programming by proposing a two-step
investigation that includes a mining software repository
analysis and a survey study. The ultimate goal of our study
is to assess how far quantum software engineering is from
eﬀectively supporting developers in practice.

In particular, we ﬁrst mine all the GitHub repositories
that employ the three most widely used quantum program-
ming frameworks implementing the quantum logic gate
model, i.e., Qiskit [11], Cirq [26], and Q] [27]. Our choice
to focus on the emerging technologies enabling the universal
quantum gate model is driven by the fact that this can be
applied to a broader range of problems if compared to other
models, e.g., quantum annealing [28] or quantum adiabatic
[29]. We conduct content analysis sessions [30] to elicit a
taxonomy of purposes for which quantum programming is
used. Afterwards, we run a survey among the contributors
of the mined repositories, asking about their opinions and
perspectives on the current adoption of quantum program-
ming and the key challenges they face when engaging with
the currently available quantum technologies.

On the one hand, our repository analysis highlights that
quantum programming is currently mainly used for didac-
tic purposes or for curiosity to experiment with quantum
technologies. On the other hand, the survey study identiﬁes
ﬁve signiﬁcant challenges related to the comprehension of
quantum programs, the hardness of setting up hardware

3The Q-Se workshop: https://q-se.github.io/qse2021/.
4The Q-SET workshop: https://quset.github.io/qset2021/

2

and software infrastructures, the implementation and code
quality issues, the diﬃculty of building a quantum devel-
oper’s community, and, perhaps more importantly, the lack
of realism of the current quantum applications.

Based on these observations, we conclude that the road
ahead for quantum software engineering is still long and
concerns technical and socio-technical matters.

Structure of the paper. Section 2 overviews the basic
concepts behind quantum computing and programming,
while Section 3 summarizes the existing literature. Section 4
elaborates on the research questions, the context of the
study, and the methodology of our empirical study. In
Sections 5 and 6 we analyze the results addressing the
two research questions of the study. Section 7 discusses
the main ﬁndings and the implications that they have for
researchers, practitioners, and tool vendors. The threats
to the validity of the study are reported and discussed
in Section 8. Finally, Section 9 concludes the paper and
outlines our future research agenda.

2. Background

In the following, we describe the basics for understand-
ing the universal gate model of quantum computing [31, 32].

2.1. Quantum Bits

In classical programming, the base unit of information is
the bit, which can assume only binary values. In quantum
computing, the base unit of information is the quantum
bit (i.e., qubit or qbit). A qubit diﬀers from a classical bit
since its state is a linear combination of two bases in the
quantum space, represented by a bidimensional vector [33].
Thus, the computational basis of the qubit is deﬁned as:

|0i =

"

#
1
0

|1i =

"

#
0
1

Then, a generic qubit |qi can be represented as:

|qi = α |0i + β |1i

(1)

(2)

where α and β are complex numbers subject to the nor-
malization condition, i.e., |α|2 + |β|2 = 1. This is necessary
since |α|2 and |β|2 indicates the probability of the qubit
to be either in state 0 or 1. The fact that the qubit can
be found in one of these states with a certain probability
is called superposition [33]. In other words, a quantum
computer consisting of Qubits is in many diﬀerent states
at the same time.

2.2. Quantum Gates

In classical logical circuits, the state of a bit can be
changed by applying a gate. The same concept applies to
quantum circuits. In this case, such gates can be applied
on a single (i.e., for the transition of a single quantum
state) or multiple qubits (i.e., for the transition of multiple

quantum states). The number of inputs and outputs of a
gate should be equal to make the operation reversible. A
single qubit gate is represented by a squared bidimensional
matrix. The resulting quantum state is determined by
multiplying the quantum state vector with the matrix. An
example of a single qubit gate is the N OT gate, denoted
in the following.

N OT =

"

0
1

#
1
0

(3)

Applying a N OT gate to a generic qubit [α, β] results in a
new state vector whose components are inverted, as shown
in the following:

N OT

#

"

α
β

=

"
0
1

#

# "
1
0

α
β

#

"

β
α

=

(4)

Single qubit gates are fundamental to achieve the superpo-
sition condition described above.

Conditional logic operations are needed to change the
state of a qubit given the state of another qubit. They
require quantum gates with multiple inputs and outputs,
namely multiple qubits gates, which are represented as
square matrices having a higher dimension. An example is
the controlled not (CN OT ):

CN OT =


1

0


0

0








0 0 0
1 0 0
0 0 1
0 1 0

(5)

This operation takes as input two qubits: the control qubit
and the target qubit. When the control qubit has state
|0i, the target qubit remains unchanged, whereas when
the control qubit has state |1i, a NOT gate is applied to
the target qubit. Please consider that in both cases, the
control qubit remains unchanged. By leveraging multiple
qubit gates, in particular the CNOT and the H gate, it
is possible to achieve the entanglement [33] among qubits,
which is a condition in which the state of a set of qubits
cannot be described anymore by considering the state of
a single qubit, but considering the system as a whole. An
entangled system is one whose quantum state cannot be
factored as a product of the states of its local constituents;
in other words, they are not discrete particles but rather
an indivisible totality. If two constituents are entangled,
one discrete particle cannot be properly deﬁned without
addressing the other. The state of a composite system
may always be expressed as a sum, or superposition, of
products of local constituent states; it is entangled if this
sum cannot be represented as a single product term [33].
In these cases, changing one qubit will aﬀect all other
constituents. This particular situation can be achieved (for
instance), if we put a CNOT gate on a two-qubit registry,
and the control qubit is in superposition (to be precise
the |+i = 1√
(|00i + |11i) state). Entanglement plays a
2

1

2

3

4

5

6

7

8

9

10

11

3

crucial role for quantum computing since it is necessary for
a quantum algorithm to oﬀer an exponential speed-up over
classical computations [34]. Indeed, changing the state of
an entangled qubit will immediately change the state of all
paired qubits, speeding up the process.

2.3. Quantum Measurement

The measurement, i.e., the process to obtain the infor-
mation of the qubits, is one of the most important oper-
ations appliable to qubits. Measurements are irreversible
and permanently force qubits to certain states (i.e., 0 or 1).
To be more precise, the probability of measuring a state |ψi
in any qubit state |xi is given by the following equation:

p(|xi) = | hx|ψi |2

(6)

This action has several implications. Any qubit in the
state |ψi = α |0i + β |1i has |α|2 probability to be found
in the state |0i, and |β|2 probability to be found in the
state |1i. Measurements alter the magnitudes of α and β.
For instance, if the result of the measurement is |1i, α is
changed to 0, and β is changed to the phase factor eiφ that
is no longer experimentally accessible. If a measurement is
performed on an entangled qubit, it may collapse the state
of the other entangled qubits.

2.4. Quantum Programming

Combining qubits and gates, we obtain the quantum
(logical) circuit, one of the most commonly used and general-
purpose quantum computing models [33]. This allows to
leverage on superposition and entanglement among qubits
and achieve a theoretical advantage over classical computers
in performing large-scale parallel computation [33].

To determine the type of transformation the circuit
performs, we need to analyze the structure of quantum
circuits, the number and the type of gates, and the inter-
connection scheme. The result of a quantum circuit can be
read out through quantum measurements.

from qiskit import QuantumCircuit
# Create a quantum circuit with two qubits
and classical bits :
qc = Quant umCircuit (2 ,2)
# Apply H - gate to the first :
qc . h (0)
# Apply a CNOT :
qc . cx (0 ,1)
# measure the qubits
qc . measure (0 ,0)
qc . measure (1 ,1)

Listing 1: Qiskit code for the bell state circuit.

Quantum programming is the process of designing and
building executable code that a quantum computer will
execute to obtain a particular result [35, 36]. A quantum
program contains classical code blocks and quantum com-
ponents. As a result, a typical quantum program contains
two types of instructions (or statements), namely quan-
tum and classical statements. On the one hand, classical

instructions work with the state of classical bits and ap-
ply conditional expressions. On the other hand, quantum
instructions operate on the state of qubits and measure
qubit values. These operations, which can be applied to
(single qubit) and (multiple qubits) and can be reversible,
are mainly represented as quantum circuits that manip-
ulate qubit register to perform quantum operations. At
the end of the operation, classical bit registers are used to
store quantum measurements.

Quantum programming, at the state of the practice,
heavily leverages libraries and APIs (e.g., Qiskit) to deﬁne
quantum circuits and run them on quantum machines.
Listing 1 shows the code of a simple circuit, which puts
the 2 qubits in an entangled state called bell state, which
is a state in which the only two possible measures can be
00 or 11, with a 50% probability each. As can be seen,
to assemble a quantum circuit, the class QuantumCircuit
is imported from the Qiskit library. Then, the quantum
gates are applied on the qubits invoking some API deﬁned
on the same QuantumCircuit class.

3. Related Work

Research in software engineering for quantum program-
ming, or quantum software engineering (QSE), is in its
infancy. During the ﬁrst International Workshop on Quan-
tum Software Engineering, researchers and practitioners
proposed a QSE manifesto, known as the “Talavera Mani-
festo", which deﬁnes the set of fundamental principles of
this new discipline [18, 19]. Some of these principles include
(i) agnosticism towards speciﬁc quantum technologies, (ii)
coexistence of classical and quantum programming, (iii)
support for developing and maintaining quantum software.
Since then, several studies have been presented discussing
challenges and potential direction in QSE research under
various perspectives. Details are reported in Table 1.

Piattini et al.

[3] deﬁned a set of topics on which
researchers should pay attention. In particular, after di-
gression on the “Golden Eras of Software Engineering”,
some priority areas for quantum software engineering were
explored. To be more precise, they pointed out 4 areas
of quantum software engineering which need high atten-
tion from developers: software design of quantum hybrid
systems, testing techniques for quantum programming,
quantum programs quality, and re-engineering and mod-
ernization toward classical-quantum information systems.
Finally, they provide some useful insights for researchers,
practitioners and universities, described in the following.
According to them, researchers should consider that many
quantum computer scientist do not have a suﬃcient knowl-
edge of software engineering techniques, so many errors
might be done again, and some expensive “rediscoveries”
could happen. Moreover, they think that researchers should
not wait until quantum programming languages would be
“stable” or “reﬁned” in order to propose, adapt or develop
software engineering quantum techniques, but develop them

in parallel with the evolution of the quantum languages.
Finally, they claim that researchers should take advantage
from the mistakes of the past and must rely on empirical
validation when proposing new software engineering quan-
tum techniques. This work, however, does not rely on a
documented and reproducible research methodology to ﬁnd
out the challenges, but leverages on the direct consequences
of the statements present in the “Talavera Manifesto”.

Zhao et al. [21] provided a complete overview of quan-
tum software engineering, including all aspects of the quan-
tum software life cycle (requirements analysis, design, im-
plementation, testing) as well as the critical topic of quan-
tum software reuse. The report also explored some of the
challenges and opportunities of the ﬁeld. They recognize
as critical that a comprehensive software engineering dis-
cipline emerges for the development of quantum software.
Moreover, this work deﬁnes the life cycle of quantum soft-
ware and leverages it as a basis for a comprehensive survey
of current research eﬀorts in quantum software engineering.
It also overviews quantum software testing and mainte-
nance and discusses some fundamental issues in quantum
software engineering. Similarly to Piattini et al.’s work [3],
this study does not exploit an empirical study to discover
the challenges of the ﬁeld, but relies on the open questions
posed by the surveyed studies.

The ﬁrst attempt to understand the challenges of quan-
tum programming from a developer perspective was made
by El Aoun et al. [25]. The paper reports on an empirical
investigation conducted analyzing the Stack Exchange fo-
rum, where developers ask and answer QSE-related topics,
and the GitHub issue reports, where developers raise QSE-
related concerns in real-world quantum computing projects.
First, the authors reviewed the categories of QSE-related
questions raised on Stack Exchange, based on an existing
taxonomy of question types on Stack Overﬂow. Afterward,
the subjects of QSE-related Stack Exchange posts and
GitHub bug reports were discovered using automated topic
modeling. Their main ﬁndings showed that the most asked
and answered issues in online forums are related to the
theory behind quantum programming, the usage of spe-
ciﬁc data structures and algorithms, the implementation of
quantum-related tasks, and the lack of learning resources.
This work diﬀers from ours from a methodological perspec-
tive: El Aoun et al. derive their set of challenges in QSE
from an automated approach (i.e., topic modeling), whilst
in our work, the taxonomy of quantum challenges is derived
from what developers pointed out as a challenge, having
explicitly asked them. Under this perspective, these two
approaches can be seen as complementary.

Finally, some other studies in the ﬁeld of quantum
software engineering have tackled a speciﬁc challenge, and
proposed preliminary solutions. For instance, some have
faced the challenge of artifact modeling [22, 37, 38, 23],
and others have discussed quality issues, ranging from the
deﬁnition of speciﬁc metrics, to debugging [39, 40, 41].

Our work puts its foundations on the idea that quantum
programming poses some challenges that research in quan-

4

Table 1: Comparison between the state-of-the art work which explicit challenges in quantum software engineering.

Paper Title

Methodology

Main Results

Toward a Quantum Soft-
ware Engineering [3]

Analysis of the impact that the rules deﬁned in
the Talavera Manifesto [18] can have in the ﬁelds
of software engineering.

In
Proposal of Some hot topics to focus on.
particular, some relevant advice is given to prac-
titioners, researchers and universities.

Quantum Software En-
gineering: Landscapes
and Horizons [21]

Understanding Quan-
tum Software Engineer-
An
ing Challenges:
Empirical
on
Stack Exchange Forums
and GitHub Issues [25]

Study

Our Work

Non-Systematic survey of the current literature
regarding quantum software engineering

Qualitative analysis of QSE-related questions
raised by developers on Stack Exchange forums.
Automated topic modeling to uncover the QSE-
related Stack Exchange posts and GitHub issue
reports.

Deﬁnition of a set of challenges divided by soft-
ware engineering areas, i.e., quantum require-
ments analysis, quantum software design, and
quantum software testing.

Highlighting some of the more diﬃcult aspects
of quantum software engineering that are dis-
tinct from traditional software engineering (e.g.,
explaining quantum code).

Combination of mining software reposito-
ries and a survey with practitioners.

Taxonomies of current usages and chal-
lenges, perceived by quantum program-
mers, of quantum programming.

tum software engineering should face. However, diﬀerently
from previous studies, we conducted a preliminary software
repository mining investigation, to better understand the
current usage of quantum programming technologies, and
then we surveyed quantum developers, asking directly to
them what they perceive as a challenge in their ﬁeld.

4. Research Methodology

The goal of our study was to investigate the current us-
age of quantum programming technologies and to explore
the challenges that quantum developers face nowadays,
with the purpose of assessing where software engineering
methods and practices can be applied and how. The per-
spective was of researchers, practitioners, and tool vendors:
the former are interested in understanding how software
engineering could steer the research in the quantum pro-
gramming ﬁeld, letting the challenges emerge; practitioners
are interested in gathering insights on how to engineer
software products that include quantum computing com-
ponents; tool vendors are instead interested in assessing
the current support provided to quantum developers, to
understand possible addressable limitations.

More speciﬁcally, our work was structured around two
main research questions. We started our investigation by as-
sessing the current usage of quantum programming, namely,
the developer’s purpose to employ quantum computing
frameworks in their products. An improved understanding
of these aspects may provide insights into the activities
developers typically perform with the support of quantum
computing and where software engineering might be more
needed. Speciﬁcally, we asked:

Figure 1: Graphical summary of the applied methodology. By mining
GitHub, we have obtained a set of repositories that we manually
classiﬁed. Afterward, we extracted the list of public emails of their
developers, whom we surveyed. We addressed RQ1 using the classiﬁ-
cation results, while we addressed RQ2 with the survey responses.

Once we had investigated the current adoption of quan-
tum programming in practice, we deepen our analysis to
identify the major challenges that quantum developers face
when dealing with the frameworks that make quantum
computing accessible and usable. Knowing the challenges
that developers typically encounter would help tool vendors
better assist developers and researchers in devising novel
techniques and approaches to deal with those issues. Hence,
we formulated the second research question:

RQ2. What are the main challenges that quantum de-
velopers are experiencing when interacting with quantum
frameworks?

RQ1. To what extent and for what purposes are quan-
tum programming frameworks being used?

We aimed at elaborating on the key challenges and
opportunities for software engineering when it turns to

5

Quantum Software  RepositoriesRepository AnalysisQuantum DevelopersDevelopers' SurveyRQ2RQ1GitHubquantum programming. In particular, we sought to elicit a
comprehensive set of challenges that would make quantum
developers’ daily programming tasks easier if addressed.

As an ultimate result of our empirical investigation,
we provided an improved view of how quantum program-
ming currently is and how it might potentially be, should
a software engineering process be successfully adopted. We
approached such an objective using multiple research in-
struments, as depicted in Figure 1 and detailed in the next
sections. In a nutshell, we employed software repository
mining and grounded theory to classify the current adop-
tion of quantum computing frameworks; then, we set up a
survey study to elicit the software engineering challenges
that quantum developers face. By design, our empirical
study can be classiﬁed as a mixed-method investigation
where both quantitative and qualitative methodologies are
employed [42]. In terms of reporting, we followed the recent
ACM/SIGSOFT Empirical Research Standards [43].5

4.1. Context of the Study

As explained in Section 2, universal gate quantum pro-
gramming is based on APIs provided by third-party li-
braries. For this reason, the scope of the work is mainly
delimited by the quantum technologies considered. To un-
derstand the current adoption and challenges of quantum
programming, we focused on understanding how third-
party libraries are used and their limitations from both a
technological and a socio-technical perspective. Hence, the
context of the study was focused on the three state-of-the-
practice universal gate quantum programming technologies,
i.e., Qiskit [11], Cirq [26], and Q] [27]. These three
frameworks represent the main instruments that quantum
developers can currently use. As shown later in the pa-
per, they are indeed used by over 95% of the open-source
projects on GitHub that include quantum components.

The frameworks are developed and maintained by three
big corporations that are widely involved in quantum
computing technologies, namely IBM, Google, and Mi-
crosoft. These technologies are widely recognized as
more mature and stable than others [44, 45], having their
own peculiar functionalities, and allowing to write and
run quantum programs on both local simulators and real
quantum devices provided by their vendors.

4.2. Data Collection

In our empirical study, we exploited two main sources
of information, i.e., the quantum software repositories and
the quantum developers. In the following, we describe the
steps we performed in the data collection phase, whilst the
data analysis process is described in the next section.

5Given our study and currently available standards, we followed
the general guidelines when reporting the study design and results.

4.2.1. Quantum Software Repositories

To understand the extent to which and how quantum
frameworks are currently used in practice, we ﬁrst adopted
a software repository mining approach aiming at ﬁnding
those projects which are hosted on GitHub that use at
least one of the considered technologies.

By means of the Python Client Library of the GitHub
REST APIs,6 we searched for code snippets (using the
search_code function) that indicated the use of the tech-
nologies we were interested in. More speciﬁcally, for
Qiskit and Cirq we looked for patterns like ‘from qiskit
import’ and ‘from cirq import’, respectively. Both
frameworks are written in Python and, therefore, de-
velopers must necessarily use those patterns to include
the libraries in their programs. In other words, the use of
these patterns ensured the identiﬁcation of all the repos-
itories that currently employ Qiskit and Cirq in their
code. When it turns to Q], we had to use a diﬀerent
strategy. Unlike the others, Q] is recognized by GitHub
as a programming language. For this reason, we could
directly look for the repositories written in such a language:
we used the search_repositories function, passing Q]
as language parameter. In our online appendix [46], we
released the source code developed for mining quantum
repositories. Overall, this process found a total of 731
unique repositories (442 using Qiskit, 217 using Cirq, 72
using Q]).

4.3. Quantum Software Developers

In the context of our empirical investigation, we needed
to collect opinions from developers of quantum-based appli-
cations. This step was harder than expected since quantum
programmers are a new category of developers that are
not necessarily computer scientists but also physicians,
chemists, and others. Therefore, we had to customize the
recruitment of the participants, the design of the survey,
and its dissemination.

Survey Recruitment. We took advantage of the soft-
ware repositories mined from GitHub to obtain a list of
eligible candidates for our survey. In this way, we ensured
to involve developers having some real experience with
quantum programming. Starting from the initial set of
2,399 unique developers, we selected only developers having
a public email to be contacted with. The email address
collection was done by exploiting the GitHub APIs. By
applying this selection criterion, we obtained a set of 984
developers. Of these, 79 had less than ten commits: we
excluded these developers as they might have only tan-
gentially contributed to the projects and, as such, they
might not have the adequate expertise and/or experience
to address our questions [47]. This ﬁlter led to a total of
905 contributors which could participate to our survey.

We employed an opt-in strategy [48] when involving
developers. We sent a ﬁrst email asking whether they

6PyGitHub: https://github.com/PyGithub/PyGithub

6

Question Text

Answer Type

Possible Answers

Table 2: Questions asked in the survey

Part 1 - Background
What is your current employment status?

What is your educational background?

What is your age range?

What is your gender?

Multiple Choice

Student; M.Sc.

B.Sc.
Student;
Ph.D. Student; Researcher; Open
Source Developer; Industrial Devel-
oper; Other

Single Choice

Computer
Physics; Other

Science;

Chemistry;

Single Choice

18-24; 25-34; 35-44; 45-54; 55+

Free Text

-

Please, indicate your expertise (in years) in Software Development.

Single Choice

None; 0-3; 3-5; 5-10; 10+

Please, indicate your expertise (in years) in Industrial Development.

Single Choice

None; 0-3; 3-5; 5-10; 10+

Please, indicate your expertise (in years) in Quantum Programming.

Single Choice

None; 0-3; 3-5; 5-10; 10+

What is your Country?

Free Text

-

Part 2 - Current Adoption
Which quantum technology are you most conﬁdent with?

Which other quantum technology do you use?

Single Choice

Qiskit; Cirq; Q]; Other

Multiple Choice

Qiskit; Cirq; Q]; Other

In which context are you using quantum computing?

Multiple Choice

Academic Study; Hackaton; Indus-
try; OSS; Personal Study; Research;
Other

Could you please tell more about the tasks you are performing with
quantum computing?

Long Free Text

-

Part 3 - Potential Adoption and Challenges
Consider the technology you are most conﬁdent with. What were the top
3 challenges that you have faced?

Based on your experience, have you ever solved (or tried to solve) a
problem using quantum programming which has no "traditional" solution
(or the solution is intractable)?

Multiple Free Text

-

Single Choice

Yes; No

If yes, could you please elaborate on the problem and why you have to
use quantum computing?

Long Free Text

-

Based on your experience, have you ever solved (or tried to solve) a
problem that has a "traditional" solution using quantum programming?

Single Choice

Yes; No

If yes, could you please elaborate on what it was and explain why you
chose to use quantum computing?

Long Free Text

-

would have liked to participate in our survey study and,
only in case of positive feedback, we sent them additional
instructions. With this strategy we recruited 56 volunteers
and mitigated possible legal concerns [49]. Nonetheless,
it might have led to self-selection or voluntary response
bias [50, 51]. To mitigate this, we introduced a prize of
four Amazon gift cards with a total value of $100.

Survey Design. The survey was composed of three
main sections, as reported in Table 2. The ﬁrst one aimed
at gathering the background of the participants. Besides

asking about their current employment and their experience
with software development, industrial development, and
quantum programming, we asked for information about
gender and country (in a free text form, as recommended by
recent research [52, 53]) and educational background. This
latter question was intended to understand more closely
the expertise of the current population of quantum pro-
grammers; such information might be interesting to reveal
cultural barriers to quantum software engineering [54].

The second section of the survey aimed at gathering

7

developer’s opinions about the current use of quantum
technologies. We ﬁrst asked which of the available frame-
works they use and, more in general, the technologies they
are typically comfortable with. Afterward, we asked the
reason behind the use of quantum programming. This
question was essential to understand better why quantum
technologies are currently employed, e.g., for an academic
interest or for a personal study of how to program using
quantum computing. In addition, this question enabled us
to complement the grounded-theory exercise conducted to
address RQ1 (more details are reported in Section 4.4).

The last section targeted the longer-term adoption of
quantum technologies. More particularly, it aimed at as-
sessing the main challenges currently faced by developers
when adopting the quantum framework they are most com-
fortable with. This question sought to elicit the most
relevant limitations of the existing instruments, potentially
highlighting the most pressing issues and challenges that
researchers and tool vendors might need to pay attention to.
Afterward, we focused on the interplay between quantum
and traditional computing. Finally, it aimed at analyz-
ing whether developers addressed or are trying to address
problems with and without traditional or tractable solu-
tions through the adoption of quantum technologies. In
both cases, we asked to further elaborate on the speciﬁc
problems treated and the rationale behind the use of quan-
tum programming. Answers to these questions helped
us to understand how far quantum technologies are from
solving real-case problems and the software engineering
methodologies and tools required to support developers.

Survey Dissemination. The survey was developed
and disseminated to participants using LimeSurvey,7 an
open-source survey editor released under GNU-GPL license.
The questionnaire was available from June 1 to June 30,
2021. The survey link was sent to every recruited developer
via e-mail. We estimated a completion time of 15 minutes.
Ethical and Privacy Considerations. In our coun-
try, it is not mandatory yet to seek approval from an Ethical
Review Board when releasing surveys and experiments with
human subjects. Nonetheless, we took into account several
possible ethical and privacy concerns. In the ﬁrst place, we
guaranteed the participants’ privacy by not asking their
names or email addresses, hence gathering anonymous an-
swers. When recruiting developers, we clearly stated the
goal of the survey study, as well as explicitly report that
the given answers would have been used in the scope of
a research activity that would not have any intention of
publishing sensitive data. We also clariﬁed that completed
surveys would eventually become public, although guar-
anteeing their privacy. Finally, opting for an open-source
survey tool avoided ethical concerns that might have po-
tentially led participants to feel uncomfortable answering
questions using commercial editors (e.g., Google Forms).
Indeed, previous work [55] showed that this aspect impacts

7LimeSurvey website: https://www.limesurvey.org.

8

the potential response rate in survey studies.

4.4. Data Analysis

Once we had collected all the required data, we ad-
dressed our research questions. To answer the ﬁrst research
question (RQ1), we employed the information coming from
both the repository mining and the ﬁrst two parts of the
developers’ survey. To answer the second research ques-
tion (RQ2) we only relied on the responses provided to
the third part of the survey. The investigation into the
purposes of the repositories collected from GitHub and
the challenges from the developer’s survey share the same
methodology. In particular, in both cases, we applied a
systematic approach that constructs theories applying a
methodical gathering and analysis of the data, known as
Straussian Grounded Theory [56]. This methodology does
not assume previous theoretical formulation but rather
adopts an approach wherefore a theory is directly and
solely generated from data. As for the other data collected
from the survey, i.e., the background and current adoption
of quantum programming, we mainly relied on statistics.
More details are reported in the following.

Application of Straussian Grounded Theory. The

ﬁrst author (i.e., hereafter, the main inspector) extracted
the excerpts from the textual data we had.
In the
context of the repository analysis, the excerpts were
README ﬁles and repository descriptions (translated in
English if written in another language) of each analyzed
If both README ﬁle and the repository
repository.
description were missing, we labeled the purpose of the
repository as “Unknown”. As for the survey, the excerpts
were the individual answers provided by developers.
The main inspector applied open coding [56], which
is the process of taking the excerpts and continuously
comparing and contrasting them with other excerpts,
with the ﬁnal aim of grouping them, and thus giving
them a code. These excerpts were considered based
on semantic similarity [57]. This process was also
carried out individually by the other two inspectors (the
second and third author of the paper) to have coding
as unbiased as possible. To validate this step, we also
computed their agreement in terms of Fleiss’ k [58].

Once the inspectors assigned the codes to the excerpts,
they proceeded with the axial coding step [56], which
consists of grouping into categories the codes found in the
previous step. Alongside the open coding, it is a cyclical
process since new excerpts and examined categories might
contradict, support, or expand the existing codes and
categories. When additional excepts do not expand upon
the found code and categories, theoretical saturation [56,
59] is reached, i.e., the point at which codes and categories
are stabilized and ﬁxed.

The resulting taxonomy collects all the codes and cate-
gories, resulting from the open and axial coding steps,
linked together by a common aspect (or core category),

Figure 2: Partition of the repository per class of usage.

Figure 4: Distribution of developers by kind of repository. Toy
projects have a distribution skewed on the minimum (1), whilst
Framework ones have a much wider distribution of contributors.

Figure 3: Number of contributors per type of repository.

found by selective coding [56]. This core category repre-
sents the foundation on which the answers to our research
questions rely.

Analysis of Other Survey Information. We analyzed
the ﬁrst two sections of the survey to understand the
background of the developers in our sample and their take
on the current adoption of quantum programming. The
demographics of the surveyed developers and their cur-
rent employment status were summarized using statistics.
Furthermore, we analyzed the distribution of contributors
per repository category and the distribution of reposito-
ries per developer. These distributions were compared
against the answers obtained from the survey to add
qualitative insights to the repository analysis previously
conducted.

5. RQ1. On the Current Usage of Quantum Pro-

gramming

The analysis of 731 repositories led to a taxonomy of
the current usage of quantum programming technologies,
reported in Table 3. The taxonomy is composed of six
categories, representing the high-level purpose for which
the repository was created, e.g., study purposes. Figure 2
summarizes the repositories partitioned using the taxon-
omy that we have built, Figure 3 plots the distribution of
developers per kind of repository, whilst Figure 4 depicts

9

Figure 5: Distribution of repositories per single developer. The
median value insists on 1, indicating that most quantum developers
have contributed only to a single repository.

the distribution of developers by type of repository. It must
be pointed out that the total number of unique contribu-
tors found is 2,399, which is not obtainable by summing
up all the values reported in Figure 3. The reason is that
a developer might be contributing to more than a single
repository. To this extent, we also analyzed the number
of repositories for single developers, whose distribution is
reported in Figure 5. It is possible to note that, although
some developers might have been counted more than once
in Figure 3, the majority we took into consideration has
contributed just to a single repository. Thus the number of
developers per class of repositories is much more signiﬁcant.
Since quantum programming is still in its infancy, the
main purpose of use is for exercise or personal study. The
hosted code aims to explore the features of quantum pro-
gramming and, in general, is not intended to become a
real-world software. This is proved by the fact that 41% of
the analyzed repositories belong to this category. However,
as shown in Figure 3 only 548 developers contribute to this
kind of repositories, since most of these repositories have
only one single contributor, as shown in Figure 4. Some ex-
ample of projects developed for such purpose are quantum
games, i.e., small and generally text-based games, which
leverage the power of real randomness given by the qubits

Label Name

Purpose

Example

Table 3: Summary of the labels employed in the classiﬁcation of the mined repositories

Exercise/Toy

Repository containing toy projects or collection
of sample code.

ryuNagai/QML. Repository containing exper-
imental code on Quantum Machine Learning.

Hackaton/Assignment Repository containing code developed for a hack-

aton or a school assignment.

oliverfunk/quantum-natural-gradient
Quantum Natural Gradient implemention in
Qiskit for the 2019 Qiskit Africa Camp.

Library/Framework

Repository containing code composing a library
or a framework.

Davidelanz/quantum-robot.
Package for
quantum-like perception modeling for robotics.

Research

Teaching

Tool

Unknown

Repository containing code belonging to a paper
or research appendix.

Repository containing code that complements a
lecture or a textbook.

Repository containing code for a supporting tool,
e.g., a quantum compiler.

Repository containing code not classiﬁable by
reading the README or the Description or not
having any of them.

BramDo/custom-cx-gate-on-Casablanca.
Code of Qiskit Pulse - Programming Quantum
Computers Through the Cloud with Pulses.

kongju/QML. Lecture notes and the code for
the course on Quantum Machine Learning oﬀered
by University of Toronto on edX.

mtreinish/bqskit-qiskit-synthesis-plugin.
This repository contains a PoC unitary synthesis
plugin for Qiskit.

eggerdj/backends. Repository missing both
the README and the Description.

to generate random worlds, or scenarios. These are directly
correlated with the third-largest slice of repositories, which
is composed of repositories developed during hackathons
or class assignments.

The other main purpose for which quantum program-
ming is used is to develop quantum libraries or frameworks,
which represent the 16% of the total repositories. This out-
come is indeed reasonably expected since quantum technolo-
gies currently under development are mostly open-source
(e.g., Qiskit, Cirq). Moreover, domain- and task-speciﬁc
libraries are also emerging (e.g., quantum machine learn-
ing or chemistry ones). This is the second top class of
repositories for number of contributors (1792), and the
class of repositories having the most variable distribution
of contributors, with a median value of 3.

Online appendices of research papers or related research
projects represent 11% of the considered repositories. This
result is in line with the fact that quantum programming
is still a neat ﬁeld in the vast plethora of computer science
and physics research. Although being the top class for
number of developers (1915), the distribution of developers
ranges from 1 to 375, with 1 as median value.

The remaining cases of use of quantum programming
represent only a small percentage over the total. Evidence
has been observed of material used for teaching purposes:
book appendices, blog posts, etc.
represent 7% of the
analyzed repositories. There are also some tools among
the repositories that we have inspected (3%), but these,
along with teaching materials, were never mentioned by

Figure 6: Educational Background of the Survey Participants.

the surveyed developers.

Insights from the developers. Figure 6 depicts the
educational background of the survey participants. Most
of the respondents to the survey had a computer science
background (55% of the total), while 20% had a physics
one. The remaining 25% of the respondents have other
backgrounds, e.g., Mathematics, electrical engineering, civil
engineering. 71% of the participants were younger than 35
years, with most of them (39%) belonging to the 25-34 age
range. Another 21% have an age between 35 and 44 years.
Finally, 4% of them belong to the 45-54 age range; the last
4% are older than 54 years.

Figure 7 shows the employment status of the partici-
pants at the time of the survey, divided by used technologies.

10

advantages of quantum computation over the classical one
(e.g., applying the Shor algorithm for the factorization).
This reinforces the idea that the current use of quantum
programming is mainly didactic.

Main ﬁndings for RQ1

Quantum programming technologies are used mostly for
personal study purposes: 41% of the analyzed reposito-
ries were created for this. On the other hand, framework
and research repositories have the largest number of
contributors, meaning that a major eﬀort is put in these
activities. The conclusion is supported by the survey
that showcased that most respondents were involved
in research or frameworks development activities.

6. RQ2. On the Current Challenges of Quantum

Programming

Figure 8 depicts a hierarchical taxonomy of the chal-
lenges in quantum programming that we have constructed
as outcome of the Straussian Grounded Theory excercise
described in 4. Some categories have just one layer, while
others have been partitioned. In particular, some categories
presented a set of challenges that were much more cohesive
than others, and thus they do not need a specialized cat-
egory to be described. In the following, we describe each
category (alongside their sub-categories) of challenges.
(cid:147) Environment (A) The problems described in this
macro-category are all related to the quantum environment,
both in terms of hardware and software.

Software Infrastructure (A.1) The challenges in this
area range from those relating to the framework being
utilized to those relating to the execution environment.
Framework (A.1.1). Challenges regarding the frame-
works are mainly related to API design, missing features
and standardization. In particular, 15 participants mostly
complained about the ‘‘constant changes in API ” of quan-
tum technologies, which often are not correlated with
an adequate “deprecation policy”. Other 2 developers
complained of lacking features. For instance, “some kind
of operations are not directly supported by Qiskit”, or
“Are not supported quantum operations among diﬀerent
circuits, which could be interesting to develop operations
in diﬀerent nodes, for Quantum Networks”. A set of
12 participants also pointed out challenges concerning
“gate deﬁnitions” and “endianess of the qubits”, which
diﬀer from framework to framework. i.e., standardization
problems. Some technologies implement concepts (e.g.,
quantum gates) diﬀerently from how they are deﬁned in
theory and thus hindering the actual development pro-
cess. “Conventions and standards haven’t fully solidiﬁed
across the industry yet”. Standardization challenges are
revealed also in the form of lack of abstraction. At the
time of writing, quantum programs are generally written

Figure 7: Employment Status of the Survey Participants, divided by
main tchnology used.

Most of the participants are Open Source Developers (17),
although the majority of them (31) are involved in academia
(12 BSc Students, 11 MSc Students, 8 Ph.D. Students). Re-
searchers and Industrial developers include 12 people each.
It is also possible to notice that the most used technology
is indeed Qiskit in almost all the employments categories,
except for industrial developers, who mostly use Q] and
other technologies. Cirq is the least used technology by
all the categories. It is worth pointing out that researchers
only employ Qiskit and Q]. Most of the respondents
(27%) come from the USA, while the other countries with
the highest number of respondents are India (12%) and
Italy (9%). The other respondents mainly come from Eu-
ropean countries (i.e., France, Germany, Greece, Poland,
Portugal, Spain, Sweden, Switzerland, United Kingdom),
Eastern countries (i.e., China, Japan, Israel, Turkey), and
American countries (i.e., Canada, Colombia, Mexico).

The results of the survey show that most of the in-
terviewees (29%) indeed use quantum programming for
personal learning. Another large group of users of quan-
tum programming belongs to those who carry out research,
who are divided into two categories, namely those who
use quantum programming for research, and those who
actually do research on quantum programming. The ﬁrst
group is represented by 14% of the interviewees, while the
second by 23%, for a total of 37% developers using quan-
tum programming for research activities. Another 14% of
survey respondents use quantum programming to develop
technologies for quantum programming itself.

Another interesting result that emerges by analyzing
of the answers given to the last questions of the third
part of the survey, i.e., whether the respondent has ever
applied quantum computing for an intractable classical
computation problem (and what was it), and whether
the interviewee has ever applied quantum computing to
a problem solvable with classical computation (and what
was it). The analysis of these answers show that few
respondents have tried it, and the problems solved are
actually those which are used as an example to show the

11

Figure 8: Graphical representation of the obtained taxonomy of quantum computing challenges.

in quantum circuits interacting with classical code. To
some extent, a quantum computer is programmed at
a very low level of abstraction compared to traditional
computers. Having a low level of programming inevitably
raises some issues, such as code portability and “inter-
facing with a wide variety of hardware platforms”. In
general, as other developers pointed out, quantum code
written with a speciﬁc technology is meant to be run
on the machines that the technology vendor oﬀers, thus
leading to vendor lock-in. Finally, although some tech-
nologies oﬀer ready-to-use implementations, developers
must implement quantum algorithms from scratch, rely-
ing on what the platform oﬀers. Some developers, ﬁnally,
(4) complained about defects within the used framework
(e.g., “Incorrect noise modeling of CX gates in parallel”).
Integration (A.1.2) . All challenges related to integrat-
ing quantum systems with traditional ones were reported
by 6 participants. Developers, for instance, found it
challenging to “integrating a classical algorithm into its
quantum analog” or “ Connecting quantum computers to
blockchain networks”.
Execution (A.1.3). The reported challenges falling in
this category are related to the execution environment,
and were reported by 11 survey participants. They strug-
gle with setting up execution environments, simulators, or
classical systems with which quantum programs interact,
hindering their ability to execute their programs.

Hardware Infrastructure (A.2) This category groups
together challenges that somehow relate to hardware as-
pects, ranging from the “bare metal” to the performances.
Hardware (A.2.1) Reported hardware challenges fall
into this category. Quantum programming requires spe-
cialized hardware, which is under constant development.
At the time of writing, we have access to quantum com-
puters with a limited small number of qubits. Therefore,
large-scale applications cannot be eﬀectively developed.

“No real quantum computer to work on”, “lack of hard-
ware support”, “access that is limited to small quantum
devices” are examples of this category of challenges devel-
opers face. Finally, quantum computers suﬀer from noise
because of the relative immaturity of quantum technolo-
gies and some physical limitations (e.g., “IBM’s hardware
has an error rate that is too high for many purposes”,
“qubits propagate error to others while entangling”).
Performance (A.2.2). Quantum hardware is limited,
so vendors oﬀer emulators to run quantum programs
on classical computers. This leads to another set of
challenges related to performance. Emulators are re-
source greedy, and limit the actual execution of quantum
programs (‘‘Performance of emulators - even with few
qubits”, “Qiskit objects use memory ineﬃciently, which
made them too slow and memory hungry.”). Similarly,
running programs on real quantum devices “takes time to
complete execution”, since vendors queue jobs to guaran-
tee free access to everyone. Finally, a lack of optimization
given by the vendors causes troubles to developers, who
complain “Poor optimization of operations” and compile-
time issues (“Qiskit does not have support in its pipeline
for optimizing synthesis for more than 2 qubits”).

(cid:147) Comprehension (B) This macro-category refers to
all the challenges that developers face in comprehending
quantum programs, in all facets. Thus, this category ranges
from challenges which are inherent to the documentations
of the frameworks, to challenges that are inherent to (lack
of) theoretical grounds.

Theoretical Grounds (B.1) This category includes all
those challenges that are related to learning quantum
technologies. A set of 20 respondents reported that many
concepts are needed to get acquainted with quantum
programming, particularly linear algebra. Moreover, it
was pointed out that programming a quantum computer
is completely diﬀerent, and many found it challenging to

12

theoretically understand new concepts related to quan-
tum circuits and quantum gates. For instance, as one
developer reported, it is fairly challenging “designing a
circuit in terms of the basis gates of the QPU to reduce
the computational cost to perform a desired task”.

Documentation (B.2) The category represents chal-
lenges related to documentation that developers face
when approaching quantum technologies. Most of the
reported challenges complain about poor consistency in
the documentation, and lack of proper getting started
material.
Documentation Comprehensibility (B.2.1). Chal-
lenges falling into this category include inconsistent tu-
torials that make diﬃcult to completely understand the
technology, and, as a consequence, hinder the actual
learning process of the quantum technology. This was
pointed out by 3 participants
Documentation Quality (B.2.1). Among all the par-
ticipants, 16 of them pointed out problems related to the
quality of the provided documentation. “Documentation
out-of-date or not comprehensive enough”, “Outdated and
erroneous documentation”, or “Missing Documentation”
are some examples of the reported complaints.

(cid:147) Coding (C) In this category fall all the reported chal-
lenges related to coding quantum programs.

Implementation (C.1) Challenges in this category re-

late to the implementation activities.
IDE (C.1.1). Although not necessary, it is known that
a good IDE makes the diﬀerence when programming:
quantum programming makes no exception. However,
some developers (3) have pointed out some IDE-related
challenges that hinder, rather than helping, their devel-
opment tasks. For instance, many found it diﬃcult to
work with the Q] environment, particularly with the IDE.
Others pointed out that working with Qiskit IDEs and
Language extensions resulted in an unstable experience
on particular hardware architectures. Finally, when it
comes to plotting the deﬁned circuit, the IDE does not
allow a clear visualization, making coding even harder.
Compilation (C.1.2). Quantum circuits are deﬁned
based on quantum technologies that must be compiled
to be executed on real quantum machines. The cur-
rent models for quantum computing require quantum
algorithms to be speciﬁed as quantum circuits on ideal
hardware, ignoring hardware-speciﬁc details. Although
such modeling should make programs more portable and
allow developers not to concentrate on hardware-speciﬁc
issues [60], such programs need to be translated into code
that quantum computers can execute, i.e., need to be
compiled [60]. However, as 4 participants said, “adapting
ideal quantum circuits to available device architectures”
is a tough challenge for developers, particularly, “hard to
write compiler passes” since “non standard benchmarking
on compilation depths” are available.

13

Code Quality (C.2) The challenges that fall into this
category are related to traditional code quality problems,
e.g., testability, debugging, and readability.
Debugging (C.2.1)
Some participants (11) have
pointed out that they often found it challenging to un-
derstand the error messages given by the execution of
quantum programs or even the code itself. Debugging
these errors is even more complicated, if we consider the
uniqueness of this new programming paradigm.
Testability (C.2.2) Understanding if a program per-
forms as intended is a fundamental concept in program-
ming. However, it is not so simple for quantum program-
ming: 4 respondents have pointed out that “being able
to check that the circuit does what you want it to do” is
particularly challenging. In particular, they pointed out
that a major problem “the little understanding of what
should the result look like resulting in a lack of common
sense regarding the correctness of the result”.
Readability (C.2.3) Another quality-related set of chal-
lenges is readability, as pointed out by 1 respondent.
Since the quantum code consists of deﬁning a register of
qubits and applying gates on them, one of the challenges
pointed out by developers is “creating a readable code”.

(cid:147) Degree of Realism (D) This category of challenges
involves the applicability of quantum programming to solve
real-world problems. In theory, quantum computers should
allow developers to solve problems that classical comput-
ers cannot solve. Nevertheless, in practice, there are still
hardware and performance limitations, which were pointed
out by 10 respondents. “Finding interesting use cases”,
“Using quantum computers on real products”, or “Formu-
late a problem” are only a few examples of the kind of
challenges reported by developers. Many people also ﬁnd
it challenging to design quantum programs able to solve
real problems or design their quantum algorithms since
“There aren’t yet many problems that quantum can solve
that traditional tech can’t”.
(cid:147) Community (E) Challenges in this category concern
the lack of a community to interact with. Indeed, many
developers wish to have other people they can compare
their work with and ﬁnd support: 12 respondents reported
that they suﬀer from “lack of professional connections; lack
of peer guidance”. These kind of challenges also concern
the diﬃculty of performing code reviews because of missing
peers. In particular, developers pointed out that “Code
reviews are slow”, and the issue aﬀects the entire review
process. Furthermore, the additional eﬀort necessary to
comprehend the programs does not promote code reviews
for developers who want to “learn to review the source code
to understand how to use some features”.

Main ﬁndings for RQ2

Our results identify challenges related to the compre-
hension of quantum programs, the hardness of setting
up hardware and software infrastructures, the imple-
mentation and code quality issues, the diﬃculty of
building a quantum developer’s community, and the
lack of realism of the current quantum applications.

7. Discussion and Implications

Our study’s key ﬁndings clearly show that quantum
programming is still an emerging subject, even though the
software engineering approaches available to developers are
still limited, and, perhaps more crucially, there are few
real-world applications for quantum technology. Both the
research questions of the study converge toward a clear
implication for the research community:

⁄ Take Away Message. There is the need for a joint
research eﬀort toward the deﬁnition of follow-up empirical
studies aiming at delving into the quantum programmers’
needs, alongside to the development of tools that these
programmers can use to comprehend, set up the required
infrastructure, implement, and verify quantum programs.
Our study deﬁned a set of research directions to pursue,
represented by the challenges deﬁned in our taxonomy,
along with concrete and speciﬁc problems that quantum
programmers currently experience and that the research
community is called to address.

While the key take away message is similar to what has
been somehow reported in early research on the matter
[3, 18, 21, 25], we aimed at elaborating more on this point.
By nature, survey studies like the one we conducted
in this paper might not necessarily provide insights at a
granularity level that would allow a proper understanding
and analysis of the developer’s opinions [61]. For instance,
some of the open answers might not be clear enough or
might even be contrasting. For this reason, we decided to
complement the insights from the survey with additional,
ﬁner-grained observations into the potential adoption of
quantum technologies and the role of software engineering
for quantum programming. To this aim, we created several
discussion groups on developer’s forums. Being these dis-
cussions deﬁned after the analysis of the survey responses,
our goal was to clarify or explore more closely some of
the aspects mentioned in the survey rather than creating
generic discussions about quantum software engineering.

We opted for Reddit,8 a popular social news aggre-
gation, web content rating, and discussion website that
developers often use to discuss open issues and challenges
on various computer science-related subjects [62].
In
particular, Reddit allows the creation of the so-called

sub-reddits, i.e., discussion channels dedicated to speciﬁc
matters. In our case, there exist three sub-reddits ded-
icated to quantum computing and programming, e.g.,
9
‘r/QuantumComputing’, ‘r/Qiskit’, and ‘r/cirq’.
Hence, also in this case we could target a population of
developers that are currently working on quantum pro-
gramming.

As already mentioned, the goal of such an additional
analysis was to let developers discuss speciﬁc aspects that
were found to be particularly interesting, contrasting, or
unclear from the survey responses. These pieces of informa-
tion were extracted from the ﬁrst author of the paper after
the survey analysis. For each of the identiﬁed discussion
points, we created a post where we presented ourselves,
the goals of the study, and the topic we were interested in.
We asked developers to comment and provide their take
on it. As an example, let consider the case of theoretical
ground—this is one of the key challenges discovered and
detailed in Section 6. We created the following post (the
introductory part is omitted for the sake of brevity):

Discussion - Example. It seems that this documenta-
tion, although simplifying most of the concepts related
to quantum mechanics, is still really hard to understand,
and most of the parts assume a deep knowledge of linear
algebra. Is there a way for a beginner who has mainly a
computer science background to start programming with
quantum technologies?

As shown, the post aimed to engage developers in a
discussion on how to use the documentation of quantum
frameworks to start programming with quantum technolo-
gies. Similar posts were created for the other discussion
points: the complete list of posts is available in our online
appendix [46]. Overall, we obtained around 30 answers.

Among these discussions, we found of particular in-
terest the ones about the real applicability of quantum
programming and the diﬃculty for a practitioner with only
a computer science background to cope with these tech-
nologies, along with other questions regarding code quality
issues. An interesting point of discussion was concerned
the lack of abstraction which aﬀect the quantum technolo-
gies taken into consideration. We found out that the idea
of programming is completely diﬀerent, which “is more
like designing circuits rather than programming the high
level stuﬀ. Much like probably 60 to 70 years ago when the
concept of computers wasn’t well deﬁned and those which
existed back then were speciﬁc purpose computers and mak-
ing them would require designing circuits (similar to what
we are doing in Quantum programming).” This comment
suggests that the software engineering researchers might
take advantage of the methodologies deﬁned in the past,
which resulted in the software and abstraction layers that
we currently have, to apply them to quantum computers.
As for the background challenge, we found something

8Reddit website: https://www.reddit.com.

9At the submission date, there was no sub-reddits speciﬁc for Q#.

14

interesting. While it is generally recognized that to be able
to program a quantum computer a knowledge of quantum
physics and advanced linear algebra is required, the dis-
cussions we had let emerge it as a misconception or false
myth of quantum programming. This was made clear by
one of the developers who reported that: “Much like how
a deep understanding of the band structure of the Silicon
in a CPU is not required to do computer science, the end
goal of quantum programming is to be able to program on
a quantum computer without needing knowledge of what is
physically happening to the qubits during the computation”.
Of course, being familiar with some notion of math can
help in having a better understanding of the underlying
technology, but is not mandatory to be a quantum physics
expert—indeed, many books have been published which
propose an “hands on” approach, such as the one written
by Johnston et al. [63].

Speaking about misconceptions, what emerges from the
discussions about the use of quantum programming in real
world applications is that many developers struggle to ﬁnd
an actual application of these algorithms. These discussions
lead to the idea that quantum computer might sometime re-
place digital computers, and developers are adapting their
programming abilities to achieve that. However, what we
know now is that a complete replacement of digital com-
puter is not a matter of near future, given several technical
limitations. One of the developers that discussed with us
about this topic (using Grover’s Algorithm as an example),
said that “real world use cases of Grover’s algorithm would
deﬁnitely take at least thousands of fault tolerant qubits,
which at the moment would require millions of noisy qubis”,
which the current state of the art technology cannot give.
What we are really able to do with quantum computer is
solving optimization problems exploiting variational quan-
tum algorithms on near terms devices (i.e., the quantum
computers available so far) [64, 65, 66]. In this scenario, a
quantum computer should be seen as an external compu-
tational unit (Quantum Computational Unit, QPU), and
programmed with that idea in mind, just as Graphical
Processing Units (GPUs) are programmed [63]. Thus, we
can claim that all the challenges which we have shown
should be solved by software engineering research with this
idea in mind, trying to apply the acquired knowledge with
GPU programming and all its issues and challenges to this
new emerging ﬁeld. Remembering that as Booch remarks
[67]: “No matter the medium or the technology or the
domain, the fundamentals of sound software engineering
will always apply: craft sound abstractions.” Without this
in mind, misconceptions are behind the corner, making us
far from software engineering for quantum programming.
The message for practitioners aiming at joining the QSE
challenge derives from this: quantum programming should
not be considered the panacea of all evils; its current appli-
cations are still minimal, expecially at the industry level.
Practitioners should focus on leveraging the beneﬁts of
quantum programming in particular situations. In doing
so, they could develop new software engineering methods

15

and tools to boost the research in the ﬁeld.

8. Threats to Validity

A number of threats might have possibly inﬂuenced the
results of our study. In the following, we report and discuss
how we mitigated them.

8.1. Threats to Construct Validity

Threats to construct validity concern the relationship
between hypotheses and observations. When studying the
current adoption of quantum programming (RQ1), we
mined repositories using search strategies aiming at identi-
fying all the projects using the most widely used quantum
frameworks available to date. These strategies pertain to
source code patterns that developers must necessarily use
to include the frameworks in their code or, in the case of
Q], through the features provided by GitHub. In any case,
our mining strategies represent the only available, hence
ensuring the maximum coverage possible. In this respect,
we can claim that the analysis done is extensive and not
threatened by false positive or false negative projects.

As for RQ2, whenever needed we deﬁned free text
answers to let practitioners express their opinions freely,
without any restriction. As for the participants involved,
we invited developers who contributed to the GitHub
projects relying on quantum frameworks. Based on the
considerations done for the projects selection, we can ensure
that the developers involved in the survey are the ones that
are actually working on open-source quantum projects.
In addition, we excluded the developers who contributed
to those projects with less than ten commits. This was
done to make sure to rely on the opinions of developers
who had done signiﬁcant contributions in terms of quantum
programming. Nonetheless, replications of the survey study
would be beneﬁcial to discover additional points of view
and perspectives on the state of quantum programming.

8.2. Threats to Conclusion Validity

A threat of this kind which might aﬀect the validity of
our study is related with the subjectivity of the constructed
taxonomies, either the one regarding the current adoption
of quantum technologies or the one related to the quantum
programming challenges, which might result in a biased
classiﬁcation. In both cases we iteratively built them by
splitting and aggregating categories, following a rigorous
schemed procedure. Moreover, diﬀerent authors have taken
part of the taxonomy building phase, which provides more
conﬁdence of the result achieved. Anyway, also in this case
replications would be desirable. To ease the work of other
researchers, we released all the material produced in the
context of this study in our online appendix [46].

8.3. Threats to External Validity

These threats concern with the generalization of our
results. First, the scope of this study is limited to the quan-
tum logic gate model of quantum computing. On the one
hand, we did focus on a single model given the exploratory
nature of the study. On the other hand, follow-up studies
on other quantum models, such as the very promising quan-
tum annealing one, are already part of our research agenda.
The study considers the three state-of-the-practice and
most mature quantum technologies available so far [44, 45],
namely Qiskit [11], Cirq [26], and Q] [27]. While other
quantum frameworks are emerging, we leave to further
research the willingness to compare the results achieved
in our empirical study. It must also be considered that
our study focuses solely on open-source quantum projects,
which can be freely mined and analyzed. Thus the se-
lected repositories only come from GitHub which oﬀers
a plethora of mining tools. We are aware that other host-
ing platforms are available (e.g., Quantum Programming
Studio), although not automatically minable; therefore, we
acknowledge a threat to validity to the generalizability of
our results. It is worth mentioning that the latter platform
is technology-agnostic: its inclusion in our work would have
been out of scope since the circuits were not designed for the
languages we took into consideration but rather translated.
They can only host quantum circuits (i.e., algorithms) and
not entire quantum applications (which require a classical
part). Finally, our results observations might not be valid
in industrial contexts. We acknowledge a limitation of our
study, limited by the proprietary and closed-source nature
of industrial code. The majority of the mined repositories
are developed for didactic purposes, which might represent
a potential bias to the ﬁnal results. This characteristic
might have biased the results, especially in the case of the
faced challenges, which might pertain mainly to developers
who are learning the quantum technologies under consid-
eration. Therefore, we plan to replicate this study once
quantum programming is more mature and pervasive to
improve the generalizability of the already achieved results,
targeting a diﬀerent population of developers. Another
potential threat might be represented by the fact that we
selected only developers coming from the contributors of
the mined GitHub repositories. On the one hand, this
might introduce a bias in the generalizability of the study.
On the other hand, we had to select a very niche set of
developers, so we chose stricter selection criteria. Another
potential threat might be represented by the response rate
achieved when involving developers in the survey study. In
particular, we got an answer from 56 out of 905 contacted
developers, which corresponds to a response rate of 6,1%.
Such a response rate is in line with respect to other papers
that conducted survey studies in software engineering [68]:
as such, we deemed the response rate to be good enough.
Of course, further experimentation might reveal additional
insights that were not discussed by the participants of our
study. Finally, the selection criteria we adopted (as recom-
mended by Sugar et al. [47]) might have excluded a more

diverse and potentially more experienced population of
developers. We are aware of this risk, and we will consider
diﬀerent selection criteria in the follow-up studies.

9. Conclusions

We have conducted an exploratory study into the cur-
rent state of quantum programming. First, we applied a
manual coding exercise to understand for which purposes
the currently available software repositories that use quan-
tum technologies are created. Secondly, we surveyed 56
quantum programmers, inquiring them on the current us-
age and challenges they face when interacting with the
state of the practice quantum frameworks, i.e., Qiskit [11],
Cirq [26], and Q] [27]. The results of our empirical study
revealed that quantum programming is mainly used for
didactic purposes or for curiosity to experiment with quan-
tum technologies. In addition, the survey study shed light
on several challenges which are not only related to technical
aspects of quantum development but also socio-technical
matters, such as the comprehension challenges, the degree
of realism, and the community ones.

The output of the study represents the input of our
future research agenda. We indeed aim at addressing the
challenges identiﬁed, by providing (semi-)automated sup-
port for developers in terms of quantum program compre-
hension, analysis, manipulation, and testing.

Acknowledgement

Fabio gratefully acknowledges the support of the Swiss
National Science Foundation through the SNF Projects No.
PZ00P2_186090.

References

[1] W. Knight, Serious quantum computers are ﬁnally here. what are
we going to do with them, MIT Technology Review. Retrieved
on October 30 (2018) 2018.

[2] T. Hoare, R. Milner, Grand challenges for computing research,

The Computer Journal 48 (2005) 49–52.

[3] M. Piattini, M. Serrano, R. Perez-Castillo, G. Petersen, J. L.
Hevia, Toward a quantum software engineering, IT Professional
23 (2021) 62–66.

[4] L. Mueck, Quantum software, Nature 549 (2017) 171–171.
[5] S. Aaronson, Guest column: Np-complete problems and physical

reality, ACM Sigact News 36 (2005) 30–52.

[6] M. Ohya, I. V. Volovich, New quantum algorithm for studying
np-complete problems, in: Selected Papers Of M Ohya, World
Scientiﬁc, 2008, pp. 83–90.

[7] F. Arute, K. Arya, R. Babbush, D. Bacon, J. C. Bardin,
R. Barends, R. Biswas, S. Boixo, F. G. Brandao, D. A. Buell,
et al., Quantum supremacy using a programmable supercon-
ducting processor, Nature 574 (2019) 505–510.

[8] B. Ömer, Qcl-a programming language for quantum comput-
ers, Software available on-line at http://tph. tuwien. ac. at/˜
oemer/qcl. html (2003).

[9] Q#: A quantum programming language, https://qsharp.

community, 2021. Accessed: 2021-09-21.

[10] T. Altenkirch, J. Grattage, Qml: Quantum data and control,

Submitted for publication, Febuary (2005).

16

[11] G. Aleksandrowicz, T. Alexander, P. Barkoutsos, L. Bello,
Y. Ben-Haim, D. Bucher, F. J. Cabrera-Hernández, J. Carballo-
Franquis, A. Chen, C.-F. Chen, et al., Qiskit: An open-source
framework for quantum computing, Accessed on: Mar 16 (2019).
[12] M. Broughton, G. Verdon, T. McCourt, A. J. Martinez, J. H.
Yoo, S. V. Isakov, P. Massey, M. Y. Niu, R. Halavati, E. Peters,
et al., Tensorﬂow quantum: A software framework for quantum
machine learning, arXiv preprint arXiv:2003.02989 (2020).
[13] D. S. Steiger, T. Häner, M. Troyer, Projectq: an open source
software framework for quantum computing, Quantum 2 (2018)
49.

[14] J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost, N. Wiebe,
S. Lloyd, Quantum machine learning, Nature 549 (2017) 195–
202.

[15] G. G. Guerreschi, M. Smelyanskiy, Practical optimization
arXiv preprint

for hybrid quantum-classical algorithms,
arXiv:1701.01450 (2017).

[16] L. O. Mailloux, C. D. Lewis II, C. Riggs, M. R. Grimaila, Post-
quantum cryptography: what advancements in quantum com-
puting mean for it professionals,
IT Professional 18 (2016)
42–47.

[17] M. Reiher, N. Wiebe, K. M. Svore, D. Wecker, M. Troyer, Eluci-
dating reaction mechanisms on quantum computers, Proceedings
of the National Academy of Sciences 114 (2017) 7555–7560.
[18] M. Piattini, G. Peterssen, R. Pérez-Castillo, J. L. Hevia, M. A.
Serrano, G. Hernández, I. G. R. de Guzmán, C. A. Paradela,
M. Polo, E. Murina, et al., The talavera manifesto for quantum
software engineering and programming.,
in: QANSWER, pp.
1–5.

[19] M. Piattini, G. Peterssen, R. Pérez-Castillo, Quantum comput-
ing: A new software engineering golden age, ACM SIGSOFT
Software Engineering Notes 45 (2020) 12–14.

[20] E. Moguel, J. Berrocal, J. García-Alonso, J. M. Murillo, A
roadmap for quantum software engineering: Applying the lessons
learned from the classics., in: Q-SET@ QCE, pp. 5–13.

[21] J. Zhao, Quantum software engineering: Landscapes and hori-

zons, arXiv preprint arXiv:2007.07047 (2020).

[22] L. S. Barbosa, Software engineering for’quantum advantage’, in:
Proceedings of the IEEE/ACM 42nd International Conference
on Software Engineering Workshops, pp. 427–429.

[23] F. Gemeinhardt, A. Garmendia, M. Wimmer, Towards model-
driven quantum software engineering, in: Second International
Workshop on Quantum Software Engineering (Q-SE 2021) co-
located with ICSE 2021.

[24] G. Li, L. Zhou, N. Yu, Y. Ding, M. Ying, Y. Xie, Projection-
based runtime assertions for testing and debugging quantum
programs, Proceedings of the ACM on Programming Languages
4 (2020) 1–29.

[25] M. R. El aoun, H. Li, F. Khomh, M. Openja, Understanding
quantum software engineering challenges: An empirical study on
stack exchange forums and github issues, in: 37th International
Conference on Software Maintenance and Evolution (ICSME).
[26] C. Developers, Cirq, 2021. See full list of authors on Github:
https://github .com/quantumlib/Cirq/graphs/contributors.
[27] Quantum development kit, https://azure.microsoft.com/
it-it/resources/development-kit/quantum-computing/,
2021. Accessed: 2021-06-05.

[28] A. B. Finnila, M. Gomez, C. Sebenik, C. Stenson, J. D. Doll,
Quantum annealing: A new method for minimizing multidimen-
sional functions, Chemical physics letters 219 (1994) 343–348.

[29] E. Farhi, J. Goldstone, S. Gutmann, M. Sipser, Quantum compu-
tation by adiabatic evolution, arXiv preprint quant-ph/0001106
(2000).

[30] W. Lidwell, K. Holden, J. Butler, Universal principles of design,
revised and updated: 125 ways to enhance usability, inﬂuence
perception, increase appeal, make better design decisions, and
teach through design, Rockport Pub, 2010.

[31] A. Barenco, C. H. Bennett, R. Cleve, D. P. DiVincenzo, N. Mar-
golus, P. Shor, T. Sleator, J. A. Smolin, H. Weinfurter, Ele-
mentary gates for quantum computation, Physical review A 52

(1995) 3457.

[32] R. P. Feynman, Quantum mechanical computers, Between

Quantum and Cosmos (2017) 523–548.

[33] P. Kaye, R. Laﬂamme, M. Mosca, et al., An introduction to
quantum computing, Oxford University Press on Demand, 2007.
[34] R. Jozsa, N. Linden, On the role of entanglement in quantum-
computational speed-up, Proceedings of the Royal Society of
London. Series A: Mathematical, Physical and Engineering Sci-
ences 459 (2003) 2011–2032.

[35] J. A. Miszczak, High-level structures for quantum computing,
Synthesis Lectures on Quantum Computing 4 (2012) 1–129.
[36] M. Ying, Foundations of Quantum Programming, Morgan Kauf-

mann, 2016.

[37] I. Exman, A. T. Shmilovich, Quantum software models: The
density matrix for classical and quantum software systems design,
arXiv preprint arXiv:2103.13755 (2021).

[38] R. Pérez-Castillo, L. Jiménez-Navajas, M. Piattini, Modelling
quantum circuits with uml, arXiv preprint arXiv:2103.16169
(2021).

[39] P. Zhao, J. Zhao, L. Ma, Identifying bug patterns in quantum

programs, arXiv preprint arXiv:2103.09069 (2021).

[40] J. Zhao, Some size and structure metrics for quantum software,

arXiv preprint arXiv:2103.08815 (2021).

[41] J. Campos, A. Souto, Qbugs: A collection of reproducible bugs
in quantum algorithms and a supporting infrastructure to enable
controlled quantum software testing and debugging experiments,
arXiv preprint arXiv:2103.16968 (2021).

[42] R. B. Johnson, A. J. Onwuegbuzie, Mixed methods research: A
research paradigm whose time has come, Educational researcher
33 (2004) 14–26.

[43] P. Ralph, N. bin Ali, S. Baltes, D. Bianculli, J. Diaz, Y. Dittrich,
N. Ernst, M. Felderer, R. Feldt, A. Filieri, B. B. N. de França,
C. A. Furia, G. Gay, N. Gold, D. Graziotin, P. He, R. Hoda,
N. Juristo, B. Kitchenham, V. Lenarduzzi, J. Martínez, J. Mele-
gati, D. Mendez, T. Menzies, J. Molleri, D. Pfahl, R. Robbes,
D. Russo, N. Saarimäki, F. Sarro, D. Taibi, J. Siegmund,
D. Spinellis, M. Staron, K. Stol, M.-A. Storey, D. Taibi, D. Tam-
burri, M. Torchiano, C. Treude, B. Turhan, X. Wang, S. Vegas,
Empirical standards for software engineering research (2021).

[44] What to look for in a quantum machine learning framework,

https://bit.ly/2ZkC0jr, 2021. Accessed: 2021-06-05.

[45] Open-source

quantum

software

//quantumcomputingreport.com/tools/,
2021-06-05.

projects,
2021.

https:
Accessed:

[46] Anonymous, Software engineering for quantum programming:

How far are we? — online appendix, TBD, 2021.

[47] W. Sugar, Studies of id practices: A review and synthesis of

research on id current practices (2014).

[48] K. J. Hunt, N. Shlomo, J. Addington-Hall, Participant recruit-
ment in sensitive surveys: a comparative trial of ‘opt in’versus
‘opt out’approaches, BMC Medical Research Methodology 13
(2013) 1–8.
ICT,

ghtorrent

[49] L.

legal

github
is-it-legal-for-ghtorrent-to-aggregate-github-user-data,
2016.

aggregate
https://www.ictrecht.nl/en/blog/

it
data?,

Is
user

for

to

[50] J. J. Heckman, Selection bias and self-selection, in: Economet-

rics, Springer, 1990, pp. 201–224.

[51] J. W. Sakshaug, A. Schmucker, F. Kreuter, M. P. Couper,
E. Singer, Evaluating active (opt-in) and passive (opt-out) con-
sent bias in the transfer of federal contact data to a third-party
survey agency, Journal of Survey Statistics and Methodology 4
(2016) 382–416.

[52] A. Fink, The survey handbook, sage, 2003.
[53] K. A. Broussard, R. H. Warner, A. R. Pope, Too many boxes,
or not enough? preferences for how we ask about gender in
cisgender, lgb, and gender-diverse samples, Sex Roles 78 (2018)
606–624.

[54] J. Noll, S. Beecham, I. Richardson, Global software development
and collaboration: barriers and solutions, ACM inroads 1 (2011)
66–78.

17

[55] E. A. Buchanan, E. E. Hvizdak, Online survey tools: Ethical and
methodological concerns of human research ethics committees,
Journal of empirical research on human research ethics 4 (2009)
37–48.

[56] J. M. Corbin, A. Strauss, Grounded theory research: Procedures,
canons, and evaluative criteria, Qualitative sociology 13 (1990)
3–21.

[57] S. Harispe, S. Ranwez, S. Janaqi, J. Montmain, Semantic simi-
larity from natural language and ontology analysis, Synthesis
Lectures on Human Language Technologies 8 (2015) 1–254.
[58] J. L. Fleiss, Measuring nominal scale agreement among many

raters., Psychological bulletin 76 (1971) 378.

[59] J. L. Walker, Research column. the use of saturation in quali-
tative research., Canadian journal of cardiovascular nursing 22
(2012).

[60] Understanding the complexity of quantum circuit com-
https://www.ibm.com/blogs/research/2018/08/

pilation,
understanding-complexity-quantum-circuit-compilation/,
2021. Accessed: 2021-06-05.

[61] M. Coughlan, P. Cronin, F. Ryan, Survey research: Process and
limitations, International Journal of Therapy and Rehabilitation
16 (2009) 9–15.

[62] A. N. Medvedev, R. Lambiotte, J.-C. Delvenne, The anatomy

of reddit: An overview of academic research, in: Dynamics on
and of Complex Networks, Springer, pp. 183–204.

[63] E. R. Johnston, N. Harrigan, M. Gimeno-Segovia, Programming
Quantum Computers: essential algorithms and code samples,
O’Reilly Media, 2019.

[64] D. Wecker, M. B. Hastings, M. Troyer, Progress towards practical
quantum variational algorithms, Physical Review A 92 (2015)
042303.

[65] N. Moll, P. Barkoutsos, L. S. Bishop, J. M. Chow, A. Cross,
D. J. Egger, S. Filipp, A. Fuhrer, J. M. Gambetta, M. Ganzhorn,
et al., Quantum optimization using variational algorithms on
near-term quantum devices, Quantum Science and Technology
3 (2018) 030503.

[66] M. Cerezo, A. Arrasmith, R. Babbush, S. C. Benjamin, S. Endo,
K. Fujii, J. R. McClean, K. Mitarai, X. Yuan, L. Cincio, et al.,
Variational quantum algorithms, Nature Reviews Physics (2021)
1–20.

[67] G. Booch, The history of software engineering, IEEE Software

35 (2018) 108–114.

[68] J. D. Blackburn, G. D. Scudder, L. N. Van Wassenhove, Improv-
ing speed and productivity of software development: a global
survey of software developers, IEEE transactions on software
engineering 22 (1996) 875–885.

18

