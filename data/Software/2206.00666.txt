The Journal of Systems and Software 00 (2022) 1–??

Journal
Logo

2
2
0
2

n
u
J

1

]
E
S
.
s
c
[

1
v
6
6
6
0
0
.
6
0
2
2
:
v
i
X
r
a

Technical Debts and Faults in Open-source Quantum Software
Systems: An Empirical Study

Moses Openjaa,, Mohammad Mehdi Morovatia,, Le Ana,, Foutse Khomha,, Mouna Abidia,

aSWAT Lab, École Polytechnique de Montréal

Abstract

Quantum computing is a rapidly growing ﬁeld attracting the interest of both researchers and software developers. Supported by its
numerous open-source tools, developers can now build, test, or run their quantum algorithms. Although the maintenance practices
for traditional software systems have been extensively studied, the maintenance of quantum software is still a new ﬁeld of study but
a critical part to ensure the quality of a whole quantum computing system. In this work, we set out to investigate the distribution
and evolution of technical debts in quantum software and their relationship with fault occurrences. Understanding these problems
could guide future quantum development and provide maintenance recommendations for the key areas where quantum software
developers and researchers should pay more attention. In this paper, we empirically studied 118 open-source quantum projects,
which were selected from GitHub. The projects are categorized into 10 categories. We found that the studied quantum software
suﬀers from the issues of code convention violation, error-handling, and code design. We also observed a statistically signiﬁcant
correlation between code design, redundant code or code convention, and the occurrences of faults in quantum software.

Highlights

• Quantum software suﬀers from code convention, error handling, and code redundancy.

• There is a correlation between technical debts and fault in quantum software.

• Quantum developers should use existing static analysis tools to examine their code.

• New tools should be introduced to support identifying quantum-speciﬁc problems.

• Future works should study other aspects of maintenance and reliability of quantum.

© 2022 Published by Elsevier Ltd.

Keywords:
Quantum Computing, Technical Debts, Software Bugs, Software Maintenance, Software Reliability

Email addresses: openja.moses@polymtl.ca (Moses Openja), mehdi.morovati@polymtl.ca (Mohammad Mehdi Morovati),

le.an@polymtl.ca (Le An), foutse.khomh@polymtl.ca (Foutse Khomh), mouna.abidi@polymtl.ca (Mouna Abidi)

1

 
 
 
 
 
 
Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

2

1. Introduction

Quantum Computing is a paradigm that intersects computer science, mathematics, and physics [1, 2]. Unlike other
computing ﬁelds, quantum computing uses the law of quantum mechanics with the goal to achieve high computation
eﬃciency. In contrast, quantum software can be software applications that run quantum algorithms, provide a platform
for testing and simulating quantum algorithms, or govern quantum computers’ operations. The example of operational
quantum software include applications developed for checking and correcting errors, maintaining the stability of
quantum computers or software for supporting complex and highly computational tools such as medical equipment.

Software maintenance support is considered one of the most important aspects of the software development pro-
cess. It is a well-known fact that between 60% and 80% of the total software development cost is taken by the mainte-
nance phase [3]. Previous studies have shown that modifying and revising previously released software’s versions are
the main activities of software maintenance [4, 5, 6]. Therefore, to ensure a maintainable software, developers have to
design and implement the source code, in a way that facilitates future modiﬁcations and evolution changes. However,
maintenance activities have never been a straightforward task, it is considered as the most time/eﬀort-consuming and
complex task throughout the life cycle of software development [7]. The maintenance practices for traditional soft-
ware systems have been extensively studied [8, 9, 10, 11, 7, 12, 13, 14, 15]. These studies focus on a broad range of
areas, including examining source-code complexity and software enhancement eﬀort [16], estimating the reliability in
the maintenance phase [17], studying the distributions and evolution of technical debts [18, 19, 20, 21], and predicting
the prevalence of bugs using anti-patterns [22, 23, 24] among others.

To the best of our knowledge, there is no prior study exploring maintenance eﬀorts for quantum software yet. The
recent emerging studies [6, 5] related to quantum software systems maintenance mostly focused on re-engineering
new quantum algorithms within traditional software systems. For example, Pérez-Castillo [6] proposed a model-
driven re-engineering [25] that allows the migration of classical or legacy systems together with quantum algorithms
and the integration of new quantum software during the re-engineering of classical or legacy systems while preserving
knowledge. While maintenance eﬀort is a broader dimension, examining the maintenance in terms of the technical
debt composition in a quantum software system is one direction to understand how this software is being maintained.
Studies [19, 26, 12, 13, 27] have shown that technical debts provide relevant and actionable insight into the design
and implementation deﬁciencies of software systems. For instance, according to Martin Fowler [18], technical debts
indicate the internal quality issues of software that make the software more diﬃcult to modify or develop (for example
the source code conventions for readability [28]). Understanding the distribution and evolution of technical debts
in quantum software could guide future development and provide maintenance recommendations for the key areas
that may require further attention to both the practitioners and researchers in quantum computing. In this paper, we
examine the distribution and evolution of technical debts in quantum software and their relation with fault occurrences.
In particular, we answered the following research questions:

RQ1) What Are the Characteristics of Technical Debts in Quantum Software?

We examined the distribution of technical debts in quantum software systems represented as code smells and
coding errors and their severity (categorise as critical, major, minor, and blocker) [29]. We summarized the
technical debts based on the types of technical debts and highlighted the critical debts. Results show that about
80% of the technical debts are related to the code smells and more than half of technical debts in all software
types belong to the major severity. The major severity are quality issues or ﬂaw that can highly impact the
productivity of developer, for example, an uncovered piece of code, unused parameters, or duplicated blocks.
In addition, we found that a few types of technical debts (such as ‘code convention’ (problem with coding
convention such as formatting, naming, white-space), ‘design issues’ (e.g., duplicate string literals), ‘brain-
overload’ (related to cognitive complexity), and ‘error-handling’) dominate the total number of technical debts.

RQ2) How Do Technical Debts Evolve Over Time?

We investigated how new technical debts are added into the code-base with respect to the total ﬁle size over
time. We observe that technical debts tend to be added in the initial versions of a project (when most new
codes and ﬁles are added). Besides, we found that LOC can be considered as key indicators of the existence
of technical debts in quantum computing software systems. This result is in line with the studies on traditional

2

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

3

software [30, 31]. We recommend quantum software developers pay more attention to the code quality and
code size, especially when new ﬁles are added to the code base.

RQ3) What Is the Relationship Between Technical Debts and Faults?

In this research question, we used regression models to examine the correlation between technical debts (and
their types [32]) and fault-inducing commits in quantum software at the ﬁle level. Our results indicate a statisti-
cally signiﬁcant correlation. Particularly, we found that the highest signiﬁcance in all studied quantum software
systems is related to ‘convention’ and ‘unused’ technical debts.

The rest of this paper is organized as follows. In Section 2, we provide the background of this study. Then, we
discuss the related works on quantum computing, technical debts, and fault analysis in the software systems in Section
3. We describe the methodology that is followed in Section 4. In Section 5, we present the results of our analysis.
In Section 6, we discuss the implication of our ﬁndings. Section 7 describes the threats to the validity of our study.
Finally, we provide the conclusion in Section 8.

2. Background

The main focus of this study is to investigate technical debts and their evolution in quantum software and how
the technical debts aﬀect the reliability of quantum software. This section describes the background of quantum
computing and quantum software development.

2.1. Quantum Computing

Quantum computers can adopt a superposition form of |0(cid:105) and |1(cid:105), which enables a qubit to exist in all of these
states simultaneously. A qubit is a two-dimensional quantum-mechanical system, presenting sizeable information to
process in quantum computing. This basic concept of superposition allows quantum computers to perform computa-
tions on an extensive scale in parallel (also known as parallel computation).

Another property of a quantum computer is the entanglement: given a two-qubit system, it is possible that the state
of each qubit cannot be described separately. In mathematical form, the state cannot be factorized as the tensor product
of two separate states. Certain types of highly entangled systems are challenging to model for classical computers.
Generally, it is also possible to eﬃciently describe systems that do not exhibit too much entanglement using classical
computational methods such as tensor networks [33]. However, highly entangled systems are almost impossible to
be modeled in classical computers. Consequently, quantum algorithms must exploit high amounts of entanglement
to reach higher possible capabilities than classical algorithms. This entanglement property has applications in many
aspects of quantum computing, such as cryptography [34], and quantum computation [35, 36].

2.2. Quantum Software Development

Zhao, Jianjun. [37] deﬁned Quantum software engineering as “the application of sound engineering principles for
the development, operation, and maintenance of quantum software and the associated document to achieve economi-
cally quantum software that operates eﬃciently on quantum computers and is reliable.”

Like classical software, quantum software is also developed by following a series of steps: requirements analysis,
design, and implementation to testing and maintenance. The quantum design stage provides the means for modeling
and deﬁning quantum software systems [38, 39]. The testing phase aims to identify any ﬂaws or defects in the
quantum software and verify that the software’s behavior reﬂects the documentation deﬁned at the early phase of
analysis. Finally, the maintenance as the last phase of quantum development process represents any changes or updates
later when quantum software products are released. Indeed, to develop maintainable and reliable quantum software
systems, there are numerous factors that developers must take into consideration and respect in every phase of software
development, for example, deﬁning system requirements and quantum design patterns, implementing test and fault
detection models, implementing development environments, and selecting quantum programming mechanics. For
further readings on quantum software development, we refer our readers to [37, 39, 40, 35, 41] containing well
documented set of guidelines to assist a well-engineered quantum software system development.

3

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

4

Quantum programming is the design and implementation of a program executable on a quantum computer to meet the
computing need [42, 43]. Every chunk of code in a typical quantum program consists of both quantum and classical
instructions [44]. A classical instruction uses classical bit registers to measure the qubit states, including conditional
operation, whereas quantum instruction uses qubit registers to operate on the quantum computer. Unlike in the early
stage of Quantum Turing Machine (QTM) [45], quantum programming majorly focuses on quantum circuit models.
This is followed by new quantum programming models such as the Quantum Random-Access Machine (QRAM)
model [46] and pseudocode [47]. Instead of just designing the quantum circuit, a quantum program is built to run
on a classical computer to control the quantum system. Numerous other quantum programming languages such as
‘Quipper’ [48], Q# [49] and ‘Scaﬀold’ [50, 51] are now available. These programming languages are built on top
of the traditional programming languages such as C#, Python, Java, C/C++, and Julia. For the complete list of the
programming languages and their history, we refer the readers to the studies [44, 37, 42].

3. Related Works

In this section, we discusses the related works on quantum computing, technical debts, and analysis of fault charac-
teristics.

3.1. Quantum Computing

Piattini et al. [52] studied the emergence of quantum computing software systems and quantum software en-
gineering. They also explained that based on evidences, demand for quantum software systems will be increased
dramatically during the next years of the current decade. Besides, they mentioned nine principles as the main princi-
ples of quantum software engineering.

Garhwal et al. [53] studied various high-level quantum programming languages and identiﬁed the main features
of each one. They categorized quantum programming languages into ﬁve diﬀerent main classes (such as Quantum
Object Oriented Programming Language, Quantum Circuit Language, etc). Next, they represented that QPL and QFC
are the most popular quantum programming languages.

Moguel et al. [54] explained that quantum software systems in quantum software engineering need processes that
require methodologies, like classical software systems. They identiﬁed that classical software engineering processes
such as requirements speciﬁcation, architectural design, detailed design, implementation or testing can be used to carry
out activities of each process in quantum software engineering eﬀectively. While, the methodologies for each process
of quantum software engineering should be adopted based on the requirements of quantum software development.
The reason behind this diﬀerence is the underlying model of computing being used in each one. In classical software
systems, computation is done by a sequence of instructions manipulating the data and the ﬁnal state should be the
output of the program. Although in quantum computing there is not a sequence of instruction. System in quantum
computing has a set of states and can be in all of them at the same time. Besides, system stops when a certain subset
of system states is in the desired state.

The most related work is a recent study regarding engineering quantum software [37]. In this paper, the authors
introduced a quantum software life cycle and named it as quantum software engineering. They ﬁrstly explained
quantum programming as the process of designing and building an executable quantum computer program. Quantum
Software Requirements Analysis, Quantum Software Design, Quantum Software Implementation, Quantum Software
Testing, and Quantum Software Maintenance have been reported as the main stages of engineering quantum software
systems. It is also mentioned that quantum software testing is more diﬃcult than classical counterparts that are resulted
from the structure of quantum computing programs and also quantum computers. Seven diﬀerent types of faults
(Incorrect quantum initial values, Incorrect operations and transformations, Incorrect composition of operations using
iteration, Incorrect composition of operations using recursion, Incorrect composition of operations using mirroring,
Incorrect classical input parameters, and Incorrect deallocation of qubits) are introduced as faults related to quantum
software engineering to achieve a deep understanding about the behavior of faults in quantum computer programs. To
detect introduced faults, an assertion has been explained for each identiﬁed fault category.

Another related work to our study is the article discussing open-source software in quantum computing carried
out by Fingerhuth et al. [55]. In that article, a wide range of open-source software systems focusing on quantum
computing are studied and the authors introduced four paradigms to develop quantum computing software projects, in

4

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

5

order to ease the understanding of quantum computing systems for computer scientists and software engineers. The
ﬁrst paradigm is the discrete variable gate-model quantum computing paradigm in which bits and logical transforma-
tions are replaced by qubits and a ﬁnite set of unitary gates respectively. Continuous variable gate-model quantum
computing is another paradigm where the qubits are replaced by qumods taking continuous values. This paradigm
is mostly regarding physics aspects of quantum mechanics and particularly, quantum optics. The third introduced
paradigm is Adiabatic quantum computation that uses adiabatic theorem, a phenomenon from quantum physics, to
ﬁnd the global optimum of a discrete optimization problem. Last but not least, they discuss quantum simulators which
are application-speciﬁc quantum devices. But this paradigm is diﬀerent from the simulation of quantum computa-
tions. The author of this paper just reviewed the development process of quantum computing projects from a software
engineering view point.

Shaydulin et al. [56] focused on the contributors of open-source quantum computing projects hosted on GitHub.
They studied data of 146 contributors and surveyed 46 of them. Based on the analysis of the collected data, they
mentioned that almost all (45 out of 46) of the contributors of quantum computing software systems did not receive
formal training in quantum computation. Thus, they concluded that their lack of a good understanding of quantum
computing may lead to poor quality software systems. Besides, they introduced the main challenges that developers
are facing in open-source quantum computing software systems.

3.2. Technical Debts

Cunningham [57] introduced the concept of technical debt (TD) for the ﬁrst time in 1992. Since that time, a
number of studies have been carried out to shed light on the diﬀerent properties of TD. Ageriou et al. [58] found that
although TD can yield some beneﬁt in short term, it can increase the cost of changes in a long term. Martini et al. [59]
showed that the existence of TD in software systems is inevitable. Besker et al. [60] studied the strategies to prioritize
the identiﬁed TDs to be resolved and the most important factors aﬀecting this process. Besker et al [61] carried
out another study to determine the refactoring cost and negative eﬀects of diﬀerent types of TD. Besides, there have
been various tools for identifying TDs. As an example, Avgeriou et al. [62] conducted a comparison of 9 TD tools
and highlighted the main features of each one. They showed that SonarQube can best handle multiple programming
languages, which is the reason why we used this tool in our study because our subject Quantum software is written in
diﬀerent programming languages.

Technical debts in software imply quality issues, i.e., code quality was ignored to achieve a faster goal instead of
using a systematic approach to reach the same purpose that would take longer time [63]. Therefore, this may involve
additional rework such as code refactoring in a later time to achieve a better quality. For this reason, tools such as
‘Squore1’, ‘SonarQube’, ‘Kiuwan2’ or ‘Ndepend3’ have been proposed both in academia and industry to assist in
identifying technical debts. Such tools are built based on a set of quality models [64] to help practitioners reduce
the time it takes to synthesize and make the best decision regarding a system’s future quality by providing systematic
and quantiﬁable metrics for the industry’s best practice [20]. For example, SonarQube, NDepend and Squore use the
SQALE model [65] that is programming language independent, whereas tools such as Kiuwan uses the concept of
Checking Quality Model (CQM).

4. Study Design

This section presents the methodology we followed in this study. We used sequential mixed-methods to answer
our research questions RQ1 through RQ3, from data collection, data processing, to quantitative and qualitative anal-
yses [66]. Figure 1 shows an overview of our methodology.

To avoid any ambiguity, we use the following terms throughout the paper to denote diﬀerent kinds of defects

identiﬁed by SonarQube and GitHub project’s repositories.

• Error: Potential coding errors or bugs detected by SonarQube. These errors might break the code and have to

be ﬁxed as soon as possible.

• Code smell: They include poor coding decisions and any characteristics in the software source code that indicate

the possibility of a deeper problem, as reported by SonarQube [67, 68].

• Fault: Post-release bugs or developer/QA reported bugs. Only the GitHub issues [69] labeled as ‘bug’ will be

considered as faults.

5

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

6

Figure 1: An overview of our study methodology

4.1. Selection of Quantum Projects

The ﬁrst step of our work is to select a list of open-source quantum computing projects. We searched quantum
computing projects from GitHub, because GitHub hosts the largest collection of open-source software. Some of the
famous quantum projects, such as Qiskit from IBM, are shared on GitHub. In the following sections, we will use
this pattern <author_name>/<repo_name> to denote a GitHub project, whose URL will be https://github.com/
<author_name>/<repo_name>.

Searching against the Rest API [70] provided by GitHub, we obtained a total of 1,364 repositories that: 1) contain
the word ‘quantum’ (case insensitive in either the repository name, descriptions, or project ReadME ﬁle); 2) are a
mainline, not a forked repository; 3) have a ReadME or description written in English to provide us details about the
project. We used the GitHub API (:owner/:repo) to extract the repositories descriptions and other meta-data then
used to manually check if the descriptions are written in English. We then use the following criteria to ﬁlter out our
search results.

• Following the idea of previous works [71, 72, 73], we selected the repositories that have been forked more than
once to reduce the chance of selecting a student’s class assignment. This step removed 803 repositories and
remained with 561 repositories.

• Our projects should contain enough history and development activities for the analysis of technical debts and
faults. Thus, we only considered the repositories that have been created more than 10 months earlier (i.e.,
2019-09-16) than the date of this study. Inspired by [55], we chose the projects that have at least 100 commits
and 10 GitHub issues or pull requests. In addition, we limited our selection of projects to those with at least
one release. These selection criteria allowed us to consider projects targeting the end-users because ‘never
released projects’ may not show representative data on faults experienced during the project development or by
the end-users. This step further removed 417 projects and remained with 144 projects.

• We manually read the project descriptions and removed 13 repositories that are only related to quantum doc-
umentations or lecture notes. We also identiﬁed and removed 9 more repositories that are not related to quantum

6

Quantum Project SelectionExtracting the Projects’s snapshotsCategorization of ProjectsCorrection of Technical debts & Fault-inducing commitsAnalysis of Technical debts EvolutionIdentifying the Technical debtsExtracting the Fault-inducing commits and corresponding commit messagesExtracting the Fault-ﬁxing commits90 days intervalReport the results in Section 5Discussion and Implications in Section 64.64.84.54.44.24.14.7RQ3RQ1RQ2sonarQubeRegression Model4.3Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

7

computing but merely contain the word ‘quantum’ in their descriptions, such as foxyproxy/firefox-extension
and quantacms/quanta. After this step, we ﬁnally obtained a list of 122 repositories.

4.2. Categorization of Projects
In this step, we classiﬁed the selected quantum projects into diﬀerent categories. We used the list of categories
provided by the Quantum Open-Source Foundation (QoSF) [74], which is an initiative to promote the advancement of
open-source tools for quantum computing. To decide which category a project belongs to, we ﬁrst checked whether
a target project is listed by QoSF. If it is listed, we will directly use the QoSF provided category. Otherwise, two of
the authors will independently read the project descriptions and/or the project’s oﬃcial website to classify the project
into one of the QoSF deﬁned categories. The two authors will compare their results and resolve all discrepancies until
reaching an agreement for all of the projects.

During the categorization step, the authors removed four more projects either because their programming lan-
guages are not supported by SonarQube or because they are identiﬁed as experimental or toy projects, such as
Quantum-Game/quantum-game-2 and PJavaFXpert/quantum-toy-piano-ibmq. The remaining 118 projects
are classiﬁed into 10 categories as follows. Readers can refer to Appendix A for a list of example repositories that
belong to each of the categories.

• Full-Stack Library or Framework: This can be seen as all-in-one software containing all the frameworks and/or

libraries required for building quantum applications.

• Experimentation: Tools that support experimentation of quantum systems or states, such as superconducting

qubit systems and parametrization of a pulse.

• Simulator: Controllable quantum systems that enable users to study the quantum systems which are hard to

study on actual hardware or in laboratory.

• Cryptography: This class is related to the usage of quantum mechanics’ characteristics to carry out cryptography

tasks.

• Quantum-Algorithms: Systems that execute a quantum computation on a quantum model (such as a quantum

circuit model). They are designed majorly to solve the classical problems in a probabilistic fashion [75].

• Toolkit: A set of libraries and tools that help interact with diﬀerent components of quantum systems mainly in

research settings.

• Quantum Annealing: Systems that provide meta-heuristics for ﬁnding global minimum over a very large number

of possible solutions by using quantum ﬂuctuation-based computation [76].

• Quantum-Chemistry: Projects that focus on the use of quantum mechanics in the chemical systems experiments.

• Compiler: When a quantum computing algorithm is implemented on actual hardware, the circuits should be
compiled for the restricted topology of the particular quantum chip used for execution. This category is related
to the systems translating quantum circuits to the quantum assembly format.

• Assembly: This class is related to quantum assembly languages used for describing quantum circuits. It is
used in many quantum compilation and simulation tools as the intermediate representation to describe quantum
circuits [77].

The summary statistics of the selected repositories in the 10 categories are shown in Figure 2.

7

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

8

Figure 2: Statistics of selected quantum projects by categories
(Commits: number of commits, Age: Time (in days) from the project creation date to its latest change, Issues: number of issues reported on the
GitHub repositories, Forks:number of forks (popularity metric), Stars:number of stars (popularity metric), Snaps:number of snapshots extracted
based on 90 days (extracted in Section 4.3), Repos: number of studied GitHub repositories in respective quantum category.)
Algo:Algorithms, Ann:Annealing, Asm:Assembly, Chem:Chemistry, Comp:Compiler, Crypt:Cryptography, Exp:Experimentation, Fstack:Full-
stack library, Sim:Simulator, Tkit:ToolKit.

4.3. Extraction of Snapshots of Studied Projects

Our study aims to analyze the change history of the selected quantum projects to investigate the maintenance
eﬀort over time. Git allows us to take snapshots of a given project at a speciﬁc time period. We deﬁned snapshots
as diﬀerent copies of the same project. Each snapshot contains a set of changes made at that point of the project
development. We report the distribution of the commits in Figure 2 for the given studied quantum category. We use
the following steps to extract the snapshots.

Choosing the Snapshot Period. Studying snapshots from each of the commits will provide us with the most
precise result, but this will also exhaust our computational resources, making it impossible to analyze all the 118
projects. Based on the idea of iterative and incremental development, we assume that developers of the studied
projects did not make a large number of changes between consecutive commits. Thus, we can use a snapshot every
N days to represent the changes and development activities (such as fault ﬁxes) during these days. To decide the best
N, we investigated the distribution of commits between days interval {30, 60, 120, 150, 180} to be able to choose
the appropriate number of days and extract project snapshots with considerable code-changes across all the studied
projects. Fig. 3a shows how commits are distributed within the time frames of {30, 60, 120, 150, 180} days in the
studied quantum categories.

8

IssuesSnapshotsStarsAgeCommitForksAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkit03006009000100020003000025005000750010000025507510002000300001000200030004000Total countsCategory (Repos)Algo (14)Ann (6)Asm (5)Chem (19)Comp (3)Crypt (5)Exp (8)Fstack (16)Sim (20)Tkit (22)Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

9

(a) The distribution of commits across diﬀerent time frames (in days) for the studied categories of quantum projects. The y-axis
indicates the number of commits, and the x-axis indicates the time frames (in days) from 30 to 180 days with the interval of 30 days.

(b) The distributions of lines of code for the ﬁrst ten snapshot’s of the studied projects, basing on the 90 days interval.

Figure 3: The ﬁgures highlighting the distributions of commits and the consecutive changes. In the ﬁrst part of the ﬁgures, we shows how the
commits are distributions across diﬀerent time frames from from 30 to 180 (in days) for the studied categories of quantum projects. The second
9
ﬁgure indicate the changes in terms of changed lines of code (left) and the cumulative mean value of the changed lines of code (right) across the
ﬁrst ten snapshot’s consecutive commits for 90 days interval.

SimulatorToolKitFull−stack LibraryQuantum AlgorithsmQuantum AnnealingQuantum−ChemistryAssemblyCompilerCryptographyExperimentation30609012015018030609012015018030609012015018030609012015018030609012015018030609012015018030609012015018030609012015018030609012015018030609012015018001002003004005000400800120005010015020002004006000200400600800050100150010020002040608002004006008000100200Time frame (in days)Number of commitsSimulatorToolKitFull−stack LibraryQuantum AlgorithsmQuantum AnnealingQuantum−ChemistryAssemblyCompilerCryptographyExperimentation01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890e+002e+054e+056e+050e+002e+064e+066e+068e+060e+002e+054e+056e+050e+001e+062e+063e+064e+060500000100000015000002000000050000010000001500000200000025000000e+001e+062e+063e+060e+001e+052e+053e+0505000001000000150000020000000500000100000015000002000000Changed lines of code (cloc)cumulative of average changed lines of codeMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

10

Severity

Impact Likelihood Description

Table 1: Severity rules deﬁne by SonarQube [32].

BLOCKER

CRITICAL

MAJOR

MINOR

√

√

×

×

√

×

√

×

Higher impact probability to the behavior of the application, for exam-
ple memory leak or unenclosed JDBC connection. The code needs to
be ﬁxed immediately.
Either an error with a low probability to impact the behavior of the
application or a security ﬂaw such as an empty catch block or SQL
injection.
Quality issues or ﬂaw that can highly impact the productivity of devel-
oper, for example, an uncovered piece of code, unused parameters, or
duplicated blocks.
Quality issues or ﬂaw which can slightly aﬀect the productivity of de-
velopers, for example, too long lines, or ‘switch’ statements with fewer
than 3 cases.

For example, the box-plot corresponding to 30 indicates the number of commits every 30 days across all projects
in the categories. Observing the commits distribution with the time-frames shown in the ﬁgure, we chose 90 days as
the appropriate time frame, which represents the median size number of commits for most of the selected projects.
This size of time frame also allows us to extract a number of snapshots from each project, which is feasible to conduct
the following analyses based on our computational resources.

Extract Snapshots. Using the time frame of 90 days, we identiﬁed the latest commits for every time frame (snap-
shots). We then used git archive (i.e., https://github.com/<author_name>/<repo_name>/archive/<commit>.zip)
to create and download a zip ﬁle containing only the ﬁles under git data source from the starting of the project until
the latest commit in a given snapshot. Figure 2 shows the distribution of number of snapshots (and other metrics
such as age) extracted from the projects categories. Considering that most of the projects we analyzed have at least
212 commits (with maximum commits of 9,592) and the survival times (age) of 476 days at the point of starting
this study. There is a trade-oﬀ when analyzing the number of revisions of each project of manageable size and code
changes. Figure 3b illustrates consecutive changes in terms of changed lines of code within the commits for the ﬁrst
ten snapshots based on a 90 days interval (i.e., code changes for the selected time frame). In Figure 3b we also show
the cumulative mean value of the changed lines of code (right) across the snapshot for the selected time frame.

4.4. Technical Debts in Quantum Software

This section presents the steps carried out to identify technical debts from the snapshots extracted from the previous
section. First, we give a general background of the SonarQube tool that we used to detect technical debts. Then we
describe our steps for detecting the technical debts.

4.4.1. SonarQube Platform

SonarQube is an open-source platform used for monitoring source code quality and security. It uses static analysis
to detect code smells, potential bugs (referred to as errors in the rest of this paper), and vulnerability in software
systems written with over 20 programming languages, including Python, C#, C/C++, JavaScript, XML, and Java. It
also allows creating plugins to support new programming languages. SonarQube uses a rule deﬁnition during source
code analysis. An alert is raised in case a rule is broken. The properties of the created alerts include the type, severity,
and eﬀort needed to ﬁx the alert.

SonarQube uses a risk estimation procedure to assign severity levels to the detected debt. Table 1 illustrates the
severity deﬁnition, extracted from the oﬃcial SonarQube documentation [32]. The columns ‘Impact’ and ‘Likelihood’
indicate how sonarQube assesses whether the severity of the debt is high or low. For example, evaluating if the
code error can cause the application to crash or corrupt stored data (Impact) and the probability that the worst [78]
will happen (likelihood), or assessing whether the detected code smell could lead to a error during the maintenance
process. Also, sonarQube uses tags to categorize rules and debts. One or more tags are assigned to the debts inherited
10

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

11

from the rules that raised them. Moreover, tags denote diﬀerent types of technical debts. Also, each rule provides an
estimation function for determining the time needed to ﬁx the corresponding debts. The estimation usually oﬀer either
a function with a linear oﬀset or a constant time per debt. For example, the rule ‘S3776’ states that ‘the Cognitive
Complexity should not be too high’. It generates code smells of the severity type CRITICAL with a linear time to ﬁx,
which consists of a constant 5 minute time per issue, including one more minute for each additional complexity point
over an established threshold.

Also, as part of the analysis results returned from running sonarQube, sonarQube calculates the eﬀort required (in
terms of time) for ﬁxing technical debts (TD) in a target system. Further, SonarQube computes the technical debts
ratio as T DR = T d
devT ; where devT is the time estimated to develop the system, where a single line of code (LOC) is
estimated to take 30 minutes. Then the T DR is classiﬁed on a scaling of A as the best (T DR < 5%) to E as the worst
(T DR ≥ 50%). This detailed information, therefore, gives a high-level view of the system’s internal quality.

The characteristics of technical debts important in our study are: 1) The types of debts: code smells (maintain-
ability domain) and coding error (reliability domain). 2) The severity of technical debts, introduced in Table 1. 3) The
eﬀort required to ﬁx the technical debts mentioned above. Providing these breakdowns can assist practitioners in
prioritizing the allocation of resources to address critical debts.

We chose SonarQube in this study because: 1) It is broadly used for technical debts detection by over 200 thou-
sand users [79] and academic research setting [80, 81, 82, 83, 84]; 2) The tool is based on a SQUARE quality
model [65, 85], which is academically evaluated and published [86, 87]; 3) Our subject projects are written in diﬀer-
ent programming languages, which are supported by SonarQube.

4.4.2. Detection and Analysis of Technical Debts

We ran SonarQube on every project’s snapshots extracted in Section 4.3. The tool is conﬁgured on a local computer
and used its web interface to monitor the results of the analysis. For data extraction and further analysis of the
SonarQube results, we used a purpose-written program written with Python and Java (i.e., code written speciﬁcally
to achieve the analysis goals guided by our RQ), making use of the SonarQube API and spreadsheet software as the
primary storage. Figure 4 highlights the general summary of the metrics obtained after running SonarQube analysis.
To answer our RQ1, we investigated technical debts for every snapshot of the target project. We used the Spearman
test [88] with a high correlation value (> 90) between thousands of lines of code (KLOC) which was used as the proxy
for application size and the total classes and functions for all 118 target projects. In Section 5.1, we will discuss the
results of this analysis.

4.5. Evolution of Technical Debts

Previous studies [59, 30] have shown that refactoring eﬀorts and architectural changes are some of the factors that
inﬂuence technical debt in software projects compared to source code ﬁle size. Also, constraints such as time and
budget have been described as some of the root causes of technical debt [12]. This step examines how technical debts
(in terms of errors and code smells) evolve across the snapshots of every target project to help us understand how debt
is introduced in quantum software source code. Speciﬁcally, we computed the technical debt ratio (T DR, described
in Section 4.4.1) for the debts detected in each snapshot of the target projects. We also examined the addition of new
codes (in KLOC) and how the codebase grows to identify the point in time when debts are introduced. Finally, we
verify how the source code ﬁle size impacts the technical debts using a Spearman rank correlation. We present the
detailed results of this analysis in Section 5.2 to answer our RQ2.

4.6. Identiﬁcation of Fault-Fixing Commits

One of the goals of this study is to examine activities that may introduce faults during quantum software develop-
ment. To achieve this goal, we analyzed the fault-ﬁxing and fault-introducing commits and their correlation with the
overall technical debts discussed in the previous section. We deﬁned a fault-ﬁx commit as code changes to ﬁx faults
and a fault-inducing commit as the code-changes that induced faults [89].

To identify the fault-ﬁxing commits, we combine two approaches: 1) using a list of keywords such as “bug” or
“ﬁxes” as shown in Listing 1. Our selection of keywords is based on previous studies [90, 91, 92, 93] and ii) using
the identiﬁer/references to the bug reports within the commit message (i.e., references to the issue labeled as ‘bug’)
such as #131 [94, 95, 96, 91, 92]. The two approaches above consider the faults that are reported in the bug tracking

11

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

12

Figure 4: Summary of the analysis results from SonarQube ( Debts: number of technical debts detected, Eﬀort: estimated time (in minutes) to
ﬁx all reported technical debts, Complexity: reported source-code cognitive complexity, KLOC: number of thousand lines of code for the analyzed
ﬁles, Files: number of unique ﬁles with at least one technical debt )
Algo:Algorithms, Ann:Annealing, Asm:Assembly, Chem:Chemistry, Comp:Compiler, Crypt:Cryptography, Exp:Experimentation, Fstack:Full-
stack library, Sim:Simulator, Tkit:ToolKit.

system (for our case GitHub issues tracker) and those that are not reported in the system, because developers might
ﬁx a fault in the source code which is not captured by such systems (also known as ‘on-demand’) [91].

Using the two approaches described above we obtained a total of 33,917 unique fault-ﬁxing commits that modiﬁed
49,593 unique ﬁles across all the studied projects. Next, we removed all the commits detected as fault-inducing and
fault-ﬁxing that touched only the ﬁles related to readMe/ documentation, git, or test cases. To this end, we checked if
a given keyword (case insensitive) is within the ﬁle path or ﬁle name. In Listing 2 we show the list of keywords used
to match if the modiﬁed ﬁles by the fault-ﬁxing commits are related to documentation, licence, test case, or git-related
ﬁles. After cleaning the commits related to the documentation or test cases, the ﬁnal list of the fault-ﬁxing commits is
31,114 unique fault-ﬁxing commits with 39,285 unique ﬁles modiﬁed.

4.7. Extracting the Fault-Inducing Commits

This step aims to identify the fault-inducing commits and use the information to check for the correlation with
the debts in the quantum software systems. We may not directly know how faults are introduced, but we can extract
characteristics of the fault-inducing commits. We used the SZZ algorithm [97] to identify fault-inducing commits
using the fault-ﬁxing commits.

12

KLOCDuplicationEffortFilesCode ComplexityCognitiveDebtsAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkitAlgoAnnAsmChemCompCryptExpFstackSimTkit0250050007500100000100020000500000100000015000000250005000075000100000040000080000012000000500000100000015000000500010000ValueCategoryAlgoAnnAsmChemCompCryptExpFstackSimTkitMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

13

Listing 1: The keywords used to extract fault-ﬁx commits

"fixed ", "fixes ", " fixed", "crash", " resolves", "fall back", "coverity", "reproducible",

"stack-wanted", "failur", "fail", "npe ", "except", "broken", " bug", "error",
"addresssanitizer", "hang ", "permaorange", "random orange", "intermittent", "steps to
reproduce", "crash", "assertion", "failure", "leak", "stack trace", "heap overflow",
"freez", "fix ", " problem", " overflow", " issue", "workaround ", "break ", "stop"

Listing 2: The keywords used to removed the fault-ﬁxing and fault-inducing commits related to documentation or test case

‘readme’, ‘doc’, ‘test’, ‘.png’, ‘.pdf’, ‘.jpeg’, ‘.jpg’, ‘.gif’, ‘licence’,
‘.txt’, ‘.md’, ‘.git’, ‘changelog’, ‘.rst’, ‘.bib’, ‘.json’, ‘tox.’

Given the fault-ﬁxing commit, SZZ will track the fault-inducing predecessor lines to lines modiﬁed in the ﬁxing
commit within a software repository. As a step in SZZ, for every fault-ﬁxing commit, SZZ will identify all previous
commits that changed the same lines of code using git blame command, resulting in a set of a fault-inducing
commits that might have introduced the fault. Next, the identiﬁed commit time is compared to the time when the
corresponding bug reports were submitted to determine if it should be ruled out as fault-introducing or not. The
commit created later than the submission time is inducing commit if it is either a partial ﬁx- didn’t fully resolve
the fault as evident in the later fault-ﬁxing commit for the same issue or is responsible for another fault. Hence,
separate fault-ﬁxing commits may originate from similar fault-inducing commits that have modiﬁed related ﬁles.
Many previous studies such as [98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112] have also
leveraged the SZZ algorithm to detect fault-inducing commits from a fault-ﬁxing commit. Also, many tools have been
proposed implementing the SZZ algorithm such as Pydriller [113], Commit Guru [114] or SZZ Unleashed [115]. In
this study, we used the Pydriller framework to detect the fault-inducing commits because it is very convenient for
mining software repositories and provides a set of APIs to extract important historical information regarding commits
[113].

To verify the accuracy of the extracted fault-inducing commits, we performed a manual analysis on the sampled
fault-inducing commits. We randomly selected 382 fault-inducing commits based on 95% conﬁdence interval and
manually checked if the changes in the sampled fault-inducing commits are indeed related to the modiﬁcations per-
formed in the corresponding fault-ﬁxing commits. Two authors discussed and assigned each commits with tags as
either “True”, “False”, or “Unclear”. In this case, the tag “True” was assigned for a situation where the authors were
convinced that the change performed in fault-ﬁxing was indeed related to the changes applied in fault-inducing. While
“False” was used for the case where the changes are not related. Finally, a tag “Unclear” was attached in situations
where the authors could not completely relate to a tag “True” or “False”. The two authors discussed any conﬂicts until
reaching an agreement. We calculated the precision considering only the True and False tags for data emerging from
our manual validation and found a precision scores of 84.8%.

Next, we used the GitHub API (:owner/:repo/commits/:id) to extract the commit messages and other related
information such as commit author from the candidate fault-inducing commits. We eliminated the fault-inducing
commits where the modiﬁed ﬁles are not the actual source code but are related to documentation, licence, test case, or
git-related ﬁles shown in Listing 2 and obtained a list of 51,269 unique fault-inducing commits that modiﬁed a total
of 56,003 unique ﬁles across all the studied projects.

4.8. Correlation of Technical Debts and Fault-Inducing

This step aims to investigate how technical debts and fault-inducing changes are correlated. Examining the relation
between them can show us the potential impact of technical debts. This information can also provide explanatory
answers regarding the potential relationship between maintenance and reliability activities. To predict the occurrence
of faults due to technical debts, we built multiple regression models on the set of technical debt metrics derived from
the results of RQ1, which will be described in Section 5.1. We also used the number of fault-inducing commits
(described in Section 4.7) as the dependent variable. Each data point is derived at the ﬁles level of a given project’s
snapshot. The metrics used in the regression model include:

13

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

14

• File_ID: A unique identiﬁer is sequentially assigned to every new ﬁle added to the target project since the
beginning of the development. We used this identiﬁer to map the ﬁle history activities, such as a renamed ﬁle
or deleted ﬁles. To assign the identiﬁer, we ﬁrst identiﬁed all code changes at the beginning of the project
development and sequentially assigned a number (from 1) to all unique added ﬁles within the commit. We then
checked for every new commit added to the project repository, and used the git diff command to detect any
code modiﬁcations. For a renamed ﬁle, we mapped all ﬁle paths with the original ﬁle path and assigned the
previous identiﬁer to the ﬁle. For an added ﬁle, we gave a new sequential number. The File_ID was used to
map the technical debts of the same ﬁles that may have been renamed.

• File_size: number of lines of code in a ﬁle as computed by SonarQube. This metric was used as the control

variable when examining the relationship between technical debts and fault inducing occurrence.

• Is_smelly: A dummy value 1 if at least one smell was reported in the ﬁle, otherwise 0.

• Is_erroneous A dummy value 1 if at least one error was reported by SonarQube in the given ﬁle, otherwise 0.

• Tag: Number of diﬀerent types of technical debts in a speciﬁed ﬁle. The full list of types is presented in Table

3 such as ‘accessibility’, ‘brain-overload’, ‘clumsy’, ‘redundancy’.

Approach:. We built Multiple Linear Regression (MLR) models for individual categories and a model for all com-
bined quantum projects using the independent variables discussed above and the total number of fault-inducing com-
mits (identiﬁed in the following Section 4.7) as the dependent variable. We used a separate model to examine how
the technical debt metrics impact each category of the target projects. The combined category model was used to
investigate the eﬀect of each metric on the faults for all the target quantum projects.

Model Building and Evaluation:. We follow two steps suggested in previous studies [116, 22] to build our MLR
models: removing the independent variables and analysis of multicollinearity.
The independent variable removal step eliminates the independent variables that are not statistically signiﬁcant
based on the dependent variable. For this case, we built a multiple regression model using the aforementioned metrics
as independent variables and the number of fault-inducing commits as the dependent variable. We repeated this
process and removed independent variables that have p-value ≥ 0.1, representing statistically non-signiﬁcant variables.
Multicollinearity is a phenomenon that happens when two or more independent variables used in a regression model
are highly correlated. This is an issue because it increases the variance of the regression coeﬃcients, making them
unstable. To check for multicollinearity in the models, we used the variance inﬂation factor (VIF). The VIF score of
an independent variable represents how well the variable is explained by other independent variables. Therefore, the
higher the value of VIF for an independent variable, the higher is the multicollinearity with that particular variable.

In this study, we follow previous works [22] and ﬁlter out independent variables for which VIF > 2.5. We used

the vif function of the car package in R [117] to calculate VIF scores.

Next, we built the ﬁnal model on the ﬁnal set of independent variables. One of the parameters we used to assess
MLR model’s performance is the adjusted R2 value instead of R2. The adjusted R2 is recommended to be more accurate
for model assessment [118] because it reﬂects the complexity of models. Besides, additional independent variables
with lower explanatory power can directly reduce the value of R2, which can be mitigated by using the adjusted R2.
We used the F-test [119] to measure whether any of the independent variables are signiﬁcant in the model. Another
metric we used is Akaike’s Information Criteria (AIC), which aims to add a penalty to the low importance variables
of the model. Likewise, for the model selection, we considered the models with lower AIC values. We will discuss
the results of this analysis in detail in Section 5.3 to answer RQ3.

5. Study Results

This section presents the results of the analysis described in Section 4 answering our proposed questions RQ1

through RQ3.

14

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

15

Figure 5: Eﬀort required to ﬁx technical debts in terms of the debt types (coding errors and code smells)

5.1. RQ1: What Are the Characteristics of Technical Debts in Quantum Software?

We computed the average time to ﬁx each debt type and separately debt severity across the snapshots of a given
project. Figure 5 and 6 present the composition of technical debts by quantum software category. We show the
percentage of the estimated time required to ﬁx the technical debts (errors and code smells) and the severity assessed
based on the total ﬁxing eﬀort in each of the project’s snapshots in a quantum category.

As shown in Figure 5, technical debts reported as code smells would require more ﬁxing eﬀort than errors (po-
tential bugs). It implies that developers need more eﬀort to ﬁx maintenance-related issues (e.g., code smells) than
reliability-related issues (e.g., coding errors). We observed a low value of the standard deviation (σ) across the target
systems (from 2% to 25%), which indicates the consistency of required ﬁxing eﬀort in diﬀerent quantum projects
from diﬀerent categories. Our results also show that coding errors in diﬀerent categories do not require the same
ﬁxing eﬀort. For example, errors in the categories of ‘Quantum-Annealing’, ‘Experimentation’, and ‘Toolkit’ require
the most ﬁxing eﬀort while errors in the categories of ‘Cryptography’, ‘Compiler’, and ‘Quantum-Chemistry’ require
the least ﬁxing eﬀort.

As indicated by [80, 120, 15], technical debts can increase development overhead. Some of our ﬁndings can con-
cretely explain this. For example, in BBN-Q/QGL (an experimental quantum application for domain-speciﬁc language
embedded to specify pulse sequences), SonarQube detected about 2,000 coding errors and 20,000 code smells, which
respectively estimated to require about 42 days and 186 days to ﬁx. Another example is that, in certain programming
languages (such as Python), function names should follow a lowercase convention. Generally, the naming convention
is considered necessary in a project with a shared team for eﬀective collaboration. Renaming each of the functions in
15

SimulatorToolKitFull−stack LibraryQuantum AlgorithsmQuantum AnnealingQuantum−ChemistryAssemblyCompilerCryptographyExperimentationSimulatorToolKitFull−stack LibraryQuantum AlgorithsmQuantum AnnealingQuantum−ChemistryAssemblyCompilerCryptographyExperimentation0255075100025507510002550751000255075100025507510002550751000255075100025507502550751000255075100Quantum categoriesPercentage effort to fix technical debts by typeTypeBugSmellMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

16

Figure 6: Eﬀort required to ﬁx the technical debts in terms of types

BBN-Q/QGL will take an average of two minutes.

We also observed multiple coding errors with the critical severity in the project Quantomatic/pyzx (a compiler
project for rewriting quantum circuit and optimization). For example, a single ﬁle pyzx/circuit.py for representing
a quantum circuit has up to 78 cognitive complexity. Cognitive complexity is a measure of how hard to understand the
control ﬂow in a function, and the high Cognitive Complexity will be challenging to maintain [121]. The maximum
authorized cognitive complexity of the ﬁle is 15, indicating that the ﬁle needs about one hour to get ﬁxed. In another
error with the critical severity, the constructor method uses 12 parameters. A long parameter list indicates that the
function or method is doing too many things, or that a new structure should be created to wrap the numerous param-
eters [122] suggested that functions or methods should use less than 7 parameters to make the code maintainable.
Refactoring each of these functions or methods requires about 20 minutes.

In Figure 6, we further observed that the technical debts with the major and critical severity, require the most
ﬁxing eﬀort, while debts with the blocker severity require the least ﬁxing eﬀort. Compared to other severity types, the
ﬁxing eﬀort of critical debts has a higher standard deviation, which indicates that errors with this level of severity do
not require a similar amount of time to get ﬁxed. In addition, we observed that debts in the categories of ‘Compiler’
and ‘Full-stack Libraries’ require the most ﬁxing eﬀort.

Overall, our ﬁndings are consistent with previous studies [120, 84, 81] where people studied technical debts in
traditional software. For instance, Digkas et al. [84] studied technical debts in 57 software projects developed by
the Apache ecosystem. They presented that more than 68% of identiﬁed technical debts were related to the major
category. Marcilio et al. [81] mined 426 diﬀerent projects and reported that 68% of all types of technical debts belong

16

SimulatorToolKitFull−stack LibraryQuantum AlgorithsmQuantum AnnealingQuantum−ChemistryAssemblyCompilerCryptographyExperimentationSimulatorToolKitFull−stack LibraryQuantum AlgorithsmQuantum AnnealingQuantum−ChemistryAssemblyCompilerCryptographyExperimentation02550751000255075020406001020304050025507502550751000255075100020406002550750255075100Quantum categoriesPercentage effort to fix technical debts by severitySeverityCriticalMajorMinorBlockerMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

17

Table 2: Rules generating about 80% or more of technical debts, indicating the mean percentage of occurrence in overall application snapshots,
severity, type of technical debts, and the descriptions of the rule (as indicated by SonarQube). The highlighted rows indicate the technical debts
with the CRITICAL severity.

Exp

Ann

Fstack

Tkit Chem Comp

Ass

Alg

Sim tag [122]

Example Descriptions

rule(severity)

S117(minor)
S1542(major)
S3776(critical)

Cryp

17.5
32.98
8.92

51.73
6.09
1.98

29.85
6.59
5.13

13.01
6.32
6.43

18.42
6
4.48

11.55
8.15
8.64

2.07
4.17
21.88

26.64
10.54
8.64

25.91
4.35
8.36

36.7
14.01
1.96

convention
convention
brain-overload

S1192(critical)

7.85

1.99

2.79

8.61

14.12

13.69

2.46

2.88

10.56

7.19

design

S1481(minor)

1.77

1.99

12.65

5.89

7.98

5.56

6.46

7.59

6.72

8.25

unused

function/

parameter naming convention
function naming convention
Cognitive Complexity of
method shouldn’t be too long
deﬁne a constant instead of duplicating
this literal
Remove this unused declaration should
be removed
Remove this commented out code

S125(major)
PrintStatement
Usage(major)

0.61

0.54

4.33

1.34

4.69

4.5

1.85

6.04

5.15

10.67

19.12

6.65

5.38

4.88

unused

3.9

18.55

0

0.67

11.75

1.33

python3,obsolete Replace print statement by built-in

function.

S3827(blocker)

0.16

3.95

6.57

1.12

1.47

1.42

0.94

6.49

8.71

0.81

S1117(major)

0.04

0

0

8.26

1.05

0.08

13.95

0.56

0.06

1.58

S5754(critical)

2.01

0.9

0.45

4.43

7.12

1.59

3.64

1.88

0.58

1.94

S100(minor)
S112(major)

2.46
4.19

3.8
0.61

3.27
0.77

4.32
1.46

1.66
3.32

1.85
1.52

0.44
5.61

1.54
1.6

0.31
0.64

0.97
0.3

S1827(major)

0

0.88

0.96

0.21

3.09

0.74

0

1.55

0.57

6.55

S107(major)

0.32

1.04

2

1.48

2.77

1.37

1.15

0.76

2.4

0.82

undeﬁned
usage.
confusing,pitfall,
suspicious
confusing,unpredictable,
error-handling
convention
error-
handling,cwe
user-
experience,html5,
obsolete
brain-overload

Two or more ﬁeld should not be de-
clared with same name
Specify an exception class to catch or
reraise the exception
method naming convention.
replace this generic exception class
with a more speciﬁc one.
Remove this deprecated attribute

S101(minor)
S1066(major)

S116(minor)
BoldItalicTags
Check(minor)
S1186(critical)

0.23
1.04

2

0.02

1.38

0.65
0.38

2.93

0.47

0.39

1.94
0.41

0.19

0.91

0.18

2.13
2.28

1.0

2.64

2.32

1.06
1.36

2.75

0.84

1.48

1.01
1.37

0.84

0.2

0.33

1.57
1.66

0.27

0.34

0.38

1.28
0.68

0.01

3.27

0.57

1.2
1.82

0.21

0.99

0.34

0.22
0.25

convention
clumsy

0.44

convention

parameter list of a function should not
be greater than the 7 authorized.
class naming convention
Merge this if statement with the enclos-
ing one.
ﬁeld naming convention

0.81

accessibility

Replace this <i> tag by <em>.

2.86

suspicious

Add a nested comment explaining why
this method is empty, or complete the
implementation.

84.02

85.45

83.85

80.0

88.02

89.13

86.11

83.8

90.86

91.87

to the major class. Molnar et al. [120] carried out research on technical debts in three Java-based open-source projects.
They showed that the technical debts with major severity account for 57.5% in FreeMind, 74.5% in jEdit, and 61.8%
in TextGuitar. In other words, their result shows that a high percentage of technical debts have a major severity.

In Table 2 and Table 3, we examined the types of technical debts in the target projects based on the set of rules and
types deﬁned by SonarQube [122]. Table 2 shows the set of rules contributing to 80% and more of the overall technical
debts in the target quantum categories. The highlighted rows indicate the debts classiﬁed as CRITICAL. From Table
3, we found the most prevalent types of debts: ‘convention’ (problem with coding convention such as formatting,
naming, white-space), ‘unused’ (unused code, e.g., commented out code or unused private variable), ‘brain-overload’
(related to cognitive complexity, there is too much code to keep in the head at once), ‘design’ (the design of the code is
questionable, e.g., duplicate string literals),‘cwe’ (relates to a rule in the Common Weakness Enumeration [123]), and
clumsy (unnecessary steps was used on something that should be straightforward) [122]. According to our ﬁndings
in Table 3, the type ‘code convention’ dominates in at least 50% of the studied categories, followed by the high rate
of ‘unused code’, ‘design smells’ and ‘brain-overload’. We also observe that ‘Quantum Chemistry’ shows a higher
percentage of code deprecation and design issues.
In addition, a high percentage of code in the ‘Compiler’ and
‘Full-stack Library’ categories are characterized as confusing and suspicious.

In our manual investigation of source codes of two projects from ‘Compiler’ category (Quantomatic/pyzx and
QE-Lab/OpenQL) we found that most of the technical debts were related to handling and generating graphs, bench-
marks, unreachable code (due to jump statements), and unexpected expressions.
Also, we manually investigating the source code for the project artiste-qb-net/qubiter of Assembly category.
We observed most of the code smells and coding errors detected (such as suspicious code, design, unused, brain-
overload) are related to the source code for implementing in-memory storage of the circuits. In artiste-qb-net/
qubiter, circuits are stored entirely in memory, essentially as Python lists of gates. Lists of this type can be sliced,

17

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

18

Table 3: Types of technical debts that contribute to greater than 80% of the overall technical debts across diﬀerent categories of the quantum
projects (s for code smells and e for coding errors).

Tag [122]

Type Cryp Exp

Ann Fstack

Tkit Chem Comp

Ass

Alg

Sim

convention
unused
brain-overload
design
obsolete
cwe
confusing
error-handling
accessibility
suspicious
python3
user-experience
html5
unpredictable
wcag2-a
clumsy
Total

s, e
s, e
s
s
s, e
s, e
s, e
s, e
s, e
s, e
s, e
s, e
s, e
s
s, e
s

48.31
2.62
7.62
6.44
0.45
3.77
3.1
5.08
6.93
2.65
0.45
0
0
1.64
6.92
1.59
97.57

56.9
6.74
2.64
1.73
4.12
2.61
1.16
1.42
0.74
1.07
1.18
3.03
2.95
0.85
0.33
0.43
87.9

36.92
15.62
6.25
2.48
6.38
1.33
0.94
1.09
1.02
1.09
3.96
2.44
2.44
0.4
0.21
0.6
83.17

18.49
8.03
5.45
6.13
4.83
3.45
11.28
4.48
3.83
9.2
4.67
1.49
0.16
3.3
2.02
1.96
88.77

21.66
10.63
5.16
10.05
6.82
3.95
6.38
7.46
2.33
2.33
2.78
4.05
4.01
5.04
1.69
1.65
95.99

17.65
13.52
7.48
10.28
14.75
3.04
1.63
2.77
3.17
1.19
14.15
0.69
0.66
1.35
3.02
1.51
96.86

6.14
18.87
15.67
1.96
0
5.5
13.74
6.33
0.47
11.03
0
0
0
2.51
0.24
2.45
84.91

37.99
14.61
8.14
2.63
3.09
2.71
2.87
2.95
4.31
1.92
0.57
2.78
2.52
1.59
1.53
1.15
91.36

26.44
12.45
8.96
8.93
10.9
3.08
1.13
1.08
1.05
1.24
9.91
1.21
1.2
0.48
0.23
1.61
89.9

40.71
11.56
2.16
5.8
6.19
0.54
3.53
2.43
3.18
3.78
1.04
5.43
5.15
2.1
2.52
0.34
96.46

combined, etc. When using such lists, it is easy to randomly access any gate of the circuit at will, for instance, when
doing circuit optimizations (e.g., replacing the circuit with an equivalent shorter one). artiste-qb-net/qubiter
uses a Python list of the lines stored as strings of the circuit’s English ﬁle. For example, we observed multiple empty
blocks of codes detected as ‘suspicious’ in the function for generating the Python list of gates of Hermitian conjugate.
These features are particular in quantum software, while in traditional software, the most frequent technical debts are
related to diﬀerent groups. Marcilio et al. [81] explained that the problems regarding packages and exception handling
contain the biggest proportion of technical debts in their studied projects. Digkas et al. [84] also reported that the most
frequent technical debts are related to resource management, null pointer, and exception handling problems.

We also observed that the ﬁles containing debts have high cognitive complexity due to a large number of code
lines, loops, and if-else statements. For example, a function used for computing the echelon form of a matrix has
the cognitive complexity of 155, which exceeds the maximum allowed cognitive complexity of the function (i.e.,
140). Moreover, we found 86.6% of the code duplication on 70,000 lines in Quantomatic/pyzx and 88.9% code
duplication on 1.3M lines in QE-Lab/OpenQL.

We will further discuss the implication of our ﬁndings in Section 6.

On the one hand, more than half of technical debts in all kinds of software systems (quantum and non-quantum) are
classiﬁed as major from the severity point of view. On the other hand, the most frequent types of technical debts are
diﬀerent in various software types. With respect to this fact, we found that the most frequent technical debts in quantum
computing software systems are related to the ‘code convention’, ‘design issue’, ‘brain-overload’, and ‘error-handling’
problems.

5.2. RQ2: How Do Technical Debts Evolve Over Time?

This section discusses how technical debts evolve in the target quantum projects. From the 10 identiﬁed quantum
software categories, we selected the 8 most representative categories, i.e., ‘Assembly’, ‘Quantum-Annealing’, ‘Ex-
perimental’, ‘Full-stack Library’, ‘Quantum-chemistry’, ‘Toolkit’, ‘Simulator’, and ‘Quantum-Algorithms’. Figure 7
(7a to 7t) provides the general summary of how the technical debts (in terms of code errors on the left and code
smells on the right) evolve in eight of the studied categories. Each line represents the evolution of technical debt ratio
(TDR, described in Section 4.4.1) on the y-axis and the number of days based on 90 days intervals (snapshots) on the
x-axis, for a single project. In the following, we report our results from manually analyzing two projects in each of
the categories and discuss the evolution of technical debts in detail.

18

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

19

(a) Assembly (code errors)

(b) Assembly (code smells)

(c) Quantum Annealing (code errors)

(d) Quantum Annealing (code smells)

(e) Experimentation (code errors)

(f) Experimentation (code smells)

(g) Full-stack Library (code errors)

(h) Full-stack Library (code smells)

19

0200400600800100012000.00%0.50%1.00%1.50%2.00%2.50%TDR (% percentage of coding errors)pyqgl2blackbirdqubiterqmasm0200400600800100012000.0%2.0%4.0%6.0%8.0%10.0%12.0%14.0%TDR (% percentage of code smells)pyqgl2blackbirdqubiterqmasm0200400600800100012000.0%5.0%10.0%15.0%20.0%25.0%30.0%35.0%TDR (% percentage of coding errors)sqaoddwavebinarycspqbsolvdwave-systemdimodpenaltymodel0200400600800100012000.0%5.0%10.0%15.0%20.0%25.0%TDR (% percentage of code smells)sqaoddwavebinarycspqbsolvdwave-systemdimodpenaltymodel050010001500200025000.0%5.0%10.0%15.0%20.0%TDR (% percentage of coding errors)pyEPRQGLquantum-shellPyQLabQlabartiqpyrplqupulseQuantumInformation.jl050010001500200025000.0%5.0%10.0%15.0%20.0%25.0%30.0%35.0%40.0%TDR (% percentage of code smells)pyEPRQGLquantum-shellPyQLabQlabartiqpyrplqupulseQuantumInformation.jl0200400600800100012000.000%0.100%0.200%0.300%0.400%TDR (% percentage of coding errors)qiskit-terraQuantumLibrariesQuantum0200400600800100012000.0%2.5%5.0%7.5%10.0%12.5%15.0%17.5%20.0%TDR (% percentage of code smells)qiskit-terraQuantumLibrariesQuantumMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

20

(i) Quantum Chemistry (code errors)

(j) Quantum Chemistry (code smells)

(k) ToolKit (code errors)

(l) ToolKit (code smells)

(m) Simulator (code errors)

(n) Simulator (code smells)

(o) Quantum Algorithms (code errors)

(p) Quantum Algorithms (code smells)

20

020004000600080000.00%0.50%1.00%1.50%2.00%2.50%TDR (% percentage of coding errors)QCElementalQCEnginebasis_set_exchangeCheMPS2libra-codepyscfQCFractalmpqc020004000600080000.0%5.0%10.0%15.0%20.0%25.0%TDR (% percentage of code smells)QCElementalQCEnginebasis_set_exchangeCheMPS2libra-codepyscfQCFractalmpqc020040060080010000.0%2.5%5.0%7.5%10.0%12.5%15.0%17.5%20.0%TDR (% percentage of coding errors)QPanda-2quantumrandomqiskit-ignisQUBEKitpennylaneforest-benchmarkingaiida-quantumespressoQGIS-visibility-analysisqucatquantum020040060080010000.0%2.0%4.0%6.0%8.0%10.0%12.0%14.0%16.0%TDR (% percentage of code smells)QPanda-2quantumrandomqiskit-ignisQUBEKitpennylaneforest-benchmarkingaiida-quantumespressoQGIS-visibility-analysisqucatquantum025050075010001250150017500.0%1.0%2.0%3.0%4.0%5.0%6.0%TDR (% percentage of coding errors)nuSQuIDSqpp025050075010001250150017500.0%5.0%10.0%15.0%20.0%25.0%TDR (% percentage of code smells)nuSQuIDSqpp020040060080010000.0%2.0%4.0%6.0%8.0%10.0%TDR (% percentage of coding errors)EDLibkrotovnetketqrefinegrovefactoringqiskit-aquaFermiLibthewalrusOpenFermion020040060080010000.0%2.0%4.0%6.0%8.0%10.0%12.0%TDR (% percentage of code smells)EDLibkrotovnetketqrefinegrovefactoringqiskit-aquaFermiLibthewalrusOpenFermionMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

21

(q) Cryptography (code errors)

(r) Cryptography (code smells)

(s) Compiler (code errors)

(t) Compiler (code smells)

Figure 7: How the technical debts (coding errors on the left and code smells on the right) evolve for ten randomly selected projects in each of
the eight studied categories with high rate of technical debts. Each line represents the evolution of technical debt ratio (TDR, described in Section
4.4.1) on the y-axis and the number of days based on 90 days interval (snapshots) on the x-axis, for a single project.

21

020040060080010001200140016000.00%0.10%0.20%0.30%0.40%0.50%0.60%TDR (% percentage of coding errors)pqm4QRLcodecryptquantum020040060080010001200140016000.0%2.5%5.0%7.5%10.0%12.5%15.0%17.5%TDR (% percentage of code smells)pqm4QRLcodecryptquantum0200400600800100012000.0%1.0%2.0%3.0%4.0%5.0%TDR (% percentage of coding errors)pyzxOpenQLqsharp-compiler0200400600800100012000.0%5.0%10.0%15.0%20.0%25.0%TDR (% percentage of code smells)pyzxOpenQLqsharp-compilerMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

22

(a) Assembly (qubiter)

(b) Assembly (pyqgl2)

(c) Quantum Annealing (dwave-system)

(d) Quantum Annealing(qbsolv)

(e) Experimentation (PyQLab)

(f) Experimentation (QGL)

(g) Full-stack library (strawberryﬁelds)

(h) Full-stack library (Blueqat)

22

(i) Quantum-chemistry (QCFractal)

(j) Quantum-chemistry (CheMPS2)

02004006008000.0%1.0%2.0%3.0%4.0%5.0%6.0%7.0%8.0%TDR (% percentage)020406080100120KLOC02004006008000.0%2.0%4.0%6.0%8.0%10.0%12.0%14.0%TDR (% percentage)05101520253035KLOC0200400600800100012000.0%2.0%4.0%6.0%8.0%10.0%12.0%14.0%16.0%TDR (% percentage)510152025KLOC020040060080010000.0%5.0%10.0%15.0%20.0%25.0%30.0%35.0%TDR (% percentage)0.51.01.52.0KLOC025050075010001250150017500.0%2.5%5.0%7.5%10.0%12.5%15.0%17.5%TDR (% percentage)01020304050KLOC050010001500200025000.0%5.0%10.0%15.0%20.0%25.0%30.0%35.0%40.0%TDR (% percentage)010203040506070KLOC01002003004005006007008000.00%1.00%2.00%3.00%4.00%TDR (% percentage)1015202530354045KLOC01002003004005006000.0%1.0%2.0%3.0%4.0%5.0%6.0%TDR (% percentage)012345KLOC020040060080010000.00%0.50%1.00%1.50%2.00%2.50%3.00%TDR (% percentage)020406080100120140KLOC02004006008001000120014000.0%2.0%4.0%6.0%8.0%10.0%12.0%14.0%16.0%TDR (% percentage)01234567KLOCMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

23

(k) Toolkit (qucat)

(l) Toolkit (bloomberg)

(m) Simulator (SimulaQron)

(n) Simulator (Quirk)

(o) Quantum algorithm (grove)

(p) Quantum algorithm (qiskit-aqua)

23

01002003004000.0%1.0%2.0%3.0%4.0%5.0%6.0%7.0%TDR (% percentage)0102030405060KLOC01002003004005006007000.0%5.0%10.0%15.0%20.0%25.0%30.0%35.0%TDR (% percentage)51015202530KLOC02004006008000.0%1.0%2.0%3.0%4.0%5.0%6.0%7.0%8.0%TDR (% percentage)1020304050607080KLOC02004006008001000120014000.00%0.10%0.20%0.30%0.40%0.50%0.60%0.70%TDR (% percentage)020406080100120KLOC01002003004005006000.0%2.0%4.0%6.0%8.0%TDR (% percentage)01234KLOC01002003004005006007008000.0%1.0%2.0%3.0%4.0%5.0%6.0%7.0%TDR (% percentage)010203040506070KLOCMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

24

(q) Cryptography (pqm4)

(r) Cryptography (QRL)

(s) Compiler (OpenQL)

(t) Compiler (pyzx)

Figure 8: How the technical debts (coding errors
) evolve with development activities (the added and deleted lines of code
) for two randomly selected projects in each of the eight studied categories with high rate of technical debts. We show the technical
(KLOC)
debt ratio (TDR, described in Section 4.4.1) on the left side of y-axis and the KLOC on the right side (calculated from LOC returned by SonarQube)
and the number of days based on 90 days interval (snapshots) on the x-axis.

and code smells

24

012345678No. snapshots0.0%2.5%5.0%7.5%10.0%12.5%15.0%17.5%TDR (%ge)pqm4(Cryptography)new smellsnew bugs0.000.050.100.150.200.250.300.35KLOCKLOC024681012No. snapshots0.0%2.0%4.0%6.0%8.0%10.0%12.0%14.0%TDR (%ge)QRL(Cryptography)new smellsnew bugs020406080100120KLOCKLOC02468101214No. snapshots0.0%5.0%10.0%15.0%20.0%25.0%TDR (%ge)OpenQL(Compiler)new smellsnew bugs020406080100120KLOCKLOC012345678No. snapshots0.0%2.0%4.0%6.0%8.0%10.0%12.0%TDR (%ge)pyzx(Compiler)new smellsnew bugs0246810121416KLOCKLOCMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

25

Table 4: The Spearman rank correlation coeﬃcient that evaluates the correlations between the total technical debts in a ﬁle and the lines of code of
the ﬁle. We calculated the correlation coeﬃcient for two randomly selected quantum projects from each quantum categories in Fig. 8.
Statistical signiﬁcance denoted as: ***< 0.001, **< 0.01, *< 0.05

Category

Assembly

Quantum-Annealing

Experimental

Full-stack Library

Quantum-Chemistry

Toolkit

Simulator

Quantum-Algorithms

Target project
qubiter
pyqgl2
dwave-system
qbsolv
PyQLab
QGL
strawberryfields
Blueqat
QCFractal
CheMPS2
qucat
bloomberg/quantum
SimulaQron
Quirk
grove
qiskit-aqua

correlation
0.622
0.895
0.893
0.879
0.940
0.936
0.895
0.902
0.903
0.883
0.820
0.949
0.855
0.584
0.838
0.860

p-value
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗∗
∗∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗
∗ ∗ ∗

Fig. 8 (8a to 8t) illustrates how new technical debts were added to the projects over time across the studied
snapshots. The technical debt in the ﬁrst snapshot of each application is new; the divergence from the horizontal line
indicates the supplementary debt that has been introduced or removed or both. Each sub-ﬁgure is scaled to indicate
the technical debts ration (TDR) on the left and KLOC on the right. The KLOC allows us to identify the snapshots
where key development activities took place, such as new code added or deleted and how these activities are related
to technical debts.

In the ﬁgure, we observed that there is a general sharp raise of TDR at the initial phase of the software development
(more than 10% of corresponding to SQALE maintainability rating from B and C), which later gradually decreased
as the code base matured in most of the target projects. Also, according to Fig. 8, we found that the introduction of
technical debts is highly related to the project size (KLOC). For the Assembly project artiste-qb-net/qubiter,
we can see that most of the code was added within the ﬁrst two snapshots (corresponding to the development time of
up to 180 days), in which most new added debts are related to code smells. We observed fewer code changes in the
later snapshots of the project. These changes have little relationship with technical debts. Similarly, we observed a
sharp rise of technical debts in the BBN-Q/pyqgl2 project.

For the case of the Quantum Annealing project dwavesystems/qbsolv, the majority of the codebase was added
between the ﬁrst 90 and 180 days. The added code contains more coding errors than code smells. The number of
technical debts remains stable in the later snapshots of the project. Similar trends are observed in the Full-stack library
project Blueqat/Blueqat where more coding errors were detected mainly in the initial snapshot of the projects
compared to the later snapshots.

Higher debts and the sharp rise of code lines at the initial snapshots may be due to the fact that most new ﬁles
are added at the initial phase of the development. When a project becomes mature, fewer added and deleted lines
are observed, which can be associated with minor or modiﬁcation changes. This was also observed in some of the
projects such as artiste-qb-net/qubiter where a single commit #e3f5539 added 71 new ﬁles with over 8,800
new lines of code in the ﬁrst snapshot. With a manual investigation on 30 of these ﬁles, we found both coding errors
and code smells existing in the ﬁles. Some of the ﬁles were later refactored, which implies that developers realized the
technical debts and removed them. Tsoukalas et al. [124] carried out research on 15 open-source projects and showed
that complexity and LOC are two of the most signiﬁcant indicators of technical debts. Siavvas et al. [125] also studied
150 open-source software projects and reported that cyclomatic complexity of code is one of the key indicators of
technical debts.

25

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

26

Figure 9: Percentage of unique ﬁles contributing to 80% of the overall technical debts across the snapshots of the selected projects.

We observed a similar relation for quantum projects. We observed a high positive correlation between ﬁle size
and the amount of technical debts. Table 4 presents the results of our correlation analysis (using the Spearman rank
correlation test [88]) between ﬁle size (LOC) and reported new technical debts across the snapshots of the randomly
selected quantum projects from Fig. 8). The low values of standard deviation indicate that the results are consistent
across the project snapshots. We also found that at least half of the reported technical debts are contributed by the
top 20% of ﬁles (according to LOC) in all the studied snapshots, while the bottom 20% of ﬁles only introduced a few
technical debts (≤ 5%). Fig. 9 illustrates the percentage of unique ﬁles contributing to at least 80% of the technical
debts across the snapshots of our studied projects. Our results conﬁrms the Pareto’s principle (80-20 rule) [126] and is
in line with the previous studies [127, 120] on software defects and technical debts in traditional software. Walkinshaw
et al. [127] studied 100 open-source projects and reported that 80.5% of ﬁxes are related to just 20% of the ﬁles in all
projects. Besides, they identiﬁed that near to 73% of LOC of the top 20% ﬁles are involved in the top 80% of ﬁxes.

Technical debts tend to be added in the initial versions of a project in quantum computing software systems. Furthermore,
similar to other types of software systems, we show that LOC is a key indicator of the occurrence of technical debts in
quantum computing software systems.

5.3. RQ3: What Is the Relationship Between Technical Debts and Faults?

In Section 4.8, we described the steps used to examine the relationship between technical debts and faults in-
troduced, as well as metrics that are related to the fault-inducing changes. This section discusses the results of the
analysis of Section 4.8.

Tables 5 and 6 presents the Multiple Linear Regression (MLR) model ﬁtting results showing the relationship
between technical debt as dependent variables and the fault-inducing commits as the independent variable. The
dependent variables is_smelly and is_errorneous indicate if a given ﬁle contains at least one technical debt of type
code smell and code error, respectively. The rest of the independent variables are the total counts of diﬀerent technical
debts by tags (tags presented in Table 3) in a given ﬁle across the project’s snapshots.

Table 5 reports the MLR results after ﬁtting the model on all the quantum projects as one dataset (i.e., the debts
reported for all the target projects as independent variables and the total number fault-inducing commits as dependent
variable at ﬁle level). In Table 6, we present the MLR ﬁt result for the 10 individual quantum categories. We only
26

0.02.55.07.510.012.515.017.520.0Percentage of unique files contributing to 80% of the technical debtsAlgo(qiskit-aqua)Algo(grove)Sim(Quirk)Sim(SimulaQron)Tkit(quantum)Tkit(qucat)Chem(CheMPS2)Chem(QCFractal)Fstack(Blueqat)Fstack(strawberryfields)Exp(QGL)Exp(PyQLab)Ann(qbsolv)Ann(dwave-system)Ass(pyqgl2)Ass(qubiter)The selected projectMoses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

27

Table 5: p-values for statistical signiﬁcance and the coeﬃcient for the Multiple Linear Regression (MLR) model based on all quantum projects
(ALL-QT). The model uses the fault-inducing commits as dependent variable and the list of independent variables derived from technical debts
types (as described in Section 4.8).
Statistical signiﬁcance denoted as: ***< 0.001, **< 0.01, *< 0.05,
† variable removed during VIF analysis,
‡ variable removed during stepwise selection criteria.

coef/p-value

is_smelly
is_erroneous

project

accessibility
brain-overload
design
unused
convention
cwe
redundant
confusing
error-handling
obsolete
user-experience
suspicious
Adj. R2
Prob (F-stat)
AIC

ALL-QT
2.045e-06∗∗∗
2.045e-06∗∗∗

‡

‡
2.497e-05∗∗∗
1.853e-09∗∗
‡
3.867e-06∗
‡
0.0003∗∗∗
‡
1.687e-09∗∗
‡
‡
‡

0.074
0.00
-2.039e+06

Table 6: p-values for statistical signiﬁcance and the coeﬃcient for the MLR model based on individual quantum categories. The model uses the
number of fault-inducing commits as dependent variable and the list of independent variables derived from technical debts types.
Statistical signiﬁcance denoted as: ∗ ∗ ∗ < 0.001, ∗∗ < 0.01, ∗ < 0.05,
† variable removed during VIF analysis,
‡ variable removed during stepwise criteria.

coef/p-value

is_smelly
is_erroneous

project

accessibility
brain-overload
design
unused
convention
cwe
redundant
confusing
error-handling
obsolete
user-experience
suspicious
Adj. R2
Prob (F-stat)
AIC:

Fstack

Tkit

Exp

Sim

0.1115∗∗∗
0.2100∗∗∗

‡

‡
0.7717∗∗∗
0.1035∗∗∗
‡
0.0790∗∗∗
‡
1.8002∗∗∗
†
‡
†
‡
0.3689∗∗∗
0.210
0.00
-9139.

0.0012∗∗∗
0.0013∗∗∗

0.0005∗∗∗

‡
†
0.0183∗∗∗
‡
0.0085∗∗∗
0.0053∗∗∗
0.0385∗∗∗
0.0262∗∗∗
‡
‡
‡
‡

0.0023∗∗∗
0.0042∗∗∗

0.0108∗

†
0.0813∗∗∗
0.0023∗∗∗
0.0169∗∗∗
‡
0.0231∗
‡
0.0281∗∗∗
0.0050∗∗∗
†
†
0.0023∗∗

0.197
0.00
-9.767e+04

0.291
9.40e-249
-2.273e+04

0.0938∗∗∗
‡

‡

‡
†
0.0976∗∗∗
0.0497∗∗∗
0.0475∗∗∗
4.2227∗∗∗
0.7558∗∗∗
0.4411∗∗
0.0385∗
†
‡
‡

0.203
0.00
-8373.

Crypt

0.0002∗∗∗
0.0003∗∗∗

0.0120∗∗

†
†
1.011e-05∗∗∗
†
†
0.0001∗∗
†
†
0.0005∗∗∗
†
†
5.244e-05∗∗∗
0.554
0.00
-5.372e+04

27

Alg

Chem

Asm

Ann

Comp

0.0410∗∗∗
0.0230∗∗

0.9320∗∗∗

†
†
†
†
‡
†
2.4618∗
†
‡
†
†
†

0.0259∗∗∗
0.0080∗∗

†

†
0.1778∗∗∗
0.0735∗∗
‡
0.0214∗∗∗
‡
‡
0.2032∗∗∗
0.0791∗
†
‡
‡

0.0632∗∗∗
0.1433∗∗∗

2.9523∗∗∗

‡
†
‡
0.2327∗∗∗
‡
‡
2.2455∗
‡
0.0260∗∗
†
‡
‡

0.094
3.28e-58
-1.243e+04

0.236
1.69e-274
-2.136e+04

0.028
2.36e-284
-5.435e+04

0.0073∗∗∗
0.0084∗

0.0088∗∗
0.0136∗∗

‡

‡

‡
0.1323∗∗
‡
0.0087∗∗∗
†
†
‡
‡
0.0206∗
†
‡
‡

0.359
1.69e-44
-3141.

†
0.2321∗∗∗
‡
‡
‡
‡
‡
0.2616∗
‡
†
†
‡

0.175
1.72e-34
-5411.

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

28

reported the MLR model results for the p-value that is less and equal to 0.05 (i.e., p-value ≤ 0.05), the positive
coeﬃcient for statistically signiﬁcant independent variables, and the variance inﬂation factor (VIF) that is less and
equal to 2.5. The positive coeﬃcient indicates the positive correlation between the independent variables (number of
technical debts) and the dependent variable (number of fault-inducing commits).

From Tables 5 and 6, we observed a statistically signiﬁcant correlation between code smells and the number of
fault-inducing changes, which is shown by the positive coeﬃcient values of ‘is_smelly’ in all the categories of studied
projects. The high positive coeﬃcient of ‘is_smelly’ for the quantum category ‘Full-stack Library’, ‘Simulator’,
‘Quantum Chemistry’, ‘Compiler’, and ‘Quantum Algorithm’ also shows that there is a particularly high correlation
between the code smells and the number of fault-inducing commits in the respective target quantum software. In
addition, we found statistically signiﬁcant correlation between the coding errors and the number of fault-inducing
commits in most (80%) of the target quantum categories. In particular, the coding Error shows a higher positive
correlation on the fault introduced in the ‘Full-stack Library’, and ‘Quantum Chemistry’ categories.

Moreover, Table 6 presents the correlation of technical debts based on the tag and the number of fault-inducing
commits. Our results show that the tags ‘design’, ‘redundant’, ‘error-handling’, and ‘brain-overload’ have a statisti-
cally signiﬁcant correlation with the number of fault-inducing commits in most (≥ 50%) of the quantum categories.
This result suggests that the tags ‘design’, ‘redundant’, ‘error-handling’, and ‘brain-overload’ would help predict the
occurrences of fault-inducing commits in quantum software systems. The design technical debt has higher posi-
tive correlation to fault-inducing in Full-stack libraries, quantum simulators and Toolkit categories, ‘brain-overload’
shows a higher positive correlation with the number of fault-inducing commits in the quantum categories in the order
‘Full-stack Library’, ‘Quantum-Annealing’, ‘Quantum-algorithms’ and ‘Assembly’.

Comparing the technical debts tags across the project categories, ‘brain-overload’ shows a higher positive correla-
tion with the number of fault-inducing commits in the quantum categories in the order ‘Full-stack Library’, ‘Quantum-
Annealing’, ‘Quantum-algorithms’ and ‘Assembly’. Similarly, the design related technical debt has higher positive
correlation to fault-inducing in ‘Full-stack Library’. Moreover, the technical debt of tag ‘redundant’ introduces more
faults in the categories ‘Compiler’, ‘Quantum-Chemistry’. Finally, in Table 6 we observed that most of the tags are
statistically signiﬁcantly correlated with the number of fault-inducing commits in the quantum categories of ‘Experi-
mentation’, ‘Simulator’ and ‘Quantum Algorithms’, whereas only fewer (≤ 20%) of the tags are correlated with the
fault-inducing commits in the categories ‘Compiler’ and ‘Quantum Annealing’. This implies that these technical debt
tags can be included to predict the number of fault-inducing commits in the respective quantum categories.

Previous studies also reviewed the relationship between technical debts and types of faults in diﬀerent types of
software systems. Digkas et al. [83] carried out a research on 66 open-source java based software projects developed
by the Apache software foundation. They showed that ’literal duplicate’ is the most frequent type of technical debts.
They also observed that this type of technical debts are equally distributed among their analyzed systems. Moreover,
they revealed that ‘using diamond operation’ and ‘code comment-out’ are the least equally distributed technical debts
among their studied software systems. Tan et al. [80] studied 44 open-source software systems based on Python
belonging to the Apache software foundation. They indicated that ‘deﬁning docstring’, ‘too long lines’ and ‘undeﬁned
variables’ are the top three types of technical debts identiﬁed in those projects. Moreover, they mentioned that ‘empty
nested block’ and ‘too many line of code in a ﬁle’ are the least frequent types of technical debt.

As expected, the correlation between technical debts and the number of faults introduced are diﬀerent based on the nature
of software systems. On the other hand, the technical debts of types ‘design’, ‘redundant’, ‘error-handling’ and ‘brain-
overload’ can be a good indicator to predict the number of fault-inducing commits in quantum software since they have
the highest signiﬁcance in most of our studied quantum projects.

6. Discussion and Implication

In this section, we further elaborate on the results shown in Section 5 and highlight the implications of the results

to the researchers and the developers of quantum software.

As the initial step, we investigated the representation of maintainability and reliability in the overall technical
debts in quantum software systems as shown in Figure 5. We then broke down the technical debt based on the severity
(in Figure 6) and examine the rules distributions across the diﬀerent categories of technical debt. We found that
28

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

29

about 80% of the technical debts are related to code smells and most of these debts are related to critical and major
severity types. We also highlighted some of the examples for critical debts as reported in Table 2. We believe that this
information can help practitioners prioritize resource allocation to refactor their code, speciﬁcally on the code with
critical technical debts.

In our manual investigation of the quantum project of compiler category, we observed that technical debts are
found most in source code for handling and generating graphs, benchmarks, unreachable code (due to inappropriate
exit points, control ﬂow or jump statements), and unexpected expressions. We also observed code smells due to mul-
tiple empty blocks of codes detected as ‘suspicious’ in the source code generating Python list to store gates which is
of Hermitian conjugate, in the Assembly project. The related source code implementing the in-memory storage of cir-
cuits were also associated with other technical debts such as design, unused code, brain-overload (related to cognitive
complexity). Implementing in-memory storage of circuits can be helpful in quantum Assembly for easy randomly
access any gate of the circuit, for instance, during circuit optimizations. These features are particular in quantum
software. Usually, a typical quantum program consists of blocks of code, each of which contains both classical and
quantum components to execute classical instructions and quantum instruction, respectively. Classical instructions
operate on the state of classical bits and apply conditional statements. They are also used for post processing the
outcome of measurements on qubits, while quantum instructions operate on the state of qubits and measure the qubit
values [77]. Studies on traditional software by Marcilio et al. [81] revealed that the problems regarding packages
and exception handling contain the biggest proportion of technical debts in their studied traditional projects. Digkas
et al. [84] also reported that the most frequent technical debts are related to resource management, null pointer, and
exception handling problems.

In Table 3 we showed that a few types of technical debts contribute to about 80% and more of the overall tech-
nical debts. These dominating types include ‘code convention’, ‘unused’, ‘design issues’ (the design of the code is
questionable, e.g., duplicate string literals), ‘brain-overload’, ‘obsolete’, ‘accessibility,’ ‘cwe,’ ‘confusing’ and ‘error-
handling’. Our ﬁnding is in line with the Pareto principle hence its application. We have also shown that the type
‘code convention’ dominates in more than 50% of the studied quantum categories. Therefore, we recommend that
quantum developers should follow the coding convention to avoid confusion and allow eﬃcient team collaboration.

Lenarduzzi et al. [12] have shown that constraints such as time and budgets are the root causes of technical debts.
Also, factors such as refactoring eﬀorts and architectural changes have been mentioned to inﬂuence technical debt
in the software projects as compared to the changes in the line of code [59, 30]. We investigated how and when the
technical debts are introduced into the code base of quantum software systems to improve our understanding and
verify whether similar trends can be identiﬁed for technical debt in a quantum software system. Fig. 8 shows how
the code changes are related to technical debts and how these trends evolve over time. We found that most of the
technical debts are associated with the initial versions, where most new code or source ﬁles are added. Our result
indicates that less than 20% of the studied ﬁles with large ﬁle size introduced most of the technical debts across the
studied snapshots of the quantum projects. This result is inline with the studies on traditional software [30, 31]. Our
ﬁnding suggests that quantum software developers should pay attention to the code quality and code size, especially
when new ﬁles are added. They should more carefully review and test the commits with a large number of changes.
Quantum developers should also consider using the traditional static code analysis tools to detect and monitor their
source code at the early stage of development to reduce future maintenance costs. In the future, we plan to examine
the lifespan of quantum software faults and how developers prioritize resolving these faults based on the types and
severity.

In Table 5, we found that there is a statistically signiﬁcant correlation between the technical debts and the number
of fault-inducing commits in the studied quantum projects. We observed that the debt types related to cognitive
complexity (brain-overload), code design, redundant code and error-handling show a signiﬁcant correlation with fault-
inducing commit occurrences in about 60% of the quantum categories. We recommend that developers should use
these metrics as measures to predict faults in quantum software systems especially when the developers are working
on projects related to ‘Full-stack Library’, ‘Quantum-annealing’, ‘Quantum-chemistry’, ‘Quantum-algorithms’, and
‘Compiler’. Also, as we observed the statistical signiﬁcant correlation between design-related technical and faults
introduced in most (60%) of the studied quantum categories, we recommend that practitioners should implement
more systematic testing on quantum software systems that reﬂect the structural nature of the quantum software. We
suggest that the quality assurance team for quantum software systems should eﬀectively allocate more resources and
time to thoroughly validate and test the complex components and the components related to error handling before
29

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

30

integrating new commits.

We suggest that developers should use existing static analysis tools to detect potential problems that also happen
in traditional software. We also appeal the quantum software community to introduce new tools to detect quantum-
speciﬁc errors or technical debts.

7. Threats to Validity

There are several threats that can potentially aﬀect the validity of our study. In this section, we discuss the threats
to validity of our study by following the guidelines for case study research. We followed the best practice deﬁned to
evaluate our study as presented by Runeson et al. [128].

Threats to construct validity. are concerned with the relationship between theory and observation. We used the SZZ
algorithm to identify the changes that introduced faults. This algorithm assumes that faults are introduced by the lines
that are later ﬁxed by fault-ﬁxing commits. However, in a fault-ﬁxing commit, not all of the changed lines are used
to ﬁx faults. To mitigate this threat, we used the PyDriller which eliminate the candidates of fault-inducing commits
that only changed white spaces. Muse et al. [129] manually validated the precision of PyDriller and showed that the
tool only yielded 6% of false positives. In addition, we used the topic modeling technique to automatically extract the
characteristics of the fault-inducing changes. Some characteristics may be missed during this automatic process. In
future work, we plan to select a sample of the fault-inducing commits, and manually analyze the root causes and the
symptoms of the faults.

Threats to internal validity. are concerned with the factors that may aﬀect a dependent variable and were not consid-
ered in the study. We manually selected quantum related projects and grouped the projects into diﬀerent categories.
To minimize this threat, the project selection and categorization were performed by two of the authors independently.
They discussed each of the discrepancies until a mutual agreement was reached. We shared our dataset online 1.
Future studies can replicate and validate our results.

Threats to conclusion validity. are concerned with the relationship between the treatment and the outcome. We
detect the technical debts from quantum software by using a static analysis tool (SonarQube), which is designed
for traditional software. However, to mitigate this threat we limit our studied projects to be those that are written in
traditional programming languages and can be analyzed by traditional static code analysis tools. Validating our results
on the software running speciﬁcally on quantum computers will be our future work. To validate the detection accuracy
of SonarQube on technical debts, we manually examined 500 technical debts identiﬁed by the tool and observed that
98% of the technical debts are correct. Throughout our discussion in Section 5, we highlighted the technical debts
that are validated in our manual validation. In addition, we relied on a set of rules deﬁned by SonarQube to identify
diﬀerent types of technical debts. These rules may not capture all possible technical debts. In the future, we plan to
use other equivalent tools to verify our results and perform manual analyses to ﬁnd out which kinds of debts cannot
be identiﬁed by the state-of-the-art tools and will suggest the software engineering community to improve the static
analysis tools on this aspect.

Threats to external validity. are concerned with the generalizability of our results. To study the characteristics of
technical debts and faults in quantum software, we analyzed 118 open-source quantum projects from GitHub. Our
selected projects are related to diﬀerent domains of quantum computing. Our results can be considered as a reference
for quantum developers and researchers to improve their software quality in terms of maintainability and reliability.
However, our results may not generalize to all quantum software. Future studies are welcome to replicate and validate
our work in other quantum projects.

1https://github.com/openjamoses/JSS-Replication

30

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

31

8. Conclusion

As for traditional software, the maintenance of quantum software systems is equally important because the main-
tenance practices can aﬀect the quality of a whole quantum computing system. In this study, we selected 118 open-
source quantum computing related projects from GitHub. We empirically studied the distribution and evolution of
technical debts in these projects and the relationship between technical debts and fault occurrences. We observed that
a few types of technical debts (related to code convention violation, error-handling, and code complexity) dominate
the total number of technical debts detected from our studied projects. There is a strong correlation between technical
debts and post-release faults. Particularly, ﬁles with high code complexity are more likely to lead to faults. We also
found that code changes related to conﬁguration ﬁles and dependency management tend to be highly fault-prone,
which need more attention when developers perform code review and testing. Based on the ﬁndings reported in this
paper, we formulate the following recommendations:

• For the technical debt detection, we recommend that quantum software developers use the existing static anal-

ysis tools to examine their code.

• We also recommend that practitioners prioritize resource allocation to refactor their source code, especially
the code with critical technical debts. Also, quantum developers should follow the coding convention to avoid
confusion, especially to support team collaboration.

• Quantum developers should pay attention to the code quality and code size, especially when new ﬁles are added.

They should review and test carefully the commits with a large number of changes.

• Code reviewers and quantum quality assurance team should use metrics like code convention, code redundancy,

error-handling, and the cognitive complexity of the code to predict faulty commits.

• New tools should be introduced to support identifying quantum-speciﬁc problems, such as the technical debts

and faults that only occur in a quantum software system.

• Future works are appealed to study other aspects of quantum software in terms of maintenance and reliability,
such as code review, veriﬁcation methods to ensure the correctness of a quantum program, and practical fault
detection techniques for supporting quantum systematic testing and debugging.

Acknowledgement

We thank the Natural Sciences and Engineering Research Council of Canada (NSERC) for funding this project.

References

[1] L. Spector, H. Barnum, H. J. Bernstein, N. Swamy, Quantum computing applications of genetic programming, Advances in genetic pro-

gramming 3 (1999) 135–160.

[2] P. Kaye, R. Laﬂamme, M. Mosca, et al., An introduction to quantum computing, Oxford university press, 2007.
[3] E. VanDoren, Maintenance of operational systems–an overview, Software technology Roadmap. Carnegie Mellon Software Engineering

Institute.

[4] I. S. C. Committee, et al., Ieee standard glossary of software engineering terminology (ieee std 610.12-1990). los alamitos, CA: IEEE

Computer Society 169.

[5] T. Krüger, W. Mauerer, Quantum annealing-based software components: An experimental case study with sat solving, arXiv preprint

arXiv:2005.05465.

[6] R. Pérez-Castillo, Reengineering of information systems toward classical-quantum systems., in: QANSWER, 2020, pp. 64–70.
[7] T. M. Pigoski, Practical software maintenance: best practices for managing your software investment, Wiley Publishing, 1996.
[8] A. J. Ko, B. A. Myers, M. J. Coblenz, H. H. Aung, An exploratory study of how developers seek, relate, and collect relevant information

during software maintenance tasks, IEEE Trans. Softw. Eng. 32 (12) (2006) 971–987. doi:10.1109/TSE.2006.116.
URL https://doi.org/10.1109/TSE.2006.116

[9] T. Gyimothy, R. Ferenc, I. Siket, Empirical validation of object-oriented metrics on open source software for fault prediction, IEEE Trans-

actions on Software Engineering 31 (10) (2005) 897–910.

[10] C. J. Xiong, Y. F. Li, M. Xie, S. H. Ng, T. N. Goh, A model of open source software maintenance activities, in: 2009 IEEE International

Conference on Industrial Engineering and Engineering Management, 2009, pp. 267–271.

31

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

32

[11] E. Raymond, The cathedral and the bazaar, Knowledge, Technology & Policy 12 (3) (1999) 23–49.
[12] V. Lenarduzzi, T. Orava, N. Saarimäki, K. Systa, D. Taibi, An empirical study on technical debt in a ﬁnnish sme, in: 2019 fACM/IEEE

International Symposium on Empirical Software Engineering and Measurement (ESEM), 2019, pp. 1–6.

[13] Z. Li, P. Avgeriou, P. Liang, A systematic mapping study on technical debt and its management, J. Syst. Softw. 101 (C) (2015) 193–220.

doi:10.1016/j.jss.2014.12.027.
URL https://doi.org/10.1016/j.jss.2014.12.027

[14] M. Cataldo, J. D. Herbsleb, K. M. Carley, Socio-technical congruence: a framework for assessing the impact of technical and work depen-
dencies on software development productivity, in: Proceedings of the Second ACM-IEEE international symposium on Empirical software
engineering and measurement, 2008, pp. 2–11.

[15] T. Saika, E. Choi, N. Yoshida, S. Haruna, K. Inoue, Do developers focus on severe code smells?, in: 2016 IEEE 23rd International Conference

on Software Analysis, Evolution, and Reengineering (SANER), Vol. 4, IEEE, 2016, pp. 1–3.

[16] R. D. Banker, G. B. Davis, S. A. Slaughter, Software development practices, software complexity, and software maintenance performance:

A ﬁeld study, Management science 44 (4) (1998) 433–450.

[17] A. Mateen, M. A. Akbar, Estimating software reliability in maintenance phase through ann and statistics, arXiv preprint arXiv:1605.00774.
[18] F. Martin, Technical debt (2019).

URL https://martinfowler.com/bliki/TechnicalDebt.html

[19] A. Martini, J. Bosch, M. Chaudron, Investigating architectural technical debt accumulation and refactoring over time, Inf. Softw. Technol.

67 (C) (2015) 237–253. doi:10.1016/j.infsof.2015.07.005.
URL https://doi.org/10.1016/j.infsof.2015.07.005

[20] D. Reimanis, C. Izurieta, Towards assessing the technical debt of undesired software behaviors in design patterns, in: 2016 IEEE 8th

International Workshop on Managing Technical Debt (MTD), 2016, pp. 24–27.

[21] P. Kruchten, R. L. Nord, I. Ozkaya, Technical debt: From metaphor to theory and practice, Ieee software 29 (6) (2012) 18–21.
[22] S. E. S. Taba, F. Khomh, Y. Zou, A. E. Hassan, M. Nagappan, Predicting bugs using antipatterns, in: 2013 IEEE International Conference

on Software Maintenance, IEEE, 2013, pp. 270–279.

[23] G. M. Ubayawardana, D. D. Karunaratna, Bug prediction model using code smells, in: 2018 18th International Conference on Advances in

ICT for Emerging Regions (ICTer), IEEE, 2018, pp. 70–77.

[24] A. S. Cairo, G. d. F. Carneiro, M. P. Monteiro, The impact of code smells on software bugs: A systematic literature review, Information

9 (11) (2018) 273.

[25] R. C. Seacord, D. Plakosh, G. A. Lewis, Modernizing legacy systems: software technologies, engineering processes, and business practices,

Addison-Wesley Professional, 2003.

[26] W. Cunningham, The wycash portfolio management system, in: Addendum to the Proceedings on Object-Oriented Programming Systems,
Languages, and Applications (Addendum), OOPSLA ’92, Association for Computing Machinery, New York, NY, USA, 1992, p. 29–30.
doi:10.1145/157709.157715.
URL https://doi.org/10.1145/157709.157715
[27] F. Martin, Is high quality software worth the cost? (2019).

URL https://martinfowler.com/articles/is-quality-worth-cost.html

[28] M. Smit, B. Gergel, H. J. Hoover, E. Stroulia, Maintainability and source code conventions: An analysis of open source projects, University

of Alberta, Department of Computing Science, Tech. Rep. TR11 6.

[29] Sonarqube, Sonarqube, doc 8.6 issues.

URL https://docs.sonarqube.org/latest/user-guide/issues/

[30] A. Molnar, S. Motogna, Discovering maintainability changes in large software systems, in: Proceedings of the 27th International Workshop
on Software Measurement and 12th International Conference on Software Process and Product Measurement, IWSM Mensura ’17, Associ-
ation for Computing Machinery, New York, NY, USA, 2017, p. 88–93. doi:10.1145/3143434.3143447.
URL https://doi.org/10.1145/3143434.3143447

[31] A.-J. Molnar, A. Neam¸tu, S. Motogna, Longitudinal evaluation of software quality metrics in open-source applications, in: Proceedings of
the 14th International Conference on Evaluation of Novel Approaches to Software Engineering, ENASE 2019, SCITEPRESS - Science and
Technology Publications, Lda, Setubal, PRT, 2019, p. 80–91. doi:10.5220/0007725600800091.
URL https://doi.org/10.5220/0007725600800091

[32] Sonarqube documentation rules (2021).

URL https://docs.sonarqube.org/latest/user-guide/rules/

[33] R. Orús, A practical introduction to tensor networks: Matrix product states and projected entangled pair states, Annals of Physics 349 (2014)

117 – 158. doi:https://doi.org/10.1016/j.aop.2014.06.013.
URL http://www.sciencedirect.com/science/article/pii/S0003491614001596

[34] A. K. Ekert, Quantum cryptography based on bell’s theorem, Physical review letters 67 (6) (1991) 661.
[35] M. A. Nielsen, I. Chuang, Quantum computation and quantum information (2002).
[36] P. W. Shor, Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer, SIAM review 41 (2) (1999)

303–332.

[37] J. Zhao, Quantum software engineering: Landscapes and horizons, arXiv preprint arXiv:2007.07047.
[38] N. Kieﬂ, G. Hagel, Software engineering education of classical computing vs. quantum computing: A competency-centric approach, in:
Proceedings of the 4th European Conference on Software Engineering Education, ECSEE ’20, Association for Computing Machinery, New
York, NY, USA, 2020, p. 27–31. doi:10.1145/3396802.3396816.
URL https://doi.org/10.1145/3396802.3396816

[39] C. A. Pérez-Delgado, H. G. Perez-Gonzalez, Towards a quantum software modeling language, ICSEW’20, Association for Computing

Machinery, New York, NY, USA, 2020, p. 442–444. doi:10.1145/3387940.3392183.
URL https://doi.org/10.1145/3387940.3392183

32

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

33

[40] J. Thompson, K. Modi, V. Vedral, M. Gu, Quantum plug n’play: modular computation in the quantum regime, New Journal of Physics

20 (1) (2018) 013004.

[41] M. Piattini, G. Peterssen, R. Pérez-Castillo, J. L. Hevia, M. A. Serrano, G. Hernández, I. G. R. de Guzmán, C. A. Paradela, M. Polo,

E. Murina, et al., The talavera manifesto for quantum software engineering and programming., in: QANSWER, 2020, pp. 1–5.

[42] M. Ying, Foundations of Quantum Programming, Morgan Kaufmann, 2016.
[43] J. A. Miszczak, High-level structures for quantum computing, Synthesis Lectures on Quantum Computing 4 (1) (2012) 1–129.
[44] S. A. Cook, D. G. Mitchell, Finding hard instances of the satisﬁability problem: A survey, Satisﬁability Problem: Theory and Applications

35 (1997) 1–17.

[45] D. Deutsch, Quantum theory, the church–turing principle and the universal quantum computer, Proceedings of the Royal Society of London.

A. Mathematical and Physical Sciences 400 (1818) (1985) 97–117.

[46] E. Knill, M. Nielsen, Encyclopedia of mathematics, supplement iii, chapter theory of quantum computation (2000).
[47] E. Knill, Conventions for quantum pseudocode, Tech. rep., Los Alamos National Lab., NM (United States) (1996).
[48] A. S. Green, P. L. Lumsdaine, N. J. Ross, P. Selinger, B. Valiron, Quipper: a scalable quantum programming language, in: Proceedings of

the 34th ACM SIGPLAN conference on Programming language design and implementation, 2013, pp. 333–342.

[49] K. Svore, A. Geller, M. Troyer, J. Azariah, C. Granade, B. Heim, V. Kliuchnikov, M. Mykhailova, A. Paz, M. Roetteler, Q# enabling scalable
quantum computing and development with a high-level dsl, in: Proceedings of the Real World Domain Speciﬁc Languages Workshop 2018,
2018, pp. 1–10.

[50] A. JavadiAbhari, S. Patil, D. Kudrow, J. Heckey, A. Lvov, F. T. Chong, M. Martonosi, Scaﬀcc: Scalable compilation and analysis of quantum

programs, Parallel Computing 45 (2015) 2–17.

[51] A. J. Abhari, A. Faruque, M. J. Dousti, L. Svec, O. Catu, A. Chakrabati, C.-F. Chiang, S. Vanderwilt, J. Black, F. Chong, Scaﬀold: Quantum

programming language, Tech. rep., Princeton Univ NJ Dept of Computer Science (2012).

[52] M. Piattini, G. Peterssen, R. Pérez-Castillo, Quantum computing: A new software engineering golden age, ACM SIGSOFT Software

Engineering Notes 45 (3) (2020) 12–14.

[53] S. Garhwal, M. Ghorani, A. Ahmad, Quantum programming language: A systematic review of research topic and top cited languages,

Archives of Computational Methods in Engineering (2019) 1–22.

[54] E. Moguel, J. Berrocal, J. García-Alonso, J. M. Murillo, A roadmap for quantum software engineering: applying the lessons learned from

the classics.

[55] M. Fingerhuth, T. Babej, P. Wittek, Open source software in quantum computing, PloS one 13 (12) (2018) e0208561.
[56] R. Shaydulin, C. Thomas, P. Rodeghero, Making quantum computing open: Lessons from open source projects, in: Proceedings of the

IEEE/ACM 42nd International Conference on Software Engineering Workshops, 2020, pp. 451–455.

[57] W. Cunningham, The wycash portfolio management system, ACM SIGPLAN OOPS Messenger 4 (2) (1992) 29–30.
[58] P. Avgeriou, P. Kruchten, I. Ozkaya, C. Seaman, Managing technical debt in software engineering (dagstuhl seminar 16162), in: Dagstuhl

Reports, Vol. 6, Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2016.

[59] A. Martini, J. Bosch, M. Chaudron, Investigating architectural technical debt accumulation and refactoring over time: A multiple-case study,

Information and Software Technology 67 (2015) 237–253.

[60] T. Besker, A. Martini, J. Bosch, Technical debt triage in backlog management, in: 2019 IEEE/ACM International Conference on Technical

Debt (TechDebt), IEEE, 2019, pp. 13–22.

[61] T. Besker, A. Martini, J. Bosch, Technical debt cripples software developer productivity: a longitudinal study on developers’ daily software

development work, in: Proceedings of the 2018 International Conference on Technical Debt, 2018, pp. 105–114.

[62] P. C. Avgeriou, D. Taibi, A. Ampatzoglou, F. A. Fontana, T. Besker, A. Chatzigeorgiou, V. Lenarduzzi, A. Martini, N. Moschou, I. Pigazzini,

et al., An overview and comparison of technical debt measurement tools, IEEE Software.

[63] Techopedia, Technical debt.

URL http://www-cs-faculty.stanford.edu/~uno/abcde.html

[64] D. Samadhiya, Su-Hua Wang, Dengjie Chen, Quality models: Role and value in software engineering, in: 2010 2nd International Conference

on Software Technology and Engineering, Vol. 1, 2010, pp. V1–320–V1–324. doi:10.1109/ICSTE.2010.5608852.

[65] J.-L. Letouzey, The sqale method for evaluating technical debt, in: Proceedings of the Third International Workshop on Managing Technical

Debt, MTD ’12, IEEE Press, 2012, p. 31–36.

[66] N. V. Ivankova, J. W. Creswell, S. L. Stick, Using mixed-methods sequential explanatory design: From theory to practice, Field methods

18 (1) (2006) 3–20.

[67] W. H. Brown, R. C. Malveau, H. W. McCormick, T. J. Mowbray, AntiPatterns: refactoring software, architectures, and projects in crisis,

John Wiley & Sons, Inc., 1998.

[68] M. Fowler, K. Beck, Refactoring: improving the design of existing code, Addison-Wesley Professional, 1999.
[69] Github issues.

URL https://docs.github.com/en/free-pro-team@latest/github/managing-your-work-on-github/about-issues

[70] Github rest api (2021).

URL https://developer.github.com/v3/

[71] N. Munaiah, S. Kroh, C. Cabrey, M. Nagappan, Curating github for engineered software projects, Empirical Software Engineering 22 (6)

(2017) 3219–3253.

[72] J. Businge, M. Openja, S. Nadi, E. Bainomugisha, T. Berger, Clone-based variability management in the android ecosystem, in: 2018 IEEE
International Conference on Software Maintenance and Evolution (ICSME), 2018, pp. 625–634. doi:10.1109/ICSME.2018.00072.
[73] J. Businge, M. Openja, D. Kavaler, E. Bainomugisha, F. Khomh, V. Filkov, Studying android app popularity by cross-linking github and
google play store, in: 2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER), 2019, pp.
287–297. doi:10.1109/SANER.2019.8667998.

[74] Quantum open source foundation (qosf) (2021).

URL https://qosf.org

33

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

34

[75] A. Montanaro, Quantum algorithms: an overview, npj Quantum Information 2 (1) (2016) 1–8.
[76] A. B. Finnila, M. Gomez, C. Sebenik, C. Stenson, J. D. Doll, Quantum annealing: a new method for minimizing multidimensional functions,

Chemical physics letters 219 (5-6) (1994) 343–348.

[77] A. W. Cross, L. S. Bishop, J. A. Smolin, J. M. Gambetta, Open quantum assembly language (2017). arXiv:1707.03429.
[78] A. Bloch, Murphy’s law, Penguin, 2003.
[79] Sonaqube oﬃcial website (2021).

URL https://www.sonarqube.org/

[80] J. Tan, D. Feitosa, P. Avgeriou, M. Lungu, Evolution of technical debt remediation in python: A case study on the apache software ecosystem,

Journal of Software: Evolution and Process (2020) e2319.

[81] D. Marcilio, R. Bonifácio, E. Monteiro, E. Canedo, W. Luz, G. Pinto, Are static analysis violations really ﬁxed? a closer look at realistic
usage of sonarqube, in: 2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC), IEEE, 2019, pp. 209–219.
[82] N. Saarimäki, V. Lenarduzzi, D. Taibi, On the diﬀuseness of code technical debt in java projects of the apache ecosystem, in: Proceedings

of the Second International Conference on Technical Debt, IEEE Press, 2019, pp. 98–107.

[83] G. Digkas, M. Lungu, A. Chatzigeorgiou, P. Avgeriou, The evolution of technical debt in the apache ecosystem, in: European Conference

on Software Architecture, Springer, 2017, pp. 51–66.

[84] G. Digkas, M. Lungu, P. Avgeriou, A. Chatzigeorgiou, A. Ampatzoglou, How do developers ﬁx issues and pay back technical debt in the
apache ecosystem?, in: 2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER), IEEE,
2018, pp. 153–163.

[85] J.-L. Letouzey, T. Coq, The sqale analysis model: An analysis model compliant with the representation condition for assessing the quality
of software source code, in: 2010 Second International Conference on Advances in System Testing and Validation Lifecycle, IEEE, 2010,
pp. 43–48.

[86] M. R. Dale, C. Izurieta, Impacts of design pattern decay on system quality, in: Proceedings of the 8th ACM/IEEE International Symposium

on Empirical Software Engineering and Measurement, 2014, pp. 1–4.

[87] J.-L. Letouzey, M. Ilkiewicz, Managing technical debt with the sqale method, IEEE software 29 (6) (2012) 44–51.
[88] J. H. Zar, Spearman rank correlation, Encyclopedia of Biostatistics 7.
[89] M. Wen, R. Wu, Y. Liu, Y. Tian, X. Xie, S.-C. Cheung, Z. Su, Exploring and exploiting the correlations between bug-inducing and bug-ﬁxing
commits, ESEC/FSE 2019, Association for Computing Machinery, New York, NY, USA, 2019, p. 326–337. doi:10.1145/3338906.
3338962.
URL https://doi.org/10.1145/3338906.3338962

[90] Mockus, Votta, Identifying reasons for software changes using historic databases, in: Proceedings 2000 International Conference on Soft-

ware Maintenance, 2000, pp. 120–130. doi:10.1109/ICSM.2000.883028.

[91] H. Zhong, Z. Su, An empirical study on real bug ﬁxes, in: Proceedings of the 37th International Conference on Software Engineering -

Volume 1, ICSE ’15, IEEE Press, 2015, p. 913–923.

[92] S. Kim, T. Zimmermann, E. J. Whitehead Jr., A. Zeller, Predicting faults from cached history, in: 29th International Conference on Software

Engineering (ICSE’07), 2007, pp. 489–498. doi:10.1109/ICSE.2007.66.

[93] M. Abidi, M. S. Rahman, M. Openja, F. Khomh, Are multi-language design smells prevalent?

an empirical study, arXiv preprint

arXiv:2010.14331.

[94] D. ˇCubrani´c, G. C. Murphy, Hipikat: Recommending pertinent software development artifacts, in: Proceedings of the 25th International

Conference on Software Engineering, ICSE ’03, IEEE Computer Society, USA, 2003, p. 408–418.

[95] M. Fischer, M. Pinzger, H. Gall, Populating a release history database from version control and bug tracking systems, in: International

Conference on Software Maintenance, 2003. ICSM 2003. Proceedings., 2003, pp. 23–32. doi:10.1109/ICSM.2003.1235403.
[96] J. ´Sliwerski, T. Zimmermann, A. Zeller, When do changes induce ﬁxes?, ACM sigsoft software engineering notes 30 (4) (2005) 1–5.
[97] S. Kim, T. Zimmermann, K. Pan, E. James Jr, et al., Automatic identiﬁcation of bug-introducing changes, in: 21st IEEE/ACM international

conference on automated software engineering (ASE’06), IEEE, 2006, pp. 81–90.

[98] M. L. Bernardi, G. Canfora, G. A. Di Lucca, M. Di Penta, D. Distante, Do developers introduce bugs when they do not communicate?
the case of eclipse and mozilla, in: 2012 16th European Conference on Software Maintenance and Reengineering, 2012, pp. 139–148.
doi:10.1109/CSMR.2012.24.

[99] M. Asaduzzaman, M. C. Bullock, C. K. Roy, K. A. Schneider, Bug introducing changes: A case study with android, in: 2012 9th IEEE

Working Conference on Mining Software Repositories (MSR), 2012, pp. 116–119. doi:10.1109/MSR.2012.6224267.

[100] G. Bavota, B. De Carluccio, A. De Lucia, M. Di Penta, R. Oliveto, O. Strollo, When does a refactoring induce bugs? an empirical study,
in: Proceedings of the 2012 IEEE 12th International Working Conference on Source Code Analysis and Manipulation, SCAM ’12, IEEE
Computer Society, USA, 2012, p. 104–113. doi:10.1109/SCAM.2012.20.
URL https://doi.org/10.1109/SCAM.2012.20

[101] G. Canfora, M. Ceccarelli, L. Cerulo, M. Di Penta, How long does a bug survive? an empirical study, in: 2011 18th Working Conference on

Reverse Engineering, 2011, pp. 191–200. doi:10.1109/WCRE.2011.31.

[102] J. Ell, Identifying failure inducing developer pairs within developer networks, in: 2013 35th International Conference on Software Engi-

neering (ICSE), 2013, pp. 1471–1473. doi:10.1109/ICSE.2013.6606748.

[103] J. Eyolfson, L. Tan, P. Lam, Do time of day and developer experience aﬀect commit bugginess?, in: Proceedings of the 8th Working
Conference on Mining Software Repositories, MSR ’11, Association for Computing Machinery, New York, NY, USA, 2011, p. 153–162.
doi:10.1145/1985441.1985464.
URL https://doi.org/10.1145/1985441.1985464

[104] Y. Kamei, E. Shihab, B. Adams, A. E. Hassan, A. Mockus, A. Sinha, N. Ubayashi, A large-scale empirical study of just-in-time quality

assurance, IEEE Trans. Softw. Eng. 39 (6) (2013) 757–773. doi:10.1109/TSE.2012.70.
URL https://doi.org/10.1109/TSE.2012.70

[105] S. Kim, E. J. Whitehead, How long did it take to ﬁx bugs?, in: Proceedings of the 2006 International Workshop on Mining Software Repos-

34

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

35

itories, MSR ’06, Association for Computing Machinery, New York, NY, USA, 2006, p. 173–174. doi:10.1145/1137983.1138027.
URL https://doi.org/10.1145/1137983.1138027

[106] S. Kim, E. J. Whitehead,, Y. Zhang, Classifying software changes: Clean or buggy?, IEEE Transactions on Software Engineering 34 (2)

(2008) 181–196. doi:10.1109/TSE.2007.70773.

[107] F. Rahman, P. Devanbu, Ownership, experience and defects: a ﬁne-grained study of authorship, in: 2011 33rd International Conference on

Software Engineering (ICSE), 2011, pp. 491–500. doi:10.1145/1985793.1985860.

[108] J. undeﬁnedliwerski, T. Zimmermann, A. Zeller, Hatari: Raising risk awareness, in: Proceedings of the 10th European Software Engineering
Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering, ESEC/FSE-13,
Association for Computing Machinery, New York, NY, USA, 2005, p. 107–110. doi:10.1145/1081706.1081725.
URL https://doi.org/10.1145/1081706.1081725

[109] M. Tufano, G. Bavota, D. Poshyvanyk, M. Di Penta, R. Oliveto, A. De Lucia, An empirical study on developer-related factors characterizing

ﬁx-inducing commits, Journal of Software: Evolution and Process 29 (1) (2017) e1797.

[110] M. Wen, R. Wu, S. Cheung, Locus: Locating bugs from software changes, in: 2016 31st IEEE/ACM International Conference on Automated

Software Engineering (ASE), 2016, pp. 262–273.

[111] R. Wu, M. Wen, S.-C. Cheung, H. Zhang, Changelocator: Locate crash-inducing changes based on crash reports, Empirical Softw. Engg.

23 (5) (2018) 2866–2900.
URL https://doi.org/10.1007/s10664-017-9567-4

[112] Z. Yin, D. Yuan, Y. Zhou, S. Pasupathy, L. Bairavasundaram, How do ﬁxes become bugs?, in: Proceedings of the 19th ACM SIGSOFT

symposium and the 13th European conference on Foundations of software engineering, 2011, pp. 26–36.

[113] D. Spadini, M. Aniche, A. Bacchelli, Pydriller: Python framework for mining software repositories, in: Proceedings of the 2018 26th ACM
Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, ESEC/FSE
2018, Association for Computing Machinery, New York, NY, USA, 2018, p. 908–911. doi:10.1145/3236024.3264598.
URL https://doi.org/10.1145/3236024.3264598

[114] C. Rosen, B. Grawi, E. Shihab, Commit guru: Analytics and risk prediction of software commits, in: Proceedings of the 2015 10th Joint
Meeting on Foundations of Software Engineering, ESEC/FSE 2015, Association for Computing Machinery, New York, NY, USA, 2015, p.
966–969. doi:10.1145/2786805.2803183.
URL https://doi.org/10.1145/2786805.2803183

[115] M. Borg, O. Svensson, K. Berg, D. Hansson, Szz unleashed: An open implementation of the szz algorithm - featuring example usage in a
study of just-in-time bug prediction for the jenkins project, in: Proceedings of the 3rd ACM SIGSOFT International Workshop on Machine
Learning Techniques for Software Quality Evaluation, MaLTeSQuE 2019, Association for Computing Machinery, New York, NY, USA,
2019, p. 7–12. doi:10.1145/3340482.3342742.
URL https://doi.org/10.1145/3340482.3342742

[116] E. Shihab, Z. M. Jiang, W. M. Ibrahim, B. Adams, A. E. Hassan, Understanding the impact of code and process metrics on post-release
defects: a case study on the eclipse project, in: Proceedings of the 2010 ACM-IEEE International Symposium on Empirical Software
Engineering and Measurement, 2010, pp. 1–10.

[117] J. Fox, S. Weisberg, Multivariate linear models in r, An R Companion to Applied Regression. Los Angeles: Thousand Oaks.
[118] T. Hastie, R. Tibshirani, J. Friedman, The elements of statistical learning: data mining, inference, and prediction, Springer Science &

Business Media, 2009.

[119] Wikipedia, F-test.

URL https://en.wikipedia.org/wiki/F-test

[120] A.-J. Molnar, S. Motogna, Long-term evaluation of technical debt in open-source software, in: Proceedings of the 14th ACM/IEEE Interna-

tional Symposium on Empirical Software Engineering and Measurement (ESEM), 2020, pp. 1–9.

[121] G. A. Campbell, Cognitive complexity-a new way of measuring understandability, SonarSource SA.
[122] Sonarqube built-in rule tags (2021).

URL https://docs.sonarqube.org/latest/user-guide/built-in-rule-tags/

[123] Common weakness enumeration(cwe):a community-developed list of software and hardware weakness types (2021).

URL http://cwe.mitre.org/

[124] D. Tsoukalas, D. Kehagias, M. Siavvas, A. Chatzigeorgiou, Technical debt forecasting: An empirical study on open-source repositories,

Journal of Systems and Software 170 (2020) 110777.

[125] M. Siavvas, D. Tsoukalas, M. Jankovic, D. Kehagias, D. Tzovaras, Technical debt as an indicator of software security risk: a machine

learning approach for software development enterprises, Enterprise Information Systems (2020) 1–43.

[126] R. Dunford, Q. Su, E. Tamang, The pareto principle.
[127] N. Walkinshaw, L. Minku, Are 20% of ﬁles responsible for 80% of defects?, in: Proceedings of the 12th ACM/IEEE International Sympo-

sium on Empirical Software Engineering and Measurement, 2018, pp. 1–10.

[128] P. Runeson, M. Höst, Guidelines for conducting and reporting case study research in software engineering, Empirical Softw. Engg. 14 (2)

(2009) 131–164. doi:10.1007/s10664-008-9102-8.
URL https://doi.org/10.1007/s10664-008-9102-8

[129] B. A. Muse, M. M. Rahman, C. Nagy, A. Cleve, F. Khomh, G. Antoniol, On the prevalence, impact, and evolution of sql code smells in
data-intensive systems, in: Proceedings of the 17th International Conference on Mining Software Repositories, 2020, pp. 327–338.

Appendix A Sample quantum projects in each categorie

The GitHub repositories are shown as: <owner_name>/<repository_name>

35

Moses Openja, Mohammad Mehdi Morovati, Le An, Foutse Khomh, Mouna Abidi / The Journal of Systems and Software 00 (2022) 1–??

36

Category

1

Full-stack Library or Frame-
work (Fstack)

2

Experimentation (Exp)

3

Simulator (Sim)

4
5

Cryptography (Crypt)
Compiler (Comp)

6

ToolKit (Tkit)

7

Algorithms (Algo)

8

Annealing (Ann)

9

Chemistry (Chem)

10 Assembly (Ass)

QuantumBFS/Yao.jl,

qojulia/QuantumOptics.jl,

qiskit-community/qiskit-js,

ProjectQ-Framework/ProjectQ,

The studied repositories (separated by comma)
Qiskit/qiskit-terra, microsoft/Quantum, microsoft/QuantumLibraries,
microsoft/Quantum-NC, rigetti/pyquil, Qiskit/qiskit, Qiskit/qiskit-ibmq-
qiskit-community/qiskit-vscode,
provider,
rigetti/rpcq,
QuantumPackage/qp2,
XanaduAI/strawberryﬁelds, Blueqat/Blueqat, quantumlib/Cirq, software-
Qinc/staq
m-labs/artiq, sedabull/quantum-shell, qutech/qupulse, iitis/QuantumInfor-
mation.jl, lneuhaus/pyrpl, BBN-Q/Qlab, BBN-Q/PyQLab
issp-center-dev/HPhi,
softwareQinc/qpp, QuantumBFS/YaoBlocks.jl,
SoftwareQuTech/SimulaQron,
Strilanc/Quirk,
Qiskit/qiskit-aer, qutip/qutip, QuEST-Kit/QuEST, vm6502q/qrack, qulac-
s/qulacs, quantumlib/OpenFermion-Cirq, microsoft/qmt, Approximates/-
dotBloch, Qiskit/qiskit-jku-provider, ngnrsaa/qﬂex, aparent/QCViewer,
rigetti/qvm, marvel-nccr/quantum-mobile
theQRL/QRL, exaexa/codecrypt, BBN-Q/QGL, mupq/pqm4
microsoft/qsharp-compiler, QE-Lab/OpenQL, Quantomatic/pyzx
evaleev/libint,
jcmgray/quimb, Xanadu-
AI/pennylane, OriginQ/QPanda-2, CQCL/pytket, bloomberg/quantum,
rigetti/forest-benchmarking, QInfer/python-qinfer, zoran-cuckovic/QGIS-
redhat-
visibility-analysis,
cip/openstack-quantum-puppet,
TRIQS/triqs,
boschmitt/tweedledum,
QuTech-Delft/qtt,
lmacken/quantumrandom, qucat/qucat, Qiskit/qiskit-
ignis, orbkit/orbkit,deepchem/deepchem, aiidateam/aiida-quantumespresso
qreﬁne/qreﬁne, mabuchilab/QNET, Qiskit/qiskit-aqua, quantumlib/Open-
Fermion, rigetti/grove, netket/netket, XanaduAI/thewalrus, qucontrol/kro-
aeantipov/pomerol, Q-solvers/EDLib, dwave-examples/factoring,
tov,
PanPalitta/phase_estimation, ProjectQ-Framework/FermiLib,
JoshuaS-
Brown/QC_Tools
shinmorino/sqaod,
dwavesystems/dimod,
dwavesystems/dwave-system, dwavesystems/dwavebinarycsp, dwavesys-
tems/penaltymodel
ValeevGroup/mpqc,
pyscf/pyscf, MolSSI-BSE/basis_set_exchange,
MolSSI/QCElemental, MolSSI/QCEngine, MolSSI/QCFractal, Seb-
Wouters/CheMPS2, Quantum-Dynamics-Hub/libra-code, QMCPACK/qm-
tmancal74/quantarhei,
cpack, cp2k/cp2k, votca/xtp, hande-qmc/hande,
LCPQ/quantum_package,
vonDonnerstein/QuantumLab.jl,
ericcha-
nsen/q2mm, aoterodelaroza/critic2, GQCG/GQCP, qcdb/qcdb
valeevGroup/mpqc, MolSSI/QCElemental, MolSSI/QCEngine, QMC-
PACK/qmcpack, SebWouters/CheMPS2

dwavesystems/qbsolv,

tensorﬂow/quantum,

qubekit/QUBEKit,

Total

16

8

20

4
3

22

14

6

19

5

36

