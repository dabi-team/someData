Towards the Future: Bring Program Correctness back to the focus

Chongyi Yuana, Lijie Wena, Xiongliang Yana

aSchool of Software, Tsinghua University, Beijing 100084, China

2
2
0
2

r
a

M
9
2

]
E
S
.
s
c
[

1
v
3
5
6
5
1
.
3
0
2
2
:
v
i
X
r
a

Abstract

Program correctness used to be the main concern of computer software in the early days when formal semantics was a hot topic.
But, the word “correct” was afterwards replaced by reliable, robust and trustworthy etc., a tradeoﬀ situation then. This is not
because correctness is no longer important, but because people found no way to get through in this direction. The tradeoﬀ has led
software engineers to focus on techniques and testing tools. Rapid development of software engineering has now reached a peak
and programmers are now working freely without worrying too much about bugs, since bugs are not avoidable anyway. While
software engineers are enjoying their work, computer applications are, in the name of artiﬁcial intelligence, big data and cloud
computing etc., creating big fortune.

Can we always ignore existence of errors like today? Or equally, is it meaningful to talk about program correctness today? Our
answer is yes. It is the time to seriously consider correctness again, before it is too late, to prepare for the future. Future generation
computer systems should be correct, both syntactically (statically) and semantically (dynamically).

The book “OESPA: Semantic Oriented Theory of Programming” (2019) by the ﬁrst author has opened a new direction for
semantic study. Theoretically speaking, it is possible now, based on OESPA, to compute program semantics from program text so
that program correctness could be proved.

But, semantic computations and correctness proving cannot be done by hand when the size of a program is big. Automatic tools
are necessary. This paper tries to lay a foundation for developing needed auto tools, so that OESPA is enriched to serve future need.
To this end, a new concept named conditional semantic predicate is proposed. Concepts in OESPA, including semantic functions,
semantic predicates, semantic formulas and semantic calculus, are re-represented in accordance. Such re-introduction is necessary
since the book is the only publication on semantic calculus so far. The new version of semantic calculus illustrates how semantics
auto-computation would be carried out. The second and third authors have played an important role in the course of this stage of
study.

A 3-step meta-method called ARM is the tour-guide in writing this paper. As readers may ﬁnd that the ﬁrst step of ARM, i.e.
abstraction of physical object (variables here), is the key step for OESPA. ARM aims at constructing formal models whenever a
formal model is needed. OE is a formal computation model for programming, SPA provides a formal way in deﬁning program
semantics (A), and doing semantics predicate (SP) calculus.

Keywords: operations on variables, semantic functions, semantic axioms based on syntax formulas, semantic predicate, semantic
calculus, semantics computation, conditional semantic predicate

1. Introduction

Our study is of 2-in-1 nature. By “2-in-1” we mean two
things: syntax and semantics in one model (i.e. OESPA), and
physical observation and logical analysis in one meta-method
(i.e. ARM). It is ARM that has made OESPA possible. ARM,
abbreviated from Abstraction, Representation, Method, was pro-
posed by the ﬁrst author at a CBPM (Chinese Business Process
Management, 2014) meeting, but not published at that time.
ARM aims at constructing a formal model for a given applica-
tion. It is applicable whenever a formal system model is needed.
Thus, it deserves a few words of introduction. The abstraction
step in ARM requires a purpose-guided observation on physi-
cal objects involved in the given problem. Such an observation-
based abstraction serves as the bases for constructing (repre-

Email address: wenlj@tsinghua.edu.cn (Lijie Wen)

Preprint submitted to Elsevier

sentation step) and analyzing (method step) the wanted formal
model.

Physical objects involved in programming are memory lo-
cations where data are stored and programs are executed. With
semantic computing as the purpose, careful observation on mem-
ory locations has resulted as a formal deﬁnition of program
variables (see Deﬁnition 1 and 2 below). As a formal model
for programming, OESPA is a nature consequence of variable
deﬁnition in which OE (Operation Expression) is for program-
ming and SPA (Semantic Predicate and semantic Axioms) is for
semantic deﬁnition and semantic analysis.

This paper aims at automatic computation of semantics: from
understanding semantics (OESPA) to semantics computation.
To this end, a new concept named conditional semantic pred-
icate is to be proposed next with which semantic axioms are
better written, and math concepts like semantic functions, se-
mantic predicates, semantic formulas and semantic calculus are

March 30, 2022

 
 
 
 
 
 
modiﬁed so that auto tools for semantic computation becomes
feasible.

OESPA becomes mature from na¨ıve in the course of the
ﬁrst author’s long-term teaching on formal semantics. ARM
is just a by-product. It was noticed that the lack of proper ab-
straction of variables has prevented conventional formal seman-
tics from proper treatment of program semantics. Next in Sec-
tion 2, a brief recall is given on the way how conventional for-
mal semantics (mainly denotational semantics [1] , operational
semantics [2] and Hoare logic [3, 4]) understand program vari-
ables and program semantics. Section 3 introduces what Hoare
logic has achieved, since Hoare logic is the main stream in this
area. Other logics [5, 6, 7, 8] are, almost all, followers of it.

The rest of this paper will talk about next topics:

• How to abstract memory locations (ﬁrst step of ARM) so
ambiguity would be removed from assignments, and how
to form a system based on the abstractions (second step
of ARM) so that semantics axioms of the system can be
deﬁned on top of its syntax formulas.

• How to invent new methods for the analysis of the newly

constructed system (last step of ARM).

In the discussion of above topics, we will talk about:

• How to give a formal deﬁnition of program semantics.

• How to compute semantics from program text.

• How to develop semantics of function calls.

• Semantic axioms on C pointers.

2. Program variables and program semantics in conven-

tional formal semantics

2.1. Concept of program variables is copied from mathematics

All branches of formal semantics, including denotational
semantics, operational semantics and Hoare logic, have inher-
ited the concept of variables from syntactic deﬁnition of pro-
gramming languages while programming languages have copied
the concept of variables from mathematics. The syntactic deﬁ-
nition of a variable given by programming languages is just an
identiﬁer with no semantic operator(s) and operation(s) deﬁned
on it. Such a variable can be read only for evaluating math
expressions that need no operator. Consequently, an assign-
ment is not a precise math operation with explicit operator and
operands, and as such, variables involved in an assignment are
ambiguous: the same identiﬁer may represent a value as well as
a memory location at the same time. Such ambiguity has made
formal treatment impossible.

Formal semantics aims at developing semantics from pro-
gram text without evaluating expressions. As such, seman-
tic read operations before and after an assignment (or a pro-
gram segment) are a must for investigations to see what changes
would be brought up by executing the assignment (or segment).
In fact, such changes are, as we will see below, nothing but

2

the semantics of the due assignment (segment). Of course,
such read operations do not return a value. Instead, it returns
a math expression with which the variable being read would
be assigned at run time. In a word, formal semantics, denota-
tional, operational or axiomatical, did not deﬁne the concept of
program variables for semantic need.

2.2. How to deﬁne program semantics, or what is it?

It is often the case that diﬀerent programs by diﬀerent pro-
grammers are designed to carry out the same duty while they
enjoy their own properties and their own ways to do it. The
completion of the duty and the respective execution processes,
which of them is the semantics? It depends on how you under-
stand the word semantics.

The set of execution sequences tells a computer what to do,
so this set is the semantics for a computer. But, for a human
client, the consequence of program execution is the semantics
of the program, since what a client wanted is just the result.
So, the semantics of x:=e for a computer is to assign the value
of e (evaluated at the initial state of x:=e) to variable x while
for a human client, its semantics is the equation x:=e at the ﬁ-
nal state. The problem is how to put it formally? Denotational
semantics says that it is a function to map a program state to
a program state, and this semantic function is its denotation.
Operational semantics tells that its semantics is an operation.
Denotation, and operation, they are talking about semantics for
a computer, not for human clients. Hoare logic says that it is all
the true assertions in the form {p}x:=e{q}. The concept of asser-
tions will be introduced next in Section 3. Here, it is clear that
neither denotational semantics and operational semantics, nor
Hoare logic, has a direct and clear description of the informally
stated semantics of x:=e. The diﬃculties they have encountered
include: ambiguous assignments do not subject to direct seman-
tic treatment, and a single variable name cannot denote both its
initial and ﬁnal values in the same formula. For example, in
case the above expression e is given by x+1, then the seman-
tics of x:=e for human client would become equation x:=x+1,
where the ﬁrst xis the ﬁnal value while the second x is the ini-
tial value. How could the same name represent two diﬀerent
values in the same equation?As such, conventional formal se-
mantics are, in a sense, “disabled” by the miss-deﬁned concept
of variables.

Apparently, conventional formal semantics did not realize
that program variables demand a deﬁnition for semantic need.
OESPA starts from such a variable deﬁnition, replaces ambigu-
ous assignment with precisely deﬁned write/read operations.
And as such, initial value and ﬁnal value of the same variable
can be represented, in the same formula, with the same name.

Hoare logic is the best studied branch of formal semantics.
It is introduced, in certain detail in Section 3, to make clear the
reason why it provides no essential help to software engineers.
From now on, the term “semantics” means always seman-

tics for human client.

3. Hoare logic and others

The most fundamental concept in Hoare logic is assertions(or
a triple) on an assignment (extendable to assertions on a pro-
gram) in the form {p}S{q} where S is an assignment, p and q
are predicates on the initial state and respectively ﬁnal state of
S. Assertion {p}S{q} is true if the truth of p at the initial state
of S leads to the truth of q at the ﬁnal state of S. Compared
with other semantics study branches, Hoare logic is much bet-
ter, since the concept of assertions is well deﬁned so that the
semantics of an assignment may be given, by using auxiliary
constants, like {x=a}x:=x+1{x=a+1} for all constant a. This is
much more explicit than “an operation”, “a denotation” etc. Put
aside the fact that assertions talk about program properties in-
stead of program semantics, the problem is, how to prove the
truth of {p}S{q}?

e, where qx

The ambiguity of assignments have been wrapped up by
assertions, but {p}S{q} is itself ambiguous: the same name in
p and q represent its initial value and ﬁnal value respectively.
As such, an assertion does not comply with direct formal treat-
ment. The development of Hoare logic was not on the track to
give variables a new deﬁnition. Instead, the concept of weakest
preconditions, represented as wp(x:=e, q), was invented for the
proof of {p}x:=e{q}. By deﬁnition, wp(x:=e, q)=qx
e is
obtained by substituting every appearance of x in q with expres-
e implies {p}x:=e{q}. The most fundamental
sion e. Now, p → qx
e}x:=e{q}, though written
axiom in Hoare logic is nothing but {qx
diﬀerently. Other axioms in Hoare logic are variations of this
one to cover control mechanisms, including sequences, choices
and loops. What has prevented Hoare logic from practical use,
we believe, is the fact that it is hard to extend the above formal
treatment on a single assignment to a real program. In order to
prove just one property at the ﬁnal state, the weakest precondi-
tion must be computed one statement by one statement starting
from the last one forward. The number of statements in a real
program must be great, the computing process is bound to be
complicated and time-consuming. More importantly, no paral-
lelism possible for the series computing of weakest precondi-
tions. Besides, no one knows how many properties need to be
proved in order to prove the correctness of a program. All these
factors have made infeasible the automatic proving of program
correctness by Hoare logic. There existed trade-oﬀs between
pure formalism and practical use: B-method and model check-
ing are among the best. These methods had in deed attracted
attentions from practitioners, but not for long.

Theoretical speaking, Hoare logic is well studied and beau-
tiful to win Turing prize while practically speaking, it is not so
sound. It doesn’t change the fact that testing is a must step in
software lifecycle.

Next section is devoted to deﬁne the write/read operations.

This is the ﬁrst step of ARM.

To leave a deep impression on readers before starting Sec-
tion 4, let’s have a comparison among operational semantics,
Hoare logic and OESPA, with a small program S , to see how
each of which deals with the semantics of S .

Example 1. A comparison by example.

3

Program S : x := x + y; y := x − y; x := x − y.
How to study semantics of S , i.e., sem(S )?
For Operational semantics: sem(S ) = {(cid:104)x := x + y, y := x −
y, x := x − y(cid:105)}, a set consisting of one sequence only. There are
three categories of properties: stable properties, safety prop-
erties and progress properties. The program S given above
is too small to enjoy properties in all three categories. The
only meaningful property of S is a progress property, namely
x = a ∧ y = b (cid:55)−→ (leads-to) x = b ∧ y = a, which says that
sooner or later x = b∧y = a will be true if initially x = a∧y = b.
This property is proved by symbolic execution (or analysis) of
S with x = a ∧ y = b as its initial state. Termination is also a
progress property of S.

For Hoare logic, to prove the same property given above,

we have:

{q ≡ x = b ∧ y = a}.

{wp3} x := x + y; {wp2} y := x − y; {wp1} x := x − y

By deﬁnition of weakest precondition (i.e. wp):
wp1 = wp(x := x − y, x = b ∧ y = a) ≡ x = a + b ∧ y = a,
wp2 = wp(y := x − y, x = a + b ∧ y = a) ≡ x = a + b ∧ y = b,
wp3 = wp(x := x + y, x = a + b ∧ y = b) ≡ x = a ∧ y = b,
so, p ≡ x = a ∧ y = b, i.e., {x = a ∧ y = b}S {x = b ∧ y = a}.
Auxiliary constants a, b are necessary to distinguish ﬁnal

value from initial value of the same variable.

OESPA:
With a precise deﬁnition of variables (names of memory lo-
cations), the concept of semantic functions is obtained. For
variables x and y, semantic functions x and y represent, respec-
tively, the ﬁnal values of x and y while x and y themselves are
their respective initial values for the program in question. So,
the semantics of above program S is given by x = y ∧ y = x for
OESPA (see Figure 1 in Section 6 to ﬁnd out how to compute it
from program text).

Readers may ﬁnd, in what follows, the following facts about

OESPA:

• No auxiliary constants like a and b above, are necessary.

• It computes, from program text, semantics rather than

properties.

• It allows parallel computing in reducing a semantic for-

mula.

• It contains a rich body of new math concepts including
semantic functions, etc. which are necessary for seman-
tic studies while they are missing in conventional mathe-
matics.

• Above characteristics ensure automatic semantics com-

putation from program texts.

• Key words like “if” and “∼” are removed from semantic
axioms with conditional semantic predicates, so that auto
tools can be developed.

4. Formal deﬁnition of program variables

A formal deﬁnition is a purposeful abstraction of something

in doing formalism. Here we aim at semantic analysis.

Deﬁnition 1 (Program variable). A variable is a two-facet ob-
ject. As a physical object (a memory location), it allows three
operations applied on it as given by Deﬁnition 2. As a math
object, it represents a value whenever it appears in a math ex-
pression.

The three operations on a variable include one write oper-
ation and two read operations. Operators chosen for them are
respectively the over bar “ ¯ ”, the under bar “ ” and the curved
under bar (tilde) “(cid:58)”. Such operators would have a complete
cover-up on top (or from bottom) a variable name, no matter
long or short the variable name is.

Note that the write operation is the formal way to assign
a new value to a variable, and as such, a new programming
language can be deﬁned with assignments to be replaced by
write operations and control mechanisms deﬁned accordingly.
To simplify the matter, matured concepts like date types, vari-
able declarations, function deﬁnitions and function calls etc. are
not to be redeﬁned. What to be obtained is a computation model
rather than a complete programming language. This computa-
tion model is named Operation Expression, abbreviated as OE,
since a program in this model is an expression constructed with
the write (as well as read) operator and control mechanisms.

Deﬁnition 2 (Operations on variables).
¯ : V × Em → Eo, write operation,
: V × Eo → Em, read-after operation,
(cid:58): V × Eo → Em, read-before operation,
where Eo and Em are respectively the set of operation ex-
pressions (to be deﬁned) and the set of mathematical expres-
sions on variable set V.

These operations are represented respectively as:
¯v(e): to write variable v with math expression e,
v(p): to read variable v after (the execution of) p,
(cid:58)v(p): to read variable v before (the execution of) p,
where p is an operation expression in Eo.
The concept of variables includes scale variables, well-deﬁned

structures and elements of such structures.

Example 2.

(a) ¯x(x + 1), ¯A[i](B[i]), ¯A(B), to write variable x, array ele-

ment A[i] and array A as a whole respectively.

(b) x( ¯x(x + y)), A[ j]( ¯A[i](B[k])), A( ¯A(B)), to read variable
x, array element A[ j] and the whole array A after respective
write operations.

(c) (cid:58)x(¯v(e)), to read variable x before operation expression

¯v(e).

With a variable name ﬁxed as the ﬁrst operand and leaving
the second operand absent for the two read operations, obtained
are semantic functions deﬁned on Eo. Semantic functions are
the key to open door from program text in OE to program se-
mantics.

4

Deﬁnition 3 (Semantic function). Let v be an arbitrary vari-
able, i.e. v ∈ V. From Deﬁnition 2, we have:

v : Eo → Em,
(cid:58)v: Eo → Em,
v and (cid:58)v are called semantic functions on Eo. The former is

abbreviated as a F-function while the latter is a I-function.

Note that when an operation expression in Eo is given to the
semantic functions as their respective operands, the semantic
functions become complete read-operations, each to return a
math expression.

Now, for every p, p ∈ Eo, (cid:58)v(p) is a math expression which
would evaluate to the value of v at the initial state of p, and v(p)
is a math expression which would evaluate to the value of v at
the ﬁnal state of p. The math expressions mentioned above are
both deﬁned on the initial state of p.

Proposition 1 (Initial and ﬁnal value).

v represents the ﬁnal value of v in general when no particu-

lar operation expression is in question.

(cid:58)v represents the initial value of v in general when no partic-

ular operation expression is in question.

Proposition 1 ensures us to represent freely how the ﬁnal
state relies on the initial state of a program (or program seg-
ment). Thus, there is a formal way now to describe semantics
of programs.

In contrast to conventional assignment, with the two read-
operations as its inverse, the write-operation makes a big diﬀer-
ence.

Semantic functions are used to trace back written expres-

sions.

Example 3. The semantics of x(x + v) is x = x + v and v = v
since by semantic axioms given blow, we have x(x(x+v)) = x+v
and v = v.

Example 3 suggests the following deﬁnition for programs in
general. In Deﬁnition 2 and what follows, S is always a com-
plete program by itself. Deﬁnition 4 is supported by Proposi-
tion 2 below. By “very initial value” we mean values happen to
be held by variables declared, but not initialized for S yet.

Proposition 2 (Very initial value). For program S , (cid:58)v(S)=v, i.e.
(cid:58)v=v, for all v ∈ V.

Deﬁnition 4 (Program semantics). The semantics of program
S is ∀v ∈ V : v = ev∧ (cid:58)v=v where ev is an expression which
would return, when evaluated at the initial state of S , the ﬁnal
value of v.

Remarks

• Assignments (write-operations), including conditional as-
signments and repeated assignments (loops), are the only
consisting elements of any program. Thus, there must be
an expression ev for variable v as stated in Deﬁnition 4.

• Expression ev may be of special type CSP as deﬁned next
by Deﬁnition 6 to serve the need of conditional assign-
ments.

With semantic functions, we can now extend the concept
of predicates to the concept of semantic predicates. A conven-
tional predicate speciﬁes a property of an individual object, or
it describes how two or more objects are related. A program
relates ﬁnal values of variables with their initial values, and as
such, it requires a new kind of predicates to specify variable
relations (i.e. program semantics).

5. Syntax formulas of OE and semantics axioms on Eo

Formal syntax of OE is in fact a group of rules with which
operation expressions are to be constructed. The set of so con-
structed operation expressions is Eo. OE or Eo, they are diﬀer-
ent as well as two sides of the same thing. Syntax and seman-
tics, they will be given side by side.

In formulas below, v ∈ V, e ∈ Em and b, bi, i = 1, · · · , n are

Boole expressions.
5.1. Assingments
5.1.1. Special term and simple term

Deﬁnition 5 (Semantic predicate). The concept of semantic pred-
icate is an extension of the concept of conventional predicate by
allowing semantic functions to be its consisting part. A seman-
tic function may appear wherever a variable appears.

To be a semantic predicate, it must contain at least one se-
mantic function. Semantic predicates are also functions deﬁned
on Eo. For semantic predicate p and eo ∈ Eo, p(eo) is deﬁned
as the Boole expression obtained from p by substituting every
semantic function v or (cid:58)v in p with v(eo) or (cid:58)v(eo).

Note that p(eo) returns a truth value, telling whether this
semantic predicate p is or is not a property of operation expres-
sion eo.

Let p1 ≡ x = x + v and p2 ≡ v = v be two semantic
predicates. For x(x + v) ∈ Eo, we have p1(x = x + v) ≡ x(x(x +
v)) = x + v ≡ x + v = x + v ≡ true, since x(x(x + v)) = x + v
(see semantics axioms in Section 5). Similarly, we have p2(x =
x + v) ≡ v(x(x + v)) = v ≡ v = v ≡ true. Thus, p1 and p2 are
properties of x(x + v).

The semantics of the write operation and the two read oper-

ations will be formally deﬁned in Section 5.

Deﬁnition 6 (Conditional semantic predicates, CSP for short).
For semantic predicates p1, p2, · · · , pn and Boole expressions
b1, b2, · · · , bn, p1 ∧ b1 ⊕ p2 ∧ b2 ⊕ · · · ⊕ pn ∧ bn is a conditional
semantic predicate if b1 ⊕ b2 ⊕ · · · ⊕ bn at the initial state of the
program in question. ⊕ is the operator exclusive-OR.

As its value of p1 ∧ b1 ⊕ p2 ∧ b2 ⊕ · · · ⊕ pn ∧ bn = pi ∧ bi,

we have:

i = 1, 2, · · · , n.

bi → p1 ∧ b1 ⊕ p2 ∧ b2 ⊕ · · · ⊕ pn ∧ bn = pi ∧ bi = pi for

As an example of CSP, we have x = x ∧ y = y ∧ x ≤ y ⊕ x =
y ∧ y = x ∧ x > y, which tells that x and y are ascendingly
ordered. Note that x ≤ y ⊕ x > y is always true. A condi-
tional semantic predicate is also a function on Eo that returns a
conditional Boole expression, since it is not known which bi is
true.

Note that in case n = 1, a CSP degenerates to a normal

semantic predicate.

The above deﬁned concepts, including write/read operations
and semantic functions are all about individual variables. Other
deﬁnitions, including CSP, are preparation for stating semantic
axioms in Section 5, where we approach to the second step of
ARM, i.e. from individuals to a system.

5

By simple term we mean to write a single variable, condi-

tionally or unconditionally.

By Proposition 2 we have (cid:58)v=v for all v ∈ V, and for vaiable
u, u is not written by operation p, we have u(p) = u or u = u.
These two semantic axioms are assumed as part of all semantic
axioms to be given below.

Deﬁnition 7.

Syntax formula 1
(F1.1) special-term ::= ε
(F1.2) simple-term ::= |vsimple-term(v)
simple-term(v) ::=unconditional-s-term(v) | conditional-s-

term(v)

unconditional-s-term(v) ::= v(e)
conditional-s-term(v) ::= v(e)b | conditional-s-term(v)(cid:12)v(e)b
Semantic Axiom 1
(A1.1) v(ε) = v, i.e. sem(ε) ≡ v = v
(A1.2) v(v(e)) = e, i.e. sem(v(e)) ≡ v = e
(A1.3) v(v(e)b) = e if b ∼ v if ¬b, i.e. sem(v(e)b) ≡ v =

e ∧ b ⊕ v = v ∧ ¬b

(A1.4) v(v(e1)b1 (cid:12) v(e2)b2 ) = e1 if b1 ∼ e2 if b2 ∼ v if ¬(b1 ∨

b2),

i.e. sem(v(e1)b1 (cid:12) v(e2)b2 ) ≡ v = e1 ∧ b1 ⊕ v = e2 ∧ b2 ⊕ v =

v ∧ ¬(b1 ∨ b2)

(A1.5) sem(conditional-s-term(v)(cid:12)v(e)b) ≡ sem(conditional-

s-term(v)) ∧¬b ⊕ sem(v(e)) ∧ b

Remarks
• The symbol |v above means for every v, v ∈ V, exclusive-

OR.

• A conditional-s-term(v) allows more than one condition
to be given for selecting one value as the second operand
of writing v. These conditions must be exclusive with
each other when evaluated at runtime. Otherwise, a run-
time error would be raised. Program designers are sup-
posed to be aware of these conditions.

• By (A1.1), the special term ε writes no variable at all. It

resembles “skip”.

• Axioms given with conditional expressions (where sym-
bol “∼” denotes “or”) are included just to help under-
standing sem(p), a new way to deﬁne axioms with CSP.

• Note that (cid:12) can be omitted here and below. It is like the

multiplication operator.

5.1.2. Simultaneous assignment

By simultaneous assignment we mean to write more than

one diﬀerent variable simultaneously.

Deﬁnition 8.

Syntax formula 2
(F2) simultaneous-term ::= simple-term(cid:12) simple-term

| simultaneous-term(cid:12)simple-term | (simultaneous-term)b

Semantic Axiom 2
For simple-term or simultaneous-term p and q, let Vp , Vq
be sets of variables written by p or q respectively. It is required
that Vp ∩ Vq = ∅.

(A2.1) v(p (cid:12) q) = v(p) if v ∈ Vp ∼ v(q) if v ∈ Vq ∼ v if

v (cid:60) Vp ∪ Vq

or sem(p (cid:12) q) ≡ ∀v ∈ V : v = v(p) ∧ v ∈ Vp ⊕ v = v(q) ∧ v ∈

Vq ⊕ v = v ∧ v (cid:60) Vp ∪ Vq

(A2.2) v((p (cid:12) q)b) = v(p (cid:12) q) if b ∼ v if ¬b
or equivalently (p (cid:12) q)b ≡ p (cid:12) q if b ∼ ε if ¬b
or sem((p (cid:12) q)b) ≡ sem(p (cid:12) q) ∧ b ⊕ sem(ε) ∧ ¬b
(A2.3) (pb1 )b2 = pb1b2 or sem(pb1 )b2 ≡ sem(p) ∧ (b1 ∧ b2) ⊕

sem(ε) ∧ ¬(b1 ∧ b2)

Example 4.

x(1)y>0(cid:12)x(0)y=0(cid:12)x(−1)y<0 is a simple term to write variable
x so that x characterizes variable y. This term is the same as
x(1)y>0x(0)y=0x(−1)y<0 since (cid:12) can be omitted. u(e1) (cid:12) v(e2),
u(e1) (cid:12) (v(e2))b, (u(e1) (cid:12) v(e2))b, (u(e1) (cid:12) v(e2))b (cid:12) w(e3) are
diﬀerent forms of simultaneous terms.

Remarks

sem(p; q) ∧ b ⊕ sem(ε) ∧ ¬b

(A3.5) ((p; q)b1 )b2 = (p; q)b1∧b2 or sem((p; q)b1 )b2 ≡ sem(p; q)∧

(b1 ∧ b2) ⊕ sem(ε) ∧ ¬(b1 ∧ b2)

Example 5. For p ≡ x(x + y), q ≡ y(x − y), r ≡ x(x − y),
to compute sem(p; q; r). Since p; q; r = (p; q); r, let’s compute
sem(p; q) ﬁrst. By (A1.2), sem(q) ≡ y =
(cid:58)x. Here(cid:58)x(cid:44) x
since q is not a program by itself, it is just a part of p; q. Simi-
larly, we have x(p) = x + y ∧ y(p) = y. Thus, by (A3.1) we have
sem(p; q) ≡ y =
(cid:58)x∧(cid:58)x= x + y ∧ y = y ≡ y = x ∧ x = x + y.
Notice here the deletion of (cid:58)x= x + y∧(cid:58)y=y, denoted by |del in the
axiom.

(cid:58)x-(cid:58)y∧x =

(cid:58)x-(cid:58)y∧x =

Further computation tells that sem(p; q; r) ≡ sem((p; q); r) ≡

x = y ∧ y = x.

Note that (p; q; r)x>y = (x(x + y); y(x − y); x(x − y))x>y is a
conditional simple sequence. It’s easy to compute, by (A3.3),
that sem((p; q; r)x>y) ≡ sem((p; q); r) ∧ x > y ⊕ x = x ∧ y =
y ∧ x ≤ y ≡ x = y ∧ y = x ∧ x > y ⊕ x = x ∧ y = y ∧ x ≤ y, i.e.
it sorts x, y into ascending order.

Remarks

• “v(p; q) = v(q) with (cid:58)x(q) = x(p) for all x ∈ V” denotes
that the initial value of every variable x in x(q) is the ﬁnal
value of x after p. That is ∀x :(cid:58)x(q) = x(p).

• The function of ∀x :(cid:58)x(q) = x(p) in (A3.1) is a value trans-
fer: to pass the ﬁnal values after p to q as the initial values
for q to start with. When this transit work is completed,
∀x :(cid:58)x(q) = x(p) should be deleted from sem(p; q). This
deleting is denoted by |del∀x : (cid:58)x(q) = x(p).

• Each of p and q may be a simple-term or a simultaneous-
term by itself. It is derivable from (A2.1) that p (cid:12) q =
q (cid:12) p, i.e. (cid:12) is commutative.

• It is forbidden that p and q write on the same variable
unless the written expression evaluate, at runtime, to the
same value.

Proposition 3 below states that the two steps of value-passing
is associative since the values to be passed are ﬁnal values after
p and after p; q respectively, that are uniquely given by p or by
p; q.

Proposition 3. For simple sequences p, q and r

p; q; r ≡ (p; q); r ≡ p; (q; r)

(associative law)

5.1.3. Sequential control

5.1.4. Sequence: operation expression in Eo

The sequential control operator is semicolon “;”, as used by

many of a programming language.

Deﬁnition 9.

Syntax formula 3
(F3) simple-sequence ::= term;term | term;simple-sequence

| simple-sequence;term | (simple-sequence)b
| simple-sequence;simple-sequence

term ::= simultaneous-term | simple-term
Semantic Axiom 3
(A3.1) v(p; q) = v(q) with (cid:58)x(q)= x(p) for all x ∈ V or
sem(p; q) ≡ sem(q) ∧ ∀x :(cid:58)x(q) = x(p)|del∀x : (cid:58)x(q) = x(p), or
sem(p; q) = sem(q)|∀x :(cid:58)x(q) = x(p)

(cid:58)v(p) = v for all v ∈ V

(A3.2) v(p; q) =
(A3.3) p; q; r ≡ (p; q); r
(A3.4) v((p; q)b) = v(p; q) if b ∼ v if ¬b or sem((p; q)b) ≡

A sequence allows loop structures to be part of it. In what
follows, N is a constant integer no less than 0, and b is a se-
mantic predicate, containing either F-functions only or both F-
functions and I-functions.

Deﬁnition 10.

Syntax formula 4
(F4) sequence ::= simple-sequence | loop | sequence;sequence

| sequenceb

loop ::= (sequence)N | (sequence)b | εb | termN | termb
Semantic Axiom 4
(A4.1) For sequence p, q, sem(p; q) ≡ sem(p); sem(q)
(A4.2) sem(pb) ≡ sem(p) ∧ b ⊕ sem(ε) ∧ ¬b
(A4.3) sem(pN) ≡ sem(ε)∧N=0⊕sem(p)∧N=1⊕sem(p); sem(pN−1)∧

N > 1

(A4.4) sem1(pb) ≡ sem(ε)∧b(ε)⊕(sem(p)∧¬b(ε); sem(pb))

6

in case b contains only F-functions. This is the ﬁrst type of
repeat-until loop.

(A4.5) sem2(pb) ≡ sem(p); sem1(pb)) in case b contains
both F-function(s) and I-function(s), it is the second type of
repeat-until.

(A4.6) sem(εb) ≡ sem(εb) ∧ ¬b(ε) ⊕ sem(ε) ∧ b(ε)

Remarks

• Proposition 3 above applies to sequence as well.

• A loop body may be just a term. That is why we have
termN and termb in (F4). The semantics of such a loop is
covered by Semantic Axiom 4.

• The semicolon “;” betweent sem(p) and sem(q) in (A4.1)
is a semantic operator to form semantic formulas. See
Deﬁnition 14 in Section 6.

Example 6. For array A[0..N − 1], N > 1,
p1 ≡ m(A[0])i(1); (m(A[i])A[i]>mi(i + 1))¬(i<N) is a sequence to
ﬁnd the maximum element of A : m = max(A[0..N − 1]).
For array A[0..N − 1], N > 1, p2 ≡ (q1; q2)N−1 is a sequence
that sorts A into ascending order, where q1 and q2 are condi-
tional simultaneous terms:
(cid:74)N−2

(cid:74)N−2

i=0 (A[i](A[i+1])A[i+1](A[i]))b1 ≡

q1 ≡

i=0 swap(A[i], A[i+

q2 ≡

(cid:74)N−2

i=1 (A[i](A[i+1])A[i+1](A[i]))b2 ≡

(cid:74)N−2

i=1 swap(A[i], A[i+

1])b1

1])b2

in which b1 = even(i) ∧ A[i] > A[i + 1], b2 = odd(i) ∧ A[i] >
A[i + 1] and swap(a, b) is a function to exchange values of a
and b. Here the role of swap is only to make clear what q1 and
q2 do.

i=1 is similar to (cid:81)N−2

i=1 (product).

(cid:74)N−2

To compute the semantics of a loop, the concept of loop in-

variant is needed.

Deﬁnition 11. For a loop with loop body q, the loop invariant
is a semantic predicate b that is true before and after q. Vari-
ables that are not written by q should not be counted in.

Note that a loop may have more than one invariant by Deﬁ-
nition 11. But, when we talk about the loop invariant, we mean
the maximum one, i.e. it implies all other invariants of this loop.
The loop invariant of p1 is m = max(A[0..i − 1]) ∧ 1 ≤ i ≤
= AM is not loop invariant since array A is not
N while AM
written by the loop where AM is the multiple set consisting of
all elements of A. So is AM. Now, i = N is the termination
condition (¬(i < N) ∧ 1 ≤ i ≤ N ≡ i = N). Put the invariant
and termination condition together, we have, as the semantics
of p1, m = max(A[0..N − 1]) ∧ i = N.
The body of loop p2 is q1; q2. AM

= AM remains constant
for this loop, it is part of the loop semantics as well as part of
loop invariant. A loop invariant should imply progress for the
loop to reach its goal. The idea behind q1; q2 is clear: to reduce
the number of mis-ordered pairs in A. (A[i], A[ j]), i < j, is a
mis-ordered pair for ascending ordering if A[i] > A[ j]. So, the
loop invariant of p2 is: |{i|A[i] > A[ j] ∧ i < j}| ≤ |{i|A[i] >
= AM is true since swap is
A[ j] ∧ i < j}| ∧ AM
the only operation. Loop p2 will repeat its body N − 1 times

= AM. Am

to complete the sorting since the number of mis-ordered pairs
involving any individual array element is no more than N − 1.
Loop p2 provides hints to us: loop invariant is part of the
semantics of loop body. For OESPA, it would be suﬃcient to
compute semantics of loop body. Proposition 4 given next may
apply to loops in any programming language in case the loop
semantics is not computed.

Proposition 4. If h is the invariant of loop p and k is the termi-
nation condition of p, then, when p terminates, we have sem(p) =
h ∧ k.

Remarks

• All variables appearing in semantic predicate b are con-
stants in the loop: they represent their respective initial
values of qb. All F-functions and I-functions in b are
their respective ﬁnal and initial values of each execution
of loop body q. For conventional loops, variable names
play the role of F-functions.

• In case b contains only F-functions, qb is of repeat q until
b type: qb ends when b becomes true. It is possible that b
is true at the initial state of qb.

• In case b contains both F-function(s) and I-function(s),
pb is often used for convergence test. For example, b ≡
|x− (cid:58)x| ≤ δ is used to test how x is close to (cid:58)x after each
execution of p (the loop body). And as such, p must
be executed at least once since otherwise x =
(cid:58)x. pb ends
when|x−(cid:58)x| ≤ δ(i.e. b) becomes true. Note that (cid:58)x is not a
constant: it is the initial value each time to start the loop
body p and it is also the ﬁnal value after the previous
execution of the loop body.

• The special loop εb is useful for constructing reactive sys-
tems. It appears before a sequence like in εb; s: it waits
by repeated execution of ε till a signal (like a button push)
from outside to make b true to end εb and to start s.

• We didn’t put Proposition 4 as a theorem since rigorous
proof has not been found. This proposition is helpful to a
programmer for him to understand his loop.

Deﬁnition 12. The above deﬁned syntax formulas 1 to 4, in-
cluding terms, simple sequences and sequences are the syntax
of OE. Everything constructed according to this syntax is an
operation expression. Eo is the set of individual operation ex-
pressions.

So far, what we have deﬁned is in fact sequential OE. Def-
inition 13 tries to touch parallel OE. A parallel operation ex-
it doesn’t have
pression is semantically nondeterministic, i.e.
a unique ﬁnal state for any given initial state. We will explain
it with examples instead of deﬁning it. An important idea is to
ﬁnd invariants from nondeterministic semantics.

Deﬁnition 13.

Syntax formula 5, (cid:107) is the parallel operator

7

(F5) parallel-sequence ::= (sequence(cid:107)sequence)|(parallel-

sequence(cid:107)sequence)

Semantic axiom 5, for sequences p and q,
(A5.1) sem(p (cid:107) q) = sem(p) ⊗ sem(q)

Remarks

• For p and q in parallel, there exist at least three situations:
independent with each other; cooperating to provide the
same service, or cooperating with due division of labor.
For independent p and q, sem(p) and sem(q) are also in-
dependent. We will discuss semantics of cooperating se-
quences with examples in a separate paper.

• The semantics of “⊗” is nondeterministic. In case p and
q are independent, ⊗ is the logic operator ∧, i.e. sem(p (cid:107)
q) = sem(p) ∧ sem(q).

As the third step of ARM, analytic methods are proposed in
Section 6.

6. Semantics Calculus (SC for short)

An operation expression in sequential OE consists of se-
quences (loops are also sequences) of terms connected by semi-
colon (the sequential operator). The semantics of terms are se-
mantic predicates (SP for short) or conditional semantic predi-
cates (CSP). Thus, the computation of program semantic starts
from the computation of term semantics to yield a semantic for-
mula as deﬁned in Deﬁnition 14 below. Semantic calculus to be
introduced below aims to reduce a semantic formula to a SP or
CSP, i.e. to deduce the semantics of the operation expression
behind the semantic formula.

Deﬁnition 14. p1; p2; · · · ; pn is called a semantic formula if,
for 1 ≤ i ≤ n, pi is a SP or CSP.

Semantic calculus is an invention to serve the need of se-

mantics analysis of operation expressions.

In the rules given below, V is the set of variables in question,
and p, q, r are SP or CSP while Vp, Vq, Vr are subsets of V
consisting of variables whose corresponding semantic functions
appear in p, q, r respectively, e.g. x ∈ Vp means x ∈ p.

Deﬁnition 15 (Semantic calculus, SC for short). Semantic cal-
culus consists of 5 reduction rules as given below.
Rule 1 (Completion)
With com as the completion operator, and let be pc ≡ ∧v∈V (cid:48) v =
v, where V (cid:48)=V-Vp, we have the completion rules below:
(a) com(p) ≡ p ∧ pc is the completion of p,
(b) com(p; q; · · · ; r) ≡ com(p); com(q); · · · ; com(r) is the com-
pletion of p; q; · · · ; r.
Rule 2 (Relay) This rule is essentially the same as semantic ax-
iom (A3.1).
p; q ≡ q(v,(cid:58)v) ∧ p(v,(cid:58)v)|(cid:58)v
where q(v,(cid:58)v) is obtained by replacing every v in q with (cid:58)v, and
p(v,(cid:58)v) is obtained by replacing every v in p with (cid:58)v. “|(cid:58)v” re-
quires deletion of p(v,(cid:58)v) when every (cid:58)v in q(v,(cid:58)v) gains its value

8

Figure 1: Semantic calculus

from p(v,(cid:58)v). See examples below.
Rule 3 (Associative)
p; q; r ≡ (p; q); r
Rule 4 (Substitution)
p ≡ p(cid:48) ∧ q ≡ q(cid:48) ⇒ p; q ≡ p(cid:48); q(cid:48)
Rule 5 (Distribution)
p; (p1 ∧ b1 ⊕ p2 ∧ b2 ⊕ · · · ⊕ pn ∧ bn) ≡ (p; p1) ∧ b1 ⊕ (p; p2) ∧
b2 ⊕ · · · ⊕ (p; pn) ∧ bn,
(p1 ∧ b1 ⊕ p2 ∧ b2 ⊕ · · · ⊕ pn ∧ bn); p ≡ (p1; p) ∧ b1 ⊕ (p2; p) ∧
b2 ⊕ · · · ⊕ (pn; p) ∧ bn.
And for completion:
com(p1 ∧b1 ⊕ p2 ∧b2 ⊕· · ·⊕ pn ∧bn) ≡ com(p1)∧b1 ⊕com(p2)∧
b2 ⊕ · · · ⊕ com(pn) ∧ bn.

Remarks on above rules:
(1) Rule 1 is to make the implicit part pc of p explicit.
(2) Rule 2 is, by the conjunction operation, to make the ﬁnal
values of variables after p delivered to q as its respective initial
values.

(3) Rule 3 states the fact that relay of deliveries is associa-

tive. Furthermore, it is provable that p; q; r ≡ p; (q; r).

(4) Rule 4 says that equivalents are substitutable with each

other.

(5) Rule 5 serves the need of symbolic computation, should

CSP be encountered.

Example 7. For operation expressions p ≡ x(x + y), q ≡ y(x −
y), r ≡ x(x − y) as given in Example 7, the semantics of p; q; r
was computed based on semantic axioms. Now, from respec-
tive semantics of terms p, q, r obtained is sem(p; q; r) ≡ x =
x + y; y = x–y; x = x–y. This is a semantic formula. It will be
reduced, by above given SC, to x = y ∧ y = x. Figure 1 above
explains the reducing steps. This could be done automatically
with symbolic computation tools (to be developed). Further-
more, sem(p; q; r)x>y ≡ sem(p; q; r)∧ x > y⊕ sem(ε)∧¬(x > y),
is reduced, by SC, to x = y ∧ y = x ∧ (x > y) ⊕ x = x ∧ y =
y ∧ ¬(x > y).

In case p; q; r is preﬁxed with x(2)y(1), we have:

sem(x(2)y(1)) ≡ x = 2 ∧ y = 1,
sem(x(2)y(1); (p; q; r)x>y)
≡ sem(x(2)y(1)); sem(p; q; r)x>y
≡ (x = 2 ∧ y = 1); (x = y ∧ y = x ∧ x > y ⊕ x = x ∧ y =

 ()xxy+； y()xy-()xxy-； operation expression  semantics of terms by axioms semantics formula rule 3, associative rule rule 1 + rule 2 (details are omitted) =xxyyx+Ù==xyyxÙ=rule 1 + rule 2 semantic predicate  =-xxy； ； =-xxy=yxy-=xxy+Ùy ∧ ¬(x > y))

1; x = x ∧ y = y ∧ ¬(x > y))

≡ (x = 2 ∧ y = 1; x = y ∧ y = x ∧ x > y) ⊕ (x = 2 ∧ y =

≡ x = 1 ∧ y = 2 ∧ 2 > 1 ⊕ x = 2 ∧ y = 1 ∧ ¬(2 > 1)
≡ x = 1 ∧ y = 2.

This example of x(2)y(1); (p; q; r)x>y illustrates the intended

symbolic computation of program semantics.

We have taken Prof. Hoare’s quick-sorting [9] as an exam-
ple in [10] to show how to develop semantics from C program
text, though in a way diﬀerent from this paper. We tried to ﬁnd
another C program of certain size as an example of computing
semantics. It has turned out that every C program contains li-
brary functions. We would, to start with in the future, develop
semantics of library functions.

Now, before going on with other examples, we would like to
stress once more the importance from reality to logic. Without
the proper deﬁnition of program variables, OESPA would not
be possible. The mate-method ARM leads a way from reality
to logic.

Next section provides two examples to illustrate the role of
OESPA in understanding program features: function calls and
C pointers. Table 1 below is a comparison between Hoare logic
and our work.

7. A study of two features from conventional programming

7.1. Functions

Function calls are often included in program texts: either
called by value or called by name. Here in this subsection, we
show, with examples, how to insert semantics of function calls
into semantic formula. This is to mend the missing of func-
tions in the deﬁnition of OE. Formal deﬁnitions of functions
and function calls are to be discussed and proposed when OE is
accepted to play a role in programming.

=Am ∧ ∀i : 0 ≤ i < N-1 : A[i] ≤ A[i+1].

Example 8 (Call by name). A program in C called quick-sorting
by Prof. Hoare has been discussed in [10], of which the seman-
tics is:
AM
The program segment
Quick-sorting(A); m(A[N-1])
will assign the maximum element of A into m. The semantics
of m(A[N-1]) is m=A[N-1], and the semantic formula for this
segment is
AM
That would be reduced, by semantic calculus, to
AM
i.e., AM

=Am ∧ ∀i : 0 ≤ i < N-1 : A[i] ≤ A[i+1] ∧ m=A[N-1],

=Am ∧ ∀i : 0 ≤ i < N-1 : A[i] ≤ A[i+1];m=A[N-1].

=Am ∧ ∀i : 0 ≤ i < N : A[i] ≤ m.

This example seems na¨ıve: it has two terms only: a call and
an assignment. But on the contrary, it is meaningful in gen-
eral. The way to reduce a semantic formula could be done, by
semantic calculus, pairwise in parallel. For semantic formula
p1; p2; · · · ; pn, its pairwise division is (p1; p2); · · · ; (pn−1; pn)
in case n is an even integer. The reduction of all these pairs

9

is the same as shown by this example, and parallel reduction
insures high eﬃciency.

For function calls that return a value, say m(sum(A)), where
sum(A) is a function call to return the sum of all elements in
array A. The semantics of this call is as simple as m=(cid:80)n−1
i=0 A[i],
since sem(sum(A))=(cid:80)n−1

i=0 A[i].

Example 9 (Recursion). To ﬁnd factorial of non-negative in-
tegers, i.e. for N, N ≥ 1, to ﬁnd N!. The recursive program to
implement function F(N) = N! is given, in OE, as below, where
superscript N > 1 is a Boole expression:
F(1)(1); F(N)(N × F(N − 1))N>1.
Note that it requires to compute F(N − 1) in order to com-
pute F(N). The semantics of above function is, by conditional
semantic predicate (CSP), as below:

F(N) = 1 ∧ N = 1 ⊕ F(N) = N × F(N − 1) ∧ N > 1.
This is abbreviated as:
F(N) = (1 ∧ N = 1 ⊕ N × F(N − 1) ∧ N > 1).
By math induction and assuming
F(N − 1) = (N-1) × (N-2) × · · · × 2 × 1 ∧ N > 1,
we have
F(N) = (1 ∧ N = 1 ⊕ N × (N-1) × (N-2) × · · · × 2 × 1 ∧ N > 1),
i.e., F(N) = N × (N-1) × (N-2) × · · · × 2 × 1 ∧ N ≥ 1,
i.e., N! = N × (N-1) × (N-2) × · · · × 2 × 1 for N ≥ 1.
In addition to this, 0!=1 is deﬁned to be true. Thus, we have
N! = (1 ∧ N = 0 ⊕ N × (N-1) × (N-2) × · · · × 2 × 1 ∧ N ≥ 1).

This example tells that automatic tools for semantics com-
puting must be intelligent to make use of matured math methods
like math induction etc.

Another recursive function is to compute Fibonacci sequence

deﬁned by

Fib(0)=0, Fib(1)=1 and for n > 1, Fib(n)=Fib(n-1)+Fib(n-

2),
or in terms of CSP (in abbreviated form):

Fib(N)=(0∧N=0⊕1∧N=1⊕Fib(N − 1)+Fib(N − 2)∧N ≥

2).

The recursive OE program to produce the ﬁrst N+2 ele-

ments of the above deﬁned Fibonacci sequence is:
Fib(0)(0)Fib(1)(1); Fib(N)(Fib(N − 1)+Fib(N − 2))N>1.

It is a well-known fact that a recursive algorithm can always
be implemented by a loop with higher eﬃciency. An OE pro-
gram with loop to produce Fibonacci sequence is:

i(0) j(1); (i(i + j); j(i + j))i= j,
of which the loop body is i(i + j); j(i + j). Note that this loop
will never terminate (to reﬂect inﬁnite length of Fibonacci se-
quence) since its termination condition is i = j that always eval-
uates to false. The semantics of this loop body is i=i+ j; j=i+ j,
or by semantic calculus,
i=i+ j ∧ j=i+2 j.
So, the semantic formula of the whole program is of inﬁnite

length as below:

i=0 ∧ j=1; i=i+ j ∧ j=i+2 j; i=i+ j ∧ j=i+2 j · · · .
Thus, the above program is in dead to produce Fibonacci
sequence. Diﬀerent from the original recursive deﬁnition, this
inﬁnitely long formula allows parallel computing of two adja-

Table 1: A comparison between Hoare logic and OE+SP+A (OE: operation expression, SP: semantic predicate, A: axiom)

method

program
studied

Hoare
logic

pure logic

formal
syntax
only

concept
of seman-
tics
properties
of
pro-
grams

OE+SP+A from real-
ity to logic

OE:
formal
syntax +
semantic
axioms

a

what
program
does,
precise
deﬁnition

concept
variables

of

core
statement

new con-
cept

process of
reasoning

math objects:
a value, ac-
cessible only
for evaluating
math expres-
sion
a value and
a physical ob-
ject allowing
3 operations

assignment,
ambigu-
ous

reasoning
axioms
based on
assertions

write
operation,
not
am-
biguous

semantic
functions
predicate
formula

of

sequential
compu-
tation
weakest
precondi-
tions
semantic
calculus,
parallel
comput-
ing

cent Fibonacci numbers, namely Fib(2N) and Fib(2N+1) for
N ≥ 1:

Fib(2N)=Fib(2N-2)+Fib(2N-1),
Fib(2N+1)=Fib(2N-2)+2Fib(2N-1).

Example 10 (Iteration). Next is a simple iterative program in
C to ﬁnd out root of a given equation.
x0=a ;

/ * a i s an i n i t i a l a p p r o x i m a t e

do {

v a l u e * /

x1=x0 ;
x0=g ( x1 ) ;

v a l u e * /

/ * c o m p u t e n e x t a p p r o x i m a t e

} w h i l e ( f a b s ( x0 −x1 ) > d e l t a ) ;

/ * d e l t a i s

t h e a l l o w e d d i f f e r e n c e * /
r o o t o f

t h e

e q u a t i o n i s %f ’ ’

p r i n t f ( ‘ ‘ t h e
, x0 ) ;

To put this iteration in OE, we have:
x(a); (x(g(x)))b,
where b ≡ |x-x| ≤ δ and x is the initial value of x before
each execution of the loop body x(g(x)). Note also that |x-x| is
the absolute value of the diﬀerence. The read-before operator
“(cid:58)” has made iteration much simpler.

In case the loop terminates, the semantics would be
x=g(x) ∧ |x-x| ≤ δ.
Programmers are not responsible for termination if g(x) is

given to them.

Figure 2: The initial and goal states of Hanoi Tower game

Example 11 (Hanoi Tower). This problem is related to an an-
cient Greek fairy tale. There were three poles in a row stand-
ing on the grand in a temple, with 64 disks (each has a hole
in the center) of diﬀerent sizes on the ﬁrst pole (A) while the
other poles (B and C) are empty (see Figure 2). All disks are
in order: the biggest one at the bottom and every other one is
smaller than the one beneath it. It is asked to move all 64 disks
from pole A to pole C under the conditions:

1) One disk at a time to move from pole to pole,

2) A disk must be put on top of a bigger disk if the receiving

pole is not empty,

3) Pole B is the only place for a disk to stay before it ﬁnally

arrives at Pole C.

It should be clear by now that a function call by name ap-
pears in OE programs in the same way as it appears in other
programs. The quick-sorting in Example 8 illustrates this. A
function call by value appears in OE programs is as a read-
after operation applied on the function name being called like
m(sum(A)). Example 9 talked about semantics of recursive
functions deﬁned in terms of OE. Note F(N) in Example 9 is
called as a whole, where N is the real parameter for calling.
F(N) is the operand of reading: to read the value returned by
the call.

The problem is: to make the move in the temple and to com-

pute the move sequence here.

For this example, it is suﬃcient to know that its solution is

given by the following recursive function:

T (N, A, B, C) = T (N-1, A, C, B); T (1, A, B, C); T (N-1, B, A, C)
and
T (1, A, B, C) = (A, B, C),
where N is an integer greater than 0. In case this function
is called, it looks like S (T (N, A, B, C)) in OE: to store the se-
quence in S . This is a diﬀerent way of recursion from Fibonacci

10

InitialGoalABCABCA variable name is its compiler name (cn for short) since it is
the compiler that assigns this address to the variable. A pointer
is a false name ( f n for short) of it since only indirect access
is possible. Let be HN={hn}, CN={cn} and FN={ f n}, i.e. hn,
cn and f n are individuals while HN, CN and FN are the re-
spect sets of individuals. Furthermore, FN2 is the pointer set of
pointer to pointer.

It is important to notice that HN(the set of addresses) is in
fact a new kind of data type, since it allows plus and minus
operations to be applied as long as the returned value falls into
HN. In other word, an address is also a two-facet object like a
variable.

There are two operations, namely ∗ and &, deﬁned in C on

pointers:

∗p=a and p=&a
for pointer p pointing to variable a. Now, ∗p is another
way to name variable a. Let’s call ∗p anonymous name (an
for short) of a, since the name a is not explicitly mentioned.
Besides, whenever p is assigned a new address, ∗p=a will no
longer be true. Let be AN={an}.

Here, ∗ is a math operator, since its operand is the content
of pointer p, i.e. a value of type HN, a math object; & is a op-
erator whose operand is the variable name, not the value of this
variable, that is a physical object. Thus, as the respect formal
deﬁnitions of ∗ and &, we have

∗ : HN → CN,
& : CN → HN.

Note that the deﬁnition of ∗ is HN → CN instead of FN →
CN, since the content of a pointer (value of type HN) is the
real operand of ∗. Based on these two deﬁnitions, we have the
semantics axioms below:
Axioms for pointers (AP1-6)
(AP1)&∗ = id : HN → HN, ∗& = id : CN → CN,
where id is the identiﬁcation operator deﬁned respectively on
HN and CN.
(AP2) ∀v ∈ CN : &v ∈ HN ∧ constant(&v), once an address is
assigned to v, it will never change.
(AP3) &u = &v → u ≡ v, if two variables share the same ad-
dress, then they are always equivalent with each other.
(AP4) ∗p = ∗q ≡ p = q, if two diﬀerent pointers point to the
same variable, then they are only equal in value.
(AP5)p(&a) → p = &a ∧ ∗p = a. ∗p is changed to ∗p by
p(&a).

Remarks

• The diﬀerence between (AP3) and (AP4) is that u = v
will always be true while ∗p = ∗q may be changed when
p or q receives a new value in HN.

• (AP5) is an extension of of (A1.1). Here, ∗p = a instead
of ∗p = a since ∗ is a math operator. ∗p is the variable p
points to before p(&a). Note that &p is illegal since the
operand of & is a variable name, not a value.

Figure 3: The structure of the move sequence: a binary tree (4 disks)

and factorial since the recursive part appears twice in the deﬁ-
nition.

The above deﬁnition of T (N, A, B, C) produces the sequence
for disk move: (A, B, C) is to move the disk on top of pole A and
to put it on top of pole C. All moves must be done in sequence
given by T (N, A, B, C).

Now, semantics of T (N, A, B, C), i.e. T (N, A, B, C).
We have T (1, A, B, C) = (A, B, C), and for N > 1,
T (N, A, B, C) = T (N − 1, A, C, B); (A, B, C); T (N − 1, B, A, C)
is the semantic formula. This computing goes on and ter-
minates for given N. Careful observation helps to ﬁnd that
T (N − 1, A, C, B) and T (N − 1, B, A, C) are independent with
each other, i.e.
they can be computed in parallel since they
are solutions to diﬀerent problems. So, the above formula can
be re-written as

T (N − 1, A, C, B) (cid:107) (A, B, C) (cid:107) T (N − 1, B, A, C).
This observation applies to T (N − 1, A, C, B) and

T (N − 1, B, A, C) as well. It is easy to ﬁnd out that the complete
sequence of disk move is a full binary tree traveled in middle
order way if such analysis goes on (see Figure 3 for N=4). As
such, the length of the sequence is 2N-1.

The ﬁnal conclusion is: all individual move can be com-
puted in parallel.
In case we want to develop a game from
Hanoi Tower, we can compute the next move right away. The
formula to compute the nth move, when the total number of
disks is N and n = 2k×(2m+1), is given by:

(a, b, c) = (A, B, C) ∧ odd(N-k) ⊕ (A, C, B) ∧ even(N-k),
and the move is rotatem(a, b, c), i.e. to rotate (a, b, c) m times.
The right side of above equation suggests a new way to write
conditional expressions.

For example, for N = 4 and n = 10, we have k = 1 and
m = 2. Since N − k = 3 is odd, we have (a, b, c) = (A, B, C). To
rotate (A, B, C) twice (m = 2), obtained is (B, C, A). Thus, the
10th move is to take the top disk on stack B and to put it on top
of stack A. Readers may test it by hand simulation since there
are altogether 15 moves only for N = 4.

7.2. Pointers in C
7.2.1. Semantic axioms for pointers

Pointers [11] are special variables via which other variables
can be indirectly accessed. It is useful for call-by-value func-
tions. Extra operations, in addition to read/write, need to be
deﬁned for pointers as their due abstraction.

Careful study of the physical facet of pointers leads to a

better understanding.

A memory location may be accessed by its address, its vari-
able name and a pointer pointing to it. Address is its hardware
name (hn for short) since address is inseparable from hardware.

11

 (A,B,C) (A,C,B) (B,A,C) (A,B,C) (C,A,B) (B,C,A) (A,B,C) (A,C,B) (B,A,C) (C,B,A) (A,C,B) (B,A,C) (C,B,A) (A,C,B) (B,A,C) layer 1 layer 2 layer 3 layer 4 7.2.2. What is new in the understanding of pointers

Example 13. This example is also from the same book, p137.

1. Here the set of addresses is a new data type for it allows

restricted plus and minus operations.

2. Here it is made clear the diﬀerence between physical facet
and math facet of a variable while they are called L-value
and R-value respectively in the literature on C.

3. Here the essence of the two unary operators, namely ∗
and &, are made clear: the former is a math operator on
HN while the latter is a physical operator on CN. For a C
compiler, operator ∗ needs the address of p to indirect to
where p points to. But for semantic computation, it is not
necessary to mention the address of p. &p is illegal since
the operand of & is a physical object and p is a value.
4. In case p = 1000, 1000 ∈ HN, ∗1000 is considered as
an illegal L-value by C though the operand of ∗ is an
address. OE respects this fact since a C compiler needs
a pointer for indirection. Besides, it is unknown whether
address 1000 is available to the program.

5. With axioms (AP1-5), semantics of pointers can be com-
puted from program text as illustrated by examples be-
low.

Text in C:

Text in OE:

int a;
int ∗ d = &a;
∗ d = 10 − ∗d;
d = 10 − ∗d

int a, f n o f int d;
a(Ψ); d(&a); ∗d(10 − ∗d); d(10 − ∗d)

To compute a, d and ∗d.
First the semantics of a(Ψ); d(&a); ∗d(10 − ∗d):

a = Ψ ∧ d = &a is the semantics of a(Ψ); d(&a) that pro-
vides initial values for ∗d(10 − ∗d) whose semantics is ∗d =
10 − ∗d. Since the initial value of d is &a, so the semantics of
a(Ψ); d(&a) is ∗&a = 10−a, in which a = Ψ is the initial value,
i.e. a = 10–Ψ. Finally, the semantics of a(Ψ); d(&a); ∗d(10 −
∗d) is

d = &a ∧ a = 10 − Ψ that implies ∗d = a.
With these as the initial values of the last term d(10 − ∗d),

7.2.3. Examples of pointers’ semantics computation

The Grace letter Ψ is used as a general default value for all
data types in case a variable is not initialized. Ψ is just used to
ﬁnd absence of initial values in the course of semantic compu-
tation, it is not a consisting part of OE.

Example 12. This is from the book <Pointer on C>by Kenneth
Reek, 2013, P140
Text in C:

we have

d = 10–a = 10–(10–Ψ) = Ψ. Finally a = 10–Ψ ∧ d = Ψ.
Apparently, there are two errors here: lacking initial value

and wrong address.

Note that the process of passing initial values to the next
term is just the application of the rule of relay in semantic cal-
culus that can be done in an automatic way by symbolic com-
putation. We didn’t put down all formulas just to make it easier
to read.

int a = 12;
int ∗ b = &a;
int ∗ ∗c = &b

Text in OE:

int a, f n o f int b,

f n2 o f int c;

a(12); b(&a); c(&b);

To ﬁnd the values a, b and c, ∗b and ∗c, ∗ ∗ c.
From the text in OE and the axioms above, we have the

semantic formula below:
a = 12 ∧ b = &a ∧ c = &b since 12 and &a and &b are
constants. So, ∗b = a ∧ ∗c = b by (AP1).

From b = &a; c = &b we have b = &a; ∗ ∗ c = ∗ ∗ &b ≡
b = &a; ∗ ∗ c = ∗b. Applying the relay rule in semantic calculus
and (AP1), obtained is ∗ ∗ c = ∗ b(cid:58) ∧ b(cid:58)
Putting above results together:
a = 12 ∧ b = &a ∧ c = &b ∧ ∗b = a ∧ ∗c = b ∧ ∗ ∗ c = a.
As for values of ∗b, ∗c and ∗ ∗ c, they are respectively 12,
&a and 12 since diﬀerent names of the same address share the
same value.

= &a i.e. ∗ ∗ c = a.

8. Conclusion and future work

Computer science is to lay a solid foundation for program-
ming. OESPA is just one step forward towards this goal. Al-
though OESPA is essentially diﬀerent from Hoare logic (see Ta-
ble 1), it is still not possible to expect programmers to give up
what they are familiar in their daily work to switch to OESPA.
OESPA is important since it prepares a theoretical foundation
for the future generation computer systems. Contributions of
OESPA include:

1. It has formally deﬁned, for the ﬁrst time in the litera-
ture, the concept of program variables (in contrast to the
concept of math variables) to serve the need of formal
semantics study.

2. It includes math concepts like semantic functions, se-
mantic predicates, semantic calculus etc. that are badly
needed by formal semantics study, but do not exist in
conventional mathematics. As shown in Figure 4, these
concepts provide means for the analysis of all steps, but
testing, of software lifecycle.

12

We do not expect OE to be in practical use before it is en-
riched (by adapting data types, data structures etc.) to be a pro-
gramming language and auto tools are available. Our next goal
is to have a team to work together to do all these. We know that
the bibliography is very short. This is due to the fact that our
research is in a completely new direction and as such no similar
research reported yet. Besides, conventional semantics are, in a
sense, under criticism here, and it is suﬃcient to list just a few.

Acknowledgements

The authors would like to extend their sincere gratitude to
Jianhui Chen for his valuable suggestions. The work was sup-
ported by the National Key Research and Development Pro-
gram of China (No. 2019YFB1704003), the National Nature
Science Foundation of China (No. 71690231) and Tsinghua
BNRist.

Figure 4: New software lifecycle of OESPA

3. It has given program semantics a precise formal deﬁni-

References

[1] R. D. Tennent. The denotational semantics of programming languages.

Communications of the ACM, 19(8):437–453, 1976.

[2] G. D. Plotkin. A structural approach to operational semantics. Aarhus

university, 1981.

[3] C. A. R. Hoare. An axiomatic basis for computer programming.

Communications of the ACM, 12(10):576–580, 1969.

[4] J. He C. A. R. Hoare. Unifying theories of programming. Englewood

Cliﬀs: Prentice Hall, 1998.

[5] E. W. Dijkstra. A discipline of programming. Englewood Cliﬀs: Prentice

Hall, 1976.

[6] D. Gries. The science of programming. Springer Science & Business

Media, 1981.

[7] J. Misra K. M. Chandy.

Parallel Program Design: A Foundation.

Addison-Wesley publishing company, 1988.

[8] J. M. Wing E. M. Clarke. Formal methods: state of the art and future

directions. ACM Computing Surveys, 28(4):626–643, 1996.

[9] C. A. R. Hoare. Algorithm 64: quicksort. Communications of the ACM,

4(7):321–322, 1961.

[10] C. Yuan. OESPA: Semantic oriented theory of programming. Science

Press, China, 2019.

[11] K. A. Reek. Pointers on C. Addison-Wesley Longman Publishing Co.,

Inc., 1997.

tion.

4. It makes semantic computation possible.

5. It has clariﬁed the concept of “computer science”. This
term is often mixed up with computational mathematics
while the latter belongs to computer application.

Real programs are great in size. But this is not a problem at
all since a program may be divided into consisting subprogram.
Programmers used to insert comments into program text to no-
tify progress. With OESPA, such comments should be replaced
by semantic predicate (SP) to make progress explicit. To put all
these SP together, obtained is a SP formula, i.e. semantics of
the program. Isn’t it nice?

We are well aware that there is still a long way to go for
OESPA to play a role in practical programming. To start with
in our next research, we would propose rules to interpret, from
individual features of C, to semantic predicates. For example,
x=e is an assignment in C, it is interpreted as x=e. Other pro-
gramming languages, like Java or Python, may be chosen as
well for semantics interpretation. If this is well done for C, a
C program can then be interpreted as a semantic formula that
complies to semantic calculus. In case this is arranged as part
of work agenda, the development of auto tools to carry out the
interpretation and to do semantic calculus should also be ar-
ranged. Without such auto tools, it is impossible to interpret
programs consisting of hundreds of thousands of lines. We hope
that programmers may beneﬁt from reading this paper since the
above contributions would help in understanding program and
programming. You may try it by writing small programs in
the way as Figure 4 illustrated, An OE program is exactly an
expression of operations, no need for key words. As readers
can see in this paper, OE programs appear much simpler than
conventional ones. The iteration program given above in C has
about 10 lines while the corresponding OE program is one line
in length. That is why all examples in this paper are very small
in size.

13

 program  specification refined specification operation expression semantic formula SP SPOE SA SPC (to prove correctness) SPF: semantic predicate formula SPC: semantic predicate calculus SA: semantic axiom SPC (to prove correctness) SP: semantic predicate  