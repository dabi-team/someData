2
2
0
2

r
p
A
8
2

]
L
P
.
s
c
[

1
v
4
6
4
3
1
.
4
0
2
2
:
v
i
X
r
a

Stay Safe under Panic: Aﬃne Rust Programming
with Multiparty Session Types

Nicolas Lagaillardie !
Department of Computing, Imperial College London, London, SW7 2AZ, United Kingdom

Rumyana Neykova !
Department of Computer Science, Brunel University London, London, UB8 3PH, United Kingdom

Nobuko Yoshida !
Department of Computing, Imperial College London, London, SW7 2AZ, United Kingdom

Abstract

Communicating systems comprise diverse software components across networks. To ensure their
robustness, modern programming languages such as Rust provide both strongly typed channels,
whose usage is guaranteed to be aﬃne (at most once), and cancellation operations over binary
channels. For coordinating components to correctly communicate and synchronise with each
other, we use the structuring mechanism from multiparty session types, extending it with aﬃne
communication channels and implicit/explicit cancellation mechanisms. This new typing discipline,
aﬃne multiparty session types (AMPST), ensures cancellation termination of multiple, independently
running components and guarantees that communication will not get stuck due to error or abrupt
termination. Guided by AMPST, we implemented an automated generation tool (MultiCrusty) of
Rust APIs associated with cancellation termination algorithms, by which the Rust compiler auto-
detects unsafe programs. Our evaluation shows that MultiCrusty provides an eﬃcient mechanism
for communication, synchronisation and propagation of the notiﬁcations of cancellation for arbitrary
processes. We have implemented several usecases, including popular application protocols (OAuth,
SMTP), and protocols with exception handling patterns (circuit breaker, distributed logging).

2012 ACM Subject Classiﬁcation Software and its engineering → Software usability; Software and
its engineering → Concurrent programming languages; Theory of computation → Process calculi

Keywords and phrases Rust language, aﬃne multiparty session types, failures, cancellation

Digital Object Identiﬁer 10.4230/LIPIcs.ECOOP.2022.1

Funding The work is supported by EPSRC EP/T006544/1, EP/K011715/1, EP/K034413/1,
EP/L00058X/1, EP/N027833/1, EP/N028201/1, EP/T014709/1 and EP/V000462/1, and NC-
SS/EPSRC VeTSS.

Acknowledgements We thank the ECOOP reviewers for their insightful comments and suggestions,
and (alphabetical order) Zak Cutner, Wen Kokke, Roland Kuhn, Dimitris Mostrous and Martin
Vassor for discussions.

1

Introduction

The advantage of message-passing concurrency is well-understood: it allows cheap horizontal
scalability at a time when technology providers have to adapt and scale their tools and
applications to various devices and platforms. In recent years, the software industry has
seen a shift towards languages with native message-passing primitives (e.g., Go, Elixir and
Rust). Rust, for example, has been named the most loved programming language in the
annual Stack Overﬂow survey for ﬁve consecutive years (2016-20) [56]. It has been used for
the implementation of large-scale concurrent applications such as the Firefox browser, and
Rust libraries are part of the Windows Runtime and Linux kernel. Rust’s rise in popularity
is due to its eﬃciency and memory safety. Rust’s dedication to safety, however, does not

© Nicolas Lagaillardie, Rumyana Neykova and Nobuko Yoshida;
licensed under Creative Commons License CC-BY 4.0

ECOOP 2022.
Editors: Editors; Article No. 1; pp. 1:1–1:48

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

 
 
 
 
 
 
1:2

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

yet extend to communication safety. Message-passing based software is as liable to errors as
other concurrent programming techniques [58] and communication programming with Rust
built-in message-passing abstractions can lead to a plethora of communication errors [36].

Much academic research has been done to develop rigorous theoretical frameworks for the
veriﬁcation of message-passing programs. One such framework is multiparty session types
(MPST) [27] – a type-based discipline that ensures concurrent and distributed systems are
safe by design. It guarantees that processes following a predeﬁned communication protocol
(also called a multiparty session) are free from communication errors and deadlocks. Rust
may seem a particularly appealing language for the practical embedding of session types with
its message-passing abstractions and aﬃne type system. The core theory of session types,
however, has serious shortcomings as its safety is guaranteed under the assumption that a
session should run until its completion without any failure. Adapting MPST in the presence
of failure and realising it in Rust are closely intertwined, and raise two major challenges:

Challenge 1: Aﬃne multiparty session types (AMPST). There is an inherent
conﬂict between the aﬃnity of Rust and the linearity of session types. The type system of
MPST guarantees a linear usage of channels, i.e., communication channels in a session must
be used exactly once. As noted in [36], in a distributed system, it is a common behaviour
that a channel or the whole session can be cancelled prematurely – for example, a node can
suddenly get disconnected, and the channels associated with that node will be dropped. A
naive implementation of MPST cancellation, however, will lead to incorrect error notiﬁcation
propagation, orphan messages, and stuck processes. The current theory of MPST does not
capture aﬃnity, hence cannot guarantee deadlock-freedom and liveness between multiple
components in a realistic distributed system. Classic multiparty session type systems [27]
do not prevent any errors related to session cancellation. An aﬃne multiparty session type
system should (1) prevent inﬁnitely cascading errors, and (2) ensure deadlock-freedom and
liveness in the presence of session cancellations for arbitrary processes. Although there
are a few works on aﬃne session types, they are either binary [45, 21] or modelling a very
limited cancellation over a single communication action, and a general cancellation is not
supported [25] (see § 6.2, § D.1).

Challenge 2: Realising an aﬃne multiparty channel over binary channels. The
extension of binary session types to multiparty is usually not trivial. The theory assumes
multiparty channels, while channels, in practice, are binary. To preserve the global order
speciﬁed by a global protocol, also called the order of interactions, when implementing a
multiparty protocol over binary channels, existing works [28, 46, 51, 9] use code generation
from a global protocol to local APIs, requiring type-casts at runtime on the underlying
channels, compromising the type safety of the host type system. Implementing MPST with
failure becomes especially challenging given that cancellation messages should be correctly
propagated across multiple binary channels.

In this work, we overcome the above two challenges by presenting a new aﬃne multiparty
session types framework for Rust (AMPST). We present a shallow embedding of the theory
into Rust by developing a library for safe communication, MultiCrusty. The library utilises
a new communication data structure, aﬃne meshed channels, which stores multiple binary
channels without compromising type safety. A macro operation for exception handling safely
propagates failure across all in-scope channels. We leverage an existing binary session types
library, Rust’s macros facilities, and optional types to ensure that communication programs
written with MultiCrusty are correct-by-construction.

Our implementation brings three insightful contributions: (1) multiparty communication
safety can be realised by the native Rust type system (without external validation tools); (2)

N. Lagaillardie, R. Neykova and N. Yoshida

1:3

(a) MultiCrusty Workﬂow (top-down)

(b) Video streaming service usecase

Figure 1 Programming with multiparty session types

top-down and bottom-up approaches can co-exist; (3) Rust’s destructor mechanism can be
utilised to propagate session cancellation. All other works generate not only the types but
also the communication primitives for multiparty channels which are protocol-speciﬁc. The
crucial idea underpinning the novelty of our implementation is that one can pre-generate the
possible communication actions without having the global protocol; and then use the types
to limit the set of permitted actions. Without this realisation neither (1), nor (2) is possible.

Paper Summary and Contributions:

§ 2 outlines the gains of programming with aﬃne meshed channels by introducing our running

example, a Video streaming service, and its Rust implementation using MultiCrusty.

§ 3 establishes the metatheory of AMPST. We present a core multiparty session π-calculus
with session delegation and recursion, together with new constructs for exception handling,
and aﬃne selection and branching (from Rust optional types). The calculus enjoys session-
ﬁdelity (Theorem 3.18), deadlock-freedom (Theorem 3.20), liveness (Theorem 3.21), and
a novel cancellation termination property (Theorem 3.27).

§ 4 describes the main challenges of embedding AMPST in Rust, and the design and implement-
ation of MultiCrusty, a library for safe multiparty communication Rust programming.
§ 5 evaluates the execution and compilation overhead of MultiCrusty. Microbenchmarks
show negligible overhead when compared with the built-in unsafe Rust channels, provided
by crossbeam-channel, and up to two-fold runtime improvement to a binary session
types library on protocols with high-degree of synchronisation. We have implemented,
using MultiCrusty, examples from the literature, and application protocols (see [39]).

Additionally, § 6 discusses related works and § 7 concludes. Appendix includes the proofs
of our theorems (§ A) and additional technical details of MultiCrusty (§ B). Our library is
available in this public library: https://github.com/NicolasLagaillardie/mpst_rust_
github/. An ECOOP artifact is also available.

2 Overview: aﬃne multiparty session types (AMPST) in Rust

Framework overview: AMPST in Rust Figure 1a depicts the overall design of MultiCrusty.
Our design combines the top-down [27] and bottom-up [40] methodologies of multiparty
session types in a single framework.

The top-down approach enables correctness-by-construction and requires that a developer
speciﬁes a global type (hereafter a global protocol) describing the communication behaviour of

E C O O P 2 0 2 2

Top-down approachGlobal types in ScribbleLocal types\CFSMprojectBottom-up approachCFSM are (in)compatibleCFSMRust typesPrograms written with MultiCrusty APIgeneraterewriteType checkingk-MC checkClientAuthenticatorServeraltRequestVidRequestVidSendVidSendVidCloseClose1:4

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1
2

1
2
3
4
5
6
7

8
9
10
11
12
13
14

15
16
17

// generates at compile-time communication primitives for 3-party affine meshed channels
gen_mpst!(MeshedChannelsThree, A, C, S);

fn client(

s: RecC<i32>,
i: i32
) -> R {
if (i<MAX) {
let s = choose_c!(s,
ChoiceA::Video, ChoiceS::

Video)

let n = get_video(i);
let s = s.send(n)?;
let (_,s) = s.recv()?;
client(s, i+1)
} else {
let s = choose_c!(s,
ChoiceA::Close, ChoiceS::

Close);

s.close()
}

}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

fn auth(s: RecA<i32>)

-> R {
offer_mpst!(
s, {
ChoiceA::Video(s)
=> {
let (x,s) = s.recv()?;
let s = s.send(x)?;
let (x,s) = s.recv()?;
let s = s.send(x)?;
auth(s)
},
ChoiceA::Close(s)
=> {
s.close()
} }
)

}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

fn server(s: RecS<i32>)

-> R {
offer_mpst!(
s, {
ChoiceS::Video(s)
=> {
let v = attempt!{{

let (x, s) = s.recv()?;
let f = get_file(x);
read_video_file(f)

} catch (e) {
cancel(s);
panic!("Err: {:?}", e)

} }()?;
let s = s.send(x)?;
server(s)}
ChoiceS::Close(s)
=> {s.close()

} } ) }

(a) role C

(b) role A

(c) role S

a!ReqVideo

a?ResVideo

a
!
c
l
o
s
e

c?ReqVideo

s!ReqVideo

c
?
c
l
o
s
e

c!ResVideo

s!close

a?ReqVideo

a!ResVideo

s
?
R
e
s
V
d
e
o

i

a
?
c
l
o
s
e

Figure 2 Rust implementations and respective CFSMs of role C (a), role A (b) and role S (c)

the program. We utilise the Scribble toolchain [54] for writing and verifying global protocols.
The toolchain projects local types for each role in a protocol. We have augmented the
toolchain to further generate those local types into Rust types, i.e., types that stipulate the
behaviour of communication channels.

On the other hand, the bottom-up approach requires a developer to only implement the
concurrent programs and their respective types, the types are then checked for compatibility.
We leverage a recent bounded model checking tool for communicating ﬁnite state machines.
In essence, we translate the Rust types written by the developer to communicating ﬁnite
state machines (CFSMs) and invoke the k-MC tool [41] which checks if the two types are
compatible, i.e., if their execution may lead to safety errors, or in other words, no thread
gets permanently stuck and all sent messages are eventually received.

Finally, our Rust API (MultiCrusty API) integrates both approaches, as illustrated
in Figure 1a. Developers can choose to either (1) write the global protocol and have the Rust
types generated, or (2) write the Rust types manually and check that the types are compatible.
Note that both approaches rely on concurrent programs written with MultiCrusty API, and
both approaches rely on the Rust compiler to type check the concurrent programs against their
respective types. Overall, the framework guarantees that well-typed concurrent programs
implemented using MultiCrusty API with Scribble-generated types or k-MC-compatible
types, will be free from deadlocks, reception errors, and protocol deviations.

The main primitives of MultiCrusty API are summarised in Table 1. Next, we brieﬂy

explain them through an example. A more detailed explanation is provided in § 4.

N. Lagaillardie, R. Neykova and N. Yoshida

1:5

2.1 Example: Video streaming service

The Video streaming service is a usecase that can take full advantage of aﬃne multiparty
session types and demonstrate the need for multiparty channels with cancellation. Each
streaming application connects to servers, and possibly other devices, to access services and
follows a speciﬁc protocol. To present our design, we use a simpliﬁed version of the protocol,
omitting the authentication part, illustrated in the diagram of Figure 1b. The diagram
should be read from top to bottom. The protocol involves three services – an Authenticator
(role A) service, a Server (role S) and a Client (role C ). The protocol starts with a choice on
the Client to either request a video or end the session. The ﬁrst branch is, a priori, the main
service provided, i.e., request for a video. The Client cannot directly request videos from
the Server and has to go through the Authenticator instead. On the diagram, the choice is
denoted as the frame alt and the choices are separated by the horizontal dotted line. The
protocol is recursive, and the Client can request new videos as many times as needed. This
recursive behaviour is represented by the arrow going back on the Client side in Figure 1b.
To end the session, the Client ﬁrst sends a Close message to the Authenticator, which then
subsequently sends a Close message to the Server.

Aﬃne meshed channels and multiparty session programming with MultiCrusty
The implementations in MultiCrusty of the three roles are given in Figure 2. They closely
follow the behaviour that is prescribed by the protocol. The global protocol does not explicitly
specify cancellation. However, in a distributed setting, timeout or failure can happen at
any time: a request from a CDN network or cloud storage to the server might be a timeout
or the result message might be lost. Our implementation accounts for failure by providing
communication primitives for two diﬀerent types of session cancellation, called implicit and
explicit: either we run a block of code and upon any error at any point, we go to the catch
branch, or we explicitly test each step. They are displayed in Figure 7 and the detailed
diﬀerence between both is explained later.

The implementation of the three concurrent programs starts by generating all com-
munication primitives for aﬃne channels between three roles. This is done by the macro
gen_mpst!(MeshedChannelsThree, A, C, S), see line 2 in Figure 2. The macro gen_mpst!
takes two kinds of arguments: the name of the data structure for aﬃne meshed channels,
MeshedChannelsThree, and the name for each role, A, C and S. MeshedChannelsThree is a
string literal that must be supplied by the developer, any name can be chosen. In our
case, gen_mpst! will generate a data structure called MeshedChannelsThree that can be used
for communication between three participants. In our example, three roles are provided, but
the macro can handle any number of roles. Then, using the Rust procedural macro system, it
generates communication primitives for programming between aﬃne meshed channels. This
generation is done at compile time. For instance, the primitive s.send(p) sends a payload p
on an aﬃne meshed channel s. Note that we do not have to explicitly specify the destination
channel, this is determined from the type: the stack speciﬁes which binary channel can
be used, regardless of the type of those binary channels. See Figure 15 for an example of
MeshedChannels.

To explain aﬃne meshed channels and all MultiCrusty communication primitives, we
focus on the implementation for role A given in Figure 2b. The implementations of the
other roles are similar. First, line 1 declares an auth(s) function that is parametric on an
aﬃne meshed channel s of type RecA<i32>, the result type of the function is irrelevant to our
explanation, hence we have simply denoted it by R. The type RecA<i32>, an alias for the full
type described in Figure 15, speciﬁes the operations allowed on s. As mentioned previously,
this type can be either written by the developer or generated by Scribble. We defer the

E C O O P 2 0 2 2

1:6

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

explanation of the (generated) types to § 4, i.e., the full Rust type is given in Figure 15. For
clarity, here we only give a high-level view of the behaviour for each channel by representing
its respective local session types as a communicating ﬁnite state machine (CFSM [5]), where
! (resp. ?) denotes sending (resp. receiving). The CFSMs for each role (channel) can be
seen in Figure 2. For example, c!ResVideo means that role A is receiving from the role C a
message labelled as Video, while s!ReqVideo says that role A sends a message to role S.

The thread for role A uses an aﬃne meshed channel s to implement the given CFSM
behaviour. In essence, the meshed channel is implemented as an indexed tuple of binary
channels – one binary channel for each pair of interacting processes, i.e., a binary channel
for role A and role S and a binary channel for role A and role C .

The implementation starts by realising a choice: role C broadcasts its choice, which
can either be to request a video at line 7 or to close the connection at line 14 (Figure 2a).
Role C broadcasts the choice to every other role. This can be seen in Figure 14, lines 19
and 20, where the choose_c! macro encapsulates two sends of the new branch, one for
each other participant. This choice is received by role A, which will either receive a Video
or a Close label. This behaviour is implemented by the MultiCrusty macro offer_mpst!
(line 3), which is applied to a multiparty channel s and a sum type, either ChoiceA::Video or
ChoiceA::Close here. The behaviour of each branch in the protocol is implemented as an
anonymous function. For example, the code in lines 5 – 12 supplies such a function that
implements the behaviour when role C sends a Video label, while lines 13 – 16 handle the
Close request. At each step, the channel s is rebound to a new meshed channel s returned by
the respective communication primitive. For example, the communication primitive recv()
at line 7 is for receiving a value on the binary channel between role A and role C that is
stored in the meshed channel s. Note that this is the only primitive available for that type at
that point. This communication primitive, if everything goes right, returns a tuple containing
the received value and the new meshed channel to be used for subsequent communications
which are bound resp. to the variable x and s. An error is returned instead of the tuple if
the reception of the value fails. Similarly, send(x) in line 8 sends the value x to the process
that implements the role S and rebinds the new meshed channel to s. Finally, because the
protocol is recursive, line 11 calls the recursive function auth(s).

Alternatively, the anonymous function for branch Close calls the primitive close() which
safely and cleanly closes all binary channels stored inside the aﬃne meshed channel s. This
last primitive ensures that the type of all the binary channels of s is Close End: the only
primitive implemented for such meshed channels is close(). Forgetting either s.close() or
auth(s) at the end of their respective branch will throw an error during compilation because
the output type of the auth(s) function will be the wrong one. All communication functions
used in the example (i.e., s.recv(), s.send(), s.close(), offer_mpst!) are generated for all
roles and all possible interactions through the macro gen_mpst!, see line 2.

The types of the aﬃne meshed channels, as well as the generic types in the declaration
of the MultiCrusty communication functions, enable compile-time detection of protocol
violations. Examples of protocol violations include swapping lines 10 and 9, using another
communication primitive or using the wrong payload type. The Rust type system, on the
other hand, ensures that all aﬃne channels are used at most once. For example, using channel
s twice (without rebinding) will be detected by the compiler. All the errors mentioned above
will be reported as compile-time errors. In the case that an unexpected runtime error occurs,
all roles are guaranteed to terminate safely. This is ensured by two mechanisms – explicit
session cancellation (that can be triggered by the user) and implicit session cancellation (that
is embedded in the MultiCrusty primitives and the channel destructors).

N. Lagaillardie, R. Neykova and N. Yoshida

1:7

Table 1 Primitives provided by MultiCrusty. s is an aﬃne meshed channel; p is a payload of a
given type; I is a subset of all roles in the protocol but the current role; K is a subset of all branches;

Primitives

let s = s.send(p)?;

let (p, s) = s.recv()?;

s.close()

attempt! {{ ... } catch(e) { ... }}

offer_mpst!(s, { enumi :: variantk(e) => {...}k∈K } )

choose!(s, {enumi :: variantk}i∈I )

Description
Sends a payload p on a channel s and assigns the continuation
of the session (a new meshed channel) to a new variable s.
Receives a payload p on channel s and assigns the continuation
of the session to a new variable s.
Closes the channel s and returns a unit type.
Attempts to run the ﬁrst block of code and, upon error, catches
the error in the variable e and runs the second block of code.
Role i receives a message label on channel s, and,
depending on the label value which should match
one of the variants variantk of enumi, runs the related block of code.
Sends the chosen label, which corresponds to variantk,
to all other roles.

Implicit and explicit cancellations The processes of role A and role S illustrate resp.
implicit and explicit cancellations. The primitive cancel(s) drops the aﬃne meshed channel
s, and its binary channels, making it inaccessible to other participants. This is convenient
when an error related to the computation aspects of the program occurs. For example,
In Figure 2c the session is cancelled in line 12 after an error occurs as a result of reading
a corrupted video. We have used the attempt!{ { ... } catch(e) { ... } } macro (Rust
version of a try-catch block) in lines 7 to 14 to catch the error message, and explicitly cancel
the session. The macro tries to go through the attempt-block of code, and upon any error in
this block, stops the process and calls the catch(e)-block with the error message e. Line 13
executes a panic!, which allows a program to terminate immediately and provide feedback to
the caller of the program. Forgetting to call cancel(s) before panic! will result in the same
outcome as when both cancel(s) and panic! drop s. Forgetting both will throw an error
because the output type will not match the one of fn server(s), unless replaced with an
Ok(()). In any cases, an error will be thrown on other threads linked to other roles because
role S’s sessions are inaccessible in the catch(e)-block.

Alternatively, we explain implicit cancellation as implemented by role A in Figure 2b.
The construct let x = f()?, as seen in line 7, is Rust’s monadic bind notation for programs
and functions that may return errors: their usual output type is Result<T, Error> where
T is the expected type if everything goes right and Error is the error type returned. For
any program and function returning such type, the users have to unwrap it. The two usual
ways of doing so are by using the ?-operator, or by pattern matching on the result using
match. In our case, if recv() succeeds, the ?-operator unpacks the result and returns the
tuple containing the received payload and the continuation. If recv() fails, the ?-operator
short-circuits, skips the rest of the statements, and returns the error. We use this mechanism
to catch any session cancellation. In the case that a recv() (or send()) does not succeed,
the implementation of the underlying communication primitive will cancel the channel and
broadcast the cancellation to all other binary channels that are part of the session.

Finally, we look at the implementation of role C to demonstrate the ﬁnal mechanism of
session cancellation. For this purpose, we have to comment out lines 9 – 11 in Figure 2a
or replace them with a panic! as to simulate a wrongly implemented role C . With such
modiﬁcation, this function will still compile despite the protocol not being fully implemented
(since the last received action from role A is missing, the meshed channel s will be dropped
prematurely). Even in this case, MultiCrusty ensures that all processes will terminate safely,
i.e., all parties are notiﬁed that an aﬃne channel has been dropped. Prematurely dropping a
channel can happen due to incorrectly implemented behaviour (as we demonstrated above),

E C O O P 2 0 2 2

1:8

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

or by unhandled user error, for example, the function get_video() in line 8 can invoke a
panic! because there is no video associated with the index i. Safe session termination is
realised by customising the native destructor Drop in Rust, as proposed for binary meshed
channels by [36]. When an aﬃne meshed channel goes out of scope, the channel destructor is
called, the session is cancelled, dropping every channel value used in the session, and only
then is the memory deallocated.

Memory management should not pose a problem in our case. Our library uses only the
safe fragment of Rust. This ensures that variables that are out of scope are automatically
collected. We utilise this mechanism to ensure that closed and cancelled channels are collected
in the same way. Hence, memory leaks are ruled out.

In short, a session can be cancelled for three reasons: (1) an error aﬀecting the computation
aspects of the program, as in Figure 2c; (2) an error during communication, e.g., a timeout
on a channel, as in Figure 2b; or (3) a premature drop of the aﬃne meshed channel due to
incorrect implementation, as in Figure 2a. Our mechanisms for session cancellation cover all
the above cases. In this way, our framework provides aﬃne multiparty session compliance by
ensuring that (1) if all results are returned without failure, the processes follow the given
Scribble global protocol (Theorem 3.18) or (2) once a cancellation happens, all processes in
the same session terminate with an error (Theorem 3.27). We have proven the above results
by formalising aﬃne meshed channels in an extension of a multiparty π-calculus.

3

Aﬃne multiparty session processes for Rust programming

3.1 Aﬃne multiparty session processes

Our calculus (AMPST) is an extension of a full multiparty session π-calculus [53] which
includes session delegation (channel passing) and session recursion. We shade additions
to [53] in this colour .

(cid:73) Deﬁnition 3.1. The aﬃne multiparty session π-calculus (AMPST) is deﬁned as
follows:

c, d ::= x (cid:12)
P , Q ::= 0 (cid:12)

(cid:12) ?

† ::= ∅ (cid:12)
(cid:12) (νs) P

(cid:12) s[p]
(cid:12) P | Q (cid:12)
? c[q]⊕mhdi.P (cid:12)
(cid:12) ? c[q]P
c[q]⊕mhdi.P (cid:12)
c[q]P
(cid:12)
def D in P (cid:12)
(cid:12) Xheci
try P catch Q (cid:12)

i∈I mi(xi).Pi
i∈I mi(xi).Pi

(cid:12) cancel(c).P (cid:12)

(cid:12) s

(cid:32)

D ::= X(ex) = P

(variable, channel with role p, error, ﬂag)

(inaction, composition, restriction)

(aﬃne selection, branching I 6= ∅)

(selection, branching I 6= ∅)

(process deﬁnition, process call)

(catch, cancel, kill)

(declaration of process variable X)

A set P denotes participants: P = {p, q, r, . . . }, and A is a set of alphabets. A channel
c can be either a variable or a channel with role s[p], i.e., a multiparty communication
endpoint whose user plays role p in the session s. ec denotes a vector c1c2 . . . cn (n ≥ 1) and
similarly for ex and es.

The two processes with ? model the option ?-operator in Rust. Process ? c[q]⊕mhdi.P
performs an aﬃne selection (internal choice) towards role q, using the channel c: if the
message label m with the payload channel d is successfully sent, then the execution continues
as P ; otherwise (if the receiver has failed or timeout), it triggers an exception. The aﬃne
branching (external choice) ? c[q]P
i∈I mi(xi).Pi uses channel c to wait for a message
from role q:
if a message label mk with payload d is received (for some k ∈ I), then the
execution continues as P k, with xk replaced by d; if not received, it triggers an exception.

N. Lagaillardie, R. Neykova and N. Yoshida

1:9

Note that message labels mi are pairwise distinct and their order is irrelevant, and variable
xi is bound with scope P i.

The following two failure handling processes follow the program behaviour of Figure 2c.
The try-catch process, try P catch Q, consists of a try process P which is ready to
communicate with parallel composed one; and a catch process Q which becomes active when
a cancellation or an error happens. The cancel process, cancel(c).P , cancels other processes
kills all processes with session s and is
whose communication channel is c. The kill s
generated only at runtime from aﬃne or cancel processes.

(cid:32)

The other syntax is from [53]. The inaction 0 represents a terminated process (and is
often omitted). The parallel composition P | Q represents two processes that can execute
concurrently, and potentially communicate. The session restriction (νs) P declares a
new session s with a scope limited to process P . The linear selection and the linear
branching can be understood as their aﬃne versions but without failure handling. Process
deﬁnition, def X(ex) = P in Q and process call Xheci model recursion: the call invokes
X by expanding it into P , and replacing its formal parameters with the actual ones.
Linear or aﬃne branching and selection are denoted as either † c[q]P

i∈I mi(xi).Pi
and † c[q]⊕mhdi.P . We use fv(P ) / fc(P ) and dpv(P ) / fpv(P ) to denote free vari-
ables/channels and bound/free process variables of P . We call a process P such that
fv(P ) = fpv(P ) = ∅ closed. A set of subjects of P , written sbj(P ), is deﬁned as: sbj(0) = ∅;
sbj(P | Q) = sbj(P ) ∪ sbj(Q); sbj((νs) P ) = sbj(P ) \ {s[pi]}i∈I ; sbj(cid:0)† c[q]P
(cid:1) =
sbj(† c[q]⊕mhdi.P ) = {c}; sbj(def X(ex) = P in Q) = sbj(Q)∪sbj(P )\{˜x} with sbj(Xheci) =
sbj(P {˜c/˜x}); sbj(try P catch Q) = sbj(P ); and sbj(cancel(c).P ) = {c}.

i∈I mi(xi).Pi

The set of subjects is the key deﬁnition which enables us to deﬁne the typing system for

the try-catch process with recursive behaviours.

(cid:73) Example 3.2 (Subjects of processes). Assume R1 = def X(x) = x[q]⊕mhdi.0 in Xhci
which repeats the action at c and emits a message d with label repeatedly interacting with
the dual input (but reduction with this process only happens if there is a corresponding
input at c, i.e., on-demand). We calculate sbj(R1) as:

sbj(def X(x) = x[q]⊕mhdi.0 in Xhci) = sbj(Xhci) ∪ sbj(def Xhxi = x[q]⊕mhdi.0)
= sbj(Xhci) = sbj((x[q]⊕mhdi.0){c/x}) = {c}

Another example is: sbj(try x[q]⊕mhdi.0 catch cancel(x[q]).0) = sbj(x[q]⊕mhdi.0) = {x}.

(cid:73) Remark 3.3 (Syntax and semantics). AMPST extends MPST incorporating some design
choices from [45], aiming to distil the implementation essence of MultiCrusty. The design
of our try-catch process follows the binary aﬃne session types in [45], but models more
cancellations for arbitrary processes with aﬃne branchings/selections and cancel processes
non-deterministically (whose semantics follow the implementation behaviours, see § 4.4). We
list the essential diﬀerences from [45]. (1) (Nondeterministic failures) The kill process is a
runtime syntax and generated only during reductions unlike [45]. Our calculus also allows
nondeterministic failures caused by either (1) aﬃne selection/branching or (2) try-catch
processes. See Example 3.6. (2) (Recursion parameterised by linear names) One of the
novelties of our formalism which is not found in [45] is a combination of session recursions,
aﬃnity, and interleaved sessions, i.e., the def agents (linearly parameterised recursions), which
are the most technical part when designing the typing system with try-catch processes. The
combination of all features is absent from [45, 21, 25]: see § 6 for more detailed comparisons.

E C O O P 2 0 2 2

1:10

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

[R-Com]

[C-?Sel]

[T?Sel]

[C-Sel]

[C-?Br]

[T?Br]

[C-Br]

[R-Can]

E1[† s[p][q]P

i∈I mi(xi).Pi] | E2[† s[q][p]⊕mkhs0[r]i.Q] → Pk

(cid:8)s0[r]/xk

(cid:9) | Q if k ∈ I

? s[p][q]⊕mhs0[r]i.P → s[p][q]⊕mhs0[r]i.P | s

(cid:32)

try ? s[p][q]⊕mhs0[r]i.P catch Q → Q | s

(cid:32)

→ P | s

| s0
(cid:32)
i∈I mi(xi).Pi → s[p][q]P

s[p][q]⊕mhs0[r]i.P | s
? s[p][q]P
try ? s[p][q]P

(cid:32)

(cid:32)
i∈I mi(xi).Pi | s
(cid:32)

s[p][q]P

i∈I mi(xi).Pi | s
(cid:32)
| Q

E[cancel(s[p]).Q] → s

i∈I mi(xi).Pi catch Q → Q | s
(cid:32)
(cid:9) | s0
(cid:8)s0[r]/xk

→ (νs0) (Pk

) | s

(cid:32)
[C-Cat] try P catch Q | s

(cid:32)

(cid:32)
[R-Def] def X(x1, . . . , xn) = P in (Xhs1[p1], . . . , sn[pn]i | Q)

s0 6∈ fc(Pk) , k ∈ I

→ Q | s

(cid:32)

∃r. s[r] = sbj(P )

(cid:32)

→ def X(x1, .., xn) = P in (P {s1[p1]/x1} · ·{sn[pn]/xn} | Q)

[R-Ctx] P → P 0

implies C[P ] → C[P 0]

[R-Struct] P ≡ P 0 → Q0 ≡ Q implies P → Q

Figure

3

AMPST π-calculus

reduction

between

closed

processes

(we

high-

light the new rules from [53]) Additional rules can be found in our Appendix Figure 10.

(cid:73) Deﬁnition 3.4 (Semantics). A try-catch context E is: E ::= try E catch P (cid:12)
(cid:12) [ ] and
a reduction context C is: C ::= (νs) C (cid:12)
(cid:12) [ ]. Reduction
→ is inductively deﬁned in Figure 3, which uses the structural congruence ≡ which is
deﬁned by s

≡ 0 together with other rules in [53].

(cid:12) def D in C (cid:12)

(cid:12) C | P (cid:12)

(cid:12) P | C (cid:12)

and (νs) s

≡ s

| s

(cid:32)

(cid:32)

(cid:32)

(cid:32)

(cid:73) Remark 3.5 (Nested try-catches and E ). The context E is only used for deﬁning the
reductions at the top parallel composed processes, not used nested exception handling like
[21, 25]. Our (typable) try-catch processes allow any form of processes such as recursions,
parallel, session delegations, and restriction/scope opened processes under a guarded process:
R = try s[p][r]⊕m1 .(νs0) (s[p][r]⊕m3hs0[r]i.0 | try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0)

catch cancel(s[p]).0

See Example A.1 for typable processes with nested try-catch blocks.

Numerous examples about nested try-catch processes and their type derivation can be

found in our Appendix§ A.1.

We explain each rule highlighting the new rules.

Communication Rule [R-Com] is the main communication rule between an aﬃne/linear
selection and an aﬃne/linear branching. Linear selections/branching are placed in the
try position but can interact with aﬃne counterparts. Once they interact, processes are
spawned from try-blocks (notice that E1, E2 are erased after the communication), and
start communicating on parallel with other parallel composed processes. Note that the
context E is discarded after the successful communication. See Example 3.6.

Error-Cancellation Rules [C-?Sel] and [C-?Br] model the situations that an error handling
occurs at the aﬃne selection/branching. This might be the case if its counterpart has
failed (hence [R-Com] does not happen) or timeout. It then triggers the kill process at
s. Rules [T?Sel] and [T?Br] model the case that the aﬃne selection/branching are placed
inside the try-block and triggered by the error. In this case, it will go to the catch-block,
generating a kill process.

Cancelling Processes Rule [C-Sel] cancels the selection preﬁx s, additionally generating the
kill process at the delegated channel for all the session processes at s0 to be cancelled.

N. Lagaillardie, R. Neykova and N. Yoshida

1:11

Rule [C-Br] cancels only one of the branches – this is suﬃcient since all branches contain
the same channels except xi (ensured by rule [T-&] in Figure 4). After the cancellation, it
additionally instantiates a fresh name s0[r] to xk into Pk. The generated kill process at
s0 kills preﬁxes at s0[r] in Pk{s0[r]/xk}.

Cancellation from Other Parties Rule [R-Can] is a cancellation and generates a kill process.
Note that the try-catch context E is thrown away. Rule [C-Cat] is prompted to move to
. The side condition sbj(P ) ensures that P is a preﬁx at s (up to ≡ for a
Q by kill s
recursive process). All mimic the behaviour of the programs in Figure 2c.

(cid:32)

Other Rules Rules [R-Def], [R-Ctx], and [R-Struct] are standard from [53]. In Figure 3, the two

new rules are for garbage collections of kill processes.

(cid:73) Example 3.6 (Syntax and reductions). A process might be completed, or cancelled in many
ways, and also interacts non-deterministically. We demonstrate the reduction rules using
the running example with a minor modiﬁcation. We use a nested try-catch block, and for
simplicity we use shorter label names, and we use a constant, i.e., d, as a message payload.

Assume the process for role S is P = ? s[p][q](Q+close(x).0) where

Q = video(x). try ? s[p][q]req(x).try ? s[p][r]⊕reshdi.0 catch cancel(s[p]).0 catch cancel(s[p]).0
The following shows a possible reduction.

P | s[q][p]⊕videohdi.s[q][p]⊕reqhdi.s[q][p]res(x).0

[R-Com] →

try (? s[p][q]req(x).try (? s[p][r]⊕reshdi.0) catch cancel(s[p]).0)

catch cancel(s[p]).0

| s[q][p]⊕reqhdi.s[q][p]res(x).0

[R-Com] → try ? s[p][r]⊕reshdi.0 catch cancel(s[p]).0 | s[q][p]res(x).0

[T?Sel] → cancel(s[p]).0 | s

| s[q][p]res(x).0

(cid:32)
| 0 | s[q][p]res(x).0

[R-Can] →s

[C-Br] →s

| s

| s

(cid:32)

(cid:32)

(cid:32)

(cid:32)

| 0 | 0 ≡ s

(cid:32)

(1)

(2)

(3)

(4)

(5)

(6)

(7)

E6[P6] for Equation (1) is P6 = ? s[p][q]req(x).try ... catch cancel(s[p]).0 and E9[P9]

for Equation (4) is P9 = ? s[p][r]⊕reshdi.0 both because of rule [C-Cat].

Initially we reduce using the communication rule for the branching and selection. Next,
we apply [R-Com] demonstrating how the aﬃne branching reduces under try. Then we apply
[T?Sel] assuming an error (or a timeout) occurs during the selection of res. This generates
and spawns the process in the catch-block. Cancel spawns a kill process
a kill process s
| 0, following rule [R-Can] with E = [ ]. Finally, applying [R-Can]
s
(cid:32)
cancels the linear selection. To conclude, we garbage collect all kill processes. Given that
our initial parallel composition has name restrictions (νs) at the top level, (omitted from
the reduction for convenience), we have (νs) s

(cid:32)
and hence reduces to s

≡ 0.

(cid:32)

(cid:32)

|s0

(cid:32)
= R by rule [C-?Sel], then s[p][q]⊕mhs0[r]i.P | s

(cid:73) Example 3.7 ( Rules [C-?Sel]/[C-Sel] and [C-?Br]/[C-Br] ). We can obtain the reduction
, by ﬁrst deriving ? s[p][q]⊕mhs0[r]i.P → s[p][q]⊕mhs0[r]i.P |
? s[p][q]⊕mhs0[r]i.P →∗ P |s
s
by rule [C-Sel]. Suppose
(cid:32)
and can fail
R | Q and Q contains some preﬁx at s. Then Q can receive a signal from s
before an action from 14 to 15. However, this decomposition into two rules allows C[R]
to interact with other processes in the context C before generating s0
, capturing a time
diﬀerence (nondeterministic failures/asynchrony).

→ P | s

| s0

(cid:32)

(cid:32)

(cid:32)

(cid:32)

(cid:32)

(cid:32)

E C O O P 2 0 2 2

1:12

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

3.2 Aﬃne multiparty session typing system

Global and local types The advantage of aﬃne session frameworks is that no change of
the syntax of types from the original system is required. We follow [53] which is the most
widely used syntax in the literature. A global type, written G, G0, . . . , describes the whole
conversation scenario of a multiparty session as a type signature, and a local type, written by
S, S0, . . . , represents a local protocol for each participant. The syntax of types is given as:

(cid:73) Deﬁnition 3.8 (Global types). The syntax of a global type G is:

G ::= p→q: {mi(Si).Gi}i∈I

(cid:12) µt.G (cid:12)
(cid:12)

(cid:12) t (cid:12)

(cid:12) end

with p 6= q, I 6= ∅, and ∀i ∈ I : fv(Si) = ∅

The syntax of local types is:

S, T ::= p&i∈I mi(Si).S0
i

(cid:12)
(cid:12) p⊕i∈I mi(Si).S0
i
Types must be closed, and recursion variables to be guarded.

(cid:12) µt.S (cid:12)

(cid:12) end (cid:12)
(cid:12)

(cid:12) t with I 6= ∅, and mi pairwise distinct.

m ∈ A corresponds to the usual message labels in the session type theory. Global branching
type p→q: {mi(Si).Gi}i∈I states that participant p can send a message with one of the mi
labels and a message payload type Si to the participant q and that interaction described in
Gi follows. We require p 6= q to prevent self-sent messages and mi 6= mk for all i 6= k ∈ J.
Recursive types µt.G are for recursive protocols, assuming those type variables (t, t0, . . . )
are guarded in the standard way, i.e., they only occur under branching. Type end represents
session termination (often omitted). We write p ∈ roles(G) (or simply p ∈ G) iﬀ, for some
q, either p→q or q→p occurs in G. The function id(G) gives the participants of G.

For local types, the branching type p&i∈I mi(Si).S0

i speciﬁes the reception of a message
from p with a label among the mi and a payload Si. The selection type p⊕i∈I mi(Si).S0
i is its
dual – its opposite operation. The remaining type constructors are as for global types. We
say a type is guarded if it is neither a recursive type nor a type variable.

Projection The relation between global and local types is formalised by projection [11, 27].

(cid:73) Deﬁnition 3.9 (Projection). The projection of G onto p (written G(cid:22)p) is deﬁned as:



(q→r: {mi(Si).Gi}i∈I )(cid:22)p =

r⊕i∈I mi(Si).(Gi(cid:22)p)
q&i∈I mi(Si).(Gi(cid:22)p)
(cid:100)i∈I Gi(cid:22)p



if p = q
if p = r
if q 6= p 6= r

(µt.G)(cid:22)p =

(cid:26) µt.(G(cid:22)p)
end

if p ∈ G or fv(µt.G) 6= ∅
otherwise

t(cid:22)p = t

end(cid:22)p = end

For projection of branching, we introduce a merge operator along the lines of [14], written
S u S0, ensuring that if the locally observable behaviour of the local type is dependent of the
chosen branch then it is identiﬁable via a unique choice/branching label.

The merging operation u is deﬁned as a partial commutative operator over two types

such that:
p&i∈I mi(Si).S0
p⊕i∈I mi(Si).S0

i u p&j∈J mj(Sj).T 0
i u p⊕i∈I mi(Si).S0

j = p&k∈I∩J mk(Sk).(S0
i = p⊕i∈I mi(Si).S0
i

k) & p&i∈I\J mi(Si).S0
k uT 0
µt.S u µt.T = µt.(S u T )

i & p&j∈J\I mj(Sj).T 0
j
T u T = T

As an example of projection, consider µt.A→B: {a.B→C: {b.A→C: {c.t}}, d.B→C: {e.A→C: {f.end}}}.
Then C’s local type is given by: µt.B&{b.A&c.t, e.A&f.end}. We say that G is well-formed
if for all p ∈ P, G(cid:22)p is deﬁned. We also use the standard multiparty session subtyping
relation from [23, 16].

(cid:73) Deﬁnition 3.10 (Subtyping). The subtyping relation (cid:54) is coinductively deﬁned as:

N. Lagaillardie, R. Neykova and N. Yoshida

1:13

∀i ∈ I Si (cid:54) Ti S0

i (cid:54) T 0
i

p&i∈I mi(Si).S0

[Sub-&]

i (cid:54) p&i∈I∪J mi(Ti).T 0
i
S{µt.S/t} (cid:54) T
µt.S (cid:54) T

[Sub-end]

end (cid:54) end

∀i ∈ I Ti (cid:54) Si S0

i (cid:54) T 0
i
i (cid:54) p⊕i∈I mi(Ti).T 0
i

p⊕i∈I∪J mi(Si).S0

[Sub-⊕]

[Sub-µL]

S (cid:54) T {µt.T/t}
S (cid:54) µt.T

[Sub-µR]

We deﬁne typing contexts which are used to deﬁne properties of type-level behaviours.

(cid:73) Deﬁnition 3.11 (Typing contexts). Θ denotes a partial mapping from process variables to
n-tuples of types, and Γ denotes a partial mapping from channels to types, deﬁned as:

Θ ::= ∅ (cid:12)

(cid:12) Θ, X:S1, . . . , Sn

Γ ::= ∅ (cid:12)

(cid:12) Γ, c:S

The composition Γ1, Γ2 is deﬁned iﬀ dom(Γ1) ∩ dom(Γ2) = ∅. We write s 6∈ Γ iﬀ ∀p : s[p] 6∈
dom(Γ) (i.e., session s does not occur in Γ).We write dom(Γ) = {s} iﬀ ∀c ∈ dom(Γ) there
is p such that c = s[p] (i.e., Γ only contains session s); and Γ (cid:54) Γ0 iﬀ dom(Γ) = dom(Γ0) and
∀c ∈ dom(Γ): Γ(c) (cid:54) Γ0(c).

Next, we deﬁne typing context properties deﬁned by its reduction.

(cid:73) Deﬁnition 3.12 ( Typing context reduction, safety, deadlock-freedom and liveness ).

i, s[q]:T 0

j and Γ0 =
We write Γ → Γ0 with Γ = Γ0, s[p]:q⊕i∈I mi(Si).S0
Γ0, s[p]:S0
j where types are deﬁned modulo unfolding recursive types. We write
Γ →∗ Γ0 for a transitive and reﬂexive closure of →; and Γ → if there exists Γ0 such that
Γ → Γ0.
ϕ is a safety property of typing contexts iﬀ:
[S-⊕&] ϕ(cid:0)Γ, s[p]:q⊕i∈I mi(Si).S0

i, s[q]:p&j∈J mj(Tj).T 0

(cid:1) implies

I ⊆ J , and ∀i ∈ I : Si (cid:54) Ti;

[S-µ] ϕ(Γ, s[p]:µt.S)
[S-→] ϕ(Γ) and Γ → Γ0

i, s[q]:p&j∈J mj(Tj).T 0
j
implies ϕ(Γ, s[p]:S{µt.S/t});

implies ϕ(Γ0).

We say Γ is safe, written safe(Γ), if ϕ(Γ) for some safety property ϕ.
Γ is deadlock-free, written df(Γ), if Γ →∗ Γ0 6→ implies
Γ is live, written live(Γ), iﬀ:ϕ(Γ), for some ϕ such that
[L-&] whenever ϕ(Γ0, s[p]:S) with S = q&i∈I mi(Si).S0
[L-⊕] whenever ϕ(Γ0, s[p]:S) with S = q⊕i∈I mi(Si).S0

end(Γ0).

i, ∃i ∈ I: ∃Γ00: Γ0, s[p]:S →∗ Γ00, s[p]:S0
i
i, ∀i ∈ I: ∃Γ00: Γ0, s[p]:S →∗

Γ00, s[p]:S0
i
plus clauses [S-µ] and [S-→].
Γ is live+, written live+(Γ), iﬀ:ϕ(Γ), for ϕ such that
[L-&+] clause [L-&] above; moreover, Γ0, s[p]:S belongs to some fair traversal set X with
i (for some

targets Y ([53, Deﬁnition 5.5]) such that, ∀Γt ∈ Y, we have Γt = Γ00, s[p]:S0
Γ00, i ∈ I)

[L-⊕+] clause [L-⊕] above, plus the “moreover. . . ” part of [L-&+]

plus clauses [S-µ] and [S-→].

We omit the deﬁnition of fair traversal set from [53, Deﬁnition 5.5] (it needs to be deﬁned
by the transition system of the typing context). The reader can refer to [53] for more
explanations of the typing context properties.

(cid:73) Deﬁnition 3.13 (Typing judgement). The typing judgement for processes has the form:

Θ · Γ ‘ P (with Θ/Γ omitted when empty)

(8)

and are deﬁned by the typing rules in Figure 4 with the judgements for process variables
and channels. For convenience, we type-annotate channels bound by process deﬁnitions and
restrictions. Note that end(Γ) denotes that Γ only contains type end.

E C O O P 2 0 2 2

1:14

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

Θ(X) = S1, . . . , Sn
Θ ‘ X :S1, . . . , Sn

[T-X]

S (cid:54) S0
c:S ‘ c:S0

[T-sub]

∀i ∈ 1..n ci :Si ‘ ci :end
end(c1 :S1, . . . , cn :Sn)

[T-end]

end(Γ)
Θ · Γ ‘ 0

[T-0]

Γ1 ‘ c:q&i∈I mi(Si).S0

i ∀i ∈ I Θ · Γ, yi :Si, c:S0

i ‘ Pi

Θ · Γ, Γ1 ‘ † c[q]P

i∈I mi(yi).Pi

[T-&] Θ · Γ1 ‘ P1

Θ · Γ2 ‘ P2

Θ · Γ1, Γ2 ‘ P1 | P2

[T-|]

Γ1 ‘ c:q⊕m(S).S0 Γ2 ‘ c0 :S Θ · Γ, c:S0 ‘ P

[T-⊕]

Θ · Γ, Γ1, Γ2 ‘ † c[q]⊕mhc0i.P

Θ · Γ ‘ P

sbj(P ) = {c}

Θ · Γ ‘ Q

Θ · Γ ‘ try P catch Q

[ T-try ]

end(Γ)

0 ≤ n

Θ · Γ ‘ Q

Θ · Γ, s[p1]:S1, . . . , s[pn]:Sn ‘ s

(cid:32)

[ T-kill ]

[ T-cancel ]

Θ · Γ, c:S ‘ cancel(c).Q

Θ, X:S1, . . . , Sn · x1 :S1, . . . , xn :Sn ‘ P

Θ, X:S1, . . . , Sn · Γ ‘ Q

Θ · Γ ‘ def X(x1 :S1, . . . , xn :Sn) = P in Q

[T-def]

Θ ‘ X :S1, . . . , Sn

end(Γ0) ∀i ∈ 1..n Γi ‘ ci :Si

Θ · Γ0, Γ1, . . . , Γn ‘ Xhc1, . . . , cni

Γ0 = {s[p]:Sp}p∈I

s 6∈ Γ safe(Γ0) Θ · Γ, Γ0 ‘ P

Θ · Γ ‘ (νs:Γ0) P

[T-call]

[T-ν]

Γ0 = {s[p]:G(cid:22)p}p∈roles(G) or end(Γ0)
Θ · Γ ‘ (νs:Γ0) P

s 6∈ Γ Θ · Γ, Γ0 ‘ P

[ T-init ]

Figure 4 Multiparty session typing rules. We highlight the new rules from [53].

We explain each rule highlighting the new rules from [53].

(Aﬃne) Branching/Selection [T-&] and [T-⊕] are the standard rules for branching and se-
lection, which can also type aﬃne branching and selection. Note that the premise Γ
in Θ · Γ, yi :Si, c:S0
i ‘ Pi in [T-&] ensures that selecting one branch in the reduction rule
deﬁned by [C-Br] is suﬃcient for ensuring type soundness.

Try-Catch and Cancellation [T-try] is typing a try process: we ensure P has a unique subject
and catch block process Q has the same session typing (similar with branching). [T-cancel]
generates a kill process at its declared session.

Kill process [T-kill] types a kill process that appears during reductions: the cancellation of

s[p] is broadcasting the cancellation to all processes which belong to session s.

Recursions [T-def] and [T-call] are identical to those of [53].
Restriction Processes are initially typed projecting a global type by [T-init], while running

processes are typed by [T-ν] (see the proof of Theorem 3.16).

(cid:73) Example 3.14 (Typing AMPST processes). To demonstrate the typing rules we type
the inner try process from the reduction example. Let Q = try R catch cancel(s[p]).0
where R = ? s[p][r]⊕reshdi.0 and d is of type S1 = end. We show that Γ ‘ Q where
Γ = d:S1, s[p]:S2 with S2 = r⊕res(S1).end.

s[p]:S2 ‘ s[p]:S2

d:S1 ‘ d:S1

. . .
s[p]:end ‘ 0

Γ ‘ ? s[p][r]⊕reshdi.0

[T-0]

[T-⊕]

sbj(R) = {s[p]}

Γ ‘ Q

. . .
d:S1 ‘ 0
Γ ‘ cancel(s[p]).0

[T-0]

[T-cancel]

[T-try]

N. Lagaillardie, R. Neykova and N. Yoshida

1:15

3.3 Properties of aﬃne multiparty session types

This subsection proves the main properties of AMPST processes. We ﬁrst prove basic
properties such as Subject Congruence and Reduction Theorems, then prove important
properties, session ﬁdelity, deadlock-freedom and liveness. The highlight is cancellation
termination, which guarantees that once an exceptional behaviour is triggered, all parties in
a single session can terminate as nil processes.

Unlike linear-logic based typing systems [45], we do not assume that the typing system is
closed modulo ≡. Instead, we prove closedness of ≡ for tricky cases, e.g., kill and try-catches.

(cid:73) Theorem 3.15 (Subject Congruence). If Θ · Γ ‘ Q and Q ≡ P , then we have Θ · Γ ‘ P .

By Theorem 3.15, AMPST processes satisfy type soundness.

(cid:73) Theorem 3.16 (Subject Reduction). Suppose Θ · Γ ‘ P and Γ safe. Then, P → P 0 implies
there exists Γ0 such that Γ0 is safe and Γ →∗ Γ0 and Θ · Γ0 ‘ P 0.

Proof. See Appendix A. While the syntax of types stays the same as [53], the proof needs
(cid:74)
extra care due to reduction semantics not presented in [53].

A single agent in a multiparty session s is a participant playing a single role p in s. We
use the deﬁnition from [53] except the highlighted part, which now includes aﬃne processes.

(cid:73) Deﬁnition 3.17 (A unique role process). Assume ∅ · Γ ‘ P . We say that P :

1. has

guarded

deﬁnitions

def X(x1 :S1, . . . , xn :Sn) = Q in P 0,
call Y h. . . , xi, . . .i can only occur in Q as subterm of

in

iﬀ
for all i ∈ 1..n, Si

each

subterm

of

the

form
6(cid:54) end implies that a
† xi[q]P
or
j∈J mj(yj).Pj

† xi[q]⊕mhci.P 00 (i.e., after using xi for selection/branching);

2. only plays role p in s, by Γ,

iﬀ:

iii) Γ = Γ0, s[p]:S with S 6(cid:54) end and end(Γ0);
we have Γ0 = s0[p0]:end (for some p0).

i) P has guarded deﬁnitions;

ii) fv(P ) = ∅;
iv) in all subterms (νs0 :Γ0) P 0 of P ,

We say “P only plays role p in s” iﬀ ∃Γ : ∅·Γ ‘ P , and item 2 holds.

Note that by deﬁnition, a unique role process in s includes s
Session ﬁdelity is an important property to ensure liveness and deadlock-freedom, as
well as termination. We extend that in [53] by taking a kill process into account. A set of
unique role processes of a single multiparty session, together with kill processes always make
progress if a typing context has progress, satisfying a protocol compliance.

(cid:32)

.

Below we write Q

if Q contains only a parallel composition of kill processes.

(cid:32)

(cid:73) Theorem 3.18 (Session Fidelity). Assume ∅·Γ ‘ P , where Γ is safe, P ≡ (cid:12)
, and
(cid:12)p∈I Pp | Q
(cid:32)
Γ = S
. Assume that
p∈I Γp ∪ Γ0 such that, for each Pp, we have ∅· Γp ‘ Pp; and ∅· Γ0 ‘ Q
(cid:32)
each Pp is either Pp ≡ 0, or only plays p in s, by Γp. Then, Γ→ implies ∃Γ0, P 0 such that
Γ → Γ0, P →∗ P 0 and ∅·Γ0 ‘ P 0, with Γ0 safe, P 0 ≡ (cid:12)
, and Γ0 = S
(cid:12)p∈I P 0
p ∪ Γ0
0
(cid:32)
such that, for each P 0
p, and each P 0
p, we have ∅· Γ0
p is either 0, or only plays p in s, by
p; and ∅· Γ0
Γ0
.
(cid:32)

p∈I Γ0

p ‘ P 0

0 ‘ Q0

p | Q0

By the above theorem, we can prove deadlock-freedom and liveness for a single session

multiparty session in the presence of aﬃne processes.

(cid:73) Deﬁnition 3.19 (Deadlock-freedom and liveness).

E C O O P 2 0 2 2

1:16

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1. P is deadlock-free iﬀ P →∗ P 0 6 → implies P 0 ≡ 0.
2. P is live iﬀ P →∗ P 0 ≡ C[Q] implies: i) if Q = c[q]⊕mhs0[r]i.Q0 (for some m, s0, r, Q0),
i), then

i (for some mi, xi, Q0

then ∃C0: P 0 →∗ C0[Q0]; and ii) if Q = c[q]P
∃C0, k ∈ I, s0, r: P 0 →∗ C0[Q0

i∈I mi(xi).Q0

k{s0[r]/xk}].

Note that liveness is deﬁned for linear selection or linear branching processes which
appear at the top level, i.e., under the reduction context C , not under try-catch construct,
cancel nor aﬃne branching and selection processes.
(cid:73) Theorem 3.20 (Deadlock-freedom). Assume ∅ · Γ ‘ P , with Γ safe, P ≡ (cid:12)
(cid:12)p∈I Pp, each
Pp either Pp ≡ 0, or only playing role p in s. Then, df(Γ) implies that (ν˜s:Γ) P with
{˜s} = dom(Γ) is deadlock-free.

Proof. We use Theorem 3.18. See Appendix A.

(cid:74)

As discussed in [53, Deﬁnition 5.11], we require live+(Γ) for proving liveness.

(cid:73) Theorem 3.21 (Liveness). Assume ∅ · Γ ‘ P , with Γ safe, P ≡ (cid:12)
Pp ≡ 0, or only playing role p in s. Then,

live+(Γ) implies that P is live.

(cid:12)p∈I Pp, each Pp either

Proof. We use Theorem 3.18. See Appendix A.

(cid:74)

Now we consider a user-written Rust program with one session as an initial program.

(cid:73) Deﬁnition 3.22 (Initial program). We say ‘ Q is an initial program if
1. Q ≡ (ν˜s:Γ) (cid:12)
2. Pp only plays p in s;
3. in each subterm of the form, def X(ex) = Q in P 0, (1) Q is of the form try Q0 catch P 00;

(cid:12)p∈GPp with {˜s} = dom(Γ);

and (2) P 00 does not contain any (free or bound) process call.

4. Γ = {s[p]:G(cid:22)p}p∈G, Γ0 for some G and end(Γ0);
5. ‘ Q is derived using [T-init] instead of [T-ν]; and without [T-kill].

Condition (3) ensures that once a process moves to the catch-block, then it ensures ﬁnite

computation; (4,5) state that the initial program starts conforming to a global protocol.
(cid:73) Remark 3.23 (Initial processes). Condition (3) does not limit the expressiveness since the
try-block can include inﬁnite computations; and conditions (4,5) imply that an initial program
typed by condition (1) has started. Notice that running (runtime) processes generated from
the initial program are typed using [T-ν] and [T-kill]; hence the proof of the subject reduction
holds with Lemma 3.24 below.

Before proving the main theorems, we state that a set of local types projected from a

well-formed global type satisfy the safety property.

(cid:73) Lemma 3.24 ([53, Lemma 5.9]). Let Γ = {s[p]:G(cid:22)p}p∈roles(G). Then safe(Γ), df(Γ) and
live+(Γ).

Now we state the two main theorems of this paper: deadlock-freedom, liveness and
cancellation termination. The cancellation termination theorem states that once a kill signal
is produced by cancellation or aﬃne processes (due to a timeout or an error), then all
processes are enabled to terminate. We start from deadlock-freedom.

(cid:73) Corollary 3.25 (Deadlock-freedom for an initial program). Suppose ‘ Q is an initial program.
Then for all P such that Q →∗ P , P is deadlock-free.

N. Lagaillardie, R. Neykova and N. Yoshida

Proof. By Theorem 3.20 and Lemma 3.24.

1:17

(cid:74)

(cid:73) Corollary 3.26 (Liveness for an initial program). Suppose ‘ Q is an initial program. Then
for all P such that Q →∗ P , P is live.

Proof. By Theorem 3.21 and Lemma 3.24.

(cid:74)

(cid:73) Theorem 3.27 (Cancellation Termination). Suppose ‘ Q is an initial program. If Q →∗
C[s

] = P 0, then we have P 0 →∗ 0.

(cid:32)

Proof. See Appendix A. We use Corollary 3.25.

(cid:74)

(cid:73) Corollary 3.28 (Cancellation Termination of Aﬃne and Cancel Processes). Suppose ‘ Q is
an initial program.

1. If Q →∗ C[cancel(s[p]).Q0] = P 0, then we have P 0 →∗ 0.
2. If Q →∗ C[E[? s[p][q]P
we have P 0 →∗ 0.

i∈I mi(xi).Pi]] = P 0 or Q →∗ C[E[? s[p][q]⊕mhs0[r]i.P ]] = P 0, then

Proof. By [C-?Sel], [T?Sel], [C-?Br], [T?Br], and [R-Can], we have P 0 → C0[s
Theorem 3.27.

]. Then we apply
(cid:74)

(cid:32)

(cid:73) Remark 3.29 (Termination theorem). The cancellation termination theorem means that
there always exists a path which leads to 0; and an initial program might not terminate even
if it contains a process with s
. This diﬀers from the total termination, i.e., all paths are
ﬁnite – a program will deﬁnitely stop as 0. However, if we apply fair traversal sets, i.e., fair
scheduling, from [53, Deﬁnition 5.5], applying to processes in C[s
], we can prove the total
termination. Since these extensions require an introduction of labelled transition systems for
processes, we leave it as future work.

(cid:32)

(cid:32)

4 Design and implementation of MultiCrusty

4.1 Challenges for the implementation of MultiCrusty

The three main challenges underpinning the implementation of AMPST in Rust are related
to multiparty communications and ensuring correctness for aﬃne channels.

(Challenge 1) Realising a multiparty channel by binary channels. AMPST
relies on a multiparty channel – a channel that can communicate with several roles. In
Rust, communication channels are peer-to-peer, e.g., they are binary [36]. To overcome this
limitation, we extend an encoding of MPST into binary channels [51]. In this encoding,
a multiparty channel can be represented as an indexed tuple of one-shot binary channels
used in a sequence depending on the ordering speciﬁed by the type. This design ensures
reception error safety by construction. Since each pair of binary channels is dual, then no
communication mismatch can occur. We piggyback on this result by introducing meshed
channels, which reuse an existing library of binary session types in Rust [36] with built-in
duality guarantees. We explain the implementation of meshed channels in § 4.2. notably
distributed logging (Figure 16), and circuit breaker (Figure 17).

(Challenge 2) Deadlock-freedom, liveness and termination. Duality is unfor-
tunately insuﬃcient to guarantee deadlock-freedom. The naive decomposition of binary
channels leads to hard to detect deadlock errors [51]. To ensure liveness properties and correct

E C O O P 2 0 2 2

1:18

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1
2

pub struct MeshedChannels< S1: Session, S2: Session, R: Role, N: Role> {
pub session1: S1, pub session2: S, pub stack: R, pub name: N }

Figure 5 Generated MeshedChannles structure.

termination of cancellation behaviour, we integrate MultiCrusty with two state-of-the-art
veriﬁcation toolchains – Scribble [33] and k-MC [41], that ensures meshed channel types are
correct. The former generates correct meshed channel types in Rust, while the latter veriﬁes
a set of existing meshed channel types. In both cases, well-typed processes implemented
using well-typed meshed channels are free from deadlocks, orphan messages and reception
errors. We display the Rust types for our running example in § B.3.

(Challenge 3) Aﬃnity with try-catch and optional types. Rust does not have
a native try-catch construct, but macros and optional types. We use them to design and
implement a try-catch block and aﬃne selection and branching. Channels can be implicitly
or explicitly cancelled, and all processes are guaranteed to terminate gracefully in the event
of a cancellation, avoiding endless cascading errors. We discuss our design choices in § 4.4.

4.2 Meshed Channels in MultiCrusty

A multiparty channel in MultiCrusty is realised as an aﬃne meshed channel (hereafter
meshed channel), which has three ingredients: (1) a list of separate binary channels (one
binary channel for each pair of participants); (2) a stack that imposes the ordering between
the binary channels; and (3) the name of the role, whose behaviour is implemented by the
meshed channel. For example, a meshed channel for a 3-party protocol can be generated using
the macro gen_mpst!(MeshedChannels, A, C, S): the name of the structure (MeshedChannels),
and the three roles involved in the communication (A, C, S). Figure 5 shows the generated
structure.

The generated structure, MeshedChannels, holds four ﬁelds. The ﬁrst two ﬁelds, session1
and session2, are of type Session which is a binary session type. Therefore, these ﬁelds store
binary channels. Session in Rust is a trait and a trait is similar to an interface. The Session
trait can be instantiated to three generic (binary session) types: an End type; a Recv<T, S> or
a Send<T, S> type, with their respective payload of type T and their continuation of a binary
session type S. This has important implications for the design and safety of our system.
Since all pairs of binary channels are created and distributed across meshed channels at the
start of the protocol, the binary type Session enforces that each pair of binary channels
are dual. For example, the binary channel for role S inside the meshed channels for role
A; and the binary channel for role A inside the meshed channels for role S are dual. This
design ensures that, without using any external tools, our system is communication safe, no
reception error can occur. This is insuﬃcient to guarantee deadlock-freedom, which is why
we utilise Scribble or bounded model checking, i.e., k-MC, as an additional veriﬁcation step.
The rest of the ﬁelds of the struct MeshedChannels are stack-like structures, stack and
name, which represent respectively the order of the interactions (in what order the binary
channels should be used) and the associated role. For instance, the behaviour where role
A has to communicate ﬁrst with role S, then with role C and then the session ends, can
be speciﬁed using a stack of type RoleS<RoleC<RoleEnd>>. Note that all stack types such as
RoleS and RoleC are generated singleton types. Role names are codiﬁed as RoleX<RoleEnd>
where X is the actual name of the participant. For instance, role A is realised as the singleton
type RoleA<RoleEnd>. We chose this design for its readability and its ease of implementation:

N. Lagaillardie, R. Neykova and N. Yoshida

1:19

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

// Declare the name of the role
type NameA = RoleA<RoleEnd>;

// Binary session types for A and C
type AtoCVideo<N> = Recv<N, Send<N, Recv<ChoiceA<N>, End>>

// Binary session types for A and S
type AtoSVideo<N> = Send<N, Recv<N, End>>;

// Declare usage order of binary channels inside a meshed channel
type StackAInit = RoleC<RoleEnd>; // for the initial meshed channel
type StackAVideo = RoleC<RoleS<RoleS<RoleC<RoleEnd>>>>; // for branch Video

// Declare the type of the meshed channel
type RecA<N> = MeshedChannels<Recv<ChoiceA<N>, End>, End, StackAInit, NameA>;

// Declare an enum with variants corresponding to the different branches, \ie Video and End
enum ChoiceA<N> {

Video(MeshedChannels<AtoCVideo<N>, AtoSVideo<N>, StackAVideo, NameA>),
Close(MeshedChannels<End, End, RoleEnd, NameA>)

}

Figure 6 Local Rust types for role A (Authenticator) from Figure 2b

one can guess at a glance the current state of a participant.

The code generation macro gen_mpst! produces meshed channels for any ﬁnite number of
communicating processes. For example, in the case of a protocol with four roles, the macro
gen_mpst! will generate a meshed channel with ﬁve ﬁelds – one ﬁeld for the binary session
between each pair of participants (which is 3 ﬁelds in total), one ﬁeld for the stack and one
ﬁeld for the name of the role that is being implemented.

4.3 Types for aﬃne meshed channels

Meshed channel types – MeshedChannels – correspond to local session types. They describe
the behaviour of each meshed channel and specify which communication primitives are
permitted on a meshed channel. To better illustrate meshed channel types, we explain the
type RecA<N> for role A (Authenticator) from Figure 2b. The types are displayed in Figure 15.
The types of the meshed channels for the other roles, i.e., C and S are available in Figures 12
and 13 of the Appendix.

Meshed channels consist of (1) binary channels, (2) a stack that stipulates the order of
interactions and (3) the name of the related role. We explain how to declare each of these
below.

Declaring meshed channel types Following the protocol, the ﬁrst action on A is an
external choice. Role A should receive a choice from role C of either Video or Close. External
choice is realised in MultiCrusty as an enum with a variant for each branch, where each
variant is parameterised on the meshed channel that will be used for that branch. Hence, the
type for the meshed channel for A must specify that A must ﬁrst receive one of the enum
variants and its corresponding meshed channel. Then, it should use the received meshed
channel to realise the interactions for each branch. This precise behaviour is captured by
the meshed channel type RecA<N> declared at line 15, see Figure 15. Note that, in Rust,
type RecA<N> declares a type alias, not a new type. Here, RecA<N> for a meshed channel
whose binary channel for S (the type Recv<ChoiceA<N>, End> stored at the ﬁrst position in
the meshed channel structure) is expected to receive the enum ChoiceA<N>.

The enum type ChoiceA<N> in line 18 declares two variants with their respective meshed
channels. The branch Close is trivial since no communication apart from closing all channels

E C O O P 2 0 2 2

1:20

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

is expected in this branch. Hence, the binary channels for S and A, and C and A are
all End. The type of the meshed channel for the branch Video in line 19 is more elaborate.
MeshedChannels<AtoCVideo<N>, AtoSVideo<N>, StackAVideo, NameA> speciﬁes that the type
of the binary channel for C and A is AtoCVideo<N>, the type of the binary channel for role
S and role A is AtoSVideo<N>, the stack of the meshed channel is StackAVideo. The last
argument speciﬁes that this is a meshed channel for role A.

Declaring meshed channel stacks First, let us recap the behaviour for role A in the
Video branch. Role A ﬁrst receives a request from C , then it forwards it to S, it waits to
receive the response from S, and ﬁnally sends it back to C . This sequence of interactions is
captured in the declaration of the stack StackAVideo in line 12. The declaration RoleC<RoleS
<RoleS<RoleC<RoleEnd>>>> speciﬁes the order in which binary channels must the used – ﬁrst
the binary channel with C , then with role S, then with S again, and ﬁnally with C .

Declaring binary session types Finally, we must declare the types for the binary channels
that role A must utilise for communication with role A and role C in the Video branch. The
binary type for role A and role C is type AtoCVideo<N> in line 5. Note that the keyword type
declares an alias, hence the AtoCVideo<N> is an alias for the binary channel type Recv<N, Send
<N, RecvChoiceA<N>>> which speciﬁes that the channel between S and C should be used for
receiving a payload N, then should return a continuation Send<N, Recv<ChoiceA<N>, End>>.
The continuation is another binary session type with capabilities for sending a payload N, and
returning a continuation Recv<ChoiceA<N>, End>. The type for the binary channel between
role A and role S in the Video branch is similar. We remind the reader that role A must
send a request and then wait to receive a response from role S. This is codiﬁed in the type
AtoSVideo<N>, declared in line 8. The type Send<N, Recv<N, End>> says the channel will ﬁrst
be used to send and then to receive.

With the above declarations, we are done specifying all behaviours in the branch Video

and the type declaration for the meshed channel for role A is complete.

Recursive types Note that none of the deﬁned stacks is recursive. Recursion is implicitly
speciﬁed on binary types, and each stack is only related to a MeshedChannels up to either
a choice or the end of the protocol. When a choice occurs, each participant adopts a new
MeshedChannels. To manually detect the recursion in the current protocol, one can see that
the type AtoCVideo, inside the enum ChoiceA, is sent through the variant Video of this enum.
The type AtoCVideo ends with a Recv<ChoiceA<N>, End>, meaning that, in this branch, role
A will receive this enum again, making this branch recursive.

Note also that we assume fair scheduling as in the theory. In the case of fair scheduling,
an inﬁnite reduction (after cancellation) cannot happen. At every remaining step for each
role, either it communicates with a non cancelled role and continues with the following steps
or communicates with a cancelled role and cancels itself. At the very end of the protocol,
the close() method sends and receives a unit type from and to every participant, meaning
that every participant will know, at one point, whether a participant has failed or not.

Top-down meets bottom-up The types described so far can be written either by the
developers and veriﬁed using an external tool, k-MC, or generated from a global protocol
written in Scribble. Reception error safety is ensured since the underlying MultiCrusty
library checks statically that all pairs of binary types are dual to each other. Deadlock-
freedom is ensured if meshed channel types are generated from Scribble or veriﬁed using
k-MC. Finally, if errors occur, our implementation ensures all processes in the same session
are safely terminated.

To use the Scribble tool, developers have to specify the global protocol in the protocol
description language Scribble. Examples of the global protocols written in Scribble are

N. Lagaillardie, R. Neykova and N. Yoshida

1:21

available in Figures 16a and 17a. Then, by running the Scribble toolchain on those protocols,
they can obtain a Rust ﬁle containing all meshed channel types needed to implement the
processes. An example of such generated types is provided in Figure 15. With this Rust ﬁle,
the developers can run the protocol by implementing the processes, such as the ones shown
in Figure 2.

To use the k-MC tool, developers have to write the types and use an MultiCrusty macro
that rewrites all Rust types to CFSMs and invokes the k-MC tool at compile time. However,
they do not have to write the implementation of the processes for the meshed channels,
such as the ones shown in Figure 2. The k-MC tool checks if the system of CFSMs are
k-multiparty compatible. In particular, k-MC performs a k-bounded execution of the set of
CFSM and checks if the system has the progress property (no role gets permanently stuck
in a receiving state) and the eventual reception property (all sent messages are eventually
received). It checks that in all system executions where each channel contains at most k
messages, these properties are respected. Note that well-formed global protocols correspond
to the class of 1-MC safe systems.

Hence, the two approaches (top-down and bottom-up) are complementary and can be
used interchangeably for 1-MC systems. Note, however, that k-MC (and hence MultiCrusty)
potentially allows implementing systems that are safe but cannot be expressed as a global
protocol. In this sense, using the bottom-up approach inherently permits more behaviours.
To stay close to the theory, we have restricted the execution of k-MC to only 1-MC systems,
but the developer can specify the bound as an argument if they wish to explicitly diverge
from the class of 1-MC systems. The bottom-up approach can also be used with other
implementations. The two approaches can also be combined: the types can be generated
from Scribble and then checked by k-MC. However, if the types are generated from Scribble,
they are guaranteed to be compatible, hence no k-MC-check is required. In that sense, the
user can choose if they wish to start from the local types (the types for each communication
channel) and check if they are compatible, or start from the global type (and generate the
types for each communication channel).

4.4 Exception and cancellation

Exception handling Rust does not have exceptions. Instead, it has the type Result<T
, E> for recoverable errors and the panic! macro that stops execution when the program
encounters an unrecoverable error. Result<T, E> is a variant type with two constructors:
Ok(T) and Err(E) where T and E are generic type parameters.

We leverage two mechanisms to implement the semantics presented in § 3, both of which
rely on the Result variant type: (1) the ? operator and (2) the attempt!-catch macro. The
? is syntactic sugar for error message propagation. More speciﬁcally, each communication
primitive is wrapped inside a Result type. For example, the return type of recv() is Result
<(T, S), Box<dyn Error>>. The call recv() on the multiparty channel s triggers the attempt
of the reception of a tuple containing a payload of type T and a continuation of type S.

If a peer tries to read a cancelled endpoint then an error message is returned. Therefore,
if an error occurs during receive due to, for example, the cancellation of the other end of
the channel, the ? operator stops the recv() function and returns an Err value to the calling
code. Then, the user can decide to handle the error or panic! and terminate the program.
Similarly, the attempt!-catch block is syntactic sugar that allows exception handling over
multiple communication actions. For instance, the attempt! M catch N reduces to its failing
clause N if an error occurs in any of the statements in M. The interested users can try the

E C O O P 2 0 2 2

1:22

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1
2
3
4
5
6

match s.recv() {
Ok((v, s)) => M
Err(e) => {cancel(s);
panic!("Error: {:?}", e)
}
}

1
2
3
4
5
6

attempt! {
s.recv();
get_video(); // Error
}} catch (e) {

... }

1
2
3
4
5
6

s.recv()?;
match get_video() {
Ok(v) => M;
Err(e) => {cancel(s);
panic!("Error: {:?}", e)
} }

(a) Explicit cancel by the library

(b) Implicit cancel during runtime

(c) Explicit cancel by the user

Figure 7 Examples for implicit and explicit cancellation of meshed channels

online Rust playground that demonstrates the implementation of attempt!-catch using the
and_then combinator [50]. The attempt! M catch N corresponds to the try-catch in § 3.

The implementation follows the behaviour formalised by the reduction rules in § 3. In
particular, it ensures that whenever an error happens, a session is cancelled (s
). We utilise
Rust drop mechanism. When a value in Rust goes out of scope, Rust automatically drops
it by calling its destructor: the Drop method. A variable that cannot be cloned, such as
a session s, is out scope when used in a function and not returned, such as when used in
the close() and cancel() functions. We have customised this method by implementing the
Drop trait, which explicitly calls cancel(). If an error occurs, and the meshed channel is
not explicitly cancelled, the meshed channel is implicitly cancelled from its destructor. In
the case of a panic!, the session s will be dropped, alongside all variables within the same
function, when panic! is called. Similarly to the theory, cancel(s) is not mandatory and can
be placed arbitrarily within the process. Calling cancel(s) is mostly used for expressiveness
and mock tests purposes, when a failure, without panic!, needs to be simulated.

(cid:32)

Session Cancellation We discuss all cases involving session cancellation below:

1. Implicit vs explicit cancellation Receiving on or closing disconnected sessions returns
an error. As a result of the error, the multiparty channel s is cancelled by our underlying
library, and all binary channels associated with s are disconnected. We call this an
implicit cancellation. This behaviour implements rules [C-?Sel] and [C-?Br]. Alternatively,
the user can also cancel the session explicitly.

2. Raising an exception An error occurs (1) as a result of a communication over a
closed/cancelled channel, (2) as a result of a timeout on a channel, or (3) in case of
an error in the user code. For example the function get_video() can return an error.
Then the user can decide to (1) cancel(s) the session, (2) silently drop the session, or
(3) proceed with the protocol. Even if the user does not explicitly call the cancel(s)
primitive, Rust runtime ensures that the meshed channel is always cancelled in the end.
3. Double cancellation If a peer tries to cancel a session s that is already cancelled from
another endpoint, then the cancellation is ignored. Note that in our semantics this
behaviour is modelled using the structural congruence rules, namely s

≡ s

| s

4. Cancel propagation When a session is cancelled, no communication action can be used
subsequently on that channel. The action cancel(s) cancels all binary channels that are
. When a peer
a part of the meshed channel, which precisely simulates the kill process s
attempts to receive on a channel, if either side of the channel is cancelled, the operation
returns an error, and the session in scope is dropped. This is exactly the behaviour for the
channels from the crossbeam-channel library, and we inherit and extend this behaviour
to our library. Since our receive happens on a binary channel, our extension ensures that
all other binary channels that are in scope, and the ones that are in the stack, are also
closed. Since these channels are closed, when other peers try to read from them, they
will also encounter an error, and will subsequently close their channels.

(cid:32)

(cid:32)

(cid:32)

.
(cid:32)

N. Lagaillardie, R. Neykova and N. Yoshida

1:23

5

Evaluations: benchmarks, expressiveness and case studies

We evaluate MultiCrusty in terms of run-time performance (§ 5.1), compilation time
(§ 5.1) and applications (§ 5.2, § C). Through this section, we demonstrate the applicabil-
ity of MultiCrusty and compare its performance with programs written in binary sessions
and untyped implementations (Bare) using crossbeam-channel. The purpose of the mi-
crobenchmarks is to demonstrate the best and worst-case scenarios for the implementation:
we have not considered performance as a primary consideration in the current implementation.
The results show that rewriting multirole protocols from binary channels to aﬃne meshed
channels can have a performance gain in addition to the safety guarantees provided by MPST.
In summary, MultiCrusty has only a negligible overhead when compared to the built-
in unsafe Rust channels, provided by crossbeam-channel, and up to two-fold runtime
improvement to binary sessions in protocols with high-degree of synchronisation. The source
ﬁles of the benchmarks and a script to reproduce the results are included in the artifact.

5.1 Performance

The goal of the microbenchmarks is two-fold. On one hand,
it provides assurance
that MultiCrusty does not incur signiﬁcant overhead when compared to alternative libraries.
The source of the runtime overhead of MultiCrusty can be attributed to: (1) the additional
data structures that are generated (see § 4.2); and (2) checks for cancellation (as outlined in
§ 4.4). We also evaluate the eﬃciency of MultiCrusty when implementing multiparty (as
opposed to binary) protocols. Multiparty protocols specify interaction dependencies between
multiple threads. It is well-understood that a naive decomposition of multiparty protocol to
a binary one (without preserving interaction dependencies) not only causes race conditions
and wrong results but also deadlocks [51]. One may mitigate this problem by utilising a
synchronisation mechanism, which is an oﬀ-the-shelf alternative to meshed channels. We
compare the performance of MultiCrusty and meshed channels to a binary-channels-only
implementation that uses thread-synchronisation.

We compare implementations, written using (1) MultiCrusty API (MPST) without
cancellation; (2) MultiCrusty API with cancellation (AMPST); (3) binary channels, follow-
ing [36] (BC); and (4) a Bare-Rust implementation (Bare) using untyped channels as provided
by the corresponding transport library crossbeam-channel. As a reminder, MultiCrusty
uses [36]’s channels (which are binary only and technically non-meshed), and [36]’s channels
use crossbeam-channel for actually sending and receiving payloads: the scaﬀolding of
all programs diﬀers only in the ﬁnal communication primitives used. In addition, the BC
implementations synchronise between threads when messages must be received in order.

Figure 8 shows simple visualisation, displayed for illustrative purpose, of the three
examples that we benchmark. Figure 9 reports the results on runtime performance, i.e., the
time to complete a protocol by the implemented endpoints in Rust, and compilation time,
i.e., the time to compile the implementations for all roles. We stress tested the library up to
20 participants but only show the results up to 10 participants for readability.

Setup: Our machine conﬁgurations are AMD OpteronTM Processor 6282 SE @ 1.30 GHz
with 32 cores/64 threads, 128 GB of RAM and 100 GB of HDD with Ubuntu 20.04, and with
the latest version available for Rustup (1.24.3) and the Rust cargo compiler (1.56.0). We use
criterion [35], a popular benchmark framework in Rust. We repeat each benchmark 10000
times and report the average execution time with a fairly narrow conﬁdence interval of 95%.

Ping-pong benchmark measures the execution time for completing a recursive protocol
between two roles repeatedly increasing the number of executions for request-response unit

E C O O P 2 0 2 2

1:24

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

name

ping-
pong

ring

full-
mesh

1
2
3
4
5

1
2
3
4
5
6
7

1
2
3
4
5

Scribble representation

rec loop {

ping() from A1 to A2;
pong() from A2 to A1;

loop }

rec loop {

ping() from A1 to A2;
ping() from A2 to A3;...
ping() from A1 to An;
pong() from An; to An−1;
pong() from A2 to A1;...

loop }

diagram

ping

A1

A2

pong

ping

ping

ping

A1

A2

A3

An

pong

pong

pong

rec loop {

ping() from A to B; pong() from B to A;
ping() from B to C; pong() from C to B;
ping() from A to C; pong() from C to A;

loop }

A

pong

ping

B

ping
pong

pong
ping

C

Figure 8 Protocols for Microbenchmarks

messages. Figure 9a displays the running time w.r.t. the number of iterations. This protocol
is binary, and this benchmark measures the pure overhead of MPST implementation. MPST
directly reuses the BC library, adding the structure MeshedChannels on top of it. Since
both implementations need the same number of threads, the benchmark compares only the
overhead of MeshedChannels. Both MPST and AMPST have a linear performance increase
compared to BC and Bare. MPST is about 2.5 times slower than BC and about 6.5 times
slower than Bare for 500 iterations.

Ring protocol, as seen in Figure 8, speciﬁes N roles, connected in a ring, sending one message
in a sequence. This example is sequential and stress tests the usage of numerous binary
channels in an MultiCrusty implementation. Figure 9b displays the running time w.r.t.
the number of participants. We measure the time to complete 100 rounds of a message
for an increasing number of roles. This benchmark demonstrates a worst-case scenario
for MultiCrusty since the MPST implementation requires N*N binary channels, hence N*N
interactions at most, meanwhile the other implementations only need 2*N binary channels.
MultiCrusty is increasingly slower than the other implementations following a quadratic
curve. All the implementations are running at the same speed for 2 participants; MPST
becomes almost 2 times slower than BC for 10 participants and almost 3.25 times slower for
20 participants. AMPST implementation has a negligible overhead compared to MPST.

Full-mesh benchmark measures the execution time for completing a recursive protocol
between N roles mutually exchanging the same message together: for every iteration, each
participant sends and receives once with every other participant. For simplicity, we show the
pattern in Figure 8 for three roles only. Figure 9c displays the running time w.r.t. the number
of participants. This is a best-case scenario protocol for MultiCrusty since the protocol
requires a lot of explicit synchronisation if implemented as a composition of binary protocols.
The slowdown of BC is explained by the diﬀerence of implementation and the management
of threads: the MultiCrusty needs only one thread for each participant, meanwhile for the
binary case, two threads per pair of interactions are required to ensure that the message
causalities are preserved. All implementations have similar running time for 2 participants
but MPST is about 2.3 times faster than BC, and about 11 times slower than Bare for 10
participants. The ﬁgure only displays the results for up to 10 participants, since this is

N. Lagaillardie, R. Neykova and N. Yoshida

1:25

(a)

(b)

(c)

(d)

(e)

Figure 9 Execution time (ms) for Ping-pong (a), Ring (b), Mesh (c) and compile time (s) for

Ring (d), Mesh (e)

suﬃcient to show the overhead trend. In practice, we measured for up to 20 participants.
For reference, at 20 participants, MPST is about 12 times slower than Bare and about 3.75
times faster than BC. As expected, AMPST has almost the same running time as MPST.

Results summary on execution time Overall, MultiCrusty is faster than the BC
implementation when there are numerous interactions and participants, thanks to the
encapsulation of each participant as a thread; the worst-case scenario for MultiCrusty is
for protocols with many participants but no causalities between them which results in a
slowdown when compared with BC. AMPST adds a negligible running time due to the simple
checking of the status of the binary channels.

Results summary on compilation time We also compare the compilation time of the
three protocols using cargo build. The results are presented in Figures 9d and 9e. As
expected, the more participants there are, the higher is the compilation time for MPST,
with up to 40% increase for the full-mesh protocol and only 11% for the ring protocol. We
omit the graph for the ping-pong protocol since the number of iterations does not aﬀect
compilation time and the number of generated types, hence the compilation stays constant
at 36.4s (MPST), 36.6s (AMPST), 36.1s (BC) and 36.3s (Bare).

The compilation time of BC and Bare are very close thanks to Rust’s features, a mechanism
to express conditional compilation and optional dependencies. This allows compiling only
speciﬁc parts of libraries, instead of the whole libraries, depending on the needs of each ﬁle.
For BC and Bare, we only compile MultiCrusty’s default features, meanwhile for MPST and
AMPST, we also compile the macros features, which include heavy blocks of code and new
dependencies for the creation of the new roles, meshed channels and associated functions.

5.2 Expressiveness

We demonstrate the expressiveness and applicability of MultiCrusty by implementing
protocols for a range of applications. We also draw the examples from the session types
literature, well-established application protocols (OAuth, SMTP), and distributed protocols
(logging, circuit breaker). Protocols with more than 5 participants are not considered since
having one global protocol with more participants can quickly become intractable in terms
of protocol logic and is considered bad practice. The global protocols and patterns in the
literature that have many participants are parameterised [9], participants can be grouped in
kinds having the same type. Thereby, this will avoid a combinatorial explosion.

Table 2 displays the examples and related metrics. In particular, we report compilation
time (Check./Comp./Rel.), execution time (Exec. Time), the number of lines of code (LoC)
for implementing all roles in MultiCrusty, the lines of code generated from Scribble (Gen

E C O O P 2 0 2 2

100200300400500#iterations03691215182124Time(ms)MPSTBinaryCrossbeamAMPST0250500#iterations081624Time(ms)246810#roles03060246810#roles060120180246810#roles353739Time(s)246810#roles3545551:26

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

Table 2 Selected examples from the literature

Example (Endpoint)

Three buyers [34]
Calculator [28]
Travel agency [30]
Simple voting [28]
Online wallet [48]
Fibonacci [28]
Video Streaming service (§ 2)
oAuth2 [48]
Distributed logging (§ C)
Circuit breaker (§ C)
SMTP [19]

Check./Comp./Rel./Exec. Time LoC Impl. Gen Types/All MP Rec
(cid:51)
(cid:55)
(cid:51)
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

26.7s / 37.1s / 81.3s / 568 µs
26.5s / 36.9s / 81.3s / 467 µs
26.5s / 37.6s / 84.8s / 8 ms
26.3s / 36.7s / 82.4s / 396 µs
26.4s / 37.8s / 84.4s / 759 µs
26.6s / 36.7s / 80.9s / 9 ms
26.3s / 37.4s / 83.0s / 11 ms
26.4s / 37.5s / 83.2s / 12 ms
26.5s / 36.8s / 82.6s / 5 ms
26.5s / 38.5s / 87.0s / 18 ms
26.4s / 41.1s / 97.3s / 5 ms

37 / 180
32 / 168
47 / 247
61 / 268
76 / 307
23 / 164
39 / 143
61 / 276
59 / 311
142 / 517
143 / 714

143
136
200
207
231
141
104
215
252
375
571

(cid:51)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)
(cid:55)
(cid:51)
(cid:55)

Types) and the total lines of code (All); the two following columns indicate whether the
protocol involves three participants or more (MP), and if the protocol is recursive (Rec).

We report three compilation times corresponding to the diﬀerent compilation options in
Rust – cargo check which only type checks the code without producing binaries, cargo
build which compiles the code with binaries and cargo build –release which, in addition,
optimises the compiled artifact. Each recursive protocol is built/checked 100 times, and we
display the average in the table. All protocols are type-checked within 27 seconds, while the
basic compilations range between 36s and 41s and the optimised compilations vary between
80s and 97s. Those results represent the longest time we can expect for the respective
build/check: Rust compilation is iterative, therefore, the usual compilation time should
be shorter. A 30 seconds pause is short enough to not break the ﬂow [62] of the mental
headspace focused on the current task. Building the binaries takes longer, because of two
heavy libraries used by MultiCrusty (tokio [57] and hyper [55]). The execution time of
the protocols is measured by implementing only the communication aspects of the protocol,
and orthogonal computation-related aspects are omitted. The execution time is the time to
complete all protocol interactions, and even for larger protocols, it is negligible.

Table 2 does not contain protocols with more than 5 distinct participants because, in
our experience, whenever more participants are needed, the protocol is parameterised [9].
We leave such extension for future investigation.

6

Related work

A vast amount of session types implementations based on theories exist, as detailed in the
recent surveys on language implementations [2] and tools [22]. We discuss closely related
works, focusing on (1) session types implementations in Rust (§ 6.1); (2) MPST top-down
implementations (including other programming languages) (§ 6.2); and (3) Aﬃne types and
exceptions/error handling in session types (§ D.1).

6.1 Session types implementations in Rust

Binary session types (BST) have been implemented in Rust by [33], [36] and [10], whereas,
[12] is the only implementation of multiparty session types in Rust.
to our best knowledge,
[33] implemented binary session types, following [26], while [36] based their library on
the EGV calculus by [21] (see § D.1). Both verify at compile-time that the behaviours of two
endpoint processes are dual, i.e., the processes are compatible. The latter library allows to

N. Lagaillardie, R. Neykova and N. Yoshida

1:27

write and check session typed communications, and supports exception handling constructs.
Rust originally did not support recursive types so [33] had to use de Bruijn indices to
encode recursive session types, while [36] uses Rust’s native recursive types but only handles
failure for recv() actions: according to [36], this is generally the case with asynchronous
implementations. This is because once an endpoint has received several messages, it makes
sense to cancel them at the receiver rather than the sender. In fact, raising an exception on
a send operation in an asynchronous calculus actually breaks conﬂuence.

The library by [33] relies on an older version of Rust, hence we build MultiCrusty on top
of [36]. Notice that we formalised AMPST guaranteeing the MPST properties of MultiCrusty
(such as deadlock-freedom, liveness and cancellation termination), which are not present in [36].
In addition, our benchmarks conﬁrmed that, in protocols where most of the participants
mutually communicate, MultiCrusty is up to two times faster than [36].

[10] introduces their library, Ferrite, that implements BST in Rust, adopting intuitionistic
logic-based typing [6]. The library ensures linear typing of channels, and includes a recently
shared name extension by [3], but cannot statically handle prematurely dropped channel
endpoints. Since Ferrite lacks an additional causal analysis for ensuring deadlock-freedom
by [4], deadlock-freedom and liveness among more than two participants are not guaranteed,
unlike MultiCrusty. Ferrite also lacks documentation and tests, making it hard to use.

[17] presents an implementation of a library for programming typestates in Rust. The
library ensures that Rust programs follow a typestate speciﬁcation. The tool, however, has
several limitations. Diﬀerently than other works on typestates (e.g., typestates in Java [37]),
[17] implements and veriﬁes only binary non-recursive protocols, without a static guarantee
that all branches are exhaustively implemented.

Note that all the above implementations are limited to binary and no formalism is

proposed in their papers (see Table 3).

[12] implements MPST using async and await primitives. Their main focus is a perform-
ance analysis of asynchronous message reordering and comparisons of their asynchronous
subtyping algorithm with existing tools, including the k-MC tool [41]. Their algorithm is a
sound approximation of the (undecidable) asynchronous subtyping relation [24], by which
their tool enables to check whether an unoptimised (projected from a global type) CFSM
and its optimised CFSM are under the subtyping relation or not. The main disadvantage
of [12] is that their library depends on external tools for checking not only deadlock-freedom,
but also communication-safety. Diﬀerently, MultiCrusty can guarantee dual compatibility
(inherited from [36]) in a multiparty protocol, based on our meshed channels implementation.
Unlike MultiCrusty, neither failure handling nor cancellation termination is implemented

or formalised in any of the above-mentioned works.

6.2 Multiparty session types implementations in other languages

We compare implementations of (top-down) MPST, ordered by date of publication, in Table 3,
focusing on statically typed languages: we exclude MPST implementations by runtime
monitoring such as Erlang [47] and Python [13].

The table is composed as follows, row by row:

Languages lists the programming languages introduced or used.
Mainstream language states if the language is broadly used among developers or not.
MPST top-down characterises the framework: Multiparty session types (MPST) or binary
session types (BST). If the implementation allows the user to write MPST global types, it
is called a top-down approach.

E C O O P 2 0 2 2

1:28

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

Table 3 MPST top-down implementations

[36, 33, 10]

[49]

[28, 29]

[38]

[51]

Rust

MPI-C

Java

Java

Scala

[46]

F#

(cid:51)

(cid:51)

[9]

Go

(cid:51)

(cid:51)

[32]

[44]

OCaml Typescript

(cid:51)

(cid:51)

(cid:51)

(cid:51)

[64]

F*

(cid:51)

(cid:51)

[25]

[61]

[12]

MultiCrusty

EnsembleS

Scala

Rust

Rust

(cid:55)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

Language
Mainstream
language
MPST
Top-Down
Linearity
check
Exhaustive
choices check

Formalism
Communication
safety
Deadlock
freedom
Liveness
Cancellation
termination

(cid:51)

(cid:55)

static

(cid:51)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

(cid:51)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

(cid:51)

dynamic

(cid:55)

types

4

4

(cid:55)

(cid:55)

(cid:51)

(cid:51)

(cid:55)

(cid:55)

FJ

(cid:51)

(cid:55)

(cid:55)

(cid:55)

dynamic

dynamic

dynamic

static

static

static

static

dynamic

static

static

(cid:51)

π-cal.

(cid:51)

(cid:51)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

types

π-cal.

types

types

π-cal.

π-cal.

types

π-cal.

4

4

(cid:55)

(cid:55)

(cid:55)•

(cid:55)

(cid:55)

(cid:55)

4

4

(cid:55)

(cid:55)

4

4

(cid:55)

(cid:55)

(cid:51)

(cid:51)•

(cid:55)

(cid:55)

(cid:51)

(cid:51)

(cid:55)

(cid:55)

4

4

(cid:55)

(cid:55)

(cid:51)

(cid:51)

(cid:51)

(cid:51)

Linearity checking describes whether the linear usage of channels is not checked, checked at

compile-time (static) or checked at runtime (dynamic).

Exhaustive choices check indicates whether the implementation can statically enforce the
correct handling of potential input types. (cid:55) denotes implementations that do not support
pattern-matching to carry out choices (branching) using switch statements on enum types.
Formalism deﬁnes the theoretical foundations of the implementations, such as (1) the end
point calculus (the π-calculus (noted as π-cal.) or FJ [31]); (2) the (global) types formalism
without any endpoint calculi (no typing system is given, and no subject reduction theorem
is proved); or (3) no formalism is given (no theory is developed).

Communication safety outlines the presence or the absence of session type-soundness demon-
stration. Four languages, marked as 4, provide the type safety only at type level. (cid:55)•
means that the theoretical formalism does not provide linear types, therefore only type
safety of base values is proved.

Deadlock-freedom is a property guaranteeing that all components are progressing or ul-
timately terminate (which correspond to deadlock-freedom in MPST). Four languages
marked by 4 proved deadlock-freedom only at the type level. (cid:51)• implies the absence of
a formal link with the local conﬁgurations reduced from the projection of a global type. 1
Liveness is a property which ensure that all actions are eventually communicated with other

parties (unless killed by an exception in the case of AMPST).

Cancellation termination: once a cancellation happens at one of the participants in a multi-
party protocol, the cancellation is propagated correctly, and all processes can terminate.
The Rust implementations in the ﬁrst column of Table 3 are included for reference.
Most of the MPST implementations [29, 51, 46, 9, 44, 64] follow the methodology given
by [28], which generates Java communicating APIs from Scribble [63, 54]. They exploit
the equivalence between local session types and ﬁnite state machines to generate session
types APIs for mainstream programming languages. [28, 29, 51, 46, 9] are not completely
static: they check linearity dynamically. MultiCrusty can check linearity using the built-in
[49, 46, 9] do not enforce exhaustive handling of input
aﬃnity type checking from Rust.
types; and [28, 29, 38] rely on runtime checks to correctly handle branching.

[44, 64] provide static checking using the call-back style API generation. MultiCrusty

1 [25] did not prove that any typing context reduced from a projection of a well-formed global type
satisﬁes a safety property (a statement corresponding to Lemma 3.24). Hence, deadlock-freedom is not
provided for processes initially typed by a given global type. Note that their typing contexts contain
new elements not found in those deﬁned in [29], which weakens the link with the top-down approach.

N. Lagaillardie, R. Neykova and N. Yoshida

1:29

uses a decomposition of AMPST to BST; in [51], MPST in Scala is implemented combining
binary channels on the top of the existing BST library from [52]. Unlike MultiCrusty, [51]
lacks static linearity check and uses a continuation-passing style translation from MPST into
linear types. [38] implements static type-checking of communication protocols by linking Java
classes and their respective typestate deﬁnitions generated from Scribble. Objects declaring
a typestate should be used linearly, but a linear usage of channels is not statically enforced.
All above implementations generate multiparty APIs from protocols. To our know-
ledge, [32] is the only type-level embedding of classic multiparty channels in a mainstream
language, OCaml. However, the library heavily relies on OCaml-speciﬁc parametric poly-
morphism for variant types to ensure type-safety. Their formalism lacks linear types and
deadlock-freedom is not formalised nor proved. In addition, this implementation uses a non-
trivial, complicated encoding of polymorphic variant types and lenses, while MultiCrusty
uses the built-in aﬃne type system in Rust.

The work most closely related to ours is [25] which implements handling of dynamic
environments by MPST with explicit connections from [29], where actors can dynamically
connect and disconnect. It relies on the actor-like research language, Ensemble; and generates
endpoint code from Scribble. Their core calculus includes a syntax of the try L catch M
construction where M is evaluated if L raises an exception. The type system follows [59], and
is not as expressive as the previous paper on binary exception handling [21] that extends
the richer type system of GV [43, 42]. Due to this limitation of their base typing system,
and since their main focus is adaptation, there are several diﬀerences from AMPST, listed
below: (1) they do not model general failure of multiple (interleaved) session endpoints (such
as failures of selection and branching constructs as shown in rules [C-Sel], [C-Br]); (2) their
try-catch scope (handler) is limited to a single action unlike AMPST and [21] where its scope
can be an arbitrary process P , participants and session endpoints ([R-Cat]); (3) they do not
model any Rust speciﬁc ?-options where an arbitrary process P can self-fail ([T-try], [C-?Sel]);
and (4) their kill process is weaker than ours (it is point-to-point, it does not broadcast the
failure notiﬁcation to the same session).

As a consequence, their progress result ([21, Theorem 18]) is weaker than our theorems
since their conﬁguration can be stuck with an exception process that contains raise, while
our termination theorem (Theorem 3.27) guarantees that there always exists a path such that
the process will move or terminate as 0, cleaning up all intermediate processes which interact
non-deterministically. More precisely, in [21, Theorem 18], a cancellation in a session is
propagated, but raise blocks a reduction when the actor is not involved in a session, and its
behaviour is also stop, meaning it is terminated. Otherwise, the actor will leave the session
and restart. In contrast, MultiCrusty ensures the strong progress properties by construction
(see § 2). We also implemented interleaved sessions (as shown in Appendix B.1), where one
participant is involved in two diﬀerent protocols at the same time.

7

Conclusion and future work

Rust’s pledge to guarantee memory safety does not extend to communication safety. Rust’s
built-in binary channels and aﬃne type system are insuﬃcient to ensure correct interaction
and termination of multiple communicating processes. This paper overcomes this limitation
by providing two main contributions. We proposed a new typing discipline, aﬃne multiparty
session types, which captures implicit/explicit cancellation mechanisms in Rust, and proved
its cancellation termination theorem. In addition to progress and liveness properties, our
end-point processes can guarantee that all processes terminate safely and cancellation is

E C O O P 2 0 2 2

1:30

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

correctly propagated across all channels in a session, whenever and wherever a failure
happens. We embedded the theory in Rust and developed a practical library for safe
multiparty communication, MultiCrusty, which ensures deadlock-freedom and liveness in
the presence of cancellations of arbitrary processes. Evaluation of MultiCrusty shows that
it has only a negligible overhead when compared with the built-in unsafe Rust channels. We
demonstrated the use of MultiCrusty for programming distributed application protocols
with exception handling patterns.

As part of future work, we would like to develop recovery strategies based on causal
analysis, along the lines of [47]. In addition, it would be interesting to verify role-parametric
session types following [9] in an aﬃne setting. Finally, we plan to study polymorphic meshed
channels with diﬀerent delivery guarantees such as TCP and UDP.

References

1 Manuel Adameit, Kirstin Peters, and Uwe Nestmann. Session Types for Link Failures. In
Ahmed Bouajjani and Alexandra Silva, editors, Formal Techniques for Distributed Objects,
Components, and Systems, pages 1–16, Cham, 2017. Springer International Publishing. doi:
https://doi.org/10.1007/978-3-319-60225-7_1.

3

2 Davide Ancona, Viviana Bono, and Mario Bravetti. Behavioral Types in Programming
Languages. Number 2-3. Now Publishers Inc., Hanover, MA, USA, 2016. doi:10.1561/
2500000031.
Stephanie Balzer and Frank Pfenning. Manifest Sharing with Session Types. Proc. ACM
Program. Lang., 1(ICFP), August 2017. doi:10.1145/3110281.
Stephanie Balzer, Bernardo Toninho, and Frank Pfenning. Manifest Deadlock-Freedom for
Shared Session Types. In Luís Caires, editor, Programming Languages and Systems - 28th
European Symposium on Programming, ESOP 2019, Held as Part of the European Joint
Conferences on Theory and Practice of Software, ETAPS 2019, Prague, Czech Republic, April
6-11, 2019, Proceedings, volume 11423 of Lecture Notes in Computer Science, pages 611–639,
Cham, 2019. Springer. doi:10.1007/978-3-030-17184-1_22.

4

6

5 Daniel Brand and Pitro Zaﬁropulo. On Communicating Finite-State Machines. J. ACM,
30(2):323–342, 1983. URL: http://doi.acm.org/10.1145/322374.322380, doi:10.1145/
322374.322380.
Luís Caires and Frank Pfenning. Session Types as Intuitionistic Linear Propositions. In Paul
Gastin and François Laroussinie, editors, CONCUR 2010 - Concurrency Theory, pages 222–236,
Berlin, Heidelberg, 2010. Springer Berlin Heidelberg. doi:10.1007/978-3-642-15375-4_16.
Sara Capecchi, Elena Giachino, and Nobuko Yoshida. Global Escape in Multiparty Session.
In FSTTCS, volume 8 of LIPIcs, pages 338–351. Schloss Dagstuhl - LeibnizZentrum fuer
Informatik, 2010.

7

8 Marco Carbone, Kohei Honda, and Nobuko Yoshida. Structured Interactional Exceptions
In CONCUR, volume 5201 of LNCS, pages 402–417. Springer, 2008.

in Session Types.
doi:https://doi.org/10.1007/978-3-540-85361-9_32.

9 David Castro, Raymond Hu, SungShik Jongmans, Nicholas Ng, and Nobuko Yoshida. Distrib-
uted Programming Using Role-Parametric Session Types in Go: Statically-Typed Endpoint
APIs for Dynamically-Instantiated Communication Structures. Proc. ACM Program. Lang.,
3(POPL), January 2019. Place: New York, NY, USA Publisher: Association for Computing
Machinery. doi:10.1145/3290342.

10 Ruofei Chen and Stephanie Balzer. Ferrite: A Judgmental Embedding of Session Types
in Rust. CoRR, abs/2009.13619, 2020. URL: https://arxiv.org/abs/2009.13619, arXiv:
2009.13619.

11 Mario Coppo, Mariangiola Dezani-Ciancaglini, Nobuko Yoshida, and Luca Padovani. Global
progress for dynamically interleaved multiparty sessions. Mathematical Structures in Computer
Science, 26(2):238–302, 2016. doi:10.1017/S0960129514000188.

N. Lagaillardie, R. Neykova and N. Yoshida

1:31

12

Zak Cutner, Nobuko Yoshida, and Martin Vassor. Optimising Asynchronous Communication
in Rust: Deadlock-Free Message Reordering with Multiparty session Types, 2022. To appear
at PPoPP 2022.

13 Romain Demangeon, Kohei Honda, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida.
Practical interruptible conversations: distributed dynamic veriﬁcation with multiparty session
types and Python. FMSD, 46(3):197–225, 2015. URL: http://dx.doi.org/10.1007/s10703-
014-0218-8, doi:10.1007/s10703-014-0218-8.
Pierre-Malo Deniélou and Nobuko Yoshida. Dynamic Multirole Session Types. SIGPLAN
Not., 46(1):435–446, January 2011. doi:10.1145/1925844.1926435.

14

15 The Crossbeam Project Developers. Crate: Crossbeam channel, 2021. Last accessed: July

2021. URL: https://crates.io/crates/crossbeam-channel.

17

16 Mariangiola Dezani-Ciancaglini, Silvia Ghilezan, Svetlana Jaksic, Jovanka Pantovic, and
Nobuko Yoshida. Precise subtyping for synchronous multiparty sessions. In PLACES, pages
29–43, Università degli studi di Torino, Via Giuseppe Verdi, 8, 10124 Torino TO, Italie, 2015.
DBLP. doi:10.4204/EPTCS.203.3.
José Duarte and António Ravara. Retroﬁtting Typestates into Rust. page 83–91, 2021.
doi:10.1145/3475061.3475082.
Falahah, Kridanto Surendro, and Wikan Danar Sunindyo. Circuit Breaker in Microservices:
State of the Art and Future Prospects.
IOP Conference Series: Materials Science and
Engineering, 1077(1):012065, feb 2021. doi:10.1088/1757-899x/1077/1/012065.

18

23

21

20

22

19 Roy Fielding and Julian Reschke. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax
and Routing. Technical Report RFC7230, RFC Editor, June 2014. URL: https://www.rfc-
editor.org/info/rfc7230, doi:10.17487/rfc7230.
Simon Fowler. Typed Concurrent Functional Programming with Channels, Actors, and
Sessions. page 290.
Simon Fowler, Sam Lindley, J. Garrett Morris, and Sára Decova. Exceptional Asynchronous
Session Types: Session Types Without Tiers. Proc. ACM Program. Lang., 3(POPL):28:1–28:29,
January 2019. Place: New York, NY, USA Publisher: ACM. doi:10.1145/3290341.
In Be-
Simon Gay and António Ravara. Behavioural Types:
from Theory to Tools.
havioural Types:
from Theory to Tools, Automation, Control and Robotics, pages 1–
412. Rivers publishers, Alsbjergvej 10, 9260 Gistrup, Denmark, 2017. URL: https://
www.riverpublishers.com/dissertations_xml/9788793519817/9788793519817.xml,
doi:
10.13052/rp-9788793519817.
Silvia Ghilezan, Svetlana Jakšić, Jovanka Pantović, Alceste Scalas, and Nobuko Yoshida.
Precise subtyping for synchronous multiparty sessions. Journal of Logical and Algebraic Meth-
ods in Programming, 104:127–173, 2019. URL: https://www.sciencedirect.com/science/
article/pii/S2352220817302237, doi:https://doi.org/10.1016/j.jlamp.2018.12.002.
Silvia Ghilezan, Jovanka Pantović, Ivan Prokić, Alceste Scalas, and Nobuko Yoshida. Precise
Subtyping for Asynchronous Multiparty Sessions. Proc. ACM Program. Lang., 5(POPL),
January 2021. doi:10.1145/3434297.
Paul Harvey, Simon Fowler, Ornela Dardha, and Simon J. Gay. Multiparty Session
Types for Safe Runtime Adaptation in an Actor Language.
In Anders Møller and
Manu Sridharan, editors, 35th European Conference on Object-Oriented Programming
(ECOOP 2021), volume 194 of Leibniz International Proceedings in Informatics (LIPIcs),
page 30, Dagstuhl, Germany, 2021. Schloss Dagstuhl – Leibniz-Zentrum für Inform-
atik. URL: https://2021.ecoop.org/details/ecoop-2021-ecoop-research-papers/12/
Multiparty-Session-Types-for-Safe-Runtime-Adaptation-in-an-Actor-Language, doi:
10.4230/LIPIcs.ECOOP.2021.12.

25

24

26 Kohei Honda, Vasco T. Vasconcelos, and Makoto Kubo. Language primitives and type discipline
for structured communication-based programming. In Chris Hankin, editor, Programming
Languages and Systems, ESOP ’98, pages 122–138, Berlin, Heidelberg, 1998. Springer Berlin
Heidelberg. doi:https://doi.org/10.1007/BFb0053567.

E C O O P 2 0 2 2

1:32

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

27 Kohei Honda, Nobuko Yoshida, and Marco Carbone. Multiparty Asynchronous Session Types.

SIGPLAN Not., 43(1):273–284, January 2008. doi:10.1145/1328897.1328472.

28 Raymond Hu and Nobuko Yoshida. Hybrid Session Veriﬁcation Through Endpoint API
Generation. In Perdita Stevens and Andrzej Wasowski, editors, Fundamental Approaches
to Software Engineering, volume 9633, pages 401–418. Springer Berlin Heidelberg, Berlin,
Heidelberg, 2016. URL: http://link.springer.com/10.1007/978-3-662-49665-724, doi:
10.1007/978-3-662-49665-724.

29 Raymond Hu and Nobuko Yoshida. Explicit Connection Actions in Multiparty Session
Types. In Marieke Huisman and Julia Rubin, editors, Fundamental Approaches to Software
Engineering, volume 10202, pages 116–133. Springer Berlin Heidelberg, Berlin, Heidelberg,
2017. Series Title: Lecture Notes in Computer Science. URL: https://link.springer.com/
10.1007/978-3-662-54494-57, doi:10.1007/978-3-662-54494-57.

30 Raymond Hu, Nobuko Yoshida, and Kohei Honda. Session-Based Distributed Programming
in Java. In Jan Vitek, editor, ECOOP’08, volume 5142 of LNCS, pages 516–541, Berlin,
Heidelberg, 2008. Springer Berlin Heidelberg. doi:10.1007/978-3-540-70592-5_22.
31 Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler. Featherweight Java: a Minimal
Core Calculus for Java and GJ. ACM Trans. Program. Lang. Syst., 23(3):396–450, May 2001.
doi:10.1145/503502.503505.

33

32 Keigo Imai, Rumyana Neykova, Nobuko Yoshida, and Shoji Yuen. Multiparty Session Pro-
gramming With Global Protocol Combinators. In Robert Hirschfeld and Tobias Pape, ed-
itors, 34th European Conference on Object-Oriented Programming (ECOOP 2020), volume
166 of Leibniz International Proceedings in Informatics (LIPIcs), pages 9:1–9:30, Dag-
stuhl, Germany, 2020. Schloss Dagstuhl–Leibniz-Zentrum für Informatik. URL: https:
//drops.dagstuhl.de/opus/volltexte/2020/13166, doi:10.4230/LIPIcs.ECOOP.2020.9.
Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen. Session Types
for Rust. In Proceedings of the 11th ACM SIGPLAN Workshop on Generic Programming,
WGP 2015, page 13–22, New York, NY, USA, 2015. Association for Computing Machinery.
doi:10.1145/2808098.2808100.
Limin Jia, Hannah Gommerstadt, and Frank Pfenning. Monitors and Blame Assignment for
Higher-Order Session Types. SIGPLAN Not., 51(1):582–594, January 2016. doi:10.1145/
2914770.2837662.

34

35 Aparicio Jorge. Crate: Criterion, 2021. Last accessed: July 2021. URL: https://crates.io/

crates/criterion.

36 Wen Kokke. Rusty Variation: Deadlock-free Sessions with Failure in Rust. Electronic
Proceedings in Theoretical Computer Science, 304:48–60, Sep 2019. URL: http://dx.doi.
org/10.4204/EPTCS.304.4, doi:10.4204/eptcs.304.4.

37 Dimitrios Kouzapas, Ornela Dardha, Roly Perera, and Simon J. Gay. Typechecking Protocols
with Mungo and stmungo. In Proceedings of the 18th International Symposium on Principles
and Practice of Declarative Programming, PPDP ’16, page 146–159, New York, NY, USA,
2016. Association for Computing Machinery. doi:10.1145/2967973.2968595.

38 Dimitrios Kouzapas, Ornela Dardha, Roly Perera, and Simon J. Gay. Typechecking
Science of
protocols with Mungo and stmungo: A session type toolchain for Java.
Computer Programming, 155:52–75, April 2018.
Selected and Extended papers from
the International Symposium on Principles and Practice of Declarative Programming
2016. URL: https://www.sciencedirect.com/science/article/pii/S0167642317302186,
doi:https://doi.org/10.1016/j.scico.2017.10.006.

39 Nicolas Lagaillardie, Rumyana Neykova, and Nobuko Yoshida. Stay safe under panic: Aﬃne

40

rust programming with multiparty session types. Technical report, 2022. arXiv: to appear.
Julien Lange, Emilio Tuosto, and Nobuko Yoshida. From Communicating Machines to
Graphical Choreographies. In Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL ’15, page 221–232, New York,
NY, USA, 2015. Association for Computing Machinery. doi:10.1145/2676726.2676964.

N. Lagaillardie, R. Neykova and N. Yoshida

1:33

41

42

43

Julien Lange and Nobuko Yoshida. Verifying Asynchronous Interactions via Communicating
Session Automata. In Isil Dillig and Serdar Tasiran, editors, Computer Aided Veriﬁcation -
31st International Conference, CAV 2019, volume 11561 of Lecture Notes in Computer Science,
pages 97–117, Cham, 2019. Springer. doi:10.1007/978-3-030-25540-4_6.
Sam Lindley and J. Garrett Morris. A Semantics for Propositions as Sessions. In Jan Vitek,
editor, Programming Languages and Systems, pages 560–584, Berlin, Heidelberg, 2015. Springer
Berlin Heidelberg. doi:10.1007/978-3-662-46669-8_23.
Sam Lindley and J. Garrett Morris. Talking Bananas: Structural Recursion for Session Types.
SIGPLAN Not., 51(9):434–447, September 2016. doi:10.1145/3022670.2951921.

44 Anson Miu, Francisco Ferreira, Nobuko Yoshida, and Fangyi Zhou. Generating Interactive
WebSocket Applications in TypeScript. Electronic Proceedings in Theoretical Computer
Science, 314:12–22, April 2020. URL: http://arxiv.org/abs/2004.01321v1, doi:10.4204/
EPTCS.314.2.

45 Dimitris Mostrous and Vasco T. Vasconcelos. Aﬃne Sessions. Logical Methods in Computer
Science ; Volume 14, 8459:Issue 4 ; 18605974, 2018. Medium: PDF Publisher: Episciences.org.
URL: https://lmcs.episciences.org/4973, doi:10.23638/LMCS-14(4:14)2018.

46 Rumyana Neykova, Raymond Hu, Nobuko Yoshida, and Fahd Abdeljallal. A Session Type
Provider: Compile-Time API Generation of Distributed Protocols with Reﬁnements in f#.
In Proceedings of the 27th International Conference on Compiler Construction, CC 2018,
page 128–138, New York, NY, USA, 2018. Association for Computing Machinery. doi:
10.1145/3178372.3179495.

47 Rumyana Neykova and Nobuko Yoshida. Let It Recover: Multiparty Protocol-Induced
Recovery. In Proceedings of the 26th International Conference on Compiler Construction,
CC 2017, page 98–108, New York, NY, USA, 2017. Association for Computing Machinery.
doi:10.1145/3033019.3033031.

48 Rumyana Neykova, Nobuko Yoshida, and Raymond Hu. Spy: Local Veriﬁcation of Global
Protocols. In Axel Legay and Saddek Bensalem, editors, Runtime Veriﬁcation, volume 8174
of LNCS, pages 358–363, Berlin, Heidelberg, 2013. Springer Berlin Heidelberg. doi:https:
//doi.org/10.1007/978-3-642-40787-1_25.

49 Nicholas Ng, Jose Gabriel de Figueiredo Coutinho, and Nobuko Yoshida. Protocols by Default.
In Björn Franke, editor, Compiler Construction, pages 212–232, Berlin, Heidelberg, 2015.
Springer Berlin Heidelberg. doi:https://doi.org/10.1007/978-3-662-46663-6_11.
Last accessed:

July
2021. URL: https://play.integer32.com/?version=stable&mode=debug&edition=2018&
gist=95979b17196adbc203c4f563e00d384b.

50 Developers Rust.

attempt-catch macro,

Rust:

2018.

51 Alceste Scalas, Ornela Dardha, Raymond Hu, and Nobuko Yoshida. A Linear Decomposition
of Multiparty Sessions for Safe Distributed Programming.
In Peter Müller, editor, 31st
European Conference on Object-Oriented Programming (ECOOP 2017), volume 74 of Leibniz
International Proceedings in Informatics (LIPIcs), pages 24:1–24:31, Dagstuhl, Germany,
ISSN: 1868-8969. URL: http:
2017. Schloss Dagstuhl–LeibnizZentrum fuer Informatik.
//drops.dagstuhl.de/opus/volltexte/2017/7263, doi:10.4230/LIPIcs.ECOOP.2017.24.

52 Alceste Scalas and Nobuko Yoshida. Lightweight Session Programming in Scala. In Shriram
Krishnamurthi and Benjamin S. Lerner, editors, 30th European Conference on Object-Oriented
Programming (ECOOP 2016), volume 56 of Leibniz International Proceedings in Informatics
(LIPIcs), pages 21:1–21:28, Dagstuhl, Germany, 2016. Schloss Dagstuhl–LeibnizZentrum fuer
Informatik. ISSN: 1868-8969. URL: http://drops.dagstuhl.de/opus/volltexte/2016/6115,
doi:10.4230/LIPIcs.ECOOP.2016.21.

53 Alceste Scalas and Nobuko Yoshida. Less is More: Multiparty Session Types Revisited. Proc.

ACM Program. Lang., 3(POPL), January 2019. doi:10.1145/3290343.
54 Authors Scribble. Scribble home page. 2021. URL: http://www.scribble.org.
55 McArthur Sean. Crate: Hyper, 2021. Last accessed: July 2021. URL: https://crates.io/

crates/hyper.

E C O O P 2 0 2 2

1:34

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

56 Company StackOverﬂow. Stackoverﬂow: 2020 Developer Survey, 2020. Last accessed: July

2021. URL: https://insights.stackoverflow.com/survey/2020.

57 Contributors Tokio. Crate: Tokio, 2021. Last accessed: July 2021. URL: https://crates.

io/crates/tokio.

58 Tengfei Tu, Xiaoyu Liu, Linhai Song, and Yiying Zhang. Understanding Real-World
Concurrency Bugs in Go. In Proceedings of the Twenty-Fourth International Conference
on Architectural Support for Programming Languages and Operating Systems, ASPLOS
’19, page 865–878, New York, NY, USA, 2019. Association for Computing Machinery.
doi:10.1145/3297858.3304069.

59 Vasco T. Vasconcelos, Simon J. Gay, and António Ravara. Type checking a multith-
readed functional language with session types. Theoretical Computer Science, 368(1):64–87,
2006. URL: https://www.sciencedirect.com/science/article/pii/S0304397506003902,
doi:https://doi.org/10.1016/j.tcs.2006.06.028.

60 Malte Viering, Tzu-Chun Chen, Patrick Eugster, Raymond Hu, and Lukasz Ziarek. A Typing
Discipline for Statically Veriﬁed Crash Failure Handling in Distributed Systems, volume
10801 of LNCS, pages 799–826. Springer International Publishing, Cham, 04 2018. doi:
10.1007/978-3-319-89884-1_28.

61 Malte Viering, Raymond Hu, Patrick Eugster, and Lukasz Ziarek. A multiparty session typing
discipline for fault-tolerant event-driven distributed programming. Proceedings of the ACM on
Programming Languages, 5(OOPSLA):1–30, October 2021. URL: https://dl.acm.org/doi/
10.1145/3485501, doi:10.1145/3485501.
Contributors Wikipedia. Wikipedia: Flow (psychology), 2021. Last accessed: July 2021. URL:
https://en.wikipedia.org/wiki/Flow_(psychology).

62

63 Nobuko Yoshida, Raymond Hu, Rumyana Neykova, and Nicholas Ng. The Scribble Protocol
Language. In Martín Abadi and Alberto Lluch Lafuente, editors, Trustworthy Global Computing,
pages 22–41, Cham, 2014. Springer International Publishing. doi:https://doi.org/10.1007/
978-3-319-05119-2_3.
Fangyi Zhou, Francisco Ferreira, Raymond Hu, Rumyana Neykova, and Nobuko Yoshida. Stat-
ically Veriﬁed Reﬁnements for Multiparty Protocols. Proc. ACM Program. Lang., 4(OOPSLA),
November 2020. doi:10.1145/3428216.

64

A

Appendix for § 3

(cid:73) Theorem 3.15 (Subject Congruence). If Θ · Γ ‘ Q and Q ≡ P , then we have Θ · Γ ‘ P .

Proof. Case s

≡ s

.
| s
(cid:32)
(cid:32)
i, s[p1i]:S1i, s[p2i]:S2i, . . . , s[pni]:Sni with end(Γ0
with Γi = Γ0

(cid:32)

i) (i = 1, 2). Let

with end(Γ0

1 ∪ Γ0

2), as desired.

(⇒) Θ · Γ1 ‘ s
Γ1 ∪ Γ2 = Γ00. Then we have: Θ · Γ00 ‘ s
(⇐) Similar with the case of (⇒).

(cid:32)

(cid:32)

Case (νs) s

≡ 0

(cid:32)

By Lemma 3.24, we only have to assume we use Rule [T-ν].
(⇒) Suppose Θ · Γ ‘ (νs : Γ0) s
(⇐) Similar with the case of (⇒) applying [T-kill] (taking the session environment Γ0 safe)
(cid:74)
and [T-ν].

by [T-ν]. Then end(Γ). Hence Θ · Γ ‘ 0, as desired.

(cid:32)

(cid:73) Theorem 3.16 (Subject Reduction). Suppose Θ · Γ ‘ P and Γ safe. Then, P → P 0 implies
there exists Γ0 such that Γ0 is safe and Γ →∗ Γ0 and Θ · Γ0 ‘ P 0.

Proof. The case analysis of the reduction rules.
Case [R-Com] E1[† s[p][q]P

i∈I mi(xi).Pi] | E2[† s[q][p]⊕mkhs0[r]i.Q] → Pk{s0[r]/xk} | Q

N. Lagaillardie, R. Neykova and N. Yoshida

1:35

with k ∈ I

In the case both contexts are empty coincides with the proof in [53, Theorem 4.8]. Hence we
assume Ei ::= try [ ] catch Ri for some Ri (i = 1, 2). Recall the typing rule:

Θ · Γ ‘ P

sbj(P ) = c
Θ · Γ ‘ try P catch Q

Θ · Γ ‘ Q

[T-try]

i.e., for any P , E[P ] is typed by the same environments Θ, Γ as P ; hence the proof is the
same as the case of E = [ ] ([53, Theorem 4.8]).
Case [C-?Sel]: ? s[p][q]⊕mhs0[r]i.P → s[p][q]⊕mhs0[r]i.P | s
Assume, by [T-⊕],

(cid:32)

Θ · Γ, Γ1, Γ2 ‘ ? s[p][q]⊕mhs0[r]i.P

where

Γ1 ‘ s[p]:q⊕m(S).S0 Γ2 ‘ s0[r]:S Θ · Γ, s[p]:S0 ‘ P

(9)

Then by [T-kill], we have

Θ · ∅ ‘ s

(cid:32)

From (9), we have:

Θ · Γ, Γ1, Γ2 ‘ s[p][q]⊕mhs0[r]i.P

By [T-|], we have:

Θ · Γ, Γ1, Γ2 ‘ s[p][q]⊕mhs0[r]i.P | s
(cid:32)

as required.
Case [C-Sel] s[p][q]⊕mhs0[r]i.P | s
Suppose:

(cid:32)

→ P | s

(cid:32)

| s0

(cid:32)

Θ · Γ, Γ1, Γ2, Γ3 ‘ s[p][q]⊕mhs0[r]i.P | s
(cid:32)
with Γ, Γ1, Γ2, Γ3 safe and assume, by [T-⊕]:

Θ · Γ, Γ1, Γ2 ‘ s[p][q]⊕mhs0[r]i.P

where

Γ1 ‘ s[p]:q⊕m(S).S0 Γ2 ‘ s0[r]:S Θ · Γ, s[p]:S0 ‘ P

with Γ2 = Γ5, s0[r]:S0 with S0 (cid:54) S and end(Γ5). By [T-kill]:

Θ · Γ3 ‘ s

(cid:32)

where, by safety of the session environments in (10), we have:

Γ3 ‘ s[q]:p&i∈I mi(Si).S00
i

By [T-kill], we have:

Θ · Γ2 ‘ s0

(cid:32)

(10)

(11)

(12)

E C O O P 2 0 2 2

1:36

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

By (10), (11) and (12) we have:

Θ · Γ, Γ0

1, Γ2, Γ0

3 ‘ P | s

(cid:32)

| s0

(cid:32)

and Θ · Γ0

3 ‘ s

(cid:32)

where

1 ‘ s[p]:S0
Γ0

and Γ0

3 ‘ s[q]:S00
i

and Γ1, Γ3 → Γ0

1, Γ0
3

and Γ, Γ0

1, Γ2, Γ0
3

safe

as desired.

Case [C-?Br]: Similar with [C-?Sel] above.

(cid:32)
→ Q | s

(cid:32)

(cid:32)

) | s

→ (νs0) (Pk{s0[r]/xk} | s0

i∈I mi(xi).Pi | s
(cid:32)

i ∈ I and Θ · Γ, yi :Si, s[p]:S0

Case [T?Br]: Similar with [T?Sel] above.
Case [C-Br]: s[p][q]P
Assume by [T-&], we have Θ · Γ, Γ1 (cid:15) s[p][q]P
i ‘ Pi.
for all
Θ · Γ, s0[r]:Sk, s[p]:S0
k ‘ Pk{s0[r]/xk}. By typing s0
text Γ0 such that safe(Γ0, s0[r]:Sk), hence by applying [T-ν], we obtain the result.
Case [R-Can]: E[cancel(s[p]).Q] → s
| Q
].
By the same reason as
Θ · Γ, s[p]:S ‘ cancel(s[p]).Q with Θ · Γ ‘ Q. Then by [T-kill], Θ · s[p]:S ‘ s
[T-|], we obtain Θ · Γ, s[p]:S ‘ Q | s

with s0 6∈ fc(Pk) , k ∈ I.
i∈I mi(yi).Pi with Γ1 ‘ s[p]:q&i∈I mi(Si).S0
i
Then by the substitution lemma,
with an appropriate session typing con-

the case [R-Com], we can set E = [

Assume
. Applying

, as desired.

(cid:32)

(cid:32)

(cid:32)

(cid:32)

(cid:32)

Case [C-Cat]: try P catch Q | s

with s[r] = sbj(P ) for some r.

Similar to the case of [C-?Sel] noting that Q is typed by the same typing contexts as
try P catch Q (see the case of [R-Com]).

Cases [R-Def] and [R-Ctx]: By Lemma 3.24 and Subject Reduction Theorem in [53, The-
orem 4.8].

Case [R-Struct]: By Theorem 3.15.
(cid:73) Theorem 3.18 (Session Fidelity). Assume ∅·Γ ‘ P , where Γ is safe, P ≡ (cid:12)
(cid:12)p∈I Pp | Q
, and
(cid:32)
Γ = S
. Assume that
p∈I Γp ∪ Γ0 such that, for each Pp, we have ∅· Γp ‘ Pp; and ∅· Γ0 ‘ Q
(cid:32)
each Pp is either Pp ≡ 0, or only plays p in s, by Γp. Then, Γ→ implies ∃Γ0, P 0 such that
Γ → Γ0, P →∗ P 0 and ∅·Γ0 ‘ P 0, with Γ0 safe, P 0 ≡ (cid:12)
, and Γ0 = S
(cid:12)p∈I P 0
p ∪ Γ0
0
(cid:32)
such that, for each P 0
p, and each P 0
p, we have ∅· Γ0
p is either 0, or only plays p in s, by
p; and ∅· Γ0
Γ0
.
(cid:32)

p∈I Γ0

p ‘ P 0

0 ‘ Q0

p | Q0

(cid:74)

Proof. The proof is analogous with [53] except that we have the additional cases to consider:

as a unique role p in s.
for some s0 is newly generated.

1. s
(cid:32)
2. s0
(cid:32)

Case (1): Suppose Pp = s
[C-Cat]. These cases are trivial since if P → P 0 then P 0 = R | s
a unique role p in s of P 0.
Case (2): There are two main cases:

(cid:32)

(cid:32)

for some p. The only interesting cases are: [T?Sel], [C-Br] and
stays as

for some R thus s

(cid:32)

1. By [C-?Sel], [C-Br], [C-?Br], and [R-Can], s

is newly generated.

a. In the cases of [C-?Sel] and [C-?Br], we have ∅ · s[q]:end ‘ s

(cid:32)

included in Q0

.
(cid:32)

b. In the cases [C-Sel], [C-Br] and [R-Can], s
and branching, and typed by Γp.

(cid:32)

where q 6∈ I. Hence, s

(cid:32)

is

(cid:32)

will take a place as role p in s of the selection

N. Lagaillardie, R. Neykova and N. Yoshida

1:37

2. s0

for some s0 6= s is newly generated by [C-Sel]. In this case, by the deﬁnition of a unique

(cid:32)

role, we have ∅ · s0[p]:end ‘ s0

. Hence, s0

(cid:32)

(cid:32)

is included in Q0

.

(cid:32)

This concludes the proof.

(cid:74)

(cid:73) Theorem 3.20 (Deadlock-freedom). Assume ∅ · Γ ‘ P , with Γ safe, P ≡ (cid:12)
(cid:12)p∈I Pp, each
Pp either Pp ≡ 0, or only playing role p in s. Then, df(Γ) implies that (ν˜s:Γ) P with
{˜s} = dom(Γ) is deadlock-free.

6→ implies

, and Γ = S
(cid:12)p∈I Pp | Q
(cid:32)

Proof. Recall that df(Γ) means Γ →∗ Γ0
P ≡ (cid:12)
∅· Γ0 ‘ Q
Γ →∗ Γ0, P →∗ P 0 and ∅·Γ0 ‘ P 0, with Γ0 safe, P 0 ≡ (cid:12)
p, we have ∅· Γ0
such that, for each P 0
p, and each P 0
p ‘ P 0
0 ‘ Q0
. By the deﬁnition of df(Γ), end(Γ0
p; and ∅· Γ0
Γ0
(cid:32)
, we have (ν~s:Γ0
0) Q
Q

end(Γ0). Assume ∅·Γ ‘ P with
p∈I Γp ∪ Γ0 such that, for each Pp, we have ∅· Γp ‘ Pp; and
. By Theorem 3.18, we have P →∗ P 0 and Then, Γ→ implies ∃Γ0, P 0 such that
, and Γ0 = S
(cid:12)p∈I P 0
p ∪ Γ0
0
p is either 0, or only plays p in s, by
p) and end(Γ0
0). By applying [T-ν] to
p), we have (νs:Γ0) (cid:12)
(cid:74)

≡ 0. Then by end(Γ0

p∈I Γ0

p ≡ 0.

p | Q0

(cid:32)

(cid:32)

(cid:12)p∈I P 0

(cid:32)

(cid:32)

(cid:73) Theorem 3.21 (Liveness). Assume ∅ · Γ ‘ P , with Γ safe, P ≡ (cid:12)
Pp ≡ 0, or only playing role p in s. Then,

live+(Γ) implies that P is live.

(cid:12)p∈I Pp, each Pp either

, and Γ = S
(cid:12)p∈I Pp | Q
(cid:32)

Proof. Assume ∅·Γ ‘ P with P ≡ (cid:12)
we have ∅· Γp ‘ Pp; and ∅· Γ0 ‘ Q
implies ∃Γ0, P 0 such that Γ →∗ Γ0, P →∗ P 0 and ∅·Γ0 ‘ P 0, with Γ0 safe, P 0 ≡ (cid:12)
and Γ0 = S
p ∪ Γ0
only plays p in s, by Γ0
p and Q0
5.15] is that P 0
with in Deﬁnition 3.19(2). In the case of [C-Br], it matches with in Deﬁnition 3.19(2).

p∈I Γp ∪ Γ0 such that, for each Pp,
. By Theorem 3.18, we have P →∗ P 0 and Then, Γ→
(cid:12)p∈I P 0
,
(cid:32)
p is either 0, or
. The only important diﬀerence from [53, Theorem
interact together by [C-Sel] and [C-Br]. In the case of [C-Sel], it matches
(cid:74)

0 such that, for each P 0
p; and ∅· Γ0

p, we have ∅· Γ0

p, and each P 0

p∈I Γ0

p ‘ P 0

0 ‘ Q0

p | Q0

(cid:32)

(cid:32)

(cid:32)

(cid:73) Theorem 3.27 (Cancellation Termination). Suppose ‘ Q is an initial program. If Q →∗
C[s

] = P 0, then we have P 0 →∗ 0.

(cid:32)

Case 1: Suppose Q is ﬁnite, i.e., it does not contain any (free or bound) process calls. Then
by Corollary 3.25, for all Q0 such that Q →∗ Q0, there exits a reduction sequence such
that Q0 →∗ Q00 ≡ 0.
Case 2: Assume Q →∗ C[s

] →∗ C0[def X(ex) = Q00 in R|s
(cid:32)
(cid:32)

] and Q contains the process deﬁnitions and calls, i.e., Q can
produce the inﬁnite sequence of reductions. In this case, the only interesting case is
C[s
] where, by Deﬁnition 3.22(3), Q00 = try P 0 catch R
where R is ﬁnite. By Deﬁnition 3.17, sbj(P 0) = s[r] for some r. Hence, using [R-Def] and
[R-Cat], we have C0[def X(ex) = Q00 in P 0 | s
] where R is ﬁnite. The rest
(cid:32)
is the same as Case (1).

] →→ C0[R | s

(cid:32)

(cid:32)

A.1 Additional examples and deﬁnitions for our theory

The following shows the examples of nested try-catch processes which are typable by
our typing system introduced later. Below R1 has a simple nested try-catch process, R2 has
a session delegation, R3 has a parallel composition (spawning after the ﬁrst try), and R4
has a scope opening after the ﬁrst try. Notice that our Rust implementation can write the
interleaved sessions and delegations, some related case studies can be found in Appendix B.1.

E C O O P 2 0 2 2

1:38

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

P | Q ≡ Q | P (P | Q) | R ≡ P | (Q | R) P | 0 ≡ P (νs) 0 ≡ 0 (νs) (νs0) P ≡ (νs0) (νs) P

s
(cid:32)

| s

≡ s

(νs) s

≡ 0

(cid:32)

(cid:32)

(cid:32)

(νs) (P | Q) ≡ P | (νs) Q if s 6∈ fc(P ) def D in 0 ≡ 0

def D in (νs) P ≡ (νs) (def D in P )

if s 6∈ fc(P )

def D in (P | Q) ≡ (def D in P ) | Q if dpv(D) ∩ fpv(Q) = ∅
in P ) ≡ def D0
if (dpv(D) ∪ fpv(D)) ∩ dpv(cid:0)D0(cid:1) = (dpv(cid:0)D0(cid:1) ∪ fpv(cid:0)D0(cid:1)) ∩ dpv(D) = ∅

def D in (def D0

in (def D in P )

Figure 10 Structural congruence rules, extended version.

R1 = try s[p][r]⊕m1 .(try s0[q][r]⊕m2 .P catch cancel(s0[q]).0)

catch cancel(s[p]).cancel(s0[q]).0

R2 = try s[p][r]⊕m1hs00[r]i.(try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0)

catch cancel(s[p]).cancel(s0[q]).cancel(s00[r]).0

R3 = try s[p][r]⊕m1 .(s[p][q]⊕m3 .0 | try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0)

catch cancel(s[p]).cancel(s0[q]).0

(13)

(14)

(15)

R4 = try s[p][r]⊕m1 .(νs0) (s[p][r]⊕m3hs0[r]i.0 | try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0)

catch cancel(s[p]).0

(16)

(cid:73) Example A.2 (Typing nested Try-catch). Typing derivation for Equation (13). Assume
P = 0 in Equation (13) and R1.1 = try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0 .

See Example A.3
Γ ‘ s[p][r]⊕m1 .R1.1

[T-⊕]

sbj(R1) = {s[p]}

Γ ‘ R1

end(∅)

[T-0]

∅ ‘ 0
Γ1 ‘ cancel(s0[q]).0
Γ ‘ cancel(s[p]).cancel(s0[q]).0

[T-cancel]

[T-cancel]

[T-try]

where Γ1 = s0[q]:r⊕m2 and Γ = Γ1, s[p]:r⊕m1 .

(cid:73) Example A.3 (Typing nested Try-catch aux).

. . .
Γ2 ‘ s[p]:r⊕m1

[T-sub]

. . .
+Γ3 ‘ s0[q][r]⊕m2 .0

[T-⊕]

sbj(cid:0)s0[q][r]⊕m2 .0(cid:1) = {s0[q]}

Γ3 ‘ try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0

Γ ‘ s[p][r]⊕m1 .R1.1

[T-⊕]

end(s[p]:end)
s[p]:end ‘ 0
Γ3 ‘ cancel(s0[q]).0

[T-0]

[T-cancel]

[T-try]

because m1 does not have any payload and where Γ3 = Γ1, s[p]:end. .

(cid:73) Example A.4 (Typing nested Try-catch with rec). Typing derivation for Equation (16).
Assume R4.1 = (νs0) (s[p][r]⊕m3hs0[r]i.0 | try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0) .

N. Lagaillardie, R. Neykova and N. Yoshida

1:39

1
2

3
4
5
6
7
8
9
10
11
12
13
14

fn endpoint_controller(

s_circuit_breaker:

CircuitBreakerController,

s_logging: LogController,

) -> Result<(), Box<dyn Error>> {

let s_circuit_breaker =

s_circuit_breaker.send(0)?;

let s_logging =

s_logging.send(0)?;

let s_circuit_breaker =

s_circuit_breaker.send(0)?;
let (_, s_circuit_breaker) =
s_circuit_breaker.recv()?;

...

}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

create_fork_interleaved!( ... );

let (

thread_api,
thread_storage,
thread_user,
thread_logs,
thread_controller

) = fork_interleaved(

endpoint_api,
endpoint_storage,
endpoint_user,
endpoint_logs,
endpoint_controller

); // The function for the interleaved
session is always at the end

(a) Interleaved session example

(b) Interleaved session forking

Figure 11 Interleaved sessions

See Example A.5
Γ ‘ s[p][r]⊕m1 .R4.1

[T-⊕]

sbj(R4) = {s[p]}
Γ ‘ R4

where Γ = s[p]:r⊕m1 .

end(∅)

[T-0]

∅ ‘ 0
Γ ‘ cancel(s[p]).0

[T-cancel]

[T-try]

(cid:73) Example A.5 (Typing nested Try-catch with rec aux). Assume R4.2 = s[p][r]⊕m3hs0[r]i.0
and R4.3 = try s0[q][r]⊕m2 .0 catch cancel(s0[q]).0 .

. . .
Γ2 ‘ s[p]:r⊕m1

[T-sub]

Γ4 = {s[p]:Sp}p∈I

s 6∈ Γ3
Γ3 ‘ (cid:0)νs0 :Γ4

safe(Γ4)

Γ ‘ s[p][r]⊕m1 .R4.1

. . .
Γ3 ‘ R4.2

[T-⊕]

. . .
Γ4 ‘ R4.3

Γ3, Γ4 ‘ R4.2 | R4.3

[T-try]

[T-|]

(cid:1) (R4.2 | R4.3)

[T-⊕]

[T-ν]

because m1 does not have any payload and where Γ3 = s[p]:r⊕m3(Ss0[r]) and Γ4 =

s0[q]:r⊕m2, s[p]:end . safe(Γ4) is trivial because it only contains one endpoint.

B

Additional implementation details

B.1 Interleaved sessions in MultiCrusty

In some cases, participants are involved in multiple protocols at the same time, but the
diﬀerent sets of participants are completely disconnected. Instead of having one thread for
each participant of each protocol, we may be tempted to run each shared participant on one
thread. This way, the shared participants will give the rhythm between the diﬀerent protocols
because all theirs operations will run sequentially For instance, in § C, role Controller
can be shared between the two protocols circuit breaker and distributed logging: its related
session will be qualiﬁed as interleaved. We implemented a way to work with such interleaved
sessions: the main idea is that the function which represents the shared function needs two
MeshedChannels as inputs, instead of one for the others. Figure 11a provides an overview
of what the implementation of role Controller would look like. From line 5 to line 11, we
can see that the two endpoints that represent the participant work sequentially: ﬁrst we

E C O O P 2 0 2 2

1:40

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1

2
3

4
5

6
7
8
9
10
11
12
13

1
2

3

4
5

6
7
8
9

type StoAClose = <AtoSClose as Session>::

Dual;

type StoCClose = End;
type StoAVideo<N> = <StoBVideo<N> as

Session>::Dual;

type RecursStoC<N> = Recv<Branches0StoC<N>,

End>;

// Declare the name of the role
type NameS = RoleS<RoleEnd>;

// Declare meshed channel
type EndpointSRecurs<N> = MeshedChannels<

End, RecursStoC<N>, StackSRecurs,
RoleS<RoleEnd>>;

14

15
16

17
18
19
20

21

22
23
24

// Declare usage order of channels for

choice

type StackSEnd = RoleEnd;
type StackSVideo = RoleA<RoleA<RoleC<

RoleEnd>>>;

type StackSRecurs = RoleC<RoleEnd>;

enum ChoiceS<N: marker::Send> {

End(MeshedChannels<StoAClose, StoCClose,

StackSEnd, RoleS<RoleEnd>>),

Video(MeshedChannels<StoAVideo<N>,

RecursStoC<N>, StackSVideo, RoleS<
RoleEnd>>),

}

type RecS<N> = MeshedChannels<End, Recv<

ChoiceS<N>, End>, RoleC<RoleEnd>,
RoleS<RoleEnd>>;

Figure 12 Local Rust types for role S (Server) from Figure 2c

// The types to send the new MeshedChannels
type Choose0fromCtoA<N> = Send<ChoiceA<N>,

End>;

type Choose0fromCtoS<N> = Send<ChoiceS<N>,

End>;

type InitC<N> = Send<N, Recv<N,
Choose0fromCtoA<N>>>;

// Declare the name of the role
type NameC = RoleC<RoleEnd>;

10

11
12

13
14
15

16

// Declare usage order of channels for

choice

type StackCRecurs = RoleBroadcast;
type StackCFull = RoleA<RoleA<StackCRecurs

>>;

// Declare meshed channels
type EndpointCRecurs<N> = MeshedChannels<

Choose0fromCtoA<N>, Choose0fromCtoS<N
>, StackCRecurs, RoleC<RoleEnd>>;
type RecC<N> = MeshedChannels<InitC<N>,

Choose0fromCtoS<N>, StackCFull, RoleC<
RoleEnd>>;

Figure 13 Local Rust types for role C (Client) from Figure 2a

send() and recv() to the participants of the circuit breaker protocol, then we send() on
the distributed logging protocol. Figure 11b shows how to fork the diﬀerent endpoints: the
fork_interleaved() function (line 3), created through the macro create_fork_interleave!,
(line 1), will accept 5 endpoints in our case: one for each participant, grouped by protocol, and
the last argument of fork_interleaved() is always the function representing the interleaved
session. The function returns 5 threads, one for each participant, in the same order as the
arguments.

B.2 Communication primitives

To enable polymorphic behaviour for meshed channels, we leverage Rust generic impl blocks.
In particular, consider the code snippet impl<T> Bar<T>{ fn foo(){...}}. It speciﬁes the
implementation of the function foo() for the structure Bar, parameterised by a generic type
T. Similarly, the gen_mpst! macro generates functions for sending and receiving on meshed
channels.

Generating send/recv communication primitives Figure 14 left (lines 6 – 10) shows
an example of a send() and recv() functions that are generated from gen_mpst!. We explain
the implementation of send(); recv() is similar. The send() function requires a caller of
a type MeshedChannels<S1, Send<T, S2>, RoleS<R>, RoleA<RoleEnd>>. From the types, we
can deduce that this is a meshed channel for the role A, as clear from the last argument
RoleA<RoleEnd>. The next operation on the meshed channel should be a communication with
the binary channel for role S as stipulated by the stack type RoleS<R>. Note that binary

N. Lagaillardie, R. Neykova and N. Yoshida

1:41

channels in a meshed channel are ordered in alphanumerical order. We also see that the
binary channel for role S should be of type Send<T, S2>, which is a channel with capabilities
to send payloads of type T and to return a continuation of type S2. Let us consider that s is
a meshed channels of the given MeshedChannels type, then s.send(p) will send the payload p
of type T on the binary channel between role A and role S.

The return type of the function send() is speciﬁed as RT<S1, S2, R>, which is essentially
a meshed channel encapsulated inside an option type. Remember that all communication
primitives of MultiCrusty return option types: they need to be unwrapped to check ﬁrst
whether they are an error or an expected result, before retrieving the said result. Notice that
the returned meshed channel should have as a binary session type for role S the continuation
S2, the type for the binary channel for role C stays the same as S1 and the stack should be R.
Let us now look at the body of the function, which essentially sends the message of type T
on the binary channel stored in the second ﬁeld, session2 (corresponding to the binary session
with role S), of the meshed channel s. At line 8, the head of the stack ﬁeld is consumed
with s.stack.continuation() and its continuation is returned. Since the communication is
on a binary channel, we reuse the binary send() primitive (line 7) from [36].

Communication Transport To eﬀectively send a message, the binary send() primitive
from [36] uses crossbeam-channel’s primitives, a community-driven alternative library to
the standard Rust library std::sync::mpsc with more features and better performance. As a
consequence, MultiCrusty also relies on the crossbeam-channel message-passing library as
a default transport, included in the standard Rust distribution. However, other transports
are possible. We have chosen the crossbeam-channel library because it provides the best
trade-oﬀ. In comparison, std::sync::mpsc (a standard library of Rust) has fewer features
and worse performance [15].

External and internal choices are implemented as separate macros that require an
argument of type MeshedChannels. The implementation of the external choice, offer_mpst!, is
given in lines 16 – 22. In essence, a choice is implemented as a broadcast. In our usecase, the
active role that makes the choice is role C . Hence, the macro offer_mpst! explicitly performs
a receive (s.recv()) on the meshed channel s. The received value is pattern matched and
passed to any of the functions given as arguments to offer_mpst!. This macro expects only
those two types of arguments: the receiving channel does not need to be provided as the type
of the MeshedChannels is following a strict pattern with only one Recv<enum, End> type and
End types for the rest of the binary types. Similarly, choose_c! in lines 15 – 22 is a macro
that performs a select operation. This macro expects the running session s and two variants
of enum, each one being sent to the corresponding passive role. choose_c! broadcasts the new
choice to every other at lines 19 and 20. The name of choose_c! as well as the number of
expected variants of enum corresponding to the number of passive roles is decided by the
macro gen_mpst!. In our speciﬁc example, role C sends the selected labels l1 and l2 alongside
the new meshed channels s1 and s2 that role A and role S should use to communicate with
role C .

Note that all send(), recv(), offer_mpst! and choose_c! primitives that ﬁt the given
MeshedChannels and roles and all the possible interactions between them are generated
through the macro gen_mpst!.

B.3 Types for aﬃne meshed channels

Meshed channel types – MeshedChannels – correspond to local session types. They describe
the behaviour of each meshed channel and specify which communication primitives are

E C O O P 2 0 2 2

1:42

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1
2

4

5

6
7

8
9

10
11

14
15
16

17
18

19
20

21
22
23

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

pub struct MeshedChannels< S1: Session, S2: Session, R: Role, N: Role> {
pub session1: S1, pub session2: S, pub stack: R, pub name: N }

impl<S1: Session, S2: Session, R: Role, T:

marker::Send>

MeshedChannels<S1, Send<T, S2>, RoleS<R>,

RoleA<RoleEnd>> {

pub fn send(self, x: T) -> RT<S1, S2, R> {
let new_binary_channel = send(x, self.

session2)?;

let new_stack = s.stack.continuation();
// construct and return a new meshed

channel

}

}

#[macro_export]
macro_rules! offer_mpst {

($session: expr, { $( $pat: pat => $result:

expr, )+ }) => {

(move || -> Result<_, _> {

let (l, s) = $session.recv()?; //

receive a label l and a new meshed channel

s

cancel(s);

// Invoke the function matching the label
l
// and pass the new meshed channel s

match l { $( $pat => $result, )* }

})() }; }

4

5

6
7
8

9
10

11

14
15
16
17
18

19
20
21

22

impl<S1: Session, S2: Session, R: Role, T:

marker::Send>

MeshedChannels<S1, Recv<T, S2>, RoleS<R>,

RoleA<RoleEnd>> {

/// Receive a payload from role S
pub fn recv(self) -> RST<T, S1, S2, R> {
let (x, new_binary_channel) = recv(x, self.

session2)?;

let new_stack = s.stack.continuation();
// return x and a newly constructed meshed

channel

} }

#[macro_export]
macro_rules! choose_c($s, $l1, $l2) {

let (s1, s1_dual) = MeshedChannels::new();
let (s2, s2_dual) = MeshedChannels::new();
// create new meshed channels, send to the

passive roles the new labels l1 and l2 and

the new meshed channels s1 and s2

crossbeam::send($l1::(s1), $s.session1);
crossbeam::send($l2::(s2), $s.session2);
// return the last newly created meshed

channels

MeshedChannels { ... } }

Figure 14 AMPST communication primitives in MultiCrusty

// Declare the name of the role
type NameA = RoleA<RoleEnd>;

// Binary session types for A and C
type AtoCVideo<N> = Recv<N, Send<N, Recv<ChoiceA<N>, End>>

// Binary session types for A and S
type AtoSVideo<N> = Send<N, Recv<N, End>>;

// Declare usage order of binary channels inside a meshed channel
type StackAInit = RoleC<RoleEnd>; // for the initial meshed channel
type StackAVideo = RoleC<RoleS<RoleS<RoleC<RoleEnd>>>>; // for branch Video

// Declare the type of the meshed channel
type RecA<N> = MeshedChannels<Recv<ChoiceA<N>, End>, End, StackAInit, NameA>;

// Declare an enum with variants corresponding to the different branches, \ie Video and End
enum ChoiceA<N> {

Video(MeshedChannels<AtoCVideo<N>, AtoSVideo<N>, StackAVideo, NameA>),
Close(MeshedChannels<End, End, RoleEnd, NameA>)

}

Figure 15 Local Rust types for role A (Authenticator) from Figure 2b

permitted on a meshed channel. To better illustrate meshed channel types, we explain the
type RecA<N> for role A (Authenticator) from Figure 2b. The types are displayed in Figure 15.
The types of the meshed channels for the other roles, i.e., C and S are available in Figures 12
and 13 of the Appendix.

Meshed channels consist of (1) binary channels, (2) a stack that stipulates the order of
interactions and (3) the name of the related role. We explain how to declare each of these
below.

N. Lagaillardie, R. Neykova and N. Yoshida

1:43

Declaring meshed channel types Following the protocol, the ﬁrst action on A is an
external choice. Role A should receive a choice from role C of either Video or Close. External
choice is realised in MultiCrusty as an enum with a variant for each branch, where each
variant is parameterised on the meshed channel that will be used for that branch. Hence, the
type for the meshed channel for A must specify that A must ﬁrst receive one of the enum
variants and its corresponding meshed channel. Then, it should use the received meshed
channel to realise the interactions for each branch. This precise behaviour is captured by
the meshed channel type RecA<N> declared at line 15, see Figure 15. Note that, in Rust,
type RecA<N> declares a type alias, not a new type. Here, RecA<N> for a meshed channel
whose binary channel for S (the type Recv<ChoiceA<N>, End> stored at the ﬁrst position in
the meshed channel structure) is expected to receive the enum ChoiceA<N>.

The enum type ChoiceA<N> in line 18 declares two variants with their respective meshed
channels. The branch Close is trivial since no communication apart from closing all channels
is expected in this branch. Hence, the binary channels for S and A, and C and A are
all End. The type of the meshed channel for the branch Video in line 19 is more elaborate.
MeshedChannels<AtoCVideo<N>, AtoSVideo<N>, StackAVideo, NameA> speciﬁes that the type
of the binary channel for C and A is AtoCVideo<N>, the type of the binary channel for role
S and role A is AtoSVideo<N>, the stack of the meshed channel is StackAVideo. The last
argument speciﬁes that this is a meshed channel for role A.

Declaring meshed channel stacks First, let us recap the behaviour for role A in the
Video branch. Role A ﬁrst receives a request from C , then it forwards it to S, it waits to
receive the response from S, and ﬁnally sends it back to C . This sequence of interactions is
captured in the declaration of the stack StackAVideo in line 12. The declaration RoleC<RoleS
<RoleS<RoleC<RoleEnd>>>> speciﬁes the order in which binary channels must the used – ﬁrst
the binary channel with C , then with role S, then with S again, and ﬁnally with C .

Declaring binary session types Finally, we must declare the types for the binary channels
that role A must utilise for communication with role A and role C in the Video branch. The
binary type for role A and role C is type AtoCVideo<N> in line 5. Note that the keyword type
declares an alias, hence the AtoCVideo<N> is an alias for the binary channel type Recv<N, Send
<N, RecvChoiceA<N>>> which speciﬁes that the channel between S and C should be used for
receiving a payload N, then should return a continuation Send<N, Recv<ChoiceA<N>, End>>.
The continuation is another binary session type with capabilities for sending a payload N, and
returning a continuation Recv<ChoiceA<N>, End>. The type for the binary channel between
role A and role S in the Video branch is similar. We remind the reader that role A must
send a request and then wait to receive a response from role S. This is codiﬁed in the type
AtoSVideo<N>, declared in line 8. The type Send<N, Recv<N, End>> says the channel will ﬁrst
be used to send and then to receive.

With the above declarations, we are done specifying all behaviours in the branch Video

and the type declaration for the meshed channel for role A is complete.

Recursive types Note that none of the deﬁned stacks is recursive. Recursion is implicitly
speciﬁed on binary types, and each stack is only related to a MeshedChannels up to either
a choice or the end of the protocol. When a choice occurs, each participant adopts a new
MeshedChannels. To manually detect the recursion in the current protocol, one can see that
the type AtoCVideo, inside the enum ChoiceA, is sent through the variant Video of this enum.
The type AtoCVideo ends with a Recv<ChoiceA<N>, End>, meaning that, in this branch, role
A will receive this enum again, making this branch recursive.

Note also that we assume fair scheduling as in the theory. In the case of fair scheduling,
an inﬁnite reduction (after cancellation) cannot happen. At every remaining step for each

E C O O P 2 0 2 2

1:44

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

role, either it communicates with a non cancelled role and continues with the following steps
or communicates with a cancelled role and cancels itself. At the very end of the protocol,
the close() method sends and receives a unit type from and to every participant, meaning
that every participant will know, at one point, whether a participant has failed or not.

Top-down meets bottom-up The types described so far can be written either by the
developers and veriﬁed using an external tool, k-MC, or generated from a global protocol
written in Scribble. Reception error safety is ensured since the underlying MultiCrusty
library checks statically that all pairs of binary types are dual to each other. Deadlock-
freedom is ensured if meshed channel types are generated from Scribble or veriﬁed using
k-MC. Finally, if errors occur, our implementation ensures all processes in the same session
are safely terminated.

To use the Scribble tool, developers have to specify the global protocol in the protocol
description language Scribble. Examples of the global protocols written in Scribble are
available in Figures 16a and 17a. Then, by running the Scribble toolchain on those protocols,
they can obtain a Rust ﬁle containing all meshed channel types needed to implement the
processes. An example of such generated types is provided in Figure 15. With this Rust ﬁle,
the developers can run the protocol by implementing the processes, such as the ones shown
in Figure 2.

To use the k-MC tool, developers have to write the types and use an MultiCrusty macro
that rewrites all Rust types to CFSMs and invokes the k-MC tool at compile time. However,
they do not have to write the implementation of the processes for the meshed channels,
such as the ones shown in Figure 2. The k-MC tool checks if the system of CFSMs are
k-multiparty compatible. In particular, k-MC performs a k-bounded execution of the set of
CFSM and checks if the system has the progress property (no role gets permanently stuck
in a receiving state) and the eventual reception property (all sent messages are eventually
received). It checks that in all system executions where each channel contains at most k
messages, these properties are respected. Note that well-formed global protocols correspond
to the class of 1-MC safe systems.

Hence, the two approaches (top-down and bottom-up) are complementary and can be
used interchangeably for 1-MC systems. Note, however, that k-MC (and hence MultiCrusty)
potentially allows implementing systems that are safe but cannot be expressed as a global
protocol. In this sense, using the bottom-up approach inherently permits more behaviours.
To stay close to the theory, we have restricted the execution of k-MC to only 1-MC systems,
but the developer can specify the bound as an argument if they wish to explicitly diverge
from the class of 1-MC systems. The bottom-up approach can also be used with other
implementations. The two approaches can also be combined: the types can be generated
from Scribble and then checked by k-MC. However, if the types are generated from Scribble,
they are guaranteed to be compatible, hence no k-MC-check is required. In that sense, the
user can choose if they wish to start from the local types (the types for each communication
channel) and check if they are compatible, or start from the global type (and generate the
types for each communication channel).

C Usecases: distributed logging and circuit breaker

In this section, we present the implementations of two commonly occurring patterns related to
failure – a logging-management protocol and a circuit breaker [18]. Those two usecases were
implemented with MultiCrusty; relevant metrics are available in Table 2. Both protocols
mix complex interactions.

N. Lagaillardie, R. Neykova and N. Yoshida

1:45

1

2
3
4
5
6
7
8
9

10
11
12

13
14
15

16
17
18
19

20
21
22

global protocol Logging(role Controller,

role Supervisor)

{
Start(int) from Controller to Supervisor;

rec Loop {

choice at Supervisor
{

Success(int) from Supervisor to

Controller;
continue Loop;

} or {

Failure(int) from Supervisor to

Controller;

choice at Controller
{

Restart(int) from Controller to

Supervisor;
continue Loop;

} or {

Stop(int) from Controller to Supervisor;

}

}
}}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

fn start_supervisor(s: SInit<i32>) -> R
{

let (_start, s) = s.recv()?;

recurs_supervisor(s) }

fn recurs_supervisor(s: SRec<i32>) -> R {

let status = ... ;
// ping logger to get logger status
if status > 0
{

let s = choose_s!(s, ChoiceC::Success);
let s = s.send(1)?;
recurs_supervisor(s) }

else { failure_supervisor(s) } }

fn failure_supervisor(s: SFail<i32>) -> R {

let s = choose_s!(s, ChoiceC::Failure);
let s = s.send(-1)?;
offer_mpst!(s, {
ChoiceS::Restart(s) => {

let (_restart, s) = s.recv()?;
recurs_supervisor(s) },

ChoiceS::Stop(s) => {

let (_stop, s) = s.recv()?;
s.close() }

} ) }

(a) Scribble protocol

(b) Rust protocol

Figure 16 Distributed logging protocol

The ﬁrst usecase is a protocol for distributed logging management. The Scribble protocol
for this pattern is given in Figure 16a, while the MultiCrusty implementation is in Figure 16b.
We have chosen this protocol because it allows us to exemplify all basic constructs in
Scribble and MultiCrusty. In essence, a logging supervisor ensures that whenever the logging
process fails, it is restarted if requested by the system controller. Note that the protocol
contains two roles only – a system controller (Controller) that deals with the management
of all systems components, and a logger supervisor (Supervisor), a wrapper that controls
the logging service(s). The logging process is not part of the protocol since the supervision
mechanism between a logger and its supervisor is an orthogonal matter; it can be speciﬁed
as another protocol, but we omit it here for simplicity. Initially, the Controller starts the
Supervisor (line 3). The Supervisor monitors the logger process for their status and reports
the status back to the Controller – Success (line 9), or Failure (line 12). If the status is a
Success, the Supervisor keeps monitoring, otherwise, the Supervisor receives a request to
either Restart the failing logger process and continue monitoring the new process (line 15)
or to Stop the protocol (line 19).

The Rust implementation of the supervisor is given in Figure 16b.

It is split into
three methods – start_supervisor(), recurs_supervisor() and failure_supervisor(); each
method takes a meshed channel s and its respective type. The implementation starts with a
start message received from the Controller via the MultiCrusty API call, s.recv()? (line 3).
As explained in § 4.2, the ?-operator at the end of each method is syntactic sugar for
error message propagation. Hence, if the s.recv() at line 3 fails, the whole session will
be safely cancelled, otherwise, the execution continues to line 5 which calls the recursive
function recurs_supervisor(). Line 11 uses the choose_s! macro to perform an internal
choice. ChoiceC is an enum type, while, Success and Failure are variants of the enum. We
remind the reader that all enum types, and their variants (e.g., ChoiceC::Failure, ChoiceS::
Restart, etc) are either generated from Scribble, or written by the user. Their respective

E C O O P 2 0 2 2

1:46

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

1

2
3
4

5
6
7
8
9
10
11
12
13
14
15
16
17
18

19
20

global protocol CBreaker(role Api, role

Controller,

role Storage, Role User)

{
Start(int) from Controller to Storage,

Api;

HardPing(int) from Storage to Controller;
rec Loop {

Request() from User to Api;
GetMode() from Api to Controller;

choice at Controller {

Up() from Controller to Api;
Request(int) from Api to Storage;
Response(int) from Storage to Api;
Response(int) from Api to User;
continue Loop;

} or {

Failure(int) from Controller to Api;
Restart(int) from Controller to

Storage;

Failure(int) from Api to User;
continue Loop; } } }

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

fn endpoint_api(s: AInit<i32>) -> R
{

let (_start, s) = s.recv()?;
recurs_api(s)}

fn recurs_api(s: ARec<i32>) -> R {

let (req, s) = s.recv()?;
let s = s.send(1)?;

offer_mpst!(s, {

ChoiceA::Up => {

let (_, s) = s.recv()?;
let s = s.send(0)?;
let (res, s) = s.recv()?;
let s = s.send(res)?;
recurs_api(s)},

ChoiceA::Failure => {

let (err, s) = s.recv()?;
let s = s.send(err);
recurs_api(s) }

})}

(a) Scribble protocol

(b) Rust protocol

Figure 17 Circuit breaker protocol

name does not matter, as long as the enum and its branches exist.

In particular, choose_s!(s, ChoiceC::Success) sends the label Success to the Controller.
This line corresponds to line 9 from the Scribble protocol in Figure 16a. The Failure
branch (line 12 – 19 in Figure 16a) is implemented in the function failure_supervisor().
First, we send to the Controller the choice label Failure, choose_s!(s, ChoiceC::Failure)
at line 17, then the payload -1 (a failure code), s.send(-1), at line 18. Afterwards, we use
another MultiCrusty primitive, offer_mpst!(s, ...) which is a macro for external choice.
The offer_mpst! macro requires an expression corresponding to each of the enum types –
ChoiceS::Restart and ChoiceS::Stop. If the supervisor receives a Restart label, lines 21 – 22
are executed, otherwise, the Stop message is received, and the session is correctly closed via
s.close() in line 25. Note the diﬀerence between cancel(s) and close(s): the former drops
the channel s, while the latter cleanly and safely closes the channel s. Using close(s) after
cancel(s) will result in a compilation error because s will not be accessible.

The second protocol is presented in Figure 17. This protocol is called a circuit breaker [18].
It can be implemented to protect any scarce resource in the system. In this case, we showcase
the pattern using a storage process. The protocol includes four roles – a system controller
(Controller); a proxy (Api), a Storage that represents a scarce resource, and a User. As
shown in Figure 17a, initially, the Controller starts both the Storage and the Api (line 4). At
each iteration, the Api checks the status of the Storage by querying the Controller (line 8).
If the Controller decides that the Storage can handle requests, then the Api forwards any
incoming Requests from the User (lines 11 – 15). Otherwise, the Api immediately sends a
default Failure to the User (line 19), while the Controller attempts to Restart the Storage
process (line 18).

The implementation of the Api role is given in Figure 17b. It uses the same primitives
as in the previous example, and precisely follows the protocol. Similarly to the previous
example to check for cancellation we use the ?–operator after each send() and recv(). If
any of the communicating actions fail, the notiﬁcation of the failure will propagate to the
relevant processes.

N. Lagaillardie, R. Neykova and N. Yoshida

1:47

D Related work: extension

D.1 Aﬃne typing systems, exceptions and error-handling in session

types

We discuss related works which treat aﬃnity, exceptions and error-handling in session types
(except [25] discussed in the previous paragraph), focusing on recent work. [8] ﬁrst proposes
asynchronous exceptions in binary session types; and [7] extends it to multiparty session types.
Both works are theoretical only. [1] introduces session types for links failures, and extend
session types with an optional block surrounding a process and containing default values used
when a failure occurs. This default value, returned in case of a failure, has to be declared
by developers. [60] provide a formalism and typing discipline for handling crash failure in
asynchronous distributed systems, alongside a domain-speciﬁc language based on ZooKeeper,
a niche language unlike Rust. Besides explicitly raised application-level failures, it also
handles participant crashes, but not concurrent failures nor the spreading of failure messages
to all participants involved in the protocol.
[13] model an
interruptible session where exceptions are explicitly handled by declared participants. They
syntactically extended Scribble with special interruptible blocks, and implement runtime
monitoring in Python. Their models are limited to global types (no endpoint processes),
and their implementations require runtime checking, while MultiCrusty ensures fully static
safety and liveness.

[1, 60] is limited to theory.

[45] proposed aﬃne binary session types with explicit cancellation, which [21] extend
to deﬁne Exceptional GV for binary asynchronous communication. Exceptions can be
nested and handled over multiple communication actions, and their implementation is an
extension of the research language Links.
[45] is limited to the theory, and both [45, 21] are
limited to binary and linear logic-based session types without recursive session types.2 In
addition, the progress proof in [45] requires either a parallel composition with a characteristic
process at each active preﬁxed session process [45]. As a result, a global termination for
cancellation among more than two participants, like Theorem 3.27 and Corollary 3.25, cannot
be guaranteed in their systems.

[61] proposed a theory to extend MPST with fault-tolerance. The implementation is in
Scala and is integrated with Apache Spark. Linearity is checked dynamically. Unlike our
theory, they assume the existence of resilient components (such as monitors and robust roles)
that cannot fail. Upon failure a session can continue by skipping the interactions with the
faulty components. This can be problematic in a real case scenario where a faulty participant
handles critical information required by others to actually progress.

D.2 Code generation: MultiCrusty for an arbitrary number of roles

Currently, we have only demonstrated a communication API for three hard-coded roles, but
our code generation facilities provide utility functions for generating API for an arbitrary
number of roles, parametric on the role names. In essence, each generated function is a
generalisation of the functions presented in Figure 18. We will show only the most important
of the code-generation functions – the one that generates a new AMPST structure. All utility
functions are implemented as Rust macros. Rust supports two types of macros – regular
and procedural, we utilise both. The former are expanded into a syntactic form during

2 The ﬁrst author’s thesis [20] discusses how to extend [21] to recursive types by adding recursions at the

term level.

E C O O P 2 0 2 2

1:48

Stay Safe under Panic: Aﬃne Rust Programming with Multiparty Session Types

compilation, before any static checking, while the latter is a function over the Rust AST and
creates syntax extensions.

1
2

3
4

5
6
7

8
9
10
11
12
13
14
15
16
17
18
19
20
21

// The procedural macro
let sessions: Vec<proc_macro2::TokenStream> = ... //
Creates """S#N ,""" for #N from 1 to nsessions (
excluded)

...
quote! { // Concatenates the previous code with specific

code

...
pub struct #meshedchannels_name<

#( #sessions )* // Include the content of *sessions*

R, N

>
where

#( #sessions_struct )*
R: mpstthree::role::Role,
N: mpstthree::role::Role

{

#( #sessions_pub )*
pub stack: R,
pub name: N,

}
...

}

22
23

24
25
26
27
28
29

30

31

32
33
34
35
36
37
38
39
40
41
42

// The regular macro usage
create_meshedchannels!(

MeshedChannelsFour, 4);

// Structure created:
//
// MeshedChannelsFour<
//

S1: mpstthree::binary::
Session,
S2: mpstthree::binary::
Session,
S3: mpstthree::binary::
Session,
R: mpstthree::role::Role,
N: mpstthree::role::Role,

pub session1: S1,
pub session1: S2,
pub session1: S3,
stack: R,
name: N,

//

//

//
//
// > {
//
//
//
//
//
// }
// ...

Figure 18 Code to generate the new MeshedChannels for multiple participants

Figure 18 (left) shows the macro that generates MPST structure with an arbitrary
number of roles, Figure 18 (right) shows its usage for creating MPST structure with four
participants, along with the generated structure. The macro inputs for the regular macro
(line 23) are the name of the structure and the number of roles, and are passed to the
procedural macro. mpst_seq::create_meshedchannels calls a method that creates the code
with quote!, using the arguments provided by the user. After retrieving the arguments, the
macro creates the diﬀerent groups of ident, such as sessions (line 2). Those Vec contain
the blocks of code that are repeated, such as S1 , S2 , S3 ,, . . . for sessions. The ... at
line 3 materialises the other Vec that are created. Those groups are concatenated along with
complementary code between lines 4 and 20. The rest of the code, materialised with ...
at line 19, contain the methods for the new structure. The line 23 displays the usage of
the regular macro for developers, and the code created for 4 participants is show between
lines 28 and 41.

The most intricate part when implementing multiparty channel is the
mapping between binary channels and their name in their index in the
MPST structure. When the session starts, all the newly created binary
channels should be correctly distributed among all roles. We will rely
on the kind of structure displayed in Figure 19. The ﬁgure demonstrates
the distribution for a protocol involving 4 roles. The headers, column
and row, contain the diﬀerent roles, and the rest details the index of the
channels between two participants. This is a skew-symmetric matrix,
where each number on the top right has an opposite in the bottom
left. A negative number means that the role on the corresponding
row will receive the dual of the binary session type of the role on the
corresponding column.

a

-1
-2
-3

b
1

-4
-5

a
b
c
d

Figure
Distribution
the
branching
participants

channels

for

d
3
5
6

c
2
4

-6

19
of
for
4

