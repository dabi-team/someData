TBPLaS: A TIGHT-BINDING PACKAGE FOR LARGE-SCALE
SIMULATION

Yunhai Li, Zhen Zhan, Yonggang Li
Key Laboratory of Artiﬁcial Micro- and Nano-structures of Ministry of Education and
School of Physical Science and Technology
Wuhan University
Wuhan 430072, China

Shengjun Yuan∗
Key Laboratory of Artiﬁcial Micro- and Nano-structures of Ministry of Education and
School of Physical Science and Technology
Wuhan University
Wuhan 430072, China
Wuhan Institute of Quantum Technology
Wuhan 430206, China
E-mail: s.yuan@whu.edu.cn

ABSTRACT

TBPLaS is an open-source software package for the accurate simulation of physical systems with
arbitrary geometry and dimensionality utilizing the tight-binding (TB) theory. It has an intuitive
object-oriented Python application interface (API) and Cython/Fortran extensions for the performance
critical parts, ensuring both ﬂexibility and efﬁciency. Under the hood, numerical calculations are
mainly performed by both exact diagonalizatin and the tight-binding propagation method (TBPM)
without diagonalization. Especially, the TBPM is based on the numerical solution of time-dependent
Schrödinger equation, achieving linear scaling with system size in both memory and CPU costs.
Consequently, TBPLaS provides a numerically cheap approach to calculate the electronic, transport
and optical properties of large tight-binding models with billions of atomic orbitals. Current ca-
pabilities of TBPLaS include the calculation of band structure, density of states, local density of
states, quasi-eigenstates, optical conductivity, electrical conductivity, Hall conductivity, polarization
function, dielectric function, plasmon dispersion, carrier mobility and velocity, localization length
and free path, Z2 topological invariant, wave-packet propagation, etc. All the properties can be
obtained with only a few lines of code. Other algorithms involving tight-binding Hamiltonians can
be implemented easily thanks to its extensible and modular nature. In this paper, we discuss the
theoretical framework, implementation details and common workﬂow of TBPLaS, and give a few
demonstrations of its applications. The source code and detailed documentation are available at
www.tbplas.net.

Keywords Tight-binding · Tight-binding propagation method · Electronic structure · Response properties · Mesoscopic
scale · Moiré superlattice

2
2
0
2

p
e
S
2

]
i
c
s
-
l
r
t

m

.
t
a
m
-
d
n
o
c
[

1
v
6
0
8
0
0
.
9
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
1

Introduction

Computational modelling is an essential tool for both fundamental and applied researches in the condensed matter
community. Among the widely used modelling tools, the tight-binding (TB) method is popular in both quantum
chemistry and solid state physics [1, 2], which can provide a fast and accurate understanding of the electronic
structures of crystals with small unit cells, or large complex systems with/without translational symmetry. The TB
method investigates electronic structure via both exact diagonalization and non-diagonalization techniques. With
exact diagonalization, the TB method can tackle crystalline structures containing up to tens of thousands of orbitals in
the unit cell. With non-diagonalization techniques, for instance the the Tight-Binding Propagation Method (TBPM)
[3, 4, 5, 6, 7] and the recursion technique [8], large systems with up to billions of orbitals can be easily handled.

Recently, a plethora of exotic properties, such as superconductivity [9, 10, 11], correlated insulator [12, 13, 14],
charge-ordered states [15], ferromagnetism [16], quantum anomalous Hall effect [17] and unconventional ferroelectricity
[18], are constantly observed in moiré superlattices, which are formed by stacking single layers of two-dimensional (2D)
materials on top of each other with a small misalignment [19]. To facilitate the exploration of the physical phenomena
in the moiré superlattices, theoretical calculations are utilized to provide accurate and robust predictions. In the moiré
patterns, the loss of angstrom-scale periodicity poses an obviously computing challenge. For instance, in twisted bilayer
graphene (TBG) with rotation angle of 1.05◦–the so-called magic angle, the number of atoms in a supercell is 11908,
which is too large for state-of-the-art ﬁrst-principles methods. On the contrary, the TB method has been proved to
be a simple and effective approach to investigate the electronic structure of moiré pattern [20]. More importantly,
with the real-space TB method, the substrate effects, strains, disorders, defects, electric and magnetic ﬁelds and many
other external perturbations can be naturally implemented via the modiﬁcations of the tight-binding parameters [3, 21].
Therefore, the TB method provides a more powerful framework to tackle realistic materials fabricated in the laboratory.

There are some open source software packages implementing the TB method and covering different aspects of
the modelling of quantum transport and electronic structure. For example, Kwant is a Python package for numerical
calculations of quantum transport of nanodevices from the transmission probabilities, which is based on the Landauer-
Buttiker formalism and the wave function-matching technique [22]. PythTB is a Python package for the construction
and solution of simple TB models [23]. It includes the tools for calculating quantities that are related to Berry phases
or curvatures. Pybinding is a package with a Python interface and a C++ core, which is based on both the exact
diagonalization and the kernel polynomial method (KPM) [24]. Technically, KPM utilizes convolutions with a kernel to
attenuate the Gibbs oscillations caused by discontinuities or singularities, and is a general tool to study large matrix
problems [25]. In Pybinding, the KPM is adopted to model complex systems with disorder, strains or external
ﬁelds. The software supports numerical calculations of band structures, density of states (DOS), local density of states
(LDOS) and conductivity. TBTK is a C++ software development kit for numerical calculations of quantum mechanical
properties [26]. Particularly, it is also based on the KPM and designed for accurate real-space simulations of electronic
structure and quantum transport properties of large-scale molecular and condensed systems with tens of billions of
atomic orbitals [27]. KITE is an open-source software with a Python interface and a C++ core, which is based on
the spectral expansions methods with an exact Chebyshev polynomial expansion of Green’s function [28]. Several
functionalities are demonstrated, ranging from calculations of DOS, LDOS, spectral function, DC conductivity, AC
conductivity and wave-packet propagation. MathemaTB is a Mathematica package for TB calculations, which provides
62 functionalities to carry out matrix manipulation, data analysis and visualizations on molecules, wave functions,
Hamiltonians, coefﬁcient matrices, and energy spectra [29].

Previous implementations of the TB method have so far been limited to simple models or have limited functionalities.
Therefore, we have developed the TBPM method, which is based on the numerical solution of time-dependent
Schrödinger equation (TDSE) without any diagonalization [4]. The core concepts of TBPM are the correlation
functions, which are obtained directly from the time-dependent wave function and contain part of the features of the
Hamiltonian. With enough small time step and long propagation time, the whole characteristics of the Hamiltonian
can be captured. The correlation functions are then analyzed to yield the desired physical quantities. Compared to
exact diagonalization whose costs of memory and CPU time scale as O(N2) and O(N3), TBPM has linear scaling in
both resources, allowing us to deal with models containing tens of billions of orbitals. Moreover, the calculations
of electronic, optical, and transport properties can be easily implemented in TBPM without the requirement of any
symmetries. Other calculations involving the TB Hamiltonian can also be implemented easily.

We implement TBPM in the open source software package named Tight-Binding Package for Large-scale Simulation,
or TBPLaS in shot. In TBPLaS, TB models can be constructed from scratch using the the application interface (API),
or imported from Wannier90 output ﬁles directly. Physical quantities can be obtained via four methods: (i) exact
diagonalization to calculate the band structure, DOS, eigenfunction, polarization function [30] and optical (AC)
conductivity ; (ii) recursive Green’s function to get LDOS [31, 32]; (iii) Kernel polynomial method to obtain electrical
(DC) and Hall conductivity [33, 34]; (iv) TBPM to calculate DOS, LDOS, carrier density, AC conductivity, absorption

ii

spectrum, DC conductivity, time-dependent diffusion coefﬁcient, carrier velocity and mobility, elastic mean free
path, Anderson localization length, polarization function, response function, dielectric function, energy loss function,
plasmon dispersion, plasmon lifetime, damping rate, quasi-eigenstate, real-space charge density, and wave packet
propagation [3, 35, 36, 37, 38, 39, 6, 34, 40]. At the core of TBPLaS, we use TBPM to achieve nearly linear scaling
performance. Furthermore, crystalline defects, vacancies, adsorbates, charged impurities, strains and external electric
and/or magnetic can be easily set up with TBPLaS’s API. These features make it possible for the simulation of systems
with low concentrations of disorder [3, 41] or large unit cells, such as twisted bilayer and multilayer systems [7]. What
is more, the computations are performed in real space, so it also allows us to consider systems that lack translation
symmetry, such as fractals [42, 43] and quasicrystals [44, 45].

The numerical calculations in TBPLaS are separated into two stages. In the ﬁrst stage, the TB model is constructed in
Python using the API in an intuitive object-oriented manner. Many of the concepts of the API are natural in solid state
physics, such as lattices, orbitals, hopping terms, vacancies, external electric and magnetic ﬁelds, etc. In the second
stage, the Hamiltonian matrix is set up from the TB model and passed to backends written in Cython and Fortran,
where the quantities are calculated by using either exact diagonalization, recursion method, KPM or post-processing of
the correlation functions obtained from the TBPM. The advantage of the two-state paradigm is that it provides both
excellent ﬂexibility and high efﬁciency. Up to now, TBPLaS has been utilized to investigate the electronic structures
of a plenty of 2D materials, such as graphene [7, 31], transition metal dichalcogenides [30, 46], tin disulﬁde [47],
arsenene [48], antimonene [49], black phosphorus [33, 41], tin diselenide [50], MoSi2N4 [51]. Moreover, TBPLaS is a
powerful tool to tackle complex systems, for example, graphene with vacancies [35, 36, 38], twisted multilayer graphene
[31, 52, 53, 54], twisted multilayer transition metal dichalcogenides [55, 46, 30], graphene-boron nitride heterostructures
[7, 56], dodecagonal bilayer graphene quasicrystals [44, 57, 58, 45, 59] and fractals [42, 43, 60, 61, 62, 63].

The paper is organized as following. In Sec. 2 we discuss the concepts and theories of TBPM and other methods.
Then the implementation details of TBPLaS are described in Sec. 3, followed by the usages in Sec. 4. In Sec. 5, we give
some examples of calculations that can be done with TBPLaS. Finally, in Sec. 6 we give the conclusions, outlooks and
possible future developments.

iii

2 Methodology

In this section, we discuss brieﬂy the underlying concepts and theories of TBPLaS with which to calculate the
electronic, optical, and transport properties. Note that if not explicitly given, we will take (cid:126) = 1 and omit it from the
formula.

2.1 Tight-binding models

The Hamiltonian of any non-periodic system containing n orbitals follows

(cid:88)

ˆH =

(cid:15)ic†

i ci −

i

tijc†

i cj

(cid:88)

i(cid:54)=j

which can be rewritten in a compact matrix form

with

ˆH = c†Hc

(cid:104)

(cid:104)

c† =

c =

1, c†
c†

2, · · · , c†
n

c1, c2, · · · , cn

(cid:105)

(cid:105)T

Hij = (cid:15)iδij − tij(1 − δij)

(1)

(2)

(3)

(4)

(5)

Here (cid:15)i denotes the on-site energy of orbital i, tij denotes the hopping integral between orbitals i and j, c† and c are the
creation and annihilation operators, respectively. The on-site energy (cid:15)i is deﬁned as

and the hopping integral tij is deﬁned as

(cid:90)

(cid:15)i =

i (r)ˆh0(r)φi (r)dr
φ∗

(cid:90)

tij = −

i (r)ˆh0(r)φj (r)dr
φ∗

with ˆh0 being the single-particle Hamiltonian

(6)

(7)

(cid:126)2

ˆh0(r) = −

∇2 + V (r)

2m
and φi being the reference single particle state. In actual calculations, the reference states are typically chosen to
be localized states centered at τi, e.g., atomic wave functions or maximally localized generalized Wannier functions
(MLWF). The on-site energies and hopping integrals can be determined by direct evaluation following Eq. (6)-(8), the
Slater-Koster formula [1, 64], or numerical ﬁtting to experimental or ab initio data. Once the parameters are determined,
the eigenvalues and eigenstates can be obtained by diagonalizing the Hamiltonian matrix deﬁned in Eq. (5).

(8)

For periodic systems, the reference state gets an additional cell index R

φiR(r) = φi(r − R)

We deﬁne the Bloch basis functions and creation (annihilation) operators by Fourier transform

χik(r) =

c†
i (k) =

ci (k) =

1
√
N

1
√
N

1
√
N

(cid:88)

R
(cid:88)

R
(cid:88)

R

eik·(R+τi)φiR(r)

eik·(R+τi)c†

i (R)

e−ik·(R+τi)ci (R)

where N is the number of unit cells. Then the Hamiltonian in Bloch basis can be written as

ˆH = N

(cid:88)





(cid:88)

(cid:15)ic†

i (k)ci (k) −

(cid:88)

k

i∈uc

R(cid:54)=0∨i(cid:54)=j

iv

tij(R)eik·(R+τj −τi)c†

i (k)cj(k)





(9)

(10)

(11)

(12)

(13)

Here the third summation is performed for all cell indices R and orbital pairs (i, j), except the diagonal terms with
R = 0 and i = j. The Hamiltonian can also be rewritten in matrix form as

(14)

(15)

(16)

(17)

with

c†(k) =

c(k) =

ˆH = N

(cid:88)

c†(k)H(k)c(k)

k

(cid:104)
1(k), c†
c†

2(k), · · · , c†

(cid:105)
n(k)

(cid:104)
c1(k), c2(k), · · · , cn(k)
(cid:88)

(cid:105)T

Hij(k) = (cid:15)iδij −

tij(R)eik·(R+τj −τi)

Here tij(R) being the hopping integral between φi0 and φjR.

R(cid:54)=0∨i(cid:54)=j

There is another convention to construct the Bloch basis functions and creation (annihilation) operators, which

excludes the orbital position τi in the Fourier transform
1
√
N

χik(r) =

c†
i (k) =

ci (k) =

1
√
N

1
√
N

eik·RφiR(r)

eik·Rc†

i (R)

e−ik·Rci (R)

(cid:88)

R
(cid:88)

R
(cid:88)

R

Then Eq. (17) becomes

Hij(k) = (cid:15)iδij −

(cid:88)

tij(R)eik·R

R(cid:54)=0∨i(cid:54)=j

(18)

(19)

(20)

(21)

Both conventions have been implemented in TBPLaS, while the ﬁrst convention is enabled by default.

External electric and magnetic ﬁelds can be introduced into the tight-binding model by modifying the on-site energies

and hopping integrals. For example, homogeneous electric ﬁelds towards −z direction can be described by

(cid:15)i → (cid:15)i + E · (zi − z0)

(22)

where E is the intensity of electric ﬁeld, zi is the position of orbital i along z-axis, and z0 is the position of zero-potential
plane. Magnetic ﬁelds, on the other hand, should be described by the vector potential A and Peierls substitution [65]
(cid:19)

(cid:18)

(cid:19)

(cid:90) j

(cid:90) j

tij → tij · exp

i

A · dl

= tij · exp

A · dl

(23)

e
(cid:126)c

i

(cid:18)
i

2π
Φ0

i

where (cid:82) j
i A · dl is the line integral of the vector potential from orbital i to orbital j, and Φ0 = ch/e is the ﬂux quantum.
For homogeneous magnetic ﬁeld towards −z, we follow the Landau gauge A = (By, 0, 0). Note that for numerical
stability, the size of the system should be larger than the magnetic length.

Finally, we mention that we have omitted the spin notations in above formulation for clarity. However, spin-related
terms such as spin-orbital coupling, can be easily incorporated into the Hamiltonian and treated in the same approach in
TBPM and TBPLaS.

2.2 Tight-Binding Propagation Method

Exact diagonalization of the Hamiltonian matrix in Eq. (5), (17) and (21) yields the eigenvalues and eigenstates of
the model, eventually all the physical quantities. However, the memory and CPU time costs of exact diagonalization
scale as O(N2) and O(N3) with the model size N , making it infeasible for large models. The TBPM, on the contrary,
tackles the eigenvalue problem with a totally different philosophy. The memory and CPU time costs of TBPM scale
linearly with the model size, so models with tens of billions of orbitals can be easily handled.

In TBPM, a set of randomly generated states are prepared as the initial wave functions. Then the wave functions are

propagated following

|ψ(t)(cid:105) = e−i ˆHt|ψ(0)(cid:105)

(24)

v

and correlation functions are evaluated at each time step. The correlation functions contain a fraction of the features of
the Hamiltonian. With enough small time step and long propagation time, the whole characteristics of the Hamiltonian
will be captured. Finally, the correlation functions are averaged and analyzed to yield the physical quantities. Taking
the correlation function of DOS for example, which is deﬁned as

It can be proved that the inner product is related to the eigenvalues via

CDOS(t) = (cid:104)ψ(0)|ψ(t)(cid:105)

(cid:104)ψ(0)|ψ(t)(cid:105) =

(cid:88)

ijk

UkjU ∗

ijai a∗

ke−i(cid:15)j t

(25)

(26)

with (cid:15)j being the j-th eigenvalue, Ukj being the k-th component of j-th eigenstate, respectively. The initial wave
function ψ(0) is a random superposition of all basis states

|ψ(0)(cid:105) =

(cid:88)

i

ai |φi(cid:105)

(27)

where ai are random complex numbers with (cid:80)
i |ai|2 = 1, and φi are the basis states. It is clear that the correlation
function can be viewed as a linear combination of oscillations with frequencies of (cid:15)j. With inverse Fourier transform,
the eigenvalues and DOS can be determined.

To propagate the wave function, one needs to numerically decompose the time evolution operator. As the TB
Hamiltonian matrix is sparse, it is convenient to use the Chebyshev polynomial method for the decomposition, which is
proved to be unconditionally stable for solving TDSE [66]. Suppose x ∈ [−1, 1], then

e−izx = J0(z) + 2

∞
(cid:88)

(−i)mJm(z)Tm(x)

i=1

(28)

where Jm(z) is the Bessel function of integer order m, Tm(x) = cos [m arccos x] is the Chebyshev polynomial of the
ﬁrst kind. Tm(x) follows a recurrence relation as

Tm+1(x) + Tm−1(x) = 2xTm(x)
To utilize the Chebyshev polynomial method, we need to rescale the Hamiltonian as ˜H = ˆH/|| ˆH|| such that ˜H has
eigenvalues in the range [−1, 1]. Then, the time evolution of the states can be represented as

(29)

(cid:34)

|ψ(t)(cid:105) =

J0(˜t) ˆT0( ˜H) + 2

(cid:35)

Jm(˜t) ˆTm( ˜H)

|ψ(0)(cid:105)

∞
(cid:88)

m=1

(30)

where ˜t = t · || ˆH||, Jm(˜t) is the Bessel function of integer order m, ˆT ( ˜H) is the modiﬁed Chebyshev polynomials,
which can be calculated up to machine precision with the recurrence relation

with

ˆTm+1( ˜H)|ψ(cid:105) = −2i ˜H ˆTm( ˜H)|ψ(cid:105) + ˆTm−1( ˜H)|ψ(cid:105)

ˆT0( ˜H)|ψ(cid:105) = |ψ(cid:105),

ˆT1( ˜H)|ψ(cid:105) = −i ˜H|ψ(cid:105)

(31)

(32)

The other operators appear in TBPM can also be decomposed numerically using the Chebyshev polynomial method.

A function f (x) whose values are in the range [-1, 1] can be expressed as

f (x) =

1
2

c0T0(x) +

∞
(cid:88)

k=1

ckTk(x)

where Tk(x) = cos (k arccos x) and the coefﬁcients ck are

ck =

2
π

(cid:90) 1

−1

√

dx
1 − x2

f (x)Tk(x)

Assume x = cos θ and substitute it into Eq. (34), we have
(cid:34)

ck =

f (cos θ) cos kθdθ = Re

2
π

(cid:90) π

0

2
π

N −1
(cid:88)

n=0

(cid:18)

f

cos

(cid:19)

2πn
N

exp

(cid:18)
i

2πn
N

k

(cid:19)(cid:35)

(33)

(34)

(35)

vi

which can be calculated by fast Fourier transform. For the Fermi-Dirac operator as frequently used in TBPM, it is
more convinced to expressed it as f = ze−βH /(1 + ze−βH ) [3], where z = eβµ is the fugacity, β = 1/kBT , kB
is the Boltzmann constant, T is the temperature and µ is the chemical potential. We set ˜H = H/||H|| such that its
eigenvalues are within [-1, 1] and deﬁne ˜β = β · ||H||, then
ze− ˜β ˜H
1 + ze− ˜β ˜H

ckTk( ˜H)

f ( ˜H) =

∞
(cid:88)

(36)

=

k=0

where ck are the Chebyshev expansion coefﬁcients of the function f (x) = ze− ˜βx/(1 + ze− ˜βx). The Chebyshev
polynomials Tk( ˜H) have the following recursion relation

Tk+1( ˜H) − 2 ˜HTk( ˜H) + Tk−1( ˜H) = 0

T0( ˜H) = 1,

T1( ˜H) = ˜H

(37)

(38)

with

For more details we refer to Ref. [3].

2.3 Band structure

The band structure of a periodic system can be determined by diagonalizing the Hamiltonian matrix in Eq. (17)
or (21) for a list of k-points. Both conventions yield the same band structure. Typically, the k-points are sampled on
a k-path connecting highly symmetric k-points in the ﬁrst Brillouin zone. A recommended set of highly symmetric
k-points can be found in Ref. [67].

2.4 Density of states

In TBPLaS, we have two approaches to calculate DOS. The ﬁrst approach is based on exact diagonalization, which
consists of getting the eigenvalues of the Hamiltonian matrix on a dense k-grid, and a summation over the eigenvalues
to collect the contributions

D(E) =

δ(E − (cid:15)ik)

(39)

(cid:88)

ik
where (cid:15)ik is the i-th eigenvalue at point k. In actual calculations the delta function is approximated with Gaussian or
Lorentzian functions, which are deﬁned as

G(E − (cid:15)ik) =

√

1
2πσ

(cid:20)

exp

−

(cid:21)

(E − (cid:15)ik)2
2σ2

and

where σ is the broadening parameter.

L(E − (cid:15)ik) =

1
πσ

σ2
(E − (cid:15)ik)2 + σ2

(40)

(41)

The other approach is the TBPM method, which evaluates the correlation function according to Eq. (25). DOS is

then calculated by inverse Fourier transform of the averaged correlation function

D(E) =

1
S

S
(cid:88)

p=1

1
2π

(cid:90) ∞

−∞

eiEtCDOS(t)dt

(42)

Here S is the number of random samples for the average. The inverse Fourier transform in Eq. (42) can be performed
by fast Fourier transform, or integrated numerically if higher energy resolution is desired. We use a window function to
alleviate the effects of the ﬁnite time used in the numerical time integration of TDSE. Currently, three types of window
functions have been implemented, namely Hanning window[68], Gaussian window and exponential window.

The statistical error in calculation of DOS follows 1/

SN , where N is the model size. Thus the accuracy can be
improved by either using large models or averaging over many initial states. For a large enough model (> 108orbitals),
the initial state is already a superposition of all the eigenstates. Thus one random initial state is enough to ensure
convergence. The same conclusion holds for other quantities from TBPM. The energy resolution of DOS is determined
by the number of propagation steps. Distinct eigenvalues that differ more than the resolution appear as separate peaks
in DOS. If the eigenvalue is isolated from the rest of the spectrum, then the number of propagation steps determines
the width of the peak. More details about the methodology of calculating DOS can be found in Ref. [3, 4]. We
emphasize that the 1/
SN dependence of the statistical error is a general conclusion which is also valid for other
quantities calculated with TBPM, and the above discussions for improving accuracy and energy resolution work for
these quantities as well.

√

√

vii

2.5 Local density of states

TBPLaS provides three approaches to calculate the local density of states (LDOS). The ﬁrst approach is based on

exact diagonalization, which is similar to the evaluation of DOS

di(E) =

(cid:88)

jk

δ(E − (cid:15)jk)|Uijk|2

(43)

where Uijk is the i-th component of j-th eigenstate at point k. The second approach is the TBPM method, which also
has much in common with DOS. The only difference is that the initial wave function |ψ(0)(cid:105) in Eq. (25) is redeﬁned.
For instance, to calculate the LDOS on a particular orbital i, we set only the component ai in Eq. (27) as nonzero. Then
the correlation function can be evaluated and analyzed in the same approach as DOS, following Eq. (25) and (42). It
can be proved that in this case the correlation function becomes

(cid:104)ψ(0)|ψ(t)(cid:105) =

|Uijai|2e−i(cid:15)j t

(cid:88)

j

(44)

which contains the contributions from the i-th components of all the eigenstates.

The third approach evaluates LDOS utilizing the recursion method in real space based on Lanczos algorithm[8, 69].

The LDOS on a particular orbital i is

di(E) = − lim
(cid:15)→0+

1
π

Im(cid:104)φi|G(E + i(cid:15))|φi(cid:105)

(45)

Then, we use the recursion method to obtain the diagonal matrix elements of the Green’s function G(E)

G0(E) = (cid:104)l0|G(E)|l0(cid:105)

1/(E − a1 − b2
where l0 is a unit vector with non-zero component at orbital i only. The elements an and bn are determined with the
following recursion relation

= 1/(E − a0 − b2

2/(E − a2 − b2

3/ . . . )))

(46)

ai = (cid:104)li |H| li(cid:105)

|mi+1(cid:105) = (H − ai)|li(cid:105) − bi|li−1(cid:105)

bi+1 = (cid:112)(cid:104)mi+1|mi+1(cid:105)
1
bi+1

|mi+1(cid:105)

|li+1(cid:105) =

(47)
(48)

(49)

(50)

with |l−1(cid:105) = |0(cid:105).

2.6 Quasieigenstates

For a general Hamiltonian in Eq. (1) and for samples containing millions of orbitals, it is computationally expensive
to get the eigenstates by exact diagonalization. An approximation of the eigenstates at a certain energy E can be
calculated without diagonalization following the method in Ref. [3], which has been introduced for the calculation of
electric transport properties of large complex models. With an inverse Fourier transform of the time-dependent wave
function |ψ(t)(cid:105), one gets the following expression

which can be normalized as

|Ψ(E)(cid:105) =

=

=

(cid:90) ∞

eiEt|ψ(t)(cid:105)dt

−∞

(cid:88)

ai

i

(cid:90) ∞

−∞

ei(E−Ei)t|φi(cid:105)dt

aiδ(E − Ei)|φi(cid:105)

1
2π
1
2π
(cid:88)

i

| ˜Ψ(E)(cid:105) =

1

(cid:112)(cid:80)

i |ai|2δ(E − Ei)

(cid:88)

i

aiδ(E − Ei)|φi(cid:105)

viii

(51)

(52)

Here, Ei is the i-th eigenvalue of the scaled Hamiltonian ˜H. Note that | ˜Ψ(E)(cid:105) is an eigenstate if it is a single (non-
degenerate) state[70], or a superposition of the degenerate eigenstates with the energy E. That is why it is called
the quasieigenstate. Although | ˜Ψ(E)(cid:105) is written in the energy basis, the time-dependent wave function |ψ(t)(cid:105) can
be expanded in any orthogonal and complete basis sets. Two methods can be adopted to improve the accuracy of
quasieigenstates. The ﬁrst one is to perform inverse Fourier transform on the states from both positive and negative
time, which keeps the original form of the integral in Eq. (51). The other method is to multiply the wave function
|ψ(t)(cid:105) by a window function, which improves the approximation to the integrals. Theoretically, the spatial distribution
of the quasieigenstates reveals reveals directly the electronic structure of the eigenstates with certain eigenvalue. It has
been proved that the LDOS mapping from the quasieigenstates is highly consistent with the experimentally scanning
tunneling microscopy dI/dV mapping [31].

2.7 Optical conductivity

In TBPLaS, we use both TBPM and exact diagonalization-based methods to compute the optical conductivity [71]. In
the TBPM method, we combine the Kubo formula with the random state technology. For a non-interacting electronic
system, the real part of the optical conductivity in direction α due to a ﬁeld in direction β is (omitting the Drude
contribution at ω = 0)[3]

Re σαβ((cid:126)ω) = lim
E→0+

e−β(cid:126)ω − 1
(cid:126)ωA

(cid:90) ∞

0

e−Et sin(ωt) × 2Im(cid:104)ψ|f (H)Jα(t)[1 − f (H)]Jβ|ψ(cid:105)dt

(53)

Here, A is the area or volume of the model in two and three dimensional cases, respectively. For a generic tight-binding
Hamiltonian, the current density operator is deﬁned as

J = −

ie
(cid:126)

(cid:88)

i,j

tij(ˆrj − ˆri)c†

i cj

where ˆr is the position operator. The Fermi-Dirac distribution deﬁned as

f (H) =

1
eβ(H−µ) + 1

(54)

(55)

In actual calculations, the accuracy of the optical conductivity is ensured by performing the Eq. (53) over a random
superposition of all the basis states in the real space, similar to the calculation of the DOS. Moreover, the Fermi
distribution operator f ( ˜H) and 1 − f ( ˜H) can be obtained by the standard Chebyshev polynomial decomposition in
section 2.4. We introduce two wave functions

|ψ1(t)(cid:105)α = e−i ˜Ht[1 − f ( ˜H)]Jα|ψ(0)(cid:105)
|ψ2(t)(cid:105) = e−i ˜Htf ( ˜H)|ψ(0)(cid:105)

Then the real part of σαβ(ω) is

Re σαβ((cid:126)ω) = lim
E→0+

e−β(cid:126)ω − 1
(cid:126)ωA

(cid:90) ∞

0

e−Et sin(ωt) × 2Im(cid:104)ψ2(t)|Jα|ψ1(t)(cid:105)βdt

while the imaginary part can be extracted with the Kramers-Kronig relation

Im σαβ((cid:126)ω) = −

1
π

P

(cid:90) ∞

−∞

Re σαβ((cid:126)ω(cid:48))
ω(cid:48) − ω

dω(cid:48)

In the diagonalization-based method, the optical conductivity is evaluated as

σαβ((cid:126)ω) =

ie2(cid:126)
NkΩc

(cid:88)

(cid:88)

k

m,n

fmk − fnk
(cid:15)mk − (cid:15)nk

(cid:104)ψnk|vα|ψmk(cid:105)(cid:104)ψmk|vβ|ψnk(cid:105)
(cid:15)mk − (cid:15)nk − ((cid:126)ω + iη+)

(56)

(57)

(58)

(59)

(60)

where Nk is the number of k-points in the ﬁrst Brillouin zone, and Ωc is the volume of unit cell, respectively. ψmk and
ψnk are the eigenstates of Hamiltonian deﬁned in Eq. (17), with (cid:15)mk and (cid:15)nk being the corresponding eigenvalues, and
fmk and fnk being the occupation numbers. vα and vβ are components of velocity operator deﬁned as v = −J/e, and
η+ is the positive infestimal.

ix

2.8 DC conductivity

The DC (electric) conductivity can be calculated by taking the limit ω → 0 in the Kubo formula[71]. Based on the
DOS and quasieigenstates obtained in Eqs. (42) and (51), we can calculate the diagonal term of DC conductivity σαα
in direction α at temperature T = 0 with

σαα(E) = lim
τ →∞

= lim
τ →∞

σαα(E, τ )
(cid:90) τ

D(E)
A

0

Re (cid:2)e−iEtCDC(t)(cid:3) dt

where the DC correlation function is deﬁned as

CDC(t) =

(cid:104)ψ(0)|Jαei ˜HtJα| ˜Ψ(E)(cid:105)
|(cid:104)ψ(0)| ˜Ψ(E)(cid:105)|

(61)

(62)

and A is the area of volume of the unit cell depending on system dimension. It is important to note that |ψ(0)(cid:105) must
be the same random initial state used in the calculation of | ˜Ψ(E)(cid:105). The semiclassic DC conductivity σsc(E) without
considering the effect of Anderson localization is deﬁned as

The measured ﬁeld-effect carrier mobility is related to the semiclassic DC conductivity as

σsc(E) = σmax

αα (E, τ )

u(E) =

σsc(E)
ene(E)

(63)

(64)

where the carrier density ne(E) is obtained from the integral of density of states via ne(E) = (cid:82) E

0 D(ε)dε.

In TBPLaS, there is another efﬁcient approach to evaluate DC conductivity, which is based on a real-space imple-
mentation of the Kubo formalism, where both the diagonal and off-diagonal terms of conductivity are treated on the
same footing[21]. The DC conductivity tensor for non-interacting electronic system is given by the Kubo-Bastin
formula[21, 72]

σαβ(µ, T ) =

i(cid:126)e2
A

(cid:90) ∞

−∞

dEf (E)Tr

(cid:68)

vαδ(E − H)vβ

dG+(E)
dE

G−(E)
dE
where vα is the α component of the velocity operator, G±(E) = 1/(E − H ± iη) are the Green’s functions. Firstly,
we rescale the Hamiltonian and energy, and denote them as ˜H and ˜E, respectively. Then the delta δ and the Green’s
function G±(E) can be expanded in terms of Chebyshev polynomials using the kernel polynomial method (KPM)

vβδ(E − H)

− vα

(65)

(cid:69)

δ( ˜E − ˜H) =

2
1 − ˜E2

(cid:112)

π

G±( ˜E, ˜H) = ∓

2i
1 − ˜E2

(cid:112)

M
(cid:88)

m=0

M
(cid:88)

m=0

gm

Tm( ˜E)
δm,0 + 1

Tm( ˜H)

gm

e±im arccos( ˜E)
δm,0 + 1

Tm( ˜H)

(66)

(67)

Truncation of the above expansions gives rise to Gibbs oscillations, which can be smoothed with a Jackson kernel
gm[25]. Then the conductivity tensor can be written as[21]

σαβ(µ, T ) =

4e2(cid:126)
πA

4
∆E2

(cid:90) 1

−1

d ˜E

f ( ˜E)
(1 − ˜E2)2

(cid:88)

m,n

Γnm( ˜E)µαβ

nm( ˜H)

(68)

where ∆E = E+
nm( ˜H) are functions of the energy and the Hamiltonian, respectively
µαβ

max − E−

min is the energy range of the spectrum, ˜E is the rescaled energy within [-1,1], Γnm( ˜E) and

Γnm( ˜E) = Tm( ˜E)( ˜E − in
+ Tn( ˜E)( ˜E + im

1 − ˜E2)ein arccos( ˜E)
1 − ˜E2)e−im arccos( ˜E)

(cid:112)

(cid:112)

nm( ˜H) =
µαβ

gmgn
(1 + δn0)(1 + δm0)

Tr[vαTm( ˜H)vβTn( ˜H)]

x

(69)

(70)

2.9 Diffusion coefﬁcient

In the Kubo formalism, the DC conductivity in Eq. (61) can also be written as a function of diffusion coefﬁcient

Therefore, the time-dependent diffusion coefﬁcient is obtained as

σαα(E) =

e2
A

D(E) lim
τ →∞

Ddif f (E, τ )

Ddif f (E, τ ) =

1
e2

(cid:90) τ

0

Re (cid:2)e−iEtCDC(t)(cid:3) dt

(71)

(72)

Once we know the Ddif f (E, τ ), we can extract the carrier velocity from a short time behavior of the diffusivity as

and the elastic mean free path (cid:96)(E) from the maximum of the diffusion coefﬁcient as

(cid:113)

v(E) =

Ddif f (E, τ )/τ

(cid:96)(E) =

Dmax

dif f (E)
2v(E)

This also allows us to estimate the Anderson localization lengths [39, 73] by

ξ(E) = (cid:96)(E) exp

(cid:21)
(cid:20) πh
2e2 σsc(E)

2.10 Dielectric function

(73)

(74)

(75)

In TBPM, the dynamic polarization can be obtained by combining Kubo formula [71] and random state technology

as

ΠK(q, (cid:126)ω) = −

2
A

(cid:90) ∞

0

eiωtCDP(t)dt

where the correlation function is deﬁned as

Here, the density operator is

and the introduced two functions are

CDP(t) = Im(cid:104)ψ2(t)|ρ(q)| ˜ψ1(q, t)(cid:105)

ρ(q) =

eiq·ric†

i ci

(cid:88)

i

| ˜ψ1(q, t)(cid:105)β =e−i ˜Ht[1 − f ( ˜H)]ρ(−q)|ψ(0)(cid:105)

|ψ2(t)(cid:105) =e−i ˜Htf ( ˜H)|ψ(0)(cid:105)

(76)

(77)

(78)

(79)

(80)

The dynamical polarization function can also be obtained via diagonalization from the Lindhard function as[74]

ΠL(q, (cid:126)ω) = −

gs
(2π)p

(cid:90)

BZ

dpk

(cid:88)

m,n

fmk − fnk+q
(cid:15)mk − (cid:15)nk+q + (cid:126)ω + iη+

× |(cid:104)ψnk+q|eiq·r|ψmk(cid:105)|2

(81)

where ψmk and (cid:15)mk are the eigenstates and eigenvalues of the TB Hamiltonian deﬁned in Eq. (21), respectively. gs is
the spin degeneracy, and p is the system dimension. With the polarization function obtained from the Kubo formula
in Eq. (76) or the Lindhard function in Eq. (81), the dielectric function can be written within the random phase
approximation (RPA) as

(cid:15)(q, ω) = 1 − V (q)Π(q, ω)
(82)
in which V (q) is the Fourier transform of Coulomb interaction. For two-dimensional systems V (q) = 2πe2/κ|q|,
while for three-dimensional systems V (q) = 4πe2/κ|q|2, with κ being the background dielectric constant. The energy
loss function can be obtained as

(83)

1
(cid:15)(q, ω)

S(q, ω) = −Im

xi

The energy loss function can be measured by means of electron energy loss spectroscopy (EELS). A plasmon mode
with frequency ωp and wave vector q is well deﬁned when a peak exists in the S(q, ω) or (cid:15)(q, ω) = 0 at ωp. The
damping rate γ of the mode is

and the dimensionless damping rate is

The life time is deﬁned as

γ =

Im Π(q, ωp)
∂
∂ω Re Π(q, ω)|ω=ωp

˜γ =

1
ωp

Im Π(q, ωp)
∂
∂ω Re Π(q, ω)|ω=ωp

τ =

1
˜γωp

(84)

(85)

(86)

All the plasmon related quantities can be calculated numerically from the functions obtained with TBPM.

2.11 Z2 topological invariant

The Z2 invariant characterizes whether a system is topologically trivial or nontrivial. All the two-dimensional band
insulators with time-reversal invariance can be divided into two classes, i.e., the normal insulators with even Z2 numbers
and topological insulators with odd Z2 numbers. In TBPLaS, we adopt the method proposed by Yu et al. to calculate
the Z2 numbers of a band insulator [75]. The main idea of the method is to calculate the evolution of the Wannier
function center directly during a time-reversal pumping process, which is a Z2 analog to the charge polarization. The
Z2 topological numbers can be expressed as the number of times mod 2 of the partner switching of the phases during a
complete period of the time-reversal pumping process, which is equivalent to the Z2 number proposed by Fu and Kane
[76]. This method requires no gauge-ﬁxing condition, thereby greatly simplifying the calculation. It and can be easily
applied to general systems that lack spacial inversion symmetry.

The eigenstate of a TB Hamiltonian deﬁned by Eq. (17) can be expressed as

|ψnk(cid:105) =

(cid:88)

α

gnα(k)|χαk(cid:105)

(87)

where the Bloch basis functions |χαk(cid:105) are deﬁned in Eq. (10). Let us take the 2D system as an example. In this case,
each wave vector ky deﬁnes a one-dimensional subsystem. The Z2 topological invariant can be determined by looking
at the evolution of Wannier function centers for such effective 1D system of ﬁxed ky in the subspace of occupied states.
The eigenvalue of the position operator ˆX can be viewed as the center of the maximally localized Wannier functions,
which is

ˆXP (ky) =












0
0
0
0
0
FNx−1,0

F0,1
0
0
0
0
0

0
F1,2
0
0
0
0

0
0
F2,3
0
0
0

0
0
0
. . .
0
0



0
0
0
0
FNx−2,Nx−1
0










(88)

(89)

where

F nm

i,i+1(ky) =

(cid:88)

α

g∗
nα(kx,i, ky)gmα(kx,i+1, ky)

are the 2N × 2N matrices spanned in 2N -occupied states and kx,i are the discrete k points taken along the x axis. We
deﬁne a product of Fi,i+1 as

D(ky) = F0,1F1,2F2,3 . . . FNx−2,Nx−1FNx−1,0

D(ky) is a 2N × 2N matrix that has 2N eigenvalues
m|eiθD

m(ky) = |λD
λD

m(ky),

m = 1, 2, . . . , 2N

where θD

m(ky) is the phase of the eigenvalues

m(ky) = Im (cid:2)logλD
θD

m(ky)(cid:3)

(90)

(91)

(92)

The evolution of the Wannier function center for the effective 1D system with ky can be obtained by looking at the
phase factor θD
m. Equation (90) can be viewed as the discrete expression of the Wilson loop for the U(2N ) non-Abelian

xii

Berry connection. It is invariant under the U (2N ) gauge transformation, and can be calculated directly from the wave
functions obtained by ﬁrst-principles method without choosing any gauge-ﬁxing condition. In the Z2 invariant number
calculations, for a particular system, we calculate the evolution of the θD deﬁned in Eq. (92) as the function of ky from
zero to π. Then, we draw an arbitrary reference line parallel to the ky axis, and compute the Z2 number by counting
how many times the evolution lines of the Wannier centers cross the referee line. Note that the choice of reference line
is arbitrary, but the the crossing numbers between the reference and evolution lines and the even/odd properties will not
change. For more details we refer to Ref. [75]

xiii

3

Implementation

In this section, we introduce the implementation of TBPLaS, including the layout, main components, and parallelism.
TBPLaS has been designed with emphasis on efﬁciency and user-friendliness. The performance-critical parts are written
in Fortran and Cython. Sparse matrices are utilized to reduce the memory cost, which can be linked to vendor-provided
math libraries like Intel(cid:114) MKL. A hybrid MPI+OpenMP parallelism has been implemented to exploit the modern
architecture of high-performance computers. On top of the Fortran/Cython core, there is the application interface (API)
written in Python following an intuitive object-oriented manner, ensuring excellent user-friendliness and ﬂexibility.
Tight-binding models with arbitrary shape and boundary conditions can be easily created with the API. Advanced
modeling tools for constructing hetero-structures, quasi crystals and fractals are also provided. The API also features a
dedicated error handling system, which checks for illegal input and yields precise error message on the ﬁrst occasion.
Owing to all these features, TBPLaS can serve as not only an out-of-the-box tight-binding package, but also a common
platform for the development of advanced models and algorithms.

3.1 Layout

The layout of TBPLaS is shown in Fig. 1. At the root of hierarchy there are the Cython and Fortran extensions, which
contain the core subroutines for building the model, constructing the Hamiltonian and performing actual calculations.
The Python API consists of a comprehensive set of classes directly related to the concepts of tight-binding theory. For
example, orbitals and hopping terms in a tight-binding model are represented by the Orbital and IntraHopping
classes, respectively. From the orbitals and hopping terms, as well as lattice vectors, a primitive cell can be created as
an instance of the PrimitiveCell class. The goal of PrimitiveCell is to represent and solve tight-binding models
of small and moderate size. Modeling tools for constructing complex primitive cells, e.g., with arbitrary shape and
boundary conditions, vacancies, impurities, hetero-structures, are also available. Many properties, including band
structure, DOS, dynamic polarization, dielectric function, and optical conductivity can be obtained at primitive cell
level, either by calling proper functions of PrimitiveCell class, or with the help of Lindhard class.

SuperCell, SCInterHopping and Sample are a set of classes specially designed for constructing large models
from the primitive cell, especially for TBPM calculations. The computational expensive parts of these classes are
written in Cython, making them extremely fast. For example, it takes less than 1 second to construct a graphene model
with 1,000,000 orbitals from the Sample class on a single core of Intel(cid:114) Xeon(cid:114) E5-2690 v3 CPU. At SuperCell level
the user can specify the number of replicated primitive cells, boundary conditions, vacancies, and modiﬁer to orbital
positions. Heterogenous systems, e.g., slabs with adatoms or hetero-structures with multiple layers, are modeled as
separate supercells and containers (instances of the SCInterHopping class) for inter-supercell hopping terms . The
Sample class is a uniﬁed interface to both homogenous and heterogenous systems, from which the band structure and
DOS can be obtained via exact-diagonalization. Different kinds of perturbations, e.g., electric and magnetic ﬁelds,
strain, can be speciﬁed at Sample level. Also, it is the starting point for TBPM calculations.

The parameters of TBPM calculation are stored in the Config class. Based on the sample and conﬁguration, a solver
and an analyzer can be created from Solver and Analyzer classes, respectively. The main purpose of solver is to
obtain the time-dependent correlation functions, which are then analyzed by the analyzer to yield DOS, LDOS, optical
conductivity, electric conductivity, Hall conductance, polarization function and quasi-eigenstates, etc. The results
from TBPM calculation and exact-diagonalization at either PrimitiveCell or Sample level, can be visualized using
matplotlib directly, or alternatively with the Visualizer class, which is a wrapper over matplotlib functions.

3.2 PrimitiveCell

As aforementioned in section 3.1, the main purpose of PrimitiveCell class is to represent and solve tight-binding
models of small and moderate size. It is also the building block for large and complex models. All calculations
utilizing TBPLaS begin with creating the primitive cell. The user APIs of PrimitiveCell as well as many mis-
cellaneous tools are summarized in Table 1. To create the primitive cell, one needs to provide the lattice vectors,
which can be generated with the gen_lattice_vectors function or manually specifying their Cartesian coordi-
nates. Then the orbitals and hopping terms are added to the primitive cell with the add_orbital and add_hopping
functions, respectively. TBPLaS utilizes the conjugate relation to reduce the hopping terms, so only half of them
are needed. There are also functions to extract, modify and remove existing orbitals and hopping terms in the cell,
e.g., set_orbital/get_orbital/remove_orbitals and get_hopping/remove_hopping. Removing orbitals
and hopping terms may leave dangling items in the cell. In that case, the trim function becomes useful. By default, the
primitive cell is assumed to be periodic along all 3 directions. However, it can be made non-periodic along speciﬁc
directions by removing hopping terms along that direction, as implemented in the apply_pbc function. As TBPLaS
utilizes the lazy evaluation technique, the sync_array function is provided for synchronizing the array attributes

xiv

Figure 1: Program layout of TBPLaS. Components of the same level in the hierarchy share the same color.

after modifying the model. Once the primitive cell has been created, it can be visualized by the plot function and
dumped by the print function. Geometric properties such as lattice area, volume and reciprocal lattice vectors, and
electronic properties like band structure and DOS can be obtained with proper functions as listed in Table 1. The
k-points required for the evaluation of band structure and DOS can be generated with the gen_kpath and gen_kmesh
functions, respectively.

For the user’s convenience, TBPLaS provides a model repository which offers the utilities to obtain the primi-
tive cells of popular two-dimensional materials, as summarized in Table 1. The function make_antimonene re-
turns the 3-orbital or 6-orbtial primitive cell of antimonene[77] depending on the inclusion of spin-orbital cou-
pling. Diamond-shaped and rectangular primitive cells of graphene can be built with make_graphene_diamond and
make_graphene_rect functions, respectively. The 4-orbital primitive cell of black phosphorus[78] can be obtained
with make_black_phosphorus, while the 11-orbital models of transition metal dichalcogenides[79] are available with
the make_tmdc function. The primitive cell can also be created from the output of Wannier90[80] package, namely
seedname.win, seedname_centres.xyz and seedname_hr.dat, with the wan2pc function.

Starting from the simple primitive cell, more complex cells can be constructed through some common operations.
A set of functions are provided for this purpose. extend_prim_cell replicates the primitive cell by given times.
reshape_prim_cell reshapes the cell to new lattice vectors, while sprical_prim_cell shifts and rotates the cell
with respect to c-axis, both of which are particularly useful for constructing hetero-structures. make_hetero_layer is
a wrapper over reshape_prim_cell and produces one layer of the hetero-structure. Intercell hopping terms within
a hetero-structure are hold by the PCInterHopping class. Finally, all the layers and intercell hopping terms can be
merged into one cell by the merge_prim_cell function. Note all these functions work at PrimitiveCell level, i.e.,
they either return a new primitive cell, or modify an existing one.

xv

Table 1: User APIs of PrimitiveCell, PCInterHopping and Lindhard classes and miscellaneous tools.

Category

API

Purpose

Add a new orbital
Modify an existing orbital
Retrieve an existing orbital
Remove selected orbitals
Add a new or modify an existing hopping term
Retrieve an existing hopping term
Remove an existing hopping term
Remove dangling orbitals and hopping terms
Modify the boundary conditions
Synchronize the array attributes
Calculate the area spanned by lattice vectors
Calculate the volume spanned by lattice vectors
Calculate reciprocal lattice vectors
Calculate band structure of the primitive cell
Calculate DOS and LDOS of the primitive cell
Plot the primitive cell to the screen or ﬁle
Print orbital and hopping terms
Add a new inter-cell hopping term
Calculate dynamic polarization for regular q-points
Calculate dynamic polarization for arbitrary q-points
Calculate dielectric function
Calculate optical conductivity
Generate lattice vectors from lattice constants
Rotate Cartesian coordinates
Convert coordinates from Cartesian to fractional
Convert coordinates from fractional to Cartesian
Generate path connecting highly-symmetric k-points
Generate a mesh grid in the ﬁrst Brillouin zone
Replicate the primitive cell
Reshape primitive cell to new lattice vectors
Rotate and shift primitive cell
Produce one layer of hetero-structure
Merge primitive cells and inter-cell hopping terms
Get the primitive cell of antimonene

add_orbital
set_orbital
get_orbital
remove_orbitals
add_hopping
get_hopping
remove_hopping
trim
apply_pbc
sync_array
get_lattice_area
get_lattice_volume
get_reciprocal_vectors
calc_bands
calc_dos
plot
print
add_hopping
calc_dyn_pol_regular
calc_dyn_pol_arbitrary
calc_epsilon
calc_ac_cond
gen_lattice_vectors
rotate_coord
cart2frac
frac2cart
gen_kpath
gen_kmesh
extend_prim_cell
reshape_prim_cell
spiral_prim_cell
make_hetero_layer
merge_prim_cell
make_antimonene
make_graphene_diamond Get the diamond-shaped primitive cell of graphene
make_graphene_rect
make_black_phosphorus
make_tmdc
wan2pc

Get the rectangular primitive cell of graphene
Get the primitive cell of black phosphorus
Get the primitive cells of transition metal dichalcogenides
Create primitive cell from the output of Wannier90

PrimitiveCell

PCInterHopping

Lindhard

Lattice and k-points

Modeling tools

Model repository

xvi

3.3 Lindhard

The Lindhard class evaluates response properties, i.e., dynamic polarization, dielectric function and optical con-
ductivity of primitive cell with the help of Lindhard function. The user APIs of this class is summarized in Table
1. To instantiate a Lindhard object, one needs to specify the primitive cell, energy range and resolution, dimension
of k-grid in the ﬁrst Brillouin zone, system dimension, background dielectric constant and many other quantities.
Since dynamic polarization and dielectric function are q-dependent, three types of coordinate systems are provided to
effectively represent the q-points: Cartesian coordinate system in unit of −1 or nm−1, fractional coordinate system in
unit of reciprocal lattice vectors, and grid coordinate system in unit of dimension of k-grid. Grid coordinate system is
actually a variant of the fractional coordinate system. Conversion between coordinate systems can be achieved with the
frac2cart and cart2frac functions.

Lindhard class offers two functions to calculate the dynamic polarization: calc_dyn_pol_regular and
calc_dyn_pol_arbitrary. Both functions require an array of q-points as input. The difference is that
calc_dyn_pol_arbitrary accepts arbitrary q-points, while calc_dyn_pol_regular requires that the q-points
should be on the uniform k-grid in the ﬁrst Brillouin zone. This is due to the term k(cid:48) = k + q that appears in the
Lindhard function. For regular q on k-grid, k(cid:48) is still on the same grid. However, this may not be true for arbi-
trary q-points. So, calc_dyn_pol_arbitrary keeps two sets of energies and wave functions, for k and k(cid:48) grids
respectively, although they may be equivalent via translational symmetry. On the contrary, calc_dyn_pol_regular
utilizes translational symmetry and reuses energies and wave functions when possible. So, calc_dyn_pol_regular
uses less computational resources, at the price that only regular q-points on k-grid can be taken as input. From
the dynamic polarization, dielectric function can be obtained by calc_epsilon. Unlike dynamic polarization and
dielectric function, the optical conductivity considered in TBPLaS does not depend on q-points. So, it can be evaluated
directly by calc_ac_cond.

3.4 SuperCell, SCInterHopping and Sample

The tools discussed in section 3.2 are sufﬁciently enough to build complex models of small and moderate size.
However, there are occasions where large models are essential, e.g., hetero-structures with twisted layers, quasi crystals,
distorted structures, etc. In particular, TBPM calculations require large models for numerical stability. To build and
manipulate large models efﬁciently, a new set of classes, namely SuperCell, SCInterHopping and Sample are
provided. The APIs of these classes are summarized in Table 2.

The purpose of SuperCell class is to represent homogenous models that are formed by replicating the primitive
cell. To create a supercell, the primitive cell, supercell dimension and boundary conditions are required. Vacancies can
be added to the supercell upon creation, or through the add_vacancies and set_vacancies functions afterwards.
Modiﬁcations to the hopping terms can be added by the add_hopping function. If the hopping terms are already
included in the supercell, the original values will be overwritten. Otherwise, they will be added to the supercell as new
terms. The supercell can be assgined with an orbital position modiﬁer with the set_orb_pos_modifier function,
which is a Python function modifying the orbital positions in-place. Dangling orbitals and hopping terms in the supercell
can be removed by the trim function. Orbital positions, on-site energies, hopping terms and distances, as well as many
properties of the supercell cell can be obtained with the get_xxx functions, as listed in Table 2. TBPLaS utilizes the
conjugate relation to reduce the hopping terms, so only half of them are returned by get_hop and get_dr.

Heterogenous systems, e.g., slabs with adatoms or hetero-structures with multiple layers, are modelled as separate
supercells and containers for inter-supercell hopping terms. The containers are created from the SCInterHopping
class, with a bra supercell and a ket supercell, between which the hopping terms can be added by the add_hopping
function. The SCInterHopping class also implements the get_hop and get_dr functions for extracting the hopping
terms and distances, similar to the SuperCell class.

The Sample class is a uniﬁed interface to both homogenous and heterogenous systems. A sample may consist of single
supercell, or multiple supercells and inter-supercell hopping containers. The on-site energies, orbital positions, hopping
terms and distances are stored in the attributes of orb_eng, orb_pos, hop_i, hop_j, hop_v and dr, respectively,
which are all numpy arrays. To reduce the memory usage, these attributes are ﬁlled only when needed with the
initialization functions. Different kinds of perturbations, e.g., electric and magnetic ﬁelds, strain, can be speciﬁed by
directly calling the API, or manipulating the array attributes directly. The reset_array function is provided to reset the
array attributes of the sample, for removing the effects of perturbations. Band structure and DOS of the sample can be
obtained with calc_bands and calc_dos respectively, similar to the PrimitiveCell class. Visualization is achieved
through the plot function. Since the sample is typically large, its response properties are no longer accessible via the
Lindhard function. On the contrary, TBPM is much more efﬁcient for large samples. Since the Chebyshev polynomial

xvii

Table 2: User APIs of SuperCell, SCInterHopping and Sample classes.

Category

SuperCell

SCInterHopping

Sample

Purpose

Add a list of vacancies to the supercell
Reset the list of vacancies
Add a modiﬁcation to the hopping terms
Assign an orbital position modiﬁer to the supercell
Remove dangling orbitals and hopping terms
Synchronize the array attributes
Get the Cartesian coordinates of orbitals
Get the on-site energies
Get the hopping terms
Get the hopping distances
Calculate the area spanned by lattice vectors
Calculate the volume spanned by lattice vectors

API
add_vacancies
set_vacancies
add_hopping
set_orb_pos_modiﬁer
trim
sync_array
get_orb_pos
get_orb_eng
get_hop
get_dr
get_lattice_area
get_lattice_volume
get_reciprocal_vectors Calculate reciprocal lattice vectors
add_hopping
get_hop
get_dr
init_orb_eng
init_orb_pos
init_hop
init_dr
reset_array
rescale_ham
set_magnetic_ﬁeld
calc_bands
calc_dos
plot

Add a new inter-supercell hopping term
Get the hopping terms
Get the hopping distances
Initialize on-site energies on demand
Initialize orbital positions on demand
Initialize hopping terms on demand
Initialize hopping distances on demand
Reset the array atributes
Rescale the Hamiltonian
Apply a perpendicular magnetic ﬁeld
Calculate band structure of the sample
Calculate DOS and LDOS of the sample
Plot the sample to the screen or ﬁle

decomposition of Hamiltonian requires its eigenvluates to be within [-1, 1], an API rescale_ham is provided for this
purpose. Details on TBPM will be discussed in the next section.

3.5 Conﬁg, Solver, Analyzer and Visualizer

TBPM in TBPLaS is implemented in the classes of Config, Solver and Analyzer. Config is a simple container
class holding all the parameters that controls the calculation. So, it has no API but a few Python dictionaries as attributes.
The Solver class propagates the wave function and evaluates the correlation functions, which are then analyzed by
Analyzer class to produce the results, including DOS, LDOS, optical conductivity, electric conductivity, etc. The user
APIs of Solver and Analyzer are summarized in Table 3. To create a solver or analyzer, one needs the sample and the
conﬁguration object. The APIs of Solver and Analyzer share a common naming convention, where calc_corr_xxx
calculates the correlation function for property xxx and calc_xxx analyzes the correlation function to yield the ﬁnal
results. Some of the properties, such as LDOS from Green’s function and time-dependent wave function, can be
obtained from Solver directly without further analysis.

The Visualizer class is a thin wrapper over matplotlib for quick visualization of the results from exact-
diagonalization and TBPM. Generic data, e.g., response functions, can be plotted with the plot_xy function. There
are also special functions to plot the band structure and DOS. Quasi-eigenstates and time-dependent wave function
can be plotted with the plot_wfc function. Although Visualizer is intended for quick visualization, it can be easily
extended to produce ﬁgures of publication quality, according to the user’s needs.

3.6 Parallelization

Tight-binding calculations can be time-consuming when the model is large, or when ultra-ﬁne results are desired. For
example, band structure, DOS and response properties from Lindhard function require exact diagonalization for a dense
k-grid in the ﬁrst Brillouin zone, optionally followed by post-processing on an energy grid. TBPM calculations require
large models and averaging over multiple samples to converge the results, while the time-propagation of each sample
involves heavy matrix-vector multiplications. Consequently, dedicated parallelism that can exploit the modern hardware

xviii

Table 3: User APIs of Solver, Analyzer, Visualizer classes.

Category

API

set_output
save_conﬁg
calc_corr_dos
calc_corr_ldos
calc_corr_dyn_pol
calc_corr_ac_cond
calc_corr_dc_cond
calc_hall_mu

Solver

Purpose
Prepare output directory and ﬁles
Save conﬁguration to ﬁle
Calculate correlation function of DOS
Calculate correlation function of LDOS
Calculate correlation function of dynamical polarization
Calculate correlation function of optical conductivity
Calculate correlation function of electric conductivity
Calculate µmn required for the evaluation of Hall conductivity
using Kubo-Bastin formula

calc_quasi_eigenstates Calculate quasi-eigenstates of given energies
calc_ldos_haydock
calc_wfc_t

calc_dos
calc_ldos
calc_dyn_pol
calc_epsilon
calc_ac_cond
calc_dc_cond
calc_diff_coeff
calc_hall_cond
plot_xy
plot_bands
plot_dos
plot_wfc

Analyzer

Visualizer

Calculate LDOS using Green’s function
Calculate propagation of wave function from given initial
state
Calculate DOS from its correlation function
Calculate LDOS from its correlation function
Calculate dynamic polarization from its correlation function
Calculate dielectric function from dynamic polarization
Calculate optical conductivity from its correlation function
Calculate electric conductivity from its correlation function
Calculate diffusion coefﬁcient from DC correlation function
Calculate Hall conductivity from µmn
Plot generic data of y against x
Plot band structure
Plot DOS
Plot quasi-eigenstate or time-dependent wave function in real
space

of computers are essential to promote the application of tight-binding techniques to millions or even billions of orbitals.
However, the Global Interpreter Lock (GIL) of Python allows only one thread to run at one time, severely hinders
the parallelization at thread level. Although the GIL can be bypassed with some tricks, thread-level parallelization is
restricted to only one computational node. TBPLaS tackles these problems with a hybrid MPI+OpenMP parallelism.
Tasks are ﬁrstly distributed over MPI processes that can run among multiple nodes. Since the processes are isolated
mutually at operation system level and each keeps a local copy of the data, there is no need to worry about data conﬂicts
and GIL. For the tasks assigned to each process, thread-level parallelism is implemented with OpenMP in the Cython
and Fortran extensions. With a wise choice of the numbers of processes and threads, excellent scaling can be achieved
with respect to the computational resources. Both MPI and OpenMP of the hybrid parallelism can be enabled or disabled
separately, ensuring good ﬂexibility.

3.6.1 Band structure and DOS

For calculating the band structure, k-points are ﬁrstly distributed over MPI processes, with each process dealing with
some of the k-points. For each k-point assigned to the process, the Hamiltonian matrix has to be built in serial, while
the diagonalization is further parallelized with OpenMP in the NumPy and SciPy libraries, which call OpenBLAS or
MKL under the hood. The evaluation of DOS consists of getting the eigenvalues for a dense k-grid, and a summation
over the eigenvalues to collect the contributions following Eq. (39). Getting the eigenvalues is parallelized in the same
approach as the band structure. The summation is parallelized with respect to the k-points over MPI processes. Local
data on each process is then collected via the MPI_Allreduce call.

3.6.2 Response properties from Lindhard function

Evaluation of response properties using Lindhard function is similar to that of DOS, which also consists of getting the
eigenvalues and eigenvectors and subsequent post-processing. However, the post-processing is much more expensive
than DOS. Taking the optical conductivity for example, whose formula follows Eq. (60). To reuse the intermediate
results, we deﬁne the following arrays

∆(cid:15)(k, m, n) = (cid:15)mk − (cid:15)nk

(93)

xix

and

P (k, m, n) =

fmk − fnk
(cid:15)mk − (cid:15)nk

(cid:104)ψnk|vα|ψmk(cid:105)(cid:104)ψmk|vβ|ψnk(cid:105)

(94)

The evaluation of ∆(cid:15) and P are ﬁrstly parallelized with respect to k over MPI processes. For each process, tasks are
further parallelized with respect to m over OpenMP threads. Once the arrays are ready, the optical conductivity can be
calculated as

σαβ((cid:126)ω) =

ie2(cid:126)
NkΩc

(cid:88)

(cid:88)

k

m,n

P (k, m, n)
∆(cid:15)(k, m, n) − ((cid:126)ω + iη+)

(95)

Typically, the response properties are evaluated on a discrete frequency grid {ωi}. We ﬁrstly distribute k-points over
MPI processes, then distribute the frequencies over OpenMP threads. Final results are collected by MPI calls, similar to
the evaluation of DOS.

3.6.3 TBPM

The TBPM calculations follow a common procedure. Firstly, the time-dependent wave function is propagated from
different initial conditions and correlation functions are evaluated at each time-step. Then the correlation functions
are averaged and analyzed to yield the ﬁnal results. The averaging and analysis are cheap and need no parallelization.
The propagation of wave function, on the contrary, is much more expensive and must be parallelized. Fortunately,
propagation from each initial condition is embarrassingly parallel task, i.e., it can be split into individual sub-tasks
that do not exchange data mutually. So, the initial conditions are distributed among MPI processes. The propagation
of wave function, according to Eq. (30), involves heavy matrix-vector multiplications. In TBPLaS the matrices are
stored in Compressed Sparse Row (CSR) format, signiﬁcantly reducing the memory cost. The multiplication, as well as
many other matrix operations, are parallelized with respect to matrix elements among OpenMP threads. Averaging of
correlation functions is also done by MPI calls.

xx

4 Usage

In this section we demonstrate the installation and usages of TBPLaS. TBPLaS is released under the BSD license,
which can be found at https://opensource.org/licenses/BSD-3-Clause. The source code is available at the
home page www.tbplas.net. Detailed documentation and tutorials can also be found there.

4.1 Installation

4.1.1 Prerequisites

To install and run TBPLaS, a Unix-like operating system is required. You need both C and Fortran compilers, as well
as vendor-provided math libraries if they are available. For Intel(cid:114) CPUs, it is better to use Intel compilers and Math
Kernel Library (MKL). If Intel toolchain is not available, the GNU Compiler Collection (GCC) is another choice. In
that case, the built-in math library will be enabled automatically.

TBPLaS requires a Python3 environment (interpreter and development ﬁles), and the packages of NumPy, SciPy,
Matplotlib, Cython, Setuptools as mandatory dependencies. Optionally, the LAMMPS interface requires the ASE
package. If MPI+OpenMP hybrid parallelism is to be enabled, the MPI4PY package and an MPI implementation, e.g.,
Open MPI or MPICH, become essential. Most of the packages can be installed via the pip command, or manually from
the source code.

4.1.2 Installation

The conﬁguration of compilation is stored in setup.cfg in the top directory of the source code of TBPLaS. Examples
of this ﬁle can be found in the config directory. You should adjust it according to your computer’s hardware and
software settings. Here is an example utilizing Intel compilers and MKL

[ c o n f i g _ c c ]
c o m p i l e r = i n t e l e m

[ c o n f i g _ f c ]
f c o m p i l e r = i n t e l e m
a r c h = − x H o s t
o p t = −qopenmp −O3 − i p o −heap − a r r a y s 32
f 9 0 f l a g s = − f p p −DMKL −mkl= p a r a l l e l

[ b u i l d _ e x t ]
i n c l u d e _ d i r s = / s o f t w a r e / i n t e l / p a r a l l e l s t u d i o / 2 0 1 9 / c o m p i l e r s _ a n d _ l i b r a r i e s / l i n u x /

mkl / i n c l u d e

l i b r a r y _ d i r s = / s o f t w a r e / i n t e l / p a r a l l e l s t u d i o / 2 0 1 9 / c o m p i l e r s _ a n d _ l i b r a r i e s / l i n u x /

mkl / l i b / i n t e l 6 4
l i b r a r i e s = m k l _ r t

iomp5 p t h r e a d m d l

The config_cc and config_fc sections contain the settings of C and Fortran compilers, while the libraries are
conﬁgured in build_ext. It is important that OpenMP should be enabled by adding proper ﬂags to config_fc and
build_ext, e.g., -qopenmp in opt and iomp5 in libraries for Intel compilers. Here is another example utilizing
GCC and the built-in math library

[ c o n f i g _ c c ]
c o m p i l e r = u n i x

[ c o n f i g _ f c ]
f c o m p i l e r = g f o r t r a n
a r c h = −march = n a t i v e
o p t = −fopenmp −O3 −mtune = n a t i v e
f 9 0 f l a g s = − fno − s e c o n d − u n d e r s c o r e − cpp

[ b u i l d _ e x t ]
l i b r a r i e s = gomp

xxi

1

2

3

4

5

6

7

8

9

10

11

12

13

1

2

3

4

5

6

7

8

9

10

11

where the OpenMP ﬂags become -fopenmp and gomp.

Once setup.cfg has been properly conﬁgured, TBPLaS can be compiled with python setup.py build. If
everything goes well, a new build directory will be created, which contains the Cython and Fortran extensions. The
installation into default path is done by python setup.py install. After that, invoke the Python interpreter and try
import tbplas. If no error occurs, then the installation of TBPLaS is successful.

4.2 Overview of the workﬂow

The workﬂow of common usages of TBPLaS is summarized in Fig. 2. Tight-binding models can be created at either
PrimitiveCell or Sample level, depending on the model size and purpose. PrimitiveCell is recommended for
models of small and moderate size, and is essential for evaluating response functions utilizing the Lindhard function.
On the contrary, Sample is for extra-large models that may consist of millions or trillions of orbitals. Also, TBPM
calculations require the model to be an instance of the Sample class. For a detailed comparison of PrimitiveCell
and Sample, refer to section 3.

Generally, all calculations utilizing TBPLaS begin with creating the primitive cell, which involves creating an empty
cell from the lattice vectors, adding orbitals and adding hoping terms. Complex models, e.g., that with arbitrary shape
and boundary conditions, vacancies, impurities and hetero-structures can be constructed from the simple primitive cell
with the Python-based modeling tools, as discussed in section 3.2. Band structure and DOS of the primitive cell can be
obtained via exact diagonalization with the calc_bands and calc_dos functions, respectively. Response functions
such dynamic polarization, dielectric function and optical conductivity, need an additional step of creating a Lindhard
calculator, followed by calling the corresponding functions.

To build a sample, the user needs to construct a supercell with the Cython-based modeling tools. Heterogenous
systems are modeled as separate supercells plus containers for inter-supercell hopping terms. The sample is then
formed by assembling the supercells and containers. Band structure and DOS of the sample can be obtained via exact
diagonalization in the same approach as the primitive cell. However, these calculations may be extremely slow due to
the large size of the model. In that case, TBPM is recommended. The user needs to setup the parameters using the
Config class, and create a solver and an analyzer from Solver and Analyzer classes, respectively. Then evaluate and
analyze the correlation functions are to yield the DOS, response functions, quasi-eigenstates, etc. Finally, the results
can be visualized using the Visualizer class, or the matplotlib library directly.

4.3 Building the primitive cell

In this section we show how to build the primitive cell taking monolayer graphene as the example. Monolayer
graphene has lattice constants of a = b = 2.46 and α = β = 90◦. The lattice angle γ can be either 60◦ or 120◦,
depending on the choice of lattice vectors. Also, we need to specify an arbitrary cell length c since TBPLaS internally
treats all models as three-dimensional. We will take γ = 60◦ and c = 10 . First of all, we need to invoke the Python
interpreter and import all necessary packages

i m p o r t math
i m p o r t numpy a s np
i m p o r t

t b p l a s

a s

t b

Then we generate the lattice vectors from the lattice constants with the gen_lattice_vectors function

v e c t o r s = t b . g e n _ l a t t i c e _ v e c t o r s ( a = 2 . 4 6 , b = 2 . 4 6 , c = 1 0 . 0 , gamma = 60 )

The function accepts six arguments, namely a, b, c, alpha, beta, and gamma. The default value for alpha and beta
is 90 degrees, if not speciﬁed. The return value vectors is a 3 × 3 array containing the Cartesian coordinates of the
lattice vectors. Alternatively, we can create the lattice vectors from their Cartesian coordinates directly

a = 2 . 4 6
c = 1 0 . 0
a _ h a l f = a * 0 . 5
s q r t 3 = math . s q r t ( 3 )

v e c t o r s = np . a r r a y ( [

xxii

1

2

3

1

1

2

3

4

5

6

Figure 2: Workﬂow of common usages of TBPLaS. Blue rectangles and orange hexagons denote the main steps and
outputs, respectively.

7

8

9

10

] )

[ a , 0 , 0 , ] ,
[ a _ h a l f ,
[ 0 , 0 , c ]

s q r t 3 * a _ h a l f , 0 ] ,

From the lattice vectors, we can create an empty primitive cell by

1

p r i m _ c e l l = t b . P r i m i t i v e C e l l ( v e c t o r s , u n i t = t b .ANG)

where the argument unit speciﬁes that the lattice vectors are in Angstroms.

As we choose γ = 60◦, the two carbon atoms are then located at τ0 = 0 and τ1 = 1

3 a2, as shown in Fig. 3 (a).
In the simplest 2-band model of graphene, each carbon atom carries one 2pz orbital. We can add the orbitals with the
add_orbital function

3 a1 + 1

xxiii

1

2

1

2

p r i m _ c e l l . a d d _ o r b i t a l ( [ 0 . , 0 . ] ,
p r i m _ c e l l . a d d _ o r b i t a l ( [ 1 . / 3 , 1 . / 3 ] ,

e n e r g y = 0 . 0 ,

l a b e l = " pz " )

e n e r g y = 0 . 0 ,

l a b e l = " pz " )

The ﬁrst argument gives the position of the orbital, while energy speciﬁes the on-site energy, which is assumed to be 0
eV if not speciﬁed. In absence of strain or external ﬁelds, the two orbitals have equal on-site energies. The argument
label is a tag to denote the orbital. In addition to fractional coordinates, the orbitals can also be added using Cartesian
coordinates by the add_orbital_cart function

p r i m _ c e l l . a d d _ o r b i t a l _ c a r t ( [ 0 . , 0 . ] , u n i t = t b . ANG,
p r i m _ c e l l . a d d _ o r b i t a l _ c a r t ( [ 1 . 2 3 , 0 . 7 1 0 1 4 0 8 3 ] , u n i t = t b . ANG,

e n e r g y = 0 . 0 ,

l a b e l = " pz " )

e n e r g y = 0 . 0 ,

l a b e l = " pz "

)

Here we use the argument unit to specify the unit of Cartesian coordinates.

Figure 3: (a) Schematic plot of the primitive cell of monolayer graphene. Orbitals are shown as ﬁlled circles and
numbered in green texts, while cells are indicated with dashed diamonds and numbered in blue texts. Thick black
arrows denote the lattice vectors. (b) Band structure, (c) DOS and (d) Optical conductivity of monolayer graphene. The
optical conductivity is in the unit of σ0 = e2
4(cid:126) .

When all the orbitals have been added to the primitive cell, we can proceed with adding the hopping terms, which are

deﬁned as

tij(R) = (cid:104)φi0|ˆh0|φjR(cid:105)
(96)
where R is the index of neighbouring cell, i and j are orbital indices, respectively. The hopping terms of monolayer
graphene in the nearest approximation are

xxiv

• R = (0, 0), i = 0, j = 1

• R = (0, 0), i = 1, j = 0

• R = (1, 0), i = 1, j = 0

• R = (−1, 0), i = 0, j = 1

• R = (0, 1), i = 1, j = 0

• R = (0, −1), i = 0, j = 1

With the conjugate relation tij(R) = t∗

ji(−R), the hopping terms can be reduced to

• R = (0, 0), i = 0, j = 1

• R = (1, 0), i = 1, j = 0

• R = (0, 1), i = 1, j = 0

TBPLaS takes the conjugate relation into consideration. So, we need only to add the reduced set of hopping terms. This
can be done with the add_hopping function

p r i m _ c e l l . a d d _ h o p p i n g ( r n = [ 0 , 0 ] , o r b _ i =0 , o r b _ j =1 , e n e r g y = − 2 . 7 )
p r i m _ c e l l . a d d _ h o p p i n g ( r n = [ 1 , 0 ] , o r b _ i =1 , o r b _ j =0 , e n e r g y = − 2 . 7 )
p r i m _ c e l l . a d d _ h o p p i n g ( r n = [ 0 , 1 ] , o r b _ i =1 , o r b _ j =0 , e n e r g y = − 2 . 7 )

The argument rn speciﬁes the index of neighbouring cell, while orb_i and orb_j give the indices of orbitals of the
hopping term. energy is the hopping integral, which should be a complex number in general cases.

Now we have successfully built the primitive cell. We can visualize it with the plot function:

p r i m _ c e l l . p l o t ( )

The output is shown in Fig. 3(a), with orbitals shown as ﬁlled circles and hopping terms as arrows. We can also print
the details of the model with the print function:

p r i m _ c e l l . p r i n t ( )

The output is as follows

L a t t i c e v e c t o r s
0 . 2 4 6 0 0
0 . 1 2 3 0 0
0 . 0 0 0 0 0

( nm ) :
0 . 0 0 0 0 0
0 . 2 1 3 0 4
0 . 0 0 0 0 0

0 . 0 0 0 0 0
0 . 0 0 0 0 0
1 . 0 0 0 0 0

O r b i t a l s :

0 . 0 0 0 0 0
0 . 3 3 3 3 3
Hopping t e r m s :

0 . 0 0 0 0 0
0 . 3 3 3 3 3

0 . 0 0 0 0 0 0 . 0
0 . 0 0 0 0 0 0 . 0

( 0 , 0 , 0 )
( 1 , 0 , 0 )
( 0 , 1 , 0 )

( 0 , 1 ) −2.7
( 1 , 0 ) −2.7
( 1 , 0 ) −2.7

1

2

3

1

1

1

2

3

4

5

6

7

8

9

10

11

4.4 Properties of primitive cell

In this section we show how to calculate the band structure, DOS and response functions of the graphene primitive
cell we have just created in previous section. First of all, we need to generate a k-path of Γ → M → K → Γ with the
gen_kpath function

xxv

1

2

3

4

5

6

7

8

1

1

2

3

4

5

6

7

8

9

10

1

2

1

1

2

1

2

k _ p o i n t s = np . a r r a y ( [

[ 0 . 0 , 0 . 0 , 0 . 0 ] ,
[ 1 . / 2 , 0 . 0 , 0 . 0 ] ,
[ 2 . / 3 , 1 . / 3 , 0 . 0 ] ,
[ 0 . 0 , 0 . 0 , 0 . 0 ] ,

] )
k _ l a b e l = [ " $ \ Gamma$" , "M" , "K" , " $ \ Gamma$" ]
k _ p a t h , k _ i d x = t b . g e n _ k p a t h ( k _ p o i n t s ,

[ 4 0 , 4 0 , 4 0 ] )

In this example, we interpolate with 40 intermediate k-points along each segment of the k-path. gen_kpath returns
two arrays, with k_path containing the coordinates of k-points and k_idx containing the indices of highly-symmetric
k-points in k_path. Then we solve the band structure with the calc_bands function

k _ l e n , b a n d s = p r i m _ c e l l . c a l c _ b a n d s ( k _ p a t h )

Here k_len is the length of k-path, while bands is a Nk × Nb matrix containing the energies. The band structure can
be plotted with matplotlib

num_bands = b a n d s . s h a p e [ 1 ]
i
i n r a n g e ( num_bands ) :
f o r
p l t . p l o t ( k _ l e n , b a n d s [ : ,
i d x i n k _ i d x :
p l t . a x v l i n e ( k _ l e n [ i d x ] ,

f o r

i ] ,

c o l o r = " r " ,

l i n e w i d t h = 1 . 2 )

c o l o r = " k " ,

l i n e w i d t h = 0 . 8 )

p l t . x l i m ( ( 0 , np . amax ( k _ l e n ) ) )
p l t . x t i c k s ( k _ l e n [ k _ i d x ] , k _ l a b e l )
p l t . y l a b e l ( " E n e r g y ( eV ) " )
p l t . t i g h t _ l a y o u t ( )
p l t . show ( )

Or alternatively, using the Visualizer class:

v i s = t b . V i s u a l i z e r ( )
v i s . p l o t _ b a n d s ( k _ l e n , bands , k _ i d x , k _ l a b e l )

The output is shown in Fig. 3(b). The Dirac cone at K-point is perfectly reproduced.

To calculate the DOS, we need to sample the ﬁrst Brillouin zone with a dense k-grid, e.g., 240 × 240 × 1

k_mesh = t b . gen_kmesh ( ( 2 4 0 , 2 4 0 , 1 ) )

where k_mesh contains the coordinates of k-points on the grid. Then we evaluate and visualize the DOS as

e n e r g i e s , d o s = p r i m _ c e l l . c a l c _ d o s ( k_mesh , e_min = −9 , e_max = 9 )
v i s . p l o t _ d o s ( e n e r g i e s , d o s )

where energies is a uniform energy grid whose lower and upper bounds are controlled by the arguments e_min and
e_max. dos is an array containing the DOS values at the grid points in energies. The output is shown in Fig. 3(c).

The evaluation of response functions requires a Lindhard calculator, which can be created by

t = 2 . 7
l i n d = t b . L i n d h a r d ( c e l l = p r i m _ c e l l , energy_max =20 , e n e r g y _ s t e p =2000 , k m e s h _ s i z e

= ( 4 0 9 6 , 4 0 9 6 , 1 ) , mu = 0 . 0 ,

t e m p e r a t u r e = 3 0 0 . 0 , g _ s =2 , b a c k _ e p s i l o n = 1 . 0 )

xxvi

1

1

2

3

4

1

1

2

1

2

3

The argument cell assigns the primitive cell to the calculator. energy_max and energy_step deﬁne a uniform
energy grid on which response functions will be evaluated. kmesh_size speciﬁes the size of k-grid in the ﬁrst
Brillouin zone. As monolayer graphene is semi-metallic, we need a very dense k-grid in order to converge the response
functions. mu, temperature and g_s are the chemical potential, temperature and spin degeneracy of the system, while
back_epsilon is the background dielectic constant, respectively. The xx component of optical conductivity, namely
σxx, can be evaluated with the calc_ac_cond function

omegas , a c _ c o n d = l i n d . c a l c _ a c _ c o n d ( component = " xx " )

where omegas is the energy grid and ac_cond is the optical conductivity. The results can be visualized using the
Visualizer class

/ = t

omegas
a c _ c o n d *= 4
v i s = t b . V i s u a l i z e r ( )
v i s . p l o t _ x y ( omegas , a c _ c o n d . r e a l , x _ l a b e l = " E n e r g y ( t ) " , y _ l a b e l = " $ \ s i g m a _ { xx } ( \

s i g m a _ 0 ) $ " )

The output is shown in Fig. 3(d), in the unit of σ0 = e2
4(cid:126) .

4.5 Building the sample

In this section we show how to construct a sample by making a graphene model with 20 × 20 × 1 primitive cells. To

build the sample, we need to create the supercell ﬁrst

s u p e r _ c e l l = t b . S u p e r C e l l ( p r i m _ c e l l , dim = ( 2 0 , 2 0 , 1 ) , pbc = ( True , True , F a l s e ) )

The SuperCell class is similar to the functions of extend_prim_cell and apply_pbc, where the dimension and
periodic boundary conditions are set up at the same time. The sample is formed by gluing the supercells and inter-
hopping terms altogether with the Sample class. In our case the sample consists of only one supercell. So it can be
created and visualized by

s a m p l e = t b . Sample ( s u p e r _ c e l l )
s a m p l e . p l o t ( w i t h _ o r b i t a l s = F a l s e , w i t h _ c e l l s = F a l s e , h o p _ a s _ a r r o w s = F a l s e )

where some options are switched for boosting the plot. The output is shown in Fig. 4(a).

4.6 Properties of sample

The Sample class supports the evaluation of band structure and DOS via exact-diagonalization with the calc_bands
and calc_dos functions, similar to the PrimitiveCell class. Taking the DOS as an example, in section 4.4 we have
sampled the ﬁrst Brillouin zone with a k-grid of 240 × 240 × 1. Now that we have a much larger sample, the dimension
of k-grid can be reduced to 12 × 12 × 1 accordingly

k_mesh = t b . gen_kmesh ( ( 1 2 , 1 2 , 1 ) )
e n e r g i e s , d o s = s a m p l e . c a l c _ d o s ( k_mesh , e_min = −9 , e_max = 9 )
v i s . p l o t _ d o s ( e n e r g i e s , d o s )

The output is shown in Fig. 4(b), which is consistent with Fig. 3(c).

Exact diagonalization-based techniques are not feasible for large models as the computational costs scale cubically
with the model size. On the contrary, TBPM involves only matrix-vector multiplication, and is less demanding on
computational resources. Therefore, TBPM is particularly suitable for large models with millions of orbitals or more.

xxvii

Figure 4: (a) Plot of the 20 × 20 × 1 graphene sample. (b) DOS of graphene from exact-diagonalization and TBPM. (c)
Optical conductivity of graphene from Lindhard function and TBPM. (d) DOS of graphene under zero and 50 Tesla
magnetic ﬁelds.

Current capabilities of TBPM in TBPLaS are summarized in section 3.5. We demonstrate the usage of TBPM to
evaluate the DOS and optical conductivity of a graphene sample with 4096 × 4096 × 1 primitive cells, i.e., 33,554,432
orbitals. We begin with creating the sample

s u p e r _ c e l l = t b . S u p e r C e l l ( p r i m _ c e l l , dim = ( 4 0 9 6 , 4 0 9 6 , 1 ) , pbc = ( True , True , F a l s e ) )
s a m p l e = t b . Sample ( s u p e r _ c e l l )
s a m p l e . r e s c a l e _ h a m ( 9 . 0 )

Since the model is extremely large, we will not visualize it as in other examples. In TBPM the time evolution and
Fermi-Dirac operators are expanded in Chebyshev polynomials, which requires the eigenvalues of the Hamiltonian to
be within [−1, 1]. So, we need to rescale the Hamiltonian with the rescale_ham function. The scaling factor can be
speciﬁed as an argument. If not provided, a reasonable default value will be estimated from the Hamiltonian. Then we
set up the parameters of TBPM in an instance of the Config class

c o n f i g = t b . C o n f i g ( )
c o n f i g . g e n e r i c [ " n r _ r a n d o m _ s a m p l e s " ] = 4
c o n f i g . g e n e r i c [ " n r _ t i m e _ s t e p s " ] = 4096

Here we set two parameters: nr_random_samples and nr_time_steps. nr_random_samples speciﬁes that we are
going to consider 4 random initial wave functions for the propagation, while nr_time_steps indicates the number

xxviii

1

2

3

1

2

3

1

2

1

2

3

4

1

2

3

4

5

6

7

1

2

3

4

5

6

7

of steps to propagate. The time step for the propagation is π/f (in unit of (cid:126)/eV ), with f being the scaling factor of
Hamiltonian in eV. Now we create a pair of solver and analyzer by

s o l v e r = t b . S o l v e r ( sample ,
a n a l y z e r = t b . A n a l y z e r ( sample ,

c o n f i g )

c o n f i g )

Then we calculate and analyze the correlation function to get DOS

c o r r _ d o s = s o l v e r . c a l c _ c o r r _ d o s ( )
e n e r g i e s , d o s = a n a l y z e r . c a l c _ d o s ( c o r r _ d o s )
v i s = t b . V i s u a l i z e r ( )
v i s . p l o t _ d o s ( e n e r g i e s , d o s )

Here the correlation function corr_dos is obtained with the calc_corr_dos function, and then analyzed by the
calc_dos function to yield the energy grid energies and DOS values dos. The result is shown in Fig. 4(b), consistent
with the results from exact-diagonalization.

The calculation of optical conductivity is similar to DOS

t = 2 . 7
c o n f i g . g e n e r i c [ " c o r r e c t _ s p i n " ] = T r u e
c o r r _ a c _ c o n d = s o l v e r . c a l c _ c o r r _ a c _ c o n d ( )
omegas , a c _ c o n d = a n a l y z e r . c a l c _ a c _ c o n d ( c o r r _ a c _ c o n d )
omegas
a c _ c o n d *= 4
v i s . p l o t _ x y ( omegas , a c _ c o n d [ 0 ] . r e a l , x _ l a b e l = " E n e r g y ( t ) " , y _ l a b e l = " $ \ s i g m a _ { xx }

/ = t

( \ s i g m a _ 0 ) $ " )

Note that we set the spin-degeneracy of the model to 2 by setting the correct_spin argument to True, for consistency
with the example in section 4.4. The optical conductivity is shown in Fig. 4(c), which matches perfectly with the results
from Lindhard function.

4.7 Advanced modeling

In this section, we demonstrate how to construct complex models, including hetero structure, quasicrystal and fractal.
For the hetero structure, we are going to take the twisted bilayer graphene as an example, while for the fractal we will
consider the Sierpi´nski carpet.

4.7.1 Hetero-structure

The workﬂow of constructing hetero structures is shown in Fig. 5(a). First of all, we determine the twisting angle
and lattice vectors of the hetero-structure. Then we build the primitive cells of each layer, shift the twisted layer along
z-axis by the interlayer distance and rotate it by the twisting angle. After that, we reshape the primitive cells to the
lattice vectors of the hetero-structure to yield the layers, as depicted in Fig. 5(b). When all the layers are ready, we
merge them into one cell and add the intralayer and interlayer hopping terms up to a given cutoff distance. For the
visualization of Moiré pattern, we also need to build a sample from the merged cell.

Before constructing the model, we need to import the required packages and deﬁne some necessary functions. The

packages are imported by

i m p o r t math

i m p o r t numpy a s np
from numpy . l i n a l g i m p o r t norm
from s c i p y . s p a t i a l

i m p o r t KDTree

i m p o r t

t b p l a s

a s

t b

xxix

Figure 5: (a) Workﬂow of constructing hetero-structure. (b) Schematic plot of lattice vectors of ﬁxed (a1, a2) and
twisted (a(cid:48)
2) primitive cells and the hetero-structure (A1, A2), as well as the twisting angle θ. (c) Twisted bilayer
graphene sample with 4 × 4 × 1 merged cells of i = 5.

1, a(cid:48)

Particularly, we need the KDTree class from SciPy to ﬁnd the orbital pairs up to the cutoff distance. The twisting angle
and lattice vectors are determined following the formulation in Ref. [81]

θi = arccos

3i2 + 3i + 1/2
3i2 + 3i + 1
A1 = i · a1 + (i + 1) · a2,
A2 = −(i + 1) · a1 + (2i + 1) · a2,

,

(97)

(98)
(99)

where a1 and a2 are the lattice vectors of the primitive cell of ﬁxed layer and i is the index of hetero-structure. We
deﬁne the following functions accordingly

d e f

c a l c _ t w i s t _ a n g l e ( i ) :
c o s _ a n g = ( 3 * i **2 + 3 * i + 0 . 5 )
r e t u r n math . a c o s ( c o s _ a n g )

/

( 3 * i **2 + 3 * i + 1 )

d e f

c a l c _ h e t e r o _ l a t t i c e ( i , p r i m _ c e l l _ f i x e d ) :
h e t e r o _ l a t t i c e = np . a r r a y ( [ [ i ,

i + 1 , 0 ] ,

[ − ( i + 1 ) , 2 * i + 1 , 0 ] ,
[ 0 , 0 , 1 ] ] )

h e t e r o _ l a t t i c e = t b . f r a c 2 c a r t ( p r i m _ c e l l _ f i x e d . l a t _ v e c , h e t e r o _ l a t t i c e )
r e t u r n h e t e r o _ l a t t i c e

1

2

3

4

5

6

7

8

9

10

11

calc_twist_angle returns the twisting angle in radians, while calc_hetero_lattice returns the Cartesian coor-
dinates of lattce vectors in nm. After merging the layers, we need to add the interlayer hopping terms. Meanwhile,
the intralayer hoppings terms should also be extended in the same approach. We deﬁne the extend_hop function to
achieve these goals

xxx

1

2

3

4

5

6

7

8

9

10

11

12

13

14

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

1

2

3

4

5

6

7

8

9

d e f e x t e n d _ h o p ( p r i m _ c e l l , m a x _ d i s t a n c e = 0 . 7 5 ) :

p r i m _ c e l l . s y n c _ a r r a y ( )
p o s _ r 0 = p r i m _ c e l l . orb_pos_nm
t r e e _ r 0 = KDTree ( p o s _ r 0 )
n e i g h b o r s = [ ( i a ,
i b , 0 )
f o r

f o r

r n i n n e i g h b o r s :
p o s _ r n = p o s _ r 0 + np . matmul ( rn , p r i m _ c e l l . l a t _ v e c )
t r e e _ r n = KDTree ( p o s _ r n )
d i s t _ m a t r i x = t r e e _ r 0 . s p a r s e _ d i s t a n c e _ m a t r i x ( t r e e _ r n ,

i a

i n r a n g e ( − 1 , 2 )

f o r

i b i n r a n g e ( − 1 , 2 ) ]

f o r

i n d e x , d i s t a n c e
i f d i s t a n c e > 0 . 0 :

i n d i s t _ m a t r i x . i t e m s ( ) :

m a x _ d i s t a n c e = m a x _ d i s t a n c e )

r i j = p o s _ r n [ i n d e x [ 1 ] ] − p o s _ r 0 [ i n d e x [ 0 ] ]
p r i m _ c e l l . a d d _ h o p p i n g ( rn ,

i n d e x [ 0 ] ,

i n d e x [ 1 ] ,

c a l c _ h o p ( r i j ) )

Here in line 2 we call the sync_array function to update the attributes of prim_cell. Then the Cartesian coordinates
of orbitals are obtained via the orb_pos_nm attribute. In the following lines, we loop over the neighboring cells to
ﬁnd the orbital pairs up to the cutoff distance max_distance utilizing KDTree. The hopping terms are then evaluated
according to the displacement vector rij with the calc_hop function and added to the primitive cell. The calc_hop
function is deﬁned according to the formulation in Ref. [82]

d e f c a l c _ h o p ( r i j ) :
a0 = 0 . 1 4 1 8
a1 = 0 . 3 3 4 9
r _ c = 0 . 6 1 4 0
l _ c = 0 . 0 2 6 5
gamma0 = 2 . 7
gamma1 = 0 . 4 8
d e c a y = 2 2 . 1 8
q _ p i = d e c a y * a0
q _ s i g m a = d e c a y * a1
d r = norm ( r i j ) . i t e m ( )
n = r i j . i t e m ( 2 )
v _ p p _ p i = − gamma0 * math . exp ( q _ p i * ( 1 − d r
v _ p p _ s i g m a = gamma1 * math . exp ( q _ s i g m a * ( 1 − d r
f c = 1 /
hop = ( n **2 * v _ p p _ s i g m a + ( 1 − n * * 2 ) * v _ p p _ p i ) * f c
r e t u r n hop

( 1 + math . exp ( ( d r − r _ c )

/ a0 ) )

l _ c ) )

/ d r

/

/ a1 ) )

With all the functions ready, we proceed to build the hetero-structure. In line 2-4 we evaluate the twisting angle
of bilayer graphene for i = 5. Then we construct the primitive cells of the ﬁxed and twisted layers with the
make_graphene_diamond function. The ﬁxed primitive cell is located at z = 0 and does not need rotation or shifting.
On the other hand, the twisted primitive cell needs to be rotated counter-clockwise by the twisting angle and shifted
towards +z by 0.3349 nm, which is done with the spiral_prim_cell function. After that, we reshape the primitive
cells to the lattice vectors of hetero-structure with the make_hetero_layer function, which is a wrapper to coordinate
conversion and reshape_prim_cell. Then the layers are merged with merge_prim_cell and the hopping terms are
extended with extend_hop using a cutoff distance of 0.75 nm. Finally, a sample with 4 × 4 × 1 merged cells is created
and plotted, with the hopping terms below 0.3 eV hidden for clarity. The output is shown in Fig. 5 (c), where the Moiré
pattern can be clearly observed.

d e f main ( ) :

# E v a l u a t e
i = 5
a n g l e = c a l c _ t w i s t _ a n g l e ( i )

t w i s t i n g a n g l e

# P r e p a r e p r i m i t i v e
p r i m _ c e l l _ f i x e d = t b . m a k e _ g r a p h e n e _ d i a m o n d ( )
p r i m _ c e l l _ t w i s t e d = t b . m a k e _ g r a p h e n e _ d i a m o n d ( )

c e l l s o f

f i x e d and t w i s t e d l a y e r

xxxi

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

1

2

3

4

5

1

2

3

1

2

3

4

5

6

7

8

# S h i f t and r o t a t e
t b . s p i r a l _ p r i m _ c e l l ( p r i m _ c e l l _ t w i s t e d ,

t w i s t e d l a y e r

t h e

a n g l e = a n g l e ,

s h i f t = 0 . 3 3 4 9 )

# R e s h a p e p r i m i t i v e
h e t e r o _ l a t t i c e = c a l c _ h e t e r o _ l a t t i c e ( i , p r i m _ c e l l _ f i x e d )
l a y e r _ f i x e d = t b . m a k e _ h e t e r o _ l a y e r ( p r i m _ c e l l _ f i x e d , h e t e r o _ l a t t i c e )
l a y e r _ t w i s t e d = t b . m a k e _ h e t e r o _ l a y e r ( p r i m _ c e l l _ t w i s t e d , h e t e r o _ l a t t i c e )

l a t t i c e v e c t o r s o f h e t e r o − s t r u c t u r e

t o t h e

c e l l s

# Merge l a y e r s
m e r g e d _ c e l l = t b . m e r g e _ p r i m _ c e l l ( l a y e r _ f i x e d ,

l a y e r _ t w i s t e d )

# E x t e n d h o p p i n g t e r m s
e x t e n d _ h o p ( m e r g e d _ c e l l , m a x _ d i s t a n c e = 0 . 7 5 )

# V i s u a l i z e Moire p a t t e r n
s a m p l e = t b . Sample ( t b . S u p e r C e l l ( m e r g e d _ c e l l , dim = ( 4 , 4 , 1 ) , pbc = ( True , True ,

F a l s e ) ) )

s a m p l e . p l o t ( w i t h _ o r b i t a l s = F a l s e , h o p _ a s _ a r r o w s = F a l s e , h o p _ e n g _ c u t o f f = 0 . 3 )

i f __name__ == " __main__ " :

main ( )

4.7.2 Quasicrystal

Here we consider the construction of hetero structure-based quasicrystal, in which we also need to shift, twist,
reshape and merge the cells. Taking bilayer graphene quasicrystal as an example, a quasicrystal with 12-fold symmtery
is formed by twisting one layer by 30◦ with respect to the center of c = 2
3 a2, where a1 and a2 are the lattice
vectors of the primitive cell of ﬁxed layer. We begin with deﬁning the geometric parameters

3 a1 + 2

a n g l e = 30 / 180 * math . p i
c e n t e r = ( 2 . / 3 , 2 . / 3 , 0 )
r a d i u s = 3 . 0
s h i f t = 0 . 3 3 4 9
dim = ( 3 3 , 3 3 , 1 )

Here angle is the twisting angle and center is the fractional coordinate of twisting center. The radius of the
quasicrystal is controlled by radius, while shift speciﬁes the interlayer distance. We need a large cell to hold the
quasicrystal, whose dimension is given in dim. After introducing the parameters, we build the ﬁxed and twisted layers
by

p r i m _ c e l l = t b . m a k e _ g r a p h e n e _ d i a m o n d ( )
l a y e r _ f i x e d = t b . e x t e n d _ p r i m _ c e l l ( p r i m _ c e l l , dim=dim )
l a y e r _ t w i s t e d = t b . e x t e n d _ p r i m _ c e l l ( p r i m _ c e l l , dim=dim )

Then we shift and rotate the twisted layer with respect to the center and reshape it to the lattice vectors of ﬁxed layer

t h e C a r t e s i a n c o o r d i n a t e o f

# Get
c e n t e r = np . a r r a y ( [ dim [ 0 ] / / 2 , dim [ 1 ] / / 2 , 0 ] ) + c e n t e r
c e n t e r = np . matmul ( c e n t e r , p r i m _ c e l l . l a t _ v e c )

t w i s t i n g c e n t e r

s h i f t

and r e s h a p e t o p l a y e r

# T w i s t ,
t b . s p i r a l _ p r i m _ c e l l ( l a y e r _ t w i s t e d ,
conv_mat = np . matmul ( l a y e r _ f i x e d . l a t _ v e c , np . l i n a l g . i n v ( l a y e r _ t w i s t e d . l a t _ v e c ) )
l a y e r _ t w i s t e d = t b . r e s h a p e _ p r i m _ c e l l ( l a y e r _ t w i s t e d , conv_mat )

c e n t e r = c e n t e r ,

a n g l e = a n g l e ,

s h i f t = s h i f t )

xxxii

1

2

1

2

3

4

5

6

7

8

9

10

1

2

Since we have extended the primitive cell by 33 × 33 × 1 times, and we want the quasicrystal to be located in the
center of the cell, we need to convert the coordinate of twisting center in line 2-3. The twisting operation is done by the
spiral_prim_cell function, where the Cartesian coordinate of the center is given in the center argument. The ﬁxed
and twisted layers have the same lattice vectors after reshaping, so we can merge them safely

# Merge b o t t o m and t o p l a y e r s
f i n a l _ c e l l = t b . m e r g e _ p r i m _ c e l l ( l a y e r _ t w i s t e d ,

l a y e r _ f i x e d )

Then we remove unnecessary orbitals to produce a round quasicrystal with ﬁnite radius. This is done by a loop over
orbital positions to collect the indices of unnecessary orbitals, and function calls to remove_orbitals and trim
functions

# Remove u n n e c e s s a r y o r b i t a l s
i d x _ r e m o v e = [ ]
o r b _ p o s = f i n a l _ c e l l . orb_pos_nm
f o r

i , p o s
i f np . l i n a l g . norm ( p o s [ : 2 ] − c e n t e r [ : 2 ] ) > r a d i u s :

i n e n u m e r a t e ( o r b _ p o s ) :

i d x _ r e m o v e . a p p e n d ( i )

f i n a l _ c e l l . r e m o v e _ o r b i t a l s ( i d x _ r e m o v e )

# Remove d a n g l i n g o r b i t a l s
f i n a l _ c e l l . t r i m ( )

Finally, we extend the hoppings and visualize the quasicrystal

e x t e n d _ h o p ( f i n a l _ c e l l )
f i n a l _ c e l l . p l o t ( w i t h _ c e l l s = F a l s e , w i t h _ o r b i t a l s = F a l s e , h o p _ a s _ a r r o w s = F a l s e ,

h o p _ e n g _ c u t o f f = 0 . 3 )

The output is shown in Fig. 6.

Figure 6: Plot of the quasicrystal formed from the incommensurate 30◦ twisted bilayer graphene with a radius of 3 nm.

xxxiii

4.7.3 Fractal

Generally, fractals can be constructed in two approaches, namely bottom-up and top-down, as demonstrated in Fig.
7. The bottom-up approach builds the fractal by iteratively replicating the fractal of low iteration number following
some speciﬁc pattern. On the contrary, the top-down approach builds a large model at ﬁrst, then recursively removes
unnecessary orbitals and hopping terms following the pattern. Both approaches can be implemented with TBPLaS,
while the top-down approach is faster.

In this section, we will take the Sierpi´nski carpet as an example and built it in the top-down approach. We begin with

deﬁning the following auxiliary classes

c l a s s Box :

d e f _ _ i n i t _ _ ( s e l f ,

i 0 ,

j 0 ,

i 1 ,

j 1 , v o i d = F a l s e ) :

s e l f . i 0 = i 0
s e l f . j 0 = j 0
s e l f . i 1 = i 1
s e l f . j 1 = j 1
s e l f . v o i d = v o i d

c l a s s Mask :

d e f _ _ i n i t _ _ ( s e l f ,

s t a r t i n g _ b o x , num_grid , n u m _ i t e r = 0 ) :

s e l f . b o x e s = [ s t a r t i n g _ b o x ]
s e l f . n u m _ g r i d = n u m _ g r i d
f o r

i n r a n g e ( n u m _ i t e r ) :

i
new_boxes = [ ]
f o r box i n s e l f . b o x e s :

new_boxes . e x t e n d ( s e l f . p a r t i t i o n _ b o x ( box ) )

s e l f . b o x e s = new_boxes

d e f p a r t i t i o n _ b o x ( s e l f , box ) :

i f box . v o i d :

s u b _ b o x e s = [ box ]

e l s e :

s u b _ b o x e s = [ ]
d i = ( box . i 1 − box . i 0 + 1 )
d j = ( box . j 1 − box . j 0 + 1 )
f o r

i i
i 0 = box . i 0 + i i * d i
i 1 = i 0 + d i
f o r

i n r a n g e ( s e l f . n u m _ g r i d ) :

/ /
/ /

s e l f . n u m _ g r i d
s e l f . n u m _ g r i d

i n r a n g e ( s e l f . n u m _ g r i d ) :

j j
j 0 = box . j 0 + j j * d j
j 1 = j 0 + d j
i f

( 1 <= i i < s e l f . n u m _ g r i d − 1 and

1 <= j j < s e l f . n u m _ g r i d − 1 ) :

v o i d = T r u e

e l s e :

v o i d = F a l s e

r e t u r n s u b _ b o x e s

s u b _ b o x e s . a p p e n d ( Box ( i 0 ,

j 0 ,

i 1 ,

j 1 , v o i d ) )

d e f

e t c h _ p r i m _ c e l l ( s e l f , p r i m _ c e l l , w i d t h ) :
p r i m _ c e l l . s y n c _ a r r a y ( )
m a s k e d _ i d _ p c = [ ]
f o r box i n s e l f . b o x e s :

i f box . v o i d :

i d _ p c = [ ( i a ,

i b )

f o r
f o r

i n r a n g e ( box . i 0 , box . i 1 )

i a
i b i n r a n g e ( box . j 0 , box . j 1 ) ]

m a s k e d _ i d _ p c . e x t e n d ( i d _ p c )

m a s k e d _ i d _ p c = [ i [ 0 ] * w i d t h + i [ 1 ]
i
p r i m _ c e l l . r e m o v e _ o r b i t a l s ( m a s k e d _ i d _ p c )
p r i m _ c e l l . s y n c _ a r r a y ( )

f o r

i n m a s k e d _ i d _ p c ]

xxxiv

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

1

2

3

4

5

6

7

8

9

10

11

1

2

3

4

1

2

3

1

2

1

2

Here the Box represents a rectangular area spanning from [i0, j0] to (i1, j1). If the box is marked as void, then the
orbitals inside it will be removed. The Mask class is a collection of boxes, which recursively partitions them into smaller
boxes and marks the central boxes as void. It offers the etch_prim_cell function to produce the fractal by removing
orbitals falling into void boxes.

To demonstrate the usage of the auxiliary classes, we deﬁne the geometric parameters and create a square primitive

cell

# G e o m e t r i c p a r a m e t e r s
s t a r t _ w i d t h = 2
e x t e n s i o n = 3
i t e r a t i o n = 4

# C r e a t e a s q u a r e p r i m i t i v e
l a t t i c e = np . e y e ( 3 , d t y p e =np . f l o a t 6 4 )
p r i m _ c e l l = t b . P r i m i t i v e C e l l ( l a t t i c e )
p r i m _ c e l l . a d d _ o r b i t a l ( ( 0 , 0 ) )
p r i m _ c e l l . a d d _ h o p p i n g ( ( 1 , 0 ) , 0 , 0 , 1 . 0 )
p r i m _ c e l l . a d d _ h o p p i n g ( ( 0 , 1 ) , 0 , 0 , 1 . 0 )

c e l l

The Sierpi´nski carpet is characterized by 3 parameters: the starting width S, the extension L which controls the pattern,
and the iteration number I, as shown in Fig. 7. We extend the square primitive cell to the ﬁnal width of the carpet,
which is determined as D = S · LI

# C r e a t e t h e e x t e n d e d c e l l
f i n a l _ w i d t h = s t a r t _ w i d t h * e x t e n s i o n ** i t e r a t i o n
e x t e n d e d _ c e l l = t b . e x t e n d _ p r i m _ c e l l ( p r i m _ c e l l , dim = ( f i n a l _ w i d t h ,
e x t e n d e d _ c e l l . a p p l y _ p b c ( ( F a l s e , F a l s e , F a l s e ) )

f i n a l _ w i d t h , 1 ) )

Then we create a box covering the whole extended cell and a mask from the box. The bottom-left corner of the box is
located at [0, 0], while the top-right corner is at (D − 1, D − 1)

# C r e a t e t h e mask
s t a r t _ b o x = Box ( 0 , 0 ,
mask = Mask ( s t a r t _ b o x , n u m _ g r i d = e x t e n s i o n , n u m _ i t e r = i t e r a t i o n )

f i n a l _ w i d t h −1 ,

f i n a l _ w i d t h − 1 )

Then we call the etch_prim_cell function to remove the orbitals falling into void boxes of the mask

# Remove o r b i t a l s
mask . e t c h _ p r i m _ c e l l ( e x t e n d e d _ c e l l ,

f i n a l _ w i d t h )

Finally, we visualize the fractal

# P l o t
e x t e n d e d _ c e l l . p l o t ( w i t h _ o r b i t a l s = F a l s e , w i t h _ c e l l s = F a l s e , w i t h _ c o n j = F a l s e ,

f r a c t a l

t h e

h o p _ a s _ a r r o w s = F a l s e )

The output is shown in Fig. 8.

4.8 Strain and external ﬁelds

In this section, we introduce the common procedure of applying strain and external ﬁelds on the model. It is difﬁcult
to design common out-of-the-box user APIs that offer such functionalities since they are strongly case-dependent.
Generally, the user should implement these perturbations by modifying model attributes such as orbital positions, on-site

xxxv

Figure 7: Schematic plot of constructing Sierpi´nski carpet with S = 2, L = 3 and I = 2 in (a)-(c) bottom-up and (d)-(f)
top-down approaches. The dashed squares in (a)-(c) and ﬁlled squares in (d)-(f) indicate the void areas in the fractal.

energies and hopping integrals. For the primitive cell, it is straightforward to achieve this goal with the set_orbital
and add_hopping functions, as mentioned in section 3.2. The Sample class, on the contrary, does not offer such
functions. Instead, the user should work with the attributes directly. In the Sample class, orbital positions and on-site
energies are stored in the orb_pos and orb_eng attributes. Hopping terms are represented with 3 attributes: hop_i
and hop_j for orbital indices, and hop_v for hopping integrals. There is also an auxiliary attribute dr which holds the
hopping vectors. All the attributes are NumPy arrays. The on-site energies and hopping terms can be modiﬁed directly,
while the orbital positions should be changed via a modiﬁer function. The hopping vectors are updated from the orbital
positions and hopping terms automatically, thus no need of explicit modiﬁcation.

As the example, we will investigate the propagation of wave function in a graphene sample. We begin with deﬁning
the functions for adding strain and external ﬁelds, then calculate and plot the time-dependent wave function to check
their effects on the propagation. The impact of magnetic ﬁeld on electronic structure will also be discussed.

4.8.1 Functions for strain

Strain will introduce deformation into the model, changing both orbital positions and hopping integrals. It is a rule
that orbital positions should not be modiﬁed directly, but through a modiﬁer function. We consider a Gaussian bump
deformation, and deﬁne the following function to generate the modiﬁer

d e f make_deform ( c e n t e r ,

s i g m a = 0 . 5 ,

e x t e n t = ( 1 . 0 , 1 . 0 ) ,

s c a l e = ( 0 . 5 , 0 . 5 ) ) :

d e f _ d e f o r m ( o r b _ p o s ) :

x , y , z = o r b _ p o s [ : , 0 ] , o r b _ p o s [ : , 1 ] , o r b _ p o s [ : , 2 ]
dx = ( x − c e n t e r [ 0 ] ) * e x t e n t [ 0 ]
dy = ( y − c e n t e r [ 1 ] ) * e x t e n t [ 1 ]
amp = np . exp ( − ( dx **2 + dy * * 2 )
/
x += amp * dx * s c a l e [ 0 ]
y += amp * dy * s c a l e [ 0 ]
z += amp * s c a l e [ 1 ]

( 2 * s i g m a * * 2 ) )

r e t u r n _ d e f o r m

1

2

3

4

5

6

7

8

9

10

xxxvi

Figure 8: Sierpi´nski carpet with S = 2, L = 3 and I = 4.

Here center, sigma and extent control the location, width and extent of the bump. For example, if extent is set
to (1.0, 0.0), the bump will become one-dimensional which varies along x-direction while remains constant along
y-direction. scale speciﬁes the scaling factors for in-plane and out-of-plane displacements. The make_deform
function returns another function as the modiﬁer, which updates the orbital positions in place according to the following
expression

i − c(cid:107)

0) · s(cid:107),

ri → ri + ∆i,
i = Ai · (r(cid:107)
∆(cid:107)
i = Ai · s⊥,
∆⊥



Ai = exp

−

1
2σ2

2
(cid:88)

(rj

i − cj

0)2 · ηj

j=1



 ,

(100)

(101)

(102)

(103)

where ri is the position of i-th orbital, ∆i is the displacement, s is the scaling factor, (cid:107) and ⊥ are the in-plane and
out-of-plane components. The location, width and extent of the bump are denoted as c0, σ and η, respectively.

In addition to the orbital position modiﬁer, we also need to update hopping integrals

1

2

3

4

5

d e f u p d a t e _ h o p ( s a m p l e ) :

s a m p l e . i n i t _ h o p ( )
s a m p l e . i n i t _ d r ( )
r i j
f o r

i n e n u m e r a t e ( s a m p l e . d r ) :
i ,
s a m p l e . hop_v [ i ] = c a l c _ h o p ( r i j )

As we will make use of the hopping terms and vectors, we should call the init_hop and init_dr functions to initialize
the attributes. Similar rule holds for the on-site energies and orbital positions, as discussed in section 3.4. Then we loop
over the hopping terms to update the integrals in hop_v according to the vectors in dr with the calc_hop function,
which is deﬁned in section 4.7.1.

xxxvii

4.8.2 Functions for external ﬁelds

The effects of external electric ﬁeld can be modeled by adding position-dependent potential to the on-site energies.

We consider a Gaussian-type scattering potential described by

Vi = V0 · Ai

(104)

and deﬁne the following function to add the potential to the sample

d e f

c e n t e r ,

s i g m a = 0 . 5 ,

e x t e n t = ( 1 . 0 , 1 . 0 ) , v _ p o t = 1 . 0 ) :

a d d _ e f i e l d ( sample ,
s a m p l e . i n i t _ o r b _ p o s ( )
s a m p l e . i n i t _ o r b _ e n g ( )
o r b _ p o s = s a m p l e . o r b _ p o s
o r b _ e n g = s a m p l e . o r b _ e n g
f o r

i n e n u m e r a t e ( o r b _ p o s ) :

i , p o s
dx = ( p o s . i t e m ( 0 ) − c e n t e r [ 0 ] ) * e x t e n t [ 0 ]
dy = ( p o s . i t e m ( 1 ) − c e n t e r [ 1 ] ) * e x t e n t [ 1 ]
o r b _ e n g [ i ] += v _ p o t * math . exp ( − ( dx **2 + dy * * 2 )

/

( 2 * s i g m a * * 2 ) )

The arguments center, sigma and extent are similar to that of the make_deform function, while v_pot speciﬁes V0.
Similar to update_hop, we need to call init_orb_pos and init_orb_eng to initialize orbital positions and on-site
energies before accessing them. Then the position-dependent scattering potential is added to the on-site energies.

The effects of magnetic ﬁeld can be modeled with Peierls substitution, as discussed in section 2. For ho-
mogeneous magnetic ﬁeld perpendicular to the xOy-plane along −z direction, the Sample class offers an API
set_magnetic_field, which follows the Landau gauge of vector potential A = (By, 0, 0) and updates the hopping
terms as

tij → tij · exp

· (rx

j − rx

i ) · (ry

j + ry
i )

(cid:21)

(cid:20)
i

eB
2(cid:126)c

(105)

where B is the intensity of magnetic ﬁeld, ri and rj are the positions of i-th and j-th orbitals, respectively.

4.8.3 Initial wave functions

The initial wave function we consider here as an example for the propagation is a Gaussian wave-packet, which is

deﬁned by

d e f

i n i t _ w f c _ g a u s s i a n ( sample ,
s a m p l e . i n i t _ o r b _ p o s ( )
o r b _ p o s = s a m p l e . o r b _ p o s
wfc = np . z e r o s ( o r b _ p o s . s h a p e [ 0 ] , d t y p e =np . complex128 )
f o r

i n e n u m e r a t e ( o r b _ p o s ) :

s i g m a = 0 . 5 ,

c e n t e r ,

i , p o s
dx = ( p o s . i t e m ( 0 ) − c e n t e r [ 0 ] ) * e x t e n t [ 0 ]
dy = ( p o s . i t e m ( 1 ) − c e n t e r [ 1 ] ) * e x t e n t [ 1 ]
wfc [ i ] = math . exp ( − ( dx **2 + dy * * 2 )

/

( 2 * s i g m a * * 2 ) )

e x t e n t = ( 1 . 0 , 1 . 0 ) ) :

wfc / = np . l i n a l g . norm ( wfc )
r e t u r n wfc

Note that the wave function should be a complex vector whose length must be equal to the number of orbitals. Also, it
should be normalized before being returned.

4.8.4 Propagation of wave function

We consider a rectangular graphene sample with 50 × 20 × 1 primitive cells, as shown in Fig. 9(a). We begin with

importing the necessary packages and deﬁning some geometric parameters

i m p o r t math
i m p o r t numpy a s np
from numpy . l i n a l g i m p o r t norm
a s
i m p o r t

t b p l a s

t b

xxxviii

1

2

3

4

5

6

7

8

9

1

2

3

4

5

6

7

8

9

10

1

2

3

4

5

6

7

8

9

10

11

12

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

1

2

3

p r i m _ c e l l = t b . m a k e _ g r a p h e n e _ r e c t ( )
dim = ( 5 0 , 2 0 , 1 )
pbc = ( True , True , F a l s e )
x_max = p r i m _ c e l l . l a t _ v e c [ 0 , 0 ] * dim [ 0 ]
y_max = p r i m _ c e l l . l a t _ v e c [ 1 , 1 ] * dim [ 1 ]
w f c _ c e n t e r = ( x_max * 0 . 5 , y_max * 0 . 5 )
d e f o r m _ c e n t e r = ( x_max * 0 . 7 5 , y_max * 0 . 5 )

Here dim and pbc deﬁne the dimension and boundary condition. x_max and y_max are the lengths of the sample along
x and y directions. The initial wave function will be a Gaussian wave-packet located at the center of the sample given
by wfc_center. The deformation and scattering potential will be located at the center of right half of the sample, as
speciﬁed by deform_center and shown in Fig. 9 (b)-(c).

Figure 9: Top and side views of (a) pristine graphene sample and (b) sample with deformation. (c) Plot of on-site
energies of graphene sample with scattering potential.

We ﬁrstly investigate the propagation of a one-dimensional Gaussian wave-packet in pristine sample, which is given

by

# P r e p a r e t h e s a m p l e and i n i t a l wave f u n c t i o n
s a m p l e = t b . Sample ( t b . S u p e r C e l l ( p r i m _ c e l l , dim , pbc ) )
p s i 0 = i n i t _ w f c _ g a u s s i a n ( sample ,

c e n t e r = w f c _ c e n t e r ,

e x t e n t = ( 1 . 0 , 0 . 0 ) )

# P r o p a g a t e t h e wave f u n c t i o n
c o n f i g = t b . C o n f i g ( )
c o n f i g . g e n e r i c [ " n r _ t i m e _ s t e p s " ] = 128
t i m e _ l o g = np . a r r a y ( [ 0 , 1 6 , 3 2 , 6 4 , 1 2 8 ] )
s a m p l e . r e s c a l e _ h a m ( )
s o l v e r = t b . S o l v e r ( sample ,
p s i _ t = s o l v e r . c a l c _ p s i _ t ( p s i 0 ,

t i m e _ l o g )

c o n f i g )

# V i s u a l i z e
v i s = t b . V i s u a l i z e r ( )
f o r

t h e t i m e − d e p e n d e n t wave f u n c t i o n

i n r a n g e ( l e n ( t i m e _ l o g ) ) :

i
v i s . p l o t _ w f c ( sample , np . a b s ( p s i _ t [ i ] ) * * 2 , cmap= " h o t " ,

s c a t t e r = F a l s e )

As the propagation is performed with the calc_psi_t function of Solver class, it follows the common procedure of
TBPM calculation. We propagate the wave function by 128 steps, and save the snapshots in psi_t at the time steps
speciﬁed in time_log. The snapshots are then visualized by the plot_wfc function of Visualizer class, as shown
in Fig. 10(a)-(e), where the wave-packet diffuses freely, hits the boundary and forms interference pattern.

We then add the bump deformation to the sample, by assigning the modiﬁer function to the supercell and calling

update_hop to update the hopping terms

d e f o r m = make_deform ( c e n t e r = d e f o r m _ c e n t e r )
s a m p l e = t b . Sample ( t b . S u p e r C e l l ( p r i m _ c e l l , dim , pbc , o r b _ p o s _ m o d i f i e r = d e f o r m ) )
u p d a t e _ h o p ( s a m p l e )

xxxix

The propagation of wave-packet in deformed graphene sample is shown in Fig. 10(f)-(j). Obviously, the wave function
gets scattered by the bump. Although similar interference pattern is formed, the propagation in the right part of the
sample is signiﬁcantly hindered, due to the increased inter-atomic distances and reduced hopping integrals at the bump.

Similar phenomena are observed when the scattering potential is added to the sample by

1

a d d _ e f i e l d ( sample ,

c e n t e r = d e f o r m _ c e n t e r )

The time-dependent wave function is shown in Fig. 10(k)-(o). Due to the higher on-site energies, the probability of
emergence of electron is suppressed near the scattering center.

Figure 10: (a)-(e) Propagation of one-dimensional Gaussian wave-packet in pristine graphene sample. (f)-(j) Propagation
in graphene sample with deformation, (k)-(o) with scattering potential and (p)-(t) with magnetic ﬁeld of 50 Tesla.

As for the effects of magnetic ﬁeld, it is well known that Landau levels will emerge in the DOS, as shown in Fig. 4(d).
The analytical solution to Schrödinger’s equation for free electron in homogeneous magnetic ﬁeld with A = (By, 0, 0)
shows that the wave function will propagate freely along x and z-directions while oscillates along y-direction. To
simulate this process, we apply the magnetic ﬁeld to the sample by

1

s a m p l e . s e t _ m a g n e t i c _ f i e l d ( 5 0 )

The snapshots of time-dependent wave function are shown in Fig. 10(p)-(t). The interference pattern is similar to the
case without magnetic ﬁeld, as the wave function propagates freely along x direction. However, due to the oscillation
along y-direction, the interference pattern gets distorted during the propagation. These phenomena agree well with the
analytical results.

xl

4.9 Parallelization

In this section, we give the general guidelines to set up the parallelization environment and show how to run
calculations in parallel mode within TBPLaS. It should be noted that the determination of optimal parallelization
conﬁguration is a non-trivial task and strongly case-dependent. So, the guidelines provided here serve only as a starting
point, whereas intensive tests and benchmarks are required before production runs.

4.9.1 General guidelines

The technical details of parallelism of TBPLaS have been discussed in section 3.6. Up to now, hybrid MPI+OpenMP
parallelization has been implemented for the evaluation of band structure and DOS from exact-diagonalization, response
properties from Lindhard function, and TBPM calculations. Both MPI and OpenMP can be switched on/off separately
on demand, while pure OpenMP mode is enabled by default.

The number of OpenMP threads is controlled by the OMP_NUM_THREADS environment variable. If TBPLaS has been
compiled with MKL support, then the MKL_NUM_THREADS environment variable will also take effect. If none of the
environment variables has been set, OpenMP will make use of all the CPU cores on the computing node. To switch
off OpenMP, set the environment variables to 1. On the contrary, MPI-based parallelization is disabled by default,
but can be easily enabled with a single option. The calc_bands and calc_dos functions of PrimitiveCell and
Sample classes, the initialization functions of Lindhard, Solver and Analyzer classes all accept an argument named
enable_mpi whose default value is taken to be False. If set to True, MPI-based parallelization is turned on, provided
that the MPI4PY package has been installed. Hybrid MPI+OpenMP parallelization is achieved by enabling MPI and
OpenMP simultaneously. The number of processes is controlled by the MPI launcher, which receives arguments from
the command line, environment variables or conﬁguration ﬁle. The user is recommended to check the manual of job
queuing system on the computer for properly setting the environment variables and invoking the MPI launcher. For
computers without a queuing system, e.g., laptops, desktops and standalone workstations, the MPI launcher should be
mpirun or mpiexec, while the number of processes is controlled by the -np command line option.

The optimal parallelization conﬁguration, i.e., the numbers of MPI processes and OpenMP threads, depend on the
hardware, the model size and the type of calculation. Generally speaking, matrix diagonalization for a single k-point
is poorly parallelized over threads. But the diagonalization for multiple k-points can be efﬁciently parallelized over
processes. Therefore, for band structure and DOS calculations, as well as response properties from Lindhard function,
it is recommended to run in pure MPI-mode by setting the number of MPI processes to the total number of allocated
CPU cores and the number of OpenMP threads to 1. However, MPI-based parallelization uses more RAM since every
process has to keep a copy of the wave functions and energies. So, if the available RAM imposes a limit, try to use
less processes and more threads. Anyway, the product of the numbers of processes and threads should be equal to the
number of allocated CPU cores. For example, if you have allocated 16 cores, then you can try 16 processes × 1 thread,
8 processes × 2 threads, 4 processes × 4 threads, etc. For TBPM calculations, the number of random initial wave
functions should be divisible by the number of processes. For example, if you are going to consider 16 initial wave
functions, then the number of processes should be 1, 2, 4, 8, or 16. The number of threads should be set according to
the number of processes. Again, if the RAM size is a problem, try to decrease the number of processes and increase the
number of threads.

If MPI-based parallelization is enabled, either in pure MPI or hybrid MPI+OpenMP mode, special care should be
taken to output and plotting part of the job script. These operations should be performed on the master process only,
otherwise the output will mess up or ﬁles get corrupted, since all the processes will try to modify the same ﬁle or
plotting the same data. This situation is avoided by checking the rank of the process before action. The Lindhard,
, Solver, Analyzer and Visualizer classes all offer an is_master attribute to detect the master process, whose
usage will be demonstrated in the following sections.

Last but not least, we have to mention that all the calculations in previous sections can be run in either interactive
or batch mode. You can input the script line-by-line in the terminal, or save it to a ﬁle and pass the ﬁle to the Python
interpreter. However, MPI-based parallelization supports only the batch mode, since there is no possibility to input
anything in the terminal for multiple processes in one time. In the following sections, we assume the script ﬁle to be
test_mpi.py. A common head block of the script is given in 4.9.2 and will not be explicitly repeated in subsequent
sections.

4.9.2 Band structure and DOS

We demonstrate the usage of calc_bands and calc_dos in parallel mode by calculating the band structure and
DOS of a 12 × 12 × 1 graphene sample. Procedure shown here is also valid for the primitive cell. To enable MPI-based
parallelization, we need to save the script to a ﬁle, for instance, test_mpi.py. The head block of this ﬁle should be

xli

1

2

3

4

5

6

7

8

1

1

1

2

3

4

5

6

7

8

9

10

11

12

13

#!

/ u s r / b i n / env p y t h o n

i m p o r t numpy a s np
i m p o r t

t b p l a s

a s

t b

t i m e r = t b . Timer ( )
v i s = t b . V i s u a l i z e r ( e n a b l e _ m p i = T r u e )

where the ﬁrst line is a magic line declaring that the script should be interpreted by the Python program. In the following
lines we import the necessary packages. To record and report the time usage, we need to create a timer from the
Timer class. We also need a visualizer for plotting the results, where the enable_mpi argument is set to True during
initialization. This head block also is essential for other examples in subsequent sections.

For convenience, we will not build the primitive cell from scratch, but import it from the material repository with the

make_graphene_diamond function

c e l l = t b . m a k e _ g r a p h e n e _ d i a m o n d ( )

Then we build the sample by

s a m p l e = t b . Sample ( t b . S u p e r C e l l ( c e l l , dim = ( 1 2 , 1 2 , 1 ) , pbc = ( True , True , F a l s e ) ) )

The evaluation of band structure in parallel mode is similar to the serial mode, which also involves generating the
k-path and calling calc_bands. The only difference is that we need to set the enable_mpi argument to True when
calling calc_bands

k _ p o i n t s = np . a r r a y ( [

[ 0 . 0 , 0 . 0 , 0 . 0 ] ,
[ 2 . / 3 , 1 . / 3 , 0 . 0 ] ,
[ 1 . / 2 , 0 . 0 , 0 . 0 ] ,
[ 0 . 0 , 0 . 0 , 0 . 0 ] ,

] )
k _ p a t h , k _ i d x = t b . g e n _ k p a t h ( k _ p o i n t s ,
t i m e r . t i c ( " band " )
k _ l e n , b a n d s = s a m p l e . c a l c _ b a n d s ( k _ p a t h ,
t i m e r . t o c ( " band " )
v i s . p l o t _ b a n d s ( k _ l e n , bands , k _ i d x , k _ l a b e l )
i f v i s . i s _ m a s t e r :

t i m e r . r e p o r t _ t o t a l _ t i m e ( )

[ 4 0 , 4 0 , 4 0 ] )

e n a b l e _ m p i = T r u e )

The tic and toc functions begin and end the recording of time usage, which receive a string as the argument for
tagging the record. The visualizer is aware of the parallel environment, so no special treatment is needed when plotting
the results. Finally, the time usage is reported with the report_total_time function on the master process only, by
checking the is_master attribute of the visualizer.

We run test_mpi.py by

1

2

$ e x p o r t OMP_NUM_THREADS=1
$ m p i r u n −np 1 . / t e s t _ m p i . py

With the environment variable OMP_NUM_THREADS set to 1, the script will run in pure MPI-mode. We invoke 1 MPI
process by the -np option of the MPI launcher (mpirun). The output should look like

xlii

1

1

2

3

4

1

2

3

4

5

6

7

1

1

2

3

4

5

6

band :

1 1 . 0 3 s

So, the evaluation of bands takes 11.03 seconds on 1 process. We try with more processes

$ m p i r u n −np 2 . / t e s t _ m p i . py

band :

5 . 7 1 s

$ m p i r u n −np 4 . / t e s t _ m p i . py

band :

2 . 9 3 s

Obviously, the time usage scales reversely with the number of processes. Detailed discussion on the time usage and
speedup under different parallelization conﬁgurations will be discussed in section 4.9.5.

Evaluation of DOS can be parallelized in the same approach, by setting the enable_mpi argument to True

k_mesh = t b . gen_kmesh ( ( 2 0 , 2 0 , 1 ) )
t i m e r . t i c ( " d o s " )
e n e r g i e s , d o s = s a m p l e . c a l c _ d o s ( k_mesh ,
t i m e r . t o c ( " d o s " )
v i s . p l o t _ d o s ( e n e r g i e s , d o s )
i f v i s . i s _ m a s t e r :

t i m e r . r e p o r t _ t o t a l _ t i m e ( )

e n a b l e _ m p i = T r u e )

The script can be run in the same approach as evaluating the band structure.

4.9.3 Response properties from Lindhard function

To evaluate response properties in parallel mode, simply set the enable_mpi argument to True when creating the

Lindhard calculator

l i n d = t b . L i n d h a r d ( c e l l = c e l l , energy_max = 1 0 . 0 , e n e r g y _ s t e p =2048 , k m e s h _ s i z e = ( 6 0 0 ,

6 0 0 , 1 ) , mu = 0 . 0 ,
e n a b l e _ m p i = T r u e )

t e m p e r a t u r e = 3 0 0 . 0 , g _ s =2 , b a c k _ e p s i l o n = 1 . 0 , d i m e n s i o n =2 ,

Subsequent calls to the functions of Lindhard class does not need further special treatment. For example, the optical
conductivity can be evaluated in the same approach as in serial mode

t i m e r . t i c ( " a c _ c o n d " )
omegas , a c _ c o n d = l i n d . c a l c _ a c _ c o n d ( component = " xx " )
t i m e r . t o c ( " a c _ c o n d " )
v i s . p l o t _ x y ( omegas , a c _ c o n d )
i f v i s . i s _ m a s t e r :

t i m e r . r e p o r t _ t o t a l _ t i m e ( )

4.9.4 Properties from TBPM

TBPM calculations in parallel mode are similar to the evaluation of response functions. The user only needs to set

the enable_mpi argument to True. To make the time usage noticeable, we build a larger sample ﬁrst

1

s a m p l e = t b . Sample ( t b . S u p e r C e l l ( c e l l , dim = ( 2 4 0 , 2 4 0 , 1 ) , pbc = ( True , True , F a l s e ) ) )

Then we create the conﬁguration, solver and analyzer, with the argument enable_mpi=True

xliii

Table 4: Time usages and speedups of benchmarks for various calculation types with respect to the numbers of MPI
processes (np) and OpenMP threads (nt) per process. The standard (t0) of each type is deﬁned as the time usage on 1
process × 1 thread, while the speedup is deﬁned as t0/tnpnt. Numbers in the brackets are the average speedups to each
CPU core deﬁned as t0/(tnpnt × np × nt).

Type

t0/s

np

Band structure

2.56

DOS

10.62

Optical conductivity

24.45

TBPM

24.71

1
2
4
1
2
4
1
2
4
1
2
4

1
1.00 (1.00)
1.92 (0.96)
4.00 (1.00)
1.00 (1.00)
1.84 (0.92)
3.74 (0.93)
1.00 (1.00)
1.76 (0.88)
3.30 (0.83)
1.00 (1.00)
1.96 (0.98)
3.55 (0.89)

nt
2
1.19 (0.60)
1.61 (0.40)
3.05 (0.38)
1.17 (0.58)
1.74 (0.44)
3.23 (0.40)
1.58 (0.79)
2.61 (0.65)
4.57 (0.57)
1.91 (0.96)
3.80 (0.95)
6.68 (0.83)

4
1.45 (0.36)
2.03 (0.25)
4.06 (0.25)
1.33 (0.33)
2.00 (0.25)
3.88 (0.24)
2.25 (0.56)
3.49 (0.44)
5.93 (0.37)
3.48 (0.87)
6.84 (0.86)
12.80 (0.80)

1

2

3

4

5

6

1

2

3

4

5

6

7

s a m p l e . r e s c a l e _ h a m ( 9 . 0 )
c o n f i g = t b . C o n f i g ( )
c o n f i g . g e n e r i c [ " n r _ r a n d o m _ s a m p l e s " ] = 4
c o n f i g . g e n e r i c [ " n r _ t i m e _ s t e p s " ] = 256
s o l v e r = t b . S o l v e r ( sample ,
a n a l y z e r = t b . A n a l y z e r ( sample ,

c o n f i g ,

c o n f i g ,

e n a b l e _ m p i = T r u e )

e n a b l e _ m p i = T r u e )

Correlation function can be obtained and analyzed in the same way as in serial mode

t i m e r . t i c ( " c o r r _ d o s " )
c o r r _ d o s = s o l v e r . c a l c _ c o r r _ d o s ( )
t i m e r . t o c ( " c o r r _ d o s " )
e n e r g i e s , d o s = a n a l y z e r . c a l c _ d o s ( c o r r _ d o s )
v i s . p l o t _ d o s ( e n e r g i e s , d o s )
i f v i s . i s _ m a s t e r :

t i m e r . r e p o r t _ t o t a l _ t i m e ( )

4.9.5 Benchmarks

The time usages and speedups of different types of calculations are summarized in Table 4. The benchmarks have
been performed on an Intel(cid:114) Xeon(cid:114) Gold 6248 CPU, with 16 cores allocated at most. It is obvious that for the
evaluation of band structure and DOS, increasing the number of MPI processes signiﬁcantly boosts the calculation.
However, the efﬁciency enhancement of increasing OpenMP threads is much lower. The average speedup drops
signiﬁcantly when OpenMP is enbaled, indicating a poor scaling versus the number of CPU cores. This is due to
the fact that matrix diagonalization cannot be efﬁciently parallelized over threads. On the contrary, pure MPI-based
parallelization has the best efﬁciency, with an almost linear scaling (average speedup ≈ 1).

The evaluation of optical conductivity has an additional post-processing step after diagonalization, which is suitable
for both MPI and OpenMP-based parallelization. So, the speedup and scaling versus the number of threads improve
slightly. For TBPM calculations, the speedups and efﬁciencies of multi-threading and multi-processing are almost equal,
since sparse matrix-vector multiplication can be efﬁciently parallelized over threads. Although pure MPI-mode still has
the best efﬁciency, the number of processes is limited by the number of random initial wave functions and available
RAM size, as discussed in section 4.9.1. So, pure OpenMP or hybrid MPI+OpenMP paralelization is recommended for
TBPM calculations, with the optimal numbers of processes and and threads determined from benchmarks.

xliv

5 Examples

As mentioned in previous sections, TBPLaS is capable of tackling complex systems with tens of billions of atoms.
In this section, we present an example utilizing TBPLaS to calculate the properties of twisted bilayer graphene (TBG)
with twist angle θ = 1.05◦, i.e. the magic angle. For TBG with the magic angle, ﬂat bands appear near the Fermi
level, which provide a platform to explore strongly correlated phases and superconductivity [9, 12, 83]. The moiré
supercell of twisted bilayer graphene is constructed by identifying a common periodicity between the two layers. We
start with a AA stacking bilayer graphene (θ = 0◦), and choose the rotation origin (O) at an atom site. Then, we rotate
one layer relatively to the other one by the angle θ. Fig. 11 shows the atomic structure of the magic angle TBG. The
moiré superlattice contains three types of high-symmetry staking patterns, namely AA, AB and BA stacking. For TBG
with twist angles smaller that 1.2◦, the system suffers signiﬁcant lattice reconstruction due to the interplay between the
interlayer van der Waals interaction and the in-plane strain ﬁeld [84]. The lattice relaxation (both the out-of-plane and
in-plane) of TBG is performed with the LAMMPS package [85]. The intralyer and interlayer interactions of TBG are
simulated with the long-range carbon bond-order potential [86] and Kolmogorov-Crespi potential [87], respectively.

Figure 11: Atomic structure of TBG with twist angle θ = 1.05◦. Highly-symmetric stacking regions of AA, AB and
BA are marked by red, blue and magenta circles, respectively. Carbon atoms in the top and bottom layers are depicted
in blue and red, respectively.

The magic angle TBG contains 11908 atoms, which is beyond the capability of ﬁrst-principles approach. So, we
utilize the tight-binding method to tackle such a huge system. The properties of both rigid (without lattice relaxation)
and relaxed (with lattice relaxation) TBG with magic angle are calculated with a full tight-binding model based on pz
orbitals [82]. The on-site energies (cid:15)i are set to zero, and the hopping parameters between sites i and j are described by
a distance-dependent function as

tij = n2Vppσ(rij) + (1 − n2)Vppπ(rij)
where rij = |rij| is the distance between two sites located at ri and rj, n is the direction cosine of rij along the
direction that is perpendicular to the graphene layer. The Slater-Koster parameters Vppσ and Vppπ are

(106)

Vppπ(rij) = −t0eqπ(1−rij /d)Fc(rij)
Vppσ(rij) = t1eqσ(1−rij /h)Fc(rij)

(107)

(108)

where d = 1.42 Å and h = 3.349 Å are the nearest in-plane and out-of-plane carbon-carbon distances, respectively.
t0 = 2.8 eV and t1 = 0.44 eV are re-optimized to obtain the magic angle at rotation angle θ = 1.05◦ [52]. The
parameters qσ and qπ satisfy qσ/h = qπ/d = 2.218 Å−1, and the smooth function is deﬁned as Fc(r) = (1 +
e(r−rc)/lc )−1 with lc = 0.265 Åand rc = 5.0 Å.

xlv

Figure 12: Band structures of (a) rigid and (b) relaxed TBG with θ = 1.05◦.

Figure 13: (a) Density of states of relaxed magic angle TBG with (blue line) and without (black line) magnetic ﬁeld. (b)
Local density of states of the highly-symmetric stacking regions of AA (black line) and AB (red line) in relaxed magic
angle TBG.

Fig. 12 shows the band structure of rigid and relaxed TBG with twist angle θ = 1.05◦, which are obtained by exact
diagonalization. In TBG without lattice relaxation (rigid sample), ultraﬂat bands appear in the charge neutrality. The
bandwidth (energy difference between the K and Γ points of the Brillouin zone) of the ﬂat band is 7 meV, and the
bandgap (energy difference between the ﬂat band and the remote bands at the Γ point) is zero. In relaxed sample (with
lattice relaxation), the bandwidth and bandgap are 4 meV and 43 meV, respectively. Obviously, the lattice relaxation
has a signiﬁcant effect on the electronic structure of magic angle TBG. The black line in Fig. 13(a) is the density of
states of relaxed TBG with magic angle, which is calculated via the TBPM in Eq. (42). In the calculations, the accuracy
of the DOS can be guaranteed by utilizing a large enough model with more than ten million atoms. The number of
time integration steps is 4096, which gives an energy resolution of 3.7 meV. In DOS a sharp peak appears in the charge
neutrality, which corresponds to the ﬂat bands. When a perpendicular magnetic ﬁeld is applied, Landau levels appear in
the DOS. The splitting of the peak around the energy E = 68 meV is the lifting of the twofold degeneracy due to the
Dirac point splitting in twisted bilayer graphene [88].

Local density of states (LDOS) is an important quantity to describe the local properties of a system, which can
be utilized to simulate the dI/dV spectra obtained with the scanning tunneling microscopy (STM) in experiments.
TBPLaS provides three approaches to evaluate the LDOS, i.e. exact-diagonalization, TBPM and the recursion method.
Both TBPM and the recursion method are capable of dealing with very large models. The LDOS of different stacking
regions in magic angle TBG obtained with TBPM are shown in Fig. 13. It is clear that the LDOS of the AA and AB

xlvi

(a)(b)(a)(b)regions have obvious different features. Only the LDOS of the AA region has a sharp peak at energy E = 0, which
means that the states of the ﬂat bands are mainly localized in the AA region. The LDOS of the AB region has some
peaks located at high energies. Such strong LDOS modulation shows spatially localized electronic states with speciﬁc
energies, which can be justiﬁed by calculating the LDOS mapping (quasieigenstates) via Eq. (51). The LDOS mappings
at different energies are shown in Fig. 14. At energy E = 0, states are mainly localized in the AA regions. At the
energy E = −0.17 eV, states are mainly localized in the AB and BA regions. Such periodic variation of the local
electronic structure is a consequence of different interlayer couplings in TBG. The LDOS mapping is equivalent to the
dI/dV mapping observed experimentally with STM.

Figure 14: Local density of states mappings of magic angle TBG (with lattice relaxation) at energies E = −0.17 eV,
−0.10 eV, −0.04 eV and 0 eV.

In TBPLaS, we can also investigate the optical conductivity via the Kubo formula or the Lindhard function. The
Lindhard function is more suitable for small models since it requires a diagonalization process. On the contrary, by
combing the Kubo formula and TBPM, we can tackle large models that contain tens of millions of orbitals. In Fig. 15,
the optical conductivity of the magic angle TBG and monolayer graphene is calculated with TBPM. Note that we omit
the Drude weight part in the calculation. For TBG the peak with energy around E = 0.1 eV is due to the transition
between the ﬂat bands and their adjacent bands. A dip-peak feature around E = 0.1 eV is due to the electron-hole
asymmetry [89].

Figure 15: Optical conductivity of relaxed TBG with twist angle θ = 1.05◦ and monolayer graphene. The temperature
is T = 300 K and the chemical potential is µ = 0 eV. The conductivity curves are scaled by σ0 = e2/4(cid:126).

In addition to the optical conductivity, many other response properties can also be obtained with TBPLaS. Fig. 16
shows the electron energy loss function of the magic angle TBG. Firstly, we calculate the dynamical polarization by
using the Kubo formula in Eq. (76). Then the dielectric function and energy loss function are obtained within the
random phase approximation with Eqs. (82) and (83), respectively. The plasmon mode can be detected by many
experimental techniques, e.g. the scattering-type scanning near-ﬁeld optical microscope (s-SNOM) and electron energy
loss spectroscopy. In experiments, when a plasmon mode with frequency ωp exists with low damping, the energy loss
spectra possess a sharp peak at ω = ωp. For the magic angle TBG, interband plasmon modes close to 100 meV appear

xlvii

E = -0.17 eVE = -0.10 eVE = -0.04 eVE = 0 eVAAABBAAA0.00.10.20.30.40.50.60.70.801234sxx/s0w (eV) TBG Grapheneat both temperature T = 300 K and 1 K, which are attributed to the interband transitions from the ﬂat bands to bands
located at energy of 100 meV. These modes originate from the collective oscillations of electrons in the AA region
[90]. The ωp = 100 meV plasmon mode disperses within the particle-hole continuum in Figs. 16(c) and 16(d) with fast
damping into electron-hole pairs. It becomes clear with a ﬁne and ﬂat shape with momentum larger than 0.2 nm−1.
Single-particle transitions are almost forbidden in ﬂat bands below 40 meV, corresponding to the value of band gap
between the ﬂat bands and the excited bands at Γ point, from which the continuum spectrum rises to non-zero zone
in Fig. 16 (c). When the temperature declines to the critical temperature 1 K at which the superconductivity can be
detected in the magic-angle system [9], a thin plasmon mode with energy 9 meV emerges and stretches to large q in
Fig. 16(b), which is contributed to the collective excitations among ﬂat bands, i.e. ﬂat-band plasmon. Meanwhile,
underneath the collective ﬂat-band plasmon mode, the particle-hole transitions arise with occupying a tiny energy region
ranging from 0 meV to 8 meV in Fig. 16(d). As a result, this plasmon mode extends above the edge of this tiny energy
zone and is free from the Laudau damping.

Figure 16: Plot of the loss function −Im [1/(cid:15)(q, ω)] as function of frequency ω and wave vector q for relaxed TBG
with twist angel θ = 1.05◦ at temperatures (a) T = 300 K and (b) T = 1 K [52]. Plot of the particle-hole continuum
−Im Π(q, ω) with respect to the frequency ω and wave vector q at (c) T = 300 K and (d) T = 1 K. The chemical
potential is µ = 0 and the background dielectric constant κ = 3.03 of hBN substrate.

6 Summary

In summary, we have introduced the TBPLaS package, an open-source software suite for accurate electronic structure,
optical properties, plasmon and transport calculations in real-space based on the tight-binding (TB) theory. It has an
intuitive Python API for convenient simulation set-up, and Cython/Fortran cores for efﬁcient performance. The main

xlviii

(a)(b)(c)(d)advantage of TBPLaS is that the numerical calculations is based on the TBPM without diagonalization. Both the memory
and CPU costs have a linear scaling with the system size. So we can tackle models contain tens of millions of atoms or
even billions of atoms if necessary. In addition to TBPM, exact diagonalization-based methods are also implemented.
Moreover, crystalline defects, vacancies, adsorbates, charge impurity centres, strains and external perturbations can be
easily and intuitively set up in TPLaS, which allows us to simulate large and complex models. With a wide range of
pre-deﬁned functions, the numerical calculations can be performed only with a few lines of code.

In the ﬁrst release, TBPLaS already features a large variety of functionalities, e.g. the band structure, DOS, LDOS,
wave functions, plasmon, optical conductivity, electric conductivity, Hall conductivity, quasi-eigenstate, real-space
electron density and wave packet propagation. Moreover, thanks to its extensible and modular nature, it is easy
to implemented other algorithms involving the tight-binding Hamiltonian. Further developments and extensions of
TBPLaS, for instance, the real-space self-consistent Hartree and Hubbard methods for large systems [91, 92] and support
for GPU acceleration, will be implemented in the future.

Acknowledgments

We thank Edo van Veen, Guus Slotman, Kaixiang Huang, Xueheng Kuang, Yalei Zhang for their contributions to
the earlier version of the code. This work is supported by the National Natural Science Foundation of China (Grant
No.12174291) and the National Key R&D Program of China (Grant No. 2018YFA0305800). Numerical calculations
presented in this paper have been performed in the Supercomputing Center of Wuhan University.

Declaration of competing interest

The authors declares no competing interests.

xlix

References

[1] J. C. Slater and G. F. Koster. Simpliﬁed lcao method for the periodic potential problem. Phys. Rev., 94:1498–1524,

Jun 1954.

[2] CM Goringe, DR Bowler, and E Hernandez. Tight-binding modelling of materials. Rep. Prog. Phys., 60(12):1447,

1997.

[3] Shengjun Yuan, Hans De Raedt, and Mikhail I. Katsnelson. Modeling electronic structure and transport properties

of graphene with resonant scattering centers. Phys. Rev. B, 82:115448, Sep 2010.

[4] Anthony Hams and Hans De Raedt. Fast algorithm for ﬁnding the eigenvalue distribution of very large matrices.

Phys. Rev. E, 62:4365–4377, Sep 2000.

[5] Shengjun Yuan, Rafael Roldán, and Mikhail I. Katsnelson. Excitation spectrum and high-energy plasmons in

single-layer and multilayer graphene. Phys. Rev. B, 84(13):035439, Jul 2011.

[6] R Logemann, KJA Reijnders, T Tudorovskiy, MI Katsnelson, and Shengjun Yuan. Modeling klein tunneling and

caustics of electron waves in graphene. Phys. Rev. B, 91(4):045420, 2015.

[7] G. J. Slotman, M. M. van Wijk, Pei-Liang Zhao, A. Fasolino, M. I. Katsnelson, and Shengjun Yuan. Effect
of structural relaxation on the electronic structure of graphene on hexagonal boron nitride. Phys. Rev. Lett.,
115:186801, Oct 2015.

[8] R Haydock, Volker Heine, and MJ Kelly. Electronic structure based on the local atomic environment for

tight-binding bands. J. Phys. C: Solid State Phys, 5(20):2845, 1972.

[9] Yuan Cao, Valla Fatemi, Shiang Fang, Kenji Watanabe, Takashi Taniguchi, Efthimios Kaxiras, and Pablo Jarillo-
Herrero. Unconventional superconductivity in magic-angle graphene superlattices. Nature, 556(7699):43–50,
2018.

[10] Jeong Min Park, Yuan Cao, Kenji Watanabe, Takashi Taniguchi, and Pablo Jarillo-Herrero. Tunable strongly

coupled superconductivity in magic-angle twisted trilayer graphene. Nature, 590(7845):249–255, 2021.

[11] Haoxin Zhou, Ludwig Holleis, Yu Saito, Liam Cohen, William Huynh, Caitlin L Patterson, Fangyuan Yang,
Takashi Taniguchi, Kenji Watanabe, and Andrea F Young. Isospin magnetism and spin-polarized superconductivity
in bernal bilayer graphene. Science, 375(6582):774–778, 2022.

[12] Yuan Cao, Valla Fatemi, Ahmet Demir, Shiang Fang, Spencer L Tomarken, Jason Y Luo, Javier D Sanchez-
Yamagishi, Kenji Watanabe, Takashi Taniguchi, Efthimios Kaxiras, et al. Correlated insulator behaviour at
half-ﬁlling in magic-angle graphene superlattices. Nature, 556(7699):80–84, 2018.

[13] Yonglong Xie, Biao Lian, Berthold Jäck, Xiaomeng Liu, Cheng-Li Chiu, Kenji Watanabe, Takashi Taniguchi,
B Andrei Bernevig, and Ali Yazdani. Spectroscopic signatures of many-body correlations in magic-angle twisted
bilayer graphene. Nature, 572(7767):101–105, 2019.

[14] Xiaobo Lu, Petr Stepanov, Wei Yang, Ming Xie, Mohammed Ali Aamir, Ipsita Das, Carles Urgell, Kenji Watanabe,
Takashi Taniguchi, Guangyu Zhang, et al. Superconductors, orbital magnets and correlated states in magic-angle
bilayer graphene. Nature, 574(7780):653–657, 2019.

[15] Yuhang Jiang, Xinyuan Lai, Kenji Watanabe, Takashi Taniguchi, Kristjan Haule, Jinhai Mao, and Eva Y Andrei.
Charge order and broken rotational symmetry in magic-angle twisted bilayer graphene. Nature, 573(7772):91–95,
2019.

[16] Aaron L Sharpe, Eli J Fox, Arthur W Barnard, Joe Finney, Kenji Watanabe, Takashi Taniguchi, MA Kastner,
and David Goldhaber-Gordon. Emergent ferromagnetism near three-quarters ﬁlling in twisted bilayer graphene.
Science, 365(6453):605–608, 2019.

[17] M Serlin, CL Tschirhart, H Polshyn, Y Zhang, J Zhu, K Watanabe, T Taniguchi, L Balents, and AF Young.

Intrinsic quantized anomalous hall effect in a moiré heterostructure. Science, 367(6480):900–903, 2020.
[18] Zhiren Zheng, Qiong Ma, Zhen Bi, Sergio de La Barrera, Ming-Hao Liu, Nannan Mao, Yang Zhang, Natasha
Kiper, Kenji Watanabe, Takashi Taniguchi, et al. Unconventional ferroelectricity in moiré heterostructures. Nature,
588(7836):71–76, 2020.

[19] Andre K Geim and Irina V Grigorieva. Van der waals heterostructures. Nature, 499(7459):419–425, 2013.
[20] Stephen Carr, Shiang Fang, and Efthimios Kaxiras. Electronic-structure methods for twisted moiré layers. Nat

Rev Mater, 5(10):748–763, 2020.

[21] Jose H. García, Lucian Covaci, and Tatiana G. Rappoport. Real-space calculation of the conductivity tensor for

disordered topological matter. Phys. Rev. Lett., 114:116602, Mar 2015.

l

[22] Christoph W Groth, Michael Wimmer, Anton R Akhmerov, and Xavier Waintal. Kwant: a software package for

quantum transport. New J. Phys., 16(6):063065, 2014.

[23] Pythtb website. http://physics.rutgers.edu/pythtb/. Accessed: 25 July 2019.

[24] Dean Moldovan, Miša An ¯delkovi´c, and Francois Peeters. pybinding v0.9.5: a Python package for tight- binding
calculations, August 2020. This work was supported by the Flemish Science Foundation (FWO-Vl) and the
Methusalem Funding of the Flemish Government.

[25] Alexander Weiße, Gerhard Wellein, Andreas Alvermann, and Holger Fehske. The kernel polynomial method. Rev.

Mod. Phys., 78:275–306, Mar 2006.

[26] Kristofer Björnson. Tbtk: A quantum mechanics software development kit. SoftwareX, 9:205–210, 2019.

[27] Simão M João, Miša An ¯delkovi´c, Lucian Covaci, Tatiana G Rappoport, João MVP Lopes, and Aires Ferreira.
Kite: high-performance accurate modelling of electronic structure and response functions of large molecules,
disordered crystals and heterostructures. R. Soc. open sci., 7(2):191809, 2020.

[28] Aires Ferreira and Eduardo R Mucciolo. Critical delocalization of chiral zero energy modes in graphene. Phys.

Rev. Lett., 115(10):106601, 2015.

[29] Peter H Jacobse. Mathematb: A mathematica package for tight-binding calculations. Comput. Phys. Commun.,

244:392–408, 2019.

[30] Xueheng Kuang, Zhen Zhan, and Shengjun Yuan. Flat-band plasmons in twisted bilayer transition metal

dichalcogenides. Phys. Rev. B, 105:245415, Jun 2022.

[31] Haohao Shi, Zhen Zhan, Zhikai Qi, Kaixiang Huang, Edo van Veen, Jose Ángel Silva-Guillén, Runxiao Zhang,
Pengju Li, Kun Xie, Hengxing Ji, et al. Large-area, periodic, and tunable intrinsic pseudo-magnetic ﬁelds in
low-angle twisted bilayer graphene. Nat. Commun., 11(371):371, 2020.

[32] Yi-Wen Liu, Zhen Zhan, Zewen Wu, Chao Yan, Shengjun Yuan, and Lin He. Realizing one-dimensional metallic
states in graphene via periodically coupled zeroth pseudo-landau levels. arXiv preprint arXiv:2112.11624, 2021.

[33] Shengjun Yuan, AN Rudenko, and MI Katsnelson. Transport and optical properties of single-and bilayer black

phosphorus with defects. Phys. Rev. B, 91(11):115436, 2015.

[34] Shengjun Yuan, Edo van Veen, Mikhail I Katsnelson, and Rafael Roldán. Quantum hall effect and semiconductor-

to-semimetal transition in biased black phosphorus. Phys. Rev. B, 93(24):245433, 2016.

[35] Shengjun Yuan, Malte Rösner, Alexander Schulz, Tim O Wehling, and Mikhail I Katsnelson. Electronic structures
and optical properties of partially and fully ﬂuorinated graphene. Phys. Rev. Lett., 114(4):047403, 2015.

[36] Shengjun Yuan, Hans De Raedt, and Mikhail I Katsnelson. Electronic transport in disordered bilayer and trilayer

graphene. Phys. Rev. B, 82(23):235409, 2010.

[37] Shengjun Yuan, Rafael Roldán, and Mikhail I Katsnelson. Landau level spectrum of aba-and abc-stacked trilayer

graphene. Phys. Rev. B, 84(12):125455, 2011.

[38] Shengjun Yuan, Rafael Roldán, Hans De Raedt, and Mikhail I Katsnelson. Optical conductivity of disordered

graphene beyond the dirac cone approximation. Phys. Rev. B, 84(19):195418, 2011.

[39] Shengjun Yuan, TO Wehling, AI Lichtenstein, and MI Katsnelson. Enhanced screening in chemically functional-

ized graphene. Phys. Rev. Lett., 109(15):156601, 2012.

[40] Edo Van Veen, Andrei Nemilentsau, Anshuman Kumar, Rafael Roldán, Mikhail I Katsnelson, Tony Low,
and Shengjun Yuan. Tuning two-dimensional hyperbolic plasmons in black phosphorus. Phys. Rev. Applied,
12(1):014011, 2019.

[41] Fengping Jin, Rafael Roldán, Mikhail I. Katsnelson, and Shengjun Yuan. Screening and plasmons in pure and

disordered single- and bilayer black phosphorus. Phys. Rev. B, 92:115440, Sep 2015.

[42] Edo van Veen, Shengjun Yuan, Mikhail I. Katsnelson, Marco Polini, and Andrea Tomadin. Quantum transport in

sierpinski carpets. Phys. Rev. B, 93:115428, Mar 2016.

[43] Edo van Veen, Andrea Tomadin, Marco Polini, Mikhail I. Katsnelson, and Shengjun Yuan. Optical conductivity

of a quantum electron gas in a sierpinski carpet. Phys. Rev. B, 96:235438, Dec 2017.

[44] Guodong Yu, Zewen Wu, Zhen Zhan, Mikhail I Katsnelson, and Shengjun Yuan. Dodecagonal bilayer graphene

quasicrystal and its approximants. npj Comput Mater, 5(1):1–10, 2019.

[45] Guodong Yu, Yunhua Wang, Mikhail I Katsnelson, Hai-Qing Lin, and Shengjun Yuan. Interlayer hybridization in

graphene quasicrystal and other bilayer graphene systems. Phys. Rev. B, 105(12):125403, 2022.

li

[46] Zhen Zhan, Yipei Zhang, Pengfei Lv, Hongxia Zhong, Guodong Yu, Francisco Guinea, José Ángel Silva-Guillén,
and Shengjun Yuan. Tunability of multiple ultraﬂat bands and effect of spin-orbit coupling in twisted bilayer
transition metal dichalcogenides. Phys. Rev. B, 102(24):241106, 2020.

[47] Jin Yu, Edo van Veen, Mikhail I Katsnelson, and Shengjun Yuan. Effective lattice hamiltonian for monolayer tin
disulﬁde: Tailoring electronic structure with electric and magnetic ﬁelds. Phys. Rev. B, 97(24):245410, 2018.
[48] Jin Yu, Mikhail I Katsnelson, and Shengjun Yuan. Tunable electronic and magneto-optical properties of mono-
layer arsenene: From g w 0 approximation to large-scale tight-binding propagation simulations. Phys. Rev. B,
98(11):115117, 2018.

[49] Guus Slotman, Alexander Rudenko, Edo van Veen, Mikhail I Katsnelson, Rafael Roldán, and Shengjun Yuan.

Plasmon spectrum of single-layer antimonene. Phys. Rev. B, 98(15):155411, 2018.

[50] Hongxia Zhong, Jin Yu, Xueheng Kuang, Kaixiang Huang, and Shengjun Yuan. Electronic and optical properties
of monolayer tin diselenide: The effect of doping, magnetic ﬁeld, and defects. Phys. Rev. B, 101(12):125430,
2020.

[51] Zhenwei Wang, Xueheng Kuang, Guodong Yu, Peiliang Zhao, Hongxia Zhong, and Shengjun Yuan. Electronic

properties and quasiparticle model of monolayer mosi2n4. Phys. Rev. B, 104:155110, Oct 2021.

[52] Xueheng Kuang, Zhen Zhan, and Shengjun Yuan. Collective excitations and ﬂat-band plasmon in twisted bilayer

graphene near the magic angle. Phys. Rev. B, 103(11):115431, 2021.

[53] Zewen Wu, Zhen Zhan, and Shengjun Yuan. Lattice relaxation, mirror symmetry and magnetic ﬁeld effects on

ultraﬂat bands in twisted trilayer graphene. Sci. China Phys. Mech. Astron., 64(6):1–7, 2021.

[54] Zewen Wu, Xueheng Kuang, Zhen Zhan, and Shengjun Yuan. Magic angle and plasmon mode engineering in

twisted trilayer graphene with pressure. Phys. Rev. B, 104(20):205104, 2021.

[55] Yipei Zhang, Zhen Zhan, Francisco Guinea, Jose Ángel Silva-Guillén, and Shengjun Yuan. Tuning band gamerican

physical society in twisted bilayer mo s 2. Phys. Rev. B, 102(23):235418, 2020.

[56] Min Long, Pierre A Pantaleón, Zhen Zhan, Francisco Guinea, Jose Ángel Silva-Guillén, and Shengjun Yuan.
An atomistic approach for the structural and electronic properties of twisted bilayer graphene-boron nitride
heterostructures. npj Comput Mater, 8(1):1–10, 2022.

[57] Guodong Yu, Zewen Wu, Zhen Zhan, Mikhail I Katsnelson, and Shengjun Yuan. Electronic structure of 30◦

twisted double bilayer graphene. Phys. Rev. B, 102(11):115123, 2020.

[58] Guodong Yu, Mikhail I Katsnelson, and Shengjun Yuan. Pressure and electric ﬁeld dependence of quasicrystalline

electronic states in 30◦ twisted bilayer graphene. Phys. Rev. B, 102(4):045113, 2020.

[59] Yunhua Wang, Guodong Yu, Malte Rösner, Mikhail I Katsnelson, Hai-Qing Lin, and Shengjun Yuan. Polarization-
dependent selection rules and optical spectrum atlas of twisted bilayer graphene quantum dots. Phys. Rev. X,
12(2):021055, 2022.

[60] Tom Westerhout, Edo van Veen, Mikhail I Katsnelson, and Shengjun Yuan. Plasmon conﬁnement in fractal

quantum systems. Phys. Rev. B, 97(20):205434, 2018.

[61] Askar A Iliasov, Mikhail I Katsnelson, and Shengjun Yuan. Power-law energy level spacing distributions in

fractals. Phys. Rev. B, 99(7):075402, 2019.

[62] Askar A Iliasov, Mikhail I Katsnelson, and Shengjun Yuan. Hall conductivity of a sierpi´nski carpet. Phys. Rev. B,

101(4):045413, 2020.

[63] Xiaotian Yang, Weiqing Zhou, Peiliang Zhao, and Shengjun Yuan. Conﬁned electrons in effective plane fractals.

Phys. Rev. B, 102(24):245425, 2020.

[64] E Cappelluti, Rafael Roldán, JA Silva-Guillén, Pablo Ordejón, and F Guinea. Tight-binding model and direct-

gap/indirect-gap transition in single-layer and multilayer mos 2. Phys. Rev. B, 88(7):075409, 2013.

[65] Serghey V Vonsovsky and Mikhail I Katsnelson. Quantum solid-state physics. Springer-Verlag Berlin, Heidelberg,

New York, 1989.

[66] Fengpin Jin, Dennis Willsch, Madita Willsch, Hannes Lagemann, Kristel Michielsen, and Hans De Raedt. Random

state technology. J. Phys. Soc. Jpn., 90(1):012001, 2021.

[67] Wahyu Setyawan and Stefano Curtarolo. High-throughput electronic band structure calculations: Challenges and

tools. Comp Mater Sci, 49(2):299–312, 2010.

[68] William H Press, H William, Saul A Teukolsky, A Saul, William T Vetterling, and Brian P Flannery. Numerical

recipes 3rd edition: The art of scientiﬁc computing. Cambridge university press, 2007.

lii

[69] SK Bose. Local density of states via the recursion and the equation-of-motion methods: A comparative study.

Philosophical Magazine B, 49(6):631–645, 1984.

[70] D Kosloff and R Kosloff. A fourier method solution for the time dependent schrödinger equation as a tool in

molecular dynamics. J. Comput. Phys., 52(1):35–53, 1983.

[71] Ryogo Kubo. Statistical-mechanical theory of irreversible processes. i. general theory and simple applications to

magnetic and conduction problems. J. Phys. Soc. Jpn., 12(6):570–586, 1957.

[72] A Bastin, C Lewiner, O Betbeder-Matibet, and P Nozieres. Quantum oscillations of the hall effect of a fermion

gas with random impurity scattering. J. Phys. Chem. Solids, 32(8):1811–1824, 1971.

[73] Aurélien Lherbier, Simon M.-M. Dubois, Xavier Declerck, Stephan Roche, Yann-Michel Niquet, and Jean-
Christophe Charlier. Two-dimensional graphene with structural defects: Elastic mean free path, minimum
conductivity, and anderson transition. Phys. Rev. Lett., 106:046803, Jan 2011.

[74] Gabriele Giuliani and Giovanni Vignale. Quantum theory of the electron liquid. Cambridge university press, 2005.
[75] Rui Yu, Xiao Liang Qi, Andrei Bernevig, Zhong Fang, and Xi Dai. Equivalent expression of (cid:122)2 topological
invariant for band insulators using the non-abelian berry connection. Phys. Rev. B, 84(7):075119, 2011.

[76] Liang Fu and Charles L Kane. Time reversal polarization and a Z2 adiabatic spin pump. Phys. Rev. B,

74(19):195312, 2006.

[77] A. N. Rudenko, M. I. Katsnelson, and R. Roldán. Electronic properties of single-layer antimony: Tight-binding
model, spin-orbit coupling, and the strength of effective coulomb interactions. Phys. Rev. B, 95:081407, Feb 2017.
[78] A. N. Rudenko, Shengjun Yuan, and M. I. Katsnelson. Toward a realistic description of multilayer black
phosphorus: From gw approximation to large-scale tight-binding simulations. Phys. Rev. B, 92:085419, Aug
2015.

[79] Shiang Fang, Rodrick Kuate Defo, Sharmila N. Shirodkar, Simon Lieu, Georgios A. Tritsaris, and Efthimios
Kaxiras. Ab initio tight-binding hamiltonian for transition metal dichalcogenides. Phys. Rev. B, 92(20):205108.
[80] Giovanni Pizzi, Valerio Vitale, Ryotaro Arita, Stefan Blügel, Frank Freimuth, Guillaume Géranton, Marco
Gibertini, Dominik Gresch, Charles Johnson, Takashi Koretsune, Julen Ibañez-Azpiroz, Hyungjun Lee, Jae-Mo
Lihm, Daniel Marchand, Antimo Marrazzo, Yuriy Mokrousov, Jamal I Mustafa, Yoshiro Nohara, Yusuke Nomura,
Lorenzo Paulatto, Samuel Poncé, Thomas Ponweiser, Junfeng Qiao, Florian Thöle, Stepan S Tsirkin, Małgorzata
Wierzbowska, Nicola Marzari, David Vanderbilt, Ivo Souza, Arash A Mostoﬁ, and Jonathan R Yates. Wannier90
as a community code: new features and applications. J. Phys.: Condens. Matter, 32(16):165902, jan 2020.
[81] J. M. B. Lopes dos Santos, N. M. R. Peres, and A. H. Castro Neto. Graphene bilayer with a twist: Electronic

structure. Phys. Rev. Lett., 99:256802, Dec 2007.

[82] G. Trambly de Laissardière, D. Mayou, and L. Magaud. Numerical studies of conﬁned states in rotated bilayers of

graphene. Phys. Rev. B, 86:125413, Sep 2012.

[83] Raﬁ Bistritzer and Allan H MacDonald. Moiré bands in twisted double-layer graphene. Proc. Natl. Acad. Sci.

Unit. States Am., 108(30):12233–12237, 2011.

[84] Fernando Gargiulo and Oleg V Yazyev. Structural and electronic transformation in low-angle twisted bilayer

graphene. 2D Materials, 5(1):015019, 2017.

[85] Steve Plimpton. Fast parallel algorithms for short-range molecular dynamics. J. Comput. Phys., 117(1):1–19,

1995.

[86] Jan H Los, Luca M Ghiringhelli, Evert Jan Meijer, and A Fasolino. Improved long-range reactive bond-order

potential for carbon. i. construction. Phys. Rev. B, 72(21):214102, 2005.

[87] Aleksey N Kolmogorov and Vincent H Crespi. Registry-dependent interlayer potential for graphitic systems.

Phys. Rev. B, 71(23):235415, 2005.

[88] Dong Su Lee, Christian Riedl, Thomas Beringer, AH Castro Neto, Klaus von Klitzing, Ulrich Starke, and Jurgen H

Smet. Quantum hall effect in twisted bilayer graphene. Phys. Rev. Lett., 107(21):216602, 2011.

[89] Pilkyung Moon and Mikito Koshino. Optical absorption in twisted bilayer graphene. Phys. Rev. B, 87(20):205404,

2013.

[90] Niels CH Hesp, Iacopo Torre, Daniel Rodan-Legrain, Pietro Novelli, Yuan Cao, Stephen Carr, Shiang Fang, Petr
Stepanov, David Barcons-Ruiz, Hanan Herzig Sheinfux, et al. Observation of interband collective excitations in
twisted bilayer graphene. Nat. Phys., 17(10):1162–1168, 2021.

[91] Francisco Guinea and Niels R Walet. Electrostatic effects, band distortions, and superconductivity in twisted

graphene bilayers. Proc. Natl. Acad. Sci. Unit. States Am., 115(52):13174–13179, 2018.

liii

[92] Zachary AH Goodwin, Valerio Vitale, Xia Liang, Arash A Mostoﬁ, and Johannes Lischner. Hartree theory
calculations of quasiparticle properties in twisted bilayer graphene. Electron. Struct., 2(3):034001, 2020.

liv

