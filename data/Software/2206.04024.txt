2
2
0
2

n
u
J

8

]
E
S
.
s
c
[

1
v
4
2
0
4
0
.
6
0
2
2
:
v
i
X
r
a

1

Trace Diagnostics for Signal-based Temporal
Properties

Chaima Boufaied, Claudio Menghi, Member, IEEE, Domenico Bianculli, Member, IEEE,
and Lionel C. Briand, Fellow, IEEE

Abstract—Trace checking is a veriﬁcation technique widely used in Cyber-physical system (CPS) development, to verify whether
execution traces satisfy or violate properties expressing system requirements. Often these properties characterize complex signal
behaviors and are deﬁned using domain-speciﬁc languages, such as SB-TemPsy-DSL, a pattern-based speciﬁcation language for
signal-based temporal properties. Most of the trace-checking tools only yield a Boolean verdict. However, when a property is violated
by a trace, engineers usually inspect the trace to understand the cause of the violation; such manual diagnostic is time-consuming and
error-prone. Existing approaches that complement trace-checking tools with diagnostic capabilities either produce low-level
explanations that are hardly comprehensible by engineers or do not support complex signal-based temporal properties.
In this paper, we propose TD-SB-TemPsy , a trace-diagnostic approach for properties expressed using SB-TemPsy-DSL. Given a
property and a trace that violates the property, TD-SB-TemPsy determines the root cause of the property violation. TD-SB-TemPsy
relies on the concepts of violation cause, which characterizes one of the behaviors of the system that may lead to a property violation,
and diagnoses, which are associated with violation causes and provide additional information to help engineers understand the
violation cause. As part of TD-SB-TemPsy , we propose a language-agnostic methodology to deﬁne violation causes and diagnoses. In
our context, its application resulted in a catalog of 34 violation causes, each associated with one diagnosis, tailored to properties
expressed in SB-TemPsy-DSL.
We assessed the applicability of TD-SB-TemPsy using an industrial case study from the satellite domain. The results show that
TD-SB-TemPsy could ﬁnish within a timeout of 1 min for ≈ 83.66% of the trace-property combinations in our dataset, yielding a
diagnosis in ≈ 99.84% of these cases; these results suggest that our tool is applicable and efﬁcient in most cases.

Index Terms—Diagnostics, Trace checking, Run-time veriﬁcation, Temporal properties, Speciﬁcation patterns, Cyber-physical
systems, Signals

✦

1 INTRODUCTION

C YBER-PHYSICAL system (CPS) development requires

engineers to verify whether the system meets its re-
quirements. In industrial contexts, veriﬁcation is often per-
formed through trace-checking tools (e.g., [1], [2], [3], [4], [5],
[6]). Engineers collect traces, sequences of records repre-
senting the behavior of the system, and use trace-checking
tools to check whether the traces satisfy or violate prop-
erties expressing the system requirements. If properties are
violated, the system has faults that need to be identiﬁed and
corrected.

In the case of pattern-based trace-checking tools, proper-
ties are expressed using pattern-based languages. Pattern-
based languages contain domain-speciﬁc constructs to ex-
press complex requirements [7] that increase their usability
in industrial contexts [7], [8]. In this work, we consider
requirements expressed in SB-TemPsy-DSL [1], a pattern-

• C. Boufaied is with the school of EECS, University of Ottawa, Ottawa,

ON K1N 6N5, Canada (e-mail:chaima.boufaied@uottawa.ca).

• D. Bianculli is with the Interdisciplinary Centre for Security, Reliability,
and Trust (SnT) of the University of Luxembourg, Luxembourg (e-mail:
domenico.bianculli@uni.lu).

• C. Menghi is with McMaster University, Hamilton, Canada (e-mail:

•

cmenghi@mcmaster.ca).
L. Briand holds shared appointments with the Interdisciplinary Centre for
Security, Reliability, and Trust (SnT) of the University of Luxembourg,
Luxembourg and the school of EECS, University of Ottawa, Ottawa, ON
K1N 6N5, Canada (e-mail: lionel.briand@uni.lu).

based language that can express complex signal behaviors
based on a recent taxonomy [9]. This language enables
engineers to write properties describing important types of
requirements for industrial CPSs, through constructs that
express complex signal behaviors, such as spikes and oscil-
lations.

When a property is checked on a trace, trace-checking
tools usually provide a Boolean verdict: true if the trace
satisﬁes the property, false otherwise. When the property is
violated by a trace, engineers usually inspect the trace to
understand the cause of the violation, leading to the analysis
of a high number of records. For example, in our industrial
case study in the satellite domain, the average number of
records included in 361 traces is 438224. Inspecting a large
number of records, and checking the causes of property
violations, requires in general signiﬁcant time. Additionally,
this activity is error-prone and engineers may fail to identify
the actual cause of the property violation. Therefore, they
need automated tools that can explain the reasons leading
to the violation of the properties. These tools should provide
diagnostic information enabling engineers to understand
the cause of violations.

Two complementary strategies were proposed in the
literature to help engineers in these activities: (i) isolat-
ing slices of traces that explain the property violation; and
(ii) checking whether traces show common behaviors that lead
to the property violation. These two complementary strategies
are discussed in the following.

 
 
 
 
 
 
Approaches that isolate slices of the trace that explain the
property violation (e.g., [10], [11], [12], [13]) usually assume
that the properties are speciﬁed using a logical formula. To
explain the property violation, these approaches iteratively
analyze the sub-formulae of the logical formula and identify
minimal slices of the trace that explain the satisfaction or
violation of each sub-formula. Using this approach, the
size of the explanation increases with the number of sub-
formulae of the logical formula expressing the property. For
properties expressed using pattern-based languages, which
provide domain-speciﬁc constructs encoding complex log-
ical formulae, using such an approach is likely to produce
large explanations that are hardly comprehensible by engi-
neers. Besides, none of these approaches was implemented
and evaluated on realistic case studies.

Approaches that check for the presence of common
behaviors leading to the property violation (e.g., [14], [15], [16]),
which are assumed to correspond to common causes of such
violation. Each cause therefore encodes one of the behaviors,
observed in the trace, that may lead to a property violation
and help explain it. However, existing approaches do not
support complex signal-based temporal properties of CPS,
such as the one expressed using SB-TemPsy-DSL. Besides, it
is unclear how to extend these approaches to support signal-
based temporal properties, since such approaches do not
come with a precise methodology that describes how to add
new causes that support more complex properties.

In this work, we propose TD-SB-TemPsy, a trace-
diagnostic approach for signal-based temporal properties.
TD-SB-TemPsy takes as input a trace and a property ex-
pressed using SB-TemPsy-DSL and violated by the trace; it
provides as output an explanation that describes why the
property is violated on that trace.

To detect the source of the property violation, we deﬁne
the notions of violation cause and diagnosis. A violation cause
characterizes one of the behaviors of the system that may
lead to a property violation. For example, for a property
requiring a signal to show a spike with an amplitude and
a width lower than speciﬁc thresholds, the absence of any
spike behavior in an increasing signal is a violation cause.
Diagnoses are associated with violation causes and provide
additional information to help engineers understand such
causes. For example, a diagnosis for the previous violation
cause contains two records (timestamps and signal val-
ues) where the signal shows its minimum and maximum
values, while increasing. These values allow engineers to
understand the range of values taken by the signal while it
exhibits an increasing behavior.

We propose a novel methodology to deﬁne violation causes
and diagnoses (Section 5). Our methodology provides for-
mal guarantees of the soundness of the proposed violation
causes: if a violation cause holds on a trace, the correspond-
ing property is violated. Though we applied our methodol-
ogy to deﬁne violation causes for properties expressed using
SB-TemPsy-DSL, our methodology is language-agnostic and
can therefore be applied to other pattern-based speciﬁcation
languages such as TemPsy [17] and FRETISH [18].

We present a catalog of 34 violation causes, each associ-
ated with one diagnosis, for signal-based temporal properties
expressed in SB-TemPsy-DSL (Section 6). These violation
causes are not complete as they do not encode all the

2

possible reasons that may lead to a property violation,
but are the results of applying our methodology in the
context of our industrial case study. However, following
the same methodology, users can add new violation causes
depending on their speciﬁc needs or on the requirements of
particular domains.

We implemented TD-SB-TemPsy as a plugin for SB-
TemPsy-Check [1], a trace-checking tool for SB-TemPsy-
DSL. We assessed the applicability of TD-SB-TemPsy on a
large industrial dataset. TD-SB-TemPsy could ﬁnish within a
timeout of 1 min for ≈ 83.66% of the trace-property combi-
nations in our dataset, yielding a diagnosis in ≈ 99.84% of
these cases.

Signiﬁcance. Since diagnoses were provided in ≈ 99.84%
of the cases for which no timeout occurred, TD-SB-TemPsy
was widely applicable across trace-property combinations
in our dataset. Given the high expressiveness of SB-TemPsy-
DSL, the many violation causes and related diagnoses we
have deﬁned in TD-SB-TemPsy, and the run-time perfor-
mance of our tool, we expect signiﬁcant impact for this tech-
nology across many CPS domains. Moreover, the method-
ology for deﬁning violation causes and diagnoses can be
adopted by other researchers working on the problem of
trace diagnostics in the context of run-time veriﬁcation.

To summarize, the main contributions of this paper are:
• TD-SB-TemPsy, a trace-diagnostic approach for signal-
based temporal properties expressed in SB-TemPsy-
DSL, based on the concepts of violation cause and di-
agnosis;

• a language-agnostic methodology for deﬁning violation
causes and diagnoses, with formal guarantees of the
soundness of the proposed violation causes, and its
application to SB-TemPsy-DSL;

• a catalog of 34 violation causes, each associated with
one diagnosis, for signal-based temporal properties ex-
pressed in SB-TemPsy-DSL;

• a comprehensive evaluation of the applicability of TD-

SB-TemPsy on an industrial case study.
Paper structure. This paper is organized as follows. Sec-
tion 2 introduces our case study from the satellite domain
and identify concrete motivations for our work. Section 3
illustrates the syntax and semantics of SB-TemPsy-DSL.
Section 4 presents TD-SB-TemPsy, our pattern-based trace-
diagnostic approach. Section 5 describes our methodology
to deﬁne violation causes and diagnoses. Section 6 presents
the violation causes and diagnoses proposed in this work.
Section 8 evaluates our solution on an industrial case study.
Section 9 discusses related work. Section 10 concludes the
paper, providing directions for future work.

2 CASE STUDY AND MOTIVATIONS

Our case study is a satellite developed by our industrial
partner. This is a representative CPS as it contains many
complex software components that interact with actuators
and sensors of the satellite.

During the satellite development, and after its deploy-
ment, engineers collect traces that describe the behavior of
the satellite. A fragment of one of these traces is depicted
in Figure 1 and plotted in Figure 2. A trace is a sequence of
records that describe how the values of some signals change

β

2.0

153.5 55.0

0.5

80.0 203.5 20.0

0.5

Property φ ::= φ1 or φ2 | δ

3

52.5 125.0 125.5 25.0

75.5

35.0 200.5

Clause

δ ::= δ1 and δ2 | α

ρ

1.0
timestamp 0.0

0.2

0.9

1.8

3.0

4.9

5.7

6.0

Record r3

Figure 1. A fragment of a trace from our case study.

β

ρ

250

200

150

100

50

0

)
°
(

e
u
l
a
V

0

1

2

3

4

5

6

Atom

Scope

α ::= not sc | sc

sc ::= globally p | before t p | after t p | at t p |

before p1 p | after p1 p |
between t1 and t2 p | between p1 and p2 p

Pattern

p ::= assert c | s becomes ∼ v |

if p1 then [within ⊲⊳ t] p2 |
exists spike in s

[with [width ∼1 v1] |[amplitude ∼2 v2]] |

exist oscillation in s

[with [p2pAmp ∼1 v1][period ∼2 v2]] |

s rises [monotonically] reaching v |
s falls [monotonically] reaching v |
s overshoots [monotonically] v1 by v2 |
s undershoots [monotonically] v1 by v2

⊲⊳ ::= exactly | at most | at least

Condition c ::= c1 and c2 | c1 or c2 | s ∼ v

t, t1, t2 ∈ R; v, v1, v2 ∈ R; ∼∈ {<, >, =, <>, <=, >=};
s is a signal or a mathematical expression over the signals.

Time (s)

Figure 3. SB-TemPsy-DSL syntax.

Figure 2. Graphical representation of the trace in Figure 1.

over time. For example, the fragment of the trace in Figure 1
contains eight records. Each record contains a timestamp,
identifying the time at which the record was collected, and
the values assumed by some variables, each recording the
values of one of the monitored signals at that time. In
the example, the variables β and ρ record respectively the
signals representing the beta angle [19] and the pointing
error [20] of the satellite. For example, for record r3 the
timestamp is 0.9, and the values of the variables β and ρ
are respectively 55.0° and 125.0°. The recording interval
of a trace is the difference between the maximum and the
minimum timestamps. For example, the recording interval
of the trace in Figure 1 is 6 s.

After the traces are collected, engineers analyze whether
the behaviors recorded in the traces satisfy the CPS require-
ments. An example of a requirement (inspired by the ones
from the case study) is the following:

R1: “Within the trace, the beta angle shall contain at least one
spike with an amplitude lower than 90° and a width less than
0.5 s”.

The beta angle is the angle between the orbital plane of the
satellite and the vector of the Sun (i.e., the direction from
which the Sun is shining). After deployment, the satellite
aligns its orbital plane. Therefore, β shall contain a spike
with an amplitude lower than 90°. The trace shown in
Figure 1 violates the requirement R1. As we will discuss
in the next section, automated trace-checking tools, such as
SB-TemPsy-Check [1] (see section 3), can verify whether a
trace satisﬁes or violates a requirement. However, they do
not provide any additional information to help engineers
understand the cause of the violation. This means that en-
gineers have to manually inspect the values of the variables
recorded in the trace records and check why these values
led to the violation of the requirement. In our example,
looking at the plot in Figure 2, one can see that the two

spikes (i.e., spike1 and spike2 deﬁned over the time intervals
[0, 1.8] and [1.8, 6.0]) of signal β have an amplitude value
(A1 = 153.5° and A2 = 203.5°) greater than 90° and show
a width (w1 = 1.8 s and w2 = 4.2 s) greater than 0.5 s. Our
pattern-based diagnostic approach (see section 4) aims to
automatically detect the causes of requirement violation.

3 BACKGROUND: SB-TEMPSY-DSL

SB-TemPsy-DSL [1] is a domain-speciﬁc language for ex-
pressing requirements that concern signal-based temporal
properties. The syntax of SB-TemPsy-DSL is shown in Fig-
ure 3; optional items are enclosed in square brackets; the
symbol ‘|’ separates alternatives.1 A property is a disjunction
of clauses. A clause is a conjunction of atoms. An atom is
deﬁned in terms of a scope (non-terminal sc) or the negation
operator (not) applied to constructs of type scope (sc).
A scope operator constrains a pattern (non-terminal p) to
hold within a given time interval. There are two types of
scope operators: absolute scopes and event scopes. Absolute
scopes are delimited by absolute time instants (e.g., before
t p). Event scopes are delimited by other patterns (e.g.,
before p1 p). A pattern (e.g., exists spike in s [...])
speciﬁes a constraint on the behavior of one or more signals.
A condition, which is used within the assert c pattern, is a
comparison (s ∼ v) between the value of a signal s and the
value v, or a combination of two conditions with the and
and or logical operators.

The syntax of SB-TemPsy-DSL enables engineers to de-
ﬁne the property φ1 expressing requirement R1 (see Sec-
tion 2) as: φ1 ≡ globally exists spike in β with
width <0.5 amplitude < 90. Note that this property is
made by a single atom (represented by the globally scope
construct).

1. The grammar of SB-TemPsy-DSL considered in this paper is
slightly different from the original one [1]. Any SB-TemPsy-DSL prop-
erty can be rewritten following this grammar by using standard rewrit-
ing rules [21].

λ |= φ1 or φ2 iff (λ |= φ1) ∨ (λ |= φ2);

λ |= δ1 and δ2 iff (λ |= δ1) ∧ (λ |= δ2) ;

λ |= not sc iff (λ 6|= sc)

4

λ |= before t p iff ti < t ≤ te ∧ λ, [ti, t] |= p ;
λ |= globally p iff λ, [ti, te] |= p ;
λ |= before p1 p iff ∀t1, t2, ((ti < t1 < t2 ≤ te ∧ λ, [t1, t2] |= p1) ⇒ ∃t3, t4, (ti ≤ t3 < t4 < t1 ∧ λ, [t3, t4] |= p))
λ |= after p1 p iff ∀t1, t2, ((ti ≤ t1 < t2 < te ∧ λ, [t1, t2] |= p1) ⇒ ∃t3, t4, (t2 < t3 < t4 ≤ te ∧ λ, [t3, t4] |= p))
λ |= between p1 and p2 p iff ∀t1, t2, t3, t4, ((ti ≤ t1 < t2 < t3 < t4 ≤ te ∧ λ, [t1, t2] |= p1 ∧ λ, [t3, t4] |= p2) ⇒ λ, [t2, t3] |= p)

λ |= at t p iff ti ≤ t ≤ te ∧ λ, [t, t] |= p ;

λ |= between n and m p iff ti ≤ n < m ≤ te ∧ λ, [n, m] |= p
λ |= after t p iff ti ≤ t < te ∧ λ, [t, te] |= p

λ, [tl, tu] |= assert c iff ∀t ∈ [tl, tu], (λ, t |= c). For every time instant t within [tl, tu], condition c holds.
λ, [tl, tu] |= s becomes ∼ v iff ∃t ∈ (tl, tu], (s(t) ∼ v ∧ ∀t1 ∈ [tl, t), (s(t1) 6∼ v)). Formula s(t) ∼ v is true for some t, and for any time instant t1
before t, s(t) ∼ v is false.
λ, [tl, tu] |= exists spike in s [with [width ∼1 v1]β[amplitude ∼2 v2]γ ]α iff ∃t1, t2, t3, t4, t5 ∈ [tl, tu], (t1 < t2 < t2 < t3 < t4 < t5 ∧
uni_m_max (s, t2, [t1, t3])∧ uni_sm_min(s, t3, [t2, t4])∧ uni_m_max (s, t4, [t3, t5])[[∧(t3 − t1) ∼1 v1]β[∧ max((s(t2)− s(t3)), (s(t4)− s(t3))) ∼2
∗
v2]γ]α). Signal s has a strict maximum within two (non strict) minima. The values v1 and v2 constrain the width and the amplitude of the spike.
λ, [tl, tu] |= exist oscillation in s [with [period ∼1 v1]ζ[p2pAmp ∼2 v2]ǫ]δ iff ∃t1, t2, t3, t4, t5 ∈ [tl, tu], (t1 < t2 < t2 < t3 < t4 <
t5 ∧ uni_sm_max (s, t2, [t1, t3]) ∧ uni_sm_min(s, t3, [t2, t4]) ∧ uni_sm_max (s, t4, [t3, t5])[[∧(t4 − t2) ∼1 v1]ζ[∧(s(t2) − s(t3)) ∼2 v2 ∧ (s(t4) −
s(t3)) ∼2 v2]ǫ]δ). Signal s shows a strict maximum within two strict minima. The values v1 and v2 constrain the period and the amplitude of the
oscillation.
λ, [tl, tu] |= s rises [monotonically]α reaching v iff ∃t ∈ (tl, tu], (s(t) ≥ v ∧ ∀t1 ∈ [tl, t), (s(t1) < v)[∧ monot (s, tl, t)]α). There exists a
time instant t where s(t) ≥ v, and for any time instant t1 before t, s(t1) < v. The character α labels the formula indicating that the signal shall
rise monotonically.
λ, [tl, tu] |= s overshoots [monotonically]α v1 by v2 iff ∃t ∈ (tl, tu], (s(t) ≥ v1 ∧ ∀t1 ∈ [t, tu], (s(t1) ≤ v1 + v2) ∧ ∀t2 ∈ [tl, t)(s(t2) <
v1)[∧ monot (s, tl, t)]α). Signal s is initially lower than v1. It then exceeds v1 at time instant t by remaining below v1 + v2. The character α labels
the formula indicating that the signal shall overshoot monotonically.
λ, [tl, tu] |= if p1 then [within ⊲⊳ d]α p2 iff ∀t1, t2 ∈ [tl, tu), ((t1 < t2 ∧ λ, [t1, t2] |= p1) ⇒ ∃t3, t4 ∈ [t2, tu], (t3 < t4 ∧ λ, [t3, t4] |=
p2[∧(t3 − t2)J⊲⊳Kd]α)) where J⊲⊳K is such that JexactlyK ≡ ‘=’, Jat mostK ≡ ‘<=’, Jat leastK ≡ ‘>=’. If pattern p1 holds in an interval [t1, t2],
then pattern p2 holds in a subsequent interval [t3, t4].

∗

λ, t |= c1 and c2 iff (λ, t |= c1) ∧ (λ, t |= c2) ;

λ, t |= c1 or c2 iff (λ, t |= c1) ∨ (λ, t |= c2) ;

λ, t |= s ∼ v iff s(t) ∼ v

t, t1, t2 ∈ R; v, v1, v2 ∈ R; ∼∈ {<, >, =, 6=, ≤, ≥}; s is a signal in S or a mathematical expression over the signals in S.
monot (s, t1, t2) ::= ∀t3 ∈ [t1, t2), ∀t4 ∈ (t3, 2], (s(t3) < s(t4)).
uni_m_max (s, t, [ta, tb]) ::= s(t) = x and ∀t1 ∈ [ta, tb], s(t1) < x and ∀t1, t2 ∈ [ta, t], if t1 < t2 then s(t1) ≤ s(t2) and ∀t1, t2 ∈ [ta, t], if t1 <
t2 then s(t1) ≥ s(t2)
uni_sm_max (s, t, [ta, tb]) ::= s(t) = x and ∀t1 ∈ [ta, tb], s(t1) < x and ∀t1, t2 ∈ [ta, t], if t1 < t2 then s(t1) < s(t2) and ∀t1, t2 ∈ [ta, t], if t1 <
t2 then s(t1) > s(t2)
∗

We present the case where a (strict) minimum is followed by a strict maximum followed by a (strict) minimum. The dual case can be derived
from our formulation. Similarly, we present the predicates that characterize a local (strict) maximum (uni_m_max and uni_sm_max ). Their dual
case, i.e., the predicates that characterize a local (strict) minimum (uni_m_min and uni_sm_min) can be derived from the above formulations.

Figure 4. SB-TemPsy-DSL formal semantics (based on [1])

The semantics of each construct η of SB-TemPsy-DSL is
shown in Figure 4, which is divided into four parts. The
ﬁrst part contains the semantics of properties, clauses, and
atoms. The other three parts address the semantics of scopes,
patterns, and conditions. The semantics of a construct η is
the formula ζ(η) (in ﬁrst-order logic) written on the right
side of the iff
(if and only if) sign. For properties, the
semantics speciﬁes the conditions that make a property φ
satisﬁed by the trace λ, i.e., λ |= φ. For example, the
semantics of φ1 or φ2 requires at least one of them to
hold on trace λ. For scopes, the semantics speciﬁes the
conditions that make a scope sc satisﬁed on the trace λ,
i.e., λ |= sc. For example, the semantics of the globally
scope indicates that a pattern p scoped by the globally
operator holds on the trace λ if the pattern p holds on the
interval of the trace λ delimited by the timestamps ti and
te. The timestamps ti and te indicate the initial and the last
timestamps of the trace. For patterns, the semantics speciﬁes
the conditions that make a pattern p satisﬁed on the interval
of the trace λ delimited by the timestamps tl and tu deﬁned
by a given scope, i.e., λ, [tl, tu] |= p. Figure 4 also includes
an informal description of the pattern semantics, after the
formal deﬁnition. For example, the semantics of pattern
“exists spike in s with width ∼1 v1 amplitude ∼2
v2” speciﬁes that signal s shows a spike behavior with
a width satisfying the constraint “∼1 v1” and an ampli-

tude satisfying the constraint “∼2 v2”. A spike informally
denotes a temporary (large) increase (or decrease) of the
value of a signal. It occurs when the signal has a strict
maximum surrounded by two minima (or a strict minimum
surrounded by two maxima). This behavior can be subjected
to additional constraints on the width (i.e., the difference
between the time instants at which the two minima — or the
two maxima occur) and on the amplitude (i.e., the difference
between the maximum and minimum values of the signal).
Finally, the semantics of conditions speciﬁes how to satisfy
a condition c for a trace λ at time instant t, i.e., λ, t |= c. For
example, the semantics of c1 and c2 requires both c1 and c2
to hold on the trace λ at timestamp t.

SB-TemPsy-DSL is supported by SB-TemPsy-Check [1],
an automated, model-driven trace-checking tool that veri-
ﬁes whether a property is satisﬁed or violated by a given
trace. SB-TemPsy-Check yields a Boolean verdict: true if the
property is satisﬁed, false otherwise. For example, when
property φ1 is checked on the trace shown in Figure 1,
SB-TemPsy-Check returns the false verdict. However, SB-
TemPsy-Check does not provide any additional information
to help engineers understand the cause of the violation. Our
trace diagnostic approach aims to solve this problem.

Algorithm 1 TD-SB-TemPsy
Inputs. λ: trace

φ: violated property

Outputs. diags: set of diagnoses instances

Algorithm 2 TD-SB-TemPsy - Atoms
Inputs. λ: trace

α: violated atom

Outputs. diag: diagnosis for α (if available)

5

diags={};
PropertyAtoms=GETATOMS(φ);
for α in PropertyAtoms do

1: function TD-SB-TEMPSY(λ, φ)
2:
3:
4:
5:
6:
7:

diags.add(TD-ATOM(λ,α))

return diags;

if CHECKATOMONTRACE(λ,α)==false then

vcs=GETVIOLATIONCAUSES(α);
for i=0; i<vcs.size(); i++ do

1: function TD-ATOM(λ,α)
2:
3:
4:
5:
6:

return null;

return GETDIAGNOSIS(λ,vcs[i]);

if CHECKVIOLATIONCAUSE(λ,vcs[i])==true then

4 PATTERN-BASED TRACE DIAGNOSTIC

This section describes TD-SB-TemPsy, our trace-diagnostic
approach. At the core of the approach, there is the com-
putation of violation causes and diagnoses. A violation cause
characterizes one of the possible behaviors of the system
that may lead to the property violation. An example of
violation cause for property φ1 and the trace in Figure 2
is that all the spikes have an amplitude greater than or
equal to 90°. A diagnosis provides additional information
to explain the violation cause. For example, a diagnosis for
the previous violation cause is the amplitude A1 = 150° and
the time interval [0 s, 1.8 s] of spike spike1, that is the closest
(among those contained in the trace) to satisfy the amplitude
constraint of property φ1.

Algorithm 1 shows the main steps of TD-SB-TemPsy.
The inputs of TD-SB-TemPsy are a trace λ and a property
φ violated by λ. Trace λ is a set of consecutive records
that contain the values of the variables at different time
instants, such as the trace depicted in Figure 1. Property φ is
a speciﬁcation of a requirement in SB-TemPsy-DSL deﬁned
according to the grammar presented in Figure 3.

The algorithm relies on the following intuition. Based on
the SB-TemPsy-DSL grammar shown in Figure 3, property φ
is speciﬁed as a disjunction of clauses. Since the property is
violated, the disjunction evaluates to false; this means that
all its clauses must be violated. To be violated, each clause
must contain one or more violated atoms (since a clause is
a conjunction of atoms). Therefore, to explain the violation
of property φ, we return the diagnoses (if available2) for all
the violated atoms of φ. Each diagnosis explains why the
corresponding atom is violated.

Algorithm 1 works as follows. After initializing a set
of diagnoses instances to be returned (line 2), it extracts
all the atoms from property φ by analyzing its abstract
syntax tree (line 3). Then, it iteratively analyzes each atom
(line 4). It ﬁrst checks, by calling a trace checker for SB-
TemPsy-DSL like SB-TemPsy-Check [1], if the atom is vio-
lated by the trace (line 5). If it is the case, the algorithm
computes (through algorithm TD-ATOM described below)
the diagnosis (if available) that explains why the atom is
violated (line 6). Finally, the algorithm returns the set of
the computed diagnoses instances (line 7). TD-SB-TemPsy
returns a diagnosis if the set of the computed diagnoses
instances is not empty.

Computing the diagnosis. Algorithm 2 describes how to
compute the diagnosis for an atom of an SB-TemPsy-DSL

property. The inputs of TD-ATOM are a trace λ and an atom
α violated by λ.

To compute the diagnosis for atom α, Algorithm 2 ex-
tracts the violation causes associated with the atom (line 2)
by calling the auxiliary function GETVIOLATIONCAUSES,
which relies on a predeﬁned mapping associating each type
of atom of SB-TemPsy-DSL with one or more violation
causes (see section 6). A violation cause encodes a behavior
that may lead to the violation of an atom. For example,
a violation cause for the atom of property φ1 deﬁned in
Section 2 is the following:

c_spike1: all the spikes in signal β violate the amplitude
constraint.

If the behavior captured by this violation cause holds, the
atom of formula φ1 is violated. The violation of an atom can
be caused by a violation of the scope used in the atom (or
its negation), a violation of the pattern constrained by the
scope, or both. Function GETVIOLATIONCAUSES returns a
list of violation causes, sorted such that violation causes of
the scope precede the violation causes of the pattern3. Then,
the algorithm loops through this list of violation causes
(line 3). The loop body includes a check that determines
whether the violation cause holds on the trace (line 4);
this is achieved through the call of the auxiliary func-
tion CHECKVIOLATIONCAUSE. If the violation cause holds,
the algorithm stops, returning the corresponding diagnosis
(line 5) using the auxiliary function GETDIAGNOSIS, which
relies on a predeﬁned mapping of diagnoses for each type
of violation cause (see section 6). A diagnosis is relevant
information that enables engineers to understand why a
violation cause holds on a trace. For example, the diagnosis
for the violation cause c_spike1 is the following

d_spike1: the amplitude a and the time interval [t1, t2] of the
spike that is the closest to satisfy the amplitude constraint.

The amplitude value of the spike that is the closest to satisfy
the amplitude constraint enables engineers to determine
how close is the atom to be satisﬁed. The time interval
[t1, t2] enables engineers to isolate the portion of the trace
containing that spike and to inspect the values assumed by
the variables within the records included in this portion of
the trace. The amplitude A1 = 150° and the time interval
[0, 1.8] of spike1 in Figure 2 is an instance of the d_spike1
diagnosis for our case study. Diagnoses like d_spike1 help
engineers understand why an atom is violated by a trace. If
all the violation causes are checked and none of them led

2. As we will discuss later on, it is possible for a violated atom not to

have any diagnosis.

3. The priority of the different violation causes is application-speciﬁc.
Our current implementation is based on the feedback received by the
engineers of our industrial partners

to the computation of diagnoses, a null value is returned
(line 6).

In the following, we present our methodology to deﬁne

violation causes and diagnoses.

5 METHODOLOGY
CAUSES AND DIAGNOSES

FOR DEFINING VIOLATION

This section describes our methodology to deﬁne violation
causes and diagnoses by using SB-TemPsy-DSL as an ex-
ample. Our methodology considers each construct η used to
deﬁne an atom α of SB-TemPsy-DSL and follows three steps:
behavior analysis, deﬁnition of violation causes, and deﬁnition of
diagnoses.

Behavior Analysis.

It identiﬁes traces capturing relevant behaviors that violate
the semantics of construct η as follows.

1) It considers an instance of construct η obtained by
selecting some values for its parameters. This instance
is a concrete example used to identifying the relevant
behaviors that violate η. For example, for the spike
construct of SB-TemPsy-DSL (see Figure 3), we consid-
ered the instance “exists spike in β with width
< 0.5 amplitude < 90 ”, which sets the parameters s,
∼1, v1, ∼2, and v2 to the values β, “<”, 0.5, “<”, and 90
respectively.

2) It considers the logical formula ζ(η) describing the se-
mantics of the construct η. For example, for the spike
construct the logical formula describing its semantics
is reported in Figure 4 (on the right side of the iff
operator).

3) It identiﬁes traces capturing relevant behaviors that
violate the instance of construct η (i.e., that make for-
mula ζ(η) evaluate to false).
For example, Figure 5 shows a trace with four signals
(β1, β2, β3, and β4) that violate the instance we con-
sidered for the spike construct; for instance, signal β4
does not contain a strict maximum.

β1

β2

β3

β4

250

200

150

100

50

e
u
l
a
V

0

0

1

2

3
Timestamp

4

5

6

Figure 5. A trace with signals violating the expression “exists spike
in β with width < 0.5 amplitude < 90”.

Deﬁnition of Violation Causes.

It characterizes each of the traces identiﬁed by the behavior
analysis step through a violation cause. Each violation cause

6

vc is deﬁned by writing a logical formula ζ(vc) that speciﬁes
its semantics; the formula ζ(vc) is true when trace λ satisﬁes
violation cause vc.

For example, the shape of signal β3 can be deﬁned, with
respect to a trace λ delimited by timestamps ti and te,
through the logical formula:

c_spike4 ≡ ∀t1 ∈ [tl, tu), (∀t2 ∈ (t1, tu], (s(t1) ≥ s(t2))).

This formula characterizes the behavior for which a signal
s decreases. More precisely, c_spike4 holds on a trace λ
if, for any timestamp t1 within tl and tu, the value s(t1) of
signal s at timestamp t1 is greater than or equal to the value
s(t2) of signal s for any timestamp t2 that follows t1.

Violation causes for SB-TemPsy-DSL are illustrated in
section 6 (and summarized in Figure 6). The formula ζ(vc)
characterizing the semantics of each violation cause is re-
ported on the right side of the iff operator.

Since violation causes should encode root causes leading
to property violations, a violation cause vc for a construct η
should satisfy the following relation:

if ζ(vc) = true, then ζ(η) = false

Intuitively, if violation cause vc holds on trace λ, i.e., for-
mula ζ(vc) is true, the trace λ should violate construct η,
i.e., formula ζ(η) should be false. To check the satisfaction
of this relation, we automatically veriﬁed that the formula

Ψ ≡ ζ(vc) ⇒ ¬ζ(η)

holds. Formula Ψ holds if, whenever the violation cause
holds (ζ(vc) is true), the construct η does not hold (ζ(η)
is false). To check if formula Ψ holds, we veriﬁed whether
the formula ¬Ψ is unsatisﬁable. If the formula ¬Ψ is unsat-
isﬁable, Ψ always holds. We used Microsoft Z3 [22] — an
industry-strength tool — to check if ¬Ψ is unsatisﬁable. For
example, Z3 conﬁrmed that the formula ¬Ψ obtained by
considering the c_spike4 violation cause and the spike
construct is unsatisﬁable. Therefore, whenever violation
cause c_spike4 holds, the spike construct is violated.

Deﬁnition of diagnoses.

It deﬁnes a diagnosis for each of the violation causes. To
deﬁne each diagnosis, we (i) analyzed the semantics of the
corresponding violation cause, and (ii) identiﬁed minimum
relevant information that enables engineers to understand
why a violation cause holds on a trace.

For

example,

the diagnosis

for violation cause
c_spike4, denoted by d_spike4, includes the lowest and
the highest values of signal s within the trace. These val-
ues allow engineers to understand the range of values of
signal s while it exhibits a decreasing behavior. For exam-
ple, for signal β3 in Figure 5, the diagnosis for violation
cause c_spike4 is hh0, 200i, h6, 55ii showing that signal β3
reaches its maximum value (200) at timestamp 0 and its
minimum value (55) at timestamp 6. In this particular case,
when the signal does not show any spike, this is the only
information required for the engineers to understand why
this particular violation was caused.

The diagnoses associated with the violation causes
shown in Figure 6 are illustrated in section 6 (and summa-
rized in Figures 7–8).

Properties of the methodology.

Our methodology provides formal guarantees of the sound-
ness of the proposed violation causes: if a violation cause
holds on a trace, the corresponding property is violated.

Though we applied our methodology to deﬁne viola-
tion causes for properties expressed using SB-TemPsy-DSL,
our methodology is language-agnostic. More speciﬁcally, this
claim is supported by the fact that, in the deﬁnition of
the methodology, we only refer to generic syntactic con-
structs of the speciﬁcation language and generic logical
formulae capturing their semantics (which we assume to
be available in formal syntax and semantics deﬁnitions), as
well as generic logical formulae of violation causes (which
have to be deﬁned from scratch). Examples of pattern-
based languages for which this methodology can be applied
(i.e., for which assumptions are satisﬁed) are TemPsy [17],
FRETISH [18] and, more in general, languages based on
speciﬁcation pattern catalogues (such as those for robotic
missions [7]).

6 VIOLATION CAUSES AND DIAGNOSES FOR SB-
TEMPSY-DSL

In this section, we describe the violation causes and the
corresponding diagnoses for each construct supported by
SB-TemPsy-DSL. We ﬁrst provide a high-level overview
through Figure 6 (for violation causes) and Figures 7–8 (for
diagnoses); the remaining subsections discuss in detail the
violation causes and diagnoses for each main construct of
SB-TemPsy-DSL.

Figure 6 presents the violation causes for the constructs
of SB-TemPsy-DSL that can be used in the deﬁnition of
an atom α. It is divided into three parts that respectively
contain the violation causes for the SB-TemPsy-DSL atoms,
scopes, and patterns. Each violation cause has a name that
identiﬁes the construct of SB-TemPsy-DSL the violation
cause refers to, and an incremental index that distinguishes
violation causes that refer to the same construct; for exam-
ple, c_becomes1 , c_becomes2 , and c_becomes3 are the
three violation causes that refer to the becomes construct
of SB-TemPsy-DSL. Each violation cause is parameterized
with the same parameters as the corresponding construct.
For example, the parameters of the c_becomes1 violation
cause (∼ and v) are the same as those of the becomes
construct in Figure 3. For conciseness, in Figure 6, we omit
the parameters of the violation causes.

The semantics of each violation cause is the (ﬁrst-order
logic) formula ζ(vc) on the right side of the iff operator;
it is followed by an informal description of the semantics
in English. The semantics of the violation causes speciﬁes
the conditions that make the violation causes satisﬁed by
trace λ. For example, the semantics of the violation cause
c_becomes1 speciﬁes that, for every timestamp t, the value
s(t) does not satisfy s(t) ∼ v. Note that the parameters of
the SB-TemPsy-DSL constructs associated with the violation
causes, e.g., the value of v, are used to deﬁne the semantics
of the corresponding violation cause.

Figures 7–8 present the diagnoses for the violation causes
in Figure 6. Figure 7 contains the diagnoses related to
the violation causes for SB-TemPsy-DSL atoms and scopes,

7

while Figure 8 contains the diagnoses related to violation
causes for patterns.

The name of the diagnosis is obtained by replacing the
string “c_” with “d_” from the name of the corresponding
violation cause. For example, diagnosis d_becomes1 refers
to violation cause c_becomes1 .

The formal deﬁnition of the diagnosis is reported on
the right side of the symbol “=”. For example, the deﬁ-
nition of the diagnosis d_becomes1 is the tuple contain-
ing the maximum and the minimum values (as well as
their timestamps) of signal4 s. Violation causes sharing
the same diagnosis are separated by the symbol “/”. For
example, d_a_at1/d_a_bef1/ d_a_aft1 is the diagnosis
associated with violation causes c_a_at1, c_a_bef1, and
c_a_aft1. The informal deﬁnition provides a high-level de-
scription of the diagnosis.

6.1 Patterns
6.1.1 assert: Event-based Data Assertion

Violation cause: This pattern is violated if there
exists at least one record in the trace that violates the
condition used in the assertion. Recall that a record is used
to represent a timestamp and a signal value observed in that
timestamp. Therefore, the corresponding violation cause
c_assert1 checks for the presence of a timestamp in which
the assertion condition c is violated.

For example, the trace shown in Figure 9 violates the
expression “assert β1 < 4” because signal β1 shows a
value equal to 5 at timestamp 4, satisfying the violation
cause c_assert1 on the interval [0, 7].

Diagnoses: The diagnosis d_assert1 associated
with violation cause c_assert1 includes the ﬁrst times-
tamp t at which one or more signals (s1, s2, . . . , sn) violate
the assertion condition c, as well as the values taken by
these signals at t. This diagnosis allows engineers to identify
the root cause of the violation of the assertion condition by
looking at the ﬁrst timestamp in which this violation was
observed.

For instance, in the case of the trace shown in Figure 9,
the diagnosis is the tuple containing timestamp 4 and the
value of β1(4) = 5 taken by signal β1.

6.1.2 becomes: State-based Data Assertion

Violation causes: This pattern can be violated in at
least three ways, as illustrated with different signal behav-
iors in Figure 10 using the expression “β becomes > 3”:

• c_becomes1 : The signal value violates the pattern con-
straint ∼ v throughout the time interval over which the
pattern is evaluated. For instance, signal β1 in the ﬁgure
is never greater than 3.

• c_becomes2 : The signal value satisﬁes the pattern
constraint ∼ v throughout the time interval over which
the pattern is evaluated. This violation cause is the dual
of the previous case. For instance, signal β2 in the ﬁgure
is always greater than value 3.

• c_becomes3 : The signal violates the semantics of the
pattern by satisfying the negation of the pattern con-
straint (i.e., λ, [tl, tu] |= s becomes 6∼ v holds).

4. To minimize cluttering, hereafter we omit to indicate that each

signal value is associated with a signal name.

8

λ |= c_not1 sc iff λ |= sc. The atom sc is satisﬁed.

λ |= c_a_at1 iff t < ti ∨ te < t. The value of t is not within the time interval [ti, te].
λ |= c_a_bef1 iff t ≤ ti ∨ te < t. The value of t is not within the time interval [ti, te].
λ |= c_a_aft1 iff t < ti ∨ te ≤ t. The value of t is not within the time interval [ti, te]
λ |= c_a_bet1 iff n < ti ∨ te < m ∨ m ≤ n. Either the value of n or m is not within [ti, te], or the value of n is not smaller than m.
λ |= c_e_bef1 iff ∃t1, t2, (ti < t1 < t2 ≤ te ∧ λ, [t1, t2] |= p1 ∧ ∀t3, t4, (ti ≤ t3 < t4 < t1 ⇒ λ, [t3, t4] 6|= p)). Pattern p1 holds within [t1, t2].
Pattern p is violated before p1.
λ |= c_e_aft1 iff ∃t1, t2, (ti ≤ t1 < t2 < te ∧ λ, [t1, t2] |= p1 ∧ ∀t3, t4, (t2 < t3 < t4 ≤ te ⇒ λ, [t3, t4] 6|= p)). Pattern p1 holds within [t1, t2].
Pattern p is violated after p1.
λ |= c_e_bet1 iff ∃t1, t2, t3, t4, (ti ≤ t1 < t2 < t3 < t4 ≤ te ∧ λ, [t1, t2] |= p1 ∧ λ, [t3, t4] |= p2 ∧ λ, [t2, t3] 6|= p). Pattern p1 holds within [t1, t2]
and pattern p2 holds within [t3, t4], but pattern p does not hold between p1 and p2.

.

.

∗

∗

λ, [tl, tu] |= c_assert1 iff ∃t ∈ [tl, tu], (λ, t 6|= c). There exists a timestamp t within [tl, tu] in which condition c is violated
λ, [tl, tu] |= c_becomes1 iff ∀t ∈ (tl, tu], (cid:0)s(t) 6∼ v) .The signal values violate the pattern constraint ∼ v throughout the time interval, delimited
by tl and tu, over which the pattern is evaluated.
λ, [tl, tu] |= c_becomes2 iff ∀t ∈ (tl, tu], (cid:0)∃t1 ∈ [tl, t), (s(t1) ∼ v)(cid:1). All the signal values observed within the time interval [tl, tu] satisfy the
pattern constraint ∼ v.
λ, [tl, tu] |= c_becomes3 iff ∃t ∈ (tl, tu), (∀t1 ∈ [tl, t), (s(t1) ∼ v) ∧ ∀t2 ∈ (t, tu], (s(t2) 6∼ v)). The signal satisﬁes the semantics of the pattern
instance in which the constraint ∼ v is negated (i.e., λ, [tl, tu] |= s becomes 6∼ v holds).
λ, [tl, tu] |= c_spike1 iff ∀t1, t2, t3, t4, t5 ∈ [tl, tu], ((t1 < t2 < t3 < t4 < t5 ∧ uni_m_min(s, t2, [t1, t3]) ∧ uni_sm_max (s, t3, [t2, t4]) ∧
uni_m_min(s, t4, [t3, t5])) ⇒ ¬(amp(s, t1, t2, t3) ∼2 v2)). All the spike instances violate the amplitude constraint
λ, [tl, tu] |= c_spike2 iff ∀t1, t2, t3, t4, t5 ∈ [tl, tu], ((t1 < t2 < t3 < t4 < t5 ∧ uni_m_min(s, t2, [t1, t3]) ∧ uni_sm_max (s, t3, [t2, t4]) ∧
uni_m_min(s, t4, [t3, t5])) ⇒ ¬(width(t2, t4) ∼1 v1)). All the spike instances violate the width constraint
λ, [tl, tu] |= c_spike3 iff ∀t ∈ [tl, tu], (s(t) = s(tl)). The signal s is constant.
λ, [tl, tu] |= c_spike4 iff ∀t1 ∈ [tl, tu), (∀t2 ∈ (t1, tu], (s(t1) ≥ s(t2))). The signal s decreases.
λ, [tl, tu] |= c_spike5 iff ∀t1 ∈ [tl, tu), (∀t2 ∈ (t1, tu], (s(t1) ≤ s(t2))). The signal s increases.
λ, [tl, tu] |= c_oscillation1 iff ∀t1, t2, t3, t4, t5 ∈ [tl, tu], ((t1 < t2 < t3 < t4 < t5 ∧ uni_sm_min(s, t2, [t1, t3]) ∧ uni_sm_max (s, t3, [t2, t4]) ∧
uni_sm_min(s, t4, [t3, t5])) ⇒ ¬(p2p(s, t2, t3) ∼2 v2) ∧ ¬(p2p(s, t3, t4) ∼2 v2)). All the oscillation instances violate the amplitude constraint.
λ, [tl, tu] |= c_oscillation2 iff ∀t1, t2, t3, t4, t5 ∈ [tl, tu], ((t1 < t2 < t3 < t4 < t5 ∧ uni_sm_min(s, t2, [t1, t3]) ∧ uni_sm_max (s, t3, [t2, t4]) ∧
uni_sm_min(s, t4, [t3, t5])) ⇒ ¬(width(t2, t4) ∼1 v1)). All the oscillation instances violate the period constraint.
λ, [tl, tu] |= c_oscillation3 iff ∃t1, t2, t3 ∈ [tl, tu], (t1 < t2 < t3 ∧ ext(s, t2, [t1, t3]) ∧ ∀t4, t5, t6 ∈ [tl, tu], ((t5 6= t2 ∧ t4 < t5 < t6) ⇒
¬ext(s, t5, [t4, t6]))). The signal s contains only one strict local extremum (minimum or maximum).
λ, [tl, tu] |= c_oscillation4 iff ∃t1, t2, t3 ∈ [tl, tu], (t1 < t2 < t3 ∧ ext(s, t2, [t1, t3]) ∧ ∃t4, t5, t6 ∈ [tl, tu], (t5 6= t2 ∧ t4 < t5 < t6 ∧
ext(s, t5, [t4, t6]) ∧ ∀t7, t8, t9 ∈ [tl, tu], (t2 6= t8 6= t5 ∧ t7 < t8 < t9 ∧ ¬ext(s, t8, [t7, t9])))). The signal s shows only two local extrema.
λ, [tl, tu] |= c_oscillation5 iff ∀t ∈ [tl, tu], (s(t) = s(tl)). The signal s is constant.
λ, [tl, tu] |= c_oscillation6 iff ∀t1 ∈ [tl, tu), (∀t2 ∈ (t1, tu], (s(t1) ≥ s(t2))). The signal s decreases.
λ, [tl, tu] |= c_oscillation7 iff ∀t1 ∈ [tl, tu), (∀t2 ∈ (t1, tu], (s(t1) ≤ s(t2)). The signal s increases.
λ, [tl, tu] |= c_rises1 iff ∀t ∈ [tl, tu], (s(t) < v). The signal value is always below v.
λ, [tl, tu] |= c_rises2 iff ∀t ∈ [tl, tu], (s(t) ≥ v). The signal value is always greater than or equal to v.
λ, [tl, tu] |= c_rises3 iff ∃t ∈ (tl, tu], (s(t) ≥ v ∧ ∀t1 ∈ [tl, t), (s(t1) < v) ∧ ¬(mon(s, tl, t)))). The signal rises at timestamp t, reaching value v.
However, it violates the monotonicity constraint deﬁned in the pattern.
λ, [tl, tu] |= c_rises4 iff ∃t ∈ (tl, tu), (∀t1 ∈ [tl, t), (s(t1) ≥ v) ∧ ∀t2 ∈ [t, tu], (s(t2) < v)). The value of the signal is initially above the threshold
value v. The signal then drops and remains below that value.
λ, [tl, tu] |= c_overshoots1 iff ∀t ∈ [tl, tu], (s(t) < v1). The signal s is always below v1.
λ, [tl, tu] |= c_overshoots2 iff ∃t ∈ [tl, tu], (s(t) > v1 + v2 ∧ ∀t1 ∈ (t, tu], (s(t1) > v1 + v2)). The signal s exceeds (and remains above) the
value v1 + v2.
λ, [tl, tu] |= c_overshoots3 iff ∃t ∈ (tl, tu], (s(t) ≥ v1 ∧ s(t) ≤ v1 + v2 ∧ ∀t2 ∈ [tl, t), (s(t2) ≤ v1) ∧ ∀t1 ∈ (t, tu], (s(t1) ≤ v1 + v2) ∧
¬(mon(s, tl, t)))). The signal overshoots value v1, without exceeding the maximum threshold set to v1+ v2, but it violates the monotonicity
constraint.
λ, [tl, tu] |= c_overshoots4 iff ∃t ∈ (tl, tu], (∀t1 ∈ [tl, t], (s(t1) ≥ v1 ∧ s(t1) ≤ v1 + v2) ∧ ∀t2 ∈ (t, tu], (s(t2) < v1))). The signal undershoots,
going below v1 after timestamp t, and remains below that value instead of overshooting.
λ, [tl, tu] |= c_if-then1 iff ∃t1, t2 ∈ [tl, tu), (λ, [t1, t2] |= p1 ∧ (∀t3, t4 ∈ [t2, tu], (λ, [t3, t4] 6|= p2))). Pattern p1 holds within the time interval
[t1, t2]. Pattern p2 never holds after the satisfaction of pattern p1, until the end of the time interval, right-bounded by value tu.
λ, [tl, tu] |= c_if-then2 iff ∃t1, t2 ∈ [tl, tu), (λ, [t1, t2] |= p1 ∧ ∀t3, t4 ∈ [t2, tu], (λ, [t3, t4] |= p2 ⇒ ¬((t3 − t2) J⊲⊳K d))) where J⊲⊳K is such
that JexactlyK ≡ ‘=’, Jat mostK ≡ ‘<=’, Jat leastK ≡ ‘>=’. Pattern p1 is satisﬁed within the time interval [t1, t2]. Any time interval [t3, t4]
satisfying pattern p2 violates the time distance constraint on the size of t3 − t2.
∗

We present the case where a (strict) minimum is followed by a strict maximum followed by a (strict) minimum. The dual case can be

derived from our formulation.
ext(s, t2, [t1, t3]) = (uni_sm_max (s, t2, [t1, t3]) ∨ uni_sm_min(s, t2, [t1, t3]));
amp(s, t1, t2, t3) = max (|s(t2) − s(t1)|, |s(t2) − s(t3)|); width(t1, t2) = (|t2 − t1|)

p2p(s, t1, t2) = |s(t1) − s(t2))|;

Figure 6. Violation causes for the constructs of SB-TemPsy-DSL

9

d_not_assert=ht, s1(t), s2(t), . . . , sn(t)i | (λ, t |= c). One timestamp and all the corresponding signal values where condition c is satisﬁed.
d_not_becomes=ht, s(t)i | t ∈ (tl, tu], (s(t) ∼ v ∧ ∀t1 ∈ [tl, t), (s(t1) 6∼ v)). The ﬁrst record that satisﬁes s(t) ∼ v, such that s(t1) 6∼ v for any
time t1 before t.
| ∃t2, t3, t4 ∈ [tl, tu], (tl < t1 < t2 < t3 < t4 < t5 ∧ uni_m_max (s, t2, [t1, t3]) ∧
d_not_spike = h(t1, s(t1)), (t5, s(t5))
uni_sm_min(s, t3, [t2, t4]) ∧ uni_m_max (s, t4, [t3, t5])[[∧(t3 − t1) ∼1 v1]β[∧ max((s(t2) − s(t3)), (s(t4) − s(t3))) ∼2 v2]γ ]α). The ﬁrst ht1, s(t1)i
and the last ht5, s(t5)i records that show an occurrence of a spike
d_not_oscillation = h(t1, s(t1)), (t5, s(t5)) | ∃t2, t3, t4 ∈ [tl, tu], (t1 < t2 < t2 < t3 < t4 < t5 ∧ uni_sm_max (s, t2, [t1, t3]) ∧
uni_sm_min(s, t3, [t2, t4]) ∧ uni_sm_max (s, t4, [t3, t5])[[∧(t4 − t2) ∼1 v1]ζ[∧(s(t2) − s(t3)) ∼2 v2 ∧ (s(t4) − s(t3)) ∼2 v2]ǫ]δ). The ﬁrst
∗
ht1, s(t1)i and the last ht5, s(t5)i records that show an occurrence of oscillations
d_not_rises = ht, s(t)i | t ∈ (tl, tu], (s(t) ≥ v ∧ ∀t1 ∈ [tl, t), (s(t1) < v)[∧mon(s, tl, t)]α). The ﬁrst record ht, s(t)i at which the signal becomes
greater than or equal to v, where the optional monotonicity constraint is satisﬁed, if deﬁned in the property.
d_not_overshoots = ht, s(t)i | t ∈ (tl, tu], (s(t) ≥ v1 ∧ ∀t1 ∈ [t, tu], (s(t1) ≤ v1 + v2) ∧ ∀t2 ∈ [tl, t), (s(t2) < v1)[∧mon(s, tl, t)]α). The ﬁrst
record at which signal s reaches value v1. The signal never goes above the maximum allowed amplitude of v1 + v2 and satisﬁes the monotonicity
constraint, if deﬁned in the property.
d_not_if-then = h[t1, t2], [t3, t4]i | (tl < t1 < t2 < t3 < t4 < tu ∧ λ, [t1, t2] |= p1 ∧ λ, [t3, t4] |= p2[∧(t3 − t2)J⊲⊳Kd]α). An interval [t1, t2]
where pattern p1 holds and a subsequent interval [t3, t4] where pattern p2 holds.

∗

.

.

d_a_at1/d_a_bef1/d_a_aft1 = h[ti, te], ti. The time interval [ti, te] and the absolute boundary t, that is not within that interval.
d_a_bet1 = h[ti, te], n, mi. Values n and m and the interval [ti, te].
d_e_bef1 = h[t1, t2]i | (tl < t1 < t2 ≤ tu ∧ λ, [t1, t2] |= p1 ∧ ∀t3, t4, (tl ≤ t3 < t4 < t1 ⇒ λ, [t3, t4] 6|= p)). The interval [t1, t2] where p1 holds,
and before which the property pattern p failed to hold.
d_e_aft1 = h[t1, t2]i | (tl ≤ t1 < t2 < tu ∧ λ, [t1, t2] |= p1 ∧ ∀t3, t4, (t2 < t3 < t4 ≤ tu ⇒ λ, [t3, t4] 6|= p)). The interval [t1, t2], where p1 holds
and after which the property pattern p failed to hold.
d_e_bet1 = h[t2, t3]i | (∃t1 ∈ [tl, tu), tl ≤ t1 < t2 < t3 < tu ∧ λ, [t1, t2] |= p1 ∧ ∃t4 ∈ (t3, tu], t3 < t4 ≤ tu ∧ λ, [t3, t4] |= p2 ∧ λ, [t2, t3] 6|= p).
The time interval [t2, t3], where t2 is the last timestamp in which pattern p1 held and t3 is the ﬁrst timestamp in which pattern p2 held.

Figure 7. Diagnoses associated with the violation causes of atoms and scopes in Figure 6.

For instance, signal β3 in the ﬁgure becomes less than
or equal to 3 (instead of becoming greater than 3). More
precisely, it goes below value 3 at timestamps 4, and
remains below that value until the end of the time
interval, delimited by timestamp 7.

Diagnoses: The diagnoses associated with the three

violation causes above are the following:

• d_becomes1 and d_becomes2 include two records
from the signal showing a minimum and a maximum
value. In this way, we show the range of values over
which the signal changes. In the example shown in
Figure 10, we report records h(7, 2.8), (4, 0.5)i for signal
β1 and records h(0.5, 5), (5, 3.3)i for signal β2.

• d_becomes3 includes the last-seen record at which the
signal value satisﬁes the constraint ∼ v, followed by
the next-seen record at which the signal value satis-
ﬁes 6∼ v. Through this diagnosis, we want to capture
the exact time interval, delimited by two consecutive
timestamps, within [tl, tu], in which the signal exhibits a
behavior compatible with the negation of the constraint
speciﬁed in the becomes expression. For instance, for
signal β3 in Figure 10, the diagnosis is h(3, 4.3), (4, 0.8)i.

6.1.3 Spike

Violation causes: This pattern can be violated in at
least ﬁve ways, as illustrated with different signal behaviors
in Figure 5 using the expression “exists spike in β
with amplitude < 90 width < 0.5”. These alternatives
are the following:

• c_spike1 : All spike instances in the signal violate the
amplitude constraint. For instance, signal β1 in the
ﬁgure shows two spike amplitude values greater than
90 (150 and 200, respectively).

• c_spike2 : All spike instances in the signal violate
the width constraint. For example, signal β1 shows
two spike width values greater than 0.5 (1.8 and 4.2,
respectively).

• c_spike3 : The signal is constant throughout the time
interval over which the pattern is evaluated. For exam-
ple, the constant signal β2 in the ﬁgure always takes the
value 100 within the time interval [0, 6].

• c_spike4 : The signal decreases,within the time in-
terval over which the pattern is evaluated, without
showing any spike behavior. For example, signal β3 in
the ﬁgure decreases within the time interval [0, 6], going
from value 190 to 30.

• c_spike5 : The signal increases within the time interval
over which the pattern is evaluated, without showing
any spike behavior. For instance, signal β4 increases
within the time interval [0, 6], going from value 30 to
190.

Diagnoses: The diagnoses associated with the ﬁve

violation causes above are the following:

• d_spike1 includes the time interval in which the spike
with the closest amplitude to satisfy the amplitude
constraint occurs, as well as the amplitude value of that
spike instance (see page 5 for a detailed explanation).
The intuition behind this diagnosis is that when a
spike property with an amplitude constraint is violated,
the engineers are interested in knowing the amplitude
value of the spike that is the closest to satisfy the
amplitude constraint, to assess how close the signal
behavior was to satisfy the property . For instance, for
signal β1 in Figure 5, the diagnosis is h[0, 1.8], 150i.
• d_spike2 is deﬁned in a similar way, but with respect
to the width constraint. It includes the time interval in
which the spike with the closest width to satisfy the
width constraint occurs, as well as the width value of
that spike instance. Similar to d_spike1 , the choice of
this speciﬁc width value enables engineers to determine
the closest value of a spike width to the satisfaction
of the width constraint deﬁned in the pattern. For
instance, for signal β1 in Figure 5, the diagnosis is
h[0, 1.8], 1.8i.

10

d_assert1 = ht, s1(t), s2(t), . . . , sn(t)i | (λ, t 6|= c) ∧ ∀t1 ∈ [tl, t), (λ, t1 |= c). The ﬁrst timestamp t and the values, taken in correspondence of
t, of the signals that lead to the violation of condition c.
d_becomes1/d_becomes2 = h(t1, s(t1)) , (t2, s(t2))i | ∀t ∈ [tl, tu], (s(t) ≤ s(t1) ∧ s(t) ≥ s(t2)). The maximum and the minimum values (and
the corresponding timestamps) of signal s.
d_becomes3 = h(t1, s(t1)) , (t2, s(t2))i | tl ≤ t1 < t2 ≤ tu ∧ s(t1) ∼ v ∧ s(t2) 6∼ v ∧ ¬∃t3 ∈ [tl, tu], (t1 < t3 < t2). The last time instant
t1 (and the corresponding value) at which the signal s satisﬁes the predicate s(t1) ∼ v, exactly followed by the next time instant t2 (and the
corresponding value) at which the signal value satisﬁes the predicate s(t2) 6∼ v.
d_spike1 = h[t1, t2], ai | (∃t3, t4, t5 ∈ [tl, tu], (spk (s, t3, t1, t4, t2, t5) ∧ ¬(amp(s, t1, t4, t2) ∼2 v2) ∧ a = amp(s, t1, t4, t2) ∧ ∀t6, t7, t8, t9, t10 ∈
[tl, tu], ((t7 6= t1 ∧ t8 6= t4 ∧ t9 6= t2 ∧ spk (s, t6, t7, t8, t9, t10)) ⇒ |a − v2| < ampv (s, t7, t8, t9, v2)))). The amplitude a and the interval [t1, t2] of
the spike that is the closest to satisfy the amplitude constraint.
d_spike2 = h[t1, t2], wi | (∃t3, t4, t5 ∈ [tl, tu], (spk (s, t3, t1, t4, t2, t5) ∧ ¬(width(t1, t2) ∼1 v1) ∧ w = width(t1, t2) ∧ ∀t6, t7, t8, t9, t10 ∈
[tl, tu], ((t7 6= t1 ∧ t8 6= t4 ∧ t9 6= t2 ∧ spk (s, t6, t7, t8, t9, t10)) ⇒ |w − v1| < widthv (t7, t9, v1)))). The width w and the time interval [t1, t2] of
the spike that is the closest to satisfy the width constraint.
d_spike3 = h[tl, tu], s(tl)i. The ﬁrst and the last timestamps (tl and tu) delimiting the interval throughout which signal s is constant, and the
signal value.
d_spike4/d_spike5 = h(t1, s(t1)), (t2, s(t2))i | ∀t ∈ [tl, tu], (s(t) ≤ s(t1) ∧ s(t) ≥ s(t2)). The maximum and the minimum values (and their
timestamps) taken by signal s.
d_oscillation1 = h[t1, t5], ai | (∃t2, t3, t4 ∈ [tl, tu], (osc(s, t1, t2, t3, t4, t5) ∧ ¬(p2p(s, t2, t3) ∼2 v2 ∨ p2p(s, t3, t4) ∼2 v2) ∧ a =
max(p2p(s, t2, t3), p2p(s, t3, t4)) ∧ ∀t6, t7, t8, t9, t10 ∈ [tl, tu], ((t8 6= t2 ∧ t9 6= t3 ∧ t10 6= t4 ∧ osc(s, t6, t8, t9, t10, t7)) ⇒ (|a − v2| ≤
p2pv (s, t8, t9, v2) ∧ |a − v2| ≤ p2pv (s, t9, t10, v2))))). The amplitude a and the time interval [t1, t5] of the closest oscillation instance to satisfy
the amplitude constraint.
d_oscillation2 = h[t1, t5], wi | (∃t2, t3, t4 ∈ [tl, tu], (osc(s, t1, t2, t3, t4, t5) ∧ ¬(width(t2, t4) ∼1 v1) ∧ w = width(t2, t4) ∧ ∀t6, t7, t8, t9, t10 ∈
[tl, tu], ((t8 6= t2 ∧ t9 6= t3 ∧ t10 6= t4 ∧ osc(s, t6, t8, t9, t10, t7)) ⇒ (|w − v1| < widthv(t8, t10, v1))))). The period w and the interval [t1, t2] of
the closest oscillations instance to satisfy the period constraint.
d_oscillation3 = ht1, s(t1)i | ∃t2, t3 ∈ [tl, tu], tl ≤ t2 < t1 ∧ t1 < t3 ≤ tu ∧ (uni_sm_min(s, t1, [t2, t3]) ∨ uni_sm_max (s, t1, [t2, t3])). The
record at which the only seen strict extremum occurs in the signal, within the time interval [tl, tu].
d_oscillation4 = h(t1, s(t1)), (t4, s(t4))i | ∃t2, t3 ∈ [tl, tu], tl ≤ t2 < t1 ∧ t1 < t4 ∧ t4 < t3 ≤ tu ∧ (uni_sm_min(s, t1, [t2, t4]) ∨
uni_sm_max (s, t1, [t2, t4])) ∧ (uni_sm_min(s, t4, [t1, t3]) ∨ uni_sm_max (s, t4, [t1, t3])) ∧ t4 6= t1. The two records at which the strict maximum
and the strict minimum occur in the signal, within the time interval [tl, tu].
d_oscillation5 = h[tl, tu], s(tl)i. The ﬁrst and the last timestamps (tl and tu) delimiting the interval throughout which signal s is constant,
and the signal value.
d_oscillation6/d_oscillation7 = h(t1, s(t1)), (t2, s(t2))i | ∀t ∈ [tl, tu], (s(t) ≤ s(t1) ∧ s(t) ≥ s(t2)). The maximum and the minimum
values (and their timestamps) taken by the signal s.
d_rises1/d_rises2 = h(t1, s(t1)), (t2, s(t2))i | ∀t ∈ [tl, tu], (s(t) ≤ s(t1) ∧ s(t) ≥ s(t2)). The maximum and the minimum values (and their
timestamps) of signal s.
d_rises3 = h(t1, s(t1)), (t2, s(t2))i | ¬(∃t ∈ [tl, tu], (t1 < t < t2)) ∧ ∃t ∈ (tl, tu], (s(t) ≥ v ∧ ∀t3 ∈ [tl, t), (s(t3) < v) ∧ t1 < t2 < t ∧ s(t1) >
s(t2)). Two signal values that violate the monotonicity constraint and the corresponding consecutive timestamps t1 and t2.
d_rises4 = h(t1, s(t1)), (t2, s(t2))i | tl ≤ t1 < t2 ≤ tu ∧ s(t1) ≥ v ∧ s(t2) < v ∧ ¬∃t ∈ [tl, tu], (t1 < t < t2). The record at which the signal s is
greater than or equal to value v, followed by the record at which the signal falls, going below v.
d_overshoots1/d_overshoots2 = h(t1, s(t1)), (t2, s(t2i)) | ∀t ∈ [tl, tu], (s(t) ≤ s(t1) ∧ s(t) ≥ s(t2)). The maximum and the minimum
values (and timestamps) of signal s.
d_overshoots3 = ht1, s(t1), t2, s(t2)i | ¬(∃t ∈ [tl, tu], (t1 < t < t2))∧∃t ∈ (tl, tu], (s(t) ≥ v1 ∧∀t4 ∈ [tl, t), (s(t4) ≤ v1)∧∀t5 ∈ [t, tu], (s(t5) ≤
v1 + v2)∧ (tl < t1 < t2 < t)∧ s(t1) ≥ s(t2)). Two consecutive records of a signal that overshoots, but does not satisfy the monotonicity constraint.
d_overshoots4 = h(t1, s(t1)), (t2, s(t2)i | tl ≤ t1 < t2 ≤ tu ∧ s(t1) ≥ v1 ∧ s(t1) ≤ v1 + v2 ∧ s(t2) < v1 ∧ ¬∃t ∈ [tl, tu], (t1 < t < t2).
The record at which the signal s is greater than or equal to value v1 and less than or equal to v1+v2, followed by the record at which the signal
undershoots, going below v1.
d_if-then1 = h[t2, tu]i | (∃t1 ∈ [tl, t2), λ, [t1, t2] |= p1 ∧ ∀t3, t4 ∈ (t2, tu], (λ, [t3, t4] 6|= p2)). The time interval delimited by t2 (the last time
instant of the last occurrence of pattern p1) up to the last time instant (tu) of the trace.
d_if-then2 = h[t2, t3], t3 − t2i | (∃t1 ∈ [tl, t2), λ, [t1, t2]
|= p2 ⇒ ¬((t3 − t2) J⊲⊳K d) ∧ ∀t5, t6 ∈
(t2, t3), (λ, [t5, t6] 6|= p2))). The time interval [t2, t3] representing the time distance between patterns p1 and p2 hold, and the exact value of
that violated time distance (t3 − t2).
∗ spk (s, t1, t2, t3, t4, t5) = uni_m_min(s, t2, [t1, t3]) ∧ uni_sm_max (s, t3, [t2, t4]) ∧ uni_m_min(s, t4, [t3, t5])
∗ osc(s, t1, t2, t3, t4, t5) = uni_sm_min(s, t2, [t1, t3]) ∧ uni_sm_max (s, t3, [t2, t4]) ∧ uni_sm_min(s, t4, [t3, t5])
ampv (s, t1, t2, t3, v) = |amp(s, t1, t2, t3) − v|;

p2pv (s, t1, t2, v) = |p2p(s, t1, t2) − v|; widthv (t1, t2, v) = |width(t1, t2) − v|

|= p1 ∧ ∃t4 ∈ (t3, tu], (λ, [t3, t4]

Figure 8. Diagnoses associated with the violation causes of patterns in Figure 6.

• d_spike3 includes the time interval [tl, tu] over which
the property pattern is evaluated, as well as the value
taken by the constant signal throughout that interval.
This diagnosis shows that the signal is constant (i.e.,
it shows a single value) throughout the full time in-
terval [tl, tu], over which the pattern is evaluated. For
instance, for signal β2 in Figure 5, the diagnosis is
h[0, 6], 100i.

• d_spike4 and d_spike5 include two records from
the signal corresponding to its minimum and maxi-
mum values (and the timestamps at which these val-
ues occur). In this way, we show the range of values
over which the signal changes (decreasing or increas-
ing). In the example shown in Figure 5, we report

records h(0, 200), (6, 55)i for the decreasing signal β3
and records h(0, 30), (6, 190)i for the increasing signal
β4.

6.1.4 Oscillation

Violation causes: This pattern can be violated in
at
least seven ways, as illustrated with different sig-
nal behaviors in Figure 11 using the expression “exist
oscillation in β with p2pAmp < 90 period < 0.5”.
These alternatives are the following:

• c_oscillation1 : All oscillation instances in the sig-
nal violate the amplitude constraint. For instance, signal
β1 in the ﬁgure shows two oscillation instances, both

e
u
l
a
V

6

5

4

3

2

1

0

β1

the ﬁgure increases, going from value 40 at timestamp
0.2 to value 150 at timestamp 5.8.

11

0

1

2

3

4

5

6

7

Timestamp

250

200

150

100

50

e
u
l
a
V

β1

β2

β3

β4

β5

β6

Figure 9. A trace violating the expression “assert β < 4”.

e
u
l
a
V

6

5

4

3

2

1

0

β1

β2

β3

0

1

2

3

4

5

6

7

Timestamp

Figure 10. A trace with signals violating the expression “β becomes >
3”.

having an amplitude value greater than 90 (125 and
200, respectively).

• c_oscillation2 : All oscillation instances in the sig-
nal violate the period constraint. For instance, signal β1
shows two oscillation instances whose period value is
greater than 0.5: the ﬁrst oscillation has a period of 0.8
(i.e., the time difference between timestamps 0.2 and 1),
while the second oscillation has a period of 1 (i.e., the
time difference between timestamps 3.5 and 4.5).

• c_oscillation3 : The signal does not show any oscil-
lation; instead, it shows only one strict local extremum
(a maximum or a minimum). This is the case, for
instance, of signal β2 in the ﬁgure, that exhibits a strict
local maximum (reaching the value of 150 at timestamp
1.5).

• c_oscillation4 : The signal does not show any oscil-
lation; instead, it shows only two strict local extrema.
For instance, signal β3 in the ﬁgure exhibits a strict
local minimum (taking value 80 at timestamp 1.5),
followed by a strict local maximum (taking value 150
at timestamp 2).

• c_oscillation5 : The signal is constant throughout
the time interval [tl, tu] (see, for example, signal β4 in
the ﬁgure).

• c_oscillation6 : The signal decreases without show-
ing any oscillatory behavior. For instance, signal β5 in
the ﬁgure decreases, going from value 180 at timestamp
0.1 to value 20 at timestamp 5.8.

• c_oscillation7 : The signal increases without show-
ing any oscillatory behavior. For example, signal β6 in

0

0

1

2

3
Timestamp

4

5

6

Figure 11. A trace with signals violating the expression “exist
oscillation in β with period < 0.5 p2pAmp < 90 ”.

Diagnoses: The diagnoses associated with the seven

violation causes above are the following:

• d_oscillation1 includes the time interval in which
the oscillation with the closest amplitude to satisfy the
amplitude constraint occurs, as well as the amplitude
value of that oscillation instance. The choice of this
diagnosis enables engineers to determine the oscillation
instance with the closest amplitude to the satisfaction
of the amplitude constraint deﬁned in the pattern. For
instance, for signal β1 in Figure 11, the diagnosis is
h[0, 1.9], 125i.

• d_oscillation2 includes the time interval in which
the oscillation with the closest period to satisfy the
period constraint occurs, as well as the period of
that oscillation instance. For instance, for signal β1
in Figure 11, the diagnosis is h[0, 1.9], 0.8i. Similar to
d_oscillation1 , we allow engineers to identify the
oscillation instance that shows the closest period value
to the satisfaction of the period constraint deﬁned in the
pattern.

• d_oscillation3 includes the timestamp (and the cor-
responding signal value) in which the signal exhibits
a strict extremum. The reported diagnosis allows en-
gineers to identify the ﬁrst time in which the signal
exhibited a considerable deviation, leading to a change
of the sign of its derivative. For instance, for signal β2
in Figure 11, the diagnosis is h1.5, 150i.

• d_oscillation4 includes the two records from the
signal in which the strict maximum and the strict min-
imum occur. By considering this diagnosis, engineers
are able to see a considerable change of the signal shape,
showing two different consecutive strict extrema. For
instance, for signal β3 in Figure 11, the diagnosis is
h(1.5, 80), (2, 150)i.

• d_oscillation5 includes the time interval

[tl, tu]
throughout which the signal s is constant, as well as
the value taken by that signal. Similar to d_spike3 , this
diagnosis shows that the signal is constant throughout
the full time interval [tl, tu] over which the pattern is
evaluated. For instance, for signal β4 in Figure 11, the
diagnosis is h[0, 6], 180i.

• d_oscillation6 and d_oscillation7 include the
records in which the maximum and the minimum
values of the signal were observed. In this way, we
show the range of values over which the signal changes
(i.e., decreases or increases). In the example shown in
Figure 11, we report records h(0.1, 180), (5.8, 20)i for
signal β5 and records h(0.2, 40), (5.8, 150)i for signal
β6.

6.1.5 Rise time

Violation causes: This pattern can be violated in
least four ways, as illustrated with different signal
at
behaviors in Figure 12 using the expression “β rises
monotonically reaching 3".

• c_rises1 : The signal is always below the threshold
value v deﬁned in the pattern constraint. For instance,
signal β1 is always below the value of 3, showing values
ranging between 0.8 and 2.5.

• c_rises2 : The signal is always greater than or equal to
the threshold value v. For instance, signal β2 is always
above the value 3, showing values ranging between 4
and 6.

• c_rises3 : The signal shows a rising behavior, but vio-
lates the monotonicity constraint deﬁned in the pattern.
For instance, signal β3 rises reaching the target value
(showing a value of 4 at timestamp 4), but it violates the
monotonicity constraint since its value decreases from
2 (at timestamp 2) to 0.5 (at timestamp 3).

• c_rises4 : The signal is initially above the threshold
value v. It then falls (and remains) below that value,
instead of rising. For instance, signal β4 falls (and
remains) below the target value of 3 (starting from
timestamp 4, up to timestamp 7, showing values rang-
ing within the interval [0.5, 2]) instead of rising.

e
u
l
a
V

6

5

4

3

2

1

0

β1

β2

β3

β4

0

1

2

3

4

5

6

7

Timestamp

12

show the exact interval over which the signal deviated
from the last time it exhibited an increasing behavior,
showing a negative derivative. For instance, for signal
β3 in Figure 12, the diagnosis is h(2, 2), (3, 0.5)i.

• d_rises4 includes two consecutive records in which
the signal shows a dual behavior (i.e., it falls instead
of rising). More precisely, the signal value in the ﬁrst
record is above the threshold value v. The signal
value in the second reported record is, however, below
that value. This diagnosis determines the interval over
which the signal shows a dual behavior, within the
time interval [tl, tu] over which the pattern is evaluated.
For instance, the diagnosis of signal β4 in Figure 12 is
h(3, 3.1), (4, 0.5)i .

6.1.6 Overshoot

Violation causes: This pattern can be violated
illustrated with different
least
in Figure 13 using the expression

in at
signal behaviors
“β overshoots monotonically 3 by 1”:

four ways, as

• c_overshoots1 : The signal violates the pattern con-
straint, by always showing values below the threshold
value v1. For example, signal β1 is always below the
value of 3.

• c_overshoots2 : The signal goes beyond the maxi-
mum allowed value, which consists of the sum of the
target value v1 and the maximum threshold value v2
(v1 + v2), and remains above that value. For instance,
signal β2 exceeds 4 (showing a value of 4.5 at times-
tamp 2) and remains above the value of 4, ranging over
[4.1, 4.9].

• c_overshoots3 : The signal overshoots the threshold
value v1, without going beyond the maximum allowed
value (delimited by v1 + v2 deﬁned in the pattern).
However, it violates the monotonicity constraint. For
instance, signal β3 overshoots, reaching the value of 3.8
at timestamp 4, without going beyond the value of 4
after then. It violates the monotonicity constraint within
the time interval [2, 3], since its value goes from 2 down
to 0.5.

• c_overshoots4 : The signal shows a dual behavior: it
undershoots, going below the value v1, and remains
below that value instead of overshooting. For instance,
signal β4 goes (and remains) below the value of 3. It
reaches value 2 at timestamp 3 and takes, right after
then, values ranging over [0.5, 2].

Diagnoses: The diagnoses associated with the four

Figure 12. A trace with signals violating the expression “β rises
monotonically reaching 3”.

Diagnoses: The diagnoses associated with the four

violation causes above are the following:

• d_rises1 and d_rises2 include the records in which
the signal shows a maximum and a minimum value. In
this way, we show the range of values the signal takes.
For instance, for signal β1 in Figure 12, the diagnosis is
h(5, 0.8), (6.7, 2.5)i. Similarly, diagnosis for signal β2 is
h(0.5, 4), (7, 6)i.

• d_rises3 includes two consecutive records where the
monotonicity constraint is violated. In this way, we

violation causes above are the following:

• d_overshoots1 and d_overshoots2 include the
records in which the signal shows a maximum and
a minimum value. The reported diagnosis allows en-
gineers to understand the range of values taken by
the signal. For instance, for signal β1 in Figure13, the
diagnosis is h(5, 0.8), (6.7, 2.5)i.

• d_overshoots3

includes two consecutive records
from a signal that overshoots, but violates the mono-
tonicity constraint. This diagnosis shows the time in-
terval over which the signal violated the monotonicity
constraint within [tl, tu]. For instance, for signal β3 in
Figure13, the diagnosis is h(2, 2), (3, 0.5)i

β1

β2

β3

β4

13

6.2 Scopes

Since the same syntactic constructs of SB-TemPsy-DSL (e.g.,
the keyword before) can be used to deﬁne both absolute
and event scopes (see Figure 3), we use the identiﬁers
a_ and e_ before the violation cause name depending on
whether it refers to an absolute or an event scope. Addition-
ally, we use bef, aft, and bet as shortcuts for before,
after, and between, respectively. For example, c_a_bef2
denotes a violation cause for the before absolute scope.

0

1

2

3

4

5

6

7

Violation causes:

e
u
l
a
V

6

5

4

3

2

1

0

Timestamp

Figure 13. A trace with signals violating the expression “β overshoots
monotonically 3 by 1”.

• d_overshoots4 includes two consecutive records in
which the signal shows a dual behavior (i.e., it un-
dershoots instead of overshooting). More speciﬁcally,
we report the last record at which the signal value is
delimited by [v1, v1 + v2], followed by the next-seen
record at which it undershoots, going below v1. This
diagnosis allows engineers to understand the interval
over which the signal shows a dual behavior within
the time interval [tl, tu]. For instance, for signal beta4 in
Figure13, the diagnosis is h(2, 3.8), (3, 2.1)i.

6.1.7 Order relationship

Violation causes: A property with an if-then con-
struct is based on two patterns, each of which represents
one of the pattern constructs we support in SB-TemPsy-
DSL. According to the construct syntax if p1 then p2, p1 is
referred to as a cause pattern and p2 as an effect pattern. We
consider two possible violation causes of a property with
the if-then construct.

• c_if-then1 : the cause pattern p1 holds at some time
interval [t1, t2] within the time interval [tl, tu], but then,
the effect pattern p2 fails to hold until the last times-
tamp (tu) of that time interval.

• c_if-then2 : the cause pattern p1 holds within a time
interval [t1, t2] but since then, whenever the effect pat-
tern p2 holds (after p1) within a time interval [t3, t4], the
time distance (t3 − t2) between the occurrences of two
patterns p1 and p2 is violated.

Diagnoses: The diagnoses associated with a viola-
tion of an expression with an if-then construct are the
following:

• d_if-then1 includes the time interval delimited by
the last timestamp (t2) of the last occurrence of pattern
p1 and the last timestamp tu of the time interval [tl, tu],
showing the exact interval over which the effect pattern
p2 failed to hold. The corresponding diagnosis is then
the following: h[t2, tu]i.

• d_if-then2 includes the time interval delimited by
the last timestamp (t2) in which the cause pattern p1
holds, and the ﬁrst timestamp (t3) in which the effect
pattern p2 holds again. The diagnosis also includes the
violated time distance (t3 − t2) between the occurrence
of patterns p1 and p2. The diagnosis is the following:
h[t2, t3], t3 − t2i.

• c_a_at1 , c_a_bef1 and c_a_aft1 are violations re-
lated to absolute boundaries (i.e., timestamps) that are
not within the time interval of the trace over which the
property is evaluated.

• c_a_bet1 indicates that either at least one of the scope
boundaries is outside the time interval [ti, te] or the left
boundary (which is supposed to be smaller than the
right one) is greater than or equal to the right boundary.
• c_e_bef1 states that scope pattern p1 holds in the
execution trace, whereas the property pattern p fails to
hold sometime before p1 held.

• c_e_aft1 indicates that scope pattern p1 holds in the
execution trace, whereas the property pattern p fails to
hold after that.

• c_e_bet1 states that scope patterns p1 and p2 hold in
the execution trace, whereas the property pattern p fails
to hold between the last timestamp where p1 held and
the ﬁrst timestamp in which p2 held.

Diagnoses: The diagnoses associated with scope-

based violations are the following:

• d_a_at1 , d_a_bef1 and d_a_aft1 include the time
interval [ti, te] that delimits the execution trace, as well
as the absolute boundary t that is not within the range
delimited by that time interval.

• d_a_bet1 includes the time interval [ti, te] of the ex-
ecution trace over which the property is evaluated, as
well as the left and the right absolute boundaries of the
scope (i.e., timestamps n and m, respectively; see see
Figure 3).

• d_e_bef1 includes the time interval [t1, t2] in which
the scope pattern p1 held and before which the property
pattern p failed to hold.

• d_e_aft1 includes the time interval [t1, t2] in which
the scope pattern p1 held and after which the property
pattern p failed to hold.

• d_e_bet1 includes the time interval

[t2, t3] where
t2 represents the last timestamp in which pattern p1
(the left event-boundary) held and t3 (the right event-
boundary) is the ﬁrst timestamp in which pattern p2
held throughout the execution trace.

6.3 Atoms

Violation causes: The violation cause c_not1 for the
construct “not sc” requires sc to be satisﬁed, since for “not
sc” to be violated, sc must be satisﬁed (see the semantics in
Figure 4).

Diagnosis: As depicted in Figure 7, many diagnosis
are associated with the violation cause c_not1. Indeed,
for c_not1 the diagnosis should explain why the violation

cause c_not1 (see Figure 6) holds, i.e., why sc is satisﬁed.
The reasons that lead to the satisfaction of sc depend on
the SB-TemPsy-DSL scope and the pattern used to deﬁne
sc. When sc is satisﬁed, both the scope and the pattern
are satisﬁed. Our diagnosis explains why the pattern used to
deﬁne sc holds. For this reason, the name of the diagnosis is
obtained by adding the string “d_not” before the name of
the pattern used to deﬁne sc. In the following, we explain
each of the diagnoses w.r.t the pattern deﬁning sc:

• diagnosis d_not_assert includes a timestamp t in
which one or more signals (s1, s2, . . . , sn) deﬁned in the
related property satisfy the corresponding condition c
as well as the corresponding value(s) taken by each of
these signals.

• diagnosis d_not_becomes includes the ﬁrst times-
tamp t that satisﬁes the property condition, as well as
the value of the signal recorded at t.

• diagnosis d_not_spike includes the ﬁrst and the last
records of a spike instance that occurred within the time
interval [tl, tu].

• diagnosis d_not_oscillation includes the ﬁrst and

the last records of an oscillation instance.

• diagnosis d_not_rises includes the ﬁrst record at
timestamp t in which (1) the signal deﬁned in the prop-
erty rises, reaching the property threshold v, and (2)
the monotonicity constraint (if deﬁned in the pattern) is
satisﬁed within the time interval [tl, t].

• diagnosis d_not_overshoots includes

the ﬁrst
record at which the signal deﬁned in the property
overshoots (i.e., reaching a value that ranges between
values v and v1 + v2) and satisﬁes the monotonicity
constraint, if deﬁned in the pattern.

• diagnosis d_not_if-then includes two time intervals
delimiting where the cause pattern and the effect one of
the property hold throughout the execution trace.

7 TD-SB-TemPsy AT WORK
In this section, we illustrate how TD-SB-TemPsy works by
applying algorithm 1 to three example properties, each of
them with different constructs.

7.1 Property with a single atom

Let us consider property P1, checked on the trace shown in
Figure 5:

P1 ≡ after 7 exists spike in β1

with width < 0.5 amplitude < 90.

14

atom and determines the possible violation causes associ-
ated with it. In this case, the possible violation causes are
the one associated with the after scope construct with
an absolute boundary, i.e., c_a_aft1, and the ﬁve ones
associated with the spike construct, i.e., c_spikei with
1 ≤ i ≤ 5. This means that function GETVIOLATIONCAUSES
returns the list vcs = [c_a_aft1, c_spike1 , c_spike2 ,
c_spike3 , c_spike4, c_spike5].

The algorithm continues by looping through the viola-
tion causes in vcs, to determine the ﬁrst violation cause that
holds on the trace; it will then return the corresponding
diagnosis. In this example, the violation cause c_a_aft1
holds on the trace since the value of parameter t (7) is
outside the time interval [0, 6]. The corresponding diagnosis
d_a_aft1 = h[0, 6], 7i shows the interval [0, 6] and the
absolute boundary 7.

7.2 Property with a single atom and negation

Let us consider property P2, checked on the trace shown in
Figure 10:

P2 ≡ not globally β3 becomes < 3

Based on the SB-TemPsy-DSL grammar in Figure 3, this
property is made of a single atom of the form not sc, where
sc ≡ globally p consists of a globally scope construct
constraining a pattern p of type becomes.

As in the previous example, with only one atom in the
property, algorithm 1 determines whether the atom itself is
violated by the trace (line 5). Since the trace violates the
speciﬁcation deﬁned by the atom, algorithm 1 continues
by computing the associated diagnosis using function TD-
ATOM (algorithm 2).

During the execution of algorithm 2, the auxiliary func-
tion GETVIOLATIONCAUSES returns the list vcs = [c_not1],
since, in this example, the only possible violation cause is
associated with the not construct.

Algorithm 2 will then compute the diagnosis corre-
sponding to the only violation cause included in list vcs, us-
ing the auxiliary function GETDIAGNOSIS. In this example,
the violation cause c_not1 holds on the trace since there
exists a time instant (timestamp 3) in which the value of
signal β3 decreases from value 4.5 to 0.9 (at timestamp 4).
The corresponding diagnosis d_not_becomes = h4, 0.9i
shows the ﬁrst record (at timestamp 4) in which the predi-
cate associated with the becomes pattern holds, as well as
the value of the signal.

Based on the SB-TemPsy-DSL grammar in Figure 3, this
property is made of a single atom of the form after t p,
i.e., it consists of an after scope construct (delimited by
an absolute time instant, parameter t = 7) constraining a
pattern p of type spike.

Given the presence of only one atom in the property,
algorithm 1 ﬁrst determines whether the atom itself is
violated by the trace (line 5). Since the trace violates the
speciﬁcation deﬁned by the atom, algorithm 1 continues
by computing the associated diagnosis using function TD-
ATOM (algorithm 2).

Algorithm 2 relies on the auxiliary function GETVIOLA-
TIONCAUSES, which analyzes the syntactic structure of the

7.3 Property with a conjunction of two atoms

Let us consider property P3, checked on the trace shown in
Figure 12

P3 ≡ globally β3 rises monotonically reaching 3

and between 2 and 6 assert β3 ≤ 4

Based on the SB-TemPsy-DSL grammar in Figure 3, this
property is made of a single clause that consists of
two atoms δ1 and δ2, where δ1 ≡
a conjunction of
globally β3 rises monotonically reaching 3 and
δ2 ≡ between 2 and 7 assert β3 ≤ 4. Atom δ1 consists
of a globally scope construct constraining a pattern p of
type rises; atom δ2 consists of a between scope construct

(delimited by two absolute time instants, parameters t1 = 2
and t2 = 7) constraining a pattern p of type assert.

Given the presence of two atoms in the property, the
loop at lines 4–6 of algorithm 1 is executed twice. More
in details, algorithm 1 ﬁrst determines whether atom δ1
is violated by the trace. Since the trace violates the spec-
iﬁcation deﬁned by the atom, algorithm 1 continues by
computing the associated diagnosis using function TD-
ATOM (algorithm 2). During the execution of the latter, the
auxiliary function GETVIOLATIONCAUSES returns the list
vcs = [c_rises1, c_rises2, c_rises3, c_rises4], since
four possible violation causes are associated with the rises
pattern construct. Function CHECKVIOLATIONCAUSE will
then determine that the ﬁrst violation cause (among those
in vcs) that holds on the trace is c_rises3, since signal β3
violates the monotonicity constraint in two time instants (at
timestamp 2 with value 2 and at timestamp 3 with value
0.5). The corresponding diagnosis, computed by function
GETDIAGNOSIS, is d_rises3 = hh2, 2i, h3, 0.5ii, consisting
of the tuples (each with a timestamp and the corresponding
signal value) that violate the monotonicity constraint.

A similar process is followed for atom δ2, which is also
violated by the trace. In this case, function GETVIOLATION-
CAUSES returns the list vcs = [c_a_bet1, c_assert1],
since the possible violation causes are associated with the
between scope construct and the assert pattern con-
struct. The ﬁrst violation cause that holds on the trace is
c_assert1, since signal β3 violates the predicate associated
with the assertion at timestamp 5, when its value reaches 4.9.
The corresponding diagnosis d_assert1 = h5, 4.9i shows
the timestamp and the signal value. Algorithm 1 then ends
by returning the set of the diagnoses instances, containing
d_rises3 and d_assert1.

8 EVALUATION
Recall that, in CPSs, temporal properties are often complex,
since they are typically expressed as constraints on different
signal behaviors. Although we support characterizations
of individual signal behaviors, these can be and are often
considered together to report violations within a single
property. As a result, we are interested in assessing the
applicability of TD-SB-TemPsy, that is to which extent and
how efﬁciently TD-SB-TemPsy is able to report diagnoses of
industrial properties violated by industrial traces.

8.1 Implementation

We implemented TD-SB-TemPsy as an OCL [23] plugin
for SB-TemPsy-Check [1]. The plugin contains the deﬁni-
tions of OCL constraints that encode the violation causes
(see Figure 6) as well as OCL functions that compute
the diagnoses (see Figures 7–8) associated with the vi-
olation causes. The full OCL encoding is available at
https://ﬁgshare.com/s/50f355f84a28fcbcc153.

8.2 Dataset

To investigate the applicability of TD-SB-TemPsy, we consid-
ered 361 traces provided by our industrial partner; each of
these traces logs in-orbit operations of a satellite. The num-
ber of records in the traces ranges from 25 358 to 9 328 178

(avg = 438 224, StdDev ≈ 596 505), and the recording in-
terval ranges from 25 min to 23 h.29 min (avg = 6 h.38 min,
StdDev = 7 h.5 min).

15

We considered 98 properties deﬁned with our industrial
partner and expressed in SB-TemPsy-DSL. The number of
occurrences of each scope and pattern construct of SB-
TemPsy-DSL in the properties is the following. For scopes:
globally 73, before 1, after 8, at 3, between 15; for
patterns: assert 111, becomes 13, spike 5, oscillation
23, rises 3, falls 7, overshoots 4, undershoots 4,
if-then 23. All the listed scopes and pattern constructs are
used in the deﬁnition of at least one property; we remark
that none of the properties used the not sc construct for
deﬁning atoms.

We considered 361 × 98 = 35 378 trace-property com-
binations, each obtained from one of the 361 traces and
one of the 98 properties. We removed 13 426 trace-property
combinations for which the trace did not log (in any of its
records) any variable used in the property and therefore
did not enable the veriﬁcation of its satisfaction. Then, we
iteratively considered each of the remaining 21 952 trace-
property combinations. Due to the sampling strategy used
by our industrial partner, two records of the same trace may
log different variables, i.e., a value may not be present in
every record for some of the variables. Therefore, to ensure
that the traces have the format described in section 2, we
proceeded as follows. For each trace-property combination,
we (a) removed entirely from the trace all the records that
only contain variable values that do not refer to any of
the variables used in the considered property, since these
records do not affect its satisfaction; (b) removed, from each
of the remaining records, the values of the variables that
were not used in the property, while preserving the rest of
the record; (c) generated missing values for the remaining
variables by using various interpolation functions [24]. We
considered different interpolation functions depending on
the type of the signal, as commonly done in the literature
(e.g., [2]).

Then, we analyzed each of the resulting 21 952 trace-
property combinations. Since TD-SB-TemPsy aims to sup-
port engineers in detecting the source of property violations,
we are interested in selecting the trace-property combina-
tions that lead to such violations. We executed SB-TemPsy-
Check by setting a timeout of 1 min, thus enabling us to
consider all the trace-property combinations in approxi-
mately 1 min × 21952=15 days of computation. Out of the
21 952 trace-property combinations, 2328 of them timed out
(≈ 10.60%). Among the remaining 19 624 (≈ 89.40%) trace-
property combinations that did not timeout, 14 940 com-
binations represent traces that violate a property (76.13%).
Though this may appear surprising at ﬁrst, some of the
properties only refer to speciﬁc phases of the satellite life
cycle (e.g., satellite launch, deployment). We nevertheless
checked these properties by considering all the traces pro-
vided by our industrial partner, including the ones that
refer to the actual regular operations of the satellite. These
trace-property combinations naturally led to a property

violation5.

Our ﬁnal dataset contains 14 940 trace-property combi-
nations leading to a property violation. In this dataset, the
number of records in the traces ranges from 1 to 11 901
(avg ≈ 1032, StdDev ≈ 1471), the recording interval ranges
from 0 s, for traces with a single record, to 23 h.28 min
(avg = 4 h.51 min, StdDev = 6 h.24 min). Notice that the
number of records and the recording intervals of the traces
of the ﬁnal dataset are signiﬁcantly smaller than those
observed for the original traces. This is due to the fact that,
for each trace-property combination, we removed from the
trace all the records that only contained variable values
that did not refer to any of the variables of the considered
property (see step (a) above).

We remark that, to the best of our knowledge, there is no
public dataset containing traces and properties suitable for
works in the area of monitoring or diagnostics for signal-
based temporal properties. For example, existing works in
this area, that use different speciﬁcation languages (e.g.,
STL [10], [13] and HLS [2]), have not released their traces
and properties. Moreover, the lack of standardized bench-
marks in the ﬁeld of runtime veriﬁcation is a well-known is-
sue [25], hindered by the diversity of the tools’ speciﬁcation
languages [26]. Existing speciﬁcation-based generators for
synthesized traces target a particular speciﬁcation language,
such as MFODL [27], MLTL [28], and MTL [29]. No trace
generator exists for SB-TemPsy-DSL or for other languages
for signal-based properties (like STL and HLS).

8.3 Applicability

We assessed the applicability of TD-SB-TemPsy by consid-
ering the 14940 trace-property combinations in our dataset.
Applicability entails the capacity to report diagnoses within
reasonable time.

We remark that we could not perform a comparison
between TD-SB-TemPsy and state-of-the-art tools, for a num-
ber of reasons. First, some alternative approaches [14], [15],
[16] do not support signal-based temporal properties, thus
making any comparison impossible. The only alternative
that supports signal-based properties is AMT2.0 [10], [13].
However, the tool is no longer publicly available6 and its
successor rtamt [30] has dropped support for diagnostics
capabilities, rendering impossible any experimental com-
parison.

Methodology.

We executed TD-SB-TemPsy on each trace-property com-
bination in the dataset, with a timeout of 1 min, leading
to approximately 1 min × 14940=10 days of computation.
For each execution, we recorded whether TD-SB-TemPsy
ﬁnished within the timeout and the diagnoses (if any) it
yielded. To assess the applicability of TD-SB-TemPsy, we an-
alyzed the number of combinations in which TD-SB-TemPsy
ﬁnished within the timeout and whether it yielded a diag-
nosis, i.e., whether at least one violation cause was appli-
cable. We conducted our evaluation on a high-performance

5. A property that does not refer to the regular operations of the
satellite is expected to be violated if checked on a trace recording such
regular operations.

6. https://www-verimag.imag.fr/AMT-2-0.html

Table 1
Number (#N) of diagnosis instances generated by TD-SB-TemPsy for
each scope and pattern construct of SB-TemPsy-DSL (as used in the
properties in our datasets).

16

Type

Construct

#N Construct

#N Construct

#N

main dataset

Scope

globally
at

before

0
1002 between

294 after
660

Pattern assert

oscillation 460
overshoots

0

7098 becomes

0
rises
0
undershoots 0

spike
falls
if-then

2640

321
0
11

Pattern becomes

656

overshoots

942 undershoots 940

MD1 dataset

Pattern rises

90

falls

90

MD2 dataset

computing platform, using nodes equipped with Dell C6320
units (2 Xeon E5-2680v4@2.4 GHz, 128 GB).

Results.

TD-SB-TemPsy ﬁnished within the timeout for ≈ 80.66% of
the combinations (12 051 out of 14 940).

For the remaining 2889 combinations that timed out,
≈ 9.48% of these combinations (274 out of 2889) come
from properties using the if-then construct, ≈ 76.71% of
the combinations (2216 out of 2889) come from properties
using the event scope constructs, and ≈ 13.81% of the
combinations (399 out of 2889) come from properties that
used the or and and operators to combine properties and
clauses deﬁned using the aforementioned constructs. For
these combinations, the computational overhead to com-
pute the diagnosis led to timeouts. Note that, in practice,
engineers are likely to use larger timeouts than the one
selected here, which is due to experimental constraints, and,
therefore, we expect the percentage of combinations that
time out to decrease.

For the 12 051 trace-property combinations that ﬁnished
within the timeout, TD-SB-TemPsy always returned a diag-
nosis. We recall that a diagnosis is made by one or more
diagnosis instances that are generated by TD-SB-TemPsy for
the different atoms of the formula (see Section 4). These
instances describe why the scope and pattern constructs
of SB-TemPsy-DSL used for the deﬁnitions of the atom are
violated by a trace. TD-SB-TemPsy produced one diagnosis
instance for each atom of the formula (corresponding to the
input property) for 94.38% of the combinations (11 374 out
of 12 051). For the remaining 5.62% of the combinations
(677 out of 12 051), some atoms of the formula did not lead
to any diagnosis instance. In total, the 12 051 combinations
returned 12 486 diagnosis instances.

The top part of Table 1 shows the number of diagnosis
instances (column #N) computed by TD-SB-TemPsy for each
scope and pattern construct of SB-TemPsy-DSL (as used in
the properties in our main dataset). These results suggest
that a relatively high percentage of the diagnosis instances
(1002 + 294 + 660 + 2640 = 4596 out of 12 486, ≈ 36.81%)
are related to scope constructs. Indeed, since we considered
all the possible trace-property combinations in our dataset,
there are many combinations for which the time instant

values used to deﬁne the scope operators exceeded the
maximum timestamp recorded in the trace. The remaining
≈ 63.19% of the diagnosis instances (7098+460+321+11 =
7890 out of 12 486) are related to patterns constructs. TD-
SB-TemPsy returned diagnosis instances for the assert,
spike, oscillation, and if-then constructs, though
with different prevalence. TD-SB-TemPsy did not report
any diagnosis instances for the becomes, rises, falls,
overshoots, and undershoots constructs. We further
analyzed the properties containing these constructs and
noticed that, in all these cases, TD-SB-TemPsy detected a
violation of the corresponding scope. In such cases, the diag-
nosis instances returned by TD-SB-TemPsy are only related
to the scope constructs.

To guarantee a complete applicability assessment of TD-
SB-TemPsy, covering all SB-TemPsy-DSL constructs, we built
two additional datasets (MD1 and MD2), derived from the
main one, using the following strategies:

MD1 (replacing the property scope). We considered all
the 2562 trace-property combinations where the properties
are deﬁned using only one single pattern of type becomes,
overshoots, or undershoots within a scope operator. We
changed the scope of the patterns to globally in order to
avoid any scope violations, thus making the detection of
violations of these property patterns possible. As a result,
we obtained 2562 additional trace-property combinations
which constitute the MD1 dataset.

MD2 (changing the pattern deﬁnition). The

patterns
rises and falls were not used in any property containing
only one single pattern, but were always used within the
if-then construct. Therefore, we considered the 180 trace-
property combinations where the properties contained
the rises and falls patterns and extracted from the
if-then construct
the subproperties that were using
these patterns. This led to 180 additional trace-property
combinations, which constitute the MD2 dataset.

We executed TD-SB-TemPsy on the MD1 and MD2
datasets with a timeout of 1 min. In the case of MD1, TD-
SB-TemPsy yielded diagnosis instances for ≈ 99.06% of
the combinations (2538 out of 2562), with no timeout; the
distribution of these instances is shown in the middle part of
Table 1. For MD2, TD-SB-TemPsy yielded diagnosis instances
for all 180 combinations; the distribution of these instances
is shown in the bottom part of Table 1.

In conclusion, the results showed that TD-SB-TemPsy
was widely applicable in the context of an industrial case
study. Indeed, when considering the main dataset as well as
MD1 and MD2, TD-SB-TemPsy was able to ﬁnish within the
small timeout of 1 min for 12 051 + 2562 + 180 = 14 793 out
of 14 940 + 2562 + 180 = 17 682 (≈ 83.66%) of the trace-
property combinations in our dataset, returning a diagnosis
for 12 051 + 2538 + 180 = 14 769 combinations (≈ 99.84%
of the cases). These results suggest that, in practice, our set
of violation causes provide sufﬁcient coverage of observed
violations.

8.4 Threats to Validity

In terms of internal validity, the choice of a timeout of 1 min,
justiﬁed by the high computational time for the experiments
(15 days), led to a number of trace-property combinations

17

for which TD-SB-TemPsy did not ﬁnish its execution. Con-
sidering a larger timeout would further increase the appli-
cability of TD-SB-TemPsy.

In terms of external validity, the trace-property combina-
tions in our dataset may be a threat for the generalization
of our results, as other datasets may differ in terms of
(a) the constructs used for expressing the properties, (b) the
type of property violations. We mitigated this threat by
selecting an industrial case study in the satellite domain
that is representative of complex CPS, with large traces and
many complex properties elicited with experts. Further, we
modiﬁed scopes and patterns in our case study properties to
expand our analysis such as to consider more trace-property
combinations.

Regarding conclusion validity, the trace-property combi-
nations in our dataset did not trigger all the 34 violation
causes in our catalogue (see Figure 6). More in details, trace-
property combinations from the main dataset cover 9 out
of the 34 violation causes. Including additional datasets
(MD1 and MD2), covered violation causes reach 17 out of
34 (8 new ones). These 8 new covered violations causes are
distributed as follows: 2 becomes, 2 rises (and its dual
falls) and 4 overshoots (and its dual undershoots).

8.5 Data Availability

We cannot publicly release the traces and properties used in
the experiments because they are subject to a non-disclosure
agreement. The raw output of TD-SB-TemPsy and the script
used for the analysis of the evaluation data are available at
https://ﬁgshare.com/s/50f355f84a28fcbcc153; we are going
to make this dataset public upon acceptance. Also upon
acceptance, we are going to release TD-SB-TemPsy under a
FOSS license.

9 RELATED WORK

The problem of enriching Boolean veriﬁcation verdicts
with additional information that supports reasoning on the
causes of such verdicts has been widely studied in the
literature. This section discusses related work in the trace-
checking and model-checking areas. We included the latter
since a trace can be seen as a model made by a sequence of
consecutive states, each representing one trace record, with
transitions connecting the consecutive records.

In the trace-checking area, there are two main strategies
(see Section 1) that aim to provide additional information on
the causes of a property violation: (i) isolating slices of the
traces that explain the property violation (e.g., [10], [11], [12],
[13]); and (ii) checking whether the traces show common
behaviors that lead to the property violation (e.g., [14],
[15], [16]). The ﬁrst strategy produces large explanations
for complex properties since the size of the explanation
increases with the number of operators of the formula ex-
pressing the property of interest. Existing approaches based
on the second strategy do not support complex signal-based
temporal properties (as the ones considered in this work)
and are not complemented by a precise methodology that
describes how to add new causes that support more com-
plex properties. Therefore, in this work we have proposed a
novel, language-agnostic methodology for deﬁning violation

causes and diagnoses, and applied it in the context of signal-
based temporal properties expressed in SB-TemPsy-DSL.

In the model-checking area, some approaches (e.g., [31],
[32], [33], [34], [35], [36], [37], [38], [39], [40]) extract informa-
tion from the model (e.g., model slices) to explain the model
checking verdict. Typically, these approaches have limited
scalability and therefore are not easily applicable to the
trace-checking scenario. TD-SB-TemPsy relies on a concep-
tually different technique, which leverages violation causes
and diagnoses to explain trace checking verdicts. Moreover,
its implementation uses existing technologies that showed
encouraging scalability results in previous works; our eval-
uation conﬁrms the applicability of our solution. Other
approaches (e.g., [41], [42], [43], [44], [45], [46], [47]) rely on
deductive reasoning techniques to explain model checking
verdicts. Different from the approach proposed in this work,
they usually provide an exhaustive explanation for a verdict
by considering some initial assertions (e.g., simple condi-
tions on the values assumed by the variables in the states
of the model) and examining how logical operators can
be applied to reach a speciﬁc logical conclusion. However,
the proofs produced by deductive reasoning approaches
are usually difﬁcult to understand for non-experts. Besides,
their size signiﬁcantly grows with the size of the model to
analyze [48]. Therefore, when the model represents a trace,
which is typically large in practice (i.e., because of a large
number of records), the generated proofs are likely to be
extremely large and difﬁcult to understand by engineers.

10 CONCLUSION

In this paper, we proposed TD-SB-TemPsy, a trace-diagnostic
approach for signal-based temporal properties, based on
violation causes and diagnoses. We deﬁned a methodology
for deﬁning violation causes and diagnoses that provides
formal soundness guarantees. We proposed a catalog of 34
violation causes, each associated with one diagnosis, for
properties expressed in SB-TemPsy-DSL. We evaluated TD-
SB-TemPsy by assessing its applicability on a large set of
trace-property combinations from an industrial case study
in the satellite domain. TD-SB-TemPsy ﬁnished within the
stringent timeout of 1 min for ≈ 83.66% of these combina-
tions and provided a diagnosis for ≈ 99.84% of these cases.
In practice, outside of experimental settings, longer timeouts
can be considered.

In the future, we plan to perform a large-scale, sys-
tematic evaluation to assess (a) the scalability of TD-SB-
TemPsy with respect to the trace size and (b) its applicability
when dealing with different violation causes. This evalu-
ation requires the use of synthesized traces, which enable
varying the trace size and controlling the causes of property
violations. In addition, we intend to conduct a user study
to assess the usefulness of the diagnoses provided by TD-
SB-TemPsy, for example in the context of fault localization.
Furthermore, we foresee the application of our methodology
for deﬁning violation causes to other pattern-based speciﬁ-
cation languages, to corroborate our language-agnosticism
claim through concrete examples.

18

ACKNOWLEDGMENTS

Part of this work was supported by the Natural Sciences
and Engineering Research Council of Canada (NSERC),
through its DG and CRC programs; by European Union’s
Horizon 2020 Research and Innovation Programme under
grant agreement No. 957254 (COSMOS).

REFERENCES

[1] C. Boufaied, C. Menghi, D. Bianculli, L. Briand,

and
Y. Isasi Parache, “Trace-checking signal-based temporal proper-
ties: A model-driven approach,” in International Conference on
Automated Software Engineering (ASE).
New York, NY, USA:
IEEE/ACM, 2020, pp. 1004–1015.

[2] C. Menghi, E. Viganò, D. Bianculli, and L. C. Briand, “Trace-
Checking CPS Properties: Bridging the Cyber-Physical Gap,” in
International Conference on Software Engineering (ICSE). Los Alami-
tos, CA, USA: IEEE, 2021, pp. 847–859.

[3] C. Menghi, S. Nejati, K. Gaaloul, and L. C. Briand, “Generating
automated and online test oracles for simulink models with con-
tinuous and uncertain behaviors,” in European Software Engineering
Conference and Symposium on the Foundations of Software Engineering
(ESEC/FSE). New York, NY, USA: ACM, 2019, pp. 27–38.

[4] F. Gorostiaga and C. Sánchez, “Striver: Stream runtime veriﬁcation
for real-time event-streams,” in International Conference on Runtime
Veriﬁcation (RV). Cham: Springer, 2018, pp. 282–298.

[5] L. Convent, S. Hungerecker, M. Leucker, T. Scheffel, M. Schmitz,
and D. Thoma, “TeSSLa: temporal stream-based speciﬁcation
language,” in Brazilian Symposium on Formal Methods.
Cham:
Springer, 2018, pp. 144–162.

[6] P. Faymonville, B. Finkbeiner, S. Schirmer, and H. Torfah, “A
stream-based speciﬁcation language for network monitoring,” in
International Conference on Runtime Veriﬁcation, vol. 10012, 09 2016.
[Online]. Available: https://10.1007/978-3-319-46982-9_10

[7] C. Menghi, C. Tsigkanos, P. Pelliccione, C. Ghezzi, and T. Berger,
“Speciﬁcation patterns for robotic missions,” IEEE Transactions on
Software Engineering, vol. 47, no. 10, pp. 2208–2224, 2021.

[8] M. Fowler, Domain-speciﬁc languages. Boston, MA, USA: Pearson

Education, 2010.

[9] C. Boufaied, M. Jukss, D. Bianculli, L. C. Briand, and Y. Isasi
Parache, “Signal-based properties of cyber-physical systems:
Taxonomy and logic-based characterization,” Journal of Systems
and Software, vol. 174, p. 110881, 2021.
[Online]. Available:
https://www.sciencedirect.com/science/article/pii/S0164121220302715

[10] T. Ferrère, O. Maler, and D. Niˇckovi´c, “Trace diagnostics using
temporal implicants,” in International Symposium on Automated
Technology for Veriﬁcation and Analysis. Cham: Springer, 2015, pp.
241–258.

[11] S. Mukherjee and P. Dasgupta, “Computing minimal debugging
windows in failure traces of ams assertions,” IEEE Transactions on
Computer-Aided Design of Integrated Circuits and Systems, vol. 31,
no. 11, pp. 1776–1781, 2012.

[12] I. Beer, S. Ben-David, H. Chockler, A. Orni, and R. Treﬂer, “Ex-
plaining counterexamples using causality,” in International Con-
ference on Computer Aided Veriﬁcation (CAV). Berlin, Heidelberg:
Springer, 2009, pp. 94–108.

[13] D. Niˇckovi´c, O. Lebeltel, O. Maler, T. Ferrère, and D. Ulus, “Amt
2.0: Qualitative and quantitative trace analysis with extended
signal temporal logic,” in Tools and Algorithms for the Construction
and Analysis of Systems. Cham: Springer, 2018, pp. 303–319.
[14] J. H. Dawes and G. Reger, “Explaining violations of properties in
control-ﬂow temporal logic,” in International Conference on Runtime
Veriﬁcation (RV). Cham: Springer, 2019, pp. 202–220.

[15] W. Dou, D. Bianculli, and L. Briand, “Model-driven trace diag-
nostics for pattern-based temporal speciﬁcations,” in Proceedings
of the 21th ACM/IEEE International Conference on Model Driven
Engineering Languages and Systems. New York, NY, USA: ACM,
2018, pp. 278–288.

[16] Q. Luo, Y. Zhang, C. Lee, D. Jin, P. O. Meredith, T. Serbanuta,
and G. Rosu,
runtime
veriﬁcation with simultaneous properties,” in Runtime Veriﬁcation
(RV 2014),
in Computer Science, vol.
8734. Cham: Springer, 2014, pp. 285–300. [Online]. Available:
https://doi.org/10.1007/978-3-319-11164-3_24

“Rv-monitor: Efﬁcient parametric

ser. Lecture Notes

model checking,” in Formal Methods in Computer Aided Design
(FMCAD). Los Alamitos, CA, USA: IEEE, 2018, pp. 1–9.

19

[38] F. Funke, S. Jantsch, and C. Baier, “Farkas certiﬁcates and minimal
witnesses for probabilistic reachability constraints,” in Tools and
Algorithms for the Construction and Analysis of Systems (TACAS
2020), ser. LNCS, vol. 12078. Cham: Springer, 2020, pp. 324–345.
[39] N. Timm, S. Gruner, M. Nxumalo, and J. Botha, “Model checking
safety and liveness via k-induction and witness reﬁnement with
constraint generation,” Science of Computer Programming, vol. 200,
p. 102532, 2020.

[40] A. Gurﬁnkel and M. Chechik, “Proof-like counter-examples,” in
Tools and Algorithms for the Construction and Analysis of Systems.
Berlin, Heidelberg: Springer, 2003, pp. 160–175.

[41] D. Peled and L. Zuck, “From model checking to a temporal proof,”
in International SPIN workshop on Model checking of software. Berlin
Heidelberg: Springer-Verlag, 2001, pp. 1–14.

[42] A. Bernasconi, C. Menghi, P. Spoletini, L. D. Zuck, and C. Ghezzi,
“From model checking to a temporal proof for partial models,” in
Software Engineering and Formal Methods (SEFM). Cham: Springer,
2017, pp. 54–69.

[43] D. Peled, A. Pnueli, and L. Zuck, “From falsiﬁcation to ver-
iﬁcation,” in International Conference on Foundations of Software
Technology and Theoretical Computer Science.
Berlin, Heidelberg:
Springer, 2001, pp. 292–304.

[44] A. Mebsout and C. Tinelli, “Proof certiﬁcates for smt-based model
checkers for inﬁnite-state systems,” in 2016 Formal Methods in
Computer-Aided Design (FMCAD). Los Alamitos, CA, USA: IEEE,
2016, pp. 117–124.

[45] D. Basin, B. N. Bhatt, and D. Traytel, “Optimal proofs for linear
temporal logic on lasso words,” in International Symposium on
Automated Technology for Veriﬁcation and Analysis. Cham: Springer,
2018, pp. 37–55.

[46] A. Pnueli and Y. Kesten, “A deductive proof system for ctl,” in
International Conference on Concurrency Theory. Berlin, Heidelberg:
Springer-Verlag, 2002, pp. 24–40.

[47] I. Balaban, A. Pnueli, and L. D. Zuck, “Proving the refuted:
Symbolic model checkers as proof generators,” in Concurrency,
Compositionality, and Correctness.
Berlin, Heidelberg: Springer,
2010, pp. 221–236.

[48] S. Grebing and M. Ulbrich, “Usability recommendations for
user guidance in deductive program veriﬁcation,” in Deductive
Software Veriﬁcation: Future Perspectives: Reﬂections on the Occasion
of 20 Years of KeY. Cham: Springer, 2020, pp. 261–284. [Online].
Available: https://doi.org/10.1007/978-3-030-64354-6_11

[17] W. Dou, D. Bianculli, and L. Briand, “A model-driven approach
to trace checking of pattern-based temporal properties,” in Proc.
MODELS2017. Los Alamitos, CA, USA: IEEE Computer Society,
2017, pp. 323–333.

[18] D. Giannakopoulou, T. Pressburger, A. Mavridou, and J. Schu-
mann, “Generation of formal requirements from structured natu-
ral language,” in Requirements Engineering: Foundation for Software
Quality (REFSQ 2020). Cham: Springer International Publishing,
2020, pp. 19–35.

contributors,

[19] Wikipedia
the
cessed
https://en.wikipedia.org/w/index.php?title=Beta_angle&oldid=1035086598

angle — Wikipedia,
ac-
[Online;
Available:

encyclopedia,”
2-September-2021].

[Online].

“Beta

2021,

free

[20] T. Ott, A. Benoit, P. Van den Braembussche, and W. Fichter, “ESA
pointing error engineering handbook,” in 8th International ESA
Conference on Guidance, Navigation & Control Systems. Bruxelles:
European Space Agency, 2011, p. 17.

[21] A. J. Robinson and A. Voronkov, Handbook of automated reasoning.

Amsterdam, Holland: Elsevier, 2001, vol. 1.

[22] L. De Moura and N. Bjørner, “Z3: An efﬁcient smt solver,” in
Proceedings of the Theory and Practice of Software, 14th International
Conference on Tools and Algorithms for the Construction and Analysis
of Systems. Berlin, Heidelberg: Springer-Verlag, 2008, pp. 337–340.
v2.3.1),”

[23] OMG,

“ISO/IEC

19507

(OCL

http://www.omg.org/spec/OCL/ISO/19507/PDF, April 2012.

[24] J. Szabados and P. Vértesi, Interpolation of functions.

Singapore:

World Scientiﬁc, 1990.

[25] E. Bartocci, Y. Falcone, B. Bonakdarpour, C. Colombo, N. Decker,
K. Havelund, Y.
Joshi, F. Klaedtke, R. Milewicz, G. Reger,
G. Rosu, J. Signoles, D. Thoma, E. Zalinescu, and Y. Zhang,
“First international competition on runtime veriﬁcation: rules,
benchmarks, tools, and ﬁnal results of CRV 2014,” Int. J. Softw.
Tools Technol. Transf., vol. 21, no. 1, pp. 31–70, 2019. [Online].
Available: https://doi.org/10.1007/s10009-017-0454-5

[26] G. Reger, “A report of rv-cubes 2017,” in RV-CuBES 2017.
An International Workshop on Competitions, Usability, Benchmarks,
Evaluation, and Standardisation for Runtime Veriﬁcation Tools,
September 15, 2017, Seattle, WA, USA, ser. Kalpa Publications in
Computing, G. Reger and K. Havelund, Eds., vol. 3. EasyChair,
2017, pp. 1–9. [Online]. Available: https://doi.org/10.29007/2496
[27] S. Krsti´c and J. Schneider, “A benchmark generator for online ﬁrst-
order monitoring,” in International Conference on Runtime Veriﬁca-
tion. Springer, 2020, pp. 482–494.

[28] J. Li and K. Y. Rozier, “Mltl benchmark generation via formula
progression,” in International Conference on Runtime Veriﬁcation.
Springer, 2018, pp. 426–433.

[29] D. Ulus, “Timescales: A benchmark generator for mtl monitoring
tools,” in International Conference on Runtime Veriﬁcation. Springer,
2019, pp. 402–412.

[30] D. Niˇckovi´c and T. Yamaguchi, “Rtamt: Online robustness moni-
tors from stl,” in International Symposium on Automated Technology
for Veriﬁcation and Analysis. Springer, 2020, pp. 564–571.

[31] C. Menghi, A. M. Rizzi, and A. Bernasconi, “Integrating topolog-
ical proofs with model checking to instrument iterative design,”
in Fundamental Approaches to Software Engineering (FASE). Cham:
Springer, 2020, pp. 53–74.

[32] V. Schuppan, “Towards a notion of unsatisﬁable and unrealizable
cores for ltl,” Science of Computer Programming, vol. 77, no. 7-8, pp.
908–939, 2012.

[33] F. Hantry and M.-S. Hacid, “Handling conﬂicts in depth-ﬁrst
search for ltl tableau to debug compliance based languages,”
Electronic Proceedings in Theoretical Computer Science, vol. 68, 09
2011.

[34] G. Zheng, T. Nguyen, S. G. Brida, G. Regis, M. F. Frias, N. Aguirre,
and H. Bagheri, “Flack: Counterexample-guided fault localization
for alloy models,” in International Conference on Software Engineer-
ing (ICSE). Los Alamitos, CA, USA: IEEE, 2021, pp. 637–648.
[35] M. Chechik and A. Gurﬁnkel, “A framework for counterexample
generation and exploration,” in Fundamental Approaches to Software
Engineering, ser. FASE.
Berlin, Heidelberg: Springer, 2005, p.
220–236.

[36] T. Bochot, P. Virelizier, H. Waeselynck, and V. Wiels, “Paths to
property violation: A structural approach for analyzing counter-
examples,” in International Symposium on High Assurance Systems
Engineering. Los Alamitos, CA, USA: IEEE, 2010, pp. 74–83.
[37] A. Griggio, M. Roveri, and S. Tonetta, “Certifying proofs for ltl

