2
2
0
2

l
u
J

2
1

]
i
c
s
-
l
r
t

m

.
t
a
m
-
d
n
o
c
[

2
v
4
8
4
4
0
.
4
0
2
2
:
v
i
X
r
a

Data-analysis software framework 2DMAT and its application to experimental
measurements for two-dimensional material structures

Yuichi Motoyamaa, Kazuyoshi Yoshimia, Izumi Mochizukib, Harumichi Iwamotoc, Hayato Ichinosed, Takeo Hoshic,b,d,e

aInstitute for Solid State Physics, University of Tokyo, Kashiwa-shi, Chiba 277-8581 Japan
bSlow Positron Facility, Institute of Materials Structure Science, High Energy Accelerator Research Organization (KEK), Oho 1-1, Tsukuba, Ibaraki 305-0801,
Japan
cDepartment of Mechanical and Physical Engineering, Faculty of Engineering, Tottori University, Tottori-shi, Tottori 680-8552, Japan
dDepartment of Engineering, Graduate School of Sustainability Science, Tottori University, Tottori-shi, Tottori 680-8552, Japan
eAdvanced Mechanical and Electronic System Research Center, Faculty of Engineering, Tottori University, Tottori-shi, Tottori 680-8552, Japan

Abstract

An open-source data-analysis framework 2DMAT has been developed for experimental measurements of two-dimensional mate-
rial structures. 2DMAT oﬀers ﬁve analysis methods: (i) Nelder-Mead optimization, (ii) grid search, (iii) Bayesian optimization,
(iv) replica exchange Monte Carlo method, and (v) population-annealing Monte Carlo method. Methods (ii) through (v) are im-
plemented by parallel computation, which is eﬃcient not only for personal computers but also for supercomputers. The current
version of 2DMAT is applicable to total-reﬂection high-energy positron diﬀraction (TRHEPD), surface X-ray diﬀraction (SXRD),
and low-energy electron diﬀraction (LEED) experiments by installing corresponding forward problem solvers that generate diﬀrac-
tion intensity data from a given dataset of the atomic positions. The analysis methods are general and can be applied also to other
experiments and problems.

Keywords: data analysis for experimental measurements, Nelder-Mead optimization, Bayesian optimization, grid search, replica
exchange Monte Carlo method, population-annealing Monte Carlo method, two-dimensional material, total-reﬂection high-energy
positron diﬀraction, surface X-ray diﬀraction, low-energy electron diﬀraction

PROGRAM SUMMARY

Code Ocean capsule: (to be added by Technical Editor)

2DMAT– Open-source data-analysis framework for experimental
measurement of two-dimensional material structures
Authors: Yuichi Motoyama, Kazuyoshi Yoshimi, Izumi Mochizuki,
Harumichi Iwamoto, Hayato Ichinose, Takeo Hoshi
Program title: 2DMAT
Journal reference:
Catalogue identiﬁer:
Program summary URL:
https://www.pasums.issp.u-tokyo.ac.jp/2dmat/
Licensing provisions: GNU General Public License v3.0
Programming language: Python 3
Computer: Any architecture
Operating system: Unix, Linux, macOS
RAM: Depends on the number of variables
Number of processors used: Arbitrary
Keywords: Nelder-Mead optimization, Bayesian optimization, grid-
based search, replica exchange Monte Carlo method, population-
annealing Monte Carlo method, total-reﬂection high-energy positron
diﬀraction (TRHEPD), surface X-ray diﬀraction (SXRD), low-energy
electron diﬀraction (LEED).
External routines/libraries: Numpy, Scipy, Tomli, mpy4py
Nature of problem: Analysis of experimental measurement data
Solution method: Optimization, grid-based global search, Monte
Carlo method

Email addresses: y-motoyama@issp.u-tokyo.ac.jp (Yuichi
Motoyama), k-yoshimi@issp.u-tokyo.ac.jp (Kazuyoshi Yoshimi),
hoshi@tottori-u.ac.jp (Takeo Hoshi)

1. Introduction

One major issue in computational physics is to construct a
fast and reliable data-analysis method for experimental mea-
surements. The data-analysis procedure is to obtain the target
physical quantity X
(X1, X2, . . . , Xn) from the experimentally
≡
observed data D
(D1, D2, . . . , Dm). A typical case is the in-
verse problem, in which D is caused by X and is written as a
function of X (D = Dcal(X)), which is referred to as a forward
problem solver. The inverse problem is solved, in principle, by
searching for the minimum of the objective function

≡

F = F(X)

≡

d(Dcal(X), D),

(1)

where d(u, v) denotes a distance function between the two vec-
tors u = (u1, . . . , um) and v = (v1, . . . , vm). Hereinafter the 2-
norm form

d(u, v)

vi)2

(ui

−

,

(2)

m

Xi=1

≡ 


1/2





is used, except where indicated. The objective function F(X)
may have local minima and may be aﬀected by uncertainties
due to the measurement conditions and the apparatus.

Preprint submitted to Computer Physics Communications

July 13, 2022

 
 
 
 
 
 
Here, we focus on quantum-beam diﬀraction experiments
for the structure determination of two-dimensional (2D) ma-
terials, since 2D materials hold great promise for industrial ap-
plications, such as next-generation electronic devices, and cat-
alysts. Nowadays, the structure of 2D materials are measured
by total-reﬂection high-energy positron diﬀraction (TRHEPD)
[1–3], surface X-ray diﬀraction (SXRD) [4, 5] and low-energy
electron diﬀraction (LEED) [6].
In these experiments, D is
the diﬀraction intensity and X is the atom position in two-
dimensional materials. However, 2D materials are generally
more diﬃcult to measure the structure (atom position) than
three-dimensional materials, since the diﬀraction beam inten-
sity of 2D materials is weak, and the types of structures are
diverse.

The present paper reports that we have recently developed
2DMAT,
an open-source data-analysis framework for two-
dimensional material structures. The data-analysis methods are
based on the above inverse-problem approach for TRHEPD,
SXRD, and LEED experiments. In addition, 2DMAT is appli-
cable to other problems if the user prepares an objective func-
tion F = F(X). The software framework features parallel algo-
rithms using the Message Passing Interface (MPI) for eﬃcient
data analysis not only by workstations with many-core CPU’s
but also by supercomputers. An early-stage package was de-
veloped as a private program [7–9]. We then added several
new features to the code and released the present package as
an open-source software framework.

The remainder of the present paper is organized as follows.
Section 2 gives an overview of the algorithms for the inverse
problem. Section 3 explains the supported experiments and
problems: TRHEPD, SXRD, LEED, and others. Section 4 ex-
plains the present software framework. Section 5 is devoted to
examples. Finally, we summarize the present paper and com-
ment on future utilities in Section 6.

2. Analysis algorithms for the inverse problem

This section is devoted to an overview of the following
ﬁve analysis algorithms implemented in 2DMAT: (i) Nelder-
Mead method [10, 11], (ii) grid search, (iii) Bayesian opti-
mization (BO) method [12], (iv) replica exchange MC (REMC)
method [13], and (v) population-annealing MC (PAMC)
method [14]. These algorithms commonly use computation of
the objective function F = F(X) in n-dimensional parameter
space (X
(X1, . . . , Xn)). For the latter four methods, MPI
(MPI for Python [15–18]) can be used for parallel computation.

≡

2.1. Nelder-Mead method

The Nelder-Mead optimization method, also known as
the downhill simplex method[10, 11],
is a gradient-free
=
optimization method in which the gradient,
(∂F/∂X1, ∂F/∂X2, . . . , ∂F/∂Xn), is not required. The optimal
solution is searched for by systematically moving pairs of n + 1
coordinate points
l=1,...,n+1, according to the value of the
}
objective function F(X(l)) at each point X(l). In 2DMAT, the func-
tion scipy.optimize.minimize in scipy [19] is used, and the
method is not parallelized.

X(l)

X F

∇

{

2

2.2. Grid-search method

The grid-search method is an algorithm for searching for the
minimum value of F(X) by computing F(X) for all of the can-
didate points in the parameter space prepared in advance. In
2DMAT, the set of candidate points is equally divided and auto-
matically assigned to each process for trivial parallel computa-
tion.

2.3. Bayesian optimization method

The BO method is a black-box optimization method[12]. In
BO, a surrogate model with a parameter set θ, G(X; θ), is trained
by an observed dataset for representing F(X). Then, by us-
ing the trained model G(X; θ), the next candidate X∗ to be ob-
served is obtained by optimizing an acquisition function calcu-
lated from the expectation value and the variance of G(X; θ).
For example, the probability of improvement PI(X), which is
the probability that X becomes the new optimal solution when
X is observed, is one of the widely-used acquisition functions.
2DMAT uses a BO library, PHYSBO [20, 21]. As for the grid-
search method, PHYSBO requires the set of candidate points in
advance but enables speed-up for yielding the next candidate by
trivial parallelization.

2.4. Replica-exchange Monte Carlo method

Thus far, we have considered the optimization problem, i.e.,
the minimization of F(X; D) for determining the optimal value
of X from the experimentally observed data D. Hereinafter, we
will determine the conditional distribution of X under D (also
known as the posterior probability distribution), π(X
D). Then,
π(X

D) is given by

|

|

D) =

π(X

|

π(D

X)π(X)
Z

|

,

(3)

|

|

|

−

dXπ(D
X) is deﬁned as π(D

X) is the likelihood function, π(X) is the prior prob-
where π(D
ability distribution of X, and Z =
X)π(X) is the nor-
X) =
malization factor. The likelihood π(D
R
F/τ). The given parameter τ(> 0) is a measure of the
exp(
tolerable uncertainty, which is called the ‘temperature’ based
on the analogy of statistical physics. A constraint such as
X(lower)
is reduced to the uniform prior dis-
i
tribution in the region π(X). The normalization factor Z, also
called the partition function, is useful for choosing the proper
model, Dcal(X). By using these terms, the posterior probability
distribution π(X

D; τ) can be rewritten as

X(upper)
i

Xi

≤

≤

|

|

D; τ) =

π(X

|

exp(

−

F(X; D)/τ)
ZΩ

,

(4)

where Ω is the volume of the region. Although it looks simple,
it is generally diﬃcult to evaluate π(X
D; τ) for all of the pa-
rameter space when the number of parameters is large (curse of
dimensionality).

|

Instead of a direct calculation of π(X

D; τ) for entire region,
the Markov chain MC (MCMC) method can be used to gen-
erate samples X(t) with a probability proportional to π(X
D; τ).
The MCMC method creates the next conﬁguration X(t+1) by a

|

|

small modiﬁcation of the current conﬁguration X(t). The tem-
perature τ is one of the most important hyper-parameters in
MCMC sampling for the following reason. MCMC sampling
can climb over a hill with a height of τ but cannot easily escape
from a valley deeper than τ. Thus, we should increase the tem-
perature in order to avoid becoming stuck in local minima. On
the other hand, since walkers cannot see valleys smaller than
τ, the precision of the obtained result, Fmin, becomes approxi-
mately τ, and decreasing the temperature is necessary in order
to achieve more precise results. This dilemma indicates that we
should tune the temperature carefully.

−

The replica-exchange MC (REMC) method [13] is an ex-
tended ensemble Monte Carlo method for overcoming this
problem. In the REMC method, K independent systems (repli-
cas) with diﬀerent temperatures τ0, τ1, . . . , τK
1 are prepared,
and the MCMC method is performed in parallel for each
replica. After some updates, K/2 pairs of all the replicas are
created, and exchanging temperatures between replicas in each
pair is attempted. This trial succeeds with some probability ac-
cording to the detailed balance condition. After the eﬃciently
long simulation, samples with the given temperature τi gathered
from all of the replicas follow a temperature-dependent distri-
bution, i.e., π(X
D; τi). In the REMC method, the temperature
of each replica can change, and hence each replica can escape
from local minima.

|

(N1D

is obtained by another analysis method. The grid search is re-
duced to trivial parallel computations and is useful if the total
computational cost is bearable based on the computational re-
sources of the user. The grid search, however, tends to be im-
practical with a large data dimension n = dim(X), since the
grid)n) will be huge, as dis-
number of grid points (Ngrid ∝
cussed, for example, in Section 4.4 of Reference [9]. The BO
method can realize an eﬃcient iterative search to obtain the op-
timal point X(opt) by setting a surrogate model and an initial
dataset generated by a random search. The two MC methods
generally require a large number of sampling points but give a
histogram of the posterior probability density as a unique sta-
tionary state. The posterior probability density is crucial when
the uncertainty is estimated based on the experimental condi-
tions and apparatus, as in Reference [23, 24] for the SXRD ex-
periment.

The diﬀerence between the REMC and PAMC methods ap-
pears in the typical number of parallel (MPI) processes Np. The
REMC method is a parallel computation among various tolera-
i and the typical number of possi-
ble uncertainty parameters
}
102. The PAMC method is
ble parallel processes Np is Np = 10
a parallel computation among diﬀerent replicas at a given value
of the tolerable uncertainty parameter τ = τi and the typical
number of possible parallel processes Np is Np = 103
105 or
more. A practical comparison between the REMC and PAMC
methods is ongoing on supercomputers.

τi
{

−

−

2.5. Population-annealing Monte Carlo method

The population-annealing MC (PAMC) method [14] is an
extension of the simulated annealing (SA) method. The SA
method starts performing the MCMC method at suﬃciently
high temperature and decreases the temperature gradually in
order to search for the minimum of F(X). However,
the
temperature-decreasing process, which suddenly changes the
temperature, distorts the distribution of random walkers from
equilibrium. This is because a burn-in process is needed for
each temperature if the expectation values are wanted. The an-
nealed importance sampling (AIS) method [22] compensates
for this distortion by introducing an extra weight, i.e., the Neal-
Jarzynskii (NJ) weight. The AIS method prepares N indepen-
dent replicas and performs the SA method for these replicas in
parallel. After N series of conﬁgurations are generated, the NJ
weighted average of observables (e.g., F(X) itself) is taken over
all of the samples for each temperature. In the AIS method, the
variance of the NJ weights increases as the simulation proceeds.
This means that the eﬀective number of samples becomes small,
and, as a result, the calculation precision becomes worse. The
PAMC method introduces resampling of replicas according to
their NJ weights in order to reduce the variance of weights. Af-
ter each resampling step, all of the NJ weights are reset to unity.

2.6. Comparison among the analysis methods

Finally, the ﬁve analysis methods are compared from the
viewpoint of the application. The Nelder-Mead method con-
sists of iterative local updates from an initial guess and tends
to converge to a (local) minimum near the initial guess. The
Nelder-Mead method is typically useful when an initial guess

3. Supported experiments and objective functions

This section is devoted to an overview of the supported ex-
periments and problems. 2DMAT is applicable to various ex-
periments and problems by preparing a proper forward prob-
lem solver Dcal(X). The present package supports TRHEPD,
SXRD, and LEED experiments, as explained in Sections 3.1,
3.2, and 3.3, respectively. The present package also supports
several analytic test functions for F(X), and users can deﬁne
a user-deﬁned function F(X), which will be explained in Sec-
tions 3.4 and 3.5.

3.1. Total-reﬂection
(TRHEPD)

high-energy

positron

diﬀraction

is

The

analysis of TRHEPD data

realized, when
sim-threpd-rheed [25–27],
an open-source simulator
written in Fortran, is installed. Total-reﬂection high-energy
positron diﬀraction is a novel experimental probe for two-
dimensional materials and has been actively developed in the
last decade at large-scale experimental facilities at the Slow
Positron Facility (SPF), Institute of Materials Structure Science
(IMSS), High- Energy Accelerator Research Organization
(KEK) [1–3, 28, 29]. Details are provided in review studies
[1–3].

3.2. Surface X-ray diﬀraction

The analysis of SXRD data is realized when sxrdcalc
[30, 31], an open-source simulator written in the C language, is
installed. Surface X-ray diﬀraction has been used for decades

3

for structure analysis experiments involving two-dimensional
materials. Details are provided in review studies [4, 5].
It
is noted that several other SXRD simulators, like ANA-ROD
[32, 33] and CTR-structure [23, 24, 34], are available online.

2DMAT requires one input ﬁle with the TOML format [42] and
reference ﬁles for the forward problem solver, for example, the
experimental data to be ﬁtted. The input ﬁle has the following
six sections1:

3.3. Low-energy electron diﬀraction

The analysis of LEED data is realized by installing SATLEED
[6], a well-known simulator written in Fortran, as the forward
problem solver Dcal(X). Low-energy electron diﬀraction has
been used for decades for structure analysis experiments involv-
ing two-dimensional materials. Details are provided in review
studies [6]. Low-energy electron diﬀraction data was analyzed
by SATLEED in numerous studies such as Ref. [35]. Note that
the LEED simulator is also applicable to low-energy positron
diﬀraction (LEPD) [36, 37], recently developed for structure
determination of two-dimensional materials.

3.4. Analytic test functions

Several well-known analytic test functions, such as the
Rosenbrock function [38], the Ackley function [39], and the
Himmerblau function [40] are also implemented as the objec-
tive function F(X) in order to demonstrate the algorithms in
Section 2. For example, the Himmelblau function is given as

1. The [base] section speciﬁes the basic parameters.
2. The [solver] section speciﬁes the parameters related to

the forward problem solver.

3. The [algorithm] section speciﬁes the parameters related

to the algorithm.

4. The [runner] section speciﬁes the parameters of Runner,

which bridges the Algorithm and the Solver.

5. The [mapping] section deﬁnes the mapping from a pa-
rameter searched by the Algorithm to a parameter used in
the forward problem solver.

6. The [log] section speciﬁes parameters related to logging

of solver calls.

In addition, reference ﬁles such as the target data D to be ﬁtted
and basic input ﬁles for forward problem solver are needed.
After preparing these ﬁles, the optimized parameters Xopt can
be searched for by running 2DMAT.

After ﬁnishing the calculation, 2DMAT outputs the time.log,
which describes the total calculate time, and runner.log,
which contains log information about solver calls. In addition,
output ﬁles for each forward solver and the algorithm are saved.
For details, see the manual for 2DMAT. Below, the installation
and usage of 2DMAT are introduced through a demonstration.

F(x, y) = (x2 + y

11)2 + (x + y2

7)2,

−
and the minimum value of F = 0 appears at (x, y)
(3.00, 2.00), (

3.28), and (3.58,

2.81, 3.13), (

3.78,

−

1.85).

(5)

−

−

−

−

≈

4.1. Install

3.5. User-deﬁned objective functions

Users can implement and analyze any objective function
F(X). For example, in a previous study [41], the REMC algo-
rithm in 2DMAT was used as the performance prediction method
for a massively parallel numerical library for a generalized
eigenvalue problem. This paper shows a method by which to
predict the elapsed time T for the numerical library as a func-
tion of the number of nodes used P (T = T (P)) and focuses
on extrapolation to larger values of P. The teacher dataset is
the set of measured elapsed times for various numbers of nodes
Texp(Pi)
i=1,...,ν. The present paper proposed a model of the
{
}
elapsed time Tcal(P, X) with a parameter set X = (C1, C2, ..Cn).
The objective function to be minimized is the relative error

ν

F(X) =

|

Tcal(Pi, X)

Texp(Pi)

Xi

|

−
Texp(Pi)

2

|

2

|

.

(6)

4. Software

2DMAT is a framework for applying a search algorithm to a
forward problem solver Dcal(X) in order to ﬁnd the optimal so-
lution of F(X), such as determining the optimized atomic posi-
tions. A prototype package of 2DMAT was developed as a private
program [7–9]. We then added several new features to the code
and released 2DMAT as an open-source software framework.
The structure of 2DMAT is shown in Fig. 1.

2DMAT is written in Python and requires Python 3.6.8
Installing 2DMAT requires the python packages
or higher.
tomli [43] and numpy [44].
In addition, as optional pack-
ages, scipy [19], and physbo [21] are required the Nelder-Mead
method, and Bayesian optimization, respectively. If users want
to perform a parallel calculation, mpi4py [18] is also required.
These packages are registered in PyPI, which is a public reposi-
tory of Python software. Since 2DMAT is also registered in PyPI,
users can install 2DMAT simply by typing the following com-
mand:

$ python3 -m pip install py2dmat

The sample ﬁles can be downloaded from the oﬃcial site for
2DMAT. Using git, all ﬁles will be downloaded by typing the
following command:

$ git clone https://github.com/issp-center-dev/2DMAT

Recently, some of authors have developed the MateriApps
Installer[45], a scripting tool that provides a computing envi-
ronment for using various software packages. Users can also
be used to install 2DMAT with setting the necessary libraries.

Note that forward problem solvers used in py2dmat, such
as sim-trhepd-rheed and sxrd, must be installed separately
when users want to use these solvers.
Information on each
solver, available from oﬃcial websites, is in the 2DMAT man-
ual.

1A section, called a ’table’ in TOML, is a set of parameters speciﬁed in the

name = value format.

4

Input

A TOML file
[base] 
[solver]
[algorithm]
[runner]
[mapping]
[log]

Reference files
for forward 
problem solver

2dmat

Algorithm

Nelder-Mead, Grid-search, Bayesian optimization,

Replica-exchange MC, Population-Annealing MC

Dcal(X)

X

Dcal(X)

X

Dcal(X)

X

Forward
problem
solver

Forward
problem
solver

・・・

Forward
problem
solver

D

Output

Text files
time.log
runner.log

Xopt

Output files
for forward 
problem solver

Figure 1: Schematic calculation ﬂow for 2DMAT. The data to be ﬁtted, D, are given by the input ﬁle. When the target quantity X is given, the forward problem
solver calculates the numerical data Dcal(X). Through an analysis algorithm, a candidate solution X is proposed to minimize
Dcal(X)
. When the analysis
|
−
process is ﬁnished, the optimal point Xopt is output. In the MC method, the posterior probability density can be output as a histogram.

D

|

4.2. Usage

Let us introduce the use of 2DMAT through a sample demon-
stration. The input ﬁle for this sample, input.toml, is lo-
cated in the sample/analytical/bayes directory and shown
as follows:

[base]
dimension = 2
output_dir = "output"

[algorithm]
name = "bayes"
seed = 12345

[algorithm.param]
max_list = [6.0, 6.0]
min_list = [-6.0, -6.0]
num_list = [61, 61]

[algorithm.bayes]
random_max_num_probes = 20
bayes_max_num_probes = 40

[solver]
name = "analytical"
function_name = "himmelblau"

In the [base] section, the dimension of parameters to be
optimized and the output directory are speciﬁed by variables
dimension and output_dir, which are set as 2 and output,
the search al-
In the [algorithm] section,
respectively.
gorithm and the seed of the random number generator are
speciﬁed by parameters names and seed, which are set as

5

6, 6], [

In the param subsection,

"bayes" and 12, 345, respectively. There are subsections
depending on the search algorithm.
In the case of select-
ing the algorithm "bayes", there are param and bayes sub-
sections.
the search region can
be speciﬁed by setting the maximum and minimum values,
max_list and min_list, and the speciﬁed space is equally
divided by the parameter num_list.
In this example, the
6, 6] for the 61 divided pa-
two-dimensional space [
−
In the bayes subsection, the number
rameters is searched.
of random samplings to be taken before Bayesian optimiza-
tion random_max_num_probes and the number of steps to
perform Bayesian optimization bayes_max_num_probes are
speciﬁed. The default score function (acquisition function) is
set as Thomson sampling. If the user wants to use expected im-
provement (EI) or probability of improvement (PI) as the score,
then the parameter score is available (e.g., score = "EI").
In the [solver] section, the forward problem solver is spec-
iﬁed as the himmelblau function, Eq. (5), as deﬁned in the
analytical solver using name and function_name.

−

After preparing the input ﬁle, the calculation will be per-
formed in two ways. The ﬁrst is the py2dmat command, which
is installed via pip install. Here, py2dmat takes one argu-
ment, the name of the input ﬁle, as follows:

$ py2dmat input.toml

The second is to use the python script py2dmat_main.py,
which is located in the src directory. The command for ex-
ecution is given as follows (here, we assume that the current
directory is sample/analytical/bayes):

$ python3 ../../../src/py2dmat_main.py input.toml

The only diﬀerence between these methods is which python
package will be used. The former uses the installed python

package, and the latter uses the source ﬁles located in
src/py2dmat. After ﬁnishing the calculation, the following
ﬁles are output to the output directory. In BayesData.txt,
step i, the best parameter Xbest, and F(Xbest), as well as the ac-
tion Xi, and F(Xi) at the i-th step are output as shown below.

#step x1 x2 fx x1_action x2_action fx_action
0 -2.4 -0.7999999999999998 ...
1 -2.4 -0.7999999999999998 ...
...
57 3.6000000000000014 -1.7999999999999998 ...
58 3.6000000000000014 -1.7999999999999998 ...
59 3.6000000000000014 -1.7999999999999998 ...

In this case, we can see that the optimal parameter at step 60
is (3.6,
1.85), one of the exact minimum
points of F(X) deﬁned in Eq. (5).

1.8) around (3.58,

−

−

We can easily apply another algorithm to solving the same in-
verse problem by editing [algorithm] section in the input ﬁle.
For example, PAMC method can be applied when we change
the [algorithm] section in the input ﬁle as follows:

[algorithm]
name = "pamc"
seed = 12345

[algorithm.param]
max_list = [6.0, 6.0]
min_list = [-6.0, -6.0]
unit_list = [0.05, 0.05]

[algorithm.pamc]
bmin = 0.0
bmax = 10.0
Tnum = 20
Tlogspace = false
numsteps_annealing = 20
nreplica_per_proc = 130
resampling_interval = 4

In this case, the number of replicas was set to Nreplica = 3, 120,
and the number of annealing steps or the number of temperature
values was set to K = 20. The initial and ﬁnal temperatures
1
1
0 = 0 and τ−
1 = 10, respectively. The intermediate
were τ−
K
−
2 were prepared to discretize [τ−
τ j
temperatures
1]
i=1,..,K
}
{
−
uniformly, i.e.,

1
1
0 , τ−
K

−

j

.

(7)

1
j = τ−
τ−

1
1
0 + (τ−
K

1
τ−
0 )

−

1

−

×

K

N(tmp)
MCMC = 20

1 −
At each temperature (τ = τ j), N(tmp)
MCMC=20 MCMC steps were
carried out. The total number of MCMC steps for each replica
20 = 400. The resampling process
was K
occurred every four annealing steps. Figure 2 shows the resul-
tant histogram of the probability density at (a) τ−
0.53
1
19 = 10. The histograms in Figures 2(a) and
and (b) τ−
2(b) were drawn with a bin width of hbin = 0.1. Figure 2(b)
conﬁrms that the PAMC analysis detects the four global min-
ima correctly. For details of the algorithms and their parameter
settings, please refer to the 2DMAT oﬃcial manual.

1 = τ−

1
1 ≈

1 = τ−

×

Figure 2: Population-annealing Monte Carlo (PAMC) analysis of Himmelblau
function. Histograms of probability density π(x, y; τ) are shown at (a) τ−
0.53 and (b) τ−

10. The contour of F is also plotted as a guide for the eye.

≈

1

1

≈

4.3. User-deﬁned objective function

The simplest way to deﬁne a user-deﬁned objective func-
tion F(X) is to add the function to the analytical solver,
which is for the benchmark test. This solver is deﬁned in
the src/py2dmat/solver/analytical.py ﬁle, and hence a
new problem can be added simply by editing this ﬁle. When
adding the function, the function can be analyzed by invoking
the src/py2dmat main.py script.

Another way is to use the function solver, which can reg-
ister a python function as F(X). The following simple script
(sample/user_function/simple.py) shows an example for
a grid search of a user-deﬁned objective function F(X) =

N
i X2

i /N:

P

1 import numpy as np
2 import py2dmat
3 import py2dmat . util . toml
4 import py2dmat . algorithm . mapper_mpi as pm_alg
5 import py2dmat . solver . function
6

6

2) surface structure. The z coordinates
Figure 3: Side view of the Ge(001)-c(4
×
of the ﬁrst, second, third, fourth and ﬁfth surface layers are denoted as z1, z2,
z3, z4 and z5, respectively.

return np . mean ( x * x )

7 def m y _ o b j e c t i v e _ f n ( x : np . ndarray ) -> float :
8
9
10 file_name = " input . toml "
11 inp = py2dmat . util . toml . load ( file_name )
12 info = py2dmat . Info ( inp )
13 solver = py2dmat . solver . function . Solver ( info )
14 solver . s e t _ f u n c t i o n ( m y _ o b j e c t i v e _ f n )
15 runner = py2dmat . Runner ( solver , info )
16 alg = pm_alg . Algorithm ( info , runner )
17 alg . main ()

line 14, solver.set function registers a function
At
my objective fn as the objective function. In this way, the
original source code of Py2dmat does not need to be edited.

5. Examples of TRHEPD data analysis

5.1. Analysis of artiﬁcial TRHEPD data

|

×

In this subsection, all of the analysis algorithms in Section
2, except for the PAMC algorithm, are demonstrated with an
example of the artiﬁcial generated TRHEPD data. The applica-
tion of the PAMC method is skipped in this section, because the
PAMC and REMC methods calculate, commonly, the posterior
probability density π(X
D; τi), and the resultant ﬁgures for the
PAMC method are almost the same as for the REMC method.
The present example for the TRHEPD experiment is the
2) surface, a famous semiconductor surface.
Ge(001)-c(4
Hereinafter, the z axis is deﬁned as being normal to the material
surface. Figure 3 shows a side view of the surface structure.
The horizontal view is found, for example, in Fig. 3(b) of Ref-
erence [8]. The ﬁrst and second surface atoms are denoted by
S1 and S2, respectively, and form an asymmetric dimer. The
third surface atoms are denoted by S3a and S3b. The fourth sur-
face atoms are denoted by S4a and S4b. The ﬁfth surface atom
is denoted by S5. The z coordinates of the ﬁrst layer (S1), the
second layer (S2), the third layer (S3a and S3b), the fourth layer
(S4a and S4b) and the ﬁfth layer (S5) are denoted as z1, z2, z3, z4
and z5, respectively.

7

Figure 4: Nelder-Mead analysis of TRHEPD experiment for Ge(001)-c(4
surface. (a) The objective function F = F(z(k)
from the initial values δz(k)
the iteration step k(= 0, 1, 2...).

2)
3 ) and (b) the deviations
(i = 1, 2, 3) are plotted as functions of

i = z(k)

1 , z(k)

2 , z(k)

i −

z(0)
i

×

The experimental data are set to be those for the one-beam
condition[2, 46], the experimental condition for the determina-
tion of the z coordinates of the atom positions. The present anal-
ysis was carried out with artiﬁcial reference data, instead of real
experimental data, as in the previous paper [8]. The reference
data were generated by a simulation with reference positions of
(z1, z2, z3) = (z(ref)
(5.231Å, 4.371Å, 3.596Å) [8,
47].

, z(ref)
2

, z(ref)
3

≈

)

1

The objective function is expressed as F = F(z1, z2, z3).
When the values of z1 and z2 are replaced with each other,
the objective function F(z1, z2, z3) is unchanged (F(z2, z1, z3) =
F(z1, z2, z3)), owing to the symmetry of the structure. There-
fore, we do not lose generality by assuming the constraint
z1 ≥
5.1.1. Nelder-Mead analysis

z2.

×

1 , z(0)

2 , z(0)
3 )

The Nelder-Mead method was applied to the analysis of the
2) surface in a previous study [8], in which the

Ge(001)-c(4
initial values were chosen to be (z1, z2, z3) = (z(0)
≡
(5.25Å, 4.25Å, 3.50Å). Figure 4(a) shows that the objective
function F decreases monotonically through the iterative op-
timization steps k(= 0, 1, 2, . . . ) and reaches the convergence
point (z1, z2, z3) = (z(ref)
) after k = 61 iterative
steps. Figure 4(b) shows the deviations from the initial val-
ues δz(k)
(i = 1, 2, 3) as functions of the iteration
i −
δz(k)
step k. It can be seen that δz(k)
0.15Å) for the
i
i
converged structure. The ﬁles for the calculation are stored in
the sample/py2dmat/minsearch/ directory.

i = z(k)

is small (

, z(ref)
2

, z(ref)
3

z(0)
i

| ≤

1

|

Objective function at search points F(z( j)
2 ) with j =
Figure 6:
0, 1, 2, . . . , 549 in Bayesian optimization (BO) analysis of TRHEPD data for
Ge(001)-c(4

2) surface.

1 , z( j)

×

Figure 5(a) plots the contour of F using the grid search data
and indicates that the objective function F(z1, z2) has many lo-
cal minima. Figure 5(b) picks out the grid points that satisfy
the condition F < 0.02, because these points are candidate so-
lutions in practical data analysis [2, 9]. Three local regions that
z2
contain (local) minima are found within the condition z1 ≥
and are denoted as α, β, and γ. The region α contains the grid
minimum point (z1, z2) = (5.25Å, 4.4Å) with F
0.003, while
the regions β and γ contain local minima with 0.01 < F < 0.02.
Note that the three regions, α, β, and γ, are almost linearly
distributed and satisfy the relation (z1 −
(constant), which
is a common property of TRHEPD. Similar results have also
been obtained for the Si4O5N3 / 6H-SiC(0001)-( √3
√3) R30◦
surface, as shown in Fig. 3(a) of Reference [9]. This stems from
the fact that the interaction of positron waves scattered from the
ﬁrst and second atomic layers contributes signiﬁcantly to the
diﬀraction signal, and the objective function F(z1, z2) is quite
sensitive to the distance between the ﬁrst and second atomic
layers (z1 −
5.1.3. Bayesian optimization analysis

z2) [9].

z2)

×

≈

≈

The BO analysis was carried out using a similar grid to that
in Section 5.1.2, but the grid points were prepared only under
z2. Thus, the total number of grid points is
the constraint z1 ≥
Ngrid,BO = (N(1D)
grid + 1)/2 = 141

grid )(N(1D)

Figure 6 plots the objective function F(z( j)

2 ) as a func-
tion of the search point index j = 0, 1, 2, . . . , 549. The initial
nrand = 50 search points ( j = 0, . . . , 49) were generated using
a random search. Then, the search points with j = 50, 51, . . .
were generated iteratively using the BO algorithm. Figure 6
indicates that the grid minimum point F(z1=5.25 Å, z2=4.4

142/2 = 10, 011.
1 , z( j)

×

2)
Figure 5: Grid-search analysis of TRHEPD experiment for Ge(001)-c(4
(a) Contour plot of the objective function F(z1, z2) using the grid-
surface.
F. (b) Objective function F(z1, z2)
search data. The isovalues are shown as 100
on the selected grid data that satisfy F < 0.005 (circles), 0.005 < F < 0.010
(squares), 0.010 < F < 0.015 (triangles), and 0.015 < F < 0.020 (crosses).

×

×

5.1.2. Grid-search analysis

A grid search was applied to the analysis of the Ge(001)-
2) surface in a previous study [8], in which the grid points

c(4
were on a (z1, z2, z3) space with a grid interval of h = 0.25 Å.

×

≤

z1, z2 ≤

. The grid range is Lmin ≡

Figure 5 shows the results of the grid search on a (z1, z2)
space with a grid interval of h = 0.05 Å, where z3 is ﬁxed at z3 =
z(ref)
Lmax ≡
9Å, and the
2Å
3
number of the grid points on the z1 or z2 axis is N(1D)
grid = (Lmax −
Lmin)/h + 1 = 141. The total number of grid points is Ngrid =
(N(1D)
grid )2 = 1412 = 19, 881. As a result, the grid minimum
points are obtained (z1, z2) = (5.25Å, 4.4Å), (4.4Å, 5.25Å) that
give the minimum value of F = 0.003. The grid minimum
point (z1, z2) = (5.25Å, 4.4Å) is close to the true minimum point
(z(ref)
(5.231Å, 4.371Å). To obtain a ﬁner solution than
1
the grid minimum point, the Nelder-Mead method, in which
the initial point is chosen to be the grid minimum point, can be
used.

, z(ref)
2

≈

)

8

Å)=0.003 appears at
j=127. The number of search points
nopt = 127 is much smaller than the total number of grid points
Ngrid,BO), which shows the eﬃciency
Ngrid,BO = 10, 011 (nopt ≪
of the BO method.

Figure 7 shows the search points (z( j)

2 ) that appear in the
BO analysis with (a) j
49, (b) j
549.
Figure 7 indicates that the search points cover the region β at
ﬁrst, as seen in Figure 7(b), and then cover the regions α and γ
later, as shown in Fig. 7(c).

1 , z( j)
≤

127, and (c) j

≤

≤

5.1.4. Replica-exchange Monte Carlo analysis

Figure 8 shows the results of the REMC method. In this ex-
ample, we used K = 36 replicas and prepared datasets for tem-
1 as follows. The maximum and minimum
perature
−
1 = 0.001, respectively,
temperatures were τ0 = 0.1 and τK
and the other values
2 were prepared to discretize
[τ0, τK

τ j
{
1] uniformly on a log scale, i.e.,

τ j
{

j=0,..,K

j=1,..,K

}

}

−

−

−

τ j = τ0 ×  

j

K

1
−

.

τK
1
−
τ0 !

(8)

The total number of MCMC steps was NMCMC = 50,000 for
each replica. The temperature-exchange process occurred ev-
ery 50 MCMC steps. Figure 8 shows the posterior distribu-
D; τ), as histograms, at (a) τ = τ0 = 0.1, (b)
tions π(z1, z2|
0.0029 and (c) τ = τ35 = 0.001. The histograms were
τ = τ27 ≈
constructed without the ‘burn-in’ data at the early NMCMC/2
MCMC steps and were drawn with a bin size of hbin =0.05 Å.
The histogram in Fig. 8(b) indicates that the objective function
has two minima. In Figs. 8(b) and 8(c), the histogram can be
D; τ) owing
conﬁrmed to be symmetric π(z1, z2|
to the symmetry of the objective function (F(z1, z2) = F(z2, z1)).

π(z2, z1|

D; τ)

≈

5.2. Analysis of experimental TRHEPD data

The present subsection is devoted to the analysis of the ex-
perimental TRHEPD data. Several studies for other materials
are ongoing.

5.2.1. Ge(001)-c(4

2) surface

×

×

×

×

10

Very recently, one of the authors (I. M.) carried out the
TRHEPD experiment for Ge(001)-c(4
2) surface. The sam-
ple preparation and the measurement condition are explained
0.5 mm3) was
as follows. The sample substrate (5
cut from a mirror-polished Ge(001) wafer. The surface was
5 ×
cleaned by a few cycles of 0.5 keV Ar+ sputtering (
4 Pa, 673 K, 15 min) followed by annealing (853 K, 10
10−
min) in a TRHEPD measurement chamber [9, 28, 29], after
which cleanliness and well-ordered periodicity of the surface
were conﬁrmed by reﬂection high-energy electron diﬀraction
patterns. The TRHEPD experiment was performed using a
positron beam of 10 keV. The incident azimuth was set at 22.5◦
oﬀ the [1¯10] direction (i.e., the one-beam condition [2, 46]).
The glancing angle was varied from 0.5◦ to 6.5◦.

∼

The experimental data was analyzed by the Nelder-Mead
method using 2DMAT . The iterative procedure was performed
for the ﬁve variables
i=1,5 in Fig. 3, until the objective
}
function F = F(z1, z2, z3, z4, z5) converges within the criteria

zi
{

9

×

10−

10−

10−

4 , z(k)

2 , z(k)

1 , z(k)

3 , z(k)

4. The initial structure was set to be the one
∆F = 5
determined by LEED experiment [47]. Figure 9(a) shows the
objective function F(k) = F(z(k)
5 ) as the func-
tion of the iterative step k(= 0, 1, ..., 24). As a result, the ob-
jective function F(k) decreases from F(0) = 1.96
2 at the
×
initial structure into F(24) = 1.40
2 at the converged struc-
×
ture. Figure 9(b) shows the deviation of the variables
i=1,5
}
i = z(k)
from the initial values δz(k)
as the function of the
iteration step k. Here one ﬁnds that the diﬀerence between the
initial and ﬁnal structures was approximately 0.15 Å or less.
In other words, the structures determined by the TRHEPD and
LEED experiments agree with a small (0.1Å-scale) diﬀerence.
Figure 10 shows the calculated rocking curves in the initial and
converged structures, together with the experimental data. The
calculated rocking curves in the converged structure agrees with
the experimental data better than that of the initial structure.

i −

z(0)
i

zi
{

It

is noted that, among existing TRHEPD researches
(Refs. [2, 9] and references therein), a structure is accepted
as a ﬁnal solution, when the objective function value is less
than 0.02 (F
0.02). The present result demonstrates that the
TRHEPD diﬀraction data is sensitive to a small (0.1Å-scale)
diﬀerence in the coordinates.

≤

×

5.2.2. Si4O5N3 / 6H-SiC(0001)-( √3

√3) R30◦ surface

×

A previous paper [9] reports that 2DMAT was used in the data
analysis of TRHEPD experiment for Si4O5N3 / 6H-SiC(0001)-
( √3
√3) R30◦ surface, a novel two-dimensional semiconduc-
tor. The trial atomic positions were optimized by the Nelder-
Mead method, in which the value of the objective function de-
2. In addition,
creases from F = 2.28
a grid search was carried out for a local region near the opti-
mized position, so as to investigate the properties of the objec-
tive function in the local region.

2 into F = 0.91

10−

10−

×

×

6. Summary and future utilities

A general-purpose open-source software framework 2DMAT
has been developed for analysis of experimental data using an
inverse problem approach. The framework provides ﬁve analy-
sis algorithms: the Nelder-Mead optimization, the grid search,
the Bayesian optimization, the replica-exchange Monte Carlo,
and the population-annealing Monte Carlo methods. Thus,
users can choose an appropriate analysis method according to
the purpose and can construct a multi-stage scheme, in which
a single method is carried out ﬁrst, and then other methods are
performed. The current version of 2DMAT supports analysis of
several experiments; TRHEPD, SXRD, and LEED data by of-
fering adapters for the external software packages for simulat-
ing these experiments. 2DMAT is designed to deﬁne the objective
function by users. Thus, by adding the appropriate objective
function, many experimental measurements can be analyzed us-
ing 2DMAT.

Finally, we comment on the future utilities of 2DMAT. Sev-
eral application studies beyond those in this paper are ongo-
ing and several types of the studies are picked out below: The
ﬁrst type of the ongoing studies is the the analysis of the ex-
perimental data of SXRD and LEED. In particular, 2DMATwill

[11] M. Wright, in Numerical analysis, edited by D. Griﬃths and G. Watson

(Addison-Wesley, 1996), pp. 191–208.

[12] C. E. Rasmussen and C. K. I. Williams, Gaussian Processes for Ma-
chine Learning (Adaptive Computation and Machine Learning) (The MIT
Press, 2005), ISBN 026218253X.

[13] K. Hukushima and K. Nemoto, J. Phys. Soc. Jpn. 65, 1604 (1996).
[14] K. Hukushima and Y. Iba, AIP Conf. Proc. 690, 1604 (2003).
[15] L. Dalc´ın, R. Paz, and M. Storti, J. Parallel Distrib. Comput. 65, 1108

(2005).

[16] L. Dalc´ın, R. Paz, M. Storti, and J. D’El´ıa, J. Parallel Distrib. Comput.

68, 655 (2008).

[17] L. D. Dalcin, R. R. Paz, P. A. Kler, and A. Cosimo, Adv. Water Resour.

34, 1124 (2011).

[18] L. Dalcin and Y.-L. L. Fang, Comput. Sci. Eng. 23, 47 (2021).
[19] scipy, https://scipy.org/.
[20] PHYSBO, https://www.pasums.issp.u-tokyo.ac.jp/physbo/.
[21] Y. Motoyama, R. Tamura, K. Yoshimi, K. Terayama, T. Ueno, and

K. Tsuda, Comp. Phys. Commun. 278, 108405 (2022).

[22] R. M. Neal, Stat. Comput. 11, 125 (2001).
[23] M. Anada, Y. Nakanishi-Ohno, M. Okada, T. Kimura, and Y. Wak-

abayashi, J. Appl. Cryst. 50, 1611 (2017).

[24] K. Nagai, M. Anada, Y. Nakanishi-Ohno, M. Okada, and Y. Wakabayashi,

J. Appl. Cryst. 53, 387 (2020).

[25] sim-trhepd-rheed, https://github.com/sim-trhepd-rheed/.
[26] T. Hanada, H. Daimon, and S. Ino, Phys. Rev. B 51, 13320 (1995).
[27] T. Hanada, Y. Motoyama, K. Yoshimi, and T. Hoshi, Comp. Phys. Com-

mun. 277, 108371 (2022).

[28] I. Mochizuki, H. Ariga, Y. Fukaya, K. Wada, M. Maekawa, A. Kawasuso,
T. Shidara, K. Asakura, and T. Hyodo, Phys. Chem. Chem. Phys. 18, 7085
(2016).

[29] Y. Endo, Y. Fukaya,

I. Mochizuki, A. Takayama, T. Hyodo, and

S. Hasegawa, Carbon 157, 857 (2020).
[30] sxrdcalc, https://github.com/sxrdcalc/.
[31] W. Voegeli, K. Akimoto, T. Aoyama, K. Sumitani, S. Nakatani, H. Tajiri,
T. Takahashi, Y. Hisada, S. Mukainakano, X. Zhang, et al., Appl. Surf.
Sci. 252, 5259 (2006).

[32] ANA-ROD, https://www.esrf.fr/computing/scientiﬁc/joint projects/ANA-

ROD.

[33] E. Vlieg, J. Appl. Cryst. 33, 401 (2000).
[34] CTR-structure, https://github.com/yusuke-wakabayashi/CTR-structure.
[35] T. Hirahara, S. Eremeev, T. Shirasawa, O. Yuma, T. Kubo, R. Nakanishi,
R. Akiyama, A. Takayama, T. Hajiri, S. Ideta, et al., Nano Lett. 17, 3493
(2017).

[36] S. Y. Tong, Surf. Sci. 457, L432 (2000), ISSN 0039-6028.
[37] K. Wada, T. Shirasawa, I. Mochizuki, M. Fujinami, M. Maekawa,
A. Kawasuso, T. Takahashi, and T.Hyodo, e-J. Surf. Sci. Nanotechnol.
16, 313 (2018).

[38] H. H. Rosenbrock, Comput. J. 3, 175 (1960).
[39] D. H. Ackley, A connectionist machine for genetic hillclimbing (Kluwer

Academic Publishers, Boston, 1987).

[40] D. Himmelblau, Applied Nonlinear Programming (McGraw-Hill, 1972).
[41] H. Kohashi, H. Iwamoto, T. Fukaya, Y. Yamamoto, and T. Hoshi, JSIAM

Letters 14, 13 (2022).
[42] TOML, https://toml.io/en/.
[43] tomli, https://pypi.org/project/tomli/.
[44] numpy, https://numpy.org/.
[45] Y. Motoyama, K. Yoshimi, T. Kato, and S. Todo (2022), URL

https://arxiv.org/abs/2205.01991.
[46] A. Ichimiya, Surf. Sci. Lett. 192, L893 (1987).
[47] T. Shirasawa, S. Mizuno, and H. Tochihara, Surf. Sci. 600, 815 (2006).
[48] Quantum Espresso, https://www.quantum-espresso.org.

enable us a fruitful analysis, when we perform multiple types
of the diﬀraction experiments on a specimen and analyze the
results seamlessly. The second type of the ongoing studies is
the prediction of material properties, which is realized by ab
initio calculations with the determined atomic positions. For
this purpose, some of the present authors developed a tool that
converts the atomic position data ﬁle used in TRHEPD analysis
into the ﬁle of Quantum Espresso, a famous ab initio software
package [25, 27, 48]. The third type of the ongoing studies
is application to other problems beyond 2D materials, where
we construct a user-deﬁned problem, as explained in Sec. 3.5.
With these features and possible future utilities, we expect that
2DMAT becomes a useful data-analysis framework in material
science and other scientiﬁc ﬁelds.

Acknowledgement

We would like to acknowledge support for code develop-
ment from the “Project for advancement of software usability
in materials science (PASUMS)” by the Institute for Solid State
Physics, University of Tokyo. The present research was sup-
ported in part by a Grant-in-Aid for Scientiﬁc Research (KAK-
ENHI) from the Japan Society for the Promotion of Science
(19H04125, 20H00581). 2DMAT was developed using the fol-
lowing supercomputers: the Ohtaka supercomputer at the Su-
percomputer Center, Institute for Solid State Physics, Univer-
sity of Tokyo; the Fugaku supercomputer through the HPCI
projects (hp210083, hp210267); the Oakforest-PACS super-
computer as part of the Interdisciplinary Computational Sci-
ence Program in the Center for Computational Sciences, Uni-
versity of Tsukuba; the Wisteria-Odyssey supercomputer at the
Information Technology Center, University of Tokyo; and the
Laurel2 supercomputer at the Academic Center for Computing
and Media Studies, Kyoto University. The present research was
also supported in part by JHPCN project (jh210044-NAH). We
would like to acknowledge Takashi Hanada, Wolfgang Voegeli,
Tetsuroh Shirasawa, Rezwan Ahmed, and Ken Wada for fruit-
ful discussions on the diﬀraction experiments, and Daishiro
Sakata, Koji Hukushima, Taisuke Ozaki, and Osamu Sugino
for fruitful discussions on the code.

References

[1] C. Hugenschmidt, Surf. Sci. Rep. 71, 547 (2016).
[2] Y. Fukaya, A. Kawasuso, A. Ichimiya, and T. Hyodo, J. Phys. D 52,

013002 (2019).

[3] Y. Fukaya, in Monatomic Two-Dimensional Layers, edited by I. Matsuda

(Elsevier, 2019), Micro and Nano Technologies, pp. 75 – 111.

[4] R. Feidenhans’l, Surf. Sci. Rep. 10, 105 (1989).
[5] H. Tajiri, Jpn. J. Appl. Phys. 59, 020503 (2020).
[6] M. A. V. Hove, W. Moritz, H. Over, P. Rous, A. Wander, A. Barbieri,
N. Materser, U. Starke, and G. A. Somorjai, Surf. Sci. Rep. 19, 191
(1993).

[7] K. Tanaka, T. Hoshi, I. Mochizuki, T. Hanada, A. Ichimiya, and T. Hyodo,

Acta. Phys. Pol. A 137, 188 (2020).

[8] K. Tanaka, I. Mochizuki, T. Hanada, A. Ichimiya, T. Hyodo, and T. Hoshi,
JJAP Conf. Series, in press; Preprint:https://arxiv.org/abs/2002.12165/.
[9] T. Hoshi, D. Sakata, S. Oie, I. Mochizuki, S. Tanaka, T. Hyodo, and

K. Hukushima, Comp. Phys. Commun. 271, 108186 (2022).

[10] J. A. Nelder and R. Mead, Comput J 7, 308 (1965).

10

1 , z( j)
(z( j)
2 )
}

Search points

j in BO analysis of TRHEPD data for
Figure 7:
2) surface with (a) j = 0, . . . , 49, (b) j = 0, . . . , 127, and (c)
Ge(001)-c(4
j = 0, . . . , 449. The grid minimum point (z1, z2) = (5.25Å, 4.4Å) is indicated
by a ﬁlled circle, and the other search points are indicated by crosses. The
contour of F is also plotted as a guide for the eye.

×

{

Figure 8: Replica exchange Monte Carlo (REMC) analysis of TRHEPD data
2) surface. The histograms of the posterior probability density
for Ge(001)-c(4
D; τ) are drawn for temperature parameters of (a) τ = 0.0029 and (b)
π(z1, z2
τ = 0.001. The contour of F is also plotted as a guide for the eye.

×

|

11

(a)

0.020

F
e
u
a
v

l

n
o
i
t
c
n
u
f

e
v
i
t
c
e
b
O

j

(b)

)

Å

(

e
u
a
v

l

l

a
i
t
i
n

i

e
h
t

m
o
r
f

0.019

0.018

0.017

0.016

0.015

0.014

0.2

0.1

0

-0.1

0

5

15
10
Iteration step k

20

25

t
n
e
m
e
c
a
p
s
D

l

i

-0.2

0

5

10

15

Iteration step k

20

25

Figure 9: Nelder-Mead optimization analysis of the experimental TRHEPD
(a) The objective function F =
data for Ge(001)-c(4
1 , z(k)
F(z(k)
4 , z(k)
2 , z(k)
i =
z(k)
z(0)
(i = 1, 2, 5) are plotted as functions of the iteration step k(= 0, 1, 2...).
i
i −

5 ) and (b) the deviations from the initial values δz(k)

2) surface.

3 , z(k)

×

)
t
i
n
u
.

b
r
a

(

experiment
initial
converged

y
t
i
c
n
e
t
n

i

t
o
p
s
0
0

glancing angle (degree)

Figure 10: Comparison between the experimental rocking curve (open circles),
the calculated ones for the initial (dashed line) and converged (solid line) struc-
tures in the Nelder-Mead optimization analysis of the experimental TRHEPD
data for Ge(001)-c(4

2) surface.

×

12

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
