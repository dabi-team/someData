2
2
0
2

l
u
J

3
2

]
T
A
.
h
t
a
m

[

1
v
1
9
5
1
1
.
7
0
2
2
:
v
i
X
r
a

The discriminating power of the generalized rank
invariant

Nathaniel Clause1, Woojin Kim2, and Facundo Mémoli1

1The Ohio State University, Columbus OH ∗ †
2Duke University, Durham NC ‡

July 26, 2022

Abstract

It is a well-known fact that there is no complete and discrete invariant on the
collection of all multiparameter persistence modules. Nonetheless, many invariants
have been proposed in the literature to study multiparameter persistence modules,
though each invariant will lose some amount of information. One such invariant is
the generalized rank invariant. This invariant is known to be complete on the class
of interval decomposable persistence modules in general, under mild assumptions on
the indexing poset P .

There is often a trade-oﬀ, where the stronger an invariant is, the more expensive
it is to compute in practice. The generalized rank invariant on its own is diﬃcult to
compute, whereas the standard rank invariant is readily computable through software
implementations such as RIVET. We can interpolate between these two to induce
new invariants via restricting the domain of the generalized rank invariant, and this
family exhibits the aforementioned trade-oﬀ. This work studies the tension which
exists between computational eﬃciency and retaining strength when restricting the
domain of the generalized rank invariant. We provide a characterization result on
where such restrictions are complete invariants in the setting where P is ﬁnite, and
furthermore show that such restricted generalized rank invariants are stable.

1 Introduction

A central tool in topological data analysis (TDA) is persistent homology [8, 17], wherein
the homology functor is applied to a ﬁltration - an increasing family of simplicial complexes
- on a dataset. The resulting object is called a persistence module. For this paper, by a
persistence module we mean a functor M : P → vec from the poset P (viewed as a category
P), to vec, the category of ﬁnite dimensional vector spaces and linear maps between
them. We call such an M a P -module, and say that M is indexed over P . Properties of
these persistence modules give us insight into the shape of the underlying dataset: giving

∗memoli@math.osu.edu
†clause.15@osu.edu
‡woojin@math.duke.edu

1

 
 
 
 
 
 
information on connectivity, holes, and voids in the data. When the ﬁltration has one-
parameter, i.e.
is indexed over some subset of R, the resulting persistence module has a
direct sum decomposition into interval modules [13]. The collection of supports of those
interval modules is a complete and discrete invariant of the persistence module, called a
persistence diagram or a barcode [18, 31].

One-parameter persistent homology can be sensitive to addition of outlier points in the
original dataset. One way to deal with this is to use multiple parameters when building
the ﬁltration, such as a combining a scale parameter with a density parameter. Applying
persistent homology then yields a multiparameter persistence module, as discussed by
Carlsson and Zomorodian in [10].
In this paper, the authors showed that a complete,
discrete invariant for all multiparameter persistence modules does not exist as with the
persistence diagram in the one parameter setting. Also, quiver representation theory tells
us that there is no simple invariant that completely encodes the isomorphism type of
multiparameter persistence modules [19].
In particular, it does not always hold that a
multiparameter persistence module decomposes into a direct sum of interval modules.

In absence of such an invariant, many non-complete invariants have been proposed for
converting multiparameter persistence modules into simpler and easier to study objects.
The ﬁrst, proposed by Carlsson and Zomorodian in their introductory paper, is called the
rank invariant, which captures the rank of all linear maps present in a persistence module.
Patel noted that persistent diagrams in the one-parameter setting can equivalently be
deﬁned in the one parameter setting as the Möbius inversion of the rank function. Patel
used the idea of Möbius inversion to deﬁne a generalized persistence diagram in the setting
where the image of a persistence module is in a more general category than vector spaces
[29]. Patel and McCleary proved stability for such generalized persistence diagrams with
respect to a bottleneck distance [27]. They later deﬁned a notion of generalized persistence
diagrams indexed over a lattice, and showed a stability result with respect to an edit
distance [28].

Kim and Mémoli [21] further broadened the notion of generalized persistence diagram,
by deﬁning them for persistence modules indexed over a broad class of partially ordered
sets meeting mild conditions. They do so by ﬁrst deﬁning the generalized rank invariant
of a module on a poset P , and taking the Möbius inversion of this function. In this work,
they showed that the generalized persistence diagram is a complete invariant on the class
of interval-decomposable persistence modules over a ﬁxed P . By uniqueness of Möbius
inversion, this implies the generalized rank invariant is a complete invariant on this class
as well.

The authors also demonstrated that the generalized rank invariant is stable with respect
to a notion of erosion distance, ﬁrst introduced by Patel [29], when the indexing set for
the persistence module is Zd or Rd. Stability is an important property of invariants, which
guarantee that a small change, in some sense, to the input object results in a proportionally
small change in the invariants’ output. In data analysis this is an important property as
much real world data contains noise, and we want an invariant to capture key features of
the dataset and not features stemming from the noise.

The information from the generalized rank invariant encompasses that of the rank in-
variant, and hence all invariants which are derived from the rank invariant. Kim and Moore
[22] recently found a combinatorial formula for extracting the bigraded Betti numbers of a
2-parameter persistence module via the Möbius inversion of the generalized rank invariant.

2

1.1 Related Work

Much study of multiparameter persistence modules has revolved around certain classes of
persistence modules which decompose in a nice way, and invariants which are complete
If a persistence module does decompose into a direct
when restricted to these classes.
sum of interval modules, then one can deﬁne the persistence diagram as the multiset
of interval summands as in the one parameter case. Asashiba et al.
[1] developed a
criterion for determining if an n-parameter persistence module is interval decomposable,
In [2],
as well as providing an algorithm to check this criterion in the n = 2 setting.
Ashashiba et al. provide an approach to approximate a 2-parameter persistence module
by an interval decomposable module, with the approximation retaining the same dimension
function and rank function. Given a 2-parameter persistence module M , their notion of
interval decomposable approximation δtot(M ) is equivalent to the generalized rank invariant
on the collection of all intervals (Deﬁnition 2.7).

Cochoy and Oudot considered the restricted class of so-called block-decomposable 2-
parameter persistence modules [12]. They showed a local condition, which they named ex-
actness, can determine whether a 2-parameter persistence module is block-decomposable.
In [5], Botnan et al.
showed that a weaker local condition, which they named weak-
exactness, determines whether a 2-parameter persistence module is rectangle-decomposable.
They also showed that the classical rank invariant is complete when restricting to rectangle
decomposable 2-parameter persistence modules.

Botnan et al.

introduced the notion of rank decomposition in [6]. In this paper, the
authors decompose the generalized rank invariant of a 2D persistence module M restricted
to a collection It ⊆ Int(P ) of test intervals, as a sum of generalized rank invariants of
interval modules, where the intervals are taken from another collection Id, of dictionary
intervals. The authors note that they make a choice of a collection of test intervals It
with which to probe the generalized rank invariant, and a set of dictionary intervals Id
with which to decompose a generalized rank invariant. Their developments focus on the
case when Id = It, but they note that new and interesting results may be obtained when
letting these two sets diﬀer, primarily if one allows It (cid:40) Id.

There is also much work on practical computation of multiparameter persistence and
resulting invariants, such as the rank invariant. Most of this existing work takes place
when P is a ﬁnite subset of the two dimensional lattice Z2. The most well-known software
for multiparameter persistence computation is RIVET, developed by Lesnick and Wright
[24], which visualizes, among other invariants, the rank invariant for a 2D persistence
module. This software computes a biﬁltration and then uses an algorithm to compute a
minimal presentation for the persistence module, developed by the same authors [25]. This
algorithm for computing minimal presentations is improved upon by Kerber and Rolle in
[20].

To compute the generalized rank invariant from a dataset, one would ﬁrst need to
compute a biﬁltration over some ﬁnite P ⊆ Z2 on the data, as is done in RIVET. Dey et al.
[16] showed that from this biﬁltration, one can compute the generalized rank invariant over
a speciﬁc interval using a tool called zigzag persistence, introduced by Carlsson and de Silva
[9]. There are existing algorithms and software implementations for zigzag persistence, with
the current state of the art algorithm developed by Dey and Hou [15].

This provides the most eﬃcient known algorithm for computing the generalized rank
invariant, yet speed limitations make this algorithm generally not practical to use to com-
pute rankM (I) for all I ∈ Int(P ). A key motivation for the work in this paper was to
determine how much we weaken the generalized rank invariant by restricting its domain

3

to a subset I (cid:40) Int(P ), for which computing rankM (I) over all I ∈ I could be used in
practice.

1.2 Our Contribution

The generalized rank invariant for a given multiparameter persistence module is a function
with domain consisting of all intervals in the indexing poset. If M is a persistence module
over Z2, or a ﬁnite subset thereof, and I is a ﬁnite interval, we can use Dey et al.’s
aforementioned algorithm to compute rankM (I). Even for a ﬁnite, small poset P ⊂ Z2,
the size of Int(P ) can grow rapidly, see [1]. As a result, computing rankM (I) over all
I ∈ Int(P ) is generally not practical.

This suggests restricting the domain of rankM to strict subsets of I ⊂ Int(P ) to get a
wide family of invariants. As we decrease the domain I in our restriction, the invariant loses
information, hence it becomes weaker. If I (cid:40) Int(P ), we no longer are guaranteed that
M (cid:55)→ rankM |I is a complete invariant on interval-decomposable P -modules, and in fact in
Theorem 3.2, we show that completeness no longer holds in this setting. For example, if
P = Z2 and I is the collection of all rectangles, then rankM |I turns out to be the standard
rank invariant, which is known to be incomplete on interval decomposable modules. Our
Theorem 3.17 makes this statement precise for any ﬁnite poset P .

Nonetheless, if we take a smaller subset I ⊂ Int(P ), it becomes more feasible to compute
rankM (I) over all I ∈ I, so we would like to do this in practice. The pressing question
then is how strong of an invariant rank|I remains as the size of I changes. Our main result
is a characterization answering this question, in the form of Theorem 3.17:

Theorem 3.17. Let P be any ﬁnite poset, and I ⊆ Int(P ) be any subcollection. Then,
(i) rank|I is a complete invariant on the collection of I-decomposable P -modules.
(ii) Further, there is no J (cid:40) I such that rank|J is a complete invariant on the collection

of I-decomposable P -modules.

As a consequence of (ii), there is no J (cid:41) I such that rank|I is a complete invariant on

the collection of J -decomposable P -modules.

While (i) is a rather direct consequence of the Möbius inversion theorem, (ii) requires a
general process for constructing a pair of P -modules M and N which are I-decomposable
and non-isomorphic, yet have rankM |J = rankN |J .

Recall the collections It and Id from Botnan et al.’s work [6] mentioned previously.
The collection of intervals I in Theorem 3.17 plays the role of It, being the collection of
intervals the generalized rank invariant is allowed to probe. The collection of intervals J in
(ii) is related to the collection Id. In particular, if M is I-decomposable and It (cid:40) I, then
Theorem 3.17 suggests that the rank decomposition of rankM |It over intervals from Id will,
in general, change and become, in some sense, more accurate as Id ranges in It ⊆ Id ⊆ I,
but will not change once Id ⊇ I.

We also provide a stability result for the generalized rank invariant when restricted
to collections I ⊆ Int(P ) which meet certain additional criteria. This stability result
generalized that of Kim and Mémoli in [21], which held in the setting of P = R2.

Organization.
In Section 2, we will brieﬂy provide relevant background on persistence
modules, decomposability, and the deﬁnition and some key properties of the generalized
In Section 3, we state and prove completeness results, compounding in
rank invariant.
In Section 4, we prove a stability result for these restricted generalized
Theorem 3.17.

4

I ⊆ Int(P ) on which
to restrict rank|I

P -modules M generated by kI,
with I ∈ I ⊆ Int(P )

Int(P )

I

J

Int(P )

I (cid:48)

J (cid:48)

Figure 1: The dashed lines indicate that M (cid:55)→ rankM |∗, where ∗ ⊆ Int(P ) is a collection
of intervals on the left, is a complete invariant on the collection of P -modules M whose
indecomposable summands are all of the form kI, where I ∈ ∗(cid:48) ⊆ Int(P ). Theorem 3.17
tells us that ∗ ⊇ ∗(cid:48), and that ∗ = ∗(cid:48) is the minimal collection meeting this criteria. For
example, I = I (cid:48) and J = J (cid:48) as in the ﬁgure. The theorem tells us that if we shrink the
collection on the left, the corresponding collection on the right will shrink in the exact same
manner, and likewise if we expand the collection on the right, the corresponding collection
on the left will expand in the exact same manner.

rank invariants over general posets P , using a notion of erosion distance, based on the one
introduced by Patel [29], and the notion of interleaving distance on a general poset, deﬁned
by Bubenik et al. [7] and generalized by de Silva et al. [14].

2 Preliminaries

Throughout this paper, unless otherwise stated, we take (P, ≤) to be a ﬁnite poset. We
regard (P, ≤) as the category P, with objects the elements p ∈ P , and a unique morphism
p → q if and only if p ≤ q.

Let vec denote the category of ﬁnite dimensional vector spaces with linear maps be-

tween them. All vector spaces in this paper have coeﬃcients in some ﬁxed ﬁeld k.

A persistence module over P is a functor M : P → vec to the category of ﬁnite
dimensional vector spaces and linear maps. For any p ∈ P , we denote the vector space
Mp := M (p), and for any p ≤ q ∈ P , we denote the linear map ϕM (p, q) := M (p ≤ q).

We also refer to M as a P -module, and say that P is the indexing set for M . Of
particular interest to us will be persistence modules which decompose into a direct sum of
interval modules.

Deﬁnition 2.1. An interval of P is a non-empty subset I ⊂ P such that:

(i) (convexity) If p, r ∈ I and q ∈ P with p ≤ q ≤ r, then q ∈ I.
(ii) (connectivity) For any p, q ∈ I, there is a sequence p = r0, r1, . . . , rn = q of elements

of I, where ri and ri+1 are comparable for 0 ≤ i ≤ n − 1.

We refer to the collection of all intervals in P as Int(P ).

For example, ﬁx p ≤ q ∈ P , and denote [p, q] := {r ∈ P | p ≤ r ≤ q}. Then [p, q]
is an interval. If P = R2, then [p, q] geometrically is a rectangle, and we refer to such an
interval as a rectangle. In more general posets P , we refer to such interval an interval with
a unique minimal element and a unique maximal element as a segment.

5

For I ∈ Int(P ), the interval module kI is the persistence module indexed over P,

with:

kI

p =

(cid:40)

k if p ∈ I
0

otherwise

,

ϕkI (p, q) =

(cid:40)

idk
0

if p ≤ q ∈ I
otherwise

Given any M, N : P → vec, the direct sum M ⊕ N is deﬁned pointwise at each p ∈ P .
We say a nontrivial M : P → vec is decomposable if M is isomorphic to N1 ⊕ N2 for
some non-trivial N1, N2 : P → vec, which we denote by M ∼= N1 ⊕ N2. Otherwise, say M
is indecomposable. Interval modules are indecomposable [4].

A persistence module M : P → vec is interval decomposable if it is isomorphic to
a direct sum of interval modules. That is, if there is a multiset of intervals barc(M ), such
that:

M ∼=

(cid:77)

kI

I∈barc(M )

If this multiset exists, we call it the barcode of M .

If it exists, barc(M ) is well-deﬁned as a result of the Azumaya-Krull-Remak-Schmidt
theorem [3]. Thus, in the case where M is interval decomposable, barc(M ) is a complete
descriptor of the isomorphism type of M .

For a collection of intervals I ⊆ Int(P ), we say a persistence module M : P → vec
is I-decomposable, if M can be written as a direct sum of interval modules, where all
intervals are from I. Equivalently, if all intervals in barc(M ) are from I. For example, if
I = Int(P ), then M is I-decomposable is the same as saying M is interval-decomposable.
If P = R2 and I is the collection of rectangle intervals, then M being I-decomposable is
the same as M being rectangle-decomposable.

2.1 Rank Invariant

We state the deﬁnition of the rank invariant discussed by Carlsson and Zomorodian [10]:

Deﬁnition 2.2. Let Q := {(p, q) ∈ P × P | p ≤ q}. For M : P → vec, the rank invariant
of M , rkM : Q → Z≥0, is deﬁned point-wisely as the rank of the linear map:

rkM (p, q) := rank(ϕM (p, q))

In their paper, the authors noted that the rank invariant is not a complete invariant
on the class of multidimensional persistence modules. This fact also follows quickly from
Proposition 3.10. However, by restricting to rectangle-decomposable modules indexed over
Z2, Botnan et al. [5] showed the following completeness result:

Theorem 2.3. Suppose X, Y ⊆ Z, and P = X × Y . The isomorphism type of any
point-wise ﬁnite dimensional rectangle-decomposable persistence module M over P is fully
determined by the rank invariant of M .

This outlines a speciﬁc case where the rank invariant is complete. We will generalize

the statement of this theorem and show it holds for any ﬁnite P in Proposition 3.1.

2.2 The Möbius inversion formula in combinatorics

We review the Möbius inversion formula [30]. Let a poset Q be locally ﬁnite, i.e.
for
all p, q ∈ Q with p ≤ q, the segment [p, q] := {r ∈ Q : p ≤ r ≤ q} is ﬁnite. The Möbius
function µQ : Q × Q → Z of Q is deﬁned recursively as

6

µQ(p, q) =





1,
− (cid:80)

p = q,
µQ(p, r), p < q,

p≤r<q

0,

otherwise.

(1)

For q ∈ Q, let q↓ denote the principal ideal {p ∈ Q : p ≤ q}.

Theorem 2.4 (Möbius Inversion formula). Assume that q↓ is ﬁnite for all q ∈ Q (which
implies that Q is locally ﬁnite) and let k be a ﬁeld. For any pair of functions f, g : Q → k,

if and only if

g(q) =

(cid:88)

r≤q

f (r) for all q ∈ Q

f (q) =

(cid:88)

r≤q

g(r) · µQ(r, q) for all q ∈ Q.

f will be referred to as the Möbius inversion of g.

2.3 Generalized Rank Invariant

For p ≤ q in P , the rank invariant evaluated at p, q, rkM (p, q), captures the number of
features which persist throughout the entire segment I = [p, q] (cf. Proposition 2.8). One
natural extension to consider is how to capture persistence of features on a general interval
I ∈ Int(P ). The generalized rank invariant accomplishes this task.

We outline key deﬁnitions and properties regarding the generalized rank invariant de-
veloped by Kim and Mémoli [21]. The originally deﬁned domain for the generalized rank
invariant is the collection of all connected subsets of P . For our purposes, we restrict the
domain of the generalized rank invariant to Int(P ), as was done in [16]. As mentioned
before, this restricted generalized rank invariant is equivalent to the interval module ap-
proximation introduced by Asashiba et al.
[2]. Our exposition follows [16]. There are
many texts one can use for an overview of necessary elements of category theory, such as
Mac Lane’s popular text [26].

Any P -module M admits a limit

and a colimit

lim
←−

lim
−→

M = (L, (πp : L → Mp)p∈P )

M = (C, (ip : Mp → C)p∈P ).

Deﬁnition 2.5 ([21]). The canonical limit-to-colimit-map

ψM : lim
←−

M → lim
−→

M

is the linear map ip ◦πp for any p ∈ P . The generalized rank of M is rank(M ) := rank(ψM ).

For any P -module M , rank(M ) coincides with the multiplicity of the fully supported

interval module kP in a direct sum decomposition of M into indecomposable modules:

Theorem 2.6 ([11, Lemma 3.1]). Assume that a P -module M is isomorphic to the direct
sum (cid:76)
i∈I Mi for some indexing set I where each Mi is indecomposable. The generalized
rank of M is equal to the cardinality of the set {i ∈ I : Mi

∼= kP }.

7

Deﬁnition 2.7. The Int-generalized rank invariant of M is the map rankM : Int(P ) → Z≥0
deﬁned by rankM (I) := rank(M |I), where M |I is the restriction of M to I. By the
generalized rank invariant, we refer to the mapping M (cid:55)→ rankM .

M = Mq, and so rank(M ) =
Note that if P = [p, q] is a segment, then lim
←−
rkM (p, q). Thus, the generalized rank invariant restricted to segments gives the rank in-
variant.

M = Mp, lim
−→

Theorem 2.6 leads to the following proposition.

Proposition 2.8. For any interval decomposable M : P → vec and I ∈ Int(P ), rankM (I)
is equal to the total multiplicity of intervals J ∈ barcP(M ) such that J ⊇ I.

This result is related to the fact that ﬁnite direct sums commute with limits and col-
i=1Mi) ∼=
(cid:1). This yields the following prop-
i=1 rankMi(I). We refer to this

imits, i.e., if Mi : P → vec for 1 ≤ i ≤ n are a family of P -modules, then lim
←−
(cid:0)lim
⊕n
←−
erty: if M := ⊕n
property as the additivity of the generalized rank invariant.

i=1Mi, and I ∈ Int(P ), then rankM (I) = (cid:80)n

(cid:1), and similarly lim
−→

i=1Mi) ∼= ⊕n

(cid:0)lim
←−

(⊕n

(⊕n

Mi

Mi

i=1

i=1

Deﬁnition 2.9. The (Int)-generalized persistence diagram of M is the unique function
dgm(M ) : Int(P ) → Z that satisﬁes, for any I ∈ Int(P ),

rankM (I) =

(cid:88)

J⊇I
J∈Int(P )

dgm(M )(J)

This deﬁnition is based on the notion of Möbius inversion. Existence and uniqueness are
guaranteed by Theorem 2.4. By [2, Theorem 5.10], the Int-generalized persistence diagram
coincides with the interval decomposable approximation δtot(M ) introduced in that paper.
The most important property of the generalized rank invariant in the context of our

paper comes as:

Theorem 2.10 ([21]). If M : P → vec is interval decomposable, then for all I ∈ Int(P ),
dgm(M )(I) is equal to the multiplicity of I in barc(M ).

Due to uniqueness of Möbius inversion, and completeness of the barcode as an invari-
ant for interval-decomposable modules, this Theorem implies that the generalized rank
invariant is a complete invariant on the class of interval-decomposable modules over P.

3 Completeness of Generalized Rank Invariants

In this section we prove our main result, Theorem 3.17. We build to this result by ﬁrst
establishing statement (i) of the Theorem in Proposition 3.1. We then show statement (ii)
of the Theorem in a special case in Proposition 3.2, and in the general form in Proposition
3.10.

Completeness We ﬁrst show statement (i) of Theorem 3.17. This statement is the
analogue of the completeness result in Theorem 2.10, adapted to any I ⊆ Int(P ):

Proposition 3.1. Fix I ⊆ Int(P ). Then rank|I is a complete invariant on the collection
of I-decomposable P -modules.

8

Proof. Assume M, N : P → vec are I-decomposable, and that rankM |I = rankN |I. We
will show that M ∼= N .

Deﬁne dgmI to be the Möbius inversion of rank|I over the ﬁnite poset I op. This poset
has the same elements as I, but with ordering reversed: I ≤ J in I op if and only if J ⊆ I.
Explicitly, dgmI(M ) : I → Z is the unique function which satisﬁes:

rankM |I(I) =

dgmI(M )(J),

(cid:88)

J⊇I
J∈I

and similarly for N . By Theorem 2.4, we get rankM |I = rankN |I =⇒ dgmI(M ) =

dgmI(N ). For I ∈ I, we have:

dgm(M )(J) = rankM (I)

and

(cid:88)

J⊇I
J∈Int(P )

dgmI(M )(J) = rankM |I(I)

(cid:88)

J⊇I
J∈I

But as I ∈ I, dgm(M )(I) = 0 for J /∈ I, implying that for all I ∈ I we have:

dgmI(M )(J) =

(cid:88)

J⊇I
J∈I

dgm(M )(J)

(cid:88)

J⊇I
J∈I

Theorem 2.4 then implies dgm(M )|I = dgmI(M ). As dgm(M ) is 0 outside of I,
dgmI(M ) uniquely determines dgm(M ). Thus, we have:

rankM |I = rankN |I =⇒ dgmI(M ) = dgmI(N ) =⇒ dgm(M ) = dgm(N )

and as M and N are interval decomposable, this alongside Theorem 2.10 implies M ∼=
N .

Finiteness of P was implicitly used in this proof for use of results regarding Möbius
inversion. The same argument would hold for Int(P ) a locally ﬁnite poset with a maximal
element, see [30, Proposition 2].

Optimality of our completeness results After knowing that the generalized rank
invariant restricted to I is complete on I-decomposable P -modules, we wonder whether
further restrictions to the domain allow the invariant to retain completeness. The remain-
ing propositions build to answering this question.

Proposition 3.2 is a special case of Proposition 3.10 and Corollary 3.16, where the class
I is Int(P ) \ {I} for some interval I. We give the proof for Proposition 3.2 in this special
case, and then will build upon this proof for demonstrating the more general statements.

Proposition 3.2. Fix an I ∈ Int(P ). Then rank|Int(P )\{I} is not a complete invariant on
the class of interval-decomposable persistence modules over P .

We will prove this by deﬁning two P -modules M and N which are interval decompos-
able, non-isomorphic, and have rankM (J) = rankN (J) for all J ∈ Int(P ) \ {I}. The central
idea of the construction of these two modules is to deﬁne their barcodes, which consist of
intervals formed by removing subsets of minimal and maximal points from I. We ﬁrst give
some deﬁnitions and lemmas.

9

Deﬁnition 3.3. For I ⊆ P , denote the collection of minimal points of I as min(I), and
the collection of maximal points of I as max(I). Deﬁne A := min(I) ∪ max(I).

We consider the sets I − a for a ⊆ A. We want to take direct sums of interval modules
on these sets. The issue with this is that I − a is not necessarily connected. We introduce
the following notation to deal with this:

Deﬁnition 3.4. For J ⊂ P convex, let int(J) be the collection of maximal intervals in J.

Note that J is an interval if and only if int(J) = {J}, if and only if |int(J)| = 1. If J

is not connected, then int(J) is the collection of connected components of J.

Deﬁnition 3.5. For a ⊆ A, and any convex set I ⊂ P , deﬁne:

kI :=

(cid:77)

kJ

J∈int(I)

If a ⊂ A is a collection of extremal points of I, it is evident that I − a is convex, so
we can use Deﬁnition 3.5 to deﬁne kI−a. For example, if I − a = J1 ∪ J2 ∪ J3, with Ji the
connected components in I − a for 1 ≤ i ≤ 3, then by kI−a we mean kJ1 ⊕ kJ2 ⊕ kJ3.

Lemma 3.6. For L ∈ Int(P ), and a convex set I ⊂ P , one computes:

rankkI (L) =

(cid:40)

1 L ⊆ I
else
0

Proof. By deﬁnition, kI = ⊕J∈int(I)kJ . Then by Proposition 2.8, for any L ∈ Int(P ),
rankkI (L) is the number of intervals J ∈ int(I) containing L. As L is an interval, it is
connected, and so L can be contained in at most one such J. Thus, if L ⊂ I, then L is
contained in one and only one J ∈ int(I), and if L (cid:54)⊂ I, L is contained in no J ∈ int(I),
proving the claim.

In light of Lemma 3.6, if M is a direct sum of terms kI−a, then computing rankM (J)
for some J ∈ I boils down to a counting argument. The proof of Proposition 3.2 and some
later results rely on the following well-known combinatorial lemma, whose proof we omit:

Lemma 3.7. For any natural number n, we have:

(cid:88)

0≤i≤n
i even

(cid:19)

(cid:18)n
i

=

(cid:19)

(cid:18)n
i

(cid:88)

0≤i≤n
i odd

= 2n−1.

Recall the deﬁnition of A from Deﬁnition 3.3.

Deﬁnition 3.8. Suppose I has m minimal and n maximal points, so that |A| = n + m.
For 0 ≤ (cid:96) ≤ n + m, deﬁne A(cid:96) := {a ⊆ A | |a| = (cid:96)}.

A(cid:96) consists of all subsets of size (cid:96) from A, note this means |A(cid:96)| = (cid:0)n+m

(cid:1). For example,
A1 = {{x} | x ∈ A}, An+m = {A}, and A0 = {∅}. The idea behind the construction of the
persistence modules in the proof of Proposition 3.2 is to generate two multisets of intervals
by removing elements of A(cid:96) from I for 0 ≤ (cid:96) ≤ |A|.

(cid:96)

We give a simple example illustrating this idea of removing extremal subsets in Example

3.9, visualized in Figure 2.

10

Figure 2: The intervals I (blue), J1 = I − {(1, 1)} (red), J2 = I − {(3, 3)} (orange), and
J3 = I − {(1, 1), (3, 3)} (purple) in P from Example 3.9.

Example 3.9. Let P := [0, 4] × [0, 4] ⊂ Z2 with the usual product order. Take I to
be the segment [(1, 1), (3, 3)] ∈ Int(P ). Then we have A = {(1, 1), (3, 3)}. One checks
A1 = {{(1, 1)}, {(3, 3)}}, and A2 = {A}. Let J1 := I − {(1, 1)}, J2 := I − {(3, 3)} and
J3 := I − A. See I, J1, J2, J3 in Figure 2.

If we let M := kI ⊕ kJ3 and N := kJ1 ⊕ kJ2, one can check straightforwardly that
rankM (J) = rankN (J) for all J ∈ Int(P ) \ {I}, even though these are both interval
decomposable modules and are non-isomorphic.

We now give the proof of Proposition 3.2.

Proof of Proposition 3.2. We deﬁne M, N : P → vec which are (i) interval-decomposable
over P , (ii) are non-isomorphic, and (iii) for which rankM (J) = rankN (J) for all J ∈
Int(P ) \ {I}

(cid:32)

(cid:33)

M :=

(cid:77)

(cid:77)

kI−a

0≤(cid:96)≤n+m
(cid:96) even

a∈A(cid:96)

N :=

(cid:77)

0≤(cid:96)≤n+m
(cid:96) odd

(cid:33)

kI−a

(cid:32)

(cid:77)

a∈A(cid:96)

(2)

(3)

By Deﬁnition 3.5, each kI−a is interval decomposable, and so it is immediate that M

and N are interval decomposable, so (i) is satisﬁed.

We claim that M and N are non-isomorphic. By Deﬁnition 3.8, A0 = {∅}, so M
contains a summand of kI−∅ = kI.
If (cid:96) ≥ 1, a ∈ A(cid:96) is non-empty, so all intervals in
barc(N ) are strict subsets of I, implying kI is not a summand of N . This implies the
claim, and so we have shown condition (ii).

It remains to show condition (iii). To do so, we compute rankM (J) and rankN (J) for
all possible cases of J ∈ Int(P ) \ {I}. Towards this end, ﬁx some J ∈ Int(P ) \ {I}. We
consider two cases:

Case 1: Suppose J (cid:54)⊆ I. By Proposition 2.8, we have immediately that rankM (J) =
rankN (J) = 0.
Case 2: Suppose J ⊆ I. As J (cid:54)= I, we have J (cid:40) I. This implies that J cannot contain
all of the minimal and maximal points of I, and thus 0 ≤ |J ∩ A| ≤ n + m − 1. We claim:

rankM (J) = rankN (J) = 2n+m−1−|J∩A|.

11

(0,0)(4,4)By Lemma 3.6, to compute rank∗(J), we need to count the number of terms kI−a in the
respective summations, such that J ⊆ I − a. It holds that J ⊆ I − a if and only if J ∩ a = ∅
if and only if a ⊆ A − (J ∩ A).

The set A − (J ∩ A) contains n + m − |J ∩ A| elements, so the number of a ∈ A(cid:96) with
J ⊆ I − a is the number of ways to choose (cid:96) elements from n + m − |J ∩ A| elements. From
this fact, the deﬁnition of M and N in Equations 2 and 3, respectively, Lemma 3.6, and
the additivity of the generalized rank invariant, we compute:

rankM (J) =

rankN (J) =

(cid:18)n + m − |J ∩ A|
(cid:96)

(cid:19)

(cid:18)n + m − |J ∩ A|
(cid:96)

(cid:19)

(cid:88)

0≤(cid:96)≤n+m
(cid:96) even

(cid:88)

0≤(cid:96)≤n+m
(cid:96) odd

By Lemma 3.7, these are both equal:

rankM (J) = 2n+m−|J∩A|−1 = rankN (J)

We have shown rankM (J) = rankN (J) for all J ∈ Int(P ) \ {I}, thus condition (iii) is

satisﬁed, as desired.

We now consider move to a broader setting, where instead of just Int(P ) \ {I}, we

consider any collection I (cid:40) Int(P ) on which to restrict the generalized rank invariant.

Proposition 3.10. Let I ⊆ Int(P ), and ﬁx some I /∈ I in Int(P ). Then rank|I is not a
complete invariant on the class of (I ∪ {I})-decomposable persistence modules.

Similarly to the proof of Proposition 3.2, we will show this by constructing two per-
sistence modules M, N : P → vec, which are (i) (I ∪ {I})-decomposable, (ii) are non-
isomorphic, and (iii) for which rankM (I) = rankN (I) for I ∈ I. Before providing the
construction for these modules, we give a concrete example to provide intuition for our
construction:

Example 3.11 (Figure 3.11). Let P := [0, 4]×[0, 4] ⊂ Z2 with the usual product order. Let
I be the collection of all segments in Int(P ). As in the ﬁgure, we take J1 = [(1, 2), (3, 3)],
J2 = [(2, 1), (3, 3)], J3 = J1 ∩ J2 = [(2, 2), (3, 3)] and I = J1 ∪ J2. Since rank|I does
not contain I in its domain, we "mimic" the eﬀect of kI on rank|I using the maximal
rectangle intervals inside I, being J1 and J2. But these two rectangles overlap, and so
to balance this we add the overlap, the interval J3, as an interval module alongside kI.
Setting M = kI ⊕ kJ3, N = kJ1 ⊕ kJ2, one can easily verify that rankM |I = rankN |I.

12

Figure 3: The intervals I (blue), J1 (red), J2 (orange), J3 (purple) from Example 3.11.

Proof of Proposition 3.10 We aim to ﬁnd a pair of P -modules M and N that are
(I ∪ {I})-decomposable, non-isomorphic, and for which rankM |I = rankN |I.

For any J /∈ I, deﬁne maxI(J) to be the collection of maximal sub-intervals of J in
the collection I. Namely, K ∈ I belongs to maxI(J) if and only if K ⊆ J and there is no
K (cid:48) ∈ I with K (cid:48) ⊆ J and K (cid:40) K (cid:48). For example, in Example 3.11, maxI(I) = {J1, J2}. We
will generalize the idea of Example 3.11.

Given any convex J ⊂ P , recall the deﬁnition of int(J) from Deﬁnition 3.4. Given a

set J of intervals in P and n ∈ N, we deﬁne the multiset

intn(J ) :=

(cid:91)

(cid:16)(cid:92)

(cid:17)

,

E

int

E⊂J
|E|=n

where the union is the multiset union. Note that int1(J ) = J .

Let J := maxI(I) ⊂ I and k := |J |.

Suppose k = 0. This implies that there are no J ∈ I with J ⊆ I. We deﬁne M := kI
and N := 0. These are clearly (I ∪ {I})-decomposable and non-isomorphic. Since there is
no J ∈ I with J ⊆ I, Proposition 2.8 tells us that both rankM and rankN vanish on I, as
desired.
Suppose k ≥ 1. We construct two multisets of intervals X1 and X2 in P , which can
possibly be the barcodes of two persistence modules whose rank functions coincide on I.

X1 =

X2 =



inti(J )


 ∪ {I}






(cid:91)

1≤i≤k
i even

inti(J )

(cid:91)

1≤i≤k
i odd

(4)

(5)

If all of the intervals in X1 and X2 belong I, the proof is completed by establishing the

following proposition.

Proposition 3.12. The two P -modules M and N whose barcodes are X1 and X2, respec-
tively, are non-isomorphic. Also, their generalized rank invariants coincide on I.

13

(0,0)(4,4)Proof. It is clear M and N are non-isomorphic as M contains a summand of kI, whereas
N does not, as all members of X2 are from I. Note also that all intervals in barc(M ) and
barc(N ) are subsets of I.

It remains to show that rankM (L) = rankN (L) for all L ∈ I. Fix an L ∈ I. There are
two cases: L (cid:54)⊆ I or L ⊆ I. Suppose L (cid:54)⊆ I. Since all intervals in barc(M ) and barc(N )
are subsets of I, Proposition 2.8 implies rankM (L) = 0 = rankN (L).

Next, suppose L ⊆ I. Since L ∈ I, we must have that L ⊆ K for some K ∈ J =
maxI(I). Hence, m := |{J ∈ J : L ⊆ J}| is nonzero. Note that L is contained in (cid:84) J (cid:48)
for all nonempty J (cid:48) ⊆ {J ∈ J : L ⊆ J}. There are (cid:0)m
(cid:1) ways to pick i members from
{J ∈ J : L ⊆ J} and thus by Lemma 3.6, the number of intervals in inti(J ) containing
L is also (cid:0)m

(cid:1). Using the additivity of the generalized rank invariant, we compute:

i

i

rankM (L) =

rankN (L) =

(cid:88)

J∈X1
L⊆J

(cid:88)

J∈X2
L⊆J

1 =






(cid:88)

1≤i≤m
i even



(cid:18)m
i

(cid:19)

 + 1

(cid:19)

(cid:18)m
i

(cid:88)

1 =

1≤i≤m
i odd

where the +1 in the ﬁrst line comes from the fact L ⊆ I ∈ X1. We rewrite these sums as:

rankM (L) =

rankN (L) =






(cid:88)

0≤i≤m
i even






(cid:19)

(cid:18)m
i






(cid:88)

0≤i≤m
i odd






(cid:19)

(cid:18)m
i

Then Lemma 3.7 gives rankM (L) = rankN (L), as desired.

No assumptions on I. We have proven Proposition 3.10 in the case where all intervals
in X1 and X2 deﬁned in (4) and (5) belong to I. Now we deal with the case where this
does not hold true.

We adapt the previous argument by replacing intervals J in X1 and X2 which are not
in I ∪ {I} by maximal sub-intervals of J contained in I ∪ {I}. If no such sub-intervals
exist, then J will simply be deleted from X1 or X2, as it cannot be detected by rank|I.

To outline the coming argument, we will provide a process by which we update X1
and X2 to new multisets of intervals X (cid:48)
2. We use these to deﬁne P -modules M (cid:48)
and N (cid:48) as the direct sum of interval modules over the new X (cid:48)
2. We show that if
rankM (L) = rankN (L) for all L ∈ I, then after the update rankM (cid:48)(L) = rankN (cid:48)(L) will
hold for all L ∈ I. We conclude by showing that after ﬁnitely many applications of this
update process, M (cid:48) and N (cid:48) will be (I ∪ {I})-decomposable.

1 and X (cid:48)

1 and X (cid:48)

We deﬁne the following procedure to update X1 and X2. The aim of the following

procedure is to remove an interval J /∈ I ∪ {I} from X1 or X2.

14

Procedure 3.13. Input: the collection of intervals (I ∪ {I}) ⊆ Int(P ), X1 and X2 ﬁnite
multisets of intervals, and an interval J ∈ X1 which is not in I ∪{I}. Set K := maxI∪{I}(J)
and m := |K| If m = 0, we deﬁne X (cid:48)

2 := X2. If m > 0, we deﬁne:

1 := X1 \ {J} and X (cid:48)

X (cid:48)

1 :=

X (cid:48)

2 :=











inti(K)

inti(K)











(cid:91)

1≤i≤m
i odd

(cid:91)

1≤i≤m
i even

(cid:91)

(X1 \ {J})

(cid:91)

X2

(6)

(7)

where the unions are the multiset union. If we instead start with J ∈ X2, J /∈ I ∪ {I},
the process is the same, except we replace X1, X (cid:48)
1, respectively.
The process outputs the new multisets of intervals X (cid:48)

2 with X2, X (cid:48)
1 and X (cid:48)
2.

1, X2, X (cid:48)

2, X1, X (cid:48)

Lemma 3.14. Let M, N, M (cid:48), N (cid:48) be the interval decomposable P -modules whose barcodes
are X1, X2, X (cid:48)
2 respectively. Let L ∈ I. If rankM (L) = rankN (L), then rankM (cid:48)(L) =
rankN (cid:48)(L).

1 and X (cid:48)

Proof. Case 1: Suppose L (cid:54)⊆ J. Note that the only intervals added or removed from X1
and X2 by Procedure 3.13 are intervals which are subsets of J. Hence, by Proposition 2.8,
we have:

rankM (cid:48)(L) = rankM (L) = rankN (L) = rankN (cid:48)(L).

Case 2: Suppose L ⊆ J. Recall that K = maxI∪{I}(J). We cannot have K = ∅, as this
implies there are no L ∈ I such that L ⊆ J. Hence we have K (cid:54)= ∅. Since L ⊆ J and
L ∈ I, L must be contained in some I ∪{I}-maximal interval inside J, i.e., L ⊆ K for some
K ∈ K. This implies that there is p ∈ N such that {K ∈ K : L ⊆ K} = {K1, . . . , Kp}.
Note that for a ﬁxed 1 ≤ i ≤ p, L is contained in (cid:0)p
(cid:1) elements of inti(K). By Proposition
2.8 and the deﬁnitions of X (cid:48)

i
2 in Equations 6 and 7, we have:

1 and X (cid:48)

rankM (cid:48)(L) = rankM (L) − 1 +






(cid:18)p
i

(cid:88)

1≤i≤p
i odd

(cid:19)






rankN (cid:48)(L) = rankN (L) +






(cid:18)p
i

(cid:88)

1≤i≤p
i even

(cid:19)






The -1 in the ﬁrst line comes from the fact that we removed J from X1 when going to X (cid:48)
1,
and by assumption, L ⊆ J. By additivity of the generalized rank invariant and Lemma

15

3.7, we compute:

rankM (cid:48)(L) = rankM (L) − 1 +

= rankM (L) − 1 +

= rankM (L) − 1 +

(cid:19)






(cid:19)






(cid:19)






(cid:18)p
i

(cid:18)p
i

(cid:18)p
i
















(cid:88)

1≤i≤p
i odd

(cid:88)

0≤i≤p
i odd

(cid:88)

0≤i≤p
i even

= rankM (L) +











= rankN (L) +

=rankN (cid:48)(L),

(cid:19)






(cid:19)






(cid:18)p
i

(cid:88)

1≤i≤p
i even

(cid:18)p
i

(cid:88)

1≤i≤p
i even

as desired.

Proof of Proposition 3.10. We have already covered case (1); there is no J ∈ I with
J ⊂ I.
It remains to cover case (2); there exists J ∈ I with J ⊂ I. We will ﬁnd
(I ∪ {I})-decomposable P -modules M and N by specifying their barcodes, and then show
that rankM (L) = rankN (L) for all L ∈ I.

Consider X1 and X2 in Equations (4) and (5), which are well-deﬁned by the assumption
that there exists J ∈ I with J ⊂ I. If X1 and X2 consists solely of intervals from I, then
let M and N be P -modules whose barcodes are X1 and X2, respectively. Then, M and N
are clearly (I ∪ {I})-decomposable by construction. By Proposition 3.12, M and N have
the same rank invariant on I.

Next assume that there is K in either X1 or X2 such that I does not contain K.
Without loss of generality, assume that K ∈ X1. By Proposition 3.12 and Lemma 3.14,
the two P -modules whose barcodes are X (cid:48)
1 and X (cid:48)
2 respectively in Equations 6 and 7 have
the same rank invariant on I. If X (cid:48)
2 consist solely of intervals from I, then we
declare that M and N are the P -modules with the barcodes X (cid:48)
1 and X (cid:48)
2 and complete the
proof. If not, we apply Procedure 3.13 to X (cid:48)

1 and X (cid:48)

1 and X (cid:48)

2 again.

We claim that this process must end in ﬁnitely many steps. Consider the sequence

(Zi := X (i)

1 ∪ X (i)

2 )i=0,... of multisets of intervals in P . Let

ai := max{|J| ∈ N ∪ {0} : J ∈ Zi but J /∈ I ∪ {I}}.

Note that ai = 0 if and only if Zi does not contain any J ∈ I ∪ {I}. Note also that (ai) is a
monotonically non-increasing sequence. We further claim that there cannot be an inﬁnite
subsequence of (ai) having the same nonzero value. To see this, suppose ai = c > 0, and let
J := {J ∈ Zi | |J| = c}. Let j := |J |. Then after j subsequent applications of Procedure
3.13, all intervals in J can be removed from Zi, potentially being replaced by strictly

16

smaller intervals. Thus, we must have ai+j < ai. These properties of (ai) force aT = 0 for
large enough T . Now, by Lemma 3.14, the P -modules MT and NT , with barcodes X (T )
and X (T )
, respectively, are (I ∪ {I})-decomposable modules with the same rank invariant
2
over I.

1

Lastly, observe that the original X1 had I as an element, whereas X2 did not. Observe
also that I (cid:41) J for all J ∈ X1 ∪ X2 with J (cid:54)= I. From this fact, alongside the fact
I ∈ I ∪ {I}, we get that applications of Procedure 3.13 cannot alter the multiplicity of I in
X1 or X2. Hence, X (T )
does not. This
implies that the two P -modules whose barcodes are X (T )
respectively cannot be
isomorphic.

contains the interval I as an element, whereas X (T )

and X (T )

1

2

1

2

Remark 3.15. Propositions 3.1 and 3.10 tell us that I-decomposable persistence modules
have the largest underlying set of interval modules in the decomposition, whilst maintaining
completeness of the generalized rank invariant restricted to I. This is diﬀerent then saying
that I-decomposable persistence modules is the maximal set of persistence modules on
which rank|I is complete.

For example, if we take P and all labelled intervals as in Example 3.11, and let I be
the set of segments, then rank|I can distinguish M := kI from any segment-decomposable
module. However, if we take the collection of all (I ∪ {I})-decomposable persistence
modules, then rank|I can no longer properly distinguish modules in this collection.

Lastly, similar to in Proposition 3.2, given that rank|I is complete on I-decomposable
modules, we wonder if any further restriction of the domain allows us to retain complete-
ness. The following answers this question in the negative:

Corollary 3.16. Let I ∈ I ⊂ Int(P ). Then rank|I\{I} is not a complete invariant on the
class of I-decomposable persistence modules over P .

Combining the results of this section gives us our main theorem:

Theorem 3.17. Let P be any ﬁnite poset, and I ⊆ Int(P ) be any subcollection. Then,
(i) rank|I is a complete invariant on the collection of I-decomposable P -modules.
(ii) Further, there is no J (cid:40) I such that rank|J is a complete invariant on the collection

of I-decomposable P -modules.

As a consequence of (ii), there is no J (cid:41) I such that rank|I is a complete invariant on

the collection of J -decomposable P -modules.

4 Stability

We now discuss stability for the generalized rank invariant restricted to I ⊆ Int(P ). The
distance we deﬁne for comparing generalized rank invariants will be a notion of erosion
distance, ﬁrst introduced by Patel in [29]. We compare P -modules using the notion of
interleaving distance on general persistence diagrams developed by Bubenik et al.
in [7]
and expanded upon by de Silva et al. in [14]. We review key deﬁnitions, following format
and notation from [14]:

Deﬁnition 4.1. A translation on P is an endofunctor Γ : P → P, together with a natural
transformation η : IP → Γ, where IP is the identify functor.

We care about translations respecting the order of P. For Γ1, Γ2 : P → P, we say
Γ1 ≤ Γ2 if for all p ≤ q ∈ P , Γ1(p) ≤ Γ2(q). A superlinear family of translations Ω, is a
family of translations Ω(cid:15) on P, for (cid:15) ≥ 0, such that IP = Ω0, and Ω(cid:15)Ωζ ≤ Ω(cid:15)+ζ.

17

We remark that, in [14], the authors allowed for IP ≤ Ω0.
For Ω(cid:15) a superlinear translation on P and I ⊆ P , we denote Ω(cid:15)(I) := {Ω(cid:15)(p) | p ∈ I}.
For all (cid:15) ≥ 0, the translation Ω(cid:15) comes with a natural transformation η(cid:15) : IP → Ω(cid:15). For
any M : P → vec, this induces a natural transformation M η(cid:15) : M → M Ω(cid:15).

Throughout this section Ω will be a superlinear family of translations on P.

Deﬁnition 4.2. Two P -modules M and N are Ω(cid:15)-interleaved if there exist a pair of natural
transformations ϕ : M → N Ω(cid:15) and ψ : N → M Ω(cid:15) such that the diagram:

M

N

M η(cid:15)

M Ω(cid:15)

M η(cid:15)Ω(cid:15)

M Ω(cid:15)Ω(cid:15)

ψ

ϕ

ψΩ(cid:15)

ϕΩ(cid:15)

N η(cid:15)

N Ω(cid:15)

N η(cid:15)Ω(cid:15)

N Ω(cid:15)Ω(cid:15)

commutes. The pair (ϕ, ψ) is an Ω(cid:15)-interleaving.
The interleaving distance with respect to Ω is:

dΩ
I (M, N ) = inf{(cid:15) ≥ 0 | M, N are Ω(cid:15) − interleaved}

or dΩ

I (M, N ) = ∞ if there is no (cid:15)-interleaving for any (cid:15) ≥ 0.

For example, if we take P = Rn with the standard product order, and Ω to be the family
I is the classical notion of interleaving

with Ω(cid:15) the translation by ((cid:15), (cid:15), . . . , (cid:15)) ∈ Rn, then dΩ
for multiparameter persistence modules in the Euclidean setting [23].

We now build to a deﬁnition of erosion distance between generalized rank invariants.

Deﬁnition 4.3. Let I ⊆ P be non-empty. For (cid:15) > 0, we call I (cid:15) the (cid:15)-thickening of I,
deﬁned as:

I (cid:15) := {r ∈ P | ∃p, q ∈ I with p ≤ Ω(cid:15)(r) and r ≤ Ω(cid:15)(q)}.

Clearly, I ⊂ I (cid:15). For example, if P = R, and Ω is the family with Ω(cid:15) the translation
by (cid:15) for (cid:15) ≥ 0, then for an interval I = [a, b], its (cid:15)-thickening would be the interval
I (cid:15) = [a − (cid:15), b + (cid:15)].

Proposition 4.4. Let I ∈ Int(P ). Then I (cid:15) ∈ Int(P ) for all (cid:15) ≥ 0.

Proof. Let (cid:15) ≥ 0. We need to show that I (cid:15) is non-empty, convex, and connected.

Since I((cid:54)= ∅) ⊂ I (cid:15), we have that I (cid:15) is non-empty. Suppose a, b ∈ I (cid:15), and a ≤ c ≤ b.
Then, we know there exist pa, qa, pb, qb ∈ I such that pa ≤ Ω(cid:15)(a), pb ≤ Ω(cid:15)(b), a ≤ Ω(cid:15)(qa),

and b ≤ Ω(cid:15)(qb). Then we have: pa ≤ Ω(cid:15)(a) ≤ Ω(cid:15)(c) and c ≤ b ≤ Ω(cid:15)(qb), and thus c ∈ I (cid:15).

To see connectivity, suppose p, q ∈ I (cid:15). Note that for all r ∈ I, Ω(cid:15)(r) ∈ I (cid:15), which can be
seen by letting p = q = r in Deﬁnition 4.3. Thus, we can ﬁnd rp, rq ∈ I with p ≤ Ω(cid:15)(rp)
and q ≤ Ω(cid:15)(rq). As rp, rq ∈ I, there is a chain rp = a0, a1, . . . , an = rq of sequentially
comparable elements of I. Then p ≤ Ω(cid:15)(rp) ≥ rp = a0, a1, . . . , an = rq ≤ Ω(cid:15)(rq) ≥ q gives
a chain of sequentially comparable elements of I (cid:15), so I (cid:15) is connected.

If I ⊆ Int(P ) and for all I ∈ I and (cid:15) ≥ 0, I (cid:15) ∈ I, then we say I is closed under

Ω-thickenings.

18

Example 4.5. If P = R2 with the usual product order, and Ω is the family with Ω(cid:15) the
translation by ((cid:15), (cid:15)) for (cid:15) ≥ 0, then for a rectangle I = [a, b], its (cid:15)-thickening would be
I (cid:15) = [a − ((cid:15), (cid:15)), b + ((cid:15), (cid:15))]. This is still a rectangle, so the collection of rectangles in R2 is
closed under Ω-thickenings.

Now we deﬁne the erosion distance:

Deﬁnition 4.6. Let I ⊆ Int(P ) be closed under Ω-thickenings, and let M, N be P -
modules. We say there is an (cid:15)-erosion between rankM |I and rankN |I if for all I ∈ I, we
have:

rankM (I (cid:15)) ≤ rankN (I)

and

rankN (I (cid:15)) ≤ rankM (I).

Deﬁne the erosion distance between rankM |I and rankN |I as:

dΩ
E(rankM |I, rankN |I) = inf{(cid:15) ≥ 0 | ∃ an (cid:15) − erosion between rankM |I and rankN |I}

and dΩ

E(rankM |I, rankN |I) = ∞ if no such erosion exists.

Proposition 4.7. Fix a collection I ⊆ Int(P ) that is closed under Ω-thickenings. Then
dΩ
E is an extended pseudometric on the collection {rankM |I | M : P → vec}.
Proof. Since Ω0 = IP, it is immediate that dΩ
immediate from the deﬁnition.

E(rankM |I, rankM |I) = 0. Symmetry is

It remains to show the triangle inequality. Note that Ω(cid:15)Ω(cid:15)(cid:48) ≤ Ω(cid:15)+(cid:15)(cid:48). This implies
(I (cid:15))(cid:15)(cid:48) ⊆ I (cid:15)+(cid:15)(cid:48). From this, if there is an (cid:15)-erosion between rankM |I and rankN |I, and an
(cid:15)(cid:48)-erosion between rankN |I and rankL|I, then for all I ∈ I:

rankM (I) ≥ rankN (I (cid:15)) ≥ rankL((I (cid:15))(cid:15)(cid:48)) ≥ rankL(I (cid:15)+(cid:15)(cid:48))
rankL(I) ≥ rankN (I (cid:15)(cid:48)) ≥ rankM ((I (cid:15)(cid:48))(cid:15)) ≥ rankM (I (cid:15)(cid:48)+(cid:15)),

hence there is an ((cid:15) + (cid:15)(cid:48))-erosion between rankM |I and rankL|I, as desired.

Remark 4.8. From the following example, we can see that dΩ
E is in general a pseudometric.
Let P = R, Ω(cid:15) be the shift by (cid:15) for all (cid:15) ≥ 0. Let M = k{0} and N = 0. Then
rankM (cid:54)= rankN , yet with I = Int(P ), one can easily check dΩ

E(rankM , rankN ) = 0.

In order to guarantee the stability of the generalized rank invariant in dΩ

E, one needs
a special assumption on (P, Ω). Namely, we require that for all I ∈ Int(P ) and (cid:15) ≥ 0,
I ⊆ Ω(cid:15)(I (cid:15)). This is a condition on the pair (P, Ω), and if (P, Ω) satisfy this condition, we
say the pair is accretive.

Here are an example and a non-example of accretive pairs.

Example 4.9. Consider the poset P = R2, with Ω(cid:15)((x, y)) := (x + (cid:15), y + (cid:15)). Fix any
I ∈ Int(P ) and (x, y) ∈ I. Then (x − (cid:15), y − (cid:15)) ∈ I (cid:15), and Ω(cid:15)((x − (cid:15), y − (cid:15))) = (x, y), so
I ⊆ Ω(cid:15)(I (cid:15)). Thus, this (R2, Ω) is an accretive pair.

Example 4.10. Consider the poset P = [0, 4] × [0, 4] ⊂ Z2 from Example 3.11. For (cid:15) ≥ 0
and (x, y) ∈ P, deﬁne Ω(cid:15)((x, y)) := (min(x + (cid:98)(cid:15)(cid:99), 4), min(y + (cid:98)(cid:15)(cid:99), 4)). One can check that
Ω := {Ω(cid:15)}(cid:15)≥0 is a family of superlinear translations on P.

Consider the interval with single point I = {(0, 0)}. Then one computes

I 1 = [(0, 0), (1, 1)] ⊂ Z2. Note that if Ω were extended to Z2, then the thickening of I with
(cid:15) = 1 would contain (−1, −1), but thickenings occur inside a particular poset P, which in
this case does not contain any element below (0, 0) in Z2. From here, if is evident that
Ω1(I 1) = [(1, 1), (2, 2)] ⊂ Z2, and so I (cid:54)⊆ Ω1(I 1), meaning this (P, Ω) is not an accretive
pair.

19

If (P, Ω) is not an accretive pair, then stability of rank|I may fail. Consider the following

example:

Example 4.11. Let P, Ω be as in Example 4.10. Let I = Int(P ). Let M and N be the
P -modules deﬁned as M := kP and N := kP \{(0,0)}. One can check that dΩ
I (M, N ) = 1,
however dΩ
E(rankM , rankN ) = ∞. The latter is due to the fact that if I := {(0, 0)}, then
for all (cid:15) ≥ 0, rankN (I) = 0 < 1 = rankM (I (cid:15)).

In the case of Example 4.11, we can extend P to P (cid:48)

:= (4, 4)↓ ⊂ Z2, and deﬁne
Ω(cid:48) : P(cid:48) → P(cid:48) using the same formula as that for Ω(cid:15) in Example 4.10. One can check that
this (P(cid:48), Ω(cid:48)) is an accretive pair. Deﬁne M (cid:48) : kP and N (cid:48) := kP \{(0,0)}, as P (cid:48)-modules. It is
clear that M (cid:48)|P = M and N (cid:48)|P = N . Similarly to before, we have dΩ(cid:48)
I (M (cid:48), N (cid:48)) = 1, but
now as P (cid:48)-modules, dΩ(cid:48)
E (rankM (cid:48), rankN (cid:48)) = 1. This is because unlike in Example 4.11, in
P(cid:48), rankM (cid:48)({(0, 0)}1) = 0. Many ﬁnite posets P equipped with Ω naturally embed into an
inﬁnite subset P (cid:48) of Zn or Rn, with Ω(cid:48) : P(cid:48) → P(cid:48) an extension of Ω, such that (P(cid:48), Ω(cid:48)) is an
accretive pair. Then extending P -modules to P (cid:48)-modules such as what was done above,
allows us to compare P -modules via their P (cid:48)-module extensions. As (P(cid:48), Ω(cid:48)) is an accretive
pair, Theorem 4.12 below gives us stability for P (cid:48)-modules formed in this way.

Theorem 4.12. Fix Ω be a superlinear family of translations on P such that (P, Ω) is an
accretive pair. Let I ⊆ Int(P ) be a collection of ﬁnite intervals closed under Ω-thickenings.
Then for any P -modules M and N :

dΩ
E(rankM |I, rankN |I) ≤ dΩ

I (M, N )

(8)

Under the assumption that P = Zd or Rd equipped with the standard shift Ω, the

theorem above was proved in [21]. Our proof will be similar.

We make use of a well-known concrete formulation of the limit and colimit of any

M : P → vec (see e.g. [21]):

(i) The limit of M is isomorphic to the pair (L, (πp)p∈P ) described as:

(cid:40)

L :=

((cid:96)p)p∈P ∈

(cid:89)

p∈P

Mp : ∀p ≤ q ∈ P, ϕM (p, q)((cid:96)p) = (cid:96)q

.

(cid:41)

(ii) The colimit of M is isomorphic to a pair (C, (ik)k∈P). For k ∈ P, let ¯ik : Mk →
⊕k∈PMk be the canonical injection. C is the quotient space (⊕k∈PMk) /V , where V
is generated by ¯ik(vk) − ¯i(cid:96)(v(cid:96)) over all k ≤ (cid:96) in P, with vk ∈ Mk, v(cid:96) ∈ M(cid:96). Letting q
be the quotient map from ⊕k∈PMk to C, for k ∈ P, ik : Mk → C is the composition
q ◦ ¯ik.

Proof. If dI(M, N ) = ∞, there is nothing to prove. Assume dΩ
I (M, N ) < ∞, and that there
exists (α, β) an Ω(cid:15)-interleaving. Fix I ∈ I. We show rankN (I (cid:15)) ≤ rankM (I). Consider the
diagram:

lim
←−

N |I (cid:15)

α(cid:48)

lim
←−

M |I

lim
−→

N |I (cid:15)

β(cid:48)

lim
−→

M |I

If α(cid:48), β(cid:48) exist which make this diagram commute, then the limit-to-colimit map on N |I (cid:15)
factors through the limit-to-colimit map on M |I, implying the desired bound on ranks.

20

Deﬁne a(cid:48) by ((cid:96)p)p∈I (cid:15) (cid:55)→ (αp((cid:96)p))Ω(cid:15)(p)∈I. By our additional condition, we have I ⊆ Ω(cid:15)(I (cid:15)),
so this image does deﬁne an element αp((cid:96)p) ∈ MΩ(cid:15)(p) for all q ∈ I. This (αp((cid:96)p))Ω(cid:15)(p)∈I is a
section of M |I by naturality of α.

Deﬁne β(cid:48) by [vp] (cid:55)→ [βp(vp)] for any p ∈ I and vp ∈ Mp. By naturality of β, and since

p ∈ I =⇒ Ω(cid:15)(p) ∈ I (cid:15), β(cid:48) is well-deﬁned.

Fix p0 ∈ I. As noted previously, there exists p(cid:48)

0) = p0, and
also Ω(cid:15)(p0) ∈ I (cid:15). We follow any section ((cid:96)p)p∈I (cid:15) in the previous diagram and observe
commutativity:

0 ∈ I (cid:15) such that Ω(cid:15)(p(cid:48)

(cid:2)(cid:96)p(cid:48)

0

((cid:96)p)p∈I (cid:15)

α(cid:48)

(αp((cid:96)p))Ω(cid:15)(p)∈I

(cid:3) = (cid:2)ϕN (p(cid:48)

0, Ω(cid:15)(p0))((cid:96)p(cid:48)

0

)(cid:3)

β(cid:48)
(cid:2)αp(cid:48)

0

)(cid:3)

((cid:96)p(cid:48)

0

This gives rankN (I (cid:15)) ≤ rankM (I) and a symmetric argument gives rankM (I (cid:15)) ≤ rankN (I (cid:15)),
so dΩ

E(rankM |I, rankN |I) ≤ (cid:15), as desired.

Example 4.13. Let m, n ∈ N and consider the subcollection I := Intm,n(Z2) ⊂ Int(Z2)
consisting solely of ﬁnite intervals of Z2 with at most m minimal points and at most n
maximal points (if m = n = 1, then Intm,n(Z2) is the collection of ﬁnite segments in Z2).
Then Intm,n(Z2) is closed under Ω := (Ω(cid:15) : (x, y) (cid:55)→ (x, y) + ((cid:98)(cid:15)(cid:99), (cid:98)(cid:15)(cid:99))) on Z2, and thus
Theorem 4.12 applies. It is clear that, as m, n increase, the size of Intm,n(Z2) increases and
in turn the computational cost of the LHS in equation (8) increases. In light of Theorem
3.17, the discriminative power of the LHS in equation (8) is also strictly increasing as m, n
increase.

5 Discussions

The proof of Theorem 3.17 relied on the ﬁniteness of the indexing poset P . We are
interested in what the proper analogue of Theorem 3.17 is in the general setting, where P
is inﬁnite. In the comments after the proof of Proposition 3.1, we discussed that Theorem
3.17 statement (i) holds as long as I ⊆ Int(P ) is locally ﬁnite and has a maximal element.
A full and precise generalization of Theorem 3.17 statement (ii) when P is inﬁnite is
still undetermined. In the Theorem statement, we can take any I ⊆ Int(P ), and J (cid:40) I.
We aim to determine, if they exist, necessary and suﬃcient conditions on I and J (cid:40) I
which make Theorem 3.17 statement (ii) hold when P is inﬁnite.

Acknowledgements. This research was partially supported by the NSF through grants
DMS-1723003, IIS-1901360, CCF-1740761, DMS-1547357 and by the BSF under grant
2020124.

References

[1] Hideto Asashiba, Mickaël Buchet, Emerson G Escolar, Ken Nakashima, and Michio
Yoshiwaki. On interval decomposability of 2d persistence modules. Computational
Geometry, 105:101879, 2022.

21

[2] Hideto Asashiba, Emerson G Escolar, Ken Nakashima, and Michio Yoshiwaki. On
approximation of 2 d persistence modules by interval-decomposables. arXiv preprint
arXiv:1911.01637, 2019.

[3] Gorô Azumaya. Corrections and supplementaries to my paper concerning krull-remak-

schmidt’s theorem. Nagoya Mathematical Journal, 1:117–124, 1950.

[4] Magnus Botnan and Michael Lesnick. Algebraic stability of zigzag persistence mod-

ules. Algebraic & geometric topology, 18(6):3133–3204, 2018.

[5] Magnus Bakke Botnan, Vadim Lebovici, and Steve Oudot. On rectangle-decomposable
2-parameter persistence modules. Discrete & Computational Geometry, pages 1–24,
2022.

[6] Magnus Bakke Botnan, Steﬀen Oppermann, and Steve Oudot. Signed barcodes for
multi-parameter persistence via rank decompositions. In 38th International Sympo-
sium on Computational Geometry (SoCG 2022). Schloss Dagstuhl-Leibniz-Zentrum
für Informatik, 2022.

[7] Peter Bubenik, Vin De Silva, and Jonathan Scott. Metrics for generalized persistence

modules. Foundations of Computational Mathematics, 15(6):1501–1531, 2015.

[8] Gunnar Carlsson. Topology and data. Bulletin of the American Mathematical Society,

46(2):255–308, 2009.

[9] Gunnar Carlsson and Vin De Silva. Zigzag persistence. Foundations of computational

mathematics, 10(4):367–405, 2010.

[10] Gunnar Carlsson and Afra Zomorodian. The theory of multidimensional persistence.

Discrete & Computational Geometry, 42(1):71–93, 2009.

[11] Erin Wolf Chambers and David Letscher. Persistent homology over directed acyclic

graphs. In Research in Computational Topology, pages 11–32. Springer, 2018.

[12] Jérémy Cochoy and Steve Oudot. Decomposition of exact pfd persistence bimodules.

Discrete & Computational Geometry, 63(2):255–293, 2020.

[13] William Crawley-Boevey. Decomposition of pointwise ﬁnite-dimensional persistence

modules. Journal of Algebra and its Applications, 14(05):1550066, 2015.

[14] Vin de Silva, Elizabeth Munch, and Anastasios Stefanou. Theory of interleavings on
categories with a ﬂow. Theory and Applications of Categories, 33(21):583–607, 2018.

[15] Tamal K Dey and Tao Hou. Fast computation of zigzag persistence. arXiv preprint

arXiv:2204.11080, 2022.

[16] Tamal K Dey, Woojin Kim, and Facundo Mémoli. Computing generalized rank invari-
ant for 2-parameter persistence modules via zigzag persistence and its applications.
In 38th International Symposium on Computational Geometry (SoCG 2022). Schloss
Dagstuhl-Leibniz-Zentrum für Informatik, 2022.

[17] Herbert Edelsbrunner and John L Harer. Computational topology: an introduction.

American Mathematical Society, 2022.

22

[18] Herbert Edelsbrunner, David Letscher, and Afra Zomorodian. Topological persistence

and simpliﬁcation. Discrete Comput Geom, 28:511–533, 2002.

[19] Peter Gabriel. Unzerlegbare darstellungen i. Manuscripta mathematica, 6(1):71–103,

1972.

[20] Michael Kerber and Alexander Rolle. Fast minimal presentations of bi-graded persis-
tence modules∗. In 2021 Proceedings of the Workshop on Algorithm Engineering and
Experiments (ALENEX), pages 207–220. SIAM, 2021.

[21] Woojin Kim and Facundo Mémoli. Generalized persistence diagrams for persistence
modules over posets. Journal of Applied and Computational Topology, 5(4):533–581,
2021.

[22] Woojin Kim and Samantha Moore. The generalized persistence diagram encodes the

bigraded betti numbers. arXiv preprint arXiv:2111.02551, 2021.

[23] Michael Lesnick. The theory of the interleaving distance on multidimensional persis-
tence modules. Foundations of Computational Mathematics, 15(3):613–650, 2015.

[24] Michael Lesnick and Matthew Wright.

Interactive visualization of 2-d persistence

modules. arXiv preprint arXiv:1512.00180, 2015.

[25] Michael Lesnick and Matthew Wright. Computing minimal presentations and bigraded
betti numbers of 2-parameter persistent homology. SIAM Journal on Applied Algebra
and Geometry, 6(2):267–298, 2022.

[26] Saunders Mac Lane. Categories for the working mathematician, volume 5. Springer

Science & Business Media, 2013.

[27] Alex McCleary and Amit Patel. Bottleneck stability for generalized persistence dia-

grams. Proceedings of the American Mathematical Society, 148(7):3149–3161, 2020.

[28] Alexander McCleary and Amit Patel. Edit distance and persistence diagrams over
lattices. SIAM Journal on Applied Algebra and Geometry, 6(2):134–155, 2022.

[29] Amit Patel. Generalized persistence diagrams. Journal of Applied and Computational

Topology, 1(3):397–419, 2018.

[30] Gian-Carlo Rota. On the foundations of combinatorial theory i. theory of möbius
functions. Zeitschrift für Wahrscheinlichkeitstheorie und verwandte Gebiete, 2(4):340–
368, 1964.

[31] Afra Zomorodian and Gunnar Carlsson. Computing persistent homology. Discrete &

Computational Geometry, 33(2):249–274, 2005.

23

