1

2
2
0
2

l
u
J

0
3

]
L
P
.
s
c
[

1
v
5
1
3
0
0
.
8
0
2
2
:
v
i
X
r
a

Implementing and Verifying Release-Acquire Transactional
Memory (Extended Version)

SADEGH DALVANDI, University of Surrey, UK
BRIJESH DONGOL, University of Surrey, UK

Transactional memory (TM) is an intensively studied synchronisation paradigm with many proposed imple-
mentations in software and hardware, and combinations thereof. However, TM under relaxed memory, e.g.,
C11 (the 2011 C/C++ standard) is still poorly understood, lacking rigorous foundations that support verifiable
implementations. This paper addresses this gap by developing TMS2-ra, a relaxed operational TM specification.
We integrate TMS2-ra with RC11 (the repaired C11 memory model that disallows load-buffering) to provide a
formal semantics for TM libraries and their clients. We develop a logic, TARO, for verifying client programs
that use TMS2-ra for synchronisation. We also show how TMS2-ra can be implemented by a C11 library,
TML-ra, that uses relaxed and release-acquire atomics, yet guarantees the synchronisation properties required
by TMS2-ra. We benchmark TML-ra and show that it outperforms its sequentially consistent counterpart
in the STAMP benchmarks. Finally, we use a simulation-based verification technique to prove correctness of
TML-ra. Our entire development is supported by the Isabelle/HOL proof assistant.

Additional Key Words and Phrases: Weak Memory, Transactional Memory, C11, Verification, Refinement

1 INTRODUCTION

The advent and proliferation of architectures implementing relaxed memory models has resulted
in many new challenges in the development of concurrent programs. In the context of the C/C++
relaxed memory model defined by C111, over a decadeâ€™s worth of research has resulted in rigorous
semantic foundations [Batty et al. 2016, 2011; Kang et al. 2017; Lahav et al. 2017; Lee et al. 2020;
Paviotti et al. 2020], and more recently, logics for reasoning about the correctness of concurrent
programs [Dalvandi et al. 2020a, 2022; Doherty et al. 2019; Doko and Vafeiadis 2017; He et al.
2016; Kaiser et al. 2017; Kang et al. 2017; Lahav and Vafeiadis 2015; Vafeiadis and Narayan 2013;
Wright et al. 2021]. These works have provided the background necessary to develop high-level
abstractions and concurrency libraries over relaxed-memory architectures. Recent works have
included reimplementations of concurrent data structures [Dalvandi and Dongol 2021; Dongol et al.
2018b; Emmi and Enea 2019; Krishna et al. 2020; Raad et al. 2019a], including those with relaxed
specifications that aim to exploit the additional behaviours allowed by relaxed memory.

Our aim for this paper is to implement and verify synchronisation abstractions, fine-tuned for
C11, in the form of transactional memory (TM) libraries, which provide reusable foundations for
high-performance, yet easy to manage concurrency control [Guerraoui and Kapalka 2010; Herlihy
and Moss 1993; Shavit and Touitou 1997]. Implementations include those in software (as STM
libraries) and hardware (Intel-RTM and Armv9). Other variations include hybrid TM that combine
software and hardware TMs and implementations that are natively supported by the compiler (e.g.,
the continued C++ TM Lite development). In addition to supporting general-purpose concurrency,
TM has also been used to develop transactional concurrent objects and data structures [Assa et al.
2020, 2021; Bronson et al. 2010; Lesani et al. 2022]. Intelâ€™s persistent memory development kit
(PMDK) [Scargall 2020] extensively promotes the transactional paradigm (though multi-threaded

1C11 refers to the 2011 ISO specification of C/C++.

Authorsâ€™ addresses: Sadegh Dalvandi, m.dalvandi@surrey.ac.uk, University of Surrey, Guildford, UK; Brijesh Dongol,
b.dongol@surrey.ac.uk, University of Surrey, Guildford, UK.

2022. 2475-1421/2022/12-ART1 $15.00
https://doi.org/

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

 
 
 
 
 
 
1:2

Sadegh Dalvandi and Brijesh Dongol

transactions are not directly supported by PMDKâ€™s transactions). These prior works have assumed
SC transactions, i.e., that transactional access provide the same guarantees as sequentially consistent
memory. Our focus is the verification of STMs implemented as a programming language library
with relaxed, release, acquire and release-acquire accesses providing a pathway towards simplified
development of transactional objects (including concurrent data structures) for relaxed memory.
TM implementations provide fine-grained interleaving (for efficiency) that execute with an
illusion of atomicity (for correctness). A completed transaction may be committed or aborted so
that all or none of its effects are externally visible. TM implementations are designed to satisfy
a variety of correctness conditions such as (strict) serialisability, opacity, and snapshot isolation,
which restrict ordering possibilities of completed transactions. TM has been extensively studied
for sequentially consistent (SC) architectures [Lamport 1979], but implementations over relaxed
memory are limited.

Prior works on relaxed memory transactions (e.g., [Chong et al. 2018; Dongol et al. 2018a])
have focussed on foundations of hardware transactions and their interaction with relaxed memory
models, e.g., the expected isolation guarantees, reordering possibilities etc. The work of Chong et
al [Chong et al. 2018] also provides for semantics of native C++ transactions. However, native TM
support in C++ is still in a state of flux [Spear et al. 2020; Zardoshti et al. 2019] and the underlying
designs have changed since the original works by Chong et al [Chong et al. 2018]. Moreover,
these semantics are presented in an axiomatic (aka declarative) style, which cannot be used to
verify TM implementations, where we require operational descriptions of correctness. Therefore,
our point of departure is a separate set of works on TM specifications, in particular the TMS2
specification [Doherty et al. 2013], which has been used extensively as a TM specification for
standard (i.e., SC) architectures.

More recent works have taken steps towards C++ implementations, including native support of
TM within C++ [Zardoshti et al. 2019] and STMs implemented using C++ relaxed memory [Ro-
driguez and Spear 2020]. However, Zardoshti et al. [2019] do not describe interactions with the C11
relaxed memory model, while Rodriguez and Spear [Rodriguez and Spear 2020] focus on data race
freedom and privatisation guarantees. Neither of these works have a formal semantics, nor are
they supported by a verification methodology. (See Â§7 for a more comprehensive survey of related
works.)

Our work addresses several gaps in the current state-of-the-art of transactions for C/C++. We
work with RC11, i.e., the repaired C11 memory model [Lahav et al. 2017]. The RC11 memory model
disallows program-order and reads-from cycles, and hence disallows load-buffering behaviour.
This restriction greatly simplifies reasoning and variants of RC11 are supported by a number of
different logics [Dalvandi et al. 2020a; Dalvandi and Dongol 2021; Dalvandi et al. 2022; Dang et al.
2022; Kaiser et al. 2017; Lahav and Vafeiadis 2015]. Logics that address the full C11 memory model
(allowing load buffering) have also been developed, but proofs in these logics are limited to small
litmus tests [Svendsen et al. 2018; Wright et al. 2021].

We develop: (i) a reusable specification of TM that provides well-defined guarantees to those
developing client programs; (ii) techniques for verifying client programs in C11 that use such
TM abstractions; (iii) implementations of TM in C11, including their rigorous verification; and
(iv) mechanisation of the verification described above in the theorem prover Isabelle/HOL. We
discuss these contributions in more detail below.

Correctness specifications. To enable verification, we start with the TMS2 specification [Doherty
et al. 2013]. TMS2 implies the TMS1 specification, which is known to be both necessary and
sufficient for observational refinement (of client programs) [Attiya et al. 2018]. The main difference
between TMS1 and TMS2 is that TMS1 allows aborted transactions to observe different serialization

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:3

orders [Lesani et al. 2012]. In contrast, TMS2, like opacity [Guerraoui and Kapalka 2010], ensures
strict serializability of the committed transactions and furthermore that aborted transactions are
consistent with the serialisation order. Although more restrictive than TMS1, TMS2 has been shown
to be a robust correctness condition that is useful in practice, providing a specification for a number
of TM implementations under SC [Armstrong and Dongol 2017; Armstrong et al. 2017; Derrick
et al. 2018; Doherty et al. 2016].

Under relaxed memory, the TMS2 specification is inadequate since it does not provide any of the
client-side guarantees required by relaxed memory libraries [Dalvandi and Dongol 2021; Dongol
et al. 2018b; Raad et al. 2019a, 2018]. Such client-side guarantees are required under relaxed memory
since writes in one thread are not guaranteed to be propagated to other threads unless the library
is properly synchronised (cf. the message passing litmus tests [Alglave et al. 2014]).

Our first contribution is the adaptation of TMS2 to address this issue. In particular, our specifi-
cation, TMS2-ra, provides a flexible meaning of correctness, allowing a client to specify relaxed,
releasing, acquiring and release-acquiring transactions (see Â§3), mimicking the memory annotations
of C11 atomics [Batty et al. 2011]. This provides greater flexibility in TM design; we develop a
model in which these different types of transactions co-exist within the same TM system.

Client verification. Our second contribution (see Â§5) is a verification technique for relaxed-
memory client programs that use TMS2-ra. In particular, we prove correctness of several variations
of the message passing litmus test, synchronised through TMS2-ra transactions, to show that
TMS2-ra behaves as expected. In particular, we show how different client-side guarantees are
achieved depending on the type of synchronisation guarantee (relaxed, releasing or acquiring)
guaranteed by the transaction in question.

Our verification framework includes a new logic, TARO, capable of efficiently reasoning about the
views of a client programs [Dalvandi et al. 2022; Kaiser et al. 2017]. This means that the correctness
of programs can be established using a standard Owicki-Gries reasoning framework [Dalvandi
et al. 2020a; Dalvandi and Dongol 2021; Owicki and Gries 1976].

Implementation, benchmarking and verification. Our third contribution is the implementation and
full verification of an STM algorithm that uses C11 relaxed/release-acquire atomics and implements
TMS2-ra. Our implementation is an adaptation of Dalessandro et alâ€™s Transactional Mutex Lock
(TML) [Dalessandro et al. 2010], which presents a simple mechanism for synchronising transactions
optimised for read-heavy workloads. TML is synchronised using a single global lock, and allows
multiple concurrent read-only transactions, but at most one writing transaction, i.e., a writing
transaction causes all other concurrent transactions to abort.

Interestingly, our adapted algorithm, which we call TML-ra, allows more concurrency than TML
by exploiting the parallelism afforded by relaxed and release-acquire C11 atomics. Moreover, a
writing transaction does not force other read-only transactions to abort, allowing greater read/write
parallelism (see Â§4). We show that this theoretical speedup manifests in real implementations and
TML-ra outperforms its SC counterpart in all STAMP benchmarks (see Â§4.3).

We use a simulation-based verification method for the C11 memory model [Dalvandi and Dongol
2021] to prove correctness of TML-ra. This proof establishes a refinement between TML-ra and
TMS2-ra, which ensures that all observable behaviours of TML-ra are observable behaviours of
TMS2-ra. Thus, if a client program ğ¶ is proved correct when it uses TMS2-ra, then ğ¶ will also be
correct if we replace calls to TMS2-ra in ğ¶ by calls to TML-ra.

Mechanisation. Our fourth contribution is the mechanisation of all proofs presented in the
paper in the Isabelle/HOL proof assistant (available as supplementary material). This includes
the operational semantics of C11 integrated with TMS2-ra, soundness of all TARO rules, the use

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:4

Sadegh Dalvandi and Brijesh Dongol

Thread ğœ1 Thread ğœ2
1 : ğ‘‘ := 5;
2 : ğ‘“ := 1;

3 : do ğ‘Ÿ1 â† ğ‘“

until ğ‘Ÿ1 = 1;

4 : ğ‘Ÿ2 â† ğ‘‘;
{ğ‘Ÿ2 = 0 âˆ¨ ğ‘Ÿ2 = 5}
(a) Unsynchronised MP

Thread ğœ1
1 : ğ‘‘ := 5;
2 : ğ‘“ :=R 1;

Thread ğœ2
3 : do ğ‘Ÿ1 â†A ğ‘“
until ğ‘Ÿ1 = 1;

4 : ğ‘Ÿ2 â† ğ‘‘;

{ğ‘Ÿ2 = 5}
(b) Synchronised MP

Fig. 1. Message passing (MP) in C11

of TARO to prove several client programs that use TMS2-ra, and finally the proof of simulation
between TMS2-ra and TML-ra.2

Overview. This paper is structured as follows. We describe our requirements for relaxed and
release-acquire transactions in Â§2. We formalise this semantics in Â§3 via the TMS2-ra specification,
and describe its integration with a view-based semantics for RC11 with release-acquire atom-
ics [Dalvandi et al. 2020a]. In Â§4, we provide an examplar implementation and benchmarking results
for TML-ra. In Â§5, we present our logic for reasoning about release-acquire transactional memory,
which provides a method of reasoning about client programs that use the TMS2-ra specification.
Finally, in Â§6, we present a proof of correctness of TML-ra via refinement w.r.t. TMS2-ra.

2 TRANSACTIONAL GUARANTEES IN C11

A TM specification in a relaxed memory setting has two distinct sets of goals. The first set must
guarantee the expected behaviours of transactions, e.g., serializability, opacity etc. The second must
provide client-side guarantees, e.g., release-acquire synchronisation, observational refinement etc.
We consider both in our TMS2-ra specification (see Fig. 4).

2.1 Release-acquire synchronisation

Prior to detailing the design choices of TMS2-ra, we recap the basics of release-acquire synchroni-
sation in C11, including a recently developed timestamp-based operational semantics, which is the
semantics assumed by TMS2-ra.

The fragment of C11 we focus on is the RC11-RAR fragment. The first â€œRâ€ denotes the repairing
model [Lahav et al. 2017], which precludes â€˜thin-airâ€™ behaviour by disallowing memory operations
within a thread to be reordered. The â€œRARâ€ refers to the fact that the model includes release-acquire
as well as relaxed atomics [Dalvandi et al. 2020b; Doherty et al. 2019]. 3 For the remainder of this
paper, we simply write C11 to refer to RC11-RAR.

We explain the main ideas behind release-acquire synchronisation using the message passing
(MP) litmus test in Figs. 1a and 1b. It comprises two shared variables: ğ‘‘ (for data) and ğ‘“ (for a flag),
both of which are initially 0. Under SC, the postcondition of the program is ğ‘Ÿ2 = 5 because the loop
in thread ğœ2 only terminates after ğ‘“ has been updated to 1 in thread ğœ1, which in turn happens after
ğ‘‘ is set to 5. Therefore, the only possible value of ğ‘‘ that thread ğœ2 can read is 5.

However, in Fig. 1a, all read/write accesses of ğ‘‘ and ğ‘“ are relaxed, and hence the program can
only establish the weaker postcondition ğ‘Ÿ2 = 0 âˆ¨ ğ‘Ÿ2 = 5 since it is possible for thread ğœ2 to read 0
for d at line 4. In particular, reading 1 for ğ‘“ does not guarantee that thread ğœ2 will read 5 for ğ‘‘.

2Our development may be found in [Dalvandi and Dongol 2022].
3Note that extending this model to include other types of C11 synchronisation (e.g., SC fences) and relaxations that allow
intra-thread ordering is possible [Wright et al. 2021], but these extended models are not so interesting for the purposes of
this paper, and the additional complexity that they induce detracts from our main contributions.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:5

Thread ğœ1
1 : ğ‘‘ := 5;
2 : TxBegin(R)
3 : TxWrite(ğ‘“ , 1) ;
4 : TxEnd ;

Thread ğœ2
5 : do
TxBegin(A, {r1})
6 :
TxRead(ğ‘“ , ğ‘Ÿ1) ;
7 :
TxEnd ;
8 :
9 : until ğ‘Ÿ1 = 1
10 : ğ‘Ÿ2 â† ğ‘‘

{ğ‘Ÿ2 = 5}

Thread ğœ1
1 : ğ‘‘1 := 5;
2 : TxBegin(RX, âˆ…) ;
3 : TxWrite(ğ‘‘2, 10) ;
4 : TxWrite(ğ‘“ , 1) ;
5 : TxEnd ;

Thread ğœ2
6 : TxBegin(RX, {r1, r2})
7 : TxRead(ğ‘“ , ğ‘Ÿ1) ;
8 : if ğ‘Ÿ1 = 1 then
9 :
10 : TxEnd;
11 : ğ‘Ÿ3 â† ğ‘‘1;

TxRead(ğ‘‘2, ğ‘Ÿ2) ;

{ğ‘Ÿ1 = 1 â‡’ ğ‘Ÿ2 = 10 âˆ§ ğ‘Ÿ3 âˆˆ {0, 5}}

(a) Transactional MP

(b) Relaxed transactions

Thread ğœ1
1 : ğ‘‘1 := 5;
2 : TxBegin(R, âˆ…)
3 : TxWrite(ğ‘“ , 1) ;
4 : TxEnd;

Thread ğœ2
5 : ğ‘‘2 := 10;
6 : TxBegin(RA, {r2})
7 : TxRead(ğ‘“ , ğ‘Ÿ2) ;
8 : if ğ‘Ÿ2 = 1 then
9 :
10 : TxEnd;
{ğ‘Ÿ3 = 2 â‡’ ğ‘ 1 = 5 âˆ§ ğ‘ 2 = 10}
(c) Extended transactional MP

TxWrite(ğ‘“ , 2)

Thread ğœ3
11 : TxBegin(A, {r3})
12 : TxRead(ğ‘“ , ğ‘Ÿ3) ;
13 : TxEnd ;
14 : if ğ‘Ÿ3 = 2 then
ğ‘ 1 â† ğ‘‘1
15 :
ğ‘ 2 â† ğ‘‘2
16 :

Fig. 2. Transactional memory client interactions

This anomaly is corrected in Fig. 1b where the highlighted code depicts the necessary changes.
In particular, we introduce a release annotation (line 2) as well as an acquire annotation (line 3),
which together induces a happens-before relation if the read of ğ‘“ at line 3 reads from the write at
line 2 (see [Batty et al. 2011]). This in turn ensures that thread ğœ2 sees the most recent write to ğ‘‘ at
line 1. We explain how relaxed accesses and release-acquire synchronisation is formalised by the
operational semantics in Â§3.1.

2.2 Transactional message passing

We now describe the guarantees provided by our transactional model in the context of a client
program. Like standard reads and writes in C11, we allow transactions to be combined with a
synchronising annotation, which may be one of relaxed (RX), releasing (R), acquiring (A), or release-
acquiring (RA). These annotations dictate whether or not transaction induces a client-side happens
before. In particular, client-side happens-before is induced from thread ğœ1 to thread ğœ2 if (i) a read
in transaction ğ‘¡2 executed by ğœ2 reads-from a write in transaction ğ‘¡1 executed by ğœ1, (ii) ğ‘¡1 contains
a release annotation (either R or RA), and (iii) ğ‘¡2 contains an acquire annotation (either A or RA).
We illustrate the implications of these annotations via the examples in Fig. 2, where the highlights
are used to identify the transactions. We assume that a client provides a transaction with a set of
registers that it may use when the transaction begins (see Â§3).

Fig. 2a describes a transactional variation of MP. Thread ğœ1 comprises a (non-transactional)
relaxed write on ğ‘‘ followed by a transactional write of the flag, ğ‘“ . Thread ğœ2 contains a transactional
read of ğ‘“ within a loop that terminates if ğœ2 reads 1 for ğ‘“ . After the loop terminates, ğœ2 performs a
(non-transactional) relaxed read of ğ‘‘. In this example, like Fig. 1b, the release and acquire annotations
induce a happens-before relation from ğœ1 to ğœ2 and hence ensure that the read of ğ‘‘ in ğœ2 does not
return the stale value, 0.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:6

Sadegh Dalvandi and Brijesh Dongol

Fig. 2b describes a program that uses a relaxed transaction. The postcondition of the program
considers the case where the transaction in ğœ1 occurs before the transaction in ğœ2 since the an-
tecedent assumes that ğ‘Ÿ1 = 1, i.e., the read of ğ‘“ at line 7 reads the write of ğ‘“ at line 4. In this example,
both transactions are relaxed, and hence, the ordering of transactions above does not induce a
happens before from ğœ1 to ğœ2. Thus, the read of ğ‘‘1 at line 11 is not guaranteed to see the write of ğ‘‘1
at line 1, i.e., the final value of ğ‘Ÿ3 is either 0 or 5. However, since the write and read of ğ‘‘2 occurs
within the transactions of ğœ1 and ğœ2, respectively, if ğ‘Ÿ1 = 1, then ğœ2 is guaranteed to read 10 for ğ‘‘2.
Finally, Fig. 2c demonstrates a program with an RA transaction. The antecedent of the programâ€™s
postcondition implies that the transaction in ğœ3 occurs after the transaction in ğœ2, which in turn
occurs after the transaction in ğœ1. Here, the transaction annotations ensure that the writes to
ğ‘‘1 and ğ‘‘2 (at lines 1 and 5) performed by the client are seen by the client reads at lines 15 and
16. This is because the transaction in ğœ2 (annotated by RA) is guaranteed to synchronise with
the transaction in ğœ1 (annotated by R), and similarly, the transaction in ğœ2 (annotated by A) is
guaranteed to synchronise with the transaction in ğœ2 (annotated by RA). Note that if the transaction
in ğœ2 was only releasing, then ğœ1 and ğœ2 would not synchronise, and the read at line 15 may return
either 0 or 5. Yet, the read at line 16 would still be guaranteed to return 10 for ğ‘‘2 since ğœ2 and ğœ3
synchronise. If the transaction in ğœ2 was only acquiring, then ğœ2 and ğœ3 would not synchronise.
In this case, although ğœ1 and ğœ2 have synchronised, neither of the reads at lines 15 and 16 are
guaranteed to return the new writes at lines 1 and 5.

Deciding a transactionâ€™s synchronisation flag ultimately comes down to the needs of a client
program, much like memory_order parameters on atomic_compare_exchange instructions in
C11 [cppreference.com 2022]. Client programs that require message passing through transactions
would use release-acquire, while others may only require relaxed annotations.

3 RELEASE-ACQUIRE TM SPECIFICATION

With the basic requirements for release-acquire and transactional synchronisation in place, we
work towards a formal TM specification. Our specification will be closely tied to an operational
semantics for C11 with timestamped writes and per-thread views [Dalvandi et al. 2020a; Dolan
et al. 2018; Kaiser et al. 2017; Kang et al. 2017; Podkopaev et al. 2016] (see Â§3.1). We integrate this
model with a TM specification in Â§3.3.

3.1 View-based operational semantics
As discussed above, in our model, the C11 relaxed memory state is formalised by timestamped writes.
Instead of mapping each location to a value, the state contains a set of writes writes âŠ† Write,
where Write = Loc Ã— Val Ã— TS represents a write to a location Loc with value Val and ğ‘‡ ğ‘† Ë†= Q is
the set of possible timestamps. If ğ‘¤ âˆˆ Write and ğ‘¤ = (ğ‘¥, ğ‘£, q), then we let loc(ğ‘¤) Ë†= ğ‘¥, val(ğ‘¤) Ë†= ğ‘£,
tst(ğ‘¤) Ë†= q, be the functions that extract the location, value and timestamp of ğ‘¤, respectively.

A view is a mapping from a location to a write of that location, i.e., View Ë†= Loc â†’ Write. To
define the allowable reads by each thread to each location, the state also records a thread view for
each thread define by a function

tview : TId â†’ View
where TId Ë†= N is the set of thread identifiers. A thread may read from any write whose timestamp
is no smaller than the threadâ€™s current view. Thus, the observable values (OV ), i.e., the set of values
that thread ğœ can read for location ğ‘¥ is

OW ğœ (ğ‘¥) Ë†= (cid:8)w âˆˆ writes loc(w) = ğ‘¥ âˆ§ tst(w) â‰¥ tst(tviewğœ (ğ‘¥))(cid:9)
OV ğœ (ğ‘¥) Ë†= {val(w) | w âˆˆ OW ğœ (ğ‘¥)}

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:7

ğ‘‘

ğ‘“

0, 0

ğœ2

0, 0

ğœ1

ğ‘‘

ğ‘“

ğœ2

0, 0

ğœ1

0, 0

5, 1

ğœ0

ğœ1

ğ‘‘

ğ‘“

0, 0

5, 1

ğœ2

0, 0

ğœ1
1R ,1

ğœ2

ğ‘‘

ğ‘“

0, 0

5, 1

ğœ2

0, 0

ğœ1
1R ,1

ğœ3

Fig. 3. Synchronised message passing views

A write may be introduced at any timestamp greater than the threadâ€™s current view (with a caveat
that ensures atomicity of read-modify-writes, see [Dalvandi et al. 2020a; Doherty et al. 2019] for
details).

Finally, to formalise release-acquire synchronisation, a state in the timestamp model also includes

a notion of a modification view,

mview : Write â†’ View
which is a function that records the thread view of the executing thread when a new write is
introduced to writes. In particular, if thread ğœ introduces a new write w to writes and tviewğœ is
updated to ğ‘£ğ‘–ğ‘’ğ‘¤ in this new state, then mview is also updated so that mvieww = ğ‘£ğ‘–ğ‘’ğ‘¤ in the new
state. This information is used to update thread views in case release-acquire synchronisation
occurs.

Formally, when threads synchronise, a new view is calculated using âŠ—, which is defined as

follows. Given ğ‘‰1, ğ‘‰2 âˆˆ View, we have

ğ‘‰1 âŠ— ğ‘‰2 Ë†= ğœ†ğ‘¥ . if tst(ğ‘‰2(ğ‘¥)) â‰¤ tst(ğ‘‰1(ğ‘¥)) then ğ‘‰1(ğ‘¥) else ğ‘‰2(ğ‘¥)
which constructs a new view by taking the write with the larger timestamp for each location ğ‘¥.

Example 1 (Synchronised MP). Consider Fig. 3, which depicts a possible execution of the program
in Fig. 1b. Each â€œğ‘£, ğ‘–â€ represents a â€œvalue, timestampâ€ pair for the location in question. The initial
state is ğœ0, where the views of threads ğœ1 and ğœ2 are both the initial writes. State ğœ1 occurs after
executing line 1, where the view of ğœ1 is updated to the new write on ğ‘‘. Similarly, ğœ2 occurs
after executing line 2. Note that the new write is tagged with a release annotation. Moreover,
the operational semantics guarantees that in ğœ2, we have ğœ2.mview( ğ‘“ ,1,1) (ğ‘‘) = (ğ‘‘, 5, 1), i.e., the
modification view of the write (ğ‘“ , 1, 1) returns (ğ‘‘, 5, 1) for ğ‘‘ (since this was the thread view of ğœ1
for ğ‘‘ when the write at line 2 occurred).

Finally, ğœ3 depicts the state after execution of line 3, where the read returns the value 1 for
ğ‘“ . In this case, the thread view of ğœ2 for ğ‘“ is updated to the new read. More importantly, due to
release-acquire annotations the semantics enforces that the thread view of ğœ2 for ğ‘‘ in ğœ3 is also
updated to the new modification view, i.e., ğœ2.mview(ğ‘“ ,1,1) (ğ‘‘). Thus, after state ğœ3, ğœ2 will no longer
be able to return the stale value 0 for ğ‘‘.

The key difference in execution of the unsynchronised example (Fig. 1a) is that the read at line 3
does not update tviewğœ2(ğ‘‘). Hence, for the state of Fig. 1a analogous to ğœ3, the view of ğœ2 for ğ‘‘
will remain at the initial write, allowing it to return a stale value.

3.2 TMS2
First, we consider the TMS2 specification, which is our TMS2-ra specification without any client-
side release-acquire guarantees. This is given by the unhighlighted components of Fig. 4, which

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:8

Sadegh Dalvandi and Brijesh Dongol

correspond precisely to the internal actions of TMS2 [Doherty et al. 2013].4 Note that each action
of Fig. 4 is atomic and guarded by the conditions defined in pre. If all the conditions in pre hold
the transition is enabled, and the corresponding action atomically updates the state according to
the assignments and functions in eff. If some condition in pre does not hold then the transition is
blocked. We use âŠ“ to denote a non-deterministic choice (see [Lynch 1996] for details).

TMS2 is a close operational approximation of opacity [Guerraoui and Kapalka 2010]. The dif-
ferences between TMS2 and opacity are minor [Lesani et al. 2012], and much of the discussion
below applies equally to opacity. TMS2 (and opacity) distinguishes between completed and live
transactions, where completed transaction may either be committed or aborted. TMS2 guarantees
the existence of a total order â‰º over all transactions such that:

(1) if transaction ğ‘¡1 executes TxEnd before ğ‘¡2 executes TxBegin, then ğ‘¡1 â‰º ğ‘¡2;
(2) for any transaction ğ‘¡, if â‰ºâ†“ğ‘¡ is the strict downclosure of ğ‘¡ w.r.t. â‰º and ğ‘š is the memory

obtained by applying the committed transactions in â‰ºâ†“ğ‘¡ in order, then
â€¢ all internal reads in ğ‘¡ for a variable ğ‘¥ are consistent with the last write to ğ‘¥ in ğ‘¡, and
â€¢ all external reads of ğ‘¡ are consistent with ğ‘š.

Note that conditions (1) and (2) together imply strict serialisability of the transactions. Condition (2)
additionally ensures that no transaction reads from an aborted or live transaction since all external
writes can be explained by the prior writes of committed transactions only. Moreover, reads of
all transactions (including aborted and live transactions) never return a spurious value, i.e., each
non-aborting read can be explained by prior committed transactions.

The existence of the total order mentioned above is guaranteed by the TMS2 specification as
follows. Each transaction ğ‘¡ comprises a local read set, rdSetğ‘¡ , local write set, wrSetğ‘¡ , and variable,
statusğ‘¡ that is used to model control flow within a transaction. If the status of ğ‘¡ is NOTSTARTED, ğ‘¡
may transition to status READY if a thread ğœ executes TxBeginğœ . Once ready, ğœ may execute some
number of TxRead and TxWrite operations, or TxEnd, which sets the status of ğ‘¡ (the transaction
that ğœ is executing) to COMMITTED. Note that if transaction ğ‘¡ is READY, it may transition to status
ABORT at any time. Moreover, in some circumstances, ğ‘¡ may be forced to abort because all other
transitions of ğ‘¡ are blocked. For example, if ğ‘¡ is a writing transaction and ğ‘¡â€™s read set is not a subset
of last (ğ‘€), then ğ‘¡ must abort.

To ensure read/write consistency, TMS2 uses a sequence of memories ğ‘€, where a memory is a
mapping from locations to values. A transaction ğ‘¡ records the earliest memory it can read from by
setting beginIdxğ‘¡ to the last index of ğ‘€ when ğ‘¡ executed TxBeginğœ . Moreover, each committing
writing transaction ğ‘¡ constructs a new memory ğ‘ = last (ğ‘€) âŠ• wrSetğ‘¡ which is the memory last (ğ‘€)
overwritten with the write set of ğ‘¡. It then appends ğ‘ to the end of ğ‘€ (see TxEndWR).

We differentiate between internal reads TxReadInt and external reads TxReadExt, by whether
the read location ğ‘¥ is in the write set of the executing transaction, ğ‘¡. An internal read of ğ‘¥ simply
returns the value of ğ‘¥ in the write set of ğ‘¡. An external read of ğ‘¥ non-deterministically picks a
memory index ğ‘–. This read is enabled iff ğ‘– is a valid index (i.e., is between beginIdxğ‘¡ and the last
memory index, |ğ‘€ | âˆ’ 1) and the read set of ğ‘¡ is consistent with ğ‘€ğ‘– (i.e., the memory at index ğ‘–). In
case an external read occurs, the read set is updated and the value read is returned. This means
that all external reads in ğ‘¡ are validated with respect to some memory snapshot between beginIdxğ‘¡
and the maximum memory index. Note that it is possible for two different reads to validate w.r.t.
different memory snapshots.

TMS2 prescribes a lazy write-back strategy via TxWrite, where writes are cached in a local write
set until the commit occurs (as described above). However, as we shall see, this does not preclude

4TMS2-ra, like TMS2 is presented as an I/O automaton [Lynch 1996]. For simplicity, we eschew the external actions, but
they can easily be included to formalise the TM interface.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:9

implementations that use eager write-backs, where writes occur in memory at the time of writing
(see [Derrick et al. 2018]). In fact, the TML-ra algorithm, our main case study in this paper, is such
an eager algorithm (see Â§4).

We split the commit phase into two cases: read-only (modelled by TxEndRO) and writing (modelled
by TxEndWR). Since all reads are validated at the time of reading, a read-only transaction can simply
commit the transaction. On the other hand, the writing transaction must ensure its reads are valid
w.r.t. the last memory snapshot. The effect of this transition is to install a new memory snapshot as
described above.

The final component of ğ‘¡ is a local set regsğ‘¡ that is used to keep track of the set of registers that
the transaction has written to. A client provides the set of registers to be used by each transaction
when the transaction begins. These registers are set to a special value âŠ¥ when a transaction aborts
to ensure that no value read by ğ‘¡ is seen outside ğ‘¡.

3.3 TMS2-ra

We now discuss the release-acquire extensions of TMS2-ra, as defined by the I/O automata algorithm
in Fig. 4, including the highlighted components. The key extension of TMS2-ra is its ability to
synchronise client threads, thus allowing it to cope with the examples in Fig. 2. Formally, this is
achieved by ensuring TMS2-ra synchronises the thread view of the client whenever transactional
release-acquire synchronisation occurs.

We introduce two new local variables in transaction ğ‘¡. Namely, synctypeğ‘¡ , which records the
type of synchronisation of ğ‘¡, and seenIdxsğ‘¡ , which records the set of all memory indices seen
by ğ‘¡ that are either releasing or release-acquiring. We also introduce a new thread local variable
txview, which records the transaction thread view of ğœ. The transaction thread view is similar to
thread view introduced in Â§3.1. The difference here is in the definition of View. In this context the
View is a function that maps the threads to memory indexes of ğ‘€. The transaction view of ğœ is
the smallest memory in ğ‘€ that can be read by any transaction ğ‘¡ that was begun by thread ğœ. We
also introduce two global variables. Namely ğ‘†, which is a sequence recording the type of each
committed writing transaction that installs each new memory in ğ‘€, and ğ‘‰ which is a sequence of
modification views for each new memory in ğ‘€. Thus, in TMS2-ra, memory ğ‘€ğ‘– has synchronisation
type ğ‘†ğ‘– , and modification view ğ‘‰ğ‘– .

The transactional operations of TMS2 are modified as follows. In TxBeginğ‘¡ , we take as input the
type of synchronisation transaction ğ‘¡ is to perform, and store this value in synctypeğ‘¡ . Another
input to TxBeginğ‘¡ is ğ‘š, an index to a visible memory ğ‘€. We also initialise seenIdxsğ‘¡ to the empty
set. In TxReadExtğ‘¡ (ğ‘¥, ğ‘–), i.e., a transition for external read of ğ‘¥ from memory index ğ‘–, we record the
index ğ‘– in seenIdxsğ‘¡ if the memory ğ‘€ğ‘– is releasing or release-acquiring.

When a transaction ends (for both read-only and writing transactions), if the transaction is
acquiring or release-acquiring and seenIdxsğ‘¡ is non-empty, we construct a new view nv to be the
maximum modification view for each transaction in seenIdxsğ‘¡ using the function view. We use this
to synchronise the client threadâ€™s view by updating tviewğœ to tviewğœ âŠ— nv. For a writing transaction,
we record this new view of the client in ğ‘‰ so that any future transactions that synchronise with
this new transaction does so with respect to this view. Finally, once a transaction ends, it updates
txview to the largest index in seenIdxs.

We demonstrate the interaction of TMS2-ra and a client program by considering the views of
three possible executions of the programs in Fig. 5. Unlike the trace considered in Fig. 3, we only
show the most critical transitions. The memory sequence ğ‘€ of TMS2-ra is clear from the figures.
We represent ğ‘† by the superscripts on each state of ğ‘€, and the modification views ğ‘‰ by the dotted
arrows (

) from each state of ğ‘€.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:10

Sadegh Dalvandi and Brijesh Dongol

TxBeginVğœ ( sflag , ğ‘š ,regSet)
pre statusğ‘¡ = NOTSTARTED

txnğœ = âŠ¥
ğ‘š âˆˆ OMğœ
eff wrSetğ‘¡ :=âˆ…
rdSetğ‘¡ :=âˆ…
beginIdxğ‘¡ := ğ‘š
seenIdxsğ‘¡ :=âˆ…
synctypeğ‘¡ :=sflag
regsğ‘¡ :=regSet
txnğœ :=ğ‘¡
statusğ‘¡ :=READY

TxWriteğœ (ğ‘¥, ğ‘£)
pre statusğ‘¡ = READY

txnğœ = ğ‘¡

eff wrSetğ‘¡ :=wrSetğ‘¡ âˆª{ğ‘¥ â†¦â†’ ğ‘£ }

TxReadIntğœ (ğ‘¥, ğ‘Ÿ )
pre statusğ‘¡ = READY

ğ‘¥ â†¦â†’ ğ‘£ âˆˆ wrSetğ‘¡
ğ‘Ÿ âˆˆ regsğ‘¡
txnğœ = ğ‘¡

eff ğ‘Ÿ :=ğ‘£

TxReadExtğœ (ğ‘¥, ğ‘–, ğ‘Ÿ )
pre statusğ‘¡ = READY
ğ‘¥ âˆ‰ dom(wrSetğ‘¡ )
beginIdxğ‘¡ â‰¤ ğ‘– < |ğ‘€ |
rdSetğ‘¡ âŠ† ğ‘€ğ‘–
txnğœ = ğ‘¡

TxEndROğœ
pre statusğ‘¡ = READY
wrSetğ‘¡ = âˆ…
txnğœ = ğ‘¡

eff statusğ‘¡ :=COMMIT

if synctypeğ‘¡ âˆˆ {A, RA} âˆ§ seenIdxsğ‘¡ â‰  âˆ…
then

let nv = view(seenIdxsğ‘¡ ,V) in
tviewğœ := tviewğœ âŠ— nv

txnğœ :=âŠ¥
txviewğœ := max(seenIdxsğ‘¡ )

TxEndWRğœ
pre statusğ‘¡ = READY
wrSetğ‘¡ â‰  âˆ…
rdSetğ‘¡ âŠ† last (ğ‘€)
txnğœ = ğ‘¡

eff ğ‘€:= ğ‘€ Â· (last (ğ‘€) âŠ• wrSetğ‘¡ )

statusğ‘¡ :=COMMIT
if synctypeğ‘¡ âˆˆ {A, RA} âˆ§ seenIdxsğ‘¡ â‰  âˆ…
then

let nv = view(seenIdxsğ‘¡ ,V) in

ğ‘‰ := ğ‘‰ Â· (tviewğœ âŠ— nv)
tviewğœ := tviewğœ âŠ— nv

else ğ‘‰ := ğ‘‰ Â· tviewğœ
ğ‘†:= ğ‘† Â· synctypeğ‘¡
txnğœ :=âŠ¥
txviewğœ := max(seenIdxsğ‘¡ )

Abortğœ
pre statusğ‘¡ = READY

eff rdSetğ‘¡ :=rdSetğ‘¡ âˆª {ğ‘¥ â†¦â†’ ğ‘€ğ‘– (ğ‘¥)}

txnğœ = ğ‘¡

if ğ‘†ğ‘– âˆˆ {R, RA}
then seenIdxsğ‘¡ := seenIdxsğ‘¡ âˆª {ğ‘–}
ğ‘Ÿ :=ğ‘€ğ‘– (ğ‘¥)

eff âˆ€ğ‘  âˆˆ regsğ‘¡ . ğ‘ :=âŠ¥

txnğ‘¡ :=âŠ¥
statusğ‘¡ :=ABORT

TxReadğœ (ğ‘¥, ğ‘Ÿ ) =

TxReadIntğœ (ğ‘¥) âŠ“

(cid:46)

ğ‘– TxReadExtğœ (ğ‘¥, ğ‘–, ğ‘Ÿ )

TXBeginğœ (sflag, regSet) =
TxEndğœ = TxEndROğœ âŠ“ TxEndWRğœ

(cid:46)

ğ‘š TXBeginVğœ (sflag, ğ‘š, regSet)

where
ğ‘€ : seq(Loc â†’ Val), initially ğ‘€ = âŸ¨(ğœ†ğ‘£ âˆˆ Loc.0)âŸ©
ğ‘‰ : seq(Loc â†’ TS), initially ğ‘‰ = âŸ¨(ğœ†ğ‘£ âˆˆ Loc.0)âŸ©
OMğœ = {ğ‘› | ğ‘› â‰¥ txviewğœ âˆ§ ğ‘› â‰¤ |ğ‘€ | âˆ’ 1}

ğ‘† : seq{RX, R, A, RA}, initially ğ‘† = âŸ¨RXâŸ©
view(Idxs, Vf ) = ğœ†ğ‘™ âˆˆ Loc. maxWr{Vf ğ‘– (ğ‘™) | ğ‘– âˆˆ Idxs}

Fig. 4. TMS2-ra specification: highlighted components are extensions necessary for client synchronisation
for C11 transactions. We assume that the transactions are executed by thread ğœ. Moreover, let ğ‘„ Â· ğ‘ be the
sequence ğ‘„ appended with element ğ‘ and ğ‘“ âŠ• ğ‘” be the function ğ‘“ overridden by function ğ‘”. Finally, let maxWr
be a function that returns the write with the largest timestamp in the given set of writes.

Fig. 5a represents part of an execution of the program in Fig. 2a. In the execution depicted, we
assume that all of thread ğœ1 executes before ğœ2. Here, ğœ2 is the state after executing line 4, where

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:11

ğ‘€

ğ‘‘

ğœ2

{ğ‘“ â†¦â†’ 0}RX

{ğ‘“ â†¦â†’ 1}R

0, 0

ğœ1

5, 1

ğ‘€
{ğ‘“ â†¦â†’ 0}RX

{ğ‘“ â†¦â†’ 1}R

ğ‘‘

ğœ2

0, 0

ğœ1

5, 1

ğœ2 (after executing
line 4)

ğœ3 (after executing
line 8)

ğœ2

ğœ1

ğ‘‘1

(cid:27)RX

0, 0

ğ‘€
(cid:26)ğ‘“ â†¦â†’ 0,
ğ‘‘2 â†¦â†’ 0
(cid:26)ğ‘“ â†¦â†’ 1,
ğ‘‘2 â†¦â†’ 10
ğœ2 (after executing
line 5)

5, 1

(cid:27)RX

ğœ2

ğœ1

ğ‘‘1

(cid:27)RX

0, 0

ğ‘€
(cid:26)ğ‘“ â†¦â†’ 0,
ğ‘‘2 â†¦â†’ 0
(cid:26)ğ‘“ â†¦â†’ 1,
ğ‘‘2 â†¦â†’ 10
ğœ3 (after executing
line 10)

5, 1

(cid:27)RX

(a) Views for transactional MP (Fig. 2a)

(b) Views for relaxed transactions (Fig. 2b)

ğ‘€
(cid:8)ğ‘“ â†¦â†’ 0(cid:9)RX

(cid:8)ğ‘“ â†¦â†’ 1(cid:9)R

ğ‘‘1

ğ‘‘2

0, 0

0, 0

5, 1

ğœ3

ğœ2

ğœ1

ğ‘€
(cid:8)ğ‘“ â†¦â†’ 0(cid:9)RX

ğ‘‘1

ğ‘‘2

0, 0

0, 0

(cid:8)ğ‘“ â†¦â†’ 1(cid:9)R

5, 1

10, 1

ğœ3

ğœ2

ğœ1

ğ‘€
(cid:8)ğ‘“ â†¦â†’ 0(cid:9)RX

ğ‘‘1

ğ‘‘2

0, 0

0, 0

ğœ3

ğœ2

(cid:8)ğ‘“ â†¦â†’ 1(cid:9)R

5, 1

10, 1

ğœ1

ğœ2 (after executing line 4)

(cid:8)ğ‘“ â†¦â†’ 2(cid:9)RA
ğœ4 (after executing line 10)
(c) Views for release-acquire transaction chain (Fig. 2c)

(cid:8)ğ‘“ â†¦â†’ 2(cid:9)RA
ğœ5 (after executing line 13)

Fig. 5. Views for the transaction-based client program from Fig. 2

ğœ1 has introduced a new write to ğ‘‘ and then executed its (releasing) transaction, introducing a
new memory snapshot whose modification view becomes the new write of ğ‘‘ (since ğœ1â€™s thread
view is at this new write). Then, when ğœ2 executes its (acquiring) transaction that reads 1 from ğ‘“ , it
synchronises with the latest memory snapshot, causing ğœ2â€™s thread view to be the new write of ğ‘‘ as
well. This is analogous, as required, to the way in which views are updated in C11 (see Fig. 3).

Fig. 5b represents a part execution of the program in Fig. 2b. Again, we assume a complete
execution of thread ğœ1 followed by ğœ2. State ğœ2 is the state after executing line 5, where ğœ1 has
introduced a new write to ğ‘‘1. Now consider the state ğœ3 (the state after execution of line 10), where
ğœ1 introduces a new memory snapshot in ğ‘€ with annotation RX and modification view pointing to
the new write on ğ‘‘1. When ğœ2 continues execution, its transaction must be ordered after the latest
memory snapshot, but this will not induce a release-acquire synchronisation. This means that ğœ2â€™s
view of ğ‘‘2 will not be updated. However, since ğœ2â€™s transaction occurs after ğœ1â€™s transaction, ğœ2
is guaranteed to read 10 for ğ‘‘2. Note that the transaction executed by ğœ2 is a read-only relaxed
transaction, the view of ğœ2 of the client variable (ğ‘‘1) is unchanged. However, ğœ2â€™s view of the
transactional memory (not shown in the diagrams) will be updated to the new memory state
{ğ‘“ â†¦â†’ 1, ğ‘‘2 â†¦â†’ 10}.

Finally, Fig. 5c represents part of an execution of Fig. 2c comprising the complete execution of
ğœ1, ğœ2 then ğœ3 in order. State ğœ2 represents the state after executing line 4, where the modification
view of the newly installed memory is consistent with the view of the executing thread ğœ1. Then,
in ğœ4 (the state after execution of line 10), we have a new write on ğ‘‘2 with value 10 and a further
new snapshot that synchronises with the snapshot {ğ‘“ â†¦â†’ 1}R causing the thread view of ğœ2 and
the modification view of the new snapshot to be updated to the last writes of ğ‘‘1 and ğ‘‘2. Next, in ğœ5,
when ğœ3 executes its transaction, this transaction is guaranteed to synchronise with {ğ‘“ â†¦â†’ 2}RA,

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:12

Sadegh Dalvandi and Brijesh Dongol

TxBeginğœ (sflag, ğ‘š, regSet)

ğ›¾ .statusğ‘¡ = NOTSTARTED

ğ‘š âˆˆ ğ‘£ğ‘šğ‘’ğ‘šğ‘ ğœ
ğ›¾ .txnğœ = âŠ¥
beginIdxğ‘¡ := ğ‘š, seenIdxsğ‘¡ := âˆ…, rdSetğ‘¡ := âˆ…,
wrSetğ‘¡ := âˆ…, synctypeğ‘¡ := sflag, regsğ‘¡ := regSet,
statusğ‘¡ = READY, txnğœ := ğ‘¡

lst, ğ›¾, ğ›½

ğœ lst, ğ›¾

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

, ğ›½

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£»

TxWriteğœ (ğ‘™, ğ‘£)

ğ›¾ .statusğ‘¡ = READY
ğœ lst, ğ›¾ (cid:2)wrSetğ‘¡ := ğ›¾ .wrSetğ‘¡ âˆª {ğ‘™ â†¦â†’ ğ‘£ }(cid:3) , ğ›½

ğ›¾ .txnğœ = ğ‘¡

lst, ğ›¾, ğ›½

ğ›¾ .statusğ‘¡ = READY

ğ›¾ .txnğœ = ğ‘¡

ğ‘Ÿ âˆˆ ğ›¾ .regsğ‘¡

(ğ‘™ âˆˆ dom(ğ›¾ .wrSetğ‘¡ ) âˆ¨ (ğ›¾ .beginIdxğ‘¡ â‰¤ ğ‘– âˆ§ ğ›¾ .rdSetğ‘¡ âŠ† ğ›¾ .Mğ‘– ))
ğ‘£ = if ğ‘™ âˆ‰ dom(ğ›¾ .wrSetğ‘¡ ) then ğ›¾ .Mğ‘– (ğ‘™) else ğ›¾ .wrSetğ‘¡ (ğ‘™)

seenIdxsâ€² = if ğ‘™ âˆ‰ dom(ğ›¾ .wrSetğ‘¡ ) âˆ§ ğ›¾ .ğ‘†ğ‘– âˆˆ {R, RA}

then ğ›¾ .seenIdxsğ‘¡ âˆª {ğ‘–} else ğ›¾ .seenIdxsğ‘¡

TxReadğœ (ğ‘™, ğ‘Ÿ )

rdSetâ€² = if ğ‘™ âˆ‰ dom(ğ›¾ .wrSetğ‘¡ ) then ğ›¾ .rdSetğ‘¡ âˆª {ğ‘™ â†¦â†’ ğ‘£ } else ğ›¾ .rdSetğ‘¡
ğœ lst [ğ‘Ÿ := ğ‘£], ğ›¾ (cid:2)rdSetğ‘¡ := rdSetâ€², seenIdxsğ‘¡ := seenIdxsâ€²(cid:3) , ğ›½

lst, ğ›¾, ğ›½

ğ›¾ .statusğ‘¡ = READY

ğ›¾ .txnğœ = ğ‘¡

ğ›¾ .wrSetğ‘¡ = âˆ…

tviewâ€² = if ğ›¾ .rdSetğ‘¡ â‰  âˆ… âˆ§ ğ›¾ .synctypeğ‘¡ âˆˆ {A, RA} âˆ§ ğ›¾ .seenIdxsğ‘¡ â‰  âˆ…

TxEndROğœ

then ğ›½.tviewğœ âŠ— view(ğ›¾ .seenIdxsğ‘¡ , ğ›¾ .ğ‘‰ ) else ğ›½.tviewğœ

lst, ğ›¾, ğ›½

ğœ lst, ğ›¾

(cid:20)statusğ‘¡ := COMMITTED,
txviewğœ := max(ğ›¾ .seenIdxsğ‘¡ )

(cid:21)

, ğ›½ [tviewğœ := tviewâ€²]

ğ›¾ .statusğ‘¡ = READY

ğ›¾ .txnğœ = ğ‘¡

ğ›¾ .wrSetğ‘¡ â‰  âˆ…

ğ‘– = |ğ›¾ .M |

Sâ€² = ğ›¾ .synctypeğ‘¡

ğ‘šğ‘’ğ‘šâ€² = (last (ğ›¾ .M) âŠ• ğ›¾ .wrSetğœ )

tviewâ€² = if ğ›¾ .rdSetğ‘¡ â‰  âˆ… âˆ§ ğ›¾ .synctypeğ‘¡ âˆˆ {A, RA} âˆ§ ğ›¾ .seenIdxsğ‘¡ â‰  âˆ…

TxEndWRğœ

then ğ›½.tviewğœ âŠ— view(ğ›¾ .seenIdxsğ‘¡ , ğ›¾ .ğ‘‰ ) else ğ›½.tviewğœ

lst, ğ›¾, ğ›½

ğœ lst, ğ›¾

statusğ‘¡ := COMMITTED, Mğ‘– := ğ‘šğ‘’ğ‘šâ€²
Sğ‘– := Sâ€², Vğ‘– := tviewâ€²
txviewğœ := max(ğ›¾ .seenIdxsğ‘¡ )

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£»

, ğ›½ [tviewğœ := tviewâ€²]

TxAbortğœ

ğ›¾ .statusğ‘¡ = READY

ğ›¾ .txnğœ = ğ‘¡

lst â€² = ğœ†ğ‘Ÿ âˆˆ Reg. if ğ‘Ÿ âˆˆ ğ›¾ .regsğ‘¡ then âŠ¥ else lst (ğ‘Ÿ )

lst, ğ›¾, ğ›½

ğœ lst â€², ğ›¾ (cid:2)statusğ‘¡ := ABORTED(cid:3) , ğ›½

Fig. 6. Operational semantics for TMS2-RA

causing ğœ3â€™s view to be updated to the latest writes of ğ‘‘1 and ğ‘‘2, which is inherited from the
modification view of {ğ‘“ â†¦â†’ 2}RA.

3.4 Modular operational semantics

To reason about clients that use abstract TMS2-ra transactions in a modular fashion, we use
configurations that are triples (lst, ğ›¾, ğ›½), where lst : Reg â†’ Val denotes the local register state, ğ›¾ is
the TMS2-ra state (which includes all transactional variables described in Fig. 4) and ğ›½ is the C11
state of the client (see [Dalvandi et al. 2020a, 2022], Â§A).

The transition relation for transactional operations is given in Fig. 6. These follow the automata-
style description given in Fig. 4, but make state components that are affect more precise. The most

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:13

Init: glb := 0
TxBegin(regSet)
ğµ1 : regs := regSet
ğµ2 : hasRead := false ;
ğµ3 : do loc â†A glb;
ğµ4 : until ğ‘’ğ‘£ğ‘’ğ‘›(loc)
TxWrite(ğ‘¥, ğ‘£)
ğ‘Š1 : if ğ‘’ğ‘£ğ‘’ğ‘›(loc) then
ğ‘Š2 :
ğ‘Š3 :
ğ‘Š4 :
else loc := loc + 1;
ğ‘Š5 :
ğ‘Š6 : ğ‘¥ :=R ğ‘£; // WRITE OK

ğ‘Ÿ1 â† CASRA (glb, loc, loc + 1)
if Â¬ğ‘Ÿ1 then

âˆ€ğ‘  âˆˆ regs. ğ‘  := âŠ¥; return; // ABORT

TxEnd
ğ¸1 : if ğ‘œğ‘‘ğ‘‘ (loc) then
glb :=R loc + 1;
ğ¸2 :

if ğ‘Ÿ âˆˆ regs then

ğ‘Ÿ â†A ğ‘¥;
if Â¬hasRead âˆ§ ğ‘’ğ‘£ğ‘’ğ‘›(loc) then
ğ‘Ÿ1 â† CASRA (glb, loc, loc)
if ğ‘Ÿ1 then

TMRead(ğ‘¥, ğ‘Ÿ )
ğ‘…1 :
ğ‘…2 :
ğ‘…3 :
ğ‘…4 :
ğ‘…5 :
ğ‘…6 :
ğ‘…7 :
ğ‘…8 :
ğ‘…9 :
ğ‘…10 :
return; // READ OK
ğ‘…11 :
ğ‘…12 : âˆ€ğ‘  âˆˆ regs. ğ‘  := âŠ¥; // ABORT

hasRead := ğ‘¡ğ‘Ÿğ‘¢ğ‘’;
return; // READ OK

ğ‘Ÿ1 â† glb;
if ğ‘Ÿ1 = loc then

else

Fig. 7. TML-ra: A release-acquire transactional mutex lock. For simplicity, the thread id is omitted

interesting aspect of these rules is the interaction between a releasing writing transaction and
subsequent committing reading transaction.

Note that each releasing writing transaction sets ğ‘†ğ‘– (where ğ‘– is last index in ğ‘€ at the time of
writing) to either R or RA. Additionally, the view of the thread at the time of writing is recorded
in ğ‘‰ğ‘– . A later transaction with an acquiring annotation calculates a new view using the function
view as defined in Fig. 4 and updates, among other components, the executing threadâ€™s view in ğ›½.
This means that, as expected, if there is a release-acquire synchronisation through a transactional
memory library, then the clientâ€™s view will be updated to match the synchronisation that occurs.

4 A C11 STM IMPLEMENTATION

In this section, we develop a release-acquire version of a transactional mutex lock, that we call
TML-ra, based on an SC implementation by Dalessandro et al [Dalessandro et al. 2010]. Our
algorithm is provided in Fig. 7, where the highlights indicate the fragments of code that we have
introduced or modified. The grey highlights represent code additional to Dalessandro et alâ€™s original
implementation, and the blue highlights represent the necessary release-acquire synchronisation.
We first discuss the core features of TML (Â§4.1), then discuss the extensions introduced in TML-ra
to optimise for C11 release-acquire synchronisation (Â§4.2). We present the benchmarking results
for both algorithms in Â§4.3. In Â§6, we present a proof that TML-ra implements TMS2-ra, i.e., any
observation a client program makes when it uses TML-ra is a possible observation when it uses
TMS2-ra.

4.1 TML

TML is synchronised using a single global counter glb, initialised to 0, where glb is even iff no
writing transaction is currently executing.

A transaction begins by taking a snapshot of glb in local variable loc and only begins if the

value read is even.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:14

Sadegh Dalvandi and Brijesh Dongol

A write operation checks that loc is even and if so, it attempts to increment glb using the
CAS at line ğ‘Š2. If this CAS succeeds, it increments loc (line ğ‘Š5), then immediately updates the
location ğ‘¥ (line ğ‘Š6). If the CAS fails, the transaction aborts. Note that if loc is odd then the current
transaction â€œownsâ€ the lock, meaning that lines ğ‘Š2-ğ‘Š5 can be bypassed.

A read operation (ignoring lines ğ‘…3-ğ‘…7 for now) reads the given location into the given register
ğ‘Ÿ (line ğ‘…2). At lines ğ‘…9 and ğ‘…10 it checks that glb is consistent with loc. If so, the read succeeds,
otherwise, the transaction aborts.

A transaction ends by checking whether the current transaction is a writing transaction. This can
be determined by checking whether loc is odd since a writing transaction must have incremented
glb via the CAS at line ğ‘Š2 and loc via the write at line ğ‘Š5 making both their values odd. Therefore,
a writing transaction must increment glb to make it even again.

4.2 TML-ra

We now describe the necessary modifications to TML and the synchronisation induced by TMS2-ra.
We assume that transactions in TML-ra are all release-acquiring and hence we omit the transaction
annotation in TxBegin.

We assume all accesses to shared variables are either relaxed (e.g., the read at line ğ‘…9), releasing
(e.g., the write at line ğ¸2), acquiring (e.g., the read at line ğµ2) or release-acquiring (e.g., the CAS
at line ğ‘…4). Additionally, we introduce a new local variable hasRead, initially set to false and a
code path ğ‘…3-ğ‘…7, which is followed if a transaction performs a read without having previously
performed a read or a write. We explain the purpose of this code path in more detail below.

Transaction synchronisation. Recall that TMS2-ra requires that transactions are consistent w.r.t.
a single memory snapshot and that external reads of a transaction synchronise with some memory
snapshot. This may not occur in a relaxed memory context without adequate synchronisation. In
particular, a writing transaction must perform a releasing write to glb at line ğ¸2 so that if a later
transaction reads from this write, it synchronises with all of the writes performed by the writing
transaction. To ensure this, we require the read of glb at line ğµ3 as well as the CAS operations at
lines ğ‘Š2 and ğ‘…4 to be acquiring. Note that this also guarantees release-acquire client synchronisation.
The second key synchronisation is between ğ‘Š6 performed by a writing transaction ğ‘¡ğ‘¤ and ğ‘…2
performed by a (different) reading transaction ğ‘¡ğ‘Ÿ . Suppose that both ğ‘¡ğ‘¤ and ğ‘¡ğ‘Ÿ are live. If ğ‘¡ğ‘Ÿ happens
to read the write written at ğ‘Š6, it must now abort because ğ‘¡ğ‘Ÿ â€™s snapshot of glb will be inconsistent
with the latest value of glb installed by the ğ‘¡ğ‘¤. The release-acquire synchronisation between ğ‘Š6
and ğ‘…1 ensures that this will happen, i.e., ğ‘¡ğ‘Ÿ will see the new glb written by ğ‘¡ğ‘¤, causing the test at
ğ‘…10 to fail and ğ‘¡ğ‘Ÿ to abort.

Causal linearizability. The design of TML-ra ensures that all transactions, including read-only
transactions are causally linearizable [Doherty et al. 2018], which is a condition that additionally
guarantees compositionality (or locality [Herlihy and Wing 1990; Sela et al. 2021]) of concurrent
objects. This notion of compositionality is that of Herlihy and Wing [Herlihy and Wing 1990].
In particular, under SC memory, given a history comprising several concurrent objects, if the
history restricted to each object is linearizable, then the history as a whole is linearizable. In a
relaxed memory setting, Doherty et al [Doherty et al. 2018] have shown that linearizability alone is
insufficient to guarantee compositionality, and it is necessary to induce a â€œhappens-beforeâ€ relation
when a specification induces a particular linearization.

The happens-before required by causal linearizability is naturally achieved for writing transac-
tions via the CAS at line ğ‘Š2. For a read-only transaction, we introduce the CAS at line ğ‘…4, which
installs a new write to glb without changing its value. All transactions that follow the CAS at line
ğ‘…4 will be causally ordered after the reading transaction. Such a CAS must only be performed once,

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:15

Fig. 8. Results of STAMP benchmarks for TML-ra and TML-sc

thus we introduce a local variable hasRead, which is set to true if the CAS succeeds so that later
reads from the same transaction can avoid the code path from ğ‘…3-ğ‘…7.

Note that the conditions necessary to guarantee causal linearizability (and hence composition-
ality) could have been introduced at the level of TMS2-ra. However, there are questions about
whether the notion of compositionality introduced by Herlihy and Wing [Herlihy and Wing 1990]
are appropriate in a relaxed memory context [Raad et al. 2019a]. Therefore we leave out the causal
linearizability conditions in TMS2-ra to avoid over-constraining the specification.

4.3 Benchmarking

We implemented two versions of the TML algorithm: TML-ra (see Fig. 7) and TML-sc (the SC
counterpart [Dalessandro et al. 2010]) and benchmarked both using the STAMP benchmarking
suite [Minh et al. 2008]. Each experiment was repeated 20 times to rule out external loads on the
test machine and an average of these times was taken. The results of the six benchmarks that we
ran with STAMP are presented in Fig. 8. TML-ra is equivalent to or outperforms TML-sc in almost
all cases, with a maximum improvement of 20%. On average, TML-ra performs 8.2% better than
TML-sc.

Unsurprisingly, since TML optimises read-heavy workloads, its performance degrades under
high write contention, and this is consistent with prior results [Dalessandro et al. 2010]. However,
it is interesting that the degradation of TML-ra is not as severe as TML-sc for the Intruder and
SSCA2 benchmarks.

TML-ra theoretically allows more parallelism than TML-sc since a read-only transaction ğ‘¡ğ‘Ÿ
is not forced to abort if a writing transaction ğ‘¡ğ‘¤ executes after ğ‘¡ğ‘Ÿ â€™s first read operation - ğ‘¡ğ‘Ÿ must
only aborts if it sees ğ‘¡ğ‘¤â€™s ğ‘”ğ‘™ğ‘ update, or one of ğ‘¡ğ‘¤â€™s writes. Both Intruder and SSCA2 have a large
number of short transactions; SSCA2 additionally has small read/write sets [Minh et al. 2008]. Here,
TML-ra may be able to exploit the theoretical parallelism. In the single-threaded case, TML-ra
executes far fewer heavyweight CASs.

As with prior results, we see that for the read-heavy benchmark Genome, the performance of

both TML-ra and TML-sc improves as the number of threads increases.

5 TARO: A LOGIC FOR RELEASE-ACQUIRE TM

The development of view-based operational semantics for various fragments of C11 [Dalvandi et al.
2020a; Kaiser et al. 2017; Kang et al. 2017] has provided foundations for several logics for reasoning
about C11 programs. These include separation logics [Kaiser et al. 2017; Svendsen et al. 2018]

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:16

Sadegh Dalvandi and Brijesh Dongol

(cid:8)[ğ‘‘ = 0]ğœ1 âˆ§ [ğ‘‘ = 0]ğœ2 âˆ§ [ğ‘“ = 0]ğœ1 âˆ§ [ğ‘“ = 0]ğœ2

(cid:9)

Thread ğœ1
(cid:8)Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 âˆ§ [ğ‘‘ = 0]ğœ1
1 : ğ‘‘ := 5;
(cid:8)Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 âˆ§ [ğ‘‘ = 5]ğœ1
2 : TxBegin(R, âˆ…)
(cid:26)Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 âˆ§ [ğ‘‘ = 5]ğœ1
âˆ§ Relğœ1

(cid:9)

(cid:9)

(cid:27)

3 : TxWrite(ğ‘“ , 1) ;
(cid:26)Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 âˆ§ [ğ‘‘ = 5]ğœ1
âˆ§ Relğœ1 âˆ§ ( Ë†ğ‘“ , 1) âˆˆ WSğœ1

(cid:27)

4 : TxEnd;
(cid:8)true(cid:9)

Thread ğœ2
5 : do
(cid:8)âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2
(cid:9)
6 : TxBegin(A, {r1})
(cid:8)âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2 âˆ§ WSğœ2 = âˆ… âˆ§ Acqğœ2
7 : TxRead(ğ‘“ , ğ‘Ÿ1) ;
(cid:40)
âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2 âˆ§ WSğœ2 = âˆ… âˆ§ Acqğœ2
âˆ§ ( Ë†ğ‘“ , ğ‘Ÿ1) âˆˆ RSğœ2 âˆ§ (ğ‘Ÿ1 = 1 â‡’ [ğ‘‘ ğ‘†

(cid:9)

= 5]ğœ2)

(cid:41)

8 : TxEnd ;
(cid:8)âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2 âˆ§ (ğ‘Ÿ1 = 1 â‡’ [ğ‘‘ = 5]ğœ2)(cid:9)
9 : until ğ‘Ÿ1 = 1
(cid:8)[ğ‘‘ = 5]ğœ2
10 : ğ‘Ÿ2 â† ğ‘‘
(cid:8)ğ‘Ÿ2 = 5(cid:9)

(cid:9)

{ğ‘Ÿ2 = 5}

Fig. 9. Proof outline for transactional MP from Fig. 2a

and extensions to Owicki-Gries reasoning [Dalvandi et al. 2020a, 2022; Lahav and Vafeiadis 2015;
Wright et al. 2021]. Our point of departure is the Owicki-Gries encoding for RC11 RAR [Dalvandi
et al. 2020a], which is the fragment of C11 that we focus on in this paper.5

A key benefit of the logic in [Dalvandi et al. 2020a] is that it enables reuse of standard Owicki-
Gries proof decomposition rules and straightforward mechanisation in Isabelle/HOL [Dalvandi
et al. 2020b, 2022]. As we shall see, we maintain these benefits in the context of C11 with release-
acquire transactions. Our reasoning framework, called TARO, like Dalvandi et al [Dalvandi et al.
2020a; Dalvandi and Dongol 2021] uses view-based assertions to abstractly describe the system
state, allowing reasoning about the current view of a thread, and view transfer from one thread to
another through release-acquire synchronisation. TARO introduces additional assertions to enable
reasoning about transactional views.

5.1 View-based assertions

In this section, we discuss the assertions and proof rules of TARO abstractly. The proof rules can be
used to reason syntactically about a program without having to understand the low-level operational
semantics of the C11 model. Our operational semantics is an extension of prior works [Dalvandi
et al. 2020a; Kaiser et al. 2017; Kang et al. 2017] that include an encoding of TMS2-ra.

To motivate TARO, consider the proof outline in Fig. 9 for the transactional message passing
program from Fig. 2a. We use â€˜Ë†â€™ to distinguish transactional locations in a proof. For the program
in Fig. 9, we have a transactional location Ë†ğ‘“ .

5.1.1 View assertions. The proof outline contains three assertions from [Dalvandi et al. 2020a]
describing the views that each thread may have of the system state. Recall (Â§3.1), that we can define
the set of values that a thread can see in each state using the function ğ‘‚ğ‘‰ .

â€¢ A definite value assertion, denoted [ğ‘¥ = ğ‘£]ğœ , holds iff thread ğœ sees the last write to location ğ‘¥

and this write has value ğ‘£. Thus, [ğ‘¥ = ğ‘£]ğœ â‡’ ğ‘‚ğ‘‰ğœ (ğ‘¥) = {ğ‘£ }.

5These frameworks are based on models that assume top-level parallelism only. Therefore, our framework similarly
re assumes top-level paralellism. This model can be extended to support dynamic parallelism, but such extensions are
uninteresting for the purposes of this paper.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:17

â€¢ A possible value assertion, denoted [ğ‘¥ â‰ˆ ğ‘£]ğœ , which holds iff when ğœ can see a write to ğ‘¥ with

value ğ‘£. [ğ‘¥ â‰ˆ ğ‘£]ğœ is shorthand for ğ‘£ âˆˆ ğ‘‚ğ‘‰ğœ (ğ‘¥).

â€¢ A conditional value assertion, denoted âŸ¨ğ‘¦ = ğ‘¢âŸ©[ğ‘¥ = ğ‘£]ğœ , which holds iff an acquiring read of ğ‘¦
by ğœ that returns the value ğ‘¢ is guaranteed to induce a release-acquire synchronisation so
that [ğ‘¥ = ğ‘£]ğœ holds after this read.

Example 2. Consider the third state, i.e., ğœ2 in Fig. 3. There, we have [ğ‘‘ = 5]ğœ1 âˆ§ [ğ‘“ = 1]ğœ1 as well
as [ğ‘“ â‰ˆ 0]ğœ2 âˆ§ [ğ‘“ â‰ˆ 1]ğœ2. Moreover, we have âŸ¨ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2.

We ask the interested reader to consult [Dalvandi et al. 2020a, 2022] for further details of these

assertions.

5.1.2 Transactional assertions. As alluded to above, TARO introduces several new assertions to
describe the transactional state. These assertions are, in general, local to the transaction being
executed, and hence, stable under the execution of other threads. Fig. 9 contains the following
transaction local assertions:

â€¢ Relğœ , which holds iff ğœ is executing a releasing or release-acquiring transaction.
â€¢ Acqğœ , which holds iff ğœ is executing an acquiring or release-acquiring transaction.
â€¢ ( Ë†ğ‘¥, ğ‘£) âˆˆ WSğœ (and ( Ë†ğ‘¥, ğ‘£) âˆˆ RSğœ ), which holds iff ğœ is executing a transaction whose write set

(resp. read set) contains a write to (resp. read of) Ë†ğ‘¥ with value ğ‘£.

â€¢ [ğ‘¥ ğ‘†

= ğ‘£]ğœ , which holds iff ğœ is executing a transaction such that committing this transaction

results in the definite value assertion [ğ‘¥ = ğ‘£]ğœ (see above).

In addition, we include a number of assertions This section provides the formal definition for
the assertion language used in the verification of client programs that use TMS2-RA (See Â§5.1).
The assertion language presented here is heavily inspired by the view-based assertion language
presented in [Dalvandi et al. 2020a].

A memory ğ‘– is visible to a transaction executed by a thread ğœ iff ğ‘– is greater than the transaction
thread view of ğœ (txviewğœ ) and is less than the maximum index of the memory (|ğ‘€ | âˆ’ 1). We define
the set of visible memories OMğ‘¡ to be:

OMğœ = {ğ‘› | ğ‘› â‰¥ txviewğœ âˆ§ ğ‘› â‰¤ |ğ‘€ | âˆ’ 1}

â€¢ A transactional definite observation assertion, denoted [ Ë†ğ‘¥ = ğ‘£]ğ‘¡ , holds iff for all memory
versions ğ‘–, where ğ‘– is greater than or equal to beginIdxğ‘¡ , the value of Mğ‘– (ğ‘¥) is ğ‘£. Formally,
for a transactional state ğ›¾:

[ Ë†ğ‘¥ = ğ‘£]ğœ (ğ›¾)

Ë†= âˆ€ğ‘– âˆˆ ğ›¾ .OMğœ . ğ›¾ .Mğ‘– ( Ë†ğ‘¥) = ğ‘£

These are lifted to client-object states (ğ›¾, ğ›½) in the normal manner, e.g., [ Ë†ğ‘¥ = ğ‘£]ğœ (ğ›¾, ğ›½) = [ Ë†ğ‘¥ =
ğ‘£]ğœ (ğ›¾)

â€¢ A transactional possible observation assertion, denoted [ Ë†ğ‘¥ â‰ˆ ğ‘£]ğœ , holds iff there exists a

memory version ğ‘– that has value ğ‘£ for Ë†ğ‘¥. Formally:

[ Ë†ğ‘¥ â‰ˆ ğ‘£]ğœ (ğ›¾)

Ë†= âˆƒğ‘– âˆˆ ğ›¾ .OMğœ . ğ›¾ .Mğ‘– ( Ë†ğ‘¥) = ğ‘£

â€¢ A transactional conditional observation assertion, denoted âŸ¨ Ë†ğ‘¦ = ğ‘¢âŸ©[ğ‘¥ = ğ‘£]ğœ , holds iff an
acquiring transactional read of ğ‘¦ by ğœ that returns a value ğ‘¢ is guaranteed to induce a release-
acquire synchronisation so that [ğ‘¥ ğ‘†
= ğ‘£]ğœ holds in the client state after the reading transaction
successfully commits. Formally:

âŸ¨ Ë†ğ‘¦ = ğ‘¢âŸ©[ğ‘¥ = ğ‘£]ğœ (ğ›¾, ğ›½)

Ë†= âˆ€ğ‘– âˆˆ ğ›¾ .OMğœ . ğ›¾ .Mğ‘– ( Ë†ğ‘¦) = ğ‘¢ â‡’

ğ›¾ .Vğ‘– (ğ‘¥) = ğ›½.ğ‘™ğ‘ğ‘ ğ‘¡ (ğ‘¥) âˆ§ val(ğ›½.last (ğ‘¥)) = ğ‘£ âˆ§ ğ›¾ .Sğ‘–

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:18

Sadegh Dalvandi and Brijesh Dongol

where ğ‘™ğ‘ğ‘ ğ‘¡ (ğ‘¥) is the last write to ğ‘¥ in the modification order. It is important to note that this
assertion is over two states: transaction state ğ›¾ and client state ğ›½, explaining transfer of infor-
mation across two threads using the transactional memory. In particular, the transactional
view ğ‘‰ğ‘– for the memory index ğ‘– must see the last write to ğ‘¥ in the client state ğ›½. This means
that the thread that committed the transaction writing the value ğ‘¢ to Ë†ğ‘¦ did so when it saw
the last write to ğ‘¥.

Example 3. Returning to our transactional MP example (Fig. 9), the precondition of line 1 contains
assertions Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 and [ğ‘‘ = 0]ğœ1, which ensure that, prior to executing line 1, thread ğœ2 cannot
see the value 1 for Ë†ğ‘“ and thread ğœ1 must see the value 0 for ğ‘‘, respectively. In the postcondition
of line 2, [ğ‘‘ = 0]ğœ1 changes to [ğ‘‘ = 5]ğœ1 since ğœ1 performs a write to ğ‘‘ with value 5. The other
view-based assertions in ğœ1 are similar. We explain the transactional assertions involving Rel and
WS below.

Now consider the assertions in thread ğœ2. The precondition of line 6 (which is also the precondition
of line 5) contains a conditional value assertion âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2. This assertion ensures that, if
ğœ2 reads the value 1 for Ë†ğ‘“ via an acquiring (or release-acquiring) transaction, and this transaction
successfuly commits, then its view is guaranteed to be updated so that [ğ‘‘ = 5]ğœ2 holds. In a
transactional setting, we establish this fact in three steps.

(1) After executing line 7, we use âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2 to establish that ğ‘Ÿ1 = 1 â‡’ [ğ‘‘ ğ‘†

= 5]ğœ2 holds.
Note that ğ‘Ÿ2 stores the value 1 returned by a transactional read of Ë†ğ‘“ . Thus, âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘ = 5]ğœ2 is
transformed into an implication after the execution of line 7. The assertion [ğ‘‘ ğ‘†
= 5]ğœ2 is a new
assertion introduced in TARO, which states that if the transaction executed by ğœ2 commits,
then [ğ‘‘ = 5]ğœ2 holds in the post-state.

(2) If the transaction sucessfully commits (line 8), we use ğ‘Ÿ1 = 1 â‡’ [ğ‘‘ ğ‘†

= 5]ğœ2 to establish
ğ‘Ÿ1 = 1 â‡’ [ğ‘‘ = 5]ğœ2 in the postcondition. Recall that all registers used by a transaction are set
to âŠ¥ when a transaction aborts, so if ğœ2 reaches line 9 by aborting the transaction, then this
assertion is trivially true.

(3) We use ğ‘Ÿ1 = 1 â‡’ [ğ‘‘ = 5]ğœ2 to establish [ğ‘‘ = 5]ğœ2 after the do-until loop, using the guard

ğ‘Ÿ1 = 1 at line 9.

Finally, we use [ğ‘‘ = 5]ğœ2 in the precondition of line 10 to establish the postcondition ğ‘Ÿ2 = 5. This is
because [ğ‘‘ = 5]ğœ2 guarantees that the only value ğœ2 can read for ğ‘‘ is 5.

5.2 TARO: Transactional Owicki-Gries Reasoning

Now that we have introduced the assertions used by TARO, we now review the Owicki-Gries proof
obligations. As discussed above, the use of view-based assertions allows us to use the standard
Owicki-Gries theory. Regardless, we review the theory in the context of our language, which
supports (abstract) TM operations. Formally, we model programs as a labelled transition system,
given by the syntax in Fig. 10.

A command (of type ACom) is either a local assignment ğ‘Ÿ := Exp, a store to a shared location
ğ‘¥ :=[R] Exp, a load from a shared location ğ‘Ÿ â†[A] ğ‘¥, a compare-and-swap ğ‘Ÿ â† CAS[RX] [R] [A] (ğ‘¥, ğ‘¢, ğ‘£),
or a transactional operation. The annotations RX, R and A are optional, as indicated by the brackets
â€˜[â€™ and â€˜]â€™. Thus, for example, both ğ‘¥ := ğ‘’ and ğ‘¥ :=R ğ‘’ are valid load commands; the former is relaxed
and the latter is releasing. A CAS may be annotated to be relaxed, or release and/or acquire. Note
that a CAS returns a boolean to indicate whether or not the compare-and-swap has been success-
ful. TxBegin([RX] [R] [A]), TxRead(ğ‘¥, ğ‘Ÿ ), TxWrite(ğ‘¥, ğ‘£) and TxEnd are transactional operations, as
defined by the TMS2-ra automata in Fig. 4.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:19

ğ‘¢, ğ‘£ âˆˆ Val Ë†= N

ğ‘¥, ğ‘¦, . . . âˆˆ Loc

ğ‘Ÿ, ğ‘Ÿ1, ğ‘Ÿ2 . . . âˆˆ Reg

ğœ, ğœ1, ğœ2, . . . âˆˆ TId Ë†= N

ğ‘–, ğ‘—, ğ‘˜, . . . âˆˆ Label

ğ‘’ âˆˆ Exp ::= ğ‘£ | ğ‘Ÿ | ğ‘’+ğ‘’ | Â· Â· Â·
ğµ âˆˆ BExp ::= true | ğµ âˆ§ ğµ | Â· Â· Â·
ğ›¼ âˆˆ ACom ::= ğ‘Ÿ := Exp | ğ‘¥ :=[R] Exp | ğ‘Ÿ â†[A] ğ‘¥ | ğ‘Ÿ â† CAS[RX] [R] [A] (ğ‘¥, ğ‘¢, ğ‘£) |

TxBegin([RX] [R] [A], 2Reg) | TxRead(ğ‘¥, ğ‘Ÿ ) | TxWrite(ğ‘¥, ğ‘£) | TxEnd

ğ‘™ğ‘  âˆˆ LCom ::= ğ›¼ goto ğ‘— | if ğµ goto ğ‘— elseto ğ‘˜

Î  âˆˆ Prog Ë†= TId Ã— Label â†’ LCom

Fig. 10. Language syntax

We use a program counter variable ğ‘ğ‘ : TId â†’ ğ¿ğ‘ğ‘ğ‘’ğ‘™ to model control flow, and model a program
Î  as a function mapping each pair (ğœ, ğ‘–) of thread identifier and label to the labelled statement
(in LCom) to be executed. A labelled statement may be (i) a plain statement of the form ğ›¼ goto ğ‘—,
comprising an atomic statement ğ›¼ to be executed and the label ğ‘— of the next statement; or (ii) a
conditional statement of the form if ğµ goto ğ‘— elseto ğ‘˜ to accommodate branching, which proceeds
to label ğ‘— if ğµ holds and to ğ‘˜, otherwise. We assume a designated label, ğœ„ âˆˆ Label, representing the
initial label; i.e., each thread begins execution with pc(ğœ) = ğœ„. Similarly, ğœ âˆˆ Label represents the
final label.

We let Assertion be the set of assertions that use view-based expressions. We model program
annotations via an annotation function, ann âˆˆ Ann = TId Ã— Label â†’ Assertion, associating each
program point (ğœ, ğ‘–) with its associated assertion. A proof outline is a tuple (in, ann, fin), where
in, fin âˆˆ Assertion are the initial and final assertions.

Definition 1 (Validity). A proof outline (in, ann, fin) is valid for a program Î  iff each of the
following holds:

Initialisation For all ğœ âˆˆ TId, in â‡’ ann(ğœ, ğœ„).
Finalisation (âˆ€ğœ âˆˆ TId. ann(ğœ, ğœ )) â‡’ fin
Local correctness For all ğœ âˆˆ TId and ğ‘– âˆˆ Label, either:

â€¢ Î (ğœ, ğ‘–) = ğ›¼ goto ğ‘— and (cid:8)ann(ğœ, ğ‘–)(cid:9) ğ›¼ (cid:8)ann(ğœ, ğ‘—)(cid:9); or
â€¢ Î (ğœ, ğ‘–) = if ğµ goto ğ‘— elseto ğ‘˜ and both ann(ğœ, ğ‘–) âˆ§ ğµ â‡’ ann(ğœ, ğ‘—) and ann(ğœ, ğ‘–) âˆ§ Â¬ğµ â‡’

ann(ğœ, ğ‘˜) hold.

Stability For all ğœ1, ğœ2 âˆˆ TId such that ğœ1 â‰  ğœ2 and ğ‘–1, ğ‘–2 âˆˆ Label if Î (ğœ1, ğ‘–1) = ğ›¼ goto ğ‘—, then

(cid:8)ann(ğœ2, ğ‘–2) âˆ§ ann(ğœ1, ğ‘–1)(cid:9) ğ›¼ (cid:8)ann(ğœ2, ğ‘–2)(cid:9)

Intuitively, Initialisation (resp. Finalisation) ensures that the initial (resp. final) assertion of each
thread holds at the beginning (resp. end); Local correctness establishes validity for each thread;
and Stability ensures that each (local) thread annotation is interference-free under the execution of
other threads [Owicki and Gries 1976].

To support Owicki-Gries reasoning, we have proved a number of high-level rules, extending
those of Dalvandi et al. [Dalvandi et al. 2020a; Dalvandi and Dongol 2021] to cope with transactional
assertions from Â§5.1 and the transactional commands. For instance, the following rules are used in
the proof of transactional message passing. A number of other rules are provided as part of our
Isabelle/HOL development.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:20

Sadegh Dalvandi and Brijesh Dongol

Lemma 1. Suppose ğœ1 â‰  ğœ2. Then each of the following holds:

(cid:8)true(cid:9) TxWriteğœ (ğ‘¥, ğ‘£) (cid:8)( Ë†ğ‘¥, ğ‘£) âˆˆ WSğœ (cid:9)
(cid:8)(ğ‘¥, ğ‘¢) âˆˆ WSğœ1 âˆ§ Relğœ1 âˆ§ [ Ë†ğ‘¥ (cid:48) ğ‘¢]ğœ2 âˆ§ [ğ‘¦ = ğ‘£]ğœ1
(cid:9) TxEndğœ2
(cid:110)
(cid:8)(ğ‘¥, _) âˆ‰ WSğœ âˆ§ ğ´ğ‘ğ‘ğœ âˆ§ âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘¦ = ğ‘£]ğœ (cid:9) TxReadğœ (ğ‘¥, ğ‘Ÿ )
(cid:110)

(cid:111)

( Ë†ğ‘¥, ğ‘Ÿ ) âˆˆ RSğœ âˆ§ (ğ‘Ÿ = ğ‘¢ â‡’ [ğ‘¦ ğ‘†

= ğ‘£]ğœ )

TxEndğœ (cid:8)ğ‘Ÿ = ğ‘¢ â‡’ [ğ‘¦ = ğ‘š]ğœ (cid:9)

(cid:9)

(cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘¦ = ğ‘£]ğœ2
( Ë†ğ‘¥, ğ‘Ÿ ) âˆˆ RSğœ âˆ§ (ğ‘Ÿ = ğ‘¢ â‡’ [ğ‘¦ ğ‘†

= ğ‘£]ğœ )

(cid:111)

The rules in Lemma 1 have been verified in Isabelle/HOL w.r.t. the operational semantics. Once
proved, they can be used to show validity of proof outlines such as those in Fig. 9 without having
to consult the operational semantics.

Theorem 1. The proof outline in Fig. 9 is valid.

This theorem has been verified in Isabelle/HOL, and it makes extensive use of generic proof rules
such as the ones proved in Lemma 1. In particular, given such lemmas, like in previous works [Bila
et al. 2022; Dalvandi et al. 2020a; Dalvandi and Dongol 2021; Dalvandi et al. 2022], Isabelle/HOL is
automatically able to find and apply the appropriate proof rule using the built-in sledgehammer
tool [BÃ¶hme and Nipkow 2010]. This automation has been key to scaling mechanised verification of
proof outlines in view-based logics. For example, the proofs of TML-RA (see Â§6) requires verification
of complex invariants and proof outlines, and these proofs make use of the proof rules developed
in prior work [Dalvandi et al. 2020a]. Similarly, TARO can be applied to verify more complex
porgrams that use transactions, for instance if one were to develop transactional data structures.
Interestingly, because transactions provide isolation guarantees, many of the proofs are simplified
since the stability checks for in-flight transactions become trivial.

The proof outlines for the programs in Figs. 2b and 2c are provided in Appendix E.

6 PROVING CORRECTNESS OF TML-RA

We now turn to the question of correctness of TML-ra with respect to the TMS2-ra specification.

6.1 Refinement and Simulation for Weak Memory

Since we have an operational semantics with an interleaving semantics over weak memory
states, the development of our refinement theory closely follows the standard approach under
SC [de Roever and Engelhardt 1998]. Suppose ğ‘ƒ is a program with initialisation Init. An execution
of ğ‘ƒ is defined by a possibly infinite sequence Î”0 Î”1 Î”2 . . . such that
(1) each Î”ğ‘– is a 4-tuple (ğ‘ƒğ‘–, lsğ‘–, ğ›¾ğ‘–, ğ›½ğ‘– ) comprising a program to be executed, local state, global library

state and global client state, and

(2) (ğ‘ƒ0, ls0, ğ›¾0, ğ›½0) = (ğ‘ƒ, lsInit, ğ›¾Init, ğ›½Init), and
(3) for each ğ‘–, we have Î”ğ‘– =â‡’ Î”ğ‘–+1, where =â‡’ is the transition relation of the program (as defined

by the operational semantics).

Let LVarğ‘ƒ be the set of local variables corresponding to a program ğ‘ƒ. If ğ‘ƒ is a client, a client trace
corresponding to an execution Î”0 Î”1 Î”2 . . . is a sequence ct âˆˆ Î£âˆ—
ğ‘ƒ such that ctğ‘– = (ğœ‹2(Î”ğ‘– ) |ğ‘ƒ, ğœ‹4(Î”ğ‘– )),
where ğœ‹ğ‘› is a projection function that extracts the ğ‘›th component of a given tuple and ls |ğ‘ƒ restricts
the given local state ls to the variables in LVarğ‘ƒ . Thus, each ctğ‘– is the global client state compo-
nent of Î”ğ‘– . After such a projection, the concrete implementation may contain (finite or infinite)
stuttering [de Roever and Engelhardt 1998], i.e., consecutive states in which the client state is
unchanged. We let rem_stut (ct) be the function that removes all stuttering from the trace ct, i.e.,
each consecutively repeating state is replaced by a single instance of that state. We let TrSF (ğ‘ƒ)

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:21

denote the set of stutter-free traces of a program ğ‘ƒ, i.e., the stutter-free traces generated from the
set of all executions of ğ‘ƒ.

Below we refer to the client that uses the abstract object as the abstract client and the client that
uses the objectâ€™s implementation as the concrete client. The notion of contextual refinement that
we develop ensures that a client is not able to distinguish the use of a concrete implementation in
place of an abstract specification. In other words, each thread of the concrete client should only be
able to observe the writes (and updates) in the client state (i.e., ğ›¾ component) that the thread could
already observe in a corresponding of the client state of the abstract client. First we define trace
refinement for weak memory states.
Definition 2 (State and Trace Refinement). We say a concrete client state (ls, ğ›½ğ¶ ) is a refinement
of an abstract client state (als, ğ›½ğ´), denoted (ls, ğ›½ğ¶ ) â‰¤ (als, ğ›½ğ´) iff ls = als and for all threads ğœ and
ğ‘¥ âˆˆ GVar, we have ğ›½ğ¶ .OW ğœ (ğ‘¥) âŠ† ğ›½ğ´.OW ğœ (ğ‘¥). We say a concrete client trace ct is a refinement of
an abstract client trace at, denoted ct â‰¤ at, iff ctğ‘– â‰¤ atğ‘– for all ğ‘–.

This now leads to a natural trace-based definition of contextual refinement.

Definition 3 (Program Refinement). A concrete program ğ‘ƒğ¶ is a refinement of an abstract program
ğ‘ƒğ´, denoted ğ‘ƒğ¶ â‰¤ ğ‘ƒğ´, iff for any (stutter-free) client trace ct âˆˆ TrSF (ğ‘ƒğ¶ ) there exists a (stutter-free)
client trace at âˆˆ TrSF (ğ‘ƒğ´) such that ct â‰¤ at.

Finally, we obtain a notion of contextual refinement for abstract objects. We let ğ‘ƒ [ğ‘‚] be the client
program calling operations from object ğ‘‚. Note that ğ‘‚ may be an abstract object, in which case
execution of each method call follows the abstract object semantics, or a concrete implementation.
Definition 4 (Contextual refinement). We say a concrete object ğ¶ğ‘‚ is a contextual refinement of
an abstract object ğ´ğ‘‚ iff for any client program ğ‘ƒ, we have ğ‘ƒ [ğ¶ğ‘‚] â‰¤ ğ‘ƒ [ğ´ğ‘‚].

Here, we use a simulation-based proof method, which is a standard technique from the literature
that establishes refinement between TMS2-ra and TML-ra. The difference in a relaxed memory
setting is that the refinement relation is between more complex configurations of the form (ls, ğ›¾, ğ›½),
where ls describes the local state, ğ›¾ is the client state and ğ›½ is a state of the TM in question. In
particular, a simulation relation, ğ‘…, relates triples Î“ğ´ Ë†= (als, ğ›¾ğ´, ğ›½ğ´) of the abstract system with
triples Î“ğ¶ Ë†= (ls, ğ›¾ğ¶, ğ›½ğ¶ ) of the concrete system.

The definition below assumes a reflexive relation ğ›¾ğ¶ âˆ’tviewğœâˆ’âˆ’âˆ’âˆ’âˆ’â†’ ğ›¾ â€²

ğ¶ for each thread ğœ that arbitrarily

advances the thread view of ğœ (for one or more locations).
Definition 5 (Forward simulation). For an abstract object ğ´ğ‘‚ and a concrete object ğ¶ğ‘‚, for a client
program ğ‘ƒ, we say ğ‘…(Î“ğ´, Î“ğ¶ ) Ë†= ğ‘…ğ‘‰ ((als, ğ›½ğ´), (ls, ğ›½ğ¶ )) âˆ§ ğ‘…ğ‘‚ ((als |ğ´ğ‘‚, ğ›¾ğ´), (ls |ğ¶ğ‘‚, ğ›¾ğ¶ )) is a forward
simulation between ğ´ and ğ¶ iff each of the following holds:
Client observation.

ğ‘…ğ‘‰ ((als, ğ›½ğ´), (ls, ğ›½ğ¶ )) = als |ğ‘ƒ = ls |ğ‘ƒ âˆ§ (âˆ€ğœ âˆˆ TId, ğ‘¥ âˆˆ Loc. ğ›½ğ´.tview(ğ‘¡, ğ‘¥) â‰¤ ğ›½ğ¶ .tview(ğ‘¡, ğ‘¥))

Thread view stability. For any thread ğœ,

ğ‘…ğ‘‚ ((als |ğ´ğ‘‚, ğ›¾ğ´), (ls |ğ¶ğ‘‚, ğ›¾ğ¶ )) âˆ§ (ğ›¾ğ¶ âˆ’tviewğœâˆ’âˆ’âˆ’âˆ’âˆ’â†’ ğ›¾ â€²

ğ¶ ) â‡’ ğ‘…ğ‘‚ ((als |ğ´ğ‘‚, ğ›¾ğ´), (ls |ğ¶ğ‘‚, ğ›¾ â€²

ğ¶ ))

Initialisation. For any concrete initial state Î“0

ğ¶ , there exists an abstract initial state Î“0

ğ´ such that

ğ‘…(Î“0

ğ´, Î“0
ğ¶ ).

Preservation. For any concrete states Î“ğ¶ , Î“â€²

ğ¶ such that ğ¶ can take an atomic transition from Î“ğ¶ to

Î“â€²
ğ¶ , if Î“ğ´ is an abstract state such that ğ‘…(Î“ğ´, Î“ğ¶ ), then either
â€¢ ğ‘…(Î“ğ´, Î“â€²
â€¢ there exists a transition of ğ´ from Î“ğ´ to some state Î“â€²

ğ¶ ), or

ğ´ such that ğ‘…(Î“â€²

ğ´, Î“â€²

(stuttering step)
ğ¶ ). (non-stuttering

step)

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:22

Sadegh Dalvandi and Brijesh Dongol

Initialisation and preservation are standard components of a forward simulation. Client observation
is necessary in a relaxed memory context to ensure that the client-side observations of the concrete
system are possible observations of the abstract system. In particular, if an abstract object specifies
a particular client-side synchronisation, then this synchronisation must also be present in the
concrete implementation (see [Dalvandi and Dongol 2021]). Thread view stability guarantees that
the ğ‘…ğ‘‚ component of the refinement relation is preserved when the thread view in the library is
shifted forward, e.g., due to synchronisation within a client.

Note that Definition 5 only guarantees preservation of safety. To additionally preserve liveness,
further progress guarantees are required in an implementation [Dongol and Groves 2016; Gotsman
and Yang 2011]. We leave liveness preservation through refinement for future work since notions
of fairness and progress of weak memory models is still at the early stages [Lahav et al. 2021].

Theorem 2. If ğ‘… is a forward simulation between ğ´ğ‘‚ and ğ¶ğ‘‚, then for any client ğ‘ƒ we have

ğ‘ƒ [ğ¶ğ‘‚] â‰¤ ğ‘ƒ [ğ´ğ‘‚].

6.2 Forward Simulation for TML-ra

Perhaps the most technically challenging aspect of this paper is the proof of Theorem 3 below,
which ensures the correctness of TML-ra w.r.t. TMS2-ra.

This section describes the simulation relation used to prove refinement between TML-ra and
TMS2-RA. Validity of the forward simulation itself has been verified using Isabelle/HOL. The
refinement relation

ğ‘…((als, ğ›¾ğ´, ğ›½ğ´), (ğ‘™ğ‘ , ğ›¾ğ¶, ğ›½ğ¶ ))

Ë†= ğ‘…ğ‘‰ ((als, ğ›½ğ´), (ls, ğ›½ğ¶ )) âˆ§ (1) âˆ§

(âˆ€ğ‘¡ . (2) âˆ§ (3) âˆ§ (4) âˆ§ (5) âˆ§ (6) âˆ§ (7) âˆ§ (8) âˆ§ (9))

The first conjunct (1) in the refinement relation ğ‘… states that the value of the last write to glb divided
by 2 (wc(ğ‘›) Ë†= ğ‘› Ã· 2) is equal to the last version of history written to M.

wc(ğ›¾ğ¶ .lastval(ğ‘”ğ‘™ğ‘)) = |ğ›¾ğ´.M |
(1)
The next conjunct, (2), states that the last value written to any location ğ‘™ in ğ›¾ğ¶ is either the value of
ğ‘™ in the last abstract memory index or in the write set of the executing transaction

âˆ€ğ‘™ . ğ‘™ â‰  glb â‡’ ğ›¾ğ¶ .lastval(ğ‘™) âˆˆ {ğ›¾ğ´.M|ğ›¾ğ´.M | (ğ‘™), ğ›¾ğ´.wrSetğ‘¡ (ğ‘™)}

(2)

where lastval(ğ‘¥) is a function that returns the value of the last write written to a location ğ‘¥.

The next conjunct (3) is an on-the-fly simulation relation (i.e. the transaction has begun and is
not committed or aborted) and states that for all threads ğœ if transaction ğ‘¡ (ğ›¾ğ´.txnğœ = ğ‘¡) is on-the-fly,
the value of wc(ğ›¾ğ¶ .ğ‘™ğ‘œğ‘ğœ ) will be greater than or equal to beginIdxğ‘¡ and the read set of ğ‘¡ will be
consistent with memory verison wc(ğ›¾ğ¶ .ğ‘™ğ‘œğ‘ğœ ):

ğ›¾ğ´.beginIdxğ‘¡ â‰¤ wc(ğ‘™ğ‘ .ğ‘™ğ‘œğ‘ğ‘¡ ) âˆ§ ğ›¾ğ´.rdSetğ‘¡ âŠ† ğ›¾ğ´.Mwc(ğ‘™ğ‘ .ğ‘™ğ‘œğ‘ğ‘¡ )

Conjunct (4) states that if the value of ğ‘™ğ‘ .ğ‘™ğ‘œğ‘ğ‘¡ is even then write set of ğ›¾ğ´ must be empty:

even(ğ‘™ğ‘ .ğ‘™ğ‘œğ‘ğ‘¡ ) â‡’ ğ›¾ğ´.wrSetğ‘¡ = âˆ…

(3)

(4)

Also if a transaction ğ‘¡ that has already written to a location then the write set of ğ›¾ğ´ is not empty:
ğ‘™ğ‘ .hasWrittenğ‘¡ â‡’ ğ›¾ğ´.wrSetğ‘¡ â‰  âˆ…

(5)

If a transaction has not read any location yet in the concrete state, then the read set of the abstract

state should be empty:

Â¬ğ‘™ğ‘ .hasReadğ‘¡ â‡’ ğ›¾ğ´.rdSetğ‘¡ = âˆ…

(6)

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:23

If there is a write in the write set of the abstract state, then the value should match the value of

the last write written to that location by the concrete implementation:

(7)
The value of a visible write of thread ğœ to variable ğ‘”ğ‘™ğ‘ divided by two is a visible memory by

âˆ€ğ‘™ âˆˆ dom(ğ›¾ğ´.wrSetğ‘¡ ). ğ›¾ğ´.wrSetğ‘¡ (ğ‘™) = ğ›¾ğ¶ .lastval(ğ‘™)

thread ğœ of the abstract state:

(8)
All seen memory indices by the abstract transaction ğ‘¡ are less the value of thread view of ğ‘”ğ‘™ğ‘ for

âˆ€ğ‘¤ âˆˆ ğ›¾ğ¶ .ğ‘‚ğ‘Šğœ (ğ‘”ğ‘™ğ‘). wc(val(ğ‘¤)) âˆˆ ğ›¾ğ´.ğ‘£ğ‘šğ‘’ğ‘šğ‘ ğœ

thread ğœ divided by 2:

âˆ€ğ‘– âˆˆ ğ›¾ğ´.seenIdxsğ‘¡ . ğ‘– â‰¤ wc(val(ğ›¾ğ¶ .tviewğœ (ğ‘”ğ‘™ğ‘)))

Theorem 3. ğ‘… is a forward simulation between TMS2-ra and TML-ra.

Proof. This theorem has been verified in Isabelle/HOL.

(9)

â–¡

7 RELATED WORK

Verifying C11 programs. There are now several different approaches to program verification
that support different aspects of the C11 relaxed memory model using pen-and-paper proofs
(e.g., [Alglave and Cousot 2017; Doko and Vafeiadis 2017; Lahav and Vafeiadis 2015; Turon et al.
2014]), model checking (e.g., [Abdulla et al. 2019; Kokologiannakis et al. 2019]), specialised tools
(e.g., [Krishna et al. 2020; Summers and MÃ¼ller 2018; Svendsen et al. 2018; Tassarotti et al. 2015]),
and generalist theorem provers (e.g., [Dalvandi et al. 2020a]). These cover a variety of (fragments
of) memory models and proceed via exhaustive state space exploration, separation logics, or Hoare-
style calculi. A related approach to TARO that uses a view-based semantics for persistent x86-TSO
has been developed by Bila et al. [2022].

Another series of works has focussed on semantics that support the relaxed dependencies that are
allowed by C11 [Jagadeesan et al. 2020; Kang et al. 2017; Lee et al. 2020; Paviotti et al. 2020]. These
have been followed more recently by logics and verification over this semantics [Svendsen et al.
2018; Wright et al. 2021]. However, relaxed dependencies produce high levels of non-determinism,
making verification significantly more complex. We consider a verification framework that supports
relaxed dependencies and STMs to be a topic for future research.

More recent works include robustness of C11-style programs, which aims to show â€œadequate
synchronisationâ€ so that the relaxed memory executions reduce to executions under stronger
memory models [Margalit and Lahav 2021]. Such reductions, although automatic, are limited to
finite state systems, and a small number of threads. Furthermore, it is currently unclear how they
would handle client-library synchronisation or relaxed (non-SC) specifications.

Correctness conditions under relaxed memory. Following the extensive literature on the semantics
of relaxed memory architectures, a natural next question has been the development of library
abstractions for relaxed memory. One aim has been to ensure observational refinement and com-
positionality of the implemented objects. A series of works have considered reforumulations of
linearizability [Doherty et al. 2018; Dongol et al. 2018b; Raad et al. 2019a] by presenting suitable
weakenings fine-tuned to the underlying memory model. This includes extensions of linearizability,
e.g., so that it is defined in terms of axiomatic (aka declarative) relaxed memory models [Dongol
et al. 2018b; Raad et al. 2019a] and those that are based on the more abstract concept of execution
structures [Doherty et al. 2018]. Recent works have covered verification of relaxed memory concur-
rent data structures that have been developed to satisfy the conditions described above [Dalvandi
and Dongol 2021; Krishna et al. 2020; Raad et al. 2019a], but none of these cover transactions.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:24

Sadegh Dalvandi and Brijesh Dongol

Khyzha and Lahav [2022] have recently developed notions of abstraction for crash resilient
libraries, providing correctness conditions (extending linearizability) that ensure contextual refine-
ment for concurrent objects executed over the PSC (persistent sequential consistency) model. They
do so by exposing the internal synchronisation mechanisms that are used to implement an object
in the history (in addition to the invocations and responses). Our work differs since we consider
transactional memory libraries as opposed to concurrent objects, use a different memory model and
focus on verification of contextual refinement directly. Nevertheless, in future work, it would be
interesting to see if their methods provide an alternative method for specifying concurrent object
and transactional memory libraries in C11.

Several papers have revisited transaction semantics in the context of relaxed memory mod-
els [Chong et al. 2018; Dongol et al. 2018a, 2019; Raad et al. 2019b]. Raad et al have considered
relaxed memory and snapshot isolation [Raad et al. 2018, 2019b], which is a weaker condition that
serializability (and hence opacity and TMS2). The question of whether snapshot isolation can be
fully exploited by implementations in a relaxed memory setting remains a topic of future research,
with most transactional implementations aiming to support at least serializability [Zardoshti et al.
2019]. Dongol et al. [2018a] and Chong et al. [2018] have provided axiomatic atransactional se-
mantics integrated with relaxed memory models, focussing on hardware memory models and
hardware transactions. Chong et al. [2018] additionally propose a model for C11 transactions, but
these models are focussed on transactions within the compiler, as opposed to STMs. Finally, the
axiomatic models proposed in these earlier works [Chong et al. 2018; Dongol et al. 2018a] are not
suitable for operational verification, e.g., as supported by TARO, where we require an operational
semantics as provided by TMS2-ra.

Another set of works has focussed on distributed (relaxed) transactions [Beillahi et al. 2021a,b;
Xiong et al. 2020]. Although there are analogues between transactions in distributed systems and
relaxed memory, constraints such as replication consistency and session order are not factors in
shared memory, and hence the underlying issues are fundamentally different. Xiong et al. [2020]
describe a taxonomy of distributed transactional models supported by an operational semantics.
It would be interesting to investigate whether TARO can be adapted to cope with client-object
systems in their models.

Relaxed memory TM implementations. There is a set of recent works on implementing TM
algorithms in C11 [Spear et al. 2020; Zardoshti et al. 2019]. The focus here has been real-world
implementability of STMs via compiler support. Since the focus is on benchmarks and real-world
workflows, these works neither consider a formal semantics nor provide a verification framework.
Our work can thus be seen as providing a formal basis to support to these efforts. In particular, we
show how the serialisability specifications assumed by Spear et al. [2020]; Zardoshti et al. [2019]
can be relaxed, without impacting correctness, while improving performance.

8 CONCLUSIONS

In this paper, we have presented a new approach to release-acquire transactions for RC11 RAR (a
fragment of C11 that supports relaxed as well as release-acquire atomics). We have developed a
new TM specification, TMS2-ra, that extends TMS2 to a relaxed memory context by describing the
interactions between transactions and their clients. We implement TMS2-ra by TML-ra, which is
an adaptation of an existing eager algorithm, TML. We show that TML-ra outperforms TML-sc
using the STAMP benchmarks.

Our second set of contributions covers the verification of release-acquire TM implementations. We
focus on proofs at two levels: (i) correctness of client programs that use TMS2-ra, and (ii) correctness
of implementations of TMS2-ra. For (i), we have developed a logic, TARO, extending [Dalvandi

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:25

and Dongol 2021], and used this logic to prove that TMS2-ra does indeed guarantee the desired
client-side synchronisation properties. For (ii), we have applied a simulation method, simular
to [Dalvandi and Dongol 2021] and proved a forward simulation between TML-ra and TMS2-ra.
All proofs for (i) and (ii) as well as all meta-level soundness results are fully mechanised in the
Isabelle/HOL proof assistant, providing a high level of assurance to our results.

Our motivation for using TML as the main implementation case study was to start with a simple
algorithm with an existing proof in SC [Derrick et al. 2018]. TML performs a global synchronisation
through a CAS on a single location, which degrades performance on write-heavy workloads.
For improved scalability, there are more sophisticated algorithms like TL2 [Dice et al. 2006] that
offer per-location locking as well as hybrid TM implementations [Matveev and Shavit 2015] that
combine hardware and software TM. TMS2 is known to be a sufficient abstraction for hybrid TMs in
SC [Armstrong and Dongol 2017], so it is likely that TMS2-ra also provides a basis for developing
and verifying relaxed and release-acquire versions of these more sophisticated algorithms. We
leave such studies for future work.

ACKNOWLEDGMENTS

The authors would also like to thank the anonymous referees for their valuable comments and
helpful suggestions. Dalvandi and Dongol are supported by EPSRC Grant EP/R032556/1. Dongol is
additionally supported by EPSRC Grant EP/V038915/1, EPSRC Grant EP/R025134/2, ARC Grant
DP190102142 and VeTSS.

REFERENCES

P. A. Abdulla, J. Arora, M. F. Atig, and S. N. Krishna. 2019. Verification of programs under the release-acquire semantics. In

PLDI, K. S. McKinley and K. Fisher (Eds.). ACM, 1117â€“1132. https://doi.org/10.1145/3314221.3314649

J. Alglave and P. Cousot. 2017. Ogre and Pythia: an invariance proof method for weak consistency models. In POPL,

G. Castagna and A. D. Gordon (Eds.). ACM, 3â€“18.

J. Alglave, L. Maranget, and M. Tautschnig. 2014. Herding Cats: Modelling, Simulation, Testing, and Data Mining for Weak

Memory. ACM Trans. Program. Lang. Syst. 36, 2 (2014), 7:1â€“7:74.

A. Armstrong and B. Dongol. 2017. Modularising Opacity Verification for Hybrid Transactional Memory. In FORTE (LNCS,

Vol. 10321), A. Bouajjani and A. Silva (Eds.). Springer, 33â€“49.

A. Armstrong, B. Dongol, and S. Doherty. 2017. Proving Opacity via Linearizability: A Sound and Complete Method. In

FORTE (LNCS, Vol. 10321), A. Bouajjani and A. Silva (Eds.). Springer, 50â€“66.

G. Assa, H. Meir, G. Golan-Gueta, I. Keidar, and A. Spiegelman. 2020. Nesting and composition in transactional data structure

libraries. In PPoPP â€™20, R. Gupta and X. Shen (Eds.). ACM, 405â€“406. https://doi.org/10.1145/3332466.3374514

G. Assa, H. Meir, G. Golan-Gueta, I. Keidar, and A. Spiegelman. 2021. Using Nesting to Push the Limits of Transactional
Data Structure Libraries. In OPODIS (LIPIcs, Vol. 217), Q. Bramas, V. Gramoli, and A. Milani (Eds.). Schloss Dagstuhl -
Leibniz-Zentrum fÃ¼r Informatik, 30:1â€“30:17. https://doi.org/10.4230/LIPIcs.OPODIS.2021.30

H. Attiya, A. Gotsman, S. Hans, and N. Rinetzky. 2018. Characterizing Transactional Memory Consistency Conditions Using

Observational Refinement. J. ACM 65, 1 (2018), 2:1â€“2:44.

M. Batty, A. F. Donaldson, and J. Wickerson. 2016. Overhauling SC atomics in C11 and OpenCL. In POPL. ACM, 634â€“648.
M. Batty, S. Owens, S. Sarkar, P. Sewell, and T. Weber. 2011. Mathematizing C++ concurrency. In POPL, T. Ball and M. Sagiv

(Eds.). ACM, 55â€“66.

S. M. Beillahi, A. Bouajjani, and C. Enea. 2021a. Checking Robustness Between Weak Transactional Consistency Models. In

ESOP (LNCS, Vol. 12648), N. Yoshida (Ed.). Springer, 87â€“117. https://doi.org/10.1007/978-3-030-72019-3_4

S. M. Beillahi, A. Bouajjani, and C. Enea. 2021b. Robustness Against Transactional Causal Consistency. Log. Methods Comput.

Sci. 17, 1 (2021). https://lmcs.episciences.org/7149

E. Vafeiadi Bila, B. Dongol, O. Lahav, A. Raad, and J. Wickerson. 2022. View-Based Owicki-Gries Reasoning for Persistent x86-
TSO. In ESOP (Lecture Notes in Computer Science, Vol. 13240), I. Sergey (Ed.). Springer, 234â€“261. https://doi.org/10.1007/978-
3-030-99336-8_9

S. BÃ¶hme and T. Nipkow. 2010. Sledgehammer: Judgement Day. In IJCAR (LNCS, Vol. 6173). Springer, 107â€“121.
N. G. Bronson, J. Casper, H. Chafi, and K. Olukotun. 2010. Transactional predication: high-performance concurrent sets and
maps for STM. In PODC, A. W. Richa and R. Guerraoui (Eds.). ACM, 6â€“15. https://doi.org/10.1145/1835698.1835703

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:26

Sadegh Dalvandi and Brijesh Dongol

N. Chong, T. Sorensen, and J. Wickerson. 2018. The semantics of transactions and weak memory in x86, Power, ARM, and

C++. In PLDI, J. S. Foster and D. Grossman (Eds.). ACM, 211â€“225. https://doi.org/10.1145/3192366.3192373

cppreference.com. 2022. std::atomic_compare_exchange. https://en.cppreference.com/w/cpp/atomic/atomic_compare_

exchange Accessed 18 July, 2022.

L. Dalessandro, D. Dice, M. L. Scott, N. Shavit, and M. F. Spear. 2010. Transactional Mutex Locks. In Euro-Par (2) (LNCS,

Vol. 6272). Springer, 2â€“13.

S. Dalvandi, S. Doherty, B. Dongol, and H. Wehrheim. 2020a. Owicki-Gries Reasoning for C11 RAR. In ECOOP (LIPIcs,
Vol. 166), R. Hirschfeld and T. Pape (Eds.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 11:1â€“11:26. https:
//doi.org/10.4230/LIPIcs.ECOOP.2020.11

S. Dalvandi, S. Doherty, B. Dongol, and H. Wehrheim. 2020b. Owicki-Gries Reasoning for C11 RAR (Artifact). Dagstuhl

Artifacts Ser. 6, 2 (2020), 15:1â€“15:2. https://doi.org/10.4230/DARTS.6.2.15

S. Dalvandi and B. Dongol. 2021. Verifying C11-style weak memory libraries. In PPoPP, J. Lee and E. Petrank (Eds.). ACM,

451â€“453. https://doi.org/10.1145/3437801.3441619

S. Dalvandi and B. Dongol. 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Artifact). https:

//doi.org/10.5281/zenodo.6899919

S. Dalvandi, B. Dongol, S. Doherty, and H. Wehrheim. 2022. Integrating Owicki-Gries for C11-Style Memory Models into

Isabelle/HOL. J. Autom. Reason. 66, 1 (2022), 141â€“171. https://doi.org/10.1007/s10817-021-09610-2

H.-H. Dang, J. Jung, J. Choi, D.-T. Nguyen, W. Mansky, J. Kang, and D. Dreyer. 2022. Compass: strong and compositional
library specifications in relaxed memory separation logic. In PLDI, R. Jhala and I. Dillig (Eds.). ACM, 792â€“808. https:
//doi.org/10.1145/3519939.3523451

W. P. de Roever and K. Engelhardt. 1998. Data Refinement: Model-oriented Proof Theories and their Comparison. Cambridge

Tracts in Theoretical Computer Science, Vol. 46. Cambridge University Press.

J. Derrick, S. Doherty, B. Dongol, G. Schellhorn, O. Travkin, and H. Wehrheim. 2018. Mechanized proofs of opacity: a
comparison of two techniques. Formal Aspects Comput. 30, 5 (2018), 597â€“625. https://doi.org/10.1007/s00165-017-0433-3
D. Dice, O. Shalev, and N. Shavit. 2006. Transactional Locking II. In DISC (Lecture Notes in Computer Science, Vol. 4167),

S. Dolev (Ed.). Springer, 194â€“208. https://doi.org/10.1007/11864219_14

S. Doherty, B. Dongol, J. Derrick, G. Schellhorn, and H. Wehrheim. 2016. Proving Opacity of a Pessimistic STM. In OPODIS
(LIPIcs, Vol. 70), P. Fatourou, E. JimÃ©nez, and F. Pedone (Eds.). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,
35:1â€“35:17.

S. Doherty, B. Dongol, H. Wehrheim, and J. Derrick. 2018. Making Linearizability Compositional for Partially Ordered
Executions. In iFM (LNCS, Vol. 11023), C. A. Furia and K. Winter (Eds.). Springer, 110â€“129. https://doi.org/10.1007/978-3-
319-98938-9_7

S. Doherty, B. Dongol, H. Wehrheim, and J. Derrick. 2019. Verifying C11 programs operationally. In PPoPP, Jeffrey K.

Hollingsworth and Idit Keidar (Eds.). ACM, 355â€“365.

S. Doherty, L. Groves, V. Luchangco, and M. Moir. 2013. Towards formally specifying and verifying transactional memory.

Formal Asp. Comput. 25, 5 (2013), 769â€“799.

M. Doko and V. Vafeiadis. 2017. Tackling Real-Life Relaxed Concurrency with FSL++. In ESOP. 448â€“475.
S. Dolan, KC Sivaramakrishnan, and A. Madhavapeddy. 2018. Bounding Data Races in Space and Time. In PLDI (Philadelphia,

PA, USA) (PLDI 2018). ACM, New York, NY, USA, 242â€“255.

B. Dongol and L. Groves. 2016. Contextual Trace Refinement for Concurrent Objects: Safety and Progress. In ICFEM (Lecture
Notes in Computer Science, Vol. 10009), K. Ogata, M. Lawford, and S. Liu (Eds.). 261â€“278. https://doi.org/10.1007/978-3-
319-47846-3_17

B. Dongol, R. Jagadeesan, and J. Riely. 2018a. Transactions in relaxed memory architectures. PACMPL 2, POPL (2018),

18:1â€“18:29.

B. Dongol, R. Jagadeesan, and J. Riely. 2019. Modular transactions: bounding mixed races in space and time. In PPoPP, J. K.

Hollingsworth and I. Keidar (Eds.). ACM, 82â€“93. https://doi.org/10.1145/3293883.3295708

B. Dongol, R. Jagadeesan, J. Riely, and A. Armstrong. 2018b. On abstraction and compositionality for weak-memory

linearisability. In VMCAI (LNCS, Vol. 10747). Springer, 183â€“204.

M. Emmi and C. Enea. 2019. Weak-consistency specification via visibility relaxation. Proc. ACM Program. Lang. 3, POPL

(2019), 60:1â€“60:28. https://doi.org/10.1145/3290373

A. Gotsman and H. Yang. 2011. Liveness-Preserving Atomicity Abstraction. In ICALP (Lecture Notes in Computer Science,
Vol. 6756), L. Aceto, M. Henzinger, and J. Sgall (Eds.). Springer, 453â€“465. https://doi.org/10.1007/978-3-642-22012-8_36

R. Guerraoui and M. Kapalka. 2010. Principles of Transactional Memory. Morgan & Claypool Publishers.
M. He, V. Vafeiadis, S. Qin, and J. F. Ferreira. 2016. Reasoning about Fences and Relaxed Atomics. In PDP. IEEE Computer

Society, 520â€“527.

M. Herlihy and J. E. B. Moss. 1993. Transactional Memory: Architectural Support for Lock-Free Data Structures. In ISCA,

A. J. Smith (Ed.). ACM, 289â€“300.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:27

M. Herlihy and J. M. Wing. 1990. Linearizability: A Correctness Condition for Concurrent Objects. ACM TOPLAS 12, 3

(1990), 463â€“492.

R. Jagadeesan, A. Jeffrey, and J. Riely. 2020. Pomsets with preconditions: a simple model of relaxed memory. Proc. ACM

Program. Lang. 4, OOPSLA (2020), 194:1â€“194:30. https://doi.org/10.1145/3428262

J.-O. Kaiser, H.-H. Dang, D. D., O. Lahav, and V. Vafeiadis. 2017. Strong Logic for Weak Memory: Reasoning About Release-
Acquire Consistency in Iris. In ECOOP (LIPIcs, Vol. 74), P. MÃ¼ller (Ed.). Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,
17:1â€“17:29.

J. Kang, C.-K. Hur, O. Lahav, V. Vafeiadis, and D. Dreyer. 2017. A promising semantics for relaxed-memory concurrency. In

POPL. ACM, 175â€“189.

A. Khyzha and O. Lahav. 2022. Abstraction for Crash-Resilient Objects. In ESOP (Lecture Notes in Computer Science, Vol. 13240),

Ilya Sergey (Ed.). Springer, 262â€“289. https://doi.org/10.1007/978-3-030-99336-8_10

M. Kokologiannakis, A. Raad, and V. Vafeiadis. 2019. Model checking for weakly consistent libraries. In PLDI, K. S. McKinley

and K. Fisher (Eds.). ACM, 96â€“110. https://doi.org/10.1145/3314221.3314609

S. Krishna, M. Emmi, C. Enea, and D. Jovanovic. 2020. Verifying Visibility-Based Weak Consistency. In ESOP (LNCS,

Vol. 12075), P. MÃ¼ller (Ed.). Springer, 280â€“307. https://doi.org/10.1007/978-3-030-44914-8_11

O. Lahav, E. Namakonov, J. Oberhauser, A. Podkopaev, and V. Vafeiadis. 2021. Making weak memory models fair. Proc. ACM

Program. Lang. 5, OOPSLA (2021), 1â€“27. https://doi.org/10.1145/3485475

O. Lahav and V. Vafeiadis. 2015. Owicki-Gries Reasoning for Weak Memory Models. In ICALP (LNCS, Vol. 9135), M. M.

HalldÃ³rsson, K. Iwama, N. Kobayashi, and B. Speckmann (Eds.). Springer, 311â€“323.

O. Lahav, V. Vafeiadis, J. Kang, C.-K. Hur, and D. Dreyer. 2017. Repairing sequential consistency in C/C++11. In PLDI. ACM,

618â€“632.

L. Lamport. 1979. How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs. IEEE Trans.

Computers 28, 9 (1979), 690â€“691.

S.-H. Lee, M. Cho, A. Podkopaev, S. Chakraborty, C.-K. Hur, O. Lahav, and V. Vafeiadis. 2020. Promising 2.0: global
optimizations in relaxed memory concurrency. In PLDI, A. F. Donaldson and E. Torlak (Eds.). ACM, 362â€“376. https:
//doi.org/10.1145/3385412.3386010

M. Lesani, V. Luchangco, and M. Moir. 2012. Putting Opacity in Its Place. In WTTM.
M. Lesani, L. Xia, A. Kaseorg, C. J. Bell, A. Chlipala, B. C. Pierce, and S. Zdancewic. 2022. C4: verified transactional objects.

Proc. ACM Program. Lang. 6, OOPSLA (2022), 1â€“31. https://doi.org/10.1145/3527324

N. A. Lynch. 1996. Distributed Algorithms. Morgan Kaufmann.
R. Margalit and O. Lahav. 2021. Verifying Observational Robustness against a C11-Style Memory Model. Proc. ACM Program.

Lang. 5, POPL, Article 4 (Jan. 2021), 33 pages. https://doi.org/10.1145/3434285

A. Matveev and N. Shavit. 2015. Reduced Hardware NOrec: A Safe and Scalable Hybrid Transactional Memory. In ASPLOS,

Ã–. Ã–., K. Ebcioglu, and S. Dwarkadas (Eds.). ACM, 59â€“71. https://doi.org/10.1145/2694344.2694393

C. C. Minh, J. Chung, C. Kozyrakis, and K. Olukotun. 2008. STAMP: Stanford Transactional Applications for Multi-
Processing. In IISWC, D. Christie, A. Lee, O. Mutlu, and B. G. Zorn (Eds.). IEEE Computer Society, 35â€“46. https:
//doi.org/10.1109/IISWC.2008.4636089

S. S. Owicki and D. Gries. 1976. An Axiomatic Proof Technique for Parallel Programs I. Acta Inf. 6 (1976), 319â€“340.
M. Paviotti, S. Cooksey, A. Paradis, D. Wright, S. Owens, and M. Batty. 2020. Modular Relaxed Dependencies in Weak Memory
Concurrency. In ESOP (LNCS, Vol. 12075), P. MÃ¼ller (Ed.). Springer, 599â€“625. https://doi.org/10.1007/978-3-030-44914-8_22
A. Podkopaev, I. Sergey, and A. Nanevski. 2016. Operational Aspects of C/C++ Concurrency. CoRR abs/1606.01400 (2016).

arXiv:1606.01400

A. Raad, M. Doko, L. Rozic, O. Lahav, and V. Vafeiadis. 2019a. On library correctness under weak memory consistency:
specifying and verifying concurrent libraries under declarative consistency models. Proc. ACM Program. Lang. 3, POPL
(2019), 68:1â€“68:31. https://doi.org/10.1145/3290381

A. Raad, O. Lahav, and V. Vafeiadis. 2018. On Parallel Snapshot Isolation and Release/Acquire Consistency. In ESOP (LNCS,

Vol. 10801), A. Ahmed (Ed.). Springer, 940â€“967. https://doi.org/10.1007/978-3-319-89884-1_33

A. Raad, O. Lahav, and V. Vafeiadis. 2019b. On the Semantics of Snapshot Isolation. In VMCAI (LNCS, Vol. 11388), C. Enea

and R. Piskac (Eds.). Springer, 1â€“23. https://doi.org/10.1007/978-3-030-11245-5_1

M. Rodriguez and M. F. Spear. 2020. Brief Announcement: On Implementing Software Transactional Memory in the C++
Memory Model. In PODC, Y. Emek and C. Cachin (Eds.). ACM, 224â€“226. https://doi.org/10.1145/3382734.3405746
S. Scargall. 2020. Programming Persistent Memory: A Comprehensive Guide for Developers. APress. https://doi.org/10.1007/978-

1-4842-4932-1_8

G. Sela, M. Herlihy, and E. Petrank. 2021. Brief Announcement: Linearizability: A Typo. In PODC, A. Miller, K. Censor-Hillel,

and J. H. Korhonen (Eds.). ACM, 561â€“564. https://doi.org/10.1145/3465084.3467944

N. Shavit and D. Touitou. 1997. Software Transactional Memory. Distributed Computing 10, 2 (1997), 99â€“116.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:28

Sadegh Dalvandi and Brijesh Dongol

M. Spear, H. Boehm, V. Luchangco, M. L. Scott, and M. Wong. 2020. Transactional Memory Lite Support in C++. Technical

Report. isocpp.

A. J. Summers and P. MÃ¼ller. 2018. Automating Deductive Verification for Weak-Memory Programs. In TACAS (LNCS,

Vol. 10805), D. Beyer and M. Huisman (Eds.). Springer, 190â€“209.

K. Svendsen, J. Pichon-Pharabod, M. Doko, O. Lahav, and V. Vafeiadis. 2018. A Separation Logic for a Promising Semantics.

In ESOP (LNCS, Vol. 10801), A. Ahmed (Ed.). Springer, 357â€“384.

J. Tassarotti, D. Dreyer, and V. Vafeiadis. 2015. Verifying read-copy-update in a logic for weak memory. In PLDI, D. Grove

and S. Blackburn (Eds.). ACM, 110â€“120. https://doi.org/10.1145/2737924.2737992

A. Turon, V. Vafeiadis, and D. Dreyer. 2014. GPS: navigating weak memory with ghosts, protocols, and separation. In

OOPSLA, A. P. Black and T. D. Millstein (Eds.). ACM, 691â€“707.

V. Vafeiadis and C. Narayan. 2013. Relaxed separation logic: A program logic for C11 concurrency. In OOPSLA. 867â€“884.
D. Wright, M. Batty, and B. Dongol. 2021. Owicki-Gries Reasoning for C11 Programs with Relaxed Dependencies. 13047

(2021), 237â€“254. https://doi.org/10.1007/978-3-030-90870-6_13

S. Xiong, A. Cerone, A. Raad, and P. Gardner. 2020. Data Consistency in Transactional Storage Systems: A Centralised
Semantics. In ECOOP (LIPIcs, Vol. 166), R. Hirschfeld and T. Pape (Eds.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik,
21:1â€“21:31. https://doi.org/10.4230/LIPIcs.ECOOP.2020.21

P. Zardoshti, T. Zhou, P. Balaji, M. L. Scott, and M. F. Spear. 2019. Simplifying Transactional Memory Support in C++. ACM

Trans. Archit. Code Optim. 16, 3 (2019), 25:1â€“25:24. https://doi.org/10.1145/3328796

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:29

ğ‘ âˆˆ {ğ‘Ÿğ‘‘ (ğ‘¥, ğ‘£), ğ‘Ÿğ‘‘A (ğ‘¥, ğ‘£)}

ğ‘¤ âˆˆ ğ›¾ .OW ğœ (ğ‘¥)

val(ğ‘¤) = ğ‘£

tviewâ€² = if ğ›¾ .rel(ğ‘¤) âˆ§ ğ‘ = ğ‘Ÿğ‘‘A (ğ‘¥, ğ‘£) then ğ›¾ .tviewğœ âŠ— ğ›¾ .mviewğ‘¤ else ğ›¾ .tviewğœ [ğ‘¥ := ğ‘¤]

ğ›¾ ğ‘

ğœ ğ›¾ [tviewğœ := tviewâ€²]

Read

Write

RMW-RA

ğ‘ âˆˆ {ğ‘¤ğ‘Ÿ (ğ‘¥, ğ‘£), ğ‘¤ğ‘Ÿ R (ğ‘¥, ğ‘£)}
writesâ€² = ğ›¾ .writes âˆª {(ğ‘¥, ğ‘£, ğ‘)}
ğ›¾ ğ‘

tst(ğ‘¤) < ğ‘
ğ‘ = (ğ‘ = ğ‘¤ğ‘Ÿ R (ğ‘¥, ğ‘£))
ğœ ğ›¾ [tviewğœ := tviewâ€², mview(ğ‘¥,ğ‘£,ğ‘) := tviewâ€², writes := writesâ€², rel := ğ›¾ .rel[ğ‘¤ := ğ‘]]

tviewâ€² = ğ›¾ .tviewğœ [ğ‘¥ := (ğ‘¥, ğ‘£, ğ‘)]

w âˆˆ ğ›¾ .OW ğœ (ğ‘¥) \ ğ›¾ .cvd

freshğ›¾ (ğ‘¥, ğ‘)

ğ‘ = ğ‘Ÿğ‘šğ‘¤ RA (ğ‘¥, ğ‘¢, ğ‘£)

w âˆˆ ğ›¾ .OW ğœ (ğ‘¥) \ ğ›¾ .cvd

writesâ€² = ğ›¾ .writes âˆª {(ğ‘¥, ğ‘£, ğ‘)}

val(w) = ğ‘¢

freshğ›¾ (ğ‘¥, ğ‘)
cvdâ€² = ğ›¾ .cvd âˆª {(ğ‘¥, ğ‘£, ğ‘)}

tst(ğ‘¤) < ğ‘

tviewâ€² = if ğ›¾ .rel(ğ‘¤) then ğ›¾ .tviewğœ [ğ‘¥ := (ğ‘¥, ğ‘£, ğ‘)] âŠ— ğ›¾ .mviewğ‘¤ else ğ›¾ .tviewğœ [ğ‘¥ := (ğ‘¥, ğ‘£, ğ‘)]

ğ›¾ ğ‘

ğ‘¡ ğ›¾

(cid:20)tviewğœ := tviewâ€², mview(ğ‘¥,ğ‘£,ğ‘) := tviewâ€²,
writes := writesâ€², cvd := cvdâ€², rel := ğ›¾ .rel[(ğ‘¥, ğ‘£, q) := true]

(cid:21)

Fig. 11. Memory semantics for reads, writes and updates, where freshğ›¾ (ğ‘¥, ğ‘) holds iff there is no write in
ğ›¾ .writes on ğ‘¥ with timestamp ğ‘, i.e., (ğ‘¥, _, ğ‘) âˆ‰ ğ›¾ .writes

A RC11 RAR OPERATIONAL SEMANTICS

We now briefly review the C11 operational semantics (introduced by [Dalvandi et al. 2020a]) used
in our framework.

Component State. Here we detail the C11 state as modelled by the operational semantics. The
first state component is writes which is the set of all global writes to shared locations. Each global
write is represented by a tuple (ğ‘¥, ğ‘£, ğ‘), where ğ‘¥ is a shared location, ğ‘ is a rational number used as
a timestamp, and ğ‘£ is the value written by the global write. The writes to each variable are totally
ordered by timestamps.

For any write ğ‘¤ = (ğ‘¥, ğ‘£, ğ‘), we have var(ğ‘¤) = ğ‘¥, tst(ğ‘¤) = ğ‘ and val(ğ‘¤) = ğ‘£. The state needs
to record the writes that are observable by each thread. A function tviewğ‘¡ is included in the state
to record the viewfront of thread ğ‘¡ (i.e. the latest write that a thread has seen so far). All the writes
with a timestamp greater than or equal to the timestamp of the viewfront of thread ğ‘¡ are ğ‘œğ‘ğ‘ ğ‘’ğ‘Ÿğ‘£ğ‘ğ‘ğ‘™ğ‘’
by the thread. Another component of the state is a function mviewğ‘¤ that records the viewfront of
write ğ‘¤, which is set to be the viewfront of the thread that executed ğ‘¤ at the time of ğ‘¤â€™s execution.
mviewğ‘¤ is used to compute a new value for tviewğ‘¡ if a thread ğ‘¡ synchronizes with ğ‘¤. The state
also must record If a global write is ğ‘Ÿğ‘’ğ‘™ğ‘’ğ‘ğ‘ ğ‘–ğ‘›ğ‘”. This is recorded by a function relğ‘¤ which returns
true if ğ‘¤ is releasing or false otherwise. Finally, the state maintains a variable cvd âŠ† writes. The
semantics assumes that each update action occurs in the modification order immediately after
the write that it reads from to preserve the atomicity of updates. To prevent any newer write to
intervene between any update and the write that it reads from, we add all the writes read by an
update operation to the the covered set cvd so newer writes should never interact with covered
writes.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:30

Sadegh Dalvandi and Brijesh Dongol

Initialisation. The initial state ğ›¾ Init is defined as follows.

ğ›¾ Init.writes Ë†= {(ğ‘¥, 0, 0) | ğ‘¥ âˆˆ Loc}

ğ›¾ Init.cvd Ë†= âˆ…
ğ›¾ Init.rel Ë†= ğœ†(ğ‘¥, 0, 0). false
ğ›¾ Init.tviewğœ Ë†= ğœ†ğ‘¥ âˆˆ Loc. (ğ‘¥, 0, 0)
ğ›¾ Init.mviewğ‘¤ Ë†= ğœ†ğ‘¥ âˆˆ Loc. (ğ‘¥, 0, 0)

Transition semantics. The transition relation of our semantics for global reads and writes is given

in Fig. 11 [Dalvandi et al. 2020a].

Read transition by thread ğœ. Assume that ğ‘ is either a relaxed or acquiring read to variable
ğ‘¥, ğ‘¤ is a write to ğ‘¥ that ğ‘¡ can observe (i.e., (ğ‘¤, ğ‘, ğ‘£) âˆˆ ğ›¾ .OW ğœ (ğ‘¥)), and the value read by ğ‘ is the
value written by ğ‘¤. Each read causes the viewfront of ğ‘¡ to be updated. For an unsynchronised
read, tviewğ‘¡ is simply updated to include the new write. A synchronised read causes the executing
threadâ€™s view of the executing component and context to be updated. In particular, for each variable
ğ‘¥, the new view of ğ‘¥ will be the later (in timestamp order) of either tviewğ‘¡ (ğ‘¥) or mviewğ‘¤ (ğ‘¥).

Write transition by thread ğ‘¡. A write transition must identify the write (ğ‘¤, ğ‘£, ğ‘) after which
ğ‘ occurs. This ğ‘¤ must be observable and must not be covered â€” the second condition preserves the
atomicity of read-modify-write (RMW) updates. We must choose a fresh timestamp ğ‘â€² âˆˆ Q for ğ‘,
which for a C11 state ğ›¾ is formalised by freshğ›¾ (ğ‘, ğ‘â€²) = ğ‘ < ğ‘â€² âˆ§ âˆ€ğ‘¤ â€² âˆˆ ğ›¾ .writes. ğ‘ < tst(ğ‘¤ â€²) â‡’
ğ‘â€² < tst(ğ‘¤ â€²). That is, ğ‘â€² is a new timestamp for variable ğ‘¥ and that (ğ‘, ğ‘â€², ğ‘£ â€²) occurs immediately
after (ğ‘¤, ğ‘£, ğ‘). The new write is added to the set writes.

We update ğ›¾ .tviewğ‘¡ to include the new write, which ensures that ğ‘¡ can no longer observe any
writes prior to (ğ‘, ğ‘£ â€², ğ‘â€²). Moreover, we set the viewfront of (ğ‘, ğ‘£ â€², ğ‘â€²) to be the new viewfront of ğ‘¡ in
ğ›¾ together with the thread viewfront of the environment state ğ›½. If some other thread synchronises
with this new write in some later transition, that threadâ€™s view will become at least as recent
as ğ‘¡â€™s view at this transition. Since mview keeps track of the executing threadâ€™s view of both the
component being executed and its context, any synchronisation through this new write will update
views across components.

Update (aka RMW) transition by thread ğ‘¡. These transitions are best understood as a combi-
nation of the read and write transitions. As with a write transition, we must choose a valid fresh
timestamp ğ‘â€², and the state component writes is updated in the same way. State component mview
includes information from the new view of the executing thread ğ‘¡. As discussed earlier, in Update
transitions it is necessary to record that the write that the update interacts with is now covered,
which is achieved by adding that write to cvd. Finally, we must compute a new thread view, which
is similar to a Read transition, except that the threadâ€™s new view always includes the new write
introduced by the update.

B TMS2-RA OPERATIONAL SEMANTICS

This section presents further details of the operational semantics from Â§3.3 of TMS2-RA as formalised
in our Isabelle/HOL development.

Component State. Here we present the transactional state of TMS2-RA which builds on the earlier
semantics of TMS2 [Doherty et al. 2013]. The state space of TMS2-RA extends the state space
of TMS2 and comprises several components. The first component is M which is a sequence that
keeps track of memory snapshots (memory states). The status of each transaction ğ‘¡ is stored in

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:31

statusğ‘¡ which can have any of the following values: NOTSTARTED, READY, COMMITTED, ABORTED.
Each transaction ğ‘¡ also has a write set (wrSetğ‘¡ ) and a read set (rdSetğ‘¡ ) where the writes and reads
performed by the transaction are stored. For each transaction ğ‘¡ there is also a beginIdxğ‘¡ variable
which is set to the most recent memory version when the transaction begins. We extend the TMS2
state space with a number of new components. The seenIdxsğ‘¡ variable stores the memory version
of all the reads performed by the transaction. Vğ‘– is the memory modification view of a stored memory
ğ‘– (0 â‰¤ ğ‘– â‰¤ |M | âˆ’ 1). Memory modification view of memory ğ‘– is an snapshot of the transactionâ€™s
client thread view at the time of commiting taht memory. Sğ‘– indicates that if the transaction that
committed memory version ğ‘– was releasing.

Initialisation. The initial state ğ›¾ Init is defined as follows:

ğ›¾ Init.M Ë†= âŸ¨(ğœ†ğ‘™ âˆˆ ğ¿ğ‘œğ‘. 0)âŸ©
ğ›¾ Init.ğ‘‰ Ë†= âŸ¨(ğœ†ğ‘™ âˆˆ ğ¿ğ‘œğ‘. ğ›½ Init.tviewğ‘¡ (ğ‘™))âŸ©
ğ›¾ Init.S Ë†= âŸ¨falseâŸ©
ğ›¾ Init.statusğ‘¡ Ë†= NOTSTARTED
ğ›¾ Init.rdSetğ‘¡ Ë†= âˆ…
ğ›¾init .wrSetğ‘¡ Ë†= âˆ…
ğ›¾ Init.seenIdxsğ‘¡ Ë†= âˆ…
ğ›¾ Init.beginIdxğ‘¡ Ë†= 0

where ğ›½ Init is the initial state of the client program.

Transition semantics of TMS2-RA. The transition relation of our TMS2-RA semantics for various

transactional operations is given in Fig. 6 and explained below.

TxBegin operation by transaction ğ‘¡. A transaction starts with a TxBegin operation and
should specify if it is a relaxed or releasing/acquiring transaction. The TxBegin operation takes ğ‘
and ğ‘Ÿ and sets the value of synctypeğ‘¡ accordingly. It also sets the value beginIdxğ‘¡ to be the latest
memory version at the time of begining the transaction and changes the statusğ‘¡ to READY. Values
of seenIdxsğ‘¡ , rdSetğ‘¡ , and wrSetğ‘¡ are set to empty.

TxWrite operation by transaction ğ‘¡. Assuming that ğ‘™ is a location and ğ‘£ is a value and
statusğ‘¡ = READY, TxWrite operation of transaction ğ‘¡ adds the ğ‘™ â†¦â†’ ğ‘£ pair to the write set of
transaction ğ‘¡ (i.e. wrSetğ‘¡ ). Other state components remain unchanged.

TxRead operation by transaction ğ‘¡. The transactional read operation (TxRead) reads the
value (ğ‘£) of location ğ‘™ from the transaction ğ‘¡â€™s write set (wrSetğ‘¡ ) if the transaction ğ‘¡ has previously
wrote to the location ğ‘™ (ğ‘™ âˆˆ dom(wrSetğ‘¡ )). In this case the state will remain unchanged.

If ğ‘¡ has not previously written to ğ‘™ (ğ‘™ âˆ‰ dom(wrSetğ‘¡ )) then the value of ğ‘™ will be read from a
memory version ğ‘– where ğ‘– is greater than or equal to beginIdxğ‘¡ and the rdSetğ‘¡ is consistent with
that memory version (i.e. rdSetğ‘¡ âŠ† Mğ‘– ). In this case version ğ‘– will be added to seenIdxsğ‘¡ and
the transactionâ€™s read set (rdSetğ‘¡ ) is also updated to include the ğ‘™ â†¦â†’ ğ‘£. seenIdxs is particularly
important for synchronisation if the transaction is acquiring.

TxEndRO operation by transaction ğ‘¡. A read-only transaction is committed by TxEndRO. If
a transaction is read-only (wrSetğ‘¡ = âˆ…) then it updates statusğ‘¡ of the transaction state (ğ›¾) to be
COMMITTED and will leave the rest of the state unchanged. If the transaction was set to be acquiring

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:32

Sadegh Dalvandi and Brijesh Dongol

by TxBegin (isAcqğ‘¡ = ğ‘‡ğ‘Ÿğ‘¢ğ‘’) and the transactionâ€™s read set is not empty (rdSetğ‘¡ â‰  âˆ…) then the
clientâ€™s thread view (ğ›½.tviewğ‘¡ ) may also get synchronised as well.

TxEndWR operation by transaction ğ‘¡. A writer transaction is committed by TxEndWR. Simil-
lar to a read-only transaction, a writer transaction (wrSetğ‘¡ â‰  âˆ…) will set ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğ‘¡ to COMMITTED.
A writer transaction also add a new memory version ğ‘– to M where ğ‘– is equal to the size of ğ›¾ .M
meaning that the new memory version is added to the end of M sequence. The new memory
version is obtained by overrwriting the latest memory version in ğ›¾ .M with the transactionâ€™s write
set: ğ‘šğ‘’ğ‘šâ€² = last (ğ›¾ .M) âŠ• wrSetğ‘¡ ). The function ğ‘™ğ‘ğ‘ ğ‘¡ is defined as ğ‘™ğ‘ğ‘ ğ‘¡ (ğ‘š) Ë†= ğ‘š |ğ‘š |âˆ’1. The memory
modification view (ğ‘‰ğ‘– ) of the new memory version ğ‘– and the updated thread view of the clinet state
(tviewğ‘¡ ) is going to be the same and determined by tviewâ€². The value of tviewâ€² is determined in
the same way as explained for TxEndRO.

TxAbort operation by transaction ğ‘¡. If transaction ğ‘¡ aborts, TxAbort will set statusğ‘¡ to
ABORTED. At this point, other transaction operations (except TxBegin) cannot be executed. The
client state ğ›½ will remain unchanged.

C FORWARD SIMULATION IMPLIES OBSERVATIONAL REFINEMENT

We have already shown that there exists a forward simulation between TMS2-ra and TML-ra. In
this section, we show that if there exists a forward simulation between an abstract TM specification
ğ´ğ‘‚ and a concrete implementation ğ¶ğ‘‚ as defined in Definition 5, then for any client ğ‘ƒ, ğ‘ƒ [ğ¶ğ‘‚] is a
contextual refinement of ğ‘ƒ [ğ´ğ‘‚] (ğ‘ƒ [ğ¶ğ‘‚] â‰¤ ğ‘ƒ [ğ´ğ‘‚]).

Theorem 2. If ğ‘… is a forward simulation between ğ´ğ‘‚ and ğ¶ğ‘‚, then for any client ğ‘ƒ we have

ğ‘ƒ [ğ¶ğ‘‚] â‰¤ ğ‘ƒ [ğ´ğ‘‚].

Proof. Assume ft is a full trace of ğ‘ƒ [ğ¶ğ‘‚], where for each ğ‘–, ftğ‘– is a triple is of the form (lsğ‘–, ğ›¾ğ‘–, ğ›½ğ‘– ).
We show that there exists a full trace aft of ğ‘ƒ [ğ´ğ‘‚] such that ğœ‰ (ft) â‰¤ ğœ‰ (aft) (see Definition 2), where
ğœ‰ (ft) projects the full trace to the client trace, i.e., for each ğ‘–, ğœ‰ (ft)ğ‘– = (lsğ‘– |ğ‘ƒ, ğ›½ğ‘– ) (and similarly ğœ‰ (aft)),
and additionally removes any stuttering.

The proof is by induction over prefixes ft â€² of ft.
For the base case, ft â€² = âŸ¨(lsInit, ğ›¾ Init

ğ¶ , ğ›½ Init

â€œInitialisationâ€ of Definition 5 there exists a (alsInit, ğ›¾ Init

ğ¶ )âŸ© is a trace containing just the initial state of ğ¶. By

ğ‘…((alsInit, ğ›¾ Init

ğ¶ ))
Moreover, by â€œClient observationâ€ of Definition 5, we have alsInit
and locations ğ‘¥, ğ›½ Init
ğœ‰ (ft) â‰¤ ğœ‰ (aft).

ğ¶ .OW (ğœ, ğ‘¥) âŠ† ğ›½ Init

ğ´ , ğ›½ Init

|ğ‘ƒ and for all threads ğœ
ğ´ .OW (ğœ, ğ‘¥). Thus, for ğœ‰ (ft) there exists an aft such that

|ğ‘ƒ = lsInit

For our inductive hypothesis, assume the result holds for ft â€², i.e., there exists an abstrace pre-
fix aft â€² of an abstract trace aft of ğ‘ƒ [ğ´ğ‘‚] such that ğœ‰ (ft â€²) â‰¤ ğœ‰ (aft â€²). Moreover, we assume that
ğ‘…(last (aft â€²), last (ft â€²)). Suppose ft â€²â€² = ft â€² Â· âŸ¨(ls, ğ›¾ğ¶, ğ›½ğ¶ )âŸ© where (ls, ğ›¾ğ¶, ğ›½ğ¶ ) is generated by a concrete
step from last (ft â€²). There are three possibilites based on the step taken by the concrete program.
â€¢ The first case is when the concrete program takes a library step and ft â€²â€² is the program
trace after the execution of the library step, because we already proved ğ¶ğ‘‚ â‰¤ ğ´ğ‘‚ then
by preservation rule of Definition 5 we know that there exists an abstract trace aft â€²â€² =
aft â€² Â· âŸ¨(als, ğ›¾ğ´, ğ›½ğ´)âŸ© such that ğ‘…((als, ğ›¾ğ´, ğ›½ğ´), (ls, ğ›¾ğ¶, ğ›½ğ¶ )). Moreover using â€œClient observationâ€
of Definition 5, we have ğœ‰ (ft â€²â€²) â‰¤ ğœ‰ (aft â€²â€²).

â€¢ The next case is when the concrete program takes a non-synchronising client step. Since
the abstract and concrete takes the same non-synchronising step, the abstract and concrete

ğ´ , ğ›½ Init
ğ´ ), (lsInit, ğ›¾ Init

ğ´ ) such that
ğ¶ , ğ›½ Init

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:33

library states remain unchanged, thus ğ‘…ğ‘‚ ((als |ğ´ğ‘‚, ğ›¾ğ´), (ls |ğ¶ğ‘‚, ğ›¾ğ¶ )). Moreover, the thread view
and local state of both abstract and concrete programs will be updated in the same way,
thus we also have ğ‘…ğ‘‰ ((als, ğ›½ğ´), (ls, ğ›½ğ¶ )). Finally, by the client observation property and the
refinement relation ğ‘… are preserved. Since we match the concrete step at the abstract level,
we have ğœ‰ (ft â€²â€²) â‰¤ ğœ‰ (aft â€²â€²).

â€¢ The last case is when the concrete program takes a synchronising client step. Like the un-
synchronising case, the abstract and concrete client steps are identical and they both update
the thread view and local state of the client in the same way, thus ğ‘…ğ‘‰ ((als, ğ›½ğ´), (ls, ğ›½ğ¶ )).
Thus, we have ğœ‰ (ft â€²â€²) â‰¤ ğœ‰ (aft â€²â€²). We must now show that the refinement relation holds in
the post-state. As opposed to the previous case, the synchronising client step potentially
updates the library state by advancing the library thread view for the executing thread, ğœ.
However, this is equivalent to moving the library view forward using the â€œThread view
stabilityâ€ property of Definition 5. Thus, we have ğ‘…ğ‘‚ ((als |ğ´ğ‘‚, ğ›¾ğ´), (ls |ğ¶ğ‘‚, ğ›¾ğ¶ )).

â–¡

D SELECTION OF TARO PROOF RULES

We present a selection of TARO proof rules that we use in our examples. The full development [Dal-
vandi and Dongol 2022] contains many other rules, but we do not present all of these, since they
are less interesting. Note that ğ‘§ below is a client variable.

D.1 Assertions over TxBegin

(1) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ (cid:9) TxBegin_ (_, _) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ (cid:9)
(2) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ (cid:9) TxBegin_ (_, _) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ (cid:9)
(3) (cid:8)[ğ‘§ = ğ‘¢]ğœ (cid:9) TxBegin_(_, _) (cid:8)[ğ‘§ = ğ‘¢]ğœ (cid:9)
(4) (cid:8)true(cid:9) TxBeginğœ (R, _) (cid:8)ğ‘…ğ‘’ğ‘™ğœ (cid:9)
(5) (cid:8)true(cid:9) TxBeginğœ (A, _) (cid:8)ğ´ğ‘ğ‘ğœ (cid:9)
(6) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ â€² âˆ§ ğœ â‰  ğœ â€²(cid:9) TxBeginğœ (_, _) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ â€² (cid:9)

D.2 Assertions over TxRead

(1) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ (cid:9) TxRead_(_, _) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ (cid:9)
(2) (cid:8)[ Ë†ğ‘¥ = ğ‘¢]ğœ â€² (cid:9) TxReadğœ (_, _) (cid:8)ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğœ = READY â‡’ [ Ë†ğ‘¥ = ğ‘¢]ğœ â€² (cid:9)
(3) (cid:8)WSğœ = âˆ…(cid:9) TxReadğœ ( Ë†ğ‘¥, ğ‘Ÿ ) (cid:8)( Ë†ğ‘¥, ğ‘Ÿ ) âˆˆ RSğœ (cid:9)
(4) (cid:8)( Ë†ğ‘¥, ğ‘Ÿ ) âˆ‰ WSğœ (cid:9) TxReadğœ ( Ë†ğ‘¥, ğ‘Ÿ ) (cid:8)[ Ë†ğ‘¥ â‰ˆ ğ‘Ÿ ]ğœ (cid:9)
(5) (cid:8)[ Ë†ğ‘¥ = ğ‘¢]ğœ âˆ§ Ë†ğ‘¥ âˆ‰ dom(WSğœ )(cid:9) TxReadğœ ( Ë†ğ‘¥, ğ‘Ÿ ) (cid:8)ğ‘Ÿ = ğ‘¢(cid:9)
(6) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ (cid:9) TxRead_(_, _) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ (cid:9)
(7) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ RSğœ â€² âˆ§ ğœ â‰  ğœ â€²(cid:9) TxReadğœ (_, _) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ RSğœ â€² (cid:9)

D.3 Assertions over TxWrite

(1) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ (cid:9) TxWrite_ (_, _) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ (cid:9)
(2) (cid:8)[ğ‘§ = ğ‘¢]ğœ (cid:9) TxWrite_ (_, _) (cid:8)[ğ‘§ = ğ‘¢]ğœ (cid:9)
(3) (cid:8)true(cid:9) TxWriteğœ ( Ë†ğ‘¦, ğ‘£) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ (cid:9)

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:34

Sadegh Dalvandi and Brijesh Dongol

(4) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ âˆ§ ğ‘¤ â‰  ğ‘¢(cid:9) TxWriteğœ ( Ë†ğ‘¦, ğ‘¤) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ (cid:9)
(5) (cid:8) Ë†ğ‘¥ â‰  Ë†ğ‘¦ âˆ§ ( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ (cid:9) TxWrite_ ( Ë†ğ‘¥, _) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ (cid:9)

D.4 Assertions over TxEnd

(1) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² âˆ§ WSğœ = âˆ…(cid:9) TxEndğœ (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² (cid:9)

(cid:26)( Ë†ğ‘¥, ğ‘¢) âˆˆ WSğœ âˆ§ Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ â€² âˆ§
[ğ‘§ = ğ‘£]ğœ âˆ§ ğ‘…ğ‘’ğ‘™ğœ âˆ§ ğœ â‰  ğœ â€²

(cid:27)

(2)

TxEndğœ (cid:8)ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğœ = COMMITTED â‡’ âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² (cid:9)

(3) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ âˆ§ ( Ë†ğ‘¥, ğ‘¢) âˆ‰ WSğœ âˆ§ ğ‘…ğ‘’ğ‘™ğœ (cid:9) TxEndğœ (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ (cid:9)
(4) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² (cid:9) TxEndğœ (cid:8)ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğœ = ABORTED â‡’ âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² (cid:9)

(cid:26)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ âˆ§ ( Ë†ğ‘¥, ğ‘¢) âˆˆ RSğœ âˆ§
ğ´ğ‘ğ‘ğœ âˆ§ WSğœ = âˆ…

(cid:27)

(5)

TxEndğœ (cid:8)ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğœ = COMMITTED â‡’ [ğ‘§ = ğ‘£]ğœ (cid:9)

(6) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ â€² âˆ§ ( Ë†ğ‘¥, ğ‘¢) âˆ‰ WSğœ (cid:9) TxEndğœ (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘¢]ğœ â€² (cid:9)
(7) (cid:8)[ğ‘¦ = ğ‘£]ğœ (cid:9) TxEndğœ (cid:8)[ğ‘¦ = ğ‘£]ğœ (cid:9)
(8) (cid:8)[ğ‘¥ â‰ˆ ğ‘¢]ğœ â€² âˆ§ Â¬ğ´ğ‘ğ‘ğœ (cid:9) TxEndğœ (cid:8)[ğ‘¥ â‰ˆ ğ‘¢]ğœ â€² (cid:9)
(9) (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ â€² (cid:9) TxEndğœ (cid:8)( Ë†ğ‘¦, ğ‘£) âˆˆ WSğœ â€² (cid:9)

D.5 Assertions over client actions

(1) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² (cid:9) ğ‘Ÿ â†ğœ ğ‘§ â€² (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ â€² (cid:9)
(2) (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ âˆ§ ğ‘§ â‰  ğ‘§ â€²(cid:9) ğ‘§ â€² :=ğœ ğ‘š (cid:8)âŸ¨ Ë†ğ‘¥ = ğ‘¢âŸ©[ğ‘§ = ğ‘£]ğœ (cid:9)

E ADDITIONAL EXAMPLES

This section provides the full proof outline for two additional examples. The proof outline presented
in Fig. 13 includes two new assertions that were not introduced previously:

â€¢ Memory-value assertion: A memory-value assertion, denoted as M [ Ë†ğ‘¥, ğ‘£]ğ‘– , holds iff the

value of location ğ‘¥ in memory version ğ‘– is ğ‘£.

M [ Ë†ğ‘¥, ğ‘£]ğ‘– Ë†= ğ‘– âˆˆ dom(M) âˆ§ Mğ‘– ( Ë†ğ‘¥) = ğ‘£

â€¢ Never-written assertion: A never-written assertion, denoted as ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£], holds iff none

of the recorded memories in M has the value ğ‘£ for location ğ‘¥.

ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£] Ë†= âˆ€ğ‘– âˆˆ dom(M). Â¬M [ Ë†ğ‘¥, ğ‘£]ğ‘–

A selection of proof rules over memory-value and never-written predicates are given below.
(1) (cid:8)M [ Ë†ğ‘¥, ğ‘¢]ğ‘– (cid:9) TxBeginğœ (_, _)(cid:8)M [ Ë†ğ‘¥, ğ‘¢]ğ‘– (cid:9)
(2) (cid:8)M [ Ë†ğ‘¥, ğ‘¢]ğ‘– (cid:9) TxReadğœ (_, _) (cid:8)M [ Ë†ğ‘¥, ğ‘¢]ğ‘– (cid:9)
(3) (cid:8)M [ Ë†ğ‘¥, ğ‘¢]ğ‘– (cid:9) TxWriteğœ (_, _)(cid:8)M [ Ë†ğ‘¥, ğ‘¢]ğ‘– (cid:9)
(4) (cid:8)( Ë†ğ‘¥, ğ‘¢) âˆˆ WSğœ âˆ§ |M | = ğ‘›(cid:9) TxEndğœ (cid:8)ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğœ = COMMITTED â‡’ M [ Ë†ğ‘¥ = ğ‘¢]ğ‘›(cid:9)
(5) (cid:8)M [ Ë†ğ‘¥ = ğ‘£]ğ‘– âˆ§ ğ‘– < |M | âˆ’ 1(cid:9) TxEndğœ (cid:8)M [ Ë†ğ‘¥ = ğ‘£]ğ‘– (cid:9)

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:35

TxReadğœ ( Ë†ğ‘¦, ğ‘Ÿ ) (cid:8)ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ğœ = READY â‡’ ğ‘Ÿ = ğ‘›(cid:9)

M [ Ë†ğ‘¥ = ğ‘¢]ğ‘–âˆ’1 âˆ§ M [ Ë†ğ‘¥ = ğ‘£]ğ‘– âˆ§
M [ Ë†ğ‘¦ = ğ‘™]ğ‘–âˆ’1 âˆ§ M [ Ë†ğ‘¦ = ğ‘›]ğ‘– âˆ§
ğ‘¢ â‰  ğ‘£ âˆ§ ğ‘™ â‰  ğ‘› âˆ§ ğ‘– = |M | âˆ’ 1 âˆ§
txnğœ = ğ‘¡ âˆ§ ğ‘ğ‘’ğ‘”ğ‘–ğ‘›ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥ğ‘¡ = ğ‘– âˆ’ 1 âˆ§
( Ë†ğ‘¥, ğ‘£) âˆˆ RSğœ âˆ§ WSğœ = âˆ…

(6)

ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´

ï£³

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´

ï£¾

(7) (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£](cid:9) TxBeginğœ (_, _) (cid:8)Â¬[ Ë†ğ‘¥ â‰ˆ ğ‘£]ğœ â€² (cid:9)
(8) (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£](cid:9) TxBeginğœ (_, _) (cid:8)ğ‘ğ‘Š [ğ‘¥, ğ‘£](cid:9)
(9) (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£](cid:9) TxReadğœ (_, _) (cid:8)ğ‘ğ‘Š [ğ‘¥, ğ‘£](cid:9)
(10) (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£](cid:9) TxWriteğœ (_, _) (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£](cid:9)
(11) (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£] âˆ§ ( Ë†ğ‘¥, ğ‘£) âˆ‰ WSğœ (cid:9) TxEndğœ (cid:8)ğ‘ğ‘Š [ Ë†ğ‘¥, ğ‘£](cid:9)
Theorem 4. The proof outlines in Fig. 12 and Fig. 13 are valid.

Proof. This theorem has been verified in Isabelle/HOL.

â–¡

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

1:36

Sadegh Dalvandi and Brijesh Dongol

(cid:8)âˆ€ğœ âˆˆ {ğœ1, ğœ2, ğœ3}. [ Ë†ğ‘“ = 0]ğœ âˆ§ [ğ‘‘1 = 0]ğœ âˆ§ [ğ‘‘2 = 0]ğœ (cid:9)

Thread ğœ1
(cid:8)[ Ë†ğ‘“ (cid:48) 1]ğœ2 âˆ§ [ğ‘‘1 = 0]ğœ1 âˆ§ Â¬tf
1 : ğ‘‘1 := 5;
(cid:8)[ Ë†ğ‘“ (cid:48) 1]ğœ2 âˆ§ [ğ‘‘1 = 5]ğœ1 âˆ§ Â¬tf
2 : TxBegin(R, âˆ…)
(cid:26)[ Ë†ğ‘“ (cid:48) 1]ğœ2 âˆ§ [ğ‘‘1 = 5]ğœ1 âˆ§
Relğœ1 âˆ§ Â¬tf
1
3 : TxWrite(ğ‘“ , 1) ;
(cid:26)[ Ë†ğ‘“ (cid:48) 1]ğœ2 âˆ§ [ğ‘‘1 = 5]ğœ1 âˆ§
Relğœ1 âˆ§ ( Ë†ğ‘“ , 1) âˆˆ WSğœ1 âˆ§ Â¬tf
4 : âŸ¨TxEnd, tf
1 := trueâŸ© ;
(cid:8)âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘1 = 5]ğœ2 âˆ§ tf

(cid:27)

(cid:9)

1

1

(cid:9)

(cid:9)

1

1

(cid:27)

ï£¼ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´
ï£¾

(cid:27)

1) âˆ§

1)(cid:9)
1)(cid:9)

Thread ğœ2
(cid:8)ğ‘ƒ (0) âˆ§ ( [ Ë†ğ‘“ â‰ˆ 1]ğœ2 â‡’ tf
5 : ğ‘‘2 := 10;
(cid:8)ğ‘ƒ (10) âˆ§ ( [ Ë†ğ‘“ â‰ˆ 1]ğœ2 â‡’ tf
6 : TxBegin(RA, {r2})
(cid:26)ğ‘ƒ (10) âˆ§ ( [ Ë†ğ‘“ â‰ˆ 1]ğœ2 â‡’ tf
Acqğœ2 âˆ§ Relğœ2 âˆ§ WSğœ2 = âˆ…
7 : TxRead(ğ‘“ , ğ‘Ÿ2) ;
ğ‘ƒ (10) âˆ§
ï£±ï£´ï£´ï£´ï£´ï£²
(ğ‘Ÿ2 = 1 â‡’ [ğ‘‘1
Acqğœ2 âˆ§ Relğœ2 âˆ§
ï£´ï£´ï£´ï£´
WSğœ2 = âˆ… âˆ§ ( Ë†ğ‘“ , ğ‘Ÿ2) âˆˆ RSğœ2
ï£³
8 : if ğ‘Ÿ2 = 1 then
ğ‘†
ï£±ï£´ï£´ï£´ï£²
= 5]ğœ2 âˆ§ tf
ğ‘ƒ (10) âˆ§ [ğ‘‘1
ğ‘Ÿ2 = 1 âˆ§ Acqğœ2 âˆ§ Relğœ2 âˆ§
ï£´ï£´ï£´
WSğœ2 = âˆ… âˆ§ ( Ë†ğ‘“ , ğ‘Ÿ2) âˆˆ RSğœ2
ï£³
9 :

ğ‘†
= 5]ğœ2 âˆ§ tf

TxWrite(ğ‘“ , 2)

1 âˆ§

1) âˆ§

1 âˆ§

(cid:33)

âˆ§

ğ‘†
= 5]ğœ2 âˆ§ tf
ğ‘ƒ (10) âˆ§ [ğ‘‘1
ğ‘Ÿ2 = 1 âˆ§ Acqğœ2 âˆ§ Relğœ2 âˆ§
WSğœ2 = {( Ë†ğ‘“ , 2)} âˆ§
( Ë†ğ‘“ , ğ‘Ÿ2) âˆˆ RSğœ2

ï£±ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´
ï£³
ğ‘ƒ (10) âˆ§ Acqğœ2 âˆ§ Relğœ2 âˆ§
(ğ‘Ÿ2 â‰  1 â‡’ WSğœ2 = âˆ…) âˆ§
(cid:32)
ğ‘†
ğ‘Ÿ2 = 1 â‡’ [ğ‘‘1
= 5]ğœ2 âˆ§
tf
( Ë†ğ‘“ , ğ‘Ÿ2) âˆˆ RSğœ2
ï£³
10 : TxEnd ;
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘2 = 10]ğœ3 âˆ§
(cid:18)ğ‘Ÿ2 â‰  1 â‡’

1 âˆ§ ( Ë†ğ‘“ , 2) âˆˆ WSğœ2

ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´

ï£¼ï£´ï£´ï£´ï£½
ï£´ï£´ï£´
ï£¾

ï£¾

ï£¼ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´
ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´ï£´

ï£¾

ï£¼ï£´ï£´ï£½
ï£´ï£´
ï£¾

ï£¼ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´
ï£¾

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´

1 â‡’ [ Ë†ğ‘“ (cid:48) 1]ğœ3 âˆ§ [ Ë†ğ‘“ (cid:48) 2]ğœ3)

1 â‡’ [ Ë†ğ‘“ (cid:48) 1]ğœ3 âˆ§ [ Ë†ğ‘“ (cid:48) 2]ğœ3)

Thread ğœ3
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘1 = 5]ğœ3 âˆ§
ï£±ï£´ï£´ï£²
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘2 = 10]ğœ3 âˆ§
ï£´ï£´
(Â¬tf
ï£³
11 : TxBegin(A, {r3})
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘1 = 5]ğœ3 âˆ§
ï£±ï£´ï£´ï£´ï£´ï£²
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘2 = 10]ğœ3 âˆ§
(Â¬tf
ï£´ï£´ï£´ï£´
âˆ§WSğœ3 = âˆ… âˆ§ Acqğœ3
ï£³
12 : TxRead(ğ‘“ , ğ‘Ÿ3) ;
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘1 = 5]ğœ3 âˆ§
âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘2 = 10]ğœ3 âˆ§
(cid:18)Â¬tf

ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´

1 â‡’
[ Ë†ğ‘“ (cid:48) 1]ğœ3 âˆ§ [ Ë†ğ‘“ (cid:48) 2]ğœ3

(cid:19)

âˆ§

WSğœ3 = âˆ… âˆ§
( Ë†ğ‘“ , ğ‘Ÿ3) âˆˆ RSğœ3 âˆ§ Acqğœ3 âˆ§
(cid:32)ğ‘Ÿ3 = 2 â‡’
[ğ‘‘1
ï£³
ï£¾
13 : TxEnd ;
(cid:8)ğ‘Ÿ3 = 2 â‡’ [ğ‘‘1 = 5]ğœ3 âˆ§ [ğ‘‘2 = 10]ğœ3
14 : if ğ‘Ÿ3 = 2 then

ğ‘†
= 5]ğœ3 âˆ§ [ğ‘‘2

ğ‘†
= 10]ğœ3

(cid:33)

(cid:9)

(cid:9)

15 :

(cid:8)[ğ‘‘1 = 5]ğœ3 âˆ§ [ğ‘‘2 = 10]ğœ3
ğ‘ 1 â† ğ‘‘1
(cid:8)ğ‘ 1 = 5 âˆ§ [ğ‘‘2 = 10]ğœ3
ğ‘ 2 â† ğ‘‘2
(cid:8)ğ‘ 1 = 5 âˆ§ ğ‘ 2 = 10(cid:9)
(cid:8)ğ‘Ÿ3 = 2 â‡’ ğ‘ 1 = 5 âˆ§ ğ‘ 2 = 10(cid:9)

16 :

(cid:9)

(cid:19)

ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´

[ Ë†ğ‘“ (cid:48) 2]ğœ1 âˆ§ [ Ë†ğ‘“ (cid:48) 2]ğœ3

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´
1 âˆ§ âŸ¨ Ë†ğ‘“ = 2âŸ©[ğ‘‘1 =ğœ3 5]
ï£¾
{ğ‘Ÿ3 = 2 â‡’ ğ‘ 1 = 5 âˆ§ ğ‘ 2 = 10}
Fig. 12. Proof outline for extended transactional MP, where ğ‘ƒ (ğ‘˜) Ë†= [ğ‘‘2 = ğ‘˜]ğœ2 âˆ§ âŸ¨ Ë†ğ‘“ = 1âŸ©[ğ‘‘1 = 42]ğœ2 âˆ§ [ Ë†ğ‘“ (cid:48)
2]ğœ1 âˆ§ [ Ë†ğ‘“ (cid:48) 2]ğœ3

(cid:18)ğ‘Ÿ2 = 1 â‡’
tf

âˆ§

ï£³

(cid:19)

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

Implementing and Verifying Release-Acquire Transactional Memory (Extended Version)

1:37

(cid:27)

(cid:27)

Thread ğœ1
(cid:26)ğ‘ğ‘Š [ Ë†ğ‘“ , 1] âˆ§ ğ‘ğ‘Š [ Ë†ğ‘‘2, 10]
âˆ§[ğ‘‘1 = 0]ğœ1 âˆ§ |M | = 0
1 : ğ‘‘1 := 5;
(cid:26)ğ‘ğ‘Š [ Ë†ğ‘“ , 1] âˆ§ ğ‘ğ‘Š [ Ë†ğ‘‘2, 10]
âˆ§[ğ‘‘1 = 5]ğœ1 âˆ§ |M | = 0
2 : TxBegin(RX, âˆ…) ;
Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 âˆ§ Â¬[ Ë†ğ‘‘2 â‰ˆ 10]ğœ2
ï£±ï£´ï£´ï£´ï£´ï£²
ï£¼ï£´ï£´ï£´ï£´ï£½
âˆ§[ğ‘‘1 = 5]ğœ1 âˆ§ Â¬Relğœ1
âˆ§ statusğœ1 = ğ‘…
ï£´ï£´ï£´ï£´
ï£´ï£´ï£´ï£´
âˆ§Â¬Acqğœ1 âˆ§ |M | = 0
ï£³
ï£¾
3 : TxWrite(ğ‘‘2, 10) ;
( Ë†ğ‘‘2, 10) âˆˆ WSğ‘¡ âˆ§ Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2
ï£±ï£´ï£´ï£´ï£´ï£²
âˆ§Â¬[ Ë†ğ‘‘2 â‰ˆ 10]ğœ2 âˆ§ [ğ‘‘1 = 5]ğœ1
âˆ§Â¬Relğœ1 âˆ§ statusğœ1 = ğ‘…âˆ§
ï£´ï£´ï£´ï£´
Â¬Acqğœ1 âˆ§ |M | = 0
ï£³
4 : TxWrite(ğ‘“ , 1) ;
( Ë†ğ‘“ , 1) âˆˆ WSğœ1 âˆ§ ( Ë†ğ‘‘2, 10) âˆˆ WSğœ1
ï£±ï£´ï£´ï£´ï£´ï£²
âˆ§Â¬[ Ë†ğ‘“ â‰ˆ 1]ğœ2 âˆ§ Â¬[ Ë†ğ‘‘2 â‰ˆ 10]ğœ2
âˆ§[ğ‘‘1 = 5]ğœ1 âˆ§ Â¬Relğœ1âˆ§
ï£´ï£´ï£´ï£´
statusğœ1 = ğ‘… âˆ§ Â¬Acqğœ1 âˆ§ |M | = 0
ï£³
5 : TxEnd ;
(cid:8)true(cid:9)

ï£¼ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´
ï£¾

ï£¼ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´
ï£¾

Thread ğœ2
M [ Ë†ğ‘“ = 0]0 âˆ§ M [ Ë†ğ‘‘2 = 0]0âˆ§
(statusğœ1 = ğ¶ â‡’ M [ Ë†ğ‘“ = 1]1 âˆ§ M [ Ë†ğ‘‘2 = 10]1)âˆ§
(statusğœ1 = ğ¶ â‡’ ([ Ë†ğ‘“ â‰ˆ 0]ğ‘¡ âˆ¨ [ Ë†ğ‘“ â‰ˆ 1]ğ‘¡ ))âˆ§
(statusğœ1 = ğ¶ â‡’ ([ Ë†ğ‘‘2 â‰ˆ 0]ğ‘¡ âˆ¨ [ Ë†ğ‘‘2 â‰ˆ 10]ğ‘¡ ))âˆ§
(âˆ€ğ‘£.ğ‘£ âˆ‰ {0, 5} â‡’ Â¬[ğ‘‘1 â‰ˆğœ2 ğ‘£])âˆ§
(statusğœ1 â‰  ğ¶ â‡’ [ Ë†ğ‘“ = 0]ğ‘¡ âˆ§ [ Ë†ğ‘‘2 = 0]ğ‘¡ )âˆ§
ğ‘Š ğ‘†ğ‘¡ = âˆ…âˆ§
(âˆ€ğ‘–.ğ‘– â‰  0 âˆ§ ğ‘– â‰¤ |M | â‡’ Â¬M [ Ë†ğ‘‘2 = 0]ğ‘– )âˆ§
(âˆ€ğ‘–.ğ‘– â‰  1 âˆ§ ğ‘– â‰¤ |M | â‡’ Â¬M [ Ë†ğ‘“ = 1]ğ‘– )

ï£³
6 : TxBegin(RX, {r1, r2})

M [ Ë†ğ‘“ = 0]0 âˆ§ M [ Ë†ğ‘‘2 = 0]0âˆ§
(statusğœ1 = ğ¶ â‡’ M [ Ë†ğ‘“ = 1]1 âˆ§ M [ Ë†ğ‘‘2 = 10]1)âˆ§
(statusğœ1 = ğ¶ â‡’ ([ Ë†ğ‘“ â‰ˆ 0]ğœ1 âˆ¨ [ Ë†ğ‘“ â‰ˆ 1]ğœ1))âˆ§
(statusğœ1 = ğ¶ â‡’ ([ Ë†ğ‘‘2 â‰ˆ 0]ğœ1 âˆ¨ [ Ë†ğ‘‘2 â‰ˆ 10]ğœ1))âˆ§
(âˆ€ğ‘£.ğ‘£ âˆ‰ 0, 5 â‡’ Â¬[ğ‘‘1 â‰ˆğœ2 ğ‘£])âˆ§
(statusğœ1 â‰  ğ¶ â‡’ [ Ë†ğ‘“ = 0]ğœ1 âˆ§ [ Ë†ğ‘‘2 = 0]ğœ1)âˆ§
ğ‘Š ğ‘†ğœ1 = âˆ…âˆ§
(âˆ€ğ‘–.ğ‘– â‰  0 âˆ§ ğ‘– â‰¤ |ğ‘€ | â‡’ Â¬M [ Ë†ğ‘‘2 = 0]ğ‘– )âˆ§
(âˆ€ğ‘–.ğ‘– â‰  1 âˆ§ ğ‘– â‰¤ |ğ‘€ | â‡’ Â¬M [ Ë†ğ‘“ = 1]ğ‘– ) âˆ§ Â¬ğ´ğ‘ğ‘ğœ1

ï£¾

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´
ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´

ï£¾

ï£³
7 : TxRead(ğ‘“ , ğ‘Ÿ1) ;

M [ Ë†ğ‘“ = 0]0 âˆ§ M [ Ë†ğ‘‘2 = 0]0âˆ§
(ğ‘Ÿ 1 = 1 â‡’ statusğœ1 = ğ¶)âˆ§
(ğ‘Ÿ 1 = 1 â‡’ ( Ë†ğ‘“ , 1) âˆˆ ğ‘…ğ‘†ğœ1)âˆ§
(ğ‘Ÿ 1 = 1 â‡’ M [ Ë†ğ‘“ = 1]1 âˆ§ M [ Ë†ğ‘‘2 = 10]1)âˆ§
(âˆ€ğ‘£.ğ‘£ âˆ‰ 0, 5 â‡’ Â¬[ğ‘‘1 â‰ˆğœ2 ğ‘£])âˆ§
ğ‘Š ğ‘†ğœ1 = âˆ…âˆ§
(âˆ€ğ‘–.ğ‘– â‰  0 âˆ§ ğ‘– â‰¤ |ğ‘€ | â‡’ Â¬M [ Ë†ğ‘‘2 = 0]ğ‘– )âˆ§
(âˆ€ğ‘–.ğ‘– â‰  1 âˆ§ ğ‘– â‰¤ |ğ‘€ | â‡’ Â¬M [ Ë†ğ‘“ = 1]ğ‘– ) âˆ§ Â¬ğ´ğ‘ğ‘ğœ1

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´

ï£¾

ï£³
8 : if ğ‘Ÿ1 = 1 then

ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´
ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´
ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´
ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´

M [ Ë†ğ‘“ = 0]0 âˆ§ M [ Ë†ğ‘‘2 = 0]0
âˆ§M [ Ë†ğ‘“ = 1]1 âˆ§ M [ Ë†ğ‘‘2 = 10]1
âˆ§ğ‘Ÿ 1 = 1 âˆ§ ( Ë†ğ‘“ , 1) âˆˆ ğ‘…ğ‘†ğœ1âˆ§
(âˆ€ğ‘£.ğ‘£ âˆ‰ 0, 5 â‡’ Â¬[ğ‘‘1 â‰ˆğœ2 ğ‘£])âˆ§
ğ‘Š ğ‘†ğœ1 = âˆ…âˆ§
(âˆ€ğ‘–.ğ‘– â‰  0 âˆ§ ğ‘– â‰¤ |ğ‘€ | â‡’ Â¬M [ Ë†ğ‘‘2 = 0]ğ‘– )âˆ§
(âˆ€ğ‘–.ğ‘– â‰  1 âˆ§ ğ‘– â‰¤ |ğ‘€ | â‡’ Â¬M [ Ë†ğ‘“ = 1]ğ‘– ) âˆ§ Â¬ğ´ğ‘ğ‘ğœ1 âˆ§ statusğœ1 = ğ¶

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´

ï£¾

ï£³
TxRead(ğ‘‘2, ğ‘Ÿ2) ;
9 :
(ğ‘Ÿ 1 = 1 â‡’ ğ‘Ÿ 2 = 10)âˆ§
ï£±ï£´ï£´ï£²
(âˆ€ğ‘£.ğ‘£ âˆ‰ 0, 5 â‡’ Â¬[ğ‘‘1 â‰ˆğœ2 ğ‘£])âˆ§
ğ‘Š ğ‘†ğœ1 = âˆ… âˆ§ Â¬ğ´ğ‘ğ‘ğœ1
ï£´ï£´
ï£³
10 : TxEnd ;
(cid:26)(âˆ€ğ‘£.ğ‘£ âˆ‰ 0, 5 â‡’ Â¬[ğ‘‘1 â‰ˆğœ2 ğ‘£])âˆ§
(statusğœ2 = ğ¶ âˆ§ ğ‘Ÿ 1 = 1 â‡’ ğ‘Ÿ 2 = 10)

ï£¼ï£´ï£´ï£½
ï£´ï£´
ï£¾

(cid:27)

11 : ğ‘Ÿ3 â† ğ‘‘1;
(cid:8)(statusğœ2 = ğ¶ âˆ§ ğ‘Ÿ1 = 1 â‡’ ğ‘Ÿ2 = 10 âˆ§ ğ‘Ÿ3 âˆˆ {0, 5})(cid:9)

{statusğœ2 = ğ¶ âˆ§ ğ‘Ÿ1 = 1 â‡’ ğ‘Ÿ2 = 10 âˆ§ ğ‘Ÿ3 âˆˆ {0, 5}}
Fig. 13. Proof outline for relaxed transactions where ğ¶ and ğ‘… are shorthand for COMMITTED and READY,
respectively.

Proc. ACM Program. Lang., Vol. 1, No. OOPSLA, Article 1. Publication date: December 2022.

