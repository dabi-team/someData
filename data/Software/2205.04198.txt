2
2
0
2

l
u
J

1
1

]
E
S
.
s
c
[

2
v
8
9
1
4
0
.
5
0
2
2
:
v
i
X
r
a

Towards Development with Multi-Version
Models: Detecting Merge Conﬂicts and
Checking Well-Formedness(cid:63)

Matthias BarkowskyQ and Holger Giese

Hasso-Plattner Institute at the University of Potsdam
Prof.-Dr.-Helmert-Str. 2-3, D-14482 Potsdam, Germany
{matthias.barkowsky,holger.giese}@hpi.de

Abstract. Developing complex software requires that multiple views
and versions of the software can be developed in parallel and merged
as supported by views and managed by version control systems. In this
context, this paper considers monitoring merging and related consistency
problems permanently at the level of models and abstract syntax to per-
mit early and frequent conﬂict detection while developing in parallel.
The presented approach introduces multi-version models based on typed
graphs that permit to store changes and multiple versions in one graph
in a compact form and allow (1) to study well-formedness for all versions
without the need to extract each version individually, (2) to report all
possible merge conﬂicts without the need to merge all pairs of versions,
and (3) to report all violations of well-formedness conditions that will
result for merges of any two versions independent of any merge decisions
without the need to merge all pairs of versions. The paper deﬁnes the re-
lated concepts and algorithms operating on multi-version models, proves
their correctness w.r.t. the usually employed three-way-merge, and re-
ports on preliminary experiments concerning the scalability.

1

Introduction

Developing complex software nowadays requires that multiple views and versions
of the software can be developed in parallel and merged as supported by views
and managed by version control systems [10]. For complex software, living with
inconsistencies at least temporarily is inevitable, as enforcing consistency may
lead to loss of important information [9] and is hence neither always possible nor
desirable. However, working with multiple versions in parallel and changing each
version on its own for longer periods of time can introduce substantial conﬂicts

(cid:63) This work was developed mainly in the course of the project modular and incremen-
tal Global Model Management (project number 336677879) funded by the DFG.
This preprint has not undergone peer review (when applicable) or any post-
submission improvements or corrections. The Version of Record of this contribution
is published in Graph Transformation, 15th International Conference, Proceedings,
and is available online at https://doi.org/10.1007/978-3-031-09843-7.

 
 
 
 
 
 
2

M. Barkowsky, H. Giese

that are diﬃcult and expensive to resolve. Therefore, it is necessary to manage
consistency when combining views and versions using merge approaches [10,16].

In this context, this paper considers monitoring merging and related consis-
tency problems permanently at the level of models and abstract syntax. This
aims to permit early and frequent conﬂict detection while developing in parallel,
as suggested in approaches to detect conﬂicts early and to enable collaboration
to manage conﬂicts and their risks [5].

The presented approach therefore introduces multi-version models based on
typed graphs, which permit to store changes and multiple versions in one graph
in a compact form and allow to study the diﬀerent versions and their merge com-
binations. The following capabilities are considered: (1) Study well-formedness
for all versions at once without the need to extract and explicitly consider each
version individually. (2) Report all possible merge conﬂicts that may result for
merges of any two versions without the need to extract and explicitly merge all
pairs of versions. (3) Report all violations of well-formedness conditions that will
result for merges of any two versions independent of any merge decisions without
the need to extract and explicitly merge all pairs of versions.

The approach thus promises to support early conﬂict detection and collabo-
ration for managing conﬂicts and their risks, while not having to decide how to
later merge conﬂicting versions. The technique also aims for a better scalability
in case there are many versions that are considered in parallel.

Furthermore, the developed multi-version models permit to study the phe-
nomena of versions, merging, and well-formedness conditions in the unifying
framework of typed graphs. This enables us to (a) formulate algorithms that can
obtain several analysis results without the need to consider a speciﬁc version,
merge of a pair of versions, or strategy for conﬂict resolution and (b) prove that
the algorithms compute the same results as if we would explicitly consider all
speciﬁc versions, merges of pairs of versions, or strategies for conﬂict resolution.

The paper deﬁnes the related concepts and algorithms operating on multi-
version models, proves their correctness w.r.t. the usually employed three-way-
merge, and reports on ﬁrst experiments concerning the scalability. In Section
2, we summarize the preliminaries of the presented approach, including basic
deﬁnitions for typed graphs, well-formedness conditions, and graph modiﬁca-
tions. Then, as a baseline, single-version models in the form of typed graphs
with well-formedness conditions are deﬁned in Section 3, before multi-version
models are introduced in Section 4. Determining all merge conﬂicts and check-
ing well-formedness for all merge results based on multi-version models is then
considered in Section 5. Results of ﬁrst experiments for our prototypical imple-
mentation of the algorithms are presented in Section 6. Finally, the conclusions
of the paper and an outlook of planned future work are presented in Section 7.
For the submitted review version, more detailed proofs and the conditions used
in the evaluation are in addition presented in an appendix.

Title Suppressed Due to Excessive Length

3

2 Preliminaries

We brieﬂy reiterate the basic concepts of graphs, graph modiﬁcations, and well-
formedness conditions used in the remainder of the paper.

A graph G = (V G, EG, sG, tG) consists of a set of nodes V G, a set of edges
EG and two functions sG : EG → V G and tG : EG → V G assigning each edge its
source and target, respectively. We assume that graph elements have identities
and source and target of an edge are invariant if an edge is part of multiple
graphs, that is, for two graphs G and H and an edge e ∈ EG ∩ EH , it holds that
sG(e) = sH (e) and tG(e) = tH (e). This also implies that, in the context of this
paper, (V G = V H ∧ EG = EH ) → (G = H).

A graph morphism m : G → H is given by a pair of functions mV : V G → V H
and mE : EG → EH that map elements from G to elements from H such that
sH ◦ mE = mE ◦ sG and tH ◦ mE = mE ◦ tG [8].

A graph G can be typed over a type graph T G via a typing morphism type :
G → T G, forming the typed graph GT = (G, type G). A typed graph morphism
between two typed graphs GT = (G, type G) and H T = (H, type H ) with the same
type graph then denotes a graph morphism mT : G → H such that type G =
type H ◦ mT . A (typed) graph morphism is a monomorphism iﬀ its functions are
both surjective and injective.

Figure 1 shows an example typed graph M1 and associated type graph T M
from the software development domain. M1 represents an abstract syntax graph
for a program written in an object-oriented language that contains four classes
represented by nodes, with edges representing superclass relationships.

Fig. 1. Example graph, type graph, and violation pattern

The structure of a typed graph G can be restricted by a well-formedness
condition φ, which in the context of this paper is characterized by a typed
graph Q typed over the same type graph. G then satisﬁes the condition φ,
denoted G |= φ, iﬀ there exists no monomorphism m : Q → G. We also call such
monomorphisms matches and Q the violation pattern of φ.

Figure 1 shows a violation pattern Q for an example well-formedness con-

straint that forbids a class having two outgoing superclass relationships.

A graph modiﬁcation as deﬁned by Taentzer et al. [20] formalizes the diﬀer-
ence between two graphs G and H and is characterized by an intermediate graph
K and a span of monomorphisms (G ← K → H). In this paper, we assume that
the two morphisms are always partial identities. The graph K then characterizes

c1:ClassQc2:Classc3:ClassClassTMsuperclassc1:Classc2:Classc3:Classc4:ClassM14

M. Barkowsky, H. Giese

the subgraph that is preserved through the modiﬁcation, whereas all elements
in G that are not in K are deleted and elements in H but not in K are created.
Figure 2 shows an example graph modiﬁcation from the graph M1 from
Figure 1 to a new graph M2, where a superclass edge from class c1 to class c3 is
created and the class c4 is deleted. The morphisms are implied by node labels.

Fig. 2. Example graph modiﬁcation

Graphs and graph modiﬁcations correspond to versions and diﬀerences in
conventional, line-based version control systems like Git [2], where versions of a
development artifact and intermediate diﬀerences form a directed acyclic graph.

3 Single-Version Models

In this paper, we consider models in the form of typed graphs that are required
to adhere to a set of well-formedness conditions. Eﬀectively, the combination
of type graph and well-formedness conditions then acts as a metamodel with
potential further constraints. Note that attributes, as usually employed in real-
world models, can in this context be modeled as dedicated nodes [13].

For Φ the set of well-formedness conditions, a model Mi is well-formed iﬀ
∀φ ∈ Φ : Mi |= φ. We assume pcheck(Mi, φ) to report all violations to property
φ with violation pattern Q for model Mi in the form of matches for Q, essentially
realizing |= as pcheck(Mi, φ) = ∅ ⇐⇒ Mi |= φ. If violations exist, the model
Mi is also called ill-formed.

For the notion of models as typed graphs, model modiﬁcations correspond
to graph modiﬁcations as presented in Section 2. We say a model modiﬁcation
(Mi ← K → Mj) with identity morphisms is maximally preserving iﬀ it does
not delete and recreate identical elements. Formally, K = (V Mi ∩ V Mj , EMi ∩
EMj , sK, tK), where sK and tK are uniquely deﬁned assuming invariant edge
sources and targets. Consequently, for two models Mi and Mj, the maximally
preserving model modiﬁcation (Mi ← K → Mj) is uniquely deﬁned.

For a set of model modiﬁcations ∆M{1,...,n} between models M{1,...,n} =
{M1, . . . , Mn}, with ∀(G ← K → H) ∈ ∆M{1,...,n} : G ∈ M{1,...,n} ∧ H ∈
M{1,...,n}, we can deﬁne the set of predecessors pre(i) ⊂ M{1,...,n} of a version Mi
as the set of versions Mj such that there exists a sequence of model modiﬁcations
(Mx1 ← Kx1 → Mx2), (Mx2 ← Kx2 → Mx3), . . . , (Mxn−1 ← Kxn−1 → Mxn )
where x1 = j, xn = i, and (Mxk ← Kxk → Mxk+1) ∈ ∆M{1,...,n} for 1 ≤ k < n.

c1:Classc2:Classc3:Classc4:ClassM1c1:Classc2:Classc3:ClassKc1:Classc2:Classc3:ClassM2Title Suppressed Due to Excessive Length

5

∆M{1,...,n} describes a correct model versioning if all morphisms in the in-
dividual model modiﬁcations are partial identities, all model modiﬁcations are
maximally preserving, the pre relation is acyclic and there exists a model Mα
such that Mα ∈ pre(i) for all models Mi (cid:54)= Mα. Eﬀectively, a correct model ver-
sioning describes a directed acyclic graph of model versions M{1,...,n} that are
derived from an original model Mα via the model modiﬁcations in ∆M{1,...,n} ,
and therefore closely corresponds to the versioning of some development artifact
in a conventional version control system.

Taentzer et al. [20] deﬁne a merge operation for model modiﬁcations m1 =
(Mc ← Ki → Mi) and m2 = (Mc ← Kj → Mj) with common source Mc, which
uniﬁes m1 and m2 into a merged model modiﬁcation mm = merge(m1, m2) =
(Mc ← Km → Mm). We denote the merged model by Mm = mergeG(m1, m2).
This merge operation is similar to a three-way-merge in conventional version
control systems [16], since mm in the default case (i) preserves an element x ∈ Mc
iﬀ it is preserved by both m1 and m2 (ii) deletes an element x ∈ Mc iﬀ it is deleted
by m1 or m2 (iii) creates an element x ∈ Mm iﬀ it is created by m1 or m2.

However, according to [20], model modiﬁcations can be in conﬂict in two
cases: (i) insert-delete conﬂict and (ii) delete-delete conﬂict. Taentzer et al. state
that only (i), where one modiﬁcation creates an edge connected to a node deleted
by the other modiﬁcation, is an actual conﬂict, which has to be resolved to create
a correct merge result. In this case, the merge result may deviate from the default
case. Such conﬂicts will be reported by mcheck((Mc ← Ki → Mi), (Mc ← Kj →
Mj)) in the form (e, v), where e is an edge created by one of the modiﬁcations
and v is a node deleted by the other modiﬁcation.

For a correct model versioning ∆M{1,...,n} , we say that two sequences of model
modiﬁcations Mc ⇒∗ Mi and Mc ⇒∗ Mj are in conﬂict iﬀ their corresponding
maximally preserving model modiﬁcations (Mc ← Kc,i → Mi) and (Mc ←
Kc,j → Mj) are in conﬂict. In this case, we also say that Mi and Mj are in
conﬂict for the common predecessor Mc.

Insert-delete conﬂicts can be resolved by equipping the merge operation with
a manual or automatic strategy for conﬂict resolution. We consider such a strat-
egy valid if it decides for each conﬂict whether to either revert the edge creation
or the node deletion and always produces a proper merged graph. The approach
in [20] eﬀectively proposes an automatic strategy that favors insertion over dele-
tion in order to preserve as many model elements as possible. Therefore, it reverts
any deletions of nodes that would lead to insert-delete conﬂicts.

In contrast, a strategy for conﬂict resolution may favor deletion over insertion
by reverting any creations of edges that would lead to insert-delete conﬂicts.
Speciﬁcally, for model modiﬁcations m1 = (Mc ← Ki → Mi) and m2 = (Mc ←
Kj → Mj), the model modiﬁcation mmin = mergemin(m1, m2), with mergemin
a merge operation equipped with this strategy, only creates an edge created by
m1 or m2 if neither its source nor target is deleted by the other modiﬁcation.

If all well-formedness conditions are speciﬁed by simple violation patterns,
mmin also yields a model where all well-formedness violations are also present
in the merge result for any other conﬂict resolution strategy:

6

M. Barkowsky, H. Giese

Theorem 1. For two model modiﬁcations m1 = (Mc ← Ki → Mi) and m2 =
(Mc ← Kj → Mj) and a well-formedness constraint φ with violation pattern Q,
it holds that

pcheck(mergemin

G (m1, m2), φ) =

(cid:92)

str ∈S

pcheck(mergestr

G (m1, m2), φ),

with S the set of all valid conﬂict resolution strategies.

Proof. (Sketch) Follows directly from the fact that mergemin
G (m1, m2) is the
smallest common subgraph of all graphs produced by the operation merge for
(cid:117)(cid:116)
any valid conﬂict resolution strategy.

If there are no conﬂicts in the merged model operations, the merge operation
produces the same result regardless of the chosen strategy for conﬂict resolution.
For a correct model versioning, two model versions Mi and Mj, and the set

of versions P = pre(i) ∩ pre(j), we deﬁne the function

preC(i, j) =

(cid:40)
∅
{Mc ∈ P | ∀Mx ∈ P : Mc /∈ pre(x)}

Mi ∈ pre(j) ∨ Mj ∈ pre(i)
otherwise

,

which returns the set of latest common predecessors of Mi and Mj. Note that
our deﬁnition of pre C corresponds to the deﬁnition of a best common ancestor
in conventional version control systems such as Git [2], which is used to compute
the base for three-way merges in these systems.

Figure 3 shows an exemplary model versioning based on the graph M1 from
Figure 1. The initial graph Mα = M1 contains four classes. The modiﬁcation m1
(not to be confused with a morphism) to M2 creates a superclass edge from c1 to
c3 and deletes the node c4. The modiﬁcation m2 to graph M3 creates superclass
edges from c1 to c2 and from c4 to c2. There is an insert-delete conﬂict between
the two modiﬁcations, since the modiﬁcation to M2 deletes a node that is needed
as the source of an edge created by the modiﬁcation to M3. Furthermore, the
result of the merge of the two modiﬁcations would violate the well-formedness
constraint with the violation pattern Q from Figure 1, since without additional
modiﬁcations, the node c1 would have two outgoing superclass edges.

Fig. 3. Example model versioning

c1:Classc2:Classc3:Classc4:ClassM1c1:Classc2:Classc3:Classc4:ClassM3c1:Classc2:Classc3:ClassM2m1m2Title Suppressed Due to Excessive Length

7

4 Multi-Version Models as Typed Graphs

A correct model versioning ∆M{1,...,n} with model versions M{1,...,n} conforming
to a type graph T M can be represented by a multi-version model in the form of
a single graph that is typed over an adapted type graph.

The adapted type graph T Mmv contains a node for each node and edge in
T M . It also contains edges connecting each node in T Mmv that represents an
edge in T M to the nodes representing the edge’s source and target in T M .
This yields a bijective function corr mv : V T M ∪ ET M → V T Mmv , which maps
elements from T M to the corresponding node in T Mmv, and two bijective func-
tions corrs
mv : ET M → ET Mmv mapping edges from T M to the edges
in T Mmv encoding the source and target relation in T M . In addition, T Mmv
contains a node version, an edge suc with source and target version, and two
edges cvv and dvv from each other node v ∈ V T Mmv to the version node.

mv, corrt

A multi-version model MVM for ∆M{1,...,n} is then constructed by an op-
eration comb as follows: A subgraph P M
mv encodes structural information about
all model versions and is constructed by translating P M = (cid:83)
Mi to
conform to T Mmv using an operation transmv. Since source and target functions
are invariant in a correct model versioning, P M is well-deﬁned.

Mi∈M{1,...,n}

For each v ∈ vP M

, transmv creates a node of type corr mv(v) in V P M
mv . For
, a node of type corr mv(e) is created. This yields a bijection origin :

each e ∈ EP M
mv → P M mapping translated elements to their original representation.
P M

, an edge of type corrs

In addition, for each edge e ∈ EP M

mv(e) with source
origin −1(e) and target origin −1(sP M
mv(e) with
source origin −1(e) and target origin −1(tP M
mv . Since edge
sources and targets are invariant, the corresponding node ve = origin −1(e) in
the end has exactly one edge of type corrs
mv(e).
We thus have two functions smv : origin −1(EP M
mv respectively tmv :
origin −1(EP M
mv encoding these mappings.

mv(e) and one of type corrt

(e)) and an edge of type corrt

(e)) are created in EP M

) → EP M

structed as follows: For each Mi ∈ M{1,...,n}, P V
of type version. For each (Mi ← K → Mj) ∈ ∆M{1,...,n} , P V
of type suc from the node representing Mi to the node representing Mj.

mv contains versioning information and is con-
mv contains a corresponding node
mv contains an edge

For each modiﬁcation (Mi ← K → Mj), a cv-edge with the node correspond-
ing to Mj as its target is added to all nodes corresponding to elements created
by the modiﬁcation. A dv-edge with the node corresponding to Mj as its target
is added to all nodes corresponding to elements deleted by the modiﬁcation.
Additionally, a cv edge with the node corresponding to the initial version Mα as
its target is added to all nodes corresponding to elements in Mα.

Since attributes can be encoded by dedicated nodes and assignment edges

[13], the construction can be performed analogously for attributed graphs.

For v ∈ P M

mv and Mi ∈ M{1,...,n}, we say that v is mv-present in Mi, iﬀ for
a node mcv connected to v via a cv edge, there exists a path from mcv to the
node representing Mi via suc edges that does not go through a node connected
to v via a dv edge. We denote the set of versions where v is mv-present by p(v).

) → EP M
Another, distinct subgraph P V

8

M. Barkowsky, H. Giese

A model version Mi can then be derived from MVM via an operation proj as
follows: Collect all nodes Vp = {vp ∈ V P M
mv |Mi ∈ p(vp)}, that is, all nodes that
are mv-present in Mi, and translate the induced subgraph into the single-version
mv(typeM V M (vv)) ∈
model Mi with V Mi = {origin(vv)|vv ∈ V M V M ∧ corr −1
V T M }, EMi = {origin(ve)|ve ∈ V M V M ∧ corr −1
mv(typeM V M (ve)) ∈ ET M },
sMi = origin ◦ tM V M ◦ smv ◦ origin −1, and tMi = origin ◦ tM V M ◦ tmv ◦ origin −1.

Correctness

Theorem 2. For a correct model versioning ∆M{1,...,n} holds concerning comb
and proj:

∀i ∈ {1, . . . , n} : Mi = proj(comb(∆M{1,...,n} ), i).

Proof. (Sketch) Any element in a version Mi has a corresponding node v in
comb(∆M{1,...,n} ). By construction, v is connected to a node corresponding to
some version Mj via a cv edge, for which there exists a path of suc edges to the
node corresponding to Mi. That path does not go through a node connected to v
by a dv edge. v is thus mv-present in Mi and hence contained in the projection.
Inclusion of elements in the opposite direction can be shown analogously.
Because edge sources and targets are invariant over all graphs, the edges in
comb(M1, . . . , Mn) correctly encode the source and target functions by construc-
(cid:117)(cid:116)
tion. Thus, ∀i ∈ {1, . . . , n} : Mi = proj(comb(M1, . . . , Mn), i).

A maximally preserving model modiﬁcation (Mi ← K → Mj) with Mi, Mj ∈
M{1,...,n} (and thus any model modiﬁcation in ∆M{1,...,n} ) can be derived from
MVM via proj∆ as follows: Mi and Mj can be derived via the operation proj.
K is then the graph containing all elements from Mi ∩ Mj, with sK and tK
uniquely deﬁned by the corresponding functions from Mi and Mj and partial
identities as morphisms into Mi and Mj.

Theorem 3. For a correct model versioning ∆M
proj∆, it holds that:

{1,...,n}, concerning comb and

∀Mi, Mj ∈ M{1,...,n} : mi,j = proj∆(comb(∆M{1,...,n} ), i, j),

with mi,j the maximally preserving model modiﬁcation from Mi to Mj.

Proof. Follows trivially from Theorem 2 and the deﬁnition of the maximally
(cid:117)(cid:116)
preserving model modiﬁcation (Mi ← Ki,j → Mj).

Figure 4 visualizes the multi-version model M V M constructed for the ex-
ample versioning in Figure 3 and the associated adapted type graph T Mmv.
M V M contains a node for each node and edge in the models of the example
versioning, one node of type version for each of the graphs M1, M2, and M3,
and appropriate edges as created by comb.

Title Suppressed Due to Excessive Length

9

Fig. 4. Multi-version model and adapted type graph for the versioning in Figure 3

4.1 Directly Checking Well-Formedness for Multi-Version Models

We can use a multi-version model to directly ﬁnd all well-formedness viola-
tions in all individual versions via an operation pcheckmv. For a multi-version
model MVM with a bijective mapping into a union of original model versions
origin M and a well-formedness constraint φ with associated violation pattern Q,
pcheckmv(MVM , φ) works as follows:

First, the graph Q typed over the original type graph is translated into a
corresponding graph Qmv typed over the adapted type graph using transmv.
This yields a bijective mapping originQ : Qmv → Q.

Then, all matches for Qmv in MVM are found. For each such match mmv,
pcheckmv computes all versions for which all vertices in the image of the match
are mv-present by P = (cid:84)
v∈V Qmv p(mmv(v)). If P (cid:54)= ∅, the match into the
original model versions m = originM ◦mmv◦origin −1
Q is constructed and reported
as a violation in all versions in P .

Correctness

Theorem 4. For a well-formedness constraint φ with violation pattern Q, a
correct model versioning ∆M{1,...,n} , and MVM = comb(∆M

{1,...,n}) holds:

pcheckmv(MVM , φ) =

(cid:93)

i∈{1,...,n}

{(i, m)|m ∈ pcheck(proj(MVM , i), φ)}.

Proof. (Sketch) A match m : Q → Mi for any version Mi has one corresponding
match mmv with m = originM ◦ mmv ◦ origin −1
Q , where edges created by transmv
ensure correct connectivity. P = (cid:84)
v∈V Qmv p(mmv(v)) contains exactly the ver-
(cid:117)(cid:116)
sions containing all elements in m(Q). This yields the stated equality.

Complexity The eﬀort for searching all versions M{1,...,n} of some model ver-
sioning ∆M{1,...,n} for a pattern Q using pcheck is in O((cid:80)
C(Mi, Q)),
with C(Mi, Q) the eﬀort for ﬁnding all matches of Q into Mi.

Mi∈M{1,...,n}

mv = transmv(P M ) and Qmv = transmv(Q) are only diﬀerent encodings
P M
of P M = (cid:83)
Mi and Q. Considering computation of the mv-present

Mi∈M{1,...,n}

c1:Classs2:superclasss1:superclassc2:Classc3:Classc4:Classttssm1:versionm2:versionm3:versionsucsucs3:superclasstscv1cv1cv1cv1dv1cv2cv2cv2MVMClasssuperclassstversionsuccv1dv1dv2cv2TMmv10

M. Barkowsky, H. Giese

predicate, the eﬀort for pcheckmv is hence in O(C((cid:83)
Mi, Q) + X ·
|V Qmv | · |∆M1,...,n |), with X the number of matches for Qmv into P M
mv.

Mi∈M{1,...,n}

Discussion If many elements are shared between individual versions and modi-
ﬁcations only perform few changes, the size of the union of all model versions will
be small compared to the sum of the sizes of all individual versions. If pattern
matching is eﬃcient with respect to the size of the considered model, pattern
matching over the union of all model versions will then likely require less eﬀort
than matching over each individual version. If the number of matches for viola-
tion patterns is low, the associated checks performed by pcheckmv will likely be
more eﬃcient than the pattern matching over the individual versions.

Overall, pcheckmv will thus likely be more eﬃcient than using pcheck in
scenarios where pattern matching is eﬃcient, the number of changes between
versions is low, and the number of violations in the union of versions is low.

5 Directly Checking Merge Results for Multi-Version

Models

We can consider multi-version models to directly detect whether (a) merge
conﬂicts exist for any valid pair of encoded model modiﬁcations via an oper-
ation mcheckmv and (b) any resulting merged model is ill-formed via an op-
eration pcheckm
mv, where a pair of model modiﬁcations (Mc ← Ki → Mi) and
(Mc ← Kj → Mj) is valid iﬀ Mc ∈ pre C(Mi, Mj).

5.1 Directly Checking for Merge Conﬂicts

mcheckmv can be realized for a multi-version model MVM = comb(∆M{1,...,n} )
as follows: First, the operation collects all nodes in MVM representing edges
that are created by some model modiﬁcation. This means all nodes ve ∈ V M V M
where corr −1
mv(typeM V M (v)) ∈ ET M connected to a node mx via a cv edge, where
mx does not correspond to Mα and with T M the original type graph. Then, for
each node ve, we compute the set of versions P = p(ve) where it is mv-present.
If P (cid:54)= p(vs), where vs = sMVM (smv(ve)), we then compute a set of versions D
that correspond to nodes reachable via suc edges from a node connected to vs
via a dv edge without going through nodes connected to vs via a cv edge.

Afterwards, for each pair of versions Mi ∈ P and Mj ∈ D, we check for each
latest common predecessor Mc ∈ pre C(i, j) whether Mc ∈ p(vs) ∧ Mc /∈ P . For
any triplet of versions (i, j, c) where this is the case, the edge origin(ve) is then in
an insert-delete conﬂict with its source. To facilitate formalization, this conﬂict is
reported in the normalized form (min(i, j), max(i, j), c, (origin(ve), origin(vs))).
Insert-delete conﬂicts with the edge’s target are computed analogously.

Correctness

Title Suppressed Due to Excessive Length

11

Theorem 5. For a model versioning ∆M{1,...,n} and the associated multi-version
model MVM = comb(∆M

{1,...,n}) holds:

mcheckmv(MVM ) =

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ mcheck(mc,i, mc,j)},

where Y = {(i, j, c) | i, j ∈ {1, . . . , n} : i < j, c ∈ {c|Mc ∈ preC(i, j)}} and with
mc,i = proj∆(MVM , c, i) and mc,j = proj∆(MVM , c, j).

Proof. (Sketch) The collected nodes representing edges correspond to a superset
of edges that may be involved in a conﬂict. The construction of the sets P and
D for a collected node ve ensures that any pair of versions where one may create
e = origin(ve) and the other may delete the source (or target) of e is considered.
The condition checked for each common predecessor of a version pair then yields
exactly the triplets of versions where e is part of an insert-delete conﬂict. Because
of the normalization of the results of mcheckmv, we have the stated equality. (cid:117)(cid:116)

Complexity The function pre C

mv can be precomputed in O(|M{1,...,n}|4).

Since information about creation and deletion of elements is not explicitly
available in a na¨ıve representation, ﬁnding all insert-delete conﬂicts between two
model modiﬁcations via mcheck has to be done by checking for each edge in
either modiﬁcation’s resulting model whether it is created by that modiﬁcation
and its source or target is deleted by the other modiﬁcation. Since there may
exist up to O(|M{1,...,n}|3) possible merges in a model versioning, in the worst
case, this implies eﬀort in O(|M{1,...,n}|4 +|EMmax |·|M{1,...,n}|3), where |EMmax |
is the maximum number of edges present in a single model version.

Created edges can be retrieved eﬃciently from a multi-version model given
appropriate data structures. Computing and checking the required version sets
takes O(|M{1,...,n}|3) steps per edge. Therefore, the overall computational com-
plexity of mcheckmv is in O(|M{1,...,n}|4 + ∆+ · |M{1,...,n}|3), where ∆+ is the
overall number of elements created in the model versioning.

Discussion The eﬃciency of mcheckmv compared to using mcheck mostly de-
pends on the number of edges created by some model modiﬁcation compared to
the number of edges in the individual versions. If most edges are present in the
original model version and are shared between many model versions, mcheckmv
will be more eﬃcient. Otherwise, mcheckmv will not achieve a signiﬁcant im-
provement and might even perform worse than the operation based on mcheck.
Version control systems such as Git typically select a single latest common
predecessor as the base for a three way merge [2]. Using a corresponding partial
1 (i, j) ∈ pre C(i, j) if pre C(i, j) (cid:54)= ∅
function pre C
and pre C
1 (i, j) =⊥ to select a single latest common predecessor of two versions
i and j rather than pre C in mcheckmv, by the same logic as used in the proof
of correctness, we instead have an analogous equality for pre C
1 . Disregarding the
computational eﬀort for precomputing pre C
1 reduces the
remaining computational complexity of mcheckmv to O(∆+ · |M{1,...,n}|2).

1 : N × N → M{1,...,n} with pre C

1 , replacing pre C by pre C

12

M. Barkowsky, H. Giese

5.2 Directly Checking Well-Formedness for Merge Results

To ﬁnd all violations of a well-formedness constraint φ characterized by a pat-
tern Q via pcheckm
mv in merge results of a multi-version model M V M , we ﬁrst
translate Q into Qmv = transmv. We then ﬁnd all matches for Qmv in M V M .
For a match mmv for Qmv, we determine the set of versions Pv = p(v) for each
v ∈ mmv(V Qmv ). For each pair of versions Mi ∈ arg minP ∈{p(v)|v∈mmv(V Qmv } |P |
and Mj ∈ (cid:83)
v∈V Qmv p(v), we check whether ∀v ∈ mmv(V Qmv ) : Mi ∈ p(v)∨Mj ∈
p(v). We then check for each latest common predecessor Mc ∈ pre C(i, j) if for all
v ∈ V Qmv , it holds that v ∈ V Mc → (v ∈ V Mi ∧v ∈ V Mj ), that is, v is not deleted
in Mi or Mj. If this is the case, the match m into (cid:83)
Mx corresponding
to mmv represents a violation in mergemin((Mc ← Ki → Mi), (Mc ← Kj →
Mj)). We report results in the normalized form (min(i, j), max(i, j), c, m).

Mx∈M{1,...,n}

Correctness

Theorem 6. For a well-formedness constraint φ, a correct model versioning
∆M{1,...,n} , and the multi-version model MVM = comb(∆M

{1,...,n}) holds:

pcheckm

mv(MVM , φ) =

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ pcheck(M min

i,j,c , φ)},

where Y = {(i, j, c) | i, j ∈ {1, . . . , n} : i < j, c ∈ {c|Mc ∈ preC(i, j)}} and
M min

G (proj∆(MVM , c, i), proj∆(MVM , c, j)).

i,j,c = mergemin

Proof. (Sketch) For two versions Mi, Mj with latest common predecessor Mc, a
G (proj∆(MVM , c, i), proj∆(MVM , c, j)) has one cor-
match m : Q → mergemin
responding match mmv : transmv(Q) → MVM by construction, where the edges
created by transmv ensure the correct connectivity. The set of version pairs con-
sidered by pcheckm
mv contains all version pairs such that each matched element
is contained in at least one of the versions. The condition checked for every lat-
est common predecessor ensures that only version triplets are reported where the
merge result also contains all matched elements if there are no merge conﬂicts.
Since mergemin resolves conﬂicts by prioritizing deletion and, as ensured by the
check, no matched node is deleted by the merge, conﬂict resolution cannot inval-
(cid:117)(cid:116)
idate the match or create new matches. We thus have the stated equality.

By Theorem 1 and Theorem 6, we also have that pcheckm

mv yields the set of

violations that cannot be avoided by any conﬂict resolution strategy:

Corollary 1. For a well-formedness constraint φ, a correct model versioning
∆M{1,...,n} , and the multi-version model MVM = comb(∆M{1,...,n} ) holds:
(cid:92)

(cid:93)

{(i, j, c, m)|m ∈ mcheck(M str

i,j,c, φ)},

pcheckm

mv(MVM , φ) =

(i,j,c)∈Y

str ∈S

where Y = {(i, j, c) | i, j ∈ {1, . . . , n} : i < j, c ∈ {c|Mc ∈ preC(i, j)}} and
M str
G (proj∆(MVM , c, i), proj∆(MVM , c, j)), and with S the set of
all valid conﬂict resolution strategies.

i,j,c = mergestr

Title Suppressed Due to Excessive Length

13

Complexity The function pre C

mv can be precomputed in O(|M{1,...,n}|4).

With C(Mi, Q) the eﬀort for ﬁnding all matches of Q into Mi, ﬁnding viola-
tions characterized by a pattern Q in all results of a set of possible merges Y using
pcheck takes eﬀort in O(O(|M{1,...,n}|4 +(cid:80)
G (m1, m2), Q)).
The computation and checking of version triplets for a match in pcheckm
mv
takes eﬀort in O(|M{1,...,n}|3). For X matches for Qmv, the eﬀort for pcheckm
mv
is thus in O(|M{1,...,n}|4 + C((cid:83)
Mi, Q) + X · |V Qmv | · |M{1,...,n}|3).

(m1,m2)∈Y C(mergemin

Mi∈M{1,...,n}

Discussion By the same argumentation as for pcheckmv, pcheckm
mv will likely
be more eﬃcient than the corresponding operation using pcheck in scenarios
where pattern matching is eﬃcient, the number of changes between versions is
low, and the number of violations in the union of model versions is low.

Using some partial function pre C

latest common predecessor rather than pre C in pcheckm
in the proof of correctness, we have an analogous equality for pre C
the eﬀort for precomputing pre C
mv to O(C((cid:83)
complexity of pcheckm

1 : N × N → M{1,...,n} to select a single
mv, by the same logic as
1 . Disregarding
1 reduces the remaining
Mi, Q)+X ·|V Qmv |·|M{1,...,n}|2).

1 , replacing pre C by pre C

Mi∈M{1,...,n}

6 Evaluation

For an initial empirical evaluation of the performance and scalability of the pre-
sented operations, we experiment with an application scenario from the software
development domain. Therefore, we extract abstract syntax graphs from a small
previous research project (rete) and a larger open source project (henshin [3])
written in Java using the EMF-based [1] MoDisco tool [6]. We store the extracted
models in a graph format and fold each of the projects into a multi-version model,
using a mapping strategy based on hierarchy and element names.

We then run implementations of the presented operations for conﬂict detec-
tion and well-formedness checking based on multi-version models (MVM) and
baseline implementations using corresponding single-version models (SVM).1
We consider three well-formedness constraints: uniqueness of a class’s superclass,
uniqueness of a method’s return type, and consistency of an overriden method’s
return type. We employ our own EMF-based tool [11] for pattern matching.

Figure 5 shows the measured execution times for the operations pcheckmv,
mcheckmv, and pcheckm
mv and related single-version-model-based operations over
the example models. The execution times for pcheckmv and pcheckm
mv correspond
to the combined pattern matching time for all considered well-formedness con-
straints. All reported times exclude the time for computing any merge results
required by SVM and the time required to precompute the pre C function, since it

1 All experiments were executed on a Linux SMP Debian 4.19.67-2 machine with
Intel Xeon E5-2630 CPU (2.3 GHz clock rate) and 386 GB system memory running
OpenJDK version 1.8.0 242. Reported execution times correspond to the arithmetic
mean of at least ﬁve runs of the respective experiment. Our implementation and
datasets are available under https://github.com/hpi-sam/multi-version-models

14

M. Barkowsky, H. Giese

is required by both the MVM and the SVM implementation. Precomputing pre C
took about 5 ms for the smaller project and about 3.5 s for the larger project.

Fig. 5. Measurement results for pcheckmv, mcheckmv, and pcheckm
mv

For the tasks related to well-formedness checking, the MVM variant performs
better (up to factor 50) than SVM. Since there are only few to no matches for
the violation patterns of the considered constraints, the MVM implementation
only performs few of the potentially expensive checks over the version graph,
while avoiding most of the redundancy in the pattern matching of SVM.

For conﬂict detection, MVM performs better than SVM for the smaller
project (factor 5), but has a substantially higher execution time for the larger
project (factor 10). The reason for the bad performance is that most edges are
not present in the initial model version. In fact, the number of edges created
throughout the model versioning is much higher than the number of edges in
any individual version. Furthermore, in contrast to the solution using mcheck,
the operation mcheckmv considers versions where the source or target of an edge
is not present. Due to the high number of versions in the project and because
many elements are only present in few versions, this leads to the processing of
large version sets, which deteriorates the performance of MVM in this scenario.

Threats to Validity Unexpected JVM behavior poses a threat to internal va-
lidity, which we tried to mitigate by performing multiple runs of each experiment
and proﬁling time spent on garbage collection. To address threats to external
validity, we used real-world data and well-formedness constraints in our experi-
ments. While we used our own tool for pattern matching, said tool has already
been used in our previous works and has shown adequate performance [11].

However, the example constraints are not representative and the folding of
individual model versions extracted from source code may yield a larger-than-
necessary multi-version model. Our results are thus not necessarily generalizable,
but instead constitute an early conceptual evaluation of the presented approach.

7 Related Work

While most practical version control systems operate on text documents [16],
versioning and merging of models has also been subject to extensive research.

MVMSVM216188758435105000retehenshintime (ms)pcheckmv7063411463755342830500000retehenshintime (ms)mcheckmv21219413599602020000retehenshintime (ms)pcheckmmvTitle Suppressed Due to Excessive Length

15

There already exist several formal and semi-formal approaches to model
merging, which compute the result of a three-way-merge of model modiﬁca-
tions [20,21]. Notably, the approach by Taentzer et al. [20] represents a formally
deﬁned solution that works on the level of graphs, which is why for our ap-
proach, we build on their notion of model merging. In their work, Taentzer et al.
also consider checking of well-formedness constraints by constructing a tentative
merge result over which the check is executed. While this allows their approach
to handle arbitrary constraints rather than just simple graph patterns, the check
has to be executed for each individual merge.

Some approaches consider detection of merge conﬂicts [15] or model incon-
sistencies [4] based on the analysis of sequences of primitive changes. However,
these approaches do not consider the case of multiple versions and pairwise
merges and naturally do not employ a graph-based deﬁnition of inconsistencies.
For the more general problem of model versioning, both formal solutions
[7, 18] and tool implementations [14, 17] have been introduced. Similar to our
approach, some of these techniques are based on a joint representation of multiple
model versions [17, 18]. However, to the best of our knowledge, joint conﬂict
detection or well-formedness checking for all merges at once is not considered.

Westfechtel and Greiner [22] present a solution to conﬁguration management
for product lines, where several conﬁgurations are represented in a uniﬁed feature
model. Information about the presence of elements in certain conﬁgurations is
encoded in logic formulas and propagated along model transformations. While
this approach bears some similarity to the encoding of diﬀerent versions and
collective well-formedness checking in our solution, the technique in [22] focuses
on the deﬁnition of product lines and hence does not consider merging.

Folding and joint querying of the temporal evolution of graphs has been
studied in previous work of our group [12,19]. However, the aim of these solutions
is the development of a temporal logic for graphs. The presented concepts are
hence speciﬁc to sequences of graph modiﬁcations and do not consider merging.

8 Conclusion

In this paper, we have presented an approach for encoding a model versioning as a
single typed graph. Based on this representation, we have introduced operations
for ﬁnding merge conﬂicts and violations of well-formedness conditions in the
form of graph patterns in the entire versioning and related merge results. We have
conducted an initial empirical evaluation, which demonstrates potential beneﬁts
of the approach, but also highlights shortcomings in unfavorable scenarios.

In future work, we plan to address these shortcomings by studying how to
compress the version graph or restrict the set of considered versions to those most
relevant to users. We want to investigate how to lift our notion of well-formedness
constraints to more expressive formalisms such as nested graph conditions and
develop an incremental version of the approach. Finally, we will extend our
empirical evaluation to better characterize our technique’s performance.

16

M. Barkowsky, H. Giese

References

1. EMF. https://www.eclipse.org/modeling/emf/, last accessed 23 February 2022
2. Git. https://git-scm.com/, last accessed 23 February 2022
3. Arendt, T., Biermann, E., Jurack, S., Krause, C., Taentzer, G.: Henshin: advanced
concepts and tools for in-place EMF model transformations. In: International Con-
ference on Model Driven Engineering Languages and Systems. Springer (2010)
4. Blanc, X., Mougenot, A., Mounier, I., Mens, T.: Incremental detection of model in-
consistencies based on model operations. In: International Conference on Advanced
Information Systems Engineering. pp. 32–46. Springer (2009)

5. Brun, Y., Holmes, R., Ernst, M.D., Notkin, D.: Early Detection of Collaboration

Conﬂicts and Risks. IEEE Transactions on Software Engineering 39(10)

6. Bruneliere, H., Cabot, J., Jouault, F., Madiot, F.: MoDisco: a generic and ex-
tensible framework for model driven reverse engineering. In: Proceedings of the
IEEE/ACM international conference on Automated software engineering

7. Diskin, Z., Czarnecki, K., Antkiewicz, M.: Model-versioning-in-the-large: Algebraic
foundations and the tile notation. In: 2009 ICSE Workshop on Comparison and
Versioning of Software Models. pp. 7–12. IEEE (2009)

8. Ehrig, H., Ehrig, K., Prange, U., Taentzer, G.: Fundamentals of algebraic graph

transformation. Springer (2006)

9. Finkelstein, A.C.W., Gabbay, D., Hunter, A., Kramer, J., Nuseibeh, B.: Inconsis-
tency Handling in Multiperspective Speciﬁcations. IEEE Transactions on Software
Engineering 20(8), 569–578 (August 1994)

10. Fr¨uhauf, K., Zeller, A.: Software conﬁguration management: State of the art, state
of the practice. In: International Symposium on Software Conﬁguration Manage-
ment. pp. 217–227. Springer (1999)

11. Giese, H., Hildebrandt, S., Seibel, A.: Improved ﬂexibility and scalability by inter-
preting story diagrams. Electronic Communications of the EASST 18 (2009)
12. Giese, H., Maximova, M., Sakizloglou, L., Schneider, S.: Metric temporal graph
logic over typed attributed graphs. In: International Conference on Fundamental
Approaches to Software Engineering. pp. 282–298. Springer, Cham (2019)

13. Heckel, R., K¨uster, J.M., Taentzer, G.: Conﬂuence of Typed Attributed Graph

Transformation Systems. In: Graph Transformation (2002)

14. Koegel, M., Helming, J.: Emfstore: a model repository for emf models. In: Proceed-
ings of the 32nd ACM/IEEE International Conference on Software Engineering-
Volume 2. pp. 307–308 (2010)

15. K¨uster, J.M., Gerth, C., Engels, G.: Dependent and conﬂicting change opera-
tions of process models. In: European Conference on Model Driven Architecture-
Foundations and Applications. pp. 158–173. Springer (2009)

16. Mens, T.: A State-of-the-Art Survey on Software Merging. IEEE Trans. Softw.

Eng. 28(5), 449–462 (2002)

17. Murta, L., Corrˆea, C., Prudˆencio, J.G., Werner, C.: Towards odyssey-vcs 2: Im-
provements over a uml-based version control system. In: Proceedings of the 2008
international workshop on Comparison and versioning of software models (2008)

18. Rutle, A., Rossini, A., Lamo, Y., Wolter, U.: A category-theoretical approach to
the formalisation of version control in MDE. In: International Conference on Fun-
damental Approaches to Software Engineering. pp. 64–78. Springer (2009)

19. Sakizloglou, L., Ghahremani, S., Barkowsky, M., Giese, H.: Incremental execution
of temporal graph queries over runtime models with history and its applications.
Software and Systems Modeling pp. 1–41 (2021)

Title Suppressed Due to Excessive Length

17

20. Taentzer, G., Ermel, C., Langer, P., Wimmer, M.: A fundamental approach to
model versioning based on graph modiﬁcations: from theory to implementation.
Software & Systems Modeling 13(1), 239–272 (2014)

21. Westfechtel, B.: A formal approach to three-way merging of emf models. In: Pro-
ceedings of the 1st International Workshop on Model Comparison in Practice
22. Westfechtel, B., Greiner, S.: Extending single-to multi-variant model transforma-
tions by trace-based propagation of variability annotations. Software and Systems
Modeling 19(4), 853–888 (2020)

18

M. Barkowsky, H. Giese

A Technical Details

Theorem 7. For a correct model versioning ∆M{1,...,n} holds concerning comb
and proj:

∀i ∈ {1, . . . , n} : Mi = proj(comb(∆M{1,...,n} ), i).
Proof. For any version Mi and any element x ∈ Mi, there is a version Mj, such
that x ∈ Mj with Mj = Mα or ∃(Mx ← K → Mj) ∈ ∆M{1,...,n} : x /∈ Mx ∧ x ∈
Mj, that is, (Mx ← K → Mj) creates x, and there exists a (potentially empty)
sequence of model modiﬁcations Mj ⇒∗ Mi that does not delete x again.

Thus, by the construction of comb, there exists an element xmv ∈ MVM ,
where MVM = comb(M1, . . . , Mn), which is connected to the node mj ∈ M V M
that corresponds to Mj via a cv edge.

Because there exists a sequence of model modiﬁcations Mj ⇒∗ Mi where x is
not deleted, there exists a path of suc edges from mj to the node representing Mi
that does not go through any node connected to xmv via a dv edge. Therefore,
xmv is mv-present in Mi for MVM . Hence, x ∈ proj(comb(M1, . . . , Mn), i).

Since all implications used for deductions are equivalences, we have that x ∈
proj(comb(M1, . . . , Mn), i) ⇔ x ∈ Mi for any element x and model version Mi
and therefore the equality of vertex and edge sets of Mi and the projection.

Because edge sources and targets are invariant over multiple graphs, the edges
in comb(M1, . . . , Mn) correctly encode the source and target functions by con-
(cid:117)(cid:116)
struction. Thus, ∀i ∈ {1, . . . , n} : Mi = proj(comb(M1, . . . , Mn), i).

Theorem 8. For a well-formedness constraint φ, a correct model versioning
∆M{1,...,n} , and associated multi-version model MVM = comb(∆M
{1,...,n}) holds:

pcheckmv(MVM , φ) =

(cid:93)

i∈{1,...,n}

{(i, m)|m ∈ pcheck(proj(MVM , i), φ)}.

Proof. For a tuple (i, m) with match m : Q → (cid:83)
Mi to be re-
ported in the result of pcheckmv(M{1,...,n}, φ), there has to exist a match mmv :
m(mmv) and
Qmv → MVM , where Qmv = transmv(Q), such that m = transmv
(cid:84)

Mi∈M{1,...,n}

v∈V Qmv p(mmv(v)) (cid:54)= ∅.

There hence exists some version Mi ∈ M{1,...,n} such that ∀v ∈ V Qmv : Mi ∈

p(mmv(v)). Therefore, ∀v ∈ V Qmv : originM (mmv(v)) ∈ proj(M{1,...,n}, i).

Then, m is a valid monomorphism into Mi = proj(M{1,...,n}, i), since (i)
all required elements are present and (ii) by construction of MVM , Qmv, the
edges in Qmv ensure that ∀e ∈ EQ : sMi(m(e)) = m(sQ(e)) ∧ tMi (m(e)) =
m(tQ(e)), and the origin function is bijective. Therefore, it holds that (i, m) ∈
(cid:85)

i∈{1,...,n} pcheck(proj(M{1,...,n}, i), φ).

Thus, we have:

pcheckmv(MVM , φ) ⊆

(cid:93)

i∈{1,...,n}

{(i, m)|m ∈ pcheck(proj(MVM , i), φ)}

Any match m : Q → Mi, where Mi = proj(M{1,...,n}, i) is also structurally
Mi. Since transmv creates isomorphic graphs for Q

present in (cid:85)

Mi∈M{1,...,n}

Title Suppressed Due to Excessive Length

19

and the image of Q under m, there exists a match mmv = transmv
Qmv = transmv(Q) into MVM .

m(mmv) for

For m to be reported by pcheck(proj(M{1,...,n}, i), φ), all elements in the im-
age of m have to be present in Mi. Hence, by the semantics of proj, we have that
∀x ∈ Q : Mi ∈ p(origin −1
M (m(x))) and hence, ∀v ∈ V Qmv : Mi ∈ p(mmv(v)).
Therefore, (cid:84)

v∈V Qmv p(mmv(v)) (cid:54)= ∅, so (i, m) ∈ pcheckmv(M{1,...,n}, φ).

Thus, we have:

pcheckmv(MVM , φ) ⊇

(cid:93)

i∈{1,...,n}

{(i, m)|m ∈ pcheck(proj(MVM , i), φ)}

From the two subset-relations follows the equality.

(cid:117)(cid:116)

Theorem 9. For a model versioning ∆M{1,...,n} and the associated multi-version
model MVM = comb(∆M

{1,...,n}) holds:

mcheckmv(MVM ) =

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ mcheck(mc,i, mc,j)},

where Y = {(i, j, c) | i, j ∈ {1, . . . , n} : i < j, c ∈ {c|Mc ∈ preC(i, j)}} and with
mc,i = proj∆(MVM , c, i) and mc,j = proj∆(MVM , c, j).

Proof. For e an edge and its invariant source s reported for versions Mi and Mj
and common predecessor Mc ∈ pre C(i, j) by mcheckmv, by the normalization
and the fact that pre C (cid:54)= ∅ → i (cid:54)= j, we have that i < j. Because Mc /∈ p(ve), we
also have that e /∈ EMc. Furthermore, we either have that Mi ∈ p(origin −1(e))
and therefore e ∈ EMi by Theorem 2 (case 1) or Mj ∈ p(origin −1(e)) and
therefore e ∈ EMj (case 2). Since, Mc ∈ pre(Mi), we therefore have a sequence
of model modiﬁcations Mc ⇒∗ Mi (case 1) or Mc ⇒∗ Mj (case 2) that creates
e.

We also know that, in case 1, the node in the multi-version model correspond-
ing to Mj lies on a path corresponding to a sequence of model modiﬁcations that
deletes but does not recreate s. Hence, Mj /∈ p(origin −1(s)), since Mj being in
p(origin −1(s)) would contradict the consistency of the model versioning. Further-
more, we know that Mc ∈ p(origin −1(s)). This means there exists a sequence of
model modiﬁcations Mc ⇒∗ Mj that deletes s, but not e, since e /∈ EMc. In case
2, by the same logic, there exists a sequence of model modiﬁcations Mc ⇒∗ Mi
that deletes s but not e. Thus, there is an insert-delete conﬂict between e and s
for Mi and Mj in either case.

The same is true for the target of an edge.
Thus, we have:

mcheckmv(MVM ) ⊆

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ mcheck(mc,i, mc,j)},

If there exists an insert-delete conﬂict for an edge e and its source s between
two versions Mi = proj(M{1,...,n}, i) and Mj = proj(M{1,...,n}, j) for a common

20

M. Barkowsky, H. Giese

predecessor Mc ∈ pre C(i, j), this means that there exist a sequence of model
modiﬁcations Si = Mc ⇒∗ Mi and at least one sequence Sj = Mc ⇒∗ Mj, where
one sequence deletes s and does not delete e and the other sequence creates e.
Therefore, s ∈ V Mc and e /∈ EMc .

In the case where Si is the sequence that creates e, it follows that e ∈ EMi.
By Theoreme 2, it then follows that Mi ∈ p(ve) and Mc /∈ p(ve), with ve =
origin −1(e). Because Sj then deletes and does not recreate s, it follows that there
exists a path from a node connected to vs via a dv edge to the node corresponding
to Mj that does not go through a node connected to vs via a cv edge, with vs =
origin −1(s).

By the same logic, we can derive mirrored statements for the case where Sj

is the sequence that creates e.

From the existence of a sequence of model modiﬁcations that creates e, it
also follows that ve is connected to some node mx via a cv edge that does not
correspond to Mα. From the fact that one sequence deletes e but not s, it follows
that p(ve) (cid:54)= p(vs).

Thus, e and v would be reported as an insert-delete conﬂict for versions Mi

and Mj with predecessor Mc in its normalized format by mcheckmv.

The same is true for the target of an edge.
Thus, we have:

mcheckmv(MVM ) ⊇

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ mcheck(mc,i, mc,j)},

By the two inclusions, we also have the equality.

(cid:117)(cid:116)

Theorem 10. For a well-formedness constraint φ, a correct model version-
ing ∆M{1,...,n} and the associated multi-version model MVM = comb(∆M
{1,...,n})
holds:

pcheckm

mv(MVM , φ) =

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ pcheck(M min

i,j,c , φ)},

where Y = {(i, j, c) | i, j ∈ {1, . . . , n} : i < j, c ∈ {c|Mc ∈ preC(i, j)}} and
M min

G (proj∆(MVM , c, i), proj∆(MVM , c, j)).

i,j,c = mergemin

Mi∈M{1,...,n}

Proof. For a match m for Q into (cid:83)
Mi to be reported as a viola-
tion in the merge of versions Mi and Mj with latest common predecessor Mc by
pcheckm
mv, there has to exist a corresponding match mmv : transmv(Q) → MVM .
We know that, because Mc ∈ pre C(Mi, Mj), there are sequences of model modiﬁ-
cations Si = Mc ⇒∗ Mi and Sj = Mc ⇒∗ Mj. Furthermore mmv, we know that
∀v ∈ mmv(Qmv) : Mi ∈ p(v) ∨ Mj ∈ p(v) and ∀v ∈ mmv(Qmv) : Mc ∈ p(v) →
(Mi ∈ p(v) ∧ Mj ∈ p(v)).

Hence, every element x ∈ m(Q) is either present in Mc or created by Si or
Sj, and none of these elements are deleted by either modiﬁcation sequence. The
resolution of merge conﬂicts by mergemin may delete an edge created by one
modiﬁcation sequence, if its source or target is deleted by the other modiﬁcation

Title Suppressed Due to Excessive Length

21

sequence. However, since Q is a proper graph, meaning that for any edge e ∈
EQ : sQ(e) ∈ V Q ∧ tQ(e) ∈ V Q, and no node v ∈ m(V Q) is deleted by either
modiﬁcation sequence, it follows that no edge e ∈ m(EQ) can be deleted in the
process of resolving merge conﬂicts.

Hence, all elements x ∈ m(Q) are present in mergemin

G (Si, Sj). By the con-
struction of M V M , we also know that source and target functions of edges are
preserved by transm
mv(mmv). This makes m a violation of φ in the merge. There-
fore, (i, j, c, m) ∈ pcheck(mergemin

G (proj(M{1,...,n}, i), proj(M{1,...,n}, j)), φ).

Since we know that i < j, we have:

pcheckm

mv(MVM , φ) ⊆

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ pcheck(M min

i,j,c , φ)},

Mi∈M{1,...,n}

For two versions Mi and Mj with common predecessor Mc = pre C(Mi, Mj),
G (proj(M{1,...,n}, i), proj(M{1,...,n}, j)), φ) is also
Mi. There hence exists a corresponding match

a match m ∈ pcheck(mergemin
a valid match into (cid:83)
mmv : Qmv → MVM with m = transm

mv(mmv).
Furthermore, in order to be present in the merge result, each element in the
image of m needs to be contained in Mi or Mj and, therefore, ∀x ∈ m(φ) : x ∈
Mi ∪ Mj. We also know that none of the elements are deleted by the modiﬁca-
tion sequence Mc ⇒∗ Mi or Mc ⇒∗ Mi, which means that ∀x ∈ m(Q) : x ∈
Mc → (x ∈ Mi ∧ x ∈ Mj). We thus also have that ∀v ∈ mmv(V Qmv ) : Mi ∈
p(v) ∨ Mj ∈ p(v) and ∀v ∈ mmv(V Qmv ) : Mc ∈ p(v) → (Mi ∈ p(v) ∧ Mj ∈ p(v)).
Thereby, it must also hold that Mi ∈ arg minP ∈{p(v)|v∈mmv(V Qmv } |P | ∨ Mj ∈
arg minP ∈{p(v)|v∈mmv(V Qmv } |P |. Because i < j, it follows that (i, j, c, m) ∈
pcheckm

mv(M{1,...,n}, φ).

Thus, we have:

pcheckm

mv(MVM , φ) ⊇

(cid:93)

(i,j,c)∈Y

{(i, j, c, m)|m ∈ pcheck(M min

i,j,c , φ)},

By the two inclusions, we also have the equality.

(cid:117)(cid:116)

mv = transmv(P M ) and
Complexity of pcheckmv Eﬀectively, the graphs P M
Qmv = transmv(Q) are only a diﬀerent encoding of P M = (cid:83)
Mi
and Q, where edges are replaced by nodes with a single incoming and outgoing
edge. Since these newly introduced nodes only cause a constant-factor overhead
in pattern matching using an appropriate matching strategy and the size of the
two graphs increases only by a constant factor, the eﬀort for ﬁnding all matches
for Qmv into P M

mv is in O(C((cid:83)

Mi∈M{1,...,n}

Mi, Q)).

Mi∈M{1,...,n}

The set p(vx) for each individual element x with vx = origin −1(x) can be
computed via breadth-ﬁrst searches starting in each node connected to vx via a
cv edge over P V
mv and stopping at nodes that are either connected to vx via a dv
edge or that have already been visited by a previous search. Since this ensures
that the breadth-ﬁrst searches do not perform redundant searches, the combined

22

M. Barkowsky, H. Giese

eﬀort is in O(|∆M1,...,n |). Given appropriate data structures, the eﬀort for a
single intersection of two version sets is in O(|M{1,...,n}|). Hence, computing P =
(cid:84)
v∈V Qmv p(mmv(v)) for a single match mmv takes eﬀort in O(|V Qmv |·|∆M1,...,n |).
For a number of matches X for Qmv into P M
mv, the eﬀort for pcheckmv is then

in O(C((cid:83)

Mi∈M{1,...,n}

Mi, Q) + X · |V Qmv | · |∆M1,...,n |).

Complexity of mcheckmv We can precompute the latest common predeces-
sors for any pair of versions Mi and Mj according to the deﬁnition in O(|P V
mv ·
|M{1,...,n}| + |M{1,...,n}|4) via breadth-ﬁrst search for ﬁnding all predecessors for
every version and basic set operations. Since the maximally preserving model
modiﬁcation between two versions along identity morphisms is uniquely deﬁned
and therefore |EP V
mv | ≤ |M{1,...,n}|2, the complexity is in O(|M{1,...,n}|4). This
computation allows an eﬃcient enumeration of the set of model modiﬁcation
pairs representing possible merges.

Since information about creation and deletion of elements is not explicitly
available in a model-modiﬁcation-based representation of a versioning, ﬁnding
all insert-delete conﬂicts between two model modiﬁcations via mcheck can be
done by checking for each edge in either modiﬁcation’s resulting model whether
it is created by that modiﬁcation and its source or target is deleted by the other
modiﬁcation. Given appropriate data structures for storing the individual model
versions, the check for one edge can be performed in constant time thanks to the
requirement of partial identity morphisms. This yields a computational com-
plexity in O(|M{1,...,n}|4 + (cid:80)
((Mc←Ki→Mi),(Mc←Kj→Mj ))∈Y |EMi| + |EMj |) for
checking an entire model versioning with Y the set of possible merges repre-
sented by pairs of model modiﬁcations. Note that, in the worst case, there may
exist up to O(|M{1,...,n}|3) possible merges in a model versioning, so in the worst
case, this implies eﬀort in O(|M{1,...,n}|4 +|EMmax |·|M{1,...,n}|3), where |EMmax |
is the maximum number of edges present in a single model version.

The computation of P = p(ve) and D for every node ve ∈ V M V M , where
mv(typeM V M (ve)) ∈ ET M and ve has a cv edge to a node representing
corr −1
another version than Mα, and the edge source vs = sM (origin(ve)) can be
performed in O(∆+ · |P V
mv is the version graph and ∆+ is the
overall number of elements created by the model versioning. Checking whether
p(ve) = p(vs) only takes eﬀort in O(|M{1,...,n}|).

mv|), where P V

For a node ve and versions Mi ∈ P and Mj ∈ D, we can then determine all
latest predecessors for which Mi and Mj are in conﬂict in O(|M{1,...,n}|). Since
there are at most |M{1,...,n}|2 pairs of versions in P ×D, the overall complexity of
mcheckmv considering the eﬀort for precomputing latest common predecessors
is in O(|M{1,...,n}|4 + ∆+ · |M{1,...,n}|3), which simpliﬁes to O(|∆+ · |M{1,...,n}|3)
if |M{1,...,n}| ≤ ∆+. The computation for edge targets works analogously and
thus does not change the complexity.

Complexity of pcheckm
mv We denote the eﬀort for ﬁnding all matches for
a pattern Q in a model Mm by C(Mm, Q). A possible merge in a model ver-
sioning is characterized by two model modiﬁcations, that is, two model ver-

Title Suppressed Due to Excessive Length

23

(m1,m2)∈Y C(mergemin

sions Mi and Mj and a latest common predecessor Mc. Disregarding the ef-
fort for computing a merge itself, the eﬀort for ﬁnding all violations of a well-
formedness condition characterized by Q in a model versioning with Y the set of
possible merges via computing all merges and searching for Q in the results
is then given by O((cid:80)
G (m1, m2), Q)). Potentially, there
are up to O(|M{1,...,n}|3) possible merges in a model versioning with versions
M{1,...,n}, which can be computed in O(|M{1,...,n}|4). This results in a complex-
ity for computing and checking all these merges via pcheck in O(|M{1,...,n}|4 +
(cid:80)

(m1,m2)∈Y C(mergemin
Finding all violations characterized by a pattern Q in a model versioning by
pcheckm
mv requires a search for Qmv over the corresponding multi-version model.
As discussed in Section 4.1, this requires eﬀort in O(C((cid:83)
Mi, Q)).
Then, for each structural match that is found, the set Pv = p(v) has to be
computed for each v ∈ V Qmv , which takes O(|V Qmv | · |P V
mv|) computational
steps. Finding all complementary versions Mj regarding Qmv for a version Mi
requires O(|V Qmv | · |M{1,...,n}|) steps.

G (m1, m2), Q)).

Mi∈M{1,...,n}

The number of candidates of complementary versions is in O(|M{1,...,n}|2).
Latest common predecessors for all version pairs can be computed and cached
upfront in O(|M{1,...,n}|4). For each latest common predecessor, the remaining
checks can be performed in O(|V Qmv |) given appropriate data structures. Since
any pair of versions has at most |M{1,...,n}| common predecessors, we thus have
eﬀort in O(|V Qmv | · |M{1,...,n}|3) for each match.

For X matches for Qmv into MVM , the overall computational eﬀort is thus

in O(|M{1,...,n}|4 + C((cid:83)

Mi∈M{1,...,n}

Mi, Q) + X · |V Qmv | · |M{1,...,n}|3).

24

M. Barkowsky, H. Giese

B Violation Patterns of Considered Well-Formedness

Constraints

Fig. 6. Violation pattern for the constraint “unique superclass”

Fig. 7. Violation pattern for the constraint “unique return type”

Title Suppressed Due to Excessive Length

25

Fig. 8. Violation pattern for the constraint “consistent override”

