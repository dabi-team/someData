2
2
0
2

g
u
A
4

]

R
C
.
s
c
[

1
v
2
7
6
2
0
.
8
0
2
2
:
v
i
X
r
a

Information Flow Control-by-Construction for
an Object-Oriented Language Using Type
Modiﬁers

Tobias Runge1,2 [0000-0002-9154-7743], Alexander Kittelmann1,2 [0000-0002-8804-7051],
Marco Servetto3, Alex Potanin4 [0000-0002-4242-2725], and Ina Schaefer1,2

1 TU Braunschweig, Braunschweig, Germany
2 Karlsruhe Institute of Technology, Karlsruhe, Germany
3 Victoria University of Wellington, Wellington, New Zealand
4 Australian National University, Canberra, Australia
{tobias.runge,alexander.kittelmann,ina.schaefer}@kit.edu,
marco@ecs.vuw.ac.nz, alex.potanin@anu.edu.au

Abstract. In security-critical software applications, conﬁdential infor-
mation must be prevented from leaking to unauthorized sinks. Static
analysis techniques are widespread to enforce a secure information ﬂow
by checking a program after construction. A drawback of these systems
is that incomplete programs during construction cannot be checked prop-
erly. The user is not guided to a secure program by most systems. We
introduce IFbCOO, an approach that guides users incrementally to a
secure implementation by using reﬁnement rules. In each reﬁnement step,
conﬁdentiality or integrity (or both) is guaranteed alongside the functional
correctness of the program, such that insecure programs are declined by
construction. In this work, we formalize IFbCOO and prove soundness
of the reﬁnement rules. We implement IFbCOO in the tool CorC and
conduct a feasibility study by successfully implementing case studies.

Keywords: correctness-by-construction, information ﬂow control, security-by-
design

1

Introduction

For security-critical software, it is important to ensure conﬁdentiality and integrity
of data, otherwise attackers could gain access to this secure data. For example, in
a distributed system, one client A has a lower privilege (i.e., a lower security level)
than another client B. When both clients send information to each other, security
policies can be violated. If A reads secret data from B, conﬁdentiality is violated. If
B reads untrusted data from A, the integrity of B’s data is no longer guaranteed. To
ensure security in software, mostly static analysis techniques are used, which check
the software after development [27]. A violation of security is only revealed after
the program is fully developed. If violations occur, an extensive and repetitive
repairing process of writing code and checking the security properties with the

 
 
 
 
 
 
2

Tobias Runge et al.

analysis technique is needed. An alternative is to check the security with language-
based techniques such as type systems [27] during the development. In such a
secure type system, every expression is assigned to a type, and a set of typing
rules checks that the security policy is not violated [27]. If violations occur, an
extensive process of debugging is required until the code is type-checked.

To counter these shortcomings, we propose a constructive approach to directly
develop functionally correct programs that are secure by design without the need
of a post-hoc analysis. Inspired by the correctness-by-construction (CbC) approach
for functional correctness [18], we start with a security speciﬁcation and reﬁne
a high-level abstraction of the program stepwise to a concrete implementation
using a set of reﬁnement rules. Guided by the security speciﬁcation deﬁning the
allowed security policies on the used data, the programmer is directly informed
if a reﬁnement is not applicable because of a prohibited information ﬂow. With
IFbCOO (Information Flow control by Construction for an Object-Oriented
language), programmers get a local warning as soon as a reﬁnement is not secure,
which can reduce debugging eﬀort. With IFbCOO, functionally correct and secure
programs can be developed because both, the CbC reﬁnement rules for functional
correctness and the proposed reﬁnement rules for information ﬂow security, can
be applied simultaneously.

In this paper, we introduce IFbCOO which supports information ﬂow control
for an object-oriented language with type modiﬁers for mutability and alias
control [13]. IFbCOO is based on IFbC [24] proposed by some of the authors
in previous work, but lifts its programming paradigm from a simple impera-
tive language to an object-oriented language. IFbC introduced a sound set of
reﬁnement rules to create imperative programs following an information ﬂow
policy, but the language itself is limited to a simple while-language. In contrast,
IFbCOO is based on the secure object-oriented language SIFO [26]. SIFO’s type
system uses immutability and uniqueness properties to facilitate information ﬂow
reasoning. In this work, we translate SIFO’s typing rules to reﬁnement rules as
required by our correctness-by-construction approach. This has the consequence
that programs written in SIFO and programs constructed using IFbCOO are
interchangeable. In summary, our contributions are the following. We formalize
IFbCOO and establish 13 reﬁnement rules. We prove soundness that programs
constructed with IFbCOO are secure. Furthermore, we implement IFbCOO in
the tool CorC and conduct a feasibility study.

2 Object-Oriented Language SIFO by Example

SIFO [26] is an object-oriented language that ensures secure information ﬂow
through a type system with precise uniqueness and (im)mutability reasoning.
SIFO introduces four type modiﬁers for references, namely read, mut, imm, and
capsule, which deﬁne allowed aliasing and mutability of objects in programs.
While, mut and imm point to mutable and immutable object respectively, a
capsule reference points to a mutable object that cannot be accessed from other
mut references. A read reference points to an object that cannot be aliased or

Title Suppressed Due to Excessive Length

3

mutated. In this section, SIFO is introduced with examples to give an overview
of the expressiveness and the security mechanism of the language. We use in the
examples two security levels, namely low and high. An information ﬂow from
low to high is allowed, whereas the opposite ﬂow is prohibited. The security
levels can be arranged in any user-deﬁned lattice. In Section 4, we introduce SIFO
formally. In Listing 1, we show the implementation of a class Card containing
a low immutable int number and two high ﬁelds: a mutable Balance and an
immutable Pin.

class Card { low imm int number ; high mut Balance blc ;

high imm Pin pin ;}

class Balance { low imm int blc ;}
class Pin { low imm int pin ;}

Listing 1: Class declarations

1
2
3
4

In Listing 2, we show allowed and prohibited ﬁeld assignments with immutable
objects as information ﬂow reasoning is the easiest with these references. In a
secure assignment, the assigned expression and the reference need the same
security level (Lines 6,7). This applies to mutable and immutable objects. The
security level of expressions is calculated by the least upper bound of the accessed
ﬁeld security level and the receiver security level. A high int cannot be assigned
to a low blc reference (Line 8) because this would leak conﬁdential information
to an attacker, when the attacker reads the low blc reference. The assignment
is rejected. Updates of a high immutable ﬁeld are allowed with a high int
(Line 9) or with a low int (Line 10). The imm reference guarantees that the
assigned integer is not changed, therefore, no new conﬁdential information can
be introduced and a promotion in Line 10 is secure. The promotion alters the
security level of the assigned expression to be equal to the security level of the
reference. As expected, the opposite update of a low ﬁeld with a high int is
prohibited in Line 11 because of the direct ﬂow from higher to lower security
levels.

5
6
7
8
9
10
11
12

low mut Card c = new low Card (); // an existing Card reference
high mut Balance blc = c . blc ; // correct access of high blc
high imm int blc = c . blc . blc ; // correct access of high blc . blc
low imm int blc = c . blc . blc ; // wrong high assigned to low
c . blc . blc = highInt ; // correct field update with high int
c . blc . blc = c . number ; // correct update with promoted imm int
high imm int highInt = 0; // should be some secret value
c . number = highInt ; // wrong , high int assigned to low c . number

Listing 2: Examples with immutable objects

Next, in Listing 3, we exemplify which updates of mutable objects are legal
and which updates are not. We have a strict separation of mutable objects
with diﬀerent security levels. We want to prohibit that an update through a
higher reference is read by lower references, or that an update through lower
references corrupt data of higher references. A new Balance object can be

4

Tobias Runge et al.

initialized as a low object because the Balance object itself is not conﬁdential
(Line 12). The association to a Card object makes it a conﬁdential attribute of
the Card class. However, the assignment of a low mut object to a high reference
is prohibited. If Line 13 would be accepted, Line 14 could be used to insecurely
update the conﬁdential Balance object because the low reference is still in scope
of the program. Only an assignment without aliasing is allowed (Line 16). With
capsule, an encapsulated object is referenced to which no other mut reference
points. The low capsBlc object can be promoted to a high security level and
assigned. Afterwards, the capsule reference is no longer accessible. In the case
of an immutable object, the aliasing is allowed (Line 18), since the object itself
cannot be updated (Line 19). Both imm and capsule references are usable to
communicate between diﬀerent security levels.

12
13
14
15
16
17
18
19

low mut Balance newBlc = new low Balance (0); // ok
c . blc = newBlc ; // wrong , mutable secret shared as low and high
newBlc . blc = 10; // ok ? Insecure with previous line
low capsule Balance capsBlc = new low Balance (0); // ok
c . blc = capsBlc ; // ok , no alias introduced
low imm Pin immPin = new low Pin (1234); // ok
c . pin = immPin ; // ok , pin is imm and can be aliased
immPin . pin = 5678; // wrong , immutable object cannot be updated

Listing 3: Examples with mutable and encapsulated objects

3

IFbCOO by Example

With IFbCOO, programmers can incrementally develop programs, where the
security levels are organized in a lattice structure to guarantee a variety of
conﬁdentiality and integrity policies. IFbCOO deﬁnes 13 reﬁnement rules to create
secure programs. As these rules are based on reﬁnement rules for correctness-
by-construction, programmers can simultaneously apply reﬁnements rules for
functional correctness [18,25,12] and security. We now explain IFbCOO in the
following examples. For simplicity, we omit the functional speciﬁcation. IFbCOO
is introduced formally in Section 4.

In IFbCOO, the programmer starts with a class including ﬁelds of the class
and declarations of method headers. IFbCOO is used to implement methods in
this class successively. The programmer chooses one abstract method body and
reﬁnes this body to a concrete implementation of the method. A starting IFbCOO
tuple speciﬁes the typing context Γ and the abstract method body eA. The
expression eA is abstract in the beginning and reﬁned incrementally to a concrete
implementation. During the construction process, local variables can be added.
The reﬁnement process in IFbCOO results in a method implementation which
can be exported to the existing class. First, we give a ﬁne-grained example to
show the application of reﬁnement rules in detail. The second example illustrates
that IFbCOO can be used to implement larger methods.

Title Suppressed Due to Excessive Length

5

The ﬁrst example in Listing 4 is a setter method. A ﬁeld number is set
with a parameter x. We start the construction with an abstract expression
eA : [Γ ; low imm void] with a typing context Γ = low mut C this, low imm int x
extracted from the method signature (C is the class of the method receiver).
The abstract expression eA contains all local information (the typing context
and its type) to be further reﬁned. A concrete expression that replaces the
abstract expression must have the same type low imm void, and it can only
use variables from the typing context Γ . The tuple [Γ ; low imm void] is now
reﬁned stepwise. First, we introduce a ﬁeld assignment: eA → eA1.number = eA2.
The newly introduced abstract expressions are eA1 : [Γ ; low mut C] and eA2 :
[Γ ; low imm int] according to the ﬁeld assignment reﬁnement rule. In the next
step, eA1 is reﬁned to this, which is the following reﬁnement: eA1.number =
eA2 → this.number = eA2. As this has the same type as eA1, the reﬁnement
is correct. The last reﬁnement replaces eA2 with x, resulting in this.number =
eA2 → this.number = x. As x has the same type as eA2, the reﬁnement is correct.
The method is fully reﬁned since no abstract expression is left.

low mut method low imm void setNumber ( low imm int x ) {

this . number = x ; }

Listing 4: Set method

To present a larger example, we construct a check of a signature in an email
system (see Listing 5). The input of the method is an email object and a client
object that is the receiver of the email. The method checks whether the key
with which the email object was signed and the stored public key of the client
object are a valid pair. If this is the case, the email object is marked as veriﬁed.
The ﬁelds isSignatureVerified and emailSignKey of the class email have a
high security level, as they contain conﬁdential data. The remaining ﬁelds have
low as security level.
static low imm void verifySignature (

low mut Client client , low mut Email email ) {
low imm int pubkey = client . publicKey ;
high imm int privkey = email . emailSignKey ;
high imm boolean isVerified ;
if ( isKeyPairValid ( privkey , pubkey )) {

isVerified = true ;

} else {

isVerified = false ;

}
email . I sSi gn atu r eV e rified = isVerified ;

}

Listing 5: Program of a secure signature veriﬁcation

In Figure 1, we show the starting IFbCOO tuple with the security level of
the variables (type modiﬁer and class name are omitted) at the top. In our
example, we have two parameters client and email, with a low security level.
To construct the algorithm of Listing 5, the method implementation is split into

1
2

1
2
3
4
5
6
7
8
9
10
11
12

6

Tobias Runge et al.

Fig. 1: Reﬁnement steps for the signature example

three parts. First, two local variables (private and public key for the signature
veriﬁcation) are initialized and a Boolean for the result of the veriﬁcation is
declared. Second, veriﬁcation whether the keys used for the signature form a
valid pair takes place. Finally, the result is saved in a ﬁeld of the email object.
Using the reﬁnement rule for composition, the program is initially split into
the initialization phase and the remainder of the program’s behavior (Ref(1)).
This reﬁnement introduces two abstract expressions eA1 and eA2. The typing
contexts of the expressions are calculated by IFbCOO automatically during
reﬁnement. As we want to initialize two local variables by further reﬁning eA1,
the ﬁnished reﬁnement in Figure 1 already contains the local high variables
privkey and isVerified, and the low variable pubkey in the typing context of
expression eA2.

In Ref(2), we apply the assignment reﬁnement5 to initialize the integers pubkey
and privkey. Both references point to immutable objects that are accessed via
ﬁelds of the objects client and email. The security levels of the ﬁeld accesses
are determined with the ﬁeld access rule checked by IFbCOO. The determined
security level of the assigned expression must match the security level of the
reference. In this case, the security levels are the same. Additionally, it is enforced
that immutable objects cannot be altered after construction (i.e., it is not possible
to corrupt the private and public key). In Ref(3), the next expression eA2 is split
with a composition reﬁnement into eA21 and eA22.

Ref(4) introduces an if-then-else-expression by reﬁning eA21. Here, it is
checked whether the public and private key pair is valid. As the privkey object
has a high security level, we have to restrict our typing context with Γ [mut(high)].

5 To be precise, it would be a combination of composition and assignment reﬁnements,
because an assignment reﬁnement can only introduce one assignment expression.

Ref(6) Γ [mut(high)]eA : [low email, low client; low imm void] low imm int pubkey = client.publicKey;  high imm int privkey = email.emailSignKey;  high imm boolean isVerified;if isKeyPairValid(privkey, pubkey)  then eT else eFemail.isSignatureVerified = isVerified;isVerified = true;Ref(1)Ref(2)Ref(3)eA1 : [low email, low client; low imm void]eA2 : [low email, low client, low pubkey, high privkey, high isVerified; low imm void]eA22 : [low email, low client, low pubkey, high privkey, high isVerified; low imm void]eA21 : [low email, low client, low pubkey, high privkey, high isVerified; low imm void]Ref(4)Ref(5) Γ [mut(high)]Ref(7)isVerified = false;Title Suppressed Due to Excessive Length

7

::= s mdf C
::= high | low | . . . (user deﬁned)

T
s
mdf ::= mut | imm | capsule | read
CD ::= class C implements C {F M D } | interface C extends C {MH }
F
M D ::= MH {return e;}
MH ::= s mdf method T m(T1 x1, . . . , Tn xn)
e

::= eA | x | e0.f = e1 | e.f | e0.m(e) | new s C (e) | e0; e1

::= s mut C f ; | s imm C f ;

| if e0 then e1 else e2 | while e0 do e1 | declassify(e)

Γ
E

::= x1 : T1 . . . xn : Tn
::= [] | E.f | E.f = e | e.f = E| E.m(e) | e.m(e E e) | new s C (e E e)

Fig. 2: Syntax of the extended core calculus of SIFO

This is necessary to prevent indirect information leaks. With the restrictions,
we can only assign expressions to at least high references and mutate high
objects (mut(high)) in the then- and else-expression. If we assign a value in the
then-expression to a low reference that is visible outside of the then-expression,
an attacker could deduce that the guard was evaluated to true by reading that
low reference.

Ref(5) introduces an assignment of an immutable object to a high reference,
which is allowed in the restricted typing context. As explained, the assignment to
low references is forbidden. The assigned immutable object true can be securely
promoted to a high security level. In Ref(6), a similar assignment is done, but
with the value false. Ref(7) sets a ﬁeld of the email object by reﬁning eA22.
We update the high ﬁeld of the email object by accepting the high expression
isVerified. With this last reﬁnement step, the method is fully concretized. The
method is secure by construction and constitutes valid SIFO code (see Listing 5).

4 Formalizing Information Flow Control-by-Construction

In this section, we formalize IFbCOO for the construction of functionally correct
and secure programs. Before, we introduce SIFO as the underlying programming
language formally.

4.1 Core Calculus of SIFO

Figure 2 shows the syntax of the extended core calculus of SIFO [26]. SIFO is an
expression-based language similar to Featherweight Java [17]. Every reference
and expression is associated with a type T . The type T is composed of a security
level s, a type modiﬁer mdf and a class name C . Security levels are arranged in a
lattice with one greatest level (cid:62) and one least level ⊥ forming the security policy.
The security policy determines the allowed information ﬂow. Conﬁdentiality
and integrity can be enforced by using two security lattices and two security
annotations for each expression. Each property is enforced by a strict separation of

8

Tobias Runge et al.

security levels. In the interest of an expressive language, we allow the information
ﬂow from lower to higher levels (conﬁdentiality or integrity security levels) using
promotion rules while the opposite needs direct interaction with the programmer
by using the declassify expression. For convenience, we will use only one lattice
of conﬁdentiality security levels in the explanations.

The type modiﬁer mdf can be mut, imm, capsule, and read with the following
subtyping relation. For all type modiﬁer mdf : capsule ≤ mdf , mdf ≤ read. In
SIFO, objects are mutable or (deeply) immutable. The reachable object graph
(ROG) from a mutable object is composed of mutable and immutable objects,
while the ROG of an immutable object can only contain immutable objects. A
mut reference must point to a mutable object; such an object can be aliased
and mutated. An imm reference must point to an immutable object; such an
object can be aliased, but not mutated. A capsule reference points to a mutable
object. The object and the mutable objects in its ROG cannot be accessed from
other references. As capsule is a subtype of imm and mut the object can be
assigned to both. Finally, a read reference is the supertype that points to an
object that cannot be aliased or mutated, but it has no immutability guarantee
that the object is not modiﬁed by other references. These modiﬁers allow us to
make precise decisions about the information ﬂow by utilizing immutability or
uniqueness properties of objects. For example, an immutable object cannot be
altered, therefore it can be securely promoted to a higher security level. For a
mutable object, a security promotion is insecure because an update through other
references with lower security levels can corrupt the conﬁdential information.

Additionally, the syntax of SIFO contains class deﬁnitions CD which can
be classes or interfaces. An interface has a list of method headers. A class has
additional ﬁelds. A ﬁeld F has a type T and a name, but the type modiﬁer can
only be mut or imm. A method deﬁnition M D consists of a method header and a
body. The header has a receiver, a return type, and a list of parameters. The
parameters have a name and a type T . The receiver has a type modiﬁer and a
security level. An expression e can be a variable, ﬁeld access, ﬁeld assignment,
method call, or object construction in SIFO. In the extended version presented in
the paper, we also added abstract expressions, sequence of expressions, conditional
expression, loop expression, and declassiﬁcation. With the declassify operator
a reverse information ﬂow is allowed. The expression eA is abstract and typed
by [Γ ; T ]. Beside the type T a local typing context Γ is used to have all needed
information to further reﬁne eA. We require a Boolean type for the guards in
the conditional and loop expression. A typing context Γ assigns a type Ti to
variable xi. With the evaluation context E, we deﬁne the order of evaluation for
the reduction of the system. The typing rules of SIFO are shown in Appendix A.

4.2 Reﬁnement Rules for Program Construction

To formalize the IFbCOO reﬁnement rules, in Figure 3, we introduce basic
notations, which are used in the reﬁnement rules.

L is the lattice of security levels to deﬁne the information ﬂow policy and
lub is used to calculate the least upper bound of a set of security levels. The

Title Suppressed Due to Excessive Length

9

L Bounded upper semi-lattice (L, ≤) of security levels

lub : P(L) → L Least upper bound of the security levels in L
{P ; Q; Γ ; T ; eA} Starting IFbCOO tuple
eA : [P ; Q; Γ ; T ] Typed abstract expression eA
Γ [mut(s)] Restricted typing context
sec(T ) = s Returns the security level s in type T

Fig. 3: Basic notations for IFbCOO

functional and security speciﬁcation of a program is deﬁned by an IFbCOO
tuple {P ; Q; Γ ; T ; eA}. The IFbCOO tuple consists of a typing context Γ , a
type T , an abstract expression eA, and a functional pre-/postcondition, which
is declared in the ﬁrst-order predicates P and Q. The abstract expression is
typed by [P ; Q; Γ ; T ]. In the following, we focus on security, so the functional
speciﬁcation is omitted.

The reﬁnement process of IFbCOO starts with a method declaration, where
the typing context Γ is extracted from the arguments and T is the method return
type. Then, the user guides the construction process by reﬁning the ﬁrst abstract
expression eA. With the notation Γ [mut(s)], we introduce a restriction to the
typing context. The function mut(s) prevents mutation of mutable objects that
have a security level lower than s. When the user chooses the lowest security
level of the lattice, the function does not restrict Γ . The function sec(T ) extracts
the security level of a type T .

Reﬁnement Rules. The reﬁnement rules are used to replace an IFbCOO tuple
{Γ ; T ; eA} with a concrete implementation by concretizing the abstract expression
eA. This reﬁnement is only correct if speciﬁc side conditions hold. On the right side
of the rules, all newly introduced symbols are implicitly existentially quantiﬁed.
The rules can introduce new abstract expressions eAi which can be reﬁned by
further applying the reﬁnement rules.

Reﬁnement Rule 1 (Variable)
eA is reﬁnable to x if eA : [Γ ; T ] and Γ (x) = T .

The ﬁrst IFbCOO rule introduces a variable x, which does not alter the program.
It reﬁnes an abstract expression to an x if x has the correct type T .

Reﬁnement Rule 2 (Field Assignment)
eA is reﬁnable to eA0.f := eA1 if eA : [Γ ; T ] and eA0 : [Γ ; s0 mut C0] and
eA1 : [Γ ; s1 mdf C] and s mdf C f ∈ f ields(C0) and s1 = lub(s0, s).

We can reﬁne an abstract expression to a ﬁeld assignment if the following
conditions hold. The expression eA0 has to be mut to allow a manipulation of the
object. The security level of the assigned expression eA1 has to be equal to the
least upper bound of the security levels of expression eA0 and the ﬁeld f . The
ﬁeld f must be a ﬁeld of the class C0 with the type s mdf C . With the security
promotion rule, the security level of the assigned expression can be altered.

10

Tobias Runge et al.

Reﬁnement Rule 3 (Field Access)
eA is reﬁnable to eA0.f if eA : [Γ ; s mdf C ] and eA0 : [Γ ; s0 mdf 0 C0] and
s1 mdf 1 C f ∈ f ields(C0) and s = lub(s0, s1) and mdf 0

(cid:3) mdf 1 = mdf .

We can reﬁne an abstract expression to a ﬁeld access if a ﬁeld f exists in the
class of receiver eA0 with the type s1 mdf 1 C . The accessed value must have the
expected type s mdf C of the abstract expression. This means, the class name
of the ﬁeld f and C must be the same. Additionally, the security level of the
abstract expression eA is equal to the least upper bound of the security levels
of expression eA0 and ﬁeld f . The type modiﬁers must also comply. The arrow
between type modiﬁers is deﬁned as follows. As we allow only mut and imm ﬁelds,
not all possible cases are deﬁned: mdf (cid:3) mdf (cid:48) = mdf (cid:48)(cid:48)
• mut (cid:3) mdf = capsule (cid:3) mdf = mdf
• imm (cid:3) mdf = mdf (cid:3) imm = imm
• read (cid:3) mut = read.

Reﬁnement Rule 4 (Method Call)
eA is reﬁnable to eA0.m(eA1, . . . , eAn) if eA : [Γ ; T ] and eA0 : [Γ ; T0] . . . eAn :
[Γ ; Tn] and T0 . . . Tn → T ∈ methTypes(class(T0), m) and sec(T ) ≥ sec(T0) and
forall i ∈ {1, . . . , n} if mdf (Ti) ∈ {mut, capsule} then sec(Ti) ≥ sec(T0).

With the method call rule, an abstract expression is reﬁned to a call to method
m. The method has a receiver eA0, a list of parameters eA1 . . . eAn, and a return
value. A method with matching deﬁnition must exist in the class of receiver
eA0. This method deﬁnition is returned by the methTypes function. The function
class returns the class of a type T . The security level of the return type has to
be greater than or equal to the security level of the receiver. This condition is
needed because through dynamic dispatch information of the receiver may be
leaked if its security level is higher than the security level of the return type.
The same applies for mut and capsule parameters. The security level of these
parameters must also be greater than or equal to the security level of the receiver.
As the method call replaces an abstract expression eA, the return value must
have the same type (security level, type modiﬁer, and class name) as the reﬁned
expression. In Appendix B, we introduce multiple methods types [26] to reduce
writing eﬀort and increase the ﬂexibility of IFbCOO. A method can be declared
with speciﬁc types for receiver, parameters and return value, and other signatures
of this method are deduced by applying the transformations from the multiple
method types deﬁnition, where security level and type modiﬁers are altered. All
these deduced method declarations can be used in the method call reﬁnement
rule.

Reﬁnement Rule 5 (Constructor)
eA is reﬁnable to new s C(eA1 . . . eAn) if eA : [Γ ; s mdf C ] and ﬁelds(C) =
T1 f1 . . . Tn fn and eA1 : [Γ ; T1[s]] . . . eAn : [Γ ; Tn[s]].

The constructor rule is a special method call. We can reﬁne an abstract expression
to a constructor call, where a mutable object of class C is constructed with a

Title Suppressed Due to Excessive Length

11

security level s. The parameter list eA1 . . . eAn must match the list of declared
ﬁelds f1 . . . fn in class C. Each parameter eAi is assigned to ﬁeld fi. This
assignment is allowed if the type of parameter eAi is (a subtype of) Ti[s]. T [s]
is a helper function which returns a new type whose security level is the least
upper bound of sec(T ) and s. It is deﬁned as: T [s] = lub(s, s (cid:48)) mdf C , where
T = s (cid:48) mdf C , deﬁned only if s(cid:48) ≤ s or s ≤ s(cid:48). By calling a constructor, the
security level s can be freely chosen to use parameters with security levels that
are higher than originally declared for the ﬁelds. In other words, a security level
s is used to initialize lower security ﬁelds with parameters of higher security level
s. This results in a newly created object with the security level s [26]. As the
newly created object replaces an abstract expression eA, the object must have
the same type as the abstract expression. If the modiﬁer promotion rule is used
(i.e., no mutable input value exist), the object can be assigned to a capsule or
imm reference.

Reﬁnement Rule 6 (Composition)
eA is reﬁnable to eA0; eA1 if eA : [Γ ; T ] and eA0 : [Γ ; T0] and eA1 : [Γ ; T ].

With the composition rule, an abstract expression eA is reﬁned to two subsequent
abstract expression eA0 and eA1. The second abstract expression must have the
same type T as the reﬁned expression.

Reﬁnement Rule 7 (Selection)
eA is reﬁnable to if eA0 then eA1 else eA2 if eA : [Γ ; T ] and eA0 : [Γ ; s imm
Boolean] and eA1 : [Γ [mut(s)]; T ] and eA2 : [Γ [mut(s)]; T ].

The selection rule reﬁnes an abstract expression to a conditional if-then-else-
expression. Secure information can be leaked indirectly as the selected branch
may reveal the value of the guard. In the branches, the typing context is restricted.
The restricted typing context prevents updating mutable objects with a security
level lower than s. The security level s is determined by the Boolean guard eA0.
When we add updatable local variables to our language, the selection rule must
also prevent the update of local variables that have a security level lower than s.

Reﬁnement Rule 8 (Repetition)
eA is reﬁnable to while eA0 do eA1 if eA : [Γ ; T ] and eA0 : [Γ ; s imm Boolean]
and eA1 : [Γ [mut(s)]; T ].

The repetition rule reﬁnes an abstract expression to a while-loop. The repetition
rule is similar to the selection rule. For the loop body, the typing context is
restricted to prevent indirect leaks of the guard in the loop body. The security
level s is determined by the Boolean guard eA0.

Reﬁnement Rule 9 (Context Rule)
E[eA] is reﬁnable to E[e] if eA is reﬁnable to e.

The context rule replaces in a context E an abstract expression with a concrete
expression, if the abstract expression is reﬁnable to the concrete expression.

12

Tobias Runge et al.

Reﬁnement Rule 10 (Subsumption Rule)
eA : [Γ ; T ] is reﬁnable to eA1 : [Γ ; T (cid:48)] if T (cid:48) ≤ T .

The subsumption rule can alter the type of expressions. An abstract expression
that requires a type T can be weakened to require a type T (cid:48) if the type T (cid:48) is a
subtype of T .

Reﬁnement Rule 11 (Security Promotion)
eA : [Γ ; s mdf C] is reﬁnable to eA1 : [Γ ; s(cid:48) mdf C] if mdf ∈ {capsule, imm}
and s(cid:48) ≤ s.

The security promotion rule can alter the security level of expressions. An abstract
expression that requires a security level s can be weakened to require a security
level s(cid:48) if the expression is capsule or imm. Other expressions (mut or read)
cannot be altered because potentially existing aliases are a security hazard.

Reﬁnement Rule 12 (Modiﬁer Promotion)
eA : [Γ ; s capsule C] is reﬁnable to eA1 : [Γ [mut\read]; s mut C].

The modiﬁer promotion rule can alter the type modiﬁer of an expression eA.
An abstract expression that requires a capsule type modiﬁer can be weakened
to require a mut type modiﬁer if all mut references are only seen as read in
the typing context. That means, that the mutable objects in the ROG of the
expression cannot be accessed by other references. Thus, manipulation of the
object is only possible through the reference on eA.

Reﬁnement Rule 13 (Declassiﬁcation)
eA : [Γ ; ⊥ mdf C] is reﬁnable to declassify(eA1) : [Γ ; s mdf C] if mdf ∈
{capsule, imm}.

In our information ﬂow policy, we can never assign an expression with a higher
security level to a variable with a lower security level. To allow this assignment
in appropriate cases, the declassify rule is used. An expression eA is altered
to a declassify-expression with an abstract expression eA1 that has a security
level s if the type modiﬁer is capsule or imm. A mut or read expression cannot
be declassiﬁed as existing aliases are a security hazard. Since we have the
security promotion rule, the declassiﬁed capsule or imm expression can directly
be promoted to any higher security level. Therefore, it is suﬃcient to use the
bottom security level in this rule without restricting the expressiveness. For
example, the rule can be used to assign a hashed password to a public variable.
The programmer has the responsibility to ensure that the use of declassify is
secure.

4.3 Proof of Soundness

In this subsection and Appendix C, we prove that programs constructed with
the IFbCOO reﬁnement rules are secure according to the deﬁned information

Title Suppressed Due to Excessive Length

13

ﬂow policy. We prove this by showing that programs constructed with IFbCOO
are well typed in SIFO (Theorem 1). SIFO itself is proven to be secure [26]. In
Appendix C, we prove this property for the core language of SIFO, which does
not contain composition, selection, and repetition expressions. The SIFO core
language is minimal, but using well-known encodings, it can support composition,
selection, and repetition (encodings of the Smalltalk [14] style support control
structures). We also exclude the declassify operation because this rule is an
explicit mechanism to break security in a controlled way.

Theorem 1 (Soundness of IFbCOO).
An expression e constructed with IFbCOO is well typed in SIFO.

5 CorC Tool Support and Evaluation

IFbCOO is implemented in the tool CorC [25,12]. CorC itself is a hybrid tex-
tual and graphical editor to develop programs with correctness-by-construction.
IFbC [24] is already implemented as extension of CorC, but to support object-
orientation with IFbCOO a redesign was necessary. Source code and case studies
are available at: https://github.com/TUBS-ISF/CorC/tree/CCorCOO.

5.1 CorC for IFbCOO

For space reasons, we cannot introduce CorC comprehensively. We just summarize
the features of CorC to check IFbCOO information ﬂow policies:

– Programs are written in a tree structure of reﬁning IFbCOO tuples (see
Figure 1). Besides the functional speciﬁcation, variables are labeled with a
type T in the tuples.

– Each IFbCOO reﬁnement rule is implemented in CorC. Consequently, func-

tional correctness and security can be constructed simultaneously.

– The information ﬂow checks according to the reﬁnement rules are executed

automatically after each reﬁnement.

– Each CorC-program is uniquely mapped to a method in a SIFO class. A
SIFO class contains methods and ﬁelds that are annotated with security
labels and type modiﬁers.

– A properties view shows the type T of each used variable in an IFbCOO
tuple. Violations of the information ﬂow policy are explained in the view.

5.2 Case Studies and Discussion

The implementation of IFbCOO in the tool CorC enables us to evaluate the
feasibility of the security mechanism by successfully implementing three case
studies [16,31] from the literature and a novel one in CorC. The case studies are
also implemented and type-checked in SIFO to conﬁrm that the case studies are
secure. The newly developed Database case study represents a secure system that

14

Tobias Runge et al.

Name

Database

Email [16]

Banking [31]

Paycard

#Security
Levels

4

2

2

6

9

3

156

807

243

2

3
244
Table 1: Metrics of the case studies

CorC

2

15

6

5

#Classes

#Lines of Code #Methods in

strictly separates databases of diﬀerent security levels. Email [16] ensures that
encrypted emails cannot be decrypted by recipients without the matching key.
Paycard (http://spl2go.cs.ovgu.de/projects/57) and Banking [31] simulate
secure money transfer without leaking customer data. The Database case study
uses four security levels, while the others (Email, Banking, and Paycard ) use two.
As shown in Table 1, the cases studies comprise three to nine classes with
156 to 807 lines of code each. 28 Methods that exceed the complexity of getter
and setter are implemented in CorC. It should be noted that we do not have
to implement every method in CorC. If only low input data is used to compute
low output, the method is intrinsically secure. For example, three classes in the
Database case study are implemented with only low security levels. Only the class
GUI and the main method of the case study, which calls the low methods with
higher security levels (using multiple method types) is then correctly implemented
in CorC. The correct and secure promotion of security levels of methods called
in the main method is conﬁrmed by CorC.

Discussion and Applicability of IFbCOO. We emphasize that CbC and also IFb-
COO should be used to implement correctness- and security-critical programs [18].
The scope of this work is to demonstrate the feasibility of the incremental con-
struction of correctness- and security-critical programs. We argue that we achieve
this goal by implementing four case studies in CorC.

The constructive nature of IFbCOO is an advantage in the secure creation
of programs. Instead of writing complete methods to allow a static analyzer to
accept/reject the method, with IFbCOO, we directly design and construct secure
methods. We get feedback during each reﬁnement step, and we can observe the
status of all accessible variables at any time of the method. For example, we
received direct feedback when we manipulated a low object in the body of a high
then-branch. With this information, we could adjust the code to ensure security.
As IFbCOO extends CorC, functional correctness is also guaranteed at the same
time. This is beneﬁcial as a program, which is security-critical, should also be
functionally correct. As IFbCOO is based on SIFO, programs written with any
of the two approaches can be used interchangeably. This allows developers to use
their preferred environment to develop new systems, re-engineer their systems, or
integrate secure software into existing systems. These beneﬁts of IFbCOO are of
course connected with functional and security speciﬁcation eﬀort, and the strict
reﬁnement-based construction of programs.

Title Suppressed Due to Excessive Length

15

6 Related Work

In this section, we compare IFbCOO to IFbC [24,28] and other Hoare-style logics
for information ﬂow control. We also discuss information ﬂow type systems and
correctness-by-construction [18] for functional correctness.

IFbCOO extends IFbC [24] by introducing object-orientation and type modi-
ﬁers. IFbC is based on a simple while language. As explained in Section 4, the
language of IFbCOO includes objects and type modiﬁers. Therefore, the reﬁne-
ment rules of IFbC are revised to handle secure information ﬂow with objects.
The object-orientation complicates the reasoning of secure assignments because
objects could be altered through references with diﬀerent security levels. If private
information is introduced, an already public reference could read this information.
SIFO and therefore IFbCOO consider these cases and prevent information leaks
by considering immutability and encapsulation and only allowing secure aliases.
Previous work using Hoare-style program logics with information ﬂow control
analyzes programs after construction, rather than guaranteeing security during
construction. Andrews and Reitman [5] encode information ﬂow directly in a
logical form. They also support parallel programs. Amtoft and Banerjee [3] use
Hoare-style program logics and abstract interpretations to detect information
ﬂow leaks. They can give error explanations based on strongest postcondition
calculation. The work of Amtoft and Banerjee [3] is used in SPARK Ada [4] to
specify and check the information ﬂow.

Type system for information ﬂow control are widely used, we refer to Sabelfeld
and Myers [27] for a comprehensive overview. We only discuss closely related
type systems for object-oriented languages [11,9,30,20,29,10]. Banerjee et al. [9]
introduced a type system for a Java-like language with only two security levels.
We extend this by operating on any lattice of security levels. We also introduce
type modiﬁers to simplify reasoning in cases where objects cannot be mutated
or are encapsulated. Jif [20] is a type system to check information ﬂow in Java.
One main diﬀerence is in the treatment of aliases: Jif does not have an alias
analysis to reason about limited side eﬀects. Therefore, Jif pessimistically discards
programs that introduce aliases because Jif has no option to state immutable or
encapsulated objects. IFbCOO allows the introduction of secure aliases.

In the area of correctness-by-construction, Morgan [19] and Back [8] propose
reﬁnement-based approaches which reﬁne functional speciﬁcations to concrete
implementations. Beside of pre-/postcondition speciﬁcation, Back also uses invari-
ants as starting point. Morgan’s calculus is implemented in ArcAngel [22] with
the veriﬁer ProofPower [32], and SOCOS [6,7] implements Back’s approach. In
comparison to IFbCOO, those approaches do not reason about information ﬂow
security. Other reﬁnement-based approaches are Event-B [1,2] for automata-based
systems and Circus [21,23] for state-rich reactive systems. These approaches have
a higher abstraction level, as they operate on abstract machines instead of source
code. Hall and Chapman [15] introduced with CbyC another related approach
that uses formal modeling techniques to analyze the development during all stages
(architectural design, detailed design, code) to eliminate defects early. IFbCOO
is tailored to source code and does not consider other development phases.

16

Tobias Runge et al.

7 Conclusion

In this paper, we present IFbCOO, which establishes an incremental reﬁnement-
based approach for functionally correct and secure programs. With IFbCOO
programs are constructed stepwise to comply at all time with the security policy.
The local check of each reﬁnement can reduce debugging eﬀort, since the user
is not warned only after the implementation of a whole method. We formalized
IFbCOO by introducing 13 reﬁnement rules and proved soundness by showing
that constructed programs are well-typed in SIFO. We also implemented IFbCOO
in CorC and evaluated our implementation with a feasibility study. One future
direction of research is the conduction of comprehensive user studies for user-
friendly improvements which is only now possible due to our sophisticated CorC
tool support.

Acknowledgments This work was supported by KASTEL Security Research Labs.

References

1. Abrial, J.: Modeling in Event-B - System and Software Engineering. Cambridge

University Press (2010)

2. Abrial, J.R., Butler, M., Hallerstede, S., Hoang, T.S., Mehta, F., Voisin, L.: Rodin:
An Open Toolset for Modelling and Reasoning in Event-B. International Journal
on Software Tools for Technology Transfer 12(6), 447–466 (2010)

3. Amtoft, T., Banerjee, A.: Information Flow Analysis in Logical Form. In: Interna-
tional Static Analysis Symposium. LNCS, vol. 3148, pp. 100–115. Springer (2004)
4. Amtoft, T., Hatcliﬀ, J., Rodr´ıguez, E., Robby, Hoag, J., Greve, D.A.: Speciﬁca-
tion and Checking of Software Contracts for Conditional Information Flow. In:
International Symposium on Formal Methods. pp. 229–245. Springer (2008)

5. Andrews, G.R., Reitman, R.P.: An Axiomatic Approach to Information Flow in
Programs. ACM Transactions on Programming Languages and Systems (TOPLAS)
2(1), 56–76 (1980)

6. Back, R.J.: Invariant Based Programming: Basic Approach and Teaching Experi-

ences. Formal Aspects of Computing 21(3), 227–244 (2009)

7. Back, R.J., Eriksson, J., Myreen, M.: Testing and Verifying Invariant Based Pro-
grams in the SOCOS Environment. In: International Conference on Tests and
Proofs (TAP). LNCS, vol. 4454, pp. 61–78. Springer (2007)

8. Back, R.J., Wright, J.: Reﬁnement Calculus: A Systematic Introduction. Springer

Science & Business Media (2012)

9. Banerjee, A., Naumann, D.A.: Secure Information Flow and Pointer Conﬁnement in
a Java-like Language. In: Computer Security Foundations Workshop. vol. 2, p. 253
(2002)

10. Barthe, G., Pichardie, D., Rezk, T.: A Certiﬁed Lightweight Non-Interference Java
Bytecode Veriﬁer. In: European Symposium on Programming. LNCS, vol. 4421, pp.
125–140. Springer (2007)

11. Barthe, G., Serpette, B.P.: Partial Evaluation and Non-Interference for Object
Calculi. In: International Symposium on Functional and Logic Programming. LNCS,
vol. 1722, pp. 53–67. Springer (1999)

Title Suppressed Due to Excessive Length

17

12. Bordis, T., Cleophas, L., Kittelmann, A., Runge, T., Schaefer, I., Watson, B.W.:
Re-CorC-ing KeY: Correct-by-Construction Software Development Based on KeY.
In: The Logic of Software. A Tasting Menu of Formal Methods. Springer (2022)

13. Giannini, P., Servetto, M., Zucca, E., Cone, J.: Flexible Recovery of Uniqueness

and Immutability. Theoretical Computer Science 764, 145–172 (2019)

14. Goldberg, A., Robson, D.: Smalltalk-80: The Language and its Implementation.

Addison-Wesley Longman Publishing Co., Inc. (1983)

15. Hall, A., Chapman, R.: Correctness by Construction: Developing a Commercial

Secure System. IEEE Software 19(1), 18–25 (2002)

16. Hall, R.J.: Fundamental Nonmodularity in Electronic Mail. Automated Software

Engineering 12(1), 41–79 (2005)

17. Igarashi, A., Pierce, B.C., Wadler, P.: Featherweight Java: A Minimal Core Calculus
for Java and GJ. ACM Transactions on Programming Languages and Systems
(TOPLAS) 23(3), 396–450 (2001)

18. Kourie, D.G., Watson, B.W.: The Correctness-by-Construction Approach to Pro-

gramming. Springer Science & Business Media (2012)

19. Morgan, C.: Programming from Speciﬁcations. Prentice Hall, 2nd edn. (1994)
20. Myers, A.C.: JFlow: Practical Mostly-Static Information Flow Control. In: Proceed-
ings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages. pp. 228–241. ACM (1999)

21. Oliveira, M., Cavalcanti, A., Woodcock, J.: A UTP Semantics for Circus. Formal

Aspects of Computing 21(1), 3–32 (2009)

22. Oliveira, M.V.M., Cavalcanti, A., Woodcock, J.: ArcAngel: A Tactic Language for

Reﬁnement. Formal Aspects of Computing 15(1), 28–47 (2003)

23. Oliveira, M.V.M., Gurgel, A.C., Castro, C.G.: CReﬁne: Support for the Circus
Reﬁnement Calculus. In: 2008 Sixth IEEE International Conference on Software
Engineering and Formal Methods. pp. 281–290. IEEE (Nov 2008)

24. Runge, T., Kn¨uppel, A., Th¨um, T., Schaefer, I.: Lattice-Based Information Flow
Control-by-Construction for Security-by-Design. In: Proceedings of the 8th Interna-
tional Conference on Formal Methods in Software Engineering (2020)

25. Runge, T., Schaefer, I., Cleophas, L., Th¨um, T., Kourie, D., Watson, B.W.: Tool
Support for Correctness-by-Construction. In: International Conference on Funda-
mental Approaches to Software Engineering. LNCS, vol. 11424, pp. 25–42. Springer,
Cham (2019)

26. Runge, T., Servetto, M., Potanin, A., Schaefer, I.: Immutability and Encapsulation

for Sound OO Information Flow Control (2022), Under Review

27. Sabelfeld, A., Myers, A.C.: Language-Based Information-Flow Security. IEEE

Journal on Selected Areas in Communications 21(1), 5–19 (2003)

28. Schaefer, I., Runge, T., Kn¨uppel, A., Cleophas, L., Kourie, D., Watson, B.W.: To-
wards Conﬁdentiality-by-Construction. In: International Symposium on Leveraging
Applications of Formal Methods. LNCS, vol. 11244, pp. 502–515. Springer (2018)
29. Strecker, M.: Formal Analysis of an Information Flow Type System for MicroJava.

Technische Universit¨at M¨unchen, Tech. Rep (2003)

30. Sun, Q., Banerjee, A., Naumann, D.A.: Modular and Constraint-Based Information
Flow Inference for an Object-Oriented Language. In: International Static Analysis
Symposium. LNCS, vol. 3148, pp. 84–99. Springer (2004)

31. Th¨um, T., Schaefer, I., Apel, S., Hentschel, M.: Family-based Deductive Veriﬁcation
of Software Product Lines. In: Proceedings of the 11th International Conference on
Generative Programming and Component Engineering. pp. 11–20 (2012)

32. Zeyda, F., Oliveira, M., Cavalcanti, A.: Supporting ArcAngel in ProofPower. Elec-

tronic Notes in Theoretical Computer Science 259, 225–243 (2009)

18

Tobias Runge et al.

A Expression Typing Rules of SIFO

In Figure 4, typing rules of SIFO are shown.

mdf ≤ mdf (cid:48)
C ≤ C(cid:48)
s mdf C ≤ s mdf (cid:48) C(cid:48)

(Sub)

Γ (cid:96) e : T (cid:48)

T (cid:48) ≤ T

Γ (cid:96) e : T

(Subsumption)

Γ (cid:96) x : Γ (x)

(T-Var)

Γ (cid:96) e0 : s0 mdf 0 C0

Γ (cid:96) e0.f : lub(s0, s1) mdf 0

s1 mdf 1 C1 f ∈ ﬁelds(C0)
(cid:3) mdf 1 C1

(Field Access)

Γ (cid:96) e1 : lub(s0, s) mdf C

s mdf C f ∈ ﬁelds(C0)

Γ (cid:96) e0 : s0 mut C0

Γ (cid:96) e0.f = e1 : lub(s0, s) mdf C

(Field Assign)

Γ (cid:96) e0 : T0 . . . Γ (cid:96) en : Tn

sec(T ) ≥ sec(T0)

if mdf (Ti) ∈ {mut, capsule} then sec(Ti) ≥ sec(T0)
T0 . . . Tn → T ∈ methTypes(class(T0), m)
Γ (cid:96) e0.m(e1 . . . en) : T

(Call)

Γ (cid:96) e1 : T1[s] . . . Γ (cid:96) en : Tn[s]

ﬁelds(C) = T1 f1 . . . Tn fn

Γ (cid:96) new s C(e1 . . . en) : s mut C

(New)

Γ [mut\read] (cid:96) e : s mut C
Γ (cid:96) e : s capsule C

(Prom)

s(cid:48) ≤ s

Γ (cid:96) e : s (cid:48) mdf C

mdf ∈ {imm, capsule}

Γ (cid:96) e : s mdf C

(Sec-Prom)

this : s mdf C, x1 : T1 . . . xn : Tn

(cid:96) e : T

C (cid:96) s mdf method T m(T1 x1 . . . Tn xn){return e; }

(M-Ok)

C (cid:96) M1 . . . C (cid:96) Mn

mhs(C) ⊆ mhs(M1 . . . Mn)

class C implements C {F M1 . . . Mn}

(C-Ok)

mhs(C) ⊆ MH
interface C extends C {MH }

(I-Ok)

Fig. 4: Expression typing rules of SIFO

B Method Declarations.

In Figure 5, we show the transformations, which can be applied on a method
declaration. In the ﬁrst case, the security level of all types can be increased by
choosing a security level s(cid:48) higher than the lowest level of the lattice. As used
in the constructor rule, the helper function T [s(cid:48)] increases the security level of
T to the least upper bound of s(cid:48) and sec(T ). This means, a method can be
declared with some security level, but it can be used with any higher level by
applying the ﬁrst transformation case. For example, a mathematical function

Title Suppressed Due to Excessive Length

19

If s mdf method T m(T1 x1 . . . Tn xn) is declared in C, with T0 = s mdf C then
1: T0[s(cid:48)] . . . Tn[s(cid:48)] → T [s(cid:48)] ∈ methTypes(C, m)
2: (T0[s(cid:48)] . . . Tn[s(cid:48)] → T [s(cid:48)])[mut\capsule] ∈ methTypes(C, m)
3: (T0[s(cid:48)] . . . Tn[s(cid:48)] → T [s(cid:48)])[read\imm, mut\capsule] ∈ methTypes(C, m)

Fig. 5: Deﬁnition of multiple method types

can be called with low parameters and it returns a low result, or it can be called
with high parameters and it returns a high result. Thanks to this deﬁnition, the
programmer has to declare the method only once.

In the second and third case, the security level can be altered as in the ﬁrst
case. Additionally, in the second case, all type modiﬁers mut are changed to
capsule. This is useful for methods, which are declared with mut parameters and
return type. If we provide capsule instead of mut in the input, we can use the
method to produce a capsule return value. If we ensure that only encapsulated
input is used, we can guarantee that the produced output is also a capsule.
Thus, we do not have to declare a method twice with capsule or mut types.

The third case changes all read type modiﬁers to imm and all mut type
modiﬁers to capsule. This case is useful if the method is returning a read value,
then we can obtain an imm. A read reference can point to immutable or mutable
object. If it is an immutable object, we can return it as imm. If it is a mutable
object, as in case two, the object can be promoted to capsule, and capsule is a
subtype of imm.

C Proof of Soundness Theorem 1

Proof. We prove by structural induction on the length of the reﬁnement chain.
We prove that any expression that is generated using n or less reﬁnement steps
is well-typed.
Base: The only expressions that can be generated with one reﬁnement step are of
form x and newC(). An expression of form x must have been obtained starting
from an abstract expression eA : [Γ ; T ] and was replaced with an x so that
Γ (x) = T . Thus, we can apply rule (T-Var) of SIFO to type the expression.

An expression of form newC() must have been obtained starting from an
abstract expression eA : [Γ ; T ] and was replaced with a newsC() so that T =
s mut C and ﬁelds(C) = ∅. Thus, we can apply rule (New) of SIFO to type the
expression.
Inductive step: For the inductive step, we prove by cases over the ﬁrst performed
reﬁnement step. The expression resulting from the complete reﬁnement will have
sub-expressions that have been completed using less reﬁnement steps. Thus, in all
those cases the following inductive hypothesis will hold: all the sub-expressions of
the ﬁnal result of the reﬁnement using less than n reﬁnement steps are well-typed.
We will then need to prove that the ﬁnal result of the reﬁnement is well-typed
too.

20

Tobias Runge et al.

Field Assignment. The abstract expression eA : [Γ ; T ] is reﬁned in the
ﬁrst step into eA0.f = eA1 and then it is fully-reﬁned into e0.f = e1. It must
be the case that eA0 : [..] is fully-reﬁned into e0 (by application of reﬁnement
rules through the rule 9 (context rule)) and eA1 : [..] is fully-reﬁned into e1
(by application of reﬁnement rules through the rule 9 (context rule)). By the
inductive hypothesis, we have Γ (cid:96) e0 : s0 mut C0 and Γ (cid:96) e1 : s1 mdf C.
Then, we know that Γ (cid:96) e0.f = e1 : s1 mdf C, since we applied reﬁnement rule
(Field Assignment). We know that we can apply the rule (Field Assign) of SIFO
because premise 1 of (Field Assign) is satisﬁed since e0 is well-typed and premise
2 of (Field Assign) is satisﬁed since e1 is well-typed. Additionally, the (Field
Assignment) reﬁnement states that s mdf C f ∈ f ields(C0) and s1 = lub(s0, s).
These are the same conditions as for the (Field Assign) typing rule in SIFO,
therefore, the (Field Assignment) reﬁnement is well-typed.

Field Access. The abstract expression eA : [Γ ; T ] is reﬁned in the ﬁrst step
into eA0.f and then it is fully-reﬁned into e0.f . It must be the case that eA0 : [..]
is fully-reﬁned into e0. By the inductive hypothesis, we have Γ (cid:96) e0 : s0 mdf 0 C0.
Then, we know that Γ (cid:96) e0.f : s mdf C and s1 mdf 1 C f ∈ f ields(C0), since
we applied reﬁnement rule (Field Access). We know that we can apply the rule
(Field Access) of SIFO because premise 1 of (Field Access) is satisﬁed since
e0 is well-typed. Additionally, the (Field Access) reﬁnement states that and
(cid:3) mdf 1 = mdf . These are the same conditions as for
s = lub(s0, s1) and mdf 0
the (Field Access) typing rule in SIFO, therefore, the (Field Access) reﬁnement
is well-typed.

Method Call. The abstract expression eA : [Γ ; T ] is reﬁned in the ﬁrst step
into eA0.m(eA1, . . . , eAn) and then it is fully-reﬁned into e0.m(e1, . . . , en). It
must be the case that eA0 : [..], . . . , eAn : [..] are fully-reﬁned into e0, . . . , en.
By the inductive hypothesis, we have Γ (cid:96) e0 : T0 . . . Γ (cid:96) en : Tn. Then, we
know that Γ (cid:96) e0.m(e1, . . . , en) : T , since we applied reﬁnement rule (Method
Call). We know that we can apply the rule (Call) of SIFO because premise 1 of
(Call) is satisﬁed since e0, . . . , en are well-typed. Additionally, the (Method Call)
reﬁnement state that T0 . . . Tn → T ∈ methTypes(class(T0), m) and sec(T ) ≥
sec(T0) and if mdf (Ti) ∈ {mut, capsule} then sec(Ti) ≥ sec(T0). These are
the same conditions as for the (Call) typing rule, therefore, the (Method Call)
reﬁnement is well-typed.

Constructor. The abstract expression eA : [Γ ; T ] is reﬁned in the ﬁrst step
into new s C(eA1 . . . eAn) and then it is fully-reﬁned into new s C(e1 . . . en). It
must be the case that eA1 : [..], . . . , eAn : [..] are fully-reﬁned into e1, . . . , en. By
the inductive hypothesis, we have Γ (cid:96) e1 : T1[s] . . . Γ (cid:96) en : Tn[s]. Then, we
know that new s C(eA1 . . . eAn), since we applied reﬁnement rule (Constructor).
We know that we can apply the rule (New) of SIFO because premise 1 of
(New) is satisﬁed since e0, . . . , en are well-typed. Additionally, the (Constructor)
reﬁnement state that ﬁelds(C) = T1 f1 . . . Tn fn. This is the same condition as
for the (New) typing rule in SIFO, therefore, the (Constructor) reﬁnement is
well-typed.

Title Suppressed Due to Excessive Length

21

Subsumption. The abstract expression eA : [Γ ; T ] is reﬁned in the ﬁrst step
into eA1 : [Γ ; T (cid:48)] and then it is fully-reﬁned into e. By the inductive hypothesis,
we have Γ (cid:96) e : T (cid:48). Then, we know that T (cid:48) ≤ T , since we applied reﬁnement rule
(Subsumption). We know that we can apply the rule (Subsumption) of SIFO
because premise 1 and 2 are satisﬁed. Therefore, the (Subsumption) reﬁnement
is well-typed.

Security Promotion. The abstract expression eA : [Γ ; T ] is reﬁned in the
ﬁrst step into eA1 : [Γ ; s(cid:48) mdf C] and then it is fully-reﬁned into e. By the
inductive hypothesis, we have Γ (cid:96) e : s(cid:48) mdf C. Then, we know that s(cid:48) ≤ s and
mdf ∈ {capsule, imm} since we applied reﬁnement rule (Security Promotion).
We know that we can apply the rule (Sec-Prom) of SIFO because premise 1, 2,
and 3 are satisﬁed. Therefore, the (Security Promotion) reﬁnement is well-typed.
Modiﬁer Promotion.The abstract expression eA : [Γ ; s capsule C] is
reﬁned in the ﬁrst step into eA1 : [Γ [mut\read]; s mut C] and then it is fully-
reﬁned into e. By the inductive hypothesis, we have Γ [mut\read] (cid:96) e : s mut C.
We know that we can apply the rule (Prom) of SIFO because premise 1 is satisﬁed.
Therefore, the (Modiﬁer Promotion) reﬁnement is well-typed.

