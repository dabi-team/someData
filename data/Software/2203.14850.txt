A Fly in the Ointment: An Empirical Study on the Characteristics of Ethereum Smart
Contracts Code Weaknesses and Vulnerabilities

Majd Souda,∗, Grischa Liebela, Mohammad Hamdaqaa,b

aSchool of Computer Science, Reykjavik University, Reykjavik, Iceland
bDepartment of Computer and Software Engineering, Polytechnique Montreal, Montreal, Canada

2
2
0
2

r
a

M
8
2

]

R
C
.
s
c
[

1
v
0
5
8
4
1
.
3
0
2
2
:
v
i
X
r
a

Abstract

Context: Smart contracts are computer programs that are automatically executed on the blockchain. Among other issues, vul-
nerabilities in their implementation have led to severe loss and theft of cryptocurrency. In contrast to traditional software, smart
contracts become immutable when deployed to the Ethereum blockchain. Therefore, it is essential to understand the nature of vul-
nerabilities in Ethereum smart contracts to prevent these vulnerabilities in the future. Existing classiﬁcations exist, but are limited
in several ways, e.g., focusing on single data sources, mixing dimensions, or providing categories that are not orthogonal.
Objective: This study aims to characterize vulnerabilities and code weaknesses in Ethereum smart contracts written in Solidity,
and to unify existing classiﬁcations schemes on Ethereum smart contract vulnerabilities by mapping them to our classiﬁcation.
Method: We extracted 2143 vulnerabilities from public coding platforms (i.e., GitHub and Stack Overﬂow) and popular vulnera-
bility databases (i.e., National Vulnerability Database and Smart Contract Weakness Registry) and categorized them using a card
sorting approach. We targeted the Ethereum blockchain in this paper, as it is the ﬁrst and most popular blockchain to support
the deployment of smart contracts, and Solidity as the most widely used language to implement smart contracts. We devised a
classiﬁcation scheme of smart contract vulnerabilities according to their error source and impact. Afterwards, we mapped existing
classiﬁcation schemes to our classiﬁcation.
Results: The resulting classiﬁcation consists of 11 categories describing the error source of a vulnerability and 13 categories de-
scribing potential impacts. Our ﬁndings show that the language speciﬁc coding and the structural data ﬂow categories are the
dominant categories, but that the frequency of occurrence diﬀers substantially between the data sources.
Conclusions: Our ﬁndings enable researchers to better understand smart contract vulnerabilities by deﬁning various dimensions of
the problem and supporting our classiﬁcation with mappings with literature-based classiﬁcations and frequency distributions of the
deﬁned categories. Also, they allow researchers to target their research and tool development to better support the implementation
and quality assurance of smart contracts.

Keywords: Blockchain, Smart Contracts, Ethereum, Solidity, Software Security, Vulnerability.

1. Introduction

To process autonomous tasks, some blockchains execute dig-
ital programs called smart contracts that become immutable
once deployed (Zheng et al., 2020). Smart contracts are au-
tonomous programs that can (1) customize contracting rules
and functions between contractors and (2) facilitate transfer-
ring irreversible and traceable digital cryptocurrency transac-
tions (Hewa et al., 2020). Smart contracts were born and con-
tinued to grow with noteworthy achievements in various life
ﬁelds, including industry, ﬁnance, and economic.

Due to the immaturity of blockchain technology, vulnerabili-
ties in smart contracts can have severe consequences and result
in substantial ﬁnancial losses. For instance, the infamous DAO
attack in 2016 (Mehar et al., 2019) resulted in stealing around
50 million dollars because of exploiting a re-entrancy vulnera-

∗Corresponding author
Email addresses: majd18@ru.is (Majd Soud), grischal@ru.is

(Grischa Liebel), mhamdaqa@polymtl.ca (Mohammad Hamdaqa)

Preprint submitted to Elsevier

bility in the Distributed Autonomous Organizations (DAO) con-
tract1.

Therefore, understanding vulnerabilities in smart contracts is
critical to perceive the threats they represent, e.g., to develop
predictive models or software engineering tools that can pre-
dict or detect threats with a high precision (Seacord and House-
holder, 2005). Furthermore, classifying smart contract vulner-
abilities enables researchers and practitioners to better under-
stand their frequency and trends over time

Existing studies attempt

to categorize vulnerabilities in
Ethereum smart contracts Atzei et al. (2017); Dingman et al.
(2019); Chen et al. (2020b); Zhang et al. (2020); Rameder
(2021). While they provide valuable insights into existing se-
curity issues in smart contracts, they fall short in several ways:

1. There is no uniﬁed view on smart contract vulnerabili-
ties. For instance, (Atzei et al., 2017) classify security vul-
nerabilities according to their network level, (Chen et al.,

1https://www.coindesk.com/understanding-dao-hack-journalists

 
 
 
 
 
 
2020b) classify defects in smart contracts according to
their impact on quality attributes, and (Zhang et al., 2020)
categorize smart contract defects according to sources of
error. While these dimensions are all relevant, they are
orthogonal and cannot easily be compared.

2. Several studies mix diﬀerent classiﬁcation dimensions.
For instance, (Zhang et al., 2020) focus primarily on er-
ror sources (e.g., data and interface errors), but also in-
clude categories concerned with eﬀects/impact on qual-
ity attributes (e.g., security and performance). This leads
to classiﬁcations where categories are not orthogonal and,
since these dimensions are not discussed, often confusing.
3. Vulnerabilities are classiﬁed into broad categories.
Several studies classify vulnerabilities into broad cate-
gories, which results in two main shortcomings. First, a
vulnerability can be assigned into more than one category.
Second, the diﬀerences among the categories are too gen-
eral to be useful to reason about the vulnerabilities.

4. Data sources diﬀer widely. Several existing studies rely
only on vulnerabilities published in academic literature or
white literature, e.g., (Atzei et al., 2016) and (Alharby and
Van Moorsel, 2017), while (Chen et al., 2020b) used posts
on StackExchange, and (Zhang et al., 2020) used a mix of
academic literature and GitHub project data. This makes
the comparison challenging or even impossible.

5. Important data sources are omitted in existing classiﬁ-
cations. To our knowledge, no existing study uses estab-
lished vulnerability and defect registries such as the Smart
Contract Weakness Registry (SWC) 2 and vulnerabilities
in the Common Vulnerability and Exposure (CVE)3.

To address these gaps,

the contribution of this study is

twofold:

1. To unify existing classiﬁcations on smart contract vulner-
abilities by providing an overview of the diﬀerent classiﬁ-
cation dimensions, and by mapping existing classiﬁcations
to a single classiﬁcation scheme using error source and im-
pact as dimensions of the vulnerabilities.

2. To complement existing studies by classifying smart con-
tract vulnerabilities extracted from a variety of important
data sources according to the diﬀerent dimensions pre-
sented in existing work.

We extracted and analyzed data related to Ethereum smart
contracts written in Solidity from four data sources, i.e., Stack
Overﬂow, GitHub, CVE and SWC. Using a card sorting ap-
proach, we devised a classiﬁcation scheme that uses the error
source and impact of a vulnerability as dimensions. Further-
more, we mapped existing classﬁcations to this scheme and an-
alyzed the frequency distribution of the deﬁned categories per
data source. The resulting classiﬁcation scheme consists of 11
categories describing the error source, and 13 categories de-
scribing potential impacts.

2https://swcregistry.io/
3https://cve.mitre.org/

Our ﬁndings show that language speciﬁc coding and struc-
tural data ﬂow categories are the dominant categories of vul-
nerabilities in Ethereum smart contracts. However, frequency
distribution of the error source categories diﬀer widely across
data sources. With respect to the existing classifcations, we
ﬁnd that the majority of sources use broad categories that are
applicable to many vulnerabilities, such as “security” or “avail-
ability”.

The remainder of this paper is organized as follows. Sec-
tion 2 presents the background on Ethereum smart contracts,
Solidity and the used data sources. Section 3 discusses how ex-
isting work relates to our study and what gaps exist. Section 2
describes the methodology that we followed. In Section 5, we
report our ﬁndings in terms of the obtained classiﬁcation and
mapping to existing work. We then discuss our ﬁndings in Sec-
tion 6 and potential threats to validity in Section 7. The paper
is concluded in Section 8.

2. Background

In this section, we discuss the background of our work.
Speciﬁcally, we discuss deﬁnitions used in this paper,
the
Ethereum environment, and existing vulnerability and weak-
ness databases.

2.1. Deﬁnitions

Before we can discuss a classiﬁcation scheme for smart con-
tracts’ vulnerabilities, it is fundamental that we have a suﬃ-
ciently speciﬁc deﬁnition of what we are classifying. There
have been eﬀorts to formally deﬁne concepts such as vulner-
ability in SE. However, we will use the formal deﬁnition of a
vulnerability and weakness that were deﬁned in the Ethereum
Improvement Proposals (EIPs)4 as follows:

• Vulnerability:

“A weakness or multiple weaknesses
which directly or indirectly lead to an undesirable state in a
smart contract system” (EIP 1470). A vulnerable contract
does not necessarily imply exploited (Perez and Livshits,
2019). Moreover, as the contract is a digital agreement be-
tween two or more parties, exploiting the contract is not
always done by external malicious actors. A venerable
contract can also be exploited by one of the contracting
parties such as the contract owner who can use vulnera-
bilities to gain more proﬁts such as in CVE-2018-137835.
Any of the contractors can also exploit it, the miners or
even the developers who implemented the contract (e.g.,
CVE-2018-17968 6).

• Weakness: “a software error or mistake in contract code
that in the right conditions can by itself or coupled with
other weaknesses lead to a vulnerability”. (EIP 1470).

4https://eips.ethereum.org/
5https://nvd.nist.gov/vuln/detail/CVE-2018-13783
6https://nvd.nist.gov/vuln/detail/CVE-2018-17968

2

What distinguishes smart contract code weaknesses from
other software applications is that any smart contract code in-
struction costs a speciﬁc amount of gas (see Section-2.4). This
means even if the weakness was not exploited, it would result
in losing Ether 7 when it is triggered by the contract itself and
executed, which makes the contract vulnerable even if it is not
exploited. Thus, it is of high importance to study smart con-
tracts’ weaknesses along with smart contracts’ vulnerabilities.

2.2. Ethereum Virtual Machine (EVM)

it

Ethereum8 is a globally open decentralized blockchain
framework that supports smart contracts,
referred to as
Ethereum Virtual Machine (EVM). Because EVM hosts and
is often referred to as the
executes smart contracts,
programmable blockchain.
EVM contracts reside on the
blockchain in a Turing complete bytecode language; however,
they are implemented by developers using high-level languages
such as Solidity or Vyper and then compiled to bytecode to be
uploaded to the EVM. Users on the EVM can create new con-
tracts, invoke methods in a contract, and transfer Ether. All
of the transactions on EVM are recorded publicly and their se-
quence determines the state of each contract and the balance
of each user. In order to ensure the correct execution of smart
contracts, EVM relies on a large network of mutually untrusted
peers (miners) to process the transactions. EVM also uses
the Proof-of-Work (PoW) consensus protocol to ensure that a
trustworthy third party (e.g., banks) is not needed to validate
transactions, fostering trust among users to build a dependable
transaction ledger. EVM gained remarkable popularity among
blockchain users as EVM is the ﬁrst framework that supports
smart contracts to manage digital assets and build decentralized
applications (DApps) (Khan and Namin, 2020a).

2.3. Ethereum Smart Contracts

A smart contract is a general-purpose digital program that
can be deployed and executed on the blockchain. Ethereum
smart contract is identiﬁed by a unique 160-bit hexadecimal
string which is the contract address. It is written in a high-level
language, either Solidity or Vyper. In this paper, we focus on
Ethereum smart contracts written in Solidity because it is the
most popular language in the EVM community and most of the
deployed contracts on EVM are written using Solidity (Bhat
and Vijayal, 2017; Badawi and Jourdan, 2020). A smart con-
tract can call other accounts, as well as other contracts on the
EVM. For example, it can call a function in another contract
In EVM, internal transac-
and send Ether to a user account.
tions (i.e., calls from within a smart contract) do not create new
transactions and are therefore not directly recorded on-chain.

2.4. Ethereum Gas System

In order to execute a smart contract, a user has to send a trans-
action (i.e., make a function call) to the target contract and pay
a transaction fee that is measured in units of gas, referred to as

the gas usage of a transaction. The transaction fee is derived
from the contract’s computational cost, i.e., the type and the
number of executed instructions during runtime. Each executed
instruction in the contract consumes an agreed-upon amount
Instructions that need more computational resources
of gas.
cost more gas than instructions that need less computational re-
sources. This helps secure the system against denial-of-service
attacks and prevents ﬂooding the network. Hence, the gas sys-
tem in EVM has two main beneﬁts: (1) it motivates develop-
ers to implement eﬃcient applications and smart contracts and
(2) it compensates miners who are validating transactions and
executing the needed operations for their contributed comput-
ing resources. To pay for gas, the transaction fee equals the
gasprice ∗ gascost. The minimum unit of gas price is Wei (1
Ether = 1018 Wei). Therefore, Ether can be thought of as the
fuel for operating Ethereum.

2.5. Solidity

Solidity9 is a domain-speciﬁc language (DSL) that is used to
implement smart contracts on the Ethereum blockchain. It is the
most widely used open-source programming language in imple-
menting blockchain and smart contracts. Also, although it was
originally designed to be used on Ethereum, it can be used in
other blockchain platforms such as Hyperledger and Monax10.
Solidity is statically typed, which requires specifying the type
of all variables in the contract.
It does not support any “un-
deﬁned” or “null” values, and any newly deﬁned variable has
a default value based on its type. Smart contracts written in
Solidity are organized in terms of subcontracts, interfaces, and
libraries. They may contain state variables, functions, function
modiﬁers, events, struct types, and enum types. Also, Solid-
ity contracts can inherit from other contracts, and can call other
contracts.

In Solidity there are two kinds of function calls.

Internal
function calls, which do not create an actual EVM call, and
External function calls, which do. Due to this distinction, So-
lidity supports four types of visibility for functions and state
variables:

• External functions can be called from other contracts us-
ing transactions as they are part of the contract interface.
They can not be called internally (e.g., externalFunction()
does not work, while this.externalFunction() works). State
variables can not be external.

• Public functions can be called internally or using messages
and they are part of the contract interface. For public state
variables, an automatic getter function is generated by the
Solidity compiler to avoid high gas cost when returning an
entire array.

• Internal functions and state variables can only be accessed
internally (i.e., from within the current contract or con-
tracts deriving from it).

7Ethereum corresponding cryptocurrency
8https://ethereum.org/en/

9https://docs.soliditylang.org/
10https://monax.io/

3

• Private functions and state variables are only visible for
the contract they are deﬁned in and not in derived con-
tracts.

State variables can be declared using the keywords constant
or immutable. Immutable variables can be assigned at construc-
tion time, while constant variables must be ﬁxed at compile
time. For the functions declaration, they can be declared as
follows.

• Pure Functions promise not to read or modify the state.
They can use the revert() and require() functions to revert
potential state changes when an error occurs.

• View Functions promise not to modify the state such as

writing to state variables.

• Receive Ether Functions can exist at most once in a con-
tract. They cannot have any arguments and cannot re-
turn any value, and must be declared with external visi-
bility and payable state mutability as in receive() external
payable{ ...}. These functions are executed on plain Ether
transfers (e.g., using .send() or .transfer()) and based on a
call to the contract with empty calldata.

• Fallback Functions are similar to Receive Ether functions,
It
as any contract can have at most one such function.
must have external visibility, and is executed on a call to
the contract if none of the other functions match the given
function signature or if no data was supplied at all and
there is no receive function. The fallback function always
receives data, but in order to also receive Ether it must be
marked as payable.

Finally, if any function promises to receive Ether, it has to be
declared as payable. An example of a Solidity contract is shown
in Figure 1. It shows a voting contract as explained in Solidity’s
oﬃcial documentation (Ethereum, 2021).

2.6. Common Vulnerability and Exposure (CVE) and Na-

tional Vulnerability Database (NVD)

CVE is a list of publicly disclosed vulnerabilities and expo-
sures that is maintained by MITRE11. It feeds into the NVD12,
so both are synchronized at all times. NVD is a comprehensive
repository with information about all publicly known software
vulnerabilities and includes all public sources of vulnerabilities
(e.g., alerts from security focus13). NVD also provides more in-
formation about the CVE lists’ vulnerabilities, such as severity
scores and patch availability. It also provides an easy mecha-
nism to search for vulnerabilities using various variables. Both
CVE and NVD are maintained by the US Federal Government.
An example of a reported smart contract vulnerability in NVD
is shown in Table 1. It also shows the impact metrics (Com-
mon Vulnerability Scoring System - CVSS), vulnerability types

11https://cve.mitre.org/cve/
12http://nvd.nist.gov/
13https://www.securityfocus.com/

Figure 1: Voting Contract Example Written in Solidity (Ethereum, 2021)

(Common Weakness Enumeration - CWE), applicability state-
ments (Common Platform Enumeration - CPE), and other rele-
vant meta-data. Each CVE in the list also has a unique identiﬁer
that shows the aﬀected software product, sub-products, and var-
ious versions.

2.7. Common Weakness Enumeration (CWE)

CWE 15 is a community-developed list of common software
security weaknesses. It is considered as a comprehensive on-
line dictionary of weaknesses that have been found in computer
software. It also serves as a baseline for weakness identiﬁca-
tion, mitigation, and prevention eﬀorts. Its primary purpose is
to promote the eﬀective use of tools to identify, ﬁnd, and repair
vulnerabilities and exposures in computer software before the
programs are distributed to the public.

15http://cwe.mitre.org

4

Table 1: An example of a vulnerability in NVD

CVE ID
NVD Published Date:
Source:
Description

CVSS
Weakness Enumeration
CWE Name
Hyperlink
Integrity
Impact score

CVE-2021-3006
01/03/2021
CVE MITRE
The breed function in the
smart contract implementation
for Farm in Seal Finance
an Ethereum token,
(Seal),
lacks access control and thus
allows price manipulation, as
exploited in the wild in Decem-
ber 2020 and January 2021.
7.5
CWE-863
Incorrect Authorization
Link14
High
3.6

2.8. Smart Contract Weakness Classiﬁcation Registry (SWC)

SWC is an implementation of the weakness classiﬁcation
scheme that is proposed in Ethereum Improvement Proposals16.
It is also aligned with the terms and structures described in the
CWE. Each SWC has an identiﬁer (ID), weakness title, CWE
parent, and related code samples list.

3. Related Work

Multiple studies that classify smart contract vulnerabilities
have been published since the ﬁrst attack on Ethereum smart
contracts in 2016 (Daian, 2016), e.g., Atzei et al. (2016), Al-
harby et al. (2018), Dingman et al. (2019), and Zhang et al.
(2020). This section summarizes these studies in relation to our
work.

3.1. Literature-Based Vulnerability Classiﬁcation

Several studies on Ethereum smart contract vulnerabili-
ties classify vulnerabilities reported in blogs, academic litera-
ture, and white papers, i.e., Atzei et al. (2016); Alharby and
Van Moorsel (2017); Huang et al. (2019); S´anchez (2018);
Chen et al. (2020a); Praitheeshan et al. (2019); Dingman et al.
(2019).

Atzei et al. (2016) propose a classiﬁcation scheme com-
prised of three categories to classify security vulnerabilities in
Ethereum smart contracts. In addition to blogs and academic
literature, the authors also employ their own practical experi-
ence as a resource for their classiﬁcation. Vulnerabilities are
classiﬁed into language-related issues, blockchain issues, and
EVM bytecode issues. The classiﬁcation is followed by a brief
discussion on potential attacks that result in stealing money or
causing other damage.

Alharby and Van Moorsel (2017) also use academic litera-
ture as the main source of data, classifying them into four main
classes: codifying, security, privacy, and performance issues.
Additionally, they discuss proposed solutions based on sugges-
tions provided by smart contract analysis tools. The proposed
classiﬁcation suﬀers from a signiﬁcant overlap between cate-
gories. For example, codifying issues can lead to security and
privacy issues, as in the case of the popular re-entrancy vulner-
ability (classiﬁed as a security issue in the paper).

Huang et al. (2019) report a literature review of smart con-
tract security from a software lifecycle perspective. The authors
analyze blockchain features that may result in security issues in
smart contracts and summarize popular smart contracts’ vulner-
abilities based on four development phases, i.e., design, imple-
mentation, testing before deployment, and monitoring and anal-
ysis. Finally, they classiﬁed 10 vulnerabilities into three broad
categories (i.e., Solidity, blockchain and misunderstanding of
common practices). Unfortunately, there is no explanation of
how or on what basis these categories were designed.

Dingman et al. (2019) study well-known vulnerabilities re-
ported in white and gray literature and classify them accord-
ing to National Institute of Standards and Technologies Bugs
framework (NIST-BF)17 into security, functional, developmen-
tal, and operational vulnerabilities. The results show that the
majority of vulnerabilities fall outside the scope of any cate-
gory. However, the categories and the classiﬁcation process are
not deﬁned or described in the paper.

Similar to Dingman et al. (2019), Samreen and Alalﬁ (2021)
survey and map eight popular smart contracts’ vulnerabilities in
the literature to the NIST-BF. Their results show that only three
of the studied eight vulnerabilities could be matched with two
NIST-BF classes. They also suggest a preventive technique per
classiﬁed vulnerability. Finally, a map between existing analy-
sis tools and the eight vulnerabilities are provided in the paper.

Praitheeshan et al. (2019) classify 16 smart contracts’ vul-
nerabilities reported in literature based on their internal mecha-
nisms. The authors use three categories, i.e., blockchain, soft-
ware security issues, and Ethereum and Solidity vulnerabilities.

Finally, Chen et al. (2020a) survey Ethereum System Vul-
nerabilities including smart contract vulnerabilities reported in
literature, classifying them according to two dimensions. First,
they group vulnerabilities into four-layer groups according to
the location, i.e., on the application, data, consensus or net-
work layer. Secondly, they group vulnerabilities according to
their cause into Ethereum design and implementation, smart
contract programming, Solidity language and tool-chain, and
human factors. This classiﬁcation focuses on few locations that
a vulnerability might occur at, while omitting others. For in-
stance, the vulnerability could be located in the source code
of the smart contract itself or in its dependencies. Furthermore,
there is no clear indication of how these categories were deﬁned
or if a systematic way to classify them was followed.

16https://eips.ethereum.org/

17https://samate.nist.gov/BF/

5

3.2. Repository-Based Vulnerability Classiﬁcation

In addition to classiﬁcations that are based on published vul-
nerabilities, two papers attempt classiﬁcations based on data
extracted from public repositories such as StackExchange, i.e.,
Chen et al. (2020b); Zhang et al. (2020).

Chen et al. (2020b) collect smart contract vulnerabilities
from discussions available on Ethereum StackExchange, clas-
sifying them based on ﬁve high-level aspects according to their
consequences, i.e., security, availability, performance, main-
tainability, and reusability. To evaluate if the selected vulner-
abilities are harmful, the authors conduct an online survey to
collect feedback from practitioners. The proposed categories
have the drawback that not all vulnerabilities can be clearly
placed in a single category, i.e., one vulnerability could have
various consequences.

Zhang et al. (2020) classify smart contracts vulnerabilities
from both literature and open projects on GitHub. The au-
thors classify extracted vulnerabilities into 9 categories based
on an extension of IEEE Standard Classiﬁcation for Software
Anomalies18. Finally, they propose a four-category classiﬁca-
tion scheme for the impact of a vulnerability, i.e., unwanted
function executed, performance, security, and serviceability.
This classiﬁcation is based on vulnerability GitHub reports, and
some categories are too general to be useful in any detailed en-
gineering analysis (e.g., the security category).

3.3. Tool-Based Vulnerability Detection

As a last category of related work, several publications study
existing tools to detect vulnerabilities in smart contracts, and
propose classiﬁcations based on the tools’ capabilities, i.e.,
Khan and Namin (2020b); Rameder (2021).

Khan and Namin (2020b) provide an overview of current
smart contracts vulnerabilities and testing tools in their work.
In addition, they propose a vulnerability taxonomy for smart
contracts’ vulnerabilities. The proposed taxonomy consists of
seven categories, i.e., inter-contractual vulnerabilities, contrac-
tual vulnerabilities, integer bugs, gas-related issues, transna-
tional vulnerabilities, deprecated vulnerabilities, and random-
ization vulnerabilities. The authors then provide a mapping be-
tween the surveyed vulnerabilities and the available detection
tools. Unfortunately, this categorization is not actually a classi-
ﬁcation scheme, in the sense that it fails to identify a category
unique to each vulnerability and no structured method was pro-
vided to show how the classiﬁcation was performed.

In a Master Thesis, Rameder (2021) provides a comprehen-
sive overview of state-of-the-art tools that analyze Ethereum
smart contracts with an overview of known security vulnera-
bilities and the available classiﬁcation schemes in the litera-
ture. The studied vulnerabilities are classiﬁed into 10 novel
categories, i.e., malicious environment, environment dependen-
cy/blockchain, exception & error handling disorders, denial of
service, gas related issues, authentication, arithmetic bugs, bad
coding quality, environment conﬁguration, and deprecated vul-
nerabilities. However, the proposed categories cover diﬀerent

18https://standards.ieee.org/standard/1044-2009.html

6

dimensions, e.g., vulnerability consequences as well as pro-
gramming errors. Finally, some categories are not deﬁned in
the work.

3.4. Summary and Research Gap

In summary, various attempts to classify smart contract vul-
nerabilities have been published, both on reported vulnerabil-
ities and by mining software repositories. A third line of re-
search focuses on studying smart contract vulnerability detec-
tion tools, classifying what vulnerabilities they are able to de-
tect. These papers suﬀer from three ﬂaws. First, they rely
exclusively on vulnerabilities reported in literature and might,
therefore, provide a skewed image, e.g., Atzei et al. (2016).
Secondly, they propose classiﬁcations that mix diﬀerent con-
cerns or dimensions, such as consequences of exploiting a vul-
nerability and the source of error in Rameder (2021). Third,
they use categories with too broad distinctions that do not al-
low for detailed reasoning, such as the privacy and security cat-
egories in Alharby and Van Moorsel (2017) and Zhang et al.
(2020). Finally, they provide only a limited view on smart con-
tract vulnerabilities due to focusing on a single dimension, such
as the consequences in Chen et al. (2020a). Therefore, there is
a need to unify existing taxonomies and classiﬁcation schemes
and provide a reference taxonomy that includes several dimen-
sions such as root cause, impact, or scope Vacca et al. (2021).
The aim of this paper is to arrive at such a classiﬁcation by in-
tegrating existing work and complementing it with additional
data from software repositories and well-known sources such
as the CVE and SWC registries.

4. Research Method

This section presents the method we followed in this paper,
as shown in Figure 2. It includes the study setup, data sources,
data cleaning, and data analysis.

4.1. Study setup

In this study, we aim to answer the following research ques-

tions (RQs):

• RQ1. What categories of vulnerabilities appear in smart

contracts?

Goal: To comprehensively categorize the vulnerabilities
that appear in Ethereum smart contracts. To study diﬀer-
ent dimensions of the problem and to map literature-based
classiﬁcations on Ethereum smart contract vulnerabilities
and unify them in one thorough classiﬁcation. A thorough
classiﬁcation scheme will make it possible to collect statis-
tics on frequency, trends, and vulnerabilities, as well as
evaluate countermeasures.

• RQ2. Are the frequency distributions of smart contract
vulnerability categories similar across all studied data
sources?

Goal: To investigate if all data sources have the same fre-
quency distributions of vulnerabilities. If so, then we can

Figure 2: Empirical Study Method

rank vulnerability categories from the most common to the
least common. If not, we can reason about the skew or bias
when diﬀerent sources are used. Further research can ﬁnd
solutions for the most common vulnerabilities. More ef-
fort could be put to address the prevalent category before
deploying the contract to the blockchain.

• RQ3. What impact do the diﬀerent categories of smart

contract vulnerabilities and weaknesses have?

Goal: To investigate the impacts of smart contract vulnera-
bility and code weaknesses. To deﬁne various dimensions
of impacts classiﬁcations and to map literature-based im-
pact classiﬁcations and propose a thorough impact classi-
ﬁcation of smart contracts vulnerabilities and code weak-
nesses. More eﬀort can be put to vulnerabilities and code
weaknesses with critical impacts.

4.1.1. Data Sources

To answer the proposed research questions, we analyzed
and studied smart contract code vulnerabilities and weaknesses
from four primary sources. Two of these sources are widely
used by developers (i.e., Github and StackOverﬂow), and two
are very well-known publicly accessible sources (i.e., SWC and
NVD) for reporting vulnerabilities and weakness in Ethereum
smart contracts and other software systems. Table 2 shows
the ﬁnal number of data records during and after data pre-
processing.

Table 2: Summary of the sampled vulnerabilities in the selected data sources

Data Source

# of collected data
# of data records
after preprocess-
ing steps
Final # of Vulner-
abilities

Stack
Overﬂow
2065
1490

GitHub CVE SWC

3160
1160

523
523

37
37

765

818

523

37

Data-source 1: We opted for extracting data from Stack
Overﬂow, as it has successfully been leveraged in existing work
on smart contracts (Ayman et al., 2019, 2020; Chen et al.,
2020b), and in general Software Engineering research (Bajaj
et al., 2014; Ponzanelli et al., 2014; Calefato et al., 2015; Chen
and Xing, 2016; Ahasanuzzaman et al., 2016).

We used Stack Overﬂow posts to study weaknesses and
vulnerabilities in smart contracts. To do so, we extracted
Q&A posts tagged with “smart contract”, “Solidity”, and
“Ethereum”, posted between January 2015 and April 2021. We
discarded posts with the “Ethereum” tag, but without the “So-
lidity” or “smart contract” tags. To retrieve the related informa-
tion for each post, we used Scrapy Scr, an open source Python
library that facilitates Web crawling. For each of the 2065 ex-
tracted posts, we extracted the post title, URL, related tags, post

7

time and accepted answer time.

Figure 3: Vulnerability Example from GitHub

Data-source 2: We used GitHub as the second data source
for our study, as it is the most popular social coding platform
(Cosentino et al., 2017). Moreover, many studies on Ethereum
smart contracts and smart contract analysis tools have been pub-
lished reporting ﬁndings based on data published in GitHub
open-source projects (e.g., Durieux et al. (2020)). We studied
vulnerabilities and code weaknesses reported in open source
projects that have Ethereum smart contracts written in Solid-
ity. We used the keywords “smart contract”, “Solidity”, and
“Ethereum” to search for these projects. Then we searched for
the vulnerabilities and weaknesses based on the ﬁxes in each
project and based on the keywords “Vulnerability”, “bug”, “de-
fect”, “issue”, “problem”, and “weakness”.

We also studied Ethereum oﬃcial GitHub repository. Fig-
ure 3 shows an example of a reported smart contract vulnera-
bility in GitHub.

Data-source 3: We used the NVD search interface to col-
lect and extract all reported CVEs on smart contracts and their
CVSS until April 2021. We searched with “smart contracts”,
“Solidity”, and “Ethereum”. Then, we manually extracted the
reported CVEs that are related to smart contracts.

Data-source 4: We extracted all the reported code weak-
nesses in SWC until April 2021. For each code weakness, we
extracted the ID, title, relationships, and test cases.

4.1.2. Data Cleaning and Pre-Processing

After the initial extraction, we applied several ﬁltering steps
to obtain a clean dataset. First, we removed posts with dupli-
cate titles or marked as [duplicate] in StackOverﬂow. Secondly,
we manually inspected the title and the body of the question
and decided if the post actually discussed smart contracts in
Ethereum/Solidity. Finally, we removed vague, ambiguous, in-
complete, and overly broad posts. As an indication for such
posts, we considered the amount of negative votes and/or nega-
tive feedback. Finally, we extracted the code of the smart con-
tract in each post for further analysis.

In order to pre-process the collected GitHub data, we re-
moved the duplicates based on the description of the vulner-
ability. For further analysis, we also extracted the code of the
smart contract that contained the vulnerability.

8

We also double-checked data collected from both the NVD
database and SWC registry for duplicates. After this stage, we
had a clean dataset with records from the four data sources.

Table 2 shows a summary of the collected dataset after ap-

plying the aforementioned cleaning and pre-processing steps.

4.2. Data Analysis and Classiﬁcation Categories

To analyze and label the cleaned dataset, we manually in-
spected each record and read the description of each vulnerabil-
ity and weakness. Then, to deﬁne the categories of vulnerabili-
ties and weaknesses in smart contracts, two experts (i.e., a soft-
ware engineering expert and a cybersecurity expert) together
used card sorting to propose a classiﬁcation scheme based on
the cleaned data. After that, we discussed each category and
gave it a name based on the categories that were deﬁned by
Beizer (Beizer, 1984). To ﬁnd out root causes of the categories,
we analyzed the question and/or the answer information. Fi-
nally, we followed the same categorization approach to propose
a classiﬁcation scheme for the impact of the recorded vulnera-
bilities and weaknesses.

For each record in the cleaned dataset, we created a card con-
taining the information of the vulnerability as collected from
the original data source. Then, the two experts determined the
category of the vulnerability (RQ1) independently based on its
root cause. As well as the impact category (RQ3) was decided
based on its consequence on the software product (i.e., smart
contracts). When cards did not ﬁt into any of the existing cate-
gories, we extended the schemes accordingly. We started with a
random 10% of the data, and measured inter-rater agreement af-
ter independent labeling using Cohen’s Kappa coeﬃcient. The
Kappa value between the two experts was 0.60, showing mod-
erate agreement (Viera et al., 2005). We then clariﬁed major
disagreements to reach a common decision, and continued with
the remaining 90% of the data. We repeated the clariﬁcation
discussions again after 20% and 40% of the posts were labeled
(with Kappa values of 0.75 and 0.82 respectively). Finally, cal-
culations of the Kappa coeﬃcient at 60%, 80%, and 100% re-
sulted in values of > 0.90, indicating perfect agreement.

The same approach was followed to label the impact of each
vulnerability in the cleaned dataset. The Kappa value was also
> 0.90 in the ﬁnal discussion of the impact labeling.

4.2.1. Classiﬁcation Scheme Attribute-value Design

To design a thorough classiﬁcation scheme for smart con-
tracts’ vulnerabilities, we also followed the structured approach
and recommendations of Seacord and Householder (2005).

To eliminate the problem of having vulnerabilities that ﬁt into
multiple classiﬁcations and therefore invalidate frequency data,
we added attribute-value pairs in our classiﬁcation for each vul-
nerability. This also helped us to provide an overall picture of
the vulnerability.

A smart contract has many attributes such as size, complex-
ity, performance, and other quality attributes. In this paper, we
are only interested in attributes that characterize the overall vul-
nerability of a smart contract. Therefore, these attributes can
also represent code weaknesses (that may or may not lead to

vulnerability, which means the result of executing the vulnera-
bility.

vulnerabilities). All attributes and values that we list in this pa-
per are selected based on engineering diﬀerences of the vulner-
ability sources of error that were concluded from expert discus-
sions while analyzing the data (see Section 4.2). An example
of the proposed attributes-value pairs is shown in Figure 4.

We present a sample contract (i.e., not a real contract)
demonstrating solidity functions with a set of weaknesses and
vulnerabilities. In particular, the contract has multiple vulnera-
bilities, some of which are popular vulnerabilities, such as au-
thorization with tx.origin and reentrancy. In addition, the con-
tract contains another attribute that is an insuﬃcient/ outdated
compiler version, which uses insuﬃcient pragma version 0.x.x.
Another attribute is the use of wrong visibility initialization that
uses wrong state variable initialization.

Figure 5: Dimensions of Smart Contract Vulnerabilities (V-D)

We followed the same approach to devise a thorough classiﬁ-
cation scheme for the impacts of smart contract vulnerabilities.
We deﬁned two dimensions (i.e., impact on the software prod-
uct, and impact on business factors) as shown in Figure 6. We
name these impact dimensions I-D. I-D1 is the impact of the
vulnerability on the software product itself and its resulting be-
havior, whereas I-D2 describes the impact of the vulnerability
on the business level, e.g., losing money or important informa-
tion.

Figure 4: Sample Solidity contract annotated with vulnerability attribute-value
pairs

The attribute-value pairs eliminate the possibility of vulnera-
bilities ﬁtting into multiple classiﬁcations and therefore invali-
dating frequency data Seacord and Householder (2005).

4.3. Unifying Classiﬁcation Schemes

To unify existing vulnerability classiﬁcation schemes in the
literature, we gathered all the categories proposed in the lit-
erature into an Excel sheet. The ﬁrst and the second authors
then discussed each category in relation to the categories pro-
posed by us. We subsequently deﬁned three dimensions of the
problem (i.e., the vulnerability’s source of error; the location
of the vulnerability in the network level; the behavior and con-
sequences arising from an exploit of the vulnerability). After-
wards, we mapped existing classiﬁcations to the deﬁned dimen-
sions, as illustrated in Figure 5. We name these vulnerability
dimensions V-D. The error source dimension (V-D1) describes
the main cause that, when triggered, can result in executing the
vulnerability, such as the logic of the contract and the data ini-
tialization. V-D2 is the network dimension, which indicates at
which layer on the network the vulnerability occurs. Finally,
V-D3 describes the resulting behavior and consequences of the

9

Figure 6: Dimensions of Smart Contract Vulnerability Impacts (I-D)

5. Results

In this section, we present the results of our study, and answer
the proposed RQs. Our objective is to unify the existing classiﬁ-
cation schemes and deﬁne the causes, impacts, and recurrences
of smart contract vulnerabilities and code weaknesses. More-
over, we propose thorough classiﬁcation schemes for both the
impacts and categories of smart contracts’ weaknesses and vul-
nerabilities.

Smart contracts’ code weaknesses and vulnerabilities
are found in more than half (i.e., 66.7%) of the cleaned
data from all the four data sources (Stack Overﬂow,
GitHub, CVE and SWC).

5.1. What categories of vulnerabilities appear in smart con-

tracts? (RQ1)

To answer RQ1, we followed the analysis approach in Sec-
tion 4.2, then mapped the result of our classiﬁcation to other
classiﬁcation schemes as explained in Section 4.3. We classi-
ﬁed the 2143 extracted vulnerabilities and weaknesses into 47
unique smart contract weaknesses and vulnerabilities, grouped
into 11 categories. Within our classiﬁcation scheme, we
mapped the existing literature classiﬁcation schemes.

Table 3 shows a mapping between our categories and
Beizer’s categories (Beizer, 1984). We deﬁne each category
in our proposed classiﬁcation scheme and show its relation to
Beizer’s categories. The categories Interface, Dependency and
upgradability, Authentication & authorization, and Deployment
and conﬁgurations were added to the classiﬁcation based on
discussions throughout the card sorting process, and do not cor-
respond to any category in Beizer’s classiﬁcation.

Table 4 maps literature-based classiﬁcation schemes of smart
contracts vulnerabilities with our own. The categories proposed
in the literature are listed in the rows, while our categories are
listed in the columns of the table. The table covers all the three
dimensions of V-D discussed in Section 4.3. As can be seen,
some broad categories listed in literature essentially cover all
of our classiﬁcation categories.

Most literature-based classiﬁcation schemes for smart
contract vulnerabilities include broad categories, such
as security and availability.

The following subsections present the key ﬁndings related to
the deﬁned categories. For each category, we deﬁne and explain
the most critical vulnerabilities and weaknesses as agreed by
the two raters. We give examples for some vulnerabilities and
weaknesses, which are directly taken from our dataset. For the
full list of vulnerability and code weakness deﬁnitions, we refer
to our published dataset (Majd Soud, 2021).

5.1.1. Language Speciﬁc Coding Vulnerabilities and Weak-

nesses

In this category, smart contracts’ vulnerabilities and weak-
nesses result from language-based errors not captured by the
compiler. The source of error of this category can be in the lan-
guage pre-deﬁned functions, events, libraries, and/or language
standards. Table 5 shows the attribute-value pair for this cate-
gory.

We deﬁne 14 Language Speciﬁc Coding vulnerabilities and
weaknesses that can result in undesirable state in a smart con-
tract or can be used by attackers in their favor. Next, we show a
sample of these vulnerabilities and weaknesses.

Insuﬃcient compiler version or pragma version — CV#1.
A so-called version pragma should be included in the source
code of smart contract to reject compiling the contract using in-
compatible compiler versions. When using a version pragma in
the contract which is later than the selected compiler, this may
introduce incompatible changes and lead to vulnerabilities in
compiled smart contract code. Moreover, future compiler ver-
sions may handle language constructs in a way that introduces

unclear changes aﬀecting the behavior of the contract as shown
in Listing 1.

1 pragma solidity ^0.6.3; // weakness /

vulnerability
2 pragma solidity 0.6.3;

Listing 1: Version pragma

Fallback function not payable — CV#2. Smart contracts
written in Solidity versions 0.6.0+ should have the fallback
function split up into a receive() and a fallback() function (i.e., a
new fallback function that is deﬁned using the fallback keyword
and a receive ether function deﬁned using the receive keyword).
If present, the receive function is called whenever no parame-
ters are provided in the call. The receive function is implicitly
payable. The new fallback function is called when no other
function matches. However, if fallback() is not payable and
receive() does not exist, transactions not matching any other
function which send ether will revert and result in an undesir-
able state in the contract.

Fallback function does not exist — CV#3. In addition to
CV#2, when sending Ether from a contract to another contract
without calling any of the receiving contract’s functions, send-
ing the Ether will fail if the receiver contract has no fallback
function. Thus, a payable fallback function should be added
to the receiver before deployment. Otherwise, there is no way
to receive the Ether unless the sender has previous knowledge
of the exact functions of the receiving contract, which is not
usually the case.

Violating splitting Fallback function — CV#4. Smart con-
tracts written in Solidity versions 0.6.0+ should have the fall-
back function split up to receive() and fallback() (i.e., a new
Fallback function that is deﬁned using the fallback keyword and
a receive ether function deﬁned using the receive keyword). If
present, the receive function is called whenever the call data
is empty. The receive function is implicitly payable. The new
fallback function is called when no other function matches. The
fallback function in Listing 2 can be payable or not, however, if
it is not payable then transactions not matching any other func-
tion which send value will revert.

1 contract payment {
2

mapping ( address = > uint ) _balance ;
fallback () payable external {

_balance [ msg . sender ] += msg . value ;

3

4

}

5
6 }

Listing 2: Fallback function

Violating modiﬁer deﬁnition — CV#5. Solidity provides
modiﬁers that are used to change the behavior of functions
in a declarative way. They can be used to enforce pre/post-
conditions on the execution of a function. The operator should
be used in deﬁning a modiﬁer, and starting from Solidity ver-
sion 0.4.0+ a semicolon should be added after the
operator.
The operator represents the actual code of the function that is
being modiﬁed. Thus, the code for the function being modi-
is placed in the modiﬁer. Missing
ﬁed is inserted where the
the
operator might generate unwanted results. For example,
in Listing 3, line 8, every time transferOwnership is invoked,

10

Table 3: Classiﬁcation Scheme of Vulnerabilities in Smart Contracts

Category Name
Language
Coding

Speciﬁc

Initialization

Data
and Validation

Structural Sequence
& Control

Description
Syntax mistakes in implementing Solidity contracts that are not captured by the Solidity com-
piler can introduce unexpected behavior or damage the contract. Similar to Implementation
in Beizer (1984), but speciﬁc to Solidity.
The input data type to the contract or the ﬁelds’ data type in the contract are not initialized
correctly. Also includes the data passed from/sent to other contracts. Corresponding to Data
deﬁnition and Data access in Beizer (1984).
Predictable resources is a subcategory of data initialization and validation. Weaknesses
and vulnerabilities resulting from using expected values in state variables or functions. These
vulnerabilities can allow malicious minors to take advantage of the vulnerabilities and control
the contract.
Problem with the structure of the contract control ﬂow. Speciﬁcally, a result of incorrect
control ﬂow structure such as require, if-else conditions, assert, and loop structures. Corre-
sponding to Flow control and sequence in Beizer (1984).

Logic

Structural Data Flow Problems with the structure of the contract data ﬂow. The main diﬀerence to Data is that Data
originates in the data ﬁelds and input parameters to the subcontracts or the contract methods.
Instead, in this category, changing data ﬁelds in a wrong way during and after the execution
of the contract leads to issues. Corresponds to Data-ﬂow anomaly in Beizer (1984).
Inconsistency between the intention of the programmer and the coded contract, and not one
of the other categories. Corresponds to Logic in Beizer (1984).
Performance and timing issues that can aﬀect execution time and results in abnormal respon-
siveness under a normal workload. Corresponds to Performance and timing in Beizer (1984),
considering the existence of the Ether/gas concept.
Required software and packages are not compatible with the available resources (e.g., oper-
ating system, CPU architecture). Corresponds to Conﬁguration sensitivity in Beizer (1984)
Weaknesses during deployment of implemented contracts on the Ethereum blockchain.

Timing & Optimiza-
tion

Compatibility

Deployment & Con-
ﬁgurations
Authentication
Authorization
Dependency
Upgradability
Interface

&

&

Vulnerabilities allow malicious actors to take control over the contract.

Upgrades in a smart contract breaking the dependencies in the new contract.

Vulnerabilities and weaknesses in the interface of smart contracts, e.g., when the contract is
functioning correctly, but the interface is showing a wrong output that contradicts the con-
tract’s execution logs and transaction logs.

11

Short
CV

DV

DV-
PR

SV-
SC

SV-
DF

LV

TV

CoV

DL

SV

UV

IB

Table 4: Mapping Literature-based Classiﬁcations to V-D. The rows marked V-D1 refer to the source of error dimension, rows marked V-D2 refer to the network
view dimension, and rows marked V-D3 refer to the resulting behavior and consequences dimension. ⊂* indicates that the category in the V-D classiﬁcation is a
subset of the corresponding category in the literature marked by *. *⊂ means the category in the literature is a subset of a proposed category in V-D. Finally, =
means the categories are identical.

Ours

Literature
Codifying (Alharby and Van Moorsel, 2017)
Data* (Zhang et al., 2020)
Description* (Zhang et al., 2020)
Interaction* (Zhang et al., 2020)
Interface* (Zhang et al., 2020)
Logic* (Zhang et al., 2020)
Standard* (Zhang et al., 2020)
Authentication* (Rameder, 2021)
Arithmetic* (Rameder, 2021)
Bad Coding Quality* (Rameder, 2021)
Environment Conﬁguration* (Rameder, 2021)
Deprecated* (Rameder, 2021)
Solidity* (Atzei et al., 2016)
EVM* (Atzei et al., 2016)
Blockchain* (Atzei et al., 2016)
Security* (Alharby and Van Moorsel, 2017)
Privacy* (Alharby and Van Moorsel, 2017)
Performance* (Alharby and Van Moorsel, 2017)
Availability* (Chen et al., 2020b)
Maintainability* (Chen et al., 2020b)
Reusability* (Chen et al., 2020b)

Table 5: Language Speciﬁc Coding Attribute

V-D1

V-D2

V-D3

CV DV SV LV TV CoV DL SV UV IB

⊂*
*⊂
*⊂
*⊂

*⊂

=

*⊂
*⊂

⊂*
⊂*

⊂*
⊂*
⊂*

*⊂

*⊂

⊂*

*⊂

=

=

=

=

=

⊂*

⊂* ⊂*

⊂*

⊂*

⊂*

⊂*

⊂*

=
⊂*

⊂*
⊂*

⊂*

⊂*

⊂* ⊂*
⊂*

⊂* ⊂*
⊂* ⊂*
⊂* ⊂*

⊂*

⊂*

⊂*
⊂*

⊂*
⊂*

⊂*

⊂*

⊂*

⊂*

⊂*

⊂*

⊂*

⊂*
⊂*

⊂*

⊂*

Attribute
Language
speciﬁc
coding

Values
pragma version, fallback function, pre-
deﬁned functions in the language,
lan-
guage standards,
language deﬁned li-
braries, syntax issues (not detectable by the
compiler), style guide and recommended
language patterns, experimental language
features, deprecated code, unsafe language
features.

the onlyOwner modiﬁer will get into play ﬁrst. If the owner
invokes it, then the control ﬂow will reach the operator, so the
transferOwnership statements will be executed. Otherwise, the
execution will just throw, revert, and exit.

1 contract owned {
2

address public owner ;
function owned () {

3

4

5

6

7

8

9

owner = msg . sender ;}

modifier onlyOwner {

if ( msg . sender != owner ) throw ;
_ ;

}

function tr an s f er Own ersh ip ( address newOwner )

onlyOwner {
owner = newOwner ; }}

Listing 3: Violating modiﬁer deﬁnition

Manipulated language standard — CV#6 Ethereum has
adopted many standards to guarantee the composability of
smart contracts and Dapps. Those standards are in Ethereum’s
oﬃcial EIPs and include token 19 standards. For example, ERC-
20 is a token technical standard that allows developers to imple-
ment tokens of cryptocurrencies. It contains nine unique func-
tions and two events to guarantee the possibility of exchanging
tokens based on ERC-20 with other ERC-20 tokens. Any mod-
iﬁcation on the function name, parameter types, and the return
value in the standard might change its functionality and leave
the developer believing it is the same as ERC-20. The imple-
mentation of ERC-20 in any contract shall strictly be the same
as in the standard template.

Violating call-stack depth limit — CV#7. In Ethereum, the
call-stack has a hard limit of 1024 frames. Each time the con-
tract calls an external contract, the call-stack depth of transac-
tion increases by one. Thus, when the number of calls exceeds
the limit of the call-stack, an exception is thrown and the call
is aborted by Solidity. Moreover, Solidity does not support ex-
ceptions in low-level external calls. Therefore, a malicious ac-
tor can recursively call a contract 1023 times, then call a victim
contract to reach the call-stack depth limit. This will fail any
subsequent call made by the victim contract without the victim

19An Ethereum token can represent anything, including lottery tickets, ﬁnan-

cial assets, a ﬁat currency like USD, an ounce of gold, etc.

12

contract owner being aware of the attack. Recently, EIP 15020
makes it impossible to reach stack depths of 1024, eﬀectively
eliminating call depth attacks

Insuﬃcient Address split — CV#8. Starting from Solid-
ity 0.5.0+, the address should be split to address and address
payable, where only address payable provides the transfer func-
tion. Otherwise, sending tokens to “unpayable” addresses will
be reverted. Moreover, there is no way to convert an address to
address payable.

Mixing pure and view — CV#9. In Solidity, pure and view
are function modiﬁers that describe how the logic in that func-
tion will interact with the contract’s state. Functions that are
declared view promise not to modify the state, while functions
that are declared pure promise not to read or write the state.By
using no speciﬁer, the state can be read as well as modiﬁed.
Developers can mix these two modiﬁers by replacing view with
pure or missing any of these modiﬁers, resulting in unexpected
state changes or incorrect reads from the state .

Using of balance as attribute to the contract — CV#10
One of the features of Solidity is that contracts inherit all mem-
bers from Address, meaning that the keyword this is the pointer
to the current instance of the type derived from Address.
In
other words, if the developer wants to access members of the
address type (e.g. the balance) of the current contract instance,
then the developer should use this and should use balance as
an attribute of the address type, not the contract as shown in
Listing 4. We noticed a confusion in using balance and other
address attributes as if they are attributes of the contract.

uint , uint , uint , uint , address

1 function getSummary () public view returns (
2
3 ) {
4

return (

minimumContribution ,

this . balance , // incorrect

address ( this ) . balance ,// correct
requests . length ,
approversCount ,
manager

5

6

7

8

9

10

11
12 }

) ;

Listing 4: Using of balance as attribute to the contract

Unsafe delegatecall (code injection)— CV#11 A special
variant of a message call in Solidity is delegatecall. With this
feature, the contract can be executed in the callee’s context,
while msg.sender and msg.value remain unchanged. Conse-
quently, it allows an external contract to modify the storage of
the calling contract. This can be exploited by a malicious caller
to manipulate the caller’s contract state variables and take full
control over the balance.

Variable shadowing — CV#12 Solidity supports ambigu-
ous naming when inheritance is used. For instance, contract Al-
pha with a variable V could inherit contract Beta that also has
a state variable V deﬁned. Consequently, there would be two
versions of V, one accessed from contract Alpha and the other
from contract Beta. In complex contract systems, this condition

20https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md

might go undetected and ultimately cause security issues. Also,
this can also occur at the contract level (e.g., a contract with
more than one deﬁnition at the contract and function level).

Deprecated Solidity code — CV#13 As Solidity evolves,
several of its functions and operators are deprecated. Making
use of them leads to poor code quality. It is strongly discour-
aged to use deprecated Solidity language code with new major
versions of the Solidity compiler, since it can cause unwanted
behavior and vulnerabilities.

Experimental Language Features — CV#14 Similar to CV
#13, it is strongly discouraged to use experimental Solidity lan-
guage features since it can cause undesired behavior and code
weaknesses.

5.1.2. Data Vulnerabilities and Weaknesses

Most of the data vulnerabilities result from the use of wrong
or insuﬃcient data types, or passing wrong data formats to ar-
guments without knowing the exact required type. Moreover,
organizing the memory and storage in Solidity is the responsi-
bility of programmers, which many developers are not used to
do. Table 6 shows the attribute-value pairs for this category.

Table 6: Data vulnerabilities and weaknesses Attribute

Attribute
Data vulner-
abilities
and
weaknesses

Values
Insuﬃcient/wrong data type, wrong ad-
dresses initialization, writing on arbitrary
insuﬃcient memory and stor-
locations,
improper data valida-
age management,
tion, improper state variable initialization,
data pointer initialization, function pointer
initialization.

Violating explicit data location — DV#1. For Solidity ver-
sions 0.5.0+, an explicit data location for all variables of type
struct, array, or mapping is mandatory. This also applies to
function parameters and return variables. For instance, calldata
is a special data location that contains the function arguments,
which is only available for external function call parameters. If
calldata is not included in the initialization, it results in unex-
pected values as shown in Listing 5.

1 contract StructExample {
2

3

4

5

6

7

8

9

10

11

12

struct SomeStruct {
int someNumber ;
string someString ;

}
SomeStruct [] someStructs ;

function addSomeStruct () {

SomeStruct storage someStruct = SomeStruct
(123 , " test " ) ;// insufficient use
SomeStruct memory someStruct = SomeStruct
(123 , " test " ) ;// correct
someStructs . push ( someStruct ) ;

}

13
14 }

13

Listing 5: Using of torage instead of memory

Using of storage instead of memory — DV#2. In addition
to calldata, Solidity provides two more reference types to com-
prise structs, arrays, and mappings called storage and memory.
The Solidity contract can use any amount of memory (based
on the amount of Ether that the contract owns and can pay for)
during execution. However, when execution stops, the entire
content of the memory is wiped, and the next execution will
start fresh. The storage is persisted into the blockchain itself,
so the next time the contract executes, it has access to all the
data it previously stored in its storage area. Confusing storage
and memory can result in data loss.

Violating array indexing — DV#3. Developers are making
numerous mistakes when initializing and accessing arrays in
Solidity. Most of the time, discovering these violations is not
easy, especially if there is no syntax error or an error that can be
detected by the compiler. This can result in returning incorrect
values. A clear violation of array indexing is shown in Listing 6,
line 9, where the developer is trying to access a single element
in a 3-dimensional array, but only provides two sets of square
brackets. Therefore, the developer is returning an array instead
of a single Object.

1 contract Game {
2

struct User {

address owner ; }

3
4 User [][10][10] public gameBoard ;
5 User memory mover = gameBoard [ _fromX ][ _fromY ][0];
6

function addUser ( uint _x , uint _y ) public {
gameBoard [ _x ][ _y ]. push ( User ( msg . sender ,

10 , 5 , 5 , 5 , 5) ) ;}

function moveUser ( uint _fromX , uint

_fromY ) public {

User memory mover = gameBoard [ _fromX ][

_fromY ]; // incorrect access

if ( mover . owner != msg . sender ) return ;}}

Listing 6: Violating arrays indexing

7

8

9

10

Hard-coded address — DV#4 An existing bad practice is
the use of hard-coded addresses in smart contract code, as
shown in Listing 7. Any incorrect or missing digit in the ad-
dress may result in losing Ether, in case Ether is sent to that
wrong address, or in unexpected outcomes. This vulnerabil-
ity is also known as “Transfer to orphan address” Atzei et al.
(2016).

1 address reci everaddress ;
2 function i n i t i al iz e Ad dr e ss 1 () {
3

recie ve r ad dress = 0 x98081c ...8 e5ace ; //

hardcoded address }

5.1.3. Predictable Data Values and Resources

We encountered several issues in Solidity smart contracts that
relate to values that can be guessed even though they are in-
tended to serve as an element of randomness.

Timestamp dependency — DV-PR# 7 To keep contracts
safe from malicious actors, developers should avoid using
the block variables as a source of randomness or as part of
triggering conditions for executing signiﬁcant operations in
their contracts, such as transferring Ether. When submitting
blocks, miners determine the value of block variables such as
block.timestamp, block.coinbase, and block.diﬃculty. Thus,
these values can aﬀect the contract’s outcome and can be used
to beneﬁt the attacker. For example, Listing 8 shows an insecure
lottery contract in which block.timestamp is used as a source of
entropy.

1 function setWinner () public {
2

3

4

5

6

7

8

bytes32 hash = keccak256 ( abi . encode ( block .

timestamp ) ) ;

bytes4 [2] memory x0 = [ bytes4 (0) , 0];
assembly {

mstore ( x0 , hash )
mstore ( add ( x0 , 4) , hash )

}

Listing 8: Insecure lottery contract using block variables

Blockhash dependency — DV-PR# 8 Using blockhash has
the same risks as block.timestamp in DV-PR #7, especially
when used in critical operations such as Ether transfer. It can
lead to serious attacks as malicious miners can tamper with the
blockhash and take full control over the contract.

Bad random number generation— DV-PR# 9 Using ran-
dom numbers is not avoidable in some smart contracts, e.g.,
games or lotteries. It is important that the randomness is not
based on global blockchain variables, as that leaves the contract
open to manipulation by malicious miners similar to DV-PR#7
and DV-PR#8.

5.1.4. Sequence and Control Vulnerabilities and Weaknesses

This category of vulnerabilities is corresponding to incorrect
control structure and loop control statements. These can be ex-
ploited and help the attacker to steal money in the contract.
Moreover, they can also result in losing all the money in the
contract without even being attacked, just because of vulner-
abilities in these structures. Table 7 shows the attribute-value
pairs for this category.

Listing 7: Hardcoded address

Table 7: Sequence and control vulnerabilities and weaknesses

Improper data validation — DV#5 It is necessary to validate
input from untrusted sources, such as external libraries or con-
tracts before integrating it into any contract logic.

Unintentional Write to arbitrary storage location —
DV#6 Because Solidity storage is not dynamically allocated,
it can lead to unpredictable behavior, unauthorized data access,
and other vulnerabilities, especially if the data location of data
types like structs, mappings, and arrays is not clariﬁed and al-
lowed to overwrite entries of other data structures.

Attribute
Sequence and
control

Values
Wrong use of assert, wrong use of require.

Using assert instead of require — SV-SC#1. The assert
statement should be only used for conditions that indicate you
have an internal vulnerability in the contract code. The require
statement should be used to check valid conditions (e.g., state
variables conditions are met, validate input, and validate return

14

value from external contracts). A valid code with correct func-
tions should never fail assert conditions. Otherwise, there is
a vulnerability in the contract and something unexpected has
happened. In smart contracts, assert can consume all the gas
in the contract as shown in Listing 9. If the example is tested
with run(8), the function runs successfully and 1860 gas will
be consumed based on the cost of the function and the loop it-
erations21. If it is tested with run(15), then the function passes
assert, fails at require and the ﬁrst loop only will be executed
and consume 1049 gas. Finally, testing the same example with
run(25) causes the function to fail the assert statement. The ex-
ecution continues and thus iterates 25 times through the loop,
resulting in a very high cost of gas.

1 contract Test {
2

function run ( uint8 i ) public pure {

4

3

4

5

6

7

8

9

10

}

uint8 total = 0;
for ( uint8 j = 0; j < 10; j ++)

total += j ;
assert ( i < 20) ;
require ( i < 10) ;
for ( j = 0; j < 10; j ++)

total += j ;

Listing 9: Using assert instead of require

5.1.5. Data Flow Vulnerabilities and Weaknesses

These are vulnerabilities and weaknesses in the data ﬂow of
smart contracts, so that data ﬁelds are changing unexpectedly
or incorrectly. We deﬁned two vulnerabilities that belong to
this category. Table 8 shows the attribute-value pairs for this
category.

Table 8: Data ﬂow vulnerabilities and weaknesses

Attribute
Data ﬂow

Values
Unexpected integer overﬂow/underﬂow,
unexpected conversion in data values, un-
expected arithmetic operation behavior

Updating storage in fallback functions— SV-DF#1. Upon
receiving Ether without a function being called, either the re-
ceive Ether or the fallback function is executed. If the contract
does neither have a receive nor a fallback function, the Ether
will be rejected by throwing an exception. During the execu-
tion of one of these functions, the contract can only rely on the
passed gas (i.e., 2300 gas) being available to it at that time. This
stipend is not enough to modify storage. However, we found
that developers sometimes are updating state variables, trying
to write to the storage in the fallback functions. Updating the
variables with such a gas limit will fail. If the data ﬂow of the
contract depends on the failed state variables, this results in an
incorrect data ﬂow and in unexpected outcomes.

Arithmetic operation/calculation overﬂow/ underﬂow —
SV-DF#2. An overﬂow can happen as a result of an arithmetic

21The actual gas costs are stated in the Solidity documentation and depend

on numerous factors, such as the executed functions and the used data types.

operation or calculation that falls outside the range of a Solidity
data type, resulting in unwanted behavior or unauthorized ma-
nipulation of the contract balance. Underﬂow happens when an
arithmetic operation reaches the minimum size of a type. This
is a data ﬂow vulnerability, as the code of the contract does not
perform correct validation on the numeric inputs and the cal-
culations. In addition, the Solidity compiler does not enforce
detecting integer overﬂow/underﬂow. An example is shown in
Listing 10, where the computation of mask overﬂows at x >=
248.

1 uint256 public MAXUINT256 = 2*256 - 1;
2 for ( uint256 x = 0; x < 255; x ++) {
3

var mask = MAXUINT256 * (2 ** x ) ;
var key = signature & bytes32 ( mask ) ;}

Listing 10: Arithmetic Operation/calculation overﬂow

5.1.6. Logic Vulnerabilities and Weaknesses

This category reﬂects inconsistencies with the contract and
the programmer’s intention, which is usually mentioned in the
question information. These issues relate to a number of rea-
sons, e.g., vague developer intentions, misunderstanding of lan-
guage components, incorrect usage of Math, and incorrect gas
predictions.

Greedy contract— LV#1. This vulnerability occurs when
implementing a contract logic that is only locking Ether bal-
ance all the time because of its inability to access the external li-
brary contract to transfer Ether. For instance, the contract logic
may only accept transferring money based on a speciﬁc value
in the code, which happens to be unreachable due to incorrect
In this case, the Ether will be locked in the deployed
logic.
contract forever.
In the example of Listing 11, the function
refundMoney(), line 8, does not decrease the weiRaised value,
meaning that once starting a refund, the developer can no longer
use forwardAllRaisedFunds() to drain the contract. This code
weakness would be triggered even in the regular course of ac-
tion and Ether in this contract is stuck. It can receive any funds
but the received funds can never be retrieved.

3

4

1 contract SwordCrowdsale is Ownable {
2

// amount of raised money in wei
uint256 public weiRaised ;
bool public isSoftCapHit = false ;
// send ether to the fund collection wallet

5
6 function f o r w a r d A l l R a i s e d F u n d s () internal {
7
8 function refundMoney ( address _address ) onlyOwner

wallet . transfer ( weiRaised ) ;}

public {
uint amount = contributorLis t [ _address ].
c on t r i bu t io n A m ou n t ;
if ( amount > 0 && _address . send ( amount ) ) {
// user got money back
contr ib utorLi st [ _address ]. co n t r ib u t i o nA mo u nt
=
contr ib utorLi st [ _address ]. tokensIssued =
}

0;

0;}

Listing 11: Greedy Contract

Transaction order dependency — LV#2 The vulnerability
arises when a contract’s logic is dependent on the order in which
transactions are executed and processed in a block. It is a type

9

10

11

12

13

14

15

of race condition inherent to Blockchains. By manipulating the
order of transaction processing, malicious miners can take ad-
vantage of the contract and beneﬁt from it. Therefore, the logic
of the contract should not rely on the transaction order.

Call to the unknown — LV#3 This vulnerability arises
when a function unexpectedly invokes the fallback function of
the recipient. Consequently, malicious code can be introduced.
For example, the unknown call could trigger the recipient’s fall-
back function, allowing malicious code to execute.Also, this
can be done via direct call, delegatcall, send, or only call func-
tions. In the MultiSig Wallet Attack22, an attacker exploited this
vulnerability to steal 30M USD from the Parity Wallet. Another
example is shown in Listing 12. In which, pong function uses
a direct call to invoke Alice’s ping. However, if the interface
of contract Alice by mistake was mistyped by declaring the pa-
rameter as int instead of unit and Alice has no function with
int type, then the call to ping results in calling Alice’s fallback
function.

1 contract Alice { function ping ( uint ) returns ( uint

) }

2 contract Bob { function pong ( Alice c ) { c . ping (42)

;}}

Listing 12: Call to the unknown Atzei et al. (2016)

DoS by external contract — LV#4 It is possible for external
calls to fail and throw exceptions or revert the transaction. Inef-
ﬁcient management of these calls in the contract logic can lead
to critical vulnerabilities, such as a Denial of Service (DoS) or
loss of funds.

5.1.7. Timing and Optimization Vulnerabilities and Weak-

nesses

Performance and timing vulnerabilities/weaknesses in smart
contracts usually aﬀect the gas amount in the contracts. In the
following, we deﬁne 2 vulnerabilities belonging to this cate-
gory.

Unbounded loops — TO#1. In Solidity, iterating through
a potentially unbounded array of items can be costly, as ex-
empliﬁed in getNotes() in Listing 13. Since the array notes is
provided as an input, the smart contract has no control over the
maximum length, allowing a malicious actor to send in large
arrays.

Creating subcontracts cost — TO#2. Contract deploy-
ments are very expensive operations. For instance, deploying
a contract for every patient in Listing 13 is very costly. A mali-
cious developer can use this weakness to cost the owner of the
contract more Ether.

1 contract MedicalRecord {
2 struct Doctor {
3

bytes32 name ;
uint id ;}
4
5 struct Note {
6

bytes32 title ;
bytes32 note ;}

7
8 function getNotes ()

22https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-

405a8c12e8f7/

16

9

10

11

12
13 {
14

15

16

17

18

19

20

21

view
public
isCur re ntDoct or
returns ( bytes32 [] , bytes32 [])

bytes32 [] memory titles = new bytes32 []( notes
. length ) ;
bytes32 [] memory noteTexts = new bytes32 [](
notes . length ) ;
for ( uint i = 0; i < notes . length ; i ++) {

Note storage snote = notes [ i ];
titles [ i ] = snote . title ;
noteTexts [ i ] = snote . note ;

}
return ( titles , noteTexts ) ;}

Listing 13: Unbounded loops and creating subcontracts

Costly state variable data type — TO#3 Because of the
padding rules, the byte[] data type consumes more gas than a
In addition, declaring variables without constant
byte array.
consumes more gas than one declared with a constant. This
weakness is also reported in Chen et al. (2020b).

Costly function type — TO#4 A function declared public
rather than external and not utilized within the contract con-
sumes more gas on deployment than it should.This weakness is
also reported in Chen et al. (2020b).

5.1.8. Compatibility Vulnerabilities and Weaknesses

This category is related to vulnerabilities that prevent
Ethereum from running normally on the developer machine.
We ﬁnd that the main root causes of this category are: (1) devel-
opers are not using the latest binaries/releases and (2) the hard-
ware that is in use does not meet the minimum requirements.
As this category played only a minor role in the analyzed posts,
we did not label the posts in detail, but decided to keep this for
future work.

5.1.9. Deployment and Conﬁgurations

This category of vulnerabilities and weaknesses is caused by

wrong conﬁgurations and weaknesses in deployment.

Improper conﬁguration — DL#1 Wrong or improper con-
ﬁguration of the smart contract application tool-chain can result
in weaknesses, errors, or vulnerabilities, which applies even if
the contract itself is free of vulnerabilities.

Violating contract size limit — DL#2. In Ethereum, limits
are imposed by the gas consumed for the transaction. While
there is no exact size limit there is a block gas limit and the
amount of gas provided has to be within that limit. When de-
ploying a contract, there are three factors to consider: (1) an
intrinsic gas cost, (2) the cost of the constructor execution, and
(3) the cost of storing the bytecode. The intrinsic gas cost is
static, but the other two are not. The more gas consumed in the
constructor, the less is available for storage. Normally, the vast
majority of gas consumed is based on the size of the contract. If
the contract size is large, the consumed gas can get close to the
block gas size limits, preventing the deployment of the contract.

5.1.10. Authorization and Authentication

The following vulnerabilities and weaknesses directly aﬀect
the security of a smart contract and could enable attacks/ex-

Table 9: Authentication & authorization vulnerabilities and weaknesses At-
tribute

Values
unauthorized function call, wrong permis-
sions, lack of access control, signature is-
sues.

Attribute
Authentication
& authoriza-
vulner-
tion
abilities
and
weaknesses

ploits.

Lack of access control management — SV#1. Access con-
trol is an essential element to the security of a smart contract.
Based on the privileges of each client/contractor party, there
have to be strict rules implemented in the contract that enforce
access control.

For example, the contract in Listing 14 is trying to provide
functionality to whitelist addresses. The original function in
line 10 does not have any access restrictions, meaning any caller
can whitelist addresses. The modiﬁed version in line 15 only
allows the contract owner to do so.

1 contract WHITELIST {
2

address owner ; // set during the first call
modifier isOwner () {

require ( msg . sender == owner ) ;
_ ;

}
// insecure
function e n ab leWhitelist ( address address ) {

// Whitelist an address

}
// secure
function e n ab leWhitelist ( address address )
external isOwner {

// Whitelist an address

3

4

5

6

7

8

9

10

11

12

13

}

14
15 }

Listing 14: Lack of access control management

Authorization via tx.origin — SV#2 tx.origin is a global
variable in Solidity which returns the address of the account
that sent the transaction. Rather than returning the immediate
caller, tx.origin returns the address of the original sender (i.e.,
the ﬁrst sender who initiated the transaction chain). It can make
the contract vulnerable, if an authorized account calls into a
malicious contract. Therefore, a call could be made to the vul-
nerable contract that passes the authorization check as tx.origin
returns the original sender of the transaction, which in this case
is the authorized account.

Signature based vulnerabilities — SV#3 These vulnerabil-
ities are introduced as a result of insuﬃcient signature infor-
mation or weaknesses in signature generation and veriﬁcation.
Those include but not limited to:

(cid:4) Lack of proper signature veriﬁcation: One example can
be relying on msg.sender for authentication and assuming
that if a message is signed by the sender address, then it
has also been generated by the sender address. Particu-
larly in scenarios where proxies can be used to relay trans-

actions, this can lead to vulnerabilities. For more informa-
tion, we refer to SWC-12223

(cid:4) Missing Protection against Signature Replay Attacks: To
protect against Signature Replay Attacks, a secure im-
plementation should keep track of all processed message
hashes and only allows new message hashes to be pro-
cessed. Without such control, it would be possible for a
malicious actor to attack a contract and receive message
hashes that were sent by another user multiple times. For
more information, we refer to SWC-12124

(cid:4) Signature Malleability: The implementation of a crypto-
graphic signature system in Ethereum contracts often as-
sumes that the signature is unique, but signatures can be
altered without the possession of the private key and still
be valid. Valid signatures could be created by a malicious
user to replay previously signed messages. For more in-
formation, we refer to SWC-11725

5.1.11. Dependency and Upgradability Vulnerabilities and

Weaknesses

Dependencies of and upgrades to smart contracts can lead to
a number of issues in smart contracts. We describe one of these
weaknesses/vulnerabilities below.

Insecure contract upgrading — UV#1. There are two ways
to upgrade a contract. First, to use a registry contract that keeps
track of the updated contracts, and second, to split the contract
into a logic contract and a proxy contract so that the logic con-
tract is upgradable while the proxy contract is the same. Both
approaches allow untrusted developers to introduce dependency
vulnerabilities in the updated contract’s logic, allowing attack-
ers to modify the logic of the upgraded contract using its de-
pendencies, e.g. another contract. This vulnerability was also
reported in Atzei et al. (2017) and Chen et al. (2020a).

5.1.12. Interface Vulnerabilities and Weaknesses

This category describes weaknesses resulting in incorrect
display of results. However, in these cases the smart contracts
actually worked and produced the expected outcomes. The
weaknesses were instead found in other applications that dis-
played the results. As these applications are not part of the
smart contract, and there was no apparent code weakness in the
contracts, we did not further investigate these kind of weak-
nesses.

5.2. Are the frequency distributions of vulnerabilities similar

across all studied data sources? (RQ2)

To answer RQ2, we analyzed the frequency distributions of
the deﬁned eleven vulnerability categories across the four data
sources (i.e., Stack Overﬂow GitHub, CVE, and SWC). The
frequency distribution of the deﬁned categories is shown in Fig-
ure 7 for each data source.

23https://swcregistry.io/docs/SWC-122
24https://swcregistry.io/docs/SWC-121
25https://swcregistry.io/docs/SWC-117

17

e
g
a
t
n
e
c
r
e
P

30

25

20

15

10

5

0

e
g
a
t
n
e
c
r
e
P

20

15

10

5

0

e
g
a
t
n
e
c
r
e
P

100

80

60

40

20

0

e
g
a
t
n
e
c
r
e
P

30

20

10

0

V
o
C

V
C

L
D

V
D

B

I

V
L

V
S

F
D
V
S

-

C
S
-
V
S

V
T

V
U

V
o
C

V
C

L
D

V
D

B

I

V
L

V
S

F
D
V
S

-

C
S
-
V
S

V
T

V
U

V
o
C

V
C

L
D

V
D

B

I

V
L

V
S

F
D
V
S

-

C
S
-
V
S

V
T

V
U

V
o
C

V
C

L
D

V
D

B

I

V
L

V
S

F
D
V
S

-

C
S
-
V
S

V
T

V
U

(a) Stack Overﬂow

(b) GitHub

(c) CVE

(d) SWC

Figure 7: Distribution of SC vulnerability categories for each of the studied data sources.

The resulting frequency distribution shows that the Lan-
guage speciﬁc coding category and the Structural data
ﬂow category are the most common vulnerability cate-
gories in Ethereum smart contracts

The language speciﬁc coding category is dominant on both
Stack Overﬂow and GitHub. In contrast, structural data ﬂow
vulnerabilities are most frequent on CVE and SWC. Addition-
ally, almost 80% of the reported structural data ﬂow vulnerabil-
ities in the NVD database (CVEs) are integer overﬂow/ under-
ﬂow vulnerabilities. Interestingly, issues on StackOverﬂow and
GitHub appear to have similar frequency distributions. How-
ever, these are not statistically signiﬁcant.

5.3. What impact do the diﬀerent categories of smart contract

vulnerabilities and weaknesses have? (RQ3)

In this section, we present the main impacts of vulnerabili-
ties and bugs in smart contracts, thus answering RQ3. We unify
all the proposed impact categories in the literature (i.e., (Chen
et al., 2020b; Zhang et al., 2020)), and present a thorough clas-
siﬁcation scheme of vulnerability impacts on Ethereum smart
contracts. We followed a similar approach to what we did in
RQ1. The deﬁnitions of the ﬁnal impact categories are depicted
in Table 10 and Table 11. Furthermore, Table 12 shows how
the impact categories in literature related to our classiﬁcation.
Note that IP5 (in the second-last row) does not relate to any
of our categories, as the category describes smart contracts that
function as intended, something that we did not include in our
classiﬁcation.

Our mapping shows that the impact of smart contract
vulnerabilities and code weaknesses on certain aspects
has not been examined in detail. For instance, the im-
pact on the development process and the productivity
of a software development team. Additional research
in this area can quantify the extent to which the vul-
nerabilities impact smart contract development, the de-
veloping team, and the development of decentralized
applications based on smart contracts.

The analysis of the impacts of vulnerabilities and code weak-
nesses in smart contracts shows that unexpected stop is the most

18

Table 10: Classiﬁcation Scheme of Impacts (I-D1)

Impact
Unexpected be-
havior
Unwanted
functionality
Long response
time

Data Corrup-
tion

dis-

perfor-

Memory
closure
Poor
mance
Unexpected
stop

Description
Contract behaves abnormally, e.g.,
generating incorrect output.
Contract executes wrong function-
ality because of wrong logic.
Long runtime of a smart contract
to any input without providing the
desired output.
Data becomes unreadable, unus-
able or inaccessible, and unex-
pected output is generated.
Problems in the memory storage
of the smart contract.
Non-optimal
terms of gas and time.
Unexpected exit and execution
stop at the point of triggering the
vulnerability in the code.

resource usage in

Table 11: Classiﬁcation Scheme of Impacts (I-D2)

Impact
Information
disclosure

Lost Ether or
assets

Locked Ether

control
the

Lost
over
contract

Description
When a code weakness or vulner-
ability is exploited, sensitive infor-
mation is exposed to an actor not
explicitly authorized to see it.
An exploited code weakness can
lead to unauthorized actors taking
over the Ether of the contract and
losing it.
In the situation of triggering code
weaknesses in a contract, one can
lose access to the contract and lock
the Ether in it without having access
to it again.
By exploiting code weaknesses or
vulnerabilities, an unauthorized ac-
tor can take over the contract.

App.
UB

UF

LRT

DC

MF

PPC

USP

App.
ID

LEA

LE

LC

Table 12: Mapping literature-based Impact classiﬁcations to I-D. D1: refers to the Impact on software product. Note: IP2 belongs to D1 and D2. ⊂* indicates the
corresponding category in our own classiﬁcation is a subset of the corresponding category in the literature marked by *. *⊂ means the category in the literature is a
subset of our proposed category.

I-D1

Ours

Literature
Functionality*. (Zhang et al., 2020)
Performance* (Zhang et al., 2020)
Security (Zhang et al., 2020)
Serviceability *(Chen et al., 2020b)
IP1 unwanted behaviors* (Chen et al., 2020b)
IP3 non-exploitable UB* (Chen et al., 2020b)
IP4 Errors outside program call (Chen et al., 2020b)
IP5 No errors* (Chen et al., 2020b)
IP2 UB without losses* (Chen et al., 2020b)

UB UF LRT DC MF

PPC USP ID LEA LE LC

=

⊂*
⊂*

* ⊂

⊂*
⊂*
=
*⊂

*⊂

⊂* ⊂*
⊂* ⊂*

⊂*
⊂*

=
⊂*
⊂*

⊂*
⊂*

⊂*

⊂*

⊂*

⊂*

*⊂

It
prevalent impact category among all proposed categories.
is caused primarily by vulnerabilities in the Language Speciﬁc
Coding category. The second most prevalent impact category
is unexpected functionality. This mostly happens in smart con-
tracts when the transferred gas amount does not match the ex-
pected amount expected from the logic of the code, or when
incorrect amounts of Ether are transferred.

6. Discussion

In the following, we discuss our ﬁndings in terms of implica-

tions and relation to existing work.

We ﬁnd a substantial number of vulnerabilities and weak-
nesses being discussed in social coding platforms and existing
vulnerability repositories. This clearly shows that this is an im-
portant topic to study and analyze. Because of the unique char-
acteristics of smart contracts, e.g., immutability and gas con-
sumption, it is important to make sure that vulnerabilities and
code weaknesses with severe impacts are ﬁxed or even detected
before deploying the contract to the blockchain.

As demonstrated in our ﬁndings, existing classiﬁcations ei-
ther focus on a single dimension of smart contract vulnerabil-
ities, such as the error source, or mix multiple dimensions in
a single classiﬁcation. Our mapping uniﬁes these diﬀerent di-
mensions to some extent and shows how diﬀerent classiﬁcation
schemes relate.

In addition to mixing dimensions, the majority of existing
classiﬁcation schemes for smart contract vulnerabilities include
broad categories, such as security and availability, to which
many vulnerabilities can be assigned. As such, these categories
do not support reasoning about the included vulnerabilities,
which is an important quality criterion for classiﬁcations Ralph
(2018). Furthermore, broad categories might prevent orthogo-
nality of the categories, i.e., that a single vulnerability ﬁts into
a single category only. In the example mentioned above, i.e.,
security and availability, many vulnerabilities can lead to nega-
tive eﬀects on both, and thus could be labeled both. Due to the
use of attribute-value pairs Seacord and Householder (2005),
we believe that our uniﬁed classiﬁcation avoids this issue.

The frequency distributions discussed in Section 5.2 show
notable diﬀerences between the frequencies of found vulner-
abilities across diﬀerent data sources. This, once again, high-
lights that focusing on a single source biases the resulting study.
It further demonstrates that established databases such as CVE
and SWC do not reﬂect well the topics discussed in public cod-
ing platforms such as Stack Overﬂow or GitHub. On the lat-
ter platforms, we observe speciﬁcally that developers seem to
have a poor understanding of pre-deﬁned functions such as view
and pure, and that it is hard for them to cope with continuous
changes and updates in Solidity and its documentation. On the
one hand, this ﬁnding suggests that tools for veriﬁcation and
analysis of smart contracts is of high importance, especially fo-
cusing on the prevalent vulnerability categories in our classiﬁ-
cation. On the other hand, the observed frequencies might only
be a symptom of the technology maturity. Hence, these issues
might become less prevalent once Solidity matures and updates
become less frequent.

Based on our ﬁndings, we can provide a number of recom-
mendations to researchers and practitioners in order to improve
smart contract development.

First, available static detection tools must urgently target the
deﬁned categories of vulnerabilities and code weaknesses. Our
breakdown of the frequencies at which the diﬀerent categories
occur can help prioritizing this development to target the most
important categories ﬁrst. Second, there is a need to deﬁne cod-
ing best practices of smart contracts and make them available
to developers. Coding guidelines are available for many pro-
gramming languages and technologies, and can help improving
quality and reducing code weaknesses and unexpected gas con-
sumption. Based on the analyzed data from social coding plat-
forms, we believe that this list can include, e.g., avoiding mul-
tidimensional arrays, or arrays in general, if possible; carefully
checking gas consumption amounts; recomming speciﬁc safe
libraries such as SafeMath Saf to avoid common pitfalls such
as underﬂows; and avoiding substantial sub-contract creation.
Finally, we see a need for action from the Solidity team, in par-
ticular when it comes to clearly documenting existing libraries
and code weaknesses they can resolve, as well as clearly deﬁn-
ing gas requirements for patterns, functions, declaration types,

19

creating subcontracts, upgrading contracts, and other language
artifacts and operations. Such documentation could substan-
tially contribute to a reduction in smart contract vulnerabilities
and weaknesses in Solidity/Ethereum.

7. Threats to Validity

In the following, we discuss threats to the validity of our ﬁnd-
ings according to internal and external validity, as well as relia-
bility.

7.1. Internal Validity

Card sorting was used as the main method to categorize and
label the posts in this work. This method is subjective and open
to bias, hence two experts veriﬁed the manual labeling twice
independently in order to mitigate this threat. In case of any
disagreement, the two experts would discuss it until reaching to
a consensus.

An additional threat to internal validity lies in the keyword
search employed during data collection. For instance, to collect
Q&A posts from Stack-Overﬂow, we used the tags “Smart con-
tract”, “Ethereum”, and “Solidity”, while for GitHub we used
“smart contract”, “Solidity”, and “Ethereum”. Also, a part of
the collected data with insuﬃcient information or with informa-
tion that is not related to smart contract vulnerabilities and code
weaknesses written in Solidity were excluded from the analy-
sis. This search and ﬁltering process might have led to exclude
relevant data that could have led to further insights.

As trustworthiness of the collected posts can be a source of
noise in the data, we removed negative voted questions from
the dataset. This might have resulted in a systematic under-
representation of certain types of vulnerabilities/bugs. Given
the maturity of Solidity, we deemed this step warranted to allow
for data of suﬃciently high quality.

7.2. External Validity

A threat to external validity is the continuous updates of
Ethereum using the hard fork. More improvements are being
added to Ethereum with each hard fork such as the EIPs 26 that
ensures the energy eﬃciency of the proof-of-work. Further-
more, many new features are added to Solidity newer versions.
Therefore, new contract vulnerabilities and bugs may be intro-
duced and some others may be resolved. This means that our
classiﬁcation might not generalize to newer (or older) versions
of Solidity.

Focusing on Solidity and the Ethereum blockchain only
limits the external validity of the results, as there are other
blockchains and other smart contract languages that could have
yielded further or diﬀerent vulnerabilities/bugs. We focus on
Ethereum since it is the second-largest blockchain, and the
largest blockchain that supports smart contracts (written in So-
lidity). However, additional studies into other technologies
could be a valuable addition to our ﬁndings, and our results
might not generalize to other blockchains or smart contract lan-
guages.

26https://github.com/ethereum/EIP

7.3. Reliability

To ensure reliability of the results, we described in detail the
data collection and analysis process. We systematically cal-
culated inter-rater reliability coeﬃcients in iterative rounds, to
ensure suﬃciently clear categories and agreement among two
expert raters. Finally, we published the full dataset Majd Soud
(2021). Overall, these steps should ensure reliability and enable
replication of our study.

8. Conclusion

Due to the immaturity of blockchain technology, vulnerabili-
ties in smart contracts can have severe consequences and result
in substantial ﬁnancial losses. Hence, it is essential to under-
stand vulnerabilities and code weaknesses of smart contracts.
However, there exist several shortcomings in existing classiﬁ-
cations, i.e., they focus on single dimensions, mix dimensions,
propose too broad categories, or rely on single data source omit-
ting important sources for vulnerabilities. To address this gap,
we extracted smart contract vulnerabilities written in Solidity
from a number of important data sources, classiﬁed them in
terms of error source and impact, and related them to existing
classiﬁcations in literature. Our ﬁndings show that language-
speciﬁc coding and structural data ﬂow are the dominant cat-
egories of vulnerabilities in Solidity smart contracts. We also
ﬁnd that many vulnerabilities and code weaknesses are similar
to known issues in general purpose programming languages,
such as integer overﬂow and erroneous memory management.
However, the immaturity and rapid evolution of the technology
and the Solidity language, and the added concept of gas further-
more adds vulnerabilities and code weaknesses, and increases
the risk of attacks and ﬁnancial losses. Interestingly, we ﬁnd
that the frequency at which the diﬀerent categories occur dif-
fers widely across data sources, indicating that they should not
be viewed in isolation.

Our classiﬁcation scheme is a further step to standardize and
unify vulnerability analysis in smart contracts. This can support
researchers in building tools and methods to avoid, detect, and
ﬁx smart contract vulnerabilities in the future.

Speciﬁcally, we see a number of directions for future re-
search. First, future studies should investigate whether our
classiﬁcation scheme can be generalized by investigating other
smart contracts in other blockchain networks, e.g., Hyper-
ledger, Stellar, and Openchain. Potentially, our classiﬁcation
needs to be modiﬁed to ﬁt into other networks or languages.
Similarly, the classiﬁcation might have to be adapted as Solidity
evolves and as new languages are developed for Ethereum smart
contracts. Second, more dimensions and characteristics of the
studied vulnerabilities and code weaknesses can be explored
in the future. For instance, patterns among the extracted vul-
nerabilities and code weaknesses could be abstracted, as well
as the evolution over time. For each of the categories, code
metrics and detection tools can be explored. Finally, it should
be investigated in which ways the deﬁned vulnerabilities and
code weaknesses can be exploited, as well as what the impact
of these exploits will be. This can be accomplished by develop-
ing automated scripts or manually devising such exploits.

20

Ethereum. Solidity by example, 2021. URL https://docs.soliditylang.

org/en/latest/solidity-by-example.html.

T. Hewa, M. Ylianttila, and M. Liyanage. Survey on blockchain based smart
contracts: Applications, opportunities and challenges. Journal of Network
and Computer Applications, page 102857, 2020.

Y. Huang, Y. Bian, R. Li, J. L. Zhao, and P. Shi. Smart contract security: A
software lifecycle perspective. IEEE Access, 7:150184–150202, 2019.
Z. A. Khan and A. S. Namin. Ethereum smart contracts: Vulnerabilities and
their classiﬁcations. In 2020 IEEE International Conference on Big Data
(Big Data), pages 1–10. IEEE, 2020a.

Z. A. Khan and A. S. Namin. A survey on vulnerabilities of ethereum smart

contracts. arXiv preprint arXiv:2012.14481, 2020b.

M. H. Majd Soud, Grischa Liebel. Dataset: A ﬂy in the ointment: An em-
pirical study on the characteristics of ethereum smart contracts code weak-
nesses and vulnerabilities, Jan. 2021. URL https://doi.org/10.5281/
zenodo.6388179.

M. I. Mehar, C. L. Shier, A. Giambattista, E. Gong, G. Fletcher, R. Sanayhie,
H. M. Kim, and M. Laskowski. Understanding a revolutionary and ﬂawed
grand experiment in blockchain: the dao attack. Journal of Cases on Infor-
mation Technology (JCIT), 21(1):19–32, 2019.

D. Perez and B. Livshits. Smart contract vulnerabilities: Vulnerable does not

imply exploited. arXiv preprint arXiv:1902.06710, 2019.

L. Ponzanelli, G. Bavota, M. Di Penta, R. Oliveto, and M. Lanza. Mining
stackoverﬂow to turn the ide into a self-conﬁdent programming prompter.
In Proceedings of the 11th Working Conference on Mining Software Repos-
itories, pages 102–111, 2014.

P. Praitheeshan, L. Pan, J. Yu, J. Liu, and R. Doss. Security analysis meth-
ods on ethereum smart contract vulnerabilities: a survey. arXiv preprint
arXiv:1908.08605, 2019.

P. Ralph. Toward methodological guidelines for process theories and tax-
onomies in software engineering. IEEE Transactions on Software Engineer-
ing, 45(7):712–735, 2018.

H. Rameder. Systematic review of ethereum smart contract security vulnerabil-

ities, analysis methods and tools. PhD thesis, Wien, 2021.

N. F. Samreen and M. H. Alalﬁ. A survey of security vulnerabilities in ethereum

smart contracts. arXiv preprint arXiv:2105.06974, 2021.

D. C. S´anchez. Raziel: Private and veriﬁable smart contracts on blockchains.

arXiv preprint arXiv:1807.09484, 2018.

R. C. Seacord and A. D. Householder. A structured approach to classifying
security vulnerabilities. Technical report, Carnegie-mellon university pitts-
burgh pa software engineering inst, 2005.

A. Vacca, A. Di Sorbo, C. A. Visaggio, and G. Canfora. A systematic literature
review of blockchain and smart contract development: Techniques, tools,
and open challenges. Journal of Systems and Software, 174:110891, 2021.
A. J. Viera, J. M. Garrett, et al. Understanding interobserver agreement: the

kappa statistic. Fam med, 37(5):360–363, 2005.

P. Zhang, F. Xiao, and X. Luo. A framework and dataset for bugs in ethereum
smart contracts. In 2020 IEEE International Conference on Software Main-
tenance and Evolution (ICSME), pages 139–150. IEEE, 2020.

Z. Zheng, S. Xie, H.-N. Dai, W. Chen, X. Chen, J. Weng, and M. Imran. An
overview on smart contracts: Challenges, advances and platforms. Future
Generation Computer Systems, 105:475–491, 2020.

Acknowledgment

The authors would like to thank Mohammad Alsarhan, a se-
curity expert, for participating in the card sorting and inter-rater
agreement discussions. This work was supported by the Ice-
landic Research Fund (Rann´ıs) grant number 207156-051.

References

Ethereum improvement proposals (eips). https://github.com/ethereum/

EIPs/issues/1469. [Online] Accessed: 01-April-2020.

Safemath.

https://github.com/OpenZeppelin/

openzeppelin-solidity/blob/master/contracts/math/
SafeMath.sol. [Online] Accessed: 01-June-2020.

A fast and powerful scraping and web crawling framework. https://scrapy.

org. [Online] Accessed: 01-June-2020.

M. Ahasanuzzaman, M. Asaduzzaman, C. K. Roy, and K. A. Schneider. Mining
In 2016 IEEE/ACM 13th Working
duplicate questions of stack overﬂow.
Conference on Mining Software Repositories (MSR), pages 402–412. IEEE,
2016.

M. Alharby and A. Van Moorsel. Blockchain-based smart contracts: A system-

atic mapping study. arXiv preprint arXiv:1710.06372, 2017.

M. Alharby, A. Aldweesh, and A. van Moorsel. Blockchain-based smart con-
tracts: A systematic mapping study of academic research (2018). In 2018
International Conference on Cloud Computing, Big Data and Blockchain
(ICCBB), pages 1–6. IEEE, 2018.

N. Atzei, M. Bartoletti, and T. Cimoli. A survey of attacks on ethereum smart

contracts. IACR Cryptol. ePrint Arch., 2016:1007, 2016.

N. Atzei, M. Bartoletti, and T. Cimoli. A survey of attacks on ethereum smart
In International conference on principles of security and

contracts (sok).
trust, pages 164–186. Springer, 2017.

A. Ayman, A. Aziz, A. Alipour, and A. Laszka. Smart contract development in
practice: Trends, issues, and discussions on stack overﬂow. arXiv preprint
arXiv:1905.08833, 2019.

A. Ayman, S. Roy, A. Alipour, and A. Laszka. Smart contract development
from the perspective of developers: Topics and issues discussed on social
media. pages 405–422, 2020.

E. Badawi and G.-V. Jourdan. Cryptocurrencies emerging threats and defensive

mechanisms: A systematic literature review. IEEE Access, 2020.

K. Bajaj, K. Pattabiraman, and A. Mesbah. Mining questions asked by web
developers. In Proceedings of the 11th Working Conference on Mining Soft-
ware Repositories, pages 112–121, 2014.

B. Beizer. Software system testing and quality assurance. Van Nostrand Rein-

hold Co., 1984.

M. Bhat and S. Vijayal. A probabilistic analysis on crypto-currencies based on
blockchain. In 2017 International Conference on Next Generation Comput-
ing and Information Systems (ICNGCIS), pages 69–74. IEEE, 2017.

F. Calefato, F. Lanubile, M. C. Marasciulo, and N. Novielli. Mining successful
answers in stack overﬂow. In 2015 IEEE/ACM 12th Working Conference on
Mining Software Repositories, pages 430–433. IEEE, 2015.

C. Chen and Z. Xing. Mining technology landscape from stack overﬂow. In
Proceedings of the 10th ACM/IEEE International Symposium on Empirical
Software Engineering and Measurement, pages 1–10, 2016.

H. Chen, M. Pendleton, L. Njilla, and S. Xu. A survey on ethereum systems
security: Vulnerabilities, attacks, and defenses. ACM Computing Surveys
(CSUR), 53(3):1–43, 2020a.

J. Chen, X. Xia, D. Lo, J. Grundy, X. Luo, and T. Chen. Deﬁning smart contract
defects on ethereum. IEEE Transactions on Software Engineering, 2020b.
V. Cosentino, J. L. C. Izquierdo, and J. Cabot. A systematic mapping study of

software development with github. IEEE Access, 5:7173–7192, 2017.

P. Daian. Analysis of the dao exploit. Hacking, Distributed, 6, 2016.
W. Dingman, A. Cohen, N. Ferrara, A. Lynch, P. Jasinski, P. E. Black, and
L. Deng. Defects and vulnerabilities in smart contracts, a classiﬁcation us-
ing the nist bugs framework. International Journal of Networked and Dis-
tributed Computing, 7(3):121–132, 2019.

T. Durieux, J. F. Ferreira, R. Abreu, and P. Cruz. Empirical review of automated
analysis tools on 47,587 ethereum smart contracts. In Proceedings of the
ACM/IEEE 42nd International Conference on Software Engineering, pages
530–541, 2020.

21

