2
2
0
2

l
u
J

5
1

]

Y
S
.
s
s
e
e
[

1
v
6
4
3
7
0
.
7
0
2
2
:
v
i
X
r
a

STRIKE-GOLDD 4.0: user-friendly, eﬃcient analysis of
structural identiﬁability and observability

Sandra Díaz-Seoane1, Xabier Rey Barreiro1, Alejandro F. Villaverde1,2
1 Universidade de Vigo, Department of Systems Engineering & Control, 36310 Vigo, Galicia, Spain

2 CITMAga, 15782 Santiago de Compostela, Galicia, Spain

July 18, 2022

Abstract
Structural identiﬁability and observability are desirable properties of systems biology models.
Many software toolboxes have been developed for their analysis in the last decades. STRIKE-
GOLDD is a generally applicable tool that can analyse non-linear, non-rational ODE models
with unknown inputs. However, this generality comes at the expense of a lower computational
eﬃciency than other tools. Here we present STRIKE-GOLDD 4.0, which includes a new algo-
rithm, ProbObsTest, speciﬁcally designed for the analysis of rational models. ProbObsTest is
signiﬁcantly faster than the FISPO algorithm – which was already available in older versions
of the toolbox – when applied to computationally expensive models. An important feature of
both algorithms is their ability to analyse models with unknown inputs. Thus, their coexis-
tence in the same toolbox provides a combination of general applicability and computational
eﬃciency. STRIKE-GOLDD 4.0 is implemented as a free and open-source Matlab toolbox
with a user-friendly graphical interface. It is available under a GPLv3 license and it can be
downloaded from GitHub at https://github.com/afvillaverde/strike-goldd.
Contact: afvillaverde@uvigo.gal

1

Introduction

A model is structurally identiﬁable (respectively, observable) if it is theoretically possible to de-
termine its parameters (respectively, state variables) by observations of its output. Structural
identiﬁability and observability (SIO) are properties of dynamic models that are especially
important in biological modelling due to the usual experimental limitations [32]. Hence, in
the last two decades many specialized software tools have been developed for their analysis.
Structural identiﬁability can be tested locally or globally. Tools for analysing global and local
identiﬁability include DAISY [2], COMBOS [17], GenSSI [11], SIAN [8], and StructuralIden-
tiﬁability [6]. Tools that only analyse local identiﬁability include EAR [10], ObservabilityTest
[21], STRIKE-GOLDD [28], and ORC-DF [22]. A critical comparison of their strengths and
weaknesses can be found in [20].

Most local identiﬁability tools implement some version of a probabilistic algorithm pre-
sented by [21], which is computationally fast but can only be applied to rational models. In
contrast, STRIKE-GOLDD implements an algorithm that is usually less eﬃcient, but allows
analysing nonrational models. This versatility is the main strength of STRIKE-GOLDD, which
can also analyse models with unknown inputs, search for model symmetries, and ﬁnd identi-
ﬁable reparameterizations. A timeline of these developments is shown in Fig. 1.A. However,
STRIKE-GOLDD’s generality comes at the expense of higher computation times for rational
models than other toolboxes tailored to that problem class.

To address this issue, here we present STRIKE-GOLDD 4.0, which introduces two new fea-
tures. First, it implements ProbObsTest, an extension of the algorithm by [21] for the analysis
of rational models, for which it can achieve considerable speed-ups over FISPO. ProbObsTest
can analyse models with unknown inputs, and it includes a procedure for rewriting certain
non-rational models in rational form. As a second main feature, STRIKE-GOLDD 4.0 is
implemented as a Matlab toolbox with a user-friendly graphical interface.

2 Methods

STRIKE-GOLDD 4.0 follows a diﬀerential geometry approach [24] to the analysis of structural
properties of systems of nonlinear ordinary diﬀerential equations (ODE). It analyses the struc-

1

 
 
 
 
 
 
Figure 1: (A) Timeline of the main releases of STRIKE-GOLDD. Each version provides an inte-
grated solution with signiﬁcantly new features with respect to the previous one: version 2 allowed
for an in-depth analysis of the role of inputs, including time-varying and unknown inputs; ver-
sion 3 allowed searching for the Lie symmetries in the model, and automatically reparameterizing
the model to remove said symmetries; version 4 incorporates an algorithm that yields a faster
analysis of rational models, as well as a new graphical user interface. These new capabilities are
summarized in italics below each main version, along with their publication. (B) Computation
times, in seconds, of the new algorithm (Prob Obs Test) vs FISPO algorithm, for 22 case studies
of increasing computational complexity. The models and their characteristics are detailed in the
Appendix. Circles represent individual computation times, lines are interpolations. (C) Graphical
interface of the Matlab app STRIKE-GOLDD 4.0.

tural local identiﬁability of their parameters, as well as the observability of their states and
unknown inputs. For unidentiﬁable and/or unobservable models it can search for the Lie sym-
metries that underlie those deﬁciencies [16], and automatically suggest reparameterizations to
surmount them [15].

For the ﬁrst task, SIO analysis, STRIKE-GOLDD 4.0 allows choosing among three algo-
rithms. The most generally applicable is called FISPO – Full Input, State, and Parameter
Observability – which can analyse both non-rational models and models with unknown inputs
[29, 31]. The FISPO algorithm tests an extended version of the observability rank condition
(ORC) [7] that includes unknown inputs as additional states. The ORC test computes an
observability matrix from symbolic operations that involve Lie derivatives and calculates its
rank. If the rank equals the total number of variables, the model has the FISPO property.
The analysis of rational models that are aﬃne in the inputs can also be performed with a
second algorithm, ORC-DF [14], which was originally developed by [13].

STRIKE-GOLDD 4.0 includes a third algorithm, ProbObsTest, which implements an ex-
tension of the algorithm presented in [21] for analysing rational models. This algorithm reduces
the computational cost of the ORC test by avoiding the need for symbolic computations of
Lie derivatives to build the observability matrix. Instead, it computes a power series expan-
sion whose coeﬃcients are the terms of the observability matrix; since the model variables are
specialised on random integer values, the resulting computations as well as the calculation of
the rank can be performed numerically. The details of the methodology are provided in the
Appendix.

3 Features and results

The new algorithm, ProbObsTest, presents two main developments with respect to the algo-
rithm on which it is based, which enlarge the class of models that it can analyse. On the one
hand, it has been extended so that it can analyse models with unknown inputs; on the other
hand, it can automatically transform certain nonrational models – such as those with loga-
rithmic and trigonometric functions, or non-integer exponents – into rational models. These
developments are described in the Appendix.

Fig. 1.B. shows a comparison of the computation times of ProbObsTest and FISPO for
the analysis of 22 models of increasing complexity. It can be noticed that for models with a
low computational cost (numbers 1–10, which can be analysed in a few seconds or minutes)
ProObsTest is slightly slower than FISPO. However, for the more computationally expensive
ones (11–22) ProbObsTest is faster, and the diﬀerence is larger as the models become more
Indeed, while FISPO is unable to analyse models 20–22 due to computational
complex.

2

A                                                                                                                     CB2016                2017                2018                2019                2020                2021                2022STRIKE-GOLDD 1STRIKE-GOLDD 2STRIKE-GOLDD 3STRIKE-GOLDD 4Fasterforrationalmodels, graphicalinterfaceSymmetries, reparameterizationTime-varyingand/orunknowninputsTime-varyinginputs(Villaverde et al., 2018)Unknowninputs(Villaverde et al., 2019)ORC-DF, multiexperiment(Martínez and Villaverde, 2020)Lie symmetries(Massonisand Villaverde, 2020)AutoRepar(Massoniset al., 2021)ProbObsTestalgorithm[thispaper]Graphicalinterface[thispaper]SIO analysisof nonlinearmodelsInitialrelease(Villaverde et al., 2016)limitations, ProbObsTest performs the calculations successfully. Notably, number 22 is a
model of Chinese Hamster Overy cells (CHO) with 117 parameters. Details of the case studies
are provided in the Appendix, where we also compare the two algorithms with Sedoglavic’s
ObservabilityTest for those models to which the latter can be applied. Additional comparisons
of ProbObsTest to other methods can be found in [20].

A second new feature of STRIKE-GOLDD 4.0 is its implementation as a Matlab toolbox
with a graphical interface, a screenshot of which is shown in Fig. 1.C. The interface allows
choosing the algorithm from a drop-down menu and specifying its settings; likewise, it is
possible to select one of the models already existing in the folder from a drop-down menu, or
creating a new model from scratch in a new window. This new interface coexists with the
previously existing way of executing the toolbox, which is by running a Matlab script; in this
case one must indicate the settings by editing an options ﬁle. Further details can be found in
the user guide included in the documentation folder of STRIKE-GOLDD 4.0.

4 Conclusion

STRIKE-GOLDD 4.0 is a user-friendly tool providing a quick way of analysing structural local
identiﬁability and observability. It is arguably the most generally applicable toolbox for local
SIO analysis, being able to handle ODE models that may be non-rational and not aﬃne in
the inputs, and which may admit unknown external inputs. Previously, this general purpose
character came at the expense of high computation times for larger rational models. Version
4.0 addresses this issue by providing a faster algorithm for the analysis of such models, along
with the more generally applicable one. The coexistence of both algorithms, as well as the
other features included in the toolbox, provides the user with a convenient multi-purpose tool
for the analysis and reformulation of systems biology models. Its usability is facilitated further
by its implementation as a Matlab app with a user-friendly graphical interface.

Funding

This research has received support from grant PID2020-113992RA-I00 funded by MCIN/AEI/
10.13039/501100011033 (PREDYCTBIO); from grant RYC-2019-027537-I funded by MCIN/AEI/
10.13039/501100011033 and by “ESF Investing in your future”; and from grant ED431F
2021/003 funded by Consellería de Cultura, Educación e Ordenación Universitaria, Xunta
de Galicia.

References

[1] J. Bachmann, A. Raue, M. Schilling, M. E. Böhm, C. Kreutz, D. Kaschek, H. Busch,
N. Gretz, W. D. Lehmann, J. Timmer, et al. Division of labor by dual feedback regulators
controls JAK2/STAT5 signaling over broad ligand range. Mol. Syst. Biol., 7(1):516, 2011.
[2] G. Bellu, M. P. Saccomani, S. Audoly, and L. D’Angiò. DAISY: A new software tool to
test global identiﬁability of biological and physiological systems. Comput. Meth. Prog.
Biomed., 88(1):52–61, 2007.

[3] M. A. Capistrán, M. A. Moreles, and B. Lara. Parameter estimation of some epidemic
models: the case of recurrent epidemics caused by respiratory syncytial virus. Bull. Math.
Biol., 71(8):1890–1901, 2009.

[4] M. N. Chatzis, E. N. Chatzi, and A. W. Smyth. On the observability and identiﬁability of
nonlinear structural and mechanical systems. Struct. Contr. Health Monitor., 22(3):574–
593, 2015.

[5] S. Diop and M. Fliess. Nonlinear observability, identiﬁability, and persistent trajectories.
In Proc. 30th IEEE Conference on Decision and Control, pages 714–719. IEEE, 1991.
[6] R. Dong, C. Goodbrake, H. A. Harrington, and G. Pogudin. Diﬀerential elimination for
dynamical models via projections with applications to structural identiﬁability. arXiv
preprint arXiv:2111.00991, 2021.

[7] R. Hermann and A. Krener. Nonlinear controllability and observability. IEEE Trans.

Autom. Control, 22(5):728–740, 1977.

[8] H. Hong, A. Ovchinnikov, G. Pogudin, and C. Yap. SIAN: software for structural iden-

tiﬁability analysis of ode models. Bioinformatics, 35(16):2873–2874, 2019.

[9] O. Karin, A. Swisa, B. Glaser, Y. Dor, and U. Alon. Dynamical compensation in physi-

ological circuits. Mol. Syst. Biol., 12(11):886, 2016.

3

[10] J. Karlsson, M. Anguelova, and M. Jirstrand. An eﬃcient method for structural identi-
ﬁability analysis of large dynamic systems. IFAC proceedings volumes, 45(16):941–946,
2012.

[11] T. S. Ligon, F. Fröhlich, O. T. Chiş, J. R. Banga, E. Balsa-Canto, and J. Hasenauer.
Genssi 2.0: multi-experiment structural identiﬁability analysis of sbml models. Bioinfor-
matics, 34(8):1421–1423, 2018.

[12] T. Lipniacki, P. Paszek, A. R. Brasier, B. Luxon, and M. Kimmel. Mathematical model

of NF-κB regulatory module. J. Theor. Biol., 228(2):195–215, 2004.

[13] K. Maes, M. Chatzis, and G. Lombaert. Observability of nonlinear systems with unmea-

sured inputs. Mech. Syst. Signal Process., 130:378–394, 2019.

[14] N. Martínez and A. F. Villaverde. Nonlinear observability algorithms with known and

unknown inputs: analysis and implementation. Mathematics, 8(11):1876, 2020.

[15] G. Massonis, J. R. Banga, and A. F. Villaverde. Autorepar: A method to obtain identi-
ﬁable and observable reparameterizations of dynamic models with mechanistic insights.
Int. J. Robust Nonlin. Control, 2021.

[16] G. Massonis and A. F. Villaverde. Finding and breaking lie symmetries: implications for
structural identiﬁability and observability in biological modelling. Symmetry, 12(3):469,
2020.

[17] N. Meshkat, C. E.-z. Kuo, and J. DiStefano III. On ﬁnding and using identiﬁable param-
eter combinations in nonlinear dynamic systems biology models and COMBOS: a novel
web implementation. PLoS One, 9(10):e110261, 2014.

[18] H. Miao, X. Xia, A. S. Perelson, and H. Wu. On identiﬁability of nonlinear ODE models

and applications in viral dynamics. SIAM review, 53(1):3–39, 2011.

[19] A. Raksanyi. Utilisation du calcul formel pour l’étude des systèmes d’équations polyno-

miales (applications en modélisation). PhD thesis, Paris 9, 1986.

[20] X. Rey Barreiro and A. F. Villaverde. Benchmarking tools for a priori identiﬁability

analysis. arXiv preprint, 2022.

[21] A. Sedoglavic. A probabilistic algorithm to test local algebraic observability in polynomial

time. J. Symbol. Comput., 33(5):735–755, 2002.

[22] X. Shi and M. Chatzis. An eﬃcient algorithm to test the observability of rational nonlinear

systems with unmeasured inputs. Mech. Syst. Signal Process., 165:108345, 2022.
[23] E. Tunali and T.-J. Tarn. New results for identiﬁability of nonlinear systems.

IEEE

Trans. Autom. Control, 32(2):146–154, 1987.

[24] M. Vidyasagar. Nonlinear systems analysis. SIAM, 2002.
[25] A. Villaverde and J. R. Banga. Análisis de observabilidad e identiﬁcabilidad estructural
de modelos no lineales: aplicación a la vía de señalización JAK/STAT. In XL Jornadas
de Automática, pages 631–638. Universidade da Coruña, Servizo de Publicacións, 2019.
[26] A. F. Villaverde. Observability and structural identiﬁability of nonlinear biological sys-

tems. Complexity, 2019, 2019.

[27] A. F. Villaverde and J. R. Banga. Dynamical compensation and structural identiﬁability
of biological models: Analysis, implications, and reconciliation. PLoS Comput. Biol.,
13(11), 2017.

[28] A. F. Villaverde, A. Barreiro, and A. Papachristodoulou. Structural identiﬁability of

dynamic systems biology models. PLoS Comput. Biol., 12(10):e1005153, 2016.

[29] A. F. Villaverde, N. D. Evans, M. J. Chappell, and J. R. Banga. Input-dependent struc-
tural identiﬁability of nonlinear systems. IEEE Control Syst. Lett., 3(2):272–277, 2018.
[30] A. F. Villaverde, D. Henriques, K. Smallbone, S. Bongard, J. Schmid, D. Cicin-Sain,
A. Crombach, J. Saez-Rodriguez, K. Mauch, E. Balsa-Canto, et al. Biopredyn-bench: a
suite of benchmark problems for dynamic modelling in systems biology. BMC Syst. Biol.,
9(1):1–15, 2015.

[31] A. F. Villaverde, N. Tsiantis, and J. R. Banga. Full observability and estimation of un-
known inputs, states and parameters of nonlinear biological models. J. R. Soc. Interface,
16(156):20190043, 2019.

[32] F.-G. Wieland, A. L. Hauber, M. Rosenblatt, C. Tönsing, and J. Timmer. On structural

and practical identiﬁability. Curr. Opin. Syst. Biol., 25:60–69, 2021.

[33] D. Wodarz and M. A. Nowak. Mathematical models of HIV pathogenesis and treatment.

BioEssays, 24(12):1178–1187, 2002.

4

APPENDIX

A Theory and methods

A.1 Background on Structural Identiﬁability and Observability
(SIO)
Structural identiﬁability and observability are two key concepts in system identiﬁcation and
dynamic modelling. To give their formal deﬁnitions we consider models described by ordinary
diﬀerential equations with general form:

(cid:40)

M :

˙x = f (u(t), x(t), θ) ,

y = g (u(t), x(t), θ) ,

(1)

where f and g are analytic functions (therefore inﬁnitely diﬀerentiable); x(t) ∈ Rnx is the
state variables vector; u(t) ∈ Rnu , the known inputs vector; y(t) ∈ Rny , the outputs vector;
θ ∈ Rnθ , the parameters vector. The input vector, u(t), is assumed to consist of inﬁnitely
diﬀerentiable functions.

A parameter θi of M (1) is structurally locally identiﬁable (s.l.i.) if a neighbourhood N (θ∗)
exists such that, for any ˆθ ∈ N (θ∗), y(t, θ∗) = y(t, ˆθ) holds if and only if θ∗
i = ˆθi, for almost
any parameter vector θ∗ ∈ Rnθ . We say that a parameter is structurally unidentiﬁable (s.u.)
if this relationship does not hold in any N (θ∗). If all the parameters of a model are s.l.i., the
model is s.l.i. too. Accordingly, if at least one the parameters is s.u., the model is s.u.

A s.l.i. parameter can be determined from knowledge of the output y(t) and input u(t) of
the model. Likewise, a state xi(τ ) is said to be observable if it can be determined from the
output y(t) and any known inputs u(t) of the model in the interval t0 ≤ τ ≤ t ≤ tf , for a
ﬁnite tf . Otherwise, it is unobservable. A model is observable if all its states are observable,
and unobservable if at least one of them is unobservable.

A.2 SIO analysis with the Observability Rank Condition
Let us begin with the analysis of observability. The available knowledge for inferring the
internal state x of model M consists of the output y and its derivatives. Following a diﬀerential
geometry approach [4, 26] we construct a matrix O(x) that represents a map between the model
output y and its derivatives ˙y, ¨y, ..., on the one hand, and its state x on the other. We can
then evaluate the observability by calculating the rank of O(x). If it has full rank, then the
model is observable. If rank(O(x0)) = nx, M is observable around x0.

With time varying inputs, the output derivatives ˙y, ¨y, ... are the so-called “extended” Lie

derivatives. The extended Lie derivative [10] of g with respect to f is deﬁned by:

Lf g(x) =

∂g(x)
∂x

f (x, u) +

j=∞
(cid:88)

j=0

∂g(x)
∂u(j) u(j+1)

and the high order derivatives are recursively calculated:

Li

f g(x) =

g(x)

∂Li−1
f
∂x

f (x, u) +

j=∞
(cid:88)

j=0

g(x)

∂Li−1
f
∂u(j)

u(j+1)

The ith Lie derivative may contain input derivatives only up to order (i − 1) [31]. We can then
truncate the inﬁnite summation at j = i − 1 and rewrite the extended Lie derivative:

Lf g(x) =

∂g(x)
∂x

f (x, u) +

j=i−1
(cid:88)

j=0

∂g(x)
∂u(j) u(j+1)

We summarise the way of computing the observability matrix in the following way:

O(x(t)) =














∂
∂x

∂
∂x
∂
∂x

y(t)

˙y(t)
...



























=

y(nx−1)(t)

∂
∂x

g(x)

∂
∂x

(Lf g(x))
...














∂
∂x

(cid:0)Lnx−1

f

g(x)(cid:1)

.

(2)

For structural identiﬁability, parameters can be considered as constant state variables [23].
Assessing the observability of these states is equivalent to assessing the structural identiﬁability

5

of the parameters. To this end we construct an augmented state vector ˜x = [x(t); θ] with
dimension n˜x = nx + nθ and then we have that ˙˜x = [f (˜x(t), u(t)); 0]. For a new model with
these changes in the variables and equations we construct now an observability-identiﬁability
matrix, OI (˜x(t)), in the same way as O(x(t)). Then, if system M given by (1) satisﬁes
rank(OI (˜x0)) = n˜x = nx + nθ, with ˜x0 a point in the augmented state space, the model is
observable and identiﬁable around ˜x0.

A.3 SIO analysis with the FISPO algorithm in STRIKE-GOLDD
In [28] we see that full rank of OI might be achieved with less than n˜x − 1 Lie derivatives.
We also have a minimum number of Lie derivatives, nd, for which the matrix may be full
rank. In STRIKE-GOLDD, the OI is recursively calculated. Once the nd Lie derivative is
computed, the rank is calculated after adding each new derivative allowing early termination
of the procedure. If the full rank is achieved, the OIC is fulﬁlled; if the rank stops increasing,
there is at least one unobservable state or unidentiﬁable parameter.
In the latter case we
can determine which parameter or state is unidentiﬁable or unobservable, respectively. Each
column of OI corresponds to the partial derivative with respect to a parameter or state.
Removing each of the columns and recalculating the rank allows us to know which of the
variables is unidentiﬁable or unobservable. If the rank does not change when we remove the
ith column, then the ith variable is unidentiﬁable or unobservable.

Some models have unmeasured inputs. This is the case of disturbances or time-varying
parameters, for example. To analyse them we deﬁne a new model that includes them as
additional variables:

(cid:40)

Mw :

˙x = f (u(t), w(t), x(t), θ) ,

y = g (u(t), w(t), x(t), θ) ,

(3)

where w(t) refers to the unknown inputs. Then, we deﬁne a property analogous to observability
for these variables. An unknown input wi(τ ) is reconstructible if it can be determined from
y(t) and u(t) in t0 ≤ τ ≤ t ≤ tf , for a ﬁnite tf . A model is reconstructible if all its unknown
inputs are reconstructible (or “input observable”).

The property that encompasses observability, structural identiﬁability, and reconstructibil-
ity is called FISPO (full input, state, and parameter observability) [31]. Let ˜x(t) = [x(t), θ, w(t)]
be the vector of unknown model quantities (i.e. states, parameters and inputs), with z(t) ∈
Rnx+nθ +nw , and let us denote each element of ˜x(t) at time τ as zi(τ ). We say that the model
M (1) has the FISPO property if every ˜xi(τ ) can be determined from the output y(t) and any
known inputs u(t) of the model in the interval t0 ≤ τ ≤ t ≤ tf , for a ﬁnite tf . Thus, M is
FISPO if, for every ˜xi(τ ), for almost any vector ˜x∗(τ ) there is a neighbourhood N (˜x∗(τ )) in
which the following holds:

ˆ˜x(τ ) ∈ N (˜x∗(τ )) and y(t, ˆ˜x(t)) = y(t, ˜x∗(τ )))

⇒

ˆ˜xi(τ ) = ˜x∗

i (τ ).

For assessing reconstructibility, we consider a new augmented state vector ¯x = [x(t); θ; w(t)]
and consequently new state dynamics ˙¯x = [f (¯x(t), u(t)); 0; ˙w(t)]. Now, the ith Lie derivative
may contain derivatives up to w(i) so, we need to include them in the augmented state vector:

thus the state dynamics are:

¯x =















x(t)

θ

w(t)

˙w(t)
...
w(i)(t)















˙¯x =















f (¯x(t),u(t))

0

˙w(t)

˙w(t)
...
w(i+1)(t)















.

(4)

(5)

where ¯x ∈ Rn¯x , n¯x = nx + nθ + nw(i + 1).

Let Mw be a model of the form (3). Mw is FISPO if the new matrix OI computed with
the new augmented state vector ¯x(t) (4) and its corresponding equations ˙¯x(t) (5) is such that
rank(OI (¯x, u)) = n¯x. If the matrix is not full rank when it is not computationally feasible or

6

convenient to keep calculating Lie derivatives, the result is inconclusive. To deal with this, we
may set to zero the derivatives of w(t) of order higher than a given one (i). We will then have
∀j ≥ i. Even though this assumption restricts the type of inputs that can
that w(j) = 0,
be analysed, in [31] it was argued by induction that the results might apply to generic inputs
under certain circumstances.

A.4 SIO analysis with a probabilistic algorithm to test local
algebraic observability in polynomial time: ObservabilityTest
Sedoglavic presented an algorithm [21] related with the diﬀerential algebra approach [5], with
the goal of computing the set of observable variables of a model in polynomial time. When
this technique determines that a variable is observable, the result is guaranteed to be correct.
If it classiﬁes it as unobservable, the result is correct with high probability. This approach
is applicable to nonlinear rational dynamical systems without unknown inputs. Its deﬁnition
of algebraic observability is built on the existence of algebraic relations between the state
variables and the successive derivatives of the inputs and the outputs. If there is an algebraic
relation that allows ﬁnitely many trajectories of the state variables that are solutions of the
vector ﬁeld and yield the same speciﬁed input-output behavior, the state variables are said to
be locally observable [21]. A Maple implementation of this method, called ObservabilityTest,
is available at https://github.com/sedoglavic/ObservabilityTest/.

Let us now introduce some notation [21] to formalize the previous deﬁnition. We use capital
letters to denote the initial conditions of a function and its derivatives, i.e., u(r)(0) = U (r) and
y(r)(0) = Y (r) for r ≥ 0 and then U = (U (0), U (1), ...), Y = (Y (0), Y (1), ...). We denote the ﬁeld
adjoining the indeterminates U (0)
, ... for j = 1, ..., ny
to R as R (cid:104)U, Y (cid:105).

, ... for i = 1, ..., nu and Y (0)

, Y (1)
j

, U (1)
i

j

i

We say that xi, i ∈ {1, ..., nx} is locally algebraically observable if xi is algebraic over
the ﬁeld R (cid:104)U, Y (cid:105). The system M (1) is locally algebraically observable if the ﬁeld extension
R (cid:104)U, Y (cid:105) (cid:44)→ R (cid:104)U, Y (cid:105) (x) is algebraic. The number of non-observable state-variables which
should be assumed known, in order to obtain an observable system, can be calculated as the
In [21] the transcendence degree is also
transcendence degree of R (cid:104)U, Y (cid:105) (cid:44)→ R (cid:104)U, Y (cid:105) (x).
calculated with the rank of O(x(t)) (2). Thus, if it is a full rank matrix, the transcendence
degree is zero and the system is algebraically observable. If it is not full rank, then at least one
of the variables is not identiﬁable and further analysis would be needed to determine which
one it is.

While the way of analysing the properties is the same as in the FISPO algorithm, the
procedure to compute the matrix and its rank is rather diﬀerent. In this case, a variational
system derived from M (1) is used to directly compute the Jacobian matrix O [21]; with x,
θ, and u specialized on some given values. Let us denote by Φ(x, θ, u, t) the formal power
˙Φ = f (Φ, θ, u) with initial condition
series in t with coeﬃcients in R (cid:104)u(cid:105) (x, θ) solution of
Φ(x, θ, u, 0) = x. Then:

Φ(x, θ, u, t) = x +

Ljf (x, θ, u)

tj
j!

.

(cid:88)

j∈N∗

Besides, using Φ, we deﬁne the formal power series in t with coeﬃcients in R (cid:104)u(cid:105) (x, θ) as:

y(x, θ, u, t) = g(Φ(x, θ, u, t), θ, u, t) = g(x, θ, u) +

Ljg(x, θ, u)

tj
j!

(cid:88)

j∈N∗

Based on this we have:

Oalg =

∂(y(i))0≤i≤n˜x
∂(x, θ)

= coeﬀs

= coeﬀs

(cid:18) ∂g
∂x

(cid:18)

∂Φ
∂x
(cid:18)

∇y

Φ,

,

∂g
∂x

∂Φ
∂θ

+

∂g
∂θ

(cid:19)

(cid:19)

∂Φ
∂x

,

∂Φ
∂θ

, jj, j = 0, ..., n˜x

(cid:19)

.

(6)

where ∇y(Φ, Γ, Λ, θ, u) = (cid:0) ∂g
∂x Γ, ∂g
the n˜x ﬁrst terms of the power series expansion of Φ, Γ = ∂Φ
∂x

(cid:1) (Φ, Γ, Λ, θ, u). Consequently, we have to compute
and Λ = ∂Φ
∂θ

Since P ( ˙x, x, θ, u) = 0, the numerators of the rational relations ˙x − f (x, θ, u) = 0 and ∇P :

∂x Λ + ∂g

∂x

.

P ( ˙x, x, θ, u),






∂P
∂ ˙x
∂P
∂ ˙x

(x, θ, u) ˙Γ +

(x, θ, u) ˙Λ +

∂P
∂x
∂P
∂x

(( ˙x, x, θ, u)Γ,

(( ˙x, x, θ, u)Λ +

∂P
∂θ

(( ˙x, x, θ, u),

the power series Φ,Γ and Λ are solutions of the system of ordinary diﬀerential equations ∇P = 0
with the associated initial conditions Γ(x, θ, u, 0) = Idnx×nx

and Λ(x, θ, u, 0) = 0nx×nθ

.

7

Next, we specialize the parameters on some random integer θ∗ and the inputs on the power
series u∗, which are truncated at order n˜x + 1 with random integer coeﬃcients. Then, we solve
the associated system ∇P = 0 for some integer initial conditions x0, and we compute with ∇y
the specialization of Oalg.

The Newton operator used in the algorithm is based on the resolution of the following

system of linear ordinary diﬀerential equations:

∂P
∂ ˙x

˙Ej+1 +

∂P
∂x

Ej+1 + ∇P = 0 mod t2j+1,

(7)

with Ej+1 = (Φ − Φj, Γ − Γj, Λ − Λj) mod t2j+1, correction term, with Φj, Γj and Λj are
approximations of Φ, Γ and Λ, respectively. The system is solved using (Φj+1, Γj+1, Λj+1) =
(Φj, Γj, Λj) + Ej+1 and the initial conditions Φ0 ∈ Znx , Γ0 = Idnx×nx
.
and Λ0 = 0nx×nθ
The resolution of the linear ordinary diﬀerential system relies on the method of integrating
factors. We take the homogeneous system

∂P
∂ ˙x

(Φj, θ∗, u∗) ˙Ωj +

∂P
∂x

( ˙Φj, Φj, θ∗, u∗)Ωj + ∇P = 0 mod t2j+1,

where Ωj denotes a nx × nx unknown matrix whose coeﬃcients are truncated series. This
homogeneous system is then solved by means of a procedure called “Homogeneous Resolution”
[21] based on matricial resolution and, in a similar way, the expression in (7) can be com-
puted with a given precision by a procedure called “Constants Variation” [21]. Algorithm 1
summarizes the procedure.

Preprocesing Construct a straight-line program encoding the variational system ∇P and
the expressions used during its integration.
Specialization Specialization of the parameters, θ∗, and the inputs, u∗
Power Series Solution Computation of the power series solution of ∇P at order n˜x + 1
with a specialised value for the states
Jacobian computation Evaluation of ∇y on the series Φj, Γj and Λj where
j = ln2(n˜x + 1), giving the coeﬃcients of the Jacobian matrix
Rank computation Calculation of the matrix rank and transcendence degree
if transcendence degree = 0 then

System is algebraically observable

else

Determine which variable or variables are not observable.

end

Algorithm 1: Probabilistic algorithm to test local algebraic observability in polynomial time

B New developments in STRIKE-GOLDD 4.0

B.1 A new algorithm for SIO analysis in STRIKE-GOLDD:
ProbObsTest
STRIKE-GOLDD 4.0 includes a Matlab implementation of an extended version of Sedoglavic’s
ObservabilityTest algorithm. The new method is called ProbObsTest. It is introduced with
the aim of complementing the FISPO algorithm, achieving computational acceleration with
respect to it. In the FISPO algorithm the Lie derivatives are recursively calculated. When their
number is relatively small they can be computed in a feasible amount of time. However, for
each new Lie derivative that is needed the computational complexity increases, and calculations
quickly become impracticable when the number of unknown variables grows. To avoid the
need for such calculations, in our implementation of ProbObsTest we use the variational system
described by Sedoglavic, substituting all the symbolic variables with random numerical values.
After this, we get a polynomial matrix that we vectorize, exploiting MATLAB capabilities,
in order to obtain an even more eﬃcient implementation. Thus we perform the computations
with numerical matrices instead of symbolic expressions. This yields a new code, whose
computational complexity increases at a signiﬁcantly slower rate than FISPO for complex
models (as will be demonstrated in Section C). The remainder of this section describes the
new developments included in ProbObsTest with respect to the ObservabilityTest algorithm
originally presented in [21].

8

B.2 Extending the algorithm to admit unknown inputs
Sedoglavic’s ObservabilityTest algorithm cannot analyse models with unknown inputs. Sim-
ilarly to the FISPO algorith, ProbObsTest can handle unknown inputs by treating them as
states. To this end the state is augmented as in (4) and the state function f as in (5). We
can include as many input derivatives as additional states as the number of non-zero deriva-
tives speciﬁed as options; the last element of vector f will always be a zero in the presence of
unknown inputs. This method cannot handle an inﬁnite number of non-zero derivatives, since
the order of the computations grows with the number of derivatives. If the user indicates an
inﬁnite number of derivatives in the options, the toolbox automatically lowers it to a relatively
small number of non-zero derivatives, warning the user of the change and advising her/him to
increase the number if needed, or using the FISPO algorithm to consider the inﬁnite case.

B.3 Automatic model reformulation: obtaining a rational model
In principle, ObservabilityTest can only be applied to rational models. In ProbObsTest we have
included a procedure to replace non-rational expressions appearing in the model equations
with their Taylor expansions. This allows applying the algorithm to non-rational models for
which such an expansion is possible; while it is not feasible to do the Taylor expansion for
all non-rational functions, this solution covers a signiﬁcant amount of models. The toolbox
automatically checks whether it is possible to perform the transformation. If it is, the non-
rational expression is replaced. If it is not, the algorithm cannot be applied and an error is
issued.

The polynomial numerators of rational terms are obtained with the function rational2poly−
nomial, which we implemented as an adaptation of the dagnormal procedure in Observabili-
tyTest. Both functions obtain the numerator and denominator of a rational expression. How-
ever, we realised that ObservabilityTest has problems when non-integer exponents appear in
the equations: such terms are non-rational, but the algorithm does not detect it. To ﬁx this
issue we automatically approximate such values with the closest integer, which allows applying
the procedure while obtaining correct results in the general case.

Implementation: a Matlab toolbox with graphical interface
B.4
The ProbObsTest algorithm has been included in STRIKE-GOLDD 4.0, which has been im-
plemented as a Matlab toolbox. A screenshot of its graphical interface is shown in Fig. 1.C
of the main text. The interface allows choosing the algorithm from a drop-down menu and
specifying its settings; likewise, it is possible to select one of the models already existing in
the folder from a drop-down menu, or creating a new model from scratch in a new window.
This new interface coexists with the previously existing way of executing the toolbox, which
is by running a Matlab script; in this case one must indicate the settings by editing an options
ﬁle. Further details can be found in the user manual included in the documentation folder of
STRIKE-GOLDD 4.0.

C Results: comparing FISPO and ProbObsTest

To determine the computational improvement achieved by ProbObsTest with respect to FISPO,
we have compared their performance by applying them to a set of 22 problems, which are listed
in Table 1. We considered a number of variations of some of them, so as to assess the eﬀect
of varying the number of unknown input derivatives on the performance of the algorithms.
The CPU times of both algorithms for the set of 22 models are shown in Figure 1.B of the
main text. In the remainder of this section we describe each of the models and discuss the
results of the two aforementioned algorithms while also comparing them, when possible, with
ObservabilityTest.

C2M model: The model corresponds to a two compartment system appearing in [29, 31].
The model consists of:

• 2 states, x = (x1; x2),
• 4 parameters, θ = (k1e; k12; k21; b),
• 1 input, u,
• 1 output, x1,

and it is governed by the following state equations:

f (x, θ, u, w) =

(cid:32)

−(k1e + k12) · x1 + k21 · x2 + b · u
k12 · x1 − k21 · x2

(cid:33)

.

9

Table 1: List of benchmark models and their main features.

Model

Ref.

States Param.

1: C2M 1
2: HIV 3
3: C2M 2
4: 2DOF 1
5: C2M 3
6: 2DOF 2
7: C2M 4
8: 2DOF 3
9: PK 1
10: C2M 5
11: PK 2
12: PK 3
13: 2DOF 4
14: SIRS
15: NF-κB 1
16: βIG 1
17: HIV 5
18: βIG 2
19: NF-κB 2
20: βIG 3
21: JAK-STAT
22: CHO

[29, 31]
[31, 18]
[29, 31]
[13]
[29, 31]
[13]
[29, 31]
[13]
[19]
[29, 31]
[19]
[19]
[13]
[3]
[12, 28]
[9]
[33]
[9, 27]
[12, 28]
[9]
[1]
[30]

2
3
2
4
2
4
2
4
4
2
4
4
4
5
15
3
5
3
15
3
25
32

2
5
4
3
3
3
2
3
10
3
10
10
3
10
13
5
10
5
29
5
27
117

Known
inputs
0
1
1
1
0
1
0
0
1
0
0
0
0
0
1
1
0
0
1
0
5
0

Unknown inputs
(nonzero derivatives)
1(0)
0
0
1(0)
1(0)
1(2)
1(3)
2(0)
0
1(3)
1(0)
1(3)
2(3)
0
0
0
0
1(0)
0
1(3)
0
0

Outputs

1
2
1
2
1
2
1
2
2
1
2
2
2
2
6
1
2
1
6
1
14
13

We start considering the input as known, obtaining a FISPO result from both algorithms.
Then, we assume the input as unknown and parameter b as known. Finally, we also assume
k1e as known. ObservabilityTest can not be applied when there is an unknown input. For
the other two methods we also distinguish between constant input and with three non-zero
derivatives. Table 2 shows the computation times.

Case

Known
input

Number of derivatives

Execution
time

ObservabilityTest
FISPO
ProbObsTest

0,047
0,38
1,25

Unknown input
Known
b

Known
b an k1e

0

3

0

3

0,67
1,4

2,14
4,19

0,28
1,29

0,87
2,96

Table 2: Execution times (in seconds) for C2M model

HIV model: This dynamic system represents a HIV virus infection. We consider two
diﬀerent types of this model. The ﬁrst one, presented and analysed in [31, 18], consists of:

• 3 states, x = (Tu; TI ; V ),
• 5 parameters, θ = (λ; ρ; N ; δ; c),
• 1 know input, η,
• 2 outputs, g(x, θ, w) = (V ; TI + Tu),

and it is governed by the following state equations:

f (x, θ, u, w) =






λ − ρ · Tu − η · Tu · V
η · Tu · V − δ · TI
N · δ · TI − c · V




 .

The three algorithms yield a FISPO result. ProbObsTest takes 2,88 seconds, STRIKE-GOLDD
implementation 0,37 and ObservabilityTest 0,093.
The other model is introduced in [33]. It has:

10

• 5 states, x = (xx; y; v; ww; z),
• 10 parameters, θ = (β; λ; a; b; c; d; hh; k; q; uu),
• 0 inputs,

• 2 outputs, g(x, θ, w) = (ww; z),

and it is governed by the following state equations:



λ − (d · xx) − (β · xx · v)

f (x, θ, u, w) =









(β · xx · v) − (a · y)

(k · y) − (uu · v)

(c · z · y · ww) − (c · q · y · ww) − (b · ww)











.

(c · q · y · ww) − (hh · z)

The results obtained are the same for the three algorithms: 3 non observable states and 4 non
identiﬁable parameters. FISPO takes 8237,7 seconds, ProbObsTest 10,57 and ObservabilityTest
0,203.

2DOF model: This model is introduced and studied in [13]. It is an aﬃne-in-the-inputs
model that characterizes the behavior of a mechanical system. The model consists of:

• 4 states, x = (x1; x2; ˙x1; ˙x2),
• 3 parameters, θ = (k1; δk1; m2),
• 1 known input, u = F1,
• 1 unknown input, w = F2,
• 2 output,

and it is governed by the following state equations:



f (x, θ, u, w) =






(−(k1 + δ · k1 · x1)x1 + k2 · (x2 − x1) − c1 ·

˙x1
˙x2

˙x1 + c2 · ( ˙x2 − ˙x1) + F1)/m1








,

and the output equations:

(k2 · (x1 − x2) + c2 · ( ˙x1 − ˙x2) + F2)/m2

(cid:32)

g(x, θ, w) =

x1
(k2 · (x1 − x2) + c2 · ( ˙x1 − ˙x2) + F2)/m2

(cid:33)

.

As we have an unknown input, we did the analysis for the constant case and with two non-zero
derivatives. In both situations we ﬁnd that the model is FISPO with both of the algorithms.
FISPO spent 0,5 seconds running for the constant case and 0,83 for time-varying one, while
ProbObsTest required 5,33 and 9,48, respectively.

Also, to check the behavior with more than one unknown input, we have adapted the model
taking the known input as unknown. For the constant case we found that x2 is non observable
and F1 and F2 are not reconstructible. The solution obtained matches the one achieved with
the previous implementation. FISPO took 0,5 seconds running while the ProbObsTest took
˙F1, F2
5,33. With two non-zero derivatives we found that ˙x2 and x2 are unobservable, and F1,
and ˙F2 are not reconstructible. The times are now 18,9 for STRIKE-GOLDD, and 20,79 for
the new code. ObservabilityTest cannot be applied to this model since it has unknown inputs.

Pharmacokinetics model (PK): This example is taken from [19]. It is a model of the
behavior of certain orally administered drugs. It consists of:

• 4 states, x = (x1; x2; x3; x4),
• 10 parameters, θ = (k1; k2; k3; k4; k5; k6; k7; s2; s3),
• 1 input, u, that will be considered known and unknown,
• 2 outputs, g(x, θ, w) = (s2 · x2; s3 · x3),

and it is governed by the following state equations:

f (x, θ, u, w) =








u1 − (k1 + k2) · x1
k1 · x1 − (k3 + k6 + k7) · x2 + k5 · x4
k2 · x1 + k3 · x2 − k4 · x3
k6 · x2 − k5 · x4








.

11

For the known input case we obtain that x2, x3 and x4 are unobservable and k1, k2, k3, k7,
s2 and s3 are unidentiﬁable. The execution times are 1,95 seconds for STRIKE-GOLDD, 5,81
seconds for ProbObsTest and 0,141 seconds for ObservabilityTest. When u is an unknown
constant input only k4, k5 and k6 are identiﬁable, all the states are unobservable, and the
input is not reconstructible. FISPO takes 6,54 seconds and ProbObsTest 7,3. With 3 non-zero
derivatives of the input we get the same result; FISPO takes 14,75 seconds and ProbObsTest
16,8.

In [3] the transmission of respiratory syncytial virus (RSV) is modeled. We
SIRS model:
work with the model that takes into account the seasonal nature of transmission through an
oscillating contact rate. The population is divided into susceptible (S), infected and infectious
(I), and recovered (R) individuals. The model consists of:

• 5states, x = (S; I; R; x1; x2),
• 10 parameters, θ = (ν; b1; b0; M ; µ; g),
• 0 inputs,
• 2 outputs, g(x, θ, w) = (I; R),

and it is governed by the following state equations:

µ − S · µ − b0 · (1 + b1 · x1) · S · I + g · R
b0 · (1 + b1 · x1) · S · I − (ν + µ) · I
ν · I − (µ + g) · R

f (x, θ, u, w) =











−M · x2
M · x1











.

The three implementations ﬁnd b1 unidentiﬁable and x1 and x2 unobservable. STRIKE-
GOLDD took 70,56 seconds, ProbObsTest 7,55 and ObservabilityTest 0,125.

NF-κB model: NF-κB stands for ”nuclear factor kappa-light-chain-enhancer of activated
B cells”. We use as reference the analysis done with STRIKE-GOLDD in [28] based in [12].
The model consists of:

• 15 states, x = (x1; x2; x3; x4; x5; x6; x7; x8; x9; x10; x11; x12; x13; x14; x15),
• 29 parameters, θ = (t1; t2; c3a; c4a; c5; k1; k2; k3; kprod; kdeg; i1; e2a; i1a; ...

a1; a2; a3; c1a; c2a; c5a; c6a; c1; c2; c3; c4; kv; e1a; c1c; c2c; c3c),

• 1 known input, u1,

• 6 outputs: g(x, θ, u, w) =














x7
x10 + x13
x9
x1 + x2 + x3
x2
x12







,







and it is governed by the following state equations:

f (x, θ, u, w) =










































kprod − kdeg · x1 − k1 · x1 · u1
−k3 · x2 − kdeg · x2 − a2 · x2 · x10 + t1 · x4 − a3 · x2 · x13 . . .
· · · + t2 · x5 + (k1 · x1 − k2 · x2 · x8) · u1
k3 · x2 − kdeg · x3 + k2 · x2 · x8 · u1
a2 · x2 · x10 − t1 · x4
a3 · x2 · x13 − t2 · x5
c6a · x13 − a1 · x6 · x10 + t2 · x5 − i1 · x6
i1 · kv · x6 − a1 · x11 · x7
c4 · x9 − c5 · x8
c2 + c1 · x7 − c3 · x9
−a2 · x2 · x10 − a1 · x10 · x6 + c4a · x12 . . .
· · · − c5a · x10 − i1a · x10 + e1a · x11
−a1 · x11 · x7 + i1a · kv · x10 − e1a · kv · x11
c2a + c1a · x7 − c3a · x12
a1 · x10 · x6 − c6a · x13 − a3 · x2 · x13 + e2a · x14
a1 · x11 · x7 − e2a · kv · x14
c2c + c1c · x7 − c3c · x15










































.

12

For this model the execution time with FISPO is 2866,55 seconds while for ProbObsTest is
279,51 and for ObservabilityTest 8,422 seconds. We found that states x8 and x15 are unobserv-
able and k2, c4, c1c, c2c and c3c are unidentiﬁable. We also did the analysis with parameters
a1, a2, a3, c1a, c2a, c5a, c6a, c1, c2, c3, c4, kv, e1a, c1c, c2c and c3c ﬁxed to some speciﬁc values.
In this case we have that x15 is unobservable. For the second model the times are 844,46,
291,21 and 3,14, respectively.

βIG model: This example is one of the four case studies presented in [9], representing a
physiological circuit that models possible regulatory mechanisms of glucose homeostasis. It
was also included in [27]. It consists of:

• 3 states, x = (G; β; I),
• 5 parameters, θ = (p; si; γ; c; α),
• 1 input, called u that will be considered both as known and unknown,
• 1 output, g(x, θ, w) = G,

and it is governed by the following state equations:

f (x, θ, u, w) =



β ·









u − (c + si · I) · G
0,021
24·60
1 + ( 8,4

0,025
24·60
1 + ( G

−

G )1,7
p · β · G2
α2 + G2 − γ · I

4,8 )8,5











.

With this model we are going to analyse diﬀerent cases. For all of them the results with
the two algorithms match. With the input as known, FISPO takes 984,89 seconds while
ProbObsTest only 12,65. For constant unknown input these times were 14140,08 and 21,85
seconds, respectively. With three non-zero derivatives of the unknown input, FISPO yields an
out of memory error while ProbObsTest takes 38,95 seconds. Here we have the best exhibit
of the improvements that the new implementation can achieve. For this relatively small but
complex system, even for the known input case we see that a great computational acceleration
is obtained. Moreover, with the unknown input with three non-zero derivatives we reach a
point where FISPO cannot analyse the model while the new algorithm can. Finally, in order to
analyse this model with ObservabilityTest we need to approximate the non-integer exponents
in the equations with integer values. Otherwise, the code issues an error but it gives no clue
about its cause or possible ﬁx. After ﬁxing it, the analysis took 0,016 seconds.

JAKSTAT model: This model is introduced in [1] and consists of:

• 25 states, x = (EpoRJAK2; EpoRpJAK2; p1EpoRpJAK2; p2EpoRpJAK2;
p12EpoRpJAK2; EpoRJAK2C IS; SHP 1; SHP 1Act; ST AT 5; pST AT 5;
npST AT 5; CISnRN A1; CISnRN A2; CISnRN A3; CISnRN A4; CISnRN A5;
CISRN A; CIS; SOCS3nRN A1; SOCS3nRN A2; SOCS3nRN A3
; SOCS3nRN A4; SOCS3nRN A5; SOCS3RN A; SOCS3),

• 27 parameters, θ = (CISEqc; CISEqcOE; CISInh; CISRN ADelay;

CISRN AT urn; CIST urn; EpoRActJAK2; EpoRCISInh; EpoRCISRemove;
JAK2ActEpo; JAK2EpoRDeaSHP 1; SHP 1ActEpoR; SHP 1Dea; SHP 1P roOE;
SOCS3Eqc; SOCS3EqcOE; SOCS3Inh; SOCS3RN ADelay;
SOCS3RN AT urn; SOCS3T urn; ST AT 5ActEpoR; ST AT 5ActJAK2;
ST AT 5Exp; ST AT 5Imp; initEpoRJAK2; initSHP 1; initST AT 5),

• 5 known inputs, u = (ActD; CISoe; SOCS3oe; SHP 1oe; Epo),
• 0 unknown inputs,

• 14 outputs, with equations:

13

g(x, θ, w) =

















































2 · (EpoRpJAK2 + p12EpoRpJAK2 + p1EpoRpJAK2 + p2EpoRpJAK2)
initEpoRJAK2
16 · (p12EpoRpJAK2 + p1EpoRpJAK2 + p2EpoRpJAK2)
initEpoRJAK2
SOCS3
SOCS3Eqc
ST AT 5 + pST AT 5
initST AT 5
pST AT 5
initST AT 5
ST AT 5

SHP 1 + SHP 1Act

CIS

SOCS3
100 · pST AT 5
ST AT 5 + pST AT 5
SOCS3RN A

CISRN A

(SHP 1 + SHP 1Act) · (SHP 1oe · SHP 1P roOE + 1)
initSHP 1
CIS
CISEqc

















































.

For state equations we will refer to [25]. To analyse this model we consider the last parameter,
which is the initial condition of one of the measured states, as known. FISPO yields an out of
memory error; to avoid it, the analysis has to be done decomposing the model. In contrast,
ProbObsTest takes 1914,79 seconds and ObservabilityTest just a few seconds.

CHO model: This is a metabolic model of Chinese Hamster Ovary (CHO) cells, which
are used for protein production in fermentation processes [30]. The model consists of:

• 32 states, x = (x1; . . . ; x32),
• 117 parameters, θ = (θ1; . . . ; θ117),
• 0 inputs,

• 13 output, g(x, θ, w) = (x5; x4; x3; x2; x1; x29; x27; x21; x15; x13; x30; x32; x11).

The state equations were modelled with in lin-log kinetics. The resulting expressions are non-
rational, due to the presence of logarithms, so ObservabilityTest cannot be applied unless the
model is reformulated. STRIKE-GOLDD 4.0 checks for this possibility and reformulates the
model automatically.

In [28], the analysis of the model with STRIKE-GOLDD (i.e. FISPO) was only partially
accomplished. When trying to analyse the whole model FISPO gives an out-of-memory error.
After decomposing it in smaller submodels, four parameters were found to be unidentiﬁable,
95 were classiﬁed as identiﬁable, and the identiﬁability of the remaining 18 could not be
determined. (After ﬁxing six of them, the model was found to be FISPO.)

In contrast, ProbObsTest can analyse the whole model, obtaining conclusive results for all
parameters without the need for decomposition. However, it should be noted that it took 12
days to conclude the analysis, which reached the 99% of the computer memory.

14

