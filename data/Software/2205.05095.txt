DOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

1

Design and Implementation of a Secure RISC-V
Microprocessor

Kleber Stangherlin, Manoj Sachdev
ECE Department, University of Waterloo, Waterloo, ON N2L 3G1, Canada
{khstangh,msachdev}@uwaterloo.ca

2
2
0
2

t
c
O
3

]

R
C
.
s
c
[

3
v
5
9
0
5
0
.
5
0
2
2
:
v
i
X
r
a

Abstract—Secret keys can be extracted from the power con-
sumption or electromagnetic emanations of unprotected devices.
Traditional counter-measures have limited scope of protection,
and impose several restrictions on how sensitive data must be
manipulated. We demonstrate a bit-serial RISC-V micropro-
cessor implementation with no plain-text data. All values are
protected using Boolean masking. Software can run with little
to no counter-measures, reducing code size and performance
overheads. Unlike previous literature, our methodology is fully
automated and can be applied to designs of arbitrary size or
complexity. We also provide details on other key components such
as clock randomizer, memory protection, and random number
generator. The microprocessor was implemented in 65 nm CMOS
technology. Its implementation was evaluated using NIST tests
as well as side channel attacks. Random numbers generated with
our RNG pass on all NIST tests. Side-channel analysis on the
baseline implementation extracted the AES key using only 375
traces, while our secure microprocessor was able to withstand
attacks using 20 M traces.

Index Terms—secure microprocessor,

side-channel attack,

Boolean masking, dynamic logic, clock randomization

I. INTRODUCTION

Increased cyber crime and decentralized currencies are es-
calating the importance of protecting digital assets. Malicious
individuals use a number of techniques to extract secrets
from integrated circuits (ICs). Traditional hardware security
counter-measures only target a few most vulnerable elements,
such as system bus, memory, and cryptographic accelerators.
We demonstrate a bit-serial RISC-V microprocessor imple-
mentation with no plain-text data. All values are protected
using Boolean masking. Our architecture sets no constraints on
how sensitive data must be manipulated. Software implemen-
tations may run with little to no counter-measures, reducing
code size and performance overheads.

Unlike previous literature, our methodology is fully inte-
grated to the ASIC digital design ﬂow. We carefully selected
a set of counter-measures that require no changes to the
input register transfer level (RTL) code, or to the application
software. Our techniques can be applied to digital designs
of any size or complexity. Original circuit functionality and
latency are not affected.

Our design uses Boolean masking (BM) at the logic level.
Boolean masking splits each value into two or more shares.
Individual shares are (ideally) uncorrelated to the original
value. Physical probing of all shares is required to uncover
the original data. Accurate tampering of the system requires

precise modiﬁcations in all shares of a value, which is con-
siderably more difﬁcult.

At the transistor level, we use differential domino logic
(DDL) to implement our logic gates. DDL is a differential
input/output dynamic logic style with precharge/evaluation
phases. During precharge, both outputs are driven to the
same value, but only one of them toggles in the evaluation
phase. DDL is used to suppress glitches and reduce the data-
dependent power consumption.

To allow meaningful comparison, we implemented three
different version of a bit-serial RISC-V microprocessor using
the same RTL code as input. A baseline implementation with
no counter-measures, another using Boolean masking, and a
third that combines Boolean masking and DDL. This work
also provides detailed information on the implementation of
key components such as memory protection unit, clock edge
randomizer, and random number generator (RNG).

We fabricated a testchip in 65 nm CMOS. We report the
area cost of all counter-measures used, as well as the power
consumption of each microprocessor and the RNG. The quality
of random numbers is evaluated using NIST tests, autocorre-
lation, and Shannon entropy. Side-channel leakage assessment
is performed using an extensive database of recorded power
traces—total of more than 40 M traces. We use state-of-the-
art analysis algorithms for correlation power analysis (CPA)
with dynamic time warping (DTW) pre-processing. Our results
evaluate each counter-measure individually, such that we can
determine its relative effectiveness.

Our main contributions include the demonstration of a
microprocessor where all values are protected with Boolean
masking, and precharge logic. This work serves as proof
of concept for a system where software implementations
can run with fewer counter-measures. Our RTL design and
implementation scripts are publicly available [42]. We describe
scalable, and automated solutions that require no changes to
the architecture being protected. Relevant problems such as
the high-throughput requirements for the RNG, clock random-
ization, and the details of address/data protection at memory
interfaces are discussed. Finally, the paper also performed se-
curity assessment of different counter measures using distinct
implementations of the same initial design.

II. RELATED WORKS

Secret keys can be extracted from the power consumption
or electromagnetic emanations of unprotected devices [27],

 
 
 
 
 
 
DOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

2

Fig. 1. Top level block diagram of our testchip.

[36]. Boolean masking was ﬁrst proposed in [15], followed
by [24], [46]. Threshold implementation (TI) was introduced
as a provably glitch resistant masking technique [33]. Recent
developments have been focused on reducing the area and ran-
domness cost of implementing masked circuits [8], [17], [19]–
[22], [38]. Most of Boolean masking literature is centered at
protecting non-linear operations in cryptographic algorithms.
Interest in larger scopes of protection has risen in recent years.
A microprocessor ALU is masked using TI [16]. Masking
was applied to a binarized neural network [13], and to RISC-
V microprocessors [12], [18]. This work explores masking
expressions that have lower cost and are easy to integrate into
already existing designs [8].

Differential logic styles with return to zero encoding make
power consumption less data-dependent. For example, in [43]
a sense ampliﬁer based logic (SABL) is used to reduce
asymmetries of the dynamic logic. In [44], wave dynamic
differential logic (WDDL) uses static CMOS gates to replicate
the behavior of dynamic logic, but glitches still leak sensitive
information. Other logic styles include [2], [7], [9], [32], [34],
[35], [41]. Our work differentiates in the applied methodology.
Instead of “semi-custom” techniques, our scripts are integrated
with CAD tools and perform automatic replacement of relevant
static CMOS cells by dynamic cells, without affecting place
and route or static timing analysis.

Often, counter-measures are tailored to the hardware im-
plementation of speciﬁc algorithms. For example, in [29],
authors use randomized byte-ordering, heterogeneous substi-
tution boxes, and linear Boolean masking of mix-columns
to protect an AES implementation. Other recent works have
developed more generic protection mechanisms using fast,
randomized, voltage dithering in the voltage regulator [14],
[25], [28], [40]. Comparing the effectiveness of counter-
measures from different publications is not trivial. Changes in
the acquisition system, and the presence of combined counter-
measures make it hard to draw any conclusions. Finally, it is
possible that small drops in the supply voltage, could create
misalignment in the power traces. The mentioned works lack
a side-channel leakage assessment using alignment techniques
such as dynamic time warping (DTW).

High-throughput RNGs are essential for effective masking
of digital circuits. Large literature exists for harvesting random
numbers from different entropy sources. Recent proposals
include latch metastability [11], [31], [50], time to collapse

Fig. 2. Bit-serial RISC-V datapath. Control lines are not shown. Thin lines
have width of a single bit. Although not shown in this diagram, memory and
register ﬁle are shared among the three microprocessors.

in multi-mode ring-oscillators [49], or common mode analog
comparators [3]. But perhaps the most well understood entropy
source is still phase jitter [5]. While cryptographic algorithms
need high-quality random numbers with forward/backward
secrecy [26], masking implementations may tolerate random
numbers generated by lightweight RNGs designs that focus
on throughput—and that is where our RNG is positioned.

III. HARDWARE ARCHITECTURE

A. Top Level Design

Our design has three RISC-V microprocessors. See Fig.
1. Each microprocessor is designed to test a different set of
security counter-measures. They share two SRAM memories
for code, data, and register ﬁle (RF). The test logic selects
which one of the three microprocessor will be operational, as
well as the desired conﬁguration for clock edge randomization
and random numbers. The RISC-V implementation with no
counter-measures (NCM-uP) has direct access to the SRAM
memories, while others go through a memory protection unit.
Netlist manipulation techniques described in this section are
only applied to the BM-uP and BM-DDL-uP microprocessors.
Other blocks are synthesized with the typical ASIC digital
design ﬂow, using a commercial library of standard cells.

B. Bit-serial RISCV Microprocessor

We used a bit-serial CPU, show in Fig 2. It is based on a
publicly available design1. This CPU design was chosen for
its small area footprint. The internal datapath is one bit wide.
Techniques described in this work are equally applicable to
larger microprocessors. Main memory is single port and uses
32 bit words to store both code and data. The register ﬁle (RF)
is dual port. One port for writes, another for reads with 2 bit
words to avoid an additional read port. Arithmetic logic unit
(ALU) operates on a single bit of data per cycle. The fetch-
execute-writeback process requires 36 cycles. Instructions
need one, or two phases to complete. Two-phase instructions
such as loads, stores, and branches can use up to 70 cycles.
Only three 32 bit registers exist. BUF is a 32 bit register

1https://github.com/olofk/serv

SRAM(code & data)Memory IPsare sharedNo Counter-measures(NCM-uP)Addr Scrambling& Data EncryptionClockRandomizerJTAG & Test logicRandomNumber Gen.Addr Scrambling& Data EncryptionBoolean Masked(BM-uP)Bool. Masked &Diﬀ. Dom. Logic(BM-DDL-uP)SRAM(register ﬁle)RISC-V DesignsMEMDATBUFALUCTRL / PCREGISTERFILEINSTRDECODERADDR RS1DATA RS1ADDR RS2DATA RS2ADDRDATAADDR RDDATA RDControl linesnot shown.DOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

3

Fig. 3. Clock generation and randomization logic. Glitch suppression, test,
and forbidden state prevention logic are not shown.

that holds data between phases, which can be addresses for
branches, load/store, or data to be shifted. DAT is another
32 bit register, used for memory load and store operations,
where data is shifted in from RS2 during store operations,
and shifted out to RD during load operations. The last 32
bit register holds the program counter (PC). If the instruction
is not a branch, next address (PC + 4) is calculated one bit
at a time, in parallel with ALU execution. All three 32 bit
registers work similarly to a shift register during execution.
For memory operations, parallel output/capture functionality
is used. The instruction decoder (ID) parses instructions from
DAT. It outputs immediate ﬁelds to BUF, CTRL/PC, and
ALU, one bit at a time, to calculate jumps addresses and
arithmetic operations. Control and status registers (CSRs),
interrupts, multiplication, and divide instructions were not
implemented. Using 65 MHz clock, an AES encryption of 128
bits, without any software counter-measures, takes nearly 20
ms—substitution boxes (SBOXes) not stored as lookup tables,
but computed during execution.

C. Clock Generation and Randomization

Power analysis attacks require a large number of power
traces. Each trace records the power consumption while the
device is manipulating sensitive information with different
input data. For example, AES encryptions with different
plain-text, but same key. As discussed in section IV-E, the
effectiveness of power attacks is signiﬁcantly higher if traces
are aligned in time. Therefore, the insertion of random delays
to purposely misalign power traces may be used as counter-
measure against power analysis attacks. To avoid changing
software or existing hardware architectures, we insert random
delays by manipulating the clock signal.

Our clock generation and randomization logic is shown in
Fig. 3. A ring-oscillator (RO) generates the clock using 36
inverters and a NAND gate. Layout of the ring-oscillator was
done manually. We used MOSFETs with channel length 4x
the minimal value to achieve nominal frequency of 226 MHz.
Compensation for temperature and noise was not implemented.
The hardware includes an adjustable clock divider from 2 to
256. Glitch suppression and test logic are not shown. To gener-
ate a random signal for clock edge randomization we used an
8-degree LFSR in XNOR form, polynom x8 +x6 +x5 +x4 +1,

Fig. 4. Clock waveform visualization for 9 different randomization settings.
White/black pixels represent zero/one. Time passes from left to right, top to
bottom. White pixel on the left, and black pixel on the right represents a rising
edge.

cycle length 28 −1, all ones excluded [1]. Output is taken from
the two least signiﬁcant bits, it indicates when an edge will be
skipped. A multiplexer was added to select how often clock
edges are skipped. Valid options are 25%, 50%, or 75% for
outputs from AND, XOR, and OR, respectively. For example,
if LFSR state is “10001101” both XOR and OR outputs would
skip next clock edge if selected, while the AND output would
introduce a clock edge.

Real applications require the hardware to complete opera-
tions under a time budged. We generate the clock randomiza-
tion pattern using an 8 bit LFSR, which has sequence length of
255. Therefore, within a 255 cycles window, the randomized
clock will have a constant number of edges. This enables
performance predictability with resolution of 255 system clock
cycles. Nevertheless, one may argue that a repeating clock
randomization pattern introduces potential vulnerabilities. For
this reason, we allow the 8 bit LFSR to be perturbed, at an user
adjustable rate. The perturbation signal comes from the RNG,
therefore, it has very large cycle length. If perturbed every
clock cycle, we can assume that the randomized clock pattern
will never repeat. However, under such frequent perturbation
rate, the LFSR is more likely to, sometimes, produce a run of
30 ones—causing the clock randomizer to skip 30 consecutive
clock edges. To reduce the likelihood of such events, we
suggest a moderate perturbation rate. For example, when
perturbed every 32 cycles, the clock randomizer pattern will
follow the 8 bit LFSR natural counting sequence for 31 cycles,
until it is perturbed again.

Fig. 4 shows a grid of 3 by 3 subplots with randomized
clock waveform presented using image pixels. Rows have
different clock skip rates, while columns have different per-

En1234567836 invertersPerturbRand bit(from RNG)RandclockSkipclockRandclockSysclockSkipclockInitInit & PerturbControlSystemclockClock edge randomizer (runs on system clock)System clock generatorLinear Feedback Shift RegisterSampleclock(to RNG)ClockDividerClockDividerNo PerturbationAND (skips 25%)XOR (skips 50%)OR (skips 75%)Every 32 cyclesEvery cycleDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

4

Fig. 6. Output XOR network for random numbers. XOR wiring is deﬁned
randomly at design phase.

Fig. 5. Random number generator architecture. The sampling clock comes
from the clock generation circuit.

turbation rates. In each subplot, time is discretized as pixels.
White/black pixels represent
logic 0/1, respectively. Time
passes from left to right, top to bottom (the clock waveform
is folded in the image area). A transition from white pixel (at
the left) to black pixel (at the right) denotes a rising edge.
A pattern is clearly visible in the clock waveform when the
LFSR is not perturbed. Perturbations every 32 cycles, and
every cycle, remove noticeable patterns.

The clock skip rate affects the number of rising edges oc-
curring in a period of time. Application engineers may assign
different clock skip rates to software routines, depending on
the sensitivity of data being manipulated and performance
requirements. Also, care must be taken to avoid placing the
LFSR into forbidden state (“all ones”, where updates no longer
occur). The LFSR update cycle is skipped in case the next
state is all ones. The initial state is generated by the RNG and
loaded serially during power-on.

D. Random Number Generator

Random numbers are a critical component of secure ICs.
Both clock randomization and Boolean masking require ran-
dom numbers to work effectively. In particular, Boolean mask-
ing needs a large number of fresh (new) random numbers
every clock cycle for remasking operations (see section III-E).
The entropy requirement for Boolean masking however, is not
as high as typical cryptographic uses such as key generation.
Therefore, our random number generator (RNG) focus on high
throughput to attend the demand of our implemented counter-
measures.

Our RNG design uses ring-oscillator (RO) thermal noise as
entropy source. It accumulates thermal noise over a period of
time, which produces phase jitter. The entropy of a sampled
value is inversely proportional
to the sampling rate. The
RNG RO design, shown in Fig. 5, uses same techniques
as the system clock RO, but with relatively prime number
of stages to avoid frequency locking. The RNG RO has 22
inverters and a NAND gate, with 366 MHz nominal frequency.
The sampling clock is derived from system clock. Sampling
frequency depends on target entropy rate and on technology

Fig. 7. Boolean masking expressions to perform non-linear operations on
shared values.

noise characteristics. An IO PAD is connected to the RO output
for noise characterization (see section IV-C). A two stages
meta-stability ﬁlter running on system clock was added to the
raw random bit output.

Throughput of raw random bits depends on sampling clock
frequency, which is typically much lower than system clock
frequency. To increase throughput and remove possible en-
tropy source biases, we added a post-processing block. Our
solution is based on [45]. We use an 43-degree LFSR in
XNOR form, polynom x43 + x42 + x38 + x37 + 1, cycle length
243 −1, all ones excluded [1]. We also used a one-dimensional
linear hybrid cellular automata shift register (CASR) of 37
cells and cycle length of 237 − 1, all zeros excluded [10].
The hybrid CASR uses update rule 90 in all states, except
in position 9, where rule 150 is used. Rule 90 and rule
150 are deﬁned as ai(t + 1) = ai−1(t) ⊕ ai+1(t), and
ai(t + 1) = ai−1(t) ⊕ ai(t) ⊕ ai+1(t), respectively [48]. The
LFSR/CASR states are initialized with raw random numbers
during power on. Since the cycle length of LFSR and CASR
are relatively prime, the combined cycle length is close to 280.
Both LFSR and CASR update at every system clock cycle.

LFSR feedback and the CASR ﬁrst/last cells are XORed
with the new raw random bit prior to update. These pertur-
bations to the natural counting sequence only occur when
a new raw random bit is available, which depends on the
sample clock frequency. Output is derived by XORing LFSR
and CASR states. We use an XOR network, shown in Fig. 6,
that derives 243 outputs from LFSR/CASR state. Up to 1591
outputs are possible using two input XOR gates. More outputs
require the XORing more than two state bits. The connection

EN13743236373538......4223943122 invertersPerturbInitInit & PerturbControlRNG entropy sourceMeta. ﬁlterLinear Feedback Shift RegisterRNG post-processing (runs on system clock)RawRand bitSample clockClockDividerIO PAD(test)Cellular Automata Shift RegisterLFSR StateRandomly assigned XOR wiringCASR StateRand bits243-bits43374236413540343933......11012242xxx1x1x2x2yyy1y1y1y2x1x1x2x2z1z1z2z2y2y2y1zzxyxyr1r2x1y1x1y1x2y2x2y2To 2 sharesFrom 2 sharesAND with 2 sharesOR with 2 sharesDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

5

Fig. 8. Netlist conversion from original circuit, to shared, and then dynamic
logic.

pairs are unique, randomly assigned, and deﬁned at design
time (they are static).

E. Boolean Masking

Boolean masking (BM) splits each value into two or more
shares that are (ideally) uncorrelated to the original value.
Computation using multiple shares requires careful logic ma-
nipulation, where each operation is replaced by its masked
counterpart. We applied Boolean masking to the microproces-
sors designated as BM-uP and BM-DDL-uP. We used mask-
ing expressions from [8]. Although the masking expressions
themselves are secure, further linear combinations can make
them insecure [22]. Nevertheless, the used expressions have
key characteristics that are very attractive for the construction
of fully-masked large-scale designs: i) they are compact, and
ii) do not require fresh randomness at every operation. Fig.
7 shows the masked implementation of basic non-linear logic
gates (AND, OR) using masking expressions from [8]. Linear
operations such as XOR, shifts, and permutations do not
require any modiﬁcation,
they are applied to both shares
equally. Fresh random numbers are required when converting
from single share to two shares. Conversions between 2
shares and single share are only performed in the memory

Fig. 9. Dynamic domino gates and associated layout.

protection module, while data is still encrypted by session
keys. Therefore, plain-text values are never exposed.

We developed a script that converts arbitrary circuit netlists
into their masked counterparts. The script is integrated with
CAD tools. Two restrictions were imposed: i) the input netlist
can not use clock and reset as data; and ii) reset must be
asynchronous. See Fig. 8. The script splits every signal, except
reset and clock, in two shares, replacing all basic operations
by their masked counterparts. Circuit functionality and latency
are not affected. All registers are duplicated and wired to
accommodate the additional share of each state. An XOR gate
is added before every register to refresh the masking with
a new random number every cycle. No random number is
ever reused. New top level ports are automatically created to
accommodate the additional share of all previously existing
input/output ports. A new top level input port bus for fresh
random numbers is also created. It is driven by the RNG output
network, shown in Fig. 6, and each bit connects directly to a
pair or remasking XOR gates.

The masked implementation of non-linear operations re-
quires signals to traverse between ﬁrst/second logic networks.
Such signals are not represented in Fig. 8. Also, our implemen-
tation does not mask the reset signal. If reset is synchronous,
it can be masked together with logic.

F. Differential Domino Logic

Masking expressions for non-linear operations (AND, OR
gates) use signals from both shares (see Fig. 7). Glitches in that
logic may momentarily expose protected values, reducing the

xx1x1x2x2yy1y1y2rry2zz1z1z2z2Original circuit (1 share)Convert to Boolean Masking (BM)Convert toDiﬀerential DominoLogic (DDL)2 shares implementation2 shares using diﬀerential domino logicSingle sharelogic network Firstsharelogic network Secondsharelogic networkRSTRSTRSTPDN1PDN1PDNnPDNnPDN1PDN1PDNnPDNnRSTRSTRSTRSTQQQQQQQQQQQQRSTRSTRSTRSTCLKCLKCLKCLKCLKCLKAAAAZ = ABZ = A+BZ = A    BZ = ABZ = A+BZ = A    BAAAAABBBBBBBBAABBCLKCLKCLKZZABZAND with DDLOR with DDLXOR with DDLXOR with DDLAND/OR with DDLArea ofequivalentstatic cellDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

6

TABLE I
AREA UTILIZATION IN 65 NM CMOS.

Unit name

# of Instances

Area (µm2)

Clock generation & randomization
Random number generation
Microprocessor NCM-uP
Microprocessor BM-uP
Microprocessor BM-DDL-uP
Main memory (code & data)
Register ﬁle
Memory protection and muxes

203
674
731
8232
7633
13
19
768

922
2735
3509
22967
44426
39505
10720
2653

Notes: XOR output network uses 242 XOR instances and account for
871-µm2 of the area reported for the RNG.

Fig. 11. Die photo of the implemented chip in 65 nm CMOS technology
and its layout. The layout highlights standard cells for NCM-uP (green),
BM-up (yellow), and BM-DDL-uP (pink). Test logic, RNG, clock genera-
tion/randomization are shown in light blue.

so we manually speciﬁed the relevant
timing
arcs for delay characterization. We also wrote Verilog models
for functional simulation, supporting delay annotation. The
Liberty and Verilog ﬁles were used for timing analysis and
design sign-off.

input/output

In order to maintain the methodology applicable to complex
digital designs, we did not use routing constraints for differ-
ential signals. Therefore, wiring capacitance imbalances may
be a source of information leakage.

G. Memory Protection

A trivial solution for memory protection is to duplicate the
memory size and store both shares of the Boolean masked
data. To avoid a twofold increase in the SRAM size, we
perform encryption using a session based key, which is XORed
with the data to alter its hamming weight. Moreover, we also
scramble the address bus using another session based key that
is XORed with the address, changing the memory address
layout. Session keys have different values at every session.
The deﬁnition of a session is application dependent, but in
our case, it corresponds to one execution of the target program
in one of the microprocessors. Session keys remain stable for
the duration of a session. Our session keys are provided via
test logic. Fig. 10 shows the memory protection blocks. The
order in which the XOR operations are performed is extremely
important to avoid exposing plain-text values.

Single-port memory protection can be improved further.
The encrypted data can be XORed with the address before

Fig. 10. Memory protection scheme.

effectiveness of Boolean masking [30]. Traditional solutions
use registers to stop glitch propagation, which modiﬁes circuit
latency and requires signiﬁcant design effort for existing de-
signs. We reduce glitches by implementing our logic gates us-
ing differential domino logic (DDL), a differential input/output
dynamic logic style with precharge/evaluation phases
[37].
During precharge, both outputs are driven to the same value,
but only one of them toggles in the evaluation phase. Logic
gate inputs are restricted to a single 0 to 1 transition. Fig. 9
shows the transistor level schematic of AND, OR, and XOR
using DDL, with associated layout. Inverters are implemented
by swapping the output wires. AND/OR gates have the same
layout, which could be convenient for circuit obfuscation
techniques, such as split foundry manufacturing [23].

Our netlist conversion script was adapted to use our DDL
logic gates instead of the typical CMOS library cells. The
output netlist has each wire split in two shares for Boolean
masking. Moreover, each share is again split in two comple-
mentary signals for DDL. This technique was applied to BM-
DDL-uP, in Fig. 1. The layout of our DDL cells has same
height of the CMOS library cells, so that we can conveniently
mix DDL gates with static CMOS gates from the commercial
library. Better area results are possible with taller DDL cells,
but interoperability with commercial library cells would be
extremely hard.

Our output netlist uses sequential elements from the com-
mercial library. The remasking XOR gate preceding every
sequential element also uses a cell from the commercial
library—its output has no connection to dynamic cells, and
glitches in that gate are unlikely to cause signiﬁcant infor-
mation leakage since one of the inputs is a random number.
Inverted inputs to DDL gates are wired to registers inverted
output pins. Complementary signals were not granted their
own sequential element—the number of registers do not
quadruple with respect to the original design. Inverted outputs
from the last DDL gate in a combinational path (prior to the
remasking XOR) are left unconnected. This is a source of load
imbalance that will leak information, but it avoids signiﬁcant
area cost.

We characterized multiple strengths of the DDL cells using
a commercial tool. Our custom DDL library has two strengths
of the AND/OR gate, and three strengths of the XOR gate.
Dynamic logic is not supported by the characterization tool,

Address(share 1)Addr A/B(share 1)Data A/B(share 1)Data A/B(share 1)Data(share 1)Data(share 1)(share 2)(share 2)(share 2)(share 2)(share 2)(share 2)Mem. Address Scrambling KeyRF Address Scrambling KeyRF Data Enc. KeyMem. Data Enc. KeyMain memory protectionRF memory protectionScrambledAddressScrambledAddr A/BEncryptedData A/BEncryptedData A/BEncryptedDataEncryptedDataRandom NumberRandom NumberReg.FileMainMemoryUnrelatedLogicSecureMicroprocessorsDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

7

Fig. 12. Power consumption of (a) all RISC-V microprocessors, (b) RNG.
Static components are not included.

TABLE II
NIST TESTS ON RNG OUTPUT.

Test Name

ρ

Proportion

Frequency
Block Frequency
Cumulative Sums
Runs
Longest Run
Rank
FFT
Non Overlapping Template
Overlapping Template
Universal
Approximate Entropy
Random Excursions
Random Excursions Variant
Serial
Linear Complexity

0.554420
0.042808
0.964295
0.013569
0.289667
0.249284
0.474986
0.867692
0.115387
0.334538
0.181557
0.941144
0.619772
0.224821
0.017912

98/100
98/100
97/100
99/100
98/100
98/100
99/100
96/100
100/100
97/100
99/100
67/69
66/69
98/100
100/100

Notes: Cumulative Sums, Non Overlapping Template,
Random Excursions, Random Excursions Variant, and
Serial run multiple times in the NIST SP 800-22 Rev1a.
Values in table refers to the worst pass proportion among
all runs.

it is written, making data encryption address dependent. This
requires a non-linear expansion of the 10 bit address into a
32 bit word, which has extra area costs. It is also important
to notice that our memory protection unit does not include
ﬁrewall capabilities to detect unauthorized accesses. If present,
such logic must be protected with Boolean masking and DDL.

IV. MEASUREMENT RESULTS

A. Chip Area Utilization

We fabricated a testchip in a 65 nm CMOS process,
shown in Fig. 11. Table I shows the number of instances
and area utilization of each block after design sign-off. The
clock generation includes a 57-µm2 RO and all clock edge
randomization logic. The RNG includes a 37-µm2 RO and all
post-processing logic (LFSR, CASR, and XOR network). The
XOR network uses 242 XOR instances and accounts for 871-
µm2 of the reported area for RNG. The main memory uses a
single-port 32 kbit SRAM (1024x32). RF uses a dual-port 1

Fig. 13. Auto-correlation tests on (a) raw, and (b) post-processed random
numbers. Shannon entropy tests in (c).

kbit SRAM (512x2). The BM-uP implementation had an area
increase of 6.5x compared to baseline (NCM-uP), while the
number of instances increased by 11.3x. The BM-DDL-uP had
an area increase of 1.9x compared to BM-uP, but the number
of instances showed small reduction due to the absence of
inverters in differential logic styles.

B. Power Consumption

Dynamic power consumption was measured from 0.8V up
to 1.1V, for the NCM-uP, BM-uP, BM-DDL-uP, and RNG.
Nominal voltage is 1.0 V (see Fig. 12 (a) and (b)). We share the
same power supply pin with other non-related digital circuits
which had their clock disabled during experiments. Moreover,
static power was measured and excluded from all reported
values. The RNG was not active during measurements of
NCM-uP. The power reported for the RNG includes system
clock oscillator for sampling, RNG oscillator, LFSR/CASR
post-processing, XOR output network, and remasking XOR
gates.

C. Quality of Random Numbers

The National Institute of Standards and Technology (NIST)
published tests to assess the quality of random numbers [4].
Table II reports results for all tests. A total of 100 bitstreams
with 1 M bits each was used. All tests meet the suggested
passing criterion of 80%. Fig. 13 plots the autocorrelation
of 1 M (a) raw random bits, and (b) after post-processing
by LFSR/CASR logic. We used a sampling frequency of 3.4

(a)(b)0.800.850.900.951.001.051.102468Power @25C [mW]NCM-uP (rng oﬀ)BM-uP (rng on)BM-DDL-uP (rng on)0.800.850.900.951.001.051.10Power Supply [V]0.40.60.81.01.2Power @25C [mW]RNG0100200300400500Lags−0.0050−0.00250.00000.00250.0050Auto-correlation0100200300400500Lags−0.0050−0.00250.00000.00250.0050Auto-correlation104105106107Frequency [Hz]0.999850.999900.99995Entropy [bits]rawpost(a)(b)(c)Raw random numbersPost-processed random numbersDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

8

TABLE III
COMPARISON OF RNG RESULTS.

This work

JSSC’16
[31]

JSSC’16
[3]

JSSC’22
[50]

Technology
Entropy
Bit rate (Gb/s)
Area (µm2)
Power (mW)
Energy (fJ/bit)
Post-processing

65 nm
Jitter
12.8
2735
0.992
0.078
LFSR/CASR

14 nm
Meta
0.225
1088
1.5
6.67
AES

65 nm
Meta+Jitter
3
1609
5
1.67
None

130 nm
Meta
0.002
5561
-
-
VN8W

Notes: Power and energy reported for our work do not include the static
component.

MHz. Dashed lines represent the interval that contains 95% of
the data. Fig. 13 (c) plots the Shannon entropy for 1 M bits
at various sampling frequencies. Entropy was calculated using
intervals of 5 bits.

An statistical modeling of phase jitter entropy sources was
presented in [5]. Authors derived an expression for minimum
entropy rate. To use their expression, we measured the clock
period standard deviation of our RNG oscillator over 120 k
cycles. Our testchip divides the clock by 256 and routes the
signal to an output pin. Measured clock period mean was
716 ns, with 251 ps of standard deviation, which reﬂects the
accumulated thermal noise in our RNG oscillator. Oscillators
with high standard deviation values harvest more entropy for
the same sampling period. Similar jitter is also present in
our system clock oscillator and it was taken into account
during timing analysis as clock uncertainty—it does not affect
circuit functionality. The calculated minimum entropy for raw
random numbers sampled at 3.4 MHz is 0.41 bits (per random
bit). Using the model, 1.0 bit of entropy is achieved with
sampling frequency of 200 Hz or lower. Nevertheless, our
application tolerates lower entropy for increased throughput. If
a higher minimum entropy at increased throughput is required,
additional ROs can be XORed before the sampling register. In
that case, it is imperative to use ROs with relatively prime
number of stages to avoid frequency locking. Also notice that
the model does not include phase jitter from our sampling
clock, which could increase the calculated minimum entropy.
Our RNG produces 243 random bits each clock cycle,
therefore its total throughput at 56 MHz is 12.8 Gb/s. Further
details such as area, power, and energy efﬁciency are provided
in Table III. This lightweight, throughput focused RNG design
meets our requirement for Boolean masking operations, but
arguably, other sensitive contexts such as key generation,
padding, and nonces will require minimum entropy guarantees,
slower sampling frequencies, and forward/backward secrecy
in the post-processing—which increases the hardware size
signiﬁcantly. We recommend the interested reader to see AIS
31 standard for details [26].

D. Experimental Setup for Side-channel Analysis

Fig. 14 shows our experiment setup for side-channel anal-
ysis. We added a 75 Ohms resistor in series with the testchip
is conditioned by a high-speed
power supply. The signal

Fig. 14. Side-channel analysis acquisition setup.

ampliﬁer (OPA858, 5.5 GHz GBW) in a non-inverting con-
ﬁguration with gain of 7. A 0.84 V reference was connected
to the gain resistor to avoid clamping of the output signal.
The external chip power supply was set to 1.2 V instead of
the nominal 1.0 V, to account for the voltage drop in the
series resistor. Our oscilloscope has input bandwidth of 1 GHz.
The acquisition system is orchestrated by a desktop computer
which controls the oscilloscope using GPIB and communicates
to the testchip using an FPGA. The FPGA writes the encrypted
software using JTAG. All power traces use unique session
keys for memory protection. The having sampling rate is 10
GS/s. We used an open source Julia toolbox2 to perform the
correlation power analysis (CPA) with, and without dynamic
time warping (DTW) pre-processing. We attack only the ﬁrst
key byte during an AES encryption operation, targeting the
SBOX output using a hamming weight leakage model. Our
AES implementation uses multiplicative inverse over Galois
ﬁeld to calculate the SBOX output (lookup tables are not used).
Oscilloscope trigger is obtained from a testchip output set
by the microprocessor software 36 cycles before the sensitive
instruction. The number of samples logged in each power trace
is adjusted depending on clock edge randomization settings to
ensure all relevant clock cycles are captured.

E. Correlation Power Analysis

Correlation power analysis (CPA) uses a set of power traces
to extract secret information from a device. Traces record the
device manipulating the secret value with different input data.
For example, recorded power traces may include many AES
encryptions using the same key but different plain texts. CPA
attacks extract a few key bits in each iteration. The attacker
chooses a key candidate and creates a power consumption
hypothesis for each input data, using knowledge of the imple-
mented algorithm, and a leakage model (typically hamming-
weight). The correlation between the hypothesis vector and
the recorded power traces will be the highest when the correct
key is used.

Our side-channel analysis does not

include test vector
leakage assessment (TVLA) [6]. Such tests do not replace
conventional key extraction attacks, but provide a quick alter-
native to detect potential side-channel problems. Nevertheless,
they require saving a long power trace that includes a series
of encryptions, which would use an enormous amount of os-
cilloscope memory due to the low throughput of our hardware

2https://github.com/Riscure/Jlsca

Faraday cage-+453ROPA85875RGPIBNFSJTAGTriggerUARTTestchipFPGA75R0.84V1.2VScope1GHz10GS/sDesktopComputerServer64 CPUsRAM 256 GBDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

9

Fig. 15. CPA coefﬁcient versus number of traces for different sets of counter-measures. Results without clock edge randomization for (a) NCM-uP; (b)
BM-uP, and (c) BM-DDL-uP; results for original netlist (NCM-uP) using clock edge randomization of (d) 25%, (e) 50%, and (f) 75%; and results using DTW
pre-processing for trace alignment on NCM-uP with clock edge randomization of (g) 25%, (h) 50%, and (i) 75%.

ization on the baseline microprocessor (NCM-uP). We tested
three types of clock edge randomization. In Fig. 15 (d) 25%
of clock edges were skipped, and it took 850 k power traces to
expose the key. The required number of traces to expose the
key increased dramatically to 6.2 M, and 9.1 M, as we skipped
50% and 75% of the clock edges, as respectively shown in Fig.
15 (e) and (f).

Pre-processing techniques such as dynamic time warping
(DTW) may be used to align power traces before a CPA
attack [39]. The DTW algorithm originated from speech
recognition systems to match spoken words to a database
containing prerecorded words with different timing. We use
a FastDTW variant which has complexity O(T k), where T is
number of traces, and k is trace length [47]. In our experiments
with DTW pre-processing, the radius parameter was set to 90.
Larger radius enhance representation accuracy of the original
DTW algorithm, but signiﬁcantly increase computing time and
memory usage.

Fig. 15 (g), (h), and (i) show the CPA attack results with
DTW pre-processing on the baseline microprocessor (NCM-
uP), with clock randomization enabled. In Fig. 15 (g), with
25% of clock cycles skipped,
the key was exposed with
only 60 k traces, which is 14.2x fewer traces compared
to CPA without DTW pre-processing, as shown in Fig. 15
(d). However, it takes nearly 10x longer computation time.
Similarly, Fig. 15 (h), and (i), with 50% and 75% of clock
cycles skipped, show that the key was not exposed after a 500
k traces CPA attack using DTW pre-processing, as opposed to
the 6.5 M and 9.1 M traces required to expose the key without
DTW.

We also assess the information leakage of all counter-
measures combined. For that, we skip 50% of clock cycles
at the BM-DDL-uP microprocessor, which implements both

Fig. 16. CPA coefﬁcient versus number of traces for BM-DDL-uP with clock
edge randomization of 50%. Results (a) without DTW trace pre-processing
and (b) with DTW trace pre-processing.

architecture. Future work shall use a faster architecture so that
we can perform these tests.

Fig. 15 shows CPA results, plotting the correlation versus
number of traces used in the attack. Each plot has 256 lines,
one for each key candidate. The correct key (red) is exposed
when its correlation is the highest. In Fig. 15 (a), the baseline
implementation with no counter-measures (NCM-uP) had its
key exposed with 375 power traces. Results with Boolean
masking are shown in Fig. 15 (b), where the key is exposed
with 6200 power traces. If Boolean masking is combined with
the dynamic logic implementation, Fig. 15 (c), it takes 375 k
power traces, 1000x compared to the baseline, to expose the
key.

Next, we investigated effectiveness of the clock random-

NCM-uP200k Traces25% cyclesskipped(DTW tracepreproc.)NCM-uP500k Traces50% cyclesskipped(DTW tracepreproc.)NCM-uP500k Traces75% cyclesskipped(DTW tracepreproc.)(a) (b)(c)(f)(i)(e)(h)(d)(g)850k tracesto exposure60k tracesto exposure6.5M tracesto exposure9.1M tracesto exposure375k tracesto exposureKey was notexposedKey was notexposedNumber of tracesNumber of tracesNumber of tracesCorrelationCorrelationCorrelation0.20.40.60.81.0(x1e6)0.050.10500001000001500002000000.10.20.32004006008001000240.20.40.60.81.0(x1e7)0.020.041000002000003000004000005000000.050.100.150.202000400060008000100000.51.00.20.40.60.81.0(x1e7)0.020.041000002000003000004000005000000.10.20.20.40.60.81.0(x1e6)0.050.100.15NCM-uP1000 TracesNo cyclesskippedLogging: 53sec (77MB); processing: 1minLogging: 21h (187GB); processing: 1hLogging: 4h (37GB); processing: 10hLogging: 9min (770MB); processing: 2minLogging: 9 days (1.8TB); processing: 10hLogging: 10h (93GB); processing: 23hLogging: 15h (75GB); processing: 27minLogging: 14 days (3.7TB); processing: 26hLogging: 17h (185GB); processing: 2 days375 tracesto exposure6200 tracesto exposureBM-uP10k TracesNo cyclesskippedBM-DDL-uP1M TracesNo cyclesskippedNCM-uP10M Traces75% cyclesskippedNCM-uP10M Traces50% cyclesskippedNCM-uP1M Traces25% cyclesskipped(a)(b)Key was notexposedKey was notexposedLogging: 18 days (3.6TB); processing: 20hLogging: 2 days (374GB); processing: 4 days0.60.81.01.21.41.61.82.0Number of Traces(x1e7)0.0060.0080.010Correlation0.81.01.21.41.61.82.0Number of Traces(x1e6)0.0200.0250.0300.035CorrelationBM-DDL-uP, 2M Traces50% cycles skipped(DTW trace preproc.)BM-DDL-uP20M Traces50% cyclesskippedDOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

10

TABLE IV
COMPARISON WITH OTHER SECURE MICROPROCESSORS.

This work

CHES’07
[34]

CARDIS’16
[18]

DAC’19
[12]

Technology
Architecture
Datapath
Clock rand
Entropy source
PRNG
Rand bits/cycle
Mem addr Scr
Mem data enc
Masking
Fully masked
Pre-charge logic
Methodology
Traces to discl.
Max Traces
Attack types
Open-source

65 nm
RISC-V
1 bit
Yes
Jitter
Yes
243
Yes
Yes
[8]
Yes
DDL
Auto.
375
20 M
CPA/DTW
Yes [42]

130 nm
8051
8 bit
No
No
Not avail
1
No
No
MDPL [35]
Yes*
MDPL [35]
Not avail
5 k
300 k
DPA
No

FPGA
RISC-V
32 bit
No
No
Not avail
–
No
No
DOM [21]
No
No
Manual
–
100 M
TVLA
No

Notes: (*) few details were provided in the publication.

FPGA
RISC-V
32 bit
No
No
Not avail
–
No
Yes
TI [33]*
Yes*
No
Not avail
15 k
3 M
TVLA
No

Boolean masking and DDL. Fig. 16 shows that CPA attacks
using (a) 20 M traces without pre-processing, and (b) 2 M
traces with DTW, were not enough to expose the key.

F. Comparison with Prior Work

There are several

implementations of Boolean masked
microprocessors in the literature [12], [18], [34]. Table IV
provides a comparison of our work with previous publications
with respect to several key security features listed in the ﬁrst
column. It is clear from Table IV that our work covers a broad
range of techniques and components necessary to implement
a secure microprocessor.

Unlike other works, we used a CPU implementation with
datapath size of 1 bit. Such decision was made due to area
constraints in our testchip, but our methodology can be applied
to any digital design, of any size. In fact, our RTL and
implementation scripts are publicly available to interested re-
searchers [42]. However, comparing the effectiveness of coun-
termeasures from different publications is not trivial. Changes
in the acquisition system, and the presence of combined coun-
termeasures make it hard to draw any deﬁnitive conclusions.
It is also important to mention that the effectiveness of our
countermeasures will likely increase when applied to larger
designs. In addition to higher switching noise, the sensitive
signals of larger designs will be relatively weaker, compared
to the total power consumption, requiring attackers to collect
more power traces.

V. CONCLUSION

We demonstrated a bit-serial RISC-V microprocessor im-
plementation with no plain-text data. Our design uses Boolean
masking at the logic level, and dynamic domino logic at the
transistor level. We selected a a set of counter-measures that
require no changes to the input RTL code. Unlike previous
literature, our methodology is fully integrated with CAD
tools, and can be applied to digital designs of any size or
complexity. We also provided details on other key components

of secure ICs, such as clock randomizer, memory protection,
and random number generator. The random numbers generated
with our RNG pass on all NIST tests. Side-channel analysis
on the baseline implementation extracted the AES key using
only 375 traces, while our secure microprocessor was able to
withstand attacks using 20 M traces.

REFERENCES

[1] P Alfke. Efﬁcient shift registers, LFSR counters, and long pseudo

random sequence generators, 1996.

[3] S-G Bae, Y Kim, Y Park, and C Kim.

[2] M Avital, H Dagan, O Keren, and A Fish. Randomized multitopology
logic against differential power analysis. TVLSI, 23(4):702–711, 2014.
3-Gb/s high-speed true
random number generator using common-mode operating comparator
and sampling uncertainty of d ﬂip-ﬂop. JSSC, 52(2):605–610, 2016.
[4] LE Bassham III, AL Rukhin, J Soto, JR Nechvatal, ME Smid,
EB Barker, SD Leigh, M Levenson, M Vangel, DL Banks, and Others.
SP 800-22 Rev. 1a. A statistical test suite for random and pseudorandom
number generators for cryptographic applications, 2010.

[5] M Baudet, D Lubicz, J Micolod, and A Tassiaux. On the security
of oscillator-based random number generators. Journal of Cryptology,
24(2):398–425, 2011.

[6] G Becker, J Cooper, E DeMulder, G Goodwill, J Jaffe, G Kenworthy,
T Kouzminov, A Leiserson, M Marson, P Rohatgiand, and S Saab. Test
vector leakage assessment (TVLA) methodology in practice, 2013.
[7] D Bellizia, G Scotti, and A Triﬁletti. TEL logic style as a countermea-
sure against side-channel attacks: Secure cells library in 65nm CMOS
and experimental results. TCAS I, 65(11):3874–3884, 2018.

[8] A Biryukov, D Dinu, YL Corre, and A Udovenko. Optimal ﬁrst-order
boolean masking for embedded IoT devices. In CARDIS, pages 22–41.
Springer, 2017.

[9] M Bucci, L Giancane, R Luzzi, and A Triﬁletti. Three-phase dual-rail

pre-charge logic. In CHES, pages 232–241, 2006.

[10] K Cattell and S Zhang. Minimal cost one-dimensional linear hybrid
cellular automata of degree through 500. JET, 6(2):255–258, 1995.

[11] LT Clark, SB Medapuram, and DK Kadiyala.

SRAM circuits for
true random number generation using intrinsic bit instability. TVLSI,
26(10):2027–2037, 2018.

[12] E De Mulder, S Gummalla, and M Hutter. Protecting RISC-V against

side-channel attacks. In DAC, pages 1–4. IEEE, 2019.

[13] A Dubey, R Cammarota, and A Aysu. BoMaNet: Boolean masking of
In Intl. Conf. On Computer Aided Design,

an entire neural network.
pages 1–9. IEEE, 2020.

[14] A Ghosh, D Das, J Danial, V De, S Ghosh, and S Sen. Syn-STELLAR:
an EM/power SCA-resilient AES-256 with synthesis-friendly signature
attenuation. JSSC, 57(1):167–181, 2021.

[15] L Goubin and J Patarin. DES and differential power analysis the
“duplication” method. In CHES, pages 158–172. Springer, 1999.
[16] H Gross. Sharing is caring—on the protection of arithmetic logic
units against passive physical attacks. In Intl. Ws. on Radio Frequency
Identiﬁcation: Security and Privacy Issues, pages 68–84. Springer, 2015.
[17] H Groß, R Iusupov, and R Bloem. Generic low-latency masking in

hardware. TCHES, pages 1–21, 2018.

[18] H Gross, M Jelinek, S Mangard, T Unterluggauer, and M Werner.
Concealing secrets in embedded processors designs. In CARDIS, pages
89–104. Springer, 2016.

[19] H Groß and S Mangard. Reconciling d + 1 masking in hardware and

software. In CHES, pages 115–136. Springer, 2017.

[20] H Gross and S Mangard. A uniﬁed masking approach. Journal of

Cryptographic Engineering, 8(2):109–124, 2018.

[21] H Groß, S Mangard, and T Korak. Domain-oriented masking: Com-
pact masked hardware implementations with arbitrary protection order.
Cryptology ePrint Archive, 2016.

[22] H Gross, K Stoffelen, L De Meyer, M Krenn, and S Mangard. First-order
masking with only two random bits. In Ws. on Theory of Implementation
Security, pages 10–23. ACM, 2019.

[23] F Imeson, A Emtenan, S Garg, and M Tripunitara. Securing computer
hardware using 3d integrated circuit (IC) technology and split manufac-
turing for obfuscation. In USENIX Security Symposium, pages 495–510,
2013.

[24] Y Ishai, A Sahai, and D Wagner. Private circuits: Securing hardware
In Intl. Cryptology Conf., pages 463–481.

against probing attacks.
Springer, 2003.

DOI: 10.1109/TVLSI.2022.3203307

COPYRIGHT ©2022 IEEE

11

[25] R Jevtic, M Ylitolva, C Calonge, M Ojanen, T Santti, and L Koski-
nen. EM side-channel countermeasure for switched-capacitor DC–DC
converters based on amplitude modulation. TVLSI, 29(6):1061–1072,
2021.

[26] W Killmann and W Schindler. A proposal for: Functionality classes for

random number generators, Version 2.0, 2011.

[27] P Kocher, J Jaffe, and B Jun. Differential power analysis. In Annual

Intl. Cryptology Conf., pages 388–397. Springer, 1999.

[28] R Kumar, X Liu, V Suresh, HK Krishnamurthy, S Satpathy, MA Anders,
H Kaul, K Ravichandran, V De, and SK Mathew. A time-/frequency-
domain side-channel attack resistant AES-128 and RSA-4K crypto-
processor in 14-nm CMOS. JSSC, 56(4):1141–1151, 2021.

[29] R Kumar, V Suresh, M Kar, S Satpathy, MA Anders, H Kaul, A Agar-
wal, S Hsu, GK Chen, RK Krishnamurthy, et al. A 4900-µm2
839-Mb/s side-channel attack-resistant AES-128 in 14-nm CMOS with
heterogeneous Sboxes, linear masked mixcolumns, and dual-rail key
addition. JSSC, 55(4):945–955, 2020.

[30] S Mangard, T Popp, and BM Gammel. Side-channel leakage of masked
CMOS gates. In Cryptographers Track at the RSA Conf., pages 351–365.
Springer, 2005.

[31] SK Mathew, D Johnston, S Satpathy, V Suresh, P Newman, MA Anders,
H Kaul, A Agarwal, SK Hsu, G Chen, et al. µRNG: a 300–950 mV,
323 Gbps/W all-digital full-entropy true random number generator in
14 nm FinFET CMOS. JSSC, 51(7):1695–1704, 2016.

[32] MA Morrison, N Ranganathan, and J Ligatti. Design of adiabatic
dynamic differential logic for DPA-resistant secure integrated circuits.
TVLSI, 23(8):1381–1389, 2014.

[33] S Nikova, C Rechberger, and V Rijmen. Threshold implementations
against side-channel attacks and glitches. In Intl. Conf. on Information
and Communications Security, pages 529–545. Springer, 2006.

[34] T Popp, M Kirschbaum, T Zefferer, and S Mangard. Evaluation of the
masked logic style MDPL on a prototype chip. In CHES, pages 81–94,
2007.

Kleber Stangherlin Kleber received his B.Sc. in
Electrical Engineering at PUCRS, and M.Sc.
in
Microelectronics at UFRGS, both in Brazil. He
has more than 6 years of industry experience de-
signing security focused integrated circuits. He had
key contributions to the cryptographic cores and
countermeasures used in the ﬁrst EAL 4+ certiﬁed
chip designed in the southern hemisphere. Currently,
Kleber is pursuing a PhD at University of Waterloo
in Canada, where he conducts research in hardware
security.

Manoj Sachdev Manoj Sachdev is a Professor and
Interim Department Chair in the Department of Elec-
trical and Computer Engineering at the University of
Waterloo. He has contributed to over 180 conference
and journal publications, and has written 5 books.
He also holds more than 30 granted US patents.
Along with his students and colleagues, he has
received several international research awards. He is
a Fellow of the Institute of Electrical and Electronics
Engineers (IEEE), and Fellow of the Engineering
Institute of Canada. Professor Sachdev serves on the
editorial board of the Journal of Electronic Testing: Theory and Applications.
He is also a member of program committee of IEEE Design and Test in
Europe conference.

[35] T Popp and S Mangard. Masked dual-rail pre-charge logic: DPA-
resistance without routing constraints. In CHES, pages 172–186, 2005.
Electromagnetic analysis (EMA):
In CARDIS, pages

[36] J-J Quisquater and D Samyde.

Measures and counter-measures for smart cards.
200–210. Springer, 2001.

[37] JM Rabaey, AP Chandrakasan, and B Nikolic. Digital integrated circuits,

volume 2. Prentice Hall Englewood Cliffs, 2002.

[38] O Reparaz, B Bilgin, S Nikova, B Gierlichs, and I Verbauwhede.
In Annual Cryptology Conf., pages

Consolidating masking schemes.
764–783. Springer, 2015.

[39] S Salvador and P Chan. Toward accurate dynamic time warping in linear
time and space. Intelligent Data Analysis, 11(5):561–580, 2007.
[40] A Singh, M Kar, S K Mathew, A Rajan, V De, and S Mukhopadhyay.
Improved power/EM side-channel attack resistance of 128-bit AES
engines with random fast voltage dithering. JSSC, 54(2):569–583, 2018.
Improving the

[41] D Sokolov, J Murphy, A Bystrov, and A Yakovlev.

security of dual-rail circuits. In CHES, pages 282–297, 2004.

[42] K Stangherlin and M Sachdev. Design and implementation of a secure
https://github.com/cdrlabs-waterloo/

RISC-V microprocessor (code).
2022-07-15.

[43] K Tiri, M Akmal, and I Verbauwhede. A dynamic and differential
CMOS logic with signal independent power consumption to withstand
differential power analysis on smart cards. In E-SSCC, pages 403–406.
IEEE, 2002.

[44] K Tiri and I Verbauwhede. A logic level design methodology for a secure
In DATE, volume 1,

DPA resistant ASIC or FPGA implementation.
pages 246–251. IEEE, 2004.

[45] TE Tkacik. A hardware random number generator.

In CHES, pages

450–453. Springer, 2002.

[46] E Trichina. Combinational logic design for AES subbyte transformation

on masked data. Cryptology ePrint Archive, 2003.

[47] JGJ van Woudenberg, MF Witteman, and B Bakker. Improving differ-
ential power analysis by elastic alignment. In Cryptographers Track at
the RSA Conf., pages 104–119. Springer, 2011.

[48] S Wolfram. Random sequence generation by cellular automata. Ad-

vances in Applied Mathematics, 7(2):123–169, 1986.

[49] K Yang, D Blaauw, and D Sylvester. An all-digital edge racing
true random number generator robust against PVT variations. JSSC,
51(4):1022–1031, 2016.

[50] R Zhang, X Wang, K Liu, and H Shinohara. A 0.186-pJ per bit latch-
based true random number generator featuring mismatch compensation
and random noise enhancement. JSSC, 2022.

