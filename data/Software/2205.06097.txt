2
2
0
2

y
a
M
2
1

]
E
S
.
s
c
[

1
v
7
9
0
6
0
.
5
0
2
2
:
v
i
X
r
a

Viable Algorithmic Options for
Creating and Adapting Emergent Software Systems

Todd Wareham
Department of Computer Science
Memorial University of Newfoundland
St. John’s, NL Canada
(Email: harold@mun.ca)

Ronald de Haan
Institute for Logic, Language, and Computation
Universiteit van Amsterdam
Amsterdam, The Netherlands
(Email: me@ronalddehaan.eu)

May 13, 2022

Abstract: Given the complexity of modern software systems, it is of great
importance that such systems be able to autonomously modify themselves,
i.e., self-adapt, with minimal human supervision. It is critical that this
adaptation both results in reliable systems and scales reasonably in re-
quired memory and runtime to non-trivial systems. In this paper, we ap-
ply computational complexity analysis to evaluate algorithmic options for
the reliable creation and adaptation of emergent software systems relative
to several popular types of exact and approximate eﬃcient solvability. We
show that neither problem is solvable for all inputs when no restrictions
are placed on software system structure. This intractability continues
to hold relative to all examined types of eﬃcient exact and approximate
solvability when software systems are restricted to run (and hence can
be veriﬁed against system requirements) in polynomial time. Moreover,
both of our problems when so restricted remain intractable under a variety
of additional restrictions on software system structure, both individually
and in many combinations. That being said, we also give sets of addi-
tional restrictions that do yield tractability for both problems, as well
as circumstantial evidence that emergent software system adaptation is
computationally easier than emergent software system creation.

1

Introduction

Given the complexity of modern software systems and the increasing need to modify
such systems to handle both unplanned changes in system requirements and varying

1

 
 
 
 
 
 
operating environments, such systems must be able to autonomously modify them-
selves, i.e., self-adapt, with minimal human supervision [1, 2, 3]. Over the last 25
years, a great deal of research has been done on self-adaptive software systems, and
a number of such systems based on various types of adaptation controllers (e.g.,
MAPE-K feedback loop [4], model-predictive [5], general control-theoretic [6]) have
been created (see also [1, 7, 8]). Certifying that adaptation does not cause the re-
sulting systems to violate functional and/or non-functional system requirements, i.e.,
validation and veriﬁcation (V&V), is a major research challenge [8, page 21]. Such
V&V must be done quickly enough that the proposed adaptations are still valid (to
handle rapidly-changing operating environments). This is further complicated by the
requirement that enough computational eﬀort be put into the adaptation space search
process to ensure that the adapted system optimizes system performance as much as
possible (to satisfy system user expectations).

A valuable complement to algorithm development work would be to establish what
the general algorithmic options are for software system creation and adaptation algo-
rithms that are guaranteed to satisfy speciﬁed functional and non-functional system
requirements while optimizing adapted system performance. This can be done using
the tools and techniques of computational complexity analysis [9, 10, 11]. The results
of such analyses can be used not only to establish those situations in which known
algorithms are the best possible but also to guide the development of new algorithms
(by highlighting relative to which types of eﬃcient solvability such algorithms can
and cannot exist).

A good test case for the utility of such complexity analyses would be a type of
self-adaptive systems called emergent software systems [12, 13]. Such systems initially
self-assemble from a provided library of software components to satisfy basic system
requirements, and then continuously self-adapt with the assistance of a learning al-
gorithm that uses collected system environment events and performance metrics to
optimize a reward function such as system runtime or memory usage. An emergent
web server based on a library of 30 components has been constructed under this
paradigm and seems to function well [13]. However, as noted on [12, page 14],

. . . [the] learning algorithm, which is based on an exhaustive exploration
phase, is not designed to scale up to large systems with thousands of
compositions, but rather serves as a proof of concept and useful baseline
against which to compare more sophisticated algorithms. This is an active
research area for which we continue to develop more eﬃcient and scalable
solutions . . .

Ongoing work has focused on exploiting such strategies as making components encode
single responsibilities and dividing large systems into distributed collections of smaller

2

(and hopefully more manageable) subsystems [14, 15]. It is precisely at this current
stage of new algorithm development that computational complexity analyses might
be most useful.

1.1 Previous Work

Computational complexity analyses have been done previously for component-based
software system creation by component selection [16, 17] and component selection
with adaptation [18], with [18, 17] having the additional requirement that the number
of components in the resulting software system be minimized. Given the intractability
of all of these problems, subsequent work has focused on eﬃcient approximation algo-
rithms for component selection. Though it has been shown that eﬃcient algorithms
that produce software systems whose number of components is within a constant mul-
tiplicative factor of optimal are not possible in general [19], eﬃcient approximation
algorithms are known for a number of special cases [20, 21, 19]. All of these analy-
ses assume that any component can be composed with any other component, in the
sense that function deﬁnitions not given in a component c can be obtained by compo-
sition of c with any other components that have the required function deﬁnitions, i.e.,
component composition is not regulated using component interfaces. Moreover, none
of the formalizations used include speciﬁcation of the internal structure of software
systems, system requirements, and components that are detailed enough to allow in-
vestigation of restrictions on these aspects that could make component selection or
component selection with adaptation tractable.

Only one analysis to date has incorporated a component model which allows
investigation of the tractability eﬀects of restrictions on system requirement, com-
ponent internal, and software system structure, namely that in in [22] (subsequently
reprinted as [23]; see also [24] for the full version with proofs of results). The focus in
this work was on exact polynomial-time solvability and ﬁxed-parameter tractability of
component-based software system creation and adaptation, where system adaptation
is in response to changes in the functional system requirements. The authors showed
that both of these problems are intractable in general and remain so under a variety of
restrictions on system requirement, component, and software system structure. This
was done relative to radically restricted components (single if-then-else blocks)
and software systems (two-level reactive systems). While components in this model
cannot arbitrarily compose in the sense described above, component composition was
implicitly regulated by the the combination of two-level system structure and a pa-
rameter restricting the number of types of components in a system, and there was
no notion of a component interface, let alone interfaces providing state variables or
functions with input parameters and/or returned values.

3

1.2 Summary of Results

In this paper, we present the ﬁrst computational complexity analyses of the problems
of emergent software system creation and adaptation. These problems can be stated
informally as follows (and are described in more detail in Section 2):

Emergent Software Creation (ESCreate): Derive (possibly by using a sys-
tem environment function Env()) an emergent software system S relative to
given libraries Lint and Lcomp of software interfaces and components that satis-
ﬁes a given set R of software requirements and has the best possible value for a
speciﬁed reward function Rew().

Emergent Software Adaptation (ESAdapt): Given an emergent software sys-
tem S relative to given libraries Lint and Lcomp of software interfaces and com-
ponents that satisﬁes a given set of software system requirements R, derive
(possibly by using a system environment function Env()) an emergent software
system S′ relative to Lint and lcomp that satisﬁes R and has the best possible
value for a speciﬁed reward function Rew().

We consider the following types of eﬃcient solvability (described in more detail in
Section 3.1):

1. Polynomial-time exact solvability, such that a polynomial-time algorithm pro-
duces the correct output for a given input either (a) all the time [10] or (b)
when such an output is known to exist (promise solvability).

2. Polynomial-time approximate solvability, such that a polynomial-time algo-
rithm produces the correct output for a given input either (a) in all but a
small number of cases [25] or (b) with a high probability [26], or, in the case of
a problem that requires an output that optimizes some cost measure, (c) pro-
duces an output for a given input whose cost is within some arbitrarily small
fraction of optimal [27].

3. Eﬀectively polynomial-time exact restricted solvability (e.g., ﬁxed-parameter
(fp-)tractability [9]), such that an algorithm produces the correct output for a
given input in what is eﬀectively polynomial time when certain aspects of that
input are of restricted value, e.g., the number of components in the given library
or any valid assembled software system is small.

Relative to these types of solvability and various conjectures that are widely believed
to be true within the Computer Science community, e.g. P
= NP [28, 10], we prove
the following results (Section 3):

4

6
• Neither ESCreate nor ESAdapt is solvable by an algorithm (regardless of run-
time or memory usage) that gives the correct output for every input, i.e., both
of these problems are unsolvable in the same sense as Turing’s classic Halting
Problem [29] (Sections 3.2.1 and 3.3.1, respectively).

• Neither ESCreate nor ESAdapt is solvable by a polynomial-time algorithm in
the sense (1a) above and ESCreate is not solvable by a polynomial-time algo-
rithm in sense (1b) above, even when software systems are restricted to run
in and hence can be veriﬁed against requirements in polynomial time (Sections
3.2.2 and 3.3.2, respectively).

• Neither ESCreate nor ESAdapt is solvable by a polynomial-time algorithm in
the senses (2a), (2b), or (2c) above, even when software systems are restricted
to run in and hence can be veriﬁed against requirements in polynomial time
(Sections 3.2.3 and 3.3.3, respectively).

• Neither ESCreate nor ESAdapt is ﬁxed-parameter tractable in sense (3) above

relative to restrictions of the values of the following aspects of the input:

– The number of software component interfaces in Lint.

– The number of software components in Lcomp.

– The maximum number of components implementing an interface.

– The maximum number of interfaces provided by a component.

– The maximum number of interfaces required by a component.

– The maximum number of components in a software system.

This ﬁxed-parameter intractability holds both when software systems are re-
stricted to run in and hence can be veriﬁed against requirements in polyno-
mial time and relative to many combinations of the aspects listed above, often
when aspects are restricted to small constant values. That being said, there
are several combinations of aspect-restrictions that do yield ﬁxed-parameter
tractability (Sections 3.2.4 and 3.3.4, respectively).

the results above hold for ESCreate (except

All of
those related to cost-
inapproximability) relative to any choices of Env() and Rew() and for ESAdapt
(and ESCreate for cost-inapproximability) relative to any choice of Env() and one of
two speciﬁed reward functions, namely Rew#comp(S) (the number of components in
a software system) and RewCodeB(S) (the total size of the interface and component
code is a software system). This, in combination with the unresolved ﬁxed-parameter
status of certain aspect-combinations at this time, suggests that emergent software

5

adaptation may in general be easier to do than emergent software creation (Section
4.2).

The list above may, at ﬁrst glance, be read as saying that emergent software
system creation and adaptation are not possible under any circumstances. However,
this bleak interpretation is very much contrary to our intent. We consider only a
small subset of possible restrictions on emergent software systems (Table 1), and our
analysis, though complete with respect to some of these restrictions (Tables 5–7), is
still incomplete with respect to the whole subset, let alone the universe of possible
restrictions. The successes in real-world emergent software systems to date show
that tractability is indeed possible in some circumstances. The key issue now is to
determine in detail those circumstances in which tractability does and does not hold.
Our results should thus be seen not as ﬁnal statements but rather interim guidelines
on how to address this issue. We see the involvement of software engineers in this
process as essential (Section 4.3). To this end, we have tried to make the reasoning
used to derive our results (both in general (Section 3.1) and in our proofs) accessible
to software engineers, to make plain to them the rather limited circumstances under
which our results hold and thus enable them to break these results by suggesting
additional restrictions relative to which real-world emergent software system creation
and adaptation are provably tractable.

Before we close out this subsection, two issues with respect to the results listed
above should be noted. First, though certain notations (e.g., our conception of soft-
ware system requirements) and some of the general ideas underlying proof techniques
developed in [22, 24] are re-used in this paper, none of the results for component-based
software system creation derived in [22, 24] carry over. This is because the restrictions
on overall system structure and the number of types of components in a system crit-
ical to the proofs of those results in [22, 24] have no analogues in problems ESCreate
and ESAdapt investigated here. Second, all results in this paper are derived relative
to the classic Turing machine model of computation, and hence do not directly ad-
dress issues of eﬃcient solvability or unsolvability under other models of computation
such as quantum computers. That being said, as will be discussed in Section 4.3, our
results indirectly imply certain consequences for the eﬃcient solvability of ESCreate
and ESAdapt under such alternative models of computation.

1.3 Organization of the Paper

Our paper is organized as follows. In Section 2, we summarize the emergent software
system model given in [12, 13] and formalize the problems of emergent software system
creation and adaptation. In Section 3, we ﬁrst in Section 3.1 describe several popular
conceptions of eﬃcient solvability and then in Sections 3.2 and 3.3 assess the eﬃcient
solvability of emergent software system creation and adaptation, respectively, relative

6

to each of these conceptions. In order to focus in the main text on the implications
of our results, proofs of several of these results are given in an appendix. Our results
are summarized and discussed in Section 4. Finally, our conclusions and directions
for future work are given in Section 5.

2 Formalizing Emergent Software Creation and

Adaptation

In this section, we ﬁrst review the basic entities in the model of emergent software
given in [12, 30, 13] — namely, software system requirements, interfaces and compo-
nents, component-based software systems, and emergent software systems. We then
formalize two computational problems associated with emergent software system cre-
ation and adaptation.

The basic entities in our model are formalized as follows:

, vij (xk)

• Software system requirements: The requirements will be a set R =

r1, r2,
of input-output pairs where each pair rj = (ij, oj) consists of an input
. . . , r|R|}
vij (x1), vij (x2), . . . ,
ij deﬁned by a particular sequence of truth-values ij =
, relative to each of the Boolean variables xk
vij (x|X|)
in set X =
. As
such, these are functional requirements describing wanted system input-output
behaviors and correspond to the pre-speciﬁed abstract goal of the system [15,
page 3]. An example set of software system requirements is given in part (a) of
Figure 1.

h
o1, o2, . . . , o|O|}

∈ {
x1, x2, . . . , x|X|}

and an output oj from set O =

T rue, F alse
}

{

{

{

i

• Interfaces and Components: We use the runtime component model under-
lying the Dana programming language as speciﬁed in [30, 13]. In particular,
following [13, Page 335], let an interface be a set of function prototypes, each
comprising a function name, return type and parameter types, and a set of
transfer ﬁelds, typed pieces of state that persist across alternate implementa-
tions of the interface during runtime adaptation. A component has one or
more provided interfaces and zero or more required interfaces; the component
has implementations for all functions speciﬁed in the provided interfaces, and
these implementations in turn call upon functions and transfer ﬁelds speciﬁed
in the required interfaces. We will assume that all available interfaces and com-
ponents are stored in libraries Lint and Lcomp, respectively. Example interface
and component libraries relative to the software system requirements in part (a)
of Figure 1 are given shown in parts (b) and (c) of Figures 1 and 2, respectively.

7

req.
r1
r2
r3
r4
r5

x1 x2 x3 x4 x5
T T T T T
F T
F
T F
F
F
F
F
F
F
F
F
F
F
T T T F T

output
2
1
2
2
3

interface intSystem

void systemMain(Input I)

void callProc1(Input I)

(a)

interface intProc1

}

}

interface intProc2

interface intProc3

void callProc2(Input I)

void callProc3(Input I)

{

{

{

{

}

interface intProc

void proc(Input I)

{

}

}

(b)

Figure 1: An Example Emergent Software System (Adapted from [22, Figure 1]).
(a) Software requirements R =
deﬁned on Boolean variables X =
r1, r2, r3, r4, r5}
and output-set O =
x1, x2, x3, x4, x5}
. (b) A sample component interface
{
}
{
library Lint consisting of ﬁve interfaces.

1, 2, 3

{

Note that the interfaces and components in Figures1 and 2 (and indeed all
subsequent interfaces and components speciﬁed in this paper) are described
using a notation approximating that of the Dana programming language, e.g.,
[13, Figure 2]. This is done to ensure both that the proofs of results given here do
not invoke programming language features more powerful than those available in
Dana and that these results are hence applicable to emergent software systems
as described in [12, 30, 13], which are written in Dana.

• Component-based software systems: We use the model of component-
based software systems speciﬁed in [12, 30, 13]. In particular, given interface
and component libraries Lint and Lcomp and a base component c
Lcomp im-
plementing a main function, a valid component-based software system
S consists of a set of component-choices from Lcomp including c that not only
implements all required interfaces of c but also recursively implements all re-

∈

8

component System1

component System2

provides intSystem
requires intProc1, intProc2, intProc3

void systemMain(Input I)

if vI (x1) then callProc1(I)
elsif vI (x5) then callProc2(I)
else callProc3(I)

{

}}

component Proc1

provides intProc1
requires intProc

void callProc1(Input I)

proc(I)

}}

component Proc3

provides intProc3
requires intProc

void callProc3(Input I)

proc(I)

}}

component ProcA

provides intProc
void proc(Input I)

{

{

if vI (x4) then output 2
elsif not vI (x3) then output 1
elsif vI (x5) then output 3
else a1

}}

component ProcC

provides intProc
void proc(Input I)

if vI (x4) then output 2
else output 2

{

{

{
{

{
{

provides intSystem
requires intProc1

void systemMain(Input I)

{

{

callProc1(I)

}}

component Proc2

{

provides intProc2
requires intProc
void callProc2(I)

{
{

proc(I)

}}

component Base
void main(Input I)

{

{
systemMain(Input I)

}}

component ProcB

provides intProc
void proc(Input I)

{
{

if not vI (x2) then output 1
elsif not vI (x4) then output 2
else output 3

}}

component ProcD

provides intProc
void proc(Input I)

{

output 2

}}

}}

(c)

Figure 2: An Example Emergent Software System (Cont’d). (c) A sample software
component library Lcomp consisting of ten components.

9

Base

intSystem

System1

intProc1

intProc2

intProc3

Base

intSystem

System2

intProc1

Proc1

Proc2

Proc3

Proc1

intProc

intProc

intProc

intProc

ProcA

ProcC

ProcD

ProcB

Figure 3: An Example Emergent Software System (Cont’d). (d) Component wiring
trees corresponding to two valid component-based software systems for R in part (a)
based on Lint, Lcomp, and base component Base
Lcomp given in parts (b) and (c).
Note that interfaces intSystem and intProc can each be implemented by multiple
components (namely, System1 and System2 (intSystem) and ProcA, ProcB, ProcC,
and ProcD (intProc)) and are hence key in allowing component choices yielding
diﬀerent software systems; this is acknowledged by putting dashed boxes around
these interfaces in the component wiring trees diagrams.

∈

quired interfaces of those component-choices and their sub-component-choices,
if any. The interface-connections between these components are called wirings.
In order to allow data transfer ﬁelds to hold diﬀerent values relative to diﬀerent
implementations of an interface by the same component, these implementations
are done relative to copies of that component. Moreover, in cases where a
component provides multiple interfaces, diﬀerent implementations of that com-
ponent relative to two of those interfaces are done relative to reduced copies of
that component, both of which only contain code for and thus provide only those
services in the component speciﬁed by their respective implementing interfaces.

Any valid component-based software system has an associated directed vertex-
and arc-labeled tree in which the vertices are components, the arcs are the
wirings, and the vertices and arcs are labeled with the names of the associated
components and interfaces from Lcomp and Lint, respectively; let this tree be
called the component wiring tree T associated with S. The component
wiring trees of two valid component-based software systems relative to R, Lint,
Lcomp, and base component Base
Lcomp given in parts (a)–(c) of Figures 1 and
2 are given in Figure 3. Note that such a T has a single root vertex (namely,
base component c), exactly one directed path from this root to any vertex, and

∈

10

is labeled such that a component vertex-label does not occur more than once on
any directed path from the root to a leaf, i.e., there are no recursive dependencies
[12, page 10]. This prevents the possibility of inﬁnite-depth software systems
resulting from the interface-component implementation sequence between two
same-label components on such a path being repeated an inﬁnite number of
times.

Given a set R of software system requirements, a valid component-based soft-
ware system S is a working component-based software system relative
to R if for each input-output pair (ij, oj)
R, the output of S given input
ij is oj. For example, the software system on the left in Figure 3 satisﬁes all
requirements in R given in Figure1(a) and hence is a working component-based
software system relative to R, but the software system on the right is not (be-
cause it produces diﬀerent outputs (3, 1, 1, and 2, respectively) for requirements
r1, r3, r4, and r5).

∈

∈

• Emergent software system: As deﬁned in [12, 13], an emergent
(component-based) software system is one that, given initial functional
software systems requirements R, interface and component libraries Lint and
Lcomp, self-assembles and self-adapts as neces-
Lcomp, and a base component c
sary to optimize system performance as its running environment changes over
time. For a software system S, a system’s running environment and perfor-
mance are quantiﬁed in terms of events and metrics whose values are sampled
at discrete times during system operation [12, pages 10–11]; aspects of system
performance used by a learning algorithm to guide both self-assembly and self-
adaptation are in turn summarized in a reward function. As currently imple-
mented [12], the initial self-assembly phase creates a list of all working software
systems relative to the given Lint, Lcomp, and R, where each system is described
by a unique ID string that lists all components in the system and their intercon-
nections. During the subsequent self-adaptation phase, the learning algorithm
searches over this list to ﬁnd appropriate alternatives to the currently-running
system that might help optimize system performance [12, Section 3.2.1].

In this paper, we will assume that a system’s running environment and per-
formance are sampled using an environment function Env() that maps a given
system onto a collection of events and metric-values and that the reward func-
tion Rew() maps the latest accumulated performance metric values for a system
onto a single positive integer value. For simplicity, we shall further assume that
Env() and Rew() are computable in time polynomial in the size of S, Rew(S)
is optimized by minimization, i.e., smaller values of Rew(S) are preferred, and
Rew() is used to choose among but does not alter the set of possible working

11

software systems relative to a given Lint, Lcomp, and R.

We can now formalize computational problems corresponding to emergent software

adaptation as conceived in [12, 13]:
Emergent Software Creation (ESCreate)
Input: Software system requirements R, interface and component libraries Lint and
Lcomp, a base component c
Lcomp, and reward and environment functions Rew()
and Env().
Output: A working component-based software system S based on c relative to Lint,
Lcomp, and R that has the smallest value of Rew(S) over all working systems based
on c relative to Lint, Lcomp, and R, if any working system exists, and special symbol

∈

otherwise.

⊥
Emergent Software Adaptation (ESAdapt)
Input: Software system requirements R, interface and component libraries Lint and
Lcomp
Lcomp, a working component-based software system S based on component c
relative to R, Lint, and Lcomp, and reward and environment functions Rew() and
Env().
Output: A working component-based software system S′ based on c relative to Lint,
Lcomp, and R that has the smallest possible value of Rew(S′) over all working systems
based on c relative to Lint, Lcomp, and R.

∈

Problem ESCreate corresponds to the initial creation of a working emergent software
system, while ESAdapt corresponds to each subsequent modiﬁcation of the system
to optimize the reward function as the system’s running environment changes over
time. These problems do not correspond directly to emergent system creation and
adaptation as currently implemented, in that ESCreate only returns one rather than
all working software systems relative to Lint, Lcomp, R, ESCreate optimizes the per-
formance of this returned system relative to Rew(), and ESAdapt only has access to
S and not the complete list of working software systems relative to Lint, Lcomp, and
R.1 However, as will be discussed in Section 4.2, complexity results for ESCreate and
ESAdapt can still be used to investigate both current and potential implementations
of emergent software systems.

Two additional notes are in order about our deﬁnitions of ESCreate and ESAdapt.
First, the given Lint, and Lcomp in an input of ESCreate may not allow a working

1An additional diﬀerence and possible source of confusion is that the term “adaptation” in [12]
refers to the process of changing the components and interconnections in the currently-running
software system to those in the candidate selected by the learning algorithm.
In this paper, we
shall instead use “adaptation” to refer to the overall self-adaptation process process described by
ESAdapt, which may involve multiple episodes of adaptation in the sense of [12] to achieve an
optimal system under Rew().

12

software system relative to the given R but there is always a working software system
for any input of ESAdapt — namely, S. Second, Rew() and Env() are part of the
input for both ESCreate and ESAdapt and must be included in any instance of these
problems, i.e., it cannot be the case that Env() and/or Rew() are empty. That being
said, Env() (as well as S in the case of ESAdapt) need not necessarily be used by any
algorithm solving these problems but are provided as part of the problem inputs to
make results derived here relevant to emergent systems as described in [12, 13] (see
Section 4 for further discussion on the latter point).

In this paper, we will consider the following versions of Rew():

• Rew#comp(S) = the number of components in S.

• RewCodeB(S) = the size of the codebase of S, i.e., the total number of lines of

code in the interfaces and components comprising S.

Relative to a particular reward function RewX(), we refer to our problems above as
ESCreate under RewX() and ESAdapt under RewX(), respectively. Note that results
derived relative to Rew#comp() and RewCodeB() have broad applicability as the values
of these functions correlate with the values of at least some of the reward functions
studied to date in emergent software systems, e.g., system response time [12, page
11]. As none of our result proofs rely on Env(), we need not specify its form further.
Let us now illustrate problems ESCreate and ESAdapt relative to the example

emergent software system described in Figures 1–3:

• Valid Software Systems relative to Lint and Lcomp: As each interface
proc1, proc2, and proc3 in software systems based on component System1 can
be implemented with any of the components ProcA, ProcB, ProcC, or ProcD,
there are 43 = 64 valid software systems relative to the general structure on
the left in part (d) of Figure 3. By analogous reasoning relative to component
System2 and interface proc1, there are 4 valid software systems relative to
the general structure on the right. Hence, there are in total 68 valid software
systems relative to Lint and Lcomp.

• Working Software Systems relative to R: The reader can verify that (i)
there are no working software systems relative to R that incorporate component
System2 and (ii) all working software systems relative to R that incorporate
component System1 must implement interface Proc1 with component ProcA
and interface Proc3 with either of the components ProcC or ProcD, and that in-
terface Proc2 (as its implementing component code is never executed) can be im-
plemented by any of the components ProcA, ProcB, ProcC or ProcD. Thus, the

13

implementations of Proc1, Proc2, and Proc3 in System1 that yield working soft-
ware systems are (ProcA, ProcA, ProcC), (ProcA, ProcA, ProcD), (ProcA,
ProcB, ProcC), (ProcA, ProcB, ProcD), (ProcA, ProcC, ProcC), (ProcA,
ProcC, ProcD), (ProcA, ProcD, ProcC), and (ProcA, ProcD, ProcD), giv-
ing in total 8 working software system relative to R.

• Output of ESCreate and ESAdapt under diﬀerent Rew(): As all working
software systems relative to R have 8 components, ESCreate under Rew#comp()
can return any of them; however, as the system with the smallest codebase
implements both Proc2 and Proc3 with ProcC, it is this system that would
be selected by ESCreate under RewCodeB(). By analogous reasoning, ESAdapt
under Rew#comp can return any of the 8 working software systems given system
S drawn from the same set; however, ESAdapt under RewCodeB() must (regard-
less of the choice of the given S) return the system that implements both Proc2
and Proc3 with ProcC.

This concludes our formalization of emergent software system creation and adapta-
tion. A reasonable conjecture at this point is that ESAdapt will be easier to solve
than ESCreate, given that the former is given a working system as part of its input.
This will be assessed below.

3 Results

In this section, we will use computational complexity analysis to assess viable algo-
rithmic options for eﬃcient emergent software system creation and adaptation. This
will be done relative to various desirable types of eﬃcient solvability described in Sec-
tion 3.1. The results of our analyses for emergent software creation and adaptation
are given in Sections 3.2 and 3.3, respectively.

It turns out that both ESCreate and ESAdapt are unsolvable in the most general
possible case — that is, neither ESCreate nor ESAdapt have algorithms that always
return the correct output for an input incorporating any possible choices of Env()
and Rew() (in the case of ESCreate) or any possible choice of Env() and either of
Rew#comp() or RewCodeB() (in the case of ESAdapt) and in which there are no restric-
tions on the form, size, or running times of Lint and Lcomp, their member interfaces
and components, or any software systems created using Lint and Lcomp (see Sections
3.2.1 and 3.3.1, respectively). Hence, the remainder of our analyses will be done
relative to restricted versions of these problems in which candidate component-based
software systems run and hence can be veriﬁed against given system requirements in
polynomial time.

14

3.1 Types of Eﬃcient Solvability

Consider the following desirable forms of solvability:

1. Polynomial-time exact solvability: An exact polynomial-time algorithm is
c2, where
a deterministic algorithm whose runtime is upper-bounded by c1|
is the size of the input x and where c1 and c2 are constants, and is always
x
|
|
guaranteed to produce the correct output for all inputs. A problem that has
such an algorithm is said to be polynomial-time tractable. Polynomial-time
tractability is desirable because runtimes increase slowly as input size increases,
and hence allow the solution of larger inputs.

x
|

It is possible that the computational diﬃculty of a problem may be inﬂated
in general by inputs that have no solutions, and hence force any algorithm to
exhaustively consider all possible candidate solutions. In such cases, it is useful
to assess whether a problem is polynomial-time exact promise solvable
— that is, whether that problem is exactly solvable in polynomial time on
those inputs which are guaranteed to have solutions, where these guarantees
are known as promises.

2. Polynomial-time approximate solvability: A polynomial-time approxima-
tion algorithm is an algorithm that runs in polynomial time in an approximately
correct (but acceptable) manner for all inputs. There are a number of ways in
which an algorithm can operate in an approximately correct manner. Three of
the most popular ways are as follows:

(a) Frequently Correct (Deterministic) [25]: Such an algorithm runs in
polynomial time and gives correct solutions for all but a very small number
of inputs. In particular, if the number of inputs for each input-size n on
which the algorithm gives the wrong or no answer (denoted by the function
err(n)) is suﬃciently small (e.g., err(n) = c for some constant c), such
algorithms may be acceptable.

(b) Frequently Correct (Probabilistic) [26]: Such an algorithm (which is
typically probabilistic) runs in polynomial time and gives correct solutions
In particular, if the probability of correctness is
with high probability.
2/3 (and hence can be boosted by additional computations running in
≥
polynomial time to be correct with probability arbitrarily close to 1 [31,
Section 5.2]), such algorithms may be acceptable.

(c) Approximately Optimal [27]: Such an algorithm A runs in polynomial
time and gives a solution A(x) for an input x whose value val(A(x)) is
) of the value vOP T (x)
guaranteed to be within a multiplicative factor f (

x
|

|

15

of an optimal solution for x, i.e.,
vOP T (x)
vOP T (x)
for any input x for some function f (). A problem with such an algorithm is
said to be polynomial-time f (
) is a
constant very close to 0 (meaning that the algorithm is always guaranteed
to give a solution that is either optimal or very close to optimal), such
algorithms may be acceptable.

)-approximable. In particular, if f (

val(A(x))

x
|

x
|

x
|

| ≤

f (

−

×

)

|

|

|

|

3. Eﬀectively polynomial-time exact restricted solvability: Even if a prob-
lem is not solvable in any of the senses above, a restricted version of that problem
may be exactly solvable in close-to-polynomial time. Let us characterize restric-
tions on problem inputs in terms of a set K =
of aspects of
the input. For example, possible restrictions on the inputs ESCreate could be
the number of given software requirements, the number of components in Lcomp,
and the maximum number of components in a working software system relative
to Lint, Lcomp, and R (see also Table 1 in Section 3.2.4). Let each such aspect
be called a parameter.

k1, k2, . . . , k|K|}

{

|

x
|

One of the most popular ways in which an algorithm can operate in close-to-
polynomial time relative to restricted inputs is ﬁxed-parameter (fp-)
tractability [32]. Such an algorithm runs in time that is non-polynomial purely
c where f () is some func-
in terms of the parameters in K, i.e., in time f (K)
is the size of input x, and c is a constant. A problem with such an
tion,
algorithm for parameter-set K is said to be ﬁxed-parameter (fp-)tractable
relative to K. Fixed-parameter tractability generalize polynomial-time exact
solvability by allowing the leading constant c1 of the input size in the runtime
upper-bound of an algorithm to be a function of K. Though such algorithms
run in non-polynomial time in general, for inputs in which all the parameters in
K have very small constant values and f (K) thus collapses to a possibly large
but nonetheless constant value, such algorithms (particularly if f () is suitably
well-behaved, (e.g, (1.2)k1+k2) may be acceptable.

x
|

|

In the following two subsections, we shall evaluate the algorithmic options for
ESCreate and ESAdapt, respectively, relative to each of these types of solvability. Our
unsolvability proofs will use reductions between pairs of problems, where a reduction
from a problem Π to a problem Π′ is essentially an eﬃcient algorithm A for solving
Π which uses a hypothetical algorithm for solving Π′. Reductions are useful by the
following logic:

• If Π reduces to Π′ and Π′ is eﬃciently solvable by algorithm B then Π is eﬃ-
ciently solvable (courtesy of the algorithm A′ that invokes A relative to B).

16

• If Π reduces to Π′ and Π is not eﬃciently solvable then Π′ is not eﬃciently
solvable (as otherwise, by the logic above, Π would be eﬃciently solvable, which
would be a contradiction).

We will use the following three types of reducibility:

Deﬁnition 1 [11, Section 3.1.2] Given decision problems Π and Π′, i.e., problems
whose answers are either “Yes” or “No”, Π polynomial-time (Karp) reduces to Π′ if
there is a polynomial-time computable function f () such that for any instance x of Π,
the answer to Π for x is “Yes” if and only if the answer to Π′ for f (x) is “Yes”.

Deﬁnition 2 [11, Section 3.1.2] Given search problems Π and Π′, i.e., problems
whose answers are actual solutions rather than just “Yes” or “No”, Π polynomial-
time (Levin) reduces to Π′ if there is a pair of polynomial-time functions f () and g()
such that for any instance x of Π, the answer to Π for x is g(x, y) if and only if the
answer to Π′ for f (x) is y.

Deﬁnition 3 [32]2 Given parameterized decision problems Π and Π′, Π parameter-
ized reduces to Π′ if there is a function f () which transforms instances
of Π
h
c time for some function
into instances
i
f ′() and constant c, k′ = gk′(K) for each k′
K for some function gk′(), and for any
instance
is “Yes” if and only if the answer
of Π, the answer to Π for
to Π′ for f (

of Π′ such that f () runs in f ′(K)

∈
x, K
h

) is “Yes”.

i
x, K

x′, K ′

x, K

x, K

x
|

h

h

i

i

|

h

i

Our reductions will be from versions of the following problems:
Turing Machine Halting (TM Halting) [29]
Input: A Turing Machine M and a binary string x.
Question: Does M halt when given x as input?
Dominating set [10, Problem GT2]
Input: An undirected graph G = (V, E) and a positive integer k.
Question: Does G contain a dominating set of size k, i.e., is there a subset V ′
V ′
|
that (v, v′)
Optimal Dominating set (Dominating setOP T )
Input: An undirected graph G = (V, E).
Output: A dominating set in G of minimum size.

= k, such that for all v
E?

V ′ or there is at least one v′

V , either v

∈

∈

∈

∈

|

V ,
⊆
V ′ such

V in a graph G, let the complete neighbourhood NC(v) of v
For each vertex v
be the set composed of v and the set of all vertices in G that are adjacent to v by

∈

2Note that this deﬁnition given here is actually Deﬁnition 6.1 in [33], which modiﬁes that in [32]

to accommodate parameterized problems with multi-parameter sets.

17

|

{

u

u

∈

∈

∪ {

E
}

v1, v2, . . . , v|V |}

a single edge, i.e., v
V and (u, v)
. We assume below for each
instance of Dominating set an arbitrary ordering on the vertices of V such that
V =
. Note that only the ﬁrst of the three problems above is provably
unsolvable (indeed, unsolvable in the sense that there can be no algorithm period that
returns the correct output for every input [34, Section 9.2.4]). Versions of the others
are only known to be unsolvable relative to the types of eﬃcient solvability listed
at the start of this subsection modulo the conjectures P
= W [2];
however, this is not a problem in practice as both of these conjectures are widely
believed within computer science to be true [9, 28].

= NP and F P T

As we shall often see in the following two sections, a single reduction may imply
multiple results. For example, with respect to the third of the solvability options
described above, additional and sometimes stronger fp-tractability and intractability
results can often be derived using the following three lemmas.

Lemma 1 [35, Lemma 2.1.30] If problem Π is fp-tractable relative to parameter-set
K then Π is fp-tractable for any parameter-set K ′ such that K

K ′.

⊂

Lemma 2 [35, Lemma 2.1.31] If problem Π is fp-intractable relative to parameter-set
K then Π is fp-intractable for any parameter-set K ′ such that K ′

K.

⊂

If problem is NP -hard when all parameters in
Lemma 3 [35, Lemma 2.1.35].
parameter-set K have constant values then Π cannot be fp-tractable relative to any
subset of K unless P = NP .

There are a variety of techniques for creating a reduction from a problem Π to a
problem Π′ ([10, Section 3.2]; see also [33, Chapters 3 and 6]). One of these tech-
niques is component design, in which an instance of Π′ constructed by a reduction is
structured as mechanisms that generate candidate solutions for the given instance of
Π and check these candidates to see if any are actual solutions. We have already seen
in the example software systems given in Figure 3 how interfaces with diﬀerent imple-
menting components (in that case, interfaces intSystem and intProc) can be used
to generate choices when constructing a component-based software system. In sub-
sequent subsections, we will use this and other features of interfaces and components
under the Dana runtime model as described in Section 2 to structure mechanisms
that generate candidate solutions (i.e., valid component-based software systems cor-
responding to vertex-sets of size k in a given graph G) and check these candidates
to see if they are actual solutions (e.g., working component-based software systems
relative R corresponding to dominating sets of size k in G) in many of the reductions
underlying our results for problems ESCreate and ESAdapt.

18

6
6
3.2 Results for Emergent Software Creation

Many of the results derived in this section for ESCreate will actually be derived
relative to the following problem:
Component-based Software Creation (CSCreate)
Input: Software system requirements R, interface and component libraries Lint and
Lcomp, and a base component c
Question: Is there a working component-based software system S based on c relative
to Lint, Lcomp, and R?

Lcomp.

∈

Note that each input for ESCreate has a corresponding input to CSCreate (namely,
the input to ESCreate without Rew() and Env()). Moreover, any algorithm A that
solves ESCreate under some Rew() can be also used to solve CSCreate (namely, if
A run on the given input x for CSCreate produces a working system, output “Yes”,
otherwise output “No”). This yields the following useful observation.

Observation 1 For any choice of Rew() and Env(), if there is an algorithm A of
solvability type T for ESCreate under Rew() than there is an algorithm A′ of solvability
type T for CSCreate.

3.2.1 Unsolvability of Unrestricted Emergent Software Creation

We start oﬀ by considering if problem ESCreate is solvable in the most general possible
case — that is, if ESCreate has an algorithm that always returns the correct output
for an input incorporating any possible choices of Env() and Rew() and in which
there are no restrictions on the form, size, or running times of Lint and Lcomp, their
member interfaces and components, or any software systems created using Lint and
Lcomp. It turns out that such an algorithm cannot exist.

Result A.1 For any choice of Rew() and Env(), ESCreate is unsolvable.

Proof: Consider the following polynomial-time Karp reduction from TM Halting
of TM Halting, construct an instance
to CSCreate: given an instance I =
I ′ =
and O =
, there is a
single input-output pair r in R such that for r = (T rue, 1), Lint consists of the single
interface

h
of CSCreate in which X =

R, Lint, Lcomp, c

M, x
i

x1}

}

{

{

1

h

i

interface base {

void main(Input I)

}

and Lcomp consists of the single component

19

component Base provides base {
void main(Input I) {

<CODEM(x)>
output 1

}

}

where <CODEM(x)> is the Dana code simulating the computation of M on input x.
As Dana contains both loops and conditional statements, it can readily simulate M
on input x using code that is of size polynomial in the sizes of the given descriptions
of M and x. Finally, let c be component Base in Lcomp. Note that the instance
of CSCreate described above can be constructed in time polynomial in the size of
the given instance of TM Halting. To conclude the proof, observe that the only
possible component-based system for the constructed instance of CSCreate based on
c is that consisting of Base itself, and that this system satisﬁes the sole input-output
constraint in R if and only if M halts on input x for the given instance of TM
Halting. It is known that TM Halting cannot have an algorithm that is correct
for all possible
instances [34, Section 9.2.4], and hence is unsolvable. Hence,
the reduction above implies in turn that CSCreate cannot have an algorithm either.
The unsolvability result for ESCreate then follows by contradiction from Observation
1.

M, x
i

h

This result is especially disconcerting as it holds relative to not just some choices
but every possible choice of Env() and Rew() (this is because the proof of this
result ignores these functions entirely). However,
it is ultimately not surprising,
given the computational power inherent in the Dana programming language and the
folklore result that a number of problems in software engineering, e.g., checking if a
software system satisﬁes a set of given requirements, are known to be unsolvable as
a consequence of Rice’s Theorem [34, Section 9.3.3].

I

That being said, restricted versions of ESCreate may yet have correct and even
eﬃcient algorithms. One reasonable such restriction is that any candidate component-
based software system S created from a given Lint and Lcomp runs in time polynomial
and hence can be checked against the system requirements in R
in the input size
|
I
in time polynomial in the size of R (as
), i.e., created software systems not
|
only operate but can also be veriﬁed quickly. Indeed, such a restriction is implicit
in the requirement that emergent software systems be autonomously veriﬁable at
runtime [12, page 5]. In the remainder of our analyses in this paper, we will assume
ESCreate and CSCreate to be so restricted, and will denote these restricted versions
as ESCreatepoly and CSCreatepoly, respectively.

<

R

|

|

|

|

20

Base

cond2

. . .
InSet2x

cond1

InSet1x

condk

InSetkx

Figure 4: General structure of valid software systems created by the reduction in
the proof of Lemma 4. Note that index x in InSetjx, 1
x
components are enclosed in dashed boxes.

≤
. Following the convention in Figure 3, interfaces with multiple implementing

k, is such that 1

≤ |

≤

≤

V

j

|

3.2.2 Polynomial-time Exact Solvability of Restricted Emergent Software

Creation

We now consider if ESCreatepoly is eﬃciently solvable in the ﬁrst of the senses listed at
the start of Section 3.1 — namely, polynomial-time exact solvability and polynomial-
time exact promise solvability. One might initially think that, given the somewhat
radical nature of the restriction on ESCreate proposed at the end of the previous
subsection, ESCreate so restricted is now eﬃciently solvable in both of these senses.
However, this turns out not to the case.

These intractability results are shown using the following reduction. This re-
duction creates valid component-based systems with component wiring trees of the
form shown in Figure 4 in which the multiply implemented interfaces cond1, cond2,
...condk are used to create valid software systems corresponding to all possible
vertex-sets of size k in the graph G in the given instance of Dominating set. As
each input-output pair in the constructed R corresponds to a vertex-neighbourhood
in G, the code in component Base ensures that working software systems correspond
to dominating sets of size k in G.

Lemma 4 Dominating set polynomial-time Karp reduces to CSCreatepoly.

G = (V, E), k

h
R, Lint, Lcomp, c

of Dominating set, construct the
Proof: Given an instance I =
following instance I ′ =
x1, x2, . . . , x|V |}
,
i.e., there is a unique Boolean variable corresponding to each vertex in V , and O =
input-output pairs in R such that for rj = (ij, oj), 1
V
j
,
|
NC(vj) and is F alse otherwise and oj = 1. Let Lint consist of

V
0, 1
{
vij (xk) = T rue if vk
k + 1 interfaces broken into two groups:

of CSCreatepoly: Let X =

. There are

|
∈

≤ |

≤

{

}

h

i

i

|

1. A single interface of the form

21

interface base {

void main(Input I)

}

2. A set of k interfaces of the form

interface condJ {

Boolean inSetJ(Input I)

}

for 1

J

≤

≤

k.

Let Lcomp consist of k

V

|

|

+ 1 components broken into two groups:

1. A single component of the form

component Base provides base

requires cond1, cond2, ..., condk {

void main(Input I) {

if inSet1(I) then output 1
elsif inSet2(I) then output 1

...

elsif inSetk(I) then output 1
else output 0

}

}

2. A set of k

V

|

|

components of the form

component InSetJK provides condJ {
Boolean inSetJ(Input I) {

return v_I(x_K)

}

}

for 1

J

≤

≤

k and 1

K

V

.

|

≤ |

≤

22

|

|

V

implementations of each cond-interface. Finally, let c
Note that in Lcomp, there are
be component Base in Lcomp. Note that the instance of CSCreatepoly described above
can be constructed in time polynomial in the size of the given instance of Dominating
set; moreover, as there is only a (k + 1)-clause if-then statement block and no loops
in the component code and k
, any candidate component-based software
|
system created relative to Lint, Lcomp, and c runs in time linear in the size of input
I ′.

≤ |

<

V

I

|

|

Let us now verify the correctness of this reduction:

• Suppose that there is a dominating set D of size at most k in the given instance
of Dominating set. We can then construct a component-based software sys-
InSet-components corresponding to the vertices
tem consisting of c and the
in D; the choice of which interface to implement for each vertex is immaterial,
required cond-
and if there are less than k vertices in D, the ﬁnal k
interfaces can be implemented relative to InSet-components corresponding to
R, this software system
arbitrary vertices in D. Observe that for each (ij, oj)
produces output oj given input ij.

− |

D

D

∈

|

|

|

• Conversely, suppose that the constructed instance of CSCreatepoly has a work-
ing component-based software system based on c relative to Lint, Lcomp, and R.
In order to correctly accommodate all input-output pairs in R, the k if-then
statements in c must implement InSet-components whose corresponding ver-
tices form a dominating set in G of size at most k. Hence, the existence of
a working component-based software system for the constructed instance of
CSCreatepoly implies the existence of a dominating set of size at most k for the
given instance of Dominating set.

This completes the proof.

Result A.2 For any choice of Rew() and Env(), if ESCreatepoly is polynomial-time

exact solvable then P = NP .

Proof: Given the NP -hardness of Dominating set, the reduction in Lemma 4
implies that CSCreatepoly is NP -hard, and hence not solvable in polynomial time
unless P = NP . The polynomial-time intractability result for ESCreatepoly then
follows by contradiction from Observation 1.

Result A.3 For any choice of Rew() and Env(), if ESCreatepoly is polynomial-time

exact promise solvable then P = NP .

23

Proof: Suppose that for some choice of Rew() and Env(), ESCreatepoly is polynomial-
time promise solvable by an algorithm A.3 Consider the following algorithm for
Dominating set:

1. Given an instance I =

of Dominating set, construct an
instance I ′ =
of ESCreatepoly using the reduction
from Dominating set to CSCreatepoly described in Lemma 4 to create R, Lint,
Lcomp, and c.

R, Lint, Lcomp,Rew(),Env(), c
i

G = (V, E), k

h

h

i

2. Run A on I ′ to produce output O′ for ESCreatepoly.

3. As speciﬁed in the converse part of the proof of correctness of the reduction
in Lemma 4 use the invoked if-then components in O′ to derive a candidate
solution O for the given instance of Dominating set.

4. If O is a correct solution for I, output “Yes”; otherwise, output “No” (as by
the deﬁnition of promise solvability, if the answer was “Yes” then A would have
had to output O′ such that O was a correct solution to the given instance of
Dominating set).

As all steps in this algorithm run in polynomial time, the above is a polynomial-time
algorithm for Dominating set. However, given the NP -hardness of Dominating
set, this would imply that P = NP , completing the proof.

3.2.3 Polynomial-time Approximate Solvability of Restricted Emergent

Software Creation

We now consider if ESCreatepoly is eﬃciently approximately solvable in either of the
three senses (frequently correct (deterministic), frequently correct (probabilistic), or
approximately optimal) listed at the start of Section 3.1. As can be seen below, the
polynomial-time exact intractability of ESCreatepoly proved in the previous section
rules out all three of these types of eﬃcient approximability.

We start by considering the two types of frequently correct approximability.

Result A.4 For any choice of Rew() and Env(), if ESCreatepoly is solvable by a
polynomial-time algorithm with a polynomial error frequency (i.e., err(n) is
upper bounded by a polynomial of n) then P = NP .

3It may initially seem puzzling why, in light of Observation 1, we here directly evaluate the
polynomial-time promise solvability of ESCreatepoly. This is necessary because the promise solvabil-
ity of any decision problem such as CSCreatepoly is established by the trivial constant-time algorithm
which always answers “Yes” (and hence is always correct if a solution exists).

24

Proof: That the existence of such an algorithm for CSCreatepoly implies P = NP
follows from the NP -hardness of CSCreatepoly (which is established in the proof of
Result A.1) and Corollary 2.2. in [25]. The polynomial-time inapproximability result
for ESCreatepoly then follows by contradiction from Observation 1.

Result A.5 For any choice of Rew() and Env(), if P = BP P and ESCreatepoly is
polynomial-time solvable by a probabilistic algorithm which operates correctly
with probability

2/3 then P = NP .

≥

Proof: It is widely believed that P = BP P [31, Section 5.2] where BP P is considered
the most inclusive class of decision problems that can be eﬃciently solved using
probabilistic methods (in particular, methods whose probability of correctness is
≥
2/3 and can thus be eﬃciently boosted to be arbitrarily close to one). Hence, if
CSCreatepoly has a probabilistic polynomial-time algorithm which operates correctly
with probability
if
BP P = P and we know that CSCreatepoly is NP -hard by the proof of Result A.2, this
would then imply by the deﬁnition of NP -hardness that P = NP . The polynomial-
time inapproximability result for ESCreatepoly then follows by contradiction from
Observation 1.

2/3 then CSCreatepoly is by deﬁnition in BP P . However,

≥

To assess cost-approximability, we need the following problem.
Optimal Component-based Software Creation (CSCreateOP T )
Input: Software system requirements R, interface and component libraries Lint and
Lcomp, a base component c
Output: A working component-based software system S based on c relative to Lint,
Lcomp, and R that has the smallest value of Rew(S) over all working systems based
on c relative to Lint, Lcomp, and R, if such a system exists, and special symbol
otherwise.

Lcomp, and a reward function Rew().

⊥

∈

poly be the version of CSCreateOP T such that any component-based
Let CSCreateOP T
system S runs in time polynomial in the input size
. Note that each input
|
for ESCreatepoly has a corresponding input to CSCreateOP T
(namely, the input to
poly
ESCreatepoly without Env()). Moreover, any algorithm A that solves ESCreatepoly
under some Rew() can also be used to solve CSCreateOP T
poly (namely, return whatever
A run on the given input x for CSCreateOP T
poly produces). This yields the following
useful observation.

I

|

Observation 2 For any choice of Rew() and Env(), if there is an algorithm A of
solvability type T for ESCreatepoly than there is an algorithm A′ of solvability type T
for CSCreateOP T

poly under Rew().

25

TopBase

base

BaseJ

cond2

. . .

condJ

cond1

InSet1x

InSet2x

InSetJx

Figure 5: General structure of valid software systems created by the reduction in the
proof of Lemma 5. Note that indices J and x in InSetJx are such that 1
V
|
components are enclosed in dashed boxes.

≤
. Following the convention in Figure 3, interfaces with multiple implementing

J, x

≤

|

We ﬁrst give a reduction that will be used to establish the cost-inapproximability of
ESCreate under Rew#comp(). This reduction builds on that in Lemma 4 by further
exploiting the ability of interfaces to be implemented by multiple components to allow
a set of BaseJ components that eﬀectively encode all possible candidate dominating
sets of size 1 to

in G (see Figure 5).

V

|

|

Lemma 5 Dominating setOP T polynomial-time Levin reduces to CSCreateOP T
poly un-
der Rew#comp() such that there is a dominating set of size k for the given instance
of Dominating setOP T if and only if there is a working component-based software
system S with reward value Rew#comp(S) = k + 2 for the constructed instance of
CSCreateOP T
poly .

Proof: Given an instance I =
following instance I ′ =
of Lemma 4. Let Lint consist of

h

h
R, Lint, Lcomp, c

G = (V, E)

i

V

|

|

of Dominating setOP T , construct the
poly : Let R be as in the proof

of CSCreateOP T

i

+ 2 interfaces broken into three groups:

1. A single interface of the form

interface topBase {

void main(Input I)

}

2. A single interface of the form

26

interface base {

void mainBase(Input I)

}

3. A set of

V

|

|

interfaces of the form

interface condJ {

Boolean inSetJ(Input I)

}

for 1

J

V

.

|

≤ |

≤

Let Lcomp consist of

2 +

V

|

|

V

|

|

+ 1 components broken into three groups:

1. A single component of the form

component TopBase provides topBase requires base {

void main(Input I) {
mainBase(I)

}

}

2. A set of

V

|

|

components of the form

component BaseJ provides base

requires cond1, cond2, ..., condJ {

void mainBase(Input I) {

if inSet1(I) then output 1
elsif inSet2(I) then output 1

...

elsif inSetJ(I) then output 1
else output 0

}

}

J

for 1

≤
3. A set of

V

.

|

≤ |
V

|

|

2 components of the form

27

component InSetJK provides condJ {
Boolean inSetJ(Input I) {

return v_I(x_K)

}

}

for 1

J

V

and 1

K

V

.

|

|

≤

≤ |

≤ |
V

|
implementations of the base-interface and

≤
V
Note that in Lcomp, there are
|
implementations of each cond-interface. Finally, let c be component TopBase in
Lcomp. Note that the instance of CSCreateOP T
poly described above can be constructed in
time polynomial in the size of the given instance of Dominating setOP T .; moreover,
+ 1)-clause if-then statement block and no loops in
as there is only an at most (
I
V
the component code and
, any candidate component-based software system
created relative to Lint, Lcomp, and c runs in time linear in the size of input I ′.

V
|
<

|
|

|

|

|

|

|

Let us now verify the correctness of this reduction:
• Suppose that there is a dominating set D of size k in the given instance of
Dominating set. We can then construct a component-based software system
consisting of c, component basek, and the k Inset-components corresponding
to the vertices in D; the choice of which interface to implement for each vertex
is immaterial. Observe that for each (ij, oj)
R, this software system produces
output oj given input ij; moreover, Rew#comp(S) = k + 2.

∈

• Conversely, suppose that the constructed instance of CSCreateOP T

poly has a
working component-based software system based on c relative to Lint, Lcomp, and
R such that Rew#comp(S) = val.4 As c is component TopBase which requires a
Base component and this Base component requires some number of InSet com-
ponents, this system is comprised of components TopBase, Base(val
2), and
2 InSet components. In order to correctly accommodate all input-output
val
2) must implement
2) if-then statements in Base(val
pairs in R, the (val
Inset-components whose corresponding vertices form a dominating set in G
of size at most val
2. Hence, the existence of a working component-based
software system S such that Rew#comp(S) = val for the constructed instance of
CSCreateOP T
implies the existence of a dominating set of size val
2 for the
poly
given instance of Dominating set.

−

−

−

−

−

−

4Note that the existence of at least one such a working system is guaranteed for all instances of
CSCreateOP T
poly constructed as described above (namely, the system consisting of components TopBase
and Base(|V|) and the
, which corresponds to the dom-
inating set consisting of all vertices in V ). This is necessary for our reduction, as each instance
of Dominating setOP T has at least one dominating set (namely, V ), and cannot correspond to a
constructed instance of CSCreateOP T

components InSetJJ for 1

poly whose solution is

≤ |

≤

V

V

J

.

|

|

|

⊥

28

To complete the proof, note that the required functions f () and g() in the deﬁnition
of a Levin reduction correspond respectively to the algorithm given at the beginning
of this proof for constructing an instance of CSCreateOP T
poly under Rew#comp() from
the given instance of Dominating setOP T and the algorithm implicit in the con-
verse clause of the proof of reduction correctness above for constructing a dominating
set from a valid component-based software system for the constructed instance of
CSCreateOP T
poly .

The reduction above can also be used to establish the cost-inapproximability of ES-
Create under RewCodeB().

Lemma 6 Dominating setOP T polynomial-time Levin reduces to CSCreateOP T
poly un-
der RewCodeB() such that there is a dominating set of size k for the given instance
of Dominating setOP T if and only if there is a working component-based software
system S with reward value RewCodeB(S) = 9k + 16 for the constructed instance of
CSCreateOP T
poly .

Proof: In the proof of Lemma 5, observe that for a dominating set of size k in
the given instance of Dominating setOP T , a software system S for the constructed
instance of CSCreateOP T
poly consists of components TopBase and Basek, k InSet com-
ponents, interfaces topBase and base, and k cond interfaces. The total number
of lines of code in this system and hence the value of RewCodeB(S)) is therefore
5 + (k + 5) + 5k + 3 + 3 + 3k = 9k + 16. The result then follows by a slight modiﬁca-
tion to the proof of correctness of the reduction described in Lemma 5.

Result A.6 For any choice of Env(), if ESCreateOP T

poly under Rew#comp() is polynomial-

time
c-approximable for any constant c > 0 then P = NP .

−

Proof: Observe that in the proof of the reduction in Lemma 5, the size k of a
dominating set in G in the given instance of Dominating setOP T is always a linear
function of the value of Rew#comp(S) in the constructed instance of CSCreateOP T
poly , i.e.,
2. This means that a polynomial-time c-approximation algorithm
k = Rew#comp(S)
for CSCreateOP T
poly under Rew#comp() for any constant c, when combined with the re-
duction from Dominating setOP T to CSCreateOP T
poly described in the proof of Lemma
5, implies the existence of a polynomial-time 3c-approximation algorithm for Domi-
nating setOP T (as c
1).
×
However, if Dominating setOP T has a polynomial-time c-approximation algorithm
for any constant c > 0 then P = NP [36], which means that CSCreateOP T
poly under
Rew#comp() cannot have a polynomial-time c-approximation algorithm for any c > 0
unless P = NP . The polynomial-time inapproximability result for ESCreateOP T
poly
under Rew#comp() then follows by contradiction from Observation 2.

Rew#comp(S) = c

(k + 2k)

(k + 2)

k for k

3c

≤

≥

×

×

×

≤

c

29

Table 1: Parameters for emergent software creation problems.
Parameter Description

|

|

Lint
|
|
Lcomp
Ici
Cpi
Cri
Scomp
Sdepth

# available interfaces
# available components
Maximum # components implementing an interface
Maximum # provided interfaces per component
Maximum # required interfaces per component
Maximum # components in a valid system
Maximum depth of component wiring tree

Result A.7 For any choice of Env(), if ESCreateOP T

poly under RewCodeB() is polynomial-

time
c-approximable for any constant c > 0 then P = NP .

Proof: Observe that in the proof of the reduction in Lemma 6, the size k of a
dominating set in G in the given instance of Dominating setOP T is always a linear
function of the value of RewCodeB(S) in the constructed instance of CSCreateOP T
poly , i.e.,
k = RewCodeB (S)−16
. This means that a polynomial-time c-approximation algorithm for
9
CSCreateOP T
poly under RewCodeB() for any constant c, when combined with the reduction
from Dominating setOP T to CSCreate OP T described in the proof of Lemma 6, im-
plies the existence of a polynomial-time 25c-approximation algorithm for Dominat-
ing setOP T (as c
(9k +16)
1).
×
However, if Dominating setOP T has a polynomial-time c-approximation algorithm
for any constant c > 0 then P = NP [36], which means that CSCreateOP T
poly under
RewCodeB() cannot have a polynomial-time c-approximation algorithm for any c > 0
unless P = NP . The polynomial-time inapproximability result for ESCreateOP T
poly
under RewCodeB() then follows by contradiction from Observation 2.

RewCodeB(S) = c

(9k +16k)

k for k

25c

×

≥

≤

×

≤

×

c

3.2.4 Fixed-parameter Tractability of Restricted Emergent Software Cre-

ation

Given the plethora of intractability results in the previous three subsections, we now
consider to what extent and relative to which parameters ESCreatepoly is and is not
fp-tractable. In our analyses below, we will focus on parameter-sets K drawn from
the parameters listed in Table 1. These parameters can be divided into four main
groups:

1. Parameters characterizing interface and component libraries (

Lint

,

|

|

|

Lcomp

);

|

30

2. Parameters charactering interfaces (Ici);

3. Parameters charactering components (Cpi, Cri); and

4. Parameters characterizing component-based software systems (Scomp, Sdepth).

We ﬁrst consider those parameter-sets which yield fp-intractability.

Result A.8 For any choice of Rew() and Env(), if

ESCreatepoly is fp-tractable then F P T = W [2].

Lint

|

h|

, Cpi, Cri, Scomp, Sdepth

-

i

-Dominating set, the reduction in Lemma 4
Proof: Given the W [2]-hardness of
k
i
implies that CSCreatepoly is W [2]-hard when Cpi = 1, Sdepth = 2, Cri = k, and
=
Scomp = k + 1 and hence not fp-tractable relative to these parameters unless F P T =
W [2]. The fp-intractability result for ESCreatepoly then follows by contradiction from
Observation 1.

Lint

h

|

|

The reductions underlying the following three results exploit the tricks previously
used to such good eﬀect in Lemmas 4 and 5 as well as other features of our software
component model. The reduction underlying Result A.9 reduces the number of InSet
components by invoking a larger encoding of candidate dominating sets and more
complex but still polynomial-time checking computations in the Base component.
The reduction underlying Result A.10 reduces the number of interfaces required by
any component to a constant by splitting the creation of the candidate dominating
sets in component Base in the reduction in the proof of Result A.9 over multiple
components. Finally, the reduction underlying Result A.11 reduces the number of
components in Lcomp to 3 by exploiting the ability of components providing multiple
interfaces to provide only the code required by an interface in that interface’s copy
of the component. Readers interested in details can consult the full proofs of these
results in the appendix.

Result A.9 For any choice of Rew() and Env(), if

fp-tractable then P = NP .

Ici, Cpi, Sdepth

h

i

-ESCreatepoly is

Result A.10 For any choice of Rew() and Env(), if

fp-tractable then P = NP .

Ici, Cpi, Cri

h

i

-ESCreatepoly is

Result A.11 For any choice of Rew() and Env(), if

is fp-tractable then P = NP .

Lcomp

|

h|

, Ici, Sdepth

i

-ESCreatepoly

We now consider those parameter-sets that yield fp-tractability. All of these results
are based on the same brute-force solution enumeration algorithm relative to diﬀerent
worst-case runtime analyses.

31

Result A.12 For any choice of Rew() and Env(),

fp-tractable.

Ici, Cri, Sdepth

h

i

-ESCreatepoly is

Proof: The largest possible component-based software system relative to a given Lint
and Lcomp has a component wiring tree rooted at base component c with branching
factor Cri and depth Sdepth. This tree has (Cri)Sdepth
2 non-root vertices, each
corresponding to an interface required by a component. As each of these interfaces
can be implemented by at most Ici components, there are at most (Ici + 1)(Cri)Sdepth
possible component-based software systems of depth at most Sdepth based on c (the
“+ 1” term at the lowest level denotes labeling a vertex v with a special symbol that
triggers deletion all descendent-vertices of v).

−

Consider the algorithm that exhaustively generates all such systems and for each
system S, (i) determines if S is a working system relative to R and, if so, (2) computes
reward value Rew(S). The output of this algorithm is the working system with the
lowest or highest reward value, depending on the intent of Rew(). Given the above
and our assumption that a candidate component-based software system S can be
checked against software system requirements R in time polynomial in the sizes of S
and R, this algorithm runs in fp-time relative to Ici, Cri, and Sdepth, completing the
proof of this result.

Result A.13 For any choice of Rew() and Env(),

fp-tractable.

Ici, Scomp

h

i

-ESCreatepoly

is

Proof: As no path from the root to a leaf in the wiring component trees for our
software systems can contain duplicate component vertex-labels, the length of the
longest path in such a tree from base component c is bounded by Scomp; this means
Scomp. Moreover, as implementing each required interface adds a com-
that Sdepth
ponent to the software system, Cri
1 < Scomp. Given these two observations,
≤
this result then follows from the algorithm in the proof of Result A.12.

Scomp

≤

−

Result A.14 For any choice of Rew() and Env(),

fp-tractable.

Lint

,

|

|

h|

Lcomp

|i

-ESCreatepoly is

Proof: As no path from the root to a leaf in the wiring component trees for our
software systems can contain duplicate component vertex-labels, the length of the
longest path in such a tree from base component c is bounded by
; this means
that Sdepth
. Moreover, as a component cannot require the same interface
twice, Cri
. Given these two observations, this result then follows from the
|
algorithm in the proof of Result A.12.

Lcomp
Lint

≤ |
≤ |

Lcomp

|

|

|

Note that for each of the parameter-sets in Results A.12–A.14, ESCreatepoly is fp-
intractable relative to each non-empty subset of these parameter-sets. Hence, these

32

fp-tractability results are all minimal, in the sense that no subsets of the parameters
in their associated parameter-sets yield fp-tractability.

3.3 Results for Emergent Software Adaptation

Many of the results derived in this section for ESAdapt will actually be derived
relative to the following problem:
Component-based Software Adaptation (CSAdapt)
Input: Software system requirements R, interface and component libraries Lint and
Lcomp, a working component-based software system S based on component c
Lcomp
relative to R, Lint, and Lcomp, reward function Rew(), and an integer k.
Question: Is there a working component-based software system S′ based on c relative
to Lint, Lcomp, and R such that Rew(S′)

≤
Note that each input for ESAdapt has a corresponding input to CSAdapt (namely, the
input to ESAdapt without Env()). Moreover, any algorithm A that solves ESAdapt
under some Rew() can be also used to solve CSAdapt (namely, if A run on the given
input x for CSAdapt produces a working system S′ such that Rew(S′)
k, output
“Yes”, otherwise output “No”). This yields the following useful observation.

k?

≤

∈

Observation 3 For any choice of Rew() and Env(), if there is an algorithm A of
solvability type T for ESAdapt under Rew() than there is an algorithm A′ of solvability
type T for CSAdapt under Rew().

It is very important to note that CSAdapt (unlike CSCreate in Section 3.2) explicitly
invokes Rew(); hence, all of our results proved by invoking Observation 3 (i.e., all re-
sults proved in this section) are relative to speciﬁc Rew(), namely, either Rew#comp()
or RewCodeB(). This has some interesting consequences, which will be discussed fur-
ther in Section 4.

3.3.1 Unsolvability of Unrestricted Emergent Software Adaptation

We start oﬀ by considering if problem ESAdapt is solvable in the most general possible
case — that is, if ESAdapt has an algorithm that always returns the correct output
for an input incorporating any possible choice of Env() and in which there are no
restrictions on the form, size, or running times of Lint and Lcomp, their member
interfaces and components, or any software systems created using Lint and Lcomp.
Analogous to ESCreate in Section 3.2.1, this once again turns out not to be the case,
though we only show unsolvability at this time for ESAdapt under either Rew#comp()
or RewCodeB().

33

TopBase

Base1

base1

base2

Base1a

TopBase

base1

Base2

Figure 6: General structure of valid software systems created by the reduction in the
proof of Result B.1. The “twin” component-based system with an extra component
and extra code that is given as S in the reduction is on the left, and is forbidden
as output by appropriate values of k under Rew#comp() and RewCodeB() in favor of
the component-based system on the right. Following the convention in Figure 3,
interfaces with multiple implementing components are enclosed in dashed boxes.

Let us ﬁrst consider ESAdapt under Rew#comp().

In the following, we modify
Lint and Lcomp in the reduction in the proof of Result A.1 such that any working
component-based software system has a new topmost component topBase and there
are thus now two possible working component-based software systems, one of which
is the given “twin” component-based system S with extra component (Base1a) that
can be disallowed as a possible solution by appropriately setting the value of k relative
to reward function Rew#comp() (see Figure 6).

Result B.1 For any choice of Env(), ESAdapt under Rew#comp() is unsolvable.

Proof: Consider the following polynomial-time Karp reduction from TM Halting
of TM Halting, construct an instance
to CSAdapt: given an instance I =
I ′ =
and
O =
, there is a single input-output pair r in R such that for r = (T rue, 1), Lint
consists of the three interfaces

R, Lint, Lcomp, S, c, Rew() = Rew#comp(), k
1

of CSAdapt in which X =

M, x
i

x1}

h
{

}

{

i

h

interface topBase {

void main(Input I)

}

interface base1 {

void main1(Input I)

}

34

interface base2 {

void base1a(Input I)

}

and Lcomp consists of the four components

component TopBase provides topBase requires base1 {

void main(Input I) {

main1(I)

}

}

component Base1 provides base1 requires base2 {

void main1(Input I) {

base1a(I)

}

}

component Base1a provides base2 {
void base1a(Input I) {

output 1

}

}

component Base2 provides base1 {
void main1(Input I) {

<CODEM(x)>
output 1

}

}

where <CODEM(x)> is the Dana code simulating the computation of M on input x. As
noted previously in the proof of Result A.1, Dana contains both loops and conditional
statements and can readily simulate M on input x using code that is of size polynomial
in the sizes of the given descriptions of M and x. Finally, let c be component TopBase
in Lcomp, S be the software system based on components TopBase, Base1 and Base1a,
and k = 2. Note that the instance of CSAdapt described above can be constructed
in time polynomial in the size of the given instance of TM Halting. To conclude
the proof, observe that the only possible component-based system for the constructed
instance of CSAdapt which has only the two components required by the value of k

35

h

M, x
i

is that consisting of TopBase and Base2, and that this system satisﬁes the sole input-
output constraint in R if and only if M halts on input x for the given instance of TM
Halting. It is known that TM Halting cannot have an algorithm that is correct for
all given
instances ([29]; see also [34, Section 9.2.4]), and hence is unsolvable.
The reduction above implies in turn that CSAdapt under Rew#comp() cannot have
an algorithm either. The unsolvability result for ESAdapt under Rew#comp() then
follows by contradiction from Observation 3.
We can in turn use a version of the reduction above to prove unsolvability of ESAdapt
under RewCodeB() by “padding” the code of component Base1a to ensure that the
given component-based system S cannot be a solution relative to an appropriate value
of k.

Result B.2 For any choice of Env(), ESAdapt under RewCodeB() is unsolvable.

Proof: Consider a modiﬁcation of the reduction in the proof of Result B.1 in which
component Base1a is instead

component Base1a provides base2 {
void base1a(Input I) {

<BLOCK>
output 1

}

}

|

<CODE(M(x))>
|

copies of the statement x = 1 and k =
where <BLOCK> consists of
<CODE(M(x))>
+16. To conclude the proof, observe that the only possible component-
|
|
based system for the constructed instance of CSAdapt which has the code-base length
required by the value of k is that consisting of TopBase and Base2, and that this sys-
tem satisﬁes the sole input-output constraint in R if and only if M halts on input
x for the given instance of TM Halting. It is known that TM Halting cannot
have an algorithm that is correct for all given
instances [34, Section 9.2.4],
and hence is unsolvable. The reduction above implies in turn that CSAdapt under
RewCodeB() cannot have an algorithm either. The unsolvability result for ESAdapt
under Rew)CodeB() then follows by contradiction from Observation 3.

M, x
i

h

Unlike ESCreate in Section 3.3.1, the two results above only hold relative to some
choices of Env and Rew() — namely, every possible choice of Env() paired with
either of Rew#comp() or RewCodeB() (this is because the proofs of these results only
ignore Env() and not both Env() and Rew()). That being said, restricted versions of
ESAdapt under Rew#comp() and RewCodeB() may yet have correct and even eﬃcient
algorithms. Thus, in the remainder of this paper, we shall assume that ESAdapt and

36

CSAdapt are (as were ESCreate and CSCreate in Section 3.2.1) restricted such that
any component-based software system S and S′ relative to given Lint and Lcomp run
in time polynomial in input size
and hence can be checked against the system
requirements in R in time polynomial in the sizes of S and R, i.e., created software
systems not only operate but can also be veriﬁed quickly. We will denote these
restricted versions as ESAdaptpoly and CSAdaptpoly, respectively.

I

|

|

3.3.2 Polynomial-time Exact Solvability of Restricted Emergent Software

Adaptation

We now consider if ESAdaptpoly is eﬃciently solvable in the ﬁrst of the senses listed at
the start of Section 3.1 — namely, polynomial-time exact solvability and polynomial-
time exact promise solvability. As was the case with ESCreatepoly in Section 3.2.2,
it turns out that ESAdaptpoly is also polynomial-time exact intractable, with the
diﬀerence that this intractability is proven relative to speciﬁc rather than any reward
functions (namely, Rew#comp() and RewCodeB()).

Lemma 7 Dominating set polynomial-time Karp reduces to CSAdaptpoly under
Rew#comp().

h

h

V

G = (V, E), k

i
R, Lint, Lcomp, S, c, Rew() = Rew#comp(), k′

of Dominating set, construct the
Proof: Given an instance I =
following instance I ′ =
of CSAdaptpoly:
. Let R, Lint, Lcomp, and c be as in the proof
Without loss of generality, assume k <
|
of Lemma 5 and S be the software system based on TopBase, Base(|V|), and the
. Finally, let k′ = k + 2. Note that this instance
components InSetJJ for 1
CSAdaptpoly can be constructed in time polynomial in the size of the given instance
of Dominating set; moreover, as there are only a (k + 1)
+ 1)-
clause if-then statement block and two single-level loops in the component code that
each execute at most
times, any component-based software system created
relative to Lint, Lcomp, and Ec runs in time linear in the size of input I ′.

+ 1) < (

≤ |

≤

≤

<

V

V

V

J

I

I

i

(

|

|

|

|

|

|

|

|

|

|

Let us now verify the correctness of this reduction:

• Suppose that there is a dominating set D of size k in the given instance of
Dominating set. We c an then construct a component-based software system
S′ consisting of c and component Basek, in which the k cond-interfaces in
Basek are implemented by Inset components corresponding to the vertices in
R, S′ produces output oj given input ij;
D. Observe that for each (ij, oj)
moreover, Rew#comp(S′) = k + 2

∈
k′.

≤

• Conversely, suppose that the constructed instance of CSAdaptpoly has a
working component-based software system S′ based on c relative to Lint, Lcomp,

37

|

≤

≤

6≤

V
J

+ 2

|
≤

and R such that Rew#comp(S′)
k′ = k + 2. Such a system S′ cannot in-
clude component Base(|V|) as in S, because in that case, Rew#comp(S′) would
k′. Therefore, S′ must include one of the component
have the value
BaseJ for 1
k; let us call this component BaseM. As in the proof of
Lemma 5, in order to correctly accommodate all other input-output pairs in
R, the M if-then statements in BaseM must implement InSet-components
whose corresponding vertices form a dominating set in G of size at most k in
G. Hence, the existence of a working component-based software system for the
constructed instance of CSCreatepoly implies the existence of a dominating set
of size at most k for the given instance of Dominating set.

This completes the proof.

Lemma 8 Dominating set polynomial-time Karp reduces to CSAdaptpoly under
RewCodeB().

Proof: In the proof of Lemma 7, observe that for a dominating set of size k in the
given instance of Dominating setOP T , a software system S′ for the constructed
instance of CSAdaptpoly consists of components TopBase and Basek, k InSet com-
ponents, interfaces topBase and base, and k cond interfaces. The total number
of lines of code in this system and hence the value of RewCodeB(S′)) is therefore
5 + (k + 5) + 5k + 3 + 3 + 3k = 9k + 16. The result then follows by a slight modiﬁca-
tion to the proof of correctness of the reduction described in Lemma 7.

Result B.3 For any choice of Env(), if ESAdaptpoly under Rew#comp() is polynomial-

time exact solvable then P = NP .

Proof: Given the NP -hardness of Dominating set, the reduction in Lemma 7
implies that CSAdaptpoly under Rew#comp() is NP -hard, and hence not solvable
in polynomial time unless P = NP . The polynomial-time intractability result for
ESAdaptpoly under Rew#comp() then follows by contradiction from Observation 3.

Result B.4 For any choice of Env(), if ESAdaptpoly under RewCodeB() is polynomial-

time exact solvable then P = NP .

Proof: Given the NP -hardness of Dominating set, the reduction in Lemma 8
implies that CSAdaptpoly under RewCodeB()is NP -hard, and hence not solvable in
polynomial time unless P = NP . The polynomial-time intractability result for
ESAdaptpoly under RewCodeB() then follows by contradiction from Observation 3.

Note that, unlike for ESCreatepoly, evaluating the polynomial-time exact promise
solvability of ESAdaptpoly is not possible. This is because (as noted previously in

38

Section 2) any version of ESAdaptpoly promising a working software system for the
given input will always have at least one such system — namely, S.

3.3.3 Polynomial-time Approximate Solvability of Restricted Emergent

Software Adaptation

We now consider if ESAdaptpoly is eﬃciently approximately solvable in either of
the three senses (frequently correct (deterministic), frequently correct (probabilis-
tic), or approximately optimal) listed at the start of Section 3.1. Once again, as with
ESAdaptpoly, this turns out not to be the case. The proofs of Results B.5–B.8 below
are analogous to the proofs for Results A.2 and A.3 in Section 3.2.2, only this time
relative to the proofs of Results B.3 and B.4 and Observation 3.

Result B.5 For any choice of Env(), if ESAdaptpoly under Rew#comp() is solvable
by a polynomial-time algorithm with a polynomial error frequency (i.e., err(n)
is upper bounded by a polynomial of n) then P = NP .

Result B.6 For any choice of Env(), if ESAdaptpoly under RewCodeB() is solvable by
a polynomial-time algorithm with a polynomial error frequency (i.e., err(n) is
upper bounded by a polynomial of n) then P = NP .

Result B.7 For any choice of Env(), if P = BP P and ESAdaptpoly under Rew#comp()
is polynomial-time solvable by a probabilistic algorithm which operates correctly
with probability

2/3 then P = NP .

≥

Result B.8 For any choice of Env(), if P = BP P and ESAdaptpoly under RewCodeB()
is polynomial-time solvable by a probabilistic algorithm which operates correctly
with probability

2/3 then P = NP .

≥

To assess cost-approximability, we need the following problem.
Optimal Component-based Software Adaptation (CSAdaptOP T )
Input: Software system requirements R, interface and component libraries Lint and
Lcomp
Lcomp, a working component-based software system S based on component c
relative to R, Lint, and Lcomp, and a reward function Rew().
Output: A working component-based software system S′ based on c relative to Lint,
Lcomp, and R that has the smallest possible value of Rew(S) over all working systems
based on c relative to Lint, Lcomp, and R.

∈

poly be the version of CSAdaptOP T such that given and candidate
Let CSAdaptOP T
component-based systems S and S′ run in time polynomial in the input size
I
.
|
|
Note that each input for ESAdaptpoly has a corresponding input to CSAdaptOP T
poly

39

(namely, the input to ESAdaptpoly without Env()). Moreover, any algorithm A that
solves ESAdaptpoly under some Rew() can also be used to solve CSAdaptOP T
poly (namely,
return whatever A run on the given input x for CSAdaptOP T
poly produces). This yields
the following useful observation.

Observation 4 For any choice of Rew() and Env(), if there is an algorithm A
of solvability type T for ESAdaptpoly under Rew() than there is an algorithm A′ of
solvability type T for CSAdaptOP T

poly under Rew().

Observe that the reductions in the proof of Lemmas 7 and 8 based on that in the proof
of Lemma 5 only add a working software component-based software system S and
do not change any other details of the constructed R, Lint, Lcomp, and c. Hence, the
following hold by slight modiﬁcations to the proofs of Lemmas 5 and 6 and Results
A.6 and A.7

Lemma 9 Dominating setOP T polynomial-time Levin reduces to CSAdaptOP T
poly un-
der Rew#comp() such that there is a dominating set of size k for the given instance
of Dominating setOP T if and only if there is a working component-based software
system S with reward value Rew#comp(S) = k + 2 for the constructed instance of
CSAdaptOP T
poly .

Lemma 10 Dominating setOP T polynomial-time Levin reduces to CSAdaptOP T
poly
under RewCodeB() such that there is a dominating set of size k for the given instance
of Dominating setOP T if and only if there is a working component-based software
system S with reward value RewCodeB(S) = 9k + 16 for the constructed instance of
CSAdaptOP T
poly .

Result B.9 For any choice of Env(), if ESAdaptOP T under Rew#comp() is polynomial-

time
c-approximable for any constant c > 0 then P = NP .

Result B.10 For any choice of Env(), if ESAdaptOP T under RewCodeB() is polynomial-

time
c-approximable for any constant c > 0 then P = NP .

3.3.4 Fixed-parameter tractability of Restricted Emergent Software Adap-

tation

Given the plethora of intractability results in the previous three subsections, we now
consider to what extent and relative to which parameters ESAdaptpoly is and is not
fp-tractable. Our results in this section are derived relative to the parameters listed

40

in Table 1 for ESCreatepoly in Section 3.2.4 and use versions of the proofs of Results
A.8, A.9, A.10, and A.11 as modiﬁed by the “twinning” and “padding” tricks used in
the proofs of Results B.1 and B.2. The former trick works relative to the results listed
above derived by reductions from Dominating set, as any instance of Dominating
set always has a trivial dominating set consisting of the set V of all vertices in the
given graph G which can be used to structure the “twin” given component-based
software system S. We show how this is done relative to the proof of Result A.8
for ESAdaptpoly under Rew#comp() and RewCodeB() and leave the details of the other
proofs to the reader.

Result B.11 For any choice of Env(), if

Lint

, Cpi, Cri, Scomp, Sdepth

under Rew#comp() is fp-tractable then F P T = W [2].

h|

|

-ESAdaptpoly

i

Proof: Consider the following polynomial-time Karp reduction from Dominating
set to CSAdaptpoly under Rew#comp(): given an instance I =
of
Dominating set, construct an instance I ′ =
R, Lint, Lcomp, S, c, Rew() =
h
Rew#comp(), k′
x1, x2, . . . , x|V |}
of CSAdaptpoly in which X =
, i.e., there is a unique
0, 1
Boolean variable corresponding to each vertex in V , and O =
V
. There are
|
, vij (xk) = T rue if
input-output pairs in R such that for ri = (ij, oj), 1
vk
NC(vj) and is F alse otherwise and oj = 1. Let Lint consist of k + 3 interfaces
broken into four groups:

G = (V, E), k

≤ |

{
V

≤

∈

{

}

j

i

i

h

|

|

1. A single interface of the form

interface topBase {

void main(Input I)

}

2. A single interface of the form

interface base1 {

void main1(Input I)

}

3. A single interface of the form

interface base2 {

void base1a(Input I)

}

41

4. A set of k interfaces of the form

interface condJ {

Boolean inSetJ(Input I)

}

for 1

J

≤

≤

k.

Let Lcomp consist of k

V

|

|

+ 4 components broken into ﬁve groups:

1. A single component of the form

component TopBase provides topBase requires base1 {

void main(Input I) {

main1(I)

}

}

2. A single component of the form

component Base1 provides base1 requires base2 {

void main1(Input I) {

base1a(I)

}

}

3. A single component of the form

component Base1a provides base2 {

void base1a(Input I)

requires cond1, cond2, ..., condk {

if inSet1(I) then output 1
elsif inSet2(I) then output 1

...

elsif inSetk(I) then output 1
else output 1

}

}

42

4. A single component of the form

component Base2 provides base1

requires cond1, cond2, ..., condk {

void main1(Input I) {

if inSet1(I) then output 1
elsif inSet2(I) then output 1

...

elsif inSetk(I) then output 1
else output 0

}

}

5. A set of k

V

|

|

components of the form

component InSetJK provides condJ {
Boolean inSetJ(Input I) {

return v_I(x_K)

}

}

for 1

J

k and 1

K

V

.

|

|

≤

≤

≤

≤ |
V

|
implementations of each cond-interface. Finally,
Note that in Lcomp, there are
let c be component TopBase in Lcomp, S be the component-based software system
k, and k′ = k + 2.
composed of TopBase, Base1, Base1A, and InSetJJ for 1
Note that the instance of CSAdaptpoly described above can be constructed in time
polynomial in the size of the given instance of Dominating set; moreover, as there
is only a (k + 1)-clause if-then statement block and no loops in the component code
and k
, any candidate component-based software system created relative
to Lint, Lcomp, and c runs in time linear in the size of input I ′.

≤ |

≤

≤

<

V

J

I

|

|

|

Let us now verify the correctness of this reduction:

• Suppose that there is a dominating set D of size at most k in the given instance
of Dominating set. We can then construct a component-based software sys-
tem S′ consisting of c, Base2, and the
InSet-components corresponding to
D
|
the vertices in D; the choice of which interface to implement for each vertex is
immaterial, and if there are less than k vertices in D, the ﬁnal k
required
cond-interfaces can be implemented relative to InSet-components correspond-
ing to arbitrary vertices in D. Observe that for each (ij, oj)
R, this software
system produces output oj given input ij and Rew#comp(S′) = k + 2.

− |

D

∈

|

|

43

≤

• Conversely, suppose that the constructed instance of CSAdaptpoly has a
working component-based software system S′ based on c relative to Lint, Lcomp,
and R such that Rew#comp(S′)
k′ = k + 2. This system cannot incorporate
components Base1 and Base1a, as this would result in Rew#comp(S′) = k + 4
6≤
k′ = k + 2. Hence, S′ must include component Base2. In order to correctly
k if-then statements in Base2
accommodate all input-output pairs in R, the
must implement InSet-components whose corresponding vertices form a domi-
nating set in G of size at most k. Hence, the existence of a working component-
based software system S′ for the constructed instance of CSAdaptpoly under
Rew#comp() such that Rew#comp(S′)
k′ implies the existence of a dominating
set of size at most k for the given instance of Dominating set.

≤

≤

h

i

k

This completes the proof of correctness of the reduction. Given the W [2]-hardness
-Dominating set, this reduction implies that CSAdaptpoly under Rew#comp()
of
is W [2]-hard when Cpi = 1, Sdepth = 4, Cri = k, and
= Scomp = k + 3 and
hence not fp-tractable relative to these parameters unless F P T = W [2]. The fp-
intractability result for ESAdaptpoly under Rew#comp() then follows by contradiction
from Observation 3.

Lint

|

|

Result B.12 For any choice of Env(), if

Lint

, Cpi, Cri, Scomp, Sdepth

under
RewCodeB() is fp-tractable then F P T = W [2].

h|

|

-ESAdaptpoly

i

Proof: Observe that in the reduction in the proof of Result B.11, if k′ = 6k + 15, the
only possible working component-based software system is that including TopBase
and Base2. The result then holds by a modiﬁed version of the proof of Result B.11.

Result B.13 For any choice of Env(),

if
Rew#comp() is fp-tractable then P = NP .

Result B.14 For any choice of Env(),

if
RewCodeB() is fp-tractable then P = NP .

Ici, Cpi, Sdepth

Ici, Cpi, Sdepth

h

h

i

i

-ESAdaptpoly under

-ESAdaptpoly under

Result B.15 For any choice of Env(), if
is fp-tractable then P = NP .

h

Ici, Cpi, Cri

i

-ESAdaptpoly under Rew#comp()

Result B.16 For any choice of Env(), if
is fp-tractable then P = NP .

h

Ici, Cpi, Cri

i

-ESAdaptpoly under RewCodeB()

Result B.17 For any choice of Env(),

h|
Rew#comp() is fp-tractable then P = NP .

if

Lcomp

|

, Ici, Sdepth

i

-ESAdaptpoly under

44

Result B.18 For any choice of Env(),

h|
RewCodeB() is fp-tractable then P = NP .

if

Lcomp

|

, Ici, Sdepth

i

-ESAdaptpoly under

The next three results follow from the algorithms in Results A.12–A.14, respectively,
in which all candidate working systems are generated and hence can be evaluated
under any Rew() of interest that is computable in time polynomial in the size of
given system S.

Result B.19 For any choice of Rew() and Env(),

fp-tractable.

Ici, Cri, Sdepth

h

i

-ESAdaptpoly is

Result B.20 For any choice of Rew() and Env(),

fp-tractable.

Ici, Scomp

h

i

-ESAdaptpoly

is

Result B.21 For any choice of Rew() and Env(),

fp-tractable.

Lint,

Lcomp

|

|i

h|

-ESAdaptpoly is

Given the fp-intractability results we have at this time, none of these fp-tractability
results are known to be minimal in the sense described at the end of Section 3.2.4.

4 Discussion

In this section, we will ﬁrst summarize our results for the problems ESCreate and
ESAdapt (Section 4.1). We then discuss the implications of these results for real-
world implementations of emergent software systems (Section 4.2). Several points
raised in this discussion motivate the inclusion of new results; so as not to disturb
the ﬂow of the discussion, proofs when required are given in the appendix. Finally,
we conclude with some general thoughts and caveats on how best to interpret and
use the results of computational complexity analyses such as ours within software
engineering (Section 4.3).

4.1 Summary of Results

Our results establish that neither of our investigated problems ESCreate or ESAdapt
is solvable exactly by any algorithm when no restrictions are placed on the structure
or operation of the derived software systems (Results A.1, B.1, and B.2). This in-
tractability still holds for both problems relative to polynomial-time exact and exact
promise solvability (Results A.2, A.3, B.3, and B.4) and all three of the considered
forms of polynomial-time approximability (Results A.4–A.7 and B.5–B.10) even when
software systems are restricted to run in time polynomial in the sizes of their inputs.

45

A Detailed Summary of Our Parameterized Complexity Results for
Table 2:
ESCreatepoly and ESAdaptpoly under Rew#comp() and RewCodeB(). a) Summary for
ESCreatepoly. Each column in this table is a result which holds relative to the
parameter-set consisting of all parameters with a @-symbol in that column. If the
result holds when a particular parameter has a constant value c, that is indicated by
c replacing @ for that parameter in that result’s column. Fp-intractability results are
given ﬁrst and fp-tractability results (shown in bold) are given last.

A.8 A.9 A.10 A.11 A.12 A.13 A.14
@
–
–
1
@
@
2

@
–
–
–
@
–
@ @ –
–
–
–
@ –
–
@ –
–
–
@ –

–
–
2
1
–
–
3

–
3
2
–
–
–
2

–
–
2
1
2
–
–

|

Lint
|
|
Lcomp
|
Ici
Cpi
Cri
Scomp
Sdepth

Moreover, both problems when so restricted remain ﬁxed-parameter intractable rel-
ative to all parameters listed in Table 1 (Results A.8–A.11 and B.11–B.18), both
individually and in many combinations and even when many parameters have val-
ues that are small constants. That being said, there are several combinations of
parameters that yield fp-tractability for our problems (see Tables 2–4).

Our intractability results have a surprisingly broad applicability. This is be-
cause all results (excluding polynomial-time exact promise unsolvability and cost-
inapproximability) are derived relative to two underlying problems — namely, CSCre-
ate (which asks for any working software system S relative to the given interface
and component libraries Lint and Lcomp and software system requirements R) and
CSAdapt (which asks for a working software system S′ relative to given Lint, Lcomp,
R, and S such that Rew(S′)
k for some given k). The use of CSCreate and
CSAdapt has two consequences. First, as CSCreate does not invoke Env() or Rew(),
intractability results derived relative to CSCreate hold for ESCreate relative to each
possible choice of Env() and Rew() and hence ESCreate in general. By analogous
reasoning, as CSAdapt does not invoke Env() but does explicitly invoke Rew() rel-
ative to given bound k, intractability results derived relative to CSAdapt hold for
ESAdapt relative to only some possible choices of Env() and Rew() — namely, any
possible Env() and one of either Rew#comp() or RewCodeB(). However, as these cases
must be solved by any algorithm that solves ESAdapt with arbitrary input Env()
and Rew(), these intractability results also hold for ESAdapt in general. Second, as

≤

46

A Detailed Summary of Our Parameterized Complexity Results for
Table 3:
ESCreatepoly and ESAdaptpoly under Rew#comp() and RewCodeB() (Cont’d). b) Sum-
mary for ESAdaptpoly under Rew#comp().

B.11 B.13 B.15 B.17 B.19 B.20 B.21
@
–
–
1
@
@
3

@
–
–
–
@
–
@ @ –
–
–
–
@ –
–
@ –
–
–
@ –

–
5
2
–
–
–
3

–
–
2
1
–
–
4

–
–
2
1
2
–
–

|

Lint
|
|
Lcomp
|
Ici
Cpi
Cri
Scomp
Sdepth

A Detailed Summary of Our Parameterized Complexity Results for
Table 4:
ESCreatepoly and ESAdaptpoly under Rew#comp() and RewCodeB() (Cont’d). c) Sum-
mary for ESAdaptpoly under RewCodeB().

B.12 B.14 B.16 B.18 B.19 B.20 B.21
@
–
–
1
@
@
3

@
–
–
–
@
–
@ @ –
–
–
–
@ –
–
@ –
–
–
@ –

–
–
2
1
–
–
4

–
5
2
–
–
–
3

–
–
2
1
2
–
–

|

Lint
|
|
Lcomp
|
Ici
Cpi
Cri
Scomp
Sdepth

neither CSCreate nor CSAdapt optimizes derived software systems relative to Rew(),
the observed forms of intractability for ESCreate and ESAdapt cannot be attributed
to optimization of derived software systems relative to Rew().

4.2

Implications for Real-world Emergent Software Systems

The foregoing is all well and good for our problems ESAdapt and ESCreate. However,
how applicable are our results to real-world emergent software system creation and
adaptation? Given the use of CSCreate (which ignores Rew()) to derive results for
ESCreate, all of our results, both for tractability and intractability, apply directly to
real-world emergent system creation. The situation is the same for ESAdapt relative
to real-world emergent system adaptation if one is only given the information in the

47

stated input to ESAdapt. However, this is not the case in the real-world emergent
software system described in [13, 12], where the adaptation process is also given the
complete list of working software systems created relative to Lint, Lcomp, and R (see
Section 2). If this list is small enough (i.e., of size polynomial in the sizes of Lint,
Lcomp, and R), then a linear scan of this list can determine a candidate with improved
(indeed, optimal) performance relative to Rew() and adaptation can be done in time
polynomial the sizes of Lint, Lcomp, R, and S. The issue of whether an intractable
problem can have some ﬁxed part of its input (e.g., Lint, Lcomp, R, and c) preprocessed
(probably in non-polynomial time) to create information of polynomial size that can
be used to solve subsequent instances of the problem with a varying part (e.g., S,
Rew(), and k) in polynomial time is addressed by the complexity framework given
in [37]. At present, relative to an admittedly artiﬁcial and problem-speciﬁc reward
function, we have the following result.

Result B.22 :] If ESAdaptpoly can have Lint, Lcomp, R, and c preprocessed to create
polynomial-size information that can be used to solve ESAdaptpoly instances of
arbitrary S, Rew(), and k in polynomial time then the Polynomial Hierarchy
P H collapse, i.e., P H = Σp
2.

There is good reason to believe that this result holds, as it is widely believed within
computer science that the Polynomial Hierarchy does not collapse, let alone to a
level as low in the Hierarchy as Σp
2 [38, 11, 39]. Note that this result applies to any
polynomial-length information obtained by preprocessing, and not just as in [12, 13]
a list of working software systems relative to Lint, Lcomp, c, and R. Though Result
B.22 does not invalidate the adaptation strategy employed in [12, 13], it does suggest
that it is not universally applicable to all instances of emergent system adaptation,
and that further complexity-theoretic work is necessary to determine those situations
in which it does and does not work.

Let us now consider some additional implications of our results:

• All of our polynomial-time and ﬁxed-parameter results for runtime-restricted
ESCreate and ESAdapt hold when valid software systems are restricted to run
( and hence can be veriﬁed against system requirements) in time polynomial
(and indeed, as noted in our proofs, linear) in the size of the given input. This
suggests that the basic computational diﬃculty of these problems is tied not
so much to V&V as the acts of creating working software systems from inter-
face and component libraries relative to a set of functional system requirements
(in the case of ESCreate) and attempting to merely improve (and not neces-
sarily optimize) the performance of an existing working system (in the case of
ESAdapt).

48

{

Ici, Cpi, Cri, Sdepth, Scomp

• Our ﬁxed-parameter intractability and tractability results for both of our prob-
are complete, in
lems relative to the parameter-set
the sense that the fp-status of our problems relative to each of the subsets of
this parameter set is known (see Tables 5–7). Moreover, our fp-tractability re-
sults are not only all based on diﬀerent runtime analyses of the same brute-force
candidate software system algorithm but are all minimal, in the sense that no
subset of the parameters invoked in any of these fp-tractability results yields
fp-tractability. This suggests that, short of additional restrictions, the proof-
of-concept brute-force enumeration algorithm proposed in [12, 13] for creating
valid software systems may in fact be the best possible.

}

• As all of our intractability results hold when component interfaces support spe-
cialized rather than universal composability, components are small, and com-
ponents comply with the single-responsibility design pattern, claims that these
attributes help tame the state space explosion when creating valid software sys-
tems from interface and component libraries ([12, pages 4 and 5] and [15, page
2], respectively) should be seen as incomplete, in the sense that additional re-
strictions may be required to account for observed eﬃcient operation. The same
holds relative to claims of the proposed linear bandit learning algorithm work-
ing with high probability [13, page 340] given our polynomial-time probabilistic
inapproximability results for ESAdapt.

Though the situation may change in future as additional results are derived, the above
does suggest that emergent software system adaptation may indeed be computation-
ally easier than emergent software system creation, and that eﬃcient adaptation (after
an initial computationally costly but unavoidable system creation) may be possible
in emergent software systems.

The above (in particular, the second and third bullet-points) very much begs the
question of under what additional restrictions such eﬃcient adaptation or creation
might be possible. Answering this question will aid both designing the best possible
emergent software systems and explaining when and why existing systems do perform
well (e.g., the claims listed in point (3) above). Known sets of aspect restrictions
that yield fp-tractability like those reported in this paper are a start, but given the
observed prevalence of fp-intractability, more aspects need to be analyzed. A good
source for these would be restrictions that “break” our intractability reductions, e.g.,
restricting the number of instances of required interfaces in a component that can be
implemented by multiple components. One should also not underestimate the value
of additional broad restrictions like our requirement that derived software systems
run in polynomial time. That such restrictions are critical is demonstrated by the
three results below, which follow from the reductions in the proofs of Results A.1,

49

B.1, and B.2 (in which the values of
all very small constants) and the deﬁnition of fp-tractability.

Lcomp

Lint

|

|

|

|

,

, Ici, Cpi, Cri, Scomp, and Sdepth are

Result A.15 For any choice of Rew() and Env(),

Sdepth

i

-ESCreate is unsolvable.

Lint

,

|

|

h|

Lcomp

Result B.23 For
Sdepth

any

choice

of Env(),

-ESAdapt under Rew#comp() is unsolvable.

, Ici, Cpi, Cri, Scomp,

, Ici, Cpi, Cri, Scomp,

, Ici, Cpi, Cri, Scomp,

|

|

|

Lint

h|

Lcomp

Lcomp

,

|

|

,

|

|

Result B.24 For
Sdepth

any

choice

of Env(),

h|
-ESAdapt under RewCodeB() is unsolvable.

Lint

i

i

Another demonstration is the above-noted solvability of ESAdapt in polynomial time
if polynomial-size preprocessed information is available. Additional possible restric-
tions of this type that might be useful could be on the forms of environment or
reward functions or the internal code structure and/or maximum code-length of com-
ponents. It might also be of use to consider alternative problem formulations. For
example, requiring that ESAdapt only derive a new system whose Rew()-performance
is a constant-valued improvement over that of the given system S (cf., the absolute
rather than S-relative performance bound currently implemented by k in CSAdapt)
will not lower the computational complexity of ESAdapt relative to Rew#comp() (as
the twinning trick used to derive these intractability results means that working sys-
tems diﬀer in at most one component and hence in Rew#comp()-value by at most one)
but it may well work relative to other reward functions.

4.3 Computational Complexity Analysis and

Software Engineering

Quite aside from the utility of intractability results for ESCreate and ESAdapt in
answering questions about the operation of existing emergent software systems and
the design of new ones, the mere existence of such results relative to standard types
of intractability such as Turing unsolvability and NP - and W -hardness has addi-
tional far-reaching consequences. This is because of structural complexity theory,
the subdiscipline of theoretical computer science that investigates the (non)inclusion
relationships between various complexity classes [38, 40, 41, 42]. As complexity
classes are typically deﬁned relative to particular types of algorithms (e.g., P , EXP ,
and P SP ACE are the classes of problems solvable in polynomial time, exponential
time, and polynomial space, respectively), standard intractability results typically
imply many other intractability results. For example, given the imminent availabil-
ity of functional quantum computers and the accompanying hoopla [43], one might
think that polynomial-time intractability (in particular, NP -hardness) results like

50

Systematic Parameterized Complexity Analysis of ESCreatepoly and
Table 5:
ESAdaptpoly Relative to the Parameter-set
. a) Analysis
for ESCreatepoly. In this table, a √ (X) symbol indicates that ES-create relative to
the parameter-set composed of the union of the row and column parameter-sets in-
dexing that entry is fp-(in)tractable. The original results are subscripted with the
result-number followed by a star; all other results are subscripted by number of the
result they are derived from relative to Lemmas 1 and 2.

Ici, Cpi, Cri, Sdepth, Scomp

{

}

Sdepth Scomp, Sdepth
Scomp
—
NPh
XA.8
XA.8
XA.9 √A.13∗ XA.9
XA.8
XA.8
XA.8
XA.8
XA.8
XA.8
XA.9 √A.13 XA.9∗
XA.10 √A.13 √A.12∗
XA.8
XA.8
XA.8
Ici, Cpi, Cri XA.10∗ √A.13 √A.12

—
Ici
Cpi
Cri
Ici, Cpi
Ici, Cri
Cpi, Cri

XA.8
√A.13
XA.8
XA.8
√A.13
√A.12
XA.8∗
√A.12

6⊆

those given here are moot. However, it is widely believed in computer science that
NP
BQP , where BQP (Bounded-error Quantum Polynomial Time) is considered
the largest class of problems solvable by usable quantum computer algorithms [44].
If any NP -hard problem is in BQP then this conjecture is false [44], rendering such
quantum solvability of NP -hard problems like ours very unlikely.

The above, in combination with the points raised and implications described ear-
lier in Section 4, highlights why computational complexity analyses are useful in
software engineering and moreover the context in which they can be used most pro-
ductively — namely, as part of an ongoing dialogue between software engineers and
theoretical computer scientists, in which questions raised by members of one group,
e.g.,

• Why do our systems (not) work as well as they do?

• Does this restriction on our systems matter, and if so, how?

• How do we formulate relevant problems for analysis?

• What types of algorithms do (not) exist for our problems?

inspire both investigations by and new questions from the other.

Before we close out this subsection, two ﬁnal caveats are in order. First, it is impor-
tant to note that the brute-force search algorithms underlying all of our fp-tractability

51

Table 6:
ESAdaptpoly Relative to the Parameter-set
Analysis for ESAdaptpoly under Rew#comp().

Systematic Parameterized Complexity Analysis of ESCreatepoly and
(Cont’d). b)

Ici, Cpi, Cri, Sdepth, Scomp

{

}

Sdepth
Scomp
—
NPh
XB.11
XB.11
XB.13 √B.20∗ XB.13
XB.11
XB.11 XB.11
XB.11 XB.11
XB.11
XB.13 √B.20 XB.13∗
XB.15 √B.20 √B.19∗
XB.11
XB.11 XB.11
Ici, Cpi, Cri XB.15∗ √B.20 √B.19

—
Ici
Cpi
Cri
Ici, Cpi
Ici, Cri
Cpi, Cri

Scomp, Sdepth
XB.11
√B.20
XB.11
XB.11
√B.20
√B.19
XB.11∗
√B.19

results are not immediately usable in real-world emergent software systems because
the running times of these algorithms are (to be blunt, ludicrously) exorbitant. This
diﬃculty is also not as bad as it initially seems because it is well known within
the parameterized complexity research community that once fp-tractability is proven
relative to a parameter-set, surprisingly eﬀective fp-algorithms can often be subse-
quently developed [45, 46]. This may involve either applying advanced fp-algorithm
design techniques or adding additional parameters to minimal parameter-sets, and
typically results in algorithm runtimes with greatly diminished non-polynomial terms
and polynomial terms that are additive rather than multiplicative.

Second, and perhaps more importantly, the ﬁxed-parameter (and indeed all of
the theoretical) analyses in this paper are only intended to sketch out what types of
eﬃcient algorithms do and do not exist for our problems of interest and are not in-
tended to be of immediate use. Given this, one may be tempted to conclude that our
results and by proxy theoretical analyses in general are irrelevant. We believe that
such a view is short-sighted at best and dangerous at worst. Not knowing the precise
conditions under which existing emergent software system creation and adaptation
algorithms work well may have serious consequences, e.g., drastically slowed software
creation time and/or unreliable software operation, if these conditions are violated.
These consequences would be particularly damaging in the case of the fully auto-
matic operations underlying emergent software systems. Given that reliable software
operation is crucial and eﬃcient software creation and adaptation is at the very least
desirable, the acquisition of such knowledge via a combination of rigorous empirical
and theoretical analyses should be a priority. With respect to theoretical analyses, it
is our hope that the techniques and results in this paper comprise a useful ﬁrst step.

52

Table 7:
ESAdaptpoly Relative to the Parameter-set
Analysis for ESAdaptpoly under RewCodeB().

Systematic Parameterized Complexity Analysis of ESCreatepoly and
(Cont’d). c)

Ici, Cpi, Cri, Sdepth, Scomp

{

}

Sdepth
Scomp
—
NPh
XB.12
XB.12
XB.14 √B.20∗ XB.14
XB.12
XB.12 XB.12
XB.12 XB.12
XB.12
XB.14 √B.20 XB.14∗
XB.16 √B.20 √B.19∗
XB.12
XB.12 XB.12
Ici, Cpi, Cri XB.16∗ √B.20 √B.19

—
Ici
Cpi
Cri
Ici, Cpi
Ici, Cri
Cpi, Cri

Scomp, Sdepth
XB.12
√B.20
XB.12
XB.12
√B.20
√B.19
XB.12∗
√B.19

5 Conclusions and Future Work

In this paper, we have applied computational complexity analysis to evaluate algorith-
mic options for emergent software system creation and adaptation relative to several
popular types of exact and approximate eﬃcient solvability. We have shown that nei-
ther problem is correctly and exactly solvable for all inputs when no restrictions are
placed on the structure and operation of valid software systems. This intractability
continues to hold relative to all examined types of eﬃcient exact and approximate
solvability when valid software systems are restricted to run in times polynomial in
their input sizes. Moreover, both of our problems remain intractable under a variety
of additional restrictions on valid software system structure, both individually and in
many combinations. That being said, we give sets of additional restrictions that do
yield tractability for both problems, as well as circumstantial evidence that emergent
software system adaptation is computationally easier than emergent software system
creation.

There are three promising directions for future research. The ﬁrst of these is to
extend our current analyses by (1) establishing the fp-status of our problems rela-
tive to all parameter-combinations from Table 1 and (2) considering additional pa-
rameters for and restrictions on emergent software systems. A productive source
for the latter might be restrictions which “break” the reduction-tricks used in our
intractability proofs. The second research direction is to consider additional compu-
tational problems associated with emergent software systems. Of particular interest
here is the automated synthesis of both variants of existing components and new
components from input-output examples [47, 48]. Analyses of these problems may
also give insights into the more general problem of program synthesis [49, 50, 51].

53

The third research direction involves not so much emergent software systems but self-
adaptive and component-based software systems in general. Invoking the terminology
in the taxonomy of component models given in [52], emergent software systems have
operation-based interfaces, provide horizontal and partial vertical component bind-
ing during composition, and explicitly distinguish between the required and provided
interfaces of a component. These characteristics are not only exploited by our in-
tractability result reductions but are also typical of many other component models
[52, Table 2]. Hence, it would be of great interest to see if our analyses for emer-
gent software systems could be extended to software system creation and adaptation
problems arising relative to other proposed types of self-adaptive software systems
[1, 7, 8] and within component-based software engineering in general [53, 54, 55].

Acknowledgements

The authors thank Barry Porter for invaluable discussions about and comments on
previous versions of this paper; though we have not been able to address all of his
concerns, we very much appreciate his eﬀorts in helping us create a better and more
relevant paper. TW would also like to thank Antonina Kolokolova for useful dis-
cussions on Rice’s Theorem and Ulrike Stege for introducing him to the research
area of self-adaptive software systems. TW was supported by National Science and
Engineering Council (NSERC) Discovery Grant 228104-2015.

References

[1] B. H. Cheng, R. de Lemos, H. Giese, P. Inverardi, J. Magee, J. Andersson,
B. Becker, N. Bencomo, Y. Brun, B. Cukic et al., “Software engineering for
self-adaptive systems: A research roadmap,” in Software Engineering for Self-
adaptive Systems, ser. Lecture Notes in Computer Science. Springer, 2009, vol.
5525, pp. 1–26.

[2] C. Krupitzer, F. M. Roth, S. VanSyckel, G. Schiele, and C. Becker, “A sur-
vey on engineering approaches for self-adaptive systems,” Pervasive and Mobile
Computing, vol. 17, pp. 184–206, 2015.

[3] M. Salehie and L. Tahvildari, “Self-adaptive software: Landscape and research
challenges,” ACM Transactions on Autonomous and Adaptive Systems (TAAS),
vol. 4, no. 2, p. 14, 2009.

54

[4] D. G. D. L. Iglesia and D. Weyns, “MAPE-K formal templates to rigorously
design behaviors for self-adaptive systems,” ACM Transactions on Autonomous
and Adaptive Systems (TAAS), vol. 10, no. 3, pp. 1–31, 2015.

[5] K. Angelopoulos, A. V. Papadopoulos, V. E. S. Souza, and J. Mylopoulos, “En-
gineering self-adaptive software systems: From requirements to model predictive
control,” ACM Transactions on Autonomous and Adaptive Systems (TAAS),
vol. 13, no. 1, pp. 1–27, 2018.

[6] A. Filieri, M. Maggio, K. Angelopoulos, N. D’ippolito, I. Gerostathopoulos, A. B.
Hempel, H. Hoﬀmann, P. Jamshidi, E. Kalyvianaki, C. Klein et al., “Con-
trol strategies for self-adaptive software systems,” ACM Transactions on Au-
tonomous and Adaptive Systems (TAAS), vol. 11, no. 4, pp. 1–31, 2017.

[7] R. De Lemos, D. Garlan, C. Ghezzi, H. Giese, J. Andersson, M. Litoiu,
B. Schmerl, D. Weyns, L. Baresi, N. Bencomo et al., “Software engineering for
self-adaptive systems: Research challenges in the provision of assurances,” in
Software Engineering for Self-Adaptive Systems III, ser. Lecture Notes in Com-
puter Science. Springer, 2017, vol. 9640, pp. 3–30.

[8] R. De Lemos, H. Giese, H. A. M¨uller, M. Shaw, J. Andersson, M. Litoiu,
B. Schmerl, G. Tamura, N. M. Villegas, T. Vogel et al., “Software engineering
for self-adaptive systems: A second research roadmap,” in Software Engineering
for Self-Adaptive Systems II, ser. Lecture Notes in Computer Science. Springer,
2013, vol. 7475, pp. 1–32.

[9] R. G. Downey and M. R. Fellows, Fundamentals of Parameterized Complexity.

Berlin: Springer, 2013.

[10] M. R. Garey and D. S. Johnson, Computers and Intractability. W.H. Freeman,

1979.

[11] O. Goldreich, Computational Complexity: A Conceptual Perspective. Cambridge

University Press, 2008.

[12] R. R. Filho and B. Porter, “Deﬁning emergent software using continuous self-
assembly, perception, and learning,” ACM Transactions on Autonomous and
Adaptive Systems (TAAS), vol. 12, no. 3, pp. 16:1–16:25, 2017.

[13] B. Porter, M. Grieves, R. R. Filho, and D. Leslie, “REX: A development plat-
form and online learning approach for runtime emergent software systems,” in
12th USENIX Symposium on Operating Systems Design and Implementation
(OSDI 16), 2016, pp. 333–348.

55

[14] R. R. Filho, B. Porter, F. Costa, and M. Pereira de S´a, “Towards emergent
microservices for client-tailored design,” in Proceedings of the 19th Workshop on
Adaptive and Reﬂexive Middleware. ACM, 2018, pp. 1–6.

[15] B. Porter and R. R. Filho, “Distributed emergent software: Assembling, perceiv-
ing and learning systems at scale,” in Proceedings of the 13th IEEE International
IEEE, 2019.
Conference on Self-Adaptive and Self-Organizing Systems (SASO).

[16] E. H. Page and J. M. Opper, “Observations on the complexity of composable
simulation,” in Proceedings of the 31st Winter Conference on Simulation, vol. 1.
ACM, 1999, pp. 553–560.

[17] M. Petty, E. Weisel, and R. Mielke, “Computational complexity of selecting
components for composition,” in Proceedings of the Fall 2003 Simulation Inter-
operability Workshop, 2003, pp. 14–19.

[18] R. G. Bartholet, D. C. Brogan, and P. F. Reynolds Jr, “The computational
complexity of component selection in simulation reuse,” in Proceedings of the
2005 Winter Simulation Conference, 2005, pp. 2472–2481.

[19] M. Nouri and J. Habibi, “Approximating component selection with general
Springer, 2008,

costs,” in Advances in Computer Science and Engineering.
pp. 61–68.

[20] M. R. Fox, D. C. Brogan, and P. F. Reynolds Jr, “Approximating component
selection,” in Proceedings of the 36th conference on Winter simulation. Winter
Simulation Conference, 2004, pp. 429–434.

[21] N. Haghpanah, S. Moaven, J. Habibi, M. Kargar, and S. H. Yeganeh, “Approxi-
mation algorithms for software component selection problem,” in Proceedings of
the 14th Asia-Paciﬁc Software Engineering Conference (APSEC 2007).
IEEE,
2007, pp. 159–166.

[22] T. Wareham and M. Sweers, “On the computational complexity of designing
and reconﬁguring component-based software systems,” in Proceedings of the 9th
EAI International Conference on Bio-inspired Information and Communication
Technologies (BICT 2015). Brussels: Institute for Computer Sciences, Social-
informatics, and Telecommunications Engineering (ICST), 2015, pp. 425–432.

[23] ——, “On the computational complexity of designing and reconﬁguring
component-based software systems,” EAI Endorsed Transactions on Self-
Adaptive Systems, vol. 16, no. 5, p. e4, 2016.

56

[24] ——, “On the computational complexity of designing and reconﬁguring
component-based software systems: A computational complexity approach
(full version),” 2022, coRR abs/2205.05001 (38 pages).
[Online]. Available:
https://arxiv.org/abs/2205.05001

[25] L. A. Hemaspaandra and R. Williams, “Complexity Theory Column 76: An atyp-
ical survey of typical-case heuristic algorithms,” ACM SIGACT News, vol. 43,
no. 4, pp. 70–89, 2012.

[26] R. Motwani and P. Raghavan, Randomized Algorithms. Chapman & Hall/CRC,

2010.

[27] G. Ausiello, P. Crescenzi, G. Gambosi, V. Kann, A. Marchetti-Spaccamela, and
M. Protasi, Complexity and Approximation: Combinatorial Optimization Prob-
lems and their Approximability Properties. Springer, 1999.

[28] L. Fortnow, “The Status of the P Versus NP Problem,” Communications of the

ACM, vol. 52, no. 9, pp. 78–86, 2009.

[29] A. M. Turing, “On computable numbers, with an application to the entschei-
dungsproblem,” Proceedings of the London Mathematical Society, vol. 42, no.
230-265, 1936.

[30] B. Porter, “Runtime modularity in complex structures: A component model for
ﬁne grained runtime adaptation,” in Proceedings of the 17th International ACM
SIGSOFT Symposium on Component-based Software Engineering. ACM, 2014,
pp. 29–34.

[31] A. Wigderson, “P, NP and mathematics — A computational complexity perspec-
tive,” in Proceedings of ICM 2006: Volume I. Zurich: EMS Publishing House,
2007, pp. 665–712.

[32] R. G. Downey and M. R. Fellows, Parameterized Complexity. Berlin: Springer,

1999.

[33] I. van Rooij, M. Blokpoel, J. Kwisthout, and T. Wareham, Cognition and In-
tractability: A Guide to Classical and Parameterized Complexity Analysis. Cam-
bridge, UK: Cambridge University Press, 2019.

[34] J. E. Hopcroft, R. Motwani, and J. Ullman, Introduction to Automata Theory,

Languages, and Computation, 2nd ed. Addison-Wesley, 2001.

[35] T. Wareham, “Systematic parameterized complexity analysis in computational

phonology,” Ph.D. dissertation, University of Victoria, Canada, 1999.

57

[36] C. Lund and M. Yannakakis, “On the hardness of approximating minimization
problems,” Journal of the ACM (JACM), vol. 41, no. 5, pp. 960–981, 1994.

[37] M. Cadoli, F. M. Donini, P. Liberatore, and M. Schaerf, “Preprocessing of in-
tractable problems,” Information and Computation, vol. 176, no. 2, pp. 89–120,
2002.

[38] J. L. Balc´azar, J. D´ıaz, and J. Gabarr´o, Structural Complexity I, ser. EATCS
Monographs on Theoretical Computer Science. Berlin: Springer-Verlag, 1988,
vol. 11.

[39] B. Rossman, R. A. Servedio, and L.-Y. Tan, “An average-case depth hierarchy
theorem for boolean circuits,” in 56th Annual IEEE Symposium on Foundations
of Computer Science (FOCS).

IEEE, 2015, pp. 1030–1048.

[40] J. L. Balc´azar, J. D´ıaz, and J. Gabarr´o, Structural Complexity II, ser. EATCS
Monographs on Theoretical Computer Science. Berlin: Springer-Verlag, 1990,
vol. 22.

[41] S.

Aaronson.

(2020)

The

complexity

zoo.

[Online].

Available:

https://complexityzoo.uwaterloo.ca/Complexity Zoo

[42] D. S. Johnson, “A catalog of complexity classes,” in Handbook of Theoretical
Computer Science, J. van Leeuwen, Ed. Elsevier, 1990, vol. A: Algorithms and
complexity, pp. 67–161.

[43] L. Gyongyosi and S. Imre, “A survey on quantum computing technology,” Com-

puter Science Review, vol. 31, pp. 51–71, 2019.

[44] E. Bernstein and U. Vazirani, “Quantum complexity theory,” SIAM Journal on

Computing, vol. 26, no. 5, pp. 1411–1473, 1997.

[45] M. Cygan, F. V. Fomin, L. Kowalik, D. Lokshtanov, D. Marx, M. Pilipczuk,
M. Pilipczuk, and S. Saurabh, Parameterized Algorithms. Springer, 2015.

[46] F. V. Fomin, D. Lokshantov, S. Saurabh, and M. Zehavi, Kernalization: Theory
of Parameterized Prepreocessing. Cambridge, UK: Cambridge University Press,
2019.

[47] R. R. Filho, A. Wild, and B. Porter, “Code synthesis in self-improving software
systems,” in 4th International Workshop on Foundations and Applications of
Self* Systems (FAS* W).

IEEE, 2019, pp. 4–5.

58

[48] C. McGowan, A. Wild, and B. Porter, “Experiments in genetic divergence for
emergent systems,” in Proceedings of the 4th International Workshop on Genetic
Improvement, 2018, pp. 9–16.

[49] M. Balog, A. L. Gaunt, M. Brockschmidt, S. Nowozin, and D. Tarlow, “Deep-
coder: Learning to write programs,” in 5th International Conference on Learning
Representations, ICLR 2017-Conference Track Proceedings, 2017.

[50] S. Gulwani, “Dimensions in program synthesis,” in Proceedings of the 12th Inter-
national ACM SIGPLAN Symposium on Principles and Practice of Declarative
Programming, 2010, pp. 13–24.

[51] S. Gulwani, O. Polozov, and R. Singh, “Program synthesis,” Foundations and

Trends® in Programming Languages, vol. 4, no. 1-2, pp. 1–119, 2017.

[52] I. Crnkovic, S. Sentilles, A. Vulgarakis, and M. R. Chaudron, “A classiﬁcation
framework for software component models,” IEEE Transactions on Software En-
gineering, vol. 37, no. 5, pp. 593–615, 2011.

[53] D. Gruntz, S. Murer, and C. Szyperski, Component Software-Beyond Object-

Oriented Programming. Addison-Wesley, 2002.

[54] G. T. Heineman and W. T. Councill, Eds., Component-Based Software Engi-

neering: Putting the Pieces Together. Addison-Wesley, 2000.

[55] T. Vale, I. Crnkovic, E. S. de Almeida, P. A. d. M. S. Neto, Y. C. Cavalcanti,
and S. R. de Lemos Meira, “Twenty-eight years of component-based software
engineering,” Journal of Systems and Software, vol. 111, pp. 128–148, 2016.

[56] R. Karp and R. J. Lipton, “Turing machines that take advice,” Enseignement

Mathematique., vol. 28, pp. 191–209, 1982.

A Proofs of Selected Results

Let us ﬁrst prove Result A.9. In the reduction below, instead of encoding a dominat-
ing set of size k implicitly in the components implementing procedures InSet1(),
InSet2(), ..., InSetk() as in the reductions in the proofs of Lemmas 4 and 5, a
candidate dominating set is encoded explicitly in binary-valued vector vS in compo-
nent Base in the components used to implement the procedures vertexStatus1(),
vertexStatus2(), ..., vertexStatus(|V|(). Moreover, checks to see if this can-
didate is an actual dominating set of size k in G are explicitly coded in component
Base (see Figure 7. This allows us to reduce the maximum number of interfaces

59

Base

vertStat1

. . .

vertStat2

vertStat|V|

VertexStatus1

VertexStatus2

VertexStatus|V|

domSetStat

domSetStat

domSetStat

DomSetStatusx

DomSetStatusx

DomSetStatusx

Figure 7: General structure of valid software systems created by the reduction in
the proof of Result A.9. Note that index x in DomSetStatusx is such that x
0, 1

∈
. Following the convention in Figure 3, interfaces with multiple implementing

{
components are enclosed in dashed boxes.

}

provided by any component and the maximum number of components implemented
by any interface to 1 and 2, respectively, while maintaining a maximum component
depth of 3.

Result A.9 For any choice of Rew() and Env(), if

fp-tractable then P = NP .

Ici, Cpi, Sdepth

h

i

-ESCreatepoly is

Proof: Consider the following polynomial-time Karp reduction from Dominating
set to CSCreatepoly: given an instance I =
of Dominating set,
h
construct an instance I ′ =
of CSCreatepoly in which R is the same
as that given in the reduction in the proof of Lemma 4. Let Lint consist of
+ 2
interfaces broken into three groups:

R, Lint, Lcomp, c

G = (V, E), k

V

h

i

i

|

|

1. A single interface of the form

interface base {

void main(Input I)

}

2. A set of

V

|

|

interfaces of the form

interface vertStatJ {

int vertexStatusJ()

}

for 1

J

V

.

|

≤ |

≤

60

3. An interface of the form

interface domSetStat {
int domSetStatus()

}

Let Lcomp consist of

V

+ 3 components broken into three groups:

|
1. A single component of the form

|

component Base provides base

requires vertStat1, vertStat2, ...,

vertStat|V| {

void main(Input I) {

create integer array vS of length |V|

vS[1] = vertexStatus1()
vS[2] = vertexStatus2()

...

vS[|V|] = vertexStatus|V|()

numFound = 0
for i = 1 to |V| do

if vS[j] == 1 then

numFound = numFound + 1

if numFound == k then

isCandidatekDomSet = True

else

isCandidatekDomSet = False

if isCandidatekDomSet then

numFound = 0
for i = 1 to |V| do

if v_I(x_i) and vS[i] == 1 then
numFound = numFound + 1

if numFound > 0 then

output 1

else

61

output 0

else

output 0

}

}

2. A set of

V

|

|

components of the form

component VertexStatusJ provides vertStatJ {

requires domSetStat

int vertexStatusJ() {

return domSetStatus()

}

}

for 1

J

V

.

|

≤ |

≤

3. Two components of the form

component DomSetStatus0 provides domSetStat {

int domSetStatus() {

return 0

}

}

component DomSetStatus1 provides domSetStat {

int domSetStatus() {

return 1

}

}

Observe that in component Base, if entry i of array vS has value 1, then vertex i is in
the candidate dominating set for G encoded in vS. Finally, let c be component Base
in Lcomp. Note that the instance of CSCreatepoly described above can be constructed
in time polynomial in the size of the given instance of Dominating set; moreover,
-length assignment statement block and two single-level loops in
as there is only a
<
the component code that each execute at most
times, any component-based
software system created relative to Lint, Lcomp, and c runs in time linear in the size
of input I ′.

V

V

I

|

|

|

|

|

|

Let us now verify the correctness of this reduction:

62

Base

vertStat1

. . .

vertStat2

vertStat|V|

VertexStatus1

VertexStatus2

VertexStatus|V|

domSetStat

domSetStat

domSetStat

DomSetStatusx

DomSetStatusx

DomSetStatusx

Figure 8: General structure of valid software systems created by the reduction in
the proof of Result A.10. Note that index x in DomSetStatusx is such that x
0, 1

∈
. Following the convention in Figure 3, interfaces with multiple implementing

{
components are enclosed in dashed boxes.

}

|

• Suppose there is a dominating set D of size at most k in the given instance of
Dominating set; if
< k, augment D with k
D
arbitrary other vertices
− |
|
= k. Construct a component-based software system con-
D
from G such that
|
|
sisting of c and all
V
in which
the domSetStat interface in component VertexStatusJ is implemented by com-
ponent DomSetStatus1 if vertex J is in D and by component DomSetStatus0
otherwise. Observe that for each (ij, oj)
R, this software system produces
output oj given input ij.

components VertexStatusJ for 1

≤ |

D

≤

∈

V

J

|

|

|

|

• Conversely, suppose that the constructed instance of CSCreatepoly has a working
component-based software system based on c relative to Lint, Lcomp, and R.
vertexStatus
In order to accommodate all input-output pairs in R, the
components must implement their domSetStat interfaces such that the 1-values
in array vS specify a dominating set of size k in G. Hence, the existence of
a working component-based software system for the constructed instance of
CSCreatepoly implies the existence of a dominating set of size k for the given
instance of Dominating set.

V

|

|

The reduction above is thus correct. Given the NP -hardness of Dominating set,
this reduction implies that CSCreatepoly is NP -hard when Ici = 2, Cpi = 1, and
Sdepth = 3 and hence by Lemma 3 not fp-tractable relative to these parameters unless
P = NP . The fp-intractability result for ESCreatepoly then follows by contradiction
from Observation 1.

Let us now prove Result A.10.

In the reduction below, we modify the reduc-
tion in the proof of Result A.9 to split the call to procedures vertexStatus1(),
vertexStatus2(), ..., vertexStatus|V|() in component Base over
base-

V

|

|

63

components (see Figured 8). This still allows us to have the values of the maxi-
mum number of interfaces provided by any component and the maximum number of
components implemented by any interface as 1 and 2, respectively, as in the previ-
ous reduction but trades oﬀ constant-valued component depth for a constant-valued
maximum number of interfaces required by any component.

Result A.10 For any choice of Rew() and Env(), if

fp-tractable then P = NP .

Ici, Cpi, Cri

h

i

-ESCreatepoly is

Proof: Consider the following polynomial-time Karp reduction from Dominating
set to CSCreatepoly: given an instance I =
of Dominating set,
h
construct an instance I ′ =
of CSCreatepoly in which R is the same
as that given in the reduction in the proof of Lemma 4. Let Lint consist of 2
+ 1
interfaces broken into four groups:

R, Lint, Lcomp, c

G = (V, E), k

V

h

i

i

|

|

1. A single interface of the form

interface base {

void main(Input I)

}

2. A set of

V

|

| −

1 interfaces of the form

interface baseJ {

void callBaseJ(Input I, int[] vS)

}

J

for 2

≤
3. A set of

V

.

|

≤ |
V

|

|

interfaces of the form

interface vertStatJ {

int vertexStatusJ()

}

for 1

J

V

.

≤

≤ |
4. An interface of the form

|

64

interface domSetStat {
int domSetStatus()

}

Let Lcomp consist of 2

V

|

|

+ 2 components broken into ﬁve groups:

1. A single component of the form

component Base provides base

requires vertStat1, base2 {

void main(Input I) {

create integer array vS of length |V|

vS[1] = vertexStatus1()

callBase2(I, vS)

}

}

2. A set of

V

|

| −

2 components of the form

component BaseJ provides baseJ

requires vertStatJ, base(J + 1) {

void callBaseJ(Input I, int[] vS) {

vS[J] = vertexStatusJ()

callBase(J + 1)(I, vS)

}

}

for 2

J

V

≤ |

≤

| −

1.

3. A single component of the form

component Base|V| provides base|V|

requires vertStat|V| {

void callBase|V|(Input I, int[] vS) {

65

vS[|V|] = vertexStatus|V|()

numFound = 0
for j = 1 to |V| do

if vS[i] == i then

numFound = numFound + 1

if numFound = k then

isCandidatekDomSet = True

else

isCandidatekDomSet = False

if isCandidatekDomSet then

numFound = 0
for i = 1 to |V| do

if v_I(x_i) and vS[i] == 1 then
numFound = numFound + 1

if numFound > 0 then

else

output 1

output 0

else

output = 0

}

}

4. A set of

V

|

|

components of the form

component VertexStatusJ provides vertStatJ {

requires domSetStat

int vertexStatusJ() {

return domSetStatus()

}

}

for 1

J

V

.

|

≤ |

≤

5. Two components of the form

66

component DomSetStatus0 provides domSetStat {

int domSetStatus() {

return 0

}

}

component DomSetStatus1 provides domSetStat {

int domSetStatus() {

return 1

}

}

Finally, let c be component Base in Lcomp. Note that the instance of CSCreatepoly
described above can be constructed in time polynomial in the size of the given instance
of Dominating set; moreover, as there are only single-level loops in the component
I
code that each execute at most
times, any component-based software system
|
created relative to Lint, Lcomp, and c runs in time linear in the size of input I ′.

<

V

|

|

|

|

|

J

J

V

V

≤

≤

≤ |

Observe that interfaces base, vertStatJ for 1

, and domSetStat and
, DomSetStatus0, and DomSetStatus1
components VertexStatusJ for 1
≤ |
are the same as in the reduction in the proof of Result A.9. Moreover, interfaces
base and baseJ, and components Base and callBaseJ, 2
, eﬀectively
simulate interface base and component Base in the same reduction. Hence, the
proof of correctness of the reduction in the proof of Result A.9 can, with slight
modiﬁcations, also proves the correctness of the reduction described above. Given
the NP -hardness of Dominating set, this reduction implies that CSCreatepoly is
NP -hard when Ici = 2, Cpi = 1, and Cri = 2, and hence by Lemma 3 not fp-
tractable relative to these parameters unless P = NP . The fp-intractability result
for ESCreatepoly then follows by contradiction from Observation 1.

≤ |

≤

V

J

|

Let us now prove Result A.11. The reduction below modiﬁes that given in the
proof of Result A.9 such that there are still only two components DomSetStatus0
and DomSetStatus1 but now, each of these components contains customized versions
of procedures vertexStatus1(), vertexStatus2(), ..., vertexStatus|V|() in-
stead of placing these procedures separately in components VertexStatus1,
VertexStatus2, ..., VertexStatus|V| (see Figure 9). By invoking the abilities of
diﬀerent interfaces to implement diﬀerent copies of the same component and imple-
menting components to provide to an interface only that code which is used by that
interface, not only is the maximum component depth reduced by one but the size of
the component library Lcomp is reduced to a constant (namely, 3).

67

Base

vertStat1

vertStat|V|

. . .

vertStat2

DomSetStatusx DomSetStatusx

DomSetStatusx

Figure 9: General structure of valid software systems created by the reduction in
the proof of Result A.11. Note that index x in DomSetStatusx is such that x
0, 1

∈
. Following the convention in Figure 3, interfaces with multiple implementing

{
components are enclosed in dashed boxes.

}

Result A.11 For any choice of Rew() and Env(), if

is fp-tractable then P = NP .

Lcomp

|

h|

, Ici, Sdepth

i

-ESCreatepoly

Proof: Consider the following polynomial-time Karp reduction from Dominating
set to CSCreatepoly: given an instance I =
of Dominating set,
h
construct an instance I ′ =
of CSCreatepoly in which R is the same
as that given in the reduction in the proof of Lemma 4. Let Lint consist of
+ 1
interfaces broken into two groups:

R, Lint, Lcomp, c

G = (V, E), k

V

h

i

i

|

|

1. A single interface of the form

interface base {

void main(Input I)

}

2. A set of

V

|

|

interfaces of the form

interface vertStatJ {

int vertexStatusJ()

}

for 1

J

V

.

|

≤ |

≤

Let Lcomp consist of 3 components broken into three groups:

1. A single component of the form

68

component Base provides base

requires vertStat1, vertStat2, ...,

vertStat|V| {

void main(Input I) {

create integer array vS of length |V|

vS[1] = vertexStatus1()
vS[2] = vertexStatus2()

...

vS[|V|] = vertexStatus|V|()

numFound = 0
for i = 1 to |V| do

if vS[i] == i then

numFound = numFound + 1

if num_found == k then

isCandidatekDomSet = True

else

isCandidatekDomSet = False

if isCandidatekDomSet then

numFound = 0
for i = 1 to |V| do

if v_I(x_i) and vS[i] == 1 then
numFound = numFound + 1

if numFound > 0 then

else

output 1

output 0

else

output 0

}

}

69

2. Two components of the form

component DomSetStatus0 provides vertStat1, vertStat2, ...

vertStat|V| {

int vertexStatus1() {

return 0

}

int vertexStatus2() {

return 0

}

...

int vertexStatus|V|() {

return 0

}

}

component DomSetStatus1 provides vertStat1, vertStat2, ...

vertStat|V| {

int vertexStatus1() {

return 1

}

int vertexStatus2() {

return 1

}

...

int vertexStatus|V|() {

return 1

}

}

Observe that in component Base, if entry i of array vS has value 1 then vertex i is in
the candidate dominating set for G encoded in vS. Finally, let c be component Base

70

in Lcomp. Note that the instance of CSCreatepoly described above can be constructed
in time polynomial in the size of the given instance of Dominating set; moreover,
-length assignment block and two single-level loops in
as there are only a single
the component code that each execute at most
times, any component-based
software system created relative to Lint, Lcomp, and c runs in time linear in the size
of input I ′.

<

V

V

I

|

|

|

|

|

|

Let us now verify the correctness of this reduction:

D

< k, augment D with k

• Suppose there is a dominating set D of size at most k in the given instance
of Dominating set; if
arbitrary other
|
|
= k. Construct a component-based software
D
vertices from G such that
|
|
copies of the domSetStatus components in
V
system consisting of c and
which the vertStatJ interface in component Base is implemented by com-
ponent DomSetStatus1 if vertex J is in D and by component DomSetStatus0
otherwise. Observe that for each (ij, oj)
R, this software system produces
output oj given input ij.

− |

D

∈

|

|

|

• Conversely, suppose that the constructed instance of CSCreatepoly has a working
component-based software system based on c relative to Lint, Lcomp, and R. In
vertStatJ interfaces
order to accommodate all input-output pairs in R, the
in component Base must be implemented by domSetStatus components such
that the produced values in array vS specify a dominating set of size k in G.
Hence, the existence of a working component-based software system for the
constructed instance of CSCreatepoly implies the existence of a dominating set
of size k for the given instance of Dominating set.

V

|

|

The reduction above is thus correct. Given the NP -hardness of Dominating set,
this reduction implies that CSCreatepoly is NP -hard when
= 3, Ici = 2, and
Sdepth = 2 and hence by Lemma 3 not fp-tractable relative to these parameters unless
P = NP . The fp-intractability result for ESCreatepoly then follows by contradiction
from Observation 1.

Lcomp

|

|

Finally, let us prove Result B.22. This result addresses the feasibility of prepro-
cessing a ﬁxed portion of the input to an intractable problem to create polynomial-size
information that can be used to solve future instances of that problem relative to a
varying portion of the problem input in polynomial time. This will be evaluated using
the computational complexity framework described in [37]. The input to a problem
, where x is the ﬁxed part and y is the
x, y
of interest will be considered as a pair
varying part. As we will focus here on decision problems like CSCreatepoly in the main
text whose solution is either “Yes” or “No”, each such problem will be considered a
language of pairs. An example of such a problem is

i

h

71

Base

varAssign1

. . .

varAssign2

varAssign(m+1)

VarAssign1

VarAssign2

VarAssign(m+1)

truthValue

truthValue

truthValue

TruthValuex

TruthValuex

TruthValuex

Figure 10: General structure of valid software systems created by the reduction
in the proof of Result B.22. Note that index x in TruthValuex is such that
x
. Following the convention in Figure 3, interfaces with multiple
implementing components are enclosed in dashed boxes.

T rue, F alse
}

∈ {

C-SAT =

(f ), (p)

{h

i |

p can be extended to a truth assignment satisfying f

}

where ﬁxed part f is a formula in conjunctive normal form (a set C =
}
of clauses AND-ed together where each clause is a set of negated or unnegated Boolean
variables, e.g., (v1OR
v2ORv4)AND(v2ORv3)) over a set of Boolean variables V =
and varying part p is a partial truth assignment to the variables in
v1, v2, . . . , vm
{
V . Consider the following reducibility between such problems.

C1, C2, . . . Cn

¬

{

}

  reduction between two languages of pairs A
Deﬁnition 4 [37, Deﬁnition 2.8] A
and B is a triplef1, f2, g) where f1 and f2 are poly-size unary functions and g is a
it holds that:
binary polynomial-time function such that for any pair of strings

x, y

||

h

i

x, y

h

i ∈

A if and only if

h

y

), g(f2(x,

f1(x,
  reductions relative to a class

), y)

i ∈

B

y

|

|

|

|

 NP [37,
It is known that C-SAT is hard under
||
Section 3.1] and hence not preprocessable in the sense above unless the Polynomial
Hierarchy P H collapses, i.e., P H = Σr
2 [37, Theorem 2.12].5 We will now prove the
result by a reduction based on that in the proof of Result A.9 (see Figure 10).

||

Result B.22: If ESAdaptpoly can have Lint, Lcomp, R, and c preprocessed to create
polynomial-size information that can be used to solve ESAdaptpoly instances of
arbitrary S, Rew(), and k in polynomial time then the Polynomial Hierarchy
P H collapses, i.e., P H = Σp
2.

5Aﬁcionados of [37] will protest that by Theorem 2.12, our result implies that the Polynomial
3. However, when that theorem is combined with the Karp-Lipton
2), we

Hierarchy only collapses to Σp
Theorem [56] (the most typical version of which states that if N P
can strengthen Theorem 2.12 to give our stated result.

P/P oly then P H = Σp

⊆

72

(f ), (p)

  reduction from C-SAT to CSAdaptpoly: given
Proof: Consider the following
(R, Lint, Lcomp, c),
an instance I =
(S, Rew(), k)
.
}
Let f ′ be the version of f in which there is a new Boolean variable xm+1 that is OR-ed
into every clause and p′ be the version of p such that xm+1 = F alse. Let Lint consist
of m + 3 interfaces broken into three groups:

of CSAdaptpoly in which R has a single input-output pair

of C-SAT, construct an instance I ′ =

T rue, 1

||

{

i

h

i

h

1. A single interface of the form

interface Base {

void main(Input I)

}

2. A set of m + 1 interfaces of the form

interface varAssignJ {

Boolean varAssignJ()

}

for 1

J

m + 1.

≤

≤
3. An interface of the form

interface truthValue {

Boolean truthValue()

}

Let Lcomp consist of m + 4 components broken into three groups:

1. A single component of the form

component Base provides base

requires varAssign1, varAssign2, ...,

varAssignm {

void main(Input I) {

create Boolean array vA of length m

vA[1] = varAssign1()

73

vA[2] = varAssign2()

...

vA[m+1] = varAssign(m+1)()

if truth assignment vA satisfies f’ then

else

output 1

output 0

}

}

2. A set of m + 1 components of the form

component VarAssignJ provides varAssignJ {

requires truthValue

Boolean varAssignJ() {
return truthValue()

}

}

for 1

J

≤

≤

m + 1.

3. Two components of the form

component TruthValueFalse provides truthValue {

Boolean truthValue() {

return False

}

}

component TruthValueTrue provides truthValue {

Boolean truthValue() {

return True

}

}

Observe that in component Base, if entry i of array vA has value T rue (F alse), then
variable i in the candidate truth-assignment for f encoded in vA has value T rue
(F alse). Let c be component Base in Lcomp and S be the component-based software

74

x

≤

≤

system consisting of Base and VarAssign1, VarAssign2, . . . , VarAssign(m+1) such
implemented by TruthValueTrue and all other
that varAssign(m+1)() is
varAssignx(), 1
m, have a random implementation relative to
TruthValueFalse and TruthValueTrue. Observe that courtesy of the truth-setting
of vm+1 encoded in S, each clause in f ′ is satisﬁed and S will output 1 on any input. Fi-
nally, let Rew(S′′) return the number of variable-assignments in the truth-assignment
for f ′ encoded in component-based system S′′ that diﬀer from those in the partial
truth-assignment p′ and set k = 0. Note that the instance of CSAdaptpoly described
above can be constructed in time polynomial in the size of the given instance of C-
SAT and that this construction encodes the required functions f1(), f2(), and g() in
the deﬁnition of
comp-reducibility; moreover, any candidate software system created
relative Lint, Lcomp, and c runs in time linear in the size of input I ′.

≤

Let us now verify the correctness of this reduction:

≤

• Suppose there is a satisfying assignment p′′ that extends p and satisﬁes f .
Construct a component-based software system S′ consisting of c = Base and
VarAssign1, VarAssign2, . . . , VarAssign(m+1) such that varAssignx(), 1
≤
x
m, implements the TruthVValue component corresponding to the value of
vx in p′′ and varAssign(m+1)() implements TruthValueFalse. Observe that
R, this software system produces output 1 given
for the only requirement r
input T rue; moreover, Rew(S′) = 0
k = 0. Hence, the existence of a satis-
fying truth-assignment that extends p and satisﬁes f in the given instance of
C-SAT implies the existence of a working component-based software system S′
for the constructed instance of CSAdaptpoly such that Rew(S′)

≤

∈

k

≤

≤

• Conversely, suppose that the constructed instance of CSAdaptpoly has a working
component-based software system S′ based on c relative to Lint, Lcomp, and R
such that Rew(S′)
k. As k = 0, by the deﬁnition of Rew(), this means
that the truth-assignment to the variables in V encoded in S′ cannot diﬀer
from any of the variable assignments in the partial truth-assignment p′. As
vm+1 = F alse in p′, this means that the truth-assignments to the remaining
variables in V (i) are an extension of p and (ii) encode a truth assignment that
satisﬁes f . Hence, the existence of a working component-based software system
for the constructed instance of CSAdaptpoly such that Rew(S′)
k implies the
existence of a satisfying truth-assignment that extends p and satisﬁes f in the
given instance of C-SAT.

≤

 NP -hardness of C-SAT, this
The reduction above is thus correct. Given the
 NP -hard as well and not preprocessable
reduction implies that CSAdaptpoly is
in the sense of [37] unless the Polynomial Hierarchy P H collapses, i.e., P H = Σp
2

||

||

75

(see the discussion immediately prior to this proof). The same non-preprocessability
result for ESAdaptpoly then follows by contradiction from Observation 1.

76

