2
2
0
2

n
u
J

7

]
L
P
.
s
c
[

1
v
7
5
4
3
0
.
6
0
2
2
:
v
i
X
r
a

Dependently-Typed Data Plane Programming

MATTHIAS EICHHOLZ, Technical University of Darmstadt, Germany
ERIC HAYDEN CAMPBELL, Cornell University, USA
MATTHIAS KREBS, Technical University of Darmstadt, Germany
NATE FOSTER, Cornell University, USA
MIRA MEZINI, Technical University of Darmstadt, Germany

Programming languages like P4 enable specifying the behavior of network data planes in software. However,
with increasingly powerful and complex applications running in the network, the risk of faults also increases.
Hence, there is growing recognition of the need for methods and tools to statically verify the correctness of P4
code, especially as the language lacks basic safety guarantees. Type systems are a lightweight and compositional
way to establish program properties, but there is a significant gap between the kinds of properties that can be
proved using simple type systems (e.g., SafeP4) and those that can be obtained using full-blown verification
tools (e.g., p4v). In this paper, we close this gap by developing Î 4, a dependently-typed version of P4 based
on decidable refinements. We motivate the design of Î 4, prove the soundness of its type system, develop an
SMT-based implementation, and present case studies that illustrate its applicability to a variety of data plane
programs.

CCS Concepts: â€¢ Software and its engineering â†’ Formal language definitions; â€¢ Networks â†’ Pro-
gramming interfaces.

Additional Key Words and Phrases: Software-Defined Networking, P4, Dependent Types

ACM Reference Format:
Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini. 2022. Dependently-
Typed Data Plane Programming. Proc. ACM Program. Lang. 6, POPL, Article 40 (January 2022), 83 pages.
https://doi.org/10.1145/3498701

1 INTRODUCTION
Computer networks are becoming increasingly programmable as languages like P4 [Bosshart et al.
2014] make it possible to specify the behavior of data planes in software. With the increased
availability of programmable devices, a number of powerful and complex applications having
become viable, ranging from novel network protocols to full-blown in-network computation (e.g.,
executing application-level storage queries using network devices [Jin et al. 2017]). But as the
complexity of these applications increases, so does the risk of faults, especially as P4â€™s main
abstraction for representing packet dataâ€”namely header typesâ€”lacks basic safety guarantees.
Experience with a growing number of programs has shown the risks of the unsafe approach, which
often leads to subtle software bugs [Eichholz et al. 2019; Liu et al. 2018]. This is clearly unacceptable,

Authorsâ€™ addresses: Matthias Eichholz, Technical University of Darmstadt, Germany, eichholz@cs.tu-darmstadt.de; Eric
Hayden Campbell, Cornell University, USA, ehc86@cornell.edu; Matthias Krebs, Technical University of Darmstadt, Ger-
many, krebs@cs.tu-darmstadt.de; Nate Foster, Cornell University, USA, jnfoster@cs.cornell.edu; Mira Mezini, Technical
University of Darmstadt, Germany, mezini@cs.tu-darmstadt.de.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
Â© 2022 Copyright held by the owner/author(s).
2475-1421/2022/1-ART40
https://doi.org/10.1145/3498701

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40

 
 
 
 
 
 
40:2

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

given the crucial role that networks play in nearly all modern systems. Hence, we need methods
and tools to statically verify the correctness of data plane programs.

Today, most data plane verification tools [Dumitrescu et al. 2020; Liu et al. 2018; Stoenescu et al.
2018] are monolithic in nature. For example, p4v [Liu et al. 2018], which is based on software model
checking, operates on whole programs. But while monolithic approaches have certain advantagesâ€”
e.g., they minimize the need for programmer annotationsâ€”they also have downsides. The most
fundamental limitation is the inherent tension with modular designâ€”it is difficult to accommodate
an â€œopen-worldâ€ model, in which third-party components are plugged into existing programs.
For instance, an equipment vendor might want to provide a â€œbaseâ€ program that implements
standard packet-processing functionality like Ethernet switching, and allow customers to add
custom functionality of their own design [Baldi 2019; Gao et al. 2020; Soni et al. 2020]. Composable
approaches to data plane programming require compositional reasoning methods [Beckett and
Mahajan 2020].

Type systems are a lightweight and compositional way to establish program propertiesâ€”i.e., the
types for individual components document assumptions about the components they rely upon as
well as the guarantees they offer. However, somewhat surprisingly, types have rarely been applied in
the realm of network programming, and the few exceptions [Eichholz et al. 2019; Ennals et al. 2004;
Muthukrishnan et al. 2010] are simple type systems with limited expressive power. For example,
SafeP4 [Eichholz et al. 2019] uses regular types [Castagna et al. 2014; Gapeyev and Pierce 2003;
Hosoya and Pierce 2003] and path-sensitive occurrence typing [Tobin-Hochstadt and Felleisen
2010] to reason about basic safety properties, but it cannot capture richer program properties
(e.g., whether the IPv4 and IPv6 headers are only ever accessed on mutually exclusive execution
paths), or track the values of individual fields (e.g., whether EtherType equals to 0x0800, which
indicates an IPv4 packet, or to 0x86DD, which indicates an IPv6 packet). The inability of SafeP4 to
reason about the values being manipulated by the program significantly limits its expressiveness.
In general, there is a significant gap between the kinds of properties that can be checked using
type systems like SafeP4 and full-blown verification tools like p4v.

Thus, it is natural to ask whether we can design a compositional type system that has the
same expressive power as data plane verification tools. This paper answers this question in the
affirmative, by presenting Î 4â€”a dependently-typed version of P4. Î 4 fits with the trend of recently
proposed dependently-typed languages [Condit et al. 2007; Rondon et al. 2008; Vazou et al. 2014;
Xi and Pfenning 1999] that are blurring the line between type checking and theorem proving. For
instance, Liquid Haskell [Rondon et al. 2008; Vazou et al. 2014] allows programmers to smoothly
shift from properties that can be checked with traditional typing disciplines to more sophisticated
ones that go beyond simple syntactic checks. Under the hood, Liquid Haskell uses an SMT solver
to automatically discharge the logical proof obligations generated during type checking.

Yet, thus far, the dependently-typed approach has not been explored for network programming.
In this paper, we demonstrate that data plane programs are a â€œkiller applicationâ€ for dependent types.
On the one hand, they clearly need precise types, as most programs rely on intricate packet formats
(e.g., so-called â€œtype-length-valueâ€ encodings, where the first few bits determine the type, length,
and structure of the bits that follow). On the other hand, data plane programs are fundamentally
simple (e.g., P4 does not support pointers or loops) and lack the kinds of complex features that
often make precise type systems complicated to design and implement.

Our main contribution lies in exploring and addressing the subtle challenges that arise in
developing a dependent type system for the P4 programming language, including balancing the
tradeoffs between expressiveness and decidability. Î 4 features a combination of refinement types,
dependent function types, union types, and explicit substitutions. This combination is key to retain
precision during type checkingâ€”e.g., we can compute exact types for conditionals, thereby having

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:3

access to an accurate type at any program point. Moreover, our design enables precise typing
in the presence of domain-specific features that combine packet serialization and deserialization
operations with imperative control-flow. To this end, Î 4 combines a dependent sum type with a
novel â€œchompâ€ operation that computes the type that remains after extracting bits from a packet
buffer. We formally prove that Î 4â€™s type system is sound via standard progress and preservation
theorems.

The chomp operator is reminiscent of regular expression derivatives [Brzozowski 1964]. To
the best of our knowledge, with a few notable exceptions (e.g., work by McBride [McBride 2001])
derivative-like operations have not been extensively studied the context of dependent type systems.
Thus, beyond providing an elegant solution to a practical problem, we believe that Î 4â€™s innovative
combination of dependent types with regular types and the possibility to compute derivatives of
types is of general theoretical interest and may be useful in other domainsâ€”e.g., one potential
direction is verified serializers and deserializers [Delaware et al. 2019; Ramananandro et al. 2019].
We have built a prototype implementation of Î 4 in OCaml and the Z3 SMT solver. The type
checker determines whether a Î 4 program has a given type by checking the validity of a series of
logical formulae using an SMT solver. We encode types into the effectively propositional fragment of
first-order logic over fixed-width bit vectors, which facilitates automating subtyping and equivalence
checks. We prove (cf. Theorem 4.1) that this logical fragment is sufficient for checking our types
under the assumption that the types written by the programmer denote finite sets. We believe this
is a reasonable assumption, because networks enforce a maximum transmission unit (MTU) (i.e., a
bound on the size of packets constraining the maximum number of bits that network switches can
receive or transmit1) which bounds the size of bit vectors we need to consider in the encoding. In
the presence of an MTU, our types denote finite sets, which can be enumerated to decide the key
judgments (i.e., subtyping, size constraints, and inclusion checks).

Using our Î 4 prototype, we develop several case studies, demonstrating that Î 4 is capable of
expressing and (modularly) reasoning about properties from the literature ranging from basic safety
to intricate invariants: parser round-tripping, protocol conformance, determined forwarding, etc.
We selected properties that are also studied by recent data plane verification tools like p4v or Vera,
which indicates that Î 4 is capable of covering properties of interest to the networking community.
However, we leave a careful study of the practical utility of Î 4 (e.g., with larger examples and user
studies) to future work.

Overall, the contributions of our work are as follows:

â€¢ Section 2 motivates dependently-typed data plane programming.
â€¢ Section 3 presents Î 4, a dependently-typed core of P4, featuring a combination expressive
types for describing structures (regular types as well as decidable refinement and dependent
function types) combined with a bit-by-bit â€œchompâ€ operator.

â€¢ Section 3 develops a semantic proof of soundness for Î 4â€™s type system.
â€¢ Section 4 defines a decidable algorithmic type system for Î 4.
â€¢ Section 5 and Section 6 discusses case studies using Î 4â€™s type system to check realistic

program properties.

2 BACKGROUND
Most networks are based on a division of labor between two components: the control plane and
the data plane. The control plane, usually implemented in software, is responsible for performing
tasks such as learning the topology, computing network-wide forwarding paths, managing shared

1The MTU is often set to 1500 bytes.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:4

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1
2

3
4
5

6
7

8
9
10

11
12
13

14

parser P( packet_in p, out hdrs h ) {

state start {

p. extract (h. ethernet );
transition select (

h. ethernet . etherType ) {
0 x0800 : parse_ipv4 ;
default : accept ;

}

}
state parse_ipv4 {

p. extract (h. ipv4 );
transition accept ;

}

}

15
16

17
18
19

20
21

control Ingress ( inout hdrs h) {

apply {

if (h. ipv4 . src == 10.10.10.10) {

drop () ;

}

}

}

Fig. 1. Unsafe P4 program: IPv4 is not guaranteed to be valid in the ingress.

resources like bandwidth, and enforcing security policies. The control plane can either be realized
using distributed routing protocols (e.g., in a traditional network), or as a logically-centralized
program (e.g., in a software-defined network). The data plane, often implemented in hardware
or with highly-optimized software, is responsible for forwarding packets. It parses packets into
collections of headers, performs lookups in routing tables, filters traffic using access control lists,
applies queueing policies, and ultimately drops, copies, or forwards the packet to the next device.
P4 is a domain-specific programming language for specifying the behavior of network data planes.
It is designed to be used with programmable devices such as PISA switches [Bosshart et al. 2013],
FPGAs [Ibanez et al. 2019; Wang et al. 2017], or software devices (e.g., eBPF [HÃ¸iland-JÃ¸rgensen
et al. 2018]). The language is based on a pipeline abstraction: given an input packet it executes a
sequence of blocks of code, one per pipeline component, to produce the outputs. Each pipeline
component is either a â€œparser,â€ which consists of a state machine that maps binary packets into
typed representations, or a â€œcontrol,â€ which consists of a sequence of imperative commands. To
interface with the control plane, P4 programs may contain â€œmatch-actionâ€ tables, which contain
dynamically reconfigurable entries, each corresponding to a fixed block of code.

Unfortunately, P4 is an unsafe language that does not prevent programmers from writing
programs such as the one shown in Figure 1. The program begins by parsing the Ethernet header.
Then, if the Ethernet header contains the appropriate EtherType (0x0800), it also parses the IPv4
header. Next, in the ingress control, if the IPv4 source address matches a specified address, the
packet is marked to be dropped. However, there is no guarantee that the IPv4 header will be a
well-defined valueâ€”e.g., if the EtherType is 0x08DD, indicating an IPv6 packet, the value produced
by reading the IPv4 source address (Line 17) will be undefined, making the behavior of the program
non-deterministic and possibly different than what the programmer intended.

SafeP4 addresses the lack of basic safety guarantees for P4 using a simple type system [Eichholz
et al. 2019]. Specifically, its type system keeps track of the set of valid header instances at each
statement. For example, starting from the empty heap with no header instances valid, SafeP4
computes the type of the program above to be ether.ipv4 + ether after parsing. This type reflects
that on the first program path both Ethernet and IPv4 are valid, but on the second program path
only Ethernet is valid. Thus, when type checking the if-condition in the ingress code, the type
checker knows that IPv4 may be invalid and rejects the program. A simple fix (shown in Figure 2a)
that makes the program safe is to add an explicit validity check before accessing the IPv4 header.
Because it is aware of the semantics of the isValid command, the SafeP4 type checker computes
the type before the access to be ether.ipv4â€”i.e., IPv4 is guaranteed to be valid.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:5

1
2

3
4
5

6

control Ingress ( inout headers h) {

apply {

if (h. ipv4 . isValid () ) {

if (h. ipv4 . src == 10.10.10.10) {

drop () ;

}}}}

1
2

3
4
5

6

control Ingress ( inout headers h) {

apply {

if (h. ether . etherType == 0 x0800 ) {
if (h. ipv4 . src == 10.10.10.10) {

drop () ;

}}}}

(a) Explicit validity check

(b) Implicit validity check

Fig. 2. Safe implementation of ingress

In practice, however, relying on explicit validity checks is not sufficient. For example, consider the
code shown in Figure 2b. Recall that, given the parser above, the IPv4 header will be present if the
EtherType is 0x0800. Hence, the ingress control can be safely executed. Yet, SafeP4â€™s type checker
rejects the program because the type system is not expressive enough to capture the dependency
between the EtherType value and IPv4â€™s validity.

To address this problem, Î 4 employs a dependent type system [Xi and Pfenning 1999], in which

we can compute a precise type for the program after parsing:

(ğ‘¥ : {ğ‘¦ : ğœ– | |y.pktin| > 272}) â†’

(cid:18) Î£ğ‘¦ : ether.{ğ‘§ : ipv4 | ğ‘¦.ether.etherType == 0ğ‘¥0800}

(cid:19)

+ {ğ‘§ : ether | ğ‘§.ether.etherType â‰  0ğ‘¥0800})

Intuitively, this type says that, starting with the empty heap (ğ‘¦ : ğœ–) and a packet buffer that has at least
enough bits to extract both the Ethernet and the IPv4 header (|ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | > 272), the parser ends in one
of two possible states: (1) either both Ethernet and IPv4 are valid (Î£ğ‘¦ : ether.{ğ‘§ : ipv4 | ...}), if the
EtherType is equal to 0x0800 (note how ğ‘§ : ipv4 is conditioned by ğ‘¦.ether.etherType == 0ğ‘¥0800),
or (2) just Ethernet is valid, if EtherType is not equal to 0x0800. When checking the ingress control,
the type checker uses the predicate ether.etherType == 0x0800 from the conditional to derive
the set of valid header instances, which, in this case, includes IPv4. Thus, accessing the IPv4 source
address is safe and the program correctly passes the type checker.

While the output type is admittedly notationally heavyâ€”a common feature in precise type
systemsâ€”note that the programmer is not forced to write down the most precise type! Î 4 only
requires the annotated type to be sufficiently precise to capture basic safety guarantees and other
desired invariants. For example, in a program where only the Ethernet header needs to be valid
at the end of the parser, they could use the type (ğ‘¥ : {ğ‘¦ : ğœ– | |y.pktin| > 272}) â†’ ether~, which
indicates that, at the end of the parser, at least Ethernet is valid (and possibly others, too).

This example illustrates how Î 4â€™s type system statically checks intricate safety properties with
high precision. Sections 5 and 6 present more case studies showing how Î 4â€™s type system can be
used to check practical properties of interest.

3 DEPENDENT TYPES FOR P4 (Î 4)
This section introduces the design, syntax, and semantics of Î 4, a core calculus modeled after P4
and equipped with dependent types.

3.1 Design of Î 4
Î 4 focuses on the aspects of the P4 programming language that benefit from dependent types,
(e.g., parsing, deparsing, validity, and control flow) and omits features that add clutter (e.g., externs,
registers, checksums, hashing, and packages). Following p4v [Liu et al. 2018], we do not explicitly
model match-action tables and instead use ghost state and conditionals to encode them (see

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:6

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Section 6). Consequently, Î 4 is a loop-free2 imperative language with a few domain-specific
primitive commands: extract (ğœ„), remit (ğœ„), add (ğœ„), and reset.

In P4, the emit(ğœ„) primitive serializes a header instance ğœ„ into a bitstring and prepends it to the
outgoing packet payload, only if ğœ„ is valid, otherwise it does nothing. To simplify typing rules and
semantics, Î 4 provides the primitive remit (ğœ„), which really emits ğœ„ if it is valid, and otherwise gets
stuck. Hence, emit(ğœ„) can be encoded as syntactic sugar: if (ğœ„.valid) then remit (ğœ„) else skip. Another
superficial difference is that we model header field accesses as direct bit-slices into the instance (to
avoid another layer of indirection in our semantics)â€”i.e., eth.srcAddr is written eth[48 : 96].

More substantially, Î 4 diverges from P4 in the way it handles instance validity. A header instance
is valid in two cases: (i) if it has been extracted from the packet (which automatically populates
the instance with the appropriate bits) or (ii) if its validity bit has manually been set using the
setValid() method (which does nothing to the instance itself). In P4, reads to uninitialized
variables produce undefined values, so a common programming practice is to follow a call to
setValid() with a sequence of assignments to the header fieldsâ€”thereby avoiding undefined reads.
In Î 4, rather than forcing the programmer to manually write default values, the add (ğœ„) command
sets ğœ„.valid to true, and sets ğœ„ a pre-determined default value (say 0).3 If required, P4â€™s behavior
could be encoded using an extra 1-bit header to independently track the validity of the instance
and initialization of its fields.

We also introduce a new primitive, reset, which models the behavior of P4 between pipeline
stages. In many switch architectures [Bosshart et al. 2013], packets are deparsed and then reparsed
between pipelinesâ€”e.g., after ingress and before egress. The reset command encodes the behavior
of the inner step: it combines the deparsed bits with the packetâ€™s unparsed payload and passes
it along as the input to the next stage. The reset command would also be useful to reason about
invariants across multiple switch programs, although we donâ€™t explore that use in this paper.

Finally, in designing Î 4, our primary goal is to enable data plane programmers to make use of
dependent types to verify useful program properties in a compositional way and without having
to write manual proofs. To enable modular reasoning, we need a way to annotate (and modularly
check) programs with types. We annotate a program ğ‘ with a type ğœ using an ascription operator:
ğ‘ as ğœ. The ascription has no effect on the runtime behavior of the code (i.e., ğ‘ as ğœ always just
steps to ğ‘). It does, however, indicate a program point where type checking should occur. Hence,
we can independently typecheck ğ‘ at type ğœ and then use ğœ when checking the rest of the program.

Intuition for Î 4â€™s type system. Next, we give an intuition for Î 4â€™s types. A command ğ‘ is always
assigned a dependent function type (ğ‘¥ : ğœ1) â†’ ğœ2, where ğ‘¥ may occur in ğœ2. This design allows
us to relate the input and output values of commands expressed in the heap types ğœ1 and ğœ2. For
example, we may want to ensure that the Ethernet header has the same value after being deparsed,
reset, and then reparsed. To express equations like this, we use refinement types {ğ‘¦ : ğœ | ğœ‘ }, where
ğœ‘ is a formula in the logic of variable-width bit vectors with concatenation and length operators.
In this example, we could say that the Ethernet header is unchanged by using the output type
{ğ‘¦ : ğœ2 | ğ‘¥ .eth = ğ‘¦.eth}.

We also often need to reference intermediate formulae, so we introduce substitution types,
written ğœ2 [ğ‘¥ â†¦â†’ ğœ1], where ğ‘¥ may occur in ğœ2 but not in ğœ1. In such a type, ğœ1 may represent the type
at any earlier point in the program. Î 4 also supports fine-grained path-dependent reasoning via
union types (ğœ1 + ğœ2). It is also convenient to have trivial (âŠ¤) and absurd (âˆ…) types.

2P4 allows loops within parsers, but because programs are restricted to finite state, the language specification allows
implementations to unroll loops.
3The difference here is similar to the difference between Câ€™s malloc (analogous to P4â€™s semantics) and calloc (analogous
to Î 4â€™s semantics).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:7

ğœ
ğœ
ğœ‘
ğ‘’
ğ‘ğ‘£
ğ‘
ğ‘

ğ‘‘
ğ‘ƒ

::= âˆ… | âŠ¤ | Î£ğ‘¥ : ğœ .ğœ | ğœ + ğœ | {ğ‘¥ : ğœ | ğœ‘ } | ğœ [ğ‘¥ â†¦â†’ ğœ]
::= N | B | BV | (ğ‘¥ : ğœ) â†’ ğœ
::= ğ‘’ = ğ‘’ | ğ‘’ > ğ‘’ | ğœ‘ âˆ§ ğœ‘ | Â¬ğœ‘ | ğ‘¥ .ğœ„.ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘ | true | false
::= ğ‘› | ğ‘ğ‘£ | |ğ‘¥ .ğ‘ | | ğ‘’ + ğ‘’ | ğ‘’@ğ‘’ | ğ‘¥ .ğ‘ | ğ‘¥ .ğ‘ [ğ‘™ :ğ‘Ÿ ] | ğ‘¥ .ğœ„ [ğ‘™ :ğ‘Ÿ ]
::= âŸ¨âŸ© | 0 :: ğ‘ğ‘£ | 1 :: ğ‘ğ‘£ | bn :: ğ‘ğ‘£
::= ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡
::= extract (ğœ„) | if (ğœ‘) c else c | c; c | ğœ„.f := e | remit (ğœ„)

skip | reset | add (ğœ„) | ğ‘ as (ğ‘¥ : ğœ) â†’ ğœ

::= ğœ‚ {ğ‘“ : BV} | ğœ„ â†¦â†’ ğœ‚
::= (ğ‘‘, ğ‘)

(heap types)
(base types)
(formulae)
(expressions)
(bit vectors)
(packets)
(commands)

(declarations)
(programs)

Fig. 3. Syntax of Î 4

Finally, the design of our type system is also informed by the need to model parsing operations.
Specifically, we must ensure that the refinements on the input type and on the output type remain
consistent after bits have been shuffled around by a command. For example, given an input type
{ğ‘¥ : âŠ¤ | ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 8] == 4 âˆ§ |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | > |ipv4|}, where ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› represents the incoming packet,
and the command extract (ipv4), the output type should reflect that the ipv4 header instance is
now valid, that ipv4[0 : 8] is 4, and that ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› may have no more bits remaining. Î 4 accomplishes
this using two key mechanisms: (1) a dependent sum type Î£ğ‘¥ : ğœ1.ğœ2 that computes the disjoint
union of the valid instances in ğœ1 and ğœ2 and concatenates the incoming and outgoing packets
(Section 3.3), and (2) a refinement transformer, chomp, that manipulates input refinements to be
consistent with the extraction operation (see Section 3.5).

3.2 Syntax
Figure 3 shows the syntax of Î 4. Boolean formulae ğœ‘ include literals, equality (=) and validity of
instances (ğ‘¥ .ğœ„.valid), conjunction (âˆ§), and negation (Â¬). Expressions ğ‘’ include naturals, bit vectors,
packet length (|ğ‘¥ .ğ‘ |), addition (+), concatenation (@), packet access (ğ‘¥ .ğ‘) and slices of packets
(ğ‘¥ .ğ‘ [ğ‘™ :ğ‘Ÿ ]) and instances (ğ‘¥ .ğœ„ [ğ‘™ :ğ‘Ÿ ]).

To ease the notation, we write ğ‘¥ .ğœ„ [ğ‘™] instead of ğ‘¥ .ğœ„ [ğ‘™ :ğ‘™ + 1] for bit-wise access, ğ‘¥ .ğœ„.ğ‘“ instead of
ğ‘¥ .ğœ„ [ğ‘™ :ğ‘Ÿ ] for ranges matching header instance fields, ğ‘¥ .ğœ„ instead of ğ‘¥ .ğœ„ [0 : sizeof(ğœ„)], ğ‘¥ .ğœ„ [ğ‘› :] for the
remaining bits of ğ‘¥ .ğœ„ starting from bit ğ‘› + 1, and similarly for the corresponding formulae involving
packet variables ğ‘¥ .ğ‘. We use a list-like encoding of bit vectors. A bit vector is either the empty bit
vector (âŸ¨âŸ©) or a concatenation of bits. We assume that bit variables bn are not part of the surface
syntax and are only used internally. For singleton bit vectors, we write âŸ¨ğ‘âŸ© instead of ğ‘ :: âŸ¨âŸ©.

We write ğœ– â‰œ {ğ‘¥ : âŠ¤ | (cid:211)ğœ„ âˆˆdom( H T) Â¬ğ‘¥ .ğœ„.ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘ } for the type denoting the empty heap on which no
header instances are valid, ğœ„ â‰œ {ğ‘¥ : âŠ¤ | ğ‘¥ .ğœ„.valid âˆ§ (cid:211)ğœ„â€² âˆˆdom( H T),ğœ„â€²â‰ ğœ„ Â¬ğ‘¥ .ğœ„ â€².valid} for the type denoting
the heap exclusively containing instance ğœ„, and ğœ„~ â‰œ {ğ‘¥ : âŠ¤ | ğ‘¥ .ğœ„.valid} for the type denoting the
heap on which at least instance ğœ„ is guaranteed to be valid.

For formulae, we write ğ‘¥ â‰¡ ğ‘¦ (respectively ğ‘¥ â‰¡ğœ„ ğ‘¦) as syntactic sugar for the boolean predicates
capturing strict equality (respectively instance equality) between the heaps bound to ğ‘¥ and ğ‘¦. Strict
equality requires that both the input and output packets are equivalent as well as all instances
contained in the heapâ€”i.e., ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ (cid:211)ğœ„ âˆˆdom( H T) ğ‘¥ .ğœ„ = ğ‘¦.ğœ„, while
instance equality only requires that the instances are equivalent in both heaps. We write ğ‘¥ .ğœ„.valid =
ğ‘¦.ğœ„.ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘ as syntactic sugar for (ğ‘¥ .ğœ„.valid âˆ§ ğ‘¦.ğœ„.valid) âˆ¨ (Â¬ğ‘¥ .ğœ„.valid âˆ§ Â¬ğ‘¦.ğœ„.valid). We use standard
encodings using negation and conjunction for logical connectives like âˆ¨ or â‡’.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:8

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

âŸ¦ğœâŸ§E âŠ† H
âŸ¦âˆ…âŸ§E = {}
âŸ¦âŠ¤âŸ§E = H

âŸ¦ğœ1 + ğœ2âŸ§E = âŸ¦ğœ1âŸ§E âˆª âŸ¦ğœ2âŸ§E

âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E = {â„1 ++ â„2 | â„1 âˆˆ âŸ¦ğœ1âŸ§E âˆ§ â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ] }

âŸ¦ğœ1 [ğ‘¥ â†¦â†’ ğœ2]âŸ§E = {â„ | â„2 âˆˆ âŸ¦ğœ2âŸ§E âˆ§ â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¥â†¦â†’â„2 ] }
âŸ¦{ğ‘¥ : ğœ | ğœ‘ }âŸ§E = {â„ | â„ âˆˆ âŸ¦ğœâŸ§E âˆ§ âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’â„] = true}

Fig. 4. Semantics of heap types

We write ğ‘¥ as a shorthand for a possibly empty sequence ğ‘¥1, ..., ğ‘¥ğ‘›. A program consists of a
sequence of declarations ğ‘‘ and a command ğ‘. Declarations ğ‘‘ include header type declarations
ğœ‚ {ğ‘“ : BV} and header instance declarations ğœ„ â†¦â†’ ğœ‚. Header type declarations specify the format of
network packet headers. They are defined in terms of a name and a sequence of field declarations,
where each field is itself defined in terms of a field name and a type. We write ğ‘“ : BV to denote that
field ğ‘“ has a bit vector type BV. With ğœ‚ ranging over header types, the instance declaration ğœ„ â†¦â†’ ğœ‚
assigns the name ğœ„ to header type ğœ‚. The global mapping between header instances and header
types is stored in the so-called header table H T . We assume that names of header instances and
header types are drawn from disjoint sets of names and that each name is declared only once.

Î 4 provides commands for parsing (extract), creating (add) and modifying (ğœ„.ğ‘“ := ğ‘¡) header
instances. The remit command serializes a header instance into a bit sequence. The reset com-
mand resets the program stateâ€”in particular, the packet buffers. Commands can be sequentially
composed (ğ‘1; ğ‘2), skip is a no-op, and the if -command conditionally executes one out of two
commands based on the value of the boolean formula ğœ‘. We assume that formulae and expressions
used in commands are implicitly prefixed with a variable named heap, but we often omit it in
the surface syntax. For example, we write if (ether.valid) then extract (ipv4) else skip instead of
if (heap.ether.valid) then extract (heap.ipv4) else skip. Î 4 provides modular reasoning via type
ascription (ğ‘ as (ğ‘¥ : ğœ1) â†’ ğœ2). Finally, we assume that every header referenced in a program has a
corresponding instance declarationâ€”this could be enforced statically using a simple analysis.

3.3 Type System
As shown in Figure 3, there are two categories of types, base types ğœ and heap types ğœ. Base
types include natural numbers, bit vectors, booleans, and dependent function types. Heap types ğœ
represent sets of heaps, where each element in the set describes a different program path. The goal is
to capture bit-level dependencies between header instances and the incoming and outgoing packet
in the type system. A heap â„ in the set of heaps H describes a possible system state, consisting of
the incoming and outgoing packet and the set of valid header instances. We model heaps as maps
from names to bit vectors. A heap contains two special entries ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› and ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ representing the
incoming and outgoing packet buffers, as well as mappings from instance names to bit vectors for
each valid header instance. The semantics of types is shown in Figure 4. Heap types are evaluated
in an environment E, which is a mapping from variable names to heaps. The environment models
other heaps available in the current scope upon which the current header type may depend.

The type âˆ… denotes the empty set. It is used in situations where there are unsatisfiable assumptions

involving the header instances or the incoming and outgoing packet buffers.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:9

âŸ¦ğ‘’âŸ§E âˆˆ BV âˆª N
0
ï£±ï£´ï£´ï£´ï£²
ğ‘›
ï£´ï£´ï£´
âŠ¥ otherwise
ï£³
(cid:40)

âŸ¦|ğ‘¥ .ğ‘ |âŸ§E =

if E (ğ‘¥)(ğ‘) = âŸ¨âŸ©
if E (ğ‘¥)(ğ‘) = âŸ¨ğ‘1, ..., ğ‘ğ‘›âŸ©

âŸ¦ğ‘¥ .ğ‘âŸ§E =

âŸ¦ğ‘¥ .ğ‘ [ğ‘› : ğ‘š]âŸ§E =

âŸ¦ğ‘¥ .ğœ„ [ğ‘› : ğ‘š]âŸ§E =

âŸ¨ğ‘1, ..., ğ‘ğ‘›âŸ©
âŠ¥

if E (ğ‘¥)(ğ‘) = âŸ¨ğ‘1, ..., ğ‘ğ‘›âŸ©
otherwise

âŸ¨ğ‘ğ‘›, ..., ğ‘ğ‘šâˆ’1âŸ©

âŠ¥

âŸ¨ğ‘ğ‘›, ..., ğ‘ğ‘šâˆ’1âŸ©

âŠ¥

ï£±ï£´ï£´ï£´ï£²
ï£´ï£´ï£´
ï£³
ï£±ï£´ï£´ï£´ï£²
ï£´ï£´ï£´
ï£³

if âŸ¦ğ‘¥ .ğ‘âŸ§E = âŸ¨ğ‘0, ..., ğ‘ğ‘˜ âŸ© âˆ§
0 â‰¤ ğ‘› < ğ‘š â‰¤ ğ‘˜ + 1
otherwise

if âŸ¦ğ‘¥ .ğœ„âŸ§E = âŸ¨ğ‘0, ..., ğ‘ğ‘˜ âŸ© âˆ§
0 â‰¤ ğ‘› < ğ‘š â‰¤ ğ‘˜ + 1
otherwise

Fig. 5. Selected cases of the semantics of expressions

The top type âŠ¤ denotes the set of all possible heaps. The choice type ğœ1 + ğœ2 denotes the union of
the sets of heaps represented by ğœ1 and ğœ2. The dependent pair Î£ğ‘¥ : ğœ1.ğœ2 denotes the concatenation of
heaps from ğœ1 and ğœ2, where heaps described by ğœ2 may depend on heaps from ğœ1. The concatenation
â„ = â„1 ++ â„2 of two heaps â„1 and â„2 requires that header instances contained in â„1 and â„2 are
disjoint. The resulting heap contains all instances from â„1 and from â„2, with ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› and ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ the
concatenation of respective bit vectors in â„1 and â„2. The explicit substitution ğœ1 [ğ‘¥ â†¦â†’ ğœ2] denotes
the set of heaps obtained by evaluating ğœ1 for every heap described by ğœ2. Finally, the refinement
type {ğ‘¥ : ğœ | ğ‘’} denotes the set of heaps described by ğœ for which the predicate ğ‘’ holds.

The refinement predicate ğœ‘ is evaluated in the same type of environment as heap types. Formulae
evaluate to a boolean value, i.e., âŸ¦ğœ‘âŸ§E âˆˆ B. The semantics of expression equality (ğ‘’1 = ğ‘’2) is defined
as the semantic equality between expressions ğ‘’1 and ğ‘’2. If the semantics of one of the expressions is
undefined, expression equality always evaluates to false. The semantics of expression comparison
(ğ‘’1 > ğ‘’2) is defined analogously. Instance validity ğ‘¥ .ğœ„.valid evaluates to true if header instance ğœ„ is
contained in the heap bound to ğ‘¥ in E, otherwise it evaluates to false. The remaining operations
have standard semantics.

The semantics of expressions is defined in Figure 5. For brevity, we omit standard cases. Ex-
pressions evaluate to either a bit vector or a natural number. For the semantic addition (+) and bit
vector concatenation operator (@), we assume that as soon as evaluating one operand results in
an error (âŠ¥) the whole expression also evaluates to âŠ¥. To evaluate the length of a packet |ğ‘¥ .ğ‘ |, we
compute the length of the bit vector of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› or ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ respectively in the heap bound to ğ‘¥ in the
environment. If no heap is bound to variable name ğ‘¥, the expression evaluates to âŠ¥. The semantics
of bit vectors is as expected, except for variables, which we look up from a designated location in
the environment. If no binding for the bit variable exists, it evaluates to âŠ¥. The semantics of bit
vector concatenation is standard. A packet access ğ‘¥ .ğ‘ looks up the respective entry from the heap
bound to variable ğ‘¥ in E. A packet slice ğ‘¥ .ğ‘ [ğ‘™ :ğ‘Ÿ ] is evaluated in the same way, but additionally the
designated slice is obtained from the bit vector. Again, if the variable is not bound or an index is
greater than the length of the bit vector, the expression evaluates to âŠ¥. The semantics of instance
slices ğ‘¥ .ğœ„ [ğ‘™ :ğ‘Ÿ ] is defined similarly but the lookup occurs on header instance ğœ„. We interpret slices as

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:10

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

E-Extract

H T (ğœ„) = ğœ‚

deserializeğœ‚ (ğ¼ ) = (ğ‘£, ğ¼ â€²)

âŸ¨ğ¼, ğ‘‚, ğ», extract (ğœ„)âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘£], skipâŸ©

E-Remit

ğœ„ âˆˆ ğ‘‘ğ‘œğ‘š(ğ» )

H T (ğœ„) = ğœ‚

serializeğœ‚ (ğ» (ğœ„)) = ğ‘ğ‘£
âŸ¨ğ¼, ğ‘‚, ğ», remit (ğœ„)âŸ© â†’ âŸ¨ğ¼, ğ‘‚ :: ğ‘ğ‘£, ğ», skipâŸ©

E-Mod

ğ» (ğœ„) = ğ‘Ÿ

ğ‘Ÿ â€² â‰œ {ğ‘Ÿ ğ‘¤ğ‘–ğ‘¡â„ ğ‘“ = ğ‘£ }

âŸ¨ğ¼, ğ‘‚, ğ», ğœ„.ğ‘“ := ğ‘£âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘Ÿ â€²], skipâŸ©

E-Reset

ğ¼ â€² = ğ‘‚@ğ¼
âŸ¨ğ¼, ğ‘‚, ğ», resetâŸ© â†’ âŸ¨ğ¼ â€², âŸ¨âŸ©, [], skipâŸ©

E-Add
initğœ‚ = ğ‘£
ğœ„ âˆ‰ dom(ğ» )
H T (ğœ„) = ğœ‚
âŸ¨ğ¼, ğ‘‚, ğ», add (ğœ„)âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘£], skipâŸ©

E-Ascribe

âŸ¨ğ¼, ğ‘‚, ğ», ğ‘ as (ğ‘¥ : ğœ1) â†’ ğœ2âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ©

Fig. 6. Small-step operational semantics of Î 4

half-open intervals, where the left bound is included and the right bound is excluded. For example,
given a bit vector ğ‘ğ‘£ = 1010 we have ğ‘ğ‘£ [1 : 4] = 010.

We define two semantic operations on heap types: inclusion and exclusion of instances. The first,
Includes Î“ ğœ ğœ„, traverses ğœ and checks that instance ğœ„ is valid in every path. Semantically this says
that ğœ„ is a member of every element of âŸ¦ğœâŸ§Eâ€”i.e., if E |= Î“, then âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .ğœ„ âˆˆ ğ‘‘ğ‘œğ‘š(â„). The second,
Excludes Î“ ğœ ğœ„, traverses ğœ and checks that instance ğœ„ is invalid in every path. Semantically this says
that ğœ„ is no member of every element of âŸ¦ğœâŸ§Eâ€”i.e., if E |= Î“, then âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .ğœ„ âˆ‰ ğ‘‘ğ‘œğ‘š(â„).

3.4 Operational Semantics
The small-step operational semantics of Î 4, is shown in Figure 6. It is defined in terms of a four-tuple
âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ©, where ğ¼ and ğ‘‚ are the bitstrings for the incoming and outgoing packets respectively, ğ»
is a map that relates instance names to records containing the field values, and ğ‘ is a command.

The extract (ğœ„) command (E-Extract) first looks up the header type from the header table (H T ),
and uses a deserialization function to copy the appropriate number of bits from the input packet
into the deserialized representation of the instance ğ‘£. This value is added to the map of valid
header instances ğ» . We assume there exists a deserialization function for every header instance.
For example, assuming ğ¼ = 110011ğµ, where ğµ is the rest of the bitstring, and ğœ‚ = {ğ‘“ : 4; ğ‘” : 2}, then
deserializeğœ‚ (ğ¼ ) = ({ğ‘“ = 1100; ğ‘” = 11}, ğµ).

The remit (ğœ„) command (rule E-Remit) requires that the header instance is validâ€”i.e., it is con-
tained in ğ» . Similar to E-Extract, we assume there is a serialization function for every heap
type, which turns a record representing the instance back into a bit sequence. For example,
serializeğœ‚ ({ğ‘“ = 1100; ğ‘” = 11}) = 11011. The serialized bit sequence is appended to the end of
the outgoing packet. Both the input packet and the set of valid headers remain unchanged.

The rule E-Mod defines the semantics of assigning a value to a header field. Assuming ğ‘Ÿ is the
record storing the values of the fields, an updated record ğ‘Ÿ â€² with the modified field value is stored
in ğ» . The input and output packets remain unchanged. If the assigned expression is not a value, it
is reduced first.

The rules for sequencing (E-Seq, E-Seq1) are standard. Sequences of commands evaluate from
left to rightâ€”i.e., the left-hand command is reduced to skip before the right-hand command is
evaluated. The evaluation rules for conditionals (E-If, E-IfTrue, E-IfFalse) are also standard. All
standard rules are omitted.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:11

The rule E-Reset defines the semantics of the command reset. It would be invoked between the
ingress and egress pipelines, when the packet emitted by the ingress becomes the input packet for
the egress. Operationally, the bits contained in the output packet are prepended to the bits of the
input packet. This concatenated bit sequence serves as the new input packet. The output packet is
emptied and all valid header instances are discarded.

The rule E-Add initializes a header instance if it is not already valid. The evaluation is similar to
rule E-Extract, except that no bits are taken from the input bitstring. Instead we assume that there
exists an initialization function initğœ‚ for every heap type ğœ‚ â€”similar to deserializeâ€”that initializes
all fields of an instance to a fixed value. If an instance is already valid, this operation is a no-op. An
ascribed command ğ‘ as ğœ (rule E-Ascribe) evaluates to ğ‘ trivially, without modifying the heap.

3.5 Typing Judgement
The typing judgement has the form Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2. Intuitively, type ğœ1 describes the input
heap and ğœ2 describes the output heap obtained after the execution of ğ‘. Î“ is a variable context that
maps variable names to heap types and is used to capture additional dependencies of the input
type. If a command typechecks in a context where ğ‘¥ maps to ğœ (i.e., Î“, ğ‘¥ : ğœ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2) it
means that given some heap described by type ğœ on which the input heap might depend, executing
ğ‘ on the input heap described by ğœ1 will result in a heap described by ğœ2.

The typing rules are presented in Figure 7. The typing rule T-Extract captures that ğœ„ must be
valid after an extract command is executed and the input packet of type ğœ1 provides enough bits for
the instance (sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ ğ‘› iff âˆ€E, â„ âˆˆ âŸ¦ğœâŸ§E, |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘›). Intuitively, the chomp operator
ensures that the output type reflects that the first ğ‘› bits, where ğ‘› is the number of bits contained in
header instance ğœ„, are removed from the input packet and copied into instance ğœ„.

The typing rule for sequencing T-Seq is mostly standard, with one peculiarity: because our
typing judgement assigns dependent function types to commands, the result type ğœ22 of command
ğ‘2 might depend on its input type ğœ12â€”i.e., variable ğ‘¦ might appear free in ğœ22. Hence, we must also
capture the type ğœ12 in the result type. The typing rule T-Skip is standard, except that it strictly
enforces that the heaps described by the output type are equivalent to the heaps described by
the input type. To typecheck the command remit, we check whether the instance to be emitted is
guaranteed to be valid in the input type. The assigned output type ensures that emitting a header
instance appends the value of the instance to the end of the outgoing packet (second projection of
the assigned Î£-type) but leaves the input packet and all other validity information unchanged (first
projection of the assigned Î£-type). The rule T-Reset resets all assumptions about header validity,
empties ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ and refines ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› to be the concatenation of ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ and ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› of the input type. In
the output type, we use a Î£-type to model the concatenation.

The rule T-If typechecks each branch of the conditional with the additional assumption that
the condition ğœ‘ holds respectively does not hold. The resulting type is a path-sensitive union type,
which includes the types of both paths. By default, all variables in formula ğœ‘ in the command
are bound to heap. To turn ğœ‘ into a refinement on a type, we substitute every occurrence of
heap with the respective binder of the type we want to refine. We write ğœ‘ [ğ‘¥/heap] to denote
the formula obtained from ğœ‘ in which heap is replaced with ğ‘¥. For example, if the command is
if (ether.etherType = 0x0800) then extract (ipv4) else skip, we typecheck the then-branch with
type (ğ‘¥ : {ğ‘¦ : ğœ1 | ğ‘¦.ether.etherType = 0x0800}) â†’ ğœ12. The full command is checked with type
(ğ‘¥ : ğœ1) â†’ {ğ‘¦ : ğœ12 | ğ‘¥ .ether.etherType = 0x0800} + {ğ‘¦ : ğœ22 | Â¬ğ‘¥ .ether.etherType = 0x0800}.
To typecheck a modification of an instance field, the typing rule T-Mod first checks if the instance
to be modified is guaranteed to be valid in the input type. The output type is similar to the strongest-
postcondition of the input type: everything in the output type is the same as in ğ‘¥, except for the
modified instance field ğ‘¦.ğœ„.ğ‘“ , which must be equal to ğ‘’ [ğ‘¥/heap].

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:12

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

T-Extract

Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ1) â‰¥ sizeof(ğœ„)

ğœ‘1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©

ğœ‘2 â‰œ ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥
Î“ âŠ¢ extract (ğœ„) : (ğ‘¥ : ğœ1) â†’ Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğœ‘1}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘2}

T-Seq

Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â†’ ğœ12
Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â†’ ğœ22
Î“ âŠ¢ ğ‘1; ğ‘2 : (ğ‘¥ : ğœ1) â†’ ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

T-Skip

ğœ2 â‰œ {ğ‘¦ : ğœ1 | ğ‘¦ â‰¡ ğ‘¥ }
Î“ âŠ¢ skip : (ğ‘¥ : ğœ1) â†’ ğœ2

T-Remit

Includes Î“ ğœ1 ğœ„
Î“ âŠ¢ remit (ğœ„) : (ğ‘¥ : ğœ1) â†’ Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğœ‘ }

ğœ‘ â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„

T-Reset

ğœ‘1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡
ğœ‘2 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›
Î“ âŠ¢ reset : (ğ‘¥ : ğœ1) â†’ Î£ğ‘¦ : {ğ‘§ : ğœ– | ğœ‘1}.{ğ‘§ : ğœ– | ğœ‘2}

T-Ascribe
Î“ âŠ¢ ğ‘ : ğœ
Î“ âŠ¢ ğ‘ as ğœ : ğœ

T-If

Î“; ğœ1 âŠ¢ ğœ‘ : B

Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ12

Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ22

Î“ âŠ¢ if (ğœ‘) c1 else c2 : (ğ‘¥ : ğœ1) â†’ {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}

T-Mod

F (ğœ„, ğ‘“ ) = BV

Î“; ğœ1 âŠ¢ ğ‘’ : BV

Includes Î“ ğœ1 ğœ„

ğœ‘ğ‘ğ‘˜ğ‘¡ â‰œ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡

ğœ‘ğœ„ â‰œ âˆ€ğœ… âˆˆ dom(H T ). ğœ„ â‰  ğœ… â†’ ğ‘¦.ğœ… = ğ‘¥ .ğœ…

ğœ‘ ğ‘“ â‰œ âˆ€ğ‘” âˆˆ dom(H T (ğœ„)). ğ‘“ â‰  ğ‘” â†’ ğ‘¦.ğœ„.ğ‘” = ğ‘¥ .ğœ„.ğ‘”

Î“ âŠ¢ ğœ„.ğ‘“ := ğ‘’ : (ğ‘¥ : ğœ1) â†’ {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}

T-Add

Excludes Î“ ğœ1 ğœ„

init H T (ğœ„) = ğ‘£

ğœ‘ â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£
Î“ âŠ¢ add (ğœ„) : (ğ‘¥ : ğœ1) â†’ Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğœ‘ }

T-Sub

Î“ âŠ¢ ğœ1 <: ğœ3
Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ4 <: ğœ2
Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ3) â†’ ğœ4
Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2

Fig. 7. Command typing rules for Î 4.

Rule T-Add first checks that the instance is not yet included in the type and assigns an output
type that reflects that all information from the input type ğœ1 are retained and just instance ğœ„ is added.
The typing rule for ascription T-Ascribe is standard. The typing rule for subsumption T-Sub is also
standard. We write Î“ âŠ¢ ğœ1 <: ğœ2 to denote the subtyping check between ğœ1 and ğœ2. The contexts Î“1
and Î“2 capture external dependencies of ğœ1 and ğœ2 respectively.

We take a semantic approach for defining subtyping as shown in the left of Figure 8. Type ğœ1
with context Î“1 is a subtype of type ğœ2 with context Î“2, if and only if for all environments E1 and E2
such that E1 entails the context Î“1 for subtype ğœ1 and E2 entails the context Î“2 for supertype ğœ2, the

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:13

Î“ âŠ¢ ğœ1 <: ğœ2

Î”
â‡” âˆ€E |= Î“.âŸ¦ğœ1âŸ§E âŠ† âŸ¦ğœ2âŸ§E E |= Î“

Î”
â‡” âˆ€ğ‘¥ğ‘– âˆˆ dom(Î“).E (ğ‘¥ğ‘– ) = â„ğ‘– âˆ§ â„ğ‘– |=E Î“(ğ‘¥ğ‘– )

Fig. 8. Left: Subtyping. Right: Entailment between environments and subtyping contexts.

Ent-Top

(ğ¼, ğ‘‚, ğ» ) |=E âŠ¤

Ent-ChoiceL

(ğ¼, ğ‘‚, ğ» ) |=E ğœ1
(ğ¼, ğ‘‚, ğ» ) |=E ğœ1 + ğœ2

Ent-ChoiceR

(ğ¼, ğ‘‚, ğ» ) |=E ğœ2
(ğ¼, ğ‘‚, ğ» ) |=E ğœ1 + ğœ2

Ent-Refine

(ğ¼, ğ‘‚, ğ» ) |=E ğœ
âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = true
(ğ¼, ğ‘‚, ğ» ) |=E {ğ‘¥ : ğœ | ğœ‘ }

Ent-Sigma

(ğ¼1, ğ‘‚1, ğ»1) |=E ğœ1
(ğ¼2, ğ‘‚2, ğ»2) |=E [ğ‘¥â†¦â†’(ğ¼1,ğ‘‚1,ğ»1) ] ğœ2
(ğ¼1@ğ¼2, ğ‘‚1@ğ‘‚2, ğ»1 âˆª ğ»2) |=E Î£ğ‘¥ : ğœ1.ğœ2

Ent-Subst

(ğ¼2, ğ‘‚2, ğ»2) |=E ğœ2
(ğ¼, ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼2,ğ‘‚2,ğ»2) ] ğœ1
(ğ¼, ğ‘‚, ğ» ) |=E ğœ1 [ğ‘¥ â†¦â†’ ğœ2]

Fig. 9. Entailment between heaps and heap types.

set of heaps described by ğœ1 evaluated in environment E1 is a subset of the set of heaps described
by ğœ2 evaluated in environment E2.

The entailment between environments and typing contexts is defined in the right of Figure 8.
An environment E entails a context Î“, iff for every mapping from a variable name ğ‘¥ğ‘– to some heap
type ğœğ‘– in Î“ there exists a mapping from variable ğ‘¥ğ‘– to some heap â„ğ‘– in environment E and that
heap â„ğ‘– entails type ğœğ‘– . The entailment between a heap and a type is defined in Figure 9. A heap
ğ» [ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ ğ¼, ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ â†¦â†’ ğ‘‚], in short (ğ¼, ğ‘‚, ğ» ) entails a type ğœ, if it is contained in the type.

3.6 Chomp
When an instance ğœ„ is extracted, sizeof(ğœ„) bits are moved from the input bitstring to the instanceâ€”we
call this chomping. To reflect it in the type that we assign to an extract command, we define a
syntactic operation chomp that transforms a heap type into the heap type that would result from
extracting an instance.

We first specify a semantic chomp operation on a single heap (chompâ‡“(â„, ğ‘›)) in Definition 3.1â€”it

removes the first ğ‘› bits from the input packet in heap â„.

Definition 3.1 (Semantic Chomp). chompâ‡“(â„, ğ‘›) = â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› :]]

Intuitively, syntactic chomp lifts chompâ‡“ to heap types (written formally in Lemma 3.2). For
example, given a header instance A of type A_t { f: 2 }, chomp({ğ‘¥ : ğœ– | ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 2] =
11}, ğ´, ğ‘¦) = {ğ‘¥ : ğœ– | ğ‘¦.ğ´[0 : 2] = 11}, i.e., because header instance A contains two bits, the first two
bits are moved from ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› to instance A, bound by ğ‘¦. It turns out that we can define chomp via
a simple syntactic transformation. To do this, we first define a single-bit operation, chomp1, that
processes only a single bit. Then chomp recursively lifts chomp1 to the appropriate length.
3.6.1 Chomp1. To chomp a single bit from a heap type, we will need to update all references to the
length, as well as to the first bit of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›. This computation resembles Brzozowski derivatives [Brzo-
zowski 1964]. For the complete definition of chomp1, we refer the reader to the appendix. Here we
provide some intuition for how it works. Semantically, chomp1(ğœ, b0) transforms for each heap â„
denoted by a heap type ğœ, into the heap â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [1 : ]]. The variable b0 is a placeholder
corresponding to the missing bit. Then, a helper function heapRef1 replaces the placeholder bits

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:14

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

introduced by chomp1 with references to the extracted bit. In particular, the ğ‘–-th call to heapRef1,
replaces variable bi with ğ‘¥ .ğœ„ [ğ‘– âˆ’ 1 :ğ‘–].

Syntactically, when chomping a heap type ğœ we update each occurrence of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› in a refinement,
if that occurrence describes the first bit of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› of a heap in the semantics of ğœ. Types âˆ… and âŠ¤ are
not affected by chomping. For a choice type ğœ1 + ğœ2, chomp1 is applied to both ğœ1 and ğœ2 individually,
as each branch of the choice type describes isolated heaps of ğœ. In the substitution type, ğœ1 [ğ‘¥ â†¦â†’ ğœ2],
only ğœ1 is chomped, as ğœ2 only captures information relevant for evaluating refinements.

For the refinement type {ğ‘¥ : ğœ1 | ğœ‘ }, chomp is applied recursively to ğœ1 and all references to
the first bit of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› as well as the length of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› are updated accordingly. We increment numeric
expressions referencing ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (e.g. the refinement |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | becomes |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | + 1 and we prepend
the placeholder bit bn for bit-vector expressions referencing ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›).

When we apply chomp1 to type Î£ğ‘¥ : ğœ1.ğœ2, we have to distinguish two cases, either the input
packet described by ğœ1 contains at least one bit or the input packet described by ğœ1 is empty. In the
first case, chomp1 removes the first bit of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› in ğœ1 and in the second case it removes the first bit
of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› in ğœ2. If we chomp in ğœ1 we need to update all refinements to ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› in ğœ2, as ğœ1 is bound to
ğ‘¥ in ğœ2; otherwise chomping could cause contradictions between refinements referencing the same
component. Similar to the computation of a Brzozowski derivative of a product, the result is the
union of the type obtained by chomping ğœ1 and ğœ2 respectively, where we additionally assert in the
second case that ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› of ğœ1 must be empty.

Example. Given type ğœ = Î£ğ‘¥ : {ğ‘¦ : ğœ– | |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 1}.{ğ‘§ : ğœ– | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 1}

chomp1(ğœ, b0) = Î£ğ‘¥ : {ğ‘¦ : ğœ– | |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | + 1 = 1}.{ğ‘§ : ğœ– | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | + 1 = 1} +

Î£ğ‘¥ : {ğ‘¦ : ğœ– | |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 1 âˆ§ |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}.{ğ‘§ : ğœ– | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 1}

Example. Given a type ğœ = {ğ‘¥ : {ğ‘¦ : ğœ„ | |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 8} | ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 8] = ğ‘¥ .ğœ„ [4 : 12]}

chomp1(ğœ, ğ‘0) = {ğ‘¥ : {ğ‘¦ : ğœ„ | |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | + 1 = 8} | ğ‘0 :: ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 7] = ğ‘¥ .ğœ„ [4 : 12]}
Example. Given a header instance ğ´ and a heap type ğœ = {ğ‘¥ : ğœ– | b0 :: âŸ¨âŸ©@ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0] = 10}. The

first call to heapRef1 returns type {ğ‘¥ : ğœ– | (ğ‘¦.ğœ„ [0]@âŸ¨âŸ©)@ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0] = 10}.
3.6.2 Correctness of Chomp. We prove that chomp is correct with respect to chompâ‡“. Specifically,
Lemma 3.2 states thatâ€”given some heap â„ âˆˆ âŸ¦ğœâŸ§Eâ€”there exists a corresponding heap â„â€² in the
semantics of the chomped type that is equivalent to the heap obtained after applying chompâ‡“ to â„.
Since chomp adds a refinement on ğ‘¥ .ğœ„, we evaluate the chomped type in an environment, where ğ‘¥
maps to the heap in which ğœ„ contains the first sizeof (ğœ„) bits from â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›). This reflects the intuition
that chomp populates the header instance ğœ„ with the first sizeof(ğœ„) bits from the input packet.

Lemma 3.2 (Semantic Chomp). If ğ‘¥ does not appear free in ğœ, then for all heaps â„ âˆˆ âŸ¦ğœâŸ§E where
|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ sizeof(ğœ„), there exists â„â€² âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¥)âŸ§Eâ€² such that â„â€² = chompâ‡“(â„, sizeof (ğœ„))
where E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof(ğœ„)]])].

3.7 Safety of Î 4
We prove safety of Î 4 in terms of standard progress and preservation theorems. That is, well-typed
programs do not get stuck and when well-typed programs are evaluated, they remain well typed.
Both theorems make use of the entailment relation defined in Figure 9.

Theorem 3.3 (Progress). If Â· âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 and (ğ¼, ğ‘‚, ğ» ) |= ğœ1, then either ğ‘ = skip or

âˆƒâŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©.âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©.

Proof. By induction on the typing derivation. For details, see Appendix B, Theorem B.9.

â–¡

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:15

As usual, progress says that if a command is well-typed, it is either skip or can take a step.

Theorem 3.4 (Preservation). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2, âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©, and E |= Î“
2 and E â€² |= Î“â€²
1, ğœ â€²

2, such that Î“â€² âŠ¢ ğ‘ â€² : (ğ‘¥ â€² : ğœ â€²

1) â†’ ğœ â€²

and (ğ¼, ğ‘‚, ğ» ) |=E ğœ1, then there exists Î“â€², E â€², ğ‘¥ â€², ğœ â€²
1 and âŸ¦ğœ â€²
and (ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
Proof. By induction on the typing derivation. For details, see Appendix B, Theorem B.28.

â–¡

The preservation theorem says that if a command is a well-typed command ğ‘ that can step to ğ‘ â€²,
2 such that
2 is a subset of the heaps denoted by ğœ2

and a heap entails the input type ğœ1, then ğ‘ â€² is well-typed from ğœ â€²
the final heap entails ğœ â€²
with their respective input heaps bound to variable ğ‘¥.

1 and the set of heaps described by ğœ â€²

2 for some ğœ â€²

1 and ğœ â€²

1 to ğœ â€²

4 IMPLEMENTATION
We have built a prototype implementation of Î 4â€™s type system in OCaml and Z3. Under the hood,
it uses an encoding of Î 4â€™s types into a decidable theory of first-order logic, facilitating use of an
SMT solver to automatically discharge the various side conditions that arise during type checking.
We describe the algorithmic type system and its decidability, some optimizations we use to simplify
our types, and our P416 frontend.

4.1 Algorithmic Type System and Decidability
For our implementation, we define an algorithmic version of our type system whose rules are mostly
identical to the rules from our declarative type system. Figure 10 shows two selected algorithmic
typing rules that demonstrate the key differences from our declarative system. Many of the typing
rules have semantic conditions that must be checked during type checking. In the algorithmic type
system, we encode these constraints as subtype constraints. For example, when we type-check
the command add (ğœ„), we must check that the newly added instance is not already valid in the
input type ğœ1, i.e., Excludes Î“ ğœ1 ğœ„. As shown by rule T-Add-Algo in Figure 10, Excludes Î“ ğœ1 ğœ„
becomes the subtype check Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}. Similarly, rule T-Mod and T-Remit
require Includes Î“ ğœ1 ğœ„, which becomes Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | ğ‘¥ .ğœ„.valid} in T-Mod-Algo and T-
Remit-Algo respectively. The check sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ sizeof (ğœ„) required by T-Extract becomes
Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof(ğœ„)} in rule T-Extract-Algo.

The second major difference is the rule for type ascription T-Ascribe-Algo. In our implemen-
tation we check if the input type ğœ1 is a subtype of the ascribed input type Ë†ğœ1. We then use the
ascribed input type to compute an output type ğœğ‘ . Finally, we check if the computed output type
is a subtype of the ascribed output type. Note, that our type checking algorithm can be used to
obtain a weak form of type inference. Given an input type that describes the state before the
execution, our algorithm computes an output type, which describes the state after the execution
of the program. However, a full-blown treatment of type reconstruction (such as the one used by
Liquid Haskell [Vazou et al. 2018]) is left for future work.

We convert every check Î“ âŠ¢ ğœ1 <: ğœ2 into a formula in the theory of fixed-width bit vectors. This
is largely straightforward, except for the encoding of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› and ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ , which may be arbitrarily
long. However, network switches have a maximum number of bits that they can receive or transmit,
called the maximum transmission unit (MTU). So when compiling a P4 program to a given switch,
we know that the transmitted packets must be smaller than MTU. We exploit this fact to prove a
bound on the size of the bit vectors that must be considered.

More formally, we say that a type ğœ is bounded by ğ‘ in a context Î“, written Î“ âŠ¢ ğœ â‰¤ ğ‘ , iff for
every E |= Î“, and â„ âˆˆ âŸ¦ğœâŸ§E, |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ . We need to bound both â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) and
â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) by ğ‘ because (as seen in the reset command), the emitted packet is â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:16

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

T-Add-Algo

Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}

init H T (ğœ„) = ğ‘£

Î“ âŠ¢ addğœ„ : (ğ‘¥ : ğœ1) â‡ Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }

T-Ascribe-Algo
Î“ âŠ¢ ğ‘ : (ğ‘¥ : Ë†ğœ1) â‡ ğœğ‘

Î“ âŠ¢ ğœ1 <: Ë†ğœ1
Î“ âŠ¢ ğ‘ as (ğ‘¥ : Ë†ğœ1) â†’ Ë†ğœ2 : (ğ‘¥ : ğœ1) â‡ Ë†ğœ2

Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœğ‘ <: Ë†ğœ2

Fig. 10. Selected rules of the algorithmic type system

Theorem 4.1 (MTU-Bound) says that given an algorithmic typing judgement on a program ğ‘, for
which the input type and all ascribed types in ğ‘ respect the MTU ğ‘ , the output type will require no
more than ğ‘ + emit(ğ‘) bits, where emit(ğ‘) âˆˆ N is the number of bits that could possibly be emitted
in ğ‘. The details are shown in Figure 21. Note that even though the real input type is constrained
by the same MTU ğ‘ , intermediate states may require more than just ğ‘ bits. MTU-Bound shows
that ğ‘ + emit(ğ‘) suffices as the maximum combined width of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› and ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ .

Theorem 4.1 (MTU-Bound). For every Î“, ğ‘, ğ‘¥, ğœ1, ğœ2, and ğ‘ , if Î“ âŠ¢ ğœ1 â‰¤ ğ‘ and Î“ âŠ¢ ğ‘ : ((ğ‘¥ :

ğœ1)) â‡ ğœ2 and every ascribed type in ğ‘ is also bounded by ğ‘ , then Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ2 â‰¤ ğ‘ + emit(ğ‘).

Proof. By induction on the typing derivation. For details, see Appendix D, Theorem D.5.

â–¡

Theorem 4.2 establishes the correctness of the algorithmic typing relation. It states that a program
ğ‘ typechecks in the declarative system with type (ğ‘¥ : ğœ1) â†’ ğœ2 if and only if it also typechecks in
the algorithmic system with type (ğ‘¥ : ğœ1) â‡ ğœ â€²
2 is
a subtype of the output type ğœ2 of the declarative system.

2 and the output type of the algorithmic system ğœ â€²

Theorem 4.2 (Algorithmic Typing Correctness). For all Î“, ğ‘, ğ‘¥, ğœ1, and ğœ2, where ğ‘¥ is not
2, and

2 such that Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²

free in ğœ1, Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 if and only if there is some ğœ â€²
Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ â€²

2 <: ğœ2.

Proof. By induction on the typing derivation. For details, see Appendix D, Theorem C.19. â–¡

With Theorems 4.2 and 4.1 in hand, it is straightforward to show the decidability of the declarative
type system, i.e., that Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 is decidable (cf. Theorem 4.3). Theorem 4.2 allows
us to equivalently show that typechecking the command in the algorithmic type systemâ€”i.e.,
2â€”terminates and that checking Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ â€²
Î“ âŠ¢ ğ‘ : ((ğ‘¥ : ğœ1)) â‡ ğœ â€²
2 <: ğœ2 terminates, which
follows by finite enumeration using the bounds guaranteed by Theorem 4.1.

Theorem 4.3 (Decidability). If Î“, ğœ1, ğœ2 and every ascribed type in ğ‘ are bounded by the MTU ğ‘ ,

then Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 is decidable.

Proof. Proof by Algorithmic Typing Correctness, MTU-Bound and by induction on the typing
â–¡

derivation. For details, see Appendix D, Theorem D.6.

4.2 Rewriting Optimizations
The final major difference between the declarative type system and our implementation is that we
exploit two type equivalences to eliminate Î£-types and chomp. We exploit the fact that Î£-types
can be written using refinement and substitution types. In other words, in any context Î“, the type
Î£ğ‘¥ : ğœ1.ğœ2 is equivalent to

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:17

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

ï£±ï£´ï£´ï£²
ï£´ï£´
ï£³

ğ‘¥ : âŠ¤

(cid:18) ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘™ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›@ğ‘Ÿ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘™ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ @ğ‘Ÿ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡

(cid:169)
âˆ§
(cid:173)
ğœ„ âˆˆdom( H T)
(cid:171)
We also can eliminate occurrences of chomp produced by extractions. Observe that in the context

(cid:170)
(cid:174)
(cid:172)

ğ‘¥ .ğœ„.valid = ğ‘™ .ğœ„.valid âŠ• ğ‘Ÿ .ğœ„.valid âˆ§
ğ‘™ .ğœ„.valid =â‡’ ğ‘¥ .ğœ„ = ğ‘™ .ğœ„ âˆ§
ğ‘Ÿ .ğœ„.valid =â‡’ ğ‘¥ .ğœ„ = ğ‘Ÿ .ğœ„

[ğ‘Ÿ â†¦â†’ ğœ2]
[ğ‘™ â†¦â†’ ğœ1]

ï£¼ï£´ï£´ï£½
ï£´ï£´
ï£¾

(cid:219)

(cid:19)

where (ğ‘¥ : ğœ), the following two types are equivalent

Î£ğ‘¦ :

(cid:26)
ğ‘§ : ğœ„

(cid:12)
(cid:12)
(cid:12)
(cid:12)

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©

(cid:27)

(cid:26)
ğ‘§ : chomp(ğœ, ğœ„, ğ‘¦)

.

(cid:18) ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡

(cid:19)

(cid:27)

âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:17)
{ğ‘¦ : âŠ¤ | ğ‘¦.ğœ„.valid âˆ§ ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¦.ğœ„@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ (cid:211)ğœ… âˆˆdom( H T)âˆ§ğœ…â‰ ğœ„ ğ‘¦.ğœ… = ğ‘¥ .ğœ…}

Because these types are equivalent we can give extract (ğœ„) commands the following type:

(ğ‘¥ : ğœ) â†’ {ğ‘¦ : âŠ¤ | ğ‘¦.ğœ„.valid âˆ§ ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¦.ğœ„@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§

(cid:219)

ğ‘¦.ğœ… = ğ‘¥ .ğœ…}

ğœ… âˆˆdom( H T)âˆ§ğœ…â‰ ğœ„

This optimization, along with similar changes to the types for add (ğœ„) and remit (ğœ„) greatly reduce
the size of the generated Z3 formulae, making typechecking tractable.

4.3 Beyond the Core Calculus
Our prototype is equipped with a P416 frontend that uses Petr4â€™s parser [Doenges et al. 2021] to
translate a subset of type-annotated P416 programs into Î 4 programs. We leverage P4â€™s builtin
annotation mechanism to allow users to annotate control and parser blocks with types using the
custom @pi4(ğœ) annotation, where ğœ is the desired type. We also provide convenience notation
such as @pi4_roundtrip(ğœ), which ensures, as elaborated in Section 5.3 that the composition of
deparser, reset, and parser has type (ğ‘¥ : ğœ) â†’ {ğ‘¦ : âŠ¤ | ğ‘¥ â‰¡ ğ‘¦}.

5 CHECKING NETWORK INVARIANTS
We now show that dependent types are a good match for P4, by demonstrating that Î 4â€™s type
system can be used to (i) check real network protocol invariants and (ii) verify a variety of basic
and advanced safety properties. We showcase properties that are also studied in the context of
other P4 verification tools [Liu et al. 2018; Stoenescu et al. 2018]. All examples, in this section and
the next, have been implemented in our Î 4 prototype.

In most P4 programs, packet-forwarding behavior is specified using a predefined record of type
standard_metadata_t. In particular, the egress_spec field instructs the switch to forward the
packet out on a specific port. We assume that the field is initialized to 0x00, indicating that no
forwarding decision has been made, and that by setting the field to 0x1FF (i.e., the largest unsigned
9-bit value), the switch can be instructed to drop the packet.4 For simplicity, we treat all P4 metadata
as an ordinary header instance called stdmeta.

5.1 Protocol Conformance
We start with examples showing how Î 4â€™s type system can be used to ensure that a program
conforms with standard network protocols.

4In the examples that follow, we use bitvector literals assuming that they are implicitly cast to the appropriate widths
(following P416â€™s casting semantics). The implementation, however, requires these to be explicit lengths, e.g. 0b111111111
instead of 0x1FF for a 9 bit field.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:18

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1
2

3
4
5

/* Unsafe */
if ( ipv4 . valid ) {

stdmeta . egress_spec := 0 x1 ;
ipv4 . ttl := ipv4 . ttl - 0 x1

}

1
2

3
4
5

6
7

8
9

/* Safe */
if ( ipv4 . valid ) {

if ( ipv4 . ttl == 0 x00 ) {

stdmeta . egress_spec := 0 x1FF

} else {

stdmeta . egress_spec := 0 x1 ;
ipv4 . ttl := ipv4 . ttl - 0 x1

}

}

(x :{ y:ipv4~ | y. meta . valid }) ->

{y:ipv4~ | y. meta . valid && (x. ipv4 . ttl==0x0 => y. meta . egress_spec==0x1FF )}

Fig. 11. IPv4 TTL example. Top left: doesnâ€™t typecheck; top right: typechecks; bottom: Î 4 type encoding the
TTL invariant.

1
2
3

4
5

/* Unsafe */
extract ( ether );
if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 )

}

1
2
3

4
5
6

7
8

/* Safe */
extract ( ether );
if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 );
if ( ipv4 . ihl != 0 x5 ) {
extract ( ipv4opt )

}

}

(x :{ y:ğœ– |y. pkt_in . length > 280}) ->

{y:âŠ¤|(( y. ipv4 . valid && y. ipv4 . ihl != 0 x5 ) => y. ipv4opt . valid ) &&

(( y. ipv4 . valid && y. ipv4 . ihl == 0 x5 ) => !y. ipv4opt . valid )}

Fig. 12. IPv4 Options example. Top left: doesnâ€™t typecheck; right: typechecks; bottom: Î 4 type encoding the
IPv4-Option specification.

IPv4 â€” Time To Live. For Internet Protocol (IP) packets, the time to live (TTL) limits how often a
packet can be forwarded from one network switch to another. Every time a packet is forwarded,
TTL is decremented; when TTL is zero before the packet has reached its destination, forwarding
halts to eliminate the risk of infinite loops.5 The code snippet in the top left side of Figure 11 violates
the property because the packet is always forwarded on the same port while TTL is decremented.
We can detect this violation by checking the program with the type at the bottom of Figure 11,
which reads as: Starting in a heap where at least IPv4 is valid, after executing the ingress code, still
at least IPv4 is valid and if the IPv4 TTL is zero, the value of egress_spec indicates that the packet
will be dropped. The program in the top right of Figure 11 successfully typechecks with the type.

IPv4 Options. The standard IPv4 header consists of at least 160 bits, but it may also carry additional
data in optional fields. The Internet Header Length (IHL) field specifies the length of the header as
multiples of 32 and indicates whether additional data is available. The minimum IHL is 5 (5âˆ—32 = 160)
and the maximum is 15. Due to their flexibility, IP options are notoriously difficult to parse, and
many real-world network devices handle them incorrectly. We can use Î 4â€™s type system to ensure
that we also extract the IPv4 options from the input packet, whenever IPv4 is valid and IHL > 5. The
type shown in the bottom of Figure 12 states that executing the parser in the empty heap where
enough bits are available to extract Ethernet, IPv4 and IPv4 options, produces a heap satisfying
the constraint that when IPv4 is valid and IHL is 5, IPv4 options are not valid, and when IPv4 is

5Strictly speaking, IPv4 requires a special ICMP message to be returned to the sender to indicate the error.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:19

1
2

3

/* Unsafe */
extract ( ether );
extract ( ipv4 )

1
2

3
4
5

/* Safe */
extract ( ether );
if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 )

}

(x: {y:ğœ– | y. pkt_in . length > 272}) ->

{y:âŠ¤ | y. ipv4 . valid => y. ether . etherType == 0 x0800 }

Fig. 13. Header dependency example. Top left: doesnâ€™t typecheck; top right: typechecks; bottom: Î 4 type
encoding IPv4â€™s dependency on Ethernet.

valid and IHL > 5, then IPv4 options are valid. Figure 12 shows one example where this property is
violated (top left) and one where it holds (top right).

Header Dependencies. Most protocols have some way of keeping track of what other protocols
are encapsulated in the payload of a packetâ€”i.e., which header follows next. The correspondence
between field values and protocols is typically defined as part of the protocol standard. For example,
an Ethernet frame uses the EtherType field (written ether.etherType) for this purpose: a value
of 0x0800 indicates that the next header is an IPv4 header, while a value of 0x86dd indicates that
the next header is an IPv6 header. This is specified in the type at the bottom of Figure 13. The
code snippet on the top left of Figure 13 violates the dependency between the IPv4 header and the
EtherType field of the Ethernet header. Our type checker detects this by checking that executing
the parser on an empty heap with enough bits to extract both Ethernet and IPv4, produces a heap
with either an invalid or a valid IPv4 header and an EtherType value of 0x0800. The code on the
top right of Figure 13 fixes the error by only extracting ipv4 when ether.etherType is 0x0800.

5.2 Basic Safety Properties
Î 4â€™s type system can be also used to ensure safety properties. We discussed how it detects accesses
to invalid header instances in Section 2. Here we present an example showing how it can be used
to enforce determined forwarding [Liu et al. 2018; Stoenescu et al. 2018]. Typical P4 programs
contain thousands of paths on which a packet can be processed. To avoid situations where packets
are dropped unexpectedly, a desirable invariant is that each program path contains an explicit
forwarding decisionâ€”i.e., packets are either forwarded on some switch port or dropped. Our type
checker is able to detect violations of this property. The type in the bottom of Figure 14 shows one
way of encoding this specification as a type. Under the assumption that the egress specification is
initialized with a dummy value of 0x0, the type asserts that it is, at some point, modified during
the execution of the pipeline, i.e., a forwarding decision is made for every packet. The program on
the top left of Figure 14 fails to typecheck with the type, because the egress specification is unset
for packets with ipv4.dst equal to 0x0a0a0a0a. The program on the top right of Figure 14 fixes
this issue via an else-case that assigns the egress specification to 0x1FF.

5.3 Parser-Deparser Compatibility
A P4 program typically defines the parser, controls for ingress and egress pipelines, and the
deparser.6 In practice, parsing and deparsing may also happen between the ingress and egress
stagesâ€”i.e., the deparser code is additionally executed at the end of the ingress followed by the
parser code, before the egress. In such cases, it is important to ensure that data intended to be

6Why this four-phase structure? Having separate ingress and egress pipelines allows packet processing to occur both before
and after packets are scheduled, typically using one or more queues.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:20

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1
2

3
4
5

6

/* Unsafe */
if ( ipv4 . valid ) {

if ( ipv4 . dst != 0 x0a0a0a0a ) {

stdmeta . egress_spec := 0 x1FF

}

}

1
2

3
4
5

6
7

8

/* Safe */
if ( ipv4 . valid ) {

if ( ipv4 . dst != 0 x0A0A0A0A ) {
stdmeta . egress_spec := 0 x1

} else {

stdmeta . egress_spec := 0 x1FF

}

}

(x :{ y:ipv4~| y. stdmeta . valid }) -> {y:âŠ¤| y. stdmeta . egress_spec != 0 x0 }

Fig. 14. Determined forwarding example. Top left: ill-typed; top right: well-typed; bottom: determined for-
warding specification encoded as Î 4 type.

carried from ingress to egress is serialized and deserialized correctly. Otherwise, headers may be
unexpectedly removed from the packet.

For example, assume that the parser shown in Figure 15 successfully parses the Ethernet and
IPv4 headers from the input packet, but not a VLAN header. From the code we can conclude that
EtherType must be 0ğ‘¥0800. Letâ€™s further assume that the programmer intends the ingress control
in the middle right of Figure 15. After parsing, the switch checks if a VLAN header is present.
If a VLAN header was already parsed from the input packet, no changes are made. Otherwise a
VLAN header is added (Line 27) and the EtherType of the Ethernet header is updated accordingly.
If an IPv4 header is present, the EtherType must be updated accordingly (Line 31) to obtain a
protocol-conformant packet. Now, assume that the programmer forgot the statement on Line 31,
i.e., didnâ€™t update ether.etherType (this unsafe example is in the left of Figure 15). After running
the deparser at the end of ingress, all three headers are serialized: The first 112 bits correspond
to the Ethernet header, followed by 32 bits of the VLAN header, and another 160 bits of the IPv4
header. Since the programmer forgot to update EtherType, bits 96 to 112 contain the value 0x0800.
If the parser runs with this bitstream as the input, it will first parse the Ethernet header, then look
at the etherType and given the value 0ğ‘¥0800, it will continue to parse the IPv4 header. Hence, the
bits of the VLAN header are parsed as an IPv4 header, leading to a corrupted packet.

To avoid such errors, we want to enforce the invariant that all instances valid at the end of ingress
are equivalent to those obtained after deparsing and re-parsing. We instruct our type checker to
verify this property via the type on Line 36, by checking the whole program with a type that
ensures there are enough bits to parse the headers, shown on Line 1.

5.4 Mutual Exclusion of Headers
The parser shown on the top of Figure 16 conditionally parses either IPv4 or IPv6. Because only
one of the paths is taken at runtime, it should never happen that both instances are valid at the
same time. This property might be exploited in an implementation, allowing the same memory to
be used to store both headers. In this small example, it is easy to see that this invariant holds. But
in larger programs it is difficult to track which header instances are valid on which execution paths.
We can check that the property continues to hold in the ingress in the middle of Figure 16 using
the type in the ascription on Line 1. The ingress code in the middle left of Figure 16 exemplifies
a violation of the property: If a packet enters the control block with a valid IPv4 header, it will
leave with both a valid IPv4 and a valid IPv6 header; a violation of our property. The code on the
middle right is safe because it includes a conditional that explicitly checks the validity of IPv4
before adding IPv6. The combination of union types and refinement types makes our type system
capable of such precise path-dependent reasoning.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:21

1
2

3
4

5
6
7

8
9
10

11
12

13
14
15

16

34
35

36
37
38

39

Parser â‰œ

extract ( ether );
if ( ether . etherType == 0 x8100 ) {

extract ( vlan );
if ( vlan . etherType == 0 x0800 ) {

extract ( ipv4 )

}

} else {

if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 )

}

}

Deparser â‰œ

if ( ether . valid ) { remit ( ether ) };
if ( vlan . valid ) { remit ( vlan ) };
if ( ipv4 . valid ) { remit ( ipv4 ) }

17
18

19
20
21

22
23

24

25
26

27
28

29
30
31

32
33

UnsafeIngress â‰œ

if (! vlan . valid ) {

add ( vlan );
vlan . etherType := 0 x0 ;
if ( ipv4 . valid ) {

vlan . etherType := 0 x0800

}

};

SafeIngress â‰œ

if (! vlan . valid ) {

add ( vlan );
vlan . etherType := 0 x0 ;
ether . etherType := 0 x8100 ;
if ( ipv4 . valid ) {

vlan . etherType := 0 x0800 ;

}

}

Parser ; Ingress ; /* Ingress is either UnsafeIngress or SafeIngress
( Deparser ; remit ; Parser ) as

*/

(x :{ z:ether~|z. ether . etherType == 0 x8100 && z. vlan . valid &&

(z. ipv4 . valid <=> z. vlan . etherType == 0 x0800 ) &&
z. pkt_out . length == 0 &&
z. pkt_in . length > 0}) -> {y:âŠ¤| x === y}

(x :{ y:ğœ– |y. pkt_out . length == 0 && y. pkt_in . length > 304}) -> âŠ¤

Fig. 15. Roundtripping Definitions. Top left: common parser and deparser; top right: unsafe and safe ingress
code; middle: the pipeline, which typechecks with Ingress â†¦â†’ UnsafeIngress, but not with Ingress â†¦â†’
UnsafeIngress; bottom: the type at which to check the full pipeline.

1
2

3
4
5

6
7

8
9
10

11
12

13

( extract ( ether );
if ( ether . etherType == 0 x86dd ) { extract ( ipv6 ) }
else { if ( ether . etherType == 0 x0800 ) { extract ( ipv4 ) } })

as (x :{ y:ğœ– |y. pkt_in . length>432 }) -> {y:ether~|!(y. ipv4 . valid && y. ipv6 . valid ) };

Ingress /* Can be SafeIngress or UnsafeIngress */

as (x: {y: ether ~| !(y. ipv4 . valid && y. ipv6 . valid ) }) ->

{y: ether ~| !(y. ipv4 . valid && y. ipv6 . valid ) }) ;

if ( ether . valid ) { remit ( ether ) };
if ( ipv4 . valid ) { remit ( ipv4 ) };
if ( ipv6 . valid ) { remit ( ipv6 ) }

UnsafeIngress â‰œ

add ( ipv6 )
ether . etherType := 0 x86DD

(x :{ y:ğœ– |y. pkt_in . length>432 }) -> âŠ¤

14
15

16
17

18

SafeIngress â‰œ

if ( ipv4 . valid ) {

add ( ipv6 );
ether . etherType := 0 x86DD

}

Fig. 16. Mutual exclusion example: IPv4 and IPv6 should never be simultaneously valid. Top: Common pipeline;
middle left: unsafe Ingress code; middle right: safe Ingress code; bottom: whole program type.

5.5 Limitations
There are a few P4 features that our Î 4 prototype does not support, mostly because they pose
challenges to SMT-based approaches to verification: hash functions, externs (a kind of foreign

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:22

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Fig. 17. Modular router design

1

2
3

4

extract ( vlan );
Ingress /* Customer Specified . Default, Overwrite, Table, or UnsafeActions */

as (x:Î£x: stdmeta . ipv4 ) -> {y:Î£y: stdmeta ~. ipv4 ~| y. vlan == x. vlan };

remit ( vlan )

Fig. 18. Instantiation of modular router design; the parser (Pre) and deparser (Post) are provided by the
vendor, the Ingress code is provided by the customer.

function interface into the hardware), and registers. The unpredictability of hash functions is
difficult to verify, but we can either over-approximate them as uninterpreted functions, or use
a more fine-grained approach such as concolic verification. Externs either need to be annotated
with specific types, or over-approximated as uninterpreted functions. Registers are on-switch
state that can be modified by the packet or the controller and persists between packets. This
is tricky to represent in the semantics and has some distributed computing concerns. We could
over-approximate the behavior by havoc-ing the values every time the register is read.

6 MODULARITY REASONING WITH Î 4
An emerging design pattern for data plane switches is partial programmability, e.g., Ciscoâ€™s
daPIPE [Baldi 2019], which is designed for the Nexus 3400 switch [Cisco 2018]. The idea is that
a device vendor provides a partially-implemented pipeline together with a set of program points
where customers can inject custom code as shown in Figure 17. The designer requires that customer
programs satisfy certain properties, but in current architectures, they are not automatically checked.
To illustrate, consider a deployment of the customizable pipeline in a campus network where
network engineers want to experiment with in-band network telemetry (INT) without perturbing
the VLAN tag, which is used to enforce security policies. Letâ€™s say there are four classes of traffic,
Visitor, Student, Faculty, and Staff, each with unique VLAN identifiers. We want to ensure
that no matter how Ingress is instantiated in the left of Figure 18, it cannot cause students
and visitors to acquire privileges of faculty or staffâ€”e.g., this might leak confidential data. With
Î 4, we can design a modular system that statically checks invariants on customer programs.
Practically, we can ensure that VLAN is not changed by checking that customerâ€™s code has a type
like: (ğ‘¥ : ğœ) â†’ {ğ‘¦ : ğœ â€² | ğ‘¥ .vlan.vid = ğ‘¦.vlan.vid}, where the ğœ and ğœ â€² are appropriate for the
specific pipeline. We check, once-and-for-all, that the surrounding switch code composes with this
type, and incrementally check that the customer code has this type (for an appropriate ğœ).

6.1 Specifying an Invariant
To further illustrate, consider the toy example shown the right of Figure 18, which has a VLAN
instance (32 bits) and the standard metadata used in the P4 switch model (325 bits), including a
9-bit egress specification stdmeta.egress_spec, and a 12-bit vlan tag field, vlan.vid. The control
flow simply extracts the VLAN instance, executes the modular Ingress control, and then emits

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:23

5

6

7
8
9

10
11

12
13
14

15

Default â‰œ skip

Table â‰œ

add ( _vlan_table );
if ( _vlan_table . vid_key ==

vlan . vid ){

if ( _vlan_table . act == 0 b0 ){

stdmeta . egress_spec := 0 x1FF

} else {

stdmeta . egress_spec := 0 x1

}

}

16

17

18
19
20

21
22

23
24
25

26

Overwrite â‰œ vlan . vid := Faculty

UnsafeActions â‰œ

add ( _vlan_table );
if ( _vlan_table . vid_key ==

vlan . vid ) {

if ( _vlan_table . act == 0 b0 ) {

vlan . vid := Faculty

} else { vlan . vid := Staff }

} else {

vlan . vid := Visitor

}

Fig. 19. A collection of safe and unsafe customer implementations for the Ingress module from Figure 18.
Top Left: Default; Top Right: Overwrite; Bottom Left: Table; Bottom Right: Unsafe Actions

the VLAN header. We want the program to typecheck with type (ğ‘¥ : {ğ‘¥ : stdmeta | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | >
32}) â†’ Î£ğ‘¦ : stdmeta~.vlan~.

In this example, the type ascription provides compositional reasoningâ€”i.e., we donâ€™t need to
re-check that the whole pipeline is well-typed. Instead, we check once-and-for all that extract (vlan)
has type (ğ‘¥ : {ğ‘¥ : stdmeta | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | > 32}) â†’ (ğ‘¥ : (Î£ğ‘¥ : stdmeta.ipv4)), and that remit (vlan)
has type (ğ‘¥ : ({ğ‘¥ : Î£ğ‘¥ : stdmeta.ipv4 | ğ‘¥ .vlan = ğ‘¦.vlan})) â†’ Î£ğ‘¦ : stdmeta~.vlan~ in context
(ğ‘¦ : Î£ğ‘¥ : stdmeta.ipv4). Both are easy to check.

Now, when we swap in different implementations for Ingress, we only need to check that it
has its ascribed type on Line 3 of Figure 18, without rechecking the surrounding code. With the
infrastructure Î 4â€™s type system provides, network engineers can make changes to their experimental
module Ingress and check its compatibility with the switch without re-checking the feasibility of
the whole switch in a modular fashion.

6.2 Checking Customer Programs
We now consider a collection of customer programs as shown in Figure 19 that an engineer may
want to install into the switch and how Î 4 prevents security vulnerabilities by ensuring the
customer code has the type annotated on Line 3 of Figure 18.

Default. Consider the empty program, shown in the top left of Figure 18, which would surely be
the default behavior when the programmer hasnâ€™t written any code yet. To typecheck this no-op
module, we check that skip has the ascribed type, which it clearly does, since it does not change
the value of the program.

Overwrite. Conversely, if the customer were to install a blatantly incorrect program as the one
in the top right of Figure 18, which always overwrites the VLAN tag with the identifier reserved
for faculty members, the type system complains that the following subtyping check failsâ€”when
ğ‘¥ .vlan.vid is, say, Student, the two types denote disjoint sets of heaps.

(ğ‘¥ : Î£ğ‘¦ : stdmeta.vlan)

âŠ¢ {ğ‘¤ : Î£ğ‘¦ : stdmeta~.vlan~ | ğ‘¤ .vlan.vid = Faculty}

<: {ğ‘¤ : Î£ğ‘¦ : stdmeta~.vlan~ | ğ‘¤ .vlan.vid = ğ‘¥ .vlan.vid},

Table. We model match-action tables using an encoding similar to the one used in p4v [Liu et al.
2018], where we create an extra header that captures the keys and selected action. Consider the
vlan table on the bottom left of Figure 18, which matches on vlan.vid and selects one of two
actions: the first sets the egress_spec to 0x1FF; the second sets it to 0x001. To encode this table,

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:24

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

we create a new header _vlan_table with a 12-bit field vid_key and a 1-bit field act, modelling
the table application via the code shown in the bottom left of Figure 19. This will typecheck since
no branch of the code modifies the vlan.vid field, and _vlan_table is permitted to be valid.

Unsafe Actions. Now consider a vlan table where each action does modify the VLAN id. For
example, the table shown in the bottom right of Figure 18 can either set the VID to one of
{Faculty, Staff}, or, if the packet misses in the table, to Visitor. Here, the VLAN id is clobbered
whenever this table is applied, triggering a violation of the subset check just as with Overwrite.

7 RELATED WORK

Formal Reasoning for P4 Programs. A number of verification approaches have been proposed
for P4 programs. p4v [Liu et al. 2018] applies classical techniques based on predicate transformer
semantics to achieve monolithic verification of P4 programs. Vera [Stoenescu et al. 2018] and
P4-Assert [Freire et al. 2018] are symbolic execution engines for P4. The bf4 tool [Dumitrescu
et al. 2020] follows the approach of p4v, but also attempts to infer control-plane constraints that
are sufficiently strong to establish correctness, and offers heuristics for repairing programs when
verification fails. SafeP4 [Eichholz et al. 2019] uses a simple type system to track header validity.
Petr4 [Doenges et al. 2021] develops a formal semantics for P4 but does not itself offer verification
tools. In constrast to this earlier work, Î 4 uses dependent types and offers compositional verification.

Dependent Types. Early work by Xi and Pfenning [1999] showed how dependent types could
be used to eliminate run-time safety checksâ€”e.g., array bounds checks in imperative programs.
Xanadu [Xi 2000] adds dependent typing to imperative programming, but does not capture the
effect of mutations in the type. Xi and Harper [2001] later showed how dependent types could
be applied to assembly code. Deputy [Condit et al. 2007] used dependent types to reason about
complex, heap-allocated data structures. Similar to Deputy, Î 4â€™s typing rule for modification of
header fields is also inspired by the Hoare axiom for assignment. Î 4 is different in that typechecking
has no effect on the run time and also supports path-sensitive reasoning. Similar to Î 4, Hoare
Type Theory (HTT) [Nanevski et al. 2006] statically tracks how the heap evolves during execution.
Typing of computations in HTT is similar to the dependent function types Î 4â€“ the type captures
the state before and after execution, possibly relating the output type with the input type. In our
domain, this requires bit-by-bit transformations on the input type, provided by chomp. Other type
systems like Ynot [Nanevski et al. 2008], FCSL [Nanevski et al. 2014], and Fâˆ— [Swamy et al. 2016]
provide dependent types for low-level imperative programming. They target general functional
verification and often require manual programs-as-proofs to do so. Î 4 is designed with domain-
specific properties of network programming in mind and is fully automatic.

Solver-Aided Tools. Recent work on dependently-typed languages has focused on automation,
building on advances in SAT/SMT solvers to make dependent types usable by ordinary programs.
A prominent example is Liquid Haskell [Rondon et al. 2008], which extends Haskell with decidable
refinement types. Under the hood, proof obligations generated during type checking are transpar-
ently handled by an SMT solver. Just as Liquid Haskell requires its refinements to be in the theory
of quantifier-free integer linear arithmetic in order to be decidable, Î 4 stipulates that types must
denote finite setsâ€”a restriction justified by the domain. This assumption lets us encode types into
the effectively propositional fragment of first-order logic over bit vectors.

Formalizing Protocols. Another line of work focuses on language-based specifications of protocols.
CMUâ€™s FoxNet project used SML to specify the behavior of an entire networking stack [Biagioni
et al. 1994]. McCann and Chandra [2000] used a type-based approach to give abstract specifications
of protocols. Grammar-based tools such as PADS [Fisher and Gruber 2005], Narcissus [Delaware

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:25

et al. 2019], and Yakker [Jim et al. 2010], enable specifying the syntax of complex, dependent formats
including network protocols, and provide tools for serializing and deserializing data. They focus
exclusively on deriving correct parsers from a typed representation of data and may be suitable to
describe the header formats and the parser, but there is no equivalent to our chomp operator that
allows us to statically capture how the input packet changes during parsing.

8 CONCLUSION AND FUTURE WORK
This paper presented Î 4â€”the first dependently-typed language for data plane programmingâ€”a
domain with difficult challenges where programming language theory can have a big impact. In
particular, low-level data plane languages like P4 seem to be a sweet spot for dependent types. On
the one hand, precise types are necessary because critical correctness properties often hinge on
intricate, bit-level packet formats, where the first few bits of a packet determine the format, the
length, and the processing of the following ones. On the other hand, a high degree of automation is
possible due to the restricted nature of the language, which does not support pointers, loops, or
other features that often complicate very precise type systems. Yet, thus far, dependent typing has
not been explored for data plane programsâ€”the community has relied on verification tools that
lack compositional reasoning.

Î 4â€™s type system is innovative in its combination of refinement types, dependent function types,
a limited form of regular types, including unions, explicit substitutions, and a primitive â€œchompâ€
operation, reminiscent of regular expression derivatives [Brzozowski 1964], which can be used
to give a precise type to P4â€™s parsing constructs. It is capable of statically checking advanced
properties of data plane programs that combine packet serialization and deserialization operations
with imperative control-flow. Under the hood, an SMT solver automatically discharges the formulas
generated during type checking without requiring any manual proof. We define Î 4 formally and
prove type soundness and decidability. Our case studies demonstrate how Î 4 supports modular
reasoning in scenarios ranging from basic safety properties to intricate invariants.

There are a number of interesting directions for future work. We plan to investigate connections
that our verified approach to parsing using derivatives may have to other domains, e.g., verified
serializers and deserializers like EverParse [Ramananandro et al. 2019] and Narcissus [Delaware
et al. 2019]. Another direction is to consider the effect of modularity on verification times; if
a tool incrementally caches verification results for ascribed code blocks, it would only have to
check the portions of the code that change between runs of the typechecker. Some preliminary
experiments indicate that modular typechecking offers significant benefits, but an empirical study
to answer this question carefully is left for future work, after we have optimized our prototype.
We also plan to extend Î 4 to handle more complicated features of P4 perhaps requiring concolic
techniques [Godefroid et al. 2005]. Further, understanding whether dependent types are the right
interface for modular verification of dataplane programs is important. In fact, user studies inves-
tigating the appropriate typing interfaces, such as gradual typing and type inference, would be
important for guiding the design of impactful systems for modular data plane verification.

ACKNOWLEDGMENTS
We are grateful to the POPL reviewers for their careful feedback and many suggestions for improving
this paper. Our work has been supported in part by the German Research Foundation (DFG) as
part of the Collaborative Research Center (CRC) 1053 MAKI, by the National Research Center for
Applied Cybersecurity ATHENE, by the National Science Foundation under grant FMiTF-1918396
as well as a Graduate Research Fellowship, the Defense Advanced Research Projects Agency under
Contract HR001120C0107, and gifts from Keysight and InfoSys.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:26

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

REFERENCES
M. Baldi. 2019. daPIPE a Data Plane Incremental Programming Environment. In Symposium on Architectures for Networking

and Communications Systems (ANCS). 1â€“6. https://doi.org/10.1109/ANCS.2019.8901893

Ryan Beckett and Ratul Mahajan. 2020. A General Framework for Compositional Network Modeling. In Workshop on Hot

Topics in Networks (HotNets). 8â€“15. https://doi.org/10.1145/3422604.3425930

Edoardo Biagioni, Robert Harper, Peter Lee, and Brian G. Milnes. 1994. Signatures for a Network Protocol Stack: A Systems
Application of Standard ML. In Conference on LISP and Functional Programming (LFP). 55â€“64. https://doi.org/10.1145/
182409.182431

Pat Bosshart, Dan Daly, Glen Gibb, Martin Izzard, Nick McKeown, Jennifer Rexford, Cole Schlesinger, Dan Talayco, Amin
Vahdat, George Varghese, and David Walker. 2014. P4: Programming Protocol-Independent Packet Processors. SIGCOMM
Computer Communications Review (CCR) (July 2014), 87â€“95. https://doi.org/10.1145/2656877.2656890

Pat Bosshart, Glen Gibb, Hun-Seok Kim, George Varghese, Nick McKeown, Martin Izzard, Fernando Mujica, and Mark
Horowitz. 2013. Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN. In
Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and
Protocols for Computer Communication (SIGCOMM). 99â€“110. https://doi.org/10.1145/2486001.2486011

Janusz A. Brzozowski. 1964. Derivatives of Regular Expressions. J. ACM 11, 4 (Oct. 1964), 481â€“494. https://doi.org/10.1145/

321239.321249

Giuseppe Castagna, Kim Nguyen, Zhiwu Xu, Hyeonseung Im, SergueÃ¯ Lenglet, and Luca Padovani. 2014. Polymorphic
Functions with Set-Theoretic Types: Part 1: Syntax, Semantics, and Evaluation. In Symposium on Principles of Programming
Languages (POPL). 5â€“17. https://doi.org/10.1145/2535838.2535840

Cisco. 2018. Cisco Nexus 3000 Series Switches. https://www.cisco.com/c/en/us/products/switches/nexus-3000-series-

switches/index.html

Jeremy Condit, Matthew Harren, Zachary Anderson, David Gay, and George C. Necula. 2007. Dependent Types for Low-Level
Programming. In European Symposium on Programming (ESOP). 520â€“535. https://doi.org/10.1007/978-3-540-71316-6_35
Benjamin Delaware, Sorawit Suriyakarn, ClÃ©ment Pit-Claudel, Qianchuan Ye, and Adam Chlipala. 2019. Narcissus: Correct-
by-Construction Derivation of Decoders and Encoders from Binary Formats. Proceedings of the ACM Programming
Languages (PACMPL) 3, ICFP, Article 82 (July 2019). https://doi.org/10.1145/3341686

Ryan Doenges, Mina Tahmasbi Arashloo, Santiago Bautista, Alexander Chang, Newton Ni, Samwise Parkinson, Rudy
Peterson, Alaia Solko-Breslin, Amanda Xu, and Nate Foster. 2021. Petr4: Formal Foundations for P4 Data Planes.
Proceedings of the ACM on Programming Languages (PACMPL) 5, POPL, Article 41 (Jan. 2021). https://doi.org/10.1145/
3434322

Dragos Dumitrescu, Radu Stoenescu, Lorina Negreanu, and Costin Raiciu. 2020. Bf4: Towards Bug-Free P4 Programs. In
Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and
Protocols for Computer Communication (SIGCOMM). 571â€“585. https://doi.org/10.1145/3387514.3405888

Matthias Eichholz, Eric Campbell, Nate Foster, Guido Salvaneschi, and Mira Mezini. 2019. How to Avoid Making a Billion-
Dollar Mistake: Type-Safe Data Plane Programming with SafeP4. In European Conference on Object-Oriented Programming
(ECOOP). 12:1â€“12:28. https://doi.org/10.4230/LIPIcs.ECOOP.2019.12

Robert Ennals, Richard Sharp, and Alan Mycroft. 2004. Linear Types for Packet Processing. In European Symposium on

Programming (ESOP). 204â€“218. https://doi.org/10.1007/978-3-540-24725-8_15

Kathleen Fisher and Robert Gruber. 2005. PADS: A Domain-Specific Language for Processing Ad Hoc Data. In Conference on

Programming Language Design and Implementation (PLDI). 295â€“304. https://doi.org/10.1145/1065010.1065046

Lucas Freire, Miguel Neves, Lucas Leal, Kirill Levchenko, Alberto Schaeffer-Filho, and Marinho Barcellos. 2018. Uncovering
Bugs in P4 Programs with Assertion-Based Verification. In Symposium on SDN Research (SOSR). Article 4, 7 pages.
https://doi.org/10.1145/3185467.3185499

Jiaqi Gao, Ennan Zhai, Hongqiang Harry Liu, Rui Miao, Yu Zhou, Bingchuan Tian, Chen Sun, Dennis Cai, Ming Zhang, and
Minlan Yu. 2020. Lyra: A Cross-Platform Language and Compiler for Data Plane Programming on Heterogeneous ASICs.
In Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and
Protocols for Computer Communication (SIGCOMM). 435â€“450. https://doi.org/10.1145/3387514.3405879

Vladimir Gapeyev and Benjamin C. Pierce. 2003. Regular Object Types. In European Conference on Object-Oriented Program-

ming (ECOOP). 151â€“175. https://doi.org/10.1007/978-3-540-45070-2_8

Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed automated random testing. In Conference on

Programming Language Design and Implementation (PLDI). 213â€“223. https://doi.org/10.1145/1065010.1065036

Toke HÃ¸iland-JÃ¸rgensen, Jesper Dangaard Brouer, Daniel Borkmann, John Fastabend, Tom Herbert, David Ahern, and
David Miller. 2018. The EXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel. In
International Conference on Emerging Networking EXperiments and Technologies (CoNEXT). 54â€“66. https://doi.org/10.
1145/3281411.3281443

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:27

Haruo Hosoya and Benjamin C. Pierce. 2003. XDuce: A Statically Typed XML Processing Language. ACM Transactions on

Internet Technology (TOIT) 3, 2 (May 2003), 117â€“148. https://doi.org/10.1145/767193.767195

Stephen Ibanez, Gordon Brebner, Nick McKeown, and Noa Zilberman. 2019. The P4->NetFPGA Workflow for Line-Rate Packet
Processing. In Symposium on Field-Programmable Gate Arrays (FPGA). 1â€“9. https://doi.org/10.1145/3289602.3293924
Trevor Jim, Yitzhak Mandelbaum, and David Walker. 2010. Semantics and Algorithms for Data-Dependent Grammars. In

Symposium on Principles of Programming Languages (POPL). 417â€“430. https://doi.org/10.1145/1706299.1706347

Xin Jin, Xiaozhou Li, Haoyu Zhang, Robert SoulÃ©, Jeongkeun Lee, Nate Foster, Changhoon Kim, and Ion Stoica. 2017.
NetCache: Balancing Key-Value Stores with Fast In-Network Caching. In Symposium on Operating Systems Principles
(SOSP). 121â€“136. https://doi.org/10.1145/3132747.3132764

Jed Liu, William Hallahan, Cole Schlesinger, Milad Sharif, Jeongkeun Lee, Robert SoulÃ©, Han Wang, CÄƒlin CaÅŸcaval, Nick
McKeown, and Nate Foster. 2018. p4v: Practical Verification for Programmable Data Planes. In Conference of the
Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer
Communication (SIGCOMM). 490â€“503. https://doi.org/10.1145/3230543.3230582

Conor McBride. 2001. The derivative of a regular type is its type of one-hole contexts. Extended abstract, available at

http://strictlypositive.org/diff.pdf.

Peter J. McCann and Satish Chandra. 2000. Packet Types: Abstract Specification of Network Protocol Messages. In Conference
of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for
Computer Communication (SIGCOMM). 321â€“333. https://doi.org/10.1145/347059.347563

Chitra Muthukrishnan, Vern Paxson, Mark Allman, and Aditya Akella. 2010. Using Strongly Typed Networking to Architect
for Tussle. In Workshop on Hot Topics in Networks (HotNets). Article 9, 6 pages. https://doi.org/10.1145/1868447.1868456
Aleksandar Nanevski, Ruy Ley-Wild, Ilya Sergey, and GermÃ¡n AndrÃ©s Delbianco. 2014. Communicating State Transition
Systems for Fine-Grained Concurrent Resources. In European Symposium on Programming (ESOP). 290â€“310. https:
//doi.org/10.1007/978-3-642-54833-8_16

Aleksandar Nanevski, Greg Morrisett, and Lars Birkedal. 2006. Polymorphism and Separation in Hoare Type Theory. In

International Conference on Functional Programming (ICFP). 62â€“73. https://doi.org/10.1145/1159803.1159812

Aleksandar Nanevski, Greg Morrisett, Avraham Shinnar, Paul Govereau, and Lars Birkedal. 2008. Ynot: Dependent Types
for Imperative Programs. In International Conference on Functional Programming (ICFP. 229â€“240. https://doi.org/10.1145/
1411204.1411237

Tahina Ramananandro, Antoine Delignat-Lavaud, Cedric Fournet, Nikhil Swamy, Tej Chajed, Nadim Kobeissi, and Jonathan
Protzenko. 2019. EverParse: Verified Secure Zero-Copy Parsers for Authenticated Message Formats. In USENIX Security
Symposium (USENIX Security). 1465â€“1482. https://www.usenix.org/conference/usenixsecurity19/presentation/delignat-
lavaud

Patrick M. Rondon, Ming Kawaguci, and Ranjit Jhala. 2008. Liquid Types. In Conference on Programming Language Design

and Implementation (PLDI). 159â€“169. https://doi.org/10.1145/1375581.1375602

Hardik Soni, Myriana Rifai, Praveen Kumar, Ryan Doenges, and Nate Foster. 2020. Composing Dataplane Programs with
ğœ‡P4. In Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures,
and Protocols for Computer Communication (SIGCOMM). 329â€“343. https://doi.org/10.1145/3387514.3405872

Radu Stoenescu, Dragos Dumitrescu, Matei Popovici, Lorina Negreanu, and Costin Raiciu. 2018. Debugging P4 Programs with
Vera. In Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures,
and Protocols for Computer Communication (SIGCOMM). 518â€“532. https://doi.org/10.1145/3230543.3230548

Nikhil Swamy, CÄƒtÄƒlin HriÅ£cu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Simon Forest, Karthikeyan Bharga-
van, CÃ©dric Fournet, Pierre-Yves Strub, Markulf Kohlweiss, Jean-Karim Zinzindohoue, and Santiago Zanella-BÃ©guelin.
2016. Dependent Types and Multi-Monadic Effects in F*. In Symposium on Principles of Programming Languages (POPL).
256â€“270. https://doi.org/10.1145/2837614.2837655

Sam Tobin-Hochstadt and Matthias Felleisen. 2010. Logical Types for Untyped Languages. In International Conference on

Functional Programming (ICFP). 117â€“128. https://doi.org/10.1145/1863543.1863561

Niki Vazou, Eric L. Seidel, Ranjit Jhala, Dimitrios Vytiniotis, and Simon Peyton-Jones. 2014. Refinement Types for Haskell.

In International Conference on Functional Programming (ICFP). 269â€“282. https://doi.org/10.1145/2628136.2628161
Niki Vazou, Ã‰ric Tanter, and David Van Horn. 2018. Gradual Liquid Type Inference. Proceedings of the ACM on Programming

Languages (PACMPL) 2, OOPSLA, Article 132 (Oct. 2018), 25 pages. https://doi.org/10.1145/3276502

Han Wang, Robert SoulÃ©, Huynh Tu Dang, Ki-Suh Lee, Vishal Shrivastav, Nate Foster, and Hakim Weatherspoon. 2017.
P4FPGA: A Rapid Prototyping Framework for P4. In Symposium on SDN Research (SOSR). 122â€“135. https://doi.org/10.
1145/3050220.3050234

Hongwei Xi. 2000. Imperative programming with dependent types. In Symposium on Logic in Computer Science (LICS).

375â€“387. https://doi.org/10.1109/LICS.2000.855785

Hongwei Xi and Robert Harper. 2001. A Dependently Typed Assembly Language. In International Conference on Functional

Programming (ICFP). 169â€“180. https://doi.org/10.1145/507635.507657

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:28

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Hongwei Xi and Frank Pfenning. 1999. Dependent Types in Practical Programming. In Symposium on Principles of

Programming Languages (POPL). 214â€“227.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:29

A DEFINITIONS

A.1 Chomp / HeapRef

chomp1 : ğœ Ã— ğµğ‘› â†’ ğœ

chomp1 (Î£ğ‘¥ : ğœ1.ğœ2, bn) â‰œ Î£ğ‘¥ : chomp1(ğœ1, bn).chompRef1(ğœ2, ğ‘¥, bn) +
Î£ğ‘¥ : {ğ‘¦ : ğœ1 | |ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}.chomp1(ğœ2, bn)

chomp1(ğœ1 + ğœ2, bn) â‰œ chomp1(ğœ1, bn) + chomp1(ğœ2, ğ‘0)

ğœ‘
chomp1({ğ‘¥ : ğœ | ğ‘’}, bn) â‰œ {ğ‘¥ : chomp1(ğœ, bn) | chomp
1 (ğ‘’, ğ‘¥, bn)}
chomp1(ğœ1 [ğ‘¥ â†¦â†’ ğœ2], bn) â‰œ chomp1(ğœ1, bn) [ğ‘¥ â†¦â†’ ğœ2]

chomp1(ğœ, _) â‰œ ğœ

chompRef1 : ğœ Ã— X Ã— ğµğ‘› â†’ ğœ

chompRef1(Î£ğ‘¥ : ğœ1.ğœ2, ğ‘¥, bn) â‰œ Î£ğ‘¥ : chompRef1(ğœ1, ğ‘¥, bn).chompRef1(ğœ2, ğ‘¥, bn)
chompRef1(ğœ1 + ğœ2, ğ‘¥, bn) â‰œ chompRef1(ğœ1, ğ‘¥, bn) + chompRef1(ğœ2, ğ‘¥, bn)
ğœ‘
chompRef1({ğ‘¥ : ğœ | ğœ‘ }, ğ‘¥, bn) â‰œ {ğ‘¥ : chompRef1(ğœ, ğ‘¥, bn) | chomp
1 (ğœ‘, ğ‘¥, bn)}
chompRef1(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], ğ‘¥, bn) â‰œ chompRef1(ğœ1, ğ‘¥, bn) [ğ‘¦ â†¦â†’ chompRef (ğœ2, ğ‘¥, bn)]

chompRef1(ğœ, _, _) â‰œ ğœ

ğœ‘
1 : ğœ‘ Ã— X Ã— ğµğ‘› â†’ ğœ‘
chomp

ğœ‘
ğ‘’
ğ‘’
1 (ğ‘¡1 = ğ‘¡2, ğ‘¥, bn) â‰œ chomp
1 (ğ‘¡2, ğ‘¥, bn)
1 (ğ‘¡1, ğ‘¥, bn) = chomp
chomp
ğœ‘
ğ‘’
ğ‘’
1 (ğ‘¡1 > ğ‘¡2, ğ‘¥, bn) â‰œ chomp
1 (ğ‘¡1, ğ‘¥, bn) > chomp
1 (ğ‘¡2, ğ‘¥, bn)
chomp
ğœ‘
ğœ‘
ğœ‘ (ğœ‘2, ğ‘¥, bn)
1 (ğœ‘1 âˆ§ ğœ‘2, ğ‘¥, bn) â‰œ chomp
1 (ğœ‘1, ğ‘¥, bn) âˆ§ chomp
chomp
ğœ‘
ğœ‘
1 (Â¬ğœ‘, ğ‘¥, bn) â‰œ Â¬chomp
1 (ğœ‘, ğ‘¥, bn)
chomp

ğœ‘
1 (ğœ‘, _, _) â‰œ ğœ‘
chomp

ğ‘’
1 (|ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |, ğ‘¦, _) â‰œ
chomp

ğ‘’
1 : ğ‘’ Ã— X Ã— ğµğ‘› â†’ ğ‘’
chomp
|ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | + 1
|ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |

(cid:40)

if ğ‘¥ = ğ‘¦
otherwise

ğ‘’
1 (ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›, ğ‘¦, bn) â‰œ
chomp

(cid:40)

âŸ¨bnâŸ©@ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›

if ğ‘¥ = ğ‘¦
otherwise

ï£±ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´

ğ‘’
1 (ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ], ğ‘¦, bn) â‰œ
chomp

ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ]
âŸ¨bnâŸ©
âŸ¨bnâŸ©@ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ âˆ’ 1]
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ âˆ’ 1 :ğ‘Ÿ âˆ’ 1]

if ğ‘¥ â‰  ğ‘¦
if ğ‘¥ = ğ‘¦ âˆ§ ğ‘Ÿ â‰¤ 1
if ğ‘¥ = ğ‘¦ âˆ§ ğ‘™ = 0
if ğ‘¥ = ğ‘¦ âˆ§ ğ‘™ â‰  0
ğ‘’
ğ‘’
ğ‘’
1 (ğ‘› + ğ‘š, ğ‘¦, bn) â‰œ chomp
1 (ğ‘›, ğ‘¦, bn) + chomp
1 (ğ‘š, ğ‘¦, bn)
chomp
ğ‘’
ğ‘’
ğ‘’
1 (ğ‘ğ‘£1@ğ‘ğ‘£2, ğ‘¦, bn) â‰œ chomp
1 (ğ‘ğ‘£1, ğ‘¦, bn)@chomp
1 (ğ‘ğ‘£2, ğ‘¦, bn)
chomp
ğ‘’
1 (ğ‘’, _, _) â‰œ ğ‘’
chomp

ï£³

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:30

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

heapRef1 : ğœ Ã— bn Ã— X Ã— ğœ„ Ã— N â†’ ğœ

heapRef1(Î£ğ‘¥ : ğœ1.ğœ2, bn, ğ‘¦, ğœ„, ğ‘›) â‰œ Î£ğ‘¥ : heapRef1 (ğœ1, bn, ğ‘¦, ğœ„, ğ‘›).
heapRef1(ğœ2, bn, ğ‘¦, ğœ„, ğ‘›)

heapRef1(ğœ1 + ğœ2, bn, ğ‘¦, ğœ„, ğ‘›) â‰œ heapRef1(ğœ1, bn, ğ‘¦, ğœ„, ğ‘›)+
heapRef1 (ğœ2, bn, ğ‘¦, ğœ„, ğ‘›)

heapRef1({ğ‘¥ : ğœ | ğœ‘ }, bn, ğ‘¦, ğœ„, ğ‘›) â‰œ {ğ‘¥ : heapRef1(ğœ, bn, ğ‘¦, ğœ„, ğ‘›) |
heapRef1(ğœ‘, bn, ğ‘¦, ğœ„, ğ‘›)}
heapRef1(ğœ1 [ğ‘¥ â†¦â†’ ğœ2], bn, ğ‘¦, ğœ„, ğ‘›) â‰œ heapRef1(ğœ1, bn, ğ‘¦, ğœ„, ğ‘›) [ğ‘¥ â†¦â†’

heapRef1(ğœ2, bn, ğ‘¦, ğœ„, ğ‘›)]

heapRef1(ğœ, _, _, _, _) â‰œ ğœ

heapRef1 : ğœ‘ Ã— bn Ã— X Ã— ğœ„ Ã— ğ‘› â†’ ğœ‘

heapRef1(ğ‘¡1 = ğ‘¡2, bn, ğ‘¥, ğœ„, ğ‘›) â‰œ heapRef1(ğ‘¡1, bn, ğ‘¥, ğœ„, ğ‘›) = heapRef1(ğ‘¡2, bn, ğ‘¥, ğœ„, ğ‘›)
heapRef1(ğ‘¡1 > ğ‘¡2, bn, ğ‘¥, ğœ„, ğ‘›) â‰œ heapRef1(ğ‘¡1, bn, ğ‘¥, ğœ„, ğ‘›) > heapRef1(ğ‘¡2, bn, ğ‘¥, ğœ„, ğ‘›)
heapRef1(ğœ‘1 âˆ§ ğœ‘2, bn, ğ‘¥, ğœ„, ğ‘›) â‰œ heapRef1(ğœ‘1, bn, ğ‘¥, ğœ„, ğ‘›) âˆ§ heapRef1(ğœ‘2, bn, ğ‘¥, ğœ„, ğ‘›)

heapRef1(Â¬ğœ‘, bn, ğ‘¥, ğœ„, ğ‘›) â‰œ Â¬heapRef1(ğœ‘, bn, ğ‘¥, ğœ„, ğ‘›)

heapRef1(ğœ‘, _, _, _, _) â‰œ ğœ‘

heapRef1 : ğ‘’ Ã— bn Ã— X Ã— ğœ„ Ã— ğ‘› â†’ ğ‘’

heapRef1(ğ‘ :: ğ‘ğ‘£, bn, ğ‘¥, ğœ„, ğ‘›) â‰œ

ï£±ï£´ï£´ï£´ï£²
ï£´ï£´ï£´
ï£³
heapRef1(ğ‘’, _, _, _) â‰œ ğ‘’

ğ‘¥ .ğœ„ [sizeof (ğœ„) âˆ’ ğ‘› : sizeof (ğœ„) âˆ’ ğ‘› + 1]@
heapRef1(ğ‘ğ‘£, bn, ğ‘¥, ğœ„, ğ‘›)

âŸ¨ğ‘âŸ©@heapRef1(ğ‘ğ‘£, bn, ğ‘¥, ğœ„, ğ‘›)

if ğ‘ = bn
otherwise

A.2 Additional Rules for the Operational Semantics

E-If

âŸ¨ğ¼, ğ‘‚, ğ», ğœ‘âŸ© â†’ ğœ‘ â€²
âŸ¨ğ¼, ğ‘‚, ğ», if (ğœ‘) then c1 else c2âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ», if (ğœ‘ â€²) then c1 else c2âŸ©

E-IfTrue

âŸ¨ğ¼, ğ‘‚, ğ», if (true) then c1 else c2âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ», ğ‘1âŸ©

E-IfFalse

E-Seq

âŸ¨ğ¼, ğ‘‚, ğ», if (false) then c1 else c2âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ», ğ‘2âŸ©

âŸ¨ğ¼, ğ‘‚, ğ», skip; ğ‘2âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ», ğ‘2âŸ©

E-Seq1

âŸ¨ğ¼, ğ‘‚, ğ», ğ‘1âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²
1âŸ©
âŸ¨ğ¼, ğ‘‚, ğ», ğ‘1; ğ‘2âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²
1; ğ‘2âŸ©

E-Mod1

âŸ¨ğ¼, ğ‘‚, ğ», ğ‘’âŸ© â†’ ğ‘’ â€²
âŸ¨ğ¼, ğ‘‚, ğ», ğœ„.ğ‘“ = ğ‘’âŸ© â†’ âŸ¨ğ¼, ğ‘‚, ğ», ğœ„.ğ‘“ := ğ‘’ â€²âŸ©

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:31

B SAFETY
We assume that the environment E is empty whenever it is omitted from the entailment relation or
the semantics of expressions and formulae. In the context of the semantics of heap types, we use
(ğ¼, ğ‘‚, ğ» ) as a shorthand notation for the heap ğ» [ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ ğ¼, ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ â†¦â†’ ğ‘‚]. For example, we write
(ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœâŸ§E instead of ğ» [ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ ğ¼, ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ â†¦â†’ ğ‘‚] âˆˆ âŸ¦ğœâŸ§E.

Lemma B.1 (Semantic Entailment). If (ğ¼, ğ‘‚, ğ» ) |=E ğœ, then (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœâŸ§E
Proof. By induction on ğœ.

Case ğœ = âˆ…: Immediate, since (ğ¼, ğ‘‚, ğ» ) |=E âˆ… is a contradiction.
Case ğœ = âŠ¤: Immediate, since âŸ¦âŠ¤âŸ§E = H .
Case ğœ = Î£ğ‘¥ : ğœ1.ğœ2: By inversion of entailment, we get
(A1) (ğ¼, ğ‘‚, ğ» ) = (ğ¼1@ğ¼2, ğ‘‚1@ğ‘‚2, ğ»1 âˆª ğ»2) and
(A2) (ğ¼1, ğ‘‚1, ğ»1) |=E ğœ1 and
(A3) (ğ¼2, ğ‘‚2, ğ»2) |=E [ğ‘¥â†¦â†’(ğ¼1,ğ‘‚1,ğ»1) ] ğœ2

By (A2) respectively (A3) and the induction hypothesis, we get

(A4) (ğ¼1, ğ‘‚1, ğ»1) âˆˆ âŸ¦ğœ1âŸ§E and
(A5) (ğ¼2, ğ‘‚2, ğ»2) âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼1,ğ‘‚1,ğ»1) ].

To show that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E = {â„1 ++ â„2 | â„1 âˆˆ âŸ¦ğœ1âŸ§E âˆ§ â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ] }, we
have to show that (ğ¼, ğ‘‚, ğ» ) is the concatenation of two heaps â„1 and â„2, where â„1 âˆˆ âŸ¦ğœ1âŸ§E
and â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ], which follows from (A1), (A4) and (A5).

Case ğœ = ğœ1 + ğœ2: By inversion of entailment, either (ğ¼, ğ‘‚, ğ» ) |=E ğœ1 or (ğ¼, ğ‘‚, ğ» ) |=E ğœ2. To show
that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1 + ğœ2âŸ§E = âŸ¦ğœ1âŸ§E âˆª âŸ¦ğœ2âŸ§E, we have to show that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1âŸ§E or
(ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ2âŸ§E.
Subcase (ğ¼, ğ‘‚, ğ» ) |=E ğœ1: By induction hypothesis, (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1âŸ§E. We can conclude

(ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1 + ğœ2âŸ§E.

Subcase (ğ¼, ğ‘‚, ğ» ) |=E ğœ2: Symmetric to previous subcase.

Case ğœ = {ğ‘¥ : ğœ1 | ğœ‘ }: By inversion of entailment, we get
(A1) (ğ¼, ğ‘‚, ğ» ) |=E ğœ and
(A2) âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = ğ‘¡ğ‘Ÿğ‘¢ğ‘’

To show that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦{ğ‘¥ : ğœ | ğœ‘ }âŸ§E = {â„ | â„ âˆˆ âŸ¦ğœâŸ§E âˆ§ âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’â„] }, we have to show that
(ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœâŸ§E and that âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = ğ‘¡ğ‘Ÿğ‘¢ğ‘’. The first follows by induction hypothesis
and (A1) and the latter by (A2).

Case ğœ = ğœ1 [ğ‘¥ â†¦â†’ ğœ2]: By inversion of entailment, we get
(A1) (ğ¼2, ğ‘‚2, ğ»2) |=E ğœ2 for some ğ¼2, ğ‘‚2, ğ»2 and
(A2) (ğ¼, ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼2,ğ‘‚2,ğ»2) ] ğœ1

To show that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1 [ğ‘¥ â†¦â†’ ğœ2]âŸ§E = {â„ | â„2 âˆˆ âŸ¦ğœ2âŸ§E âˆ§ â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¥â†¦â†’â„2 ] }, we
have to show that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¥â†¦â†’â„2 ] where â„2 âˆˆ âŸ¦ğœ2âŸ§E. By induction hypothesis and
(A2) follows that (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¥â†¦â†’(ğ¼2,ğ‘‚2,ğ»2) ]. (ğ¼2, ğ‘‚2, ğ»2) âˆˆ âŸ¦ğœ2âŸ§E follows by induction
hypothesis and (A1), which concludes this case.

â–¡

Lemma B.2 (Semantic Containment Entails). If (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœâŸ§E, then (ğ¼, ğ‘‚, ğ» ) |=E ğœ.
Proof. By induction on ğœ.

Case ğœ = âˆ…: Immediate, since there is no heap in âŸ¦âˆ…âŸ§E.
Case ğœ = âŠ¤: Result directly follows by Ent-Top.
Case ğœ = Î£ğ‘¥ : ğœ1.ğœ2: By the semantics of heap types, all heaps â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§ have the form
â„ = â„1 ++ â„2, where â„1 = (ğ¼1, ğ‘‚1, ğ»1) âˆˆ âŸ¦ğœ1âŸ§E and â„2 = (ğ¼2, ğ‘‚2, ğ»2) âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1]. By

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:32

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

applying the induction hypothesis, we get (ğ¼1, ğ‘‚1, ğ»1) |=E ğœ1 and (ğ¼2, ğ‘‚2, ğ»2) |=E [ğ‘¥â†¦â†’â„1 ] ğœ2.
The result directly follows by Ent-Sigma.

Case ğœ = ğœ1 + ğœ2: By the semantics of heap types, for any â„ âˆˆ âŸ¦ğœ1 +ğœ2âŸ§E holds that either â„ âˆˆ âŸ¦ğœ1âŸ§E

or â„ âˆˆ âŸ¦ğœ2âŸ§E.
Subcase â„ âˆˆ âŸ¦ğœ1âŸ§E: By induction hypothesis, â„ |=E ğœ1. The result directly follows by Ent-

ChoiceL.

Subcase â„ âˆˆ âŸ¦ğœ1âŸ§E: Symmetric to previous subcase.

Case ğœ = {ğ‘¦ : ğœ1 | ğœ‘ }: By the semantics of heap types, â„ âˆˆ âŸ¦ğœ1âŸ§E and âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’â„] = true. By

induction hypothesis, â„ |=E ğœ. The result directly follows by Ent-Refine.

Case ğœ = ğœ1 [ğ‘¥ â†¦â†’ ğœ2]: By the semantics of heap types, â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¥â†¦â†’â„2 ] where â„2 âˆˆ âŸ¦ğœ2âŸ§E. By
induction hypothesis, â„2 |=E ğœ2 and â„ |=E [ğ‘¥â†¦â†’â„2 ] ğœ1. The result directly follows by Ent-Subst.
â–¡

Lemma B.3 (Subtype Entailment). If (ğ¼, ğ‘‚, ğ» ) |=E ğœ1 and E |= Î“ and Î“ âŠ¢ ğœ1 <: ğœ2, then

(ğ¼, ğ‘‚, ğ» ) |=E ğœ2.

Proof. By Lemma B.1, (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1âŸ§E. With E |= Î“ and by definition of subtyping, (ğ¼, ğ‘‚, ğ» ) âˆˆ
â–¡

âŸ¦ğœ2âŸ§E. The result follows by Lemma B.2.

Lemma B.4 (Extended Environment Entails). If E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ and ğ‘¥ âˆ‰ dom(E),

then E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )] |= Î“, ğ‘¥ : ğœ.

Proof. By definition of entailment between environments and typing contexts and by assump-
â–¡

tions.

Lemma B.5 (Included Instances in Domain). If (ğ¼, ğ‘‚, ğ» ) |=E ğœ and Includes Î“ ğœ ğœ„, then ğœ„ âˆˆ

dom(ğ» ).

Proof. By Lemma B.1, (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœâŸ§E. By assumption Includes Î“ ğœ ğœ„ and by definition of
â–¡

inclusion, âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .ğœ„ âˆˆ dom(â„), we can conclude that ğœ„ âˆˆ dom(ğ» ).

Lemma B.6 (Excluded Instances not in Domain). If (ğ¼, ğ‘‚, ğ» ) |=E ğœ and Excludes Î“ ğœ ğœ„, then

ğœ„ âˆ‰ dom(ğ» ).

Proof. By Lemma B.1, (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœâŸ§E. By assumption Excludes Î“ ğœ ğœ„ and by definition of
â–¡

exclusion, âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .ğœ„ âˆ‰ dom(â„), we can conclude that ğœ„ âˆ‰ dom(ğ» ).

Lemma B.7 (Expression Progress). If Î“; ğœ âŠ¢ ğ‘’ : ğœ and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ, then either ğ‘’ is

a value or âˆƒğ‘’ â€².âŸ¨ğ¼, ğ‘‚, ğ», ğ‘’âŸ© â†’ ğ‘’ â€².

Lemma B.8 (Formulae Progress). If Î“; ğœ âŠ¢ ğœ‘ : B and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ, then either ğœ‘ is

a value or âˆƒğœ‘ â€².âŸ¨ğ¼, ğ‘‚, ğ», ğœ‘âŸ© â†’ ğœ‘ â€²

Theorem B.9 (Progress). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ1, then either

ğ‘ = skip or there exists âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ© such that âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©.
Proof. By induction on typing derivations of Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2.

Case T-Skip: ğ‘ = skip

The result is immediate.

Case T-Extract: ğ‘ = extract (ğœ„) and Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ1) â‰¥ sizeof(ğœ„)

By inversion of (ğ¼, ğ‘‚, ğ» ) |=E ğœ1, we know that ğ¼ contains enough bits such that deserializeğœ‚ (ğ¼ )
does not fail. Let (ğ‘£, ğ¼ â€²) = deserializeğœ‚ (I ) and ğ‘‚ â€² = ğ‘‚ and ğ» â€² = ğ» [ğœ„ â†¦â†’ ğ‘£] and ğ‘ â€² = skip. The
result follows by E-Extract.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:33

Case T-Reset: ğ‘ = reset

Let ğ¼ â€² = ğ‘‚@ğ¼, ğ‘‚ â€² = âŸ¨âŸ©, ğ» â€² = [] and ğ‘ â€² = skip. The result follows by E-Reset.

Case T-Remit: ğ‘ = remit (ğœ„) and Includes Î“ ğœ1 ğœ„

By Lemma B.5 we know ğœ„ âˆˆ ğ‘‘ğ‘œğ‘š(ğ» ). Let ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚@serializeğœ‚ (ğ» (ğœ„)), ğ» â€² = ğ» and
ğ‘ â€² = skip. The result follows by E-Remit

Case T-Mod: ğ‘ = ğœ„.ğ‘“ := ğ‘’ and Includes Î“ ğœ1 ğœ„ and F (ğœ„, ğ‘“ ) = BV and Î“; ğœ1 âŠ¢ ğ‘’ : BV and ğœ2 = {ğ‘¦ : âŠ¤ |

ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}
By Lemma B.7, either ğ‘’ is a value or there is some ğ‘’ â€² such that âŸ¨ğ¼, ğ‘‚, ğ», ğ‘’âŸ© â†’ ğ‘’ â€².
Subcase ğ‘’ = ğ‘£: By Lemma B.5, ğœ„ âˆˆ ğ‘‘ğ‘œğ‘š(ğ» ). Let ğ‘Ÿ = ğ» (ğœ„) and ğ‘Ÿ â€² = {ğ‘Ÿ with ğ‘“ = ğ‘£ }. Let

ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ» [ğœ„ â†¦â†’ ğ‘Ÿ ] and ğ‘ â€² = skip. The result follows by E-Mod.

Subcase âŸ¨ğ¼, ğ‘‚, ğ», ğ‘’âŸ© â†’ ğ‘’ â€²: Let ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ» â€² and ğ‘ â€² = ğœ„.ğ‘“ := ğ‘¡ â€². The result follows

by E-Mod1.

Case T-Seq: ğ‘ = ğ‘1; ğ‘2 and Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â†’ ğœ â€²

1 and Î“ âŠ¢ ğ‘2 : (ğ‘¥ : ğœ â€²

1) â†’ ğœ2

By IH, ğ‘1 is either skip or there is some âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²
If ğ‘1 = skip, let ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ» and ğ‘ â€² = ğ‘2.
The result follows by E-Seq. Otherwise, the result follows by E-Seq1.

1âŸ©, such that âŸ¨ğ¼, ğ‘‚, ğ», ğ‘1âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²

1âŸ©.

Case T-If: ğ‘ = if (ğœ‘) then c1 else c2 and Î“; ğœ1 âŠ¢ ğ‘’ : B

By Lemma B.8, we have that ğœ‘ is either true, false or there is some ğœ‘ â€² such that âŸ¨ğ¼, ğ‘‚, ğ», ğœ‘âŸ© â†’
ğœ‘ â€².
Subcase ğœ‘ = true: Let ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ» and ğ‘ â€² = ğ‘1. The result follows by E-IfTrue.
Subcase ğœ‘ = false: Symmetric to previous subcase.
Subcase âŸ¨ğ¼, ğ‘‚, ğ», ğœ‘âŸ© â†’ ğœ‘ â€²: Let ğ¼ â€² = ğ¼ and ğ‘‚ â€² = ğ‘‚ and ğ» â€² = ğ» .

Further, let ğ‘ â€² = if (ğœ‘ â€²) then c1 else c2. The result follows by E-If.

Case T-Add: ğ‘ = addğœ„ and Excludes Î“ ğœ ğœ„.

By Lemma B.6, ğœ„ âˆ‰ dom(ğ» ). The result follows by E-Add.

Case T-Ascribe: ğ‘ = ğ‘ğ‘ as (ğ‘¥ : ğœğ‘1) â†’ ğœğ‘2. Let ğ¼ â€² = ğ¼ , ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ» and ğ‘ â€² = ğ‘ğ‘. The result

follows by E-Ascribe.

Case T-Sub: Î“ âŠ¢ ğœ1 <: ğœ3 and Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ4 <: ğœ2 and Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ3) â†’ ğœ4. By Lemma B.3,
(ğ¼, ğ‘‚, ğ» ) |=E ğœ3. By IH, ğ‘ = skip or there exists ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€² s.t. âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©.
The result follows directly.

â–¡

Lemma B.10 (Weakening). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 and variable ğ‘§ does not appear free in ğœ1 or ğœ2,

then Î“, ğ‘§ : ğœ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 for any heap type ğœ.
Proof. By induction on the typing derivation.

â–¡

and E |= Î“ and E â€²
âŸ¦ğœ â€²

Lemma B.11 (Input Type Strengthening). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 and âŸ¦ğœ â€²

|= Î“â€² and Î“ âŠ† Î“â€² and E âŠ† E â€², then âˆƒğœ â€²

2.Î“â€² âŠ¢ ğ‘ : (ğ‘¥ : ğœ â€²

1) â†’ ğœ â€²

1âŸ§Eâ€² âŠ† âŸ¦ğœ1âŸ§E
2 and âˆ€â„â€² âˆˆ

2âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€² ]

1âŸ§Eâ€².âŸ¦ğœ â€²
Proof. By induction on a derivation of Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 with case analysis on the last rule

used. We refer to the proof goals as follows:

(1) âˆƒğœ â€²
(2) âˆ€â„â€² âˆˆ âŸ¦ğœ â€²

2.Î“â€² âŠ¢ ğ‘ : (ğ‘¥ : ğœ â€²
1âŸ§Eâ€².âŸ¦ğœ â€²
We refer to the assumptions as follows:

1) â†’ ğœ â€²
2
2âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€² ]

1âŸ§Eâ€² âŠ† âŸ¦ğœ1âŸ§E

(A) âŸ¦ğœ â€²
(B) E |= Î“
(C) E â€² |= Î“â€²

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:34

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

(D) Î“ âŠ† Î“â€²
(E) E âŠ† E â€²
Case T-Add:

By inversion of rule T-Add, we get

(A1) Excludes Î“ ğœ ğœ„ and
(A2) ğ‘–ğ‘›ğ‘–ğ‘¡ H T (ğœ„) = ğ‘£
(A3) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }.

2 = Î£ğ‘¦ : {ğ‘§ : ğœ â€²

Let ğœ â€²
(A) and (C) we can conclude that ExcludesÎ“â€² ğœ â€²
Let â„â€² âˆˆ âŸ¦ğœ â€²

1âŸ§Eâ€² be arbitrary.

1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }. By assumptions (A1),

1 ğœ„ must also hold. (1) follows by T-Add.

1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ†

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ â€²
âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§E [ğ‘¥â†¦â†’â„â€² ]
1 | ğ‘§ â‰¡ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âˆ§

â‡”{â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ â€²

â„2 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] } âŠ†

{â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„â€² ] âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] }

â‡”{â„â€² ++ â„2 | â„2 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„â€² ] } âŠ†
{â„â€² ++ â„2 | â„2 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„â€² ] }

The type {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ } does not contain any free variables, so the
2 and
semantics does not depend on the environment. In fact, the sets of heaps described by ğœ â€²
ğœ2 is actually equivalent, which shows (2).

Case T-Ascribe:

By inversion of rule T-Ascribe, we get

(A1) ğ‘ = ğ‘ğ‘ as (ğ‘¥ : ğœ1) â†’ ğœ2 and
(A2) Î“ âŠ¢ ğ‘ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2

From assumptions (A2) and (D) together with Lemma B.10 follows that

(A3) Î“â€² âŠ¢ ğ‘ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2

Since E â€² differs from E only in that it potentially contains additional bindings, we can
conclude that

(A4) âŸ¦ğœ1âŸ§E = âŸ¦ğœ1âŸ§Eâ€² and together with assumption (B)
(A5) Î“â€² âŠ¢ ğœ â€²

1 <: ğœ1.

By assumption (A3) and T-Ascribe we get

(A6) Î“â€² âŠ¢ ğ‘ğ‘ ğ‘ğ‘  (ğ‘¥ : ğœ1) â†’ ğœ2 : (ğ‘¥ : ğœ1) â†’ ğœ2

2 = ğœ2. (1) follows by T-Sub.
Let ğœ â€²
For (2), we have to show that âˆ€â„â€² âˆˆ âŸ¦ğœ â€²
1âŸ§Eâ€².âŸ¦ğœ2âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€² ]. In fact ğœ2 describes the
same set of heaps, both in E and E â€². Variable ğ‘¥ binds to the same heap and both environments
provide the same bindings for any other free variable in ğœ2.

Case T-Extract:

By inversion of rule T-Extract, we get

(A1) Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ1) â‰¥ sizeof (ğœ„)
(A2) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) |
ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }
Let ğœ â€²
ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }. By assumptions (A) and (A1) follows
that sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ â€²

2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ â€²

1) â‰¥ sizeof(ğœ„) (1) follows by T-Extract.

1, ğœ„, ğ‘¦) |

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:35

Let â„â€² âˆˆ âŸ¦ğœ â€²

1âŸ§Eâ€² be arbitrary.

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.

{ğ‘§ : chomp(ğœ â€²

1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ†

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.

{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„â€² ]

â‡”{â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’â„â€² ] âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : chomp(ğœ â€²

1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] } âŠ†

{â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’â„â€² ] âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] }
â‡”{â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’â„â€² ] âˆ§
1, ğœ„, ğ‘¦)âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] âˆ§

â„2 âˆˆ {â„22|â„22 âˆˆ âŸ¦chomp(ğœ â€²

âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1,ğ‘§â†¦â†’â„22 ] }} âŠ†
{â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’â„â€² ] âˆ§
â„2 âˆˆ {â„22|â„22 âˆˆ âŸ¦chomp(ğœ1, ğœ„, ğ‘¦)âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] âˆ§

âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1,ğ‘§â†¦â†’â„22 ] }}

1, ğœ„, ğ‘¦)âŸ§E [ğ‘¥â†¦â†’â„â€²,ğ‘¦â†¦â†’â„1 ] by taking
By Lemma B.20, we obtain all heaps contained in âŸ¦chomp(ğœ â€²
1âŸ§Eâ€² and removing the first sizeof (ğœ„) bits from the input packet. From
all heaps from âŸ¦ğœ â€²
assumption (A) we know that all heaps described by ğœ â€²
1 are also contained in the set of heaps
described by ğœ1 and when we remove the first sizeof (ğœ„) bits from the input packet, the relation
still holds. Since the rest of the types are identical this also holds for the concatenated heaps.
This shows (2) and concludes the case.

Case T-If:

By inversion of rule T-If, we get

(A1) Î“; ğœ1 âŠ¢ ğ‘’ : B
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ12
(A3) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ22
(A4) ğœ2 = {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | ğœ‘ [ğ‘¥/heap]}
(A5) ğ‘ = if (ğœ‘) then c1 else c2

To be able to conclude (1) by T-If, we must show that

(1.1) Î“â€²; ğœ â€²
1 âŠ¢ ğœ‘ : B
(1.2) Î“â€² âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ â€²
(1.3) Î“â€² âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ â€²

1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ â€²
12
1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ â€²
22

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:36

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

To apply the IH to ğ‘1, we need some ğœ â€²

ğ¼ğ»1

such that

âŸ¦ğœ â€²

ğ¼ğ»1âŸ§Eâ€² âŠ† âŸ¦{ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}âŸ§E

Let ğœ â€²
ğ¼ğ»1 = {ğ‘¦ : ğœ â€²
By IH, there exists ğœ â€²

1 | ğœ‘ [ğ‘¦/heap]}.
12 such that

(A6) Î“â€² âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ â€²
1 âˆˆ âŸ¦{ğ‘¦ : ğœ â€²
(A7) âˆ€â„â€²

1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ â€²
12
12âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²

1 | ğœ‘ [ğ‘¦/heap]}âŸ§Eâ€².âŸ¦ğœ â€²

1 ] âŠ† âŸ¦ğœ12âŸ§E [ğ‘¦â†¦â†’â„â€²
1 ]
With a similar argument as before, also by IH, there exists ğœ â€²
22 such that
1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ â€²
22
22âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²

(A8) Î“â€² âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ â€²
(A9) âˆ€â„â€²
2 âˆˆ âŸ¦{ğ‘¦ : ğœ â€²
1 âŠ¢ ğœ‘ : B also holds, because the subtyping relation between ğœ â€²

1 | Â¬ğœ‘ [ğ‘¦/heap]}âŸ§Eâ€².âŸ¦ğœ â€²

2 ] = âŸ¦ğœ22âŸ§E [ğ‘¦â†¦â†’â„â€²
2 ]

1 and ğœ1 ensures that heaps
1 have the same shape (i.e., the same instances are valid) and thus we can

Î“â€²; ğœ â€²
described by ğœ â€²
typecheck formula ğ‘’ in the context of type ğœ â€²
1.
(1) follows by T-If.
Let ğœ â€²
2 = {ğ‘¦ : ğœ â€²
12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ â€²
To show âˆ€â„â€²
1âŸ§Eâ€².âŸ¦{ğ‘¦ : ğœ â€²
ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]
Let â„â€²
or false.

1 âˆˆ âŸ¦ğœ â€²

1 âˆˆ âŸ¦ğœ â€²

22 | Â¬ğœ‘ [ğ‘¥/heap]}

12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

1 ] âŠ† âŸ¦{ğ‘¦ :

1âŸ§Eâ€² be arbitrary. Case distinction on wether the formula ğœ‘ in â„â€²

1 evaluates to true

Subcase ğ‘’ evaluates to true:

âŸ¦{ğ‘¦ : ğœ â€²
12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²
âŸ¦{ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

1 ] âŠ†

â‡”âŸ¦{ğ‘¦ : ğœ â€²

12 | true} + {ğ‘¦ : ğœ22 | false}âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²
âŸ¦{ğ‘¦ : ğœ12 | true} + {ğ‘¦ : ğœ22 | false}âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]
1 ] âŠ† âŸ¦ğœ12âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

12âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

â‡”âŸ¦ğœ â€²

1 ] âŠ†

The result follows by (A7).

Subcase ğ‘’ evaluates to false: Symmetric to previous subcase. The result follows by (A9).

Case T-Mod:
(A1) ğœ2 = {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}
(A2) Includes Î“ ğœ1 ğœ„
(A3) Î“; ğœ âŠ¢ ğ‘¡ : BV
(A4) F (ğœ„, ğ‘“ ) = BV
(A5) ğ‘ = ğœ„.ğ‘“ := ğ‘’

1) â†’ ğœ â€²

2 such that
2 and
1 ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

2âŸ§E [ğ‘¥â†¦â†’â„â€²

1âŸ§Eâ€².âŸ¦ğœ â€²

To show: There exists ğœ â€²
(1) Î“â€² âŠ¢ ğœ„.ğ‘“ := ğ‘’ : (ğ‘¥ : ğœ â€²
(2) âˆ€â„â€²
1 âˆˆ âŸ¦ğœ â€²
Let ğœ â€²
2 = ğœ2.
Includes Î“ ğœ â€²
know that ğœ â€²
expression ğ‘’ in context ğœ â€²
follows by T-Mod.

1 ğœ„ follows by assumptions (A2) and (A) and set theory. By assumption (A), we
1 has the same shape (contains the same instances) as ğœ1, so we can typecheck
1 with a bit vector type, from which follows that Î“â€²; ğœ â€²
1 âŠ¢ ğ‘’ : BV. (1)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:37

Let â„â€²

1 âˆˆ âŸ¦ğœ â€²

1âŸ§Eâ€² be arbitrary. To show (2), we must show that
1 ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

âŸ¦ğœ2âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

â‡”âŸ¦{ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘¡ [ğ‘¥/heap]}âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²
âŸ¦{ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘¡ [ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

1 ] âŠ†

Since the only free variable is ğ‘¥

â‡”âŸ¦{ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘¡ [ğ‘¥/heap]}âŸ§[ğ‘¥â†¦â†’â„â€²
âŸ¦{ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘¡ [ğ‘¥/heap]}âŸ§[ğ‘¥â†¦â†’â„â€²
1 ]

1 ] âŠ†

The result is immediate.

Case T-Remit:

By inversion of rule T-Remit, we get

(A1) Includes Î“ ğœ ğœ„
(A2) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}

1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}.

1 follows by assumptions (A1) and (A) and set theory. (1) follows by T-Remit.

2 = Î£ğ‘¦ : {ğ‘§ : ğœ â€²

Let ğœ â€²
Includesğœ„ Î“â€² ğœ â€²
Let â„ âˆˆ âŸ¦ğœ â€²

1âŸ§E be arbitrary.
âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§E [ğ‘¥â†¦â†’â„]
={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„]âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§E [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ] }

={â„ ++ â„2 | â„2 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§E [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„] }

ğ‘¥ is the only free variable in {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}, which maps to the same
heap â„ in both environments E [ğ‘¥ â†¦â†’ â„, ğ‘¦ â†¦â†’ â„] and E â€²[ğ‘¥ â†¦â†’ â„, ğ‘¦ â†¦â†’ â„].

={â„ ++ â„2 | â„2 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„] }
={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ â€²
1 | ğ‘§ â‰¡ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„]âˆ§

=âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ â€²

â„2 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ] }
1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§Eâ€² [ğ‘¥â†¦â†’â„]

This concludes the case by showing (2).

Case T-Reset:

By inversion of rule T-Reset, we get

(A1) ğ‘ = reset
(A2) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }
1 âˆˆ âŸ¦ğœ â€²

2 = ğœ2. (1) follows by T-Reset. Let â„â€²

Let ğœ â€²

1âŸ§Eâ€² be arbitrary.
âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.

{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

1 ] âŠ†

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.

{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

Both sets are actually equal, because ğ‘¥ is the only free variable in ğœ2 and ğœ â€²
2 respectively. Thus,
all other bindings in the environments E and E â€² have no effect on the semantics of ğœ2 and ğœ â€²
2
respectively. This shows (2) and concludes the case.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:38

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case T-Seq:

By inversion of rule T-Seq, we get

(A1) ğ‘ = ğ‘1; ğ‘2
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â†’ ğœ12
(A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â†’ ğœ22
(A4) ğœ2 = ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

By IH with (A2), (A), (B) and (C), there exists some ğœ â€²

12 such that

1âŸ§Eâ€² be arbitrary. By (A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â†’ ğœ22. By (A6), âŸ¦ğœ â€²
1 ]. E [ğ‘¥ â†¦â†’ â„â€²

1 ] âŠ†
1] |= Î“, ğ‘¥ : ğœ1 because by assumption E |= Î“ the entailment holds for
1 âˆˆ âŸ¦ğœ1âŸ§E (with assumption (A)) and the

12âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

1, we must show that âˆ€ğ‘¥ğ‘–, ğœğ‘– .Î“â€²(ğ‘¥ğ‘– ) = ğœğ‘– â‡’ E â€²[ğ‘¥ â†¦â†’
1 ] ğœğ‘– . Case ğ‘¥ğ‘– â‰  ğ‘¥: this holds by assumption (C). Case ğ‘¥ğ‘– = ğ‘¥.
1 ]. By assumption, ğ‘¥
1 âˆˆ âŸ¦ğœ â€²
1âŸ§Eâ€², which holds by assumption.

1 |=Eâ€² [ğ‘¥â†¦â†’â„â€²

1âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

1 âˆˆ âŸ¦ğœ â€²

1 â‡” â„â€²

(A5) Î“â€² âŠ¢ ğ‘1 : (ğ‘¥ : ğœ â€²
(A6) âˆ€â„â€²
1 âˆˆ âŸ¦ğœ â€²

1 ] âŠ† âŸ¦ğœ12âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

1) â†’ ğœ â€²
12
1âŸ§Eâ€².âŸ¦ğœ â€²
12âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²
Apply the IH again to ğ‘2:
Let â„â€²
1 âˆˆ âŸ¦ğœ â€²
âŸ¦ğœ12âŸ§E [ğ‘¥â†¦â†’â„â€²
all ğ‘¥ğ‘– â‰  ğ‘¥. For ğ‘¥ there exists a binding to heap â„â€²
entailment between â„ and ğœ1 trivially holds.
To show E â€²[ğ‘¥ â†¦â†’ â„â€²
â„â€²
1] (ğ‘¥ğ‘– ) = â„ğ‘– âˆ§ â„ğ‘–
E â€²[ğ‘¥ â†¦â†’ â„â€²
is not free in ğœ â€²
Again by IH, there exists some ğœ â€²

1 ] ğœ â€²
1, so we can equivalently show that â„â€²

|=E [ğ‘¥â†¦â†’â„â€²
1. To show that â„â€²

1] |= Î“â€², ğ‘¥ : ğœ â€²

1] (ğ‘¥) = â„â€²

22 such that

(A7) Î“â€², ğ‘¥ : ğœ â€²
(A8) âˆ€â„â€²

12 âˆˆ âŸ¦ğœ â€²
2 = ğœ â€²

1 âŠ¢ ğ‘2(ğ‘¦ : ğœ â€²
12âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²
Let ğœ â€²
22 [ğ‘¦ â†¦â†’ ğœ â€²
For (2), we must show that âˆ€â„â€²
Let â„â€²

12) â†’ ğœ â€²
22
1 ] .âŸ¦ğœ â€²
22âŸ§Eâ€² [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„â€²
12]. (1) follows by T-Seq.
1âŸ§Eâ€².âŸ¦ğœ â€²

1 âˆˆ âŸ¦ğœ â€²

12 ] âŠ† âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„â€²
12 ]

2âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

1 ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]

1âŸ§Eâ€² be arbitrary.
1 âˆˆ âŸ¦ğœ â€²
22 [ğ‘¦ â†¦â†’ ğœ â€²
âŸ¦ğœ â€²
(cid:216)

12]âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²
âŸ¦ğœ â€²

â‡”

1 ] âŠ† âŸ¦ğœ22 [ğ‘¦ â†¦â†’ ğœ12]âŸ§E [ğ‘¥â†¦â†’â„â€²
1 ]
12 ] âŠ†

1,ğ‘¦â†¦â†’â„â€²

(cid:216)

22âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€²

âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’â„â€²

1,ğ‘¦â†¦â†’â„12 ]

12 âˆˆâŸ¦ğœ â€²
â„â€²

12âŸ§Eâ€² [ğ‘¥ â†¦â†’â„â€²
1 ]
The result follows by (A6), (A8) and set theory.

â„12 âˆˆâŸ¦ğœ12âŸ§E [ğ‘¥ â†¦â†’â„â€²
1 ]

Case T-Skip:

By inversion of rule T-Skip, we get

(A1) ğ‘ = skip
(A2) ğœ2 = {ğ‘¦ : ğœ1 | ğ‘¦ â‰¡ ğ‘¥ }

2 = {ğ‘¦ : ğœ â€²

Let ğœ â€²
To show (2), let â„â€² âˆˆ âŸ¦ğœ â€²
âŸ¦{ğ‘¦ : ğœ â€²

1 | ğ‘¦ â‰¡ ğ‘¥ }. (1) follows by T-Skip.

1âŸ§Eâ€² be an arbitrary heap.

1 | ğ‘¦ â‰¡ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ† âŸ¦{ğ‘¦ : ğœ1 | ğ‘¦ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„â€² ]

â‡”{â„â€²} âŠ† âŸ¦{ğ‘¦ : ğœ1 | ğ‘¦ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’â„â€² ]
â‡”{â„â€²} âŠ† {â„â€²}

Case T-Sub:

By inversion of rule T-Sub, we get

(A1) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ3) â†’ ğœ4
(A2) Î“ âŠ¢ ğœ1 <: ğœ3
(A3) Î“, ğ‘¥ :ğœ1 âŠ¢ ğœ4 <: ğœ2

by (A)

By assumption âŸ¦ğœ â€²
âŸ¦ğœ3âŸ§E. By IH, there exists ğœ â€²

4 such that

(A4) Î“â€² âŠ¢ ğ‘ : (ğ‘¥ : ğœ â€²

1) â†’ ğœ â€²
4

1âŸ§Eâ€² âŠ† âŸ¦ğœ1âŸ§E and from (A2) follows that âŸ¦ğœ1âŸ§E âŠ† âŸ¦ğœ3âŸ§E and thus âŸ¦ğœ â€²

1âŸ§Eâ€² âŠ†

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:39

4âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ† âŸ¦ğœ4âŸ§E [ğ‘¥â†¦â†’â„â€² ]

(A5) âˆ€â„â€² âˆˆ âŸ¦ğœ â€²
1âŸ§Eâ€².âŸ¦ğœ â€²
4. (1) follows by (A4).
Let ğœ â€²
2 = ğœ â€²
For (1), we have to show that âˆ€â„â€² âˆˆ âŸ¦ğœ â€²
(A3) and (A5) and by set theory.

1âŸ§Eâ€².âŸ¦ğœ â€²

4âŸ§Eâ€² [ğ‘¥â†¦â†’â„â€² ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„â€² ], which follows by

â–¡

Lemma B.12 (Semantic Chomp Expression). For all expressions ğ‘’, heaps â„ and â„â€², environments
E and E â€² and variables ğ‘¥, if â„â€² = chompâ‡“ (â„, 1), and E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„
â†¦â†’ ğ‘£])] and, if
ğ‘¥ âˆˆ dom(E), ğ‘£ = E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = âŸ¨âŸ© and E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©, and
otherwise ğ‘£ = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and ğ‘¥ not free in ğ‘’, then
ğ‘’
1 (ğ‘’, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦ğ‘’âŸ§E [ğ‘¦â†¦â†’â„] = âŸ¦heapRef1(chomp

Proof. Proof by induction on ğ‘’. We only consider expressions referencing ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›. All other

expressions are not affected by chomping, and therefore the semantic is unchanged.
Case ğ‘’ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ]: Case distinction on ğ‘§ = ğ‘¦:

Subcase ğ‘§ â‰  ğ‘¦:

ğ‘’
1 (ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp

= âŸ¦heapRef1 (ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ], b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ]âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

If ğ‘§ â‰  ğ‘¥, ğ‘§ binds to some heap in E, which must also be contained in E â€² unchanged. If ğ‘§ = ğ‘¥,
by assumption, ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› maps to the empty bit vector, both in E and E â€².

= âŸ¦ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ]âŸ§E [ğ‘¦â†¦â†’â„]

Subcase ğ‘§ = ğ‘¦, ğ‘Ÿ â‰¤ 1:

ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 1], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 1], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦heapRef1(chomp
= âŸ¦heapRef1(b0 :: âŸ¨âŸ©, b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¥ .ğœ„ [sizeof (ğœ„) âˆ’ 1 : sizeof (ğœ„) âˆ’ 1 + 1]@âŸ¨âŸ©âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¥ .ğœ„ [|ğ‘£ | âˆ’ 1 : |ğ‘£ |]âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= E â€²(ğ‘¥)(ğœ„) [|ğ‘£ | âˆ’ 1]
= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]
= âŸ¦ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 : 1]âŸ§E [ğ‘¦â†¦â†’â„]

Subcase ğ‘§ = ğ‘¦, ğ‘™ = 0:

ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ ], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ ], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦heapRef1(chomp
= âŸ¦heapRef1(b0 :: ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ âˆ’ 1], b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¥ .ğœ„ [sizeof (ğœ„) âˆ’ 1 : sizeof(ğœ„) âˆ’ 1 + 1]@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ âˆ’ 1]âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¥ .ğœ„ [|ğ‘£ | âˆ’ 1 : |ğ‘£ |]@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ âˆ’ 1]âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= E â€²(ğ‘¥)(ğœ„) [|ğ‘£ | âˆ’ 1 : |ğ‘£ |]@â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘Ÿ âˆ’ 1]

with ğ‘£ = E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0] follows
= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]@â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘Ÿ âˆ’ 1]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:40

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

with â„â€² = chompâ‡“(â„, 1) follows

= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [1 :ğ‘Ÿ ]
= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘Ÿ ]
= âŸ¦ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [0 :ğ‘Ÿ ]âŸ§E [ğ‘¦â†¦â†’â„]

Subcase ğ‘§ = ğ‘¦, ğ‘™ â‰  0:

ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1 (chomp
ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦heapRef1 (chomp
= âŸ¦heapRef1(ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ âˆ’ 1 :ğ‘Ÿ âˆ’ 1], b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ âˆ’ 1 :ğ‘Ÿ âˆ’ 1]âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘™ âˆ’ 1 :ğ‘Ÿ âˆ’ 1]

with â„â€² = chompâ‡“(â„, 1) follows

= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘™ :ğ‘Ÿ ]
= âŸ¦ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› [ğ‘™ :ğ‘Ÿ ]âŸ§E [ğ‘¦â†¦â†’â„]

Case ğ‘’ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›: Case distinction on ğ‘§ = ğ‘¦:

Subcase ğ‘§ â‰  ğ‘¦: Symmetric to first subcase of previous case.

Subcase ğ‘§ = ğ‘¦:

ğ‘’
1 (ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp

= âŸ¦heapRef1(b0 :: ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›, b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¥ .ğœ„ [sizeof(ğœ„) âˆ’ 1 : sizeof (ğœ„) âˆ’ 1 + 1]@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘¥ .ğœ„ [|ğ‘£ | âˆ’ 1 : |ğ‘£ |]@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]@â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)

with â„â€² = chompâ‡“(â„, 1) follows

= â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)
= âŸ¦ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›âŸ§E [ğ‘¦â†¦â†’â„]

Case ğ‘’ = |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |: Case distinction on ğ‘§ = ğ‘¦:

Subcase ğ‘§ â‰  ğ‘¦:

ğ‘’
1 (|ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
= âŸ¦|ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

If ğ‘§ = ğ‘¥, the length of ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = 0 in both environments and otherwise, ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› refers to
the same heap in both E and E â€².
= âŸ¦|ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |âŸ§E [ğ‘¦â†¦â†’â„]

Subcase ğ‘§ = ğ‘¦:

ğ‘’
1 (|ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
= âŸ¦|ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | + 1âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:41

with â„â€² = chompâ‡“(â„, 1) follows
= âŸ¦|ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› |âŸ§E [ğ‘¦â†¦â†’â„]

Case ğ‘’ = ğ‘ :: ğ‘ğ‘£:

ğ‘’
1 (ğ‘ :: ğ‘ğ‘£, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
ğ‘’
1 (ğ‘ğ‘£, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦heapRef1(ğ‘ :: chomp
ğ‘’
= âŸ¦ğ‘ :: heapRef1(chomp
1 (ğ‘ğ‘£, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
ğ‘’
1 (ğ‘ğ‘£, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦ğ‘âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] :: âŸ¦heapRef1(chomp
= âŸ¦ğ‘âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] :: âŸ¦ğ‘ğ‘£âŸ§E [ğ‘¦â†¦â†’â„]

by IH follows

= âŸ¦ğ‘âŸ§E [ğ‘¦â†¦â†’â„] :: âŸ¦ğ‘ğ‘£âŸ§E [ğ‘¦â†¦â†’â„]

since ğ‘ is either 0 or 1

= âŸ¦ğ‘ :: ğ‘ğ‘£âŸ§E [ğ‘¦â†¦â†’â„]

Case ğ‘’ = ğ‘ğ‘£1@ğ‘ğ‘£2:

ğ‘’
1 (ğ‘ğ‘£1@ğ‘ğ‘£2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
ğ‘’
ğ‘’
1 (ğ‘ğ‘£1, ğ‘¦, b0)@chomp
1 (ğ‘ğ‘£2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦heapRef1(chomp
ğ‘’
1 (ğ‘ğ‘£1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]@
= âŸ¦heapRef1(chomp
ğ‘’
1 (ğ‘ğ‘£1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp

= âŸ¦ğ‘ğ‘£1âŸ§E [ğ‘¦â†¦â†’â„]@âŸ¦ğ‘ğ‘£2âŸ§E [ğ‘¦â†¦â†’â„]

by IH

= âŸ¦ğ‘ğ‘£1@ğ‘ğ‘£2âŸ§E [ğ‘¦â†¦â†’â„]

Case ğ‘’ = ğ‘› + ğ‘š: Symmetric to previous case.

Lemma B.13 (Semantic Chomp Formulae). For all formulae ğœ‘, heaps â„ and â„â€², environments
E and E â€² and variables ğ‘¥, if â„â€² = chompâ‡“ (â„, 1), and E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„
â†¦â†’ ğ‘£])], and if
ğ‘¥ âˆˆ dom, ğ‘£ = E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = âŸ¨âŸ© and E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ© and otherwise
ğ‘£ = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and ğ‘¥ not free in ğœ‘, then

ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦ğœ‘âŸ§E [ğ‘¦â†¦â†’â„] = âŸ¦heapRef1(chomp

Proof. By induction on ğœ‘.

â–¡

Case ğœ‘ = ğ‘’1 = ğ‘’2:

ğœ‘
1 (ğ‘’1 = ğ‘’2, ğ‘¦, b0), b0, ğ‘¥, ğœ„)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
ğœ‘
1 (ğ‘’1, ğ‘¦, b0), b0, ğ‘¥, ğœ„) =
= âŸ¦heapRef1(chomp
ğœ‘
1 (ğ‘’1, ğ‘¦, b0), b0, ğ‘¥, ğœ„)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
heapRef1(chomp
ğœ‘
1 (ğ‘’1, ğ‘¦, b0), b0, ğ‘¥, ğœ„)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] =
= âŸ¦heapRef1(chomp
ğœ‘
1 (ğ‘’1, ğ‘¦, b0), b0, ğ‘¥, ğœ„)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:42

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

by Lemma B.12 follows

= âŸ¦ğ‘’1âŸ§E [ğ‘¦â†¦â†’â„] = âŸ¦ğ‘’2âŸ§E [ğ‘¦â†¦â†’â„]
= âŸ¦ğ‘’1 = ğ‘’2âŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ‘ = ğœ‘1 âˆ§ ğœ‘2:

ğœ‘
1 (ğœ‘1 âˆ§ ğœ‘2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1(chomp
ğœ‘
1 (ğœ‘1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âˆ§
= âŸ¦heapRef1(chomp
ğœ‘
1 (ğœ‘2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
heapRef1(chomp
ğœ‘
1 (ğœ‘1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]âˆ§
= âŸ¦heapRef1(chomp
ğœ‘
1 (ğœ‘2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1 (chomp

by IH follows

Case ğœ‘ = Â¬ğœ‘1:

by IH follows

= âŸ¦ğœ‘1âŸ§E [ğ‘¦â†¦â†’â„] âˆ§ âŸ¦ğœ‘2âŸ§E [ğ‘¦â†¦â†’â„]
= âŸ¦ğœ‘1 âˆ§ ğœ‘2âŸ§E [ğ‘¦â†¦â†’â„]

ğœ‘
1 (Â¬ğœ‘1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„]
âŸ¦heapRef1(chomp
ğœ‘
1 (ğœ‘1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„]
= âŸ¦Â¬heapRef1(chomp
ğœ‘
1 (ğœ‘1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„]
= Â¬âŸ¦heapRef1(chomp

= Â¬âŸ¦ğœ‘âŸ§E [ğ‘¦â†¦â†’â„]
= âŸ¦Â¬ğœ‘âŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ‘ = ğ‘§.ğœ„ â€².ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘:

ğœ‘
1 (ğ‘§.ğœ„ â€².ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦heapRef1 (chomp
= âŸ¦ğ‘§.ğœ„ â€².ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= ğœ„ â€² âˆˆ ğ‘‘ğ‘œğ‘š(E â€²[ğ‘¦ â†¦â†’ â„â€²] (ğ‘§))
= ğœ„ â€² âˆˆ ğ‘‘ğ‘œğ‘š(E [ğ‘¦ â†¦â†’ â„] (ğ‘§))

by definition of E â€² and â„â€² follows
= âŸ¦ğ‘§.ğœ„ â€².ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘âŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ‘ = true:

ğœ‘
1 (true, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„]
âŸ¦heapRef1(chomp

= âŸ¦trueâŸ§Eâ€² [ğ‘¦â†¦â†’â„]
= true
= âŸ¦trueâŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ‘ = false: Symmetric to previous case.

â–¡

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:43

Lemma B.14 (Semantic Chomp Refinement). For all heap types ğœ, heaps â„ and â„â€², environments
E and E â€² and variables ğ‘¥, if â„â€² = chompâ‡“(â„, 1), and E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„
â†¦â†’ ğ‘£])], and, if
ğ‘¥ âˆˆ dom, ğ‘£ = E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = âŸ¨âŸ© and E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©, and otherwise
ğ‘£ = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and ğ‘¥ not free in ğœ, then

âŸ¦ğœâŸ§E [ğ‘¦â†¦â†’â„] = âŸ¦heapRef1(chompRef1(ğœ, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

Proof. Proof by induction on ğœ.

Case ğœ = âˆ…:

âŸ¦heapRef1(chompRef1(âˆ…, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦âˆ…âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= {}
= âŸ¦ğœâŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ = âŠ¤:

âŸ¦heapRef1(chompRef1(âŠ¤, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦âŠ¤âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= ğ»
= âŸ¦âŠ¤âŸ§E

Case ğœ = Î£ğ‘§ : ğœ1.ğœ2:

âŸ¦heapRef1(chompRef1(Î£ğ‘§ : ğœ1.ğœ2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦Î£ğ‘§ : heapRef1(chompRef1(ğœ1, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1).

heapRef1(chompRef1(ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= {â„â€²

1 ++ â„â€²

2 | â„â€²
1 âˆˆ âŸ¦heapRef1(chompRef1(ğœ1, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] âˆ§
â„â€²
2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²,ğ‘§â†¦â†’â„â€²
1 âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¦â†¦â†’â„] âˆ§ â„â€²
2 | â„â€²
2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¦â†¦â†’â„,ğ‘§â†¦â†’â„â€²

1 ] }

1 ] }

1 ++ â„â€²

= {â„â€²
= âŸ¦Î£ğ‘§ : ğœ1.ğœ2âŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ = ğœ1 + ğœ2:

âŸ¦heapRef1(chompRef1(ğœ1 + ğœ2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦heapRef1(chompRef1(ğœ1, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1) +

heapRef1(chompRef1(ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
= âŸ¦heapRef1(chompRef1(ğœ1, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] âˆª
âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦ğœ1âŸ§E [ğ‘¦â†¦â†’â„] âˆª âŸ¦ğœ1âŸ§E [ğ‘¦â†¦â†’â„]
= âŸ¦ğœ1 + ğœ2âŸ§E [ğ‘¦â†¦â†’â„]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:44

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case ğœ = {ğ‘§ : ğœ1 | ğœ‘ }:

âŸ¦heapRef1(chompRef1({ğ‘§ : ğœ1 | ğœ‘ }, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦{ğ‘§ : heapRef1(chompRef1(ğœ1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1) |
ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)}âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
heapRef1(chomp

= {â„ | â„ âˆˆ âŸ¦heapRef1(chompRef1 (ğœ1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] âˆ§

ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] = true}
âŸ¦heapRef1(chomp

= {â„ | â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¦â†¦â†’â„] âˆ§ âŸ¦ğœ‘âŸ§E [ğ‘¦â†¦â†’â„] = true}
= âŸ¦{ğ‘§ : ğœ1 | ğœ‘ }âŸ§E [ğ‘¦â†¦â†’â„]

Case ğœ = ğœ1 [ğ‘§ â†¦â†’ ğœ2]:

âŸ¦heapRef1(chompRef1(ğœ1 [ğ‘§ â†¦â†’ ğœ2], ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= âŸ¦heapRef1(chompRef1(ğœ1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1) [ğ‘§ â†¦â†’

heapRef1(chompRef1(ğœ2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)]âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]

= {â„ | â„2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]âˆ§

â„ âˆˆ âŸ¦heapRef1 (chompRef1(ğœ1, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²,ğ‘§â†¦â†’â„2 ] }

= {â„ | â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¦â†¦â†’â„] âˆ§ â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¦â†¦â†’â„,ğ‘§â†¦â†’â„2 ] }
= âŸ¦ğœ1 [ğ‘§ â†¦â†’ ğœ2]âŸ§E [ğ‘¦â†¦â†’â„]

â–¡

Lemma B.15 (Semantic Chomp1). For all heap types ğœ, environments E and E â€², and variables
â†¦â†’ ğ‘£])], and if ğ‘¥ âˆˆ dom(E), ğ‘£ = E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and
ğ‘¥, if E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„
E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©, otherwise ğ‘£ = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1], then âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ 1 =â‡’
âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, 1, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“(â„, 1)

Proof.

âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ 1 =â‡’ âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, 1, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“ (â„, 1)

â‡” (By definition of chompRec)
âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ 1 =â‡’

âˆƒâ„â€² âˆˆ âŸ¦heapRef1(chomp1(ğœ, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€².â„â€² = chompâ‡“(â„, 1)

Proof by induction on ğœ.
Case ğœ = âˆ…: âŸ¦âˆ…âŸ§E = {}. As there are no heaps in the semantics, the case holds.
Case ğœ = âŠ¤: Let â„ be some heap from âŸ¦âŠ¤âŸ§E = ğ» . Let â„â€² = â„ except that â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [1 : ].
By definition of chomp1 and heapRef1, heapRef1(chomp1(âŠ¤, b0), b0, ğ‘¥, ğœ„, 1) = âŠ¤ and âŸ¦âŠ¤âŸ§Eâ€² =
ğ» .
We can conclude that â„â€² âˆˆ âŸ¦heapRef1(chomp1(âŠ¤, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² and â„â€² = chompâ‡“(â„, 1)
follows by construction of â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [1 : ].

Case ğœ = Î£ğ‘¦ : ğœ1.ğœ2: Let â„ be some heap from âŸ¦Î£ğ‘¦ : ğœ1.ğœ2âŸ§E. We know â„ = â„1 ++ â„2, for some

â„1 âˆˆ âŸ¦ğœ1âŸ§E and some â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¦â†¦â†’â„1].
We have to show that there exists some

â„â€² âˆˆ âŸ¦heapRef1(chomp1(Î£ğ‘¦ : ğœ1.ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

such that â„â€² = chompâ‡“(â„, 1).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:45

We deconstruct âŸ¦heapRef1(chomp1(ğœ, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²:

âŸ¦heapRef1 (chomp1(Î£ğ‘¦ : ğœ1.ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦heapRef1 (Î£ğ‘¦ : chomp1(ğœ1, b0).chompRef1(ğœ2, ğ‘¦, b0) +

Î£ğ‘¦ : {ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}.chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦Î£ğ‘¦ : heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1).

heapRef1(chompRef1(ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1) +
Î£ğ‘¦ : heapRef1({ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}, b0, ğ‘¥, ğœ„, 1).
heapRef1(chomp1 (ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦Î£ğ‘¦ : heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1).

heapRef1(chompRef1 (ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² âˆª

= {â„â€²

1 ++ â„â€²

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}.heapRef1(chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
2|â„â€²
1 âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² âˆ§
â„â€²
2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0))âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²
2|â„â€²
1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€² âˆ§
â„â€²
2 âˆˆ âŸ¦heapRef1(chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²

1 ++ â„â€²

1 ] } âˆª

{â„â€²

1 ] }

By case distinction on the length of ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› in â„1.
Subcase |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| = 0:

By definition of E â€², âŸ¦ğœ1âŸ§E = âŸ¦ğœ1âŸ§Eâ€², because, ğœ1 canâ€™t contain a reference to the newly
added bit in E â€²(ğ‘¥)(ğœ„), from which follows that â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€².
By semantics of heap types, â„1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€².
By IH there exists

â„â€²
2 âˆˆ âŸ¦heapRef1(chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ]

2 = chompâ‡“(â„2, 1).

such that â„â€²
Let â„â€² = â„1 ++ â„â€²
2.
We conclude that

â„â€² âˆˆ {â„â€²

1 ++ â„â€²

2|â„â€²
1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€² âˆ§
â„â€²
2 âˆˆ âŸ¦heapRef1(chomp1 (ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²

1 ] }

and thus â„â€² âˆˆ âŸ¦heapRef1(chomp1(Î£ğ‘¦ : ğœ1.ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€².
By assumption |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| = 0, we can conclude that

â„1 ++ chompâ‡“ (â„2, 1) = chompâ‡“(â„1 ++ â„2, 1)

thus

â„â€² = â„1 ++ â„â€²
2
= â„1 ++ chompâ‡“(â„2, 1)
= chompâ‡“ (â„1 ++ â„2, 1)
= chompâ‡“ (â„, 1)

Subcase |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰  0:
By IH there exists â„â€²
1 = chompâ‡“(â„1, 1).
â„â€²

1 âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€², such that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:46

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By Lemma B.14 follows that

â„2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²
1 ]

Let â„â€² = â„â€²
1 ++ â„2.
We conclude that

â„â€² âˆˆ {â„â€²

1 ++ â„2|â„â€²

1 âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² âˆ§
â„2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0))âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²

1 ] }

and thus â„â€² âˆˆ âŸ¦heapRef1(chomp1(Î£ğ‘¦ : ğœ1.ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€².
With

â„â€² = â„â€²

1 ++ â„2

= chompâ‡“ (â„1, 1) ++ â„2
= chompâ‡“ (â„1 ++ â„2, 1)
= chompâ‡“ (â„, 1)

we can conclude this case.

Case ğœ = ğœ1 + ğœ2:

Let â„ be some heap from âŸ¦ğœ1 + ğœ2âŸ§E. By the semantics of heap types, we know â„ âˆˆ âŸ¦ğœ1âŸ§E or
â„ âˆˆ âŸ¦ğœ2âŸ§E.
Subcase â„ âˆˆ âŸ¦ğœ1âŸ§E:

By IH we know that there exists

â„â€² âˆˆ âŸ¦heapRef1(chomp1 (ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

such that â„â€² = chompâ‡“(â„, 1).
By set theory and

âŸ¦heapRef1(chomp1(ğœ1 + ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦heapRef1(chomp1(ğœ1, b0) + chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1) +
heapRef1(chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² âˆª
âŸ¦heapRef1(chomp1(ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

we conclude â„â€² âˆˆ âŸ¦heapRef1(chomp1(ğœ1 + ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€².

Subcase â„ âˆˆ âŸ¦ğœ2âŸ§E: Symmetric to previous subcase.

Case ğœ = {ğ‘¦ : ğœ1 | ğœ‘ }:

Let â„ be some heap from âŸ¦{ğ‘¦ : ğœ1 | ğœ‘ }âŸ§E.
By the semantics of heap types, we know that â„ âˆˆ âŸ¦ğœ1âŸ§E and âŸ¦ğœ‘âŸ§E [ğ‘¦â†¦â†’â„] = true. By
induction hypothesis there exists â„â€² âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² such that
â„â€² = chompâ‡“(â„, 1).
By Lemma B.13 we know that

ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ]
âŸ¦ğœ‘âŸ§E [ğ‘¦â†¦â†’â„] = âŸ¦heapRef1(chomp

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:47

To apply Lemma B.13, we must show that ğ‘¥ is not free in ğœ‘, if ğ‘¥ âˆ‰ dom(E). If this does not
hold, there is no â„ âˆˆ âŸ¦ğœâŸ§E, which violates our initial assumption. With
âŸ¦heapRef1(chomp1({ğ‘¦ : ğœ1 | ğœ‘ }, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

ğœ‘
= âŸ¦heapRef1({ğ‘¦ : chomp1(ğœ1, b0) | chomp
1 (ğœ‘, ğ‘¦, b0)}, b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦{ğ‘¦ : heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1) |

ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)}âŸ§Eâ€²
heapRef1(chomp

= {â„|â„ âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² âˆ§

ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„] }
âŸ¦heapRef1(chomp

and with our assumptions from Lemma B.13 and the induction hypothesis, we conclude that
â„â€² âˆˆ âŸ¦heapRef1(chomp1({ğ‘¦ : ğœ1 | ğœ‘ }, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² such that â„â€² = chompâ‡“ (â„, 1).

Case ğœ = ğœ1 [ğ‘¦ â†¦â†’ ğœ2]:

Let â„ be some heap from âŸ¦ğœ1 [ğ‘¦ â†¦â†’ ğœ2]âŸ§E. We know that â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¦â†¦â†’â„2 ] for some â„2 âˆˆ âŸ¦ğœ2âŸ§E.
By IH there exists some â„â€² âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„2 ] such that â„â€² =
chompâ‡“(â„, 1).
To conclude this case, we must show that

â„â€² âˆˆ âŸ¦heapRef1 (chomp1(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

From heapRef1, chomp1 and the semantics of heap types, we get:
âŸ¦heapRef1(chomp1(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0) [ğ‘¦ â†¦â†’ ğœ2], b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1) [ğ‘¦ â†¦â†’ ğœ2]âŸ§Eâ€²
= {â„11|â„22 âˆˆ âŸ¦ğœ2âŸ§Eâ€² âˆ§ â„11 âˆˆ âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„22 ] }

With â„11 = â„â€² and â„22 = â„2, we can conclude that

â„â€² âˆˆ âŸ¦heapRef1(chomp1(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
To argue that â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€², we make a case distinction on ğ‘¥ âˆˆ dom(E).
Subcase ğ‘¥ âˆ‰ dom(E): ğ‘¥ cannot appear free in ğœ and thereby also not in ğœ2, otherwise there

would be no â„ âˆˆ âŸ¦ğœâŸ§E, thus for all â„2 âˆˆ âŸ¦ğœ2âŸ§E, â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€².

Subcase ğ‘¥ âˆˆ dom(E): By assumption, there is some â„2 âˆˆ âŸ¦ğœ2âŸ§E. By semantics of heap types,
all formulae in ğœ2 referencing ğ‘¥, evaluate to true, i.e., they only refer to information contained
in E (ğ‘¥). By assumption, E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = E â€²(ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›), E (ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = E â€²(ğ‘¥)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ), and
E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] = E â€²(ğ‘¥)(ğœ„). Since all information of E (ğ‘¥) is preserved in E â€²,
â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€².

â–¡

Lemma B.16 (ChompRec Unroll). For all instances ğœ„, if ğ‘š + 1 â‰¤ sizeof (ğœ„), then
chompRec(chompRec(ğœ, ğ‘š, ğ‘¥, ğœ„), 1, ğ‘¥, ğœ„) = chompRec(ğœ, ğ‘š + 1, ğ‘¥, ğœ„)

Proof. By induction on ğ‘›.

Case ğ‘› = 0:

chompRec(chompRec(ğœ, 0, ğ‘¥, ğœ„), 1, ğ‘¥, ğœ„)

= chompRec(ğœ, 1, ğ‘¥, ğœ„)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:48

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case ğ‘› = 1:

chompRec(chompRec(ğœ, 1, ğ‘¥, ğœ„), 1, ğ‘¥, ğœ„)

= chompRec(chompRec(heapRef1(chomp1(ğœ, b0), b0, ğœ„, 1), 0, ğ‘¥, ğœ„), 1, ğ‘¥, ğœ„)
= chompRec(heapRef1(chomp1(ğœ, b0), b0, ğœ„, 1), 1, ğ‘¥, ğœ„)
= chompRec(ğœ, 2, ğ‘¥, ğœ„)

Case ğ‘› = ğ‘š:

We assume that the lemma holds for ğ‘› = ğ‘š. We now have to show that the lemma also holds
for ğ‘› = ğ‘š + 1.

chompRec(chompRec(ğœ, ğ‘š + 1, ğ‘¥, ğœ„), 1, ğ‘¥, ğœ„)

= chompRec(chompRec(heapRef1(chomp1(ğœ, b0), b0, ğœ„, ğ‘š + 1), ğ‘š, ğ‘¥, ğœ„),

1, ğ‘¥, ğœ„)

= chompRec(heapRef1(chomp1(ğœ, b0), b0, ğœ„, ğ‘š + 1), ğ‘š + 1, ğ‘¥, ğœ„)
= chompRec(ğœ, ğ‘š + 2, ğ‘¥, ğœ„)

Lemma B.17 (Semantic Chomp Unroll). For all heaps â„ and all ğ‘› âˆˆ N, if |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘› + 1, then

â–¡

chompâ‡“(chompâ‡“(â„, ğ‘›), 1) = chompâ‡“(â„, ğ‘› + 1)

Proof. By definition of chompâ‡“,

chompâ‡“(chompâ‡“(â„, ğ‘›), 1)

= â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› :]] [ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› :]] (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [1 :]]
= â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› :]] (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [1 :]]
= â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› + 1 :]]
= chompâ‡“(â„, ğ‘› + 1)

â–¡

Lemma B.18 (Chomp Slice). For all heaps â„ and all ğ‘› âˆˆ N, if |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘› + 1, then

chompâ‡“ (â„, ğ‘›)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› :ğ‘› + 1]

Proof. By definition of chompâ‡“,

chompâ‡“(â„, ğ‘›)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] = â„[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [ğ‘› :]] (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

Let ğ‘ğ‘£ = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = âŸ¨ğ‘0, ..., ğ‘ğ‘›, ..., ğ‘ğ‘šâŸ©.
Let ğ‘ğ‘£ â€² be the bit vector we obtain after removing the first ğ‘› bits from ğ‘ğ‘£ â€², ğ‘ğ‘£ â€² = âŸ¨ğ‘ğ‘›, ..., ğ‘ğ‘šâŸ©.
Accessing the first bit of ğ‘ğ‘£ â€² gives us bit ğ‘ğ‘›, which is also the n-th bit in ğ‘ğ‘£, i.e., ğ‘ğ‘£ [ğ‘› :ğ‘› + 1]. â–¡

Lemma B.19 (Semantic ChompRec). Fix overflow For all heap types ğœ, environments E and E â€²,
variables ğ‘¥ and ğ‘› âˆˆ N, if ğ‘¥ does not appear free in ğœ, and E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘›]])],
then âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘› =â‡’ âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘›, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“(â„, ğ‘›).

Proof. Proof by induction on ğ‘›.

Case ğ‘› = 0:

âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ 0 =â‡’ âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, 0, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“ (â„, 0)

â‡” âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .âˆƒâ„â€² âˆˆ âŸ¦ğœâŸ§Eâ€².â„â€² = â„

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:49

Let â„â€² = â„, i.e., we have to show that â„ âˆˆ âŸ¦ğœâŸ§Eâ€². By assumption, ğ‘¥ is not free in ğœ, i.e., the
binding of ğ‘¥ in E â€² has no effect on the semantics of ğœ. Since E and E â€² are otherwise identical,
ğœ evaluated in both environments is described by the same set of heaps, from which we can
conclude that â„ âˆˆ âŸ¦ğœâŸ§Eâ€².
Case ğ‘› = 1:

âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ 1 =â‡’ âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, 1, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“ (â„, 1)

The result directly follows by Lemma B.15.

Case ğ‘› = ğ‘š + 1:

We assume that the lemma holds for ğ‘› = ğ‘š, i.e.,
âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘š =â‡’ âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“(â„, ğ‘š)
We have to show that the lemma also holds for ğ‘› = ğ‘š + 1, i.e.,

âˆ€â„ âˆˆ âŸ¦ğœâŸ§E .|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘š + 1 =â‡’ âˆƒâ„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘š + 1, ğœ„, ğ‘¥)âŸ§Eâ€².â„â€² = chompâ‡“(â„, ğ‘š + 1)

0

, such that â„â€² =

0 = E0 [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘š]])]. We use (A) to refer to this assumption.
1 such
â†¦â†’

where E â€² = E [ğ‘¥ â†¦â†’ [ğœ„ â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘š + 1], ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ âŸ¨âŸ©, ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ â†¦â†’ âŸ¨âŸ©]].
Let â„ be some heap â„ âˆˆ âŸ¦ğœâŸ§E0.
By induction hypothesis, there exists some â„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥)âŸ§Eâ€²
chompâ‡“(â„, ğ‘š).
Let E1 = E â€²
By Lemma B.15, for all â„1 âˆˆ âŸ¦chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥)âŸ§E1, there exists some heap â„â€²
1 âˆˆ âŸ¦chompRec(chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥), 1, ğœ„, ğ‘¥)âŸ§Eâ€²
that â„â€²
1 = chompâ‡“ (â„1, 1).
E1(ğ‘¥)(ğœ„)@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]])], and â„â€²
Since, by assumption, â„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥)âŸ§Eâ€²
be equal to â„â€², i.e., â„â€²
From â„â€² = chompâ‡“ (â„, ğ‘š) follows â„â€²
From Lemma B.17 also follows that â„â€²
We must show that â„â€²
We know that

1 = chompâ‡“(chompâ‡“(â„, ğ‘š), 1).
1 = chompâ‡“(â„, ğ‘š + 1).

1 âˆˆ âŸ¦chompRec(ğœ, ğ‘š + 1, ğœ„, ğ‘¥)âŸ§Eâ€².

1 = E1 [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„

0, we can define â„1 to

1 = chompâ‡“(â„â€², 1).

and also E1 = E â€²

and E â€²

0

1

â„â€²
1 âˆˆ âŸ¦chompRec(chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥), 1, ğœ„, ğ‘¥)âŸ§Eâ€²

1

1.
, so we must show that E â€² = E â€²

â†¦â†’ E1(ğ‘¥)(ğœ„)@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]])], where â„1 =

1 = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :

1

1 = E1 [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„

1 âˆˆ âŸ¦chompRec(ğœ, ğ‘š + 1, ğœ„, ğ‘¥)âŸ§Eâ€²

and by Lemma B.16, â„â€²
By assumption, E â€²
chompâ‡“(â„, ğ‘š) (by IH).
Also by assumption, E (ğ‘¥)(ğœ„) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : ğ‘š], i.e., E â€²
ğ‘š]@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]])].
Again, substituting â„1 with â„â€², and by â„â€² = chompâ‡“(â„, ğ‘š), we obtain E â€²
â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘š]@chompâ‡“(â„, ğ‘š)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]])].
By Lemma B.18 and by definition of bit vector concatenation, E â€²
â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 :ğ‘š + 1]])] = E â€².

1 = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’

1 = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’

Lemma B.20 (Semantic Chomp). If ğ‘¥ does not appear free in ğœ, then forall heaps â„ âˆˆ âŸ¦ğœâŸ§E where
|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ sizeof(ğœ„), there exists â„â€² âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¥)âŸ§Eâ€² such that â„â€² = chompâ‡“(â„, sizeof (ğœ„))
where E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof(ğœ„)]])].

Proof. By definition of chomp, we know that

chomp(ğœ, ğœ„, ğ‘¥) = chompRec(ğœ, sizeof (ğœ„), ğ‘¥, ğœ„)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

â–¡

40:50

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

The result follows from Lemma B.19.

â–¡

Lemma B.21 (Semantic Chomp1 Inverse). For all ğ‘¥, ğ‘£, ğœ, E â€² and â„â€² such that E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’
ğ‘£]) and â„â€² âˆˆ âŸ¦chompRec(ğœ, 1, ğ‘¥, ğœ„)âŸ§Eâ€² and ğ‘¥ not free in ğœ and sizeof (ğ‘£) â‰¥ 1, there exists â„ and E such
that,

(1) â„ âˆˆ âŸ¦ğœâŸ§E and
(2) â„â€² = chompâ‡“(â„, 1) and

and

(3) E = E â€² \ ğ‘¥ and
(4) ğ‘£ = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

or

(3) ğ‘¥ âˆˆ dom(E) and
(4) ğ‘£ = E (ğ‘¥)(ğœ„)@â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] and
(5) E = E â€²[ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof (ğ‘£) âˆ’ 1]])]

Proof. We refer to the general assumptions as follows:
(A) E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£])
(B) â„â€² âˆˆ âŸ¦chompRec(ğœ, 1, ğ‘¥, ğœ„)âŸ§Eâ€² and
(C) ğ‘¥ not free in ğœ and
(D) sizeof(ğ‘£) â‰¥ 1
Proof by induction on ğœ. By definition of chompRec follows that

âŸ¦chompRec(ğœ, 1, ğ‘¥, ğœ„)âŸ§E = âŸ¦heapRef1(chomp1(ğœ, b0), b0, ğ‘¥, ğœ„, 1)âŸ§E

Case ğœ = âˆ…:

âŸ¦heapRef1(chomp1(âˆ…, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦heapRef1(âˆ…, b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦âˆ…âŸ§Eâ€²
= {}

As there is no â„â€² âˆˆ âŸ¦chompRec(ğœ, 1, ğœ„, ğ‘¥)âŸ§Eâ€², this case is immediate.
Case ğœ = âŠ¤:

âŸ¦heapRef1(chomp1(âŠ¤, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦heapRef1(âŠ¤, b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦âŠ¤âŸ§Eâ€²
= H
Let E â€² where E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) be arbitrary.
Let â„â€² âˆˆ âŸ¦chompRec(âŠ¤, 1, ğœ„, ğ‘¥)âŸ§Eâ€² = H be arbitrary. We have to distinguish two cases.
Subcase sizeof(ğ‘£) = 1:

Let E = E â€² \ ğ‘¥ and let â„ = â„â€²[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ ğ‘£@â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)], i.e., â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1] = ğ‘£. (1) follows by
the semantics of heap types. (2) follows by the definition of chompâ‡“. (3) and (4) immediately
follow from the definition of â„ and E.

Subcase sizeof(ğ‘£) > 1:

Let E = E â€²[ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof(ğ‘£) âˆ’ 1]])] and let â„ = â„â€²[ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› â†¦â†’ ğ‘£ [sizeof (ğ‘£) âˆ’
1 : sizeof (ğ‘£)]@â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)]. (1) follows by the semantics of heap types. (2) follows by the
definition of chompâ‡“ (3) and (4) immediately follow from the definition of â„ and E

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:51

Case ğœ = ğœ1 + ğœ2: Let E â€² where E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) be arbitrary.

Let â„â€² âˆˆ âŸ¦chompRec(ğœ1 + ğœ2, 1, ğœ„, ğ‘¥)âŸ§Eâ€² be arbitrary.

âŸ¦chompRec(ğœ1 + ğœ2, 1, ğœ„, ğ‘¥)âŸ§Eâ€²

= âŸ¦heapRef1(chomp1(ğœ1 + ğœ2, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² âˆª
âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²

= âŸ¦chompRec(ğœ1, 1, ğ‘¥ğœ„)âŸ§Eâ€² âˆª âŸ¦chompRec(ğœ2, 1, ğ‘¥ğœ„)âŸ§Eâ€²

We have to distinguish two cases,
(1) â„â€² âˆˆ âŸ¦chompRec(ğœ1, 1, ğ‘¥, ğœ„)âŸ§Eâ€² and
(2) â„â€² âˆˆ âŸ¦chompRec(ğœ2, 1, ğ‘¥ğœ„)âŸ§Eâ€².
Subcase â„â€² âˆˆ âŸ¦chompRec(ğœ1, 1, ğ‘¥ğœ„)âŸ§Eâ€²: We further distinguish between the size of ğ‘£.

Subcase sizeof(ğ‘£) = 1:

By IH, there exists â„1, E1, such that

(A1) â„1 âˆˆ âŸ¦ğœ1âŸ§E1
(A2) â„â€² = chompâ‡“(â„1, 1)
(A3) E1 = E â€² \ ğ‘¥
(A4) ğ‘£ = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

Let â„ = â„1 and E = E1. â„ âˆˆ âŸ¦ğœ1 + ğœ2âŸ§E follows from the semantics of heap types and by
(A1). The rest is immediate.

Subcase sizeof(ğ‘£) > 1: By IH, there exists â„1, E1, such that

(A1) â„1 âˆˆ âŸ¦ğœ1âŸ§E1
(A2) â„â€² = chompâ‡“(â„1, 1)
(A3) E1 = E â€²[ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof (ğ‘£) âˆ’ 1]])]
(A4) ğ‘£ = E (ğ‘¥)(ğœ„)@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

Let â„ = â„1 and E = E1. â„ âˆˆ âŸ¦ğœ1 + ğœ2âŸ§E follows from the semantics of heap types and by
(A1). The rest is immediate.

Subcase â„â€² âˆˆ âŸ¦chompRec(ğœ2, 1, ğ‘¥, ğœ„)âŸ§Eâ€²:

Symmetric to previous subcase.

Case ğœ = Î£ğ‘¦ : ğœ1.ğœ2: Let E â€² where E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) be arbitrary. Let â„â€² âˆˆ âŸ¦chompRec(Î£ğ‘¦ :

ğœ1.ğœ2, 1, ğœ„, ğ‘¥)âŸ§Eâ€² be arbitrary.

âŸ¦chompRec(Î£ğ‘¦ : ğœ1.ğœ2, 1, ğœ„, ğ‘¥)âŸ§Eâ€²

= {â„â€²

1 ++ â„â€²

{â„â€²

1 ++ â„â€²

2|â„â€²
1 âˆˆ âŸ¦chompRec(ğœ1, 1, ğœ„, ğ‘¥)âŸ§Eâ€² âˆ§
â„â€²
2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0))âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²
2|â„â€²
1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€²âˆ§
â„â€²
2 âˆˆ âŸ¦chompRec(ğœ2, 1, ğœ„, ğ‘¥)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²

1 ] }

1 ] } âˆª

Case distinction on the membership of â„â€².
Subcase â„â€² contained in the first subset:

1 ++ â„â€²

2 and

(A1) â„â€² = â„â€²
(A2) â„â€²
(A3) â„â€²

1 âˆˆ âŸ¦chompRec(ğœ1, 1, ğœ„, ğ‘¥)âŸ§Eâ€² and
2 âˆˆ âŸ¦heapRef1(chompRef1(ğœ2, ğ‘¥, b0))âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²
We distinguish two additional cases.
Subcase sizeof (ğ‘£) = 1: By IH, there exists â„1, E1, such that

1 ].

(A4) â„1 âˆˆ âŸ¦ğœ1âŸ§E1

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:52

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1 ++ â„â€²

1 = chompâ‡“(â„1, 1)

2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ]. Since â„â€²

(A5) â„â€²
(A6) E1 = E â€² \ ğ‘¥
(A7) ğ‘£ = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]
By Lemma B.14, â„â€²
of headers and chompâ‡“ does not affect the validity of headers, â„1 ++ â„â€²
Let â„ = â„1 ++ â„â€²
(1) follows by (A4) and â„â€²
assumption.
To show (2), we must show that â„â€²
chompâ‡“(â„1 ++ â„â€²
packet of â„1 and then concatenating â„â€²
and then removing the first bit of the input packet.
(3) follows by (A6) and (4) follows by (A7).

2 = chompâ‡“ (â„1 ++ â„â€²

2 and E = E1.

2 =
2, 1). This equality holds, because chomping of one bit from the input
2 yields the same heap as concatenating both heaps

2, 1) â‡” chompâ‡“(â„1, 1) ++ â„â€²

2 âˆˆ âŸ¦ğœ2âŸ§E1 [ğ‘¦â†¦â†’â„1 ]. The latter holds, because ğ‘¥ is not free in ğœ2 by

2 is defined, i.e., they have disjoint sets

2 is defined.

1 ++ â„â€²

Subcase sizeof(ğ‘£) > 1: By IH, there exists â„1, E1, such that

(A8) â„1 âˆˆ âŸ¦ğœ1âŸ§E1
(A9) â„â€²
(A10) E1 = E â€²[ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof (ğ‘£) âˆ’ 1]])]
(A11) ğ‘£ = E1(ğ‘¥)(ğœ„)@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

1 = chompâ‡“(â„1, 1)

1 ++ â„â€²

2 and E = E1.

2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ]. Since â„â€²

2 is defined, i.e., they have disjoint sets

2 âˆˆ âŸ¦ğœ2âŸ§E1 [ğ‘¦â†¦â†’â„1 ]. The latter holds, because ğ‘¥ is not free in ğœ2 by

By Lemma B.14, â„â€²
of headers and chompâ‡“ does not affect the validity of headers, â„1 ++ â„â€²
Let â„ = â„1 ++ â„â€²
(1) follows by (A8) and â„â€²
assumption.
To show (2), we must show that â„â€²
chompâ‡“(â„1 ++ â„â€²
packet of â„1 and then concatenating â„â€²
and then removing the first bit of the input packet.
(3) follows by (A10) and (4) follows by (A11) and (5) follows by (A10).

2 =
2, 1). This equality holds, because chomping of one bit from the input
2 yields the same heap as concatenating both heaps

2, 1) â‡” chompâ‡“(â„1, 1) ++ â„â€²

2 = chompâ‡“ (â„1 ++ â„â€²

2 is defined.

1 ++ â„â€²

Subcase â„â€² contained in the second subset:

1 ++ â„â€²

2 and

(A1) â„â€² = â„â€²
(A2) â„â€²
(A3) â„â€²

1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€² and
1 ].
2 âˆˆ âŸ¦chompRec(ğœ2, 1, ğœ„, ğ‘¥)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€²
We distinguish two cases.
Subcase sizeof(ğ‘£) = 1: By IH, for every â„â€²

E2, such that
(A4) â„2 âˆˆ âŸ¦ğœ2âŸ§E2
(A5) â„â€²
(A6) E2 = E â€²[ğ‘¦ â†¦â†’ â„â€²
(A7) ğ‘£ = â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

2 = chompâ‡“(â„2, 1)
1] \ ğ‘¥

1 âˆˆ âŸ¦{ğ‘§ : ğœ |

|ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€², there exists â„2,

1++ â„2 and E = E2\ğ‘¦. We have to show that â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E. By assumption, ğ‘¥ is
1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§E

Let â„ = â„â€²
not free in ğœ1 and ğœ2. By (A2) and by the fact that E = E â€²\ğ‘¥, â„â€²
and by subtyping, â„â€²
1 âˆˆ âŸ¦ğœ1âŸ§E.
(1) follows together with (A4).
To show (2), we must show that â„â€²
chompâ‡“(â„â€²
both heaps are equal.
(3) follows by (A6) and (4) follows by (A7).

1 ++ â„2, 1). Since by (A2), the input packet of â„â€²

2 = chompâ‡“ (â„â€²

1 ++ â„â€²

1 ++ â„2, 1) â‡” â„â€²

1 ++ chompâ‡“(â„2, 1) =
1 is empty, the input packet of

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:53

Subcase sizeof(ğ‘£) > 1: By IH, for every â„â€²

1 âˆˆ âŸ¦{ğ‘§ : ğœ |

|ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§Eâ€², there exists â„2,

E2, such that
(A8) â„2 âˆˆ âŸ¦ğœ2âŸ§E2
(A9) â„â€²
(A10) E2 = E â€²[ğ‘¦ â†¦â†’ â„â€²
(A11) ğ‘£ = E2(ğ‘¥)(ğœ„)@â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

2 = chompâ‡“(â„2, 1)

1, ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof (ğ‘£) âˆ’ 1]])]

1 ++ â„2 and E = E2 \ ğ‘¦. To show that â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E. By assumption that ğ‘¥ is
1 âˆˆ âŸ¦ğœ1âŸ§E.

1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | = 0}âŸ§E and by subtyping, â„â€²

Let â„ = â„â€²
not free in ğœ1 and by (A2), â„â€²
(1) follows together with (A8).
To show (2), we must show that â„â€²
chompâ‡“(â„â€²
both heaps are equal.
(3) follows by (A10) and (4) follows by (A11) and (5) follows by (A10).

1 ++ â„2, 1). Since by (A2), the input packet of â„â€²

1 ++ chompâ‡“(â„2, 1) =
1 is empty, the input packet of

1 ++ â„2, 1) â‡” â„â€²

2 = chompâ‡“ (â„â€²

1 ++ â„â€²

Case ğœ = {ğ‘¦ : ğœ1 | ğœ‘ }:

Let E â€² where E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) be arbitrary.
Let â„â€² âˆˆ âŸ¦chompRec({ğ‘¦ : ğœ1 | ğœ‘ }, 1, ğœ„, ğ‘¥)âŸ§Eâ€² be arbitrary.

âŸ¦chompRec({ğ‘¦ : ğœ1 | ğœ‘ }, 1, ğœ„, ğ‘¥)âŸ§Eâ€²

= âŸ¦heapRef1(chomp1({ğ‘¦ : ğœ1 | ğœ‘ }, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= {â„â€²|â„â€² âˆˆ âŸ¦chompRec(ğœ1, 1, ğœ„, ğ‘¥)âŸ§Eâ€² âˆ§

ğœ‘
1 (ğœ‘, ğ‘¦, b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€² [ğ‘¦â†¦â†’â„â€² ] }
âŸ¦heapRef1(chomp

We distinguish two cases.
Subcase sizeof (ğ‘£) = 1:

By IH, there exists â„1, E1, such that

(A1) â„1 âˆˆ âŸ¦ğœ1âŸ§E1
(A2) â„â€² = chompâ‡“(â„1, 1)
(A3) E1 = E â€² \ ğ‘¥
(A4) ğ‘£ = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

Let E = E1 and â„ = â„1. To show (1), we must show that â„1 âˆˆ âŸ¦{ğ‘¦ : ğœ1 | ğœ‘ }âŸ§E1, which
follows by (A1) and Lemma B.13.
(2) follows by (A2), (3) follows by (A3) and (4) follows by (A4).

Subcase sizeof(ğ‘£) > 1:

By IH, there exists â„1, E1, such that

(A1) â„1 âˆˆ âŸ¦ğœ1âŸ§E1
(A2) â„â€² = chompâ‡“(â„1, 1)
(A3) E1 = E â€²[ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof (ğ‘£) âˆ’ 1]])]
(A4) ğ‘£ = E1(ğ‘¥)(ğœ„)@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

Let E = E1 and â„ = â„1. To show (1), we must show â„1 âˆˆ âŸ¦{ğ‘¦ : ğœ1 | ğœ‘ }âŸ§E1, which follows by
(A1) and Lemma B.13.
(2) follows by (A2), (3) follows by (A3), (4) follows by (A4) and (5) follows by (A3).

Case ğœ = ğœ1 [ğ‘¦ â†¦â†’ ğœ2]:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:54

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Let E â€² where E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) be arbitrary.
Let â„â€² âˆˆ âŸ¦chompRec(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], 1, ğœ„, ğ‘¥)âŸ§Eâ€² be arbitrary.

âŸ¦chompRec(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], 1, ğœ„, ğ‘¥)âŸ§Eâ€²

= âŸ¦heapRef1 (chomp1(ğœ1 [ğ‘¦ â†¦â†’ ğœ2], b0), b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0) [ğ‘¦ â†¦â†’ ğœ2], b0, ğ‘¥, ğœ„, 1)âŸ§Eâ€²
= âŸ¦heapRef1(chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1) [ğ‘¦ â†¦â†’ heapRef1(ğœ2, b0, ğ‘¥, ğœ„, 1)]âŸ§Eâ€²
= âŸ¦heapRef1 (chomp1(ğœ1, b0), b0, ğ‘¥, ğœ„, 1) [ğ‘¦ â†¦â†’ ğœ2]âŸ§Eâ€²
= {â„â€²

1 âˆˆ âŸ¦chompRec(ğœ1, 1, ğ‘¥, ğœ„)âŸ§Eâ€² [ğ‘¦â†¦â†’â„2 ] }

1|â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² âˆ§ â„â€²

By IH, for every â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€², there exists â„1, E1, such that

We distinguish two cases.
Subcase sizeof (ğ‘£) = 1:

(A1) â„1 âˆˆ âŸ¦ğœ1âŸ§E1 [ğ‘¦â†¦â†’â„2 ]
1 = chompâ‡“ (â„1, 1)
(A2) â„â€²
(A3) E1 = E â€²[ğ‘¦ â†¦â†’ â„2] \ ğ‘¥
(A4) ğ‘£ = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]

Let E = E1 and â„ = â„1. Since ğ‘¥ and ğ‘¦ not free in ğœ2, for every heap â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² also holds
that â„2 âˆˆ âŸ¦ğœ2âŸ§E1, from which we can conclude (1), i.e., â„ âˆˆ âŸ¦ğœ1 [ğ‘¦ â†¦â†’ ğœ2]âŸ§E.
To show (2), we must show that â„â€² = chompâ‡“(â„, 1) = chompâ‡“(â„1, 1), which follows from
(A2) and the fact that â„â€² = â„â€²
1.
(3) follows by choice of E and (A3). (4) follows by (A4).

Subcase sizeof(ğ‘£) > 1:

By IH, for every â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€², there exists â„1, E1, such that

(A1) â„1 âˆˆ âŸ¦ğœ1âŸ§E1 [ğ‘¦â†¦â†’â„2 ]
1 = chompâ‡“ (â„1, 1)
(A2) â„â€²
(A3) E1 = E â€²[ğ‘¦ â†¦â†’ â„2, ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£ [0 : sizeof(ğ‘£) âˆ’ 1]])]
(A4) ğ‘£ = E1(ğ‘¥)(ğœ„)@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : 1]
Let E = E1 and â„ = â„1.
To show (1), we must show that â„ âˆˆ âŸ¦ğœ1 [ğ‘¦ â†¦â†’ ğœ2]âŸ§E1. Since ğ‘¥ and ğ‘¦ not free in ğœ2, for every
heap â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² also holds that â„2 âˆˆ âŸ¦ğœ2âŸ§E1. The result follows by the semantics of heap
types.
To show (2), we must show that â„â€² = chompâ‡“ (â„1, 1), which follows from (A2) and â„â€² = â„â€²
1.
(3) follows by (A3), (4) follows by (A4) and (5) follows also by (A3).

â–¡

Lemma B.22 (Semantic ChompRec Inverse). For all variables ğ‘¥, values ğ‘£, ğ‘› âˆˆ N, heap types ğœ,
environments E â€² and heaps â„â€² such that E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) and â„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘›, ğœ„, ğ‘¥)âŸ§Eâ€²
and ğ‘¥ not free in ğœ and sizeof(ğ‘£) = ğ‘›, there exists â„ and E such that â„ âˆˆ âŸ¦ğœâŸ§E and E = E â€² \ ğ‘¥ and
chompâ‡“(â„, ğ‘›) = â„â€².

Proof. Proof by induction on ğ‘›.

Case ğ‘› = 0:

By definition of chompRec, chompRec(ğœ, 0, ğœ„, ğ‘¥) = ğœ.
Together with assumption â„â€² âˆˆ âŸ¦chompRec(ğœ, ğ‘›, ğœ„, ğ‘¥)âŸ§Eâ€², we know that â„â€² âˆˆ âŸ¦ğœâŸ§Eâ€².
Let â„ = â„â€². By assumption, ğ‘¥ is not free in ğœ, thus the binding of ğ‘¥ in E â€² does not affect the
semantics of ğœ. We can therefore remove the binding altogether, so ğœ describes the same set

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:55

of heaps both in E â€² and in E. We can conclude that â„ âˆˆ âŸ¦ğœâŸ§E. chompâ‡“(â„, 0) = â„â€² follows
from the definition of semantic chomp.

Case ğ‘› = 1:

The result directly follows by Lemma B.21.

Case ğ‘› = ğ‘š + 1:

We assume that the lemma holds for ğ‘› = ğ‘š. We have to show that the lemma also holds for
. Together with
ğ‘› = ğ‘š + 1. Let â„â€²
Lemma B.16, we can conclude that

0 âˆˆ âŸ¦chompRec(ğœ, ğ‘š + 1, ğœ„, ğ‘¥)âŸ§Eâ€²

0 be some heap such that â„â€²

0

â„â€²
0 âˆˆ âŸ¦chompRec(chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥), 1, ğœ„, ğ‘¥)âŸ§Eâ€²

0

By Lemma B.21, there is some â„â€²
chompâ‡“(â„â€²
1, 1) where E â€²
0 [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„
and E1, such that â„1 âˆˆ âŸ¦ğœâŸ§E1 where E1 = E â€²
chompâ‡“(chompâ‡“(â„1, ğ‘š), 1) and Lemma B.17, follows â„â€²

1 such that â„â€²

1 = E â€²

1, E â€²

1 âˆˆ âŸ¦chompRec(ğœ, ğ‘š, ğœ„, ğ‘¥)âŸ§Eâ€²

0 =
â†¦â†’ ğ‘£ [0 : ğ‘š]])]. By IH, there exists a â„1
0 =

1 = chompâ‡“(â„1, ğ‘š). From â„â€²

1 \ ğ‘¥ and â„â€²

and â„â€²

1

0 = chompâ‡“(â„1, ğ‘š + 1).

â–¡

Lemma B.23 (Semantic Chomp Inverse). For all variables ğ‘¥, values ğ‘£, instances ğœ„, heap types ğœ,
environments E â€² and heaps â„â€² such that E â€²(ğ‘¥) = (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) and â„â€² âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¥)âŸ§Eâ€² and ğ‘¥
not free in ğœ, there exists â„ and E such that â„ âˆˆ âŸ¦ğœâŸ§E and E = E â€² \ ğ‘¥ and chompâ‡“(â„, sizeof (ğœ„)) = â„â€².

Proof. By definition of chomp, we know that

chomp(ğœ, ğœ„, ğ‘¥) = chompRec(ğœ, sizeof (ğœ„), ğ‘¥, ğœ„)

The result follows by Lemma B.22.

â–¡

Lemma B.24 (Formulae Preservation). If Î“; ğœ âŠ¢ ğœ‘ : B and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ and

âŸ¨ğ¼, ğ‘‚, ğ», ğœ‘âŸ© â†’ ğœ‘ â€² then Î“; ğœ âŠ¢ ğœ‘ â€² : B.

Proof. By induction on a derivation of Î“; ğœ âŠ¢ ğœ‘ : B.

â–¡

Lemma B.25 (Semantic Formulae Preservation). If Î“; ğœ âŠ¢ ğœ‘ : B and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ

and âŸ¨ğ¼, ğ‘‚, ğ», ğœ‘âŸ© â†’ ğœ‘ â€² then

âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğœ‘ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

Proof. By induction on a derivation of Î“; ğœ âŠ¢ ğœ‘ : B.

â–¡

Lemma B.26 (Expression Preservation). If Î“; ğœ âŠ¢ ğ‘’ : ğœ and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ and

âŸ¨ğ¼, ğ‘‚, ğ», ğ‘’âŸ© â†’ ğ‘’ â€² then Î“; ğœ âŠ¢ ğ‘’ â€² : ğœ.

Proof. By induction on a typing derivation of Î“; ğœ âŠ¢ ğ‘’ : ğœ.

â–¡

Lemma B.27 (Semantic Expression Preservation). If Î“; ğœ âŠ¢ ğ‘’ : ğœ and E |= Î“ and (ğ¼, ğ‘‚, ğ» ) |=E ğœ

and âŸ¨ğ¼, ğ‘‚, ğ», ğ‘’âŸ© â†’ ğ‘’ â€² then

âŸ¦ğ‘’ [ğ‘¥/ ğ‘ğ‘šğ‘‘ğ‘‰ ğ‘ğ‘Ÿ ]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğ‘’ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

Proof. By induction on a typing derivation of Î“; ğœ âŠ¢ ğ‘’ : ğœ.

â–¡

Theorem B.28 (Preservation). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2, âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©, E |= Î“ and
2 and E â€² |= Î“â€² and (ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²
1

2.Î“â€² âŠ¢ ğ‘ â€² : (ğ‘¥ â€² : ğœ â€²

1) â†’ ğœ â€²

1, ğœ â€²

(ğ¼, ğ‘‚, ğ» ) |=E ğœ1, then âˆƒÎ“â€², E â€², ğ‘¥ â€², ğœ â€²
and âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

Proof. Directly follows by the slightly stronger Lemma B.29.

â–¡

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:56

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Lemma B.29 (Preservation AUX). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2, âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©, E |= Î“
2 and E â€² |= Î“â€² and Î“ âŠ† Î“â€² and
2.Î“â€² âŠ¢ ğ‘ â€² : (ğ‘¥ â€² : ğœ â€²

1) â†’ ğœ â€²

and (ğ¼, ğ‘‚, ğ» ) |=E ğœ1, then âˆƒÎ“â€², E â€², ğ‘¥ â€², ğœ â€²
1 and âŸ¦ğœ â€²
E âŠ† E â€² and (ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²

1, ğœ â€²
2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

Proof. By induction on a derivation of Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 with case analysis on the last rule

used. We refer to the proof goals as follows:

1) â†’ ğœ â€²
2

(1) Î“â€² âŠ¢ ğ‘ â€² : (ğ‘¥ â€² : ğœ â€²
(2) E â€² |= Î“â€²
(3) Î“ âŠ† Î“â€²
(4) E âŠ† E â€²
(5) (ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²
1
(6) âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

General assumptions:

(A) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2
(B) âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©
(C) E |= Î“
(D) (ğ¼, ğ‘‚, ğ» ) |=E ğœ1

Case T-Add:

By inversion of rule T-Add, we get

(A1) ğ‘ = addğœ„
(A2) Excludes Î“ ğœ1 ğœ„
(A3) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }

Only evaluation rule E-Add applies to ğ‘:

(A4) ğœ„ âˆ‰ dom(ğ» )
(A5) H T (ğœ„) = ğœ‚
(A6) init = ğ‘£.
(A7) ğ¼ â€² = ğ¼ and ğ‘‚ â€² = ğ‘‚ and ğ» â€² = ğ» [ğœ„ â†¦â†’ ğ‘£] and ğ‘ â€² = skip
Let Î“â€² = Î“, ğ‘¥ : ğœ1 and E â€² = E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )].
Let ğœ â€²
2 = {ğ‘¤ : Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ } | ğ‘¤ â‰¡ ğ‘¥ â€²}.
ğœ â€²
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4. (3) and (4)
are immediate.
To show (5), we must show that (ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘£]) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ |
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }. By Ent-Sigma, we must show that

1 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ } and

(5.1) (ğ¼, ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ } and
(5.2) (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» )ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }.
(5.1) follows by Ent-Refine and (D). To show (5.2), by Ent-Refine, we must show that

(5.2.1) (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) |=E [ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : âŠ¤ | ğ‘§.ğœ„.valid âˆ§ (cid:211)ğœ… âˆˆdom( H T) Â¬ğœ….valid} and
(5.2.2) âŸ¦ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£âŸ§E [ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘§â†¦â†’( âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„â†¦â†’ğ‘£ ]) ] = true

(5.2.1) follows by Ent-Refine, Ent-Top and the semantics of formulae. (5.2.2) follows from
the semantics of formulae.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:57

(6) follows by

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
={(ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘£])}
={â„ | â„ âˆˆ âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§

ğ‘§.ğœ„ = ğ‘£ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]) ] âˆ§

âŸ¦ğ‘¤ â‰¡ ğ‘¥ â€²âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]),ğ‘¤â†¦â†’â„] }

=âŸ¦{ğ‘¤ : Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ } |

ğ‘¤ â‰¡ ğ‘¥ â€²}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]) ]

Case T-Ascribe:

By inversion of rule T-Ascribe, we get

(A1) ğ‘ = ğ‘ğ‘ as (ğ‘¥ : ğœ1) â†’ ğœ2
(A2) Î“ âŠ¢ ğ‘ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2

There is one evaluation rule that applies to ğ‘, E-Ascribe, so ğ¼ â€² = ğ¼ and ğ‘‚ â€² = ğ‘‚ and ğ» â€² = ğ» and
ğ‘ â€² = ğ‘ğ‘. Let Î“â€² = Î“, E â€² = E, ğœ â€²
2 = ğœ2. (1) follows by (A2), (2) follows by assumption
(C). (3) and (4) are immediate. (5) follows by assumption (D) and (6) follows from the equality
of ğœ2 and ğœ â€²

2, which itself follows by reflexivity.

1 = ğœ1 and ğœ â€²

Case T-Extract:

By inversion of rule T-Extract, we get

(A1) ğ‘ = extract (ğœ„)
(A2) Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ1) = sizeof (ğœ„)
(A3) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) |
ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }
Only evaluation rule E-Extract applies to ğ‘:

(A4) deserializeH T (ğœ„) (ğ¼ ) = (ğ‘£, ğ¼ â€²)
(A5) ğ‘‚ â€² = ğ‘‚
(A6) ğ» â€² = ğ» [ğœ„ â†¦â†’ ğ‘£]
(A7) ğ‘ â€² = skip

1 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

Let Î“â€² = Î“, ğ‘¥ : ğœ1, E â€² = E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )].
Let ğœ â€²
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }.
2 = {ğ‘£ : Î£ğ‘¦ : {ğ‘§ : ğœ„
Let ğœ â€²
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ } | ğ‘£ â‰¡ ğ‘¥ }.
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4. (3) and (4)
are immediate.
To show (5), we must show that (ğ¼ â€², ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘£]) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] Î£ğ‘¦ : {ğ‘§ : ğœ„
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }.
By Ent-Sigma, we must show that

| ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› =

| ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› =

(5.1) (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ ğ‘£]) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}, which follows by Ent-

Refine and the semantics of types and

(5.2) (ğ¼ â€², ğ‘‚, ğ» )

|=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’( âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„â†¦â†’ğ‘£ ]) ] {ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦)

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }
By Ent-Refine, we must show that

| ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

(5.2.1) (ğ¼ â€², ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’( âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„â†¦â†’ğ‘£ ]) ] chomp(ğœ1, ğœ„, ğ‘¦)

By Lemma B.2, it is sufficient to show that

(ğ¼ â€², ğ‘‚, ğ» ) âˆˆ âŸ¦chomp(ğœ1, ğœ„, ğ‘¦)âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’( âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„â†¦â†’ğ‘£ ]) ]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:58

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By assumption (D) and by Lemma B.2 follows (ğ¼, ğ‘‚, ğ» ) âˆˆ âŸ¦ğœ1âŸ§E.
By Lemma B.20, there exists some heap

â„ âˆˆ âŸ¦chomp(ğœ1, ğœ„, ğ‘¦)âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’( âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„â†¦â†’ğ‘£ ]) ]

such that â„ = chompâ‡“((ğ¼, ğ‘‚, ğ» ), sizeof(ğœ„)).
From the definition of chompâ‡“ follows that

chompâ‡“((ğ¼, ğ‘‚, ğ» ), sizeof(ğœ„)) = (ğ¼ â€²â€², ğ‘‚, ğ» )

where ğ¼ â€²â€² = ğ¼ [sizeof(ğœ„) :] = ğ¼ â€².

(5.2.2) âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§

ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’( âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„â†¦â†’ğ‘£ ]),ğ‘§â†¦â†’(ğ¼ â€²,ğ‘‚,ğ» ) ], which follows by the definition of deserialize
and the semantics of formulae and expressions.
Finally, we must show that âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âŠ† âŸ¦ğœ â€²

2âŸ§E [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]) ].

âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.

{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§

ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„1 ] }

={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âˆ§

â„2 âˆˆ {â„â€²

2 âˆˆ âŸ¦chomp(ğœ1, ğœ„, ğ‘¦)âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„1 ]âˆ§

âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„1,ğ‘§â†¦â†’â„â€²

2 ] }}

By Lemma B.20

={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âˆ§

â„2 âˆˆ {â„ âˆˆ âŸ¦ğœ1âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âˆ§ â„â€²

2 = chompâ‡“(â„, sizeof (ğœ„)) âˆ§
âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„1,ğ‘§â†¦â†’â„â€²

2 ] }}

By definition of chompâ‡“ and semantics of types

={(ğ¼ â€², ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘£])}
={â„ | â„ âˆˆ âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.

{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]) ] âˆ§

âŸ¦ğ‘£ â‰¡ ğ‘¥ â€²âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]),ğ‘£â†¦â†’â„] }

=âŸ¦{ğ‘£ : Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.

{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§

ğ‘£ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘£ ]) ]

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ } |

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:59

This shows (6) and concludes the case.

Case T-If:

By inversion of rule T-If, we get

(A1) Î“; ğœ1 âŠ¢ ğœ‘ : B
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ12
(A3) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ22
(A4) ğœ2 = {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}
T-If There are three evaluation rules that apply to ğ‘.
Subcase E-If:

(A5) ğ‘ â€² = if (ğœ‘ â€²) then c1 else c2
(A6) ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ»

Let Î“â€² = Î“, E â€² = E, ğ‘¥ â€² = ğ‘¥,
1 = ğœ1 and
ğœ â€²
2 = {ğ‘¦ : ğœ12 | ğœ‘ â€²[ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ â€²[ğ‘¥/heap]}.
ğœ â€²
By Lemma B.24, Î“; ğœ1 âŠ¢ ğœ‘ â€² : B.
By Lemma B.25, âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğœ‘ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ].
From (A2) follows that Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ â€²[ğ‘¦/heap]}) â†’ ğœ12 and from (A3) follows
that Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ â€²[ğ‘¦/heap]}) â†’ ğœ22 (1) follows by T-If.
(2) follows by assumption (C), (3) and (4) are immediate.
(5) follows by assumption (D).
(6) follows together with the assumption

âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğœ‘ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

from the equality âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] = âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ].

âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦{ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦{ğ‘¦ : ğœ12 | ğœ‘ â€²[ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ â€²[ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ]

Subcase E-IfTrue:

(A7) ğ‘ â€² = ğ‘1
(A8) ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ»
(A9) ğœ‘ = true

Let Î“â€² = Î“, E â€² = E, ğ‘¥ â€² = ğ‘¥,
1 = {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} = {ğ‘¦ : ğœ1 | true} = ğœ1 and
ğœ â€²
2 = ğœ12.
ğœ â€²
(1) holds by assumption (A2), (2) holds by assumption (C). (3) and (4) are immediate and (5)
(ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²
(6) follows from

1 â‡” (ğ¼, ğ‘‚, ğ» ) |=E ğœ1 holds by assumption (D).

âŸ¦{ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦{ğ‘¦ : ğœ12 | true} + {ğ‘¦ : ğœ22 | false}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦ğœ12âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦ğœ â€²
2âŸ§Eâ€² [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ]

Subcase E-IfFalse:

Symmetric to previous subcase.

Case T-Mod:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:60

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By inversion of rule T-Mod, we get

(A1) ğ‘ = ğœ„.ğ‘“ := ğ‘’
(A2) Includes Î“ ğœ1 ğœ„
(A3) F (ğœ„, ğ‘“ ) = BV
(A4) Î“; ğœ1 âŠ¢ ğ‘’ : BV
(A5) ğœ2 = {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}
(A6) ğœ‘ğ‘ğ‘˜ğ‘¡ â‰œ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡
(A7) ğœ‘ğœ„ â‰œ âˆ€ğœ… âˆˆ dom(H T ).ğœ„ â‰  ğœ… â†’ ğ‘¦.ğœ… = ğ‘¥ .ğœ…
(A8) ğœ‘ ğ‘“ â‰œ âˆ€ğ‘” âˆˆ dom(H T (ğœ„)).ğ‘“ â‰  ğ‘” â†’ ğ‘¦.ğœ„.ğ‘” = ğ‘¥ .ğœ„.ğ‘”
There are two evaluation rule that apply to ğ‘.
Subcase E-Mod:

(A9) ğ» (ğœ„) = ğ‘Ÿ
(A10) ğ‘Ÿ â€² â‰œ {r with ğ‘“ = ğ‘£ }
(A11) (ğ¼ â€², ğ‘‚ â€², ğ» â€²) = (ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘Ÿ â€²])
(A12) ğ‘ â€² = skip
(A13) ğ‘’ = ğ‘£
(A14) ğœ2 = {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘£ [ğ‘¥/heap]}

1 = ğœ2 and ğœ â€²

2 = {ğ‘§ : ğœ2 | ğ‘§ â‰¡ ğ‘¥ }.

Let Î“â€² = Î“, ğ‘¥ : ğœ1 and E â€² = E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )] and ğœ â€²
(1) follows by T-Skip and T-Sub. (2) follows by assumptions (C) and (D) and Lemma B.4. (3)
and (4) are immediate.
To show (5), we must show that (ğ¼, ğ‘‚, ğ» [ğœ„
â†¦â†’ ğ‘Ÿ â€²]) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âŠ¤ and âŸ¦ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§
ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘£ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘Ÿ â€² ]) ] = true. Since E (ğ‘¥)(ğ¼ ) = E (ğ‘¦)(ğ¼ ) and
E (ğ‘¥)(ğ‘‚) = E (ğ‘¦)(ğ‘‚), ğœ‘ğ‘ğ‘˜ğ‘¡ holds. Similarly, E (ğ‘¥)(ğ» ) = E (ğ‘¦)(ğ» ) in every aspect, except for
field ğ‘“ of instance ğœ„, so ğœ‘ ğ‘“ and ğœ‘ğ‘–ğ‘›ğ‘ ğ‘¡ also hold. ğ‘¦.ğœ„.ğ‘“ = ğ‘£ [ğ‘¥/heap] also holds, because
âŸ¦ğ‘¦.ğœ„.ğ‘“ âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘Ÿ â€² ]) ] =
âŸ¦ğ‘£ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» [ğœ„â†¦â†’ğ‘Ÿ â€² ]) ]

â‡” ğ‘£ = âŸ¦ğ‘£ [ğ‘¥/heap]âŸ§[ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
â‡” ğ‘£ = ğ‘£

To show

âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

â‡” âŸ¦{ğ‘§ : ğœ2 | ğ‘§ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
â‡” {(ğ¼ â€², ğ‘‚ â€², ğ» â€²)} âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
â‡” {(ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘Ÿ â€²])} âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

To show (6), let â„ = (ğ¼, ğ‘‚, ğ» [ğœ„ â†¦â†’ ğ‘Ÿ â€²]). Therefore,

(A15) â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = ğ¼ and
(A16) â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = ğ‘‚ and
(A17) for all ğœ… âˆˆ dom(H T ) such that ğœ… â‰  ğœ„, â„(ğœ…) = ğ» (ğœ…)
(A18) for all ğ‘” âˆˆ dom(H T (ğœ„)) such that ğ‘” â‰  ğ‘“ , â„(ğœ„)(ğ‘”) = ğ» (ğœ„)(ğ‘”)
(A19) â„(ğœ„)(ğ‘“ ) = ğ‘£ [ğ‘¥/heap] = ğ‘£

From the semantics of types follows that â„ âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ].

Subcase E-Mod1:
(A20) âŸ¨ğ¼, ğ‘‚, ğ», ğ‘¡âŸ© â†’ ğ‘’ â€²
(A21) ğ‘ â€² = ğœ„.ğ‘“ := ğ‘’ â€²
(A22) ğ¼ â€² = ğ¼, ğ‘‚ â€² = ğ‘‚ and ğ» â€² = ğ»

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:61

1 = ğœ1 and

Let Î“â€² = Î“ and E â€² = E and ğ‘¥ â€² = ğ‘¥.
Let ğœ â€²
2 = {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ â€²[ğ‘¥/heap]}.
ğœ â€²
By semantic expression preservation (Lemma B.27), we know that
âŸ¦ğ‘’ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğ‘’ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ].
If Î“; ğœ1 âŠ¢ ğ‘’ : BV and âŸ¦ğ‘’ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğ‘’ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] holds, then it
must hold that Î“; ğœ1 âŠ¢ ğ‘’ â€² : BV.
(1) follows by T-Mod, (2) follows from assumption (C). (3) and (4) are immediate. (5) follows
from assumption (D).
(6) follows from

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

âŸ¦ğœ â€²
â‡”âŸ¦ğœ â€²
â‡”âŸ¦{ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ â€²[ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âŠ†
âŸ¦{ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

together with assumption

âŸ¦ğ‘’ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] = âŸ¦ğ‘’ â€²[ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

and the semantics of types.

Case T-Remit:

By inversion of rule T-Remit, we get

(A1) ğ‘ = ğ‘Ÿğ‘’ğ‘šğ‘–ğ‘¡
(A2) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}
(A3) Includes Î“ ğœ1 ğœ„

There is only evaluation rule E-Remit that applies to ğ‘.

(A4) ğœ„ âˆˆ dom(ğ» )
(A5) H T (ğœ„) = ğœ‚
(A6) serializeğœ‚ (ğ» (ğœ„)) = ğ‘ğ‘£
(A7) ğ¼ â€² = ğ¼ , ğ‘‚ â€² = ğ‘‚@ğ‘ğ‘£, ğ» â€² = ğ» , ğ‘ â€² = skip

Let Î“â€² = Î“, ğ‘¥ : ğœ1 and E â€² = E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )].
1 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„} and
Let ğœ â€²
2 = {ğ‘£ : Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„} | ğ‘£ â‰¡ ğ‘¥ â€²}.
ğœ â€²
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4.
(3) and (4) are immediate.
For (5) we have to show that (ğ¼, ğ‘‚@ğ‘ğ‘£, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– |
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}. By Ent-Sigma, we must show that

(5.1) (ğ¼, ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ } and
(5.2) (âŸ¨âŸ©, ğ‘ğ‘£, []) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}

For (5.1) we must show by Ent-Refine that (ğ¼, ğ‘‚, ğ» )
|=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] ğœ1, which follows
by assumption (D) and the fact that x is not free in ğœ1. We must also show that âŸ¦ğ‘§ â‰¡
ğ‘¥âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘§â†¦â†’(ğ¼,ğ‘‚,ğ» ) ], which follows by the semantics of formulae and by reflexivity.
To show (5.2), by Ent-Refine, we must show that

and that

(âŸ¨âŸ©, ğ‘ğ‘£, []) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] ğœ–

âŸ¦ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘§â†¦â†’( âŸ¨âŸ©,ğ‘ğ‘£, []) ] = true

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:62

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

The first follows after unfolding the definition of ğœ– by Ent-Top, Ent-Refine and the semantics
of formulae. The second follows by the semantics of formulae and (A6).
(6) follows by

âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
=âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„1 ] }

={(ğ¼, ğ‘‚, ğ» ) ++ (âŸ¨âŸ©, ğ‘ğ‘£, [])}
={(ğ¼, ğ‘‚@ğ‘ğ‘£, ğ» )}
={â„ | â„ âˆˆ âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.

{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼,ğ‘‚@ğ‘ğ‘£,ğ» ) ] âˆ§

âŸ¦ğ‘£ â‰¡ ğ‘¥ â€²âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼,ğ‘‚@ğ‘ğ‘£,ğ» ),ğ‘£â†¦â†’â„] }

=âŸ¦{ğ‘£ : Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.

{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„} |

ğ‘£ â‰¡ ğ‘¥ â€²}âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¥ â€²â†¦â†’(ğ¼,ğ‘‚@ğ‘ğ‘£,ğ» ) ]

=âŸ¦ğœ â€²
Case T-Reset:

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ]

By inversion of rule T-Reset, we get

(A1) ğ‘ = reset
(A2) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }

There is only one evaluation rule that applies to ğ‘, E-Reset.

(A3) ğ‘ â€² = ğ‘ ğ‘˜ğ‘–ğ‘
(A4) ğ¼ â€² = ğ‘‚@ğ¼ , ğ‘‚ â€² = âŸ¨âŸ© and ğ» â€² = []

1 = Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› =

2 = {ğ‘£ : Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› =

Let E â€² = E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )] and Î“â€² = Î“, ğ‘¥ : ğœ1.
Let ğœ â€²
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }
Let ğœ â€²
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› } | ğ‘£ â‰¡ ğ‘¥ â€²}
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4.
(3) and (4) are immediate.
To show (5), we must show that

(ğ‘‚@ğ¼, âŸ¨âŸ©, []) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] Î£ğ‘¦ :{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.

{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }

By Ent-Sigma, we must show that

(ğ‘‚, âŸ¨âŸ©, []) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }

and

(ğ¼, âŸ¨âŸ©, []) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ‘‚, âŸ¨âŸ©, []) ] {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }

Both follow after unfolding the definition of ğœ– by Ent-Refine, Ent-Top and the semantics of
formulae.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:63

(6) follows by

âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.

{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

={â„1 ++ â„2 | â„1 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ } E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]âŸ§âˆ§

â„2 âˆˆ âŸ¦{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„1 ] }

={(ğ‘‚, âŸ¨âŸ©, []) ++ (ğ¼, âŸ¨âŸ©, [])}
={(ğ‘‚@ğ¼, âŸ¨âŸ©, [])}
=âŸ¦{ğ‘£ : Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.
{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› } |

ğ‘£ â‰¡ ğ‘¥ â€²}âŸ§E [ğ‘¥â†¦â†’(ğ‘‚@ğ¼, âŸ¨âŸ©, []),ğ‘¥ â€²â†¦â†’(ğ‘‚@ğ¼, âŸ¨âŸ©, []) ]

Case T-Seq:

By inversion of rule T-Seq, we get

(A1) ğ‘ = ğ‘1; ğ‘2
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â†’ ğœ12
(A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â†’ ğœ22
(A4) ğœ2 = ğœ22 [ğ‘¦ â†¦â†’ ğœ12]
Subcase E-Seq:

(A5) ğ‘1 = skip
(A6) ğ‘ â€² = ğ‘2

2 = ğœ22.

1 = ğœ12 and ğœ â€²

By E-Seq, ğ¼ â€² = ğ¼ , ğ‘‚ â€² = ğ‘‚, ğ» â€² = ğ» .
Let Î“â€² = Î“, ğ‘¥ : ğœ1, E â€² = E [ğ‘¥ â†¦â†’ (ğ¼, ğ‘‚, ğ» )] and ğ‘¥ â€² = ğ‘¦.
Let ğœ â€²
(1) follows by (A3), (2) follows by assumptions (C) and (D) and Lemma B.4. (3) and (4) are
immediate.
To show (5), we must show that (ğ¼, ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ } holds. By Ent-
Refine, we must show that (ğ¼, ğ‘‚, ğ» ) |=E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] ğœ1 and âŸ¦ğ‘§ â‰¡ ğ‘¥âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘§â†¦â†’(ğ¼,ğ‘‚,ğ» ) ],
which follows by assumption (D) and the semantics of formulae.
For (6), we must show that

âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

â‡”âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âŠ† âŸ¦ğœ22 [ğ‘¦ â†¦â†’ {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
âŸ¦ğœ22 [ğ‘¦ â†¦â†’ ğœ12]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚.ğ» ) ]
={â„22|â„12 âˆˆ âŸ¦{ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] âˆ§ â„22 âˆˆ âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„12 ] }
={â„22|â„12 = (ğ¼, ğ‘‚, ğ» ) âˆ§ â„22 âˆˆ âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„12 ] }
={â„22|â„22 âˆˆ âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ] }
=âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

This shows (6) and concludes this subcase.

Subcase E-Seq1:
1; ğ‘2

(A7) ğ‘ â€² = ğ‘ â€²
(A8) âŸ¨ğ¼, ğ‘‚, ğ», ğ‘1âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²
1âŸ©
By IH with (A2), (A7), (C) and (D), there exists Î“â€², E â€², ğœ â€²

(A9) Î“â€² âŠ¢ ğ‘ â€²
(A10) E â€² |= Î“â€²

1 : (ğ‘¥ â€² : ğœ â€²

1) â†’ ğœ â€²

12 where

1, ğœ â€²

12, ğ‘¥ â€², such that,

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:64

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

(A11) Î“ âŠ† Î“â€²
(A12) E âŠ† E â€²
(A13) (ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²
1
(A14) âŸ¦ğœ â€²

12âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ12âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

(1) follows by T-Seq, if we can show that there exists some ğœ â€²
(ğ‘¦ : ğœ â€²
22 [ğ‘¦ â†¦â†’ ğœ â€²

22 where ğœ â€²

12) â†’ ğœ â€²

2 = ğœ â€²

12]:

22, such that Î“â€², ğ‘¥ â€² : ğœ â€²

1 âŠ¢ ğ‘2 :

T-Seq
Î“â€² âŠ¢ ğ‘ â€²

1 : (ğ‘¥ : ğœ â€²

1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ â€²
22 [ğ‘¦ â†¦â†’ ğœ â€²
12]
By Lemma B.11 with (A3) and (A13), there exists some ğœ â€²
22 such that

1) â†’ ğœ â€²
12
1; ğ‘2 : (ğ‘¥ : ğœ â€²

Î“â€², ğ‘¥ : ğœ â€²
1) â†’ ğœ â€²

12) â†’ ğœ â€²
22

Î“â€² âŠ¢ ğ‘ â€²

(A15) Î“â€², ğ‘¥ â€² : ğœ â€²
(A16) âˆ€â„â€² âˆˆ âŸ¦ğœ â€²

1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ â€²
1) â†’ ğœ â€²
22
12âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] .âŸ¦ğœ â€²

22âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²),ğ‘¦â†¦â†’â„â€² ] âŠ†

âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„â€² ]
(2) follows by (A10) and (3) follows by (A11), (4) follows by (A12) and (5) follows by (A13).
(6) follows by

âŸ¦ğœ â€²
â‡”âŸ¦ğœ â€²

2âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
22 [ğ‘¦ â†¦â†’ ğœ â€²
(cid:216)

â‡”

âŸ¦ğœ â€²

22âŸ§Eâ€² [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²),ğ‘¦â†¦â†’â„â€² ] âŠ†

12]âŸ§Eâ€² [ğ‘¥â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ22 [ğ‘¦ â†¦â†’ ğœ12]âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]

â„â€² âˆˆâŸ¦ğœ â€²

12âŸ§Eâ€² [ğ‘¥ â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ]

(cid:216)

âŸ¦ğœ22âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ),ğ‘¦â†¦â†’â„]

â„ âˆˆâŸ¦ğœ12âŸ§E [ğ‘¥ â†¦â†’(ğ¼ ,ğ‘‚,ğ» ) ]

and by (A14), (A16) and the semantics of heap types.

Case T-Skip:

Immediately holds as there is no ğ‘ â€² such that âŸ¨ğ¼, ğ‘‚, ğ», ğ‘âŸ© â†’ âŸ¨ğ¼ â€², ğ‘‚ â€², ğ» â€², ğ‘ â€²âŸ©.

Case T-Sub:
(A1) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ3) â†’ ğœ4
(A2) Î“ âŠ¢ ğœ1 <: ğœ3
(A3) Î“, ğ‘¥ :ğœ1 âŠ¢ ğœ4 <: ğœ2

By Lemma B.3 with assumptions (C), (D) and (A2),

By IH with (A1), (B), (C) and (A4), there exists Î“â€², E â€², ğœ â€²

3, ğœ â€²

4, ğ‘¥ â€² such that

(A4) (ğ¼, ğ‘‚, ğ» ) |=E ğœ3.

3) â†’ ğœ â€²
4

(A5) Î“â€² âŠ¢ ğ‘ : (ğ‘¥ â€² : ğœ â€²
(A6) E â€² |= Î“â€²
(A7) Î“ âŠ† Î“â€²
(A8) E âŠ† E â€²
(A9) (ğ¼ â€², ğ‘‚ â€², ğ» â€²) |=Eâ€² ğœ â€²
3
(A10) âŸ¦ğœ â€²

4âŸ§Eâ€² [ğ‘¥ â€²â†¦â†’(ğ¼ â€²,ğ‘‚â€²,ğ» â€²) ] âŠ† âŸ¦ğœ4âŸ§E [ğ‘¥â†¦â†’(ğ¼,ğ‘‚,ğ» ) ]
2 = ğœ â€²

3 and ğœ â€²

1 = ğœ â€²

Let ğœ â€²
4. (1) follows by (A5), (2) follows by assumption (A6), (3) follows by
assumption (A7), (4) follows by assumption (A8), (5) follows by assumption (A9) and (6)
follows by (A3) and (A10).

C ALGORITHMIC TYPING RULES
The command typing rules are shown in Figure 20.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

â–¡

Dependently-Typed Data Plane Programming

40:65

T-Extract-Algo
Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof(ğœ„)}

ğœ‘1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©

ğœ‘2 â‰œ ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥
Î“ âŠ¢ extract (ğœ„) : (ğ‘¥ : ğœ1) â‡ Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğœ‘1}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘2}

T-Add-Algo

Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}

init H T (ğœ„) = ğ‘£

Î“ âŠ¢ addğœ„ : (ğ‘¥ : ğœ1) â‡ Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }

T-Mod-Algo

Î“; ğœ1 âŠ¢ ğ‘’ : BV
Î“ âŠ¢ ğœ <: ğœ„âˆ¼
F (ğœ„, ğ‘“ ) = BV
ğœ‘ğ‘ğ‘˜ğ‘¡ â‰œ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡
ğœ‘ğœ„ â‰œ âˆ€ğœ… âˆˆ dom(H T ). ğœ„ â‰  ğœ… â‡’ ğ‘¦.ğœ… = ğ‘¥ .ğœ…
ğœ‘ ğ‘“ â‰œ âˆ€ğ‘” âˆˆ dom(H T (ğœ„)). ğ‘“ â‰  ğ‘” â‡’ ğ‘¦.ğœ„.ğ‘” = ğ‘¥ .ğœ„.ğ‘”
Î“ âŠ¢ ğœ„.ğ‘“ := ğ‘’ : (ğ‘¥ : ğœ1) â‡ {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}

T-Remit-Algo
Î“ âŠ¢ ğœ1 <: ğœ„âˆ¼

ğœ‘ â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„

Î“ âŠ¢ remit (ğœ„) : (ğ‘¥ : ğœ1) â‡ Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğœ‘ }

T-Reset-Algo

ğœ‘1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡
ğœ‘2 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›
Î“ âŠ¢ reset : (ğ‘¥ : ğœ1) â‡ Î£ğ‘¦ : {ğ‘§ : ğœ– | ğœ‘1}.{ğ‘§ : ğœ– | ğœ‘2}

T-Seq-Algo

Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â‡ ğœ12
Î“, (ğ‘¥ : ğœ1) âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22
Î“ âŠ¢ ğ‘1; ğ‘2 : (ğ‘¥ : ğœ1) â‡ ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

T-Skip-Algo

ğœ2 â‰œ {ğ‘¦ : ğœ1 | ğ‘¦ â‰¡ ğ‘¥ }
Î“ âŠ¢ skip : (ğ‘¥ : ğœ1) â‡ ğœ2

T-If-Algo

T-Ascribe-Algo
Î“ âŠ¢ ğ‘ : (ğ‘¥ : Ë†ğœ1) â‡ ğœğ‘

Î“ âŠ¢ ğœ1 <: Ë†ğœ1

Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœğ‘ <: Ë†ğœ2
Î“ âŠ¢ ğ‘ as (ğ‘¥ : Ë†ğœ1) â†’ Ë†ğœ2 : (ğ‘¥ : ğœ1) â‡ Ë†ğœ2

Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â‡ ğœ12

Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â‡ ğœ22

Î“ âŠ¢ if (ğœ‘) c1 else c2 : (ğ‘¥ : ğœ1) â‡ {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}

Î“; ğœ1 âŠ¢ ğœ‘ : B

Fig. 20. Algorithmic typing rules for Î 4. Assume binders are fresh in all rules

Lemma C.1 (Subtype Reflexivity). For all subtyping contexts Î“ and heap types ğœ, Î“ âŠ¢ ğœ <: ğœ.

Proof. Immediate.

â–¡

Lemma C.2 (Subtype Transitivity). If Î“ âŠ¢ ğœ1 <: ğœ2, and Î“ âŠ¢ ğœ2 <: ğœ3, then Î“ âŠ¢ ğœ1 <: ğœ3.

Proof. Assume Î“ âŠ¢ ğœ1 <: ğœ2 and also assume Î“ âŠ¢ ğœ2 <: ğœ3. Let E |= Î“ and â„ âˆˆ âŸ¦ğœ1âŸ§E be arbitrary.
â–¡

By the first assumption â„ âˆˆ âŸ¦ğœ2âŸ§E. By the second assumption â„ âˆˆ âŸ¦ğœ3âŸ§E.

Lemma C.3 (Environment Entails Subtype). If Î“ âŠ¢ ğœ1 <: ğœ3, and E |= Î“, ğ‘¥ : ğœ3, then E |= Î“, ğ‘¥ : ğœ1.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:66

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Proof. Let Î“ âŠ¢ ğœ1 <: ğœ3 and E |= Î“, (ğ‘¥ : ğœ3). Let E |= Î“, (ğ‘¥ : ğœ1). We can write E = E â€²[ğ‘¥ â†¦â†’ â„1],
such that E â€² |= Î“, and â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€². The definition of subtyping gives â„1 âˆˆ âŸ¦ğœ3âŸ§Eâ€². The result follows
â–¡
by definition of entailment.

Lemma C.4 (Context Strengthening). If Î“ âŠ¢ ğœ1 <: ğœ3 and Î“, ğ‘¥ : ğœ3 âŠ¢ ğœ2 <: ğœ4 then Î“, ğ‘¥ : ğœ1 âŠ¢

ğœ2 <: ğœ4.

Proof. Assume Î“ âŠ¢ ğœ1 <: ğœ3 and further assume Î“, ğ‘¥ : ğœ3 âŠ¢ ğœ2 <: ğœ4. Let E |= Î“, ğ‘¥ : ğœ1. By
Lemma C.3 and the first assumption, E |= Î“, (ğ‘¥ : ğœ3). Let â„ âˆˆ âŸ¦ğœ2âŸ§E, the second assumption gives
â–¡
that â„ âˆˆ âŸ¦ğœ2âŸ§E, and weâ€™re done.

Lemma C.5 (Packet Bound Subtype). Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ ğ‘ iff Î“ âŠ¢ ğœ <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥

sizeof (ğœ„)}.

Proof. We show each direction separately.

(â‡’) Assume Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ ğ‘ . Let E |= Î“ and â„ âˆˆ âŸ¦ğœâŸ§E be arbitrary. By definition,
|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| â‰¥ ğ‘ . By the definition of subtyping, it suffices to show â„ âˆˆ âŸ¦{ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥
ğ‘ }âŸ§E. By definition, âŸ¦{ğ‘¥ : âŠ¤ |
|ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ ğ‘ }âŸ§E = {â„ | â„ âˆˆ H âˆ§ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) â‰¥ ğ‘ }, which
concludes this case.

(â‡) Assume Î“ âŠ¢ ğœ <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ ğ‘ }. We have to show that Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ ğ‘ . Let
E |= Î“ and â„ âˆˆ âŸ¦ğœâŸ§E be arbitrary. By the definition of subtyping, â„ âˆˆ âŸ¦{ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥
ğ‘ }âŸ§E. By definition of the semantics, we can conclude â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) â‰¥ ğ‘ .

â–¡

Lemma C.6 (Chomp Subtype). If ğ‘¥ not free in ğœ and ğœ â€², and Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ sizeof(ğœ„) and

Î“ âŠ¢ ğœ <: ğœ â€², then Î“, ğ‘¥ : {ğ‘¦ : ğœ„ | ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©} âŠ¢ chomp(ğœ, ğœ„, ğ‘¥) <: chomp(ğœ â€², ğœ„, ğ‘¥).

Proof. Given some heap â„â€² âˆˆ âŸ¦chomp(ğœ â€², ğœ„, ğ‘¥)âŸ§Eâ€². By Lemma B.23 there exists some E and

â„â€²â€² âˆˆ âŸ¦ğœ â€²âŸ§E, such that E â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„â€²â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof (ğœ„)]])] and
â„â€² = chompâ‡“ (â„â€²â€², sizeof (ğœ„)). By assumption Î“ âŠ¢ ğœ <: ğœ â€², we also know that â„â€²â€² âˆˆ âŸ¦ğœâŸ§E.

By Lemma B.20, we know that there exists â„ âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¥)âŸ§Eâ€²â€² such that â„ = chompâ‡“(â„â€²â€², sizeof(ğœ„))

and E â€²â€² = E [ğ‘¥ â†¦â†’ (âŸ¨âŸ©, âŸ¨âŸ©, [ğœ„ â†¦â†’ â„â€²â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof(ğœ„)]])]. From â„â€² = chompâ‡“(â„â€²â€², sizeof (ğœ„)) and
â„ = chompâ‡“(â„â€²â€², sizeof (ğœ„)) follows by the transitivity of equality that â„â€² = â„. By the fact that E â€² =
E â€²â€² follows that for every heap â„â€² âˆˆ âŸ¦chomp(ğœ â€², ğœ„, ğ‘¥)âŸ§Eâ€² also holds that â„â€² âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¦)âŸ§Eâ€²â€². â–¡

Lemma C.7 (Refinement Subtype). If Î“ âŠ¢ ğœ â€² <: ğœ, then Î“ âŠ¢ {ğ‘¥ : ğœ â€² | ğœ‘ } <: {ğ‘¥ : ğœ | ğœ‘ }.

Proof. Let E âŠ¢ Î“ and â„ âˆˆ âŸ¦{ğ‘¥ : ğœ â€²

| ğœ‘ }âŸ§E. Then â„ âˆˆ âŸ¦ğœ â€²âŸ§E, and âŸ¦ğœ‘âŸ§E [ğ‘¥â†¦â†’â„] = true. By
assumption Î“ âŠ¢ ğœ â€² <: ğœ, â„ âˆˆ âŸ¦ğœâŸ§E. Conclude â„ âˆˆ âŸ¦{ğ‘¥ : ğœ | ğœ‘ }âŸ§E by definition. The result
â–¡
follows.

Lemma C.8 (Sigma Left-Subtype). If Î“ âŠ¢ ğœ â€²

1 <: ğœ1 then Î“ âŠ¢ Î£ğ‘¥ : ğœ â€²

1.ğœ2 <: Î£ğ‘¥ : ğœ1.ğœ2.

Proof. Let E |= Î“, and â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ â€²

1âŸ§E and â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„]. By assumption Î“ âŠ¢ ğœ â€²
â„1 âˆˆ âŸ¦ğœ â€²
of the semantics, â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E. The result follows.

1.ğœ2âŸ§E. By definition of the semantics, â„ = â„1 ++ â„2,where
1 <: ğœ1 follows, â„1 âˆˆ âŸ¦ğœ1âŸ§E. By the definition
â–¡

Lemma C.9 (Sigma Right-Subtype). If Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²

2 <: ğœ2 then Î“ âŠ¢ Î£ğ‘¥ : ğœ1.ğœ â€²

2 <: Î£ğ‘¥ : ğœ1.ğœ2.

Proof. Let E |= Î“ and â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ â€²

2âŸ§E [ğ‘¥â†¦â†’â„1 ]. Notice that E [ğ‘¥ â†¦â†’ â„1] |= Î“, (ğ‘¥ : ğœ1), so by assumption Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²
â„2 âˆˆ âŸ¦ğœ â€²
â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ]. By the definition of the semantics â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E. The result follows.

2âŸ§E. By definition, â„ = â„1 ++ â„2 such that â„1 âˆˆ âŸ¦ğœ1âŸ§E, and
2 <: ğœ2 follows
â–¡

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:67

1 <: ğœ1 and Î“, (ğ‘¥ : ğœ â€²

1) âŠ¢ ğœ â€²

2 <: ğœ2, then Î“ âŠ¢ ğœ â€²

2 [ğ‘¥ â†¦â†’

Lemma C.10 (Substitution Subtype). If Î“ âŠ¢ ğœ â€²
1] <: ğœ2 [ğ‘¥ â†¦â†’ ğœ1].
ğœ â€²
Proof. Let E |= Î“ and â„2 âˆˆ âŸ¦ğœ â€²

Assumption Î“ âŠ¢ ğœ â€²
Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ â€²
â„2 âˆˆ âŸ¦ğœ2 [ğ‘¥ â†¦â†’ ğœ1]âŸ§E.

2 [ğ‘¥ â†¦â†’ ğœ â€²

1 <: ğœ1 tells us that â„1 âˆˆ âŸ¦ğœ1âŸ§E. Notice that E [ğ‘¥ â†¦â†’ â„1] |= Î“, (ğ‘¥ : ğœ â€²

2âŸ§E [ğ‘¥â†¦â†’â„1 ].
1). Assumption
2 <: ğœ2 gives â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ]. By the definition of the semantics of heap types,
â–¡

1]âŸ§E. Then we know â„1 âˆˆ âŸ¦ğœ â€²

1âŸ§E and â„2 âˆˆ âŸ¦ğœ â€²

Lemma C.11 (Choice Subtype). If Î“ âŠ¢ ğœ â€²
Proof. Let E |= Î“. Let â„ âˆˆ âŸ¦ğœ â€²

1 <: ğœ1, and Î“ âŠ¢ ğœ â€²

1 + ğœ â€²
2âŸ§E. By semantics of heap types, either â„ âˆˆ âŸ¦ğœ â€²

2 <: ğœ2, then Î“ âŠ¢ ğœ â€²

1 +ğœ â€²

2 <: ğœ1 + ğœ2
1âŸ§E or â„ âˆˆ âŸ¦ğœ â€²

2âŸ§E.
1 <: ğœ1 it also holds that â„ âˆˆ âŸ¦ğœ1âŸ§E and we can conclude

1âŸ§E: By assumption Î“ âŠ¢ ğœ â€²

Subcase â„ âˆˆ âŸ¦ğœ â€²

Subcase â„ âˆˆ âŸ¦ğœ â€²

2âŸ§E: By assumption Î“ âŠ¢ ğœ â€²

2 <: ğœ2 it also holds that â„ âˆˆ âŸ¦ğœ2âŸ§E and we can conclude

that â„ âˆˆ âŸ¦ğœ1 + ğœ2âŸ§E.

that â„ âˆˆ âŸ¦ğœ1 + ğœ2âŸ§E.

â–¡

Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²

Lemma C.12 (Context-Bound Refinement Subtype). If heap is the only free binder in ğœ‘, and
2 | ğœ‘ [ğ‘¥/heap]} <: {ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]}.
Proof. Let E |= Î“, ğ‘¥ : ğœ1. We can write this as E = E â€²[ğ‘¥ â†¦â†’ â„1], where â„1 âˆˆ âŸ¦ğœ1âŸ§E. Let
2âŸ§E and âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¦â†¦â†’â„2 ] = true. Compute as

2 <: ğœ2 then Î“, ğ‘¥ : ğœ1 âŠ¢ {ğ‘¦ : ğœ â€²

â„2 âˆˆ âŸ¦{ğ‘¦ : ğœ â€²
follows, recalling that heap is the only free binder in ğœ‘:

2 | ğœ‘ [ğ‘¥/heap]}âŸ§E. Then â„2 âˆˆ âŸ¦ğœ â€²

âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¦â†¦â†’â„2 ]
=âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E
=âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ]
=âŸ¦ğœ‘ [ğ‘¦/heap]âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ]
Together with assumption â„1 âˆˆ âŸ¦ğœ1âŸ§E, we get â„1 âˆˆ âŸ¦{ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}âŸ§Eâ€², and thus E â€²[ğ‘¥ â†¦â†’
â„1] |= Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}.

With assumption Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²

2 <: ğœ2, we can conclude that â„2 âˆˆ âŸ¦ğœ2âŸ§E. Since
we already have that âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¦â†¦â†’â„2 ] = true, it follows that â„2 âˆˆ âŸ¦{ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]}âŸ§E,
â–¡
which is what we wanted to show.

Lemma C.13 (If Choice Subtype). If heapis the only free binder in ğœ‘ and Î“, ğ‘¥ : {ğ‘¦ : ğœ â€²

ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²
12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ â€²
ğœ â€²
Proof. By Lemmas C.12 and C.11.

12 <: ğœ12, and Î“, ğ‘¥ : {ğ‘¦ : ğœ â€²

22 <: ğœ22, then Î“, ğ‘¥ : ğœ â€²
22 | ğœ‘ [ğ‘¥/heap]} <: {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}

1 | Â¬ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²

1 |
1 âŠ¢ {ğ‘¦ :

â–¡

Lemma C.14 (Algorithmic Weakening). If Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ2 and variable ğ‘¦ does not appear

free in ğœ1 or ğœ2, then Î“, ğ‘¦ : ğœ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ2 for any heap type ğœ.

Proof. By induction on the typing derivation.

â–¡

Lemma C.15 (Typing Context Subtype). If Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘ : (ğ‘¦ : ğœ12) â‡ ğœ22 and Î“ âŠ¢ ğœ â€²

1 <: ğœ1, then

Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğ‘ : (ğ‘¦ : ğœ12) â‡ ğœ22.

Proof. If ğ‘¥ is not free in ğœ12 or ğœ22, the result follows from Lemma C.14. Otherwise we proceed

by induction on the typing derivation. We refer to the general assumptions as follows:

(A) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘ : (ğ‘¦ : ğœ12) â‡ ğœ22
(B) Î“ âŠ¢ ğœ â€²

1 <: ğœ1

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:68

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case T-Extract-Algo: By inversion of T-Extract-Algo, we know
(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ extract (ğœ„) : (ğ‘¦ : ğœ12) â‡ ğœ22
(A2) ğœ22 = Î£ğ‘§ : {ğ‘£ : ğœ„ | ğœ‘1}.{ğ‘£ : chomp(ğœ12, ğœ„, ğ‘§) | ğœ‘2}
(A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 <: {ğ‘§ : âŠ¤ | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)}
By Lemma C.4 applied to (A3) and (B) follows
1 âŠ¢ ğœ12 <: {ğ‘§ : âŠ¤ | |ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)}

(A4) Î“, ğ‘¥ : ğœ â€²

The result follows by T-Extract-Algo.

Case T-Seq-Algo: By inversion of T-Seq-Algo, we know
(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘1; ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22
(A2) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘1 : (ğ‘¦ : ğœ12) â‡ ğœ â€²
12
12) â‡ ğœ â€²
(A3) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ12 âŠ¢ ğ‘2 : (ğ‘§ : ğœ â€²
22
(A4) ğœ22 = ğœ â€²
22 [ğ‘§ â†¦â†’ ğœ â€²

12]

(A5) Î“, ğ‘¥ : ğœ â€²

By IH applied to (A2) and (B) follows
1 âŠ¢ ğ‘1 : (ğ‘¦ : ğœ12) â‡ ğœ â€²
12
By IH applied to (A3) and (B) follows

(A6) Î“, ğ‘¥ : ğœ â€²

1, ğ‘¦ : ğœ12 âŠ¢ ğ‘2 : (ğ‘§ : ğœ â€²

12) â‡ ğœ â€²
22

The result follows by T-Seq-Algo with (A5) and (A6).

Case T-Skip-Algo: The result immediately follows by T-Skip-Algo.
Case T-Remit-Algo: By inversion of T-Remit-Algo, we know
(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 <: ğœ„â‰ˆ

By Lemma C.4 applied to (A1) and (B) follows

(A2) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ12 <: ğœ„â‰ˆ

The result follows by T-Remit-Algo.

Case T-Reset-Algo: The result immediately follows by T-Reset-Algo.
Case T-Ascribe-Algo: By inversion of T-Ascribe-Algo, we know
(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘0 ğ‘ğ‘  (ğ‘¦ : Ë†ğœ12) â†’ ğœ22 : (ğ‘¦ : ğœ12) â‡ ğœ22
(A2) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘0 : (ğ‘¦ : Ë†ğœ12) â‡ ğœ â€²
22
(A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 <: Ë†ğœ12
(A4) Î“, ğ‘¥ : ğœ1, ğ‘¦ : Ë†ğœ12 âŠ¢ ğœ â€²

22 <: ğœ22

By IH applied to (A2) and (B) follows
1 âŠ¢ ğ‘0 : (ğ‘¦ : Ë†ğœ12) â‡ ğœ â€²
22

(A5) Î“, ğ‘¥ : ğœ â€²

By Lemma C.4 applied to (A3) and (B) follows

(A6) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ12 <: Ë†ğœ12

By Lemma C.4 applied to (A4) and (B) follows
22 <: ğœ22

1, ğ‘¦ : Ë†ğœ12 âŠ¢ ğœ â€²

(A7) Î“, ğ‘¥ : ğœ â€²

The result follows by T-Ascribe-Algo with (A5), (A6) and (A7).

Case T-If-Algo:

By inversion of T-If-Algo, we know

(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘1 : (ğ‘¦ : {ğ‘§ : ğœ12 | ğœ‘ [ğ‘§/heap]}) â‡ ğœ â€²
12
(A2) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘1 : (ğ‘¦ : {ğ‘§ : ğœ12 | Â¬ğœ‘ [ğ‘§/heap]}) â‡ ğœ â€²â€²
12
(A3) ğœ22 = {ğ‘§ : ğœ â€²
(A4) Î“, ğ‘¥ : ğœ1; ğœ12 âŠ¢ ğœ‘ : B

12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘§ : ğœ â€²â€²

12 | Â¬ğœ‘ [ğ‘¥/heap]}

By IH applied to (A1) and (B) follows

(A5) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğ‘1 : (ğ‘¦ : {ğ‘§ : ğœ12 | ğœ‘ [ğ‘§/heap]}) â‡ ğœ â€²
12

By IH applied to (A2) and (B) follows

(A6) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğ‘1 : (ğ‘¦ : {ğ‘§ : ğœ12 | Â¬ğœ‘ [ğ‘§/heap]}) â‡ ğœ â€²â€²
12
Since Î“, ğ‘¥ : ğœ1; ğœ12 âŠ¢ ğœ‘ : B, it also holds that Î“, ğ‘¥ : ğœ â€²
T-If-Algo.

1; ğœ12 âŠ¢ ğœ‘ : B. The result then follows by

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:69

Case T-Mod-Algo: By inversion of T-Mod-Algo, we know
(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 <: ğœ„â‰ˆ
(A2) Î“, ğ‘¥ : ğœ1; ğœ12 âŠ¢ ğ‘’ : BV

By Lemma C.4 applied to (A1) and (B) follows

(A3) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ12 <: ğœ„â‰ˆ

Since Î“, ğ‘¥ : ğœ1; ğœ12 âŠ¢ ğ‘’ : BV, it also holds that Î“, ğ‘¥ : ğœ â€²
T-Mod-Algo.

1; ğœ12 âŠ¢ ğ‘’ : BV. The result follows by

Case T-Add-Algo: By inversion of T-Add-Algo, we know
(A1) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}

By Lemma C.4 applied to (A1) and (B) follows

(A2) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ12 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}
The result follows by T-Add-Algo.

â–¡

is not free in ğœ1 or ğœ â€²

Lemma C.16 (Algorithmic Input Subtype). If Î“ âŠ¢ ğœ â€²
1, then there exists ğœ â€²

2 such that Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ â€²
Proof. By induction on the typing derivation. We refer to the general assumptions as follows:
(A) Î“ âŠ¢ ğœ â€²
1 <: ğœ1
(B) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ2
(C) ğ‘¥ not free in ğœ1 or ğœ â€²
1

1 <: ğœ1 and Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ2 such that ğ‘¥
2 and Î“, ğ‘¥ : ğœ â€²

1) â‡ ğœ â€²

2 <: ğœ2.

1 âŠ¢ ğœ â€²

We refer to the proof goals as follows:

(1) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ â€²
(2) Î“, ğ‘¥ : ğœ â€²
1 âŠ¢ ğœ â€²

1) â‡ ğœ â€²
2
2 <: ğœ2

Case T-Extract-Algo: By inversion of T-Extract-Algo, we know
(A1) ğ‘ = extract (ğœ„)
(A2) Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)}
(A3) ğœ‘1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©
(A4) ğœ‘2 â‰œ ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥
(A5) ğœ21 â‰œ {ğ‘§ : ğœ„ | ğœ‘1}
(A6) ğœ22 â‰œ {ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘2}
(A7) ğœ2 = Î£ğ‘¦ : ğœ21.ğœ22

By Lemma C.2 with (A) and (A2),

(A8) Î“ âŠ¢ ğœ â€²

1 <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)}

By Lemma C.6 with (A2) and (A),

(A9) Î“, ğ‘¦ : ğœ21 âŠ¢ chomp(ğœ â€²

1, ğœ„, ğ‘¦) <: chomp(ğœ1, ğœ„, ğ‘¦)

(1) follows by T-Extract-Algo. (2) follows by Lemmas C.7 and C.9 and (A9).

Case T-Seq-Algo: By inversion of T-Seq-Algo, we know
(A1) ğ‘ = ğ‘1; ğ‘2
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â‡ ğœ12
(A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22
(A4) ğœ2 = ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

By IH applied to (A2) and (A), there is some ğœ â€²
12, and

1) â‡ ğœ â€²

12 such that

(A5) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ â€²
(A6) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ â€²

12 <: ğœ12

By Lemma C.15 with (A) and (A3),
1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22

(A7) Î“, ğ‘¥ : ğœ â€²

By IH applied to (A7) and (A6), there is some ğœ â€²

22 such that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:70

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

(A8) Î“, ğ‘¥ : ğœ â€²
(A9) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ â€²
1, ğ‘¦ : ğœ â€²
12 âŠ¢ ğœ â€²

12) â‡ ğœ â€²
22 <: ğœ22

22, and

(1) follows by T-Seq-Algo with (A5) and (A8). To show (2), we just need to show that
Î“, ğ‘¥ : ğœ â€²
12] <: ğœ22 [ğ‘¦ â†¦â†’ ğœ12]. This follows by Lemma C.10 applied to (A6) and
(A9).

22 [ğ‘¦ â†¦â†’ ğœ â€²

1 âŠ¢ ğœ â€²

Immediate by T-Skip-Algo.

Case T-Skip-Algo:
Case T-Remit-Algo: By inversion of T-Remit-Algo, we know
(A1) Î“ âŠ¢ ğœ1 <: ğœ„â‰ˆ
(A2) ğ‘ = remit (ğœ„)
(A3) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}

By Lemma C.2 with (A1) and (A) follows

(A4) Î“ âŠ¢ ğœ â€²
Let ğœ â€²
T-Remit-Algo. By Lemma C.4, and since ğ‘¥ does not occur free in ğœ1 or ğœ â€²

1 <: ğœ„â‰ˆ
2 = Î£ğ‘¦ : {ğ‘§ : ğœ â€²

1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„}. (1) follows by

1, we know

(A5) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ â€²

1 <: ğœ1

By Lemma C.7 we know
1 âŠ¢ {ğ‘§ : ğœ â€²

(A6) Î“, ğ‘¥ : ğœ â€²

1 | ğ‘§ â‰¡ ğ‘¥ } <: {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }

By Lemma C.8 with ğœ22 = {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„} follows

(A7) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ Î£ğ‘¦ : {ğ‘§ : ğœ â€²

1 | ğ‘§ â‰¡ ğ‘¥ }.ğœ22 <: Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.ğœ22

This shows (2) and concludes this case.

Case T-Reset-Algo: By inversion of T-Reset-Algo, we know
(A1) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› }

Let ğœ â€²

2 = ğœ2. (1) follows by T-Reset-Algo and (2) follows by Lemma C.1.

Case T-Ascribe-Algo: By inversion of T-Ascribe-Algo, we know
(A1) ğ‘ = ğ‘0 as (ğ‘¥ : Ë†ğœ1) â†’ ğœ2
(A2) Î“ âŠ¢ ğ‘0 : (ğ‘¥ : Ë†ğœ1) â‡ ğœğ‘
(A3) Î“ âŠ¢ ğœ1 <: Ë†ğœ1
(A4) Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœğ‘ <: ğœ2

By Lemma C.2 applied to (A) and (A3) follows that

(A5) Î“ âŠ¢ ğœ â€²
Let ğœ â€²

1 <: Ë†ğœ1
2 = ğœ2. (1) follows by T-Ascribe-Algo with (A2), (A4) and (A5). (2) follows by Lemma C.1.

Case T-If-Algo: By inversion of T-If-Algo, we know
(A1) ğ‘ = if (ğœ‘) then c1 else c2
(A2) Î“; ğœ1 âŠ¢ ğœ‘ : B
(A3) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â‡ ğœ12
(A4) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â‡ ğœ22
(A5) ğœ2 = {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}

By (A) and Lemma C.7, we know

(A6) Î“ âŠ¢ {ğ‘¦ : ğœ â€²
(A7) Î“ âŠ¢ {ğ‘¦ : ğœ â€²

1 | ğœ‘ [ğ‘¦/heap]} <: {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}, and
1 | Â¬ğœ‘ [ğ‘¦/heap]} <: {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}

By applying the IH to (A6) and (A3) we get ğœ â€²
12, and

1 | ğœ‘ [ğ‘¦/heap]}) â‡ ğœ â€²

(A8) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ â€²
(A9) Î“, ğ‘¥ : {ğ‘¦ : ğœ â€²

1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²

12 <: ğœ12

(A10) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ â€²
(A11) Î“, ğ‘¥ : {ğ‘¦ : ğœ â€²

By applying the IH to (A7) and (A4) we get ğœ â€²
22, and

1 | Â¬ğœ‘ [ğ‘¦/heap]}) â‡ ğœ â€²

1 | Â¬ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²
From (A2) and (A), we can conclude that

22 <: ğœ22

12 such that

22 such that

(A12) Î“; ğœ â€²

1 âŠ¢ ğœ‘ : B

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:71

22 | Â¬ğœ‘ [ğ‘¥/heap]}. (2) follows by Lemma C.13. (1)

2 = {ğ‘¦ : ğœ â€²

12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ â€²

Let ğœ â€²
follows by T-If-Algo with (A8), (A10) and (A12).
Case T-Mod-Algo: By inversion of T-Mod-Algo, we know
(A1) Î“ âŠ¢ ğœ1 <: ğœ„â‰ˆ
(A2) Î“; ğœ1 âŠ¢ ğ‘’ : BV
(A3) ğœ2 = {ğ‘¦ : âŠ¤ | ğœ‘ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}
By Lemma C.2 with (A) and (A1) follows

(A4) Î“ âŠ¢ ğœ â€²

1 <: ğœ„â‰ˆ

From (A2) and (A), we can conclude

(A5) Î“; ğœ â€²

1 âŠ¢ ğ‘’ : BV
2 = ğœ2. (1) follows by T-Mod-Algo with (A4) and (A5). (2) follows by Lemma C.1.

Let ğœ â€²

Case T-Add-Algo: By inversion of T-Add-Algo, we know
(A1) Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}
(A2) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }

By Lemma C.2 with (A1) and (A) follows

(A3) Î“ âŠ¢ ğœ â€²
Let ğœ â€²
T-Add-Algo. By Lemma C.4 with (A) and (C),

1 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}
2 = Î£ğ‘¦ : {ğ‘§ : ğœ â€²

1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„

| ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }. (1) follows by

(A4) Î“, ğ‘¥ : ğœ â€²

1 âŠ¢ ğœ â€²

1 <: ğœ1

By Lemma C.7 follows
1 âŠ¢ {ğ‘§ : ğœ â€²

(A5) Î“, ğ‘¥ : ğœ â€²

1 | ğ‘§ â‰¡ ğ‘¥ } <: {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }

(2) follows by Lemma C.8 with (A5).

â–¡

Lemma C.17 (Includes Subtype). Includes Î“ ğœ ğœ„ â‡â‡’ Î“ âŠ¢ ğœ <: ğœ„âˆ¼

Proof. Prove each direction separately

(â‡’) Assume Includes Î“ ğœ ğœ„. Let E |= Î“ and â„ âˆˆ âŸ¦ğœâŸ§E. By definition of the inclusion relation,
ğœ„ âˆˆ dom(â„). By the definition of subtyping, it suffices to show â„ âˆˆ âŸ¦ğœ„âˆ¼âŸ§E. By definition,
âŸ¦ğœ„âˆ¼âŸ§E = {â„ | ğœ„ âˆˆ dom(â„)}, and weâ€™re done.

(â‡) Assume Î“ âŠ¢ ğœ <: ğœ„âˆ¼. Show Includes Î“ ğœ ğœ„. To that end, let E |= Î“ and â„ âˆˆ âŸ¦ğœâŸ§E be arbitrary. By
the definition of subtyping, â„ âˆˆ âŸ¦ğœ„âˆ¼âŸ§E. By definition of the semantics, conclude ğœ„ âˆˆ dom(â„).
â–¡

Lemma C.18 (Excludes Subtype). Excludes Î“ ğœ ğœ„ iff Î“ âŠ¢ ğœ <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}

Proof. Prove each direction separately

(â‡’) Assume Excludes Î“ ğœ ğœ„. Let E |= Î“ and â„ âˆˆ âŸ¦ğœâŸ§E. By definition of the exclusion relation,
ğœ„ âˆ‰ dom(â„). By the definition of subtyping, it suffices to show â„ âˆˆ âŸ¦{ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}âŸ§E.
By definition, âŸ¦{ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}âŸ§E = {â„ | ğœ„ âˆ‰ dom(â„)}, and weâ€™re done.

(â‡) Assume Î“ âŠ¢ ğœ <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}. Show Excludes Î“ ğœ ğœ„. To that end, let E |= Î“ and
â„ âˆˆ âŸ¦ğœâŸ§E be arbitrary. By the definition of subtyping, â„ âˆˆ âŸ¦{ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}âŸ§E. By
definition of the semantics, conclude ğœ„ âˆ‰ dom(â„).

â–¡

Theorem C.19 (Algorithmic Typing Correctness). For all subtyping contexts Î“, commands ğ‘,
variables ğ‘¥, heap types ğœ1, and ğœ2, where ğ‘¥ is not free in ğœ1, Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 if and only if there is
some ğœ â€²

2 such that Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²

2, and Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ â€²

2 <: ğœ2.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:72

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Proof. (â‡’) Assume Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2. Proceed by induction on the typing derivation,

leaving Î“ general. We refer to the proof goals as follows:

(1) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²
2
(2) Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ â€²
2 <: ğœ2
Case T-Extract:

(A1) ğ‘ = extract (ğœ„)
(A2) Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ1) â‰¥ sizeof (ğ‘–)
(A3) ğœ‘1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©
(A4) ğœ‘2 â‰œ ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥
(A5) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğœ‘1}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘2}

The only algorithmic rule that applies to extract (ğœ„) is T-Extract-Algo. Since Î“ âŠ¢ ğœ1 <: {ğ‘¥ :
âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)} by (A2) and Lemma C.5, T-Extract-Algo produces ğœ â€²
2 such that
1 â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©
2 â‰œ ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥
2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğœ‘ â€²
1}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘ â€²
2}
which shows (1). (2) follows by Lemma C.1.

(A6) ğœ‘ â€²
(A7) ğœ‘ â€²
(A8) ğœ â€²

Case T-Seq:

(A1) ğ‘ = ğ‘1; ğ‘2
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â†’ ğœ12
(A3) Î“, (ğ‘¥ : ğœ1) âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â†’ ğœ22
(A4) ğœ2 = ğœ22 [ğ‘¥ â†¦â†’ ğœ12]

(A5) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â‡ ğœ â€²
(A6) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²

12 <: ğœ12

12, and

By applying the IH to (A2), we get ğœ â€²

12 such that

By applying the IH to (A3), we get ğœ â€²

22 such that

(A7) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ â€²
(A8) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ12 âŠ¢ ğœ â€²

22 <: ğœ22

22, and

(A9) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ â€²
(A10) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ â€²
12 âŠ¢ ğœ â€²â€²

By Lemma C.16 with (A6) and (A7) there exists ğœ â€²â€²
12) â‡ ğœ â€²â€²
22 <: ğœ â€²
22
By T-Seq-Algo with (A5) and (A9) follows

22, and

22 such that

(A11) Î“ âŠ¢ ğ‘1; ğ‘2 : (ğ‘¥ : ğœ1) â‡ ğœ â€²â€²

22 [ğ‘¦ â†¦â†’ ğœ â€²

12]

which shows (1). By Lemma C.4 with (A6) and (A8) follows

(A12) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ â€²

12 âŠ¢ ğœ â€²

22 <: ğœ22
By Lemma C.2 with (A10) and (A12) follows
22 <: ğœ22

12 âŠ¢ ğœ â€²â€²

(A13) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ â€²

By Lemma C.10 follows

(A14) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²â€²

22 [ğ‘¦ â†¦â†’ ğœ â€²

12] <: ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

which shows (2) and concludes this case.

Case T-Skip:
Case T-Remit: By inversion of T-Remit, we know

(1) follows by T-Skip-Algo and (2) follows by Lemma C.1.

(A1) ğ‘ = remit (ğœ„)
(A2) Includes Î“ ğœ1 ğœ„
(A3) ğœ‘ â‰œ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„
(A4) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğœ‘ }

By Lemma C.17 and (A2), T-Remit-Algo computes ğœ â€²

2 such that

(A5) Î“ âŠ¢ remit (ğœ„i) : ((ğ‘¥ : ğœ1)) â‡ ğœ â€²
(A6) ğœ â€²

2, and
2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğœ„}

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:73

which shows (1). Since ğœ â€²

2 = ğœ2, (2) follows by Lemma C.1.

Case T-Reset:
Case T-Ascribe: By inversion of T-Ascribe, we know

(1) follows by T-Reset-Algo and (2) follows by Lemma C.1.

(A1) ğ‘ = ğ‘0 as (ğ‘¥ : ğœ1) â†’ ğœ2
(A2) Î“ âŠ¢ ğ‘0 : (ğ‘¥ : ğœ1) â†’ ğœ2

By IH applied to (A2), there exists Ë†ğœ2 such that

(A3) Î“ âŠ¢ ğ‘0 : (ğ‘¥ : ğœ1) â‡ Ë†ğœ2
(A4) Î“, ğ‘¥ : ğœ1 âŠ¢ Ë†ğœ2 <: ğœ2

By T-Ascribe-Algo with (A3), (A4) and Lemma C.1,

(A5) Î“ âŠ¢ ğ‘0 as (ğ‘¥ : ğœ1) â†’ ğœ2 : (ğ‘¥ : ğœ1) â‡ ğœ2

showing (1). (2) follows by Lemma C.1.
Case T-If: By inversion of T-If, we know

(A1) ğ‘ = if (ğœ‘) then c1 else c2
(A2) Î“; ğœ1 âŠ¢ ğœ‘ : B
(A3) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ12
(A4) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ22
(A5) ğœ2 = {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}
By the IH applied to (A3) there exists ğœ â€²
12 such that
(A6) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â‡ ğœ â€²
12
(A7) Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²

12 <: ğœ12

By the IH applied to (A4) there exists ğœ â€²
22 such that
(A8) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â‡ ğœ â€²
22
(A9) Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ â€²

22 <: ğœ22

(1) follows by T-If-Algo with (A2), (A6) and (A8).
(2) follows by Lemma C.13 with (A7) and (A9).
Case T-Mod: By inversion of T-Mod, we know

(A1) ğ‘ = ğœ„.ğ‘“ := ğ‘’
(A2) Includes Î“ ğœ1 ğœ„
(A3) F (ğœ„, ğ‘“ ) = BV
(A4) Î“; ğœ1 âŠ¢ ğ‘’ : BV
(A5) ğœ2 = {ğ‘¦ : âŠ¤ | ğœ‘pkt âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}

By Lemma C.17 and (A2),

(A6) Î“ âŠ¢ ğœ1 <: ğœ„ğ‘–

(1) follows by T-Mod-Algo with (A3),(A4), (A5), and (A6). (2) follows by Lemma C.1.

Case T-Add: By inversion of T-Add, we know

(A1) Excludes Î“ ğœ1 ğœ„
(A2) initH T (ğœ„) = ğ‘£
(A3) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }

(1) follows by T-Add-Algo with (A1) and (A2). (2) follows by Lemma C.1.
Case T-Sub: By inversion of T-Sub, there exists some ğœ3 and ğœ4 such that

By Lemma C.18 and (A1),
(A4) Î“ âŠ¢ ğœ <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}

(A1) Î“ âŠ¢ ğœ1 <: ğœ3
(A2) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ4 <: ğœ2
(A3) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ3) â†’ ğœ4

By applying the IH to (A3) there is some ğœ â€²
4, and

(A4) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ3) â‡ ğœ â€²
(A5) Î“, ğ‘¥ : ğœ3 âŠ¢ ğœ â€²

4 <: ğœ4

4 such that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:74

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By Lemma C.4 together with (A1) and (A5), follows

By applying Lemma C.16 to (A1) and (A4) we get ğœ â€²â€²

4 such that

(A6) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²

4 <: ğœ4

(A7) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²â€²
(A8) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²â€²

4 <: ğœ â€²
4

4 , and

(1) follows by (A7). (2) follows by repeated application of Lemma C.2 with (A2), (A6) and
(A8).

(â‡) Proceed by induction on the typing derivation. We refer to the general assumptions as follows:

(A) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²
2
(B) Î“, (ğ‘¥ : ğœ1) âŠ¢ ğœ â€²
2 <: ğœ2

Case T-Extract-Algo: By inversion of T-Extract-Algo, we know

(A1) Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)}
(A2) ğœ â€²

2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğœ‘1}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘2}
By Lemma C.5 follows
(A3) Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ1) â‰¥ sizeof (ğœ„)

The result follows by T-Extract with (A3) and Lemma C.1.
Case T-Seq-Algo: By inversion of T-Seq-Algo, we know

(A1) ğ‘ = ğ‘1; ğ‘2
(A2) Î“ âŠ¢ ğ‘1 : ((ğ‘¥ : ğœ1)) â‡ ğœ12
(A3) Î“, (ğ‘¥ : ğœ1) âŠ¢ ğ‘2 : ((ğ‘¦ : ğœ12)) â‡ ğœ22
(A4) ğœ â€²
(A5) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²

2 = ğœ22 [ğ‘¦ â†¦â†’ ğœ12]
2 <: ğœ2

With Lemma C.1 follows

(A6) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 <: ğœ12

By IH with (A2) and (A6) follows

(A7) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â†’ ğœ12

Similarly, applying the IH to (A3) gives

(A8) Î“, (ğ‘¥ : ğœ1) âŠ¢ ğ‘2 : (ğ‘¥ : ğœ12) â†’ ğœ22

By T-Seq with (A7) and (A8) follows

(A9) Î“ âŠ¢ ğ‘1; ğ‘2 : (ğ‘¥ : ğœ1) â†’ ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

By (A4), (A5), Lemma C.1 and T-Sub follows

(A10) Î“ âŠ¢ ğ‘1; ğ‘2 : (ğ‘¥ : ğœ1) â†’ ğœ2

which concludes this case.

Case T-Skip-Algo:

The result follows by T-Skip, Lemma C.1, and T-Sub.

Case T-Remit-Algo: The result follows by T-Remit, Lemma C.17, Lemma C.1, and T-Sub.
Case T-Reset-Algo: The result follows by T-Reset, Lemma C.1, and T-Sub.
Case T-Ascribe-Algo: By inversion of T-Ascribe-Algo, we know

(A1) ğ‘ = ğ‘0 as (ğ‘¥ : Ë†ğœ1) â†’ ğœ â€²
2
(A2) Î“ âŠ¢ ğ‘0 : (ğ‘¥ : Ë†ğœ1) â‡ ğœ â€²â€²
2
(A3) Î“ âŠ¢ ğœ1 <: Ë†ğœ1
(A4) Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœ â€²â€²

2 <: ğœ â€²
2

By IH applied to (A2) and (A4), we get

(A5) Î“ âŠ¢ ğ‘0 : (ğ‘¥ : Ë†ğœ1) â†’ ğœ â€²
2
By T-Ascribe follows from (A5) that
2 : (ğ‘¥ : Ë†ğœ1) â†’ ğœ â€²
2

(A6) Î“ âŠ¢ ğ‘0 as (ğ‘¥ : Ë†ğœ1) â†’ ğœ â€²

The result follows by T-Sub with assumptions (B), (A3) and (A6).

Case T-If-Algo: By inversion of T-If-Algo, we know

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:75

(A1) ğ‘ = if (ğœ‘) then c1 else c2
(A2) Î“; ğœ1 âŠ¢ ğœ‘ : B
(A3) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â‡ ğœ12
(A4) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â‡ ğœ22
(A5) ğœ â€²

2 = {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}
By Lemma C.1, we can conclude
(A6) Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ12 <: ğœ12
By IH with (A3) and (A6) follows
(A7) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â†’ ğœ12

We can reason similarly as before to conclude

(A8) Î“ âŠ¢ ğ‘2 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â†’ ğœ22

The result follows by T-If with (A2), (A7), (A8) and (A5) and by T-Sub with assumption (B).
Case T-Mod-Algo: The result follows by T-Mod with Lemma C.17, Lemma C.1 and T-Sub.
Case T-Add-Algo: The result follows by T-Add with Lemma C.18, Lemma C.1 and T-Sub.
â–¡

D MTU BOUND
We want to prove a theorem that says that if we have an maximum transmission unit (MTU) ğ‘ for
a packet, then we can bound the number of bits in the types.

We want to prove that if a program typechecks with a bound on its input type, then we can
compute that maximum number of bits that we need to encode the input type. Ideally, this would
be the same bound; however, it is possible for the text of the program to emit more bits from the
incoming packet than is allowed by the MTU. So we define a helper function emit(ğ‘) âˆˆ N that
over-approximates the maximum number of bits that could be emitted along any program path in
ğ‘. This is defined in Figure 21

â‰œ 0

emit(extract (ğœ„))
emit(if (b) then c1 else c2) â‰œ max(emit(ğ‘1), emit(ğ‘2))
emit(ğ‘1; ğ‘2)
emit(ğœ„.ğ‘“ := ğ‘¡)
emit(remit (ğœ„))
emit(skip)
emit(reset)
emit(add (ğœ„))
emit(ğ‘ as ğœ)

â‰œ emit(ğ‘1) + emit(ğ‘2)
â‰œ 0
â‰œ sizeof(ğœ„)
â‰œ 0
â‰œ 0
â‰œ 0
â‰œ emit(ğ‘)

Fig. 21. emit(ğ‘) âˆˆ N computes the maximum number of bits that can be emitted along any path in c.

We also need a way to state that a type ğœ satisfies a given MTU ğ‘›; that is that for every denoted

heap â„, ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› and ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ use fewer than ğ‘› bits combined. This is defined formally in Figure 22.

Î“ âŠ¢ ğœ â‰¤ ğ‘› â‰œ âˆ€E |= Î“, âˆ€â„ âˆˆ âŸ¦ğœâŸ§E, |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘›

Fig. 22. Bound the size of types

We also need a few lemmas about how this interacts with various types

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:76

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Lemma D.1 (Refinement Bound). For every Î“, ğ‘¥, ğœ, ğœ‘, ğ‘ , such that Î“ âŠ¢ ğœ â‰¤ ğ‘ , Î“ âŠ¢ {ğ‘¥ : ğœ | ğœ‘ } â‰¤ ğ‘ .
Proof. Let Î“, ğ‘¥, ğœ, ğœ‘, ğ‘ , be given such that Î“ âŠ¢ ğœ â‰¤ ğ‘ . Let E |= Î“. Further, let â„ âˆˆ âŸ¦{ğ‘¥ : ğœ | ğœ‘ }âŸ§E.
By the semantics of heap types, we also know that â„ âˆˆ âŸ¦ğœâŸ§E. Assumption Î“ âŠ¢ ğœ â‰¤ ğ‘ gives us that
â–¡
|â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ , which is what we want to show.

Lemma D.2 (Bound Constraints). For every Î“, ğ‘¥, ğ‘¦, ğœ1, ğœ2, and ğœ‘, such that heap is the only free
variable in ğœ‘, Î“, ğ‘¥ : ğœ1 âŠ¢ {ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]} â‰¤ ğ‘ , if and only if Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ2 â‰¤ ğ‘ .

Proof. Let Î“, ğ‘¥, ğ‘¦, ğœ1, ğœ2, and ğœ‘ be given. Prove each direction separately.

(â‡’) Assume Î“, ğ‘¥ : ğœ1 âŠ¢ {ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]} â‰¤ ğ‘ .

Let E |= Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}. We can write E = E â€²[ğ‘¥ â†¦â†’ â„] for some E â€² |= Î“, and
some â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€², such that âŸ¦ğœ‘ [ğ‘¦/heap]âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ] = âŸ¦ğœ‘âŸ§Eâ€² [heapâ†¦â†’â„1 ] = true. Since ğ‘¦ does not
occur in ğœ‘, then we also have âŸ¦ğœ‘âŸ§E [heapâ†¦â†’â„,ğ‘¦â†¦â†’â„2 ] = true.
Now, consider â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ]. To show that |â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ .
Since âŸ¦ğœ‘âŸ§E [heapâ†¦â†’â„,ğ‘¦â†¦â†’â„2 ] = true = âŸ¦ğœ‘ [ğ‘¥/heap]âŸ§E [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„2 ], we can conclude that â„2 âˆˆ
âŸ¦{ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]}âŸ§Eâ€² [ğ‘¥â†¦â†’â„]. Now, since E â€²[ğ‘¥ â†¦â†’ â„] |= Î“, (ğ‘¥ : ğœ1), the result follows by our
initial assumption assumption Î“, (ğ‘¥ : ğœ1) âŠ¢ {ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]} â‰¤ ğ‘ .

(â‡) Assume Î“, (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) âŠ¢ ğœ2 â‰¤ ğ‘ .

Let E |= Î“, (ğ‘¥ : ğœ1). We can write E = E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€² and E â€² |= Î“.
Now consider â„2 âˆˆ âŸ¦{ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]}âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ]. To show |â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„2 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| < ğ‘ .
By the semantics of heap types, we have âŸ¦ğœ‘âŸ§Eâ€² [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„2 ] = âŸ¦ğœ‘âŸ§Eâ€² [heapâ†¦â†’â„1,ğ‘¦â†¦â†’â„2 ] = true.
Since ğ‘¦ is not free in ğœ‘, we also have âŸ¦ğœ‘âŸ§Eâ€² [heapâ†¦â†’â„1 ] = âŸ¦ğœ‘ [ğ‘¦/heap]âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ] = true, so we
can conclude that â„1 âˆˆ âŸ¦{ğ‘¦ : ğœ1 | ğ‘’ [ğ‘¦/heap]}âŸ§Eâ€². By our initial assumption, every heap in ğœ2
is bounded and as such also heap â„2 âˆˆ âŸ¦{ğ‘¦ : ğœ2 | ğœ‘ [ğ‘¥/heap]}âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ].

â–¡

Lemma D.3 (Bound Choice). If Î“ âŠ¢ ğœ1 â‰¤ ğ‘ and Î“ âŠ¢ ğœ2 â‰¤ ğ‘€, then Î“ âŠ¢ ğœ1 + ğœ2 â‰¤ max(ğ‘€, ğ‘ ).
Proof. Let E |= Î“ and â„ âˆˆ âŸ¦ğœ1+ğœ2âŸ§E. We have to show that |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)|+|â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ max(ğ‘€, ğ‘ ).

Case ğ‘€ = ğ‘ :

Assume ğ‘€ = ğ‘ , so max(ğ‘€, ğ‘ ) = ğ‘€ = ğ‘ . By the semantics of heap types â„ âˆˆ âŸ¦ğœ1âŸ§E or
â„ âˆˆ âŸ¦ğœ2âŸ§E.
Subcase â„ âˆˆ âŸ¦ğœ1âŸ§E: The result immediately follows by assumption Î“ âŠ¢ ğœ1 â‰¤ ğ‘ .
Subcase â„ âˆˆ âŸ¦ğœ2âŸ§E: The result immediately follows by assumption Î“ âŠ¢ ğœ2 â‰¤ ğ‘€.

Case ğ‘€ > ğ‘ : Without loss of generality, we assume that ğ‘€ > ğ‘ , so max(ğ‘€, ğ‘ ) = ğ‘€. By the

semantics of heap types â„ âˆˆ âŸ¦ğœ1âŸ§E or â„ âˆˆ âŸ¦ğœ2âŸ§E.
Subcase â„ âˆˆ âŸ¦ğœ1âŸ§E: By assumption Î“ âŠ¢ ğœ1 â‰¤ ğ‘ and since by assumption ğ‘ < ğ‘€, it follows

Î“ âŠ¢ ğœ1 â‰¤ ğ‘€.

Subcase â„ âˆˆ âŸ¦ğœ2âŸ§E: The result immediately follows by assumption Î“ âŠ¢ ğœ2 â‰¤ ğ‘€.

â–¡

Lemma D.4 (Bound Substitution). For all Î“, ğ‘¦, ğœ1, ğœ2, ğ‘ , Î“ âŠ¢ ğœ2 [ğ‘¦ â†¦â†’ ğœ1] â‰¤ ğ‘ if and only if

Î“, (ğ‘¦ : ğœ1) âŠ¢ ğœ2 â‰¤ ğ‘ .

Proof. Let Î“, ğ‘¦, ğœ1, ğœ2, and ğ‘ be given. Prove each direction separately:
(â‡’) Assume Î“ âŠ¢ ğœ2 [ğ‘¦ â†¦â†’ ğœ2] â‰¤ ğ‘ . Let E |= Î“, ğ‘¦ : ğœ1 such that â„2 âˆˆ âŸ¦ğœ2âŸ§E. This means there is
some E â€² |= Î“ and â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€² such that â„2 âˆˆ âŸ¦ğœ2âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ]. By the semantics of heap types
follows that â„2 âˆˆ âŸ¦ğœ2 [ğ‘¦ â†¦â†’ ğœ1]âŸ§Eâ€². With the initial assumption Î“ âŠ¢ ğœ2 [ğ‘¦ â†¦â†’ ğœ1] â‰¤ ğ‘ , we can
conclude that |â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ .

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:77

(â‡) Assume Î“, ğ‘¦ : ğœ1 |= ğœ2 â‰¤ ğ‘ . Let E |= Î“ and let â„2 âˆˆ âŸ¦ğœ2 [ğ‘¦ â†¦â†’ ğœ1]âŸ§E. By the semantics of heap
types, there is some â„1 âˆˆ âŸ¦ğœ1âŸ§E such that â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¦â†¦â†’â„1 ]. Notice that E [ğ‘¦ â†¦â†’ â„1] |= Î“, ğ‘¦ : ğœ1.
The initial assumption proves that |â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ .

â–¡

We can then formulate the following two theorems.

Theorem D.5 (Forwards MTU Bound). For every Î“, ğ‘, ğ‘¥, ğœ1, ğœ2, and ğ‘ âˆˆ N, if Î“ âŠ¢ ğœ1 â‰¤ ğ‘ and
Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ2 and every ascribed type in ğ‘ is also bounded by ğ‘ , then Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ +emit(ğ‘)

Proof. Proceed by induction on ğ‘, leaving Î“ and ğ‘ general. We refer to the general assumptions

as follows:

(A) Î“ âŠ¢ ğœ1 â‰¤ ğ‘
(B) Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ2

Case extract (ğœ„):

The only algorithmic typing rule that applies to extract (ğœ„) is T-Extract-Algo. By inversion,
we know

(A1) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğœ‘1}.{ğ‘§ : chomp(ğœ1, ğœ„, ğ‘¦) | ğœ‘2}
(A2) ğœ‘1 = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©
(A3) ğœ‘2 = ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥.

Since emit(extract (ğœ„)) = 0, it suffices to show Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ .
Let E |= Î“, ğ‘¥ : ğœ1 and let â„2 âˆˆ âŸ¦ğœ2âŸ§E. We can write E as E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€².
By definition of the semantics of heap types we know there are some â„21 and â„22 such that

(A4) â„2 = â„21 ++ â„22,
(A5) â„21(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„21 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©
(A6) â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„21(ğœ„)@â„22 (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)
(A7) â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„22 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )

We can further conclude that

(A8) â„2 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ),
(A9) â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„22 (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [|ğœ„| :]

From assumption (A) follows
(A10) |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘

Together with (A8) and (A9), we can conclude that |â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| < |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| +
|â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ .

Case addğœ„:

The only algorithmic typing rule that applies to addğœ„ is T-Add-Algo. By inversion, we know

(A1) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğœ„ = ğ‘£ }.
Since emit(addğœ„) = 0, it suffices to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ .
Let E |= Î“, ğ‘¥ : ğœ1, and â„2 âˆˆ âŸ¦ğœ2âŸ§E. We can write E as E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€².
By definition of the semantics of heap types we know there are some â„21 and â„22 such that

(A2) â„2 = â„21 ++ â„22
(A3) â„21 = â„1
(A4) â„22 (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„22 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©

From these three equations we can conclude that

(A5) â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)
(A6) â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )

The result follows by assumption (A).

Case ğœ„.ğ‘“ := ğ‘’:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:78

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

The only algorithmic typing rule that applies to ğœ„.ğ‘“ := ğ‘’ is T-Mod-Algo. By inversion, we
know

(A1) ğœ2 = {ğ‘¦ : âŠ¤ | ğœ‘ğ‘ğ‘˜ğ‘¡ âˆ§ ğœ‘ğœ„ âˆ§ ğœ‘ ğ‘“ âˆ§ ğ‘¦.ğœ„.ğ‘“ = ğ‘’ [ğ‘¥/heap]}
(A2) ğœ‘ğ‘ğ‘˜ğ‘¡ = ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡

Since emit(ğœ„.ğ‘“ := ğ‘’) = 0, it suffices to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ .
Let E |= Î“, ğ‘¥ : ğœ1 and â„2 âˆˆ âŸ¦ğœ2âŸ§E. We can write E as E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€². From
assumption (A1) and by the semantics of heap types follows

(A3) â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)
(A4) â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )

The result follows by assumption (A).

Case remit (ğœ„):

The only algorithmic typing rule that applies to remit (ğœ„) is T-Remit-Algo. By inversion, we
know

(A1) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ1 | ğ‘§ â‰¡ ğ‘¥ }.{ğ‘§ : ğœ– | ğœ‘ }
(A2) ğœ‘ = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğœ„

Since emit(remit (ğœ„)) = sizeof (ğœ„), we have to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ + sizeof(ğœ„).
Let E |= Î“, ğ‘¥ : ğœ1 and â„2 âˆˆ âŸ¦ğœ2âŸ§E. We can write E as E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€². By the
semantics of heap types, there exists â„21 and â„22 such that

(A3) â„2 = â„21 ++ â„22
(A4) â„21 = â„1
(A5) â„22 (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = âŸ¨âŸ©
(A6) â„22 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğœ„)

From (A4) and (A5), we can conclude that

(A7) â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)

From (A4) and (A6), we can further conclude that

(A8) â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )@â„1(ğœ„)

From (A7) and (A8) then follows

(A9) |â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| = |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| + sizeof(ğœ„)

Together with assumption (A), we can conclude that |â„2 (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ + sizeof (ğœ„).

Case reset:

The only algorithmic typing rule that applies to reset is T-Reset-Algo. By inversion, we
know

(A1) ğœ2 = Î£ğ‘¦ : {ğ‘§ : ğœ– | ğœ‘1}.{ğ‘§ : ğœ– | ğœ‘2}
(A2) ğœ‘1 = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡
(A3) ğœ‘2 = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ© âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›

Since emit(reset) = 0, we have to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ .
Let E |= Î“, ğ‘¥ : ğœ1 and â„2 âˆˆ âŸ¦ğœ2âŸ§E. We can write E as E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€². By the
semantics of heap types, there exists â„21 and â„22 such that

(A4) â„2 = â„21 ++ â„22
(A5) â„21 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©
(A6) â„21(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )
(A7) â„22 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©
(A8) â„22 (ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)

By (A4), (A5) and (A7) follows

(A9) â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ©

and by (A4), (A6) and (A8) follows
(A10) â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )@â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:79

Since by assumption (A), |â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| + |â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ , by (A9) and (A10), |â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)| +
|â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )| â‰¤ ğ‘ .

Case if (ğœ‘) then c1 else c2: The only algorithmic typing rule that applies is T-If-Algo. By inversion,

we know

(A1) ğœ2 = {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]}
(A2) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]}) â‡ ğœ12
(A3) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]}) â‡ ğœ22

Since emit(if (ğœ‘) then c1 else c2) = max(emit(ğ‘1), emit(ğ‘2)), we have to show that Î“, ğ‘¥ : ğœ1 âŠ¢
ğœ2 â‰¤ ğ‘ + max(emit(ğ‘1), emit(ğ‘2)).
By Lemma D.1 and assumption (A) follows

(A4) Î“ âŠ¢ {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} â‰¤ ğ‘
(A5) Î“ âŠ¢ {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]} â‰¤ ğ‘

Applying the IH to (A2) and (A2) with (A4) and (A5) respectively, gives

(A6) Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ12 â‰¤ ğ‘ + emit(ğ‘1)
(A7) Î“, ğ‘¥ : {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]} âŠ¢ ğœ22 â‰¤ ğ‘ + emit(ğ‘2)

By Lemma D.2 with (A6) and (A7) respectively follows

(A8) Î“, ğ‘¥ : ğœ1 âŠ¢ {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} â‰¤ ğ‘ + emit(ğ‘1)
(A9) Î“, ğ‘¥ : ğœ1 âŠ¢ {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]} â‰¤ ğ‘ + emit(ğ‘2)
By Lemma D.3 with (A8) and (A9) follows

(A10) Î“, ğ‘¥ : ğœ1 âŠ¢ {ğ‘¦ : ğœ12 | ğœ‘ [ğ‘¥/heap]} + {ğ‘¦ : ğœ22 | Â¬ğœ‘ [ğ‘¥/heap]} â‰¤ max(ğ‘ + emit(ğ‘1), ğ‘ + emit(ğ‘2))

The result follows together with the fact that max(ğ´ + ğµ, ğ´ + ğ¶) = ğ´ + max(ğµ, ğ¶).

Case ğ‘1; ğ‘2:

The only algorithmic typing rule that applies to ğ‘1; ğ‘2 is T-Seq-Algo. By inversion, we know

(A1) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â‡ ğœ12
(A2) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22
(A3) ğœ2 = ğœ22 [ğ‘¦ â†¦â†’ ğœ12]

Since emit(ğ‘1; ğ‘2) = emit(ğ‘1) + emit(ğ‘2), we have to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ + emit(ğ‘1) +
emit(ğ‘2). Let E |= Î“, ğ‘¥ : ğœ1 and let â„2 âˆˆ âŸ¦ğœ2âŸ§E.
By applying the IH to (A1), we get

(A4) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 â‰¤ ğ‘ + emit(ğ‘1)

Since we left Î“ and ğ‘ general, we can apply the IH again to (A2) and get

(A5) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ12 âŠ¢ ğœ22 â‰¤ ğ‘ + emit(ğ‘1) + emit(ğ‘2)
The result follows by Lemma D.4 with (A5).

Case skip:

(A1) ğœ2 = {ğ‘¦ : ğœ1 | ğ‘¦ â‰¡ ğ‘¥ }

The only algorithmic typing rule that applies to skip is T-Skip-Algo. By inversion, we know

Since emit(skip) = 0, we have to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ .
Let E |= Î“, ğ‘¥ : ğœ1 and â„2 âˆˆ âŸ¦ğœ2âŸ§E. We can write E as E â€²[ğ‘¥ â†¦â†’ â„1] where â„1 âˆˆ âŸ¦ğœ1âŸ§Eâ€².
By the semantics of heap types, follows

(A2) â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)
(A3) â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )

The result follows by assumption (A).

Case ğ‘0 as (ğ‘¥ : Ë†ğœ1) â†’ ğœ2:

The only algorithmic typing rule that applies is T-Ascribe-Algo. By inversion, we know

(A1) Î“ âŠ¢ ğ‘0 : (ğ‘¥ : Ë†ğœ1) â‡ ğœğ‘
(A2) Î“ âŠ¢ ğœ1 <: Ë†ğœ1
(A3) Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœğ‘ <: ğœ2

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:80

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Since emit(ğ‘0 as ğœ) = emit(ğ‘0), we have to show that Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ2 â‰¤ ğ‘ + emit(ğ‘0). By our
initial assumption, every ascribed type is also bounded by ğ‘ . We therefore have Î“, ğ‘¥ : ğœ1 âŠ¢
ğœ2 â‰¤ ğ‘ from which the result immediately follows.

â–¡

Theorem D.6 (Decidability). If Î“, ğœ1, ğœ2 and every ascribed type in ğ‘ are bounded by the MTU ğ‘ ,

then Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â†’ ğœ2 is decidable.

Proof. By Theorem C.19 (Algorithmic Typing Correctness), we can equivalently show that
2 is bounded.

2 <: ğœ2 are decidable. By Theorem D.5, ğœ â€²

2 and Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²

Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²
Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ â€²

2 <: ğœ2 is therefore decidable by finite enumeration.

To show that Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²

2 is decidable, we proceed by induction on the algorithmic

typing derivation.
Case T-Skip-Algo:

Immediate, because T-Skip-Algo does not perform any subtyping checks.

Case T-Reset-Algo:

Also immediate, because T-Reset-Algo does not perform any subtyping checks.

Case T-Seq-Algo:

By inversion of T-Seq-Algo,

(A1) Î“ âŠ¢ ğ‘1 : (ğ‘¥ : ğœ1) â‡ ğœ12
(A2) Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22

By (A1) and Theorem D.5,
(A3) Î“, ğ‘¥ : ğœ1 âŠ¢ ğœ12 â‰¤ ğ‘ + emit(ğ‘1)

Applying the IH to (A1) with assumption Î“ âŠ¢ ğœ1 â‰¤ ğ‘ and (A3) gives us that Î“ âŠ¢ ğ‘1 : (ğ‘¥ :
ğœ1) â‡ ğœ12 is decidable.
Again, by Theorem D.5 with (A2) and (A3), follows

(A4) Î“, ğ‘¥ : ğœ1, ğ‘¦ : ğœ12 âŠ¢ ğœ22 â‰¤ ğ‘ + emit(ğ‘1) + emit(ğ‘2)

By IH follows that Î“, ğ‘¥ : ğœ1 âŠ¢ ğ‘2 : (ğ‘¦ : ğœ12) â‡ ğœ22 is decidable and thus typechecking the
sequence of both commands is decidable.

Case T-Add-Algo:

Case T-Extract-Algo:

By inversion, we know that T-Add-Algo performs the subtyping check Î“ âŠ¢ ğœ1 <: {ğ‘¥ :
âŠ¤ | Â¬ğ‘¥ .ğœ„.valid}. To show that typechecking is decidable in this case, we must show that
Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ | Â¬ğ‘¥ .ğœ„.valid} is decidable. This is the case because we can finitely enumerate
the heaps â„ described by ğœ1 and check wether every â„ is a member of {ğ‘¥ : âŠ¤ | Â¬ğ‘¦.ğœ„.valid}.

By inversion, we know that T-Extract-Algo performs the subtyping check Î“ âŠ¢ ğœ1 <: {ğ‘¥ :
âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof (ğœ„)}. To show that typechecking is decidable in this case, we must show
that Î“ âŠ¢ ğœ1 <: {ğ‘¥ : âŠ¤ |
|ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof(ğœ„)} is decidable. This is the case because we can
finitely enumerate the heaps â„ described by ğœ1 and check wether every â„ is a member of
{ğ‘¥ : âŠ¤ | |ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› | â‰¥ sizeof(ğœ„)}.

Case T-Remit-Algo:

Identical to the previous subcase.

Case T-Mod-Algo:

Identical to the previous subcase.

Case T-If-Algo:

Since ğœ1 is bounded by assumption and refining the input type does not increase the size,
{ğ‘¦ : ğœ1 | ğœ‘ [ğ‘¦/heap]} and {ğ‘¦ : ğœ1 | Â¬ğœ‘ [ğ‘¦/heap]} are still bounded. By Theorem D.5 then
follows that the output types of ğ‘1 and ğ‘2 are also bounded. By IH applied to ğ‘1 and ğ‘2, we

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:81

get that the algorithmic type checking applied to ğ‘1 and ğ‘2 respectively is decidable and thus
checking the conditional is decidable.

Case T-Ascribe-Algo:

By assumption, Î“, ğœ1 and Ë†ğœ1 are bounded, so Î“ âŠ¢ ğœ1 <: Ë†ğœ1 is decidable by finite enumeration.
Since by assumption Î“ âŠ¢ ğœ1 â‰¤ ğ‘ , by Theorem D.5 follows that Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœğ‘ â‰¤ ğ‘ +emit(ğ‘0). By
IH then follows that Î“ âŠ¢ ğ‘ : (ğ‘¥ : ğœ1) â‡ ğœ â€²
2 is decidable. Since ğœğ‘ is bounded and by assumption
2 is also decidable and thus
also ğœ â€²
typechecking an ascribed command is decidable.

2 is bounded, we can finitely enumerate, so Î“, ğ‘¥ : Ë†ğœ1 âŠ¢ ğœğ‘ <: ğœ â€²

E REWRITE OPTIMIZATION CORRECTNESS

Definition E.1 (Type Equivalence). We write Î“ âŠ¢ ğœ1 (cid:17) ğœ2 for the equivalence of types ğœ1 and ğœ2 in

context Î“, i.e., Î“ âŠ¢ ğœ1 (cid:17) ğœ2 â‰œ âˆ€E |= Î“.âŸ¦ğœ1âŸ§E = âŸ¦ğœ2âŸ§E

Lemma E.2 (Rewriting Sigma Types). In any context Î“,

â–¡

Î“ âŠ¢ Î£ğ‘¥ : ğœ1.ğœ2
(cid:17)
(cid:18) ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›@ğ‘Ÿ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§
ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ @ğ‘Ÿ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡

âˆ§

(cid:19)

(cid:211)ğœ„ âˆˆdom( H T) (cid:169)
(cid:173)
(cid:171)

ğ‘¦.ğœ„.valid = ğ‘¥ .ğœ„.valid âŠ• ğ‘Ÿ .ğœ„.valid âˆ§
ğ‘¥ .ğœ„.valid =â‡’ ğ‘¦.ğœ„ = ğ‘¥ .ğœ„ âˆ§
ğ‘Ÿ .ğœ„.valid =â‡’ ğ‘¦.ğœ„ = ğ‘Ÿ .ğœ„

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

ğ‘¦ : âŠ¤

ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´

ï£³

Proof. Proof each direction separately.

[ğ‘Ÿ â†¦â†’ ğœ2] [ğ‘¥ â†¦â†’ ğœ1]

ï£¼ï£´ï£´ï£´ï£´ï£´ï£´ï£½
ï£´ï£´ï£´ï£´ï£´ï£´

ï£¾

(cid:170)
(cid:174)
(cid:172)

(â‡’) Let E |= Î“ and let â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E. By the semantics of heap types, we know there exists â„1

and â„2 such that â„ = â„1 ++ â„2 and â„1 âˆˆ âŸ¦ğœ1âŸ§E and â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ].
By definition of heap concatenation, â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)@â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) and also â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) =
â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )@â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ). Further, dom(â„) is the disjoint union of dom(â„1) and dom(â„2) such
that if ğœ„ âˆˆ dom(â„ğ‘– ), â„(ğœ„) = â„ğ‘– (ğœ„) for each ğ‘– = 1, 2 and each ğœ„ âˆˆ dom(H T ). The result follows
by definition of the semantics.

(â‡) Let E |= Î“. By the definition of the semantics, it suffices to show, for â„1 âˆˆ âŸ¦ğœ1âŸ§E, and
â„2 âˆˆ âŸ¦ğœ2âŸ§E [ğ‘¥â†¦â†’â„1 ], and â„ âˆˆ âŸ¦âŠ¤âŸ§E [ğ‘¥â†¦â†’â„1,ğ‘Ÿ â†¦â†’â„2 ] such that the above refinement holds for â„, that
â„ âˆˆ âŸ¦Î£ğ‘¥ : ğœ1.ğœ2âŸ§E. By the semantics of heap types, it suffices to show that â„ = â„1 ++ â„2. The
refinement tells us that
â€¢ â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)@â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) and
â€¢ â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )@â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ).
Further, dom(â„) is the disjoint union of dom(â„1) and dom(â„2) such that if ğœ„ âˆˆ dom(â„ğ‘– ),
â„(ğœ„) = â„ğ‘– (ğœ„) for each ğ‘– = 1, 2 and each ğœ„ âˆˆ dom(H T ).

â–¡

Lemma E.3 (Rewriting Refinement Types). For Î“, ğœ, ğœ„, ğ‘¥, ğ‘¦, such that ğ‘¥ and ğ‘¦ do not occur free

in ğœ,

Î“, (ğ‘¥ : ğœ) âŠ¢ {ğ‘¦ : ğœ | ğ‘¥ â‰¡ ğ‘¦} (cid:17) {ğ‘¦ : âŠ¤ | ğ‘¥ â‰¡ ğ‘¦}

Proof. Prove each direction separately.

(â‡’) Let E |= Î“, (ğ‘¥ : ğœ). We know E = E â€²[ğ‘¥ â†¦â†’ â„1] such that â„1 âˆˆ âŸ¦ğœâŸ§Eâ€². Let â„2 âˆˆ âŸ¦{ğ‘¦ : ğœ | ğ‘¥ â‰¡
ğ‘¦}âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ]. Then â„2 âˆˆ âŸ¦ğœâŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ] and âŸ¦ğ‘¥ â‰¡ ğ‘¦âŸ§Eâ€² [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„2 ] = true. From the latter, we
can conclude that â„2 = â„1. To show â„2 âˆˆ âŸ¦{ğ‘¦ : âŠ¤ | ğ‘¦ â‰¡ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ], we have to show that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:82

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

â„2 âˆˆ âŸ¦âŠ¤âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ], which is immediate, and âŸ¦ğ‘¥ â‰¡ ğ‘¦âŸ§Eâ€² [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„2 ] = true, which immediately
follows by the fact that â„2 = â„1.

(â‡) Let E |= Î“, (ğ‘¥ : ğœ). We know E = E â€²[ğ‘¥ â†¦â†’ â„1] such that â„1 âˆˆ âŸ¦ğœâŸ§Eâ€². Let â„2 âˆˆ âŸ¦{ğ‘¦ : âŠ¤ | ğ‘¥ â‰¡
ğ‘¦}âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ]. Then â„2 âˆˆ âŸ¦âŠ¤âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ], and âŸ¦ğ‘¥ â‰¡ ğ‘¦âŸ§E [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„2 ] = true. Observe that â„1 = â„2.
To show that â„2 âˆˆ âŸ¦{ğ‘¦ : ğœ | ğ‘¦ â‰¡ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ], we must show that â„2 âˆˆ âŸ¦ğœâŸ§Eâ€² [ğ‘¥â†¦â†’â„1 ] and
âŸ¦ğ‘¥ â‰¡ ğ‘¦âŸ§E [ğ‘¥â†¦â†’â„1,ğ‘¦â†¦â†’â„2 ] = true. The first follows by assumption that â„1 âˆˆ âŸ¦ğœâŸ§Eâ€² and the fact
that â„2 = â„1. The second immediately follows from â„2 = â„1.

â–¡

Lemma E.4. For all Î“, ğ‘¥, ğœ and ğœ„, if Î“ âŠ¢ sizeofğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› (ğœ) â‰¥ sizeof(ğœ„) and ğ‘¥ does not occur free in ğœ,

then

Î£ğ‘¦ :

(cid:26)
ğ‘§ : ğœ„

(cid:12)
(cid:12)
(cid:12)
(cid:12)

ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = âŸ¨âŸ© âˆ§
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©

(cid:27)

.

Î“, ğ‘¥ : ğœ âŠ¢

ğ‘§ : chomp(ğœ, ğœ„, ğ‘¦)

ï£±ï£´ï£´ï£²
ï£´ï£´
ï£³

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥

ï£¼ï£´ï£´ï£½
ï£´ï£´
ï£¾

(cid:17)
ğ‘¦.ğœ„.valid âˆ§ (cid:211)ğœ… âˆˆdom( H T)âˆ§ğœ…â‰ ğœ„ ğ‘¦.ğœ… = ğ‘¥ .ğœ… âˆ§
ğ‘¦.ğœ„@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§

(cid:27)

(cid:26)
ğ‘¦ : âŠ¤

(cid:12)
(cid:12)
(cid:12)
(cid:12)

[Rewrite Sigma Extract]

Proof. Proof each direction separately.
(â‡’) Let E |= Î“, ğ‘¥ : ğœ. We know E = E â€²[ğ‘¥ â†¦â†’ â„] such that â„ âˆˆ âŸ¦ğœâŸ§Eâ€². Let â„Î£ âˆˆ âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ„ |
ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§
ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„] be arbitrary. By the semantics of heap types follows

(A1) â„Î£ = â„1 ++ â„2
(A2) â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§Eâ€² [ğ‘¥â†¦â†’â„]
(A3) â„2 âˆˆ âŸ¦{ğ‘§ : chomp(ğœ, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ]
(A4) â„2 âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¦)âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ]
(A5) âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1,ğ‘§â†¦â†’â„2 ] = true

By Lemma B.23, there exists Ë†â„2 âˆˆ âŸ¦ğœâŸ§Eâ€² [ğ‘¥â†¦â†’â„] such that

(A6) â„2 = chompâ‡“( Ë†â„2, sizeof (ğœ„))

Together with (A5), we can conclude that

(A7) Ë†â„2 (ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )
(A8) Ë†â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [sizeof (ğœ„) :]
(A9) âˆ€ğœ… â‰  ğœ„. Ë†â„2(ğœ…) = â„(ğœ…)
(A10) ğœ„ âˆ‰ dom( Ë†â„2)

â„Î£ âˆˆ âŸ¦{ğ‘¦ : âŠ¤ | ğ‘¦.ğœ„.valid âˆ§ (cid:211)ğœ… âˆˆdom( H T)âˆ§ğœ…â‰ ğœ„ ğ‘¦.ğœ… = ğ‘¥ .ğœ… âˆ§ ğ‘¦.ğœ„@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ =
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }âŸ§E follows by the semantics of heap types with (A1), (A6), (A7), (A8), (A9) and (A10).
(â‡) Let E |= Î“, ğ‘¥ : ğœ. We know E = E â€²[ğ‘¥ â†¦â†’ â„] such that â„ âˆˆ âŸ¦ğœâŸ§Eâ€². Let Ë†â„ âˆˆ âŸ¦{ğ‘¦ : âŠ¤ |
ğ‘¦.ğœ„.valid âˆ§(cid:211)ğœ… âˆˆdom( H T)âˆ§ğœ…â‰ ğœ„ ğ‘¦.ğœ… = ğ‘¥ .ğœ… âˆ§ğ‘¦.ğœ„@ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ğ‘¦.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„]
By the semantics of heap types,

(A1) Ë†â„(ğœ„) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof(ğœ„)]
(A2) âˆ€ğœ… â‰  ğœ„. Ë†â„(ğœ…) = â„(ğœ…)
(A3) Ë†â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )
(A4) Ë†â„(ğœ„)@ Ë†â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) â‡” Ë†â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [sizeof(ğœ„) :]

To show that Ë†â„ âˆˆ âŸ¦Î£ğ‘¦ : {ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}.{ğ‘§ : chomp(ğœ, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› =
ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„], we have to show that there exists â„1 and

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:83

â„2 such that Ë†â„ = â„1 ++ â„2 and â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§Eâ€² [ğ‘¥â†¦â†’â„] and â„2 âˆˆ âŸ¦{ğ‘§ :
chomp(ğœ, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ].
Let â„1(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„1(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = âŸ¨âŸ© and â„1(ğœ„) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof (ğœ„)] and no other instances be
valid in heap â„1.
â„1 âˆˆ âŸ¦{ğ‘§ : ğœ„ | ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = âŸ¨âŸ©}âŸ§Eâ€² [ğ‘¥â†¦â†’â„] then follows by the semantics of heap types. By
Lemma B.20, there exists â„2 âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¦)âŸ§Eâ€² [ğ‘¦â†¦â†’â„1 ] such that â„2 = chompâ‡“(â„, sizeof(ğœ„)).
Since ğ‘¥ not free in ğœ, it also holds that â„2 âˆˆ âŸ¦chomp(ğœ, ğœ„, ğ‘¦)âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ].
Since â„1(ğœ„)@â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›), â„2(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) and since chomp does not change
already valid header instances also for all ğœ… â‰  ğœ„, â„2(ğœ…) = â„(ğœ…), we can conclude that
âŸ¦ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ğ‘§ â‰¡ğœ„ ğ‘¥âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1,ğ‘§â†¦â†’â„2 ] = true and thus â„2 âˆˆ
âŸ¦{ğ‘§ : chomp(ğœ, ğœ„, ğ‘¦) | ğ‘¦.ğœ„@ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘› âˆ§ ğ‘§.ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ = ğ‘¥ .ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ âˆ§ ğ‘§ â‰¡ğœ„ ğ‘¥ }âŸ§Eâ€² [ğ‘¥â†¦â†’â„,ğ‘¦â†¦â†’â„1 ].
By the semantics of heap types, we can further conclude that

(A5) (â„1 ++ â„2)(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„2(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) = â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›)
(A6) (â„1 ++ â„2)(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ ) = â„â€²(ğ‘ğ‘˜ğ‘¡ğ‘œğ‘¢ğ‘¡ )
(A7) (â„1 ++ â„2)(ğœ„) = â„(ğ‘ğ‘˜ğ‘¡ğ‘–ğ‘›) [0 : sizeof (ğœ„)] = â„â€²(ğœ„)
(A8) âˆ€ğœ… â‰  ğœ„.(â„1 ++ â„2)(ğœ…) = â„2(ğœ…) = â„(ğœ…) = â„â€²(ğœ…)

This show that actually â„â€² = â„1 ++ â„2 and concludes this case.

â–¡

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

