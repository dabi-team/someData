2
2
0
2

n
u
J

7

]
L
P
.
s
c
[

1
v
7
5
4
3
0
.
6
0
2
2
:
v
i
X
r
a

Dependently-Typed Data Plane Programming

MATTHIAS EICHHOLZ, Technical University of Darmstadt, Germany
ERIC HAYDEN CAMPBELL, Cornell University, USA
MATTHIAS KREBS, Technical University of Darmstadt, Germany
NATE FOSTER, Cornell University, USA
MIRA MEZINI, Technical University of Darmstadt, Germany

Programming languages like P4 enable specifying the behavior of network data planes in software. However,
with increasingly powerful and complex applications running in the network, the risk of faults also increases.
Hence, there is growing recognition of the need for methods and tools to statically verify the correctness of P4
code, especially as the language lacks basic safety guarantees. Type systems are a lightweight and compositional
way to establish program properties, but there is a significant gap between the kinds of properties that can be
proved using simple type systems (e.g., SafeP4) and those that can be obtained using full-blown verification
tools (e.g., p4v). In this paper, we close this gap by developing Π4, a dependently-typed version of P4 based
on decidable refinements. We motivate the design of Π4, prove the soundness of its type system, develop an
SMT-based implementation, and present case studies that illustrate its applicability to a variety of data plane
programs.

CCS Concepts: • Software and its engineering → Formal language definitions; • Networks → Pro-
gramming interfaces.

Additional Key Words and Phrases: Software-Defined Networking, P4, Dependent Types

ACM Reference Format:
Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini. 2022. Dependently-
Typed Data Plane Programming. Proc. ACM Program. Lang. 6, POPL, Article 40 (January 2022), 83 pages.
https://doi.org/10.1145/3498701

1 INTRODUCTION
Computer networks are becoming increasingly programmable as languages like P4 [Bosshart et al.
2014] make it possible to specify the behavior of data planes in software. With the increased
availability of programmable devices, a number of powerful and complex applications having
become viable, ranging from novel network protocols to full-blown in-network computation (e.g.,
executing application-level storage queries using network devices [Jin et al. 2017]). But as the
complexity of these applications increases, so does the risk of faults, especially as P4’s main
abstraction for representing packet data—namely header types—lacks basic safety guarantees.
Experience with a growing number of programs has shown the risks of the unsafe approach, which
often leads to subtle software bugs [Eichholz et al. 2019; Liu et al. 2018]. This is clearly unacceptable,

Authors’ addresses: Matthias Eichholz, Technical University of Darmstadt, Germany, eichholz@cs.tu-darmstadt.de; Eric
Hayden Campbell, Cornell University, USA, ehc86@cornell.edu; Matthias Krebs, Technical University of Darmstadt, Ger-
many, krebs@cs.tu-darmstadt.de; Nate Foster, Cornell University, USA, jnfoster@cs.cornell.edu; Mira Mezini, Technical
University of Darmstadt, Germany, mezini@cs.tu-darmstadt.de.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
© 2022 Copyright held by the owner/author(s).
2475-1421/2022/1-ART40
https://doi.org/10.1145/3498701

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40

 
 
 
 
 
 
40:2

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

given the crucial role that networks play in nearly all modern systems. Hence, we need methods
and tools to statically verify the correctness of data plane programs.

Today, most data plane verification tools [Dumitrescu et al. 2020; Liu et al. 2018; Stoenescu et al.
2018] are monolithic in nature. For example, p4v [Liu et al. 2018], which is based on software model
checking, operates on whole programs. But while monolithic approaches have certain advantages—
e.g., they minimize the need for programmer annotations—they also have downsides. The most
fundamental limitation is the inherent tension with modular design—it is difficult to accommodate
an “open-world” model, in which third-party components are plugged into existing programs.
For instance, an equipment vendor might want to provide a “base” program that implements
standard packet-processing functionality like Ethernet switching, and allow customers to add
custom functionality of their own design [Baldi 2019; Gao et al. 2020; Soni et al. 2020]. Composable
approaches to data plane programming require compositional reasoning methods [Beckett and
Mahajan 2020].

Type systems are a lightweight and compositional way to establish program properties—i.e., the
types for individual components document assumptions about the components they rely upon as
well as the guarantees they offer. However, somewhat surprisingly, types have rarely been applied in
the realm of network programming, and the few exceptions [Eichholz et al. 2019; Ennals et al. 2004;
Muthukrishnan et al. 2010] are simple type systems with limited expressive power. For example,
SafeP4 [Eichholz et al. 2019] uses regular types [Castagna et al. 2014; Gapeyev and Pierce 2003;
Hosoya and Pierce 2003] and path-sensitive occurrence typing [Tobin-Hochstadt and Felleisen
2010] to reason about basic safety properties, but it cannot capture richer program properties
(e.g., whether the IPv4 and IPv6 headers are only ever accessed on mutually exclusive execution
paths), or track the values of individual fields (e.g., whether EtherType equals to 0x0800, which
indicates an IPv4 packet, or to 0x86DD, which indicates an IPv6 packet). The inability of SafeP4 to
reason about the values being manipulated by the program significantly limits its expressiveness.
In general, there is a significant gap between the kinds of properties that can be checked using
type systems like SafeP4 and full-blown verification tools like p4v.

Thus, it is natural to ask whether we can design a compositional type system that has the
same expressive power as data plane verification tools. This paper answers this question in the
affirmative, by presenting Π4—a dependently-typed version of P4. Π4 fits with the trend of recently
proposed dependently-typed languages [Condit et al. 2007; Rondon et al. 2008; Vazou et al. 2014;
Xi and Pfenning 1999] that are blurring the line between type checking and theorem proving. For
instance, Liquid Haskell [Rondon et al. 2008; Vazou et al. 2014] allows programmers to smoothly
shift from properties that can be checked with traditional typing disciplines to more sophisticated
ones that go beyond simple syntactic checks. Under the hood, Liquid Haskell uses an SMT solver
to automatically discharge the logical proof obligations generated during type checking.

Yet, thus far, the dependently-typed approach has not been explored for network programming.
In this paper, we demonstrate that data plane programs are a “killer application” for dependent types.
On the one hand, they clearly need precise types, as most programs rely on intricate packet formats
(e.g., so-called “type-length-value” encodings, where the first few bits determine the type, length,
and structure of the bits that follow). On the other hand, data plane programs are fundamentally
simple (e.g., P4 does not support pointers or loops) and lack the kinds of complex features that
often make precise type systems complicated to design and implement.

Our main contribution lies in exploring and addressing the subtle challenges that arise in
developing a dependent type system for the P4 programming language, including balancing the
tradeoffs between expressiveness and decidability. Π4 features a combination of refinement types,
dependent function types, union types, and explicit substitutions. This combination is key to retain
precision during type checking—e.g., we can compute exact types for conditionals, thereby having

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:3

access to an accurate type at any program point. Moreover, our design enables precise typing
in the presence of domain-specific features that combine packet serialization and deserialization
operations with imperative control-flow. To this end, Π4 combines a dependent sum type with a
novel “chomp” operation that computes the type that remains after extracting bits from a packet
buffer. We formally prove that Π4’s type system is sound via standard progress and preservation
theorems.

The chomp operator is reminiscent of regular expression derivatives [Brzozowski 1964]. To
the best of our knowledge, with a few notable exceptions (e.g., work by McBride [McBride 2001])
derivative-like operations have not been extensively studied the context of dependent type systems.
Thus, beyond providing an elegant solution to a practical problem, we believe that Π4’s innovative
combination of dependent types with regular types and the possibility to compute derivatives of
types is of general theoretical interest and may be useful in other domains—e.g., one potential
direction is verified serializers and deserializers [Delaware et al. 2019; Ramananandro et al. 2019].
We have built a prototype implementation of Π4 in OCaml and the Z3 SMT solver. The type
checker determines whether a Π4 program has a given type by checking the validity of a series of
logical formulae using an SMT solver. We encode types into the effectively propositional fragment of
first-order logic over fixed-width bit vectors, which facilitates automating subtyping and equivalence
checks. We prove (cf. Theorem 4.1) that this logical fragment is sufficient for checking our types
under the assumption that the types written by the programmer denote finite sets. We believe this
is a reasonable assumption, because networks enforce a maximum transmission unit (MTU) (i.e., a
bound on the size of packets constraining the maximum number of bits that network switches can
receive or transmit1) which bounds the size of bit vectors we need to consider in the encoding. In
the presence of an MTU, our types denote finite sets, which can be enumerated to decide the key
judgments (i.e., subtyping, size constraints, and inclusion checks).

Using our Π4 prototype, we develop several case studies, demonstrating that Π4 is capable of
expressing and (modularly) reasoning about properties from the literature ranging from basic safety
to intricate invariants: parser round-tripping, protocol conformance, determined forwarding, etc.
We selected properties that are also studied by recent data plane verification tools like p4v or Vera,
which indicates that Π4 is capable of covering properties of interest to the networking community.
However, we leave a careful study of the practical utility of Π4 (e.g., with larger examples and user
studies) to future work.

Overall, the contributions of our work are as follows:

• Section 2 motivates dependently-typed data plane programming.
• Section 3 presents Π4, a dependently-typed core of P4, featuring a combination expressive
types for describing structures (regular types as well as decidable refinement and dependent
function types) combined with a bit-by-bit “chomp” operator.

• Section 3 develops a semantic proof of soundness for Π4’s type system.
• Section 4 defines a decidable algorithmic type system for Π4.
• Section 5 and Section 6 discusses case studies using Π4’s type system to check realistic

program properties.

2 BACKGROUND
Most networks are based on a division of labor between two components: the control plane and
the data plane. The control plane, usually implemented in software, is responsible for performing
tasks such as learning the topology, computing network-wide forwarding paths, managing shared

1The MTU is often set to 1500 bytes.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:4

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1
2

3
4
5

6
7

8
9
10

11
12
13

14

parser P( packet_in p, out hdrs h ) {

state start {

p. extract (h. ethernet );
transition select (

h. ethernet . etherType ) {
0 x0800 : parse_ipv4 ;
default : accept ;

}

}
state parse_ipv4 {

p. extract (h. ipv4 );
transition accept ;

}

}

15
16

17
18
19

20
21

control Ingress ( inout hdrs h) {

apply {

if (h. ipv4 . src == 10.10.10.10) {

drop () ;

}

}

}

Fig. 1. Unsafe P4 program: IPv4 is not guaranteed to be valid in the ingress.

resources like bandwidth, and enforcing security policies. The control plane can either be realized
using distributed routing protocols (e.g., in a traditional network), or as a logically-centralized
program (e.g., in a software-defined network). The data plane, often implemented in hardware
or with highly-optimized software, is responsible for forwarding packets. It parses packets into
collections of headers, performs lookups in routing tables, filters traffic using access control lists,
applies queueing policies, and ultimately drops, copies, or forwards the packet to the next device.
P4 is a domain-specific programming language for specifying the behavior of network data planes.
It is designed to be used with programmable devices such as PISA switches [Bosshart et al. 2013],
FPGAs [Ibanez et al. 2019; Wang et al. 2017], or software devices (e.g., eBPF [Høiland-Jørgensen
et al. 2018]). The language is based on a pipeline abstraction: given an input packet it executes a
sequence of blocks of code, one per pipeline component, to produce the outputs. Each pipeline
component is either a “parser,” which consists of a state machine that maps binary packets into
typed representations, or a “control,” which consists of a sequence of imperative commands. To
interface with the control plane, P4 programs may contain “match-action” tables, which contain
dynamically reconfigurable entries, each corresponding to a fixed block of code.

Unfortunately, P4 is an unsafe language that does not prevent programmers from writing
programs such as the one shown in Figure 1. The program begins by parsing the Ethernet header.
Then, if the Ethernet header contains the appropriate EtherType (0x0800), it also parses the IPv4
header. Next, in the ingress control, if the IPv4 source address matches a specified address, the
packet is marked to be dropped. However, there is no guarantee that the IPv4 header will be a
well-defined value—e.g., if the EtherType is 0x08DD, indicating an IPv6 packet, the value produced
by reading the IPv4 source address (Line 17) will be undefined, making the behavior of the program
non-deterministic and possibly different than what the programmer intended.

SafeP4 addresses the lack of basic safety guarantees for P4 using a simple type system [Eichholz
et al. 2019]. Specifically, its type system keeps track of the set of valid header instances at each
statement. For example, starting from the empty heap with no header instances valid, SafeP4
computes the type of the program above to be ether.ipv4 + ether after parsing. This type reflects
that on the first program path both Ethernet and IPv4 are valid, but on the second program path
only Ethernet is valid. Thus, when type checking the if-condition in the ingress code, the type
checker knows that IPv4 may be invalid and rejects the program. A simple fix (shown in Figure 2a)
that makes the program safe is to add an explicit validity check before accessing the IPv4 header.
Because it is aware of the semantics of the isValid command, the SafeP4 type checker computes
the type before the access to be ether.ipv4—i.e., IPv4 is guaranteed to be valid.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:5

1
2

3
4
5

6

control Ingress ( inout headers h) {

apply {

if (h. ipv4 . isValid () ) {

if (h. ipv4 . src == 10.10.10.10) {

drop () ;

}}}}

1
2

3
4
5

6

control Ingress ( inout headers h) {

apply {

if (h. ether . etherType == 0 x0800 ) {
if (h. ipv4 . src == 10.10.10.10) {

drop () ;

}}}}

(a) Explicit validity check

(b) Implicit validity check

Fig. 2. Safe implementation of ingress

In practice, however, relying on explicit validity checks is not sufficient. For example, consider the
code shown in Figure 2b. Recall that, given the parser above, the IPv4 header will be present if the
EtherType is 0x0800. Hence, the ingress control can be safely executed. Yet, SafeP4’s type checker
rejects the program because the type system is not expressive enough to capture the dependency
between the EtherType value and IPv4’s validity.

To address this problem, Π4 employs a dependent type system [Xi and Pfenning 1999], in which

we can compute a precise type for the program after parsing:

(𝑥 : {𝑦 : 𝜖 | |y.pktin| > 272}) →

(cid:18) Σ𝑦 : ether.{𝑧 : ipv4 | 𝑦.ether.etherType == 0𝑥0800}

(cid:19)

+ {𝑧 : ether | 𝑧.ether.etherType ≠ 0𝑥0800})

Intuitively, this type says that, starting with the empty heap (𝑦 : 𝜖) and a packet buffer that has at least
enough bits to extract both the Ethernet and the IPv4 header (|𝑦.𝑝𝑘𝑡𝑖𝑛 | > 272), the parser ends in one
of two possible states: (1) either both Ethernet and IPv4 are valid (Σ𝑦 : ether.{𝑧 : ipv4 | ...}), if the
EtherType is equal to 0x0800 (note how 𝑧 : ipv4 is conditioned by 𝑦.ether.etherType == 0𝑥0800),
or (2) just Ethernet is valid, if EtherType is not equal to 0x0800. When checking the ingress control,
the type checker uses the predicate ether.etherType == 0x0800 from the conditional to derive
the set of valid header instances, which, in this case, includes IPv4. Thus, accessing the IPv4 source
address is safe and the program correctly passes the type checker.

While the output type is admittedly notationally heavy—a common feature in precise type
systems—note that the programmer is not forced to write down the most precise type! Π4 only
requires the annotated type to be sufficiently precise to capture basic safety guarantees and other
desired invariants. For example, in a program where only the Ethernet header needs to be valid
at the end of the parser, they could use the type (𝑥 : {𝑦 : 𝜖 | |y.pktin| > 272}) → ether~, which
indicates that, at the end of the parser, at least Ethernet is valid (and possibly others, too).

This example illustrates how Π4’s type system statically checks intricate safety properties with
high precision. Sections 5 and 6 present more case studies showing how Π4’s type system can be
used to check practical properties of interest.

3 DEPENDENT TYPES FOR P4 (Π4)
This section introduces the design, syntax, and semantics of Π4, a core calculus modeled after P4
and equipped with dependent types.

3.1 Design of Π4
Π4 focuses on the aspects of the P4 programming language that benefit from dependent types,
(e.g., parsing, deparsing, validity, and control flow) and omits features that add clutter (e.g., externs,
registers, checksums, hashing, and packages). Following p4v [Liu et al. 2018], we do not explicitly
model match-action tables and instead use ghost state and conditionals to encode them (see

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:6

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Section 6). Consequently, Π4 is a loop-free2 imperative language with a few domain-specific
primitive commands: extract (𝜄), remit (𝜄), add (𝜄), and reset.

In P4, the emit(𝜄) primitive serializes a header instance 𝜄 into a bitstring and prepends it to the
outgoing packet payload, only if 𝜄 is valid, otherwise it does nothing. To simplify typing rules and
semantics, Π4 provides the primitive remit (𝜄), which really emits 𝜄 if it is valid, and otherwise gets
stuck. Hence, emit(𝜄) can be encoded as syntactic sugar: if (𝜄.valid) then remit (𝜄) else skip. Another
superficial difference is that we model header field accesses as direct bit-slices into the instance (to
avoid another layer of indirection in our semantics)—i.e., eth.srcAddr is written eth[48 : 96].

More substantially, Π4 diverges from P4 in the way it handles instance validity. A header instance
is valid in two cases: (i) if it has been extracted from the packet (which automatically populates
the instance with the appropriate bits) or (ii) if its validity bit has manually been set using the
setValid() method (which does nothing to the instance itself). In P4, reads to uninitialized
variables produce undefined values, so a common programming practice is to follow a call to
setValid() with a sequence of assignments to the header fields—thereby avoiding undefined reads.
In Π4, rather than forcing the programmer to manually write default values, the add (𝜄) command
sets 𝜄.valid to true, and sets 𝜄 a pre-determined default value (say 0).3 If required, P4’s behavior
could be encoded using an extra 1-bit header to independently track the validity of the instance
and initialization of its fields.

We also introduce a new primitive, reset, which models the behavior of P4 between pipeline
stages. In many switch architectures [Bosshart et al. 2013], packets are deparsed and then reparsed
between pipelines—e.g., after ingress and before egress. The reset command encodes the behavior
of the inner step: it combines the deparsed bits with the packet’s unparsed payload and passes
it along as the input to the next stage. The reset command would also be useful to reason about
invariants across multiple switch programs, although we don’t explore that use in this paper.

Finally, in designing Π4, our primary goal is to enable data plane programmers to make use of
dependent types to verify useful program properties in a compositional way and without having
to write manual proofs. To enable modular reasoning, we need a way to annotate (and modularly
check) programs with types. We annotate a program 𝑐 with a type 𝜎 using an ascription operator:
𝑐 as 𝜎. The ascription has no effect on the runtime behavior of the code (i.e., 𝑐 as 𝜎 always just
steps to 𝑐). It does, however, indicate a program point where type checking should occur. Hence,
we can independently typecheck 𝑐 at type 𝜎 and then use 𝜎 when checking the rest of the program.

Intuition for Π4’s type system. Next, we give an intuition for Π4’s types. A command 𝑐 is always
assigned a dependent function type (𝑥 : 𝜏1) → 𝜏2, where 𝑥 may occur in 𝜏2. This design allows
us to relate the input and output values of commands expressed in the heap types 𝜏1 and 𝜏2. For
example, we may want to ensure that the Ethernet header has the same value after being deparsed,
reset, and then reparsed. To express equations like this, we use refinement types {𝑦 : 𝜏 | 𝜑 }, where
𝜑 is a formula in the logic of variable-width bit vectors with concatenation and length operators.
In this example, we could say that the Ethernet header is unchanged by using the output type
{𝑦 : 𝜏2 | 𝑥 .eth = 𝑦.eth}.

We also often need to reference intermediate formulae, so we introduce substitution types,
written 𝜏2 [𝑥 ↦→ 𝜏1], where 𝑥 may occur in 𝜏2 but not in 𝜏1. In such a type, 𝜏1 may represent the type
at any earlier point in the program. Π4 also supports fine-grained path-dependent reasoning via
union types (𝜏1 + 𝜏2). It is also convenient to have trivial (⊤) and absurd (∅) types.

2P4 allows loops within parsers, but because programs are restricted to finite state, the language specification allows
implementations to unroll loops.
3The difference here is similar to the difference between C’s malloc (analogous to P4’s semantics) and calloc (analogous
to Π4’s semantics).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:7

𝜏
𝜎
𝜑
𝑒
𝑏𝑣
𝑝
𝑐

𝑑
𝑃

::= ∅ | ⊤ | Σ𝑥 : 𝜏 .𝜏 | 𝜏 + 𝜏 | {𝑥 : 𝜏 | 𝜑 } | 𝜏 [𝑥 ↦→ 𝜏]
::= N | B | BV | (𝑥 : 𝜏) → 𝜏
::= 𝑒 = 𝑒 | 𝑒 > 𝑒 | 𝜑 ∧ 𝜑 | ¬𝜑 | 𝑥 .𝜄.𝑣𝑎𝑙𝑖𝑑 | true | false
::= 𝑛 | 𝑏𝑣 | |𝑥 .𝑝 | | 𝑒 + 𝑒 | 𝑒@𝑒 | 𝑥 .𝑝 | 𝑥 .𝑝 [𝑙 :𝑟 ] | 𝑥 .𝜄 [𝑙 :𝑟 ]
::= ⟨⟩ | 0 :: 𝑏𝑣 | 1 :: 𝑏𝑣 | bn :: 𝑏𝑣
::= 𝑝𝑘𝑡𝑖𝑛 | 𝑝𝑘𝑡𝑜𝑢𝑡
::= extract (𝜄) | if (𝜑) c else c | c; c | 𝜄.f := e | remit (𝜄)

skip | reset | add (𝜄) | 𝑐 as (𝑥 : 𝜏) → 𝜏

::= 𝜂 {𝑓 : BV} | 𝜄 ↦→ 𝜂
::= (𝑑, 𝑐)

(heap types)
(base types)
(formulae)
(expressions)
(bit vectors)
(packets)
(commands)

(declarations)
(programs)

Fig. 3. Syntax of Π4

Finally, the design of our type system is also informed by the need to model parsing operations.
Specifically, we must ensure that the refinements on the input type and on the output type remain
consistent after bits have been shuffled around by a command. For example, given an input type
{𝑥 : ⊤ | 𝑥 .𝑝𝑘𝑡𝑖𝑛 [0 : 8] == 4 ∧ |𝑥 .𝑝𝑘𝑡𝑖𝑛 | > |ipv4|}, where 𝑥 .𝑝𝑘𝑡𝑖𝑛 represents the incoming packet,
and the command extract (ipv4), the output type should reflect that the ipv4 header instance is
now valid, that ipv4[0 : 8] is 4, and that 𝑥 .𝑝𝑘𝑡𝑖𝑛 may have no more bits remaining. Π4 accomplishes
this using two key mechanisms: (1) a dependent sum type Σ𝑥 : 𝜏1.𝜏2 that computes the disjoint
union of the valid instances in 𝜏1 and 𝜏2 and concatenates the incoming and outgoing packets
(Section 3.3), and (2) a refinement transformer, chomp, that manipulates input refinements to be
consistent with the extraction operation (see Section 3.5).

3.2 Syntax
Figure 3 shows the syntax of Π4. Boolean formulae 𝜑 include literals, equality (=) and validity of
instances (𝑥 .𝜄.valid), conjunction (∧), and negation (¬). Expressions 𝑒 include naturals, bit vectors,
packet length (|𝑥 .𝑝 |), addition (+), concatenation (@), packet access (𝑥 .𝑝) and slices of packets
(𝑥 .𝑝 [𝑙 :𝑟 ]) and instances (𝑥 .𝜄 [𝑙 :𝑟 ]).

To ease the notation, we write 𝑥 .𝜄 [𝑙] instead of 𝑥 .𝜄 [𝑙 :𝑙 + 1] for bit-wise access, 𝑥 .𝜄.𝑓 instead of
𝑥 .𝜄 [𝑙 :𝑟 ] for ranges matching header instance fields, 𝑥 .𝜄 instead of 𝑥 .𝜄 [0 : sizeof(𝜄)], 𝑥 .𝜄 [𝑛 :] for the
remaining bits of 𝑥 .𝜄 starting from bit 𝑛 + 1, and similarly for the corresponding formulae involving
packet variables 𝑥 .𝑝. We use a list-like encoding of bit vectors. A bit vector is either the empty bit
vector (⟨⟩) or a concatenation of bits. We assume that bit variables bn are not part of the surface
syntax and are only used internally. For singleton bit vectors, we write ⟨𝑏⟩ instead of 𝑏 :: ⟨⟩.

We write 𝜖 ≜ {𝑥 : ⊤ | (cid:211)𝜄 ∈dom( H T) ¬𝑥 .𝜄.𝑣𝑎𝑙𝑖𝑑 } for the type denoting the empty heap on which no
header instances are valid, 𝜄 ≜ {𝑥 : ⊤ | 𝑥 .𝜄.valid ∧ (cid:211)𝜄′ ∈dom( H T),𝜄′≠𝜄 ¬𝑥 .𝜄 ′.valid} for the type denoting
the heap exclusively containing instance 𝜄, and 𝜄~ ≜ {𝑥 : ⊤ | 𝑥 .𝜄.valid} for the type denoting the
heap on which at least instance 𝜄 is guaranteed to be valid.

For formulae, we write 𝑥 ≡ 𝑦 (respectively 𝑥 ≡𝜄 𝑦) as syntactic sugar for the boolean predicates
capturing strict equality (respectively instance equality) between the heaps bound to 𝑥 and 𝑦. Strict
equality requires that both the input and output packets are equivalent as well as all instances
contained in the heap—i.e., 𝑥 .𝑝𝑘𝑡𝑖𝑛 = 𝑦.𝑝𝑘𝑡𝑖𝑛 ∧ 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 ∧ (cid:211)𝜄 ∈dom( H T) 𝑥 .𝜄 = 𝑦.𝜄, while
instance equality only requires that the instances are equivalent in both heaps. We write 𝑥 .𝜄.valid =
𝑦.𝜄.𝑣𝑎𝑙𝑖𝑑 as syntactic sugar for (𝑥 .𝜄.valid ∧ 𝑦.𝜄.valid) ∨ (¬𝑥 .𝜄.valid ∧ ¬𝑦.𝜄.valid). We use standard
encodings using negation and conjunction for logical connectives like ∨ or ⇒.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:8

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

⟦𝜏⟧E ⊆ H
⟦∅⟧E = {}
⟦⊤⟧E = H

⟦𝜏1 + 𝜏2⟧E = ⟦𝜏1⟧E ∪ ⟦𝜏2⟧E

⟦Σ𝑥 : 𝜏1.𝜏2⟧E = {ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦𝜏1⟧E ∧ ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ] }

⟦𝜏1 [𝑥 ↦→ 𝜏2]⟧E = {ℎ | ℎ2 ∈ ⟦𝜏2⟧E ∧ ℎ ∈ ⟦𝜏1⟧E [𝑥↦→ℎ2 ] }
⟦{𝑥 : 𝜏 | 𝜑 }⟧E = {ℎ | ℎ ∈ ⟦𝜏⟧E ∧ ⟦𝜑⟧E [𝑥↦→ℎ] = true}

Fig. 4. Semantics of heap types

We write 𝑥 as a shorthand for a possibly empty sequence 𝑥1, ..., 𝑥𝑛. A program consists of a
sequence of declarations 𝑑 and a command 𝑐. Declarations 𝑑 include header type declarations
𝜂 {𝑓 : BV} and header instance declarations 𝜄 ↦→ 𝜂. Header type declarations specify the format of
network packet headers. They are defined in terms of a name and a sequence of field declarations,
where each field is itself defined in terms of a field name and a type. We write 𝑓 : BV to denote that
field 𝑓 has a bit vector type BV. With 𝜂 ranging over header types, the instance declaration 𝜄 ↦→ 𝜂
assigns the name 𝜄 to header type 𝜂. The global mapping between header instances and header
types is stored in the so-called header table H T . We assume that names of header instances and
header types are drawn from disjoint sets of names and that each name is declared only once.

Π4 provides commands for parsing (extract), creating (add) and modifying (𝜄.𝑓 := 𝑡) header
instances. The remit command serializes a header instance into a bit sequence. The reset com-
mand resets the program state—in particular, the packet buffers. Commands can be sequentially
composed (𝑐1; 𝑐2), skip is a no-op, and the if -command conditionally executes one out of two
commands based on the value of the boolean formula 𝜑. We assume that formulae and expressions
used in commands are implicitly prefixed with a variable named heap, but we often omit it in
the surface syntax. For example, we write if (ether.valid) then extract (ipv4) else skip instead of
if (heap.ether.valid) then extract (heap.ipv4) else skip. Π4 provides modular reasoning via type
ascription (𝑐 as (𝑥 : 𝜏1) → 𝜏2). Finally, we assume that every header referenced in a program has a
corresponding instance declaration—this could be enforced statically using a simple analysis.

3.3 Type System
As shown in Figure 3, there are two categories of types, base types 𝜎 and heap types 𝜏. Base
types include natural numbers, bit vectors, booleans, and dependent function types. Heap types 𝜏
represent sets of heaps, where each element in the set describes a different program path. The goal is
to capture bit-level dependencies between header instances and the incoming and outgoing packet
in the type system. A heap ℎ in the set of heaps H describes a possible system state, consisting of
the incoming and outgoing packet and the set of valid header instances. We model heaps as maps
from names to bit vectors. A heap contains two special entries 𝑝𝑘𝑡𝑖𝑛 and 𝑝𝑘𝑡𝑜𝑢𝑡 representing the
incoming and outgoing packet buffers, as well as mappings from instance names to bit vectors for
each valid header instance. The semantics of types is shown in Figure 4. Heap types are evaluated
in an environment E, which is a mapping from variable names to heaps. The environment models
other heaps available in the current scope upon which the current header type may depend.

The type ∅ denotes the empty set. It is used in situations where there are unsatisfiable assumptions

involving the header instances or the incoming and outgoing packet buffers.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:9

⟦𝑒⟧E ∈ BV ∪ N
0

𝑛

⊥ otherwise

(cid:40)

⟦|𝑥 .𝑝 |⟧E =

if E (𝑥)(𝑝) = ⟨⟩
if E (𝑥)(𝑝) = ⟨𝑏1, ..., 𝑏𝑛⟩

⟦𝑥 .𝑝⟧E =

⟦𝑥 .𝑝 [𝑛 : 𝑚]⟧E =

⟦𝑥 .𝜄 [𝑛 : 𝑚]⟧E =

⟨𝑏1, ..., 𝑏𝑛⟩
⊥

if E (𝑥)(𝑝) = ⟨𝑏1, ..., 𝑏𝑛⟩
otherwise

⟨𝑏𝑛, ..., 𝑏𝑚−1⟩

⊥

⟨𝑏𝑛, ..., 𝑏𝑚−1⟩

⊥








if ⟦𝑥 .𝑝⟧E = ⟨𝑏0, ..., 𝑏𝑘 ⟩ ∧
0 ≤ 𝑛 < 𝑚 ≤ 𝑘 + 1
otherwise

if ⟦𝑥 .𝜄⟧E = ⟨𝑏0, ..., 𝑏𝑘 ⟩ ∧
0 ≤ 𝑛 < 𝑚 ≤ 𝑘 + 1
otherwise

Fig. 5. Selected cases of the semantics of expressions

The top type ⊤ denotes the set of all possible heaps. The choice type 𝜏1 + 𝜏2 denotes the union of
the sets of heaps represented by 𝜏1 and 𝜏2. The dependent pair Σ𝑥 : 𝜏1.𝜏2 denotes the concatenation of
heaps from 𝜏1 and 𝜏2, where heaps described by 𝜏2 may depend on heaps from 𝜏1. The concatenation
ℎ = ℎ1 ++ ℎ2 of two heaps ℎ1 and ℎ2 requires that header instances contained in ℎ1 and ℎ2 are
disjoint. The resulting heap contains all instances from ℎ1 and from ℎ2, with 𝑝𝑘𝑡𝑖𝑛 and 𝑝𝑘𝑡𝑜𝑢𝑡 the
concatenation of respective bit vectors in ℎ1 and ℎ2. The explicit substitution 𝜏1 [𝑥 ↦→ 𝜏2] denotes
the set of heaps obtained by evaluating 𝜏1 for every heap described by 𝜏2. Finally, the refinement
type {𝑥 : 𝜏 | 𝑒} denotes the set of heaps described by 𝜏 for which the predicate 𝑒 holds.

The refinement predicate 𝜑 is evaluated in the same type of environment as heap types. Formulae
evaluate to a boolean value, i.e., ⟦𝜑⟧E ∈ B. The semantics of expression equality (𝑒1 = 𝑒2) is defined
as the semantic equality between expressions 𝑒1 and 𝑒2. If the semantics of one of the expressions is
undefined, expression equality always evaluates to false. The semantics of expression comparison
(𝑒1 > 𝑒2) is defined analogously. Instance validity 𝑥 .𝜄.valid evaluates to true if header instance 𝜄 is
contained in the heap bound to 𝑥 in E, otherwise it evaluates to false. The remaining operations
have standard semantics.

The semantics of expressions is defined in Figure 5. For brevity, we omit standard cases. Ex-
pressions evaluate to either a bit vector or a natural number. For the semantic addition (+) and bit
vector concatenation operator (@), we assume that as soon as evaluating one operand results in
an error (⊥) the whole expression also evaluates to ⊥. To evaluate the length of a packet |𝑥 .𝑝 |, we
compute the length of the bit vector of 𝑝𝑘𝑡𝑖𝑛 or 𝑝𝑘𝑡𝑜𝑢𝑡 respectively in the heap bound to 𝑥 in the
environment. If no heap is bound to variable name 𝑥, the expression evaluates to ⊥. The semantics
of bit vectors is as expected, except for variables, which we look up from a designated location in
the environment. If no binding for the bit variable exists, it evaluates to ⊥. The semantics of bit
vector concatenation is standard. A packet access 𝑥 .𝑝 looks up the respective entry from the heap
bound to variable 𝑥 in E. A packet slice 𝑥 .𝑝 [𝑙 :𝑟 ] is evaluated in the same way, but additionally the
designated slice is obtained from the bit vector. Again, if the variable is not bound or an index is
greater than the length of the bit vector, the expression evaluates to ⊥. The semantics of instance
slices 𝑥 .𝜄 [𝑙 :𝑟 ] is defined similarly but the lookup occurs on header instance 𝜄. We interpret slices as

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:10

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

E-Extract

H T (𝜄) = 𝜂

deserialize𝜂 (𝐼 ) = (𝑣, 𝐼 ′)

⟨𝐼, 𝑂, 𝐻, extract (𝜄)⟩ → ⟨𝐼 ′, 𝑂, 𝐻 [𝜄 ↦→ 𝑣], skip⟩

E-Remit

𝜄 ∈ 𝑑𝑜𝑚(𝐻 )

H T (𝜄) = 𝜂

serialize𝜂 (𝐻 (𝜄)) = 𝑏𝑣
⟨𝐼, 𝑂, 𝐻, remit (𝜄)⟩ → ⟨𝐼, 𝑂 :: 𝑏𝑣, 𝐻, skip⟩

E-Mod

𝐻 (𝜄) = 𝑟

𝑟 ′ ≜ {𝑟 𝑤𝑖𝑡ℎ 𝑓 = 𝑣 }

⟨𝐼, 𝑂, 𝐻, 𝜄.𝑓 := 𝑣⟩ → ⟨𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑟 ′], skip⟩

E-Reset

𝐼 ′ = 𝑂@𝐼
⟨𝐼, 𝑂, 𝐻, reset⟩ → ⟨𝐼 ′, ⟨⟩, [], skip⟩

E-Add
init𝜂 = 𝑣
𝜄 ∉ dom(𝐻 )
H T (𝜄) = 𝜂
⟨𝐼, 𝑂, 𝐻, add (𝜄)⟩ → ⟨𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑣], skip⟩

E-Ascribe

⟨𝐼, 𝑂, 𝐻, 𝑐 as (𝑥 : 𝜏1) → 𝜏2⟩ → ⟨𝐼, 𝑂, 𝐻, 𝑐⟩

Fig. 6. Small-step operational semantics of Π4

half-open intervals, where the left bound is included and the right bound is excluded. For example,
given a bit vector 𝑏𝑣 = 1010 we have 𝑏𝑣 [1 : 4] = 010.

We define two semantic operations on heap types: inclusion and exclusion of instances. The first,
Includes Γ 𝜏 𝜄, traverses 𝜏 and checks that instance 𝜄 is valid in every path. Semantically this says
that 𝜄 is a member of every element of ⟦𝜏⟧E—i.e., if E |= Γ, then ∀ℎ ∈ ⟦𝜏⟧E .𝜄 ∈ 𝑑𝑜𝑚(ℎ). The second,
Excludes Γ 𝜏 𝜄, traverses 𝜏 and checks that instance 𝜄 is invalid in every path. Semantically this says
that 𝜄 is no member of every element of ⟦𝜏⟧E—i.e., if E |= Γ, then ∀ℎ ∈ ⟦𝜏⟧E .𝜄 ∉ 𝑑𝑜𝑚(ℎ).

3.4 Operational Semantics
The small-step operational semantics of Π4, is shown in Figure 6. It is defined in terms of a four-tuple
⟨𝐼, 𝑂, 𝐻, 𝑐⟩, where 𝐼 and 𝑂 are the bitstrings for the incoming and outgoing packets respectively, 𝐻
is a map that relates instance names to records containing the field values, and 𝑐 is a command.

The extract (𝜄) command (E-Extract) first looks up the header type from the header table (H T ),
and uses a deserialization function to copy the appropriate number of bits from the input packet
into the deserialized representation of the instance 𝑣. This value is added to the map of valid
header instances 𝐻 . We assume there exists a deserialization function for every header instance.
For example, assuming 𝐼 = 110011𝐵, where 𝐵 is the rest of the bitstring, and 𝜂 = {𝑓 : 4; 𝑔 : 2}, then
deserialize𝜂 (𝐼 ) = ({𝑓 = 1100; 𝑔 = 11}, 𝐵).

The remit (𝜄) command (rule E-Remit) requires that the header instance is valid—i.e., it is con-
tained in 𝐻 . Similar to E-Extract, we assume there is a serialization function for every heap
type, which turns a record representing the instance back into a bit sequence. For example,
serialize𝜂 ({𝑓 = 1100; 𝑔 = 11}) = 11011. The serialized bit sequence is appended to the end of
the outgoing packet. Both the input packet and the set of valid headers remain unchanged.

The rule E-Mod defines the semantics of assigning a value to a header field. Assuming 𝑟 is the
record storing the values of the fields, an updated record 𝑟 ′ with the modified field value is stored
in 𝐻 . The input and output packets remain unchanged. If the assigned expression is not a value, it
is reduced first.

The rules for sequencing (E-Seq, E-Seq1) are standard. Sequences of commands evaluate from
left to right—i.e., the left-hand command is reduced to skip before the right-hand command is
evaluated. The evaluation rules for conditionals (E-If, E-IfTrue, E-IfFalse) are also standard. All
standard rules are omitted.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:11

The rule E-Reset defines the semantics of the command reset. It would be invoked between the
ingress and egress pipelines, when the packet emitted by the ingress becomes the input packet for
the egress. Operationally, the bits contained in the output packet are prepended to the bits of the
input packet. This concatenated bit sequence serves as the new input packet. The output packet is
emptied and all valid header instances are discarded.

The rule E-Add initializes a header instance if it is not already valid. The evaluation is similar to
rule E-Extract, except that no bits are taken from the input bitstring. Instead we assume that there
exists an initialization function init𝜂 for every heap type 𝜂 —similar to deserialize—that initializes
all fields of an instance to a fixed value. If an instance is already valid, this operation is a no-op. An
ascribed command 𝑐 as 𝜎 (rule E-Ascribe) evaluates to 𝑐 trivially, without modifying the heap.

3.5 Typing Judgement
The typing judgement has the form Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2. Intuitively, type 𝜏1 describes the input
heap and 𝜏2 describes the output heap obtained after the execution of 𝑐. Γ is a variable context that
maps variable names to heap types and is used to capture additional dependencies of the input
type. If a command typechecks in a context where 𝑥 maps to 𝜏 (i.e., Γ, 𝑥 : 𝜏 ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2) it
means that given some heap described by type 𝜏 on which the input heap might depend, executing
𝑐 on the input heap described by 𝜏1 will result in a heap described by 𝜏2.

The typing rules are presented in Figure 7. The typing rule T-Extract captures that 𝜄 must be
valid after an extract command is executed and the input packet of type 𝜏1 provides enough bits for
the instance (sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ 𝑛 iff ∀E, ℎ ∈ ⟦𝜏⟧E, |ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑛). Intuitively, the chomp operator
ensures that the output type reflects that the first 𝑛 bits, where 𝑛 is the number of bits contained in
header instance 𝜄, are removed from the input packet and copied into instance 𝜄.

The typing rule for sequencing T-Seq is mostly standard, with one peculiarity: because our
typing judgement assigns dependent function types to commands, the result type 𝜏22 of command
𝑐2 might depend on its input type 𝜏12—i.e., variable 𝑦 might appear free in 𝜏22. Hence, we must also
capture the type 𝜏12 in the result type. The typing rule T-Skip is standard, except that it strictly
enforces that the heaps described by the output type are equivalent to the heaps described by
the input type. To typecheck the command remit, we check whether the instance to be emitted is
guaranteed to be valid in the input type. The assigned output type ensures that emitting a header
instance appends the value of the instance to the end of the outgoing packet (second projection of
the assigned Σ-type) but leaves the input packet and all other validity information unchanged (first
projection of the assigned Σ-type). The rule T-Reset resets all assumptions about header validity,
empties 𝑝𝑘𝑡𝑜𝑢𝑡 and refines 𝑝𝑘𝑡𝑖𝑛 to be the concatenation of 𝑝𝑘𝑡𝑜𝑢𝑡 and 𝑝𝑘𝑡𝑖𝑛 of the input type. In
the output type, we use a Σ-type to model the concatenation.

The rule T-If typechecks each branch of the conditional with the additional assumption that
the condition 𝜑 holds respectively does not hold. The resulting type is a path-sensitive union type,
which includes the types of both paths. By default, all variables in formula 𝜑 in the command
are bound to heap. To turn 𝜑 into a refinement on a type, we substitute every occurrence of
heap with the respective binder of the type we want to refine. We write 𝜑 [𝑥/heap] to denote
the formula obtained from 𝜑 in which heap is replaced with 𝑥. For example, if the command is
if (ether.etherType = 0x0800) then extract (ipv4) else skip, we typecheck the then-branch with
type (𝑥 : {𝑦 : 𝜏1 | 𝑦.ether.etherType = 0x0800}) → 𝜏12. The full command is checked with type
(𝑥 : 𝜏1) → {𝑦 : 𝜏12 | 𝑥 .ether.etherType = 0x0800} + {𝑦 : 𝜏22 | ¬𝑥 .ether.etherType = 0x0800}.
To typecheck a modification of an instance field, the typing rule T-Mod first checks if the instance
to be modified is guaranteed to be valid in the input type. The output type is similar to the strongest-
postcondition of the input type: everything in the output type is the same as in 𝑥, except for the
modified instance field 𝑦.𝜄.𝑓 , which must be equal to 𝑒 [𝑥/heap].

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:12

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

T-Extract

Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏1) ≥ sizeof(𝜄)

𝜑1 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩

𝜑2 ≜ 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥
Γ ⊢ extract (𝜄) : (𝑥 : 𝜏1) → Σ𝑦 : {𝑧 : 𝜄 | 𝜑1}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑2}

T-Seq

Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) → 𝜏12
Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) → 𝜏22
Γ ⊢ 𝑐1; 𝑐2 : (𝑥 : 𝜏1) → 𝜏22 [𝑦 ↦→ 𝜏12]

T-Skip

𝜏2 ≜ {𝑦 : 𝜏1 | 𝑦 ≡ 𝑥 }
Γ ⊢ skip : (𝑥 : 𝜏1) → 𝜏2

T-Remit

Includes Γ 𝜏1 𝜄
Γ ⊢ remit (𝜄) : (𝑥 : 𝜏1) → Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝜑 }

𝜑 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄

T-Reset

𝜑1 ≜ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡
𝜑2 ≜ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛
Γ ⊢ reset : (𝑥 : 𝜏1) → Σ𝑦 : {𝑧 : 𝜖 | 𝜑1}.{𝑧 : 𝜖 | 𝜑2}

T-Ascribe
Γ ⊢ 𝑐 : 𝜎
Γ ⊢ 𝑐 as 𝜎 : 𝜎

T-If

Γ; 𝜏1 ⊢ 𝜑 : B

Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) → 𝜏12

Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) → 𝜏22

Γ ⊢ if (𝜑) c1 else c2 : (𝑥 : 𝜏1) → {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}

T-Mod

F (𝜄, 𝑓 ) = BV

Γ; 𝜏1 ⊢ 𝑒 : BV

Includes Γ 𝜏1 𝜄

𝜑𝑝𝑘𝑡 ≜ 𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡

𝜑𝜄 ≜ ∀𝜅 ∈ dom(H T ). 𝜄 ≠ 𝜅 → 𝑦.𝜅 = 𝑥 .𝜅

𝜑 𝑓 ≜ ∀𝑔 ∈ dom(H T (𝜄)). 𝑓 ≠ 𝑔 → 𝑦.𝜄.𝑔 = 𝑥 .𝜄.𝑔

Γ ⊢ 𝜄.𝑓 := 𝑒 : (𝑥 : 𝜏1) → {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}

T-Add

Excludes Γ 𝜏1 𝜄

init H T (𝜄) = 𝑣

𝜑 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣
Γ ⊢ add (𝜄) : (𝑥 : 𝜏1) → Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝜑 }

T-Sub

Γ ⊢ 𝜏1 <: 𝜏3
Γ, 𝑥 : 𝜏1 ⊢ 𝜏4 <: 𝜏2
Γ ⊢ 𝑐 : (𝑥 : 𝜏3) → 𝜏4
Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2

Fig. 7. Command typing rules for Π4.

Rule T-Add first checks that the instance is not yet included in the type and assigns an output
type that reflects that all information from the input type 𝜏1 are retained and just instance 𝜄 is added.
The typing rule for ascription T-Ascribe is standard. The typing rule for subsumption T-Sub is also
standard. We write Γ ⊢ 𝜏1 <: 𝜏2 to denote the subtyping check between 𝜏1 and 𝜏2. The contexts Γ1
and Γ2 capture external dependencies of 𝜏1 and 𝜏2 respectively.

We take a semantic approach for defining subtyping as shown in the left of Figure 8. Type 𝜏1
with context Γ1 is a subtype of type 𝜏2 with context Γ2, if and only if for all environments E1 and E2
such that E1 entails the context Γ1 for subtype 𝜏1 and E2 entails the context Γ2 for supertype 𝜏2, the

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:13

Γ ⊢ 𝜏1 <: 𝜏2

Δ
⇔ ∀E |= Γ.⟦𝜏1⟧E ⊆ ⟦𝜏2⟧E E |= Γ

Δ
⇔ ∀𝑥𝑖 ∈ dom(Γ).E (𝑥𝑖 ) = ℎ𝑖 ∧ ℎ𝑖 |=E Γ(𝑥𝑖 )

Fig. 8. Left: Subtyping. Right: Entailment between environments and subtyping contexts.

Ent-Top

(𝐼, 𝑂, 𝐻 ) |=E ⊤

Ent-ChoiceL

(𝐼, 𝑂, 𝐻 ) |=E 𝜏1
(𝐼, 𝑂, 𝐻 ) |=E 𝜏1 + 𝜏2

Ent-ChoiceR

(𝐼, 𝑂, 𝐻 ) |=E 𝜏2
(𝐼, 𝑂, 𝐻 ) |=E 𝜏1 + 𝜏2

Ent-Refine

(𝐼, 𝑂, 𝐻 ) |=E 𝜏
⟦𝜑⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = true
(𝐼, 𝑂, 𝐻 ) |=E {𝑥 : 𝜏 | 𝜑 }

Ent-Sigma

(𝐼1, 𝑂1, 𝐻1) |=E 𝜏1
(𝐼2, 𝑂2, 𝐻2) |=E [𝑥↦→(𝐼1,𝑂1,𝐻1) ] 𝜏2
(𝐼1@𝐼2, 𝑂1@𝑂2, 𝐻1 ∪ 𝐻2) |=E Σ𝑥 : 𝜏1.𝜏2

Ent-Subst

(𝐼2, 𝑂2, 𝐻2) |=E 𝜏2
(𝐼, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼2,𝑂2,𝐻2) ] 𝜏1
(𝐼, 𝑂, 𝐻 ) |=E 𝜏1 [𝑥 ↦→ 𝜏2]

Fig. 9. Entailment between heaps and heap types.

set of heaps described by 𝜏1 evaluated in environment E1 is a subset of the set of heaps described
by 𝜏2 evaluated in environment E2.

The entailment between environments and typing contexts is defined in the right of Figure 8.
An environment E entails a context Γ, iff for every mapping from a variable name 𝑥𝑖 to some heap
type 𝜏𝑖 in Γ there exists a mapping from variable 𝑥𝑖 to some heap ℎ𝑖 in environment E and that
heap ℎ𝑖 entails type 𝜏𝑖 . The entailment between a heap and a type is defined in Figure 9. A heap
𝐻 [𝑝𝑘𝑡𝑖𝑛 ↦→ 𝐼, 𝑝𝑘𝑡𝑜𝑢𝑡 ↦→ 𝑂], in short (𝐼, 𝑂, 𝐻 ) entails a type 𝜏, if it is contained in the type.

3.6 Chomp
When an instance 𝜄 is extracted, sizeof(𝜄) bits are moved from the input bitstring to the instance—we
call this chomping. To reflect it in the type that we assign to an extract command, we define a
syntactic operation chomp that transforms a heap type into the heap type that would result from
extracting an instance.

We first specify a semantic chomp operation on a single heap (chomp⇓(ℎ, 𝑛)) in Definition 3.1—it

removes the first 𝑛 bits from the input packet in heap ℎ.

Definition 3.1 (Semantic Chomp). chomp⇓(ℎ, 𝑛) = ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 :]]

Intuitively, syntactic chomp lifts chomp⇓ to heap types (written formally in Lemma 3.2). For
example, given a header instance A of type A_t { f: 2 }, chomp({𝑥 : 𝜖 | 𝑥 .𝑝𝑘𝑡𝑖𝑛 [0 : 2] =
11}, 𝐴, 𝑦) = {𝑥 : 𝜖 | 𝑦.𝐴[0 : 2] = 11}, i.e., because header instance A contains two bits, the first two
bits are moved from 𝑝𝑘𝑡𝑖𝑛 to instance A, bound by 𝑦. It turns out that we can define chomp via
a simple syntactic transformation. To do this, we first define a single-bit operation, chomp1, that
processes only a single bit. Then chomp recursively lifts chomp1 to the appropriate length.
3.6.1 Chomp1. To chomp a single bit from a heap type, we will need to update all references to the
length, as well as to the first bit of 𝑝𝑘𝑡𝑖𝑛. This computation resembles Brzozowski derivatives [Brzo-
zowski 1964]. For the complete definition of chomp1, we refer the reader to the appendix. Here we
provide some intuition for how it works. Semantically, chomp1(𝜏, b0) transforms for each heap ℎ
denoted by a heap type 𝜏, into the heap ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [1 : ]]. The variable b0 is a placeholder
corresponding to the missing bit. Then, a helper function heapRef1 replaces the placeholder bits

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:14

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

introduced by chomp1 with references to the extracted bit. In particular, the 𝑖-th call to heapRef1,
replaces variable bi with 𝑥 .𝜄 [𝑖 − 1 :𝑖].

Syntactically, when chomping a heap type 𝜏 we update each occurrence of 𝑝𝑘𝑡𝑖𝑛 in a refinement,
if that occurrence describes the first bit of 𝑝𝑘𝑡𝑖𝑛 of a heap in the semantics of 𝜏. Types ∅ and ⊤ are
not affected by chomping. For a choice type 𝜏1 + 𝜏2, chomp1 is applied to both 𝜏1 and 𝜏2 individually,
as each branch of the choice type describes isolated heaps of 𝜏. In the substitution type, 𝜏1 [𝑥 ↦→ 𝜏2],
only 𝜏1 is chomped, as 𝜏2 only captures information relevant for evaluating refinements.

For the refinement type {𝑥 : 𝜏1 | 𝜑 }, chomp is applied recursively to 𝜏1 and all references to
the first bit of 𝑝𝑘𝑡𝑖𝑛 as well as the length of 𝑝𝑘𝑡𝑖𝑛 are updated accordingly. We increment numeric
expressions referencing 𝑥 .𝑝𝑘𝑡𝑖𝑛 (e.g. the refinement |𝑥 .𝑝𝑘𝑡𝑖𝑛 | becomes |𝑥 .𝑝𝑘𝑡𝑖𝑛 | + 1 and we prepend
the placeholder bit bn for bit-vector expressions referencing 𝑥 .𝑝𝑘𝑡𝑖𝑛).

When we apply chomp1 to type Σ𝑥 : 𝜏1.𝜏2, we have to distinguish two cases, either the input
packet described by 𝜏1 contains at least one bit or the input packet described by 𝜏1 is empty. In the
first case, chomp1 removes the first bit of 𝑝𝑘𝑡𝑖𝑛 in 𝜏1 and in the second case it removes the first bit
of 𝑝𝑘𝑡𝑖𝑛 in 𝜏2. If we chomp in 𝜏1 we need to update all refinements to 𝑥 .𝑝𝑘𝑡𝑖𝑛 in 𝜏2, as 𝜏1 is bound to
𝑥 in 𝜏2; otherwise chomping could cause contradictions between refinements referencing the same
component. Similar to the computation of a Brzozowski derivative of a product, the result is the
union of the type obtained by chomping 𝜏1 and 𝜏2 respectively, where we additionally assert in the
second case that 𝑝𝑘𝑡𝑖𝑛 of 𝜏1 must be empty.

Example. Given type 𝜏 = Σ𝑥 : {𝑦 : 𝜖 | |𝑦.𝑝𝑘𝑡𝑖𝑛 | = 1}.{𝑧 : 𝜖 | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | = 1}

chomp1(𝜏, b0) = Σ𝑥 : {𝑦 : 𝜖 | |𝑦.𝑝𝑘𝑡𝑖𝑛 | + 1 = 1}.{𝑧 : 𝜖 | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | + 1 = 1} +

Σ𝑥 : {𝑦 : 𝜖 | |𝑦.𝑝𝑘𝑡𝑖𝑛 | = 1 ∧ |𝑦.𝑝𝑘𝑡𝑖𝑛 | = 0}.{𝑧 : 𝜖 | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | = 1}

Example. Given a type 𝜏 = {𝑥 : {𝑦 : 𝜄 | |𝑦.𝑝𝑘𝑡𝑖𝑛 | = 8} | 𝑥 .𝑝𝑘𝑡𝑖𝑛 [0 : 8] = 𝑥 .𝜄 [4 : 12]}

chomp1(𝜏, 𝑏0) = {𝑥 : {𝑦 : 𝜄 | |𝑦.𝑝𝑘𝑡𝑖𝑛 | + 1 = 8} | 𝑏0 :: 𝑥 .𝑝𝑘𝑡𝑖𝑛 [0 : 7] = 𝑥 .𝜄 [4 : 12]}
Example. Given a header instance 𝐴 and a heap type 𝜏 = {𝑥 : 𝜖 | b0 :: ⟨⟩@𝑥 .𝑝𝑘𝑡𝑖𝑛 [0] = 10}. The

first call to heapRef1 returns type {𝑥 : 𝜖 | (𝑦.𝜄 [0]@⟨⟩)@𝑥 .𝑝𝑘𝑡𝑖𝑛 [0] = 10}.
3.6.2 Correctness of Chomp. We prove that chomp is correct with respect to chomp⇓. Specifically,
Lemma 3.2 states that—given some heap ℎ ∈ ⟦𝜏⟧E—there exists a corresponding heap ℎ′ in the
semantics of the chomped type that is equivalent to the heap obtained after applying chomp⇓ to ℎ.
Since chomp adds a refinement on 𝑥 .𝜄, we evaluate the chomped type in an environment, where 𝑥
maps to the heap in which 𝜄 contains the first sizeof (𝜄) bits from ℎ(𝑝𝑘𝑡𝑖𝑛). This reflects the intuition
that chomp populates the header instance 𝜄 with the first sizeof(𝜄) bits from the input packet.

Lemma 3.2 (Semantic Chomp). If 𝑥 does not appear free in 𝜏, then for all heaps ℎ ∈ ⟦𝜏⟧E where
|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ sizeof(𝜄), there exists ℎ′ ∈ ⟦chomp(𝜏, 𝜄, 𝑥)⟧E′ such that ℎ′ = chomp⇓(ℎ, sizeof (𝜄))
where E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof(𝜄)]])].

3.7 Safety of Π4
We prove safety of Π4 in terms of standard progress and preservation theorems. That is, well-typed
programs do not get stuck and when well-typed programs are evaluated, they remain well typed.
Both theorems make use of the entailment relation defined in Figure 9.

Theorem 3.3 (Progress). If · ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 and (𝐼, 𝑂, 𝐻 ) |= 𝜏1, then either 𝑐 = skip or

∃⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩.⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩.

Proof. By induction on the typing derivation. For details, see Appendix B, Theorem B.9.

□

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:15

As usual, progress says that if a command is well-typed, it is either skip or can take a step.

Theorem 3.4 (Preservation). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2, ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩, and E |= Γ
2 and E ′ |= Γ′
1, 𝜏 ′

2, such that Γ′ ⊢ 𝑐 ′ : (𝑥 ′ : 𝜏 ′

1) → 𝜏 ′

and (𝐼, 𝑂, 𝐻 ) |=E 𝜏1, then there exists Γ′, E ′, 𝑥 ′, 𝜏 ′
1 and ⟦𝜏 ′
and (𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
Proof. By induction on the typing derivation. For details, see Appendix B, Theorem B.28.

□

The preservation theorem says that if a command is a well-typed command 𝑐 that can step to 𝑐 ′,
2 such that
2 is a subset of the heaps denoted by 𝜏2

and a heap entails the input type 𝜏1, then 𝑐 ′ is well-typed from 𝜏 ′
the final heap entails 𝜏 ′
with their respective input heaps bound to variable 𝑥.

1 and the set of heaps described by 𝜏 ′

2 for some 𝜏 ′

1 and 𝜏 ′

1 to 𝜏 ′

4 IMPLEMENTATION
We have built a prototype implementation of Π4’s type system in OCaml and Z3. Under the hood,
it uses an encoding of Π4’s types into a decidable theory of first-order logic, facilitating use of an
SMT solver to automatically discharge the various side conditions that arise during type checking.
We describe the algorithmic type system and its decidability, some optimizations we use to simplify
our types, and our P416 frontend.

4.1 Algorithmic Type System and Decidability
For our implementation, we define an algorithmic version of our type system whose rules are mostly
identical to the rules from our declarative type system. Figure 10 shows two selected algorithmic
typing rules that demonstrate the key differences from our declarative system. Many of the typing
rules have semantic conditions that must be checked during type checking. In the algorithmic type
system, we encode these constraints as subtype constraints. For example, when we type-check
the command add (𝜄), we must check that the newly added instance is not already valid in the
input type 𝜏1, i.e., Excludes Γ 𝜏1 𝜄. As shown by rule T-Add-Algo in Figure 10, Excludes Γ 𝜏1 𝜄
becomes the subtype check Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}. Similarly, rule T-Mod and T-Remit
require Includes Γ 𝜏1 𝜄, which becomes Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | 𝑥 .𝜄.valid} in T-Mod-Algo and T-
Remit-Algo respectively. The check sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ sizeof (𝜄) required by T-Extract becomes
Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof(𝜄)} in rule T-Extract-Algo.

The second major difference is the rule for type ascription T-Ascribe-Algo. In our implemen-
tation we check if the input type 𝜏1 is a subtype of the ascribed input type ˆ𝜏1. We then use the
ascribed input type to compute an output type 𝜏𝑐 . Finally, we check if the computed output type
is a subtype of the ascribed output type. Note, that our type checking algorithm can be used to
obtain a weak form of type inference. Given an input type that describes the state before the
execution, our algorithm computes an output type, which describes the state after the execution
of the program. However, a full-blown treatment of type reconstruction (such as the one used by
Liquid Haskell [Vazou et al. 2018]) is left for future work.

We convert every check Γ ⊢ 𝜏1 <: 𝜏2 into a formula in the theory of fixed-width bit vectors. This
is largely straightforward, except for the encoding of 𝑝𝑘𝑡𝑖𝑛 and 𝑝𝑘𝑡𝑜𝑢𝑡 , which may be arbitrarily
long. However, network switches have a maximum number of bits that they can receive or transmit,
called the maximum transmission unit (MTU). So when compiling a P4 program to a given switch,
we know that the transmitted packets must be smaller than MTU. We exploit this fact to prove a
bound on the size of the bit vectors that must be considered.

More formally, we say that a type 𝜏 is bounded by 𝑁 in a context Γ, written Γ ⊢ 𝜏 ≤ 𝑁 , iff for
every E |= Γ, and ℎ ∈ ⟦𝜏⟧E, |ℎ(𝑝𝑘𝑡𝑖𝑛)| + |ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 . We need to bound both ℎ(𝑝𝑘𝑡𝑖𝑛) and
ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) by 𝑁 because (as seen in the reset command), the emitted packet is ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )@ℎ(𝑝𝑘𝑡𝑖𝑛).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:16

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

T-Add-Algo

Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}

init H T (𝜄) = 𝑣

Γ ⊢ add𝜄 : (𝑥 : 𝜏1) ⇝ Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }

T-Ascribe-Algo
Γ ⊢ 𝑐 : (𝑥 : ˆ𝜏1) ⇝ 𝜏𝑐

Γ ⊢ 𝜏1 <: ˆ𝜏1
Γ ⊢ 𝑐 as (𝑥 : ˆ𝜏1) → ˆ𝜏2 : (𝑥 : 𝜏1) ⇝ ˆ𝜏2

Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏𝑐 <: ˆ𝜏2

Fig. 10. Selected rules of the algorithmic type system

Theorem 4.1 (MTU-Bound) says that given an algorithmic typing judgement on a program 𝑐, for
which the input type and all ascribed types in 𝑐 respect the MTU 𝑁 , the output type will require no
more than 𝑁 + emit(𝑐) bits, where emit(𝑐) ∈ N is the number of bits that could possibly be emitted
in 𝑐. The details are shown in Figure 21. Note that even though the real input type is constrained
by the same MTU 𝑁 , intermediate states may require more than just 𝑁 bits. MTU-Bound shows
that 𝑁 + emit(𝑐) suffices as the maximum combined width of 𝑝𝑘𝑡𝑖𝑛 and 𝑝𝑘𝑡𝑜𝑢𝑡 .

Theorem 4.1 (MTU-Bound). For every Γ, 𝑐, 𝑥, 𝜏1, 𝜏2, and 𝑁 , if Γ ⊢ 𝜏1 ≤ 𝑁 and Γ ⊢ 𝑐 : ((𝑥 :

𝜏1)) ⇝ 𝜏2 and every ascribed type in 𝑐 is also bounded by 𝑁 , then Γ, (𝑥 : 𝜏1) ⊢ 𝜏2 ≤ 𝑁 + emit(𝑐).

Proof. By induction on the typing derivation. For details, see Appendix D, Theorem D.5.

□

Theorem 4.2 establishes the correctness of the algorithmic typing relation. It states that a program
𝑐 typechecks in the declarative system with type (𝑥 : 𝜏1) → 𝜏2 if and only if it also typechecks in
the algorithmic system with type (𝑥 : 𝜏1) ⇝ 𝜏 ′
2 is
a subtype of the output type 𝜏2 of the declarative system.

2 and the output type of the algorithmic system 𝜏 ′

Theorem 4.2 (Algorithmic Typing Correctness). For all Γ, 𝑐, 𝑥, 𝜏1, and 𝜏2, where 𝑥 is not
2, and

2 such that Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′

free in 𝜏1, Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 if and only if there is some 𝜏 ′
Γ, (𝑥 : 𝜏1) ⊢ 𝜏 ′

2 <: 𝜏2.

Proof. By induction on the typing derivation. For details, see Appendix D, Theorem C.19. □

With Theorems 4.2 and 4.1 in hand, it is straightforward to show the decidability of the declarative
type system, i.e., that Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 is decidable (cf. Theorem 4.3). Theorem 4.2 allows
us to equivalently show that typechecking the command in the algorithmic type system—i.e.,
2—terminates and that checking Γ, (𝑥 : 𝜏1) ⊢ 𝜏 ′
Γ ⊢ 𝑐 : ((𝑥 : 𝜏1)) ⇝ 𝜏 ′
2 <: 𝜏2 terminates, which
follows by finite enumeration using the bounds guaranteed by Theorem 4.1.

Theorem 4.3 (Decidability). If Γ, 𝜏1, 𝜏2 and every ascribed type in 𝑐 are bounded by the MTU 𝑁 ,

then Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 is decidable.

Proof. Proof by Algorithmic Typing Correctness, MTU-Bound and by induction on the typing
□

derivation. For details, see Appendix D, Theorem D.6.

4.2 Rewriting Optimizations
The final major difference between the declarative type system and our implementation is that we
exploit two type equivalences to eliminate Σ-types and chomp. We exploit the fact that Σ-types
can be written using refinement and substitution types. In other words, in any context Γ, the type
Σ𝑥 : 𝜏1.𝜏2 is equivalent to

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:17

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)





𝑥 : ⊤

(cid:18) 𝑥 .𝑝𝑘𝑡𝑖𝑛 = 𝑙 .𝑝𝑘𝑡𝑖𝑛@𝑟 .𝑝𝑘𝑡𝑖𝑛 ∧
𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑙 .𝑝𝑘𝑡𝑜𝑢𝑡 @𝑟 .𝑝𝑘𝑡𝑜𝑢𝑡

(cid:169)
∧
(cid:173)
𝜄 ∈dom( H T)
(cid:171)
We also can eliminate occurrences of chomp produced by extractions. Observe that in the context

(cid:170)
(cid:174)
(cid:172)

𝑥 .𝜄.valid = 𝑙 .𝜄.valid ⊕ 𝑟 .𝜄.valid ∧
𝑙 .𝜄.valid =⇒ 𝑥 .𝜄 = 𝑙 .𝜄 ∧
𝑟 .𝜄.valid =⇒ 𝑥 .𝜄 = 𝑟 .𝜄

[𝑟 ↦→ 𝜏2]
[𝑙 ↦→ 𝜏1]





(cid:219)

(cid:19)

where (𝑥 : 𝜏), the following two types are equivalent

Σ𝑦 :

(cid:26)
𝑧 : 𝜄

(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩

(cid:27)

(cid:26)
𝑧 : chomp(𝜏, 𝜄, 𝑦)

.

(cid:18) 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡

(cid:19)

(cid:27)

∧ 𝑧 ≡𝜄 𝑥

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:17)
{𝑦 : ⊤ | 𝑦.𝜄.valid ∧ 𝑥 .𝑝𝑘𝑡𝑖𝑛 = 𝑦.𝜄@𝑦.𝑝𝑘𝑡𝑖𝑛 ∧ 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 ∧ (cid:211)𝜅 ∈dom( H T)∧𝜅≠𝜄 𝑦.𝜅 = 𝑥 .𝜅}

Because these types are equivalent we can give extract (𝜄) commands the following type:

(𝑥 : 𝜏) → {𝑦 : ⊤ | 𝑦.𝜄.valid ∧ 𝑥 .𝑝𝑘𝑡𝑖𝑛 = 𝑦.𝜄@𝑦.𝑝𝑘𝑡𝑖𝑛 ∧ 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 ∧

(cid:219)

𝑦.𝜅 = 𝑥 .𝜅}

𝜅 ∈dom( H T)∧𝜅≠𝜄

This optimization, along with similar changes to the types for add (𝜄) and remit (𝜄) greatly reduce
the size of the generated Z3 formulae, making typechecking tractable.

4.3 Beyond the Core Calculus
Our prototype is equipped with a P416 frontend that uses Petr4’s parser [Doenges et al. 2021] to
translate a subset of type-annotated P416 programs into Π4 programs. We leverage P4’s builtin
annotation mechanism to allow users to annotate control and parser blocks with types using the
custom @pi4(𝜎) annotation, where 𝜎 is the desired type. We also provide convenience notation
such as @pi4_roundtrip(𝜏), which ensures, as elaborated in Section 5.3 that the composition of
deparser, reset, and parser has type (𝑥 : 𝜏) → {𝑦 : ⊤ | 𝑥 ≡ 𝑦}.

5 CHECKING NETWORK INVARIANTS
We now show that dependent types are a good match for P4, by demonstrating that Π4’s type
system can be used to (i) check real network protocol invariants and (ii) verify a variety of basic
and advanced safety properties. We showcase properties that are also studied in the context of
other P4 verification tools [Liu et al. 2018; Stoenescu et al. 2018]. All examples, in this section and
the next, have been implemented in our Π4 prototype.

In most P4 programs, packet-forwarding behavior is specified using a predefined record of type
standard_metadata_t. In particular, the egress_spec field instructs the switch to forward the
packet out on a specific port. We assume that the field is initialized to 0x00, indicating that no
forwarding decision has been made, and that by setting the field to 0x1FF (i.e., the largest unsigned
9-bit value), the switch can be instructed to drop the packet.4 For simplicity, we treat all P4 metadata
as an ordinary header instance called stdmeta.

5.1 Protocol Conformance
We start with examples showing how Π4’s type system can be used to ensure that a program
conforms with standard network protocols.

4In the examples that follow, we use bitvector literals assuming that they are implicitly cast to the appropriate widths
(following P416’s casting semantics). The implementation, however, requires these to be explicit lengths, e.g. 0b111111111
instead of 0x1FF for a 9 bit field.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:18

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1
2

3
4
5

/* Unsafe */
if ( ipv4 . valid ) {

stdmeta . egress_spec := 0 x1 ;
ipv4 . ttl := ipv4 . ttl - 0 x1

}

1
2

3
4
5

6
7

8
9

/* Safe */
if ( ipv4 . valid ) {

if ( ipv4 . ttl == 0 x00 ) {

stdmeta . egress_spec := 0 x1FF

} else {

stdmeta . egress_spec := 0 x1 ;
ipv4 . ttl := ipv4 . ttl - 0 x1

}

}

(x :{ y:ipv4~ | y. meta . valid }) ->

{y:ipv4~ | y. meta . valid && (x. ipv4 . ttl==0x0 => y. meta . egress_spec==0x1FF )}

Fig. 11. IPv4 TTL example. Top left: doesn’t typecheck; top right: typechecks; bottom: Π4 type encoding the
TTL invariant.

1
2
3

4
5

/* Unsafe */
extract ( ether );
if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 )

}

1
2
3

4
5
6

7
8

/* Safe */
extract ( ether );
if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 );
if ( ipv4 . ihl != 0 x5 ) {
extract ( ipv4opt )

}

}

(x :{ y:𝜖 |y. pkt_in . length > 280}) ->

{y:⊤|(( y. ipv4 . valid && y. ipv4 . ihl != 0 x5 ) => y. ipv4opt . valid ) &&

(( y. ipv4 . valid && y. ipv4 . ihl == 0 x5 ) => !y. ipv4opt . valid )}

Fig. 12. IPv4 Options example. Top left: doesn’t typecheck; right: typechecks; bottom: Π4 type encoding the
IPv4-Option specification.

IPv4 — Time To Live. For Internet Protocol (IP) packets, the time to live (TTL) limits how often a
packet can be forwarded from one network switch to another. Every time a packet is forwarded,
TTL is decremented; when TTL is zero before the packet has reached its destination, forwarding
halts to eliminate the risk of infinite loops.5 The code snippet in the top left side of Figure 11 violates
the property because the packet is always forwarded on the same port while TTL is decremented.
We can detect this violation by checking the program with the type at the bottom of Figure 11,
which reads as: Starting in a heap where at least IPv4 is valid, after executing the ingress code, still
at least IPv4 is valid and if the IPv4 TTL is zero, the value of egress_spec indicates that the packet
will be dropped. The program in the top right of Figure 11 successfully typechecks with the type.

IPv4 Options. The standard IPv4 header consists of at least 160 bits, but it may also carry additional
data in optional fields. The Internet Header Length (IHL) field specifies the length of the header as
multiples of 32 and indicates whether additional data is available. The minimum IHL is 5 (5∗32 = 160)
and the maximum is 15. Due to their flexibility, IP options are notoriously difficult to parse, and
many real-world network devices handle them incorrectly. We can use Π4’s type system to ensure
that we also extract the IPv4 options from the input packet, whenever IPv4 is valid and IHL > 5. The
type shown in the bottom of Figure 12 states that executing the parser in the empty heap where
enough bits are available to extract Ethernet, IPv4 and IPv4 options, produces a heap satisfying
the constraint that when IPv4 is valid and IHL is 5, IPv4 options are not valid, and when IPv4 is

5Strictly speaking, IPv4 requires a special ICMP message to be returned to the sender to indicate the error.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:19

1
2

3

/* Unsafe */
extract ( ether );
extract ( ipv4 )

1
2

3
4
5

/* Safe */
extract ( ether );
if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 )

}

(x: {y:𝜖 | y. pkt_in . length > 272}) ->

{y:⊤ | y. ipv4 . valid => y. ether . etherType == 0 x0800 }

Fig. 13. Header dependency example. Top left: doesn’t typecheck; top right: typechecks; bottom: Π4 type
encoding IPv4’s dependency on Ethernet.

valid and IHL > 5, then IPv4 options are valid. Figure 12 shows one example where this property is
violated (top left) and one where it holds (top right).

Header Dependencies. Most protocols have some way of keeping track of what other protocols
are encapsulated in the payload of a packet—i.e., which header follows next. The correspondence
between field values and protocols is typically defined as part of the protocol standard. For example,
an Ethernet frame uses the EtherType field (written ether.etherType) for this purpose: a value
of 0x0800 indicates that the next header is an IPv4 header, while a value of 0x86dd indicates that
the next header is an IPv6 header. This is specified in the type at the bottom of Figure 13. The
code snippet on the top left of Figure 13 violates the dependency between the IPv4 header and the
EtherType field of the Ethernet header. Our type checker detects this by checking that executing
the parser on an empty heap with enough bits to extract both Ethernet and IPv4, produces a heap
with either an invalid or a valid IPv4 header and an EtherType value of 0x0800. The code on the
top right of Figure 13 fixes the error by only extracting ipv4 when ether.etherType is 0x0800.

5.2 Basic Safety Properties
Π4’s type system can be also used to ensure safety properties. We discussed how it detects accesses
to invalid header instances in Section 2. Here we present an example showing how it can be used
to enforce determined forwarding [Liu et al. 2018; Stoenescu et al. 2018]. Typical P4 programs
contain thousands of paths on which a packet can be processed. To avoid situations where packets
are dropped unexpectedly, a desirable invariant is that each program path contains an explicit
forwarding decision—i.e., packets are either forwarded on some switch port or dropped. Our type
checker is able to detect violations of this property. The type in the bottom of Figure 14 shows one
way of encoding this specification as a type. Under the assumption that the egress specification is
initialized with a dummy value of 0x0, the type asserts that it is, at some point, modified during
the execution of the pipeline, i.e., a forwarding decision is made for every packet. The program on
the top left of Figure 14 fails to typecheck with the type, because the egress specification is unset
for packets with ipv4.dst equal to 0x0a0a0a0a. The program on the top right of Figure 14 fixes
this issue via an else-case that assigns the egress specification to 0x1FF.

5.3 Parser-Deparser Compatibility
A P4 program typically defines the parser, controls for ingress and egress pipelines, and the
deparser.6 In practice, parsing and deparsing may also happen between the ingress and egress
stages—i.e., the deparser code is additionally executed at the end of the ingress followed by the
parser code, before the egress. In such cases, it is important to ensure that data intended to be

6Why this four-phase structure? Having separate ingress and egress pipelines allows packet processing to occur both before
and after packets are scheduled, typically using one or more queues.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:20

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1
2

3
4
5

6

/* Unsafe */
if ( ipv4 . valid ) {

if ( ipv4 . dst != 0 x0a0a0a0a ) {

stdmeta . egress_spec := 0 x1FF

}

}

1
2

3
4
5

6
7

8

/* Safe */
if ( ipv4 . valid ) {

if ( ipv4 . dst != 0 x0A0A0A0A ) {
stdmeta . egress_spec := 0 x1

} else {

stdmeta . egress_spec := 0 x1FF

}

}

(x :{ y:ipv4~| y. stdmeta . valid }) -> {y:⊤| y. stdmeta . egress_spec != 0 x0 }

Fig. 14. Determined forwarding example. Top left: ill-typed; top right: well-typed; bottom: determined for-
warding specification encoded as Π4 type.

carried from ingress to egress is serialized and deserialized correctly. Otherwise, headers may be
unexpectedly removed from the packet.

For example, assume that the parser shown in Figure 15 successfully parses the Ethernet and
IPv4 headers from the input packet, but not a VLAN header. From the code we can conclude that
EtherType must be 0𝑥0800. Let’s further assume that the programmer intends the ingress control
in the middle right of Figure 15. After parsing, the switch checks if a VLAN header is present.
If a VLAN header was already parsed from the input packet, no changes are made. Otherwise a
VLAN header is added (Line 27) and the EtherType of the Ethernet header is updated accordingly.
If an IPv4 header is present, the EtherType must be updated accordingly (Line 31) to obtain a
protocol-conformant packet. Now, assume that the programmer forgot the statement on Line 31,
i.e., didn’t update ether.etherType (this unsafe example is in the left of Figure 15). After running
the deparser at the end of ingress, all three headers are serialized: The first 112 bits correspond
to the Ethernet header, followed by 32 bits of the VLAN header, and another 160 bits of the IPv4
header. Since the programmer forgot to update EtherType, bits 96 to 112 contain the value 0x0800.
If the parser runs with this bitstream as the input, it will first parse the Ethernet header, then look
at the etherType and given the value 0𝑥0800, it will continue to parse the IPv4 header. Hence, the
bits of the VLAN header are parsed as an IPv4 header, leading to a corrupted packet.

To avoid such errors, we want to enforce the invariant that all instances valid at the end of ingress
are equivalent to those obtained after deparsing and re-parsing. We instruct our type checker to
verify this property via the type on Line 36, by checking the whole program with a type that
ensures there are enough bits to parse the headers, shown on Line 1.

5.4 Mutual Exclusion of Headers
The parser shown on the top of Figure 16 conditionally parses either IPv4 or IPv6. Because only
one of the paths is taken at runtime, it should never happen that both instances are valid at the
same time. This property might be exploited in an implementation, allowing the same memory to
be used to store both headers. In this small example, it is easy to see that this invariant holds. But
in larger programs it is difficult to track which header instances are valid on which execution paths.
We can check that the property continues to hold in the ingress in the middle of Figure 16 using
the type in the ascription on Line 1. The ingress code in the middle left of Figure 16 exemplifies
a violation of the property: If a packet enters the control block with a valid IPv4 header, it will
leave with both a valid IPv4 and a valid IPv6 header; a violation of our property. The code on the
middle right is safe because it includes a conditional that explicitly checks the validity of IPv4
before adding IPv6. The combination of union types and refinement types makes our type system
capable of such precise path-dependent reasoning.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:21

1
2

3
4

5
6
7

8
9
10

11
12

13
14
15

16

34
35

36
37
38

39

Parser ≜

extract ( ether );
if ( ether . etherType == 0 x8100 ) {

extract ( vlan );
if ( vlan . etherType == 0 x0800 ) {

extract ( ipv4 )

}

} else {

if ( ether . etherType == 0 x0800 ) {

extract ( ipv4 )

}

}

Deparser ≜

if ( ether . valid ) { remit ( ether ) };
if ( vlan . valid ) { remit ( vlan ) };
if ( ipv4 . valid ) { remit ( ipv4 ) }

17
18

19
20
21

22
23

24

25
26

27
28

29
30
31

32
33

UnsafeIngress ≜

if (! vlan . valid ) {

add ( vlan );
vlan . etherType := 0 x0 ;
if ( ipv4 . valid ) {

vlan . etherType := 0 x0800

}

};

SafeIngress ≜

if (! vlan . valid ) {

add ( vlan );
vlan . etherType := 0 x0 ;
ether . etherType := 0 x8100 ;
if ( ipv4 . valid ) {

vlan . etherType := 0 x0800 ;

}

}

Parser ; Ingress ; /* Ingress is either UnsafeIngress or SafeIngress
( Deparser ; remit ; Parser ) as

*/

(x :{ z:ether~|z. ether . etherType == 0 x8100 && z. vlan . valid &&

(z. ipv4 . valid <=> z. vlan . etherType == 0 x0800 ) &&
z. pkt_out . length == 0 &&
z. pkt_in . length > 0}) -> {y:⊤| x === y}

(x :{ y:𝜖 |y. pkt_out . length == 0 && y. pkt_in . length > 304}) -> ⊤

Fig. 15. Roundtripping Definitions. Top left: common parser and deparser; top right: unsafe and safe ingress
code; middle: the pipeline, which typechecks with Ingress ↦→ UnsafeIngress, but not with Ingress ↦→
UnsafeIngress; bottom: the type at which to check the full pipeline.

1
2

3
4
5

6
7

8
9
10

11
12

13

( extract ( ether );
if ( ether . etherType == 0 x86dd ) { extract ( ipv6 ) }
else { if ( ether . etherType == 0 x0800 ) { extract ( ipv4 ) } })

as (x :{ y:𝜖 |y. pkt_in . length>432 }) -> {y:ether~|!(y. ipv4 . valid && y. ipv6 . valid ) };

Ingress /* Can be SafeIngress or UnsafeIngress */

as (x: {y: ether ~| !(y. ipv4 . valid && y. ipv6 . valid ) }) ->

{y: ether ~| !(y. ipv4 . valid && y. ipv6 . valid ) }) ;

if ( ether . valid ) { remit ( ether ) };
if ( ipv4 . valid ) { remit ( ipv4 ) };
if ( ipv6 . valid ) { remit ( ipv6 ) }

UnsafeIngress ≜

add ( ipv6 )
ether . etherType := 0 x86DD

(x :{ y:𝜖 |y. pkt_in . length>432 }) -> ⊤

14
15

16
17

18

SafeIngress ≜

if ( ipv4 . valid ) {

add ( ipv6 );
ether . etherType := 0 x86DD

}

Fig. 16. Mutual exclusion example: IPv4 and IPv6 should never be simultaneously valid. Top: Common pipeline;
middle left: unsafe Ingress code; middle right: safe Ingress code; bottom: whole program type.

5.5 Limitations
There are a few P4 features that our Π4 prototype does not support, mostly because they pose
challenges to SMT-based approaches to verification: hash functions, externs (a kind of foreign

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:22

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Fig. 17. Modular router design

1

2
3

4

extract ( vlan );
Ingress /* Customer Specified . Default, Overwrite, Table, or UnsafeActions */

as (x:Σx: stdmeta . ipv4 ) -> {y:Σy: stdmeta ~. ipv4 ~| y. vlan == x. vlan };

remit ( vlan )

Fig. 18. Instantiation of modular router design; the parser (Pre) and deparser (Post) are provided by the
vendor, the Ingress code is provided by the customer.

function interface into the hardware), and registers. The unpredictability of hash functions is
difficult to verify, but we can either over-approximate them as uninterpreted functions, or use
a more fine-grained approach such as concolic verification. Externs either need to be annotated
with specific types, or over-approximated as uninterpreted functions. Registers are on-switch
state that can be modified by the packet or the controller and persists between packets. This
is tricky to represent in the semantics and has some distributed computing concerns. We could
over-approximate the behavior by havoc-ing the values every time the register is read.

6 MODULARITY REASONING WITH Π4
An emerging design pattern for data plane switches is partial programmability, e.g., Cisco’s
daPIPE [Baldi 2019], which is designed for the Nexus 3400 switch [Cisco 2018]. The idea is that
a device vendor provides a partially-implemented pipeline together with a set of program points
where customers can inject custom code as shown in Figure 17. The designer requires that customer
programs satisfy certain properties, but in current architectures, they are not automatically checked.
To illustrate, consider a deployment of the customizable pipeline in a campus network where
network engineers want to experiment with in-band network telemetry (INT) without perturbing
the VLAN tag, which is used to enforce security policies. Let’s say there are four classes of traffic,
Visitor, Student, Faculty, and Staff, each with unique VLAN identifiers. We want to ensure
that no matter how Ingress is instantiated in the left of Figure 18, it cannot cause students
and visitors to acquire privileges of faculty or staff—e.g., this might leak confidential data. With
Π4, we can design a modular system that statically checks invariants on customer programs.
Practically, we can ensure that VLAN is not changed by checking that customer’s code has a type
like: (𝑥 : 𝜏) → {𝑦 : 𝜏 ′ | 𝑥 .vlan.vid = 𝑦.vlan.vid}, where the 𝜏 and 𝜏 ′ are appropriate for the
specific pipeline. We check, once-and-for-all, that the surrounding switch code composes with this
type, and incrementally check that the customer code has this type (for an appropriate 𝜏).

6.1 Specifying an Invariant
To further illustrate, consider the toy example shown the right of Figure 18, which has a VLAN
instance (32 bits) and the standard metadata used in the P4 switch model (325 bits), including a
9-bit egress specification stdmeta.egress_spec, and a 12-bit vlan tag field, vlan.vid. The control
flow simply extracts the VLAN instance, executes the modular Ingress control, and then emits

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:23

5

6

7
8
9

10
11

12
13
14

15

Default ≜ skip

Table ≜

add ( _vlan_table );
if ( _vlan_table . vid_key ==

vlan . vid ){

if ( _vlan_table . act == 0 b0 ){

stdmeta . egress_spec := 0 x1FF

} else {

stdmeta . egress_spec := 0 x1

}

}

16

17

18
19
20

21
22

23
24
25

26

Overwrite ≜ vlan . vid := Faculty

UnsafeActions ≜

add ( _vlan_table );
if ( _vlan_table . vid_key ==

vlan . vid ) {

if ( _vlan_table . act == 0 b0 ) {

vlan . vid := Faculty

} else { vlan . vid := Staff }

} else {

vlan . vid := Visitor

}

Fig. 19. A collection of safe and unsafe customer implementations for the Ingress module from Figure 18.
Top Left: Default; Top Right: Overwrite; Bottom Left: Table; Bottom Right: Unsafe Actions

the VLAN header. We want the program to typecheck with type (𝑥 : {𝑥 : stdmeta | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | >
32}) → Σ𝑦 : stdmeta~.vlan~.

In this example, the type ascription provides compositional reasoning—i.e., we don’t need to
re-check that the whole pipeline is well-typed. Instead, we check once-and-for all that extract (vlan)
has type (𝑥 : {𝑥 : stdmeta | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | > 32}) → (𝑥 : (Σ𝑥 : stdmeta.ipv4)), and that remit (vlan)
has type (𝑥 : ({𝑥 : Σ𝑥 : stdmeta.ipv4 | 𝑥 .vlan = 𝑦.vlan})) → Σ𝑦 : stdmeta~.vlan~ in context
(𝑦 : Σ𝑥 : stdmeta.ipv4). Both are easy to check.

Now, when we swap in different implementations for Ingress, we only need to check that it
has its ascribed type on Line 3 of Figure 18, without rechecking the surrounding code. With the
infrastructure Π4’s type system provides, network engineers can make changes to their experimental
module Ingress and check its compatibility with the switch without re-checking the feasibility of
the whole switch in a modular fashion.

6.2 Checking Customer Programs
We now consider a collection of customer programs as shown in Figure 19 that an engineer may
want to install into the switch and how Π4 prevents security vulnerabilities by ensuring the
customer code has the type annotated on Line 3 of Figure 18.

Default. Consider the empty program, shown in the top left of Figure 18, which would surely be
the default behavior when the programmer hasn’t written any code yet. To typecheck this no-op
module, we check that skip has the ascribed type, which it clearly does, since it does not change
the value of the program.

Overwrite. Conversely, if the customer were to install a blatantly incorrect program as the one
in the top right of Figure 18, which always overwrites the VLAN tag with the identifier reserved
for faculty members, the type system complains that the following subtyping check fails—when
𝑥 .vlan.vid is, say, Student, the two types denote disjoint sets of heaps.

(𝑥 : Σ𝑦 : stdmeta.vlan)

⊢ {𝑤 : Σ𝑦 : stdmeta~.vlan~ | 𝑤 .vlan.vid = Faculty}

<: {𝑤 : Σ𝑦 : stdmeta~.vlan~ | 𝑤 .vlan.vid = 𝑥 .vlan.vid},

Table. We model match-action tables using an encoding similar to the one used in p4v [Liu et al.
2018], where we create an extra header that captures the keys and selected action. Consider the
vlan table on the bottom left of Figure 18, which matches on vlan.vid and selects one of two
actions: the first sets the egress_spec to 0x1FF; the second sets it to 0x001. To encode this table,

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:24

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

we create a new header _vlan_table with a 12-bit field vid_key and a 1-bit field act, modelling
the table application via the code shown in the bottom left of Figure 19. This will typecheck since
no branch of the code modifies the vlan.vid field, and _vlan_table is permitted to be valid.

Unsafe Actions. Now consider a vlan table where each action does modify the VLAN id. For
example, the table shown in the bottom right of Figure 18 can either set the VID to one of
{Faculty, Staff}, or, if the packet misses in the table, to Visitor. Here, the VLAN id is clobbered
whenever this table is applied, triggering a violation of the subset check just as with Overwrite.

7 RELATED WORK

Formal Reasoning for P4 Programs. A number of verification approaches have been proposed
for P4 programs. p4v [Liu et al. 2018] applies classical techniques based on predicate transformer
semantics to achieve monolithic verification of P4 programs. Vera [Stoenescu et al. 2018] and
P4-Assert [Freire et al. 2018] are symbolic execution engines for P4. The bf4 tool [Dumitrescu
et al. 2020] follows the approach of p4v, but also attempts to infer control-plane constraints that
are sufficiently strong to establish correctness, and offers heuristics for repairing programs when
verification fails. SafeP4 [Eichholz et al. 2019] uses a simple type system to track header validity.
Petr4 [Doenges et al. 2021] develops a formal semantics for P4 but does not itself offer verification
tools. In constrast to this earlier work, Π4 uses dependent types and offers compositional verification.

Dependent Types. Early work by Xi and Pfenning [1999] showed how dependent types could
be used to eliminate run-time safety checks—e.g., array bounds checks in imperative programs.
Xanadu [Xi 2000] adds dependent typing to imperative programming, but does not capture the
effect of mutations in the type. Xi and Harper [2001] later showed how dependent types could
be applied to assembly code. Deputy [Condit et al. 2007] used dependent types to reason about
complex, heap-allocated data structures. Similar to Deputy, Π4’s typing rule for modification of
header fields is also inspired by the Hoare axiom for assignment. Π4 is different in that typechecking
has no effect on the run time and also supports path-sensitive reasoning. Similar to Π4, Hoare
Type Theory (HTT) [Nanevski et al. 2006] statically tracks how the heap evolves during execution.
Typing of computations in HTT is similar to the dependent function types Π4– the type captures
the state before and after execution, possibly relating the output type with the input type. In our
domain, this requires bit-by-bit transformations on the input type, provided by chomp. Other type
systems like Ynot [Nanevski et al. 2008], FCSL [Nanevski et al. 2014], and F∗ [Swamy et al. 2016]
provide dependent types for low-level imperative programming. They target general functional
verification and often require manual programs-as-proofs to do so. Π4 is designed with domain-
specific properties of network programming in mind and is fully automatic.

Solver-Aided Tools. Recent work on dependently-typed languages has focused on automation,
building on advances in SAT/SMT solvers to make dependent types usable by ordinary programs.
A prominent example is Liquid Haskell [Rondon et al. 2008], which extends Haskell with decidable
refinement types. Under the hood, proof obligations generated during type checking are transpar-
ently handled by an SMT solver. Just as Liquid Haskell requires its refinements to be in the theory
of quantifier-free integer linear arithmetic in order to be decidable, Π4 stipulates that types must
denote finite sets—a restriction justified by the domain. This assumption lets us encode types into
the effectively propositional fragment of first-order logic over bit vectors.

Formalizing Protocols. Another line of work focuses on language-based specifications of protocols.
CMU’s FoxNet project used SML to specify the behavior of an entire networking stack [Biagioni
et al. 1994]. McCann and Chandra [2000] used a type-based approach to give abstract specifications
of protocols. Grammar-based tools such as PADS [Fisher and Gruber 2005], Narcissus [Delaware

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:25

et al. 2019], and Yakker [Jim et al. 2010], enable specifying the syntax of complex, dependent formats
including network protocols, and provide tools for serializing and deserializing data. They focus
exclusively on deriving correct parsers from a typed representation of data and may be suitable to
describe the header formats and the parser, but there is no equivalent to our chomp operator that
allows us to statically capture how the input packet changes during parsing.

8 CONCLUSION AND FUTURE WORK
This paper presented Π4—the first dependently-typed language for data plane programming—a
domain with difficult challenges where programming language theory can have a big impact. In
particular, low-level data plane languages like P4 seem to be a sweet spot for dependent types. On
the one hand, precise types are necessary because critical correctness properties often hinge on
intricate, bit-level packet formats, where the first few bits of a packet determine the format, the
length, and the processing of the following ones. On the other hand, a high degree of automation is
possible due to the restricted nature of the language, which does not support pointers, loops, or
other features that often complicate very precise type systems. Yet, thus far, dependent typing has
not been explored for data plane programs—the community has relied on verification tools that
lack compositional reasoning.

Π4’s type system is innovative in its combination of refinement types, dependent function types,
a limited form of regular types, including unions, explicit substitutions, and a primitive “chomp”
operation, reminiscent of regular expression derivatives [Brzozowski 1964], which can be used
to give a precise type to P4’s parsing constructs. It is capable of statically checking advanced
properties of data plane programs that combine packet serialization and deserialization operations
with imperative control-flow. Under the hood, an SMT solver automatically discharges the formulas
generated during type checking without requiring any manual proof. We define Π4 formally and
prove type soundness and decidability. Our case studies demonstrate how Π4 supports modular
reasoning in scenarios ranging from basic safety properties to intricate invariants.

There are a number of interesting directions for future work. We plan to investigate connections
that our verified approach to parsing using derivatives may have to other domains, e.g., verified
serializers and deserializers like EverParse [Ramananandro et al. 2019] and Narcissus [Delaware
et al. 2019]. Another direction is to consider the effect of modularity on verification times; if
a tool incrementally caches verification results for ascribed code blocks, it would only have to
check the portions of the code that change between runs of the typechecker. Some preliminary
experiments indicate that modular typechecking offers significant benefits, but an empirical study
to answer this question carefully is left for future work, after we have optimized our prototype.
We also plan to extend Π4 to handle more complicated features of P4 perhaps requiring concolic
techniques [Godefroid et al. 2005]. Further, understanding whether dependent types are the right
interface for modular verification of dataplane programs is important. In fact, user studies inves-
tigating the appropriate typing interfaces, such as gradual typing and type inference, would be
important for guiding the design of impactful systems for modular data plane verification.

ACKNOWLEDGMENTS
We are grateful to the POPL reviewers for their careful feedback and many suggestions for improving
this paper. Our work has been supported in part by the German Research Foundation (DFG) as
part of the Collaborative Research Center (CRC) 1053 MAKI, by the National Research Center for
Applied Cybersecurity ATHENE, by the National Science Foundation under grant FMiTF-1918396
as well as a Graduate Research Fellowship, the Defense Advanced Research Projects Agency under
Contract HR001120C0107, and gifts from Keysight and InfoSys.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:26

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

REFERENCES
M. Baldi. 2019. daPIPE a Data Plane Incremental Programming Environment. In Symposium on Architectures for Networking

and Communications Systems (ANCS). 1–6. https://doi.org/10.1109/ANCS.2019.8901893

Ryan Beckett and Ratul Mahajan. 2020. A General Framework for Compositional Network Modeling. In Workshop on Hot

Topics in Networks (HotNets). 8–15. https://doi.org/10.1145/3422604.3425930

Edoardo Biagioni, Robert Harper, Peter Lee, and Brian G. Milnes. 1994. Signatures for a Network Protocol Stack: A Systems
Application of Standard ML. In Conference on LISP and Functional Programming (LFP). 55–64. https://doi.org/10.1145/
182409.182431

Pat Bosshart, Dan Daly, Glen Gibb, Martin Izzard, Nick McKeown, Jennifer Rexford, Cole Schlesinger, Dan Talayco, Amin
Vahdat, George Varghese, and David Walker. 2014. P4: Programming Protocol-Independent Packet Processors. SIGCOMM
Computer Communications Review (CCR) (July 2014), 87–95. https://doi.org/10.1145/2656877.2656890

Pat Bosshart, Glen Gibb, Hun-Seok Kim, George Varghese, Nick McKeown, Martin Izzard, Fernando Mujica, and Mark
Horowitz. 2013. Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN. In
Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and
Protocols for Computer Communication (SIGCOMM). 99–110. https://doi.org/10.1145/2486001.2486011

Janusz A. Brzozowski. 1964. Derivatives of Regular Expressions. J. ACM 11, 4 (Oct. 1964), 481–494. https://doi.org/10.1145/

321239.321249

Giuseppe Castagna, Kim Nguyen, Zhiwu Xu, Hyeonseung Im, Sergueï Lenglet, and Luca Padovani. 2014. Polymorphic
Functions with Set-Theoretic Types: Part 1: Syntax, Semantics, and Evaluation. In Symposium on Principles of Programming
Languages (POPL). 5–17. https://doi.org/10.1145/2535838.2535840

Cisco. 2018. Cisco Nexus 3000 Series Switches. https://www.cisco.com/c/en/us/products/switches/nexus-3000-series-

switches/index.html

Jeremy Condit, Matthew Harren, Zachary Anderson, David Gay, and George C. Necula. 2007. Dependent Types for Low-Level
Programming. In European Symposium on Programming (ESOP). 520–535. https://doi.org/10.1007/978-3-540-71316-6_35
Benjamin Delaware, Sorawit Suriyakarn, Clément Pit-Claudel, Qianchuan Ye, and Adam Chlipala. 2019. Narcissus: Correct-
by-Construction Derivation of Decoders and Encoders from Binary Formats. Proceedings of the ACM Programming
Languages (PACMPL) 3, ICFP, Article 82 (July 2019). https://doi.org/10.1145/3341686

Ryan Doenges, Mina Tahmasbi Arashloo, Santiago Bautista, Alexander Chang, Newton Ni, Samwise Parkinson, Rudy
Peterson, Alaia Solko-Breslin, Amanda Xu, and Nate Foster. 2021. Petr4: Formal Foundations for P4 Data Planes.
Proceedings of the ACM on Programming Languages (PACMPL) 5, POPL, Article 41 (Jan. 2021). https://doi.org/10.1145/
3434322

Dragos Dumitrescu, Radu Stoenescu, Lorina Negreanu, and Costin Raiciu. 2020. Bf4: Towards Bug-Free P4 Programs. In
Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and
Protocols for Computer Communication (SIGCOMM). 571–585. https://doi.org/10.1145/3387514.3405888

Matthias Eichholz, Eric Campbell, Nate Foster, Guido Salvaneschi, and Mira Mezini. 2019. How to Avoid Making a Billion-
Dollar Mistake: Type-Safe Data Plane Programming with SafeP4. In European Conference on Object-Oriented Programming
(ECOOP). 12:1–12:28. https://doi.org/10.4230/LIPIcs.ECOOP.2019.12

Robert Ennals, Richard Sharp, and Alan Mycroft. 2004. Linear Types for Packet Processing. In European Symposium on

Programming (ESOP). 204–218. https://doi.org/10.1007/978-3-540-24725-8_15

Kathleen Fisher and Robert Gruber. 2005. PADS: A Domain-Specific Language for Processing Ad Hoc Data. In Conference on

Programming Language Design and Implementation (PLDI). 295–304. https://doi.org/10.1145/1065010.1065046

Lucas Freire, Miguel Neves, Lucas Leal, Kirill Levchenko, Alberto Schaeffer-Filho, and Marinho Barcellos. 2018. Uncovering
Bugs in P4 Programs with Assertion-Based Verification. In Symposium on SDN Research (SOSR). Article 4, 7 pages.
https://doi.org/10.1145/3185467.3185499

Jiaqi Gao, Ennan Zhai, Hongqiang Harry Liu, Rui Miao, Yu Zhou, Bingchuan Tian, Chen Sun, Dennis Cai, Ming Zhang, and
Minlan Yu. 2020. Lyra: A Cross-Platform Language and Compiler for Data Plane Programming on Heterogeneous ASICs.
In Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and
Protocols for Computer Communication (SIGCOMM). 435–450. https://doi.org/10.1145/3387514.3405879

Vladimir Gapeyev and Benjamin C. Pierce. 2003. Regular Object Types. In European Conference on Object-Oriented Program-

ming (ECOOP). 151–175. https://doi.org/10.1007/978-3-540-45070-2_8

Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed automated random testing. In Conference on

Programming Language Design and Implementation (PLDI). 213–223. https://doi.org/10.1145/1065010.1065036

Toke Høiland-Jørgensen, Jesper Dangaard Brouer, Daniel Borkmann, John Fastabend, Tom Herbert, David Ahern, and
David Miller. 2018. The EXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel. In
International Conference on Emerging Networking EXperiments and Technologies (CoNEXT). 54–66. https://doi.org/10.
1145/3281411.3281443

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:27

Haruo Hosoya and Benjamin C. Pierce. 2003. XDuce: A Statically Typed XML Processing Language. ACM Transactions on

Internet Technology (TOIT) 3, 2 (May 2003), 117–148. https://doi.org/10.1145/767193.767195

Stephen Ibanez, Gordon Brebner, Nick McKeown, and Noa Zilberman. 2019. The P4->NetFPGA Workflow for Line-Rate Packet
Processing. In Symposium on Field-Programmable Gate Arrays (FPGA). 1–9. https://doi.org/10.1145/3289602.3293924
Trevor Jim, Yitzhak Mandelbaum, and David Walker. 2010. Semantics and Algorithms for Data-Dependent Grammars. In

Symposium on Principles of Programming Languages (POPL). 417–430. https://doi.org/10.1145/1706299.1706347

Xin Jin, Xiaozhou Li, Haoyu Zhang, Robert Soulé, Jeongkeun Lee, Nate Foster, Changhoon Kim, and Ion Stoica. 2017.
NetCache: Balancing Key-Value Stores with Fast In-Network Caching. In Symposium on Operating Systems Principles
(SOSP). 121–136. https://doi.org/10.1145/3132747.3132764

Jed Liu, William Hallahan, Cole Schlesinger, Milad Sharif, Jeongkeun Lee, Robert Soulé, Han Wang, Călin Caşcaval, Nick
McKeown, and Nate Foster. 2018. p4v: Practical Verification for Programmable Data Planes. In Conference of the
Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer
Communication (SIGCOMM). 490–503. https://doi.org/10.1145/3230543.3230582

Conor McBride. 2001. The derivative of a regular type is its type of one-hole contexts. Extended abstract, available at

http://strictlypositive.org/diff.pdf.

Peter J. McCann and Satish Chandra. 2000. Packet Types: Abstract Specification of Network Protocol Messages. In Conference
of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for
Computer Communication (SIGCOMM). 321–333. https://doi.org/10.1145/347059.347563

Chitra Muthukrishnan, Vern Paxson, Mark Allman, and Aditya Akella. 2010. Using Strongly Typed Networking to Architect
for Tussle. In Workshop on Hot Topics in Networks (HotNets). Article 9, 6 pages. https://doi.org/10.1145/1868447.1868456
Aleksandar Nanevski, Ruy Ley-Wild, Ilya Sergey, and Germán Andrés Delbianco. 2014. Communicating State Transition
Systems for Fine-Grained Concurrent Resources. In European Symposium on Programming (ESOP). 290–310. https:
//doi.org/10.1007/978-3-642-54833-8_16

Aleksandar Nanevski, Greg Morrisett, and Lars Birkedal. 2006. Polymorphism and Separation in Hoare Type Theory. In

International Conference on Functional Programming (ICFP). 62–73. https://doi.org/10.1145/1159803.1159812

Aleksandar Nanevski, Greg Morrisett, Avraham Shinnar, Paul Govereau, and Lars Birkedal. 2008. Ynot: Dependent Types
for Imperative Programs. In International Conference on Functional Programming (ICFP. 229–240. https://doi.org/10.1145/
1411204.1411237

Tahina Ramananandro, Antoine Delignat-Lavaud, Cedric Fournet, Nikhil Swamy, Tej Chajed, Nadim Kobeissi, and Jonathan
Protzenko. 2019. EverParse: Verified Secure Zero-Copy Parsers for Authenticated Message Formats. In USENIX Security
Symposium (USENIX Security). 1465–1482. https://www.usenix.org/conference/usenixsecurity19/presentation/delignat-
lavaud

Patrick M. Rondon, Ming Kawaguci, and Ranjit Jhala. 2008. Liquid Types. In Conference on Programming Language Design

and Implementation (PLDI). 159–169. https://doi.org/10.1145/1375581.1375602

Hardik Soni, Myriana Rifai, Praveen Kumar, Ryan Doenges, and Nate Foster. 2020. Composing Dataplane Programs with
𝜇P4. In Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures,
and Protocols for Computer Communication (SIGCOMM). 329–343. https://doi.org/10.1145/3387514.3405872

Radu Stoenescu, Dragos Dumitrescu, Matei Popovici, Lorina Negreanu, and Costin Raiciu. 2018. Debugging P4 Programs with
Vera. In Conference of the Special Interest Group on Data Communication on the Applications, Technologies, Architectures,
and Protocols for Computer Communication (SIGCOMM). 518–532. https://doi.org/10.1145/3230543.3230548

Nikhil Swamy, Cătălin Hriţcu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Simon Forest, Karthikeyan Bharga-
van, Cédric Fournet, Pierre-Yves Strub, Markulf Kohlweiss, Jean-Karim Zinzindohoue, and Santiago Zanella-Béguelin.
2016. Dependent Types and Multi-Monadic Effects in F*. In Symposium on Principles of Programming Languages (POPL).
256–270. https://doi.org/10.1145/2837614.2837655

Sam Tobin-Hochstadt and Matthias Felleisen. 2010. Logical Types for Untyped Languages. In International Conference on

Functional Programming (ICFP). 117–128. https://doi.org/10.1145/1863543.1863561

Niki Vazou, Eric L. Seidel, Ranjit Jhala, Dimitrios Vytiniotis, and Simon Peyton-Jones. 2014. Refinement Types for Haskell.

In International Conference on Functional Programming (ICFP). 269–282. https://doi.org/10.1145/2628136.2628161
Niki Vazou, Éric Tanter, and David Van Horn. 2018. Gradual Liquid Type Inference. Proceedings of the ACM on Programming

Languages (PACMPL) 2, OOPSLA, Article 132 (Oct. 2018), 25 pages. https://doi.org/10.1145/3276502

Han Wang, Robert Soulé, Huynh Tu Dang, Ki-Suh Lee, Vishal Shrivastav, Nate Foster, and Hakim Weatherspoon. 2017.
P4FPGA: A Rapid Prototyping Framework for P4. In Symposium on SDN Research (SOSR). 122–135. https://doi.org/10.
1145/3050220.3050234

Hongwei Xi. 2000. Imperative programming with dependent types. In Symposium on Logic in Computer Science (LICS).

375–387. https://doi.org/10.1109/LICS.2000.855785

Hongwei Xi and Robert Harper. 2001. A Dependently Typed Assembly Language. In International Conference on Functional

Programming (ICFP). 169–180. https://doi.org/10.1145/507635.507657

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:28

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Hongwei Xi and Frank Pfenning. 1999. Dependent Types in Practical Programming. In Symposium on Principles of

Programming Languages (POPL). 214–227.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:29

A DEFINITIONS

A.1 Chomp / HeapRef

chomp1 : 𝜏 × 𝐵𝑛 → 𝜏

chomp1 (Σ𝑥 : 𝜏1.𝜏2, bn) ≜ Σ𝑥 : chomp1(𝜏1, bn).chompRef1(𝜏2, 𝑥, bn) +
Σ𝑥 : {𝑦 : 𝜏1 | |𝑦.𝑝𝑘𝑡𝑖𝑛 | = 0}.chomp1(𝜏2, bn)

chomp1(𝜏1 + 𝜏2, bn) ≜ chomp1(𝜏1, bn) + chomp1(𝜏2, 𝑏0)

𝜑
chomp1({𝑥 : 𝜏 | 𝑒}, bn) ≜ {𝑥 : chomp1(𝜏, bn) | chomp
1 (𝑒, 𝑥, bn)}
chomp1(𝜏1 [𝑥 ↦→ 𝜏2], bn) ≜ chomp1(𝜏1, bn) [𝑥 ↦→ 𝜏2]

chomp1(𝜏, _) ≜ 𝜏

chompRef1 : 𝜏 × X × 𝐵𝑛 → 𝜏

chompRef1(Σ𝑥 : 𝜏1.𝜏2, 𝑥, bn) ≜ Σ𝑥 : chompRef1(𝜏1, 𝑥, bn).chompRef1(𝜏2, 𝑥, bn)
chompRef1(𝜏1 + 𝜏2, 𝑥, bn) ≜ chompRef1(𝜏1, 𝑥, bn) + chompRef1(𝜏2, 𝑥, bn)
𝜑
chompRef1({𝑥 : 𝜏 | 𝜑 }, 𝑥, bn) ≜ {𝑥 : chompRef1(𝜏, 𝑥, bn) | chomp
1 (𝜑, 𝑥, bn)}
chompRef1(𝜏1 [𝑦 ↦→ 𝜏2], 𝑥, bn) ≜ chompRef1(𝜏1, 𝑥, bn) [𝑦 ↦→ chompRef (𝜏2, 𝑥, bn)]

chompRef1(𝜏, _, _) ≜ 𝜏

𝜑
1 : 𝜑 × X × 𝐵𝑛 → 𝜑
chomp

𝜑
𝑒
𝑒
1 (𝑡1 = 𝑡2, 𝑥, bn) ≜ chomp
1 (𝑡2, 𝑥, bn)
1 (𝑡1, 𝑥, bn) = chomp
chomp
𝜑
𝑒
𝑒
1 (𝑡1 > 𝑡2, 𝑥, bn) ≜ chomp
1 (𝑡1, 𝑥, bn) > chomp
1 (𝑡2, 𝑥, bn)
chomp
𝜑
𝜑
𝜑 (𝜑2, 𝑥, bn)
1 (𝜑1 ∧ 𝜑2, 𝑥, bn) ≜ chomp
1 (𝜑1, 𝑥, bn) ∧ chomp
chomp
𝜑
𝜑
1 (¬𝜑, 𝑥, bn) ≜ ¬chomp
1 (𝜑, 𝑥, bn)
chomp

𝜑
1 (𝜑, _, _) ≜ 𝜑
chomp

𝑒
1 (|𝑥 .𝑝𝑘𝑡𝑖𝑛 |, 𝑦, _) ≜
chomp

𝑒
1 : 𝑒 × X × 𝐵𝑛 → 𝑒
chomp
|𝑥 .𝑝𝑘𝑡𝑖𝑛 | + 1
|𝑥 .𝑝𝑘𝑡𝑖𝑛 |

(cid:40)

if 𝑥 = 𝑦
otherwise

𝑒
1 (𝑥 .𝑝𝑘𝑡𝑖𝑛, 𝑦, bn) ≜
chomp

(cid:40)

⟨bn⟩@𝑥 .𝑝𝑘𝑡𝑖𝑛
𝑥 .𝑝𝑘𝑡𝑖𝑛

if 𝑥 = 𝑦
otherwise




𝑒
1 (𝑥 .𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ], 𝑦, bn) ≜
chomp

𝑥 .𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ]
⟨bn⟩
⟨bn⟩@𝑥 .𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 − 1]
𝑥 .𝑝𝑘𝑡𝑖𝑛 [𝑙 − 1 :𝑟 − 1]

if 𝑥 ≠ 𝑦
if 𝑥 = 𝑦 ∧ 𝑟 ≤ 1
if 𝑥 = 𝑦 ∧ 𝑙 = 0
if 𝑥 = 𝑦 ∧ 𝑙 ≠ 0
𝑒
𝑒
𝑒
1 (𝑛 + 𝑚, 𝑦, bn) ≜ chomp
1 (𝑛, 𝑦, bn) + chomp
1 (𝑚, 𝑦, bn)
chomp
𝑒
𝑒
𝑒
1 (𝑏𝑣1@𝑏𝑣2, 𝑦, bn) ≜ chomp
1 (𝑏𝑣1, 𝑦, bn)@chomp
1 (𝑏𝑣2, 𝑦, bn)
chomp
𝑒
1 (𝑒, _, _) ≜ 𝑒
chomp



Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:30

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

heapRef1 : 𝜏 × bn × X × 𝜄 × N → 𝜏

heapRef1(Σ𝑥 : 𝜏1.𝜏2, bn, 𝑦, 𝜄, 𝑛) ≜ Σ𝑥 : heapRef1 (𝜏1, bn, 𝑦, 𝜄, 𝑛).
heapRef1(𝜏2, bn, 𝑦, 𝜄, 𝑛)

heapRef1(𝜏1 + 𝜏2, bn, 𝑦, 𝜄, 𝑛) ≜ heapRef1(𝜏1, bn, 𝑦, 𝜄, 𝑛)+
heapRef1 (𝜏2, bn, 𝑦, 𝜄, 𝑛)

heapRef1({𝑥 : 𝜏 | 𝜑 }, bn, 𝑦, 𝜄, 𝑛) ≜ {𝑥 : heapRef1(𝜏, bn, 𝑦, 𝜄, 𝑛) |
heapRef1(𝜑, bn, 𝑦, 𝜄, 𝑛)}
heapRef1(𝜏1 [𝑥 ↦→ 𝜏2], bn, 𝑦, 𝜄, 𝑛) ≜ heapRef1(𝜏1, bn, 𝑦, 𝜄, 𝑛) [𝑥 ↦→

heapRef1(𝜏2, bn, 𝑦, 𝜄, 𝑛)]

heapRef1(𝜏, _, _, _, _) ≜ 𝜏

heapRef1 : 𝜑 × bn × X × 𝜄 × 𝑛 → 𝜑

heapRef1(𝑡1 = 𝑡2, bn, 𝑥, 𝜄, 𝑛) ≜ heapRef1(𝑡1, bn, 𝑥, 𝜄, 𝑛) = heapRef1(𝑡2, bn, 𝑥, 𝜄, 𝑛)
heapRef1(𝑡1 > 𝑡2, bn, 𝑥, 𝜄, 𝑛) ≜ heapRef1(𝑡1, bn, 𝑥, 𝜄, 𝑛) > heapRef1(𝑡2, bn, 𝑥, 𝜄, 𝑛)
heapRef1(𝜑1 ∧ 𝜑2, bn, 𝑥, 𝜄, 𝑛) ≜ heapRef1(𝜑1, bn, 𝑥, 𝜄, 𝑛) ∧ heapRef1(𝜑2, bn, 𝑥, 𝜄, 𝑛)

heapRef1(¬𝜑, bn, 𝑥, 𝜄, 𝑛) ≜ ¬heapRef1(𝜑, bn, 𝑥, 𝜄, 𝑛)

heapRef1(𝜑, _, _, _, _) ≜ 𝜑

heapRef1 : 𝑒 × bn × X × 𝜄 × 𝑛 → 𝑒

heapRef1(𝑏 :: 𝑏𝑣, bn, 𝑥, 𝜄, 𝑛) ≜




heapRef1(𝑒, _, _, _) ≜ 𝑒

𝑥 .𝜄 [sizeof (𝜄) − 𝑛 : sizeof (𝜄) − 𝑛 + 1]@
heapRef1(𝑏𝑣, bn, 𝑥, 𝜄, 𝑛)

⟨𝑏⟩@heapRef1(𝑏𝑣, bn, 𝑥, 𝜄, 𝑛)

if 𝑏 = bn
otherwise

A.2 Additional Rules for the Operational Semantics

E-If

⟨𝐼, 𝑂, 𝐻, 𝜑⟩ → 𝜑 ′
⟨𝐼, 𝑂, 𝐻, if (𝜑) then c1 else c2⟩ → ⟨𝐼, 𝑂, 𝐻, if (𝜑 ′) then c1 else c2⟩

E-IfTrue

⟨𝐼, 𝑂, 𝐻, if (true) then c1 else c2⟩ → ⟨𝐼, 𝑂, 𝐻, 𝑐1⟩

E-IfFalse

E-Seq

⟨𝐼, 𝑂, 𝐻, if (false) then c1 else c2⟩ → ⟨𝐼, 𝑂, 𝐻, 𝑐2⟩

⟨𝐼, 𝑂, 𝐻, skip; 𝑐2⟩ → ⟨𝐼, 𝑂, 𝐻, 𝑐2⟩

E-Seq1

⟨𝐼, 𝑂, 𝐻, 𝑐1⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′
1⟩
⟨𝐼, 𝑂, 𝐻, 𝑐1; 𝑐2⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′
1; 𝑐2⟩

E-Mod1

⟨𝐼, 𝑂, 𝐻, 𝑒⟩ → 𝑒 ′
⟨𝐼, 𝑂, 𝐻, 𝜄.𝑓 = 𝑒⟩ → ⟨𝐼, 𝑂, 𝐻, 𝜄.𝑓 := 𝑒 ′⟩

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:31

B SAFETY
We assume that the environment E is empty whenever it is omitted from the entailment relation or
the semantics of expressions and formulae. In the context of the semantics of heap types, we use
(𝐼, 𝑂, 𝐻 ) as a shorthand notation for the heap 𝐻 [𝑝𝑘𝑡𝑖𝑛 ↦→ 𝐼, 𝑝𝑘𝑡𝑜𝑢𝑡 ↦→ 𝑂]. For example, we write
(𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏⟧E instead of 𝐻 [𝑝𝑘𝑡𝑖𝑛 ↦→ 𝐼, 𝑝𝑘𝑡𝑜𝑢𝑡 ↦→ 𝑂] ∈ ⟦𝜏⟧E.

Lemma B.1 (Semantic Entailment). If (𝐼, 𝑂, 𝐻 ) |=E 𝜏, then (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏⟧E
Proof. By induction on 𝜏.

Case 𝜏 = ∅: Immediate, since (𝐼, 𝑂, 𝐻 ) |=E ∅ is a contradiction.
Case 𝜏 = ⊤: Immediate, since ⟦⊤⟧E = H .
Case 𝜏 = Σ𝑥 : 𝜏1.𝜏2: By inversion of entailment, we get
(A1) (𝐼, 𝑂, 𝐻 ) = (𝐼1@𝐼2, 𝑂1@𝑂2, 𝐻1 ∪ 𝐻2) and
(A2) (𝐼1, 𝑂1, 𝐻1) |=E 𝜏1 and
(A3) (𝐼2, 𝑂2, 𝐻2) |=E [𝑥↦→(𝐼1,𝑂1,𝐻1) ] 𝜏2

By (A2) respectively (A3) and the induction hypothesis, we get

(A4) (𝐼1, 𝑂1, 𝐻1) ∈ ⟦𝜏1⟧E and
(A5) (𝐼2, 𝑂2, 𝐻2) ∈ ⟦𝜏2⟧E [𝑥↦→(𝐼1,𝑂1,𝐻1) ].

To show that (𝐼, 𝑂, 𝐻 ) ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E = {ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦𝜏1⟧E ∧ ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ] }, we
have to show that (𝐼, 𝑂, 𝐻 ) is the concatenation of two heaps ℎ1 and ℎ2, where ℎ1 ∈ ⟦𝜏1⟧E
and ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ], which follows from (A1), (A4) and (A5).

Case 𝜏 = 𝜏1 + 𝜏2: By inversion of entailment, either (𝐼, 𝑂, 𝐻 ) |=E 𝜏1 or (𝐼, 𝑂, 𝐻 ) |=E 𝜏2. To show
that (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1 + 𝜏2⟧E = ⟦𝜏1⟧E ∪ ⟦𝜏2⟧E, we have to show that (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1⟧E or
(𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏2⟧E.
Subcase (𝐼, 𝑂, 𝐻 ) |=E 𝜏1: By induction hypothesis, (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1⟧E. We can conclude

(𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1 + 𝜏2⟧E.

Subcase (𝐼, 𝑂, 𝐻 ) |=E 𝜏2: Symmetric to previous subcase.

Case 𝜏 = {𝑥 : 𝜏1 | 𝜑 }: By inversion of entailment, we get
(A1) (𝐼, 𝑂, 𝐻 ) |=E 𝜏 and
(A2) ⟦𝜑⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = 𝑡𝑟𝑢𝑒

To show that (𝐼, 𝑂, 𝐻 ) ∈ ⟦{𝑥 : 𝜏 | 𝜑 }⟧E = {ℎ | ℎ ∈ ⟦𝜏⟧E ∧ ⟦𝜑⟧E [𝑥↦→ℎ] }, we have to show that
(𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏⟧E and that ⟦𝜑⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = 𝑡𝑟𝑢𝑒. The first follows by induction hypothesis
and (A1) and the latter by (A2).

Case 𝜏 = 𝜏1 [𝑥 ↦→ 𝜏2]: By inversion of entailment, we get
(A1) (𝐼2, 𝑂2, 𝐻2) |=E 𝜏2 for some 𝐼2, 𝑂2, 𝐻2 and
(A2) (𝐼, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼2,𝑂2,𝐻2) ] 𝜏1

To show that (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1 [𝑥 ↦→ 𝜏2]⟧E = {ℎ | ℎ2 ∈ ⟦𝜏2⟧E ∧ ℎ ∈ ⟦𝜏1⟧E [𝑥↦→ℎ2 ] }, we
have to show that (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1⟧E [𝑥↦→ℎ2 ] where ℎ2 ∈ ⟦𝜏2⟧E. By induction hypothesis and
(A2) follows that (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1⟧E [𝑥↦→(𝐼2,𝑂2,𝐻2) ]. (𝐼2, 𝑂2, 𝐻2) ∈ ⟦𝜏2⟧E follows by induction
hypothesis and (A1), which concludes this case.

□

Lemma B.2 (Semantic Containment Entails). If (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏⟧E, then (𝐼, 𝑂, 𝐻 ) |=E 𝜏.
Proof. By induction on 𝜏.

Case 𝜏 = ∅: Immediate, since there is no heap in ⟦∅⟧E.
Case 𝜏 = ⊤: Result directly follows by Ent-Top.
Case 𝜏 = Σ𝑥 : 𝜏1.𝜏2: By the semantics of heap types, all heaps ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧ have the form
ℎ = ℎ1 ++ ℎ2, where ℎ1 = (𝐼1, 𝑂1, 𝐻1) ∈ ⟦𝜏1⟧E and ℎ2 = (𝐼2, 𝑂2, 𝐻2) ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1]. By

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:32

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

applying the induction hypothesis, we get (𝐼1, 𝑂1, 𝐻1) |=E 𝜏1 and (𝐼2, 𝑂2, 𝐻2) |=E [𝑥↦→ℎ1 ] 𝜏2.
The result directly follows by Ent-Sigma.

Case 𝜏 = 𝜏1 + 𝜏2: By the semantics of heap types, for any ℎ ∈ ⟦𝜏1 +𝜏2⟧E holds that either ℎ ∈ ⟦𝜏1⟧E

or ℎ ∈ ⟦𝜏2⟧E.
Subcase ℎ ∈ ⟦𝜏1⟧E: By induction hypothesis, ℎ |=E 𝜏1. The result directly follows by Ent-

ChoiceL.

Subcase ℎ ∈ ⟦𝜏1⟧E: Symmetric to previous subcase.

Case 𝜏 = {𝑦 : 𝜏1 | 𝜑 }: By the semantics of heap types, ℎ ∈ ⟦𝜏1⟧E and ⟦𝜑⟧E [𝑥↦→ℎ] = true. By

induction hypothesis, ℎ |=E 𝜏. The result directly follows by Ent-Refine.

Case 𝜏 = 𝜏1 [𝑥 ↦→ 𝜏2]: By the semantics of heap types, ℎ ∈ ⟦𝜏1⟧E [𝑥↦→ℎ2 ] where ℎ2 ∈ ⟦𝜏2⟧E. By
induction hypothesis, ℎ2 |=E 𝜏2 and ℎ |=E [𝑥↦→ℎ2 ] 𝜏1. The result directly follows by Ent-Subst.
□

Lemma B.3 (Subtype Entailment). If (𝐼, 𝑂, 𝐻 ) |=E 𝜏1 and E |= Γ and Γ ⊢ 𝜏1 <: 𝜏2, then

(𝐼, 𝑂, 𝐻 ) |=E 𝜏2.

Proof. By Lemma B.1, (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1⟧E. With E |= Γ and by definition of subtyping, (𝐼, 𝑂, 𝐻 ) ∈
□

⟦𝜏2⟧E. The result follows by Lemma B.2.

Lemma B.4 (Extended Environment Entails). If E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏 and 𝑥 ∉ dom(E),

then E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )] |= Γ, 𝑥 : 𝜏.

Proof. By definition of entailment between environments and typing contexts and by assump-
□

tions.

Lemma B.5 (Included Instances in Domain). If (𝐼, 𝑂, 𝐻 ) |=E 𝜏 and Includes Γ 𝜏 𝜄, then 𝜄 ∈

dom(𝐻 ).

Proof. By Lemma B.1, (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏⟧E. By assumption Includes Γ 𝜏 𝜄 and by definition of
□

inclusion, ∀ℎ ∈ ⟦𝜏⟧E .𝜄 ∈ dom(ℎ), we can conclude that 𝜄 ∈ dom(𝐻 ).

Lemma B.6 (Excluded Instances not in Domain). If (𝐼, 𝑂, 𝐻 ) |=E 𝜏 and Excludes Γ 𝜏 𝜄, then

𝜄 ∉ dom(𝐻 ).

Proof. By Lemma B.1, (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏⟧E. By assumption Excludes Γ 𝜏 𝜄 and by definition of
□

exclusion, ∀ℎ ∈ ⟦𝜏⟧E .𝜄 ∉ dom(ℎ), we can conclude that 𝜄 ∉ dom(𝐻 ).

Lemma B.7 (Expression Progress). If Γ; 𝜏 ⊢ 𝑒 : 𝜎 and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏, then either 𝑒 is

a value or ∃𝑒 ′.⟨𝐼, 𝑂, 𝐻, 𝑒⟩ → 𝑒 ′.

Lemma B.8 (Formulae Progress). If Γ; 𝜏 ⊢ 𝜑 : B and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏, then either 𝜑 is

a value or ∃𝜑 ′.⟨𝐼, 𝑂, 𝐻, 𝜑⟩ → 𝜑 ′

Theorem B.9 (Progress). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏1, then either

𝑐 = skip or there exists ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩ such that ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩.
Proof. By induction on typing derivations of Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2.

Case T-Skip: 𝑐 = skip

The result is immediate.

Case T-Extract: 𝑐 = extract (𝜄) and Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏1) ≥ sizeof(𝜄)

By inversion of (𝐼, 𝑂, 𝐻 ) |=E 𝜏1, we know that 𝐼 contains enough bits such that deserialize𝜂 (𝐼 )
does not fail. Let (𝑣, 𝐼 ′) = deserialize𝜂 (I ) and 𝑂 ′ = 𝑂 and 𝐻 ′ = 𝐻 [𝜄 ↦→ 𝑣] and 𝑐 ′ = skip. The
result follows by E-Extract.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:33

Case T-Reset: 𝑐 = reset

Let 𝐼 ′ = 𝑂@𝐼, 𝑂 ′ = ⟨⟩, 𝐻 ′ = [] and 𝑐 ′ = skip. The result follows by E-Reset.

Case T-Remit: 𝑐 = remit (𝜄) and Includes Γ 𝜏1 𝜄

By Lemma B.5 we know 𝜄 ∈ 𝑑𝑜𝑚(𝐻 ). Let 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂@serialize𝜂 (𝐻 (𝜄)), 𝐻 ′ = 𝐻 and
𝑐 ′ = skip. The result follows by E-Remit

Case T-Mod: 𝑐 = 𝜄.𝑓 := 𝑒 and Includes Γ 𝜏1 𝜄 and F (𝜄, 𝑓 ) = BV and Γ; 𝜏1 ⊢ 𝑒 : BV and 𝜏2 = {𝑦 : ⊤ |

𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}
By Lemma B.7, either 𝑒 is a value or there is some 𝑒 ′ such that ⟨𝐼, 𝑂, 𝐻, 𝑒⟩ → 𝑒 ′.
Subcase 𝑒 = 𝑣: By Lemma B.5, 𝜄 ∈ 𝑑𝑜𝑚(𝐻 ). Let 𝑟 = 𝐻 (𝜄) and 𝑟 ′ = {𝑟 with 𝑓 = 𝑣 }. Let

𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻 [𝜄 ↦→ 𝑟 ] and 𝑐 ′ = skip. The result follows by E-Mod.

Subcase ⟨𝐼, 𝑂, 𝐻, 𝑒⟩ → 𝑒 ′: Let 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻 ′ and 𝑐 ′ = 𝜄.𝑓 := 𝑡 ′. The result follows

by E-Mod1.

Case T-Seq: 𝑐 = 𝑐1; 𝑐2 and Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) → 𝜏 ′

1 and Γ ⊢ 𝑐2 : (𝑥 : 𝜏 ′

1) → 𝜏2

By IH, 𝑐1 is either skip or there is some ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′
If 𝑐1 = skip, let 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻 and 𝑐 ′ = 𝑐2.
The result follows by E-Seq. Otherwise, the result follows by E-Seq1.

1⟩, such that ⟨𝐼, 𝑂, 𝐻, 𝑐1⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′

1⟩.

Case T-If: 𝑐 = if (𝜑) then c1 else c2 and Γ; 𝜏1 ⊢ 𝑒 : B

By Lemma B.8, we have that 𝜑 is either true, false or there is some 𝜑 ′ such that ⟨𝐼, 𝑂, 𝐻, 𝜑⟩ →
𝜑 ′.
Subcase 𝜑 = true: Let 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻 and 𝑐 ′ = 𝑐1. The result follows by E-IfTrue.
Subcase 𝜑 = false: Symmetric to previous subcase.
Subcase ⟨𝐼, 𝑂, 𝐻, 𝜑⟩ → 𝜑 ′: Let 𝐼 ′ = 𝐼 and 𝑂 ′ = 𝑂 and 𝐻 ′ = 𝐻 .

Further, let 𝑐 ′ = if (𝜑 ′) then c1 else c2. The result follows by E-If.

Case T-Add: 𝑐 = add𝜄 and Excludes Γ 𝜏 𝜄.

By Lemma B.6, 𝜄 ∉ dom(𝐻 ). The result follows by E-Add.

Case T-Ascribe: 𝑐 = 𝑐𝑎 as (𝑥 : 𝜏𝑎1) → 𝜏𝑎2. Let 𝐼 ′ = 𝐼 , 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻 and 𝑐 ′ = 𝑐𝑎. The result

follows by E-Ascribe.

Case T-Sub: Γ ⊢ 𝜏1 <: 𝜏3 and Γ, 𝑥 : 𝜏1 ⊢ 𝜏4 <: 𝜏2 and Γ ⊢ 𝑐 : (𝑥 : 𝜏3) → 𝜏4. By Lemma B.3,
(𝐼, 𝑂, 𝐻 ) |=E 𝜏3. By IH, 𝑐 = skip or there exists 𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′ s.t. ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩.
The result follows directly.

□

Lemma B.10 (Weakening). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 and variable 𝑧 does not appear free in 𝜏1 or 𝜏2,

then Γ, 𝑧 : 𝜏 ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 for any heap type 𝜏.
Proof. By induction on the typing derivation.

□

and E |= Γ and E ′
⟦𝜏 ′

Lemma B.11 (Input Type Strengthening). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 and ⟦𝜏 ′

|= Γ′ and Γ ⊆ Γ′ and E ⊆ E ′, then ∃𝜏 ′

2.Γ′ ⊢ 𝑐 : (𝑥 : 𝜏 ′

1) → 𝜏 ′

1⟧E′ ⊆ ⟦𝜏1⟧E
2 and ∀ℎ′ ∈

2⟧E′ [𝑥↦→ℎ′ ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′ ]

1⟧E′.⟦𝜏 ′
Proof. By induction on a derivation of Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 with case analysis on the last rule

used. We refer to the proof goals as follows:

(1) ∃𝜏 ′
(2) ∀ℎ′ ∈ ⟦𝜏 ′

2.Γ′ ⊢ 𝑐 : (𝑥 : 𝜏 ′
1⟧E′.⟦𝜏 ′
We refer to the assumptions as follows:

1) → 𝜏 ′
2
2⟧E′ [𝑥↦→ℎ′ ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′ ]

1⟧E′ ⊆ ⟦𝜏1⟧E

(A) ⟦𝜏 ′
(B) E |= Γ
(C) E ′ |= Γ′

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:34

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

(D) Γ ⊆ Γ′
(E) E ⊆ E ′
Case T-Add:

By inversion of rule T-Add, we get

(A1) Excludes Γ 𝜏 𝜄 and
(A2) 𝑖𝑛𝑖𝑡 H T (𝜄) = 𝑣
(A3) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }.

2 = Σ𝑦 : {𝑧 : 𝜏 ′

Let 𝜏 ′
(A) and (C) we can conclude that ExcludesΓ′ 𝜏 ′
Let ℎ′ ∈ ⟦𝜏 ′

1⟧E′ be arbitrary.

1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }. By assumptions (A1),

1 𝜄 must also hold. (1) follows by T-Add.

1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E′ [𝑥↦→ℎ′ ] ⊆

⟦Σ𝑦 : {𝑧 : 𝜏 ′
⟦Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E [𝑥↦→ℎ′ ]
1 | 𝑧 ≡ 𝑥 }⟧E′ [𝑥↦→ℎ′ ] ∧

⇔{ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜏 ′

ℎ2 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E′ [𝑥↦→ℎ′,𝑦↦→ℎ1 ] } ⊆

{ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }⟧E [𝑥↦→ℎ′ ] ∧

ℎ2 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1 ] }

⇔{ℎ′ ++ ℎ2 | ℎ2 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E′ [𝑥↦→ℎ′,𝑦↦→ℎ′ ] } ⊆
{ℎ′ ++ ℎ2 | ℎ2 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E [𝑥↦→ℎ′,𝑦↦→ℎ′ ] }

The type {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 } does not contain any free variables, so the
2 and
semantics does not depend on the environment. In fact, the sets of heaps described by 𝜏 ′
𝜏2 is actually equivalent, which shows (2).

Case T-Ascribe:

By inversion of rule T-Ascribe, we get

(A1) 𝑐 = 𝑐𝑎 as (𝑥 : 𝜏1) → 𝜏2 and
(A2) Γ ⊢ 𝑐𝑎 : (𝑥 : 𝜏1) → 𝜏2

From assumptions (A2) and (D) together with Lemma B.10 follows that

(A3) Γ′ ⊢ 𝑐𝑎 : (𝑥 : 𝜏1) → 𝜏2

Since E ′ differs from E only in that it potentially contains additional bindings, we can
conclude that

(A4) ⟦𝜏1⟧E = ⟦𝜏1⟧E′ and together with assumption (B)
(A5) Γ′ ⊢ 𝜏 ′

1 <: 𝜏1.

By assumption (A3) and T-Ascribe we get

(A6) Γ′ ⊢ 𝑐𝑎 𝑎𝑠 (𝑥 : 𝜏1) → 𝜏2 : (𝑥 : 𝜏1) → 𝜏2

2 = 𝜏2. (1) follows by T-Sub.
Let 𝜏 ′
For (2), we have to show that ∀ℎ′ ∈ ⟦𝜏 ′
1⟧E′.⟦𝜏2⟧E′ [𝑥↦→ℎ′ ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′ ]. In fact 𝜏2 describes the
same set of heaps, both in E and E ′. Variable 𝑥 binds to the same heap and both environments
provide the same bindings for any other free variable in 𝜏2.

Case T-Extract:

By inversion of rule T-Extract, we get

(A1) Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏1) ≥ sizeof (𝜄)
(A2) 𝜏2 = Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) |
𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }
Let 𝜏 ′
𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }. By assumptions (A) and (A1) follows
that sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏 ′

2 = Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏 ′

1) ≥ sizeof(𝜄) (1) follows by T-Extract.

1, 𝜄, 𝑦) |

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:35

Let ℎ′ ∈ ⟦𝜏 ′

1⟧E′ be arbitrary.

⟦Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.

{𝑧 : chomp(𝜏 ′

1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E′ [𝑥↦→ℎ′ ] ⊆

⟦Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.

{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E [𝑥↦→ℎ′ ]

⇔{ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→ℎ′ ] ∧

ℎ2 ∈ ⟦{𝑧 : chomp(𝜏 ′

1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥 }⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1 ] } ⊆

{ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→ℎ′ ] ∧

ℎ2 ∈ ⟦{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥 }⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1 ] }
⇔{ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→ℎ′ ] ∧
1, 𝜄, 𝑦)⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1 ] ∧

ℎ2 ∈ {ℎ22|ℎ22 ∈ ⟦chomp(𝜏 ′

⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1,𝑧↦→ℎ22 ] }} ⊆
{ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→ℎ′ ] ∧
ℎ2 ∈ {ℎ22|ℎ22 ∈ ⟦chomp(𝜏1, 𝜄, 𝑦)⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1 ] ∧

⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1,𝑧↦→ℎ22 ] }}

1, 𝜄, 𝑦)⟧E [𝑥↦→ℎ′,𝑦↦→ℎ1 ] by taking
By Lemma B.20, we obtain all heaps contained in ⟦chomp(𝜏 ′
1⟧E′ and removing the first sizeof (𝜄) bits from the input packet. From
all heaps from ⟦𝜏 ′
assumption (A) we know that all heaps described by 𝜏 ′
1 are also contained in the set of heaps
described by 𝜏1 and when we remove the first sizeof (𝜄) bits from the input packet, the relation
still holds. Since the rest of the types are identical this also holds for the concatenated heaps.
This shows (2) and concludes the case.

Case T-If:

By inversion of rule T-If, we get

(A1) Γ; 𝜏1 ⊢ 𝑒 : B
(A2) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) → 𝜏12
(A3) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) → 𝜏22
(A4) 𝜏2 = {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | 𝜑 [𝑥/heap]}
(A5) 𝑐 = if (𝜑) then c1 else c2

To be able to conclude (1) by T-If, we must show that

(1.1) Γ′; 𝜏 ′
1 ⊢ 𝜑 : B
(1.2) Γ′ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏 ′
(1.3) Γ′ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏 ′

1 | 𝜑 [𝑦/heap]}) → 𝜏 ′
12
1 | ¬𝜑 [𝑦/heap]}) → 𝜏 ′
22

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:36

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

To apply the IH to 𝑐1, we need some 𝜏 ′

𝐼𝐻1

such that

⟦𝜏 ′

𝐼𝐻1⟧E′ ⊆ ⟦{𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}⟧E

Let 𝜏 ′
𝐼𝐻1 = {𝑦 : 𝜏 ′
By IH, there exists 𝜏 ′

1 | 𝜑 [𝑦/heap]}.
12 such that

(A6) Γ′ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏 ′
1 ∈ ⟦{𝑦 : 𝜏 ′
(A7) ∀ℎ′

1 | 𝜑 [𝑦/heap]}) → 𝜏 ′
12
12⟧E′ [𝑦↦→ℎ′

1 | 𝜑 [𝑦/heap]}⟧E′.⟦𝜏 ′

1 ] ⊆ ⟦𝜏12⟧E [𝑦↦→ℎ′
1 ]
With a similar argument as before, also by IH, there exists 𝜏 ′
22 such that
1 | ¬𝜑 [𝑦/heap]}) → 𝜏 ′
22
22⟧E′ [𝑦↦→ℎ′

(A8) Γ′ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏 ′
(A9) ∀ℎ′
2 ∈ ⟦{𝑦 : 𝜏 ′
1 ⊢ 𝜑 : B also holds, because the subtyping relation between 𝜏 ′

1 | ¬𝜑 [𝑦/heap]}⟧E′.⟦𝜏 ′

2 ] = ⟦𝜏22⟧E [𝑦↦→ℎ′
2 ]

1 and 𝜏1 ensures that heaps
1 have the same shape (i.e., the same instances are valid) and thus we can

Γ′; 𝜏 ′
described by 𝜏 ′
typecheck formula 𝑒 in the context of type 𝜏 ′
1.
(1) follows by T-If.
Let 𝜏 ′
2 = {𝑦 : 𝜏 ′
12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏 ′
To show ∀ℎ′
1⟧E′.⟦{𝑦 : 𝜏 ′
𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}⟧E [𝑥↦→ℎ′
1 ]
Let ℎ′
or false.

1 ∈ ⟦𝜏 ′

1 ∈ ⟦𝜏 ′

22 | ¬𝜑 [𝑥/heap]}

12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}⟧E′ [𝑥↦→ℎ′

1 ] ⊆ ⟦{𝑦 :

1⟧E′ be arbitrary. Case distinction on wether the formula 𝜑 in ℎ′

1 evaluates to true

Subcase 𝑒 evaluates to true:

⟦{𝑦 : 𝜏 ′
12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}⟧E′ [𝑥↦→ℎ′
⟦{𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}⟧E [𝑥↦→ℎ′
1 ]

1 ] ⊆

⇔⟦{𝑦 : 𝜏 ′

12 | true} + {𝑦 : 𝜏22 | false}⟧E′ [𝑥↦→ℎ′
⟦{𝑦 : 𝜏12 | true} + {𝑦 : 𝜏22 | false}⟧E [𝑥↦→ℎ′
1 ]
1 ] ⊆ ⟦𝜏12⟧E [𝑥↦→ℎ′
1 ]

12⟧E′ [𝑥↦→ℎ′

⇔⟦𝜏 ′

1 ] ⊆

The result follows by (A7).

Subcase 𝑒 evaluates to false: Symmetric to previous subcase. The result follows by (A9).

Case T-Mod:
(A1) 𝜏2 = {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}
(A2) Includes Γ 𝜏1 𝜄
(A3) Γ; 𝜏 ⊢ 𝑡 : BV
(A4) F (𝜄, 𝑓 ) = BV
(A5) 𝑐 = 𝜄.𝑓 := 𝑒

1) → 𝜏 ′

2 such that
2 and
1 ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′
1 ]

2⟧E [𝑥↦→ℎ′

1⟧E′.⟦𝜏 ′

To show: There exists 𝜏 ′
(1) Γ′ ⊢ 𝜄.𝑓 := 𝑒 : (𝑥 : 𝜏 ′
(2) ∀ℎ′
1 ∈ ⟦𝜏 ′
Let 𝜏 ′
2 = 𝜏2.
Includes Γ 𝜏 ′
know that 𝜏 ′
expression 𝑒 in context 𝜏 ′
follows by T-Mod.

1 𝜄 follows by assumptions (A2) and (A) and set theory. By assumption (A), we
1 has the same shape (contains the same instances) as 𝜏1, so we can typecheck
1 with a bit vector type, from which follows that Γ′; 𝜏 ′
1 ⊢ 𝑒 : BV. (1)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:37

Let ℎ′

1 ∈ ⟦𝜏 ′

1⟧E′ be arbitrary. To show (2), we must show that
1 ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′
1 ]

⟦𝜏2⟧E′ [𝑥↦→ℎ′

⇔⟦{𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑡 [𝑥/heap]}⟧E′ [𝑥↦→ℎ′
⟦{𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑡 [𝑥/heap]}⟧E [𝑥↦→ℎ′
1 ]

1 ] ⊆

Since the only free variable is 𝑥

⇔⟦{𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑡 [𝑥/heap]}⟧[𝑥↦→ℎ′
⟦{𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑡 [𝑥/heap]}⟧[𝑥↦→ℎ′
1 ]

1 ] ⊆

The result is immediate.

Case T-Remit:

By inversion of rule T-Remit, we get

(A1) Includes Γ 𝜏 𝜄
(A2) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}

1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}.

1 follows by assumptions (A1) and (A) and set theory. (1) follows by T-Remit.

2 = Σ𝑦 : {𝑧 : 𝜏 ′

Let 𝜏 ′
Includes𝜄 Γ′ 𝜏 ′
Let ℎ ∈ ⟦𝜏 ′

1⟧E be arbitrary.
⟦Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E [𝑥↦→ℎ]
={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }⟧E [𝑥↦→ℎ]∧

ℎ2 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E [𝑥↦→ℎ,𝑦↦→ℎ1 ] }

={ℎ ++ ℎ2 | ℎ2 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E [𝑥↦→ℎ,𝑦↦→ℎ] }

𝑥 is the only free variable in {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}, which maps to the same
heap ℎ in both environments E [𝑥 ↦→ ℎ, 𝑦 ↦→ ℎ] and E ′[𝑥 ↦→ ℎ, 𝑦 ↦→ ℎ].

={ℎ ++ ℎ2 | ℎ2 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ] }
={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜏 ′
1 | 𝑧 ≡ 𝑥 }⟧E′ [𝑥↦→ℎ]∧

=⟦Σ𝑦 : {𝑧 : 𝜏 ′

ℎ2 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1 ] }
1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E′ [𝑥↦→ℎ]

This concludes the case by showing (2).

Case T-Reset:

By inversion of rule T-Reset, we get

(A1) 𝑐 = reset
(A2) 𝜏2 = Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }
1 ∈ ⟦𝜏 ′

2 = 𝜏2. (1) follows by T-Reset. Let ℎ′

Let 𝜏 ′

1⟧E′ be arbitrary.
⟦Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.

{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }⟧E′ [𝑥↦→ℎ′

1 ] ⊆

⟦Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.

{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }⟧E [𝑥↦→ℎ′
1 ]

Both sets are actually equal, because 𝑥 is the only free variable in 𝜏2 and 𝜏 ′
2 respectively. Thus,
all other bindings in the environments E and E ′ have no effect on the semantics of 𝜏2 and 𝜏 ′
2
respectively. This shows (2) and concludes the case.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:38

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case T-Seq:

By inversion of rule T-Seq, we get

(A1) 𝑐 = 𝑐1; 𝑐2
(A2) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) → 𝜏12
(A3) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) → 𝜏22
(A4) 𝜏2 = 𝜏22 [𝑦 ↦→ 𝜏12]

By IH with (A2), (A), (B) and (C), there exists some 𝜏 ′

12 such that

1⟧E′ be arbitrary. By (A3) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) → 𝜏22. By (A6), ⟦𝜏 ′
1 ]. E [𝑥 ↦→ ℎ′

1 ] ⊆
1] |= Γ, 𝑥 : 𝜏1 because by assumption E |= Γ the entailment holds for
1 ∈ ⟦𝜏1⟧E (with assumption (A)) and the

12⟧E′ [𝑥↦→ℎ′

1, we must show that ∀𝑥𝑖, 𝜏𝑖 .Γ′(𝑥𝑖 ) = 𝜏𝑖 ⇒ E ′[𝑥 ↦→
1 ] 𝜏𝑖 . Case 𝑥𝑖 ≠ 𝑥: this holds by assumption (C). Case 𝑥𝑖 = 𝑥.
1 ]. By assumption, 𝑥
1 ∈ ⟦𝜏 ′
1⟧E′, which holds by assumption.

1 |=E′ [𝑥↦→ℎ′

1⟧E′ [𝑥↦→ℎ′

1 ∈ ⟦𝜏 ′

1 ⇔ ℎ′

(A5) Γ′ ⊢ 𝑐1 : (𝑥 : 𝜏 ′
(A6) ∀ℎ′
1 ∈ ⟦𝜏 ′

1 ] ⊆ ⟦𝜏12⟧E [𝑥↦→ℎ′
1 ]

1) → 𝜏 ′
12
1⟧E′.⟦𝜏 ′
12⟧E′ [𝑥↦→ℎ′
Apply the IH again to 𝑐2:
Let ℎ′
1 ∈ ⟦𝜏 ′
⟦𝜏12⟧E [𝑥↦→ℎ′
all 𝑥𝑖 ≠ 𝑥. For 𝑥 there exists a binding to heap ℎ′
entailment between ℎ and 𝜏1 trivially holds.
To show E ′[𝑥 ↦→ ℎ′
ℎ′
1] (𝑥𝑖 ) = ℎ𝑖 ∧ ℎ𝑖
E ′[𝑥 ↦→ ℎ′
is not free in 𝜏 ′
Again by IH, there exists some 𝜏 ′

1 ] 𝜏 ′
1, so we can equivalently show that ℎ′

|=E [𝑥↦→ℎ′
1. To show that ℎ′

1] |= Γ′, 𝑥 : 𝜏 ′

1] (𝑥) = ℎ′

22 such that

(A7) Γ′, 𝑥 : 𝜏 ′
(A8) ∀ℎ′

12 ∈ ⟦𝜏 ′
2 = 𝜏 ′

1 ⊢ 𝑐2(𝑦 : 𝜏 ′
12⟧E′ [𝑥↦→ℎ′
Let 𝜏 ′
22 [𝑦 ↦→ 𝜏 ′
For (2), we must show that ∀ℎ′
Let ℎ′

12) → 𝜏 ′
22
1 ] .⟦𝜏 ′
22⟧E′ [𝑥↦→ℎ1,𝑦↦→ℎ′
12]. (1) follows by T-Seq.
1⟧E′.⟦𝜏 ′

1 ∈ ⟦𝜏 ′

12 ] ⊆ ⟦𝜏22⟧E [𝑥↦→ℎ1,𝑦↦→ℎ′
12 ]

2⟧E′ [𝑥↦→ℎ′

1 ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′
1 ]

1⟧E′ be arbitrary.
1 ∈ ⟦𝜏 ′
22 [𝑦 ↦→ 𝜏 ′
⟦𝜏 ′
(cid:216)

12]⟧E′ [𝑥↦→ℎ′
⟦𝜏 ′

⇔

1 ] ⊆ ⟦𝜏22 [𝑦 ↦→ 𝜏12]⟧E [𝑥↦→ℎ′
1 ]
12 ] ⊆

1,𝑦↦→ℎ′

(cid:216)

22⟧E′ [𝑥↦→ℎ′

⟦𝜏22⟧E [𝑥↦→ℎ′

1,𝑦↦→ℎ12 ]

12 ∈⟦𝜏 ′
ℎ′

12⟧E′ [𝑥 ↦→ℎ′
1 ]
The result follows by (A6), (A8) and set theory.

ℎ12 ∈⟦𝜏12⟧E [𝑥 ↦→ℎ′
1 ]

Case T-Skip:

By inversion of rule T-Skip, we get

(A1) 𝑐 = skip
(A2) 𝜏2 = {𝑦 : 𝜏1 | 𝑦 ≡ 𝑥 }

2 = {𝑦 : 𝜏 ′

Let 𝜏 ′
To show (2), let ℎ′ ∈ ⟦𝜏 ′
⟦{𝑦 : 𝜏 ′

1 | 𝑦 ≡ 𝑥 }. (1) follows by T-Skip.

1⟧E′ be an arbitrary heap.

1 | 𝑦 ≡ 𝑥 }⟧E′ [𝑥↦→ℎ′ ] ⊆ ⟦{𝑦 : 𝜏1 | 𝑦 ≡ 𝑥 }⟧E [𝑥↦→ℎ′ ]

⇔{ℎ′} ⊆ ⟦{𝑦 : 𝜏1 | 𝑦 ≡ 𝑥 }⟧E [𝑥↦→ℎ′ ]
⇔{ℎ′} ⊆ {ℎ′}

Case T-Sub:

By inversion of rule T-Sub, we get

(A1) Γ ⊢ 𝑐 : (𝑥 : 𝜏3) → 𝜏4
(A2) Γ ⊢ 𝜏1 <: 𝜏3
(A3) Γ, 𝑥 :𝜏1 ⊢ 𝜏4 <: 𝜏2

by (A)

By assumption ⟦𝜏 ′
⟦𝜏3⟧E. By IH, there exists 𝜏 ′

4 such that

(A4) Γ′ ⊢ 𝑐 : (𝑥 : 𝜏 ′

1) → 𝜏 ′
4

1⟧E′ ⊆ ⟦𝜏1⟧E and from (A2) follows that ⟦𝜏1⟧E ⊆ ⟦𝜏3⟧E and thus ⟦𝜏 ′

1⟧E′ ⊆

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:39

4⟧E′ [𝑥↦→ℎ′ ] ⊆ ⟦𝜏4⟧E [𝑥↦→ℎ′ ]

(A5) ∀ℎ′ ∈ ⟦𝜏 ′
1⟧E′.⟦𝜏 ′
4. (1) follows by (A4).
Let 𝜏 ′
2 = 𝜏 ′
For (1), we have to show that ∀ℎ′ ∈ ⟦𝜏 ′
(A3) and (A5) and by set theory.

1⟧E′.⟦𝜏 ′

4⟧E′ [𝑥↦→ℎ′ ] ⊆ ⟦𝜏2⟧E [𝑥↦→ℎ′ ], which follows by

□

Lemma B.12 (Semantic Chomp Expression). For all expressions 𝑒, heaps ℎ and ℎ′, environments
E and E ′ and variables 𝑥, if ℎ′ = chomp⇓ (ℎ, 1), and E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄
↦→ 𝑣])] and, if
𝑥 ∈ dom(E), 𝑣 = E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and E (𝑥)(𝑝𝑘𝑡𝑖𝑛) = ⟨⟩ and E (𝑥)(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩, and
otherwise 𝑣 = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and 𝑥 not free in 𝑒, then
𝑒
1 (𝑒, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦𝑒⟧E [𝑦↦→ℎ] = ⟦heapRef1(chomp

Proof. Proof by induction on 𝑒. We only consider expressions referencing 𝑝𝑘𝑡𝑖𝑛. All other

expressions are not affected by chomping, and therefore the semantic is unchanged.
Case 𝑒 = 𝑧.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ]: Case distinction on 𝑧 = 𝑦:

Subcase 𝑧 ≠ 𝑦:

𝑒
1 (𝑧.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp

= ⟦heapRef1 (𝑧.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ], b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑧.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ]⟧E′ [𝑦↦→ℎ′ ]

If 𝑧 ≠ 𝑥, 𝑧 binds to some heap in E, which must also be contained in E ′ unchanged. If 𝑧 = 𝑥,
by assumption, 𝑥 .𝑝𝑘𝑡𝑖𝑛 maps to the empty bit vector, both in E and E ′.

= ⟦𝑧.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ]⟧E [𝑦↦→ℎ]

Subcase 𝑧 = 𝑦, 𝑟 ≤ 1:

𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛 [0 : 1], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛 [0 : 1], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦heapRef1(chomp
= ⟦heapRef1(b0 :: ⟨⟩, b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑥 .𝜄 [sizeof (𝜄) − 1 : sizeof (𝜄) − 1 + 1]@⟨⟩⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑥 .𝜄 [|𝑣 | − 1 : |𝑣 |]⟧E′ [𝑦↦→ℎ′ ]
= E ′(𝑥)(𝜄) [|𝑣 | − 1]
= ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1]
= ⟦𝑦.𝑝𝑘𝑡𝑖𝑛 [0 : 1]⟧E [𝑦↦→ℎ]

Subcase 𝑧 = 𝑦, 𝑙 = 0:

𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 ], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 ], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦heapRef1(chomp
= ⟦heapRef1(b0 :: 𝑦.𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 − 1], b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑥 .𝜄 [sizeof (𝜄) − 1 : sizeof(𝜄) − 1 + 1]@𝑦.𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 − 1]⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑥 .𝜄 [|𝑣 | − 1 : |𝑣 |]@𝑦.𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 − 1]⟧E′ [𝑦↦→ℎ′ ]
= E ′(𝑥)(𝜄) [|𝑣 | − 1 : |𝑣 |]@ℎ′(𝑝𝑘𝑡𝑖𝑛) [0 :𝑟 − 1]

with 𝑣 = E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0] follows
= ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1]@ℎ′(𝑝𝑘𝑡𝑖𝑛) [0 :𝑟 − 1]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:40

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

with ℎ′ = chomp⇓(ℎ, 1) follows

= ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1]@ℎ(𝑝𝑘𝑡𝑖𝑛) [1 :𝑟 ]
= ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :𝑟 ]
= ⟦𝑦.𝑝𝑘𝑡𝑖𝑛 [0 :𝑟 ]⟧E [𝑦↦→ℎ]

Subcase 𝑧 = 𝑦, 𝑙 ≠ 0:

𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1 (chomp
𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦heapRef1 (chomp
= ⟦heapRef1(𝑦.𝑝𝑘𝑡𝑖𝑛 [𝑙 − 1 :𝑟 − 1], b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑦.𝑝𝑘𝑡𝑖𝑛 [𝑙 − 1 :𝑟 − 1]⟧E′ [𝑦↦→ℎ′ ]
= ℎ′(𝑝𝑘𝑡𝑖𝑛) [𝑙 − 1 :𝑟 − 1]

with ℎ′ = chomp⇓(ℎ, 1) follows

= ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑙 :𝑟 ]
= ⟦𝑦.𝑝𝑘𝑡𝑖𝑛 [𝑙 :𝑟 ]⟧E [𝑦↦→ℎ]

Case 𝑒 = 𝑧.𝑝𝑘𝑡𝑖𝑛: Case distinction on 𝑧 = 𝑦:

Subcase 𝑧 ≠ 𝑦: Symmetric to first subcase of previous case.

Subcase 𝑧 = 𝑦:

𝑒
1 (𝑦.𝑝𝑘𝑡𝑖𝑛, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp

= ⟦heapRef1(b0 :: 𝑦.𝑝𝑘𝑡𝑖𝑛, b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑥 .𝜄 [sizeof(𝜄) − 1 : sizeof (𝜄) − 1 + 1]@𝑦.𝑝𝑘𝑡𝑖𝑛⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑥 .𝜄 [|𝑣 | − 1 : |𝑣 |]@𝑦.𝑝𝑘𝑡𝑖𝑛⟧E′ [𝑦↦→ℎ′ ]
= ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1]@ℎ′(𝑝𝑘𝑡𝑖𝑛)

with ℎ′ = chomp⇓(ℎ, 1) follows

= ℎ(𝑝𝑘𝑡𝑖𝑛)
= ⟦𝑦.𝑝𝑘𝑡𝑖𝑛⟧E [𝑦↦→ℎ]

Case 𝑒 = |𝑧.𝑝𝑘𝑡𝑖𝑛 |: Case distinction on 𝑧 = 𝑦:

Subcase 𝑧 ≠ 𝑦:

𝑒
1 (|𝑧.𝑝𝑘𝑡𝑖𝑛 |, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
= ⟦|𝑧.𝑝𝑘𝑡𝑖𝑛 |⟧E′ [𝑦↦→ℎ′ ]

If 𝑧 = 𝑥, the length of 𝑥 .𝑝𝑘𝑡𝑖𝑛 = 0 in both environments and otherwise, 𝑧.𝑝𝑘𝑡𝑖𝑛 refers to
the same heap in both E and E ′.
= ⟦|𝑧.𝑝𝑘𝑡𝑖𝑛 |⟧E [𝑦↦→ℎ]

Subcase 𝑧 = 𝑦:

𝑒
1 (|𝑦.𝑝𝑘𝑡𝑖𝑛 |, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
= ⟦|𝑦.𝑝𝑘𝑡𝑖𝑛 | + 1⟧E′ [𝑦↦→ℎ′ ]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:41

with ℎ′ = chomp⇓(ℎ, 1) follows
= ⟦|𝑦.𝑝𝑘𝑡𝑖𝑛 |⟧E [𝑦↦→ℎ]

Case 𝑒 = 𝑏 :: 𝑏𝑣:

𝑒
1 (𝑏 :: 𝑏𝑣, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
𝑒
1 (𝑏𝑣, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦heapRef1(𝑏 :: chomp
𝑒
= ⟦𝑏 :: heapRef1(chomp
1 (𝑏𝑣, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
𝑒
1 (𝑏𝑣, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦𝑏⟧E′ [𝑦↦→ℎ′ ] :: ⟦heapRef1(chomp
= ⟦𝑏⟧E′ [𝑦↦→ℎ′ ] :: ⟦𝑏𝑣⟧E [𝑦↦→ℎ]

by IH follows

= ⟦𝑏⟧E [𝑦↦→ℎ] :: ⟦𝑏𝑣⟧E [𝑦↦→ℎ]

since 𝑏 is either 0 or 1

= ⟦𝑏 :: 𝑏𝑣⟧E [𝑦↦→ℎ]

Case 𝑒 = 𝑏𝑣1@𝑏𝑣2:

𝑒
1 (𝑏𝑣1@𝑏𝑣2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
𝑒
𝑒
1 (𝑏𝑣1, 𝑦, b0)@chomp
1 (𝑏𝑣2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦heapRef1(chomp
𝑒
1 (𝑏𝑣1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]@
= ⟦heapRef1(chomp
𝑒
1 (𝑏𝑣1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp

= ⟦𝑏𝑣1⟧E [𝑦↦→ℎ]@⟦𝑏𝑣2⟧E [𝑦↦→ℎ]

by IH

= ⟦𝑏𝑣1@𝑏𝑣2⟧E [𝑦↦→ℎ]

Case 𝑒 = 𝑛 + 𝑚: Symmetric to previous case.

Lemma B.13 (Semantic Chomp Formulae). For all formulae 𝜑, heaps ℎ and ℎ′, environments
E and E ′ and variables 𝑥, if ℎ′ = chomp⇓ (ℎ, 1), and E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄
↦→ 𝑣])], and if
𝑥 ∈ dom, 𝑣 = E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and E (𝑥)(𝑝𝑘𝑡𝑖𝑛) = ⟨⟩ and E (𝑥)(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩ and otherwise
𝑣 = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and 𝑥 not free in 𝜑, then

𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦𝜑⟧E [𝑦↦→ℎ] = ⟦heapRef1(chomp

Proof. By induction on 𝜑.

□

Case 𝜑 = 𝑒1 = 𝑒2:

𝜑
1 (𝑒1 = 𝑒2, 𝑦, b0), b0, 𝑥, 𝜄)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
𝜑
1 (𝑒1, 𝑦, b0), b0, 𝑥, 𝜄) =
= ⟦heapRef1(chomp
𝜑
1 (𝑒1, 𝑦, b0), b0, 𝑥, 𝜄)⟧E′ [𝑦↦→ℎ′ ]
heapRef1(chomp
𝜑
1 (𝑒1, 𝑦, b0), b0, 𝑥, 𝜄)⟧E′ [𝑦↦→ℎ′ ] =
= ⟦heapRef1(chomp
𝜑
1 (𝑒1, 𝑦, b0), b0, 𝑥, 𝜄)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:42

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

by Lemma B.12 follows

= ⟦𝑒1⟧E [𝑦↦→ℎ] = ⟦𝑒2⟧E [𝑦↦→ℎ]
= ⟦𝑒1 = 𝑒2⟧E [𝑦↦→ℎ]

Case 𝜑 = 𝜑1 ∧ 𝜑2:

𝜑
1 (𝜑1 ∧ 𝜑2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1(chomp
𝜑
1 (𝜑1, 𝑦, b0), b0, 𝑥, 𝜄, 1)∧
= ⟦heapRef1(chomp
𝜑
1 (𝜑2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
heapRef1(chomp
𝜑
1 (𝜑1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]∧
= ⟦heapRef1(chomp
𝜑
1 (𝜑2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1 (chomp

by IH follows

Case 𝜑 = ¬𝜑1:

by IH follows

= ⟦𝜑1⟧E [𝑦↦→ℎ] ∧ ⟦𝜑2⟧E [𝑦↦→ℎ]
= ⟦𝜑1 ∧ 𝜑2⟧E [𝑦↦→ℎ]

𝜑
1 (¬𝜑1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ]
⟦heapRef1(chomp
𝜑
1 (𝜑1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ]
= ⟦¬heapRef1(chomp
𝜑
1 (𝜑1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ]
= ¬⟦heapRef1(chomp

= ¬⟦𝜑⟧E [𝑦↦→ℎ]
= ⟦¬𝜑⟧E [𝑦↦→ℎ]

Case 𝜑 = 𝑧.𝜄 ′.𝑣𝑎𝑙𝑖𝑑:

𝜑
1 (𝑧.𝜄 ′.𝑣𝑎𝑙𝑖𝑑, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦heapRef1 (chomp
= ⟦𝑧.𝜄 ′.𝑣𝑎𝑙𝑖𝑑⟧E′ [𝑦↦→ℎ′ ]
= 𝜄 ′ ∈ 𝑑𝑜𝑚(E ′[𝑦 ↦→ ℎ′] (𝑧))
= 𝜄 ′ ∈ 𝑑𝑜𝑚(E [𝑦 ↦→ ℎ] (𝑧))

by definition of E ′ and ℎ′ follows
= ⟦𝑧.𝜄 ′.𝑣𝑎𝑙𝑖𝑑⟧E [𝑦↦→ℎ]

Case 𝜑 = true:

𝜑
1 (true, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ]
⟦heapRef1(chomp

= ⟦true⟧E′ [𝑦↦→ℎ]
= true
= ⟦true⟧E [𝑦↦→ℎ]

Case 𝜑 = false: Symmetric to previous case.

□

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:43

Lemma B.14 (Semantic Chomp Refinement). For all heap types 𝜏, heaps ℎ and ℎ′, environments
E and E ′ and variables 𝑥, if ℎ′ = chomp⇓(ℎ, 1), and E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄
↦→ 𝑣])], and, if
𝑥 ∈ dom, 𝑣 = E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and E (𝑥)(𝑝𝑘𝑡𝑖𝑛) = ⟨⟩ and E (𝑥)(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩, and otherwise
𝑣 = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and 𝑥 not free in 𝜏, then

⟦𝜏⟧E [𝑦↦→ℎ] = ⟦heapRef1(chompRef1(𝜏, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

Proof. Proof by induction on 𝜏.

Case 𝜏 = ∅:

⟦heapRef1(chompRef1(∅, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦∅⟧E′ [𝑦↦→ℎ′ ]
= {}
= ⟦𝜏⟧E [𝑦↦→ℎ]

Case 𝜏 = ⊤:

⟦heapRef1(chompRef1(⊤, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦⊤⟧E′ [𝑦↦→ℎ′ ]
= 𝐻
= ⟦⊤⟧E

Case 𝜏 = Σ𝑧 : 𝜏1.𝜏2:

⟦heapRef1(chompRef1(Σ𝑧 : 𝜏1.𝜏2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦Σ𝑧 : heapRef1(chompRef1(𝜏1, 𝑥, b0), b0, 𝑥, 𝜄, 1).

heapRef1(chompRef1(𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= {ℎ′

1 ++ ℎ′

2 | ℎ′
1 ∈ ⟦heapRef1(chompRef1(𝜏1, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ] ∧
ℎ′
2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′,𝑧↦→ℎ′
1 ∈ ⟦𝜏1⟧E [𝑦↦→ℎ] ∧ ℎ′
2 | ℎ′
2 ∈ ⟦𝜏2⟧E [𝑦↦→ℎ,𝑧↦→ℎ′

1 ] }

1 ] }

1 ++ ℎ′

= {ℎ′
= ⟦Σ𝑧 : 𝜏1.𝜏2⟧E [𝑦↦→ℎ]

Case 𝜏 = 𝜏1 + 𝜏2:

⟦heapRef1(chompRef1(𝜏1 + 𝜏2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦heapRef1(chompRef1(𝜏1, 𝑥, b0), b0, 𝑥, 𝜄, 1) +

heapRef1(chompRef1(𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
= ⟦heapRef1(chompRef1(𝜏1, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ] ∪
⟦heapRef1(chompRef1(𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦𝜏1⟧E [𝑦↦→ℎ] ∪ ⟦𝜏1⟧E [𝑦↦→ℎ]
= ⟦𝜏1 + 𝜏2⟧E [𝑦↦→ℎ]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:44

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case 𝜏 = {𝑧 : 𝜏1 | 𝜑 }:

⟦heapRef1(chompRef1({𝑧 : 𝜏1 | 𝜑 }, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦{𝑧 : heapRef1(chompRef1(𝜏1, 𝑦, b0), b0, 𝑥, 𝜄, 1) |
𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)}⟧E′ [𝑦↦→ℎ′ ]
heapRef1(chomp

= {ℎ | ℎ ∈ ⟦heapRef1(chompRef1 (𝜏1, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ] ∧

𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ] = true}
⟦heapRef1(chomp

= {ℎ | ℎ ∈ ⟦𝜏1⟧E [𝑦↦→ℎ] ∧ ⟦𝜑⟧E [𝑦↦→ℎ] = true}
= ⟦{𝑧 : 𝜏1 | 𝜑 }⟧E [𝑦↦→ℎ]

Case 𝜏 = 𝜏1 [𝑧 ↦→ 𝜏2]:

⟦heapRef1(chompRef1(𝜏1 [𝑧 ↦→ 𝜏2], 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]

= ⟦heapRef1(chompRef1(𝜏1, 𝑦, b0), b0, 𝑥, 𝜄, 1) [𝑧 ↦→

heapRef1(chompRef1(𝜏2, 𝑦, b0), b0, 𝑥, 𝜄, 1)]⟧E′ [𝑦↦→ℎ′ ]

= {ℎ | ℎ2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]∧

ℎ ∈ ⟦heapRef1 (chompRef1(𝜏1, 𝑦, b0), b0, 𝑥, 𝜄, 1⟧E′ [𝑦↦→ℎ′,𝑧↦→ℎ2 ] }

= {ℎ | ℎ2 ∈ ⟦𝜏2⟧E [𝑦↦→ℎ] ∧ ℎ ∈ ⟦𝜏1⟧E [𝑦↦→ℎ,𝑧↦→ℎ2 ] }
= ⟦𝜏1 [𝑧 ↦→ 𝜏2]⟧E [𝑦↦→ℎ]

□

Lemma B.15 (Semantic Chomp1). For all heap types 𝜏, environments E and E ′, and variables
↦→ 𝑣])], and if 𝑥 ∈ dom(E), 𝑣 = E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and
𝑥, if E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄
E (𝑥)(𝑝𝑘𝑡𝑖𝑛) = E (𝑥)(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩, otherwise 𝑣 = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1], then ∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 1 =⇒
∃ℎ′ ∈ ⟦chompRec(𝜏, 1, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓(ℎ, 1)

Proof.

∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 1 =⇒ ∃ℎ′ ∈ ⟦chompRec(𝜏, 1, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓ (ℎ, 1)

⇔ (By definition of chompRec)
∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 1 =⇒

∃ℎ′ ∈ ⟦heapRef1(chomp1(𝜏, b0), b0, 𝑥, 𝜄, 1)⟧E′.ℎ′ = chomp⇓(ℎ, 1)

Proof by induction on 𝜏.
Case 𝜏 = ∅: ⟦∅⟧E = {}. As there are no heaps in the semantics, the case holds.
Case 𝜏 = ⊤: Let ℎ be some heap from ⟦⊤⟧E = 𝐻 . Let ℎ′ = ℎ except that ℎ′(𝑝𝑘𝑡𝑖𝑛) = ℎ(𝑝𝑘𝑡𝑖𝑛) [1 : ].
By definition of chomp1 and heapRef1, heapRef1(chomp1(⊤, b0), b0, 𝑥, 𝜄, 1) = ⊤ and ⟦⊤⟧E′ =
𝐻 .
We can conclude that ℎ′ ∈ ⟦heapRef1(chomp1(⊤, b0), b0, 𝑥, 𝜄, 1)⟧E′ and ℎ′ = chomp⇓(ℎ, 1)
follows by construction of ℎ′(𝑝𝑘𝑡𝑖𝑛) = ℎ(𝑝𝑘𝑡𝑖𝑛) [1 : ].

Case 𝜏 = Σ𝑦 : 𝜏1.𝜏2: Let ℎ be some heap from ⟦Σ𝑦 : 𝜏1.𝜏2⟧E. We know ℎ = ℎ1 ++ ℎ2, for some

ℎ1 ∈ ⟦𝜏1⟧E and some ℎ2 ∈ ⟦𝜏2⟧E [𝑦↦→ℎ1].
We have to show that there exists some

ℎ′ ∈ ⟦heapRef1(chomp1(Σ𝑦 : 𝜏1.𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′

such that ℎ′ = chomp⇓(ℎ, 1).

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:45

We deconstruct ⟦heapRef1(chomp1(𝜏, b0), b0, 𝑥, 𝜄, 1)⟧E′:

⟦heapRef1 (chomp1(Σ𝑦 : 𝜏1.𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦heapRef1 (Σ𝑦 : chomp1(𝜏1, b0).chompRef1(𝜏2, 𝑦, b0) +

Σ𝑦 : {𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}.chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦Σ𝑦 : heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1).

heapRef1(chompRef1(𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1) +
Σ𝑦 : heapRef1({𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}, b0, 𝑥, 𝜄, 1).
heapRef1(chomp1 (𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦Σ𝑦 : heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1).

heapRef1(chompRef1 (𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ ∪

= {ℎ′

1 ++ ℎ′

⟦Σ𝑦 : {𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}.heapRef1(chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′
2|ℎ′
1 ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ ∧
ℎ′
2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑥, b0))⟧E′ [𝑦↦→ℎ′
2|ℎ′
1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′ ∧
ℎ′
2 ∈ ⟦heapRef1(chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′

1 ++ ℎ′

1 ] } ∪

{ℎ′

1 ] }

By case distinction on the length of 𝑝𝑘𝑡𝑖𝑛 in ℎ1.
Subcase |ℎ1(𝑝𝑘𝑡𝑖𝑛)| = 0:

By definition of E ′, ⟦𝜏1⟧E = ⟦𝜏1⟧E′, because, 𝜏1 can’t contain a reference to the newly
added bit in E ′(𝑥)(𝜄), from which follows that ℎ1 ∈ ⟦𝜏1⟧E′.
By semantics of heap types, ℎ1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′.
By IH there exists

ℎ′
2 ∈ ⟦heapRef1(chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ1 ]

2 = chomp⇓(ℎ2, 1).

such that ℎ′
Let ℎ′ = ℎ1 ++ ℎ′
2.
We conclude that

ℎ′ ∈ {ℎ′

1 ++ ℎ′

2|ℎ′
1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′ ∧
ℎ′
2 ∈ ⟦heapRef1(chomp1 (𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′

1 ] }

and thus ℎ′ ∈ ⟦heapRef1(chomp1(Σ𝑦 : 𝜏1.𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′.
By assumption |ℎ1(𝑝𝑘𝑡𝑖𝑛)| = 0, we can conclude that

ℎ1 ++ chomp⇓ (ℎ2, 1) = chomp⇓(ℎ1 ++ ℎ2, 1)

thus

ℎ′ = ℎ1 ++ ℎ′
2
= ℎ1 ++ chomp⇓(ℎ2, 1)
= chomp⇓ (ℎ1 ++ ℎ2, 1)
= chomp⇓ (ℎ, 1)

Subcase |ℎ1(𝑝𝑘𝑡𝑖𝑛)| ≠ 0:
By IH there exists ℎ′
1 = chomp⇓(ℎ1, 1).
ℎ′

1 ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′, such that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:46

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By Lemma B.14 follows that

ℎ2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑥, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′
1 ]

Let ℎ′ = ℎ′
1 ++ ℎ2.
We conclude that

ℎ′ ∈ {ℎ′

1 ++ ℎ2|ℎ′

1 ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ ∧
ℎ2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑥, b0))⟧E′ [𝑦↦→ℎ′

1 ] }

and thus ℎ′ ∈ ⟦heapRef1(chomp1(Σ𝑦 : 𝜏1.𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′.
With

ℎ′ = ℎ′

1 ++ ℎ2

= chomp⇓ (ℎ1, 1) ++ ℎ2
= chomp⇓ (ℎ1 ++ ℎ2, 1)
= chomp⇓ (ℎ, 1)

we can conclude this case.

Case 𝜏 = 𝜏1 + 𝜏2:

Let ℎ be some heap from ⟦𝜏1 + 𝜏2⟧E. By the semantics of heap types, we know ℎ ∈ ⟦𝜏1⟧E or
ℎ ∈ ⟦𝜏2⟧E.
Subcase ℎ ∈ ⟦𝜏1⟧E:

By IH we know that there exists

ℎ′ ∈ ⟦heapRef1(chomp1 (𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′

such that ℎ′ = chomp⇓(ℎ, 1).
By set theory and

⟦heapRef1(chomp1(𝜏1 + 𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦heapRef1(chomp1(𝜏1, b0) + chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1) +
heapRef1(chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ ∪
⟦heapRef1(chomp1(𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′

we conclude ℎ′ ∈ ⟦heapRef1(chomp1(𝜏1 + 𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′.

Subcase ℎ ∈ ⟦𝜏2⟧E: Symmetric to previous subcase.

Case 𝜏 = {𝑦 : 𝜏1 | 𝜑 }:

Let ℎ be some heap from ⟦{𝑦 : 𝜏1 | 𝜑 }⟧E.
By the semantics of heap types, we know that ℎ ∈ ⟦𝜏1⟧E and ⟦𝜑⟧E [𝑦↦→ℎ] = true. By
induction hypothesis there exists ℎ′ ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ such that
ℎ′ = chomp⇓(ℎ, 1).
By Lemma B.13 we know that

𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ]
⟦𝜑⟧E [𝑦↦→ℎ] = ⟦heapRef1(chomp

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:47

To apply Lemma B.13, we must show that 𝑥 is not free in 𝜑, if 𝑥 ∉ dom(E). If this does not
hold, there is no ℎ ∈ ⟦𝜏⟧E, which violates our initial assumption. With
⟦heapRef1(chomp1({𝑦 : 𝜏1 | 𝜑 }, b0), b0, 𝑥, 𝜄, 1)⟧E′

𝜑
= ⟦heapRef1({𝑦 : chomp1(𝜏1, b0) | chomp
1 (𝜑, 𝑦, b0)}, b0, 𝑥, 𝜄, 1)⟧E′
= ⟦{𝑦 : heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1) |

𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)}⟧E′
heapRef1(chomp

= {ℎ|ℎ ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ ∧

𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ] }
⟦heapRef1(chomp

and with our assumptions from Lemma B.13 and the induction hypothesis, we conclude that
ℎ′ ∈ ⟦heapRef1(chomp1({𝑦 : 𝜏1 | 𝜑 }, b0), b0, 𝑥, 𝜄, 1)⟧E′ such that ℎ′ = chomp⇓ (ℎ, 1).

Case 𝜏 = 𝜏1 [𝑦 ↦→ 𝜏2]:

Let ℎ be some heap from ⟦𝜏1 [𝑦 ↦→ 𝜏2]⟧E. We know that ℎ ∈ ⟦𝜏1⟧E [𝑦↦→ℎ2 ] for some ℎ2 ∈ ⟦𝜏2⟧E.
By IH there exists some ℎ′ ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ2 ] such that ℎ′ =
chomp⇓(ℎ, 1).
To conclude this case, we must show that

ℎ′ ∈ ⟦heapRef1 (chomp1(𝜏1 [𝑦 ↦→ 𝜏2], b0), b0, 𝑥, 𝜄, 1)⟧E′

From heapRef1, chomp1 and the semantics of heap types, we get:
⟦heapRef1(chomp1(𝜏1 [𝑦 ↦→ 𝜏2], b0), b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0) [𝑦 ↦→ 𝜏2], b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1) [𝑦 ↦→ 𝜏2]⟧E′
= {ℎ11|ℎ22 ∈ ⟦𝜏2⟧E′ ∧ ℎ11 ∈ ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ22 ] }

With ℎ11 = ℎ′ and ℎ22 = ℎ2, we can conclude that

ℎ′ ∈ ⟦heapRef1(chomp1(𝜏1 [𝑦 ↦→ 𝜏2], b0), b0, 𝑥, 𝜄, 1)⟧E′
To argue that ℎ2 ∈ ⟦𝜏2⟧E′, we make a case distinction on 𝑥 ∈ dom(E).
Subcase 𝑥 ∉ dom(E): 𝑥 cannot appear free in 𝜏 and thereby also not in 𝜏2, otherwise there

would be no ℎ ∈ ⟦𝜏⟧E, thus for all ℎ2 ∈ ⟦𝜏2⟧E, ℎ2 ∈ ⟦𝜏2⟧E′.

Subcase 𝑥 ∈ dom(E): By assumption, there is some ℎ2 ∈ ⟦𝜏2⟧E. By semantics of heap types,
all formulae in 𝜏2 referencing 𝑥, evaluate to true, i.e., they only refer to information contained
in E (𝑥). By assumption, E (𝑥)(𝑝𝑘𝑡𝑖𝑛) = E ′(𝑥)(𝑝𝑘𝑡𝑖𝑛), E (𝑥)(𝑝𝑘𝑡𝑜𝑢𝑡 ) = E ′(𝑥)(𝑝𝑘𝑡𝑜𝑢𝑡 ), and
E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] = E ′(𝑥)(𝜄). Since all information of E (𝑥) is preserved in E ′,
ℎ2 ∈ ⟦𝜏2⟧E′.

□

Lemma B.16 (ChompRec Unroll). For all instances 𝜄, if 𝑚 + 1 ≤ sizeof (𝜄), then
chompRec(chompRec(𝜏, 𝑚, 𝑥, 𝜄), 1, 𝑥, 𝜄) = chompRec(𝜏, 𝑚 + 1, 𝑥, 𝜄)

Proof. By induction on 𝑛.

Case 𝑛 = 0:

chompRec(chompRec(𝜏, 0, 𝑥, 𝜄), 1, 𝑥, 𝜄)

= chompRec(𝜏, 1, 𝑥, 𝜄)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:48

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case 𝑛 = 1:

chompRec(chompRec(𝜏, 1, 𝑥, 𝜄), 1, 𝑥, 𝜄)

= chompRec(chompRec(heapRef1(chomp1(𝜏, b0), b0, 𝜄, 1), 0, 𝑥, 𝜄), 1, 𝑥, 𝜄)
= chompRec(heapRef1(chomp1(𝜏, b0), b0, 𝜄, 1), 1, 𝑥, 𝜄)
= chompRec(𝜏, 2, 𝑥, 𝜄)

Case 𝑛 = 𝑚:

We assume that the lemma holds for 𝑛 = 𝑚. We now have to show that the lemma also holds
for 𝑛 = 𝑚 + 1.

chompRec(chompRec(𝜏, 𝑚 + 1, 𝑥, 𝜄), 1, 𝑥, 𝜄)

= chompRec(chompRec(heapRef1(chomp1(𝜏, b0), b0, 𝜄, 𝑚 + 1), 𝑚, 𝑥, 𝜄),

1, 𝑥, 𝜄)

= chompRec(heapRef1(chomp1(𝜏, b0), b0, 𝜄, 𝑚 + 1), 𝑚 + 1, 𝑥, 𝜄)
= chompRec(𝜏, 𝑚 + 2, 𝑥, 𝜄)

Lemma B.17 (Semantic Chomp Unroll). For all heaps ℎ and all 𝑛 ∈ N, if |ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑛 + 1, then

□

chomp⇓(chomp⇓(ℎ, 𝑛), 1) = chomp⇓(ℎ, 𝑛 + 1)

Proof. By definition of chomp⇓,

chomp⇓(chomp⇓(ℎ, 𝑛), 1)

= ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 :]] [𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 :]] (𝑝𝑘𝑡𝑖𝑛) [1 :]]
= ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 :]] (𝑝𝑘𝑡𝑖𝑛) [1 :]]
= ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 + 1 :]]
= chomp⇓(ℎ, 𝑛 + 1)

□

Lemma B.18 (Chomp Slice). For all heaps ℎ and all 𝑛 ∈ N, if |ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑛 + 1, then

chomp⇓ (ℎ, 𝑛)(𝑝𝑘𝑡𝑖𝑛) [0 : 1] = ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 :𝑛 + 1]

Proof. By definition of chomp⇓,

chomp⇓(ℎ, 𝑛)(𝑝𝑘𝑡𝑖𝑛) [0 : 1] = ℎ[𝑝𝑘𝑡𝑖𝑛 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [𝑛 :]] (𝑝𝑘𝑡𝑖𝑛) [0 : 1]

Let 𝑏𝑣 = ℎ(𝑝𝑘𝑡𝑖𝑛) = ⟨𝑏0, ..., 𝑏𝑛, ..., 𝑏𝑚⟩.
Let 𝑏𝑣 ′ be the bit vector we obtain after removing the first 𝑛 bits from 𝑏𝑣 ′, 𝑏𝑣 ′ = ⟨𝑏𝑛, ..., 𝑏𝑚⟩.
Accessing the first bit of 𝑏𝑣 ′ gives us bit 𝑏𝑛, which is also the n-th bit in 𝑏𝑣, i.e., 𝑏𝑣 [𝑛 :𝑛 + 1]. □

Lemma B.19 (Semantic ChompRec). Fix overflow For all heap types 𝜏, environments E and E ′,
variables 𝑥 and 𝑛 ∈ N, if 𝑥 does not appear free in 𝜏, and E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :𝑛]])],
then ∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑛 =⇒ ∃ℎ′ ∈ ⟦chompRec(𝜏, 𝑛, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓(ℎ, 𝑛).

Proof. Proof by induction on 𝑛.

Case 𝑛 = 0:

∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 0 =⇒ ∃ℎ′ ∈ ⟦chompRec(𝜏, 0, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓ (ℎ, 0)

⇔ ∀ℎ ∈ ⟦𝜏⟧E .∃ℎ′ ∈ ⟦𝜏⟧E′.ℎ′ = ℎ

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:49

Let ℎ′ = ℎ, i.e., we have to show that ℎ ∈ ⟦𝜏⟧E′. By assumption, 𝑥 is not free in 𝜏, i.e., the
binding of 𝑥 in E ′ has no effect on the semantics of 𝜏. Since E and E ′ are otherwise identical,
𝜏 evaluated in both environments is described by the same set of heaps, from which we can
conclude that ℎ ∈ ⟦𝜏⟧E′.
Case 𝑛 = 1:

∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 1 =⇒ ∃ℎ′ ∈ ⟦chompRec(𝜏, 1, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓ (ℎ, 1)

The result directly follows by Lemma B.15.

Case 𝑛 = 𝑚 + 1:

We assume that the lemma holds for 𝑛 = 𝑚, i.e.,
∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑚 =⇒ ∃ℎ′ ∈ ⟦chompRec(𝜏, 𝑚, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓(ℎ, 𝑚)
We have to show that the lemma also holds for 𝑛 = 𝑚 + 1, i.e.,

∀ℎ ∈ ⟦𝜏⟧E .|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑚 + 1 =⇒ ∃ℎ′ ∈ ⟦chompRec(𝜏, 𝑚 + 1, 𝜄, 𝑥)⟧E′.ℎ′ = chomp⇓(ℎ, 𝑚 + 1)

0

, such that ℎ′ =

0 = E0 [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :𝑚]])]. We use (A) to refer to this assumption.
1 such
↦→

where E ′ = E [𝑥 ↦→ [𝜄 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :𝑚 + 1], 𝑝𝑘𝑡𝑖𝑛 ↦→ ⟨⟩, 𝑝𝑘𝑡𝑜𝑢𝑡 ↦→ ⟨⟩]].
Let ℎ be some heap ℎ ∈ ⟦𝜏⟧E0.
By induction hypothesis, there exists some ℎ′ ∈ ⟦chompRec(𝜏, 𝑚, 𝜄, 𝑥)⟧E′
chomp⇓(ℎ, 𝑚).
Let E1 = E ′
By Lemma B.15, for all ℎ1 ∈ ⟦chompRec(𝜏, 𝑚, 𝜄, 𝑥)⟧E1, there exists some heap ℎ′
1 ∈ ⟦chompRec(chompRec(𝜏, 𝑚, 𝜄, 𝑥), 1, 𝜄, 𝑥)⟧E′
that ℎ′
1 = chomp⇓ (ℎ1, 1).
E1(𝑥)(𝜄)@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]])], and ℎ′
Since, by assumption, ℎ′ ∈ ⟦chompRec(𝜏, 𝑚, 𝜄, 𝑥)⟧E′
be equal to ℎ′, i.e., ℎ′
From ℎ′ = chomp⇓ (ℎ, 𝑚) follows ℎ′
From Lemma B.17 also follows that ℎ′
We must show that ℎ′
We know that

1 = chomp⇓(chomp⇓(ℎ, 𝑚), 1).
1 = chomp⇓(ℎ, 𝑚 + 1).

1 ∈ ⟦chompRec(𝜏, 𝑚 + 1, 𝜄, 𝑥)⟧E′.

1 = E1 [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄

0, we can define ℎ1 to

1 = chomp⇓(ℎ′, 1).

and also E1 = E ′

and E ′

0

1

ℎ′
1 ∈ ⟦chompRec(chompRec(𝜏, 𝑚, 𝜄, 𝑥), 1, 𝜄, 𝑥)⟧E′

1

1.
, so we must show that E ′ = E ′

↦→ E1(𝑥)(𝜄)@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]])], where ℎ1 =

1 = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :

1

1 = E1 [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄

1 ∈ ⟦chompRec(𝜏, 𝑚 + 1, 𝜄, 𝑥)⟧E′

and by Lemma B.16, ℎ′
By assumption, E ′
chomp⇓(ℎ, 𝑚) (by IH).
Also by assumption, E (𝑥)(𝜄) = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 𝑚], i.e., E ′
𝑚]@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]])].
Again, substituting ℎ1 with ℎ′, and by ℎ′ = chomp⇓(ℎ, 𝑚), we obtain E ′
ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :𝑚]@chomp⇓(ℎ, 𝑚)(𝑝𝑘𝑡𝑖𝑛) [0 : 1]])].
By Lemma B.18 and by definition of bit vector concatenation, E ′
ℎ(𝑝𝑘𝑡𝑖𝑛) [0 :𝑚 + 1]])] = E ′.

1 = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→

1 = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→

Lemma B.20 (Semantic Chomp). If 𝑥 does not appear free in 𝜏, then forall heaps ℎ ∈ ⟦𝜏⟧E where
|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ sizeof(𝜄), there exists ℎ′ ∈ ⟦chomp(𝜏, 𝜄, 𝑥)⟧E′ such that ℎ′ = chomp⇓(ℎ, sizeof (𝜄))
where E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof(𝜄)]])].

Proof. By definition of chomp, we know that

chomp(𝜏, 𝜄, 𝑥) = chompRec(𝜏, sizeof (𝜄), 𝑥, 𝜄)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

□

40:50

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

The result follows from Lemma B.19.

□

Lemma B.21 (Semantic Chomp1 Inverse). For all 𝑥, 𝑣, 𝜏, E ′ and ℎ′ such that E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→
𝑣]) and ℎ′ ∈ ⟦chompRec(𝜏, 1, 𝑥, 𝜄)⟧E′ and 𝑥 not free in 𝜏 and sizeof (𝑣) ≥ 1, there exists ℎ and E such
that,

(1) ℎ ∈ ⟦𝜏⟧E and
(2) ℎ′ = chomp⇓(ℎ, 1) and

and

(3) E = E ′ \ 𝑥 and
(4) 𝑣 = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

or

(3) 𝑥 ∈ dom(E) and
(4) 𝑣 = E (𝑥)(𝜄)@ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] and
(5) E = E ′[𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof (𝑣) − 1]])]

Proof. We refer to the general assumptions as follows:
(A) E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣])
(B) ℎ′ ∈ ⟦chompRec(𝜏, 1, 𝑥, 𝜄)⟧E′ and
(C) 𝑥 not free in 𝜏 and
(D) sizeof(𝑣) ≥ 1
Proof by induction on 𝜏. By definition of chompRec follows that

⟦chompRec(𝜏, 1, 𝑥, 𝜄)⟧E = ⟦heapRef1(chomp1(𝜏, b0), b0, 𝑥, 𝜄, 1)⟧E

Case 𝜏 = ∅:

⟦heapRef1(chomp1(∅, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦heapRef1(∅, b0, 𝑥, 𝜄, 1)⟧E′
= ⟦∅⟧E′
= {}

As there is no ℎ′ ∈ ⟦chompRec(𝜏, 1, 𝜄, 𝑥)⟧E′, this case is immediate.
Case 𝜏 = ⊤:

⟦heapRef1(chomp1(⊤, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦heapRef1(⊤, b0, 𝑥, 𝜄, 1)⟧E′
= ⟦⊤⟧E′
= H
Let E ′ where E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) be arbitrary.
Let ℎ′ ∈ ⟦chompRec(⊤, 1, 𝜄, 𝑥)⟧E′ = H be arbitrary. We have to distinguish two cases.
Subcase sizeof(𝑣) = 1:

Let E = E ′ \ 𝑥 and let ℎ = ℎ′[𝑝𝑘𝑡𝑖𝑛 ↦→ 𝑣@ℎ′(𝑝𝑘𝑡𝑖𝑛)], i.e., ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : 1] = 𝑣. (1) follows by
the semantics of heap types. (2) follows by the definition of chomp⇓. (3) and (4) immediately
follow from the definition of ℎ and E.

Subcase sizeof(𝑣) > 1:

Let E = E ′[𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof(𝑣) − 1]])] and let ℎ = ℎ′[𝑝𝑘𝑡𝑖𝑛 ↦→ 𝑣 [sizeof (𝑣) −
1 : sizeof (𝑣)]@ℎ′(𝑝𝑘𝑡𝑖𝑛)]. (1) follows by the semantics of heap types. (2) follows by the
definition of chomp⇓ (3) and (4) immediately follow from the definition of ℎ and E

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:51

Case 𝜏 = 𝜏1 + 𝜏2: Let E ′ where E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) be arbitrary.

Let ℎ′ ∈ ⟦chompRec(𝜏1 + 𝜏2, 1, 𝜄, 𝑥)⟧E′ be arbitrary.

⟦chompRec(𝜏1 + 𝜏2, 1, 𝜄, 𝑥)⟧E′

= ⟦heapRef1(chomp1(𝜏1 + 𝜏2, b0), b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′ ∪
⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1)⟧E′

= ⟦chompRec(𝜏1, 1, 𝑥𝜄)⟧E′ ∪ ⟦chompRec(𝜏2, 1, 𝑥𝜄)⟧E′

We have to distinguish two cases,
(1) ℎ′ ∈ ⟦chompRec(𝜏1, 1, 𝑥, 𝜄)⟧E′ and
(2) ℎ′ ∈ ⟦chompRec(𝜏2, 1, 𝑥𝜄)⟧E′.
Subcase ℎ′ ∈ ⟦chompRec(𝜏1, 1, 𝑥𝜄)⟧E′: We further distinguish between the size of 𝑣.

Subcase sizeof(𝑣) = 1:

By IH, there exists ℎ1, E1, such that

(A1) ℎ1 ∈ ⟦𝜏1⟧E1
(A2) ℎ′ = chomp⇓(ℎ1, 1)
(A3) E1 = E ′ \ 𝑥
(A4) 𝑣 = ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

Let ℎ = ℎ1 and E = E1. ℎ ∈ ⟦𝜏1 + 𝜏2⟧E follows from the semantics of heap types and by
(A1). The rest is immediate.

Subcase sizeof(𝑣) > 1: By IH, there exists ℎ1, E1, such that

(A1) ℎ1 ∈ ⟦𝜏1⟧E1
(A2) ℎ′ = chomp⇓(ℎ1, 1)
(A3) E1 = E ′[𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof (𝑣) − 1]])]
(A4) 𝑣 = E (𝑥)(𝜄)@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

Let ℎ = ℎ1 and E = E1. ℎ ∈ ⟦𝜏1 + 𝜏2⟧E follows from the semantics of heap types and by
(A1). The rest is immediate.

Subcase ℎ′ ∈ ⟦chompRec(𝜏2, 1, 𝑥, 𝜄)⟧E′:

Symmetric to previous subcase.

Case 𝜏 = Σ𝑦 : 𝜏1.𝜏2: Let E ′ where E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) be arbitrary. Let ℎ′ ∈ ⟦chompRec(Σ𝑦 :

𝜏1.𝜏2, 1, 𝜄, 𝑥)⟧E′ be arbitrary.

⟦chompRec(Σ𝑦 : 𝜏1.𝜏2, 1, 𝜄, 𝑥)⟧E′

= {ℎ′

1 ++ ℎ′

{ℎ′

1 ++ ℎ′

2|ℎ′
1 ∈ ⟦chompRec(𝜏1, 1, 𝜄, 𝑥)⟧E′ ∧
ℎ′
2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑥, b0))⟧E′ [𝑦↦→ℎ′
2|ℎ′
1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′∧
ℎ′
2 ∈ ⟦chompRec(𝜏2, 1, 𝜄, 𝑥)⟧E′ [𝑦↦→ℎ′

1 ] }

1 ] } ∪

Case distinction on the membership of ℎ′.
Subcase ℎ′ contained in the first subset:

1 ++ ℎ′

2 and

(A1) ℎ′ = ℎ′
(A2) ℎ′
(A3) ℎ′

1 ∈ ⟦chompRec(𝜏1, 1, 𝜄, 𝑥)⟧E′ and
2 ∈ ⟦heapRef1(chompRef1(𝜏2, 𝑥, b0))⟧E′ [𝑦↦→ℎ′
We distinguish two additional cases.
Subcase sizeof (𝑣) = 1: By IH, there exists ℎ1, E1, such that

1 ].

(A4) ℎ1 ∈ ⟦𝜏1⟧E1

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:52

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

1 ++ ℎ′

1 = chomp⇓(ℎ1, 1)

2 ∈ ⟦𝜏2⟧E′ [𝑦↦→ℎ1 ]. Since ℎ′

(A5) ℎ′
(A6) E1 = E ′ \ 𝑥
(A7) 𝑣 = ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]
By Lemma B.14, ℎ′
of headers and chomp⇓ does not affect the validity of headers, ℎ1 ++ ℎ′
Let ℎ = ℎ1 ++ ℎ′
(1) follows by (A4) and ℎ′
assumption.
To show (2), we must show that ℎ′
chomp⇓(ℎ1 ++ ℎ′
packet of ℎ1 and then concatenating ℎ′
and then removing the first bit of the input packet.
(3) follows by (A6) and (4) follows by (A7).

2 = chomp⇓ (ℎ1 ++ ℎ′

2 and E = E1.

2 =
2, 1). This equality holds, because chomping of one bit from the input
2 yields the same heap as concatenating both heaps

2, 1) ⇔ chomp⇓(ℎ1, 1) ++ ℎ′

2 ∈ ⟦𝜏2⟧E1 [𝑦↦→ℎ1 ]. The latter holds, because 𝑥 is not free in 𝜏2 by

2 is defined, i.e., they have disjoint sets

2 is defined.

1 ++ ℎ′

Subcase sizeof(𝑣) > 1: By IH, there exists ℎ1, E1, such that

(A8) ℎ1 ∈ ⟦𝜏1⟧E1
(A9) ℎ′
(A10) E1 = E ′[𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof (𝑣) − 1]])]
(A11) 𝑣 = E1(𝑥)(𝜄)@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

1 = chomp⇓(ℎ1, 1)

1 ++ ℎ′

2 and E = E1.

2 ∈ ⟦𝜏2⟧E′ [𝑦↦→ℎ1 ]. Since ℎ′

2 is defined, i.e., they have disjoint sets

2 ∈ ⟦𝜏2⟧E1 [𝑦↦→ℎ1 ]. The latter holds, because 𝑥 is not free in 𝜏2 by

By Lemma B.14, ℎ′
of headers and chomp⇓ does not affect the validity of headers, ℎ1 ++ ℎ′
Let ℎ = ℎ1 ++ ℎ′
(1) follows by (A8) and ℎ′
assumption.
To show (2), we must show that ℎ′
chomp⇓(ℎ1 ++ ℎ′
packet of ℎ1 and then concatenating ℎ′
and then removing the first bit of the input packet.
(3) follows by (A10) and (4) follows by (A11) and (5) follows by (A10).

2 =
2, 1). This equality holds, because chomping of one bit from the input
2 yields the same heap as concatenating both heaps

2, 1) ⇔ chomp⇓(ℎ1, 1) ++ ℎ′

2 = chomp⇓ (ℎ1 ++ ℎ′

2 is defined.

1 ++ ℎ′

Subcase ℎ′ contained in the second subset:

1 ++ ℎ′

2 and

(A1) ℎ′ = ℎ′
(A2) ℎ′
(A3) ℎ′

1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′ and
1 ].
2 ∈ ⟦chompRec(𝜏2, 1, 𝜄, 𝑥)⟧E′ [𝑦↦→ℎ′
We distinguish two cases.
Subcase sizeof(𝑣) = 1: By IH, for every ℎ′

E2, such that
(A4) ℎ2 ∈ ⟦𝜏2⟧E2
(A5) ℎ′
(A6) E2 = E ′[𝑦 ↦→ ℎ′
(A7) 𝑣 = ℎ2(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

2 = chomp⇓(ℎ2, 1)
1] \ 𝑥

1 ∈ ⟦{𝑧 : 𝜏 |

|𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′, there exists ℎ2,

1++ ℎ2 and E = E2\𝑦. We have to show that ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E. By assumption, 𝑥 is
1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E

Let ℎ = ℎ′
not free in 𝜏1 and 𝜏2. By (A2) and by the fact that E = E ′\𝑥, ℎ′
and by subtyping, ℎ′
1 ∈ ⟦𝜏1⟧E.
(1) follows together with (A4).
To show (2), we must show that ℎ′
chomp⇓(ℎ′
both heaps are equal.
(3) follows by (A6) and (4) follows by (A7).

1 ++ ℎ2, 1). Since by (A2), the input packet of ℎ′

2 = chomp⇓ (ℎ′

1 ++ ℎ′

1 ++ ℎ2, 1) ⇔ ℎ′

1 ++ chomp⇓(ℎ2, 1) =
1 is empty, the input packet of

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:53

Subcase sizeof(𝑣) > 1: By IH, for every ℎ′

1 ∈ ⟦{𝑧 : 𝜏 |

|𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E′, there exists ℎ2,

E2, such that
(A8) ℎ2 ∈ ⟦𝜏2⟧E2
(A9) ℎ′
(A10) E2 = E ′[𝑦 ↦→ ℎ′
(A11) 𝑣 = E2(𝑥)(𝜄)@ℎ2(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

2 = chomp⇓(ℎ2, 1)

1, 𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof (𝑣) − 1]])]

1 ++ ℎ2 and E = E2 \ 𝑦. To show that ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E. By assumption that 𝑥 is
1 ∈ ⟦𝜏1⟧E.

1 ∈ ⟦{𝑧 : 𝜏1 | |𝑧.𝑝𝑘𝑡𝑖𝑛 | = 0}⟧E and by subtyping, ℎ′

Let ℎ = ℎ′
not free in 𝜏1 and by (A2), ℎ′
(1) follows together with (A8).
To show (2), we must show that ℎ′
chomp⇓(ℎ′
both heaps are equal.
(3) follows by (A10) and (4) follows by (A11) and (5) follows by (A10).

1 ++ ℎ2, 1). Since by (A2), the input packet of ℎ′

1 ++ chomp⇓(ℎ2, 1) =
1 is empty, the input packet of

1 ++ ℎ2, 1) ⇔ ℎ′

2 = chomp⇓ (ℎ′

1 ++ ℎ′

Case 𝜏 = {𝑦 : 𝜏1 | 𝜑 }:

Let E ′ where E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) be arbitrary.
Let ℎ′ ∈ ⟦chompRec({𝑦 : 𝜏1 | 𝜑 }, 1, 𝜄, 𝑥)⟧E′ be arbitrary.

⟦chompRec({𝑦 : 𝜏1 | 𝜑 }, 1, 𝜄, 𝑥)⟧E′

= ⟦heapRef1(chomp1({𝑦 : 𝜏1 | 𝜑 }, b0), b0, 𝑥, 𝜄, 1)⟧E′
= {ℎ′|ℎ′ ∈ ⟦chompRec(𝜏1, 1, 𝜄, 𝑥)⟧E′ ∧

𝜑
1 (𝜑, 𝑦, b0), b0, 𝑥, 𝜄, 1)⟧E′ [𝑦↦→ℎ′ ] }
⟦heapRef1(chomp

We distinguish two cases.
Subcase sizeof (𝑣) = 1:

By IH, there exists ℎ1, E1, such that

(A1) ℎ1 ∈ ⟦𝜏1⟧E1
(A2) ℎ′ = chomp⇓(ℎ1, 1)
(A3) E1 = E ′ \ 𝑥
(A4) 𝑣 = ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

Let E = E1 and ℎ = ℎ1. To show (1), we must show that ℎ1 ∈ ⟦{𝑦 : 𝜏1 | 𝜑 }⟧E1, which
follows by (A1) and Lemma B.13.
(2) follows by (A2), (3) follows by (A3) and (4) follows by (A4).

Subcase sizeof(𝑣) > 1:

By IH, there exists ℎ1, E1, such that

(A1) ℎ1 ∈ ⟦𝜏1⟧E1
(A2) ℎ′ = chomp⇓(ℎ1, 1)
(A3) E1 = E ′[𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof (𝑣) − 1]])]
(A4) 𝑣 = E1(𝑥)(𝜄)@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

Let E = E1 and ℎ = ℎ1. To show (1), we must show ℎ1 ∈ ⟦{𝑦 : 𝜏1 | 𝜑 }⟧E1, which follows by
(A1) and Lemma B.13.
(2) follows by (A2), (3) follows by (A3), (4) follows by (A4) and (5) follows by (A3).

Case 𝜏 = 𝜏1 [𝑦 ↦→ 𝜏2]:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:54

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Let E ′ where E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) be arbitrary.
Let ℎ′ ∈ ⟦chompRec(𝜏1 [𝑦 ↦→ 𝜏2], 1, 𝜄, 𝑥)⟧E′ be arbitrary.

⟦chompRec(𝜏1 [𝑦 ↦→ 𝜏2], 1, 𝜄, 𝑥)⟧E′

= ⟦heapRef1 (chomp1(𝜏1 [𝑦 ↦→ 𝜏2], b0), b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0) [𝑦 ↦→ 𝜏2], b0, 𝑥, 𝜄, 1)⟧E′
= ⟦heapRef1(chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1) [𝑦 ↦→ heapRef1(𝜏2, b0, 𝑥, 𝜄, 1)]⟧E′
= ⟦heapRef1 (chomp1(𝜏1, b0), b0, 𝑥, 𝜄, 1) [𝑦 ↦→ 𝜏2]⟧E′
= {ℎ′

1 ∈ ⟦chompRec(𝜏1, 1, 𝑥, 𝜄)⟧E′ [𝑦↦→ℎ2 ] }

1|ℎ2 ∈ ⟦𝜏2⟧E′ ∧ ℎ′

By IH, for every ℎ2 ∈ ⟦𝜏2⟧E′, there exists ℎ1, E1, such that

We distinguish two cases.
Subcase sizeof (𝑣) = 1:

(A1) ℎ1 ∈ ⟦𝜏1⟧E1 [𝑦↦→ℎ2 ]
1 = chomp⇓ (ℎ1, 1)
(A2) ℎ′
(A3) E1 = E ′[𝑦 ↦→ ℎ2] \ 𝑥
(A4) 𝑣 = ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]

Let E = E1 and ℎ = ℎ1. Since 𝑥 and 𝑦 not free in 𝜏2, for every heap ℎ2 ∈ ⟦𝜏2⟧E′ also holds
that ℎ2 ∈ ⟦𝜏2⟧E1, from which we can conclude (1), i.e., ℎ ∈ ⟦𝜏1 [𝑦 ↦→ 𝜏2]⟧E.
To show (2), we must show that ℎ′ = chomp⇓(ℎ, 1) = chomp⇓(ℎ1, 1), which follows from
(A2) and the fact that ℎ′ = ℎ′
1.
(3) follows by choice of E and (A3). (4) follows by (A4).

Subcase sizeof(𝑣) > 1:

By IH, for every ℎ2 ∈ ⟦𝜏2⟧E′, there exists ℎ1, E1, such that

(A1) ℎ1 ∈ ⟦𝜏1⟧E1 [𝑦↦→ℎ2 ]
1 = chomp⇓ (ℎ1, 1)
(A2) ℎ′
(A3) E1 = E ′[𝑦 ↦→ ℎ2, 𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣 [0 : sizeof(𝑣) − 1]])]
(A4) 𝑣 = E1(𝑥)(𝜄)@ℎ1(𝑝𝑘𝑡𝑖𝑛) [0 : 1]
Let E = E1 and ℎ = ℎ1.
To show (1), we must show that ℎ ∈ ⟦𝜏1 [𝑦 ↦→ 𝜏2]⟧E1. Since 𝑥 and 𝑦 not free in 𝜏2, for every
heap ℎ2 ∈ ⟦𝜏2⟧E′ also holds that ℎ2 ∈ ⟦𝜏2⟧E1. The result follows by the semantics of heap
types.
To show (2), we must show that ℎ′ = chomp⇓ (ℎ1, 1), which follows from (A2) and ℎ′ = ℎ′
1.
(3) follows by (A3), (4) follows by (A4) and (5) follows also by (A3).

□

Lemma B.22 (Semantic ChompRec Inverse). For all variables 𝑥, values 𝑣, 𝑛 ∈ N, heap types 𝜏,
environments E ′ and heaps ℎ′ such that E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) and ℎ′ ∈ ⟦chompRec(𝜏, 𝑛, 𝜄, 𝑥)⟧E′
and 𝑥 not free in 𝜏 and sizeof(𝑣) = 𝑛, there exists ℎ and E such that ℎ ∈ ⟦𝜏⟧E and E = E ′ \ 𝑥 and
chomp⇓(ℎ, 𝑛) = ℎ′.

Proof. Proof by induction on 𝑛.

Case 𝑛 = 0:

By definition of chompRec, chompRec(𝜏, 0, 𝜄, 𝑥) = 𝜏.
Together with assumption ℎ′ ∈ ⟦chompRec(𝜏, 𝑛, 𝜄, 𝑥)⟧E′, we know that ℎ′ ∈ ⟦𝜏⟧E′.
Let ℎ = ℎ′. By assumption, 𝑥 is not free in 𝜏, thus the binding of 𝑥 in E ′ does not affect the
semantics of 𝜏. We can therefore remove the binding altogether, so 𝜏 describes the same set

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:55

of heaps both in E ′ and in E. We can conclude that ℎ ∈ ⟦𝜏⟧E. chomp⇓(ℎ, 0) = ℎ′ follows
from the definition of semantic chomp.

Case 𝑛 = 1:

The result directly follows by Lemma B.21.

Case 𝑛 = 𝑚 + 1:

We assume that the lemma holds for 𝑛 = 𝑚. We have to show that the lemma also holds for
. Together with
𝑛 = 𝑚 + 1. Let ℎ′
Lemma B.16, we can conclude that

0 ∈ ⟦chompRec(𝜏, 𝑚 + 1, 𝜄, 𝑥)⟧E′

0 be some heap such that ℎ′

0

ℎ′
0 ∈ ⟦chompRec(chompRec(𝜏, 𝑚, 𝜄, 𝑥), 1, 𝜄, 𝑥)⟧E′

0

By Lemma B.21, there is some ℎ′
chomp⇓(ℎ′
1, 1) where E ′
0 [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄
and E1, such that ℎ1 ∈ ⟦𝜏⟧E1 where E1 = E ′
chomp⇓(chomp⇓(ℎ1, 𝑚), 1) and Lemma B.17, follows ℎ′

1 such that ℎ′

1 = E ′

1, E ′

1 ∈ ⟦chompRec(𝜏, 𝑚, 𝜄, 𝑥)⟧E′

0 =
↦→ 𝑣 [0 : 𝑚]])]. By IH, there exists a ℎ1
0 =

1 = chomp⇓(ℎ1, 𝑚). From ℎ′

1 \ 𝑥 and ℎ′

and ℎ′

1

0 = chomp⇓(ℎ1, 𝑚 + 1).

□

Lemma B.23 (Semantic Chomp Inverse). For all variables 𝑥, values 𝑣, instances 𝜄, heap types 𝜏,
environments E ′ and heaps ℎ′ such that E ′(𝑥) = (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) and ℎ′ ∈ ⟦chomp(𝜏, 𝜄, 𝑥)⟧E′ and 𝑥
not free in 𝜏, there exists ℎ and E such that ℎ ∈ ⟦𝜏⟧E and E = E ′ \ 𝑥 and chomp⇓(ℎ, sizeof (𝜄)) = ℎ′.

Proof. By definition of chomp, we know that

chomp(𝜏, 𝜄, 𝑥) = chompRec(𝜏, sizeof (𝜄), 𝑥, 𝜄)

The result follows by Lemma B.22.

□

Lemma B.24 (Formulae Preservation). If Γ; 𝜏 ⊢ 𝜑 : B and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏 and

⟨𝐼, 𝑂, 𝐻, 𝜑⟩ → 𝜑 ′ then Γ; 𝜏 ⊢ 𝜑 ′ : B.

Proof. By induction on a derivation of Γ; 𝜏 ⊢ 𝜑 : B.

□

Lemma B.25 (Semantic Formulae Preservation). If Γ; 𝜏 ⊢ 𝜑 : B and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏

and ⟨𝐼, 𝑂, 𝐻, 𝜑⟩ → 𝜑 ′ then

⟦𝜑 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝜑 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

Proof. By induction on a derivation of Γ; 𝜏 ⊢ 𝜑 : B.

□

Lemma B.26 (Expression Preservation). If Γ; 𝜏 ⊢ 𝑒 : 𝜎 and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏 and

⟨𝐼, 𝑂, 𝐻, 𝑒⟩ → 𝑒 ′ then Γ; 𝜏 ⊢ 𝑒 ′ : 𝜎.

Proof. By induction on a typing derivation of Γ; 𝜏 ⊢ 𝑒 : 𝜎.

□

Lemma B.27 (Semantic Expression Preservation). If Γ; 𝜏 ⊢ 𝑒 : 𝜎 and E |= Γ and (𝐼, 𝑂, 𝐻 ) |=E 𝜏

and ⟨𝐼, 𝑂, 𝐻, 𝑒⟩ → 𝑒 ′ then

⟦𝑒 [𝑥/ 𝑐𝑚𝑑𝑉 𝑎𝑟 ]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝑒 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

Proof. By induction on a typing derivation of Γ; 𝜏 ⊢ 𝑒 : 𝜎.

□

Theorem B.28 (Preservation). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2, ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩, E |= Γ and
2 and E ′ |= Γ′ and (𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′
1

2.Γ′ ⊢ 𝑐 ′ : (𝑥 ′ : 𝜏 ′

1) → 𝜏 ′

1, 𝜏 ′

(𝐼, 𝑂, 𝐻 ) |=E 𝜏1, then ∃Γ′, E ′, 𝑥 ′, 𝜏 ′
and ⟦𝜏 ′

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

Proof. Directly follows by the slightly stronger Lemma B.29.

□

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:56

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Lemma B.29 (Preservation AUX). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2, ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩, E |= Γ
2 and E ′ |= Γ′ and Γ ⊆ Γ′ and
2.Γ′ ⊢ 𝑐 ′ : (𝑥 ′ : 𝜏 ′

1) → 𝜏 ′

and (𝐼, 𝑂, 𝐻 ) |=E 𝜏1, then ∃Γ′, E ′, 𝑥 ′, 𝜏 ′
1 and ⟦𝜏 ′
E ⊆ E ′ and (𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′

1, 𝜏 ′
2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

Proof. By induction on a derivation of Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 with case analysis on the last rule

used. We refer to the proof goals as follows:

1) → 𝜏 ′
2

(1) Γ′ ⊢ 𝑐 ′ : (𝑥 ′ : 𝜏 ′
(2) E ′ |= Γ′
(3) Γ ⊆ Γ′
(4) E ⊆ E ′
(5) (𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′
1
(6) ⟦𝜏 ′

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

General assumptions:

(A) Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2
(B) ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩
(C) E |= Γ
(D) (𝐼, 𝑂, 𝐻 ) |=E 𝜏1

Case T-Add:

By inversion of rule T-Add, we get

(A1) 𝑐 = add𝜄
(A2) Excludes Γ 𝜏1 𝜄
(A3) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }

Only evaluation rule E-Add applies to 𝑐:

(A4) 𝜄 ∉ dom(𝐻 )
(A5) H T (𝜄) = 𝜂
(A6) init = 𝑣.
(A7) 𝐼 ′ = 𝐼 and 𝑂 ′ = 𝑂 and 𝐻 ′ = 𝐻 [𝜄 ↦→ 𝑣] and 𝑐 ′ = skip
Let Γ′ = Γ, 𝑥 : 𝜏1 and E ′ = E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )].
Let 𝜏 ′
2 = {𝑤 : Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 } | 𝑤 ≡ 𝑥 ′}.
𝜏 ′
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4. (3) and (4)
are immediate.
To show (5), we must show that (𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑣]) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 |
𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }. By Ent-Sigma, we must show that

1 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 } and

(5.1) (𝐼, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 } and
(5.2) (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) |=E [𝑥↦→(𝐼,𝑂,𝐻 )𝑦↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }.
(5.1) follows by Ent-Refine and (D). To show (5.2), by Ent-Refine, we must show that

(5.2.1) (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) |=E [𝑦↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : ⊤ | 𝑧.𝜄.valid ∧ (cid:211)𝜅 ∈dom( H T) ¬𝜅.valid} and
(5.2.2) ⟦𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣⟧E [𝑦↦→(𝐼,𝑂,𝐻 ),𝑧↦→( ⟨⟩, ⟨⟩, [𝜄↦→𝑣 ]) ] = true

(5.2.1) follows by Ent-Refine, Ent-Top and the semantics of formulae. (5.2.2) follows from
the semantics of formulae.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:57

(6) follows by

⟦Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
={(𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑣])}
={ℎ | ℎ ∈ ⟦Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧

𝑧.𝜄 = 𝑣 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼,𝑂,𝐻 [𝜄↦→𝑣 ]) ] ∧

⟦𝑤 ≡ 𝑥 ′⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼,𝑂,𝐻 [𝜄↦→𝑣 ]),𝑤↦→ℎ] }

=⟦{𝑤 : Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 } |

𝑤 ≡ 𝑥 ′}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼,𝑂,𝐻 [𝜄↦→𝑣 ]) ]

Case T-Ascribe:

By inversion of rule T-Ascribe, we get

(A1) 𝑐 = 𝑐𝑎 as (𝑥 : 𝜏1) → 𝜏2
(A2) Γ ⊢ 𝑐𝑎 : (𝑥 : 𝜏1) → 𝜏2

There is one evaluation rule that applies to 𝑐, E-Ascribe, so 𝐼 ′ = 𝐼 and 𝑂 ′ = 𝑂 and 𝐻 ′ = 𝐻 and
𝑐 ′ = 𝑐𝑎. Let Γ′ = Γ, E ′ = E, 𝜏 ′
2 = 𝜏2. (1) follows by (A2), (2) follows by assumption
(C). (3) and (4) are immediate. (5) follows by assumption (D) and (6) follows from the equality
of 𝜏2 and 𝜏 ′

2, which itself follows by reflexivity.

1 = 𝜏1 and 𝜏 ′

Case T-Extract:

By inversion of rule T-Extract, we get

(A1) 𝑐 = extract (𝜄)
(A2) Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏1) = sizeof (𝜄)
(A3) 𝜏2 = Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) |
𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }
Only evaluation rule E-Extract applies to 𝑐:

(A4) deserializeH T (𝜄) (𝐼 ) = (𝑣, 𝐼 ′)
(A5) 𝑂 ′ = 𝑂
(A6) 𝐻 ′ = 𝐻 [𝜄 ↦→ 𝑣]
(A7) 𝑐 ′ = skip

1 = Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

Let Γ′ = Γ, 𝑥 : 𝜏1, E ′ = E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )].
Let 𝜏 ′
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }.
2 = {𝑣 : Σ𝑦 : {𝑧 : 𝜄
Let 𝜏 ′
𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 } | 𝑣 ≡ 𝑥 }.
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4. (3) and (4)
are immediate.
To show (5), we must show that (𝐼 ′, 𝑂, 𝐻 [𝜄 ↦→ 𝑣]) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] Σ𝑦 : {𝑧 : 𝜄
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }.
By Ent-Sigma, we must show that

| 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 =

| 𝑧.𝑝𝑘𝑡𝑖𝑛 =

(5.1) (⟨⟩, ⟨⟩, [𝜄 ↦→ 𝑣]) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}, which follows by Ent-

Refine and the semantics of types and

(5.2) (𝐼 ′, 𝑂, 𝐻 )

|=E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→( ⟨⟩, ⟨⟩, [𝜄↦→𝑣 ]) ] {𝑧 : chomp(𝜏1, 𝜄, 𝑦)

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }
By Ent-Refine, we must show that

| 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

(5.2.1) (𝐼 ′, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→( ⟨⟩, ⟨⟩, [𝜄↦→𝑣 ]) ] chomp(𝜏1, 𝜄, 𝑦)

By Lemma B.2, it is sufficient to show that

(𝐼 ′, 𝑂, 𝐻 ) ∈ ⟦chomp(𝜏1, 𝜄, 𝑦)⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→( ⟨⟩, ⟨⟩, [𝜄↦→𝑣 ]) ]

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:58

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By assumption (D) and by Lemma B.2 follows (𝐼, 𝑂, 𝐻 ) ∈ ⟦𝜏1⟧E.
By Lemma B.20, there exists some heap

ℎ ∈ ⟦chomp(𝜏1, 𝜄, 𝑦)⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→( ⟨⟩, ⟨⟩, [𝜄↦→𝑣 ]) ]

such that ℎ = chomp⇓((𝐼, 𝑂, 𝐻 ), sizeof(𝜄)).
From the definition of chomp⇓ follows that

chomp⇓((𝐼, 𝑂, 𝐻 ), sizeof(𝜄)) = (𝐼 ′′, 𝑂, 𝐻 )

where 𝐼 ′′ = 𝐼 [sizeof(𝜄) :] = 𝐼 ′.

(5.2.2) ⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧

𝑧 ≡𝜄 𝑥⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→( ⟨⟩, ⟨⟩, [𝜄↦→𝑣 ]),𝑧↦→(𝐼 ′,𝑂,𝐻 ) ], which follows by the definition of deserialize
and the semantics of formulae and expressions.
Finally, we must show that ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ⊆ ⟦𝜏 ′

2⟧E [𝑥↦→(𝐼 ′,𝑂,𝐻 [𝜄↦→𝑣 ]) ].

⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.

{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧

𝑧 ≡𝜄 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ∧

ℎ2 ∈ ⟦{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ1 ] }

={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ∧

ℎ2 ∈ {ℎ′

2 ∈ ⟦chomp(𝜏1, 𝜄, 𝑦)⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ1 ]∧

⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ1,𝑧↦→ℎ′

2 ] }}

By Lemma B.20

={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ∧

ℎ2 ∈ {ℎ ∈ ⟦𝜏1⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ∧ ℎ′

2 = chomp⇓(ℎ, sizeof (𝜄)) ∧
⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ1,𝑧↦→ℎ′

2 ] }}

By definition of chomp⇓ and semantics of types

={(𝐼 ′, 𝑂, 𝐻 [𝜄 ↦→ 𝑣])}
={ℎ | ℎ ∈ ⟦Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.

{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼 ′,𝑂,𝐻 [𝜄↦→𝑣 ]) ] ∧

⟦𝑣 ≡ 𝑥 ′⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼 ′,𝑂,𝐻 [𝜄↦→𝑣 ]),𝑣↦→ℎ] }

=⟦{𝑣 : Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.

{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧

𝑣 ≡ 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼 ′,𝑂,𝐻 [𝜄↦→𝑣 ]) ]

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 } |

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:59

This shows (6) and concludes the case.

Case T-If:

By inversion of rule T-If, we get

(A1) Γ; 𝜏1 ⊢ 𝜑 : B
(A2) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) → 𝜏12
(A3) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) → 𝜏22
(A4) 𝜏2 = {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}
T-If There are three evaluation rules that apply to 𝑐.
Subcase E-If:

(A5) 𝑐 ′ = if (𝜑 ′) then c1 else c2
(A6) 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻

Let Γ′ = Γ, E ′ = E, 𝑥 ′ = 𝑥,
1 = 𝜏1 and
𝜏 ′
2 = {𝑦 : 𝜏12 | 𝜑 ′[𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 ′[𝑥/heap]}.
𝜏 ′
By Lemma B.24, Γ; 𝜏1 ⊢ 𝜑 ′ : B.
By Lemma B.25, ⟦𝜑 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝜑 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ].
From (A2) follows that Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 ′[𝑦/heap]}) → 𝜏12 and from (A3) follows
that Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 ′[𝑦/heap]}) → 𝜏22 (1) follows by T-If.
(2) follows by assumption (C), (3) and (4) are immediate.
(5) follows by assumption (D).
(6) follows together with the assumption

⟦𝜑 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝜑 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

from the equality ⟦𝜏 ′

2⟧E′ [𝑥↦→(𝐼 ′,𝑂′,𝐻 ′) ] = ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ].

⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦{𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦{𝑦 : 𝜏12 | 𝜑 ′[𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 ′[𝑥/heap]}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦𝜏 ′

2⟧E′ [𝑥↦→(𝐼 ′,𝑂′,𝐻 ′) ]

Subcase E-IfTrue:

(A7) 𝑐 ′ = 𝑐1
(A8) 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻
(A9) 𝜑 = true

Let Γ′ = Γ, E ′ = E, 𝑥 ′ = 𝑥,
1 = {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} = {𝑦 : 𝜏1 | true} = 𝜏1 and
𝜏 ′
2 = 𝜏12.
𝜏 ′
(1) holds by assumption (A2), (2) holds by assumption (C). (3) and (4) are immediate and (5)
(𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′
(6) follows from

1 ⇔ (𝐼, 𝑂, 𝐻 ) |=E 𝜏1 holds by assumption (D).

⟦{𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦{𝑦 : 𝜏12 | true} + {𝑦 : 𝜏22 | false}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦𝜏12⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦𝜏 ′
2⟧E′ [𝑥↦→(𝐼 ′,𝑂′,𝐻 ′) ]

Subcase E-IfFalse:

Symmetric to previous subcase.

Case T-Mod:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:60

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By inversion of rule T-Mod, we get

(A1) 𝑐 = 𝜄.𝑓 := 𝑒
(A2) Includes Γ 𝜏1 𝜄
(A3) F (𝜄, 𝑓 ) = BV
(A4) Γ; 𝜏1 ⊢ 𝑒 : BV
(A5) 𝜏2 = {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}
(A6) 𝜑𝑝𝑘𝑡 ≜ 𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡
(A7) 𝜑𝜄 ≜ ∀𝜅 ∈ dom(H T ).𝜄 ≠ 𝜅 → 𝑦.𝜅 = 𝑥 .𝜅
(A8) 𝜑 𝑓 ≜ ∀𝑔 ∈ dom(H T (𝜄)).𝑓 ≠ 𝑔 → 𝑦.𝜄.𝑔 = 𝑥 .𝜄.𝑔
There are two evaluation rule that apply to 𝑐.
Subcase E-Mod:

(A9) 𝐻 (𝜄) = 𝑟
(A10) 𝑟 ′ ≜ {r with 𝑓 = 𝑣 }
(A11) (𝐼 ′, 𝑂 ′, 𝐻 ′) = (𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑟 ′])
(A12) 𝑐 ′ = skip
(A13) 𝑒 = 𝑣
(A14) 𝜏2 = {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑣 [𝑥/heap]}

1 = 𝜏2 and 𝜏 ′

2 = {𝑧 : 𝜏2 | 𝑧 ≡ 𝑥 }.

Let Γ′ = Γ, 𝑥 : 𝜏1 and E ′ = E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )] and 𝜏 ′
(1) follows by T-Skip and T-Sub. (2) follows by assumptions (C) and (D) and Lemma B.4. (3)
and (4) are immediate.
To show (5), we must show that (𝐼, 𝑂, 𝐻 [𝜄
↦→ 𝑟 ′]) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ⊤ and ⟦𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧
𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑣 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 [𝜄↦→𝑟 ′ ]) ] = true. Since E (𝑥)(𝐼 ) = E (𝑦)(𝐼 ) and
E (𝑥)(𝑂) = E (𝑦)(𝑂), 𝜑𝑝𝑘𝑡 holds. Similarly, E (𝑥)(𝐻 ) = E (𝑦)(𝐻 ) in every aspect, except for
field 𝑓 of instance 𝜄, so 𝜑 𝑓 and 𝜑𝑖𝑛𝑠𝑡 also hold. 𝑦.𝜄.𝑓 = 𝑣 [𝑥/heap] also holds, because
⟦𝑦.𝜄.𝑓 ⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 [𝜄↦→𝑟 ′ ]) ] =
⟦𝑣 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 [𝜄↦→𝑟 ′ ]) ]

⇔ 𝑣 = ⟦𝑣 [𝑥/heap]⟧[𝑥↦→(𝐼,𝑂,𝐻 ) ]
⇔ 𝑣 = 𝑣

To show

⟦𝜏 ′

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

⇔ ⟦{𝑧 : 𝜏2 | 𝑧 ≡ 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
⇔ {(𝐼 ′, 𝑂 ′, 𝐻 ′)} ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
⇔ {(𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑟 ′])} ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

To show (6), let ℎ = (𝐼, 𝑂, 𝐻 [𝜄 ↦→ 𝑟 ′]). Therefore,

(A15) ℎ(𝑝𝑘𝑡𝑖𝑛) = 𝐼 and
(A16) ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) = 𝑂 and
(A17) for all 𝜅 ∈ dom(H T ) such that 𝜅 ≠ 𝜄, ℎ(𝜅) = 𝐻 (𝜅)
(A18) for all 𝑔 ∈ dom(H T (𝜄)) such that 𝑔 ≠ 𝑓 , ℎ(𝜄)(𝑔) = 𝐻 (𝜄)(𝑔)
(A19) ℎ(𝜄)(𝑓 ) = 𝑣 [𝑥/heap] = 𝑣

From the semantics of types follows that ℎ ∈ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ].

Subcase E-Mod1:
(A20) ⟨𝐼, 𝑂, 𝐻, 𝑡⟩ → 𝑒 ′
(A21) 𝑐 ′ = 𝜄.𝑓 := 𝑒 ′
(A22) 𝐼 ′ = 𝐼, 𝑂 ′ = 𝑂 and 𝐻 ′ = 𝐻

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:61

1 = 𝜏1 and

Let Γ′ = Γ and E ′ = E and 𝑥 ′ = 𝑥.
Let 𝜏 ′
2 = {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 ′[𝑥/heap]}.
𝜏 ′
By semantic expression preservation (Lemma B.27), we know that
⟦𝑒 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝑒 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ].
If Γ; 𝜏1 ⊢ 𝑒 : BV and ⟦𝑒 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝑒 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] holds, then it
must hold that Γ; 𝜏1 ⊢ 𝑒 ′ : BV.
(1) follows by T-Mod, (2) follows from assumption (C). (3) and (4) are immediate. (5) follows
from assumption (D).
(6) follows from

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

⟦𝜏 ′
⇔⟦𝜏 ′
⇔⟦{𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 ′[𝑥/heap]}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ⊆
⟦{𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

together with assumption

⟦𝑒 [𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] = ⟦𝑒 ′[𝑥/heap]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

and the semantics of types.

Case T-Remit:

By inversion of rule T-Remit, we get

(A1) 𝑐 = 𝑟𝑒𝑚𝑖𝑡
(A2) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}
(A3) Includes Γ 𝜏1 𝜄

There is only evaluation rule E-Remit that applies to 𝑐.

(A4) 𝜄 ∈ dom(𝐻 )
(A5) H T (𝜄) = 𝜂
(A6) serialize𝜂 (𝐻 (𝜄)) = 𝑏𝑣
(A7) 𝐼 ′ = 𝐼 , 𝑂 ′ = 𝑂@𝑏𝑣, 𝐻 ′ = 𝐻 , 𝑐 ′ = skip

Let Γ′ = Γ, 𝑥 : 𝜏1 and E ′ = E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )].
1 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄} and
Let 𝜏 ′
2 = {𝑣 : Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄} | 𝑣 ≡ 𝑥 ′}.
𝜏 ′
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4.
(3) and (4) are immediate.
For (5) we have to show that (𝐼, 𝑂@𝑏𝑣, 𝐻 ) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 |
𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}. By Ent-Sigma, we must show that

(5.1) (𝐼, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 } and
(5.2) (⟨⟩, 𝑏𝑣, []) |=E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}

For (5.1) we must show by Ent-Refine that (𝐼, 𝑂, 𝐻 )
|=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] 𝜏1, which follows
by assumption (D) and the fact that x is not free in 𝜏1. We must also show that ⟦𝑧 ≡
𝑥⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑧↦→(𝐼,𝑂,𝐻 ) ], which follows by the semantics of formulae and by reflexivity.
To show (5.2), by Ent-Refine, we must show that

and that

(⟨⟩, 𝑏𝑣, []) |=E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 ) ] 𝜖

⟦𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 ),𝑧↦→( ⟨⟩,𝑏𝑣, []) ] = true

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:62

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

The first follows after unfolding the definition of 𝜖 by Ent-Top, Ent-Refine and the semantics
of formulae. The second follows by the semantics of formulae and (A6).
(6) follows by

⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
=⟦Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]∧

ℎ2 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ1 ] }

={(𝐼, 𝑂, 𝐻 ) ++ (⟨⟩, 𝑏𝑣, [])}
={(𝐼, 𝑂@𝑏𝑣, 𝐻 )}
={ℎ | ℎ ∈ ⟦Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.

{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧

𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼,𝑂@𝑏𝑣,𝐻 ) ] ∧

⟦𝑣 ≡ 𝑥 ′⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼,𝑂@𝑏𝑣,𝐻 ),𝑣↦→ℎ] }

=⟦{𝑣 : Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.

{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄} |

𝑣 ≡ 𝑥 ′}⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑥 ′↦→(𝐼,𝑂@𝑏𝑣,𝐻 ) ]

=⟦𝜏 ′
Case T-Reset:

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ]

By inversion of rule T-Reset, we get

(A1) 𝑐 = reset
(A2) 𝜏2 = Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }

There is only one evaluation rule that applies to 𝑐, E-Reset.

(A3) 𝑐 ′ = 𝑠𝑘𝑖𝑝
(A4) 𝐼 ′ = 𝑂@𝐼 , 𝑂 ′ = ⟨⟩ and 𝐻 ′ = []

1 = Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 =

2 = {𝑣 : Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 =

Let E ′ = E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )] and Γ′ = Γ, 𝑥 : 𝜏1.
Let 𝜏 ′
𝑥 .𝑝𝑘𝑡𝑖𝑛 }
Let 𝜏 ′
𝑥 .𝑝𝑘𝑡𝑖𝑛 } | 𝑣 ≡ 𝑥 ′}
(1) follows by T-Skip and (2) follows by assumptions (C) and (D) and Lemma B.4.
(3) and (4) are immediate.
To show (5), we must show that

(𝑂@𝐼, ⟨⟩, []) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] Σ𝑦 :{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.

{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }

By Ent-Sigma, we must show that

(𝑂, ⟨⟩, []) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }

and

(𝐼, ⟨⟩, []) |=E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝑂, ⟨⟩, []) ] {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }

Both follow after unfolding the definition of 𝜖 by Ent-Refine, Ent-Top and the semantics of
formulae.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:63

(6) follows by

⟦Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.

{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

={ℎ1 ++ ℎ2 | ℎ1 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 } E [𝑥↦→(𝐼,𝑂,𝐻 ) ]⟧∧

ℎ2 ∈ ⟦{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ1 ] }

={(𝑂, ⟨⟩, []) ++ (𝐼, ⟨⟩, [])}
={(𝑂@𝐼, ⟨⟩, [])}
=⟦{𝑣 : Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.
{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 } |

𝑣 ≡ 𝑥 ′}⟧E [𝑥↦→(𝑂@𝐼, ⟨⟩, []),𝑥 ′↦→(𝑂@𝐼, ⟨⟩, []) ]

Case T-Seq:

By inversion of rule T-Seq, we get

(A1) 𝑐 = 𝑐1; 𝑐2
(A2) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) → 𝜏12
(A3) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) → 𝜏22
(A4) 𝜏2 = 𝜏22 [𝑦 ↦→ 𝜏12]
Subcase E-Seq:

(A5) 𝑐1 = skip
(A6) 𝑐 ′ = 𝑐2

2 = 𝜏22.

1 = 𝜏12 and 𝜏 ′

By E-Seq, 𝐼 ′ = 𝐼 , 𝑂 ′ = 𝑂, 𝐻 ′ = 𝐻 .
Let Γ′ = Γ, 𝑥 : 𝜏1, E ′ = E [𝑥 ↦→ (𝐼, 𝑂, 𝐻 )] and 𝑥 ′ = 𝑦.
Let 𝜏 ′
(1) follows by (A3), (2) follows by assumptions (C) and (D) and Lemma B.4. (3) and (4) are
immediate.
To show (5), we must show that (𝐼, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 } holds. By Ent-
Refine, we must show that (𝐼, 𝑂, 𝐻 ) |=E [𝑥↦→(𝐼,𝑂,𝐻 ) ] 𝜏1 and ⟦𝑧 ≡ 𝑥⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑧↦→(𝐼,𝑂,𝐻 ) ],
which follows by assumption (D) and the semantics of formulae.
For (6), we must show that

⟦𝜏 ′

2⟧E′ [𝑥↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

⇔⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 ) ] ⊆ ⟦𝜏22 [𝑦 ↦→ {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
⟦𝜏22 [𝑦 ↦→ 𝜏12]⟧E [𝑥↦→(𝐼,𝑂.𝐻 ) ]
={ℎ22|ℎ12 ∈ ⟦{𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ] ∧ ℎ22 ∈ ⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ12 ] }
={ℎ22|ℎ12 = (𝐼, 𝑂, 𝐻 ) ∧ ℎ22 ∈ ⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ12 ] }
={ℎ22|ℎ22 ∈ ⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 ) ] }
=⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→(𝐼,𝑂,𝐻 ) ]

This shows (6) and concludes this subcase.

Subcase E-Seq1:
1; 𝑐2

(A7) 𝑐 ′ = 𝑐 ′
(A8) ⟨𝐼, 𝑂, 𝐻, 𝑐1⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′
1⟩
By IH with (A2), (A7), (C) and (D), there exists Γ′, E ′, 𝜏 ′

(A9) Γ′ ⊢ 𝑐 ′
(A10) E ′ |= Γ′

1 : (𝑥 ′ : 𝜏 ′

1) → 𝜏 ′

12 where

1, 𝜏 ′

12, 𝑥 ′, such that,

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:64

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

(A11) Γ ⊆ Γ′
(A12) E ⊆ E ′
(A13) (𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′
1
(A14) ⟦𝜏 ′

12⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏12⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

(1) follows by T-Seq, if we can show that there exists some 𝜏 ′
(𝑦 : 𝜏 ′
22 [𝑦 ↦→ 𝜏 ′

22 where 𝜏 ′

12) → 𝜏 ′

2 = 𝜏 ′

12]:

22, such that Γ′, 𝑥 ′ : 𝜏 ′

1 ⊢ 𝑐2 :

T-Seq
Γ′ ⊢ 𝑐 ′

1 : (𝑥 : 𝜏 ′

1 ⊢ 𝑐2 : (𝑦 : 𝜏 ′
22 [𝑦 ↦→ 𝜏 ′
12]
By Lemma B.11 with (A3) and (A13), there exists some 𝜏 ′
22 such that

1) → 𝜏 ′
12
1; 𝑐2 : (𝑥 : 𝜏 ′

Γ′, 𝑥 : 𝜏 ′
1) → 𝜏 ′

12) → 𝜏 ′
22

Γ′ ⊢ 𝑐 ′

(A15) Γ′, 𝑥 ′ : 𝜏 ′
(A16) ∀ℎ′ ∈ ⟦𝜏 ′

1 ⊢ 𝑐2 : (𝑦 : 𝜏 ′
1) → 𝜏 ′
22
12⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] .⟦𝜏 ′

22⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′),𝑦↦→ℎ′ ] ⊆

⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ′ ]
(2) follows by (A10) and (3) follows by (A11), (4) follows by (A12) and (5) follows by (A13).
(6) follows by

⟦𝜏 ′
⇔⟦𝜏 ′

2⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏2⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
22 [𝑦 ↦→ 𝜏 ′
(cid:216)

⇔

⟦𝜏 ′

22⟧E′ [𝑥↦→(𝐼 ′,𝑂′,𝐻 ′),𝑦↦→ℎ′ ] ⊆

12]⟧E′ [𝑥↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏22 [𝑦 ↦→ 𝜏12]⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]

ℎ′ ∈⟦𝜏 ′

12⟧E′ [𝑥 ↦→(𝐼 ′,𝑂′,𝐻 ′) ]

(cid:216)

⟦𝜏22⟧E [𝑥↦→(𝐼,𝑂,𝐻 ),𝑦↦→ℎ]

ℎ ∈⟦𝜏12⟧E [𝑥 ↦→(𝐼 ,𝑂,𝐻 ) ]

and by (A14), (A16) and the semantics of heap types.

Case T-Skip:

Immediately holds as there is no 𝑐 ′ such that ⟨𝐼, 𝑂, 𝐻, 𝑐⟩ → ⟨𝐼 ′, 𝑂 ′, 𝐻 ′, 𝑐 ′⟩.

Case T-Sub:
(A1) Γ ⊢ 𝑐 : (𝑥 : 𝜏3) → 𝜏4
(A2) Γ ⊢ 𝜏1 <: 𝜏3
(A3) Γ, 𝑥 :𝜏1 ⊢ 𝜏4 <: 𝜏2

By Lemma B.3 with assumptions (C), (D) and (A2),

By IH with (A1), (B), (C) and (A4), there exists Γ′, E ′, 𝜏 ′

3, 𝜏 ′

4, 𝑥 ′ such that

(A4) (𝐼, 𝑂, 𝐻 ) |=E 𝜏3.

3) → 𝜏 ′
4

(A5) Γ′ ⊢ 𝑐 : (𝑥 ′ : 𝜏 ′
(A6) E ′ |= Γ′
(A7) Γ ⊆ Γ′
(A8) E ⊆ E ′
(A9) (𝐼 ′, 𝑂 ′, 𝐻 ′) |=E′ 𝜏 ′
3
(A10) ⟦𝜏 ′

4⟧E′ [𝑥 ′↦→(𝐼 ′,𝑂′,𝐻 ′) ] ⊆ ⟦𝜏4⟧E [𝑥↦→(𝐼,𝑂,𝐻 ) ]
2 = 𝜏 ′

3 and 𝜏 ′

1 = 𝜏 ′

Let 𝜏 ′
4. (1) follows by (A5), (2) follows by assumption (A6), (3) follows by
assumption (A7), (4) follows by assumption (A8), (5) follows by assumption (A9) and (6)
follows by (A3) and (A10).

C ALGORITHMIC TYPING RULES
The command typing rules are shown in Figure 20.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

□

Dependently-Typed Data Plane Programming

40:65

T-Extract-Algo
Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof(𝜄)}

𝜑1 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩

𝜑2 ≜ 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥
Γ ⊢ extract (𝜄) : (𝑥 : 𝜏1) ⇝ Σ𝑦 : {𝑧 : 𝜄 | 𝜑1}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑2}

T-Add-Algo

Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}

init H T (𝜄) = 𝑣

Γ ⊢ add𝜄 : (𝑥 : 𝜏1) ⇝ Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }

T-Mod-Algo

Γ; 𝜏1 ⊢ 𝑒 : BV
Γ ⊢ 𝜏 <: 𝜄∼
F (𝜄, 𝑓 ) = BV
𝜑𝑝𝑘𝑡 ≜ 𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡
𝜑𝜄 ≜ ∀𝜅 ∈ dom(H T ). 𝜄 ≠ 𝜅 ⇒ 𝑦.𝜅 = 𝑥 .𝜅
𝜑 𝑓 ≜ ∀𝑔 ∈ dom(H T (𝜄)). 𝑓 ≠ 𝑔 ⇒ 𝑦.𝜄.𝑔 = 𝑥 .𝜄.𝑔
Γ ⊢ 𝜄.𝑓 := 𝑒 : (𝑥 : 𝜏1) ⇝ {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}

T-Remit-Algo
Γ ⊢ 𝜏1 <: 𝜄∼

𝜑 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄

Γ ⊢ remit (𝜄) : (𝑥 : 𝜏1) ⇝ Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝜑 }

T-Reset-Algo

𝜑1 ≜ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡
𝜑2 ≜ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛
Γ ⊢ reset : (𝑥 : 𝜏1) ⇝ Σ𝑦 : {𝑧 : 𝜖 | 𝜑1}.{𝑧 : 𝜖 | 𝜑2}

T-Seq-Algo

Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) ⇝ 𝜏12
Γ, (𝑥 : 𝜏1) ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22
Γ ⊢ 𝑐1; 𝑐2 : (𝑥 : 𝜏1) ⇝ 𝜏22 [𝑦 ↦→ 𝜏12]

T-Skip-Algo

𝜏2 ≜ {𝑦 : 𝜏1 | 𝑦 ≡ 𝑥 }
Γ ⊢ skip : (𝑥 : 𝜏1) ⇝ 𝜏2

T-If-Algo

T-Ascribe-Algo
Γ ⊢ 𝑐 : (𝑥 : ˆ𝜏1) ⇝ 𝜏𝑐

Γ ⊢ 𝜏1 <: ˆ𝜏1

Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏𝑐 <: ˆ𝜏2
Γ ⊢ 𝑐 as (𝑥 : ˆ𝜏1) → ˆ𝜏2 : (𝑥 : 𝜏1) ⇝ ˆ𝜏2

Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) ⇝ 𝜏12

Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) ⇝ 𝜏22

Γ ⊢ if (𝜑) c1 else c2 : (𝑥 : 𝜏1) ⇝ {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}

Γ; 𝜏1 ⊢ 𝜑 : B

Fig. 20. Algorithmic typing rules for Π4. Assume binders are fresh in all rules

Lemma C.1 (Subtype Reflexivity). For all subtyping contexts Γ and heap types 𝜏, Γ ⊢ 𝜏 <: 𝜏.

Proof. Immediate.

□

Lemma C.2 (Subtype Transitivity). If Γ ⊢ 𝜏1 <: 𝜏2, and Γ ⊢ 𝜏2 <: 𝜏3, then Γ ⊢ 𝜏1 <: 𝜏3.

Proof. Assume Γ ⊢ 𝜏1 <: 𝜏2 and also assume Γ ⊢ 𝜏2 <: 𝜏3. Let E |= Γ and ℎ ∈ ⟦𝜏1⟧E be arbitrary.
□

By the first assumption ℎ ∈ ⟦𝜏2⟧E. By the second assumption ℎ ∈ ⟦𝜏3⟧E.

Lemma C.3 (Environment Entails Subtype). If Γ ⊢ 𝜏1 <: 𝜏3, and E |= Γ, 𝑥 : 𝜏3, then E |= Γ, 𝑥 : 𝜏1.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:66

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Proof. Let Γ ⊢ 𝜏1 <: 𝜏3 and E |= Γ, (𝑥 : 𝜏3). Let E |= Γ, (𝑥 : 𝜏1). We can write E = E ′[𝑥 ↦→ ℎ1],
such that E ′ |= Γ, and ℎ1 ∈ ⟦𝜏1⟧E′. The definition of subtyping gives ℎ1 ∈ ⟦𝜏3⟧E′. The result follows
□
by definition of entailment.

Lemma C.4 (Context Strengthening). If Γ ⊢ 𝜏1 <: 𝜏3 and Γ, 𝑥 : 𝜏3 ⊢ 𝜏2 <: 𝜏4 then Γ, 𝑥 : 𝜏1 ⊢

𝜏2 <: 𝜏4.

Proof. Assume Γ ⊢ 𝜏1 <: 𝜏3 and further assume Γ, 𝑥 : 𝜏3 ⊢ 𝜏2 <: 𝜏4. Let E |= Γ, 𝑥 : 𝜏1. By
Lemma C.3 and the first assumption, E |= Γ, (𝑥 : 𝜏3). Let ℎ ∈ ⟦𝜏2⟧E, the second assumption gives
□
that ℎ ∈ ⟦𝜏2⟧E, and we’re done.

Lemma C.5 (Packet Bound Subtype). Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ 𝑁 iff Γ ⊢ 𝜏 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥

sizeof (𝜄)}.

Proof. We show each direction separately.

(⇒) Assume Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ 𝑁 . Let E |= Γ and ℎ ∈ ⟦𝜏⟧E be arbitrary. By definition,
|ℎ(𝑝𝑘𝑡𝑖𝑛)| ≥ 𝑁 . By the definition of subtyping, it suffices to show ℎ ∈ ⟦{𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥
𝑁 }⟧E. By definition, ⟦{𝑥 : ⊤ |
|𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ 𝑁 }⟧E = {ℎ | ℎ ∈ H ∧ ℎ(𝑝𝑘𝑡𝑖𝑛) ≥ 𝑁 }, which
concludes this case.

(⇐) Assume Γ ⊢ 𝜏 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ 𝑁 }. We have to show that Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ 𝑁 . Let
E |= Γ and ℎ ∈ ⟦𝜏⟧E be arbitrary. By the definition of subtyping, ℎ ∈ ⟦{𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥
𝑁 }⟧E. By definition of the semantics, we can conclude ℎ(𝑝𝑘𝑡𝑖𝑛) ≥ 𝑁 .

□

Lemma C.6 (Chomp Subtype). If 𝑥 not free in 𝜏 and 𝜏 ′, and Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ sizeof(𝜄) and

Γ ⊢ 𝜏 <: 𝜏 ′, then Γ, 𝑥 : {𝑦 : 𝜄 | 𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩} ⊢ chomp(𝜏, 𝜄, 𝑥) <: chomp(𝜏 ′, 𝜄, 𝑥).

Proof. Given some heap ℎ′ ∈ ⟦chomp(𝜏 ′, 𝜄, 𝑥)⟧E′. By Lemma B.23 there exists some E and

ℎ′′ ∈ ⟦𝜏 ′⟧E, such that E ′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ′′(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof (𝜄)]])] and
ℎ′ = chomp⇓ (ℎ′′, sizeof (𝜄)). By assumption Γ ⊢ 𝜏 <: 𝜏 ′, we also know that ℎ′′ ∈ ⟦𝜏⟧E.

By Lemma B.20, we know that there exists ℎ ∈ ⟦chomp(𝜏, 𝜄, 𝑥)⟧E′′ such that ℎ = chomp⇓(ℎ′′, sizeof(𝜄))

and E ′′ = E [𝑥 ↦→ (⟨⟩, ⟨⟩, [𝜄 ↦→ ℎ′′(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof(𝜄)]])]. From ℎ′ = chomp⇓(ℎ′′, sizeof (𝜄)) and
ℎ = chomp⇓(ℎ′′, sizeof (𝜄)) follows by the transitivity of equality that ℎ′ = ℎ. By the fact that E ′ =
E ′′ follows that for every heap ℎ′ ∈ ⟦chomp(𝜏 ′, 𝜄, 𝑥)⟧E′ also holds that ℎ′ ∈ ⟦chomp(𝜏, 𝜄, 𝑦)⟧E′′. □

Lemma C.7 (Refinement Subtype). If Γ ⊢ 𝜏 ′ <: 𝜏, then Γ ⊢ {𝑥 : 𝜏 ′ | 𝜑 } <: {𝑥 : 𝜏 | 𝜑 }.

Proof. Let E ⊢ Γ and ℎ ∈ ⟦{𝑥 : 𝜏 ′

| 𝜑 }⟧E. Then ℎ ∈ ⟦𝜏 ′⟧E, and ⟦𝜑⟧E [𝑥↦→ℎ] = true. By
assumption Γ ⊢ 𝜏 ′ <: 𝜏, ℎ ∈ ⟦𝜏⟧E. Conclude ℎ ∈ ⟦{𝑥 : 𝜏 | 𝜑 }⟧E by definition. The result
□
follows.

Lemma C.8 (Sigma Left-Subtype). If Γ ⊢ 𝜏 ′

1 <: 𝜏1 then Γ ⊢ Σ𝑥 : 𝜏 ′

1.𝜏2 <: Σ𝑥 : 𝜏1.𝜏2.

Proof. Let E |= Γ, and ℎ ∈ ⟦Σ𝑥 : 𝜏 ′

1⟧E and ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ]. By assumption Γ ⊢ 𝜏 ′
ℎ1 ∈ ⟦𝜏 ′
of the semantics, ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E. The result follows.

1.𝜏2⟧E. By definition of the semantics, ℎ = ℎ1 ++ ℎ2,where
1 <: 𝜏1 follows, ℎ1 ∈ ⟦𝜏1⟧E. By the definition
□

Lemma C.9 (Sigma Right-Subtype). If Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′

2 <: 𝜏2 then Γ ⊢ Σ𝑥 : 𝜏1.𝜏 ′

2 <: Σ𝑥 : 𝜏1.𝜏2.

Proof. Let E |= Γ and ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏 ′

2⟧E [𝑥↦→ℎ1 ]. Notice that E [𝑥 ↦→ ℎ1] |= Γ, (𝑥 : 𝜏1), so by assumption Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′
ℎ2 ∈ ⟦𝜏 ′
ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ]. By the definition of the semantics ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E. The result follows.

2⟧E. By definition, ℎ = ℎ1 ++ ℎ2 such that ℎ1 ∈ ⟦𝜏1⟧E, and
2 <: 𝜏2 follows
□

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:67

1 <: 𝜏1 and Γ, (𝑥 : 𝜏 ′

1) ⊢ 𝜏 ′

2 <: 𝜏2, then Γ ⊢ 𝜏 ′

2 [𝑥 ↦→

Lemma C.10 (Substitution Subtype). If Γ ⊢ 𝜏 ′
1] <: 𝜏2 [𝑥 ↦→ 𝜏1].
𝜏 ′
Proof. Let E |= Γ and ℎ2 ∈ ⟦𝜏 ′

Assumption Γ ⊢ 𝜏 ′
Γ, (𝑥 : 𝜏1) ⊢ 𝜏 ′
ℎ2 ∈ ⟦𝜏2 [𝑥 ↦→ 𝜏1]⟧E.

2 [𝑥 ↦→ 𝜏 ′

1 <: 𝜏1 tells us that ℎ1 ∈ ⟦𝜏1⟧E. Notice that E [𝑥 ↦→ ℎ1] |= Γ, (𝑥 : 𝜏 ′

2⟧E [𝑥↦→ℎ1 ].
1). Assumption
2 <: 𝜏2 gives ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ]. By the definition of the semantics of heap types,
□

1]⟧E. Then we know ℎ1 ∈ ⟦𝜏 ′

1⟧E and ℎ2 ∈ ⟦𝜏 ′

Lemma C.11 (Choice Subtype). If Γ ⊢ 𝜏 ′
Proof. Let E |= Γ. Let ℎ ∈ ⟦𝜏 ′

1 <: 𝜏1, and Γ ⊢ 𝜏 ′

1 + 𝜏 ′
2⟧E. By semantics of heap types, either ℎ ∈ ⟦𝜏 ′

2 <: 𝜏2, then Γ ⊢ 𝜏 ′

1 +𝜏 ′

2 <: 𝜏1 + 𝜏2
1⟧E or ℎ ∈ ⟦𝜏 ′

2⟧E.
1 <: 𝜏1 it also holds that ℎ ∈ ⟦𝜏1⟧E and we can conclude

1⟧E: By assumption Γ ⊢ 𝜏 ′

Subcase ℎ ∈ ⟦𝜏 ′

Subcase ℎ ∈ ⟦𝜏 ′

2⟧E: By assumption Γ ⊢ 𝜏 ′

2 <: 𝜏2 it also holds that ℎ ∈ ⟦𝜏2⟧E and we can conclude

that ℎ ∈ ⟦𝜏1 + 𝜏2⟧E.

that ℎ ∈ ⟦𝜏1 + 𝜏2⟧E.

□

Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ⊢ 𝜏 ′

Lemma C.12 (Context-Bound Refinement Subtype). If heap is the only free binder in 𝜑, and
2 | 𝜑 [𝑥/heap]} <: {𝑦 : 𝜏2 | 𝜑 [𝑥/heap]}.
Proof. Let E |= Γ, 𝑥 : 𝜏1. We can write this as E = E ′[𝑥 ↦→ ℎ1], where ℎ1 ∈ ⟦𝜏1⟧E. Let
2⟧E and ⟦𝜑 [𝑥/heap]⟧E [𝑦↦→ℎ2 ] = true. Compute as

2 <: 𝜏2 then Γ, 𝑥 : 𝜏1 ⊢ {𝑦 : 𝜏 ′

ℎ2 ∈ ⟦{𝑦 : 𝜏 ′
follows, recalling that heap is the only free binder in 𝜑:

2 | 𝜑 [𝑥/heap]}⟧E. Then ℎ2 ∈ ⟦𝜏 ′

⟦𝜑 [𝑥/heap]⟧E [𝑦↦→ℎ2 ]
=⟦𝜑 [𝑥/heap]⟧E
=⟦𝜑 [𝑥/heap]⟧E′ [𝑥↦→ℎ1 ]
=⟦𝜑 [𝑦/heap]⟧E′ [𝑦↦→ℎ1 ]
Together with assumption ℎ1 ∈ ⟦𝜏1⟧E, we get ℎ1 ∈ ⟦{𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}⟧E′, and thus E ′[𝑥 ↦→
ℎ1] |= Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}.

With assumption Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ⊢ 𝜏 ′

2 <: 𝜏2, we can conclude that ℎ2 ∈ ⟦𝜏2⟧E. Since
we already have that ⟦𝜑 [𝑥/heap]⟧E [𝑦↦→ℎ2 ] = true, it follows that ℎ2 ∈ ⟦{𝑦 : 𝜏2 | 𝜑 [𝑥/heap]}⟧E,
□
which is what we wanted to show.

Lemma C.13 (If Choice Subtype). If heapis the only free binder in 𝜑 and Γ, 𝑥 : {𝑦 : 𝜏 ′

𝜑 [𝑦/heap]} ⊢ 𝜏 ′
12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏 ′
𝜏 ′
Proof. By Lemmas C.12 and C.11.

12 <: 𝜏12, and Γ, 𝑥 : {𝑦 : 𝜏 ′

22 <: 𝜏22, then Γ, 𝑥 : 𝜏 ′
22 | 𝜑 [𝑥/heap]} <: {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}

1 | ¬𝜑 [𝑦/heap]} ⊢ 𝜏 ′

1 |
1 ⊢ {𝑦 :

□

Lemma C.14 (Algorithmic Weakening). If Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏2 and variable 𝑦 does not appear

free in 𝜏1 or 𝜏2, then Γ, 𝑦 : 𝜏 ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏2 for any heap type 𝜏.

Proof. By induction on the typing derivation.

□

Lemma C.15 (Typing Context Subtype). If Γ, 𝑥 : 𝜏1 ⊢ 𝑐 : (𝑦 : 𝜏12) ⇝ 𝜏22 and Γ ⊢ 𝜏 ′

1 <: 𝜏1, then

Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝑐 : (𝑦 : 𝜏12) ⇝ 𝜏22.

Proof. If 𝑥 is not free in 𝜏12 or 𝜏22, the result follows from Lemma C.14. Otherwise we proceed

by induction on the typing derivation. We refer to the general assumptions as follows:

(A) Γ, 𝑥 : 𝜏1 ⊢ 𝑐 : (𝑦 : 𝜏12) ⇝ 𝜏22
(B) Γ ⊢ 𝜏 ′

1 <: 𝜏1

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:68

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Case T-Extract-Algo: By inversion of T-Extract-Algo, we know
(A1) Γ, 𝑥 : 𝜏1 ⊢ extract (𝜄) : (𝑦 : 𝜏12) ⇝ 𝜏22
(A2) 𝜏22 = Σ𝑧 : {𝑣 : 𝜄 | 𝜑1}.{𝑣 : chomp(𝜏12, 𝜄, 𝑧) | 𝜑2}
(A3) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 <: {𝑧 : ⊤ | |𝑧.𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)}
By Lemma C.4 applied to (A3) and (B) follows
1 ⊢ 𝜏12 <: {𝑧 : ⊤ | |𝑧.𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)}

(A4) Γ, 𝑥 : 𝜏 ′

The result follows by T-Extract-Algo.

Case T-Seq-Algo: By inversion of T-Seq-Algo, we know
(A1) Γ, 𝑥 : 𝜏1 ⊢ 𝑐1; 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22
(A2) Γ, 𝑥 : 𝜏1 ⊢ 𝑐1 : (𝑦 : 𝜏12) ⇝ 𝜏 ′
12
12) ⇝ 𝜏 ′
(A3) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏12 ⊢ 𝑐2 : (𝑧 : 𝜏 ′
22
(A4) 𝜏22 = 𝜏 ′
22 [𝑧 ↦→ 𝜏 ′

12]

(A5) Γ, 𝑥 : 𝜏 ′

By IH applied to (A2) and (B) follows
1 ⊢ 𝑐1 : (𝑦 : 𝜏12) ⇝ 𝜏 ′
12
By IH applied to (A3) and (B) follows

(A6) Γ, 𝑥 : 𝜏 ′

1, 𝑦 : 𝜏12 ⊢ 𝑐2 : (𝑧 : 𝜏 ′

12) ⇝ 𝜏 ′
22

The result follows by T-Seq-Algo with (A5) and (A6).

Case T-Skip-Algo: The result immediately follows by T-Skip-Algo.
Case T-Remit-Algo: By inversion of T-Remit-Algo, we know
(A1) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 <: 𝜄≈

By Lemma C.4 applied to (A1) and (B) follows

(A2) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏12 <: 𝜄≈

The result follows by T-Remit-Algo.

Case T-Reset-Algo: The result immediately follows by T-Reset-Algo.
Case T-Ascribe-Algo: By inversion of T-Ascribe-Algo, we know
(A1) Γ, 𝑥 : 𝜏1 ⊢ 𝑐0 𝑎𝑠 (𝑦 : ˆ𝜏12) → 𝜏22 : (𝑦 : 𝜏12) ⇝ 𝜏22
(A2) Γ, 𝑥 : 𝜏1 ⊢ 𝑐0 : (𝑦 : ˆ𝜏12) ⇝ 𝜏 ′
22
(A3) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 <: ˆ𝜏12
(A4) Γ, 𝑥 : 𝜏1, 𝑦 : ˆ𝜏12 ⊢ 𝜏 ′

22 <: 𝜏22

By IH applied to (A2) and (B) follows
1 ⊢ 𝑐0 : (𝑦 : ˆ𝜏12) ⇝ 𝜏 ′
22

(A5) Γ, 𝑥 : 𝜏 ′

By Lemma C.4 applied to (A3) and (B) follows

(A6) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏12 <: ˆ𝜏12

By Lemma C.4 applied to (A4) and (B) follows
22 <: 𝜏22

1, 𝑦 : ˆ𝜏12 ⊢ 𝜏 ′

(A7) Γ, 𝑥 : 𝜏 ′

The result follows by T-Ascribe-Algo with (A5), (A6) and (A7).

Case T-If-Algo:

By inversion of T-If-Algo, we know

(A1) Γ, 𝑥 : 𝜏1 ⊢ 𝑐1 : (𝑦 : {𝑧 : 𝜏12 | 𝜑 [𝑧/heap]}) ⇝ 𝜏 ′
12
(A2) Γ, 𝑥 : 𝜏1 ⊢ 𝑐1 : (𝑦 : {𝑧 : 𝜏12 | ¬𝜑 [𝑧/heap]}) ⇝ 𝜏 ′′
12
(A3) 𝜏22 = {𝑧 : 𝜏 ′
(A4) Γ, 𝑥 : 𝜏1; 𝜏12 ⊢ 𝜑 : B

12 | 𝜑 [𝑥/heap]} + {𝑧 : 𝜏 ′′

12 | ¬𝜑 [𝑥/heap]}

By IH applied to (A1) and (B) follows

(A5) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝑐1 : (𝑦 : {𝑧 : 𝜏12 | 𝜑 [𝑧/heap]}) ⇝ 𝜏 ′
12

By IH applied to (A2) and (B) follows

(A6) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝑐1 : (𝑦 : {𝑧 : 𝜏12 | ¬𝜑 [𝑧/heap]}) ⇝ 𝜏 ′′
12
Since Γ, 𝑥 : 𝜏1; 𝜏12 ⊢ 𝜑 : B, it also holds that Γ, 𝑥 : 𝜏 ′
T-If-Algo.

1; 𝜏12 ⊢ 𝜑 : B. The result then follows by

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:69

Case T-Mod-Algo: By inversion of T-Mod-Algo, we know
(A1) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 <: 𝜄≈
(A2) Γ, 𝑥 : 𝜏1; 𝜏12 ⊢ 𝑒 : BV

By Lemma C.4 applied to (A1) and (B) follows

(A3) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏12 <: 𝜄≈

Since Γ, 𝑥 : 𝜏1; 𝜏12 ⊢ 𝑒 : BV, it also holds that Γ, 𝑥 : 𝜏 ′
T-Mod-Algo.

1; 𝜏12 ⊢ 𝑒 : BV. The result follows by

Case T-Add-Algo: By inversion of T-Add-Algo, we know
(A1) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}

By Lemma C.4 applied to (A1) and (B) follows

(A2) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏12 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}
The result follows by T-Add-Algo.

□

is not free in 𝜏1 or 𝜏 ′

Lemma C.16 (Algorithmic Input Subtype). If Γ ⊢ 𝜏 ′
1, then there exists 𝜏 ′

2 such that Γ ⊢ 𝑐 : (𝑥 : 𝜏 ′
Proof. By induction on the typing derivation. We refer to the general assumptions as follows:
(A) Γ ⊢ 𝜏 ′
1 <: 𝜏1
(B) Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏2
(C) 𝑥 not free in 𝜏1 or 𝜏 ′
1

1 <: 𝜏1 and Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏2 such that 𝑥
2 and Γ, 𝑥 : 𝜏 ′

1) ⇝ 𝜏 ′

2 <: 𝜏2.

1 ⊢ 𝜏 ′

We refer to the proof goals as follows:

(1) Γ ⊢ 𝑐 : (𝑥 : 𝜏 ′
(2) Γ, 𝑥 : 𝜏 ′
1 ⊢ 𝜏 ′

1) ⇝ 𝜏 ′
2
2 <: 𝜏2

Case T-Extract-Algo: By inversion of T-Extract-Algo, we know
(A1) 𝑐 = extract (𝜄)
(A2) Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)}
(A3) 𝜑1 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩
(A4) 𝜑2 ≜ 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥
(A5) 𝜏21 ≜ {𝑧 : 𝜄 | 𝜑1}
(A6) 𝜏22 ≜ {𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑2}
(A7) 𝜏2 = Σ𝑦 : 𝜏21.𝜏22

By Lemma C.2 with (A) and (A2),

(A8) Γ ⊢ 𝜏 ′

1 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)}

By Lemma C.6 with (A2) and (A),

(A9) Γ, 𝑦 : 𝜏21 ⊢ chomp(𝜏 ′

1, 𝜄, 𝑦) <: chomp(𝜏1, 𝜄, 𝑦)

(1) follows by T-Extract-Algo. (2) follows by Lemmas C.7 and C.9 and (A9).

Case T-Seq-Algo: By inversion of T-Seq-Algo, we know
(A1) 𝑐 = 𝑐1; 𝑐2
(A2) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) ⇝ 𝜏12
(A3) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22
(A4) 𝜏2 = 𝜏22 [𝑦 ↦→ 𝜏12]

By IH applied to (A2) and (A), there is some 𝜏 ′
12, and

1) ⇝ 𝜏 ′

12 such that

(A5) Γ ⊢ 𝑐1 : (𝑥 : 𝜏 ′
(A6) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏 ′

12 <: 𝜏12

By Lemma C.15 with (A) and (A3),
1 ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22

(A7) Γ, 𝑥 : 𝜏 ′

By IH applied to (A7) and (A6), there is some 𝜏 ′

22 such that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:70

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

(A8) Γ, 𝑥 : 𝜏 ′
(A9) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝑐2 : (𝑦 : 𝜏 ′
1, 𝑦 : 𝜏 ′
12 ⊢ 𝜏 ′

12) ⇝ 𝜏 ′
22 <: 𝜏22

22, and

(1) follows by T-Seq-Algo with (A5) and (A8). To show (2), we just need to show that
Γ, 𝑥 : 𝜏 ′
12] <: 𝜏22 [𝑦 ↦→ 𝜏12]. This follows by Lemma C.10 applied to (A6) and
(A9).

22 [𝑦 ↦→ 𝜏 ′

1 ⊢ 𝜏 ′

Immediate by T-Skip-Algo.

Case T-Skip-Algo:
Case T-Remit-Algo: By inversion of T-Remit-Algo, we know
(A1) Γ ⊢ 𝜏1 <: 𝜄≈
(A2) 𝑐 = remit (𝜄)
(A3) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}

By Lemma C.2 with (A1) and (A) follows

(A4) Γ ⊢ 𝜏 ′
Let 𝜏 ′
T-Remit-Algo. By Lemma C.4, and since 𝑥 does not occur free in 𝜏1 or 𝜏 ′

1 <: 𝜄≈
2 = Σ𝑦 : {𝑧 : 𝜏 ′

1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄}. (1) follows by

1, we know

(A5) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏 ′

1 <: 𝜏1

By Lemma C.7 we know
1 ⊢ {𝑧 : 𝜏 ′

(A6) Γ, 𝑥 : 𝜏 ′

1 | 𝑧 ≡ 𝑥 } <: {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }

By Lemma C.8 with 𝜏22 = {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄} follows

(A7) Γ, 𝑥 : 𝜏 ′

1 ⊢ Σ𝑦 : {𝑧 : 𝜏 ′

1 | 𝑧 ≡ 𝑥 }.𝜏22 <: Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.𝜏22

This shows (2) and concludes this case.

Case T-Reset-Algo: By inversion of T-Reset-Algo, we know
(A1) 𝜏2 = Σ𝑦 : {𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑖𝑛 }

Let 𝜏 ′

2 = 𝜏2. (1) follows by T-Reset-Algo and (2) follows by Lemma C.1.

Case T-Ascribe-Algo: By inversion of T-Ascribe-Algo, we know
(A1) 𝑐 = 𝑐0 as (𝑥 : ˆ𝜏1) → 𝜏2
(A2) Γ ⊢ 𝑐0 : (𝑥 : ˆ𝜏1) ⇝ 𝜏𝑐
(A3) Γ ⊢ 𝜏1 <: ˆ𝜏1
(A4) Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏𝑐 <: 𝜏2

By Lemma C.2 applied to (A) and (A3) follows that

(A5) Γ ⊢ 𝜏 ′
Let 𝜏 ′

1 <: ˆ𝜏1
2 = 𝜏2. (1) follows by T-Ascribe-Algo with (A2), (A4) and (A5). (2) follows by Lemma C.1.

Case T-If-Algo: By inversion of T-If-Algo, we know
(A1) 𝑐 = if (𝜑) then c1 else c2
(A2) Γ; 𝜏1 ⊢ 𝜑 : B
(A3) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) ⇝ 𝜏12
(A4) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) ⇝ 𝜏22
(A5) 𝜏2 = {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}

By (A) and Lemma C.7, we know

(A6) Γ ⊢ {𝑦 : 𝜏 ′
(A7) Γ ⊢ {𝑦 : 𝜏 ′

1 | 𝜑 [𝑦/heap]} <: {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}, and
1 | ¬𝜑 [𝑦/heap]} <: {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}

By applying the IH to (A6) and (A3) we get 𝜏 ′
12, and

1 | 𝜑 [𝑦/heap]}) ⇝ 𝜏 ′

(A8) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏 ′
(A9) Γ, 𝑥 : {𝑦 : 𝜏 ′

1 | 𝜑 [𝑦/heap]} ⊢ 𝜏 ′

12 <: 𝜏12

(A10) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏 ′
(A11) Γ, 𝑥 : {𝑦 : 𝜏 ′

By applying the IH to (A7) and (A4) we get 𝜏 ′
22, and

1 | ¬𝜑 [𝑦/heap]}) ⇝ 𝜏 ′

1 | ¬𝜑 [𝑦/heap]} ⊢ 𝜏 ′
From (A2) and (A), we can conclude that

22 <: 𝜏22

12 such that

22 such that

(A12) Γ; 𝜏 ′

1 ⊢ 𝜑 : B

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:71

22 | ¬𝜑 [𝑥/heap]}. (2) follows by Lemma C.13. (1)

2 = {𝑦 : 𝜏 ′

12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏 ′

Let 𝜏 ′
follows by T-If-Algo with (A8), (A10) and (A12).
Case T-Mod-Algo: By inversion of T-Mod-Algo, we know
(A1) Γ ⊢ 𝜏1 <: 𝜄≈
(A2) Γ; 𝜏1 ⊢ 𝑒 : BV
(A3) 𝜏2 = {𝑦 : ⊤ | 𝜑 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}
By Lemma C.2 with (A) and (A1) follows

(A4) Γ ⊢ 𝜏 ′

1 <: 𝜄≈

From (A2) and (A), we can conclude

(A5) Γ; 𝜏 ′

1 ⊢ 𝑒 : BV
2 = 𝜏2. (1) follows by T-Mod-Algo with (A4) and (A5). (2) follows by Lemma C.1.

Let 𝜏 ′

Case T-Add-Algo: By inversion of T-Add-Algo, we know
(A1) Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}
(A2) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }

By Lemma C.2 with (A1) and (A) follows

(A3) Γ ⊢ 𝜏 ′
Let 𝜏 ′
T-Add-Algo. By Lemma C.4 with (A) and (C),

1 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}
2 = Σ𝑦 : {𝑧 : 𝜏 ′

1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄

| 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }. (1) follows by

(A4) Γ, 𝑥 : 𝜏 ′

1 ⊢ 𝜏 ′

1 <: 𝜏1

By Lemma C.7 follows
1 ⊢ {𝑧 : 𝜏 ′

(A5) Γ, 𝑥 : 𝜏 ′

1 | 𝑧 ≡ 𝑥 } <: {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }

(2) follows by Lemma C.8 with (A5).

□

Lemma C.17 (Includes Subtype). Includes Γ 𝜏 𝜄 ⇐⇒ Γ ⊢ 𝜏 <: 𝜄∼

Proof. Prove each direction separately

(⇒) Assume Includes Γ 𝜏 𝜄. Let E |= Γ and ℎ ∈ ⟦𝜏⟧E. By definition of the inclusion relation,
𝜄 ∈ dom(ℎ). By the definition of subtyping, it suffices to show ℎ ∈ ⟦𝜄∼⟧E. By definition,
⟦𝜄∼⟧E = {ℎ | 𝜄 ∈ dom(ℎ)}, and we’re done.

(⇐) Assume Γ ⊢ 𝜏 <: 𝜄∼. Show Includes Γ 𝜏 𝜄. To that end, let E |= Γ and ℎ ∈ ⟦𝜏⟧E be arbitrary. By
the definition of subtyping, ℎ ∈ ⟦𝜄∼⟧E. By definition of the semantics, conclude 𝜄 ∈ dom(ℎ).
□

Lemma C.18 (Excludes Subtype). Excludes Γ 𝜏 𝜄 iff Γ ⊢ 𝜏 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}

Proof. Prove each direction separately

(⇒) Assume Excludes Γ 𝜏 𝜄. Let E |= Γ and ℎ ∈ ⟦𝜏⟧E. By definition of the exclusion relation,
𝜄 ∉ dom(ℎ). By the definition of subtyping, it suffices to show ℎ ∈ ⟦{𝑥 : ⊤ | ¬𝑥 .𝜄.valid}⟧E.
By definition, ⟦{𝑥 : ⊤ | ¬𝑥 .𝜄.valid}⟧E = {ℎ | 𝜄 ∉ dom(ℎ)}, and we’re done.

(⇐) Assume Γ ⊢ 𝜏 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}. Show Excludes Γ 𝜏 𝜄. To that end, let E |= Γ and
ℎ ∈ ⟦𝜏⟧E be arbitrary. By the definition of subtyping, ℎ ∈ ⟦{𝑥 : ⊤ | ¬𝑥 .𝜄.valid}⟧E. By
definition of the semantics, conclude 𝜄 ∉ dom(ℎ).

□

Theorem C.19 (Algorithmic Typing Correctness). For all subtyping contexts Γ, commands 𝑐,
variables 𝑥, heap types 𝜏1, and 𝜏2, where 𝑥 is not free in 𝜏1, Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 if and only if there is
some 𝜏 ′

2 such that Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′

2, and Γ, (𝑥 : 𝜏1) ⊢ 𝜏 ′

2 <: 𝜏2.

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:72

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Proof. (⇒) Assume Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2. Proceed by induction on the typing derivation,

leaving Γ general. We refer to the proof goals as follows:

(1) Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′
2
(2) Γ, (𝑥 : 𝜏1) ⊢ 𝜏 ′
2 <: 𝜏2
Case T-Extract:

(A1) 𝑐 = extract (𝜄)
(A2) Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏1) ≥ sizeof (𝑖)
(A3) 𝜑1 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩
(A4) 𝜑2 ≜ 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥
(A5) 𝜏2 = Σ𝑦 : {𝑧 : 𝜄 | 𝜑1}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑2}

The only algorithmic rule that applies to extract (𝜄) is T-Extract-Algo. Since Γ ⊢ 𝜏1 <: {𝑥 :
⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)} by (A2) and Lemma C.5, T-Extract-Algo produces 𝜏 ′
2 such that
1 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩
2 ≜ 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥
2 = Σ𝑦 : {𝑧 : 𝜄 | 𝜑 ′
1}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑 ′
2}
which shows (1). (2) follows by Lemma C.1.

(A6) 𝜑 ′
(A7) 𝜑 ′
(A8) 𝜏 ′

Case T-Seq:

(A1) 𝑐 = 𝑐1; 𝑐2
(A2) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) → 𝜏12
(A3) Γ, (𝑥 : 𝜏1) ⊢ 𝑐2 : (𝑦 : 𝜏12) → 𝜏22
(A4) 𝜏2 = 𝜏22 [𝑥 ↦→ 𝜏12]

(A5) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) ⇝ 𝜏 ′
(A6) Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′

12 <: 𝜏12

12, and

By applying the IH to (A2), we get 𝜏 ′

12 such that

By applying the IH to (A3), we get 𝜏 ′

22 such that

(A7) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏 ′
(A8) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏12 ⊢ 𝜏 ′

22 <: 𝜏22

22, and

(A9) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏 ′
(A10) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏 ′
12 ⊢ 𝜏 ′′

By Lemma C.16 with (A6) and (A7) there exists 𝜏 ′′
12) ⇝ 𝜏 ′′
22 <: 𝜏 ′
22
By T-Seq-Algo with (A5) and (A9) follows

22, and

22 such that

(A11) Γ ⊢ 𝑐1; 𝑐2 : (𝑥 : 𝜏1) ⇝ 𝜏 ′′

22 [𝑦 ↦→ 𝜏 ′

12]

which shows (1). By Lemma C.4 with (A6) and (A8) follows

(A12) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏 ′

12 ⊢ 𝜏 ′

22 <: 𝜏22
By Lemma C.2 with (A10) and (A12) follows
22 <: 𝜏22

12 ⊢ 𝜏 ′′

(A13) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏 ′

By Lemma C.10 follows

(A14) Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′′

22 [𝑦 ↦→ 𝜏 ′

12] <: 𝜏22 [𝑦 ↦→ 𝜏12]

which shows (2) and concludes this case.

Case T-Skip:
Case T-Remit: By inversion of T-Remit, we know

(1) follows by T-Skip-Algo and (2) follows by Lemma C.1.

(A1) 𝑐 = remit (𝜄)
(A2) Includes Γ 𝜏1 𝜄
(A3) 𝜑 ≜ 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄
(A4) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝜑 }

By Lemma C.17 and (A2), T-Remit-Algo computes 𝜏 ′

2 such that

(A5) Γ ⊢ remit (𝜄i) : ((𝑥 : 𝜏1)) ⇝ 𝜏 ′
(A6) 𝜏 ′

2, and
2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝜄}

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:73

which shows (1). Since 𝜏 ′

2 = 𝜏2, (2) follows by Lemma C.1.

Case T-Reset:
Case T-Ascribe: By inversion of T-Ascribe, we know

(1) follows by T-Reset-Algo and (2) follows by Lemma C.1.

(A1) 𝑐 = 𝑐0 as (𝑥 : 𝜏1) → 𝜏2
(A2) Γ ⊢ 𝑐0 : (𝑥 : 𝜏1) → 𝜏2

By IH applied to (A2), there exists ˆ𝜏2 such that

(A3) Γ ⊢ 𝑐0 : (𝑥 : 𝜏1) ⇝ ˆ𝜏2
(A4) Γ, 𝑥 : 𝜏1 ⊢ ˆ𝜏2 <: 𝜏2

By T-Ascribe-Algo with (A3), (A4) and Lemma C.1,

(A5) Γ ⊢ 𝑐0 as (𝑥 : 𝜏1) → 𝜏2 : (𝑥 : 𝜏1) ⇝ 𝜏2

showing (1). (2) follows by Lemma C.1.
Case T-If: By inversion of T-If, we know

(A1) 𝑐 = if (𝜑) then c1 else c2
(A2) Γ; 𝜏1 ⊢ 𝜑 : B
(A3) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) → 𝜏12
(A4) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) → 𝜏22
(A5) 𝜏2 = {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}
By the IH applied to (A3) there exists 𝜏 ′
12 such that
(A6) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) ⇝ 𝜏 ′
12
(A7) Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ⊢ 𝜏 ′

12 <: 𝜏12

By the IH applied to (A4) there exists 𝜏 ′
22 such that
(A8) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) ⇝ 𝜏 ′
22
(A9) Γ, 𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]} ⊢ 𝜏 ′

22 <: 𝜏22

(1) follows by T-If-Algo with (A2), (A6) and (A8).
(2) follows by Lemma C.13 with (A7) and (A9).
Case T-Mod: By inversion of T-Mod, we know

(A1) 𝑐 = 𝜄.𝑓 := 𝑒
(A2) Includes Γ 𝜏1 𝜄
(A3) F (𝜄, 𝑓 ) = BV
(A4) Γ; 𝜏1 ⊢ 𝑒 : BV
(A5) 𝜏2 = {𝑦 : ⊤ | 𝜑pkt ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}

By Lemma C.17 and (A2),

(A6) Γ ⊢ 𝜏1 <: 𝜄𝑖

(1) follows by T-Mod-Algo with (A3),(A4), (A5), and (A6). (2) follows by Lemma C.1.

Case T-Add: By inversion of T-Add, we know

(A1) Excludes Γ 𝜏1 𝜄
(A2) initH T (𝜄) = 𝑣
(A3) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }

(1) follows by T-Add-Algo with (A1) and (A2). (2) follows by Lemma C.1.
Case T-Sub: By inversion of T-Sub, there exists some 𝜏3 and 𝜏4 such that

By Lemma C.18 and (A1),
(A4) Γ ⊢ 𝜏 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid}

(A1) Γ ⊢ 𝜏1 <: 𝜏3
(A2) Γ, 𝑥 : 𝜏1 ⊢ 𝜏4 <: 𝜏2
(A3) Γ ⊢ 𝑐 : (𝑥 : 𝜏3) → 𝜏4

By applying the IH to (A3) there is some 𝜏 ′
4, and

(A4) Γ ⊢ 𝑐 : (𝑥 : 𝜏3) ⇝ 𝜏 ′
(A5) Γ, 𝑥 : 𝜏3 ⊢ 𝜏 ′

4 <: 𝜏4

4 such that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:74

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

By Lemma C.4 together with (A1) and (A5), follows

By applying Lemma C.16 to (A1) and (A4) we get 𝜏 ′′

4 such that

(A6) Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′

4 <: 𝜏4

(A7) Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′′
(A8) Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′′

4 <: 𝜏 ′
4

4 , and

(1) follows by (A7). (2) follows by repeated application of Lemma C.2 with (A2), (A6) and
(A8).

(⇐) Proceed by induction on the typing derivation. We refer to the general assumptions as follows:

(A) Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′
2
(B) Γ, (𝑥 : 𝜏1) ⊢ 𝜏 ′
2 <: 𝜏2

Case T-Extract-Algo: By inversion of T-Extract-Algo, we know

(A1) Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)}
(A2) 𝜏 ′

2 = Σ𝑦 : {𝑧 : 𝜄 | 𝜑1}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑2}
By Lemma C.5 follows
(A3) Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏1) ≥ sizeof (𝜄)

The result follows by T-Extract with (A3) and Lemma C.1.
Case T-Seq-Algo: By inversion of T-Seq-Algo, we know

(A1) 𝑐 = 𝑐1; 𝑐2
(A2) Γ ⊢ 𝑐1 : ((𝑥 : 𝜏1)) ⇝ 𝜏12
(A3) Γ, (𝑥 : 𝜏1) ⊢ 𝑐2 : ((𝑦 : 𝜏12)) ⇝ 𝜏22
(A4) 𝜏 ′
(A5) Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′

2 = 𝜏22 [𝑦 ↦→ 𝜏12]
2 <: 𝜏2

With Lemma C.1 follows

(A6) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 <: 𝜏12

By IH with (A2) and (A6) follows

(A7) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) → 𝜏12

Similarly, applying the IH to (A3) gives

(A8) Γ, (𝑥 : 𝜏1) ⊢ 𝑐2 : (𝑥 : 𝜏12) → 𝜏22

By T-Seq with (A7) and (A8) follows

(A9) Γ ⊢ 𝑐1; 𝑐2 : (𝑥 : 𝜏1) → 𝜏22 [𝑦 ↦→ 𝜏12]

By (A4), (A5), Lemma C.1 and T-Sub follows

(A10) Γ ⊢ 𝑐1; 𝑐2 : (𝑥 : 𝜏1) → 𝜏2

which concludes this case.

Case T-Skip-Algo:

The result follows by T-Skip, Lemma C.1, and T-Sub.

Case T-Remit-Algo: The result follows by T-Remit, Lemma C.17, Lemma C.1, and T-Sub.
Case T-Reset-Algo: The result follows by T-Reset, Lemma C.1, and T-Sub.
Case T-Ascribe-Algo: By inversion of T-Ascribe-Algo, we know

(A1) 𝑐 = 𝑐0 as (𝑥 : ˆ𝜏1) → 𝜏 ′
2
(A2) Γ ⊢ 𝑐0 : (𝑥 : ˆ𝜏1) ⇝ 𝜏 ′′
2
(A3) Γ ⊢ 𝜏1 <: ˆ𝜏1
(A4) Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏 ′′

2 <: 𝜏 ′
2

By IH applied to (A2) and (A4), we get

(A5) Γ ⊢ 𝑐0 : (𝑥 : ˆ𝜏1) → 𝜏 ′
2
By T-Ascribe follows from (A5) that
2 : (𝑥 : ˆ𝜏1) → 𝜏 ′
2

(A6) Γ ⊢ 𝑐0 as (𝑥 : ˆ𝜏1) → 𝜏 ′

The result follows by T-Sub with assumptions (B), (A3) and (A6).

Case T-If-Algo: By inversion of T-If-Algo, we know

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:75

(A1) 𝑐 = if (𝜑) then c1 else c2
(A2) Γ; 𝜏1 ⊢ 𝜑 : B
(A3) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) ⇝ 𝜏12
(A4) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) ⇝ 𝜏22
(A5) 𝜏 ′

2 = {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}
By Lemma C.1, we can conclude
(A6) Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ⊢ 𝜏12 <: 𝜏12
By IH with (A3) and (A6) follows
(A7) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) → 𝜏12

We can reason similarly as before to conclude

(A8) Γ ⊢ 𝑐2 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) → 𝜏22

The result follows by T-If with (A2), (A7), (A8) and (A5) and by T-Sub with assumption (B).
Case T-Mod-Algo: The result follows by T-Mod with Lemma C.17, Lemma C.1 and T-Sub.
Case T-Add-Algo: The result follows by T-Add with Lemma C.18, Lemma C.1 and T-Sub.
□

D MTU BOUND
We want to prove a theorem that says that if we have an maximum transmission unit (MTU) 𝑁 for
a packet, then we can bound the number of bits in the types.

We want to prove that if a program typechecks with a bound on its input type, then we can
compute that maximum number of bits that we need to encode the input type. Ideally, this would
be the same bound; however, it is possible for the text of the program to emit more bits from the
incoming packet than is allowed by the MTU. So we define a helper function emit(𝑐) ∈ N that
over-approximates the maximum number of bits that could be emitted along any program path in
𝑐. This is defined in Figure 21

≜ 0

emit(extract (𝜄))
emit(if (b) then c1 else c2) ≜ max(emit(𝑐1), emit(𝑐2))
emit(𝑐1; 𝑐2)
emit(𝜄.𝑓 := 𝑡)
emit(remit (𝜄))
emit(skip)
emit(reset)
emit(add (𝜄))
emit(𝑐 as 𝜎)

≜ emit(𝑐1) + emit(𝑐2)
≜ 0
≜ sizeof(𝜄)
≜ 0
≜ 0
≜ 0
≜ emit(𝑐)

Fig. 21. emit(𝑐) ∈ N computes the maximum number of bits that can be emitted along any path in c.

We also need a way to state that a type 𝜏 satisfies a given MTU 𝑛; that is that for every denoted

heap ℎ, 𝑝𝑘𝑡𝑖𝑛 and 𝑝𝑘𝑡𝑜𝑢𝑡 use fewer than 𝑛 bits combined. This is defined formally in Figure 22.

Γ ⊢ 𝜏 ≤ 𝑛 ≜ ∀E |= Γ, ∀ℎ ∈ ⟦𝜏⟧E, |ℎ(𝑝𝑘𝑡𝑖𝑛)| + |ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑛

Fig. 22. Bound the size of types

We also need a few lemmas about how this interacts with various types

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:76

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Lemma D.1 (Refinement Bound). For every Γ, 𝑥, 𝜏, 𝜑, 𝑁 , such that Γ ⊢ 𝜏 ≤ 𝑁 , Γ ⊢ {𝑥 : 𝜏 | 𝜑 } ≤ 𝑁 .
Proof. Let Γ, 𝑥, 𝜏, 𝜑, 𝑁 , be given such that Γ ⊢ 𝜏 ≤ 𝑁 . Let E |= Γ. Further, let ℎ ∈ ⟦{𝑥 : 𝜏 | 𝜑 }⟧E.
By the semantics of heap types, we also know that ℎ ∈ ⟦𝜏⟧E. Assumption Γ ⊢ 𝜏 ≤ 𝑁 gives us that
□
|ℎ(𝑝𝑘𝑡𝑖𝑛)| + |ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 , which is what we want to show.

Lemma D.2 (Bound Constraints). For every Γ, 𝑥, 𝑦, 𝜏1, 𝜏2, and 𝜑, such that heap is the only free
variable in 𝜑, Γ, 𝑥 : 𝜏1 ⊢ {𝑦 : 𝜏2 | 𝜑 [𝑥/heap]} ≤ 𝑁 , if and only if Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ⊢ 𝜏2 ≤ 𝑁 .

Proof. Let Γ, 𝑥, 𝑦, 𝜏1, 𝜏2, and 𝜑 be given. Prove each direction separately.

(⇒) Assume Γ, 𝑥 : 𝜏1 ⊢ {𝑦 : 𝜏2 | 𝜑 [𝑥/heap]} ≤ 𝑁 .

Let E |= Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}. We can write E = E ′[𝑥 ↦→ ℎ] for some E ′ |= Γ, and
some ℎ1 ∈ ⟦𝜏1⟧E′, such that ⟦𝜑 [𝑦/heap]⟧E′ [𝑦↦→ℎ1 ] = ⟦𝜑⟧E′ [heap↦→ℎ1 ] = true. Since 𝑦 does not
occur in 𝜑, then we also have ⟦𝜑⟧E [heap↦→ℎ,𝑦↦→ℎ2 ] = true.
Now, consider ℎ2 ∈ ⟦𝜏2⟧E′ [𝑥↦→ℎ1 ]. To show that |ℎ2(𝑝𝑘𝑡𝑖𝑛)| + |ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 .
Since ⟦𝜑⟧E [heap↦→ℎ,𝑦↦→ℎ2 ] = true = ⟦𝜑 [𝑥/heap]⟧E [𝑥↦→ℎ,𝑦↦→ℎ2 ], we can conclude that ℎ2 ∈
⟦{𝑦 : 𝜏2 | 𝜑 [𝑥/heap]}⟧E′ [𝑥↦→ℎ]. Now, since E ′[𝑥 ↦→ ℎ] |= Γ, (𝑥 : 𝜏1), the result follows by our
initial assumption assumption Γ, (𝑥 : 𝜏1) ⊢ {𝑦 : 𝜏2 | 𝜑 [𝑥/heap]} ≤ 𝑁 .

(⇐) Assume Γ, (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) ⊢ 𝜏2 ≤ 𝑁 .

Let E |= Γ, (𝑥 : 𝜏1). We can write E = E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′ and E ′ |= Γ.
Now consider ℎ2 ∈ ⟦{𝑦 : 𝜏2 | 𝜑 [𝑥/heap]}⟧E′ [𝑥↦→ℎ1 ]. To show |ℎ2(𝑝𝑘𝑡𝑖𝑛)| + |ℎ2 (𝑝𝑘𝑡𝑜𝑢𝑡 )| < 𝑁 .
By the semantics of heap types, we have ⟦𝜑⟧E′ [𝑥↦→ℎ1,𝑦↦→ℎ2 ] = ⟦𝜑⟧E′ [heap↦→ℎ1,𝑦↦→ℎ2 ] = true.
Since 𝑦 is not free in 𝜑, we also have ⟦𝜑⟧E′ [heap↦→ℎ1 ] = ⟦𝜑 [𝑦/heap]⟧E′ [𝑦↦→ℎ1 ] = true, so we
can conclude that ℎ1 ∈ ⟦{𝑦 : 𝜏1 | 𝑒 [𝑦/heap]}⟧E′. By our initial assumption, every heap in 𝜏2
is bounded and as such also heap ℎ2 ∈ ⟦{𝑦 : 𝜏2 | 𝜑 [𝑥/heap]}⟧E′ [𝑥↦→ℎ1 ].

□

Lemma D.3 (Bound Choice). If Γ ⊢ 𝜏1 ≤ 𝑁 and Γ ⊢ 𝜏2 ≤ 𝑀, then Γ ⊢ 𝜏1 + 𝜏2 ≤ max(𝑀, 𝑁 ).
Proof. Let E |= Γ and ℎ ∈ ⟦𝜏1+𝜏2⟧E. We have to show that |ℎ(𝑝𝑘𝑡𝑖𝑛)|+|ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ max(𝑀, 𝑁 ).

Case 𝑀 = 𝑁 :

Assume 𝑀 = 𝑁 , so max(𝑀, 𝑁 ) = 𝑀 = 𝑁 . By the semantics of heap types ℎ ∈ ⟦𝜏1⟧E or
ℎ ∈ ⟦𝜏2⟧E.
Subcase ℎ ∈ ⟦𝜏1⟧E: The result immediately follows by assumption Γ ⊢ 𝜏1 ≤ 𝑁 .
Subcase ℎ ∈ ⟦𝜏2⟧E: The result immediately follows by assumption Γ ⊢ 𝜏2 ≤ 𝑀.

Case 𝑀 > 𝑁 : Without loss of generality, we assume that 𝑀 > 𝑁 , so max(𝑀, 𝑁 ) = 𝑀. By the

semantics of heap types ℎ ∈ ⟦𝜏1⟧E or ℎ ∈ ⟦𝜏2⟧E.
Subcase ℎ ∈ ⟦𝜏1⟧E: By assumption Γ ⊢ 𝜏1 ≤ 𝑁 and since by assumption 𝑁 < 𝑀, it follows

Γ ⊢ 𝜏1 ≤ 𝑀.

Subcase ℎ ∈ ⟦𝜏2⟧E: The result immediately follows by assumption Γ ⊢ 𝜏2 ≤ 𝑀.

□

Lemma D.4 (Bound Substitution). For all Γ, 𝑦, 𝜏1, 𝜏2, 𝑁 , Γ ⊢ 𝜏2 [𝑦 ↦→ 𝜏1] ≤ 𝑁 if and only if

Γ, (𝑦 : 𝜏1) ⊢ 𝜏2 ≤ 𝑁 .

Proof. Let Γ, 𝑦, 𝜏1, 𝜏2, and 𝑁 be given. Prove each direction separately:
(⇒) Assume Γ ⊢ 𝜏2 [𝑦 ↦→ 𝜏2] ≤ 𝑁 . Let E |= Γ, 𝑦 : 𝜏1 such that ℎ2 ∈ ⟦𝜏2⟧E. This means there is
some E ′ |= Γ and ℎ1 ∈ ⟦𝜏1⟧E′ such that ℎ2 ∈ ⟦𝜏2⟧E′ [𝑦↦→ℎ1 ]. By the semantics of heap types
follows that ℎ2 ∈ ⟦𝜏2 [𝑦 ↦→ 𝜏1]⟧E′. With the initial assumption Γ ⊢ 𝜏2 [𝑦 ↦→ 𝜏1] ≤ 𝑁 , we can
conclude that |ℎ2(𝑝𝑘𝑡𝑖𝑛)| + |ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 .

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:77

(⇐) Assume Γ, 𝑦 : 𝜏1 |= 𝜏2 ≤ 𝑁 . Let E |= Γ and let ℎ2 ∈ ⟦𝜏2 [𝑦 ↦→ 𝜏1]⟧E. By the semantics of heap
types, there is some ℎ1 ∈ ⟦𝜏1⟧E such that ℎ2 ∈ ⟦𝜏2⟧E [𝑦↦→ℎ1 ]. Notice that E [𝑦 ↦→ ℎ1] |= Γ, 𝑦 : 𝜏1.
The initial assumption proves that |ℎ(𝑝𝑘𝑡𝑖𝑛)| + |ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 .

□

We can then formulate the following two theorems.

Theorem D.5 (Forwards MTU Bound). For every Γ, 𝑐, 𝑥, 𝜏1, 𝜏2, and 𝑁 ∈ N, if Γ ⊢ 𝜏1 ≤ 𝑁 and
Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏2 and every ascribed type in 𝑐 is also bounded by 𝑁 , then Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 +emit(𝑐)

Proof. Proceed by induction on 𝑐, leaving Γ and 𝑁 general. We refer to the general assumptions

as follows:

(A) Γ ⊢ 𝜏1 ≤ 𝑁
(B) Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏2

Case extract (𝜄):

The only algorithmic typing rule that applies to extract (𝜄) is T-Extract-Algo. By inversion,
we know

(A1) 𝜏2 = Σ𝑦 : {𝑧 : 𝜄 | 𝜑1}.{𝑧 : chomp(𝜏1, 𝜄, 𝑦) | 𝜑2}
(A2) 𝜑1 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩
(A3) 𝜑2 = 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥.

Since emit(extract (𝜄)) = 0, it suffices to show Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 .
Let E |= Γ, 𝑥 : 𝜏1 and let ℎ2 ∈ ⟦𝜏2⟧E. We can write E as E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′.
By definition of the semantics of heap types we know there are some ℎ21 and ℎ22 such that

(A4) ℎ2 = ℎ21 ++ ℎ22,
(A5) ℎ21(𝑝𝑘𝑡𝑖𝑛) = ℎ21 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩
(A6) ℎ1(𝑝𝑘𝑡𝑖𝑛) = ℎ21(𝜄)@ℎ22 (𝑝𝑘𝑡𝑖𝑛)
(A7) ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ22 (𝑝𝑘𝑡𝑜𝑢𝑡 )

We can further conclude that

(A8) ℎ2 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 ),
(A9) ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ22 (𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛) [|𝜄| :]

From assumption (A) follows
(A10) |ℎ1(𝑝𝑘𝑡𝑖𝑛)| + |ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁

Together with (A8) and (A9), we can conclude that |ℎ2(𝑝𝑘𝑡𝑖𝑛)| + |ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 )| < |ℎ1(𝑝𝑘𝑡𝑖𝑛)| +
|ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 .

Case add𝜄:

The only algorithmic typing rule that applies to add𝜄 is T-Add-Algo. By inversion, we know

(A1) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝜄 = 𝑣 }.
Since emit(add𝜄) = 0, it suffices to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 .
Let E |= Γ, 𝑥 : 𝜏1, and ℎ2 ∈ ⟦𝜏2⟧E. We can write E as E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′.
By definition of the semantics of heap types we know there are some ℎ21 and ℎ22 such that

(A2) ℎ2 = ℎ21 ++ ℎ22
(A3) ℎ21 = ℎ1
(A4) ℎ22 (𝑝𝑘𝑡𝑖𝑛) = ℎ22 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩

From these three equations we can conclude that

(A5) ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)
(A6) ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )

The result follows by assumption (A).

Case 𝜄.𝑓 := 𝑒:

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:78

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

The only algorithmic typing rule that applies to 𝜄.𝑓 := 𝑒 is T-Mod-Algo. By inversion, we
know

(A1) 𝜏2 = {𝑦 : ⊤ | 𝜑𝑝𝑘𝑡 ∧ 𝜑𝜄 ∧ 𝜑 𝑓 ∧ 𝑦.𝜄.𝑓 = 𝑒 [𝑥/heap]}
(A2) 𝜑𝑝𝑘𝑡 = 𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡

Since emit(𝜄.𝑓 := 𝑒) = 0, it suffices to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 .
Let E |= Γ, 𝑥 : 𝜏1 and ℎ2 ∈ ⟦𝜏2⟧E. We can write E as E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′. From
assumption (A1) and by the semantics of heap types follows

(A3) ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)
(A4) ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )

The result follows by assumption (A).

Case remit (𝜄):

The only algorithmic typing rule that applies to remit (𝜄) is T-Remit-Algo. By inversion, we
know

(A1) 𝜏2 = Σ𝑦 : {𝑧 : 𝜏1 | 𝑧 ≡ 𝑥 }.{𝑧 : 𝜖 | 𝜑 }
(A2) 𝜑 = 𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝜄

Since emit(remit (𝜄)) = sizeof (𝜄), we have to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 + sizeof(𝜄).
Let E |= Γ, 𝑥 : 𝜏1 and ℎ2 ∈ ⟦𝜏2⟧E. We can write E as E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′. By the
semantics of heap types, there exists ℎ21 and ℎ22 such that

(A3) ℎ2 = ℎ21 ++ ℎ22
(A4) ℎ21 = ℎ1
(A5) ℎ22 (𝑝𝑘𝑡𝑖𝑛) = ⟨⟩
(A6) ℎ22 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝜄)

From (A4) and (A5), we can conclude that

(A7) ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)

From (A4) and (A6), we can further conclude that

(A8) ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )@ℎ1(𝜄)

From (A7) and (A8) then follows

(A9) |ℎ2(𝑝𝑘𝑡𝑖𝑛)| + |ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 )| = |ℎ1(𝑝𝑘𝑡𝑖𝑛)| + |ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )| + sizeof(𝜄)

Together with assumption (A), we can conclude that |ℎ2 (𝑝𝑘𝑡𝑖𝑛)| + |ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 + sizeof (𝜄).

Case reset:

The only algorithmic typing rule that applies to reset is T-Reset-Algo. By inversion, we
know

(A1) 𝜏2 = Σ𝑦 : {𝑧 : 𝜖 | 𝜑1}.{𝑧 : 𝜖 | 𝜑2}
(A2) 𝜑1 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡
(A3) 𝜑2 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩ ∧ 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛

Since emit(reset) = 0, we have to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 .
Let E |= Γ, 𝑥 : 𝜏1 and ℎ2 ∈ ⟦𝜏2⟧E. We can write E as E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′. By the
semantics of heap types, there exists ℎ21 and ℎ22 such that

(A4) ℎ2 = ℎ21 ++ ℎ22
(A5) ℎ21 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩
(A6) ℎ21(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )
(A7) ℎ22 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩
(A8) ℎ22 (𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)

By (A4), (A5) and (A7) follows

(A9) ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩

and by (A4), (A6) and (A8) follows
(A10) ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )@ℎ1(𝑝𝑘𝑡𝑖𝑛)

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:79

Since by assumption (A), |ℎ1(𝑝𝑘𝑡𝑖𝑛)| + |ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 , by (A9) and (A10), |ℎ2(𝑝𝑘𝑡𝑖𝑛)| +
|ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 )| ≤ 𝑁 .

Case if (𝜑) then c1 else c2: The only algorithmic typing rule that applies is T-If-Algo. By inversion,

we know

(A1) 𝜏2 = {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]}
(A2) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]}) ⇝ 𝜏12
(A3) Γ ⊢ 𝑐1 : (𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]}) ⇝ 𝜏22

Since emit(if (𝜑) then c1 else c2) = max(emit(𝑐1), emit(𝑐2)), we have to show that Γ, 𝑥 : 𝜏1 ⊢
𝜏2 ≤ 𝑁 + max(emit(𝑐1), emit(𝑐2)).
By Lemma D.1 and assumption (A) follows

(A4) Γ ⊢ {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ≤ 𝑁
(A5) Γ ⊢ {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]} ≤ 𝑁

Applying the IH to (A2) and (A2) with (A4) and (A5) respectively, gives

(A6) Γ, 𝑥 : {𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} ⊢ 𝜏12 ≤ 𝑁 + emit(𝑐1)
(A7) Γ, 𝑥 : {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]} ⊢ 𝜏22 ≤ 𝑁 + emit(𝑐2)

By Lemma D.2 with (A6) and (A7) respectively follows

(A8) Γ, 𝑥 : 𝜏1 ⊢ {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} ≤ 𝑁 + emit(𝑐1)
(A9) Γ, 𝑥 : 𝜏1 ⊢ {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]} ≤ 𝑁 + emit(𝑐2)
By Lemma D.3 with (A8) and (A9) follows

(A10) Γ, 𝑥 : 𝜏1 ⊢ {𝑦 : 𝜏12 | 𝜑 [𝑥/heap]} + {𝑦 : 𝜏22 | ¬𝜑 [𝑥/heap]} ≤ max(𝑁 + emit(𝑐1), 𝑁 + emit(𝑐2))

The result follows together with the fact that max(𝐴 + 𝐵, 𝐴 + 𝐶) = 𝐴 + max(𝐵, 𝐶).

Case 𝑐1; 𝑐2:

The only algorithmic typing rule that applies to 𝑐1; 𝑐2 is T-Seq-Algo. By inversion, we know

(A1) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) ⇝ 𝜏12
(A2) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22
(A3) 𝜏2 = 𝜏22 [𝑦 ↦→ 𝜏12]

Since emit(𝑐1; 𝑐2) = emit(𝑐1) + emit(𝑐2), we have to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 + emit(𝑐1) +
emit(𝑐2). Let E |= Γ, 𝑥 : 𝜏1 and let ℎ2 ∈ ⟦𝜏2⟧E.
By applying the IH to (A1), we get

(A4) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 ≤ 𝑁 + emit(𝑐1)

Since we left Γ and 𝑁 general, we can apply the IH again to (A2) and get

(A5) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏12 ⊢ 𝜏22 ≤ 𝑁 + emit(𝑐1) + emit(𝑐2)
The result follows by Lemma D.4 with (A5).

Case skip:

(A1) 𝜏2 = {𝑦 : 𝜏1 | 𝑦 ≡ 𝑥 }

The only algorithmic typing rule that applies to skip is T-Skip-Algo. By inversion, we know

Since emit(skip) = 0, we have to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 .
Let E |= Γ, 𝑥 : 𝜏1 and ℎ2 ∈ ⟦𝜏2⟧E. We can write E as E ′[𝑥 ↦→ ℎ1] where ℎ1 ∈ ⟦𝜏1⟧E′.
By the semantics of heap types, follows

(A2) ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)
(A3) ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )

The result follows by assumption (A).

Case 𝑐0 as (𝑥 : ˆ𝜏1) → 𝜏2:

The only algorithmic typing rule that applies is T-Ascribe-Algo. By inversion, we know

(A1) Γ ⊢ 𝑐0 : (𝑥 : ˆ𝜏1) ⇝ 𝜏𝑐
(A2) Γ ⊢ 𝜏1 <: ˆ𝜏1
(A3) Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏𝑐 <: 𝜏2

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:80

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

Since emit(𝑐0 as 𝜎) = emit(𝑐0), we have to show that Γ, 𝑥 : 𝜏1 ⊢ 𝜏2 ≤ 𝑁 + emit(𝑐0). By our
initial assumption, every ascribed type is also bounded by 𝑁 . We therefore have Γ, 𝑥 : 𝜏1 ⊢
𝜏2 ≤ 𝑁 from which the result immediately follows.

□

Theorem D.6 (Decidability). If Γ, 𝜏1, 𝜏2 and every ascribed type in 𝑐 are bounded by the MTU 𝑁 ,

then Γ ⊢ 𝑐 : (𝑥 : 𝜏1) → 𝜏2 is decidable.

Proof. By Theorem C.19 (Algorithmic Typing Correctness), we can equivalently show that
2 is bounded.

2 <: 𝜏2 are decidable. By Theorem D.5, 𝜏 ′

2 and Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′

Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′
Γ, 𝑥 : 𝜏1 ⊢ 𝜏 ′

2 <: 𝜏2 is therefore decidable by finite enumeration.

To show that Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′

2 is decidable, we proceed by induction on the algorithmic

typing derivation.
Case T-Skip-Algo:

Immediate, because T-Skip-Algo does not perform any subtyping checks.

Case T-Reset-Algo:

Also immediate, because T-Reset-Algo does not perform any subtyping checks.

Case T-Seq-Algo:

By inversion of T-Seq-Algo,

(A1) Γ ⊢ 𝑐1 : (𝑥 : 𝜏1) ⇝ 𝜏12
(A2) Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22

By (A1) and Theorem D.5,
(A3) Γ, 𝑥 : 𝜏1 ⊢ 𝜏12 ≤ 𝑁 + emit(𝑐1)

Applying the IH to (A1) with assumption Γ ⊢ 𝜏1 ≤ 𝑁 and (A3) gives us that Γ ⊢ 𝑐1 : (𝑥 :
𝜏1) ⇝ 𝜏12 is decidable.
Again, by Theorem D.5 with (A2) and (A3), follows

(A4) Γ, 𝑥 : 𝜏1, 𝑦 : 𝜏12 ⊢ 𝜏22 ≤ 𝑁 + emit(𝑐1) + emit(𝑐2)

By IH follows that Γ, 𝑥 : 𝜏1 ⊢ 𝑐2 : (𝑦 : 𝜏12) ⇝ 𝜏22 is decidable and thus typechecking the
sequence of both commands is decidable.

Case T-Add-Algo:

Case T-Extract-Algo:

By inversion, we know that T-Add-Algo performs the subtyping check Γ ⊢ 𝜏1 <: {𝑥 :
⊤ | ¬𝑥 .𝜄.valid}. To show that typechecking is decidable in this case, we must show that
Γ ⊢ 𝜏1 <: {𝑥 : ⊤ | ¬𝑥 .𝜄.valid} is decidable. This is the case because we can finitely enumerate
the heaps ℎ described by 𝜏1 and check wether every ℎ is a member of {𝑥 : ⊤ | ¬𝑦.𝜄.valid}.

By inversion, we know that T-Extract-Algo performs the subtyping check Γ ⊢ 𝜏1 <: {𝑥 :
⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof (𝜄)}. To show that typechecking is decidable in this case, we must show
that Γ ⊢ 𝜏1 <: {𝑥 : ⊤ |
|𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof(𝜄)} is decidable. This is the case because we can
finitely enumerate the heaps ℎ described by 𝜏1 and check wether every ℎ is a member of
{𝑥 : ⊤ | |𝑥 .𝑝𝑘𝑡𝑖𝑛 | ≥ sizeof(𝜄)}.

Case T-Remit-Algo:

Identical to the previous subcase.

Case T-Mod-Algo:

Identical to the previous subcase.

Case T-If-Algo:

Since 𝜏1 is bounded by assumption and refining the input type does not increase the size,
{𝑦 : 𝜏1 | 𝜑 [𝑦/heap]} and {𝑦 : 𝜏1 | ¬𝜑 [𝑦/heap]} are still bounded. By Theorem D.5 then
follows that the output types of 𝑐1 and 𝑐2 are also bounded. By IH applied to 𝑐1 and 𝑐2, we

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:81

get that the algorithmic type checking applied to 𝑐1 and 𝑐2 respectively is decidable and thus
checking the conditional is decidable.

Case T-Ascribe-Algo:

By assumption, Γ, 𝜏1 and ˆ𝜏1 are bounded, so Γ ⊢ 𝜏1 <: ˆ𝜏1 is decidable by finite enumeration.
Since by assumption Γ ⊢ 𝜏1 ≤ 𝑁 , by Theorem D.5 follows that Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏𝑐 ≤ 𝑁 +emit(𝑐0). By
IH then follows that Γ ⊢ 𝑐 : (𝑥 : 𝜏1) ⇝ 𝜏 ′
2 is decidable. Since 𝜏𝑐 is bounded and by assumption
2 is also decidable and thus
also 𝜏 ′
typechecking an ascribed command is decidable.

2 is bounded, we can finitely enumerate, so Γ, 𝑥 : ˆ𝜏1 ⊢ 𝜏𝑐 <: 𝜏 ′

E REWRITE OPTIMIZATION CORRECTNESS

Definition E.1 (Type Equivalence). We write Γ ⊢ 𝜏1 (cid:17) 𝜏2 for the equivalence of types 𝜏1 and 𝜏2 in

context Γ, i.e., Γ ⊢ 𝜏1 (cid:17) 𝜏2 ≜ ∀E |= Γ.⟦𝜏1⟧E = ⟦𝜏2⟧E

Lemma E.2 (Rewriting Sigma Types). In any context Γ,

□

Γ ⊢ Σ𝑥 : 𝜏1.𝜏2
(cid:17)
(cid:18) 𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛@𝑟 .𝑝𝑘𝑡𝑖𝑛 ∧
𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 @𝑟 .𝑝𝑘𝑡𝑜𝑢𝑡

∧

(cid:19)

(cid:211)𝜄 ∈dom( H T) (cid:169)
(cid:173)
(cid:171)

𝑦.𝜄.valid = 𝑥 .𝜄.valid ⊕ 𝑟 .𝜄.valid ∧
𝑥 .𝜄.valid =⇒ 𝑦.𝜄 = 𝑥 .𝜄 ∧
𝑟 .𝜄.valid =⇒ 𝑦.𝜄 = 𝑟 .𝜄

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝑦 : ⊤






Proof. Proof each direction separately.

[𝑟 ↦→ 𝜏2] [𝑥 ↦→ 𝜏1]






(cid:170)
(cid:174)
(cid:172)

(⇒) Let E |= Γ and let ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E. By the semantics of heap types, we know there exists ℎ1

and ℎ2 such that ℎ = ℎ1 ++ ℎ2 and ℎ1 ∈ ⟦𝜏1⟧E and ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ].
By definition of heap concatenation, ℎ(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)@ℎ2(𝑝𝑘𝑡𝑖𝑛) and also ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) =
ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )@ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ). Further, dom(ℎ) is the disjoint union of dom(ℎ1) and dom(ℎ2) such
that if 𝜄 ∈ dom(ℎ𝑖 ), ℎ(𝜄) = ℎ𝑖 (𝜄) for each 𝑖 = 1, 2 and each 𝜄 ∈ dom(H T ). The result follows
by definition of the semantics.

(⇐) Let E |= Γ. By the definition of the semantics, it suffices to show, for ℎ1 ∈ ⟦𝜏1⟧E, and
ℎ2 ∈ ⟦𝜏2⟧E [𝑥↦→ℎ1 ], and ℎ ∈ ⟦⊤⟧E [𝑥↦→ℎ1,𝑟 ↦→ℎ2 ] such that the above refinement holds for ℎ, that
ℎ ∈ ⟦Σ𝑥 : 𝜏1.𝜏2⟧E. By the semantics of heap types, it suffices to show that ℎ = ℎ1 ++ ℎ2. The
refinement tells us that
• ℎ(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑖𝑛)@ℎ2(𝑝𝑘𝑡𝑖𝑛) and
• ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 )@ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ).
Further, dom(ℎ) is the disjoint union of dom(ℎ1) and dom(ℎ2) such that if 𝜄 ∈ dom(ℎ𝑖 ),
ℎ(𝜄) = ℎ𝑖 (𝜄) for each 𝑖 = 1, 2 and each 𝜄 ∈ dom(H T ).

□

Lemma E.3 (Rewriting Refinement Types). For Γ, 𝜏, 𝜄, 𝑥, 𝑦, such that 𝑥 and 𝑦 do not occur free

in 𝜏,

Γ, (𝑥 : 𝜏) ⊢ {𝑦 : 𝜏 | 𝑥 ≡ 𝑦} (cid:17) {𝑦 : ⊤ | 𝑥 ≡ 𝑦}

Proof. Prove each direction separately.

(⇒) Let E |= Γ, (𝑥 : 𝜏). We know E = E ′[𝑥 ↦→ ℎ1] such that ℎ1 ∈ ⟦𝜏⟧E′. Let ℎ2 ∈ ⟦{𝑦 : 𝜏 | 𝑥 ≡
𝑦}⟧E′ [𝑥↦→ℎ1 ]. Then ℎ2 ∈ ⟦𝜏⟧E′ [𝑥↦→ℎ1 ] and ⟦𝑥 ≡ 𝑦⟧E′ [𝑥↦→ℎ1,𝑦↦→ℎ2 ] = true. From the latter, we
can conclude that ℎ2 = ℎ1. To show ℎ2 ∈ ⟦{𝑦 : ⊤ | 𝑦 ≡ 𝑥 }⟧E′ [𝑥↦→ℎ1 ], we have to show that

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

40:82

Matthias Eichholz, Eric Hayden Campbell, Matthias Krebs, Nate Foster, and Mira Mezini

ℎ2 ∈ ⟦⊤⟧E′ [𝑥↦→ℎ1 ], which is immediate, and ⟦𝑥 ≡ 𝑦⟧E′ [𝑥↦→ℎ1,𝑦↦→ℎ2 ] = true, which immediately
follows by the fact that ℎ2 = ℎ1.

(⇐) Let E |= Γ, (𝑥 : 𝜏). We know E = E ′[𝑥 ↦→ ℎ1] such that ℎ1 ∈ ⟦𝜏⟧E′. Let ℎ2 ∈ ⟦{𝑦 : ⊤ | 𝑥 ≡
𝑦}⟧E′ [𝑥↦→ℎ1 ]. Then ℎ2 ∈ ⟦⊤⟧E′ [𝑥↦→ℎ1 ], and ⟦𝑥 ≡ 𝑦⟧E [𝑥↦→ℎ1,𝑦↦→ℎ2 ] = true. Observe that ℎ1 = ℎ2.
To show that ℎ2 ∈ ⟦{𝑦 : 𝜏 | 𝑦 ≡ 𝑥 }⟧E′ [𝑥↦→ℎ1 ], we must show that ℎ2 ∈ ⟦𝜏⟧E′ [𝑥↦→ℎ1 ] and
⟦𝑥 ≡ 𝑦⟧E [𝑥↦→ℎ1,𝑦↦→ℎ2 ] = true. The first follows by assumption that ℎ1 ∈ ⟦𝜏⟧E′ and the fact
that ℎ2 = ℎ1. The second immediately follows from ℎ2 = ℎ1.

□

Lemma E.4. For all Γ, 𝑥, 𝜏 and 𝜄, if Γ ⊢ sizeof𝑝𝑘𝑡𝑖𝑛 (𝜏) ≥ sizeof(𝜄) and 𝑥 does not occur free in 𝜏,

then

Σ𝑦 :

(cid:26)
𝑧 : 𝜄

(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝑧.𝑝𝑘𝑡𝑖𝑛 = ⟨⟩ ∧
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩

(cid:27)

.

Γ, 𝑥 : 𝜏 ⊢

𝑧 : chomp(𝜏, 𝜄, 𝑦)





(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧
𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥





(cid:17)
𝑦.𝜄.valid ∧ (cid:211)𝜅 ∈dom( H T)∧𝜅≠𝜄 𝑦.𝜅 = 𝑥 .𝜅 ∧
𝑦.𝜄@𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧

(cid:27)

(cid:26)
𝑦 : ⊤

(cid:12)
(cid:12)
(cid:12)
(cid:12)

[Rewrite Sigma Extract]

Proof. Proof each direction separately.
(⇒) Let E |= Γ, 𝑥 : 𝜏. We know E = E ′[𝑥 ↦→ ℎ] such that ℎ ∈ ⟦𝜏⟧E′. Let ℎΣ ∈ ⟦Σ𝑦 : {𝑧 : 𝜄 |
𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧
𝑧 ≡𝜄 𝑥 }⟧E′ [𝑥↦→ℎ] be arbitrary. By the semantics of heap types follows

(A1) ℎΣ = ℎ1 ++ ℎ2
(A2) ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E′ [𝑥↦→ℎ]
(A3) ℎ2 ∈ ⟦{𝑧 : chomp(𝜏, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧𝑧 ≡𝜄 𝑥 }⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1 ]
(A4) ℎ2 ∈ ⟦chomp(𝜏, 𝜄, 𝑦)⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1 ]
(A5) ⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1,𝑧↦→ℎ2 ] = true

By Lemma B.23, there exists ˆℎ2 ∈ ⟦𝜏⟧E′ [𝑥↦→ℎ] such that

(A6) ℎ2 = chomp⇓( ˆℎ2, sizeof (𝜄))

Together with (A5), we can conclude that

(A7) ˆℎ2 (𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )
(A8) ˆℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ(𝑝𝑘𝑡𝑖𝑛) [sizeof (𝜄) :]
(A9) ∀𝜅 ≠ 𝜄. ˆℎ2(𝜅) = ℎ(𝜅)
(A10) 𝜄 ∉ dom( ˆℎ2)

ℎΣ ∈ ⟦{𝑦 : ⊤ | 𝑦.𝜄.valid ∧ (cid:211)𝜅 ∈dom( H T)∧𝜅≠𝜄 𝑦.𝜅 = 𝑥 .𝜅 ∧ 𝑦.𝜄@𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 =
𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }⟧E follows by the semantics of heap types with (A1), (A6), (A7), (A8), (A9) and (A10).
(⇐) Let E |= Γ, 𝑥 : 𝜏. We know E = E ′[𝑥 ↦→ ℎ] such that ℎ ∈ ⟦𝜏⟧E′. Let ˆℎ ∈ ⟦{𝑦 : ⊤ |
𝑦.𝜄.valid ∧(cid:211)𝜅 ∈dom( H T)∧𝜅≠𝜄 𝑦.𝜅 = 𝑥 .𝜅 ∧𝑦.𝜄@𝑦.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧𝑦.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 }⟧E′ [𝑥↦→ℎ]
By the semantics of heap types,

(A1) ˆℎ(𝜄) = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof(𝜄)]
(A2) ∀𝜅 ≠ 𝜄. ˆℎ(𝜅) = ℎ(𝜅)
(A3) ˆℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 )
(A4) ˆℎ(𝜄)@ ˆℎ(𝑝𝑘𝑡𝑖𝑛) = ℎ(𝑝𝑘𝑡𝑖𝑛) ⇔ ˆℎ(𝑝𝑘𝑡𝑖𝑛) = ℎ(𝑝𝑘𝑡𝑖𝑛) [sizeof(𝜄) :]

To show that ˆℎ ∈ ⟦Σ𝑦 : {𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}.{𝑧 : chomp(𝜏, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 =
𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E′ [𝑥↦→ℎ], we have to show that there exists ℎ1 and

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

Dependently-Typed Data Plane Programming

40:83

ℎ2 such that ˆℎ = ℎ1 ++ ℎ2 and ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E′ [𝑥↦→ℎ] and ℎ2 ∈ ⟦{𝑧 :
chomp(𝜏, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1 ].
Let ℎ1(𝑝𝑘𝑡𝑖𝑛) = ℎ1(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ⟨⟩ and ℎ1(𝜄) = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof (𝜄)] and no other instances be
valid in heap ℎ1.
ℎ1 ∈ ⟦{𝑧 : 𝜄 | 𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = ⟨⟩}⟧E′ [𝑥↦→ℎ] then follows by the semantics of heap types. By
Lemma B.20, there exists ℎ2 ∈ ⟦chomp(𝜏, 𝜄, 𝑦)⟧E′ [𝑦↦→ℎ1 ] such that ℎ2 = chomp⇓(ℎ, sizeof(𝜄)).
Since 𝑥 not free in 𝜏, it also holds that ℎ2 ∈ ⟦chomp(𝜏, 𝜄, 𝑦)⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1 ].
Since ℎ1(𝜄)@ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ(𝑝𝑘𝑡𝑖𝑛), ℎ2(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) and since chomp does not change
already valid header instances also for all 𝜅 ≠ 𝜄, ℎ2(𝜅) = ℎ(𝜅), we can conclude that
⟦𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧𝑧 ≡𝜄 𝑥⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1,𝑧↦→ℎ2 ] = true and thus ℎ2 ∈
⟦{𝑧 : chomp(𝜏, 𝜄, 𝑦) | 𝑦.𝜄@𝑧.𝑝𝑘𝑡𝑖𝑛 = 𝑥 .𝑝𝑘𝑡𝑖𝑛 ∧ 𝑧.𝑝𝑘𝑡𝑜𝑢𝑡 = 𝑥 .𝑝𝑘𝑡𝑜𝑢𝑡 ∧ 𝑧 ≡𝜄 𝑥 }⟧E′ [𝑥↦→ℎ,𝑦↦→ℎ1 ].
By the semantics of heap types, we can further conclude that

(A5) (ℎ1 ++ ℎ2)(𝑝𝑘𝑡𝑖𝑛) = ℎ2(𝑝𝑘𝑡𝑖𝑛) = ℎ′(𝑝𝑘𝑡𝑖𝑛)
(A6) (ℎ1 ++ ℎ2)(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ(𝑝𝑘𝑡𝑜𝑢𝑡 ) = ℎ′(𝑝𝑘𝑡𝑜𝑢𝑡 )
(A7) (ℎ1 ++ ℎ2)(𝜄) = ℎ(𝑝𝑘𝑡𝑖𝑛) [0 : sizeof (𝜄)] = ℎ′(𝜄)
(A8) ∀𝜅 ≠ 𝜄.(ℎ1 ++ ℎ2)(𝜅) = ℎ2(𝜅) = ℎ(𝜅) = ℎ′(𝜅)

This show that actually ℎ′ = ℎ1 ++ ℎ2 and concludes this case.

□

Proc. ACM Program. Lang., Vol. 6, No. POPL, Article 40. Publication date: January 2022.

