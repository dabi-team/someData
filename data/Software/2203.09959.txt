How Do Programmers Express High-Level
Concepts using Primitive Data Types?

1st Yusuke Shinyama
dept. name of organization (of Aff.)
Tokyo Institute of Technology
Meguro-ku, Tokyo, Japan
euske@sde.cs.titech.ac.jp

2nd Yoshitaka Arahori
dept. name of organization (of Aff.)
Tokyo Institute of Technology
Meguro-ku, Tokyo, Japan
arahori@c.titech.ac.jp

3rd Katsuhiko Gondow
dept. name of organization (of Aff.)
Tokyo Institute of Technology
Meguro-ku, Tokyo, Japan
gondow@cs.titech.ac.jp

2
2
0
2

r
a

M
8
1

]
E
S
.
s
c
[

1
v
9
5
9
9
0
.
3
0
2
2
:
v
i
X
r
a

Abstract—We investigated how programmers express high-
level concepts such as path names and coordinates using primitive
data types. While relying too much on primitive data types is
sometimes criticized as a bad smell, it is still a common practice
among programmers. We propose a novel way to accurately
identify expressions for certain predeﬁned concepts by examining
API calls. We deﬁned twelve conceptual types used in the Java
Standard API. We then obtained expressions for each conceptual
type from 26 open source projects. Based on the expressions
obtained, we trained a decision tree-based classiﬁer. It achieved
83% F-score for correctly predicting the conceptual type for a
given expression. Our result indicates that it is possible to infer a
conceptual type from a source code reasonably well once enough
examples are given. The obtained classiﬁer can be used for
potential bug detection, test case generation and documentation.

Index Terms—Program comprehension, Software maintenance,

Source code analysis, Dataﬂow analysis, Conceptual types

I. INTRODUCTION
Today, the beneﬁts of type system in programming lan-
guages are well understood. Since a well-deﬁned type sys-
tem can prevent a programmer from doing certain invalid
operations, it helps a programmer to achieve the correctness
and safety. In a statically typed language, proper typing also
helps maintenance as it indicates the programmer’s intention.
However, deﬁning a domain-speciﬁc type system for every
concept
in a program is cumbersome. At some point, a
programmer has to rely on a more primitive data type that
is closer to the runtime environment.

a) Program with “primitive obsession”:

String username = getCurrentUserName();
String path = "/home/"+username+"/user.cfg";
// Unsafe path: extra check is needed!
File config = new File(path);

b) Equivalent well-typed program:

User user = getCurrentUser();
Path path = Paths.get(

user.getHomeDirectory(), "user.cfg");

// Path is guaranteed to be safe.
File config = new File(path);

Fig. 1. Primitive obsession (Java)

In fact, programmers tend to use a lot of primitive data
types for a variety of purposes. In particular, string and

integer are among most commonly used data types in modern
programming languages. A string variable, for example, can
be used for storing any text content, such as user name,
address and phone number. Strings are so versatile that some
programming languages only support the string data type [1].
An integer is also versatile in that it can be used for a size,
counter, index, ﬂag or other enumerable constants.

While using these primitive data types is often beneﬁcial
to programmers, this tendency is sometimes accused as prim-
itive obsession [2] (Fig. 1), as it obscures the programmers’
intention and poses a threat to its safety and maintainability.
One of the major beneﬁts of using a well-deﬁned abstract type
system is its ability to check the correctness of its operations.
Relying on primitive data types means that programmers
are bypassing some of the necessary checks, resulting an
unreliable or undeﬁned behavior of a program. For example, in
most operating systems, an arbitrary string cannot be used as a
ﬁle name because a ﬁle name cannot contain certain characters
(such as “/”).

While primitive obsession is known to be risky, program-
mers often rely on appropriate variable names and source code
comments in attempt to reduce its risk by reminding them-
selves its intended uses and the domain speciﬁc constraints.
It is known that programmers heavily rely on meaningful
identiﬁer names (type/class names, function/method names
and variable/ﬁeld names) to encode their intention [3].

We are interested in how programmers indicate the existence
of domain speciﬁc values in source code. In this paper, we
propose a novel way to identify the expressions for several
predeﬁned concepts such as a path name or calendar year. We
applied our method to 26 well-known open source projects
and extracted the common expressions for each concept. We
then attempted to interpret the obtained results by developing
a decision tree-based classiﬁer that infers the type of concepts
from a given expression. Our result indicates that there is a
widely used convention to express certain conceptual types
in source code. The potential applications of our technique
test case generation and
include additional
documentation. In the example illustrated in Fig. 1, one can
insert an extra check to ensure the path is correct, knowing
the path String variable indeed speciﬁes a ﬁle system path.

type checking,

 
 
 
 
 
 
A. Contribution of This Paper

In this paper, we attempted to answer the following research

questions:
RQ.1) What kinds of high-level concepts do programmers

commonly use in software projects?

RQ.2) How do programmers express such concepts in source

code?

RQ.3) Is it possible to accurately predict such concepts from

the source code appearance?

In the rest of this paper, we ﬁrst deﬁne the concept of
“conceptual types (c-types)” in Section III-A. We then describe
how to extract conceptual types from source code in Section
III-B. Section IV presents the experiment setup for obtaining
conceptual type expressions and its results. In Section V, we
analyzed the obtained expressions for each conceptual type
by constructing a decision tree-based classiﬁer. Finally, we
discuss our ﬁndings and the threats to its validity in Section
VI. The related work is described in Section II.

II. RELATED WORK

Identifying conceptual (abstract) types used in software
has been an active research topic in the ﬁeld of program
comprehension and software maintenance. O’Callahan et al.
[4] performed type inference of a given program using static
data ﬂow analysis and static point-to analysis. Their notion of
a type is solely based on data ﬂow and close to an equivalence
class, in that two values can have the same type if their
values can be stored into the same memory location. Guo et
al. [5] took a similar approach using dynamic analysis. They
also used the data ﬂow of a program as a main source of
abstract type identiﬁcation. Since their method does not rely
on source code, their technique could be also applied to a
binary program. This line of research was further extended
by Dash et al. [6]. They combined the lexical information
of a program (variable names) with its data ﬂow, forming
the notion of “name ﬂow” that was used for clustering and
discovering abstract types. They also provided a facility to
rewrite a program in such a way that discovered types can be
automatically annotated. While it is not type inference per se,
invariant detection techniques [7] can also be used for type
identiﬁcation, as it can discern different constraints (hence
different use cases) that each variable has.

The above approaches all aimed to discover user-deﬁned
types and constraints. One of the difﬁculties in these problem
formulations is that they are all somewhat subjective; there
are a number of ways to design abstract types for a particular
application. The above three approaches all used some sort of
clustering technique and let the abstract types “emerge” from
a program. However, it is often hard to tell if the obtained
clustering was optimal for its user, as different programs have
slightly different requirements for its design. Our approach is
different in that our conceptual types are already well-deﬁned
by the API speciﬁcation and used by many applications. While
it is not directly competing with the above three, our technique
can be used as a foundation of more advanced analysis.

Our approach is also related to the studies about program
identiﬁers. The importance of names in a program code has
been emphasized by many researchers and practitioners [8],
[9]. Programmers generally prefer a long descriptive name
than single-letter variables [10]. Poor naming can lead to
misunderstanding or confusion among programmers, which
eventually result in poor code quality [11]. In some software
projects, inconsistent naming is actually considered as bugs
(naming bugs [12]). Alon et al. converted source code into
word embeddings [13] that correspond to a certain word in
natural language [14], which can be used for identiﬁers.

In numerical or business applications,

there are similar
concepts to conceptual types that are called “dimensions”.
Dimensions are typically used for expressing physical units.
Jiang et al. proposed a way to add manual annotation of
physical units to C programs and verify their conversion to
different dimensions using predeﬁned rules [15]. Hangal et al.
used a source code revision history to check if the dimensions
of each variable is consistent throughout the development [16].

III. METHODOLOGY

A. What is Conceptual Type?

Our basic idea is to use API speciﬁcations for capturing
domain speciﬁc values. Well-designed API speciﬁcations usu-
ally provide a clear deﬁnition of its inputs and outputs to each
function. Since programmers typically treat API functions as a
black box, they need to be aware of the function parameters.
More speciﬁcally, they need a precise understanding of the
type of data that is being passed and how they are going to
be used. Consider the following Java example:

String x = "foo/bar.txt";
var f = new java.io.File(x);

// x is a path name.

In

of

the

above

snippet,

argument

the ﬁrst

the
java.io.File constructor is supposed to be of String
type, according to the Java API speciﬁcation. However,
the programmer has to be aware that it has a more strict
requirement than just a string because it has to be a path
the programmer is responsible to make
name. Therefore,
sure that the value of x is not just a string but it meets the
requirements of a valid path name (such as not containing
invalid characters). In this sense, the ﬁrst argument of the
File constructor requires a more speciﬁc data type than
ones that are provided by the programming language.

Conceptually, API entry points presents a clear boundary
that translates primitive data types such as string to a more
to data types provided by a
speciﬁc domain. In contrast
programming language, we call these data types a “conceptual
type” (or “c-type” in short).

We identiﬁed c-types that frequently appear in the Java
Standard API [17]. The principles we used in choosing these
c-types are the following:

1) It has a clearly deﬁned concept that is well understood

by most programmers.

2) It is distinct enough that people do not mix up with other

concepts.

3) It is widely used in a variety of applications.
Table I lists the 12 c-types we chose. The domain of these
c-types can be divided into four different sections: ﬁle I/O,
networking, GUI (Java AWT) and date/time handling. These
domains are general enough that can be used in a variety of
software projects.

Note that XCOORD (X coordinate) and YCOORD (Y
coordinate) are treated as a separate type, as well as WIDTH
and HEIGHT. These types could be merged into one, as they
all represent a distance or length in a graphical device. How-
ever, programmers rarely treat these values interchangeably1.
Following the above principle 1, we consider them different
c-types.

After choosing the c-types, we identiﬁed the methods that
take one or more of the deﬁned types as arguments. Table
II and Fig. 2 show the number of the method arguments
selected and the excerpt of these methods, respectively. In
total, we selected 218 methods including overlaps. Note that
some methods take multiple c-types as its arguments at once
(such as WIDTH and HEIGHT).

TABLE I
CONCEPTUAL TYPES (C-TYPES)

C-Type
PATH
URL
SQL
HOST
PORT
XCOORD
YCOORD
WIDTH
HEIGHT
YEAR
MONTH
DAY

Actual Type
String
String
String
String
int
int
int
int
int
int
int
int

Description
Path name
URL/URI
SQL statement
Host name
Port number
X coordinate (for GUI)
Y coordinate (for GUI)
Width (for GUI)
Height (for GUI)
Year
Month
Day of month

TABLE II
NUMBER OF METHODS FOR EACH C-TYPE

C-Type
PATH
URL
SQL
HOST
PORT
XCOORD
YCOORD
WIDTH
HEIGHT
YEAR
MONTH
DAY
Total

# Methods
14
4
10
17
25
25
25
24
24
18
14
18
218

1While expressions like Point(x, x) or x+width*2 might be used in
some programs, we can hardly imagine a GUI program where operations like
x+y or Point(y, x) are meaningful.

• new java.io.File(PATH)
• new java.net.URI(URL)
• java.sql.Statement.execute(SQL)
• java.net.InetAddress.getByName(HOST)
• new java.net.Socket(HOST, PORT)
• new java.awt.Point(XCOORD, YCOORD)
• new java.awt.Dimension(WIDTH, HEIGHT)
• new java.util.Date(YEAR, MONTH, DAY)
• java.util.Date.setYear(YEAR)
• java.time.LocalDate.of(YEAR, MONTH, DAY)
• ...

Fig. 2. Excerpt of Methods used for Identifying C-Types

B. Extracting Conceptual Type Expressions

With the list of methods that deﬁne c-types, we scan
the source code and identify all the calls for the selected
methods or constructors. Each method call has one or more
arguments that specify a predeﬁned c-type. We then extract
the expressions for each argument as a c-type expression.

In this paper, we use Java as our target language. First, we
identify all the methods (including overloaded methods) and
assign a unique identiﬁer to each. We keep a list of method
identiﬁers (the names and signatures) that we selected and
check if each method call can match those identiﬁers.

In a case of virtual method call (dynamic dispatching),
there are multiple method implementations that has the same
signature. Note that we are only interested in the arguments
of each method call; we do not need to know which method is
actually invoked. When a method call can potentially invoke
multiple implementations, we collect its arguments if one of
its possible destinations is deﬁned in our method list.

C. Implementation

We implemented a static analyzer for Java source code. The

analyzer takes the following steps for the given set of ﬁles:

1) Parse all the source codes. We used Eclipse JDT [18] for

the Java parser.

2) Enumerate all the classes and name spaces deﬁned in the
target source code. We maintain a hierarchical symbol
table for registering Java packages.

3) Process import statements in each ﬁle to resolve the

references to external classes.

4) Scan all

the method signatures and assign a unique
identiﬁer to each method. For example, a method which
has a signature:

package foo.bar;
class Config {

int findString(String s[], int i)

}

can be encoded as a unique identiﬁer:

foo.bar.Config.findString([LString;I)I

5) In addition to source codes, compiled Java class ﬁles and
jar ﬁles are also scanned and its method signatures are
collected.

6) Construct a symbol table that includes all the variables
and ﬁeld names deﬁned in each method. The symbol table

has mappings from a variable (ﬁeld) name to its data type.
The symbol table is used for method resolution in the next
step.

7) For every method or constructor call, ﬁnd the most

precise method that matches the calling signature.

8) If the callee method is one of the selected methods (i.e. its
method identiﬁer is in our list), extract the corresponding
arguments that specify one of the predeﬁned c-types.

Note that Step 3 above typically requires complete type
information for imported classes. In our case, however, since
we only need to identify the calls of the methods that we
selected, not all the references need to be resolved. Since
all the methods we chose are included in the Java Standard
API, we simply ignored unresolved method calls. This allows
us to process a variety of Java projects without needing its
dependencies.

IV. EXPERIMENTS

We extracted c-type expressions from 26 open source
projects. First we listed top 1,000 Java projects in the number
of stars in GitHub. We then performed string search through
their source code and selected ones that uses one or more of
the Java APIs listed in Table II. We chose projects of a variety
of sizes. The size of each project ranges from 1.8mLoC to
3kLoC. Table III shows the projects and their sizes.

We used a standard PC (Intel Xeon 2.2GHz, 40 core,
64G bytes memory, running Arch Linux) for running our
experiment. Extracting method calls and c-type expressions
for the all 26 projects took less than 2 hours in total.

TABLE III
PROJECTS AND SIZES (LOC WAS COUNTED WITH [19])

Project
hadoop 3.3.1
ghidra 10.0
ignite 2.10.0
jetty 11.0.5
kafka 2.7.1
tomcat 8.5.68
jitsi 2.10
binnavi 6.1.0
netty 4.1.65
libgdx 1.10.0
alluxio 2.5.0-3
plantuml 1.2021.7
grpc 1.38.1
jenkins 2.299
jmeter 5.4.1
jedit 5.6.0
gephi 0.9.2
zookeeper 3.7.0
selenium 3.141.59
okhttp 4.9.1
jhotdraw 7.0.6
arduino 1.8.15
gson 2.8.7
websocket 1.5.2
picasso 2.8
jpacman
Total

Description
distributed computation
binary analyzer
distributed database
web container
stream processing
web server
video conference
binary analyzer
network library
game framework
data orchestration
UML generator
RPC framework
automation
network analyzer
text editor
graph visualizer
distributed computation
browser automation
HTTP client
graph drawing
development environment
serialization framework
network framework
image processing
action game

LoC
1,789k
1,588k
1,165k
441k
384k
349k
327k
309k
303k
272k
228k
210k
195k
177k
145k
125k
120k
114k
91k
36k
32k
27k
25k
15k
9k
3k
8,480k

Table IV shows the number of extracted c-type expressions
for each project. The “OTHER” column shows not an actual
the number of expressions that are passed in
c-type, but
arguments that does not specify any predeﬁned c-type. For
example, some API method takes a path name and an extra
boolean ﬂag as arguments. Since this extra argument does not
specify any predeﬁned c-type, we count them as OTHER. The
OTHER expressions are later used for training the decision tree
algorithm and measuring its performance2.

We collected frequently used expressions in each project.
Table V shows the most frequent expressions for four c-
types (PATH, URL, XCOORD and WIDTH) in each project.
Constant expressions such as "localhost" are excluded.
While shorter and more common expressions are relatively
straightforward, a long expression with multiple operators can
be complex for programmers. Table VI shows the length of
expressions for each c-type, in the number of components
included in each expression3. Table VII shows compound
expressions that include binary operators (such as + or *).

We also obtained frequently used words for each c-type by
using the word segmentation algorithm shown in Section V-B.
The results are shown in Table VIII.

V. INFERRING C-TYPES BY EXPRESSIONS
In this section, we describe our attempt to develop a decision
tree-based classiﬁer that predicts the c-type from a given
expression. Since the expressions obtained for each c-type
contain several words that are commonly used across many
projects, we expected that we could construct a relatively
straightforward model (if any) to infer the c-type of a given
expression.

A decision tree is a relatively simple machine learning
model that is equivalent to a sequence of if-then statements.
It is efﬁcient and suitable for handling discrete values such as
symbols or words. One of the major advantages of a decision
tree is that it is human readable. We used a ID3 algorithm
[20] to construct a decision tree.

In the rest of this section, we ﬁrst describe how to de-
compose an expression to a set of features used for inferring
conceptual types. Our classiﬁer uses both lexical and data
ﬂow-centric information of an expression. Then we describe
a word segmentation algorithm used in feature extraction. A
word segmentation is needed to split identiﬁers that are made
up with multiple words (such as getPath). We then show
its predictive performance and an excerpt of obtained rules.

A. Converting Expression into Features

In this experiment, a c-type is speciﬁed by an argument in a
method call. Each argument is a Java expression that consists
of the following terms: Variable (ﬁeld) accesses, method calls
and constants. To use a decision tree classiﬁer, the syntax tree
of each expression needs to be converted as discrete features.

2In theory, all the arguments of all the method calls that we are not
interested in should be counted as the OTHER type. For practical reasons,
however, we ignored method calls that clearly have nothing to do with c-types.
3Note that ﬁeld access (a.b) and method call (a.b()) are considered as

two components instead of one.

Project
alluxio
arduino
binnavi
gephi
ghidra
grpc
gson
hadoop
ignite
jedit
jenkins
jetty
jhotdraw
jitsi
jmeter
jpacman
kafka
libgdx
netty
okhttp
picasso
plantuml
selenium
tomcat
websocket
zookeeper
Total

LoC
228k
27k
309k
120k
1,588k
195k
25k
1,789k
1,165k
125k
117k
441k
32k
327k
145k
3k
384k
272k
303k
36k
9k
210k
91k
349k
15k
114k
8,480k

PATH
72
39
42
5
369
33
0
978
168
130
82
72
6
22
112
0
37
83
38
2
1
29
44
207
9
88
2,668

URL
12
5
7
0
25
16
4
634
85
19
28
216
5
18
62
0
1
7
24
24
0
4
66
64
44
4
1,374

TABLE IV
EXTRACTED C-TYPE EXPRESSIONS BY PROJECT

SQL
0
0
1
2
0
0
0
9
666
0
0
9
0
1
2
0
0
0
0
0
0
0
0
22
0
0
712

HOST
22
12
2
0
10
68
2
288
106
3
6
163
1
8
31
0
85
4
54
6
0
5
15
38
5
126
1,060

PORT
26
9
1
0
8
71
0
259
111
3
6
104
1
31
28
0
72
5
130
7
0
11
12
52
43
192
1,182

XCOORD
0
6
23
28
320
0
0
0
0
50
1
0
96
78
7
0
0
7
0
0
0
4
1
0
0
0
621

YCOORD
0
6
23
28
320
0
0
0
0
50
1
0
96
78
7
0
0
7
0
0
0
4
1
0
0
0
621

WIDTH
0
42
67
66
511
0
0
0
0
112
1
0
50
234
62
1
0
36
0
0
0
11
0
10
1
1
1,205

HEIGHT
0
42
67
66
511
0
0
0
0
112
1
0
50
234
62
1
0
36
0
0
0
11
0
10
1
1
1,205

YEAR
15
0
1
0
13
0
6
2
12
0
102
0
0
0
0
0
14
0
1
0
0
2
1
0
0
0
169

MONTH
15
0
0
0
13
0
6
2
12
0
102
0
0
0
0
0
14
0
1
0
0
2
1
0
0
0
168

DAY
15
0
0
0
13
0
6
2
12
0
102
0
0
0
0
0
14
0
1
0
0
2
1
0
0
0
168

OTHER
51
1
1
0
13
75
7
124
101
3
237
37
1
30
28
0
44
0
117
3
0
2
21
47
1
47
991

All
228
162
235
195
2,126
263
31
2,298
1,273
482
669
601
306
734
401
2
281
185
366
42
1
87
163
450
104
459
12,144

Our basic idea is to focus on each identiﬁer in an expression
in the order of signiﬁcance. When an expression consists of
only one variable reference (such as path), we call
this
variable a primary identiﬁer. When an expression consists of
two references where one variable belongs to another (such
as a.b), we choose the most signiﬁcant reference (b) as a
primary identiﬁer as the other (a) as a secondary identiﬁer.
This strategy can be formalized by using the idea of data
dependency graph (data ﬂow graph) which has been commonly
used in compiler optimization [21].

We ﬁrst construct the data dependency graph of an expres-
sion by traversing each term in its syntax tree. For each term in
the (sub-) expression, the rules shown in Table IX are applied
recursively. The obtained graph forms a lattice structure whose
node is either a variable access, method call, constant, or
one of Java operators. We then traverse the dependency graph
from the top and extract features at each node. Operator and
constant nodes are skipped. The most signiﬁcant node that
is close to the top is marked as a primary identiﬁer, and the
second degree ones are marked as secondary identiﬁers, and so
on. As we move away from the top node in the dependency
graph, we obtain ternary or fourth-degree identiﬁers. Fig. 3
illustrates the primary and secondary identiﬁers that appears
in a method call new File(config.getPath(i)); The
primary identiﬁer of this expression is getPath( ). The
secondary identiﬁer is config and i.

Note that the chain of data dependency becomes longer as
we obtain a broader range of a dependency tree, i.e. the value
represented at each node has a more indirect inﬂuence to the
entire expression. For the sake of simplicity, we discard fourth-

degree or further identiﬁers.

Fig. 3. Dependency Graph of “new File(config.getPath(i))” and
Its Primary and Secondary Identiﬁers

B. Word Segmentation

To give the prediction model more ﬂexibility, we treat
identiﬁers not as a single feature but a set of features based
on its tokens. For example, “getConfigPath” is segmented
into three distinct tokens: “get”, “config” and “path”.
Other than tokenization,
the classiﬁer does not have any
prior knowledge about the natural language used in program
identiﬁers.

We used a simple regex-based word tokenizer. For a
given string, we search a longest substring that matches with
([A-Z][a-z]+|[A-Z]+) pattern. We chunk each matched
substring as individual tokens. Since the extent of each match
is limited to consecutive alphabets, both “getConfigPath”
and “get_config_path” can be segmented to the same
tokens. Each tokens is normalized to lower case letters.

new File()configigetPath()Secondary identifiersPrimary identifierTABLE V
TOP EXPRESSIONS FOR PATH, URL, XCOORD AND WIDTH C-TYPES
(CONSTANTS EXCLUDED)

PATH
alluxio
arduino
binnavi
gephi
ghidra
grpc
hadoop
ignite
jedit
jenkins
jetty
jhotdraw
jitsi
jmeter
kafka
libgdx
netty
plantuml
selenium
tomcat
zookeeper
URL
alluxio
arduino
binnavi
ghidra
grpc
gson
hadoop
ignite
jedit
jenkins
jetty
jitsi
jmeter
kafka
libgdx
netty
selenium
tomcat
websocket
zookeeper
XCOORD
arduino
binnavi
gephi
ghidra
jedit
jhotdraw
jitsi
jmeter
libgdx
plantuml
WIDTH
arduino
binnavi
gephi
ghidra
jedit
jhotdraw
jitsi
jmeter
libgdx
plantuml
tomcat

Top Expressions
path, mLocalUfsPath+ufsBase, base
path, PreferencesData.get("runtime.ide.path")
filename, directory, pathname
System.getProperty("netbeans.user")
getTestDirectoryPath(), path, filename
uri.getPath()
GenericTestUtils.getRandomizedTempPath()
path, U.defaultWorkDirectory(), fileName
path, dir, directory
System.getProperty("user.home"), war
file.getParent()
prefs.get("projectFile", home)
path, localPath
filename, path, file
storeDirectoryPath, argument
name, sourcePath, imagePath.replace(’\\’,’/’)
getClass().getResource("test.crt").getFile()
filename, newName
System.getProperty("java.io.tmpdir"), logName
pathname, path, docBase
path, KerberosTestUtils.getKeytabFile()
Top Expressions
journalDirectory, folder, inputDir
contribution.getUrl(), packageIndexURLString
url, urlString
ref, getAbsolutePath(), url.toExternalForm()
target, TARGET, oobTarget
nextString, urlValue, uriValue
uri, url, s
GridTestProperties.getProperty("p2p.uri.cls")
path, str, fileIcon
url, site.getData().core.url, plugin.url
uri, inputUrl.toString(), s
url, imagePath, sourceString
url, LOCAL_HOST, requestPath
config.getString(METRICS_URL_CONFIG)
url, URI, httpRequest.getUrl()+queryString
URL, request.uri(), server
url, baseUrl, (String)raw.get("uri")
url, location, path
uriField.getText(), uriinput.getText()
urlStr
Top Expressions
noLeft, cancelLeft
x, m_x
currentMouseX, x, bounds.x
x, center.x+deltaX, filterPanelBounds.x
x, event.getX(), leftButtonWidth+leftWidth
evt.getX(), x, e.getX()
x, button.getX(), dx
graphPanel.getLocation().x, cellRect.x, x
upButtonX, getWidth()-buttonSize.width-5, x
e.getX()
Top Expressions
width, imageW, Preferences.BUTTON_WIDTH
COLORPANEL_WIDTH, TEXTFIELD_WIDTH, width
w, constraintWidth, DEPTH
width, center.width, filterPanelBounds.width
width, buttonSize.width, colWidth
frameWidth, r.width, bounds.width
MAX_MSG_PANE_WIDTH, WIDTH, width
graphPanel.width
width, buttonSize.width
newWidth
WIDTH

TABLE VI
EXPRESSION LENGTH (NUMBER OF COMPONENTS)

C-Type
PATH
URL
SQL
HOST
PORT
XCOORD
YCOORD
WIDTH
HEIGHT
YEAR
MONTH
DAY

n = 4
6.3%

n = 5
n = 3
n = 1
n = 2
49.6% 22.8%
4.8%
7.0%
31.6% 18.5% 13.7% 13.5% 10.2%
4.4%
8.7%
47.5% 12.1%
3.1%
2.0%
3.0% 22.1%
59.2% 11.5%
0.3%
1.2%
2.1%
68.4% 27.5%
1.6%
6.4%
54.1% 24.6%
9.8%
2.6%
9.0%
52.5% 22.4% 10.1%
1.5%
2.5%
6.3%
71.0% 15.2%
1.5%
3.1%
6.4%
71.4% 15.4%
0.0%
0.0%
1.2%
2.4%
96.4%
0.0%
0.0%
0.6%
79.8% 19.6%
0.0%
0.0%
0.6%
0.0%
99.4%

n ≥ 7
n = 6
7.3%
2.2%
5.8%
6.8%
5.5% 18.8%
2.1%
0.1%
0.0%
0.4%
1.3%
2.1%
1.4%
1.9%
1.7%
1.8%
1.0%
1.3%
0.0%
0.0%
0.0%
0.0%
0.0%
0.0%

C. ID3 Algorithm

ID3 is a recursive algorithm that produces an optimal deci-
sion tree in terms of its total entropy. Our ID3 implementation
is fairly straightforward. The way that the decision tree learner
works is following: it scans all the input instances and searches
a test that split the given instances the best. This means that
a split with the minimal average entropy is chosen (Fig. 4).
The average entropy of a split S is calculated as:

Havg (S) = −

(cid:88)

si∈S

si
|S|

log

si
|S|

where si is the number of equivalent items in the set. The
overall procedure of ID3 is shown in Fig. 5.

The algorithm starts with the most signiﬁcant test, and then
repeatedly splits the subtrees until it meets a certain predeﬁned
cutoff criteria; an important test tends to appear at the top of
the tree, and as it descends to its branches a less signiﬁcant
test appears. In general, setting the cutoff threshold too small
causes a tree over-ﬁtting problem, while setting it too large
makes it under-ﬁtting. In our experiment, we found that setting
the minimum threshold to 10 instances produced the best
results. The more detailed mechanism is described in [20].

Once the decision tree is built,

it can be treated as a
sequence of if-then clauses. The classiﬁcation process begins
with the top node of the tree; it performs a test at each branch
and decides the corresponding branch to descend. Each branch
also has an associated value (prediction). When it reaches at
a leaf or there is no corresponding branch, the process stops
and the value associated with the current branch is returned.
Table X shows the list of ID3 features we used. The test at
each branch checks if a certain word is included in one of the
features. Fig. 6 shows an excerpt of the obtained rules.

Fig. 4. Splitting Tree with Minimal Average Entropy

Entropy = 1.0Entropy =(7×0.86 + 5×0.72) ÷ 12TABLE VII
COMPOUND EXPRESSIONS WITH OPERATORS

C-Type
PATH

URL

XCOORD

WIDTH

Expressions
mLocalUfsPath + ufsBase
selectedFile.getAbsolutePath() + PREFERENCES_FILE_EXTENSION
dir.getPath() + DIR_FAILURE_SUFFIX
U.defaultWorkDirectory() + separatorChar + DEFAULT_TARGET_FOLDER + separatorChar
url.toExternalForm().substring(GhidraURL.PROTOCOL.length() + 1)
str + KMSRESTConstants.SERVICE_VERSION + "/"
newOrigin(getScheme(),getHost(),getPort()).asString() + path
base + configFile
center.x + center.width
leftButtonWidth + leftWidth
evt.getX() - getInsets().left
prefs.getInt(name+".x", 0)
Math.max(contentWidth, menuWidth) + insets.left + insets.right
TITLE_X_OFFSET + titlePreferredSize.width
width + insets.left + insets.right + 2
(int)(bounds.getWidth() * percent)

TABLE VIII
TOP WORDS USED IN C-TYPE EXPRESSIONS

C-Type
PATH
URL
SQL
HOST
PORT
XCOORD
YCOORD
WIDTH
HEIGHT
YEAR
MONTH
DAY

Top words (# Projects)
get (21), path (21), file (20)
url (19), get (18), string (18)
get (6), query (5), create (3)
host (21), get (17), address (17)
port (22), get (18), local (10)
width (9), x (9), get (9)
height (9), y (9), get (8)
width (13), get (11), size (10)
height (12), get (11), size (10)
year (4), get (2), int (2)
january (3), month (3), december (3)
day (3), int (2), parse (2)

TABLE IX
DEPENDENCY GRAPH RULES

Expression
# (constant)
A (variable access)
A() (method call)
A.B (ﬁeld access)
A.B() (instance method call)
op A (applying a unary operator)
A op B (applying a binary operator) A → op, B → op
B = A (assignment)

Dependency
#
A
A()
A → B
A → B()
A → op

A → B

TABLE X
ID3 FEATURES

Feature
PrimaryFirstWords
PrimaryLastWords
SecondaryFirstWords
SecondaryLastWords

Description
First Words of Primary Identiﬁers
Last Words of Primary Identiﬁers
First Words of Secondary Identiﬁers
Last Words of Secondary Identiﬁers

Features = [ ... ]
MinItems = 10

def buildTree(items):

if len(items) < MinItems:

default = getDefaultValue(items)
return Leaf(default)

else:

bestSplit = None
for f in Features:

split = splitItemsByFeature(items, f)
if calcEntropy(split) < calcEntropy(bestSplit):

bestSplit = split

nodes = []
for s in split:

nodes.append(buildTree(s))

return Tree(nodes)

Fig. 5.

ID3 Algorithm (Python)

if "port" in PrimaryLastWords:

if "get" in SecondaryFirstWords: ctype = PORT
elif "host" not in PrimaryFirstWords: ctype = PORT
...

elif "height" in PrimaryLastWords:

if "y" in PrimaryLastWords: ctype = YCOORD
else: ctype = HEIGHT

elif "path" in PrimaryLastWords:
if "host" in PrimaryLastWords:

if PrimaryFirstWords == "host": ctype = HOST
else: ctype = PATH

elif "address" in PrimaryLastWords: ctype = OTHER
...

Fig. 6. Obtained Rules (Python)

D. Classiﬁcation Results

To measure the performance of our method, we conducted
leave-one-project-out cross validation; For each project, we
use all other 25 projects as the training data and use the one
project as the test data. After repeating this project for 26
times, we took the average of the precision and recall for each
project across different c-types. Table XI shows the average
precision and recall as well as its F-score. The average F-score
for all 12 c-types was 83%.

TABLE XI
CLASSIFICATION RESULTS FOR EACH C-TYPES

C-Type
PATH
URL
SQL
HOST
PORT
XCOORD
YCOORD
WIDTH
HEIGHT
YEAR
MONTH
DAY
Average

Precision

Recall
68.9% 91.8%
61.3% 53.0%
70.4% 80.6%
70.0% 73.8%
84.6% 87.5%
95.7% 82.1%
97.5% 79.4%
92.0% 92.5%
90.4% 93.4%
100.0% 83.7%
100.0% 77.0%
100.0% 61.1%
85.9% 79.6%

F-score
78.8%
56.8%
75.2%
71.8%
86.0%
88.3%
87.5%
92.2%
91.9%
91.1%
87.0%
75.9%
82.7%

VI. DISCUSSIONS

As shown in Section V-D,

the average F-score of our
classiﬁer was about 80% for most c-types, except “URL” c-
type, whose F-score was less than 60%. There are several
reasons for this: First, URL expressions tend to be long and
has a number of components, as shown in Table V. Most of
these expressions are a concatenation of multiple strings with
+ operator, which is exempliﬁed in Table V. Also, since a
URL typically consists of a host name or path name, a URL
expression tends to include many PATH or HOST-associated
expressions as its constituents, which confuses the classiﬁer.
Indeed, this confusion is exhibited in the confusion matrix
shown in Table XII 4; a lot of URL expressions were mistaken
as PATH, HOST or PORT expressions.

Now, let us go back to our research questions:

RQ.1) What kinds of high-level concepts do programmers

commonly use in software projects?

RQ.2) How do programmers express such concepts in source

code?

RQ.3) Is it possible to accurately predict such concepts from

the source code appearance?

First, we have observed that a different set of c-types
appeared in different projects as shown in Table IV. Unlike
general-purpose data types, the use of c-types depends on
the domain of the project. This somewhat agrees with our
intuition; since c-types are closer to application-speciﬁc types,
its uses also depends on the application domain.

The second and third questions are related. We have seen
that a decision tree-based classiﬁer with simple features like
Table X performed reasonably well for most c-types we tested.
This indicates the following: there are certain conventions
about how these c-types should be expressed and many pro-
grammers tend to follow them. Therefore, for conceptual types
that are as common and well-deﬁned as ours, it is relatively
easy to identify them from the surface features of the source
code. We think that our methodology can be extended to

4This matrix is obtained by applying the classiﬁer to its own training set.
Note that this is not to show the performance of the classiﬁer. Rather, it shows
the limit of its discerning ability.

a wider range of concepts in other third-party libraries and
frameworks.

One of the possible ways to improve the classiﬁcation
accuracy is to exploit a longer data ﬂow between method
calls and other statements. In this paper, we treated individual
method calls separately. However, when a method call
is
chained with another method call or statement, we could take
advantage of this additional restriction to further reﬁne the
prediction result.

A. Threats to Validity

Here we discuss the threats to validity of our ﬁndings:
• An incomplete method list. To extract a c-type expression,
we need a list of API methods that specify the corre-
sponding c-type. We manually searched the Java Standard
API documentation to ﬁnd the appropriate methods for
each c-type, but we might have missed some methods.
• Some c-types are rarely used in real world and we might
not ﬁnd enough examples. This is a classic data sparse-
ness problem. Identifying some c-types might simply not
be practical.

• Open source selection bias. Our choice of the 26 open

source projects might not be representative.

• Some c-types cannot be well-deﬁned. A primary example
of this is the “URL” c-type. Technically, URL (Uniform
Resource Locator) and URI (Universal Resource Iden-
tiﬁer) are two different things [22]. URI is a broader
concept which includes URL but can be used for ofﬂine
entities such as book. In this paper, we treated them
interchangeably because these two concepts are almost
identical in the context of network applications. However,
certain c-type can be more confounding and we might not
be able to distinguish them in a consistent way. Another
example would be “ﬁle name” and “path name”. We are
yet to know how many such c-types exist.

• Potentially there are signiﬁcantly more “OTHER” c-type
expressions that we missed. In this paper, we assigned
a hypothetical “OTHER” c-type only to arguments in
certain methods. However, this should not be limited
to method calls only. If we are to identify the c-type
there will be many
of all expressions in a program,
more OTHER expressions. Training for all these OTHER
expressions might confuse the classiﬁer and end up with
a much lower performance.

VII. CONCLUSION

In this paper, we set out to examine how programmers
express a high-level concept such as path name or coordinates
in source code. We proposed a method to identify such
concepts by using standard API calls. We deﬁned 12 c-types
that are commonly used in many software projects. Each
c-type can be seen as an argument for the corresponding
API methods. We conducted experiments and obtained c-type
expressions from 26 open source projects. We constructed a
decision tree-based classiﬁer that predicts the c-type from a
given expression by combining its lexical and data ﬂow-centric

TABLE XII
CONFUSION MATRIX OF C-TYPES

C-Type
PATH
URL
SQL
HOST
PORT
XCOORD
YCOORD
WIDTH
HEIGHT
YEAR
MONTH
DAY

PATH
2274
82
2
7
2
0
0
0
0
0
0
0

URL
28
737
1
5
2
0
0
0
0
0
0
0

SQL
1
2
287
0
2
0
0
0
0
0
0
0

HOST
2
17
0
424
0
0
0
0
0
0
0
0

PORT
3
54
4
2
755
0
0
0
0
0
0
0

XCOORD
0
0
0
0
0
478
6
3
0
0
0
0

YCOORD
0
0
0
0
0
0
486
0
4
0
0
0

WIDTH
0
0
0
0
0
6
0
597
17
0
0
0

HEIGHT
0
0
0
0
1
0
7
10
569
0
0
0

YEAR
0
0
0
0
0
0
0
0
0
18
0
0

MONTH
0
0
0
0
0
0
0
0
0
0
43
0

DAY
0
0
0
0
0
0
0
0
0
0
0
7

features. We introduced the notion of primary and secondary
identiﬁer. Our classiﬁer achieved 83% average F-score for 12
c-types.

VIII. FUTURE WORK

There are several ways to extend our work. A straightfor-
ward extension is to support more c-types found in the Java
Standard API or other third-party APIs. Since a return value
of API is typically also well-deﬁned, it is possible to extend
the notion of c-type to return values.

To improve the classiﬁcation performance, one can take
advantage of more advanced data ﬂow. For example, an inter-
procedural data ﬂow between different functions or bidirec-
tional data ﬂow between multiple statements can provide extra
information to the classiﬁer. We could also use an advanced
inference algorithm such as graph neural network.

REFERENCES

[1] J. K. Ousterhout and K. Jones, Tcl and the Tk Toolkit (2nd ed.). Boston,
MA, USA: Addison-Wesley Longman Publishing Co., Inc., 2009.

[2] A. Shvets.

(2021) Primitive obsession.

[Online]. Available: https:

//refactoring.guru/smells/primitive-obsession

[3] D. Lawrie, C. Morrell, H. Feild, and D. Binkley, “What’s in a name?
a study of identiﬁers,” in Proceedings of the 14th IEEE International
Conference on Program Comprehension, ser. ICPC ’06. Washington,
DC, USA: IEEE Computer Society, 2006, pp. 3–12. [Online]. Available:
https://doi.org/10.1109/ICPC.2006.51

[4] R. O’Callahan and D. Jackson, “Lackwit: A program understanding
tool based on type inference,” in Proceedings of the 19th International
Conference on Software Engineering, ser. ICSE ’97. New York,
NY, USA: Association for Computing Machinery, 1997, p. 338–348.
[Online]. Available: https://doi.org/10.1145/253228.253351

[5] P. J. Guo, J. H. Perkins, S. McCamant, and M. D. Ernst, “Dynamic
inference of abstract types,” in Proceedings of the 2006 International
Symposium on Software Testing and Analysis, ser. ISSTA ’06. New
York, NY, USA: Association for Computing Machinery, 2006, p.
255–265. [Online]. Available: https://doi.org/10.1145/1146238.1146268
[6] S. K. Dash, M. Allamanis, and E. T. Barr, “Reﬁnym: Using names
to reﬁne types,” in Proceedings of the 2018 26th ACM Joint Meeting
on European Software Engineering Conference and Symposium on
the Foundations of Software Engineering, ser. ESEC/FSE 2018. New
York, NY, USA: Association for Computing Machinery, 2018, p.
107–117. [Online]. Available: https://doi.org/10.1145/3236024.3236042
[7] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant, C. Pacheco, M. S.
Tschantz, and C. Xiao, “The Daikon system for dynamic detection of
likely invariants,” Science of Computer Programming, vol. 69, no. 1–3,
pp. 35–45, Dec. 2007.

[8] B. W. Kernighan and R. Pike, The Practice of Programming. Boston,
MA, USA: Addison-Wesley Longman Publishing Co., Inc., 1999.

[9] S. McConnell, Code Complete, Second Edition. Redmond, WA, USA:

Microsoft Press, 2004.

[10] G. Beniamini, S. Gingichashvili, A. K. Orbach,

Feitelson, “Meaningful
variables,” in Proceedings of
on Program Comprehension,
USA:
//doi.org/10.1109/ICPC.2017.18

IEEE Press, 2017, pp. 45–54.

and D. G.
identiﬁer names: The case of single-letter
the 25th International Conference
Piscataway, NJ,
ser.
[Online]. Available: https:

ICPC ’17.

[11] E. Avidan and D. G. Feitelson, “Effects of variable names on
comprehension an empirical study,” in Proceedings of
the 25th
International Conference on Program Comprehension, ser. ICPC ’17.
Piscataway, NJ, USA: IEEE Press, 2017, pp. 55–65. [Online]. Available:
https://doi.org/10.1109/ICPC.2017.27

[12] E. W. Høst and B. M. Ostvold, “Debugging method names,” in
Proceedings of
the 23rd European Conference on ECOOP 2009
— Object-Oriented Programming, ser. Genoa. Berlin, Heidelberg:
Springer-Verlag, 2009, pp. 294–317. [Online]. Available: http://dx.doi.
org/10.1007/978-3-642-03013-0 14

[13] T. Mikolov, I. Sutskever, K. Chen, G. Corrado, and J. Dean, “Distributed
representations of words and phrases and their compositionality,” CoRR,
vol. abs/1310.4546, 2013. [Online]. Available: http://arxiv.org/abs/1310.
4546

[14] U. Alon, M. Zilberstein, O. Levy, and E. Yahav, “Code2vec: Learning
distributed representations of code,” Proc. ACM Program. Lang.,
vol. 3, no. POPL, pp. 40:1–40:29, Jan. 2019. [Online]. Available:
http://doi.acm.org/10.1145/3290353

[15] L. Jiang and Z. Su, “Osprey: A practical type system for validating
dimensional unit correctness of c programs,” in Proceedings of the
28th International Conference on Software Engineering, ser. ICSE ’06.
New York, NY, USA: Association for Computing Machinery, 2006, p.
262–271. [Online]. Available: https://doi.org/10.1145/1134285.1134323
[16] S. Hangal and M. S. Lam, “Automatic dimension inference and checking
for object-oriented programs,” in 2009 IEEE 31st International Confer-
ence on Software Engineering, 2009, pp. 155–165.

[17] (2021) Java ®platform, standard edition & java development kit
[Online]. Available: https:

version 11 api
//docs.oracle.com/en/java/javase/11/docs/api/index.html

speciﬁcation. Oracle.

[18] (2021) Eclipse java development

tools (jdt). Eclipse Foundation.

[Online]. Available: https://www.eclipse.org/jdt/

[19] D. A. Wheeler. Sloccount. [Online]. Available: https://dweeler.com/

sloccount/

[20] J. R. Quinlan, C4.5: Programs for Machine Learning.

Morgan

Kaufmann Publishers Inc., 1993.

[21] J. Ferrante, K. J. Ottenstein, and J. D. Warren, “The program
dependence graph and its use in optimization,” ACM Trans. Program.
Lang. Syst., vol. 9, no. 3, pp. 319–349, Jul. 1987. [Online]. Available:
http://doi.acm.org/10.1145/24039.24041

[22] T. Berners-Lee. (2021) Uniform resource identiﬁer (uri): Generic syntax.

W3C. [Online]. Available: https://datatracker.ietf.org/doc/html/rfc3986

