2
2
0
2

y
a
M
4

]

O
L
.
s
c
[

1
v
4
5
3
8
0
.
5
0
2
2
:
v
i
X
r
a

CONSTRUCTIVE ANALYSIS IN THE AGDA PROOF ASSISTANT

by

Zachary Murray

Submitted in partial fulﬁllment of the requirements
for the degree of BSc Honours in Mathematics and Computer Science

at

Dalhousie University
Halifax, Nova Scotia
April 2022

© Copyright by Zachary Murray, 2022

 
 
 
 
 
 
Table of Contents

Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

iv

Acknowledgements

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Chapter 1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . .

1.1

Informal Mathematics

. . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 Mathematics Formalized . . . . . . . . . . . . . . . . . . . . . . . . .

1.3 Mathematics Computerized . . . . . . . . . . . . . . . . . . . . . . .

1.4 Constructive Analysis in the Agda Proof Assistant . . . . . . . . . . .

Chapter 2

Constructive Mathematics . . . . . . . . . . . . . . . . . .

2.1 History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2

Intuitionistic Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Chapter 3

Constructive Analysis . . . . . . . . . . . . . . . . . . . . .

3.1 History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.2 Sets, Operations, and Functions . . . . . . . . . . . . . . . . . . . . .

3.3 The Set of Real Numbers . . . . . . . . . . . . . . . . . . . . . . . . .

3.4 Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

v

1

1

1

2

2

4

4

5

6

6

6

7

11

15

Chapter 4

Agda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

16

4.1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.2 Deﬁnitions and Proofs in Agda . . . . . . . . . . . . . . . . . . . . .

4.3 Problems with Agda . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.1 Canonicity . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.2
. . . . . . . . . . . . . . . . . . . .
4.3.3 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Setoids and Quotient Sets

16

16

22
22
24
25

ii

Chapter 5

Constructive Analysis in Agda . . . . . . . . . . . . . . .

26

5.1 Why Constructive Analysis? . . . . . . . . . . . . . . . . . . . . . . .

5.2 What Libraries Do We Need? . . . . . . . . . . . . . . . . . . . . . .

5.3 The Real Numbers and Software Engineering . . . . . . . . . . . . . .

5.4 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

27

27

28

31

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

33

iii

Abstract

Proof assistant software has recently been used to verify proofs of major theorems, yet

even the libraries of some of the most prominent proof assistants lack much of under-

graduate mathematics. In particular, the Agda proof assistant has no formalization

of the real numbers and their arithmetic. In this thesis, I present my implementa-

tion of Errett Bishop’s constructive real numbers in Agda, including their arithmetic,

ordering, and fundamental results, such as uncountability and Cauchy completeness.

We will also survey the basic concepts of constructive analysis and the Agda proof

assistant.

iv

Acknowledgements

First, thank you to my supervisor, Dr. Peter Selinger, for your guidance and com-

ments, especially on eﬃciency and design, and for teaching me Agda in the ﬁrst place.

Thanks to Dr. Frank Fu for his teaching of MATH 2112 in the summer of 2018, in

particular for brieﬂy banning the use of the law of the excluded middle, which is what

led me to study constructivism and type theory. I am also grateful to the David and

Faye Sobey Foundation for helping make this project possible with their generous

research scholarship during the summer of 2021.

v

Chapter 1

Introduction

1.1 Informal Mathematics

Modern mathematicians write their proofs in an informal style in natural language. A

paper’s readers are assumed to have much expertise in the topic being studied. This

allows the paper’s authors to skip seemingly trivial details in their proofs, focusing

only on the bigger details, and the bigger picture.

Informal mathematics, in this

sense, is extremely eﬃcient. It is relatively easy to write a proof informally. Likewise,

it is relatively easy for the reader to pick up the key ideas and concepts.

However, it can also be easy to make errors in informal mathematics. While it is

common for papers written in the informal style to have minor errors, these errors are

usually easily ﬁxed. On the other hand, severe errors, which either cannot be ﬁxed

or would be very diﬃcult to ﬁx, are relatively uncommon.

But severe errors do appear in informal mathematics, even within published pa-

pers. Fermat’s last theorem is infamous for the number of erroneous proofs published.

Even Andrew Wiles’s original proof contained a severe ﬂaw, which took years to ﬁx.

1.2 Mathematics Formalized

Proofs written in a formal setting, like Fitch-style natural deduction, have been a sta-

ple of courses in discrete mathematics for years. Such sterilized formalism familiarizes

students with the exact logical rules mathematicians are allowed to use in informal

proofs. These logical rules are, of course, usually unmentioned in informal proofs, but

they are always hidden in the background.

Anyone who has written a fully formal proof, even of simple logical laws, knows it

is incredibly time consuming. There is so much detail that the intuition behind the

proof is lost to the reader. The beneﬁt is that errors are easily identiﬁed. Indeed, it

seems such errors could be checked by a computer.

1

2

1.3 Mathematics Computerized

If all informal proofs were written out formally so that a computer could read the

formal proof and verify it, then severe errors would almost never be published. But

writing out such a formal proof is too time consuming, and we ﬁrst need to program

the computer to be able to verify formal proofs.

Proof assistant software aims to solve this problem. Proof assistants allow users

to write their proofs somewhere in between informal and formal. Informal enough

that, hopefully, anyone reading the proof can pick out the key ideas, and also so that

the proof does not take as long to write as a fully formal proof. But formal enough

that the proof assistant can ﬁgure out the rest of the details, thus constructing and

verifying a fully formal proof.

Proof assistants have already been used to eliminate the possibility of error in

famous proofs. A proof of the four colour theorem was veriﬁed in the Coq proof assis-

tant by Georges Gonthier, ﬁnally ending a long history of false proofs and controversy

[5].

1.4 Constructive Analysis in the Agda Proof Assistant

This thesis describes an implementation of mathematics in a proof assistant. We

implement a basic theory of real numbers and sequences and series. In particular,

we implement these aspects from the American analyst Errett Bishop’s constructive

analysis. The proof assistant we use is Agda.

In implementing this constructive analysis, we hope to achieve two goals.

1. Implement a theory of real numbers in Agda.

2. Study the problems a user implementing everyday mathematics may encounter

in a proof assistant.

For the ﬁrst goal, we note that, at the time of writing, the Agda standard library

is lacking a theory of real numbers. We hope that this thesis will help solve this

problem.

3

For the second goal, it must be admitted that most mathematicians do not use

proof assistants. Those that do tend to focus on mathematics other than analysis. It

will be useful, then, to see how feasible analysis is in Agda.

The result of this project is an Agda library consisting of over 6000 lines of code.

In this thesis, we provide some background in both constructive analysis and Agda

so that we can discuss the stated problems.

This thesis is aimed at three audiences. The ﬁrst audience is the proof assistant

community. This audience will probably be more interested in the ﬁrst problem, and

thus in the library itself. For them, the most useful parts of this thesis are probably

the background material on constructive analysis in Chapter 3, the discussion of the

library in Chapter 5, and the library at [11].

The second audience is mathematicians curious about proof assistants, but who

are unsure about how useful they can be and what problems the average user will

encounter. This audience will probably care more about the ﬁrst problem than the

second problem. The most useful material for them should be the introduction to

Agda in Chapter 4.

The third audience is those interested in learning about constructive mathematics.

On the one hand, constructive mathematics, historically done on paper, is increasingly

concerned with proof assistants. On the other hand, the design of proof assistants

tends to favour constructive mathematics, and this itself is worth studying. Moreover,

Bishop’s constructive analysis has been an area of keen interest in constructive math-

ematics since its appearance in 1967. As we will discuss the history and problems of

each of these points, every chapter except, perhaps, Chapter 5, should be of interest

to the third audience.

Chapter 2

Constructive Mathematics

2.1 History

Constructive mathematics ﬁnds its roots in philosophical debates concerning the foun-

dations of mathematics during the late 19th and early 20th centuries. Questioning

the role and validity of inﬁnities in proofs and driven by concerns about set-theoretic

antinomies like Russell’s paradox, philosophers and mathematicians debated the ex-

istence and character of a foundation of mathematics. Thus three competing schools

of thought emerged, namely the formalism of German mathematician David Hilbert,

the logicism of the logicians Gottlob Frege and Bertrand Russell, and ﬁnally, the

intuitionism of Dutch topologist L.E.J. Brouwer.

Of the three, it is Brouwer’s intuitionism that is constructivist. Intuitionists con-

ceive of mathematics as part of human consciousness. Mathematical objects cannot

be said to exist outside of the human mind, and a proposition is proved when it is

witnessed by a sequence of mental constructions. From intuitionism, we abstract the

core tenet of constructive mathematics: To exist is to be constructed.

As a result, constructivists must not assume the principle of double negation

(DNE) (i.e., ¬¬P =⇒ P ) since we could then prove ∃xP (x) from ¬¬∃xP (x). Such

proofs do not specify how to construct the x it claims to exist.

If we commit to

the common view that mathematical objects exist, then DNE forces us to conclude

that x must have some sort of external and mind-independent existence. Because

the law of the excluded middle (LEM) (i.e., P ∨ ¬P ) is logically equivalent to DNE,

constructivists also reject LEM.

Intuitionism, however, was seen as an untenable foundational philosophy of math-

ematics. The rejection of LEM places limitations on analysis, and fundamental results

like the Intermediate Value Theorem are not provable constructively. Further, the

intuitionists subscribed to Kant’s view that time is a part of the mind which makes

our conscious experience possible, and not part of the external world, and they also

4

5

rely on the concept of free will. The intuitionistic continuum is dependent on these

philosophical imports, and philosophical arguments become vital to analysis. This

results in strange conclusions, such as every function of a real variable being continu-

ous. Intuitionism is thus at odds with standard mathematical practice thanks to its

philosophical baggage and odd results.

Because intuitionism was the dominant constructivist school, its mystic charac-

ter became associated with constructivism more generally. Due to the oddities of

intuitionistic analysis, it was believed that analysis could not be carried out construc-

tively. Hilbert went as far as to claim that “Taking the principle of excluded middle

from the mathematician would be the same, say, as proscribing the telescope to the

astronomer or to the boxer the use of his ﬁsts” [6, p. 476].

2.2 Intuitionistic Logic

Modern constructivists use intuitionistic logic in place of classical logic. Intuition-

istic logic is essentially classical logic without the law of the excluded middle or

any equivalent axiom. Perhaps the most popular form of intuitionistic logic is the

Brouwer-Heyting-Kolmogorov (BHK) interpretation. A proposition P is identiﬁed

with the set of its proofs. The interpretation of the logical connectives is summarized

in Table 2.1. The left column represents the proposition P we wish to prove, and the

right column deﬁnes what a proof of P is.

Proposition
P =⇒ Q
P ∧ Q
P ∨ Q

∃xP (x)
∀xP (x)
¬P

Proof Requirement
A function mapping proofs of P to proofs of Q
A pair (p, q) of a proof p of P and a proof q of Q
A pair (0, p), where p is a proof of P or a pair (1, q)
where q is a proof of Q
A pair (a, p) of some a and a proof of P (a)
A function that maps objects x to a proof of P (x)
A proof of P =⇒ ⊥

Table 2.1: Intuitionistic characterization of logical connectives.

Chapter 3

Constructive Analysis

3.1 History

We are not interested in properties of the positive integers that have no descriptive

meaning for ﬁnite man... If God has mathematics of his own that needs to be done, let

him do it himself.

Errett Bishop, Constructive Analysis [2, p. 5]

Errett Bishop (1928–1983) was an American analyst and a leading ﬁgure in the

development of modern constructive mathematics. Like the intuitionists, Bishop be-

lieved that mathematics was a creation of the mind, and was disturbed by the free use

of the law of the excluded middle and other nonconstructive principles, referring to

classical mathematics as “idealistic” [2, pp. 4-12]. However, Bishop was disappointed

by the intuitionists’ focus on philosophical speculation over carrying out practical

constructive mathematics. In an eﬀort to save constructive mathematics from the

disdain aﬀorded it by its association with intuitionism, Bishop set out to rebuild con-

structive analysis in a manner that captured both the criticisms of the constructivists

and the essence of classical analysis. Thus Bishop published the Foundations of Con-

structive Analysis in 1967, and, later, an updated volume with Douglas S. Bridges

[2], which we follow in this chapter with added commentary. It may please the reader

to know that every numbered result in this section has been formally veriﬁed in this

thesis’s library [11].

3.2 Sets, Operations, and Functions

A constructive theory of sets must require, of course, that its sets be “constructible”

in some suitable sense. A set in Bishop’s sense is thus deﬁned by rules to construct

an element of the set and an equivalence relation on the set that determines what it

6

7

means for two of its elements to be equal.

Thus Bishop’s theory immediately distinguishes between intensional and exten-

sional equality, where the extensional equality is given by a set’s equipped equivalence

relation. Bishop takes it a step further, deﬁning an operation from a set A to a set B

by a “ﬁnite routine” intensionally mapping each element of A to an element of B, and

a function from A to B by an operation from A to B that respects the extensional

equality of A. An operation respects intension, and a function respects extension.

Those unfamiliar with constructive mathematics may be confused at why this

distinction between operation and function is used. Why not take the quotient of a

set over its equipped equivalence relation instead? Simply put, Bishop thinks that

quotients would be pointless in his constructive setting [2, p. 12]. Recall that sets

are deﬁned by rules to be satisﬁed to construct an element. An equivalence class A

(which is nonempty by deﬁnition) would thus be deﬁned by explicitly providing an

element x of A and the equivalence relation. Hence, the boilerplate that comes with

the equivalence class adds nothing, and we instead prove that operations like addition

are functions in the sense we have deﬁned. This may not be a satisfying conclusion,

but there are other reasons for avoiding quotients and equivalence classes which we

will see when discussing proof assistants in Chapter 4.

Finally, we note that the underlying logic of Bishop’s system is essentially intu-

itionistic logic under the Brouwer-Heyting-Kolmogorov interpretation. We will now

discuss some fundamental deﬁnitions and theorems regarding Bishop’s real numbers,

sequences, and series, taken from Bishop and Bridges Constructive Analysis [2].

3.3 The Set of Real Numbers

We will deﬁne the real numbers and their equality, and explore some of their prop-

erties. Note that we are using Bishop’s conception of sets, operations, and functions,

along with the BHK interpretation of logic.

Deﬁnition 3.3.1. A sequence (xn) of rational numbers is regular if for all m, n ∈ N
we have

|xm − xn| ≤

1
m

+

1
n

.

(3.1)

A real number is a regular sequence of rational numbers. Two real numbers x ≡ (xn)

and y ≡ (yn) are equal, written x = y, if for all n ∈ N we have

|xn − yn| ≤

2
n

.

8

(3.2)

While reﬂexivity and symmetry are obvious, it is not as clear that equality of real

numbers is transitive. It is a consequence of the following result.

Proposition 3.3.2. The real numbers x ≡ (xn) and y ≡ (yn) are equal if and only
if for each j ∈ N there is Nj ∈ N such that for all n ≥ Nj we have

|xn − yn| ≤

1
j

.

(3.3)

Proof. Suppose x = y. For each j ∈ N, take Nj ≡ 2j. The desired result follows
directly from (3.2).

Conversely, suppose that, for each j ∈ N, there is Nj ∈ N such that for all n ≥ Nj
we have (3.3). To show x = y, we must show that (3.2) holds. Consider an arbitrary
k ∈ N and let j ≡ 3k. By assumption, there exists Nj ∈ N such that

|xNj − yNj | ≤

1
j

=

1
3k

.

Without loss of generality, we can assume that Nj ≥ j. Using this and regularity of

(xn) and (yn), we have

|xn − yn| = |xn − yn + (xNj − yNj ) − (xNj − yNj )|

≤ |xn − xNj | + |xNj − yNj | + |yn − yNj |

) +

1
j

+ (

1
n

+

1
3k

+

1
n

+

)

+

1
Nj
1
3k

≤ (

+

1
n
1
n
2
n

+

+

1
Nj
1
3k
1
k

,

≤

=

so

|xn − yn| ≤

2
n

+

1
k

.

Since k ∈ N was arbitrary, it follows that

|xn − yn| ≤

2
n

,

as desired.

Lemma 3.3.3. Equality of real numbers is an equivalence relation.

9

Proof. Reﬂexivity and symmetry are obvious. For transitivity, let x ≡ (xn), y ≡
(yn), z ≡ (zn) be regular sequences, and suppose x = y and y = z. Let j ∈ N be
arbitrary and set k ≡ 2j. By (3.3.2), there exists Nk ∈ N such that for all n ≥ Nk we
have

and N (cid:48)

k ∈ N such that for all n ≥ N (cid:48)

1
2j

|xn − yn| ≤

=

1
k
k we have
1
k

|yn − zn| ≤

=

1
2j

.

Set Nj ≡ max{Nk, N (cid:48)

k}. Then for all n ≥ Nj we have

|xn − zn| ≤ |xn − yn| + |yn − zn|

≤

=

=

+

1
k

+

1
2j

1
k
1
2j
1
j

.

Since j ∈ N was arbitrary, it follows from (3.3.2) that x = z.

From now on, we write R to refer to the set of real numbers, that is, the collection

of regular sequences equipped with the equivalence relation deﬁned in Deﬁnition 3.3.1.

To see what real number arithmetic looks like with regular sequences, we will

deﬁne addition.

Proposition 3.3.4. Given real numbers x ≡ (xn) and y ≡ (yn), their sum

(xn) + (yn) ≡ (x2n + y2n)

is a real number.

Proof. Let m, n ∈ N. By regularity of (xn) and (yn), we have

|x2m + y2m − (x2n + y2n)| ≤ |x2m − x2n| + |y2m − y2n|

≤

=

so (x2n + y2n) is regular.

+

1
2m

+

1
2n

1
2m
1
m

+

1
2n
1
n

,

+

Next, we deﬁne the order on R.

Deﬁnition 3.3.5. Let x, y ∈ R. We write x < y if there exists n ∈ N such that

10

We write x ≤ y if, for all n ∈ N, we have

yn − xn >

1
n

.

yn − xn ≥ −

1
n

.

Notice that we do not deﬁne x ≤ y to mean x < y ∨ x = y. This is a double-edged

sword. If we were to deﬁne x ≤ y in such a manner, then ¬(x < y) would no longer

imply y ≤ x, since our constructive interpretation of logic would require us to prove

either y < x or y = x. This is not possible constructively. But the current deﬁnition

avoids this problem.

Proposition 3.3.6. Let x, y ∈ R. If ¬(x < y), then x ≥ y.

Proof. Let n ∈ N. Suppose xn − yn < − 1
contradicting our assumption. Thus xn − yn ≥ − 1

n . Then yn − xn > 1
n, giving x ≥ y.

n , and so x < y,

Note that we freely used the fact that ¬(p < q) implies p ≥ q for p, q ∈ Q.

This statement is easily proved constructively, but we needed to be careful with our
deﬁnitions to prove it for R. Next, it is easy to constructively prove that ≤ is a
total order on Q, but it cannot be constructively shown that ≤ is a total order on R.
Finally, equality is decidable on Q, but not on R.

Naturally, one may wonder what other subtleties are hidden in constructive math-
ematics. One point that is clear from our discussion of the diﬀerences between Q and
R is that, for x, y ∈ R, the statement ¬(x = y) =⇒ x < y ∨ x > y is not construc-
tively valid. Thus for x, y ∈ R we write x <> y if x < y ∨ y < x. In place of the

classical use of x (cid:54)= y (i.e., ¬(x = y)), we tend to use <>, since that is usually what

we want from x (cid:54)= y. Bishop takes it a step further, writing x (cid:54)= y instead of x <> y

for x < y ∨ y < x, but this is confusing by modern notational standards. We will

encounter similar strangeness in the treatment of sequences and series.

Despite these oddities, it is worth noting that Bishop’s continuum is consistent

with the classical continuum, in that it is uncountable (Cantor’s technique is con-
structive), and both the Archimedean property and the density of Q in R are con-

structively valid (we have veriﬁed their proofs in the Agda proof assistant, along with

all propositions, lemmas, and theorems in this chapter). But is Cauchy completeness

11

constructively valid?

3.4 Sequences

Any constructive treatment of sequences that cannot prove Cauchy completeness of R

is bound to be rejected in favour of the classical treatment. Classically, we often prove

completeness by ultimately relying on the least upper bound property. But for the
supremum of a nonempty subset S of R that is bounded above to exist constructively,

we would need to provide an algorithm to construct it, a tall order given that we know

essentially nothing about the elements of S. Indeed, the least upper bound property is

constructively invalid. Fortunately, there is a valid constructive proof of completeness

in Bishop’s system, though with some peculiarities we will later note.

Deﬁnition 3.4.1. A sequence (xn) of real numbers is a Cauchy sequence if for each
k ∈ N there is Nk ∈ N such that for all m, n ≥ Nk we have

|xm − xn| ≤

1
k

.

(3.4)

Deﬁnition 3.4.2. A sequence (xn) of real numbers converges to a real number l if
for each k ∈ N there is Nk ∈ N such that n ≥ Nk

|xn − l| ≤

1
k

.

(3.5)

We say that (xn) is convergent if there is a real number l such that (xn) converges to

l.

In Bishop’s proof of completeness of R we will need to know, for a real number

x ≡ (xn), how accurately each xn approximates x. We state the result without proof,

for which the reader may refer to Lemma 2.14 in [2, p. 25] or the lemma-2-14 function

in the RealProperties.agda ﬁle of [11].

Proposition 3.4.3. For each real number x ≡ (xn), we have

|x − xn| ≤

1
n

for all n ∈ N.

12

We now present Bishop’s proof of completeness with clariﬁcation added where it

is helpful.

Theorem 3.4.4. A sequence (xn) of real numbers converges if and only if it is a

Cauchy sequence.

Proof. Suppose (xn) converges to some l ∈ R. Let k ∈ N. For (xn) to be a Cauchy
sequence, we must show that there is Nk ∈ N such that for all m, n ≥ Nk we have

|xm − xn| ≤

1
k

.

By deﬁnition of convergence, there exists M2k ∈ N such that for all m, n ≥ M2k we
have

1
2k
Take Nk ≡ M2k. Then for all m, n ≥ Nk we have

|xn − l| ≤

.

|xm − xn| ≤ |xm − l| + |xn − l|
1
2k

1
2k

1
k

≤

+

=

,

and we are done.

Conversely, suppose (xn) is a Cauchy sequence. We will ﬁrst construct a real

number y, and then show that (xn) converges to y. We deﬁne y ≡ (yk) as follows.
Consider some k ∈ N. By Deﬁnition 3.4.1, there exists N2k ∈ N such that for all
i, j ≥ N2k, we have

|xi − xj| ≤

.

((cid:63))

1
2k

Let Mk ≡ max{3k, N2k}. Consider the real number xMk in the sequence (xn). We
deﬁne yk ≡ xMk,2k; that is, yk is the (2k)th element of the regular sequence deﬁning
xMk. Since k ∈ N was arbitrary, we deﬁne the entire sequence y ≡ (yk) through this
process.

To show that y is a real number, we must show that (yk) is a regular sequence.
To this end, let m, n ∈ N. First, note that we get Mm, Mn ≥ min{N2m, N2n} by
deﬁnition of Mm and Mn. From ((cid:63)), it follows that

|xMm − xMn| ≤ max{

1
2n

}

,

1
2m
1
2n

≤

1
2m

+

.

((cid:63)(cid:63))

By Proposition 3.4.3 and ((cid:63)(cid:63)), we have

|ym − yn| = |xMm,2m − xMn,2n|

13

≤ |xMm,2m − xMm| + |xMm − xMn| + |xMn − xMn,2n|
1
2n

1
2m

1
2n

+ (

) +

≤

+

1
2m
1
m

=

+

1
n

.

Since m and n were arbitrary, it follows that (yk) is regular. Thus y is a real number.
It remains to show that (xn) converges to y. To this end, let k ∈ N be arbitrary.

It suﬃces to show that for all n ≥ Mk we have

|y − xn| ≤

1
k

.

Taking n ≥ Mk ≡ max{3k, N2k}, it follows that n ≥ 3k, Mn ≥ N2k, and n ≥ N2k.

Since Mn, n ≥ N2k, we can apply ((cid:63)). Combined with Proposition 3.4.3, we have

|y − xn| ≤ |y − yn| + |yn − xMn| + |xMn − xn|

= |y − yn| + |xMn,2n − xMn| + |xMn − xn|

+

+

1
2n
1
6k

1
2k
1
2k

+

+

≤

≤

=

1
n
1
3k
1
k

,

as desired.

Before discussing the peculiarities of Bishop’s notions of Cauchyness and conver-

gence, we must discuss the status of the axiom of choice and its weaker counterpart,

the axiom of countable choice. We thus repeat and extend the comments of Douglas

Bridges in [2, p. 13].

For our purposes, the axiom of choice (AoC) states that, for sets X and Y and a

relation R ⊆ X × Y , if for each x ∈ X there exists y ∈ Y such that xRy holds, then

there is a function f : X → Y such that for each x ∈ X we have xRf (x). The axiom
of countable choice (AoCC) is obtained from AoC by replacing X with N.

By Diaconescu’s theorem, AoC implies the law of the excluded middle (LEM).

Thus, AoC cannot be constructively valid. However, Bishop himself seemingly states

14

otherwise, stating that “A choice function exists in constructive mathematics, because

a choice is implied by the very meaning of existence” [2, p. 13]. Indeed, AoC is, in a

weaker sense, true in Bishop’s system, as is AoCC.

The key lies in Bishop’s distinction between “function” and “operation”, and,

moreover, in what is meant by “there exists”. In the classical sense of “function”, the

function f : X → Y in AoC is understood to respect the extensional equality on X,

and thus the classical notion of “function” is essentially equivalent to Bishop’s notion.

If we do not require f to be a function in Bishop’s sense, and only an operation, then

Diaconescu’s theorem no longer applies.

This weak AoC (wAoC), where f is merely an operation, is actually provable in

Bishop’s system. Recall that “there exists an x such that P (x)” means that we have

a pair of some x and a proof of P (x). Thus for sets X, Y and a relation R ⊆ X × Y ,

the statement “for each x ∈ X there is y ∈ Y such that xRy” literally means that

there is an operation f : X → Y such that we have xRf (x) for each x ∈ X, and

so wAoC is one of the most trivial theorems in Bishop’s system. AoCC is then a

corollary of wAoC since the notion of equality of two natural numbers is intensional

equality.

It turns out that AoCC is critical for R to be Cauchy complete constructively.

Again analyzing “there exists”, Bishop’s deﬁnition of “(xn) is a Cauchy sequence”

boils down to the following (the corresponding interpretation of convergence is obvi-

ous).

Deﬁnition 3.4.5. A sequence of reals (xn) is a Cauchy sequence if there exists a
function N : N → N such that, for all k ∈ N and m, n ≥ N (k) we have

|xm − xn| ≤

1
k

.

Robert Lubarsky [8] showed that if AoCC is invalid in some constructive settings
and if there is not necessarily a function N : N → N as in Deﬁnition 3.4.5 (i.e.,

if we cannot interpret Deﬁnition 3.4.1 as Deﬁnition 3.4.5), it may be impossible to

show that the reals are complete. Thus constructivizations of analysis weaker than

Bishop’s system tend to be untenable.

15

3.5 Conclusion

While Bishop’s system comes with oddities like the fact that ≤ is not a total order
on R, we see that constructive analysis is not as untenable as Hilbert thought. Not

only does Bishop’s system avoid the philosophical baggage of Brouwer’s intuition-

ism, Bishop’s continuum is quite similar to the classical continuum, satisfying un-
countability, density of Q, the Archimedean property, and completeness. And most

importantly, Bishop’s treatment of analysis is in-depth, covering calculus, complex

analysis, and beyond. But these topics and their fascinating subtleties are far outside

the scope of this thesis.

Before continuing on to Agda, the reader is reminded that every numbered result

in this chapter has been formally veriﬁed in my constructive analysis library [11].

Chapter 4

Agda

4.1 Introduction

A proof assistant is a software tool for writing mathematical proofs in such a manner

that a computer can verify their validity. Modern proof assistants often use a type

theory powerful enough to express interesting mathematics via the Curry-Howard

correspondence. Type theory is like set theory, but it is more convenient for au-

tomation. By type, we mean the types of a programming language, like “char” or

“int”. Mathematical propositions are expressed as types, and proofs are programs

that construct a term with the proposition as its type. For example, the proposition

P =⇒ Q is represented by the function type P → Q. A proof of P =⇒ Q

is then a function mapping proofs of P (i.e., terms of type P ) to proofs of Q (i.e.,

terms of type Q). In sum, propositions are types and proofs are programs. This is

precisely the Curry-Howard correspondence. Note that it is strikingly similar to the

Brouwer-Heyting-Kolmogorov interpretation of logic.

Such proof assistants usually include a programming language in which we can

exploit features of computation, such as recursion and reﬂection, to automate portions

of proofs. Three of the most prominent proof assistants are Lean, Coq, and Agda

[10, 4, 1]. We will focus on Agda, a dependently typed functional programming

language based on a type theory similar to Martin-L¨of’s intensional type theory. We

will discuss Agda’s basic use, features, and problems that a typical mathematician

user may encounter. Some familiarity with the lambda calculus is assumed in this

chapter, for which the reader may refer to [12].

4.2 Deﬁnitions and Proofs in Agda

We will give a brief introduction to Agda through some examples. Agda provides

plenty of helpful features for the user to deﬁne their objects and make their proofs at

16

least somewhat readable. We begin by deﬁning the Peano numbers.

Deﬁnition 4.2.1. Peano axiomatized the set N of natural numbers as follows.

17

• 0 is a natural number.

• Whenever n is a natural number, so is suc(n).

• 0 (cid:54)= suc(n) for all n ∈ N.

• If suc(m) = suc(n), then m = n.

• For any set S, if 0 ∈ S and if for all n ∈ N ∩ S we have suc(n) ∈ S, then N ⊆ S.

In Agda, we can concisely deﬁne the natural numbers as a data type as follows.
data N : Set where

zero : N
suc : N → N

Note that N has type Set, indicating that the natural numbers are a set. The
elements past the where keyword are the type constructors of N, indicating that
zero is a natural number and that suc : N → N is a function producing a natural
number suc n : N given n : N. The data keyword indicates that the deﬁnition is
inductive, meaning that the only elements of N are those built with the speciﬁed type

constructors.

Typically, addition on N is deﬁned recursively on natural numbers m, n ∈ N as

follows.

0 + n = n, and

suc(m) + n = suc(m + n).

Since N was deﬁned inductively, Agda allows us to recursively deﬁne addition in
precisely the same way by pattern matching on the type constructors of N. Note that

the deﬁnition is curried, meaning that instead of deﬁning a function A × B → C, we

deﬁne a function A → (B → C). Curried deﬁnitions are the preferred style in Agda.

_+_ : N → N → N

zero + n = n

suc m + n = suc (m + n)

18

To illustrate a proof, let us prove the commutativity of addition. For the sake of

comparison with Agda, we ﬁrst write the proof informally.

Proposition 4.2.2. For each m, n ∈ N, we have m + n = n + m.

Proof. We proceed by induction on m and n. We consider several cases.

Case 1. Suppose m = n = 0. Then 0 + 0 = 0 + 0 holds by reﬂexivity.

Case 2. Suppose m = 0. Our induction hypothesis is that 0 + n = n + 0. We must

show that 0 + suc(n) = suc(n) + 0. By deﬁnition of + and suc, this is equivalent to

suc(0 + n) = suc(n + 0), which follows from the induction hypothesis and the fact

that suc is a function. The case where n = 0 with induction hypothesis m+0 = 0+m

is similar.

Case 3. Our induction hypotheses are the following:

(i) m + suc(n) = suc(n) + m,

(ii) m + n = n + m, and

(iii) suc(m) + n = n + suc(m).

We must show that suc(m) + suc(n) = suc(n) + suc(m). We have

suc(m) + suc(n) = suc(m + suc(n))

by deﬁnition,

= suc(suc(n) + m)

since suc is a function, by hypothesis (i),

= suc(suc(n + m))

by deﬁnition,

= suc(suc(m + n))

since suc is a function, by hypothesis (ii),

= suc(suc(m) + n)

by deﬁnition,

= suc(n + suc(m))

since suc is a function, by hypothesis (iii),

= suc(n) + suc(m)

by deﬁnition,

and we are done.

The proof of commutativity of addition is compactly translated into Agda. By
the Curry-Howard correspondence, the statement “∀m, n ∈ N.m + n = n + m” is

encoded in Agda by the following function and type.

+-comm : (m n : N) → m + n ≡ n + m

19

First, note that we represent the universal quantiﬁcation over m and n by a function

taking inputs m and n. The commutativity proposition regarding these inputs is the

codomain of this function. Note that ≡ is used in place of =, since the symbol = is

used for deﬁnitions in Agda. To prove commutativity, we recursively deﬁne +-comm

on the type constructors zero and suc.

First, we simply have to prove 0 + 0 = 0 + 0, which is true by reﬂexivity. The

refl term proves reﬂexivity for any given term, and so we use it here to prove

zero + zero ≡ zero + zero as follows.

+-comm zero zero = refl

Next, we prove that 0 + suc(n) = suc(n) + 0 by deﬁning +-comm on the values

zero and suc n. Note that the induction hypothesis is condensed into a recursive

call to the function +-comm.

+-comm zero (suc n) = cong suc (+-comm 0 n)

Agda requires a term of type zero + suc n ≡ suc n + zero. Since the term

zero + suc n is deﬁnitionally equivalent to suc n and suc n + zero is deﬁnition-

ally equivalent to suc (n + zero), Agda replaces these terms by their deﬁnitions

automatically and requires, instead, a proof of suc n ≡ suc (n + zero).

In our

informal proof, we used the fact that suc is a function. We do so in our Agda proof

as well by using the cong function. We supply it our function, suc, and we then need

to provide a term (or proof) of type n ≡ n + zero as the second argument to cong.

We provide the second argument via recursion, imitating the induction step in our

informal proof. The proof of suc(m) + 0 = 0 + suc(m) is similar.

Finally, we show that suc(m) + suc(n) = suc(n) + suc(m). To this end, we

recursively deﬁne +-comm on the arguments suc m and suc n.

20

+-comm (suc m) (suc n) = begin
≡〈 refl 〉

suc m + suc n
suc (m + suc n) ≡〈 cong suc (+-comm m (suc n)) 〉
suc (suc n + m) ≡〈 refl 〉
suc (suc (n + m)) ≡〈 cong suc (cong suc

(+-comm n m)) 〉

suc (suc (m + n)) ≡〈 refl 〉
suc (suc m + n) ≡〈 cong suc (+-comm (suc m) n) 〉
suc (n + suc m) ≡〈 refl 〉

suc n + suc m

Thankfully, someone built an equational reasoning package in Agda.

It pro-

vides a convenient and readable syntax that looks much like our informal proof.

Such a proof starts with the begin keyword and ends with the QED symbol

,

requiring various steps in between. The most notable diﬀerence is that instead

of writing the equation ﬁrst and the reason after, we write one side of the equa-

tion, the reason, then the other side of the equation. For instance, the step that

suc m + suc n ≡ suc (m + suc n) is proved via refl, and is read, in the Agda

proof, like “suc(m) + suc(n), by reﬂexivity, is equal to suc(m + suc(n))”.

The reader may wonder if it is necessary to apply the reﬂexivity steps in our

equational proof. The answer is no: They may be removed, since Agda computes all

terms to their deﬁnitions automatically. Our ﬁnal deﬁnition of +-comm thus looks like

the following.

21

+-comm : (m n : N) → m + n ≡ n + m

+-comm zero zero

= refl

+-comm zero (suc n)

= cong suc (+-comm 0 n)

+-comm (suc m) zero

= cong suc (+-comm m 0)

+-comm (suc m) (suc n) = begin

suc (m + suc n) ≡〈 cong suc (+-comm m (suc n)) 〉
suc (suc (n + m)) ≡〈 cong suc (cong suc

suc (suc m + n) ≡〈 cong suc (+-comm (suc m) n) 〉

(+-comm n m)) 〉

suc n + suc m

where open ≡-Reasoning

Lastly, we note the where open ≡-Reasoning string. The where clause opens

a new block of code local to the function being deﬁned, which retains access to the

variables and terms being used by the function (such as its parameters).

Inside

a where clause, we can deﬁne functions, prove lemmas, or, in this case, open the

≡-Reasoning package that lets us use the equational reasoning format shown.

The reader, perhaps noticing how often we state that “Agda reduces these terms

automatically, so we prove [this other equation] instead”, may wonder if the user has to

mentally track what is being proved, and how horriﬁc this must be in cases where the

proofs are much more complex! Perhaps Agda’s greatest feature is its interactive mode

for the Emacs environment, built to solve these kinds of inconveniences. Consider

the proof of 0 + suc(n) = suc(n) + 0. When writing the corresponding deﬁnition of

+-comm, the user may replace the right side of the deﬁnition by a hole, represented

by { }.

+-comm zero (suc n) = { }

If the user clicks the hole, they have at least three options, depending on the

keyboard command they enter. One, they could view the current goal in an Emacs

subwindow, which is what must be proved (the subwindow also shows the variables

and hypotheses the user has access to for the function they are deﬁning). Two, they

could enter a term, and by entering diﬀerent commands Agda will display its type

and compute its value. And three, once a term is entered and satisﬁes the goal, the

22

hole may be reﬁned, replacing the hole by the term given and completing the user’s

proof or deﬁnition.

There are a number of other features regarding Agda’s interactive Emacs mode,

but holes are perhaps the most convenient. Without them, the user would have to

keep track of potentially thousands of goals and potentially massive types mentally

or on paper!

The reader may wonder, “What else can Agda automate? Surely it is not just

deﬁnitions!” Indeed, Agda can automate entire proofs in some cases. For instance,

the Agda standard library contains a ring solver which, given a (true) ring equation,

provides a proof. The precise function of the ring solver is beyond the scope of this

thesis, but it essentially takes both sides of a polynomial equation, reduces them to a

form called a Horner normal form, and checks that the forms of both sides are equal

by reﬂexivity. Of course, the ring solver is itself programmed in Agda, so not only

does Agda provide this excellent feature, it also proves its validity.

So far, we have seen basic data types, inductive proofs, the package system, and the

immense amount of automation in the forms of replacing terms by their deﬁnitions,

ring solvers, and holes. We have exploited the computational features of the type

system, recursion, and an IDE-like environment. The vast power of Agda does not

end here. For instance, the cubical Agda mode enables the use of homotopy type

theory. To learn more about what Agda has to oﬀer, please visit the course at [13]

and Agda’s documentation at [1].

4.3 Problems with Agda

4.3.1 Canonicity

We say that our type theory has canonicity if every term can be reduced to some

canonical form (e.g., via a series of β-reductions applied to the term). Agda, for

instance, has canonicity.

Canonical forms are extremely useful in proof assistants. Reducing two terms to

their canonical forms, for instance, can help us decide if they are equal. Consider

the proof that 0 + 1 equals 1 + 0. Because Agda computes both 0 + 1 and 1 + 0 to

their canonical form, 1, we can easily state that the two are equal by reﬂexivity. The

ring solver also relies, to some extent, on canonicity, as it computes the two sides of

an equation into their canonical forms and checks for reﬂexivity to decide if they are

equal.

Losing canonicity can be problematic. However, it can be equally, if not more
problematic to preserve canonicity entirely. Let us deﬁne a function f : R → N such

23

that

f (x) =




0 if x = 0,



1 if x (cid:54)= 0.

Since, in general, it is impossible to decide whether or not a real number x equals

0, f (x) may never be computed. Thus an equation about natural numbers involving

f (x) may not reduce to a canonical form, and we may be unable to use reﬂexivity in a

proof involving f (x). If we decide to preserve canonicity and forbid such deﬁnitions,

we naturally must abandon axioms like the law of the excluded middle (LEM). The

addition of axioms, in general, will extinguish canonicity. Preservation of canonicity

at all costs is thus an extreme form of constructivism.

However, the extent to which canonicity is an issue is dependent on the mathe-

matics being done and on the programming. Mathematics that signiﬁcantly relies on

axioms and LEM will naturally face canonicity issues in a proof assistant. It is the

point of Bishop’s constructive analysis that analysts are not as bound to LEM as we

may believe. For instance, we usually deﬁne the absolute value |x| of a real number

x by

|x| =




x

if x ≥ 0,



−x if x (cid:3) 0.

If we then wish to prove |x| < y by proving that x < y and −x < y, we need to invoke
LEM to decide whether x ≥ 0 or x (cid:3) 0. An alternative (and classically equivalent)

constructive approach exists. We can easily deﬁne the maximum of real numbers x

and y constructively by

and thus deﬁne

(max{x, y})n = max{xn, yn}

|x| = max{x, −x}.

24

Using properties of regular sequences, we can show that if x < y and −x < y,

then |x| < y. This time, LEM is unneeded. Bishop details many more examples

where LEM is unnecessary. Hence, canonicity issues are, to a possibly great extent,

dependent upon the implementation of our mathematics.

Sometimes, it is useful to forego canonicity for reasons other than the kind of

mathematics being done or the mathematician’s technique. For the sake of perfor-

mance, we often want our terms to not compute to a canonical form! For example,

consider the Archimedean property.

If all we care about is that some natural N

greater than a ﬁxed real number x exists, and not explicitly what N is, why waste

time computing N when we can extract this information from the statement of the

Archimedean property itself? There are practical cases where computing N takes

days, even in our own constructive analysis library (the Archimedean property is a

nuisance for performance in particular). Agda thus allows us to mark functions as

abstract, meaning they will not be computed, but their types can still be used and

manipulated as desired.

4.3.2 Setoids and Quotient Sets

In Chapter 3.2, we noted that, in some sense, quotient sets are constructively redun-

dant. But a user doing classical mathematics in Agda would probably like to use

quotient sets. Unfortunately, adding quotient types to Agda can break canonicity. In

modern proof assistants that focus more on classical mathematics, like Lean, types

representing quotient sets, known as quotient types, are axiomatized, and canonicity

is lost. Thus Agda users (and many proof assistant users in general) who wish to

emulate quotients without losing canonicity typically resort to using Bishop’s con-

ception of a set, described in Chapter 3.2. For the sake of clarity, Bishop’s sets are

widely referred to as setoids. Thus, a setoid is (classically) a set equipped with an

equivalence relation on its elements.

But setoids are impractical, to the extent that the proof assistant community

coined the term “Setoid Hell” to refer to their use. For a given set S with an equiv-

alence relation ∼, the quotient of S by ∼ enables us to discuss equality of elements

of S without referring to ∼, which is hidden behind equivalence classes. But without

quotients, we need the equivalence relation ∼ to discuss any meaningful notion of

25

equality on S. Instead of one notion of equality, we have one for each set, which is

obviously quite cumbersome.

For Agda users, there is a third alternative, in which quotients can be deﬁned

without losing canonicity: cubical Agda. Homotopy type theory (HoTT), and the

“univalent foundations for mathematics” in general, is an alternative foundation of

mathematics formulated chieﬂy by the Fields medalist Vladimir Voevodsky. A de-

scription of HoTT is far beyond the scope of this thesis. Readers interested in HoTT

should refer to [14]. Cubical Agda essentially uses HoTT, unlike normal Agda which

uses a version of Martin-L¨of’s intensional type theory.

The version of HoTT that comes with cubical Agda can be used to represent

quotients without breaking canonicity. However, swapping foundations may seem

heavy-duty. Moreover, the status of HoTT as a foundation for mathematics is still

debated. But at present, cubical Agda is the only way to obtain quotients while

preserving canonicity.

4.3.3 Conclusion

The issues of canonicity and quotient types are likely to be far removed from many

mathematicians’ research. But anyone using Agda as a proof assistant is bound to

encounter these problems eventually, on top of any issues with performance that

naturally come with Agda being a programming language. Theoretical problems

made practical like these show us that proof assistants are not as ready to replace

LATEX as a proof assistant expert would like. But it is a testament to the usefulness
and potential of proof assistants that, despite these issues, their communities and

their libraries are growing quickly. For instance, the Lean proof assistant began at

Microsoft Research, and the Agda standard library has a growing category theory

library [7]. Regardless of whether or not proof assistants replace LATEX, their use in
proving otherwise unwieldy results like the four colour theorem [5] shows that using a

proof assistant is a useful skill, one that often lies at the intersection of programming

and mathematics.

Chapter 5

Constructive Analysis in Agda

We will now discuss our constructive analysis library in Agda. From Bishop and

Bridges’ Constructive Analysis, we have completed sections 2 and 3 of Chapter 2

(save a couple of minor exceptions), thus covering the real numbers and their basic

properties (including uncountability), and results regarding sequences and series (such

as Cauchy completeness and tests for convergence). Some work on the following

section, covering continuity, was also done. Finally, a plethora of lemmas, corollaries,

theorems, and propositions not present in Constructive Analysis were proved. Many

were required to prove results from Constructive Analysis but were not given in the

book, while others helped automate portions of proofs or improved performance. The

library can be found at [11]. The exact list of ﬁles is as follows.

File Description

RealProperties.agda

NonReﬂective.agda
NonReﬂectiveQ.agda
NonReﬂectiveZ.agda
Real.agda

File Name
ExtraProperties.agda A collection of extra properties about naturals, integers,
and rationals that were useful in the rest of the library.
The base ring solver ﬁle.
The ring solver instantiated for the rational numbers.
The ring solver instantiated for the integers.
Deﬁnition of the real numbers, arithmetic operations,
and ordering.
Properties of the real numbers, like arithmetic proper-
ties and the density of the rationals.
The deﬁnition of the multiplicative inverse and a number
of its properties.
The proof that the continuum is uncountable.
Deﬁnitions and properties regarding sequences and se-
ries, including results like the algebraic limit theorem
and Cauchy completeness.
Some work on deﬁning metric spaces. Incomplete.
Some work on the deﬁnitions and properties of continu-
ity. Incomplete.

Uncountability.agda
Sequence.agda

MetricBase.agda
Continuity.agda

Inverse.agda

Table 5.1: Agda ﬁles in the library.

26

27

5.1 Why Constructive Analysis?

Readers with little or no experience in Agda may wonder why someone would for-

malize results from constructive analysis. There are two distinct questions: One, why

analysis? And two, why constructive analysis?

I selected analysis because there is very little analysis in Agda. Agda users tend

to be varying kinds of computer scientists, algebraists, and programmers. The math-

ematics they usually focus on, like category theory, requires little or no analysis.

Hence, analysis is ignored.

I chose Bishop’s constructive blend of analysis mainly for convenience. Recall the

problems with axioms and canonicity in Agda. Classical analysis is highly reliant

on non-constructive axioms. Thus classical analysis does not ﬁt into the highly con-

structive setting of Agda as neatly as constructive analysis. If constructive analysis

cannot be formalized in Agda, there is no hope for classical analysis!

5.2 What Libraries Do We Need?

Considering that Bishop’s reals are deﬁned as regular sequences of rational numbers,

we obviously need integers and rational numbers. On top of these, we need some logic

and basic automation tools for simple proofs. Conveniently, everything we needed was

already present in the Agda standard library.

While the Agda standard library, at the time of writing, lacks analysis (and real

numbers in general), it is rich in logic, integers, rational numbers, and various tools

to automate the proofs of statements about each of these topics. The Brouwer-

Heyting-Kolmogorov interpretation is native to Agda, and many other tools of logic

are implemented by fellow Agda users in its standard library. The basic theory of

functions and relations is spelled out richly. The integers are implemented rather

nicely as an extension of the natural numbers (as previously deﬁned) and their most

important basic properties are proved and ready for use. Of course, as already men-

tioned in Section 4.2, the ring solver is available for automating the proof of valid

ring equations.

On the other hand, there are two versions of the rational numbers in the Agda

28

standard library. The normalized rationals require that the numerator and denomi-

nator be coprime, while the unnormalized rationals do not. Requiring that the nu-

merator and denominator be coprime can place a large proof burden on the user. It

is rare in informal mathematics, let alone formalized mathematics, to write a fraction

with its numerator and denominator coprime. The normalized rationals thus include

a function to automatically reduce a fraction to such a form. But this process can

be computationally expensive. The normalized rationals are thus ineﬃcient for our

purposes. Hence, we use the unnormalized rationals.

With all of this, along with all of the Agda standard library’s syntactic sugar, it

was easy to start working on Bishop’s constructive analysis right away.

5.3 The Real Numbers and Software Engineering

We now turn to the deﬁnition of the real numbers in Agda. In particular, we will

discuss some software engineering used to improve their usability and the library’s

overall performance.

We note that the deﬁnition of a Bishop real number and equality on Bishop reals

was ﬁrst formalized in Agda by Martin Lundfall [9]. However, Lundfall’s library only

proved some very basic results, up to the fact that the Bishop’s deﬁnition of real

number equality is an equivalence relation. Our library, as previously mentioned,

is much more extensive. We thus compare and contrast the engineering behind my

implementation of Bishop’s reals and Lundfall’s implementation.

Recall that a real number, in Bishop’s sense, is a pair consisting of a sequence of

rationals and a proof that the sequence is regular. To represent this pairing in Agda,

we use a record type.

record R : Set where
constructor mkR

field

seq : N → Qu
reg : (m n : N) {m(cid:54)≡0 : m (cid:54)≡0} {n(cid:54)≡0 : n (cid:54)≡0} →

Q.| seq m Q.- seq n | Q.≤
(+ 1 / m) {m(cid:54)≡0} Q.+ (+ 1 / n) {n(cid:54)≡0}

29

Note that this deﬁnes a set called R. Real numbers have ﬁelds (like how a Java

object has ﬁeld variables) called seq and reg, which represent a sequence of rationals

and a proof that the sequence is regular, respectively. For convenience, a constructor
mkR is provided, so that a real number with sequence xs : N → Qu and proof of
regularity P may be constructed by writing mkR xs P.

We note that Qu represents the type of unnormalized rational numbers, as previ-

ously deﬁned. To use, for instance, addition of rational numbers in the type of reg,
we write Q.+. The Q. represents that we are using rational number addition, not

real number addition. Unfortunately, we could not overload the addition operator

to write just + for each kind of addition. The same goes for the other arithmetic

operators.

We note a subtlety in the type corresponding to regularity. Rational numbers

require denominators to be nonzero, so for each denominator, we must provide a

proof that it is nonzero. Thus for the natural number m we must provide a proof

m(cid:54)≡0 : m (cid:54)≡0 that it is not nonzero. The curly braces in {m(cid:54)≡0 : m (cid:54)≡0} represent

that the proof that m is nonzero is implicit. Agda will attempt to automatically prove

implicit parameters. Indeed, since the natural numbers are recursively deﬁned and

a natural number is nonzero when it is of the form suc n, Agda will immediately

recognize any natural number written in this form as nonzero. Thus, Agda does not

require the user to provide this proof when writing reg on natural numbers of the

form suc n. This also means that when writing a fraction + 1 / m as above, we need

not supply the proof that m is nonzero if it is written in the form suc n. We only

needed to supply the proof that m was nonzero in the regularity type because m does

not compute to a form suc n in the type given.

The regularity type in Lundfall’s deﬁnition did not require proofs that the natu-

rals m and n are nonzero. Lundfall’s solution was to write suc m and suc n in the

denominators instead of m and n [9, p. 10]. As a result, Lundfall’s deﬁnition looks

somewhat cleaner.

Initially, we used the same strategy as Lundfall. But we found that given natural

numbers of the form k that were not deﬁnitionally equivalent to a natural number

of the form suc n but were nonetheless nonzero, it was diﬃcult to write the fraction

of + 1 / k instead of + 1 / (suc k). This required a lot of additional work with a

30

predecessor function, the result of which was not deﬁnitionally equivalent to + 1 / k.

Thus, Lundfall’s strategy was more diﬃcult to use in practice.

Equality of real numbers is deﬁned as a dependent data type, where the type

constructor *(cid:39)* can be used to construct a proof of x (cid:39) y.

data _(cid:39)_ : Rel R Level.zero where

*(cid:39)* : {x y : R} → ((n : N) {n(cid:54)≡0 : n (cid:54)≡0} →

Q.| seq x n Q.- seq y n | Q.≤ (+ 2 / n) {n(cid:54)≡0}) →

x (cid:39) y

First, we note that the type Rel R Level.zero simply means that equality of
real numbers is a relation on R. Next, note that the real numbers x and y are implicit
when calling the type constructor *(cid:39)*. Given the proof that |xn − yn| ≤ 2
n, which
is also a parameter of *(cid:39)*, along with the given goal (that we must prove x (cid:39) y),

Agda can deduce what it needs to write for the x and y parameters. Thus they are

left implicit.

Lundfall’s equality was not implemented as a data type. Instead, the type x (cid:39) y
n for all n ∈ N, as follows [9, p. 10].

was deﬁned to be the proposition that |xn − yn| ≤ 2

_(cid:39)_ : Rel R Level.zero
x (cid:39) y = (n : N) →

Q.| seq x n Q.- seq y n | Q.≤ + 2 / (suc n)

There is the noted issue that the denominator of 2

n is written as suc n. But more
importantly, this deﬁnition is unfriendly towards implicit real number arguments. The

function that proves reﬂexivity of equality is called (cid:39)-refl. With our deﬁnition, given

any real number x and the goal x (cid:39) x, we can write just (cid:39)-refl to prove x (cid:39) x,

thus leaving the argument x implicit. With Lundfall’s deﬁnition, this is impossible.

We must write the x argument, thus writing (cid:39)-refl {x}. This is a technical issue

regarding dependent types deﬁned as a data type (i.e., using the data keyword) and

deﬁning types in the style of Lundfall. We will not go into the details, but being

unable to leave x implicit becomes extremely problematic when using the ring solver

for the real numbers. Like our deﬁnition of the reals, our deﬁnition of equality is

easier to use and is more maintainable in practice, even if the deﬁnition itself looks a

little more complex.

31

When it comes to properties of the real numbers, such as the Archimedean prop-

erty, my Agda formalization usually provides a normal and a “fast” version. For in-
stance, the normal version of the Archimedean property is written archimedean-R,
and the fast version is written fast-archimedean-R. The fast version is marked as

abstract, which, as mentioned in Section 4.3.1, allows the user to manipulate the

type of the marked function (corresponding to the Archimedean property, in this in-

stance) without computing the function. This is a signiﬁcant performance boost. On

a Macbook Pro 2021 with an M1 Pro and 16GB of RAM, the library takes around a
minute to typecheck when marking functions, like fast-archimedean-R, as abstract.

Without marking them abstract, it takes several hours.

We have thus discussed some of the software engineering behind our library. There

were many more decisions and problems similar to those we have discussed. But it

would be far outside the scope of this thesis to discuss them all.

5.4 Future Work

A quick glance at [2] will show the reader that our library, at the time of writing, only

covers somewhere between thirty and forty pages out of over four hundred. Thus,

there is plenty of work to be done! Most importantly, the theories of diﬀerentiation

and integration of functions of a real variable must be completed.

There is also plenty of refactoring to do, as there is with any library. In particular,

there is a lot of notation that was introduced later on in the project or modiﬁed that

must be added to older work.

It may be interesting to modify the library to work in cubical Agda. However,

there are deﬁnitions of the real numbers in homotopy type theory that are preferable

to Bishop’s, so such a project may ultimately be pointless.

The ring solver was immensely useful in this project. We wonder if a general

inequality solver could be built. At the moment, every time the triangle inequality is

used it must be directly cited, never left implicit or automatically used. Of course,

analysts often implicitly use the triangle inequality in sequence with a number of

other inequalities. Such an inequality solver would be immensely useful.

It is interesting to note that a general inequality solver exists in the Lean proof

assistant [10]. Known as the linarith function or “tactic”, it assumes that the

32

inequality to be proved is false and checks if it contradicts a true proposition in

the context (e.g., a hypothesis). Obviously, the strategy of linarith will not work

constructively. We do not know if a constructive strategy exists. It is interesting that

constructivism may, in some sense, be antithetical to computation in this case.

Finally, now that a constructive theory of real numbers has been successfully im-

plemented, it is high time for a classical theory of real numbers to be implemented.

The extent to which problems like canonicity aﬀect the classical reals should be stud-

ied, since it may make classical analysis in Agda untenable. Such a study may only

be valuable to Agda’s designers, since the Lean standard library contains virtually ev-

erything from undergraduate classical analysis along with a number of useful solvers

(like linarith) [3]. Once a classical analysis library is complete in Agda, it would be

worth comparing it to the Lean implementation to see which is more maintainable

and eﬃcient, since proofs in each language tend to look extremely diﬀerent, even if

their content is the same. It may be deeply interesting to try and implement many of

Lean’s solvers in Agda, thus comparing their metaprogramming capabilities. It will

be interesting to see how these two major proof assistants compete in the future.

Bibliography

[1] Agda Documentation. Available from: https://agda.readthedocs.io/.

Accessed: Apr. 10, 2022.

[2] E. Bishop and D. S. Bridges, Constructive Analysis. Comprehensive Studies in

Mathematics, vol. 279. Springer, 1985.

[3] K. Buzzard, What Maths is in Lean? Blog post, Xena Project, Sep. 30,
2020. Available from: https://xenaproject.wordpress.com/what-maths-is-
in-lean/. Accessed: Apr. 10, 2022.

[4] The Coq Proof Assistant. Available from: https://coq.inria.fr/. Accessed:

Apr. 10, 2022.

[5] G. Gonthier. Formal proof — the four color theorem. Notices of the American

Mathematical Society, 55(11):1382–1393, 2008.

[6] J. van Heijenoort, From Frege to G¨odel: A Source Book in Mathematical Logic.

Harvard University Press, 2002.

[7] J. Z. Hu and J. Carette, Formalizing category theory in Agda, In: Proceedings
of the 10th ACM SIGPLAN International Conference on Certiﬁed Programs and
Proofs, pp. 327–342, Association for Computing Machinery, 2021.

[8] R. S. Lubarsky, On the Cauchy completeness of the constructive Cauchy reals,

Electronic Notes in Theoretical Computer Science, 167:225–254, 2007.

[9] M. Lundfall, Formalizing Real Numbers in Agda. Manuscript, 2015. Avail-
able from: https://wcl.cs.rpi.edu/pilots/library/papers/TAGGED/4211-
Lundfall (2015) - Formalizing Real Numbers in Agda.pdf.
Accessed: Apr. 10, 2022.

[10] L. de Moura, S. Ullrich. The Lean 4 Theorem Prover and Programming Lan-
guage. In: Proceedings of the 28th International Conference on Automated De-
duction (CADE 28), Pittsburgh, U.S.A., Springer Lecture Notes in Computer
Science 12699, pp. 625–635, 2021.

[11] Z. Murray, Constructive Analysis in Agda. Agda code, Apr. 2022. Avail-
able from: https://github.com/z-murray/honours-project-constructive-
analysis-in-agda.

[12] R. Nederpelt and H. Geuvers, Type Theory and Formal Proof: An Introduction.

Cambridge University Press, 2014.

33

[13] P. Selinger, Lectures on Agda, 2021. Available from: https://www.mathstat.

dal.ca/~selinger/agda-lectures/. Accessed: Apr. 10, 2022.

[14] The Univalent Foundations Program, Homotopy Type Theory: Univalent Foun-
dations of Mathematics, Institute for Advanced Studies, 2013. Available from:
https://homotopytypetheory.org/book.

34

