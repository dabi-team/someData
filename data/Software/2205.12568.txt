THE SECURITY OF THE COORDICIDE: THE
IMPLEMENTATION AND ANALYSIS OF POSSIBLE

ATTACK VECTORS

MASTER THESIS

Daria Dziubałtowska
The Wrocław School of Information Technology, Wroclaw, Poland
IOTA Foundation, Berlin, Germany
daria.dziubaltowska@iota.org

March, 2022

A thesis submitted in partial fulﬁlment of the requirements for the degree of Master in Computer
Science

Developed under supervision of
Paweł Morawiec, PhD

and industrial supervision of
Andreas Penzkofer, PhD

ABSTRACT

The goal of the thesis is to study and perform an analysis of the possible attack
vectors on the Iota network 2.0 version of the protocol. In this work existing attack
vectors on Distributed Ledger Technologies are studied and their applicability to the
Iota 2.0 protocol discussed. A speciﬁc attack that targets the capability of honest
participants to write to the ledger is presented and analysed in a network of nodes
that run a full node software version.

Keywords DLT · Iota · Tangle · orphanage · attack vectors

2
2
0
2

y
a
M
5
2

]

R
C
.
s
c
[

1
v
8
6
5
2
1
.
5
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
Contents

Introduction

1 Theory and technical introduction

1.1 Distributed Ledger Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.1.1 Eight fallacies of distributed systems . . . . . . . . . . . . . . . . . . . . .

1.1.2 Asynchronicity and partial synchronicity of the system . . . . . . . . . . .

1.1.3 CAP theorem .

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.1.4 Consensus

.

. .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3

5

5

5

7

7

8

1.1.5

FLP impossibility theory . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

1.1.6 Byzantine Fault Tolerant Systems . . . . . . . . . . . . . . . . . . . . . . 11

1.2 Directed Acyclic Graph .

1.3

Introduction to IOTA .

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

1.3.1 The pre-Coordicide IOTA . . . . . . . . . . . . . . . . . . . . . . . . . . 14

1.3.2 The reason for Coordicide . . . . . . . . . . . . . . . . . . . . . . . . . . 15

1.3.3 The Tangle . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

1.3.4

Protocol evolution over time . . . . . . . . . . . . . . . . . . . . . . . . . 20

2 Attack vectors review

22

2.1 Review of known attack vectors

. . . . . . . . . . . . . . . . . . . . . . . . . . . 22

2.1.1 Threats in the network layer

. . . . . . . . . . . . . . . . . . . . . . . . . 23

2.1.2

Sybil attacks

. .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

2.1.3 Byzantine fault and agreement failure . . . . . . . . . . . . . . . . . . . . 27

2.1.4 Cryptography vulnerabilities . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.1.5 Exploits on the protocol structures . . . . . . . . . . . . . . . . . . . . . . 30

2.2 Orphanage problem .

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

1

MASTER THESIS

2.2.1

IOTA and orphanage in the past

. . . . . . . . . . . . . . . . . . . . . .

. 32

2.2.2 Orphanage problem now . . . . . . . . . . . . . . . . . . . . . . . . . .

. 33

2.2.3 Orphanage attack .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 34

2.2.4 Blow Ball attack .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. 38

3 Experimental validation of the orphanage attack

40

3.1 Experiment setup .

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

3.1.1 Technical details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

3.1.2

Plan of the experiment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

3.1.3 Adversarial behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

3.2 Results .

.

.

.

.

.

.

.

.

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

3.2.1 Restriction on the parents’ age. . . . . . . . . . . . . . . . . . . . . . . . . 47

3.2.2 Tip pool size inﬂation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

3.2.3

Similarities to blowball attack . . . . . . . . . . . . . . . . . . . . . . . . 50

3.2.4 Tip pool size linear growth . . . . . . . . . . . . . . . . . . . . . . . . . . 50

3.2.5 Orphanage .

.

.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

3.2.6

Impact of changing the ζ parameter.

. . . . . . . . . . . . . . . . . . . . 52

Conclusion

Appendix A - complete experimental results

55

61

2

Introduction

The main goal of the thesis is to reason about the security of the IOTA protocol with an emphasis
on the orphanage problem. The main focus will be put on the newest prototype version of the node
software, commonly referred to as the ”Coordicide” solution, which is still in the research phase.

The topic of distributed systems is one of the oldest branches of computer science. Many famous
insights and proofs introduced in the early days of computers are still being used on a wide scale.
Many families of protocols designed to ensure an agreement among many distinct processes or
network participants have their beginning in the previous century. A brilliant example is the
Byzantine Failure protocols which constitute a large part of many currently developed blockchain
projects. With the emergence of blockchain technology, distributed systems have experienced
a revitalization in interest. Nakamoto’s consensus introduced in 2007 awakened scientists and
engineers to look for new ways to redesign the web again, to create a space in which system users
have full control over their data. All of this is happening with the usage of cutting-edge technology
that feeds from many ﬁelds of study, such as cryptography, distributed systems, ﬁnance, and many
others. The success of early cryptocurrency projects has brought blockchain technology to the
attention of many investors, developers, and innovators and has enabled an incredible amount of
development and research in this ﬁeld. We are in the moment where blockchain is no longer only
an investment, hype, or buzzword, as there are thousands of projects, platforms, and applications
currently developed that are focusing on security and decentralization. With increased usage it
becomes harder to follow all the changes, to validate new ideas, thus many new design ideas are
subject to activities performed by dishonest parties, trying to make a proﬁt by exploiting network
vulnerabilities and ﬁnding gaps in the protocols’ design. All of this contributes to the importance of
carrying out the research and testing before a system is brought into production.

One such innovative project is a cryptocurrency called IOTA, which has a quite distinctive approach
compared to other DLTs. Firstly, the IOTA protocol is being designed with speciﬁc principles in
mind to address non-trivial and novel challenges, such as solving scaling issues of blockchain and
creating a feeless Distributed Ledger Technology (DLT). All of this resulted in a unique design
compared to other projects. As a consequence, a completely new range of studies and research
questions need to be solved. Secondly, IOTA is still under development and its current ofﬁcial
production version of the network, called mainnet, is employing the IOTA 1.5 Chrysalis version 1.
However, this version of the protocol will not be the main point of this thesis, as the focus will be
laid on the in-development IOTA 2.0 version of the protocol, which is referred to as Coordicide.
The rationale behind choosing the version that is still under development is as follows: the new

1https://wiki.iota.org/chrysalis-docs/introduction/what_is_chrysalis

3

MASTER THESIS

version of the protocol is going to bring a vast array of changes, such that the majority of attacks and
malicious behaviors researched for the current stable version would no longer be applicable after
the protocol upgrade. Furthermore, since the upgrade of Coordicide will replace the current mainnet
software, the current version forms only a transition state to a more decentralized version. It is,
therefore, reasonable to focus on the analysis of and reasoning about the solutions in the current
prototype software. Additionally, to the theoretical analysis and review of currently known problems,
the major contribution of this work will be the implementation of selected attack scenarios and
performance studies in the presence of these. This is done under controlled, real network conditions,
to provide reproducible results about the impact it will have on the performance and robustness of
the IOTA network.

Structure of the thesis

In order to provide the reader with a sufﬁcient background needed for the understanding of security
issues that might be present in this protocol, the ﬁrst part of the thesis, Chapter 1 provides an
overview of distributed systems and introduces some of the most known problems that need to be
considered during the design phase of such a system. In Section 1.3 the IOTA protocol is portrayed
along with a brief history of how this technology has changed through the recent years. In Chapter
2 a review of existing research about known attack vectors and vulnerabilities of IOTA is performed.
Furthermore, existing problems in other blockchain-based solutions are examined to provide context.
The main point is presented in Section 2.2 where the orphanage problem is introduced. In Chapter 3
a practical demonstration of the discussed orphanage attack is presented by means of a simulation
in a real network setting. Results and a summary is provided in Chapter 3.

4

Chapter 1

Theory and technical introduction

1.1 Distributed Ledger Technology

Today’s world became data-driven – each day an enormous number of data is sent across the Internet.
All services that we use are backed up with millions of servers, machines, storage devices, and
other systems that silently support processes for exchanging information and control billions of
requests sent across all over the world. There is always a need for more computing power, resiliency,
and security, and that is precisely where distributed systems ﬁnd their applications. The existence
of a collection of machines working independently of each other, but sharing the same goal and
processes, might lead to multiple beneﬁts, such as sharing resources for efﬁcient utilization or
increased resiliency and robustness by eliminating the single point of failure. This vast group of
systems differs in their functionality. Different implementations may vary due to their openness and
transparency on who is allowed to access the system, and if users need special permissions. They
may allow for different levels of concurrency, processing certain functionalities at the same time.
Another important feature is the scalability of the system if it is able to grow and expand along with
an increasing number of system users. How are they distributed, is the network a collection of a
few big hubs or each machine is an equal participant? And ﬁnally, their fault tolerance: how many
single entities can fail before the whole system will fail?

In the next few sections, the most useful and well-known characteristics of distributed systems in
the literature will be presented to provide a background for understanding the more speciﬁc security
problems existing in DLT. In particular, in DAG-based systems, which include IOTA [1] – the
technology that is at the focus of this thesis.

1.1.1 Eight fallacies of distributed systems

In computer science, there is a generally known list of The Eight Fallacies for distributed systems
introduced by L. Peter Deutcha and James A. Gosling [2], which is pointing out the most common
false assumption made by engineers new to distributed applications. Reviewing them might help to
better understand the problems one might face during a new system design, which is spread across
many network instances.

5

MASTER THESIS

1. Reliability. The network is reliable - requests sent might fail and packets might be lost.
The system needs to be prepared for network outages, be able to handle failed requests
and multiple requests regarding the same action. This is especially important for ﬁnancial
systems. Hardware and software might fail due to bugs, updates, or faulty patches even in
today’s world, for which the recent outage in the Facebook network is a great example [3].

2. Latency is zero. - processing of database requests can be costly and takes several orders
of magnitude longer than processing a local request, which is often forgotten. Correctly
setting timeouts in communication with the database and requesting only the essential data
helps to avoid unnecessary latency in the program. All network calls shall be separated from
in-memory calls.

3. Bandwidth is inﬁnite. A bandwidth is a limit on how much data a network can process
at a given time. It can be controlled by the characteristic called network throughput. It
shows how much data was transferred during a given time range. In this case, the bandwidth
of a network will be the maximum possible network throughput. This problem becomes
especially apparent when a single component is responsible for all the processing in a certain
part of the system. Thus, it can impose constraints on the entire system. A limited bandwidth
might also be a result of the design decisions, e.g the bottleneck in blockchain-based systems
explained in Section 1.2.

4. The network is secure. This false assumption might lead to underestimation of the existing
threats and vulnerabilities present in the network and leave gaps in the overall security of the
system unnoticed. Therefore, it is reasonable to assume that some malicious third party is
always present, wanting to steal or alter the exchanged data. This is the topic that resonates
with the public the most, as it might lead to huge system and ﬁnancial failures.

5. Topology does not change. It assumes that all data sources will be always available, that
there are no network partitions. Unfortunately in the real world, servers might go down due
to many different reasons. The more distributed system is, the more likely this will occur.
This problem is partially present in the CAP theorem - consistency, availability, partition
tolerance (CAP) theorem, which will be covered in section 1.1.3.

6. There is one administrator. The fallacy of this belief becomes apparent when a failure
occurs in the system and identifying the responsible ones is not an easy task. Moreover, if
there is more than one administrator, introducing changes or collecting permissions might
be problematic. There is no single control entry that could force other network participants
to perform a task.

7. Transport cost is zero. This fallacy is related to the cost of maintenance and transport
over the network. That includes the cost of devices, access to the network, computational
resources consumed by the infrastructure, and the people responsible for the system.

8. The network is homogeneous. In the modern world it became clear that people might use
a variety of different devices to participate in the network, not all machines could have the
same processing power or similar speed of the network connection.

6

MASTER THESIS

Remembering the characteristics listed above can help in ﬁnding security ﬂaws and points of failures
of distributed systems. Negligence in any of those areas can open the possibility for an attacker to
take control over the network or at least disturb its continuous operation.

1.1.2 Asynchronicity and partial synchronicity of the system

One of the core characteristics of distributed systems is a lack of a global clock. There is no single
truth source about the time of the events happening in the system. All system components exchange
messages and there is always some non-zero network delay between issuing a message and receiving
it. Three main models for distributed systems can be distinguished:

• synchronous

• asynchronous

• partial synchronous

The synchronous model assumes that any message sent over the network will be delivered within
some known ﬁnite time ∆. However, using this kind of model would be problematic for two reasons.
Firstly, if we want to be sure that message will be delivered we would need to agree on some ﬁxed
timeout. If the value would be too large it will affect the performance of the system. On the other
hand, choosing too small ∆ could lead to safety violations.

The opposite approach is taken in the asynchronous model, in which there are no assumptions
about the delay of message delivery. However, the message will always be delivered eventually,
although the delivery time is unbounded. Whereas this solves the above issues, this model makes
the design of a robust system a much more complex task. Research in this ﬁeld had shown many
issues related to an agreement in the network, e.g. [4], where it is proven that reaching consensus in
an asynchronous system while one process fails unannounced would require an inﬁnite execution
time. Thus, in [5] the partially synchronous model was introduced. It is somewhere between the
synchronous and asynchronous models. It is supposed to guarantee the safety of the protocol,
without loosing liveness.

The partial synchronous model is deﬁned as follows: There exists a special event called Global
Stabilization Time (GST), which is characterized as:

• The GST event will eventually happen after an unknown ﬁnite time

• any message must be delivered before time ∆ + max(x, GST)∆ + max(x, GST), where x

is the time of a message issuance

1.1.3 CAP theorem

In 2000 at Conference on Principles of Distributed Computing (PODC) during his talk, E. Brewer
introduced the CAP theorem, where C stands for consistency, A for availability, and P for partition

7

MASTER THESIS

tolerance [6], which was proved two years later by S.Gilbert and N.Lynch in [7]. It stated that only
two of the following requirements can be met for distributed systems:

• Consistency (C) - in a consistent system operations are atomic and can either commit the
change to the database answering the user’s request or entirely fail, there is nothing in
between. A consistent system is behaving as a single entity.

• Availability (A) - available systems always respond, even if the requested data will not be
valid or most up-to-date. The main goal of the availability is that a service should be as
available as their underlying network with no interruptions due to server issues.

• Partition tolerance (P) - is about the endurance of the system in a faulty environment, and
still, be able to run even if certain parts of nodes will crush or a considerable amount of
packets will be dropped.

After more than twenty years have passed since the introduction of the CAP theorem, the understand-
ing of it and its implications have evolved along with an expansion of new technologies. Network
partitions do not occur often, so in a healthy environment, a service can provide both availability
and consistency without any trade-offs. Therefore, during network partitions, the choice between
availability and consistency has to be made. This compromise is possible because in reality the
system can be partially synchronous if the nodes have access to local clocks.

When taking into consideration the IOTA protocol, in the case of a network partition, the protocol
should be able to recover from disturbances caused by partition. Also, there should be no agreement
failure among the nodes. Data consistency is most essential to value-related messages or to any
other data that requires full consistency and cannot be changed once considered ﬁnal. In IOTA,
each node keeps its local copy of the Tangle and protocol-related data structures, see also Section
1.3.3. The data can be extracted from the node at any moment. However, there is no guarantee that
all nodes in the network will have the same view of the ledger. Thus, regarding the local data, it is
simply assumed through the partial synchronicity that each message eventually will be distributed
among all network participants. This is enabled by a component, called a solidiﬁer. It listens to all
incoming messages and checks if the node has in its local database all parents referenced by this
message. Whenever any parent message is missing, nodes request the missing message from their
neighbors, thereby improving the consistency of its local database (see Section 1.3.3). Nevertheless,
there are parts of the protocol that need to have an undisturbed consistency, the most important
of which are value transfers. There needs to be a certain point in time, after which we consider
data as impossible to change and be fully consistent among all nodes. To achieve that the time
for validation, voting in case of conﬂict, and other necessary steps are introduced, leading to the
sacriﬁce of data availability for the sake of its consistency.

1.1.4 Consensus

The consensus problem is the fundamental problem in the distributed systems ﬁeld. Assume
the system model in which processes are vertices of a connected graph and the links represent
connections through which messages can be exchanged between processes. The variation between

8

MASTER THESIS

different network models depends on the characteristics of the links, whether connections are reliable
(if a message can be lost), if processes might fail, and the time perception of each process. To model,
the connections between vertices, the asynchronous, synchronous, and partial synchronous model
described in Section 1.1.2 can be used.

In order to solve a consensus problem, the proposed consensus mechanism should fulﬁll the
following properties:

• Agreement. All the non-faulty processes need to decide on the same value.

• Termination. All decisions need to be made eventually.

• Validity. The decided value needs to be one of the initial values proposed by some process.

Consensus output. The consensus problems may have different levels of difﬁculty, based on
the assumptions and requirements imposed on the expected outcome. The consensus problem
describes the situation in which multiple processes need to cooperate in order to make a decision.
This decision might be to agree on certain single value (single-value consensus), to agree on a
single-digit 0, 1 (binary consensus), or on series of values (multi-value consensus). An example
of the decision might be a well-known problem of whether to commit transactions to the database
[8, 9].

Faulty processes. Another assumption is about the existence of faulty processes. Different types
of faults are distinguished. Firstly, the passive fault, where the process is collecting information
about the network but does not deviate from the protocol rules. The process that fails and stops
working without notifying the rest of the system is a crush. The next failure type is omission, where
the faulty process can omit some of the messages. A more difﬁcult scenario would be with the
existence of processes that do not follow the protocol, usually with an intention to damage the
system. They are traditionally called byzantine faults, the name was taken from the byzantine
generals’ problem [10] which will be described in Section 1.1.6.

Resiliency. The model can be also characterized by its resiliency, which is the maximum number
of faulty processes that can be tolerated in the system. Before the process of reaching the consensus
starts (might be called voting), each of the processes has the initial opinion, that is brought together
from all of the processes for an initial conﬁguration (state) of the system.

The speciﬁc system model is chosen based on the kind of characteristics desired for the system.
The difﬁculty of ﬁnding a solution to a consensus problem varies depending on this choice. De-
signing protocol that is fault-tolerant in the synchronous system will be much easier than in partial
synchronous, as, in the ﬁrst one, each message delay is limited with known by each process bound.
The same is for desired output decisions, the less complicated mechanisms will be required for
binary consensus that multi-value. Thus, proving that a certain algorithm or mechanism works with
stronger assumptions will usually be strong enough for a weaker consensus family. Diagram in
Figure 1.1 shows the discussed characteristics ordered by their difﬁculty.

9

MASTER THESIS

Figure 1.1: Characteristics of consensus, starting from the top: connection model, output decision,
fault types. Each chain is ordered from the least to the most difﬁcult for ﬁnding the solution.

Liveness and safety

The liveness and safety terminology is usually used to describe how the system is affected and the
mechanisms occurring during protocol execution. The meaning behind those terms can be read
intuitively as:

• Liveness. The ’good things’ do happen, the decision will be made, the action will be taken.

• Security. The ’bad things’ do not happen, careful decisions and the action is halted until

the solution is correct.

Liveness and security in a synchronous and asynchronous setting.
It is not possible to assume
network availability in the asynchronous setting. The reason is that even if all messages will
be ﬁnally delivered, their delay is unbounded so that one never knows if a certain message was
lost or has never been sent. The same issue relates to the liveness of the network, which can
not be guaranteed without any stronger assumption about synchronicity. On the other hand, the
synchronous model results in guaranteed liveness of the network, but the trade-off is the network
security, as too strict assumptions on the message delivery time can be broken in real-world
scenarios. The partial synchronous model can be seen as a golden mean between synchronous and
asynchronous assumptions, allowing for both liveness and security control.

Liveness and safety in consensus The two properties are quite often used with regard to con-
sensus protocols. They are both inseparable, any correct protocol aiming to solve a consensus
problem should not leave out any of those two properties. Without a security property, the consensus
agreement can not be reached. The same is for liveness, protocol that can not guarantee liveness is
violating the termination rule.

10

passivecrushommissionbyzantinesynchronouspartialsynchronousasynchronousbinarysingle-valuemulti-valueMASTER THESIS

1.1.5 FLP impossibility theory

As introduced in Section 1.1.4, the assumptions about an underlying network model can have a
great impact on what is theoretically possible in the network. There are many propositions on how
to reach a consensus in the synchronous system. However, for many years the topic of reaching
an agreement in an asynchronous setting was repeatedly discussed, without any solution. The [4]
brought this debate to an end. The proof introduced in this work is commonly referred as to FLP
impossibility. In this paper, Fischer shows that reaching consensus in an asynchronous model is not
possible. More speciﬁcally, given the solution to the consensus problem within an asynchronous
model and assuming that it is tolerant to just a single fault, it was proven that the execution time can
be inﬁnite. In order to solve the consensus problem all three requirements: termination, agreement,
and validity need to be met for all possible execution rounds. The FLP proof shows that agreement
and validity were provided, however, termination was not fulﬁlled. The proof was conducted for
very weak assumptions, such as:

• binary consensus

• crush faulty process

• agreement is reached when only some non-faulty nodes decides

Since the paper discusses a case with weak assumptions, the FLP impossibility covers also more
complicated cases. As a consequence, it is known that there is no protocol that could determin-
istically solve the consensus with the asynchronous model, as there always could be one initial
conﬁguration that will run forever.

Nevertheless, systems in the real world are usually not fully asynchronous. Thus, after the intro-
duction of the FLP impossibility, countless papers were presented, aiming to ﬁnd out how much
the asynchronous model can be modiﬁed to solve the problem. In [11] authors consider different
classes of the weakest failure detectors that solve the reliable broadcast that was proven to work in
an asynchronous system with a majority of correct processes [12]. They show that none of those
processes could be implemented in a partially synchronous model with only one failure.

1.1.6 Byzantine Fault Tolerant Systems

The term Byzantine Fault Tolerance (BFT) took its name from the well known Lamport’s paper [10]
where the concept of Byzantine failure is introduced based on an example of a thought experiment,
where a group of Byzantine Generals besieging the enemy’s camp needs to come to a consensus on
whether to attack or retreat. Generals communicate via signed messages and among generals, there
are traitors who are aiming to corrupt the plan by sending inconsistent messages and disrupting the
honest generals’ communication. The assumptions laid on messages are: messages are not lost, the
issuer of each message is known, and generals know when a message was omitted by others. Thus
the Byzantine fault is a fault in the system presenting different views to different observers and a
Byzantine failure occurs when the system fails due to a Byzantine fault.

The outcome of the generals’ problems was that for an operation to not fail 3m + 1 of generals are
needed for m traitors and that at least m + 1 rounds of message exchange are needed. Since the

11

MASTER THESIS

formation of the Byzantine General problem, it was a subject to many extensive studies that lead
to many BF T algorithms solving consensus under different conditions in a system with present
failures.

In [13] it is shown that the Byzantine Generals problem is not only a theoretical problem, and there
are many practical examples when it can be reﬂected in real systems. Therefore, either a system
is designed without the need for reaching consensus, or if when it is not possible, an appropriate
fault-tolerant consensus algorithm must be introduced to preserve system safety.

Practical Byzantine Fault Tolerance One of the most widely known BFT algorithms is Practical
Byzantine Fault Tolerance (pBFT) introduced in 1999 in [14]. The algorithm was designed with
a state machines model with faulty nodes (replicas) present in the system. The algorithm utilizes
the primary-backup technique [15] and introduces the role of the primary node (leader). All nodes
are sequentially ordered, and the rest of the nodes besides the primary are called secondary nodes
and can replace the primary in case of its failure. It works in a partial synchronous model and
guarantees the security in a presence of m faulty nodes out of a total 3m + 1, thus it provides safety
and liveness after the GST event. Replicas need to be deterministic – when given the same input
and being in the same state they should always produce the same result. All replicas must start with
the same state.

The goal is that all non-faulty replicas agree on the request execution order. The PBFT consensus
round roughly proceeds as follows:

1. primary node receives a request from a client,

2. the request is broadcasted by the leader to all secondary nodes,

3. all replicas execute the request and send the replay to the client,

4. the operation is terminated when a client receives m + 1 the same replies.

PBFT does not scale well as it requires extensive communication overhead (Onk), therefore the
number of nodes participating in the consensus shall be small. Also, it is susceptible to Sybil
attacks (more in Section 2.1.2) where a node can gain an advantage on the network by forging many
identities.

Other BFT algorithms many BFT algorithms variants are used in blockchain projects. The
Tendermint BFT algorithm uses PBFT in combination with Delegated Proof of Stake (DPoS) [16].
In contradiction to PBFT, Tendermint algorithm uses rotation for the leader role, therefore, the
leader change is a normal part of the algorithm, and not as it was in case of PBFT, the leader can
stay the same and is changed only in case of a failure, keeping a stable leader results in a smaller
message overhead. However, a malicious leader kept in place, poses a security threat. Therefore
the PBFT algorithm performs well in a permissioned setting, e.g. it is used in Hyperledger Fabric
blockchain [17].

12

MASTER THESIS

Another example is SBFT algorithm that by using threshold signatures reduces the message overhead
of the PBFT algorithm to linear complexity O(n) while providing about two times better throughput
and scalability than traditional PBFT [18].

1.2 Directed Acyclic Graph

Directed Acyclic Graph (DAG) is a data structure that is being widely used in distributed systems
DLT. It consists of vertices and edges, that can not create cycles, thus the whole structure allows to
move in one direction. DAG structure may consist of multiple parallel chains, the special case of
DAG is a single chain structure used in blockchain-based systems. Single chain structure allows for
total ordering of the data stored in vertices, however, the new vertices in the blockchain structure,
called blocks, cannot be added in parallel, which is known as a blockchain bottleneck. This problem
is the main source of blockchain scalability issues. Therefore, many systems started to use multi-
chain DAG, such as Hashgraph [19], Avalanche [20] or IOTA. A DAG-based system allows only for
partial-order, as the new vertices can be added to the structure simultaneously and it is not possible
to determine the total order without additional protocol rules. The DAG structure allows for efﬁcient
usage in the asynchronous setting where each network participant can have a different view of the
current state of the ledger due to delays present in the network.

Another important characteristic of DAG based system is the way value transfers are handled, the
two most popular concepts are:

• account-based – fund transfers are tracked via balance on the user’s accounts

• UTXO-based – funds are represented by the unspent outputs, which are the outputs from
the transactions that have not yet been spent. Funds are transferred by using unspent outputs
as an input to the transactions, which in turn creates new unspent outputs.

The security and irreversibility of the ledger are provided by the cryptographic functions and
protocol rules.

1.3

Introduction to IOTA

The idea behind IOTA was born in 2014 on one of the blockchain-related forums. The discussion
arose around the topic: why does it need to be a single chain of blocks? The Directed Acyclic
Graph was proposed to be used instead, which could allow for the creation of multiple conﬂicting,
individually valid branches. In principle, a DAG allows for simultaneous writes to the ledger and
the parallel processing of messages. After the conceptualization phase, the IOTA cryptocurrency
was created, to remove scaling issues and transaction fees, utilizing a new type of distributed ledger
structure. In 2015 S. Popov published ”The Tangle”[1], which established the backbone of IOTA.
After an initial funding phase of the ﬁrst version of the IOTA network went live in 2016 [21].

Designing a system is not an easy task. Along with a new design idea, many new questions emerge.
For example: who would validate transactions and data in the network, and what will be the

13

MASTER THESIS

incentive if there are no transaction fees? How should the protocol behave in case of conﬂicts,
and how should consensus be achieved? Additionally, a new design opens the possibility of new
unknown attack scenarios. Is the network secure enough and how to measure the health of the DLT?
To answer all those questions in-depth studies must be carried out along with the system stress
testing in practice. The IOTA protocol went through various stages of research and development.
Many protocol components have been changed up until this point. In the next sections, we are
going to explore this evolution and introduce core concepts of the protocol, that will be necessary
to understand attacks and vulnerabilities discussed in Chapter 2. We will explore the Coordicide
project which is the transition event for the update of the protocol to IOTA 2.0 that will be a major
software update and a big step for the IOTA network towards full decentralization.

1.3.1 The pre-Coordicide IOTA

Due to the novelty of this technology, the ﬁrst version of the IOTA needed some temporary solution
that could help with keeping the network safe during its infancy development period. In older
versions of IOTA, the Proof of Work (PoW) was used for limiting message throughput and for
consensus ﬁnding. Therefore, without a sufﬁcient amount of honest PoW the network would not be
able to sustain an attack from a powerful adversary that has a signiﬁcant amount of hashing power.
As a bootstrap mechanism, IOTA utilizes a centralized node, called the coordinator. The Coordinator
runs slightly modiﬁed software. It is a source of trust and every message that is conﬁrmed by the
coordinator is also valid for the rest of the network. The Coordinator node periodically issues
messages called milestones. These messages reference messages that are considered as voting
winners. IOTA was not the only cryptocurrency that decided to use such an interim state, another
example can be the Alert System in bitcoin [22].

Although it has been a couple of years from the introduction of the coordinator to the IOTA mainnet,
the Coordinator’s removal was always a big part of the protocol development road map. There are
many reasons why this centralized solution should not be included permanently, such as:

• it is a single point of failure

• theoretically it gives the foundation that is running the Coordinator a possibility to conﬁrm
transactions with chosen priority or halting the conﬁrmations of certain messages, which
should not be possible in an open and honest distributed system,

• IOTA users need to follow exactly one ofﬁcial coordinator if someone starts to follow any

malicious actor it might result in a fork,

• the coordinator might hinder problems with network scalability.

Indeed, there are real-world examples of the single point of failure threat, as it happened in the
past that Coordinator went down. Note that, the ledger consistency was not broken, as the rest
of the network kept processing transactions according to the protocol rules. However, transaction
conﬁrmations were halted until the Coordinator node was restarted.

14

MASTER THESIS

1.3.2 The reason for Coordicide

Taking into consideration all Coordinator drawbacks explained in the previous Sec. 1.3.1 it comes
with no surprise that removing the Coordinator will become one of the major objectives for the
IOTA’s further development. At the end of 2018 IOTA announced the Coordicide plans and test
network to validate their ideas. The ﬁrst proposal for a Coordicide solution was provided in
Barcelona in 2019. The whole new protocol was imagined and outlined, changing the fundamental
assumptions. As the approach was a new design, testing was crucial, which created the necessity
for a test network with a full node implementation. Thus, soon after the summit, the GoShim-
mer prototype implementation started. GoShimmer is the ﬁrst prototype node software for the
Coordinator-free IOTA network. Along with practical development, the team started to work on the
topic from the theoretical point of view, so the next major step was to summarize all theoretical
concepts in the Coordicide whitepaper [23] published in 2020, which was supposed to establish
more organized, comprehensive explanation and provide more technical details needed for future
real-world implementation.

Currently, the GoShimmer software, many versions later has much progressed, bringing it into a
state where, together with a large array of analysis tools, scientiﬁc studies can be performed. With
the current state of the node software, it is now possible, to validate the perceived theoretical ideas
and test performance. At present, the prototype software is used not only by IOTA Foundation but
also by the community members willing to help with testing the Coordicide progress. This enables
a more rapid identiﬁcation. The ﬁrst full working prototype version of Coordicide was released in
April 2021 on the DevNet and up to the time of writing this paper has resolved many conﬂicts and
has processed many messages, proving that the Coordicide development came long impressive way.
In regards to the analytical discussion, the role of GoShimmer as a tool to validate the theoretical
ideas has an important task: it allows for testing theoretical problems such as attack vectors in a
more controllable and real network environment. The test network node software is provisioned
with quite wide support for metrics and measurements collections. This allows measuring how the
protocol behaves under different circumstances and can be used to ﬁne-tune the best set of default
parameters for the protocol. Or as in the case in this work, to perform the certain attack scenario
and analyze the results of the experiment with a help of data collected by the GoShimmer software.

1.3.3 The Tangle

The Tangle is the core structure of the IOTA protocol. It is DAG structure in which vertices are
made up from messages and where messages reference each other. We call the referenced message a
parent. Each node has its local version of the Tangle and updates it based on the messages received
from its neighbors. To add a new message to the Tangle, a node has to select and reference (approve)
k other parent messages that are already part of the Tangle. Messages at the end of the Tangle data
structure that has not yet been approved are called tips. All messages that directly or indirectly
reference a message are called its future cone. And respectively, all messages that are directly or
indirectly referenced by a message are called its past cone. The Tangle structure has its beginning in
the message called the genesis. A graphical representation of the Tangle is presented in Figure 1.2

15

MASTER THESIS

Figure 1.2: The Tangle. The past and future cone of the grey message are shown. Tips are marked
in orange.

(a) The simpliﬁed message layout.

(b) The simpliﬁed transaction layout.

Message

The simpliﬁed layout of the message is presented in Figure 1.3a. Each message in the Tangle
consists of parent references, the timestamp (the time when the message was issued, the issuer
identiﬁer, the payload that contains value or data transfers, and the signature, as each message is
signed with the private key of the message issuer, through which all other nodes in the network can
validate the owner of the message.

16

MessageParent referencesIssuerTimestampMessage payloadSigned bythe IssuerTransactionInputsWeight delegation IDsTimestampOutputsSigned by theFunds OwnerMASTER THESIS

Transaction

A transaction is a value transfer that is recorded in the ledger. A created transaction is contained
as a payload in the message and is signed with private keys corresponding to addresses of the
used unspent outputs. Each transaction consists of unspent outputs - transaction inputs, transaction
outputs, timestamp, and signature. An output stores the information about the address connected
to the funds, and the balance that will be transferred. The simpliﬁed layout of the transaction is
presented in Figure 1.3b.

UTXO and branch DAG

The Tangle is not the only data structure used in the IOTA protocol. The transactions are also
tracked with the UTXO DAG data structure that keeps track of all value transactions exchanged in
the network, and allows for efﬁcient conﬂicts recognition. Whenever there are conﬂicting messages
(transactions that send the same output) introduced into the network, a branch corresponding to
each transaction that introduced a conﬂict is created. Each new conﬂicts introduce new possible
future versions of the ledger depending on which transactions will be accepted. Spending from
conﬂicting transactions creates a child branch of the origin conﬂict branch, thus forming a DAG.

All transactions that spend the same output belong to the same conﬂict set and only one transaction
within this conﬂict set will be accepted through the consensus mechanism to the ledger.

Coordice vision of the IOTA protocol

The protocol consists of multiple components that can be divided into three layers: network,
communication, and application layer.

The network layer manages connections with peers and the gossip protocol.
underlying network structure and is mostly independent of the rest of the layers.

It provides the

The communication layer contains the core data structure - the Tangle, which serves as a medium for
messages exchange. Components that belong to this layer are Rate Setter and Congestion Control.
Rate Setter is responsible for adjusting a node’s issuing rate, in a way that fairly uses its bandwidth
share. The Congestion Control, on the other hand, is controlling if other nodes are not abusing the
network resources by exceeding allowed issuing rates.

The application layer is connected to the Consensus component and provides modules necessary for
secure value transfers.

The next Sections will describe components of the protocol that are essential for this work.

Network and nodes. The IOTA network has only one type of node, this is different from other
DLTs, where multiple roles exist, e.g. miners in bitcoin. Those additional roles are not needed
because there are no transaction fees and the work for the network maintenance is performed
whenever a node sends a message. Each node is uniquely identiﬁed with a node ID and has weight
assigned to its identiﬁer (more on this topic in 1.3.3). Each node has up to eight neighbors which

17

are selected by the autopeering mechanism [24] or manually. Nodes are using a gossip protocol to
exchange messages. The gossip protocol is a communication protocol that aims to distribute any
messages to all nodes in the network. It relays on the fact that each node should pass the gossiped
message to its neighbors.

MASTER THESIS

Syncing. The number of nodes in the network varies over time, as nodes can go ofﬂine and back
online. Each node has its local version of the Tangle representing its view on the state of the ledger.
Thus, if the node goes ofﬂine for some time, his ledger is not up to date after its return. Therefore,
it needs to request missing data from its neighbors. A node that is not in sync should not issue
messages as it will attach to the wrong part of the Tangle.

Solidiﬁcation. The Tangle data structure is partially ordered because each message contains a
reference to k other messages that have been already included in the Tangle. Due to network
asynchronicity nodes can receive messages in a different order. Also, messages can be lost during
the broadcast. However, to attach a message to the Tangle, all past cone of the message has to be
known. To continue with message processing and ﬁnd out missing messages, the node is requesting
missing parents through the process called solidiﬁcation. Whenever a message is missing any of
their parents, the node sends the solidiﬁcation request to its neighbors and stops processing this
message until all parents are known. Received parent messages go under the same process as
the child message, thus the solidiﬁcation process is a recursively repeated mechanism that allows
retrieving the entire message history. It strengthens the network synchronicity and the assumption
that each message will be eventually delivered to all nodes in the network.

Right after the message knows its past cone, the maximum parent age check is performed. The node
checks if the difference between timestamps of a processed message and each of its parents is not
older than ζ. If a message is not referencing too old messages the message is marked as solid. If a
message does not comply with the parent age requirement is discarded.

In the prototype software, the component that is responsible for the solidiﬁcation process is called
solidiﬁer.

Mana. Because each node in the network has a corresponding identity, there was a need for a
Sybil protection system, which prevents the malicious actor from gaining a dishonest proportion of
control over the network by forging many identities. Mana is a Sybil protection system that can be
thought of as the reputation of the node or a scarce resource in form of a weight attached to each
node. A node can gain reputation by contributing to the network, e.g. creating value transfers.

Mana is calculated locally, as a function that takes transactions as an input and returns the Base
Mana Vector as an output, Which consists of reputation scores of all nodes. Mana values of a single
node can be changed by pledging the corresponding funds transferred in a transaction to the node
ID. Mana is derived from the token value, however, owner of the funds can delegate Mana to nodes
it favors. There are two types of Mana, that serve different purposes:

18

MASTER THESIS

• Consensus Mana (cMana). It is used in the autopeering mechanism, to connect nodes with
similar weights, and in the voting system to make votes of Mana-rich nodes more signiﬁcant.
cMana is constant over time if not interfered with value transfers.

• Access Mana (aMana). Is used as access control to the ledger. After a portion of aMana is
gained during a value transfer it decays over time, thus it encourages active participation in
the network.

Tip Selection Algorithm. Tip Selection Algorithm (TSA) is a process of selecting where to attach
a newly created message. IOTA 2.0 uses Restricted Uniform Random Tip Selection (R-URTS)
algorithm that is an extension of Uniform Random Tip Selection (URTS) which has very simple
principles. Each node maintains its own local Tip Set which is the collection of all messages that
have not been referenced yet. When a new message is created nodes select tips from the Tip Set
with a uniform probability. The difference between R-URTS and URTS is that the ﬁrst one puts a
restriction on the message’s parents’ age. This means that if a tip was not selected during ζ time it
is removed from the Tip Set.

Consensus and approval weight.
In blockchain PoW based systems the longest chain rule is
causing many blocks to be left behind, which leads to a waste of processing power. The DAG
structure allows for the existence of multiple branches and forks is accepted as a part of the protocol,
which allows for creating a mechanism that will allow for merging many of those outcast messages
back into the main Tangle and signiﬁcantly reducing the waste of resources.

Approval Weight (AW) is one of the backbones of the On Tangle Voting (OTV) consensus mech-
anism that is used for conﬂict resolution. AW is a mechanism that allows a node to express its
opinion on a conﬂict or a message, by attaching a newly created message to the part of the Tangle
he likes and by using speciﬁc types of parent references. AW is used in a twofold way. Firstly, it is
used directly on the Tangle as a weight accumulated on the message by its future cone. Whenever
a message is referenced directly or indirectly by any other message attaching in its future cone,
it gains AW that corresponds to the referencing message issuer weight. If the weight collected
by the message exceeds the known to all nodes threshold θ it is marked by the node as conﬁrmed
(ﬁnalised).

The second form of AW is approval weight collected on branches. It is the core concept for the
OTV mechanism, on which nodes express their opinions on conﬂicts by issuing messages. There is
no additional communication overhead for exchanging votes, as support for conﬂicts is expressed
by referencing them directly or indirectly on the Tangle structure. Nodes select a tip from the tip set
and decide if it agrees with the ledger state it represents. If the selected message has a conﬂicting
transaction in its past cone and the node does not agree that this conﬂicting transaction should be
accepted, we can use a special type of reference to express our disagreement, which does not allow
us to count our node weight. And the same is when the node likes the selected tip and the state of
the ledger it approved, node can approve this message in a way that his vote will be assigned to the
underlying branch.

19

MASTER THESIS

OTV works in a way that nodes can shift their opinions if the majority of the network has a different
opinion on which conﬂicting transactions should be accepted. This way, a node is adjusting its own
opinion based on the information written to the Tangle by other network participants.

Rate setter and Congestion Control. To allow for the participation of smaller and less powerful
devices, the total network throughput needs to be limited in a way that allows for the participation
of devices with limited processing power. The congestion control algorithm should provide safety,
fairness, and consistency. Safety property guarantees that any malicious actor can not bypass the
rules stated by the algorithm. The fairness property states that each node should get its share of
the throughput. In IOTA 2.0 this share is calculated based on the node’s access Mana. Consistency
means that if a message is accepted by one node and written to the Tangle, it must be received by
all nodes in the network within some time-bound.

Therefore the Congestion Control component is regulating the ﬂow of the messages and watches
if other nodes meet their network share limits. When the network is fully utilized – its whole
throughput is used – the congestion control mechanism does not allow for a node to exceed its
bandwidth.

However, during under-utilization periods, when nodes are not using their full share of the access to
the network, the protocol allows for using those unused resources. In this way, nodes with limited
aMana supplies can issue messages at rates excessively exceeding their normal network share during
full utilization periods. Usually, it is a desirable characteristic, however, it opens a possibility for an
adversary with limited aMana resources to use those under-utilization periods to ﬂood the network
with malicious messages.

The rate-setting mechanism allows for a node to estimate its own allowed bandwidth and helps to
choose a correct issuing rate.

1.3.4 Protocol evolution over time

The objective of this section is to review how the protocol changed over time. Knowing the legacy
version will be useful in understanding the obsolete security ﬂaws present in IOTA in the past. Only
the ﬁrst version of IOTA 1.0 will be discussed here and compared to the Coordicide version. The
reason is that most of the previous attack analysis papers that will be investigated later were based
on the legacy version. The ﬁrst version of IOTA node software was Ivy, however, it was not fast nor
stable enough, therefore the new two major projects were started together by IOTA Foundation and
the IOTA Community: Hornet (implemented in Go) and Bee (Rust implementation). Both stable
versions are currently used in the IOTA mainnet, the ofﬁcial primary network on IOTA version 1.5
released during Chrysalis update. Also, IOTA mainnet version is still not fully decentralized, due to
the need for Coordinator existence.

It is worth mentioning that IOTA protocol is just a set of rules that network users are advised to
follow. Based on rules provided in the protocol speciﬁcation there can be many software node
implementations. Thus, IOTA can be considered as truly free protocol, if most of the network users
follow those rules and ofﬁcial implementation, the network is able to sustain some percentage of
malicious users, behaving in a way that does not contribute to the common interest. The goal of

20

MASTER THESIS

protocol improvements is to ﬁnd a set of rules that will be most beneﬁcial to the honest participants
and will punish or neglect any negative impact of adversarial behaviors.

The ﬁrst idea on IOTA given in [1] was combining the consensus mechanism and the tip selection
in one method called Markov Chain Monte Carlo (MCMC). Each transaction had its weight
corresponding to the amount of PoW done during a transaction creation and the sum of weights
of all transactions directly or indirectly approving this transaction. In the case of two transactions
spending the same funds, the transaction that had a higher weight was considered valid. Firstly,
the security of the Tangle was supposed to be guaranteed because the hashing power put into the
Tangle by honest nodes should exceed the adversarial one, especially when the network will be
fully grown. However as mentioned earlier, due to security concerns the Coordinator node was
introduced, which follows the protocol and is the deciding entity in terms of what is accepted and
what would be rejected by the network. Therefore, the transaction was considered as conﬁrmed and
accepted by all honest nodes in the network only when it was referenced by the milestone message.

21

Chapter 2

Attack vectors review

Blockchain-based systems are being developed and used for over a decade now. According to [25],
at the moment of writing, there were more than 600 hack events related to the blockchain technology
recorded. The losses are estimated at over 25 billion dollars. The report [26] summarizes the largest
cryptocurrency thefts within 2011-2021 and indicates 30 thefts with value lost between $7 to $88
billion. Attacks are related to many areas of the crypto industry, such as exchange hacks, wallets
security issues, exploits of the decentralized application (DApp), Decentralized Finance (DeFi)
platforms, non-fungible token (NFT), public blockchain security incidents, and many more. As
shown in [27] attacks targeting applications and platforms built upon the base blockchain layer
account for over 80% of all incidents. One of the most important characteristics of blockchain
technology is its security. The security of an ecosystem built around a given DLT project depends
heavily on the security of its base layer. Security breaches that happen on this base layer are
much rarer, however, as the report indicated in 2021 there were at least 8 (1,3%) attacks on public
blockchains. In this thesis, we will focus on the security incidents and vulnerabilities related closely
to those public blockchain technologies and their protocol ﬂaws.

2.1 Review of known attack vectors

People’s creativity has no limits. One of the greatest examples are clever security violations
represented in numerous threats. Carefully designed attacks by malicious actors target the crypto
space daily. In addition to adversarial behavior, failures can also occur due to random incidents
caused by protocol ﬂaws. All of the above can be divided into different subgroups, depending on
what kind of vulnerability is exploited or occurs, what the goal of a potential attack is and which
part of the protocol is targeted.

By considering the attacker’s objective and the type of the caused damage, two general groups can
be distinguished. In the ﬁrst case, individuals or speciﬁc user subgroups that use protocol utilities
through client libraries and applications are targeted. Examples for such an attack are eclipse attack
(more in Sec. 2.1.1), double-spending attacks, and other attempts to break through a cryptographic
shield that is protecting a user. Additionally, an attacker could try to create the funds ”out of thin air”
or revert conﬁrmed transactions. The second type is targeted at the network and the protocol itself.

22

MASTER THESIS

There, a malicious actor attempts to cause damage to the wider range of users, or even paralyze
the activity of the whole network, which could lead to both ﬁnancial and trust losses. Examples of
these kinds of attacks are spam attacks, denial of service attacks, or attempts to keep the network
undecided, i.e. attacks on the liveness of the protocol.

For the purpose of this thesis attacks will be discussed in the following groups:

• Network layer – denial-of-service (DOS), spam attacks, solidiﬁcation attack, eclipse attack

• Sybil attacks – forging multiple identities, attempts to obtain unfair network resources

proportion.

• Agreement failure - attacks on the consensus, keeping network undecided, double spending,

berserk attacks.

• Structure attacks – spamming or issuing purposely designed message structures, and not
following the general protocol guidance, such as ignoring the standard TSA. e.g. Orphanage,
Blow Ball, parasite chain.

• Security exploits – exploits on the used cryptography methods, replay attack (reuse of

addresses plus reattachments).

2.1.1 Threats in the network layer

In this section attacks on the network layer will be discussed. These kinds of attacks usually are not
meant to steal the funds or bring to the adversary any tangible beneﬁts. However, the consequences
of such an attack can be fatal to the network and thus could bring about irreparable damage to the
reputation of the DLT. Additionally, any interruptions in the continuity of network operations could
lead to severe damage, and ﬁnancial losses to individuals or enterprise projects may be incurred.
Some of the undesirable outcomes of the violation of network layer robustness are halting of the
network, connections issues, prevention of the ledger inclusion for honest transactions, and crash
of nodes in the network. Certainly, if a protocol cannot defend itself against such an attack its
credibility is at stake together with reputation loss to the community and the wider ecosystem.

Spam attacks

The Denial of Service (DOS) attack is a primary attack leading to disruptions in the network layer.
It is not speciﬁc only to the DLT space, for example, quite often it is targeted at centralized hosting
servers or services, resulting in denying access to the web-service resources to users[28]. During
the DoS attack, a bad actor is ﬂooding the network or a speciﬁc target server with excessive internet
trafﬁc. The purpose is to overload servers or network nodes, thus causing problems for nodes to
process requests and respond efﬁciently. Eventually, this can make the network unusable for its
honest participants. A DoS attack can be performed with a single machine. A more powerful
attempt to destabilize the network is Distributed-denial-of-service (DDoS) [29]. Where several
machines, usually distributed around the world, are used in coordination. Those machines are often

23

MASTER THESIS

part of a botnet - a collection of infected computers, that can be controlled remotely [30, 31]. In the
cryptocurrency realm, an attacker could create thousands of transactions to increase the congestion
in the network, overload the nodes, and even halt the conﬁrmation of honest messages, which can
result in an unusable network. For most of the existing cryptocurrencies, the defense mechanism
against this kind of bad behavior is to incur a cost for performing such an attack. Typically, creating
a transaction requires to include a transaction fee, so issuing thousands of transactions can lead to
expenses that outweigh any supposed beneﬁts. This is especially true when a spamming attack does
not result in direct proﬁts. Nevertheless, when the project is still in its infancy, the price of issuing
transactions is low or even feeless. Thus, the project is particularly vulnerable to spamming attacks.
Therefore, it is important to have working defense mechanisms in place, e.g. a Congestion Control
component, described in 1.3.3.

There are many real-world examples of DoS and DDoS attacks.

Nano.
In March 2021 a spamming attack on the Nano network was performed, during which
about 4.6 million transactions were issued within the ﬁrst 24 hours [32]. At ﬁrst, it seemed that
the network will sustain the attack, however spamming continued for a couple of weeks. It was
possible with limited expenses, as Nano has no transaction fees. The attacker was able to send
transactions at almost zero cost, using only a little computing power to solve insigniﬁcant PoW,
which was supposed to work as spam prevention. Users reported problems with halted transactions
and long conﬁrmation times through the social media channels. Many of the nodes went out of
sync, as they could not keep up with processing a higher network throughput [33]. To tackle
the problem, the node’s operators were asked to intentionally lower the performance of nodes, to
allow other nodes that went out of sync to recover [34]. These kinds of intervention, needed on
the broader scale, showed that not only was the network not sufﬁciently prepared but also that it
is not truly decentralized, as this kind of external intervention would not be effective in a fully
distributed system. Another issue was a signiﬁcant increase in storage due to the ﬂood of very small
transactions, which is related to the dust protection problem.

Solana.
In September 2021 the Solana network was entirely shut down, causing a 17-hour outage,
after an enormously high increase in the transactions overload. As the result, the network started
to fork, which on the other hand, caused increased memory consumption, making some nodes go
ofﬂine. The attack was compared to an attack on Ethereum from 2016 [35]. However, in the case
of Ethereum, the production of blocks was not stopped, in contrast to Solana, where it did. To
recover after the attack, Solana’s network had to be restarted, and the fact that this process was very
well coordinated might indicate that the network was strongly centralized at the time of the attack
[36]. The problems caused by the attacker have triggered discussions around the centralization
of the cryptocurrency. Many critical voices indicated that Solana’s consensus mechanism Proof
of History (PoH) requires further research to uncover potential vulnerabilities [37]. For example,
Solana’s protocol requires the selection of a leader among the validators nodes, thus for a short
period of time, the selected node becomes a single point of failure, especially since the list of the
next validators is known upfront [38]. In December, the Solana network suffered another attack
from high congestion. At ﬁrst, a DDoS attack was suspected. However this time, the issue was
not initiated by any malicious actor. Those assumptions were clariﬁed by Solana’s co-founder

24

MASTER THESIS

explaining that the congestion was caused by an unusually high network activity due to the game
SolChicks, which is built on Solana [39].

ChainLink. ChainLink is a decentralized Oracle network that is allowing for the interaction of
different chains and external data sources. It is built on Ethereum and provides a bridge for smart
contracts and real-world use cases. At the end of August 2020, ChainLink became the target of
a spam attack [40]. The attack lasted for a few hours and did not affect the performance of the
network, which successfully resisted the attack. However, as ChainLink is an Ethereum smart
contract, during the spam nodes had to pay higher gas fees (Ethereum’s fees for the smart contract
execution). [41] indicates that node operators lost in total around 335,000 USD due to increased
fees during the attack and ChainLink needed to compensate those losses.

EOS. EOS blockchain is built to support large-scale applications and it was designed to work
both in permissionless and permissioned setting. EOS offers transactions without fees, as it pays
node operators from the tokens minted by the inﬂation. Also, the available resources for transaction
processing are connected to the amount of staked funds. In [42] authors performed an in-depth
study regarding the EOS architecture, security, and performance. Results indicate that EOS does
not achieve claimed goals as a blockchain system and it may rather be considered as a distributed
database system. Due to its design EOS can be susceptible to spam attacks targeting a certain type
of user. In January 2019 the network was under a transaction congestion attack. EOS allows for
deferred transactions. In this process transactions are prepared before they are issued at a speciﬁed
time. Deferred transactions are prioritized over user-signed transactions. If the attacker issues large
amounts of transactions in dead loops, he can cause over-congestion in the network and use up
all node’s CPUs resources resulting in paralyzing targeted EOS application. Attacks exploiting
transaction congestion were repeated many times and caused the loss of thousands of EOS [43].

Eclipse attack

An eclipse attack is a well-known attack vector present in almost all distributed systems. In an
Eclipse attack the adversary that acquired a number of nodes, attempts to convince an honest node to
accept the adversary’s nodes as its only neighbors, thus covering the access of a node to the honest
part of the network. This allows the adversary to control the in- and out-message ﬂow and provide
it with an incorrect state, allowing for manipulation of the targeted node, cause denial-of-service,
or even to double-spend conﬁrmed transactions. [44]. The details about the attack depend on the
system setting. In [45] authors describe an Eclipse attack on an Ethereum network, that can lead to
DOS situations or even allow for double-spend. A vulnerability is presented, where a victim accepts
a longest chain that has a lower total difﬁculty than the main chain. Additionally authors found a
bug in Ethereum’s PoW difﬁculty calculation.

Another example of an eclipse attack designed for a speciﬁc network is [46]. An attack on a bitcoin
network is presented, which can cause a total eclipse of a bitcoin node. The attack was successfully
performed in practice by the authors. During the attack, the victim was completely isolated, thus
could be provided with an incorrect ledger state.

25

MASTER THESIS

The Coordicide version of IOTA uses a salt-based autopeering mechanism that serves as a defense
mechanism for the eclipse attacks [24]. Nodes are periodically generating a public and private salt.
After a salt update of a node, the node starts to look for new outbound connections, and at the same
time accepts the incoming connections that have smaller scores (calculated based on the generated
private salt value). This way the network topology will be constantly reorganized whenever any
node’s salt expires. The autopeering mechanism provides some level of protection against eclipse
attacks, as long as the salt updates will not happen synchronously across the network.

Routing attack

In [47] authors indicate that routing attacks are not a well-researched topic for the IOTA protocol,
as the existing studies usually focused on consensus or cryptography issues. They distinguish three
types of attacks: address freeze, general denial of consensus, and targeted denial of consensus.
The attack focuses on BGP hijacking. BGP is an internet routing protocol, and a malicious node
can advertise the route that it does not have. It can cause the denial of service by dropping the
intercepted trafﬁc. Authors reconstructed an IOTA network topology and indicated that the attack
can be harmful to the network due to the existence of a single point of failure, the Coordinator node.
If the adversary intercepts the Coordinator node it could stop the conﬁrmation of transactions in the
whole network. Authors also referred to the post-Coordinator version of IOTA, which would be
much more secure when fully decentralized. However, they indicate that there still could be some
vulnerabilities, and propose to use secure channels for the communication between the nodes.

2.1.2 Sybil attacks

Adversarial strategies known as Sybil attacks are commonly acknowledged in DLT systems. They
are an inseparable part of all distributed systems, as shown in [48]. The network parties, with no
initial knowledge about each other, are not able to trustfully establish distinct identities where one
identity corresponds to only one party. In a centralized system, each party can be veriﬁed by a
trusted authority that is a bridge between a real-live entity and an identity in the system. In such a
system it is not possible for an entity to present more than one identity. This kind of approach is not
possible in a distributed system. Thus, it is necessary to implement an effective Sybil protection
mechanism that will stop any malicious actor from gaining more power in the network only by
frauding false identities to gain an advantage over honest network users.

Sybil attacks can be divided into subcategories for better understanding and to be able to respond
with a correct defense mechanism for different types of an attack[49]. The subcategories most
relevant in this work are:

• Routing – a malicious actor can appear in multiple places in the network layer and peer

honest network users while pretending to be multiple separate identities.

• Voting – if there is no protection from Sybil attacks, then an adversary could take control
over the voting mechanisms and gain an unfair advantage on the voting outcome simply by
creating false identities.

26

MASTER THESIS

• Fair Resource Allocation – whenever there are limited resources it is a common approach
to design rules on how they will be allocated. If the resources are distributed per identity
it leaves the open window for an adversary to obtain an unfair proportion of the network
resources.

• Misbehaviour detection – if the network uses any mechanism for misbehavior detection, any

malicious actor could exonerate itself, or even force accusation onto a legitimate user.

Unsuccessful Sybil attack on Monero

In November 2020 the Monero project leader conﬁrmed an unsuccessful Sybil attack on Monero
[50]. An attacker created many node instances in an attempt to connect transactions to the IP address
of the broadcasting node. The breached data was revealed publicly on a website[51]. However
as explained by R. Spagni the attacker can not prove a link between the revealed user Monero
transaction and corresponding IP address, as the attack was not large enough to be effective against
Monero’s defense mechanism Dandelion++. It is a broadcast system in which transactions are
passed through several nodes before it is broadcasted to the network, in a way that intermediate
nodes do not know if the node that provided them with the transaction is the sender.

2.1.3 Byzantine fault and agreement failure

The consensus mechanism is usually the core of any blockchain project. The ability to reach an
agreement on the state of the network is indispensable for any system that preserves valuable data.
Attacks that aims to disrupt the system’s ability to come to an agreement are usually divided into
two groups:

1. attack on liveness of the system to halt the consensus in a metastable state

2. attack on the security of a system, spending the same funds twice or reverting previously

considered ﬁnal transactions

51% attack

The 51% attack is applicable to PoW based blockchains in which an adversary that controls over
half of the total hashing power of a system intends to fork a blockchain and perform a double
spend [52]. This kind of attack usually is considered unlikely to happen as the cost to perform the
attack typically outweighs the gain. In this attack the adversary starts to secretly build a malicious
version of a chain, and one the chain is long enough it is presented to the network. Honest nodes
apply the longest chain rule and follow the chain proposed by the attacker. The 51% attack is also
possible for Proof of Stake (PoS) systems, however, the cost may be even greater, as an attacker
would need to own more than half of the targeted cryptocurrency. Therefore, the threat is potentially
lower compared to PoW systems.

In [53, 52] the problem of centralization of PoW system is raised, where mining pools (groups of
miners that combine their hashing power and split the reward proportionally) are in the possession

27

MASTER THESIS

of a large amount of hashing power in the network. E.g., in Bitcoin seven out of the ten biggest
mining pools are based in China.

A large theft happened on the Bitcoin Gold network in May 2018. The double-spend amount
was estimated to exceed $18 million [52, 54]. Another double-spend attempt documented in [55]
happened in January 2020. The deposit of stolen BTG coins was received on the Binance exchange
after six-block conﬁrmations and could be withdrawn after 12 conﬁrmations. Since this incident,
the number of required conﬁrmations was increased up to 20.

Stellar protocol security

In April 2019 [56] brought attention to the centralization of the Stellar network. Stellar is a
blockchain-based platform that uses Federated Byzantine agreement (FBA) consensus mechanism,
which differs from PBFT because it allows for open membership as long as nodes are trusted by
others. The study demonstrates that the system is highly centralized, and that three nodes belong to
the Stellar Foundation. Additionally, the system is susceptible to cascading failure, in which only
two nodes need to crush to take down the entire network.

After the study has been revealed, Stellar researchers conﬁrmed the centralization issue and assured
that they are currently working on a solution.

Afterward, in May 2019 the Stellar network went down as too many new nodes were added to the
system over a short period time. The network became unstable and two nodes crashed, causing the
failure of the whole system and violating the liveness [57].

To bring the network online, the number of validators was increased from two to three, nevertheless,
as the authors of [56] state, this does not solve the fundamental problem.

2.1.4 Cryptography vulnerabilities

Cryptographic structures are essential in every blockchain project. They often guarantee the security
of the system. With the growing demand for improvements in privacy, scalability, and functionalities
for the systems the used solutions introduce complexity. Along with system complexity, the chances
of vulnerability being unnoticed also increases. In this Section, we introduce some examples of
such security ﬂaws in different projects.

Ethereum direct piracy attack

SlowMint, the company focused on blockchain security, published a report describing the ﬂaw in
an Ethereum node’s authentication mechanism that was exploited for two years (2016-2017) and
led to $20 million lost [58]. An attacker scanned the network to ﬁnd nodes with RPC API ports
enabled, then repeatedly tried to transfer the balance to the attacker’s wallet. If the user happens
to execute unlockAccount on his wallet, there is a time when he does not need to reenter the
password. The attack will succeed if an attacker will try to transfer the balance during this duration

28

MASTER THESIS

period. The team performed an extensive network scan and discovered more than 10,000 Ethereum
nodes exposing the RPC API, thus being at high risk of a direct piracy attack.

Monero and Zcash

Most blockchain-based systems, despite hiding the user identity behind digital identities or addresses,
do not guarantee privacy. Usually revealing only one of the used addresses might allow interested
parties to ﬁnd out other addresses owned by the user and track its activity over the network. To
tackle this issue many privacy coins projects have been initialized, among them are Monero[59] and
Zcash[60]. Those projects aim to hide the users’ activity and hide any information that could lead to
revealing user identity. There exist examples of attacks aiming for the deanonymization of the user.

The ITM linkability attack explained in [61] on the example of Zcash protocols is also applicable for
Monero. Zcash Protocol is using shielded transactions that do not reveal the addresses of sender and
receiver, nor the transferred amount. However, as the author indicates a large amount of metadata
is produced for each transaction at the protocol level. The ITM attack takes the transaction id and
zaddrs, which happened to be revealed publicly by users on social media websites. It allows for
deanonymization of the zaddrs and connecting them to social media accounts, IP addresses, and
more data. The attack is costly as it needs a speciﬁc infrastructure, so it would not be performed by
a standard user, but rather big companies or organizations. Additionally to the attack description,
the mitigation strategy Sietch is proposed, which is already implemented in the Hush crypto coin.

Another deanonymizing attack was revealed by Stanford University in [62]. The vulnerability was
ﬁrst exposed to the Monero’s and Zcash’s team to allow for ﬁxing the issue before publishing the
ﬁnding to the public[63]. The remote side-channel attack allowed to identify the node of the payee
in an anonymous transaction. Which enabled the adversary to ﬁnd out all transactions sent by a
user, their IP address, and ﬁnally a user’s diversiﬁed address. Additionally, the attack allowed to
remotely crush any Zcash node for which the attacker knows the payment address.

Replaying attack on the legacy IOTA

In 2018 when the MCMC algorithm was still used as a tip selection mechanism in the IOTA
protocol, there was a need for transaction reattachments, which is the possibility to resend the same
transaction again by selecting different parents. Due to the walk, there is a positive probability,
that an honest non-conﬂicting transaction would never be chosen as a parent by other transactions,
and thus would never be added to the ledger. If the transaction was still pending after several
minutes, the user needed to repeat the attempt to include the transaction into the Tangle, by issuing
a reattachment. At that time IOTA was using base-3 numbers (ternary) and the quantum immune
hash function Curl-P with a one-time Winternitz signature. In the Winternitz signature scheme
transactions should not be issued twice, since with each repeated signature a part of the private key
is revealed. Therefore, the ofﬁcial IOTA guidance was to never use the same address more than
once. Although this rule was ofﬁcially supported in all ofﬁcially available applications, there was
still a possibility that a user could not follow this rule if he decided to interact with the network
through the API client library. In [64], the authors show that it is possible to reuse an address as a
user and that it is possible to exploit this by performing a replay attack.

29

MASTER THESIS

2.1.5 Exploits on the protocol structures

Selﬁsh mining in Tezos Tezos is a PoS blockchain with a self-amending governance system that
went live in June 2018. In 2020 the group of Harvard researchers discovered a selﬁsh mining
strategy that could allow for an attacker to gain rewards for a longer period if an attack will be
undetected [65]. The reward gained from an attack is low compared to the staked funds that an
attacker might lose if he will be caught. Also, the issue can be ﬁxed, by introducing changes to the
protocol without the need for a fork, through a governance structure. Therefore, the discovered
strategy is not a signiﬁcant threat for the Tezos network, however, it rose a discussion about the
security of the PoS systems and showed that research about the PoS systems is still in the early
stages and many vulnerabilities can still be exposed.

Parasite chain The Parasite Chain (PC) attack is a well-known and researched topic that was
applicable in the old versions of the IOTA protocol. The MCMC TSA was introduced to counter
the parasite chain attack. The PC attack falls into a category of double-spend attacks, when an
attacker is aiming on spending funds more than once, by reverting the ledger state to some point
in the past after certain funds have been conﬁrmed and accepted. The ledger state forks and the
previously conﬁrmed transaction is considered invalid in favor of the issued later double-spending
transaction. In the initial white paper version of IOTA this attack was theoretically possible in the
older version of IOTA when the attacker had access to reasonable power resources. In the attack,
he could secretly create a chain of transactions starting from the double-spending transaction and
reveal it whenever the collected weights of transactions that reference the double-spend (the starting
point of a parasite chain) outweighed the honest part of the Tangle. Practically this attack was not
feasible, since a centralized node called the Coordinator is required to approve transactions before
they get accepted. The attack was ﬁrst mentioned in the IOTA whitepaper. The practicability of the
PC attack (without a Coordinator) was shown in [66]. The IOTA development network was used for
the experiment. The attacker was able to outpace the cumulative weight of the previously conﬁrmed
transaction and keep it in this state through the whole duration of the experiment, which was 35
minutes. However, as mentioned above, even if the double-spend transaction had a higher weight it
remained unconﬁrmed as the network was guarded by the Coordinator, that would not approve this
transaction.

[67] introduced a method to detect the PC attack based on the differences in the structure created by
the attacker and the main part of the Tangle. The proposed solution was to measure the distance
between distribution retrieved from the Tangle data and the expected distribution describing the
number of direct approvers.

Large weight and split attack on IOTA The Large weight attack, similarly to the PC attack,
attempts to build a special structure in the DAG consisting of transactions to perform a double-
spending attempt. The attack is applicable for the ﬁrst versions of IOTA as the attacker attempts
to create support for the double-spending transaction by trying to out-weigh the main part of the
Tangle containing the ﬁrst transaction, which has been already conﬁrmed. The double-spending
transaction is attached to the Tangle such that it is outside of the future cone of the conﬂicting
transaction, to increase the weight of conﬂicting transactions separately. In [68] the large weight

30

MASTER THESIS

attack was executed on one of IOTA test networks. The double-spending transaction gained more
weight than the ﬁrst conﬂicting transaction, however, the Coordinator did not approve the double
sending transaction, therefore the attack did not succeed.

A split attack, performed in [69], attempts to keep the network undecided as long as possible (until
the time the next milestone will be issued and only one conﬂicting transaction will be selected). The
goal is to make as many honest messages to be left behind when they attach to the losing message,
thus increasing the orphanage in the network. The results indicated that the attacker was able to
slow down the conﬁrmations as the number of conﬁrmed honest messages dropped to about 60%.

Attacks involving collecting the weight by issuing messages on top of the conﬂicting transactions
are no longer applicable in the IOTA network, as in the update to the Chrysalis version of the node
software the concept of the white ﬂag has been introduced [70]. White ﬂag utilizes the advantage of
having a single source of truth in form of a Coordinator node which allows for total ordering of the
transactions. With a total order, all nodes in the network can select the same conﬂicting transaction
which will be applied to the ledger state, and ignore all the others.

As the Coordicide version of IOTA introduced the concept of Mana, ﬂooding the network with a
large number of transactions will not be possible as the access to the network is guarded by the
access Mana, except during under-utilization periods (more on this in Section 2.2).

2.2 Orphanage problem

In this section, the main topic of this thesis will be introduced: the orphanage attack. Additionally,
the next Chapter 3 will cover the practical experiment and carry out the orphanage attack scenario.
A speciﬁc deﬁnition of the orphanage problem might vary depending on the underlying ledger
and the protocol rules. The name derives from ’orphan’ that is referring to a completely valid
message, or a block that is left behind in the ledger structure. In the DLT setting, this means that the
message most probably will never become accepted by the network, i.e. added to the ledger. This is
not a desirable phenomenon, especially from a user perspective, as it forces the user to resend a
transaction that was rejected even though it was completely valid. A further concern is a waste of
resources consumed during the preparation and attachment of a message to the ledger, such as the
carried out PoW.

The orphanage problem is not IOTA speciﬁc only. Many other DLTs are facing or even accepting
this problem as an inevitable necessity. For example in Bitcoin, each time when more than one
block is created simultaneously and all of them attach to the same parent blocks a fork of the chain
is created. From that event on, the miners will decide, by building upon the preferred chain, which
chain will be considered valid. All forked chains that did lose the competition for the title of the
longest chain, are no longer considered as a part of the blockchain and become orphaned. Hence,
the energy used to solve the cryptographic puzzle is wasted.

31

MASTER THESIS

2.2.1 IOTA and orphanage in the past

In the ﬁrst version of the IOTA protocol presented in [1] the consensus algorithm responsible for
conﬂict resolution was a random walk MCMC. Despite problems with the performance, in terms of
time taken to resolve a conﬂict, there were other issues impacting user satisfaction and usability of
the protocol. Whenever an honest user of the IOTA network wanted to send funds, he needed to
create a transaction, send it, and wait for funds to be conﬁrmed. However, it could happen that after
30 minutes, his transaction was still pending. The problem that caused this, from the user’s point
of view, inconvenient suspension, was how the tip selection algorithm and consensus mechanism
worked. The MCMC selection algorithm was not only serving the purpose of selection which tips
would be approved but also was reducing the probability for a successful double-spend, i.e., it
served as a consensus mechanism. New messages would commit their approval weight that was
related to the invested PoW to the validity of all transactions in its past cone in the Tangle.

The idea is then that to overcome the main network a double-spending transaction would have to be
placed on a part of the Tangle that has lower cumulative weight and is unlikely to be selected by
the tip selection. This was protected through a combination of a random walk through the Tangle
and protection of the message issuance by PoW. As a consequence, the attacker would require a
signiﬁcant hashing power and accumulate more weight than the rest part of the honest Tangle. As
an additional initial protection mechanism, a central node was introduced that should protect the
network in its infant steps. Transactions approved by the Coordinator were considered conﬁrmed /
ﬁnal. The MCMC beneﬁt of reducing the chances of the double-spend attack success came, however,
with a disadvantage.

Since messages were made interdependent through their approval there was a probability that a
transaction would never be picked up by a new message since it is attached to the Tangle in place
that is disfavoured by the network. The behavior of the random walk used in MCMC algorithm was
controlled by the α parameter. Increasing the α value increases the probability that the transaction
with a large cumulative weight will be selected. Thus, it ensures that only the most reliable tips
will be selected. This reduces the chances for a double-spend attack success. However, increasing
α, increases the chance of an honest transaction being not selected, especially if it was placed on
a part of the Tangle structure that is unfortunate enough to be avoided by the Random Walk. If
during the creation of a new transaction, the algorithm will follow a path with a low probability,
the chances of this new transaction being approved, and eventually conﬁrmed will be equally low.
Additionally, the chance of being selected decreases over time, as the further the transaction is from
the end of the Tangle the less accumulated weight it has compared to the main part of the Tangle
that has been already supported by newly added transactions. The further from the top of the DAG
the transaction was attached, the less probable it was that it will ever be approved. Thus, some of
the transactions that selected old or unfavoured tips could be left behind and never be approved. We
call this pending transaction an orphan. Even though this kind of situation is unlikely to happen, it
still can be the source of a major inconvenience for a normal user.

To determine the frequency of these events we need to determine with which probability valid and
honest transactions are being orphaned. We call the frequency of these events the orphanage rate.

To solve this problem, many solutions were proposed. The simplest one was to ﬁnd the best
compromise by choosing the lowest α parameter that will provide enough security for given

32

MASTER THESIS

network throughput. However, this is challenging and a given parameter might not be optimal in
all circumstances. Other solutions were presented in [71], where modiﬁcations to the TSA were
introduced.

2.2.2 Orphanage problem now

The MCMC tip selection algorithm, mentioned in the section above is no longer used in the IOTA
protocol. The newest version of the protocol separates the TSA from the consensus mechanism.
IOTA 2.0 is using the R-URTS algorithm (Sec. 1.3.3) that selects the tips uniformly from the tip
set that is the collection of not yet approved messages, which is based on a node’s local perception
of the Tangle. This has some positive consequences. The chances of the valid message for being
orphaned in an idle network situation should be extremely low. Nevertheless, there is no guarantee
that all the network participants follow the rules, and there exist certain strategies (for adversaries)
that can increase the orphanage rate, e.g. the orphanage attack that will be covered in the next
section.

In the IOTA 2.0 the separation of the consensus mechanism from the tip selection is achieved
by the introduction of new references. More speciﬁcally, e.g., weak references are introduced
that allow approving the transaction within a message without approving the past cone of the
message. This way, even if a message selected the losing side of a conﬂict it can be still referenced
by other messages. The R-URTS algorithm implied the time restriction on the allowed age of a
message’s parents. All messages that are referencing messages older than a maximum parent age ζ
are considered invalid, so if the message will not be selected before the elapse of the time ζ since its
issuance it will become an orphan.

By taking into consideration all the protocol changes introduced for IOTA 2.0, we can state the
orphan deﬁnition as follows:

If a message age or age of all tips in the future cone of this message has surpassed the ζ time and
has not been selected by any other message, this message and all messages in its future cone are
orphaned.

Where age is the time difference between the issuance time and the current time.

The cause of the orphanage.
If the network is not overloaded, this situation should rarely happen,
as each tip has a similar chance for being selected by R-URTS TSA. One possibility to increase
the probability of an orphanage event is to signiﬁcantly increase the size of the tip pool, as the
probability of a tip being selected with R-URTS is inversely proportional to the tip pool size.
Usually, in a healthy environment and the presence of high network congestion, the increased width
of the Tangle is a manifestation of the Tangle scalability characteristic, as the existence of multiple
interconnected chains allows for parallelization of operations in the network. However, if the ﬂow
of transactions exceeds the processing capabilities of nodes, it can cause an increase in the tip
pool size and creates the possibility of orphanage occurrence. This problem is controlled with the
Congestion Control module, introduced in [72] that governs the allowed issuing rates for the network
participants based on its aMana supplies. When the network allowed throughput is fully utilized
the issuance rates are fairly distributed among the network participants, and without violation of

33

MASTER THESIS

the Sybil protection mechanism, ﬂooding the network with too many messages is not possible.
However, forbidding low Mana nodes to issue transactions even if a network is underutilized would
be wasteful. Therefore, IOTA 2.0 allows the utilization of unused network resources and omits
Sybil protection requirements, when there is not enough demand from the allowed parties. The
long periods of a network under-utilization open up the possibility for an attacker to gain a huge
proportion of the network throughput and by applying malicious strategies inﬂate the size of the tip
pool set.

Therefore, in addition to a bad user experience, orphanage can induce additional problems. An
attacker can, by not contributing to the reduction of the tip pool set, cause tip pool size inﬂation and
affect the ﬁnalization time of messages. When the Tangle is wide, the whole data structure grows
slower and more time is needed to collect enough AW.

2.2.3 Orphanage attack

The orphanage attack strategy takes advantage of the Tangle structure and the fact that the protocol
allows to use of underutilized network throughput even if nodes do not possess much Mana, see
the previous section. The goal of the attack is to damage the network and increase the orphanage
rate for all messages. As discussed in the previous section, it can be achieved by caused by tip pool
inﬂation. An attacker is not simply spamming, he is aiming to decrease the number of tips removed
by his messages as much as possible while following the protocol rules. As each node can have
a different Tangle perception due to delays present in the network, it is not possible to validate if
a given node is following the default TSA, which is R-URTS in the case of IOTA 2.0. Attaching
to older messages could be caused by clock or synchronization issues and not necessarily means
malicious intentions. The protocol imposes that any new message can not reference a message in
the past that is older than the time duration speciﬁed by the protocol - the ζ parameter. As long as
the attacker chooses messages within this time range, his behavior will be accepted by other nodes,
and messages issued by the adversary will be processed.

The orphanage strategy is as follows:

1. Select the oldest possible messages.

2. If possible select only own tips.

3. Use a minimum number of allowed message references.

The ﬁrst point is responsible for most of the damage caused during an attack, as by selecting the
messages closest to the maximum parent age an attacker is maximizing the possibility of referencing
a message that has been already selected by others, this is not contributing to the reduction of the
tip pool size. The second point reduces the chances of an honest message being selected, and the
third one minimizes the tip pool size reduction. Nevertheless, the situations, when the adversary
beneﬁts by applying points 2) and 3), will not happen too often during an attack, because the attacker
attaches to old messages that would be removed from the tip pool a moment after.

When the attack starts, an adversary can simply attach to his own, same message until the message’s
age will get close to maximum parent age ζ. After this time, the attacker keeps attaching to his own

34

MASTER THESIS

Figure 2.1: Illustration of the orphanage attack. Adversary messages marked in red, honest messages
in blue. At the time t an attacker is adding a new message to the Tangle and references his own,
oldest possible message, despite being completely aware of the URTS tip pool set he should use.

oldest, yet valid message. Attack is presented in Figure 2.1. The structure of the Tangle changed,
as the attacker references create long connections. It is visible as the whole structure is supported
only with honest messages. The visualized network is not overwhelmed by the adversary, as honest
nodes keep approving all messages, despite additional adversarial tips. However, if the attacker
increases the spamming rate, the honest nodes might no longer be able to keep the tip pool size
under control.

Attack consequences

The majority of nodes, that follow the default TSA will select the newest messages, that from the
given node’s local view have not been referenced yet. As the local perception of the network state
differs among the nodes, it may happen that a certain message will be selected more than once.

As proven in [67] the average number of references that message received is equal to k for high
network throughput conﬁrming the intuition that each honest message will remove k − 1 messages.

The ability of honest nodes to reduce the size of the tip pool depends on the allowed k parameter,
which represents how many tips can be removed from the tips set while adding a new message,
which in turn contributes to the speed of the tip set reduction. When the number of messages
exchanged in the network does not change in time and the network is attacked by an adversary
aiming to inﬂate the tip pool, the k parameter dictates the ability of the honest part of the network to

35

ttimet - ζURTSTip SetMASTER THESIS

counter the spam. However, when the proportion of adversary messages within the total network
throughput q increases, honest nodes at a certain point would be no longer able to keep up with
selecting messages and the attack will succeed.

Critical point

Assume the total network throughput does not change in time and all nodes in the network keep
sending messages at rate λ. The adversary spam rate λA and honest nodes spamming rate λH are
distinguished. The proportion of an adversary spamming rate λA to the total rate is called q = λA/λ.
The number of messages referenced by honest nodes is denoted by k. The critical point for when
the above becomes an issue depends on the number of parents k that each honest message selects.
To provide an estimate for the critical point qcrit we apply the following simpliﬁcations:

1. The current state of the tip pool set is globally known to all nodes in the network.

2. Each honest node reduces the tip pool size by k − 1.

3. Honest nodes always select k number of unique parents.

The ﬁrst assumption ignores the fact that information ﬂow in a real network is delayed by the
network connection and processing delays, and that messages are added to the Tangle in parallel.
In a real network environment it is common that due to network delays, one message might be
selected by more than one node. As a result of assumption 1) each node immediately knows that
a message was referenced by other nodes, thus from 1) we obtain 2), i.e., every honest reference
removes exactly one tip. Furthermore, as we will see in 3.2 the obtained equation for the critical
value agrees well with experimental results.

The critical point q happens when the number of tips introduced by both honest and adversary nodes
is equal to a number of tips removed from the tip set. Due to the orphanage attack strategy, an
adversary does not contribute to the reduction of the tip pool set. Additionally, by applying the
second assumption that each honest node decreases the tip pool size by k − 1 it can be denoted:

λA = (k − 1)λH

From q = λA/λ we can substitute λA with qλH/(1 − q). From this we obtain a critical value for
which the tip pool becomes inﬂatory, thereafter:

qcrit =

k − 1
k

(2.1)

Increase after the critical point

To predict the behavior of the tip pool size above the critical point we can extend the assumptions
introduced in the previous section by adding: the time is divided into intervals with length ti+1 −ti =
h which represents the delay, caused by the time needed to do PoW to process message and the
network delay. As proven in the [67] the average number of approvers is equal k and the tip pool

36

MASTER THESIS

size at time ti is equal Li = kλ + 1. By following the same line of reasoning, to derive the formula
that will describe the tip pool size increase during an orphanage attack, the tip pool size increase
during one interval h can be written as:

L∆ = λA − λH(k − 1)

where λA and λH are respectively the adversary and honest spamming rates. By assuming the initial
condition L0 = 1 it can be deduced that

Li = i(λA − λh(k − 1)) + 1

After replacing spamming rates with the proportion of adversary spam q = λA
time t can be described with

λ the tip pool size at

Li = i(λq − λ(1 − q)(k − 1)) + 1

(2.2)

Conﬁrmed orphans problem

Three major consequences of the orphanage attack introduced in the previous sections were con-
nected to the tip pool size inﬂation that causes both conﬁrmation time increase and increase of
the orphanage rate. The orphaned messages created during an orphanage attack usually will have
no children or the orphaned chain will be rather short, because the increase in the orphanage rate
is caused by the tip pool size inﬂation and what usually will be orphaned are tips. Since these
messages will not be conﬁrmed, their rejection will not cause any problems within the ledger state.

However, one can consider situations in which the network is rejecting conﬁrmed messages. This
situation is visualized in Figure 2.2. It can happen when certain messages will collect enough AW
and get conﬁrmed, however, their future cone will consist of a sub-tangle of which the tips become
orphaned. Whenever those tips will cross the ζ age check, the whole past cone of those orphaned
messages is also rejected by the network, as it is not possible to collect more AW.

The orphanage of the entire sub-tangle can introduce inconsistencies in the ledger, which can lead
to consensus problems. Speciﬁcally, ledger state inconsistencies could appear. The conﬁrmed and
orphaned messages are no longer reachable during the walk from the growing end of the Tangle.
The only way to ﬁnd them would be to walk forward starting from Genesis or some old checkpoint.
However, at the same time, the unspent output within those transactions will be considered valid, as
the transactions are considered conﬁrmed, and there are no contradictions from the UTXO DAG
perspective to use them in the new transaction. At this point, different states on the Tangle DAG
structure and the UTXO DAG structure can be obtained. There is a requirement for the unspent
output that it has to be in the past cone of the transaction that tries to spend it. When the conﬁrmed
and orphaned output will be used, the past cone check could never be fulﬁlled, as the output is no
longer reachable while performing a backward search algorithm in the Tangle. Note that in the
current prototype implementation, the past cone check is not performed due to performance reasons.
Thus the implementation has very strong assumptions about the ledger consistency and requires
that the divergence between ledger of different nodes will not happen. As each node should be able
to retrieve all messages (sync) by walking the Tangle starting from the tips and requesting missing
messages through the solidiﬁcation process. However, when considering the above situation with

37

MASTER THESIS

Figure 2.2: The Tangle during an orphanage attack. Conﬁrmed messages are in green, the gray
border indicates the tip. Cross means that the message is orphaned. On the left, two orange messages
have conﬁrmed messages in their past cone. However, they are only two tips in the future cone of
those conﬁrmed messages. For the situation on the left, there is still a chance for the side Tangle
that ends in orange messages to be not rejected by the network, as the age of the orange messages
is < ζ. In the left Figure, the sub-tangle with orange messages is orphaned, along with conﬁrmed
messages.

conﬁrmed orphans, the syncing node would never know about those transactions as they are not
reachable by a simple backward search algorithm. Consequently, we end up in a situation where
two nodes have different ledger state perceptions.

A ledger inconsistency has also impacted other components apart from the balance states. In
particular, its derivative – Mana – can be used as a Sybil protection mechanism, as is the case
in the prototype software. Many components rely on Mana as a Sybil protection. For example,
the consensus mechanism and the rate control. Nodes that have an incorrect view on the Mana
vector have an outdated view on AW collected by each conﬂict branch, which can result in voting
for a losing branch. The Congestion Control component which also uses Mana is responsible for
controlling the message ﬂow in the network. A Mana inconsistency can lead to punishing honest
nodes by not gossiping their messages at the rate that would available if the node knew about those
conﬁrmed and orphaned transactions. All of this would be impossible to notice by the node that has
an incorrect ledger state, as from his point of view he solidiﬁed all messages.

2.2.4 Blow Ball attack

The blowball attack is a variation of the orphanage attack. Its implications are similar to the ones
from an orphanage attack, however, those results are achieved by different spamming strategies and
by building different structures with spamming messages. An attacker instead of issuing messages
at a constant, maximum possible rate is creating the ’ball’, which is a collection of messages that
reference only messages that are part of this blowball and usually are attached to the Tangle via a
single reference from the message that ties all messages in the blowball. This kind of structure is

38

timetimet2 - ζt2 t1 - ζt1 MASTER THESIS

Figure 2.3: Depiction of the blow ball attack. The adversary messages are marked in red, honest
messages in blue. At time t an attacker is adding a new blow ball to the Tangle and references a
message from the previous blow ball. Now he starts to prepare the next blow ball, which will be
issued as soon as the last one start passing the ζ age.

prepared upfront, and all messages from the blowball are issued at once. Therefore, the adversary
messages join the network with bursts, causing sudden tip pool size increase, and are followed by
an idle period of only honest activity, up to the time when an attacker issues the next blowball.

The blowball can be attached to the last message of the previous blowball, to avoid selecting any
honest message. In this case, the time difference between two consecutive blow balls should not
exceed the maximum parent age ζ.

39

ttimet - ζURTSTip SetChapter 3

Experimental validation of the orphanage
attack

3.1 Experiment setup

In the previous Chapter 2 many adversarial scenarios were introduced, starting from real-world
examples to the theoretical discussion about the security of the protocols, and possible ways to
damage the distributed system. One important threat for the IOTA DLT is the orphanage attack, see
Section 2.2.3. Although relevant for all iterations of the IOTA protocol, this is the ﬁrst thorough
investigation of this topic. In particular, for IOTA 2.0, poses a threat to the data structure during
periods of under-utilization, when the adversary is more likely to be able to gain a high portion of
the network throughput. More precisely, since vacant throughput can be occupied at no cost an
adversary can cause a real threat to the DLT with, potentially, very little cost and effort [72].

It is common to investigate possible security ﬂaws from a theoretical side, to cover edge cases for
attacks, even though practically these attacks may be hard to achieve. Therefore many proposed
attack scenarios require from an adversary:

• an exceptional knowledge and skills,

• access to hardware resources greatly exceeding one of an average user,

• gaining a signiﬁcant amount of control over the communication layer.

This is not the case for the orphanage attack. Its simplicity imposes a major threat for the system
since it can be imposed without an adversary needing to ramp up its capabilities. There are no
signiﬁcant costs related to the transaction fees or any other additional on-ledger payments. More
speciﬁcally the resource limitation PoW is negligible in IOTA 2.0 and unused bandwidth is free.
Furthermore, even in the Chrysalis network, where PoW would be noticeably increased, compared
to IOTA 2.0, an adversary may obtain the necessary specialized hardware to overcome a given PoW
spam protection. To support those assumptions, the orphanage attack is performed in a form of
experiments aiming to measure the impact and damage it can impose on the network. To perform

40

MASTER THESIS

the malicious scenario the prototype node software is used. As such the experiment is reﬂecting
well how the DLT would be affected by the orphanage attack. The experiment is performed under
different conditions and with a different setup of network prototype parameters. The following
sections introduce the technical details of the experiment, tested parameters, and measured network
characteristics. Finally, the results of the experiment are presented and discussed.

3.1.1 Technical details

The experiment is set up in a virtual environment, with Docker – an open-source project allowing
for automatic deployments of self-sufﬁcient virtual environments within containers. The container
abstracts the program dependencies, the underlying system, and access to storage, processing power,
and other resources thus allow to run applications fast and easily, regardless of the platform we use.
Additionally, the Docker Compose application is used to create a running multi-container network
with multiple GoShimmer node instances. It allows for performing an experiment on a single
machine, and at the same time using a full version of a node software to create an artiﬁcial network
with close to real-world network behavior. Performing an experiment within such a controlled
environment brings beneﬁts, such as being in control of spamming rates and behavior of all network
instances, and the experiment environment can be set up quickly with support for tasks automation.
Also, changing any of the network parameters is not problematic, as all necessary parameters are
exposed as program ﬂags. Most importantly, ‘docker-compose‘ allows for deﬁning the initial setup
of the network instances.

The local network created for the experiment is based on the ‘docker-network‘ tool available in the
GoShimmer repository1. The tool provides a ‘docker-compose.yml‘ ﬁle, that describes the base
setup of the network. All network nodes are running with the 8.3 version of GoShimmer. The
created network consists of seven honest node instances, where their behavior does not deviate
from the default prototype implementation. The eighth node is representing an attacker instance
and follows the modiﬁed version of the prototype software. The introduced changes follow the
orphanage attack strategy. The adversary node’s codebase has been modiﬁed to accommodate a
mode in which nodes perform an alternative operation, during which malicious actions are executed.
The node’s software modiﬁcations and all necessary measure tools are implemented in a forked
Gohimmer GitHub repository 2.

Network setup. For this experiment the following default properties of the prototype software
are altered:

• Disabled activity messages. The message ﬂow in the network can be controlled with a

message spammer via Application Programming Interface (API) calls.

• Disabled faucet plugin. The experiment is performed only with data messages.

• Enabled metrics collection for all nodes. All nodes are connected to the data collection

dashboard.

1https://github.com/iotaledger/goshimmer/tree/develop/tools/docker-network
2https://github.com/daria305/goshimmer-orphanage

41

MASTER THESIS

• Identity and private seed for each node. It enables the allocation of aMana and cMana.

Snapshot. The default Mana distribution recorded in the snapshot ﬁle is divided only between
two nodes, thus is heavily centralized. After assigning identities to all honest nodes the new custom
snapshot is created. For the purpose of this experiment the aMana, see Section 1.3.3, is distributed
equally among all nodes to allow for undisturbed spamming. The cMana is pledged equally to
honest nodes with an exception for the faucet node that received all cMana from the adversary node.
In this way, only honest nodes are contributing to the message conﬁrmations, as messages issued
by the adversary do not have any impact on the approval weight collection. This represents the
worst-case scenario, as slowed down AW collection in combination with wide Tangle results in
increased conﬁrmation times. Also, all nodes have an equally large portion of aMana. Thus the
message exchange during an attack is not interrupted by the Congestion Control module.

Data collection. For the collection of data, we use a Grafana dashboard that is conﬁgured for the
prototype software. Grafana is an application that provides a graphical interface and facilities the
presentation of the collected metrics and data. The dashboard is fed by the Prometheus server set up
along with the Docker network. Prometheus is a database that collects data from each conﬁgured
node that is connected to it and then sends the data to Grafana. For the experiment, the metric
collections were expanded to gather the data from all nodes, and some of the data views were
modiﬁed to allow the collection of:

• tip pool size changes over time for each node instance,

• conﬁrmation events count for each node,

• issuing rates for each node.

The ﬁrst two metrics are used for the analysis of the experiment results. The third is collected for
data processing purposes only, thus will not be visualized.

Finally, we measure also the orphanage rate. To calculate this measure, an approximation has been
adopted to identify which messages are orphaned: we walk the Tangle starting from the Genesis,
and check each message older than maximum parent age ζ. The implemented method counts
orphans based on their conﬁrmation status, which is a sufﬁcient approximation for this research.
Nevertheless, as stated in Section 2.2.3 exceptions can occur and there might be some messages that
are both orphaned and conﬁrmed. However, for the sake of simplicity, we omit this special case.
The walk and orphanage metrics collection can be triggered for each node via an API call after a
part of an experiment has ﬁnished.

3.1.2 Plan of the experiment.

The experiment is divided into three major parts:

1. Time restriction on tips (ζ=60s), variation of q and k.

42

MASTER THESIS

2. No time restriction on tips (ζ is greater than experiment duration), variation of q and k.

3. Variation of time restriction length ζ for ﬁxed qcrit and k.

Orphanage with maximum parent age restricted

The ﬁrst part of the experiment is fairly aligned with the Coordicide speciﬁcation3. As mentioned in
1.3.3 IOTA 2.0 uses the R-URTS tip selection algorithm, which is also implemented in the prototype
software. In this algorithm, tips are selected at random from the available tips, with a restriction on
the maximum time since issuance. The default value for the maximum allowed age ζ is 30 minutes.
For the purpose of this experiment, all data is collected for ζ=1 minute. The maximum parent age
period is shortened to allow for measuring the network characteristics in a reasonable time when an
attack lasts for more than one ζ period. This allows the stabilization of the experiment.

In an initial phase of the experiment the docker network is set up with

k = {2, 4, 8, 16}

and ζ=1 minute. Next, there are spamming periods when an orphanage attack is performed for 12 · ζ
duration. Each attack period has a different proportion q of adversarial messages within the total
network throughput that is set to 50 message per second (mps):

qk=2 = [0.35
qk=4 = [0.6
qk=8 = [0.7
qk=16 = [0.8

0.4
0.65
0.75
0.85

0.45
0.7
0.8
0.9

0.5 0.55]
0.75 0.80]
0.88 0.93]
0.94 0.99]

(3.1)

All attacks are separated with idle spamming periods when only honest nodes are issuing activity
messages. It is necessary to allow the network to recover and each node to reduce the tip pool size.
The total throughput is set to be approximately constant during each attack spamming period, i.e.
λH + λA = const. The experiment starts with the smallest proportion q, which is increased with
each next attack period. We investigate the q rates up until a value slightly above the critical point.
The ﬂow of the experiment for a particular k is presented in the top diagram of Figure 3.1. The red
and green volumes show the issuance rate of the adversary and honest nodes, respectively.

No restriction on parent age

The second part of the experiment is investigating the tip pool size and conﬁrmation times increase
if there is no ζ restriction on the maximum parents’ age. The experiment is run for 1 hour with no
restriction on the parents’ age. This setup is used only for qcrit. The experiment is shown in the
bottom diagram of Figure 3.1.

3https://github.com/iotaledger/IOTA-2.0-Research-Speciﬁcations

43

MASTER THESIS

Figure 3.1: Experiment setup. The diagram illustrates the experiment methodology for a chosen
k. The top diagram reﬂects scenario 1) (ﬁxed max parent age, and q variations). With each attack
period, q is increased. All attack periods are followed by an idle spam period with only honest
messages. In scenario 2) (no time restriction) spam duration is increased and only q = qcrit is
investigated.

Impact of the maximum parent age restriction on the orphanage

In the last part, we investigate how the ζ parameter changes the orphanage results. We keep k and q
ﬁxed during the experiment.

3.1.3 Adversarial behavior

To implement the orphanage attack strategy, the Tip Manager component of the GoShimmer
software has been modiﬁed. As described in Section 1.3.3, honest nodes keep track of the current
set of available tips. Whenever there is a new fully processed and correct message it is added to the
tip pool. At the same time, there is a timeout set to remove the tip from the tip pool if it gets too old
according to the maximum parent age parameter ζ. Additionally, the node is removing tips from the
tip pool whenever any other message referencing it is added to the tip pool. The adversary aims to:

44

Series of attacks for q or ζ variationsλ=50 mpsAttack  (duration = 12 ζ)Idle spam  (duration = ζ)λAλHSpamming attack for qcritAttack (duration = 1 h < ζ)λAλHλ=50 mpsMASTER THESIS

• reference only its messages

• reference messages that are closest to the ζ limit

• reference the least possible amount of parents allowed by the protocol to minimize the tip

reduction

There are many ways in which the malicious version of the software can be implemented, to achieve
the goals stated above. The strategies used for this experiment can be summarized accordingly:

• adversary is no longer removing referenced tips from the tip pools even if he knows that a

message has been already referenced,

• tips are tracked in two sets – adversary and honest – of which one is only for adversary’s

messages,

• the adversary is using the honest set only when tips are missing in his own tip set

• because tips are removed only when they are too old, the number of tips the adversary keeps
in its memory is much higher than for honest node, the malicious tip pool size is limited by
deleting more recent messages with a higher probability.

Most of the codebase changes for the purpose of an orphanage attack affect the Tip Manager compo-
nent. The default honest behavior of the component has been mocked, so the base implementation
can be replaced whenever the adversary mode is enabled. The mode can be enabled through a
node’s conﬁguration ﬁle by providing ﬂag parameter adversary.orphanageEnabled=true Thus,
all the network nodes within the docker network can be created from the same GoShimmer image,
and only the change of one parameter is needed to introduce a malicious actor to the network.

The impact of the described above adversarial strategy on the graph structure of the Tangle depends
on the attack duration and the adversary spam proportion. In an initial phase, when the attack
duration is less than ζ, the adversary keeps attaching to the same (his oldest) message as none of his
messages are outdated yet. We show an example for such a case in Figure 3.2, which shows several
screenshots from the Tangle visualizer tool.

Situation A) shows how the Tangle looks in an honest environment. B) shows the beginning of an
attack up until the ζ time is reached. C) presents the Tangle in the middle of an attack, where the
adversary messages (new messages are marked with the red circle) are attached to old messages,
thus creating connections to the older parts of the Tangle. As q is less than the critical value for A),
B) and C) all messages are timely conﬁrmed and the width of the Tangle is small. The visualizer
used to present the Tangle structures created during an experiment has a vertex limit. When the
limit is reached the oldest vertices are removed. The visible end of the tangle was marked with a red
line in C). Additionally added arrows point to how the Tangle structure is connected to the Tangle
part about ζ time in the past, which are the attacker connections to the oldest possible messages.
The whole structure is a circle due to the physic of the visualization tool.

D) and E) show how the situation changes when the adversary throughput proportion achieves the
critical value q = qcrit = 0.5. Case D) shows many red (tips) and grey messages (pending), far

45

MASTER THESIS

Figure 3.2: Collections of screenshots of the Tangle visualisation tool for different stages of an
orphanage attack, for k = 2. The situations in A) represents an honest scenario with q = 0, B) and
C) are taken for q = 0.35, while in D) and E) q = qcrit = 0.5.

outnumbering the blue ones (conﬁrmed), the structure is not visible as at the beginning of an attack
the adversary attaches to only one message. In E) the maximum parent age is contributing to the
reduction of the tip pool size. Thus a growing structure of the DAG can be observed. Note that the
Tangle in E) is visibly wider than in C).

3.2 Results

In this section, the outcome of an orphanage attack adversarial strategy is described. Many
theoretical assumptions introduced in 2.2 have been conﬁrmed in practice. Additionally, some of
the performed attacks have to lead to the crashing of nodes, thus making the network unusable.
This, however, is mostly connected to implementation details, and the robustness of the software

46

MASTER THESIS

h

Figure 3.3: The average tip pool sizes (top subplots) and ﬁnalization times (bottom subplots) for
k = 2, measured for all honest nodes during separate experiments with different adversarial spam
proportions q. The third column shows the critical value qcrit = 0.5. The network setup with parent
age restriction ζ=1[min]. The total network throughput λ = 50mps. The x-axis represents the
duration of the experiment in minutes.

might increase with future versions. In the following sections analysis of the results is presented.
For the complete visualization of all gathered data, we refer to the Appendix 3.

3.2.1 Restriction on the parents’ age.

The orphanage attack exploits the structure of the Tangle and the fact that each node tracks tips
locally. With that, an attacker can cause serious damage to the network, while not breaking any
protocol rules. In the ﬁrst series of experiments, we check how the network will behave under an
ongoing attack.

Figure 3.3 shows the attack impact on the network for k = 2 and how it is changing when the
adversary message proportion increases. The parent age restriction is set to ζ = 1[min] and the
attack continued over the 12ζ time period. The critical point should be the value that represents
when the attack starts to be harmful to the network. Indeed the tip pool noticeably grows signiﬁcant
around and even before qcrit. The increase of the tip pool is not a problem by itself, however along
with tip pool inﬂation, the ﬁnalization times increase too. For q = 0.45, below the theoretical critical
point, the time needed for message conﬁrmation might take up to minutes, instead of seconds as is
the case without an attack. The tip pool size starts growing fast, ﬂattens as the attack progresses,
and ﬁnally, it stabilizes. All tests, performed for other k values behave in a very similar way, as for
the k = 2 example. The slight increase of the tip pool size and conﬁrmation times is visible even
before the critical value qcrit is achieved.

47

0246810120200400600800100012001400Tip Pool Size024681012020040060080010001200140002468101202004006008001000120014000246810120200400600800100012001400024681012k=2, q=0.35012345Confirmation times [min]024681012k=2, q=0.45012345024681012k=2, q=0.5012345024681012k=2, q=0.55012345MASTER THESIS

Figure 3.4 presents a comparison for the critical point of different allowed parent numbers k. Most
importantly, along with increased k the network security against the attack increases. For k = 2 the
major effects on the network are visible already at q ≈ qcrit = 0.5, however, for k = 4 or more, an
attack with this value for q does not affect the Tangle (see 3). Moreover, unsurprisingly tip pool
sizes for critical points of higher k keep increasing, e.g. for k = 8 the Tangle is over 800 tips wide,
which is correspondingly reﬂected in higher ﬁnalization times that can reach up to 4 minutes for
k = 4, while for k = 8 it even exceeds the experiment duration. The reason for the bigger impact
that an attack has at the critical point for higher k values is connected to the percentage of network
throughput controlled by the adversary.

Figure 3.4: The average tip pool sizes (top subplots) and ﬁnalisation times (bottom subplots) for
different k values and their respective critical value qcrit, measured for all honest nodes. The network
setup with parent age restriction ζ=1[min]. The total network throughput λ = 50mps. The x-axis
represents the duration of the experiment in minutes.

3.2.2 Tip pool size inﬂation

The experiment is performed for different values of q including the critical value qcrit. Results
for the restricted parent age show that the tip pool size is under control for q < qcrit. As soon as
the adversary spamming rate achieves the critical proportion, a small tip pool size inﬂation can be
observed. After a few max parent age ζ periods pass, the tip pool size stabilizes. This is expected
since whenever the ﬁrst message issued by the adversary reaches age ζ it is removed from the tip
pool set of all the nodes. Then the adversary is attaching to the next oldest message, which soon
will be removed. If the adversary spams with the ﬁxed rate for a longer time the number of tips
introduced is equal to the number of tips removed to the parent age check. Thus, as Figure 3.3
shows, the number of tips slowly stops to increase and stabilizes. By looking at the tip pool sizes in
Figure 3.5 it can be seen how the tip pool would be increased without the max parent age restriction,

48

0100200300400500600700800Tip Pool Size024681012k=2, q=0.5012345Finalization Times [min]024681012k=4, q=0.75024681012k=8, q=0.88MASTER THESIS

i.e. without the removal of old tips from the tip pool. Assuming that each message removes k − 1
one may expect a linear increase in the tip pool size. However, to understand this effect we have to
reassess the assumption in Section 2.2.3 1) about zero network delay that is no longer valid in a real
network scenario of an experiment: a tip may receive more than one reference and the number of
removed tips by an honest message will thus be less than k − 1. This effect will decrease as the tip
pool size inﬂates, due to the used TSA. Since the probability for each tip to be selected is equal, as
the tip pool size becomes large, the chances for each honest message to be selected (more than once)
decreases. The larger the tip pools size is, the closer it is to the assumption that each honest node
will remove the k − 1 tips. This assumption will limit the size to which the tip pool might grow for
q = qcrit, as the honest nodes will be able to remove exactly the amount of tips being added to the
Tangle.

Figure 3.5: The average tip pool sizes (top subplots) and ﬁnalisation times (bottom subplots) for
different k values and their respective critical value qcrit. The network setup is without restrictions
on the parent age. The total network throughput λ = 50mps. Each subplot presents the points
at which the network broke, and their corresponding time and tip pool size values. The x-axis
represents the duration of the experiment in minutes.

During a longer attack period tested with no restriction on the parents’ age, the experiment was
interrupted by the crushing of some of the honest nodes. As indicated in Figure 3.5 the point in
which the node software starts to crash matches the time when the tip pool size exceeds ≈ 1200
tips. The fact that this breaking point is similar for different k indicates that the cause could be
in the used node’s software implementation. Right after the moment when some of the honest
machines disconnected from the network, the proportion of adversary messages q became higher,
which results in an enormous tip pool size increase and the stop of message ﬁnalization soon after
that moment.

49

025050075010001250150017502000Tip Pool Size(38, 1223)(21, 1223)(6, 1380)(3, 1050)0510152025303540k=2, q=0.501020304050Finalization Times [min]0510152025303540k=4, q=0.750510152025303540k=8, q=0.880510152025303540k=16, q=0.94MASTER THESIS

Figure 3.6: The ﬁrst two minutes of the experiment performed for ζ =1[min] shows the average tip
pool sizes for different k values and q > qcrit. The total network throughput λ = 50mps. The plot
presents the theoretical calculations of the expected tip pool sizes, marked with dashed lines.

3.2.3 Similarities to blowball attack

An interesting point is to consider if similar results might be visible if the attacker use blowball
strategy, see Section 2.2.4, instead of the orphanage attack. In an Orphanage attack, with adversary
network throughput proportion q > qcrit, the tip pool growth exceeds the honest nodes’ capabilities
of reducing tips number. Tips are selected randomly, therefore the bigger tip set is the higher is
chance that a tip will not be selected during the ζ aging period. When the maximum parent age ζ is
reached by the oldest tips, they start to expire with an increasing rate limited by q − qcritλ. Which
counterweights the tip pool inﬂatory rate caused by an adversary and results in limiting the tip pool
size, as presented in Figure 3.3. The blowball strategy might, therefore, have a different impact
on the network, as it temporarily eliminates the factor by which old messages start to be removed
due to parent age restrictions. A blowball attack causes a burst in the tip pool size, however, for
the limited adversary spamming rate, the tip pool size increase will be still limited, similar to the
case of an orphanage attack. Therefore, on average, the damage should be similar. However, by
taking into practical considerations and software limitations, it could be possible that a burst of
transactions will make it harder to process the data structure.

3.2.4 Tip pool size linear growth

In Section 3.2.2 the growth of the tip pool was described for the critical point. There, in case of
a continuous attack, the speed of tip pool growth would go down to zero for the network with no
restriction on the parent age. With assumptions used for the critical point, as described in Section
2.2.3, we expect that the increase of the tip pool is described by a linear function. This reﬂects

50

020406080100120Time [s]020040060080010001200140016001800Tip Pool Size (60, 282) (60, 729) (60, 1327) (120, 487) (120, 1199) (120, 1556)k=2, q=0.55k=4, q=0.8k=8, q=0.93theoretical valuesMASTER THESIS

Figure 3.7: Orphanage results for the experiment wit ζ=1[min] restriction. The left subplot shows
the results for q = qcrit marked with dashed lines, and q < qcrit marked with solid lines. The right
subplot presents the results for q > qcrit. The total network throughput is λ = 50mps.

the best-case scenario in which each honest node removes exactly k − 1 messages from the tip
set. Figure 3.6 shows the ﬁrst two minutes of an attack with k = 2 and adversary spamming rates
exceeding the critical point. Additionally, the ﬁgure presents also the theoretical values for the tip
pool size calculated with formula in Section 2.2.3. The results are close to the predicted values
despite the major simpliﬁcation of the model. Up to 60 seconds, the slope of the lines is matching
the theoretical curve well. However, after one minute, which is ζ time, is exceeded, the increase is
slowed down. This is because the oldest messages, that reached the maximum parent age are being
removed.

3.2.5 Orphanage

To investigate orphanage caused during an attack, the number of unconﬁrmed and older than ζ tips
was recorded, which together with a total number of issued messages gives an approximation of an
orphanage rate present during an attack. Results for the experiment with ζ = 1[min] are showed in
Figure 3.7. The left subplot shows results recorded for critical values for each k and the comparison
on how higher k value stands out for qcrit of previous k. For the critical point, the attack duration
was too short for the orphanage rate to stabilize, as shown in the ﬁrst subplot. However, for the
q > qcrit the rates stabilize in the second half of the attack. For qcrit the numbers of orphans for
each k except k = 8 keep increasing. The decrease in the orphanage rate for the k = 8 parameter
is related to node crashes that happened after 8 minutes of the spam, as visible in Figure 3.4, and
therefore should be ignored. The lowest orphanage results correspond to the q ¡ qcrit for each k. In
such a case, there is no orphanage for k = 8 and k = 16. Surprisingly, for low k some messages
were orphaned even below the critical level. Low orphanage rates (below 1%) for the critical point
are achieved for k = 2, 4. For the higher values, the orphanage present during an attack with critical
adversary message proportion increases up to 5%. The higher number of orphaned messages is
related to higher tip pool sizes inﬂated for k = 8, 16, caused by higher spam rates of an attacker.

51

024681012Attack duration [min]0.000.010.020.030.040.050.06Orphanagek=2, q=0.5k=4, q=0.5k=4, q=0.75k=8, q=0.75k=8, q=0.88k=16, q=0.9k=16, q=0.94024681012Attack duration [min]0.00.20.40.60.8k=2, q=0.55k=4, q=0.8k=8, q=0.93k=16, q=0.99MASTER THESIS

In the case where an adversary controls a proportion of the network throughput exceeding the
critical point, the orphanage rates increase signiﬁcantly. For example, in the extreme scenario where
99% of messages are malicious, four out of ﬁve messages are orphaned. In a more realistic scenario
with q = 0.55 the orphanage rate reaches 40% of all messages. Orphanage rates measured for qcrit
are monotonic in regards to k decreasing. Nevertheless, it is not observed for the values above the
critical point, where k = 2 is more problematic than k = 4. This indicates that the distance of q to
qcrit has a greater impact for smaller k values. In other words, an additional 5% of the total network
throughput for the attacker gives him much more power to damage the system in case of lower k
values.

3.2.6 Impact of changing the ζ parameter.

The previously discussed experiments are performed with the maximum parents’ age parameter
set to ζ = 1[min]. However, in a real network environment, this time range will be higher, e.g.
currently the prototype software uses ζ = 30[min]. Figure 3.8 presents the characteristics measured
for different ζ parameters.

Figure 3.8: The experiment results for q = qcrit = 0.5 and k = 2: the orphanage results, the average
honest node’s tip pool sizes, and the moving average of nodes’ conﬁrmation times are presented
for different ζ parameters. The attack duration of each experiment is 10 · ζ and the total network
throughput is 50 Mps.

52

051015202530350.0000.0020.0040.0060.0080.0100.012Orphanage=20s=40s=60s=80s=100s=120s=180s=300s051015202530350500100015002000Tip Pool Size05101520253035Attack duration [min]0123456Finalization TimeMASTER THESIS

The outcome of the experiment indicates that the change of the maximum allowed age for the
parents has no impact on both the tip pool size and ﬁnalization times for the critical point q = 0.5.
The results agree well with the measurements demonstrated above for the attack on the network
with no parent age restriction.

Values reached up to ζ point are a reﬂection of data presented in Figure 3.5 and the experiment
with no-restriction on the max parent age can be treated as an indicator of what would be the values
of tip pool size and ﬁnalization times for different ζ. This is because the behavior of the network
before this point is reached is exactly the same in both situations.

However, the differences between tip pool sizes and the conﬁrmation rates become visible when
the adversarial spamming rate q exceeds the critical point. As shown in Section 3.2.2 the tip pool
should increase linearly up to the point of reaching ζ time, as after this point adversary’s tips start to
be removed at a constant rate λA. Following this reasoning, the tip pool sizes for different ζ should
not differ until they reach maximum parent age for the ﬁrst time. Therefore, for the different ζ
parameters, the tip pool size increase starts to slow down after different time periods. Thus the lines
representing subsequent ζ values diverge monotonically, one by one, starting from the smallest ζ.
Experimental results conﬁrm the applicability of this simplistic assumption, which can be seen in
Figure 3.9. We show only the ﬁrst 10 minutes for optimized visualization. For the presentation of
the whole experiment duration, we refer to the appendix 3. Since in the experiment the q was above
the critical point, the tip pool inﬂation was signiﬁcant, which caused some nodes in the network
to crash. Therefore, only at the beginning of the experiment, we can observe that the lines start to
diverge after the ζ time is reached for the ﬁrst time. The ﬁnalization times stayed the same as due to
network problems the experiment stopped too soon to notice the effect that a slowing down of the
tip pool size increase has on the ﬁnalization of messages.

53

MASTER THESIS

Figure 3.9: Experiment results for q = 0.55 and k = 2: the orphanage results, the average honest
node’s tip pool sizes, and the moving average of nodes’ conﬁrmation times are presented for
different ζ parameters. The attack duration of each experiment is 10 · ζ and the total network
throughput is 50 mps.

54

0.00.51.01.52.02.53.03.54.00.000.050.100.150.20Orphanage=20s=60s=120s=180s=300s0.00.51.01.52.02.53.03.54.005001000150020002500Tip Pool Size0.00.51.01.52.02.53.03.54.0Attack duration [min]02468Finalization TimeConclusion

After the summary of the most important concepts in the DLT space, the IOTA protocol has been
introduced and portrayed in terms of security ﬂaws along with other blockchain-based projects. The
evolution of the protocol and the reasoning for the Coordicide transition and components of the
protocol were described. Many public blockchain attacks and existing vulnerabilities have been
collected from the existing literature to give context to the studied attack scenario in this work. Also,
a variety of online sources has been searched, for example real-world thefts and security violations,
to increase the awareness of the importance of studies concerning the security of the systems, and
where a small undiscovered vulnerability might lead to a loss of millions of dollars.

In the next part of the thesis the orphanage problem was described and analyzed. Two attack
vectors were introduced: the orphanage attack and the blowball attack. Both are exploiting the
orphanage problem and causing harm to the network through the tip pool inﬂation and increase
of the conﬁrmation times. The orphanage attack was then implemented in a real network setting
within a docker network environment. An extensive study was performed to measure the effects of
the attack on the network for a variety of parameters, such as the part of the network throughput
controlled by an adversary or the number of parent references for a message allowed by the protocol.
The experimental results have conﬁrmed the theoretical assumptions about the tip pool growth and
conﬁrmed that the change of the number of allowed parent references can greatly increase network
robustness towards the attack, by increasing the proportion of the network throughput an adversary
needs to gain for the attack to succeed.

55

Bibliography

[1] S. Popov, “The tangle,” White paper, vol. 1, no. 3, 2018.
[2] “Fallacies of distributed computing.” https://en.wikipedia.org/wiki/Fallacies_of_

distributed_computing. Accessed November 21, 2021.

[3] “Facebook

outage.”

https://engineering.fb.com/2021/10/05/

networking-traffic/outage-details/. Accessed November 21, 2021.

[4] M. J. Fischer, N. A. Lynch, and M. S. Paterson, “Impossibility of distributed consensus with

one faulty process,” Journal of the ACM (JACM), vol. 32, no. 2, pp. 374–382, 1985.

[5] C. Dwork, N. Lynch, and L. Stockmeyer, “Consensus in the presence of partial synchrony,”

Journal of the ACM (JACM), vol. 35, no. 2, pp. 288–323, 1988.

[6] E. A. Brewer, “Towards robust distributed systems,” in PODC, vol. 7, pp. 343477–343502,

Portland, OR, 2000.

[7] S. Gilbert and N. Lynch, “Brewer’s conjecture and the feasibility of consistent, available,

partition-tolerant web services,” Acm Sigact News, vol. 33, no. 2, pp. 51–59, 2002.

[8] D. Dolev and H. Strong, “Distributed commit with bounded waiting,” in Proceedings of the,

1982.

[9] B. Lampson and H. E. Sturgis, “Crash recovery in a distributed data storage system,” 1979.
[10] L. Lamport, R. Shostak, and M. Pease, “The byzantine generals problem,” in Concurrency:

the Works of Leslie Lamport, pp. 203–226, 2019.

[11] M. Larrea, A. Fern´andez, and S. Ar´evalo, “On the impossibility of implementing perpetual
failure detectors in partially synchronous systems,” in Proceedings 10th Euromicro Workshop
on Parallel, Distributed and Network-based Processing, pp. 99–105, IEEE, 2002.

[12] M. Kawazoe Aguilera, S. Toueg, and B. Deianov, “Revisiting the weakest failure detector for
uniform reliable broadcast,” in International Symposium on Distributed Computing, pp. 19–34,
Springer, 1999.

[13] K. Driscoll, B. Hall, H. Sivencrona, and P. Zumsteg, “Byzantine fault tolerance, from theory
to reality,” in International Conference on Computer Safety, Reliability, and Security, pp. 235–
248, Springer, 2003.

[14] M. Castro, B. Liskov, et al., “Practical byzantine fault tolerance,” in OsDI, vol. 99, pp. 173–186,

1999.

[15] B. M. Oki and B. H. Liskov, “Viewstamped replication: A new primary copy method to
support highly-available distributed systems,” in Proceedings of the seventh annual ACM
Symposium on Principles of distributed computing, pp. 8–17, 1988.

56

MASTER THESIS

[16] E. Buchman, J. Kwon, and Z. Milosevic, “The latest gossip on bft consensus,” arXiv preprint

arXiv:1807.04938, 2018.

[17] C. Cachin et al., “Architecture of the hyperledger blockchain fabric,” in Workshop on dis-
tributed cryptocurrencies and consensus ledgers, vol. 310, pp. 1–4, Chicago, IL, 2016.

[18] G. G. Gueta, I. Abraham, S. Grossman, D. Malkhi, B. Pinkas, M. Reiter, D.-A. Seredinschi,
O. Tamir, and A. Tomescu, “Sbft: a scalable and decentralized trust infrastructure,” in 2019
49th Annual IEEE/IFIP international conference on dependable systems and networks (DSN),
pp. 568–580, IEEE, 2019.

[19] L. Baird, “Hashgraph consensus: fair, fast, byzantine fault tolerance,” Swirlds Tech Report,

Tech. Rep., 2016.

[20] T. Rocket, M. Yin, K. Sekniqi, R. van Renesse, and E. G. Sirer, “Scalable and probabilistic
leaderless bft consensus through metastability,” arXiv preprint arXiv:1906.08936, 2019.

[21] “Iota (technology) - wikipedia.” https://en.wikipedia.org/wiki/IOTA_(technology).

Accessed December 20, 2021.

[22] “Alert

system

-

bitcoin.org.”

https://bitcoin.org/en/alert/

2016-11-01-alert-retirement#updates. Accessed January 2022.

[23] S. Popov, H. Moog, D. Camargo, A. Capossele, V. Dimitrov, A. Gal, A. Greve, B. Kusmierz,

S. Mueller, A. Penzkofer, et al., “The coordicide,” Accessed Jan, pp. 1–30, 2020.

[24] S. M¨uller, A. Capossele, B. Ku´smierz, V. Lin, H. Moog, A. Penzkofer, O. Saa, W. Sanders, and
W. Welz, “Salt-based autopeering for dlt-networks,” in 2021 3rd Conference on Blockchain
Research & Applications for Innovative Networks and Services (BRAINS), pp. 165–169, IEEE,
2021.

[25] “Slowmist attacks database.” https://hacked.slowmist.io/en/. Accessed March 2022.

[26] B. Charoenwong and M. Bernardi, “A decade of cryptocurrency ‘hacks’: 2011–2021,” Avail-

able at SSRN 3944435, 2021.

[27] medium, “Medium - review of the blockchain industry 2021.” https://slowmist.medium.

com/our-review-of-the-blockchain-security-industry-in-2021-with-global-losses-exceeding-9-8-billion-60d93efbfca3.
Accessed March 2022.

[28] C. L. Schuba, I. V. Krsul, M. G. Kuhn, E. H. Spafford, A. Sundaram, and D. Zamboni,
“Analysis of a denial of service attack on tcp,” in Proceedings. 1997 IEEE Symposium on
Security and Privacy (Cat. No. 97CB36097), pp. 208–223, IEEE, 1997.

[29] J. Nazario, “Ddos attack evolution,” Network Security, vol. 2008, no. 7, pp. 7–10, 2008.

[30] N. Hoque, D. K. Bhattacharyya, and J. K. Kalita, “Botnet in ddos attacks: trends and chal-
lenges,” IEEE Communications Surveys & Tutorials, vol. 17, no. 4, pp. 2242–2270, 2015.

[31] J. Liu, Y. Xiao, K. Ghaboosi, H. Deng, and J. Zhang, “Botnet: classiﬁcation, attacks, detec-
tion, tracing, and preventive measures,” EURASIP journal on wireless communications and
networking, vol. 2009, pp. 1–11, 2009.

[32] “The spam attack on the nano network - publish0x.com.” https://www.publish0x.com/
cryptowriting/the-spam-attack-on-the-nano-network-summarised-xykoqpz.
Accessed January 2022.

57

MASTER THESIS

[33] “Network halted - reddit.com.” https://www.reddit.com/r/nanocurrency/comments/
m2h9p7/the_network_is_essentially_halted_right_now_and/. Accessed January
2022.

[34] “Nano: Spam attack leads to partial network outage - block-builders.net.” https:

//block-builders.net/nano-spam-attack-leads-to-partial-network-outage/.
Accessed January 2022.

[35] “Hudson jameson thread - twitter.com.” https://twitter.com/hudsonjameson/status/
1438038974946283530?s=20&t=E9jWO_foCW-dJMad1JNXXQ. Accessed January 2022.

[36] “Solana

recovering

-

cryptonews.com.”

solana-full-service-expected-soon-sol-recovering.html.
2022.

https://cryptonews.com/news/
Accessed January

[37] “The

grayscale

report

on

solana-

grayscale.com.”

https://grayscale.com/

wp-content/uploads/2021/12/grayscale-building-blocks-solana-1.pdf?utm_
source=twitter&utm_content=solana&utm_campaign=building_blocks&linkId=
143839577. Accessed January 2022.

[38] A. Yakovenko, “Solana: A new architecture for a high performance blockchain v0. 8.13,”

Whitepaper, 2018.

[39] “Raj gokal’s solana outage response - twitter.com.” https://twitter.com/rajgokal/

status/1469741489467305984?ref_src=twsrc%5Etfw. Accessed January 2022.

[40] “Chainlink

spam attack

-

cryptobrieﬁng.com.”

chainlink-endures-spam-attack-congestion-high-fees/.
2022.

https://cryptobriefing.com/
Accessed January

[41] “Results

of

the

attack

-

azcoinnews.com.”

https://azcoinnews.com/

chainlink-was-subjected-to-a-spam-attack.html. Accessed January 2022.

[42] B. Xu, D. Luthra, Z. Cole, and N. Blakely, “Eos: An architectural, performance, and economic

analysis,” Retrieved June, vol. 11, p. 2019, 2018.

[43] “Slowmist attacks database - eos ecosystem.” https://hacked.slowmist.io/en/?c=EOS.

Accessed March 2022.

[44] A. Singh et al., “Eclipse attacks on overlay networks: Threats and defenses,” in In IEEE

INFOCOM, Citeseer, 2006.

[45] K. W¨ust and A. Gervais, “Ethereum eclipse attacks,” tech. rep., ETH Zurich, 2016.

[46] A. E. Yves-Christian, B. Hammi, A. Serhrouchni, and H. Labiod, “Total eclipse: How to
completely isolate a bitcoin peer,” in 2018 Third International Conference on Security of
Smart Cities, Industrial Control System and Communications (SSIC), pp. 1–7, IEEE, 2018.

[47] P. Perazzo, A. Arena, and G. Dini, “An analysis of routing attacks against iota cryptocurrency,”
in 2020 IEEE International Conference on Blockchain (Blockchain), pp. 517–524, IEEE, 2020.
[48] J. R. Douceur, “The sybil attack,” in International workshop on peer-to-peer systems, pp. 251–

260, Springer, 2002.

[49] J. Newsome, E. Shi, D. Song, and A. Perrig, “The sybil attack in sensor networks: analysis &
defenses,” in Third international symposium on information processing in sensor networks,
2004. IPSN 2004, pp. 259–268, IEEE, 2004.

58

MASTER THESIS

[50] “Sybil

attack

on

monero.”

https://cryptopotato.com/

monero-xmr-sybil-attack-not-broken/. Accessed March 2022.

[51] “Monero sybil attack - hacker website.” https://monero-badcaca.net/, 2020. Accessed

March 2022.

[52] S. Sayeed and H. Marco-Gisbert, “Assessing blockchain consensus and security mechanisms

against the 51% attack,” Applied Sciences, vol. 9, no. 9, p. 1788, 2019.

[53] F. A. Aponte-Novoa, A. L. S. Orozco, R. Villanueva-Polanco, and P. Wightman, “The 51%
attack on blockchains: A mining behavior study,” IEEE Access, vol. 9, pp. 140549–140564,
2021.

[54] “Investopedia - bitcoin gold 51% attack.” https://www.investopedia.com/news/

bitcoin-gold-hack-shows-51-attack-real/. Accessed March 2022.

[55] “Bitcoin

gold

51% attack

report.”

https://gist.github.com/metalicjames/

71321570a105940529e709651d0a9765. Accessed March 2022.

[56] M. Kim, Y. Kwon, and Y. Kim, “Is stellar as secure as you think?,” in 2019 IEEE European
Symposium on Security and Privacy Workshops (EuroS&PW), pp. 377–385, IEEE, 2019.

[57] “Stellar

blockchain

goes

ofﬂine.”

https://cointelegraph.com/news/

stellars-blockchain-briefly-goes-offline-confirming-the-project-lacks-decentralization.
Accessed March 2022.

[58] “Slowmist report - an exploit of ethereum node’s authentication ﬂaw.” https://mp.weixin.

qq.com/s/ia9nBhmqVEXiiQdFrjzmyg. Accessed March 2022.

[59] N. Van Saberhagen, “Cryptonote v 2.0,” 2013.

[60] D. Hopwood, S. Bowe, T. Hornby, and N. Wilcox, “Zcash protocol speciﬁcation,” GitHub:

San Francisco, CA, USA, p. 1, 2016.

[61] D. Leto et al., “Attacking zcash for fun and proﬁt,” Cryptology ePrint Archive, 2020.

[62] F. Tram`er, D. Boneh, and K. Paterson, “Remote side-channel attacks on anonymous trans-
actions,” in 29th {USENIX} Security Symposium ({USENIX} Security 20), pp. 2739–2756,
2020.

[63] “Stanford university - remote side-channel attacks on anonymous transactions.” https://

crypto.stanford.edu/timings/. Accessed March 2022.

[64] G. De Roode, I. Ullah, and P. J. Havinga, “How to break iota heart by replaying?,” in 2018

IEEE Globecom Workshops (GC Wkshps), pp. 1–7, IEEE, 2018.

[65] M. Neuder, D. J. Moroz, R. Rao, and D. C. Parkes, “Selﬁsh behavior in the tezos proof-of-stake

protocol,” arXiv preprint arXiv:1912.02954, 2019.

[66] D. Cai, “A parasite chain attack in iota,” B.S. thesis, University of Twente, 2019.

[67] A. Penzkofer, B. Kusmierz, A. Capossele, W. Sanders, and O. Saa, “Parasite chain detection

in the iota protocol,” arXiv preprint arXiv:2004.13409, 2020.

[68] L. Vries, “Iota vulnerability: Large weight attack performed in a network,” B.S. thesis,

University of Twente, 2019.

59

MASTER THESIS

[69] M. A. Brady, I. Ullah, and P. J. Havinga, “Dosing distributed ledger technology: Iota,” in 2021
IEEE 5th International Conference on Cryptography, Security and Privacy (CSP), pp. 55–61,
IEEE, 2021.

[70] “Iota rfc - white ﬂag.” https://github.com/thibault-martinez/protocol-rfcs/
Accessed

blob/rfc-white-flag/text/0005-white-flag/0005-white-flag.md.
March 2022.

[71] P. Ferraro, C. King, and R. Shorten, “On the stability of unveriﬁed transactions in a dag-based
distributed ledger,” IEEE Transactions on Automatic Control, vol. 65, no. 9, pp. 3772–3783,
2019.

[72] A. Cullen, P. Ferraro, W. Sanders, L. Vigneri, and R. Shorten, “Access control for distributed
ledgers in the internet of things: A networking approach,” IEEE Internet of Things Journal,
2021.

60

Appendix A - complete experimental results

61

MASTER THESIS

a) k = 2

b) k = 4

c) k = 8

d) k = 16

Figure 10: Tip pool sizes for different k during an attack.

62

024681012q=0.350500100015002000Tip Pool Size024681012q=0.4024681012q=0.45024681012q=0.5024681012q=0.55024681012q=0.60500100015002000Tip Pool Size024681012q=0.65024681012q=0.7024681012q=0.75024681012q=0.8024681012q=0.70500100015002000Tip Pool Size024681012q=0.75024681012q=0.8024681012q=0.88024681012q=0.93024681012q=0.80500100015002000Tip Pool Size024681012q=0.85024681012q=0.9024681012q=0.940.00.51.01.5q=0.99MASTER THESIS

a) k = 2

b) k = 4

c) k = 8

d) k = 16

Figure 11: Conﬁrmation events and corresponding times [min] for different k during an attack.

63

024681012q=0.3501234567Confirmation times [min]024681012q=0.4024681012q=0.45024681012q=0.5024681012q=0.55024681012q=0.601234567Confirmation times [min]024681012q=0.65024681012q=0.7024681012q=0.75024681012q=0.824681012q=0.701234567Confirmation times [min]24681012q=0.7524681012q=0.824681012q=0.883456789q=0.93024681012q=0.801234567Confirmation times [min]024681012q=0.85024681012q=0.9024681012q=0.940.0000.0250.0500.0750.1000.1250.150q=0.99MASTER THESIS

a) k = 2

b) k = 4

c) k = 8

d) k = 16

Figure 12: Orphanage rates calculated from cumulative orphan counts and total issued messages for
different k.

64

024681012Attack duration [min]0.00.10.20.30.4Orphanageq=0.5q=0.53q=0.55024681012Attack duration [min]0.0000.0250.0500.0750.1000.1250.1500.175Orphanageq=0.7q=0.75q=0.8024681012Attack duration [min]0.00.10.20.30.4Orphanageq=0.8q=0.88q=0.93024681012Attack duration [min]0.00.20.40.60.8Orphanageq=0.9q=0.94q=0.99MASTER THESIS

a) Finalization times for different ζ and k = 2.

b) Finalization times for different ζ and k = 2.

c) Orphanage rates calculated from cumulative orphan counts and total issued messages for differ-
ent ζ.

Figure 13: Attack performed for different max parent age ζ values. Each attack sustained for 10 · ζ
time period.

65

01020304050Attack duration [min]0500100015002000Tip Pool Size=20=40=60=80=100=120=180=30001020304050Attack duration [min]0123456Confirmation times [min]=20=60=120=180=30001020304050Attack duration [min]0.0000.0020.0040.0060.0080.0100.012Orphanage=20s=40s=60s=80s=100s=120s=180s=300sMASTER THESIS

a) k = 2

b) k = 4

c) k = 8

d) k = 16

Figure 14: Average tip pool sizes for different k and q inﬂated during one hour of orphanage attack
with no restriction on parents age.

66

0102030405060Time [min]025050075010001250150017502000Tip Pool Sizeq=0.50102030405060Time [min]025050075010001250150017502000Tip Pool Sizeq=0.5q=0.750102030405060Time [min]025050075010001250150017502000Tip Pool Sizeq=0.75q=0.880102030405060Time [min]025050075010001250150017502000Tip Pool Sizeq=0.88q=0.93MASTER THESIS

a) k = 2

b) k = 4

c) k = 8

d) k = 16

Figure 15: Finalization times for different k and q measured during one hour of orphanage attack
with no restriction on parents age.

67

0102030405060Attack duration [min]01020304050Confirmation times [min]q=0.50102030405060Attack duration [min]01020304050Confirmation times [min]q=0.5q=0.750102030405060Attack duration [min]01020304050Confirmation times [min]q=0.75q=0.880102030405060Attack duration [min]01020304050Confirmation times [min]q=0.88q=0.93