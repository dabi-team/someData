Data-access performance anti-patterns in
data-intensive systems

Biruk Asmare Muse
Polytechnique Montr´eal
biruk-asmare.muse@polymtl.ca

Kawser Wazed Naﬁ
Polytechnique Montr´eal
kawser.naﬁ@usask.ca

Foutse Khomh
Polytechnique Montr´eal
foutse.khomh@polymtl.ca

Giuliano Antoniol
Polytechnique Montr´eal
antoniol@ieee.org

2
2
0
2

g
u
A
8
1

]
E
S
.
s
c
[

1
v
8
1
9
8
0
.
8
0
2
2
:
v
i
X
r
a

Abstract—Context: Data-intensive systems handle variable,
high volume, and high-velocity data generated by human and
digital devices. Like traditional software, data-intensive systems
are prone to technical debts introduced to cope-up with the
pressure of time and resource constraints on developers. Data-
access is a critical component of data-intensive systems as it
determines the overall performance and functionality of such
systems. While data access technical debts are getting attention
technical debts affecting the
from the research community,
performance, are not well investigated.

Objective: Identify, categorize, and validate data access per-
formance issues in the context of NoSQL-based and polyglot
persistence data-intensive systems using qualitative study.

Method: We collect issues from NoSQL-based and polyglot
persistence open-source data-intensive systems and identify data
access performance issues using inductive coding and build a
taxonomy of the root causes. Then, we validate the perceived
relevance of the newly identiﬁed performance issues using a
developer survey.

Keywords- performance anti-patterns, data-intensive systems,
polyglot persistence systems, NoSQL database, data-access code

I. INTRODUCTION

Leveraging the vast amount of heterogeneous data gener-
ated by humans and machines to obtain actionable insights
is becoming the center of attention in both industry1 and
the research community [1]. Our decisions and way of life
are greatly impacted by the insights and recommendations
obtained from analyzing this big data [2]. Due to the size,
heterogeneity, and complexity, handling this data with tradi-
tional software and applications is becoming more challenging.
As a result, data-intensive software systems leveraging the
availability of cloud infrastructures were introduced to address
this challenge. The development of data-intensive systems in-
volves the integration of data storage (e.g., Relational, NoSQL,
and polyglot databases), processing (e.g., enrichment, clas-
siﬁcation, and prediction), and presentation (Services, APIs,
and applications) frameworks. Data storage and access logic
are critical components of data-intensive systems; determining
their functionality, usability, and performance. Development of
data-intensive systems posses several design, implementation,
and quality assurance challenges [2]–[5]. Developers of such
systems,
like traditional software systems, could introduce
technical debts [6] that compromise software quality due to the
release pressure and focus on the functional requirements. In
addition to the technical debts common in traditional software

1https://techjury.net/blog/big-data-statistics/#gref

systems, data-intensive systems could be prone to data access
speciﬁc technical debts such as data-access smells (e.g., SQL
code smell) [7] and data access performance anti-patterns [8].
While several studies investigated the prevalence and impact
of technical debts in traditional software systems [9]–[14],
few studies considered data-intensive systems and technical
debts related to data access code [7], [15]–[17]. In particular,
technical debts affecting the data access performance are not
well investigated despite their importance in data-intensive
systems. Recently, Shao et al. [8] surveyed recent works to
compile a list of data-access performance anti-patterns and
complemented with new anti-patterns obtained from analyz-
ing data access performance bugs from database-backed web
applications. However, the existing performance anti-patterns
are obtained by considering only relational or SQL databases
and a small number of traditional web applications. Recently,
NoSQL databases are becoming more popular components of
data-intensive systems due to their horizontal scalability and
handling of heterogeneous data (e.g., support for unstructured
data and ﬂexible schema) [18]. Due to the differences in data
access mechanisms between relational and NoSQL databases
[19], the performance anti-patterns identiﬁed in [8] may not be
generalized to NoSQL-based data-intensive systems. Further-
more, to leverage the advantages of both paradigms, polyglot
persistence based systems are becoming more popular. While
the advantage of choosing the database based on the nature
of the data is clear, the associated design, implementation,
and maintenance issues are not well investigated [20]. Hence,
a separate attention should be given to NoSQL-based and
polyglot persistence data-intensive systems.

The goal of this empirical study is to specify data-access
performance anti-patterns by conducting a qualitative analy-
sis of issues collected from the repositories of 75 NoSQL-
based and 87 polyglot persistence open-source data-intensive
systems, and evaluating the perceived relevance of the perfor-
mance anti-patterns by developers of industrial data-intensive
systems. In particular, we seek to answer the following re-
search questions.
RQ1 What are the data-access performance anti-patterns

prevalent in data-intensive systems?
Motivation: Speciﬁcation of data access performance
anti-patterns is important as it is the ﬁrst step before
building automatic detection tools that are leveraged to
study the prevalence and impact of such anti-patterns on

 
 
 
 
 
 
the quality of data-intensive systems and development
of refactoring tools to help developers detect and ﬁx
the design issues before they impact the quality of their
applications.

RQ2 How do developers perceive the relevance of data-

systems [17]. Most of the studies focus on relational or
SQL-based systems. As a result, NoSQL-based and polyglot
persistence systems did not get much attention. In this study,
we focus on NoSQL-based and polyglot persistence based
data-intensive systems to complement the state-of-the-art.

access performance anti-patterns?
Motivation: Answering this research questions provides
the perspective of the developers on the relevance of the
newly identiﬁed performance anti-patterns. In addition,
the taxonomy could be expanded with new potential anti-
patterns that will be suggested by developers based on
their experience.

The rest of the paper is organized as follows. Section II
discusses the related work. Section III discusses in details the
methodology that we plan to follow to answer our research
questions. Finally, we outline our execution plan in Section
IV.

II. RELATED WORK

In this section, we discuss recent works related to data-

access technical debts and performance anti-patterns.

A. Data-access technical debts

The speciﬁcation [21], detection [22]–[24], prevalence [7],
[15], [16] impact [7] and refactoring practices [17] of data-
access technical debts have been investigated recently. Kar-
win et al. [21] speciﬁed a catalog of SQL code smells.
This work inspired researchers to investigate the smells and
propose automatic detection approaches. The proposed tools
perform a static analysis on SQL queries [23], [24] and
SQL queries embedded in data access code [25] to detect
SQL code smells. The availability of the tools promoted
the empirical investigation of the prevalence and impact of
data access technical debts in general and SQL code smells,
in particular, using open source systems. De Almeida Filho
[15] investigated the prevalence and co-occurrence of SQL
code smell on PL/SQL projects. In another work, Muse
et al. [7] conducted a large-scale empirical study on SQL
code smells using open-source data-intensive systems and
found that SQL code smells are prevalent and persistent in
data-intensive systems. In another work, Muse et al. [16]
investigated self-admitted technical debts (SATDS) in SQL
and NoSQL-based data-intensive systems and found that data-
access SATD is introduced as software gets more mature and
persists for a long time without getting addressed. They also
found that data-access SATDs are often introduced during bug
ﬁxing and refactoring activities and proposed a taxonomy of
data-access SATDs. The authors identiﬁed a few instances
of the self-admitted technical debts associated with query
execution performance which can be considered as a data-
access performance anti-pattern admitted by developers. In
this study, however, we investigate data access performance
issues using data from issues reported by the end users of
NoSQL-based and polyglot persistence data-intensive systems.
Recently, developers’ data-access code refactoring practices
were also investigated recently using SQL-based data-intensive

B. Data-access performance anti-patterns

There are few empirical studies on performance bugs [8],
[26]–[29],
their root cause [8], [26], [30], ﬁxing strategy
[8], [26], [27] their impact or relevance [8], [29] and both
static and dynamic analysis based detection approaches [31]–
[34]. Researchers also suggested various ways of data-access
optimization to improve performance of database-backed web
applications using caching and prefetching techniques. [35]–
[38]. Most of the performance studies either focus only on
systems that use ORM driven relational databases or consider
a subset of the performance anti-patterns, hence their ﬁndings
may not be generalized to the case of NoSQL and polyglot
persistence based data-intensive subject systems.

The closest work to this study is the work of Shao et al.
[8] where they provided a catalog of data-access performance
anti-patterns obtained from (1) literature survey (24 anti-
patterns) and (2) 10 new anti-patterns, analyzing real world
performance bugs collected from seven open-source relational
database backed web applications (BugZilla, DNN, Joomla!,
MediaWiki, Moodle, WordPress, and Odoo). Our keyword
based approach to identify data-access performance bugs is
similar to the method used in this work. However, we extended
the keywords to cover the case of NoSQL databases. While
most anti-patterns are associated with SQL queries, some
performance anti-patterns like moving computation to the
sever or not caching could also be observed in NoSQL based
systems. Hence, we aim to extend the data-access performance
anti-patterns to the case of NoSQL and polyglot persistence
data-intensive systems. In addition to providing the catalog,
we will evaluate the perceived relevance of the data-access
performance issues using a developer survey.

III. STUDY METHOD

The goal of this study is to identify, categorize and investi-
gate the perceived relevance of data access performance issues
in the context of NoSQL-based and polyglot persistence based
data-intensive systems. In particular, we use issues collected
from such subject systems as a data source for our analysis.
In this section, we describe the details of the study design
including identifying subject systems, data collection, data
analysis, and answering research questions. Figure 1 shows
the overview of our study method.

A. Data collection

We outline the steps we followed to select the 75 NoSQL
and 87 polyglot persistence-based data-intensive subject sys-
tems in the following paragraphs.

Fig. 1. Overview of the study method.

1) Search repositories: Similar to the approach we fol-
lowed in our previous work [16], we ﬁrst collected a list
of popular NoSQL databases such as MongoDB, Riak, and
Redis. The list of databases is obtained from Eclipse JNoSQL
framework2 that provides a set of APIs for java applications
to interact with NoSQL databases. The complete list of the
databases is available in our replication package [39]. We
conducted a repository search using GitHub rest API V3,
we looked for repositories that mention at least one of the
databases in our list in their title, description, or README ﬁle.
To avoid tutorials and toy projects we set the search criteria
to consider active repositories (whose latest push is not older
than one year from the data collection date), repositories that
are not mirrored to other repositories, repositories whose code
size is at least 100 KB and repositories with at least two stars
[20].

We ran the repository search on March 1, 2022, and we
found 20340 candidate repositories before applying the quality
ﬁlters and 3264 remained after applying the quality ﬁlter.

For identifying polyglot persistence data-intensive systems,
we started with the work of Benats et al.
[20] where
they investigated the usage of multi-database models us-
ing projects collected from Libraries.IO3. They assessed
the popularity of different database models including poly-

2http://www.jnosql.org/docs/supported dbs.html
3https://libraries.io/

Fig. 2. Elasticsearch query to identify data access performance issues

glot persistence models. As part of their replication pack-
age,
they released the database of projects and their cor-
responding usage of relational and key-value, wide-column,
document-oriented and graph-based NoSQL models. In par-
ticular, we used two tables from the provided database,
the ﬁrst one is a view (FILTERED REPOSITORIES VIEW)
that provides the list of repositories after quality ﬁltering
least
(projects having at
two stars). This list contains 42176 projects. The second
table (SQL NOSQL REPOSITORY WITH DBMS TYPE)
provides the usage of the aforementioned database models in

least 100 KB code size and at

List of NoSQL keywords[1] search repositories3264 NoSQL based systems[2] Filter out non-english repositories[3] Select repositories with the highest number of issues[4] Manually filter out irrelevant repositories75 NoSQL based and 87 polyglot persistence based subject systems[5] Collect issues[1] Filter data access performance issuesElasticsearch DBData-access performance issuesData collectionData extractionConduct developer survey to verify the relevance of identified performance anti-patternsOpen coding of data-access performance issuesTaxonomy of data access performance anti-patternsRQ1RQ22172 polyglot persistence based systemsall projects. Combining the two, we obtained the database
model usage of all the 42K systems. Since our goal is to
identify systems that use polyglot persistence databases, we
selected repositories that have at least two database models re-
sulting in 6877 polyglot persistence-based applications. Once
we collected the metadata of each repository, we removed
repositories whose latest push is older than one year from the
data collection date similar to the criteria of NoSQL subject
systems. We ﬁnally ended up with 2172 polyglot subject
systems.

2) Filter non-English repositories: We observed that the
description and readme ﬁles are not written in English for
some repositories. We ﬁltered out repositories whose descrip-
tions are not written in English using Langdetect4 python
library. After the language ﬁltering, 2498 NoSQL and 1604
polyglot persistence-based repositories remained.

3) Select repositories with the highest number of issues:
Since analyzing all issues from the 4102 repositories is not
feasible and since there is no automatic way to measure the
relevance of the systems, we need to restrict the number of
subject systems by sorting the systems in decreasing order of
the number of issues and picking the top projects. We selected
the top 150 NoSQL based and 150 polyglot persistence-based
systems as candidate subject systems.

4) Manually ﬁlter out irrelevant repositories: We manually
went through each of the 300 subject systems’ repositories
on GitHub and investigated the description, code, README,
and issues to understand their functionality and relevance
to our study as data-intensive systems. We also ﬁltered out
repositories with non-English language descriptions missed by
the Langdetect. After this ﬁltering, the remaining 75 NoSQL
based data-intensive systems and 87 polyglot persistence based
data-intensive systems were selected as subject systems, 162
in total. The list of our subject systems is available in the
replication package [39].

5) Collect Issues: For each of the 162 subject systems,
we collected all issues from their GitHub repositories using
PyGithub5, which provides a python wrapper for GitHub
REST API6. For each issue, we collected the title, body,
issue number, URL, state, creation time, comments, labels,
and closing time if the issue is closed. Since we want to
investigate the solutions proposed to mitigate the issues, we
are only interested in closed issues. We collected a total of
526672 closed issues from NoSQL based systems and 257840
closed issues from the polyglot persistence-based systems and
stored them in the Elasticsearch database. Table I provides the
mean, standard deviation and the ﬁve number summary of the
number of stars, number of forks, code size, and number of
closed issues for our candidate subject systems.

B. Data Extraction

In this subsection we discuss the procedure we followed to
ﬁlter data access performance issues from the collected 526K

4https://pypi.org/project/langdetect/
5https://pygithub.readthedocs.io/en/latest/index.html
6https://docs.github.com/en/rest

TABLE I
DISTRIBUTION OF REPOSITORY LEVEL METRICS FOR NOSQL AND
POLYGLOT SUBJECT SYSTEMS

Metric

Group Minimum 25% Median

Mean

75%

Maximum

std

Stars

Forks

Code size (Kb)

Closed issues

Age (years)

Polyglot
NoSQL

Polyglot
NoSQL

Polyglot
NoSQL

Polyglot
NoSQL

Polyglot
NoSQL

5
7

0
1

744
1126

30
303

2.32
1.4

71.5
405

29
174

7912
8515

476
1001

4.56
4.71

508
2229

127
428

4616.91
6083.81

1157.80
1318.23

2896
9043.5

621
954

22,727
23,010

130741.72
132062.04

138677.5
85,238.50

1028
1936

6.09
6.97

2963.41
6761.79

6.4
7.1

2163.5
4366

8.3
9.52

61167
58918

36393
21435

1719944
3836513

33914
128001

12.99
13.76

10747.29
9880.86

4072.99
2863.24

297229.78
458862.46

5541.40
18274.97

2.4
3.03

issues and come up with the performance issue dataset.

1) Filter data access performance issues: Similar to the
work of Shao et al. [8], we use the following heuristics to iden-
tify issues related to data access performance. We constructed
an Elasticsearch query string using keywords associated with
performance (performance, slow, timeout, sluggish), keywords
associated with data access (read, write, fetch, update, delete,
load), and database-related keywords (data, database, query,
schema, index, cache, table, partition, document) connected
by AND operator. The query is formed in multiple rounds
by examining the returned results and modifying the query
to minimize false positives. We applied the query against the
issue title and the issue body. Figure 2 shows the ﬁnal query
we used to ﬁlter data access performance issues where “|”
represents OR operator and “ + ” represents AND operator.
We obtained 3760 issues from the NoSQL based systems and
2645 issues from the polyglot persistence-based systems.

C. RQ1 Taxonomy of data-access performance issues

We use open coding approach to come up with the tax-
onomy of data access performance issues. Two authors will
participate in the labeling. We leverage the relevance score
obtained from the Elasticsearch to sort the performance issue
dataset from most relevant to least relevant. The relevance
score measures the relevance of the issues to the search query.
We next perform the labeling of the sorted dataset in multiple
rounds with 100 labels per round until label saturation is
achieved. To minimize the impact of researcher bias, we assign
the issues to each author under the constraint that each issue
will be reviewed by two authors. Furthermore, each author will
get the chance to label independently each issue and resolve
labeling-conﬂicts by discussing among themselves. We utilize
the list of performance anti-patterns [8] as a seed and continue
adding new labels as we continue the labeling.

Once labeling saturation happens, all authors will participate
in building the taxonomy from the ground up using the card
sorting approach to come up with the taxonomy of data
access performance issues. Leveraging the outcome of this
research question, we will discuss the differences between
the root causes of SQL based and NoSQl based data-access
performance anti-patterns and the underlying reasons behind
the difference.

D. RQ2 Developer survey

Once we identify the data access performance issues taxon-
omy from RQ1, the next step is to investigate the performance
issues that are relevant to the developers of data-intensive
systems. We plan to use a survey to collect the feedback
of the developers on the proposed taxonomy of data access
performance issues in NoSQL subject systems. The survey
will consist of personal information queries about software
development experience, preferred programming language,
and developers’ role in their organization or projects. This will
help us to proﬁle the professional experience and expertise
of our respondents. We also introduce each category of the
performance issues and ask the rating of their relevance from
1 to 5. We also put a place for their optional comments and an
open question to mention new performance issue categories.
1) Survey participants selection: Our inclusion criteria are
that developers should have at least one year of industrial de-
velopment experience on NoSQL-based databases or polyglot
persistence systems. We will use LinkedIn7 as a platform to
recruit survey participants. We ﬁrst compile a list of keywords
that will help us ﬁnd NoSQL-based and polyglot data-intensive
system developers. Then, we will use the keywords to search
the proﬁles of the developers and manually go through the pro-
ﬁles of the matched participants if their experience is relevant
to our study as per the inclusion criteria. We will also include
contributors involved in the subject systems development as
survey participants. We plan to add a reward based on the
random draw of willing participants that completed the survey.
We expect at least 40 complete responses before closing the
survey.

Table II shows the tentative survey questionnaire structure.
The survey starts by introducing the research and asking for
participants’ informed consent. The following sections contain
the anti-patterns associated with each high-level category and
their description and a Likert scale of ratings of how critical
the anti-pattern is. It ranges from: Not critical (1) to Highly
critical (5). After that we will ask for optional additional
comments about the smell. We plan to have one section per
high-level category. Next, we will give a chance for partici-
pants to mention new types of performance anti-patterns with
an optional open question. We end the survey by obtaining
demographic information such as participants’ experience in
software development and data access code development.

IV. EXECUTION PLAN

we outline our execution plan to answer the research ques-
tions in this work. Currently, we ﬁnished the data collection
and data extraction stages of the study method. Hence, We will
outline the steps we plan to answer the research questions.

1) We prepare and test a web-based tool to help us in the

labeling process.

2) We start the ﬁrst round of independent labeling using the
labeling tool and conduct a discussion to resolve conﬂicts
and reach a consensus on the labeling.

7https://www.linkedin.com/

TABLE II
TENTATIVE SURVEY STRUCTURE TEMPLATE

Section

Title

Content

1

2

3
...

Introduction

Anti-pattern category #1

Anti-pattern category #2
....

Additional anti-patterns

Demographics

- Summary of the description of the research, the role of participants, and the informed
consent to be accepted/denied by the survey
participants. The participants will access the remaining section on the condition that they
choose to participate in the research
1. Anti-pattern #1
- description
- rating (Not critical (1) to Highly critical (5))
- Comments(optional)
2. Anti-pattern #2 - description
- rating (Not critical (1) to Highly critical (5))
- Comments(optional)
....
1. Anti-pattern #1
- description of the anti-pattern
- rating (Not critical (1) to Highly critical (5)) (Likert scale)
- Comments(optional)
2. Anti-pattern #2 - description
- rating (Not critical (1) to Highly critical (5))
- Comments(optional)
....
Would you like to suggest other type of data access performance anti-patterns that
are not mentioned in the previous sections? (Open question, optional)
How many years of experience do you have in software development?
How many years of experience do you have in back-end and
database access code development?
Which database access(persistence) frameworks, if any,
do you use for development?
Personal information(Email)(Optional)

3) We repeat the previous step in multiple rounds until we

achieve label saturation.

4) We organize a card sorting session to categorize and
group the labels to build the taxonomy. We will be able
to answer RQ1 after completing this step.

5) Once we ﬁnish RQ1, we prepare the survey questionnaire
and start to recruit the participants using a convenience
sampling approach.

6) We will obtain research ethics approval to conduct the

survey from the relevant authority.

7) We will share the survey with candidates that provided

their consent to participate in the survey.

8) Once we obtain the survey responses, we will perform
quantitative and qualitative analyses of the candidate
responses to answer RQ2.

V. LIMITATIONS OF THE STUDY

One of the internal

limitations of this study would be
the performance anti-patterns
ﬁnding out and covering all
of data access systems. We are considering open source
subject systems for our studies. Although we have selected
data-intensive systems with the higher number of issues and
carefully analyzed the available information with each of our
subject systems, still there is a chance of missing some of
the corner-case performance anti-patterns which were not been
experienced by our selected subject systems. Moreover, at the
time of studying with open-source subject systems, we can
not ensure whether the ﬁndings of our study will be same
for the industry-level data-intensive systems. To mitigate this,
we plan to perform an extensive developer study. We plan
to ensure at least 40 developers’ participation for our study
where the developers need to posses signiﬁcant experiences
with the data-access code and back-end development. And
like our authors, developers will get a chance to add new
performance anti-pattern labels based on their knowledge and
experience.

In addition to that, there is a probability of missing some
potential data-access performance issues as those were not

appeared with our selected top 162 systems. Our subject
systems are selected based on the criteria we described in the
data collection, ”selection of repositories with highest number
of issues”. To mitigate this limitation, we plan to give the
opportunity to the developers who are going to participate
in the survey to add non-listed data-access performance anti-
pattern labels based on their own knowledge and experience.
Another internal limitation could be ensuring the proper
selection of issues from the subject systems for the study.
It
the issues are related to data-
access performance anti-patterns. And some of the issues have
improper descriptions too. To mitigate this challenge, we have
decided to perform manual labeling of issues with all the
authors’ mutual decision and proper veriﬁcation in several
rounds. In addition to that, we will validate our identiﬁed and
listed performance anti-patterns with developers.

that not all

is evident

The external limitations of our study could be the selection
of experienced developers. To keep our study bias-free and
ensure the quality of our study, we plan to select developers
based on their deliberately declared experience with data ac-
cess systems as well as their willingness to participate. As the
ﬁrst step of this process, we have decided to select developers
for our study by sending invitations through LinkedIn.

REFERENCES

[1] M. Naeem, T. Jamal, J. Diaz-Martinez, S. A. Butt, N. Montesano, M. I.
Tariq, E. De-la Hoz-Franco, and E. De-La-Hoz-Valdiris, “Trends and
future perspective challenges in big data,” in Advances in Intelligent
Data Analysis and Applications. Springer, 2022, pp. 309–325.

[2] B. Park, D. L. Rao, and V. N. Gudivada, “Dangers of bias in data-
intensive information systems,” in Next Generation Information Pro-
cessing System, P. Deshpande, A. Abraham, B. Iyer, and K. Ma, Eds.
Singapore: Springer Singapore, 2021, pp. 259–271.

[3] A. Cleve, T. Mens, and J. Hainaut, “Data-intensive system evolution,”

Computer, vol. 43, no. 8, pp. 110–112, 2010.

[4] H. Foidl, M. Felderer, and S. Bifﬂ, “Technical debt in data-intensive
software systems,” in 2019 45th Euromicro Conference on Software
Engineering and Advanced Applications (SEAA), 2019, pp. 338–341.
[5] O. Hummel, H. Eichelberger, A. Giloj, D. Werle, and K. Schmid, “A
collection of software engineering challenges for big data system devel-
opment,” in 2018 44th Euromicro Conference on Software Engineering
and Advanced Applications (SEAA), 2018, pp. 362–369.

[6] E. Tom, A. Aurum, and R. Vidgen, “An exploration of technical debt,”
Journal of Systems and Software, vol. 86, no. 6, pp. 1498–1516, 2013.
[7] B. A. Muse, M. M. Rahman, C. Nagy, A. Cleve, F. Khomh, and G. An-
toniol, “On the prevalence, impact, and evolution of sql code smells
in data-intensive systems,” in Proceedings of the 17th International
Conference on Mining Software Repositories, 2020, pp. 327–338.
[8] S. Shao, Z. Qiu, X. Yu, W. Yang, G. Jin, T. Xie, and X. Wu, “Database-
access performance antipatterns in database-backed web applications,”
in 2020 IEEE International Conference on Software Maintenance and
Evolution (ICSME).

IEEE, 2020, pp. 58–69.
[9] F. Khomh, M. Di Penta, and Y.-G. Gueheneuc, “An exploratory study of
the impact of code smells on software change-proneness,” in 2009 16th
Working Conference on Reverse Engineering.
IEEE, 2009, pp. 75–84.
[10] F. A. Fontana, V. Ferme, A. Marino, B. Walter, and P. Martenka,
“Investigating the impact of code smells on system’s quality: An
empirical study on systems of different application domains,” in 2013
IEEE International Conference on Software Maintenance, Sep. 2013,
pp. 260–269.

[11] A. Yamashita and L. Moonen, “Exploring the impact of inter-smell rela-
tions on software maintainability: An empirical study,” in Proceedings of
the 2013 International Conference on Software Engineering, ser. ICSE
’13.

IEEE Press, 2013, p. 682–691.

[12] D. Johannes, F. Khomh, and G. Antoniol, “A large-scale empirical study
of code smells in javascript projects,” Software Quality Journal, pp. 1–
44, 2019.

[13] F. Palomba, G. Bavota, M. Di Penta, F. Fasano, R. Oliveto, and
A. De Lucia, “On the diffuseness and the impact on maintainability of
code smells: a large scale empirical investigation,” Empirical Software
Engineering, vol. 23, no. 3, pp. 1188–1221, 2018.

[14] M. Iammarino, F. Zampetti, L. Aversano, and M. Di Penta, “Self-
admitted technical debt removal and refactoring actions: Co-occurrence
or more?” in 2019 IEEE International Conference on Software Mainte-
nance and Evolution (ICSME).

IEEE, 2019, pp. 186–190.

[15] F. G. de Almeida Filho, A. D. F. Martins, T. d. S. Vinuto, J. M. Monteiro,
´I. P. de Sousa, J. de Castro Machado, and L. S. Rocha, “Prevalence of
bad smells in pl/sql projects,” in Proceedings of the 27th International
Conference on Program Comprehension.
IEEE Press, 2019, pp. 116–
121.

[16] B. A. Muse, C. Nagy, A. Cleve, F. Khomh, and G. Antoniol, “Fixme:
Synchronize with database an empirical study of data access self-
admitted technical debt,” arXiv preprint arXiv:2201.02180, 2022.
[17] B. A. Muse, F. Khomh, and G. Antoniol, “Do developers refactor data
access code? an empirical study,” arXiv preprint arXiv:2202.03270,
2022.

[18] M. Kleppmann, Designing data-intensive applications: The big ideas
behind reliable, scalable, and maintainable systems. ” O’Reilly Media,
Inc.”, 2017.
´A. Vathy-Fogarassy and T. Hugy´ak, “Uniform data access platform for
sql and nosql database systems,” Information Systems, vol. 69, pp. 93–
105, 2017.

[19]

[20] P. Benats, M. Gobert, L. Meurice, C. Nagy, and A. Cleve, “An em-
pirical study of (multi-) database models in open-source projects,” in
International Conference on Conceptual Modeling.
Springer, 2021,
pp. 87–101.

[21] B. Karwin, SQL Antipatterns: Avoiding the pitfalls of database program-

ming. Pragmatic Bookshelf, 2010.

[22] C. Nagy and A. Cleve, “A static code smell detector for SQL queries
embedded in Java code,” in 2017 IEEE 17th International Working
Conference on Source Code Analysis and Manipulation (SCAM).
IEEE,
2017, pp. 147–152.

[23] P. Khumnin and T. Senivongse, “Sql antipatterns detection and database
refactoring process,” in 2017 18th IEEE/ACIS International Conference
on Software Engineering, Artiﬁcial Intelligence, Networking and Paral-
lel/Distributed Computing (SNPD), June 2017, pp. 199–205.

[24] T. Sharma, M. Fragkoulis, S. Rizou, M. Bruntink, and D. Spinellis,
“Smelly relations: Measuring and understanding database schema qual-
ity,” in 2018 IEEE/ACM 40th International Conference on Software
Engineering: Software Engineering in Practice Track (ICSE-SEIP), May
2018, pp. 55–64.

[25] C. Nagy and A. Cleve, “SQLInspect: A static analyzer to inspect
database usage in Java applications,” in Proceedings of the 40th Interna-
tional Conference on Software Engineering: Companion Proceeedings.
ACM, 2018, pp. 93–96.

[26] G. Jin, L. Song, X. Shi, J. Scherpelz, and S. Lu, “Understanding
and detecting real-world performance bugs,” ACM SIGPLAN Notices,
vol. 47, no. 6, pp. 77–88, 2012.

[27] A. Nistor, T. Jiang, and L. Tan, “Discovering, reporting, and ﬁxing
performance bugs,” in 2013 10th working conference on mining software
repositories (MSR).
IEEE, 2013, pp. 237–246.

[28] Y. Liu, C. Xu, and S.-C. Cheung, “Characterizing and detecting per-
formance bugs for smartphone applications,” in Proceedings of the 36th
international conference on software engineering, 2014, pp. 1013–1024.
[29] J. Yang, C. Yan, P. Subramaniam, S. Lu, and A. Cheung, “How not to
structure your database-backed web applications: a study of performance
bugs in the wild,” in 2018 IEEE/ACM 40th International Conference on
Software Engineering (ICSE).

IEEE, 2018, pp. 800–810.

[30] M. Selakovic and M. Pradel, “Performance issues and optimizations in
javascript: an empirical study,” in Proceedings of the 38th International
Conference on Software Engineering, 2016, pp. 61–72.

[31] A. Nistor, L. Song, D. Marinov, and S. Lu, “Toddler: Detecting per-
formance problems via similar memory-access patterns,” in 2013 35th
International Conference on Software Engineering (ICSE).
IEEE, 2013,
pp. 562–571.

[32] T.-H. Chen, W. Shang, Z. M. Jiang, A. E. Hassan, M. Nasser, and
P. Flora, “Detecting performance anti-patterns for applications developed

using object-relational mapping,” in Proceedings of the 36th Interna-
tional Conference on Software Engineering, 2014, pp. 1001–1012.
[33] ——, “Finding and evaluating the performance impact of redundant
data access for applications that are developed using objectrelational
mapping frameworks,” IEEE Transactions on Software Engineering,
vol. 42, no. 12, pp. 1148–1161, 2016.

[34] J. Yang, C. Yan, P. Subramaniam, S. Lu, and A. Cheung, “Powerstation:
Automatically detecting and ﬁxing inefﬁciencies of database-backed web
applications in ide,” in Proceedings of the 2018 26th ACM Joint Meeting
on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering, 2018, pp. 884–887.

[35] I. T. Bowman and K. Salem, “Optimization of query streams using
semantic prefetching,” ACM Transactions on Database Systems (TODS),
vol. 30, no. 4, pp. 1056–1101, 2005.

[36] A. Cheung, O. Arden, S. Madden, and A. C. Myers, “Automatic
partitioning of database applications,” arXiv preprint arXiv:1208.0271,
2012.

[37] X. Xiao, S. Han, D. Zhang, and T. Xie, “Context-sensitive delta
inference for identifying workload-dependent performance bottlenecks,”
in Proceedings of the 2013 International Symposium on Software Testing
and Analysis, 2013, pp. 90–100.

[38] T.-H. Chen, W. Shang, A. E. Hassan, M. Nasser, and P. Flora,
“Cacheoptimizer: Helping developers conﬁgure caching frameworks for
hibernate-based database-centric web applications,” in Proceedings of
the 2016 24th ACM SIGSOFT International Symposium on Foundations
of Software Engineering, 2016, pp. 666–677.

[39] B.

A. Muse,

[Online].
https://github.com/Biruk-Asmare/data acess performance

“Replication

package,”

2022.

Available:
antipatterns in data intensive systems RR.git

