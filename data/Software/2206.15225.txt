2
2
0
2

n
u
J

0
3

]
I

A
.
s
c
[

1
v
5
2
2
5
1
.
6
0
2
2
:
v
i
X
r
a

Are Hitting Formulas Hard for Resolution?

Tom´aˇs Peitl
peitl@ac.tuwien.ac.at

Stefan Szeider
sz@ac.tuwien.ac.at

Abstract

Hitting formulas, introduced by Iwama, are an unusual class of proposi-
tional CNF formulas. Not only is their satisﬁability decidable in polynomial
time, but even their models can be counted in closed form. This stands
in stark contrast with other polynomial-time decidable classes, which usu-
ally have algorithms based on backtracking and resolution and for which
model counting remains hard, like 2-SAT and Horn-SAT. However, those
resolution-based algorithms usually easily imply an upper bound on resolu-
tion complexity, which is missing for hitting formulas. Are hitting formulas
hard for resolution?

In this paper we take the ﬁrst steps towards answering this question.
We show that the resolution complexity of hitting formulas is dominated by
so-called irreducible hitting formulas, ﬁrst studied by Kullmann and Zhao,
that cannot be composed of smaller hitting formulas. However, by deﬁnition,
large irreducible unsatisﬁable hitting formulas are diﬃcult to construct; it is
not even known whether inﬁnitely many exist. Building upon our theoretical
results, we implement an eﬃcient algorithm on top of the Nauty software
package to enumerate all irreducible unsatisﬁable hitting formulas with up
to 14 clauses. We also determine the exact resolution complexity of the
generated hitting formulas with up to 13 clauses by extending a known SAT
encoding for our purposes. Our experimental results suggest that hitting
formulas are indeed hard for resolution.

1

Introduction

Hitting formulas (also known as hitting clause-sets) are propositional formulas
in conjunctive normal form (CNF) with the property that each pair of clauses
clashes, meaning there is a variable that occurs in one clause and its negation
in the other. Introduced by Iwama [10] in 1989 and given the name ‘hitting’ by
Kleine B¨uning and Zhao [12], they are notorious for Iwama’s stunningly elegant
argument (reproduced here as Theorem 1), which shows that their satisﬁability
can be decided in polynomial time—in fact, the number of models can be
obtained in closed form. This is a rare encounter in the bay of tractability:
most other polynomial-time decidable subclasses of SAT (‘islands of tractability’)
have algorithms with more typical ingredients like unit propagation, (bounded-
depth) backtracking, and resolution [6]. Such algorithms usually do not scale

1

 
 
 
 
 
 
{x, y}, {y, z}, {z, x}, {x, y, z}, {x, y, z}

Figure 1: An example hitting formula written as a set of clauses, each itself a set
of literals.

to the case of model counting, which remains #P-hard for 2-SAT and Horn-
SAT, two of the most prominent tractable cases of SAT [26]. Due to their
remarkable properties, hitting formulas have been the subject of many theoretical
investigations [7, 12, 14–17, 19, 22, 28, 30] and served as a building block of larger
classes of tractable formulas via backdoors [21] and treewidth [8].

But one fundamental question remains unsettled: while polynomial-time
resolution-like algorithms usually provide a corresponding polynomial upper
bound on the resolution complexity (length of a shortest resolution refutation) of
formulas they target, it is far from clear how one could get such a bound from the
counting argument for hitting formulas. Resolution complexity has established
itself as an important measure due to its relation to the running time of conﬂict-
driven clause-learning (CDCL [27]) SAT solvers—resolution complexity gives a
lower bound for CDCL running time and, under some assumptions also an upper
bound (although these assumptions include non-determinism) [2, 3, 25]. Even
though the resolution complexity of hitting formulas might not have immediate
practical consequences, it is still a natural question to ask for a famous class of
formulas and a fundamental complexity measure.

So, are hitting formulas hard for resolution? On the one hand, they are
easy even for model counting; on the other hand, the reason why they are easy
to solve is a global counting argument, the kind which is notoriously hard for
resolution (as witnessed, for instance, by the Pigeonhole Principle [9] or Tseitin
Formulas [29]). With this paper, we attempt to shed some light on this question.
One reason why we know so little about the resolution complexity of hitting
formulas is that we have no good methods of constructing large hard instances.
We can construct large hitting formulas by carefully gluing together smaller
hitting formulas, but that only produces reducible formulas, a notion recently
proposed by Kullmann and Zhao [19]. In contrast, we observe (Corollary 5)
that any sequence of hitting formulas must implicitly contain arbitrarily large
irreducible formulas to have a chance at being hard for resolution. However,
large irreducible formulas are non-trivial to construct because they cannot be
assembled from smaller ones by deﬁnition, at least not by known constructions.
That leads us to another straightforward yet non-trivial question: do there
even exist inﬁnitely many irreducible unsatisﬁable hitting formulas? We hint that
this is indeed the case by enumerating all irreducible unsatisﬁable hitting formulas
on up to 14 clauses (and some larger) modulo isomorphisms and observing that
their numbers grow fast. Kullmann and Zhao proved [19, Lemma 39], perhaps
suprisingly, that all irreducible unsatisﬁable hitting formulas other than x ∧ ¬x

2

must be regular —meaning each literal must occur at least twice (also known
as nonsingular, though we prefer the more positive term). Another surprise we
discovered is that there is no irreducible unsatisﬁable hitting formula with 4 or 6
clauses (and none with 2 or 3, but that is an artifact of regularity; see Table 1).
Now that we have the formulas, we might as well compute their shortest
refutations. Armed with recent developments in both the theory of hitting formu-
las [19] as well as in practical computation of shortest resolution refutations [23],
we can compute shortest refutations of all irreducible hitting formulas on up to
13 clauses (and some larger) and all regular hitting formulas on up to 11 clauses.
The picture that this unveils indicates that hitting formulas are perhaps not
as hard as the hardest formulas in general (by comparing with the resolution
hardness numbers [23]), but not signiﬁcantly easier either.

We need some theoretical advances to narrow our search space and compute
shortest refutations faster. Following the lead of Kullmann and Zhao [18, 19], we
focus on the aforementioned concept of irreducibility, and we observe that a new
property we call strong irreducibility is also essential. We prove irreducibility and
strong irreducibility coincide for hitting formulas, allowing us to take advantage
of the stronger variant while only checking the weaker one.

Our contributions are thus twofold. First, we contribute theoretical knowledge
about irreducibility and regularity in (not only) hitting formulas, with a focus
on connections to resolution complexity. Second, we extensively evaluate the
resolution complexity of hitting formulas using the new theoretical results. In
the experimental part, we rely on two key tools: the ability to generate formulas
modulo isomorphisms, provided by a customized version of Nauty [20], and an
eﬃcient way to compute shortest refutations of generated formulas. For the
latter, we use a recently proposed SAT encoding [23], but we enhance it with
further symmetry breaking and constraints that exploit irreducibility.

Our ﬁndings indicate that small hitting formulas are almost as hard for
resolution as the hardest formulas with the same number of clauses, suggesting
that hitting formulas in general might not admit polynomial-size resolution
refutations.

2 Preliminaries

We assume familiarity with standard notions of graph theory, including those
of (un)directed graphs, acyclicity, and in- and out-degree of a vertex—we refer
to a standard graph theory handbook [4]. All graphs considered, directed or
undirected, do not contain any self-loops or parallel edges.

2.1 Formulas

We consider propositional formulas in conjunctive normal form (CNF) represented
as sets of clauses. We assume an inﬁnite set V of (propositional) variables. A

3

literal (cid:96) is a variable x or a negated variable ¬x; we write lit := { x, ¬x | x ∈ V }.
For a literal (cid:96) we write (cid:96) := ¬x if (cid:96) = x, and (cid:96) := x if (cid:96) = ¬x. For a set C of
literals, we deﬁne C := { (cid:96) | (cid:96) ∈ C }; we say C is tautological if C ∩ C (cid:54)= ∅. A ﬁnite
non-tautological set of literals is a clause; a ﬁnite set of clauses is a (CNF) formula.
The empty clause is denoted by ⊥. We say two clauses C and D clash if C ∩D (cid:54)= ∅;
the literals in C ∩ D and C ∩ D are the clashing literals, and their variables are the
clashing variables. For a clause C, we put var(C) = { var((cid:96)) | (cid:96) ∈ C }, and for a
formula F , var(F ) = (cid:83)
C∈F var(C). Similarly, we put lit(F ) := var(F ) ∪ var(F ).
An (partial) assignment is a mapping τ : V ⊆ var(F ) → {0, 1}, extended to
literals as τ (x) = 1 − τ (x). An assignment is called total if its domain is var(F ).
We identify an assignment with the set of literals τ −1(1) ∪ τ −1(0), i.e., with the
set of all literals set to 1 by τ . For a clause C and a set of literals τ (which
could be an assignment) we deﬁne the restriction of C by τ , written C[τ ], as (cid:62) if
C ∩ τ (cid:54)= ∅ (in which case we say τ satisﬁes C), and C \ τ otherwise. If C[τ ] = ⊥
for a clause C and total assignment τ , we say C covers τ . The restriction of a
formula F by an assignment τ , written F [τ ], is deﬁned as {C[τ ] | C ∈ F } \ {(cid:62)}.
A formula F is satisﬁable if there is a satisfying assignment (also model ), i.e., a
total assignment τ with F [τ ] = ∅; otherwise it is unsatisﬁable. For two formulas
F and G, we say F entails G, denoted by F |= G, if every model of F is a model
of G. We say F and G are (logically) equivalent, denoted F ≡ G, if F |= G and
G |= F . We write #F for the number of models of F .

2.2 Resolution Refutations

If C1 ∩ C2 = {(cid:96)} for clauses C1, C2 and a literal (cid:96), then the resolution rule allows
the derivation of the clause D = (C1 ∪ C2) \ {(cid:96), (cid:96)}; D is the resolvent of the
premises C1 and C2, and we say that D is obtained by resolving on (cid:96). For a
formula F , a sequence P = C1, . . . , Cs of clauses is a resolution derivation of Cs
from F if for each i ∈ {1, . . . , s} at least one of the following holds.

1. Ci ∈ F (“Li is an axiom”);

2. Ci is the resolvent of Lj and Lj(cid:48) for some 1 ≤ j < j(cid:48) < i (“Ci is obtained

by resolution”).

We write |P | := s and call s the length of P . If Ls is the empty clause, then P
is a resolution refutation of F . A clause Ci in a resolution derivation may have
diﬀerent possible ‘histories.’ Ci may be the resolvent of more than one pair of
clauses preceding Ci, or Ci may be both an axiom and obtained from preceding
clauses by resolution. In the sequel, however, we assume that an arbitrary but
ﬁxed single history is associated with each considered resolution derivation. Thus,
with a refutation P we can associate the directed acyclic graph (refutation DAG)
G(P ) whose vertices are the clause of P , and which has an arc from Ci to Cj if
there is Ck, i, k < j, such that Cj is the resolvent of Ci and Ck. In any refutation

4

DAG G(P ), the in-degree of each axiom vertex is 0, while each resolvent has
in-degree 2.

It is well known that resolution is a complete proof system for unsatisﬁable
formulas: a formula is unsatisﬁable if and only if there exists a resolution refutation
of it [5]. The resolution complexity or resolution hardness h(F ) of an unsatisﬁable
formula F is the length of a shortest resolution refutation of F . For a nonempty
set C of formulas, we deﬁne h(C) = supF ∈C h(F ).

2.3 Unsatisﬁability Minimal and Saturated

A formula F is minimally unsatisﬁable if it is unsatisﬁable and removing any
clause C ∈ F leaves F \ {C} satisﬁable. A formula F is saturated minimally
unsatisﬁable if it is unsatisﬁable and adding any literal (including on a fresh
variable) to any clause makes it satisﬁable. The central notion of the paper is, of
course, that of a hitting formula.

Deﬁnition 1. A formula F is hitting if for every C, D ∈ F , C (cid:54)= D, C and D
clash.

Hitting formulas are notable for the following useful property.

Theorem 1 (Iwama [10]). The number of satisfying assignments of a hitting
formula F = {C1, . . . , Cm} with n variables is given by 2n(1 − (cid:80)m

i=1 2−|Ci|).

Proof. Because each pair of clauses of F clashes, every assignment can only be
covered by at most one clause. Since for each clause we can explicitly calculate
the number of assignments it covers, we get the overall number of covered
assignments—models are simply assignments that are not covered.

Corollary 1. A hitting formula F is unsatisﬁable if and only if (cid:80)

C∈F 2−|C| = 1.

Corollary 2. All unsatisﬁable hitting formulas are saturated minimally unsatis-
ﬁable.

Proof. Consider what happens to the model-counting sum after adding a literal or
deleting a clause (both of which are operations that trivially preserve hittingness).

Two important notions in the context of minimally unsatisﬁable formulas are
singularity and deﬁciency. A literal (cid:96) ∈ lit(F ) is singular if it is only contained
in one clause. A variable v ∈ var(F ) is singular if v or v is a singular literal. A
formula is singular if it has a singular variable, and is regular otherwise. Singular
formulas can be reduced by DP-reduction—the elimination of a variable v by
taking all possible resolvents on v and then removing all clauses that contained
v or v. While DP-reduction can be applied to any variable of any formula
preserving satisﬁability, singular DP-reduction—when the eliminated variable v
is singular—always decreases formula size, and thus can be applied exhaustively

5

until a regular formula is obtained in overall polynomial time. Thus arises the
importance of regular formulas—they are a kind of ‘core’ left over once singular
variables are eliminated.

The other important notion in the context of minimally unsatisﬁable formulas
is that of the deﬁciency, deﬁned as the diﬀerence between the number of clauses
and the number of variables of a formula, and known to be positive for minimally
unsatisﬁable formulas [1]. It is known that minimally unsatisﬁable formulas of
deﬁciency 1 with more than 1 clause are always singular, and, up to isomorphism,
there is only one regular minimally unsatisﬁable formula of deﬁciency 2 for each
number of clauses m ≥ 4 [11] (otherwise there are none); we will refer to it
as F 2
m. These formulas are actually saturated minimally unsatisﬁable, and for
m = 4, 5 also hitting. Kullmann and Zhao refer to F 2
5 as F2 and F3
respectively [19].

4 and F 2

It is known that singular DP-reduction of minimally unsatisﬁable formulas
preserves both minimal unsatisﬁability as well as deﬁciency, and it also preserves
saturated minimal unsatisﬁability [18, Corollaries 10 and 13]. While singular
DP-reduction is not necessarily conﬂuent in minimally unsatisﬁable formulas
(diﬀerent orders of elimination can result in diﬀerent formulas), it is conﬂuent in
saturated minimally unsatisﬁable formulas [18, Thm 23].

We will use the following acronyms to describe various classes of formulas:
UH (unsatisﬁable hitting), RUH (regular UH), IUH (irreducible UH, necessarily
regular), SMU (saturated minimally unsatisﬁable), RSMU (regular SMU), SSMU
(singular SMU), RISMU (irreducible RSMU), SISMU (irreducible SSMU). For
each of these classes we may append one or two integral parameters in parentheses:
for example IUH(n, m) are IUHs with exactly n variables and m clauses, and
IUH(m) are IUHs with exactly m clauses (without the restriction on the number
of variables).

2.4 Isomorphisms and Symmetries

An isomorphism between two formulas F and G is a bijection ϕ : lit(F ) →
lit(G) such that for each literal (cid:96) ∈ lit(F ) we have ϕ((cid:96)) = ϕ((cid:96)) and for each
C ⊆ lit(F ) we have C ∈ F if and only if ϕ(C) := { ϕ((cid:96)) | (cid:96) ∈ C } ∈ G.
If
there is an isomorphism between F and G, we say F and G are isomorphic. For
instance the formulas F = {{x, y}, {x, y}, {y}}, and G = {{z, w}, {z, w}, {w}}
are isomorphic. Obviously, two isomorphic formulas have the same properties
concerning satisﬁability, minimal unsatisﬁability, and resolution complexity.

An automorphism (or symmetry) of a CNF formula F is an isomorphism to
itself. Aut(F ) denotes the set of automorphisms of F . For an automorphism
ϕ ∈ Aut(F ) we denote by ϕ∗ the bijection var(F ) → var(F ) deﬁned by ϕ∗(x) =
var(ϕ(x)); ϕ∗ is the variable action of ϕ on x. Let Aut∗(F ) denote the set of all
variable actions of Aut(F ).

The orbit of a literal (cid:96) in F is the set OrbF ((cid:96)) = { ϕ((cid:96)) | ϕ ∈ Aut(F ) }. The
F (x) = { ϕ∗(x) | ϕ ∈ Aut∗(F ) }.

variable orbit of a variable x in F is the set Orb∗

6

For sets S, S(cid:48), T , we write T = S (cid:93) S(cid:48) if T = S ∪ S(cid:48) and S ∩ S(cid:48) = ∅. A
2-graph is an undirected graph G = (V, E) together with a partition of its vertex
set into two disjoint subsets V1 (cid:93) V2 = V . Two 2-graphs G = (V1 (cid:93) V2, E) and
G(cid:48) = (V (cid:48)
1 (cid:93) V (cid:48)
2
such that v ∈ Vi if and only if ϕ(v) ∈ V (cid:48)
i , i = 1, 2, and {u, v} ∈ E if and only if
{ϕ(u), ϕ(v}} ∈ E(cid:48).

2, E(cid:48)) are isomorphic if there exists a bijection ϕ : V1 (cid:93) V2 → V (cid:48)

1 (cid:93) V (cid:48)

The clause-literal graph of a formula F is the 2-graph G(F ) = (V1 (cid:93)V2, E) with
V1 = lit(F ), V2 = F , and E = { {x, x} | x ∈ var(F ) } ∪ { {C, (cid:96)} | C ∈ F, (cid:96) ∈ C }.
We refer to the edges { x, x } as variable edges. It is easy to verify that any two
formulas are isomorphic if and only if their clause-literal graphs are isomorphic
(as 2-graphs).

3

Irreducibility

The central notion of this section is that of a formula factor (called ‘clause-factor’,
and later ‘clause-irreducible’ by Kullmann and Zhao [19]).

Deﬁnition 2 (Kullmann and Zhao [19]). A factor of a formula G is a subset
F ⊆ G logically equivalent to a single clause C. The clause C is called the basis
of the factor F and is uniquely determined.

Lemma 1. Let F ⊆ G. Then F is a factor if and only if there is a clause C
such that C ⊆ D for every D ∈ F and { D \ C | D ∈ F } is unsatisﬁable.

Proof. If F is a factor, then its basis satisﬁes the conditions on C. Conversely, if
there is such a C, then F must be equivalent to it.

Non-trivial formula factors, like non-trivial factors for integers and other
kinds of algebraic objects, can be used to decompose or reduce formulas. That
leads to the central notion of an irreducible formula—one which cannot further
be reduced by collapsing factors to their bases.

Deﬁnition 3 (Kullmann and Zhao [19]). A formula G is called irreducible if
for each factor F ⊆ G either |F | = 1 or F = G. Otherwise, it is reducible.

There is an important connection between factors and resolution hardness. In
a nutshell, in presence of non-trivial factors, one can always pursue the strategy
of reducing any remaining non-trivial factors to their bases, gradually shrinking
the formula. These reductions can be performed in resolution, giving a way
of constructing a canonical ‘decomposition’ refutation. An upper bound on
resolution complexity follows.

Lemma 2. Let G be an unsatisﬁable formula with m clauses, F ⊆ G a factor of
size k, C the basis of F . Then G has a proof of length at most h(F [C]) + h({C} ∪
G \ F ) − 1.

7

Proof. Because F is a factor, F [C] is unsatisﬁable and can be refuted in h(F [C])
resolution steps. By re-inserting C, we can derive C from F in h(F [C]) resolution
steps. Because F ≡ C, G \ F ∪ {C} is still unsatisﬁable, and hence can be refuted
in h({C} ∪ G \ F ) steps. Combining the two refutations minus 1 for the shared
clause C we get the result.

In the previous proof, we do not actually need that F ≡ C. All we need is
that F |= C and G \ F ∪ C is unsatisﬁable. In other words, that C is a kind of
‘interpolant’ of F and G \ F . Such generalised factors will turn out quite useful
in the context of resolution.

Deﬁnition 4. A clause C is a clause interpolant of (F, G) if F |= C and
C |= ¬G. We say that F ⊆ H is a pseudo-factor of H if (F, H \ F ) has a clause
interpolant. A formula H with m clauses is strongly irreducible if it has no
pseudo-factors of size other than 1 or m, otherwise it is weakly reducible.

Corollary 3. Let G be an unsatisﬁable formula with m clauses, F ⊆ G a pseudo-
factor of size k, C a clause interpolant of (F, G \ F ). Then G has a refutation of
length at most h(F [C]) + h({C} ∪ G \ F ) − 1.

It is easy to see that strong irreducibility is indeed a strengthening of ir-
reducibility (Lemma 3), but the converse is not true even for MU formulas
(Example 1).

Lemma 3. Every unsatisﬁable strongly irreducible formula is irreducible.

Proof. A non-trivial factor is by deﬁnition also a non-trivial pseudo-factor.

Example 1. The formula {{x, y}, {x}, {y}} is minimally unsatisﬁable and irre-
ducible (no pair of clauses is equivalent to a single clause). But it is not strongly
irreducible: the ﬁrst two clauses form a pseudo-factor with the clause interpolant
{y}.

The formula in the previous example is minimally unsatisﬁable but not satu-
rated. As it turns out, it must be; for saturated minimally unsatisﬁable formulas
(which includes hitting formulas), irreducibility implies strong irreducibility.

Theorem 2. Any pseudo-factor of a saturated minimally unsatisﬁable formula
is also a factor. Consequently, an SMU formula is strongly irreducible if and only
if it is irreducible.

Proof. For contradiction, let F ⊂ G be a non-trivial pseudo-factor of the pseudo-
reducible SMU formula G, let C be the clause interpolant. Let F (cid:48) = { D ∪ C |
D ∈ F }. Then F (cid:48) ≡ F ∨ C, and hence F (cid:48) |= C and so F (cid:48) ∪ G \ F is unsatisﬁable.
Because G is saturated, F (cid:48) = F . Clearly C |= F (cid:48) = F , and so F is in fact a
factor and G is reducible.

8

Theorem 2 is an important background link that allows us to beneﬁt from
strong irreducibility while only having to check irreducibility, which is simpler
(cf. Section 5, where we describe how we generate irreducible hitting formulas,
and Subsection 6.1, where we use strong irreducibility in computing shortest
resolution refutations).

Although saturated minimal unsatisﬁability is suﬃcient to elevate irreducibil-

ity onto strong irreducibility, it is not necessary.

Example 2. The minimally unsatisﬁable formula {{x1, x2}, {x2, x3}, {x3, x4},
{x4, x1}, {x1, x2, x3}, {x1, x2, x3, x4}} is not saturated (it is obtained by deleting
the literal x4 from the 5th clause of the unique deﬁciency-2 RSMU formula F 2
6 ),
yet it is strongly irreducible. Admittedly, why it is strongly irreducible is not
obvious: we veriﬁed this by computer, trying every possible split and every possible
clause interpolant.

Finally, we arrive at the statement that we will actually use in our encoding
to prune the search spaces by asserting certain kinds of refutations do not exist
for strongly irreducible minimally unsatisﬁable formulas.

Lemma 4. Let F be a strongly irreducible minimally unsatisﬁable formula with
more than 2 clauses, let P be a resolution refutation of F . Let C, D ∈ F be two
axioms that are resolved together in P . Then at least one of C, D is used at least
once more in P .

Proof. {C, D} (cid:40) F is not unsatisﬁable, because F is minimally unsatisﬁable.
Hence P continues beyond the resolution of C and D. If neither C nor D is
used another time, then the resolvent of C and D is a clause interpolant for
({C, D}, F \ {C, D}), contradicting F ’s strong irreducibility.

Kleine B¨uning and Zhao [13] studied read-once refutations for minimally
unsatisﬁable formulas—ones in which every clause is only used once. Lemma 4
has implications for the existence of read-once refutations for strongly irreducible
formulas.

Corollary 4. Strongly irreducible minimally unsatisﬁable formulas with more
than 2 clauses do not have read-once refutations.

Example 3. Corollary 4 is in a sense tight, because there are strongly irreducible
formulas with refutations where only a single axiom is read twice and everything
else only once. An example is the formula

F 2

5 = {{x1, x2}, {x2, x3}, {x3, x1}, {x1, x2, x3}, {x1, x2, x3}},

known to have hardness 10 by [23], with a shortest refutation shown in Figure 2.

One could ask whether the decomposition refutation from Lemma 2 is optimal.

This is not the case, as witnessed by the following example.

9

{x1, x2}

{x1, x2, x3}

{x2, x3}

{x1, x2, x3}

{x3, x1}

{x1, x2}

{x1, x3}

{x1}

{x1}

⊥

Figure 2: A shortest resoluton refutation of the formula F 2
(axioms highlighted).

5 from Example 3

{x, y, e}

{y, z, e}

{y, z, e}

{x, y, z, e}

{x, y, z, e}

{x, z, e}

{x, z, e}

{x, y, z}

{x, y, z}

{x, y, e}

{x, y, e}

{x, y, z}

{x, y, z}

{x, z}

{x, z}

{x, y}

{x, y}

{x}

{x}

⊥

Figure 3: A shortest resolution refutation of the formula G from Example 4
(axioms highlighted).

Example 4. Let F = {{x, y, z}, {x, y, z}, {x, y, e}, {x, y, e}, {x, z, e}, {x, z, e},
{y, z, e}, {y, z, e}}. F is the formula F4,8,52 from [23] and so is known to have
hardness 19. Now, consider G obtained from F by replacing the clause {x, z, e}
with the clauses {x, y, z, e} and {x, y, z, e}. Clearly, G is reducible: the two new
clauses are a factor, whose basis is the replaced clause. If the decomposition
refutation were optimal, the hardness of G would have been 3 + h(F ) − 1 = 21.
But G has a refutation of length 20 (see Figure 3).

Thus concludes our tour of irreducibility and its strong cousin. In the follow-
ing subsection, we show that asymptotic resolution hardness of hitting formulas
is decided on irreducible formulas—if they have polynomial-size resolution refuta-
tions, so do all unsatisﬁable hitting formulas. Then, in Subsection 6.1, we employ
strong irreducibility to improve the computation of shortest refutations.

3.1 Irreducible Formulas and Asymptotic Hardness

The goal of this subsection is to show that irreducible hitting formulas are no easier
(asymptotically up to a polynomial factor) for resolution than non-irreducible
ones, thus showing that the question of whether hitting formulas have polynomial
refutations can be decided solely by looking at irreducible formulas. Even though

10

our focus is on hitting formulas here, there is nothing special about hittingness
that makes (strongly) irreducible formulas asymptotically hardest. We can state
and prove the theorem generally for any class of unsatisﬁable formulas that is
closed under factorisation.

Deﬁnition 5. Let C be a set of unsatisﬁable formulas. We say C is closed under
factorisation if for every weakly reducible formula G ∈ C and pseudo-factor F of
G with clause interpolant C, both F [C] and G \ F ∪ {C} are in C.

Theorem 3. Let C be a set of unsatisﬁable formulas closed under factorisation,
let C∗ ⊆ C be the set of strongly irreducible formulas of C, and let µ : N → N
be a non-decreasing function such that every formula F ∈ C∗ has a resolution
refutation of length at most µ(|F |). Then every formula F ∈ C has a resolution
refutation of length at most (|F | − 1)µ(|F |) + 1.

Proof. By induction on the number of clauses.

Base case. Every unsatisﬁable formula has at least one clause. The induction
hypothesis holds for the only 1-clause unsatisﬁable formula, which contains only
the empty clause and has a refutation of length (1 − 1)µ(1) + 1 = 1. The
induction hypothesis also holds for all G ∈ C∗ because when |G| > 1, we have
(|G| − 1)µ(|G|) + 1 > µ(|G|).

Inductive step. Consider a weakly reducible G ∈ C \ C∗. Pick a non-trivial
pseudo-factor F ⊂ G, let C = (cid:84) F be the clause interpolant of F and G \ F , let
F (cid:48) = F [C] and H = G \ F ∪ {C}. By Corollary 3, G has a refutation of size
h(F (cid:48)) + h(H) − 1. Because C is closed under factorisation, F (cid:48), H ∈ C. Both F (cid:48)
and H have fewer clauses than G, and so by the induction hypothesis h(F (cid:48)) ≤
(|F (cid:48)| − 1)µ(|F (cid:48)|) + 1 and h(H) ≤ (|H| − 1)µ(|H|) + 1. Summing up, we get that
h(G) ≤ h(F (cid:48))+h(H)−1 ≤ (|F (cid:48)|+|H|−2)µ(|G|)+2−1 = (|G|−1)µ(|G|)+1.

When C = UH, Theorem 3 translates to the following corollary.

Corollary 5. If irreducible unsatisﬁable hitting formulas have polynomial-size
resolution refutations, then so do all unsatisﬁable hitting formulas.

Proof. In order to apply Theorem 3 to hitting formulas and obtain the statement,
all that needs to be shown is that the set of hitting formulas is closed under
factorisation. This follows from Lemma 33 of [19] (and from the fact that any
pseudo-factor of a hitting formula is a factor by Theorem 2), but we also repeat
the argument below for sake of completeness.

It is easy to see that if G is hitting, then F ⊆ G is also hitting, and hittingness
is further preserved under restriction, hence F [C] is hitting. Now, consider the
other formula G \ F ∪ {C}, where F is a factor of G and C is the basis of F .
Clearly G \ F ⊆ G is hitting. It remains to show that C clashes with all clauses in
G \ F . By contradiction, assume it does not clash with D ∈ G \ F . Then, because
G is hitting, D clashes with every clause in F , but because D does not clash
with C, in fact D clashes with every clause in F [C] = {E \ C | E ∈ F }. This is

11

the same as saying that D is a satisfying assignment for F [C], contradicting the
assumption that F |= C.

In fact, a slightly stronger statement still than Corollary 5 can be derived
from Theorem 3. Let (G1, . . . ) be an inﬁnite sequence of hitting formulas
of super-polynomial resolution hardness, assuming one exists. Let C be the
closure of {G1, . . . } under factorisation, i.e., the intersection of all sets closed
under factorisation containing {G1, . . . }. Then C contains an inﬁnite sequence
of irreducible formulas of superpolynomial hardness—for if it did not, then
Theorem 3 would imply that the sequence (G1, . . . ) also has polynomial-size
refutations. In other words, in order to construct a family of hard hitting formulas,
one must at least implicitly construct a family of hard irreducible hitting formulas.

4 Symmetries

In this section we will see how formula symmetries can be used to manipulate
resolution refutations and to single out certain canonical ones.

Lemma 5. Let G be an unsatisﬁable formula, ϕ ∈ S(G) a symmetry with
ϕ∗(x) = y for some x, y ∈ var(G). If there is a shortest refutation of G that
ends with resolving x, then there is one that ends with resolving y. Moreover, the
refutation can be arranged such that it ends with either the sequence {y}, {y}, ⊥
or {y}, {y}, ⊥ (both are always possible).

Proof. The ﬁrst part follows by applying σ to the refutation (literal by literal).
For the rest we need to show that neither of {y}, {y} is needed to derive the
other. Suppose {y} is used in the derivation of {y}; surely by removing the use
of {y} we will end up with a derivation of a clause that at most contains an
additional y—but it already did to begin with.

Lemma 6. Let G be an unsatisﬁable formula, S(G) its symmetry group, O the
set of orbits under the variable action. Let R ⊆ var(G) be a set of representatives
of each orbit from O, i.e., for all O ∈ O |R ∩ O| = 1. Then there is a variable
v ∈ R and a shortest refutation of G which ends in the sequence {v}, {v}, ⊥, and
one which ends in the sequence {v}, {v}, ⊥.

Proof. There is some shortest refutation of G and it ends by resolving some
variable x. Let y ∈ R ∩ O(x), and apply Lemma 5.

5 Generating Hitting Formulas

We generate hitting formulas with a tailor-made adaptation of Nauty [20], which
generates clause-literal graphs modulo isomorphisms. In order to generate for-
mulas eﬃciently, we hook into Nauty’s generation process and prune partially

12

constructed formulas on the ﬂy when we determine they cannot be extended to
full formulas.

Suppose we are generating formulas with n variables and m clauses. Nauty
generates the formulas by progressively adding vertices corresponding to clauses
in all possible ways modulo isomorphisms. Thus, it eﬀectively exploring a
tree of ‘partial’ formulas, and the leaf nodes are ‘full’ formulas we want to
generate. Suppose we have a partially constructed candidate formula F =
{C1, . . . Cm(cid:48)}, m(cid:48) ≤ m (including the possibility m(cid:48) = m, i.e., the formula is a
leaf node). Thanks to the way Nauty generates graphs, we can assume that Cm(cid:48)
is the largest clause of F and that all further clauses added in any extension
of F will be at least as large as Cm(cid:48). As we are interested in generating only
IUHs and not arbitrary formulas, we can aﬀord to prune as follows (here prune
means discard the current partial formula and immediately backtrack in the tree
explored by Nauty):

• if #F > (m − m(cid:48))2n−|Cm(cid:48) |, prune (otherwise future clauses cannot cover all

satisfying assignments).

• If #F < m − m(cid:48), prune (every clause must uniquely cover at least one
assignment, and here we have too few satisfying assignments to be uniquely
covered by future clauses).

• If F is not hitting, prune.

• If F has a non-trivial factor, or if F itself is a factor and 1 < m(cid:48) < m,

prune.

The ﬁrst three checks can be implemented in linear time: models can be
counted easily thanks to Theorem 1, for hittingness it is suﬃcient to check whether
the last clause hits every other, because the same check has been performed on
{C1, . . . , Cm(cid:48)−1} already.

We test the fourth condition by enumerating all non-empty subsets F (cid:48) ⊆ F
and checking whether F (cid:48) ≡ I := {(cid:84) F (cid:48)}. Since obviously I |= F (cid:48), it is suﬃcient to
compare the number of models in order to see whether I and F (cid:48) are equivalent—
and this can be done in polynomial time as before, because F (cid:48) is still hitting.
Moreover, thanks to the incremental nature of the check, we can focus only on
subsets F (cid:48) with Cm(cid:48) ∈ F (cid:48).

We note that it is possible to test irreducibility faster than by traversing
all subsets of clauses. The key observation is that any factor in a minimally
unsatisﬁable formula must be intersection-maximal, meaning that any its strict
superset has a strictly smaller intersection (we leave this as exercise for the
reader, it follows straightforwardly from the deﬁnitions). Thus, one only needs
to enumerate intersection-maximal subsets of clauses, which can be done with
polynomial delay (enumerate subsets recursively and after each branching, include
all clauses that contain the current intersection; again we leave the details to the

13

reader). However, we did not implement this in Nauty, as the full traversal has
an advantage in technical simplicity that outweighs algorithmic gains for small
numbers of clauses.

We also generated some reducible regular unsatisﬁable hitting formulas
(RUHs).
In that case, we can re-use the pruning described above, and sim-
ply skip the fourth test. However, focusing on irreducible formulas allows us to
prune signiﬁcantly more and generate formulas faster and up to bigger size; and
the resulting number of formulas is smaller making subsequent processing more
manageable (see Section 7).

6 Computing Shortest Refutations

In this section we will see how to use (strong) irreducibility and formula symme-
tries in order to rule out certain refutations, thereby pruning the search space
and making it easier for the solver to show no refutations of a given length exist.
The problem we are solving asks, given a formula F and integer s, whether F
has a resolution refutation of length at most s, i.e., whether there is a sequence
C1, . . . , Cs such that each Ci is either a clause of F , or is derived by resolution from
two previous clauses. We will solve the problem by reduction to SAT, building
on a previous encoding of ours [23]; for a full presentation of the encoding we
refer to that paper. Here we will only recall that the encoding is centered around
the following three sets of propositional variables:

• pos[i, v] and neg[i, v] denote that the v and v occur in the i-th clause of

the refutation;

• arc[i, j] denotes that the i-th clause is used to obtain the j-th clause via
resolution. Every non-axiom clause has exactly two incoming arcs, i.e., for
all j > m (cid:80)j−1

i=1 arc[i, j] = 2 (where m is the number of clauses).

An assignment to these variables together fully determines a candidate reso-
lution derivation: it is then left to constraints to validate that the derivation is a
valid refutation.

We generally assume that F is minimally unsatisﬁable, as all formulas we
work with are. In the following two subsections, we ﬁrst show how we can add a
further redundant constraint when we additionally assume strong irreducibility,
and then how we can reason about refutation symmetries via formula symmetries.

6.1 Strong Irreducibility and Clause Reuse

Recall Lemma 4, which tells us that we must resolve some axioms more than
once. We will simply translate it into a SAT encoding. We deﬁne a set of fresh
variables active[i, j] equal to the clause {arc[i, j], . . . , arc[i, s]} to denote that
the i-th clause is still ‘active’ at position j in the refutation, i.e., it is used for

14

resolution to obtain the j-th or later clause.1 With this, we can rewrite Lemma 4
right into the set of clauses

(cid:8)arc[i, k], arc[j, k], active[i, k + 1], active[j, k + 1](cid:9),

for 1 ≤ i < j ≤ m and m < k < s. In practice, because this constraint can get
quite large, we decided to use only a limited version, where k is ﬁxed to m + 1
(i.e., we only apply Lemma 4 to the ﬁrst resolvent of the refutation).

We point out that while the constraint just described is a translation of
Lemma 4, successful application also relies on Theorem 2. That is because while
we require strong irreducibility, we generate formulas that are only irreducible.
But because they are hitting (saturated minimally unsatisﬁable), Theorem 2
kicks in and warrants strong irreducibility.

6.2 Symmetries

Recall Lemma 6, which says that formula symmetries can be applied in order to
obtain symmetric images of refutations. If we ﬁx an arbitrary set R of variable
representatives, thanks to Lemma 6 we need only look for refutations which end
in a variable from R. Further, we can place the two clashing unit clauses at
the end of the refutation in the order we pick (say the penultimate clause has
a negative literal). This is quite straightforward to put into constraints: for all
v ∈ var(F ) we include the unit clauses {pos[s − 1, v]} and {neg[s − 2, v]}, and for
all v ∈ var(F ) \ R, we include the unit clauses {neg[s − 1, v]} and {pos[s − 2, v]}.
Additionally, we stipulate that the literals appearing in Cs−1 and Cs−2 are on the
same variable, i.e., for all v ∈ R, neg[s − 1, v] = pos[s − 2, v], and the arc structure
at the end of the refutation: {arc[s − 2, s]}, {arc[s − 1, s]}, and {arc[s − 2, s − 1]}.
The encoding presented in our previous work [23] uses symmetry breaking to
allow only one sequence for any given refutation DAG—the canonical topological
sort. Care must be taken to ensure that our new formula symmetry breaking is
compatible with canonical topological sorting. Fortunately, there is a simple way
out: disable canonical topological sorting on the clauses Cs−1, Cs−2.

7 Results

We will now present our experimental results and connections to the work of
others.

The main results are summarised in Tables 1 and 2. For each pair n, m,
they show the maximum hardness of IUHs (Table 1) and RUHs (Table 2) with
n variables and m clauses, together with the number of formulas which attain
maximum hardness (subscript) and total number of formulas with n variables
and m clauses (superscript; both numbers modulo isomorphisms). We computed

1We use the Tseitin encoding in order to translate this set of equations into CNF.

15

Figure 4: Hardness in subclasses of SMU. The opaque bar shows average
hardness for a given number of clauses, the transparent bar extends to maximum
hardness. While irreducible hitting formulas are not as hard as general hitting
formulas in the worst case, they are harder on average.

these numbers (the shortest refutations mainly) on a cluster of heterogeneous
machines with the SAT solver CaDiCaL2, which we already observed earlier to
be most eﬀective for ﬁnding shortest refutations [23].

Figure 4 compares IUH hardness to hardness of RUHs and other related
classes like SMU, depicting both maximum as well as average hardness.3 The
data on SMU hardness is taken from our previous work [23], where we looked
for resolution hardness numbers (maximum resolution complexity with a ﬁxed
number of clauses) and showed that the hardest formulas with a given number of
clauses are saturated minimally unsatisﬁable, and consequently analyzed hardness
in SMU formulas with up to 10 clauses in detail.

We can draw several conclusions.
Firstly, it is not true that IUHs are always the hardest of hitting formulas for
a given number of clauses. On the other hand, IUHs exhibit greater hardness
on average than all hitting formulas, suggesting that irreducibility is indeed
positively correlated with hardness.

Secondly, with the caveat that our limited study cannot provide answers
for larger formulas, is seems that hitting formulas, irreducible or not, are not
substantially easier than formulas in general. Interestingly, while for most values
of m (number of clauses) the hardest formulas are not hitting, for 5 and 8 clauses
there is a IUH that is as hard as any formula (for m = 5 it is F 2
5 , for m = 8 it is
the formula F from Example 4).

2http://fmv.jku.at/cadical
3We calculate average hardness as weighted average by the number of isomorphic copies of

each formula.

16

1234567891011Number of clauses0510152025HardnessHardness in subclasses of saturated minimally unsatisfiable formulasRIUHRUHSUHUHRISMUSISMUISMURSMUSSMUSMU2 3 4

5

6

7

8

9

10

11

12

13

14

101
1

142

2 192

1 191
1
1915
7

2247
9

25138
15
24112
6

28245
2
27618
10

30511
11
305178
34
291019
1

≥33804
?
≥3425235
?
≥317765
?

n\m 1
11
0
1
1
2
3
4
5
6
7
8
9
10

Table 1: Values of h(IUH(n, m)), i.e., the lengths of the longest shortest refutation
required by a (regular) irreducible unsatisﬁable hitting formula with n variables
and m clauses. The subscript gives the number of formulas that attain maximum
hardness, the superscript is the total number of formulas in each category. All
counts are modulo isomorphisms. Empty areas contain no IUHs.

Of course, limited conclusions should be drawn from our limited computational
evaluation. We note that it is probably not possible to advance to much higher
numbers of clauses with this approach: we are looking at over 200K IUHs with 15
clauses, a number that is likely going to be very diﬃcult to process for shortest
refutations. The situation is even worse for RUHs, with almost 140K with 12
clauses and over 1M formulas with 13 clauses. A further complication is that the
computation of shortest refutations grows hard quickly with increasing formula
size [23]. It already took almost 9 days to get the hardness of the hardest IUHs
with 14 clauses whose hardness we could compute, and that still leaves many
formulas with 14 clauses left. As we noted in our previous work [23], this workﬂow
is diﬃcult to parallelize as most of the eﬀort is concentrated in one hardest SAT
query.

On the ﬂip side though, the pace of growth suggests there might indeed be
inﬁnitely many IUHs. A reﬁned existence question could ask whether IUHs with
each number of clauses exist. Table 1 shows that is not the case: IUHs with 2,
3, 4, and 6 clauses are missing. For 2 and 3, regularity is the culprit: there are
no regular minimally unsatisﬁable formulas with 2 or 3 clauses either [18, 23].
The case of 4 and 6 is a diﬀerent story: there are both RUHs and RISMUs with
6 clauses, and there is a RUH with 4 clauses, but interestingly no IUH with 6
clauses, and not even a RISMU with 4 clauses. This reminds us of other algebraic
objects like orthogonal Latin squares, which also exist for almost all sizes (cf.
OEIS sequences A160368, A305570, A305571, and A287761), but it is unclear
whether there is any connection.

17

2 3 4

5

6

7

8

9

10

11

71
1

101

1 113

3 131
151
1
1
10 1949
146
1
169
5

2079
1
19207
7
194
2

2194
5
231772
3
21281
7
211
1

2270
21
258203
21
257449
3
23261
50

n\m 1
11
0
1
1
2
3
4
5
6
7
8
9

Table 2: Values of h(RUH(n, m)), i.e., the lengths of the longest shortest refutation
required by a regular unsatisﬁable hitting formula with n variables and m clauses.
The subscript gives the number of formulas that attain maximum hardness, the
superscript is the total number of formulas in each category. All formula counts
are modulo isomorphisms. Empty areas contain no RUHs.

Kullmann and Zhao [19] were interested in the existence of RUHs, and
in particular they investigated the ‘Finiteness Conjecture’ that for any ﬁxed
deﬁciency only ﬁnitely many RUHs exist. An exact, stronger variant of their
conjecture [19, Conjecture 5] states explicitly that a RUH of deﬁciency k ≥ 2
can have at most 4k − 5 variables (and thus 5k − 5 clauses), which they prove
for k = 3 (and which was already known for k = 2 [11]). This exactness allows
our work to intersect with theirs, and indeed, wherever we touch the bound of
4k − 5, Tables 1 and 2 conﬁrm that no RUHs (or IUHs) of deﬁciency k and with
more than 4k − 5 variables exist. In fact, all three extremal cases that we cover
(for k = 1, 2, 3, n = 0, 3, 7) have a unique RUH formula modulo isomorphism
(the unique formula for k = 3 is the formula K2 described by Kullmann and
Zhao [19, Lemma 4]).This was already well known for k = 1, 2, and followed for
k = 3 from our previous work [23], where we generated all RSMU formulas with
7 variables and 10 clauses, but we did not see the connection to Kullmann and
Zhao’s work then. There is another intriguing pattern of similar nature apparent
in Table 1: formulas with n variables show up starting with m = 2n − 1 clauses.
We leave it to future work to ﬁnd out whether these patterns are coincidental or
not.

Our catalog of RUHs and IUHs will be added to our existing catalog of SMU
formulas [24], and will hopefully help with the testing of hypotheses and as
inspiration for constructing inﬁnite classes of irreducible hitting formulas. In
Figure 5, we show hand-picked examples of notable formulas. For each number of
clauses, we picked among the IUHs with highest hardness one with the smallest
length (number of literal occurrences, i.e. (cid:80)
C∈F |C|), and in case there was more

18

than one, the one with the largest symmetry group.

– –

+ – + – + –
– +
+
+ – – + –
+ – + – –

+ – –
+

+ + – –
– – – – + +
+ – – + + – – +
+ – + – + – + –

+ – – + – – +
+ + –

+ – – – –
+ + + – – – + –
– – +
+ – +
+ – + – + –

+ – + – + –
+ +
+

– – –

–
+ + –

+

– + – + –

+ –
+ + + – – – – – –
+ + + – – –

+ – +
+ +
+

+ –

– – + – –

– – – +
– +
– – + + – + + –
– – +
+ + + – + –

+ – –

+ – + – – +

+ –
+ +
+

– –
– + +
– – – – – – + + + –

– + +

– – + + – + – + –

+ – + – +

+ – – + –

– – – + +
+

–

Figure 5: Selected hardest IUHs with 7 and 9 − 13 clauses written in ‘incidence
matrix’ form (rows are variables, columns are clauses, ‘+’ and ‘–’ mean positive
and negative occurrence). The hardest IUH with 1 clause is {⊥}, with 5 clauses F 2
5 ,
already shown in Example 3, and with 8 clauses the formula F from Example 4.

8 Conclusion

Inspired by the observation that hitting formulas are remarkable among polynomial-
time decidable classes of propositional formulas in that they admit polynomial-
time model counting and at the same time lack obvious resolution-complexity
upper bounds, we set out to answer whether hitting formulas are hard for resolu-
tion. This quest led us into the land of (strong) irreducibility and to discover a
number of interesting related questions and phenomena. With our theoretical
and experimental results we now understand that IUHs are a key subset of hitting
formulas with respect to both resolution complexity, as well as just plain existence.
Because the number of IUHs (and even more so RUHs) grows so fast, it seems
safe to conjecture that there are inﬁnitely many—but at the same time there are
intriguing similarities with other algebraic objects like orthogonal Latin squares,
and the rules governing existence of IUHs (and RUHs) with ﬁxed parameters
n and m also exhibit simple-looking patterns that deserve further investigation.
Based on the resolution complexity we could observe, we see no signs that hitting
formulas should be signiﬁcantly easier for resolution than formulas in general,
even if they are a bit easier than the absolutely hardest formulas; although
we cannot draw deﬁnitive conclusions beyond the formulas whose proofs we
computed.

While we focused on resolution here, it would also be interesting to look at

19

hitting formulas’ complexity in other proof systems.

References

[1] Ron Aharoni and Nathan Linial. Minimal non-two-colorable hypergraphs
and minimal unsatisﬁable formulas. J. Combin. Theory Ser. A, 43:196–204,
1986.

[2] Albert Atserias, Johannes Klaus Fichte, and Marc Thurley. Clause-learning
algorithms with many restarts and bounded-width resolution. J. Artif. Intell.
Res., 40:353–373, 2011.

[3] Paul Beame, Henry A. Kautz, and Ashish Sabharwal. Towards understanding
and harnessing the potential of clause learning. J. Artif. Intell. Res., 22:319–
351, 2004.

[4] J. A. Bondy and U. S. R. Murty. Graph theory, volume 244 of Graduate

Texts in Mathematics. Springer Verlag, New York, 2008.

[5] M. Davis and H. Putnam. A computing procedure for quantiﬁcation theory.

J. of the ACM, 7(3):201–215, 1960.

[6] John Franco and John Martin. A history of satisﬁabilty. In Armin Biere,
Marijn Heule, Hans van Maaren, and Toby Walsh, editors, Handbook of
Satisﬁability, 2nd Ed., chapter 1, pages 3–74. IOS Press, 2021.

[7] Nicola Galesi and Oliver Kullmann. Polynomial time SAT decision, hyper-
graph transversals and the Hermitian rank. In SAT 2004 - The Seventh
International Conference on Theory and Applications of Satisﬁability Testing,
10-13 May 2004, Vancouver, BC, Canada, Online Proceedings, 2004.

[8] Robert Ganian and Stefan Szeider. New width parameters for SAT and

#SAT. Artiﬁcial Intelligence, 295:103460, 2021.

[9] Armin Haken. The intractability of resolution. Theoretical Computer Science,

39:297–308, 1985.

[10] Kazuo Iwama. CNF-satisﬁability test by counting and polynomial average

time. SIAM J. Comput., 18(2):385–391, 1989.

[11] Hans Kleine B¨uning. On subclasses of minimal unsatisﬁable formulas. Discr.

Appl. Math., 107(1–3):83–98, 2000.

[12] Hans Kleine B¨uning and Xishun Zhao. Satisﬁable formulas closed under
replacement. In Henry Kautz and Bart Selman, editors, Proceedings for the
Workshop on Theory and Applications of Satisﬁability, volume 9 of Electronic
Notes in Discrete Mathematics. Elsevier Science Publishers, North-Holland,
2001.

20

[13] Hans Kleine B¨uning and Xishun Zhao. The complexity of read-once resolution.

Ann. Math. Artif. Intell., 36(4):419–435, 2002.

[14] Hans Kleine B¨uning and Xishun Zhao. On the structure of some classes of
minimal unsatisﬁable formulas. Discr. Appl. Math., 130(2):185–207, 2003.

[15] Oliver Kullmann. The combinatorics of conﬂicts between clauses. In Enrico
Giunchiglia and Armando Tacchella, editors, Sixth International Conference
on Theory and Applications of Satisﬁability Testing, S. Margherita Ligure -
Portoﬁno, Italy, May 5-8, 2003 (SAT 2003), volume 2919 of Lecture Notes
in Computer Science. Springer Verlag, 2004.

[16] Oliver Kullmann. Green-Tao numbers and SAT. In Ofer Strichman and
Stefan Szeider, editors, Theory and Applications of Satisﬁability Testing -
SAT 2010, 13th International Conference, SAT 2010, Edinburgh, UK, July
11-14, 2010. Proceedings, volume 6175 of Lecture Notes in Computer Science,
pages 352–362. Springer, 2010.

[17] Oliver Kullmann. Constraint satisfaction problems in clausal form II: Minimal
unsatisﬁability and conﬂict structure. Fund. Inform., 109(1):83–119, 2011.

[18] Oliver Kullmann and Xishun Zhao. On Davis-Putnam reductions for min-
imally unsatisﬁable clause-sets. Theoretical Computer Science, 492:70–87,
2013.

[19] Oliver Kullmann and Xishun Zhao. Unsatisﬁable hitting clause-sets with

three more clauses than variables. CoRR, abs/1604.01288, 2016.

[20] Brendan D. McKay and Adolfo Piperno. Practical graph isomorphism, {II}.

Journal of Symbolic Computation, 60(0):94 – 112, 2014.

[21] Naomi Nishimura, Prabhakar Ragde, and Stefan Szeider. Solving #SAT

using vertex covers. Acta Informatica, 44(7-8):509–523, 2007.

[22] Sebastian Ordyniak, Dani¨el Paulusma, and Stefan Szeider. Satisﬁability of
acyclic and almost acyclic CNF formulas. Theoretical Computer Science,
481:85–99, 2013.

[23] Tom´aˇs Peitl and Stefan Szeider. Finding the hardest formulas for resolution.
J. Artif. Intell. Res., 72:69–97, 2021. Conference Award Track, best paper
CP 2020.

[24] Tom´aˇs Peitl and Stefan Szeider.

able Formulas on up to Ten Clauses.
https://doi.org/10.5281/zenodo.3951545.

Saturated Minimally Unsatisﬁ-
Zenodo, January 2021.

21

[25] Knot Pipatsrisawat and Adnan Darwiche. On the power of clause-learning
SAT solvers with restarts. In Ian P. Gent, editor, Principles and Practice
of Constraint Programming - CP 2009, 15th International Conference, CP
2009, Lisbon, Portugal, September 20-24, 2009, Proceedings, volume 5732 of
Lecture Notes in Computer Science, pages 654–668. Springer Verlag, 2009.

[26] Dan Roth. On the hardness of approximate reasoning. Artiﬁcial Intelligence,

82(1-2):273–302, 1996.

[27] Jo˜ao P. Marques Silva and Karem A. Sakallah. GRASP - a new search
algorithm for satisﬁability. In International Conference on Computer-Aided
Design (ICCAD ’96), November 10-14, 1996, San Jose, CA, USA, pages
220–227. ACM and IEEE, 1996.

[28] Bal´azs Sz¨or´enyi. Disjoint DNF tautologies with conﬂict bound two. J on

Satisﬁability, Boolean Modeling and Computation, 4(1):1–14, 2008.

[29] Alasdair Urquhart. Hard examples for resolution. J. of the ACM, 34(1):209–

219, 1987.

[30] Xishun Zhao. Complexity results on minimal unsatisﬁable formulas. In
Mathematical logic in Asia, pages 302–319. World Sci. Publ., Hackensack,
NJ, 2006.

22

