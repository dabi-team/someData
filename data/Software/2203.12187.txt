2
2
0
2

y
a
M
9

]
L
C
.
s
c
[

3
v
7
8
1
2
1
.
3
0
2
2
:
v
i
X
r
a

Converse: A Tree-Based Modular Task-Oriented
Dialogue System

Tian Xie∗
Salesforce Research
txie@salesforce.com

Xinyi Yang∗
Salesforce Research
x.yang@salesforce.com

Angela S. Lin
Salesforce Research
angela.lin@salesforce.com

Feihong Wu
Salesforce Research
feihong.wu@salesforce.com

Kazuma Hashimoto†
Google Research
freedomigo@gmail.com

Jin Qu
Salesforce Research
jqu@salesforce.com

Young Mo Kang†
Microsoft
youngmokang@microsoft.com

Wenpeng Yin†
Temple University
wenpeng.yin@temple.edu

Huan Wang
Salesforce Research
huan.wang@salesforce.com

Semih Yavuz
Salesforce Research
syavuz@salesforce.com

Gang Wu
Salesforce Research
gang.wu@salesforce.com

Michael Jones
Salesforce Research
jones.m@salesforce.com

Richard Socher†
you.com
rsocher@gmail.com

Yingbo Zhou
Salesforce Research
yingbo.zhou@salesforce.com

Wenhao Liu
Salesforce Research
wenhao.liu@salesforce.com

Caiming Xiong
Salesforce Research
cxiong@salesforce.com

Abstract

Creating a system that can have meaningful conversations with humans to help
accomplish tasks is one of the ultimate goals of Artiﬁcial Intelligence (AI). It has
deﬁned the meaning of AI since the beginning. A lot has been accomplished in
this area recently, with voice assistant products entering our daily lives and chat
bot systems becoming commonplace in customer service. At ﬁrst glance there
seems to be no shortage of options for dialogue systems. However, the frequently
deployed dialogue systems today seem to all struggle with a critical weakness -
they are hard to build and harder to maintain. At the core of the struggle is the
need to script every single turn of interactions between the bot and the human user.
This makes the dialogue systems more difﬁcult to maintain as the tasks become
more complex and more tasks are added to the system. In this paper, we propose
Converse, a ﬂexible tree-based modular task-oriented dialogue system. Converse
uses an and-or tree structure to represent tasks and offers powerful multi-task
dialogue management. Converse supports task dependency and task switching,
which are unique features compared to other open-source dialogue frameworks. At
the same time, Converse aims to make the bot building process easy and simple, for

∗Equal contribution.
†Work done while at Salesforce Research.

 
 
 
 
 
 
both professional and non-professional software developers. The code is available
at https://github.com/salesforce/Converse.

1

Introduction

Task-oriented dialogue (TOD) systems help users complete tasks through dialogue [9]. TOD systems
can be valuable for various industries. Examples of TOD tasks include: reserving a table at a restau-
rant, booking ﬂight tickets, making a customized T-shirt order, or checking vaccination appointment
availability. The typical pipeline for task-oriented dialog systems are divided into several modules
and are built on top of a structured task ontology [18]. However, there are several challenges in
building task-oriented dialogue systems.

Firstly, it is challenging to deﬁne an efﬁcient task ontology that captures the variation in dialogue.
Due to the varied nature of dialogue, there can be several different ways or orders to complete the
same task. For example, the user can check the delivery status of an order using the order id, or the
username and the delivery address. Ideally, a task ontology should be simple and efﬁcient at capturing
all of these task variations. If a bot builder needs to specify all possible trajectories for completing a
task, the building process soon becomes intractable due to the combinatorial nature of the task.

Secondly, the adaptation to new tasks and building a new bot can be costly. For instance, most
dialogue state tracking models are domain-speciﬁc, and cannot be directly generalized to new
domains. For most pipeline TOD systems, introducing a new task or building a new bot requires
resources (annotated data, training time, and computational resources) to retrain the natural language
understanding module to detect the desired new intent and entities. These resource requirements
hamper the bot building process, reducing adoption and impeding bot builders when they try to add
new use-cases.

Thirdly, handling conversations with interactions between tasks is difﬁcult. When building a bot, it is
standard to treat each task as a standalone conﬁguration. But in real conversations with users, there
will be interactions between tasks, for example task switching. Task switching is a situation where
a user ﬁrst starts a task X; then in the middle of task X, the user starts a new task Y; after ﬁnishing
task Y, the user should be able to pick up where they left off in task X and continue the conversation.
Another example is the dependency between tasks. If checking the order status and changing the
delivery address both depend on user authentication, then after checking the order status (and also
authenticating the user), the dialogue system should not authenticate the user again when changing
the delivery address. Solving these challenges is essential for creating a system that works well for
users who interact with bots and bot builders who build bots.

To address the challenges above, we propose Converse, a low-code, tree-based, modular, task-oriented
dialogue system. Converse deﬁnes a task as an and-or tree structure [16] that is called Task Tree.
A Task Tree is composed of the key pieces of information (entities and sub-tasks) needed for the
task and their relationships. This structure can represent various kinds of tasks. The system traverses
the tree to easily reference, maintain, and update the task-related dialogue states. The bot builders1
do not need to deﬁne the next step after each dialogue state one by one. Instead, they only need to
deﬁne the Task Tree structure. The tree traversal automatically traverses the Task Tree and ﬁnds the
next entity (slot) and next task. Furthermore, the Task Tree also takes care of interactions between
tasks in conversations, such as switching tasks and completing dependent sub-tasks. The Task Tree is
versatile and simpliﬁes the bot building process.

Similarly, the other components of Converse can be utilized with ease. The bot builder can build a
new bot by writing a few conﬁguration ﬁles and a bit of code. To conﬁgure a bot, the bot builder
only needs to deﬁne Task Trees for their tasks that include: the information to collect from users
and actions to take after information is collected. To use the natural language understanding module,
annotated data or training models on in-domain data are not required. We introduce a natural language
inference based few-shot intent detection model, which enables the bot builder to add new intents
by listing a few samples. We also provide common predeﬁned entity types that the user can use

1To avoid confusion on the persona involved in this paper, we use the following deﬁnitions. A bot builder
(chatbot builder or bot admin) is the person who creates chatbots using Converse. A user is a person who
interacts with the runtime bot system. A user session is created every time when a user starts a new conversation
with the chatbot.

2

out-of-the-box without collecting more training data and re-training the model. If bot builders want
to further customize the natural language understanding module, Converse’s modular design enables
them to smoothly switch out our models with their own. These design choices save bot builders effort
and time.

In this paper, we will mainly focus on how the tasks are represented in Converse, i.e., the Task Tree
and the Dialogue Management.

2 Converse’s Abilities and Limitations

2.1 What Converse can do

Before we talk about the technical details of Converse, we want to ﬁrst show what Converse can do
and what Converse cannot do. We also provide an example conﬁguration of a Converse bot in A.6.

2.1.1 Deﬁne and reuse sub-tasks

Let’s begin with an online shopping helper bot which can help the user check their order status and
update their order. For security, the bot will verify the user’s identity ﬁrst before starting these two
tasks.

User: Hi, I would like to check my order status.

Bot: Oh sure, I’d be happy to help you check your order status. First, I need to pull up your account.
Could you please tell me your email address?

Checking the order status is the main task, which has a sub-task to verify the user’s identity. We also
used this sub-task in the task for updating the order. Bot builders only need to deﬁne a sub-task once.
Then the sub-task can be used in other tasks. Reusing sub-tasks reduces the amount of conﬁgurations
that the bot builder needs to write. In addition, reusing sub-tasks allows Converse to skip the sub-task
if it has already been completed which improves the user experience, for example, verifying the
user’s identity only once in a session.

2.1.2 Use and-or relations in the Task Tree to handle branching conversations

The following conversation is a continuation of the example above. In this conversation, the bot
adjusts its response based on whether the user provides the correct email address.

Bot: Oh sure, I’d be happy to help you check your order status. First, I need to pull up your account.
Could you please tell me your email address?

Trajectory 1
User: [the correct email address]
Bot: I have veriﬁed your identity. Please provide
your order id for your order status.

Trajectory 2
User: I don’t remember it.
Bot: I am sorry, but I could not recognize your
email address. Could your please tell me your zip
code?
User: [the correct zip code]
Bot: I have veriﬁed your identity. Please provide
your order id for your order status.

Note that the bot builders only need to create the and-or relations, instead of specifying every possible
linear conversational path. The Task Tree in Converse is able to handle more nested and complex
structures than in the above example, as long as they can be represent in and-or relationships.

2.1.3 Switch between tasks in the middle of a task

Here’s an example of a ﬂight booking bot where we’d like to show Converse’s multi-task conversation
handling.

User: I’d like to book a round-trip ﬂight.

Bot: I’d be happy to help you book a ﬂight. Where will you depart from?

User: Oh wait, could you please help me check tomorrow’s weather ﬁrst?

3

Bot: I’d be happy to help you check the weather. What is the zip code of your area?

The user started a ﬂight booking task, but after the bot asked about the departure location, the user
changed the mind and started a new weather query task. The bot detected the new intent, switched to
the new task weather query, and asked for the zip code.

User: [a zip code].

Bot: The weather in [city name of the zip code] is [some weather]. That’s all I have about the
weather. Where will you depart from?

The bot successfully helped the user to query the weather. Then it picked up what it left from the
previous conversation, switched back to ﬂight booking task, and asked the user about the origin
location again.

2.1.4 Conﬁgure responses to frequently asked questions

Converse can not only switch between tasks, but also answer frequently asked questions (FAQs). The
following conversation continues from the previous conversation:

User: San Francisco.

Bot: Got it. Where is your destination?

User: Do I have free checked bags?

Bot: All frequent ﬂyer program members will have one free checked bag. Where is your destination?

Converse deﬁnes FAQs as one-turn dialogues that can happen anywhere in a conversation. FAQs
can be easily conﬁgured in the task conﬁguration by listing the question and answer pairs, such as
"Do I have free checked bags? - All frequent ﬂyer program members will have one free checked
bags.". Here the bot detected the question from the conversation and fetched the answer from FAQ
conﬁguration, then continued the ﬂight booking task.

2.2 What Converse cannot do

2.2.1 Multilingual support

Currently, Converse only supports English. If Bot builders want to build chatbots in other languages,
they need to use their own NLU models and response templates.

2.2.2 Canceling an ongoing task

Currently, Converse doesn’t support canceling an ongoing task. Here is an example conversation:

Bot: Hi there, I am the digital assistant for Northern Trail Information Center. What can I do for
you?

User: I want to check order status

Bot: Oh sure, I’d be happy to help you check your order status. First, I need to pull up your account.
What is your email address?

User: I don’t want to check order status anymore

Bot: I am sorry, but I could not recognize your email address. What is your zip code?

In this example, the user changes the mind, and doesn’t want to continue the check order status task
anymore. However, the bot is still trying to extract entity (slot) information from the user.

2.2.3 Discriminate between entities that have the same entity type

Here’s an example of a ﬂight booking conversation that multiple entities with the same entity type
mentioned in one user’s utterance.

User: I’d like to book a round trip ﬂight from San Francisco to Los Angeles for 2 people.

Bot: I’d be happy to help you book a ﬂight, I got multiple possible answers for origin: San Francisco
and Los Angeles, which one did you mean? Could you walk me through the details?

4

In above conversation the user already speciﬁed the origin and the destination. Unfortunately,
Converse detects entity based on type instead of name; it treats San Francisco and Los Angeles
equally as location entities and ﬁt them both into the ﬁrst required location entity origin.

2.2.4 Commonsense Reasoning

Converse can handle only a limited amount of commonsense reasoning. In some cases, this may
cause the bot to incorrectly process user input. Here’s an example:

Bot: And here are your returning ﬂights:
Oceanic 443, Depart at 4:16am, 800 USD
Ajira 232, Depart at 15:42pm, 1500 USD
Qantas 424, Depart at 23:08pm, 2300 USD

User: the late night one

Bot: Alright, your returning ﬂight is Oceanic 443.

In this case, the bot is not able to relate “late night” to “23:08pm”. However, the bot can understand
“the last one” or “Qantas 424” based on the rules we have implemented.

2.2.5 Mixed initiatives

In Converse, the bot always leads the conversations. Sometimes, users may not follow the bot, and
provide something not expected by the bot. Here’s an example:

Bot: Hi there, I am the digital assistant for Northern Trail Information Center. What can I do for
you?

User: I want to check order status

Bot: Oh sure, I’d be happy to help you check your order status. First, I need to pull up your account.
What is your email address?

User: Can I use my name to verify my identity?

Bot: Oh sure, I’d be happy to help you check your order status. First, I need to pull up your account.
What is your email address?

Converse doesn’t allow users to lead the conversations, like other existing task-oriented dialogue
system frameworks, hence the conversations may not be as natural as human conversations when the
users don’t follow the bot.

2.2.6 Talk to users about open-ended topics

Converse is not an open-domain dialogue system. The conversations are restricted by the deﬁned
tasks. Bot builders can deﬁne FAQs to make Converse able to handle chitchat. Since Converse
doesn’t have a model-based Natural Language Generation (NLG) module, Converse’s chitchat ability
is limited by the FAQs deﬁned by bot builders.

3 Related Work

In recent years, there has been an increasing amount of literature on studying task-oriented dialogue
systems. There are two main directions for this research: (1) frameworks for building task-oriented
bots [7, 11, 2, 3, 1, 6, 4, 5], and (2) systems for evaluating new dialogue models [12, 10]. Converse
aligns with the ﬁrst research direction with a focus on creating a task-oriented dialogue system that
does not require much code to set up.

In existing conversational frameworks, bot builders need to specify every user intent and bot action in
a conversation, giving bot builders ﬁne-grained control over the bot’s behavior at the cost of simplicity.
In Rasa [7], bot builders create a list of user intents and bot actions for every linear conversational path
that the bot handles. However, natural conversations branch when the user changes the topic or does
not respond to the bot’s questions, which does not match Rasa’s linear conversation conﬁguration
design. In contrast, bot builders using Botpress [2], Google Dialogﬂow [3], Microsoft Bot Framework
Composer [1], and IBM Watson Assistant [6] connect blocks that represent user intents and bot

5

actions in a graphical interface to conﬁgure the conversational ﬂow of a task using a graph. These
conversational graph structures are more ﬂexible to handle branches in the conversation, however,
bot builders still need to specify the bot’s behavior at every conversational step. In Converse, on the
other hand, bot builders specify the entities for each task and the Task Tree structure, and the built-in
dialogue policy handles generating responses based on the dialogue states, switching tasks, and
steering the conversation back on track when the user does not answer the bot’s questions, simplifying
the conversation conﬁguration compared to existing conversational frameworks.

The task structure used in Converse is similar to a feature in Rasa, Amazon Lex, and Google
Dialogﬂow that collects multiple entities from users that are required to complete a task, such as the
date and time of an appointment. In contrast to these other dialogue systems where bot builders can
only conﬁgure entities as required or optional, bot builders can use the task structure in Converse to
conﬁgure more complex logic to collect entities, such as asking the user to provide two out of three
types of user authentication (e.g. their zip code, a two-factor authentication code, and government ID
number).

4 System overview

Modern task-oriented dialogue systems are usually designed to be modular or a pipeline. They
usually comprise modules such as Natural Language Understanding (NLU), Dialogue State Tracking
(DST), Dialogue Management (DM), and Natural Language Generation (NLG). To solve real-world
problems, a Knowledge Base (KB)/ Backend action is often connected to the task-oriented dialogue
system. The Knowledge Base can be a database, a knowledge graph, or anything else that contains
necessary information to fulﬁll user’s inquiry. In addition to the aforementioned modules, fully
functional spoken dialogue systems also incorporate Automatic Speech Recognition (ASR) and Text
to Speech (TTS) modules.

Converse follows the typical design of modern task-oriented dialogue systems, see Figure 1. The
Orchestrator module works as the receptionist of Converse. It handles communications between the
user and the system, and also coordinates with other modules. The core of Converse is Dialogue
Management (DM). The DM is connected with a unique component in Converse called the Dialogue
Tree Manager. The Dialogue Tree Manager manages the Task Tree, which is an and-or tree-based
data structure that represents tasks in Converse.

Figure 1: The architecture of Converse task-oriented dialog system

More details about the NLU module and the NLG module can be found in the appendix and the
documentation in the GitHub repo.

6

5 And-Or Task Tree

5.1 A new way to represent tasks

In task-oriented dialogue systems, tasks (intents) are the speciﬁc things that we want the system to
help users achieve, like checking the weather or booking movie tickets. A task consists of a collection
of slots (entities) and their relationships. The simplest case is that a task has several necessary entities.
To complete the task, the bot needs to ask the user for the entity value one by one. In more complex
cases, the bot may only need to ask the user for some entity value when a condition is met. In other
words, to complete a task in different situations, different combination of entities can be used.

The representation of tasks in a task-oriented dialogue system determines how the system handles the
tasks. In other words, the representation of tasks is the organization of the slots (entities) for this task.

There are different ways to represent tasks in a task-oriented dialogue system. In Converse, we chose
an and-or tree structure to represent tasks, instead of creating a story-based conversation turn by turn
in a linear structure. We deﬁned a Task Tree structure based on and-or tree.

Why do we use and-or tree structure? We want to formulate every task as a problem to solve, and
make it possible to be solved in a generic way. The problem can be considered as a combination of a
set of sub-problems. The and-or tree structure represents the search space for solving the problem.
Different search strategies for searching the space are possible. In Converse, the Dialogue Tree
Manager traverses the Task Tree based on the dialogue states that are managed by the dialogue
management module.

5.2 How to use and-or tree to represent tasks

With the and-or tree structure, we can convert almost every task into a combination of and/or relations.
For example, if a task veriﬁes the user’s identity, and we can verify either by name and email address,
or by birthday and social security number (SSN), the task can be represented as (Verify name and
Verify email address) or (Verify birthday and Verify SSN).

The and-or tree structure is simple yet powerful for representing tasks. We don’t need to create
different stories for different tasks. We only need to reduce the task into several basic parts, and
connect them with and/or relations. In this way, conﬁguring a new task can be much easier for bot
builders.

We deﬁned 3 type of tree nodes for the Task Tree: And node, Or node, and Leaf node. Each node has
a success status label. If a tree node’s success status label is True, it means this node is successfully
ﬁnished based on the information extracted from the previous conversation, and it won’t be visited
again later in the conversation. For each type of node, we deﬁne a node success condition to decide
the value of success status label, which by default is False.

The child nodes of an And node or Or node can be And nodes, Or nodes and Leaf nodes. Leaf nodes
are entity nodes, which store a group of entities and the extracted entity values.

Table 1: Node types and success conditions

Node Type

Success Condition

And node
Or node
Leaf node

all the child nodes’ success labels are True
at least one child node’s success label is True
all or a speciﬁed number of entities have correct values

At the beginning of each conversation, the Task Tree is a root node. The root node is an Or node by
default. The system don’t check the root node’s success status. It only checks the task nodes. The
task nodes (the tree nodes represent tasks) are And or Or nodes. The task nodes will be added to the
Task Tree as the conversation goes.

5.3 The beneﬁts of using an and-or tree to represent tasks

With the tree nodes we deﬁned, the bot builders can conﬁgure complex and/or relations, which means
they can build complex task structures easily. A task can depend on other tasks, i.e., it can have

7

prerequisite tasks (sub-tasks). A sub-task can be shared by different tasks. For example, bot builders
may conﬁgure several tasks and they both need identity veriﬁcation. Then identity veriﬁcation can be
a shared sub-task. If task A is task B’s sub-task, Task node A should be Task node B’s child node
intuitively. Note that in actual implementation, in order to only have one copy for each task and check
task success status easily, all the task nodes are sibling nodes with the same parent node, which is the
root node. If task A is task B’s sub-task, task node B won’t actually have task node A as its child
node, but a reference to task node A. In this way, task node A is still the root node’s child node, and
task node B’s structure is well-maintained, see Figure 2.

Figure 2: The Task Tree visualization of a task with sub-task

The Task Tree supports task switching. Users can tell the bot they want to do task B when the bot is
currently handling task A. The bot will pause task A and switch to task B. After task B is ﬁnished,
the bot will go back to task A, and continue working on task A from where it stopped.

The Task Tree supports task repetition if the task is reusable. When a task is repeated, the task node
and all its child nodes will be reset. However, if the task has sub-tasks, the sub-tasks will not be reset.
For example, if a task is making online order, and it has a sub-task, verify identity. The making online
order can be repeated to make another order, but the bot only needs to verify the user’s identity when
making the ﬁrst order. Of course, if sub-tasks are also independent tasks, they can be reset if users
say they want to do it again.

5.4 How Task Tree is managed in Converse

The Task Tree Manager in Converse handles operations on the Task Tree, including adding a new
task, tree traversal, and quitting a task. The Task Tree Manager maintains the current task, current
entity name, and the current node. The current node is always a Leaf node. Adding a new task will
construct the task structure and add it under the root node. When the current node is ﬁnished (either
the success label is True or all the entities have been tried), tree traversal can traverse to the next
unﬁnished Leaf node. When the current node is unﬁnished, tree traversal will stay at the current node.
The Task Tree manager quits a task when the number of turns about the task exceeds the limit. The
Task Tree Manager interacts with Dialogue Management module, as shown in Figure 1 previously.

Figure 3 shows an example on how the Task Tree Manager works in detail. There are two tasks in
the Task Tree, check order status and verify user identity. The bot will work on the sub-task (verify
user identity) ﬁrst. In Step 1, for task verify user identity, the information of slot birthday has been
veriﬁed, and the current slot or entity is zip code. When the sub-task is successfully ﬁnished, the Task
Tree Manager will use tree traversal operation to switch to the main task (check order status). After
this operation, the current slot or entity will be order id, see Step 2.

8

Figure 3: An example of Task Tree operations - check order status

6 Dialogue Management

6.1 Dialogue State Tracking

The dialogue state is the representation of the system’s beliefs about the task(s) at any time during the
dialogue given the dialogue history. Dialogue state tracking (DST) is a key component in Dialogue
Management that extracts user-provided key information during the conversation and encodes them
as a compact set of dialogue states [15].

In Converse, there are three kinds of dialogue states: single-turn states, multi-turn states, and
task-related states.

Converse uses single-turn states to know what’s going on in the current turn. The states include
whether intent or entity information is extracted in this turn, the polarity (positive, negative, neutral)
of the user utterance, etc.

Converse uses multi-turn states to remember what happened in the previous conversation turns to
generate relevant dialogue in the current turn. With the multi-turn states, Converse is able to reuse
the information the user already provided in the previous turns. For example, if the system tried to
conﬁrm something with the user in the previous turn, a yes-or-no answer is expected in the current
turn. Another example is if a conversation length exceeds the turn limit, then it might be time to try
other solutions like connecting to a human agent.

Converse uses task-related states to represent the system’s belief of the tasks. The Task Tree itself
maintains the task-related states. It tells the system the current task and the current entity to focus on.
The Task Tree Manager also stores the tasks that were ﬁnished and are waiting to be ﬁnished.

9

Converse uses all the three kinds of dialogue states to track the ﬂow of dialogue. The dialogue states
accurately identify what the user wants and what process the system is in. The dialogue states are
managed by two modules in Converse - the Orchestrator and the Dialogue State Manager. In each
turn of a conversation, the Orchestrator coordinates with other modules to collect and update the
single-turn and multi-turn states. If any operations on the tree are triggered by these updated dialogue
states (decided by the Dialogue Policy and will be explained in detail later in the paper), the Dialogue
State Manager will update the Task Tree via Task Tree Manager.

6.2 Dialogue Policy

The Dialogue Policy in Converse follows a human-designed policy graph (which can be customized)
to decide the next dialogue action based on the dialogue states, and generate the response through the
Response Generation module. The policy graph is a decision tree, which we call the Policy Decision
Tree.

When the Dialogue Policy receives the updated dialogue states, it follows the Policy Decision Tree to
ﬁnd the next dialogue action. The leaf nodes in the Policy Decision Tree are the names of dialogue
actions. All the other nodes in the Policy Decision Tree are decision rules or conditions. During the
execution of the Dialogue Policy, Converse traverses the Policy Decision Tree through a depth-ﬁrst
search (DFS). When a node is a condition, if the condition is True, then its children can be visited.
The DFS stops when a leaf node is reached. Then the corresponding dialogue action will be executed.

The Dialogue Policy is shared between all the tasks in Converse. We assume that all the tasks can be
done by a set of general dialogue actions. The bot builders don’t need to write dialogue actions by
themselves for the tasks they deﬁned. The dialogue actions can be simple or complex, depending on
simple or complex cases we want them to deal with. An example of a simple dialogue action is a
greetings action, which generates a greeting response like "Hi, how are you?" when conditions are
met. An example of a complex dialogue action is a new task with info action, which handles the
conversation when both intent and entity information are extracted from user input. For a user’s input
like "I would like to check the weather for zip code 94105.", the new task with info action will add
the new check the weather task to the Task Tree, update the zip code entity node on the Task Tree,
make the API call to query the weather and ﬁnally generate a response "I would be happy to help you
query the weather, the weather in 94105, San Francisco is sunny. Is there anything else I can help
you with?".

With the Dialogue Policy, bot builders do not need to create different conversation ﬂows for different
tasks. Sometimes, bot builders may ﬁnd their use cases require capabilities beyond what the current
Dialogue Policy can do. They can add their dialogue action code, then modify the conditions and
corresponding dialogue action names in the Policy Decision Tree conﬁguration ﬁle.

Here, we show an example of the execution of the Policy Decision Tree, see Figure 4.

7 Ethical Considerations

Chatbot systems can be capable of producing unethical conversations. One example is Microsoft’s
Tay which learned and replicated offensive language within hours of interacting with users on Twitter
[14]. However, because Converse does not contain a model-based NLG model, this capability is
mitigated in our system. A bot builder could still provide biased, racist, or otherwise offensive Task
Tree, training samples, or FAQs resulting in inappropriate responses, but Converse does not have the
ability to learn offensive or racist language from the end-users. Likewise, Converse does not have the
ability to learn and distribute PII, keeping a user’s information private. As with other chatbot systems,
there is a potential for dialogue failure. To minimizes the risk of user frustration and attrition, bot
builders can provide contingency plans for users such as links to a help page, or transference to a
human operator.

8 Conclusion

We introduce Converse, a low-code, tree-based, modular, task-oriented dialogue system. Converse
has a powerful and-or-tree task structure to handle various tasks, can be adapted to new tasks easily,
and handles inter-task level conversation elegantly. In future work, we will integrate more advanced

10

Figure 4: An example of the execution of the Policy Decision Tree

conversational research into Converse, for example, model-based dialogue policy, open-domain
dialogue, dialogue act classiﬁcation, etc. We will continue to develop Converse as an easy-to-build,
easy-to-use, easy-to-deploy, task-oriented dialogue system.

Acknowledgments

The initial idea and overall design for Converse was from Caiming Xiong and Richard Socher.
Tian Xie, Kazuma Hashimoto, Jin Qu and Yingbo Zhou built the ﬁrst PoC, which was demo’ed at
Dreamforce 2019. Tian Xie, Xinyi Yang, Wenhao Liu, and Caiming Xiong redesigned the architecture
of Converse dialogue management core to make the system more ﬂexible, modular, and extensible.
Tian Xie, Xinyi Yang, Angela S. Lin, Feihong Wu, and Young Mo Kang further extended Converse by
adding additional features and improving ease of setup and deployment. Wenpeng Yin, Huan Wang
and Semih Yavuz made signiﬁcant contributions to the NLU models. We thank Gang Wu for his
help in the front-end development. We also thank Michael Jones for his help in product management.
Wenhao Liu and Yingbo Zhou led the initiative as project and team managers. Last but not least, we
received input and support from our Einstein product and engineering team members throughout the
process.

References
[1] Bot framework composer. https://docs.microsoft.com/en-us/composer/, . Accessed:

2021-11-23.

[2] Botpress. https://botpress.com/, . Accessed: 2021-11-23.
[3] Dialogﬂow. https://cloud.google.com/dialogflow/. Accessed: 2021-11-23.

11

[4] Lex. https://aws.amazon.com/lex/. Accessed: 2021-11-23.

[5] Power virtual agents. https://powervirtualagents.microsoft.com/en-us/. Accessed:

2022-01-03.

[6] Watson assistant. https://www.ibm.com/products/watson-assistant/. Accessed:

2021-11-23.

[7] Tom Bocklisch, Joey Faulkner, Nick Pawlowski, and Alan Nichol. Rasa: Open Source Language

Understanding and Dialogue Management. arXiv preprint arXiv:1712.05181, 2017.

[8] Xiaoqi Jiao, Yichun Yin, Lifeng Shang, Xin Jiang, Xiao Chen, Linlin Li, Fang Wang, and
Qun Liu. TinyBERT: Distilling BERT for natural language understanding. In Findings of the
Association for Computational Linguistics: EMNLP 2020, pages 4163–4174, 2020.

[9] Daniel Jurafsky and James H. Martin. Chapter 24: Chatbots & dialogue systems. In Speech

and Language Processing, 2021.

[10] Alexander Miller, Will Feng, Dhruv Batra, Antoine Bordes, Adam Fisch, Jiasen Lu, Devi
Parikh, and Jason Weston. ParlAI: A Dialog Research Software Platform. In Proceedings of the
2017 Conference on Empirical Methods in Natural Language Processing: System Demonstra-
tions, pages 79–84, Copenhagen, Denmark, September 2017. Association for Computational
Linguistics. doi: 10.18653/v1/D17-2014. URL https://aclanthology.org/D17-2014.

[11] Alexandros Papangelis, Mahdi Namazifar, Chandra Khatri, Yi-Chia Wang, Piero Molino, and
Gökhan Tür. Plato dialogue system: A ﬂexible conversational AI research platform. CoRR,
abs/2001.06463, 2020. URL https://arxiv.org/abs/2001.06463.

[12] Stefan Ultes, Lina M. Rojas-Barahona, Pei-Hao Su, David Vandyke, Dongho Kim, Iñigo
Casanueva, Paweł Budzianowski, Nikola Mrkši´c, Tsung-Hsien Wen, Milica Gaši´c, and Steve
Young. PyDial: A Multi-domain Statistical Dialogue System Toolkit. In Proceedings of ACL
2017, System Demonstrations, pages 73–78, Vancouver, Canada, July 2017. Association for
Computational Linguistics. URL https://aclanthology.org/P17-4013.

[13] James Paul White. UWashington: Negation resolution using machine learning methods. In
*SEM 2012: The First Joint Conference on Lexical and Computational Semantics – Volume
1: Proceedings of the main conference and the shared task, and Volume 2: Proceedings of the
Sixth International Workshop on Semantic Evaluation (SemEval 2012), pages 335–339, 2012.

[14] Marty J Wolf, Keith W Miller, and Frances S Grodzinsky. Why we should have seen that
coming: comments on microsoft’s tay “experiment,” and wider implications. The ORBIT
Journal, 1(2):1–12, 2017.

[15] Chien-Sheng Wu, Andrea Madotto, Ehsan Hosseini-Asl, Caiming Xiong, Richard Socher, and
Pascale Fung. Transferable multi-domain state generator for task-oriented dialogue systems.
In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics
(Volume 1: Long Papers). Association for Computational Linguistics, 2019.

[16] Caiming Xiong, Nishant Shukla, Wenlong Xiong, and Song-Chun Zhu. Robot learning with a
spatial, temporal, and causal and-or graph. In 2016 IEEE International Conference on Robotics
and Automation (ICRA), pages 2144–2151, 2016. doi: 10.1109/ICRA.2016.7487364.

[17] Jianguo Zhang, Kazuma Hashimoto, Wenhao Liu, Chien-Sheng Wu, Yao Wan, Philip Yu,
Richard Socher, and Caiming Xiong. Discriminative nearest neighbor few-shot intent detection
by transferring natural language inference. In Proceedings of the 2020 Conference on Empirical
Methods in Natural Language Processing (EMNLP), pages 5064–5082, 2020.

[18] Zheng Zhang, Ryuichi Takanobu, Qi Zhu, MinLie Huang, and XiaoYan Zhu. Recent advances

and challenges in task-oriented dialog systems. pages 1–17. Springer, 2020.

12

A Appendix

A.1 Natural Language Understanding (NLU)

Intent detection

We use a simple and effective approach [17], discriminative nearest neighbor classiﬁcation (i.e.,
k-nearest neighbors (kNN) classiﬁcation with k = 1), which is based-on natural language inference
(NLI). When bot builders conﬁgure tasks for Converse, they can add 3 ∼ 5 sample user utterances for
each task. During bot runtime, when there’s a user utterance, the system will compute the entailment
scores between the user utterance and all the sample utterances. The sample utterance with the highest
entailment score will be selected, and the corresponding task will be the intent detection result.

We also set a threshold for the inference score, usually 0.6 ∼ 0.8 to tackle the OOS intent problem.

Named-entity recognition (NER)

We trained an NER model based on TinyBERT6[8], and we use it as an important entity extraction
method for slot ﬁlling.

Negation detection

Usually, it is easier to know what the user wants to do in intent detection, while it can be very hard to
know what exactly the user doesn’t want to do in a dialogue system. It is fairly common to have a
system that treats “X does Y” and “X does not Y” as having the very nearly same meaning.[13]

Here, we introduce negation detection to help us solve the problem. We deﬁned an algorithm to do
intent resolution based-on the results of intent detection model and negation detection model. A
coreference resolution model is optional for intent resolution.

A.2 Dialogue Context

A conversation from the beginning to the end usually consists of many turns. Each turn is not isolated
from the others, which imposes one of the hard challenges on AI bots as they often fail to generate
dialogue consistent with past turns. In addition, Converse is designed as a distributed bot system that
can serve multiple users at the same time. It needs to maintain multiple conversations and switch
from one to the other, therefore the context of every conversation a.k.a "Dialogue Context" should be
memorized and managed. These functionalities are fulﬁlled by the Dialogue Context Manager.

The Dialogue Context Manager can be conﬁgured to run in stand-alone mode or distributed mode,
with context stored in memory or Redis, respectively. Also, we implemented the dialogue context
manager using the factory design pattern and proxy interface to make it ﬂexible to extend beyond our
two implementations.

A.3 Entity Module

An entity is a piece of information that the user provides to the system in order to carry out certain
tasks. In Converse, we implemented entities as objects instead of using strings because structured
objects are easier to manipulate than unstructured text. We provide a dedicated Entity Manager to
manage entity operations. We also provide multiple entity extraction methods.

Unlike most existing dialogue system frameworks, where entities have a life span of a single turn,
entities in Converse are long-lived throughout the user session. We provide an Entity History Manager
to manage all the entities extracted throughout the user session and allows the system to insert, remove,
and retrieve an entity. This behavior mimics a human agent who can remember entities provided by
the user in earlier conversations and does not ask for the same entity already provided in the past.

A.4 Natural Language Generation (NLG)

We use a simple template-based NLG module to generate natural language responses. The NLG
module connects to the Dialogue Policy. There are two kinds of responses: general responses for all
tasks and task-speciﬁc responses. Bot builders can conﬁgure general responses in a response template
ﬁle. Task-speciﬁc responses can be conﬁgured in the task conﬁguration ﬁle.

13

A.5 Entity backend

In order to solve real-world problems, we provide entity backend to process the extracted entity
values and return messages to the Dialogue Management after processing. For example, if the entity
backend is a weather checking API, the input entity value can be a zip code and the return message
can be a string contains the weather checking results for this location.

The entity backend can be Python functions or RESTful APIs. In the task conﬁguration ﬁle, you can
specify the entity backend function/ URL for each entity.

A.6 Example Converse chatbot

Here, we provide an example Converse bot, which is for making health appointment. To learn more
about how to build a chatbot using Converse, please check our GitHub repo.

Task conﬁguration YAML ﬁle:

Bot:

text_bot: true
bot_name: Nurse Nancy

Task:

positive:

description: polarity
samples:

- "Yes"
- "Sure"
- "correct"
- "No problem"
- "that's right"
- "yes please"
- "affirmative"
- "roger that"

negative:

description: polarity
samples:
- "No"
- "Sorry"
- "No, I don't think so."
- "I dont know"
- "It's not right"
- "Not exactly"
- "Nothing to do"
- "I forgot my"
- "I forgot it"
- "I don't want to tell you"

get_health_insurance_info:

description: get health insurance info
entities:
ssn:

function: verify_ssn
confirm: no
prompt:

- May I have the last four digits of your social security number?

response:

birthday:

function: verify_ssn
confirm: no
prompt:

14

- And your birthday?

response:

entity_groups:
ssn_group:
- ssn

birthday_group:
- birthday

success:
AND:

- VERIFY:

- ssn_group

- VERIFY:

- birthday_group

finish_response:

success:

- I have found your health insurance record.

failure:

- Sorry, I am not able to find your health insurance record.

repeat: false
max_turns: 10

health_appointment:

description: make an appointment at Nurse Nancy
samples:

- I want to see a doctor
- I don't feel so good
- I would like to make an appointment
- I want to make an appointment
- I got a fever
- make an appointment at Nurse Nancy

entities:

appt_date:

function: collect_info
confirm: no
prompt:

- What date do you prefer for the appointment?

response:

appt_time:

function: collect_info
confirm: no
prompt:

- At what time?

response:
department:

function: collect_info
confirm: no
prompt:

- Which department do you want to make the appointment with?

response:
doctor_name:

function: collect_info
confirm:
prompt:

- May I have your preferred doctor name?

response:

covid_protocol:

function: covid_protocol
confirm: no
prompt:

15

response:

- <info>

have_health_insurance:

function: check_condition
confirm: no
prompt:

- Do you have health insurance?

response:

- <info>

name:

function: collect_info
confirm: no
prompt:

- Since you don't have health insurance, let me create a profile for you.

What's your name?

response:

birthday:

function: collect_info
confirm: no
prompt:

- What is your birthday?

response:

- I have created a profile for you.

entity_groups:

date_time_group:
- appt_date
- appt_time

department_doctor_group:

- department
- doctor_name

covid_protocol_group:
- covid_protocol

have_health_insurance_group:
- have_health_insurance

name_birthday_group:

- name
- birthday

success:
AND:

- INSERT:

- date_time_group

- INSERT:

- department_doctor_group

- OR:

- AND:

- API:

- have_health_insurance_group

- TASK:

- get_health_insurance_info

- INSERT:

- name_birthday_group

- INFORM:

- covid_protocol_group

finish_response:

success:

- I have booked an appointment for you.

failure:

- Sorry, I can't help you book an appointment.

task_finish_function: create_appointment

16

repeat: true
repeat_response:

- Would you like to make another appointment?

max_turns: 10

Entity conﬁguration YAML ﬁle:

Entity:
ssn:

type: CARDINAL
methods:
ner:

birthday:

type: DATE
methods:
ner:

appt_date:

type: DATE
methods:
ner:

appt_time:

type: TIME
methods:
ner:
department:

type: PICKLIST
methods:

fuzzy_matching:

- ICU
- Elderly services
- Diagnostic Imaging
- General Surgery
- Neurology
- Microbiology
- Nutrition and Dietetics

suggest_value: yes

doctor_name:

type: PERSON
methods:
ner:

name:

type: PERSON
methods:
ner:

covid_protocol:

methods:

have_health_insurance:

type: USER_UTT
methods:

user_utterance:

We provide a conﬁg UI tool to create or edit the bot, see Figure 5.

Here is an example conversation of the health appointment bot, see Figure 6 and 7

17

Figure 5: Converse conﬁg UI

18

Figure 6: Example conversation of the health appointment bot

19

Figure 7: Task tree visualization of the health appointment bot

20

