2
2
0
2

r
p
A
6

]
E
S
.
s
c
[

1
v
7
8
7
2
0
.
4
0
2
2
:
v
i
X
r
a

1

DiffSearch: A Scalable and Precise
Search Engine for Code Changes

Luca Di Grazia, Paul Bredl, Michael Pradel

Abstract—The source code of successful projects is evolving all the time, resulting in hundreds of thousands of code changes stored
in source code repositories. This wealth of data can be useful, e.g., to ﬁnd changes similar to a planned code change or examples of
recurring code improvements. This paper presents DiffSearch, a search engine that, given a query that describes a code change,
returns a set of changes that match the query. The approach is enabled by three key contributions. First, we present a query language
that extends the underlying programming language with wildcards and placeholders, providing an intuitive way of formulating queries
that is easy to adapt to different programming languages. Second, to ensure scalability, the approach indexes code changes in a
one-time preprocessing step, mapping them into a feature space, and then performs an efﬁcient search in the feature space for each
query. Third, to guarantee precision, i.e., that any returned code change indeed matches the given query, we present a tree-based
matching algorithm that checks whether a query can be expanded to a concrete code change. We present implementations for Java,
JavaScript, and Python, and show that the approach responds within seconds to queries across one million code changes, has a recall
of 80.7% for Java, 89.6% for Python, and 90.4% for JavaScript, enables users to ﬁnd relevant code changes more effectively than a
regular expression-based search, and is helpful for gathering a large-scale dataset of real-world bug ﬁxes.

Index Terms—Software Engineering, Program Analysis, Software Maintenance.

(cid:70)

1 INTRODUCTION

H UNDREDS of thousands of code changes are stored

in the version histories of code repositories. To ben-
eﬁt from this immense source of knowledge, practitioners
and researchers often want to search for speciﬁc kinds
of code changes. For example, developers may want to
search through their own repositories to ﬁnd again a code
change performed in the past, or search for commits that
introduce a speciﬁc kind of problem. Developers may also
want to search through changes in repositories by others,
e.g., to understand how code gets migrated from one API
to another, or to retrieve examples of common refactorings
for educational purposes. A question on Stack Overﬂow on
how to systematically search through code changes1 has re-
ceived over half a million views, showing that practitioners
are interested in ﬁnding changes from the past.

Besides practitioners, researchers also commonly search
for speciﬁc kinds of code changes. For example, a researcher
evaluating a bug ﬁnding tool [2] or a program repair tool [3],
[4], [5] may be interested in examples of speciﬁc kinds
of bug ﬁxes. Likewise, researchers working on machine
learning models that predict when and where to apply
speciﬁc code changes require examples of such changes as
training data [6]. Finally, researchers systematically study
when and how developers perform speciﬁc kinds of changes
to increase our understanding of development practices [1],
[7], [8], [9].

Unfortunately, there currently is no efﬁcient and effec-
tive technique for systematically searching large version
histories for speciﬁc kinds of changes. The solutions pro-

All authors are with the Department of Computer Science, Univer-
sity of Stuttgart, Germany. Email:
luca.di-grazia@iste.uni-stuttgart.de,
paulbredl@gmx.de, michael@binaervarianz.de

1. https://stackoverﬂow.com/questions/2928584/
how-to-grep-search-committed-code-in-the-git-history

posed in the above Stack Overﬂow post are all based on
matching regular expressions against raw diffs. However,
searching for anything beyond the most simple change pat-
terns with a regular expression is cumbersome and likely to
result in irrelevant code changes. Another existing technique
is GitHub’s commit search, which allows for searching
through commit messages and meta-information, such as
developer names and project names. Nevertheless, commit
search does not support searching for speciﬁc code trans-
formations. Finally, previous research proposes techniques
that linearly scan version histories for speciﬁc patterns [10],
[11], [12], [13]. However, due to their linear design, these
techniques do not scale well to searching through hundreds
of thousands of changes in a short time.

This paper presents DiffSearch, a scalable and precise
search engine for code changes. DiffSearch is enabled by
three key contributions. First, we design a query language
that is intuitive to use and easy to adapt to different pro-
gramming languages. The query language extends the tar-
get programming language with wildcards and placehold-
ers that abstract speciﬁc syntactic categories, e.g., expres-
sions. Second, to ensure scalability, the approach is split into
an indexing part, which maps code changes into a feature
space, and a retrieval part, which matches a given query
in the feature space. We design speciﬁc features for code
changes, extracting useful information to match different
changes on code source. Finally, to ensure precision, i.e., that
a found code change indeed ﬁts the given query, a crucial
part of the approach is to match candidate code changes
against the given query. We present an efﬁcient algorithm
that checks if a query can be expanded into a code change.
DiffSearch is designed in a mostly language-agnostic
way, making it easy to apply the approach to different
languages. In particular, we restrict ourselves to a very

 
 
 
 
 
 
lightweight static analysis of code changes. The query lan-
guage and parts of the search algorithm build upon the
context-free grammar of the target programming language.
As a proof-of-concept, DiffSearch currently supports three
widely used languages: Java, JavaScript, and Python.

Our approach relates to work on searching for code,
which retrieves code snippets that match keywords [15],
[16], test cases [17], or partial code snippets [18], [19]. While
code search engines often have a design similar to ours,
i.e., based on indexing and retrieval, they consider only a
single snapshot of code, but no code changes. Other related
work synthesizes an edit program from one or more code
changes [10], [20], [21], [22], [23] and infers recurring code
change patterns [8], [24]. Starting from concrete changes,
these approaches yield abstractions of them. Our work
addresses the inverse problem: given a query that describes
a set of code changes, ﬁnd concrete examples that match
the query. Finally, our work relates to clone detection [25],
[26], [27], [28], [29], as DiffSearch searches for code changes
that resemble a query. Our work differs from clone detection
by considering code changes (and not individual snippets
of code), by focusing on guaranteed matches instead of
similar code, and by responding to queries quickly enough
for interactive use.

We evaluate the effectiveness and scalability of Diff-
Search with one million code changes in each Java, Python,
and JavaScript. We ﬁnd that the approach responds to
queries within a few seconds, scaling well to large sets of
code changes. The search has a mean recall of 80.7% for
Java, 89.6% for Python, and 90.4% for JavaScript, which can
be increased even further in exchange for a slight increase in
response time. A user study shows that DiffSearch enables
users to effectively retrieve code changes, clearly outper-
forming a regular expression-based search through raw
diffs. As a case study to show the usefulness of DiffSearch
for researchers, we apply the approach to gather a dataset
of 74,903 bug ﬁxes.

In summary, this paper contributes the following:

• A query language that extends the target program-
ming language with placeholders and wildcards,
making it easy to adapt the approach to different
languages.

• Empirical evidence that

• A technique for searching code changes that ensures
scalability through approximate, indexing-based re-
trieval, and that ensures precision via exact matching.
the approach effectively
ﬁnds thousands of relevant code changes, scales
well to more than a million changes from different
projects, and successfully helps users to answer a
diverse set of queries.

The implementation2 and a web interface3 of DiffSearch are
publicly available.

2 EXAMPLE AND OVERVIEW
2.1 Motivating Example

To illustrate the problem and how DiffSearch addresses it,
consider the following example query. The query searches

2. https://github.com/sola-st/DiffSearch
3. http://diffsearch.software-lab.org

2

for code changes that swap the arguments passed to a call
that is immediately used in a conditional. Such a query
could be used to ﬁnd ﬁxes of swapped argument bugs [30].

if(ID<1>(EXPR<1>, EXPR<2>)){

<...>

→ if(ID<1>(EXPR<2>, EXPR<1>)){

<...>

Our query language is an extension of

the target
programming language, Java in the example, and adds
placeholders for some syntactic categories. For example,
the ID<1> placeholder will match any identiﬁer, and the
EXPR<1> placeholder matches any expression. Instead of
such placeholders, queries can also include concrete iden-
tiﬁers and literals, e.g., to search for speciﬁc API changes.

As the set of code changes to search through, suppose
we have the following three examples, of which only the
second matches the query:

Code change 1:
if(check(a - 1, b)){ → if(check(a - 1, c)){

Code change 2:
if(isValidPoint(x, y)){ → if(isValidPoint(y, x)){

Code change 3:
while(var > k - 1){

sum += count(var);

→ while(var > k){

sum += 2 * count(var);

2.2 Problem Statement

An important design decision is the granularity of code
changes to consider. The options range from changes of indi-
vidual lines, which would limit the approach to very simple
code changes, to entire commits, which may span multiple
ﬁles, several dozens of lines [31], often containing multiple
entangled logical changes [32], [33], [34], [35]. We opt for a
middle ground between these two extremes and consider
code changes at the level of “hunks”, i.e., consecutive lines
that are added, modiﬁed, or removed together.
Deﬁnition 1 (Code change). A code change c → c(cid:48) consists
of two pieces of code, which each consists of a sequence
[l1, .., lm] of consecutive lines of code extracted from a
ﬁle in the target language.

Deﬁnition 2 (Query). A query q → q(cid:48) consists of two
patterns, which each are a sequence [l1, .., lm] of lines
of code in an extension of the target programming lan-
guage. The language extension adds wildcards, a special
“empty” symbol, and placeholders for speciﬁc syntactic
categories, e.g., to match an arbitrary expression or iden-
tiﬁer.

Given these two ingredients, the problem we address is:
Deﬁnition 3 (Search for code changes). Given a set C of
code changes and a query q → q(cid:48), ﬁnd a set M ⊆ C of
code changes such that each (c → c(cid:48)) ∈ M matches q →
q(cid:48). We say that a code change c → c(cid:48) matches a query
q → q(cid:48) if there exist an expansion of the placeholders
and wildcards in q → q(cid:48) that lead to c → c(cid:48).

By ensuring that, for any retrieved code change, the
query can be expanded to the code change, DiffSearch
guarantees that every result of a search precisely matches
the query.

3

Query
Snippet
Stmt
Expression

::= Snippet → Snippet
::= Stmt* | Expression |
::= (cid:104)...(cid:105) | (Target language rules)
::= EXPR | EXPR(cid:104)Number(cid:105) | (cid:104)...(cid:105) | (Target lan-

guage rules)

AssignOperator ::= OP | OP(cid:104)Number(cid:105) | (Target language rules)
BinaryOperator ::= binOP | binOP(cid:104)Number(cid:105) | (Target language

rules)

UnaryOperator ::= unOP | unOP(cid:104)Number(cid:105) | (Target language

rules)

Identiﬁer
Literal

::= ID | ID(cid:104)Number(cid:105) | (Target language rules)
::= LT | LT(cid:104)Number(cid:105) | (Target language rules)

Fig. 2: Simpliﬁed grammar of queries. Non-terminals are in
italics.

TABLE 1: Examples of Java changes and matching queries.

Code change

DiffSearch query

- evt.trig();

ID.ID();

→ _

y = 1;

- if (x > 0)
-
+ if (x < 0)
+

y = 0;

if (EXPR)

→ if (EXPR)

ID OP LT;

ID OP LT;

- run(k);
- now(k);
+ runNow(k);

run(EXPR<0>);
now(EXPR<0>);

→ runNow(EXPR<0>);

Figure 2 shows the grammar of our query language.
A query consists of two sequences of statements, which
describe the old and new code, respectively. The syntax for
statements is inherited from the target programming lan-
guage and not shown in the grammar. Instead of a regular
code snippet, a query may contain an underscore to indicate
the absence of any code, which is useful to describe code
changes that insert or remove code. The grammar extends
the target language by adding placeholders for speciﬁc
syntactic entities, namely expressions, operators, identiﬁers,
and literals. For each such entity, a query can either describe
with an unnamed placeholder that there should be any such
entity, e.g., EXPR for any expression, or repeatedly refer
to a speciﬁc entity with a named placeholder, e.g., using
EXPR<1> and EXPR<2>. Named placeholders will be bound
to the same entity across the entire query, e.g., to say that
the same expression EXPR<1> must appear on both sides.
We also introduce the wildcard <...> that matches any
statement or expression.

To illustrate the query language, Table 1 gives a few
examples of code changes and a corresponding query that
matches the code change. The ﬁrst two examples use un-
named placeholders, e.g., to match arbitrary identiﬁers. The
third example uses a named placeholder: The EXPR<0>
in both the old and new part of the query means that
this expression, here k, remains the same despite the code
change, which replaces two calls with one.

3.2 Tree-based Representation of Code Changes and
Queries

One goal of DiffSearch is to be mostly language-agnostic,
making it easy to apply the approach to different pro-

Fig. 1: Overview of the approach.

2.3 Main Idea of the Approach

DiffSearch consists of four components that are used in
an ofﬂine and an online phase as illustrated in Figure 1.
In the ofﬂine phase, the approach analyzes and indexes a
large set of code changes. The Parsing & Feature extraction
component of the approach parses and abstracts concrete
code changes and queries into a set of features, mapping
both into a common feature space. For our example query
in Section 2.1, the features encode, e.g., that a call expression
appearing within the condition of an if statement is changed
and that the changed call has two arguments. To enable
quickly searching through hundreds of thousands of code
changes, the Indexing component of DiffSearch indexes the
given feature vectors [36] once before accepting queries.

In the online phase, the input is a query that describes
the kind of code changes to ﬁnd. Based on the pre-computed
index and the feature vector of a given query, the Retrieval
component retrieves those code changes that are most sim-
ilar to the query. For our motivating example, this yields
Code change 1 and Code change 2 because both change the
arguments passed to a call. The similarity-based retrieval
does not guarantee precision, i.e., that each candidate code
change indeed matches the query. The Matching & Ranking
component of DiffSearch removes any candidates that do
not match the query by checking whether the placeholders
and wildcards in the query can be expanded into concrete
code in a way that yields the candidate code change. For our
example, matching will eliminate Code change 1, as it does
not swap arguments, and eventually returns Code change 2
as a search result to the user.

3 APPROACH
This section presents the approach in detail. Before going
through the four components introduced in Section 2.3, we
deﬁne the query language to specify what kind of code
changes to search for.

3.1 Query Language

To search for speciﬁc kinds of code changes, DiffSearch
accepts queries that describe the code before and after
the change. Our goal is to provide a query language that
developers can learn with minimal effort and that supports
all constructs of the target programming language. To this
end, the query language is an extension of the target pro-
gramming language, i.e., it includes all rules on the target
language and additional features useful for queries.

Parsing &Feature extractionIndexingRetrievalMatching &RankingFeaturevectorLearnedindexCandidatematchesQueryGuaranteedmatchesCodechangesOﬄineOnlinegramming languages. Our current version supports Java,
JavaScript, and Python. To this end, the approach repre-
sents code changes and queries using a parse tree, i.e., a
representation that is straightforward to obtain for any pro-
gramming language. The beneﬁt of parse trees is that they
abstract away some details, such as irrelevant whitespace,
yet provide an accurate representation of code changes.

To represent a set of commits in a version history as
pairs of trees, DiffSearch ﬁrst splits each commit into hunks,
which results in a set of code changes (Deﬁnition 1). The
approach then parses the old and new code of a hunk using
the programming language grammar into a single tree that
represents the code change. Likewise, to represent a query,
DiffSearch parses the query into a parse tree using our
extension of the grammar (Figure 2). For example, Figure 3
shows the parse trees of a change and a query. The change
on the left corresponds to Code change 2 from Section 2,
which swaps x and y of a call to isValidPoint.

An interesting challenge in parsing code changes and
queries are syntactically incomplete code snippets. For ex-
ample, the code changes in Section 2 open a block with { but
do not close it with }, because the line with the closing curly
brace was not changed. DiffSearch addresses this challenge
by relaxing the grammar of the target language so that it ac-
cepts individual code lines even when they are syntactically
incomplete. For example, we relax the grammar to allow for
unmatched parentheses and partial expressions.

An alternative to parse trees are abstract syntax trees
(ASTs). We build on parse trees instead because ASTs ab-
stract away many syntactic details that may be relevant in
queries. For example, consider the following code change
that adds parentheses to make a complex expression easier
to read:

flag = alive || x && y;

→ flag = alive || (x && y);

Because the added parentheses preserve the semantics
of the expression, they are abstracted away in a typical AST,
i.e., the old and new code have the same AST. As a result,
an AST-based representation could neither represent this
change nor a query to search for it.

3.3 Extracting Features

Based on the tree representation of code changes and
queries, the feature extraction component of DiffSearch rep-
resents each tree as a set of features. The goal of this step
is to enable quickly searching through hundreds of thou-
sands of code changes. By projecting both code changes and
queries into the same feature space, we enable the approach
to compare them efﬁciently. An alternative would be to
pairwise compare each code change with a given query [10],
[13]. However, such a pairwise comparison would require
an amount of computation time that is linear w.r.t. the
number of code changes, which would negatively affect the
scalability.

DiffSearch uses two kinds of features. The ﬁrst kind of
feature is node features, which encodes the presence of a node
in the parse tree. For the example in Figure 3, the dotted,
blue lines show three of the extracted node features. The
second kind of feature is parse tree triangles, which encode
the presence of a speciﬁc subtree. Each parse tree triangle

4

Algorithm 1 Represent features as ﬁxed-size vector.
Input: Set F of features, target size ltarget
Output: Feature vector v
1: v ← vector of ltarget zeros
2: for all f ∈ F do
h ← hash(f )
3:
v[h mod ltarget ] ← 1
4:
5: return v

is a tree that consists of a node and all its descendants up
to some conﬁgurable depth. We use a depth of one as a
default, i.e., a triangle contains a node and its immediate
child nodes. For the example in Figure 3, the dashed, red
lines highlight two of the extracted triangles. The triangle at
the top encodes the fact that there is an if statement, while
the other triangle encodes the fact that the code contains an
expression list with exactly two expressions. The two kinds
of features complement each other because node features
encode information about individual nodes, including iden-
tiﬁers and operators, whereas parse tree triangles represent
how nodes are structured.

For each code change or query, the approach extracts
a separate set of features for the old and the new code.
With this separation, the features encode whether speciﬁc
code elements are added or removed in a code change. The
feature sets for code changes and queries are constructed in
the same way, except that DiffSearch removes node features
for placeholder nodes, e.g., ID or EXPR, from the query. The
rationale is that we want the features of a query to be subset
of the features of a matching code change, but placeholder
nodes never appear in code changes.

n + ltri + l(cid:48)

Different code changes and queries yield different num-
bers of features. To efﬁciently compare a given query
against arbitrary code changes, DiffSearch represents all
features of a code change or query as a ﬁxed-size feature
vector. The feature vector is a binary vector of length
tri = l, where ln and l(cid:48)
ln + l(cid:48)
n are the number of
bits to represent the node features of the old and new code,
respectively, and likewise for ltri and l(cid:48)
tri for the parse tree
triangle features. We use l = 1, 000 by default, dividing it
equally among the four components, which strikes a balance
between representing a diverse set of features and efﬁciency
during indexing and retrieval. Section 5.5 evaluates different
sizes for the feature vector length.

Algorithm 1 summarizes how DiffSearch maps a set F of
features into a ﬁxed-size vector v. The algorithm computes
a hash function over the string representations of individual
nodes in a feature, sums up the hash values into a value h,
and sets the h-th index of the feature vector to one. To ensure
that the index is within the bounds of v, line 4 performs
a modulo operation. For each code change or query, the
algorithm is invoked four times to map each of the four
feature sets into a ﬁxed-size vector.

3.4 Indexing and Retrieving Code Changes

To prepare for responding to queries, DiffSearch runs an
ofﬂine phase that indexes the given set of code changes. The
indexing and retrieval components of the approach build
on FAISS, which is prior work on efﬁciently searching for

5

Fig. 3: Parse tree representations of Code change 2 (left) and the query from Section 2 (right). Only some of all considered
features are highlighted for illustration.

similar vectors across a large set of vectors [36]. In the
ﬁrst step of the ofﬂine phase, DiffSearch parses all code
changes and stores the parse trees on disk. In the second
step, DiffSearch generates the feature vectors of the code
changes using the corresponding parse trees. Given the set
Vchanges of feature vectors of all code changes, the approach
computes an index into these vectors.

After the ofﬂine indexing phase, DiffSearch accepts
queries. For a given query, the approach computes a fea-
ture vector vquery (Section 3.3), and then uses the index
to efﬁciently retrieve the most similar feature vectors of
code changes. FAISS allows for efﬁciently answering ap-
proximate nearest neighbor queries, without comparing the
query against each vector in Vchanges . The nearest neighbors
are based on the L2 (Euclidean) distance. To ensure that
the presence of matching features is weighted higher than
the absence of features, we multiple vquery by a constant
factor l
2 + 1 before running the nearest neighbor query.
To illustrate this decision consider an example with three
feature vectors: A query vQ = (0, 0, 1), a potential match
vP = (1, 1, 1) with the third feature in common, and a
mismatch vM = (0, 0, 0). Naively computing the Euclidean
√
1, i.e.,
distances yields d(vQ, vP ) =
the mismatch would be closer to the query than the potential
match. Instead, after multiplying vQ with the constant factor
√
3
6.25,
2 + 1, we have d(vQ, vP ) =
i.e., the potential match is now closer to the query than to
the mismatch.

4.25 and d(vQ, vM ) =

2 and d(vQ, vM ) =

√

√

The approach retrieves the k most similar code changes
for a given query. We use k = 5, 000 by default, and
Section 5.5 evaluates other values. The retrieved candidate
code changes are ranked based on their distance to the
query, and we use this ranking to sort the ﬁnal search results
shown to a user.

3.5 Matching of Candidate Search Results

Given the k candidate code changes retrieved for a given
query as described in Section 3.4, DiffSearch could return
all of them to the user. However, the feature-based search
does not guarantee precision, i.e., that all the retrieved code
changes indeed match the query. One reason is that the
features capture only local information, but do not encode
the entire parse tree in a lossless way. Another reason is

that the features do not encode the semantics of named
placeholders, i.e., they cannot ensure that placeholders are
expanded consistently across the old and new code.

To guarantee that all code changes returned in response
to a query precisely match the query, the matching com-
ponent of DiffSearch takes the candidate search results
obtained via the feature-based retrieval and checks for each
candidate whether it indeed matches the query. Intuitively,
a code change matches a query if the placeholders and
wildcards in the query can be expanded in a way that yields
code identical to the code change or some subset of the code
change. More formally, we deﬁne this idea as follows:
Deﬁnition 4 (Match). Given a code change c → c(cid:48) and
a query q → q(cid:48), let tc, tc(cid:48), tq, tq(cid:48) be the corresponding
parse trees. The code change matches the query if

•

•

tq can be expanded into some subtree of tc and
tq(cid:48) can be expanded into some subtree of tc(cid:48)

so that all of the following conditions hold:

• Each placeholder is expanded into a subtree of the

corresponding syntactic entity.

• All occurrences of a named placeholder are consis-

tently mapped to identical subtrees.

• Each wildcard is expanded to an arbitrary, possibly

empty subtree.

For example, consider the query and code change in
Figure 3 again. They match because the tree on the right
can be expanded into the tree on the left. The expansion
maps the named placeholders ID<1> to isValidPoint,
EXPR<1> to the subtree that represents x, and EXPR<2> to
the subtree that represents y. Moreover the wildcards in the
query are both mapped to the empty tree. As an example
of a code change that does not match this query, consider
Code change 1 from Section 2 again. The parse tree of the
query cannot be expanded into the parse tree of that code
change because there is no way of expanding the query tree
while consistently mapping EXPR<1> and EXPR<2> to the
three method arguments a-1, b, and c.

To check whether a candidate code change indeed
matches the given query, DiffSearch compares the parse tree
of the query with the parse tree of the code change in a top-
down, left-to-right manner. The basic idea is to search for a

stmt->queryIfstmtblock{<...>parExprexpr()callID<1>exprList()EXPR<1>EXPR<2>,stmtIfstmtblock{<...>parExprexpr()callID<1>exprList()EXPR<2>EXPR<1>,AST triangle featureNode featurestmt->code changeIfstmtblock{parExprexpr()callisValidPointexprList()exprexpr,stmtIfstmtblock{parExprexpr()callisValidPointexprList()exprexpr,primaryprimaryprimaryprimaryxxyyAlgorithm 2 Check if a code change matches a query.
Input: Code change c → c(cid:48) and query q → q(cid:48)
Output: True if they match, False otherwise.
1: tc, tc(cid:48) ← parse(c → c(cid:48))
2: tq, tq(cid:48) ← parse(q → q(cid:48))
3: NtoMatch ← (allNodes(q) ∪ allNodes(q(cid:48))) \ wildcards
4: W ← candidateMappings(tc, tc(cid:48) , tq, tq(cid:48) )
5: while W is not empty do
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:

M ← Take a mapping from W
nq ← nextUnmatchedNode(M, tq, tq(cid:48) )
npq ← Parent of nq
npc ← Look up npq in M
for c in all not yet matched children of npc do

M (cid:48) ← Copy of M with nq (cid:55)→ c
if keys(M (cid:48)) ∩ NtoMatch = ∅

and isValid (M, tc, tc(cid:48) , tq, tq(cid:48) ) then

if canAddToMap(M, c, nq) then

Add M (cid:48) to W

return true

else

mapping of nodes in the query tree to nodes in the parse
tree that consistently maps named placeholders to identical
subtrees. On top of this basic idea, the matching algorithm
faces two interesting challenges. We illustrate the challenges
with the following query, which searches for code changes
where two call statements get replaced by an assignment of
a literal to an identiﬁer. The following example shows the
query on the left and a matching code change on the right:
x = 5;
foo();
y = 7;

foo();
bar();
baz();

ID();
<...>
ID();

→ ID = LT;

→

The ﬁrst challenge is because queries are allowed to
match parts of a change, which is useful to ﬁnd relevant
irrelevant changed code.
changes surrounded by other,
While useful, this property of queries also implies that the
query may match at multiple places within a given code
change. In the above example, the ID = LT; part of the
query may match both x = 5; and y = 7;. The second
challenge is because queries may contain wildcards, which
is useful to leave parts of a query unspeciﬁed. Wildcards
also cause a single query to possibly match in multiple ways.
For the above example, the wildcard could be between
the calls of foo and bar, between the calls of bar and
baz, or it could match the call of bar(). Because of these
two challenges, matching must consider different ways of
mapping a query onto a code change, which results in a
search space of possible matches that must be explored.

DiffSearch addresses these challenges in Algorithm 2,
which checks whether a given query and code change
match. The algorithm starts by parsing the code change
into trees tc and tc(cid:48) , which represent the old and new
part of the change, and likewise for the query. The core of
the algorithm is a worklist-based search through possible
mappings between nodes in the parse tree of the query and
nodes in the parse tree of the code change. These mappings
are represented as a map M from nodes in the query trees
to nodes in the code change trees. Each mapping M in
the worklist W represents a possible way of matching the
query against the code change. To determine whether all
nodes in the query have been successfully mapped, the
algorithm maintains a set NtoMatch of all the nodes in

6

the query that must be matched. The algorithm explores
mappings in W until it either ﬁnds a mapping that covers
all nodes in NtoMatch , or until it has unsuccessfully explored
all mappings in W .

Algorithm 2 relies on several helper functions. One of
them, candidateMappings, computes the starting points for
the algorithm by returning all possible mappings of the
roots of tq and tq(cid:48) to nodes in the code change trees. The
nextUnmatchedNode function performs a top-down, left-to-
right pass through the query trees to ﬁnd a node that is
not yet in the current map M . The canAddToMap function
checks if adding a mapping nq (cid:55)→ c is consistent with an
already existing map M . Speciﬁcally, it checks that nq is
not yet among the keys of M , that c is not yet among the
values of M , and that the two nodes are either identical
non-placeholder nodes or that nq is a placeholder that can be
consistently mapped to c as speciﬁed in Deﬁnition 4. Finally,
the helper function isValid checks whether a mapping M
that covers all to-be-matched nodes ignores nodes in the
change tree only when there is a corresponding wildcard
in the query tree. The algorithm postpones this check to
isValid to reduce the total number of mappings to explore.
Matching a single code change against a query might
cause the algorithm to explore many different mappings,
and DiffSearch typically invokes Algorithm 2 not only once
but for tens or hundreds of candidate search results. To
ensure that the approach responds to queries quick enough
for interactive usage, we optimize Algorithm 2 by pruning
code changes that certainly cannot match a given query.
To this end, the approach checks if all leaf nodes in the
parse tree of a query occur at least once in the parse tree
of the code change. For example, consider the following
query, which searches for changes in the right-hand side
of assignments to a variable myVar:4

myVar = LT; → myVar = LT;

If a code change does not include any token myVar, then
the optimization immediately decides that the code change
cannot match the query and skips Algorithm 2.

4 IMPLEMENTATION

We implement the DiffSearch idea into a practical search
engine that supports multiple programming languages, cur-
rently Java, JavaScript, and Python. To gather raw code
changes, the implementation uses ”git log -p”. For each
change, a parse tree is created using ANTLR45, using the
grammar of the target programming language, modiﬁed to
support queries and to allow for syntactically incomplete
code fragments (Section 3.1). The indexing and retrieval
components build on the FAISS library [36], which sup-
ports efﬁcient vector similarity queries for up to billions
of vectors. Once changes are indexed, the search engine is
a server that responds to queries via one of two publicly
available interfaces: a web interface for interactive usage
and a web service for larger-scale usage, e.g., to create a
dataset of changes.

4. Because the myVar = part of the code remains the same, the
query expresses that the literal captured by the unnamed placeholder
LT is changing.

5. https://www.antlr.org/

5 EVALUATION

Our evaluation focuses on ﬁve research questions:

• RQ1: What is the recall of DiffSearch? (Section 5.1)
• RQ2: How efﬁcient and scalable is DiffSearch? (Sec-

tion 5.2)

• RQ3: Does DiffSearch enable users to ﬁnd rele-
vant code changes more effectively than a regular
expression-based search through raw diffs? (Sec-
tion 5.3)

• RQ4: Is DiffSearch useful for ﬁnding examples of

recurring bug ﬁx patterns? (Section 5.4)

• RQ5: How do parameters of the approach inﬂuence

the results? (Section 5.5)

For each of RQ1, RQ2, and RQ5, we present results for all
three currently supported target languages: Java, JavaScript,
and Python. For each language, we gather at least one
million code changes from repositories that are among the
top 100 of their language based on GitHub stars. For RQ3
and RQ4, we focus on Java as the target language because
RQ3 is based on a user study and because RQ4 builds on a
Java dataset created by prior work [37]. The experiments are
performed on a server with 48 Intel Xeon CPU cores clocked
at 2.2GHz, 250GB of RAM, running Ubuntu 18.04.

TABLE 2: Recall of DiffSearch across 80 queries per lan-
guage.

7

Queries

As-is
Less-placeholders
More-placeholders
Generalized

Total

Java

90.6%
83.5%
74.2%
76.7%

80.7%

Python

100.0%
99.9%
96.7%
74.9%

89.6%

JavaScript

100.0%
99.8%
95.8%
66.1%

90.4%

is that the parse tree of a more generalized query shares
fewer features with a matching code change, e.g., because a
complex subtree is folded into an EXPR node. The slightly
higher recall for Python and JavaScript can be explained
by two observations. First, code changes in Java tend to be
slightly larger, causing more nodes on the parse trees, which
reduces the chance to ﬁnd a suitable candidate change.
Second, across the 80 queries, there are 236,836 ground truth
code changes for Java, but only 69,626 and 59,789 for Python
and JavaScript, respectively, making ﬁnding all ground truth
code changes in Java a harder problem. We discuss in
Section 5.5 that the recall can be increased even further
by retrieving more candidate matches, at the expense of a
slightly increased response time.

5.1 RQ1: Recall

5.2 RQ2: Efﬁciency and Scalability

While the precision of DiffSearch’s results is guaranteed by
design (Section 3.5), the approach may miss code changes
due to its feature-based search, which ensures scalability
but may fail to include an expected code change into the
candidate matches. Additionally, DiffSearch only considers
k candidate changes, so it can ﬁnd at most k results even
though queries could have more than k matching code
changes.

from all

To establish a ground truth, we randomly sample code
changes c → c(cid:48)
indexed Java, Python, and
JavaScript code changes and formulate a corresponding
query q → q(cid:48) using the following four strategies. The
as-is strategy simply copies c into q and c(cid:48) into q(cid:48). The
less-placeholders strategy replaces some of the identiﬁers,
operators, and literals with corresponding placeholders or
wildcards. The more-placeholders strategy, similarly, replaces
the majority of the identiﬁers, operators, and literals. Finally,
the generalized strategy replaces most or all of the identiﬁers,
operators, and literals. For each strategy and each program-
ming language, we randomly sample 20 code changes and
construct a query for it. We then compare each query against
all 1,001,797 Java, 1,007,543 JavaScript, and 1,016,619 Python
code changes using the matching component of DiffSearch.
While signiﬁcantly slower than the feature-supported search
that DiffSearch uses otherwise, this approach allows us
to determine the set of all code changes expected to be
found for a query, because Algorithm 2 precisely computes
whether a code change matches a query.

Table 2 shows the recall of DiffSearch w.r.t. the ground
truth, i.e., the percentage of all ground truth code changes
that the approach ﬁnds. On average across the 80 queries
per programming language, DiffSearch has a recall of 80.7%
for Java, 89.6% for Python, and 90.4% for JavaScript. More
speciﬁc queries tend to lead to a higher recall. The reason

A major goal of this work is to enable quickly searching
through hundreds of thousands of code changes. The fol-
lowing evaluates how the number of code changes to search
through inﬂuences the efﬁciency of queries, i.e., how well
DiffSearch scales to large amounts of changes. As queries to
run, we use the 80 queries described in Section 5.1. For each
query, we measure how long DiffSearch takes to retrieve
code changes from ten increasingly large datasets, ranging
from 10,000 to 1,000,000 code changes.

The top row of Figure 4 shows the results for the full
DiffSearch approach. Answering a query typically takes
between 0.5 and 2 seconds. Moreover, the response time re-
mains constant when searching through more code changes.
The reasons are (i) that FAISS [36] provides constant-time
retrieval in the vector space, and (ii) that the time for match-
ing candidate changes against the query is proportional to
the constant number k of candidate changes. Comparing
the three programming languages, we ﬁnd that they yield
similar performance results, which is due to the fact that
most parts of our implementation are language-agnostic.
We conclude that DiffSearch scales well to hundreds of
thousands of changes and remains efﬁcient enough for
interactive use.

The bottom row of Figure 4 shows the same experiment
when removing the indexing and retrieval steps of Diff-
Search (note: different y-axis). Instead, the approach linearly
goes through all code changes and compares them against
a given query using the matching component only. Answer-
ing a query takes up to 41 seconds on average, showing that
the feature-based indexing is essential to ensure DiffSearch’s
scalability.

Even though scalability is most relevant for the online
part of DiffSearch, we also measure how long the ofﬂine part
takes. In total, analyzing a million code changes to extract

8

(a) DiffSearch (Java).

(b) DiffSearch (Python).

(c) DiffSearch (JavaScript).

(d) DiffSearch without indexing
(Java).

(e) DiffSearch without indexing
(Python).

(f) DiffSearch without indexing
(JavaScript).

Fig. 4: Response time across differently sized datasets (average and 95% conﬁdence interval). Top: Full DiffSearch. Bottom:
DiffSearch without indexing.

feature vectors and indexing these vectors takes up to ﬁve
hours. As this is a one-time effort that does not inﬂuence the
response time, we consider it acceptable in practice.

increase robustness (#4, #7, #8), code cleanup (#10), changes
of functionality (#6, #9), bug ﬁxes (#1, #2, #5), and uses of a
new API (#3).

5.3 RQ3: User Study

5.3.1 Study Setup

We perform a user study to measure whether DiffSearch
enables users to effectively retrieve code changes within a
given time budget, and to compare our approach with a
regular expression-based baseline. To this end, we provide
natural language descriptions of kinds of code changes and
ask each user to ﬁnd up to ten matching code changes per
description within two minutes. We choose this time limit
based on empirical results on code search sessions, which
are reported to have a median length of 89 seconds [38]. We
then ask the users how many satisfying code changes they
could ﬁnd. Each user works on each kind of query with
both DiffSearch and the baseline tool, alternating which tool
to use ﬁrst.

Queries. The descriptions of the queries (Table 3) are de-
signed with two criteria in mind. First, they cover different
syntactic categories of changes, including additions (#3, #4,
#7), modiﬁcations (#6), and removals (#10) of statements;
changes within existing statements (#1, #2, #5, #9); and
changes that surround an existing statement with a new
statement (#8). Second, the queries cover a diverse range of
reasons for changing code, including code improvements to

Baseline. Because DiffSearch is the ﬁrst search engine
speciﬁcally designed for code changes, there is no estab-
lished tool to compare against. Instead, we use a regular
expression-based approach suggested in the Stack Overﬂow
question cited in Section 1 as a baseline, which we call
REGEX. Regular expressions are well known and widely
used for general search tasks. Naively applying regular
expressions to the git history of many projects, as suggested
on Stack Overﬂow, leads to unacceptably high response
times (tens or even hundreds of seconds, depending on
the query). Instead, we preprocess the output of git log by
removing information unrelated to the task, such as commit
messages and ﬁle names, which reduces the size of the ﬁle
and makes the response time acceptable.

Participants and setup. We recruit ten participants with
solid knowledge about regular expressions, consisting of
seven PhD students, two senior undergraduate students,
and one senior developer. The participants do not overlap
with the authors of this paper. The users access DiffSearch
through a web interface that resembles a standard search
engine, but has two text input ﬁelds, for the old and new
code, respectively.6 For REGEX, participants use a terminal
and their favorite tool to search with regular expressions,

6. The web interface is available to reviewers, see end of Section 1.

500002500004000006000008500001000000# Changes012345Time (seconds)500002500004000006000008500001000000# Changes012345Time (seconds)500002500004000006000008500001000000# Changes012345Time (seconds)500002500004000006000008500001000000# Changes020406080100Time (seconds)500002500004000006000008500001000000# Changes020406080100Time (seconds)500002500004000006000008500001000000# Changes020406080100Time (seconds)e.g., grep. We provide about 750 words of instructions to
the participants, which explain the task, the query language
of DiffSearch, and how to search through raw diffs using
REGEX.

5.3.2 Quantitative Results

Table 3 shows the number of search results obtained using
DiffSearch and REGEX. Across the entire study, the par-
ticipants ﬁnd 711 code changes with DiffSearch but only
303 with REGEX. Inspecting individual queries shows that,
while some are harder than others, at least one user ﬁnds
ten code changes for each query. For 77.0% of DiffSearch
queries, users retrieve at least one code change with Diff-
Search, whereas with REGEX, users get at least one code
change for only 35.0% of all queries. For 65.0% of DiffSearch
queries, users ﬁnd the desired number of ten code changes,
but only 29.0% of users succeed with REGEX. Overall, we
conclude that DiffSearch enables users to effectively ﬁnd
code changes, and that the approach clearly outperforms
the REGEX-based baseline.

5.3.3 Qualitative Results

While DiffSearch clearly outperforms REGEX for all ten
queries, there are some user-query pairs where REGEX
yields more results than DiffSearch. Analyzing these cases
shows two main reasons. First, some users were effec-
tive with regular expressions by searching for simple code
changes that only add or only remove a single line of code.
For example, for query #3, some users simply searched
for “+ import (.*)”. Second, some users formulated regular
expression queries that are more general than the natural
language description we provide and then manually ﬁl-
tered the results to ﬁnd the ten relevant code changes. For
example, for query #5, a user searched for “if((.*?))” and
then manually checked for conditions that involve null.
Moreover about satisfying results, all the users get enough
results for query #6 with queries like ”ID(EXPR); → ”,
underlining how easy it is querying DiffSearch. Another
example is about query #10, where all the users use a
query like ”System.out.println(EXPR); → ” and they get
100 satisfying results. The user study also shows how fast
the users learn to use DiffSearch. For example, Users 2 and
5 on query #3 ﬁnd 0 code changes with DiffSearch, while
they ﬁnd 10 code changes on query #4. As a result, the
users learn with the experience the DiffSearch query syntax.
For example User 2 for query #3 use queries like ” →
import LT().LT()” and ” → import LT<...>.LT<...>” that
are syntactically invalid. After some tries they understand
the query and they perform better on the following queries.
These examples illustrate that DiffSearch is particularly
useful when searching for non-trivial code changes and to
avoid false positive results.

We also asked for informal feedback about both tools,
to better understand their strengths and weaknesses. Users
report three reasons for preferring DiffSearch over REGEX.
First, they ﬁnd the DiffSearch query language easier to
use than regular expression syntax, because it builds upon
the underlying programming language. In particular, some
users afﬁrm that in two minutes they were able to type
a DiffSearch query, but not a working regular expression,
especially for complex queries, such as multi-line code

9

changes. Second, REGEX often was much slower than Diff-
Search because it linearly searches through all code changes.
This inefﬁciency, especially for more complex regular ex-
pressions, caused some users to not ﬁnd any relevant code
changes in the given time. Finally, some users mention that
REGEX syntax is not precise enough to formulate effective
queries, leading to many false positives.

5.4 RQ4: Searching for Bug Fixes

As a case study for using DiffSearch, we apply it to search
for instances of bug ﬁx patterns, which could help, e.g., to
establish a dataset for evaluating bug detection tools [2], au-
tomated program repair tools [6], or for training a learning-
based bug detection tool [39]. We build on a set of 16
patterns deﬁned by prior work [37], of which we use twelve
(Table 4). The remaining four bug ﬁx patterns are all about
single-token changes, e.g., changing a numeric literal or
changing a modiﬁer, which currently cannot be expressed
with our query language. For the twelve supported patterns,
we formulate queries based on the descriptions of the pat-
terns and then search for them with DiffSearch. We use two
different datasets for this case study. First, a set of around
10,000 code changes, called SStuBs commits, that contains all
those commits where the prior work [37] found instances of
the bug ﬁx patterns through custom-built analysis scripts,
which we call SStuBs. Second, a set of around 1,000,000
code changes, called Large, sampled from all the repositories
analyzed in the prior work.

Table 4 shows for each bug ﬁx pattern how many code
changes the different approaches ﬁnd. DiffSearch returns a
total of 15,959 code changes for the ﬁrst dataset and 74,903
for the second dataset. Computing the intersection with the
results retrieved by SStuBs, DiffSearch ﬁnds 79.2% of their
changes, a result consistent with the Java recall computed
in RQ1. Moreover, DiffSearch ﬁnds many more matching
code changes, increasing the dataset from 2,867 to 15,959
examples of bug ﬁxes. The reason is that our queries are
more general than the custom analysis scripts in SStuBs
and include, e.g., also code changes that perform other
changes besides the speciﬁc bug ﬁx. The number of code
changes found by DiffSearch is higher than the number of
commits (10k) because a single commit may match multiple
patterns. For example, a change that swaps two arguments
and modiﬁes a function name will appear in patterns 5
and 8. Overall, DiffSearch is effective at ﬁnding various
examples of bug ﬁx patterns, showing the usefulness of the
approach for creating large-scale datasets.

5.5 RQ5: Impact of Parameters

We perform a sensitivity analysis for the two main parame-
ters of DiffSearch: the length l of feature vectors (Section 3.3),
and the number k of candidate matches retrieved via the
feature vectors (Section 3.4). We select a set of values from
1,000 to 20,000 for k and from 500 to 4,000 for l, i.e.,
values below and above the defaults, and then measure their
impact on the time to answer queries, the recall, and the size
of the index.

Table 5 shows the results. We ﬁnd that retrieving more
candidate code changes, i.e., a higher k, slightly increases
the response time. The reason is that matching more code

TABLE 3: Query descriptions for user study and summary of search results.

10

Id Query description

DiffSearch | REGEX

1 Find changes in which a return statement that returns a
literal changes to returning the result of a method call.
2 Find changes where the developer swaps the arguments

of a method call.

User 1 User 2 User 3 User 4 User 5 User 6 User 7 User 8 User User 10 Total

10| 0 10 | 0

0 |10

0 | 0

10 | 0

7 | 0

10 | 0

7 | 0

7 | 0

7 | 0

68 | 10

0 | 0

0 | 0

10 | 0

10 | 0

10 | 0

0 | 0

10 | 0

10 | 0 10 | 0 10 | 0

70 | 0

3 Find changes that add an import of a class in the form

10| 0

0 |10 10 |10 10 |10

0 |10

10 |10 10 |10 10 | 0 10 | 0 10 | 0

80 | 60

“import somePkg.SomeClass”.

4 Find changes that add a call to close some resource, e.g.,

0 | 0 10 |10 10 |10 10 | 0

10 |10

0 |10 10 |10 10 | 0 10 | 0 10 | 10

80 | 60

a stream or ﬁle reader.

5 Find changes where the condition of an if statement with

4 | 0 10 | 0

4 | 5

0 | 0

7 | 0

0 | 2

4 | 0

4 | 0

0 | 0

5 | 0

38 | 7

a body changes from “-= null” to “!= null”.

6 Find changes that remove a method call with one argu-

10| 0 10 | 1

10 |10 10 | 0

10 | 0

10 |10 10 |10 10 | 0 10 | 0 10 | 0

100| 31

ment.

7 Find changes that insert an assertion using Java’s “as-

10| 0 10 |10

0 |10

0 | 2

10 |10

0 |10 10 |10 10 | 0 10 | 0 10 | 10

70 | 62

sert” keyword.

8 Find changes in which a code snippet is surrounded with

0 | 0

0 | 0

0 | 0

0 | 0

0 | 0

10 | 0

4 |10 10 | 0

0 | 0

1 | 0

25 | 0

a try/catch block.

9 Find changes where the condition of a while loop is

10| 0 10 |10 10 | 2

10 | 0

10 | 0

0 | 1

10 | 0

0 | 0 10 | 0 10 | 0

80 | 13

changed.

10 Find changes that remove a call to System.out.println(...). 10| 0 10 |10 10 |10 10 | 0

10 |10

10 |10 10 |10 10 | 0 10 | 0 10 | 10

100| 60

Total

64| 0 70 |51 64 |67 60 |12 77 |40

47 |53 88 |50 81 | 0 77 | 0 83 | 30

711|303

TABLE 4: Effectiveness of DiffSearch in ﬁnding instances of
bug ﬁx patterns [37].

TABLE 5: Impact of length l of feature vectors and number
k of candidates (default conﬁguration is bold).

Description

SStuBs commits (10k)

Large (1M)

k

l

Response time (s)

Recall

Size of

SStuBs DiffSearch Both DiffSearch

min

avg

max

(%)

index (GB)

1 Change only caller
2 Change binary operator
3 More speciﬁc if
4 Less speciﬁc if
5 Wrong function name
6 Same caller, more args
7 Same caller, less args
8 Same caller, swap args
9 Change unary operator
10 Change binary operand
11 Add throws exception
12 Delete throws exception

Total

132
211
130
166
1,141
557
110
98
126
91
60
45

2,867

1,880
347
592
592
1,439
2,108
2,123
2,285
134
347
1,834
2,278

121
131
116
150
935
432
75
89
70
73
34
44

15,959 2,270

5,974
2,979
5,660
5,387
8,109
11,207
10,798
9,042
6,081
2,136
3,848
3,682

74,903

changes against the query increases the time taken by the
matching phase. On the positive side, increasing k increases
the recall, reaching 87.3% for Java, 93.7% for Python, and
95.6% for JavaScript when k=20,000, while still providing an
acceptable average response time. Parameter l increases the
time to answer a query because a larger feature vector slows
down the nearest neighbor search. Likewise, a larger l also
increases the size of the index. Since increasing l beyond
our default does not signiﬁcantly increase recall, we use
l=1,000 as the default to have a manageable index size and
a reasonable response time.

6 RELATED WORK

Code Search. Code search engines allow users to ﬁnd code
snippets based on method signatures [17], existing code
examples [18], [19], [40], or natural language queries [16],
[41], [42]. Sourcerer provides an infrastructure that combines
several of the above ideas [15]. Early work by Paul et
al. [14] proposes a mechanism similar to the placeholders

Java:

1,000
5,000
10,000
20,000
5,000
5,000
5,000

Python:

1,000
5,000
10,000
20,000
5,000
5,000
5,000

JavaScript:

1,000
5,000
10,000
20,000
5,000
5,000
5,000

1,000
1,000
1,000
1,000
500
2,000
4,000

1,000
1,000
1,000
1,000
500
2,000
4,000

1,000
1,000
1,000
1,000
500
2,000
4,000

1.5
1.5
1.7
1.8
0.8
3.0
5.8

3.0
1.8
3.5
4.1
1.0
2.7
6.1

1.2
1.3
1.4
1.8
0.7
3.1
5.1

1.9
2.2
2.5
3.1
1.3
4.2
7.4

4.1
2.4
5.0
6.0
1.6
4.9
7.9

1.9
2.0
2.3
2.9
1.2
4.5
9.2

3.5
9.0
9.4
17.7
8.1
9.9
15.3

5.5
3.5
8.9
12.4
3.1
40.8
13.1

2.8
2.8
3.3
5.7
2.1
5.4
12.8

71.8
80.7
84.9
87.3
79.3
80.6
78.1

81.9
89.8
91.6
93.7
86.6
89.8
83.4

85.4
90.4
94.0
95.6
90.3
92.5
88.6

4.0
4.0
4.0
4.0
2.0
8.0
16.0

4.1
4.1
4.1
4.1
2.0
8.1
16.3

4.0
4.0
4.0
4.0
2.0
8.0
16.1

in our query language. The most important difference be-
tween these approaches and DiffSearch is that we search
for changes of code, not for code snippets within a single
snapshot of code. Another difference is that DiffSearch
guarantees that all search results match the given query,
whereas the existing techniques, with the exception of [40],
are aimed at similarity only.

Prequel has a goal similar to DiffSearch, and matches
patches against user-provided rules that the code before
and after a patch must comply with [13]. The approaches

differ in two aspects. First, Prequel’s rules are based on
the semantic patch language of Coccinelle [43] and may
include executable code, e.g., queries are Turing-complete.
In contrast, our queries are purely declarative and build
on the underlying programming language. Second, Prequel
performs a regular expression-based pre-ﬁltering for each
query, followed by a linear search through all commits. As
a result, answering a query may take minutes or, if the pre-
ﬁltering is not effective, even longer [13]. In contrast, Diff-
Search avoids a linear search via feature-based retrieval, and
hence, responds to queries across hundreds of thousands of
code changes within seconds.

Several ideas to improve the user’s interaction with a
code search engine have been proposed, such as reﬁning
search results based on user’s feedback about the quality
of results [44], [45]. Other work resolves vocabulary mis-
matches between queries and code [46]. Future work could
adopt similar ideas to searching for code changes.

Code Changes as Edit Scripts. To reason about code
changes, several techniques derive edit scripts on ASTs [10],
[20], [23], [47], providing an abstract description of the
change that can then be applied elsewhere [48]. Lase gen-
eralizes from multiple code changes into a single edit
script [49]. Future work could explore using an edit script-
based representation of code changes to search for code
changes. An advantage of our parse tree-based feature
extraction is that it does not require aligning the old and
new code, allowing us to featurize hundreds of thousands
of code changes in reasonable time.

Mining Code Changes. Work on mining code repositories
and learning from code changes shows development his-
tories to be a rich source of implicitly stored knowledge.
For example, existing approaches leverage version histories
to extract repetitive code changes [1], [8], [50], predict code
changes [51], predict bugs [52], [53], or to learn about API
usages [54], [55]. Mining approaches typically consider all
code changes in a project’s version history or ﬁlter changes
using simple patterns, e.g., keywords in commit messages.
In contrast, DiffSearch allows for identifying code changes
that match a speciﬁc query.

Learning from Code Changes. Large sets of code changes
enable learning-based techniques. One line of work learns
from speciﬁc kinds of changes, e.g., ﬁxes of particular bug
patterns, how to apply this kind of change to other code
for automated program repair [6], [21], [56]. Another line
of work ranks potential program repairs based on their
similarity to common code change patterns [57]. DiffSearch
could help gather datasets of changes for these approaches
to learn from, e.g., based on queries for bug ﬁxing patterns.
Other Analyses of Code Changes. There are various other
analyses of code changes, of which we discuss only a subset
here. Hashimoto et al. propose a technique for reducing
a diff to the essence of a bug [58]. Nielsen et al. [59]
use JavaScript code change templates to ﬁx code broken
due to library evolution. Another approach automatically
documents code changes with a natural language descrip-
tion [60]. SCC [61] and DeepJIT [62] are predictive models
that estimate how likely a code change is to introduce a bug.
A related problem is to ﬁnd the bug-inducing code change
for a given bug report [63], [64]. DiffBase [65] encodes facts
about different versions of a program to facilitate multi-

11

version program analyses. CodeShovel [66] tracks a method
from its creation to its current state throughout a version
history. All these approaches relate to our work by also
reasoning about code changes, but they aim for different
goals than DiffSearch.

Clone Detection. DiffSearch relates to code clone detec-
tors [25], [26], [27], [28], [29], as answering a query resembles
ﬁnding clones of the query. Clone detectors are typically
evaluated on a single snapshot of a code base, and they
may take several minutes or even hours to terminate [29].
In principle, one could use an off-the-shelf code clone de-
tector to search for speciﬁc kinds of code changes, where
the old and parts of the query must be clones of the old
and new parts of a change. However, this approach would
search for clones among all code changes for each query,
which may not be fast enough for an interactive search
engine. Another difference is that DiffSearch guarantees
to yield code changes that match a query, whereas clone
detectors are interested in similar but not necessarily ex-
actly matching code. Some clone detectors summarize code
in ways related to our feature extraction. For example,
Deckard [27] computes characteristic vectors of parse trees
and SourcererCC [29] indexes large amounts of code into a
bag-of-tokens representation. Integrating such ideas into the
feature-based retrieval in DiffSearch could further improve
recall.

7 CONCLUSION
We present a scalable and precise search engine for code
changes. Given a query that describes code before and after
a change, the approach retrieves within seconds relevant ex-
amples from a corpus of a million code changes. Our query
language extends the underlying programming language
with wildcards and placeholders, providing an intuitive
way of formulating queries to search for code changes. Key
to the scalability of DiffSearch is to encode both queries
and code changes into a common feature space, enabling
efﬁcient retrieval of candidate search results. Matching these
candidates against the query guarantees that every returned
search result indeed ﬁts the query. The approach is mostly
language-agnostic, and we empirically evaluate it on Java,
JavaScript, and Python. DiffSearch answers most queries
in less than a second, even when searching through large
datasets. The recall ranges between 80.7% and 90.4%, de-
pending on the target language, and can be further in-
creased at the expense of response time. We also show that
users ﬁnd relevant code changes more effectively with Diff-
Search than with a regular expression-based search. Finally,
as an example of how the approach could help researchers,
we use it to gather a dataset of 74,903 code changes that
match recurring bug ﬁx patterns. We envision DiffSearch to
serve as a tool useful to both practitioners and researchers,
and to provide a basis for future work on searching for code
changes.

ACKNOWLEDGMENT
This work was supported by the European Research Coun-
cil (ERC, grant agreement 851895), and by the German
Research Foundation within the ConcSys and DeMoCo
projects.

REFERENCES

[1]

S. Negara, M. Codoban, D. Dig, and R. E. Johnson, “Mining ﬁne-
grained code changes to detect unknown change patterns,” in Pro-
ceedings of the 36th International Conference on Software Engineering,
2014, pp. 803–813.

[2] A. Habib and M. Pradel, “How many of all bugs do we ﬁnd? A

study of static bug detectors,” in ASE, 2018.

[4]

[3] C. Le Goues, M. Pradel, and A. Roychoudhury, “Automated
program repair,” Commun. ACM, vol. 62, no. 12, pp. 56–65, 2019.
[Online]. Available: https://doi.org/10.1145/3318162
S. H. Tan, J. Yi, Yulis, S. Mechtaev, and A. Roychoudhury,
“Codeﬂaws:
a programming competition benchmark for
evaluating automated program repair tools,” in Proceedings
of the 39th International Conference on Software Engineering, ICSE
2017, Buenos Aires, Argentina, May 20-28, 2017 - Companion Volume,
S. Uchitel, A. Orso,
IEEE
Computer Society, 2017, pp. 180–182.
[Online]. Available:
https://doi.org/10.1109/ICSE-C.2017.76

and M. P. Robillard, Eds.

[6]

[5] M. Motwani, M. Soto, Y. Brun, R. Just, and C. Le Goues, “Quality
of automated program repair on real-world defects,” IEEE Trans-
actions on Software Engineering, 2020.
J. Bader, A. Scott, M. Pradel, and S. Chandra, “Getaﬁx: Learning
to ﬁx bugs automatically,” in OOPSLA, 2019, pp. 159:1–159:27.
I. Rak-amnouykit, D. McCrevan, A. Milanova, M. Hirzel, and
J. Dolby, “Python 3 types in the wild: A tale of two type systems,”
in DLS, 2020.

[7]

[8] H. A. Nguyen, T. N. Nguyen, D. Dig, S. Nguyen, H. Tran,
in-the-wild, ﬁne-
and M. Hilton, “Graph-based mining of
semantic code change patterns,” in Proceedings of
grained,
the 41st International Conference on Software Engineering, ICSE 2019,
Montreal, QC, Canada, May 25-31, 2019, 2019, pp. 819–830. [Online].
Available: https://doi.org/10.1109/ICSE.2019.00089

Pradel,

and M.
study

attached:
Eghbali
[9] A.
empirical
bugs,”
An
35th IEEE/ACM International Conference on Automated Soft-
in
ware Engineering, ASE 2020, Melbourne, Australia, September 21-
25, 2020.
[Online]. Available:
https://ieeexplore.ieee.org/document/9286132

strings
software

string-related

2020, pp.

956–967.

IEEE,

“No

of

[10] B. Fluri, M. Wuersch, M. PInzger, and H. Gall, “Change distilling:
Tree differencing for ﬁne-grained source code change extraction,”
IEEE Transactions on software engineering, vol. 33, no. 11, pp. 725–
743, 2007.

[11] D. Kawrykow and M. P. Robillard, “Non-essential changes in
version histories,” in 2011 33rd International Conference on Software
Engineering (ICSE).
IEEE, 2011, pp. 351–360.

[12] K. Pan, S. Kim, and E. J. Whitehead, “Toward an understanding of
bug ﬁx patterns,” Empirical Software Engineering, vol. 14, no. 3, pp.
286–315, 2009.

[13] J. Lawall, Q. Lambert, and G. Muller, “Prequel: A patch-like query

language for commit history search,” 2016.

[14] S. Paul and A. Prakash, “A framework for source code search us-
ing program patterns,” IEEE Transactions on Software Engineering,
vol. 20, no. 6, pp. 463–475, 1994.

[15] S. K. Bajracharya, T. C. Ngo, E. Linstead, Y. Dou, P. Rigor,
P. Baldi, and C. V. Lopes, “Sourcerer: a search engine for open
source code supporting structure-based search,” in Companion
to the 21th Annual ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages, and Applications, OOPSLA 2006,
October 22-26, 2006, Portland, Oregon, USA, P. L. Tarr and W. R.
Cook, Eds. ACM, 2006, pp. 681–682.
[Online]. Available:
https://doi.org/10.1145/1176617.1176671

[16] X. Gu, H. Zhang, and S. Kim, “Deep code search,” in Proceedings
of the 40th International Conference on Software Engineering, ICSE
2018, Gothenburg, Sweden, May 27 - June 03, 2018, M. Chaudron,
I. Crnkovic, M. Chechik, and M. Harman, Eds. ACM, 2018, pp.
933–944.
[Online]. Available: https://doi.org/10.1145/3180155.
3180167

[17] S. P. Reiss, “Semantics-based code search,” in 31st International
Conference on Software Engineering, ICSE 2009, May 16-24, 2009,
Vancouver, Canada, Proceedings.
IEEE, 2009, pp. 243–253. [Online].
Available: https://doi.org/10.1109/ICSE.2009.5070525

[18] S. Luan, D. Yang, C. Barnaby, K. Sen, and S. Chandra, “Aroma:
Code recommendation via structural code search,” Proceedings of
the ACM on Programming Languages, vol. 3, no. OOPSLA, p. 152,
2019.

[19] K. Kim, D. Kim, T. F. Bissyand´e, E. Choi, L. Li, J. Klein, and Y. L.
Traon, “Facoy: a code-to-code search engine,” in Proceedings of the
40th International Conference on Software Engineering, 2018, pp. 946–
957.

12

[20] J.

“Fine-grained and accurate

F. Morandat, X. Blanc, M. Martinez,
source

and
Falleri,
code
M. Monperrus,
in ACM/IEEE International Conference on Auto-
differencing,”
mated Software Engineering, ASE ’14, Vasteras, Sweden - September
15 - 19, 2014,
[Online]. Available:
313–324.
2014,
https://doi.org/10.1145/2642937.2642982

pp.

[21] R. Rolim, G. Soares, L. D’Antoni, O. Polozov, S. Gulwani,
R. Gheyi, R. Suzuki, and B. Hartmann, “Learning syntactic
from examples,” in Proceedings of
program transformations
the 39th International Conference on Software Engineering, ICSE 2017,
Buenos Aires, Argentina, May 20-28, 2017,
404–415.
[Online]. Available: https://doi.org/10.1109/ICSE.2017.44

2017, pp.

[22] X. Gao, S. Barke, A. Radhakrishna, G. Soares, S. Gulwani,
A. Leung, N. Nagappan, and A. Tiwari, “Feedback-driven
semi-supervised synthesis of program transformations,” Proc.
ACM Program. Lang., vol. 4, no. OOPSLA, pp. 219:1–219:30, 2020.
[Online]. Available: https://doi.org/10.1145/3428287

[23] S. Erdweg, T. Szab ´o, and A. Pacak, “Concise, type-safe, and

efﬁcient structural difﬁng,” in PLDI, 2021.

[24] R. Paletov, P. Tsankov, V. Raychev, and M. T. Vechev, “Inferring
crypto API rules from code changes,” in Proceedings of the
39th ACM SIGPLAN Conference on Programming Language Design
and Implementation, PLDI 2018, Philadelphia, PA, USA, June 18-22,
2018, J. S. Foster and D. Grossman, Eds. ACM, 2018, pp. 450–464.
[Online]. Available: https://doi.org/10.1145/3192366.3192403
[25] T. Kamiya, S. Kusumoto, and K. Inoue, “Ccﬁnder: a multilinguistic
token-based code clone detection system for large scale source
code,” IEEE Transactions on Software Engineering, vol. 28, no. 7, pp.
654–670, 2002.

[26] Z. Li, S. Lu, S. Myagmar, and Y. Zhou, “CP-miner: Finding
copy-paste and related bugs in large-scale software code,” IEEE
Transactions on Software Engineering, vol. 32, no. 3, pp. 176–192,
2006.

[27] L. Jiang, G. Misherghi, Z. Su, and S. Glondu, “Deckard: Scalable
and accurate tree-based detection of code clones,” in 29th Interna-
tional Conference on Software Engineering (ICSE’07).
IEEE, 2007, pp.
96–105.

[28] C. K. Roy and J. R. Cordy, “Nicad: Accurate detection of near-
miss intentional clones using ﬂexible pretty-printing and code nor-
malization,” in 2008 16th iEEE international conference on program
comprehension.

IEEE, 2008, pp. 172–181.

[29] H. Sajnani, V. Saini, J. Svajlenko, C. K. Roy, and C. V. Lopes,
“Sourcerercc: Scaling code clone detection to big-code,” in Pro-
ceedings of the 38th International Conference on Software Engineering,
2016, pp. 1157–1168.

[30] A. Rice, E. Aftandilian, C. Jaspan, E. Johnston, M. Pradel, and
Y. Arroyo-Paredes, “Detecting argument selection defects,” in
Conference on Object-Oriented Programming, Systems, Languages, and
Applications (OOPSLA), 2017.
[31] A. Alali, H. H. Kagdi,

a
typical commit? A characterization of open source software
repositories,” in The 16th IEEE International Conference on Program
Comprehension, ICPC 2008, Amsterdam, The Netherlands, June 10-13,
2008, R. L. Krikhaar, R. L¨ammel, and C. Verhoef, Eds.
IEEE Computer Society, 2008, pp. 182–191. [Online]. Available:
https://doi.org/10.1109/ICPC.2008.24

I. Maletic,

“What’s

and J.

[32] D. Kawrykow and M. P. Robillard, “Non-essential changes
in version histories,” in Proceedings of the 33rd International
Conference on Software Engineering, ICSE 2011, Waikiki, Honolulu ,
HI, USA, May 21-28, 2011, R. N. Taylor, H. C. Gall, and
[Online].
N. Medvidovic, Eds. ACM, 2011, pp. 351–360.
Available: https://doi.org/10.1145/1985793.1985842

[33] M. Barnett, C. Bird,

J. Brunet, and S. K. Lahiri, “Helping
developers help themselves: Automatic decomposition of code
review changesets,” in 37th IEEE/ACM International Conference
on Software Engineering, ICSE 2015, Florence, Italy, May 16-24, 2015,
Volume 1, A. Bertolino, G. Canfora, and S. G. Elbaum, Eds.
IEEE Computer Society, 2015, pp. 134–144. [Online]. Available:
https://doi.org/10.1109/ICSE.2015.35

[34] K. Herzig, S.

Just, and A. Zeller, “The impact of

tangled
code changes on defect prediction models,” Empir. Softw.
Eng., vol. 21, no. 2, pp. 303–336, 2016.
[Online]. Available:
https://doi.org/10.1007/s10664-015-9376-6

13

Proceedings of the 2016 24th ACM SIGSOFT International Symposium
on Foundations of Software Engineering, 2016, pp. 511–522.

[55] R. Paletov, P. Tsankov, V. Raychev, and M. T. Vechev, “Inferring
crypto API rules from code changes,” in Proceedings of the 39th
ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2018, Philadelphia, PA, USA, June 18-22, 2018,
2018, pp. 450–464.

[56] R. Rolim, G. Soares, R. Gheyi, and L. D’Antoni, “Learning quick
ﬁxes from code repositories,” CoRR, vol. abs/1803.03806, 2018.
[Online]. Available: http://arxiv.org/abs/1803.03806

[57] X. D. Le, D. Lo, and C. Le Goues, “History driven
program repair,” in IEEE 23rd International Conference on Software
Analysis, Evolution, and Reengineering, SANER 2016, Suita, Osaka,
Japan, March 14-18, 2016 - Volume 1, 2016, pp. 213–224. [Online].
Available: https://doi.org/10.1109/SANER.2016.76

[58] M. Hashimoto, A. Mori, and T. Izumida, “Automated patch
extraction via syntax- and semantics-aware delta debugging on
source code changes,” in Proceedings of the 2018 ACM Joint Meeting
on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake
Buena Vista, FL, USA, November 04-09, 2018, 2018, pp. 598–609.
[Online]. Available: https://doi.org/10.1145/3236024.3236047
[59] B. B. Nielsen, M. T. Torp, and A. Møller, “Semantic patches for
adaptation of javascript programs to evolving libraries,” in 2021
IEEE/ACM 43rd International Conference on Software Engineering
(ICSE).

IEEE, 2021, pp. 74–85.

[60] R. P. L. Buse and W. Weimer, “Automatically documenting pro-
gram changes,” in Conference on Automated Software Engineering
(ASE). ACM, 2010, pp. 33–42.

[61] E. Giger, M. Pinzger, and H. C. Gall, “Comparing ﬁne-grained
source code changes and code churn for bug prediction,” in
Proceedings of the 8th Working Conference on Mining Software Reposi-
tories, 2011, pp. 83–92.

[62] T. Hoang, H. K. Dam, Y. Kamei, D. Lo, and N. Ubayashi,
“Deepjit: an end-to-end deep learning framework for just-in-
time defect prediction,” in Proceedings of the 16th International
Conference on Mining Software Repositories, MSR 2019, 26-27 May
2019, Montreal, Canada., 2019, pp. 34–45.
[Online]. Available:
https://doi.org/10.1109/MSR.2019.00016

[63] M. Wen, R. Wu, and S. Cheung, “Locus:

locating bugs
from software changes,” in Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engineering, ASE
2016, Singapore, September 3-7, 2016, 2016, pp. 262–273. [Online].
Available: https://doi.org/10.1145/2970276.2970359

[64] R. Wu, M. Wen, S. Cheung, and H. Zhang, “Changelocator:
locate crash-inducing changes based on crash reports,” Empirical
Software Engineering, vol. 23, no. 5, pp. 2866–2900, 2018. [Online].
Available: https://doi.org/10.1007/s10664-017-9567-4

[65] X. Wu, C. Zhu, and Y. Li, “Diffbase: A differential factbase for
effective software evolution management,” in ESEC/FSE, 2021.
[66] F. Grund, S. A. Chowdhury, N. Bradley, B. Hall, and R. Holmes,
“Codeshovel: Constructing method-level source code histories,”
in ICSE, 2021.

Luca Di Grazia is a PhD student in the De-
partment of Computer Science at the Univer-
sity of Stuttgart in Germany, advised by Michael
Pradel. His main research interests are code
evolution and maintenance, mining software
repositories, and program analysis.

[35] P. Pˆartachi, S. K. Dash, M. Allamanis, and E. T. Barr,
“Flexeme: untangling commits using lexical ﬂows,” in ESEC/FSE
’20: 28th ACM Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering, Virtual Event,
USA, November 8-13, 2020, P. Devanbu, M. B. Cohen, and
T. Zimmermann, Eds. ACM, 2020, pp. 63–74. [Online]. Available:
https://doi.org/10.1145/3368089.3409693

[36] J. Johnson, M. Douze, and H. J´egou, “Billion-scale similarity search

with gpus,” IEEE Transactions on Big Data, 2019.

[37] R. Karampatsis and C. A. Sutton, “How often do single-statement
bugs occur? the manysstubs4j dataset,” CoRR, vol. abs/1905.13334,
2019. [Online]. Available: http://arxiv.org/abs/1905.13334
[38] C. Sadowski, K. T. Stolee, and S. Elbaum, “How developers search
for code: a case study,” in Proceedings of the 2015 10th Joint Meeting
on Foundations of Software Engineering, 2015, pp. 191–201.

[39] M. Pradel and K. Sen, “DeepBugs: A learning approach to
name-based bug detection,” PACMPL, vol. 2, no. OOPSLA, pp.
147:1–147:25, 2018. [Online]. Available: https://doi.org/10.1145/
3276517

[40] V. Premtoon, J. Koppel, and A. Solar-Lezama, “Semantic code

search via equational reasoning,” in PLDI, 2020.

[41] S. Sachdev, H. Li, S. Luan, S. Kim, K. Sen, and S. Chandra,
“Retrieval on source code: a neural code search,” in Proceedings of
the 2nd ACM SIGPLAN International Workshop on Machine Learning
and Programming Languages. ACM, 2018, pp. 31–41.

[42] J. Cambronero, H. Li, S. Kim, K. Sen, and S. Chandra, “When deep
learning met code search,” in Proceedings of the 2019 27th ACM Joint
Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering, 2019, pp. 964–974.
[43] J. Lawall and G. Muller, “Coccinelle: 10 years of automated
evolution in the linux kernel,” in 2018 USENIX Annual Technical
Conference, USENIX ATC 2018, Boston, MA, USA, July 11-13, 2018,
H. S. Gunawi and B. Reed, Eds. USENIX Association,
2018, pp. 601–614. [Online]. Available: https://www.usenix.org/
conference/atc18/presentation/lawall

[44] L. Martie, A. v. d. Hoek, and T. Kwak, “Understanding the impact
of support for iteration on code search,” in Proceedings of the 2017
11th Joint Meeting on Foundations of Software Engineering, 2017, pp.
774–785.

[45] A. Sivaraman, T. Zhang, G. Van den Broeck, and M. Kim, “Active
inductive logic programming for code search,” in 2019 IEEE/ACM
41st International Conference on Software Engineering (ICSE).
IEEE,
2019, pp. 292–303.

[46] R. Sirres, T. F. Bissyand´e, D. Kim, D. Lo, J. Klein, K. Kim, and
Y. Le Traon, “Augmenting and structuring user queries to support
efﬁcient free-form code search,” Empirical Software Engineering,
vol. 23, no. 5, pp. 2622–2654, 2018.

[47] M. Hashimoto and A. Mori, “Diff/ts: A tool for ﬁne-grained
structural change analysis,” in WCRE 2008, Proceedings of the
15th Working Conference on Reverse Engineering, Antwerp, Belgium,
October 15-18, 2008, 2008, pp. 279–288.
[Online]. Available:
https://doi.org/10.1109/WCRE.2008.44

[48] N. Meng, M. Kim, and K. S. McKinley, “Systematic editing: gener-
ating program transformations from an example.” in PLDI, 2011,
pp. 329–342.

[49] ——, “Lase: locating and applying systematic edits by learning

from examples.” in ICSE, 2013, pp. 502–511.

[50] H. A. Nguyen, A. T. Nguyen, T. T. Nguyen, T. N. Nguyen, and
H. Rajan, “A study of repetitiveness of code changes in software
evolution,” in 2013 28th IEEE/ACM International Conference on
Automated Software Engineering (ASE).

IEEE, 2013, pp. 180–190.

[51] M. Tufano,

neural machine

J. Pantiuchina, C. Watson, G. Bavota,

and
changes
“On learning meaningful
D. Poshyvanyk,
Proceedings of the
via
translation,”
41st International Conference on Software Engineering, ICSE 2019,
Montreal, QC, Canada, May 25-31, 2019, 2019, pp. 25–36. [Online].
Available: https://dl.acm.org/citation.cfm?id=3339509

code

in

[52] V. B. Livshits and T. Zimmermann, “DynaMine: Finding common
error patterns by mining software revision histories,” in European
Software Engineering Conference and Symposium on Foundations of
Software Engineering (ESEC/FSE). ACM, 2005, pp. 296–305.
[53] S. Kim, E. J. W. Jr., and Y. Zhang, “Classifying software changes:
Clean or buggy?” IEEE Transactions on Software Engineering, vol. 34,
no. 2, pp. 181–196, 2008.

[54] A. T. Nguyen, M. Hilton, M. Codoban, H. A. Nguyen, L. Mast,
E. Rademacher, T. N. Nguyen, and D. Dig, “Api code recommen-
dation using statistical learning from ﬁne-grained changes,” in

14

Paul Bredl is a master student in Software En-
gineering at the University of Stuttgart. During
and after his bachelor studies he worked as a
software developer, maintaining and extending
enterprise systems.

Michael Pradel is a full professor at the Uni-
versity of Stuttgart. His research interests span
software engineering, programming languages,
security, and machine learning, with a focus on
tools and techniques for building reliable, efﬁ-
cient, and secure software.

