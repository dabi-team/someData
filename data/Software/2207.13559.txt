2
2
0
2

l
u
J

7
2

]

R
C
.
s
c
[

1
v
9
5
5
3
1
.
7
0
2
2
:
v
i
X
r
a

Balanced Encoding of Near-Zero Correlation for
an AES Implementation

Seungkwang Lee1 and Jeong-Nyeo Kim2,∗

1 Dept. Industrial Security, Dankook University (sk.cryptographic@dankook.ac.kr)
2 Dept. Information Security Research Division, ETRI (jnkim@etri.re.kr)

Abstract. Power consumption of a circuit can be exploited to recover
a secret key of a cryptographic algorithm. This technique is known as
power analysis, one of the well-known techniques of side-channel anal-
ysis. Many software countermeasures against power analysis present a
time-space trade-oﬀ. Masking and shuﬄing come at the cost of the exe-
cution time and the extreme use of run-time random number generators.
Internally encoded implementations of block ciphers, on the other hand,
require large memory space to store a set of lookup tables. While the
internal encoding is widely used in white-box cryptography, it has a se-
rious drawback. It cannot protect the secret key against power analysis.
In this paper, we propose a secure internal encoding method of an AES
implementation. Provided that the ﬁve inner rounds are left unprotected
because these are not subject to power analysis, the lookup tables are
approximately 232KB in size and the number of operations including
XORs and table lookups are about 1,000 in total. This is about half
the table size required by the white-box AES implementation, which is
vulnerable to power analysis, and is about three times the amount of
operations required by the straightforward AES implementation.

Keywords: Block cipher, AES, power analysis, internal encoding, countermea-
sure, white-box cryptography.

1

Introduction

In the gray-box model, software cryptographic implementations executed in un-
trusted environments can be attacked by exploiting side-channel information
such as timing or power consumption. Such information is highly likely to expose
a secret key, so an attacker can recover it from non-protected implementations
without the eﬀort of reverse engineering. Among many leakage sources of side-
channel information, the correlation to key-dependent intermediate values has
been exploited by various attacks. For example, power analysis including Dif-
ferential Power Analysis (DPA) [13] and Correlation Power Analysis (CPA) [8]
analyzes the correlation between the power consumption of the target computa-
tion and the corresponding hypothetical values. The attacker queries the software
implementation of a cryptographic primitive with arbitrary inputs and collects
power traces through physical interaction with an oscilloscope. For every pair of

 
 
 
 
 
 
2

the input and the subkey candidate to the target cryptographic function such as
SubBytes, the attacker computes the hypothetical value. The correct candidate
produces the correct hypothetical values which are strongly correlated to a par-
ticular point in the power traces because the power consumption is proportional
(or inversely proportional) to the data processed in the circuit. Here, DPA di-
vides the power traces into sets based on the hypothetical values and gets the
average traces of each set. If the subkey candidate is correct, a diﬀerential trace
then shows a noticeable peak at the points related to the target function. In the
case of CPA, the subkey is simply guessed by calculating a correlation between
hypotheses and each point in the traces.

The number of power traces required for successful power analysis depends
primarily on the power model and electronic noise. A power model such as a
bit model or a hamming weight model determines how to express the power
consumption of the target function. On the other hand, electronic noise is partly
generated in power measurement and is partly generated due to constant compo-
nents such as leakage current and transistor switching [19]. Generally speaking,
as the noise increases, the number of power traces required for key recovery in-
creases. Recently, several studies [7, 16, 22] have deﬁned another threat model
of computational analysis, in which an attacker can access a source code or an
executable of the target primitive. In this threat model, a computational trace
can be collected by observing the computations in memory without electronic
noise. Hence, the key-dependent intermediate values or the memory addresses
pertaining to read and write access are clearly revealed.

Computational analysis was originally adapted by Diﬀerential Computation
Analysis (DCA) [7], a non-invasive attack extracting the secret keys from a wide
range of diﬀerent white-box implementations [9, 10] without having to perform
a detailed reverse engineering of the target implementation. From the attacker’s
perspective, the noise-free computational traces have also contributed to DCA-
variant attacks such as Zero diﬀerence enumeration [2], collision attacks, mutual
information analysis [21], and bucketing attacks [27]. From the cryptographic
engineer’s perspective, on the other hand, the noise-free traces can be used to
evaluate the protection of secret keys against power analysis with the reduced
number of traces compared to classical power analysis and without an expensive
oscilloscope.

The common software countermeasures reducing the problematic correlation
are masking and operation shuﬄing. The basic idea of masking is to split every
sensitive variable s into d + 1 shares s0, . . . sd such that s0 ◦ s1 ◦ . . . ◦ sd = s,
where a group operation ◦ is the XOR ⊕ in most cases or is sometimes the
modular addition. Here, any subset of less than d + 1 shares or leakage signals
should be statistically independent of s. This is achieved by picking up the masks
s1, . . . , sd uniformly at random and by setting the masked variable s0 such that
s0 = s ◦ s1 ◦ . . . ◦ sd. Then d is called the masking order. Because the attack
cost of higher-order DPA exploiting d + 1 leakages grows exponentially with
the masking order [19], higher-order masking schemes can secure block-cipher
implementations.

3

The disadvantage of higher-order masking is that it is not eﬃcient when
recomputing a new S-box S(cid:48) which blinds the input and the output with random
masks. A second-order masked AES implementation takes more than 20 times
the execution time compared to the ﬁrst-order implementation [23]. Since the
ﬁrst-order masking can be broken by the second-order DPA with reasonable
eﬀorts, a practical approach for industrial practitioners is often to combine it
with shuﬄing [12].

Shuﬄing randomizes the sequence of independent operations for each exe-
cution of encryption. This spreads the leakage point of a key-sensitive variable
over t diﬀerent points. Provided that the sequence is shuﬄed uniformly at ran-
dom, then the signal-to-noise ratio of the instantaneous leakage on the sensitive
variable is reduced by a factor of t. Shuﬄing is easy to implement and less costly
than higher-order masking especially when applied to the S-box. However, the
combination of ﬁrst-order masking and shuﬄing is not suﬃciently secure against
advanced power analysis [25, 26].

It is noteworthy that the higher-order DCA [5] is reminiscent of higher-order
DPA attacks. This attack was developed to recover the secret key from the
masked and shuﬄed implementation by using computational traces. In addi-
tion, an algebraic DCA attack [4] has been proposed to break the linear masking
on the white-box implementation independently of the masking orders in the
white-box setting. In order to resist both computational and algebraic attacks, a
white-box masking scheme that combines linear and nonlinear components has
been proposed [24]. However, this masking technique is a hardware-based coun-
termeasure that is largely dependent on a run-time random number generator.
In general, masking schemes are costly in terms of run time and often lead to
the joint leakage. Although a masking technique can be customized into the pre-
computation tables of the white-box instances [15, 16], it is also costly in terms
of memory requirements.

In light of this, there is a clear need for a software-based and non-masking
countermeasure against power analysis in the gray-box setting. By doing so, the
software implementation of a block cipher in the low-cost device such as ID cards
can eﬀectively protect the secret key within limited resources. To achieve this
goal, we revisit the internal encoding for the table-based AES implementation.
The internal encoding was originally used in white-box cryptography to enhance
the table diversity and ambiguity [9, 10]. However, the high correlation that still
remains in the encoded intermediate values is the main cause of the vulnerabil-
ities of white-box cryptography to gray-box attacks [7, 22]. This vulnerability
has raised the need for balanced encoding methods.

In this paper, we primarily focus on ﬁnding the balanced encoding method.
Above all, we customize an 8-bit linear transformation in such a way to elimi-
nate the problematic correlation. Here we note that our linear transformation is
designed to use not only nonsingular but also singular matrices. This improves
on the table diversity and ambiguity. Because the linear transformation is un-
able to conceal zeros per se, the nonlinear transformation is partly used to hide
zeros. When an AES algorithm is implemented by using our encoding method,

4

the key can be protected from power analysis. The proposed AES implementa-
tion requires approximately 232KB of memory space for lookup tables and 1,000
operations including XORs and table lookups. Importantly, it is not dependent
on masking techniques and run-time random sources in the device.

The rest of the paper is organized as follows: Section 2 explains the basic
concepts of power analysis and the existing method of the internal encoding. In
Section 3, we propose our encoding method. In Section 4, we introduce our AES
implementation protected by the balanced encoding and analyze its performance
and cost. Section 5 shows the experimental results on calculating the correlation
between the lookup values and the hypothetical values. Section 6 summarizes
this paper.

2 Preliminaries

In this section, we ﬁrst introduce the well-known techniques of power analysis,
which is still one of the most prevalent ways for extracting secret keys from IC
cards. Using oscilloscopes in power analysis requires a large number of power
traces because the key-dependent information in the trace is not clear due to
the measurement noise. However, given the source code or executable of the tar-
get cipher, collecting computational traces from memory is more practical than
collecting power traces. It is important to notice that if the key is not extracted
from noise-free computational traces, it can be determined that the key is secure
against power analysis. To demonstrate the security of the proposed AES im-
plementation, we conduct experiments using computational traces in Section 5.
Therefore, we explain methods used to measure correlation in the experiments.
Lastly, we brieﬂy demonstrate the key leakage caused by the problematic corre-
lation in the existing method of internal encoding adapted to white-box cryp-
tography.

2.1 Power Analysis

Power analysis is a non-invasive attack to extract the key from low-cost devices
such as IC cards. In the gray-box model of power analysis, an attacker can se-
lect a plaintext and access the ciphertext. The attacker can also collect timing or
power consumption information related to the encryption operation. However, it
is not possible to access the internal resources of the computing environment to
observe or manipulate memory. Power consumption of IC cards is proportional
(or inversely proportional) to the Hamming weight (HW) of data processed in
the circuit [19]. Suppose that an attacker knows a correct subkey of the AES al-
gorithm. For a target operation like SubBytes, power consumption of a circuit is
then strongly correlated to the attacker’s hypothetical value at a point of power
traces. The following explains two fundamental techniques of power analysis,
Diﬀerential power analysis (DPA) and Correlation power analysis (CPA).

5

DPA is a statistical method for analyzing power consumption. A selection
function D(b, C, k∗) is deﬁned to compute a key-sensitive variable b, where C
is a ciphertext and k∗ is a subkey candidate. If k∗ is a wrong key candidate,
D will evaluate b correctly with a 1/2 probability. DPA records N power traces
V1..N [1..κ] consisting of κ points. Then the diﬀerential trace ∆D[j], where j
∈ [1, κ], is generated by computing the diﬀerence between the average of traces
for D(·) = 1 and D(·) = 0 as follows:

∆D[j] =

≈ 2

(cid:80)N

−

n=1 D(b, Cn, k∗)Vn[j]
(cid:80)N
n=1 D(b, Cn, k∗)
(cid:32) (cid:80)N
n=1 D(b, Cn, k∗)Vn[j]
(cid:80)M
n=1 D(b, Cn, k∗)

(cid:80)N

n=1(1 − D(b, Cn, k∗))Vn[j]
(cid:80)N
n=1(1 − D(b, Cn, k∗))
(cid:33)
n=1 Vn[j]
N

(cid:80)N

−

If k∗ is correct, D will be proportional to Vm[j], a sample point in the trace.
That point indicates power consumption of computing b. For this reason, a cor-
rect subkey will result in a noticeable peak in the diﬀerential trace, but it is
unlikely that the wrong key candidate will produce a spike.

CPA improves on DPA by taking advantage of leakage models such as the
HW. For K diﬀerent key candidates, let hn,k∗ be the hypothetical value for
the power estimation, where n ∈ [1, N ], and k∗ [0, K). A correlation between
hypothetical values and power traces can be obtained by the estimator r as
follows [19]:

rk∗,j =

(cid:113)(cid:80)N

(cid:80)N

n=1(hn,k∗ − h∗

k) · (Vn[j] − V [j])

n=1(hn,k∗ − h∗

k)2 · (cid:80)N

n=1(Vn[j] − V [j])2

,

k and V [j] are the sample means of h∗

where h∗
k and V [j], respectively. Like in the
case of DPA, a correct subkey makes a noticeable spike in the correlation plot.
As mentioned previously, each point of a power trace is also aﬀected by
electronic noise of power measurement as well as constant components such as
leakage currents and transistor switching. The noise has a signiﬁcant impact on
the number of power traces needed to recover the key. However, it is not neces-
sary to collect power traces if the source code or execution binary is available. In
this threat model, Diﬀerential computation analysis (DCA) [7] collects noise-free
computational traces consisting of read-write data or memory addresses accessed
by the software. Since the collected information has no noise, the computational
traces make CPA successful with fewer traces. In order to collect computational
traces during the encryption, dynamic binary instrumentation (DBI) tools in-
cluding Pin [18] and Valgrind [20] can be adapted.

Walsh transform can also quantify a correlation using only simple XOR and
addition if the intermediate values or computational traces can be collected [22].
To evaluate the security of software cryptographic implementations, the Walsh
transform can be inserted in the source code to calculate the correlation without
having to use DBI tools. By doing so, scanning every sample point of the traces is

6

not necessary. Compared to Pearson correlation coeﬃcients, the Walsh transform
consists of lightweight operations and shows the correlation as a natural number.

Deﬁnition 1. Let x = (cid:104)x1, . . ., xn(cid:105), ω = (cid:104)ω1, . . ., ωn(cid:105) be elements of {0, 1}n
and x·ω = x1ω1⊕. . .⊕xnωn. Let f (x) be a Boolean function of n variables. Then
the Walsh transform of the function f (x) is a real valued function over {0, 1}n
that can be deﬁned as Wf (ω) = Σx∈{0,1}n (−1)f (x)⊕x·ω.

Deﬁnition 2. Iﬀ the Walsh transform Wf of a Boolean function f (x1, . . . , xn)
satisﬁes Wf (ω) = 0, for 0 ≤ HW (ω) ≤ d, it is called a balanced d-th order
correlation immune function or an d-resilient function.

In Deﬁnition 1, Wf (ω) quantiﬁes a correlation between f (x) and x · ω, where
f (x) is the intermediate value and x · ω is the attacker’s hypothetical value; if
HW(ω) = 1, ω selects a particular bit of x. Here, f (x) acts as the computational
trace because it represents the noise-free intermediate value. Deﬁnition 2 explains
the criterion for a balanced ﬁrst-order correlation immune function such that
each bit of intermediate values has no correlation to any bit of hypothetical
values.

2.2 High Correlation in the Existing Encoding Method

So far, the internal encoding consisting of linear and nonlinear transformations
has been applied to white-box cryptographic implementations for block ciphers in
order to obfuscate key-dependent intermediate values. Unfortunately, the current
encoding method cannot hide the keys completely from power analysis [1, 14].
First, the linear combinations of intermediate values are highly correlated with
the intermediate values due to the key-dependent distribution. For example,
suppose that an 8-bit linear transformation is applied to 3 · x, where x is the
SubBytes output. Then the linear combination of the ﬁrst to ﬁfth bits of 3 · x
is always correlated to the ﬁrst bit of x. Second, the two 4-bit concatenated
nonlinear transformations show a limited confusion eﬀect on 8-bit values.

Let fi(·) denote the encoding on the MixColumns multiplication in the ﬁrst
round of a white-box implementation of an AES-128 algorithm (WB-AES) [9]. To
be speciﬁc, the MixColumns multiplication is performed between the SubBytes
output and the ﬁrst column of MixColumn matrix. Given the SubBytes output
x, fi∈[0,31](x) is an encoded 32-bit value of MixColumns multiplication. Fig. 1
illustrates the Walsh transform with ω = 8. Although the correct subkey has
Wf i = 0 at 30 bits out of 32 bits, the 6th and the 7th bits of f (·) are highly
correlated to the 4th LSB of x. Their Walsh transform scores are 128. In contrary,
the average of |Wf i| of the wrong key candidates was 13.07 (max = 52 and s.d
= 9.44). This gives us that the subkey can be recovered by power analysis with
an overwhelming probability.

Previously, the classical and customized masking techniques have been pro-
posed to solve this problem of the internal encoding [5, 15, 16]. The classical

7

Fig. 1: Walsh transform on the MixColumns multiplication in the ﬁrst round of
WB-AES. Black: correct subkey. Gray: wrong key candidates.

masking is however expensive in terms of computational costs and is not secure
against higher-order DPA attacks. On the other hand, the customized mask-
ing requires tens of megabytes for lookup tables, which cannot be stored in a
low-cost device. To address this problem, we propose a non-masking encoding
method that takes up less memory space for an AES-128 algorithm.

3 Proposed Encoding

Before going into depth on our balanced encoding, let’s start by explaining the
imbalances in the existing 8-bit linear transformation of a white-box AES im-
plementation. For x ∈ GF(28), let S(cid:96)(x) denote the SubBytes output multiplied
by (cid:96) ∈ {1, 2, 3}, the elements in the MixColumns matrix. Here, S(cid:96)(x, y) refers to
the y-th bit of S(cid:96)(x), where y ∈ [1, 8] (the MSB is the ﬁrst bit). The following
matrix S(cid:96) is deﬁned as

S(cid:96) =

1,2

2,2








1,1 S(cid:96)
S(cid:96)
2,1 S(cid:96)
S(cid:96)
...
...
S(cid:96)
8,1 S(cid:96)

8,2

1,256

2,256

. . . S(cid:96)
. . . S(cid:96)
. . .
· · · S(cid:96)

...

8,256








=








S(cid:96)(0, 1) S(cid:96)(1, 1)
S(cid:96)(0, 2) S(cid:96)(1, 2)

...

...

S(cid:96)(0, 8) S(cid:96)(1, 8)

. . . S(cid:96)(255, 1)
. . . S(cid:96)(255, 2)
. . .
· · · S(cid:96)(255, 8)

...








.

An asterisk often refers to either a row or a column. For example, S(cid:96)
i,∗ refers to
the i-th row, and S(cid:96)
∗,j refers to the j-th column of S(cid:96). If Mi,j is an 8 × 8 binary
invertible matrix, an 8-bit linear transformation with S(cid:96) is given by R(cid:96) = M ·S(cid:96).
Each row in R(cid:96)
i,∗ is then computed by the XOR operations between the selected
rows in S(cid:96); if Mi,j = 1, S(cid:96)

j,∗ is XORed to compute R(cid:96)
i,∗

0501000102030iWfi8

By Deﬁnition 2, for random integers i, i(cid:48) ∈ [1,8] and (cid:96), (cid:96)(cid:48) ∈ [1,3], the balanced

linear transformation must satisfy the Walsh transform as follows:

(−1)R(cid:96)

i,j ⊕S(cid:96)(cid:48)

i(cid:48) ,j = 0.

255
(cid:88)

j=0

(1)

i,∗ ⊕ S(cid:96)(cid:48)

In other words, this implies HW(R(cid:96)
key-dependent distribution of S(cid:96), however, leads to HW(R(cid:96)
results in the Walsh transform value 256, with an overwhelming probability.

i(cid:48),∗) = 128. As pointed out in [14], the
i,∗ ⊕ S(cid:96)(cid:48)
i(cid:48),∗) = 0, which

Table 1 lists V and W, the row index of S(cid:96)(cid:48)

and the sets of the row indexes
of S(cid:96), respectively, producing the Walsh transform value of 256 for each pair of
((cid:96), (cid:96)(cid:48)). The ﬁrst row of the table means that if (cid:96) = (cid:96)(cid:48), the Walsh transform value
would be 256 only if the j-th row from S(cid:96) and S(cid:96)(cid:48)
was selected, where j ∈ [1, 8].
For ((cid:96), (cid:96)(cid:48)) = (2, 1), for example, suppose that R2 contains a row computed by
a linear combination of the 7- and 8-th rows of S2. This row is then identical to
the 8th bit of S1. In other words, this linear transformation is unable to protect
R2 from an attacker calculating a correlation using the 8th bit of S1.

Considering AddRoundKey performed before SubBytes, a subkey k will be
added to the input x of S(·). Here, it is easy to know that S(x ⊕ k) can by
expressed by a permutation of columns in S(cid:96) and S(cid:96)(cid:48)
. Thus, the same row indexes
listed in Table 1 will lead to the same results even after k is added to x.

3.1 Basic Idea

Overall, our encoding protects a byte using a customized 8-bit linear transfor-
mation and a simple nibble encoding. To be balanced, the linear transformation
must generate a matrix M that does not contain the row indexes listed in Ta-
ble 1. Previously, the linear transformation has adapted only invertible matrices
to guarantee its inverse transformation. However, using only binary invertible
matrices, after excluding those row indexes, reduces the table diversity. To solve
this problem, our linear transformation is designed to adapt singular matrices
as well as nonsingular ones. It is noteworthy that this proposed linear trans-
formation is capable of decoding, i.e., inverse transformation, even though both
singular and nonsingular matrices are utilized. The following explains the pro-
posed 8-bit linear transformation consisting of 4-bit transformations. In addition,
the 4-bit nonlinear transformations, often called the nibble encoding, are partly
used to hide the value of 0.

Notation. For 8-bit binary vectors X, Y, Z, the superscripts H and L represent
their upper 4 bits and lower 4 bits, respectively. Thus, X = XH||XL. The en-
coding is denoted by E, consisting of the linear and nonlinear transformations,
denoted by L and N , respectively. By abuse of notation, N H denotes the nibble
encoding for the upper 4 bits whereas N L denotes for the lower 4 bits of the
input. The subscripts to N are used to indicate diﬀerent nibble encodings. The
decoding is denoted by D. Let denote two sets of 4 × 4 binary matrices by F

Table 1: The row indexes of S(cid:96) of which the XOR result becomes a row of S(cid:96)(cid:48)

.

9

(cid:96)

i

(cid:96)(cid:48)

i

1

2

1

3

2

1

2

3

3

1

3

2

V

j

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

W

{j}

{2}
{3}
{4}
{1, 5}
{1, 6}
{7}
{1, 8}
{1}

{1, 2}
{2, 3}
{3, 4}
{1, 4, 5}
{1, 5, 6}
{6, 7}
{1, 7, 8}
{1, 8}

{8}
{1}
{2}
{3}
{4, 8}
{5, 8}
{6}
{7, 8}

{1, 8}
{1, 2}
{2, 3}
{3, 4}
{4, 5, 8}
{5, 6, 8}
{6, 7}
{7}

{1, 2, 3, 4, 5, 6, 7, 8}
{2, 3, 4, 5, 6, 7, 8}
{3, 4, 5, 6, 7, 8}
{4, 5, 6, 7, 8}
{1, 2, 3, 4}
{6, 7, 8}
{7, 8}
{1, 2, 3, 4, 5, 6, 7}

{2, 3, 4, 5, 6, 7, 8}
{3, 4, 5, 6, 7, 8}
{4, 5, 6, 7, 8}
{5, 6, 7, 8}
{1, 2, 3, 4, 5}
{7, 8}
{8}
{1, 2, 3, 4, 5, 6, 7, 8}

10

and G, which are chosen under the certain conditions explained in the following.
f $←− F means a random sampling from F. Idx (v) is deﬁned to be a function:
Idx (v) = {i | vi = 1 for i ∈ [1, 8]}, where v is an 8-bit binary vector. For exam-
ple, {1, 5, 6} ← Idx ([1, 0, 0, 0, 1, 1, 0, 0]).

3.2 Balanced Linear Transformation

Suppose f and g are the elements randomly chosen from F and G, respec-
tively. For an 8-bit vector X = XH||XL, the proposed linear transformation
Z = L(X, f, g) is deﬁned as follows:

ZH = XH ⊕ (f · XL)
ZL = XL ⊕ (g · ZH),

where · implies multiplication. This can be represented by M · X, using an 8×8
matrix M deﬁned as follows:

(cid:21)

(cid:20) I4
g

f
I4 ⊕ g · f
During the computation of L, if M∗,i =1, the i-th row of X is to be XORed.
The balance can be achieved by using binary vectors fi,∗ that are not listed
in Table 1, where i ∈ [1, 4]. Let BF
i denote the blacklist, i.e., the set of binary
vectors that must not appear to the i-th row of f ∈ F. There exist 27,000
(=10×15×15×12) binary matrices in F such that Fi,∗ (cid:54)∈ BF
i .

.

After f $←− F, g is randomly picked from G and is checked if Idx (gi,∗||(I4 ⊕
g · f )i,∗) ∈ W listed in Table 1. Our exhaustive search found that a total of
1,098,661,500 (> 230) pairs of (g, f ) satisﬁes

Idx(gi,∗||(I4 ⊕ g · f )i,∗) (cid:54)∈ W.

In other words, our linear transformation guarantees the table diversity consist-
ing of more than 230 pairs of (g, f ) producing the Walsh transform value of 0.
For each f , the average numbers of row vectors at g1,∗, g2,∗, g3,∗, and g4,∗ are
approximately 14, 13.6, 14.2, and 14.6, respectively.

For four 8-bit values X1, X2, X3, and X4, let Y and Z stand for the followings:

Y =

4
(cid:77)

i=1

Xi and Z =

4
(cid:77)

i=1

L(Xi, f, g),

where Z = Z H ||Z L = L(Y H ||Y L, f, g). Then, the inverse of the linear transfor-
mation is accomplished by Y = L−1(Z, f, g):

Y L =Z L ⊕ (g · Z H )
Y H =Z H ⊕ (f · Y L)

Y =Y H ||Y L.

11

Table 2: The set of vectors that should be ﬁltered out at the i-th row of F .

i

1

2
3
4

BF
i

{[0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 0 ],
[0, 0, 0, 1 ],[1, 1, 0, 0 ],[0, 0, 1, 1 ] }
{[0, 0, 0, 0]}
{[0, 0, 0, 0]}
{[0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]}

Importantly, L remains to be balanced during the XOR operations in Mix-
Columns for the following reason. Let (cid:96)1, (cid:96)2, (cid:96)3, (cid:96)4 be four coeﬃcients of a row
in the MixColumns matrix. For the ﬁrst row, these are 2, 3, 1, and 1 in order.
Each byte in the state matrix after MixColumns is obtained by the XOR sum
of four bytes selected from S(cid:96)1, S(cid:96)2 , S(cid:96)3, and S(cid:96)4. Let v be an XOR sum of
three arbitrary columns selected from S(cid:96)1, S(cid:96)2, and S(cid:96)3 . To explain the balanced
transformation by L on the XOR computation, we deﬁne an 8 × 256 lookup
tables S as follows:

S∗,j = S(cid:96)4

∗,j ⊕ vT , for 1 ≤ j ≤ 256.

Then, it is easy to see that S can be considered a permutation of columns in S(cid:96)(cid:48)
Without loss of generality, R = M · S. If Equation 1 is true, then

.

255
(cid:88)

j=0

(−1)Ri,j ⊕Si(cid:48) ,j = 0.

(2)

It also implies that HW(Ri,∗ ⊕ Si(cid:48),∗) = 128. This gives us that the protection
of L on MixColumns does not produce intermediate values which are highly
correlated to the correct hypothetical value of it.

3.3 Nibble Encoding for Hiding Zeros

Because of the balance provided by L, all intermediate values have no prob-
lematic correlation to the correct hypothetical values before applying nibble
encodings. For this reason, the use of nibble encoding is restricted to hide the
value of 0, which cannot be hidden by multiplication. Simply speaking, each
nibble encoding swaps the value 0 with e ∈ [0, 0xF ], whereas the other values
remains the same. The focus is on ﬁnding a candidate e, keeping the balance in
the encoding.

Fig. 2 shows graphical representation of two nibble encodings applied to R(cid:96).
In the upper and lower 4 bits, every four-bit chunk from 0 to 0xF appears exactly
16 times because of the balance by L. Let denote two candidates to be swapped
in the upper and the lower four bits by eH and eL, respectively. In other words,
the upper (resp. the lower) nibble encoding performs 16 swaps between 0 and

12

Fig. 2: Swapping zeros in N on R(cid:96).

eH (resp. eL). Let J H
equal to zero, and let J H
equal to e as follows:

0 be a set of column indices with the upper four bits of R(cid:96)
e be a set of column indices with the upper four bits

J H
0 ={j|R(cid:96)
J H
e ={j(cid:48)|R(cid:96)

1,j||R(cid:96)
1,j(cid:48)||R(cid:96)

2,j||R(cid:96)
2,j(cid:48)||R(cid:96)

3,j||R(cid:96)

4,j = 0}

3,j(cid:48)||R(cid:96)

4,j(cid:48) = e}

(3)

For the upper 4-bit nibble encoding N H , a candidate eH must satisfy the fol-
lowing conditions to provide the ﬁrst-order balanced encoding:

(cid:88)

S(cid:96)(cid:48)
i,j =

(cid:88)

S(cid:96)(cid:48)
i,j(cid:48)

j∈J H
0

j(cid:48)∈J H
e

for all (cid:96)(cid:48) ∈ {1, 2, 3} and 1 ≤ i ≤ 8.

Here, it is worthy noting that the balance must be investigated for all (cid:96)(cid:48) ∈ {1,2,3}
since a single matrix M will be used to protect S1, S2, and S3 (see Section 4).
Similarly, we deﬁne

J L
0 ={j|R5,j||R6,j||R7,j||R8,j = 0}
e ={j(cid:48)|R5,j(cid:48)||R6,j(cid:48)||R7,j(cid:48)||R8,j(cid:48) = e}
J L

(4)

For the lower 4-bit nibble encoding N L, a candidate eL must satisfy the following
conditions:

(cid:88)

S(cid:96)(cid:48)
i,j =

(cid:88)

S(cid:96)(cid:48)
i,j(cid:48)

j∈J L
0

j(cid:48)∈J L
e

for all (cid:96)(cid:48) ∈ {1, 2, 3} and 1 ≤ i ≤ 8.

A more graphical way of representing the implication is illustrated in Fig. 3. 0
can be swapped with eH if the HW of every column in J H
e are the same
for each row of S(cid:96)(cid:48)
. Also, eL can be found in the same manner using column
e . By using 100 diﬀerent pairs of (f, g), R(cid:96)∈{1,2,3}
indices belonging to J L
was constructed and was then encoded by a pair of nibble encodings. We found
that an average of 12.48 candidates (min: 2, max: 16) provides the balance for
each nibble encoding.

0 and J H

0 and J L

0eL0eH13

Fig. 3: eH can be a candidate if the same HW holds at every row after swaps.

4 Protected AES-128

From now on, we describe a secure design of AES with a 128-bit key protected
by our balanced encoding. Overall, this is inspired by a white-box cryptographic
implementation of AES [9], which is mainly composed of a series of internally
encoded lookup tables. Our focus is, however, on protecting against DPA-like
attacks which take advantage of correlation to the key-dependent intermediate
values. In other words, the rest of gray- and white-box attacks such as cryptanal-
ysis and fault injection are not taken into account. Thus, the proposed structure
is not as heavyweight as a white-box implementation.

4.1 Threat Model

We clarify the threat model as follows. Above all, an attacker has no access to
the internal computing resource in the device. This non-invasive attacker can
obtain the input and output of encryption and can collect power traces. When
conducting power analysis, the target hypothetical values against the table-based
implementation of AES are one of the followings.

First, the most common hypothetical value is the output of MixColumns mul-
tiplication. More speciﬁcally, it is the result of multiplication of the SubBytes
output with one of the three coeﬃcients in the MixColumns matrix. Second, the
partial or three XOR operations between four bytes from MixColumns multipli-
cation can be attacked. Here we note that the three XORs compute a subbyte
of the round output.

Ironically, the low correlation provided by the proposed encoding increases
the probability that the lowest-ranked key is the correct key as a result of power
analysis. To solve this problem, we explain a method of deliberately raising the
ranking of correct subkeys in the power analysis results.

............ithrowHW (red columns) = HW (blank columns) at the ithrow14

4.2 Design

The following describes a rearrangement of AES-128 by which a series of lookup
tables is generated. By shifting the initial AddRoundKey into the ﬁrst round and
by applying ShiftRows to the round key (except the ﬁnal round key), AES-128
can be described concisely as follows:

state ← plaintext
for r = 1 · · · 9

ShiftRows(state)
AddRoundKey(state, ˆkr−1)
SubBytes(state)
MixColumns(state)

ShiftRows(state)
AddRoundKey (state, ˆk9)
SubBytes(state)
AddRoundKey(state, k10)
ciphertext ← state,

where kr is a 4 × 4 matrix of the r-th round key, and ˆkr is the result of applying
ShiftRows to kr. By doing so, AddRoundKey can combine with SubBytes before
multiplying each column of the MixColumns matrix for the ﬁrst - ninth rounds.
Let T-boxes be an 8×8 lookup table deﬁned as

i,j(p) = S(p ⊕ ˆkr−1
T r
i,j ),
i,j (p) = S(p ⊕ ˆk9
i,j) ⊕ k10
T 10

i,j for i, j ∈ [1, 4],

for i, j ∈ [1, 4] and r ∈ [1, 9],

where p is a subbyte of state.
Let [x1 x2 x3 x4]T be a column vector of state after looking up T-boxes. Each
subscript of x implies the row index of the subbyte. The precomputation of
multiplying xi with a column vector of the MixColumns matrix is given by the
U r

i,j tables as follows:

U r
U r
U r
U r

1,j(x1) = x1 · [02 01 01 03]T
2,j(x2) = x2 · [03 02 01 01]T
3,j(x3) = x3 · [01 03 02 01]T
4,j(x4) = x4 · [01 01 03 02]T ,

where j is the column index of the vector.
The next step is to make a composition U ◦ T , say U T , mapping each subbyte of
the plaintext to the MixColumns multiplication. Because the ﬁrst key-dependent
intermediate value, after running encryption, is exposed by looking up the U T
table, its output must be encoded. Let denote them by

U T r

i,j(xi) = [yi,1 yi,2 yi,3 yi,4]T .

In order to apply L on the four bytes of a column vector above, four sets of
(f, g) are required; therefore each round uses 16 sets in total. The subscripts

15

j,k are used to index a set pertaining to L, where j is a column index and k ∈
{1, 2, 3, 4}. yi,k is then encoded by Lj,k(yi,k, fj,k, gj,k). The structure of lookup
tables precomputing the operations up to the MixColumns multiplication are
simply depicted in Fig. 4. Note that the second round begins with the decoding
of the ﬁrst round output whereas the ﬁrst round does not have to decode the
plaintext. Through out this paper, we assume that the nibble encoding (blank
squares in Fig. 4) is always applied to every boundary of lookup tables.

(a) The ﬁrst round

(b) The second round

Fig. 4: Internal structure of U T computing up to MixColumns multiplication. A
blank squre is a nibble encoding.

Fig. 5 illustrates a simple description of lookups from state to the ﬁrst round
output. For each column of state, U T takes a byte and provides a 4-byte vector
of the MixColumns multiplication. The intermediate values after looking up U T
can be placed in a 4×4×4 array.
The next step is to combine the encoded results of MixColumns multiplication
into the round output by conducting XOR operations. Since the nibble encoding
swaps zeros with unknown values, every XOR operation depicted by ⊕ in Fig. 5
must be performed by looking up the XOR tables, denoted by T x. An instance

T1i,jLj,1Lj,2Lj,3Lj,4U1i,jTri,jUri,jLi,j (cid:2)(cid:3)Lj,1Lj,2Lj,3Lj,416

of T x is generated by using three nibble encodings to decode two 4-bit inputs
and to encode a 4-bit output. Due to the distributive property of multiplication
over XOR, L does not have to be decoded in this process. The ﬁnal round does
not involve MixColumns, and thus T 10 is not composed with U . Because its
outputs make a ciphertext, T 10 does not encode the output.

Fig. 5: Overall table lookups of a column vector in state. A diﬀerent color of the
box means a diﬀerent set of (f, g). ⊕ will be conducted by looking up the XOR
tables T x.

Let Q0 denote the set of tables above, protected by the proposed encoding.
As previously pointed out, we need another set of lookup tables, say Q1, so
that the correct key does not show the lowest correlation as a result of power
analysis. Here, Q1 is simply generated by ﬂipping the input and output bits of
Q0. By doing so, Q1 can also provide the balanced encoding on the encryption
of a plaintext. In order to eﬀectively protect the key from power analysis, the
balance must be broken to some extent. So, a plaintext is encrypted by using Q0
with probability α and by using Q1 with probability 1 − α. Let {b1, b2 · · · bn} be
a sequence of binary numbers where bi = 0 or 1 such that (cid:80)n
i=1 bi = n × α. If a
random number generator is available in the device, each encryption begins by
picking up i ∈ [1, n] at random and encrypts a plaintext using Qbi. If α = 1/2, a
binary number, say b, may be simply generated to choose Qb. In this case, this is
the only operation that the encryption depends on the run-time random number
generator. Otherwise, based on the fact that power analysis uses uniformly-
distributed plaintexts, i can be derived from plaintexts. For example, if n is
unknown and less than 256, an XOR sum of every subbyte of the plaintext (mod
n) can be used to choose i. By doing so, the encryption becomes independent of
run-time random sources.

P1P2P3P4¯¯¯=UT1,1 UT2,1 UT3,1 UT4,1 17

4.3 Costs

From the 1st to 2nd rounds, the size and the number of lookups of the table
are only half compared to a white-box AES implementation [9]. This is because
we do not protect the intermediate values by a 32-bit linear transformation
which is replaced with four 8-bit transformations. Only the ﬁrst and the last two
MixColumns are protected against the non-invasive power analysis, and thus the
proposed encoding is applied to those ﬁve outer rounds. During the encryption
operation, one byte must pass through two MixColumns to be aﬀected by all
the bits in the key. For the inner rounds (from the 3rd to the 7th rounds) a
straightforward AES implementation is adapted.
Table 3 shows the table size of the number of lookups for the outer rounds. Here,
the additional memory consumption including the S-box and the rest of round
keys required for the inner-round operations is negligible and therefore gives
approximately 116KB of the table size. Because the size of Q0 and Q1 are the
same, the total size is about 232KB. In addition, approximately 400 operations
including lookups and XORs are required for the inner rounds and thus about
1,000 operations are needed in total. Simply put, the additional cost for applying
the proposed encoding is mainly imposed by the lookup tables of the protected
rounds. From the practical point of view, each execution of encryption does not
need to generate random numbers and a new set of masked tables.

Table 3: Table size and lookups of the ﬁve outer rounds protected by the proposed
encoding.

Size (bytes)

# of lookups

U T
T x
T 10

44 × 256 = 65,536
43 × 3 × 2 × 128 = 49,125
42 × 256 = 4,096

43 = 64
43 × 3 × 2 = 384
43 = 64

Total

118,757 (approx. 116KB)

512

5 Experimental Results

Our experiments can be divided into two parts. First, we demonstrate the bal-
anced encoding using only Q0. To that end, the UT outputs and the round
outputs were analyzed. We measured how much they correlate with the correct
hypothetical values through the Walsh transforms and the DCA attacks. Second,
we show that there is an increase in the correlation coeﬃcients when using either
Q0 or Q1 with a 1/2 probability. As mentioned before, it has the same eﬀect as
the increase in encoding imbalance. By doing so, the correct subkey does not
lead to the lowest correlation.

18

5.1 Analysis of the UT Outputs

To demonstrate the eﬀect of the balanced encoding on the UT outputs, we pro-
vide the following experimental results. First, the correlation of the UT outputs
to the hypothetical values was investigated in the ﬁrst round. Speciﬁcally, the
hypothetical values guess the results of MixColumns multiplication, i.e., the Sub-
Bytes outputs multiplied by 1, 2, or 3. In the following, we take a close look at
U T 1
0,0, a slice of the UT table mapping the ﬁrst subbyte of a plaintext to the
MixColumns multiplication in the ﬁrst round. The Walsh transforms Wt(cid:96)(cid:48)
is
deﬁned:

Wt(cid:96)(cid:48)(i(cid:48)) =

255
(cid:88)

(−1)U T 1

0,0(j)i⊕S(cid:96)(cid:48)

i(cid:48) ,j .

(5)

j=0

Here, Wt(cid:96)(cid:48) tells us how much the lookup values of U T 1
0,0 and the hypothetical
SubBytes output multiplied by (cid:96)(cid:48) ∈ {1, 2, 3} are correlated. For every single bit
of the correct hypothetical values, all of the Walsh transforms give 0 as a result
of the balanced encoding as shown in Fig. 10 - Fig. 12 in Appendix A. Fig. 6
shows a small part of the results obtained by the hypothetical values — the ﬁrst
bit of the SubBytes output multiplied by 1, 2, and 3.
This balanced encoding has an inﬂuence on the result of DCA attacks using the
hypothetical SubBytes output. In order to illustrate it, 10,000 computational
traces of encryption using 10,000 random plaintexts were collected by using
Valgrind. Table 4 shows the DCA result based on the SubBytes output. All
correct subkeys ranked the lowest out of eight attacks at least once. Table 5
compares the highest correlation coeﬃcient from all key candidates and the
coeﬃcient from the correct key. When the computational traces are composed
of only the UT outputs, the DCA results and the corresponding correlation
coeﬃcients are shown in Table 10 and Table 11 in Appendix B, respectively.
This shows the proposed encoding addresses the correlation problem caused by
the existing encoding method. These two experiments were carried out to show
there is no problematic correlation between the encoded lookup values and the
correct values of S(cid:96)(cid:48)∈{1,2,3}.

Table 4: DCA ranking on the AES encryption using only Q0 when conducting
mono-bit CPA on the SubBytes output with 10,000 computational traces.

(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)

TargetBit

Subkey

1
2
3
4
5
6
7
8

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

76 249 13

161 254 247 250 256 249 250 256 167 236 250 166 211 251 253 189
253 249 256 249 203 256 251 230 253 256 255 256 230 256 256 256
21 185 136 225 199 185 24 209 183 59
29 210 18 168 235 255
75
70 158 251 52 248 190 63 124 108 171 136 239
252 253 256 243 256 256 256 256 256 245 228 216 249 251 253 255
210 138 253 241 206 161 243 256 125 219 256 247 256 120 100 90
256 118 249 192 68 162 235 158 167 158 119 252 118 180 230 241
213 256 256 256 254 248 252 254 252 234 253 256 256 239 207 125

19

(a) With respect to the SubBytes output

(b) With respect to the SubBytes output multiplied by 2

(c) With respect to the SubBytes output multiplied by 3

Fig. 6: Walsh transforms on the MixColumns multiplication obtained by Q0.
Black: correct subkey. Gray: wrong key candidates.

01020300102030iWt101020300102030iWt201020300102030iWt320

Table 5: Highest correlation of all key candidates vs. highest correlation of the
correct subkeys when conducting the DCA attacks on the UT output obtained
by Q0.

1

Subkey
Highest 0.166 0.163 0.164 0.159 0.155 0.170 0.154 0.155 0.156 0.166 0.165 0.160 0.170 0.160 0.156 0.158
0.141 0.132 0.129 0.142 0.132 0.127 0.139 0.135 0.129 0.134 0.139 0.130 0.144 0.130 0.132 0.132

Key

14

12

13

11

10

15

16

2

4

3

6

9

5

7

8

With α = 1/2, the probability that a plaintext is encrypted with Q0 or Q1 is
the same. The next experiments are almost the same with the previous ones,
except that Q0 and Q1 were selected with a 1/2 probability for each encryption.
In other words, the Walsh transforms were calculated by using the UT lookup
values from Q0 and Q1. All of the results are provided in Fig. 14 - Fig. 16 in
Appendix A, and Fig. 7 shows one of them. The hypothetical value was, like
in the case of the previous experiments, the ﬁrst bit of the SubBytes output
multiplied by 1, 2, and 3. There was an increase in the encoding imbalance by
which the correct subkey does not lead to the lowest correlation to the correct
hypothetical values.
The encoding imbalance shown in the results of the Walsh transforms above
improves the protection of keys against DCA attacks searching for either the
highest- or lowest-ranking subkey candidate. While the correct subkeys are in
the lowest rank in Table 4, those are not in the highest or lowest ranks as shown
in Table 6 when a plaintext was encrypted by looking up Q0 or Q1 with a
1/2 probability. Compared to Table 5, the gap between correlation coeﬃcients
computed by the correct and wrong subkeys are reduced as shown in Table 7.

Table 6: DCA ranking on the AES encryption using Q0 or Q1 with a 1/2 prob-
ability when conducting mono-bit CPA on the SubBytes output with 10,000
computational traces.

(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)

TargetBit

Subkey

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

1
2
3
4
5
6
7
8

4

54
66

64 102 28 131 67

48
51
172 62
65

41 199 145 53
71 211 62 132 94 239 213 99
34
76 230 244 153 95
57
133 146 210 214 74
94 254 96
51 234 124 192 180 144 186 27
18
67
4

19 218
15 245 42
21
18 135
53
71 252 219 112 125
86 200 181 232 211 250 201 191
36 212 78 237 147 238 197
63
93 234 93
52 100 187
38
37
85 188 128 161 145 15 111
38 177 143 64
238 252 135 212 100 182 174 46 127

57 126 117 199 38
70
66

150 120 136 27 110 49

62

88

54

10

5

3

5.2 Analysis of the Round Outputs

The encoded round output of the ﬁrst round was analyzed so that the balance
in the encoding applied to the round output can be investigated. Let p1 and p2

21

(a) With respect to the SubBytes output

(b) With respect to the SubBytes output multiplied by 2

(c) With respect to the SubBytes output multiplied by 3

Fig. 7: Walsh transforms on the MixColumns multiplication obtained by Q0 and
Q1. Black: correct subkey. Gray: wrong key candidates.

02040600102030iWt102040600102030iWt202040600102030iWt322

Table 7: Highest correlation of all key candidates vs. highest correlation of the
correct subkeys when conducting the DCA attacks on the UT output obtained
by Q0 or Q1 with a 1/2 probability.

1

Subkey
Highest 0.043 0.043 0.044 0.043 0.040 0.043 0.045 0.038 0.039 0.042 0.042 0.042 0.043 0.046 0.038 0.042
0.037 0.027 0.032 0.030 0.024 0.027 0.035 0.023 0.026 0.028 0.033 0.031 0.027 0.029 0.029 0.023

Key

12

14

16

10

11

13

15

2

3

4

6

8

5

7

9

denote the ﬁrst two byte of the plaintexts. When the remaining 14 bytes are
ﬁxed to 0, the ﬁrst byte of the ﬁrst round output can be expressed as follows.

δ(p1, p2) = S2(p1 ⊕ ˆk0

0,0) ⊕ S3(p2 ⊕ ˆk0

1,0) ⊕ c,

(6)

where c is a constant. For simplicity, (cid:15) represents the encoding applied to δ. Then,
the ﬁrst subbyte of the ﬁrst round output protected by the proposed encoding
can be written by (cid:15) ◦ δ(p1, p2). If we assume that the attacker knows ˆk0
0,0, the
corresponding hypothetical value is given by

γ(p1, p2) = S2(p1 ⊕ ˆk0

0,0) ⊕ S3(p2 ⊕ k∗),

(7)

where k∗ is the key candidates. Let the subscripts i and i(cid:48) denote the i- and i(cid:48)-th
bits, respectively. For a ﬁxed p1 and the correct key candidate, by Equation (2),
we expect

255
(cid:88)

p2=0

(−1)(cid:15)◦δ(p1,p2)i⊕γ(p1,p2)i(cid:48) = 0.

Thus, the Walsh transform W(cid:15)γ is deﬁned:

W(cid:15)γ(i(cid:48)) =

255
(cid:88)

p1=0

255
(cid:88)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
p2=0

(−1)(cid:15)◦δ(p1,p2)i⊕γ(p1,p2)i(cid:48)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

.

(8)

(9)

To see the eﬀect of the balance in the encoded round output, we calculated
W(cid:15)γ for all i, i(cid:48) ∈ [1, 8]. As a result, the correct subkey always produced zeros
on the Walsh transforms as illustrated in Fig. 13 in Appendix A, and Fig. 8
shows one of the results in the case of i(cid:48) = 1. Only the correct subkey (0x55)
scores 0 for all i ∈ [1, 8]. We also collected 10,000 computational traces while
performing encryption using plaintexts consisting of the ﬁrst two random bytes
(p1, p2) followed by the 14 zeros. Assuming that the ﬁrst subkey ˆk0
0,0 is known,
we mounted a customized DCA attack to recover the second subkey ˆk0
1,0. Table 8
shows the result. It is noteworthy that the DCA ranking of the correct subkey is
relatively high compared to Table 4 because there is a decrease in the correlation
coeﬃcients computed by each of all key candidates. For this reason, the round
output protected by the proposed encoding is not an attractive attack target
for power analysis. The Walsh transforms and the DCA results with respect to
the round outputs obtained by looking up Q0 and Q1 with a 1/2 probability are

23

provided in Fig. 9 and Table 9, respectively. There is no noticeable point of key
leakage.
These experimental results give us the following. The proposed encoding has the
eﬀect of extremely lowering the problematic correlation to the correct hypothet-
ical intermediate value. However, due to this fact, a variant of power analysis
can ﬁnd the subkeys that lead to the lowest correlation on the UT output. If a
plaintext is encrypted by either Q0 and Q1 with a 1/2 probability, it is possible
to counteract the variant of power analysis in advance.

Fig. 8: Walsh transforms on the round output obtained by Q0. Black: correct
subkey. Gray: wrong key candidates.

Table 8: Highest correlation of all key candidates vs. highest correlation/ranking
of the correct subkey when conducting the customized DCA on the ﬁrst round
output obtained by Q0.

TargetBit
Highest

1

2

3

4

5

6

7

8

0.031 0.029 0.025 0.032 0.028 0.033 0.032 0.034
Correct subkey 0.0009 0.0006 0.009 0.008 0.004 0.003 0.017 0.0005
84

Key ranking

116

114

189

250

240

241

26

6 Conclusion

Power analysis has been an attractive issue particularly for low-cost devices such
as IC cards. In most cases, cryptographic operations have been severely slowed
down to hide the key-dependent intermediate values with limited resources, or
memory requirements have steeply increased to perform secure cryptographic

0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg24

Fig. 9: Walsh transforms on the round output obtained by Q0 and Q1. Black:
correct subkey. Gray: wrong key candidates.

Table 9: Highest correlation of all key candidates vs. highest correlation/ranking
of the correct subkey when conducting the customized DCA on the ﬁrst round
output obtained by Q0 and Q1.

TargetBit
Highest

1

2

3

4

5

6

7

8

0.030 0.027 0.030 0.034 0.028 0.030 0.029 0.030
Correct subkey 0.009 0.007 0.011 0.004 0.01 0.003 0.004 0.003
179

Key ranking

171

117

178

180

75

74

88

2.75 K3.00 K3.25 K3.50 K3.75 K2468iWeg25

operations quickly. In this paper, we improved on the internal encoding of the
table-based AES implementation in such a way to protect the key hidden in
the tables from power analysis as well as simple memory observation. Since our
proposed encoding is perfectly balanced, power analysis attackers may guess the
key which leads to the lowest correlation to the correct hypothetical values. To
solve this problem, we suggested to generate the complement of the balanced
tables and use it to encrypt a plaintext with a 1/2 probability. Meanwhile, our
scheme requires only 232KB in the memory space and 1,000 operations including
XORs and lookups. It is also noteworthy that it does not rely on run-time random
number generators.
As future work, we remark that it seems possible to combine our implementation
with countermeasures of fault attacks [3, 6, 11]. In particular, our table-based
implementation is easy to combine with a table redundancy method for protect-
ing fault attacks [17]. By doing so, we can defend against power analysis and
fault attacks at the same time with only a few hundred kilobytes of memory
space. Since a table redundancy method is also not dependent on a run-time
random source, a combination of both techniques seem to be reasonable for low-
cost devices. Note, however, that the proposed implementation is secure under
the gray-box model. In other words, the key would lead to the lowest correlation
if a white-box attacker could manipulate the execution ﬂow so that either table
of Q0 or Q1 is always selected.

A The experimental results of the Walsh Transforms

All of the Walsh transform results explained in Section 5 are provided. First,
Fig. 10 - Fig. 12 show Wt1 - Wt3, respectively, using only Q0. Next, Fig. 13
depicts W(cid:15)γ. Every Walsh transform with respect to the correct subkeys and
Q0 results in the value of 0. In contrary, Fig. 14 - Fig. 16 illustrate Wt1 - Wt3,
respectively, with an increase in the encoding imbalance when using Q0 and Q1.
Fig. 17 also demonstrate it with respect to W(cid:15)γ.

B The experimental results of the DCA attacks on the

UT outputs

Table 4 and Table 5 in Section 5 show the results of DCA using the computational
traces that contain every computation in the encryption. For this reason, the
DCA ranking of the correct subkey was not always the lowest. To show the
eﬀectiveness of our balanced encoding in more detail, we would like to provide
DCA results using the 10,000 computational traces consisting of only the UT
output values. This will help us understand more accurately how the Walsh
transform score 0 for the UT output appears in the correlation coeﬃcients. As
shown in Table 10, all correct subkeys were ranked lowest in all cases as a result of
the DCA attacks. In this regard, it can be seen that the correlation coeﬃcients
calculated by the correct subkeys shown in Table 11 is much lower than the
coeﬃcients provided in Table 5.

26

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 10: The Walsh transforms on the U T 1
the ﬁrst round. Black: correct key; gray: wrong key.

0,0 outputs obtained by Q0 and S1 in

01020300102030iWt101020300102030iWt101020300102030iWt101020300102030iWt101020300102030iWt101020300102030iWt101020300102030iWt101020300102030iWt127

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 11: The Walsh transforms on the U T 1
the ﬁrst round. Black: correct key; gray: wrong key.

0,0 outputs obtained by Q0 and S2 in

01020300102030iWt201020300102030iWt201020300102030iWt201020300102030iWt201020300102030iWt201020300102030iWt201020300102030iWt201020300102030iWt228

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 12: The Walsh transforms on the U T 1
the ﬁrst round. Black: correct key; gray: wrong key.

0,0 outputs obtained by Q0 and S3 in

01020300102030iWt301020300102030iWt301020300102030iWt301020300102030iWt301020300102030iWt301020300102030iWt301020300102030iWt301020300102030iWt329

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 13: The Walsh transforms on the round outputs obtained by Q0 and the
hypothetical round outputs in the ﬁrst round. Black: correct key; gray: wrong
key.

0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg0.0 K2.0 K4.0 K6.0 K8.0 K2468iWeg30

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 14: The Walsh transforms on the U T 1
S1 in the ﬁrst round. Black: correct key; gray: wrong key.

0,0 outputs obtained by Q0 and Q1 and

02040600102030iWt102040600102030iWt102040600102030iWt102040600102030iWt102040600102030iWt102040600102030iWt102040600102030iWt102040600102030iWt131

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 15: The Walsh transforms on the U T 1
S2 in the ﬁrst round. Black: correct key; gray: wrong key.

0,0 outputs obtained by Q0 and Q1 and

02040600102030iWt202040600102030iWt202040600102030iWt202040600102030iWt202040600102030iWt202040600102030iWt202040600102030iWt202040600102030iWt232

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 16: The Walsh transforms on the U T 1
S3 in the ﬁrst round. Black: correct key; gray: wrong key.

0,0 outputs obtained by Q0 and Q1 and

02040600102030iWt302040600102030iWt302040600102030iWt302040600102030iWt3020400102030iWt302040600102030iWt3020400102030iWt302040600102030iWt333

(a) i(cid:48) = 1.

(b) i(cid:48) = 2.

(c) i(cid:48) = 3.

(d) i(cid:48) = 4.

(e) i(cid:48) = 5.

(f) i(cid:48) = 6.

(g) i(cid:48) = 7.

(h) i(cid:48) = 8.

Fig. 17: The Walsh transforms on the round outputs obtained by Q0 and Q1
and the hypothetical round outputs in the ﬁrst round. Black: correct key; gray:
wrong key.

2.75 K3.00 K3.25 K3.50 K3.75 K2468iWeg3.00 K3.25 K3.50 K3.75 K2468iWeg3.00 K3.30 K3.60 K3.90 K2468iWeg3.00 K3.25 K3.50 K2468iWeg2.70 K3.00 K3.30 K3.60 K2468iWeg2.75 K3.00 K3.25 K3.50 K3.75 K2468iWeg2.75 K3.00 K3.25 K3.50 K3.75 K2468iWeg3.00 K3.25 K3.50 K3.75 K2468iWeg34

Table 10: DCA ranking on the AES encryption using only Q0 when conduct-
ing mono-bit CPA on the SubBytes output with 10,000 computational traces
consisting of only the UT outputs.

(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)(cid:96)

TargetBit

Subkey

1
2
3
4
5
6
7
8

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256
256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256

Table 11: Highest correlation of all key candidates vs. highest correlation of the
correct subkeys when conducting the DCA attacks above.

1

Subkey
Highest 0.156 0.154 0.157 0.155 0.153 0.161 0.162 0.158 0.161 0.158 0.157 0.158 0.152 0.155 0.153 0.159
0.030 0.024 0.024 0.025 0.028 0.029 0.038 0.034 0.029 0.030 0.021 0.026 0.032 0.028 0.028 0.033

Key

11

10

13

14

16

12

15

2

4

3

9

5

6

8

7

References

1. Alpirez Bock, E., Brzuska, C., Michiels, W., Treﬀ, A.: On the Ineﬀectiveness of
Internal Encodings - Revisiting the DCA attack on White-box Cryptography. In:
Proceedings of the 16th International Conference on Applied Cryptography and
Network Security, ACNS 2018. pp. 103–120. Lecture Notes in Computer Science
(including subseries Lecture Notes in Artiﬁcial Intelligence and Lecture Notes in
Bioinformatics), Springer, Germany (1 2018)

2. Banik, S., Bogdanov, A., Isobe, T., Jepsen, M.B.: Analysis of Software Counter-
measures for Whitebox Encryption. vol. 2017, pp. 307–328 (2017), http://tosc.
iacr.org/index.php/ToSC/article/view/596

3. Biham, E., Shamir, A.: Diﬀerential Fault Analysis of Secret Key Cryptosystems.
In: Proceedings of the 17th Annual International Cryptology Conference on Ad-
vances in Cryptology. pp. 513–525. CRYPTO ’97, Springer-Verlag, London, UK,
UK (1997), http://dl.acm.org/citation.cfm?id=646762.706179

4. Biryukov, A., Udovenko, A.: Attacks and countermeasures for white-box designs.
In: Peyrin, T., Galbraith, S. (eds.) Advances in Cryptology – ASIACRYPT 2018.
pp. 373–402. Springer International Publishing, Cham (2018)

5. Bogdanov, A., Rivain, M., Vejre, P.S., Wang, J.: Higher-Order DCA against Stan-
dard Side-Channel Countermeasures. In: Proceedings of the 10th International
Workshop on Constructive Side-Channel Analysis and Secure Design, COSADE
’19, Darmstadt, Germany, April 3-5. pp. 118–141 (2019), https://doi.org/10.
1007/978-3-030-16350-1_8

6. Boneh, D., DeMillo, R.A., Lipton, R.J.: On the Importance of Checking Crypto-
graphic Protocols for Faults. In: Proceedings of the 16th Annual International Con-
ference on Theory and Application of Cryptographic Techniques. pp. 37–51. EU-
ROCRYPT’97, Springer-Verlag, Berlin, Heidelberg (1997), http://dl.acm.org/
citation.cfm?id=1754542.1754548

35

7. Bos, J.W., Hubain, C., Michiels, W., Teuwen, P.: Diﬀerential Computation Analy-
sis: Hiding Your White-Box Designs is Not Enough. In: Proceedings of the 18th In-
ternational Workshop on Cryptographic Hardware and Embedded Systems, CHES
’16. pp. 215–236. CHES ’16, Springer Berlin Heidelberg, Berlin, Heidelberg (2016)
8. Brier, E., Clavier, C., Olivier, F.: Correlation Power Analysis with a Leakage
Model. In: Proceedings of the 6th International Workshop on Cryptographic Hard-
ware and Embedded Systems. pp. 16–29. CHES ’04, Springer (2004)

9. Chow, S., Eisen, P., Johnson, H., Oorschot, P.C.V.: White-Box Cryptography and
an AES Implementation. In: Proceedings of the 9th International Workshop on
Selected Areas in Cryptography, SAC ’02. pp. 250–270. Springer-Verlag (2002)
10. Chow, S., Eisen, P.A., Johnson, H., van Oorschot, P.C.: A White-Box DES Im-
plementation for DRM Applications. In: Security and Privacy in Digital Rights
Management, ACM CCS-9 Workshop, DRM 2002, Washington, DC, USA, Novem-
ber 18, 2002, Revised Papers. pp. 1–15 (2002), http://dx.doi.org/10.1007/
978-3-540-44993-5_1

11. Giraud, C.: DFA on AES. In: Proceedings of the 4th International Conference
on Advanced Encryption Standard. pp. 27–41. AES’04, Springer-Verlag, Berlin,
Heidelberg (2005), http://dx.doi.org/10.1007/11506447_4

12. Herbst, C., Oswald, E., Mangard, S.: An aes smart card implementation resistant
to power analysis attacks. In: Zhou, J., Yung, M., Bao, F. (eds.) Applied Cryp-
tography and Network Security. pp. 239–252. Springer Berlin Heidelberg, Berlin,
Heidelberg (2006)

13. Kocher, P.C., Jaﬀe, J., Jun, B.: Diﬀerential Power Analysis. In: Advances in Cryp-
tology - CRYPTO ’99, 19th Annual International Cryptology Conference, Santa
Barbara, California, USA, August 15-19, 1999, Proceedings. pp. 388–397 (1999),
http://dx.doi.org/10.1007/3-540-48405-1_25

14. Lee, S., Jho, N., Kim, M.: On the Linear Transformation in White-Box Cryptog-

raphy. IEEE Access 8, 51684–51691 (2020)

15. Lee, S., Kim, M.: Improvement on a masked white-box cryptographic implemen-

tation. IEEE Access 8, 90992–91004 (2020)

16. Lee, S., Kim, T., Kang, Y.: A Masked White-Box Cryptographic Implementation
for Protecting Against Diﬀerential Computation Analysis. IEEE Transactions on
Information Forensics and Security 13(10), 2602–2615 (Oct 2018)

17. Lee, S., Jho, N.S., Kim, M.: Table redundancy method for protecting against fault

attacks. IEEE Access 9, 92214–92223 (2021)

18. Luk, C., Cohn, R.S., Muth, R., Patil, H., Klauser, A., Lowney, P.G., Wallace, S.,
Reddi, V.J., Hazelwood, K.M.: Pin: Building Customized Program Analysis Tools
with Dynamic Instrumentation. In: Proceedings of the ACM SIGPLAN 2005 Con-
ference on Programming Language Design and Implementation, Chicago, IL, USA,
June 12-15, 2005. pp. 190–200 (2005), http://doi.acm.org/10.1145/1065010.
1065034

19. Mangard, S., Oswald, E., Popp, T.: Power Analysis Attacks: Revealing the Secrets

of Smart Cards (Advances in Information Security) (2007)

20. Nethercote, N., Seward, J.: Valgrind: a Framework for Heavyweight Dynamic
Binary Instrumentation. In: Proceedings of the ACM SIGPLAN 2007 Confer-
ence on Programming Language Design and Implementation, San Diego, Cali-
fornia, USA, June 10-13, 2007. pp. 89–100 (2007), http://doi.acm.org/10.1145/
1250734.1250746

21. Rivain, M., Wang, J.: Analysis and Improvement of Diﬀerential Computation At-
tacks against Internally-Encoded White-Box Implementations. IACR Trans. Cryp-

36

togr. Hardw. Embed. Syst. 2019(2), 225–255 (2019), https://doi.org/10.13154/
tches.v2019.i2.225-255

22. Sasdrich, P., Moradi, A., G¨uneysu, T.: White-Box Cryptography in the Gray Box
- A Hardware Implementation and its Side Channels -. In: Fast Software Encryp-
tion - 23rd International Conference, FSE 2016, Bochum, Germany, March 20-23,
2016, Revised Selected Papers. pp. 185–203 (2016), http://dx.doi.org/10.1007/
978-3-662-52993-5_10

23. Schramm, K., Paar, C.: Higher order masking of the aes. In: Proceedings of the
2006 The Cryptographers’ Track at the RSA Conference on Topics in Cryptology.
p. 208–225. CT-RSA’06, Springer-Verlag, Berlin, Heidelberg (2006), https://doi.
org/10.1007/11605805_14

24. Seker, O., Eisenbarth, T., Liskiewicz, M.: A white-box masking scheme resisting
computational and algebraic attacks. IACR Transactions on Cryptographic Hard-
ware and Embedded Systems 2021(2), 61–105 (Feb 2021), https://tches.iacr.
org/index.php/TCHES/article/view/8788

25. Tillich, S., Herbst, C.: Attacking state-of-the-art software countermeasures—a case
study for aes. In: Oswald, E., Rohatgi, P. (eds.) Cryptographic Hardware and
Embedded Systems – CHES 2008. pp. 228–243. Springer Berlin Heidelberg, Berlin,
Heidelberg (2008)

26. Tillich, S., Herbst, C., Mangard, S.: Protecting aes software implementations on 32-
bit processors against power analysis. In: Katz, J., Yung, M. (eds.) Applied Cryp-
tography and Network Security. pp. 141–157. Springer Berlin Heidelberg, Berlin,
Heidelberg (2007)

27. Zeyad, M., Maghrebi, H., Alessio, D., Batteux, B.: Another Look on Bucketing At-
tack to Defeat White-Box Implementations. In: Constructive Side-Channel Analy-
sis and Secure Design - 10th International Workshop, COSADE 2019, Darmstadt,
Germany, April 3-5, 2019, Proceedings. pp. 99–117 (2019)

