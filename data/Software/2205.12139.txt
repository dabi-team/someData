Springer Nature 2021 LATEX template

2
2
0
2

y
a
M
4
2

]
I

N
.
s
c
[

1
v
9
3
1
2
1
.
5
0
2
2
:
v
i
X
r
a

Extending the Network Calculus
Algorithmic Toolbox for
Ultimately Pseudo-Periodic Functions:
Pseudo-Inverse and Composition

Raﬀaele Zippo1,2,3*, Paul Nikolaus3 and Giovanni Stea2

1*Dipartimento di Ingegneria dell’Informazione, Università di
Firenze, Via di S. Marta 3, Firenze, 50139, Italy.
2Dipartimento di Ingegneria dell’Informazione, Università di Pisa,
Largo Lucio Lazzarino 1, Pisa, 56122, Italy.
3Distributed Computer Systems Lab (DISCO), TU Kaiserslautern,
Paul-Ehrlich-Straße 34, Kaiserslautern, 67663, Germany.

*Corresponding author(s). E-mail(s): raﬀaele.zippo@uniﬁ.it;
Contributing authors: nikolaus@cs.uni-kl.de;
giovanni.stea@unipi.it;

Abstract

Network Calculus (NC) is an algebraic theory that represents traﬃc
and service guarantees as curves in a Cartesian plane, in order to com-
pute performance guarantees for ﬂows traversing a network. NC uses
transformation operations, e.g., min-plus convolution of two curves, to
model how the traﬃc proﬁle changes with the traversal of network nodes.
Such operations, while mathematically well-deﬁned, can quickly become
unmanageable to compute using simple pen and paper for any non-
trivial case, hence the need for algorithmic descriptions. Previous work
identiﬁed the class of piecewise aﬃne functions which are ultimately
pseudo-periodic (UPP) as being closed under the main NC operations
and able to be described ﬁnitely. Algorithms that embody NC oper-
ations taking as operands UPP curves have been deﬁned and proved
correct, thus enabling software implementations of these operations.
However, recent advancements in NC make use of operations, namely the
lower pseudo-inverse, upper pseudo-inverse, and composition, that are
well deﬁned from an algebraic standpoint, but whose algorithmic aspects

1

 
 
 
 
 
 
Springer Nature 2021 LATEX template

2

Extending the NC Algorithmic Toolbox for UPP Functions

have not been addressed yet. In this paper, we introduce algorithms for
the above operations when operands are UPP curves, thus extending
the available algorithmic toolbox for NC. We discuss the algorithmic
properties of these operations, providing formal proofs of correctness.

Keywords: Network calculus, (min,+)-algebra, algorithms, pseudo-inverse,
composition

1 Introduction

Network Calculus (NC) is an algebraic theory where traﬃc and service guar-
antees are represented as functions of time. The I/O transformations that
network traversal imposes on an input traﬃc can be represented as operations
of min-plus algebra involving these curves. This allows one to compute worst-
case performance guarantees for a ﬂow traversing a network. NC dates back
to the early 1990s, and it is mainly due to the work of Cruz [1, 2], Le Boudec
and Thiran [3], and Chang [4]. Originally devised for the Internet, where it
was used to engineer models of service [5–9], it has found applications in sev-
eral other contexts, from sensor networks [10] to avionic networks [11, 12],
industrial networks [13–15] automotive systems [16] and systems architecture
[17, 18].

NC characterizes constraints on traﬃc arrivals (due to traﬃc shaping) and
on minimum received service (due to scheduling) as curves, i.e., functions of
time.1 These curves are then used with operators from min-plus and max-plus
algebra to derive further insights about the system. For example, the per-ﬂow
service curve of a scheduler, such as Weighted Round Robin, or performance
bounds on the traﬃc such as an end-to-end delay bound.

While these operations can be computed with pen and paper for simple
examples, in most practical cases the application of NC requires the use of
software. To this end, [19, 20] provide an “algorithmic toolbox” for NC: they
show that piecewise aﬃne functions that are ultimately pseudo-periodic (UPP)
represent good models for both traﬃc and service guarantees. Moreover, they
prove that this class of functions is closed under the main NC operations
and can be described with a ﬁnite amount of information. Additionally, they
introduce the algorithms that embody the main NC operations, computing
UPP results starting from UPP operands. The results in these works cover the
main operations used in NC, such as minimum, min-plus convolution, min-
plus deconvolution, etc. (see [20] for a complete list). The toolbox was ﬁrst
implemented in the COINC free library [21], which is not available anymore,
and later by the commercial library RTaW-Pegase [22].

However, other NC operators, i.e., the composition and lower and upper
pseudo-inverse, have been in focus in recent NC literature. [23] shows the
duality between min-plus and max-plus models, and how the lower and

1We use the terms function and curve interchangeably

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

3

upper pseudo-inverses can be used to switch between the two models. In
[20, Theorem 8.6], lower pseudo-inverse and composition are used to com-
pute the per-ﬂow service curve for a Weighted Round-Robin scheduler; in
[24, Theorem 1], a similar result is shown for a Interleaved Weighted Round-
Robin scheduler, using again lower pseudo-inverse and composition; in [25],
authors show that several service curves can be found for a ﬂow scheduled in
a Deﬁcit Round-Robin scheduler, under diﬀerent hypotheses regarding cross-
traﬃc. [26, 27] use pseudo-inverses and compositions to study properties of
IEEE Time-Sensitive Networking (TSN) [28], a standard relevant for many
applications. We can therefore obtain the results presented in these papers,
using arbitrarily complex UPP curves as inputs.

While the algebraic formulation of these three operations is well known,
their algorithmic aspects have not been addressed, to the best of our knowl-
edge. This means that we do not have publicly known algorithms that compute
these operations yet.

In this paper, we aim to ﬁll this gap and extend the existing algo-
rithm toolbox to include lower- and upper-pseudo inverses and composition of
functions.

We show that the UPP class is closed with respect to these operations,
and provide algorithms to compute the result of each one. We prove that all
of them have linear complexity with respect to the number of segments that
represent the operands. We design specialized, more eﬃcient versions of the
composition algorithm that leverage characteristics of the operand functions
– notably, their being Ultimately Aﬃne (UA) or Ultimately Constant (UC)
[20]. Last, we exemplify our ﬁndings on a comprehensive proof of concept,
showing how to compute the per-ﬂow service curve of [24, Theorem 1], which
makes use of all the ﬁndings in this paper. The algorithms described in this
paper, together with those for known NC operators, are implemented in the
Nancy open-source toolbox [29], which, to the best of our knowledge, is the
only public one to implement UPP algorithms.

The rest of this paper is organized as follows: Section 2 brieﬂy introduces
Network Calculus notation and some basic results. Section 3 introduces the
deﬁnitions and notation used throughout the paper, and discusses the kind of
results that we need to provide for each operator to enable their implementa-
tion. In Section 4, we present the results for the lower and upper pseudo-inverse
operators, including their properties for UPP curves and algorithms to com-
pute them. Section 5 shows our results for the composition operator, including
its properties on UPP curves and an algorithm to compute it. In Section 6,
we report a proof-of-concept evaluation, by computing the results of a recent
NC paper via our algorithms. Finally, Section 7 draws some conclusions and
highlights directions for future works.

Springer Nature 2021 LATEX template

4

Extending the NC Algorithmic Toolbox for UPP Functions

Fig. 1: Example of leaky-bucket shaper, taken from [17]. The traﬃc process
A(t) is always below the arrival curve α(t) and its translations along A(t).

Fig. 2: Graphical interpretation of the convolution operation.

2 Network Calculus Basics

This section brieﬂy introduces Network Calculus (NC). A NC ﬂow is repre-
sented by a function of time A(t) that counts the amount of traﬃc arrived by
time t. Such function is necessarily wide-sense increasing. It is often assumed to
be left-continuous, i.e., A(t) represents the number of bits in [0, t[. In particular,
A(0) = 0.

Flows can be constrained by arrival curves. A wide-sense increasing

function α is an arrival curve for a ﬂow A if

A(t) − A(s) ≤ α(t − s),

∀s ≤ t.

For instance, a leaky-bucket shaper, with a rate ρ and a burst size σ, enforces
the concave aﬃne arrival curve γσ,ρ(t) = σ + ρt, as shown in Figure 1. In
particular, this means that the long-term arrival rate of the ﬂow cannot exceed
ρ. Leaky-bucket shapers are often employed at the entrance of a network, to
ensure that the traﬃc injected does not overﬂow the negotiated amount.

bitsSpringer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

5

Fig. 3: Graphical example of a delay bound.

Let A and D be non-decreasing functions that describe the same data ﬂow
at the input and output of a lossless network element (or node), respectively.
If that node does not create data internally (which is often the case), causality
requires that A ≥ D. We say that the ﬂow is guaranteed the (minimum) service
curve β if

D(t) ≥ inf

0≤s≤t

A(s) + β(t − s) =: (A ⊗ β)(t),

∀t ≥ 0.

(1)

We call the operation on the right the (min-plus) convolution of A and β. The
function argument t is omitted whenever it is clear from the context. Several
network elements, such as delay elements, schedulers or links, can be modeled
through service curves.

A very frequent case is the one of rate-latency service curves, deﬁned as

βR,θ(t) = R · [t − θ]+

for some rate R > 0 and latency θ > 0. Notation [·]+ denotes max {·, 0}.
For instance, a constant-rate server (e.g., a wired link) can be modeled as a
rate-latency curve with zero latency. Figure 2 shows the lower bound of D(t)
obtained when convolving the input A(t) with a rate-latency service curve.

A point of strength of NC is that service curves are composable: the end-
to-end service curve of a tandem of nodes traversed by the same ﬂow can be
computed as the convolution of the service curves of each node.

For a ﬂow that traverses a service curve (be it the one of a single node,
or the end-to-end service curve of a tandem computed as discussed above), a
tight upper bound on the delay can be computed by combining its arrival curve
α and the service curve β itself, as follows:

h(α, β) = sup
t≥0

[inf {d ≥ 0 | α(t − d) ≤ β(t)}] .

(2)

Springer Nature 2021 LATEX template

6

Extending the NC Algorithmic Toolbox for UPP Functions

The quantity h(α, β) is in fact the maximum horizontal distance between
α and β, as shown in Figure 3. Therefore, computing the end-to-end service
curve of a ﬂow in a tandem traversal is the crucial step towards obtaining its
worst-case delay bound.

The above introduction, albeit concise, should convince the alert reader
that algorithms for automated manipulation of curves, implementing NC oper-
ators, are necessary to reap the beneﬁts of NC algebra in practical scenarios.
Many such algorithms have been discussed in [19, 20]. The next section
describes the generic algorithmic framework exposed in these papers, which
we extend in this work.

3 Mathematical Background and Notation

In this section, we provide an overview of the mathematical background for
this paper, including the deﬁnitions used and the results we aim to provide.

NC computations can be implemented in software. In order to do so, one
needs to provide ﬁnite representations of functions and well-formed algorithms
for NC operations. According to the widely accepted approach described in
[19, 20], a suﬃciently generic class of functions useful for NC computations is
that of (i) piecewise aﬃne (ii) ultimately pseudo-periodic Q+ → Q functions.
We deﬁne both properties (i) and (ii) separately:

Deﬁnition 1 (Piecewise Aﬃne Function [19, p. 9]) We say that a function f is
piecewise aﬃne (PA) if there exists an increasing sequence (ai)i∈N which tends to
+∞, such that a0 = 0 and ∀i ≥ 0, f is aﬃne on ]ai, ai+1[i.e.,

f (t) ∈ {bi + ρit, +∞, −∞} ,

∀t ∈ ]ai, ai+1[ .

The ai’s are called breakpoints.

Deﬁnition 2 (Ultimately Pseudo-Periodic Function [19, p. 8] ) Let f be a function
Q+ → Q ∪ {+∞, −∞}. Then, f is ultimately pseudo-periodic (UPP) if there exist
Tf ∈ Q+, df ∈ Q+ \ {0}, cf ∈ Q such that

f (t + kf · df ) = f (t) + kf · cf ,

(3)
We call Tf the (pseudo-periodic) start or length of the initial transient, df the
(pseudo-periodic) length, and cf the (pseudo-periodic) height.

∀t ≥ Tf , ∀kf ∈ N0.

In [19], this class of functions is shown to be stable w.r.t. all min-plus
operations, while functions R+ → R are not.2 Henceforth, we will consider all
functions to be piecewise aﬃne and UPP. For such functions, it is enough to
store a representation of the initial transient part and of one period, which is
a ﬁnite amount of information. This is exempliﬁed in Figure 4.

Accordingly, we call a representation Rf of a function f the tuple
(S, T, d, c), where T, d, c are the values described above, and S is a sequence

2An alternative class of functions with such stability is N → R, however this is only feasible for

models where time is discrete.

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

7

(a) f

(b) Rf

Fig. 4: Example of ultimately pseudo-periodic piecewise aﬃne function f and
its representation Rf .

of points and open segments describing f in [0, T + d[. We use both points
and open segments in order to easily model discontinuities. We will use the
umbrella term elements to encompass both when convenient.

Deﬁnition 3 (Point) We deﬁne a point as a tuple

pi := (ti, f (ti)),

i ∈ {1, . . . , n} .

Deﬁnition 4 (Segment) We deﬁne a segment as a tuple

(cid:16)

si :=

ti, ti+1, f (t+

i ), f (t−

i+1)

(cid:17)

,

i ∈ {1, . . . , n}

which describes f in the open interval ]ti, ti+1[ in which it is aﬃne, i.e.,

f (t) = f (t+

i ) +

f (t−

i+1) − f (t+
i )
ti+1 − ti

· (t − ti) =: b + r · (t − ti)

for all t ∈ ]ti, ti+1[ .

If r = 0, we call si a constant segment.

Deﬁnition 5 (Sequence) We deﬁne a sequence SD
f as on ordered set of elements
e1, . . . , en that alternate between points and segments and describe f in the ﬁnite
interval D.

For example, given D = [0, T [, then SD

f = {p1, s1, p2, . . . , pn, sn} where
p1 = (0, f (0)) and, assuming pn = (tn, f (tn)) for some 0 < tn < T , sn =
(tn, T, f (t+

n ), f (T −)).

Note that, given Rf , one can compute f (t) for all t ≥ 0, and also SD
f for
any interval D. Furthermore, being ﬁnite, Rf can be used as a data structure
to represent f in code. As is discussed in depth in [30], Rf is not unique,
and using a non-minimal representation of f can aﬀect the eﬃciency of the
computations. Given a sequence S, let n(S) be its cardinality. As it is useful in

TfdfcftimedataTfdfcftimedataSpringer Nature 2021 LATEX template

8

Extending the NC Algorithmic Toolbox for UPP Functions

↓

(cid:17)−1

, to express that we are computing it on f over the limited interval D.

the following, we deﬁne Cut to be an (obvious) algorithm that, given Rf and
D, computes SD
f . With a little abuse of notation, we use min-plus operators
directly on ﬁnite sequences such as SD
f . For instance, given the lower pseudo-
inverse of f , (f )−1
(its formal deﬁnition is in the next section), we will write
↓
(cid:16)
SD
f
A NC operator can then be deﬁned computationally as an algorithm that
takes UPP representations of its input functions and yields an UPP repre-
sentation of the result, provided that the class of UPP functions is closed
with respect to such operator. Considering a generic unitary operator [·]∗, in
order to compute f ∗ we need an algorithm that computes Rf ∗ from Rf , i.e.,
Rf → Rf ∗ . We call this by-curve algorithm. This process can be divided in
the following steps:

1. compute valid parameters Tf ∗ , df ∗ and cf ∗ for the result;
2. compute the domain D for the sequence SD
3. compute SD

f → Sf ∗ , i.e., use an algorithm that computes the result-
ing sequence from the sequence of the operand. We call this by-sequence
algorithm for operator [·]∗;

f = Cut(Rf , D);

4. return Rf ∗ = (Sf ∗ , Tf ∗ , df ∗ , cf ∗ ).

We therefore need to provide the following results:
• a proof that the result of the operator [·]∗, applied to an UPP function,

yields an UPP result;

• a way to compute UPP parameters Tf ∗ , df ∗ and cf ∗ from Rf ;
• a valid domain D, again to be computed from Rf ;
• a by-sequence algorithm.
Combining the above results, we can then construct the by-curve algorithm

for operator [·]∗, thus allowing us to compute [·]∗ for any UPP curve.3

Works [19, 20] provided such computational descriptions for fundamental
NC operators such as minimum, sum, convolution, and many others. In this
paper, we extend the above toolbox by adding the lower pseudo-inverse, upper
pseudo-inverse, and composition operators. To the best of our knowledge, no
computational description of the above has been formalized before, despite
their relevance in the NC literature.

Before presenting our contribution, we introduce two more deﬁnitions that

will be used throughout the paper.

Deﬁnition 6 (Ultimately Aﬃne Function) Let f be a function Q+ → Q. Then, f
is Ultimately Aﬃne (UA), if there exist T a

f ∈ Q+, ρf ∈ Q such that

f (t) = f (T a

f ) + ρf · (cid:0)t − T a

f

(cid:1) ,

∀t ≥ T a
f .

(4)

Note that this deﬁnition diﬀers from the one in the literature [19], but we
prove their equivalence in Appendix A. UA functions are (obviously) UPP
as well, their period being a single segment of slope ρf and arbitrary length

3The same process applies also, with minor adjustments, to binary operators

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

9

starting at T a
f . They occur quite often in NC, e.g., the arrival curve of a leaky-
bucket shaper or a rate-latency service curve are both UA. An Ultimately
Constant (UC) function is UA with ρf = 0.

Unlike UPP, the class of UA functions is not closed with respect to NC
operations. For instance, [30] shows that ﬂow-controlled networks with rate-
latency (hence UA) service curves yield closed-loop service curves that are
UPP, but not necessarily UA again. Moreover, in many cases, the service
curves of individual ﬂows served by Round-Robin schedulers are UPP, but
not UA either (see, e.g., [24, 25, 31]). However, there are cases when simpler
algorithms for NC operations can be derived if one assumes that operands
are UA. For this reason, there are NC toolboxes that only consider UA func-
tions, e.g., [32]. A possible approach to NC analysis is thus to approximate
UPP (non-UA) functions with UA lower/upper bounds, trading some accu-
racy for computation time [33, 34]. Throughout this paper, we provide general
algorithms for UPP functions. However, we also show what is to be gained –
in terms of domain compactness and/or algorithmic eﬃciency – when we can
make stronger assumptions on the operands.

Deﬁnition 7 (Weakly Ultimately Inﬁnite Function) Let f : Q+ → Q+ ∪ {+∞} be
an UPP function. If there exists Tf ∈ Q+ such that

f (t) < +∞,
f (t) = +∞,

∀t < Tf ,
∀t > Tf ,

then we call this function a weakly ultimately inﬁnite (wUI) one.

Weakly ultimately inﬁnite functions are inﬁnite starting from a ﬁnite
abscissa. Typical cases in NC are the service curves of delay elements. Note
that the above deﬁnition diﬀers from the one of ultimately inﬁnite in [19]:
the latter requires f to be inﬁnite in Tf (i.e., it has a weak inequality in the
lower branch), whereas we do not mandate anything in Tf . Therefore, every
ultimately inﬁnite function is wUI too, but not vice versa. Our more general
deﬁnition allows us to better discuss corner cases in Section 4.4.

4 Lower and Upper Pseudo-Inverse of UPP

Functions

In this section, we discuss the lower and upper pseudo-inverse operators for
UPP functions (henceforth, we will omit the lower or upper attribute when
the discussion applies to both).

First, we provide formal deﬁnitions.

Deﬁnition 8 (Lower and Upper Pseudo-Inverse [23]) Let f : Q → Q ∪ {−∞} ∪ {∞}
be non-decreasing. Then the lower pseudo-inverse is deﬁned as

f −1
↓ (y) := inf {x | f (x) ≥ y} = sup {x | f (x) < y}

Springer Nature 2021 LATEX template

10

Extending the NC Algorithmic Toolbox for UPP Functions

and the upper pseudo-inverse is deﬁned as

f −1
↑ (y) := sup {x | f (x) ≤ y} = inf {x | f (x) > y} .

Note that the lower pseudo-inverse is always left-continuous and the upper
pseudo-inverse is right-continuous [23, pp. 64]. Moreover, we have in general
that [23, pp. 61]

f −1
↓ ≤ f −1
↑ .
The rest of this section is organized as follows. In Section 4.1 we show that
the pseudo-inverse of an UPP function is still UPP, and provide expressions to
compute its UPP parameters a priori. In Section 4.2 we discuss, ﬁrst through
an visual example and then via pseudo-code, how to algorithmically compute
the pseudo-inverse. In Section 4.3 we conclude with a summary of the by-curve
algorithm, some observations on the algorithmic complexity of this operator.
In Section 4.4 we discuss corner cases.

4.1 Properties of pseudo-inverses of UPP functions

We discuss our properties for a generic function f , excluding the cases of
UC and wUI functions. These two cases are treated separately for ease of
presentation. At the end of this section, we report the necessary information
for the alert reader to retrace the steps exposed hereafter to include these
two corner cases. We remark that the Nancy software library [29] computes
pseudo-inverses of generic (non-decreasing) UPP functions, including UC and
wUI ones.

Theorem 9 Let f be a non-decreasing UPP function that is neither UC nor wUI.
Then, its lower pseudo-inverse f −1

↓ (x) = inf {t | f (t) ≥ x} is again UPP with

Tf −1

↓

df −1

↓

cf −1

↓

= f (cid:0)Tf + df

(cid:1) ,

= cf ,

= df .

(5)

(6)

(7)

Proof Let t1 ≥ Tf + df and x := f (t1). Moreover, we deﬁne t0 := f −1
↓ (x) =
inf {t | f (t) ≥ x} = inf {t | f (t) ≥ f (t1)}. By deﬁnition, it is clear that t0 ≤ t1 (t1
satisﬁes the condition in the inﬁmum, and t0 is the smallest to satisfy it). Since f is
non-UC and we have by deﬁnition t1 − df ≥ Tf , it follows that

f (Tf ) ≤ f (t1 − df )

(3)
= f (t1) − cf < f (t1) = f (t0),

where we used in the strict inequality that f is not UC and thus t0 > Tf . Therefore,
(cid:26)

(cid:27)

(cid:18)

(cid:19)

f −1
↓

x + k · df −1

↓

= inf

t | f (t) ≥ x + k · df −1

↓

(6)

= inf (cid:8)t | f (t) ≥ x + k · cf

(cid:9)

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

11

(cid:9)

= inf (cid:8)t | f (t) ≥ f (t1) + k · cf
= inf (cid:8)t | f (t) ≥ f (t0) + k · cf
(cid:9)
= inf (cid:8)t | f (t) ≥ f (t0 + k · df )(cid:9)
= t0 + k · df
(7)
= f −1

↓ (x) + k · cf −1

.

↓

(cid:3)

It follows from Theorem 9 that, in order to compute a representation Rf −1

,

↓

we need only to compute SD(cid:48)
f −1
↓

where

D(cid:48) = [0, Tf −1

↓

+ df −1

↓

[= [0, f (Tf + df ) + cf [.

If there is no left-discontinuity in Tf + 2 · df , it follows that

SD(cid:48)
f −1
↓

= (cid:0)SD

f

(cid:1)−1
↓

,

where

D = [0, Tf + 2 · df [
(8)
Otherwise, let x1 = f ((Tf + 2 · df )−) and x2 = f (Tf + 2 · df ), then x1 < x2,
and therefore SD(cid:48)
must end with a constant segment deﬁned in ]x1, x2[ with
f −1
↓
ordinate Tf + 2 · df . Such segment must be added manually at the end of
(cid:16)

(cid:17)−1

.

SD
f
A similar result can be derived for the upper pseudo-inverse.

↓

Theorem 10 Let f be a non-decreasing UPP function that is not UC. Then, the
upper pseudo-inverse f −1

↑ (x) = sup {t | f (t) ≤ x} is again UPP with
= f (cid:0)Tf

(cid:1)

Tf −1

↑

df −1

↑

cf −1

↑

= cf

= df

(9)

(10)

(11)

Proof The proof follows the same steps as the one for the lower pseudo-inverse. Let
t0 ≥ Tf and x := f (t0). Moreover, we deﬁne t1 := f −1
↑ (x) = sup {t | f (t) ≤ x} =
sup {t | f (t) ≤ f (t0)}. By deﬁnition, it is clear that t0 ≤ t1 (t0 satisﬁes the condition
in the supremum, and t1 is the largest to satisfy it). Since f is non-UC and we have
by deﬁnition t0 ≥ Tf , it follows that

f (t0 + df )

(3)
= f (t0) + cf > f (t0) = f (t1).

Springer Nature 2021 LATEX template

12

Extending the NC Algorithmic Toolbox for UPP Functions

where we used in the strict inequality that f is not ultimately constant and thus
t1 < t0 + df < ∞. Therefore,

f −1
↑

(cid:18)

(cid:19)

(cid:26)

(cid:27)

x + k · df −1

↑

= sup

t | f (t) ≤ x + k · df −1

↑

(10)

(cid:9)

= sup (cid:8)t | f (t) ≤ x + k · cf
(cid:9)
= sup (cid:8)t | f (t) ≤ f (t0) + k · cf
= sup (cid:8)t | f (t) ≤ f (t1) + k · cf
(cid:9)
= sup (cid:8)t | f (t) ≤ f (t1 + k · df )(cid:9)
= t1 + k · df
(11)
= f −1

↑ (x) + k · cf −1

.

↑

(cid:3)

Similar to the previous theorem, it follows from Theorem 10 that, in order

to compute a representation Rf −1

↑

, we need only to compute SD(cid:48)
f −1
↑

, where

D(cid:48) = [0, Tf −1

↑

+ df −1

↑

[= [0, f (Tf ) + cf [.

If there is no left-discontinuity in Tf + df , it follows that

SD(cid:48)
f −1
↑

= (cid:0)SD

f

(cid:1)−1
↑

,

where

(cid:16)

D = [0, Tf + df [.
Otherwise, let x1 = f ((Tf + df )−) and x2 = f (Tf + df ), then x1 < x2,
and therefore SD(cid:48)
must end with a constant segment deﬁned in ]x1, x2[ with
f −1
↑
(cid:17)−1

ordinate Tf +df . Such segment must be added manually at the end of
The alert reader will notice that Tf −1
diﬀer, for which we can provide
the following intuitive explanation. Consider a function f so that f (t) = k, ∀t ∈
]a, T +b[ with a < T, b > 0. Then f −1
↓ (k) = a, as the lower pseudo-inverse “goes
backwards” to the start of the constant segment. However, since a < T , the
pseudo-periodic property does not apply for f (a), i.e., we cannot say anything
about f (a+d). So, in general, we cannot say f −1
is pseudo-periodic from f (T ),
and we instead need to “skip” to the second pseudo-period so that, as in the
proof, T < a < T + d.
The same does not apply for f −1
↑ (k) = T + b as the
upper pseudo-inverse “goes forward” to the end of the constant segment and
T + b > T , thus we can rely on the pseudo-periodic property of f .

↑ , however, since f −1

and Tf −1

SD
f

↑

↓

.

↑

↓

An interesting consequence of this discussion is that the representation Rf
may change when we do not expect it to. From [23, pp. 64], [20, p. 48], we
know the following properties:

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

13

• if f is left-continuous,

(cid:16)

• if f is right-continuous,

(cid:17)−1

(cid:16)

(cid:17)−1

=

f −1
↓
(cid:16)

↓
(cid:17)−1
f −1
↑

↑

=

f −1
↑
(cid:16)

↓
(cid:17)−1
f −1
↓

↑

= f ,

= f .

Thus, one may expect that applying the pseudo-inverse twice would lead to a
function with the same representation, i.e., that

= Rf . However,

(cid:17)−1

(cid:16)

(Rf )−1
↓

↓

as per the discussion above, the start of the pseudo-period of the result would
go from an initial Tf to Tf + df + cf . This is unavoidable – the above example
shows that there exists one case when Tf would not be the correct starting
point. However, in other cases, Tf would be the correct starting point for the
pseudo-periodic behavior.

This is an instance of a general issue encountered with algorithms for UPP
curves – also discussed in [30]. Generic algorithms, that make no assump-
tions on the shape of the operands (such as the ones presented here for
the pseudo-inverse), may in general yield non-minimal representations of the
result. Generally speaking, minimal representations are preferable, since the
number of elements in a sequence aﬀects the complexity of the algorithms.
However, addressing the issue of representation minimization a priori when
implementing NC operators is too hard (if doable at all), since one would
need to make a comprehensive list of subcases, and, of course, as many for-
mal proofs of correctness. It is instead considerably more eﬃcient to devise
a generic algorithm for an operator, neglecting minimization, and then use a
simple algorithm a posteriori that minimizes the representation of the result
– see [30].

4.2 By-sequence algorithm for pseudo-inverses

In this section we discuss the by-sequence algorithms for pseudo-inverses. We
recall that with "by-sequence" we mean that the operand, and thus its result,
is deﬁned on a limited domain. Without loss of generality, we will focus on
a sequence S representing a function f over an interval [0, t[, with f (0) = 0.
Then S−1
over the interval [0, f (t−)[. The
same applies to S−1
↑ .

is the sequence representing f −1

↓

↓

↓

and S−1

The simplest case is when S is continuous and strictly increasing, hence
bijective. In this case, both S−1
are the classic inverse of S, and the
↑
algorithm consists of drawing, for each point and segment of S, its reﬂection
over the line y = x. However, when S includes discontinuities and/or constant
segments, the algorithm becomes slighlty more complicated: a discontinuity
in S “maps” to a constant segment in both S−1
↑ , while a constant
segment in S “maps” to a right-discontinuity in S−1
and a left-discontinuity
in S−1

↑ . This is exempliﬁed in Figure 5.
We describe Algorithm 1 for the lower pseudo-inverse (the one for the upper
pseudo-inverse diﬀers in few details which we brieﬂy discuss later). Algorithm 1
linearly scans S considering one elements at a time. Based on the type of

and S−1

↓

↓

Springer Nature 2021 LATEX template

14

Extending the NC Algorithmic Toolbox for UPP Functions

(a) S

(b) S−1

↓

(c)

(cid:16)
S−1
↓

(cid:17)−1

↓

Fig. 5: Example of lower pseudo-inverse of a sequence S. Since S is left-

continuous, S =

(cid:17)−1

(cid:16)

S−1
↓

↓

element (point or segment), as well as on its topological relationship with its
predecessor, it decides what to add to S−1
↓ .
More in detail, there are eight possible cases, shown in Table 1, which
require zero, one, two, or three elements to be added to S−1
↓ . These are reported
in the same order in Algorithm 1. The rigorous (though cumbersome) mathe-
matical justiﬁcation for each case is instead postponed to Appendix B for the
beneﬁt of the interested reader.

We exemplify the above algorithm with reference to the example in
Figure 5. For each of the considered steps, we will reference the case in Table 1,
the line of Algorithm 1, and the relevant equations from Appendix B proving
the result. Processing each element from left to right, we calculate:

t1t2t3t4f(t1)f(t2)f(t4)ρ1ρ2ρ3timedatat1t2t3t4f(t1)f(t2)f(t4)1ρ11ρ3timedatat1t2t3t4f(t1)f(t2)f(t4)ρ1ρ2ρ3timedataSpringer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

15

↓ (0)

• The origin (t1, f (t1)) = (0, 0) for f −1
• for the segment s1 and its predecessor point p1 = (t1, f (t1)): this cor-
responds to Line 22 of the algorithm. Since s1 has a positive slope, we
continue in Line 31. As the function is right-continuous at t1, we are in
case c8. We go to Line 36 and add a segment s = (cid:0)f (t+
to
O. It can be veriﬁed that this follows Equation (39).

1 ), f (t−

2 ), t1, t2

(cid:1)

• for the point p2 = (t2, f (t2)) and its preceding segment s1, we are in
case c4, corresponding to Line 18 and we therefore append the point
p := (f (t2), t2) to O. It can be veriﬁed that this follows Equation (31).
• for the constant segment s2 with preceding point p2 = (t2, f (t2)), we are
in case c6, corresponding to Line 28, and no element is added. This follows
Equation (35).

• for the point p3 = (t3, f (t3)) with preceding constant segment s2, we are
in case c2, corresponding to Line 10, and no element is added. This follows
Equation (27).

• for a segment s3 with preceding point (t3, f (t3)), we are in case c8, Line 36,

to O (veriﬁed in Equation (39)).

and append s := (cid:0)f (t+
We note that, since S−1

3 ), f (t−

4 ), t3, t4

(cid:1)

is left-continuous, when a continuous sequence of
a point, a constant segment, and a point is encountered in S, they all “map”
to the inverse of the ﬁrst (leftmost) point of this sequence. This justiﬁes the
fact that nothing has to be added to S−1

in these cases (e.g., 2 and 6).

↓

The algorithm for S−1

↑ , that we omit here for brevity, diﬀers from the one
provided only in how constant segments are handled, that is, by appending the
inverse of the last (rightmost) point instead of the ﬁrst (recall that the upper
pseudo-inverse is right-continuous). This requires the algorithm for S−1
to look
ahead to the next element during the linear scan. We leave the (tedious, but
simple) task of spelling out the minutiae of this algorithm to the interested
reader.

↑

↓

Springer Nature 2021 LATEX template

16

Extending the NC Algorithmic Toolbox for UPP Functions

Table 1: Cases to be considered in the by-sequence algorithm to compute S−1

↓

Considered
Element

Constant
segment

Discontinuity
in S

Example of S

Append to
S−1
↓

Case #

Yes

Point
after segment

No

Yes

Segment
after point

No

Yes

No

Yes

No

Yes

No

Yes

No

nothing
to append

nothing
to append

c1

c2

c3

c4

c5

c6

c7

c8

t1t2b1b20b1b2t1t20t1t2b10t1t2b1b2b30b1b2b3t1t20t1t2b1b20b1b2t1t20t1t2b1b20b1b2t1t20t1t2b10t1t2b1b2b30b1b2b3t1t20t1t2b1b20b1b2t1t20Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

17

Algorithm 1 Pseudo-code for lower pseudo-inverse of a ﬁnite sequence

Input Finite sequence of elements S, consisting of ek, k ∈ {1, . . . , n} that

is either a point or a segment. Moreover, e1 is a point at the origin (0, 0).

Return Lower pseudo-inverse S−1

↓

of S, consisting of a sequence of

elements O = {o1, . . . , om}

1: Deﬁne an empty sequence of elements O := { }
2: Append p := (0, 0) to O
3: for ek in (e2, . . . , en) do
4:

if ek == pi then

↓ (e0)
(cid:46) The for loop starts after the origin
(cid:46) The element is a point

(cid:46) f −1

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

19:

20:

21:

22:

23:

24:

25:

26:

27:

28:

29:

30:

31:

32:

33:

34:

35:

36:

37:

38:

39:

ek−1 is a segment si−1
if si−1 is constant then

if f (t−

i ) < f (ti) then
Append s := (cid:0)f (t−
Append p := (f (ti), ti) to O

i ), f (ti), ti, ti

(cid:46) f is not left-cont. at ti
(cid:1)
(cid:46) (c1)
to O

else

Nothing to append

(cid:46) f is left-cont. at ti
(cid:46) (c2)

end if

else

if f (t−

i ) < f (ti) then
Append p := (cid:0)f (t−
Append s := (cid:0)f (t−
Append p := (f (ti), ti) to O

i ), ti
i ), f (ti), ti, ti

to O

(cid:1)

(cid:46) si−1 is not constant
(cid:46) f is not left-cont. at ti
(cid:46) (c3)

(cid:1)

to O

else

Append p := (f (ti), ti) to O

(cid:46) f is left-cont. at ti
(cid:46) (c4)

end if

end if

else

(cid:46) The element is a segment si

ek−1 is a point pi
if ek = si is constant then
i ) then
Append s := (cid:0)f (ti), f (t+
i ), ti, ti
(cid:1)
Append p := (cid:0)f (t+
to O

if f (ti) < f (t+

i ), ti

(cid:46) f is not right-cont. at ti
(cid:1)
(cid:46) (c5)

to O

else

Nothing to append

(cid:46) f is right-cont. at ti
(cid:46) (c6)

end if

else

if f (ti) < f (t+

i ) then
Append s := (cid:0)f (ti), f (t+
i ), ti, ti
(cid:1)
Append p := (cid:0)f (t+
i ), ti
to O
Append s := (cid:0)f (t+
i ), f (t−
i+1), ti, ti+1

(cid:1)

to O

(cid:46) si is not constant
(cid:46) f is not right-cont. at ti
(cid:1)
(cid:46) (c7)

to O

else

Append s := (cid:0)f (t+

i ), f (t−

i+1), ti, ti+1

(cid:46) f is right-cont. at ti
(cid:46) (c8)

to O

(cid:1)

end if

end if

end if

40:
41: end for

Springer Nature 2021 LATEX template

18

Extending the NC Algorithmic Toolbox for UPP Functions

4.3 By-curve algorithm for pseudo-inverses

We can now discuss the by-curve algorithm by combining the results presented
in Sections 4.1 and 4.2. In Algorithm 2, we show the pseudo-code to compute
f −1
for a UPP function f . The analogous for upper pseudo-inverse, which we
↓
omit for brevity, can be similarly derived from the results in the sections above.

Algorithm 2 Pseudo-code for lower pseudo-inverse of a UPP function

Input Representation Rf of a non-decreasing UPP function f , consisting

of sequence Sf and parameters Tf , df and cf .

Return Representation Rf −1

↓

of f −1
↓

1: Compute the UPP parameters for the result
2:

↓

↓

3:

← f (Tf + df )
Tf −1
← cf
df −1
← df
cf −1
4:
5: Compute SD
f
6:

↓

D ← [0, Tf + 2 · df [
SD
f ← Cut(Rf , D)
SD
f

←

(cid:16)

8: Compute Sf −1

↓

7:

(cid:16)

9: Rf −1

↓

←

Sf −1

↓

, Tf −1

↓

(cid:17)−1

↓
, df −1

↓

(cid:17)

, cf −1

↓

(cid:46) Theorem 9

(cid:46) Equation (8)

(cid:46) Algorithm 1

Regarding the complexity of Algorithm 2, we note that the main cost is

computing

. Since Algorithm 1 is a linear scan of the input sequence,

(cid:16)

(cid:17)−1

SD
f

↓

the resulting complexity is O

(cid:16)

(cid:16)

n

SD
f

(cid:17)(cid:17)

.

4.4 Corner cases: UC and wUI functions

We conclude this section by discussing the two corner cases that we had
initially left out, i.e., those when f is either UC or wUI. For these, some
mathematical inconsistencies need be resolved ﬁrst. For example:

• if f was UC, the current algorithm would yield df −1
• if f was wUI, it would yield Tf −1
We treat these two cases in the following propositions.

= +∞.

↓

↓

= 0,

Proposition 11 Let f : Q+ → Q+ be a non-decreasing, UC function with Tf ∈ Q+.
Then, its lower pseudo-inverse f −1

↓ (y) is for y ≥ f (Tf )




inf






x | f (x) ≥

=f (Tf )
(cid:122)(cid:125)(cid:124)(cid:123)y






= Tf ,

if y = f (Tf ),

sup {x | f (x) < y} = +∞,

if y > f (Tf )

f −1
↓ (y) =



Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

19

and its upper pseudo-inverse f −1

↑ (y) is for y ≥ f (Tf )

f −1
↑ (y) = sup {x | f (x) ≤ y} = +∞.

Note that, if one follows Deﬁnition 7, the result of both operators is weakly

ultimately inﬁnite, while only f −1

↑

is ultimately inﬁnite.

Proposition 12 Let f : Q+ → Q+ ∪ {+∞} be a non-decreasing, weakly ultimately
inﬁnite function with Tf ∈ Q+. We recall that this is deﬁned as

f (t) < +∞,
f (t) = +∞,

∀t < Tf ,
∀t > Tf .

Then, its lower pseudo-inverse f −1

↓ (y) is for y ≥ f

(cid:17)

(cid:16)

T −
f

f −1
↓ (y) = sup {x | f (x) < y} = Tf

and its upper pseudo-inverse f −1

↑ (y) is for y ≥ f

(cid:17)

(cid:16)

T −
f

f −1
↑ (y) = sup {x | f (x) ≤ y} = Tf .

In other words, both pseudo-inverses are UC.

Again, by using Deﬁnition 7, we show that the above property applies to

weakly ultimately inﬁnite functions, not only to ultimately inﬁnite ones.

Starting from the above results, one can derive the few modiﬁcations to the
algorithms described so far in this section to include these two corner cases.
We leave this simple (yet tedious) task to the interested reader.

5 Composition of UPP Functions

In this section, we discuss the composition operator for UPP functions, i.e.,
(f ◦g)(t) = f (g(t)). This section is organized as follows. In Section 5.1 we show
that the composition of UPP functions is again UPP, and provide expressions
to compute its UPP parameters a priori. In Section 5.2 we discuss, ﬁrst via an
example and then via pseudo-code, how to compute the composition algorith-
mically. In Section 5.3 we conclude with a summary of the by-curve algorithm
and some observations on the algorithmic complexity of this operator.

5.1 Properties of composition of UPP functions

We assume that the inner function g is not wUI.4 We initially provide the
result for generic f and g. Later on, we show that, if either or both are UA or
UC, we can improve upon this result.

4If, for t > T , g(t) = +∞ then h(t) = limy→+∞ f (y). The fact that f is UPP does not

guarantee that such limit exists, e.g., when f is periodic.

Springer Nature 2021 LATEX template

20

Extending the NC Algorithmic Toolbox for UPP Functions

Theorem 13 Let f and g be two UPP functions with g being non-negative, non-
decreasing and not wUI. Then, their composition h := f ◦ g is again UPP with
(cid:110)

(cid:111)

Th = max

g−1
↓ (Tf ), Tg

,

(12)

dh = Ndf · dg · Dcg ,
ch = Ddf · Ncg · cf .

(13)

(14)

Proof Let kh ∈ N be arbitrary but ﬁxed. Since g is UPP, it holds for all t ≥ Tg that

(cid:18)

(cid:18)

h(t + kh · dh) = f (g(t + kh · dh))
dh
dg
dh
dg

g(t) + kh ·

t + kh ·

(3)
= f

= f

(cid:18)

g

(cid:19)(cid:19)

· dg

(cid:19)

· cg

,

∈ N0,
(13)
= Ndf · Dcg ∈ N, where we used that df > 0. Moreover, since f is UPP,

where we used the UPP property of g in the last line. Note that kg := kh · dh
dg
since dh
dg
too, we have under this additional assumption of g(t) ≥ Tf that

h(t + kh · dh) = f

= f

(cid:18)

(cid:18)

g(t) + kh ·

g(t) + kh ·

(cid:19)

(cid:19)

· df

· cf

· cg

dh
dg
dh · cg
dg · df
dh · cg
dg · df
dh · cg · cf
dg · df

(3)
= f (g(t)) + kh ·

= h(t) + kh ·

(14)
= h(t) + kh · ch.

∈ N0, since dh·cg
Note that kf := kh · dh·cg
dg·df
dg·df
we used that cg ≥ 0 as g is non-decreasing.

(13)
=

Ndf
df

· Dcg · cg = Ddf · Ncg ∈ N0 and

We set t ≥ Tg and g(t) ≥ Tf , thus ensuring that both f and g are in their periodic
part. Exploiting the notion of a lower pseudo-inverse and g being non-decreasing, the
latter expression is equivalent to t ≥ g−1

↓ (Tf ) [23, p. 62]. Therefore, we require

t ≥ Th

(12)
= max

(cid:110)

g−1
↓ (Tf ), Tg

(cid:111)

.

This concludes the proof.

(cid:3)

Remark 14 Note that the above is also true for the particular case in which df ∈
N, cg ∈ N0. In fact, it follows that Ndf = df and Dcg = 1 and thus

(13)
= Ndf · Dcg · dg = df · dg,

dh

and the properties are then veriﬁed since dh
dg
corresponding ch is cf · cg.

= df ∈ N and dh·cg
dg·df

= cg ∈ N0. The

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

21

It follows from Theorem 13 that, in order to compute the representation

Rh, we only need to compute SDh

h where

Dh = [0, Th + dh[=

(cid:104)

0, max

(cid:110)

g−1
↓ (Tf ), Tg

(cid:111)

+ Ndf · dg · Dcg

(cid:104)

.

It follows that

where

h = SDf
SDh

f

◦ SDg
g

,

(15)

Dg = [0, Th + dh[
Df = (cid:2)g(0), g (cid:0)(Th + dh)−(cid:1)(cid:3)
The reason Df needs to be right-closed is that SDg

g may end with a constant
segment. If this happens, ∃t ∈ Dg so that g(t) = g ((Th + dh)−) thus we will
need to compute f (cid:0)g (cid:0)t(cid:1)(cid:1) = f (g ((Th + dh)−)), and that is in fact the right
boundary of Df . On the other hand, if SDg
ends with a strictly increasing
g
segment, it is safe to have Df right-open.

Hereafter, we show that the above result can be improved when either or

both functions are UA. First, we consider the case for which only g is UA.

Proposition 15 Let f and g be two UPP functions that are not wUI, with g
being non-negative, non-decreasing, UA, with ρg > 0 (hence not UC). Then, their
composition h := f ◦ g is again UPP with

Th = max

(cid:110)

g−1
↓ (Tf ), Tg

(cid:111)

,

,

dh =

df
ρg
ch = cf .

(16)

(17)

Proof Let kh ∈ N be arbitrary but ﬁxed. Since g is assumed to be UA, it holds for
all t ≥ Th that

h(t + kh · dh) = f (g(t + kh · dh))
(4)
= f (g(Th) + ρg · (t + kh · dh − Th))
= f (cid:0)ρg · t + g(Th) − ρg · Th + kh · df

(cid:1)

(3)
= f (ρg · t + g(Th) − ρg · Th) + kh · cf
= f (g(Th) − ρg · (t − Th)) + kh · cf
(4)
= f (g(t)) + kh · cf
= h(t) + kh · ch.

(cid:3)

Springer Nature 2021 LATEX template

22

Extending the NC Algorithmic Toolbox for UPP Functions

Again, in order to compute the representation Rh, we only need SDh

h , where

Dh = [0, Th + dh[ =

0, max

(cid:20)

(cid:110)

g−1
↓ (Tf ), Tg

(cid:111)

+

(cid:20)

.

df
ρg

It follows that

where

h = SDf
SDh

f

◦ SDg
g

,

Dg = [0, Th + dh[
(cid:20)

(cid:20)

(cid:104)

(cid:16)

(16)
=

Df =

0, Th +

df
ρg
(Th + dh)−(cid:17)(cid:104)
(cid:18)
(cid:19)(cid:20)
df
ρg
= [g(0), g (Th) + df [ .
Here, we observe that domain Df is smaller than the one obtained by applying
directly Theorem 13, due to the disappearance of a factor Ddf · Ncg ≥ 1. In
fact, with Theorem 13 we would have:

g(0), g
(cid:20)

g(0), g

Th +

(16)
=

(18)

Dg = [0, Th + dh[

(cid:2)

(cid:104)

=

(13)

0, Th + Ddf · Ncg ·

= (cid:2)0, Th + Ndf · dg · Dcg
(cid:20)
(cid:20)
df
ρg
(Th + dh)−(cid:17)(cid:104)
(cid:16)(cid:0)Th + Ndf · dg · Dcg
(cid:2) .

(13)
=
= (cid:2)g(0), g(Th) + Ddf · Ncg · df

g(0), g

g(0), g

(cid:16)

(cid:104)

Df =

(cid:1)−(cid:17)(cid:104)

As speciﬁed in the statement of Proposition 15, we exclude the case for
which g is UC. This is because of Equation (16) where ρg is in the denominator,
hence cannot be zero. However, if g is UC, a stronger proposition can be found
as reported in Appendix C.

Next, we consider the case in which only f is UA.

Proposition 16 Let f be UA and g be an UPP function that is non-negative, non-
decreasing and not wUI. Then, their composition h := f ◦ g is again UPP with

Th = max

(cid:110)

g−1
↓ (Tf ), Tg

(cid:111)

dh = dg,
ch = cg · ρf .

(19)

(20)

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

23

Proof Let kh ∈ N be arbitrary but ﬁxed. Since f is assumed to be UA, it holds for
all t ≥ Th that

h(t + kh · dh) = f (g(t + kh · dh))
(3)
= f (g(t) + kh · cg)
(4)
= f (g(Th)) + ρf · (g(t) + kh · cg − g(Th))
= f (g(Th)) + ρf · (g(t) − g(Th)) + kh · cg · ρf
(4)
= f (g(t)) + kh · cg · ρf
= h(t) + kh · ch.

Again, for the representation Rh, we only compute SDh

h , where

Dh = [0, Th + dh[ =

(cid:104)

0, max

(cid:110)

g−1
↓ (Tf ), Tg

(cid:111)

(cid:104)

.

+ dg

It follows that

where

h = SDf
SDh

f

◦ SDg
g

,

Dg = [0, Th + dh[

(19)
= [0, Th + dg[

Df =

(cid:104)

g(0), g

(cid:16)

(cid:104)

(19)
=

g(0), g

(Th + dh)−(cid:17)(cid:105)
(Th + dg)−(cid:17)(cid:105)
(cid:16)

.

(cid:3)

(21)

Again, domain Dg is smaller than the one that Theorem 13 would yield, due
to the disappearance of a factor Ndf · Dcg ≥ 1. For comparison, Theorem 13
yields

Dg = [0, Th + dh[

Df =

(13)

(cid:2)

(cid:16)

= (cid:2)0, Th + Ndf · Dcg · dg
(cid:104)
(Th + dh)−(cid:17)(cid:105)
(cid:16)(cid:0)Th + Ndf · dg · Dcg

g(0), g

g(0), g

(cid:104)

(13)
=

(cid:1)−(cid:17)(cid:105)

.

When both functions are UA, we obtain a stronger result by showing that

the composition is UA again.

Proposition 17 Let f and g be UA functions with g being non-negative, non-
decreasing and not wUI. Then, their composition h := f ◦ g is again UA with

T a
h = max

(cid:110)

g−1
↓ (T a

f ), T a
g

(cid:111)

,

ρh = ρf · ρg.

(22)

Springer Nature 2021 LATEX template

24

Extending the NC Algorithmic Toolbox for UPP Functions

Proof If f is ultimately −∞ or +∞ or if g is ultimately +∞, the result is trivial.
Let us assume that f and g are not wUI. Deﬁne T a
. Then
we have that for any t ≥ T a
h
h(t + T a

h := max

g−1
↓ (T a

f ), T a
g

(cid:110)

(cid:111)

h )(cid:1)

h ) = f (cid:0)g(t + T a
(4)
= f (cid:0)g(T a
(4)
= f (g(T a
= f (g(T a
= h(T a

h ) + ρg · (t − T a
h )) + ρf · (cid:0)(cid:0)g(T a
h )) + ρf · ρg · (t − T a
h )
h ) + ρf · ρg · (t − T a
h ).

h )(cid:1)
h ) + ρg · (t − T a

h )(cid:1) − g(T a

h )(cid:1)

(cid:3)

Considering Equation (15), we observe how taking these results into

account will yield tighter Df , Dg than what we obtain with Theorem 13.

Finally, we mention that, if either or both f and g are UC, then the com-
position can be simplifed further, even with respect to the above properties.
We report the results in Appendix C.

5.2 By-sequence algorithm for composition

In this section, we discuss the by-sequence algorithm for the composi-
tion. Without loss of generality, we focus on sequences Sg, representing a
non-negative and non-decreasing function g over an interval [0, t[, and Sf ,
representing a function f deﬁned on over the interval [g(0), g(t−)].5 Then,
Sh = Sf ◦ Sg is the sequence representing h = f ◦ g over the interval [0, t[. We
use the example shown in Figure 6, where t = 6 and g(t−) = 4.

First, we consider the shape of f ◦ g on an interval ]a, b[ ⊂ [0, t[, a, b ∈ Q+.

Consider the case in which, for this interval, there exist ρg, ρf ∈ Q+ so that

g(x) = g(a+) + ρg · (x − a),
f (x) = f (cid:0)g(a+)+(cid:1) + ρf · (cid:0)x − g(a+)(cid:1) ,

∀x ∈ ]a, b[ ,

∀x ∈ (cid:3)g(a+), g(b−)(cid:2) ,

(23)

where we use the shorthand notation

f (cid:0)g(a+)+(cid:1) = lim
x→a+

f (g(x)) = lim
y→y0

f (y),

with y0 := limx→a+ g(x).

More broadly speaking, we have segment of g mapping to a segment of f .
In the example of Figure 6, ]4, 6[ is such an interval. Then, in this interval we
can apply the chain rule and ﬁnd that h(cid:48)(x) = f (cid:48)(g(x)) · g(cid:48)(x) = ρg · ρf for all
x ∈ ]a, b[. Thus, h also a segment on ]a, b[.

If either of the equations in (23) does not apply, it means that one function
has one or more breakpoints over this interval. Assume initially that this be

5We consider Df to be always right-closed since it yields the correct result for both cases
discussed in the previous section. The right boundary of Df is never used as a breakpoint in the
algorithm anyway, as imposed by the condition ym < g(b−) discussed below.

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

25

(a) Sf

(b) Sg

(c) Sf ◦ Sg

Fig. 6: Example of composition of two sequences

g. Let this ﬁnite sets of breakpoints be t0, . . . , tn, with a < t0 < · · · < tn < b.
Then, the intervals ]a, t0[ , . . . , ]tn, b[ verify the properties in Equation (23)
while for any breakpoint ti we can just compute f (g(ti)). A similar reason-
ing can be done for f : consider the ﬁnite set of breakpoints y0, . . . , ym, with
g(a+) < y0 < · · · < ym < g(b−). Then, we can use the lower pseudo-inverse of
(cid:9)
g to ﬁnd the corresponding ti = g−1
,
preserving the ascending order, deﬁnes a ﬁnite set of breakpoints for f ◦ g.
Then, we have again a ﬁnite set of points (ti, f (g(ti))), and open intervals for
which we compute h as a segment with ρh = ρf ·ρg. In the example of Figure 6,
]0, 4[ is such an interval:

↓ (yi).6 The set {t1, . . . , tn} ∪ (cid:8)t1, . . . , tm

• for Sg we ﬁnd the set {t1 = 1}
• for Sf we ﬁnd the set {y1 = 1} → (cid:8)t1 = 1
• the combined set of breakpoints is then

that verify Equation (23) is

(cid:8)(cid:3)0, 1

(cid:2) , (cid:3) 1

2

(cid:9)
2
2 , 1(cid:9)
(cid:8) 1
2 , 1(cid:2) , ]1, 4[(cid:9)

, and the open intervals

By generalizing this reasoning, we obtain Algorithm 3.

6Following the discussion in Section 4, (Sg)−1

↓

is suﬃcient for this computation.

0124134timedata014624timedata00.5146134timedataSpringer Nature 2021 LATEX template

26

Extending the NC Algorithmic Toolbox for UPP Functions

Algorithm 3 Pseudo-code for the composition of ﬁnite sequences

Input Two ﬁnite sequences of elements, Sf of f and Sg of g, so that Sg

deﬁned on [0, a[ and Sf deﬁned on [g(0), g(a−)].

Return Composition Sh = Sf ◦ Sg consisting of a sequence of elements

O = {o1, . . . , om}

Add the time ti of pi to T

1: Deﬁne an empty sequence of elements O := { }
2: Let T be an empty, but ordered set of distinct rationals
3: Let Pg be the set of points of Sg
4: for pi in Pg do
5:
6: end for
7: Let Pf be the set of points of Sf , excluding the last point g(a−)
8: for pi in Pf do
9:
10: end for
11: for each pair of consecutive (ti, ti+1) in T do
12:

Given time ti of pi, add ti = g−1

Append p := (ti, f (g(ti))) to O
Append s := (cid:0)ti, ti+1, f (cid:0)g(t+

i )+(cid:1) , f (cid:0)g(t−

i+1)−(cid:1)(cid:1)

to O

13:
14: end for

↓ (ti) to T (cid:46) preserving the order in T

5.3 By-curve algorithm for composition

We can now discuss the by-curve algorithm, by combining the results presented
in Sections 5.1 and 5.2. In Algorithm 4 we show the pseudo-code to compute
the composition h = f ◦ g of UPP functions f and g, in the most general
case. The analogous for the more specialized cases, i.e., ultimately aﬃne or
ultimately constant operands, which here we omit for brevity, can be similarly
derived by adjusting the parameters and domains computations.

◦ SDg
g

Regarding the complexity of Algorithm 4, we note that the main cost is
and

. Since Algorithm 3 is a linear scan of SDf
f
(cid:16)
SDg
g

computing Sh ← SDf
f
SDg
, the resulting complexity is O
. Note that given the
g
expressions in Theorem 13, this computational cost highly depends on the
numerical properties of the operands, i.e., numerators and denominators of
UPP parameters, rather than simply the cardinalities of Rf and Rg. Thus,
using the specialized properties of Propositions 15 to 17 yields performance
improvements, since Df and Dg are smaller.

SDf
f

+ n

(cid:17)(cid:17)

(cid:17)

(cid:16)

(cid:16)

n

We remark again that the result of the composition may have a non-

minimal representation (see the discussion at the end of Section 4.1).

6 Proof of Concept

In this section, we show how the algorithms computed in this paper allow one
to replicate the result appeared in a recent NC paper [24].

The algorithms described in this paper, including variants and corner
cases omitted for brevity, are implemented in the publicly available Nancy

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

27

Algorithm 4 Pseudo-code for composition of UPP functions.

Input Representation Rf of a UPP function f , consisting of sequence Sf
and parameters Tf , df and cf ; Representation Rg of a non-negative and non-
decreasing UPP function g, consisting of sequence Sg and parameters Tg, dg
and cg

Return Representation Rh of h = f ◦ g
1: Compute the UPP parameters for the result

2:

3:

7:

8:

4:
5: Compute SDf
f
6:

(cid:110)

(cid:111)

g−1
↓ (Tf ), Tg

Th ← max
dh ← Ndf · dg · Dcg
ch ← Ddf · Ncg · cf
and SDg
g
Df ← [g(0), g ((Th + dh)−) [
SDf
f ← Cut(Rf , Df )
Dg ← [0, Th + dh[
SDg
g ← Cut(Rg, Dg)

9:
10: Compute Sh ← SDf
f
11: Rh ← (Sh, Th, dh, ch)

◦ SDg
g

(cid:46) Theorem 13

(cid:46) Equation (15)

(cid:46) Algorithm 3

NC library [29]. Nancy is a C# library implementing the UPP model and
its operators, as described in [19, 20]. Moreover, it implements state-of-the-
art algorithms that improve the eﬃciency of NC operators, described in [30],
and lower pseudo-inverse, upper pseudo-inverse and composition operators,
described in this paper. Nancy makes extensive use of parallelism. However,
the NC operators described in this paper are implemented as sequential.

As a notable example, we implemented the results from [24, Theorem 1],
which uses the composition operator, using the same parameters of the example
in [24, Figure 3]. The above theorem allows us to compute the service curve
for a ﬂow served by an Interleaved Weighted Round-Robin scheduler, once
a) the weight of the ﬂow; b) the minimum and maximum packet length for
each ﬂow, and c) the (strict) service curve for the entire aggregate of ﬂows
β(t) are known. The complete formulation of the theorem – which is rather
cumbersome – is postponed to Appendix D. For the purpose of this proof of
concept, the important bit is that computing the service curve of the ﬂow
involves computing a function γi that takes into account ﬂow i’s characteristics
(e.g., weight, packet lengths), and then, given β as the (strict) service curve
of the server regulated by IWRR, compute the (strict) per-ﬂow service curve
for ﬂow i as βi = γi ◦ β.7 In the example in [24, Figure 3], β is a constant-
rate service curve, thus UA, while γi is, in general, a UPP function. On the
one hand, this conﬁrms that limiting NC algorithms to UA curves only is
severely constraining – in this example, one could not compute ﬂow i’s service
curve without an algorithm that handles UPP curves. On the other hand, it

7Recall that composition requires the lower pseudo-inverse of the inner function to be computed,

hence this example makes use of both the algorithms presented in this paper.

Springer Nature 2021 LATEX template

28

Extending the NC Algorithmic Toolbox for UPP Functions

Table 2: Performance comparison of composition with and without UA
optimization.

Runtime
75th percentile
median
25th percentile

Not optimized Optimized

1117.72 ms
1105.01 ms
1088.61 ms

0.67 ms
0.55 ms
0.50 ms

means that we can obtain the same result by applying both Theorem 13 and
its specialized version for UA inner functions Proposition 15, and that we can
expect the latter to be more eﬃcient due to the tighter Df , as explained below
Equation (18).

Our experiments conﬁrm the above intuition. We run the computation on
a laptop computer (i7-10750H, 32 GB RAM). As shown in Table 2, when using
Theorem 13, computing the result took a median of 1.11 seconds. On the other
hand, using Proposition 15 the same result is obtained in 0.55 milliseconds in
the median, an improvement of three orders of magnitude. Figures 7 and 8
report the code used and the resulting plot.

It is worth noting that [25, Theorem 1] describes a similar result for the
Deﬁcit Round-Robin scheduler, under similar hypotheses, still making use
of composition, with the outer curve being non-UA. The derivations in this
section apply to this case as well, with minimal obvious modiﬁcations. Several
other results in [25] make use of composition as well.

7 Conclusions

Automated computation of Network Calculus operations is necessary to carry
out analyses of non-trivial network scenarios. Therefore, algorithms that trans-
form representations of operand functions into result functions are required
for each "useful" NC operator. Recently, pseudo-inverses and composition
operators have been repeatedly use in NC papers. To the best of our knowl-
edge, these operators lacked an algorithmic description that would allow their
implementation in software.

This paper ﬁlls the above gap, by providing algorithms for lower and upper
pseudo-inverses and composition of operators. We have presented algorithms
that work under general assumptions (i.e., UPP operands), as well as special-
ized ones that leverage the fact that operands are UA (or UC) to compute
results faster. We have discussed the complexity of these algorithms, as well as
corner cases, with a rigorous mathematical exposition. Beside the theoretical
contribution, we provided a practical one by including the above algorithms
(together with the others known from the literature) in an open-source free
library called Nancy. This allows researchers to experiment with our results to
study complex scenarios, or support the generation of novel theoretical insight.
Future work on this topic will include studying the computational and
numerical properties of NC operators. As the example in Section 6 shows (not
to mention those in [30], by the same authors), exploiting more knowledge on

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

29

Fig. 7: Code used to replicate the results of [25, Theorem 1].

Fig. 8: Plot of the resulting service curve βi.

Springer Nature 2021 LATEX template

30

Extending the NC Algorithmic Toolbox for UPP Functions

the operands allows one to compute the same results via specialized versions
of the algorithms, often in considerably shorter times (some by orders of mag-
nitude). We believe that this is an avenue of research worth pursuing, with the
aim of enabling larger-scale real-world performance studies.

8 Acknowledgements

This work was partially supported by the Italian Ministry of Education and
Research (MIUR) in the framework of the CrossLab project (Departments
of Excellence), and by the University of Pisa, through grant “Analisi di reti
complesse: dalla teoria alle applicazioni” - PRA 2020.

References

[1] Cruz, R.L., et al.: A calculus for network delay, part I: Network elements
in isolation. IEEE Transactions on information theory 37(1), 114–131
(1991)

[2] Cruz, R.L.: A calculus for network delay, part II: Network analysis. IEEE

Transactions on information theory 37(1), 132–141 (1991)

[3] Le Boudec, J.-Y., Thiran, P.: Network Calculus: a Theory of Deterministic
Queuing Systems for the Internet. Springer, Berlin, Germany (2001)

[4] Chang, C.-S.: Performance Guarantees in Communication Networks.

Springer, New York, USA (2000)

[5] Le Boudec, J.-Y.: Application of network calculus to guaranteed service
networks. IEEE Transactions on Information theory 44(3), 1087–1096
(1998)

[6] Firoiu, V., Le Boudec, J.-Y., Towsley, D., Zhang, Z.-L.: Theories and
models for internet quality of service. Proceedings of the IEEE 90(9),
1565–1591 (2002)

[7] Le Boudec, J.-Y.: Application of network calculus to guaranteed service
networks. IEEE Transactions on Information Theory 44(3), 1087–1096
(1998). https://doi.org/10.1109/18.669170

[8] Bennett, J.C., Benson, K., Charny, A., Courtney, W.F., Le Boudec,
J.-Y.: Delay jitter bounds and packet scale rate guarantee for expe-
dited forwarding. IEEE/ACM Transactions on networking 10(4), 529–540
(2002)

[9] Fidler, M., Sander, V.: A parameter based admission control for diﬀeren-
tiated services networks. Computer Networks 44(4), 463–479 (2004)

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

31

[10] Schmitt, J.B., Roedig, U.: Sensor network calculus–a framework for worst
case analysis. In: International Conference on Distributed Computing in
Sensor Systems, pp. 141–154 (2005). Springer

[11] Charara, H., Scharbarg, J.-L., Ermont, J., Fraboul, C.: Methods for
bounding end-to-end delays on an afdx network. In: 18th Euromicro
Conference on Real-Time Systems (ECRTS’06), p. 10 (2006). IEEE

[12] Bauer, H., Scharbarg, J.-L., Fraboul, C.: Worst-case end-to-end delay
analysis of an avionics afdx network. In: 2010 Design, Automation & Test
in Europe Conference & Exhibition (DATE 2010), pp. 1220–1224 (2010).
IEEE

[13] Zhang, J., Chen, L., Wang, T., Wang, X.: Analysis of tsn for industrial
automation based on network calculus. In: 2019 24th IEEE International
Conference on Emerging Technologies and Factory Automation (ETFA),
pp. 240–247 (2019). IEEE

[14] Maile, L., Hielscher, K.-S., German, R.: Network calculus results for
tsn: An introduction. In: 2020 Information Communication Technologies
Conference (ICTC), pp. 131–140 (2020). IEEE

[15] Zhao, L., Pop, P., Zheng, Z., Daigmorte, H., Boyer, M.: Latency analysis
of multiple classes of AVB traﬃc in TSN with standard credit behavior
using network calculus. IEEE Trans. Ind. Electron. 68(10), 10291–10302
(2021). https://doi.org/10.1109/TIE.2020.3021638

[16] Rehm, F., Seitter, J., Larsson, J.-P., Saidi, S., Stea, G., Zippo, R., Ziegen-
bein, D., Andreozzi, M., Hamann, A.: The road towards predictable
automotive high-performance platforms. In: 2021 Design, Automation &
Test in Europe Conference & Exhibition (DATE), pp. 1915–1924 (2021).
IEEE

[17] Andreozzi, M., Conboy, F., Stea, G., Zippo, R.: Heterogeneous systems
modelling with adaptive traﬃc proﬁles and its application to worst-case
analysis of a dram controller. In: 2020 IEEE 44th Annual Computers,
Software, and Applications Conference (COMPSAC), pp. 79–86 (2020).
IEEE

[18] Boyer, M., Graillat, A., de Dinechin, B.D., Migge, J.: Bounding the
delays of the MPPA network-on-chip with network calculus:models and
benchmarks. Perform. Evaluation 143, 102–124 (2020). https://doi.org/
10.1016/j.peva.2020.102124

[19] Bouillard, A., Thierry, É.: An algorithmic toolbox for network calculus.

Discrete Event Dynamic Systems 18(1), 3–49 (2008)

Springer Nature 2021 LATEX template

32

Extending the NC Algorithmic Toolbox for UPP Functions

[20] Bouillard, A., Boyer, M., Le Corronc, E.: Deterministic Network Calculus:

From Theory to Practical Implementation. Wiley, Hoboken, NJ (2018)

[21] Bouillard, A., Cottenceau, B., Gaujal, B., Hardouin, L., Lagrange, S.,
Lhommeau, M., Thierry, E.: Coinc library: a toolbox for the network
calculus

[22] RealTime-at-Work: RTaW-Pegase

(min,+)

library.

https://www.

realtimeatwork.com/rtaw-pegase-libraries/. Accessed: 2022-04-05

[23] Liebeherr, J.: Duality of the max-plus and min-plus network calculus.
Foundations and Trends in Networking 11(3-4), 139–282 (2017). https:
//doi.org/10.1561/1300000059

[24] Tabatabaee, S.M., Le Boudec, J.-Y., Boyer, M.: Interleaved weighted
round-robin: A network calculus analysis. IEICE Transactions on Com-
munications 104(12), 1479–1493 (2021)

[25] Tabatabaee, S.M., Le Boudec, J.-Y.: Deﬁcit round-robin: A second net-

work calculus analysis. IEEE/ACM Transactions on Networking (2022)

[26] Mohammadpour, E., Stai, E., Boudec, J.-Y.L.: Improved delay bound for
a service curve element with known transmission rate. IEEE Networking
Letters 1(4), 156–159 (2019)

[27] Mohammadpour, E., Stai, E., Boudec, J.-Y.L.: Improved network calculus
delay bounds in time-sensitive networks. arXiv preprint arXiv:2204.10906
(2022)

[28] IEEE: Time-sensitive networking (TSN) task group. [Online]. https://1.

ieee802.org/tsn/. Accessed: 2022-05-16

[29] Zippo, R., Stea, G.: Nancy: an eﬃcient parallel Network Calculus library.

http://arxiv.org/abs/2205.11449 (2022)

[30] Zippo, R., Stea, G.: Computationally eﬃcient worst-case analysis of ﬂow-
controlled networks with Network Calculus. https://arxiv.org/abs/2203.
02497 (2022)

[31] Boyer, M., Stea, G., Sofack, W.M.: Deﬁcit round robin with network
calculus. In: 6th International ICST Conference on Performance Eval-
uation Methodologies and Tools, Cargese, Corsica, France, October
9-12, 2012, pp. 138–147 (2012). https://doi.org/10.4108/valuetools.2012.
250202. https://doi.org/10.4108/valuetools.2012.250202

[32] Bondorf, S., Schmitt, J.B.: The DiscoDNC v2 – a comprehensive tool for
deterministic network calculus. In: Proc. of the International Conference

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

33

on Performance Evaluation Methodologies and Tools. ValueTools ’14, pp.
44–49 (2014). https://dl.acm.org/citation.cfm?id=2747659

[33] Guan, N., Yi, W.: Finitary real-time calculus: Eﬃcient performance anal-
ysis of distributed embedded systems. In: 2013 IEEE 34th Real-Time
Systems Symposium, pp. 330–339 (2013)

[34] Lampka, K., Bondorf, S., Schmitt, J.B., Guan, N., Yi, W.: Generalized
ﬁnitary Real-Time calculus. In: Proc. of the 36th IEEE International
Conference on Computer Communications (INFOCOM 2017) (2017)

Springer Nature 2021 LATEX template

34

Extending the NC Algorithmic Toolbox for UPP Functions

A Properties of Ultimately Aﬃne Functions

Proposition 18 A function f is ultimately aﬃne iﬀ there exist T ∈ Q+, σ, ρ ∈ Q
such that

f (t) ∈ {ρt + σ, −∞, +∞}

∀t > T.

(24)

Proof “⇒”
Let f be ultimately aﬃne. Deﬁne T = T a
all t > T that

f , σ = f (T a

f ) and ρ = ρf . Then, it holds for

f (t) = f (cid:0)t − T a

f + T a
f

(cid:1) = f (T a

f ) + ρf · t = σ + ρt.

“⇐”
Assume f to verify the condition in Equation (24). If f (t) ∈ {−∞, +∞} , the
proof is trivial. Let us therefore assume that f (t) = ρt + σ for all t > T . Deﬁne
T a
f = T, ρf = ρ. Then for all t > 0

f (t + T a

f ) = σ + ρf

(cid:0)t + T a
f

This concludes the proof.

(cid:1) = (cid:0)ρf T a

f + σ(cid:1) + ρf t = f (T a

f ) + ρf t.

(cid:3)

B Calculation of Lower Pseudo-Inverses

We report here the rigorous mathematical derivations for cases c1-c8 in Table 1.

Point after segment (cases c1-c4)

In these cases we have, in general, an f such that

f (x) =






b1 + ρ (x − t1) ,
b2,
b3

if t1 < x < t2,
if x → t−
2
if x = t2

Since f is non-decreasing, b1 + ρ (x − t1) ≤ b2 ≤ b3 for all x ∈ ]t1, t2[.

We then classify based on two properties:
• Whether the segment is constant, i.e., ρ = 0 → b1 = b2
• Whether there is a discontinuity at t2, i.e., b2 < b3

Case c1: ρ = 0 and b1 = b2 < b3 (constant segment followed by a
discontinuity).

It holds that

f −1
↓ (y) =






inf {x | f (x) ≥ y} = t2,






inf

x | f (x) ≥ y

= t2,

if b1 < y < f (t2) = b2,

if y = f (t2) = b2.

(25)



(cid:124)(cid:123)(cid:122)(cid:125)
=b2



Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

35

and

f −1
↑ (y) =






(cid:40)

sup

x | f (x) ≤

(cid:41)

=b
(cid:122)(cid:125)(cid:124)(cid:123)y

= t2,

sup {x | f (x) ≤ y} = t2,






inf






> y

x | f (x)
(cid:124)(cid:123)(cid:122)(cid:125)
=b2

if y = b1 = f (t+

1 ),

if b1 = f (t+

1 ) < y < f (t2),

= sup {x | f (x) ≤ y} = t2

if y = f (t2) = b2.

(26)

Case c2: ρ = 0 and b1 = b2 = b3 (constant segment without any
discontinuity).

It holds that

f ↓(y) = inf

=b1
(cid:122)(cid:125)(cid:124)(cid:123)
f (x) ≥ y

x |











= t1, if y = b1

(27)

(however, we do not add a value as it is processed in the “segment after point”-
section) and

f −1
↑ (y) := sup






≤ y

x | f (x)
(cid:124)(cid:123)(cid:122)(cid:125)
=b1






= t1, if y = b1

(28)

Case c3: ρ > 0 and b2 < b3 (non-constant segment followed by a
discontinuity).

f −1
↓ (y) =






inf {x | f (x) ≥ y} = t2,
inf {x | f (x) ≥ y} = t2,






inf

x | f (x) ≥ y

= t2,

(cid:124)(cid:123)(cid:122)(cid:125)
b3







and

f −1
↑ (y) =






inf {x | f (x) > y} = t2,
inf {x | f (x) > y} = t2,






inf

x | f (x) > y

= t2,

(cid:124)(cid:123)(cid:122)(cid:125)
b3



if y = b1 + r (t2 − t1) = f (t−
2 )
if f (t−
2 ) < y < f (t2) = b3

y = f (t2) = b3

(29)

if y = b1 + r (t2 − t1) = f (t−
2 )
if f (t−
2 ) < y < f (t2) = b3

y = f (t2) = b3.

(30)

Springer Nature 2021 LATEX template

36

Extending the NC Algorithmic Toolbox for UPP Functions

Case c4: ρ > 0 and b2 = b3 (non-constant segment without any
discontinuity).

and

f −1
↓ (y) = inf






x | f (x) ≥ y

(cid:124)(cid:123)(cid:122)(cid:125)
b2






f −1
↑ (y) = inf






x | f (x) > y

(cid:124)(cid:123)(cid:122)(cid:125)
b2






= t2, y = f (t2) = b2

(31)

= t2, y = f (t2) = b2.

(32)

Segment after point (cases 5-8)

In these cases we have, in general, an f such that

f (x) =






b1,
b2,
b2 + ρ (x − t1) ,

x = t1,
x → t+
1 ,
t1 < x < t2.

We then classify based on two properties:
• Whether the segment is constant, i.e., ρ = 0 → b2 = b3
• Whether there is a discontinuity at t1, i.e., b1 (cid:54)= b2

Case c5: b1 < b2 = b3 and ρ = 0 (discontinuity followed by a constant
segment).

It holds that

f −1
↓ (y) =






and

f −1
↑ (y) =






inf {x | f (x) ≥ y} = sup {x | f (x) < y} = t1,






inf

x | f (x) ≥ y

= t1,



(cid:124)(cid:123)(cid:122)(cid:125)
=b1



if b1 < y < f (t+

1 ) = b2,

if y = f (t+

1 ) = b2

(33)

inf {x | f (x) > y} = sup {x | f (x) ≤ y} = t1,






inf {x | f (x) > y} = sup

x | f (x) ≤ y



= t2,

(cid:124)(cid:123)(cid:122)(cid:125)
=b1



if b1 < y < f (t+

1 ) = b2,

if y = f (t+

1 ) = b2

(34)

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

37

Case c6: b1 = b2 = b3 and ρ = 0 (no discontinuity and a constant
segment).

Then it holds that

f −1
↓ (y) = inf

=b1
(cid:122)(cid:125)(cid:124)(cid:123)
f (x) ≥ y

x |











= t1, if y = b1

(35)

(however, we do not add a value as it is processed in the “point after segment”-
section) and

f −1
↑ (y) := sup






≤ y

x | f (x)
(cid:124)(cid:123)(cid:122)(cid:125)
=b1






= t2, if y = b1.

(36)

Case c7: b1 < b2 and ρ > 0 (discontinuity followed by a
non-constant segment).

Then,

f −1
↓ (y) =






inf {x | f (x) ≥ y} = t1,






inf

x | f (x) ≥ y

= t1,



(cid:124)(cid:123)(cid:122)(cid:125)
=b2
inf {x | b2 + ρ (x − t1) ≥ y} = y−b2
ρ ,



if b1 < y < f (t−

1 ) = b2,

if y = f (t−

1 ) = b2

if b2 < y < b3

(37)

and

f −1
↑ (y) =



inf {x | f (x) > y} = t1,

inf {x | f (x) > y} = sup



inf {x | b2 + ρ (x − t1)} = y−b2
ρ ,






x | f (x) ≤ y

(cid:124)(cid:123)(cid:122)(cid:125)
=b2

if b1 < y < b2,

= t1,

if y = b2






if b2 < y < b3.
(38)

Case c8: b1 = b2 and ρ > 0 (no discontinuity and non-constant
segment).

Then,

f −1
↓ (y) = inf {x | b1 + ρ (x − t1) ≥ y} =

y − b1
ρ

, if b1 = f (t+

1 ) < y < f (t−

2 ) = b2

(39)

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

38

and

f −1
↑ (y) = inf {x | b1 + ρ (x − t1) > y} =

y − b1
ρ

, if b1 = f (t+

1 ) < y < f (t−

2 ) = b2.

(40)

C Composition of Ultimately Constant

Functions

Proposition 19 Let f and g be two ultimately pseudo-periodic (UPP) functions
that are not wUI with g being non-negative, non-decreasing and ultimately constant
(UC). Then, their composition h := f ◦ g is again UC with

Th = Tg.

Proof For t ≥ Tg, it holds that

h(t) = f (g(t)) = f (g(Tg)) = h(Th).

(41)

(cid:3)

Proposition 20 Let f be UC and g be UPP function that is non-negative and non-
decreasing. Then, their composition h := f ◦ g is again UC with

Th = g−1

↓ (Tf ).

Proof For t ≥ g−1

↓ (Tf ), it holds that

h(t) = f (g(t)) = f (Tf ) = h(Th).

(42)

(cid:3)

Proposition 21 Let f and g be UC functions with g being non-negative, non-
decreasing. Then, their composition h := f ◦ g is again UC with

Th = min

(cid:110)
Tf , g−1

↓ (Tf )

(cid:111)

.

Proof The proof is simply a combination of the previous two propositions.

D Service Curve of a Flow in Interleaved

Weighted Round Robin

(43)

(cid:3)

We report here the statement of Theorem 1 in [24], for ease of reference. We
slightly rephrased it to aid comprehension.

Springer Nature 2021 LATEX template

Extending the NC Algorithmic Toolbox for UPP Functions

39

Theorem 22 (Strict Per-Flow Service Curves for IWRR) Assume n ﬂows arriv-
ing at a server performing interleaved weighted round robin (IWRR) with weights
w1, . . . , wn. Let lmin
denote the minimum and maximum packet size of the
respective ﬂow. Let this server oﬀer a super-additive strict service curve β to these
n ﬂows. Then,

and lmax
j

i

βi(t) := γi (β(t)) ,

is a strict service curve for ﬂow fi, where

γi(t) := β1,0 ⊗ Ui (t),
wi−1
(cid:88)

Ui(t) :=

νlmin

i

k=0

Ltot := wilmin

i +

(cid:18)(cid:104)

t − ψ

(cid:16)
klmin
i

(cid:17)(cid:105)+(cid:19)

,

wj lmax
j

,

,Ltot

(cid:88)

j:j(cid:54)=i
(cid:32)(cid:36)

φij

(cid:88)

(cid:37)(cid:33)

lmax
j

,

x
lmin
i

ψi(x) := x +

φij (p) :=

(cid:22) p
wi

j(cid:54)=i
(cid:23)

wj + (cid:2)wj − wi

(cid:3)+

+ min (cid:8)(p mod wi) + 1, wj

(cid:9) ,

β1,0 is a constant-rate function with slope 1, and the stair function νh,P (t) is deﬁned
as
(cid:25)

νh,P (t) := h

,

for t ≥ 0.

(cid:24) t
P

