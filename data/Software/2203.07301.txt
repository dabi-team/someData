2
2
0
2

y
a
M
4
2

]
h
p
-
t
n
a
u
q
[

2
v
1
0
3
7
0
.
3
0
2
2
:
v
i
X
r
a

Psitrum: An Open Source Simulator for Universal
Quantum Computers

Mohammed Alghadeera,b,∗, Eid Aldawsaric, Raja Selvarajand, Khaled
Alutaibic, Sabre Kaisd, Fahhad H Alharbib

aDepartment of Physics, King Fahd University of Petroleum and
Minerals, Dhahran, 31261, Saudi Arabia
bDepartment of Electrical Engineering, King Fahd University of Petroleum and
Minerals, Dhahran, 31261, Saudi Arabia
cDepartment of Information and Computer Science, King Fahd University of Petroleum
and Minerals, Dhahran, 31261, Saudi Arabia
dDepartment of Chemistry, Department of Physics and Astronomy, and Purdue Quantum
Science and Engineering Institute, Purdue University, West Lafayette, IN, 47907, USA

Abstract

Quantum computing is a radical new paradigm for a technology that is ca-
pable to revolutionize information processing. Simulators of universal quan-
tum computer are important for understanding the basic principles and
operations of the current noisy intermediate-scale quantum (NISQ) proces-
sors, and for building in future fault-tolerant quantum computers. In this
work, we present simulation of universal quantum computers by introduc-
ing Psitrum – a universal gate-model quantum computer simulator imple-
mented on classical hardware. The simulator allows to emulate and debug
quantum algorithms in form of quantum circuits for many applications with
the choice of adding variety of noise modules to simulate decoherence in
quantum circuits. Psitrum allows to simulate all basic quantum operations
and provides variety of visualization tools. The simulator allows to trace
out all possible quantum states at each stage M of an N-qubit implemented
quantum circuit. Psitrum software and source codes are freely available at:
https://github.com/MoGhadeer/Psitrum.

Keywords: Quantum computation, quantum simulation, universal
quantum circuit simulators, quantum algorithms

∗modghadeer@gmail.com

 
 
 
 
 
 
1. Introduction

Quantum computation is a radical new candidate for a technology that
is capable to make a paradigm shift in information processing [1]. Quantum
computers are now a reality with available quantum testbeds and variety of
quantum algorithms [2]. Computation based on quantum algorithms have
proved to be more eﬃcient in processing information and solving wide range
of complex problems [3, 4]. Quantum simulators can be designed using quan-
tum algorithms represented by quantum circuits and based on mathematical
unitary operations [5]. In this sense, simulators are special purpose quantum
circuits designed to provide insight about speciﬁc physical problems. Variety
of universal logic gates based on quantum mechanics can be combined to
provide very powerful computing features [6]. Such simulators permit under-
standing quantum systems that are challenging to study in laboratories and
impossible to model with the most powerful supercomputers [7, 8].

Universal quantum simulators are based on a quantum computer pro-
posed by Yuri Manin in 1980 [9] and Richard Feynman in 1982 [10]. Feynman
showed that a Classical Turing Machine (CTM) would not be able to sim-
ulate complex quantum systems because of the huge amount of information
contained with exponential increase in the required size of computational
bits, while his hypothetical universal quantum computer can mimic many
quantum eﬀects, such as superposition and entanglement, which allows to
eﬃciently simulate quantum systems [11]. Quantum properties have shown
to signiﬁcantly enhance simulation power and computational speed when
implemented in quantum algorithms [12, 13].

Quantum simulators may be constructed with generally programmable
quantum computers [14], which would be capable for solving a wider class
of problems using both classical and quantum algorithms. The later can
be deﬁned as a ﬁnite sequence of steps for solving a problem in which each
step can be executed on a quantum computer. [15, 16]. Instead, a quantum
computer simulator can be implemented on the currently available classical
hardware to mimic the operation of a real quantum computer, but with
limited number of quantum bits (qubits) [17]. Such simulator allows to test
and implement quantum algorithms for many applications even before a fully-
controllable quantum computer exists [18]. Quantum simulators are not to
be confused with simulations of quantum computation on classical hardware

2

which we call a quantum computer simulator.

A universal simulator of quantum circuits can be implemented based on
David Deutsch model for a Quantum Turing Machine (QTM) [19], which pro-
vides a simple model that captures all the power of quantum computation.
Therefore, any quantum algorithm can be expressed formally as a particu-
lar QTM. The practical equivalent model is a quantum circuit deﬁned as a
quantum algorithm implemented on a gate-model based quantum computer
with special logic gates. In such circuits, only matrix multiplication and ten-
sor products are the advanced mathematical operations that are used. QTM
can be related to classical and probabilistic Turing machines in a framework
based on transition matrices. As shown by Lance Fortnow [20], a matrix
can be speciﬁed whose product with the matrix representing a classical or
probabilistic machine provides the quantum probability matrix describing
the quantum circuit.

Most of the existing quantum computers are still noisy and located in
research labs [21]. In addition, the hardware and maintenance of such sys-
tems are expensive and not optimized yet [22]. Hence, only limited public
access to these computers is available. On the other hand, quantum com-
puter (QC) simulators can be useful to overcome such problems. A QC
simulator is a software program which imitates the functionality of a quan-
tum computer using classical hardware [23], which allows to design, run and
test quantum algorithms. There are many QC simulators available to the
public [24]. They diﬀer in purpose, language, size, complexity, performance
and technical-based type (e.g.
toolkits) [25]. Companies working in this
ﬁeld (e.g. IBM, Microsoft, Rigetti, Google, and ETH Zurich) are creating
full-stack libraries for universal quantum computers with useful simulation
tools [25, 26, 27]. Most of these tools are not software, but software devel-
opment kits (SDKs) or frameworks, including Qiskit [28], Q# [29], ProjectQ
[30] and Cirq [31]. Other simulators focus in enhancing some aspects, such
as QiPSTER from Intel [32] that takes maximum advantage of multi-core
and multi-nodes architectures, and QuEST from Oxford [33] which is a mul-
tithreaded, distributed and GPU-accelerated. There are few software that
allow the user to graphically design a quantum circuit and test it without
writing a programming code and most of them are web-based, such as IBM
Quantum [34] and Quirk [35]. There is no local-server based universal QC
simulator with simple and accessible user interface.

Many QC simulators focus on increasing the number of qubits and sim-
ulation speed by using diﬀerent software tools. This task is important, but

3

also very diﬃcult at the same time. The challenge here is the exponen-
tial increase in the dimension of available quantum states with number of
qubits [36]. Actually, this is why we need quantum computers in the ﬁrst
place [37]. Furthermore, there are serious shortcomings in the development
of abstractions and visualizations of the QC simulation problem. One of
these problems is tracing the state of each qubit after each unitary quantum
operation [38]. Another shortcoming is in providing useful probabilistic vi-
sualizations of the resulted quantum states [39]. In this work, we address
these issues with many visualizations tools. There are other shortcomings
that need to be resolved later, such as using diﬀerent simulation methods for
visualizing quantum states, such as using Feynman path integral formulation
[40] and using tensor networks [41].

Quantum computer simulators are important for understanding the oper-
ation of noisy intermediate-scale quantum (NISQ) processors, and for build-
ing future quantum computers. Current and near-term NISQ computers are
limited by the presence of diﬀerent types of quantum noise that are still too
large to allow solving relevant scientiﬁc problems. One main source of noise
is readout errors that occur during measurements [42, 43]. They typically
prevent reading the correct state of qubits, such as reading zero while the
correct state is one and vice versa. Another important source of quantum
noise is gate errors, which can be classiﬁed into coherent and incoherent noise
[44, 45]. Coherent noise preserve state purity of quantum systems and result
in miscalibration in control parameters [46]. Incoherent noise can be modeled
as coherent noise with stochastic varying control parameters. This allows to
convert coherent errors into incoherent errors through randomized compiling
[47, 48, 49]. Incoherent noise are relatively easier to handle because they can
be modeled as a process that entangles the quantum system with its envi-
ronment. One very important class of Incoherent noise includes depolarizing
channels.

In this work, we present Psitrum – a universal gate-model based quan-
tum computer simulator implemented on classical hardware. The simulator
allows to emulate and debug quantum algorithms in form of quantum cir-
cuits for many applications with the choice of adding quantum noise that
limit coherence of quantum circuits. Psitrum allows to keep track of quan-
tum operations and provides variety of visualisation tools. The simulator
allows to trace out all possible quantum states at each stage M of an N-qubit
implemented quantum circuit. The design of Psitrum is ﬂexible and allows
the user later to add more quantum gates and variety of noise modules.

4

2. Software Structure

In this work, we use MATLAB to build Psitrum based on universal quan-
tum gates. A set of single- and multi-qubits gates is deﬁned as the basic
building blocks of Psitrum. Any other arbitrary multi-qubits operation can
be simply implemented by applying successive tensor products and multipli-
cations of the basic gates. It is suﬃcient to implement these speciﬁc gates
as a sequence of arithmetic operations on the input state vector in order to
implement any quantum logic operation [50]. The deﬁnition of the basic set
of quantum gates is presented in section of Additional information below.
In addtion, MATLAB is a well-known software environment that can handle
and manipulate matrices in form of unitary operations very eﬃciently [51].
This toolbox can also be used in other platforms by using MATLAB APIs.

2.1. Basic operation

For a given quantum circuit and an initial vector state, Psitrum calculates
the algorithm matrix, the density matrix and the output quantum states
which are used to provide useful visualizations. The simulation process of
Psitrum starts by replacing each quantum gate by its unitary matrix. Next,
the diﬀerent M stages are combined by applying N-1 tensor products and
M-1 matrix multiplications. Then, the output vector state of N qubits is
calculated by multiplying the algorithm matrix by the initialized input vector
state of the qubits.

The state of an elementary storage unit of a quantum computer is a
qubit, described by a two-dimensional vector of Euclidean length one. The
normalized state |Φ(cid:105) of a qubit can be written as a linear superposition of
two orthogonal basis |0(cid:105) and |1(cid:105):

|Φ(cid:105) = a0 |0(cid:105) + a1 |1(cid:105)

(1)

where a0 and a1 are complex numbers that satisfy the normalization con-
dition |a0|2 + |a1|2 = 1. In general, the normalized state |Ψ(cid:105) of N qubits is
accordingly described by 2N dimensional unit vector:

|Ψ(cid:105) = a(0...00) |0...00(cid:105)+a(0...01) |0...01(cid:105)+...a(1...10) |1...10(cid:105)+a(1...11) |1...11(cid:105) (2)

where now the complex coeﬃcients must satisfy the normalization condi-

tion:

5

2N −1
(cid:88)

|an|2 = 1

(3)

n=0
where a0 = a(0...00), a1 = a(0...01)....and a2N −1 = a(1...11).

In order to
satisfy this condition in Eq. 3, the complex-valued amplitudes an are rescaled
such that (cid:104)Ψ|Ψ(cid:105) = 1. State representation of qubits in Psitrum follows the
convention in quantum computing literature where the qubits are labeled
from 0 to N − 1, that is the rightmost (leftmost) bit corresponds to the 0
(N − 1) qubit [52].

2.2. Framework of Psitrum

Quantum algorithms can be fed into Psitrum as string matrices in form
of quantum circuits. Rows of the matrices represent N qubits, and columns
represent the execution of M operations of the input algorithms. Each ele-
ment of the circuit represent a gate that applies a speciﬁc unitary operation.
The deﬁnition of each level of a circuit implemented in Psitrum is shown in
Fig. 1. This framework allows the user to initialize qubits, set parameters of
quantum gates and select the output qubits to be measured.

Figure 1: Diﬀerent level of a basic quantum circuit implemented in Psitrum. This frame-
work allows to set/reset qubits, set parameters of quantum gates and choose which output
qubits to be measured.

Psitrum is a gate-model quantum computer simulator that follows the
workﬂow of many full-stack quantum simulators [53, 54, 55, 56]. First, the

6

problem is deﬁned at a high-level of abstraction, and based on the type of
the problem a quantum algorithm is selected in such a way that maximize
the output probabilities of the solution. Next, the quantum algorithm is
expressed in form of a quantum circuit that applies unitary operations. This
circuits then needs to be compiled to a speciﬁc set of quantum gates. Finally,
the circuit is executed on Psitrum which in turn acts like a quantum compiler.
Fig. 2 shows the workﬂow of Psitrum with examples and details at each level.

Figure 2: Workﬂow of Psitrum, which follows a full-stack gate-model quantum computer
simulator [56]. In this way, the selected quantum algorithm for a speciﬁc problem needs
to be expressed in form of a circuit using a set of deﬁned gates. Psitrum then simulates
the operation of an actual quantum compiler that executes this circuit. Finally, a set of
visualization tools is available for the user, including Bloch sphere diagrams, state and
density tracers, 3D and heatmap diagrams.

2.3. Decoherence and quantum noise

Simulating quantum errors in Psitrum is possible by simply adding the
unitary operation corresponding to a speciﬁc noise model. This can be done
in the backend of Psitrum. Here, we show how to do that by implementing
depolarizing channel which is an important type of incoherent noise. The
depolarizing noise model is given by [57]:

7

ξ(ρ) = (1 − p)ρ +

pI
2n

(4)

where ξ denotes the depolarizing noise channel, ρ is the density matrix,
n is the number of qubits and p is the error rate in range 0 ≤ p ≤ 4n
4n−1. The
parameter p represents the probability that the qubits are depolarized and
replaced with completely mixed state I
2n , while 1 − p is the probability that
the qubits are still in their pure states ρ. Psitrum gives the choice to select
p as a stochastic error rate or at overshoot. The eﬀect of the depolarizing
channel is basically a uniform contraction of all axes on the Bloch sphere as
function of p.

3. User Interface and visualization

There are few user friendly and easy-accessible software that allow to
graphically design, run, and test quantum algorithms as most of the available
QC simulators are SDKs or frameworks. Also, there are even fewer software
that allow to represent the simulation results with variety of visualization
tools. Psitrum is a software that provides all of these services in an integrated
environment. Psitrum provides a simple, friendly, and dynamic graphical
user interface (GUI), which is divided into four sections that provide the main
services of the software, including circuit designer, quantum state tracer,
visualization graphs and numerical representations.

3.1. Circuit designer

This section allows the user to graphically design quantum circuits with
a deﬁned universal set of quantum gates. The user can add qubits and
stages to the circuit as many as needed, and limited only by the available
computational power on the user’s hardware. The user can then set the
initial state of each qubit and which of the output qubits to be measured.
Also, it is possible to add additional parameters to some quantum gates,
like phase angles of rotations on Bloch sphere. Finally, when the user has
designed circuit, next it can be executed on the simulator which dynamically
presents the outputs in multiple result windows.

3.2. Visualization diagrams

Quantum computers are probabilistic systems and the output of a quan-
tum circuit is based on probabilities. Diagrams can be useful to visualize

8

probabilities, heatmap and Bloch Spheres. These diagrams are provided in
Psitrum to visualize algorithm matrix, output states and density matrices.

3.3. State and density tracers

The implementation of the quantum state and density matrix tracers in
the GUI are another useful features provided by Psitrum. These allow the
user to trace out the quantum state of all qubit and desity matrix at each
stage after any quantum operation. Psitrum visualizes each step on N qubit
in N diﬀerent Bloch Sphere diagrams to show quantum states at every stage
of the circuit. Each qubit is visualized by calculating its Bloch vector. The
user can trace out the evolution of all qubits after each stage, either by
choosing to access the Bloch vector of each stage or the output Bloch vectors
after executing all operations. Similarly, Psitrum shows all density matrices
after M stages with and without qunatum noise.

3.4. Numerical tables

It is useful, especially for small circuits, to track the state of qubits during
the simulation. The ability to observe the numeric values of the output is
useful for large circuits where visualization tools are now more needed. In
addition, Psitrum also provides several output numerical tables that can be
exported, including the output table of the algorithm matrix, its density
matrix and the output quantum states. The user can then save the data
and have a complete reference of the solution to the simulated quantum
algorithm.

4. Testing and Validation

This section is about testing Psitrum to validate its performance by im-
plementing four quantum algorithms, quantum full-adder [58], Deutsch-Joza
[59], Grover Search [60] and prime factorization [61] algorithms. These cir-
cuits are good benchmark problems for a universal quantum computer sim-
ulator [62, 63, 64, 65].

4.1. Quantum full-adder

Full-Adder circuit adds the input bits of A and B plus a carry input bit
Cin to produce the sum S and a carry output Cout bits. Classical full-adder
requires three input and two output bits. However, the quantum version
requires the same number of input and output qubits, since the circuit must

9

be reversible. The truth table of the full-adder with assigned qubits is given
in Table. 1, and the corresponding quantum circuit is shown in Fig. 3.

A B Cin S Cout
q4
q2
q0
0
0
0
0
1
0
0
0
0
1
1
0
0
0
1
1
1
1
1
0
1
1
1
1

q3
0
1
1
0
1
0
0
1

q1
0
0
1
1
0
0
1
1

Table 1: Truth table of a full-adder circuit. A quantum full-adder requires at least ﬁve
qubits with the same number of inputs and outputs so it becomes reversible. q0 and q1
represent the input bits with q3 representing the input carry bit. The output sum and
carry bits are represented by q3 and q4, respectively.

Figure 3: Circuit diagram of a ﬁve qubits quantum full-adder in Psitrum. The ﬁrst three
qubits take the input and output bits are measured in the last two qubits.

10

Next, quantum full-adder is modeled in Psitrum while introducing depo-
larizing noise channels, given in equ. 4. Fig. 4(a) shows a heatmap of the
simulated circuit and Fig. 4(b) shows the corresponding probabilities of the
measured output qubits, matching the truth table in Table. 1. Depolarizing
channels are introduced at all stages of the circuit in Fig. 3, with P = 0.05 at
overshoot. The eﬀect of this noise model can be seen on the output density
matrix. Fig. 4(c) and Fig. 4(d) show the output density matrices with and
without noise. Clearly, depolarizing channels reduce the amplitudes of the
density matrix without introducing dephasing on qubits.

Figure 4: Results after running quantum full-adder in Psitrum. (a) Shows heatmap of
the simulated circuit matrix, and (b) shows the output states probabilities of measured
qubits. (c) and (d) show the density matrix of the output with and without depolarizing
noise channels, respectively. All stages are noisy depolarized with P = 0.05 at overshoot.

11

b)a)d)c)4.2. Deutsch-Joza

Deutsch-Jozsa (DJ) algorithm ﬁnds whether an oracle is constant or bal-
anced.
If all outputs qubits are only zeros or ones then the function is
constant, whereas if the function is balanced then exactly half the output
qubits are measured to be zeros and the other half are ones. To apply DJ
algorithm, ﬁrst all qubits are initialized to zero states followed by Hadamard
gates to create superposition. Next, the circuit of the oracle to be tested is
constructed followed Hadamard gates on all qubits. Finally, the upper N-1
qubits are measured to ﬁnd out whether this function constant or balanced.
Fig. 5 shows DJ algorithm for a balanced function.

Figure 5: Diagram of a Deutsch-Jozsa circuit of a balanced function in Psitrum. The ﬁrst
four qubits are measured to ﬁnd out whether the oracle is balanced or constant.

Next, DJ circuit is modeled in Psitrum with depolarizing noise channels.
Fig. 6(a) shows a heatmap of the simulated circuit and Fig. 6(b) shows
the measured probabilities of the ﬁrst four qubits. All qubits are measured
at the |1111(cid:105) state, indicating that this is a balanced function. Depolarizing
channels are introduced at all stages of the circuit in Fig. 5, with P = 0.05 at
overshoot. The eﬀect of this noise model can be seen on the output density
matrix. Fig. 6(c) and Fig. 6(d) show the output density matrices with and
without noise. At both cases, the measured qubits are all still at the |1111(cid:105)
state with much smaller amplitudes.

12

Figure 6: Output of running Deutsch-Jozsa algorithm of a balanced function. (a) Shows
heatmap of the simulated circuit matrix, and (b) shows the output states probabilities of
measured qubits. (c) and (d) show the density matrix of the output with and without
depolarizing noise channels, respectively. All stages are noisy depolarized with P = 0.05
at overshoot.

13

b)a)d)c)4.3. Grover search

Grover algorithm requires iterations that scale as the square root of length
of the list. This is a quadratic speed over classical algorithms. First, qubits
are initialized at the desired state to be found, followed by Hadamard gates
to create superposition states. Next, Grover circuit applies selective phase
inversion of the states followed by inversion about the mean in order to
amplify the probability of measuring the correct state. Fig. 7 shows two
iterations of Grover algorithm for three-qubit search of |110(cid:105) state.

Figure 7: Circuit diagram of two iterations of three qubits search algorithm. The qubit
states are initialized at |110(cid:105) representing the state to be searched.

Next, Grover circuit is modeled in Psitrum with depolarizing noise chan-
nels. Fig. 8(a) shows a heatmap of the simulated circuit and Fig. 8(b) shows
the measured probabilities of qubits after the second iteration. The correct
answer is found in just two iterations, in which standard classical search
would require at least eight iterations. Depolarizing channels are introduced
at all stages of the circuit in Fig. 7, with P = 0.05 at overshoot. The eﬀect of
this noise model can be seen on the output density matrix. Fig. 8(c) and Fig.
8(d) show the output density matrices with and without noise. The correct
state still appears after depolarizing channels with smaller amplitudes.

14

Figure 8: Results of three qubits Grover algorithm. (a) Shows heatmap of the simulated
circuit matrix, and (b) shows the output states probabilities of measured qubits after the
second iteration. (c) and (d) show the density matrix of the output with and without
depolarizing noise channels, respectively. All stages are noisy depolarized with P = 0.05
at overshoot.

15

b)a)d)c)4.4. Prime factorization using Variational Quantum EigenSolver

Unlike Shors algorithm that makes use of the period to compute the
factors of the number to be factorized [65], here we compute factors of a
given number through solving an optimization problem. The cost function
used is given by (N − pq)2, where N is the number to be factorized, while p
and q are factors to be identiﬁed and expressed in binary form as qubits over
which the optimization is performed. Refer [61] for a complete discussion on
how the cost function is constructed and its complexity. The authors there
made use of imaginary time evolution to solve for the factors. Here instead
we only make use of the gradients to the cost function through standard
Variational Quantum EigenSolver (VQE). We would like to note that the
updates in the imaginary time evolution diﬀers from VQE only by a factor of
the ﬁsher information that works similar to the hessian for gradient updates.

Figure 9: Diagram of 5-qubit variational circuit used to factorize 91. Parameters of the
circuits were randomly initialized.

We use a hardware eﬃcient ansatz (Fig. 9) to implement a variational
circuit that consists of repeating layers to allow for a low error in the cost
function output, but not representative enough to result in barren plateaus.
The initial parameters of the circuit were randomly initialized. The learning
rate was set to 0.1 and the convergence threshold for the amplitude of factors
was set to 0.90 at least. Results of simulating this variational circuit for
factorizing 91 are shown in Fig. 10.

16

Figure 10: Output of simulating the variational circuit for factoring 91 in Psitrum. (a)
Shows heatmap of the circuit matrix, and (b) shows the density matrix of the output state.

We plot training of the cost function and the amplitude of the solutions at
the end of 100 iterations for the factorization of numbers 77 and 91 starting
with the same set of initial parameters in either case and compare the results
with IBM Qiskit Aqua framework (Fig. 11). 77 has factors of 11(1101)
and 7(111), and 91 has factors of 13(1110) and 7(111). Given that the least
signiﬁcant digit of all prime numbers begin with 1, we have a total of 5 qubits
over which the optimization is to be performed.

(a) and (b) show the minimization of the
Figure 11: 5-qubit factorization examples.
cost function for 77 and 91, respectively, using Psitrum and IBM Qiskit. (C) shows the
amplitude of the solutions in the computational basis for factoring 77 and 91, respectively,
as function of iteration solved by Psitrum.

17

b)a)b)a)c)020406080100-6-5-4-3-2   Cost (77) Iteration Psitrum IBM Qiskit020406080100-8-6-4-2  Cost (91) Iteration Psitrum IBM Qiskit0204060801000.20.40.60.81.0  Amplitude of solution Iteration Psitrum: 77 Psitrum: 915. Conclusion

We presented Psitrum, a universal quantum computer simulator based
on classical hardware and showed how to run widely popular quantum algo-
rithms, namely quantum-full adder, Deutsch-Joza and Grover search, both
in the presence and absence of quantum gate noise. We made use of vi-
sualization tools available in the software to demonstrate the simulation of
quantum circuits pertaining to these algorithms on Psitrum. In addition, we
solved the factorization problem using standard Variational Quantum Eigen-
Solver and were able to run the circuit in Psitrum to factorize prime numbers.
This demonstrates that, Psitrum provides features for simulating noisy and
noiseless quantum circuits to solve a wide class of quantum algorithms avail-
able for noisy intermediate-scale quantum processors. Given that Psitrum
runs on a local server with a simplistic MATLAB interface, it provides a
base layer for developers to easily add their own customization to suit their
needs. In future, we are going to add modules relevant to implement vari-
ous machine learning methods directly onto this platform, which will help to
provide a good starting point to newcomers for a good experience with our
visual learning tools.

6. Acknowledgment

This work was supported by the Deanship of Scientiﬁc Research at King
Fahd University of Petroleum and Minerals. S.K. acknowledge the support
from the National Science Foundation under award number 1955907.

Appendix A. Quantum Gates in Psitrum

This section provides details of gate operations implemented in Psitrum.
These are the basic quantum gates for many algorithms and are available in
this ﬁrst version of Psitrum. In later versions, we can easily add more gates.
Deﬁnitions of single- and multi-qubits gates are given in Table. A.2.

18

Symbol

Gate

I

X

Y

Z

H

S

T

S†

T †

U1

Matrix

(cid:21)

(cid:20)1 0
0 1

(cid:21)

(cid:20)0 1
1 0

(cid:21)

(cid:20)0 −i
0
i

(cid:21)

(cid:20)1
0
0 −1

(cid:21)

(cid:20)1
1
1 −1

(cid:21)

(cid:20)1 0
0 i

(cid:21)

(cid:20)1
0
0 e iπ

4

(cid:21)

(cid:20)1
0
0 −i

(cid:21)

(cid:20)1
0
0 e− iπ

4

(cid:21)

(cid:20)1
0
0 eiθ

19

U2

U3

RX

RY

RZ

SX

S†
X

SWAP

CNOT

(cid:20) 1 −eiθ
eiφ ei(θ+φ)

(cid:21)

(cid:1)
(cid:20) cos(cid:0) θ
eiφ sin(cid:0) θ

2

2

(cid:1)
−eiλ sin(cid:0) θ
(cid:1)
(cid:1) ei(λ+θ) cos(cid:0) θ

2

2

(cid:21)

(cid:21)
(cid:20) cos( θ
2) −isin( θ
2)
cos( θ
−isin( θ
2)
2)

(cid:21)
(cid:20)cos( θ
2) −sin( θ
2)
sin( θ
cos( θ
2)
2)

(cid:34)

2

e− iφ
0

(cid:35)

0
iφ
e
2

(cid:21)
(cid:20)1 + i 1 − i
1 − i 1 + i

(cid:20)1 − i 1 + i
1 + i 1 − i

(cid:21)













1 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1

1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0













20

Toﬀoli















1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0















Table A.2: Single- and multi-qubits quantum gates de-
ﬁned in Psitrum.

References

[1] A. Steane, Quantum computing, Reports on Progress in Physics 61 (2)

(1998) 117.

[2] C. Ryan, C. Negrevergne, M. Laforest, E. Knill, R. Laﬂamme, Liquid-
state nuclear magnetic resonance as a testbed for developing quantum
control methods, Physical Review A 78 (1) (2008) 012328.

[3] D. W. Berry, G. Ahokas, R. Cleve, B. C. Sanders, Eﬃcient quantum al-
gorithms for simulating sparse hamiltonians, Communications in Math-
ematical Physics 270 (2) (2007) 359–371.

[4] G. Benenti, G. Casati, S. Montangero, D. L. Shepelyansky, Eﬃcient
quantum computing of complex dynamics, Physical Review Letters
87 (22) (2001) 227901.

[5] I. Buluta, F. Nori, Quantum simulators, Science 326 (5949) (2009) 108–

111.

[6] J.-L. Brylinski, R. Brylinski, Universal quantum gates, in: Mathematics
of quantum computation, Chapman and Hall/CRC, 2002, pp. 117–134.

[7] P. Roushan, C. Neill, Y. Chen, M. Kolodrubetz, C. Quintana, N. Leung,
M. Fang, R. Barends, B. Campbell, Z. Chen, et al., Observation of topo-
logical transitions in interacting quantum circuits, Nature 515 (7526)
(2014) 241–244.

21

[8] A. Aspuru-Guzik, P. Walther, Photonic quantum simulators, Nature

physics 8 (4) (2012) 285–291.

[9] Y. Manin, Computable and uncomputable, Sovetskoye Radio, Moscow

128 (1980).

[10] R. P. Feynman, Simulating physics with computers, in: Feynman and

computation, CRC Press, 2018, pp. 133–153.

[11] M. Nakahara, Quantum computing: from linear algebra to physical re-

alizations, CRC press, 2008.

[12] S.-S. Li, G.-L. Long, F.-S. Bai, S.-L. Feng, H.-Z. Zheng, Quantum com-
puting, Proceedings of the National Academy of Sciences 98 (21) (2001)
11847–11848.

[13] J. W. Britton, B. C. Sawyer, A. C. Keith, C.-C. J. Wang, J. K. Freericks,
H. Uys, M. J. Biercuk, J. J. Bollinger, Engineered two-dimensional ising
interactions in a trapped-ion quantum simulator with hundreds of spins,
Nature 484 (7395) (2012) 489–492.

[14] N. C. Jones, R. Van Meter, A. G. Fowler, P. L. McMahon, J. Kim,
T. D. Ladd, Y. Yamamoto, Layered architecture for quantum comput-
ing, Physical Review X 2 (3) (2012) 031007.

[15] M. N. Leuenberger, D. Loss, Quantum computing in molecular magnets,

Nature 410 (6830) (2001) 789–793.

[16] I. Buluta, F. Nori, Quantum simulators, Science 326 (5949) (2009) 108–

111.

[17] K. De Raedt, K. Michielsen, H. De Raedt, B. Trieu, G. Arnold,
M. Richter, T. Lippert, H. Watanabe, N. Ito, Massively parallel quan-
tum computer simulator, Computer Physics Communications 176 (2)
(2007) 121–136.

[18] K. M. Obenland, A. M. Despain, A parallel quantum computer simula-

tor, arXiv preprint quant-ph/9804039 (1998).

[19] D. Deutsch, Quantum theory, the church–turing principle and the uni-
versal quantum computer, Proceedings of the Royal Society of London.
A. Mathematical and Physical Sciences 400 (1818) (1985) 97–117.

22

[20] L. Fortnow, One complexity theorist’s view of quantum computing, Elec-

tronic Notes in Theoretical Computer Science 31 (2000) 58–72.

[21] J. Preskill, Quantum computing in the nisq era and beyond, Quantum

2 (2018) 79.

[22] P. Murali, D. C. McKay, M. Martonosi, A. Javadi-Abhari, Software
mitigation of crosstalk on noisy intermediate-scale quantum computers,
in: Proceedings of the Twenty-Fifth International Conference on Archi-
tectural Support for Programming Languages and Operating Systems,
2020, pp. 1001–1016.

[23] I. G. Karafyllidis, Quantum computer simulator based on the circuit
model of quantum computation, IEEE Transactions on Circuits and
Systems I: Regular Papers 52 (8) (2005) 1590–1596.

[24] N. Khammassi, I. Ashraf, X. Fu, C. G. Almudever, K. Bertels, Qx: A
high-performance quantum computer simulation platform, in: Design,
Automation & Test in Europe Conference & Exhibition (DATE), 2017,
IEEE, 2017, pp. 464–469.

[25] V. Guzik, S. Gushanskiy, M. Polenov, V. Potapov, Models of a quantum
computer, their characteristics and analysis, in: 2015 9th International
Conference on Application of Information and Communication Tech-
nologies (AICT), IEEE, 2015, pp. 583–587.

[26] F. Arute, K. Arya, R. Babbush, D. Bacon, J. C. Bardin, R. Barends,
R. Biswas, S. Boixo, F. G. Brandao, D. A. Buell, et al., Quantum
supremacy using a programmable superconducting processor, Nature
574 (7779) (2019) 505–510.

[27] P. Ball, Google moves closer to a universal quantum computer, Nature

News (2016).

[28] A. Cross, The ibm q experience and qiskit open-source quantum com-
puting software, in: APS March Meeting Abstracts, Vol. 2018, 2018, pp.
L58–003.

[29] M. B. Hastings, D. Wecker, B. Bauer, M. Troyer, Improving quantum al-
gorithms for quantum chemistry, arXiv preprint arXiv:1403.1539 (2014).

23

[30] D. S. Steiger, T. H¨aner, M. Troyer, Projectq: an open source software

framework for quantum computing, Quantum 2 (2018) 49.

[31] W. Liu, Q. Wu, J. Shen, J. Zhao, M. Zidan, L. Tong, An optimized
quantum minimum searching algorithm with sure-success probability
and its experiment simulation with cirq, Journal of Ambient Intelligence
and Humanized Computing (2021) 1–10.

[32] G. G. Guerreschi, J. Hogaboam, F. Baruﬀa, N. P. Sawaya, Intel quan-
tum simulator: A cloud-ready high-performance simulator of quantum
circuits, Quantum Science and Technology 5 (3) (2020) 034007.

[33] T. Jones, A. Brown, I. Bush, S. C. Benjamin, Quest and high perfor-
mance simulation of quantum computers, Scientiﬁc reports 9 (1) (2019)
1–11.

[34] S. L. Wu, J. Chan, W. Guan, S. Sun, A. Wang, C. Zhou, M. Livny,
F. Carminati, A. Di Meglio, A. C. Li, et al., Application of quantum
machine learning using the quantum variational classiﬁer method to high
energy physics analysis at the lhc on ibm quantum computer simulator
and hardware with 10 qubits, Journal of Physics G: Nuclear and Particle
Physics (2021).

[35] C. Gidney, Quirk quantum circuit simulator, A drag-and-drop quantum

circuit simulator. URL: https://algassert. com/quirk (2016).

[36] Y. Zhou, E. M. Stoudenmire, X. Waintal, What limits the simulation of

quantum computers?, Physical Review X 10 (4) (2020) 041038.

[37] C. Zalka, Eﬃcient simulation of quantum systems by quantum comput-
ers, Fortschritte der Physik: Progress of Physics 46 (6-8) (1998) 877–879.

[38] F. Verstraete, J. Dehaene, B. De Moor, H. Verschelde, Four qubits can
be entangled in nine diﬀerent ways, Physical Review A 65 (5) (2002)
052112.

[39] J. E. Avron, G. Bisker, O. Kenneth, Visualizing two qubits, Journal of

mathematical physics 48 (10) (2007) 102107.

[40] J. Yepez, Relativistic path integral as a lattice-based quantum algo-

rithm, Quantum Information Processing 4 (6) (2005) 471–509.

24

[41] W. Huggins, P. Patil, B. Mitchell, K. B. Whaley, E. M. Stoudenmire,
Towards quantum machine learning with tensor networks, Quantum Sci-
ence and technology 4 (2) (2019) 024001.

[42] F. B. Maciejewski, Z. Zimbor´as, M. Oszmaniec, Mitigation of readout
noise in near-term quantum devices by classical post-processing based
on detector tomography, Quantum 4 (2020) 257.

[43] B. Nachman, M. Urbanek, W. A. de Jong, C. W. Bauer, Unfolding quan-
tum computer readout noise, npj Quantum Information 6 (1) (2020) 1–7.

[44] M. Guti´errez, C. Smith, L. Lulushi, S. Janardan, K. R. Brown, Errors
and pseudothresholds for incoherent and coherent noise, Physical Review
A 94 (4) (2016) 042338.

[45] C. J. Wood, J. M. Gambetta, Quantiﬁcation and characterization of

leakage errors, Physical Review A 97 (3) (2018) 032306.

[46] M. Urbanek, B. Nachman, V. R. Pascuzzi, A. He, C. W. Bauer, W. A.
de Jong, Mitigating depolarizing noise on quantum computers with
noise-estimation circuits, arXiv preprint arXiv:2103.08591 (2021).

[47] J. J. Wallman, J. Emerson, Noise tailoring for scalable quantum com-
putation via randomized compiling, Physical Review A 94 (5) (2016)
052325.

[48] Z. Cai, X. Xu, S. C. Benjamin, Mitigating coherent noise using pauli

conjugation, npj Quantum Information 6 (1) (2020) 1–9.

[49] Z. Cai, X. Xu, S. C. Benjamin, Mitigating coherent noise using pauli

conjugation, npj Quantum Information 6 (1) (2020) 1–9.

[50] D. Gottesman, I. L. Chuang, Demonstrating the viability of universal
quantum computation using teleportation and single-qubit operations,
Nature 402 (6760) (1999) 390–393.

[51] J. R. Gilbert, C. Moler, R. Schreiber, Sparse matrices in matlab: Design
and implementation, SIAM journal on matrix analysis and applications
13 (1) (1992) 333–356.

[52] M. A. Nielsen, I. Chuang, Quantum computation and quantum infor-

mation (2002).

25

[53] K. Bertels, A. Sarkar, T. Hubregtsen, M. Serrao, A. A. Mouedenne,
A. Yadav, A. Krol, I. Ashraf, Quantum computer architecture: Towards
full-stack quantum accelerators, in: 2020 Design, Automation & Test in
Europe Conference & Exhibition (DATE), IEEE, 2020, pp. 1–6.

[54] V. Frey, R. Rademacher, E. Durso-Sabina, N. Greenberg, N. Videnov,
M. L. Day, R. Islam, C. Senko, Programming the full stack of an open-
access quantum computer, arXiv preprint arXiv:2106.06549 (2021).

[55] L. Bassman, C. Powers, W. A. de Jong, Arqtic: A full-stack software
package for simulating materials on quantum computers, arXiv preprint
arXiv:2106.04749 (2021).

[56] M. Fingerhuth, T. Babej, P. Wittek, Open source software in quantum

computing, PloS one 13 (12) (2018) e0208561.

[57] M. A. Nielsen, I. L. Chuang, Quantum computation and quantum in-

formation, Phys. Today 54 (2) (2001) 60.

[58] K.-W. Cheng, C.-C. Tseng, Quantum full adder and subtractor, Elec-

tronics Letters 38 (22) (2002) 1343–1344.

[59] D. Deutsch, R. Jozsa, Rapid solution of problems by quantum compu-
tation, Proceedings of the Royal Society of London. Series A: Mathe-
matical and Physical Sciences 439 (1907) (1992) 553–558.

[60] L. K. Grover, A fast quantum mechanical algorithm for database search,
in: Proceedings of the twenty-eighth annual ACM symposium on Theory
of computing, 1996, pp. 212–219.

[61] R. Selvarajan, V. Dixit, X. Cui, T. S. Humble, S. Kais, Prime factor-
ization using quantum variational imaginary time evolution, Scientiﬁc
reports 11 (1) (2021) 1–8.

[62] S. Seyedi, N. J. Navimipour, An optimized design of full adder based on

nanoscale quantum-dot cellular automata, Optik 158 (2018) 243–256.

[63] S. Gulde, M. Riebe, G. P. Lancaster, C. Becher, J. Eschner, H. H¨aﬀner,
F. Schmidt-Kaler, I. L. Chuang, R. Blatt, Implementation of the
deutsch–jozsa algorithm on an ion-trap quantum computer, Nature
421 (6918) (2003) 48–50.

26

[64] J. A. Jones, M. Mosca, R. H. Hansen, Implementation of a quantum
search algorithm on a quantum computer, Nature 393 (6683) (1998)
344–346.

[65] P. W. Shor, Polynomial-time algorithms for prime factorization and dis-
crete logarithms on a quantum computer, SIAM review 41 (2) (1999)
303–332.

27

