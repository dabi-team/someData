Noname manuscript No.
(will be inserted by the editor)

Fluently specifying taint-ﬂow queries with
ﬂuentTQL

Goran Piskachev 14 · Johannes Späth 3 ·
Ingo Budde1 · Eric Bodden 12

2
2
0
2

r
p
A
6

]
L
P
.
s
c
[

1
v
9
8
0
3
0
.
4
0
2
2
:
v
i
X
r
a

Abstract Previous work has shown that taint analyses are only useful if cor-
rectly customized to the context in which they are used. Existing domain-
speciﬁc languages (DSLs) allow such customization through the deﬁnition of
deny-listing data-ﬂow rules that describe potentially vulnerable or malicious
taint-ﬂows. These languages, however, are designed primarily for security ex-
perts who are expected to be knowledgeable in taint analysis. Software devel-
opers, however, consider these languages to be complex.

This paper thus presents ﬂuentTQL, a query speciﬁcation language par-
ticularly for taint-ﬂow. ﬂuentTQL is internal Java DSL and uses a ﬂuent-
interface design. ﬂuentTQL queries can express various taint-style vulnera-
bility types, e.g. injections, cross-site scripting or path traversal. This paper
describes ﬂuentTQL’s abstract and concrete syntax and deﬁnes its runtime se-
mantics. The semantics are independent of any underlying analysis and allows
evaluation of ﬂuentTQL queries by a variety of taint analyses. Instantiations
of ﬂuentTQL, on top of two taint analysis solvers, Boomerang and FlowDroid,
show and validate ﬂuentTQL expressiveness.

Based on existing examples from the literature, we have used ﬂuentTQL
to implement queries for 11 popular security vulnerability types in Java. Using
our SQL injection speciﬁcation, the Boomerang-based taint analysis found all
17 known taint-ﬂows in the OWASP WebGoat application, whereas with Flow-
Droid 13 taint-ﬂows were found. Similarly, in a vulnerable version of the Java
Spring PetClinic application, the Boomerang-based taint analysis found all
seven expected taint-ﬂows. In seven real-world Android apps with 25 expected
malicious taint-ﬂows, 18 taint-ﬂows were detected. In a user study with 26

Goran Piskachev
E-mail: goran.piskachev@iem.fraunhofer.de

1Fraunhofer IEM, Paderborn, Germany
2Department of Computer Science, Paderborn University, Paderborn, Germany
3CodeShield GmbH
4Corresponding author

 
 
 
 
 
 
2

Piskachev, et. al

software developers, ﬂuentTQL reached a high usability score. In comparison
to CodeQL, the state-of-the-art DSL by Semmle/GitHub, participants found
ﬂuentTQL more usable and with it they were able to specify taint analysis
queries in shorter time.

Keywords -

taint analysis, program analysis, domain-speciﬁc language, user study, us-

ability.

1 Introduction

Over the past decade, static and dynamic taint analyses have gained signif-
icant traction both in industry and academia (Späth et al., 2019; Bodden,
2018; Grech et al., 2018; Arzt et al., 2014). This is due to the fact that—in
principle—most types of security vulnerabilities on the code level, e.g. 17 of the
25 vulnerabilities types of SANS-25 (Mitre, 2020a), can be detected via taint
analysis (Piskachev et al., 2019). Similarly, the OWASP top 10 list (OWASP,
2020b) comprises 6 taint-style vulnerability types.

Taint analysis tracks sensitive data from sources, which are typically method
calls to application programming interfaces (APIs), to program statements
performing security-relevant actions, known as sinks. To soundly and pre-
cisely detect security vulnerabilities in a given software development project,
any taint analysis, whether static or dynamic, requires conﬁguration. Partic-
ularly, the sources and sinks must be conﬁgured regarding the libraries and
frameworks the project uses (Arzt et al., 2013). Additionally, due to a lack of
scalability, static analyses frequently are unable to analyze all the software’s
code and must instead be conﬁgured to cut corners.

Some existing static analysis tools from academia (Krüger et al., 2019;
Martin et al., 2005; Johnson et al., 2015) as well as from industry (Checkmarx,
2020; Microfocus, 2020; Grammatech, 2020; Github, 2020) provide a DSL to
conﬁgure their analyses. However, all of the existing DSLs are designed to be
used by static analysis experts and not by software developers—despite the
fact that developers are usually the ones who best know how the project under
analysis is structured. This was also conﬁrmed in a recent research project with
several industry partners (SecuCheck, 2021), in which the authors conducted
interviews with software developers that have used various commercial and
non-commercial static analysis tools. Eight of the nine interviewees ﬁnd the
conﬁguration options for taint analysis of the tools to be too complex. In
another recent study among developers, the authors discovered that for 47.1%
of the participants, there is a dedicated team to conﬁgure the used static
analysis tools, 36.8% conﬁgure their analysis tools themselves, and 16.2% run
on default settings (Nguyen Quang Do et al., 2020). Moreover, the existing
DSLs require expertise in static code analysis which many developers do not
have. We are not aware of any excising study that evaluates the usability of
the DSLs used for conﬁguring the tools.

ﬂuentTQL

3

While much eﬀort has been spent on automatically proposing relevant
sources, sanitizers, and sinks (Piskachev et al., 2019; Arzt et al., 2013; Sas
et al., 2018) or inference of taint-ﬂows (source-sanitizer-sink paths) (Livshits
et al., 2009; Chibotaru et al., 2019; Song et al., 2019), in practice taint analyses
still require substantial manual speciﬁcation eﬀort.

To address this shortcoming, this paper presents a new domain-speciﬁc
language called ﬂuentTQL. ﬂuentTQL is designed for software developers—
not static or dynamic analysis experts—and allows the speciﬁcation of taint-
ﬂow queries. Compared to existing DSLs, the abstraction level of ﬂuentTQL
is speciﬁc to taint analysis and contains only concepts that allow software
developers to easily create or modify taint-ﬂow queries. In result, ﬂuentTQL
queries can be evaluated by virtually any existing taint analysis. This sets
the language apart from previous more generic code-query language such as
CodeQL, the state-of-the-art DSL used within the commercial tool LGTM
by Semmle/GitHub. At the same time, ﬂuentTQL is suﬃciently expressive,
though, to support the speciﬁcation of multiple taint-ﬂows which allow the
detection of complex security vulnerabilities.

Since Java is still amongst the most widely used languages, we designed
ﬂuentTQL as an internal Java DSL with a ﬂuent-API design.1 This paper
presents the syntax and semantics of ﬂuentTQL, which is independent of
any concrete (static or dynamic) taint analysis. Our example implementa-
tion instantiates ﬂuentTQL with two static taint analyses, one based on
Boomerang (Späth et al., 2019) and one based on FlowDroid (Arzt et al.,
2014). We explain how these implementations statically approximate the ﬂu-
entTQL semantics. The implementation is built on top of MagpieBridge (Luo
et al., 2019) and the Language Server Protocol (Microsoft, 2020). In result,
it can be used in a multitude of editors and integrated development environ-
ments (IDEs), including Vim, Eclipse, VSCode, IntelliJ, SublimeText, Emacs,
Thea and Gitpod.

We evaluate the usability of ﬂuentTQL through a user study with 26
participants (professional software developers, students, and researchers). We
compare ﬂuentTQL to the more generic CodeQL. The results show that
software developers perceive ﬂuentTQL as easier to use. ﬂuentTQL has an
excellent System Usability Score (SUS) (Brooke, 2013) of 80,77 (out of 100),
whereas (for taint analysis) CodeQL has a score of only 38,562. The Net Pro-
moter Score (NPS) (Reichheld, 2003) shows that—for the task of specifying
taint-ﬂow queries—participants would recommend to others ﬂuentTQL over
CodeQL. Moreover, we evaluate the applicability of ﬂuentTQL by provid-
ing speciﬁcations of 11 popular vulnerabilities with catalog of small programs.
Additionally, we select two vulnerable Java applications (OWASP WebGoat
application3 and PetClinic4) and seven real-world Android applications from

1 Fluent Interfaces: https://www.martinfowler.com/bliki/FluentInterface.html
2 Interpreting SUS: 0-50 is bad, 51-67 is poor, 68 is an average usability, 69-80,3 is good,

> 80,4 is excellent, and 100 is imaginary perfect.

3 https://github.com/WebGoat/WebGoat
4 https://github.com/contrast-community/spring-petclinic

4

Piskachev, et. al

TaintBench (Luo et al., 2021) known with malicious behavior. For all applica-
tions, we speciﬁed corresponding ﬂuentTQL queries and were able to detect
most of the expected taint-ﬂows.

To summarize, this paper makes the following contributions:

– ﬂuentTQL, a new DSL for specifying taint-ﬂow queries, designed to be

well usable for software developers.

– A formal deﬁnition of the syntax and semantics of ﬂuentTQL, the latter

independent of any concrete taint-analysis tool.

– An implementation and an empirical evaluation of the usability of ﬂu-
entTQL in comparison to a state-of-the-art DSL for static code analysis.

Our artifact includes the ﬂuentTQL tooling, the catalog of queries for
popular taint-style security vulnerabilities and the dataset of our user study.
It is available anonymously online at https://ﬂuenttql.github.io/

We next explain relevant concepts on taint analysis and elicit the require-
ments for a developer-centric DSL. In Section 3 we present ﬂuentTQL with
its syntax and semantics, and explain how our static instantiations statically
approximate this semantics. In Section 4 we discuss the user study. We discuss
related work in Section 5 and, ﬁnally, we conclude in Section 6.

2 Requirements for a Taint Analysis DSL

We next explain the concept of taint analysis with an example and deﬁne
requirements for a developer-centric DSL for taint analysis.

Listing 1 shows an excerpt of Java code of an HTTP handler. The method
doGet is called upon a GET-request from a web browser when a user changes
the password by providing the username, the old password, and the new pass-
word. The method calls a helper method changePassword shown in Listing 2
which veriﬁes the user and changes the database. The code in doGet con-
tains a potential cross-site scripting vulnerability (XSS) (Mitre, 2020d). The
username value from the request in the variable uName is added to the cre-
ated HTML page for the response object to inform the user if the password
was changed successfully (line 5). There is no sanitization check if the value
contains any malicious behavior before it is added to the generated HTML
page.

1

2
3
4
5

6
7
8

protected void doGet ( @RequestParam (" user ") String uName ,

H tt p Se r vl e tR e qu e st request , H t t p S e r v l e t R e s p on s e response )
{

String oldPass = request . getParameter ( ’ oldKey ’) ;
String newPass = request . getParameter ( ’ newKey ’) ;
if ( changePassword ( uName , oldPass , newPass ) )
response . getWriter () . append ( ’ < html >... Password
changed for user ’ + uName + ’ ... </ html > ’) ) ;

else
response . getWriter () . append ( ’ < html >...
Wrong credentials .... </ html > ’) ;

ﬂuentTQL

9

}

5

Listing 1: Java code with potential XSS vulnerability (from line 1 to line 5)

The code in the helper method changePassword contains a potential NoSQL
injection vulnerability (NoSQLi) (Mitre, 2020e). A single atomic action per-
forms the user authentication and a change of a password in line 20 in which
two database documents (ﬁlter and set), one with $where clause and one
with $set clause are executed. To report the taint-ﬂow precisely, both values
should be marked as tainted. We explain both XSS and NoSQLi vulnerabilities
throughout this section.

10

protected boolean changePassword ( String uName , String

oldPass , String newPass ) {

11

12

13

14
15

16
17
18
19
20

21
22

}

MongoClient myMongoClient = new

MongoClient ( " localhost " , 8990) ;

MongoDatabase credDB =

myMongoClient . getDatabase ( ’ CREDDB ’) ;

MongoCollection < Document > credCollection =

credDB . getCollection ( ’ CRED ’ , Document . class ) ;

BasicDBObject filter = new BasicDBObject () ;
filter . put ( ’ $where ’ , ’( username == \" ’ + uName + ’ \")

\& ( password == \" ’ + oldPass + ’ \") ’) ;
BasicDBObject newPassDoc = new BasicDBObject () ;
newPassDoc . put ( ’ password ’ , newPass ) ;
BasicDBObject set = new BasicDBObject () ;
set . put ( ’ $set ’ , newPassDoc ) ;
UpdateResult res = credCollection . updateOne ( filter ,

set ) ;

return ( res . getMatchedCount () == 1) ;

Listing 2: Potential NoSQLi vulnerability (lines 1-3 to line 20)

Fig. 1: Data-ﬂow graphs for (a) XSS and (b) NoSQLi vulnerabilities from
Listing 1 and Listing 2

6

Piskachev, et. al

2.1 Selection of Sensitive Methods

To detect such vulnerabilities using a taint analysis, one must conﬁgure the
analysis with any security-relevant methods (SM), such as sources, sinks and
sanitizers.

Consider the example of the XSS vulnerability in Listing 1. Here, untrusted
data ﬂows from the parameter uName of the method doGet to the sink in line 5
where method append() is called with a string value of a request. Figure 1 (a)
shows the data-ﬂow graph extracted from the code. To ﬁx this vulnerabil-
ity, a software developer should apply a sanitizer such as encodeHTML() to
clear potential malicious inputs from the variable uName before appending
the contents to the HTML string. This leads to our ﬁrst requirement:

R1: The DSL must allow one to express the following security-relevant methods
( SM): source, sanitizer, and sink.

2.2 Selection of In- and Out-Values

Apart from the selection of the call sites, the actual values ﬂowing in or out of
the methods (return values, parameters, and receiver) must be selected. For
the source of the XSS vulnerability in Listing 1, the developer must select the
argument value of the ﬁrst parameter of the method doGet. At the call to
the sink of the vulnerability, the developer needs to provide the possibility to
select a parameter of a called method.
R2: The DSL must allow one to express the data-ﬂow propagation of each SM
to a granularity of single argument, a return value, and a receiver.

2.3 Composition of Taint-Flows

The presented XSS vulnerability is detected by what we call a “single-step taint
analysis”. It is relatively easy to detect, even manually. But many real-world
taint-analysis problems comprise a sequence of multiple events. For example,
consider the NoSQL injection vulnerability in Listing 2 and its data-ﬂow graph
in Figure 1 (b).

The NoSQLi vulnerability occurs in line 20 when the method updateOne is
called under the condition that the Mongo database has a record with the user-
name and the old password that matches the values coming from the request
object (uName in line 1 and oldPass in line 3). The value of ﬁlter contains the
document that checks the existing password for the given username by calling
the method put in line 15 with a $where-clause. The value of set contains the
document that sets the new password by calling the method put in line 18
with a $set-clause. When the method put is called in line 15 and line 17, the

ﬂuentTQL

7

uName and oldPass taint the ﬁlter whereas the newPass taints the set. For
the taint-ﬂow to be complete, both calls to the method put must occur before
the set and ﬁlter ﬂow to the sink updateOne() in line 20. Thus, we desired
a feature to compose complex queries consisting of multiple single-step taint
analyses.

R3: The DSL must allow one to express complex multi-step taint-ﬂow queries.

2.4 Detailed Error Message

When ﬁndings are reported, the analysis tool usually provides a description
to the user to help understanding the vulnerability. The study of Christakis
et al. (Christakis and Bird, 2016) showed that software developers have dif-
ﬁculties in understanding those descriptions. For diﬀerent vulnerabilities and
types of data-ﬂow the DSL shall present the results of the taint analysis with
ﬁne-grained error messages that help developers to quickly identify and ﬁx the
vulnerability. The user that speciﬁes the taint-ﬂow should be able to deﬁne a
custom error message that can be reported at diﬀerent locations.

R4: The DSL must allow one to specify error messages for each type of ﬁnding.

2.5 Integration into Developer’s Workﬂow

Empirical studies show that software developers need static analysis tools in-
tegrated in their workﬂow (Christakis and Bird, 2016; Johnson et al., 2013).
Most software developers use integrated development environments (IDEs)
and prefer static analyses to be directly integrated in the IDE. The results
of the analysis should be shown within the IDE, preferably visible near the
editor for the code. Therefore, a DSL designed for software developers should
be integrated in this workﬂow with appropriate tooling and usability.

R5: The DSL must integrate well with the software developers’ workﬂow.

2.6 Independence of Concrete Taint Analysis

Software developers desire reusing taint-ﬂow speciﬁcations for both static and
dynamic taint analyses. Moreover, some analysis tools are only part of the
continuous integration whereas others can be integrated in diﬀerent workﬂows,
e.g. the IDE. To enable reusability of the speciﬁcations among diﬀerent tools,
the DSL semantics must therefore be independent of any concrete static or

8

Piskachev, et. al

dynamic analysis. Thus, any limitations due to the approximations of the
underlying solver are transferred to the results reported by ﬂuentTQL.

R6: The speciﬁed taint-ﬂow queries can be reused among existing taint analysis
tools, i.e., the DSL is independent of the underlying taint analysis.

The NoSQLi vulnerability from the example in this section, can not be
detected by default with the existing tools due to its speciﬁc structure. Such
complex taint-ﬂows require the user to specify a custom query. ﬂuentTQL
introduced in the next section aims at providing usable and easy approach for
mainly software developers specifying custom queries. The existing DSLs are
design for experts who have understanding in data-ﬂow analysis, which most
developers do not have. Moreover, based on our evaluation of the existing DSLs
in Section 5, indicates that none of them completely fulﬁlls all requirements.

3 ﬂuentTQL

We next deﬁne the domain-speciﬁc language ﬂuentTQL through its abstract
and concrete syntax (Stahl et al., 2006). We also deﬁne the runtime semantics
of ﬂuentTQL as independent of a concrete taint analysis. Dynamic taint anal-
yses could faithfully implement the semantics, whereas static taint analyses
would seek to soundly approximate it. Finally, we discuss relevant implemen-
tation details.

3.1 Concrete Syntax

As a concrete syntax for ﬂuentTQL, we decided to use a Java ﬂuent-interface
syntax. Since Java is one of the most popular programming languages, this
allows software developers to learn the DSL with little eﬀort. Moreover, in
interviews with nine software developers (SecuCheck, 2021), the authors asked
what concrete syntax they would prefer if given the choice of (1) a ﬂuent
interface, (2) a graphical syntax, or (3) a textual syntax for taint-ﬂow queries,
six participants chose the ﬂuent interface, and only two chose the graphical
and one the textual syntax.

In the following, we explain the concrete syntax by specifying the ﬂu-
entTQL queries for the detection of the XSS and NoSQLi code in Listing 1
and Listing 2. The speciﬁcation is presented in Listing 3, where lines 23–31
contain the SM declaration and lines 32–38 contain the taint-ﬂow queries.

23

Method source1 = new Method ( " String

getParameter ( String ) " ) . out () . return () ;
Method source2 = new Method ( " void doGet ( String ,

24

HttpServletRequest ,
H t t p S e r v le t R e s p o n s e ) " ) . out () . param (0) ;

25

MethodSet sources = new

MethodSet () . add ( source1 ) . add ( source2 ) ;

ﬂuentTQL

9

26

Method sanitizer = new Method ( " String encodeHTML
( String ) " ) . in () . param (0) . out () . return () ;

27

Method reqPropagator1 = new Method ( " BasicDBObject put ( String ,

String ) " ) . in () . param (1) . out () . thisObject () ;

28

Method reqPropagator2 = new Method ( " DBObject put ( String ,

DBObject ) " ) . in () . param (1) . out () . thisObject () ;

29

MethodSet r eqP rop aga tor sPu t = new MethodSet () .

add ( reqPropagator1 ) . add ( reqPropagator2 ) ;

30

Method sinkXss = new Method ( " PrintWriter

append ( CharSequence ) " ) . in () . param (0) ;

31

Method sinkNoSql = new Method ( " FindIterable

updateOne ( BasicDBObject ,
BasicDBObject ) " ) . in () . param (0) . param (1) ;

32

Tain tFlowQuery xss = new

TaintFlowQuery () . from ( source1 ) . notThrough ( sanitizer )
. to ( sinkXss ) . report ( " Reflective XSS
vulnerability . " ) . at ( Location . SOURCE ) ;

33

Tain tFlowQuery noSQLi1 = new

TaintFlowQuery () . from ( source1 ) . through (
re q Pr opa gat ors Pu t ) . to ( sinkNoSql ) . report (
" No - SQL - Injection . " ) . at ( Location . SINK ) ;
Tain tFlowQuery noSQLi2 = new TaintFlowQuery () ;
noSQLi2 . from ( source1 ) . through ( reqPropagator1 ) . to (

sinkNoSql ) . and () . from ( source2 ) . through (

reqP ropagator1 ) . to ( sinkNoSql ) . and () . from ( source1 ) .
through ( reqPropagator2 ) . to ( sinkNoSql ) . report (
" No - SQL - Injection vulnerability with multiple
taint - flows " ) . at ( Location . SOURCEANDSINK ) ;

34
35

36
37
38

}

39
Listing 3: ﬂuentTQL speciﬁcation for XSS and NoSQLi in Listings 1 and 2. To simplify,
fully qualiﬁed method names are omitted.

In the code there are two potential sources. One source is the return value
of the getParameter() method which in Listing 3 is speciﬁed in line 23. The
ﬁrst argument to the constructor of Method() takes a method signature as a
String argument. Next, using the ﬂuent interface of ﬂuentTQL, we append
out() indicating that the method generates a sensitive data-ﬂow. Eventually,
by appending return(), we select the return value as the out-value that is
generated. The other source is the ﬁrst parameter of the doGet() method
(line 24) indicated by out() and param(0).

The ﬂuent interface of ﬂuentTQL allows calling out() or in() on a
Method object. After out() there has to be at least one more call to return(),
thisObject() and/or one or more calls to param(int) with the integer refer-
ring to the parameter index of the out-value. After in() there must be a call
to thisObject() and/or one or more calls to param(int).

Both sources in line 23 and line 24 are potential sources for SQLi and XSS,
i.e., they are not speciﬁc to the vulnerability type. Thus, they are grouped into
a MethodSet object (line 25). Afterwards, the method encodeHTML is speciﬁed
as sanitizer which is relevant to the XSS vulnerability only. The method put()
is a propagator (i.e. only propagates the taint) but a required one, because it
has to be called between the source and the sink for this speciﬁc vulnerability.
It can be called with two diﬀerent parameter types. Hence, it is speciﬁed twice

10

Piskachev, et. al

(lines 27 and 28). They are grouped in the method set reqPropagatorsPut.
Finally, the sinks are speciﬁed (lines 30 and 31). They are speciﬁc to each
vulnerability type.

The taint-ﬂow query for XSS is speciﬁed in line 32 where the class Taint-
FlowQuery is instantiated after which from(...), to(...), and report(...)
are called. For the XSS taint-ﬂow query, the sanitizer is also speciﬁed by call-
ing the method notThrough(...). Each of these methods expects an object
of type Method or MethodSet.

At the end there is a call to at(Location.SOURCE) which is optional and
expresses where in the code the report message should be shown. Location
is an enumeration with values SOURCE, SINK, and SOURCEANDSINK.
The taint-ﬂow query can be read as follows: If there is a taint-ﬂow from the
source source1 not propagating through the sanitizer and reaching any of
the sinkXss, then report a ﬁnding with "‘Reﬂective XSS vulnerability"’ at the
source location.

For the NoSQLi vulnerability there are two taint-ﬂow queries in Listing 3,
in lines 33–38. The object noSQLi1 will report a ﬁnding with a message
"‘No-SQL-injection vulnerability"’ for the source getParameter, deﬁned with
source1, propagating through any required propagator from the set reqProp-
agatorsPut reaching the sinkNoSql. If applied to the code example from List-
ing 1 and Listing 2, there will be two traces found which will be reported as
separate ﬁndings. The taint-ﬂow from the ﬁrst parameter of doGet carrying
the username will be missed. To detect this taint-ﬂow as well, one can use the
method set sources instead of the single method source1. On the other hand, a
taint analysis speciﬁed as deﬁned though noSQLi2 will report a single ﬁnding
only: For this speciﬁcation, the three single taint-ﬂows are joined by a call to
and(), which means all separate taint-ﬂows need to occur individually.

3.2 Abstract Syntax

We discuss the abstract syntax through the meta-model shown in Figure 2.
The DSL has a root node (class RootNode) containing all objects. An object of
this class represents single instance of the DSL that can contain multiple top
level elements. The abstract class TopLevelElement is a superclass of the main
concepts in ﬂuentTQL, i.e., the class Method and the class TaintFlowQuery.

3.2.1 Methods

The class Method represents a reference to a method from the analyzed code.
It contains information about the method signature and the data-ﬂow propa-
gation when that method is called in a given context (conforming to R1 and
R2). This is expressed through the references to InputDeclaration and Out-
putDeclaration. A Method object has to have one or both InputDeclaration or
OutputDeclaration references. An InputDeclaration contains an in-value (ab-
stract class Input), whereas OutputDeclaration contains an out-value (abstract

ﬂuentTQL

11

class Output). In-values can be a parameter of a method call (class Parameter )
or a receiver of the method (class ThisObject). Out-values can be a parameter,
a receiver, or a return value (class Return). In-values ﬂow into the method call
and out-values ﬂow out of the method call.

The class Method in combination with the classes InputDeclaration and
OutputDeclaration can model sources, sinks, and sanitizers (R1). Source is a
combination of Method and OutputDeclaration specifying which values become
tainted through a method call. Sink is an instance of Method and InputDec-
laration specifying which values must be tainted for the sink to be considered
“reached”. Sanitizer is a combination of a Method and InputDeclaration, spec-
ifying which tainted value ﬂowing in the method call will get untainted.

3.2.2 Required propagators

Required propagators are method calls that have to be on the path between a
source and a sink in order for a given vulnerability to be present. For instance
the method put() in the running example from Section 2 has to be on the
taint-ﬂow trace from the source to the sink. It only propagates the taint from
the in-value to the out-value. In ﬂuentTQL, a required propagator is modeled
as a combination of Method, InputDeclaration, and OutputDeclaration. This
model allows propagating out-values once an in-value reaches a method. The
analyses that are aware of these methods know how to propagate the data-
ﬂow without analyzing them, for example for improving scalability or handling
calls for which the source code is not available.

3.2.3 Taint-ﬂow queries

The class TaintFlowQuery represents a taint-ﬂow query. It contains all the
information one needs to trigger a taint analysis. It contains one or more
TaintFlow objects and a user deﬁned message (R4). The class TaintFlow
has four references to the class FlowParticipant. The from reference deﬁnes
the set of sources, the through reference deﬁnes the required propagators, the
notThrough reference deﬁnes the sanitizers, and the to reference deﬁnes the
sinks. For any valid TaintFlow there should be at least one source and one
sink. A FlowParticipant is either a Method or a MethodSet, i.e., a collection
of methods. Similarly, the QueriesSet is a collection of taint-ﬂow queries.

3.2.4 Imports and reuse

The root node can contain imports from other models deﬁned in other loca-
tions. This is modeled via the class Import. This allows references of methods
and taint-ﬂow queries from diﬀerent ﬁles. The classes Import, MethodSet, and
QueriesSet are provided for maintenance, reusability, and structure of ﬂu-
entTQL speciﬁcations, enabling software developers to deﬁne categories of
methods and taint-ﬂow queries and share them (R5). As Java internal DSL,

12

Piskachev, et. al

Fig. 2: ﬂuentTQL meta-model (UML class diagram, gray-ﬁlled classes are
abstract). The constraints of the cardinalities of the classes are shown as mes-
sages, since the semantics of UML class diagram can not express all of them.

the users of ﬂuentTQL get all advantages of Java compared to any exter-
nal DSL or XML/JSON-based DSL, often used in the existing tools. From
Java, users can reuse existing abstractions such as packaging, modules, and
object-oriented design to improve the maintenance, the readability, and the
accessibility of the rules.

3.3 Semantics

A taint-ﬂow query, an instance of the class TaintFlowQuery, is a ﬂuentTQL
speciﬁcation that describes which traces of the program should be returned as
ﬁndings to the user when a given taint analysis is triggered with that taint-
ﬂow query. In the following we deﬁne the relevant terms and how ﬂuentTQL
refers to them.

We denote M to be the set of all method signatures where a signature
includes the fully qualiﬁed method name, parameter types, and a return type.
A sensitive value is a type deﬁnition with information about the direction of
propagation (in- or out-), and location (return, receiver, or parameter index).

QueriesSetQueriesSetTopLevel-ElementTopLevel-ElementTaintFlow QueryTaintFlow QueryTaintFlowTaintFlowRootNodeRootNodeImportImportFlow-ParticipantFlow-ParticipantMethodSetMethodSetMethodMethodOutput-DeclarationOutput-DeclarationInput-DeclarationInput-DeclarationOutputOutputThisObjectThisObjectReturnReturnParameterParameterInputInput[0..1] ref[0..1] ref[0..1] ref[0..1] ref[0..1] set[0..*] flows[0..*] imports[0..*] elems[1..1] to[1..1] from[0..*] through[0..*] notThrough[0..1] inputs[0..1] outputs[1..*] inputs[1..*] outputssize(inputs) + size(output) > 0size(inputs) + size(output) > 0#ThisObject <= 1#ThisObject <= 1#ThisObject <= 1 & #Return <=1#ThisObject <= 1 & #Return <=1[1..*] flowsﬂuentTQL

13

Hence, in- and out-values are sensitive values with in- and out-propagation,
respectively.

Deﬁnition 1 A sensitive method is a tuple (m,SV), where m ∈ M and SV
is a set of sensitive values. SV contains subset SVin for in-values and subset
SVout for out-values.

Deﬁnition 2 A taint analysis speciﬁcation TAS consists of the tuple (Sources,
Sanitizers, RequiredPropagators, Sinks), where

1. Sources is a set of sensitive methods (m, SVout) for which SV contains at

least one out-value, (SVout (cid:54)= ∅),

2. Sanitizers and Sinks are sets of sensitive methods (m, SVin) for which SV

contains at least one in-value, (SVin (cid:54)= ∅), and

3. RequiredPropagators is a set of sensitive methods (m, SVin, SVout) contain-

ing at least one in-value and one out-value (SVin (cid:54)= ∅, SVout (cid:54)= ∅).

Given a taint analysis speciﬁcation TAS, some black-box taint analysis T
and a program P , we assume the execution of T returns a set of traces for
the data-ﬂow, i.e., T (P, TAS) = {t1 . . . , tn} where each ti is a data-ﬂow trace.
A trace is a sequence of program statements, i.e., ti = s1
i . For each
individual trace ti it holds that
– the ﬁrst statement is a source statement, s1
– the last statement is a sink, sn
– none of the statement sj
– if RequiredPropagators is non empty, there exists exactly one element from

i is a sanitizer, sj

i /∈ Sanitizers, and

i ∈ Sources,

i ∈ Sinks

i . . . sn

i s2

RequiredPropagators that appears at statement sj

i , where j ∈ {1, . . . , n}.

Note that in the case the analysis T is a dynamic taint analysis, the set of traces
is a singleton set while static analyses, which simulate all possible executions,
may generate multiple traces.

Example: A TAS can detect rudimentary data-ﬂows modeled with the
class TaintFlow from Figure 2 such as the XSS vulnerability in Listing 1. The
TaintFlowQuery xss in line 32 speciﬁes a TaintFlow with

sources - {(getParameter(String),returnout), (doGet(String, ...), 0out)}

sanitizers - {(encodeHTML(String),0in)}

r. propagators - {}

sinks - {(append(CharSequence),0in)}

ﬂuentTQL allows one to specify these sets with respective syntax elements
from(...), notThrough(...), and to(...). Running a taint analysis with
the ﬂuentTQL speciﬁcation for xss on the code in Listing 1 returns the single
trace consisting of the two statements5 t1 = 1 5.

Additionally, the syntax element through(...) allows to specify the set of

RequiredPropagators.

For instance, the taint-ﬂow query noSQLi1 in line 33 speciﬁes a non-empty

set RequiredPropagators.

5 We use line numbers from Listing 1 and Listing 2 to represent traces.

14

Piskachev, et. al

sources - {(getParameter(String),returnout)}

r. propagators - {(put(String, String),1in, returnout), (put(String, BasicD-

sanitizers - {}

BObject), 1in, returnout)}

sinks - {(updateOne(BasicDBObject, BasicDBObject),0in, 1in), returnout}

The result of the taint-ﬂow query noSQLi1 is

TracenoSQLi1 = 2 4 10 15 20, 3 4 10 17 19 20

and consists of two traces. Each of these traces is reported as a separate ﬁnding
to the user. A “simple” ﬁnding is a single trace with a single message. For in-
stance, the ﬁndings of noSQLi1 are Findings noSQLi1 = { F1
noSQLi1},
where
F 1
F 2

noSQLi1 = ({2 4 10 15 20}, "No-SQL-Injection vulnerability.")
noSQLi1 = ({3 4 10 17 19 20}, "No-SQL-Injection vulnerability.")
Yet, for more complex queries one can use the and() operator, which combines
ﬁndings over individual traces to a single ﬁnding over multiple traces.

noSQLi1, F2

Combining taint-ﬂow queries: The and() operator allows one to merge mul-
tiple TAS as a single query. This is through an object of type TaintFlowQuery
(from Figure 2) that contains multiple objects of type TaintFlow. Formally,
the operator computes the cross product of the traces of the individual TAS.
For example, the taint-ﬂow query noSQLi2 in line 34 deﬁnes three TAS spec-
iﬁcations:

sources - {(getParameter(String),returnout)}

sanitizers - {}

r. propagators - {(put(String, String),1in), returnout}

sinks - {(updateOne(BasicDBObject, BasicDBObject),0in, 1in)}

sources - {(put(String, String),returnout)}

sanitizers - {}
r. propagators - {}

sinks - {(updateOne(BasicDBObject, BasicDBObject),0in, 1in)}

sources - {(getParameter(String),returnout)}

sanitizers - {}

r. propagators - {(put(String, BasicDBObject),1in, returnout))}

sinks - {(updateOne(BasicDBObject, BasicDBObject),0in, 1in)}]

noSQLi2}, where
F 1

The ﬁrst one returns the trace “2 4 10 15 20”, the second one returns the
trace “1 4 10 15 20”, and the last one returns the trace “3 4 10 17 19 20”. Yet,
the result of the query noSQLi2 will be a single ﬁnding, Findings noSQLi2 =
{F 1

noSQLi2 = ({2 4 10 15 20, 1 4 10 15 20, 3 4 10 17 19 20}, "No-SQL-

Injection vulnerability with multiple taint-ﬂows.").

Calculating traces: By its deﬁnition, ﬂuentTQL has a precise runtime se-
mantics. However, when applied in static context, the traces need to be approx-
imated by the underlying data-ﬂow engine. Thus, reported traces of diﬀerent
tool implementations can diﬀer.

ﬂuentTQL

15

To explain the precise runtime semantics for traces construction, we deﬁne
a taint analysis core language, in similar fashion to previous works (Schwartz
et al., 2010; Livshits, 2012). Though simple, the core language covers relevant
statements that can be mapped one-to-one with Java statements. The state-
ments are listed in Table 1. A program of the language contains a sequence
of statements with line number. For simplicity, we decided to exclude method
calls from the language. These can be compiled to the language by storing
the memory address of the return statement and transferring the control ﬂow.
This rule is not applied to the four statements in Table 1 which are special
method calls.

Table 1: Statements of the core language for constructing ﬂuentTQL traces

Statement Description

src(x)
snk(x)
san(x)
rpr(x)
x = y
x = y.f
x.f = y
x = a[i]
a[i] = x
skip

call to a sensitive method (m,SVout) ∈Sources with sensitive parameter x
call to a sensitive method (m,SVin) ∈Sinks with leaked parameter x
call to a sensitive method (m,SVin) ∈Sanitizers sanitizing parameter x
call to a sensitive method (m,SVin,SVout) ∈RequiredPropagators
assignment
ﬁeld load
ﬁeld store
read from array at index i
write to array at index i
skip and continue

We denote variables with x and y, a ﬁeld of an object with f , and an i-th
index of an array with a[i]. We model all memory locations through a shadow
heap: The shadow-heap values for a memory location v is true if the value is
tainted and false otherwise. The execution context Σ has the parameters listed
in Table 2. Σ.∆[x] stores the current taint value of variable x. We write Σ (cid:96)
x ⇓ v to extract that value into v. Similarly, notations like src(x) (cid:96) (m, SV )
extract the method m with its sensitive values SV , when a method call src
is matched. Additionally, Σ stores all traces t ∈ T that will be created during
the execution. t is a sequence of statements (which we here denote by line
numbers).

Table 2: Statements of the core language for constructing ﬂuentTQL traces

Parameter Description

∆

λ
θ

match a variable, a ﬁeld, an array element or a sensitive value to its taint
value
match a given statement to its line number
returns the set of all traces created

Figure 3 shows ﬂuentTQL’s semantics through inference rules. We use a
syntax akin to the one used by Schwartz et al. (Schwartz et al., 2010). The
semantics essentially deﬁne a regular dynamic taint analysis which, as side-

16

Piskachev, et. al

eﬀect collects un-sanitized traces from sources to sinks. For instance, given the
statement x = y, the ASSIGN rule’s computation comprises four parts. First,
Σ (cid:96) y ⇓ v evaluates and extracts the taint value v for variable y. Due to the
assignment, the rule updates the taint value of x with v. The rule then also
extracts each trace in t ∈ θ and adds to it the current statement, identiﬁed
by its line number. The rules for load/store and array accesses are equivalent.
The rule SOURCE creates a new trace and taints the out-value, the rule
SINK gracefully terminates a trace by untainting the sensitive value. The rule
SANITIZER also discontinues the tracing. The rule PROPAGATOR taints
the out-value if the in-value is tainted. SKIP advances to the next statement
whereas SEQ enables the progression of the semantics covering the recursive
case. The semantics must additionally enforce one aspect that we found hard
to capture with inference rules: for such ﬂuentTQL speciﬁcations that deﬁne
required propagators, the taint analysis must ensure to report only such traces
that actually contain all required propagators. Finally, the notion of user-
deﬁned message is skipped in the formal semantics due to simplicity, but we
explain it in the following through our example.

Report message: As seen in the previous examples, the queries speciﬁed
in ﬂuentTQL contain a user-deﬁned message which is added to each ﬁnding
(R4). In the concrete syntax, the mandatory syntax element report(...)
takes the string message as an argument. Optionally, the user may specify
the location for the reporting message by using the syntax element at(...).
As an argument, the enumeration Location can be used, which contains three
elements SOURCE, SINK and SOURCEANDSINK. SOURCE and SINK de-
ﬁne that the reporting message should be shown at the source and the sink
location respectively. For SOURCEANDSINK the message should be shown
at both source and sink location in the code. If the ﬁnding has multiple traces
then the reporting message is shown for each trace individually. For example,
for noSQLi2 the error message will be shown at each source and sink location,
i.e., lines 1, 2, 3, and 20, because SOURCEANDSINK is used in the query
speciﬁcation (Listing 3, line 38). This information can be used by tools for
visualization purposes. E.g. an IDE plug-in may display error markers in the
editor at the source location, the sink location, or both.

Usability versus expressiveness: ﬂuentTQL is a DSL for users without deep
expertise in static analysis as most software developers. Its purpose is to enable
users specify a custom taint analysis for their codebase and detect many popu-
lar security vulnerabilities. Hence, the usability and simplicity of the language
is the primary aim. A trade-oﬀ to this design decision is the lower expres-
siveness when compared to some existing DSLs such as CodeQL. ﬂuentTQL
does not provide the users a ﬁne-grained manipulation of the abstract syntax
tree (AST). Such expressive DSLs are used by program analysis experts. This
ﬁne-grained AST manipulation, can be useful for writing more compact code.
Nonetheless, as our evaluation in Section 4 shows, most popular security vul-
nerabilities can be expressed in ﬂuentTQL. This is due to the fact that the
relevant data being tracked by the analysis is impacted only by speciﬁc method
calls within the program, which is the case for most security vulnerabilities.

ﬂuentTQL

17

Fig. 3: Inference rules of the operational semantics of the traces construction
in ﬂuentTQL

Compared to CodeQL, in ﬂuentTQL, other language constructs than method
calls currently can’t be modeled. However, as discussed in Section 4.4, extend-
ing ﬂuentTQL with new language constructs is possible without signiﬁcant
semantic changes. On the side of expressiveness, ﬂuentTQL has a support
of R3 which is only partially supported by other DSL as can be seen later
in Section 5. Complex multi-step taint-ﬂow queries are in particular relevant
for stored versions of SQLi and XSS vulnerabilities. Finally, ﬂuentTQL only
support taint analysis, whereas other DSLs like CodeQL support additional
types of analyses, such as value analysis.

18

3.4 Implementation

Piskachev, et. al

We implemented ﬂuentTQL as an internal Java DSL which can be easily used
in any Java project by implementing the interface FluentTQLSpeciﬁcation.
Hence, any Java editor can be used to write and edit ﬂuentTQL queries.

Additionally, we implemented a server using the MagpieBridge framework (Luo

et al., 2019) that can trigger, execute the analysis, and return the results to the
IDE. ﬂuentTQL is implemented as a standard Java library using the builder
pattern to allow method chaining as user interface. All queries need to be
implemented within a class that implements the interface FluentTQLSpeci-
ﬁcation. Using the Java classloader the classes are located and the queries
correctly loaded and provided as input to the analysis.

As we rely on MagpieBridge, we support IDEs that support the Language
Server Protocol (Microsoft, 2020) such as Vim, Eclipse, VSCode, IntelliJ, and
many more. The MagpieBridge server uses the Language Server Protocol to
notify the IDE for available results. Figure 4 shows a component diagram of our
implementation. The core analysis uses Soot as an underlying static analysis
framework responsible for providing the main data structures, such as control-
ﬂow graph and call graph. Solvers such as Boomerang and FlowDroid provide
interface for starting a taint analysis. The core analysis utilizes this to execute
the semantics of the ﬂuentTQL queries as described previously in ﬂuentTQL’s
semantics. The core analysis matches the solver’s APIs with the ﬂuentTQL
queries that are executed. For complex queries it breaks them into simple taint-
ﬂows which are independently solved by the underlying solver and their results
merged afterwards. The queries are loaded through the ﬂuentTQL-classloader
into the MagpieBridge-Server.

Fig. 4: Component diagram of the ﬂuentTQL imeplementation as Mag-
pieBridge server (gray components are external, white components are in-
ternal)

ﬂuentTQL

19

Our implementation uses the standard IDE features: errors view, editor
markups, and notiﬁcations to display the results from the analysis directly in
the IDE. Additionally, it provides a conﬁguration page where the user can ﬁlter
the queries and the entry points used for the call graph used by the analysis.
To instantiate ﬂuentTQL with concrete analyses, we ﬁrst implemented
a taint analysis built on top of the Boomerang solver (Späth et al., 2019),
an eﬃcient and precise context-, ﬂow-, and ﬁeld-sensitive data-ﬂow engine
with demand-driven pointer analysis. Boomerang provides an API to query
all traces from given seeds. The API of the seed is expressible to cover the
ﬂuentTQL semantics of the sensitive methods. However, the basic API of
Boomerang does not support sanitizers, nor required propagators. To support
the sanitizers we transformed the bodies of the sanitizers to empty, which is a
terminal case of the Boomerang data propagation solver. To support required
propagators, we break the TAS speciﬁcation to multiple TAS speciﬁcations
containing only sources and sinks. A TAS with required propagator is broken
to two TAS where the ﬁrst one has the original source and the required prop-
agator as sink, whereas the second one has the required propagator as source
and the original sink as sink. Boomerang returns the traces of the individual
TAS, and our implementation merges them. There is no explicit well-formed
check in our implementation. However, we implemented the taint analysis with
Boomerang on ourselves and we, therefore, trust its correctness with respect
to the semantics of the constructed traces. However, future implementation
with other solvers, should also include a well-formed check.

Moreover, we instantiated ﬂuentTQL with the existing taint analysis of
FlowDroid (Arzt et al., 2014). This, however, was not possible without limi-
tations. Speciﬁcally, the default component for deﬁning sources and sinks in
FlowDroid is limited and supports only return as out-value of sources and
parameter index as in-value of sinks. This can be extended by adding new
implementation of the SourceSinkManager, which we left as future work. San-
itizers by default are not supported, but we applied the same solution as in our
Boomerang implementation, whereas required propagators are not supported
and requires either extension of the taint analysis or post-processing of the
ﬁndings which we also consider as future work.

Finally, both instances of ﬂuentTQL have some limitations in the way
the traces are constructed and reported. Since ﬂuentTQL has precise runtime
semantics, it is expected that static analysis engines like Boomerang and Flow-
Droid will approximate. In particular, both engines will unsoundly underap-
proximate the constructed traces. For example, both apply diﬀerent strategies
for merging conditional paths of the program. Thus, these limitations are part
of our implementation, too.

4 Evaluation

We evaluated the usability of ﬂuentTQL by conducting a comparative user
study between ﬂuentTQL and CodeQL. We chose CodeQL because it is

20

Piskachev, et. al

part of LGTM, a state-of-the-art security tool, which has, in our perspective,
very good tool support and the query speciﬁcations are open-source. There is
also an Eclipse plugin, a web console for queries, and integration with GitHub,
a popular versioning system among developers. Additionally, we evaluated the
applicability of ﬂuentTQL by specifying queries for diﬀerent set of applica-
tions: a catalog of eleven Java programs, each demonstrating diﬀerent security
vulnerability, the deliberately insecure application OWASP WebGoat aiming
to teach developers about relevant security vulnerabilities, an insecure version
of the Spring Demo application PetClinic, and randomly selected ﬁve real-
world Android apps with known malicious taint-ﬂows part of TaintBench (Luo
et al., 2021). All selected applications have known expected taint-ﬂows that
can be used to evaluate how does the analysis perform in ﬁnding real vulner-
abilities. We answer the following research questions:

– RQ1 How usable is ﬂuentTQL for software developers?
– RQ2 How does ﬂuentTQL compare to CodeQL for specifying taint-ﬂow

queries for taint-style security vulnerabilities?

– RQ3 Are ﬂuentTQL syntax elements suﬃcient to express queries for pop-

ular taint-style security vulnerabilities?

– RQ4 Can ﬂuentTQL express and detect the known security vulnerabilities

Java/Android applications?

To answer the research questions, we use corresponding metrics. For RQ1,
we use the System Usability Scale and Net Promoter Score. The same met-
rics are also used in RQ2 to compare both DSLs. Additionally, we measure
the time needed for the participants to complete the given tasks. We count
only the solutions which are complete queries. The partial solutions are not
counted due to the nature of the task. In similar realistic scenario, incomplete
queries will not return results from the tools. For RQ3, we evaluate how each
ﬂuentTQL construct contributes in specifying the most popular Java security
vulnerabilities. Moreover, we identify security vulnerabilities for which ﬂu-
entTQL can not express the required constructs. Finally, for RQ4, we count
how many of the expected taint-ﬂows in the selected applications are found
when ﬂuentTQL runs with adequate queries.

The following subsection explains our methodology for the user study used
to answer RQ1 and RQ2. The next subsections discuss the results of each
research question individually. Finally, we discuss threats to validity.

4.1 Methodology

Setup: The user study was conducted over a set of teleconferences where each
participant shared the screen. Each study took on average 80 minutes. The
session was recorded for post-processing purposes. We invited 35 software de-
velopers to take part in the study, from which 26 accepted the invitation,
referred to as P01-P26. We invited professional developers via our contacts

ﬂuentTQL

21

from the industry as well as researchers and master level students. Addition-
ally, we asked three students to participate in a test session, which helped us
to estimate the time and adjust the diﬃculty of the tasks.

Due to the limited number of participants, we chose a within-subjects de-
sign. Hence, each participant worked in Eclipse with available tool support for
both DSLs. The ﬂuentTQL implementation used the more versatile instan-
tiation based on Boomerang. To avoid any bias, we referred to the DSLs by
DSL-1 and DSL-2. Initially, the participants received a project with all ﬁles
needed for the practical part. The moderator gave an introduction to taint
analysis and showed a Java code example with an SQL injection vulnerabil-
ity (Mitre, 2020h) to make sure that the participant understands the required
concepts such as source, sanitizer, required propagator, and sink. Then, the
exercises for DSL-1 and DSL-2 followed.

Each exercise consisted of a tutorial and a task. The tutorial for each
DSL was based on the SQL injection vulnerability. Then, the participants
had ten minutes to write a speciﬁcation in the same DSL for a new vulner-
ability explained by the moderator. We chose the vulnerability types open
redirect (Mitre, 2020l) for ﬂuentTQL and cross-site scripting (Mitre, 2020d)
for CodeQL. For either type, we selected an example with the same pattern
in form of source-sanitizer-sink. This ensures that writing a speciﬁcation for
each vulnerability is equally hard, i.e., the eﬀort is the same regardless of the
vulnerability.

For each vulnerability type, we provided a Java code example as a reference.
The participant was allowed to use any of the ﬁles provided that included
the Java classes and the ﬁles with example speciﬁcations of ﬂuentTQL and
CodeQL. For each task, we additionally provided a ﬁle with a skeleton code
in which the participant wrote the solution. During the tasks, the participants
were allowed to ask questions for clariﬁcation.

After the tasks, we let the participants ﬁll a web form. The moderator
guided the participant in the discussion and collected the data for the ques-
tionnaire.

Questionnaire: In total the questionnaire asked 28 questions, of which two
are of open type and optional (Q26 and Q27). The complete list of questions
is part of our artifact. Each of the questions asks for feedback for each DSL by
the participant. From the 26 mandatory questions of closed type, 4 are infor-
mational, 20 are related to the System-Usability-Scale (SUS) (Brooke, 2013),
and two are related to the Net Promoter Score (NPS) (Reichheld, 2003). The
SUS value is a usability metric that can be calculated with ten simple questions
in a predeﬁned format. The SUS-related questions (Q4-Q23) are the same ten
questions per DSL with answering options on agreement scale from one to
ﬁve. SUS expresses usability of a single DSL. Hence, for comparison we use
the same questions for each DSL. The NPS metric expresses how likely the
participant would recommend something to a colleague. To calculate a value,
NPS identiﬁes so-called promoters and detractors among the participants. The
NPS-related questions (Q24-Q25), ask for the likelihood of DSL1 being recom-
mended over DSL2 for the task of specifying taint-ﬂow queries and vice versa.

22

Piskachev, et. al

The informational questions ask about participant coding experience (Q1),
security expertise (Q2), willingness to learn a new DSLs (Q3), and preferred
way of learning new languages (Q28).

Participants: The study population with 26 participants is larger than the
size of related studies that have been performed earlier, e.g. 10 in (Smith et al.,
2019), 12 in (Smith et al., 2020), and 22 in (Nguyen Quang Do and Bodden,
2020). We chose participants with a diverse background. Ten of them are
professional developers, six are computer science students on the master level,
and ten are researchers in computer science. The participants have diﬀerent
experiences in programming. Twelve of the participants have 10+, nine have
6-10, four have 3-5, and one has 1-2 years of programming experience. They
rated their experience with security vulnerabilities. Three consider themselves
as beginners, 16 have basic knowledge, ﬁve regularly inform themselves about
the topic, and two consider themselves as experts.

Statistical tests: Along with the reported data and metrics, we perform rel-
evant statistical tests. As a within-subject design our collected data is paired,
i.e, for each participant we have one set of collected data. Exception are the
SUS and NPS metrics which are aggregated among all participants. The lim-
itation of this design is the possibility of carryover eﬀects, such as learning
eﬀects. The main treatment variable is the technique, stating which DSL was
used to solve each task (nominal data). In addition, we have an independent
crossover treatment variable, the choice of DSL for the ﬁrst task (binomial
data). The background variable are: years of coding experience (ordinal data),
position (nominal data), and security experience (nominal data). Finally, we
have two eﬀort variables, one for the outcome of each task (binomial data)
and the time (ratio data). As most of the data is nominal and ordinal, we
used only non-parametric statistical tests. Bellow we report individually each
selected test and the results. We used the signiﬁcance level α = 0.05 for all
the tests.

4.2 RQ1 Usability of ﬂuentTQL

ﬂuentTQL was positively received by the participants of our user study. It
received an excellent System Usability Score of 80,77 on a scale from 0 to 100
where 68 is considered to be an average usability and 100 is imaginary perfect.
Using the null hypothesis "ﬂuentTQL is usable (SUS is bigger then the
hypothetical value of 68)", we select the Wilcoxon test (the data is ratio but
without normal distribution). The test accepts the hypothesis with statisti-
cal signiﬁcance and large eﬀect size (>0.5). For the given task, 20 out of 26
participants have ﬁnished with a correct solution in 10 minutes (on average
472 seconds, with σ =99,05). Table 3 shows the exact time in seconds for
each participant. In the open questions (Q26-Q27), many of the participants
gave additional feedback what they like and what they would improve in ﬂu-
entTQL. Most of the participants said that they can learn the language very
easily, one of them said "‘with simple tutorial, I can learn it ( ﬂuentTQL) even

ﬂuentTQL

23

without an expert. (...) it was very intuitive"’ and other said "‘I didn’t have to
learn a lot"’. Few participants mentioned that they like that the queries are
compact and have the right level of abstraction.

We noted a few points that many participants disliked. Most dislike that
the method signatures are speciﬁed as a string value. One participant said
"‘method calls are prone to typos or cumbersome to create"’. For this, we al-
ready added a check in the editor to inform the users if their string is an
invalid method signature. We support Java and Soot signatures. We even plan
to add suggestions for existing methods from the workspace to the code com-
pletion feature of the editor. Some participants gave suggestions for improving
the names of some keywords. For example the class ThisObject, which in ﬂu-
entTQL is called with thisObject(), was earlier called This and confused many
participants with the this keyword in Java.

ﬂuentTQL as a new DSL is found to be very usable. The participants of our
user study gave a score of 80,77 on the System Usability Score system.

4.3 RQ2 Comparison of ﬂuentTQL and CodeQL

In terms of usability, with a SUS value of 38,56 CodeQL is perceived with bad
usability. Using the null hypothesis "CodeQL is not usable (SUS is smaller
than the hypothetical value of 68)", we select the Wilcoxon test. The test
accepts the hypothesis with statistical signiﬁcance and large eﬀect size (>0.5).
On the questions how likely will the participant recommend one DSL over
the other for the task they were given (Q24-Q25), ﬂuentTQL over CodeQL
has a Net Promoter Score value of 30,77, whereas CodeQL over ﬂuentTQL
has a value of -86,96, where on the scale from -100 to 100, positive values are
considered good. It follows that for specifying taint-ﬂow queries, participants
would more likely recommend ﬂuentTQL over CodeQL.

24

Piskachev, et. al

Table 3: List of participants: coding experience and position, time in solving
each task and DSL used in the ﬁrst task (X means the participant did not
solve the task in 10 minutes)

Coding
(years)
P01
3-5
P02 >10
P03
6-10
P04 >10
P05 >10
P06 >10
P07
3-5
P08 >10
6-10
P09
P10 >10
1-2
P11
6-10
P12
3-5
P13
6-10
P14
6-10
P15
P16
6-10
P17 >10
P18 >10
6-10
P19
6-10
P20
P21
6-10
P22 >10
P23 >10
P24 >10
3-5
P25
P26 >10

Position

Security
experience
basic
basic
expert
basic
basic

basic
advanced
basic
basic

developer
developer
student
researcher
researcher
researcher advanced
researcher
student
student
researcher
researcher beginner
researcher
researcher beginner
researcher
researcher
student
developer
developer
developer
developer
student
developer advanced
developer advanced
developer advanced
student
developer

basic
basic
beginner
basic
basic
basic
expert
basic

basic
basic

basic

ﬂuentTQL
(seconds)
554
499
482
560
X
544
X
449
X
545
558
X
473
305
571
412
X
328
594
375
455
X
507
206
531
492

CodeQL
(seconds)
X
X
588
590
591
562
595
495
587
567
585
X
541
434
X
558
X
600
X
492
467
X
600
425
X
X

1st DSL

ﬂuentTQL
ﬂuentTQL
ﬂuentTQL
CodeQL
ﬂuentTQL
ﬂuentTQL
ﬂuentTQL
CodeQL
CodeQL
CodeQL
CodeQL
ﬂuentTQL
CodeQL
CodeQL
ﬂuentTQL
CodeQL
ﬂuentTQL
CodeQL
ﬂuentTQL
CodeQL
CodeQL
CodeQL
ﬂuentTQL
CodeQL
ﬂuentTQL
ﬂuentTQL

40

41
42

43

44

45

46
47

48
49

50

}

class XSSConfig extends TaintTracking2 :: Configuration

{

XSSConfig () { this = " XSSConfig " }
override predicate isSource ( DataFlow :: Node

source ) { source instanceof
RemoteFlowSource }

override predicate isSink ( DataFlow :: Node
sink ) { sink instanceof XssSink }

override predicate isSanitizer ( DataFlow :: Node

node ) {

node . getType () instanceof NumericType
or node . getType () instanceof
BooleanType }

}
from DataFlow2 :: PathNode source , DataFlow2 :: PathNode

sink , XSSConfig conf

where conf . hasFlowPath ( source , sink )
select sink . getNode () , source , sink , " Cross - site
scripting due to $@ . " , source . getNode () ,
" user - provided value "

Listing 4: CodeQL speciﬁcation for XSS

ﬂuentTQL

25

To compare both languages, let us consider the CodeQL example for XSS
in Listing 4. This is a solution for the task given to the participants. The
query (lines 47- 49) consists of three sections, from, where, and select. In the
from section, the user deﬁnes objects from predeﬁned or self-deﬁned classes.
In the where section, constraints are deﬁned that may also contain calls to
predicates. In the select section, the results of the query are deﬁned. For taint
analysis, CodeQL provides a module. The class XSSConﬁg extends from the
conﬁguration class for taint analysis where the sources, sanitizers, and sinks are
deﬁned. Additionally, the classes RemoteFlowSource and XssSink are provided
and can be used to detect sources and sinks for XSS. The stub code with
relevant imports given to each participant contained information that these
classes exist and can be used. A user who needs other SM that the provided
classes cannot detect, will need to write a new implementation. Note that the
provided classes RemoteFlowSource and XssSink will match more sources and
sinks than the ﬂuentTQL query solution. To have an equivalent query as the
one in ﬂuentTQL, the participants would have to write additional code for the
isSource (Line 42) and isSink (Line 43) methods instead of using the provided
classes.

Few participants mentioned the amount of code they would need to write
in CodeQL is large. One participant said, "’...way too much code to get to
the actual thing that needs to be written."’.

Furthermore, we observed how each participant performed in solving the
tasks. The task with CodeQL was solved by 17 participants, compared to
20 with ﬂuentTQL. Fourteen participants solved both tasks. However, on this
data, the Fisher’s test (selected due to binomial small sample) did not indicate
a statistical signiﬁcance. We measured the time each participant needed for
each task, which is given in Table 3. On average participants solved the task
with CodeQL in 546 seconds (σ =57,89), which is by 13,4% slower than with
ﬂuentTQL. Using the Wilcoxon test we found a statistical signiﬁcance for the
null hypothesis with a small eﬀect.

We performed few additional Wilcoxon tests for the impact of the back-
ground variables, i.e. Coding, Position, and Security experience. None of these
tests showed a statistical signiﬁcance of the null hypothesis which tested
whether the variable impacts the time of solving the tasks. Finally, we look
into the outcome of each task. The null hypothesis is "The order of the tasks
impact the output". We used the two-way ANOVA (Girden, 1992) test, which
did not show a statistical signiﬁcance. Hence, we reject the null hypothesis and
accept the alternative one stating that the order of the tasks does not impact
the outcome.

26

Piskachev, et. al

While CodeQL is more expressive DSL for multiple types of static analy-
ses, ﬂuentTQL is more preferred among software developers due to its user-
friendliness. CodeQL scored a bad SUS value of 38,56. On the NPS system,
ﬂuentTQL is preferred over CodeQL with a score of 30,77, whereas CodeQL
is preferred over ﬂuentTQL with a negative value of 86,96. When specifying
a taint-ﬂow for given known vulnerability, the participants in our user study
were 13,4% faster when using ﬂuentTQL compared to CodeQL.

4.4 RQ3 Expressiveness

To evaluate whether ﬂuentTQL syntax elements are suﬃcient to express pop-
ular Java taint-style vulnerabilities, we created a catalog with Java code ex-
amples accompanied by ﬂuentTQL speciﬁcations. The catalog contains eleven
types of security vulnerabilities (Table 4). Each Java code example has a vari-
ant with and without sanitization. The catalog demonstrates diﬀerent language
syntax elements of ﬂuentTQL and how they can be used for specifying vulner-
abilities. The Java examples and the SM are manually collected from several
sources including the Mitre (Mitre, 2020b) and OWASP (OWASP, 2020b)
databases, OWASP benchmark project(OWASP, 2020a), and other publicly
available SM lists (Arzt et al., 2013; Brooke, 2013; Piskachev et al., 2019;
Thomé et al., 2017).

Table 4: List of vulnerability types implemented in the ﬂuentTQL catalog (so
- sources, sa - sanitizers, rp - required propagators, si - sinks)

Vulnerability type
SQL injection (Mitre, 2020h)
XPath (Mitre, 2020c)
Command injection (Mitre, 2020f)
XML injection (Mitre, 2020m)
LDAP injection (Mitre, 2020g)
Cross-site scripting (Mitre, 2020d)
Open redirect (Mitre, 2020l)
NoSQL injection (Mitre, 2020e)
Trust boundary violation (Mitre, 2020k)
Path traversal (Mitre, 2020j)
Log injection (Mitre, 2020i)
Total (unique):

ﬂows so sa rp si SM
13 3 6 10 32
3
12 1 0 12 25
1
12 1 1 1 15
1
12 1 0 4 17
1
12 1 0 8 21
1
13 1 1 3 18
2
13 1 0 2 16
2
5 2 3 2 12
2
12 1 0 1 15
1
12 1 1 2 16
2
2
12 1 1 4 18
18 46 14 13 49 122

Many of the taint-style vulnerabilities from the Mitre and OWASP databases
can be modeled with single taint ﬂow queries. Yet, we found some examples
such as the noSQLi2 query in Listing 3 where the and() operator is needed.

Taint ﬂows that require multiple intermediate source-sinks steps were nec-
essary for the speciﬁcation of many taint ﬂows, i.e., the feature of multi-step

ﬂuentTQL

27

taint analysis is ubiquitous. For example, the OWASP Benchmark test 000016
contains Path Traversal vulnerability (Mitre, 2020j). A File object is con-
structed using a String parameter as location to the ﬁle. If the String is user-
controllable, i.e., tainted, and the File object is passed to a FileInputStream
constructor, a path traversal vulnerability occurs. The ﬁle constructor in this
case is a required propagator that ensures the order of SM calls.

When it comes to the SM speciﬁcations, we observed that most of the
sources have a Return object as an out-value. For sinks, most of the in-values
are Parameter objects.

Additionally, we inspected the vulnerability types (known as Common
Weakness Enumerations - CWEs) in the SANS-25 list (Mitre, 2020a). 17 of 25
vulnerability types can be expressed as taint-style. 13 of those can be modeled
in ﬂuentTQL.

The remaining four CWEs are: CWE-119, CWE-787, CWE-476, and CWE-
798. Both, CWE-119 and CWE-787 are related to buﬀer overﬂows, which do
not apply to Java. The CWE-476 cannot be expressed because the potential
sources are new-expressions, which cannot currently be modeled. Also, con-
stant values cannot currently be modeled as potential sources which is needed
for CWE-798 where these values should be detected as hard-coded credentials.
Extending ﬂuentTQL to support new-expressions and constant values is pos-
sible in the abstract syntax by modeling them with a new class that extends
the class FlowParticipant. The semantics needs to be extended to deﬁne how
these values will be detected and deﬁne appropriate concrete syntax.

Even though our implementation of ﬂuentTQL if bound to Java only, ﬂu-
entTQL can express taint-style vulnerabilities in other languages too. To spec-
ify a query for other languages, the only requirement is that the sources, san-
itizers, and sinks are deﬁned as method calls. Similar to Java, ﬂuentTQL can
be adapted to work for C/C++, C#, other JVM-hosted languages and cover
a wide range of taint-style vulnerabilities. In languages such as JavaScript, the
coverage of vulnerabilities is smaller since the sources and sinks are often not
method calls.

ﬂuentTQL is able to express all taint-style vulnerabilities in which the key
constructs of the taint-ﬂows are method calls. Our implementation shows that
at least 11 types of security vulnerabilities can be speciﬁed with ﬂuentTQL.
These are the most popular security vulnerabilities for Java. Theoretically, one
can express many more.

6 https://github.com/OWASP/Benchmark/blob/master/src/main/java/org/owasp/

benchmark/testcode/BenchmarkTest00001.java

28

Piskachev, et. al

4.5 RQ4 Analyzing Java/Android Applications

To answer RQ4 we ran ﬂuentTQL queries on two Java applications, OWASP
WebGoat and PetClinic, and seven Android applications from TaintBench (Luo
et al., 2021).

The OWASP WebGoat is a deliberately insecure application aiming to
teach developers about relevant security vulnerabilities. As a Java Spring ap-
plication7, it is popular in the community and has been used for evaluating
static analyses (Antoniadis et al., 2020). We used this application to evaluate
the applicability of ﬂuentTQL on real-world scenario, including specifying
taint-ﬂow queries and running our Boomerang-based and FlowDroid-based
taint analysis.

We chose to work with the SQL injection as example since it has the most
taint-ﬂows in WebGoat. We documented all 17 SQL injection taint-ﬂows in
OWASP WebGoat and use them as ground truth. This was manually done by
following the directions of the lessons present in WebGoat and inspecting the
source code.

Next, we speciﬁed the sensitive methods which includes 17 sources, 1 sani-
tizer, 2 required propagators, and 2 sinks. We only needed to create two taint-
ﬂow queries to be able to cover all types of taint-ﬂows. The Boomerang-based
implementation was able to detect all 17 taint-ﬂows. The oﬃcial FlowDroid
implementation (we used version 2.8) was not able to ﬁnd any taint-ﬂow in
WebGoat. We investigated and found out that FlowDroid deﬁnes only the re-
turn values of the sources as taints. For all taint-ﬂows in WebGoat, the taints
are the parameters of the sources. Hence, we adapted FlowDroid to support
this and after doing so, the FlowDroid implementation detected 13 taint-ﬂows.
Those that were missed are the types that contain a required propagator which
is currently not supported by FlowDroid.

For the second Java application, PetClinic, we followed the same steps
as for OWASP WebGoat. We identiﬁed and documented ﬁve taint-ﬂows of
type hibernate injection and two taint-ﬂows of type cross-site request forgery.
In this application, all taint-ﬂows were detected by our implementation with
Boomerang and our updated version of FlowDroid. Table 5 shows summary
of the Java applications.

TaintBench is a collection of real-world Android apps that contain mali-
cious behavior in form of taint-ﬂows. These apps have well documented infor-
mation about the expected taint-ﬂows and should help analyses writers eval-
uate their tools in a rigorous and fair way. Table 6 summarizes the ﬁndings of
running our ﬂuentTQL implementation with Boomerang as well as with Flow-
Droid. Out of 25 expected taint-ﬂows among all apps the Boomerang-based
implementation found 18 whereas FlowDroid-based implementation found 13.
We manually inspected those that were not found and identiﬁed two causes
which are due to the existing solvers and not the inability of ﬂuentTQL to
express them. The ﬁrst cause is the inability to analyze taint-ﬂows through

7 https://spring.io/

ﬂuentTQL

29

diﬀerent threads in the code. Due to implicit data-ﬂow behavior of the threads,
the existing call graph algorithms have limitation in modeling this correctly.
This second cause is that the existing data-ﬂow analyses do not analyze the
expressions within path constraints. In the case of our experiments, we found
that the call of the source method is within the condition of an IF statement,
which is not analyzed by Boomerang nor by FlowDroid.

The runtime values reported in Table 5 and Table 6 are the average values
over ten runs on a system with Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz,
16 GB RAM with Win-10 OS.

51
52
53
54
55
56
57
58

59

60
61
62
63
64
65
66

67

68
69
70
71

private void loadClass ( Context context ) {

...
try {

InputStream is = getAssets () . open ( " ds " ) ;
int len = is . available () ;
byte [] encrypeData = new byte [ len ];
is . read ( encrypeData , 0 , len ) ;
byte [] rawdata = new DesUtils (

DesUtils . STRING_KEY ) . decrypt ( encrypeData ) ;

FileOutputStream fos = new

FileOutputStream ( sourcePathName ) ;

fos . write ( rawdata ) ;
fos . close () ;

} catch ( Exception e ) {

e . printStackTrace () ;

}
try {

Object [] argsObj = new

Object []{ sourcePathName , outputPathName ,
Integer . valueOf (0) };

DexFile dx = ( DexFile ) Class . forName (

" dalvik . system . DexFile " ) . getMethod ( " loadDex " ,
new Class []{ String . class , String . class ,
Integer . TYPE }) . invoke ( null , argsObj ) ;

...

} catch ( Exception e2 ) {
}

}

Listing 5: Malisious taint-ﬂow through a ﬁle in the dsencrypt app from TaintBench

Detecting taint-ﬂows through ﬁles. The code in Listing 5 shows the loadClass
method from the app dsencrypt 8 which contains the malicious taint-ﬂow. It
reads an encrypted zip ﬁle from asset folder (source in Line 54), decrypts it
and extracts class.dex which contains malicious code (intermediate statements
in the trace are lines 57, 58, and 59). The malicious code is called via reﬂection
(sink in Line 67). As reported in the work by Luo et al.(Luo et al., 2021), these
kind of taint-ﬂows going through ﬁles, databases, etc., can not be detected by
the existing Android taint analysis tools. With ﬂuentTQL, we are now able
to model and detect these taint-ﬂows using the and() operator.

8 https://github.com/TaintBench/dsencrypt_samp/blob/master/src/main/java/com/kbstar/

kb/android/star/ProxyApp.java

30

Piskachev, et. al

Table 5: Overview of the evaluated Java projects. Flows/B/F is number of ex-
pected taint-ﬂows (vulnerability instances) and those found by Boomerang and
FlowDroid, CWE is number of common weakness enumerations (vulnerability
types), Runtime is average over ten runs.

Project #Classes #Flows/B/F #CWE #Runtime(s) B/F
Catalog
PetClinic
WebGoat

52.8/43.7
10.9/14.4
30.3/36.7

27/27/25
4/4/4
17/17/13

36
42
35

11
1
1

Table 6: Overview of the evaluated Android apps from TaintBench. Flows/B/F
is number of expected taint-ﬂows (vulnerability instances) and those found by
Boomerang and FlowDroid, Runtime is average over ten runs.

App

#Classes #Flows/B/F #Runtime(s) B/F

blackﬁsh
beita_com_beita_contact
phospy
repane
dsencrypt
fakeappstore
fakemart

338
379
236
5
4
402
868

13/11/11
3/1/1
2/2/0
1/1/0
1/1/1
3/2/0
2/0/0

18.6/29.8
11.2/25.5
8.6/11.5
3/4.8
10.2/4.9
23/16.5
27.3/34.9

Our Boomerang-based implementation of ﬂuentTQL is able to detect all ex-
pected taint-ﬂows in the Java Spring applications: OWASP WebGoat and the
PetClinic. Among seven real-world Android apps with malicious taint-ﬂows,
ﬂuentTQL can detect 18 out of 25 expected taint-ﬂows. Those that can not be
detected are complex modeling of threads and not considering path conditions.

4.6 Threats to Validity

We next discuss the most relevant threats to the validity of our study design
and evaluation based on the threat types by Cook et al. (Cook and Campbell,
1979).

External validity. The participation in the study was voluntary. We asked our
contacts in industry to invite their software developers. The invitation men-
tioned that the study would try to compare two domain-speciﬁc languages
for static analysis. Having this information, it is more likely that the partici-
pants have some interest in the design of programming languages and/or static
analysis. Hence, there is a threat of having a subject not representative for the
entire population of software developers.

ﬂuentTQL

31

Internal validity. Apart from professional software developers, we invited re-
searchers and master-level students from the university. Previous work has
shown that graduate students are valid proxies for software developers in such
studies (Naiakshina et al., 2020, 2018, 2019, 2017). Also, our results conﬁrm
that there is no signiﬁcant correlation between the position of the participant
and the performance in the task, thus also conﬁrming that—for the purpose
of such studies—researchers and master-level students have coding knowledge
comparable to professional developers.

Moreover, the format of within-subjects study design has its own limi-
tations. As both tasks were the same, but for a diﬀerent DSL and context
(vulnerability example), when solving the second task, participants may have
be inﬂuenced by the ﬁrst task, known as carryover eﬀects. To deal with this
we applied randomization of the order of the tasks.

Construct validity. Another threat to validity is the fairness of the tasks. Both
DSLs are not equally expressible. This means one may need more or less time
to learn a new DSL. To address this, we took into consideration the following
points. First, we used vulnerabilities that have the same taint-ﬂow pattern. The
Java code shown as an example for each task had the same complexity. Second,
for each task, we provided a stub code for the solution. In the case of CodeQL,
which is more expressible DSL than ﬂuentTQL, and has support not only for
taint analysis but other analyses too, we asked the participants to focus only
on the taint analysis module. Finally, we had three test sessions to adjust the
tasks and deﬁne what exact information the participants will need to be able
to solve each task in under ten minutes. Similarly, a possible threat to validity
comes from the design of our study to use the open redirect vulnerability
with ﬂuentTQL and XSS for CodeQL for all participants without switching
among half of the participants. To mitigate the threat, we have selected the
code examples used in the tasks to have the same structure, i.e. the taint
was in both cases created by a call to an HTTP request object and only
the sink method diﬀers for each vulnerability. Additionally, while explaining
each task, we also explained the vulnerability. While the participants were
performing the task, we encouraged them to verbally share their thoughts.
After processing the recorded material, we ﬁnd none of the participants to
struggle with understanding the vulnerability itself.

5 Related Work

With few exceptions, such as DroidSafe (Gordon et al., 2015), which has hard-
coded SM, the SM of the existing static analyses can be customized by the
user, to some extend. In this section, we discuss the related approaches sum-
marized in Table 7 that shows design principals of each approach and level of
fulﬁllment to the requirements from Section 2.

32

Piskachev, et. al

Table 7: List of related approaches, their design characteristic, and their sup-
port of the requirements in Section 2.
- not fullﬁlled

- partially fullﬁlled,

- fullﬁlled,

d
e
t
n
e
i
r
o
-
t
c
e
j
b
o

e
k
i
l
-
l
a
r
e
n
e
g

d
e
s
a
b
-
n
r
e
t
t
a
p

s
t
n
i
a
r
t
s
n
o
c

s
n
o
i
t
a
t
o
n
n
a

R1 R2 R3 R4 R5 R6

e
v
i
t
a
r
a
l
c
e
d

Approach
CxQL (Checkmarx, 2020)
CodeQL (Github, 2020)
PIDGIN (Johnson et al., 2015)
IncA (Szabó et al., 2016)
CrySL (Krüger et al., 2019)
PQL (Martin et al., 2005)
CheckersF. (Dietl et al., 2011)
Apposcopy (Feng et al., 2014) X
X
Athena (Le and Soﬀa, 2011)
AQL (Pauck et al., 2018)
WAFL (Sridharan et al., 2011)
Saluki (Gotovchits et al., 2018) X
ﬂuentTQL

X
X

X X
X X X

X X

X
X

X X
X

X

X X
X X

X X
X

X X

Graph-based

Typestate

Other

5.1 Graph-based approaches

We group DSLs in this category that allow users to explicitly manipulate graph
structures to specify code patterns.

CxQL, the DSL of the tool Checkmarx (Checkmarx, 2020), is general-
purpose-like and object-oriented language. It supports a wide range of SM
(R1). The ﬂow propagation is done implicitly via the graph patterns (R2).
As a commercial tool it provides well integrated workﬂow for the users (R4 and
R5). Since CxQL is capable of expressing a broad range of graph properties,
it is hard to integrate it to a generic taint analysis (R6) as it is bound to the
tool’s core analysis.

CodeQL has good integration in the developers’ workﬂow (R5) with plug-
ins for popular IDEs as well as web-based interface. It is a declarative language
with support for predicates and object-oriented design. The DSL can express
a wide range of properties similar to CxQL.

PIDGIN (Johnson et al., 2015) follows the object-oriented design. It is not
designed for taint analysis, therefore it is hard to integrate it in a generic way
(R6). PIDGIN does not provide tool integrations for software developers.

IncA (Szabó et al., 2016) is a DSL for speciﬁcation of the rules for in-
cremental execution of static analyses. Compared to the other DSL in this
category it is the least expressive and targets very speciﬁc domain. The SM
and ﬂow propagation can be expressed through the graph patterns (R1, R2).
User-deﬁned messages are not supported (R4).

ﬂuentTQL

5.2 Typestate approaches.

33

This category consists of two DSLs, i.e. CrySL and PQL, which are designed
for typestate analysis, that detects the incorrect API usage.

CrySL (Krüger et al., 2019) enables cryptography experts to specify the
correct usage of the crypto API making it not suitable for generic taint anal-
ysis (R6). The DSL is declarative with mechanism based on predicates and
constraints. It has a full support for SM and ﬂow propagation (R1, R2). The
tool support is maintained.

PQL (Martin et al., 2005) is declarative DSL with speciﬁcations compara-
ble to CrySL. Compared to ﬂuentTQL, the PQL’s syntax signiﬁcantly diﬀers
from regular Java syntax making it diﬃcult to use for non-experts. PQL does
not ship with available tooling support for the users (R6).

5.3 Other approaches.

The approach used in CheckersFramework (Dietl et al., 2011) is based on the
annotations @tainted and @untainted which developers can use to annotate
their code to mark custom SM. The annotation speciﬁcation requires addi-
tional manual work, which - in the case of legacy code - is even infeasible
(R5). The CheckersFramework allows to conﬁgure the messages that are re-
ported (R4).

Apposcopy (Feng et al., 2014) is a Android-speciﬁc taint analysis (R6) with
a Datalog-based DSL for data-ﬂow and control-ﬂow predicates. The sources,
sinks, and propagators are speciﬁed in form of annotations (R1, R2). We were
not able to ﬁnd tooling support (R5) for the language.

Athena (Le and Soﬀa, 2011) is a declarative DSL based on patterns and
constraints with explicit support for SM and ﬂow propagations (R1, R2).
Athena does not support user-deﬁned messages and is tightly coupled to a
generator of analysis conﬁgurations.

AQL (Pauck et al., 2018) is an Android-speciﬁc (R6) querying language for
taint ﬂow results from diﬀerent taint analysis tools. It supports speciﬁcations
of sources and sinks (R1) and ﬂow propagations (R2) and provides workﬂow
with tool support for developers to query taint results from multiple tools
(R5).

WAFL is the DSL of the F4F approach (Sridharan et al., 2011) and is
a general-purpose-like language with object-oriented design that allows the
speciﬁcation of reﬂective behavior in frameworks so that static analyses can
propagate the ﬂow. WAFL has partial support for SM and ﬂow propagation
(R1, R2). Its main purpose is modeling of frameworks.

Finally, Saluki (Gotovchits et al., 2018) is a declarative DSL where method
patterns can be speciﬁed. SM and ﬂow propagation are supported (R1, R2),
but complex ﬂows not (R3).

34

6 Conclusion

Piskachev, et. al

Static and dynamic taint analyses can detect many popular vulnerability types.
Using them during development time can reduce the costs. To use taint analysis
tools eﬃciently, software developers need to conﬁgure them to their contexts.
We proposed ﬂuentTQL, a new domain-speciﬁc language for taint analysis
designed to be used by software developers. ﬂuentTQL is able to express
many taint-style vulnerability types. It supports single-step as well as multi-
step taint-ﬂow queries. Moreover, taint-ﬂow queries can be combined with and
operator to express parallel taint-ﬂows. ﬂuentTQL uses Java ﬂuent interface
as a concrete syntax. Its semantics is independent of a concrete implementation
of taint analysis, making it easy for integration into existing tools.

In a comparative, within-subjects user study, ﬂuentTQL showed to be
more usable for software developers than CodeQL, a state-of-the-art DSL of
the commercial tool LGTM. Participants were faster in solving the task of
specifying a taint-ﬂow query for given vulnerability type in ﬂuentTQL than
in CodeQL.

In future, we plan to make ﬂuentTQL more expressive. With ﬂuentTQL,
only method calls can be modeled as sources and sinks. We will add support
for modeling speciﬁc variables, such as constant values for detecting hardcoded
credentials and nullable variables for detecting null pointer dereferences. More-
over, we will add support for regular expressions to ease the speciﬁcation of
methods in case of method overloading in Java. Additionally, we plan on inves-
tigating the usefulness of incorporating the concept of entry point as part of
ﬂuentTQL. Finally, we are working on further evaluations of the applicability
of ﬂuentTQL in other real-world large-scale Java applications and creating
new queries for detecting more security vulnerabilities.

Acknowledgements We gratefully acknowlede the funding by the project "AppSecure.nrw
- Security-by-Design of Java-based Applications" of the European Regional Development
Fund (ERDF-0801379). We thank Ranjith Krishnamurthy and Abdul Rehman Tareen for
their contribution to the implementation of the MagpieBridge server.

Authors’ contributions: The ﬁrst author is the main contributor to this
research. The second and fourth author contributed with conceptual ideas and
feedback. The third author contributed to the implementation and with ideas
for the concrete syntax of ﬂuentTQL.

Data availability: https://ﬂuenttql.github.io/
Code availability: https://github.com/secure-software-engineering/secucheck

Declarations

Ethics approval: The user study design has been approved for ethical cor-
rectness by one of the companies participated in the study as well as by the
corresponding head of department at Fraunhofer IEM.

ﬂuentTQL

35

Consent to participate and publication: For the user study described
in section 4, all 26 participants signed a written consent form in which they
agreed to participate voluntarily in the study. They also agreed that the col-
lected data can be used for research publication. The written consent form
was obtained from all participants before the study.

Conﬂicts of interest/Competing interests: Not applicable

References

Antoniadis A, Filippakis N, Krishnan P, Ramesh R, Allen N, Smaragdakis
Y (2020) Static analysis of java enterprise applications: Frameworks and
caches, the elephants in the room. In: Proceedings of the 41st ACM
SIGPLAN Conference on Programming Language Design and Implemen-
tation, ACM, New York, NY, USA, PLDI 2020, pp 794 – 807, DOI
10.1145/3385412.3386026

Arzt S, Rasthofer S, Bodden E (2013) Susi: A tool for the fully automated
classiﬁcation and categorization of android sources and sinks. In: Network
and Distributed System Security Symposium 2013, NDSS’13

Arzt S, Rasthofer S, Fritz C, Bodden E, Bartel A, Klein J, Traon YL, Octeau
D, McDaniel P (2014) Flowdroid: Precise context, ﬂow, ﬁeld, object-sensitive
and lifecycle-aware taint analysis for android apps. In: Proceedings of the
35th ACM SIGPLAN Conference on Programming Language Design and
Implementation, ACM, New York, NY, USA, PLDI ’14, pp 259–269

Bodden E (2018) The secret sauce in eﬃcient and precise static analysis: The
beauty of distributive, summary-based static analyses (and how to master
them). In: ACM SIGPLAN International Workshop on the State Of the Art
in Java Program Analysis (SOAP 2018), ACM, New York, NY, USA, ISSTA
’18, pp 85–93

Brooke J (2013) Sus: A retrospective. J Usability Studies 8(2):29–40
Checkmarx (2020) Checkmarx. https://www.checkmarx.com/, online; ac-

cessed January 2021

Chibotaru V, Bichsel B, Raychev V, Vechev M (2019) Scalable taint speciﬁ-
cation inference with big code. In: Proceedings of the 40th ACM SIGPLAN
Conference on Programming Language Design and Implementation, ACM,
New York, NY, USA, PLDI 2019, pp 760–774

Christakis M, Bird C (2016) What developers want and need from program
analysis: An empirical study. In: Proceedings of the 31st IEEE/ACM Inter-
national Conference on Automated Software Engineering, ACM, New York,
NY, USA, ASE 2016, pp 332–343

Cook TD, Campbell DT (1979) Quasi-Experimentation: Design and Analysis

Issues for Field Settings. Boston: Houghton Miﬄin, Boston, USA

Dietl W, Dietzel S, Ernst MD, Muşlu K, Schiller TW (2011) Building and us-
ing pluggable type-checkers. In: Proceedings of the 33rd International Con-
ference on Software Engineering, ACM, New York, NY, USA, ICSE11, pp
681–690

36

Piskachev, et. al

Feng Y, Anand S, Dillig I, Aiken A (2014) Apposcopy: Semantics-based de-
tection of android malware through static analysis. In: Proceedings of the
22nd ACM SIGSOFT International Symposium on Foundations of Software
Engineering, ACM, New York, NY, USA, FSE 2014, pp 576–587

Girden ER (1992) ANOVA: Repeated measures. 84, Sage
Github S (2020) Lgtm. http://lgtm.com/, online; accessed January 2021
Gordon MI, Kim D, Perkins JH, Gilham L, Nguyen N, Rinard MC (2015)
Information ﬂow analysis of android applications in droidsafe. In: 22nd An-
nual Network and Distributed System Security Symposium, NDSS 2015,
San Diego, California, USA, February 8-11, 2015, The Internet Society
Gotovchits I, van Tonder R, Brumley D (2018) Saluki: ﬁnding taint-style
vulnerabilities with static property checking. In: Proceedings of the NDSS
Workshop on Binary Analysis Research

Grammatech (2020) Codesonar. https://www.grammatech.com/products/

codesonar, online; accessed January 2021

Grech N, Fourtounis G, Francalanza A, Smaragdakis Y (2018) Shooting from
the heap: Ultra-scalable static analysis with heap snapshots. In: Proceedings
of the 27th ACM SIGSOFT International Symposium on Software Testing
and Analysis, ACM, New York, NY, USA, ISSTA 2018, pp 198–208

Johnson A, Waye L, Moore S, Chong S (2015) Exploring and enforcing security
guarantees via program dependence graphs. SIGPLAN Not 50(6):291–302
Johnson B, Song Y, Murphy-Hill E, Bowdidge R (2013) Why don’t software
developers use static analysis tools to ﬁnd bugs? In: Proceedings of the
International Conference on Software Engineering, IEEE Press, Piscataway,
NJ, USA, ICSE ’13, pp 672–681

Krüger S, Späth J, Ali K, Bodden E, Mezini M (2019) Crysl: An extensi-
ble approach to validating the correct usage of cryptographic apis. IEEE
Transactions on Software Engineering

Le W, Soﬀa ML (2011) Generating analyses for detecting faults in path seg-
ments. In: Proceedings of the 2011 International Symposium on Software
Testing and Analysis, ACM, New York, NY, USA, ISSTA11, pp 320–330
Livshits B (2012) Dynamic taint tracking in managed runtimes. Tech. rep.,

Microsoft Research

Livshits B, Nori AV, Rajamani SK, Banerjee A (2009) Merlin: Speciﬁcation
inference for explicit information ﬂow problems. SIGPLAN Not 44(6):75–86
Luo L, Dolby J, Bodden E (2019) MagpieBridge: A General Approach to
Integrating Static Analyses into IDEs and Editors (Tool Insights Paper).
In: Donaldson AF (ed) 33rd European Conference on Object-Oriented Pro-
gramming (ECOOP 2019), Schloss Dagstuhl–Leibniz-Zentrum fuer Infor-
matik, Dagstuhl, Germany, vol 134, pp 21:1–21:25, DOI 10.4230/LIPIcs.
ECOOP.2019.21

Luo L, Pauck F, Piskachev G, Benz M, Pashchenko I, Mory M, Bodden E,
Hermann B, Massacci F (2021) Taintbench: Automatic real-world malware
benchmarking of android taint analyses. Empirical Software Engineering
Martin M, Livshits B, Lam MS (2005) Finding application errors and security
ﬂaws using pql: A program query language. SIGPLAN Not 40(10):365–383

ﬂuentTQL

37

Microfocus (2020) Fortify. https://www.microfocus.com/en-us/products/
static-code-analysis-sast/overview, online; accessed January 2021
Microsoft (2020) Language server protocol. https://microsoft.github.io/

language-server-protocol/, online; accessed January 2021

Mitre CWE (2020a) 2011 cwe/sans top 25 most dangerous software errors.

http://cwe.mitre.org/top25/, online; accessed January 2021

Mitre CWE (2020b) Cwe home page. http://cwe.mitre.org/, online; ac-

cessed January 2021

Mitre CWE (2020c) Improper neutralization of data within xpath expres-
sions. https://cwe.mitre.org/data/definitions/643.html, online; ac-
cessed January 2021

Mitre CWE (2020d) Improper neutralization of input during web page gen-
eration. https://cwe.mitre.org/data/definitions/79.html, online; ac-
cessed January 2021

Mitre CWE (2020e) Improper neutralization of special elements in data query
logic. https://cwe.mitre.org/data/definitions/943.html, online; ac-
cessed January 2021

Mitre CWE (2020f) Improper neutralization of special elements used in a
command. https://cwe.mitre.org/data/definitions/77.html, online;
accessed January 2021

Mitre CWE (2020g) Improper neutralization of special elements used in an
ldap query. https://cwe.mitre.org/data/definitions/90.html, online;
accessed January 2021

Mitre CWE (2020h) Improper neutralization of special elements used in an sql
command. https://cwe.mitre.org/data/definitions/89.html, online;
accessed January 2021

Mitre CWE (2020i) Improper output neutralization for logs. https://cwe.
mitre.org/data/definitions/117.html, online; accessed January 2021
Mitre CWE (2020j) Relative path traversal. https://cwe.mitre.org/data/

definitions/23.html, online; accessed January 2021

Mitre CWE (2020k) Trust boundary violation. https://cwe.mitre.org/

data/definitions/501.html, online; accessed January 2021

Mitre CWE (2020l) Url redirection to untrusted site (open redirect). https:
//cwe.mitre.org/data/definitions/601.html, online; accessed January
2021

Mitre CWE (2020m) Xml

injection.

https://cwe.mitre.org/data/

definitions/91.html, online; accessed January 2021

Naiakshina A, Danilova A, Tiefenau C, Herzog M, Dechand S, Smith M (2017)
Why do developers get password storage wrong? a qualitative usability
study. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security, ACM, New York, NY, USA, CCS 17, pp
311–328, DOI 10.1145/3133956.3134082

Naiakshina A, Danilova A, Tiefenau C, Smith M (2018) Deception task design
in developer password studies: Exploring a student sample. In: Proceed-
ings of the Fourteenth USENIX Conference on Usable Privacy and Security,
USENIX Association, USA, SOUPS 18, pp 297–313

38

Piskachev, et. al

Naiakshina A, Danilova A, Gerlitz E, von Zezschwitz E, Smith M (2019) If you
want, i can store the encrypted password: A password-storage ﬁeld study
with freelance developers. In: Proceedings of the Conference on Human Fac-
tors in Computing Systems, ACM, New York, NY, USA, CHI 19, pp 1–12
Naiakshina A, Danilova A, Gerlitz E, Smith M (2020) On conducting security
developer studies with cs students: Examining a password-storage study
with cs students, freelancers, and company developers. In: Proceedings of
the 2020 CHI Conference on Human Factors in Computing Systems, ACM,
New York, NY, USA, CHI 20, pp 1–13

Nguyen Quang Do L, Bodden E (2020) Explaining static analysis with rule
graphs. IEEE Transactions on Software Engineering pp 1–1, DOI 10.1109/
TSE.2020.3004525

Nguyen Quang Do L, Wright JR, Ali K (2020) Why do software developers
use static analysis tools? a user-centered study of developer needs and mo-
tivations. In: Proceedings of the Sixteenth Symposium on Usable Privacy
and Security, DOI 10.1109/TSE.2020.3004525

OWASP

(2020a)

Owasp

benchmark.

https://owasp.org/

www-project-benchmark/, online; accessed January 2021

OWASP OWASP (2020b) Owasp top 10 most critical web application se-
curity risks. https://www.owasp.org/index.php/Category:OWASP_Top_
Ten_Project, online; accessed January 2021

Pauck F, Bodden E, Wehrheim H (2018) Do android taint analysis tools keep
their promises? In: Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering, ACM, New York, NY, USA, ESEC/FSE
2018, pp 331–341

Piskachev G, Do LNQ, Bodden E (2019) Codebase-adaptive detection of
security-relevant methods. In: Proceedings of the 28th ACM SIGSOFT In-
ternational Symposium on Software Testing and Analysis, ACM, New York,
NY, USA, ISSTA 2019, pp 181–191

Reichheld FF (2003) The one number you need to grow. Harvard business

review 81(12):46–55

Sas D, Bessi M, Fontana FA (2018) Automatic detection of sources and sinks
in arbitrary java libraries. In: 2018 IEEE 18th International Working Con-
ference on Source Code Analysis and Manipulation (SCAM), pp 103–112
Schwartz EJ, Avgerinos T, Brumley D (2010) All you ever wanted to know
about dynamic taint analysis and forward symbolic execution (but might
have been afraid to ask). In: 2010 IEEE Symposium on Security and Privacy,
pp 317–331, DOI 10.1109/SP.2010.26

SecuCheck RP (2021) Interviews with developers. https://secucheck.

github.io/, online; accessed January 2021

Smith J, Johnson B, Murphy-Hill E, Chu B, Lipford HR (2019) How developers
diagnose potential security vulnerabilities with a static analysis tool. IEEE
Transactions on Software Engineering 45(9):877–897

Smith J, Nguyen Quang Do L, Murphy-Hill E (2020) Why can’t johnny ﬁx
vulnerabilities: A usability evaluation of static analysis tools for security. In:

ﬂuentTQL

39

Proceedings of the Sixteenth Symposium on Usable Privacy and Security,
SOUPS 2020

Song T, Li X, Feng Z, Xu G (2019) Inferring patterns for taint-style vulnera-

bilities with security patches. IEEE Access 7:52339–52349

Späth J, Ali K, Bodden E (2019) Context-, ﬂow-, and ﬁeld-sensitive data-
ﬂow analysis using synchronized pushdown systems. Proceedings of the
ACM SIGPLAN Symposium on Principles of Programming Languages
3(POPL):48:1–48:29

Sridharan M, Artzi S, Pistoia M, Guarnieri S, Tripp O, Berg R (2011)
F4f: Taint analysis of framework-based web applications. SIGPLAN Not
46(10):1053–1068

Stahl T, Voelter M, Czarnecki K (2006) Model-Driven Software Development:
Technology, Engineering, Management. John Wiley Sons, Inc., Hoboken,
NJ, USA

Szabó T, Erdweg S, Voelter M (2016) Inca: A dsl for the deﬁnition of incre-
mental program analyses. In: Proceedings of the 31st IEEE/ACM Interna-
tional Conference on Automated Software Engineering, ACM, New York,
NY, USA, ASE 2016, pp 320–331

Thomé J, Shar LK, Bianculli D, Briand LC (2017) Joanaudit: A tool for
auditing common injection vulnerabilities. In: Proceedings of the 2017 11th
Joint Meeting on Foundations of Software Engineering, ACM, New York,
NY, USA, ESEC/FSE 2017, pp 1004–1008

