Eur. Phys. J. C manuscript No.
(will be inserted by the editor)

2
2
0
2

y
a
M
3

]
h
p
-
p
e
h
[

1
v
2
6
7
1
0
.
5
0
2
2
:
v
i
X
r
a

EpIC: novel Monte Carlo generator for exclusive processes

E. C. Aschenauera,1, V. Batozskayab,2, S. Fazioc,3, K. Gatesd,4,
H. Moutardee,5, D. Sokhanf,5,4, H. Spiesbergerg,6, P. Sznajderh,2,
K. Tezgini,1

1 Department of Physics, Brookhaven National Laboratory, Upton, New York 11973
2 National Centre for Nuclear Research (NCBJ), Pasteura 7, 02-093 Warsaw, Poland
3 University of Calabria & INFN-Cosenza, Italy
4 University of Glasgow, Glasgow G12 8QQ, United Kingdom
5 IRFU, CEA, Universit´e Paris-Saclay, F-91191 Gif-sur-Yvette, France
6 PRISMA+ Cluster of Excellence, Institut f¨ur Physik, Johannes Gutenberg-Universit¨at, D-55099 Mainz, Germany

Received: date / Accepted: date

Abstract We present the EpIC Monte Carlo event
generator for exclusive processes sensitive to gener-
alised parton distributions. EpIC utilises the PAR-
TONS framework, which provides a ﬂexible software
architecture and a variety of modelling options for the
partonic description of the nucleon. The generator of-
fers a comprehensive set of features, including multi-
channel capabilities and radiative corrections. It may
be used both in analyses of experimental data, as well
as in impact studies, especially for future electron-ion
colliders.

1 Introduction

The objective of this study is to develop a Monte
Carlo event generator for exclusive processes involving
hadrons remaining coherent during interactions with
high-energy leptons. The factorisation theorems devel-
oped in the framework of quantum chromodynamics
(QCD) allow one to describe such processes in terms of
non-perturbative generalised parton distribution func-
tions (GPDs) [1–5] convoluted with perturbatively cal-
culable hard scattering subprocesses.

GPDs are universal, process-independent functions
that parametrise the oﬀ-forward nucleon matrix ele-
ments of quark and gluon bilinear operators with light-

ae-mail: elke@bnl.gov
be-mail: varvara.batozskaya@ncbj.gov.pl
ce-mail: salvatore.fazio@unical.it
de-mail: k.gates.1@research.gla.ac.uk
ee-mail: herve.moutarde@cea.fr
fe-mail: daria.sokhan@cea.fr
ge-mail: spiesber@uni-mainz.de
he-mail: pawel.sznajder@ncbj.gov.pl
ie-mail: ktezgin@bnl.gov

like separations. In case there is no momentum trans-
fer to the nucleon, i.e. in the forward limit, certain
GPDs become equivalent to PDFs. Additionally, the
ﬁrst Mellin moments of GPDs are related to elastic form
factors. In this regard, GPDs may be viewed as a uni-
ﬁed concept of elastic form factors studied via elastic
scattering processes and one-dimensional parton distri-
bution functions studied via (semi-) inclusive scattering
processes. Another key aspect of GPDs is their rela-
tion to nucleon tomography. The Fourier transform of
GPDs are related to the impact parameter space distri-
butions when there is no collinear, but ﬁnite transverse
momentum transfer to the nucleon [6–8]. This relation
enables nucleon tomography, which involves the correla-
tion between impact space distribution functions, par-
ton polarization, and the longitudinal momentum frac-
tions carried by partons. GPDs also exhibit a unique re-
lationship with energy-momentum tensor (EMT) form
factors, which encode fundamental properties of the nu-
cleon, such as mass and spin decomposition of the nu-
cleon into its constituent parts (including orbital angu-
lar momentum) [2, 3, 9] as well as its internal structure
based on the so-called “mechanical” forces [10–12]. For
more information on GPDs, we refer to the available
reviews on the subject, like Ref. [13].

The extraction of GPDs from data on exclusive pro-
cesses is not an easy task, mainly due to the diﬃculty of
the inverse problem one must solve. Namely, typically
many types of GPDs contribute to a given process, and
it is necessary to deconvolute them all from the process
amplitude. In order to accomplish this, measurements
of many diﬀerent types of processes are needed in a wide
range of kinematic domains. Therefore, measurements
of exclusive processes have been performed in several
facilities, such as DESY, JLAB, and CERN. In addi-

 
 
 
 
 
 
2

tion to that, GPDs are pillars of scientiﬁc programmes
for a new generation of machines. This includes both
electron-ion colliders, such as EIC [14, 15], EIcC [16]
and LHeC [17], and ﬁxed target experiments, such as
AMBER at CERN [18] and JLAB12 [19].

As part of this global eﬀort, we have developed
a Monte Carlo (MC) generator called EpIC, whose
logo appears in Fig. 1. The EpIC generator features
a novel architecture based on the modularity program-
ming paradigm. In this way, the code structure is kept
as simple as possible and the addition of new develop-
ments, such as new channels or algorithms to gener-
ate random numbers, is made as easy as possible. The
architecture of EpIC, including the nomenclature for
naming its elements, is based on the PARTONS frame-
work [20]. PARTONS is also used to evaluate the Born
cross-section for a given process, which is used to gen-
erate MC events after the inclusion of radiative correc-
tions (RCs).

Fig. 1 Logo of the project.

EpIC can generate events for a number of ex-
clusive processes. The following are available at the
time of this writing: deeply virtual Compton scat-
tering (DVCS), time-like Compton scattering (TCS),
and deeply virtual meson production (DVMP) of π0
and π+ mesons. In this article, we choose the case
of DVCS whenever an exemplary process is needed.
Adapting to other processes is straightforward and
typically only requires replacing the acronym, e.g.
the equivalence of DVCSGeneratorService for TCS is
TCSGeneratorService. EpIC, as in the case of PAR-
TONS, follows the so-called Trento convention [21] for
the deﬁnition of e.g. scattering angles.

The purpose of this article is to provide a reference
to be used for a better understanding of EpIC’s struc-
ture and its functioning. We will mostly focus on the
explanation of the architecture, starting with a brief de-
scription of the PARTONS framework in Sect. 2. Topics
covered in that section are crucial to understand the
technical aspects of EpIC. In Sect. 3, we present the
architecture of EpIC. In particular, we list all types of
modules and show the relation between them. The user
interface is introduced in Sect. 4, while the demonstra-

tion of the generator’s performance is shown in Sect.
5. The summary is given in Sect. 6. In the appendix of
the article (Appendix A), we review the basics of ra-
diative corrections and explain how to compute them
in the collinear approximation. The purpose of this ap-
pendix is to help users familiarise themselves with the
parameters of RC used in EpIC.

EpIC is written in the C++ programming language.
The code can be accessed at the GitHub platform [22]
and is distributed under the GPL 3.0 licence. The
project’s webpage, Ref. [23], includes information such
as a technical documentation of C++ classes, a guide
on how to compile the code, and example code for users.

2 PARTONS framework

PARTONS (PARtonic Tomography Of Nucleon Soft-
ware) [20] is a software framework for studying the 3D
structure of hadrons. It provides essential tools for QCD
phenomenology and allows one to compute observables
from the models of non-perturbative objects. For in-
stance, it includes various models of GPDs and meth-
ods to perform their pQCD evolution. It also includes
methods to evaluate amplitudes and cross-sections for a
variety of exclusive processes, like DVCS and TCS, de-
scribed at various orders of pQCD precision. The frame-
work can be used in analyses to predict observables
from existing models, see e.g. Refs. [15, 16, 24], but also
to constrain new models from available experimental
data [25, 26]. Because of its versatility, the framework
can also act as a laboratory for studying new concepts
for phenomenology, like new ways of modelling, see e.g.
Refs. [27–29].

What distinguishes PARTONS from other software
projects used in the ﬁeld of particle physics is its archi-
tecture utilising the modular programming paradigm.
The central role in this architecture, which has been
also adopted in EpIC, is played by the modules. A mod-
ule is a single encapsulated development of a given type,
for instance a single GPD model. The only purpose of
modules is to provide data for a speciﬁc input, like val-
ues of GPDs for a given GPD kinematics. The construc-
tion of modules utilises both the inheritance and poly-
morphism mechanisms of C++. Therefore, the devel-
opment of new modules is remarkably straightforward,
as developers need only to provide their code related
to the developments they are interested in and adapt it
to the predeﬁned classes in the framework. We demon-
strate this with the example of GPDGK11 module, which
is used to implement the Goloskokov-Kroll (GK) GPD
model [30–32], from the PARTONS library. The follow-
ing is an excerpt from the header ﬁle:

namespace PARTONS {

class GPDGK11: public GPDModule {

public:

//Unique ID to automatically register the class in
(cid:44)→
static const unsigned int classId;

the registry.

//Constructor.
//Class name is passed to GPDModule constructor.
GPDGK11(const std::string& className);

//Used for automation.
virtual void configure(const ElemUtils::Parameters&
(cid:44)→

parameters);

//Function containing the evaluation of GPD H.
virtual PartonDistribution computeH();

...
};
}

where only the most relevant members of the class
are shown, some of which will be discussed further in
this section. The purpose of the GPDGK11 module is to
evaluate the values of GPDs. This task is predeﬁned
in GPDModule, being in terms of inheritance the par-
ent class of GPDGK11. The predeﬁnition means here the
declaration of a virtual function, so that each derived
classes (GPDGK11, GPDGK16, . . . ) have a function of the
same signature among its members, but the actual im-
plementation of this function in those classes is in gen-
eral diﬀerent. The evaluation of GPDs takes place, for
instance, in the following function:

using namespace PARTONS;

PartonDistribution GPDGK11::computeH(){

//Protected variables that store input GPD kinematics
to be used by developers.
(cid:44)→
m_x; m_xi; m_t; m_MuF2, m_MuR2;

...

//Container to be returned.
PartonDistribution partonDistribution;

for up quarks.

//Store values of H, H (+) and H (−), respectively,
(cid:44)→
//Results for other flavours can be added
(cid:44)→
partonDistribution.addQuarkDistribution(
(cid:44)→

QuarkDistribution( QuarkFlavor::UP, ..., ...,
...));

analogously.

(cid:44)→

3

The function GPDGK11::computeH() returns a con-
tainer that stores the numerical values of GPDs of
including singlet, H (+), and non-singlet,
type H,
H (−), combinations, as deﬁned in Ref.
[13]. The
input GPD kinematics is accessible in the body of
the function via the m_x, m_xi, m_t, m_MuF2 and
m_MuR2 variables, which are deﬁned in the GPDModule
class. Those variables correspond to x (average lon-
gitudinal momentum fraction carried by the active
parton), ξ (skewness parameter), t (four-momentum
transfer to the hadron target), µ2
F (factorisation scale
squared) and µ2
R (renormalisation scale squared)
GPDs depend on. They are set when one evaluates
GPDs
PartonDistribution compute(const
GPDKinematic& kinematic, GPDType::Type
gpdType), which is also deﬁned in GPDModule. As
one may see,
in our example quark ﬂavours and
GPD types are distinguished by QuarkFlavor and
GPDType enums, respectively, while inputs and out-
puts are encapsulated in the QuarkDistribution,
PartonDistribution and GPDKinematic containers.

via

A single instance of each module is loaded into mem-
ory at the beginning of the program execution, namely,
when static constant variables are initialised. The ad-
dresses of such instances are stored by the registry,
which later acts as a phone book, allowing one to access
the instances by either their IDs or deﬁned names. We
demonstrate this mechanism with the following exam-
ple:

using namespace PARTONS;

const unsigned int GPDGK11::classId =
(cid:44)→

BaseObjectRegistry::getInstance()->
registerBaseObject(new GPDGK11("GPDGK11"));

(cid:44)→

When the program starts, GPDGK11::classId is ini-
tialised with a unique ID assigned by the registry
(BaseObjectRegistry class being a singleton). During
this process, the registry takes and stores the address of
each new instance. All modules inherit from the same
basic class called BaseObject, allowing the registry to
store addresses of the same type of objects. The con-
structor of BaseObject requires a unique string of char-
acters that is used as a human-readable name of the
module.

The registry stores addresses of single instances of
pre-conﬁgured modules. Users may get copies of those
instances by using the factory (also being a singleton),
for instance:

//Store value of H for gluons.
partonDistribution.setGluonDistribution(...);

return partonDistribution;
}

using namespace PARTONS;

GPDModule* pGPDModel = nullptr;

//Get by ID.

4

pGPDModel = Partons::getInstance()->
(cid:44)→

getModuleObjectFactory()->
newGPDModule(GPDGK11::classId);

(cid:44)→

//Get by name
pGPDModel = Partons::getInstance()->
(cid:44)→

getModuleObjectFactory()->
newGPDModule("GPDGK11");

(cid:44)→

The registry and factory are the key architectural ingre-
dients, which allow users to add an unlimited number
of new modules in the PARTONS architecture, without
having to modify existing modules.

There are many types of modules, but one
i.e. pass additional
may conﬁgure all of
them,
in a generic way,
information to the modules,
avoiding,
casting. This
to the void configure(const
is possible thanks
ElemUtils::Parameters& parameters) virtual func-
tions, which developers may use to allow transferring
additional parameters to modules. For instance:

instance,

static

the

for

using namespace PARTONS;

void configure(const ElemUtils::Parameters&
(cid:44)→

parameters){

//Check if parameter is available.
if (parameters.isAvailable("myKey")) {

//Set.
int myVariable =
parameters.getLastAvailable().toInt();

(cid:44)→

}

}

can be used to set myVariable variable to 1 in the fol-
lowing way:

//Container for multiple parameters.
ElemUtils::Parameters parameters;

would also be time consuming and vulnerable to mis-
takes.

3 EpIC’s architecture

The generic architecture of the generator, including the
ﬂow of data transferred between the modules, is shown
in Fig. 2. Each module takes input data, processes it ac-
cording to predeﬁned tasks, and returns the correspond-
ing output. The actual implementation of some types
of modules depends on the simulated process. For in-
stance, RCModule is the parent class for DVCSRCModule
and TCSRCModule, which are used for DVCS and TCS
processes, respectively. These two types of modules pro-
cess data according to the same task predeﬁned in
RCModule, but they use diﬀerent inputs. It is either
DVCS or TCS kinematics. Because of this diﬀerence,
RCModule has been developed as a C++ template, al-
lowing DVCSRCModule and TCSRCModule to handle in-
put containers of various types. With those templates,
the addition of new processes to the generator is as
easy as possible. DVCSRCModule and TCSRCModule are
used as base classes for actual modules, where speciﬁc
physics developments are encoded. In Fig. 3 we present
the entire tree of inheritance for modules of RCModule
type.

Below, we provide a brief description of each type
of module and its purpose. Additionally, we indicate
whether the actual implementation of modules of a
given type depends on the simulated process. This in-
formation is useful in recognising which parts of the
generator need to be extended when a new process is
added to the generator.

//Set.
parameters.add(ElemUtils::Parameter("myKey", 1));

3.1 RCModule

//Pass.
pMyModule->configure(parameters);

where "myKey" is the unique name of the parameter.
The way of supplying modules with additional param-
eters presented here plays a crucial role in constructing
user interface (UI).

To avoid “manually” repeating some tasks, the ser-
vices are used. In this way, users can perform complex
tasks in a straightforward and robust manner by hiding
the complexity of low-level functions. The services link
such tasks as parsing input ﬁles, running many com-
putations, employing multi-threading computing, ﬁll-
ing the database, printing the output to the screen etc.
Without services, all those tasks would have to be done
explicitly by users, requiring a profound knowledge of
the functioning of the project. This way of working

Purpose: Simulation of radiative corrections.

Does it depend on the generated process? Yes.

Description: In EpIC events are generated according to
the probability distribution given by:

dσ(X (cid:48), Z) = dσ0(X) R(Z) .

(1)

Here, dσ0(X) is the Born cross-section (given by PAR-
TONS), while R(Z) is the radiator function. The set of
variables that the Born cross-section depends on is de-
noted by X, for instance X = {xBj, t, Q2, φ, φS, El} for
DVCS, where xBj and Q2 are the usual DIS variables,
φ is the angle between the lepton scattering plane and
the production plane, φS is the angle between the lep-
ton scattering plane and the target spin component per-
pendicular to the direction of the virtual photon, and

5

Fig. 2 Sketch showing the generic architecture of the project, i.e. without specifying the corresponding physics process for
some modules. Details are provided in the text.

El is the lepton energy in the ﬁxed target frame [20].
Because of the radiative corrections, the values of those
variables may be diﬀerent from those for a generated
event, X (cid:48). The radiator function, on the other hand,
depends on the set of variables Z. The number of vari-
ables making this set depends on the approximation one
uses. For instance, if one considers the collinear approx-
imation and only the initial and ﬁnal state radiations of
single photons from the incoming and scattered leptons,
two variables make the set Z, namely Z = {z1, z3}, see
Appendix A for more details.

Taking the above in mind, modules of RCModule
type perform three actions: i ) they deﬁne a number
of variables that the radiative corrections depend on,
i.e. they deﬁne the set Z, ii ) they implement a func-
tion used for the evaluation of R(Z), but also for the
evaluation of “true” kinematics entering the Born cross-
section, X = f (X (cid:48), Z), iii ) they implement a function
that stores the four-momenta of radiated photons in the
ﬁnal event records.

3.2 ProcessModule

Purpose: Evaluation of Born cross-section.

Does it depend on the generated process? Yes.

Description: The Born cross-section is evaluated in
EpIC using the modules of ProcessModule type,
which are deﬁned in the PARTONS library. In the
most general case, where the Born cross-section is
directly calculated from GPDs, ProcessModule re-
quires modules of other types for proper functioning:
ConvolCoeffFunctionModule for the evaluation of the
process amplitudes, GPDModule for the evaluation of
GPDs at a reference scale, GPDEvolutionModule for the
evolution of GPDs, XiConverterModule for the evalu-
ation of GPD skewness variable, ξ, from the process
kinematics, and ScalesModule for the evaluation of
renormalisation and factorisation scales from the pro-
cess kinematics. However, this general case can hardly
be used in the Monte Carlo generation because of the
nested integrations evaluating the Born cross-section.
Instead, one may start the evaluation, for instance, from
the level of amplitudes parametrised in lookup tables.
In this case, GPDModule and GPDEvolutionModule are
not used as there is no need for a convolution of GPDs
with hard scattering coeﬃcient functions. More details
about the ProcessModule modules can be found in
Ref. [20].

KinematicModuleRCModuleProcessModuleRCModuleWriterModuleintegrated cross-sectionevent recordskinematics andexperimental conditionsfor Born cross-sectionvalidity of kinematics and experimental conditionsRC kinematicsexperimental conditionsfour-momentafour-momentaradiative functionkinematics andexperimental conditionsfor Born cross-sectionkinematics andexperimental conditionsfor Born cross-sectionRC kinematicsexperimental conditionsobserved kinematicsBorn cross-sectionGeneratorModulerandom seedkinematic rangesexperimental conditionsintegrated cross-sectionxmlinput(scenario)STDOUTtxt, root, ...output6

Fig. 3 Inheritance tree of modules used for the implemen-
tation of radiative corrections. Each box represents a single
C++ class. Two ﬁrst classes are the part of PARTONS li-
brary, the rest are the part of EpIC project. Classes acting as
modules to be used be users are indicated by boldface fonts.

3.3 EventGeneratorModule

Purpose: Generation of kinematic conﬁgurations ac-
cording to the probability distribution given by the
product of the Born cross-section and the radiator func-
tion.

Does it depend on the generated process? No.

Description: Modules of this type play a central role
in the generation of events. Three actions are imple-
mented in those modules: i ) Initialisation, where the
algorithm implemented in the module probes the prob-
ability distribution, for instance to “memorise” it using
an interpolation method, or to capture its key features,
like the location of places in which the probability dis-
tribution tends to change rapidly. For some complicated
probability distribution functions, the initialisation pro-
cess can be time-consuming, but the results of the pro-
cess can be stored in a ﬁle for use in subsequent jobs.
ii ) Generation of kinematic conﬁgurations according to
the probability distribution, based on the data collected
during the initialisation stage. iii ) Evaluation of the to-
tal cross-section, which is needed to normalise the event
distributions to a given integrated luminosity.

3.4 KinematicModule

Purpose: Evaluation of four-momenta for a given kine-
matic conﬁguration.

Does it depend on the generated process? Yes.

Description: Modules of this type are responsible for
the evaluation of four-momenta for a given kinematic
conﬁguration. In addition, they implement a predeﬁned
function that determines if a given kinematic conﬁgu-
ration is physical, i.e. if it does not break any kinematic
limit. This function is utilised by GeneratorModule to
probe only valid kinematics.

3.5 WriterModule

Purpose: Composing and saving event records.

Does it depend on the generated process? No.

Description: The purpose of modules of this type is to
create and store event records in output ﬁles. Diﬀerent
formats may be implemented by diﬀerent modules. Ad-
ditional information, like the integrated cross-section,
can also be stored in output ﬁles, e.g. in their headers.

4 User interface

Both compilation and linking of the project make use
of the CMake tool [33]. In the current version (1.0.0)
EpIC requires the following external libraries: PAR-
TONS [20] (providing elements of the architecture and
used for the evaluation of Born cross-sections), ROOT
[34] (used in one of the EventGeneratorModule mod-
ules), HepMC3 [35] (used in one of the WriterModule
modules), GSL [36] (used for the generation of random
numbers). For more detailed and always up-to-date in-
formation we refer to the online documentation [23].

The executable of the project, epic, must be in-

voked with two arguments, like this:

./epic --seed=SEED --scenario=SCENARIO_PATH

where SEED is the random seed (unsigned integer) to be
used in the initialisation of modules that deal with ran-
dom numbers, and SCENARIO PATH is the relative or ab-
solute path to the scenario containing all options used
in the generation.

The EpIC scenarios are written in XML markup lan-
guage which, thanks to the usage of tags based on stan-
dard words, is an easy-to-read format for humans while
being straightforward for machines to process. EpIC as-
sumes input data to be provided in units of GeV (and
its powers, whenever applicable), and radians for an-
gles. The general structure of a single scenario is the
following:

BaseObjectdefine e.g. std::string to store class name and functions to print predefined info and warning messages ModuleObjectdefine e.g. functions for initialisation and  generic configuration with additional parameters EpicModuleObjectdefine functions for generic testing  template RCModuledefine basic tasks for this type of modules, like evaluation of radiative function   DVCSRCModulefixes RCModule template for DVCS kinematics DVCSRCCollinearimplement corrections in collinear approximationDVCSRCNullno radiative correctionsTCSRCNullno radiative correctionsTCSRCModulefixes RCModule template for TCS kinematicPARTONSEpIC<!-- XML header -->
<?xml version="1.0" encoding="UTF-8" standalone="yes"
(cid:44)→

?>

4.1 general configuration

<general_configuration>

7

<!-- Definition of scenario -->
<!-- For bookkeeping it includes date and description
(cid:44)→
<scenario date="2022-01-01" description="My first
(cid:44)→

scenario">

-->

<!-- Selection of service and its method-->
<task service="DVCSGeneratorService"
(cid:44)→

method="generate">

<!-- General configuration -->
<general_configuration>
...
</general_configuration>

<!-- Selection of kinematic ranges -->
<kinematic_range>
...
</kinematic_range>

<!-- Indication of experimental conditions -->
<experimental_conditions>
...
</experimental_conditions>

<!-- Configuration of ProcessModule -->
<computation_configuration>
...
</computation_configuration>

<!-- Configuration of GeneratorModule -->
<generator_configuration>
...
</generator_configuration>

<!-- Configuration of KinematicModule -->
<kinematic_configuration>

...

</kinematic_configuration>

<!-- Configuration of RCModule -->
<rc_configuration>
...

</rc_configuration>

<!-- Configuration of WriterModule -->
<writer_configuration>
...
</writer_configuration>

</task>
</scenario>

like

Here, we only expose blocks containing speciﬁc
information,
<general_configuration> ...
</general_configuration>. Each block is described
in one of the subsequent subsections. In our demon-
stration we only show an exemplary scenario for the
DVCS case. More examples, including those for other
processes, can be found online [23].

<!-- Number of events to be generated -->
<param name="number_of_events" value="10" />

<!-- Subprocess. Possible values: "DVCS" (pure
(cid:44)→

DVCS), "BH" (pure Bethe-Heitler), "DVCS|BH"
(pure DVCS and BH), "DVCS|BH|INT" (pure DVCS,
BH and the interference between the two) -->

(cid:44)→
<param name="subprocess_type" value="DVCS" />

(cid:44)→

</general_configuration>

4.2 kinematic range

<kinematic_range>

<!-- Range of xB (Bjorken variable)-->
<param name="range_xB" value="0.|1." />

<!-- Range of t -->
<param name="range_t" value="-1.|0." />

<!-- Range of Q2 -->
<param name="range_Q2" value="1.|10." />

<!-- Range of φ -->
<param name="range_phi" value="0.|2*pi" />

<!-- Range of φS -->
<param name="range_phiS" value="0.|2*pi" />

<!-- Range of y -->
<param name="range_y" value="0.01|0.95" />

</kinematic_range>

4.3 experimental conditions

<experimental_conditions>

<!-- Energy of the lepton beam -->
<param name="lepton_energy" value="5." />

<!-- Type of the lepton beam, here electron -->
<param name="lepton_type" value="e-" />

<!-- Polarisation of the lepton beam -->
<param name="lepton_helicity" value="1" />

<!-- Energy of the hadron beam -->
<!-- For a target in rest frame use:
(cid:44)→
<param name="hadron_energy" value="10." />

value="fixed target" -->

<!-- Type of the hadron beam, here proton -->
<param name="hadron_type" value="p" />

<!-- Polarisation of the hadron beam -->

8

(cid:44)→

<!-- Possible values: "0|0|0" for unpolarised
(cid:44)→

target, "0|0|±1" for long. polarised target,
"±1|0|0" or "0|±1|0" for trans. polarised
target -->

(cid:44)→
<param name="hadron_polarisation" value="0.|0.|0."
(cid:44)→

/>

</experimental_conditions>

4.4 computation configuration

<computation_configuration>

<!-- Selection of module -->
<!-- DVCSProcessBMJ12 module encodes the BH, DVCS,
(cid:44)→

and interference terms of the Born
cross-section according to Refs. [37] and [38]
-->

(cid:44)→

(cid:44)→
<module type="DVCSProcessModule"
name="DVCSProcessBMJ12">
(cid:44)→

<!-- Selection of module used for evaluation of
(cid:44)→

factorisation and renormalisation scales from
DVCS kinematics -->

both scales in terms of the Q2 variable -->

(cid:44)→
<!-- DVCSScalesQ2Multiplier module identifies
(cid:44)→
<module type="DVCSScalesModule"
(cid:44)→
</module>

name="DVCSScalesQ2Multiplier">

<!-- Selection of module used for evaluation of
the GPD skewness variable, ξ, from DVCS
(cid:44)→
kinematics -->

(cid:44)→
<!-- DVCSXiConverterXBToXi module use the
conversion ξ = xBj/(2 − xBj) -->
(cid:44)→
<module type="DVCSXiConverterModule"
name="DVCSXiConverterXBToXi">
(cid:44)→
</module>

DVCS Compton form factors (CFFs) -->

<!-- Selection of module used for the evaluation
(cid:44)→
<!-- DVCSCFFCMILOU3DTables module does not
(cid:44)→

evaluate CFFs from a GPD model during EpIC
run-time. Instead, it uses look-up tables of
CFFs evaluated ahead of time for a particular
GPD module. A number of these tables are
included with EpIC.-->

(cid:44)→
<module type="DVCSConvolCoeffFunctionModule"
(cid:44)→

name="DVCSCFFCMILOU3DTables">

(cid:44)→

(cid:44)→

(cid:44)→

4.5 generator configuration

<generator_configuration>

<!-- Selection of module -->
<!-- EventGeneratorFOAM module uses mini-FOAM
(cid:44)→
<module type="EventGeneratorModule"
name="EventGeneratorFOAM">
(cid:44)→

library [39] that is issued with ROOT [34] -->

<!-- Parameters of the FOAM algorithm -->

<!-- Maximum number of cells -->
<param name="nCells" value="10000" />

<!--Number of MC events when exploring a cell -->
<param name="nSamples" value="2000" />

<!-- Number of bins in edge histogram for a cell
(cid:44)→
<param name="nBins" value="2000" />

-->

(cid:44)→

<!-- After the initialisation process, the state
of FOAM will be saved in PATH/state.root. To
(cid:44)→
use this file in another EpIC run, so as to
skip the initialisation in that run, use the
read state file path option. -->
(cid:44)→
<param name="save_state_file_path"
value="PATH/state.root" />
(cid:44)→

(cid:44)→

</module>

</generator_configuration>

4.6 kinematic configuration

<kinematic_configuration>

<!-- Selection of module -->
<!-- DVCSKinematicDefault module provides default
(cid:44)→

evaluation of four-momenta from DVCS kinematics
-->

(cid:44)→
<module type="DVCSKinematicModule"
(cid:44)→
</module>

name="DVCSKinematicDefault">

</kinematic_configuration>

4.7 rc configuration

<!-- pQCD order of evaluation -->
<param name="qcd_order_type" value="LO" />

<rc_configuration>

based on the GK GPD model is specified -->

<!-- Path to a look-up table, here the one
(cid:44)→
<param name="cff_set_file"
value="PATH/epic/data/
(cid:44)→
DVCSCFFCMILOU3DTables/tables_GK.root" />

(cid:44)→

</module>

</module>

<!-- Selection of module -->
<!-- DVCSRCCollinear module provides evaluation of
initial and final state radiative corrections
(cid:44)→
from lepton lines using the collinear
approximation, see Sect. Appendix A for more
details -->

(cid:44)→

(cid:44)→

(cid:44)→
<module type="DVCSRCModule"
name="DVCSRCCollinear">
(cid:44)→
</module>

</computation_configuration>

</rc_configuration>

4.8 writer configuration

<writer_configuration>

<!-- Selection of module -->
<!-- WriterHepMC3 module is used to save event
(cid:44)→
<module type="WriterModule" name="WriterHepMC3">

records in HepMC3 format [35] -->

-->

<!-- Path to output file containing event records
(cid:44)→
<param name="output_file_path" value="test.txt"
(cid:44)→

/>

<!-- Format of output file containing event
(cid:44)→

records: "ascii" for text format, or "root"
for binary ROOT format-->

(cid:44)→
<param name="HepMC3_writer_type" value="ascii"
(cid:44)→

/>

</module>

</writer_configuration>

9

eters of the FOAM library, which may, however, lead
to a longer time needed by EpIC to generate a single
event. We remind that the result of the initialisation
can be stored in a ﬁle, allowing to avoid this step in
subsequent MC runs.

To ensure our results are consistent, we also plot the
theory expectation values, as solid lines, on top of each
histogram. The number of events associated with the
theory curves is calculated as follows: at each bin, the
cross-section for the given bin width is calculated, and
then the result is divided by the total cross-section of
the phase space. One can then multiply this ratio by the
total number of events to ﬁnd the number of events in
that speciﬁc bin. To obtain those curves in Fig. 4, ﬁrst
we assign the number of events to the middle point of
each bin, then interpolate all these results. As a result,
we observe that EpIC generates events in accordance
with the theory values.

5 Demonstration of EpIC

6 Summary

Here, we demonstrate EpIC in a detailed manner by
using speciﬁc components of the PARTONS frame-
work. The demonstration is based on one million
MC events generated for the DVCS sub-process, i.e.
exclusive leptoproduction of a single photon with-
out the Bethe-Heitler contribution, at 10 GeV posi-
tive helicity electron and 100 GeV unpolarized pro-
ton energies. The following modules are used dur-
ing the generation process: DVCSCFFCMILOU3DTables
for the parameterisation of CFFs obtained from the
GK GPD model [30–32] and LO coeﬃcients functions,
DVCSProcessBMJ12 for the evaluation of DVCS cross-
section based on the set of expressions published in
Ref. [38], DVCSRCNull for the simulation without ra-
diative corrections, EventGeneratorFOAM for the gen-
eration of DVCS kinematics based on cross-section with
the FOAM algorithm [39], DVCSKinematicDefault for
the default evaluation of four-momenta from DVCS
kinematics, and WriterHepMC3 to save four-momenta
in HepMC3 format.

The following cuts are used in the generation pro-
cess: 0.0001 ≤ xB ≤ 0.6, 0.01 ≤ y ≤ 0.95 (here, y
is the inelasticity parameter), 1 ≤ Q2 ≤ 100 GeV2,
0 ≤ |t| ≤ 1 GeV2, 0 ≤ φ ≤ 2π, and 0 ≤ φS ≤ 2π. On the
basis of these cuts, the distribution of events is shown
in Fig. 4. The following FOAM library parameters are
used in producing those events [39]: nCells = 3000,
nSamples = 600, nBins = 600. For the FOAM library,
the initialisation lasted about 40 minutes, whereas the
generation time after initialisation took around 0.0052
seconds per event at BNL computer farms. The initial-
isation time can be shortened by changing the param-

In this work, we described in detail the overall structure
and essential features of the novel MC generator EpIC.
This generator is based on the PARTONS framework in
the model selection. It is designed to generate events for
exclusive processes, such as DVCS, TCS, DVMP and
more broadly to all exclusive processes implemented
in the PARTONS framework. As these processes have
the potential to reveal the 3D structure of the nucleon
through GPDs, they have been studied extensively at
facilities such as DESY, JLab, and CERN, and they
will remain crucial for future EIC programmes.

The EpIC MC generator stands out with its ﬂexi-
ble architecture that utilises a modular programming
paradigm. Consequently, the code is easier to under-
stand, as each element of the architecture is designed
to perform a speciﬁc task. The distribution of events
generated by EpIC is highly precise since it utilises an
accurate representation of the cross-section of the un-
derlying process in the FOAM library. Besides gener-
ating accurate events, EpIC also allows users to gener-
ate events with radiative corrections as well as to run
multi-channel analyses. On top of this, EpIC is released
through GitHub as an open-source project under a GPL
licence. In particular it means that users can trace code
modiﬁcations and new contributors can easily join the
development team. To the best of our knowledge, a tool
such as EpIC is unique in the GPD community by its
very nature. The comprehensive set of features and the
variety of models available in EpIC make it ideal for the
systematic study of the 3D structure of the nucleon.

The generator was designed in a way that facilitates
easy expansion. The encapsulation of elements is one of

10

Fig. 4 Distribution of one million DVCS events produced by the DVCSProcessBMJ12 module utilising GPDGK16 GPDs within
the PARTONS framework. Events are binned with respect to log10(xB), y, Q2, |t|, φ and φS. The solid curves on top of the
histograms depict the expected number of events for the given model. The curves are normalised according to the integrated
luminosity estimated by EpIC.

the fundamental characteristics of the generator when
it comes to maintaining the project for a long time and
with a changing team of developers. This allows us to
easily adapt the architecture to the latest developments.
Finally, to make this project as useful to the particle
physics community as possible, we promote open-source
standards and oﬀer easy access to its development. This
perspective is well suited to the experimental timeline
of the 3D hadron structure community.

authors

thank Alexander
Acknowledgements The
Jentsch, Kreˇsimir Kumeriˇcki,
and Kornelija Passek-
Kumeriˇcki for fruitful discussions. This work was supported
by the Grant No. 2019/35/D/ST2/00272 of the National
Science Center, Poland; by the European Union’s Horizon
2020 research and innovation programme under grant agree-
ment No 824093; in the framework of the GLUODYNAMICS
project funded by the ”P2IO LabEx (ANR-10-LABX-0038)”
in the framework ”Investissements d’Avenir” (ANR-11-
IDEX-0003-01) managed by the Agence Nationale de la
Recherche (ANR), France; by the Ile-de-France region via
the Blaise Pascal Chair of International Excellence. KT was

supported by U.S. Department of Energy under Contract
No. de-sc0012704.

Appendix A: Radiative corrections

Radiative corrections can have a signiﬁcant impact on
the interpretation of experimental data, as they intro-
duce uncertainties in the reconstruction of “true” kine-
matics of the measured process. On the other hand,
neglecting radiative corrections in simulations typically
leads to unrealistic distributions of generated events,
making e.g. impact studies to be much less robust. To
address both of these problems it is highly desirable to
have radiative corrections implemented in generators of
MC events.

In the literature, it has been discussed that the lep-
tonic initial and ﬁnal state radiative corrections, i.e.
when photons are emitted by either incoming or out-
going leptons, respectively, can be computed with a

4-3.5-3-2.5-2-1.5-1-0.5-Bx10log0200040006000800010000120001400016000180002000022000Counts0.10.20.30.40.50.60.70.80.9y310410510Counts102030405060708090100]2 [GeV2Q110210310410510610Counts00.10.20.30.40.50.60.70.80.91]2|t| [GeV210310410510Counts0123456 [rad]j0200040006000800010000Counts0123456 [rad]Sj0200040006000800010000Countsgood accuracy in the collinear approximation [40, 41].
In this approximation the transverse component of the
momenta of emitted photons are neglected. Therefore,
the radiated photons are restricted to move along the
direction of the source leptons.

The collinear approximation allows one to introduce
a single parameter, z1 or z3, for the initial or ﬁnal state
radiation, respectively. The parameter describes the en-
ergy of the emitted photon:

z1 =

Ee − Eγ
Ee

,

z3 =

Ee(cid:48)
Ee(cid:48) + Eγ(cid:48)

,

(A.1)

where Ee (Ee(cid:48)) and Eγ (Eγ(cid:48)) are the energies of the
incoming (outgoing) lepton and the initial (ﬁnal) state
emitted photon, respectively. The DIS cross section can
be then expressed by [41]:

d2σ
dx dy

=

(cid:90) 1

zmin
1

dz1
z1

D(z1)

(cid:90) 1

zmin
3

dz3
z2
3

D(z3)

y
ˆy

d2 ˆσBorn
dˆx dˆy

,

(A.2)

where d2 ˆσBorn is the diﬀerential Born cross-section eval-
uated for “true” variables, which are related to the ob-
served ones by [41]:

ˆx =

z1xy
z1z3 + y − 1

, ˆy =

z1z3 + y − 1
z1z3

,

(A.3)

and where due to kinematic limits one has:

zmin
1 =

1 − y
1 − xy

,

zmin
3 = 1 − y(1 − x) .

(A.4)

In Eq. (A.2) the radiator functions, D(z1) and D(z3),
describe the weight of the rescaled cross-section in the
presence of the initial and ﬁnal state radiations, respec-
tively. At the leading order D(z1) and D(z3) are equal
to each other and given by:

(cid:34)

(cid:34)

D(z) =

δ(1 − z)

1 +

(cid:32)

L

2 ln (cid:15) +

(cid:33)(cid:35)

3
2

α
2π

+ θ(1 − (cid:15) − z)

α
2π

L

1 + z2
1 − z

(cid:35)

,

(A.5)

with L = ln(Q2/m2
l ). Here, α is the ﬁne-structure con-
stant, and ml is the lepton mass. The parameter (cid:15) acts
as a cutoﬀ avoiding the generation of a very soft photons
characterised by energies Eγ ≤ (cid:15)Ee and Eγ(cid:48) ≤ (cid:15)Ee(cid:48). It
is crucial to choose the cutoﬀ carefully so that (cid:15)Ee and
(cid:15)Ee(cid:48) are much smaller than the energy resolution of the
experiment. Due to the cutoﬀ Eq. (A.5) consists of two
parts: the term proportional to the Dirac delta func-
tion collectively describes the contribution of very soft
photons and virtual corrections, while the term propor-
tional to the step function describes the eﬀects of real
radiation of photons with sizeable energies.

11

The generalisation of leading order radiative correc-

tions for the DVCS case can be achieved as follows:

d5σ
dx dQ2 dt dφ dφS

=

×

(cid:90) 1

zmin
1

dz1z1D(z1)

(cid:90) 1

zmin
3

dz3
z2
3

D(z3)

y
ˆy

d5 ˆσBorn
dˆx d ˆQ2 dt d φ dφS

.

(A.6)

References

1. D. M¨uller, D. Robaschik, B. Geyer, F.M. Dittes,
J. Hoˇrejˇsi, Fortsch. Phys. 42, 101 (1994). DOI 10.1002/
prop.2190420202

2. X.D. Ji, Phys. Rev. Lett. 78, 610 (1997). DOI 10.1103/

PhysRevLett.78.610

3. X.D. Ji, Phys. Rev. D 55, 7114 (1997). DOI 10.1103/

PhysRevD.55.7114

4. A.V. Radyushkin, Phys. Lett. B 385, 333 (1996). DOI

10.1016/0370-2693(96)00844-1

5. A.V. Radyushkin, Phys. Rev. D 56, 5524 (1997). DOI

10.1103/PhysRevD.56.5524

6. M. Burkardt, Phys. Rev. D 62, 071503 (2000). DOI

10.1103/PhysRevD.62.071503.
66, 119903 (2002)]

[Erratum: Phys.Rev.D

7. M. Burkardt, Int. J. Mod. Phys. A 18, 173 (2003). DOI

10.1142/S0217751X03012370

8. M. Burkardt, Phys. Lett. B 595, 245 (2004). DOI 10.

1016/j.physletb.2004.05.070

9. X.D. Ji, W. Melnitchouk, X. Song, Phys. Rev. D 56, 5511

(1997). DOI 10.1103/PhysRevD.56.5511

10. M.V. Polyakov, Phys. Lett. B 555, 57 (2003). DOI 10.

1016/S0370-2693(03)00036-4

11. M.V. Polyakov, P.
Phys. A 33(26),
10.1142/S0217751X18300259

1830025

Schweitzer,

Int.

(2018).

J. Mod.
DOI

12. C. Lorc´e, H. Moutarde, A.P. Trawi´nski, Eur. Phys. J. C
79(1), 89 (2019). DOI 10.1140/epjc/s10052-019-6572-3
13. M. Diehl, Phys. Rept. 388, 41 (2003). DOI 10.1016/j.

physrep.2003.08.002

14. A. Accardi, et al., Eur. Phys. J. A 52(9), 268 (2016). DOI

10.1140/epja/i2016-16268-9

15. R. Abdul Khalek, et al., Science Requirements and De-
tector Concepts for the Electron-Ion Collider: EIC Yellow
Report (2021). arXiv:physics.ins-det/2103.05419

16. D.P. Anderle, et al., Front. Phys. (Beijing) 16(6), 64701

(2021). DOI 10.1007/s11467-021-1062-0

17. J.L. Abelleira Fernandez, et al., J. Phys. G 39, 075001

(2012). DOI 10.1088/0954-3899/39/7/075001

18. B. Adams, et al., COMPASS++/AMBER: Proposal for
Measurements at the M2 beam line of the CERN SPS
Phase-1: 2022-2024. Tech. rep., CERN, Geneva (2019).
CERN-SPSC-2019-022, SPSC-P-360

19. J. Arrington, et al., Physics with CEBAF at 12 GeV and
Future Opportunities (2021). arXiv:nucl-ex/2112.00060
20. B. Berthou, et al., Eur. Phys. J. C 78(6), 478 (2018).

DOI 10.1140/epjc/s10052-018-5948-0

21. A. Bacchetta, U. D’Alesio, M. Diehl, C.A. Miller, Phys.
Rev. D 70, 117504 (2004). DOI 10.1103/PhysRevD.70.
117504

22. EpIC project on GitHub.

https://github.com/

pawelsznajder/epic

23. EpIC project webpage. https://pawelsznajder.github.

io/epic

12

24. O. Grocholski, H. Moutarde, B. Pire, P. Sznajder, J. Wag-
ner, Eur. Phys. J. C 80(2), 171 (2020). DOI 10.1140/
epjc/s10052-020-7700-9

25. H. Moutarde, P. Sznajder, J. Wagner, Eur. Phys.
DOI 10.1140/epjc/

J. C 78(11), 890 (2018).
s10052-018-6359-y

26. H. Moutarde, P. Sznajder, J. Wagner, Eur. Phys. J. C
79(7), 614 (2019). DOI 10.1140/epjc/s10052-019-7117-5
27. V. Bertone, H. Dutrieux, C. Mezrag, H. Moutarde, P. Sz-

najder, Phys. Rev. D 103(11), 114019 (2021). DOI
10.1103/PhysRevD.103.114019

28. J.M.M. Chavez, V. Bertone, F.D.S. Borrero, M. De-
furne, C. Mezrag, H. Moutarde, J. Rodr´ıguez-Quintero,
J. Segovia, Pion GPDs: A path toward phenomenology
(2021). arXiv:hep-ph/2110.06052

29. H. Dutrieux, O. Grocholski, H. Moutarde, P. Sznajder,
Eur. Phys. J. C 82(3), 252 (2022). DOI 10.1140/epjc/
s10052-022-10211-5

30. S.V. Goloskokov, P. Kroll, Eur. Phys. J. C 42, 281 (2005).

DOI 10.1140/epjc/s2005-02298-5

31. S.V. Goloskokov, P. Kroll, Eur. Phys. J. C 53, 367 (2008).

DOI 10.1140/epjc/s10052-007-0466-5

32. S.V. Goloskokov, P. Kroll, Eur. Phys. J. C 65, 137 (2010).

DOI 10.1140/epjc/s10052-009-1178-9

33. CMake project webpage. https://cmake.org
34. R. Brun, F. Rademakers, Nucl. Instrum. Meth. A 389,

81 (1997). DOI 10.1016/S0168-9002(97)00048-X

35. A. Buckley, P. Ilten, D. Konstantinov, L. L¨onnblad,
J. Monk, W. Pokorski, T. Przedzinski, A. Verbytskyi,
Comput. Phys. Commun. 260, 107310 (2021). DOI
10.1016/j.cpc.2020.107310

36. M. Galassi, et al., GNU Scientiﬁc Library: Reference
Manual (Network Theory, 2009). ISBN 0954612078
37. A.V. Belitsky, D. Mueller, A. Kirchner, Nucl. Phys. B

629, 323 (2002). DOI 10.1016/S0550-3213(02)00144-X

38. A.V. Belitsky, D. M¨uller, Y. Ji, Nucl. Phys. B 878, 214

(2014). DOI 10.1016/j.nuclphysb.2013.11.014

39. S. Jadach, P. Sawicki, Comput. Phys. Commun. 177, 441

(2007). DOI 10.1016/j.cpc.2007.02.112

40. L.W. Mo, Y.S. Tsai, Rev. Mod. Phys. 41, 205 (1969).

DOI 10.1103/RevModPhys.41.205

41. J. Kripfganz, H.J. Mohring, H. Spiesberger, Z. Phys. C

49, 501 (1991). DOI 10.1007/BF01549704

