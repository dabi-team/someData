2
2
0
2

g
u
A
5
2

]

O
L
.
s
c
[

1
v
3
2
7
2
1
.
8
0
2
2
:
v
i
X
r
a

Fast Parametric Model Checking

Xinwei Fang∗, Radu Calinescu∗, Simos Gerasimou, and Faisal Alhwikem

1

Abstract—We present a technique for reducing the complexity of parametric model checking (PMC) by automatically decomposing
parametric discrete-time Markov chains (pDTMCs) into fragments that can be analysed independently, yielding results that we combine
to obtain the solution of the original PMC veriﬁcation problem. Our fast parametric model checking (fPMC) technique enables the
formal analysis of reliability, performance and other nonfunctional properties of software systems modelled by pDTMCs that are too
complex to be handled by existing PMC methods. Furthermore, for many pDTMCs that state-of-the-art parametric model checkers can
analyse, fPMC produces solutions (i.e., algebraic formulae) that are simpler and much faster to evaluate. We show experimentally that
adding fPMC to the existing repertoire of PMC methods improves the efﬁciency of parametric model checking signiﬁcantly, and extends
its applicability to systems with more complex behaviour than currently possible.

Index Terms—Parametric model checking; Markov models; model abstraction; probabilistic model checking; quality of service;
nonfunctional properties

(cid:70)

1 INTRODUCTION

Most software operates in environments characterised by
workloads, usage proﬁles, failures and available resources
that are stochastic in nature [9], [20], [40]. As such, proba-
bilistic models such as Markov chains [27], [31], [44], queue-
ing networks [6], [28] and stochastic Petri nets [7], [43], [45]
have long been used to analyse the dependability, perfor-
mance and other nonfunctional properties of software.

In this paper, we focus on the analysis of nonfunctional
software properties using parametric discrete-time Markov
chains (pDTMCs), i.e., Markov chains that have transition
probabilities and/or that are augmented with rewards spec-
iﬁed as rational functions over the parameters of the anal-
ysed system. The technique used to analyse these stochastic
models is called parametric model checking (PMC) [15], [19],
[36], [41]. Given a pDTMC model of a software system, and
a set of nonfunctional system properties speciﬁed in prob-
abilistic temporal logic, PMC computes algebraic formulae
for these properties. The concept is straightforward. As a
simple example, consider a web server that handles two
types of request, and suppose that requests belong to these
types with probabilities p and 1 − p. If the mean times to
handle the two types of request are t1 and t2, respectively,
then the expected (i.e., mean) time for handling a request is
computed by PMC as pt1 + (1 − p)t2.

The algebraic formulae produced by PMC have many
important applications in software engineering. They can
be used to analyse the sensitivity of nonfunctional software
properties to parametric variability [27], to identify opti-
mal system conﬁgurations for software product lines [32],
[33], and to establish conﬁdence intervals for the analysed
nonfunctional properties [1], [12], [13]. Furthermore, PMC
formulae precomputed prior to deployment (when some
of the system parameters are unknown) can be evaluated
at runtime (when the parameter values are determined

∗ The ﬁrst two authors contributed equally to the article.
X. Fang, R. Calinescu, S. Gerasimou and F. Alhwikem are with the
Department of Computer Science at the University of York, UK.

through monitoring), to verify if the nonfunctional require-
ments of a system are still satisﬁed after environmental
changes [47]. Last but not least, self-adaptive systems can
use these formulae to efﬁciently select new conﬁgurations
when requirements are violated after such changes [25], [26].
Despite these beneﬁts, PMC is seldom used in practice
due to its limited scalability. While theoretical advances over
the past decade [36], [41] and their implementation in state-
of-the-art model checkers [21], [35], [42] have alleviated this
limitation, existing PMC approaches are often unable to
analyse pDTMCs with large numbers of parameters.

Our paper presents a fast parametric model checking
(fPMC) technique that extends the applicability of PMC to
systems with considerably more complex behaviour and
with much larger sets of parameters than currently possible.
fPMC is a compositional analysis technique that uses well-
deﬁned rules (described later in the paper) to partition the
graph induced by the pDTMC under analysis1 into sub-
graphs called fragments. The fPMC fragments deﬁne small
pDTCMs that are analysed individually to generate PMC
subexpressions. Finally, the overall PMC result is obtained
by combining these subexpressions with an expression pro-
duced by analysing an abstract model created by replacing
each fragment from the original pDTMC with a single state.
fPMC fragments are not strongly connected components
(SCCs) of the analysed pDTMC. They can typically be
assembled to ensure that each fragment is small enough for
its individual PMC analysis to be feasible, and large enough
to avoid the creation of so many fragments that the abstract
pDTMC becomes difﬁcult to analyse. This ﬂexibility yields
both fragments that include only a part of an SCC and
fragments that include multiple SCCs, and explains why
fPMC can efﬁciently analyse many pDTMCs not handled
by the SCC-partitioning PMC approach from [41], as shown
in our experimental evaluation from Section 6.

fPMC builds on recent research that laid the groundwork
for the use of pDTMC fragments to speed up parametric

1. i.e., the directed graph comprising a vertex for each pDTMC state
and an edge between each pair of vertices that correspond to pDTMC
states between which a transition is possible

 
 
 
 
 
 
model checking [15]. However, that research provides no
algorithm for the partition of pDTMCs into fragments. The
main contributions of our paper are:

1) The fPMC theoretical foundation comprising algo-
rithms (a) for pDTMC fragmentation, and (b) for
pDTMC restructuring, to aid the formation of suit-
ably sized fragments.

2) A new parametric model checking tool that (a) em-
ploys a simple heuristic to determine whether the
analysis of a pDTMC requires fragmentation, and
(b) performs the analysis of the pDTMC by using
our fPMC fragmentation and restructuring algo-
rithms if fragmentation is required, or by invoking
the model checker Storm [21] otherwise.

3) An extensive evaluation of the fPMC theoretical
foundation and tool for 62 pDTMC model vari-
ants and a wide range of nonfunctional properties
taken from the software engineering and parametric
model checking research literature.

A preliminary fPMC version that only supports the analysis
of reachability probabilistic temporal logic formulae over
pDTMCs was introduced in [24]. This paper extends the
theoretical foundation from [24] with:

1)

2)

for

Support for the PMC of unbounded until formulae,
which correspond to the analysis of software prop-
erties such as the probability of successful termina-
tion without intermediate errors or timeouts.
Support
reachability reward
the PMC of
formulae—a signiﬁcant improvement because using
PMC to analyse nonfunctional properties related to
the performance, cost, utility and resource usage of
software systems requires the speciﬁcation of these
properties as reward formulae over pDTMCs.
Formal correctness proofs for the fPMC fragmenta-
tion algorithm and pDTMC restructuring methods.
4) A formal complexity analysis of the end-to-end

3)

fPMC fragmentation technique.

Additionally, we considerably extended and improved the
validation of fPMC by evaluating it for a much broader
range of models and properties (Section 6). Finally, we
augmented the fPMC tool support with the heuristic for
determining if the pDTMC under analysis requires fragmen-
tation (Section 6.2.1).

The remainder of the paper is structured as follows. Sec-
tion 2 provides formal deﬁnitions and explanations of the
techniques used in this work. Section 3 describes a software
system we use to motivate the need for fPMC and to illus-
trate its application. The fPMC algorithms and their proofs
are presented in Section 4, followed by the implementation
details in Sections 5. We then evaluate fPMC in Section 6,
and discuss threats to validity in Section 7. Finally, Section 8
compares fPMC to related work, and Section 9 provides a
brief summary and discusses directions for future work.

2 PRELIMINARIES
Parametric model checking [15], [19], [36], [41] is a math-
ematically based technique for the analysis of pDTMC
properties expressed in probabilistic computation tree logic
(PCTL) [8], [16], [39] extended with rewards [3]. This section
provides formal deﬁnitions for each of these concepts.

2

2.1 Discrete-time Markov chains

Discrete-time Markov chains (DTMCs) are ﬁnite state-
transition models used to analyse the stochastic behaviour
of real-world systems. They comprise states that correspond
to relevant conﬁgurations of the system under analysis, and
transitions that model the changes that can occur between
these conﬁgurations.

Deﬁnition 1. A (non-parametric) discrete-time Markov chain is
a tuple

D = (S, s0, P, L),

(1)

where: (i) S is a ﬁnite set of states; (ii) s0 ∈ S is the initial state;
(iii) P : S × S → [0, 1] is a transition probability matrix such
that, for any states s, s(cid:48) ∈ S, P(s, s(cid:48)) represents the probability
that the Markov chain transitions from s to s(cid:48), and, for any
s ∈ S, (cid:80)
s(cid:48)∈S P(s, s(cid:48)) = 1; and (iv) L : S → 2AP is a labelling
function that maps every state s ∈ S to elements of a set of
atomic propositions AP that hold in that state.

Given a discrete-time Markov chain (1), a state s ∈ S is
an absorbing state if P(s, s) = 1 and P(s, s(cid:48)) = 0 for all s (cid:54)= s(cid:48),
and a transient state otherwise. A path π over a DTMC D is
a (possibly inﬁnite) sequence of states from S, such that for
any consecutive states s and s(cid:48) from π, P(s, s(cid:48)) > 0. The i-th
state on the path π, i ≥ 1, is denoted π(i). For any state s,
Paths D(s) represents the set of all inﬁnite paths over D that
start with state s.

To enlarge the spectrum of nonfunctional properties that
can be analysed using DTMCs, these models are often
augmented with reward functions.

Deﬁnition 2. A reward function over a DTMC (1) is a function
rwd : S → R≥0

(2)

that associates a non-negative quantity (i.e., a reward) with each
Markov chain state.

Finally, parametric DTMCs are used when a reward-
augmented Markov chain contains probabilities or rewards
that are unknown or that correspond to adjustable parame-
ters of the system under analysis.

Deﬁnition 3. A parametric discrete-time Markov chain
(pDTMC) is a Markov chain (1) augmented with a set of re-
ward functions (2) that comprises transition probabilities and/or
rewards speciﬁed as rational functions over a set of continuous
variables.

The continuous variables from the previous deﬁnition
correspond to parameters of the modelled system and its
environment.

2.2 Probabilistic computation tree logic

The properties of (non-parametric and parametric) discrete-
event Markov chains are formally speciﬁed in reward-
extended PCTL.

Deﬁnition 4. A PCTL state formula Φ, path formula Ψ, and
reward state formula ΦR over an atomic proposition set AP are
deﬁned by the grammar:

Φ ::= true | a | ¬Φ | Φ ∧ Φ | P=?[Ψ]
Ψ ::= XΦ | Φ U Φ | Φ U≤k Φ
Φ:

=? [I=k] | Rrwd

R := Rrwd

=? [C≤k] | Rrwd

=? [F Φ] | Rrwd

=? [S]

(3)

3

Fig. 2: Parametric model checking through fragmentation

This deﬁnition is much less restrictive than that of a
strongly connected component. In particular, any pDTMC
state z forms a one-state, degenerate fragment F = ({z},
z, {z}). Furthermore, the “inner” states Z \ ({z0} ∪ Zout)
of a fragment can include one of several SCCs. Finally, an
SCC can be split into multiple fragments, because paths that
start from the output states of a fragment and reach its input
state (either directly or through intermediate states outside
the fragment) are permitted.

Given a fragment F = (Z, z0, Zout) of a pDTMC D
augmented with a reward function rwd , the PMC of reacha-
bility, unbounded until, and reachability reward properties
of D can be carried out compositionally by using the fol-
lowing four-step process introduced in [15] and illustrated
in Figure 2:

1) Use standard PMC to obtain algebraic formulae for:

i) the probabilities probz of reaching each of the output
states z ∈ Zout of F from the input fragment state z0;
ii) the cumulative reward rwd out associated with reach-

ing the output state set Zout from z0.

2) Assemble an abstract pDTMC model D(cid:48) = (S(cid:48), s(cid:48)
augmented with a reward function rwd (cid:48), where:
i) S(cid:48) = (S \ Z) ∪ {z(cid:48)}, i.e., the states from Z are replaced

0, P (cid:48))

with a single, abstract state z(cid:48);
0 = s0 if z0 (cid:54)= s0, and s(cid:48)

ii) s(cid:48)
iii) the incoming transitions and transition probabilities

0 = z(cid:48) otherwise;

of z(cid:48) are inherited from z0;

iv) z(cid:48) has outgoing transitions to each state that one or
more states from Zout have outgoing transitions to
in D; and the probabilities of these transitions can
be expressed in terms of the reachability properties
computed in step 1—details about the calculation of
these probabilities are provided in [15];

v) the new reward function is given by rwd (cid:48)(s) = rwd (s)

for all s ∈ S(cid:48) \ {z(cid:48)}, and rwd (cid:48)(z(cid:48)) = rwd out.

3) Compute the PMC formula for the original property

under analysis, for the abstract model from step 2.

4) Combine the PMC formulae from step 1 and the PMC

formula from step 3 into a system of expressions.

The system of expressions from step 4 provides a closed-
form analytical model for the analysed property. This ana-

Fig. 1: pDTMC fragment F = (Z, z0, Zout)

where a ∈ AP is an atomic proposition, k ∈ N>0 is a timestep
bound, and rwd is a reward structure (2).

The PCTL semantics is deﬁned using a satisfaction rela-
tion |= over the states s ∈ S and paths π ∈ Paths D(s) of a
Markov chain (1). Thus, s |= Φ means “Φ holds in state s”,
π |= Ψ means “Ψ holds for path π”, and we have: s |= true
for all states s ∈ S; s |= a iff a ∈ L(s); s |= ¬Φ iff ¬(s |= Φ);
and s |= Φ1 ∧ Φ2 iff s |= Φ1 and s |= Φ2.

The next formula XΦ holds for a path π if π(2) |= Φ.
The time-bounded until formula Φ1 U≤k Φ2 holds for a path
π iff π(i) |= Φ2 for some i ≤ k and π(j) |= Φ1 for all
j = 1, 2, . . . , i − 1; and the unbounded until formula Φ1 U Φ2
removes the bound k from the time-bounded until formula.
The quantitative state formula P=?[Ψ] speciﬁes the prob-
ability that paths from Paths D(s) satisfy the path property
Ψ. Reachability properties P=?[true U Φ] are equivalently writ-
ten as P=?[F Φ] or P=?[F R], where R ⊆ S is the set of states
in which Φ holds.

Finally, the reward formulae specify the expected values
=? [I=k]); the
for: the instantaneous reward at timestep k (Rrwd
cumulative reward up to timestep k (Rrwd
=? [C≤k]); the reach-
ability reward cumulated until reaching a state that satisﬁes
a property Φ (Rrwd
=? [F R] if R ⊆ S is the set
of states in which Φ holds); and the steady-state reward in
the long run (Rrwd
=? [S]). A complete description of the PCTL
semantics is available in [3], [8], [39].

=? [F Φ], or Rrwd

2.3 Parametric Model Checking through Fragmentation

Our fPMC technique builds on recently introduced theo-
retical results on the use of pDTMC fragmentation to speed
up parametric model checking [15]. These results, which
explain how pDTCM fragments can be exploited—but not
how they could be obtained—are summarised below. We
start by introducing the concept of a pDTMC fragment.

Deﬁnition 5. A fragment of a pDTMC D = (S, s0, P, L) is a
tuple

F = (Z, z0, Zout),

(4)

where (Figure 1):

• Z ⊂ S is a subset of transient pDTMC states;
•

z0 is the (only) input state of F , i.e., {z0} = {z ∈ Z |
∃s ∈ S \Z . P(s, z) > 0};

• Zout = {z ∈ Z | (∃s ∈ S \ Z . P(z, s) > 0) ∧ (∀z(cid:48) ∈
Z \ {z0} . P(z, z(cid:48)) = 0)} is the non-empty set of output
states of F .

outputstatesZoutinputstatez0outgoingtransitionstostatesoutsidefragmentincomingtransitionsfromstatesoutsidefragment{{innerstatesZ\({z0}∪Zout)fragmentstatesZFragmentPMCformulaeFragmentPMCformulaeAbstractmodelPMCformulapDTMCModelfragmentationStandardPMCAbstractmodelFragment&PCTLpropertiesStandardPMCStandardPMCfPMCclosed-formanalyticalmodelPCTLpropertiesFragment&PCTLproperties4

Fig. 3: FX service-based system, where x, y1, y2, z1, z2 are
the (unknown) probabilities of different execution paths, i.e.,
the operational proﬁle of the system

lytical model is equivalent to the PMC formula obtained by
analysing the original pDTMC in one step, and we will refer
to it as fPMC or fPMC-computed algebraic formulae in the
rest of the paper.

The PMC carried out in steps 1 and 3 uses models
that are simpler and smaller than the original model D.
As such, this four-step approach is often faster, produces
much smaller algebraic formulae, and enables the analysis
of models that are larger and more complex than those
supported by previous PMC methods.

3 MOTIVATING EXAMPLE

In this section, we introduce a software system that will be
used to illustrate the use of our fPMC approach throughout
the paper. Taken from [30], [31], this a six-operation service-
based system performing trading in the foreign exchange
(FX) market. The workﬂow of the FX system is shown in
Fig. 3 and described brieﬂy below.

FX workﬂow. The FX system has two execution modes that
a trader can choose from: an expert mode and a normal mode.
In the expert mode, the Market watch operation extracts
real-time exchange rates (i.e., bid/ask prices) of selected
currency pairs, and this information is then passed to the
Technical analysis operation for further analysis, such as
evaluating the current trading conditions, predicting future
price movement, and deciding which actions to take. Three
actions can be taken: carrying out a trade by calling the
Order operation; performing the Market watch operation
again, e.g., on different or additional currency pairs; and
reporting an error that triggers an Alarm operation. The
Order and Alarm operations are each followed by a user
Notiﬁcation operation, and the end of the workﬂow.

In the normal mode, the system uses a Fundamental anal-
ysis operation to evaluate the economic outlook of a country
and decides whether to: call the Order operation to trade
the currency of that country; re-do the Fundamental analysis
operation; or end the execution of the workﬂow.

Given its business-critical nature, the underlying soft-
ware architecture of the FX system needs to be highly
reliable. To avoid single points of failure, each FX operation
is implemented by two functionally-equivalent services, and
each service is invoked in order using a sequential execution
strategy with retry (SEQ R). For the i-th operation, if the ﬁrst
service fails, it is re-invoked with probability ri1 or, with
probability 1 − ri1, the second service is invoked. If the
second service also fails, it is re-invoked with probability

Fig. 4: pDTMC model of the FX system

ri2, or the operation is abandoned with probability 1 − ri2,
leading to the failure of the entire workﬂow execution.

FX pDTMC. Fig. 4 shows the pDTMC model of the FX
workﬂow, speciﬁed in the modelling language of PRISM
probabilistic model checker [42]. Lines 3–18 deﬁne the
model parameters associated with (a) the FX operational
proﬁle (line 4), with (b) the implementations of the FX op-
erations (lines 6–11), and with (c) the mean execution times
of each service used by these implementations (lines 13–
18). The parameters pij, rij and tij represent the probability
of successful execution, the probability of retrying and the
mean execution time, respectively, for the i-th operation us-
ing the j-th service implementation, where i ∈ {1, 2, . . . , 6}
and j ∈ {1, 2}. The use of parameters to model the system

MarketWatchOrdernormalmodeexpertmode1-xxretrydotransactionobjectivesmetobjectivesnotmet1-z1-z2z2z1y1y2Alarm1-y1-y2errorFundamentalAnalysisTechnicalAnalysisNotiﬁcationend1dtmc23//Operationalproﬁleparameters4constdoublex;constdoubley1;constdoubley2;constdoublez1;constdoublez2;5//Operationimplementationparameters6constdoublep11;constdoubler11;constdoublep12;constdoubler12;7constdoublep21;constdoubler21;constdoublep22;constdoubler22;8constdoublep31;constdoubler31;constdoublep32;constdoubler32;9constdoublep41;constdoubler41;constdoublep42;constdoubler42;10constdoublep51;constdoubler51;constdoublep52;constdoubler52;11constdoublep61;constdoubler61;constdoublep62;constdoubler62;12//Rewardparameters13constdoublet11;constdoublet12;14constdoublet21;constdoublet22;15constdoublet31;constdoublet32;16constdoublet41;constdoublet42;17constdoublet51;constdoublet52;18constdoublet61;constdoublet62;1920moduleWorkﬂowFX21//FXstates22s:[0..11]init0;23//Retrystatusofeachserviceimplementation24rtry:[1..2]init1;25//Employedserviceforoperationop1...op626op1:[1..2]init1;op2:[1..2]init1;op3:[1..2]init1;27op4:[1..2]init1;op5:[1..2]init1;op6:[1..2]init1;2829//Start:expertmodeornormalmode30[fxStart]s=0→x:(s’=1)+(1-x):(s’=4);3132//Operation#1:SequentialexecutionstrategywithretryfortheMarketWatch33[op11](s=1)&(rtry=1)&(op1=1)→p11:(s’=2)+(1-p11):(rtry’=2);34[op11r](s=1)&(rtry=2)&(op1=1)→r11:(rtry’=1)+(1-r11):(op1’=2)&(rtry’=1);35[op12](s=1)&(rtry=1)&(op1=2)→p12:(s’=2)+(1-p12):(rtry’=2);36[op12r](s=1)&(rtry=2)&(op1=2)→r12:(rtry’=1)+(1-r12):(s’=9);...46//Operation#3:SequentialexecutionstrategywithretryfortheAlarm47[op31](s=3)&(rtry=1)&(op3=1)→p31:(s’=6)+(1-p31):(rtry’=2);48[op31r](s=3)&(rtry=2)&(op3=1)→r31:(rtry’=1)+(1-r31):(op3’=2)&(rtry’=1);49[op32](s=3)&(rtry=1)&(op3=2)→p32:(s’=6)+(1-p32):(rtry’=2);50[op32r](s=3)&(rtry=2)&(op3=2)→r32:(rtry’=1)+(1-r32):(s’=9);...76//Technicalanalysisresult77[TAResult]s=7→y1:(s’=5)+y2:(s’=1)+(1-y1-y2):(s’=3);78//Fundamentalanalysisresult79[FAResult]s=8→z1:(s’=5)+z2:(s’=9)+(1-z1-z2):(s’=4);80//FXﬁnalstates(workﬂowcompletedsuccessfullyorfailed)81[failedFX]s=9→1:(s’=9);82[successFX]s=10→1:(s’=10);83endmodule8485//Timetakenbyservicesasstatereward86rewards“time”87(s=1)&(op1=1)&(rtry=1):t11;88(s=1)&(op1=2)&(rtry=1):t12;89(s=2)&(op2=1)&(rtry=1):t21;90(s=2)&(op2=2)&(rtry=1):t22;91(s=3)&(op3=1)&(rtry=1):t31;92(s=3)&(op3=2)&(rtry=1):t32;93(s=4)&(op4=1)&(rtry=1):t41;94(s=4)&(op4=2)&(rtry=1):t42;95(s=5)&(op5=1)&(rtry=1):t51;96(s=5)&(op5=2)&(rtry=1):t52;97(s=6)&(op6=1)&(rtry=1):t61;98(s=6)&(op6=2)&(rtry=1):t62;99endrewards5

and reachability reward pDTMC properties in Section 4.1. A
pDTMC model restructuring algorithm that aids the forma-
tion of fragments is discussed in Section 4.2. Section 4.3 pro-
vides formal proofs for the correctness the fPMC algorithms.
Finally, Section 4.4 illustrates the application of fPMC to the
pDTMC model and PCTL properties from our motivating
example.

4.1 Markov Chain Fragmentation Algorithm

fPMC partitions a pDTMC into fragments that can be anal-
ysed individually by current parametric model checkers.
This partition is carried out by the function FRAGMENTA-
TION from Algorithm 1, supported by the auxiliary func-
tions from Algorithms 2, 3 and 4. The function FRAGMEN-
TATION takes four arguments:

1)
2)

3)

4)

the analysed pDTMC D(S, s0, P, L);
the analysed PCTL formula φ, which can be a
reachability property P=?[F Φ], an unbounded un-
til property P=?[Φ1 U Φ2], or a reachability reward
property Rrwd
=? [F Φ], where the inner state formulae
Φ, Φ1 and Φ2 cannot contain the probabilistic oper-
ator P;2
a reward function rwd over D, which is only rel-
evant if φ is a reachability reward property (we
assume that rwd (s) = 0 for all s ∈ S otherwise);
a fragmentation threshold α ∈ N>0, whose role is
described later in this section.

Given these arguments, the function returns (line 28):

1)

2)

3)

a restructured version of
the original pDTMC,
where the restructuring (described later in this sec-
tion) aids the formation of fragments;
a revised version of the reward function rwd that
matches the restructured pDTMC;
a set of fragments FS that satisfy Deﬁnition 5, with
each state of the restructured pDTMC either in-
cluded in a regular, multi-state fragment or organised
into a one-state (degenerate) fragment.

The function starts by placing the pDTMC states that
satisfy Φ1 and Φ2 (if the analysed property is an unbounded
until formula P=?[Φ1 U Φ2]) or Φ (if the analysed property
is a reachability formula P=?[F Φ] or a reachability reward
formula Rrwd
=? [F Φ]) into a set of “visited” states V (line 2).
Each state from V is then used to assemble a one-state
fragment that is placed into the fragment set FS (line 3).
The states from V are preserved as one-state fragments so
that they can appear in the fPMC abstract model (see the
description from Section 2.3). This allows the direct analysis
of the PCTL property φ, which refers to these states from
the abstract model.

Next, additional fragments (Z, z0, ZOUT) are generated
in each iteration of the for loop from lines 4–27 as follows.
First, a node z0 not yet included in any fragment is selected
(line 4) and inserted into the fragment state set Z (line 5),
while the fragment output set Zout is initialised to the empty
set (line 6). An empty stack, T , is created in line 7, and
then populated with the states reached by the outgoing

Fig. 5: Graph representation of the FX pDTMC; the model
comprises 29 states and 58 transitions

aspects from lines 3–18 is justiﬁed because:

1)

the operational proﬁle of a system is often unknown
when its model is developed;

2) modelling the system conﬁguration by means of a
set of parameters allows the exploration and better
selection of suitable system conﬁgurations;
the execution times of individual services are not
available until the system is deployed and executed
(and may change over time).

3)

Inside the WorkﬂowFX module, we use the local variable
state (line 22) to model the operations in the FX system,
and use retry (line 24) and opi (line 26–27) to encode the
retry status of a service implementation and the employed
service implementation for each operation, respectively. The
selection of the expert or normal mode is decided in line 30,
and the execution of the FX operations is modelled in
lines 33–75. Due to space constraints, we only show the
modelling of the Market Watch operation (line 33–36) and the
Alarm operation (lines 46–50); all the other FX operations are
modelled similarly. For both operations, the invocation of
the ﬁrst service succeeds with probability pi1 and FX moves
to the next operation, fails with probability 1 − pi1 and is
retried with probability ri1 (lines 33 and 34, and lines 47 and
48, respectively); otherwise, the second service is executed
and succeeds, or is re-invoked with probabilities pi2 and ri2
in lines 35 and 36, and lines 49 and 50, respectively. If both
service implementations fail, the FX workﬂow execution
terminates with a failure in line 81.

Fig. 5 shows the directed graph induced by the FX
pDTMC, with the initial and ﬁnal states of the FX workﬂow
highlighted in colour. For this pDTMC model, we assume
that we are interested in analysing the three non-functional
properties from Table 1. We note that despite the relatively
small number of states and transitions from the FX pDTMC
model, the leading parametric model checkers PRISM [42]
and Storm [21] could not return a closed-form PMC formula
for any of these properties within an hour when run on
the MacBook Pro computer we used in all our experiments
(please see Section 6.1 for a detailed speciﬁcation of this
computer). In the next section, we explain how fPMC can
successfully analyse those three properties via automated
model fragmentation.

4 FPMC THEORETICAL FOUNDATION

We present the model fragmentation algorithm that under-
pins the fPMC analysis of reachability, unbounded until

2. Like other parametric model checking methods [19], [36], [41],

fPMC only supports non-nested probabilistic properties.

initialsuccessFXfailedFXTABLE 1: Non-functional properties for the FX system from the motivating example

6

ID Property type

Informal description

P1 Reachability

probability that FX workﬂow completes successfully

P2 Reachability reward

expected workﬂow execution time

Property speciﬁed in PCTL

P=?[F successFX]
Rtime

=? [F failedFX ∨ successFX]

P3 Unbounded until

probability that FX workﬂow completes successfully without triggering an alarm P=?[ ! Alarm U successFX]

Algorithm 1 pDTMC model fragmentation

Algorithm 2 Traversal of pDTMC-induced graph

1: function FRAGMENTATION(D(S, s0, P, L), φ, rwd, α)

(cid:26){s ∈ S | s |= Φ1 ∨s |= Φ2}, if φ = P=?[Φ1 U Φ2]
{s ∈ S | s |= Φ},

if φ = P=?[F Φ]∨φ = Rrwd

2:

V ←

=? [F Φ]

FS ← {({s}, s, {s}) | s ∈ V }
for all z0 ∈ S \ V do

Z ← {z0}
ZOUT ← {}
T ← EMPTYSTACK()
TRAVERSE(D(S, s0, P, L), rwd, FS , V, T, Z, z0, true)
while ¬EMPTY(T ) do

z ← T.POP()
if {i ∈ S | P(i, z) (cid:54)= 0}⊆Z ∧ {o ∈ S | P(z,o) (cid:54)= 0}⊆S\Z then

ZOUT ← ZOUT ∪ {z}

if #Z < α then
TRAVERSE(D(S,s0,P,L), rwd, FS , V, T, Z, z, false)
else
TERMINATE(D(S,s0,P,L),φ, rwd, F S, V, T, Z, ZOUT, z)
end if

end if
Z ← Z ∪ {z}

end while
if ¬VALIDFRAGMENT((Z, z0, ZOUT)) then

else

3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29: end function

Z ← {z0}, ZOUT ← {z0}

end if
FS ← FS ∪ {(Z, z0, ZOUT)}
V ← V ∪ Z

end for
return D(S, s0, P, L), rwd, FS

transitions from z0 through invoking (in line 8) the function
TRAVERSE from Algorithm 2. Each state z from this stack,
T , is processed by the while loop from lines 9–21, ending up
in ZOUT if it satisﬁes the constraints associated with output
fragment states (lines 11 and 12). When z does not satisfy
these constraints, two options are possible (lines 13–19):

• If Z has accumulated fewer states than the threshold α,
the graph traversal function TRAVERSE is invoked again
to add to the stack the predecessor and successor vertices
of z that are not already in the fragment (line 15).

• Otherwise, the function for the early fragment formation
TERMINATE from Algorithm 3 is invoked to “force” z into
becoming an output state (by restructuring the pDTMC)
whenever that is possible (line 17).

In this way, the threshold α provides a soft upper bound
for the fragment size. When this bound is reached, the
model restructuring techniques detailed in Section 4.2 are
used to force the formation of a valid fragment if possible.
Irrespective of the way in which z is processed in lines 11–
19, it becomes part of the fragment being constructed, and
therefore it is added to the fragment state set Z in line 20.

The fragment candidate (Z, z0, ZOU T ) assembled by the
while loop from lines 9–21 is validated in line 22. If the
candidate does not satisfy the constraints from Deﬁnition 5,

else

T.PUSH(I)

if ¬inputState then

I ← {i ∈ S \Z | P(i, z) (cid:54)= 0}
if I ∩ V = {} then

FS ← FS ∪ {({z}, z, {z})}
V ← V ∪ {z}
return

1: function TRAVERSE(D(S, s0, P, L), rwd, FS , V, T, Z, z, inputState)
(cid:46) z is not the fragment’s input state
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20: end function

O(cid:48) ← RESTRUCTURESTATE(D(S, s0, P, L), rwd, Z, z)
T.PUSH(O(cid:48))

end if
O ← {o ∈ S \Z | P(z, o) (cid:54)= 0}
if O (cid:54)⊆ V then

T.PUSH(O\V )
if V \O (cid:54)= {} then

end if

end if

end if

the fragment is “downgraded” by using its input state, z0,
to form a degenerate, one-state fragment (line 23). After
validation (and, if necessary, degradation or restructuring),
the new fragment is added to the fragment set FS (line 25),
and its states are added to the set of “visited” states V
already assigned to fragments (line 26), ensuring that they
are not re-used by the loop starting in line 4.

The growing of a fragment in Algorithm 1 is carried out
by the function TRAVERSE from Algorithm 2. Given a state
z, TRAVERSE examines:

• its incoming transitions in lines 2–11 (only if z is not the
input state z0 of the fragment under construction, i.e., if
inputState is false in line 2);

• its outgoing transitions in lines 12–19.

The states that are directly connected to z via the examined
incoming and outgoing transitions, and that are not already
in the set of fragment states Z, are collected into an input
state set I (line 3) and an output state set O (line 12), respec-
tively. These two sets of states are processed as follows.

Firstly, the states from I are added to the stack T (line 5)
if none of them belongs to an existing fragment (line 4).
Otherwise, z is organised into a one-state fragment and
the traversal of the pDTMC-induced graph is terminated
(lines 7–9) because, with an incoming transition from a state
belonging to an already assembled fragment, z cannot be
an inner or output state of the fragment under construction.
Note that creating this one-state fragment halfway through
assembling another fragment may impact the construction
of the other fragment. If this is the case, then the issue will
be detected and dealt with by the validation process from
Algorithm 1 (line 22).

Secondly, if the output set O has at least one state

Algorithm 3 Early termination of fragment formation

Algorithm 4 pDTMC restructuring

7

=? [F Φ] ∨ rwd(z) = 0) then

if (∃ i ∈ S \Z.P(i, z) (cid:54)= 0) ∧ (∀ o ∈ Z.P(z, o) = 0)
∧(φ (cid:54)= Rrwd
RESTRUCTURETRANS(D(S, s0, P, L), Z, z)
ZOUT ← ZOUT ∪ {z}

1: function TERMINATE(D(S, s0, P, L), φ, rwd, FS , V, T, Z, ZOUT, z)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12: end function

else if (∀ i ∈ S \Z.P(i, z) = 0) ∧ (∃ o ∈ Z.P(z, o) (cid:54)= 0) then
O ← RESTRUCTURESTATE(D(S, s0, P, L), rwd, Z, z)
Z ← Z ∪ O, ZOUT ← ZOUT ∪ O

TRAVERSE(D(S, s0, P, L), rwd, FS , V, T, Z, z, false)

end if

else

not belonging to other fragments (line 13), growing the
fragment under construction with the “successors” of z may
be feasible. As such, the function:

• places the states from O that do not belong to other

fragments onto the stack T (line 14);

• if O contains states belonging to previously constructed
fragments (line 15),
it attempts to continue to grow
the fragment under construction by using the function
RESTRUCTURESTATE from Algorithm 4 to extend the
pDTMC with auxiliary states O(cid:48) that allow z to become
an inner fragment state (lines 16 and 17).

4.2 Early Termination of Fragment Construction and
Model Restructuring to Aid Fragment Formation

As we will show in Section 4.3, the function FRAGMENTA-
TION from Algorithm 1 is guaranteed to partition a pDTMC
into a set of valid fragments. However, the success of fPMC
also depends on these fragments being of an appropriate
size. If a fragment is too large, existing PMC techniques
(which fPMC uses for the fragment analysis, see Figure 2)
will be unable to handle it. Conversely, partitioning a
pDMTC into a very large number of small fragments may
yield an abstract model whose analysis is unfeasible.

Based on our experience (see Section 6), pDTMCs that
model complex systems often comprise many loops (e.g., see
the pDTMC from Figure 5), whichs favour the formation of
fragments that may be too large for existing PMC techniques
to analyse. To address this issue, FRAGMENTATION uses
the threshold α to decide when to force the formation of
a fragment, preventing it from growing too large (line 14
from Algorithm 1). This early termination of the fragment
formation is accomplished by the function TERMINATE. This
function is supplied (in line 17) with complete information
about the fragmentation process so far and, importantly,
with a state z that does not satisfy the condition from line 11
and therefore cannot be an output state for the fragment
under construction. The role of TERMINATE is to modify
the pDTMC states and/or transitions such that: (i) z meets
the condition for being an output fragment state in the
restructured pDTMC; (ii) the modiﬁcations do not affect
the PMC result. This restructuring is possible in one of
the following two scenarios, which are handled in lines 2–
5 and 6–8 of TERMINATE, respectively. If neither scenario
applies, TERMINATE cannot support the early termination
of the fragment construction, and therefore needs to invoke
the function TRAVERSE, which will continue to grow the

I ← {i ∈ S \Z | P(i,z) (cid:54)= 0}
O ← {o ∈ S | P(z,o) (cid:54)= 0}
for all i ∈ I do
P(i, z) ← 0
for all o ∈ O do

1: function RESTRUCTURETRANS(D(S, s0, P, L), Z, z)
2:
3:
4:
5:
6:
7:
8:
9:
10: end function

P(i, o) ← P(i, z) · P(z, o)

end for

end for

z(cid:48) ← NEWSTATE()
S ← S ∪ {z(cid:48)}
for all s ∈ S do

O ← {o ∈ S \Z | P(z, o) (cid:54)= 0}
NewStates ← {}
for all o ∈ O do

11: function RESTRUCTURESTATE(D(S, s0, P, L), rwd, Z, z)
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26: end function

end for
P(z, z(cid:48)) ← P(z, o), P(z(cid:48), o) ← 1
L(z(cid:48)) ← {}
rwd(z(cid:48)) ← 0
NewStates ← NewStates ∪ {z(cid:48)}

end for
return N ewStates

P(s, z(cid:48)) ← 0, P(z(cid:48), s) ← 0

fragment (line 10). As such, the threshold α only provides a
soft upper bound for the size of an fPMC fragment.

Scenario 1. The state z has m ≥ 1 incoming transitions
(of probabilities pi1, pi2, . . . , pim) from states si1, si2, . . . ,
sim outside the fragment, and n ≥ 1 outgoing transitions
(of probabilities po1, po2, . . . , pon) to states so1, so2, . . . ,
son outside the fragment (line 2 from Algorithm 3 and
Figure 6a–left); additionally (for reasons explained in The-
orem 2 in Section 4.3) either the analysed property φ is not
a reachability reward property, or z is a zero-reward state.
In this scenario, we replace the transition between each state
sij, 1 ≤ j ≤ m, and z with transitions of probabilities pijpo1,
pijpo2, . . . , pijpon, between sij and the states so1, so2, . . . ,
son, respectively. This modiﬁcation of the pDTMC structure
is shown in Figure 6a–right, and is carried out by function
RESTRUCTURETRANS from Algorithm 4. To perform the
restructuring, the function ﬁrst assembles the sets of states
I = {si1, si2, . . . , sim} (line 2) and O = {so1, so2, . . . , son}
(line 3), and then iterates through state pairs (i, o) ∈ I × O,
removing the transition from state i to state z (line 5) and
inserting a transition from state i to state o. As a result of
this modiﬁcation of the original pDTMC, state z meets the
condition for becoming an output state of the fragment un-
der construction, and will be placed into the set of outputs
states ZOUT in line 5 from Algorithm 3.

Scenario 2. The state z has no incoming transitions from
outside the fragment under construction, but has outgoing
transitions to one or more states inside the fragment in
addition to n ≥ 1 outgoing transitions (of probabilities p1,
p2, . . . , pn) to states s1, s2, . . . sn outside of the fragment
(Figure 6b–left). In this scenario, we augment the pDTMC
with states z(cid:48)
n, and we replace each transition
between states z and sj, 1 ≤ j ≤ n with a transition of
probability pj between z and z(cid:48)
j and a transition of probabil-
ity 1 between z(cid:48)
j and sj. This change supports the formation
of a fragment whose output state set includes the auxiliary

2, . . . , z(cid:48)

1, z(cid:48)

8

(a) Transition replacement to force creation of output fragment state

(b) Auxiliary state insertion to force formation of fragment containing the new states among its output states

Fig. 6: Model restructuring techniques supporting fragment formation

1, z(cid:48)

1, z(cid:48)

2, . . . , z(cid:48)

2, . . . , z(cid:48)

states z(cid:48)
n (Figure 6b–right), and is performed by
the function RESTRUCTURESTATE from Algorithm 4. This
function assembles a set O comprising the states s1, s2, . . . sn
in line 12 and creates the set of NewStates z(cid:48)
n in
the for loop from lines 14–24. After it is created in line 15,
each new state is added to the state set S in line 16, has its
incoming and outgoing transition probabilities initialised in
lines 17–20, is associated with an empty label set and with
a zero reward in lines 21 and 22, respectively, and is added
to the set of NewStates in line 23. This NewStates set is
returned in line 25, so that the function TERMINATE can add
the new states to both the set Z of fragment states and the set
ZOUT of output fragment states (line 8 from Algorithm 3).

Before providing correctness proofs for the fPMC frag-
mentation in the next section, we note that the function RE-
STRUCTURESTATE is also used to support the growing of the
fragment under construction in the function TRAVERSE from
Algorithm 2. This use occurs when TRAVERSE processes (in
lines 16 and 17) a state z that has outgoing transitions to
states belonging to previously constructed fragments.

4.3 Correctness of the fPMC Fragmentation

We start by showing that the pDTMC fragmentation pro-
duced by fPMC is valid.

Theorem 1. Function FRAGMENTATION returns a valid frag-
mentation of the pDTMC D(S, s0, P, L) as restructured by its
auxiliary functions.

Proof. We prove this result by showing that: (a) the set
FS assembled by FRAGMENTATION comprises only valid
fragments; (b) the fragments from FS are disjoint (i.e., no
state from S is included in more than one fragment); and
(c) the function terminates and returns a set of fragments
FS that includes all the states from the state set S of the
restructured pDTMC.

To prove part (a), we note that new fragments are
added to FS in three lines from Algorithms 1 and 2. In
line 3 of Algorithm 1 and in line 7 of Algorithm 2, FS is
augmented with tuples that represent degenerate, one-state
fragments according to the deﬁnition given in Section 2.3.

Finally, in line 25 of Algorithm 1, FS is augmented with a
tuple (Z, z0, ZOUT) that either passes the fragment-validity
check from line 22, or is reduced to a degenerate, one-state
fragment in line 23 before it is included in FS . As such, any
tuple inserted into FS is a valid fragment.

To prove part (b), we note that the states from the set V
assembled in line 2 of FRAGMENTATION are each placed into
a degenerate, one-state fragment in line 3 of Algorithm 1,
and that the state set Z of any fragment (Z, z0, ZOUT) added
to FS comes from S \ V , where V is updated (in line 26 of
Algorithm 1, and in line 8 of Algorithm 2) to include all the
states of new fragments included in FS . To see that the states
of all new fragments come from S \ V , observe that:

(i) state z0 added to Z in line 5 and line 23 of Algorithm 1

comes directly from S \ V (line 4);

(ii) state z added to Z in line 20 of the same algorithm
(or included into FS as the only vertex of a degener-
ate fragment in line 7 of Algorithm 2) comes from the
stack T , which can only acquire vertices from S \ V
(as enforced by the if statements before lines 5 and 14
from Algorithm 2, and by the use of states newly created
by function RESTRUCTURESTATE in line 17 from Algo-
rithm 2);

(iii) the states added to Z in line 8 from Algorithm 3 are
states newly created by function RESTRUCTURESTATE,
which do not belong to any existing fragment.

Therefore, the fragments from FS are disjoint.

To prove part (c), we note that all the functions from
Algorithms 1–4 terminate. RESTRUCTURETRANS and RE-
STRUCTURESTATE from Algorithm 4 terminate because each
of their statements (including the assembly of the state sets
I and O in RESTRUCTURETRANS and of the state set O
in RESTRUCTURESTATE, and their for loops) operate with
ﬁnite numbers of states. As such, TRAVERSE also terminates
because it builds and operates with ﬁnite sets of states I
and O, and invokes a function that terminates (i.e., RE-
STRUCTURESTATE). The function TERMINATE contains no
loops and invokes one of three functions, each of which
is guaranteed to terminate; therefore, TERMINATE is also
guaranteed to terminate. Finally, FRAGMENTATION termi-

nates because:

(i) each iteration of its for loop adds at least state z0 from
S \ V to V in line 26, until S \ V = {} in line 4 (since S
is a ﬁnite set of states) and the loop terminates with all
states from S included in fragments from FS ;

(ii) its while loop terminates since it iterates over the ele-
ments of stack T that can only contain one instance of
each state from the ﬁnite set S and is therefore ﬁnite;
(iii) RESTRUCTURESTATE invocations can occur at most once
for each state of the initial pDTMC, and can only add a
ﬁnite number of states to S, as shown in Section 4.2.

Thus, FRAGMENTATION terminates, returning a fragment
set FS that includes all the vertices from S.

Having demonstrated that the function FRAGMENTA-
TION yields a valid fragmentation of the restructured ver-
sion of the pDTMC received as its ﬁrst argument, we will
show next that using this restructured pDTMC instead of
the original pDTMC to analyse the PCTL formula φ under
veriﬁcation does not change the PMC result.

Theorem 2. Applying the model restructuring techniques from
Algorithm 4 and Figure 6 to a pDTMC does not affect its
reachability, unbounded until and reachability reward properties.

Proof. We ﬁrst show that the theorem holds for any reach-
ability property φ = P=?[F Φ]. To that end, we consider a
generic pDTMC D, the pDTMC D(cid:48) obtained by applying
one of the model restructuring techniques from Figure 6 to
D, and the sets of all paths Π over D and Π(cid:48) over D(cid:48) that sat-
isfy φ. According to the semantics of PCTL, we need to show
that Prs0(Π) = Pr(cid:48)
(Π(cid:48)), where Prs0 is a probability mea-
s0
sure deﬁned over all paths π = s0s1s2 . . . sn starting in the
initial state s0 of D such that Prs0 (π) = (cid:81)n−1
i=0 P(si, si+1),
and Pr(cid:48)
s0 is a similarly deﬁned probability measure for D(cid:48).
We focus on the paths that differ between Π and Π(cid:48), and
show that Prs0 (Π \ Π(cid:48)) = Pr(cid:48)
(Π(cid:48) \ Π) for each technique
s0
from Figure 6 in turn:
• For the technique from Figure 6a, a path from Π\Π(cid:48) has
the form π = s0ω1sijzsokω2, with j ∈ {1, 2, . . . , m}, k ∈
{1, 2, . . . , n}, and ω1, ω2 subpaths such that ω2 ends in
a state that satisﬁes Φ. Path π has a corresponding path
π(cid:48) = s0ω1sijsokω2 ∈ Π(cid:48) \Π (and the other way around)
such that
Prs0(π) = Prs0(s0ω1sij)P(sij, z)P(z, sok)Prsok (sokω2)
(s0ω1sij)P(cid:48)(sij, sok)Pr(cid:48)
(π(cid:48))

(sokω2)

= Pr(cid:48)
s0
= Pr(cid:48)
s0

sok

the

since
P(cid:48)(sij, sok) = P(sij, z)P(z, sok).

restructuring technique guarantees

that

• For the technique from Figure 6b, a path from Π\Π(cid:48) has
the form π = s0ω1zsiω2 for some i ∈ {1, 2, . . . , n} and
subpaths ω1, ω2, with ω2 ending in a state that satisﬁes
Φ. Path π has a corresponding path π(cid:48) = s0ω1zz(cid:48)
isiω2 ∈
Π(cid:48) \Π (and the other way around) such that

Prs0 (π) = Prs0(s0ω1z)P(z, si)Prsi(siω2)

= Pr(cid:48)
s0
= Pr(cid:48)
s0

(s0ω1z)P(cid:48)(z, z(cid:48)
(π(cid:48))

i)P(cid:48)(z(cid:48)

i, si)Pr(cid:48)
si

(siω2)

since
P(cid:48)(z, z(cid:48)

the
i) = 1 and P(cid:48)(z(cid:48)

restructuring technique guarantees
i, si) = P(z, si).

that

9

We showed that neither of the restructuring techniques from
Figure 6 affects the value of the reachability property φ,
and therefore the ﬁnite number of applications of these
techniques within the fPMC fragmentation approach do not
affect this value either.

To show that the theorem holds for a generic unbounded
until property φ = P=?[Φ1 U Φ2], we ﬁrst note that the sets
of paths Π over D and Π(cid:48) over D(cid:48) that satisfy φ are subsets
of the path sets Πreach and Π(cid:48)
reach that satisfy the reachability
property P=?[F Φ2] over D and D(cid:48), respectively. We know
from the ﬁrst part of the proof that Πreach and Π(cid:48)
reach are
equiprobable. Consider now a generic path π ∈ Πreach\Π, i.e.,
a path that ends in a state that satisﬁes Φ2, but without any
intermediate state where Φ1 is satisﬁed. We have two cases.
If π is unaffected by the restructuring technique used to ob-
tain the pDTMC D(cid:48) from D, then π ∈ Π(cid:48)
reach\Π(cid:48). Otherwise,
the equiprobable path π(cid:48) ∈ Πreach constructed from π as in
the ﬁrst part of the theorem will not be in Π(cid:48) because none of
its intermediate states can satisfy Φ2. Indeed, any such states
that are identical to states from π do not satisfy Φ1 because
no intermediate state of π does, and any new states created
by the pDTMC restructuring is labelled with an empty set
of atomic propositions (in line 21 of Algorithm 4) and thus
does not satisfy any PCTL formula. We showed that path
sets Π and Π(cid:48) are obtained by removing equiprobable paths
from the equiprobable path sets Πreach and Π(cid:48)
reach. As such,
Π and Π(cid:48) are also equiprobable, and the theorem holds for
unbounded until properties.

Finally,
for a generic reachability reward property
φ = Rrwd
=? [F Φ], we note that the value of φ is given by a
weighted sum of the probabilities of all DTMC paths that
satisfy the associated reachability property P=?[F Φ], where
the weight associated with a path π = s0s1s2 . . . is the
cumulative reward rwd (s0)+rwd (s1)+rwd (s2)+. . . for the
states on the path. As shown in the ﬁrst part of the theorem,
the path formula F Φ is satisﬁed by pairs of equiprobable
paths π and π(cid:48) over D and D(cid:48), respectively. We will show
that the paths in every such pair have the same cumulative
reward. We have three cases. First, if π is unaffected by the
restructuring technique used to obtain the pDTMC D(cid:48) from
D, then π(cid:48) = π, and the two cumulative rewards are trivially
equal. Second, when the restructuring from Figure 6a is
used, a state z from path π is skipped on path π(cid:48), but
otherwise the two paths are identical. However, z is in this
case a zero-reward state (cf. line 2 from Algorithm 3), so
the two cumulative rewards are equal. Finally, when the
restructuring from Figure 6b is used, path π(cid:48) only differs
from π through the inclusion of an auxiliary state z(cid:48)
i. Since
rwd (zi) = 0 (cf. line 22 from Algorithm 4), the cumulative
rewards for the two paths are again equal. As such, the
theorem also holds for reachability reward properties.

We have shown so far that fPMC produces valid pDTMC
fragmentations, and that the model restructuring used dur-
ing this fragmentation does not impact the PMC of reacha-
bility, unbounded until and reachability reward properties.
The next result establishes the complexity of the fPMC
fragmentation. To derive this result, we adopt the standard
graph notation indegree(s) = #{s(cid:48) ∈ S | P(s(cid:48), s) (cid:54)= 0},
outdegree(s) = #{s(cid:48) ∈ S | P(s, s(cid:48)) (cid:54)= 0} and degree(s) =
max{indegree(s), outdegree(s)} to denote the number of

incoming transitions, the number of outgoing transitions,
and the maximum between the two numbers, respectively,
for a state s of a pDTMC.

Theorem 3. The function FRAGMENTATION requires at most
O(n3d) steps, where n represents the number of pDTMC states
after model restructuring3 and d = maxs∈S degree(s).

Proof. The function RESTRUCTURETRANS (Algorithm 4) re-
quires O(n) steps to assemble the state sets I and O, and at
most O(d2) steps to process up to indegree(z) · outdegree(z)
pairs of incoming-outgoing transitions of a state z. As such,
it has O(max{n, d2}) overall complexity. Given a state z, the
function RESTRUCTURESTATE requires O(n) steps to assem-
ble the state set O, and then O(nd) steps to initialise 2n tran-
sition probabilities for each new state it creates, since one
new state is created for each of the up to outdegree(z)−1 < d
outgoing transitions of z. Therefore, the overall complexity
of RESTRUCTURESTATE is O(nd).

The function TRAVERSE requires at most O(nd) steps
due to the invocation of RESTRUCTURESTATE, with its other
operations (i.e., building the set I and placing it onto the
stack T , and building the set O and placing O \V onto the
stack T ) performed in O(n) time.

The function TERMINATE requires O(n) time to evalu-
ate the conditions whose values determine which of the
functions RESTRUCTURETRANS, RESTRUCTURESTATE and
TRAVERSE it needs to invoke. As such, the complexity of
TERMINATE is given by the highest complexity among these
three functions, i.e., O(nd) for both RESTRUCTURESTATE
and TRAVERSE. Note that this complexity is higher than the
O(max{n, d2}) complexity of RESTRUCTURETRANS since
nd ≥ n, and (because n ≥ d) nd ≥ d2.

In the worst-case scenario where the fragmentation pro-
duces only one-state fragments, the execution of FRAGMEN-
TATION requires the execution of its for loop from lines 4–27
for each of the n0 ≤ n states of the initial pDTMC (with any
new states created by RESTRUCTURESTATE included into
the same fragment as the state that led to their creation,
cf. Figure 6b). Each iteration of this loop executes:

i) TRAVERSE (line 8) in O(nd) steps;
ii) a while loop (lines 9–21) with at most n iterations (one
for each pDTMC state) that may each invoke the O(nd)-
step TRAVERSE or the O(nd)-step TERMINATE, yielding
an O(n2d) complexity for the while loop;

iii) the fragment validity check from line 22, which requires

no more than O(nd) operations.

Thus, each iteration of the for loop from lines 4–27 is com-
pleted in no more than O(n2d) steps (due to the while loop
from lines 9–21), and the entire FRAGMENTATION requires
O(n3d) steps in the worst-case scenario.

We note that the coefﬁcients associated with n and d
from the big-O notation in Theorem 3 are typically well be-
low 1. For instance, in all our experiments, the for loop from
FRAGMENTATION was only executed for a small fraction of
the pDTMC states (because many fragments with multiple

3. RESTRUCTURESTATE may add up to outdegree(z) − 1 new states
for each of the n0 states of the initial pDTMC (i.e., of the pDTMC that
FRAGMENTATION receives as its ﬁrst argument), yielding a restructured
pDTMC with n0(d − 1) vertices in the worst-case scenario.

10

(a) pDTMC fragmentation for the reachability property from
the ﬁrst row of Table 1: 13 fragments were obtained, including
ﬁve one-state fragments.

(b) pDTMC fragmentation for the reachability reward property
from the second row of Table 1 and the “time” reward function
from Figure 4: 17 fragments were obtained, including 11 one-
state fragments.

(c) pDTMC fragmentation for the unbounded until property
from the last row of Table 1: 15 fragments were obtained,
including nine one-state fragments.

Fig. 7: fPMC fragmentation of the pDTMC from Figure 4 for
the PCTL properties from Table 1 and α = 5, with different
shading used to highlight each fragment.

states are typically produced), and TERMINATE, RESTRUC-
TURETRANS and RESTRUCTURESTATE were only executed
sparingly. Furthermore, it is worth noting that pDTMCs
are typically sparsely connected graphs, and therefore d is
relatively small.

4.4 fPMC Application to the Motivating Example

We illustrate the use of fPMC by using the pDTMC model
and properties from our running example (cf. Figure 4 and
Table 1). The leading parametric model checkers Storm and
PRISM time out without producing results for any of these
properties within 60 minutes of running on the computer
with the speciﬁcation provided in Section 6.1. The outcome
of applying fPMC to this pDTMC and each of the three
PCTL properties from Table 1 (with fragmentation threshold
α = 5) are summarised in Figure 7 and Table 2.

successFXfailedFXinitialsuccessFXfailedFXinitialinitialsuccessFXfailedFXTABLE 2: Summary of fPMC application to the pDTMC and properties of the FX system in Section 3

ID Property type

States

Transitions

fPMC time

Arithmetic operations

Evaluation time

Restructured pDTMC†

fPMC closed-form analytical model (cf. Fig. 2)

P1 Reachability
P2 Reachability reward
P3 Unbounded until

49
47
46

83
76
79

7.2s
7.7s
5.1s

1456
2020
1224

†starting from the initial FX pDTMC model with 29 states and 58 transitions in Figure 5

2ms
30ms
5ms

11

Figure 7 depicts the pDTMC fragments generated by
fPMC, which are different for each property because the
function FRAGMENTATION from Algorithm 1 starts by cre-
ating property-speciﬁc sets of one-state fragments in lines 2
and 3. Table 2 shows:

•

•

•

the change in pDTMC size due to fPMC restructuring
(an increase of 59%–69% in the number of states, and
31%–43% in the number of transitions compared to
the initial pDTMC from Figure 5);
the time taken by the end-to-end fPMC process from
Figure 2 (under 8s for each property by running the
tool presented in the next section on the computer
with the speciﬁcation provided in Section 6.1);
the number of arithmetic operations from the alge-
braic formulae of the fPMC closed-form analytical
model for each analysed property, and the time
required to evaluate these algebraic formulae for a
given parameter valuation by running MATLAB on
the computer from Section 6.1 (up to 30ms for the
evaluation of the 2020-operation formulae of prop-
erty P2).

Given the large size of the fPMC algebraic formulae for the
three FX properties, we do not include them in the paper;
they are provided on our project website https://www.cs.
york.ac.uk/tasp/fPMC.

5 IMPLEMENTATION

We developed a parametric model checking tool that im-
plements the fPMC algorithms presented in the previous
section. This tool uses:

•

•

the model checker PRISM, to identify the pDTMC
states that satisfy Φ, Φ1 and Φ2 in line 2 of Al-
gorithm 1, and to obtain the transition probability
matrix P (used throughout the fPMC algorithms)
from a pDTMC speciﬁed in the PRISM modelling
language (e.g., see Figure 4);
the model checker Storm, to apply standard PMC
to each pDTMC fragment and to the abstract model
from Figure 2.

As pDTMCs with small numbers of parameters are al-
ready handled extremely efﬁciently by Storm, our tool only
invokes the end-to-end fPMC approach for pDTMCs whose
number of such parameters exceeds a user-conﬁgurable
threshold β ∈ N>0. For pDTMCs with up to β model
parameters, the tool invokes Storm directly, and the PMC
is performed on the unfragmented model. According to our
experimental results (presented in Figure 8), β values in the
range 21..30 work well for most models.

6 EVALUATION

6.1 Evaluation methodology

We carried out extensive experiments to answer the research
questions summarised below. RQ1 (Efﬁciency): Does fPMC

model fragmentation improve the efﬁciency of parametric
model checking? We assess if our fPMC approach speeds
up parametric model checking in comparison to PRISM [42]
and Storm [21], and whether it can handle pDTMCs that
cannot be analysed by the two leading model checkers (with
a 60-minute timeout).

RQ2 (Result complexity): Does fPMC reduce the complex-
ity of the closed-form formulae generated by parametric
model checking? We assess whether the fPMC-computed
algebraic formulae are simpler (in terms of number of
arithmetic operations) than those computed by the leading
model checkers, and whether they can be evaluated faster
than those produced by Storm.

RQ3 (Conﬁgurability): How does the fragmentation
threshold α affect
the results of fPMC? We examine
how different fragmentation threshold values affect fPMC
in terms of the number of operations from the computed
closed-form formulae, and execution time for producing
those formulae.

Three software systems and processes taken from related
research [15], [17], [30], [33], [38] and belonging to different
application domains were used in our evaluation. These
systems were selected because their Markov models contain:

(i) multiple transition probabilities that can be mean-
ingfully speciﬁed as functions over a set of system
parameters;
conﬁguration variables that can be instantiated to
obtain pDTMCs of different sizes (i.e., with a broad
range of state and transition numbers).

(ii)

The three systems are described below, and the signiﬁ-
cant differences between their key characteristics are sum-
marised in Table 3. The full details of these models are
available in [15], [17], [30], [33], [38].

FX system. We introduced this system in Section 3, and its
pDTMC corresponding to the sequential execution strategy
with retry (SEQ R) in Fig. 4 and 5. For the fPMC evaluation
in this section, we also considered the additional strategies
below (applied to between one and ﬁve functionally equiv-
alent service implementations per FX operation):

•

SEQ—the services are invoked in order, stopping
after the ﬁrst successful invocation or after the last
service fails;

TABLE 3: Key characteristics of the systems and pDTMC models used for the fPMC evaluation

12

Application domain

System type

FX system

Financial

PL system

COM process

Vending machine controller

Communication protocol

Service-based system

Software product line

Middleware

Number of model variants
Number of states
Number of transitions
Number of model parameters

21
11–208
22–399
11–71

40
92–115
167–198
10–198

1
234
444
20

Analysed properties

Reachability
Reward × 2
Unbounded until

Reachability
Unbounded until

Reachability × 21
Reward

Sample reachability property
Sample reachability reward property Rtime
Sample unbounded until property

P=?[F successFX]

=? [F successFX ∨ failFX]

P=?[¬alarm U successFX]

P=?[F SUCCESS]
–
P=?[¬Function1 U SUCCESS]

P=?[F ¬a0 ∧ ¬a1 ∧ . . . ∧ ¬a19]
Rcoin ﬂips
–

[F b]

=?

• PAR—all services are invoked in parallel (i.e., simul-
taneously), and the operation uses the result returned
by the ﬁrst service terminating successfully;

• PROB—a probabilistic selection is made among the

2)

3)

the number of arithmetic operations in the PMC
formulae;4
the time required to evaluate the PMC formulae (in
MATLAB) for a parameter valuation.

available services;

• PROB R—similar to PROB, but if the selected service
fails, it is retried with a given probability (as in
SEQ R).

PL system. We used a pDTMC model of a product line
(PL) system taken from [17], [33]. This pDTMC models the
software controller of a vending machine that dispenses
a user-selected beverage and, if applicable, takes payment
from and gives back change to the user.

The possible features of this system comprise: the bev-
erage type (soda, tea, or both), the payment mode (cash
or free), and the taste preference (e.g., add lemon or
sugar). This variability enables the derivation of vending
machines—and the speciﬁcation of associated pDTMCs—
with between four and 22 features.

COM process. We considered a communication (COM)
process among n ≥ 2 agents taken from [38], and inspired
by the way in which honeybees emit an alarm pheromone
to recruit workers and protect their colonies from intrud-
ers. Given the self-destructive defence behaviour in social
insects (the recruited workers die after completing their
defence actions), a balance between efﬁcient defence and
preservation of a critical mass of workers is required. The
induced pDTMC is a stochastic population model with
n parameters. The quantitative analysis of such stochastic
models of multi-agent systems is often challenging because
the dependencies among the agents within the population
make the models complex.

Throughout the evaluation, fPMC is compared to the
leading PMC model checkers PRISM (version 4.6) and Storm
(version 1.5.1), both with their default settings. All experi-
ments were performed on a MacBook Pro with 2.7GHz dual
Core Intel i5 processor and 8GB RAM, using a timeout of
60 minutes. For a fair comparison, we ensured that both
PRISM and Storm can successfully process at least the sim-
plest pDTMC of each systems. The following experimental
data were collected:

To ensure the correctness of our fPMC tool, we evalu-
ated the fPMC formulae produced for each analysed prop-
erty using randomly generated combinations of parameter
values, and conﬁrmed that the resulting property value
matched that produced by PRISM and Storm (subject to
negligible rounding errors). For the purpose of this check,
the PRISM and Storm results were obtained by running the
probabilistic model checking on the non-parametric DTMC
obtained by replacing the pDTMC parameters with the
relevant combination of parameter values. While this is not a
formal proof that the fPMC tool was implemented correctly,
we note that even small alterations of the non-trivial for-
mulae generated by the tool yield noticeable changes in the
evaluation results, so this random testing strongly suggests
that the fPMC tool operates correctly.

The source code of our fPMC tool, the models, properties
and results for all the experiments presented in the paper,
as well as additional materials supporting the adoption of
fPMC are available on our project website at https://www.
cs.york.ac.uk/tasp/fPMC.

6.2 Results and discussion

6.2.1 RQ1 (Efﬁciency)
FX system. We used fPMC, PRISM and Storm to analyse
pDTMC models corresponding to 21 variants of the FX
system. The ﬁrst of these system variants used a single
service for each FX operation, and the remaining vari-
ants used one of the ﬁve execution strategies (i.e., SEQ,
SEQ R, PAR, PROB or PROB R) and between two and ﬁve
functionally equivalent services for each FX operation. For
each of the 21 pDTMCs, four properties were analysed: the
properties P1, P2 and P3 from Table 1, and an additional
reachability reward property (property P4) used to establish
the expected cost of executing the FX workﬂow.

The parametric model checking times for these exper-
iments are presented in Table 4. These results show that
fPMC successfully computed all PMC formulae well ahead

1)

the time required to compute the PMC formulae;

4. PRISM and Storm produce a single PMC formula per property,

whereas fPMC yields a set of formulae per property (cf. Figure 2).

TABLE 4: Parametric model checking times (in seconds, ‘–’ indicates a timeout) for the 21 FX pDTMC variants and their
four properties; STG, #SVC, #S and #T represent the strategy used to invoke multiple functionally equivalent services for
an FX operation, the number of such services, and the numbers of pDTMC states and transitions, respectively.

13

pDTMC variant

P1 PMC time

P2 PMC time

P3 PMC time

P4 PMC time

ID

STG

#SVC #S #T

fPMC Storm PRISM

fPMC Storm PRISM

fPMC Storm PRISM

fPMC Storm PRISM

–

SEQ

PAR

PROB

SEQ R

PROB R

1

2
3
4
5

6
7
8
9

10
11
12
13

14
15
16
17

18
19
20
21

1 11 22

2 17 34
3 23 46
4 29 58
5 35 70

2 40 36
3 64 111
4 112 207
5 208 399

2 23 46
3 29 64
4 35 82
5 65 130

2 29 58
3 41 28
4 53 106
5 65 130

2 29 58
3 35 75
4 41 93
5 47 111

2.9

3.5
3.8
5.0
5.7

5.6
6.8
14.3
31.2

0.01

2.5
–
–
–

1.8
–
–
–

0.4
3.4
3.4
5.2
27.0
6.7
8.2 592.8

7.3
18.8
85.7
496.1

8.1
17.0
65.3
199.7

–
–
–
–

34.0
–
–
–

0.4

57.1
–
–
–

2.4
–
–
–

10.0
–
–
–

–
–
–
–

54.8
–
–
–

3.9

0.03

4.7
6.9
8.6
11.8

6.2
7.5
21.9
45.4

2.6
–
–
–

3.3
–
–
–

0.6
5.8
4.9
8.6
46.0
11.7
16.5 611.3

8.4
35.0
152.3
1305.4

8.8
23.6
79.5
243.5

–
–
–
–

–
–
–
–

0.8

5.7
–
–
–

3.5
–
–
–

–
–
–
–

–
–
–
–

–
–
–
–

2.9

0.01

0.5
3.4
3.5 1127.5
–
5.0
–
5.2

5.0
6.4
14.7
26.6

0.6
–
–
–

0.2
4.5
1.1
5.2
10.0
6.7
8.1 153.3

5.1
18.9
49.7
331.0

4.1
12.6
52.2
171.1

–
–
–
–

3.2
–
–
–

0.6

17.5
–
–
–

2.0
–
–
–

5.0
–
–
–

–
–
–
–

–
–
–
–

3.7

0.02

4.5
6.8
9.0
11.1

6.4
9.2
32.5
78.0

2.5
–
–
–

1.6
–
–
–

0.6
6.1
5.0
7.6
48.6
11.4
16.3 580.3

7.8
35.2
159.0
1335.9

8.3
23.2
80.4
244.3

–
–
–
–

–
–
–
–

0.8

5.6
–
–
–

3.4
–
–
–

–
–
–
–

–
–
–
–

–
–
–
–

of the 60-minute timeout for all four properties. It took
fPMC just 2.9s to analyse properties P1 and P3 for the sim-
plest pDTMC variant (ID 1), and under 600s for analysing
each of the four properties for most of the other models.
Only the analyses of properties P2 and P4 for the pDTMC
variant with ID 17 required more time, i.e., 1305.4s and
1335.9s, respectively. In contrast, Storm only completed the
analysis for 31 of the 21 × 4 = 84 model–property combi-
nations before the 60-minute timeout. These combinations
correspond to the simplest pDTMC variants (which Storm
analysed slightly faster than fPMC) across all execution
strategies except the PROB strategy. For this strategy, Storm
produced PMC formulae for all model-property combina-
tions, but with an execution time that increased very quickly
over the fPMC time for the more complex PROB pDTMC
variants with four and ﬁve functionally equivalent services
per FX operation (i.e., the pDTMC variants with IDs 12 and
13 in the table). PRISM completed the analysis for even
fewer model–property combinations: only 15 of the 84 PMC
analyses returned results within 60 minutes. These results
correspond again to the simplest pDTMC variants.

PL system. We used fPMC, PRISM and Storm to analyse
pDTMC models corresponding to system conﬁgurations
with four, 16, 18 and 22 software product line features, and
with increasing numbers of parameters. To that end, we
used different parameters for 10%, 20%, . . . , 100% of the
transition probabilities of the models for the four system
conﬁgurations, obtaining 4 × 10 = 40 pDTMC variants. The
reachability and unbounded until properties from Table 3
were analysed for each of these pDTMC variants, and the
time taken by these analyses are reported in Table 5.

The results are similar to those obtained for the FX
system. fPMC produced all PMC formulae successfully in

between 13.3 and 93.1 seconds, while Storm and PRISM
completed only 50% and 35% of the PMC analyses, respec-
tively, before the 60-minute timeout. The two existing model
checkers could analyse the pDTMCs with low numbers of
parameters, and performed their PMC faster than fPMC
for pDTMCs with the fewest parameters but increasingly
slower than fPMC for pDTMCs with more than approx-
imately 40% of their transition probabilities speciﬁed as
parameters.

COM process. As indicated in Table 3, a single pDTMC
variant (with 234 states and 444 transitions) was analysed
for the COM process. A number of 21 reachability properties
and one reachability reward property (taken from [38])
were considered, and the times required to complete their
parametric model checking are reported in Table 6.

Once more, fPMC was the only approach that success-
fully analysed all properties. Storm completed the analysis
of reachability properties 1–13 much faster than fPMC,
but took signiﬁcantly longer to analyse the reachability
properties 14–21, and timed out for the reachability reward
property. PRISM completed the fewest analyses (12 out of
22) but produced the PMC formulae for these approximately
55% of the properties faster than fPMC.

Discussion. fPMC outperforms both Storm and PRISM in
its ability to handle complex pDTMC with large numbers
of parameters. In many of our PMC experiments with
such models, fPMC completed its analysis within a few
tens of seconds, while the other model checkers timed out
after 3600 seconds. Thus, our approach often speed up the
analysis for two or more orders of magnitude. Furthermore,
the increase in the fPMC analysis time as the models be-
came more complex was consistently much slower than the
increase of the analysis time for the other model checkers

TABLE 6: Parametric model checking times (in seconds, ‘–’
indicates a timeout) for the COM model and its 22 properties

14

Property

PMC time

Type

fPMC

Storm

PRISM

12.8
12.4
11.8
12.0
12.9
12.9
12.5
12.7
12.6
12.8
11.6
11.9
11.8
12.4
11.5
12.5
11.6
11.6
11.7
11.3
11.7

41.7

<1ms
0.001
0.004
0.004
0.03
0.01
0.4
0.1
0.4
0.5
3.8
8.4
1.7
15.0
18.8
94.3
73.8
316.6
130.9
39.2
22.4

–

y
t
i
l
i

b
a
h
c
a
e
R

Reward

0.7
0.6
0.8
0.4
1.2
0.6
3.0
0.9
4.8
1.9
3.9
9.4
–
–
–
–
–
–
–
–
–

–

ID

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

22

TABLE 5: Parametric model checking times (in seconds, ‘–
’ indicates a timeout) for the 40 PL pDTMC variants and
their two properties; #F and %PAR represent the number
of features in the model, and the percentage of parametric
transitions, respectively.

pDTMC variant†

Reachability

Unbounded until

ID #F %PAR fPMC Storm PRISM fPMC Storm PRISM

1
2
3
4
5
6
7
8
9
10

11
12
13
14
15
16
17
18
19
20

21
22
23
24
25
26
27
28
29
30

31
32
33
34
35
36
37
38
39
40

4

16

18

22

10
20
30
40
50
60
70
80
90
100

10
20
30
40
50
60
70
80
90
100

10
20
30
40
50
60
70
80
90
100

10
20
30
40
50
60
70
80
90
100

0.01
48.4
0.2
56.6
3.1
55.2
56.3
32.0
73.5 1671.1
–
81.8
–
86.5
–
92.2
–
93.0
–
93.1

46.8
50.1
19.9
19.8
22.6
22.4
23.1
24.0
26.4
23.8

14.0
13.9
14.1
13.9
14.9
14.3
14.6
17.7
17.4
17.1

38.6
45.9
42.4
42.4
42.3
42.5
43.0
43.3
48.4
48.6

0.3
15.7
23.4
31.6
164.6
164.9
–
–
–
–

0.04
0.1
0.5
18.7
911.3
–
–
–
–
–

0.03
3.5
42.3
793.4
–
–
–
–
–
–

0.2
0.3
1.4
5.1
105.5
–
–
–
–
–

14.9
–
–
–
–
–
–
–
–
–

0.9
1.1
2.4
41.6
86.1
188.9
–
–
–
–

1.8
53.2
–
–
–
–
–
–
–
–

23.8
26.9
27.4
29.3
37.4
42.2
51.8
50.2
52.1
51.2

16.3
16.2
16.5
16.3
17.3
17.7
17.8
19.1
18.9
18.9

13.5
13.3
13.3
13.5
14.2
14.1
14.1
15.3
16.1
15.6

37.8
41.1
41.5
41.2
42.1
42.0
43.3
43.5
48.9
49.2

0.007
0.1
3.1
22.6
711.6
–
–
–
–
–

0.1
6.3
3.4
3.8
15.7
92.3
–
–
–
–

0.04
0.1
0.5
16.4
840.6
–
–
–
–
–

0.035
3.3
39.3
569.3
–
–
–
–
–
–

0.3
0.6
1.5
5.3
56.8
–
–
–
–
–

5.1
–
–
–
–
–
–
–
–
–

0.3
0.5
1.5
27.6
69.8
78.5
–
–
–
–

0.5
23.4
–
–
–
–
–
–
–
–

†pDTMCs sizes: four-feature models = 92 states, 167 transitions
16-feature models = 110 states, 193 transitions
18-feature models = 104 states, 183 transitions
22-feature models = 115 states, 198 transitions

Fig. 8: pDTMCs analyses completed faster by Storm and by
fPMC for models with different numbers of parameters. The
dashed boxes show the total numbers of analyses completed
by Storm within 60 minutes (fPMC completed all analyses).

for the FX and PL systems, and the fPMC PMC time was
not affected much by the analysed property for the COM
process.

For some of the simpler pDTMC variants (in the case of
the FX and PL systems) or properties (in the case of the COM
process), Storm and, only occasionally, PRISM completed
the analysis faster than fPMC. These results are expected for
the models and properties that Storm and PRISM can handle
because the two leading model checkers use highly efﬁcient
internal representations (e.g., sparse matrices, binary deci-
sion diagrams) for DTMCs and sophisticated algorithms for
their analysis. In contrast, fPMC needs to perform fragmen-
tation before leveraging the same functionality (by using
Storm) for the resulting fragments and the abstract model

induced by these fragments (cf. Figure 2).

To exploit the capabilities of both fPMC (which can
efﬁciently analyse complex pDTMCs that other tools cannot
handle) and Storm (which can efﬁciently analyse simple
pDTMCs), our fPMC tool employs the user-conﬁgurable
threshold β we mentioned in Section 5. For models with
β or more parameters, the tool performs the analysis by
using fPMC fragmentation, while for simple models with
fewer than β parameters Storm is used directly to perform
monolithic PMC. To support the selection of a suitable
value for the threshold β, we compared the execution times
of fPMC and Storm for pDTMC variants with different
numbers of parameters from our evaluation. The result of
this comparison is summarised by the histogram in Figure 8,

8299161011552322218166421...1011...2021...3031...4041...5051...6061...7071...8081...9091...100101...110Number of pDTMC parameters0510152025303540FrequencyStorm fasterfPMC fasterStorm completed successfully15

(a) property P1

(b) property P2

(c) property P3

(d) property P4

Fig. 9: Number of operations in the PMC formulae for the FX pDTMC variants and properties from Table 4, with the values
corresponding to the same service combination strategy (SEQ, PAR, etc.) joined by continuous lines to improve readability

TABLE 7: MATLAB evaluation time for the FX PMC formulae (in seconds)

pDTMC variant

P1

P2

P3

P4

ID

1

2

6

10
11
12
13

18

STG

–

SEQ

PAR

PROB

PROB R

#SRV

fPMC

1

2

2

2
3
4
5

2

0.001

0.002

0.006

0.001
0.002
0.007
0.013

0.006

Storm

0.004

3.5

3.5

0.06
5.4
156.2
4245.1

17.2

fPMC

0.001

0.005

0.006

0.004
0.006
0.01
0.016

0.01

Storm

0.002

8.2

8.9

0.1
10.9
271.9
7507.1

–†

fPMC

0.001

0.002

0.002

0.004
0.007
0.008
0.016

0.01

Storm

fPMC

0.002

7.9

2.4

0.1
11.2
267.2
7499.1

–†

0.001

0.001

0.004

0.008
0.003
0.008
0.008

0.007

Storm

< 1ms

0.3

0.3

0.01
0.4
12.8
142.8

0.09

†PMC formula unavailable for evaluation due to Storm analysis timeout

which shows that most pDTMCs with up to 20 parameters
were analysed faster by Storm, while almost all the pDTMCs
with over 30 parameters were analysed faster by fPMC. The
two tools were each able to analyse faster a subset of the
pDTMCs with numbers of parameters in the range 21 . . . 30,
though Storm timed out before completing the analysis of
several of these models. Further decomposing this set of
pDTMCs into smaller ranges (e.g., between 21 . . . 25 and
26 . . . 30 parameters) does not yield a better separation
into models handled faster by the two tools. As such, the
comparison summarised in Figure 8 suggests that setting
the threshold β to a value between 21 and 30 is likely to
work well. While this rule of thumb may not always apply,
we note that adopting it is never going to cause a problem:
in borderline cases, one can easily analyse a pDTMC using
both PMC tools.

6.2.2 RQ2 (Result complexity)

For each of our three case studies and experiments pre-
sented in the previous section, we compared the number
of arithmetic operations from the PMC formulae generated
by fPMC, Storm and PRISM, and the time required to
evaluate the fPMC and Storm formulae in MATLAB on the
computer with the speciﬁcation from Section 6.1. We only
considered Storm in the latter comparison because Storm
completed signiﬁcantly more PMC analyses than PRISM in
our experiments (92 versus 55 out of a total of 186 analyses).

FX system. The sizes of the FX PMC formulae produced
by fPMC, Storm and PRISM are shown in Figure 9. With

one exception (for property P3 of the pDTMC variant with
ID 1), fPMC generated formulae with signiﬁcantly fewer
operations than the other model checkers. This difference
increases quickly for larger and more complex models, with
an extreme case (for property P1 of the pDTMC variant with
ID 13) in which the formulae obtained by fPMC contain over
225 times fewer operations than the Storm PMC formula
(i.e., 2629 versus 593426 operations).

The MATLAB evaluation times for the PMC formulae
produced by Storm and fPMC are reported (for the analyses
completed by Storm) in Table 7. For the simplest models
(e.g., pDTMC variants 1 and 10) all evaluations can be
carried out within a few milliseconds. However, when the
complexity of the model increases, the evaluation of the
fPMC formulae is signiﬁcantly faster than that of the Storm
formulae. This is particularly noticeable for the pDTMC
variants corresponding to the PROB service-combination
strategy, e.g., the evaluation of the P2 property of pDTMC
variant 13 took over 7500s when the Storm formula was
used compared to only 16ms when the fPMC formulae were
used. Even for pDTMC variants for which Storm completed
the analysis faster than fPMC (e.g., those with IDs 2, 6, 10
and 11, cf. Table 4), the Storm PMC formulae are orders
of magnitude larger than those computed by fPMC, and
therefore they require much longer time to evaluate.

PL system. Figure 10 shows the PMC formula sizes gen-
erated by the three model checkers for the PL system. As
expected, with a gradual increase of parametric transitions
(i.e., the percentage of pDTMC transitions probabilities

05101520pDTMC variant ID102104106Number of operationsfPMCStormPRISM05101520pDTMC variant ID102104106Number of operationsfPMCStormPRISM05101520pDTMC variant ID102104106Number of operationsfPMCStormPRISM05101520pDTMC variant ID102104106Number of operationsfPMCStormPRISM16

(a) property reachability

(b) property unbounded until

Fig. 10: Number of operations in the PMC formulae for the PL pDTMC variants and properties from Table 5, with the
values corresponding to the system with the same number of features joined by continuous lines to improve readability

TABLE 8: MATLAB evaluation time for the PL PMC formu-
lae (in seconds)

pDTMC variant

Reachability

Unbounded until

ID

#F

%PAR

fPMC

Storm

fPMC

Storm

1
2
3
4
5

11
12
13
14
15
16

21
22
23
24
25

31
32
33
34

4

16

18

22

10
20
30
40
50

10
20
30
40
50
60

10
20
30
40
50

10
20
30
40

5.5
6.4
7.1
7.2
11.4

1.6
21.3
22.7
23.1
33.1
33.9

1.5
1.5
1.9
1.9
2.2

116.1
160.4
165.3
122.1

0.001
0.002
0.06
3.4
1635.7

<1ms
0.05
0.8
2.5
215.9
4188.8

0.001
0.001
0.1
14.7
17113.7

0.001
0.005
2.3
6049.8

5.8
6.1
6.7
6.6
10.4

2.2
6.1
6.1
6.2
9.2
9.4

2.2
2.4
2.7
3.1
3.2

106.2
142.2
145.9
153.1

0.001
<1ms
0.07
3.7
1214.1

<1ms
0.02
0.2
0.7
68.2
659.9

<1ms
0.001
0.1
15.4
16959

0.001
0.005
2.1
5992.3

growing from 10% to 100%) in each model variant, larger
algebraic formulae are obtain across all three model check-
ers, with exponential growth for the formulae computed by
Storm and PRISM, neither of which can handle the pDTMC
variants with over 60% of their transition probabilities spec-
iﬁed as parameters.

For simpler pDTMC variants (i.e., those with up to 40%
of their transitions speciﬁed as probabilities), the Storm and
PRISM formulae have signiﬁcantly fewer operators than the
fPMC formulae. We investigated this unexpected result, and
found it to be due to a large number of parameters in the
fPMC abstract pDTMC model: one such parameter for each
probability probz of reaching an output state z of a fPMC
fragment, as described in Section 2.3. As such, the fPMC
abstract models generated from the pDTMC variants with
between 10–40% parametric transition probabilities end up
with more probz parameters than the PL pDTMC variants
they are obtained from. However, for these pDTMCs vari-
ants, many of the fPMC fragments contain no or only a
few PL parameters, and therefore multiple or even all probz
parameters for these fragments are in fact constant proba-
bilities. We carried out separate experiments in which the

Fig. 11: Number of operations in the PMC formulae for
the COM pDTMC and properties from Table 6; Storm
and PRISM computed PMC formulae for several additional
properties, but the multi-megabyte ﬁles required to store
these extremely large formulae (which are available on our
project website) were difﬁcult to process, so their numbers
of operations are not provided in the diagram

constant values of such probz parameters were used in the
abstract fPMC model instead of these parameters, and the
size of the resulting fPMC formulae became similar to that of
the Storm and PRISM formulae for these pDTMC variants.
Given these ﬁndings, we plan to include this simpliﬁcation
in the next version of our fPMC tool.

A similar trend can be observed in the MATLAB eval-
uation time for the PL PMC formulae (Table 8). For the
formulae derived for the pDTMC variants with up to 30%
parametric transitions, the Storm formulae can be evaluated
within milliseconds, while the evaluation of the fPMC for-
mulae takes seconds (for the pDTMC variants modelling PL
instances with four and 18 features), tens of seconds (for
pDTMC variants modelling PL instances with 16 features)
or even more than 100s (or pDTMC variants modelling PL
instances with 22 features). Again, this difference is due to
fPMC operating with abstract models with unnecessarily
many parameters, and can be resolve through the simpli-
ﬁcation explained earlier. For pDTMC variants with over
40% parametric transitions, the fPMC formulae are consis-
tently and increasingly much faster to evaluate than those
produced by Storm and PRISM, or these model checkers do
not complete the PMC within 60 minutes.

1510152025303540pDTMC variant ID100102104106Number of operationsfPMCStormPRISM1510152025303540pDTMC variant ID100102104106Number of operationsfPMCStormPRISM15101520property ID100102104106Number of operationsfPMCStormPRISMTABLE 9: MATLAB evaluation time for the COM process PMC formulae (in seconds)

17

Property ID

fPMC
Storm

1

29

2

33

3

15

4

5

6

35 35 15
1

7

33

8

17

9

19

0.02 0.001 0.01 0.008

2 156 330 24528 14042

10 11 12 13 14 15 16 17 18 19 20 21

34 35 38 41 42 36 35 35 42 36 33 30
*

*

*

*

*

*

*

*

*

*

*

*PMC formula failed to be evaluated in MATLAB using the experimental machine in a 7-hour timeout

COM process. As shown in Figure 11, the PMC formula
sizes generated by fPMC, Storm and PRISM for the COM
process follow a pattern similar to that obtained for the
PL system. Thus, for the simplest properties (i.e., those
with IDs between 1 and 5), the sizes for the Storm and
PRISM formulae are much smaller than those of the fPMC
formulae; this is for the reason explained in our earlier dis-
cussion of the PL system results. However, as the analysed
properties become more complex (i.e., because longer paths
are required to reach the states from the reachability PCTL
formulae), the number of operations from the Storm and
PRISM formulae grows exponentially. In contrast, the size
of the fPMC-computed formulae remains relatively stable
with the increased complexity of the properties.

The MATLAB evaluation times for the Storm PMC for-
mulae (Table 9) are again increasing exponentially from a
few millisecond for properties 1–4 to tens of thousands of
seconds for properties 9 and 10, with MATLAB unable to
complete the evaluation before a seven-hour timeout for
properties 11–21. MATLAB, however, managed to evaluate
all formulae produced by fPMC within at most 42s.

Discussion. The complexity of the PMC formulae (i.e., their
number of arithmetic operations) in our three case studies
increased with the complexity of the analysed pDTCM and
PCTL property. For the Storm and PRISM formulae, this
increase was exponential for all case studies (cf. Figures 9,
10, and 11). In contrast, the complexity of fPMC formulae
increased relatively little for the PL and COM case studies,
and exponentially—but at a signiﬁcantly slower rate than
for the Storm and PRISM formulae—for the FX system. For
low complexity PL and COM model-property combinations,
Storm and PRISM computed PMC formulae with fewer
operations than fPMC. This was an unexpected behaviour
that we investigated and explained in the analysis of the
FX experiments, and for which we proposed a ﬁx (to be
implemented in the next version of our fPMC tool).

The MATLAB evaluation time reﬂects the complexity of
the PMC formulae generated by the three model checkers.
The evaluation of the fPMC formulae took milliseconds
for the FX system, up to 165s for the most complex PL
model-property combination, and up to 42s for the COM
process. In contrast, the evaluation time for the PMC formu-
lae generated by Storm (for the subset of model-property
combinations that the model checker could analyse within
3600s) increased very rapidly with the complexity of these
formulae—from milliseconds for the simplest formulae to
several hours for the complex ones. The much faster eval-
uation made possible by fPMC is highly beneﬁcial, as it
allows the parametric model checking of systems of far
greater complexity than previously possible. Furthermore,
self-adaptive systems that use parametric model checking
(e.g., [25], [26]) can leverage the simpler fPMC formulae
to perform their runtime decision-making much faster, and

with signiﬁcantly lower CPU overheads.

6.2.3 RQ3 (Conﬁgurability)

We evaluated the impact of varying the fPMC fragmentation
threshold α on: (1) the fPMC execution time, and (2) the
number of operations in the resulting algebraic formulae.
To that end, we randomly selected one pDTMC model–
reachability property combination from each of our three
case studies, and we performed its fPMC analysis for all
possible values of α (i.e., from 1 to the maximum number
of states in the analysed pDTMC). The results of these
experiments are summarised in Fig. 12.

FX system. Figures 12a and 12d show the results from
the analysis of the reachability property of FX pDTMC
variant 19, which has 35 states. fPMC completed the analysis
successfully within 60 minutes for 1 ≤ α ≤ 32. For small α
values (α < 10), the time spent checking the abstract model
was higher than that required to analyse the fragments.
This is because smaller α values often lead to a larger
abstract model by limiting the size of each fragment, and
therefore increasing the number of fragments. For α ≥ 10,
each fragment was allowed to grow larger, resulting in
abstract models with fewer states. As a result, the time
spent checking the abstract model decreases (and the time
spent checking the fragments grows) with the increase of α.
For α ≥ 32, fPMC could not complete the analysis of its
ﬁrst fragment within the 60-minute timeout. This indicates
that a single fragment can become too large and complex
(as a result of α being too large) to be handle by the
model checker that fPMC uses for the analysis of individual
fragments (i.e., Storm). The same pattern can be observed in
the size of the obtained closed-form formulae: their numbers
of operations increase in the fragments but decrease in the
abstract model with the increase of α. A mid-range α value
of between 10 and 20 minimises both the fPMC execution
time and the complexity of the generated formulae.

PL system. Figures 12b and 12e show the results for the
analysis of the reachability property of PL pDTMC variant
30. This pDTMC has 104 states, and fPMC completed its
analysis within 60 minutes for all α values between 4 and
104. For 1 ≤ α ≤ 3, fPMC timed out in the analysis of the
abstract model, which was too complex. For α > 3 but still
relatively small (i.e., 4 ≤ α ≤ 8), the time spent analysing
the abstract model is higher than that required to analyse the
fragments—and the sizes of the fPMC algebraic formulae
follow a similar pattern. As α increases further, a similar
trend to that from Figure 12a can be observed: the abstract
model analysis time starts to decrease, and the fragment
analysis goes up. However, increasing α beyond 10 has no
noticeable impact on the analysis time and formula size.
This is due to the fact that fPMC partitions this pDTMC into
fragments of up to 10 states “naturally”, meaning that the

18

(a) Execution Time (ID 19, FX system)

(b) Execution Time (ID 30, PL system)

(c) Execution Time (ID 19, COM process)

(d) Formulae size (ID 19, FX system)

(e) Formulae size (ID 30, PL system)

(f) Formulae size (ID 19, COM process)

Fig. 12: fPMC execution time for (a) the reachability property of FX pDTMC variant 19, (b) the reachability property of PL
variant 30, and (c) reachability property 19 of the COM pDTMC; and fPMC formula complexity (i.e., number of operations)
for the same pDTMC-property combinations of (d) the FX system, (e) the PL system, and (f) the COM process.

forced fragment termination from line 17 of Algorithm 1 is
not exercised for α > 10. As a consequence, the abstract
model remains relatively complex even for large α values,
and—irrespective of the value of α—the vast majority of the
operations from the fPMC formulae for the PL reachability
property come from the abstract model formula.

COM process. Figures 12c and 12f show the results for the
analysis of reachability property 19 of the COM pDTMC
model. This pDTMC has 234 states, and fPMC completed
the analysis successfully for all possible values of α, i.e., 1 ≤
α ≤ 234. Similar to the FX and PL experiments, increasing
α led to lower analysis times and fewer formula operations
for the abstract model, but resulted in higher analysis times
and more formula operations for the fragments. As for the
FX system, an intermediate α value (of between 30–70 in
this case) yields the lowest total analysis time and number
of operations.

Discussion. The fragmentation threshold α serves as a soft
upper bound for deciding whether fPMC should continue
model traversal (adding further states to its stack, cf. line 14
of Algorithm 1) or invoke fragment termination by forcing
the currently analysed state to become an output fragment
state (cf. line 16 of Algorithm 1). The experiments sum-
marised in Figure 12 suggest that the selection of optimal α

values depends on many factors, including pDTMC struc-
ture and number of states. Trying all the possible values of
α as what we did here is impractical. Thus, the determina-
tion of optimal α values (other than by exhaustive search)
remains an open research question. Nevertheless, this result
suggests useful rules of thumb for the selection of suitable
α values. First, adopting a default α value of between 10–30
is likely to produce good results (by guiding fPMC to create
abstract models with at least one order of magnitude fewer
state than the original pDTMC). Second, increasing α may
help if the time to analyse the abstract model is too high
(or the formula produced by this analysis is too complex);
conversely, decreasing α may help if the time to analyse
one of the fragments is too high (or the formulae from the
fragment analyses are too complex). Used in conjunction
with hill climbing [46], the latter thumb rule could enable
the optimisation of the threshold α, e.g., to ensure that
fPMC yields formulae with the lowest number of operations
possible.

7 THREATS TO VALIDITY

Construct validity threats. These threats may be caused by
over-simpliﬁcations and invalid assumptions made during
in devising the evaluation experiments. To avoid them, we

05101520253035,100101102103104Time (seconds)Time (fragments)Time (abstract model)Time in total020406080100,101102Time (seconds)Time (fragments)Time (abstract model)Time in total04080120160200240,100101102Time (seconds)Time (fragments)Time (abstract model)Time in total05101520253035,100102104106Number of operations#OP (fragments)#OP (abstract model)#OP in total0102030405060708090100,103104105106Number of operations#OP (fragments)#OP (abstract model)#OP in total04080120160200240,100102104106108Number of operations#OP (fragments)#OP (abstract model)#OP in total19

carried out the evaluation of fPMC by using case studies
based on two software systems and a communications
process that are freely available from other published soft-
ware engineering projects. Furthermore, the pDTMCs and
properties evaluated in our paper were also used in related
research [15], [17], [30], [33], [38].

PMC technique) operate on the entire pDMTC under analy-
sis [5], [29], [36], and those which (like our fPMC approach)
operate by partitioning this pDTMC into components that
are then analysed individually [15], [41]. We term these
classes of approaches standard PMC and compositional
PMC, respectively.

Internal validity threats. To avoid these threats—which
could introduce bias in the identiﬁcation of cause-effect
relationships in our experiments—we evaluated fPMC by
answering three independent research questions (cf. Sec-
tion 6.1). To further mitigate the potential bias, the evalua-
tion results were compared against the leading probabilistic
model checkers Storm [21] and PRISM [42]. In addition,
we performed the evaluation using multiple variants of the
systems from our case studies, and the correctness of each
result produced by fPMC was individually checked using
the approach described in Section 6.1. Finally, we published
the source code and data from our experiments online, in
order to allow the replication and veriﬁcation of our results.

External validity threats. These threats could affect the
generalisability of our ﬁndings. As summarised in Table 3,
we mitigated them in our evaluation by applying fPMC
to three types of systems (i.e., service-based systems [2],
[48], software product lines [4], [18], and communication
processes [22], [23]) taken from different application do-
mains. Moreover, we used multiple model variants and
properties, allowing us to test our approach on a wide
range of pDTMC structures and sizes, and thus to show that
fPMC provides consistently better performance in terms
of faster computation time, fewer arithmetic operations in
the derived algebraic formulae, and faster evaluation of
these formulae than the model checkers PRISM and Storm
for complex models. Finally, we eased the use of fPMC
in practice by providing tool support for our approach.
However, additional experiments are needed to conﬁrm that
fPMC is applicable to a wider range of pDTMC models and
to other application domains.

8 RELATED WORK

Parametric model checking (PMC) was ﬁrstly introduced
by Daws [19] less than two decades ago. The technique
enables the analysis of a DTMC when some or all of its tran-
sition probabilities are speciﬁed as rational functions over
the parameters of the modelled system. PMC produces an
algebraic formula for each analysed property. Such formulae
are used in the design and veriﬁcation of software systems,
e.g., to compare alternative system designs [32], [33], to
dynamically evolve the conﬁguration of self-adaptive soft-
ware [14], [20], [25], [26], and for system parameter analysis
and synthesis [10], [11], [27], [34]. Despite this wide adop-
tion, the computationally intensive nature of PMC limits
the scalability and applicability of the multiple software
engineering methods that rely on it.

To the best of our knowledge, the research aimed at
improving the efﬁciency of PMC is limited to the approaches
proposed in [5], [15], [29], [36], [41]. For the purpose of
comparing these approaches to fPMC, we consider them
organised into two classes: those which (like Daws’ original

Standard PMC approaches. The ﬁrst class of PMC ap-
proaches are complementary to our work. Any of them
can be used in conjunction with fPMC, to ensure that the
individual probabilistic model checking of the fPMC frag-
ments and fPMC abstract model is carried out efﬁciently.
We summarise these approaches below.

In comparison to Daws’ initial PMC technique [19], the
technique proposed by Hahn et al. [36] yields a signiﬁcant
improvement in PMC performance. Both PMC approaches
derive an algebraic formula for the probability of reaching
a set of parametric Markov chain states speciﬁed in a PCTL
path formula. However, instead of computing a regular
expression by exploiting the pDTMC structure as in [19],
the PMC technique from [36] produces a rational expression
and leverages symmetry and “cancellation” properties of
rational formulae to simplify this expression. The cancel-
lation involves computing the greatest common divisor
(GCD) of the denominator and numerator polynomials of
the rational PMC formula, and using this GCD polynomial
to simplify the formula. The model checkers PARAM [35]
and PRISM [42] implement this technique.

According to our classiﬁcation, Jansen et al. [41] propose
a hybrid PMC approach, and we discuss its PMC “com-
ponents” separately. The standard PMC component of [41]
consists of sophisticated partial polynomial factorisations
that support the efﬁcient simpliﬁcation of large PMC ratio-
nal expressions. This PMC approach is implemented by the
parametric model checker Storm [21].

More recently, Baier et al. [5] have introduced a new
technique for obtaining simpliﬁed PMC formulae. This tech-
nique avoids the computationally expensive calculation of
GCD polynomials (which the PMC approaches from [36],
[41] rely on) by leveraging fraction-free Gaussian elimi-
nation, which is an existing efﬁcient method for solving
systems of parametric linear equations. This method is
implemented in the Storm model checker.

A different type of approach to speeding up PMC is
proposed by Gainer et al. [29]. This approach involves the
stepwise elimination of the states of the analysed pDTMC,
through a process that resembles the mapping of ﬁnite
automata to regular expressions. The outcome of this elimi-
nation is a directed acyclic graph encoding of the PMC result
instead of the usual rational formula produced by other
PMC techniques. The authors’ evaluation of the approach
(implemented in their ePMC/ISCASMC model checker [37])
shows that it can outperform the formula-based PMC en-
gine used by PRISM by up to two orders of magnitude.

Compositional PMC approaches. These approaches oper-
ate in a similar way to fPMC. As such, we will compare
each of them to our work.

The PMC approach devised by Jansen et al. [41] im-
proves the efﬁciency of parametric model checking by
decomposing the state transition graph induced by the
pDTMC under analysis into strongly connected components

(SCCs). PMC expressions are then computed independently
for each SCC, and then combined to obtain the ﬁnal PMC
output in the form of a single rational formula over the
parameters of the system modelled by the pDTMC. Because
it is predetermined by the SCCs of the analysed pDTMC,
this decomposition (which is implemented by the paramet-
ric model checker Storm) is very rigid. In particular, it may
produce SCCs that are too large to be analysed efﬁciently,
and that cannot be further decomposed. In contrast, the
fPMC fragmentation of a pDTMC is much more ﬂexible. The
analysed pDTMC is partitioned into fragments whose size is
guided by the fragmentation threshold α. These fragments
can include one or more small SCCs. Most importantly,
fPMC can split any SCCs that are too large to be analysed
individually into multiple fragments. The experimental re-
sults from Section 6 provide ample evidence about the
beneﬁts of this ﬂexible pDTMC partitioning. Furthermore,
the fPMC fragmentation can, in theory, be applied repeat-
edly, e.g., to partition a large fragment into sub-fragments
(although this still has to be conﬁrmed experimentally).

The fPMC theoretical foundation comprises two comple-
mentary parts. The ﬁrst part, which we introduced in [15],
deﬁnes the method for using pDTMC fragments to speed
up parametric model checking—but does not provide any
method for partitioning a pDTMC into fragments. There-
fore, the solution from [15] can only be applied when its
users are able to exploit domain knowledge in order to
manually specify the fragments of the analysed pDTMC.
This limitation represents a signiﬁcant barrier for the practi-
cal adoption of fragmentation-based PMC. The second part
of the fPMC theoretical foundation, which is introduced in
this paper and complements our results from [15], removes
this barrier by providing a tool-supported method for the
automated fragmentation of pDTMCs.

9 CONCLUSION

We presented fPMC, a tool-supported technique for compo-
sitional parametric model checking. fPMC supports the ef-
ﬁcient analysis of reachability, unbounded until and reacha-
bility reward properties of parametric discrete-time Markov
chains by automatically partitioning these models into frag-
ments that can be analysed independently. The results of
these analyses are then combined into a system of closed-
form algebraic expressions that represent the solution of the
initial parametric model checking problem.

To evaluate fPMC, we used it to analyse 28 PCTL proper-
ties of 62 pDTMC variants modelling three types of software
systems (i.e., service-based systems, software product lines,
and middleware) from different application domains. The
experimental results show that fPMC can analyse pDTMCs
with over 10–20 parameters much faster than previous PMC
techniques, and—in many cases—when these techniques
cannot complete their analyses within 60 minutes on a
standard computer. Furthermore, our evaluation showed
that the algebraic expressions generated by fPMC for such
models comprise considerably fewer operations and are
much faster to evaluate than those produced by previous
PMC techniques.

In future work, we will explore several opportunities for
extending the applicability and efﬁciency of fPMC. First,

20

we will examine the possibility to apply fPMC fragmen-
tation repeatedly, to partition pDTMC fragments that may
be too large or too complex to analyse as a whole into
sub-fragments. This opportunity, which is unique to our
compositional PMC technique, has the potential to support
the analysis of complex pDTMCs that cannot be handled by
any existing model checkers.

Second, we aim to enhance the fPMC fragmentation
algorithm with the ability to generate close-to-optimal frag-
ments, i.e., fragments that: (i) are non-trivial in terms of
structure, size and number of parameters; (ii) can be anal-
ysed efﬁciently; and (iii) produce PMC expressions of ac-
ceptable complexity. One option for obtaining such frag-
ments is to adapt the fPMC fragmentation threshold to the
characteristics of the fragment under construction.

Last but not least, we plan to improve our fPMC tool. In
particular, we will implement the simpliﬁcation identiﬁed
in Section 6.2.2. To that end, we will update the fPMC
tool to ensure that abstract model parameters associated
with constant-valued fragment reachability properties are
replaced with the actual values of those properties. Addi-
tionally, we will explore options for selecting an effective
PMC technique (e.g., standard or compositional) for the
analysis of a given pDTCM, pDTMC fragment or pDTMC
strongly connected component, paving the way for the
development of a highly efﬁcient hybrid parametric model
checker that uses the available PMC techniques together.

ACKNOWLEDGEMENTS
This project has received funding from the UKRI project
EP/V026747/1 ‘Trustworthy Autonomous Systems Node in
Resilience’, and the ORCA-Hub PRF project ‘COVE’. The
authors are grateful to the research groups who have devel-
oped the EPMC/IscasMC, PARAM, PRISM and Storm prob-
abilistic and parameteric model checkers: our work would
not have been possible without the signiﬁcant theoretical
advances and tools introduced by these research groups.

CREDIT AUTHORSHIP CONTRIBUTION STATEMENT
Xinwei Fang: Conceptualization, Investigation, Methodol-
ogy, Software, Validation, Visualization, Writing – original
draft. Radu Calinescu: Conceptualization, Formal Analysis,
Funding Acquisition, Investigation, Methodology, Super-
vision, Validation, Visualization, Writing – original draft,
Writing – review & editing. Simos Gerasimou: Concep-
tualization, Funding Acquisition, Investigation, Methodol-
ogy, Software, Supervision, Visualization, Writing – original
draft. Faisal Alhwikem: Methodology, Software.

REFERENCES

[1] N. Alasmari, R. Calinescu, C. Paterson, and R. Mirandola, “Quan-
titative veriﬁcation with adaptive uncertainty reduction,” Journal
of Systems and Software, vol. 188, no. 111275, 2022.

[3]

[2] D. Ameller, M. Galster, P. Avgeriou, and X. Franch, “A survey
on quality attributes in service-based systems,” Software quality
journal, vol. 24, pp. 271–299, 2016.
S. Andova, H. Hermanns, and J. P. Katoen, “Discrete-time rewards
model-checked,” in International Conference on Formal Modelling and
Analysis of Timed Systems (FORMATS). Springer, 2003, pp. 88–104.
S. Apel, D. Batory, C. K¨astner, and G. Saake, Feature-oriented
software product lines. Springer, 2016.

[4]

[6]

[5] C. Baier, C. Hensel, L. Hutschenreiter, S. Junges, J. P. Katoen,
and J. Klein, “Parametric Markov chains: PCTL complexity and
fraction-free Gaussian elimination,” Information and Computation,
vol. 272, no. 104504, 2020.
S. Balsamo, V. De Nitto Person`e, and P. Inverardi, “A review
on queueing network models with ﬁnite capacity queues for
software architectures performance prediction,” Performance Eval-
uation, vol. 51, pp. 269–288, 2003.
S. Balsamo, P. G. Harrison, and A. Marin, “Methodological con-
struction of product-form stochastic Petri nets for performance
evaluation,” Journal of Systems and Software, vol. 85, pp. 1520–1539,
2012.

[7]

[8] A. Bianco and L. de Alfaro, “Model checking of probabilistic and
nondeterministic systems,” in Foundations of Software Technology
and Theoretical Computer Science (FST&TCS).
Springer, 1995, pp.
499–513.

[9] R. Calinescu, “Emerging techniques for the engineering of self-
adaptive high-integrity software,” Assurances for Self-Adaptive Sys-
tems, pp. 297–310, 2013.

[10] R. Calinescu, M. Autili, J. C´amara, A. Di Marco, S. Gerasimou,
P. Inverardi, A. Perucci, N. Jansen, J. P. Katoen, M. Kwiatkowska,
O. J.Mengshoel, R. Spalazzese, and M. Tivoli, “Synthesis and ver-
iﬁcation of self-aware computing systems,” Self-Aware Computing
Systems, pp. 337–373, 2017.

[11] R. Calinescu, M.

ˇCeˇska, S. Gerasimou, M. Kwiatkowska, and
N. Paoletti, “Efﬁcient synthesis of robust models for stochastic
systems,” Journal of Systems and Software, vol. 143, pp. 140–158,
2018.

[12] R. Calinescu, C. Ghezzi, K. Johnson, M. Pezz´e, Y. Raﬁq, and
G. Tamburrelli, “Formal veriﬁcation with conﬁdence intervals to
establish quality of service properties of software systems,” IEEE
Transactions on Reliability, vol. 65, no. 1, pp. 107–125, 2016.

[13] R. Calinescu, K. Johnson, and C. Paterson, “FACT: A probabilistic
model checker for formal veriﬁcation with conﬁdence intervals,”
in International Conference on Tools and Algorithms for the Construc-
tion and Analysis of Systems (TACAS), 2016, pp. 540–546.

[14] R. Calinescu and M. Kwiatkowska, “Cads*: Computer-aided de-
velopment of self-* systems,” in International Conference on Funda-
mental Approaches to Software Engineering (FASE).
Springer, 2009,
pp. 421–424.

[15] R. Calinescu, C. Paterson, and K. Johnson, “Efﬁcient parametric
model checking using domain knowledge,” IEEE Transactions on
Software Engineering, vol. 47, pp. 1114–1133, 2021.

[16] F. Ciesinski and M. Gr ¨oßer, “On probabilistic computation tree
logic,” Validation of Stochastic Systems, vol. 2925, pp. 147–188, 2004.
[17] A. Classen, P. Heymans, P.-Y. Schobbens, A. Legay, and J. F. Raskin,
“Model checking lots of systems: efﬁcient veriﬁcation of temporal
properties in software product lines,” in International Conference on
Software Engineering (ICSE), 2010, pp. 335–344.

[18] P. Clements and L. Northrop, Software product lines. Addison

Wesley, 2002.

[19] C. Daws, “Symbolic and parametric model checking of discrete-
time Markov chains,” in First International Conference on Theoretical
Aspects of Computing (ICTAC), 2005, pp. 280–294.

[20] R. De Lemos, D. Garlan, C. Ghezzi, H. Giese, J. Andersson,
M. Litoiu, B. Schmerl, D. Weyns, L. Baresi, N. Bencomo et al., “Soft-
ware engineering for self-adaptive systems: Research challenges in
the provision of assurances,” Software Engineering for Self-Adaptive
Systems III. Assurances, vol. 9640, pp. 3–30, 2018.

[21] C. Dehnert, S. Junges, J. P. Katoen, and M. Volk, “A storm is
coming: A modern probabilistic model checker,” in International
Conference on Computer Aided Veriﬁcation (CAV), R. Majumdar and
V. Kunˇcak, Eds., 2017, pp. 592–600.

[22] F. Dressler and O. B. Akan, “Bio-inspired networking: from theory
to practice,” IEEE Communications Magazine, vol. 48, pp. 176–183,
2010.

[23] ——, “A survey on bio-inspired networking,” Computer Networks,

vol. 54, pp. 881–900, 2010.

[24] X. Fang, R. Calinescu, S. Gerasimou, and F. Alhwikem, “Fast
parametric model checking through model fragmentation,” in
International Conference on Software Engineering (ICSE).
IEEE, 2021,
pp. 835–846.

[25] A. Filieri, C. Ghezzi, and G. Tamburrelli, “Run-time efﬁcient prob-
abilistic model checking,” in International Conference on Software
Engineering (ICSE), 2011, pp. 341–350.

21

[26] A. Filieri and G. Tamburrelli, “Probabilistic veriﬁcation at runtime
for self-adaptive systems,” Assurances for Self-Adaptive Systems, vol.
7740, pp. 30–59, 2013.

[27] A. Filieri, G. Tamburrelli, and C. Ghezzi, “Supporting self-
adaptation via quantitative veriﬁcation and sensitivity analysis at
run time,” IEEE Transactions on Software Engineering, vol. 42, pp.
75–99, 2015.

[28] G. Franks, T. Al-Omari, M. Woodside, O. Das, and S. Derisavi, “En-
hanced modelling and solution of layered queueing networks,”
IEEE Transactions on Software Engineering, vol. 35, pp. 148–161,
2009.

[29] P. Gainer, E. M. Hahn, and S. Schewe, “Accelerated model check-
ing of parametric markov chains,” in International Symposium on
Automated Technology for Veriﬁcation and Analysis (ATVA). Springer,
2018, pp. 300–316.

[30] S. Gerasimou, G. Tamburrelli, and R. Calinescu, “Search-based
synthesis of probabilistic models for quality-of-service software
engineering,” in International Conference on Automated Software
Engineering (ASE), 2015, pp. 319–330.

[31] S. Gerasimou, R. Calinescu, and G. Tamburrelli, “Synthesis of
probabilistic models for quality-of-service software engineering,”
Automated Software Engineering, vol. 25, pp. 785–831, 2018.

[32] C. Ghezzi and A. M. Shariﬂoo, “Verifying non-functional proper-
ties of software product lines: Towards an efﬁcient approach using
parametric model checking,” in International Software Product Line
Conference (SPLC).
IEEE, 2011, pp. 170–174.

[33] ——, “Model-based veriﬁcation of quantitative non-functional
properties for software product lines,” Information and Software
Technology, vol. 55, pp. 508–524, 2013.

[34] E. M. Hahn, T. Han, and L. Zhang, “Synthesis for PCTL in
parametric markov decision processes,” in NASA formal methods
symposium (NFM). Springer, 2011, pp. 146–161.

[35] E. M. Hahn, H. Hermanns, B. Wachter, and L. Zhang, “PARAM:
A model checker for parametric Markov models,” in International
Conference on Computer Aided Veriﬁcation (CAV), 2010, pp. 660–664.
[36] E. M. Hahn, H. Hermanns, and L. Zhang, “Probabilistic reach-
ability for parametric Markov models,” International Journal on
Software Tools for Technology Transfer, vol. 13, no. 1, pp. 3–19, 2011.
[37] E. M. Hahn, Y. Li, S. Schewe, A. Turrini, and L. Zhang, “ISCASMC:
A web-based probabilistic model checker,” in Formal Methods
(FM), 2014, pp. 312–317.
[38] M. Hajnal, M. Nouvian, D.

ˇSafr´anek, and T. Petrov, “Data-
informed parameter synthesis for population Markov chains,” in
International Workshop on Hybrid Systems Biology (HSB). Springer,
2019, pp. 147–164.

[39] H. Hansson and B. Jonsson, “A logic for reasoning about time and
reliability,” Formal Aspects of Computing, vol. 6, pp. 512–535, 1994.
[40] S. M. Hezavehi, D. Weyns, P. Avgeriou, R. Calinescu, R. Mirandola,
and D. Perez-Palacin, “Uncertainty in self-adaptive systems: a re-
search community perspective,” ACM Transactions on Autonomous
and Adaptive Systems, vol. 15, pp. 1–36, 2021.
[41] N. Jansen, F. Corzilius, M. Volk, R. Wimmer, E.

´Abrah´am, J. P.
Katoen, and B. Becker, “Accelerating parametric probabilistic ver-
iﬁcation,” in International Conference on Quantitative Evaluation of
Systems (QEST), 2014, pp. 404–420.

[42] M. Kwiatkowska, G. Norman, and D. Parker, “PRISM 4.0: Veriﬁca-
tion of probabilistic real-time systems,” in International Conference
on Computer Aided Veriﬁcation (CAV), 2011, pp. 585–591.

[43] C. Lindemann, “Performance modelling with deterministic and
stochastic Petri nets,” Performance Evaluation Review, vol. 26, no. 2,
1998.

[44] C. Paterson and R. Calinescu, “Observation-enhanced QoS anal-
ysis of component-based systems,” IEEE Transactions on Software
Engineering, vol. 46, pp. 526–548, 2018.

[45] D. Perez-Palacin and J. Merseguer, “Performance evaluation of
self-reconﬁgurable service-oriented software with stochastic Petri
nets,” Electronic Notes in Theoretical Computer Science, vol. 261, pp.
181–201, 2010.

[46] B. Selman and C. P. Gomes, “Hill-climbing search,” Encyclopedia of

cognitive science, vol. 81, p. 82, 2006.

[47] G. Su, D. S. Rosenblum, and G. Tamburrelli, “Reliability of run-
time quality-of-service evaluation using parametric model check-
ing,” in International Conference on Software Engineering (ICSE),
2016, p. 73–84.

[48] C. Sun, R. Rossing, M. Sinnema, P. Bulanov, and M. Aiello, “Mod-
eling and managing the variability of web service-based systems,”
Journal of Systems and Software, vol. 83, pp. 502–516, 2010.

