2
2
0
2

g
u
A
9

]
E
S
.
s
c
[

1
v
6
4
0
5
0
.
8
0
2
2
:
v
i
X
r
a

Interpolation and SAT-Based Model Checking Revisited:
Adoption to Software Veriﬁcation

Dirk Beyer

· Nian-Ze Lee

·

Philipp Wendler

Received: 2022-08-09

Abstract Interpolation-based model checking (McMillan, 2003) is a formal-veriﬁcation
algorithm, which was originally devised to verify safety properties of ﬁnite-state transition
systems. The algorithm is state-of-the-art in hardware model checking. It derives interpolants
from unsatisﬁable BMC queries, and collects them to construct an overapproximation of
the set of reachable states. Unlike other formal-veriﬁcation algorithms, such as k-induction
or PDR, which have been extended to handle inﬁnite-state systems and investigated for
program analysis, McMillan’s interpolation-based model checking algorithm from 2003 has
not been used to verify programs so far. This paper closes this signiﬁcant, 19 years old
gap in knowledge by adopting the algorithm to software veriﬁcation. We implemented it in
the veriﬁcation framework CPACHECKER, and evaluated the implementation against other
state-of-the-art software-veriﬁcation techniques over the largest publicly available benchmark
suite of C safety-veriﬁcation tasks. The evaluation demonstrates that interpolation-based
model checking is competitive among other algorithms in terms of both the number of solved
veriﬁcation tasks and the run-time efﬁciency. Our results might have important implications for
software veriﬁcation, because researchers and developers now have a richer set of approaches
to choose from.

Keywords Software veriﬁcation · Program analysis · Model checking · Interpolation ·
Interpolation-based model checking · CPAchecker · SMT · SAT

1 Introduction

Automatic software veriﬁcation [43] is an active research ﬁeld in which automated solutions
of the following problem are studied: Given a program and a speciﬁcation, decide whether
the program satisﬁes the speciﬁcation or not. In this paper, we focus on the veriﬁcation
of reachability-safety properties, asserting that some error location in the program should
never be reached by the control ﬂow. Other speciﬁcations, including termination, memory
safety, concurrency safety, and overﬂows, are also investigated in the literature. Although the
problem of software veriﬁcation is in general undecidable, many important concepts, including
various predicate-abstraction techniques [5, 36, 38, 42], counterexample-guided abstraction

LMU Munich, Germany

 
 
 
 
 
 
2

D. Beyer, N.-Z. Lee, and P. Wendler

1 extern int nondet();
2 int main(void) {

unsigned int x = 0;
while (nondet()) {

x += 2;

}
if (x % 2) {

ERROR: return 1;

}
return 0;

3

4

5

6

7

8

9

10
11 }

unsigned int x = 0;

l3

l4

[nondet()]

l5

[!nondet()]

x += 2;

l7

[x % 2]

l8

[!(x % 2)]

ERROR: return 1;

l10

return 0;

l11

(a) C program

(b) Control-ﬂow automaton

1: An

example C program (a)

Fig.
from
loop-invariants/even.c of the benchmark set of the 2022 Competition on
Software Veriﬁcation (SV-COMP ’22) [8])

its CFA (b)

(adopted

and

reﬁnement (CEGAR) [30], large-block encoding [10, 19], interpolation [41, 52], together with
the advances in SMT solving [7] and combinations with data-ﬂow analysis [14], make it
feasible to verify industry-scale software such as operating-systems code [4, 6, 22, 27, 32, 47].
To illustrate the reachability-safety veriﬁcation of a program, consider the C program
in Fig. 1a. The program ﬁrst initializes variable x to 0, and keeps incrementing x by 2
while the nondeterministic value returned from function nondet() is nonzero. Once the
nondeterministic value equals zero, the control ﬂow exits the loop and tests whether variable x
is odd. If variable x is odd, the control ﬂow reaches the error location at line 8; otherwise
the program terminates without errors. The goal of the reachability-safety veriﬁcation is to
either prove that the error location is unreachable by the control ﬂow, or ﬁnd an execution
path of the program reaching the error location.

As the veriﬁcation of ﬁnite-state transition systems and inﬁnite-state transition systems
share much similarity, some classic model-checking algorithms for software (inﬁnite-state
systems), such as bounded model checking (BMC) [23, 31] or k-induction [12, 34, 46], were
originally developed for hardware (ﬁnite-state systems). A well-known example of such
technology transfer is property-directed reachability (PDR) [25]. After it obtained huge
success in hardware model checking, many research efforts have been invested for its software-
veriﬁcation adoption [11, 24, 28, 45, 50].

1.1 Interpolation-Based Veriﬁcation Approaches

McMillan’s algorithm [51] from 2003 is another state-of-the-art approach for hardware
model checking, prior to the invention of PDR. It utilizes Craig interpolation [33] to derive
interpolants from unsatisﬁable BMC queries, and computes an overapproximation of the set of
reachable states as the union of the interpolants. Its idea of abstracting objects with interpolants
has been extended beyond state sets and underpinned various interpolation-based veriﬁcation
approaches and tools. Abstractions of transition relations [44], traces [39], predicates over

Interpolation and SAT-Based Model Checking Revisited

3

Abstraction with Craig Interpolation

State Set

Transition Relation

Trace

Predicate

Function

IMC

IMPACT

PDR

Interpolation-Sequence (ISB)

Fig. 2: Classiﬁcation of different abstractions using Craig interpolation

program variables [41], and function calls [56] have been studied in the literature. We classify
in Fig. 2 different usages of Craig interpolation and highlight several important algorithms
regarding state-set abstraction. An overview of several representative interpolation-based
formal-veriﬁcation approaches is provided in Sect. 2.

Despite its success in hardware model checking and profound theoretical impact on
program analysis, McMillan’s algorithm [51] from 2003 has not been investigated for software
veriﬁcation. We emphasize that McMillan’s interpolation-based algorithm for model checking
from 2003 should not be mistaken for other interpolation-based veriﬁcation approaches. In the
following, we refer to the algorithm proposed by McMillan from 2003 as interpolation-based
model checking and abbreviate it as IMC.

One potential concern to apply IMC to software, raised by its inventor McMillan in
his later paper [52] presenting the algorithm IMPACT, was the scalability of the underlying
decision procedure to handle the entire unrolled program. Compared to IMC, IMPACT derives
interpolants only for individual execution paths, reducing the workload of the solver. Fortu-
nately, due to the advancements in SMT solving, delegating formulas encoding the entire
unrolled program to the solvers has become feasible. Therefore, it is time to revisit IMC and
evaluate its performance against the state of the art. Other SMT-based approaches have been
thoroughly compared already in the literature [13].

1.2 Our Research Questions and Contributions

In this paper, we explore the applicability of the IMC algorithm to software veriﬁcation.
Speciﬁcally, we answer the following two research questions. First, we investigate how to
efﬁciently adopt IMC to software veriﬁcation. As mentioned earlier, IMC was originally
invented to verify sequential Boolean-logic circuits (hardware), whose transition relations,
required to perform IMC, are easy to derive: The downstream circuitry of the memory
elements (i.e., registers) encodes the next-state function of the system, which can then be
naturally expressed as a transition relation between system states. It is less straightforward, by
contrast, to extract a transition relation from a program (software). Although representing a
program as a transition relation with the program counter is possible, such conversion often
blows up the control-ﬂow structure, and in turn inﬂuences the computational efﬁciency of
veriﬁcation. To address this research question, we propose an efﬁcient software adoption
of IMC via large-block encoding, exploring the analogy between the execution paths of a
sequential Boolean-logic circuit and a program. We also present the ﬁrst implementation
of the IMC algorithm for software veriﬁcation, and make it available in the open-source
framework CPACHECKER. The details of the proposed adoption and implementation will be
discussed in Sect. 4. Our second research question focuses on evaluating the performance
of the IMC adoption against the state of the art. To address this research question, we

4

D. Beyer, N.-Z. Lee, and P. Wendler

compare the proposed implementation against other state-of-the-art software-veriﬁcation
algorithms, including PDR, BMC, k-induction, predicate abstraction, and IMPACT, over the
largest benchmark suite of C safety-veriﬁcation tasks in Sect. 5. Our experimental results
show that IMC is competitive in terms of both effectiveness (the number of solved tasks)
and efﬁciency (the elapsed CPU time).

Novelty. (1) This paper closes the 19 years old gap of knowledge by investigating the applica-
bility of IMC to software veriﬁcation. We analyze the characteristics of IMC in the context
of software veriﬁcation, and our empirical evaluation indicates its competitiveness against
the state-of-the-art approaches. (2) Our replication of the IMC algorithm as open-source
implementation broadens the spectrum of available software-veriﬁcation techniques, which
might have important implications in practice, because researchers, developers, and tool users
now have more choices at their disposal. (3) While the application of large-block encoding to
program analysis has a long history, to the best of our knowledge, using large-block encoding
to represent an algorithm originated from a different research community for software is a
new idea, which may shed light on the efﬁcient adoptions of other algorithms.

Signiﬁcance. IMC is an important veriﬁcation algorithm in hardware veriﬁcation. It is a risk to
leave the potential of it unleveraged for the veriﬁcation of software. Therefore, we believe that
the knowledge about the algorithm’s adoption to software is a signiﬁcant improvement of the
state of the art and has the potential to inspire other works in the area of software veriﬁcation.

Correctness. We show the correctness of our algorithms in Theorem 1. Our implementation
is based on components from the CPACHECKER framework, which is a well-maintained
software project with lots of evidence that the components work well. Large-block encoding
is a sound component from the literature.

The effectiveness and efﬁciency of our implementation is empirically evaluated with
experiments on a large benchmark set. We discuss possible threats to validity that might affect
the soundness of our conclusions from the experimental results.

2 Related Work

IMC has popularized the idea of using interpolation for veriﬁcation, and although IMC itself
has not been applied to software so far, there are many approaches for software veriﬁca-
tion that make use of interpolation. Based on the classiﬁcation in Fig. 2, we will discuss
several representative interpolation-based approaches and tools, as summarized in Table 1.
Interested readers are referred to the chapter [54] by McMillan in the Handbook of Model
Checking for a broader survey. Of course, there exist many techniques for computing inter-
polants. We do not discuss them here as interpolant computation is typically orthogonal to
the used veriﬁcation algorithm. In our implementation, we use an off-the-shelf SMT solver
for interpolation (MATHSAT5 [29]).

2.1 State Sets

The most closely related algorithm is IMPACT [52] from the same author, which is also
based on the idea of computing a ﬁxed point from interpolants, but applies interpolation to
formulas of single program paths instead of the whole program, generating one interpolant for
each step of a spurious counterexample. It also computes ﬁxed points of reachable states per

Interpolation and SAT-Based Model Checking Revisited

5

Table 1: Important interpolation-based formal-veriﬁcation approaches and tools

Approach

IMC

Year

2003

Predicate abstraction

2004

TR approximation

IMPACT

Slicing abstraction

ISB

2005

2006

2007

2009

Trace abstraction

2009

Lazy annotation

2010

Function summaries

2011

Software PDR

CTIGAR

BLAST

CPACHECKER

WOLVERINE

UFO

DUALITY

SPACER

SAFARI

2012

2014

2004

2004

2011

2012

2013

2013

2014

Publication

Contribution

[51]

[41]

[44]

[52]

[26]

[57]

[39]

[53]

[56]

[28]

[24]

[41]

[18]

[49]

[2]

[55]

[48]

[3]

First interpolation-based model-checking algorithm

Discovering relevant predicates
from interpolants to refute false alarms

Reﬁning an abstract TR with interpolants
to avoid exact image computation

Combining lazy abstraction with interpolants

Splitting abstract states with interpolants

Imitating BDD-based model checking by
abstracting states with interpolants

Reﬁning an overapproximation of
possible traces with interpolant automata

Annotating a program with interpolants
derived from Hoare triples

Summarizing function calls with interpolants
to reduce future analysis effort

Combining IMPACT-like proof-based interpolants
and PDR clause generation

Reﬁning abstraction failures
relative to single steps with interpolants

First software model checker using interpolation

Large-block encoding and interpolation

First public implementation of IMPACT

Combining predicate and interpolation methods

Solving constrained Horn clauses with interpolation

Combining proof-based approaches and CEGAR

Backward IMPACT-like analysis with arrays

program location instead of globally. One adaption of property-directed reachability (PDR) to
software [28] computes sequences of sets of clauses for refuting spurious counterexamples,
and these sequences also form a valid sequence of interpolants. Under this view, the approach
is similar to IMPACT, only differing in how the interpolants are computed. A hybrid approach
with a combination of proof-based interpolation (as in IMPACT) and PDR-based clause
generation has also been suggested. CTIGAR [24] is another attempt to extend PDR to
software. It combines Cartesian predicate abstraction with PDR and considers an abstract
state as a conjunction of the predicates satisﬁed by the corresponding concrete state. Different
from other adaptions of PDR, CTIGAR avoids expensive pre-image computation by focusing
on reﬁnement relative to single steps of the transition relation.

A related approach for hardware model checking is interpolation-sequence based model
checking (ISB) [57]. In contrast to IMC, which computes only one interpolant at a time that
overapproximates states reachable within a certain number of steps, ISB derives a sequence of
interpolants from an unsatisﬁable BMC query, and each interpolant is an overapproximation
of the states reachable within an increasing number of steps. This is similar to IMPACT, just
with ISB computing interpolant sequences for an unrolling of the whole transition relation
instead of single program paths like IMPACT. In ISB, the ﬁxed point is found if the interpolant
derived at the last unrolled loop head implies the disjunction of all previous interpolants.

The approach of lazy annotation [53] combines symbolic execution and interpolation to
generate Hoare-style annotations for a program in a similar way as a conﬂict-driven clause-
learning SAT solver. An annotation on a program edge is a condition that will block any

6

D. Beyer, N.-Z. Lee, and P. Wendler

future execution from this edge to an error location. The method symbolically executes the
input program along some chosen path to search for an error location. If the execution is
blocked by an edge, it backtracks and produces an annotation by interpolation, which is
a valid precondition of the edge’s Hoare triple. This method is also applicable to program
testing, because it explores only feasible traces.

2.2 Predicates, Traces, and Functions

Another popular use of interpolation for software veriﬁcation is to derive predicates from
interpolants for predicate abstraction [41] in the reﬁnement step of CEGAR, typically by
breaking up the interpolants into atomic predicates. In contrast to IMC and IMPACT, which
both create the ﬁnal abstract model of the program (the overapproximation of the set of
reachable states) directly from interpolants, predicate abstraction uses Boolean or Cartesian
abstraction over the set of derived predicates and may generalize better. Interpolation has
also been used to avoid the expensive exact image computation in predicate abstraction [44],
reﬁning an abstract transition relation to guarantee convergence given adequate predicates.
Slicing abstraction [26] is another technique related to predicate abstraction. It splits abstract
states using predicates obtained from Craig interpolants to reﬁne the abstraction.

Trace abstraction [39, 40] extends the concept of abstracting information by Craig interpo-
lation to representing program paths with interpolants. Given an unsatisﬁable BMC query, it
derives a sequence of interpolants and constructs an interpolant automaton out of them. This
interpolant automaton excludes spurious traces that share the same reason of infeasibility with
the current one. A novel counterexample-guided abstraction reﬁnement scheme is proposed
for trace abstraction to prove the correctness of a program.

Interpolants are also applied to summarize function calls in a program [56]. This approach
replaces function calls with interpolants obtained in a previous analysis to reduce the sub-
sequent veriﬁcation effort. Given an unsatisﬁable BMC query involving a function call, a
summary of the function is computed as an interpolant between the function’s corresponding
formula and the rest of the BMC formula.

2.3 Tools Based on Craig Interpolation

Several software-veriﬁcation tools are developed on top of Craig interpolation. The tool
BLAST [15, 41] provides the ﬁrst implementation of a software-veriﬁcation tool that uses
interpolants for computing abstractions. The veriﬁcation framework CPACHECKER [18]
applies Craig interpolation to large-block encodings of program code. The tool WOLVER-
INE [49] provides the ﬁrst publicly available implementation of IMPACT, featuring a built-in
interpolation procedure and some support for bit-vector operations. The framework UFO [2] is
parameterized by deﬁnable components of abstract post, reﬁnement, and expansion, allowing
various veriﬁcation techniques based on over- and under-approximation. Craig interpolation
has also been applied to solve constrained Horn clauses (CHC’s). The tool DUALITY [55]
generalizes IMPACT to gradually unroll a program and solves the corresponding CHC’s
with interpolation until it yields valid inductive invariants. The tool SPACER [48] combines
proof-based techniques with CEGAR, maintaining both an overapproximation and an under-
approximation of the input program. The tool SAFARI [3] implements a backward reachability
analysis with lazy abstraction based on the MCMT framework [37], which can be understood
as a backward variant of IMPACT, to support reasoning of arrays with unknown length.

Interpolation and SAT-Based Model Checking Revisited

7

3 Background

In the following, Boolean connectives ¬, ∨, ∧, →, ≡ are used in their conventional semantics.
A ﬁrst-order logical formula is also interpreted as a set of (program) states that satisfy the
formula, and we use the two terms interchangeably when it is clear from the context.

3.1 Interpolation-Based Model Checking

Interpolation-based model checking (IMC) [51] is an algorithm for unbounded model checking
to verify safety properties of state-transition systems. It can be considered as an extension
of BMC, which is well-known for bug hunting. In order to describe IMC, we ﬁrst deﬁne
the notation to formalize a state-transition system. Second, we review Craig’s interpolation
theorem [33], which is the core concept to extend BMC to unbounded model checking.

3.1.1 State-Transition System

Let s and s(cid:48) be two arbitrary states in the state space of a state-transition system. We formalize
the state-transition system by three predicates over states. Predicate I(s) evaluates to true if
state s is an initial state of the system. Predicate T (s, s(cid:48)) evaluates to true if the system can
transit from state s to state s(cid:48). It is also called the transition relation of the system. Predicate
P (s) evaluates to true if state s satisﬁes the safety property to be veriﬁed.

In the above formulation of a state-transition system, we do not assume the state space
to be ﬁnite or inﬁnite. The working of IMC is similar in both cases, provided that the under-
lying constraint solver (SAT/SMT solver) supports the reasoning over the corresponding
logical formulas.

3.1.2 Craig’s Interpolation Theorem

Given two logical formulas A and B, if A ∧ B is unsatisﬁable, Craig’s interpolation the-
orem [33] guarantees the existence of a logical formula C, called an interpolant of A and
B, which only refers to the common variables of A and B and satisﬁes: (1) A → C and
(2) C ∧ B is unsatisﬁable.

3.1.3 Algorithm Description

The overall procedure of IMC [51] can be decomposed into two phases. The ﬁrst phase
poses a BMC query by unrolling the transition relation k times and constructing a formula
representing all possible execution paths from an initial state to a bad state (a state that violates
the safety property) with k transitions. We use variable si to denote the state after the ith
transition. Furthermore, to facilitate Craig interpolation in the second phase, the BMC query
is partitioned into two formulas A and B:

I(s0)T (s0, s1)
(cid:125)
(cid:123)(cid:122)
(cid:124)
A(s0, s1)

T (s1, s2) . . . T (sk−1, sk)¬P (sk)
(cid:123)(cid:122)
(cid:125)
(cid:124)
B(s1, s2, . . . , sk)

(1)

If this formula is satisﬁable, a violation is found and we conclude that the system does
not fulﬁll the safety property. Otherwise, instead of simply increasing the unrolling upper

8

D. Beyer, N.-Z. Lee, and P. Wendler

bound, IMC tries to prove the safety property from the unsatisﬁable BMC query as its second
phase. According to Craig’s interpolation theorem, there exists an interpolant C(s1) referring
to the common variable s1, such that the following two conditions hold:

I(s0)T (s0, s1) → C(s1) and
C(s1)T (s1, s2) . . . T (sk−1, sk)¬P (sk) is unsatisﬁable.

The above two conditions indicate that C(s1) is an overapproximation of the set of states
reachable from the initial states with one transition, and that states in C(s1) will not violate
the safety property after (k − 1) transitions.

An overapproximation of the set of reachable states can be built by iteratively computing
these interpolants. Suppose the interpolant contains some noninitial states. Changing the
variable used in the interpolant from s1 to s0, another BMC query starting from the interpolant
can be posed with I(s0) replaced by C(s0):

C(s0)T (s0, s1)
(cid:125)
(cid:123)(cid:122)
(cid:124)
A(cid:48)(s0, s1)

T (s1, s2) . . . T (sk−1, sk)¬P (sk)
(cid:123)(cid:122)
(cid:125)
(cid:124)
B(cid:48)(s1, s2, . . . , sk)

If the formula is again unsatisﬁable, another interpolant C(cid:48)(s1) exists, which is an overap-
proximation of the set of states reachable from the initial states with two transitions. Such
computation is repeated until the newly derived interpolant is contained in the union of the
initial states and all previous interpolants. In other words, the procedure stops when the union
of the initial states and all previous interpolants grows to a ﬁxed point, i.e., an inductive set
of states with respect to the transition relation, which contains all reachable states. From the
second condition of Craig’s interpolation theorem, it is guaranteed that this ﬁxed point implies
the safety property, and hence the safety property is proved.

If any BMC query is satisﬁable during the iteration in the second phase, we cannot
conclude that the property is violated. The violation could be a wrong alarm, as some starting
states in the interpolants might not be reachable. Therefore, we have to return back to the ﬁrst
phase, increase the unrolling upper bound, and precisely check the existence of a violation
starting from the initial states.

3.1.4 Towards an Efﬁcient Adoption

While IMC is described in terms of logical formulas in the above discussion, the adoption
of this algorithm to a concrete state-transition system, such as a sequential Boolean-logic
circuit (hardware) or a program (software), requires a conversion from the system under
veriﬁcation to the three predicates I(s), T (s, s(cid:48)), and P (s). The conversion is simple for
sequential Boolean-logic circuits which IMC originally focused on, as the input wires to
the registers of the circuit encode the function to compute the next state (i.e., the state after
transition) via the downstream circuitry in terms of the output wires of the registers (i.e.,
the current state). This state-transition function can be naturally expressed as a transition
relation. It is less straightforward, by contrast, to extract a transition relation from a program.
Although a brute-force conversion is available, representing a program via a transition relation
with the program counter often destroys the control-ﬂow structure, and in turn decreases the
computational efﬁciency of veriﬁcation. The main challenge towards an efﬁcient adoption
to software veriﬁcation thus lies in obtaining all required predicates without blowing up
the program’s structure.

Interpolation and SAT-Based Model Checking Revisited

9

3.2 Program Representation

To facilitate the subsequent discussion of program analysis, here we provide some funda-
mental deﬁnitions for program representation from the literature [14, 15]. We consider an
imperative programming language whose variables are all integers. The operations are either
variable assignment or Boolean-expression evaluation. A control-ﬂow automaton (CFA) is a
representation of such a program. It is a directed graph with nodes being program locations
and edges annotated with program operations.

A reachability-safety veriﬁcation task consists of a CFA and an error location of the CFA.
The task is to either prove that the error location is unreachable from the initial location,
or ﬁnd a feasible error path to the error location otherwise. For instance, the CFA of the
example C program in Fig. 1a is shown in Fig. 1b. The initial location of this CFA is l3,
and the error location is l8.

3.3 Conﬁgurable Program Analysis

A conﬁgurable program analysis (CPA) [16, 17] deﬁnes the abstract domain used for a program
analysis. As we implemented the proposed adoption of IMC in the framework CPACHECKER,
which utilizes CPA as the core concept, we provide necessary background knowledge about
CPA as follows. For the rigorous deﬁnition of a CPA as well as further details, please refer
to the literature [13, 14].

3.3.1 Fundamental CPAs

Several fundamental CPAs are used in this paper: The Location CPA L [17] uses a ﬂat
lattice over all program locations to track the program counter explicitly; the Loop-Bound
CPA LB [12, 13] tracks in its abstract states for every loop of the program how often the loop
body has been traversed on the current program path; the ARG CPA A stores the predecessor-
successor relationship between abstract states to track the abstract reachability graph (ARG).
Another important CPA, namely the Predicate CPA P [13], will be used in Sect. 4.2.

3.3.2 Composite CPA

Several CPAs can be combined using a Composite CPA [16] to achieve synergy. The abstract
states of the Composite CPA are tuples of one abstract state from each component CPA and
the operators of the Composite CPA delegate to the component CPAs’ operators accordingly.

3.3.3 CPA Algorithm

CPAs can be used by the CPA algorithm [13, 14, 16] for reachability analysis, which gets
as input a CPA and an initial abstract state. The algorithm performs a classic ﬁxed-point
iteration by looping until all abstract states have been completely processed and returns the
set of reachable abstract states.

10

D. Beyer, N.-Z. Lee, and P. Wendler

4 An Efﬁcient Adoption to Software Veriﬁcation

In this section, we describe the proposed approach for adopting IMC to software veriﬁcation.
The presentation will be split into two parts. The ﬁrst part will introduce the main idea towards
an efﬁcient adoption. In essence, we take advantage of large-block encoding [10] to draw
an analogy between a program and the state-transition system discussed in Sect. 3. The
idea is not only helpful for this paper, but might also shed light on the efﬁcient adoptions
of other algorithms. The second part will focus on the implementation, discussing the data
structure and the algorithmic procedures. We implemented the proposed adoption in the
veriﬁcation framework CPACHECKER [18], leveraging its ﬂexibility provided by conﬁgurable
program analysis [16].

4.1 Obtaining Transition Relation with Large-Block Encoding

As discussed in Sect. 3.1, obtaining a transition relation from a CFA is not a straightforward
process. Unlike sequential Boolean-logic circuits, which usually have only one feedback loop,
a CFA could have arbitrarily many loops. To simplify the problem, we start by considering
single-loop programs. As a program with multiple loops can be converted into a single-loop
program by a standard transformation [1, 35], this simpliﬁcation will not hurt the generality
of the proposed approach.

To obtain the transition relation of a single-loop program, we take advantage of large-
block encoding (LBE) [10]. Given a CFA, LBE repeatedly rewrites the original CFA in order
to summarize it. In the summarized CFA, each loop-free subgraph of the original CFA is
represented by a single control-ﬂow edge. The edge is annotated with a formula that encodes
the program behavior of the represented subgraph of the original CFA.

A summarized single-loop CFA is given in Fig. 3a. It has an initial location l0, a loop-
head location lH , a loop-body location lB, a loop-tail location lT , and an error location lE.
These locations correspond to the program locations in the original single-loop CFA be-
fore summarization. The edges of the summarized single-loop CFA are labeled with the
following formulas: Formula ϕ0 summarizes the subgraph from l0 to lH , formula ϕL sum-
marizes the subgraph from lB back to lH , and formulas ϕE, ϕ(cid:48)
E summarize the subgraphs
from lT , lB to lE, respectively.

We notice that, the summarized single-loop CFA has a natural analogy to those predicates
used in Sect. 3.1: The initial-state predicate I(s) is analogous to ϕ0, the transition relation
T (s, s(cid:48)) is analogous to C ∧ ϕL, and the negated safety property ¬P (s) is analogous to
(¬C ∧ ϕE) ∨ (C ∧ ϕ(cid:48)
E). Using LBE, we successfully obtain the required predicates without
destroying the control ﬂow of the CFA.

Furthermore, in order to perform IMC, we have to unroll the summarized single-loop CFA
and construct the BMC query Eq. (1). In Fig. 3b, we unroll the CFA by drawing all possible
paths starting from l0, iterating the loop k times (k + 1 visits to lH ), and ﬁnally reaching lE.
A node in Fig. 3b consists of a program location which the control ﬂow is currently at and a
formula σ to encode all possible paths starting from the program location of the preceding node.
Note that σ is indexed with the unrolling counter i to distinguish between different iterations.
To discover the similarity between Eq. (1) and Fig. 3b, we additionally label a node
in Fig. 3b with the subformula in Eq. (1) that σ corresponds to. From those labels, we
observe that the formulas in the unrolled CFA nicely match the subformulas in Eq. (1).
We name the formula matching I(s0) preﬁx formula, the formula matching T (s0, s1) loop

Interpolation and SAT-Based Model Checking Revisited

11

l0

ϕ0

lH

¬C

lT

ϕE

lE

C

ϕL

lB

ϕ(cid:48)
E

(l0, true)

(lH , ϕ0|i=0) : I(s0)

(lH , (C ∧ ϕL)|i=1) : T (s0, s1)

(lH , (C ∧ ϕL)|i=2) : T (s1, s2)
...
(lH , (C ∧ ϕL)|i=k) : T (sk−1, sk)

(lE, ((¬C ∧ ϕE) ∨ (C ∧ ϕ(cid:48)

E))|i=k) : ¬P (sk)

(a) Summarized single-loop CFA

(b) k-Unrolling

Fig. 3: A summarized single-loop CFA (a) and its k-unrolling (b)

formula, and the formula matching T (s1, s2) ∧ . . . ∧ T (sk−1, sk) ∧ ¬P (sk) sufﬁx formula.
In the following we will describe an implementation in CPACHECKER to construct these
formulas and perform IMC.

4.2 Implementation in CPACHECKER

Before we delve into implementation details, we would like to emphasize that the idea to
extract a transition relation with LBE is general and independent of the underlying frame-
work. We chose to implement the proposed adoption in CPACHECKER because it provides
(1) the necessary components for the adoption, which are highly conﬁgurable, and (2) the
implementations of various state-of-the-art software-veriﬁcation algorithms, which is con-
venient for the evaluation.

To implement the proposed adoption in CPACHECKER, we use the Predicate CPA [19]
as the core data structure to store formulas that encode program behavior, and build the
algorithmic procedures of IMC on top of the CPA++ algorithm [13].

4.2.1 Predicate CPA

The Predicate CPA P for adjustable-block encoding (ABE) [19] uses a triple (ψ, lψ , ϕ) of
an abstraction formula ψ, an abstraction location lψ , and a path formula ϕ as an abstract
state. The abstraction formula ψ stores the abstraction of the program state computed at the
program location lψ . The path formula ϕ syntactically encodes the program behavior from
the abstraction location lψ to the current program location. Abstract states where the path
formula ϕ is true are called abstraction states; other abstract states are intermediate states.
In this paper, we augment an abstract state of the Predicate CPA by a fourth element: a
block formula σ. The block formula encodes all possible paths from the previous abstraction
location to the current abstraction location, and is used to compute the abstraction formula. In
the implementation of CPACHECKER, the block formula is already stored in the data structure
for the abstraction formula. We append it to an abstract state of the Predicate CPA in order
to make the subsequent discussion more understandable.

12

D. Beyer, N.-Z. Lee, and P. Wendler

With the help of ABE, we can achieve the effect of LBE via using the block-adjustment
operator blkl [19]. The operator blkl will make the Predicate CPA convert an intermediate state
to an abstraction state if the current program location is at the loop head or the error location.
Under this conﬁguration, the unrolled ARG, if projected to abstraction states, will have a
similar structure to Fig. 3b. Therefore, we can easily obtain the required formulas by collecting
and combining the block formulas from the corresponding abstraction states in the ARG.

It is worth noting that here we take advantage of the ﬂexibility of the Predicate CPA: By
choosing an appropriate implementation for the block-adjustment operator, we can conﬁgure
the Predicate CPA to be suitable for IMC (together with the algorithms described in the follow-
ing) without further changes to its deﬁnition. Other choices for its operators would allow it to
be combined with different algorithms and implement different approaches like IMPACT, pred-
icate abstraction, and k-induction [13]. Using the Predicate CPA as common framework not
only highlights conceptual differences and similarities between the approaches, but also allows
for comparing them experimentally with the set of confounding variables kept to a minimum.

4.2.2 Algorithmic Procedures

We present an algorithm for the adoption of IMC to software veriﬁcation in Alg. 1, based on
the CPA++ algorithm [13]. The algorithm assumes single-loop programs as input. We apply
single-loop transformation [1, 35] to input programs with multiple loops as a preprocessing.
The algorithm takes as input an upper limit kmax for a counter k that tracks the number of
loop iterations on a program path and a composite CPA consisting of the Location CPA, the
Predicate CPA described above, and the Loop-Bound CPA.

Note that the CPA++ algorithm [13] will stop exploring a program path if the number of
loop iterations on this path has reached the given unrolling upper bound. While the algorithm
is asked to unroll the program k times, it uses the last unrolling only for encoding the
predicate P (s) and thus only k −1 copies of T (s, s(cid:48)) appear in its BMC query. This is done for
consistency with other algorithms expressed on top of the same unifying framework [13]. For
analyzing up to k unrollings of a program with IMC, we can pass k + 1 as parameter to Alg. 1.
An abstract state of the composite CPA is (l , (ψ, lψ , ϕ, σ), {lH (cid:55)→ i}), where the ﬁrst
element is an abstract state of the Location CPA representing the current program location
l, the second element is an abstract state of the Predicate CPA as explained above, and the
third element is an abstract state of the Loop-Bound CPA recording that the loop body starting
from lH has been completely traversed i times already. We also use the ARG CPA A to store
the predecessor-successor relationship between abstract states. To increase readability we
simply use abstract states as elements in the ARG, and explicitly give the unrolling upper
bound k as a parameter to the CPA++ algorithm (instead of passing it via the precision of
the initial abstract state as in the literature [13]).

After unrolling the CFA with the CPA++ algorithm (line 6), we have to collect pre-
ﬁx, loop, and sufﬁx formulas to pose a BMC query and perform the ﬁxed-point com-
putation via interpolation. The formula collection is described in lines 7 to 11, where
we write σ|(l , (ψ, lψ , ϕ, σ), {lH (cid:55)→ i}) to denote the block formula σ of the abstract state
(l , (ψ, lψ , ϕ, σ), {lH (cid:55)→ i}). The preﬁx formula σp is the block formula of the abstract state
(lH , (·, ·, ·, σ), {lH (cid:55)→ 0}); if the loop head is visited more than once, i.e., k > 1, the loop for-
mula σl is the block formula of the abstract state (lH , (·, ·, ·, σ), {lH (cid:55)→ 1}), otherwise, it is set
to true; the sufﬁx formula σs is the conjunction of the following two formulas: the conjunction
of block formulas of the abstract state (lH , (·, ·, ·, σ), {lH (cid:55)→ i}) for i = 2, . . . , (k − 1), and
the disjunction of the block formulas of the abstract states (lE, (·, ·, ·, σ), {lH (cid:55)→ (k − 1)}).

Interpolation and SAT-Based Model Checking Revisited

13

Algorithm 1 IMC: main procedure

Input: an upper limit kmax for the loop unrolling bound k,

a composite CPA D with components: the Location CPA L,
the Predicate CPA P, and the Loop-Bound CPA LB

Output: false if an error path to lE is found,

true if a ﬁxed point is obtained,
unknown otherwise

// Create initial abstract state at l0
// abortnever always returns false

1: k := 1
2: e0 := (l0, (true, l0, true, true), {lH (cid:55)→ −1})
3: abortnever := {· (cid:55)→ false}
4: reached := waitlist := {e0}
5: while k ≤ kmax do
6:

(reached, waitlist) :=

CPA++(D, reached, waitlist, abortnever , k)
σp := σ | (lH , (·, ·, ·, σ), {lH (cid:55)→ 0}) ∈ reached
σl := true
if k > 1 then

7:
8:
9:
10:
11:

σl := σ | (lH , (·, ·, ·, σ), {lH (cid:55)→ 1}) ∈ reached

σs := (cid:86)k−1

i=2 σ | (lH , (·, ·, ·, σ), {lH (cid:55)→ i}) ∈ reached ∧
(cid:87) {σ | (lE , (·, ·, ·, σ), {lH (cid:55)→ (k − 1)}) ∈ reached}

if sat(σp ∧ σl ∧ σs) then

if k > 1 and reach_ﬁxed_point(σp,σl,σs) then

return false

12:
13:
14:
15:
16:
17: return unknown

k := k + 1

return true

Algorithm 2 IMC: reach_ﬁxed_point(σp,σl,σs)
Input: preﬁx formula σp, loop formula σl, and sufﬁx formula σs
Output: true if a ﬁxed point is reached, false otherwise
1: image := start := σp
2: while ¬sat(start ∧ σl ∧ σs) do
3:
4:
5:
6:
image := image ∨ τ
7:
start := τ
8:
9: return false

τ := get_interpolant(start ∧ σl, σs)
τ := shift_variable_index(τ, σp)
if ¬sat(τ ∧ ¬image) then

return true

// Found an error path via BMC query

// Obtained a ﬁxed point via interpolation

// Set current reachable and starting states to initial states

// formula A: start ∧ σl; formula B: σs

// Interpolant implies image: ﬁxed point
// Find new states: enlarge image
// Start next iteration from new states
// Reach error: might be wrong alarm

Note that the above formula collection at abstract states whose locations equal lH is
unambiguous, meaning that there is a unique abstract state satisfying the conditions imposed
by the Location CPA L and the Loop-Bound CPA LB. This is because we assume single-loop
programs and use LBE to summarize all paths between two adjacent abstraction states. After
collecting these formulas, the BMC query is simply the conjunction of the preﬁx, loop, and
sufﬁx formulas. If the BMC query is unsatisﬁable, we try to compute a ﬁxed point using Alg. 2,
which implements the procedure described in Sect. 3.1 to iteratively derive interpolants from
unsatisﬁable BMC queries and grow a ﬁxed point as their union.

We ﬁrst initialize both image, which stores an overapproximation of the reachable states,
and start, which stores the starting states of BMC queries, to be the preﬁx formula. Using
start ∧ σl as formula A and σs as formula B, we derive an interpolant τ . As discussed
in Sect. 3.1, the ith interpolant is an overapproximation of the reachable states after i loop
unrollings. We change the variables used in the interpolant to those in the preﬁx formula

14

D. Beyer, N.-Z. Lee, and P. Wendler

e0: (l3, (true, l3, true, true), {l4 (cid:55)→ −1})

e1: (l4, (true, l4, true, x0 = 0), {l4 (cid:55)→ 0})

e2: (l7, (true, l4, r0 = 0, x0 = 0), {l4 (cid:55)→ 0})

e3: (l8, (true, l8, true, r0 = 0 ∧ ¬(x0%2 = 0)), {l4 (cid:55)→ 0})

e4: (l10, (true, l4, r0 = 0 ∧ x0%2 = 0, x0 = 0), {l4 (cid:55)→ 0})

e5: (l5, (true, l4, ¬(r0 = 0), x0 = 0), {l4 (cid:55)→ 0})

e6: (l4, (true, l4, true, ¬(r0 = 0) ∧ x1 = x0 + 2), {l4 (cid:55)→ 1})

e7: (l7, (true, l4, r1 = 0, ¬(r0 = 0) ∧ x1 = x0 + 2), {l4 (cid:55)→ 1})

e8: (l8, (true, l8, true, r1 = 0 ∧ ¬(x1%2 = 0)), {l4 (cid:55)→ 1})

e9: (l10, (true, l4, r1 = 0 ∧ x1%2 = 0, ¬(r0 = 0) ∧ x1 = x0 + 2), {l4 (cid:55)→ 1})

e10: (l5, (true, l4, ¬(r1 = 0), ¬(r0 = 0) ∧ x1 = x0 + 2), {l4 (cid:55)→ 1})

e11: (l4, (true, l4, true, ¬(r1 = 0) ∧ x2 = x1 + 2), {l4 (cid:55)→ 2})

Fig. 4: ARG constructed by the CPA++ algorithm [13] for the CFA in Fig. 1b (k = 2)

and check whether the interpolant implies image. If yes, a ﬁxed point has been reached,
and we conclude the property is true; otherwise, we enlarge image by adding the states
contained in the interpolant to it and pose another BMC query starting from the interpolant. If
any BMC query during the iteration is satisﬁable, we return back to Alg. 1 and increase the
loop-unrolling counter k to check whether the violation is a wrong alarm.

4.3 Example

We demonstrate step-by-step how to apply Alg. 1 and Alg. 2 to verify the CFA in Fig. 1b.
The ARG constructed by the CPA++ algorithm when k = 2 is shown in Fig. 4. In this ﬁgure,
each abstract state is a tuple (l , (ψ, lψ , ϕ, σ), {l4 (cid:55)→ i}) of the abstract states of L, P, and LB.
Note that every abstract state in the ARG has an abstraction formula ψ (the ﬁrst element in an
abstract state of Predicate CPA) equal to true, because IMC does not compute an abstraction
formula. Instead, it relies on interpolants for the abstraction of program states. Abstract states
whose predicate abstract state is an abstraction state are highlighted in gray. We use r to
denote the return value of function nondet.

The preﬁx formula σp is the block formula x0 = 0 of abstract state e1, the loop formula σl
is the block formula ¬(r0 = 0) ∧ x1 = x0 + 2 of abstract state e6, and the sufﬁx formula σs
is the block formula r1 = 0 ∧ ¬(x1%2 = 0) of abstract state e8 (note that the block formula
of abstract state e3, which also has location l8, is not selected because l4 (cid:55)→ 0 does not
match in line 11 of Alg. 1). As the BMC query x0 = 0 ∧ ¬(r0 = 0) ∧ x1 = x0 + 2 ∧ r1 =
0 ∧ ¬(x1%2 = 0) is unsatisﬁable, we try to compute a ﬁxed point using Alg. 2.

Interpolation and SAT-Based Model Checking Revisited

15

Variables image and start are initialized to x0 = 0. Using x0 = 0 ∧ ¬(r0 = 0) ∧
x1 = x0 + 2 as formula A and r1 = 0 ∧ ¬(x1%2 = 0) as formula B, we can derive an
interpolant τ from the unsatisﬁable BMC query. Assume that τ is x1%2 = 0, referring to
the common variable x1 between formulas A and B. After shifting the variable to the one
used in σp, we obtain x0%2 = 0. As the interpolant does not imply image, we enlarge the
current image by disjoining it with the interpolant. The computation is then repeated again,
with start equal to x0%2 = 0 this time. The BMC query in the second iteration becomes
x0%2 = 0 ∧ ¬(r0 = 0) ∧ x1 = x0 + 2 ∧ r1 = 0 ∧ ¬(x1%2 = 0), which is still unsatisﬁable.
Assume the interpolant is again x1%2 = 0. Obviously, we have reached a ﬁxed point, as the
newly derived interpolant implies image. Therefore, we conclude that the property holds.

4.4 Correctness

It is straightforward to see that Alg. 1 is precise, i.e., does not produce wrong alarms, because
if it returns false, then the BMC query for all paths from l0 to lE at line 12 is satisﬁable, which
implies that the CFA has a feasible path to lE. More interesting is the soundness of Alg. 1,
i.e., whether it may produce wrong proofs, which we discuss in the following. Its soundness
follows from that of large-block encoding [10] and the original IMC algorithm [51]. We state
the soundness of Alg. 1 when it is applied to a single-loop CFA in Theorem 1. For CFAs with
multiple loops, the soundness will also depend on that of the single-loop transformation [1, 35].

Theorem 1 Given a single-loop CFA A and its corresponding composite CPA D as input, if
Alg. 1 returns true upon D, then A does not have a feasible path to lE.

Proof We prove the statement by contradiction. Suppose Alg. 1 returns true when the value
of the loop-unrolling counter k equals (cid:98)k, but the single-loop CFA has a feasible path to lE.
We split into two cases based on the number (cid:98)h of the visits to lH on the error path.

First, assume (cid:98)h ≤ (cid:98)k. Thanks to the sound summarization of LBE, the formula of the error
path must imply σp ∧ σl ∧ σs when k = (cid:98)h. Therefore, Alg. 1 should have returned false as
k = (cid:98)h, because the BMC query at line 12 of Alg. 1 is satisﬁable. This result contradicts to the
assumption that Alg. 1 returns true.

Second, assume (cid:98)h > (cid:98)k. Such error path indicates the existence of a state (cid:98)s that is reachable
from l0 by traversing the loop (cid:98)h − (cid:98)k times and will reach lE after further traversing the loop
(cid:98)k − 1 times. We will show that Alg. 2 will return false after discovering (cid:98)s via interpolation.
Note that Alg. 2 cannot return true before ﬁnding (cid:98)s, because the state must be contained in
the computed ﬁxed point.

According to the property of the original IMC algorithm described in Sect. 3.1, the
interpolant derived in the ith while-loop iteration of Alg. 2 is an overapproximation of the
set of states reachable from l0 by traversing the loop i times. Therefore, (cid:98)s must belong to
the interpolant τ derived in the ((cid:98)h − (cid:98)k)th while-loop iteration of Alg. 2, which will be used
as new starting states in the next iteration. Moreover, because of the soundness of LBE, the
formula from the ((cid:98)h − (cid:98)k + 1)th lH to lE (involving (cid:98)k visits to lH ) on the error path must
imply σl ∧ σs when we enter Alg. 2 with k = (cid:98)k. As a result, in the beginning of the next
iteration, the satisﬁability query at line 2 of Alg. 2 must be satisﬁable, which makes Alg. 2
return false. This in turn prevents Alg. 1 from returning true when k = (cid:98)k, contradicting to
our assumption.

Having analyzed the above two possibilities, we conclude that such a feasible error path

does not exist, and hence Alg. 1 is sound.

16

D. Beyer, N.-Z. Lee, and P. Wendler

4.5 Backward Derivation of Interpolants

Notice that in the example of Sect. 4.3, the “quality” of interpolants heavily affects the
convergence of the ﬁxed-point computation. For example, instead of x1%2 = 0, which is
actually the loop invariant, suppose the interpolant derived by the solver is x1 = 2. Starting
from this interpolant, we might be trapped in a sequence of interpolants x1 = 4, x1 = 6,
x1 = 8, . . ., and never reach a ﬁxed point.

While in general it is difﬁcult to control the interpolation process of the solver, there is a
trick to mitigate this problem. First, we switch the labels of the two formulas, i.e., we label
the original formula B as the new formula A and the original formula A as the new formula
B. Second, we ask the solver to derive an interpolant for the new formulas and then negate
it. The negated interpolant is a valid interpolant for the original formulas A and B. In other
words, instead of get_interpolant(A, B), we use ¬get_interpolant(B, A).

Using this trick in IMC, we are actually deriving interpolants backwards, from the safety
property. Therefore, we call it backward derivation of interpolants. With the backward deriva-
tion, we can in practice often avoid the bad interpolant x1 = 2 and obtain the good one
x1%2 = 0 for fast convergence of the example program in Sect. 4.3. Empirically, we found
that the backward derivation performs slightly better than the forward derivation. This phe-
nomenon might be attributed to the fact that deriving the interpolants backward from the
safety property side is likely to yield interpolants summarizing information more relevant to
proving the property. As a result, we use it as default in our implementation.

5 Evaluation

In order to answer the research questions posed in Sect. 1.2, namely,

• RQ1: How to efﬁciently adopt IMC to software veriﬁcation?
• RQ2: How does the software adoption of IMC compare with the state of the art?

we evaluated the proposed adoption of IMC against several state-of-the-art algorithms, in-
cluding BMC [23], k-induction [12], predicate abstraction [38], IMPACT [52], and PDR [24],
over the largest publicly available benchmark suite of C safety-veriﬁcation tasks [8]. All
of the compared approaches are implemented in CPACHECKER. The implementations of
BMC, k-induction, predicate abstraction, and IMPACT are built on top of the CPA++ algo-
rithm in a uniﬁed manner [13]. The implementation of PDR in CPACHECKER follows a
software-veriﬁcation adaption named CTIGAR [24], which was compared against other PDR-
related approaches recently in the literature [11]. We did not include other state-of-the-art
veriﬁers in this paper for space reasons (and because the results are available already from
SV-COMP ’22 [8]) and to limit confounding variables to a minimum (same parser, same
libraries, same SMT solver, etc.). We chose CPACHECKER as platform because it is a ﬂexible
framework that performed well in the competitions.

5.1 Benchmark Set

As the benchmark set we used the veriﬁcation tasks from the 2022 Competition on Software
Veriﬁcation (SV-COMP ’22) [9]. We used only veriﬁcation tasks where the safety property is
the reachability of a program location. From those, we further excluded veriﬁcation tasks that

Interpolation and SAT-Based Model Checking Revisited

17

Table 2: Summary of the results for 6 027 reachability-safety veriﬁcation tasks

Algorithm

IMC

PDR

BMC k-Induction

Predicate Abstraction

IMPACT

Correct results

proofs
alarms
Wrong proofs
Wrong alarms
Timeouts
Out of memory
Other inconclusive

2 767
1 867
900
0
3
2 038
141
1 078

1 610
1 146
464
0
1
3 367
33
1 016

2 380
1 205
1 175
0
1
2 228
358
1 060

3 116
2 128
988
0
1
1 825
277
808

2 342
1 532
810
1
5
1 959
22
1 698

2 418
1 547
871
0
6
1 728
102
1 773

are not supported by at least one of the compared approaches, e.g., those from the categories
ReachSafety-Recursive and ConcurrencySafety-Main. The resulting benchmark set consists
of a total of 6 027 veriﬁcation tasks from the subcategories AWS-C-Common-ReachSafety,
DeviceDriversLinux64-ReachSafety, DeviceDriversLinux64Large-ReachSafety, and uthash-
ReachSafety of the category SoftwareSystems and from the following subcategories of the
category ReachSafety: Arrays, Bitvectors, ControlFlow, ECA, Floats, Heap, Loops, Product-
Lines, Sequentialized, XCSP, and Combinations. A total of 1 793 tasks in the benchmark set
contain a known speciﬁcation violation, while the other 4 234 tasks are assumed to be correct.

5.2 Experimental Setup

Our experiments were performed on machines with one 3.4 GHz CPU (Intel Xeon E3-
1230 v5) with 8 processing units and 33 GB of RAM each. The operating system was
Ubuntu 20.04 (64 bit), using Linux 5.4 and OpenJDK 11.0.8. Each veriﬁcation task was
limited to two CPU cores, a CPU time of 15 min, and a memory usage of 15 GB. We
used BENCHEXEC1 [21] to achieve reliable benchmarking and revision 40 806 of branch
cfa-single-loop-transformation of CPACHECKER for evaluation. We conﬁgured
CPACHECKER to use the SMT theories of equality with uninterpreted functions, bit vectors,
ﬂoats, and arrays. All SMT queries were handled by MATHSAT5 [29].

5.3 Results

The experimental results of all compared approaches are summarized in Table 2. Observe that
IMC produced the most correct results for both proofs and alarms among the interpolation-
based approaches (IMC, PDR, predicate abstraction, and IMPACT), and was second only to
k-induction in the evaluation. Furthermore, it uniquely solved 6 programs for which all other
approaches ran out of resources. In comparison to the most-related approach IMPACT, IMC
proved the safety of 320 more programs and found 29 more bugs (an increase of 21 % and
3.3 %, respectively). Meanwhile, BMC generated the most correct alarms as expected, and
k-induction correctly solved the most tasks, with the most correct proofs and the second-most
correct alarms. Moreover, although IMC is a new addition to CPACHECKER, it did not produce
any wrong proof in the evaluation, identical to the other long-established approaches in the
software-veriﬁcation framework. We consider the 3 wrong alarms of IMC not caused by

1 https://github.com/sosy-lab/benchexec

18

1 000

100

10

1

0

D. Beyer, N.-Z. Lee, and P. Wendler

1 000

100

10

500

1 000

1 500

2 000

1

0

200

400

600

800

1 000 1 200

(a) Proofs

(b) Alarms

IMC
k-Induction

PDR
Predicate Abstraction

BMC
IMPACT

x-Axis: n-th fastest correct result
y-Axis: CPU time (s)

Fig. 5: Quantile plots for all correct proofs and alarms

our implementation. They are related to the program encoding of CPACHECKER, and other
approaches, such as predicate abstraction, also failed to solve these tasks correctly.

The quantile plots for the correct proofs and alarms of the compared approaches are shown
in Fig. 5a and Fig. 5b, respectively. A data point (x, y) in the plots indicates that there are x
tasks correctly solved by the respective algorithm within a CPU time of y seconds each. Note
that IMC is not only effective in producing proofs and alarms but is also efﬁcient. From Fig. 5,
we see that it is the most efﬁcient and effective interpolation-based approach in the evaluation.
The scatter plots for the correctly solved tasks (including both proofs and alarms) of the
compared approaches are shown in Fig. 6. We omitted the scatter plot for BMC as it is mainly
inclined to bug hunting, while other approaches have more balanced behavior. A data point
(x, y) in the plots indicates that there is a task correctly solved by both IMC and a compared
approach, while IMC took a CPU time of y seconds and the other approach took a CPU
time of x seconds. Observe that IMC is often more efﬁcient than a compared approach. For
example, while it solved less tasks compared to k-induction, its time efﬁciency is often better
than k-induction on the tasks which can be solved by both algorithms. This phenomenon
could be explained by the fact that, unlike k-induction, which relies on an external procedure
to generate auxiliary invariants, IMC generates interpolants from BMC queries and uses
them to construct ﬁxed points purely internally.

Moreover, in our evaluation, there were 122 programs that IMC solved, but k-induction
ran out of time or memory. These programs often have a loop for which helpful loop invariants,
i.e., those that help to prove the property, require complex formulas. IMC is better in such
cases. The default conﬁguration of k-induction in CPACHECKER uses an interval-based data-
ﬂow analysis to generate candidate invariants whose expressiveness is limited. By contrast,
IMC constructs a candidate ﬁxed point (also a loop invariant) as a union of previously derived
interpolants, which in principle can express any combination of reachable states.

The best subcategory for IMC was category ReachSafety-ECA. These event-condition-
action (ECA) programs have a loop to receive external inputs, generate outputs, and update
internal variables based on the ECA rules. Inside the loop is a complex control ﬂow to
implement the ECA rules. Overall, the working of these programs is similar to that of
sequential Boolean-logic circuits. IMC naturally performs well on them because it originated
from hardware veriﬁcation. Out of a total 1 265 ECA programs, IMC solved a second most

Interpolation and SAT-Based Model Checking Revisited

19

1 000

100

10

1

1

1 000

100

10

10

100

1 000

(a) PDR

1 000

100

10

1

1

1 000

100

10

10

100

1 000

(b) k-Induction

1

1

10

100

1 000

1

1

10

100

1 000

(c) Predicate Abstraction

(d) IMPACT

Fig. 6: Scatter plots of CPU time in seconds for all correct results with IMC in y-axis and
compared approaches in x-axis

561 programs, while predicate abstraction, IMPACT, and k-induction solved 476, 555, and
578 tasks, respectively.

Answers to the Research Questions. Regarding RQ1, we conclude that the proposed ap-
proach with large-block encoding is an efﬁcient adoption of IMC to software veriﬁcation. The
conclusion is well supported by the experimental results, because our IMC implementation
not only solved the second most veriﬁcation tasks (Table 2) in the evaluation, but was also
efﬁcient compared to other state-of-the-art approaches (Fig. 6). In our experiments, it was the
most efﬁcient and effective interpolation-based approach (Fig. 5). Note that the efﬁciency and
effectiveness might not be achieved without large-block encoding, because the control-ﬂow
structure would be destroyed if one simply converts a program into a transition relation with
the program counter to perform IMC. The empirical results demonstrate the unique value
of using large-block encoding to adopt the IMC algorithm.

As for RQ2, we conclude that IMC, the ﬁrst interpolation-based formal-veriﬁcation
approach ever invented, is competitive against the other state-of-the-art algorithms, which
have been investigated much more by the research community. It has great potential to improve

20

D. Beyer, N.-Z. Lee, and P. Wendler

the state of the art of software veriﬁcation and thus deserves more attention. Our experimental
results show that IMC is not only comparable but also complements other approaches, as it
uniquely solved 6 veriﬁcation tasks for which all other algorithms ran out of resources.

5.4 Threats to Validity

Here we discuss some threats that may affect the validity of our conclusions and how we
reduced them. To enhance internal validity, all the compared algorithms are implemented
in CPACHECKER. This practice minimizes the confounding variables (front ends and utilities)
and rules out differences unrelated to the algorithms. We also use BENCHEXEC [21] to ensure
best possible measurement accuracy. To reduce the external threat resulting from the selection
bias of veriﬁcation tasks, we conduct the experiments using the largest publicly available
benchmark set of C safety-veriﬁcation tasks. Other external threats arise from the selection
of the compared approaches and underlying framework. It is clear from the literature [13]
that the compared approaches in this paper indeed represent the state of the art of software
veriﬁcation; the only missing main related state-of-the-art approach is trace abstraction [40],
for which the implementation in CPACHECKER is not yet mature enough. Moreover, the
chosen platform CPACHECKER is a well-maintained software project that performs well in
the competitions, and the relative performance between CPACHECKER and other veriﬁers
is available from SV-COMP ’22 [8].

6 Conclusion

Software veriﬁcation is a hard problem, and it is imperative to leverage as much knowledge
of the veriﬁcation community as possible. Interpolation-based model checking (McMillan,
2003 [51]) is a successful hardware-veriﬁcation algorithm, but in contrast to many other
interpolation-based veriﬁcation approaches this algorithm was not yet adopted to software
veriﬁcation and the characteristics of the algorithm when applied to software systems were
unknown. This paper presents the ﬁrst theoretical adoption and practical implementation of the
algorithm for software veriﬁcation, and provides a base-line for other researchers to build on.
Surprisingly, it has taken 19 years to close this signiﬁcant gap of knowledge by investigating
the applicability to software veriﬁcation. We present the novel idea of utilizing the well
established technique large-block encoding to extract transition relations from programs
while preserving the control-ﬂow structures. The proposed adoption was implemented in
the open-source software-veriﬁcation framework CPACHECKER and evaluated against other
state-of-the-art software-veriﬁcation algorithms on a large benchmark set of C veriﬁcation
tasks for reachability properties.

Among the competing approaches, our implementation achieved a comparable perfor-
mance, evaluated in terms of both effectiveness (the number of correctly solved tasks) and
efﬁciency (the CPU time to solve tasks). Our IMC implementation was the most effective
and efﬁcient interpolation-based approach in the evaluation. Furthermore, the new approach
was able to solve 6 programs for which all other approaches ran out of resources (15 min
CPU time or 15 GB memory usage), which shows that the new approach improves the state of
the art and complements the other approaches. We hope that our promising results stimulate
other researchers to further improve the approach for software veriﬁcation, and that our
open-source implementation in the ﬂexible framework CPACHECKER helps other researchers
to understand the details of the algorithm.

Interpolation and SAT-Based Model Checking Revisited

21

Data-Availability Statement

To enhance the veriﬁability and transparency of the results reported in this paper, all used
software, input programs, and raw experimental results are available in a supplemental
reproduction package [20]. For convenient browsing through the results, interactive tables are
available at https://www.sosy-lab.org/research/cpa-imc. Current versions
of CPACHECKER are also available at https://cpachecker.sosy-lab.org.

References

1. Aho, A.V., Sethi, R., Ullman, J.D.: Compilers: Principles, Techniques, and Tools. Addison-Wesley (1986).

ISBN: 978-0-201-10088-4

2. Albarghouthi, A., Li, Y., Gurﬁnkel, A., Chechik, M.: UFO: A framework for abstraction- and interpolation-
based software veriﬁcation. In: Proc. CAV, LNCS 7358, pp. 672–678. Springer (2012). https://doi.
org/10.1007/978-3-642-31424-7_48

3. Alberti, F., Bruttomesso, R., Ghilardi, S., Ranise, S., Sharygina, N.: An extension of lazy abstraction
with interpolation for programs with arrays. Formal Methods in System Design 45(1), 63–109 (2014).
https://doi.org/10.1007/s10703-014-0209-9

4. Ball, T., Cook, B., Levin, V., Rajamani, S.K.: SLAM and Static Driver Veriﬁer: Technology transfer
of formal methods inside Microsoft. In: Proc. IFM, LNCS 2999, pp. 1–20. Springer (2004). https:
//doi.org/10.1007/978-3-540-24756-2_1

5. Ball, T., Majumdar, R., Millstein, T., Rajamani, S.K.: Automatic predicate abstraction of C programs. In:

Proc. PLDI, pp. 203–213. ACM (2001). https://doi.org/10.1145/378795.378846

6. Ball, T., Rajamani, S.K.: The SLAM project: Debugging system software via static analysis. In: Proc.

POPL, pp. 1–3. ACM (2002). https://doi.org/10.1145/503272.503274

7. Barrett, C., Tinelli, C.: Satisﬁability modulo theories. In: Handbook of Model Checking, pp. 305–343.

Springer (2018). https://doi.org/10.1007/978-3-319-10575-8_11

8. Beyer, D.: Progress on software veriﬁcation: SV-COMP 2022. In: Proc. TACAS (2), LNCS 13244, pp.

375–402. Springer (2022). https://doi.org/10.1007/978-3-030-99527-0_20

9. Beyer, D.: SV-Benchmarks: Benchmark set for software veriﬁcation and testing (SV-COMP 2022 and

Test-Comp 2022). Zenodo (2022). https://doi.org/10.5281/zenodo.5831003

10. Beyer, D., Cimatti, A., Griggio, A., Keremoglu, M.E., Sebastiani, R.: Software model checking via large-
block encoding. In: Proc. FMCAD, pp. 25–32. IEEE (2009). https://doi.org/10.1109/FMCAD.
2009.5351147

11. Beyer, D., Dangl, M.: Software veriﬁcation with PDR: An implementation of the state of the art.
In: Proc. TACAS (1), LNCS 12078, pp. 3–21. Springer (2020). https://doi.org/10.1007/
978-3-030-45190-5_1

12. Beyer, D., Dangl, M., Wendler, P.: Boosting k-induction with continuously-reﬁned invariants.
https://doi.org/10.1007/

In: Proc. CAV, LNCS 9206, pp. 622–640. Springer (2015).
978-3-319-21690-4_42

13. Beyer, D., Dangl, M., Wendler, P.: A unifying view on SMT-based software veriﬁcation. J. Autom.

Reasoning 60(3), 299–335 (2018). https://doi.org/10.1007/s10817-017-9432-6

14. Beyer, D., Gulwani, S., Schmidt, D.: Combining model checking and data-ﬂow analysis.

In:
Handbook of Model Checking, pp. 493–540. Springer (2018). https://doi.org/10.1007/
978-3-319-10575-8_16

15. Beyer, D., Henzinger, T.A., Jhala, R., Majumdar, R.: The software model checker BLAST.

Int.
https://doi.org/10.1007/

J. Softw. Tools Technol. Transfer 9(5-6), 505–525 (2007).
s10009-007-0044-z

16. Beyer, D., Henzinger, T.A., Théoduloz, G.: Conﬁgurable software veriﬁcation: Concretizing the conver-
gence of model checking and program analysis. In: Proc. CAV, LNCS 4590, pp. 504–518. Springer (2007).
https://doi.org/10.1007/978-3-540-73368-3_51

17. Beyer, D., Henzinger, T.A., Théoduloz, G.: Program analysis with dynamic precision adjustment. In: Proc.

ASE, pp. 29–38. IEEE (2008). https://doi.org/10.1109/ASE.2008.13

18. Beyer, D., Keremoglu, M.E.: CPACHECKER: A tool for conﬁgurable software veriﬁcation.

In:
https://doi.org/10.1007/

Proc. CAV, LNCS 6806, pp. 184–190. Springer
978-3-642-22110-1_16

(2011).

22

D. Beyer, N.-Z. Lee, and P. Wendler

19. Beyer, D., Keremoglu, M.E., Wendler, P.: Predicate abstraction with adjustable-block encoding. In: Proc.

FMCAD, pp. 189–197. FMCAD (2010)

20. Beyer, D., Lee, N.Z., Wendler, P.: Reproduction package for article ‘Interpolation and SAT-based model

checking revisited’. Zenodo (2022). https://doi.org/10.5281/zenodo.6700515

21. Beyer, D., Löwe, S., Wendler, P.: Reliable benchmarking: Requirements and solutions. Int. J. Softw. Tools
Technol. Transfer 21(1), 1–29 (2019). https://doi.org/10.1007/s10009-017-0469-y
22. Beyer, D., Petrenko, A.K.: Linux driver veriﬁcation. In: Proc. ISoLA, LNCS 7610, pp. 1–6. Springer

(2012). https://doi.org/10.1007/978-3-642-34032-1_1

23. Biere, A., Cimatti, A., Clarke, E.M., Zhu, Y.: Symbolic model checking without BDDs. In: Proc. TACAS,
LNCS 1579, pp. 193–207. Springer (1999). https://doi.org/10.1007/3-540-49059-0_14
24. Birgmeier, J., Bradley, A.R., Weissenbacher, G.: Counterexample to induction-guided abstraction-
reﬁnement (CTIGAR). In: Proc. CAV, LNCS 8559, pp. 831–848. Springer (2014). https://doi.org/
10.1007/978-3-319-08867-9_55

25. Bradley, A.R.: SAT-based model checking without unrolling. In: Proc. VMCAI, LNCS 6538, pp. 70–87.

Springer (2011). https://doi.org/10.1007/978-3-642-18275-4_7

26. Brückner, I., Dräger, K., Finkbeiner, B., Wehrheim, H.: Slicing abstractions. In: Proc. FSEN, LNCS 4767,

pp. 17–32. Springer (2007). https://doi.org/10.1007/978-3-540-75698-9_2

27. Calcagno, C., Distefano, D., Dubreil, J., Gabi, D., Hooimeijer, P., Luca, M., O’Hearn, P.W., Papakonstanti-
nou, I., Purbrick, J., Rodriguez, D.: Moving fast with software veriﬁcation. In: Proc. NFM, LNCS 9058,
pp. 3–11. Springer (2015). https://doi.org/10.1007/978-3-319-17524-9_1

28. Cimatti, A., Griggio, A.: Software model checking via IC3. In: Proc. CAV, LNCS 7358, pp. 277–293.

Springer (2012). https://doi.org/10.1007/978-3-642-31424-7_23

29. Cimatti, A., Griggio, A., Schaafsma, B.J., Sebastiani, R.: The MATHSAT5 SMT solver.

In:
https://doi.org/10.1007/

Proc. TACAS, LNCS 7795, pp. 93–107. Springer (2013).
978-3-642-36742-7_7

30. Clarke, E.M., Grumberg, O., Jha, S., Lu, Y., Veith, H.: Counterexample-guided abstraction reﬁnement for
symbolic model checking. J. ACM 50(5), 752–794 (2003). https://doi.org/10.1145/876638.
876643

31. Clarke, E.M., Kröning, D., Lerda, F.: A tool for checking ANSI-C programs. In: Proc. TACAS, LNCS 2988,
pp. 168–176. Springer (2004). https://doi.org/10.1007/978-3-540-24730-2_15
32. Cook, B.: Formal reasoning about the security of Amazon web services. In: Proc. CAV (2), LNCS 10981,

pp. 38–47. Springer (2018). https://doi.org/10.1007/978-3-319-96145-3_3

33. Craig, W.: Linear reasoning. A new form of the Herbrand-Gentzen theorem. J. Symb. Log. 22(3), 250–268

(1957). https://doi.org/10.2307/2963593

34. Donaldson, A.F., Haller, L., Kröning, D., Rümmer, P.: Software veriﬁcation using k-induction.
https://doi.org/10.1007/

In: Proc. SAS, LNCS 6887, pp. 351–368. Springer (2011).
978-3-642-23702-7_26

35. Donaldson, A.F., Kröning, D., Rümmer, P.: Automatic analysis of DMA races using model checking and
k-induction. FMSD 39(1), 83–113 (2011). https://doi.org/10.1007/s10703-011-0124-2
36. Flanagan, C., Qadeer, S.: Predicate abstraction for software veriﬁcation. In: Proc. POPL, pp. 191–202.

ACM (2002)

37. Ghilardi, S., Ranise, S.: Goal-directed invariant synthesis for model checking modulo theories.

In:
Proc. TABLEAUX, LNCS 5607, pp. 173–188. Springer (2009). https://doi.org/10.1007/
978-3-642-02716-1_14

38. Graf, S., Saïdi, H.: Construction of abstract state graphs with PVS. In: Proc. CAV, LNCS 1254, pp. 72–83.

Springer (1997). https://doi.org/10.1007/3-540-63166-6_10

39. Heizmann, M., Hoenicke, J., Podelski, A.: Reﬁnement of trace abstraction. In: Proc. SAS, LNCS 5673, pp.

69–85. Springer (2009). https://doi.org/10.1007/978-3-642-03237-0_7

40. Heizmann, M., Hoenicke, J., Podelski, A.: Software model checking for people who love au-
tomata. In: Proc. CAV, LNCS 8044, pp. 36–52. Springer (2013). https://doi.org/10.1007/
978-3-642-39799-8_2

41. Henzinger, T.A., Jhala, R., Majumdar, R., McMillan, K.L.: Abstractions from proofs. In: Proc. POPL, pp.

232–244. ACM (2004). https://doi.org/10.1145/964001.964021

42. Henzinger, T.A., Jhala, R., Majumdar, R., Sutre, G.: Lazy abstraction. In: Proc. POPL, pp. 58–70. ACM

(2002). https://doi.org/10.1145/503272.503279

43. Jhala, R., Majumdar, R.: Software model checking. ACM Computing Surveys 41(4) (2009). https:

//doi.org/10.1145/1592434.1592438

44. Jhala, R., McMillan, K.L.: Interpolant-based transition relation approximation. In: Proc. CAV, LNCS 3576,

pp. 39–51. Springer (2005). https://doi.org/10.1007/11513988_6

Interpolation and SAT-Based Model Checking Revisited

23

45. Jovanovic, D., Dutertre, B.: Property-directed k-induction. In: Proc. FMCAD, pp. 85–92. IEEE (2016).

https://doi.org/10.1109/FMCAD.2016.7886665

46. Kahsai, T., Tinelli, C.: PKIND: A parallel k-induction based model checker. In: Proc. Int. Workshop
on Parallel and Distributed Methods in Veriﬁcation, EPTCS 72, pp. 55–62. EPTCS (2011). https:
//doi.org/10.4204/EPTCS.72.6

47. Khoroshilov, A.V., Mutilin, V.S., Petrenko, A.K., Zakharov, V.: Establishing Linux driver veriﬁcation
process. In: Proc. Ershov Memorial Conference, LNCS 5947, pp. 165–176. Springer (2009). https:
//doi.org/10.1007/978-3-642-11486-1_14

48. Komuravelli, A., Gurﬁnkel, A., Chaki, S., Clarke, E.M.: Automatic abstraction in SMT-based unbounded
software model checking. In: Proc. CAV, LNCS 8044, pp. 846–862. Springer (2013). https://doi.
org/10.1007/978-3-642-39799-8_59

49. Kröning, D., Weissenbacher, G.: Interpolation-based software veriﬁcation with Wolverine.

In:
https://doi.org/10.1007/

Proc. CAV, LNCS 6806, pp. 573–578. Springer
978-3-642-22110-1_45

(2011).

50. Lange, T., Neuhäußer, M.R., Noll, T.: IC3 software model checking on control ﬂow automata. In: Proc.

FMCAD, pp. 97–104 (2015)

51. McMillan, K.L.: Interpolation and SAT-based model checking. In: Proc. CAV, LNCS 2725, pp. 1–13.

Springer (2003). https://doi.org/10.1007/978-3-540-45069-6_1

52. McMillan, K.L.: Lazy abstraction with interpolants. In: Proc. CAV, LNCS 4144, pp. 123–136. Springer

(2006). https://doi.org/10.1007/11817963_14

53. McMillan, K.L.: Lazy annotation for program testing and veriﬁcation. In: Proc. CAV, LNCS 6174, pp.

104–118. Springer (2010). https://doi.org/10.1007/978-3-642-14295-6_10

54. McMillan, K.L.: Interpolation and model checking. In: Handbook of Model Checking, pp. 421–446.

Springer (2018). https://doi.org/10.1007/978-3-319-10575-8_14

55. McMillan, K.L., Rybalchenko, A.: Computing relational ﬁxed points using interpolation. Tech. Rep.

MSR-TR-2013-6, Microsoft Research (2013)

56. Sery, O., Fedyukovich, G., Sharygina, N.: Interpolation-based function summaries in bounded model
checking. In: Proc. HVC, LNCS 7261, pp. 160–175. Springer (2011). https://doi.org/10.1007/
978-3-642-34188-5_15

57. Vizel, Y., Grumberg, O.: Interpolation-sequence based model checking. In: Proc. FMCAD, pp. 1–8. IEEE

(2009). https://doi.org/10.1109/FMCAD.2009.5351148

