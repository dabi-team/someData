Type-Directed Program Synthesis for RESTful APIs

Zheng Guo
UC San Diego
USA
zhg069@ucsd.edu

Jean Yang
Akita Software
USA
jean@akitasoftware.com

David Cao
UC San Diego
USA
dmcao@ucsd.edu

Cole Schlesinger
Akita Software
USA
cole@akitasoftware.com

Davin Tjong
UC San Diego
USA
dtjong@ucsd.edu

Nadia Polikarpova
UC San Diego
USA
npolikarpova@ucsd.edu

2
2
0
2

r
p
A
5

]
L
P
.
s
c
[

2
v
7
9
6
6
1
.
3
0
2
2
:
v
i
X
r
a

Abstract

With the rise of software-as-a-service and microservice ar-
chitectures, RESTful APIs are now ubiquitous in mobile and
web applications. A service can have tens or hundreds of
API methods, making it a challenge for programmers to find
the right combination of methods to solve their task.

We present APIphany, a component-based synthesizer
for programs that compose calls to RESTful APIs. The main
innovation behind APIphany is the use of precise semantic
types, both to specify user intent and to direct the search.
APIphany contributes three novel mechanisms to overcome
challenges in adapting component-based synthesis to the
REST domain: (1) a type inference algorithm for augment-
ing REST specifications with semantic types; (2) an efficient
synthesis technique for “wrangling” semi-structured data,
which is commonly required in working with RESTful APIs;
and (3) a new form of simulated execution to avoid executing
APIs calls during synthesis. We evaluate APIphany on three
real-world APIs and 32 tasks extracted from GitHub reposi-
tories and StackOverflow. In our experiments, APIphany
found correct solutions to 29 tasks, with 23 of them reported
among top ten synthesis results.

CCS Concepts: • Software and its engineering → Auto-
matic programming.

Keywords: Program Synthesis, RESTful API, Type Inference

ACM Reference Format:
Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger,
and Nadia Polikarpova. 2022. Type-Directed Program Synthesis for
RESTful APIs. In Proceedings of the 43rd ACM SIGPLAN International
Conference on Programming Language Design and Implementation

Permission to make digital or hard copies of part or all of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. Copyrights for third-
party components of this work must be honored. For all other uses, contact
the owner/author(s).
PLDI ’22, June 13–17, 2022, San Diego, CA, USA
© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9265-5/22/06.
https://doi.org/10.1145/3519939.3523450

(PLDI ’22), June 13–17, 2022, San Diego, CA, USA. ACM, New York,
NY, USA, 27 pages. https://doi.org/10.1145/3519939.3523450

1 Introduction

Software-as-a-service has emerged as a widely-used means
for developers to leverage third-party software. Developers
might send requests to Stripe to handle payments or inte-
grate with Slack to publish notifications, all while making
use of cloud providers to provision various form of storage
and compute. According to recent industry surveys, more
than 80% of respondents’ services offer RESTful APIs [26, 30],
and these APIs are extensive. Slack, for example, has 174
API methods as of version 1.5.0. Amazon Web Services of-
fers over two hundred products and services, each with
tens or hundreds of API methods. Even with comprehensive
documentation—which is by no means guaranteed—using a
new service can be a daunting proposition.

As an example, consider a question posed on StackOver-
flow about the Slack API: How do I retrieve all member
emails from a Slack channel with a given name? The answer
is surprisingly complicated:

1. First, call conversations_list

1 to retrieve the array of all
channel objects, and then search for a channel object
with a given name and get its ID;

2. Next, call conversations_members on the channel ID to

get all user IDs of its members;

3. Finally, for each user ID, call users_info to retrieve
a user object u, and then access the user’s email via
u.profile.email.

To come up with this solution, one must be familiar with
channel objects, user objects, and three different API methods.
Component-based program synthesis [8, 14, 18, 21] has
been previously used to help programmers navigate APIs
in Java, Scala, and Haskell. Component-based synthesizers
take as input a type signature and (in most cases) a set of
input-output examples, and return a list of program snippets
that compose API calls and have the desired type and input-
output behavior. This is a powerful approach for navigating

1We shorten method names for brevity and elide the distinction between
REST methods and endpoints, irrelevant in this context.

 
 
 
 
 
 
PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Figure 1. Overview of APIphany

APIs, because it allows developers to start with information
easily at hand—the types of inputs they have and the out-
puts they desire—and requires no knowledge of which API
methods to apply.
Challenges. Unfortunately, there are three significant chal-
lenges in applying component-based synthesis to RESTful
APIs. First, component-based synthesis relies on types both
for expressing user intent and for efficient search, but types
in REST APIs are quite shallow. For example, in the Slack
API specification, both channel names and emails have type
String, so our example, which transforms a channel name
into an array of emails, would have a very imprecise type
signature String → [String].

Second, RESTful APIs commonly transmit semi-structured
data, i.e. arrays of objects, which may themselves contain
nested objects and arrays. As a result, using an API is often
not as simple as sequencing together a handful of method
calls; instead, the calls must be interleaved with “data wran-
gling” operations such as projections, maps, and filters. These
data wrangling operations are challenging for component-
based synthesis: they are extremely generic, and hence sig-
nificantly expand the search space.

Finally, to compensate for the inherent ambiguity of types,
component-based synthesis typically relies on executing can-
didate program snippets and matching them against user-
provided input-output examples. In a software-as-a-service
environment, this is a complete non-starter: not only is the
user generally unaware of the internal state of the service
and hence unable to provide accurate examples, but exe-
cuting API calls during synthesis can also be prohibitively
expensive due to rate limits imposed by the services and,
even more importantly, can have unrecoverable side effects,
such as deleting accounts or publishing messages.
APIphany: synthesis with semantic types. Our core in-
sight is that type-based specifications are actually a good fit
for REST APIs, as long as the types are more fine-grained.

In our example, if the Slack API had dedicated types for
Channel.name and Profile.email, the programmer could spec-
ify their intent as the type Channel.name → [Profile.email].
Although this specification is still somewhat ambiguous,
intuitively it has enough information to narrow down the
synthesis results to a manageable number such that the pro-
grammer can manually inspect the remaining solutions. We
refer to such fine-grained types as semantic types.

In this paper, we present APIphany, a component-based
synthesizer for REST APIs guided by semantic types. Fig. 1
shows a high-level overview of our approach, which is struc-
tured into two phases: (1) the analysis phase infers semantic
type annotations for a given API; (2) the synthesis phase uses
these type annotations to perform component-based synthe-
sis. For the Slack API, APIphany is able to infer, for example,
that the method conversations_members has the semantic type
Channel.id → [User.id]. At synthesis time, given the type
query Channel.name → [Profile.email], APIphany returns a
ranked list of programs of this type, where the desired solu-
tion (shown in Fig. 2) appears among the top ten. APIphany’s
output is expressed in a compact DSL inspired by Haskell’s
monadic do-notation and Scala’s for-comprehensions, which,
however, can be easily translated into the user’s language of
choice for communicating with the API.
Contributions. We present the design, implementation, and
evaluation of APIphany, including:

1. Type mining (Sec. 4), a technique that infers semantic
types from a set of witnesses (observed invocations of
API methods). Witnesses can be generated in a sandbox
or by tapping live production traffic; in either case, they
are collected ahead of time, once per API, which avoids
inducing side effects during synthesis.

2. Efficient synthesis of wrangling operations for semi-
structured data via array-oblivious search (Sec. 5), which
omits challenging array operations during search, and
recovers them later via type-directed lifting.

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

1 \channel_name → {

c ← conversations_list()
if c.name = channel_name
uid ← conversations_members(channel=c.id)
let u = users_info(user=uid)

return u.profile.email

2

3

4

5

6

7 }

Figure 2. Solution for retrieving all member emails from a
Slack channel in APIphany DSL.

3. Ranking synthesis results with the help of retrospective
execution (Sec. 6), a type of simulated execution using
previously collected witnesses. Retrospective execu-
tion helps APIphany weed out uninteresting programs
(e.g. programs that always return an empty array), re-
ducing the number of synthesis results the user has to
inspect to find their expected solution.

We evaluate APIphany on three real-world APIs, and 32
tasks extracted from GitHub repositories and StackOver-
flow (Sec. 7). Our evaluation shows that APIphany can
find solutions to the majority of tasks (29/32) within 150
seconds. Moreover, semantic types are crucial to its effec-
tiveness: without type mining, APIphany can only solve
four tasks. Finally, ranking significantly improves the qual-
ity of reported solutions, increasing the number of correct
solutions appearing in top ten results from 12/29 to 23/29.

2 APIphany by Example

In this section we use the task of retrieving all member emails
in a Slack channel as a running example to illustrate the
APIphany workflow depicted in Fig. 1.

2.1 API Analysis by Example

API analysis is performed once per API. It takes as input a
spec in the popular OpenAPI format2 and a set of witnesses
(successful API method calls); it produces a spec annotated
with semantic types. OpenAPI specs are publicly available
for most popular APIs.3 Witnesses can be generated in a
number of ways, for example, by running an integration test
suite in a sandbox or by passively listening to production API
traffic. We envision witness collection and API analysis be-
ing performed by the API maintainer (or another interested
party), not by regular users of the APIphany synthesizer.
OpenAPI specs. Fig. 3 shows a fragment of the OpenAPI
spec provided by Slack. An OpenAPI spec consists of object
definitions and method definitions. We show definitions of
three objects, user, profile and channel, and two methods,
users_info and conversations_list, relevant to our example.

2https://swagger.io/. APIphany supports both OpenAPI v2 and v3.
3Slack OpenAPI spec is available at: https://raw.githubusercontent.com/sl
ackapi/slack-api-specs/master/web-api/slack_web_openapi_v2.json

As you can see, the spec does provide precise type infor-
mation for some of the locations: for example, the response
of users_info clearly has type User (it is annotated with a
reference to the corresponding object definition). The bulk
of the locations, however, such as the field user.id or the
parameter of users_info, are simply annotated with String,
which is not very helpful for the purposes of type-directed
synthesis. Our goal is to replace these String annotations
with more fine-grained types.
Mining types from witnesses. To this end, we build upon
an algorithm first proposed in [1] that infers types by mining
them from execution traces, based on the insight that equal
values observed at different locations likely have the same
type. More specifically, our type mining algorithm starts by
ascribing a unique semantic type to each String location and
then merges locations that share a value anywhere in the
witness set. As an illustration, consider Fig. 4, which lists two
witnesses for the API methods from our running example.
In this witness set we observe the same value "UJ5RHEG4S"
in three locations: (1) the parameter of users_info, (2) the id
field of a User object (we know from the spec that users_info
returns a User), and (3) the creator field of a Channel object (we
know from the spec that conversations_list returns an array
of Channels). Hence we merge all three locations into the
same semantic type. For presentation purposes, we assign
the name User.id to this type, which is derived from location
(2) above. The choice of name is not important, however:
the user is free to refer to this semantic type via any of its
representative locations; for example, Channel.creator also
denotes the same type.

2.2 Program Synthesis by Example

The program synthesis phase of APIphany is meant to be
used by regular programmers, any time they need help ac-
complishing a task with one of the supported APIs. The pro-
grammer queries APIphany with a type signature built from
semantic types. Although the UI for constructing queries is
beyond the scope of this paper, we envision the program-
mer browsing object definitions and selecting relevant fields
as semantic types. For our running example, the program-
mer knows that they need to go from a channel name to
an array of user emails; they might first look through the
channel object definition and find the name field; they might
then search globally for a field called email and find it in-
side the profile object; hence they settle on the type query
Channel.name → [Profile.email].

The program synthesis phase itself comprises two steps,
beginning with a program search step to generate a list of
candidate programs with a given type, followed by a ranking
step to identify promising candidates (described in Sec. 2.3).
Challenge: components meet control flow. Given the type
query Channel.name → [Profile.email], how would APIphany
go about enumerating all programs of this type? This task

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Figure 3. Fragment of the Slack API’s OpenAPI specification. (left) Definitions of user, profile and channel objects. (right)
Parameters and responses of the methods users_info and conversations_list.

\channel_name → {

\channel_name → {

c ← conversations_list()
if c.name = channel_name

c ← conversations_open()

if c.name = channel_name

let uid = c.creator
let u = users_info(user=uid)

let uid = c.creator
let u = users_info(user=uid)

return u.profile.email

return u.profile.email

}

}

Figure 5. A sample of incorrect candidate solutions.

program above using existing TTN-based techniques, we can
synthesize an array-oblivious version of this program, where
we pretend that conversations_members returns a single User.id
instead of an array, and hence we can simply sequence the
two method calls, without monadic binding:

4 let uid = conversations_members(channel=c.id);

5 let u

= users_info(user=uid);

6 u.profile.email

To transform an array-oblivious program into the final
solution, APIphany lifts it into a comprehension by replac-
ing each let binding that causes a type mismatch with a
monadic bind. In our example, the let in line 4 causes a type
error (because conversations_members returns [User.id], while
users_info expects a single User.id), while the let in line 5
does not (since users_info returns a single User); hence lifting
replaces the first let-binding with ← but not the second.

2.3 Ranking via Retrospective Execution

Although semantic types are less ambiguous than primi-
tive types for expressing user intent, they are still not precise
enough to exactly identify the desired program. For example,
our synthesizer generates more than 1000 candidates for the
type signature Channel.name → [Profile.email]; clearly, it is
infeasible for the user to manually go through all of them.
Hence, APIphany must be able to rank the candidates in
order to show the user a small number of likely solutions.

Fortunately, most of the 1000 candidates are easy to weed
out because they produce uninteresting results. Consider

Figure 4. Witnesses for two Slack API methods. Arrows
connect equal values observed at different locations. Type
mining ascribes the type User.id to all the boxed locations.

presents a challenge to existing synthesis techniques because
our candidate programs have both a large component library
to choose from—from dozens to hundreds of methods—and
non-trivial control flow—e.g. the solution to our running
example has to loop over the members of a channel. One
line of prior work that scales to large component libraries is
graph-based search using type-transition nets (TTNs) [8, 12];
unfortunately, this approach can only generate sequences of
method calls, and does not support loops.
The APIphany DSL. We observe that the loops we need
for manipulating semi-structured data are restricted to it-
erating over (possibly nested) arrays of objects. To capture
this restricted class of programs we have designed a DSL
inspired by Scala’s for-comprehensions, Haskell’s monadic
do-notation, and LINQ [22]. The solution to our running exam-
ple in this DSL is given in Fig. 2. In this language, iteration
over an array is expressed using the monadic bind operation
(written ←). For example, the second bind in Fig. 2 has the
effect of performing the subsequent computation for every
element uid of the array returned in line 4:

4 uid ← conversations_members(channel=c.id);
5 let u = users_info(user=uid);

6 return u.profile.email

Array-oblivious search. The main idea behind APIphany’s
search is that although we cannot directly synthesize the

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

two of the candidates depicted in Fig. 5, which differ from
our desired solution (Fig. 2) in the highlighted fragments: the
first program returns the email of the channel’s creator (as
opposed to all of its members), and the second one gets the
list of channels from conversations_open, which is intended
for opening a direct message channel. It turns out that the
second program always fails at run time, because a successful
call to conversations_open requires providing exactly one of
its two optional arguments (a channel ID or a list of users).
The first program executes successfully, but it always returns
a single email, while the user asked for an array of emails.
For these reasons, both of these programs are less likely to
be the intended solution than the program in Fig. 2, which
successfully returns multiple emails at least sometimes.

A natural idea is to test all candidate programs on ran-
dom inputs and rank them based on the results they produce.
Unfortunately, as we have hinted above, there are several bar-
riers to systematically executing many candidate programs
that make calls to REST APIs. First, most REST APIs set a
rate limit on how frequently a user can make method calls
or how many calls a user can make in a day. Second, many
REST API methods are side-effecting. Unlike a self-contained
binary, a remotely-hosted service cannot be restarted from a
clean state for each execution.

Retrospective execution. We propose retrospective execu-
tion (RE) as an efficient, non-side effecting alternative to
program execution. The main idea is to simulate execution
by “replaying” witnesses collected for the API analysis phase.
When evaluating a candidate program, rather than executing
an API call, RE instead searches for a matching witness and
substitutes its response at the call site. If done naively, how-
ever, this process almost always yields failure or an empty
array; so making RE useful for ranking purposes requires
explicitly biasing execution towards meaningful results.

As an illustration, consider executing the program in Fig. 2
using the witnesses in Fig. 4. As the first step, we simulate the
call to conversations_list using the first witness; the response
is an array of channels with names "general", "private-test",
and "team". The second step is to filter this array, retaining
only those channels whose name is equal to the input parame-
ter channel_name. If we had sampled the value for channel_name
eagerly, before running the program, we could scarcely have
chosen one of the three names actually present in the array,
so the filtering step (and hence the whole program) would
almost always return an empty array. Instead we sample the
value for channel_name lazily, once we encounter the filter,
picking one of the names present in the array.

Assume that we picked channel_name = "general", and hence
the filter returns the first channel. Next, we simulate the call
to conversations_members on this channel’s ID. Because our
witness set is sparse, we may or may not find an exact match
for this call; in the latter case, we sample the response from
the set of approximate matches, i.e. witnesses with the same

𝑜 ::= User | Channel | . . .
𝑓 ::= u_info | . . .
𝑙 ::= in | out | 0 | id | name | . . .
ℓ ::= 𝑙 |?𝑙
loc ::= 𝑜.𝑙 | 𝑓 .𝑙

object names
method names
field labels
record fields
locations

Terms

𝑒 ::=

Expressions
variable, projection

| 𝑥 | 𝑒.𝑙
| 𝑓 (𝑙𝑖 = 𝑒𝑖 ) | let 𝑥 = 𝑒; 𝑒 method call, pure binding
| if 𝑒 = 𝑒; 𝑒 | 𝑥 ← 𝑒; 𝑒
| return 𝑒

guard, monadic binding
pure value lifting
Top Level Programs

E ::= 𝜆𝑥 .𝑒

Values

𝑣 ::= "..." | [𝑣] | {𝑙𝑖 = 𝑣𝑖 }

strings, arrays, objects

Types

𝑡 ::=

| String
| 𝑜 | [𝑡] | {ℓ𝑖 : 𝑡𝑖 }

𝑠 ::= 𝑡 → 𝑡
ˆ𝑡 ::=

| {loc}
| 𝑜 | [ˆ𝑡] | {ℓ𝑖 : ˆ𝑡𝑖 }

ˆ𝑠 ::= ˆ𝑡 → ˆ𝑡

Syntactic types
strings
named objects, arrays, records
function types
Semantic types
loc-sets
named objects, arrays, records
function types

Libraries

Λ ::= 𝑜 : 𝑡; 𝑓 : 𝑠
ˆΛ ::= 𝑜 : ˆ𝑡; 𝑓 : ˆ𝑠

object and method definitions
semantic definitions

Figure 6. Syntax of the language 𝜆𝐴

method names and argument names,4 but not necessarily
the same argument values. Due to approximate matching,
RE results do not always equal the results of a real execution,
but they are still useful for estimating whether a program
candidate is able to produce meaningful outputs. For each
candidate, we run RE multiple times (with different random
seeds) and use the outputs to assign a rank to each candidate.

3 The Core Language

In this section, we formalize the core of APIphany’s DSL as
𝜆𝐴, a functional language specialized for manipulating semi-
structured data. The syntax of 𝜆𝐴 is summarized in Fig. 6.
Types. The types of 𝜆𝐴 include syntactic types 𝑡 (those used
in the OpenAPI spec) and semantic types ˆ𝑡, which we infer.
Both categories of types have named objects 𝑜, arrays [𝑡],
and records {ℓ𝑖 : 𝑡𝑖 }.5 Records are mappings from field labels
to types; some fields are optional, indicated with a ? before its
label. For example, the record type {id : String, ?time_zone :
String}, has a required field id and an optional field time_zone.

4Because in REST some arguments are optional, the same method can be
called with different subsets of arguments.
5We write 𝑋 to denote zero or more occurrences of a syntactic element 𝑋 .

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

The two categories of types differ in their base types: the sole
primitive syntactic type is String,6 while the sole primitive
semantic type is a loc-set, i.e. a set of locations.

A location is an object or method name followed by a
sequence of labels, such as User.id. Apart from field labels
that correspond to object fields in the OpenAPI spec, we
introduce three reserved labels—in, out, and 0—for address-
ing method parameters and responses, and array elements,
respectively. For example, c_list.out.0 refers to an element
type of the response array of the method c_list.

Function types are written 𝑡 → 𝑡, and multiple arguments
are represented as a record whose fields encode argument
names (with optional fields encoding optional arguments).
A library Λ models an OpenAPI spec. It contains object
definitions, which bind object identifiers to (record) types,
and method definitions, which bind method names to func-
tion types. A semantic library ˆΛ, which is the output of type
mining, binds object identifiers and method names to se-
mantic types. As an example, Fig. 7 shows Λ definitions that
correspond to a portion of the Slack OpenAPI spec (with
method names shortened for brevity), and their correspond-
ing definitions in the semantic library ˆΛ.
Terms. Values of 𝜆𝐴 include string literals, arrays, and ob-
jects; objects are mappings from field labels to values. Simi-
larly to Haskell’s do-notation, return e returns an array with
a single element 𝑒, and the monadic binding 𝑥 ← 𝑒1; 𝑒2 evalu-
ates 𝑒2 for each element 𝑥 of the array 𝑒1, and concatenates all
resulting arrays. In contrast, the pure binding let 𝑥 = 𝑒1; 𝑒2
binds 𝑥 to the entire result of 𝑒1 and then evaluates 𝑒2. The
guard expression if 𝑒1 = 𝑒2; 𝑒 evaluates 𝑒 if the guard holds
and returns an empty array otherwise; guards are restricted
to equalities, since these are the only guards generated by
APIphany. At the top level, a program E is an abstraction
with a list of arguments 𝑥 and body 𝑒.

4 Type Mining

In this section we detail APIphany’s type mining algorithm,
using the library Λ in Fig. 7 and the witnesses in Fig. 4 as a
running example. Informally, the idea is to first assign every
String location loc in Λ a unique type {loc}, and then merge
the types of some locations based on the witnesses.
Assigning location-based types. We formalize the first step
as a judgement Λ ⊢ loc =⇒ ˆ𝑡, which assigns a semantic type
ˆ𝑡 to location loc based only on the information present in the
syntactic library Λ. The reader might be wondering why isn’t
the assigned type ˆ𝑡 always simply {loc}. This is indeed the
case for String-annotated locations explicitly present in Λ,
such as User.id or u_info.in.user. But in other cases, location-
based type assignment is more involved; for example:

• Λ ⊢ u_info.out =⇒ User because this location is anno-

tated with a named object type.

6In practice, REST APIs also include integers and booleans; these types are
handled slightly differently in APIphany, as discussed in Sec. 7.4.

• Λ ⊢ c_members.out =⇒ [{c_members.out.0}] because ar-
ray types do not themselves get replaced with loc-sets;
instead, we recursively assign a location-based type to
an array’s element.

• Λ ⊢ u_info.out.id =⇒ {User.id} because type assign-
ment canonicalizes locations inside types to make sure
they explicitly appear in Λ; to this end, we recursively
assign a type to location’s prefix, Λ ⊢ u_info.out =⇒
User, and then follow the field id of the User object.

The formalization of location-based type assignment is mostly
straightforward and relegated to Appendix A (Fig. 15).

Merging types via a disjoint-set. Type mining relies on
a variant of the disjoint-set data structure (also known as
union-find [31]). Our disjoint-set 𝐷𝑆 stores disjoint groups
of pairs (loc, 𝑣), where loc is a location and 𝑣 is a string value.
When two pairs are in the same group, their corresponding
locations have the same semantic type.

DS supports two efficient operations: insert and find. insert
takes a pair (loc, 𝑣) and checks whether either of its compo-
nents already appears in DS; if so, it merges the new pair
into the corresponding group, and otherwise puts it into a
new group. find takes a location loc and returns a semantic
type ˆ𝑡; internally, find locates the group to which the pair
(loc, _) belongs in DS and returns the loc-set {loc, loc1, . . .}
that contains all locations in that group.

Type mining algorithm. Fig. 8 presents the top-level algo-
rithm MineTypes, which takes as input a syntactic library
Λ and a set of witnesses W, and returns a semantic library
ˆΛ. A witness 𝑊 is a triple ⟨𝑓 , 𝑣𝑖𝑛, 𝑣𝑜𝑢𝑡 ⟩, where 𝑓 is a method
name and 𝑣𝑖𝑛, 𝑣𝑜𝑢𝑡 are its argument and response value (mul-
tiple arguments are represented as an object). MineTypes
operates in two phases: in lines 2–5 it builds the disjoint-set
DS from W and in line 6 it build ˆΛ from DS.

In the first phase, the algorithm iterates over the witnesses,
registering the input value 𝑣𝑖𝑛 at the location 𝑓 .in and the
output value 𝑣𝑜𝑢𝑡 at the location 𝑓 .out. To this end, we call a
helper function AddWitness, which drills down into com-
posite values (arrays and objects) to get to string literals,
and then inserts each string into DS with its location-based
type. For example, when processing the response from the
first witness in Fig. 4, AddWitness iterates over all chan-
nel objects in the array, and over all fields of each chan-
nel object; once it reaches the value "UJ5RHEG4S", it com-
putes the type of its location as Λ ⊢ c_list.out.0.creator =⇒
{Channel.creator}, and inserts (Channel.creator, "UJ...") into
DS. Processing the second witness results in inserting the
pairs (u_info.in.user, "UJ...") and (User.id, "UJ..."), which
share the same string value, and hence all three pairs get
merged into the same group. Once all the witnesses are added
to DS, its groups represent the final set of semantic types.

In the second phase, the algorithm calls AddDefinitions
to iterate over all object and method definitions in Λ, and

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Syntactic library Λ

Semantic library ˆΛ

Channel: { id: String,

Channel: { id: Channel.id ,

name: String,

creator: String }

name: Channel.name ,

creator: User.id }

User: { id: String,

User: { id: User.id ,

name: String,

profile: Profile }

name: User.name ,

profile: Profile }

c_list:

{} → [Channel]

u_info:

c_list:

{} → [Channel]

u_info:

{user: String} → User

{user: User.id } → User

c_members:

c_members:

{channel: String} → [String]

{channel: Channel.id } → [ User.id ]

s
t
c
e
j
b
O

s
d
o
h
t
e
M

Figure 7. Library Λ that models a portion of the Slack OpenAPI spec and the
corresponding semantic library ˆΛ. Each gray box is a loc-set type inferred by type
mining, depicted for brevity using a single representative location from the set.

Input: A library Λ and witnesses W
Output: A semantic library ˆΛ
1: function MineTypes(Λ, W)
2: DS ← empty disjoint-set
for ⟨𝑓 , 𝑣𝑖𝑛, 𝑣𝑜𝑢𝑡 ⟩ ∈ W do
3:
4:
5:

AddWitness(DS, 𝑓 , in, 𝑣𝑖𝑛)
AddWitness(DS, 𝑓 , out, 𝑣𝑜𝑢𝑡 )

6:
7:

ˆΛ ← AddDefinitions(Λ, DS)
return ˆΛ

8: function AddWitness(DS, loc, 𝑣)
9: match 𝑣
10:
11:
12:

Λ ⊢ loc =⇒ {loc′}
DS ← insert(DS, loc′, 𝑣)

case "...":

13:
14:

15:
16:

case [𝑣𝑖 ]:

forall 𝑖 : AddWitness(DS, loc.0, 𝑣𝑖 )

case {𝑙𝑖 = 𝑣𝑖 }:

forall 𝑖 : AddWitness(DS, loc.𝑙𝑖, 𝑣𝑖 )

Figure 8. Type mining algorithm.

add corresponding definitions to ˆΛ, relying on find to re-
trieve the semantic type for each location. For example, when
adding the method u_info, we query find(DS, u_info.in.user),
which finds the group mentioned above and returns its loc-
set: {User.id, Channel.creator, . . .}. If the requested location
is not in DS—because W has no witnesses for the enclos-
ing method or object—it is annotated with the unmerged
location-based type.

5 Type-Directed Synthesis

In this section, we discuss how APIphany generates a set
of well-typed programs given a query type, using the same
running example as in previous sections.
Synthesis problem. Formally, our synthesis problem is de-
fined by a semantic library ˆΛ and a semantic query type ˆ𝑠.
For our running example, we use the semantic library from
Fig. 7 and the query type Channel.name → [Profile.email].7 A
candidate solution is any program E that type-checks against
ˆ𝑠. To formalize this notion, we introduce the program typing
judgment ˆΛ ⊢ E :: ˆ𝑠, which is mostly straightforward. We
note only that in a monadic binding 𝑥 ← 𝑒1; 𝑒2, both 𝑒1 and
𝑒2 must have array types; in a guard if 𝑒1 = 𝑒2; 𝑒, 𝑒 must
have an array type, while 𝑒1 and 𝑒2 must have (the same) loc-
set type, since equality is only supported over string values.
Full definition can be found in Appendix B (Fig. 16).
Type transition nets. To efficiently enumerate well-typed
programs we follow prior work [8, 12] and encode the search
space as a special kind of Petri net, called type-transition
net (TTN). Intuitively, a TTN encodes how each API method

7Here and throughout this section, we write loc-set types using an arbitrarily
chosen representative; the user can query APIphany using any locations of
their choosing, and the tool interprets them as the loc-sets they belong to.

transforms values of one semantic type into another; e.g.
u_info transforms a User.id into a User. Fig. 9 shows a TTN for
our running example. Places (circles) correspond to semantic
types, transitions (rectangles) correspond to methods, and
edges connect methods with their input and output types.
In addition to API methods, the TTN contains transitions
that correspond to 𝜆𝐴 projections (e.g. projUser.profile and
projProfile.email) and guards (e.g. filterChannel.name).
Array-oblivious search. For our search space encoding to
be useful, we need to make sure that every well-typed 𝜆𝐴
program corresponds to a path in the TTN. This is where
we encounter a challenge: there is no straightforward way
to encode 𝜆𝐴’s monadic bind operation into the TTN. Al-
though prior work on Hoogle+ [12] supports higher-order
functions, the arguments to those functions are syntactically
restricted to variables (i.e. inner lambda abstractions are not
supported), which is insufficient for our purposes. To address
this problem, we introduce a new, array-oblivious TTN en-
coding, which does not distinguish between array types and
types of their elements, and hence does not require monadic
binds. For example, in Fig. 9 c_members returns User instead of
[User], and hence its output can be passed directly to u_info,
without iterating over it.
Search in the TTN. Once the TTN is built, we enumerate
paths from the input to the output type (or rather, array-
oblivious versions thereof). In our example, we place a to-
ken in the input type Channel.name and search for a path (a
sequence of transitions) that would get this token to the out-
put type Profile.email, possibly generating and consuming
extra tokens along the way. The bold path in Fig. 9 corre-
sponds to our desired solution from Fig. 2. On this path, we
first fire the transition c_list (which does not consume any

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Input: Semantic library ˆΛ query type ˆ𝑠
Output: Set of candidate solutions E

1: function Synthesize( ˆΛ, ˆ𝑠)
2: N ← BuildTTN( ˆΛ)
3:
4:
5:
6:

𝐼, 𝐹 ← PlaceTokens(ˆ𝑠)
for 𝜋 ∈ Paths(N, 𝐼, 𝐹 ) do
for E ∈ Progs(𝜋) do
yield Lift( ˆΛ, ˆ𝑠, E)

Figure 10. Synthesis algorithm

Figure 9. A fragment of the type-transition net (TTN) for Slack. Places (circles) are
semantic types; transitions (rectangles) are API methods and data transformations.
The bold path represents the solution to our running example.

tokens) to produce an extra token in Channel. Next, we fire
filterChannel.name, which consumes the two tokens in Channel
and Channel.name, and produces a single token in Channel. The
remaining five transitions on the bold path simply move this
one token along until it reaches Profile.email.

Like in prior work [8, 12], a path is only considered valid if
the final state contains exactly one token in the output type
(and no tokens in any other types); this condition ensures
that the generated programs use all their inputs.

Synthesis algorithm. APIphany’s top-level synthesis algo-
rithm is depicted in Fig. 10. The algorithm first constructs
a TTN N and encodes the query type ˆ𝑠 as an initial and
final token placement, 𝐼 and 𝐹 ; it then enumerates all paths
from 𝐼 to 𝐹 in N in the order of length (until timeout). For
each path 𝜋, the algorithm iterates over the corresponding
array-oblivious programs E and lifts them into well-typed
𝜆𝐴 programs. The reason 𝜋 might yield multiple programs is
that the TTN does not distinguish different arguments of the
same type, and hence we must try all their combinations.

Because TTN construction and search for valid paths is
similar to prior work, we omit their detailed description and
refer an interested reader to Appendix B.

One difference worth mentioning, however, is that we use
an integer linear programming (ILP) solver to find paths in
the TTN, unlike prior approaches, which relied on SAT/SMT
solvers. We found that although both solvers are equally
quick at finding one valid path, when it comes to computing
all valid paths of a given length, the ILP solver is much more
efficient, as it has native support for enumerating multiple
solutions.

Lifting array-oblivious programs. The function Progs(𝜋)
(line 5 in Fig. 10) converts a TTN path 𝜋 into a set of array-
oblivious programs in A-Normal Form (ANF). Fig. 11 (left)
shows the full array-oblivious program extracted from the
bold path in Fig. 9. As you can see from this example, array-
oblivious programs can be ill-typed: for example, the projec-
tion 𝑥1.name in line 4 does not type-check since 𝑥1 actually

1 \channel_name →

\channel_name →

2

3

4

5

6

7

8

9

10

11

12

13

let x1 = c_list({});

let x2 = x1.name;
if x2 = channel_name;

let x3 = x1.id;
let x4 = c_members(channel=x3);

let x5 = u_info(user=x4);

let x1 = c_list({});
x1' ← x1;

let x2 = x1'.name;
if x2 = channel_name;

let x3 = x1'.id;
let x4 = c_members(channel=x3);
x4' ← x4;
let x5 = u_info(user=x4');

let x6 = x5.profile;

let x6 = x5.profile;

let x7 = x6.email;

let x7 = x6.email;

let x7' = return x7

x7

x7'

Figure 11. Array-oblivious program built from the bold path
in Fig. 9 (left) and its lifted version (right).

has an array type [Channel]. What we really want this pro-
gram to do is to project name (and execute the remaining
steps in the program) for each channel in 𝑥1. This can be
accomplished by inserting a monadic binding 𝑥 ′
1 ← 𝑥1 and
using 𝑥 ′
1 instead of 𝑥1 in line 4 (and elsewhere in the program
where a non-array version of 𝑥1 is required, such as line 6).
We refer to this process of repairing type errors by inserting
monadic bindings and returns as lifting.8

The function Lift (line 6 in Fig. 10) takes as input a seman-
tic library ˆΛ, a query type ˆ𝑠, and an array-oblivious program
E, and produces a program E ′ that is well-typed at ˆ𝑠. Fig. 11
(right) depicts the result of lifting the program in Fig. 11
(left) to the query type Channel.name → [Profile.email] with
ˆΛ from Fig. 7. The full definition of lifting can be found
in Appendix B (Fig. 18). Informally, lifting type-checks the
program “line by line”, and whenever it encounters a type
mismatch (in a projection, guard, or a method argument),
it inserts the appropriate number of monadic bindings or

8A reader familiar with monads might think of the array-oblivious program
as written in the identity monad instead of the list monad, and lifting as
lifting the program back into the list monad.

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

returns in order to fix the mismatch. This is always possible
because the only kind of type mismatch we can encounter is
between an actual type [..[ˆ𝑡]..] and the expected type ˆ𝑡, or
vice versa. One thing worth noting is that we assume that
the top-level return type of the program is an array type:
since the lifted programs have top-level monadic bindings,
they can only return arrays. If the user requests a scalar re-
turn type, we take this into account at the ranking stage by
prioritizing programs that always return singleton arrays.

Completeness. Strictly speaking, array-oblivious search is
incomplete: there are multiple programs that map to the
same array-oblivious program, but lifting only returns a
single, canonical representative. For example, consider the
program in Fig. 11 (right), where we iterate over the array
x1 only once (line 3), and reuse the same “iterator" variable
x1' in lines 4 and 6. An alternative would be to iterate over
x1 the second time before line 6, effectively retrieving names
and IDs from all pairs of channels (instead of the name and
the ID belonging to the same channel). We consider this a
benign incompleteness because it is much less likely that
the user intended to loop twice over the same array. If they
did, we believe they would be able to repair the program by
hand, as we discuss in Sec. 7.4.

6 Ranking

As we mentioned in Sec. 2, the algorithm Synthesize may
generate hundreds or even thousands of well-typed candi-
date solutions, most of which, however, are uninteresting.
We now formalize how APIphany ranks these candidates
with the help of retrospective execution (RE).

Cost computation. To rank the programs, we assign them
a positive cost, and then order them from lowest to highest
cost. To compute the cost of a program E, we retrospectively
execute it multiple times, accumulating execution results in
a set res; retrospective execution is non-deterministic, and
executing a program more times lead to more precise cost
estimates. We then compute the cost of E based on its result
set res and the return type ˆ𝑡 of the query as follows:

1. The base cost is the size of E in AST nodes.
2. If res = ∅ (all executions have failed), the candidate

receives a large penalty.

3. If res = {[]} (all executions return an empty array),

the candidate receives a medium penalty.

4. Finally, we compare the values 𝑣 ∈ res with the desired
result type ˆ𝑡; recall that 𝜆𝐴 programs always return an
array, while ˆ𝑡 might or might not be an array type. We
assign a small penalty for a multiplicity mismatch, i.e.
if either ˆ𝑡 is a scalar type and any value 𝑣 has more
than one element, or ˆ𝑡 is an array type and all values
𝑣 have a single element.

Retrospective Execution

⟨W; Γ; Σ | 𝑒⟩ ⇒ 𝑣
Σ(𝑥1) = 𝑣1

𝑥1 ∈ Σ

𝑥2 ∉ Σ

⟨W; Γ; 𝑥2 ↦→ 𝑣1, Σ | 𝑒⟩ ⇒ 𝑣
⟨W; Γ; Σ | if 𝑥1 = 𝑥2; 𝑒⟩ ⇒ 𝑣

⟨W; Γ; Σ | 𝑥2⟩ ⇒ 𝑣2
𝑥1 ∉ Σ
⟨W; Γ; 𝑥1 ↦→ 𝑣2, 𝑥2 ↦→ 𝑣2, Σ | 𝑒⟩ ⇒ 𝑣
⟨W; Γ; Σ | if 𝑥1 = 𝑥2; 𝑒⟩ ⇒ 𝑣
(𝑓 , 𝑙𝑖 = 𝑣𝑖, 𝑣𝑜𝑢𝑡 ) ∈ W

∀(𝑓 , 𝑙𝑖 = 𝑣 ′

⟨W; Γ; Σ | 𝑓 (𝑙𝑖 = 𝑣𝑖 )⟩ ⇒ 𝑣𝑜𝑢𝑡
𝑖 , 𝑣𝑜𝑢𝑡 ) ∈ W. ∃𝑖 : 𝑣 ′
𝑖 , 𝑣𝑜𝑢𝑡 ) ∈ W

(𝑓 , 𝑙𝑖 = 𝑣 ′

𝑖 ≠ 𝑣𝑖

⟨W; Γ; Σ | 𝑓 (𝑙𝑖 = 𝑣𝑖 )⟩ ⇒ 𝑣𝑜𝑢𝑡

E-If-True-L

E-If-True-R

E-Method-val

E-Method-name

Figure 12. Retrospective execution.

Retrospective execution. We formalize RE as a judgement
⟨W; Γ; Σ | 𝑒⟩ ⇒ 𝑣, stating that 𝑣 is a valid result for exe-
cuting the expression 𝑒 in the environment Σ (which maps
variables to values). The judgment is also parameterized by
a type context Γ and witness set W, used to replay method
calls and sample program inputs. To run a candidate solution
E, we execute its body in an empty environment Σ = · and
with Γ storing the types of E’s arguments. As we explain in
more detail below, program inputs are selected lazily, during
execution, in order to maximize its chances of producing
meaningful results.
Replaying method calls. Most of the rules for the RE judge-
ment describe standard big-step operational semantics (they
can be found in Fig. 19 in Appendix C), but two groups of
rules, shown in Fig. 12, deserve more attention. The first
group of interest includes E-Method-Val and E-Method-
Name, which replay a method call by looking it up in W.
The rule E-Method-Val applies when W contains an exact
match for the current call, i.e. we have previously observed
a call to the same method, with the same parameter names
and parameter values. The rule E-Method-Name applies
when an exact match cannot be found (see first premise);
in this case we pick an approximate match, where only the
method name and parameter names match. Matching param-
eter names is important because many REST API methods
admit optional parameters, and behave very differently based
on which pattern of optional parameters is provided. If an ap-
proximate match cannot be found either, RE fails. Note that
for a given call 𝑓 (𝑙𝑖 = 𝑣𝑖 ), there might be multiple approx-
imate matches in W, which makes RE non-deterministic
(in fact, there can even be multiple precise matches because
services are stateful). Due to hidden state and approximate
matches, the results of RE are not guaranteed to match actual
execution, but our experiments show that they are precise
enough for the purposes of ranking.

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Table 1. APIs used in our experiments. For each API we
report the number of methods |Λ.𝑓 |, min/max number of
arguments per method 𝑛arg, the number of objects |Λ.𝑜 |, and
min/max size of the objects 𝑠obj. We also report the number of
witnesses |W| we collected for type mining and the number
of methods covered by those witnesses 𝑛cov.

API

|Λ.𝑓 |

API size
𝑛arg

|Λ.𝑜 |

Slack
Stripe
Sqare

174
300
175

0 - 15
0 - 145
0 - 20

79
399
716

API Analysis
𝑛cov

|W|

3834
25402
1749

60
124
67

𝑠obj
1 - 70
1 - 66
1 - 34

Lazy sampling of program inputs. The remaining two
rules in Fig. 12 are responsible for choosing program inputs
so as to bias guard expressions to evaluate to true. We ob-
serve that when inputs are sampled eagerly ahead of time,
guard expressions almost always evaluate to false, causing
RE to return an empty array; as a result, our ranking heuris-
tic cannot distinguish meaningful candidates from those that
return an empty array regardless of the input. To address
this issue, we postpone adding program inputs to the envi-
ronment Σ until they are used. If the first usage of a program
input is in a guard, the rules E-If-True-L and E-If-True-R
pick its value to make the guard true: E-If-True-L applies
when only the right-hand side of a guard is undefined, and
E-If-True-R applies when the left-hand side or both are un-
defined. If the first usage of an input is in a method call or a
projection, we instead randomly sample from all values of
the same type observed in W.

7 Evaluation

We implemented APIphany in Python, except for retrospec-
tive execution, where we used Rust for performance reasons.
We used the Gurobi ILP solver [13] v9.1 as the back-end for
TTN search. We ran all the experiments on a machine with
an Intel Core i9-10850K CPU and 32GB of memory.

We designed our empirical evaluation to answer the fol-

lowing research questions:
(RQ1) Can APIphany find solutions for a wide range of real-

istic tasks across multiple popular APIs?

(RQ2) Is type mining effective and necessary for enabling

type-directed synthesis?

(RQ3) Is retrospective execution effective and necessary for

prioritizing relevant synthesis results?

API selection. For our evaluation, we selected three popular
REST APIs: the Slack communication platform and two
online payment platforms, Stripe and Sqare. We selected
these APIs because they are widely used and have both an
OpenAPI specification and a web interface, which allowed
us to set up the test environment and collect witnesses easily.
As shown in Tab. 1, these APIs are quite complex: each has

over a hundred methods with up to 145 arguments; all three
feature optional arguments. The three APIs also contain a
large number of object definitions, with up to 70 fields.
Experiment setup: type mining. Recall that type mining
relies on a witness set W. Witnesses are straightforward
to collect for API owners, or when an integration test suite
is publicly available; neither was the case in our setting.
Instead, we collected witnesses by observing traffic from
the services’s web interface, and then enhancing this initial
(very sparse) witness set via random testing; this process
is described in more detail in Appendix D. As shown in
Tab. 1, we collected between 1.7K and 25K witnesses per API,
which covered 30–40% of all methods. It is hard to obtain
full coverage for these closed source APIs as an outsider, for
instance, because many methods are only available to paid
accounts; our experiments show, however, that APIphany
performs well with this witness set.
Benchmark selection. For each API, we extracted program-
ming tasks from StackOverflow questions that mention
this API as well as GitHub repositories that use the API.
After excluding the tasks that were out of scope of our DSL,
we manually translated each of the remaining tasks from a
natural-language description or a code snippet into a type
query, resulting in 32 benchmarks (see Tab. 2). Apart from
our running example (benchmark 1.1), these include, for in-
stance: “Send a message to a user given their email” in Slack
(1.2), “Create a product and invoice a customer” in Stripe
(2.3), and “Delete catalog items with given names” in Sqare
(3.10). As noted in Tab. 2, many of these tasks are effectful:
they require creating, modifying, or deleting objects.

Each benchmark comes with a “gold standard” solution:
the accepted solution on StackOverflow or the snippet we
found on GitHub. We manually translated these solutions
into APIphany’s DSL. As shown in the “Solution Size” por-
tion of Tab. 2, these solutions range in complexity from 7 to
22 AST nodes, containing up to three method calls and guards
and up to seven projections, which makes them non-trivial
for programmers to solve manually. A complete list of tasks,
type queries, and solutions can be found in Appendix E.
Experiment setup: program synthesis. For each of the 32
benchmarks, we ran the synthesizer with a timeout of 150
seconds. For each new candidate generated, we estimated its
cost using 15 rounds of RE and recorded the synthesis time
(including both TTN search and RE time). After the time-
out, we checked whether the gold standard solution appears
among the generated candidates and compared its RE-based
rank vs the original rank at which it was generated (based
on path length). Below we report average time and median
rank over three runs to reduce the impact of randomness.

7.1 RQ1: Overall Effectiveness

The last four columns of Tab. 2 detail APIphany’s perfor-
mance on the 32 synthesis benchmarks. APIphany finds the

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Table 2. Synthesis benchmarks and results. Benchmarks
marked with † are effectful. For each benchmark we report
the size of the desired solution: AST, 𝑛𝑓 , 𝑛𝑝 and 𝑛𝑔 corre-
spond to number of AST nodes, method calls, projections
and guards, respectively. We also report the time to find the
correct solution (in seconds), its rank without RE (𝑟orig), and
the lower and upper bound on its rank with RE (𝑟RE and 𝑟 TO
RE ).
‘-’ means no solution is found in 150 seconds.

API

ID

Solution Size

AST 𝑛𝑓

𝑛𝑝

𝑛𝑔

k
c
a
l
S

e
p
i
r
t
S

e
r
a
q

S

1.1
1.2†
1.3
1.4
1.5†
1.6†
1.7†
1.8
2.1†
2.2†
2.3†
2.4
2.5
2.6†
2.7
2.8
2.9
2.10†
2.11†
2.12†
2.13†
3.1
3.2
3.3
3.4
3.5†
3.6
3.7
3.8
3.9
3.10†
3.11†

17
12
16
14
10
9
12
9
9
10
12
8
8
9
5
16
6
10
7
11
10
4
16
10
5
14
5
6
9
8
16
8

3
3
3
2
2
2
2
2
2
2
3
1
2
3
1
2
1
2
2
3
3
1
1
1
1
2
1
1
1
1
2
2

6
5
7
4
3
2
4
3
2
2
2
2
2
2
2
7
2
3
1
2
2
1
4
3
2
3
2
2
3
2
5
3

1
0
0
1
0
0
1
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
3
1
0
0
0
0
0
1
1
0

Time

(sec)

83.5
5.6
-
1.3
3.4
1.7
1.3
42.0
95.4
92.4
121.2
0.5
1.0
12.2
0.6
20.2
0.5
7.8
17.2
-
-
0.2
0.5
0.4
0.7
2.2
0.2
0.3
0.7
0.2
1.9
1.0

Rank
𝑟RE

5
10
-
24
5
8
8
29
3
4
1
1
4
3
2
17
1
6
6
-
-
1
4
1
1
2
1
4
1
2
10
16

𝑟orig

25230
2224
-
489
788
573
757
16438
4952
4854
6363
3
10
270
4
679
2
187
490
-
-
2
10
6
2
99
1
7
1
3
174
68

𝑟 TO
RE
5
10
-
31
5
19
9
30
3
4
1
1
4
3
2
17
1
6
6
-
-
1
4
1
1
2
1
4
1
2
12
16

correct solution for 29 benchmarks. The remaining three
benchmarks fail with a timeout because their type queries
are too ambiguous; for example, in benchmark 1.3 (“Get un-
read messages of a user”) the type query has no means to
specify that we are only interested in unread messages; as
a result, the solution is drowned among thousands of other
programs that map a user ID to messages.

We plot the number of benchmarks solved as a function
of time (including RE) in Fig. 13. As the plot shows, majority
of benchmarks (19/32) can be solved within five seconds. On

Figure 13. Comparison of synthesis performance between
APIphany and its two variants that do not use type mining.

average APIphany takes 17.8 seconds to find the desired
solution (median time 1.3 seconds).

Takeaway: APIphany is able to solve 91% of tasks from
three real-world APIs.

7.2 RQ2: Type Mining

Recall that type mining involves replacing primitive syntactic
types in the spec with unique location-based types, and then
merging those based on the witness set to obtain semantic
types. The merging process is not perfect: it might fail to
merge two location that should have the same type because
the witness set lacks evidence to justify the merge; or it
might spuriously merge two locations if they share a value by
chance. It is hard to measure the accuracy of inferred types
directly, since we do not have an oracle for semantic types.
Instead, we evaluate type mining indirectly in two ways:
1) we run an ablation study to measure its impact on the
overall performance of the synthesizer, and 2) we perform a
small-scale qualitative analysis of inferred types.
Ablation study. For this experiment, we compare the perfor-
mance of APIphany and its two variants: (a) APIphany-Syn,
which builds the TTN directly from syntactic types, and
(b) APIphany-Loc, which builds the TTN from (unmerged)
location-based types. We plot the number of benchmarks
solved by each variant as the function of time in Fig. 13.

As expected, both variants perform poorly: APIphany-
Syn only solves 4/32 benchmarks and APIphany-Loc solves
5. All these benchmarks are “easy” (solved by APIphany in
under a second). Intuitively, the two variants represent two
extremes in terms of type granularity. Syntactic types are
too coarse-grained (all String locations have the same type),
which leads TTN search to return too many well-typed can-
didates. As a result, APIphany-Syn struggles to solve all but
the simplest tasks, with many benchmarks running out of
memory. Location-based types, on the other hand, are too
fine-grained (each String location has a unique type), which

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

leads to most desired solutions simply being ill-typed, be-
cause there is no way for one method to use values returned
by another. The solutions to all of the five benchmarks solved
by APIphany-Loc have only one method call with no pa-
rameters, followed by several projections or filters.

As you can see from Fig. 13, APIphany drastically outper-
forms both variants. This result indicates that type mining
strikes a good balance between coarse- and fine-grained
types: all 32 benchmarks have a well-typed solution in terms
of the mined types, and APIphany is able to find most of
them within a reasonable time.
Qualitative analysis. To give a more direct account of the
quality of inferred semantic types, we randomly sampled
five methods from each API (among the methods covered
by the collected witnesses), and manually inspected the in-
ferred types to check if they match our expectations. More
specifically, for each String location in a method spec, we
pick a location type loc∗, which we deem most natural for
a programmer to use in a type query (for example, for the
parameter to users_info, loc∗ = User.id); we consider the in-
ferred loc-set type sufficient if it contains loc∗. The detailed
results appear in Appendix E (Tab. 4).

In the methods we examined, type mining was able to infer
a sufficient semantic type for all responses, required param-
eters, and about half of optional parameters. The remaining
optional parameters were assigned unmerged location types,
because they were never used in our witness set. This is
almost unavoidable, because of the sheer number of obscure
optional parameters in real-world APIs (which, fortunately,
are rarely needed to solve programmer’s tasks).

Recall that the other failure mode of type mining is spuri-
ously merging unrelated locations. We did not observe any
spurious merges among the randomly sampled methods, but
anecdotally we did encounter one such merge elsewhere in
the Slack API: between Channel.name and Message.name. Note
that spurious merges might slow down the search and pro-
duce some “semantically ill-typed” solutions, but they do not
prevent APIphany from finding the desired solution.

Takeaway: Type mining increases the percentage of
solved benchmarks from 12% to 91%.

7.3 RQ3: Ranking

To measure the effectiveness of RE-based ranking, we com-
pare the last three columns of Tab. 2: 𝑟orig denotes the rank
of the desired solution in the order it was generated by TTN
search (which is based on path length, and hence correlated
with solution size); 𝑟RE denotes the RE-based rank of the
solution at the time it was generated, and 𝑟 TO
RE denotes its RE-
based rank by the timeout (which can be lower than 𝑟RE as
other candidates generated later might end up being ranked
higher). We report both of these RE-based ranks because we
envision an APIphany user inspecting the candidate solu-
tions some time between they are generated and the timeout,

Figure 14. Number of benchmarks whose solution is re-
ported within a given rank. The filled blue area is the range
of ranks one might get depending on when they inspect the
candidates. The shaded area is the 95% confidence interval.

and hence the relevant rank value is between 𝑟RE and 𝑟 TO
RE .
We plot the number of benchmarks whose solutions lie at or
below each rank in Fig. 14, with the range between 𝑟RE and
𝑟 TO
RE represented as a filled area.
As you can see from Fig. 14, RE-based ranking signifi-
cantly increases the chances that the desired solution makes
the short-list of candidates. In particular, without RE-based
ranking only 8 benchmarks (28% of solved) return the correct
solution in top five, and only 12 (41%) return it in top ten; in
contrast, with RE-based ranking, 19 (65%) benchmarks return
the correct solution in top five (after timeout), and 23 (79%)
in top ten. Moreover, as we can see from Tab. 2, the solution’s
rank never gets worse after RE, in all but two cases it strictly
improves, and for all long-running benchmarks it improves
drastically (the average rank improves from 2230.5 to 7.0).
A closer look at the six benchmarks that do not land in top
ten after RE reveals two main reasons for these suboptimal
rankings. In most cases the solution is simply large, and there
are many smaller candidates that are still meaningful. For
example, the query “Delete all catalog items" (3.11) takes no
arguments and returns an array of all deleted items; there are
many valid and simple ways to construct an array of catalog
items without deleting them. In a few cases, APIphany fails
to throw out meaningless programs due to the imprecision
of retrospective execution. For example, in 1.6 it reports a
solution that posts an update to a given channel with a given
timestamp, even though this timestamp might be invalid
for this channel; APIphany instead thinks that this call al-
ways succeeds by relying on approximate matches during
retrospective execution.

We also recorded the time APIphany takes to compute the
cost for all generated candidates (which involves executing
each candidate 15 times). Although APIphany generates
thousands of well-typed candidates for most benchmarks,
cost computation only takes about 1% of total synthesis time.

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Takeaway: RE-based ranking takes a negligible amount
of time and increases the percentage of correct solutions
reported in top ten from 41% to 79%.

7.4 Discussion and Limitations

Witness generation. One threat to validity of our evalua-
tion is that the results of type minings (and therefore synthe-
sis) depend heavily on the witness set. In particular, if our
benchmarks required methods that are not covered by the
witness set, APIphany most likely would not be able to solve
them, since they would be ill-typed with inferred semantic
types. We ran our experiments using a particular witness
set, which we collected using one methodology (described
in Appendix D); our findings might not generalize to using
APIphany with witness sets collected by other means.

Effectful methods. We observe that effectful methods in
REST APIs have an interesting property: they make the ef-
fect explicit in their response. For example, the method for
posting a message on Slack also returns the message object,
and the method for deleting a catalog item in Sqare returns
the ID of the deleted item (instead of just returning void).
This property makes REST APIs particularly suitable for type-
directed synthesis and expressing user intent with types: for
example, the query “Send a message to a user with a given
email” can be expressed as the type Profile.email → Message
instead of a much less informative type Profile.email → void.
The downside, of course, is that the return type of an ef-
fectful method might not be obvious to the user (for ex-
ample, does deleting a catalog item return an object or its
ID?) One way to overcome this limitation is to let the user
specify the name of the last method they want to call (e.g.
catalog_object_delete) instead of the output type; this kind of
specification is straightforward to integrate into TTN search.

DSL restrictions. In our search for benchmarks, we encoun-
tered (very few) snippets that were inexpressible in our DSL
because they required functional transformations on prim-
itive values, as opposed to just structural transformations
on objects and arrays, for example: “Get all members of a
channel and concatenate them together". We consider such
functional transformations beyond the scope of APIphany
because its type-based specifications are too coarse to distin-
guish between different functional transformations. This is
also the reasoning behind our design decision to only support
equality inside guards, as opposed to more general predi-
cates: if the specification cannot distinguish between, say, =
and ≤, there is little use in generating programs with both.
More generally, we view programs synthesized by APIphany
as a starting point, which helps the programmer figure out
how to plumb data through a set of API calls; we envision
the user building on top of those programs to add functional

modifications and more expressive predicates. This inter-
action model motivates both our DSL restrictions and our
type-based specifications.
Value-based location merging. Value-based merging works
well for strings, since their large domain makes it unlikely
that two String locations share a value by chance. It works
less well for other primitive types, such as integers and
booleans. To reduce the risk of spurious merges, our im-
plementation performs value-based merging only for strings
and large integers (> 1000), but not for booleans or small
integers. In the future, we plan to investigate more sophis-
ticated approaches to location merging. One idea is to use
probabilistic reasoning to estimate the likelihood of two lo-
cations having the same type based on (1) how common a
value is across locations and (2) what proportion of values is
shared between the two locations. Another approach is to
cluster locations using NLP techniques, such as sentiment
analysis of object and field names, as well as documentation.
User interface. Another important direction for future work
is to investigate usable ways of specifying semantic type
queries and comprehending synthesis results. In particular,
existing work from the HCI community [9, 10] might help
users quickly explore a large space of related candidate solu-
tions, thereby mitigating the limitations of ranking.

8 Related Work

APIphany is a component-based synthesizer and primarily
compares with related work in this space. It also draws on
techniques from specification mining and type inference.
Type-directed component-based synthesis. The goal of
component-based synthesis is to find a composition of com-
ponents (library functions) that implements a given task. In
type-directed component-based synthesis both the task and
the components are specified using types. The traditional
approach to this problem based on proof search [3, 15, 24]
scales poorly with the size of the component library. An
alternative, more scalable graph-based approach was intro-
duced in Prospector [21] for unary components, and gen-
eralized to 𝑛-ary components in SyPet [8], by replacing
graphs with Petri nets. TYGAR [12] further extends SyPet’s
search to polymorphic components using the idea of abstract
types, which are inspired by succinct types from another
component-based synthesizer, InSynth [14]. APIphany’s
program search phase is using the Petri net encoding from
SyPet and TYGAR with minor adaptations (support for op-
tional arguments and ILP encoding). Our array-oblivious
encoding is related to abstract and succinct types in that it
helps make the Petri net smaller, but it is also substantially
different in that, unlike prior work, it can efficiently encode
a certain class of higher-order programs (array comprehen-
sions) into the Petri net.
API navigation. Beyond type-directed synthesis, other work
focuses on smart auto-completion [20, 25, 27] but relies on

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

static analysis and mining client code, which APIphany
does not require. Among tools that leverage dynamic analy-
sis, EdSynth [34] uses test executions to generate snippets
that involve both API calls and control structures. Match-
Maker [36] and DemoMatch [35] are similar to APIphany
in that they rely on observed program traces to suggest code
that uses complex APIs (the former from types and the lat-
ter from demonstrations). All these techniques work in the
context of Java, and hence assume that sufficiently precise
types are already present.
SQL synthesis. The problem of generating projections and
filters is related to synthesis of SQL queries [32, 33]. Exist-
ing SQL synthesis techniques are not directly applicable to
our problem domain, because (1) our programs also contain
arbitrary API method invocations, and (2) we manipulate
semi-structured data instead of relational data.
API discovery and specification mining. A complimen-
tary approach to API navigation using program synthesis is
to infer specifications [1, 23, 28] or example usages [4, 6, 17]
to help the user understand the API better. APIphany’s type
mining is inspired by Ammons et al. [1], where they build
probabilistic finite state automata representing data and tem-
poral dependencies between API methods. APIphany imple-
ments a simpler form of their algorithm, which discovers
data flows (but not temporal dependencies), but the novelty
lies in using this information to drive program synthesis.

Type mining is also related to prior work on inferring
type annotations for dynamically typed languages from exe-
cutions [2, 5, 7]. However, this work is for structural types,
whereas we infer domain-specific nominal types.
Simulated execution. An alternative to our retrospective
execution is to synthesize a model of the API, and evaluate
program candidates against that model. Previous work [16,
19] synthesizes models for complex frameworks and opaque
code; our retrospective execution is simpler: it skips the extra
step of model synthesis.
Ranking solutions. Specifications in program synthesis are
often ambiguous, so synthesizers have to rank their candi-
date solutions and return the top result(s). Existing tools most
commonly rely on hand-crafted [11] or learned [14, 27, 29]
ranking functions based on syntactic features of generated
programs. Hoogle+ [18] is most similar to APIphany in that
it ranks programs based on the results of their execution,
using heuristics like whether the program always fails, and
how similar it is to other candidates.

Acknowledgments

The authors would like to thank the anonymous reviewers,
our shepherd Yuepeng Wang, as well as Hila Peleg and Ilya
Sergey for their valuable feedback on earlier drafts of this
paper. This work was supported by the National Science
Foundation under Grants No. 1943623, 1911149, and 2107397.

References

[1] Glenn Ammons, Rastislav Bodík, and James R. Larus. 2002. Mining
Specifications. In Proceedings of the 29th ACM SIGPLAN-SIGACT Sym-
posium on Principles of Programming Languages (Portland, Oregon)
(POPL ’02). Association for Computing Machinery, New York, NY, USA,
4–16. https://doi.org/10.1145/503272.503275

[2] Jong-hoon (David) An, Avik Chaudhuri, Jeffrey S. Foster, and Michael
Hicks. 2011. Dynamic inference of static types for ruby. In POPL.
Austin, TX, USA, January 26-28, 2011, Thomas Ball and Mooly Sagiv
(Eds.). ACM, 459–472.

[3] Lennart Augusstson. 2005. Djinn. https://github.com/augustss/djinn.
[4] Celeste Barnaby, Koushik Sen, Tianyi Zhang, Elena Glassman, and
Satish Chandra. 2020. Exempla Gratis (E.G.): Code Examples for Free.
In Proceedings of the 28th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software
Engineering (Virtual Event, USA) (ESEC/FSE 2020). Association for
Computing Machinery, New York, NY, USA, 1353–1364. https://doi.
org/10.1145/3368089.3417052

[5] Ambrose Bonnaire-Sergeant. 2019. Typed Clojure in Theory and Practice.

Ph.D. Dissertation. Indiana University, Bloomington.

[6] Raymond P. L. Buse and Westley Weimer. 2012. Synthesizing API
Usage Examples. In Proceedings of the 34th International Conference
on Software Engineering (Zurich, Switzerland) (ICSE ’12). IEEE Press,
782–792.

[7] Ravi Chugh, Sorin Lerner, and Ranjit Jhala. 2011. Type Inference with

Run-time Logs. In Workshop on Scripts to Programs (STOP).

[8] Yu Feng, Ruben Martins, Yuepeng Wang, Isil Dillig, and Thomas W.

Reps. 2017. Component-based synthesis for complex APIs. In POPL.
[9] Elena L. Glassman, Jeremy Scott, Rishabh Singh, Philip J. Guo, and
Robert C. Miller. 2015. OverCode: Visualizing Variation in Student
Solutions to Programming Problems at Scale. ACM Trans. Comput.-
Hum. Interact. 22, 2, Article 7 (mar 2015), 35 pages. https://doi.org/10
.1145/2699751

[10] Elena L. Glassman, Tianyi Zhang, Björn Hartmann, and Miryung
Kim. 2018. Visualizing API Usage Examples at Scale. Association for
Computing Machinery, New York, NY, USA, 1–12. https://doi.org/10
.1145/3173574.3174154

[11] Sumit Gulwani. 2011. Automating string processing in spreadsheets
using input-output examples. In Proceedings of the 38th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, POPL
2011, Austin, TX, USA, January 26-28, 2011. 317–330. https://doi.org/
10.1145/1926385.1926423

[12] Zheng Guo, Michael James, David Justo, Jiaxiao Zhou, Ziteng Wang,
Ranjit Jhala, and Nadia Polikarpova. 2020. Program synthesis by type-
guided abstraction refinement. Proc. ACM Program. Lang. 4, POPL
(2020), 12:1–12:28.

[13] Gurobi Optimization, LLC. 2021. Gurobi Optimizer Reference Manual.

https://www.gurobi.com

[14] Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica Piskac. 2013.

Complete completion using types and weights. In PLDI.

[15] George T. Heineman, Jan Bessai, Boris Düdder, and Jakob Rehof. 2016.
A Long and Winding Road Towards Modular Synthesis. In Leveraging
Applications of Formal Methods, Verification and Validation: Founda-
tional Techniques - 7th International Symposium, ISoLA 2016, Impe-
rial, Corfu, Greece, October 10-14, 2016, Proceedings, Part I. 303–317.
https://doi.org/10.1007/978-3-319-47166-2_21

[16] Stefan Heule, Manu Sridharan, and Satish Chandra. 2015. Mimic:
Computing Models for Opaque Code. In Proceedings of the 2015 10th
Joint Meeting on Foundations of Software Engineering (Bergamo, Italy)
(ESEC/FSE 2015). Association for Computing Machinery, New York,
NY, USA, 710–720. https://doi.org/10.1145/2786805.2786875

[17] Abbas Heydarnoori, Krzysztof Czarnecki, and Thiago Tonelli Bar-
tolomei. 2009. Supporting Framework Use via Automatically Ex-
tracted Concept-Implementation Templates. In Proceedings of the

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

23rd European Conference on ECOOP 2009 — Object-Oriented Program-
ming (Italy) (Genoa). Springer-Verlag, Berlin, Heidelberg, 344–368.
https://doi.org/10.1007/978-3-642-03013-0_16

[18] Michael B. James, Zheng Guo, Ziteng Wang, Shivani Doshi, Hila Peleg,
Ranjit Jhala, and Nadia Polikarpova. 2020. Digging for fold: synthesis-
aided API discovery for Haskell. Proc. ACM Program. Lang. 4, OOPSLA
(2020), 205:1–205:27.

[19] Jinseong Jeon, Xiaokang Qiu, Jonathan Fetter-Degges, Jeffrey S. Foster,
and Armando Solar-Lezama. 2016. Synthesizing Framework Models for
Symbolic Execution. In Proceedings of the 38th International Conference
on Software Engineering (Austin, Texas) (ICSE ’16). Association for
Computing Machinery, New York, NY, USA, 156–167. https://doi.or
g/10.1145/2884781.2884856

[20] Sifei Luan, Di Yang, Celeste Barnaby, Koushik Sen, and Satish Chandra.
2019. Aroma: Code Recommendation via Structural Code Search. Proc.
ACM Program. Lang. 3, OOPSLA, Article 152 (Oct. 2019), 28 pages.
https://doi.org/10.1145/3360578

[21] David Mandelin, Lin Xu, Rastislav Bodík, and Doug Kimelman. 2005.
Jungloid Mining: Helping to Navigate the API Jungle. In PLDI.
[22] Erik Meijer, Brian Beckman, and Gavin Bierman. 2006. LINQ: Reconcil-
ing Object, Relations and XML in the .NET Framework. In Proceedings
of the 2006 ACM SIGMOD International Conference on Management of
Data (Chicago, IL, USA) (SIGMOD ’06). Association for Computing
Machinery, New York, NY, USA, 706. https://doi.org/10.1145/1142473.
1142552

[23] Alon Mishne, Sharon Shoham, and Eran Yahav. 2012. Typestate-Based
Semantic Code Search over Partial Programs. In Proceedings of the
ACM International Conference on Object Oriented Programming Systems
Languages and Applications (Tucson, Arizona, USA) (OOPSLA ’12).
Association for Computing Machinery, New York, NY, USA, 997–1016.
https://doi.org/10.1145/2384616.2384689

[24] Ulf Norell. 2008. Dependently Typed Programming in Agda. In Ad-
vanced Functional Programming, 6th International School, AFP 2008,
Heijen, The Netherlands, May 2008, Revised Lectures. 230–266. https:
//doi.org/10.1007/978-3-642-04652-0_5

[25] Daniel Perelman, Sumit Gulwani, Thomas Ball, and Dan Grossman.
2012. Type-directed completion of partial expressions. In ACM SIG-
PLAN Conference on Programming Language Design and Implemen-
tation, PLDI ’12, Beijing, China - June 11 - 16, 2012. 275–286. https:
//doi.org/10.1145/2254064.2254098

[26] Inc. Postman. 2020. 2020 State of The API Report. https://www.post

man.com/state-of-api/api-technologies/.

[27] Veselin Raychev, Martin Vechev, and Eran Yahav. 2014. Code Comple-
tion with Statistical Language Models. SIGPLAN Not. 49, 6 (June 2014),
419–428. https://doi.org/10.1145/2666356.2594321

[28] Sharon Shoham, Eran Yahav, Stephen Fink, and Marco Pistoia. 2007.
Static specification mining using automata-based abstractions. In Pro-
ceedings of the ACM/SIGSOFT International Symposium on Software
Testing and Analysis, ISSTA 2007, London, UK, July 9-12, 2007. 174–184.
[29] Rishabh Singh and Sumit Gulwani. 2015. Predicting a Correct Program
in Programming by Example. In CAV - 27th International Conference,
2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part I. 398–
414.

[30] Inc. SmartBear. 2020.

The State of API Report 2020.

https://static1.smartbear.co/smartbearbrand/media/pdf/smartb
ear_state_of_api_2020.pdf.

[31] Robert Endre Tarjan. 1975. Efficiency of a Good But Not Linear Set
Union Algorithm. J. ACM 22, 2 (April 1975), 215–225. https://doi.or
g/10.1145/321879.321884

[32] Chenglong Wang, Alvin Cheung, and Rastislav Bodik. 2017. Synthe-
sizing Highly Expressive SQL Queries from Input-Output Examples.
In Proceedings of the 38th ACM SIGPLAN Conference on Programming
Language Design and Implementation (Barcelona, Spain) (PLDI 2017).
Association for Computing Machinery, New York, NY, USA, 452–466.
https://doi.org/10.1145/3062341.3062365

[33] Navid Yaghmazadeh, Yuepeng Wang, Isil Dillig, and Thomas Dillig.
2017. SQLizer: Query Synthesis from Natural Language. Proc. ACM
Program. Lang. 1, OOPSLA, Article 63 (Oct. 2017), 26 pages. https:
//doi.org/10.1145/3133887

[34] Z. Yang, J. Hua, K. Wang, and S. Khurshid. 2018. EdSynth: Synthesiz-
ing API Sequences with Conditionals and Loops. In 2018 IEEE 11th
International Conference on Software Testing, Verification and Validation
(ICST). 161–171. https://doi.org/10.1109/ICST.2018.00025

[35] Kuat Yessenov, Ivan Kuraj, and Armando Solar-Lezama. 2017. De-
moMatch: API Discovery from Demonstrations. In Proceedings of
the 38th ACM SIGPLAN Conference on Programming Language De-
sign and Implementation (Barcelona, Spain) (PLDI 2017). Associa-
tion for Computing Machinery, New York, NY, USA, 64–78. https:
//doi.org/10.1145/3062341.3062386

[36] Kuat Yessenov, Zhilei Xu, and Armando Solar-Lezama. 2011. Data-
Driven Synthesis for Object-Oriented Frameworks. In Proceedings of
the 2011 ACM International Conference on Object Oriented Programming
Systems Languages and Applications (Portland, Oregon, USA) (OOPSLA
’11). Association for Computing Machinery, New York, NY, USA, 65–82.
https://doi.org/10.1145/2048066.2048075

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Expression Typing

ˆΛ; Γ ⊢ 𝑒 :: ˆ𝑡

ˆΛ ⊢ E :: ˆ𝑠

T-Var

𝑥 : ˆ𝑡 ∈ Γ
ˆΛ; Γ ⊢ 𝑥 :: ˆ𝑡

T-Proj

ˆΛ; Γ ⊢ 𝑒 :: {𝑙 : ˆ𝑡, . . .}
ˆΛ; Γ ⊢ 𝑒.𝑙 :: ˆ𝑡

T-Ret

ˆΛ; Γ ⊢ 𝑒 :: ˆ𝑡
ˆΛ; Γ ⊢ return 𝑒 :: [ˆ𝑡]

𝑓 : {ℓ𝑗 : ˆ𝑡 𝑗 } → ˆ𝑡𝑜 ∈ ˆΛ

ˆΛ; Γ ⊢ 𝑒𝑖 :: ˆ𝑡𝑖

∀𝑗 .ℓ𝑗 = 𝑙 𝑗 ⇒ ∃𝑖.𝑙 𝑗 = 𝑙𝑖 ∧ ˆ𝑡 𝑗 = ˆ𝑡𝑖
∀𝑗, 𝑖.ℓ𝑗 =?𝑙 𝑗 ∧ 𝑙 𝑗 = 𝑙𝑖 ⇒ ˆ𝑡 𝑗 = ˆ𝑡𝑖

T-Call

ˆΛ; Γ ⊢ 𝑒𝑥 :: {loc}

ˆΛ; Γ ⊢ 𝑓 (𝑙𝑖 = 𝑒𝑖 ) :: ˆ𝑡𝑜
ˆΛ; Γ ⊢ 𝑒𝑦 :: {loc}

ˆΛ; Γ ⊢ 𝑒 :: [ˆ𝑡]

T-If

T-Let

T-Bind

ˆΛ; Γ ⊢ if 𝑒𝑥 = 𝑒𝑦; 𝑒 :: [ˆ𝑡]

ˆΛ; Γ ⊢ 𝑒1 :: ˆ𝑡1

ˆΛ; Γ, 𝑥 : ˆ𝑡1 ⊢ 𝑒2 :: ˆ𝑡2

ˆΛ; Γ ⊢ let 𝑥 = 𝑒1; 𝑒2 :: ˆ𝑡2

ˆΛ; Γ ⊢ 𝑒1 :: [ˆ𝑡1]

ˆΛ; Γ, 𝑥 : ˆ𝑡1 ⊢ 𝑒2 :: [ˆ𝑡2]

ˆΛ; Γ ⊢ 𝑥 ← 𝑒1; 𝑒2 :: [ˆ𝑡2]
𝑜 : ˆ𝑡 ∈ ˆΛ
ˆΛ; Γ ⊢ 𝑒 :: 𝑜

ˆΛ; Γ ⊢ 𝑒 :: ˆ𝑡
ˆΛ; 𝑥𝑖 : ˆ𝑡𝑖 ⊢ 𝑒 :: ˆ𝑡

ˆΛ ⊢ 𝜆𝑥𝑖 .𝑒 :: {𝑥𝑖 : ˆ𝑡𝑖 } → ˆ𝑡

T-Obj

T-Top

Figure 16. 𝜆𝐴: typing judgment.

Location-Based Type Inference

Λ ⊢ loc =⇒ ˆ𝑡

ObjStart

Λ, 𝑜 ⊢ 𝑙 =⇒ ˆ𝑡
Λ ⊢ 𝑜.𝑙 =⇒ ˆ𝑡

FunStart

ObjBase Λ, 𝑜 ⊢ [] =⇒ 𝑜

PathBase

Λ, 𝑓 ⊢ 𝑙 =⇒ ˆ𝑡

Λ ⊢ 𝑓 .𝑙 =⇒ ˆ𝑡
loc ≠ 𝑜
Λ, loc ⊢ [] =⇒ {loc}

ObjFollow

Λ(loc.𝑙1) = 𝑜

Λ, 𝑜 ⊢ 𝑙 =⇒ ˆ𝑡

Λ, loc ⊢ 𝑙1.𝑙 =⇒ ˆ𝑡

Arr

AdHoc

Λ(loc.𝑙) = [𝑡]

Λ, loc.𝑙 ⊢ 0 =⇒ ˆ𝑡

Λ, loc ⊢ 𝑙 =⇒ [ˆ𝑡]

Λ(loc.𝑙) = {𝑙𝑖 : 𝑡𝑖 }

Λ, loc.𝑙 ⊢ 𝑙𝑖 =⇒ ˆ𝑡𝑖

Λ, loc ⊢ 𝑙 =⇒ {𝑙𝑖 : ˆ𝑡𝑖 }

PathFollow

Λ(loc.𝑙1) = String ∨ (Λ(loc.𝑙1) ≠ 𝑜 ∧ 𝑙 ≠ [])
Λ, loc.𝑙1 ⊢ 𝑙 =⇒ ˆ𝑡
Λ, loc ⊢ 𝑙1.𝑙 =⇒ ˆ𝑡

Figure 15. Rules for location-based type inference.

A Type Mining

Location-based type inference. The location-based type in-
ference judgement Λ ⊢ loc =⇒ ˆ𝑡 is defined in Fig. 15. In this

figure, the notation Λ(loc) = 𝑡 denotes looking up the syntac-
tic type of location loc in the library Λ, e.g. Λ(User.profile) =
Profile and Λ(c_members.out.0) = String. At the same time,
Λ(User.profile.email) is undefined because it does not di-
rectly appear in Λ (instead we need to ask for Profile.email).
The full definition of syntactic lookup is straightforward and
therefore omitted.

The main complication during location-based type infer-
ence is that we need to “fold” locations that denote named
objects, replacing them with object names; e.g.
Λ ⊢ users_info.out.id =⇒ {User.id}
To this end we introduce an auxiliary judgment Λ, loc ⊢ 𝑙 =⇒
ˆ𝑡, where intuitively loc and 𝑙 correspond to a prefix and a
suffix of the location of interest, except that loc is sufficiently
“folded”. For example, to derive the judgment above, we will
start with

Λ, users_info ⊢ out.id =⇒ · · ·
but then use ObjFollow to fold the path and rewrite the
judgment it into

Λ, User ⊢ id =⇒ · · ·

and then by PathBase we can establish

Λ, User ⊢ id =⇒ {User.id}

Note that because loc in this judgment is always sufficiently
folded, all applications of Λ(loc.𝑙) in our rules are actually
well-defined.

The rules Arr and AdHoc deal with inference of array
types and record types. The rule Arr applies when the syn-
tactic type of the top-level location of interest is an array; in
this case we infer the semantic type ˆ𝑡 of the array element
and return [ˆ𝑡] for the location. Note that this rule is not used
when an array-typed location occurs in the middle of a path
and not at the top level: in this case the default rule Path-
Follow applies. The rule AdHoc takes care of locations that
have ad-hoc record types in Λ (as opposed to names object
types); for example, we infer the type {user : User.id} for
the location users_info.in. Just like Arr, AdHoc only applies
when the top-level location has a record type, and otherwise
PathFollow suffices.

B Program Synthesis

Expression typing. The (semantic) typing rules for pro-
grams of 𝜆𝐴 are presented in Fig. 16. The typing judgement
ˆΛ; Γ ⊢ 𝑒 :: ˆ𝑡 states that a term 𝑒 has the semantic type ˆ𝑡
under context Γ and the semantic library ˆΛ. The rule T-Call
check that all required arguments are provided and all pro-
vided arguments have correct types. In a monadic binding
𝑥 ← 𝑒1; 𝑒2, both 𝑒1 and 𝑒2 must have array types (T-Bind).
In a guard if 𝑒1 = 𝑒2; 𝑒, 𝑒 must have an array type, while 𝑒1
and 𝑒2 cannot have an array or record type, since equality
is only supported over string values (T-If). Finally, typing

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

TTN Construction

ˆΛ ⊢ N

𝑐
−→ N ′

ˆΛ ⊢ N

𝑐:ˆ𝑡
−−→ N ′

𝑓 : {ℓ𝑖 : ˆ𝑡𝑖 } → ˆ𝑡𝑜 ∈ ˆΛ

ˆ𝑡𝑖𝑛 = {ℓ𝑖 : ⌊ˆ𝑡𝑖 ⌋}

𝑂 ′ = 𝑂 [(𝑝, 𝑓 ) ↦→ |{𝑙𝑖 |?𝑙𝑖 : 𝑝 ∈ ˆ𝑡𝑖𝑛 }|]
𝐸 ′ = 𝐸 [(𝑝, 𝑓 ) ↦→ |{𝑙𝑖 | 𝑙𝑖 : 𝑝 ∈ ˆ𝑡𝑖𝑛 }|] [(𝑓 , ⌊ˆ𝑡𝑜 ⌋) ↦→ 1]

ˆΛ ⊢ (𝑃,𝑇 , 𝐸, 𝑂)

𝑓
−→ (𝑃 ∪ {⌊ˆ𝑡𝑖 ⌋, ⌊ˆ𝑡𝑜 ⌋},𝑇 ∪ {𝑓 }, 𝐸 ′, 𝑂 ′)

C-Method

C-Object

𝑜 : {ℓ𝑖 : ˆ𝑡𝑖 } ∈ ˆΛ

ˆΛ ⊢ (cid:208) N ′
𝑖

proj𝑜.𝑙𝑖 : ⌊ ˆ𝑡𝑖 ⌋
−−−−−−−−−−→ N ′
𝑖

ˆΛ ⊢ N
filter𝑜.𝑙𝑖 : ⌊ ˆ𝑡𝑖 ⌋
−−−−−−−−−−→ N ′′
𝑖

ˆΛ ⊢ N

𝑜
−→ (cid:208) N ′′
𝑖

𝐸 ′ = 𝐸 [(𝑜, proj𝑜.𝑙 ) ↦→ 1, (proj𝑜.𝑙 , ˆ𝑡) ↦→ 1]

C-Proj

C-Filter

ˆΛ ⊢ (𝑃,𝑇 , 𝐸, 𝑂)

proj𝑜.𝑙 :ˆ𝑡
−−−−−−→ (𝑃 ′ ∪ {𝑜, ˆ𝑡 },𝑇 ′ ∪ {proj𝑜.𝑙 }, 𝐸 ′, 𝑂)

𝐸 ′ = 𝐸 [(𝑜, filter𝑜.𝑙 ) ↦→ 1, (ˆ𝑡, filter𝑜.𝑙 ) ↦→ 1, (filter𝑜.𝑙

ˆ𝑡 not obj. id

, 𝑜) ↦→ 1]

Λ ⊢ (𝑃,𝑇 , 𝐸, 𝑂)

filter𝑜.𝑙 :ˆ𝑡
−−−−−−−→ (𝑃 ∪ {𝑜, ˆ𝑡 },𝑇 ∪ {filter𝑜.𝑙 }, 𝐸 ′, 𝑂)

C-Filter-Obj

𝑜 ′ : {ℓ𝑖 : ˆ𝑡𝑖 } ∈ ˆΛ

ˆΛ ⊢ N

filter𝑜.𝑙 .𝑙𝑖 : ⌊ ˆ𝑡𝑖 ⌋
−−−−−−−−−−−→ N ′
𝑖

Λ ⊢ N

filter𝑜.𝑙 :𝑜′
−−−−−−−−→ (cid:208) N ′
𝑖

Figure 17. TTN construction from a semantic library.

follows object definitions in ˆΛ: if 𝑒 has type 𝑜 and 𝑜 : ˆ𝑡 ∈ Λ,
then 𝑒 also has the type ˆ𝑡 (T-Obj).

B.1 TTN Construction
A TTN N is a 4-tuple (𝑃,𝑇 , 𝐸, 𝑂), where 𝑃 is a set of places,
𝑇 is a set of transitions, and 𝐸 : (𝑃 × 𝑇 ) ∪ (𝑇 × 𝑃) → N
is a matrix of edge multiplicities. 𝐸 (𝑝, 𝜏) denotes how many
required arguments of type 𝑝 component 𝜏 consumes, and
𝐸 (𝜏, 𝑝) denotes how many responses of type 𝑝 it produces.
𝐸 (𝑝, 𝜏) = 0 means that there is no edge from 𝑝 to 𝜏 (and
symmetrically for 𝐸 (𝜏, 𝑝) = 0). To model optional arguments,
in this work we augment the TTN with the matrix of optional
multiplicities 𝑂 : 𝑃 × 𝑇 → N, which denotes the number of
optional arguments of a given type.

A marking is a mapping 𝑀 : 𝑃 → N that assigns a non-
negative number of tokens to every place. A transition firing
𝜏
−→ 𝑀2, such that for all places 𝑝: (a) 𝑀1 con-
is a triple 𝑀1
tains at least as many tokens as 𝜏’s incoming edges require:
𝑀1(𝑝) ≥ 𝐸 (𝑝, 𝜏), and (b) 𝑀2 loses tokens consumed by the
incoming edge, but gains tokens produced by the outgoing
edge: ∃𝑐.𝐸 (𝑝, 𝜏) ≤ 𝑐 ≤ 𝐸 (𝑝, 𝜏) + 𝑂 (𝑝, 𝜏) ∧ 𝑀2(𝑝) = 𝑀1(𝑝) −
𝑐 + 𝐸 (𝜏, 𝑝). A path between 𝑀 and 𝑀 ′ is a sequence of transi-
𝜏𝑛−→ 𝑀 ′
𝜏1−→ 𝑀1
tions 𝜏1, . . . , 𝜏𝑛 such that 𝑀
is a sequence of transition firings.
Array-oblivious encoding. Procedure BuildTTN( ˆΛ) (line
2 in Fig. 10) constructs a TTN N given a semantic library.
Intuitively, its goal is to add transitions for all methods in ˆΛ,

𝜏𝑛−1−−−→ 𝑀𝑛−1

𝜏2−→ . . .

as well as other operations of 𝜆𝐴, such as projections and fil-
tering, such that any well-typed 𝜆𝐴 program can be encoded
as a path in N . There is one major issue, however: 𝜆𝐴 pro-
grams also contain the higher-order monadic bind operations
(aka “flat maps”), which cannot be easily encoded in a TTN;
moreover, the presence of array types in the TTN increases
the number of places and transitions, and slows down the
search. To combat this issue we propose the array-oblivious
encoding of 𝜆𝐴 programs into the TTN, which replaces array
types with types of their elements and monadic bindings
with regular let-bindings (which in the TTN corresponds to
simple sequencing of transitions). Formally, we define the
downgrading operation on semantic types ⌊ˆ𝑡⌋ as follows:

⌊ˆ𝑡⌋ =

(cid:40)

⌊ ˆ𝑡 ′⌋
ˆ𝑡

if ˆ𝑡 = [ ˆ𝑡 ′]

otherwise

Construction rules. We formalize TTN construction using
𝑐
the step relation ˆΛ ⊢ N
−→ N ′ defined in Fig. 17. A construc-
tion step adds an encoding of a library component 𝑐 (method
or object) to N and produces a new TTN N ′; to encode the
entire library ˆΛ, we compose steps for all methods and ob-
jects in the library. For example, Fig. 9 depicts (a fragment
of) the TTN built from the semantic library in Fig. 7; in this
figure, all edges have multiplicity 1 (since no method in ˆΛ
takes multiple arguments of the same type), and there are no
optional edges. In general, there are three kinds of transitions
in a TTN: method transitions, such as conversations_members,
projection transitions, such as projUser.id, and filter transi-
tions, such as filterChannel.name. We now describe the construc-
tion rules for the three kinds of transitions in more detail.
The rule C-Method adds a transition for a method 𝑓 and
connects it to the 𝑓 ’s (downgraded) input and output types.
For example, let 𝑓 = conversations_members, whose down-
graded type is {channel : Channel.id} → User.id. In this case,
the rule C-Method extends the TTN with a transition 𝑓 and
places {Channel.id, User.id}; it also sets 𝐸 [(Channel.id, 𝑓 )] =
1, 𝐸 [(𝑓 , User.id)] = 1 (and all other incoming and outgoing
edge multiplicities to 0). Fig. 17 uses the notation 𝐸 [𝑘 ↦→ 𝑣],
to denote a map that is equal to 𝐸 except for mapping 𝑘 to
𝑣. Note that C-Method is the only rule that modifies op-
tional multiplicities 𝑂, since only methods can have optional
arguments.

The rule C-Object adds projection and filter transitions
for every field 𝑙 of an object identifier 𝑜, merging the resulting
TTNs component-wise. The rule C-Proj adds a projection
transition proj𝑜.𝑙 between an on object identifier 𝑜 and the
type of 𝑙.

Filter transitions are a little more involved, as they do not
mirror the structure of 𝜆𝐴 guards one-to-one. Guards in their
general form are higher-order operations, and hence cannot
be directly encoded in the TTN. Fortunately, APIphany only
uses guards for one purpose: filtering objects from an array
𝑥𝑠 if their constituent is equal to some 𝑦 (in code: 𝑥 ←

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

𝑥𝑠; if 𝑥 .𝑙 = 𝑦; return 𝑥). We encode this filtering operation
in the TTN as a filter transition filter𝑜.𝑙 , which consumes 𝑜
(the downgraded type of 𝑥𝑠) and the type of 𝑦, and produces
𝑜. For example, the filter transition filterChannel.name in Fig. 9
consumes a Channel and a Channel.name and produces a Channel.
When 𝑜.𝑙 is an object, the rule C-Filter-Obj recursively
creates filter transitions for all its fields (recall that 𝜆𝐴 only
supports guards on primitive values). For example, for the
object ID User, we will add a transition filterUser.profile.email,
but not filterUser.profile.

B.2 TTN Search

Once the TTN N has been constructed, the algorithm Syn-
thesize proceeds to enumerate paths from the initial mark-
ing 𝐼 to the final marking 𝐹 in N . 𝐼 and 𝐹 are constructed
from the query type ˆ𝑡𝑖𝑛 → ˆ𝑡𝑜 as follows:
𝐼 (𝑝) = |{𝑙𝑖 | 𝑙𝑖 : 𝑝 ∈ ⌊ˆ𝑡𝑖𝑛⌋}|
𝐹 (𝑝) = if 𝑝 = ⌊ˆ𝑡𝑜 ⌋ then 1 else 0
For example, for the query Channel.name → [Profile.email],
the initial marking contains a single token in Channel.name
and the final marking contains a single token in Profile.email.
Hence, any valid path from 𝐼 to 𝐹 must consume all inputs
and produce the output of the query type. Note that the TTN
as defined in Sec. B.1 encodes a linear type system, i.e. can
only generate programs where each input is used exactly
once. Following prior work [8, 12], our implementation adds
copy transitions to the TTN, which results in a relevant type
system, i.e. one where every input has to be used at least once.
Prior work shows that this relevancy requirement is crucial
to filtering out meaningless solutions during search.
ILP encoding. To find paths in the TTN, prior work has re-
lied on a SAT/SMT encoding of TTN reachability. We have
found that although the SMT encoding from [12] works well
to find a handful of paths, in our domain we often need to
enumerate thousands of paths, which becomes very inef-
ficient. To address this problem, we instead use an integer
linear programming (ILP) solver, which provides native func-
tionality for computing all solutions to a constraint.

Given a TTN N = (𝑃,𝑇 , 𝐸, 𝑂) with the initial marking
𝐼 and the final marking 𝐹 , we show how to build an ILP
formula that encodes all valid paths of a given length 𝐿. The
overall search proceeds by iteratively increasing the path
length 𝐿. We encode the number of tokens in each place
𝑝
𝑝 ∈ 𝑃 at each time step 𝑘 ∈ [0, 𝐿] as a variable tok
𝑘 . We
encode firing of transition 𝜏 ∈ 𝑇 at time step 𝑘 ∈ [0, 𝐿 − 1] as
a variable fire𝜏
𝑘 = 1 indicates that 𝜏 is
fired at time step 𝑘. For any 𝜏 ∈ 𝑇 , we define the pre-image
of 𝜏 as pre(𝜏) = {𝑝 ∈ 𝑃 | 𝐸 (𝑝, 𝜏) > 0 ∨ 𝑂 (𝑝, 𝜏) > 0} and the
post-image of 𝜏 as post(𝜏) = {𝑝 ∈ 𝑃 | 𝐸 (𝜏, 𝑝) > 0}.

𝑘 ∈ {0, 1}, such that fire𝜏

The formula for TTN reachability is a conjunction of the

following constraints:

𝑝

(1) If a transition 𝜏 is fired at time step 𝑘, then all re-
quired places 𝑝 ∈ pre(𝜏) have sufficiently many to-
kens: (cid:211)𝐿−1
𝑘=0

(cid:211)𝜏 ∈𝑇 (cid:211)𝑝 ∈pre(𝜏) tok

𝑘 ≥ 𝐸 (𝑝, 𝜏) × fire𝜏

(2) If a transition 𝜏 is fired at time step 𝑘, then all places
𝑝 ∈ pre(𝜏) ∪ post(𝜏) will have their marking updated
𝑝
at time step 𝑘 + 1: (cid:211)𝐿−1
(cid:211)𝜏 ∈𝑇 (cid:211)𝑝 ∈pre(𝜏)∪post(𝜏) tok
𝑘 −
𝑘=0
𝑝
𝑝
(𝐸 (𝑝, 𝜏) + 𝑂 (𝑝, 𝜏) − 𝐸 (𝜏, 𝑝)) × fire𝜏
𝑘 −
≤ tok
𝑘 ≤ tok
𝑘+1
(𝐸 (𝑝, 𝜏) − 𝐸 (𝜏, 𝑝)) × fire𝜏
𝑘

𝑘

(3) At each time step, only one transition is fired:

(cid:211)𝐿−1
𝑘=0

(cid:205)𝜏 ∈𝑇 fire𝜏

𝑘=0

𝑘 ≤ 1

0 = 𝐼 (𝑝)

and (cid:211)𝐿−1
𝑘=0

𝑝
(cid:211)𝑝 ∈𝑃 0 ≤ tok
𝑘

𝑘 = 1
(4) Variable domains are respected: (cid:211)𝐿
(cid:211)𝜏 ∈𝑇 0 ≤ fire𝜏
𝑝
(5) The initial marking 𝐼 is valid: (cid:211)𝑝 ∈𝑃 tok
𝑝
(6) The final marking is valid: (cid:211)𝑝 ∈𝑃 tok
𝐿 = 𝐹 (𝑝)
Note that constraint (2) approximates consumption of op-
tional arguments as a range between consuming all of them
(𝐸 (𝑝, 𝜏)+𝑂 (𝑝, 𝜏)) and consuming none of them (𝐸 (𝑝, 𝜏)). This
encoding is unsound when an optional argument has the
same type as the output. Consider firing a transition 𝜏 at step
𝑝
𝑘 = 0, 𝐸 (𝑝, 𝜏) = 0, 𝑂 (𝑝, 𝜏) = 1, 𝐸 (𝜏, 𝑝) = 1;
𝑘 such that tok
𝑝
≤ 1, whereas the TTN definition
our encoding 0 ≤ tok
𝑘+1
𝑝
= 1 (the optional argument could
in Sec. B.1 requires tok
𝑘+1
not be consumed since there was no token to consume). We
use the approximate encoding because in our experience
it is significantly more efficient than the exact alternatives,
which require additional variables and/or constraints. In our
evaluation, the unsoundness arises very rarely, and when it
does, the path is simply rejected by the type checker when
converted into a program.

B.3 Program Lifting

From paths to programs. The function Progs(𝜋) (line 5 in
Fig. 10) converts a TTN path 𝜋 into a set of array-oblivious
programs in A-Normal Form (ANF). An ANF program is se-
quence of statements 𝜎 followed by a variable; the syntax of
ANF terms is given in Fig. 18. Progs converts each transition
in 𝜋 into a sequence of statements with a dedicated output
variable 𝑥𝑜 : a method transition becomes let 𝑥𝑜 = 𝑓 (𝑙𝑖 = 𝑥𝑖 ),
a projection transition becomes let 𝑥𝑜 = 𝑥 .𝑙, and a filter tran-
sition becomes let 𝑥1 = 𝑥𝑜 .𝑙1; . . . let 𝑥𝑛 = 𝑥𝑛−1.𝑙𝑛; if 𝑥𝑛 =
𝑦. All emitted statements are then concatenated into an ANF
term 𝜎1; . . . ; 𝜎𝑛; 𝑥𝑛, where 𝑥𝑛 is the output variable of the
last transition. Fig. 11 (left) shows the full array-oblivious
program extracted from the bold path in Fig. 9. The reason
we use ANF as the intermediate representation instead of
generating 𝜆𝐴 terms directly is that ANF has a more direct
correspondence with TTN paths and also is more convenient
to work with during lifting; and ANF term can be translated
into a regular 𝜆𝐴 term by recursing through the sequence
of statements and replacing sequential composition with 𝜆𝐴
let bindings, monadic bindings, or guard expressions.
Lifting rules. We formalize lifting of ANF terms as a term
lifting judgement Γ ⊢ 𝑎 ↑ ˆ𝑡 (cid:123) 𝑎′ ⊣ Γ′, defined in Fig. 18.

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

fresh(𝑥 ′)

C Retrospective Execution

The full definition of the RE judgement is presented in Fig. 19.

ANF Syntax

𝜎 ::= let 𝑥 = 𝑓 (𝑙𝑖 = 𝑥𝑖 ) | let 𝑥 = 𝑥 .𝑙

Statements

| if 𝑥 = 𝑥 | 𝑥 ← 𝑥 | let 𝑥 = return 𝑥

𝑎 ::= 𝜎; 𝑥

ANF terms

Statement Lifting

Γ ⊢ 𝜎 (cid:123) 𝜎 ′ ⊣ Γ′

𝑓 : {𝑙𝑖 : ˆ𝑡𝑖 } → ˆ𝑡𝑜 ∈ ˆΛ
Γ0 = Γ

Γ𝑖−1 ⊢ 𝑥𝑖 ↑ ˆ𝑡𝑖 (cid:123) 𝜎𝑖 ; 𝑥 ′
𝜎 ′ = (𝜎1; . . . ; 𝜎𝑛; let 𝑥 = 𝑓 (𝑙𝑖 = 𝑥 ′

𝑖 ⊣ Γ𝑖
𝑖 ))

Γ ⊢ let 𝑥 = 𝑓 (𝑙𝑖 = 𝑥𝑖 ) (cid:123) 𝜎 ′ ⊣ Γ𝑛, 𝑥 : ˆ𝑡𝑜

Γ ⊢ 𝑦 :: ˆ𝑡

Γ ⊢ 𝑦 ↑ ⌊ˆ𝑡⌋ (cid:123) 𝜎; 𝑦 ′ ⊣ Γ′

Γ′ ⊢ 𝑦 ′.𝑙 :: ˆ𝑡 ′

L-Call

L-Proj

Γ ⊢ let 𝑥 = 𝑦.𝑙 (cid:123) 𝜎; let 𝑥 = 𝑦 ′.𝑙 ⊣ Γ′, 𝑥 : ˆ𝑡 ′
Γ ⊢ 𝑥 ↑ ⌊ˆ𝑡𝑥 ⌋ (cid:123) 𝜎𝑥 ; 𝑥 ′ ⊣ Γ′
Γ ⊢ 𝑥 :: ˆ𝑡𝑥
Γ′ ⊢ 𝑦 ↑ ⌊ˆ𝑡𝑦⌋ (cid:123) 𝜎𝑦; 𝑦 ′ ⊣ Γ′′
Γ ⊢ 𝑦 :: ˆ𝑡𝑦
Γ ⊢ if 𝑥 = 𝑦 (cid:123) 𝜎𝑥 ; 𝜎𝑦; if 𝑥 ′ = 𝑦 ′ ⊣ Γ′′

L-Guard

ANF Term Lifting

Γ ⊢ 𝑎 ↑ ˆ𝑡 (cid:123) 𝑎′ ⊣ Γ′

Γ ⊢ 𝜎0 (cid:123) 𝜎 ′
0

⊣ Γ′

L-Seq

Γ′ ⊢ 𝜎; 𝑥 ↑ ˆ𝑡 (cid:123) 𝜎 ′; 𝑥 ′ ⊣ Γ′′
0; 𝜎 ′; 𝑥 ′ ⊣ Γ′′

Γ ⊢ 𝜎0; 𝜎; 𝑥 ↑ ˆ𝑡 (cid:123) 𝜎 ′
Γ ⊢ 𝑥 :: ˆ𝑡
Γ ⊢ 𝑥 ↑ ˆ𝑡 (cid:123) 𝑥 ⊣ Γ

L-Var

Γ ⊢ 𝑥 :: [ˆ𝑡 ′]

ˆ𝑡 ≠ [ˆ𝑡 ′]

_ :𝑥 ˆ𝑡 ′ ∉ Γ

L-Var-Down

L-Var-Repeat

Γ, 𝑥 ′ :𝑥 ˆ𝑡 ′ ⊢ 𝑥 ′ ↑ ˆ𝑡 (cid:123) 𝜎; 𝑦 ⊣ Γ′
Γ ⊢ 𝑥 ↑ ˆ𝑡 (cid:123) 𝑥 ′ ← 𝑥; 𝜎; 𝑦 ⊣ Γ′
ˆ𝑡 ≠ [ˆ𝑡 ′]
Γ ⊢ 𝑥 ′ ↑ ˆ𝑡 (cid:123) 𝜎; 𝑦 ⊣ Γ′
Γ ⊢ 𝑥 ↑ ˆ𝑡 (cid:123) 𝜎; 𝑦 ⊣ Γ′

Γ ⊢ 𝑥 :: [ˆ𝑡 ′]

𝑥 ′ :𝑥 ˆ𝑡 ′ ∈ Γ

L-Var-Up

Γ ⊢ 𝑥 :: ˆ𝑡 ′
fresh(𝑥 ′)
ˆ𝑡 ′ ≠ [ˆ𝑡]
Γ, 𝑥 ′ : [ˆ𝑡 ′] ⊢ 𝑥 ′ ↑ ˆ𝑡 (cid:123) 𝜎; 𝑦 ⊣ Γ′
Γ ⊢ 𝑥 ↑ [ˆ𝑡] (cid:123) let 𝑥 ′ = return 𝑥; 𝜎; 𝑦 ⊣ Γ′

Figure 18. Lifting rules.

Here 𝑎 is the array-oblivious term to be lifted, whose free
variables are defined in Γ, ˆ𝑡 is the target type, 𝑎′ is the lifted
term, and Γ′ is Γ extended with all the variables bound in 𝑎′.
The definition of term lifting relies on the auxiliary statement
lifting judgment Γ ⊢ 𝜎 (cid:123) 𝜎 ′ ⊣ Γ′, which lifts a single state-
ment 𝜎 that appears in the environment Γ into a sequence of
statements 𝜎 ′; again Γ′ is Γ extended with variables bound
in 𝜎 ′. Both judgments implicitly rely on the semantic library
ˆΛ, which we omit for brevity since it is not modified. For
example, the statement in line 4 of Fig. 11 is lifted as follows:

𝑥1 : [Channel] ⊢ let 𝑥2 = 𝑥1.name (cid:123)
1 ← 𝑥1; let 𝑥2 = 𝑥 ′
𝑥 ′

1

.name ⊣

𝑥1 Channel, 𝑥2 : Channel.name
𝑥1 : [Channel], 𝑥 ′
1 :
1 in Γ′ is annotated with 𝑥1; we
Note that the binding for 𝑥 ′
introduce these annotations to keep track of mapping vari-
ables: here 𝑥 ′
1 is the mapping variable for the array 𝑥1, and it
will be reused later in the program whenever an element of
𝑥1 is required again (see line 6).

Let us now describe the rules in Fig. 18 in more detail.
The statement lifting rules enforce well-typing for the three
kinds of statements that appear in array-oblivious programs:
L-Call enforces that the arguments of a method call agree
with it definition in ˆΛ, while L-Proj and L-Guard make sure
their operands are scalars. The heavy lifting is done by the
rules L-Var-Down and L-Var-Up, both of which handle the
case of lifting a variable whose type ˆ𝑡 ′ in Γ does not match
the target type ˆ𝑡. L-Var-Down applies when ˆ𝑡 ′ = [..[ˆ𝑡]..]:
in this case we generate a monadic binding 𝑥 ′ ← 𝑥 (and
then lift 𝑥 ′ again in case the array type was nested); this
rule is responsible for the monadic bindings in lines 3 and 8
of Fig. 11. Note that in the last premise we add the binding
𝑥 ′ :𝑥 ˆ𝑡 ′ to Γ to record that 𝑥 ′ is the mapping variable for 𝑥.
If Γ already has a mapping variable for 𝑥, we want to reuse
that variable instead of generating a new binding; this is
accomplished by the rule L-Var-Repeat. Finally, L-Var-Up
applies when the opposite is true, i.e. ˆ𝑡 = [..[ˆ𝑡 ′]..]; in this
case we simply need to wrap 𝑥 in a return. This rule generates
line 12 of Fig. 11: here the target return type of the program
is ˆ𝑡 = [Profile.email] and the type of 𝑥7 is ˆ𝑡 ′ = Profile.email.

D Witness Collection

For each API, we manually created a test environment via the
corresponding web interface and filled in some arbitrary test
data. We then ran several operations in the test environment,
using Google Chrome to record the web traffic in an HTTP
Archive (HAR) file: a JSON-formatted file that logs browser
interactions with a server. We then extracted initial witnesses
W0 from the HAR file and ran the algorithm MineTypes
(Fig. 8) on these witnesses, resulting in an initial semantic
library ˆΛ0.

Unfortunately, the set W0 obtained this way is sparse,
which may prevent the mining algorithm from merging
equivalent locations or even inferring types for some meth-
ods altogether. For example, if we only have initial wit-
nesses as shown in Fig. 4, APIphany is unable to infer the
semantic type of users_lookupByEmail that is required by one
of our benchmarks, and hence fail to solve this task. At
the same time, generating useful tests for this method is
challenging, because it only succeeds on inputs that corre-
spond to existing users’ emails. To improve the quality and
coverage of inferred types, APIphany generates additional
witnesses, using a combination of type-directed random
testing and a small amount of manual annotations. Specifi-
cally, APIphany draws test inputs from the bank of values
it has observed in the existing witnesses; in our example,
one of the strings that appear in Fig. 4 is "xyz@gmail.com".
Calling users_lookupByEmail with this string succeeds and re-
turns "UJ5RHEG4S". Based on the previously mined types of

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Retrospective Execution

⟨W; Γ; Σ | 𝑒⟩ ⇒ 𝑣

E-Var

Σ(𝑥) = 𝑣
⟨W; Γ; Σ | 𝑥⟩ ⇒ 𝑣
Γ ⊢ 𝑥 :: ˆ𝑡

𝑥 ∉ Σ

𝑣 ∈ W (ˆ𝑡)

⟨W; Γ; Σ | 𝑥⟩ ⇒ 𝑣
⟨W; Γ; Σ | 𝑒1⟩ ⇒ 𝑣
⟨W; Γ; 𝑥 ↦→ 𝑣, Σ | 𝑒2⟩ ⇒ 𝑣 ′
⟨W; Γ; Σ | let 𝑥 = 𝑒1; 𝑒2⟩ ⇒ 𝑣 ′
⟨W; Γ; Σ | 𝑒1⟩ ⇒ [𝑣𝑖 ]
⟨W; Γ; 𝑥 ↦→ 𝑣𝑖, Σ | 𝑒2⟩ ⇒ 𝑣 ′
𝑖
𝑣 ′ = (cid:210) 𝑣 ′
𝑖
⟨W; Γ; Σ | 𝑥 ← 𝑒1; 𝑒2⟩ ⇒ 𝑣 ′

⟨W; Γ; Σ | 𝑥⟩ ⇒ 𝑣
⟨W; Γ; Σ | return 𝑥⟩ ⇒ [𝑣]

E-Var-Lazy

E-Bind-Pure

E-Bind-Monad

E-Return

E-Projection

⟨W; Γ; Σ | 𝑥⟩ ⇒ 𝑣

hasField(𝑣, 𝑙)

⟨W; Γ; Σ | 𝑥 .𝑙⟩ ⇒ 𝑣.𝑙

E-If-True-L

E-If-True-R

E-If-True-LR

E-If-False

E-Method

𝑥1 ∈ Σ

𝑥2 ∉ Σ

Σ(𝑥1) = 𝑣1

⟨W; Γ; 𝑥2 ↦→ 𝑣1, Σ | 𝑒⟩ ⇒ 𝑣
⟨W; Γ; Σ | if 𝑥1 = 𝑥2; 𝑒⟩ ⇒ 𝑣

𝑥1 ∉ Σ
⟨W; Γ; Σ | 𝑥2⟩ ⇒ 𝑣2
⟨W; Γ; 𝑥1 ↦→ 𝑣2, 𝑥2 ↦→ 𝑣2, Σ | 𝑒⟩ ⇒ 𝑣
⟨W; Γ; Σ | if 𝑥1 = 𝑥2; 𝑒⟩ ⇒ 𝑣

𝑥1 ∈ Σ

𝑥2 ∈ Σ

Σ(𝑥1) = Σ(𝑥2)

⟨W; Γ; Σ | 𝑒⟩ ⇒ 𝑣
⟨W; Γ; Σ | if 𝑥1 = 𝑥2; 𝑒⟩ ⇒ 𝑣
𝑥1 ∈ Σ
Σ(𝑥1) = 𝑣1

Σ(𝑥2) = 𝑣2

𝑥2 ∈ Σ

𝑣1 ≠ 𝑣2

⟨W; Γ; Σ | if 𝑥1 = 𝑥2; 𝑒⟩ ⇒ []
⟨W; Γ; Σ | 𝑥𝑖 ⟩ ⇒ 𝑣𝑖
⟨W; Γ; Σ | 𝑓 (𝑙𝑖 = 𝑣𝑖 )⟩ ⇒ 𝑣𝑜𝑢𝑡
⟨W; Γ; Σ | 𝑓 (𝑙𝑖 = 𝑥𝑖 )⟩ ⇒ 𝑣𝑜𝑢𝑡

E-Method-val

E-Method-name

(𝑓 , 𝑙𝑖 = 𝑣𝑖, 𝑣𝑜𝑢𝑡 ) ∈ W

∀(𝑓 , 𝑙𝑖 = 𝑣 ′

⟨W; Γ; Σ | 𝑓 (𝑙𝑖 = 𝑣𝑖 )⟩ ⇒ 𝑣𝑜𝑢𝑡
𝑖 , 𝑣𝑜𝑢𝑡 ) ∈ W. ∃𝑖 : 𝑣 ′
𝑖 , 𝑣𝑜𝑢𝑡 ) ∈ W

(𝑓 , 𝑙𝑖 = 𝑣 ′

𝑖 ≠ 𝑣𝑖

⟨W; Γ; Σ | 𝑓 (𝑙𝑖 = 𝑣𝑖 )⟩ ⇒ 𝑣𝑜𝑢𝑡

The algorithm returns both ˆΛ, which is used to build the
TTN during the synthesis step, and W, which is used for
retrospective execution during the ranking step; hence aug-
menting W also improves the quality of ranking.

Before we introduce the algorithm GenerateTests, we
augment the semantic library ˆΛ with a value bank V, which
is a mapping from semantic types to sets of values. The value
bank gets populated during type mining and contains all val-
ues that appear in W; for arrays and objects, it also contains
their constituents. With the value bank at hand, let us explain
the algorithm GenerateTests presented in Fig. 20 (bottom).
GenerateTests iterates through the method signatures in
ˆΛ, and for every method 𝑓 : ˆ𝑡𝑖 → ˆ𝑡𝑜 , it samples a random
input of type ˆ𝑡𝑖 , makes an API call to 𝑓 with that input, and
if the call succeeds, yields the corresponding witness. It uses
the value bank (denoted ˆΛ.V) at line 7 to randomly sam-
ple an input from all values stored at semantic type ˆ𝑡. We
also observe that many API methods have optional argu-
ments and behave differently depending on which subset
of optional arguments is provided. To cover a wide range
of method behaviors, GenerateTests partitions the record
of all arguments ˆ𝑡𝑖 into two records, each containing either
only required or only optional arguments (line 3). The algo-
rithm then iterates over all subsets of optional arguments
(line 4), attempting to make a call for each subset (our im-
plementation only iterates over subsets up to a pre-defined
size).

Fully automatic test generation helps us bootstrap seman-
tic type inference for methods that already appear in W0,
but it cannot add witnesses for methods that are missing en-
tirely. To address this problem, we manually add consumer-
producer annotations to those methods missing from W0.

In the evaluation, we collect witnesses by running the al-
gorithm AnalyzeAPI (Fig. 20) until it converges, alternating
test generation and type mining, which resulted in the final
set of witnesses W and library ˆΛ. The total running time
for API analysis depends on the number of methods and
their arguments, and ranged from several minutes to several
hours in our experiments.

Figure 19. Retrospective execution.

E Benchmarks and Solutions

these two strings, APIphany infers the type Profile.email →
User.id for the new method.

The top-level API analysis algorithm of APIphany is de-
picted in Fig. 20 (top). The algorithm alternates between calls
to MineTypes (to compute the best semantic library ˆΛ it can
mine from the current witnesses W) and GenerateTests (to
augment W using the current ˆΛ). Analysis terminates either
if ˆΛ and W reach a fixpoint, or when a timeout is reached.

Tab. 3 contains benchmark descriptions and detailed results.
Tab. 4 contains the results of the qualitative analysis of mined
semantic types.

The rest of this section includes type queries and “gold
standard” solutions for all benchmarks. Note that the type
queries used here correspond directly to the OpenAPI spec;
earlier in the paper, type and method names were simplified
for readability.

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Input: Library Λ, initial witnesses W0
Output: Semantic library ˆΛ
Output: Augmented witnesses W
1: function AnalyzeAPI(Λ, W0)
2: W ← W0
repeat
3:
ˆΛ ← MineTypes(Λ, W)
4:
5: W ← W ∪ GenerateTests( ˆΛ)
6:
7:

until fixpoint or timeout
return ˆΛ, W

Input: Semantic library ˆΛ
Output: Generated witnesses W
1: function GenerateTests( ˆΛ)
2:

for 𝑓 : {𝑙𝑖 : ˆ𝑡𝑖, ?𝑙 𝑗 : ˆ𝑡 𝑗 } → ˆ𝑡𝑜 ∈ ˆΛ do
ˆ𝑡𝑟𝑒𝑞, ˆ𝑡𝑜𝑝𝑡 ← {𝑙𝑖 : ˆ𝑡𝑖 }, {?𝑙 𝑗 : ˆ𝑡 𝑗 }
for ˆ𝑡𝑠𝑢𝑏 ⊂ ˆ𝑡𝑜𝑝𝑡 do

𝑣𝑖𝑛 ← {}
for 𝑙 : ˆ𝑡 ∈ ˆ𝑡𝑟𝑒𝑞 ∪ ˆ𝑡𝑠𝑢𝑏 do

𝑣𝑖𝑛.𝑙 ← random( ˆΛ.V [ˆ𝑡])

𝑣𝑜𝑢𝑡 ← call(𝑓 , 𝑣𝑖𝑛)
if 𝑣𝑜𝑢𝑡 ≠ ⊥ then yield ⟨𝑓 , 𝑣𝑖𝑛, 𝑣𝑜𝑢𝑡 ⟩

3:
4:
5:
6:

7:

8:
9:

Figure 20. Top-level API analysis algorithm and test generation.

Table 3. Synthesis benchmarks and results. Benchmarks marked with † are effectful. For each benchmark we report the size of
the desired solution: AST, 𝑛𝑓 , 𝑛𝑝 and 𝑛𝑔 correspond to number of AST nodes, method calls, projections and guards, respectively.
We also report the time spent on RE-based ranking 𝑡RE and the total synthesis time 𝑡Total in seconds. In the last four columns,
we report the rank before RE 𝑟orig, the rank after RE among candidates that we find before the desired solution 𝑟RE, the total
number of candidates we get within timeout, and the rank after RE among all candidates within timeout 𝑟 TO
RE . ‘-’ means no
solution is found in 150 seconds.

Benchmark

Solution Size

Timing

Rank

API

ID

Description

k
c
a
l
S

e
p
i
r
t
S

e
r
a
q

S

1.1
Retrieve emails of all members in a channel
1.2†
Send a message to a user given their email
1.3
Get the unread messages of a user
1.4
Get all messages associated with a user
1.5†
Create a channel and invite a list of users
1.6†
Reply to a message and update it
1.7†
Send a message to a channel with the given name
1.8
Get the unread messages of a channel
2.1†
Subscribe to a product for a customer
2.2†
Subscribe to multiple items
2.3†
Create a product and invoice a customer
2.4
Retrieve a customer by email
2.5
Get a list of receipts for a customer
2.6†
Get a refund for a subscription
2.7
Get the emails of all customers
2.8
Get the emails of the subscribers of a product
2.9
Get the last 4 digits of a customer’s card
2.10† Update payment methods for a user’s subscriptions
2.11† Delete the default payment source for a customer
2.12†
Save a card during payment
2.13†
Send an invoice to a customer
List invoices that match a location id
3.1
List subscriptions by location, customer, and plan
3.2
Get all items a tax applies to
3.3
Get a list of discounts in the catalog
3.4
3.5†
Add order details to order
Get payment notes of a payment
3.6
Get order ids of current user’s transactions
3.7
Get order names from a transaction id
3.8
Find customers by name
3.9
3.10† Delete catalog items with names
3.11† Delete all catalog items

AST 𝑛𝑓

𝑛𝑝

𝑛𝑔

17
12
16
14
10
9
12
9
9
10
12
8
8
9
5
16
6
10
7
11
10
4
16
10
5
14
5
6
9
8
16
8

3
3
3
2
2
2
2
2
2
2
3
1
2
3
1
2
1
2
2
3
3
1
1
1
1
2
1
1
1
1
2
2

6
5
7
4
3
2
4
3
2
2
2
2
2
2
2
7
2
3
1
2
2
1
4
3
2
3
2
2
3
2
5
3

1
0
0
1
0
0
1
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
3
1
0
0
0
0
0
1
1
0

𝑡RE

𝑡Total
0.5
83.5
0.1
5.6
-
-
0.2
1.3
0.1
3.4
1.7
0.1
1.3 <0.1
0.8
42.0
0.6
95.4
0.6
92.4
2.6
121.2
0.5 <0.1
1.0 <0.1
12.2
0.1
0.6 <0.1
20.2
0.2
0.5 <0.1
0.1
7.8
0.1
17.2
-
-
-
-
0.2 <0.1
0.5 <0.1
0.4 <0.1
0.7 <0.1
2.2 <0.1
0.2 <0.1
0.3 <0.1
0.7 <0.1
0.2 <0.1
1.9 <0.1
1.0 <0.1

𝑟orig

𝑟RE

# cands

25230
2224
-
489
788
573
757
16438
4952
4854
6363
3
10
270
4
679
2
187
490
-
-
2
10
6
2
99
1
7
1
3
174
68

5
10
-
24
5
8
8
29
3
4
1
1
4
3
2
17
1
6
6
-
-
1
4
1
1
2
1
4
1
2
10
16

38212
30437
-
28012
22426
39276
39078
50757
6312
6167
6644
1751
4548
4584
1382
3407
1812
3068
1373
-
-
9544
2526
11039
11704
7222
9590
8669
12323
3177
11336
7429

𝑟 TO
RE
5
10
-
31
5
19
9
30
3
4
1
1
4
3
2
17
1
6
6
-
-
1
4
1
1
2
1
4
1
2
12
16

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

Table 4. A sample of API methods, with their expected and inferred semantic types. Non-string parameters and responses are
omitted since we do not perform inference for those.

API

Method

Field Type Required

/stars.add_POST

Parameter

k
c
a
l
S

/conversations.list_GET

/users.profile.get_GET

/reminders.list_GET

/users.conversations_GET

Parameter

Parameter

Response
Response

Parameter

/v1/invoiceitems/{invoiceitem}_POST

Parameter

No
No
No
No
No

No

-
-

No

No
Yes

No

No
No
No
No
No
No

Name

channel

file
file_comment

timestamp

types

user

profile

reminders

user

types

Expected Type

defs_channel
defs_file_id
defs_comment_id
defs_ts
objs_conversation.types

defs_user_id

objs_user_profile
objs_reminder

defs_user_id

objs_conversation.types

invoiceitem

invoiceitem.id

description

invoiceitem.description

Inferred Type

defs_group_id,defs_dm_id

/stars.add.in.file
/stars.add.in.file_comment

/stars.add.in.timestamp

/conversations.list.in.types
objs_file.user, defs_bot_id, defs_topic_purpose_creator,
defs_user_id
objs_user_profile
objs_reminder
objs_file.user, defs_bot_id, defs_topic_purpose_creator,
defs_user_id

/users.conversations.in.types

invoiceitem.id,line_item.invoice_item

product.name,invoiceitem.description,
credit_note_line_item.description,
line_item.description

discounts[0][coupon]

discounts.coupon

/v1/invoiceitems/{invoiceitem}.in.discounts.0.coupon

discounts[0][discount]

discounts.discount

/v1/invoiceitems/{invoiceitem}.in.discounts.0.discount

price
price_data[currency]
price_data[product]
tax_rates[0]

price.id

invoice.lines.data.price.currency

invoice.lines.data.price.product
tax_rate.id

e
p
i
r
t
S

e
r
a
q

S

/v1/webhook_endpoints_GET

Response

-

object

N/A (Method returns constant string).

Parameter

No
No

destination
transfer_group

account.id
transfer.transfer_group

/v1/transfers_GET

Response

-

object

N/A (Method returns constant string).

Parameter

Yes

subscription

subscription.id

/v1/subscription_items_GET

Response

-

object

subscription.items.object

tax_rate

country

description
display_name

tax_rate.id
tax_rate.country
tax_rate.description
tax_rate.display_name

jurisdiction

tax_rate.jurisdiction

/v1/tax_rates/{tax_rate}_POST

Parameter

/v2/customers_POST

Parameter

Yes
No
No
No

No

No
No
No
No
No
No
No
No
No
No
No

/v2/orders/{order_id}_GET

Parameter

Yes

state

given_name
family_name
company_name

nickname
email_address

address
phone_number
reference_id

note

birthday

order_id

/v2/catalog/list_GET

/v2/labor/break-types_GET

Parameter

Parameter

/v2/inventory/batch-retrieve-counts_POST

Parameter

No
No
No
No
No
No
No

types
catalog_version
location_id
catalog_object_ids[0]
location_ids[0]
updated_after

states[0]

tax_rate.state

Customer.given_name
Customer.famile_name
Customer.company_name

Customer.nickname
Customer.email_address

Address
Customer.phone_number
Customer.reference_id

Customer.note

Customer.birthday

Order.id

CatalogObject.type

CatalogObject.version

Location.id

CatalogObject.id

Location.id
Counts.updated_at

Counts.states

price.id, plan.id
/v1/invoiceitems/{invoiceitem}.in.price_data.currency
/v1/invoiceitems/{invoiceitem}.in.price_data.product
/v1/invoiceitems/{invoiceitem}.in.tax_rates.0
radar.value_list.list_items.object,
credit_note.lines.object, customer.sources.object,
subscription.items.object, payment_intent.charges.object,

charge.refunds.object, file.links.object,

customer.subscriptions.object, invoice.lines.object

/v1/transfers.in.destination
/v1/transfers.in.transfer_group
radar.value_list.list_items.object,
credit_note.lines.object, customer.sources.object,
subscription.items.object, payment_intent.charges.object,

charge.refunds.object, file.links.object,

customer.subscriptions.object, invoice.lines.object

invoiceitem.subscription, invoice.subscription,
discount.subscription, subscription_item.subscription,
line_item.subscription,subscription.id
radar.value_list.list_items.object,
credit_note.lines.object, customer.sources.object,
subscription.items.object, payment_intent.charges.object,

charge.refunds.object, file.links.object,

customer.subscriptions.object, invoice.lines.object
tax_rate.id, invoice_tax_amount.tax_rate
/v1/tax_rates/{tax_rate}.in.country
tax_rate.description
tax_rate.display_name
address.state, invoice.account_country,
card.country,tax_rate.jurisdiction,
tax_rate.country, source_type_card.country,
account.country, payment_method_card.country,
payment_method_details_card.country,
country_spec.supported_transfer_countries.[?],
card.address_state, country_spec.id,

address.country
/v1/tax_rates/{tax_rate}.in.state
Customer.given_name, InvoiceRecipient.given_name
Customer.family_name, InvoiceRecipient.family_name
Customer.company_name

Customer.nickname
/v2/customers.in.email_address

Address
Customer.phone_number
Customer.reference_id

Customer.note

/v2/customers.in.birthday
Transaction.id, Payment.order_id,Order.id,
Transaction.order_id, Invoice.order_id,
Tender.transaction_id, OrderEntry.order_id

CatalogObject.type
/v2/catalog/list.in.catalog_version
/v2/labor/break-types.in.location_id
/v2/inventory/batch-retrieve-counts.in.catalog_object_ids.0
/v2/inventory/batch-retrieve-counts.in.location_ids.0
/v2/inventory/batch-retrieve-counts.in.updated_after

/v2/inventory/batch-retrieve-counts.in.states.0

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

E.1 Slack

1.1. Retrieve emails of all members in a channel
Type query:

{ channel_name: objs_conversation.name } → [objs_user_profile.

}

let x2 = /conversations_history_GET(channel=x1.id, oldest=ts)
x3 ← x2.messages
if x3.user = user_id

return x3

↩→ email]

Solution:

\channel_name → {

let x0 = /conversations_list_GET()
x1 ← x0.channels
if x1.name = channel_name
let x2 = /conversations_members_GET(channel=x1.id)
x3 ← x2.members
let x4 = /users_profile_get_GET(user=x3)

return x4.profile.email

}

Source: https://stackoverflow.com/questions/41564027/slack-api-retrieve-
all-member-emails-from-a-slack-channel

1.2. Send a message to a user given their email
Type query:

{ email: objs_user_profile.email } → objs_message

Solution:

\email → {

let x0 = /users_lookupByEmail_GET(email=email)
let x1 = /conversations_open_POST(users=x0.user.id)
let x2 = /chat_postMessage_POST(channel=x1.channel.id)

return x2.message

}

Source: https://stackoverflow.com/questions/43733375/slack-api-post-me
ssage-via-user-email

1.3. Get the unread messages of a user
Type query:

{ user_id: defs_user_id } → [[objs_message]]

Solution:

\user_id → {

let x0 = /users_conversations_GET(user=user_id)
x1 ← x0.channels
let x2 = /conversations_info_GET(channel=x1.id)
let x3 = /conversations_history_GET(channel=x2.channel.id,

↩→ oldest=x2.channel.last_read)

return x3.messages

}

Source: https://github.com/hisabimbola/slack-history-export/blob/e53868
d8820ba65e5e726bd5968c80d5eb54c0db/src/utils.js

1.5. Create a channel and invite a list of users
Type query:

{ user_ids: [defs_user_id],

channel_name: objs_conversation.name

} → [objs_conversation]

Solution:

\user_ids channel_name → {

let x0 = /conversations_create_POST(name=channel_name)
x1 ← user_ids
let x2 = /conversations_invite_POST(channel=x0.channel.id,

↩→ users=x1)

return x2.channel

}

Source: https://stackoverflow.com/questions/48328380/slack-api-channels-
create-followed-by-channels-invite-info-returns-channel-not

1.6. Reply to a message and update it
Type query:

{ channel: defs_channel,

ts: defs_ts
} → objs_message

Solution:

\channel ts → {

let x1 = /chat_postMessage_POST(channel=channel, thread_ts=ts

↩→ )

let x2 = /chat_update_POST(channel=channel, ts=x1.ts)

return x2.message

}

1.7. Send a message to a channel with the given name
Type query:

{ channel: objs_conversation.name } → objs_message

Solution:

\channel → {

let x0 = /conversations_list_GET()
x1 ← x0.channels

Source: https://stackoverflow.com/questions/64561594/is-it-possible-to-kn
ow-the-number-of-unread-slack-messages-a-user-has-with-the-s

if x1.name = channel
let x2 = /chat_postMessage_POST(channel=x1.id)

1.4. Get all messages associated with a user
Type query:

{ user_id: defs_user_id,

ts: defs_ts

} → [objs_message]

Solution:

\user_id ts → {

let x0 = /conversations_list_GET()
x1 ← x0.channels

return x2.message

}

Source: https://github.com/backspace/slack-statsbot/blob/primary/src/st
atsbot.js

1.8. Get the unread messages of a channel
Type query:

{ channel_id: defs_channel } → [[objs_message]]

Solution:

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

\channel_id → {

}

let x2 = /conversations_info_GET(channel=channel_id)
let x3 = /conversations_history_GET(channel=channel_id,

↩→ oldest=x2.channel.last_read)

return x3.messages

}

Source: https://stripe.com/docs/invoicing/prices-guide

2.4. Retrieve a customer by email
Type query:

{ email: customer.email } → customer

Source: https://stackoverflow.com/questions/64561594/is-it-possible-to-kn
ow-the-number-of-unread-slack-messages-a-user-has-with-the-s

Solution:

\email → {

E.2 Stripe

2.1. Subscribe to a product for a customer
Type query:

{ customer_id: customer.id,
product_id: product.id

} → [subscription]

Solution:

\customer_id product_id → {

let x1 = /v1/prices_GET(product=product_id)
x2 ← x1.data
let x3 = /v1/subscriptions_POST(customer=customer_id, items

↩→ [0][price]=x2.id)

return x3

}

Source: https://github.com/stripe-samples/charging-for-multiple-plan-su
bscriptions/blob/master/server/node/server.js

2.2. Subscribe to multiple items
Type query:

{ customer_id: customer.id,
product_ids: [product.id]

} → [subscription]

Solution:

\customer_id product_ids → {

x0 ← product_ids
let x1 = /v1/prices_GET(product=x0)
x2 ← x1.data
let x3 = /v1/subscriptions_POST(customer=customer_id, items

↩→ [0][price]=x2.id)

return x3

}

Source: https://github.com/stripe-samples/charging-for-multiple-plan-su
bscriptions/blob/master/server/node/server.js

2.3. Create a product and invoice a customer
Type query:

{ product_name: product.name,
customer_id: customer.id,

currency: fee.currency,
unit_amount: plan.amount

} → invoiceitem

Solution:

\product_name customer_id currency unit_amount → {
let x0 = /v1/products_POST(name=product_name)
let x1 = /v1/prices_POST(currency=currency, product=x0.id,

↩→ unit_amount=unit_amount)

let x2 = /v1/invoiceitems_POST(customer=customer_id, price=x1

↩→ .id)

return x2

let x0 = /v1/customers_GET()
x1 ← x0.data

if x1.email = email

return x1

}

Source: https://stackoverflow.com/questions/26767150/stripe-is-it-possib
le-to-search-a-customer-by-their-email

2.5. Get a list of receipts for a customer
Type query:

{ customer_id: customer.id } → [charge]

Solution:

\customer_id → {

let x1 = /v1/invoices_GET(customer=customer_id)
x2 ← x1.data
let x3 = /v1/charges/{charge}_GET(charge=x2.charge)

return x3

}

Source: https://stackoverflow.com/questions/24335268/stripe-api-receipts-
listing

2.6. Get a refund for a subscription
Type query:

{ subscription: subscription.id } → refund

Solution:

\subscription → {

let x0 = /v1/subscriptions/{subscription_exposed_id}_GET(

↩→ subscription_exposed_id=subscription)

let x1 = /v1/invoices/{invoice}_GET(invoice=x0.latest_invoice

↩→ )

let x2 = /v1/refunds_POST(charge=x1.charge)

return x2

}

Source: https://stackoverflow.com/questions/62403075/stripe-api-get-up
coming-invoice-for-cancelled-subscription

2.7. Get the emails of all customers
Type query:

{ } → [customer.email]

Solution:

\ → {

let x0 = /v1/customers_GET()
x1 ← x0.data

return x1.email

}

Source: https://stackoverflow.com/questions/65545997/python3-stripe-api-
to-get-all-customer-email

2.8. Get the emails of the subscribers of a product
Type query:

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

{ product_id: product.id } → [customer.email]

Solution:

\product_id → {

let x1 = /v1/subscriptions_GET()
x2 ← x1.data
x3 ← x2.items.data
if x3.price.product = product_id
let x4 = /v1/customers/{customer}_GET(customer=x2.customer)

return x4.email

}

Source: https://stackoverflow.com/questions/35882771/use-stripe-api-to-
return-a-list-of-valid-subscribers

2.9. Get the last 4 digits of a customer’s card
Type query:

{ customer_id: customer.id } → bank_account.last4

Solution:

\customer_id → {

let x0 = /v1/customers/{customer}/sources_GET(customer=

↩→ customer_id)

x1 ← x0.data

return x1.last4

}

Source: https://stackoverflow.com/questions/17807881/stripe-api-throwi
ng-error-when-trying-to-delete-a-card

2.12. Save a card during payment
Type query:

{ cur: fee.currency,

amt: plan.amount,
pm: payment_method.id

} → payment_intent

Solution:

\cur amt pm → {

let x1 = /v1/customers_POST()
let x2 = /v1/payment_intents_POST(customer=x1.id,

↩→ payment_method=pm, currency=cur, amount=amt)
let x3 = /v1/payment_intents/{intent}/confirm_POST(intent=x2.

↩→ id)

return x3

}

Source: https://github.com/stripe-samples/saving-card-after-payment/bl
ob/master/without-webhooks/server/node/server.js

2.13. Send an invoice to a customer
Type query:

{ customer_id: customer.id,

Source: https://stackoverflow.com/questions/30447026/getting-last4-digits-
of-card-using-customer-object-stripe-api-with-php

price_id: plan.id

} → invoice

2.10. Update payment methods for a user’s subscriptions
Type query:

Solution:

\customer_id price_id → {

{ payment_method: payment_method,

customer_id: customer.id

} → [subscription]

Solution:

\payment_method customer_id → {

let x0 = /v1/subscriptions_GET(customer=customer_id)
x1 ← x0.data
let x2 = /v1/subscriptions/{subscription_exposed_id}_POST(

↩→ subscription_exposed_id=x1.id,
↩→ default_payment_method=payment_method.id)

return x2

}

let x1 = /v1/invoiceitems_POST(customer=customer_id, price=

↩→ price_id)

let x2 = /v1/invoices_POST(customer=x1.customer)
let x3 = /v1/invoices/{invoice}/send_POST(invoice=x2.id)

return x3

}

Source: https://stripe.com/docs/invoicing/integration#send-invoice

E.3 Sqare

3.1. List invoices that match a location id
Type query:

{ location_id: Location.id } → [Invoice]

Source: https://stackoverflow.com/questions/58270828/update-credit-card-
details-of-user-for-all-subscriptions-in-stripe-using-api

Solution:

\location_id → {

2.11. Delete the default payment source for a customer
Type query:

{ customer_id: customer.id } → payment_source

Solution:

\customer_id → {

let x0 = /v2/invoices_GET(location_id=location_id)

return x0.invoices

}

Source: https://github.com/square/connect-api-examples/blob/4283ac967c
31b75dc17aceebd84f649093477e9a/connect-examples/v2/node_invoices/ro
utes/management.js

let x0 = /v1/customers/{customer}_GET(customer=customer_id)
let x1 = /v1/customers/{customer}/sources/{id}_DELETE(

↩→ customer=customer_id, id=x0.default_source)

3.2. List subscriptions by location, customer, and plan
Type query:

return x1

}

{ customer_id: Customer.id,
location_id: Location.id,
plan_id: CatalogObject.id

} → [Subscription]

Solution:

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

Zheng Guo, David Cao, Davin Tjong, Jean Yang, Cole Schlesinger, and Nadia Polikarpova

\customer_id location_id plan_id → {

let x0 = /v2/subscriptions/search_POST()
x1 ← x0.subscriptions
if x1.customer_id = customer_id
if x1.location_id = location_id
if x1.plan_id = plan_id

return x1

}

Source: https://github.com/square/connect-api-examples/blob/4283ac967c
31b75dc17aceebd84f649093477e9a/connect-examples/v2/node_subscriptio
n/routes/subscription.js

3.3. Get all items a tax applies to
Type query:

{ tax_id: CatalogObject.id } → [CatalogObject]

Solution:

\tax_id → {

let x0 = /v2/catalog/search_POST()
x1 ← x0.objects
x2 ← x1.item_data.tax_ids
if x2 = tax_id

return x1

}

Source: https://github.com/square/catalog-api-demo/blob/85b6754c90fa7b
66fc5e605ee7a344314537eade/src/main/java/com/squareup/catalog/demo/e
xample/ApplyTaxToAllIItemsExample.java

3.4. Get a list of discounts in the catalog
Type query:

{ } → [CatalogDiscount]

Solution:

\ → {

let x0 = /v2/catalog/list_GET()
x1 ← x0.objects
return x1.discount_data

}

Source: https://github.com/square/catalog-api-demo/blob/master/src/mai
n/java/com/squareup/catalog/demo/example/ListDiscountsExample.java

3.5. Add order details to order
Type query:

{ location_id: Location.id,
order_ids: [Order.id],

updates: [OrderFulfillment]

} → [Order]

Solution:

\location_id order_ids updates → {

x0 ← order_ids
let x1 = /v2/orders/batch-retrieve_POST(location_id=

↩→ location_id, order_ids[0]=x0)

x2 ← x1.orders

let x3 = {fulfillments=updates}
let x4 = /v2/orders/{order_id}_PUT(order_id=x2.id, order=x3)

return x4.order

}

Source: https://github.com/square/connect-api-examples/blob/4283ac967c
31b75dc17aceebd84f649093477e9a/connect-examples/v2/node_orders-paym
ents/routes/checkout.js

3.6. Get payment notes of a payment
Type query:

{ } → [Payment.note]

Solution:

\ → {

let x0 = /v2/payments_GET()
x1 ← x0.payments

return x1.note

}

Source: https://stackoverflow.com/questions/23252751/square-connect-api-
list-payments-endpoint-not-showing-description

3.7. Get order ids of current user’s transactions
Type query:

{ location_id: Location.id } → [Order.id]

Solution:

\location_id → {

let x0 = /v2/locations/{location_id}/transactions_GET(

↩→ location_id=location_id)

x1 ← x0.transactions
return x1.order_id

}

Source: https://stackoverflow.com/questions/46910044/getting-compact-
information-from-square-connect-api

3.8. Get order names from a transaction id
Type query:

{ location_id: Location.id,
transaction_id: Order.id

} → [Invoice.title]

Solution:

\location_id transaction_id → {

let x0 = /v2/orders/batch-retrieve_POST(location_id=

↩→ location_id, order_ids[0]=transaction_id)

x1 ← x0.orders
x2 ← x1.line_items

return x2.name

}

Source: https://stackoverflow.com/questions/58047894/square-connect-ho
w-to-retrieve-product-information-from-transaction-id

3.9. Find customers by name
Type query:

{ name: Customer.given_name } → Customer

Solution:

\name → {

let x0 = /v2/customers_GET()
x1 ← x0.customers
if x1.given_name = name

return x1

}

Source: https://developer.squareup.com/forums/t/search-customers-by-na
me/1567

3.10. Delete catalog items with names
Type query:

Type-Directed Program Synthesis for RESTful APIs

PLDI ’22, June 13–17, 2022, San Diego, CA, USA

{ item_type: CatalogObject.type,

names: [CatalogItem.name]

} → [CatalogObject.id]

Solution:

\item_type names → {

let x0 = /v2/catalog/search_POST(object_types[0]=item_type)
x1 ← x0.objects
x2 ← names
if x1.item_data.name = x2
let x3 = /v2/catalog/object/{object_id}_DELETE(object_id=x1.

↩→ id)

x4 ← x3.deleted_object_ids

return x4

}

Source: https://github.com/square/catalog-api-demo/blob/85b6754c90fa7b
66fc5e605ee7a344314537eade/src/main/java/com/squareup/catalog/demo/e
xample/DeleteCategoryExample.java

3.11. Delete all catalog items
Type query:

{ } → [CatalogObject.id]

Solution:

\ → {

let x0 = /v2/catalog/list_GET()
x1 ← x0.objects
let x2 = /v2/catalog/object/{object_id}_DELETE(object_id=x1.

↩→ id)

return x2.deleted_object_ids

}

Source: https://github.com/square/catalog-api-demo/blob/85b6754c90fa7b
66fc5e605ee7a344314537eade/src/main/java/com/squareup/catalog/demo/e
xample/DeleteAllItemsExample.java

