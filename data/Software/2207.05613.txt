2
2
0
2

l
u
J

2
1

]
E
S
.
s
c
[

1
v
3
1
6
5
0
.
7
0
2
2
:
v
i
X
r
a

Making Python Code Idiomatic by Automatic Refactoring
Non-Idiomatic Python Code with Pythonic Idioms

Zejun Zhang
Australian National University
Australia
zejun.zhang@anu.edu.au

Zhenchang Xing
Data61, CSIRO
Australian National University
Australia
zhenchang.xing@anu.edu.au

Xin Xia∗
Software Engineering Application
Technology Lab, Huawei
China
xin.xia@acm.org

Xiwei Xu
Data61, CSIRO
Australia
xiwei.xu@data61.csiro.au

Liming Zhu
Data61, CSIRO
Australia
Liming.Zhu@data61.csiro.au

ABSTRACT
Compared to other programming languages (e.g., Java), Python
has more idioms to make Python code concise and efficient. Al-
though pythonic idioms are well accepted in the Python community,
Python programmers are often faced with many challenges in using
them, for example, being unaware of certain pythonic idioms or
do not know how to use them properly. Based on an analysis of
7,638 Python repositories on GitHub, we find that non-idiomatic
Python code that can be implemented with pythonic idioms occurs
frequently and widely. Unfortunately, there is no tool for automati-
cally refactoring such non-idiomatic code into idiomatic code. In
this paper, we design and implement an automatic refactoring tool
to make Python code idiomatic. We identify nine pythonic idioms by
systematically contrasting the abstract syntax grammar of Python
and Java. Then we define the syntactic patterns for detecting non-
idiomatic code for each pythonic idiom. Finally, we devise atomic
AST-rewriting operations and refactoring steps to refactor non-
idiomatic code into idiomatic code. We test and review over 4,115
refactorings applied to 1,065 Python projects from GitHub, and sub-
mit 90 pull requests for the 90 randomly sampled refactorings to 84
projects. These evaluations confirm the high-accuracy, practicality
and usefulness of our refactoring tool on real-world Python code.
Our refactoring tool can be accessed at 47.242.131.128:5000.

KEYWORDS
Pythonic Idioms, Abstract Syntax Grammar, Code Refactoring

1 INTRODUCTION
Programming (or code) idioms are widely present in programming
languages [17]. They represent notable programming styles and
features of a programming language. Python is well known for
its pythonic idioms [46, 61]. Many books and online materials [29,
41, 44, 46, 54, 58] promote the use of pythonic idioms for not only
concise coding styles but also improved performance (see Table 1
for examples). In spite of the benefits of pythonic idioms and the
availability of many online materials, our investigation of some
highly viewed Python questions on Stack Overflow suggests that
developers are often unaware of pythonic idioms or do not know

when and how to use pythonic idioms properly (see the examples
in Table 4 and the analysis in Section 2.2).

Due to these challenges in using pythonic idioms, developers
may implement a functionality in a non-idiomatic way without
using pythonic idioms. Table 1 shows some examples. We study
7,638 Python projects on GitHub (see Section 2.2) and find that
non-idiomatic code that can be implemented with pythonic idioms
is widely present at the repository, file, method and statement
level (see Table 2). Non-idiomatic code and idiomatic code co-exist
in many repositories, files or even methods. As seen in Table 1,
non-idiomatic code syntax is similar to those of other mainstream
programming languages (e.g., Java). In contrast, pythonic idioms
have “uncommon” syntax. Developers, even those with little Python
programming experience, can still write non-idiomatic code. How-
ever, to use pythonic idioms, they would need to learn new syntax
or need some tool supports.

Although online documentation of pythonic idioms provide rich
learning materials, they cannot directly support programming with
pythonic idioms. To the best of our knowledge, only two tools
provide limited support for using pythonic idioms. Among the
nine pythonic idioms in Table 1, Pylint [1] can detect two types of
non-idiomatic code which can be refactored into chain-comparison
and truth-value-test respectively. However, it offers only a simple
refactoring suggestion which may not be intuitive to developers.
For example, for the code “a < 0 and b > 1 and c < 1 and d > 2”, Pylint
suggests “Simplify chained comparison between the operands”1.
Unfortunately, the developer did not understand this suggestion
initially. When Pylint developer further explained that the code
can be refactored into “a < 0 and b > 1 > c and d > 2”, the developer
understood what to do and left a comment “Would it be an idea
for Pylint to output the suggested refactor to the user?” which
received thumbs up by other developers. Teddy [51] collects 58
non-idiomatic code fragments and corresponding 55 idiomatic code
(three pythonic idioms list-comprehension, set-comprehension and
truth-value-test overlap with 9 idioms in Table 1). It detects non-
idiomatic code similar to the collected 58 examples and recommends
corresponding idiomatic code examples. Developers still have to
manually refactor the non-idiomatic code.

∗Corresponding author.

1https://github.com/PyCQA/pylint/issues/5800

1

 
 
 
 
 
 
ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Zejun Zhang, Zhenchang Xing, Xin Xia, Xiwei Xu, and Liming Zhu

In this paper, we develop the first automatic refactoring tool
that detects 9 types of non-idiomatic code (referred to as anti-
idiom code smells) and refactors these anti-idiom code smells into
idiomatic code implementing the same functionalities. Existing
work [30, 31, 36, 46, 57] mines recurring code idioms from source
code or relies on books that include many idioms that are not unique
to Python. To identify unique pythonic idioms, we contrast the lan-
guage syntax of Python and the other mainstream programming
language (Java in this work). This is inspired by the observation that
non-idiomatic code syntax is similar to those of other languages
but idiomatic code has unique syntax. Our analysis identifies 9
types of pythonic idioms (see Table 1). We confirm the validity of
these pythonic idioms through the Python language specification
and online materials [41, 44, 58]. For each pythonic idiom, we de-
fine syntactic patterns for detecting non-idiomatic code fragments
that implement the same functionality as the pythonic idiom. Fol-
lowing the refactoring principle (one small step at a time) [37],
we formulate four atomic AST rewriting operations and compose
these atomic operations for each pythonic idiom for refactoring
anti-idiom code with the corresponding pythonic idiom.

To evaluate the code smell detection and refactoring accuracy
of our approach, we apply our tool to 7,638 Python projects which
detects and refactors over 2,252,022 anti-idiom code smells. We
verify the refactoring results by both testing and code review. Our
approach achieves 100% smell detection accuracy for six idioms
and 100% refactoring accuracy for eight idioms. It makes only a
few rare detection errors and only one refactoring error due to
the limitation of Python static analysis and the complex program
logic. To explore the usefulness of our code refactoring tool in
practice, we randomly sample 10 refactorings respectively for each
pythonic idiom, and submit in total 90 pull requests to 84 projects
to make the project members review our refactorings. As a result,
we receive 57 replies from 54 projects, of which 34 accept our pull
request with praise of our refactorings and 28 replies merge the
pull requests into their repositories. Our results show developers
care about pythonic idiom refactorings, and our refactorings have
been well received in practice. The developers’ feedback on the
rejected pull requests reveal some interesting concerns about the
readability and performance of pythonic idioms which deserve
further study. The dataset of anti-idiom code and corresponding
idiomatic code produced in this work provides the first large-scale
test bed to systematically investigate such concerns.

In summary, this paper makes the following contributions:

• To the best of our knowledge, we are the first to automatically
detect non-idiomatic code and refactor it into idiomatic code for
9 widely used pythonic idioms.

• Through the evaluation on a large number of real-world Python
projects, we confirm the high accuracy, practicality and useful-
ness of our refactoring tool.

• Our work creates the first large-scale dataset of anti-idiom code
smells and corresponding idiomatic code for studying and vali-
dating the claims and concerns about pythonic idioms.

2 FORMATIVE STUDY AND MOTIVATION
We conduct an empirical study of pythonic coding practices to
answer the following three research questions:

2

Table 1: Pythonic idioms: conciseness and performance
Idiom
X
List
Compre-
hension

Anti-idiom code smell
t = []
for i in range(10000):

t =[i for i in
range(10000)]

Idiomatic code

t.append(i)

2.07

Resource
performance benefits to
using a list compre-
hension [11, 29, 44]
Set comprehension
is a more compact
and faster way to
create sets [20]
Use a dict comp-
rehension to build
a dict clearly and
efficiently [7, 29, 44]
...can have a posi-
tive effect on per-
formance [5, 6, 44]
...can make your
code more effici-
ent... [24, 25, 28]

Set
Compre-
hension

Dict
Compre-
hension

Chain
Compar-
ison
Truth
Value
Test

Loop
Else

an efficient
for loop imple-
mentation [12, 41]

Assign
Multiple
Targets

Star in
Func Call

For
Multiple
Targets

Speed up and shorten
your code is to assign
the variables in your -
program at the same
time [2–4]
Unpacking is faster
than accessing by
index [8, 22]
Accessing by index
slow things down
compared to for loop
item unpacking [8, 9]

simpsons_set =set()
for word in chars:

simpsons_set.add(word)

simpsons_set = {
word for word
in chars}

1.70

b = {}
for k,v in a.items():

b[v]=k

a <= b
and b <= c and c <= d
and d <= e and e <= f

if a==[]:
pass

finishedForLoop = True
for x in range(2, n):

if n % x == 0:

finishedForLoop=False
break

if finishedForLoop:

pass

a = 2
b = 3
c = 5
d = 7

s = sum(values[0],
values[1])

for item in sales:

a=item[0], item[1],
item[2]

b = {v: k
for k, v in a.items()}

1.09

a <= b <= c
<= d <= e <= f

if not a:
pass

for x in range(2, n):
if n % x == 0:

break

else:
pass

a, b, c, d
= 2, 3, 5, 7

1.15

1.82

1.17

1.21

s = sum(*values)

1.45

for product, price,
sold_units in sales:
a =product, price,
sold_units

1.56

RQ1: What are the benefits of pythonic idioms?
RQ2: What are the coding practices concerning pythonic idioms
and anti-idiom code smells?
RQ3: What are the challenges for writing idiomatic code?

2.1 RQ1: The Benefits of Pythonic Idioms
Compared with other mainstream programming languages, Python
supports more idioms which are highly valued by Python develop-
ers [29]. By referring to several resources (i.e., books, presentations
and websites) about pythonic idioms [13, 21, 29, 41, 44, 46, 54, 58],
we summarize the key benefits of pythonic idioms: conciseness
(i.e., fewer lines or fewer tokens) and performance. To help readers
understand these two benefits, we summarize in Table 1 the code
examples of idiomatic code and the corresponding non-idiomatic
code (i.e., anti-idiom code smell) for each pythonic idiom excerpted
from the reference resources. We also excerpt relevant performance
descriptions. We omit conciseness related descriptions as code con-
ciseness can be observed intuitively from code examples.

To confirm the performance benefit, we use the timeit pack-
age [23] to record the execution time of idiomatic and non-idiomatic
code snippets shown in Table 1. We execute each code snippet
three times repeatedly and take the average execution time. We
divide the execution time of non-idiomatic code by that of cor-
responding idiomatic code which indicates how much speedup
idiomatic code has compared with non-idiomatic code. As shown
in the fifth column of Table 1, idiomatic code has about 1.09~2.07x
speedup. We acknowledge this is only an anecdotal experiment.
Many online resources [10, 29] argue pythonic idioms (e.g., list
comprehension) may achieve significant performance advantages
over non-idiomatic code, but they generally do not provide specific
empirical evidences. This calls for more systematic investigation of
such performance claims which is beyond the scope of this work.

Making Python Code Idiomatic by Automatic Refactoring Non-Idiomatic Python Code with Pythonic Idioms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Table 3: Statistics of pythonic idioms and anti-idiom code
smells at the statement level

Idiom
List Compre
Set Compre
Dict Compre
Chain Comparison
Truth Value Test
Loop Else
Assign Multi Targets
Star in Func Call
For Multi Targets

Non-idiomatic
26510
1596
10695
53811
197667
1644
1934165
17444
8490

Idiomatic
349912
9304
42149
26913
1023539
5552
70700
90292
127305

Sum
376422
10900
52844
80724
1221206
7196
2004865
107736
135795

%
0.070
0.146
0.202
0.667
0.162
0.228
0.965
0.162
0.063

idioms or contain 5 or more types of non-idiomatic code that can
be refactored with pythonic idioms.

Table 2 summarizes the number of repositories, files and methods
containing non-idiomatic code smells (the NPy column), pythonic
idiom (PyId) and both non-idiomatic and idiomatic code ((cid:209)) for
each pythonic idiom. We see that many repositories, files or even
methods often have a mix of idiomatic and non-idiomatic code
to achieve the same functionality. For example, a large number
of repositories and files mix the use of the list-comprehension
idiom and non-idiomatic list operation, and 8,258 methods contain
both idiomatic list comprehension and non-idiomatic list operation
that can be refactored into idiomatic list comprehension. Among
the nine pythonic idioms, set-comprehension and loop-else have
relatively low mix usage, while truth-value-test and assign-multiple-
targets have high mix usage in methods.

Table 3 summarizes the occurrence of non-idiomatic code that
can be refactored with an idiom (the Non-idiomatic column) and
the occurrence of a type of pythonic idiom (the Idiomatic column)
at the statement level. Sum is the sum of the two occurrences and
% is the percentage of the non-idiomatic code out of the Sum. For
the five pythonic idioms (set-comprehension, dict-comprehension,
truth-value-test, loop-else and star-in-func-call), the percentages
of non-idiomatic code are about 14.6%-22.9%. List-comprehension
and for-multi-targets have low non-idiomatic percentages (7.0%
and 6.3% respectively). This may be due to the popularity of these
two idioms in the Python community. Most of online resources we
read mention these two idioms. These two idioms have been used
more than 349K and 127K times. Although the percentage of non-
idiomatic code is low, there are still large numbers of non-idiomatic
code fragments (26,510 and 8,490) that can be refactored with the
list-comprehension idiom and the for-multi-targets idiom respec-
tively. In contrast, chain-comparison and assign-multi-targets have
high non-pythonic percentages (66.7% and 96.5% respectively). Ex-
pression comparison and assignment are very basic programming
constructs no matter in Python or other programming languages.
However, developers may not realize unique pythonic idioms for
comparison and assignment. For example, developers are surprised
when they see Python can make comparison for more than two
operands2.

2.3 RQ3: Challenges in Writing Idiomatic Code
We examine Stack Overflow questions to understand the challenges
in writing idiomatic code. We search the questions for each pythonic
idiom using the “python” tag and the pythonic idiom name. We
examine the returned top 30 questions and summarize the chal-
lenges in using pythonic idioms in the discussions. We summarize

2https://stackoverflow.com/questions/26502775/simplify-chained-comparison

Figure 1: The usage of pythonic idioms and anti-idiom code
smells in repositories, files and methods
Table 2: Python coding practices with respect to pythonic
idioms and anti-idiom code smells

Idiom

List Compre
Set Compre
Dict Compre
Chain Compare
Truth Val Test
Loop Else
Assign Multi
Star in Func Call
For Multi

Repository
PyId (cid:209)
6161
1048
3167
2690
6930
1204
4074
4185
5372

3619
319
1600
2252
5728
65
4068
1840
1812

NPy
3814
700
2348
4334
5885
806
7271
2336
2018

File
PyId (cid:209)
NPy
10040
97775
17732
151
4724
1279
1636
20871
7837
11066
3095
26017
179184 46303
67991
1399
3602
288578 28193
30566
7671
57063
5314

133
26452
1977
1953

Method
PyId
NPy
219414
24505
7151
1512
32941
10001
17241
39045
578141
135861
1644
4537
1173508 49560
64492
11325
104893
7245

(cid:209)

8258
115
1113
2467
48550
127
46075
2303
1923

2.2 RQ2: Python Coding Practices
2.2.1 Data Preparation. To understand the coding practices with
respect to pythonic idioms and anti-idiom code smells, we crawl the
top 10,000 repositories using Python by the number of stars from
GitHub. 7,638 repositories can be successfully parsed using Python
3. We collect 506,765 Python source files from these repositories.
We then detect the occurrence of idiomatic code and the anti-idiom
code that can be refactored with pythonic idioms in these Python
source files. All nine pythonic idioms can be detected by analyz-
ing abstract syntax trees (ASTs). List/set/dict-comprehension and
loop-else idioms directly correspond to AST nodes, we can directly
detect such idiomatic code instances. For star-in-function-call, we
extract starred node in function call node. For truth-value-test,
we extract the test node corresponding to an object. For chain-
comparison, assign-multiple-targets and for-multiple-targets, we
extract operators of the compare node, the value and targets of
the assign node, and the target of for node with elements greater
than 1, respectively. For non-idiomatic code, we use our detection
rules (see Section 3.2) to detect non-idiomatic code instances. We
count the number of repositories, files, methods and statements
that contain the instances of idiomatic code and non-idiomatic code.
Note that a repository, file or method may contain both pythonic
idioms and refactorable non-idiomatic code.

2.2.2 Result. Figure 1 shows the numbers of repositories, files
and methods using different types of pythonic idioms and anti-
idiom code smells. We see that although pythonic idioms are well
adopted in the Python projects, there are still non-trivial usage of
non-idiomatic code that can be refactored with pythonic idioms. Fur-
thermore, a repository, file or method generally uses multiple types
of idiomatic and non-idiomatic code. There are non-trivial num-
bers of repositories and files that use 5 or more types of pythonic

3

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Zejun Zhang, Zhenchang Xing, Xin Xia, Xiwei Xu, and Liming Zhu

three key challenges. Table 4 shows some representative examples.
Many questions have very high view counts which indicate com-
mon information needs. The #C column lists the challenge index
as discussed below. One question may involve several challenges.
However, we observe that the three challenges have a progressive
relationship. For example, when developers do not know the mean-
ing of an idiom, they would also further ask how to use the idiom
correctly. Therefore, we list only the most fundamental challenge.
(1) Developers do not know certain pythonic idioms. For
example, for the dict-comprehension idiom (the 4th row in Table 4),
the developer knows list comprehension but he/she does not know
whether he/she can initialize dictionary in a similar way. The ques-
tion has been viewed about 1,000,000 times. Although it was asked
12 years ago, it was still actively discussed about 1 month ago (as of
this paper writing). Idioms in Python are more than those in other
mainstream languages [29], which brings challenges for developers
to learn and write idiomatic Python code.

(2) Developers know certain pythonic idioms but they do
not understand what the idioms can do. Consider the question
for using asterisk operator “*” in the function call (the second last
row in Table 4) which has been viewed about 234,000 times. The
developer notices a single asterisk (zip(*x)) can be used before a
parameter in function calls, but he/she does not know what this
means and what it can be used for. Actually, the *x is to unpack x
into multiple arguments. Knowing what an idiom can be used for
is the pre-requisite for using it in practice.

(3) Developers know what a pythonic idiom can do but
they do not know how to use them properly. The 2nd row of
Table 4 shows such an example. The developer wants to refactor a
list initialization using list comprehension. Unfortunately, he/she
does not know whether and how if-else statement can be used in
the list-comprehension idiom. The question has been viewed about
165,000 times. In fact, list-comprehension has complex syntax and
it may nest multiple loops and multiple if statements. Developers
have to read and understand this complex syntax in order to use
the list-comprehension idiom properly.

It has been generally accepted that pythonic idioms result in concise
code and improve runtime performance. However, non-idiomatic code
that can be refactored with pythonic idioms is widely present in real
world projects and is often mix-used with idiomatic code. This could
be caused by the fact that developers are often unaware of pythonic
idioms or do not know when and how to use pythonic idioms properly.
Although there are rich learning materials about pythonic idioms,
there are no effective tools to assist developers in writing idiomatic
code and to enforce the consistent use of pythonic idioms in practice.

3 OUR APPROACH
We now present our refactoring tool for improving idiomatic cod-
ing practices. Figure 2 shows the three steps for designing and
implementing our refactoring tool. These three steps answer three
technical questions respectively: 1) how to identify programming
idioms unique to Python; 2) how to detect anti-idiom code that
can be implemented in pythonic idioms; 3) how to refactor non-
idiomatic code with pythonic idioms in a systematic and extensible

4

Table 4: Challenges in writing idiomatic Python code

Idiom

#C

Question

List Com-
prehension

Set Com-
prehension

Dict Com-
prehension

(3)

(1)

(1)

Chain
Comparison

(1)

Truth
Value
Test

Loop
Else

Assign
Multiple
Targets

Star in
Func Call

For
Multiple
Targets

(1)

(2)

(1)

(2)

(2)

Question: Here is the code I was trying to turn into a list comprehe-

nsion:...
Is there a way to add the else statement to this comprehension?
Asked 11 years; Active 2 years; Viewed 165k times

Question: Fastest way to generate a random-like unique string with

random length in Python 3
Answer: ...Use a set comprehension to produce a series of keys at a
time to avoid having to look up and call the set.add() method in a loop...
Asked 4 years; Active 6 months ago; Viewed 16k times

Question:

I like the Python list comprehension syntax. Can it be-

used to create dictionaries too? For example, by iterating over pairs of
keys and values:
Asked 12 years; Active 28 days ago; Viewed 1.0m times

Question:

I write the following statement: if x >= start and x <= end:

... the tooltip tells me that I must simplify chained comparison
What have I missed here?
Comment: Thanks, I didn’t know you could do that in Python.
Was really scratching my head on this one.
Asked 7 years; Active 2 years ago; Viewed 100k times

Question: Does Python have something like an empty string

variable where you can do: if myString == string.empty:
Asked 10 years; Active 19 days ago; Viewed 2.5m times

Question: Why does python use ’else’ after for and while loops?

Asked 9 years; Active 2 months ago;Viewed 245k times

Question: Python assigning two variables on one line

Answer: ...use sequence unpacking: self.a, self.b = a, b
Asked 8 years; Active 8 years; Viewed 19k times

Question: What does the * operator mean in Python, such as in code

like zip(*x) or f(**k)?
Asked 11 years; Active 12 months ago; Viewed 234k times

Question: Tuple unpacking in for loops

Asked 9 years; Active 1 month ago; Viewed 222k times

Figure 2: Approach overview

way. Rather than relying on mining code patterns or personal pro-
gramming experience, our solution is built on the effective analysis
of Python language syntax and specification.

3.1 Identifying Unique Pythonic Idioms
A programming idiom can be regarded as a micro-level code pattern.
Mining programming idioms in code [30, 31, 46, 57] may identify a
wide range of code patterns, including not only pythonic idioms but
also many generic code patterns and API usage patterns. As online
materials [29, 41, 44, 46, 54, 58] about idiomatic code usually men-
tion only some popular pythonic idioms (e.g., list-comprehension,

Making Python Code Idiomatic by Automatic Refactoring Non-Idiomatic Python Code with Pythonic Idioms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

truth-value-test and enumerate function) repeatedly based on per-
sonal programming experience, collecting pythonic idioms from
online materials is ad-hoc and may miss important pythonic idioms.
In this work, our goal is to not only identify pythonic idioms but
also analyze these idioms to design the methods for detecting and
refactoring non-idiomatic code in a systematic manner. Therefore,
we resort to Python language syntax and specification. We observe
that non-idiomatic code share the common or similar syntax as
other mainstream programming languages, while pythonic idioms
have unique syntax. Based on this observation, we identify unique
pythonic idioms by contrasting Python syntax and the syntax of
the other programming language. In this work, we choose Java due
to its popularity and syntactic similarity to Python.

We examine each syntactic construct of Python in Python lan-
guage specification [18], and check whether there is some similar
syntactic construct(s) in Java. For similar syntactic constructs, we
further compare and analyze the differences of the syntax gram-
mars between Python and Java. We consider the following four
cases as candidate pythonic idioms:

(1) Python supports new syntactic constructs which do not
exist in Java. This includes four syntactic constructs: ListComp,
SetComp, DictComp and Starred which correspond to four idioms,
list comprehension, set comprehension, dictionary comprehension
and single asterisk operator. The list/set/dict-comprehension create
iterable object with one line of code [14, 15]. The single asterisk
operator is usually used to unpack the an iterable into positional
arguments inside a function call (star-in-func-call) [16]. We also
identify several other new constructs, such as Yield, With and Gen-
eratorExp. However, it is very inconvenient to implement the same
functionality as these new constructs in a non-idiomatic way. As
such, the Yield-, With- or GeneratorExp-equivalent non-idiomatic
code is too complex to safely refactor. Therefore, we do not consider
Yield, With and GeneratorExp in this work.
(2) Python syntax adds new nodes. Python and Java have the
same syntactic construct, but Python syntax adds new nodes to
extend its functionality. This includes the Loop construct which
consists of the For and While statement. For example, the For state-
ment of Python adds orelse node (i.e., the loop-else idiom). The
orelse node is executed after the loop iterator is exhausted, unless
the loop ends prematurely due to a break statement [44].
(3) Python syntax adds new elements. Python and Java have
the same syntactic construct, but Python syntax supports more
elements [18]. This includes the Assign statement with multiple
targets (the assign-multi-targets idiom), the ChainComp with mul-
tiple operators (the chain-comparison idiom), and the For statement
with multiple targets (the for-multi-targets idiom). For example,
the assignment statement of Python allows multiple variables to be
assigned simultaneously. A useful scenario for assign-multi-targets
is to swap variables without creating temporary variables.
(4) Python syntax supports more comprehensive data type.
Python and Java have the same syntactic construct, but Python
supports objects of more data types. This includes the truth-value-
testing idiom [26, 44]. In Python, any object (e.g., string, numeric
type and sequences) can be directly tested for truth value. For
example, we can directly check if a variable “a” of list data type is
empty with “if not a” instead of “if a == []”.

5

Table 1 lists the nine pythonic idioms we identify and the code
examples of idiomatic code and corresponding non-idiomatic code.
For each identified pythonic idiom, we read Python language speci-
fication to confirm its validity. We also search online materials with
the idiom names to support our analysis. Searching with specific
idiom names can find relevant supporting documentation. However,
searching “python idiom” generally return many materials which
do not cover all nine types of pythonic idioms.

3.2 Detecting Anti-idiom Code Smells
For each pythonic idiom, we define syntactic patterns for imple-
menting the pythonic idioms in a non-idiomatic way. Contrasting
Python and Java syntax provides the basis for defining such patterns.
In a sense, we try to implement a pythonic idiom in a Java-style
Python code pattern. The defined syntactic patterns can detect
anti-idiom code smells that can be refactored with pythonic idioms.
Table 5 lists our detection rules and illustrative examples.

List/Set/Dict Comprehension. The list-comprehension idiom
3.2.1
is used for the list initialization (2nd row in Table 5). The rule first
finds an empty assignment statement 𝑠𝑡𝑚𝑡1 (e.g., “dblist = []”). Then,
it finds a for statement 𝑠𝑡𝑚𝑡𝑛 which iteratively adds elements to
the target ( “dblist”) of 𝑠𝑡𝑚𝑡1. There cannot be other statements
using the target “dblist” of 𝑠𝑡𝑚𝑡1 between 𝑠𝑡𝑚𝑡1 and 𝑠𝑡𝑚𝑡𝑛 to lest
the “dblist” is modified (i.e., 𝑖𝑠𝑁𝑜𝑡𝑈 𝑠𝑒 (𝑠𝑡𝑚𝑡1.𝑡𝑎𝑟𝑔𝑒𝑡, 𝑠𝑡𝑚𝑡1, 𝑠𝑡𝑚𝑡𝑛)).
Since the 𝑠𝑡𝑚𝑡𝑛 corresponds to the comp node of the ListComp con-
struct which only supports for clause and if clause, the rule checks
whether 𝑠𝑡𝑚𝑡𝑛 satisfies the MatchCompre condition, i.e., if the 𝑠𝑡𝑚𝑡𝑛
corresponds to the syntax grammar of Comprehension. The detec-
tion rule for the non-idiomatic code of the set-comprehension and
the dict-comprehension idiom are the same.

3.2.2 Chain Comparison. The chain-comparison “a 𝑜𝑝1 b 𝑜𝑝2 c ... y
𝑜𝑝𝑛 z” is equivalent to “a 𝑜𝑝1 b and b 𝑜𝑝2 c and ... y 𝑜𝑝𝑛 z” [19]. The
non-idiomatic code of the chain comparison must be a 𝐵𝑜𝑜𝑙𝑂𝑝-and
expression which contains at least two compare nodes. Moreover,
the two compare nodes have the same operands. For example, for
the expression “cp >= 178208 and cp <= 183983” (3rd row in Table 5),
the cp is the common operand of the two compare nodes, and the
expression can be refactored as “183983 >= cp >= 178208”.

3.2.3 Truth Value Test. The truth-value-test idiom is used for check-
ing the “truthiness” of an object. Generally, when developers want
to compare whether an object is equal or is not equal to a value,
many programming languages use “==” or “!=” operator to achieve
the functionality. In Python, any object can be directly tested for
truth value, so developers do not need to use “==” or “!=” operator
to test truth value. Python documentation specify the built-in ob-
jects in 𝐸𝑚𝑝𝑡𝑦𝑆𝑒𝑡 (e.g., [] and set()) are considered as false value.
Therefore, if a statement directly compares an object to the element
of 𝐸𝑚𝑝𝑡𝑦𝑆𝑒𝑡, it will be regarded as a non-idiomatic code of the truth
value test. However, not all compare nodes are refactorable with
truth value test. For example, “a!=[]” in “return a!=[]” cannot be
refactored because “return a” changes the code semantic. Accord-
ing to Python syntax, the non-idiomatic code of truth value test
corresponds to a test-type node. Therefore, our rule checks whether
a compare node is the child of a test-type node, for example, the
“runs([]) == []” is the child of an if-node “if runs([]) == []” (4th row

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Zejun Zhang, Zhenchang Xing, Xin Xia, Xiwei Xu, and Liming Zhu

Idiom

Detection Rules and Examples of Code Pairs

Refactoring Steps

Table 5: Examples of detection and refactoring of anti-idiom code smells

6

Making Python Code Idiomatic by Automatic Refactoring Non-Idiomatic Python Code with Pythonic Idioms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

in Table 5). Since the if-node is a test-type node, the compare node
“runs([]) == []” is refactorable to a truth-value-test.

3.2.4 Loop Else. The else clause of the loop statement is executed
after the iterator is exhausted, unless the loop was ended prema-
turely due to a break statement. The non-idiomatic way of imple-
menting a loop-else generally has an assignment statement 𝑠𝑡𝑚𝑡1 to
flag current state, a for statement 𝑠𝑡𝑚𝑡𝑛 which contains a statement
𝑠 to change the current state and a break statement 𝑠𝑡𝑚𝑡 𝑗 to end
the loop, and an if statement 𝑠𝑡𝑚𝑡𝑛+1 after the for statement 𝑠𝑡𝑚𝑡𝑛
to check the current state to execute different operations. There are
four circumstances: 𝑐1 and 𝑐2 complement each other, and 𝑐3 and
𝑐4 complement each other.

The 𝑐1 satisfies the following semantic conditions: the semantic
of the assignment statement 𝑠𝑡𝑚𝑡1 is the same as the semantic
of the test node of if statement 𝑠𝑡𝑚𝑡𝑛+1.𝑡𝑒𝑠𝑡, and the semantic of
assignment statement 𝑠 is different from the semantic of 𝑠𝑡𝑚𝑡1
where 𝑠 and the break statement 𝑠𝑡𝑚𝑡 𝑗 are at the same scope. These
semantic conditions are designed because the non-idiomatic code
of loop-else implies two execution paths (5th row in Table 5): 𝑠𝑡𝑚𝑡1
↛ 𝑠 and 𝑠𝑡𝑚𝑡1 → 𝑠𝑡𝑚𝑡𝑛+1 or 𝑠𝑡𝑚𝑡1 → 𝑠 and 𝑠𝑡𝑚𝑡 𝑗 ↛ 𝑠𝑡𝑚𝑡𝑛+1.

The 𝑐2 satisfies the following semantic conditions: the semantic
of the assignment statement 𝑠𝑡𝑚𝑡1 is the opposite of the semantic
of the test node of the if-statement 𝑠𝑡𝑚𝑡𝑛+1.𝑡𝑒𝑠𝑡, the if-statement
𝑠𝑡𝑚𝑡𝑛+1 has an else clause, and the semantic of the assignment
statement 𝑠 is the opposite of the semantic of 𝑠𝑡𝑚𝑡1 where 𝑠 and
the break statement 𝑠𝑡𝑚𝑡 𝑗 are at the same scope. The 𝑐2 condition
is a complement to the 𝑐1 condition. If 𝑠𝑡𝑚𝑡𝑛+1 has an else clause
and 𝑠𝑡𝑚𝑡𝑛+1.𝑡𝑒𝑠𝑡 has the opposite semantic with 𝑠𝑡𝑚𝑡1, it indicates
that the else clause has the same semantic as 𝑠𝑡𝑚𝑡1. Therefore, the
code satisfying the 𝑐2 condition is also refactorable to a loop-else.
For example (5th row in Table 5), if we change 𝑠𝑡𝑚𝑡𝑛+1.𝑡𝑒𝑠𝑡 “good_
partition” into “not good_partition” and add an else clause to the if
statement, the code satisfies the 𝑐2 condition.

The 𝑐3 satisfies the following semantic conditions: the semantic
of the assignment statement 𝑠𝑡𝑚𝑡1 is the same as the semantic of
test node of the if-statement 𝑠𝑡𝑚𝑡𝑛+1.𝑡𝑒𝑠𝑡, and the semantic of the if-
statement 𝑠 in the body of the loop statement 𝑠𝑡𝑚𝑡𝑛 is different from
the semantic of 𝑠𝑡𝑚𝑡1, and the body of the if-statement 𝑠 contains
the break statement 𝑠𝑡𝑚𝑡 𝑗 . The 𝑐3 is a variant of 𝑐1 and 𝑐2. The 𝑐1
and 𝑐2 requires an assignment 𝑠 to change the current state, but 𝑐3
uses an if statement 𝑠 to detect the change of the current state and
break the loop, such as “if not good_partition: break”.

The 𝑐4 satisfies the following semantic conditions: the semantic
of the the assignment 𝑠𝑡𝑚𝑡1 is the opposite of the semantic of test
node of the if-statement 𝑠𝑡𝑚𝑡𝑛+1.𝑡𝑒𝑠𝑡, the if-statement 𝑠𝑡𝑚𝑡𝑛+1 has
an else clause, and the semantic of the test node of if statement
𝑠.𝑡𝑒𝑠𝑡 in the body of the loop-statement 𝑠𝑡𝑚𝑡𝑛 is the opposite of the
semantic of 𝑠𝑡𝑚𝑡1 and the body of the if-statement 𝑠 contains the
break statement 𝑠𝑡𝑚𝑡 𝑗 . The 𝑐4 complements 𝑐3, in the same vein as
𝑐2 complements 𝑐1.

3.2.5 Assign Multiple Targets. The assign-multiple-targets idiom
is to assign multiple values at the same time in one assignment
statement. For several consecutive assignment statements, if an
assignment statement 𝑠𝑡𝑚𝑡𝑘 does not use the result of an assign-
ment statement 𝑠𝑡𝑚𝑡𝑖 before it, these assignment statements are
refactorable to assign-multi-targets. When an assignment statement

7

𝑠𝑡𝑚𝑡𝑘 uses the result of the an assignment statement 𝑠𝑡𝑚𝑡𝑖 before
𝑠𝑡𝑚𝑡𝑘 , the code usually is to swap variables by creating temporary
variables. For such non-idiomatic code, it requires that the target
of a statement 𝑠𝑡𝑚𝑡 𝑗 between the 𝑠𝑡𝑚𝑡𝑖 and the 𝑠𝑡𝑚𝑡𝑘 is the same
as the value of 𝑠𝑡𝑚𝑡𝑖 . For example (6th row in Table 5), 𝑠𝑡𝑚𝑡𝑘 “d[e]
= f” uses the target “f” of 𝑠𝑡𝑚𝑡𝑖 “f = d[0]”, and the target “d[0]” of
the 𝑠𝑡𝑚𝑡 𝑗 “d[0] = d[e]” is the same as the value “d[0]” of the 𝑠𝑡𝑚𝑡𝑖
“f = d[0]”. This sequence of assignments via a temporary variable
can also be refactored with the assign-multiple-targets idiom.

Star in Function Calls. The star-in-function-call idiom is usu-
3.2.6
ally used to unpack an iterable to the positional arguments in a
function call [16]. The non-idiomatic way of passing a sequence of
arguments is that the subscript sequence of multiple consecutive
parameters of a function call is an arithmetic sequence of the same
variable. For example, “1, 2, 3” is an arithmetic sequence where the
common difference is 1 for accessing the first, second and third
element of “sys.argv” (second-to-last row in Table 5). It can be
refactored into “*sys.argv[1:4:1]”.

For Multiple Targets. The non-idiomatic code of the for-
3.2.7
multiple-targets idiom only contains one variable as the target
of for statement 𝑝. The body of 𝑝 uses the subscript expression to
get elements of the variable. For example (the last row of Table 5),
the code uses “interval[0]” and “interval[1]” to get the elements
of the variable “interval” inside the body of for loop. Instead, the
elements of “interval” can be accessed using a for-multiple-targets
idiom.

3.3 Refactoring with Pythonic Idioms
According to [37], a refactoring is a series of small behavior pre-
serving transformations. Based on this principle, we analyze the
AST transformations required to transform a piece of anti-idiom
code into an idiomatic code. We identify four atomic AST-rewriting
operations across all idioms, and then compose these atomic opera-
tions into the refactoring steps for each pythonic idiom. The four
atomic operations are as follows:

(1) Copy(s, i) copies the node 𝑠 of non-idiomatic code to the po-
sition 𝑖 of a node of idiomatic code. If the node at the position 𝑖 is
empty, we copy 𝑠 into the position 𝑖. Otherwise, we insert 𝑠 into the
position 𝑖. Since a refactoring does not change the code semantics,
many parts of non-idiomatic code can be copied to the resulting
idiomatic code. For example, for the list-comprehension idiom (2nd
row in Table 5), both the target node item and the iter node cmplist
of non-idiomatic code are copied to the corresponding target and
iter position of the comprehension node respectively. For another
example, for the chain-comparison idiom (3rd row in Table 5) we
copy operands of compare node of non-idiomatic code into the
position of operands of a new compare node.
(2) Create(s, *info) builds the node of type 𝑠 with information
∗𝑖𝑛𝑓 𝑜 where * represents any amount of information. To refactor
non-idiomatic code into pythonic idioms, it is sometimes necessary
to create some new AST nodes or elements which do not have the
corresponding parts in the non-idiomatic code. For example, for
the truth-value-test idiom (4th row in Table 5), we need to create a
“Not” node. For another example, for the star-in-function-call idiom

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Zejun Zhang, Zhenchang Xing, Xin Xia, Xiwei Xu, and Liming Zhu

(second-to-last row in Table 5), we need to create a Starred node
with subscript information from the non-idiomatic code.
(3) Remove(s) removes the node 𝑠 from the AST of non-idiomatic
code which is no longer needed in idiomatic code. Generally, refac-
toring non-idiomatic code into idiomatic code will reduce the lines
or tokens of code. Therefore, it is natural to remove those no-longer-
used nodes. For example, for the loop-else idiom (5th row in Table 5),
we need to remove the initial flag assignment “good_partition =
True” and the flag-update statement “good_partition = False” which
are no longer needed when the loop-else idiom is used. For another
example, for the assign-multi-targets idiom (6th row in Table 5),
we remove assign statements from 𝑠𝑡𝑚𝑡2 to 𝑠𝑡𝑚𝑡𝑛.
(4) Replace(s, t) replaces the node 𝑠 of non-idiomatic with the node
𝑡 obtained through code transformation. For example, for the chain-
comparison idiom (3rd row in Table 5), we replace the original
expression “cp >= 178208 and cp <= 183983” with the resulting
chain-comparison “183983 >= cp >= 178208”. For another example,
for the for-multi-targets idiom (the last row in Table 5), we replace
“interval[0], interval[1]” with “interval_0, interval_1” respectively.

The 3rd column of Table 5 shows the refactoring steps to com-
plete each pythonic idiom refactoring. The green line numbers
shows the steps that are performed to refactor the examples of non-
idiomatic code on the left into the idiomatic code on the right in the
2nd column of Table 5. For example, to refactor the non-idiomatic
code example into a list comprehension code (2nd row in Table 5),
we first create a ListComp node 𝑐𝑜𝑚𝑝 and then traverse the for
statement 𝑠𝑡𝑚𝑡𝑛 to copy its children to the 𝑐𝑜𝑚𝑝 node (line 1-2),
e.g., copy item._avatar to the position of 𝑠𝑡𝑚𝑡𝑛.𝑒𝑙𝑡 (i.e., elements
to add to the list). Since 𝑠𝑡𝑚𝑡𝑛 and 𝑠𝑡𝑚𝑡1 are at the same scope
(line 6), we directly replace 𝑠𝑡𝑚𝑡1.𝑣𝑎𝑙𝑢𝑒 with 𝑐𝑜𝑚𝑝 in and then re-
move 𝑠𝑡𝑚𝑡𝑛 (line 7-8). Finally, the new 𝑠𝑡𝑚𝑡1 is the idiomatic code
obtained through the refactoring. When 𝑠𝑡𝑚𝑡1 and 𝑠𝑡𝑚𝑡𝑛 are at
different scope (line 3), we do not perform the Remove operation
for the 𝑠𝑡𝑚𝑡1 because 𝑠𝑡𝑚𝑡𝑛 may not be executed after executing
𝑠𝑡𝑚𝑡1, so we only replace 𝑠𝑡𝑚𝑡𝑛 with 𝑠𝑡𝑚𝑡1 and then update the
value of 𝑠𝑡𝑚𝑡𝑛 (line 4-5).

4 EVALUATION
This section reports the evaluation of our approach. We focus on
two aspects: the correctness and usefulness of refactoring anti-
idiom code smells with pythonic idioms:

RQ1: How accurate is our approach when refactoring real-world
anti-idiom Python code with pythonic idioms?
RQ2: Do code refactorings performed by our approach have prac-
tical value for real-world projects?

4.1 RQ1: Correctness of Refactorings
4.1.1 Motivation. Refactorings involve complex logic for detecting
anti-idiom code smells and applying code transformation. We would
like to confirm the design and implementation of our approach is
robust and correct on real-world Python code.

4.1.2 Method. As described in Section 2.2.1, we collect 7,638 repos-
itories from GitHub which can be successfully parsed using Python
3, and collect 506,765 Python source files from these repositories.
We apply our refactoring tool to these Python source files to detect

8

nine types of anti-idiom code statements and refactor these state-
ments with pythonic idioms. We use both testing and code review
to verify the correctness of refactorings.

Testing based verification. To determine the test cases that
cover the detected non-idiomatic code fragments, we first collect the
fully qualified names of all methods called by a test method using
the DLocator tool [62]. If the method that contains a non-idiomatic
code fragment belongs to the list of the methods called by the test
method, we consider this test method as a test case for the non-
idiomatic code fragment. Note that one test case may test one or
more methods, and one method may undergo one or more different
types of refactorings. Then, to execute the test cases successfully,
we install the packages that the project depends on by reading
its requirements.txt. Note that not all test cases can be executed
successfully because of several problems, such as requiring other
non-python packages or to manually configure some parameters.
We filter out such fail-to-execute test cases.

In the work, we use Pytest [42], a popular Python unit testing
frame which also supports the Python’s default unittest tool [27].
We run the test cases on the original methods with non-idiomatic
code fragments to ensure they pass successfully. Then we run the
test cases again on the refactored methods. If the refactored meth-
ods pass the test cases, we consider the detection of anti-idiom,
non-idiomatic code fragments and the corresponding code refactor-
ings are correct. For the refactorings that fail the test cases, the two
authors independently analyze the failure causes. Two authors have
more than three years of Python development experience. They ex-
amine the detected non-idiomatic code fragments and the idiomatic
code obtained by the refactorings, and determine if the failures are
caused by non-idiomatic code smell detection or pythonic idiom
transformation. A detection failure means a detected non-idiomatic
code fragment is not refactorable, e.g, it cannot be safely refactored
into semantic-equivalent idiomatic code. If the failure is caused
by non-idiomatic code detection, we do not double count it as the
failure of pythonic idiom transformation. The two authors discuss
to resolve their disagreement and reach the consensus. Finally,
we compute the accuracy of anti-idiom code smell detection and
idiomatic code refactoring for each pythonic idiom.

Code review based verification. We randomly sample 100
pairs of non-idiomatic code fragments and the corresponding id-
iomatic code fragments for each pythonic idiom. Then the two
authors independently review these code pairs, and determine if
the non-idiomatic code fragments are detected correctly and if the
idiomatic code fragments are refactored correctly. They discuss to
resolve their disagreement and reach the consensus. Based on their
code review results, we compute the accuracy of anti-idiom code
smell detection and idiomatic code refactoring for each pythonic
idiom.

4.1.3 Result. Table 6 presents the analysis results. #Ref and #TCs of
the Testing column are the number of refactorings with successfully-
executed test cases and the corresponding number of test cases.
#Ref of the Code Review column is the number of refactorings we
reviewed. d-acc and r-acc are the accuracy of non-idiomatic code
smell detection and idiomatic code transformation respectively. In
total, we successfully test 3,215 refactorings from 479 repositories
and reviewed 900 refactorings from 672 repositories. Overall, our

Making Python Code Idiomatic by Automatic Refactoring Non-Idiomatic Python Code with Pythonic Idioms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Table 6: Accuracy of anti-idiom code smell detection (d-acc)
and idiomatic code transformation (r-acc)

Idiom

List-Compre
Set-Compre
Dict-Compre
Chain-Compa
Truth-Test
Loop-Else
Assign-Multi-Tar
Star-in-Func-Call
For-Multi-Tar
Total

#Refs
132
21
102
309
641
37
1802
86
85
3215

Testing

#TCs
391
39
297
837
1680
98
4565
201
314
7216

d-acc
1
1
1
1
0.986
1
0.999
0.977
1
0.995

r-acc
1
1
1
1
1
1
1
1
1
1

Code Review
d-acc
1
1
1
1
1
1
1
0.98
1
0.998

#Refs
100
100
100
100
100
100
100
100
100
900

r-acc
1
1
1
0.99
1
1
1
1
1
0.998

approach is very robust on real-world code. It achieves 100% ac-
curacy of detection and refactoring for five pythonic idioms, i.e.,
list-comprehension, set-comprehension, dict-comprehension, loop-
else and for-multi-targets. It achieves 100% detection accuracy for
chain-comparison, and 100% refactoring accuracy for truth-value-
test, assign-multi-targets and star-in-func-call.

Detection failure analysis. Our verification identifies 15 de-
tected non-idiomatic code fragments which are not refactorable,
including 9 for truth-value-test, 2 for assign-multi-targets and 4 for
star-in-func-call. For example, for the truth-value-test “if xpath_
results == []”, if “xpath_results” is an empty string, the if-condition
is false. However, the idiom “if not xpath_results” will be true if
“xpath_results” is an empty string. Therefore, “if xpath_results ==
[]” cannot be refactored into “if not xpath_results”. Other non-
refactorable truth-value-test cases suffer from the same problem.
The two non-refactorable assign-multi-targets failures are caused
by the limitation of the Python static parsing. For example, for the
two assignment statements, 𝑠𝑡𝑚𝑡1: lib=... and 𝑠𝑡𝑚𝑡2: tmpl=‘{lib}’.
“lib” of 𝑠𝑡𝑚𝑡2 is a variable because Python uses curly brackets to
insert variables in string. 𝑠𝑡𝑚𝑡2 uses the target “lib” of 𝑠𝑡𝑚𝑡1, so
the two statements cannot be refactored into “lib,tmpl=...,‘{ lib}”’
because it will make tmpl use the old value of lib. Since the parser
parses ‘{lib}’ into a string constant and does not parse the “lib” in-
side the brackets into a variable, we loss the information of data
dependency and mistakenly identify the statements as refactorable.
For the star-in-func-call idiom, both testing and code review find
two non-refactorable non-idiomatic code fragments identified by
our detection tool. The reason is that our tool does not consider the
semantic of Python slice. For example, for the code “self.add_circle_
arc(p[-1], p[0], p[1])”, “-1, 0, 1” is an arithmetic sequence. However,
Python list grows linearly and is not cyclic, as such slicing does not
wrap (from end back to start going forward) as we expect.

Code transformation failure analysis. Our tool makes only
1 code transformation error for chain-comparison. For the code
“type is not None and self._meta_types and type not in self._meta_
types”, it has three comparison operations and “type” is the common
operand of the first and the third operation. Therefore, we refactor
it into “None is not type not in self._meta_types and self._ meta_
typestype”. However, if “self._meta_types” is None, the refactoring
will report a TypeError at runtime because None is not iterable. As
our tool does not analyze the priority of comparison operations
and adjust their order when refactoring the code, the resulting code
encounters the runtime error.

9

Table 7: Results of our refactoring pull requests

Idiom Category
List Comprehension
Set Comprehension
Dict Comprehension
Chain Comparison
Truth Value Test
Loop Else
Assign Multi Targets
Star in Func Call
For Multi Targets
Total

Accepted
6
5
5
4
3
5
3
1
2
34

Rejected Merged

3
3
0
4
3
1
2
6
1
23

5
4
5
3
3
4
1
1
2
28

#Repo
10
10
10
10
10
10
10
10
10
84

Our refactoring tool is robust and correct on real-world Python code.
The limitation of Python static parsing and the complex program
logic may result in a few rare detection and refactoring errors.

4.2 RQ2: Usefulness of Refactorings
4.2.1 Motivation. Our tool is the first refactoring tool for pythonic
idioms. We would like to know how well Python developers ac-
cept the refactorings our tool makes and what opinions they have
towards pythonic idiom refactoring in practice.

4.2.2 Method. We randomly sample 10 refactorings (including the
original non-idiomatic code fragments and the resulting idiomatic
code after refactoring) for each type of pythonic idiom. The sampled
refactorings come from 84 repositories. We fork the repository
corresponding to the non-idiomatic code fragment and commit a
pull request with the resulting idiomatic code. Readers can find the
list of the 90 pull requests in our replication package. We collect the
developers’ responses to our pull requests, and count how many
pull requests have been accepted or rejected by developers. Among
the accepted pull requests, we further count how many pull requests
have been merged into the repositories.

4.2.3 Result. Table 7 presents our experiment results. Among 90
pull requests, we received 57 responses, including 34 accepted and
23 rejected. 28 of the accepted pull requests have been merged into
the repositories. The six pull requests that are not merged as they are
not yet tested. The 63% (57/90) response rate indicates that Python
developers pay attention to the pythonic idiom refactorings. The
60% acceptance rate and the 50% merge rate among the responses
provide the initial evidence of our refactoring tool’s practicality
and usefulness.

Among the accepted pull requests, many developers praise the
refactoring pull requests we made to their repositories. For example,
two developers praise the dict-comprehension refactoring (“{ name:
mod for name, mod in module.named_modules() if isinstance(mod,
_ConvNd)}”) “Thanks for the contribution, looks great!”. Many de-
velopers confirm that the suggested refactorings are more pythonic,
such as “Definitely more pythonic!” on a list-comprehension refac-
toring. Some developers express the interests in refactoring other
places with the same pythonic idiom, such as “I will change the
other place to a more pythonic style ...” inspired by our pull request
for an assign-multiple-targets refactoring.

We analyze the rejected pull requests and summarize four main
concerns developers have about pythonic idiom refactorings: read-
ability, performance, systematic refactoring, and inertia.

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Zejun Zhang, Zhenchang Xing, Xin Xia, Xiwei Xu, and Liming Zhu

Readability. 13 out of 23 reject responses are concerned that
the pythonic idioms make the code less readable. For example, the
developer comments on a suggested star-in-func-call refactoring (
“*clip.size([2:4:1])”) : “While your change is indeed feasible, I believe
the original style is more readable”. Even with the readability con-
cern, some developers express that they learn something from the
suggested refactorings. For example, the developer comments on
the chain-comparison refactoring (“sessions is None is metrics”):
“... Interesting, ..., I learned something today though, thanks.” As
another example, the developer worries that refactoring may loss
specific information for the truth-value-test. For example, a devel-
oper replied “I feel like asserting it to empty dict is more explicit
and readable” if “assert deepdiff.DeepDiff(...) == {}” is refactored
into “assert not deepdiff.DeepDiff(...)”.

Performance. 3 reject responses are concerned about the perfor-
mance or memory usage. For example, for the list-comprehension
refactoring, the developers reject the pull request because they are
not sure that the performance improvement would be significant in
their project. For the star-in-func-call refactoring which refactors
“ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6]” into “*ss[0:7:1]”, the de-
veloper believes the refactoring can cause memory fragmentation.
Systematic refactoring. 3 reject responses indicates that de-
velopers do not want to refactor the project in an ad-hoc way. Two
responses are discouraged to refactor only one code fragment of
the project. For example, although the developers reject our pull
request for a set-comprehension refactoring, they propose that such
refactorings should be applied to the whole project rather than by
a single pull request to just one place. In another reject response,
the developer replies that “Waf is just a tool for us. We don’t need
style patches for it.” for a list-comprehension refactoring. In fact, we
believe these responses confirm the need for systematic pythonic
idiom refactoring tool like ours. Our tool can scan and refactor the
whole project and dependent packages. It was just we submitted
only some randomly sampled refactorings to the projects.

Inertia. 4 rejects are because the developers prefer the original
code. For example, a developer replies “Thanks for the suggestion,
I prefer the existing code” for a star-in-func-call refactoring. And
some developers would like to accept pull requests to fix bugs
instead of code refactoring, e.g., the developer replies to a for-
multiple-targets refactoring: “I think it’s better to leave the RUBI
code alone for now unless there is work to fix it.”.

Our pythonic idiom refactorings have been well received by the de-
velopers. The developers also raise concerns about readability and
performance of pythonic idioms which deserve further study.

5 RELATED WORK
5.1 Pythonic Idioms
How to write pythonic code has been a popular topic [29, 41, 44,
46, 58]. Several studies identify some Python idioms to help devel-
opers write more idiomatic code (commonly referred to as more
pythonic [46, 61]). Alexandru et al. [29] identify 19 pythonic id-
ioms (list-comprehension and dict-comprehension overlap with
our work) from several books. Merchante et al. [46] identify the
usage of pythonic idioms in GitHub. Kula et al. [55] visualize the
usage of the with-open idiom over time, and find that projects are

10

accustomed to using the with-open idiom instead of non-idiomatic
counterpart. Phan-udom et al. [51] develop a tool to recommend
pythonic code examples by searching similar code examples from
113 code snippets of three repositories. Different from these related
works, our work identifies unique pythonic idioms from the lan-
guage syntax and find 4 idioms (star-in-func-call, for-multi-targets,
assign-multi-targets, loop-else) that have not been identified before.
Furthermore, we not only identify pythonic idioms but also develop
an automatic tool to refactor anti-idiom code into idiomatic code.

5.2 Code refactoring
Martin Fowler proposes code refactoring [37] about 30 years ago. An
active line of research is to recover refactorings made in the code [33,
34, 40, 43, 48, 52, 56, 59, 63, 64]. Prete et al. [43, 52] detect the
largest number of refactoring types based on the Fowler’s catalog.
Tsantalis et. al. [59] identify 15 Java refactoring types by statement
matching algorithm and refactoring detection rules. Dilhara et.
al. [35] identify 18 Python refactoring kinds (e.g., rename, move,
pull up methods), which do not overlap with our refactoring type.
Another active line of research is to refactor code [1, 32, 38, 45, 47,
49, 53, 60]. Ouni et al. [49] propose a multi-objective search-based
approach for finding the optimal sequence of refactorings. Köhler et
al. [45] develop a tool to automatically convert asynchronous code
to reactive programming. Pylint [1] is a static code analysis tool,
which could give refactoring suggestions for chain-comparison and
truth-value-test, but it does not support automatic refactorings. To
the best of our knowledge, our tool is the first automatic refactoring
tool which covers 9 types of pythonic idioms.

6 DISCUSSION
6.1 Pythonic Coding Practices
Refactoring is a widely adopted practice to improve code quality.
A wide range of refactorings have been proposed to address code
smells such as code clones, feature envy, shotgun surgery. Our
work introduces a new type of code smell, i.e., non-idiomatic code
that can be refactored with pythonic idioms. Our empirical study
on GitHub repositories and Stack Overflow questions calls for the
tool support for assisting developers in using pythonic idioms con-
sistently. Our refactoring tool is the first tool of this kind. The
evaluation on a large number of Python projects provides posi-
tive and encouraging feedback on the prototype. Some developer
feedback raises concerns about the readability and performance of
pythonic idioms. This calls for the careful validation of the concise-
ness and performance of pythonic idioms. However, existing online
materials are anecdotal and mostly based on personal programming
experience. Our work produces a large dataset of non-idiomatic
versus idiomatic code from real-world projects, which serves as an
excellent testbed to empirically investigate the general claims and
concerns about pythonic idioms.

6.2 Threats to Validity
Threats to internal validity relate to two aspects in our work:
(1) the errors in the implementation of code refactoring tool and
(2) personal bias in evaluating accuracy of code refactoring. For
the aspect (1), we have double-checked the code and verified the
accuracy of our tool implementation by manually examining a

Making Python Code Idiomatic by Automatic Refactoring Non-Idiomatic Python Code with Pythonic Idioms

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

large number of refactoring instances outputted by each step of our
tool. As for the aspect (2), two authors with more than three years
of Java and Python programming experience check the accuracy
of refactoring instances independently. Furthermore, we collect a
large number of real test cases to test the refactored code. Threats
to external validity relate to the generalizability of experiment
results. To alleviate this threat, we built a large-scale dataset of 7,638
repositories and 506,765 Python files. To explore whether our code
refactoring has practical value for developers, we submitted 90 pull
requests to project members to review. The number of pull requests
is larger than existing user studies in previous works [39, 50, 65].
We release our tool and data in Zenodo3 for public evaluation.

7 CONCLUSION AND FUTURE WORK
This paper designs and implements the first automatic refactoring
tool for nine types of pythonic idioms. Our tool is motivated by
the empirical observation of the challenges in writing pythonic
code from the Stack Overflow discussions and of the wide presence
of non-idiomatic code in thousands of real-world Python projects.
Rather than relying on idiom mining, literature review or personal
programming experience, our approach identifies pythonic idioms
and define non-idiomatic syntactic patterns and idiomatic code
transformation steps through the systematic analysis of Python
abstract syntax grammar. Our tool is robust and correct in detect-
ing anti-idiom code smells and refactor these smells in real-world
Python projects. The refactorings made by our tool have been well
received and praised by the Python developers. In the future, we
will integrate our refactoring tool into the open-source linting tool
(e.g., Pylint). We will systematically investigate the readability and
performance concerns about pythonic idioms based on the large-
scale refactoring dataset our tool produces.

REFERENCES
[1] 2021. Pylint. https://pylint.org/
[2] 2022. Assign with Multiple Targets on loginradius. https://www.loginradius.com/

blog/async/speed-up-python-code/

[3] 2022. Assign with Multiple Targets on Medium. https://medium.com/geekculture/
3-easy-ways-to-instantly-make-your-python-program-faster-e599e920ea28
Assign with Multiple Targets on StackOverflow.
//stackoverflow.com/questions/22278695/python-multiple-assignment-vs-
individual-assignment-speed

[4] 2022.

https:

[5] 2022.

Chain Comparison on StackOverflow.

https://stackoverflow.com/

questions/48375753/why-are-chained-operator-expressions-slower-than-
their-expanded-equivalent

[6] 2022. Chain Comparison on Wiki. https://wiki.python.org/moin/PythonSpeed
[7] 2022. Dict Comprehension. https://stackoverflow.com/questions/52542742/why-
is-this-loop-faster-than-a-dictionary-comprehension-for-creating-a-dictionar
[8] 2022. For Multiple Targets on StackOverflow. https://stackoverflow.com/questions/

13024416/how-come-unpacking-is-faster-than-accessing-by-index

[9] 2022. For Multiple Targets on StackOverflow. https://stackoverflow.com/questions/

23039485/for-loop-item-unpacking

[10] 2022. List comprehension is 10X faster than loops. https://innovationyourself.

com/list-comprehension-in-python/

[11] 2022. List Comprehension on StackOverflow. https://stackoverflow.com/questions/
30245397/why-is-a-list-comprehension-so-much-faster-than-appending-to-a-
list

[12] 2022.

Loop Else.

https://stackoverflow.com/questions/13069402/efficient-

implementation-for-python-for-else-loop-in-java

[13] 2022. Medium. https://medium.com/
[14] 2022. PEP 202-List comprehension. https://peps.python.org/pep-0202/
[15] 2022. PEP 274-Dict comprehension. https://peps.python.org/pep-0274/
[16] 2022. PEP 448-Additional Unpacking Generalizations. https://peps.python.org/pep-

0202/

3https://zenodo.org/record/6367738#.YjRzLxBBzdo
[17] 2022. Programming Idioms. https://programming-idioms.org/

11

[18] 2022. Python Abstract Grammar. https://docs.python.org/3/library/ast.html
[19] 2022. Python Chain Comparison. https://docs.python.org/3/reference/expressions.

html#comparisons

[20] 2022. Set Comprehension.

https://appdividend.com/2020/12/03/python-set-

comprehension/

[21] 2022. StackOverflow. https://stackoverflow.com/
[22] 2022. Star in Call on StackOverflow. https://stackoverflow.com/questions/2921847/

what-does-the-star-and-doublestar-operator-mean-in-a-function-call

[23] 2022. timeit. https://docs.python.org/3/library/timeit.html
[24] 2022. Truth Value Test. https://stackoverflow.com/questions/39983695/what-is-

truthy-and-falsy-how-is-it-different-from-true-and-false

[25] 2022. Truth Value Test. https://stackoverflow.com/questions/53513/how-do-i-

check-if-a-list-is-empty

[26] 2022. Truth Value Test on Python Documentation. https://docs.python.org/3/

library/stdtypes.html#truth-value-testing

[27] 2022. Unit testing framework. https://docs.python.org/3/library/unittest.html
[28] 2022. Writing Fast Python. https://switowski.com/blog/checking-for-true-or-

false

[29] Carol V Alexandru, José J Merchante, Sebastiano Panichella, Sebastian Proksch,
Harald C Gall, and Gregorio Robles. 2018. On the usage of pythonic idioms. In
Proceedings of the 2018 ACM SIGPLAN International Symposium on New Ideas,
New Paradigms, and Reflections on Programming and Software. 1–11.

[30] Miltiadis Allamanis, Earl T Barr, Christian Bird, Premkumar Devanbu, Mark Mar-
ron, and Charles Sutton. 2018. Mining semantic loop idioms. IEEE Transactions
on Software Engineering 44, 7 (2018), 651–668.

[31] Miltiadis Allamanis and Charles Sutton. 2014. Mining idioms from source code.
In Proceedings of the 22nd acm sigsoft international symposium on foundations of
software engineering. 472–483.

[32] Cristina David, Pascal Kesseli, and Daniel Kroening. 2017. Kayak: Safe semantic

refactoring to java streams. arXiv preprint arXiv:1712.07388 (2017).

[33] Serge Demeyer, Stéphane Ducasse, and Oscar Nierstrasz. 2000. Finding refactor-

ings via change metrics. ACM SIGPLAN Notices 35, 10 (2000), 166–177.

[34] Danny Dig, Can Comertoglu, Darko Marinov, and Ralph Johnson. 2006. Auto-
mated detection of refactorings in evolving components. In European conference
on object-oriented programming. Springer, 404–428.

[35] Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig. 2022. Discov-
ering Repetitive Code Changes in Python ML Systems. In International Conference
on Software Engineering (ICSE’22). To appear.

[36] Aamir Farooq and Vadim Zaytsev. 2021. There is More than One Way to Zen
Your Python. In Proceedings of the 14th ACM SIGPLAN International Conference
on Software Language Engineering. 68–82.

[37] Martin Fowler. 2018. Refactoring: improving the design of existing code. Addison-

Wesley Professional.

[38] Lyle Franklin, Alex Gyori, Jan Lahoda, and Danny Dig. 2013. LAMBDAFICATOR:
from imperative to functional programming through automated refactoring. In
2013 35th international conference on software engineering (ICSE). IEEE, 1287–1290.
[39] Zhipeng Gao, Xin Xia, David Lo, John Grundy, and Thomas Zimmermann. 2021.
Automating the removal of obsolete TODO comments. In Proceedings of the 29th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering. 218–229.

[40] Michael W Godfrey and Lijie Zou. 2005. Using origin analysis to detect merging
and splitting of source code entities. IEEE Transactions on Software Engineering
31, 2 (2005), 166–181.

[41] Raymond Hettinger. 2013. Transforming code into beautiful, idiomatic Python.

https://www.youtube.com/watch?v=OSGv2VnC0go

[42] John Hunt. 2019. PyTest Testing Framework. In Advanced Guide to Python 3

Programming. Springer, 175–186.

[43] Miryung Kim, Matthew Gee, Alex Loh, and Napol Rachatasumrit. 2010. Ref-finder:
a refactoring reconstruction tool based on logic query templates. In Proceedings of
the eighteenth ACM SIGSOFT international symposium on Foundations of software
engineering. 371–372.

[44] Jeff Knupp. 2013. Writing Idiomatic Python 3.3. Jeff Knupp.
[45] Mirko Köhler and Guido Salvaneschi. 2019. Automated refactoring to reactive
programming. In 2019 34th IEEE/ACM International Conference on Automated
Software Engineering (ASE). IEEE, 835–846.

[46] José Javier Merchante and Gregorio Robles. 2017. From Python to Pythonic:
Searching for Python idioms in GitHub. In Proceedings of the Seminar Series on
Advanced Techniques and Tools for Software Evolution. 1–3.

[47] Alessandro Midolo and Emiliano Tramontana. 2021. Refactoring Java Loops to
Streams Automatically. In 2021 4th International Conference on Computer Science
and Software Engineering (CSSE 2021). 135–139.

[48] Stas Negara, Nicholas Chen, Mohsen Vakilian, Ralph E Johnson, and Danny Dig.
2013. A comparative study of manual and automated refactorings. In European
Conference on Object-Oriented Programming. Springer, 552–576.

[49] Ali Ouni, Marouane Kessentini, Houari Sahraoui, Katsuro Inoue, and Kalyanmoy
Deb. 2016. Multi-criteria code refactoring using search-based software engineer-
ing: An industrial case study. ACM Transactions on Software Engineering and
Methodology (TOSEM) 25, 3 (2016), 1–53.

ESEC/FSE 2022, 14 - 18 November, 2022, Singapore

Zejun Zhang, Zhenchang Xing, Xin Xia, Xiwei Xu, and Liming Zhu

[50] Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li. 2020.
Reinforcement learning based curiosity-driven testing of Android applications.
In Proceedings of the 29th ACM SIGSOFT International Symposium on Software
Testing and Analysis. 153–164.

[51] Purit Phan-udom, Naruedon Wattanakul, Tattiya Sakulniwat, Chaiyong
Ragkhitwetsagul, Thanwadee Sunetnanta, Morakot Choetkiertikul, and
Raula Gaikovina Kula. 2020. Teddy: Automatic Recommendation of Pythonic Id-
iom Usage For Pull-Based Software Projects. In 2020 IEEE International Conference
on Software Maintenance and Evolution (ICSME). IEEE, 806–809.

[52] Kyle Prete, Napol Rachatasumrit, Nikita Sudan, and Miryung Kim. 2010. Template-
based reconstruction of complex refactorings. In 2010 IEEE International Confer-
ence on Software Maintenance. IEEE, 1–10.

[53] Cosmin Radoi, Stephen J Fink, Rodric Rabbah, and Manu Sridharan. 2014. Trans-
lating imperative code to MapReduce. In Proceedings of the 2014 ACM International
Conference on Object Oriented Programming Systems Languages & Applications.
909–927.

[54] Kenneth Reitz and Tanya Schlusser. 2016. The Hitchhiker’s guide to Python: best

practices for development. " O’Reilly Media, Inc.".

[55] Tattiya Sakulniwat, Raula Gaikovina Kula, Chaiyong Ragkhitwetsagul, Morakot
Choetkiertikul, Thanwadee Sunetnanta, Dong Wang, Takashi Ishio, and Kenichi
Matsumoto. 2019. Visualizing the Usage of Pythonic Idioms Over Time: A Case
Study of the with open Idiom. In 2019 10th International Workshop on Empirical
Software Engineering in Practice (IWESEP). IEEE, 43–435.

[56] Danilo Silva and Marco Tulio Valente. 2017. Refdiff: detecting refactorings in
version histories. In 2017 IEEE/ACM 14th International Conference on Mining
Software Repositories (MSR). IEEE, 269–279.

[57] Aishwarya Sivaraman, Rui Abreu, Andrew Scott, Tobi Akomolede, and Satish
Chandra. 2021. Mining Idioms in the Wild. arXiv preprint arXiv:2107.06402 (2021).
[58] Brett Slatkin. 2019. Effective python: 90 specific ways to write better python.

Addison-Wesley Professional.

[59] Nikolaos Tsantalis, Matin Mansouri, Laleh Eshkevari, Davood Mazinanian, and
Danny Dig. 2018. Accurate and efficient refactoring detection in commit history.
In 2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE).
IEEE, 483–494.

[60] Nikolaos Tsantalis, Davood Mazinanian, and Shahriar Rostami. 2017. Clone refac-
toring with lambda expressions. In 2017 IEEE/ACM 39th International Conference
on Software Engineering (ICSE). IEEE, 60–70.

[61] Guido Van Rossum et al. 2007. Python Programming language.. In USENIX annual

technical conference, Vol. 41. 1–36.

[62] Jiawei Wang, Li Li, Kui Liu, and Haipeng Cai. 2020. Exploring how deprecated
python library apis are (not) handled. In Proceedings of the 28th acm joint meeting
on european software engineering conference and symposium on the foundations of
software engineering. 233–244.

[63] Peter Weißgerber and Stephan Diehl. 2006. Identifying refactorings from source-
code changes. In 21st IEEE/ACM international conference on automated software
engineering (ASE’06). IEEE, 231–240.

[64] Zhenchang Xing and Eleni Stroulia. 2006. Refactoring detection based on umldiff
change-facts queries. In 2006 13th Working Conference on Reverse Engineering.
IEEE, 263–274.

[65] Neng Zhang, Qiao Huang, Xin Xia, Ying Zou, David Lo, and Zhenchang Xing.
2020. Chatbot4qr: Interactive query refinement for technical question retrieval.
IEEE Transactions on Software Engineering (2020).

12

