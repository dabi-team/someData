MetaFI: Model-driven Fault Simulation Framework

Endri Kaja∗†, Nicolas Gerlin∗†, Luis Rivas∗†, Bora Monideep∗§,
Keerthikumara Devarajegowda∗†, Wolfgang Ecker∗‡
∗Inﬁneon Technologies AG, Germany
†Technische Universit¨at Kaiserslautern, Germany
§Albert-Ludwigs-Universit¨at Freiburg, Germany
‡Technische Universit¨at M¨unchen, Germany

2
2
0
2

r
p
A
7
2

]
E
S
.
s
c
[

1
v
3
8
1
3
1
.
4
0
2
2
:
v
i
X
r
a

Abstract—Safety-critical designs need to ensure reliable opera-
tions under hostile conditions with a certain degree of conﬁdence.
The continuously higher complexity of these designs makes them
more susceptible to the risk of failure. ISO26262 recommends
fault injection as the proper technique to verify and measure
the dependability of safety-critical designs. To cope with the
complexity, a lot of effort and stringent veriﬁcation ﬂow is needed.
Moreover, many fault injection tools offer only a limited degree
of controllability.

We propose MetaFI, a model-driven simulator-independent
fault simulation framework that provides multi-purpose fault
injection strategies such as Statistical Fault Injection, Direct
Fault Injection, Exhaustive Fault Injection, and at the same
time reduces manual efforts. The framework enables injection
of Stuck-at faults, Single-Event Transient faults, Single-Event
Upset faults as well as Timing faults. The fault simulation is
performed at the Register Transfer Level (RTL) of a design,
in which parts of the design targeted for fault simulation are
represented with Gate-level (GL) granularity. MetaFI is scalable
with a full System-on-Chip (SoC) design and to demonstrate the
applicability of the framework, fault simulation was applied to
various components of two different SoCs. One SoC is running
the Dhrystone application and the other one is running a
Fingerprint calculation application. A minimal effort of 2 person-
days was required to run 38 various fault injection campaigns
on both the designs. The framework provided signiﬁcant data
regarding failure rates of the components. Results concluded that
Prefetcher, a component of the SoC processor, is more susceptible
to failures than the other targeted components on both the SoCs,
regardless of the running application.

Index Terms—Model-based generation, Safety analysis, Fault

Simulation, Fault models, Mixed granularity design

I. INTRODUCTION

Semiconductor devices operate in various environmental
conditions for a long duration of time. Natural radiation, aging,
mechanical stress, processing defects, and other events impact
the intended behavior of the system by introducing numerous
faults. When a fault causes an incorrect behavior of the device,
a failure occurs. Due to the increased complexity and growing
transistor density of modern designs, the probability of failures
is noticeably becoming higher [24]. Therefore, fault detection
and correction mechanisms are integrated into safety-critical
designs to detect failure events and take necessary precaution-
ary measures. ISO26262 [1], the functional safety standard
for the automotive domain, recommends fault injection as the
proper technique to assess circuit and system dependability.

Fault injection is deﬁned by [2], [31] as the validation tech-
nique of fault tolerant systems by observing the behavior of

the system in the presence of injected faults. Fault injection is
a well-researched topic and most of the developed techniques
fall into ﬁve categories [31]:

• Hardware-based fault injection,
• Software-based fault injection,
• Simulation-based fault injection,
• Emulation-based fault injection,
• Hybrid fault injection.
In this paper, we propose MetaFI, a fully automated model-
driven simulation-based fault injection framework that reduces
manual efforts signiﬁcantly. Initially, an existing saboteur-
based fault injection ﬂow of mixed RTL/GL granularity is
extended to support Timing faults and Single-Event Upsets.
Next, a metamodel-based generator framework is utilized to
automatically support various fault injection strategies such as
Exhaustive Fault Injection, Statistical Fault Injection, Direct
Fault Injection, and at the same time to provide a simulator-
independent fault simulation campaign.

To demonstrate the applicability, scalability, and advantages
of the proposed approach, various fault simulation campaigns
are applied to different
target components of two distinct
RISC-V based SoCs, running a Fingerprint calculation ap-
plication and Dhrystone program respectively. Experimental
results show that only a minimal amount of manual effort of
2 man-days was required to run 38 different fault injection
campaigns. Further, it was observed that for every campaign
we ran, the Prefetcher component, responsible for program
ﬂow, had the highest rate of failures on both the SoCs and we
recommended integrating different protection mechanisms to
this component to reduce the risk of failures.

The paper is structured as follows: Section II describes the
existing fault injection ﬂow. In Section III, we present the
extended fault models to support Timing faults and SEUs. Sec-
tion IV gives a detailed description of the model-based fault
simulation framework. The experimental results are described
in Section V and a brief summary in Section VI completes
the paper.

II. BACKGROUND

A. Fault models

Fault models are used to abstract the effect of faults onto
different abstraction levels of digital designs. The widely
applied fault models on the circuit and transistor-level of the
design are permanent and transient faults.

 
 
 
 
 
 
Permanent faults (hard errors) remain in the system for the
full duration of the operation, or until they are externally
ﬁxed. These kinds of faults are mainly caused by physical
effects, e.g. processing defects, electromigration, and other
aging effects [11]. Some examples of permanent faults are
stuck-at-0, i.e. a signal is permanently tied to logical value 0,
Stuck-at-1, i.e. a signal is permanently tied to logical value 1,
Timing faults, i.e. a delayed response in the system.

Transient faults (soft errors) are introduced in the system
only for a short duration of time and are mainly caused by
radiation effects [12]. These kinds of faults create a tempo-
rary change in the voltage of a signal that causes a logical
bitﬂip. Common examples of transient faults are Single-Event
Transients, i.e. a bitﬂip in the output of a combinational gate,
Single-Event Upset, i.e. a reversible bitﬂip in a sequential cell
(memory, registers, latches).

B. Fault Injection Flow

Fault modeling enables analyzing the effects of the faults on
the design utilizing fault injection. Traditionally, fault injection
has been applied to the Gate-Level (GL) and Register Transfer
Level (RTL) granularity of the design. Although fault injection
at GL granularity provides accurate fault coverage [17], [18],
it suffers from low performance. Contrary, RTL fault injec-
tion increases the performance but limits the applicable fault
models.

Ecker et al. [14] presented a mixed RTL/GL fault injection
ﬂow that utilizes an existing metamodel-based RTL genera-
tion framework [27], [28] to generate the RTL on a mixed
granularity that enables injecting different categories of faults.

Fig. 1. Mixed register transfer/gate-level design generation ﬂow

RTL generation is composed of three main abstraction
levels. The ﬁrst level captures the speciﬁcations into formal
models through a metamodel. The speciﬁcation models are
named as Model-of-Things (MoTs), and after the creation
of the MoT, a Python-based framework utilizes the microar-
chitecture blueprint deﬁned in the Template-of-Desing (ToD)
to generate a platform and technology independent hardware
description level termed as Model-of-Design (MoD). Lastly,
the MoD is mapped to Model-of-View (MoV) to generate the
RTL in a selected Hardware Description Language (HDL).

The aforementioned ﬂow is extended to generate the RTL on
a mixed RTL/GL granularity as shown in Fig. 1. Initially, the
generated RTL is synthesized to get its Gate-level representa-
tion, generally known as GL netlist. The ToD Generator (Fig.
1) extracts the data from the netlist and the speciﬁc technology
library used to synthesize the design. Depending on the input
from the user, i.e. component that is subject to fault injection,
ToD Generator generates a new ToD with a mixed RTL/GL
granularity. For example, let us consider a CPU core and
the Arithmetic-Logic Unit (ALU) is the target to apply fault
injection. The generator maps the GL representation of the
ALU to MoD components and the rest of the design modules
are mapped to the original RTL MoD components. Therefore,
the ToD generator builds the complete design model with
partial RTL and partial GL granularity.

MoD, a platform-independent layer, is a tree-like data struc-
ture that can be transformed by adding, deleting, or modifying
its items. Consequently, it permits adding extra components,
termed saboteurs into the design connections to enable fault
injection. Saboteurs are particular hardware modules added to
intended fault injection locations. They are easily controllable
and, when activated, modify the original value of a signal
[6]. Before adding the saboteurs to the design MoD, fault
collapsing [20] is performed to reduce the total number of
injectable faults. The collapsed fault list provides only one
of the two stuck-at fault models for equivalent faults (e.g. a
stuck-at-0 at the input and output of an AND gate). Saboteur
control signals are propagated as primary input ports of the
design, allowing a high degree of controllability.

Lastly, an equivalence check is applied between the original
RTL design and the transformed mixed RTL/GL granularity
design by constraining the saboteurs to not inject any fault.

III. EXTENDING THE FAULT INJECTION FLOW
The presented ﬂow is insufﬁcient to perform fault injec-
tion considering all circuit-level fault models. We propose
techniques to inject Timing faults via RTL primitives and
extend the current ﬂow to enable SEU independently from
the register/latch type.

A. Timing Faults

Timing faults, also known as transient-delay faults, were
ﬁrst mentioned by Breuer [7]. These faults arise as a result of
manufacturing [21], [23] and manifest as a delayed response
in the system. The affected system parts calculate the correct
result, but the response is observed later than in the fault-free
scenario.

Fig. 2. Timing fault example waveform
Assume an AND gate presented in the left side of Fig. 2.
Input A has a logical value of 1 for three consecutive clock

Designs pass equivalence check..Original RTL codeSynthesisTechnology LibraryGate level netlist View ModelMoDOriginal ToDToD GeneratorIntended components for fault injectionRTL code with submodule at Gate level granularity/added saboteursMoDGenerated ToD*View ModelFault collapsingSaboteursMod TransformationWrapperCopyright © Infineon Technologies AG 2021. All rights reserved.12021-10-25             restrictedABCBCABCcycles, input B becomes 1 next clock cycle after A becomes
1 and, consequently, C becomes 1 at the same clock cycle.
Due to a timing fault at the AND gate input, the rising edge
of input B is delayed by one clock cycle and, therefore, the
correct value at the output port is delayed as well.

To mimic the behavior displayed above, the existing sabo-
teurs in [14] are extended as shown in Fig. 3. Since the
injection ﬂow utilizes a mixed RTL/GL granularity,
is
possible to use RTL primitives, i.e. registers to induce a one
clock cycle delay. When the last bit of control signal CTRL
is set to 1, the In signal value at the output Out is delayed
by one clock cycle. Hence, a timing fault is injected to the
desired signal location.

it

Fig. 3. Timing fault saboteur

B. Single Event Upset

Single Event Upset faults occur when radiation causes
enough disturbance to ﬂip the logical value of a memory
cell, register, latch or ﬂip ﬂop. These soft errors have the
ability and potential to cause the highest failure rate of all
reliability mechanisms included [5]. The existing saboteurs
in the presented fault injection ﬂow trigger a bitﬂip at the
intended signal location. Nevertheless, some state-saving Gate-
level technology cells (registers, latches) depend on an enable
signal to activate the fault, i.e. if the cell is not activated, the
fault is masked. If the testing pattern does not consider the
case, it could potentially lead to a dangerous behavior of the
design and affect the dependability analysis.

Fig. 4.

Injection of SEU into Enabled D-FlipFlop

To tackle this scenario, we propose to replace enabled
technology cells with simple cells that have the enable signal
as a select signal for the multiplexer connected to the cell
input. An example of transforming an enabled D-Flipﬂop is
presented in Fig. 4. Both the circuits are equivalent, i.e. the

cell would be written only when the enable signal is activated.
Therefore, by adding the saboteurs at the input of the cell, as
shown in color red in Fig. 4, the value of the cell would be
ﬂipped independently of the enable signal.

IV. MODEL-DRIVEN FAULT SIMULATION FRAMEWORK

The existing fault injection ﬂow enables a high level of con-
trollability of fault injection locations via propagated saboteur
control lines as primary inputs. Nevertheless, the process of
fault simulation, i.e. determining the fault simulation purpose
and selecting fault model, requires manual efforts and is
prone to errors. We propose MetaFI, a simulator independent
model-driven fault simulation framework that facilitates and
automates the process of fault simulation with substantial
reduced manual efforts

A. MetaFI Metamodel

The integral part of the simulation framework is the MetaFI
metamodel, shown in Fig. 5. A model represents a system at
a certain abstraction level. Similarly, a metamodel represents
the structure of a model and the relation between the ele-
ments of a model [9]. The central class of the metamodel is
Fault Injection that has association relation with three main
components of the metamodel:
• Simulation Controller,
• Fault List,
• Fault Analyzer.
Simulation Controller describes the classes that deﬁne
the fault simulation purpose and fault models. Simula-
tion Controller class has three attributes: TopModule: Top
module of the RTL to perform fault simulation, Simula-
tionTime: determines for how many clock cycles to run the
simulation, TimingFaultActive: deﬁnes whether timing faults
are supported in order to add the extra hardware as presented
in section III. This class has a composition relation to three
classes: SFI, DFI, and ExhaustiveFI. These three classes
narrate the most common fault simulation purposes such as
Statistical Fault Injection (SFI), Direct Fault Injection (DFI),
and Exhaustive Fault Injection (ExhaustiveFI).

• SFI is one of the widely used techniques to determine the
dependability of safety-critical designs according to ISO
26262. During an SFI campaign, only a certain random
subset of all possible errors is injected. The subset is
random in relation to fault injection time and location.
This process allows the designer to deﬁne the number of
experiments to get a rigorous evaluation of the margin of
error and conﬁdence interval for the SFI campaign [19].
SFI class allows the user to select the total number of
the injected faults via the attribute SimTotal. FaultPerSim
details the total number of faults to inject per single
simulation, thus allowing single and multiple faults per
simulation. SEU and TimingFault are boolean attributes
and, when set to True, inject only Single Event Upsets or
Timing faults respectively. The fault model, fault injection
time, and fault location are all randomized.

12022-01-31             restrictedCopyright © Infineon Technologies AG 2022. All rights reserved.ANDORXORInCTRL[2][1][0]Out12022-01-31             restrictedCopyright © Infineon Technologies AG 2022. All rights reserved.DE-FFQClkOutENEnD-FFInDQEnClkOutD-FFInDQEnClkOutFault moduleMUX cellTechnology cellD-FFIn• For particular applications, it is needed to analyze the
effects of the injected fault on speciﬁc locations, speciﬁc
clock cycle and desired fault model. DFI class permits
the user to select the certain fault model to inject with
the help of FaultModel attribute. This attribute has a
relation to the Model enumeration class that supports four
different fault models. ID class lists the set of the faults to
inject per simulation, i.e. fault signals with the same ID
will be injected at the same simulation. SignalName class
determines the fault location. This class has a relation to
Time class, specifying the clock cycle to inject and release
the fault.

• Design for Test (DFT) techniques require an exhaustive
fault simulation, i.e. to inject all possible stuck-at faults
at all possible locations at the desired design component.
ExchaustiveFI class enables injecting all stuck-at faults
at all signals present in the fault list. InjectionTime and
ReleaseTime attribute determine the clock cycle to inject
the fault and remove the faulty line, respectively.

Fig. 5. MetaFI metamodel
Fault List represents the model-based fault list description.
A python-based script extracts the information from the de-
sign, performs fault collapsing, and populates the model with
the necessary fault information. FaultList class has a 1..* (one
to many) relation to the Signal class. It means that each signal
of the intended component to apply fault simulation will be
added to the fault list. Control attribute represents the saboteur
control line that manages the fault to inject at the certain signal
and Sequential attribute determines whether the signal is the
input of a register/latch which is important when injecting

Single Event Upsets. Fault Model shows all possible faults
to inject at the signal, e.g. after collapsing, only one of two
stuck-at fault models is needed.

Fault Analyzer describes the part of the metamodel that
is responsible to collect and analyze the data from the fault
injections. Group class represents modules and sub-modules of
the design, outputs of which are intended to be analyzed. It has
a 1..* relation to the Strobe class that deﬁnes all output signals
that should be analyzed. StrobeSignal attribute represents the
output signal, Active deﬁnes whether it should be analyzed or
not and StrobeType determines the output type, whether it is a
functional strobe (functional output of the design) or a checker
strobe (output of a safety mechanism).

B. Fault simulation algorithm

The MetaFI metamodel deﬁnes all the necessary features
to generate fault simulation testbenches. Using APIs of the
internal code generation framework, SystemVerilog (SV), Ver-
ilog and C++ fault simulation testbenches are generated con-
forming to the metamodel classes. The generated testbenches
are simulator independent,
i.e. all commercial and open-
source SV and Verilog simulators can be utilized to perform
fault simulation, while C++ generated testbench is speciﬁc
to Verilator [29], an open-source widely used simulator in
academia. A description of the complete ﬂow is given in Fig.
6.

Fig. 6. Fault simulation ﬂow
Fig. 7 presents the pseudocode of the testbench. Initially,
a golden simulation is run without any fault injected. The
simulation is run for as many clock cycles as determined by
the user (line 4) and the value of the selected strobe signals
at every clock cycle is stored in (output data) variable as
shown in line 6. Next, the fault simulation procedure is run.
Sim count is the variable counting the number of serial fault
simulations, i.e. after the complete simulation is completed,
it will increase by one. The testbench checks which fault
simulation category is selected by the user (lines 10, 20, 30).
If SFI or DFI is selected, a while loop determines how many
fault simulations to run as decided by the user (lines 11, 31
respectively.) If ExhaustiveFI is selected, then there should 2
stuck-at fault (s-a-0, s-a-1) simulations for every fault line (line
31). The Design Under Test (DUT) must be in a clean initial
state before every simulation is started (lines 12, 22, 32). For
each simulation, a set of faults from the fault list is injected
complying with the user data (lines 15,26,35), e.g. only stuck-
at faults, timing faults, random faults, etc. As the last step, the
value of selected strobe lines is compared to the data from the
golden simulation. The fault is then classiﬁed according to the
impact it has on the design and this information is stored in
log ﬁles.

12022-02-03             restrictedCopyright © Infineon Technologies AG 2022. All rights reserved.Name:string[0..1]Fault_InjectionrootNodeTopModule: string[0..1]SimulationTime: int[1]TimingFaultActive: bool[1]Simulation_ControllerInjectionTime: int[1]ReleaseTime: int[1]ExhaustiveFIID: int[1]FaultModel: Model[1]SignalName: string[1]DFIInjectionTime: int[1]ReleaseTime: int[1]TimeFaultsPerSim: int[1]SimTotal: int[1]SEU: bool[1]TimingFault: bool[1]SFIName: string[1]Fault_ListControl: string[1]Sequential: bool[1]SignalFaultModel:Model[1]Fault_ModelName: string[1]Fault_AnalyzerName: string[1]GroupStrobeSignal: string[1]Active: bool[1]StrobeType: StrobeType[1]StrobeSa0: ModelSa1: ModelBF: ModelTimingFault: Model<<enum>>ModelChecker: StrobeTypeFunctional: StrobeType<<enum>>StrobeType1..*1..*1..*1..*1110..10..1**: compositionUnderlined attributes have external reference (e.g. Value[1])Simulation_controllerFault_AnalyzerFault_List12022-04-11             restrictedCopyright © Infineon Technologies AG 2022. All rights reserved.TestbenchSpecificationsOriginal RTLRTL/GL with saboteurs Fault simulation TestbenchSimulatorRTL/GLMoDtransformReportsreturn store data()

while sim count < SimTotal do

run simulation()
inject random(f list, SEU, TimingFault)
output data = store date(f analyzer.getStrobes())
compare outputs(output data,GOLDEN SIM(sim time))
sim count = sim count+1

sim count=0
if sim ctrl.hasSFI() then

initial state()
while time++ < sim time do

initial state()
fault free signals()
while time++ < sim time do

run simulation()
output data = store data(f analyzer.getStrobes())

1: procedure GOLDEN SIM(sim time)
2:
3:
4:
5:
6:
7:
8: procedure FAULT SIM(sim ctrl, f list, f analyzer, sim time)
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:

sim count=0
if sim ctrl.hasExhaustiveFI() then

initial state()
while time++ < sim time do

initial state()
while time++ < sim time do

sim count=0
if sim ctrl.hasDFI() then

while sim count < total fault lines do

run simulation()
inject stuck at(f list)
output data = store date(f analyzer.getStrobes())
compare outputs(output data,GOLDEN SIM(sim time))
sim count = sim count+1

run simulation()
inject DFI(f list, FaultModel, SignalName, ID)
output data = store date(f analyzer.getStrobes())
compare outputs(output data,GOLDEN SIM(sim time))
sim count = sim count+1
Fig. 7. Fault simulation testbench pseudocode

while sim count < length(DFIs) do

V. APPLICATION AND RESULTS

The applicability and reduced efforts of fault simulation
ﬂow have been demonstrated by running experiments on two
different System-on-Chips (SoCs). First SoC is composed of
a RISC-V based processor, Instruction and Data Memory,
peripherals such as buses, bus bridge, SPI, UART and it is
running a ﬁngerprint calculation application. This application
hashes the value of Program Counter and compares it to an
expected value to protect the program control ﬂow.

Second SoC is composed of a RISC-V based processor
as well, Instruction and Data Memory, peripherals such as
buses, bus bridge, Timer, Interrupt Controller and it is running
Dhrystone application. Dhrystone measures the processor and
compiler performance running a ”typical” program.

Different fault simulation strategies were performed on
various components of the processor cores. The simulation
was run for 10k clock cycles, i.e. faults were injected only on
a random sequence of instructions. Experiments were run on
Xcelium ® [8] Verilog simulator.

Tables in the upcoming sub-sections display the results
of different fault injection strategies. Fault set represents the
total number of signals to inject faults and Total simulations
indicate the total number of fault simulations. Fail represents
the number of faults that have propagated to the functional
strobes, and Safe represents silent faults. Further, Runtime
indicates the complete time it took to run the experiments.

A. Exhaustive Fault Injection

Table I and Table II show the results of performing exhaus-
tive fault injection into RISC-V CPU components of the SoCs.
Both stuck-at-0 and stuck-at-1 faults were injected at all netlist
signals. Since fault collapsing is applied to the fault list, the
total amount of stuck-at faults is reduced. For example, let us
consider ALU in Table I. Fault set contains 2675 signals, i.e.
5350 (2675 times 2) possible stuck-at faults, but after fault
collapsing the fault list was reduced to 4713 (12% reduction).
Observations: Dhrystone application was more susceptible
to stuck-at failures and a notable difference was observed
while injecting faults at Execute (EX) stage. Faults injected
into the fetch stage (IF) were responsible for the least per-
centage of failures on both SoCs.
TABLE I
FINGERPRINT APPLICATION EXHAUSTIVE FI

Component

ALU
Prefetcher
IF stage
EX stage

Fault
set

2675
2546
8449
11784

Total
simulations

Fail

Safe

Runtime
h:min

4713
4347
13683
20489

45.0% 55.0% 02:27
55.5% 44.5% 03:18
20.0% 80.0% 11:06
35.9% 64.1% 23:24

TABLE II
DHRYSTONE APPLICATION EXHAUSTIVE FI

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
7948
12322

Total
simulations

Fail

Safe

Runtime
h:min

4713
4347
12788
21601

52.1% 47.9% 02:26
71.6% 28.4% 03:57
32.4% 67.6% 08:45
68.9% 31.1% 16:21

B. Statistical Fault Injection

Table III and Table IV show the results of performing SFI
on the same components as above. 5000 faults were injected
randomly: random clock cycle, random location, and random
fault model. Timing faults were not included since the design
area would be increased and it would impact the runtime
performance.

Observations: Similarly to Exhaustive Fault

Injection,
Dhrystone application was more susceptible to faults. Never-
theless, we see a reduction of failures on both IF and EX stage
and the one reason for that is the small number of simulations
compared to the total fault set.

TABLE III
FINGERPRINT APPLICATION SFI WITHOUT TIMING FAULTS

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
8449
11784

Total
simulations

Fail

Safe

Runtime
h:min

5000
5000
5000
5000

16.4% 83.6% 03:10
21.2% 78.8% 03:56
7.9%
92.1% 04:33
10.1% 89.9% 05:23

C. SEU Fault Injection

Table V and Table VI present the results of randomly inject-
ing only SEU faults into the SoC components. Observations:
Similarly, Dhrystone application is more susceptible to faults,
but as can be seen from the tables, the rate of failures is fairly
low for both applications.

TABLE IV
DHRYSTONE APPLICATION SFI WITHOUT TIMING FAULTS

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
7948
12322

Total
simulations

Fail

Safe

Runtime
h:min

5000
5000
5000
5000

20.5% 79.5% 03:15
31.6% 68.4% 03:28
12.6% 87.4% 04:01
11.9% 88.1% 04:39

TABLE V
FINGERPRINT APPLICATION SEU FAULTS

Component

Prefetcher
IF stage
EX stage

Fault
lines
208
857
959

Total
simulations
500
2000
2000

Fail

Safe

Runtime
h:min
14.4%
85.6% 00:16
84.7% 01:35
5.3%
1.8%% 98.2% 01:42

TABLE VI
DHRYSTONE APPLICATION SEU FAULTS

Component

Prefetcher
IF stage
EX stage

Fault
lines
208
857
926

Total
simulations
500
2000
2000

Fail

Safe

Runtime
h:min
87.8% 00:13
18.2%
6.4%
83.6% 01:12
3.1%% 96.9% 01:32

D. Statistical Fault Injection including timing faults

SFI results presented in Table III and Table IV are extended
to support timing faults as well. As explained in section III,
timing faults add an extra register and multiplexer to the
saboteur. Table VII and Table VIII display the results of
conducting SFI campaign including timing faults in the SoCs.
Observations: Timing faults do not increase the rate of
failure. Results are very similar to the ones presented in Table
III and Table IV and the marginal difference is only 0-2%.
TABLE VII
FINGERPRINT APPLICATION SFI WITH TIMING FAULTS

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
8449
11784

Total
simulations

Fail

Safe

Runtime
h:min

5000
5000
5000
5000

15.3% 84.7% 11:01
21.0% 79.0% 09:14
92.5% 25:01
7.5%
10.6% 89.4% 72:03

TABLE VIII
DHRYSTONE APPLICATION SFI WITH TIMING FAULTS

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
7948
12322

Total
simulations

Fail

Safe

Runtime
h:min

5000
5000
5000
5000

22.0% 78.0% 10:05
32.2% 67.8% 09:25
11.6% 88.4% 29:59
12.7% 88.1% 78:14

E. Random timing faults

As the last experiment, we injected randomly only timing
faults into the SoCs and the results are shown on Table IX
and Table X.

Observations: Similar results as previous SFI campaigns
are noticed. Failure rate is higher for Prefetcher injected
faults(6% on average) and the marginal difference for the other
components is still fairly low.

TABLE IX
FINGERPRINT APPLICATION RANDOM TIMING FAULTS

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
8449
11784

Total
simulations

Fail

Safe

Runtime
h:min

5000
5000
5000
5000

15.6% 84.4% 10:48
27.0% 77.0% 08:50
6.0%
94.0% 23:11
11.5% 88.5% 70:04

TABLE X
DHRYSTONE APPLICATION RANDOM TIMING FAULTS

Component

ALU
Prefetcher
IF stage
EX stage

Fault
lines

2675
2546
7948
12322

Total
simulations

Fail

Safe

Runtime
h:min

5000
5000
5000
5000

22.5% 77.5% 09:34
36.2% 63.8
08:43
12.4% 87.6% 26:50
13.0% 87.0% 76:20

F. General observations

The fully automated ﬂow facilitated fault injection cam-
paigns with a very minimal effort of 2 person-days, spent
mostly on conﬁguring the fault campaign attributes. Further,
the technique was scalable with a full System-on-Chip design,
a bottleneck for fault simulators since many are utilized only
on a processor level [25], [10], [22]. Moreover, [14] shows
that the existing fault injection ﬂow introduces an overhead
of 16%-99% of overall runtime compared to the original
design, but an increase of 3.5x-8.4x in the fault simulation
performance compared to full GL simulation.. After running
the IF stage was the
the experiments, we observed that
component most resilient to failures. This was due to the fact
that one of the biggest modules of IF stage is the Exception
Unit. Since no exception was detected during the applications
run, the fault injected into it had no real effect on the SoC.
Noticeably, Prefetcher had the highest rate of failure on every
fault simulation campaign, because it is the component that
controls the PC. We noticed also that
the failure rate of
the applications is low. The main reason is that the random
interval (10k clock cycles) of instruction sequences that we
chose to inject faults was repeating many series of instructions
due to software loops and we expect a higher failure rate
for different intervals. Timing faults introduced an acceptable
runtime performance overhead, 3-16.8x slower, considering
the increased design area due to added registers.

VI. RELATED WORK

Fault simulation is a well-researched topic in academia and
industry. In this section, we are providing a summary of the
most related works.

Pravadelli et al. [10] present an automated non-intrusive
simulation-based fault injection framework based on QEMU,
an emulator for microprocessor architectures. The authors
injected faults into the processor by masking data structures
inside QEMU to mimic the behavior of the faults. The
framework supports stuck-at faults, timing faults, as well as
bit-ﬂips, and experiments were conducted in x86 and ARM
processors. This approach provides a fast simulation ﬂow for

CPU designs but could lack some accuracy compared to cycle-
accurate fault injection and further estimations are needed.

An approach to inject faults on microarchitectural simula-
tors is presented in [15]. Authors have extended MARSS and
Gem5 simulators to support fault injection (namely MaFIN
and GeFIN respectively). A Fault Mask Generator is im-
plemented that can produce a random set of fault masks
for different types of faults such as bitﬂips, permanent and
intermittent faults. An Injection Campaign Controller reads the
masks and sends injection requests to the Injector Dispatcher,
a module that communicates directly with the simulators.
Experiments were run on x86 and ARM processors, and the
technique is only suitable for processor fault simulation.

In [16] authors propose a framework for Verilog-based
fault injection based on Verilog Programming Interface (VPI).
A single system function allows the user to determine the
fault type, location, and duration of the fault. With the help
of callback functions, i.e. using VPI to control the Verilog
simulator, the selected fault is injected. The technique can only
be applied to Verilog and VPI-compliant simulators.

Rosa et al. [26] present a fault

injection framework to
evaluate soft error reliability of multi/many-core design. The
framework is able to inject faults into the memory area, CPU
registers, and interconnection infrastructure. Authors have
extended the existing OPVSim and via the help of callbacks,
they enabled accessing, modifying, and controlling platform
components during simulation, thus, the user can determine the
fault injection campaign by setting particular ﬂags to inform
target components.

[4], [3], [13] modify the VHDL description of the design
with the help of saboteurs and mutants. These techniques
provide a high degree of controllability but are limited to RTL
and VHDL description language.

A fault injection tool, SINJECT, based on the synthesiz-
ability of HDL models is proposed in [30]. The tool provides
injection of bitﬂips and permanent faults into the Verilog
and VHDL models. The authors ran experiments on two
different small processors, ARP and DP32. Even though the
tool provides an automated fault injection campaign, we expect
it to have a high overhead when it comes to simulating an SoC
and further experiments are needed.

VII. CONCLUSION AND FUTURE WORK

We introduced in this paper a fully automated fault simula-
tion framework, namely MetaFI, supporting different perma-
nent and transient fault models. Furthermore, MetaFI enables
running automatically various fault injection campaigns such
as EFI, SFI, and DFI. Numerous experiments were conducted
on different components of two SoCs, running ﬁngerprint
calculation application and Dhrystone program respectively.
A very minimal manual effort of 2 man-days was required to
run 38 distinct fault injection campaigns. Additionally, it was
concluded that Prefetcher was the component most susceptible
to failures, and protection mechanisms are recommended to be
integrated into this component. Timing faults introduced an
overhead of 3-16x due to the increased design area. In future

work, we aim to reduce timing faults overhead by dynamically
modifying the saboteurs. Also, extending the fault injection
ﬂow to use different techniques apart from the simulation is
an outlook for future work.

VIII. ACKNOWLEDGEMENTS

Part of the work has been performed in the project Archi-
tectECA2030 under grant agreement No 877539. The project
is co-funded by grants from Germany, Netherlands, Czech
Republic, Austria, Norway, France and Electronic Component
Systems for European Leadership Joint Undertaking (ECSEL
JU). Part of the work described herein is also funded by the
German Federal Ministry of Education and Research (BMBF)
as part of the research project Scale4Edge (16ME0122K).

REFERENCES

[1] Road vehicles — Functional safety — Part 11: Guidelines on application
of ISO 26262 to semiconductors. https://www.iso.org/obp/ui/#iso:std:
iso:26262:-11:ed-1:v1:en.

[2] J. Arlat, Y. Crouzet, and J.-C. Laprie. Fault injection for dependability
In [1989] The Nine-
validation of fault-tolerant computing systems.
teenth International Symposium on Fault-Tolerant Computing. Digest of
Papers, pages 348–355, 1989.

[3] J.C. Baraza, J. Gracia, D. Gil, and P.J. Gil.

Improvement of fault
In Tenth IEEE
injection techniques based on vhdl code modiﬁcation.
International High-Level Design Validation and Test Workshop, 2005.,
pages 19–26, 2005.

[4] Juan-Carlos Baraza, Joaqu´In Gracia, Sara Blanc, Daniel Gil, and Pedro-
J. Gil. Enhancement of fault injection techniques based on the modiﬁ-
cation of vhdl code. IEEE Transactions on Very Large Scale Integration
(VLSI) Systems, 16(6):693–706, 2008.

[5] R.C. Baumann. Radiation-induced soft errors in advanced semiconductor
technologies. IEEE Transactions on Device and Materials Reliability,
5(3):305–316, 2005.

[6] Alfredo Benso and Paolo Prinetto. Fault Injection Techniques and Tools

for Embedded Systems Reliability Evaluation. 01 2003.

[7] M.A. Breuer. The effects of races, delays, and delay faults on test
IEEE Transactions on Computers, C-23(10):1078–1092,

generation.
1974.

[8] Cadence Design Systems.

https:
//www.cadence.com/ko KR/home/tools/system-design-and-veriﬁcation/
simulation-and-testbench-veriﬁcation/xcelium-simulator.html.

Xcelium Logic Simulation.

[9] Wolfgang Ecker and Johannes Schreiner. Metamodeling and Code
Generation in the Springer Science+Business Media Dordrecht, pages
1–41. 01 2016.

[10] Davide Ferraretto and Graziano Pravadelli. Efﬁcient fault injection in
qemu. In 2015 16th Latin-American Test Symposium (LATS), pages 1–6,
2015.

[11] J¨org Henkel, Lars Bauer, Nikil Dutt, Puneet Gupta, Sani Nassif, Muham-
mad Shaﬁque, Mehdi Tahoori, and Norbert Wehn. Reliable on-chip
systems in the nano-era: Lessons learnt and future trends. In 2013 50th
ACM/EDAC/IEEE Design Automation Conference (DAC), pages 1–10,
2013.

[12] Andreas Herkersdorf, Michael Engel, Michael Glaß, J¨org Henkel, Veit
Kleeberger, Michael Kochte, Johannes K¨uhn, Sani Nassif, Holm Rauch-
fuss, Wolfgang Rosenstiel, Ulf Schlichtmann, Muhammad Shaﬁque,
Mehdi Tahoori, J¨urgen Teich, Norbert Wehn, Christian Weis, and Hans-
Joachim Wunderlich. Cross-layer dependability modeling and abstrac-
tion in system on chip. 03 2013.

[13] E. Jenn, J. Arlat, M. Rimen, J. Ohlsson, and J. Karlsson. Fault injection
In Proceedings of IEEE 24th
into vhdl models:
International Symposium on Fault- Tolerant Computing, pages 66–75,
1994.

the meﬁsto tool.

[14] Endri Kaja, Nicolas Gerlin, Mounika Vaddeboina, Luis Rivas, Sebas-
tian Prebeck, Zhao Han, Keerthikumara Devarajegowda, and Wolfgang
Ecker. Towards fault simulation at mixed register-transfer/gate-level
In 2021 IEEE International Symposium on Defect and Fault
models.
Tolerance in VLSI and Nanotechnology Systems (DFT), pages 1–6, 2021.

[15] Manolis Kaliorakis, Sotiris Tselonis, Athanasios Chatzidimitriou, Nikos
Foutris, and Dimitris Gizopoulos. Differential fault injection on mi-
croarchitectural simulators. In 2015 IEEE International Symposium on
Workload Characterization, pages 172–182, 2015.

[16] David Kammler, Junqing Guan, Gerd Ascheid, Rainer Leupers, and
Heinrich Meyr. A fast and ﬂexible platform for fault injection and eval-
uation in verilog-based simulations. In 2009 Third IEEE International
Conference on Secure Software Integration and Reliability Improvement,
pages 309–314, 2009.

[17] Michael A. Kochte, Christian G. Zoellin, Rafal Baranowski, Michael E.
Imhof, Hans-Joachim Wunderlich, Nadereh Hatami, Stefano Di Carlo,
and Paolo Prinetto. Efﬁcient simulation of structural faults for the
In 2010 19th IEEE Asian Test
reliability evaluation at system-level.
Symposium, pages 3–8, 2010.

[18] Dongwoo Lee and Jongwhoa Na. A novel simulation fault injection
IEEE Design Test of Computers,

method for dependability analysis.
26(6):50–61, 2009.

[19] R. Leveugle, A. Calvez, P. Maistri, and P. Vanhauwaert. Statistical fault
injection: Quantiﬁed error and conﬁdence. In 2009 Design, Automation
Test in Europe Conference Exhibition, pages 502–506, 2009.

[20] A. Lloy. Advanced fault collapsing (logic circuits testing). IEEE Design

Test of Computers, 9(1):64–71, 1992.

[21] G.M. Luong and D.M.H. Walker. Test generation for global delay faults.
In Proceedings International Test Conference 1996. Test and Design
Validity, pages 433–442, 1996.

[22] P.S. Magnusson, M. Christensson, J. Eskilson, D. Forsgren, G. Hallberg,
J. Hogberg, F. Larsson, A. Moestedt, and B. Werner. Simics: A full
system simulation platform. Computer, 35(2):50–58, 2002.

[23] Yashwant K. Malaiya and Ramesh Narayanaswamy. Modeling and
testing for timing faults in synchronous sequential circuits. IEEE Design
Test of Computers, 1(4):62–74, 1984.

[24] J.-H. Oetjens, N. Bannow, M. Becker, O. Bringmann, A. Burger,
M. Chaari, S. Chakraborty, R. Drechsler, W. Ecker, K. Gr¨uttner, Th.
Kruse, C. Kuznik, H. M. Le, A. Mauderer, W. M¨uller, D. M¨uller-
Gritschneder, F. Poppen, H. Post, S. Reiter, W. Rosenstiel, S. Roth,
U. Schlichtmann, A. von Schwerin, B.-A. Tabacaru, and A. Viehl. Safety
evaluation of automotive electronics using virtual prototypes: State of
the art and research challenges. In 2014 51st ACM/EDAC/IEEE Design
Automation Conference (DAC), pages 1–6, 2014.

[25] Konstantinos Parasyris, Georgios Tziantzoulis, Christos D. Antonopou-
los, and Nikolaos Bellas. Gemﬁ: A fault injection tool for studying
In 2014 44th
the behavior of applications on unreliable substrates.
Annual IEEE/IFIP International Conference on Dependable Systems and
Networks, pages 622–629, 2014.

[26] Felipe Rosa, Fernanda Kastensmidt, Ricardo Reis, and Luciano Ost. A
fast and scalable fault injection framework to evaluate multi/many-core
soft error reliability. In 2015 IEEE International Symposium on Defect
and Fault Tolerance in VLSI and Nanotechnology Systems (DFTS), pages
211–214, 2015.

[27] J. Schreiner, R. Findenig, and W. Ecker. Design Centric Modeling of
Digital Hardware. In IEEE International High Level Design Validation
and Test Workshop, HLDVT 2016, pages 46–52, 2016.

[28] J. Schreiner, F. Willgerodt, and W. Ecker. A new approach for generating
view generators. In Design and Veriﬁcation Conference - US, Feb 2017.
http://events.dvcon.org/2017/proceedings/papers/04P 18.pdf.

[29] Verilator. Verilator. https://www.veripool.org/verilator/.
[30] H.R. Zarandi, S.G. Miremadi, and A. Ejlali. Dependability analysis
using a fault injection tool based on synthesizability of hdl models. In
Proceedings 18th IEEE Symposium on Defect and Fault Tolerance in
VLSI Systems, pages 485–492, 2003.

[31] Haissam Ziade, Raﬁc Ayoubi, and R. Velazco. A survey on fault

injection techniques. Int. Arab J. Inf. Technol., 1:171–186, 01 2004.

