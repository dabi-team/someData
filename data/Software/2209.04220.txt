2
2
0
2

p
e
S
9

]
F
P
.
s
c
[

1
v
0
2
2
4
0
.
9
0
2
2
:
v
i
X
r
a

A Software Package for Queueing Networks and Markov
Chains analysis

MORENO MARZOLLA, UniversitÃ  di Bologna, Italy

Queueing networks and Markov chains are widely used for conducting performance and reliability studies.
In this paper we describe the queueing package, a free software package for queueing networks and Markov
chain analysis for GNU Octave. The queueing package provides implementations of numerical algorithms for
computing transient and steady-state performance measures of discrete and continuous Markov chains, and
for steady-state analysis of single-station queueing systems and queueing networks. We illustrate the design
principles of the queueing package, describe its most salient features and provide some usage examples.

CCS Concepts: â€¢ Mathematics of computing â†’ Queueing theory; Markov processes; Mathematical
software.

Additional Key Words and Phrases: Queueing Networks, Markov Chains, Mean Value Analysis

1 INTRODUCTION
Queueing Networks (QNs) and Markov chains are powerful modeling notations that are commonly
used for capacity planning, bottleneck analysis and performance evaluation of systems [7]. Ana-
lyzing QNs and Markov chains involves the computation of metric such as the system throughput
of a QN, or the stationary state occupancy probabilities of a Markov chain. Symbolic, numerical,
and simulation-based techniques have been developed to compute these metrics.

In this paper we describe the queueing package for GNU Octave, a free environment for numer-
ical computing [16]. The queueing package provides implementations of numerical algorithms
for (i) transient and stationary analysis of discrete and continuous Markov chains; (ii) stationary
analysis of single-station queueing systems; (iii) stationary analysis of some classes of product-
form Queueing Network.

Although QNs and Markov chains are well studied topics, relatively few computer implementa-
tions of solution algorithms are available and actively supported [12]. Table 1 lists some software
tools that are relevant for this paper.

JMT [6] is a Java package for workload characterization, bottleneck analysis, and QN modeling.
JMT has a GUI that simpliï¬es the deï¬nition and analysis of QN models, although it can also be
used from the command line. JMT uses a simulation engine as its main solution technique, so it
can support extended features (non-Markovian queues, fork/join systems, passive resources, and
others) that are diï¬ƒcult if not impossible to handle numerically.

The LINE solver [11] is a free MATLAB toolbox for analyzing extended and layered queueing net-
works [17]. Extended QNs support features, such as simultaneous resource possession, fork/join
systems, ï¬nite capacity regions and others, allowing more accurate models to be deï¬ned. This
comes with the drawback that extended QNs are more diï¬ƒcult to analyze numerically. LINE can
delegate the solution of these models to external solvers such as JMT.

PDQ [19] is an implementation of the Mean Value Analysis (MVA) algorithm for closed, single-
class networks. PDQ provides bindings for diï¬€erent programming languages: at the time of writing,
C, Perl, Python and R are supported.

The queueing package for R [9] (that, despite the name, is unrelated to the software described
in this paper) is a free package for analyzing product-form QNs written in the R language [29]. It
supports product-form open and closed, single and multiclass networks.

Authorâ€™s address: Moreno Marzolla, moreno.marzolla@unibo.it, UniversitÃ  di Bologna, Department of Computer Science
and Engineering (DISI), Mura Anteo Zamboni 7, Bologna, I-40126, Italy, moreno.marzolla@unibo.it.

 
 
 
 
 
 
2

Name

JMT [6]

LINE [11]
PDQ [19]
queueing [9]

SHARPE [35]

Description

Java tool for workload characterization, simulation-based queueing net-
work modeling
Performance and reliability analysis based on queueing models
queueing networks
R package for analyzing single-station queueing systems and queueing
networks
reliability modeling, Markov and semi-Markov models, Petri nets,
queueing networks

Moreno Marzolla

License

GNU GPL

BSD-3
MIT
GNU GPL

Proprietary

Table 1. Some software package for queueing network analysis that are currently available and actively
maintained.

SHARPE (Symbolic Hierarchical Automated Reliability and Performance Evaluator) [35] is a hi-
erarchical modeling tool that supports any combination of diï¬€erent types of performance and reli-
ability models (product-form queueing networks, Petri nets, Markov chains, fault trees). SHARPE
has both a command-line and a graphical interface, and has been under development since the
early 80s. It is the only tool of those reviewed that has a non-free license.

The queueing package presented in this paper is somewhat orthogonal to above tools, in the
sense that it has been developed around speciï¬c design goals which are only partially considered
by other packages; of course, this implies that it has some limitations which might be addressed
by other tools.

One of the design goals of the queueing package is to provide reference implementations of
some fundamental â€œtextbookâ€ algorithms for QN and Markov chain analysis, like other research
communities are doing since a long time (e.g., linear algebra algorithms). To this aim, eï¬ƒciency has
sometimes been sacriï¬ced in favor of code readability. The availability of reference implementa-
tions is useful also for teaching purposes: students can immediately put the textbook algorithms at
work to solve practical problems, encouraging â€œlearning by doingâ€. The author is aware of several
Universities that are using the queueing package to teach performance modeling classes.

The GNU Octave language, being a large subset of the MATLAB language, is well suited for
implementing numerical algorithms that operate on arrays and matrices in a concise and under-
standable way. Moreover, it allows complex performance studies can be done quickly, since models
involving repetitive or embedded structure can be deï¬ned programmatically. Parametric model
evaluation or ad-hoc analyses are also possible. The queueing package has been contributed to
the Octave-forge public repository (https://octave.sourceforge.io/). This means that queueing can
be easily installed from the Octave prompt using the standard command pkg install.

Any design decision inevitably carries some drawbacks. The GNU Octave environment allows a
great degree of ï¬‚exibility, but imposes a steep learning curve that might deter the occasional user.
The focus on well-known classic algorithms neglects more recent results or less frequently used
techniques. Yet, both issues can be addressed. A more comfortable interface, e.g., a GUI, can be built
either as an independent application, or by leveraging existing tools (e.g., JMT) and then delegating
the computations to the queueing package. More algorithms can be implemented and contributed
for inclusion in the queueing package, that is free software and as such can be extended by anyone.
A few contributors already did so.

This paper is structured as follows. In Section 2 we illustrate the design principles behind
the queueing package. The next sections are devoted to illustrate the functions for analyzing
Markov chains (Section 3), single-station queueing systems (Section 4) and queueing networks

A Software Package for Queueing Networks and Markov Chains analysis

3

(Section 5). The presentation focuses on the features provided, rather than the algorithmic details;
comprehensive bibliographic references are provided for the interested reader. Although this pa-
per is not intended to be a substitute of the package userâ€™s manual, a few examples will be shown
to better illustrate its use. Finally, concluding remarks are given in Section 6.

2 DESIGN PRINCIPLES
The queueing package is a collection of functions for computing transient and steady-state perfor-
mance measures of queueing networks and Markov chains. It has been under development over
the last decade to support the authorâ€™s research and teaching activity in the area of performance
modeling of systems. The queueing package consists of a set of m-ï¬les written in the GNU Oc-
tave [16] dialect of the MATLAB programming language; therefore, queueing does not require
any special installation procedure, nor does it require a compiler to generate executable code.

The decision of targeting GNU Octave was made at the beginning of the development eï¬€ort.
GNU Octave started its existence as a free MATLAB clone, but ended up providing extensions and
additional features, some of which have been exploited by queueing (see below). More importantly,
GNU Octave is free software and runs on all major operating systems, so it does not represent an
entry barrier for potential users.

GNU Octave supports most of the standard MATLAB syntax, plus some extensions. For example,
! can be used as the logical not operator; structured blocks such as the if and for constructs can be
terminated with the endif and endfor keywords, respectively, to improve readability. The Texinfo
markup notation [14] can be used for the documentation text embedded in function ï¬les. This
feature has been extensively used: the documentation of each function in the queueing package
can be displayed using the help command during interactive sessions. The userâ€™s manual, in PDF
and HTML formats, is built from the Texinfo documentation extracted from the source ï¬les. This
guarantees that the userâ€™s manual is always consistent with the help text.

Naming conventions. Most of the functions in the queueing package obey a common naming
convention. Function names are the concatenation of several parts, beginning with a preï¬x that
indicates the class of problems the function addresses:

ctmc-
dtmc-
qs-
qn-

Functions dealing with continuous-time Markov chains
Functions dealing with discrete-time Markov chains
Functions dealing with single-station queueing systems
Functions dealing with queueing networks

Functions that handle Markov chains (Section 3) start with either the ctmc or dtmc preï¬x, that

may be followed by a string that hints at what the function does:

-bd
-mtta
-fpt
-exps
-taexps

Birth-Death process
Mean Time to Absorption
First Passage Times
Expected Sojourn Times
Time-Averaged Expected Sojourn Times

Therefore, function ctmcbd returns the inï¬nitesimal generator matrix for a continuous birth-
death process, while dtmcbd returns the transition probability matrix for a discrete birth-death
process. Functions ctmc and dtmc (without any suï¬ƒx) compute steady-state and transient state
occupancy probabilities for Continuous Time Markov Chains (CTMCs) and Discrete Time Markov
Chains (DTMCs), respectively.

Functions whose name starts with qs- deal with single station queueing systems (Section 4).

The suï¬ƒx describes the type of system, e.g., qsmm1 for ğ‘€/ğ‘€/1, qnmmm for ğ‘€/ğ‘€/ğ‘š and so on.

4

Moreno Marzolla

Finally, functions whose name starts with qn- deal with queueing networks (Section 5). The
character that follows indicates the type of network (o = open network, c = closed network), and
whether there is a single (s) or multiple (m) customer classes.

-os-
-om-
-cs-
-cm-
-mix-

Open, single-class network
Open, multiclass network
Closed, single-class network
Closed, multiclass network
Mixed network with open and closed classes of customers

The last part of the function name indicates what the function computes:

-aba
-bsb
-gb
-pb
-cb
-mva
-cmva
-mvald
-mvabs
-mvablo
-conv
-convld

Asymptotic Bounds
Balanced System Bounds
Geometric Bounds
PB Bounds
Composite Bounds
Mean Value Analysis (MVA)
Conditional MVA
MVA with load-dependent servers
Approximate MVA using Bard and Schweitzerâ€™s approximation
Approximate MVA for blocking queueing networks
Convolution algorithm
Convolution algorithm with load-dependent servers

Validation. One important issue of numerical software is to make sure that the computed results
are correct. Almost all functions in the queueing package include unit tests embedded as specially-
formatted comments inside the source code. The unit tests are used to check the results against
reference values from the literature. When reference results are not available, cross-validation
with the output of diï¬€erent functions on the same model (if available), or with the output of other
packages have been used. For example, a closed product-form network can be analyzed by MVA
or using the convolution algorithm; therefore it is possible to apply the functions qncsmva() and
qncsconv() on the same model and check whether their results agree up to known numerical
problems [10]. Results have also been compared with those produced by diï¬€erent tools. This was
helpful to investigate an issue with the qncmmva() function, whose result on the model described
in [33, Figure 7, p. 9] did not agree with the one reported in that paper. The model was analyzed
with Java Modeling Tools (JMT) that conï¬rmed the values computed by the queueing package.

3 MARKOV CHAINS
A stochastic process is a set of random variables {ğ‘‹ (ğ‘¡), ğ‘¡ âˆˆ ğ‘‡ } where each ğ‘‹ (ğ‘¡) is indexed by a
time parameter ğ‘¡ âˆˆ ğ‘‡ . The state space is the set of all possible values of ğ‘‹ (ğ‘¡). A time-homogeneous
Markov chain is a stochastic process over the discrete state space {1, . . . , ğ‘ } for some given ğ‘ . In
a DTMC, the time parameter ğ‘¡ assumes the discrete values in ğ‘‡ = {0, 1, . . .}, while in a CTMC the
time parameter assumes values in ğ‘‡ = [0, +âˆ).

In a time-homogeneous DTMC the conditional probability ğ‘ğ‘–,ğ‘— = Pr{ğ‘‹ (ğ‘›+1) = ğ‘— | ğ‘‹ (ğ‘›) = ğ‘–} that
the system is in state ğ‘— at time ğ‘› + 1, given that the system was in state ğ‘– at time ğ‘›, is independent
from ğ‘›, so that we can deï¬ne a DTMC as a stochastic matrix P âˆˆ Rğ‘ Ã—ğ‘ , where ğ‘ğ‘–,ğ‘— = Pr{ğ‘‹ (ğ‘› + 1) =
ğ‘— | ğ‘‹ (ğ‘›) = ğ‘–} is the transition probability from state ğ‘– to state ğ‘— , ğ‘– â‰  ğ‘— .

Similarly, in a time-homogeneous CTMC the conditional probability ğ‘ğ‘–,ğ‘— (ğ‘¢, ğ‘£) = Pr{ğ‘‹ (ğ‘£) =
ğ‘— | ğ‘‹ (ğ‘¢) = ğ‘–}, ğ‘£ â‰¥ ğ‘¢, only depends on the time diï¬€erence ğ‘¡ = ğ‘£ âˆ’ ğ‘¢, and not on the speciï¬c values

A Software Package for Queueing Networks and Markov Chains analysis

5

ğ‘1

ğ‘2

ğ‘3

ğ‘ğ‘

1

2

3

Â· Â· Â·

ğ‘ +1

ğ‘‘1

ğ‘‘2

ğ‘‘3

ğ‘‘ğ‘

Fig. 1. Birth-death process

of ğ‘¢ and ğ‘£, so that we have ğ‘ğ‘–,ğ‘— (ğ‘¡) = Pr{ğ‘‹ (ğ‘¢ + ğ‘¡) = ğ‘— | ğ‘‹ (ğ‘¢) = ğ‘–} = Pr{ğ‘‹ (ğ‘¡) = ğ‘— | ğ‘‹ (0) = ğ‘–} for
each ğ‘¡ â‰¥ 0. The evolution of a CTMC is deï¬ned by a generator matrix Q âˆˆ Rğ‘ Ã—ğ‘ where ğ‘ğ‘–,ğ‘— is
the transition rate from state ğ‘– to state ğ‘— â‰  ğ‘–. The diagonal elements ğ‘ğ‘–ğ‘– are deï¬ned in such a way
that the sum of each row is zero, i.e., 1Q = 0 (1 and 0 denote suitably sized row vectors of 1 and 0,
respectively).

Let ğœ‹ğ‘– (0) be the probability that the system is in state ğ‘– at time 0. It can be shown that the state

occupancy probabilities ğ… (ğ‘¡) = (ğœ‹1(ğ‘¡), . . . , ğœ‹ğ‘ (ğ‘¡)) at time ğ‘¡ can be computed as:

ğ… (ğ‘›) = ğ… (0)Pğ‘›

(DTMC)

ğ… (ğ‘¡) = ğ… (0)ğ‘’Qğ‘¡

(CTMC)

(1)

Under certain conditions [7] a Markov chain has a unique stationary distribution ğ… that is inde-
pendent from the initial state. The stationary distribution can be computed by solving the linear
systems:

= ğ…
ğ… P
ğ… 1âŠº = 1

(DTMC)

(
where 1âŠº is a column vector of 1.

ğ… Q = 0
ğ… 1âŠº = 1

(

(CTMC)

(2)

Functions dtmc() and ctmc() compute the transient or stationary state occupancy probabili-
ties of a DTMC and CTMC, respectively, using a direct implementations of equations (1) and (2),
respectively. For example, the expression pn = dtmc(P,n,p0) computes the state occupancy prob-
ability vector pn after ğ‘› steps of a DTMC with stochastic matrix ğ‘ƒ and initial state probabilities p0.
If invoked with a single parameter as in p = dtmc(P), the function computes the stationary state
distribution vector p. ctmc() can be used in a similar way to analyze CTMCs.

The queueing package provides other functions that compute metrics used in reliability and
performability studies. The Mean Time To Absorption (MTTA) of a DTMC is deï¬ned as the average
number of transitions required to reach an absorbing state, given the initial occupancy probability
vector ğ… (0) (a state is absorbing if it has no outgoing transitions). The MTTA can be computed
from the fundamental matrix N = (Iâˆ’Pğ‘¡ )âˆ’1, where Pğ‘¡ is the restriction of the transition matrix P to
transient states only, and I is a suitably sized square identity matrix. Given initial state occupancy
probabilities ğ… (0), the mean number of steps before entering any absorbing state is:

MTTA = ğ… (0) (1N) âŠº

Other metrics of interest include the ï¬rst passage time ğ‘€ğ‘–,ğ‘— , deï¬ned as the average number of
transitions before state ğ‘— is visited for the ï¬rst time, starting from state ğ‘–. Finally, the mean sojourn
time ğ¿ğ‘– (ğ‘›) is the expected number of visits to state ğ‘– during the ï¬rst ğ‘› transitions, for given initial
state occupancy probabilities; the ratio ğ¿ğ‘– (ğ‘›)/ğ‘› is called time-averaged mean sojourn time. All these
concepts can be easily deï¬ned for continuous-time Markov chains as well.

Birth-death processes are a subclass of Markov chains that are at the basis, among other things,
of the analysis of single-station queueing systems (see Section 4). In a (ğ‘ + 1)-states birth-death

6

Moreno Marzolla

Type

Description

Continuous

Discrete

dtmc()
dtmcbd()
dtmcexps()

ctmc()
ctmcbd()
ctmcexps()
ctmctaexps() dtmctaexps() Time-Averaged Mean Sojourn Tiems
ctmcfpt()
ctmcmtta()

Stationary/Transient state occupancy probabilities
Birth-Death process
Mean Sojourn Times

First Passage Times
Mean Time to Absorption

dtmcfpt()
dtmcmtta()

Table 2. Functions for Markov chains analysis

2ğ‘ğ›¾

2

2(1 âˆ’ ğ‘)ğ›¾

ğ‘…ğ¶

ğ›¿

ğ‘…ğµ

ğ›½

ğ›¼

(a)

1

ğ›¾

ğ›¿

0

2ğ‘ğ›¾

2

2(1 âˆ’ ğ‘)ğ›¾

ğ‘…ğ¶

ğ›¿

ğ‘…ğµ

ğ›½

ğ›¾

1

0

(b)

Fig. 2. Reliability Model for a dual-processor system (from [20])

process, the transition probability (resp. rate) from state ğ‘– to (ğ‘– + 1) is ğ‘ğ‘–, and the transition proba-
bility (resp. rate) from state (ğ‘– + 1) to ğ‘– is ğ‘‘ğ‘–, ğ‘– = 1, . . . , ğ‘ (Figure 1). Function P = dtmcbd(b, d)
returns a stochastic matrix P for a birth-death process with birth rates b = (ğ‘1, . . . , ğ‘ğ‘ ) and death
rates d = (ğ‘‘1, . . . , ğ‘‘ğ‘ ). Function Q = ctmcbd(b, d) does the same for the continuous case, with
the obvious diï¬€erence that b and d are birth and death rates instead of probabilities.

Table 2 lists the functions that compute the performance metrics described above for.

Example
Let us consider the reliability model of a multiprocessor system shown in Figure 2 and originally
described in [20]. The system consists of two processors, each subject to failures with Mean Time
To Failure (MTTF) 1/ğ›¾. States labeled ğ‘› âˆˆ {0, 1, 2} denote that there are ğ‘› working processors. If
one processor fails, it can be recovered (state RC) with probability ğ‘; recovery takes time 1/ğ›½. When
the system can not be recovered, a reboot is required (state RB) that brings down the entire system
for time 1/ğ›¼ > 1/ğ›½. The mean time to repair a failed processor is 1/ğ›¿. The system is operational
if there is at least one working processor.

The model above can be represented as a CTMC with ï¬ve states {2, ğ‘…ğ¶, ğ‘…ğµ, 1, 0}. The following
fragment of GNU Octave code deï¬nes the stochastic matrix Q of the CTMC in Figure 2(a), and the
uses the function ctmc() to compute the steady state occupancy probability vector p (parameter
values are taken from [20]):

mm = 60; hh = 60* mm ; dd = 24* hh ; yy = 365* dd ;
a = 1/(10* mm );
b = 1/30;
g = 1/(5000* hh );

# 1/ a = duration of reboot (10 min )
# 1/ b = reconfiguration time (30 sec )
# 1/ g = processor MTTF (5000 h )

A Software Package for Queueing Networks and Markov Chains analysis

7

d = 1/(4* hh );
c = 0.9;
#
Q = [ -2* g

2

RC

RB

2* c * g 2*(1 - c )* g

# 1/ d = processor MTTR (4 h )
# recovery probability

1
0
b
a
-( g+ d )
d

0
0;
0;
0;
g ;
-d ];

# 2
# RC
# RB
# 1
# 0

0
0
d
0

-b
0
0
0

0
-a
0
0

p = ctmc ( Q );

that is p = (9.9839 Ã— 10âˆ’1, 2.9952 Ã— 10âˆ’6, 6.6559 Ã— 10âˆ’6, 1.5974 Ã— 10âˆ’3, 1.2779 Ã— 10âˆ’6). From these
values we can derive several availability metrics; for example, the average time spent over one
year in states ğ‘…ğ¶, ğ‘…ğµ and 0 is:

p (2)* yy / mm
# => 1.5743
p (3)* yy / mm
# => 3.4984
p (5)* yy / mm
# => 0.67169

# minutes / year spent in RC

# minutes / year spent in RB

# minutes / year spent in 0

that is, over a year, the system is unavailable for about 1.57 minutes due to reconï¬gurations, 3.50
minutes due to reboots and 0.67 minutes due to failure of both processors.

The Mean Time Between Failures (MTBF) is the average duration of continuous system opera-
tion. We assume that the system starts in state 2, and we consider the system operational also when
in the reconï¬guration state. Therefore, the set of states that we consider operational is {2, 1, ğ‘…ğ¶}.
If we make states 0 and RB absorbing by removing all their outgoing transitions, the MTBF is the
mean time to absorption of the (modiï¬ed) CTMC:

Q (3 ,:) = Q (5 ,:) = 0;
p0 = [1 0 0 0 0];
MTBF = ctmcmtta (Q , p0 )/ yy # MTBF ( years )
# => 2.8376

# make states {0 , RB } absorbing
# initial state occupancy prob .

that yields a MTBF of approximately 2.84 years.

4 SINGLE-STATION QUEUEING SYSTEMS

A single-station queueing system, also called service center, consists of one or more servers con-
nected to a shared queue. An inï¬nite stream of requests (jobs) is generated outside the system and
put into the queue. Jobs are extracted according to some queueing policy (e.g., First-Come-First-
Served) and processed by one of the available servers. Once service completes, a job leaves the
system permanently.

The following information is required to fully describe a single-station queueing system: (i) the
nature of the arrival process; (ii) the distribution of service times; (iii) the number of servers;
(iv) the size of the queue; (v) the queueing discipline, i.e., the policy used by the server(s) to extract
requests from the queue.

Kendallâ€™s notation [22] can be used to specify of queueing system. It consists of ï¬ve symbols
ğ´/ğ‘†/ğ‘š/ğ¾/ğ·, where ğ´ denotes the type of arrival process, ğ‘† the service time distribution, ğ‘š â‰¥ 1
the number of servers, ğ¾ â‰¥ ğ‘š the maximum system capacity, and ğ· the queueing discipline.

8

Moreno Marzolla

Fig. 3. Graphical representation of some single-station queueing systems

Several types of arrival processes ğ´ and service time distributions ğ‘† have been studied in the lit-
erature, and assigned speciï¬c symbols: ğ‘€ (exponential distribution), ğ· (deterministic distribution),
ğº (general distribution), Hyperğ‘˜ (hyperexponential distribution with ğ‘˜ phases), and others.

Queueing disciplines include First-Come First-Served (FCFS), Last-Come-First-Served (LCFS),
Service In Random Order (SIRO), and Processor Sharing (PS). In the PS discipline all jobs are served
at the same time (i.e., there is no queue), that is equivalent to round-robin scheduling with inï¬nites-
imally small time slice.

A commonly used arrival process and service time distribution are the Poisson point process
and exponential distribution, respectively; both are denoted with the letter ğ‘€ in Kendallâ€™s notation.
Let ğ´(ğ‘¡) be the number of requests arriving at the queueing system during a time interval of
length ğ‘¡; ğ´(ğ‘¡) is a Poisson point process if the probability Pr{ğ´(ğ‘¡) = ğ‘›} that there are ğ‘› arrivals is:

Pr{ğ´(ğ‘¡) = ğ‘›} =

(ğœ†ğ‘¡)ğ‘›
ğ‘›!

ğ‘’âˆ’ğœ†ğ‘¡

where ğœ† > 0 is the expected number of arrivals for unit of time. It can be shown [24] that the
stochastic variable ğ‘‡ representing the time between two successive arrivals (interarrival time)
follows an exponential distribution with mean 1/ğœ†:

Pr{ğ‘‡ â‰¤ ğ‘¡ } = 1 âˆ’ ğ‘’âˆ’ğœ†ğ‘¡

The inter-arrival and service time distributions of a ğ‘€/ğ‘€/âˆ’ queue are therefore fully speciï¬ed
by the arrival rate ğœ† of requests and the throughput ğœ‡ of each server. ğ‘€/ğ‘€/âˆ’ systems have the
useful property that the Probability Mass Function (PMF) ğœ‹ğ‘˜ that there are ğ‘˜ â‰¥ 0 requests in the
system1 has a simple form allowing stationary performance measures to be expressed easily [7, 24].
Figure 3 shows a graphical representation of some of the single-station queueing system types
supported by the queueing package. ğ‘€/ğ‘€/ğ‘š systems have ğ‘š â‰¥ 1 identical servers, so that up to ğ‘š
requests can be serviced at the same time. Once a server becomes idle, it fetches the next request
from the queue (if any) and processes it. The system is stable, i.e., the average queue length is ï¬nite,
if ğœ† < ğ‘šğœ‡. Special cases of the ğ‘€/ğ‘€/ğ‘š system are the ğ‘€/ğ‘€/1 service center, where there is a single
server, and the ğ‘€/ğ‘€/âˆ center where there are inï¬nitely many identical servers, and therefore
requests do not need to wait before receiving service. ğ‘€/ğ‘€/âˆ stations are also called Inï¬nite

1We adopt the widely used convention of using the same symbol ğœ‹ğ‘˜ for both the state occupancy probability of a queueing
system and the state of a Markov chain

A Software Package for Queueing Networks and Markov Chains analysis

9

Function Description

ğ‘€/ğ‘€/1 system
ğ‘€/ğ‘€/ğ‘š system with ğ‘š identical servers

qsmm1()
qsmmm()
qsmminf() ğ‘€/ğ‘€/âˆ system (delay center)
qsmm1k() ğ‘€/ğ‘€/1/ğ¾ ï¬nite-capacity system
qsmmmk() ğ‘€/ğ‘€/ğ‘š/ğ¾ ï¬nite-capacity system (ğ¾ â‰¥ ğ‘š)
qsammm()
qsmh1()
qsmg1()

Asymmetric ğ‘€/ğ‘€/ğ‘š
ğ‘€/Hyperğ‘š/1 queue with hyper-exponential service time distribution
ğ‘€/ğº/1 queue with general service time distribution

Table 3. Supported single-station queueing systems

Server (IS) nodes or delay centers, since they essentially delay incoming requests by an average
duration 1/ğœ‡. IS nodes are always stable, irrespective of the arrival and service rates.

The ğ‘€/ğ‘€/ğ‘š/ğ¾ system is a ï¬nite-capacity variants of the ğ‘€/ğ‘€/ğ‘š queueing center. The param-
eter ğ¾ â‰¥ ğ‘š represents the maximum number of jobs in the system, including those being served;
therefore, there are (ğ¾ âˆ’ğ‘š) slots in the queue. Finite-capacity centers are always stable, since each
request that tries to join a full system is discarded.

Non-Markovian queues are used in some contexts, such as modeling of telecommunication net-
works. The asymmetric ğ‘€/ğ‘€/ğ‘š systems consists of ğ‘š exponential servers with possibly diï¬€erent
service rates ğ = (ğœ‡1, . . . , ğœ‡ğ‘š ). At most ğ‘š requests can be served concurrently; if multiple servers
are available, the next request receives service from a randomly chosen one. This system is stable
if ğœ† <
ğ‘–=1 ğœ‡ğ‘– . In the ğ‘€/Hyperğ‘š/1 system the server has ğ‘š diï¬€erent service rates ğ = (ğœ‡1, . . . , ğœ‡ğ‘š)
ğ‘š
ğ‘š
that are selected with probabilities ğœ¶ = (ğ›¼1, . . . , ğ›¼ğ‘š),
ğ‘–=1 ğ›¼ğ‘– = 1. Non-Markovian queueing sys-
tems are harder to analyze; the queueing package uses the approximation techniques described
in [24], where both asymmetric ğ‘€/ğ‘€/ğ‘š and ğ‘€/Hyperğ‘š/1 queues are treated as ğ‘€/ğº/1 systems.
Performance measures of single-station queueing systems include the following quantities:

Ã

Ã

ğ‘ˆ

ğ‘…

ğ‘„
ğ‘‹

Utilization: mean fraction of time the servers are busy. In general, ğ‘ˆ âˆˆ [0, 1]: for example, for
a stable ğ‘€/ğ‘€/ğ‘š system the utilization is ğ‘ˆ = ğœ†/(ğ‘šğœ‡). In the case of the ğ‘€/ğ‘€/âˆ system, ğ‘ˆ
is deï¬ned as the traï¬ƒc intensity ğ‘ˆ = ğœ†/ğœ‡ and can be also greater than one, since the system
is always stable.
Response time: average time spent by a request inside the system, i.e., the mean duration
of the interval between a request arrival in the queue and its departure after completing
service.
Mean queue length.
Throughput: average number of requests that complete service in a unit of time. If the system
is stable, then the throughput is equal to the arrival rate (ğ‘‹ = ğœ†).

The performance measures above can be derived from the steady-state probability ğœ‹ğ‘˜ , although
in most cases there are simpler closed-form expressions that do not require the explicit compu-
tation of ğœ‹ğ‘˜ . However, of particular interest is the probability ğœ‹0 that the system is empty, and
the rejection probability ğœ‹ğ¾ for a ï¬nite-capacity systems where at most ğ¾ jobs are allowed. The
queueing package can compute the value of ğœ‹ğ‘˜ for Markovian queues for any given ğ‘˜.

Table 3 lists the functions provided by the queueing package to analyze the supported types of
queueing systems. Note that ğ‘€/ğ‘€/1 and ğ‘€/ğ‘€/âˆ systems are handled separately from ğ‘€/ğ‘€/ğ‘š
queues, since simpler formulas for the special cases ğ‘š = 1 and ğ‘š = âˆ are used.

10

Moreno Marzolla

Example
Let us consider a ğ‘€/ğ‘€/ğ‘š center with arrival rate ğœ† and service rates ğœ‡. Assuming stability (ğœ† <
ğ‘šğœ‡), the steady state probability ğœ‹ğ‘˜,ğ‘€/ğ‘€/ğ‘š that there are ğ‘˜ â‰¥ 0 requests in the system is [7]:

ğœ‹0,ğ‘€/ğ‘€/ğ‘š

ğœ‹0,ğ‘€/ğ‘€/ğ‘š

(ğ‘šğœŒ)ğ‘˜
ğ‘˜!

ğœŒğ‘˜ğ‘šğ‘š
ğ‘š!

0 â‰¤ ğ‘˜ â‰¤ ğ‘š

ğ‘˜ > ğ‘š

(3)

ğœ‹ğ‘˜,ğ‘€/ğ‘€/ğ‘š = ï£±ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´

where ğœŒ = ğœ†/(ğ‘šğœ‡) is the individual server utilization, and the steady-state probability ğœ‹0,ğ‘€/ğ‘€/ğ‘š
that there are no requests in the system is:

ï£³

ğœ‹0,ğ‘€/ğ‘€/ğ‘š =

(ğ‘šğœŒ)ğ‘˜
ğ‘˜!

+

(ğ‘šğœŒ)ğ‘š
ğ‘š!

1
1 âˆ’ ğœŒ #

âˆ’1

ğ‘šâˆ’1

"

Ã•ğ‘˜=0

(4)

The limit of (3) as ğ‘š tends to inï¬nity is the steady state probability ğœ‹ğ‘˜,ğ‘€/ğ‘€/âˆ that there are ğ‘˜

request in a ğ‘€/ğ‘€/âˆ Inï¬nite Server node:

ğœ‹ğ‘˜,ğ‘€/ğ‘€/âˆ = lim
ğ‘šâ†’âˆ

ğœ‹ğ‘˜,ğ‘€/ğ‘€/ğ‘š = 1
ğ‘˜!

ğ‘˜

ğ‘’âˆ’ğœ†/ğœ‡

ğœ†
ğœ‡

(cid:18)

(cid:19)

The following fragment of GNU Octave code uses the functions qsmmm() and qsmminf() to
compute the steady state probability that there are ğ‘˜ requests in the system, ğ‘˜ = 0, . . . , 20, for an
ğ‘€/ğ‘€/4, ğ‘€/ğ‘€/5 and ğ‘€/ğ‘€/âˆ system.

lambda = 4; mu = 1.2; k = 0:20;
pi_mm4
pi_mm5
pi_mminf = qsmminf ( lambda , mu , k );

= qsmmm ( lambda , mu , 4, k );
= qsmmm ( lambda , mu , 5, k );

Note that qsmmm(), qsmmm() and qsmminf() like other functions in the queueing package, sup-
port vector arguments. In these cases a vector of results is returned. Also, the queueing package
relies on Hornerâ€™s rule

Ã•ğ‘˜=0
to evaluate the summation of Eq. (4) more accurately.

(cid:16)

(cid:16)

ğ‘›

ğ‘ğ‘˜
ğ‘˜!

= 1 + ğ‘

1 +

1 +

ğ‘
2

ğ‘
3

ğ‘
ğ‘›

Â· Â· Â·

1 +

(cid:16)

(cid:16)

Â· Â· Â·

(cid:17)

(cid:17)(cid:17) (cid:17)

Figure 4 shows that the marginal probabilities ğœ‹ğ‘˜,ğ‘€/ğ‘€/ğ‘š tend indeed to ğœ‹ğ‘˜,ğ‘€/ğ‘€/âˆ as the number

of servers ğ‘š grows.

5 QUEUEING NETWORKS
A QN consists of ğ¾ â‰¥ 1 service centers (nodes) and a population of requests (jobs) that visit the
servers in some order. Several types of QNs have been studied, depending on the type of population
of requests. In open networks there is an inï¬nite stream of jobs that originate outside the system
and eventually leave the system forever (Figure 5a). In closed networks there is a ï¬xed population
of jobs that never leave the system (Figure 5b). Requests can be all of the same type (single-class
networks) or of multiple types (multiclass models). In a multiclass QN, diï¬€erent types of requests
can visit the service centers in a diï¬€erent order or have diï¬€erent service demands (the service
demand is the average time spent by requests on a given node, see below). In mixed networks,
open and closed classes of requests can coexist (Figure 5c).

A Software Package for Queueing Networks and Markov Chains analysis

11

PMF of M/M/âˆ and M/M/m systems, Î» = 4, Âµ = 1.2

k

Ï€

0.25

0.2

0.15

0.1

0.05

0

0

M/M/âˆ
M/M/5
M/M/4

5

10
N. of requests (k)

15

20

Fig. 4. Probability ğœ‹ğ‘˜ that there are ğ‘˜ requests in a ğ‘€/ğ‘€/4, ğ‘€/ğ‘€/5 and ğ‘€/ğ‘€/âˆ system with arrival rate
ğœ† = 4req/ğ‘  and service rates ğœ‡ = 1.2req/ğ‘ .

Fig. 5. Three types of queueing networks: (a) Closed network; (b) Open network; (c) Mixed network.

QN analysis consists of computing steady-state performance measures such as throughput or
average queue length of the service centers. These measures can be derived from the equilibrium
state probability Pr(S) that the system is in state S for each valid state, where the exact nature
of S is model-dependent.

12

Moreno Marzolla

Some classes of QNs enjoy product-form solution, meaning that Pr(S) has the relatively simple

form

Pr(S) =

1
ğº (S)

ğ¾

ğ‘‘ (S)

ğ‘“ğ‘– (ğ‘¥ğ‘–)

(5)

Ã–ğ‘–=1

where ğ‘¥ğ‘– is the conï¬guration of the ğ‘–-th service center, ğ‘“ğ‘– is a function that depends on the type
of service center, ğ‘‘ (S) is a model-dependent function of the global state, and ğº is a normalization
constant. A QN with product-form solution can be analyzed eï¬ƒciently by considering each node
in isolation and combining the partial results.

The ï¬rst class of product-form open networks was identiï¬ed by Jackson [21]. Later, Gordon and
Newell extended product-form solution to certain classes of closed networks [18]. These results
were further extended by Baskett, Chandy, Muntz and Palacios [5] to include open, closed and
mixed networks with multiple customer classes (since then known as BCMP networks). Other
types of networks have been shown to possess product-form solution; the interested reader is
referred to [2] for a review.

The queueing package supports a subset of BCMP networks that satisfy the following con-

straints:

â€¢ The network can consist of open or closed job classes (or both).
â€¢ The following queueing disciplines are allowed: FCFS, PS, Last-Came First-Served, Preemp-

tive Resume (LCFS-PR) and IS.

â€¢ Service times for FCFS nodes are exponentially distributed and class-independent. For PS,

LCFS-PR and IS nodes, diï¬€erent classes of customers can have diï¬€erent service times.

â€¢ The service rate of a FCFS node can depend on the number of jobs at this node (load-

dependent service centers).

â€¢ In open networks two kinds of arrival processes are allowed: (i) Poisson arrival process with
arrival rate ğœ†. (ii) ğ¶ independent Poisson arrival streams where the ğ¶ job sources are assigned
to the ğ¶ chains.

The constraints above allow a considerable simpliï¬cation of the algorithms implemented, and

at the same time include the types of networks that are most frequently used in practice.

Table 4 lists the main functions for QN analysis provided by the queueing package; more details

are provided in the rest of this section.

Single-class models. In single class models, service centers do not diï¬€erentiate the requests that
they process. This means that, for example, the mean time spent by a request in a given server
(service time) will depend only on the server, not on the type of request.
A single-class QN can be fully speciï¬ed by the following parameters:

ğ¾
ğœ†ğ‘–
ğ‘
ğ‘

ğ‘†ğ‘–

ğ‘ƒğ‘–,ğ‘—

Number of service centers.
(Open networks only) External arrival rate to center ğ‘– âˆˆ {1, . . . , ğ¾ }.
(Closed networks only) Total number of requests in the system.
(Closed networks only) Optional external delay (â€œthink timeâ€) spent by each request outside
the system after each interaction.
Mean service time at any server inside center ğ‘– for each visit (not including the time spent
waiting in the queue). For general load-dependent service centers, the service time is a vector
where ğ‘†ğ‘– (ğ‘›) is the service time when there are ğ‘› requests in center ğ‘–
Probability that a request completing service at center ğ‘– is routed to center ğ‘— . For open net-
works, the probability that a request leaves the system after completing service at center ğ‘–
is

1 âˆ’

.

ğ¾
ğ‘—=1 ğ‘ƒğ‘–,ğ‘—

(cid:16)

Ã

(cid:17)

A Software Package for Queueing Networks and Markov Chains analysis

13

Number of classes

Description

Multiple

qncmaba()
qnomaba()

qncmbsb()

qncmcb()
qnom()

Single

qncsaba()
qnosaba()
qncsbsb()
qnosbsb()
qncsgb()

qnos()
qncsconv()
qncsconvld()

qncsmva()

qncmmva()

qncsmvald()
qncscmva()

qncmmvabs()

qnmix()

qncsmvablo()
qn?svisits()

Asymptotic Bounds for closed Networks [15]
Asymptotic Bounds for open networks [15]
Balanced System Bounds for closed networks [36]
Balanced System Bounds for open networks [36]
Geometric Bounds [13]
Composite Bound Method [23]
Analysis of Jackson networks [21] and their multiclass extension
Convolution algorithm for closed networks with ï¬xed-rate servers [8]
Convolution algorithm for closed networks with load dependent
servers [8]
MVA for closed networks with ï¬xed-rate and multiple server nodes [31,
34]
MVA for closed networks with load dependent servers [31]
Conditional MVA for closed networks with a load dependent
server [10]
Bard and Schweitzerâ€™s MVA approximation for closed networks with
ï¬xed-rate servers [4, 32]
MVA for multiclass networks with both open and closed chains and
ï¬xed-rate servers [34]
Approximate MVA for closed networks with blocking [1]

qn?mvisits() Compute visit ratios from the routing matrix (? can be c or o)

Table 4. Main functions for QN analysis

ğ‘‰ğ‘–

Mean number of visits to center ğ‘– (also called visit ratio or relative arrival rate).
For open, single class networks the visit ratios ğ‘‰ğ‘– satisfy the following equations:

ğ¾

ğ‘‰ğ‘– = ğ‘ƒ0,ğ‘– +

ğ‘‰ğ‘—ğ‘ƒ ğ‘—,ğ‘–

ğ‘– = 1, . . . , ğ¾

Ã•ğ‘—=1

(6)

where ğ‘ƒ0,ğ‘– is the probability that an external request goes to center ğ‘–. If we denote with ğœ†ğ‘– the
ğ‘– ğœ†ğ‘– is the overall external arrival rate, then ğ‘ƒ0,ğ‘– = ğœ†ğ‘– /ğœ†.
external arrival rate to center ğ‘–, and ğœ† =

For closed networks, the visit ratios satisfy the following equation:

Ã

ğ¾
ğ‘—=1 ğ‘‰ğ‘—ğ‘ƒ ğ‘—,ğ‘–

ğ‘‰ğ‘– =
ğ‘‰ğ‘Ÿ = 1
(
Ã

ğ‘– = 1, . . . , ğ¾, ğ‘– â‰  ğ‘Ÿ
for a selected reference station ğ‘Ÿ âˆˆ {1, . . . , ğ¾ }

(7)

The second condition ensures that the values ğ‘‰ğ‘– are uniquely deï¬ned. A job that returns to the
reference station (default ğ‘Ÿ = 1) is assumed to have completed one interaction with the system. The
product ğ·ğ‘– = ğ‘†ğ‘–ğ‘‰ğ‘– of the average service time per visit ğ‘†ğ‘– and the mean number of visits ğ‘‰ğ‘– is called
service demand, and can be understood as the total service time requested by a job during one
interaction with the system. The service center with the larger service demand is the bottleneck
of the system.

Most of the algorithms in the queueing package rely on the visit ratios ğ‘‰ğ‘–; if only the routing
matrix P is available, functions qnosvisits() and qncsvisits() can be used to compute the ğ‘‰ğ‘–
using Eq. (6) or (7), respectively.

The following performance results for single-class models are computed:

14

Moreno Marzolla

Algorithm 1 MVA algorithm without load-dependent service centers
Require: ğ¾, ğ‘ , ğ‘, ğ‘†ğ‘–, ğ‘‰ğ‘–, ğ‘– = 1, . . . , ğ¾
Ensure: ğ‘„ğ‘–, ğ‘…ğ‘–, ğ‘ˆğ‘–, ğ‘‹ğ‘–
for ğ‘– â† 1, . . . , ğ¾ do

ğ‘„ğ‘– â† 0

for ğ‘› â† 1, . . . , ğ‘ do

for ğ‘– â† 1, . . . , ğ¾ do

ğ‘†ğ‘–
ğ‘†ğ‘– (1 + ğ‘„ğ‘–)
(

if center ğ‘– is ğ‘€/ğ‘€/âˆ
if center ğ‘– is ğ‘€/ğ‘€/1

ğ‘…ğ‘– â†

ğ‘€

ğ‘… â†

ğ‘…ğ‘–ğ‘‰ğ‘–

Ã•ğ‘–=1
ğ‘›
ğ‘ + ğ‘…

ğ‘‹ =
for ğ‘– â† 1, . . . , ğ¾ do
ğ‘„ğ‘– â† ğ‘‹ğ‘‰ğ‘–ğ‘…ğ‘–
for ğ‘– â† 1, . . . , ğ¾ do
ğ‘‹ğ‘– â† ğ‘‹ğ‘‰ğ‘–
ğ‘ˆğ‘– â† ğ‘‹ğ‘‰ğ‘–ğ‘†ğ‘–

ğ‘ˆğ‘–
ğ‘…ğ‘–
ğ‘„ğ‘–
ğ‘‹ğ‘–

ğ‘‹
ğ‘…
ğ‘„

Utilization of service center ğ‘–;
Response time of service center ğ‘–;
Average number of requests at center ğ‘–, including the request(s) being served;
Throughput of service center ğ‘–;

From the values above, global performance measures can be derived:

System throughput, ğ‘‹ = ğ‘‹ğ‘– /ğ‘‰ğ‘– for any ğ‘– for which ğ‘‰ğ‘– > 0;
ğ¾
System response time, ğ‘… =
ğ‘–=1 ğ‘…ğ‘–ğ‘‰ğ‘–;
Average number of requests in the system, ğ‘„ =

ğ¾
ğ‘–=1 ğ‘„ğ‘–

Ã

The MVA [31] and convolution [8] algorithms are the most widely used techniques to compute
stationary performance measures of closed product-form networks. The convolution algorithm
computes the normalization constant ğº in Eq. (5); all other performance measures are derived
from ğº. MVA relies on the fact that, in a closed network with ğ‘ requests, the response time ğ‘…ğ‘– (ğ‘ )
of center ğ‘– can be expressed as [31]

Ã

ğ‘…ğ‘– (ğ‘ ) = ğ‘†ğ‘– (1 + ğ‘„ğ‘– (ğ‘ âˆ’ 1))

(8)

where ğ‘„ğ‘– (ğ‘ âˆ’ 1) is the mean queue length at center ğ‘– if one request is removed from the system.
In the case of a single-class network with ğ‘€/ğ‘€/1 center or ğ‘€/ğ‘€/âˆ IS nodes only, MVA assumes
the simple form shown in Algorithm 1.

A single-class closed networks with ğ‘ requests and ğ¾ service centers of type ğ‘€/ğ‘€/1 or ğ‘€/ğ‘€/âˆ
can be analyzed in time ğ‘‚ (ğ‘ ğ¾) by either the MVA or the convolution algorithms. Unfortunately,
if multiple-server nodes or general load-dependent service centers are present, both algorithms
suï¬€er from numerical instabilities. In the case of MVA, Eq. (8) is no longer suï¬ƒcient to compute
the response time at center ğ‘–, since adding a new request may alter the (load dependent) service
time ğ‘†ğ‘–. It is therefore necessary to compute the marginal probabilities ğ‘ğ‘– ( ğ‘— |ğ‘›) that there are ğ‘—
requests at center ğ‘–, given that the total number of requests in the system is ğ‘›. At the end of each

A Software Package for Queueing Networks and Markov Chains analysis

iteration, the MVA algorithm computes the probability ğ‘ğ‘– (0|ğ‘›) that center ğ‘– is idle as

ğ‘›

ğ‘ğ‘– (0|ğ‘›) = 1 âˆ’

ğ‘ğ‘– ( ğ‘— |ğ‘›)

15

(9)

Ã•ğ‘—=1
Eq. (9) is the source of numerical errors [30], especially if there are many requests (ğ‘› is large)

and/or there are servers whose utilization is close to 1.

So far, no numerically stable variant of the MVA and convolution algorithms exist, although sta-
ble approximations have been proposed [37]. The queueing package provides an implementation
of the Conditional MVA (CMVA) algorithm [10], a numerically stable variant of MVA. Unfortu-
nately, CMVA only supports a single load-dependent service center, and is therefore less general
than MVA.

Multiple-class models. The MVA and convolution algorithms can be extended to handle QNs
with multiple job classes. In a multiclass QN there are ğ¶ customer classes; open and closed classes
of requests may be present at the same time. Since a request may change class after service com-
pletion, the concept of chain needs to be introduced. Chains induce a partition of the set of classes:
class ğ‘1 and ğ‘2 belong to the same chain if a job of class ğ‘1 can eventually become a job of class ğ‘2.
A chain can contain multiple classes, but can not contain both an open and a closed class. This
prevents jobs from closed classes to enter open classes, or the other way around

A multiclass network can be described using the same parameters as those used for single class

models, with additional subscripts required to take classes into account:
ğœ†ğ‘,ğ‘–
ğ‘ğ‘
ğ‘ğ‘

(Open networks only) External arrival rate of class ğ‘ requests to service center ğ‘–.
(Closed networks only) Total number of class ğ‘ requests in the system.
(Closed networks only) External delay (also called â€œthink timeâ€) spent by each class ğ‘
request outside the system after one round of interaction with the service centers is com-
pletes. See below.
Mean service time of class ğ‘ requests at center ğ‘–; product-form requires that service times
at FCFS queues be class-independent, while service times at IS or PS nodes can vary on a
per-class basis.
Probability that a class ğ‘Ÿ request that completes service at center ğ‘– is routed to class ğ‘— as a
class ğ‘  request.
Mean number of visits of class ğ‘ requests to center ğ‘–.

ğ‘†ğ‘.ğ‘–

ğ‘ƒğ‘Ÿ,ğ‘–,ğ‘ ,ğ‘—

ğ‘‰ğ‘,ğ‘–

Similarly, performance results (utilization, response times, and so on) are computed for each

service center and class, e.g., ğ‘‹ğ‘,ğ‘– denotes the throughput of class ğ‘ requests at center ğ‘–.

The queueing package analyzes product-form multiclass closed networks are using the multi-
class MVA algorithm. Let N = (ğ‘1, . . . , ğ‘ğ¶ ) be the population vector, i.e., the vector where ğ‘ğ‘ is
the number of class ğ‘ requests in the system, ğ‘ = 1, . . . , ğ¶. Let 1ğ‘ be the vector of length ğ¶ where
the ğ‘-th element is one and all other elements are zero. For closed networks with only ï¬xed-rate
(ğ‘€/ğ‘€/1) and IS (ğ‘€/ğ‘€/âˆ) nodes, the BCMP theorem [5] states that the response time ğ‘…ğ‘,ğ‘– (N) of
class ğ‘ requests at center ğ‘– is:

ğ‘…ğ‘,ğ‘– (N) = ğ‘†ğ‘,ğ‘– (1 + ğ‘„ğ‘– (N âˆ’ 1ğ‘))
where ğ‘„ğ‘– (N âˆ’ 1ğ‘) is the mean queue length at center ğ‘– with one class ğ‘ customer removed (if ğ‘›ğ‘ = 0
we let ğ‘„ğ‘– (N âˆ’ 1ğ‘ ) = 0). Eq. (10) is similar to (8), and is the core of the multiclass MVA Algorithm
shown in 2.

(10)

Multiclass MVA allows all performance measures to be computed starting from the queue lengths ğ‘„ğ‘– (0) =

0 of the network with no jobs. Speciï¬cally, Algorithm 2 computes the mean response time ğ‘…ğ‘,ğ‘– of

16

Moreno Marzolla

Algorithm 2 Multiclass MVA without load-dependent service centers
Require: ğ¾, ğ¶, ğ‘ğ‘, ğ‘ğ‘, ğ‘†ğ‘,ğ‘–, ğ‘‰ğ‘,ğ‘–, ğ‘ = 1, . . . , ğ¶, ğ‘– = 1, . . . , ğ¾
Ensure: ğ‘„ğ‘–, ğ‘…ğ‘,ğ‘–, ğ‘‹ğ‘

for ğ‘– â† 1, . . . , ğ¾ do
ğ‘„ğ‘– (0) â† 0
for ğ‘› â† 1, . . . ,

ğ¶
ğ‘=1 ğ‘ğ‘ do

Ã
for ğ‘ â† 1, . . . , ğ¶ do

for each feasible population n = (ğ‘›1, . . . , ğ‘›ğ¶ ) with ğ‘› total requests do

for ğ‘– â† 1, . . . , ğ¾ do

ğ‘…ğ‘,ğ‘– â†

ğ‘†ğ‘,ğ‘–
ğ‘†ğ‘,ğ‘– (1 + ğ‘„ğ‘– (n âˆ’ 1ğ‘))
(

if center ğ‘– is ğ‘€/ğ‘€/âˆ
if center ğ‘– is ğ‘€/ğ‘€/1

for ğ‘ â† 1, . . . , ğ¶ do

ğ‘‹ğ‘ =

ğ‘ğ‘ +

ğ‘›ğ‘
ğ¾
ğ‘–=1 ğ‘‰ğ‘,ğ‘–ğ‘…ğ‘,ğ‘–

for ğ‘– â† 1, . . . , ğ¾ do

Ã
ğ¶

ğ‘„ğ‘– (n) â†

ğ‘‹ğ‘ğ‘‰ğ‘,ğ‘–ğ‘…ğ‘,ğ‘–

Ã•ğ‘=1

class ğ‘ requests at center ğ‘–, the mean queue length ğ‘„ğ‘– (N) at center ğ‘–, and the global throughput ğ‘‹ğ‘
of class ğ‘ requests. The other performance measures can be derived easily [7, 25]:

ğ‘‹ğ‘,ğ‘– = ğ‘‹ğ‘ğ‘‰ğ‘,ğ‘–
ğ‘ˆğ‘,ğ‘– = ğ‘‹ğ‘ğ‘†ğ‘,ğ‘–ğ‘‰ğ‘,ğ‘–
ğ‘„ğ‘,ğ‘– = ğ‘‹ğ‘ğ‘…ğ‘,ğ‘–

class ğ‘ throughput at center ğ‘–

class ğ‘ utilization at center ğ‘–

mean number of class ğ‘ requests at center ğ‘–

(11)

(12)

(13)

The multiclass MVA algorithm generates all feasible populations n = (ğ‘›1, . . . , ğ‘›ğ¶ ); we say that n
is feasible with respect to the population vector N = (ğ‘1, . . . , ğ‘ğ¶ ) if 0 â‰¤ ğ‘›ğ‘ â‰¤ ğ‘ğ‘ for all ğ‘ = 1, . . . , ğ¶.
ğ¶
ğ‘=1 (ğ‘ğ‘ + 1) feasible population vectors; therefore, for a closed,
It can be easily seen that there are
multiclass network with ğ¾ ï¬xed-rate or IS nodes, ğ¶ customer classes and population vector N,
multiclass MVA requires time ğ‘‚

and space ğ‘‚

Ã
ğ¶ğ¾

ğ¾

.

ğ¶
ğ‘=1 (ğ‘ğ‘ + 1)

ğ¶
ğ‘=1 (ğ‘ğ‘ + 1)

(cid:16)

(cid:16)

Ã

Ã

Due to its computational cost, multiclass MVA is appropriate for networks with small popu-
(cid:17)
lation and limited number of classes. For larger networks, approximations based on the MVA
have been proposed in the literature. The queueing package provides an implementation of Bard
and Schweitzerâ€™s iterative approximation scheme [4, 25, 32] through function qncmmvabs(). Bard-
Scweitzer approximation requires space ğ‘‚ (ğ¶ğ¾), that compares favorably with that of standard
multiclass MVA. Being an iterative scheme that stops as soon as a convergence criterion is met,
the execution time of Bard-Scweitzer approximation depends on the network being analyzed, but
is generally much lower than multiclass MVA (see the example at the end of this section). Unfortu-
nately, the drawback is that there is no known way to estimate the accuracy of the results provided
by the Bard-Scweitzer algorithm.

(cid:17)

Bound analysis. In situations where accurate computation of performance measures is imprac-
tical, bound analysis can be used to provide upper/lower limits on the system throughput ğ‘‹ and
response time ğ‘…. Performance bounds on QNs can be computed quickly, and are useful for exam-
ple in scenarios involving on-line performance tuning of systems [26â€“28]. The queueing package

A Software Package for Queueing Networks and Markov Chains analysis

17

allows the computation of several classes of bounds: Asymptotic Bounds (AB), Balanced System
Bounds (BSB), Composite Bounds (CB) and Geometric Bounds (GB).

Asymptotic Bounds [15] rely on the simplifying assumption that the service demand of a request
at a service center is independent from the number of requests in the system and their exact
location. Under this assumption (that is not true in general) it is possible to bound the systemâ€™s
performance by considering the extreme situations of lowest and highest possible loads. ABs for a
single-class network with ğ¾ service centers can be computed in time ğ‘‚ (ğ¾); for multiclass networks
with ğ¶ customer classes, the computational complexity is ğ‘‚ (ğ¶ğ¾).

Balanced System Bounds [36] provide tighter bounds that are computed by forcing the service
demands of the network under consideration to be all the same. BSB have the same computational
complexity as AB, both for single and multiclass models. Composite Bounds [23] and Geometric
Bounds [13] are yet diï¬€erent bounding techniques that, in many cases, produce even better bounds
with the same computational cost.

Queueing networks with blocking. The queueing package provides limited support for analyzing
closed, single-class networks with blocking. In blocking networks, queues have a ï¬nite capacity: a
request joining a full queue will block until one slot becomes available. Apart from very few excep-
tions, queueing networks with blocking do not satisfy the conditions for product-form solution [3],
and are therefore diï¬ƒcult to analyze.

The qncsmvablo() function implements the MVABLO algorithm [1] that is based on an ex-
tension of MVA. MVABLO provides approximate performance measures for closed, single-class
networks with Blocking After Service (BAS) blocking. According to the BAS discipline, a request
completing service at center ğ‘– that wants to move to center ğ‘— blocks the source server ğ‘– until one
slot is available at the destination.

Networks with a diï¬€erent type of blocking are handled by the qnmarkov() function. This func-
tion supports single-class, open or closed networks where all queues have (possibly diï¬€erent) ï¬nite
capacity. The blocking discipline is Repetitive Service with Random Destination (RS-RD): when a
request terminates service at center ğ‘– and wants to move to a saturated center ğ‘— , the request is
put back in the queue of center ğ‘– so that it will eventually receive another round of service from ğ‘–.
Each time the request completes a new round of service, it is routed to a possibly diï¬€erent, ran-
domly chosen server. In the case of open networks, external arrivals to a saturated servers are
discarded. The qnmarkov() function computes performance measures by building and analyzing
the underlying Markov chain; this makes the function unsuited for even moderate networks due
to the combinatorial explosion of the size of the Markov chain.

Example
We now demonstrate the use of the queueing package for analyzing the closed multiclass network
shown in Figure 6, that represents a simple model of a scientiï¬c compute farm. The system has
three classes of jobs that process data stored on disk servers; occasionally, data must be retrieved
from tape libraries and copied to the disk servers. Each job spends some amount of time on CPU-
intensive computations and then accesses data on external storage. Data resides on three tape
libraries (nodes 1â€“3). Four disk servers (nodes 4â€“7) act as a cache for data copied from the tape
libraries. Tape libraries and disk servers are modeled as ğ‘€/ğ‘€/1 service centers. We assume that
the number of CPU cores is not a limiting factor, i.e., each job starting a CPU burst always ï¬nds
a CPU core available. Therefore, the CPU farm can be represented as an IS node (ğ‘€/ğ‘€/âˆ center).
In the model of Figure 6, the IS node represents the â€œthink timeâ€ of jobs, a term that originated
from batch systems where IS nodes were the terminals where users spend some time â€œthinkingâ€
before submitting new commands to the system.

18

Moreno Marzolla

Fig. 6. Multiclass closed network model of a scientific compute farm.

Param Description Class 1 Class 2 Class 3

ğ·ğ‘,1
ğ·ğ‘,2
ğ·ğ‘,3
ğ·ğ‘,4
ğ·ğ‘,5
ğ·ğ‘,6
ğ·ğ‘,7
ğ‘ğ‘

Tape Server
Tape Server
Tape Server
Disk Server
Disk Server
Disk Server
Disk Server
Cpu farm

100
140
200
30
50
20
10
2400

180
10
70
10
90
130
30
1800

280
160
150
90
20
50
18
2100

Table 5. Parameters for the model in Figure 6

Let ğ‘ be the total number of jobs. We denote with ğœ· = (ğ›½1, ğ›½2, ğ›½3) the population mix of the
network, where ğ›½ğ‘ is the fraction of class ğ‘ jobs, 0 â‰¤ ğ›½ğ‘ â‰¤ 1 and ğ›½1 + ğ›½2 + ğ›½3 = 1. Thus, the number
of class ğ‘ jobs is ğ‘ğ‘ = ğ›½ğ‘ ğ‘ rounded to the nearest integer. Let ğ·ğ‘,ğ‘– be the service demand of class ğ‘
requests at center ğ‘– (recall that the service demand is the product of the mean service time and the
number of visits, ğ·ğ‘,ğ‘– = ğ‘†ğ‘,ğ‘–ğ‘‰ğ‘,ğ‘– ). Let ğ‘ğ‘ be the average duration of a CPU burst of a class ğ‘ job. The
parameter values are shown on Table 5.

We consider ğ‘ = 300 jobs, and we want to study how diï¬€erent population mixes ğœ· aï¬€ect the
system throughput ğ‘‹ . For example, the following GNU Octave code computes the per-class utiliza-
tions ğ‘ˆğ‘,ğ‘– , response times ğ‘…ğ‘,ğ‘– , mean queue lengths ğ‘„ğ‘,ğ‘– and throughput ğ‘‹ğ‘,ğ‘– when ğœ· = (0.2, 0.3, 0.5):
N = 300;
S = [100 140 200
180
70
10
280 160 150
Z = [2400 1800 2100];
V = ones ( size ( S ));
m = ones (1 , columns (S ));
beta = [0.2 , 0.3 , 0.5];

# mean duration CPU bursts
# n. of visits
# n. of servers in nodes
# population mix

10; # service demands
30;
18];

50
20
90 130
50
20

# total n. of jobs

30
10
90

A Software Package for Queueing Networks and Markov Chains analysis

19

System throughput

1

Î²

0.2

0.4

0.6

0.8

0.007

0.0065

0.006

0.0055

0.005

0.0045

0.2

0.4

0.6

0.8

Î²2

Fig. 7. Approximate system throughput as a function of the population mix ğœ· = (ğ›½1, ğ›½2, 1 âˆ’ ğ›½1 âˆ’ ğ›½2); the
values have been computed using Bard-Schweitzer approximation. Contour lines show the regions of equal
throughput. Irregularities towards the center are caused by rounding the population to the nearest integer.
(Best viewed in color)

pop = round ( N* beta ); pop (3) = N - pop (1) - pop (2);
[U R Q X ] = qncmmva ( pop , S , V , m , Z );
X_sys = sum ( X (: ,1) ./ V (: ,1));

# System throughput

Note that qncmmva() expects as parameters the mean service times ğ‘†ğ‘,ğ‘– and the mean number

of visits ğ‘‰ğ‘,ğ‘– . Since we know the service demands, we let ğ‘†ğ‘,ğ‘– = ğ·ğ‘,ğ‘– and set all visits to one.

The system throughput of a multiclass network is ğ‘‹sys =

ğ‘ ğ‘‹ğ‘, where ğ‘‹ğ‘ is the class ğ‘ through-
put. The values of ğ‘‹ğ‘ can be computed from the individual servers throughput ğ‘‹ğ‘,ğ‘– that are returned
by qncmmva(), using Eq. (11) with ğ‘– = 1 (actually, any valid value for ğ‘– will do). In the example
above we get ğ‘‹sys = 0.0053793.

Ã

Even on such a small network, qncmmva() requires about 170ğ‘  of CPU time on an Intel i7-4790
CPU at 3.60GHz running Ubuntu Linux 18.04 with GNU Octave 5.1; this makes the multiclass MVA
algorithm impractical for this type of study, since analyzing many population mixes would require
a prohibitive amount of time. We therefore resort to the much faster Bard-Scweitzer approximation,
realized by function qncmmvabs().

Figure 7 shows the system throughput ğ‘‹ for (50 Ã—50)/2 diï¬€erent population mixes. Each square
corresponds to a combinations of ğ›½1, ğ›½2, from which ğ›½3 = ğ‘ âˆ’ ğ›½1 âˆ’ ğ›½2. Contour lines show the
regions of the parameter space of equal throughput; the population mixes that result in the optimal
throughput are those towards the center of the image.

The whole Figure 7 can be computed in about 5ğ‘  using qncmmvabs() on the same system above,
i.e., orders of magnitude faster than the time that would be required by the multiclass MVA imple-
mentation from function qncmmva().

20

Moreno Marzolla

6 CONCLUSIONS
In this paper we described the queueing package, a GNU Octave package for QNs and Markov
chains analysis. The queueing package includes functions for transient and stationary analysis of
discrete and continuous Markov Chains, and for stationary analysis of single-station queueing sys-
tems and product-form QNs. The queueing package can handle open, closed and mixed QNs with
one or multiple classes of requests. Exact and approximate performance metrics can be obtained,
as well as diï¬€erent types of bounds.

Research on eï¬ƒcient solution techniques for QN models is still an active topic. The queueing
package will therefore be extended to include some of the newer algorithms. Furthermore, we plan
to include support for more types of non product-form networks.

The latest version of the queueing package is available at https://octave.sourceforge.io/queueing/
and can be used, modiï¬ed and distributed under the terms of the GNU General Public License (GPL)
version 3 or later.

REFERENCES
[1] Ian F. Akyildiz. 1988. Mean Value Analysis for Blocking Queueing Networks. IEEE Transactions on Software Engineer-

ing 1, 2 (April 1988), 418â€“428. https://doi.org/10.1109/32.4663
[2] Simonetta Balsamo. 2000. Product Form Queueing Networks.

In Performance Evaluation: Origins and Directions,
GÃ¼nter Haring, Christoph Lindemann, and Martin Reiser (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 377â€“
401. https://doi.org/10.1007/3-540-46506-5_16

[3] S. Balsamo, V. De Nitto PersonÃ©, and R. Onvural. 2001. Analysis of Queueing Networks with Blocking. Kluwer Academic

Publishers.

[4] Yonathan Bard. 1979. Some Extensions to Multiclass Queueing Network Analysis. In Proceedings of the Third Interna-
tional Symposium on Modelling and Performance Evaluation of Computer Systems: Performance of Computer Systems.
North-Holland Publishing Co., Amsterdam, The Netherlands, The Netherlands, 51â€“62.

[5] Forest Baskett, K. Mani Chandy, Richard R. Muntz, and Fernando G. Palacios. 1975. Open, Closed, and Mixed Networks
of Queues with Diï¬€erent Classes of Customers. J. ACM 22, 2 (1975), 248â€“260. https://doi.org/10.1145/321879.321887
[6] Marco Bertoli, Giuliano Casale, and Giuseppe Serazzi. 2009. JMT: performance engineering tools for system modeling.

SIGMETRICS Performance Evaluation Review 36, 4 (2009), 10â€“15. https://doi.org/10.1145/1530873.1530877

[7] Gunter Bolch, Stefan Greiner, Hermann de Meer, and Kishor S. Trivedi. 1998. Queueing Networks and Markov Chains:

Modeling and Performance Evaluation with Computer Science Applications. Wiley.

[8] Jeï¬€rey P. Buzen. 1973. Computational Algorithms for Closed Queueing Networks with Exponential Servers. Commun.

ACM 16, 9 (Sept. 1973), 527â€“531. https://doi.org/10.1145/362342.362345
of

Canadilla.

queueing:

Analysis

2019.

[9] Pedro

Queueing

Networks

and

Models.

https://CRAN.R-project.org/package=queueing R package version 0.2.12.

[10] Giuliano Casale. 2008. A note on stable ï¬‚ow-equivalent aggregation in closed networks. Queueing Syst. Theory Appl.

60 (Dec. 2008), 193â€“202. Issue 3-4. https://doi.org/10.1007/s11134-008-9093-6

[11] Giuliano Casale. 2019. Automated Multi-paradigm Analysis of Extended and Layered Queueing Models with LINE.
In Companion of the 2019 ACM/SPEC International Conference on Performance Engineering (Mumbai, India) (ICPE â€™19).
ACM, New York, NY, USA, 37â€“38. https://doi.org/10.1145/3302541.3311959

[12] Giuliano Casale, Marco Gribaudo, and Giuseppe Serazzi. 2011. Tools for Performance Evaluation of Computer Sys-
tems: Historical Evolution and Perspectives.
In Performance Evaluation of Computer and Communication Systems.
Milestones and Future Challenges: IFIP WG 6.3/7.3 International Workshop, PERFORM 2010, in Honor of GÃ¼nter Haring
on the Occasion of His Emeritus Celebration, Vienna, Austria, October 14-16, 2010, Revised Selected Papers, Karin Anna
Hummel, Helmut Hlavacs, and Wilfried Gansterer (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 24â€“37.
https://doi.org/10.1007/978-3-642-25575-5_3

[13] Giuliano Casale, R. R. Muntz, and Giuseppe Serazzi. 2008. Geometric Bounds: a Non-Iterative Analysis Technique for
Closed Queueing Networks. IEEE Trans. Comput. 57, 6 (June 2008), 780â€“794. https://doi.org/10.1109/TC.2008.37

[14] Robert K. Chassell

and Richard M. Stallman.
https://www.gnu.org/software/texinfo/manual/texinfo/ Accessed on 2013-03-13.

2019.

Texinfo: The GNU Documentation Format.

[15] Peter J. Denning and Jeï¬€rey P. Buzen. 1978. The Operational Analysis of Queueing Network Models. Comput. Surveys

10, 3 (Sept. 1978), 225â€“261. https://doi.org/10.1145/356733.356735

[16] John W. Eaton, David Bateman, SÃ¸ren Hauberg, and Rik Wehbring. 2020. GNU Octave version 5.2.0 manual: a high-
level interactive language for numerical computations. https://www.gnu.org/software/octave/doc/v5.2.0/ Accessed on

A Software Package for Queueing Networks and Markov Chains analysis

21

2020-08-14.

[17] Greg Franks, Tariq Al-Omari, Murray Woodside, Olivia Das, and Salem Derisavi. 2009. Enhanced Modeling and
IEEE Transactions on Software Engineering 35, 2 (March 2009), 148â€“161.

Solution of Layered Queueing Networks.
https://doi.org/10.1109/TSE.2008.74

[18] William J. Gordon and Gordon F. Newell. 1967. Closed Queuing Systems with Exponential Servers. Operations

Research 15, 2 (1967), 254â€“265. https://doi.org/10.1287/opre.15.2.254

[19] Neil J. Gunther. 1997. The Practical Performance Analyst: Performance-by-Design Techniques for Distributed Systems.

McGraw-Hill, Inc., New York, NY, USA.

[20] David I. Heiman, Nitin Mittal, and Kishor S. Trivedi. 1991. Dependability modeling for computer systems. In Proc.

Ann. Reliability and Maintainability Symposium. 120â€“128. https://doi.org/10.1109/ARMS.1991.154425

[21] James R. Jackson. 2004.

Jobshop-Like Queueing Systems. Manage. Sci. 50, 12 Supplement (2004), 1796â€“1802.

https://doi.org/10.1287/mnsc.1040.0268

[22] David G. Kendall. 1953. Stochastic Processes Occurring in the Theory of Queues and their Analysis by the Method of
the Imbedded Markov Chain. Ann. Math. Statist. 24, 3 (Sept. 1953), 338â€“354. https://doi.org/10.1214/aoms/1177728975
[23] Teemu Kerola. 1986. The composite bound method for computing throughput bounds in multiple class environments.

Performance Evaluation 6, 1 (March 1986), 1â€“9. https://doi.org/10.1016/0166-5316(86)90002-7
[24] Leonard Kleinrock. 1975. Queueing Systems: Volume Iâ€“Theory. Wiley Interscience, New York.
[25] Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C. Sevcik. 1984. Quantitative System Performance:

Computer System Analysis Using Queueing Network Models. Prentice Hall.

[26] Moreno Marzolla, Stefano Ferretti, and Gabriele Dâ€™Angelo. 2012. Dynamic Resource Provisioning for Cloud-Based

Gaming Infrastructures. Comput. Entertain. 10, 1 (Dec. 2012). https://doi.org/10.1145/2381876.2381880

[27] Moreno Marzolla and Raï¬€aela Mirandola. 2011.

PARSY: Performance Aware Reconï¬guration of Soft-
International Journal of Performability Engineering 7, 5, Article 479 (2011), 13 pages.

ware Systems.
https://doi.org/10.23940/ijpe.11.5.p479.mag

[28] Moreno Marzolla and Raï¬€aela Mirandola. 2013. Dynamic power management for QoS-aware applications. Sustainable

Computing: Informatics and Systems 3, 4 (2013), 231â€“248. https://doi.org/10.1016/j.suscom.2013.02.001

[29] R Core Team. 2018. R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing,

Vienna, Austria. https://www.R-project.org/ Accessed on 2020-03-20.

[30] Martin Reiser. 1981. Mean-value analysis and convolution method for queue-dependent servers in closed queueing

networks. Performance Evaluation 1, 1 (1981), 7â€“18. https://doi.org/10.1016/0166-5316(81)90040-7

[31] Martin Reiser and Stephen S. Lavenberg. 1980. Mean-Value Analysis of Closed Multichain Queuing Networks. J. ACM

27, 2 (April 1980), 313â€”-322. https://doi.org/10.1145/322186.322195

[32] Paul J. Schweitzer. 1979. Approximate Analysis of Multiclass Closed Networks of Queues. In Proc. Int. Conf. on Sto-

chastic Control and Optimization.

[33] Herb Schwetman. 1980. Testing Network-Of-Queues Software. Technical Report CSD-TR-330. Purdue University.

https://docs.lib.purdue.edu/cstech/259/ Accessed on 2020-03-13.

[34] Herb Schwetman. 1982. Implementing the Mean Value Algorithm for the Solution of Queueing Network Models. Technical

Report CSD-TR-355. Purdue University. https://docs.lib.purdue.edu/cstech/286/ Accessed on 2020-03-13.

[35] Kishor S. Trivedi and Robin Sahner. 2009. SHARPE at the Age of Twenty Two. SIGMETRICS Perform. Eval. Rev. 36, 4

(March 2009), 52â€“57. https://doi.org/10.1145/1530873.1530884

[36] John Zahorjan, Kenneth C. Sevcick, Derek L. Eager, and Bruce I. Galler. 1982. Balanced Job Bound Analysis of Queueing

Networks. Commun. ACM 25, 2 (Feb. 1982), 134â€“141. https://doi.org/10.1145/358396.358447

[37] Lei Zhang and Douglas G. Down. 2019. SMVA: A Stable Mean Value Analysis Algorithm for Closed Systems with Load-

Dependent Queues. Springer International Publishing, Cham, 11â€“28. https://doi.org/10.1007/978-3-319-92378-9_2

