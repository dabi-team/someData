2
2
0
2

p
e
S
9

]
F
P
.
s
c
[

1
v
0
2
2
4
0
.
9
0
2
2
:
v
i
X
r
a

A Software Package for Queueing Networks and Markov
Chains analysis

MORENO MARZOLLA, Università di Bologna, Italy

Queueing networks and Markov chains are widely used for conducting performance and reliability studies.
In this paper we describe the queueing package, a free software package for queueing networks and Markov
chain analysis for GNU Octave. The queueing package provides implementations of numerical algorithms for
computing transient and steady-state performance measures of discrete and continuous Markov chains, and
for steady-state analysis of single-station queueing systems and queueing networks. We illustrate the design
principles of the queueing package, describe its most salient features and provide some usage examples.

CCS Concepts: • Mathematics of computing → Queueing theory; Markov processes; Mathematical
software.

Additional Key Words and Phrases: Queueing Networks, Markov Chains, Mean Value Analysis

1 INTRODUCTION
Queueing Networks (QNs) and Markov chains are powerful modeling notations that are commonly
used for capacity planning, bottleneck analysis and performance evaluation of systems [7]. Ana-
lyzing QNs and Markov chains involves the computation of metric such as the system throughput
of a QN, or the stationary state occupancy probabilities of a Markov chain. Symbolic, numerical,
and simulation-based techniques have been developed to compute these metrics.

In this paper we describe the queueing package for GNU Octave, a free environment for numer-
ical computing [16]. The queueing package provides implementations of numerical algorithms
for (i) transient and stationary analysis of discrete and continuous Markov chains; (ii) stationary
analysis of single-station queueing systems; (iii) stationary analysis of some classes of product-
form Queueing Network.

Although QNs and Markov chains are well studied topics, relatively few computer implementa-
tions of solution algorithms are available and actively supported [12]. Table 1 lists some software
tools that are relevant for this paper.

JMT [6] is a Java package for workload characterization, bottleneck analysis, and QN modeling.
JMT has a GUI that simpliﬁes the deﬁnition and analysis of QN models, although it can also be
used from the command line. JMT uses a simulation engine as its main solution technique, so it
can support extended features (non-Markovian queues, fork/join systems, passive resources, and
others) that are diﬃcult if not impossible to handle numerically.

The LINE solver [11] is a free MATLAB toolbox for analyzing extended and layered queueing net-
works [17]. Extended QNs support features, such as simultaneous resource possession, fork/join
systems, ﬁnite capacity regions and others, allowing more accurate models to be deﬁned. This
comes with the drawback that extended QNs are more diﬃcult to analyze numerically. LINE can
delegate the solution of these models to external solvers such as JMT.

PDQ [19] is an implementation of the Mean Value Analysis (MVA) algorithm for closed, single-
class networks. PDQ provides bindings for diﬀerent programming languages: at the time of writing,
C, Perl, Python and R are supported.

The queueing package for R [9] (that, despite the name, is unrelated to the software described
in this paper) is a free package for analyzing product-form QNs written in the R language [29]. It
supports product-form open and closed, single and multiclass networks.

Author’s address: Moreno Marzolla, moreno.marzolla@unibo.it, Università di Bologna, Department of Computer Science
and Engineering (DISI), Mura Anteo Zamboni 7, Bologna, I-40126, Italy, moreno.marzolla@unibo.it.

 
 
 
 
 
 
2

Name

JMT [6]

LINE [11]
PDQ [19]
queueing [9]

SHARPE [35]

Description

Java tool for workload characterization, simulation-based queueing net-
work modeling
Performance and reliability analysis based on queueing models
queueing networks
R package for analyzing single-station queueing systems and queueing
networks
reliability modeling, Markov and semi-Markov models, Petri nets,
queueing networks

Moreno Marzolla

License

GNU GPL

BSD-3
MIT
GNU GPL

Proprietary

Table 1. Some software package for queueing network analysis that are currently available and actively
maintained.

SHARPE (Symbolic Hierarchical Automated Reliability and Performance Evaluator) [35] is a hi-
erarchical modeling tool that supports any combination of diﬀerent types of performance and reli-
ability models (product-form queueing networks, Petri nets, Markov chains, fault trees). SHARPE
has both a command-line and a graphical interface, and has been under development since the
early 80s. It is the only tool of those reviewed that has a non-free license.

The queueing package presented in this paper is somewhat orthogonal to above tools, in the
sense that it has been developed around speciﬁc design goals which are only partially considered
by other packages; of course, this implies that it has some limitations which might be addressed
by other tools.

One of the design goals of the queueing package is to provide reference implementations of
some fundamental “textbook” algorithms for QN and Markov chain analysis, like other research
communities are doing since a long time (e.g., linear algebra algorithms). To this aim, eﬃciency has
sometimes been sacriﬁced in favor of code readability. The availability of reference implementa-
tions is useful also for teaching purposes: students can immediately put the textbook algorithms at
work to solve practical problems, encouraging “learning by doing”. The author is aware of several
Universities that are using the queueing package to teach performance modeling classes.

The GNU Octave language, being a large subset of the MATLAB language, is well suited for
implementing numerical algorithms that operate on arrays and matrices in a concise and under-
standable way. Moreover, it allows complex performance studies can be done quickly, since models
involving repetitive or embedded structure can be deﬁned programmatically. Parametric model
evaluation or ad-hoc analyses are also possible. The queueing package has been contributed to
the Octave-forge public repository (https://octave.sourceforge.io/). This means that queueing can
be easily installed from the Octave prompt using the standard command pkg install.

Any design decision inevitably carries some drawbacks. The GNU Octave environment allows a
great degree of ﬂexibility, but imposes a steep learning curve that might deter the occasional user.
The focus on well-known classic algorithms neglects more recent results or less frequently used
techniques. Yet, both issues can be addressed. A more comfortable interface, e.g., a GUI, can be built
either as an independent application, or by leveraging existing tools (e.g., JMT) and then delegating
the computations to the queueing package. More algorithms can be implemented and contributed
for inclusion in the queueing package, that is free software and as such can be extended by anyone.
A few contributors already did so.

This paper is structured as follows. In Section 2 we illustrate the design principles behind
the queueing package. The next sections are devoted to illustrate the functions for analyzing
Markov chains (Section 3), single-station queueing systems (Section 4) and queueing networks

A Software Package for Queueing Networks and Markov Chains analysis

3

(Section 5). The presentation focuses on the features provided, rather than the algorithmic details;
comprehensive bibliographic references are provided for the interested reader. Although this pa-
per is not intended to be a substitute of the package user’s manual, a few examples will be shown
to better illustrate its use. Finally, concluding remarks are given in Section 6.

2 DESIGN PRINCIPLES
The queueing package is a collection of functions for computing transient and steady-state perfor-
mance measures of queueing networks and Markov chains. It has been under development over
the last decade to support the author’s research and teaching activity in the area of performance
modeling of systems. The queueing package consists of a set of m-ﬁles written in the GNU Oc-
tave [16] dialect of the MATLAB programming language; therefore, queueing does not require
any special installation procedure, nor does it require a compiler to generate executable code.

The decision of targeting GNU Octave was made at the beginning of the development eﬀort.
GNU Octave started its existence as a free MATLAB clone, but ended up providing extensions and
additional features, some of which have been exploited by queueing (see below). More importantly,
GNU Octave is free software and runs on all major operating systems, so it does not represent an
entry barrier for potential users.

GNU Octave supports most of the standard MATLAB syntax, plus some extensions. For example,
! can be used as the logical not operator; structured blocks such as the if and for constructs can be
terminated with the endif and endfor keywords, respectively, to improve readability. The Texinfo
markup notation [14] can be used for the documentation text embedded in function ﬁles. This
feature has been extensively used: the documentation of each function in the queueing package
can be displayed using the help command during interactive sessions. The user’s manual, in PDF
and HTML formats, is built from the Texinfo documentation extracted from the source ﬁles. This
guarantees that the user’s manual is always consistent with the help text.

Naming conventions. Most of the functions in the queueing package obey a common naming
convention. Function names are the concatenation of several parts, beginning with a preﬁx that
indicates the class of problems the function addresses:

ctmc-
dtmc-
qs-
qn-

Functions dealing with continuous-time Markov chains
Functions dealing with discrete-time Markov chains
Functions dealing with single-station queueing systems
Functions dealing with queueing networks

Functions that handle Markov chains (Section 3) start with either the ctmc or dtmc preﬁx, that

may be followed by a string that hints at what the function does:

-bd
-mtta
-fpt
-exps
-taexps

Birth-Death process
Mean Time to Absorption
First Passage Times
Expected Sojourn Times
Time-Averaged Expected Sojourn Times

Therefore, function ctmcbd returns the inﬁnitesimal generator matrix for a continuous birth-
death process, while dtmcbd returns the transition probability matrix for a discrete birth-death
process. Functions ctmc and dtmc (without any suﬃx) compute steady-state and transient state
occupancy probabilities for Continuous Time Markov Chains (CTMCs) and Discrete Time Markov
Chains (DTMCs), respectively.

Functions whose name starts with qs- deal with single station queueing systems (Section 4).

The suﬃx describes the type of system, e.g., qsmm1 for 𝑀/𝑀/1, qnmmm for 𝑀/𝑀/𝑚 and so on.

4

Moreno Marzolla

Finally, functions whose name starts with qn- deal with queueing networks (Section 5). The
character that follows indicates the type of network (o = open network, c = closed network), and
whether there is a single (s) or multiple (m) customer classes.

-os-
-om-
-cs-
-cm-
-mix-

Open, single-class network
Open, multiclass network
Closed, single-class network
Closed, multiclass network
Mixed network with open and closed classes of customers

The last part of the function name indicates what the function computes:

-aba
-bsb
-gb
-pb
-cb
-mva
-cmva
-mvald
-mvabs
-mvablo
-conv
-convld

Asymptotic Bounds
Balanced System Bounds
Geometric Bounds
PB Bounds
Composite Bounds
Mean Value Analysis (MVA)
Conditional MVA
MVA with load-dependent servers
Approximate MVA using Bard and Schweitzer’s approximation
Approximate MVA for blocking queueing networks
Convolution algorithm
Convolution algorithm with load-dependent servers

Validation. One important issue of numerical software is to make sure that the computed results
are correct. Almost all functions in the queueing package include unit tests embedded as specially-
formatted comments inside the source code. The unit tests are used to check the results against
reference values from the literature. When reference results are not available, cross-validation
with the output of diﬀerent functions on the same model (if available), or with the output of other
packages have been used. For example, a closed product-form network can be analyzed by MVA
or using the convolution algorithm; therefore it is possible to apply the functions qncsmva() and
qncsconv() on the same model and check whether their results agree up to known numerical
problems [10]. Results have also been compared with those produced by diﬀerent tools. This was
helpful to investigate an issue with the qncmmva() function, whose result on the model described
in [33, Figure 7, p. 9] did not agree with the one reported in that paper. The model was analyzed
with Java Modeling Tools (JMT) that conﬁrmed the values computed by the queueing package.

3 MARKOV CHAINS
A stochastic process is a set of random variables {𝑋 (𝑡), 𝑡 ∈ 𝑇 } where each 𝑋 (𝑡) is indexed by a
time parameter 𝑡 ∈ 𝑇 . The state space is the set of all possible values of 𝑋 (𝑡). A time-homogeneous
Markov chain is a stochastic process over the discrete state space {1, . . . , 𝑁 } for some given 𝑁 . In
a DTMC, the time parameter 𝑡 assumes the discrete values in 𝑇 = {0, 1, . . .}, while in a CTMC the
time parameter assumes values in 𝑇 = [0, +∞).

In a time-homogeneous DTMC the conditional probability 𝑝𝑖,𝑗 = Pr{𝑋 (𝑛+1) = 𝑗 | 𝑋 (𝑛) = 𝑖} that
the system is in state 𝑗 at time 𝑛 + 1, given that the system was in state 𝑖 at time 𝑛, is independent
from 𝑛, so that we can deﬁne a DTMC as a stochastic matrix P ∈ R𝑁 ×𝑁 , where 𝑝𝑖,𝑗 = Pr{𝑋 (𝑛 + 1) =
𝑗 | 𝑋 (𝑛) = 𝑖} is the transition probability from state 𝑖 to state 𝑗 , 𝑖 ≠ 𝑗 .

Similarly, in a time-homogeneous CTMC the conditional probability 𝑝𝑖,𝑗 (𝑢, 𝑣) = Pr{𝑋 (𝑣) =
𝑗 | 𝑋 (𝑢) = 𝑖}, 𝑣 ≥ 𝑢, only depends on the time diﬀerence 𝑡 = 𝑣 − 𝑢, and not on the speciﬁc values

A Software Package for Queueing Networks and Markov Chains analysis

5

𝑏1

𝑏2

𝑏3

𝑏𝑁

1

2

3

· · ·

𝑁 +1

𝑑1

𝑑2

𝑑3

𝑑𝑁

Fig. 1. Birth-death process

of 𝑢 and 𝑣, so that we have 𝑝𝑖,𝑗 (𝑡) = Pr{𝑋 (𝑢 + 𝑡) = 𝑗 | 𝑋 (𝑢) = 𝑖} = Pr{𝑋 (𝑡) = 𝑗 | 𝑋 (0) = 𝑖} for
each 𝑡 ≥ 0. The evolution of a CTMC is deﬁned by a generator matrix Q ∈ R𝑁 ×𝑁 where 𝑞𝑖,𝑗 is
the transition rate from state 𝑖 to state 𝑗 ≠ 𝑖. The diagonal elements 𝑞𝑖𝑖 are deﬁned in such a way
that the sum of each row is zero, i.e., 1Q = 0 (1 and 0 denote suitably sized row vectors of 1 and 0,
respectively).

Let 𝜋𝑖 (0) be the probability that the system is in state 𝑖 at time 0. It can be shown that the state

occupancy probabilities 𝝅 (𝑡) = (𝜋1(𝑡), . . . , 𝜋𝑁 (𝑡)) at time 𝑡 can be computed as:

𝝅 (𝑛) = 𝝅 (0)P𝑛

(DTMC)

𝝅 (𝑡) = 𝝅 (0)𝑒Q𝑡

(CTMC)

(1)

Under certain conditions [7] a Markov chain has a unique stationary distribution 𝝅 that is inde-
pendent from the initial state. The stationary distribution can be computed by solving the linear
systems:

= 𝝅
𝝅 P
𝝅 1⊺ = 1

(DTMC)

(
where 1⊺ is a column vector of 1.

𝝅 Q = 0
𝝅 1⊺ = 1

(

(CTMC)

(2)

Functions dtmc() and ctmc() compute the transient or stationary state occupancy probabili-
ties of a DTMC and CTMC, respectively, using a direct implementations of equations (1) and (2),
respectively. For example, the expression pn = dtmc(P,n,p0) computes the state occupancy prob-
ability vector pn after 𝑛 steps of a DTMC with stochastic matrix 𝑃 and initial state probabilities p0.
If invoked with a single parameter as in p = dtmc(P), the function computes the stationary state
distribution vector p. ctmc() can be used in a similar way to analyze CTMCs.

The queueing package provides other functions that compute metrics used in reliability and
performability studies. The Mean Time To Absorption (MTTA) of a DTMC is deﬁned as the average
number of transitions required to reach an absorbing state, given the initial occupancy probability
vector 𝝅 (0) (a state is absorbing if it has no outgoing transitions). The MTTA can be computed
from the fundamental matrix N = (I−P𝑡 )−1, where P𝑡 is the restriction of the transition matrix P to
transient states only, and I is a suitably sized square identity matrix. Given initial state occupancy
probabilities 𝝅 (0), the mean number of steps before entering any absorbing state is:

MTTA = 𝝅 (0) (1N) ⊺

Other metrics of interest include the ﬁrst passage time 𝑀𝑖,𝑗 , deﬁned as the average number of
transitions before state 𝑗 is visited for the ﬁrst time, starting from state 𝑖. Finally, the mean sojourn
time 𝐿𝑖 (𝑛) is the expected number of visits to state 𝑖 during the ﬁrst 𝑛 transitions, for given initial
state occupancy probabilities; the ratio 𝐿𝑖 (𝑛)/𝑛 is called time-averaged mean sojourn time. All these
concepts can be easily deﬁned for continuous-time Markov chains as well.

Birth-death processes are a subclass of Markov chains that are at the basis, among other things,
of the analysis of single-station queueing systems (see Section 4). In a (𝑁 + 1)-states birth-death

6

Moreno Marzolla

Type

Description

Continuous

Discrete

dtmc()
dtmcbd()
dtmcexps()

ctmc()
ctmcbd()
ctmcexps()
ctmctaexps() dtmctaexps() Time-Averaged Mean Sojourn Tiems
ctmcfpt()
ctmcmtta()

Stationary/Transient state occupancy probabilities
Birth-Death process
Mean Sojourn Times

First Passage Times
Mean Time to Absorption

dtmcfpt()
dtmcmtta()

Table 2. Functions for Markov chains analysis

2𝑐𝛾

2

2(1 − 𝑐)𝛾

𝑅𝐶

𝛿

𝑅𝐵

𝛽

𝛼

(a)

1

𝛾

𝛿

0

2𝑐𝛾

2

2(1 − 𝑐)𝛾

𝑅𝐶

𝛿

𝑅𝐵

𝛽

𝛾

1

0

(b)

Fig. 2. Reliability Model for a dual-processor system (from [20])

process, the transition probability (resp. rate) from state 𝑖 to (𝑖 + 1) is 𝑏𝑖, and the transition proba-
bility (resp. rate) from state (𝑖 + 1) to 𝑖 is 𝑑𝑖, 𝑖 = 1, . . . , 𝑁 (Figure 1). Function P = dtmcbd(b, d)
returns a stochastic matrix P for a birth-death process with birth rates b = (𝑏1, . . . , 𝑏𝑁 ) and death
rates d = (𝑑1, . . . , 𝑑𝑁 ). Function Q = ctmcbd(b, d) does the same for the continuous case, with
the obvious diﬀerence that b and d are birth and death rates instead of probabilities.

Table 2 lists the functions that compute the performance metrics described above for.

Example
Let us consider the reliability model of a multiprocessor system shown in Figure 2 and originally
described in [20]. The system consists of two processors, each subject to failures with Mean Time
To Failure (MTTF) 1/𝛾. States labeled 𝑛 ∈ {0, 1, 2} denote that there are 𝑛 working processors. If
one processor fails, it can be recovered (state RC) with probability 𝑐; recovery takes time 1/𝛽. When
the system can not be recovered, a reboot is required (state RB) that brings down the entire system
for time 1/𝛼 > 1/𝛽. The mean time to repair a failed processor is 1/𝛿. The system is operational
if there is at least one working processor.

The model above can be represented as a CTMC with ﬁve states {2, 𝑅𝐶, 𝑅𝐵, 1, 0}. The following
fragment of GNU Octave code deﬁnes the stochastic matrix Q of the CTMC in Figure 2(a), and the
uses the function ctmc() to compute the steady state occupancy probability vector p (parameter
values are taken from [20]):

mm = 60; hh = 60* mm ; dd = 24* hh ; yy = 365* dd ;
a = 1/(10* mm );
b = 1/30;
g = 1/(5000* hh );

# 1/ a = duration of reboot (10 min )
# 1/ b = reconfiguration time (30 sec )
# 1/ g = processor MTTF (5000 h )

A Software Package for Queueing Networks and Markov Chains analysis

7

d = 1/(4* hh );
c = 0.9;
#
Q = [ -2* g

2

RC

RB

2* c * g 2*(1 - c )* g

# 1/ d = processor MTTR (4 h )
# recovery probability

1
0
b
a
-( g+ d )
d

0
0;
0;
0;
g ;
-d ];

# 2
# RC
# RB
# 1
# 0

0
0
d
0

-b
0
0
0

0
-a
0
0

p = ctmc ( Q );

that is p = (9.9839 × 10−1, 2.9952 × 10−6, 6.6559 × 10−6, 1.5974 × 10−3, 1.2779 × 10−6). From these
values we can derive several availability metrics; for example, the average time spent over one
year in states 𝑅𝐶, 𝑅𝐵 and 0 is:

p (2)* yy / mm
# => 1.5743
p (3)* yy / mm
# => 3.4984
p (5)* yy / mm
# => 0.67169

# minutes / year spent in RC

# minutes / year spent in RB

# minutes / year spent in 0

that is, over a year, the system is unavailable for about 1.57 minutes due to reconﬁgurations, 3.50
minutes due to reboots and 0.67 minutes due to failure of both processors.

The Mean Time Between Failures (MTBF) is the average duration of continuous system opera-
tion. We assume that the system starts in state 2, and we consider the system operational also when
in the reconﬁguration state. Therefore, the set of states that we consider operational is {2, 1, 𝑅𝐶}.
If we make states 0 and RB absorbing by removing all their outgoing transitions, the MTBF is the
mean time to absorption of the (modiﬁed) CTMC:

Q (3 ,:) = Q (5 ,:) = 0;
p0 = [1 0 0 0 0];
MTBF = ctmcmtta (Q , p0 )/ yy # MTBF ( years )
# => 2.8376

# make states {0 , RB } absorbing
# initial state occupancy prob .

that yields a MTBF of approximately 2.84 years.

4 SINGLE-STATION QUEUEING SYSTEMS

A single-station queueing system, also called service center, consists of one or more servers con-
nected to a shared queue. An inﬁnite stream of requests (jobs) is generated outside the system and
put into the queue. Jobs are extracted according to some queueing policy (e.g., First-Come-First-
Served) and processed by one of the available servers. Once service completes, a job leaves the
system permanently.

The following information is required to fully describe a single-station queueing system: (i) the
nature of the arrival process; (ii) the distribution of service times; (iii) the number of servers;
(iv) the size of the queue; (v) the queueing discipline, i.e., the policy used by the server(s) to extract
requests from the queue.

Kendall’s notation [22] can be used to specify of queueing system. It consists of ﬁve symbols
𝐴/𝑆/𝑚/𝐾/𝐷, where 𝐴 denotes the type of arrival process, 𝑆 the service time distribution, 𝑚 ≥ 1
the number of servers, 𝐾 ≥ 𝑚 the maximum system capacity, and 𝐷 the queueing discipline.

8

Moreno Marzolla

Fig. 3. Graphical representation of some single-station queueing systems

Several types of arrival processes 𝐴 and service time distributions 𝑆 have been studied in the lit-
erature, and assigned speciﬁc symbols: 𝑀 (exponential distribution), 𝐷 (deterministic distribution),
𝐺 (general distribution), Hyper𝑘 (hyperexponential distribution with 𝑘 phases), and others.

Queueing disciplines include First-Come First-Served (FCFS), Last-Come-First-Served (LCFS),
Service In Random Order (SIRO), and Processor Sharing (PS). In the PS discipline all jobs are served
at the same time (i.e., there is no queue), that is equivalent to round-robin scheduling with inﬁnites-
imally small time slice.

A commonly used arrival process and service time distribution are the Poisson point process
and exponential distribution, respectively; both are denoted with the letter 𝑀 in Kendall’s notation.
Let 𝐴(𝑡) be the number of requests arriving at the queueing system during a time interval of
length 𝑡; 𝐴(𝑡) is a Poisson point process if the probability Pr{𝐴(𝑡) = 𝑛} that there are 𝑛 arrivals is:

Pr{𝐴(𝑡) = 𝑛} =

(𝜆𝑡)𝑛
𝑛!

𝑒−𝜆𝑡

where 𝜆 > 0 is the expected number of arrivals for unit of time. It can be shown [24] that the
stochastic variable 𝑇 representing the time between two successive arrivals (interarrival time)
follows an exponential distribution with mean 1/𝜆:

Pr{𝑇 ≤ 𝑡 } = 1 − 𝑒−𝜆𝑡

The inter-arrival and service time distributions of a 𝑀/𝑀/− queue are therefore fully speciﬁed
by the arrival rate 𝜆 of requests and the throughput 𝜇 of each server. 𝑀/𝑀/− systems have the
useful property that the Probability Mass Function (PMF) 𝜋𝑘 that there are 𝑘 ≥ 0 requests in the
system1 has a simple form allowing stationary performance measures to be expressed easily [7, 24].
Figure 3 shows a graphical representation of some of the single-station queueing system types
supported by the queueing package. 𝑀/𝑀/𝑚 systems have 𝑚 ≥ 1 identical servers, so that up to 𝑚
requests can be serviced at the same time. Once a server becomes idle, it fetches the next request
from the queue (if any) and processes it. The system is stable, i.e., the average queue length is ﬁnite,
if 𝜆 < 𝑚𝜇. Special cases of the 𝑀/𝑀/𝑚 system are the 𝑀/𝑀/1 service center, where there is a single
server, and the 𝑀/𝑀/∞ center where there are inﬁnitely many identical servers, and therefore
requests do not need to wait before receiving service. 𝑀/𝑀/∞ stations are also called Inﬁnite

1We adopt the widely used convention of using the same symbol 𝜋𝑘 for both the state occupancy probability of a queueing
system and the state of a Markov chain

A Software Package for Queueing Networks and Markov Chains analysis

9

Function Description

𝑀/𝑀/1 system
𝑀/𝑀/𝑚 system with 𝑚 identical servers

qsmm1()
qsmmm()
qsmminf() 𝑀/𝑀/∞ system (delay center)
qsmm1k() 𝑀/𝑀/1/𝐾 ﬁnite-capacity system
qsmmmk() 𝑀/𝑀/𝑚/𝐾 ﬁnite-capacity system (𝐾 ≥ 𝑚)
qsammm()
qsmh1()
qsmg1()

Asymmetric 𝑀/𝑀/𝑚
𝑀/Hyper𝑚/1 queue with hyper-exponential service time distribution
𝑀/𝐺/1 queue with general service time distribution

Table 3. Supported single-station queueing systems

Server (IS) nodes or delay centers, since they essentially delay incoming requests by an average
duration 1/𝜇. IS nodes are always stable, irrespective of the arrival and service rates.

The 𝑀/𝑀/𝑚/𝐾 system is a ﬁnite-capacity variants of the 𝑀/𝑀/𝑚 queueing center. The param-
eter 𝐾 ≥ 𝑚 represents the maximum number of jobs in the system, including those being served;
therefore, there are (𝐾 −𝑚) slots in the queue. Finite-capacity centers are always stable, since each
request that tries to join a full system is discarded.

Non-Markovian queues are used in some contexts, such as modeling of telecommunication net-
works. The asymmetric 𝑀/𝑀/𝑚 systems consists of 𝑚 exponential servers with possibly diﬀerent
service rates 𝝁 = (𝜇1, . . . , 𝜇𝑚 ). At most 𝑚 requests can be served concurrently; if multiple servers
are available, the next request receives service from a randomly chosen one. This system is stable
if 𝜆 <
𝑖=1 𝜇𝑖 . In the 𝑀/Hyper𝑚/1 system the server has 𝑚 diﬀerent service rates 𝝁 = (𝜇1, . . . , 𝜇𝑚)
𝑚
𝑚
that are selected with probabilities 𝜶 = (𝛼1, . . . , 𝛼𝑚),
𝑖=1 𝛼𝑖 = 1. Non-Markovian queueing sys-
tems are harder to analyze; the queueing package uses the approximation techniques described
in [24], where both asymmetric 𝑀/𝑀/𝑚 and 𝑀/Hyper𝑚/1 queues are treated as 𝑀/𝐺/1 systems.
Performance measures of single-station queueing systems include the following quantities:

Í

Í

𝑈

𝑅

𝑄
𝑋

Utilization: mean fraction of time the servers are busy. In general, 𝑈 ∈ [0, 1]: for example, for
a stable 𝑀/𝑀/𝑚 system the utilization is 𝑈 = 𝜆/(𝑚𝜇). In the case of the 𝑀/𝑀/∞ system, 𝑈
is deﬁned as the traﬃc intensity 𝑈 = 𝜆/𝜇 and can be also greater than one, since the system
is always stable.
Response time: average time spent by a request inside the system, i.e., the mean duration
of the interval between a request arrival in the queue and its departure after completing
service.
Mean queue length.
Throughput: average number of requests that complete service in a unit of time. If the system
is stable, then the throughput is equal to the arrival rate (𝑋 = 𝜆).

The performance measures above can be derived from the steady-state probability 𝜋𝑘 , although
in most cases there are simpler closed-form expressions that do not require the explicit compu-
tation of 𝜋𝑘 . However, of particular interest is the probability 𝜋0 that the system is empty, and
the rejection probability 𝜋𝐾 for a ﬁnite-capacity systems where at most 𝐾 jobs are allowed. The
queueing package can compute the value of 𝜋𝑘 for Markovian queues for any given 𝑘.

Table 3 lists the functions provided by the queueing package to analyze the supported types of
queueing systems. Note that 𝑀/𝑀/1 and 𝑀/𝑀/∞ systems are handled separately from 𝑀/𝑀/𝑚
queues, since simpler formulas for the special cases 𝑚 = 1 and 𝑚 = ∞ are used.

10

Moreno Marzolla

Example
Let us consider a 𝑀/𝑀/𝑚 center with arrival rate 𝜆 and service rates 𝜇. Assuming stability (𝜆 <
𝑚𝜇), the steady state probability 𝜋𝑘,𝑀/𝑀/𝑚 that there are 𝑘 ≥ 0 requests in the system is [7]:

𝜋0,𝑀/𝑀/𝑚

𝜋0,𝑀/𝑀/𝑚

(𝑚𝜌)𝑘
𝑘!

𝜌𝑘𝑚𝑚
𝑚!

0 ≤ 𝑘 ≤ 𝑚

𝑘 > 𝑚

(3)

𝜋𝑘,𝑀/𝑀/𝑚 = 


where 𝜌 = 𝜆/(𝑚𝜇) is the individual server utilization, and the steady-state probability 𝜋0,𝑀/𝑀/𝑚
that there are no requests in the system is:



𝜋0,𝑀/𝑀/𝑚 =

(𝑚𝜌)𝑘
𝑘!

+

(𝑚𝜌)𝑚
𝑚!

1
1 − 𝜌 #

−1

𝑚−1

"

Õ𝑘=0

(4)

The limit of (3) as 𝑚 tends to inﬁnity is the steady state probability 𝜋𝑘,𝑀/𝑀/∞ that there are 𝑘

request in a 𝑀/𝑀/∞ Inﬁnite Server node:

𝜋𝑘,𝑀/𝑀/∞ = lim
𝑚→∞

𝜋𝑘,𝑀/𝑀/𝑚 = 1
𝑘!

𝑘

𝑒−𝜆/𝜇

𝜆
𝜇

(cid:18)

(cid:19)

The following fragment of GNU Octave code uses the functions qsmmm() and qsmminf() to
compute the steady state probability that there are 𝑘 requests in the system, 𝑘 = 0, . . . , 20, for an
𝑀/𝑀/4, 𝑀/𝑀/5 and 𝑀/𝑀/∞ system.

lambda = 4; mu = 1.2; k = 0:20;
pi_mm4
pi_mm5
pi_mminf = qsmminf ( lambda , mu , k );

= qsmmm ( lambda , mu , 4, k );
= qsmmm ( lambda , mu , 5, k );

Note that qsmmm(), qsmmm() and qsmminf() like other functions in the queueing package, sup-
port vector arguments. In these cases a vector of results is returned. Also, the queueing package
relies on Horner’s rule

Õ𝑘=0
to evaluate the summation of Eq. (4) more accurately.

(cid:16)

(cid:16)

𝑛

𝑎𝑘
𝑘!

= 1 + 𝑎

1 +

1 +

𝑎
2

𝑎
3

𝑎
𝑛

· · ·

1 +

(cid:16)

(cid:16)

· · ·

(cid:17)

(cid:17)(cid:17) (cid:17)

Figure 4 shows that the marginal probabilities 𝜋𝑘,𝑀/𝑀/𝑚 tend indeed to 𝜋𝑘,𝑀/𝑀/∞ as the number

of servers 𝑚 grows.

5 QUEUEING NETWORKS
A QN consists of 𝐾 ≥ 1 service centers (nodes) and a population of requests (jobs) that visit the
servers in some order. Several types of QNs have been studied, depending on the type of population
of requests. In open networks there is an inﬁnite stream of jobs that originate outside the system
and eventually leave the system forever (Figure 5a). In closed networks there is a ﬁxed population
of jobs that never leave the system (Figure 5b). Requests can be all of the same type (single-class
networks) or of multiple types (multiclass models). In a multiclass QN, diﬀerent types of requests
can visit the service centers in a diﬀerent order or have diﬀerent service demands (the service
demand is the average time spent by requests on a given node, see below). In mixed networks,
open and closed classes of requests can coexist (Figure 5c).

A Software Package for Queueing Networks and Markov Chains analysis

11

PMF of M/M/∞ and M/M/m systems, λ = 4, µ = 1.2

k

π

0.25

0.2

0.15

0.1

0.05

0

0

M/M/∞
M/M/5
M/M/4

5

10
N. of requests (k)

15

20

Fig. 4. Probability 𝜋𝑘 that there are 𝑘 requests in a 𝑀/𝑀/4, 𝑀/𝑀/5 and 𝑀/𝑀/∞ system with arrival rate
𝜆 = 4req/𝑠 and service rates 𝜇 = 1.2req/𝑠.

Fig. 5. Three types of queueing networks: (a) Closed network; (b) Open network; (c) Mixed network.

QN analysis consists of computing steady-state performance measures such as throughput or
average queue length of the service centers. These measures can be derived from the equilibrium
state probability Pr(S) that the system is in state S for each valid state, where the exact nature
of S is model-dependent.

12

Moreno Marzolla

Some classes of QNs enjoy product-form solution, meaning that Pr(S) has the relatively simple

form

Pr(S) =

1
𝐺 (S)

𝐾

𝑑 (S)

𝑓𝑖 (𝑥𝑖)

(5)

Ö𝑖=1

where 𝑥𝑖 is the conﬁguration of the 𝑖-th service center, 𝑓𝑖 is a function that depends on the type
of service center, 𝑑 (S) is a model-dependent function of the global state, and 𝐺 is a normalization
constant. A QN with product-form solution can be analyzed eﬃciently by considering each node
in isolation and combining the partial results.

The ﬁrst class of product-form open networks was identiﬁed by Jackson [21]. Later, Gordon and
Newell extended product-form solution to certain classes of closed networks [18]. These results
were further extended by Baskett, Chandy, Muntz and Palacios [5] to include open, closed and
mixed networks with multiple customer classes (since then known as BCMP networks). Other
types of networks have been shown to possess product-form solution; the interested reader is
referred to [2] for a review.

The queueing package supports a subset of BCMP networks that satisfy the following con-

straints:

• The network can consist of open or closed job classes (or both).
• The following queueing disciplines are allowed: FCFS, PS, Last-Came First-Served, Preemp-

tive Resume (LCFS-PR) and IS.

• Service times for FCFS nodes are exponentially distributed and class-independent. For PS,

LCFS-PR and IS nodes, diﬀerent classes of customers can have diﬀerent service times.

• The service rate of a FCFS node can depend on the number of jobs at this node (load-

dependent service centers).

• In open networks two kinds of arrival processes are allowed: (i) Poisson arrival process with
arrival rate 𝜆. (ii) 𝐶 independent Poisson arrival streams where the 𝐶 job sources are assigned
to the 𝐶 chains.

The constraints above allow a considerable simpliﬁcation of the algorithms implemented, and

at the same time include the types of networks that are most frequently used in practice.

Table 4 lists the main functions for QN analysis provided by the queueing package; more details

are provided in the rest of this section.

Single-class models. In single class models, service centers do not diﬀerentiate the requests that
they process. This means that, for example, the mean time spent by a request in a given server
(service time) will depend only on the server, not on the type of request.
A single-class QN can be fully speciﬁed by the following parameters:

𝐾
𝜆𝑖
𝑁
𝑍

𝑆𝑖

𝑃𝑖,𝑗

Number of service centers.
(Open networks only) External arrival rate to center 𝑖 ∈ {1, . . . , 𝐾 }.
(Closed networks only) Total number of requests in the system.
(Closed networks only) Optional external delay (“think time”) spent by each request outside
the system after each interaction.
Mean service time at any server inside center 𝑖 for each visit (not including the time spent
waiting in the queue). For general load-dependent service centers, the service time is a vector
where 𝑆𝑖 (𝑛) is the service time when there are 𝑛 requests in center 𝑖
Probability that a request completing service at center 𝑖 is routed to center 𝑗 . For open net-
works, the probability that a request leaves the system after completing service at center 𝑖
is

1 −

.

𝐾
𝑗=1 𝑃𝑖,𝑗

(cid:16)

Í

(cid:17)

A Software Package for Queueing Networks and Markov Chains analysis

13

Number of classes

Description

Multiple

qncmaba()
qnomaba()

qncmbsb()

qncmcb()
qnom()

Single

qncsaba()
qnosaba()
qncsbsb()
qnosbsb()
qncsgb()

qnos()
qncsconv()
qncsconvld()

qncsmva()

qncmmva()

qncsmvald()
qncscmva()

qncmmvabs()

qnmix()

qncsmvablo()
qn?svisits()

Asymptotic Bounds for closed Networks [15]
Asymptotic Bounds for open networks [15]
Balanced System Bounds for closed networks [36]
Balanced System Bounds for open networks [36]
Geometric Bounds [13]
Composite Bound Method [23]
Analysis of Jackson networks [21] and their multiclass extension
Convolution algorithm for closed networks with ﬁxed-rate servers [8]
Convolution algorithm for closed networks with load dependent
servers [8]
MVA for closed networks with ﬁxed-rate and multiple server nodes [31,
34]
MVA for closed networks with load dependent servers [31]
Conditional MVA for closed networks with a load dependent
server [10]
Bard and Schweitzer’s MVA approximation for closed networks with
ﬁxed-rate servers [4, 32]
MVA for multiclass networks with both open and closed chains and
ﬁxed-rate servers [34]
Approximate MVA for closed networks with blocking [1]

qn?mvisits() Compute visit ratios from the routing matrix (? can be c or o)

Table 4. Main functions for QN analysis

𝑉𝑖

Mean number of visits to center 𝑖 (also called visit ratio or relative arrival rate).
For open, single class networks the visit ratios 𝑉𝑖 satisfy the following equations:

𝐾

𝑉𝑖 = 𝑃0,𝑖 +

𝑉𝑗𝑃 𝑗,𝑖

𝑖 = 1, . . . , 𝐾

Õ𝑗=1

(6)

where 𝑃0,𝑖 is the probability that an external request goes to center 𝑖. If we denote with 𝜆𝑖 the
𝑖 𝜆𝑖 is the overall external arrival rate, then 𝑃0,𝑖 = 𝜆𝑖 /𝜆.
external arrival rate to center 𝑖, and 𝜆 =

For closed networks, the visit ratios satisfy the following equation:

Í

𝐾
𝑗=1 𝑉𝑗𝑃 𝑗,𝑖

𝑉𝑖 =
𝑉𝑟 = 1
(
Í

𝑖 = 1, . . . , 𝐾, 𝑖 ≠ 𝑟
for a selected reference station 𝑟 ∈ {1, . . . , 𝐾 }

(7)

The second condition ensures that the values 𝑉𝑖 are uniquely deﬁned. A job that returns to the
reference station (default 𝑟 = 1) is assumed to have completed one interaction with the system. The
product 𝐷𝑖 = 𝑆𝑖𝑉𝑖 of the average service time per visit 𝑆𝑖 and the mean number of visits 𝑉𝑖 is called
service demand, and can be understood as the total service time requested by a job during one
interaction with the system. The service center with the larger service demand is the bottleneck
of the system.

Most of the algorithms in the queueing package rely on the visit ratios 𝑉𝑖; if only the routing
matrix P is available, functions qnosvisits() and qncsvisits() can be used to compute the 𝑉𝑖
using Eq. (6) or (7), respectively.

The following performance results for single-class models are computed:

14

Moreno Marzolla

Algorithm 1 MVA algorithm without load-dependent service centers
Require: 𝐾, 𝑁 , 𝑍, 𝑆𝑖, 𝑉𝑖, 𝑖 = 1, . . . , 𝐾
Ensure: 𝑄𝑖, 𝑅𝑖, 𝑈𝑖, 𝑋𝑖
for 𝑖 ← 1, . . . , 𝐾 do

𝑄𝑖 ← 0

for 𝑛 ← 1, . . . , 𝑁 do

for 𝑖 ← 1, . . . , 𝐾 do

𝑆𝑖
𝑆𝑖 (1 + 𝑄𝑖)
(

if center 𝑖 is 𝑀/𝑀/∞
if center 𝑖 is 𝑀/𝑀/1

𝑅𝑖 ←

𝑀

𝑅 ←

𝑅𝑖𝑉𝑖

Õ𝑖=1
𝑛
𝑍 + 𝑅

𝑋 =
for 𝑖 ← 1, . . . , 𝐾 do
𝑄𝑖 ← 𝑋𝑉𝑖𝑅𝑖
for 𝑖 ← 1, . . . , 𝐾 do
𝑋𝑖 ← 𝑋𝑉𝑖
𝑈𝑖 ← 𝑋𝑉𝑖𝑆𝑖

𝑈𝑖
𝑅𝑖
𝑄𝑖
𝑋𝑖

𝑋
𝑅
𝑄

Utilization of service center 𝑖;
Response time of service center 𝑖;
Average number of requests at center 𝑖, including the request(s) being served;
Throughput of service center 𝑖;

From the values above, global performance measures can be derived:

System throughput, 𝑋 = 𝑋𝑖 /𝑉𝑖 for any 𝑖 for which 𝑉𝑖 > 0;
𝐾
System response time, 𝑅 =
𝑖=1 𝑅𝑖𝑉𝑖;
Average number of requests in the system, 𝑄 =

𝐾
𝑖=1 𝑄𝑖

Í

The MVA [31] and convolution [8] algorithms are the most widely used techniques to compute
stationary performance measures of closed product-form networks. The convolution algorithm
computes the normalization constant 𝐺 in Eq. (5); all other performance measures are derived
from 𝐺. MVA relies on the fact that, in a closed network with 𝑁 requests, the response time 𝑅𝑖 (𝑁 )
of center 𝑖 can be expressed as [31]

Í

𝑅𝑖 (𝑁 ) = 𝑆𝑖 (1 + 𝑄𝑖 (𝑁 − 1))

(8)

where 𝑄𝑖 (𝑁 − 1) is the mean queue length at center 𝑖 if one request is removed from the system.
In the case of a single-class network with 𝑀/𝑀/1 center or 𝑀/𝑀/∞ IS nodes only, MVA assumes
the simple form shown in Algorithm 1.

A single-class closed networks with 𝑁 requests and 𝐾 service centers of type 𝑀/𝑀/1 or 𝑀/𝑀/∞
can be analyzed in time 𝑂 (𝑁 𝐾) by either the MVA or the convolution algorithms. Unfortunately,
if multiple-server nodes or general load-dependent service centers are present, both algorithms
suﬀer from numerical instabilities. In the case of MVA, Eq. (8) is no longer suﬃcient to compute
the response time at center 𝑖, since adding a new request may alter the (load dependent) service
time 𝑆𝑖. It is therefore necessary to compute the marginal probabilities 𝑝𝑖 ( 𝑗 |𝑛) that there are 𝑗
requests at center 𝑖, given that the total number of requests in the system is 𝑛. At the end of each

A Software Package for Queueing Networks and Markov Chains analysis

iteration, the MVA algorithm computes the probability 𝑝𝑖 (0|𝑛) that center 𝑖 is idle as

𝑛

𝑝𝑖 (0|𝑛) = 1 −

𝑝𝑖 ( 𝑗 |𝑛)

15

(9)

Õ𝑗=1
Eq. (9) is the source of numerical errors [30], especially if there are many requests (𝑛 is large)

and/or there are servers whose utilization is close to 1.

So far, no numerically stable variant of the MVA and convolution algorithms exist, although sta-
ble approximations have been proposed [37]. The queueing package provides an implementation
of the Conditional MVA (CMVA) algorithm [10], a numerically stable variant of MVA. Unfortu-
nately, CMVA only supports a single load-dependent service center, and is therefore less general
than MVA.

Multiple-class models. The MVA and convolution algorithms can be extended to handle QNs
with multiple job classes. In a multiclass QN there are 𝐶 customer classes; open and closed classes
of requests may be present at the same time. Since a request may change class after service com-
pletion, the concept of chain needs to be introduced. Chains induce a partition of the set of classes:
class 𝑐1 and 𝑐2 belong to the same chain if a job of class 𝑐1 can eventually become a job of class 𝑐2.
A chain can contain multiple classes, but can not contain both an open and a closed class. This
prevents jobs from closed classes to enter open classes, or the other way around

A multiclass network can be described using the same parameters as those used for single class

models, with additional subscripts required to take classes into account:
𝜆𝑐,𝑖
𝑁𝑐
𝑍𝑐

(Open networks only) External arrival rate of class 𝑐 requests to service center 𝑖.
(Closed networks only) Total number of class 𝑐 requests in the system.
(Closed networks only) External delay (also called “think time”) spent by each class 𝑐
request outside the system after one round of interaction with the service centers is com-
pletes. See below.
Mean service time of class 𝑐 requests at center 𝑖; product-form requires that service times
at FCFS queues be class-independent, while service times at IS or PS nodes can vary on a
per-class basis.
Probability that a class 𝑟 request that completes service at center 𝑖 is routed to class 𝑗 as a
class 𝑠 request.
Mean number of visits of class 𝑐 requests to center 𝑖.

𝑆𝑐.𝑖

𝑃𝑟,𝑖,𝑠,𝑗

𝑉𝑐,𝑖

Similarly, performance results (utilization, response times, and so on) are computed for each

service center and class, e.g., 𝑋𝑐,𝑖 denotes the throughput of class 𝑐 requests at center 𝑖.

The queueing package analyzes product-form multiclass closed networks are using the multi-
class MVA algorithm. Let N = (𝑁1, . . . , 𝑁𝐶 ) be the population vector, i.e., the vector where 𝑁𝑐 is
the number of class 𝑐 requests in the system, 𝑐 = 1, . . . , 𝐶. Let 1𝑐 be the vector of length 𝐶 where
the 𝑐-th element is one and all other elements are zero. For closed networks with only ﬁxed-rate
(𝑀/𝑀/1) and IS (𝑀/𝑀/∞) nodes, the BCMP theorem [5] states that the response time 𝑅𝑐,𝑖 (N) of
class 𝑐 requests at center 𝑖 is:

𝑅𝑐,𝑖 (N) = 𝑆𝑐,𝑖 (1 + 𝑄𝑖 (N − 1𝑐))
where 𝑄𝑖 (N − 1𝑐) is the mean queue length at center 𝑖 with one class 𝑐 customer removed (if 𝑛𝑐 = 0
we let 𝑄𝑖 (N − 1𝑐 ) = 0). Eq. (10) is similar to (8), and is the core of the multiclass MVA Algorithm
shown in 2.

(10)

Multiclass MVA allows all performance measures to be computed starting from the queue lengths 𝑄𝑖 (0) =

0 of the network with no jobs. Speciﬁcally, Algorithm 2 computes the mean response time 𝑅𝑐,𝑖 of

16

Moreno Marzolla

Algorithm 2 Multiclass MVA without load-dependent service centers
Require: 𝐾, 𝐶, 𝑁𝑐, 𝑍𝑐, 𝑆𝑐,𝑖, 𝑉𝑐,𝑖, 𝑐 = 1, . . . , 𝐶, 𝑖 = 1, . . . , 𝐾
Ensure: 𝑄𝑖, 𝑅𝑐,𝑖, 𝑋𝑐

for 𝑖 ← 1, . . . , 𝐾 do
𝑄𝑖 (0) ← 0
for 𝑛 ← 1, . . . ,

𝐶
𝑐=1 𝑁𝑐 do

Í
for 𝑐 ← 1, . . . , 𝐶 do

for each feasible population n = (𝑛1, . . . , 𝑛𝐶 ) with 𝑛 total requests do

for 𝑖 ← 1, . . . , 𝐾 do

𝑅𝑐,𝑖 ←

𝑆𝑐,𝑖
𝑆𝑐,𝑖 (1 + 𝑄𝑖 (n − 1𝑐))
(

if center 𝑖 is 𝑀/𝑀/∞
if center 𝑖 is 𝑀/𝑀/1

for 𝑐 ← 1, . . . , 𝐶 do

𝑋𝑐 =

𝑍𝑐 +

𝑛𝑐
𝐾
𝑖=1 𝑉𝑐,𝑖𝑅𝑐,𝑖

for 𝑖 ← 1, . . . , 𝐾 do

Í
𝐶

𝑄𝑖 (n) ←

𝑋𝑐𝑉𝑐,𝑖𝑅𝑐,𝑖

Õ𝑐=1

class 𝑐 requests at center 𝑖, the mean queue length 𝑄𝑖 (N) at center 𝑖, and the global throughput 𝑋𝑐
of class 𝑐 requests. The other performance measures can be derived easily [7, 25]:

𝑋𝑐,𝑖 = 𝑋𝑐𝑉𝑐,𝑖
𝑈𝑐,𝑖 = 𝑋𝑐𝑆𝑐,𝑖𝑉𝑐,𝑖
𝑄𝑐,𝑖 = 𝑋𝑐𝑅𝑐,𝑖

class 𝑐 throughput at center 𝑖

class 𝑐 utilization at center 𝑖

mean number of class 𝑐 requests at center 𝑖

(11)

(12)

(13)

The multiclass MVA algorithm generates all feasible populations n = (𝑛1, . . . , 𝑛𝐶 ); we say that n
is feasible with respect to the population vector N = (𝑁1, . . . , 𝑁𝐶 ) if 0 ≤ 𝑛𝑐 ≤ 𝑁𝑐 for all 𝑐 = 1, . . . , 𝐶.
𝐶
𝑐=1 (𝑁𝑐 + 1) feasible population vectors; therefore, for a closed,
It can be easily seen that there are
multiclass network with 𝐾 ﬁxed-rate or IS nodes, 𝐶 customer classes and population vector N,
multiclass MVA requires time 𝑂

and space 𝑂

Î
𝐶𝐾

𝐾

.

𝐶
𝑐=1 (𝑁𝑐 + 1)

𝐶
𝑐=1 (𝑁𝑐 + 1)

(cid:16)

(cid:16)

Î

Î

Due to its computational cost, multiclass MVA is appropriate for networks with small popu-
(cid:17)
lation and limited number of classes. For larger networks, approximations based on the MVA
have been proposed in the literature. The queueing package provides an implementation of Bard
and Schweitzer’s iterative approximation scheme [4, 25, 32] through function qncmmvabs(). Bard-
Scweitzer approximation requires space 𝑂 (𝐶𝐾), that compares favorably with that of standard
multiclass MVA. Being an iterative scheme that stops as soon as a convergence criterion is met,
the execution time of Bard-Scweitzer approximation depends on the network being analyzed, but
is generally much lower than multiclass MVA (see the example at the end of this section). Unfortu-
nately, the drawback is that there is no known way to estimate the accuracy of the results provided
by the Bard-Scweitzer algorithm.

(cid:17)

Bound analysis. In situations where accurate computation of performance measures is imprac-
tical, bound analysis can be used to provide upper/lower limits on the system throughput 𝑋 and
response time 𝑅. Performance bounds on QNs can be computed quickly, and are useful for exam-
ple in scenarios involving on-line performance tuning of systems [26–28]. The queueing package

A Software Package for Queueing Networks and Markov Chains analysis

17

allows the computation of several classes of bounds: Asymptotic Bounds (AB), Balanced System
Bounds (BSB), Composite Bounds (CB) and Geometric Bounds (GB).

Asymptotic Bounds [15] rely on the simplifying assumption that the service demand of a request
at a service center is independent from the number of requests in the system and their exact
location. Under this assumption (that is not true in general) it is possible to bound the system’s
performance by considering the extreme situations of lowest and highest possible loads. ABs for a
single-class network with 𝐾 service centers can be computed in time 𝑂 (𝐾); for multiclass networks
with 𝐶 customer classes, the computational complexity is 𝑂 (𝐶𝐾).

Balanced System Bounds [36] provide tighter bounds that are computed by forcing the service
demands of the network under consideration to be all the same. BSB have the same computational
complexity as AB, both for single and multiclass models. Composite Bounds [23] and Geometric
Bounds [13] are yet diﬀerent bounding techniques that, in many cases, produce even better bounds
with the same computational cost.

Queueing networks with blocking. The queueing package provides limited support for analyzing
closed, single-class networks with blocking. In blocking networks, queues have a ﬁnite capacity: a
request joining a full queue will block until one slot becomes available. Apart from very few excep-
tions, queueing networks with blocking do not satisfy the conditions for product-form solution [3],
and are therefore diﬃcult to analyze.

The qncsmvablo() function implements the MVABLO algorithm [1] that is based on an ex-
tension of MVA. MVABLO provides approximate performance measures for closed, single-class
networks with Blocking After Service (BAS) blocking. According to the BAS discipline, a request
completing service at center 𝑖 that wants to move to center 𝑗 blocks the source server 𝑖 until one
slot is available at the destination.

Networks with a diﬀerent type of blocking are handled by the qnmarkov() function. This func-
tion supports single-class, open or closed networks where all queues have (possibly diﬀerent) ﬁnite
capacity. The blocking discipline is Repetitive Service with Random Destination (RS-RD): when a
request terminates service at center 𝑖 and wants to move to a saturated center 𝑗 , the request is
put back in the queue of center 𝑖 so that it will eventually receive another round of service from 𝑖.
Each time the request completes a new round of service, it is routed to a possibly diﬀerent, ran-
domly chosen server. In the case of open networks, external arrivals to a saturated servers are
discarded. The qnmarkov() function computes performance measures by building and analyzing
the underlying Markov chain; this makes the function unsuited for even moderate networks due
to the combinatorial explosion of the size of the Markov chain.

Example
We now demonstrate the use of the queueing package for analyzing the closed multiclass network
shown in Figure 6, that represents a simple model of a scientiﬁc compute farm. The system has
three classes of jobs that process data stored on disk servers; occasionally, data must be retrieved
from tape libraries and copied to the disk servers. Each job spends some amount of time on CPU-
intensive computations and then accesses data on external storage. Data resides on three tape
libraries (nodes 1–3). Four disk servers (nodes 4–7) act as a cache for data copied from the tape
libraries. Tape libraries and disk servers are modeled as 𝑀/𝑀/1 service centers. We assume that
the number of CPU cores is not a limiting factor, i.e., each job starting a CPU burst always ﬁnds
a CPU core available. Therefore, the CPU farm can be represented as an IS node (𝑀/𝑀/∞ center).
In the model of Figure 6, the IS node represents the “think time” of jobs, a term that originated
from batch systems where IS nodes were the terminals where users spend some time “thinking”
before submitting new commands to the system.

18

Moreno Marzolla

Fig. 6. Multiclass closed network model of a scientific compute farm.

Param Description Class 1 Class 2 Class 3

𝐷𝑐,1
𝐷𝑐,2
𝐷𝑐,3
𝐷𝑐,4
𝐷𝑐,5
𝐷𝑐,6
𝐷𝑐,7
𝑍𝑐

Tape Server
Tape Server
Tape Server
Disk Server
Disk Server
Disk Server
Disk Server
Cpu farm

100
140
200
30
50
20
10
2400

180
10
70
10
90
130
30
1800

280
160
150
90
20
50
18
2100

Table 5. Parameters for the model in Figure 6

Let 𝑁 be the total number of jobs. We denote with 𝜷 = (𝛽1, 𝛽2, 𝛽3) the population mix of the
network, where 𝛽𝑐 is the fraction of class 𝑐 jobs, 0 ≤ 𝛽𝑐 ≤ 1 and 𝛽1 + 𝛽2 + 𝛽3 = 1. Thus, the number
of class 𝑐 jobs is 𝑁𝑐 = 𝛽𝑐 𝑁 rounded to the nearest integer. Let 𝐷𝑐,𝑖 be the service demand of class 𝑐
requests at center 𝑖 (recall that the service demand is the product of the mean service time and the
number of visits, 𝐷𝑐,𝑖 = 𝑆𝑐,𝑖𝑉𝑐,𝑖 ). Let 𝑍𝑐 be the average duration of a CPU burst of a class 𝑐 job. The
parameter values are shown on Table 5.

We consider 𝑁 = 300 jobs, and we want to study how diﬀerent population mixes 𝜷 aﬀect the
system throughput 𝑋 . For example, the following GNU Octave code computes the per-class utiliza-
tions 𝑈𝑐,𝑖 , response times 𝑅𝑐,𝑖 , mean queue lengths 𝑄𝑐,𝑖 and throughput 𝑋𝑐,𝑖 when 𝜷 = (0.2, 0.3, 0.5):
N = 300;
S = [100 140 200
180
70
10
280 160 150
Z = [2400 1800 2100];
V = ones ( size ( S ));
m = ones (1 , columns (S ));
beta = [0.2 , 0.3 , 0.5];

# mean duration CPU bursts
# n. of visits
# n. of servers in nodes
# population mix

10; # service demands
30;
18];

50
20
90 130
50
20

# total n. of jobs

30
10
90

A Software Package for Queueing Networks and Markov Chains analysis

19

System throughput

1

β

0.2

0.4

0.6

0.8

0.007

0.0065

0.006

0.0055

0.005

0.0045

0.2

0.4

0.6

0.8

β2

Fig. 7. Approximate system throughput as a function of the population mix 𝜷 = (𝛽1, 𝛽2, 1 − 𝛽1 − 𝛽2); the
values have been computed using Bard-Schweitzer approximation. Contour lines show the regions of equal
throughput. Irregularities towards the center are caused by rounding the population to the nearest integer.
(Best viewed in color)

pop = round ( N* beta ); pop (3) = N - pop (1) - pop (2);
[U R Q X ] = qncmmva ( pop , S , V , m , Z );
X_sys = sum ( X (: ,1) ./ V (: ,1));

# System throughput

Note that qncmmva() expects as parameters the mean service times 𝑆𝑐,𝑖 and the mean number

of visits 𝑉𝑐,𝑖 . Since we know the service demands, we let 𝑆𝑐,𝑖 = 𝐷𝑐,𝑖 and set all visits to one.

The system throughput of a multiclass network is 𝑋sys =

𝑐 𝑋𝑐, where 𝑋𝑐 is the class 𝑐 through-
put. The values of 𝑋𝑐 can be computed from the individual servers throughput 𝑋𝑐,𝑖 that are returned
by qncmmva(), using Eq. (11) with 𝑖 = 1 (actually, any valid value for 𝑖 will do). In the example
above we get 𝑋sys = 0.0053793.

Í

Even on such a small network, qncmmva() requires about 170𝑠 of CPU time on an Intel i7-4790
CPU at 3.60GHz running Ubuntu Linux 18.04 with GNU Octave 5.1; this makes the multiclass MVA
algorithm impractical for this type of study, since analyzing many population mixes would require
a prohibitive amount of time. We therefore resort to the much faster Bard-Scweitzer approximation,
realized by function qncmmvabs().

Figure 7 shows the system throughput 𝑋 for (50 ×50)/2 diﬀerent population mixes. Each square
corresponds to a combinations of 𝛽1, 𝛽2, from which 𝛽3 = 𝑁 − 𝛽1 − 𝛽2. Contour lines show the
regions of the parameter space of equal throughput; the population mixes that result in the optimal
throughput are those towards the center of the image.

The whole Figure 7 can be computed in about 5𝑠 using qncmmvabs() on the same system above,
i.e., orders of magnitude faster than the time that would be required by the multiclass MVA imple-
mentation from function qncmmva().

20

Moreno Marzolla

6 CONCLUSIONS
In this paper we described the queueing package, a GNU Octave package for QNs and Markov
chains analysis. The queueing package includes functions for transient and stationary analysis of
discrete and continuous Markov Chains, and for stationary analysis of single-station queueing sys-
tems and product-form QNs. The queueing package can handle open, closed and mixed QNs with
one or multiple classes of requests. Exact and approximate performance metrics can be obtained,
as well as diﬀerent types of bounds.

Research on eﬃcient solution techniques for QN models is still an active topic. The queueing
package will therefore be extended to include some of the newer algorithms. Furthermore, we plan
to include support for more types of non product-form networks.

The latest version of the queueing package is available at https://octave.sourceforge.io/queueing/
and can be used, modiﬁed and distributed under the terms of the GNU General Public License (GPL)
version 3 or later.

REFERENCES
[1] Ian F. Akyildiz. 1988. Mean Value Analysis for Blocking Queueing Networks. IEEE Transactions on Software Engineer-

ing 1, 2 (April 1988), 418–428. https://doi.org/10.1109/32.4663
[2] Simonetta Balsamo. 2000. Product Form Queueing Networks.

In Performance Evaluation: Origins and Directions,
Günter Haring, Christoph Lindemann, and Martin Reiser (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 377–
401. https://doi.org/10.1007/3-540-46506-5_16

[3] S. Balsamo, V. De Nitto Personé, and R. Onvural. 2001. Analysis of Queueing Networks with Blocking. Kluwer Academic

Publishers.

[4] Yonathan Bard. 1979. Some Extensions to Multiclass Queueing Network Analysis. In Proceedings of the Third Interna-
tional Symposium on Modelling and Performance Evaluation of Computer Systems: Performance of Computer Systems.
North-Holland Publishing Co., Amsterdam, The Netherlands, The Netherlands, 51–62.

[5] Forest Baskett, K. Mani Chandy, Richard R. Muntz, and Fernando G. Palacios. 1975. Open, Closed, and Mixed Networks
of Queues with Diﬀerent Classes of Customers. J. ACM 22, 2 (1975), 248–260. https://doi.org/10.1145/321879.321887
[6] Marco Bertoli, Giuliano Casale, and Giuseppe Serazzi. 2009. JMT: performance engineering tools for system modeling.

SIGMETRICS Performance Evaluation Review 36, 4 (2009), 10–15. https://doi.org/10.1145/1530873.1530877

[7] Gunter Bolch, Stefan Greiner, Hermann de Meer, and Kishor S. Trivedi. 1998. Queueing Networks and Markov Chains:

Modeling and Performance Evaluation with Computer Science Applications. Wiley.

[8] Jeﬀrey P. Buzen. 1973. Computational Algorithms for Closed Queueing Networks with Exponential Servers. Commun.

ACM 16, 9 (Sept. 1973), 527–531. https://doi.org/10.1145/362342.362345
of

Canadilla.

queueing:

Analysis

2019.

[9] Pedro

Queueing

Networks

and

Models.

https://CRAN.R-project.org/package=queueing R package version 0.2.12.

[10] Giuliano Casale. 2008. A note on stable ﬂow-equivalent aggregation in closed networks. Queueing Syst. Theory Appl.

60 (Dec. 2008), 193–202. Issue 3-4. https://doi.org/10.1007/s11134-008-9093-6

[11] Giuliano Casale. 2019. Automated Multi-paradigm Analysis of Extended and Layered Queueing Models with LINE.
In Companion of the 2019 ACM/SPEC International Conference on Performance Engineering (Mumbai, India) (ICPE ’19).
ACM, New York, NY, USA, 37–38. https://doi.org/10.1145/3302541.3311959

[12] Giuliano Casale, Marco Gribaudo, and Giuseppe Serazzi. 2011. Tools for Performance Evaluation of Computer Sys-
tems: Historical Evolution and Perspectives.
In Performance Evaluation of Computer and Communication Systems.
Milestones and Future Challenges: IFIP WG 6.3/7.3 International Workshop, PERFORM 2010, in Honor of Günter Haring
on the Occasion of His Emeritus Celebration, Vienna, Austria, October 14-16, 2010, Revised Selected Papers, Karin Anna
Hummel, Helmut Hlavacs, and Wilfried Gansterer (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 24–37.
https://doi.org/10.1007/978-3-642-25575-5_3

[13] Giuliano Casale, R. R. Muntz, and Giuseppe Serazzi. 2008. Geometric Bounds: a Non-Iterative Analysis Technique for
Closed Queueing Networks. IEEE Trans. Comput. 57, 6 (June 2008), 780–794. https://doi.org/10.1109/TC.2008.37

[14] Robert K. Chassell

and Richard M. Stallman.
https://www.gnu.org/software/texinfo/manual/texinfo/ Accessed on 2013-03-13.

2019.

Texinfo: The GNU Documentation Format.

[15] Peter J. Denning and Jeﬀrey P. Buzen. 1978. The Operational Analysis of Queueing Network Models. Comput. Surveys

10, 3 (Sept. 1978), 225–261. https://doi.org/10.1145/356733.356735

[16] John W. Eaton, David Bateman, Søren Hauberg, and Rik Wehbring. 2020. GNU Octave version 5.2.0 manual: a high-
level interactive language for numerical computations. https://www.gnu.org/software/octave/doc/v5.2.0/ Accessed on

A Software Package for Queueing Networks and Markov Chains analysis

21

2020-08-14.

[17] Greg Franks, Tariq Al-Omari, Murray Woodside, Olivia Das, and Salem Derisavi. 2009. Enhanced Modeling and
IEEE Transactions on Software Engineering 35, 2 (March 2009), 148–161.

Solution of Layered Queueing Networks.
https://doi.org/10.1109/TSE.2008.74

[18] William J. Gordon and Gordon F. Newell. 1967. Closed Queuing Systems with Exponential Servers. Operations

Research 15, 2 (1967), 254–265. https://doi.org/10.1287/opre.15.2.254

[19] Neil J. Gunther. 1997. The Practical Performance Analyst: Performance-by-Design Techniques for Distributed Systems.

McGraw-Hill, Inc., New York, NY, USA.

[20] David I. Heiman, Nitin Mittal, and Kishor S. Trivedi. 1991. Dependability modeling for computer systems. In Proc.

Ann. Reliability and Maintainability Symposium. 120–128. https://doi.org/10.1109/ARMS.1991.154425

[21] James R. Jackson. 2004.

Jobshop-Like Queueing Systems. Manage. Sci. 50, 12 Supplement (2004), 1796–1802.

https://doi.org/10.1287/mnsc.1040.0268

[22] David G. Kendall. 1953. Stochastic Processes Occurring in the Theory of Queues and their Analysis by the Method of
the Imbedded Markov Chain. Ann. Math. Statist. 24, 3 (Sept. 1953), 338–354. https://doi.org/10.1214/aoms/1177728975
[23] Teemu Kerola. 1986. The composite bound method for computing throughput bounds in multiple class environments.

Performance Evaluation 6, 1 (March 1986), 1–9. https://doi.org/10.1016/0166-5316(86)90002-7
[24] Leonard Kleinrock. 1975. Queueing Systems: Volume I–Theory. Wiley Interscience, New York.
[25] Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C. Sevcik. 1984. Quantitative System Performance:

Computer System Analysis Using Queueing Network Models. Prentice Hall.

[26] Moreno Marzolla, Stefano Ferretti, and Gabriele D’Angelo. 2012. Dynamic Resource Provisioning for Cloud-Based

Gaming Infrastructures. Comput. Entertain. 10, 1 (Dec. 2012). https://doi.org/10.1145/2381876.2381880

[27] Moreno Marzolla and Raﬀaela Mirandola. 2011.

PARSY: Performance Aware Reconﬁguration of Soft-
International Journal of Performability Engineering 7, 5, Article 479 (2011), 13 pages.

ware Systems.
https://doi.org/10.23940/ijpe.11.5.p479.mag

[28] Moreno Marzolla and Raﬀaela Mirandola. 2013. Dynamic power management for QoS-aware applications. Sustainable

Computing: Informatics and Systems 3, 4 (2013), 231–248. https://doi.org/10.1016/j.suscom.2013.02.001

[29] R Core Team. 2018. R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing,

Vienna, Austria. https://www.R-project.org/ Accessed on 2020-03-20.

[30] Martin Reiser. 1981. Mean-value analysis and convolution method for queue-dependent servers in closed queueing

networks. Performance Evaluation 1, 1 (1981), 7–18. https://doi.org/10.1016/0166-5316(81)90040-7

[31] Martin Reiser and Stephen S. Lavenberg. 1980. Mean-Value Analysis of Closed Multichain Queuing Networks. J. ACM

27, 2 (April 1980), 313—-322. https://doi.org/10.1145/322186.322195

[32] Paul J. Schweitzer. 1979. Approximate Analysis of Multiclass Closed Networks of Queues. In Proc. Int. Conf. on Sto-

chastic Control and Optimization.

[33] Herb Schwetman. 1980. Testing Network-Of-Queues Software. Technical Report CSD-TR-330. Purdue University.

https://docs.lib.purdue.edu/cstech/259/ Accessed on 2020-03-13.

[34] Herb Schwetman. 1982. Implementing the Mean Value Algorithm for the Solution of Queueing Network Models. Technical

Report CSD-TR-355. Purdue University. https://docs.lib.purdue.edu/cstech/286/ Accessed on 2020-03-13.

[35] Kishor S. Trivedi and Robin Sahner. 2009. SHARPE at the Age of Twenty Two. SIGMETRICS Perform. Eval. Rev. 36, 4

(March 2009), 52–57. https://doi.org/10.1145/1530873.1530884

[36] John Zahorjan, Kenneth C. Sevcick, Derek L. Eager, and Bruce I. Galler. 1982. Balanced Job Bound Analysis of Queueing

Networks. Commun. ACM 25, 2 (Feb. 1982), 134–141. https://doi.org/10.1145/358396.358447

[37] Lei Zhang and Douglas G. Down. 2019. SMVA: A Stable Mean Value Analysis Algorithm for Closed Systems with Load-

Dependent Queues. Springer International Publishing, Cham, 11–28. https://doi.org/10.1007/978-3-319-92378-9_2

