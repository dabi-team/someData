2
2
0
2

l
u
J

3
1

]
h
p
-
t
n
a
u
q
[

1
v
6
2
5
6
0
.
7
0
2
2
:
v
i
X
r
a

Quantum computing ﬁdelity susceptibility using automatic diﬀerentiation

Olivia Di Matteo1 and R. M. Woloshyn2
1Department of Electrical and Computer Engineering,
University of British Columbia, Vancouver, British Columbia V6T 1Z4, Canada
2TRIUMF, Vancouver, British Columbia V6T 2A3, Canada

Automatic diﬀerentiation is an invaluable feature of machine learning and quantum machine
learning software libraries. In this work it is shown how quantum automatic diﬀerentiation can be
used to solve the condensed-matter problem of computing ﬁdelity susceptibility, a quantity whose
value may be indicative of a phase transition in a system. Results are presented using simulations
including hardware noise for small instances of the transverse-ﬁeld Ising model, and a number
of optimizations that can be applied are highlighted. Error mitigation (zero-noise extrapolation)
is applied within the autodiﬀerentiation framework to a number of gradient values required for
computation of ﬁdelity susceptibility and a related quantity, the second derivative of the energy.
Such computations are found to be highly sensitive to the additional statistical noise incurred by
the error mitigation method.

I.

INTRODUCTION

Automatic diﬀerentiation is a technique for constructing a set of instructions for computing the derivatives
of a function deﬁned by a computer program. It is implemented in software packages such as Autograd [1],
PyTorch [2], TensorFlow [3] and Jax [4], and is now a crucial component in machine learning libraries. It is
natural that this functionality in classical computation is being replicated in quantum computing frameworks.
An increasing number of libraries, e.g., Qiskit [5], TensorFlow Quantum [6], and PennyLane [7], provide
automatic computation of gradients and higher derivatives mainly for optimization and machine learning
applications. Quantum diﬀerentiable programming has also been implemented speciﬁcally for quantum
chemistry in PennyLane [8].

Automatic diﬀerentiation has a broader range of uses than the applications mentioned above. In this work
we consider the use of automatic diﬀerentiation to solve a problem in condensed matter physics, namely, the
calculation of ﬁdelity susceptibility [9, 10]. This is a quantity related to derivatives of a wave function overlap
and has been used in the study of quantum phase transitions in a variety of condensed matter models. Our
focus here is not on the physics of this problem but primarily to provide an end-to-end demonstration of
quantum automatic diﬀerentiation to solve it. The PennyLane library [7] is used and the cross-platform
capability of this framework is illustrated by running PennyLane code on Qiskit simulators. Finally, this
study exposes some of the issues that have to be dealt with in the NISQ era of quantum computation. The
computation had to be designed to reduce sensitivity to noise as much as possible since gate error mitigation
with automatic diﬀerentiation is still a signiﬁcant challenge. We implement such mitigation and perform an
analysis of the complications that arise when doing so in a practical setting. To that end this work presents,
to the best of our knowledge, the ﬁrst study of how applying error mitigation aﬀects the computation of
energy derivatives with respect to Hamiltonian parameters, which we ﬁnd to be a very sensitive process even
for small systems and a limited amount of mitigation.

In Sect. II A we brieﬂy review how quantum gradients can be computed automatically using parameter-
shift rules. In Sect. II B the concepts of ﬁdelity [11] and ﬁdelity susceptibility [9, 10] as used in condensed
matter physics are introduced. They are a measure of how a wave function changes when Hamiltonian
parameters change. Therefore, they can be useful in the study of quantum systems which exist in diﬀerent
phases depending on interaction parameters. The calculation of ﬁdelity susceptibility is done in a variational
framework and its derivation in terms of derivatives with respect to variational parameters is outlined.
In order to complete the calculation, one needs to know how variational parameters change with respect
changes in Hamiltonian parameters. For this, derivatives of energy expectation values are required. This is
also discussed in Sect. III.

The model used in this study is the one-dimensional transverse ﬁeld Ising model. It is the simplest model
which displays a quantum phase transition and is discussed, for example, in [12]. The model is exactly
solvable by transforming it to a model of free fermions [13] but that would defeat our purpose, so we work
with the spin degrees of freedom directly. In simulations including a hardware noise model only small systems
(4 or 6 spins) are feasible. The techniques used to simplify the calculation and reduce noise sensitivity are

 
 
 
 
 
 
discussed in Sect. III and results of simulations are presented in Sect. IV. A demonstration of automatically-
diﬀerentiable error mitigation is presented in Sect. V. Alternate algorithms for calculating wave function
overlaps are discussed in Appendix A and supplementary error mitigation results are presented in Appendix
B.

2

II. BACKGROUND

A. Quantum gradients and automatic diﬀerentiation

Let U (θ) be a parametrized (variational) quantum circuit with θ =

a set of real-valued parameters.
Consider a quantum computation that begins with a set of qubits in the all-zeros state
, executes
0
U (θ), and measures the expectation value of a Hamiltonian H. The analytical expression of the expectation
value is a function of θ,

θi
{

0
(cid:105)

· · ·

}

|

U †(θ)HU (θ)
|
This function can be diﬀerentiated with respect to the variational parameters. A common means of achieving
this is using parameter-shift rules.

E(θ) =

H
(cid:104)

0
(cid:104)

0
|

(1)

· · ·

· · ·

.
(cid:105)

=

0

0

(cid:105)

Suppose we would like to compute the gradient of E(θ) with respect to a particular θi. If θi appears in the
circuit as the parameter of a single-qubit rotation, it is by now well-known that the gradient can be obtained
by running the circuit at two diﬀerent values of the parameter and combining the results according to the
shift rule [14–18]:

∂E(θ)
∂θi

=

1
2

[E(. . . , θi + π/2, . . .)

E(. . . , θi

−

−

π/2, . . .)] ,

(2)

where it is implicit that all parameters other than θi are held constant during this process.

Such rules are advantageous as they allow for computation of gradients in both software and on hardware
without modifying the actual structure of the circuit, as only the input parameters change. For more
sophisticated unitary operations, generalized parameter-shift rules can be used [16], which may require
evaluating the circuit at four, or even more shifted values, depending on the operation.

Parameter-shift rules provide a straightforward recipe for computing quantum gradients; they can be
further diﬀerentiated in order to compute similar rules for higher-order derivatives, such as Hessians [18]. The
availability of these rules thus allows gradient computation to be incorporated into automatic diﬀerentiation
frameworks, wherein parameters can be modiﬁed through classical processing (e.g., multiplication by a
constant or by another parameter), and the chain rule can be applied. Results of fully-diﬀerentiable quantum
computations can also be incorporated into more extensive hybrid classical-quantum computations.

B. Fidelity susceptibility

Phase transitions are a ubiquitous feature of many-body systems. The long-standing paradigm of de-
scribing phase transitions in terms of a local order parameter associated with symmetry breaking [19] is not
adequate for describing many to the systems studied in contemporary condensed matter physics [20, 21].
Many alternative ways of describing phase transitions have been proposed including ﬁdelity [11] and ﬁdelity
susceptibility [9, 10].

Consider a Hamiltonian with a single variable parameter

When r is varied the system may be in diﬀerent phases. The ﬁdelity, as deﬁned by Chen et al. [22] is

H(r) = H0 + rH1.

F (r, δ) =

ψ(r)
|

|(cid:104)

ψ(r + δ)

(cid:105)|

,

(3)

(4)

where ψ(r) and ψ(r + δ) are eigenstates (only ground states are considered here) at two diﬀerent values of
the Hamiltonian parameter. The susceptibility is the second derivative of this quantity w.r.t. δ evaluated

at δ = 0. By expanding ψ(r + δ) in eigenstates of H(r) one can derive a kind of spectral representation of
the ﬁdelity susceptibility which involves the sum over a complete set of states. For the ground state, the
expression for the ﬁdelity susceptibility is [22]

3

(r) =

S

(cid:88)

n(cid:54)=0

|(cid:104)

H1
ψn(r)
|
E0(r)

|

−

2
ψ0(r)
(cid:105)|
|
2
En(r)
|

.

(5)

This, in principle, requires knowledge of the complete spectrum. However, the use of automatic diﬀerentiation
allows for the calculation of the ﬁdelity susceptibility using only the ground state wave function.

We suppose that the ground state wave function has been obtained by a variational calculation. Let
denote the variational parameters which at the variational minimum are implicit functions of r.

θi

θ =
The quantity to be computed is

{

}

(r) = (cid:12)

(cid:12)∂2
r (cid:104)

ψ

ψ(θ(r), r)

|

(cid:12)
(cid:12)
(cid:105)

(6)

S

where it is understood that diﬀerentiation is applied only to the right side of the overlap. By the chain rule

∂r

ψ
(cid:104)

|

ψ(θ(r), r)

=

(cid:105)

(cid:88)

∂

i

ψ
(cid:104)

|

ψ(θ(r), r)
∂θi

(cid:105)

∂θi
∂r

,

and

∂2
r (cid:104)

ψ

ψ(θ(r), r)
(cid:105)
|

=

(cid:88)

∂2

i,j

ψ
(cid:104)

ψ(θ(r), r)
|
∂θj∂θi

(cid:105)

∂θi
∂r

∂θj
∂r

+

(cid:88)

∂

i

ψ

(cid:104)

ψ(θ(r), r)
(cid:105)
|
∂θi

∂2θi
∂r2 .

(7)

(8)

With a parametrization of the variational wave function and a circuit to compute the overlap, the derivatives
of the overlap w.r.t.
the variational parameters can be computed in a straightforward manner through
parameter-shift rules. Obtaining derivatives of the variational parameters w.r.t. the Hamiltonian parameter
r is more involved.

For the transverse ﬁeld Ising model (considered in this work) or other Hamiltonians for which the expansion
of the ground state wave function involves coeﬃcients which are real, the gradient of the overlap w.r.t.
variational parameters will vanish so the second term in (8) will not contribute. If the expansion coeﬃcients
are complex this may not be the case.

The Hadamard test is a standard method to compute the overlap of two wave functions; automatic
diﬀerentiation of the Hadamard test circuit to get the Hessian needed in the ﬁrst term in (8) is a way to
2 and, if the gradient ∂(cid:104)ψ|ψ(θ(r),r)(cid:105)
get to the ﬁdelity susceptibility. Alternatively, consider
vanishes, then

ψ(θ(r), r)
|

∂θi

|(cid:104)

(cid:105)|

ψ

∂2

ψ

|(cid:104)

ψ(θ(r), r)
|
∂θj∂θi

2
(cid:105)|

∂2

= 2

(cid:104)

ψ

ψ(θ(r), r)
|
(cid:105)
∂θj∂θi

(9)

is another means by which to compute overlap Hessian. The choice of algorithm for computing the right-hand
side of (9) is discussed in Sect. IV and in Appendix A.

In order to complete the calculation of the ﬁdelity susceptibility the quantities ∂θi

∂r are needed. To get
these, derivatives of the Hamiltonian expectation value are used. See the article by Pulay [23] for a systematic
discussion. The energy is

and the condition for the variational minimum is

E =

(cid:104)

ψ(θ(r), r)

H

ψ(θ(r), r)
(cid:105)

|

|

∂E
∂θi

=

ψ

∂

ψ
H
(cid:104)
|
∂θi

|

(cid:105)

= 0

for all i. The ﬁrst energy derivative is

∂E
∂r

(cid:28)

=

ψ

(cid:12)
(cid:12)
(cid:12)
(cid:12)

∂H
∂r

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:29)

ψ

+

(cid:88)

∂

i

(cid:104)

H
ψ
|
∂θi

|

ψ

(cid:105)

∂θi
∂r

=

ψ

(cid:104)

H1
|

|

ψ

(cid:105)

(10)

(11)

(12)

(13)

at the variational minimum. The second energy derivative is

∂2E
∂r2 =

(cid:88)

∂

i

ψ

(cid:104)

H1
|
∂θi

|

ψ

(cid:105)

∂θi
∂r

,

4

(14)

for a Hamiltonian which is linear in the variable parameter.

To get the derivatives of the variational parameters w.r.t. r, take the derivative of the variational condition

(11). The ﬁrst order response is

(cid:18) ∂

∂
∂r

H
ψ
|
(cid:104)
∂θi

|

ψ

(cid:105)

(cid:19)

∂

ψ

(cid:104)

=

ψ

H1
|
∂θi

|

(cid:105)

+

(cid:88)

∂2

j

H
ψ
(cid:104)
|
|
∂θi∂θj

ψ

(cid:105)

∂θj
∂r

= 0.

(15)

This gives a set of equations that can be solved to get the ∂θi
∂r . This is suﬃcient for the calculation of the
ﬁrst and second energy derivatives as discussed in [8, 24] and for the ﬁdelity susceptibility calculated here.
If second derivatives of the variational parameters are required they can be obtained by taking another
derivative of the variational condition [23]

(cid:18) ∂

∂2
∂r2

(cid:104)

H
ψ
|
∂θi

|

ψ

(cid:105)

(cid:19)

=

(cid:88)

∂2

H1
ψ
|
|
(cid:104)
∂θi∂θj

ψ

(cid:105)

∂θj
∂r

(cid:88)

+

j,k

H

ψ
(cid:104)

∂3
ψ
|
∂θi∂θj∂θk

|

(cid:88)

∂2

H
ψ
(cid:104)
|
|
∂θi∂θj

ψ

(cid:105)

∂2θj
∂r2 ,

j

+

j

= 0.

(cid:105)

∂θj
∂r

∂ϑk
∂r

(16)

In summary, to compute the ﬁdelity susceptibility (second derivative of the overlap) and the second derivative
of energy, one needs to compute:

1. The Hessian of the overlap w.r.t. the variational parameters

2. The Hessian of the expectation value of the full Hamiltonian w.r.t. the variational parameters

3. The gradient of the expectation value of the r-dependent part of the Hamiltonian (H1) w.r.t. the

variational parameters

In this work we will demonstrate how all of these gradients can be computed using quantum automatic
diﬀerentiation software.

III. FIDELITY SUSCEPTIBILITY AND THE TRANSVERSE FIELD ISING MODEL

This section outlines the analytical description of the quantum computation that will be performed. For

the one-dimensional transverse ﬁeld Ising model the Hamiltonian

H(r) =

L−1
(cid:88)

−

i=0

(cid:0)σx

i σx

i+1 + rσz
i

(cid:1)

(17)

will be used with periodic boundary conditions, so there is a translation invariance. Furthermore, the
Hamiltonian is invariant under a transformation by σz at every site, that is,

where

[H(r),

] = 0,

P

=

P

(cid:79)

σz
i .

i

(18)

(19)

Consider a one-dimensional spin chain with an even number L of sites. The total number of possible spin
conﬁgurations is 2L. However, due to (18), only half of the possible spin conﬁgurations, i.e., 2(L−1) contribute

5

FIG. 1. Circuit for the 4-spin variational wave function encoded in two qubits.

to the eigenstate of H. For the ground state, the contributing spin conﬁgurations are those where both the
number of up and down spins is even. Due to translation invariance many spin conﬁgurations will have the
same coeﬃcient. These features are used to simplify the quantum computation.

As an illustration of how the computation can be simpliﬁed consider the case of 4 spins. The number
of possible spin conﬁgurations is 16 but only 8 appear in the ground state wave function. These spin
conﬁgurations can be grouped into 4 composite basis states:

1
2 (
|

0000
,
(cid:105)
|
+
0011
1100
+
1001
(cid:105)
|
(cid:105)
|
1√
1010
+
2 (
|
|

+

0110
|

) ,
(cid:105)

(cid:105)
0101
(cid:105)
1111
(cid:105)
|
Calculating the matrix elements of the full Hamiltonian using the above states gives a reduced (4
Hamiltonian matrix

) ,
(cid:105)

.







4r
−
0
2
−
0

0
0
2√2
0

−







.

−

0
2
−
2√2 0
0
2
−
4r
2
−

4)

×

(20)

It can be veriﬁed by exact diagonalization that the ground state energy and ﬁdelity susceptibility using the
reduced Hamiltonian are identical to the results obtained with the full Hamiltonian.

The quantum computation using the reduced Hamiltonian can be done using two qubits with a variational
wave function depending on three parameters. The circuit for the unitary operator which instantiates the
4-spin variational wave function is shown in Fig. 1. In terms of Pauli operators the Hamiltonian (19) acting
on two qubits is

X(0)

−

−

X(1)

−

X(0)Z(1) + Z(0)X(1)

−

√2(X(0)X(1) + Y (0)Y (1))

2r(Z(0) + Z(1)).

−

The above procedure can be extended to systems with more spins. For 6 spins, the 64 possible spin
conﬁgurations can be reduced to a composite basis of eight states. The quantum computation can be done
using three qubits. The circuit for the 6-spin variational wave function depending on seven parameters is
shown in Fig. 2. This circuit has been optimized for a quantum architecture with only nearest-neighbour
qubit connectivity.

IV. SIMULATION RESULTS

Computations were carried out for 4- and 6-spin systems using quantum simulators. Code was writ-
ten using the PennyLane diﬀerentiable programming framework. For production work, the PennyLane
default.qubit and Qiskit Aer simulators were used (through the PennyLane-Qiskit plugin)[25]. All code
and data ﬁles used for this work is available on GitHub [26].

The ﬁrst step in the computation was the determination of optimal variational wave function parameters
for a number of diﬀerent values of the Hamiltonian parameter r spanning a range from 0.5 to 1.4 (this
region was chosen as it is centered around the point of a phase transition at r = 1). This was done using a

6

FIG. 2. Optimized circuit for the 6-spin variational wave function encoded in three qubits.

FIG. 3. Circuit for calculating the squared overlap of the wave functions instantiated by the unitary operators Ui
and Uf .

standard variational quantum eigensolver (VQE). VQE was performed using fully analytical simulation. All
variational parameters were initialized to 0. A gradient descent optimizer with step size 0.1 was used, with
the maximum number of iterations set to 1000, however optimization would terminate early if the energy
computed at a particular iteration was within 10−8 of the true value obtained by exact diagonalization.

Both the ﬁdelity susceptibility, Eq. (6), and the second derivative of the energy (14) are of interest as
indicators of a phase transition (see Ref.[22]). As per Eqs. (15) and (9), to determine these quantities the
gradient

and the Hessians

∂

ψ
(cid:104)

H1
|
∂θi

|

ψ

(cid:105)

∂2

H
ψ
|
|
(cid:104)
∂θi∂θj

ψ

(cid:105)

,

∂2

ψ

|(cid:104)

ψ(θ(r), r)
|
∂θj∂θi

2
(cid:105)|

(21)

(22)

are required. PennyLane computes these automatically by applying parameter-shift rules to circuits for the
Hamiltonian expectation value and squared wave function overlap. The circuit employed for the square of
the wave function overlap is shown in generic form in Fig. 3. Starting in a state of all 0’s, the probability of
measuring all 0’s gives the squared overlap. If one could not make use of Eq. (9) and the overlap, instead of
its square, was really required, a Hadamard test could be used. This is discussed in Appendix A.

7

FIG. 4. Fidelity susceptibility per site of the transverse ﬁeld Ising model as a function of the Hamiltonian parameter
r computed using a simulator of an ideal quantum computer. The circles (squares) are for a lattice of four (six) sites.
The solid lines are exact results.

FIG. 5. Second derivative of the energy per site of the transverse ﬁeld Ising model as a function of the Hamiltonian
parameter r computed using a simulator of an ideal quantum computer. The circles (squares) are for a lattice of four
(six) sites. The solid lines are exact results.

To verify that automatic diﬀerentiation was working properly the ﬁdelity susceptibility (6) and the second
derivative of the energy (14) were computed at each value of r using the PennyLane default.qubit device

0.60.811.21.4r00.050.10.150.2Fidelity susceptibility/LL= 4L = 60.60.811.21.4r00.20.40.60.81- (¶2E(r)/¶r2)/LL = 4L = 6which simulates an ideal (i.e., noise-free) quantum computer. The results, averaged over twenty trials using
8192 shots for each measurement per trial, are shown in Figs. 4 and 5 for spin chains of length 4 and 6. The
solid lines are the results obtained by exact solution of the model.

8

FIG. 6. Fidelity susceptibility per site of the transverse ﬁeld Ising model with four sites as a function of the Hamil-
tonian parameter r computed using a simulator of a noisy quantum computer. The circles (squares) are computed
using qubits with the minimum (maximum) CNOT error. The solid line is the exact result.

On a real quantum device, gate errors and readout errors will degrade the accuracy of the computation.
Readout errors can be mitigated in a fairly straightforward way so in this study these eﬀects were not
included. The focus here is in quantifying gate error eﬀects and the mitigation of gate errors is discussed in
the next section. The Qiskit Aer simulator is used since it provides access to noise models for actual (IBM
Q) hardware devices.

The four spin computation is done on two qubits using publicly available calibration data, so we can
choose a device and a qubit pair which has the minimum CNOT gate error. At the time the computation
was done, this was the ibmq manila device. The results of noisy simulation averaged over twenty trials are
shown in Figs. 6 and 7. For comparison the results of using the qubit pair with the largest CNOT error
are also plotted. For this calculation, where the wave function ansatz contains only a single two-qubit gate,
there is very little sensitivity to gate errors.

The six spin model, even simpliﬁed to run on three qubits, is more challenging. In order to entangle all
qubits more CNOT gates are required. We choose to use CNOT gates only between neighbouring qubits
(Fig. 2) rather than relying on transpiler-generated swap operations. This is to facilitate the error mitigation
study discussed in the next section. The simulation results using the ibmq manila noise model and coupling
map, which speciﬁes connectivity, are shown in Figs. 8 and 9. Note that no transpiler optimization was
applied in doing these calculations.

V. ERROR MITIGATION AND AUTOMATIC DIFFERENTIATION

A. Richardson extrapolation

Zero-noise extrapolation is a common means of performing error mitigation on the results of quantum
computations run on hardware. It involves scaling up the amount of noise in a computation through the

0.60.811.21.4r00.050.10.15Fidelity susceptibility/Lmin CNOT errormax CNOT error9

FIG. 7. Second derivative of energy per site of the transverse ﬁeld Ising model with four sites as a function of
the Hamiltonian parameter r computed using a simulator of a noisy quantum computer. The circles (squares) are
computed using qubits with the minimum (maximum) CNOT error. The solid line is the exact result.

systematic addition of noisy gates, followed by extrapolation back to a noise-less value. Richardson extrap-
olation (RE) is often used to perform such extrapolation [27, 28]; it is based on polynomial interpolation
using Lagrange basis polynomials. Suppose we measure a set of expectation values at n + 1 diﬀerent points
(e.g., diﬀerent noise scale factors), labelled (xj, Ej), for j = 0, . . . , n. The Lagrange polynomial for this set
of points is the lowest-degree polynomial that passes through all of them exactly. It can be constructed as
a linear combination of the expectation values and Lagrange basis polynomials,

where

Pn(x) =

n
(cid:88)

j=0

Ej(cid:96)j(x),

(cid:96)j(x) =

(cid:89)

0≤m≤n,
m(cid:54)=j

xm
xm

.

x
xj

−
−

(23)

(24)

To perform error mitigation with RE, ﬁrst construct the Lagrange polynomial, and then evaluate it at x = 0
to obtain an estimate for the mitigated value. A somewhat simpliﬁed expression of the polynomial can be
used at this point:

Pn(0) =

n
(cid:88)

j=0

Ej(cid:96)j(0) =

n
(cid:88)

j=0

Ej

(cid:89)

0≤m≤n,
m(cid:54)=j

xm

xm

xj

−
−

=

n
(cid:88)

j=0

Ejγj,

(25)

as per the notation in Eqs. (3) and (4) of [28]. From hereon we will denote this value by
will in general be represented using a calligraphic font).

E

(mitigated values

In this work, we are interested in performing error mitigation not only on expectation values, but also
on gradients of them. Suppose that θ is the parameter with respect to which we would like to compute a

0.60.811.21.4r00.20.40.60.81- (¶2E(r)/¶r2)/Lmin CNOT errormax CNOT error10

FIG. 8. Fidelity susceptibility per site of the transverse ﬁeld Ising model with six sites as a function of the Hamiltonian
parameter r computed using a simulator of a noisy quantum computer (circles). The solid line is the exact result.

derivative. It is straightforward to show that for


= Pn(0),



Ejγj

 =

n
(cid:88)

j=0

∂Ej
∂θ

γj,

(26)

E
n
(cid:88)

j=0

∂
E
∂θ

=

∂
∂θ



and so the gradient of an error-mitigated value is simply the error-mitigated computation of a gradient.
Similarly, second derivatives are required, and work the same way:

∂2
∂θ2 =
E

n
(cid:88)

j=0

∂2Ej
∂θ2 γj.

(27)

Thus, computing gradients and performing error mitigation within the larger context of automatic diﬀeren-
tiation will in theory commute.

When we apply RE in practice, each Ej in Eq. (25) has been computed independently based on Nj shots.

What is obtained, then, is an estimate of

E

, ˆ
E

, computed as a linear combination of estimates ˆEj,

=

ˆ
E

n
(cid:88)

j=0

ˆEjγj.

(28)

The variance of the mitigated value, σ2, can be computed in terms of the variances of the individual estimates.
Usually the variance of a sum of terms involves covariance terms. However, it is reasonable to assume
measurements of the expectation values are independent such that all covariances are 0. This yields

σ2 =

n
(cid:88)

j=0

j γ2
σ2
j .

(29)

In the broader context of a quantum algorithm, such as the one considered here, we are computing the

expectation value of not only a single observable, but of a full Hamiltonian. Let

H =

(cid:88)

i

ciPi,

(30)

0.60.811.21.4r00.050.10.150.2Fidelity susceptibility/L11

FIG. 9. Second derivative of energy per site of the transverse ﬁeld Ising model with six sites as a function of the
Hamiltonian parameter r computed using a simulator of a noisy quantum computer (circles). The solid line is the
exact result.

be the Hamiltonian of interest, where Pi are n-qubit Pauli operators. The error-mitigated estimate of the
energy, ˆ
H

, is given by

=

ˆ
H

(cid:88)

i

ci ˆ
i.
P

If each estimate ˆ
P

i has variance σ2

Pi according to Eq. 29, then the total variance is

σ2
H =

(cid:88)

i σ2
c2

Pi =

(cid:88)

c2
i

n
(cid:88)

(σ2

Pi)jγ2
j .

i

i

j=0

Unless the number of shots is adjusted, the variance of error-mitigated estimates is generally higher than
those of the unmitigated values, a fact which has been remarked upon in a number of previous works [28–
30]. If “too much” error mitigation is applied (e.g., if n is too large), the results may be worse than an
unmitigated value unless compensated for. The quality of mitigation can be quantiﬁed using an absolute
mitigation error [30], which is reported for these simulations in Appendix B.

The increase in variance is further compounded by the fact that we are computing mitigated values of
ﬁrst and second derivatives, each of which comprises a sum of multiple shifted terms. For example, for the
gradient of a single expectation value,

∂ ˆ
E
∂θ

=

n
(cid:88)

j=0

∂ ˆEj
∂θ

γj =

(cid:16)

n
(cid:88)

j=0

1
2

ˆEj(θ + π/2)

ˆEj(θ

−

−

(cid:17)

γj.

π/2)

The variance of the estimate is

(σ2)(cid:48) =

n
(cid:88)

j=0

1
4

(σ2

j+ + σ2

j−)γ2

j ≈

n
(cid:88)

j=0

1
2

(σ2

j+)γ2
j

(33)

(34)

where σ2
π/2, and it is assumed that, due to
symmetry, these variances will be equal (but note that they are not necessarily equal to the variance at the

j± represents the variance of the jth term at a shifted value of

±

(31)

(32)

0.60.811.21.4r00.20.40.60.81- (¶2E(r)/¶r2)/L12

unshifted value) [18]. Thus, for the derivative of the expectation value of a full Hamiltonian, a mitigated
estimate is obtained with variance

(σ2

H )(cid:48) =

(cid:88)

i

i (σ2
c2

Pi)(cid:48) =

(cid:88)

c2
i

n
(cid:88)

i

j=0

1
2

(σ2

Pi )j+γ2
j .

(35)

A similar expression can be derived for Hessians. In both cases there is a dependence on the parameter-shift
rule used, and in particular on the number of terms it contains. The increased variance has consequences in
our problem due to where they are used: in the solution of the response equations, Eq. (15), whose results
are propagated into the computations of second energy derivative and ﬁdelity susceptibility. Even small
deviation can result in the system of equations being poorly conditioned, leading to suboptimal solutions.

B. Software implementation

While we note that the open-source error-mitigation library Mitiq [31] has a great variety of error mit-
igation functionality, mitigation was implemented using the diﬀerentiable quantum transforms framework
in PennyLane [32] in order to preserve diﬀerentiability. Transforms are composable “metaprograms” that
modify the behaviour of quantum functions and circuits. In particular, we leverage the concept of a batch
transform: such transforms take quantum functions as input, and return a set of transformed functions, and
a processing function that acts on the results of those functions. This is shown below in pseudocode:

transformed_functions , processing_fn = bat ch _tran sform ( function )
results = execute ( t r a n s f o r m e d _ f u n c t i o n s )
processing_fn ( results )

Expansion of a Hamiltonian into Pauli terms, computation of gradients and Hessians, and zero-noise
extrapolation can all be expressed as batch transforms. For example, the gradient computation as described
in Sect. II A is a batch transform: a quantum circuit is passed as input, and the transform returns two
quantum circuits as output (one for each shifted parameter), and a function that combines the executed
results (Eq. (2)). Furthermore, if the extrapolation procedure is implemented in an autodiﬀerentiable way,
the error-mitigated results can be input to subsequent computations without compromising diﬀerentiability.
A pseudocode implementation of the core function to compute mitigated gradients is shown below to highlight
key elements of batch transform functionality such as composition and usage of the reconstruction functions.
The full implementation is included in our GitHub repository [26].

import pennylane as qml

# A quantum device
dev = qml . device (...)

# A quantum circuit that computes the expectation of a Hamiltonian
# that we would like to obtain an error - mitigated gradient for
circuit = ...

# Some configuration options for error mitigation ; passed to ZNE routine
mi t ig a tio n _ c onf ig = {...}

# Split into constituent terms so mitigation is applied to each one separately
ham_circuits , ham_fn = qml . transforms . ha m i l to n ia n_ e xp a nd ( circuit , group = False )

# Map gradient computation batch transform over each circuit from the previous step .
grad_circuits , grad_fn = qml . transforms . m a p _ b a t c h _ t r a n s f o r m (

qml . gradients . param_shift , ham_circuits

)

# Map each gradient circuit into a set of circuits that computes the error - mitigated
# value . This set of circuits is then executed by the quantum device .
zne_circuits , zne_fn = qml . transforms . m a p _ b a t c h _ t r a ns f o r m (

partial ( zne , miti gat ion _co nfig ) , grad_circuits ,

)

ex e cu t ion _ r e sul ts = qml . execute ( zne_circuits , dev , gradient_fn = None )

1

2

3

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

# The processing functions keep track of what should happen to each
# value during the transform , and are used to recombine the results
e r r o r _ m i t i g a t e d _ e x p v a l _ g r a d i e n t = ham_fn ( grad_fn ( zne_fn ( ex ecu tio n_re sul ts ) ) )

13

28

29

30

31

The mitigation config parameter in the pseudocode described above provides a great deal of choice in
how error mitigation is performed. For instance, how many noise scale factors are used, what their values
are, and how noise gets added based on them. This work considers two ways of adding noise: unitary folding
[33] and CNOT folding [34], each of which are implemented as quantum function transforms [32]. In unitary
folding, given an input circuit U (θ) and an integer noise scale factor λj, the circuit is transformed into
(U (θ)U †(θ))(λj −1)/2U (θ), i.e., the circuit is run forwards and backwards (λj
1)/2 times. In CNOT folding
(λj

1)/2 pairs of CNOTs are added after each existing CNOT.

−

To verify the mitigation pipeline, it was ﬁrst applied to computation of ground state energy, the second
energy derivative, and the ﬁdelity susceptibility by running the circuit at the optimal variational parameters
with no noise, as well as with shot noise. Following this, the simulated device noise model of ibmq manila was
applied, with the circuits adjusted for the coupling map prior to any transforms being applied. Simulations
were run on a desktop machine, but due to the extensive run time of noisy simulations, execution was
parallelized over the diﬀerent values of r.

−

We experimented with sequences of noise scale factors with varying length. Given λj = 2j + 1, simulations
were run for sequences of scale factors [λ0, . . . , λn] for n = 0 (i.e., noisy simulation only) up to n = 4 (i.e.,
a max λj of 9) for L = 4, and up to n = 3 for L = 6. No notable diﬀerence was observed between CNOT
folding and unitary folding. In both cases, as the number of folds increases, so does the variance in results;
however, due to the nature of the quantities being computed, this variance was strongly ampliﬁed, most
notably for the cases of max n = 3 and n = 4 (up to 3 and 4 folds, respectively).

FIG. 10. Second energy derivative per site for the 4-spin system. Results are plotted along the horizontal axis for
r ∈ [0.5, 0.6, . . . 1.4] but oﬀset for readability. The numbers in the legend indicate which scale factors were used in the
mitigation process (e.g., “1,3,5” means mitigation was performed using 3 points for the extrapolation: the unmodiﬁed
circuit, adding one fold, and adding two folds). For each mitigation method, 100 independent trials were run; the
error bars correspond to the standard deviation of these results. As expected, a greater number of points in the
extrapolation leads to higher variance in the potential result.

Results are shown here for up to the n = 3 case for L = 4, and up to n = 2 for L = 6; the full set of
numerical results is available for perusal on GitHub [26]. The L = 4 (L = 6) results are shown in Fig. 10
and 11 (Figs. 12 and 13). To obtain the error-mitigated estimate 8192 shots were used for each circuit that
was run. The entire computation was run 100 times for each quantity of interest; the error bars on the plots
show the mean and standard deviation of the results. We observe the clear increase in variance which occurs
from performing error mitigation as the number of points used in the extrapolation is increased. Note that,
when results are averaged over all error-mitigated attempts, we do in many cases obtain a mitigated value
that improves over the unmitigated one; however this requires a substantial amount of quantum resources.
This is further discussed in Appendix B, where plots are provided for the absolute mitigation error over the
distribution of results.

In some trials, a signiﬁcant variation was observed, most notably for simulations with a larger number of
folds and scale factors. It was found that the reason for this was due to the dependence of both the second

0.50.60.70.80.91.01.11.21.31.4r0.30.40.50.60.70.8-(∂2E(r)/∂r2)/LUnitaryfoldingExactUnmitigated1,31,3,51,3,5,70.50.60.70.80.91.01.11.21.31.4r-(∂2E(r)/∂r2)/LCNOTfoldingExactUnmitigated1,31,3,51,3,5,714

FIG. 11. Fidelity susceptibility per site for the 4-spin system. For each mitigation method, 100 independent trials
were run; the error bars correspond to the standard deviation of these results. Greater variation is observed, compared
to the second energy derivative of Fig. 10, due to a double dependence on the derivatives of variational parameters
with respect to the Hamiltonian parameter r.

FIG. 12. Second energy derivative per site for the 6-spin system. Error bars correspond to the standard deviation of
100 independent trials. Compared to results in the 4-spin case, the variance is higher for both types of folding.

energy derivative and the ﬁdelity susceptibility on the quantities ∂θi/∂r. Error mitigation was applied to
the computation of each element of the Hessian matrix and gradient of the expectation value of H1 required
as per the response equations (Eq. (15)). Their solution involves a linear inversion, but when the Hessian is
noisy the resulting matrix may be poorly conditioned, leading to very large values of the ∂θi/∂r. These are
then used directly in computation of the second energy derivative, and twice in the computation of ﬁdelity
susceptibility (so its variance is even higher). Obtaining accurate values of these parameters is thus critical.

VI. SUMMARY

In this work an end-to-end implementation of quantum automatic diﬀerentiation for a problem in con-
densed matter physics was presented. The use of automatic diﬀerentiation enables the computation of
quantities of interest (second energy derivative and ﬁdelity susceptibility) using eﬀectively a single quantum
It is hoped that this demonstration will
circuit, without knowledge of the full spectrum of the system.
motivate further exploration into how these tools can be applied to other physical problems.

The methods were successfully applied here to small quantum systems with correct results, up to deviations
due to statistical and simulated hardware noise. However, the computation of error-mitigated gradients with
respect to Hamiltonian parameters was found to be particularly sensitive to such noise. A more general
and systematic study should be performed to analyze the theory underlying error-mitigation of energy
derivatives, as it has implications for many other problems in areas such as quantum chemistry. This could
include testing diﬀerent methods for computing the matrix inverse when solving the response equations

0.50.60.70.80.91.01.11.21.31.4r0.040.060.080.100.120.14Fidelitysusceptibility/LUnitaryfoldingExactUnmitigated1,31,3,51,3,5,70.50.60.70.80.91.01.11.21.31.4rFidelitysusceptibility/LCNOTfoldingExactUnmitigated1,31,3,51,3,5,70.50.60.70.80.91.01.11.21.31.4r0.30.40.50.60.70.80.9-(∂2E(r)/∂r2)/LUnitaryfoldingExactUnmitigated1,31,3,50.50.60.70.80.91.01.11.21.31.4r-(∂2E(r)/∂r2)/LCNOTfoldingExactUnmitigated1,31,3,515

FIG. 13. Fidelity susceptibility per site for the 6-spin system. Error bars correspond to the standard deviation of
100 independent trials. Similar to the 4-spin case, the variance in results is higher than that of the second energy
derivative. In the case of unitary folding at r = 1.4, one trial resulted in a markedly large condition number for
the matrix inversion involved in solution of the response equations, leading to signiﬁcantly less accurate results. We
found such behaviour to be common for the 6-spin case when pushing beyond the use of three scale factors for both
types of folding.

(e.g., through a pseudoinverse / singular value decomposition), or alternative strategies for evaluating the
derivatives themselves [35, 36]. Diﬀerent (non-ZNE) error mitigation techniques should also be analyzed,
and it would be of interest to determine the extent to which the mitigation strategy itself could be optimized,
using, e.g., methods developed in [28] or [37]. Finally, as noted in [37], results of error mitigation applied to
noisy simulations may not be representative of those obtained using an actual quantum processor, and so, if
feasible, future work should include execution on real devices.

VII. ACKNOWLEDGEMENTS

ODM thanks Josh Izaac and Tom Bromley for helpful discussions, and acknowledges funding provided by
NSERC grant no. RGPIN-2022-04609. TRIUMF receives federal funding via a contribution agreement with
the National Research Council of Canada. We acknowledge the use of the IBM Qiskit framework for this
work. The views expressed are those of the authors, and do not reﬂect the oﬃcial policy or position of IBM
or the IBM Quantum team

APPENDIX A: OVERLAP ALGORITHMS

The Hadamard test is a standard way to calculate the overlap between two states. The circuit for this test
is shown in generic form in Fig. 14. The advantage of the Hadamard test is that it can provide separately
the real and imaginary parts of the overlap. The disadvantages, compared to the circuit in Fig. 3 are that
it uses an additional qubit and, more importantly, it requires controlled versions of the unitary operators
that create the states. This leads to a large increase in the number of multi-qubit gates resulting in greater
sensitivity to hardware noise. This is illustrated in Fig. 15 where the ﬁdelity susceptibility as a function
of the Hamiltonian parameter r for 4 spins calculated using the Hadamard test, and is compared to that
calculated with overlap from Fig. 3. The simulation is done using the ibmq manila gate noise model.

The swap test is another way to compute the squared overlap of two states. The generic circuit is shown
in Fig. 16. The advantage of the swap test over the Hadamard test is that the unitary operators creating the
states are not controlled. However, the number of qubits required to contain the states is doubled. Instead
of controlled unitaries, controlled swaps are needed which is a disadvantage compared to the overlap circuit
in Fig. 3.

In Ref. [38] Cincio et al. discuss ways to improve the swap test. Fig. 17 compares the ﬁdelity susceptibility
as a function of the Hamiltonian parameter r for 4 spins calculated with the ibmq manila gate noise model
using the Ancilla-Based Algorithm (ABA, Ref. [38], Fig. 5) and the Bell-Based Algorithm (BBA, Ref. [38],

0.50.60.70.80.91.01.11.21.31.4r0.0250.0500.0750.1000.1250.1500.1750.200Fidelitysusceptibility/LUnitaryfoldingExactUnmitigated1,31,3,50.50.60.70.80.91.01.11.21.31.4rFidelitysusceptibility/LCNOTfoldingExactUnmitigated1,31,3,516

FIG. 14. Circuit for calculating the overlap of the wave functions instantiated by the unitary operators Ui and Uf
using the Hadamard test. The gate R is Ry(−π/2) or Rx(π/2) for the real and imaginary parts respectively.

FIG. 15. Fidelity susceptibility of the transverse ﬁeld Ising model as a function of the Hamiltonian parameter r for
four spins comparing the Hadamard test (squares)with the overlap circuit Fig. 3 (circles). The solid line is the exact
result.

0.60.811.21.4r00.050.10.15Fidelity susceptibility/L17

FIG. 16. Circuit for calculating the squared overlap of the wave functions instantiated by the unitary operators Ui
and Uf using the swap test.

FIG. 17. Fidelity susceptibility of the transverse ﬁeld Ising model as a function of the Hamiltonian parameter r for
four spins using the swap test Fig. 16 (squares) compared to the overlap circuit Fig. 3 (circles). Results of using
alternate versions of the swap test discussed in [38] are shown using up-triangles (Ancilla-Based Algorithm, Ref. [38],
Fig. 5) and down-triangles (Bell-Based Algorithm, Ref. [38], Fig. 6). The solid line is the exact result.

0.60.811.21.4r00.050.10.15Fidelity susceptibility/L18

FIG. 18. Error-mitigated ground state energies of the 4-spin system. Mean and standard deviation of 100 independent
trials are shown for each value of r.

FIG. 19. Mitigation error for the ground state energy of the 4-spin system.

Fig. 6) with results using a simple unimproved swap, Fig. 16, and the overlap circuit in Fig. 3. The
algorithms from Ref. [38] provide an improvement but, as one might expect, the circuit Fig. 3 which does
not introduce controlled gates, other than those contained in the state-creating unitaries, shows the least
sensitivity to hardware noise.

APPENDIX B: ADDITIONAL RESULTS

In this section additional numerical results are presented for the 4- and 6-spin systems. In particular, we
show results for mitigated estimation of the ground state energy of both systems, and the absolute mitigation
error [30] (which, for the unmitigated case, is simply the error).

Note that error mitigation has the best overall performance for the estimation of the ground state energy;
this is not surprising given that there is no dependence on the results on the solution of a noisy linear system.
As 100 trials were performed at each r, there are two errors to plot: the absolute mitigation error for each
trial, averaged over all trials; or the absolute mitigation error of the average of all results together. For the
ground state energy of the L = 4 system (Fig. 19) one sees that a small amount of mitigation generally
improves on the results of any individual trial. When considering all the mitigation results together, all
mitigation methods see improvement. As each trial is independent, this provides insight into what could be
expected in the limit of an inﬁnite number of shots (in this case, obtained from running 819200 shots for each
term in the Hamiltonian, for each circuit). For L = 6 the beneﬁts are more clear. This is not unexpected:
given the small size of the 4-spin circuit, the increase in statistical noise that occurs when mitigating is worse
than simply using the results as-is given the noise levels in today’s processors. On the other hand for the
6-spin case, where there are ﬁve CNOTs in the circuit, mitigation is helpful.

For the second energy derivative (Fig. 22) and ﬁdelity susceptibility (Fig. 23 in the L = 4 case), the

0.50.60.70.80.91.01.11.21.31.4r−6.5−6.0−5.5−5.0−4.5GroundstateenergyUnitaryfoldingExactUnmitigated1,31,3,51,3,5,70.50.60.70.80.91.01.11.21.31.4rGroundstateenergyCNOTfoldingExactUnmitigated1,31,3,51,3,5,70.50.60.70.80.91.01.11.21.31.4r0.000.020.040.060.080.10MeanabsolutemitigationerrorUnmitigatedUnitary1,3Unitary1,3,5Unitary1,3,5,7CNOT1,3CNOT1,3,5CNOT1,3,5,70.50.60.70.80.91.01.11.21.31.4rAbsolutemitigationerrorofmean19

FIG. 20. Error-mitigated ground state energies of the 6-spin system. Mean and standard deviation of 100 independent
trials are shown for each value of r.

FIG. 21. Mitigation error for the ground state energy of the 6-spin system.

beneﬁts of mitigation in an average trial are less clear, but again in the limit of an inﬁnite number of shots
one can expect an advantage, at least up to a maximum of 3 folds; running with 4 folds produces worse
results for both metrics, even for the 4-spin system (this data is provided in the GitHub repository). Running
with two diﬀerent scale factors and then extrapolating back produces the best results for both system sizes;
while for the 4-spin case there is again no real improvement noted, there is a clear improvement in the L = 6
case.

FIG. 22. Mitigation error for the second energy derivative of the 4-spin system.

0.50.60.70.80.91.01.11.21.31.4r−9.5−9.0−8.5−8.0−7.5−7.0−6.5GroundstateenergyUnitaryfoldingExactUnmitigated1,31,3,50.50.60.70.80.91.01.11.21.31.4rGroundstateenergyCNOTfoldingExactUnmitigated1,31,3,50.50.60.70.80.91.01.11.21.31.4r0.000.020.040.060.080.100.120.140.16MeanabsolutemitigationerrorUnmitigatedUnitary1,3Unitary1,3,5CNOT1,3CNOT1,3,50.50.60.70.80.91.01.11.21.31.4rAbsolutemitigationerrorofmean0.50.60.70.80.91.01.11.21.31.4r0.0000.0050.0100.0150.0200.0250.0300.035MeanabsolutemitigationerrorUnmitigatedUnitary1,3Unitary1,3,5Unitary1,3,5,7CNOT1,3CNOT1,3,5CNOT1,3,5,70.50.60.70.80.91.01.11.21.31.4rAbsolutemitigationerrorofmean20

FIG. 23. Mitigation error for the ﬁdelity susceptibility of the 4-spin system.

FIG. 24. Mitigation error for the second energy derivative of the 6-spin system.

[1] D. Maclaurin, D. Duvenaud and R. P. Adams, Autograd: Eﬀortless gradients in numpy, in ICML 2015 AutoML

Workshop, 2015.

[2] A. Paszke et al., Pytorch: An imperative style, high-performance deep learning library, in Advances in Neural
Information Processing Systems 32, edited by H. Wallach et al., pp. 8024–8035, Curran Associates, Inc., 2019.

[3] M. Abadi et al., TensorFlow: Large-scale machine learning on heterogeneous systems, 2015.
[4] J. Bradbury et al., JAX: composable transformations of Python+NumPy programs, http://github.com/

FIG. 25. Mitigation error for the ﬁdelity susceptibility of the 6-spin system.

0.50.60.70.80.91.01.11.21.31.4r0.0000.0020.0040.0060.0080.010MeanabsolutemitigationerrorUnmitigatedUnitary1,3Unitary1,3,5Unitary1,3,5,7CNOT1,3CNOT1,3,5CNOT1,3,5,70.50.60.70.80.91.01.11.21.31.4rAbsolutemitigationerrorofmean0.50.60.70.80.91.01.11.21.31.4r0.0000.0050.0100.0150.0200.0250.0300.035MeanabsolutemitigationerrorUnmitigatedUnitary1,3Unitary1,3,5CNOT1,3CNOT1,3,50.50.60.70.80.91.01.11.21.31.4rAbsolutemitigationerrorofmean0.50.60.70.80.91.01.11.21.31.4r0.0000.0020.0040.0060.0080.0100.0120.014MeanabsolutemitigationerrorUnmitigatedUnitary1,3Unitary1,3,5CNOT1,3CNOT1,3,50.50.60.70.80.91.01.11.21.31.4rAbsolutemitigationerrorofmean21

google/jax, 2018.

[5] M. S. ANIS et al., Qiskit: An open-source framework for quantum computing, 2021.
[6] M. Broughton et al., TensorFlow Quantum: A Software Framework for Quantum Machine Learning, 2021,

[arXiv:2003.02989].

[7] V. Bergholm et al., PennyLane: Automatic diﬀerentiation of hybrid quantum-classical computations, 2020,

[arXiv:1811.04968].

[8] J. M. Arrazola et al., Diﬀerentiable quantum computational chemistry with PennyLane, 2021, [arXiv:2111.09967].
[9] W.-L. You, Y.-W. Li and S.-J. Gu, Phys. Rev. E 76, 022101 (2007).

[10] M. Cozzini, R. Ionicioiu and P. Zanardi, Phys. Rev. B 76, 104420 (2007).
[11] P. Zanardi and N. Paunkovi´c, Phys. Rev. E 74, 031123 (2006).
[12] S. Suzuki, J. Inoue and B. Chakrabarti, Transverse Ising Chain (Pure System), in Quantum Ising Phases and

Transitions in Transverse Ising Models, Lecture Notes in Physics, vol 862, Springer, 2013.

[13] P. Pfeuty, Annals of Physics 57, 79 (1970).
[14] K. Mitarai, M. Negoro, M. Kitagawa and K. Fujii, Phys. Rev. A 98, 032309 (2018).
[15] J. Li, X. Yang, X. Peng and C.-P. Sun, Phys. Rev. Lett. 118, 150503 (2017).
[16] D. Wierichs, J. Izaac, C. Wang and C. Y.-Y. Lin, Quantum 6, 677 (2022).
[17] M. Schuld, V. Bergholm, C. Gogolin, J. Izaac and N. Killoran, Physical Review A 99, 032331 (2019).
[18] A. Mari, T. R. Bromley and N. Killoran, Physical Review A 103 (2021).
[19] C. Itzykson and J.-M. Drouﬀe, Statistical Field Theory, Cambridge Monographs on Mathematical Physics Vol. 1

(Cambridge University Press, 1989).

[20] S. Sachdev, Quantum Phase Transitions, 2 ed. (Cambridge University Press, 2011).
[21] B. A. Bernevig, Topological Insulators and Topological Superconductors (Princeton University Press, 2013).
[22] S. Chen, L. Wang, Y. Hao and Y. Wang, Phys. Rev. A 77, 032111 (2008).
[23] P. Pulay, Analytical derivative methods in quantum chemistry, in Ab Initio Methods in Quantum Chemistry II,

edited by K. P. Lawley, pp. 241–286, John Wiley & Sons, New York, NY, 1987.

[24] K. Mitarai, Y. O. Nakagawa and W. Mizukami, Phys. Rev. Research 2, 013129 (2020).
[25] To check cross-platform capability, code was a tested on Cirq and Rigetti Forest simulators also.
[26] http://github.com/glassnotes/qcfs-autodiff, 2022.
[27] K. Temme, S. Bravyi and J. M. Gambetta, Phys. Rev. Lett. 119, 180509 (2017).
[28] M. Krebsbach, B. Trauzettel and A. Calzona, Optimization of Richardson extrapolation for quantum error

mitigation, 2022, [arXiv:2201.08080].

[29] S. Wang et al., Can error mitigation improve trainability of noisy variational quantum algorithms?, 2021,

[arXiv:2109.01051].

[30] C. Cirstoiu, S. Dilkes, D. Mills, S. Sivarajah and R. Duncan, Volumetric Benchmarking of Error Mitigation with

Qermit, 2022, [arXiv:2204.09725].

[31] R. LaRose et al., Mitiq: A software package for error mitigation on noisy quantum computers, 2020,

[arXiv:2009.04417].

[32] O. Di Matteo et al., Quantum computing with diﬀerentiable quantum transforms, 2022, [arXiv:2202.13414].
[33] T. Giurgica-Tiron, Y. Hindy, R. LaRose, A. Mari and W. J. Zeng, Digital zero noise extrapolation for quantum
error mitigation, in 2020 IEEE International Conference on Quantum Computing and Engineering (QCE), pp.
306–316, 2020.

[34] A. He, B. Nachman, W. A. de Jong and C. W. Bauer, Phys. Rev. A 102, 012426 (2020).
[35] T. E. O’Brien et al., npj Quantum Information 5 (2019).
[36] U. Azad and H. Singh, Chemical Physics 558, 111506 (2022).
[37] G. S. Ravi et al., VAQEM: A Variational Approach to Quantum Error Mitigation, 2021, [arXiv:2112.05821].
[38] L. Cincio, Y. Suba¸sı, A. T. Sornborger and P. J. Coles, New Journal of Physics 20, 113022 (2018).

