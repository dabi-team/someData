2
2
0
2

t
c
O
7

]

M
D
.
s
c
[

2
v
8
5
4
0
0
.
8
0
2
2
:
v
i
X
r
a

A heuristic technique for decomposing
multisets of non-negative integers
according to the Minkowski sum

Luciano Margara

Department of Computer Science and Engineering
University of Bologna
Via dell’Universit`a 50, 47521 Cesena, Italy
luciano.margara@unibo.it

October 10, 2022

Abstract

We study the following problem. Given a multiset M of non-negative integers,
decide whether there exist and, in the positive case, compute two non-trivial mul-
tisets whose Minkowski sum is equal to M. The Minkowski sum of two multisets
A and B is a multiset containing all possible sums of any element of A and any
element of B. This problem was proved to be NP-complete when multisets are re-
placed by sets. This version of the problem is strictly related to the factorization of
boolean polynomials that turns out to be NP-complete as well. When multisets are
considered, the problem is equivalent to the factorization of polynomials with non-
negative integer coefﬁcients. The computational complexity of both these problems
is still unknown.

The main contribution of this paper is a heuristic technique for decomposing
multisets of non-negative integers. Experimental results show that our heuristic de-
composes multisets of hundreds of elements within seconds, independently of the
magnitude of numbers belonging to the multisets. Our heuristic can also be used
for factoring polynomials in N[x]. We show that, when the degree of the polyno-
mials gets larger, our technique is much faster than the state-of-the-art algorithms
implemented in commercial software like Mathematica and MatLab.

Keywords: multisets, polynomials, decomposition, heuristics.

1 Introduction

The idea of decomposing a mathematical object into the sum (product, or other opera-
tions) of smaller ones is deﬁnitely not new. A huge literature has been devoted to the
factorization of numbers, polynomials, matrices, graphs and many other mathematical
objects, including sets and multisets. The basic idea behind factorization is decompos-
ing a complex object into smaller and easier to analyze pieces. Properties satisﬁed by

1

 
 
 
 
 
 
each piece might shed some light on the properties satisﬁed by the entire object. As an
example, from irreducible factors of a polynomial, we can recover valuable information
about its roots.

In this paper, we study the decomposition of multisets of non-negative integers ac-
cording to the Minkowski sum. Multisets are an extension of the notion of sets where,
basically, multiple copies of the same element are allowed. The Minkowski sum is a
binary operation that can be applied both to sets and multisets. The Minkowski sum of
two multisets A and B is a multiset containing all possible sums of any element of A
and any element of B.

Given a multiset M of non-negative integers, the decomposition problem asks for com-
puting two non-trivial multisets whose Minkowski sum is equal to M.

Multisets theory have applications in many ﬁelds [17], e.g., in combinatorics [1, 18,
19], in the theory of relational databases [9, 10, 14], in multigraphs theory [5, 6] and in
computational geometry [7]. The problem of decomposing multisets of non-negative
integers is strictly related to the problem of factoring univariate polynomials with non-
negative coefﬁcients (see Section 2.1 for details). Even if this problem arises in a very
natural way in a number of different theoretical and practical contexts, it has not been
thoroughly studied (see for example [2, 3, 20]) and its computational complexity is still
unknown. To our knowledge, no polynomial time algorithm nor an NP-completeness
proof exists. When multisets are replaced by sets, the decomposition problem was
proved to be NP-complete [13]. Other variants of the Minkowski sum decomposition
problem have been studied. As an example, in [8] the authors study the Minkowski
decomposition of integral convex polytopes proving that the decisional version of this
problem is again NP-complete.

The main contribution of this paper is a heuristic technique for decomposing multisets
of non-negative integers which, in turn, can be applied to factoring polynomials with
non-negative coefﬁcients.

The idea behind our algorithm is to transform the decomposition problem in an op-
timization problem by introducing a score function for candidate solutions. A candidate
solution is an approximation of a solution. The score function measures the quality of
candidate solutions, i.e., the similarity to the actual solution (not necessarily unique).
The score function reaches its maximum (whose value is known in advance) only at a
solution for the problem. Our algorithm starts from a randomly generated candidate so-
lution s0 and iteratively improves it until it ﬁnds a local optimum candidate solution sk
according to the score function. If sk reaches the maximum score the algorithms termi-
nates, otherwise it starts over from another initial candidate solution computed starting
from sk. The maximum number of iterations is bounded by a predetermined threshold.

We extensively tested our algorithm over randomly generated instances of different
size and structure. Experimental results (see Section 4 and Tables in Appendix A and
B) show that after a small number of iterations our algorithm almost always ﬁnds a
solution.

As far as polynomial with non-negative coefﬁcients factorization is concerned, no
efﬁcient and speciﬁcally designed algorithms are known. A possible natural strategy to

2

solve this problem might consist of factoring the polynomial in Z[x] (this can be done
in polynomial time) and then suitably grouping factors in Z[x] in order to get factors
in N[x]. Unfortunately, there exists no efﬁcient algorithm to perform the grouping of
factors whose number can be, in general, exponentially large. In our opinion, this is
an interesting problem in itself. Since decomposing multisets of non-negative integers
is equivalent (under some conditions we will discuss in Section 2.1) to the problem of
factoring polynomials in N[x], the alternative strategy might also be used for decom-
posing multisets. In Section 5 we make a comparison between our algorithm and the
alternative strategy depicted above unrealistically assuming that the grouping of factors
can be computed for free. We used built-in functions provided in Wolfram Mathematica
language for integer polynomials factorization (similar results have been found using
MatLab).

Experimental results clearly show (see Tables 13,14 and 15 in Appendix B) that, when
the degree of polynomials increases, our technique is much faster than going through
factoring. Reversing the line of reasoning, i.e., using multisets decomposition techniques
for factoring polynomials in N[x], our heuristics becomes a serious candidate to be the
ﬁrst effective method for factoring polynomials with non-negative coefﬁcients.

The rest of this paper is organized as follows. In Section 2 we give basic deﬁnitions
and known results. In Section 3 we describe our heuristics and we provide its pseu-
docode. In Section 4 we show experimental results. In Section 5 we make a comparison
between our algorithm and an alternative strategy for decomposing multisets based on
integer polynomial factorization. Section 6 contains conclusions and some ideas for
further works. Appendices A and B contain tables with experimental data.

2 Deﬁnitions and Known Results

Let Z be the set of integers and Z[x] be the sets of univariate polynomials with coefﬁ-
cients in Z. Let N be the set of non-negative integers and N[x] be the sets of univariate
polynomials with coefﬁcients in N.

Multisets are an extension of the concept of sets. While a set can contain only one oc-
currence of any given element, a multiset may contain multiple occurrences of the same
element. To distinguish multisets from sets, we will represent multisets by using double
braces. As an example M =
is a multiset. Given a multiset
2, 2, 3, 3, 5, 5, 5, 5, 5, 6, 8, 8
M we denote by µ(x, M) the number of occurrences (possibly 0) of the element x in M.
Sometimes we will represent a multiset M as a set of pairs (element, µ(element, M). With
this notation, the above multiset can be written as M =
.
}
In what follows, we will consider sets and multisets of numbers. This enable us to de-
) sometimes called Minkowski
ﬁne a binary operation on them (denoted by the symbol
sum. We will use the symbol
both for sets and multisets sum inferring the type of
operation from the type of operands.

(2, 2), (3, 2), (5, 5), (6, 1), (8, 2)

{{

}}

⊕

⊕

{

Deﬁnition 1 (Minkowski Set Sum). The Minkowski sum of two sets A and B is a set deﬁned
as follows.

B =

A

⊕

{

a + b : a

∈

A and b

B

}

∈

3

Example 2. Example of set sum. Let A =

2, 5
}
. Since we are working with sets, the multiplicity of 5 in A

and B =

2, 3, 5, 6, 8

0, 1, 3

}

{

{

{
can be obtained both as 0 + 5 and 3 + 2.

}

. Then A

B =
B is 1 even if 5

⊕

⊕

Deﬁnition 3 (Minkowski Multiset Sum). The Minkowski sum of two multisets A and B is a
multiset given by

A

B =

a + b : a

A and b

B

}}

∈

∈

{{
Example 4. Examples of multiset sum.
Let A =
Let A =

0, 1, 3
}}
0, 1, 3, 3

{{
and B =

and B =

}}
2, 2, 5

2, 5

⊕

}}

{{

}}

{{
{{

. Then A

B =

2, 3, 5, 5, 6, 8

⊕

. ThenA

{{
B =

⊕

2, 2, 3, 3, 5, 5, 5, 5, 5, 6, 8, 8

.

}}

.

}}

{{
0

{

}

The identity element with respect to the set sum is

. A multiset A is contained in a multiset B (A

and the identity element with
B)

respect to the multiset sum is
if and only if

0

}}

{{

⊆

We also deﬁne the multiset difference operation (denoted by the

symbol) as follows.

x

∀

∈

A : x

∈

B and µ(x, A)

µ(x, B)

≤

(1)

A

\
As an example,

2, 2, 3, 3, 5, 6, 8, 8

2, 3, 3, 3, 5, 9

{{

}} \ {{

B =

{

(x, mx) : x

∈

A and mx = max(µ(x, A)

}

(2)

\
µ(x, B), 0)

−
2, 6, 8, 8

.

}}

=

}}

{{

We now introduce the notion of reducible multisets (sets) of non-negative integers.

Deﬁnition 5 (Reducible multiset (set)). A multiset (set) M of non-negative integers is re-
ducible if and only if there exist two multisets (sets) A and B, both of them different from the
identity element, such that M = A

B.

⊕

A multiset (set) M of non-negative integers is irreducible (sometimes called prime)
if and only if it is not reducible. We are now ready to state the following two problems.
Deﬁnition 6 (set-red). Given a set S of non-negative integers, decide whether S is reducible
or not.
Deﬁnition 7 (multiset-red). Given a multiset M of non-negative integers, decide whether M
is reducible or not.

The following result was proved in [8].

Theorem 8. set-red is NP-complete.

Unlike set-red, the computational complexity of multiset-red is, to our knowledge,

still unknown. This leads us to state the following open question.
Question 9. Is multiset-red NP-complete ?

Even if we have deﬁned set-red and multiset-red in their decisional version, in
the rest of this paper we will refer to them (with a little abuse of notation) as con-
structive problems, i.e, the problem of effectively computing two multisets (sets) whose
Minkowski sum is equal to the multiset (set) received as input.

In the next example we show that the irreducible factorization of non-negative inte-
ger multisets is not unique. This makes the problem of factoring multisets even harder,
if possible.

4

Example 10. Let M =

0, 1, 2, 3, 4, 5

. Then

}}

{{

M =
=

Multisets

0, 1

,

}}

{{

{{

0, 2, 4

,

}}

{{

0, 3

}}

{{
{{
and

0, 1

0, 3

}} ⊕ {{
}} ⊕ {{

0, 1, 2

}}

{{

0, 2, 4

.

0, 1, 2

}}
}}
are irreducible.

2.1 Multisets decomposition and polynomials factorization

One of the most studied problem in computer algebra is the problem of factoring poly-
nomials. A huge literature has been devoted to the factorization of polynomials (without
claim of exhaustiveness see [11, 15, 12]). The ﬁrst polynomial factorization algorithm
was published by Theodor Von Schubert in 1793 [16]. Since then, dozens of papers
on the computational complexity of polynomial factorization have been published. In
1982, Arjen K. Lenstra, Hendric W. Lenstra, and L´aszl ´o Lov´asz [15] published the ﬁrst
polynomial time algorithm for factoring polynomials over Q and then over Z.

The problem of factoring polynomials over a ring can be, in a sense, labeled as “well
studied” and “efﬁciently solved”. The same cannot be said when rings are replaced
by semirings (e.g. the natural numbers). Unlike the case of factoring polynomials over
rings, the problem of factoring polynomials over semirings has received far less atten-
tion, there are far fewer known results and many interesting unanswered questions. One
of them is the following.

Question 11 (N-poly-red). Given a polynomial p(x)
ducible in N[x].

∈

N[x], decide whether p(x) is re-

As far as we know, for the N-poly-red problem, there are neither polynomial algo-
rithms to solve it nor proofs of NP-completeness. N-poly-red problem is strictly related
to the multiset-red problem.

To any given polynomial p(x)

N[x] it is possible to associate a multiset as follows.

∈

+ anxn be any element of N[x]. We deﬁne the multiset

Let p = a0 + a1x + a2x2 +

· · ·

a0

ai

Multiset(p) =

0, . . . , 0, . . . ,
z }| {

i, . . . , i, . . . ,
z }| {

{{

an
n, . . . , n
z }| {

}}

On the other hand, we can associate to any multiset

M =

m1
n1, . . . , n1,
{
}|
z

{{

m2

md

n2, . . . , n2, . . . ,
z

}|

{

nd, . . . , nd}}
z
}|

{

the polynomial

Polynomial(M) = m1xn1 + m2xn2 +

+ mdxnd

· · ·

(3)

(4)

It is not difﬁcult to verify that
- Polynomial(Multiset(p)) = p and Multiset(Polynomial(M)) = M
- Multiset(p q) = Multiset(p)
- Polynomial(A

B) = Polynomial(A) Polynomial(B)

Multiset(q) and

⊕

⊕

5

As a consequence of these properties we have that
- M is an irreducible multiset of non-negative integers if and only if
Polynomial(M) is an irreducible polynomial over N[x] and
- p is an irreducible polynomial over N[x] if and only if Multiset(p) is an irreducible
multiset of non-negative integers.

Unfortunately, in the general case, the size of Multiset(p) may be exponentially
larger than the size of p. This prevents us from readily translating computational com-
plexity results for multiset-red into equivalent results for N-poly-red and viceversa.

Taking advantage of Example 10 we show that the irreducible factorization of poly-

nomials in N[x] is not unique.

Example 12. Let p(x) = 1 + x + x2 + x3 + x4 + x5. The complete factorization of p(x) in
Z[x] is p(x) = (1 + x)(1
N[x] and
(1

−
N[x], then we have two distinct factorizations of p(x) in N[x].

x + x2)(1 + x + x2). Since (1 + x)(1

x + x2)(1 + x + x2)

x + x2)

−

∈

−

∈

p(x) = (1 + x)(1 + x2 + x4)
= (1 + x3)(1 + x + x2)

3 The Heuristics

In this section we provide a complete description of our heuristics by using pseudocode
(for details see pages from 20 to 22 in [4]).

0

=

Given a multiset M of n non-negative integer numbers, a candidate solution for M
M and m divides n. A
) of cardinality m such that A
is any multiset A (A
candidate solution A for M is also a solution for M if and only if there exists another
) for M such that M = A
candidate solution B (B
B. Given a candidate solution
A for M, deciding whether A is also a solution for M can be done in polynomial time.
Given a solution A for M, computing B such that M = A
B can be done in polynomial
time.

{{

}}

}}

{{

⊕

⊕

⊆

=

0

Our heuristics starts from an initial candidate solution of a given cardinality and itera-
tively improves it (according to a given score function) until it ﬁnds a solution.

The cardinality m of the initial candidate solution is unknown in advance but must
divide the cardinality of M. For computing an actual decomposition of a multiset M of
√n.
cardinality n we have to run our algorithm on all possible factors f of n with f
We are aware that this leads to an overhead of computation, but luckily, the number of
factors of any positive integer n (not exceeding √n) is very small if compared to n. For
every positive integer n, with 100
100.000, we computed its number of factors
divided by n. It turns out that the average of these ratios is 0.00025 and the maximum is
0.058 (higher values are obtained for small numbers). For these reasons, in what follows,
we will assume that the target cardinality of solutions is known.

≤

≤

≤

n

We now give the pseudocode of each function used in our heuristics and a short expla-
nation on how it works.

6

6
6
InitialSolution(M, n)
1 m = Round(M.length/2)
2 M = Sort(M)
3 M = M[1 . . m]
4 M = RandomSample(M, n)
5 return M

InitialSolution takes as input a multiset M and a non-negative integer n that divides
the cardinality of M and returns a candidate solution of cardinality n.

col matrix whose entries are set to 0

\

⊆

×

Score(M, S)
1 // invariant: S[1] = 0
2 // invariant: S
M
3 // invariant: S.length divides M.length
4 col = S.length
5 row = M.length/col
6 // Let mat be an row
7 r = M
S
8 // ﬁrst row of mat gets S
score = col
9
10 for i = 2 to row
w = Min(r)
11
r = r
w
12
score = score + 1
13
// mat[row, 1] = w
14
for j = 2 to col
15
16
17
18
19
20
21
22 return score

c = w + S[j]
if c
r
∈
r = r
c
}
score = score + 1
// mat[row, col] = c

else return score

\ {

\ {

}

Score takes as input a multiset M and a candidate solution S for M and returns a
positive integer measuring the quality of S. Score(M, S) ranges from length of S (lowest
If Score(M, S) = length of M then S is a
quality) to length of M (highest quality).
solution for M.

To better understand how Score works, we describe its behavior on the following

example. Let A =

0, 1, 3, 3

, B =

0, 2, 2, 6

, and

}}

{{

{{
M = A

}}
B =

⊕

0, 1, 2, 2, 3, 3, 3, 3, 5, 5, 5, 5, 6, 7, 9, 9

{{

}}

Assume now to run Score(M, B). Since B is a solution for M, Score(M, B) returns 16,
i.e., the length of M. The matrix mat described (but not computed) at lines 6,8,14 and 20

7

would be

mat =

0 2 2 6
1 3 3 7
3 5 5 9
3 5 5 9













and the elements of mat would give exactly the multiset M.
Assume now to run Score(M, C). Where C =
not a solution. Score(M, C) returns 6. The matrix mat would now have the form

0, 1, 2, 6

{{

}}

is a candidate solution but

mat =

0 1 2 6
2 3 0 0
0 0 0 0
0 0 0 0













The element at row 2 and column 3 (2 + 2 = 4) in mat cannot be found in M (note that
we have already removed 0, 1, 2, 6, 2 and 3 from M) and then Score(M, C) stops at line
21 returning 6, i.e., the number of elements correctly placed in mat until that moment.
Last case. Assume to run Score(M, C). Where C =
is again a candidate
solution but not a solution. Score(M, C) returns 11. The matrix mat would have now
the form

0, 2, 2, 5

{{

}}

mat =







0 2 2 5
1 3 3 6
3 5 5 0
0 0 0 0







The element at row 3 and column 4 (3 + 5 = 8) in mat cannot be found in M and then
Score(M, C) stops at line 21 returning 11, i.e., the number of elements correctly placed
in mat until that moment.

alternatives = DeleteDuplicates(M

NeighborSearch(M, S)
1 // invariant: S[1] = 0
2 // invariant: S.length divides M.length
3 initial score = Score(M, S)
4
5 for i = 2 to S.length
6
7
8
9
10
11
12
13 return (initial score, S)

temp = S[i]
S[i] = alternatives[j]
new score = Score(M, S)
if new score > initial score
return (new score, S)

for j = 1 to alternatives.length

else S[i] = temp

\

S)

NeighborSearch takes as input a multiset M and a candidate solution S for M and
returns a candidate solution N in the neighborhood of S such that Score(M, N) >
Score(M, S), if any. Returns S, otherwise.

8

Given a multiset M and a candidate solution S for M, a neighbor of S is any can-
didate solution for M differing from S for exactly 1 element. To speed up the process,
NeighborSearch returns (line 11) the ﬁrst improved candidate solution found.

current score = Score(M, S)

FindLocalOpt(M, S)
1 // invariant: S[1] = 0
2 n = M.length
3
4 while true
5
6
7
8
9
10

return (true, S)
if score == current score
return (false, S)
current score = score

(score, S) = NeighborSearch(M, S)
if score == n

FindLocalOpt takes as input a multiset M and a candidate solution S for M and returns
a candidate solution N with the property of being the best candidate solution in its
neighbor, i.e., a local optimum. To accomplish this task, FindLocalOpt keeps on calling
NeighborSearch on improved solutions until no more improvement is found. Note
that the candidate solution N produced by FindLocalOpt is not guaranteed to be a
solution.

current solution = InitialSolution(M, m)

( f ound, S) = FindLocalOpt(M, current solution)
if f ound

IteratedSearch(M, m, iterations)
1 // invariant: m divides M.length
2
3 for i = 1 to iterations
4
5
6
7
8
9 return solution not found

return S

current solution = NewInitialSolution(M, current solution)
// note that current solution contains 0

IteratedSearch takes as input a multiset M, an integer m > 1 dividing the cardinal-
ity of M and an upper bound on the number of iterations and returns a solution of
cardinality m, if found. IteratedSearch keeps on calling FindLocalOpt with different
initial candidate solutions (computed by NewInitialSolution) until a solution is found
or the maximum number of iterations is exceeded.

9

col matrix whose entries are set to 0

\

×

NewInitialSolution(M, S)
1 // invariant: S[1] = 0
2 // invariant: all the elements of S are in M
3 // invariant: S.length divides M.length
4 col = S.length
5 row = M.length/col
6 // Let mat be an row
7 R = M
S
8 // ﬁrst row of mat gets S
9 new set = S
10 for i = 2 to row
11
12
13
14
15
16
17
18
19
20
21
22 return RandomSample(new set, col)

c = w + S[j]
if c
R
∈
r = R
c
}
// mat[row, col] = c

w = Min(R)
R = R
w
\ {
new set = new set
// mat[row, 1] = w
for j = 2 to col

S{

\ {

w

}

}

else return RandomSample(new set, col)

// RandomSample(new set, col) must contain 0

NewInitialSolution takes as input a multiset M and a candidate solution S for M and
returns a new initial candidate solution.
To better understand how NewInitialSolution works, we show its behavior on an
example. Let A =

0, 1, 3, 3

0, 2, 2, 6

, B =

, and

{{
M = A

}}
B =

⊕

{{

}}

0, 1, 2, 2, 3, 3, 3, 3, 5, 5, 5, 5, 6, 7, 9, 9

{{

}}

Assume to run NewInitialSolution(M, C). Where C =
solution but not a solution. The matrix mat, if computed, would have the form

0, 2, 2, 5

{{

}}

is a candidate

mat =

0 2 2 5
1 3 3 6
3 5 5 0
0 0 0 0













NewInitialSolution(M, C) stops at line 20 returning
, i.e., the union
of the ﬁrst row of mat and the initial part (ﬁrst 3 elements) of the ﬁrst column of mat.
Experimental results clearly show that solutions to the problem contains with high prob-
ability elements placed in the ﬁrst row or in the ﬁrst column of the matrix mat associated
to the local optimum candidate solution.

0, 2, 2, 5, 1, 3

{{

}}

10

4 Experimental results

We tested our algorithm on an iMac equipped with a 4.2 GHz Intel Core i7 quad-core
processor and 32 GB RAM (2400 MHz DDR4 ). Operating System: macOS Monterey
Version 12.2.1. Our algorithm has been implemented in Wolfram Mathematica language
(Version 12). To make the code more readable even to those unfamiliar with the Mathe-
matica language, we decided to describe it providing a pseudocode version (see Section
3).

Our algorithm has been extensively tested over instances (multisets of non-negative
integers) of different size and structure. Instances depend on two parameters, namely
structure and range, and have been generated according to the following procedure.

0

{{

InstanceGeneration(structure, range)
1 inst =
}}
2 for i = 1 to structure.length
3
4
5
6
7
8 return inst

⊕

Let M be a multiset with the following properties:
- cardinality of M is equal to structure[i]
- M contains at least one element equal to 0
- each element of M is randomly chosen in the interval [0 . . range]
inst = inst

M

The parameter structure is a list of positive integers representing the cardinalities of
the multisets that, once summed together, produce the instance. The parameter range
represents an upper bound on the numbers in the multisets (see line 6 of InstanceGen-
eration). As an example, the instance produced by InstanceGeneration(
, 10)
2,2,3
}
{
is a multiset of cardinality 12 = 2
3 obtained by summing up 3 randomly gen-
2
erated multisets of cardinality 2, 2 and 3, respectively. Each element of the 3 multisets
is randomly chosen from the set
. We only consider multisets contain-
In fact, any multiset M that does not con-
ing at least one element equal to zero.
tain 0, i.e., µ(0, M) = 0, can be always decomposed as
min(M)
M′ where M′
is a multiset obtained from M subtracting to each element min(M). As an example,

0, 1, . . . , 10

}} ⊕

{{

×

×

}

{

2, 4, 3, 4, 3, 5

=

2

0, 2, 1, 2, 1, 3

.

}}

{{
For each structure and range, we tested our algorithms on a large number of instances
collecting results in Tables 1 to 12 in Appendix A.

}} ⊕ {{

}}

{{

Columns of Tables contain the following data.
1. Size: size of the input, i.e., cardinality of the considered multiset
2. Structure: structure of the considered multiset
3. Success: percentage of runs for which a solution is found
4. Iterations: Average number of iterations for any given structure
5. Time: Average running time for any given structure
6. Time/Iter: Time divided by Iterations
7. Time/Size: Time divided by Size

We investigated the performance of our algorithm in different scenarios.

11

Number of duplicates. We tested our algorithm with two different values of the param-
eter range. Namely, range = 5 and range = 10000. In the case of range = 5, multisets
contain a large number of duplicates, while in the case of range = 10000 duplicates are
very rare.

Type of structure. We tested our algorithm with 3 different type of structures

.

{

n, . . . , n

2 n, n
and
}
n, n
: sum of two multisets with the same cardinality;
}
2 n, n
n, . . . , n

}

}

{
-
-
-

: sum of k multisets with the same cardinality (denoted by

: sum of two multisets with different cardinalities (one half of the other);

n, n

,

}

{

{
{
{

}

k).

n

{

}

We now give some reading keys and interpretations of experimental data collected in
Tables 1 to 12 in Appendix A.
IteratedSearch ﬁnds a solution most of the time. Leaving unbounded the maximum
number of allowed iterations, IteratedSearch always ﬁnds a solution. From a practical
point of view, leaving unbounded the number of iterations prevents the algorithm to
recognize irreducible multisets. In our tests we set the maximum number of iterations
equal to 100. Even in this case, IteratedSearch is able to ﬁnd a solution approximately
999 times out of 1000.

Multisets with many duplicates approximately takes the same amount of time to de-
compose with respect to multisets with a small number of duplicates. The presence of
many duplicates forces the heuristics to go through a larger number of iterations to ﬁnd
a solution but single iterations are much faster. With many duplicates, the behavior of
IteratedSearch is less regular in terms of running times and distribution of failures.

Multisets obtained summing up many small multisets are much easier to decompose
with respect to multisets obtained summing up 2 large multisets. As an example, a
15 and size 32768 takes approximately the same time (last
multiset with structure
and size 400 (last row of Table
row of Table 3) of a multiset with structure
2). For multisets obtained summing up many small multisets, the average number of
iterations is very close to 1.

20, 20

}

}

{

{

2

5 Polynomial Factorization vs Iterated Search

An alternative strategy for decomposing a multiset of non-negative integers (or, equiv-
alently, an intuitive way of factoring a polynomial in N[x]) might be the following.

AlternativeStrategy(M)
1 // M is a multiset of non-negative integers
2 p = Polynomial(M)
3 ﬂ = FactorList(p)
(P1, P2) = Group(ﬂ)
4
5 return (Multiset(P1), Multiset(P2))

Line 2 computes the polynomial p associated to the multiset M as shown in Equation
(4). Line 3 computes the factor list f l of p. Line 4, using some unknown algorithm (it

12

would be of some interest to ﬁnd an algorithm for efﬁciently computing Group(ﬂ)),
computes a partition P =
(if there exists one) of the factor list ﬂ such that the
product of all the polynomials in P1 and the product of all the polynomials in P2 have
non-negative coefﬁcients.

P1, P2}

{

In what follows we will assume that the computational cost of Line 4 is zero. Ta-
ble 13 to 15 compare running times of IteratedSearch and AlternativeStrategy for
multisets with homogeneous structure and increasing ranges.

For computing the factor list at Line 3 of AlternativeStrategy we make use of the
function FactorList provided by Mathematica Language (similar results are obtained
by using the function factor of MatLab).

Experimental results (see Tables 13,14 and 15) clearly show that the running time of
IteratedSearch is independent of the magnitude of numbers in the multisets (expo-
nents in the polynomials). IteratedSearch is much faster than AlternativeStrategy
in the case of multisets containing large numbers and small multiplicity.

Doing the reverse path enable us to give a new technique for decomposing polyno-

mials in N[x] based on IteratedSearch.

∈

N-PolyFact(p)
1 // p
N[x]
2 M = Multiset(p)
3 S = IteratedSearch(M) //
4 P = Polynomial(S)
5 return (Polynomial(S), p/P)

We end this section by giving an example of a small multiset M of non-negative

integers that IteratedSearch decomposes in 0.008 seconds.
AlternativeStrategy (both using Mathematica and MatLab factorization primitives)
called on the same multiset, after 24 hours of computation, was unable to ﬁnd any
solution.

A =

B =

0, 1249, 4270, 4324, 4852

{{

}}

0, 1705, 2250, 2267, 4390

{{

}}

M = A

B =

⊕

0, 1249, 1705, 2250, 2267, 2954, 3499, 3516, 4270, 4324, 4390, 4852, 5639,

{{
5975, 6029, 6520, 6537, 6557, 6574, 6591, 7102, 7119, 8660, 8714, 9242

}}

Polynomial(M) = 1 + x1249 + x1705 + x2250 + x2267 + x2954 + x3499 + x3516 + x4270 +

x4324 + x4390 + x4852 + x5639 + x5975 + x6029 + x6520 + x6537 +
x6557 + x6574 + x6591 + x7102 + x7119 + x8660 + x8714 + x9242

13

6 Conclusions and further work

We have introduced and analyzed a heuristic technique for decomposing multisets of
non-negative integers according to the Minkowski sum. Experimental results show that
our technique allows to decompose quite large multisets (hundreds to thousands of
elements depending on the instance structure) in seconds. Our technique can also be
used to tackle the problem of factoring polynomials in N[x]. Experimental results show
that, when the size of exponents (elements of multisets) increases, our technique is much
faster than state-of-the-art implementation of polynomial factoring algorithms over Z[x]
that can be viewed as a preparatory step for factoring over N[x].

A natural extension of this work is replacing non-negative integers with more com-
It would be of some interest to investigate the case of d
plex mathematical objects.
dimensional vectors of non-negative integers with d > 1. The problem of decomposing
multisets of d dimensional vectors is strictly related to the problem of factoring multi-
variate polynomials with non-negative coefﬁcients, but also to a number of problems
arising, for example, in the ﬁeld of computational geometry and seems to be more chal-
lenging than the 1 dimensional case.

It would be interesting to investigate whether the combination of the results obtained
by using our algorithm on single components of the d dimensional object can be of any
help for solving the global problem.

References

[1] I. Anderson. Combinatorics of Finite Sets. Dover books on mathematics. Dover Pub-

lications, 2002.

[2] H. Brunotte. On some classes of polynomials with nonnegative coefﬁcients and a

given factor. Periodica Mathematica Hungarica, 67(1):15–32, 2013.

[3] F. Campanini and A. Facchini. Factorizations of polynomials with integral non-

negative coefﬁcients. Semigroup Forum, 99(2):317–332, 2019.

[4] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algorithms.

The MIT Press, 3rd edition, 2009.

[5] M. DeVos, R. Krakovski, B. Mohar, and A. Sheikh Ahmady. Integral cayley multi-
graphs over abelian and hamiltonian groups. The Electronic Journal of Combinatorics,
20(2), Jun 2013.

[6] A. Dudek, A. Frieze, A. Ruci ´nski, and M. ˇSileikis. Approximate counting of regular

hypergraphs. Information Processing Letters, 113(19):785–788, 2013.

[7] I. Z. Emiris, A. Karasoulou, and C. Tzovas. Approximating multidimensional sub-
set sum and minkowski decomposition of polygons. Mathematics in Computer Sci-
ence, 11(1):35–48, 2017.

[8] S. Gao and A. G. B. Lauder. Decomposition of polytopes and polynomials. Discrete

& Computational Geometry, 26(1):89–104, 2001.

14

[9] S. Grumbach and T. Milo. Towards tractable algebras for bags. J. Comput. Syst. Sci.,

52(3):570–588, 1996.

[10] F. Henglein, R. Kaarsgaard, and M. K. Mathiesen. The programming of algebra.

CoRR, abs/2207.00850, 2022.

[11] M. Van Hoeij. Factoring polynomials and the knapsack problem. Journal of Number

Theory, 95(2):167–189, 2002.

[12] E. Kaltofen. Polynomial factorization 1987-1991. In Imre Simon, editor, LATIN ’92,
1st Latin American Symposium on Theoretical Informatics, S˜ao Paulo, Brazil, April 6-10,
1992, Proceedings, volume 583 of Lecture Notes in Computer Science, pages 294–313.
Springer, 1992.

[13] K. H. Kim and F. W. Roush. Factorization of polynomials in one variable over the

tropical semiring. https://arxiv.org/abs/math/0501167, 2005.

[14] G. Lamperti, M. Melchiori, and M. Zanella. On multisets in database systems.

volume 2235, pages 147–216, 08 2000.

[15] A. K. Lenstra, H. W. Lenstra, and L. Lov´asz. Factoring polynomials with rational

coefﬁcients. Mathematische Annalen, 261:515–534, 1982.

[16] F. T. Schubert. De inventione divisorum. Nova Acta Academiae Scientiarum Petropoli-

tanae, 11:172–182, 1793.

[17] D. Singh, A. M. Ibrahim, T. Yohanna, and J. N. Singh. An overview of the applica-

tions of multisets. Novi Sad Journal of Mathematics, 37(2):73–92, 2007.

[18] R. P. Stanley. Enumerative Combinatorics, volume 1 of Cambridge Studies in Advanced

Mathematics. Cambridge University Press, 2 edition, 2011.

[19] R. P. Stanley and S. Fomin. Enumerative Combinatorics, volume 2 of Cambridge Studies

in Advanced Mathematics. Cambridge University Press, 1999.

[20] C. E. Van de Woestijne. Factors of disconnected graphs and polynomials with
nonnegative integer coefﬁcients. Ars Mathematica Contemporanea, 5(2):307–323, Apr
2012.

15

A Experimental Data Tables I

Table 1: Range = 5. Number of tested instances for each structure: 1000.

Size
9
16
25
36
49
64
81
100
121
144
169
196
225
256
289
324
361
400

Structure
3, 3
{
}
4, 4
{
}
5, 5
{
}
6, 6
{
}
7, 7
{
}
8, 8
{
}
9, 9
}
{
10, 10
}
{
11, 11
}
{
12, 12
}
{
13, 13
}
{
14, 14
}
{
15, 15
}
{
16, 16
}
{
17, 17
}
{
18, 18
}
{
19, 19
}
{
20, 20
}
{

Success
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
99.9
100

Iterations
1
1.14
1.4
1.9
2.6
3
4.22
4.22
7.06
4.72
11.7
7.02
7.14
8.16
10.72
9.56
11
18.5

Time
0.001
0.002
0.008
0.025
0.061
0.122
0.242
0.366
0.934
0.95
2.728
2.454
3.298
4.563
8.151
9.18
12.168
29.491

Time/Iter Time/Size

0.001
0.00175
0.00571
0.01316
0.02346
0.04067
0.05735
0.08673
0.13229
0.20127
0.23316
0.34957
0.4619
0.55919
0.76035
0.96025
1.10618
1.59411

0.00011
0.00012
0.00032
0.00069
0.00124
0.00191
0.00299
0.00366
0.00772
0.0066
0.01614
0.01252
0.01466
0.01782
0.0282
0.02833
0.03371
0.07373

16

Table 2: Range = 5. Number of tested instances for each structure: 1000.

Size
18
32
50
72
98
128
162
200
242
288
338
392
450

Structure
6, 3
}
{
8, 4
}
{
10, 5
}
{
12, 6
}
{
14, 7
}
{
16, 8
}
{
18, 9
{
}
20, 10
}
{
22, 11
}
{
24, 12
}
{
26, 13
}
{
28, 14
}
{
30, 15
}
{

Success
100
100
100
100
100
100
100
100
100
100
100
99.9
100

Iterations
1.24
1.92
2.52
3.1
3.58
4.68
6.44
9.22
7.56
9.4
15.8
12.1
11.62

Time
0.002
0.011
0.038
0.104
0.222
0.452
0.961
1.865
2.655
4.161
8.474
10.56
13.641

Time/Iter Time/Size

0.00161
0.00573
0.01508
0.03355
0.06201
0.09658
0.14922
0.20228
0.35119
0.44266
0.53633
0.87273
1.17392

0.00011
0.00034
0.00076
0.00144
0.00227
0.00353
0.00593
0.00932
0.01097
0.01445
0.02507
0.02694
0.03031

Table 3: Range = 5. Number of tested instances for each structure: 1000.

Size
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768

7

8

3

5

6

4

Structure
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{

}
}
}
}
}
}
}
10
}
}
}
}
}
}

11

13

12

14

15

9

Success
100
100
100
100
100
100
100
100
100
100
100
100
100

Iterations
1
1
1
1
1
1
1
1
1
1
1
1
1

Time
0.001
0.001
0.001
0.002
0.004
0.007
0.014
0.037
0.11
0.375
1.15
4.708
18.625

Time/Iter Time/Size

0.001
0.001
0.001
0.002
0.004
0.007
0.014
0.037
0.11
0.375
1.15
4.708
18.625

0.00012
0.00006
0.00003
0.00003
0.00003
0.00003
0.00003
0.00004
0.00005
0.00009
0.00014
0.00029
0.00057

17

Table 4: Range = 5. Number of tested instances for each structure: 1000.

Size
27
81
243
729
2187
6561
19683

4

5

3

Structure
3
3
3
3
3
3
3

}
}
}
}
}
}
}

{
{
{
{
{
{
{

7

6

9

8

Success
100
100
100
100
100
100
100

Iterations
1
1.04
1
1
1
1
1

Time
0.003
0.012
0.039
0.175
1.088
6.646
60.155

Time/Iter Time/Size

0.003
0.01154
0.039
0.175
1.088
6.646
60.155

0.00011
0.00015
0.00016
0.00024
0.0005
0.00101
0.00306

Table 5: Range = 5. Number of tested instances for each structure: 1000. For Size =
16384, due to time limits, we reduced the number of instances to 300.

Size
64
256
1024
4096
16384

4

3

Structure
4
4
4
4
4

7

5

6

{
{
{
{
{

}
}
}
}
}

Success
100
100
100
100
100

Iterations
1.1
1.02
1.06
1
1.24

Time
0.022
0.14
1.266
11.377
366.325

Time/Iter Time/Size

0.02
0.13725
1.19434
11.377
295.423

0.00034
0.00055
0.00124
0.00278
0.02236

Table 6: Range = 5. Number of tested instances for each structure: 1000. For Size =
15625, due to time limits, we reduced the number of instances to 300.

Size
125
625
3125
15625

3

Structure
5
5
5
5

6

5

4

{
{
{
{

}
}
}
}

Success
100
100
100
100

Iterations
1.38
1.26
1.12
1.08

Time
0.114
1.307
23.818
521.383

Time/Iter Time/Size

0.08261
1.0373
21.2661
482.762

0.00091
0.00209
0.00762
0.03337

18

Table 7: Range = 10000. Number of instances for each structure: 1000.

Size
9
16
25
36
49
64
81
100
121
144
169
196
225
256
289
324
361
400

Structure
3, 3
}
{
4, 4
}
{
5, 5
}
{
6, 6
}
{
7, 7
}
{
8, 8
}
{
9, 9
}
{
10, 10
}
{
11, 11
}
{
12, 12
}
{
13, 13
}
{
14, 14
}
{
15, 15
}
{
16, 16
}
{
17, 17
}
{
18, 18
}
{
19, 19
}
{
20, 20
}
{

Success
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100

Iterations
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1.4
1
1
1.02

Time
0.001
0.002
0.008
0.02
0.05
0.105
0.199
0.375
0.606
1.138
1.815
2.831
4.064
6.09
10.515
13.469
19.217
27.122

Time/Iter Time/Size

0.001
0.002
0.008
0.02
0.05
0.105
0.199
0.375
0.606
1.138
1.815
2.831
4.064
6.09
7.51071
13.469
19.217
26.5902

0.00011
0.00012
0.00032
0.00056
0.00102
0.00164
0.00246
0.00375
0.00501
0.0079
0.01074
0.01444
0.01806
0.02379
0.03638
0.04157
0.05323
0.0678

Table 8: Range = 10000. Number of instances for each structure: 1000.

Size
18
32
50
72
98
128
162
200
242
288
338
392
450

Structure
6, 3
}
{
8, 4
}
{
10, 5
}
{
12, 6
}
{
14, 7
}
{
16, 8
}
{
18, 9
}
{
20, 10
}
{
22, 11
}
{
24, 12
}
{
26, 13
}
{
28, 14
}
{
30, 15
}
{

Success
100
100
100
100
100
100
100
99.9
100
100
100
100
100

Iterations
2.22
1.78
2.2
1.76
1.72
1.96
3.02
6.14
2.68
1.64
2.26
2.06
3.18

Time
0.004
0.012
0.047
0.096
0.214
0.488
1.469
6.141
3.944
4.777
9.864
15.012
33.11

Time/Iter Time/Size

0.0018
0.00674
0.02136
0.05455
0.12442
0.24898
0.48642
100016
1.47164
2.9128
4.3646
7.28738
10.412

0.00022
0.00038
0.00094
0.00133
0.00218
0.00381
0.00907
0.0307
0.0163
0.01659
0.02918
0.0383
0.07358

19

Table 9: Range = 10000. Number of instances for each structure: 1000.

Size
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768

3

4

8

6

7

5

Structure
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{
2
{

}
}
}
}
}
}
}
10
}
}
}
}
}
}

14

12

11

15

13

9

Success
100
100
100
100
100
100
100
100
100
100
100
100
100

Iterations
1
1
1
1
1
1
1
1
1
1
1
1
1

Time
0.001
0.001
0.001
0.001
0.002
0.004
0.009
0.024
0.07
0.228
0.811
2.984
11.708

Time/Iter Time/Size

0.001
0.001
0.001
0.001
0.002
0.004
0.009
0.024
0.07
0.228
0.811
2.984
11.708

0.00012
0.00006
0.00003
0.00002
0.00002
0.00002
0.00002
0.00002
0.00003
0.00006
0.0001
0.00018
0.00036

Table 10: Range = 10000. Number of instances for each structure: 1000.

Size
27
81
243
729
2187
6561
19683

3

5

4

Structure
3
3
3
3
3
3
3

}
}
}
}
}
}
}

{
{
{
{
{
{
{

8

6

7

9

Success
100
100
100
100
100
100
100

Iterations
1
1
1
1
1
1
1

Time
0.002
0.008
0.028
0.139
0.916
7.047
72.214

Time/Iter Time/Size

0.002
0.008
0.028
0.139
0.916
7.047
72.214

0.00007
0.0001
0.00012
0.00019
0.00042
0.00107
0.00367

Table 11: Range = 10000. Number of instances for each structure: 1000. For Size =
16384, due to time limits, we reduced the number of instances to 300.

Size
64
256
1024
4096
16384

4

3

Structure
4
4
4
4
4

6

5

7

{
{
{
{
{

}
}
}
}
}

Success
100
100
100
100
100

Iterations
1.16
1.12
1.28
1.26
1.18

Time
0.021
0.148
1.54
21.532
355.661

Time/Iter Time/Size

0.0181
0.13214
1.20312
17.0889
301.408

0.00033
0.00058
0.0015
0.00526
0.02171

20

Table 12: Range = 10000. Number of instances for each structure: 1000. For Size = 3125
and Size = 15625, due to time limits, we reduced the number of instances to 100.

Size
125
625
3125
15625

3

Structure
5
5
5
5

4

6

5

}
}
}
}

{
{
{
{

Success
100
100
100
100

Iterations
1.62
5.2
7.7
3.4

Time
0.146
4.767
122.143
1689.16

Time/Iter Time/Size

0.09012
0.91673
15.8627
496.812

0.00117
0.00763
0.03909
0.10811

B Experimental Data Tables II

Table 13: Running times for IteratedSearch and AlternativeStrategy called on mul-
tisets with different range values and structure =
. Number of instances for each
range: 100.

5, 5

{

}

Size
25
25
25
25
25
25

Structure Range

IteratedSearch AlternativeStrategy

5, 5
5, 5
5, 5
5, 5
5, 5
5, 5

}
}
}
}
}
}

{
{
{
{
{
{

100
300
500
700
900
1100

0.09
0.008
0.009
0.008
0.007
0.01

0.144747
3.764507
22.003455
64.317906
161.541679
253.745332

21

Table 14: Running times for IteratedSearch and AlternativeStrategy called on mul-
tisets with different range values and structure =
. Number of instances for each
range: 100.

10, 10

}

{

Size
100
100
100
100
100
100

Structure Range

IteratedSearch AlternativeStrategy

10, 10
10, 10
10, 10
10, 10
10, 10
10, 10

}
}
}
}
}
}

{
{
{
{
{
{

100
300
500
700
900
1100

0.551
0.532
0.397
0.426
0.612
0.4

0.220502
4.213079
26.706801
75.783461
187.938575
379.374113

Table 15: Running times for IteratedSearch and AlternativeStrategy called on mul-
12. Number of instances for each
tisets with different range values and structure =
range: 100.

}

{

2

Size
4096
4096
4096
4096
4096
4096

Structure Range

IteratedSearch AlternativeStrategy

0.142596
2.682864
3.145838
6.137466
31.849028
356.950613

12

12

12

12

12

12

2
2
2
2
2
2

}
}
}
}
}
}

{
{
{
{
{
{

40
60
80
100
120
140

0.294
0.319
0.316
0.311
0.283
0.253

22

