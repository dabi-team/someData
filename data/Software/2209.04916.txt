2
2
0
2

p
e
S
1
1

]
E
S
.
s
c
[

1
v
6
1
9
4
0
.
9
0
2
2
:
v
i
X
r
a

Formal Semantics of the Kconﬁg Language
Technical Note

Steven She1 and Thorsten Berger2

1shshe@gsd.uwaterloo.ca, University of Waterloo, Canada
2berger@informatik.uni-leipzig.de, University of Leipzig, Germany

January 2010

Abstract

The Kconﬁg language deﬁnes a set of symbols that are assigned a value in a conﬁguration.
We describe the semantics of the Kconﬁg language according to the behaviour exhibited in the
xconﬁg conﬁgurator. We assume an abstract syntax representation for concepts in the Kconﬁg
language and delegate the details of the translation from concrete to abstract syntaxes to a later
document.

1 Abstract syntax

Identiﬁers and expressions. We start be deﬁning the preliminary concepts available in the
Kconﬁg language. Let Id be a ﬁnite set of names identifying a symbol—more precisely, Id ∈ P(String).
Let Const = Tri ∪ String ∪ Hex ∪ Int be the set of values assignable to each feature and available as
constants in expressions, where Tri = {0t, 1t, 2t}. Tri is ordered such that 0t < 1t < 2t. The Tri,
String, Hex, and Int domains are disjoint (i.e. mutually exclusive). We can now deﬁne an expression in
the Kconﬁg language. KExpr(Id) is a set of expressions over Id generated by the following grammar,
where e ∈ KExpr(Id), iv ∈ Id ∪ Const, ⊗ ∈ {or, and}, ⊖ ∈ {=, 6=}:

e ::= e ⊗ e | not e | iv ⊖ iv | iv

(1)

Evaluating a KExpr returns a tristate value (i.e. v ∈ Tri). We will deﬁne the semantics of an eval

function in Section 2.2.

Kconﬁg model. Kconﬁg denotes the set of all possible models in the Kconﬁg language. Thus
a single Kconﬁg model m ∈ Kconﬁg is a tuple consisting of a set of conﬁgs and a set of choices.
Kconﬁg is deﬁned as:

Kconﬁg = P(Conﬁgs) × P(Choices)

(2)

Given a Kconﬁg model m ∈ Kconﬁg, we deﬁne the shorthand mconﬁg to refer to its set of conﬁgs and
mchoice to refer to its set of choices.

0The semantics deﬁned in this document directly reﬂect the behavior of the Linux make xconﬁg tool, which could
 in some speciﬁc cases  act diﬀerently from what the Kconﬁg language developers originally had in mind. At least
in case of the reverse dependency the documentation explicitly states the following gap: "Select should be used with
care. Select will force a symbol to a value without visiting the dependencies. By abusing select you are able to select
a symbol foo even if foo depends on bar that is not set."

1

 
 
 
 
 
 
Conﬁgs are the primary components of a Kconﬁg model. A conﬁg deﬁnes a unique identiﬁer with
type, a prompt condition — a condition that determines when a conﬁg becomes user-changeable, a
list of defaults, a expression denoting its reverse dependency — the conditions that would forcefully
enable this feature through a select statement, and a set of ranges — restrictions on the value for
conﬁgs or hex type. We deﬁne Conﬁgsas follows:

Conﬁgs = Id × Type × KExpr(Id) × Default ∗ ×KExpr(Id) × P(Range)

(3)

where,

• Type = {boolean, tristate, int, hex, string} denotes a type and consequently the possible values

for the conﬁg.

• Default = KExpr(Id)×KExpr(Id) denotes defaults. The ﬁrst KExpr denotes a default expression
(i.e. that is evaluated and assigned to the symbol) and the second KExpr denotes the condition
required for the default to become eﬀective.

• Range = (Int ∪ Hex ∪ Id) × (Int ∪ Hex ∪ Id) × KExpr(Id) is a triple consisting of a lower bound,
an upper bound and a condition. Note the absence of Tri in the lower and upper bounds of
the range; this is due to ranges being only eﬀective on int and hex-typed conﬁgs as we will
describe in the following paragraph.

We further deﬁne a function Id(m) to denote identiﬁers of conﬁgs in the model m:

Id(m) = {n | (n, _, _, _, _, _) ∈ mconﬁg}

(4)

The second component of Kconﬁg refers to a set of choice nodes. A choice is an abstract construct
that deﬁnes no symbol in the conﬁguration, however, it imposes additional constraints on its nested
elements. We deﬁne choices as a quadruple consisting of a type where boolean or tristate are the
only valid types, a ﬂag indicating whether the choice is mandatory, a prompt condition followed by
a set of identiﬁers indicating its members. The set Choices is deﬁned as:

Choices = {boolean, tristate} × Bool × KExpr(Id) × P(Id(m))

(5)

Well-formedness rules. Given an element (_, t, _, _, rev, rngs) ∈ Conﬁgs, this conﬁg is well-
formed if the following conditions are satisﬁed:

• The reverse dependency of conﬁgs with type int, hex or string must be 0t. In other words, no

conﬁg may select a conﬁg that is not of type boolean or tristate.

(rev 6= 0t) =⇒ t = boolean ∨ t = tristate

(6)

• Ranges can only be deﬁned on conﬁgs with a numerical type, namely int or hex types. Thus,

the following constraint must hold for a conﬁg to be well-formed:

(|rngs| > 0) =⇒ t = int ∨ t = hex

(7)

Brief note on concrete syntax translation. Menuconﬁgs and menus are ﬁrst-class concepts
in the concrete syntax of the Kconﬁg language. However, both of these concepts are not present in
the abstract syntax. First, menuconﬁgs are semantically identical to conﬁgs and only diﬀer in terms
of its appearance in the conﬁgurator; thus, we model menuconﬁgs as conﬁgs in the abstract syntax.
Menus do not deﬁne a symbol; thus menus are not present in a conﬁguration. However, menus can
impose constraints on its nested elements. We handle these constraints via a syntactic rewrite on
the prompt, default and range conditions of all nested symbols. Details for this syntactic rewrite
will be provided in later document.

2

2 Semantics

2.1 Semantic domain

A conﬁguration of a Kconﬁg model is an assignment of values v ∈ Const to conﬁg elements. Thus,
the set of all possible conﬁgurations is deﬁned as:

Confs = Id → ⌊Const⌋

(8)

If c ∈ Confs and x ∈ Id, we write c(x) in order to refer to the value of identiﬁer x under the
conﬁguration c. Now, we deﬁne the semantics of a Kconﬁg model in terms of sets of conﬁgurations.
Thus, P(Confs) is our semantic domain. We deﬁne [[·]]kconﬁg as the function that evaluates a Kconﬁg
model and returns a set of valid conﬁgurations:

[[·]]kconﬁg : Kconﬁg → P(Confs)

(9)

2.2 Global functions

We start with the deﬁnition of some functions used throughout the semantics. First, we deﬁne an
interpretation of tristate values in boolean logic with bool : Tri → Bool where Bool = {T, F }:

bool(v) =

F iﬀ v = 0t
T

iﬀ v = 1t ∨ v = 2t

(

(10)

Moreover, we deﬁne a function access : (Id ∪ Const) × Confs → Const that retrieves the value of
either a constant or a symbol. When an identiﬁer has the value of ⊥ (to be deﬁned in Equation 14),
then the access function returns the identiﬁer itself in the form of a string:

access(iv, c) =

(

iﬀ iv ∈ Const ∨ (iv ∈ Id ∧ c(iv) = ⊥)

iv
c(iv) otherwise

(11)

Next, we deﬁne the function toStr : Const → String that models the translation of a constant to

a string representation. Let i ∈ Int, h ∈ Hex and s ∈ String, in the following deﬁnition of toStr:

toStr(0t) = “n”
toStr(i) = “” + i

toStr(1t) = “m”
toStr(h) = “0x” + h

toStr(2t) = “y”
toStr(s) = s

(12)

where the + operator is string concatenation.

Finally, the function eval : KExpr(Id) → Tri describes the evaluation of a KExpr in the Kconﬁg

language. We deﬁne eval recursively with e1, e2 ∈ KExpr(Id) and iv, ivx, ivy ∈ Id ∪ Const:

eval(ivx = ivy, c) =

(
eval(ivx 6= ivy, c) = 2t − eval(ivx = ivy, c)

2t
0t

iﬀ toStr(access(ivx, c)) = toStr(access(ivy, c))
otherwise

eval(not e1, c) = 2t − eval(e1, c)

eval(e1 and e2, c) = min(eval(e1, c), eval(e2, c))
eval(e1 or e2, c) = max(eval(e1, c), eval(e2, c))

eval(iv, c) =

viv
0t

(

iﬀ viv = access(iv, c) ∧ viv ∈ Tri
otherwise

(13)

3

2.3 Valuation functions

Kconﬁg model. We begin by deﬁning the [[·]]kconﬁg. Given a Kconﬁg model m ∈ Kconﬁg, the
semantics of a model is the intersection of all denotations across the model, conﬁgs and choices. In
other words, the set of valid conﬁgurations for a Kconﬁg model is those conﬁgurations that satisfy
all denotations. [[·]]kconﬁg : Kconﬁg → Confs is deﬁned:

[[m]]kconﬁg =





[[n]]type ∩ [[n]]bounds ∩ [[n]]default ∩ [[n]]range

n∈mconﬁg
\
∩ [[m]]module
∩ [[m]]undeclared

∩





[[n]]choice

!

n∈mchoice
\

(14)

Type. The ﬁrst denotation pertains to the constraints imposed by a conﬁg’s type. The type of a
conﬁg restricts its valid values to those in its respective domain. [[·]]type : Conﬁgs → Confs is deﬁned:

[[(n, t, _, _, _, _)]]type =

{c ∈ Confs | c(n) ∈ Tri \ {1t}}
{c ∈ Confs | c(n) ∈ Tri}
{c ∈ Confs | c(n) ∈ String}
{c ∈ Confs | c(n) ∈ Hex ∪ {“”}} iﬀ t = hex
iﬀ t = int
{c ∈ Confs | c(n) ∈ Int ∪ {“”}}

iﬀ t = boolean
iﬀ t = tristate
iﬀ t = string

(15)






Upper and lower bounds. Next, the bounds denotation models the lower and upper bounds of
a conﬁg. The lower bound is determined by the evaluation of a conﬁg’s reverse dependency. Recall
that the reverse dependency models the behaviour of the select statement in the concrete syntax.
The upper bound is deﬁned by a conﬁg’s prompt condition. This denotation has no eﬀect on conﬁgs
of type int, hex, or string since the the reverse dependency that determines a lower bound is 0t
by our well-formedness rules, and the eval function returns 0t when evaluating a value not in Tri.
[[·]]bounds : Conﬁgs → Confs is deﬁned:

[[(n, _, pro, _, rev, _)]]bounds =

{c ∈ Confs | eval(c(n), c) ≥ Lower(c) ∧ (Upper(c) < Lower(c) ∨ eval(c(n), c) ≤ Upper)}

(16)

where Lower(c) = eval (rev,c) and Upper(c) = eval (pro,c).

Defaults. Kconﬁg has support for setting a default expression for a conﬁg. The default expression
interacts with the prompt condition that determines when the conﬁg is user-changeable. When
the prompt condition is satisﬁed, then the user is free to set a value. However, when the prompt
[[·]]default : Conﬁgs → Confs is
condition is not satisﬁed, the default determine the conﬁg’s value.
deﬁned:

[[(n, _, _, def s, rev, _)]]default =

{c ∈ Confs | bool(eval(pro, c)) ∨ c(n) = max(eval(default(defs, c)), eval(rev, c))}

(17)

where def ault : P(Default) × Type × Confs → Const is a function that models the retrieval of a
default. Recall that def s is a list of defaults (and thus ordered). The eﬀect of a default’s value
depends on the type of its deﬁning conﬁg. If the conﬁg is boolean or tristate, then the default value
is evaluated to a value in Tri. Otherwise, the default value must be either an element of Const or
Id. Let N il be the empty list and :: be the list cons operator. Let tTri ∈ {boolean, tristate} and

4

 
tEntry ∈ {int, hex, string}. The def ault function is deﬁned recursively, so we begin by deﬁning its
base cases:

default(N il, tTri, c) = 0t
default(N il, tEntry, c) = “ ”

(18)

Equation 18 states that given an empty list of defaults, we return 0t if the type is either boolean or
tristate, or the empty string for types int, hex or string. Next, we deﬁne the recursive rule. In the
following equation, we decompose the list into its head and tail components. First, we describe the
function for boolean and tristate type:

default( (e, cond) :: rest, tTri, c) =

Now for the remaining types:

default( (e, cond) :: rest, tEntry, c) =

(

(

eval(e, c)
default(rest, tTri, c) otherwise

if bool(eval(cond, c))

(19)

access(e, c)
default(rest, tEntry, c) otherwise

if bool(eval(cond, c))

(20)

Ranges. Ranges impose a lower and upper bound on the value of int or hex conﬁgs. [[·]]range : Conﬁgs →
Confs is deﬁned as:

[[n, _, _, _, _, rngs)]]range = {c ∈ Confs | ∀(l, u, cond) ∈ rngs.

bool(eval(cond, c)) → c(n) ≥ access(l, c) ∧ c(n) ≤ access(u, c)} (21)

Choices. A choice restricts the number of members that can be selected (i.e. have a value greater
than 0t). The choice denotation, [[·]]choice : Choices → Confs is deﬁned:

[[(boolOrT ri, isM and, prompt, mems)]]choice =

{c ∈ Confs | bool(eval(prompt, c)) → Xor ∧ BChoice ∧ Mandatory} (22)

where Xor deﬁnes the condition that one and only one member may be set to 2t:

Xor = ∃m1 ∈ mems. (m1 = 2t) → (∀m2 ∈ mems \ {m1}. m2 = 0t)

(23)

If the choice is a boolean choice, then the only valid value for its members is 2t. In combination
with Xor, this deﬁnes that a boolean choice may have at most one member with a value not equal
to 0t and that member must be set to 2t:

BChoice = (boolOrT ri = boolean) → ∃m ∈ mems. c(m) = 2t

Finally, if the choice is mandatory, then at least one member must be selected:

Mandatory = isM and → ∃m ∈ mems. c(m) > 0t

(24)

(25)

Modules. A special modules conﬁg is used to specify support for modules in the kernel. Disabling
modules disallows the 1t state for conﬁgs and eﬀectively turns all tristate conﬁgs into boolean
conﬁgs. A special symbol m is used in expressions to identify a dependency on the modules feature
in the concrete syntax. Conﬁgs with a dependency on m cannot be selected (i.e. must be set to 0t)
if modules is not selected. We assume that the special m identiﬁer has been expanded to modules
in the abstract syntax.

[[m]]module = {c ∈ Confs | c(modules) = n → ∀i ∈ Id. c(i) 6= 1t}

(26)

5

type

interpretation in tristate logic

X tristate X = y or X = m

¬X tristate X = n
X boolean X = y
¬X boolean X = n

X string
¬X string
X int
¬X int
X hex
¬X hex

X = “. . . ” (some non-empty string)
X = “ ”
X = i (some integer, including 0)
X = “ ”
X = i (some hex)
X = “ ”

Table 1: Interpretation of propositional variables

Undeclared symbols. We also deﬁne the behaviour of undeclared symbols. The Kconﬁg language
supports references to symbols that are not declared in constraints. These undeclared symbols are
assigned the special symbol ⊥ in our semantics. The use of this symbol will become apparent in
the deﬁnition of the eval function in Section 2.2. The [[·]]undeclared : Kconﬁg → P(Confs) denotation
is deﬁned as:

[[m]]undeclared = {c ∈ Confs | ∀x ∈ Id \ Id(m). c(x) = ⊥}

(27)

3 1-Var Propositional Semantics

The goal of the propositional semantics is to achieve a weakening of the constraints of the full
semantics.

Rewrite rules for expressions. The rewrite is a partial function that implements rewrite rules
on expressions. The function rewrite : KExpr(Id) → KExpr(Id) is deﬁned as:

0
1
rewrite(e) = 

X ↔ Y
Use Table 1 if e is X = lit ∨ X 6= lit


if (e is an variable ∧ typeOf (e) ∈ {int, hex, string}) ∨ e = 0t
if e = 1t ∨ e = 2t
if e is X = Y where X and Y are variables

(28)

We further deﬁne the function relax : KExpr(Id) → KExpr(Id) which converts an expression to
CNF and removes clauses equivalent to equality checks. This function is used to relax the constraints
on the antecedent (LHS) of an implication.

Semantics.
Confsp:

In the propositional semantics, we model the set of propositional conﬁgurations as

The def ault function is deﬁned as Id × Default ∗ ×Confsp → Bool. An extra parameter providing

the declaring identiﬁer is needed for the propositional semantics.

Confsp = Id → Bool

(29)

def ault(n, def s, c) = 



¬n
rewrite(n = eval(ivi, c))

n

if no default conditions are satisﬁed
otherwise if t ∈ {boolean, tristate},
where ivi is the 1st matching default value
otherwise if t ∈ {int, hex, string}

(30)

6

The default denotation is deﬁned as:

[[(n, t, vis, pro, def s, rev, rngs)]]default = {c ∈ Confsp | eval(pro, c) ∨ def ault(n, def s, c)}

(31)

The constraint denotation which models constraints imposed by the reverse dependency and

visibility conditions is deﬁned as:

[[(n, t, vis, pro, def s, rev, rngs)]]bounds = {c ∈ Confsp | (eval(relax(rev), c) → c(n))∧(c(n) → eval(vis, c))}

(32)
We ignore ranges since we abstract away the value of each conﬁg. We also assume that the

module conﬁg is enabled, thus allowing for the 1t state in tristate conﬁgs.

[[(boolOrT ri, isM and, vis, mems)]]choice =

c ∈ Confs | eval(vis, c) → choose(1, ids(mems)) ∧

isM and →

(

m

!)

(33)

m∈mems
_

7

 
