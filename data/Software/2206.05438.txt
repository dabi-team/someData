2
2
0
2

n
u
J

1
1

]

R
C
.
s
c
[

1
v
8
3
4
5
0
.
6
0
2
2
:
v
i
X
r
a

Guaranteeing Timed Opacity using Parametric
Timed Model Checking∗

´Etienne Andr´e

1, Didier Lime

2, Dylan Marinho 1 and Jun Sun 3

1Universit´e de Lorraine, CNRS, Inria, LORIA, Nancy, France
2 ´Ecole Centrale de Nantes, LS2N, UMR CNRS 6004, Nantes
3School of Information Systems, Singapore Management University

Abstract

Information leakage can have dramatic consequences on systems secu-
rity. Among harmful information leaks, the timing information leakage
occurs whenever an attacker successfully deduces conﬁdential internal in-
formation. In this work, we consider that the attacker has access (only)
to the system execution time. We address the following timed opacity
problem: given a timed system, a private location and a ﬁnal location,
synthesize the execution times from the initial location to the ﬁnal loca-
tion for which one cannot deduce whether the system went through the
private location. We also consider the full timed opacity problem, asking
whether the system is opaque for all execution times. We show that these
problems are decidable for timed automata (TAs) but become undecidable
when one adds parameters, yielding parametric timed automata (PTAs).
We identify a subclass with some decidability results. We then devise an
algorithm for synthesizing PTAs parameter valuations guaranteeing that
the resulting TA is opaque. We ﬁnally show that our method can also
apply to program analysis.

Keywords— opacity, timed automata, IMITATOR, parameter synthesis

1

Introduction

Timed systems often combine hard real-time constraints with other complications such
as concurrency. Information leakage can have dramatic consequences on the security of

∗This is the author version of the manuscript of the same name published in ACM Trans-
actions on Software Engineering and Methodology (ToSEM). The ﬁnal version is available
at acm.org. We would like to thank Sudipta Chattopadhyay for helpful suggestions, Nicolas
Markey for an interesting discussion on the proof of Proposition 1, Jiaying Li for his help
with preliminary model conversion, and an anonymous reviewer of ATVA 2019 for suggesting
Remark 1. This work is partially supported by the ANR national research program PACS
(ANR-14-CE28-0002), by the ANR-NRF research program ProMiS (ANR-19-CE25-0015), and
by ERATO HASUO Metamathematics for Systems Design Project (No. JPMJER1603), JST.

1

 
 
 
 
 
 
such systems. Among harmful information leaks, the timing information leakage is the
ability for an attacker to deduce internal information depending on timing information.
In this work, we focus on timing leakage through the total execution time, i. e., when
a system works as an almost black-box and the ability of the attacker is limited to
know the model and observe the total execution time.

Opacity In its most general form on partially observed labeled transitions systems,
given a set of runs that reveal a secret (e. g., they perform a secret action or visit
a secret state), opacity states that if there exists a run of the system that reveals
the secret (i. e., belongs to the given secret set), there exists another run, with the
same observation, that does not reveal that secret [Bry+08]. This secret is completely
generic and, depending on its actual deﬁnition, properties and their decidability can
diﬀer.

In our setting, we deﬁne a form of opacity in which the observation is only the

time to reach a designated location.

Contributions for TAs
In this work, we consider the setting of timed automata
(TAs), which is a popular extension of ﬁnite-state automata with clocks [AD94]. We
consider the following version of timed opacity: given a TA, a private location denoting
the execution of some secret behavior and a ﬁnal location denoting the completion of
the execution, the TA is opaque for a given execution time d (i. e., the time of a run
from the initial location to the ﬁnal location) if there exist two runs of duration d
from the initial location to the ﬁnal location, one going through the private location,
and another run not going through the private location. That is, for this particular
execution time, the system is opaque if one cannot deduce whether the system went
through the private location. Such a notion of timed opacity can be used to capture
many interesting security problems: for instance, it is possible to deduce whether a
secret satisﬁes a certain condition based on whether a certain branch is visited or not.
To be explicit, the attacker knows a TA model of the system, and can observe the
execution time from the system start until it reaches some particular ﬁnal location.
No other actions can be observed. Then, the system is timed opaque if the attacker
cannot deduce whether the system has visited some particular private location. From
a higher-level point of view, this means that the attacker cannot deduce some private
information, such as whether some location has been visited, or whether some branch
of a given program was visited, by only observing the execution time. In practice, this
corresponds to a setting where the attacker may interact with some computational
process on a remote machine (e. g., a server) and receives the responses only at the
end of the process (e. g., a server message is received).

We consider two problems based on this notion of timed opacity:

1. a computation problem: the computation of the set of possible execution times

for which the system is timed opaque; and

2. a decision problem: whether the TA is timed opaque for all execution times

(referred to as full timed opacity).

We ﬁrst prove that these problems can be eﬀectively solved for TAs. We implement
our procedure and apply it to a set of benchmarks containing notably a set of Java
programs known for their (absence of) timing information leakage.

2

Contributions for parametric TAs As a second setting, we consider a higher-
level version of these problems by allowing (internal) timing parameters in the system,
which can model uncertainty or unknown constants at early design stage. The setting
becomes parametric timed automata (PTAs) [AHV93].

On the theoretical side, we answer an existential parametric version of the two
aforementioned problems, that is, the existence of (at least) one parameter valuation
for which the TA is (fully) timed opaque. Although we show that these problems are
in general undecidable, we exhibit a subclass with some decidability results.

Then, we address a practical problem: given a timed system with timing parame-
ters, a private location and a ﬁnal location, synthesize the timing parameters and the
execution times for which one cannot deduce whether the system went through the
private location. We devise a general procedure not guaranteed to terminate, but that
behaves well on examples from the literature.

Summary of the contributions To sum up, this manuscript proposes the fol-
lowing contributions:

1. a notion of timed opacity, and a notion of full timed opacity for TAs;

2. a procedure to solve the timed opacity computation problem for TAs, and a

procedure to answer the full timed opacity decision problem for TAs;

3. a study of two theoretical decision problems extending the two aforementioned
problems to the parametric setting, and exhibition of a decidable subclass;

4. a practical algorithm to synthesize parameter valuations and execution times

for which the TA is guaranteed to be opaque;

5. a set of experiments on a set of benchmarks, including PTAs translations from

Java programs.

This manuscript is an extension of [AS19] with the following improvements.
• We provide all proofs of the results published in [AS19].
• We extend the theoretical part, by considering not one problem (as in [AS19])
but two versions (timed opacity w.r.t. a set of execution times, and full timed
opacity), both for TAs and PTAs (including the subclass of L/U-PTAs).

• We propose a more elegant proof of Proposition 1 (formerly [AS19, Proposi-

tion 1]), based on RA arithmetic [Wei99].

• On the practical side, we give hints to extend our construction to a richer frame-

work (Section 9.3).

Outline After reviewing related works in Section 2, Section 3 recalls necessary
concepts and Section 4 introduces the problem. Section 5 addresses timed opacity for
timed automata. We then address the parametric version of timed opacity, with theory
studied in Sections 6 and 7, algorithmic in Section 8 and experiments in Section 9.
Section 10 concludes the paper.

2 Related works

Opacity and timed automata This work is closely related to the line of work
on deﬁning and analyzing information ﬂow in timed automata. It is well-known (see

3

e. g., [Koc96; FS00; BB07; Kot+13; Ben+15a]) that time is a potential attack vector
against secure systems. That is, it is possible that a non-interferent (secure) system
can become interferent (insecure) when timing constraints are added [GMR07].

In non-interference, actions are partitioned into two levels of privilege, high and
low, and we require that the system in which high-level actions are removed is equiva-
lent to the system in which they are hidden (i. e., replaced by an unobservable action).
Diﬀerent equivalences lead to diﬀerent ﬂavors of non-interference. In [Bar+02; BT03],
a ﬁrst notion of timed non-interference is proposed for TAs. This notion is extended
to PTAs in [AK20], with a semi-algorithm.

In [GMR07], Gardey et al. deﬁne timed strong non-deterministic non-interference
(SNNI) based on timed language equivalence between the automaton with hidden low-
level actions and the automaton with removed low-level actions. Furthermore, they
show that the problem of determining whether a timed automaton satisﬁes SNNI is
undecidable. In contrast, timed cosimulation-based SNNI, timed bisimulation-based
SNNI and timed state SNNI are decidable. Classical SNNI is the one corresponding
to the equality of the languages of the two systems. As such it is clearly a spe-
cial case of opacity in which the secret runs are those containing a high-level ac-
tion [Bry+08]. Other equivalence relations (namely (timed) cosimulation, (timed)
bisimulation, sets of states) are not as easily relatable to opacity. No implementation
is provided in [GMR07].

In [Cas09], it is proved that it is undecidable whether a TA is opaque, for the
following deﬁnition of opacity: the system is opaque if an attacker cannot deduce
whether some set of actions was performed, by only observing a given set of observable
actions together with their timestamp. This problem is proved undecidable even for
the restricted class of event-recording automata [AFH99], which is a subclass of TAs.
No implementation nor procedure is provided. In contrast, our deﬁnition of opacity is
decidable for TAs, notably because in our setting the attacker power is more restricted
(they can only observe the “execution time”); in addition, our deﬁnition of opacity
has some practical relevance nonetheless, when an attacker is able to interact remotely
with the system under attack, and is therefore able to measure the response time.

In [Amm+21], the authors consider a time-bound opacity, where the attacker has
to disclose the secret before an upper bound, using a partial observability. The authors
prove that this problem is decidable for TAs. A construction and an algorithm are also
provided to solve it; a case study is veriﬁed using SpaceEx [Fre+11]. In contrast, our
deﬁnition of opacity only assumes observation of the execution time, does not assume
any time-bounded setting, and our most general problem is parametric.

In [NNV17], the authors propose a type system dealing with non-determinism
and (continuous) real-time, the adequacy of which is ensured using non-interference.
We share the common formalism of TAs; however, we mainly focus on leakage as
execution time, and we synthesize internal parts of the system (clock guards), in
contrast to [NNV17] where the system is ﬁxed.

In [VNN18], Vasilikos et al. deﬁne the security of timed automata in term of infor-
mation ﬂow using a bisimulation relation over a set of observable nodes and develop an
algorithm for deriving a sound constraint for satisfying the information ﬂow property
locally based on relevant transitions.

In [GSB18], Gerking et al. study non-interference properties with input, high and
low actions and provide a resolution method reducing a secure behavior to an unreacha-
bility construction. The proof-of-concept consists in the exhibition of a test automaton
with a dedicated location that indicates violations of noninterference whenever it is
reachable during execution. Then, Uppaal [LPY97] is used to obtain the answer.

4

In [Ben+15a], Benattar et al. study the control synthesis problem of timed au-
tomata for SNNI. That is, given a timed automaton, they propose a method to au-
tomatically generate a (largest) sub-system such that it is non-interferent, if possi-
ble. Diﬀerent from the above-mentioned work, our work considers parametric timed
automata, i. e., timed systems with unknown design parameters, and focuses on syn-
thesizing parameter valuations which guarantee information ﬂow property. Compared
to [Ben+15a], our approach is more realistic as it does not require change of program
structure. Rather, our result provides guidelines on how to choose the timing parame-
ters (e. g., how long to wait after certain program statements) for avoiding information
leakage.

In [WZ18; WZA18], Wang et al. investigate interesting opacity problems for real-
time automata. These works come with a dedicated Python implementation. Al-
though their deﬁnition shares similarities with ours, real-time automata are a severely
restricted formalism compared to TAs. Indeed, timed aspects are only considered by
interval restrictions over the total elapsed time along transitions. Real-time automata
can be seen as a subclass of TAs with a single clock, reset at each transition. Also,
parameters are not considered in their work.

To the best of our knowledge, our approach is the ﬁrst work on parametric model
checking for timed automata for information ﬂow property. In addition, and in contrast
to most of the aforementioned works, our approach comes with an implementation.

Execution times and timed automata In this paper, we need to compute
execution times in timed automata, i. e., the durations of all runs reaching the ﬁnal
state. Despite its natural aspect, this problem seems sparsely investigated in the
literature. Both [BDR08; Ros19] deal with the computation of duration sets; we do
reuse some of the reasoning from [BDR08] in our proof of Proposition 1. Conversely,
results from [BR07] cannot be used in our work: while the equality must be forbidden
in PTCTL formulae to make the problems decidable, equality constraints in a PTCTL
formula would be required for such an approach to answer our problems. Furthermore,
the results presented in [Bou+21] cannot be applied to our study, since they concern
one-clock timed automata.

Mitigating information leakage Complex systems may exhibit security prob-
lems through information leakage due to the presence of unintended communication
media, called side channels. An example is time side channels in which measuring,
e. g., execution times, gives information on some sensitive information. In 2018, the
Spectre vulnerability [Koc+20] exploited speculative execution to bring secret infor-
mation into the cache; subsequently, cache-timing attacks were launched to exﬁltrate
these secrets. Therefore, mitigation of timing attacks is of utmost importance.

Our work is related to work on mitigating information leakage through those time
side channels [Aga00; Mol+05; Cop+09; WS17; Wu+18]. In [Aga00], Agat et al. pro-
posed to eliminate time side channels through type-driven cross-copying. In [Mol+05],
Molnar et al. proposed, along the program counter model, a method for mitigating
side channel through merging branches. A similar idea was proposed in [BRW06].
Coppens et al. [Cop+09] developed a compiler backend for removing such leaks on
x86 processors. In [WS17], Wang et al. proposed to automatically generate masking
code for eliminating side channels through program synthesis. In [Wu+18], Wu et al.
proposed to eliminate time side channels through program repair. Diﬀerent from the
above-mentioned works, we reduce the problem of mitigating time side channels as a

5

parametric model checking problem and solve it using parametric reachability analysis
techniques.

This work is related to work on identifying information leakage through timing
analysis [SPW18; CR11; Abb+16; Zha+18; DSF16; Doy+15; GWW18]. In [CR11],
Chattopadhyay and Roychoudhury applied model checking to perform cache timing
analysis. In [CJM16], Chu et al. performed similar analysis through symbolic execu-
tion. In [Abb+16], Abbasi et al. apply the NuSMV model checker to verify integrated
circuits against information leakage through side channels. In [Doy+15], a tool is de-
veloped to identify time side channel through static analysis. In [Zha+18], Sung et al.
developed a framework based on LLVM for cache timing analysis.

3 Preliminaries

In this work, we assume a system is modeled in the form of a parametric timed au-
tomaton (PTA). In Section 9.2, we discuss how we can model programs with unknown
design parameters (e. g., a Java program with a statement Thread.sleep(n) where n
is unknown) as PTA.

3.1 Clocks, parameters and guards
We assume a set X = {x1, . . . , xH } of clocks, i. e., real-valued variables that all evolve
over time at the same rate. A clock valuation is a function µ : X → R≥0. We write
(cid:126)0 for the clock valuation assigning 0 to all clocks. Given d ∈ R≥0, µ + d denotes the
valuation s.t. (µ + d)(x) = µ(x) + d, for all x ∈ X. Given R ⊆ X, we deﬁne the reset of
a valuation µ, denoted by [µ]R, as follows: [µ]R(x) = 0 if x ∈ R, and [µ]R(x) = µ(x)
otherwise.

We assume a set P = {p1, . . . , pM } of parameters, i. e., unknown constants. A
parameter valuation v is a function v : P → Q+. We assume (cid:46)(cid:47) ∈ {<, ≤, =, ≥, >}. A
guard g is a constraint over X ∪ P deﬁned by a conjunction of inequalities of the form
x (cid:46)(cid:47) (cid:80)
1≤i≤M αipi + d, with pi ∈ P, and αi, d ∈ Z. Given g, we write µ |= v(g) if the
expression obtained by replacing each x with µ(x) and each p with v(p) in g evaluates
to true.

3.2 Parametric timed automata

Parametric timed automata (PTAs) extend timed automata with parameters within
guards and invariants in place of integer constants [AHV93].

3.2.1 Syntax

Deﬁnition 1 (PTA). A PTA A is a tuple A = (Σ, L, (cid:96)0, (cid:96)f , X, P, I, E), where:

1. Σ is a ﬁnite set of actions,

2. L is a ﬁnite set of locations,

3. (cid:96)0 ∈ L is the initial location,

4. (cid:96)f ∈ L is the (unique) ﬁnal location,
5. X is a ﬁnite set of clocks,
6. P is a ﬁnite set of parameters,

6

x ≥ p1

x ≤ 3
(cid:96)0

x ≤ 3
(cid:96)2

x ≥ p2

(cid:96)1

Figure 1: A PTA example

7. I is the invariant, assigning to every (cid:96) ∈ L a guard I((cid:96)),
8. E is a ﬁnite set of edges e = ((cid:96), g, a, R, (cid:96)(cid:48)) where (cid:96), (cid:96)(cid:48) ∈ L are the source and
target locations, a ∈ Σ, R ⊆ X is a set of clocks to be reset, and g is a guard.

Example 1. Consider the PTA in Fig. 1 (inspired by [GMR07, Fig. 1b]), using one
clock x and two parameters p1 and p2. (cid:96)0 is the initial location, while we assume
that (cid:96)1 is the (only) ﬁnal location, i. e., a location in which an attacker can measure
the execution time from the initial location.

L/U-PTAs For some theoretical problems solved in Sections 6 and 7, we will con-
sider the subclass of PTAs called “lower-bound/upper-bound parametric timed au-
tomata” (L/U-PTAs), introduced in [Hun+02].

Deﬁnition 2 (L/U-PTA [Hun+02]). An L/U-PTA is a PTA where the set of param-
eters is partitioned into lower-bound parameters and upper-bound parameters, where
each upper-bound (resp. lower-bound) parameter pi must be such that, for every guard
or invariant constraint x (cid:46)(cid:47) (cid:80)
1≤i≤M αipi + d, we have: (cid:46)(cid:47) ∈ {≤, <} implies αi ≥ 0
(resp. αi ≤ 0) and (cid:46)(cid:47) ∈ {≥, >} implies αi ≤ 0 (resp. αi ≥ 0).

Example 2. The PTA in Fig. 1 is an L/U-PTA with {p1, p2} as lower-bound param-
eters, and ∅ as upper-bound parameters.

The PTA in Fig. 5 is not an L/U-PTA, because p is compared to cl both as a

lower-bound (in “p × 322 ≤ cl”) and as an upper-bound (“cl ≤ p × 322 + (cid:15)”).

Given a parameter valuation v, we denote by v(A) the non-parametric structure
where all occurrences of any parameter pi have been replaced by v(pi). We denote as
a timed automaton any structure v(A), by assuming a rescaling of the constants: by
multiplying all constants in v(A) by the least common multiple of their denominators,
we obtain an equivalent (integer-valued) TA, as deﬁned in [AD94].

Synchronized product of PTAs The synchronous product (using strong broad-
cast, i. e., synchronization on a given set of actions), or parallel composition, of several
PTAs gives a PTA.

Deﬁnition 3 (synchronized product of PTAs). Let N ∈ N. Given a set of PTAs Ai =
(Σi, Li, ((cid:96)0)i, ((cid:96)f )i, Xi, Pi, Ii, Ei), 1 ≤ i ≤ N , and a set of actions Σs, the synchronized
product of Ai, 1 ≤ i ≤ N , denoted by A1 (cid:107)Σs A2 (cid:107)Σs · · · (cid:107)Σs AN , is the tuple
(Σ, L, (cid:96)0, (cid:96)f , X, P, I, E), where:
1. Σ = (cid:83)N
i=1 Σi,
2. L = (cid:81)N
i=1 Li,
3. (cid:96)0 = (((cid:96)0)1, . . . , ((cid:96)0)N ),

7

4. (cid:96)f = (((cid:96)f )1, . . . , ((cid:96)f )N ),
5. X = (cid:83)
6. P = (cid:83)
7. I(((cid:96)1, . . . , (cid:96)N )) = (cid:86)N

Xi,
Pi,

1≤i≤N

1≤i≤N

i=1 Ii((cid:96)i) for all ((cid:96)1, . . . , (cid:96)N ) ∈ L,
and E is deﬁned as follows. For all a ∈ Σ, let ζa be the subset of indices i ∈ 1, . . . , N
such that a ∈ Σi. For all a ∈ Σ, for all ((cid:96)1, . . . , (cid:96)N ) ∈ L, for all ((cid:96)(cid:48)
N ) ∈ L,
(cid:0)((cid:96)1, . . . , (cid:96)N ), g, a, R, ((cid:96)(cid:48)
N )(cid:1) ∈ E if:
• if a ∈ Σs, then

1, . . . , (cid:96)(cid:48)

1, . . . , (cid:96)(cid:48)

1. for all i ∈ ζa, there exist gi, Ri such that ((cid:96)i, gi, a, Ri, (cid:96)(cid:48)

i) ∈ Ei, g = (cid:86)

gi,

i∈ζa

R = (cid:83)

Ri, and,

i∈ζa

2. for all i (cid:54)∈ ζa, (cid:96)(cid:48)

i = (cid:96)i.

• otherwise (if a /∈ Σs), then there exists i ∈ ζa such that

1. there exist gi, Ri such that ((cid:96)i, gi, a, Ri, (cid:96)(cid:48)
2. for all j (cid:54)= i, (cid:96)(cid:48)

j = (cid:96)j.

i) ∈ Ei, g = gi, R = Ri, and,

That is, synchronization is only performed on Σs, and other actions are interleaved.

3.2.2 Concrete semantics of TAs

Let us now recall the concrete semantics of TA.

Deﬁnition 4 (Semantics of a TA). Given a PTA A = (Σ, L, (cid:96)0, (cid:96)f , X, P, I, E), and a
parameter valuation v, the semantics of v(A) is given by the timed transition system
(TTS) [HMP91] Tv(A) = (S, s0, →), with

• S = {((cid:96), µ) ∈ L × RH
• s0 = ((cid:96)0,(cid:126)0),
• → consists of the discrete and (continuous) delay transition relations:

≥0 | µ |= v(I((cid:96)))},

1. discrete transitions: ((cid:96), µ) e(cid:55)→ ((cid:96)(cid:48), µ(cid:48)), if ((cid:96), µ), ((cid:96)(cid:48), µ(cid:48)) ∈ S, and there exists

e = ((cid:96), g, a, R, (cid:96)(cid:48)) ∈ E, such that µ(cid:48) = [µ]R, and µ |= v(g).

2. delay transitions: ((cid:96), µ) d(cid:55)→ ((cid:96), µ + d), with d ∈ R≥0, if ∀d(cid:48) ∈ [0, d], ((cid:96), µ +

d(cid:48)) ∈ S.

Moreover we write ((cid:96), µ)

(d,e)
−→ ((cid:96)(cid:48), µ(cid:48)) for a combination of a delay and discrete

transition if ∃µ(cid:48)(cid:48) : ((cid:96), µ) d(cid:55)→ ((cid:96), µ(cid:48)(cid:48)) e(cid:55)→ ((cid:96)(cid:48), µ(cid:48)).

Given a TA v(A) with concrete semantics (S, s0, →), we refer to the states of Tv(A)
as the concrete states of v(A). A run of v(A) is a (ﬁnite or inﬁnite) alternating sequence
of concrete states of v(A) and pairs of delays and edges starting from the initial state s0
of the form s0, (d0, e0), s1, · · · with i = 0, 1, . . . , ei ∈ E, di ∈ R≥0 and si

(di,ei)
−→ si+1.

Given a state s = ((cid:96), µ), we say that s is reachable in v(A) if s appears in a run of
v(A). By extension, we say that (cid:96) is reachable; and by extension again, given a set LT
of locations, we say that LT is reachable if there exists (cid:96) ∈ LT such that (cid:96) is reachable

8

in v(A).1 Given (cid:96), (cid:96)(cid:48) ∈ L and a run ρ, we say that (cid:96) is reached on the way to (cid:96)(cid:48)
in ρ if ρ is of the form ((cid:96)0, µ0), (d0, e0), ((cid:96)1, µ1), · · · , ((cid:96)m, µm), (dm, em), · · · ((cid:96)n, µn) for
some m, n ∈ N such that (cid:96)m = (cid:96), (cid:96)n = (cid:96)(cid:48) and ∀0 ≤ i ≤ m − 1, (cid:96)i (cid:54)= (cid:96)(cid:48). Conversely, (cid:96) is
avoided on the way to (cid:96)(cid:48) in ρ if ρ is of the form ((cid:96)0, µ0), (d0, e0), ((cid:96)1, µ1), · · · , ((cid:96)n, µn)
with (cid:96)n = (cid:96)(cid:48) and ∀0 ≤ i ≤ n, (cid:96)i (cid:54)= (cid:96). Given (cid:96), (cid:96)(cid:48) ∈ L, we say that (cid:96) is reachable on the
way to (cid:96)(cid:48) in v(A) if there exists a run ρ of v(A) for which (cid:96) is reached on the way to (cid:96)(cid:48)
in ρ. Otherwise, (cid:96) is unreachable on the way to (cid:96)(cid:48).

(cid:80)

The duration of a ﬁnite run ρ : s0, (d0, e0), s1, · · · , (di−1, ei−1), ((cid:96)i, µi) is dur (ρ) =
0≤j≤i−1 dj. We also say that (cid:96)i is reachable in time dur (ρ).

Example 3. Consider again the PTA A in Fig. 1, and let v be such that v(p1) = 1
and v(p2) = 2. Consider the following run ρ of v(A): ((cid:96)0, x = 0), (1.4, e2), ((cid:96)2, x =
1.4), (1.3, e3), ((cid:96)1, x = 2.7), where e2 is the edge from (cid:96)0 to (cid:96)2 in Fig. 1, and e3 is the
edge from (cid:96)2 to (cid:96)1. We write “x = 1.4” instead of “µ such that µ(x) = 1.4”. We have
dur (ρ) = 1.4 + 1.3 = 2.7. In addition, (cid:96)2 is reached on the way to (cid:96)1 in ρ.

3.2.3 Timed automata regions

Let us next recall the concept of regions and the region graph [AD94].

Given a TA v(A), for a clock xi, we denote by ci the largest constant to which
xi is compared within the guards and invariants of v(A) (that is, ci = maxi({ di |
x (cid:46)(cid:47) di appears in a guard or invariant of v(A)}). Given a clock valuation µ and a
clock xi, let (cid:98)µ(xi)(cid:99) and fract(µ(xi)) denote respectively the integral part and the
fractional part of µ(xi).

Example 4. Consider again the PTA in Fig. 1, and let v be such that v(p1) = 2 and
v(p2) = 4. In the TA v(A), the clock x is compared to the constants in {2, 3, 4}. In
that case, c = 4 is the largest constant to which the clock x is compared.

Deﬁnition 5 (Region equivalence). We say that two clock valuations µ and µ(cid:48) are
equivalent, denoted µ ≈ µ(cid:48), if the following three conditions hold for any clocks xi, xj:

1. either

(a) (cid:98)µ(xi)(cid:99) = (cid:98)µ(cid:48)(xi)(cid:99) or
(b) µ(xi) > ci and µ(cid:48)(xi) > ci

2. fract(µ(xi)) ≤ fract(µ(xj)) iﬀ fract(µ(cid:48)(xi)) ≤ fract(µ(cid:48)(xj))
3. fract(µ(xi)) = 0 iﬀ fract(µ(cid:48)(xi)) = 0

The

equivalence

relation ≈ is

extended to the

states of Tv(A):

if

s = ((cid:96), µ), s(cid:48) = ((cid:96)(cid:48), µ(cid:48)) are two states of Tv(A), we write s ≈ s(cid:48) iﬀ (cid:96) = (cid:96)(cid:48) and µ ≈ µ(cid:48).

We denote by [s] the equivalence class of s for ≈. A region is an equivalence class
[s] of ≈. The set of all regions is denoted Rv(A). Given a state s = ((cid:96), µ) and d ≥ 0,
we write s + d to denote ((cid:96), µ + d).

Deﬁnition 6 (Region graph [BDR08]). The region graph RGv(A) = (Rv(A), Fv(A)) is
a ﬁnite graph with:

1We use an existential quantiﬁcation over the set LT of locations, i. e., the set of locations
is reachable if at least one target location is reachable. This is a standard deﬁnition for
reachability synthesis (see, e. g., [JLR15]), and our Algorithm 1 uses a singleton set for LT
anyway.

9

x2 ≤ 1
x1 ← 0

(cid:96)0

x1 ≤ 2
(cid:96)1

x2 ≤ 2

(cid:96)f

Figure 2: A TA example

x2

x2

4

3

2

1

x1

1

2

3

4

x1

1

2

3

4

(b) Step 2: x1 is reset

(c) Step 3: x1 and x2 lin-
early increase as long as
x1 ≤ 2

x2

x2

4

3

2

1

x1

1

2

3

4

(a) Step 1: x1 and x2 lin-
early increase as long as
y ≤ 1

x2

4

3

2

1

4

3

2

1

4

3

2

1

x1

1

2

3

4

(d) Step 4: x2 ≤ 2

x1

1

2

3

4

(e) Division into regions
of the last constraint

Figure 3: Region abstraction of the TA in Fig. 2

• Rv(A) as the set of vertices
• given two regions r = [s] , r(cid:48) = [s(cid:48)] ∈ Rv(A), we have (r, r(cid:48)) ∈ Fv(A) if one of the

following holds:

– if s e(cid:55)→ s(cid:48) ∈ Tv(A) for some e ∈ E (discrete instantaneous transition);
– if r(cid:48) is a time successor of r: r (cid:54)= r(cid:48) and there exists d such that s + d ∈ r(cid:48)

and ∀d(cid:48) < d, s + d(cid:48) ∈ r ∪ r(cid:48) (delay transition);

– r = r(cid:48) is unbounded: s = ((cid:96), µ) with µ(xi) > ci for all xi (equivalent

unbounded regions).

Example 5 (Region abstraction). Consider the TA in Fig. 2. We present in Fig. 3
some of its regions. For example, the region depicted in Fig. 3b is the successor (by
taking the discrete transition from (cid:96)0 to (cid:96)1, resetting x1) of the region depicted in
Fig. 3a.

10

Consider the valuations µ1 and µ2 such that µ1(x1) = 0, µ1(x2) = 0.35, µ2(x1) = 0,
and µ2(x2) = 0.75. These two valuations satisfy all three conditions of Deﬁnition 5,
and therefore µ1 ≈ µ2. Note that they both belong to the region depicted in Fig. 3b,
and any pair of valuations in this region is (by deﬁnition) equivalent.

3.3 Symbolic semantics

Let us now recall the symbolic semantics of PTAs (see e. g., [Hun+02; And+09]).

Constraints We ﬁrst need to deﬁne operations on constraints. A linear term over
X ∪ P is of the form (cid:80)
1≤j≤M βjpj + d, with xi ∈ X, pj ∈ P, and
αi, βj, d ∈ Z. A constraint C (i. e., a convex polyhedron2) over X ∪ P is a conjunction
of inequalities of the form lt (cid:46)(cid:47) 0, where lt is a linear term.

1≤i≤H αixi + (cid:80)

Given a parameter valuation v, v(C) denotes the constraint over X obtained by
replacing each parameter p in C with v(p). Likewise, given a clock valuation µ, µ(v(C))
denotes the expression obtained by replacing each clock x in v(C) with µ(x). We write
µ |= v(C) whenever µ(v(C)) evaluates to true. We say that v satisﬁes C, denoted by
v |= C, if the set of clock valuations satisfying v(C) is nonempty. We say that C is
satisﬁable if ∃µ, v s.t. µ |= v(C).

We deﬁne the time elapsing of C, denoted by C(cid:37), as the constraint over X and P

obtained from C by delaying all clocks by an arbitrary amount of time. That is,

µ(cid:48) |= v(C(cid:37)) if ∃µ : X → R+, ∃d ∈ R+ s.t. µ |= v(C) ∧ µ(cid:48) = µ + d.

Given R ⊆ X, we deﬁne the reset of C, denoted by [C]R, as the constraint obtained
from C by resetting the clocks in R to 0, and keeping the other clocks unchanged.
That is,

µ(cid:48) |= v([C]R) if ∃µ : X → R+ s.t. µ |= v(C) ∧ ∀x ∈ X

(cid:26) µ(cid:48)(x) = 0

µ(cid:48)(x) = µ(x)

if x ∈ R
otherwise.

We denote by C↓P the projection of C onto P, i. e., obtained by eliminating the variables
not in P (e. g., using Fourier-Motzkin [Sch99]).

Deﬁnition 7 (Symbolic state). A symbolic state is a pair ((cid:96), C) where (cid:96) ∈ L is a
location, and C its associated parametric zone.

Deﬁnition 8 (Symbolic semantics). Given a PTA A = (Σ, L, (cid:96)0, (cid:96)f , X, P, I, E), the
symbolic semantics of A is the labeled transition system called parametric zone graph
PZG = (E, S, s0, ⇒), with

• S = {((cid:96), C) | C ⊆ I((cid:96))},
• s0 = (cid:0)(cid:96)0, ((cid:86)
• (cid:0)((cid:96), C), e, ((cid:96)(cid:48), C (cid:48))(cid:1) ∈ ⇒ if e = ((cid:96), g, a, R, (cid:96)(cid:48)) ∈ E and

1≤i≤H xi = 0)(cid:37) ∧ I((cid:96)0)(cid:1), and

C (cid:48) = (cid:0)[(C ∧ g)]R ∧ I((cid:96)(cid:48))(cid:1)(cid:37) ∧ I((cid:96)(cid:48))

with C (cid:48) satisﬁable.

2Strictly speaking, we manipulate polytopes, while polyhedra refer to 3-dimensional poly-
topes. However, for sake of consistency with the parametric timed model checking literature,
and with the Parma polyhedra library (among others), we refer to these geometric objects as
polyhedra.

11

e2

s0

e1

s1

s2

e3

s3

Figure 4: Parametric zone graph of Fig. 1

That is, in the parametric zone graph, nodes are symbolic states, and arcs are

labeled by edges of the original PTA.

If (s, e, s(cid:48)) ∈ ⇒, we write Succ(s, e) = s(cid:48). By extension, we write Succ(s) for

∪e∈ESucc(s, e).

In the non-parametric timed automata setting, a zone can be seen as a convex union
of regions. In the parametric setting, a parametric zone constrains both clocks and
parameters in such a way that, for each admissible parameter valuation, the resulting
projection on clocks is a zone.

Example 6. Consider again the PTA A in Fig. 1. The parametric zone graph of A
is given in Fig. 4, where e1 is the edge from (cid:96)0 to (cid:96)1 in Fig. 1, e2 is the edge from (cid:96)0
to (cid:96)2, and e3 is the edge from (cid:96)2 to (cid:96)1. In addition, the symbolic states are:

)
s0 = ( (cid:96)0 , 0 ≤ x ≤ 3 ∧ p1 ≥ 0 ∧ p2 ≥ 0
s1 = ( (cid:96)1 , x ≥ p2 ∧ 0 ≤ p2 ≤ 3 ∧ p1 ≥ 0
)
s2 = ( (cid:96)2 , 3 ≥ x ≥ p1 ∧ 0 ≤ p1 ≤ 3 ∧ p2 ≥ 0 )
s3 = ( (cid:96)1 , x ≥ p1 ∧ 0 ≤ p1 ≤ 3 ∧ p2 ≥ 0

) .

3.4 Reachability synthesis

We use reachability synthesis to solve the problems deﬁned in Section 4. This proce-
dure, called EFsynth, takes as input a PTA A and a set of target locations LT , and
attempts to synthesize all parameter valuations v for which LT is reachable in v(A).
EFsynth(A, LT ) was formalized in e. g., [JLR15] and is a procedure that may not termi-
nate, but that computes an exact result (sound and complete) if it terminates. EFsynth
traverses the parametric zone graph of A.

Example 7. Consider again the PTA A in Fig. 1. EFsynth(A, {(cid:96)1}) = p1 ≤ 3∨p2 ≤ 3.
Intuitively, it corresponds to all parameter constraints in the parametric zone graph
in Fig. 4 associated to symbolic states with location (cid:96)1.

We ﬁnally recall the correctness of EFsynth.

Lemma 1 ([JLR15]). Let A be a PTA, and let LT be a subset of the locations of A.
Assume EFsynth(A, LT ) terminates with result K. Then v |= K iﬀ LT is reachable
in v(A).

4 Timed opacity problems

4.1 Deﬁnitions
Let us ﬁrst introduce two key concepts to deﬁne our notion of opacity. DReach v(A)
(resp. DReach v(A)

((cid:96)(cid:48))
((cid:96)(cid:48))) is the set of all the durations of the runs for which (cid:96) is reachable

(cid:96)

¬(cid:96)

12

(resp. unreachable) on the way to (cid:96)(cid:48). Formally:

DReach v(A)

(cid:96)

and

DReach v(A)

¬(cid:96)

((cid:96)(cid:48)) = {d | ∃ρ in v(A) such that d = dur (ρ)∧(cid:96) is reached on the way to (cid:96)(cid:48) in ρ}

((cid:96)(cid:48)) = {d | ∃ρ in v(A) such that d = dur (ρ)∧(cid:96) is avoided on the way to (cid:96)(cid:48) in ρ}.

These concepts can be seen as the set of execution times from the initial location (cid:96)0
to a target location (cid:96)(cid:48) while passing (resp. not passing) by a private location (cid:96). Observe
that, from the deﬁnition of dur (ρ), this “execution time” does not include the time
spent in (cid:96)(cid:48).

Example 8. Consider again the PTA in Fig. 1, and let v be such that v(p1) = 1 and
v(p2) = 2. We have DReach v(A)

((cid:96)1) = [1, 3] and DReach v(A)
¬(cid:96)2

((cid:96)1) = [2, 3].

(cid:96)2

We now introduce the concept of “timed opacity w.r.t. a set of durations (or
execution times) D”: a system is opaque w.r.t. a given location (cid:96)priv on the way to (cid:96)f
for execution times D whenever, for any duration in D, it is not possible to deduce
whether the system went through (cid:96)priv or not. In other words, if an attacker measures
an execution time within D from the initial location to the target location (cid:96)f , then
this attacker is not able to deduce whether the system visited (cid:96)priv .

Deﬁnition 9 (timed opacity w.r.t. D). Given a TA v(A), a private location (cid:96)priv , a
target location (cid:96)f and a set of execution times D, we say that v(A) is opaque w.r.t.
(cid:96)priv on the way to (cid:96)f for execution times D if D ⊆ DReach v(A)
((cid:96)f ).
(cid:96)priv

((cid:96)f )∩DReach v(A)
¬(cid:96)priv

If one does not have the ability to tune the system (i. e., change internal delays, or
add some sleep() or Wait() statements in the program), one may be ﬁrst interested
in knowing whether the system is opaque for all execution times (i. e., the durations
of the runs from the initial location to the target location (cid:96)f ). In other words, if a
system is fully opaque, for any possible measured execution time, an attacker is not
able to deduce anything on the system, in terms of visit of (cid:96)priv .

Deﬁnition 10 (full timed opacity). Given a TA v(A), a private location (cid:96)priv and
a target location (cid:96)f , we say that v(A) is fully opaque w.r.t. (cid:96)priv on the way to (cid:96)f if
DReach v(A)
(cid:96)priv

((cid:96)f ) = DReach v(A)
¬(cid:96)priv

((cid:96)f ).

That is, a system is fully opaque if, for any execution time d, a run of duration d
reaches (cid:96)f after going through (cid:96)priv iﬀ another run of duration d reaches (cid:96)f without
going through (cid:96)priv .

Remark 1. This deﬁnition is symmetric: a system is not opaque iﬀ an attacker can
deduce (cid:96)priv or ¬(cid:96)priv . For instance, if there is no path through (cid:96)priv to (cid:96)f , but a path
to (cid:96)f , a system is not opaque w.r.t. Deﬁnition 10.

Example 9. Consider the PTA A in Fig. 5 where cl is a clock, while (cid:15), p are pa-
rameters. We use a sightly extended PTA syntax: read?x reads the value input on
a given channel read, and assigns it to a (discrete, global) variable x.
secret is a
constant variable of arbitrary value. If both x and secret are ﬁnite-domain variables
(e. g., bounded integers) then they can be seen as syntactic sugar for locations. Such
variables are supported by most model checkers, including Uppaal [LPY97] and IMI-
TATOR [And21].

13

error

cl ≤ (cid:15)
x < 0

x > secret

∧ cl ≤ (cid:15)
cl ← 0

(cid:96)5

p × 322 ≤ cl
∧ cl ≤ p × 322 + (cid:15)

cl ≤ (cid:15)
setupserver

cl ← 0

(cid:96)2
cl ≤ (cid:15)

(cid:96)1
cl ≤ (cid:15)

cl ≤ (cid:15)
read?x
cl ← 0

(cid:96)3
cl ≤ (cid:15)

cl ≤ (cid:15)
x ≥ 0

cl ← 0

x ≤ secret

∧ cl ≤ (cid:15)

(cid:96)4
cl ≤ (cid:15)

cl ← 0

322 ≤ cl
∧ cl ≤ 322 + (cid:15)

(cid:96)f

(cid:96)priv

Figure 5: A Java program encoded in a PTA

This PTA encodes a server process and is a (manual) translation of a Java pro-
gram from the DARPA Space/Time Analysis for Cybersecurity (STAC) library3, that
compares a user-input variable with a given secret and performs diﬀerent actions tak-
ing diﬀerent times depending on this secret. The original Java program is vulnerable,
and tagged as such in the DARPA library, because some sensitive information can be
deduced from the timing information. The original Java code is given in Appendix A.
In our encoding, a single instruction takes a time in [0, (cid:15)], while p is a (parametric)
factor to one of the sleep instructions of the program. Note that in the original Java
code in Appendix A, at line 25, there is no parameter p but an integer 2; that is, the
code is ﬁxed to have v(p) = 2. For sake of simplicity, we abstract away instructions not
related to time, and merge subfunctions calls. For this work, we simplify the problem
and abstract in this way. Precisely modeling the timing behavior of a program is itself
a complicated problem (due to caching, speculative execution, etc.) and we leave to
future work.

Let v1 such that v1((cid:15)) = 1 and v1(p) = 2. For this example, DReach v1(A)

((cid:96)f ) =

(cid:96)priv

[1024, 1029] while DReach v1(A)
¬(cid:96)priv
(cid:96)priv on the way to (cid:96)f for execution times D = [1024, 1029] ∩ [2048, 2053] = ∅.

((cid:96)f ) = [2048, 2053]. Therefore, v1(A) is opaque w.r.t.

Let v2 such that v2((cid:15)) = 2 and v2(p) = 1.002. DReach v2(A)

(cid:96)priv

((cid:96)f ) = [1024, 1034]

while DReach v2(A)
¬(cid:96)priv
on the way to (cid:96)f for execution times D = [1026.048, 1034].

((cid:96)f ) = [1026.048, 1036.048]. Therefore, v2(A) is opaque w.r.t. (cid:96)priv

Obviously, neither v1(A) nor v2(A) are fully opaque w.r.t. (cid:96)priv on the way to (cid:96)f .

4.2 Decision and computation problems

We can now deﬁne the timed opacity computation problem, which consists in comput-
ing the possible execution times ensuring opacity w.r.t. a private location. In other
words, the attacker model is as follows: the attacker knows the system model in the
form of a TA, and can only observe the computation time between the start of the
program and the time it reaches a given (ﬁnal) location.

Timed opacity computation Problem:
Input: A TA v(A), a private location (cid:96)priv , a target location (cid:96)f
Problem: Compute the execution times D such that v(A) is opaque w.r.t. (cid:96)priv
on the way to (cid:96)f for these execution times D.

Let us illustrate that this computation problem is certainly not easy. For the TA A
in Fig. 6, the execution times D for which A is opaque w.r.t. (cid:96)priv on the way to (cid:96)f

3https://github.com/Apogee-Research/STAC/blob/master/Canonical_Examples/

Source/Category1_vulnerable.java

14

is exactly N; that is, only integer times are opaque (as the system can only leave (cid:96)priv
and hence enter (cid:96)f at an integer time).

x = 1
x ← 0

(cid:96)priv

x = 0

x = 0

(cid:96)0

(cid:96)f

Figure 6: TA for which the set of opaque execution times is N

The synthesis counterpart allows for a higher-level problem by also synthesizing

the internal timings guaranteeing opacity.

Timed opacity synthesis Problem:
Input: A PTA A, a private location (cid:96)priv , a target location (cid:96)f
Problem: Synthesize the parameter valuations v and the execution times Dv such
that v(A) is opaque w.r.t. (cid:96)priv on the way to (cid:96)f for these execution times Dv.

Note that the execution times can depend on the parameter valuations.
We can also deﬁne the full timed opacity decision problem, which consists in an-

swering whether a timed automaton is fully opaque w.r.t. a private location.

Full timed opacity decision Problem:
Input: A TA v(A), a private location (cid:96)priv , a target location (cid:96)f
Problem: Is v(A) fully opaque w.r.t. (cid:96)priv on the way to (cid:96)f ?

Note that a last problem of interest would be full timed opacity synthesis, aiming
at synthesizing (ideally the entire set of) parameter valuations v for which v(A) is
fully opaque w.r.t. (cid:96)priv on the way to (cid:96)f . This is left as future work.

5 Timed opacity problems for timed automata

In this section, we address the non-parametric problems deﬁned in Section 4.2, i. e.,
the timed opacity computation problem (Section 5.2) and full timed opacity decision
problem (Section 5.3). We show that both problems can be solved using a construction
of the DReach sets based on the RA arithmetic [Wei99] (Section 5.1).
In this section, let A denote a (non-parametric) timed automaton.

5.1 Computing DReach A

(cid:96)priv ((cid:96)f ) and DReach A

¬(cid:96)priv ((cid:96)f )

We must be able to express the set of execution times, i. e., the durations of all runs
from the initial location to a given target location. While the problem of expressing the
set of execution times seems very natural for timed automata, it was barely addressed
in the literature, with the exception of [BDR08; Ros19].

15

5.1.1 The RA arithmetic

We use the RA arithmetic, which is the set of ﬁrst-order formulae, interpreted over the
real numbers, of (cid:104)R, +, <, N, 0, 1(cid:105) where N is a unary predicate such that N(z) is true
iﬀ z is a natural number. This arithmetic has a decidable theory with a complexity of
3EXPTIME [Wei99].

5.1.2 Computing execution times of timed automata

With r, r(cid:48) ∈ RA, we denote by λr,r(cid:48) the set of durations d such that there exists a
ﬁnite path ρ = (si)i in TA such that dur (ρ) = d and the associated path π(ρ) =
(rk)0≤k≤K in the region graph satisﬁes r0 = r, rK = r(cid:48).
It is shown in [BDR08,
Proposition 5.3] that these sets λr,r(cid:48) can be deﬁned in RA arithmetic. Moreover, they
are deﬁnable by a disjunction of terms of the form d = m, ∃z, N(z) ∧ d = m + cz and
∃z, N(z) ∧ m + cz < d < m + cz + 1, where c, m ∈ N.

Let us give the main idea of the proof presented in [BDR08] (even though this ex-
planation is not necessary to follow our reasoning). The idea of the proof of [BDR08]
is to consider a TA A0 obtained from A by adding a new clock x0 which is reset to 0
each time it reaches the value 1 and to count all of the resets of x0. The construction
of A0 ensures that each (ﬁnite) run ρ of TA corresponds to a run ρ0 of TA0 (at each
state, the value of x0 is the fractional part of the total time elapsed), and conversely
(erasing x0). The authors propose next a classical automaton C as a particular sub-
graph of the region graph RA0 , where the only action a denotes the reset of x0 (all
other transitions are labeled with the silent action). The conclusion follows because
t ∈ λr,r(cid:48) if (cid:98)t(cid:99) is the length of a path in C (cid:48), the deterministic automaton obtained
from C by subset construction.

Lemma 2 (Reachability-duration computation). The sets DReach A
DReach A
¬(cid:96)priv ((cid:96)f ) are computable and deﬁnable in RA arithmetic.

(cid:96)priv ((cid:96)f ) and

Proof. Let A be a TA. We aim at reducing the computation of the sets DReach A
and DReach A

¬(cid:96)priv ((cid:96)f ) to the computation of sets λr,r(cid:48) .

(cid:96)priv ((cid:96)f )

First, let us compute DReach A

(cid:96)priv ((cid:96)f ). From A, we deﬁne a TA A(cid:48) by adding a
Boolean discrete variable b, initially false. Recall that discrete variables over a ﬁnite
domain are syntactic sugar for locations: therefore, (cid:96)f with b = false and (cid:96)f with
b = true can be seen as two diﬀerent locations. Then, we set b ← true on any
transition whose target location is (cid:96)priv ; therefore, b = true denotes that (cid:96)priv has been
visited. We denote by (cid:96)(cid:48)
(cid:96)priv ((cid:96)f ) is
exactly the set of executions times in A(cid:48) between (cid:96)0 and (cid:96)(cid:48)
f true. For all the regions
r(cid:48)
i associated to (cid:96)(cid:48)
, where r is the region
associated to (cid:96)0 in A(cid:48). Therefore, DReach A
(cid:96)priv ((cid:96)f ) can be computed as the union of all
the λr,r(cid:48)

f true the ﬁnal state of A(cid:48) where b = true. DReach A

(of which there is a ﬁnite number), which is deﬁnable in RA arithmetic.

f true, we can compute (using [BDR08]) λr,r(cid:48)

i

Second, let us compute DReach A

¬(cid:96)priv ((cid:96)f ). We deﬁne another TA A(cid:48)(cid:48) obtained
from A by deleting all the transitions leading to (cid:96)priv . Therefore, the set of durations
reaching (cid:96)f in A(cid:48)(cid:48) is exactly the set of durations reaching (cid:96)f in A associated to runs
¬(cid:96)priv ((cid:96)f ) is exactly the set of executions times in A(cid:48)(cid:48) between
not visiting (cid:96)priv . DReach A
(cid:96)0 and (cid:96)f . For all the regions r(cid:48)
, where r is
the region associated to (cid:96)0 in A(cid:48)(cid:48). Therefore, DReach A
(cid:96)priv ((cid:96)f ) can be computed as the
union of all the λr,r(cid:48)

i associated to (cid:96)f , we can compute λr,r(cid:48)

.

i

i

i

16

5.2 Answering the timed opacity computation problem

Proposition 1 (timed opacity computation). The timed opacity computation problem
is solvable for TAs.

Proof. Let A be a TA. From Lemma 2, we can compute and deﬁne in RA arithmetic
the sets DReach A
(cid:96)priv ((cid:96)f ).

¬(cid:96)priv ((cid:96)f ) and DReach A

By the decidability of RA arithmetic, the intersection of these sets is computable.
¬(cid:96)priv ((cid:96)f ) is eﬀectively computable (with

(cid:96)priv ((cid:96)f ) ∩ DReach A

Then, the set D = DReach A
a 3EXPTIME upper bound).

This positive result can be put in perspective with the negative result of [Cas09]
that proves that it is undecidable whether a TA (and even the more restricted subclass
of event-recording automata [AFH99]) is opaque, in a sense that the attacker can
deduce some actions, by looking at observable actions together with their timing. The
diﬀerence in our setting is that only the global time is observable, which can be seen
as a single action, occurring once only at the end of the computation. In other words,
our attacker is less powerful than the attacker in [Cas09].

5.3 Checking for full timed opacity

Proposition 2 (full timed opacity decision). The full timed opacity decision problem
is decidable for TAs.

Proof. Let A be a TA. From Lemma 2, we can compute and deﬁne in RA arithmetic
the sets DReach A
(cid:96)priv ((cid:96)f ).

¬(cid:96)priv ((cid:96)f ) and DReach A

From the decidability of RA arithmetic, the equality between these sets is decid-

able. Therefore, DReach A

(cid:96)priv ((cid:96)f ) ?= DReach A

¬(cid:96)priv ((cid:96)f ) is decidable.

From [Wei99] and [BDR08, Theorem 7.5], the computation of a set λr,r(cid:48) is 2EX-
PTIME and the RA arithmetic has a decidable theory with complexity 3EXPTIME.
Therefore, our construction is 3EXPTIME, which is an upper-bound for the problem
complexity. Note that, as in [BDR08], we did not compute a lower bound for the
complexity of Propositions 1 and 2. This remains to be done as future work.

Example 10. Consider again the PTA A in Fig. 1, and let v be such that
v(p1) = 1 and v(p2) = 2. Recall from Example 8 that DReach v(A)
((cid:96)1) = [1, 3] and
DReach v(A)
((cid:96)1) and therefore v(A)
¬(cid:96)2
is not (fully) opaque w.r.t. (cid:96)2 on the way to (cid:96)1.

((cid:96)1) = [2, 3]. Thus, DReach v(A)

((cid:96)1) (cid:54)= DReach v(A)
¬(cid:96)2

(cid:96)2

(cid:96)2

Now, consider v(cid:48) such that v(cid:48)(p1) = v(cid:48)(p2) = 1.5. This time, DReach v(cid:48)(A)

((cid:96)1) =
((cid:96)1) = [1.5, 3] and therefore v(cid:48)(A) is (fully) opaque w.r.t. (cid:96)2 on the way

(cid:96)2

DReach v(cid:48)(A)
to (cid:96)1.

¬(cid:96)2

6 The theory of parametric timed opacity w.r.t.

execution times

We address in this section the parametric problems of timed opacity w.r.t. execution
times.

Let us consider the following decision problem, i. e., the problem of checking the
emptiness of the parameter valuations and execution times set guaranteeing timed

17

(cid:96)(cid:48)
0

(cid:96)0

A

(cid:96)f

(cid:96)priv

(cid:96)pub

(cid:96)(cid:48)
f

Figure 7: Reduction from reachability-emptiness

opacity w.r.t. execution times. The decision problem associated to full timed opacity
will be considered in Section 7.

Timed opacity emptiness Problem:
Input: A PTA A, a private location (cid:96)priv , a target location (cid:96)f
Problem: Is the set of valuations v such that v(A) is opaque w.r.t. (cid:96)priv on the
way to (cid:96)f for a non-empty set of execution times empty?

The negation of the timed opacity emptiness consists in deciding whether there
exists at least one parameter valuation for which v(A) is opaque for at least some
execution time.

6.1 Undecidability in general

We prove undecidability results for a “suﬃcient” number of clocks and parameters.
Put it diﬀerently, our proofs of undecidability require a minimum number of clocks
and parameters to work; the problems are obviously undecidable for larger numbers,
but the decidability is open for smaller numbers. This will be brieﬂy discussed in
Section 10.

With the rule of thumb that all non-trivial decision problems are undecidable for
general PTAs [And19], the following result is not surprising, and follows from the
undecidability of reachability-emptiness for PTAs.

Theorem 1 (undecidability). The timed opacity emptiness problem is undecidable for
general PTAs.

Proof. We reduce from the reachability-emptiness problem, i. e., the existence of a pa-
rameter valuation for which there exists a run reaching a given location in a PTA, which
is undecidable (e. g., [AHV93; Mil00; Doy07; JLR15; Ben+15b]). Consider an arbi-
trary PTA A with initial location (cid:96)0 and a given location (cid:96)f . It is undecidable whether
there exists a parameter valuation for which there exists a run reaching (cid:96)f (proofs of un-
decidability in the literature generally reduce from the halting problem of a 2-counter
machine which is undecidable [Min67], so one can see A as an encoding of a 2-counter
machine).

Now, add the following locations and transitions (all unguarded) as in Fig. 7: a new
urgent4 initial location (cid:96)(cid:48)
0 with outgoing transitions to (cid:96)0 and to a new location (cid:96)pub; a
new urgent location (cid:96)priv with an incoming transition from (cid:96)f ; a new ﬁnal location (cid:96)(cid:48)
f
with incoming transitions from (cid:96)priv and (cid:96)pub. Also, (cid:96)f is made urgent. Let A(cid:48) denote
this new PTA.

4Where time cannot elapse (depicted in dotted yellow in our ﬁgures).

18

First note that, due to the unguarded transitions, (cid:96)(cid:48)

f is reachable for any param-
eter valuation and for any execution time by runs going through (cid:96)pub and not going
through (cid:96)priv . That is, for all v, DReach v(A(cid:48))
¬(cid:96)priv

f ) = [0, ∞).

((cid:96)(cid:48)

Assume there exists some parameter valuation v such that (cid:96)f is reachable from (cid:96)0
in v(A) for some execution times D: then, due to our construction with additional
urgent locations, (cid:96)priv is reachable on the way to (cid:96)(cid:48)
f in v(A(cid:48)) for the exact same
execution times D. Therefore, v(A) is opaque w.r.t. (cid:96)priv on the way to (cid:96)(cid:48)
f for execution
times D.

Conversely, if (cid:96)f is not reachable from (cid:96)0 in A for any valuation, then (cid:96)priv is not
f for any valuation in A(cid:48). Therefore, there is no valuation v
f for any execution time. Therefore,
f iﬀ (cid:96)f

reachable on the way to (cid:96)(cid:48)
such that v(A) is opaque w.r.t. (cid:96)priv on the way to (cid:96)(cid:48)
there exists a valuation v such that v(A) is opaque w.r.t. (cid:96)priv on the way to (cid:96)(cid:48)
is reachable in A—which is undecidable.

Remark 2. Our proof reduces from the reachability-emptiness problem, for which sev-
eral undecidability proofs were proposed (notably [AHV93; Mil00; Doy07; JLR15;
Ben+15b]), with various ﬂavors (numbers of parameters,
integer- or dense-time,
integer- or rational-valued parameters, etc.). See [And19] for a survey. Notably, this
means (from [Ben+15b]) that Theorem 1 holds for PTAs with at least 3 clocks and a
single parameter.

6.2 A decidable subclass

We now show that the timed opacity emptiness problem is decidable for the sub-
class of PTAs called L/U-PTAs [Hun+02]. Despite early positive results for L/U-
PTAs [Hun+02; BL09], more recent results (notably [JLR15; AL17; ALR18; ALM20])
mostly proved undecidable properties of L/U-PTAs, and therefore this positive result
is welcome.

Theorem 2 (decidability). The timed opacity emptiness problem is decidable for L/U-
PTAs.

Proof. We reduce to the timed opacity computation problem of a given TA, which is
decidable (Proposition 1).

Let A be an L/U-PTA. Let A0,∞ denote the structure obtained as follows: any
occurrence of a lower-bound parameter is replaced with 0, and any occurrence of a
conjunct x (cid:47) p (where p is necessarily an upper-bound parameter) is deleted, i. e.,
replaced with true.

Let us show that the set of valuations v such that v(A) is opaque w.r.t. (cid:96)priv on
the way to (cid:96)f for a non-empty set of execution times is non empty iﬀ the solution to
the timed opacity computation problem for A0,∞ is non-empty.

⇒ Assume there exists a valuation v such that v(A) is opaque w.r.t.

(cid:96)priv on
the way to (cid:96)f for a non-empty set of execution. Therefore, the solution to
the timed opacity computation problem for A0,∞ is non-empty. That is, there
exists a duration d such that there exists a run of duration d such that (cid:96)priv is
reachable on the way to (cid:96)f , and there exists a run of duration d such that (cid:96)priv
is unreachable on the way to (cid:96)f .
We now need the following monotonicity property of L/U-PTAs:

19

Lemma 3 ([Hun+02]). Let A be an L/U-PTA and v be a parameter valuation.
Let v(cid:48) be a valuation such that for each upper-bound parameter pu, v(cid:48)(pu) ≥ v(pu)
and for each lower-bound parameter pl, v(cid:48)(pl) ≤ v(pl). Then any run of v(A) is
a run of v(cid:48)(A).

Therefore, from Lemma 3, the runs of v(A) of duration d such that (cid:96)priv is
reachable (resp. unreachable) on the way to (cid:96)f are also runs of A0,∞. Therefore,
there exists a non-empty set of durations such that A0,∞ is opaque, i. e., solution
to the timed opacity computation problem for A0,∞ is non-empty.

⇐ Assume the solution to the timed opacity computation problem for A0,∞ is
non-empty. That is, there exists a duration d such that there exists a run of
duration d such that (cid:96)priv is reachable on the way to (cid:96)f in A0,∞, and there exists
a run of duration d such that (cid:96)priv is unreachable on the way to (cid:96)f in A0,∞.
The result could follow immediately—if only assigning 0 and ∞ to parame-
ters was a proper parameter valuation. From [Hun+02; BL09], if a location
is reachable in the TA obtained by valuating lower-bound parameters with 0
and upper-bound parameters with ∞, then there exists a suﬃciently large con-
stant C such that this run exists in v(A) such that v assigns 0 to lower-bound
and C to upper-bound parameters. Here, we can trivially pick d+1, as any clock
constraint x ≤ d + 1 or x < d + 1 will be satisﬁed for a run of duration d. Let v
assign 0 to lower-bound and d to upper-bound parameters. Then, there exists
a run of duration d such that (cid:96)priv is reachable on the way to (cid:96)f in v(A), and
there exists a run of duration d such that (cid:96)priv is unreachable on the way to (cid:96)f
in v(A). Therefore, the set of valuations v such that v(A) is opaque w.r.t. (cid:96)priv
on the way to (cid:96)f for a non-empty set of execution times is non empty—which
concludes the proof.

Remark 3. The class of L/U-PTAs is known to be relatively meaningful, and many
case studies from the literature ﬁt into this class, including case studies proposed even
before this class was deﬁned in [Hun+02], e. g., a toy railroad crossing model and a
model of Fischer mutual exclusion protocol given in [AHV93] (see [And19] for a survey).
Even though the PTA in Fig. 5 does not ﬁt in this class, it can easily be transformed
into an L/U-PTA, by duplicating p into pl (used in lower-bound comparisons with
clocks) and pu (used in upper-bound comparisons with clocks).

6.3

Intractability of synthesis for L/U-PTAs

Even though the emptiness problem for the timed opacity w.r.t. a set of execution
times D is decidable for L/U-PTAs (Theorem 2), the synthesis of the parameter val-
uations remains intractable in general, as shown in the following Proposition 3. By
intractable, we mean more precisely that the solution, if it can be computed, can-
not (in general) be represented using any formalism for which the emptiness of the
intersection with equality constraints is decidable. That is, a formalism in which it
is decidable to answer the question “is the computed solution intersected with an
equality test between variables empty?” cannot be used to represent the solution. By
empty, we mean emptiness of the valuations set. For example, let us question whether
we could represent the solution of the timed opacity synthesis problem for L/U-PTAs
using the formalism of a ﬁnite union of polyhedra: testing whether a ﬁnite union of
polyhedra intersected with “equality constraints” (typically p1 = p2) is empty or not is
decidable. The Parma polyhedra library [BHZ08] can typically compute the answer to

20

this question. Therefore, from the following Proposition 3, ﬁnite unions of polyhedra
cannot be used to represent the solution of the timed opacity synthesis problem for
L/U-PTAs. As ﬁnite unions of polyhedra are a very common formalism (not to say the
de facto standard) to represent the solutions of various timing parameters synthesis
problems, the synthesis is then considered to be infeasible in practice, or intractable
(following the vocabulary used in [JLR15, Theorem 2]).

Proposition 3 (intractability). If it can be computed, the solution to the timed opacity
synthesis problem for L/U-PTAs cannot in general be represented using any formalism
for which the emptiness of the intersection with equality constraints is decidable.

Proof. We reuse a reasoning inspired by [JLR15, Theorem 2], and we reduce from the
undecidability of the timed opacity emptiness problem for general PTAs (Theorem 1).
Assume the solution of the timed opacity synthesis problem for L/U-PTAs can be
represented in a formalism for which the emptiness of the intersection with equality
constraints is decidable.

By

the

assumption,

Assume an arbitrary PTA A with notably two locations (cid:96)priv and (cid:96)f . From A,
we deﬁne an L/U-PTA A(cid:48) as follow: for each parameter pi that is used both as an
upper bound and a lower bound, replace its occurrences as upper bounds by a fresh
i and its occurrences as lower bounds by a fresh parameter pl
parameter pu
i.
of

=
solution
{(v, Dv) | v(A(cid:48)) is opaque w.r.t. (cid:96)priv on the way to (cid:96)f for times Dv}
can
be computed and represented in a formalism for which the emptiness of the
intersection with equality constraints is decidable.

problem Γ
for A(cid:48)

However, solving the emptiness of (cid:8)(v, Dv) ∈ Γ | (cid:86)

i)(cid:9) (which is de-
cidable by assumption), we can decide the timed opacity emptiness for the PTA A
(which is undecidable from Theorem 1). This leads to a contradiction, and therefore
the solution of the timed opacity synthesis problem for L/U-PTAs cannot in general
be represented in a formalism for which the emptiness of the intersection with equality
constraints is decidable.

i ) = v(pl

synthesis

i v(pu

the

7 The theory of parametric full timed opacity

We address here the following decision problem, which asks about the emptiness of
the parameter valuations set guaranteeing full timed opacity.

Full timed opacity Emptiness Problem:
Input: A PTA A, a private location (cid:96)priv , a target location (cid:96)f
Problem: Is the set of valuations v such that v(A) is fully opaque w.r.t. (cid:96)priv on
the way to (cid:96)f empty?

Equivalently, we are interested in deciding whether there exists at least one pa-

rameter valuation for which v(A) is fully opaque.

7.1 Undecidability in general

Considering that Theorem 1 shows that the undecidability of the timed opacity empti-
ness problem, the undecidability of the emptiness problem for the full timed opacity
is not surprising, but does not follow immediately.

To prove this result (that will be stated formally in Theorem 3), we ﬁrst need the
following lemma stating that the reachability-emptiness (hereafter sometimes referred

21

(cid:96)0

A

x = 1

(cid:96)f

(cid:96)(cid:48)
f

Figure 8: Undecidability of EF-emptiness over constant time

to as “EF-emptiness”) problem is undecidable in constant time, i. e., for a ﬁxed time
bound T . That is, the following lemma shows that, given a PTA A, a target location (cid:96)T
and a time bound T , it is undecidable whether the set of parameter valuations for which
there exists a run reaching (cid:96)T in exactly T time units is empty or not.

Lemma 4 (Reachability in constant time). The reachability-emptiness problem in
constant time is undecidable for PTAs with 4 clocks and 2 parameters.

Proof. In [ALM20, Theorem 3.12], we showed that the EF-emptiness problem is unde-
cidable over bounded time for PTAs with (at least) 3 clocks and 2 parameters. That is,
given a ﬁxed bound T and a location (cid:96)f , it is undecidable whether the set of parameter
valuations for which at least one run reaches (cid:96)f within T time units is empty or not.
We reduce the reachability in bounded time (i. e., in at most T time units) to the
reachability in constant time (i. e., in exactly T time units). In this proof, we ﬁx T = 1.
Assume a PTA A with a location (cid:96)f . We deﬁne a PTA A(cid:48) as in Fig. 8 by adding
f guarded by x = 1, where x is a new

a new location (cid:96)(cid:48)
clock (initially 0), not used in A and therefore never reset in the automaton.

f , and a transition from (cid:96)f to (cid:96)(cid:48)

Let us show that there is no valuation such that (cid:96)f is reachable in at most 1 time

unit iﬀ there is no valuation such that (cid:96)(cid:48)
⇐ Assume EF-emptiness holds in constant time for A(cid:48), i. e., there exists no param-
eter valuation for which (cid:96)(cid:48)
f is reachable in T = 1 time units. Then, from the
construction of A(cid:48), no parameter valuation exists for which (cid:96)f is reachable in
T ≤ 1 time units.

f is reachable exactly in 1 time unit.

⇒ Conversely, assume EF-emptiness holds over bounded time for A, i. e., there exists
no parameter valuation for which (cid:96)f is reachable in T ≤ 1 time units. Then, from
the construction of A(cid:48), no parameter valuation exists for which (cid:96)(cid:48)
f is reachable
in T = 1 time units.

This concludes the proof of the lemma.

We can now state and prove Theorem 3.

Theorem 3 (undecidability). The full timed opacity emptiness problem is undecidable
for general PTAs with (at least) 4 clocks and 2 parameters.

Proof. We reduce from the reachability-emptiness problem in constant time, which is
undecidable (Lemma 4).

Consider an arbitrary PTA A with (at least) 4 clocks and 2 parameters, with initial
location (cid:96)0 and a given location (cid:96)f . We add the following locations and transitions
in A to obtain a PTA A(cid:48), as in Fig. 9: a new urgent initial location (cid:96)(cid:48)
0, with outgoing
transition to (cid:96)0 and to a new location (cid:96)pub, a new urgent location (cid:96)priv with an incoming

22

(cid:96)(cid:48)
0

(cid:96)0

A

(cid:96)f

(cid:96)priv

(cid:96)pub

x = 1

(cid:96)(cid:48)
f

Figure 9: Reduction from reachability-emptiness

transition from (cid:96)f , a new urgent and ﬁnal location (cid:96)(cid:48)
f with incoming transitions from
(cid:96)priv and (cid:96)pub, and a guard x = 1 (with a new clock x, never reset) on the transition
from (cid:96)pub to (cid:96)(cid:48)
f .

First, note that, due to the guarded transition, (cid:96)(cid:48)

f is reachable for any parameter
valuation and (only) for an execution time equal to 1 by runs going through (cid:96)pub and
not going through (cid:96)priv . That is, for all v, DReach v(A)
¬(cid:96)priv

((cid:96)f ) = {1}.

We show that there exists a valuation v such that v(A(cid:48)) is fully opaque w.r.t. (cid:96)priv
f iﬀ there exists a valuation v such that (cid:96)f is reachable in v(A) for

on the way to (cid:96)(cid:48)
execution time equal to 1.

⇐ Assume there exists some valuation v such that (cid:96)f is reachable from (cid:96)0 in A
(only) for execution time equal to 1. Then, due to our construction, (cid:96)priv is
f in v(A(cid:48)) for the exact same execution time 1. There-
reachable on the way to (cid:96)(cid:48)
fore, v(A(cid:48)) is fully opaque w.r.t. (cid:96)priv on the way to (cid:96)(cid:48)
f .

⇒ Conversely, if (cid:96)f is not reachable from (cid:96)0 in A for any valuation for execution
time 1, then (cid:96)priv is not reachable on the way to (cid:96)(cid:48)
f for any valuation of A(cid:48).
Therefore, there is no valuation v such that v(A(cid:48)) is fully opaque w.r.t. (cid:96)priv on
the way to (cid:96)(cid:48)

f for execution time 1.

Therefore, there exists a valuation v such that v(A(cid:48)) is fully opaque w.r.t. (cid:96)priv on the
way to (cid:96)(cid:48)
f iﬀ there exists a valuation v such that (cid:96)f is reachable in v(A) for execution
time equal to 1—which is undecidable. This concludes the proof.

Let us brieﬂy discuss the minimum number of clocks necessary to obtain undecid-
ability using our proof (the case of smaller numbers of clocks remains open). Recall
that Lemma 4 needs 4 clocks; in the current proof of Theorem 3, we add a new clock x
which is never reset; however, since the proof of Lemma 4 also uses a clock which is
never reset, therefore we can reuse it, and our proof does not need an additional clock.
So the result holds for 4 clocks and 2 parameters.

7.2 Undecidability for L/U-PTAs

Note that reasoning like in Section 6.2, i. e., reducing the emptiness problem to a
decision problem of the non-parametric A0,∞, is not relevant. Fig. 10 shows an L/U-
PTA A (and more precisely, a U-PTA, i. e., an L/U-PTA with an empty set of lower-
bound parameters [BL09]) which is not fully opaque for any parameter valuation, but
whose associated TA A0,∞ is.

In addition, while it is well-known that L/U-PTAs enjoy a monotonicity for reach-
ability properties (“enlarging an upper-bound parameter or decreasing a lower-bound

23

(cid:96)priv

x ≤ p

(cid:96)1

(cid:96)0

Figure 10: A0,∞ is not suﬃcient for the full timed opacity emptiness problem

(cid:96)priv

x ≤ p

x ≤ 1

(cid:96)f

(cid:96)0

Figure 11: No monotonicity for full timed opacity in L/U-PTAs

parameter preserves reachability”) as recalled in Lemma 3, we can show in the follow-
ing example that this is not the case for full timed opacity.

Example 11. Consider the PTA in Fig. 11. First assume v such that v(p) = 0.5.
Then, v(A) is not full timed opaque: indeed, (cid:96)f can be reached in 1 time unit via (cid:96)priv ,
but not without going through (cid:96)priv .

Second, assume v(cid:48) such that v(cid:48)(p) = 1. Then, v(cid:48)(A) is full timed opaque: indeed,
(cid:96)f can be reached for any duration in [0, 1] by runs both going through and not going
through (cid:96)priv .

Finally, let us enlarge p further, and assume v(cid:48)(cid:48) such that v(cid:48)(cid:48)(p) = 2. Then, v(cid:48)(cid:48)(A)
becomes again not full timed opaque: indeed, (cid:96)f can be reached in 2 time units not
going through (cid:96)priv , but cannot be reached in 2 time units by going through (cid:96)priv .

As a side note, remark that this PTA is actually a U-PTA, that is, monotonicity

for this problem does not even hold for U-PTAs.

In fact, we show that, while the timed opacity emptiness problem is decidable
for L/U-PTAs (Theorem 2), the full timed opacity emptiness problem becomes unde-
cidable for this same class (from 4 parameters). This conﬁrms (after previous works
in [JLR15; AL17; ALR18]) that L/U-PTAs stand at the frontier between decidability
and undecidability.

Theorem 4. The full timed opacity emptiness problem is undecidable for L/U-PTAs
with (at least) 4 clocks and 4 parameters.

Proof. Let us recall from [ALM20, Theorem 3.12] that the EF-emptiness problem is
undecidable over bounded time for PTAs with (at least) 3 clocks and 2 parameters.
Assume a PTA A with 3 clocks and 2 parameters, say p1 and p2, and a target loca-
tion (cid:96)f . Take 1 as a time bound. From [ALM20, Theorem 3.12], it is undecidable
whether there exists a parameter valuation for which (cid:96)f is reachable in time ≤ 1.

The idea of our proof is that, as in [JLR15; And+19], we “split” each of the two
2) and an upper-bound
2 ). Each construction of the form x < pi (resp. x ≤ pi) is replaced

parameters used in A into a lower-bound parameter (pl
parameter (pu

1 and pu

1 and pl

24

p l
1
pl

)

1

≤ x ≤ p u
2 ≤x≤pu

(cid:96)(cid:48)
0

pl

(cid:96)1

2 ≤x≤pu
2)
≤ x ≤ p u
)

1

(cid:96)3

2) p l
(cid:96)2

1

x = 2

x = 1
X \ {x} ← 0

(cid:96)0

A

(cid:96)f

(cid:96)priv

x = 2

(cid:96)(cid:48)
f

(cid:87)

i(pl

i < x ≤ pu
i )

x > 2

(cid:96)4

Figure 12: Undecidability of full timed opacity emptiness for L/U-PTAs

with x < pu
is replaced with x > pl

i (resp. x ≤ pu

i ) while each construction of the form x > pi (resp. x ≥ pi)

i (resp. x ≥ pl

i); x = pi is replaced with pl

i ≤ x ≤ pu
i .

The idea is that the PTA A is exactly equivalent to our construction with dupli-
cated parameters only when pl
2 . The crux of the rest of this proof
is that we will “rule out” any parameter valuation not satisfying these equalities, so
as to use directly the undecidability result of [ALM20, Theorem 3.12].

1 and pl

2 = pu

1 = pu

Now, consider the extension of A given in Fig. 12, and let A(cid:48) be this extension.
We assume that x is an extra clock not used in A. The syntax “X \ {x} ← 0”
denotes that all clocks of the original PTA A are reset—but not the new clock x. The
guard on the lower transition from (cid:96)(cid:48)
0 to (cid:96)4 stands for 2 diﬀerent transitions guarded
with pl
2 < x ≤ pu
2 , respectively. Let us ﬁrst make the following
observations:

1 < x ≤ pu

1 , and pl

time 2, i. e., (cid:96)(cid:48)

1. for any parameter valuation, one can take the upper transition from (cid:96)(cid:48)

f at
f is always reachable in time 2 without going through location (cid:96)priv ;
2 ≤ pu
2 ;

1 and pl

1 ≤ pu

2. the original automaton A can only be entered whenever pl

0 to (cid:96)(cid:48)

going from (cid:96)(cid:48)

0 to (cid:96)0 takes exactly 1 time unit (due to the x = 1 guard);

3. if a run reaches (cid:96)priv on the way to (cid:96)(cid:48)

f , then its duration is necessarily 2;

4. from [ALM20, Theorem 3.12], it is undecidable whether there exists a parameter
valuation for which there exists a run reaching (cid:96)f from (cid:96)0 in time ≤ 1, i. e.,
reaching (cid:96)f from (cid:96)(cid:48)

0 in time ≤ 2.
Let us consider the following cases:
1. if pl

1 > pu

2 > pu

1 or pl

2 , then thanks to the transitions from (cid:96)(cid:48)

way to enter the original PTA A (and therefore to reach (cid:96)priv on the way to (cid:96)(cid:48)
since these valuations can still reach (cid:96)(cid:48)
through the upper transition from (cid:96)(cid:48)
of these valuations.

0 to (cid:96)0, there is no
f );
f for some execution times (notably x = 2
f ), then A(cid:48) is not fully opaque for any

0 to (cid:96)(cid:48)

25

2. if pl

1 < pu

2 < pu
1 or pl
taken, and therefore (cid:96)(cid:48)
Since no run can reach (cid:96)(cid:48)
again A(cid:48) is not fully opaque for any of these valuations.

2 , then one of the lower transitions from (cid:96)(cid:48)
0 to (cid:96)4 can be
f is reachable in a time > 2 without going through (cid:96)priv .
f while going through (cid:96)priv for a duration (cid:54)= 2, then

3. if pl

2 = pu

1 = pu

1 and pl

f without visiting (cid:96)priv .

2 , then the behavior of the modiﬁed A (with duplicate
parameters) is exactly the one of the original A. Also, note that the lower tran-
sitions from (cid:96)(cid:48)
0 to (cid:96)(cid:48)
f (via (cid:96)4) cannot be taken. In contrast, the upper transition
from (cid:96)(cid:48)
0 to (cid:96)(cid:48)
f can still be taken, and therefore there exists a run of duration 2
reaching (cid:96)(cid:48)
Now, assume there exists a parameter valuation for which there exists a run
of A of duration ≤ 1 reaching (cid:96)f . And, as a consequence, (cid:96)priv is reachable, and
therefore there exists some run of duration 2 (including the 1 time unit to go
from (cid:96)0 to (cid:96)(cid:48)
f after visiting (cid:96)priv . From the above reasoning, all runs
reaching (cid:96)(cid:48)
f have duration 2; in addition, we exhibited a run visiting (cid:96)priv and a
run not visiting (cid:96)priv ; therefore the modiﬁed automaton A(cid:48) is fully opaque for
such a parameter valuation.
Conversely, assume there exists no parameter valuation for which there exists a
run of A of duration ≤ 1 reaching (cid:96)f . In that case, A(cid:48) is not fully opaque for
any parameter valuation.

0) reaching (cid:96)(cid:48)

As a consequence, there exists a parameter valuation v(cid:48) for which v(cid:48)(A(cid:48)) is fully
opaque iﬀ there exists a parameter valuation v for which there exists a run in v(A) of
duration ≤ 1 reaching (cid:96)f —which is undecidable from [ALM20, Theorem 3.12].

8 Parameter synthesis for opacity

Despite the negative theoretical result of Theorem 1, we now address the timed opac-
ity synthesis problem for the full class of PTAs. Our method may not terminate
(due to the undecidability) but, if it does, its result is correct. Our workﬂow can be
summarized as follows.

1. We enrich the original PTA by adding a Boolean ﬂag b and a ﬁnal synchroniza-

tion action;

2. We perform self-composition (i. e., parallel composition with a copy of itself) of

this modiﬁed PTA;

3. We perform reachability-synthesis using EFsynth on (cid:96)f with contradictory values

of b.

We detail each operation in the following.
In this section, we assume a PTA A, a given private location (cid:96)priv and a given ﬁnal

location (cid:96)f .

8.1 Enriching the PTA

We ﬁrst add a Boolean ﬂag b initially set to false, and then set to true on any transition
whose target location is (cid:96)priv (in the line of the proof of Proposition 1). Therefore,
b = true denotes that (cid:96)priv has been visited. Second, we add a synchronization action
ﬁnish on any transition whose target location is (cid:96)f . Third, we add a new clock xabs
(never reset) together with a new parameter pabs , and we guard all transitions to (cid:96)f

26

error

cl ≤ (cid:15)
x < 0

x > secret

∧ cl ≤ (cid:15)
cl ← 0

(cid:96)5

cl ≤ (cid:15)
setupserver

cl ← 0

cl ≤ (cid:15)
read?x
cl ← 0

(cid:96)2
cl ≤ (cid:15)

(cid:96)1
cl ≤ (cid:15)

(cid:96)3
cl ≤ (cid:15)

cl ≤ (cid:15)
x ≥ 0

cl ← 0

x ≤ secret

∧ cl ≤ (cid:15)

(cid:96)4
cl ≤ (cid:15)

cl ← 0
b ← true

(cid:96)priv

Figure 13: Transformed version of Fig. 5

p × 322 ≤ cl
∧ cl ≤ p × 322 + (cid:15)
xabs = pabs
∧
ﬁnish

322 ≤ cl
∧ cl ≤ 322 + (cid:15)
∧ xabs = pabs

ﬁnish

(cid:96)f

with xabs = pabs . This will allow to measure the (parametric) execution time. Let
Enrich(A, (cid:96)priv , (cid:96)f ) denote this procedure.

Example 12. Fig. 13 shows the transformed version of the PTA in Fig. 5.

8.2 Self-composition

We use here the principle of self-composition [BDR11], i. e., composing the PTA with
a copy of itself. More precisely, given a PTA A(cid:48) = Enrich(A, (cid:96)priv , (cid:96)f ), we ﬁrst perform
an identical copy of A(cid:48) with distinct variables: that is, a clock x of A(cid:48) is distinct from a
clock x in the copy of A(cid:48)—which can be trivially performed using variable renaming.5
Let Copy(A(cid:48)) denote this copy of A(cid:48). We then compute A(cid:48) (cid:107){ﬁnish} Copy(A(cid:48)). That
is, A(cid:48) and Copy(A(cid:48)) evolve completely independently due to the interleaving—except
that they are forced to enter (cid:96)f at the same time, thanks to the synchronization
action ﬁnish.

8.3 Synthesis

Then, we apply reachability synthesis EFsynth (over all parameters, i. e., the “internal”
timing parameters, but also the pabs parameter) to the following goal location: the
f with b(cid:48) = false
original A(cid:48) is in (cid:96)f with b = true while its copy Copy(A(cid:48)) is in (cid:96)(cid:48)
(primed variables denote variables from the copy). Intuitively, we synthesize timing
parameters and execution times such that there exists a run reaching (cid:96)f with b = true
(i. e., that has visited (cid:96)priv ) and there exists another run of same duration reaching (cid:96)f
with b = false (i. e., that has not visited (cid:96)priv ).

Let SynthOp(A, (cid:96)priv , (cid:96)f ) denote the entire procedure. We formalize SynthOp in
Algorithm 1, where “(cid:96)f ∧ b = true” denotes the location (cid:96)f with b = true. Recall that
pabs is added by the enrichment step described in Section 8.1. The set of execution
times D is therefore given by the possible valuations of pabs ; these valuations may
depend on the model timing parameters (in the form of a constraint). Finally note
that EFsynth is called on a set made of a single location of A(cid:48) (cid:107){ﬁnish} Copy(A(cid:48)); by
deﬁnition of the synchronous product, this location is a pair of locations, one from A(cid:48)
(i. e., “(cid:96)f ∧ b = true”) and one from Copy(A(cid:48)) (i. e., “(cid:96)(cid:48)

f ∧ b(cid:48) = false”).

5In fact, the fresh clock xabs and parameter pabs can be shared to save two variables, as xabs
is never reset, and both PTAs enter (cid:96)f at the same time, therefore both “copies” of xabs and
pabs always share the same values.

27

Algorithm 1: SynthOp(A, (cid:96)priv , (cid:96)f )

input : A PTA A with parameters set P, locations (cid:96)priv , (cid:96)f
output: Parameter constraint K over P ∪ {pabs }

1 A(cid:48) ← Enrich(A, (cid:96)priv , (cid:96)f )
2 A(cid:48)(cid:48) ← A(cid:48) (cid:107){ﬁnish} Copy(A(cid:48))
3 return EFsynth

(cid:16)

A(cid:48)(cid:48), (cid:8)((cid:96)f ∧ b = true, (cid:96)(cid:48)

f ∧ b(cid:48) = false)(cid:9)(cid:17)

Example 13. Consider again the PTA A in Fig. 5: its enriched version A(cid:48) is given
in Fig. 13. Fix v((cid:15)) = 1, v(p) = 2. We then perform the synthesis applied to the
self-composition of A(cid:48) according to Algorithm 1. The result obtained with IMITATOR
is: pabs = ∅ (as expected from Example 9).

Now ﬁx v((cid:15)) = 2, v(p) = 1.002. We obtain: pabs ∈ [1026.048, 1034] (again, as

expected from Example 9).

Now let us keep all parameters unconstrained. The result of Algorithm 1 is the

following 3-dimensional constraint:

5 × (cid:15) + 1024 ≥ pabs ≥ 1024

∧ 1024 × p + 5 × (cid:15) ≥ pabs ≥ 1024 × p ≥ 0

8.4 Correctness

We will state below that, whenever SynthOp(A, (cid:96)priv , (cid:96)f ) terminates, then its result is
an exact (sound and complete) answer to the timed opacity synthesis problem.

Let us ﬁrst prove a technical lemma used later to prove the soundness of SynthOp.

Lemma 5. Assume SynthOp(A, (cid:96)priv , (cid:96)f ) terminates with result K. For all v |= K,
there exists a run ending in (cid:96)f at time v(pabs ) in v(A).

Proof. From the construction of the procedure Enrich, we added a new clock xabs
(never reset) together with a new parameter pabs , and we guarded all transitions to (cid:96)f
with xabs = pabs . Therefore, valuations of pabs correspond exactly to the times at
which (cid:96)f can be reached in v(A).

We can now prove soundness and completeness.

Proposition 4 (soundness). Assume SynthOp(A, (cid:96)priv , (cid:96)f ) terminates with result K.
For all v |= K, there exists a run of duration v(pabs ) such that (cid:96)priv is reachable on the
way to (cid:96)f in v(A) and there exists a run of duration v(pabs ) such that (cid:96)priv is avoided
on the way to (cid:96)f in v(A).

Proof. SynthOp(A, (cid:96)priv , (cid:96)f ) is the result of EFsynth called on the self-composition
of Enrich(A, (cid:96)priv , (cid:96)f ). Recall that Enrich has enriched A with the addition of a guard
xabs = pabs on the incoming transitions of (cid:96)f , as well as a Boolean ﬂag b that is true
iﬀ (cid:96)priv was visited along a run. Assume v |= K. From Lemma 1, there exists a run of
A(cid:48)(cid:48) reaching (cid:96)f ∧ b = true, (cid:96)(cid:48)
f ∧ b(cid:48) = false. From Lemma 5, this run takes v(pabs ) time
units. From the self-composition that is made of interleaving only (except for the ﬁnal
synchronization), there exists a run of duration v(pabs ) such that (cid:96)priv is reachable on
the way to (cid:96)f in v(A) and there exists a run of duration v(pabs ) such that (cid:96)priv is
avoided on the way to (cid:96)f in v(A).

28

Proposition 5 (completeness). Assume SynthOp(A, (cid:96)priv , (cid:96)f ) terminates with re-
sult K. Assume v. Assume there exists a run of duration v(pabs ) such that (cid:96)priv
is reachable on the way to (cid:96)f in v(A) and there exists a run of duration v(pabs ) such
that (cid:96)priv is avoided on the way to (cid:96)f in v(A). Then v |= K.

Proof. Assume SynthOp(A, (cid:96)priv , (cid:96)f ) terminates with result K. Assume v. Assume
there exists a run ρ of duration v(pabs ) such that (cid:96)priv is reachable on the way to (cid:96)f
in v(A) and there exists a run ρ(cid:48) of duration v(pabs ) such that (cid:96)priv is avoided on the
way to (cid:96)f in v(A).

First, from Enrich, there exists a run ρ of duration v(pabs ) such that (cid:96)priv is reach-
able (resp. avoided) on the way to (cid:96)f in v(A) implies that there exists a run ρ of
duration v(pabs ) such that (cid:96)f ∧ b = true (resp. b = false) is reachable in v(Enrich(A)).
Since our self-composition allows any interleaving, runs ρ of v(A(cid:48)) and ρ(cid:48)
in v(Copy(A(cid:48))) are independent—except for reaching (cid:96)f . Since ρ and ρ(cid:48) have the
same duration v(pabs ), then they both reach (cid:96)f at the same time and, from our def-
inition of self-composition, they can simultaneously ﬁre action ﬁnish and enter (cid:96)f at
f ∧ b(cid:48) = false in v(A(cid:48)(cid:48)).
time v(pabs ). Hence, there exists a run reaching (cid:96)f ∧ b = true, (cid:96)(cid:48)

Finally, from Lemma 1, v |= K.

Theorem 5 (correctness). Assume SynthOp(A, (cid:96)priv , (cid:96)f ) terminates with result K.
Assume v. The following two statements are equivalent:

1. There exists a run of duration v(pabs ) such that (cid:96)priv is reachable on the way
to (cid:96)f in v(A) and there exists a run of duration v(pabs ) such that (cid:96)priv is avoided
on the way to (cid:96)f in v(A).

2. v |= K.

Proof. From Propositions 4 and 5

9 Experiments

9.1 Experimental environment

We use IMITATOR [And21], a parametric timed model checking tool taking as input
networks of PTAs extended with several handful features such as shared global dis-
crete variables, PTA synchronization through strong broadcast, non-timing rational-
valued parameters, etc. IMITATOR supports various parameter synthesis algorithms,
including reachability synthesis. IMITATOR represents symbolic states as polyhedra,
relying on PPL [BHZ08]. IMITATOR is a leading tool for parameter synthesis for ex-
tensions of parametric timed automata. Related tools are Romeo [Lim+09] (which
cannot be used here, as it does not support parametric timed automata, but exten-
sions of Petri nets), SpaceEx [Fre+11] (which does not perform parameter synthesis),
or Uppaal [LPY97] (which cannot be used here, as our algorithm requires timing
parameters, not supported by Uppaal).

We ran experiments using IMITATOR 2.10.4 “Butter Jellyﬁsh” (build 2477
HEAD/5b53333) on a Dell XPS 13 9360 equipped with an Intel® Core™ i7-7500U
CPU @ 2.70GHz with 8 GiB memory running Linux Mint 18.3 64 bits.6

6Sources, models and results are available at doi.org/10.5281/zenodo.3251141 and

imitator.fr/static/ATVA19/.

29

9.2 Translating programs into PTAs

We will consider case studies from the PTA community and from previous works focus-
ing on privacy using (parametric) timed automata. In addition, we will be interested
in analyzing programs too. In order to apply our method to the analysis of programs,
we need a systematic way of translating a program (e. g., a Java program) into a PTA.
In general, precisely modeling the execution time of a program using models like timed
automata is highly non-trivial due to complication of hardware pipelining, caching, OS
scheduling, etc. The readers are referred to the rich literature in, for instance, [Lv+10].
In this work, we instead make the following simplistic assumption on execution time
of a program statement and focus on solving the parameter synthesis problem. How
to precisely model the execution time of programs is orthogonal and complementary
to our work.

We assume that the execution time of a program statement other than
Thread.sleep(n) is within a range [0, (cid:15)] where (cid:15) is a small integer constant (in millisec-
onds), whereas the execution time of statement Thread.sleep(n) is within a range
[n, n + (cid:15)]. In fact, we choose to keep (cid:15) parametric to be as general as possible, and to
not depend on particular architectures.

Our test subject is a set of benchmark programs from the DARPA Space/Time
Analysis for Cybersecurity (STAC) program.7 These programs are being released
publicly to facilitate researchers to develop methods and tools for identifying STAC
vulnerabilities in the programs. These programs are simple yet non-trivial, and were
built on purpose to highlight vulnerabilities that can be easily missed by existing
security analysis tools.

9.3 A richer framework

The symbolic representation of variables and parameters in IMITATOR allows us to
reason symbolically concerning variables. That is, instead of enumerating all possible
(bounded) values of x and secret in Fig. 5, we turn them to parameters (i. e., unknown
constants), and IMITATOR performs a symbolic reasoning. Even better, the analysis
terminates for this example even when no bound is provided on these variables. This
is often not possible in (non-parametric) timed automata based model checkers, which
usually have to enumerate these values. Therefore, in our PTA representation of Java
programs, we turn all user-input variable and secret constant variables to non-timing
rational-valued parameters, also supported by IMITATOR. Other local variables are
implemented using IMITATOR discrete (shared, global) variables.
We also discuss how to enlarge the scope of our framework.

Multiple private locations This can be easily achieved by setting b to true
along any incoming transition of one of these private locations.

Multiple ﬁnal locations The technique used depends on whether these multiple
ﬁnal locations can be distinguished or not.
If they are indistinguishable (i. e., the
observer knows when the program has terminated, but not in which state), then it
suﬃces to merge all these ﬁnal locations in a single one, and our framework trivially
applies. If they are distinguishable, then one analysis needs to be conducted on each
of these locations (with a diﬀerent parameter pabs for each of these), and the obtained
constraints must be intersected.

7https://github.com/Apogee-Research/STAC/

30

h > 0
cl > 30

(cid:96)1

(cid:96)2

h ≤ 0

Figure 14: [VNN18, Fig. 5]

Access to high-level variables
In the literature, a distinction is sometimes
made between low-level (“public”) and high-level (“private”) variables. Opacity or
non-interference can be deﬁned in terms of the ability for an observer to deduce some
information on the high-level variables.

Example 14. For example, in Fig. 14 (where cl is a clock and h a variable), if (cid:96)2 is
reachable in 20 time units, then it is clear that the value of the high-level variable h
is negative.

Our framework can also be used to address this problem, e. g., by setting b to true,

not on locations but on selected tests / valuations of such variables.

Example 15. For example, setting b to true on the upper transition from (cid:96)1 to (cid:96)2 in
Fig. 14, the answer to the timed opacity computation problem is D = (30, ∞), and
the system is therefore not opaque since (cid:96)2 can be reached for any execution time
in [0, ∞).

9.4 Experiments

9.4.1 Benchmarks

As a proof of concept, we applied our method to a set of examples from the literature.
The ﬁrst ﬁve models come from previous works from the literature [GMR07; Ben+15a;
VNN18], also addressing non-interference or opacity in timed automata.8 In addition,
we used two common models from the (P)TA literature, not necessarily linked to
security: a toy coﬀee machine (Coffee) used as benchmark in a number of papers,
and a model Fischer’s mutual exclusion protocol (Fischer-HRSV02) [Hun+02].
In
both cases, we added manually a deﬁnition of private location (the number of sugars
ordered, and the identity of the process entering the critical section, respectively), and
we veriﬁed whether they are opaque w.r.t. these internal behaviors.

We also applied our approach to a set of Java programs from the aforementioned
STAC library. We use identiﬁers of the form STAC:1:n where 1 denotes the identiﬁer in
the library, while n (resp. v) denotes non-vulnerable (resp. vulnerable). We manually
translated these programs to PTAs, following the method described in Section 9.2.
We used a representative set of programs from the library; however, some of them
were too complex to ﬁt in our framework, notably when the timing leaks come from
calls to external libraries (STAC:15:v), when dealing with complex computations such
as operations on matrices (STAC:16:v) or when handling probabilities (STAC:18:v).
Proposing eﬃcient and accurate ways to represent arbitrary programs into (paramet-
ric) timed automata is orthogonal to our work, and is the object of future works.

8As most previous works on opacity and timed automata do not come with an implemen-
tation nor with benchmarks, it is not easy to ﬁnd larger models coming in the form of TAs.

31

Table 1: Experiments: timed opacity

Model

Transf. PTA

Result

1
1
1
1
2
2
2

Name
[VNN18, Fig. 5]
[GMR07, Fig. 1b]
[GMR07, Fig. 2a]
[GMR07, Fig. 2b]

|A| |X| |A| |X|
3
1
3
1
3
1
3
1
4
Web privacy problem [Ben+15a] 1
5
1
5
3
3
3
3
3
3
3
3
3
3
3
3
3
3

Coffee
Fischer-HSRV02
STAC:1:n
STAC:1:v
STAC:3:n
STAC:3:v
STAC:4:n
STAC:4:v
STAC:5:n
STAC:11A:v
STAC:11B:v
STAC:12c:v
STAC:12e:n
STAC:12e:v
STAC:14:n

2
2
2
2
2
2
6
2
2
2
2
2
2
2
2
2
2
2
2
2

(×)
(×)
×
√

|P| Time (s) Opaque?
(×)
0.02
3
(×)
0.04
1
(×)
0.05
1
(×)
0.02
1
(×)
0.07
1
√
0.05
1
5.83
1
0.12
6
0.11
6
0.72
8
0.74
8
6.40
8
265.52
8
0.24
6
47.77
8
59.35
8
18.44
8
0.58
8
1.10
8
22.34
8

(×)
(×)
×
×
(×)
(×)

(×)
×
×
√

9.4.2 Timed opacity computation

First, we veriﬁed whether a given TA model is opaque, i. e., if for all execution times
reaching a given ﬁnal location, both an execution goes through a given private location
and an execution does not go through this private location. To this end, we also
answer the timed opacity computation problem, i. e., to synthesize all execution times
for which the system is opaque. While this problem can be veriﬁed on the region graph
(Proposition 1), we use the same framework as in Section 8, but without parameters in
the original TA. That is, we use the Boolean ﬂag b and the parameter pabs to compute
all possible execution times. In other words, we use a parametric analysis to solve a
non-parametric problem.

We tabulate the experiments results in Table 1. We give from left to right the
model name, the numbers of automata and of clocks in the original timed automaton
(this information is not relevant for Java programs as the original model is not a
TA), the numbers of automata9, of clocks and of parameters in the transformed PTA,
the computation time in seconds (for the timed opacity computation problem), and
the result. In the result column, “
” (resp. “×”) denotes that the model is opaque
(resp. is not opaque, i. e., vulnerable), while “(×)” denotes that the model is not
opaque, but could be ﬁxed. That is, although DReach v(A)
((cid:96)f ),
(cid:96)priv
their intersection is non-empty and therefore, by tuning the computation time, it may
be possible to make the system opaque. This will be discussed in Section 9.5.

((cid:96)f ) (cid:54)= DReach v(A)
¬(cid:96)priv

√

Even though we are interested here in timed opacity computation (and not in
synthesis), note that all models derived from Java programs feature the parameter (cid:15).

9As usual, it may be simpler to write PTA models as a network of PTAs. Recall from
Deﬁnition 3 that a network of PTAs gives a PTA. In this case, |A| denotes the number of
input PTA components.

32

The result is obtained by variable elimination, i. e., by existential quantiﬁcation over
the parameters diﬀerent from pabs . In addition, the number of parameters is increased
by the parameters encoding the symbolic variables (such as x and secret in Fig. 5).

Concerning the Java programs, we decided to keep the most abstract representa-
tion, by imposing that each instruction lasts for a time in [0, (cid:15)], with (cid:15) a parameter.
However, ﬁxing an identical (parametric) time (cid:15) for all instructions, or ﬁxing an ar-
bitrary time in a constant interval [0, (cid:15)] (for some constant (cid:15), e. g., 1), or even ﬁxing
an identical (constant) time (cid:15) (e. g., 1) for all instructions, signiﬁcantly speeds up the
analysis. These choices can be made for larger models.

Discussion Overall, our method is able to answer the timed opacity computa-
tion problem for practical case studies, exhibiting which execution times are opaque
(timed opacity computation problem), and whether all execution times indeed guar-
antee opacity (timed opacity problem).

In many cases, while the system is not opaque, we are able to infer the execution
times guaranteeing opacity (cells marked “(×)”). This is an advantage of our method
w.r.t. methods outputting only binary answers.

We observed some mismatches in the Java programs, i. e., some of the programs
marked n (non-vulnerable) in the library are actually vulnerable according to our
method. This mainly comes from the fact that the STAC library expect tools to use
imprecise analyses on the execution times, while we use an exact method. Therefore,
a very small mismatch between DReach v(A)
((cid:96)f ) will lead our
(cid:96)priv
algorithm to answer “not opaque”, while some methods may not be able to diﬀerentiate
this mismatch from imprecision (noise). This is notably the case of STAC:14:n where
some action lasts either 5,010,000 or 5,000,000 time units depending on some secret,
which our method detects to be diﬀerent, while the library does not. For STAC:1:n,
using our data, the diﬀerence in the execution time upper bound between an execution
performing some secret action and an execution not performing it is larger than 1 %,
which we believe is a value which is not negligible, and therefore this case study might
be considered as vulnerable.

((cid:96)f ) and DReach v(A)
¬(cid:96)priv

STAC:4:n requires a more detailed discussion. This particular program is targeting
vulnerabilities that can be detected easily when they accumulate, typically in loops.
This program checks a number of times (10) a user-input password, and each password
check is made in the most insecure way, i. e., by returning “incorrect” as soon as one
character diﬀers between the input password and the expected password. This way is
very insecure because the execution time is proportional to the number of consecutive
correct characters in the input password and, by observing the execution time, an
attacker can guess how many characters are correct, and therefore using a limited
number of tests, (s)he will eventually guess the correct password. The diﬀerence
between the vulnerable (STAC:4:v) and the non-vulnerable (STAC:4:n) versions is that
the non-vulnerable version immediately stops if the password is incorrect, and performs
the 10 checks only if the password is correct. Therefore, while the computation time is
very diﬀerent between the correct input password and any incorrect input password,
it is however very similar between an incorrect input password that would only be
incorrect because, say, of the last character (e. g., “kouignamaz” while the expected
password is “kouignaman”), and a completely incorrect input password diﬀering as
early as the ﬁrst character (e. g., “andouille”). This makes the attacker’s task very
diﬃcult. The main reason for the STAC library to label STAC:4:n as a non-vulnerable
program is because of the “very similar” nature of the computation times between an

33

Table 2: Experiments: timed opacity synthesis

Model

Transf. PTA

Result

Name
[VNN18, Fig. 5]
[GMR07, Fig. 1b]
[GMR07, Fig. 2]

|A| |X| |P| |A| |X|
3
0
1
3
0
1
3
0
1
4
2
Web privacy problem [Ben+15a] 1
5
3
1
5
2
3
3
2

Coffee
Fischer-HSRV02
STAC:3:v

2
2
2
2
2
6
2

1
1
1
2
2
2

|P| Time (s) Constraint

4
3
3
3
4
3
9

0.02
0.03
0.05
0.07
0.10
7.53
0.93

K
K
K
K
(cid:62)
K
K

incorrect input password that would only be incorrect because of the last character, and
a completely incorrect input password. (In contrast, the vulnerable version STAC:4:v
is completely vulnerable because this time diﬀerence is ampliﬁed by the loop, here
10 times.) While “very similar” might be acceptable for most tools, in our setting based
on formal veriﬁcation, we do detect that testing “kouignamaz” or testing “kouignamzz”
will yield a slightly faster computation time for the second input, because the ﬁrst
incorrect letter occurs earlier—and the program is therefore vulnerable.

9.4.3 Timed opacity synthesis

Then, we address the timed opacity synthesis problem.
In this case, we synthesize
both the execution time and the internal values of the parameters for which one cannot
deduce private information from the execution time.

We consider the same case studies as for timed opacity computation; however,
the Java programs feature no internal “parameter” and cannot be used here. Still,
as a proof of concept, we artiﬁcially enriched one of them (STAC:3:v) as follows:
in
addition to the parametric value of (cid:15) and the execution time, we parameterized one of
the sleep timers. The resulting constraint can help designers to reﬁne this latter value
to ensure opacity. Note that it may not be that easy to tune a Java program to make it
non-opaque: while this is reasonably easy on the PTA level (restraining the execution
times using an additional clock), this may not be clear on the original model: Making a
program terminate slower than originally is easy with a Sleep statement; but making
it terminate “earlier” is less obvious, as it may mean an abrupt termination, possibly
leading to wrong results.

We tabulate the results in Table 2, where the columns are similar to Table 1. A
diﬀerence is that the ﬁrst |P| column denotes the number of parameters in the original
model (without counting these added by our transformation). In addition, Table 2
does not contain a “vulnerable?” column as we synthesize the condition for which the
model is non-vulnerable, and therefore the answer is non-binary. However, in the last
column (“Constraint”), we make explicit whether no valuations ensure opacity (“⊥”),
all of them (“(cid:62)”), or some of them (“K”).

Discussion An interesting outcome is that the computation time is comparable to
the (non-parametric) timed opacity computation, with an increase of up to 20 % only.
In addition, for all case studies, we exhibit at least some valuations for which the
system can be made opaque. Also note that our method always terminates for these
models, and therefore the result exhibited is complete. Interestingly, Coffee is opaque
for any valuation of the 3 internal parameters.

34

9.5 “Repairing” a non-opaque PTA

Our method gives a result in time of a union of polyhedra over the internal timing
parameters and the execution time. On the one hand, we believe tuning the internal
timing parameters should be easy: for a program, an internal timing parameter can be
the duration of a sleep, for example. On the other hand, tuning the execution time
of a program may be more subtle. A solution is to enforce a minimal execution time
by adding a second thread in parallel with a Wait() primitive to ensure a minimal
execution time. Ensuring a maximal execution time can be achieved with an exception
stopping the program after a given time; however there is a priori no guarantee that
the result of the computation is correct.

10 Conclusion

In this work, we proposed an approach based on parametric timed model checking
to not only decide whether the model of a timed system can be subject to timing
information leakage, but also to synthesize internal timing parameters and execution
times that render the system opaque. We implemented our approach in a framework
based on IMITATOR, and performed experiments on case studies from the literature
and from a library of Java programs.

We now discuss future works in the following.

Theory We proved decidability of the timed opacity computation problem (Propo-
sition 1) and of the full timed opacity decision problem (Proposition 2) for TAs, but
we only provided an upper bound (3EXPTIME) on the complexity. It can be easily
shown that these problems are at least PSPACE, but the exact complexity remains to
be exhibited.

In addition, the decidability of several “low-dimensional” problems (i. e., with
“small” number of clocks or parameters) remains open. Among these, the one-clock
case for parametric timed opacity emptiness (Theorem 1) remains open: that is, is
the timed opacity emptiness problem decidable for PTAs using a single clock? Our
method in Section 8 consists in duplicating the automaton and adding a clock that is
never reset, thus resulting in a PTA with 3 clocks, for which reachability-emptiness is
undecidable [AHV93]. However, since one of the clocks is never reset, and since the
automaton is structurally constrained (it is the result of the composition of two copies
of the same automaton), decidability might be envisioned. Recall that the 2-clock
reachability-emptiness problem is a famous open problem [And19], despite recent ad-
vances, notably over discrete time [BO14; GH21]. The 1-clock question also remains
open for full timed opacity emptiness (Theorem 3). The minimum number of param-
eters required for our proof of the undecidability of the full timed opacity emptiness
problem for PTAs (resp. L/U-PTAs) to work is 2 (resp. 4), as seen in Theorem 3
(resp. Theorem 4); it is open whether using less parameters can render these problems
decidable.

Finally, concerning L/U-PTAs, we proved two negative results, despite the decid-
ability of the timed opacity emptiness problem (Theorem 2): the undecidability of
the full timed opacity emptiness (Theorem 4) and the intractability of timed opacity
synthesis (Proposition 3).
It remains open whether these results still apply to the
more restrictive class of U-PTAs [BL09].

35

Full timed opacity synthesis We leave full timed opacity synthesis as future
work; while we could certainly reuse partially our algorithm, this is not entirely trivial,
as we need to select only the parameter valuations for which the whole set of execution
times is exactly the set of opaque times.

Applications The translation of the STAC library required some non-trivial cre-
ativity: while the translation from programs to quantitative extensions of automata
is orthogonal to our work, proposing automated translations of (possibly annotated)
programs to timed automata dedicated to timing analysis is on our agenda.

Adding probabilities to our framework will be interesting, helping to quantify the
execution times of “untimed” instructions in program with a ﬁner grain than an inter-
val; also note that some benchmarks make use of probabilities (notably STAC:18:v).
Finally, IMITATOR is a general model checker, not speciﬁcally aimed at solving the
problem we address here. Notably, constraints managed by PPL contain all variables
(clocks, timing parameters, and parameters encoding symbolic variables of programs),
yielding an exponential complexity. Separating certain types of independent variables
(typically parameters encoding symbolic variables of programs, and other variables)
should increase eﬃciency.

References

[Abb+16]

[AD94]

[AFH99]

[Aga00]

[AHV93]

[AK20]

[AL17]

Imran Hafeez Abbasi, Faiq Khalid Lodhi, Awais Mehmood Kamboh, and Os-
man Hasan. “Formal Veriﬁcation of Gate-Level Multiple Side Channel Param-
eters to Detect Hardware Trojans”. In: FTSCS (Nov. 14, 2016). Ed. by Cyrille
Artho and Peter Csaba ¨Olveczky. Vol. 694. Communications in Computer and
Information Science. Tokyo, Japan, 2016, pp. 75–92. doi: 10.1007/978-3-319-
53946-1_5 (cit. on p. 6).

Rajeev Alur and David L. Dill. “A theory of timed automata”. In: Theoret-
ical Computer Science 126.2 (Apr. 1994), pp. 183–235. doi: 10.1016/0304-
3975(94)90010-8 (cit. on pp. 2, 7, 9).

Rajeev Alur, Limor Fix, and Thomas A. Henzinger. “Event-Clock Automata:
A Determinizable Class of Timed Automata”. In: Theoretical Computer Sci-
ence 211.1-2 (1999), pp. 253–273. doi: 10.1016/S0304-3975(97)00173-4 (cit.
on pp. 4, 17).

Johan Agat. “Transforming Out Timing Leaks”. In: POPL (Jan. 19–21, 2000).
Boston, Massachusetts, USA, 2000, pp. 40–53. doi: 10.1145/325694.325702
(cit. on p. 5).

Rajeev Alur, Thomas A. Henzinger, and Moshe Y. Vardi. “Parametric real-
time reasoning”. In: STOC (May 16–18, 1993). Ed. by S. Rao Kosaraju, David
S. Johnson, and Alok Aggarwal. San Diego, California, United States: ACM,
1993, pp. 592–601. doi: 10.1145/167088.167242 (cit. on pp. 3, 6, 18–20, 35).
´Etienne Andr´e and Aleksander Kryukov. “Parametric non-interference in
timed automata”. In: ICECCS (Mar. 4–6, 2021). Ed. by Yi Li and Alan Liew.
Singapore, 2020, pp. 37–42. doi: 10.1109/ICECCS51672.2020.00012 (cit. on
p. 4).
´Etienne Andr´e and Didier Lime. “Liveness in L/U-Parametric Timed Au-
tomata”. In: ACSD (June 25–30, 2017). Ed. by Alex Legay and Klaus Schnei-
der. Zaragoza, Spain: IEEE, 2017, pp. 9–18. doi: 10.1109/ACSD.2017.19 (cit.
on pp. 19, 24).

36

[ALM20]

[ALR18]

[Amm+21]

[And+09]

[And+19]

[And19]

[And21]

[AS19]

[Bar+02]

[BB07]

[BDR08]

[BDR11]

[Ben+15a]

´Etienne Andr´e, Didier Lime, and Nicolas Markey. “Language Preservation
Problems in Parametric Timed Automata”. In: Logical Methods in Computer
Science 16.1 (Jan. 2020). doi: 10.23638/LMCS- 16(1:5)2020 (cit. on pp. 19,
22, 24–26).
´Etienne Andr´e, Didier Lime, and Mathias Ramparison. “TCTL model checking
lower/upper-bound parametric timed automata without invariants”. In: FOR-
MATS (Sept. 4–6, 2018). Ed. by David N. Jansen and Pavithra Prabhakar.
Vol. 11022. Lecture Notes in Computer Science. Beijing, China: Springer, 2018,
pp. 1–17. doi: 10.1007/978-3-030-00151-3_3 (cit. on pp. 19, 24).
Ikhlass Ammar, Yamen El Touati, Moez Yeddes, and John Mullins. “Bounded
opacity for timed systems”. In: Journal of Information Security and Applica-
tions 61 (Sept. 2021), pp. 1–13. doi: 10.1016/j.jisa.2021.102926 (cit. on
p. 4).
´Etienne Andr´e, Thomas Chatain, Emmanuelle Encrenaz, and Laurent Fri-
bourg. “An Inverse Method for Parametric Timed Automata”. In: Interna-
tional Journal of Foundations of Computer Science 20.5 (2009), pp. 819–836.
doi: 10.1142/S0129054109006905 (cit. on p. 11).
´Etienne Andr´e, Vincent Bloemen, Laure Petrucci, and Jaco van de Pol.
“Minimal-Time Synthesis for Parametric Timed Automata”. In: TACAS, Part
II (Apr. 8–11, 2019). Ed. by Tom´aˇs Vojnar and Lijun Zhang. Vol. 11428.
Lecture Notes in Computer Science. Prague, Czech Repubic: Springer, 2019,
pp. 211–228. doi: 10.1007/978-3-030-17465-1_12 (cit. on p. 24).
´Etienne Andr´e. “What’s decidable about parametric timed automata?” In:
International Journal on Software Tools for Technology Transfer 21.2 (Apr.
2019), pp. 203–219. doi: 10.1007/s10009-017-0467-0 (cit. on pp. 18–20, 35).
´Etienne Andr´e. “IMITATOR 3: Synthesis of timing parameters beyond decid-
ability”. In: CAV (July 18–23, 2021). Ed. by Rustan Leino and Alexandra
Silva. Vol. 12759. Lecture Notes in Computer Science. virtual: Springer, 2021,
pp. 1–14. doi: 10.1007/978-3-030-81685-8_26 (cit. on pp. 13, 29).
´Etienne Andr´e and Jun Sun. “Parametric Timed Model Checking for Guaran-
teeing Timed Opacity”. In: ATVA (Oct. 28–31, 2019). Ed. by Yu-Fang Chen,
Chih-Hong Cheng, and Javier Esparza. Vol. 11781. Lecture Notes in Computer
Science. Taipei, Taiwan: Springer, 2019, pp. 115–130. doi: 10.1007/978- 3-
030-31784-3_7 (cit. on p. 3).

Roberto Barbuti, Nicoletta De Francesco, Antonella Santone, and Luca Tesei.
“A Notion of Non-Interference for Timed Automata”. In: Fundamenta Infor-
mormaticae 51.1-2 (2002), pp. 1–11 (cit. on p. 4).

Andrew Bortz and Dan Boneh. “Exposing private information by timing Web
applications”. In: WWW (May 8–12, 2007). Ed. by Carey L. Williamson,
Mary Ellen Zurko, Peter F. Patel-Schneider, and Prashant J. Shenoy. Banﬀ,
Alberta, Canada: ACM, 2007, pp. 621–628. doi: 10.1145/1242572.1242656
(cit. on p. 4).

V´eronique Bruy`ere, Emmanuel Dall’Olio, and Jean-Francois Raskin. “Dura-
tions and parametric model-checking in timed automata”. In: ACM Transac-
tions on Computational Logic 9.2 (2008), 12:1–12:23. doi: 10.1145/1342991.
1342996 (cit. on pp. 5, 9, 15–17).

Gilles Barthe, Pedro R. D’Argenio, and Tamara Rezk. “Secure information
ﬂow by self-composition”. In: Mathematical Structures in Computer Science
21.6 (2011), pp. 1207–1252. doi: 10.1017/S0960129511000193 (cit. on p. 27).
Gilles Benattar, Franck Cassez, Didier Lime, and Olivier H. Roux. “Control
and synthesis of non-interferent timed systems”. In: International Journal of
Control 88.2 (2015), pp. 217–236. doi: 10.1080/00207179.2014.944356 (cit.
on pp. 4, 5, 31, 32, 34).

37

[Ben+15b]

[BHZ08]

[BL09]

[BO14]

[Bou+21]

[BR07]

[BRW06]

[Bry+08]

[BT03]

[Cas09]

[CJM16]

[Cop+09]

Nikola Beneˇs, Peter Bezdˇek, Kim Gulstrand Larsen, and Jiˇr´ı Srba. “Language
Emptiness of Continuous-Time Parametric Timed Automata”. In: ICALP,
Part II (July 6–10, 2015). Ed. by Magn´us M. Halld´orsson, Kazuo Iwama,
Naoki Kobayashi, and Bettina Speckmann. Vol. 9135. Lecture Notes in Com-
puter Science. Kyoto, Japan: Springer, July 2015, pp. 69–81. doi: 10.1007/
978-3-662-47666-6_6 (cit. on pp. 18, 19).

Roberto Bagnara, Patricia M. Hill, and Enea Zaﬀanella. “The Parma Polyhe-
dra Library: Toward a Complete Set of Numerical Abstractions for the Analysis
and Veriﬁcation of Hardware and Software Systems”. In: Science of Computer
Programming 72.1–2 (2008), pp. 3–21. doi: 10.1016/j.scico.2007.08.001
(cit. on pp. 20, 29).

Laura Bozzelli and Salvatore La Torre. “Decision problems for lower/upper
bound parametric timed automata”. In: Formal Methods in System Design
35.2 (2009), pp. 121–151. doi: 10.1007/s10703- 009- 0074- 0 (cit. on pp. 19,
20, 23, 35).

Daniel Bundala and Jo¨el Ouaknine. “Advances in Parametric Real-Time Rea-
soning”. In: MFCS, Part I (Aug. 25–29, 2014). Ed. by Erzs´ebet Csuhaj-Varj´u,
Martin Dietzfelbinger, and Zolt´an ´Esik. Vol. 8634. Lecture Notes in Computer
Science. Budapest, Hungary: Springer, 2014, pp. 123–134. doi: 10.1007/978-
3-662-44522-8 (cit. on p. 35).

Patricia Bouyer, L´eo Henry, Samy Jaziri, Thierry J´eron, and Nicolas Markey.
“Diagnosing timed automata using timed markings”. In: International Journal
on Software Tools for Technology Transfer 23.2 (2021), pp. 229–253. doi:
10.1007/s10009-021-00606-2 (cit. on p. 5).

V´eronique Bruy`ere and Jean-Fran¸cois Raskin. “Real-Time Model-Checking:
Parameters everywhere”. In: Logical Methods in Computer Science 3.1:7
(2007), pp. 1–30. doi: 10.2168/LMCS-3(1:7)2007 (cit. on p. 5).

Gilles Barthe, Tamara Rezk, and Martijn Warnier. “Preventing Timing Leaks
Through Transactional Branching Instructions”. In: Electronic Notes in The-
oretical Computer Science 153.2 (2006), pp. 33–55. doi: 10.1016/j.entcs.
2005.10.031 (cit. on p. 5).

Jeremy W. Bryans, Maciej Koutny, Laurent Mazar´e, and Peter Y. A. Ryan.
“Opacity generalised to transition systems”. In: International Journal of In-
formation Security 7.6 (2008), pp. 421–435. doi: 10.1007/s10207-008-0058-x
(cit. on pp. 2, 4).

Roberto Barbuti and Luca Tesei. “A Decidable Notion of Timed Non-
Interference”. In: Fundamenta Informaticae 54.2-3 (2003), pp. 137–150 (cit.
on p. 4).

Franck Cassez. “The Dark Side of Timed Opacity”. In: ISA (June 25–27,
2009). Ed. by Jong Hyuk Park, Hsiao-Hwa Chen, Mohammed Atiquzzaman,
Changhoon Lee, Tai-Hoon Kim, and Sang-Soo Yeo. Vol. 5576. Lecture Notes in
Computer Science. Seoul, Korea: Springer, 2009, pp. 21–30. doi: 10.1007/978-
3-642-02617-1_3 (cit. on pp. 4, 17).

Duc-Hiep Chu, Joxan Jaﬀar, and Rasool Maghareh. “Precise Cache Timing
Analysis via Symbolic Execution”. In: RTAS (Apr. 11–14, 2016). Vienna, Aus-
tria: IEEE Computer Society, 2016, pp. 293–304. doi: 10.1109/RTAS.2016.
7461358 (cit. on p. 6).

Bart Coppens, Ingrid Verbauwhede, Koen De Bosschere, and Bjorn De Sutter.
“Practical Mitigations for Timing-Based Side-Channel Attacks on Modern x86
Processors”. In: S&P (May 17–20, 2009). Oakland, California, USA, 2009,
pp. 45–60. doi: 10.1109/SP.2009.19 (cit. on p. 5).

38

[CR11]

[Doy+15]

[Doy07]

[DSF16]

[Fre+11]

[FS00]

[GH21]

[GMR07]

[GSB18]

[GWW18]

[HMP91]

[Hun+02]

Sudipta Chattopadhyay and Abhik Roychoudhury. “Scalable and Precise Re-
ﬁnement of Cache Timing Analysis via Model Checking”. In: RTSS (Nov. 29–
Dec. 2, 2011). Vienna, Austria, 2011, pp. 193–203. doi: 10.1109/RTSS.2011.25
(cit. on p. 6).

Goran Doychev, Boris K¨opf, Laurent Mauborgne, and Jan Reineke. “CacheAu-
dit: A Tool for the Static Analysis of Cache Side Channels”. In: ACM Trans-
actions on Information and System Security 18.1 (2015), 4:1–4:32. doi: 10.
1145/2756550 (cit. on p. 6).

Laurent Doyen. “Robust Parametric Reachability for Timed Automata”. In:
Information Processing Letters 102.5 (2007), pp. 208–213. doi: 10.1016/j.
ipl.2006.11.018 (cit. on pp. 18, 19).

Louise A. Dennis, Marija Slavkovik, and Michael Fisher. “”How Did They
Know?” – Model-Checking for Analysis of Information Leakage in Social Net-
works”. In: COIN@AAMAS (May 9, 2016). Ed. by Stephen Craneﬁeld, Samhar
Mahmoud, Julian A. Padget, and Ana Paula Rocha. Vol. 10315. Lecture Notes
in Computer Science. Singapore: Springer, 2016, pp. 42–59. doi: 10.1007/978-
3-319-66595-5_3 (cit. on p. 6).

Goran Frehse, Colas Le Guernic, Alexandre Donz´e, Scott Cotton, Rajarshi
Ray, Olivier Lebeltel, Rodolfo Ripado, Antoine Girard, Thao Dang, and Oded
Maler. “SpaceEx: Scalable Veriﬁcation of Hybrid Systems”. In: CAV (July 14–
20, 2011). Ed. by Ganesh Gopalakrishnan and Shaz Qadeer. Vol. 6806. Lecture
Notes in Computer Science. Snowbird, UT, USA: Springer, 2011, pp. 379–395.
doi: 10.1007/978-3-642-22110-1_30 (cit. on pp. 4, 29).
Edward W. Felten and Michael A. Schneider. “Timing attacks on Web pri-
vacy”. In: CCS (Nov. 1–4, 2000). Ed. by Dimitris Gritzalis, Sushil Jajodia,
and Pierangela Samarati. Athens, Greece: ACM, 2000, pp. 25–32. doi: 10 .
1145/352600.352606 (cit. on p. 4).

Stefan G¨oller and Mathieu Hilaire. “Reachability in Two-Parametric Timed
Automata with One Parameter Is EXPSPACE-Complete”.
In: STACS
(Mar. 16–19, 2021). Ed. by Markus Bl¨aser and Benjamin Monmege. Vol. 187.
LIPIcs. Saarbr¨ucken, Germany: Schloss Dagstuhl - Leibniz-Zentrum f¨ur Infor-
matik, 2021, 36:1–36:18. doi: 10.4230/LIPIcs.STACS.2021.36 (cit. on p. 35).
Guillaume Gardey, John Mullins, and Olivier H. Roux. “Non-Interference Con-
trol Synthesis for Security Timed Automata”. In: Electronic Notes in Theoret-
ical Computer Science 180.1 (2007), pp. 35–53. doi: 10.1016/j.entcs.2005.
05.046 (cit. on pp. 4, 7, 31, 32, 34).

Christopher Gerking, David Schubert, and Eric Bodden. “Model Checking the
Information Flow Security of Real-Time Systems”. In: ESSoS (June 26–27,
2018). Ed. by Mathias Payer, Awais Rashid, and Jose M. Such. Vol. 10953.
Lecture Notes in Computer Science. Paris, France: Springer, 2018, pp. 27–43.
doi: 10.1007/978-3-319-94496-8_3 (cit. on p. 4).
Shengjian Guo, Meng Wu, and Chao Wang. “Adversarial symbolic execution
for detecting concurrency-related cache timing leaks”. In: ESEC/SIGSOFT
FSE (Nov. 4–9, 2018). Ed. by Gary T. Leavens, Alessandro Garcia, and Corina
S. Pasareanu. Lake Buena Vista, FL, USA: ACM, 2018, pp. 377–388. doi:
10.1145/3236024.3236028 (cit. on p. 6).

Thomas A. Henzinger, Zohar Manna, and Amir Pnueli. “Temporal Proof
Methodologies for Real-time Systems”. In: POPL (Jan. 21–23, 1991). Ed. by
David S. Wise. Orlando, Florida, USA: ACM Press, 1991, pp. 353–366. doi:
10.1145/99583.99629 (cit. on p. 8).

Thomas Hune, Judi Romijn, Mari¨elle Stoelinga, and Frits W. Vaandrager.
“Linear parametric model checking of timed automata”. In: Journal of Logic
and Algebraic Programming 52-53 (2002), pp. 183–220. doi: 10.1016/S1567-
8326(02)00037-1 (cit. on pp. 7, 11, 19, 20, 31).

39

[JLR15]

[Koc+20]

[Koc96]

[Kot+13]

[Lim+09]

[LPY97]

[Lv+10]

[Mil00]

[Min67]

[Mol+05]

[NNV17]

[Ros19]

Aleksandra Jovanovi´c, Didier Lime, and Olivier H. Roux. “Integer Parameter
Synthesis for Real-Time Systems”. In: IEEE Transactions on Software Engi-
neering 41.5 (2015), pp. 445–461. doi: 10.1109/TSE.2014.2357445 (cit. on
pp. 9, 12, 18, 19, 21, 24).

Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner
Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher,
Michael Schwarz, and Yuval Yarom. “Spectre attacks: Exploiting speculative
execution”. In: Communications of the ACM 63.7 (2020), pp. 93–101. doi:
10.1145/3399742 (cit. on p. 5).

Paul C. Kocher. “Timing Attacks on Implementations of Diﬃe-Hellman, RSA,
DSS, and Other Systems”. In: CRYPTO (Aug. 18–22, 1996). Ed. by Neal
Koblitz. Vol. 1109. Lecture Notes in Computer Science. Santa Barbara, Cal-
ifornia, USA: Springer, 1996, pp. 104–113. doi: 10.1007/3- 540- 68697- 5_9
(cit. on p. 4).

Robert Kotcher, Yutong Pei, Pranjal Jumde, and Collin Jackson. “Cross-origin
pixel stealing: timing attacks using CSS ﬁlters”. In: CCS (Nov. 4–8, 2013). Ed.
by Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung. Berlin, Germany:
ACM, 2013, pp. 1055–1062. doi: 10.1145/2508859.2516712 (cit. on p. 4).

Didier Lime, Olivier H. Roux, Charlotte Seidner, and Louis-Marie Traonouez.
“Romeo: A Parametric Model-Checker for Petri Nets with Stopwatches”. In:
TACAS (Mar. 22–29, 2009). Ed. by Stefan Kowalewski and Anna Philip-
pou. Vol. 5505. Lecture Notes in Computer Science. York, United Kingdom:
Springer, Mar. 2009, pp. 54–57. doi: 10.1007/978-3-642-00768-2_6 (cit. on
p. 29).

Kim Guldstrand Larsen, Paul Pettersson, and Wang Yi. “UPPAAL in a Nut-
shell”. In: International Journal on Software Tools for Technology Transfer
1.1-2 (1997), pp. 134–152. doi: 10.1007/s100090050010 (cit. on pp. 4, 13, 29).

Mingsong Lv, Wang Yi, Nan Guan, and Ge Yu. “Combining Abstract Interpre-
tation with Model Checking for Timing Analysis of Multicore Software”. In:
RTSS (Nov. 30–Dec. 3, 2010). San Diego, California, USA: IEEE Computer
Society, 2010, pp. 339–349. doi: 10.1109/RTSS.2010.30 (cit. on p. 30).

Joseph S. Miller. “Decidability and Complexity Results for Timed Automata
and Semi-linear Hybrid Automata”. In: HSCC (Mar. 23–25, 2000). Ed. by
Nancy A. Lynch and Bruce H. Krogh. Vol. 1790. Lecture Notes in Computer
Science. Pittsburgh, PA, USA: Springer, 2000, pp. 296–309. doi: 10.1007/3-
540-46430-1_26 (cit. on pp. 18, 19).

Marvin L. Minsky. Computation: Finite and inﬁnite machines. Upper Saddle
River, NJ, USA: Prentice-Hall, Inc., 1967. isbn: 0-13-165563-9 (cit. on p. 18).

David Molnar, Matt Piotrowski, David Schultz, and David A. Wagner. “The
Program Counter Security Model: Automatic Detection and Removal of
Control-Flow Side Channel Attacks”. In: ICISC. Seoul, Korea, 2005, pp. 156–
168. doi: 10.1007/11734727_14 (cit. on p. 5).

Flemming Nielson, Hanne Riis Nielson, and Panagiotis Vasilikos. “Information
Flow for Timed Automata”. In: Models, Algorithms, Logics and Tools. Ed. by
Luca Aceto, Giorgio Bacci, Giovanni Bacci, Anna Ing´olfsd´ottir, Axel Legay,
and Radu Mardare. Vol. 10460. Lecture Notes in Computer Science. Springer,
2017, pp. 3–21. doi: 10.1007/978-3-319-63121-9_1 (cit. on p. 4).

Amnon Rosenmann. “The Timestamp of Timed Automata”. In: FORMATS
(Aug. 27–29, 2019). Ed. by ´Etienne Andr´e and Mari¨elle Stoelinga. Vol. 11750.
Lecture Notes in Computer Science. Amsterdam, The Netherlands: Springer,
2019, pp. 181–198. doi: 10.1007/978-3-030-29662-9_11 (cit. on pp. 5, 15).

40

[Sch99]

[SPW18]

[VNN18]

[Wei99]

[WS17]

[Wu+18]

[WZ18]

[WZA18]

[Zha+18]

linear and integer programming. Wiley-
Alexander Schrijver. Theory of
Interscience series in discrete mathematics and optimization. Wiley, 1999. isbn:
978-0-471-98232-6 (cit. on p. 11).

Chungha Sung, Brandon Paulsen, and Chao Wang. “CANAL: a cache tim-
ing analysis framework via LLVM transformation”. In: ASE (Sept. 3–Mar. 7,
2018). Montpellier, France, 2018, pp. 904–907. doi: 10.1145/3238147.3240485
(cit. on p. 6).

Panagiotis Vasilikos, Flemming Nielson, and Hanne Riis Nielson. “Secure In-
formation Release in Timed Automata”. In: POST (Apr. 14–20, 2018). Ed. by
Lujo Bauer and Ralf K¨usters. Vol. 10804. Lecture Notes in Computer Science.
Thessaloniki, Greece: Springer, 2018, pp. 28–52. doi: 10.1007/978- 3- 319-
89722-6_2 (cit. on pp. 4, 31, 32, 34).

Volker Weispfenning. “Mixed Real-Integer Linear Quantiﬁer Elimination”. In:
ISSAC (July 29–31, 1999). Ed. by Keith O. Geddes, Bruno Salvy, and Samuel
S. Dooley. Vancouver, BC, Canada: Association for Computing Machinery,
1999, pp. 129–136. doi: 10.1145/309831.309888 (cit. on pp. 3, 15–17).

Chao Wang and Patrick Schaumont. “Security by compilation: an automated
approach to comprehensive side-channel resistance”. In: SIGLOG News 4.2
(2017), pp. 76–89. doi: 10.1145/3090064.3090071 (cit. on p. 5).

Meng Wu, Shengjian Guo, Patrick Schaumont, and Chao Wang. “Eliminat-
ing timing side-channel leaks using program repair”. In: ISSTA (July 16–21,
2018). Amsterdam, The Netherlands, 2018, pp. 15–26. doi: 10.1145/3213846.
3213851 (cit. on p. 5).

Lingtai Wang and Naijun Zhan. “Decidability of the Initial-State Opacity of
Real-Time Automata”. In: Symposium on Real-Time and Hybrid Systems -
Essays Dedicated to Professor Chaochen Zhou on the Occasion of His 80th
Birthday. Ed. by Cliﬀ B. Jones, Ji Wang, and Naijun Zhan. Vol. 11180. Lecture
Notes in Computer Science. Springer, 2018, pp. 44–60. doi: 10.1007/978-3-
030-01461-2_3 (cit. on p. 5).

Lingtai Wang, Naijun Zhan, and Jie An. “The Opacity of Real-Time Au-
tomata”. In: IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems 37.11 (2018), pp. 2845–2856. doi: 10.1109/TCAD.2018.
2857363 (cit. on p. 5).

Jun Zhang, Pengfei Gao, Fu Song, and Chao Wang. “SCInfer: Reﬁnement-
Based Veriﬁcation of Software Countermeasures Against Side-Channel At-
tacks”. In: CAV, Part II (July 14–17, 2018). Ed. by Hana Chockler and Georg
Weissenbacher. Vol. 10982. Lecture Notes in Computer Science. Oxford, UK,
2018, pp. 157–177. doi: 10.1007/978-3-319-96142-2_12 (cit. on p. 6).

41

A The code of the Java example

j a v a . i o . B u f f e r e d R e a d e r ;
j a v a . i o . I O E x c e p t i o n ;
j a v a . i o . I n p u t S t r e a m R e a d e r ;
j a v a . i o . P r i n t W r i t e r ;
j a v a . n e t . S e r v e r S o c k e t ;
j a v a . n e t . S o c k e t ;

1 i m p o r t
2 i m p o r t
3 i m p o r t
4 i m p o r t
5 i m p o r t
6 i m p o r t
7
8 // C o e f f i c i e n t s a r e D i s r e g a r d e d
9 p u b l i c c l a s s C a t e g o r y 1 v u l n e r a b l e {

10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68 }

p r i v a t e
p r i v a t e
p r i v a t e
p r i v a t e

f i n a l
s t a t i c
f i n a l
s t a t i c
s t a t i c
f i n a l
s t a t i c S e r v e r S o c k e t

i n t p o r t = 8 0 0 0 ;
i n t
i n t n = 3 2 ;

s e r v e r ;

s e c r e t = 1 2 3 4 ;

p r i v a t e

s t a t i c v o i d c h e c k S e c r e t ( i n t g u e s s ) t h r o w s

I n t e r r u p t e d E x c e p t i o n {

i f

( g u e s s <= s e c r e t ) {

f o r

( i n t
f o r

i = 0 ;

i < n ;

i ++) {

( i n t
t = 0 ;
Thread . s l e e p ( 1 ) ;

t < n ;

t++) {

}

}
} e l s e {

f o r

( i n t
f o r

i = 0 ;

i < n ;

i ++) {

( i n t
t = 0 ;
Thread . s l e e p ( 2 ) ;

t < n ;

t++) {

}

}

}

}

p r i v a t e

s t a t i c v o i d s t a r t S e r v e r ( ) {

t r y {

s e r v e r = new S e r v e r S o c k e t ( p o r t ) ;
System . o u t . p r i n t l n ( ” S e r v e r S t a r t e d P o r t : ” + p o r t ) ;
S o c k e t c l i e n t ;
P r i n t W r i t e r o u t ;
B u f f e r e d R e a d e r
S t r i n g u s e r I n p u t ;
i n t g u e s s ;
w h i l e ( t r u e ) {

i n ;

c l i e n t = s e r v e r . a c c e p t ( ) ;
o u t = new P r i n t W r i t e r ( c l i e n t . g e t O u t p u t S t r e a m ( ) ,
i n = new B u f f e r e d R e a d e r ( new I n p u t S t r e a m R e a d e r ( c l i e n t . g e t I n p u t S t r e a m

t r u e ) ;

( ) ) ) ;

u s e r I n p u t = i n . r e a d L i n e ( ) ;
t r y {

g u e s s = I n t e g e r . p a r s e I n t ( u s e r I n p u t ) ;
i f ( g u e s s < 0 ) {

t h r o w new I l l e g a l A r g u m e n t E x c e p t i o n ( ) ;

}
c h e c k S e c r e t ( g u e s s ) ;
o u t . p r i n t l n ( ” P r o c e s s Complete ” ) ;

} c a t c h ( I l l e g a l A r g u m e n t E x c e p t i o n |

I n t e r r u p t e d E x c e p t i o n e ) {

o u t . p r i n t l n ( ” U n a b l e t o P r o c e s s

I n p u t ” ) ;

}
c l i e n t . shutdownOutput ( ) ;
c l i e n t . s h u t d o w n I n p u t ( ) ;
c l i e n t . c l o s e ( ) ;

}

} c a t c h ( I O E x c e p t i o n e ) {
System . e x i t ( −1) ;

}

}

p u b l i c s t a t i c v o i d main ( S t r i n g [ ] a r g s ) t h r o w s

I n t e r r u p t e d E x c e p t i o n {

s t a r t S e r v e r ( ) ;

}

Note that

the two “for” loops

(resp. 2)
equivalently replaced with a simple Thread.sleep(32*32) (resp.

featuring a Thread.sleep(1)

could be
Thread.sleep(2*32*32)) statement, but

1. this is the way the program is presented in the DARPA library, and

2. a (minor) diﬃculty may come from these loops

instead of a simple

Thread.sleep(32*32) statement.

42

