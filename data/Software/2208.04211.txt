This work has been submitted to the IEEE for possible publication. Copyright may be
transferred without notice, after which this version may no longer be accessible.

2
2
0
2

g
u
A
8

]

O
R
.
s
c
[

1
v
1
1
2
4
0
.
8
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

1

Behavior Trees and State Machines
in Robotics Applications

Razan Ghzouli, Swaib Dragule, Thorsten Berger, Einar Broch Johnsen and Andrzej Wasowski

Abstract—Autonomous robots combine a variety of skills to form increasingly complex behaviors called missions. While the skills are often
programmed at a relatively low level of abstraction, their coordination is architecturally separated and often expressed in higher-level lan-
guages or frameworks. State Machines have been the go-to modeling language for decades, but recently, the language of Behavior Trees
gained attention among roboticists. Originally designed for computer games to model autonomous actors, Behavior Trees offer an extensi-
ble tree-based representation of missions and are praised for supporting modular design and reuse of code. However, even though, several
implementations of the language are in use, little is known about its usage and scope in the real world. How do concepts offered by behavior
trees relate to traditional languages, such as state machines? How are behavior tree and state machine concepts used in applications?
We present a study of the key language concepts in Behavior Trees and their use in real-world robotic applications. We identify behavior
tree languages and compare their semantics to the most well-known behavior modeling language in robotics: state machines. We mine
open source repositories for robotics applications that use the languages and analyze this usage. We ﬁnd similarity aspects between
the two behavior modeling languages in terms of language design and their usage in open-source projects to accommodated the need
of robotic domain. We ﬁnd that behavior trees and state machines existing implementations are pragmatic languages, not fully speciﬁed,
allowing projects to extend models even for just one model. The identiﬁed libraries offer frequent control ﬂow constructs with different
range of support. The usage of behavior trees libraries among open-source projects is increasing rapidly. Similar patterns of usage in
model structure and reuse of code are observed in projects using behavior trees and state machines. We contribute a dataset of real-world
behavior models, hoping to inspire the community to use and further develop this language, associated tools, and analysis techniques.

Index Terms—behavior trees, state machines, robotics applications, usage patterns, empirical study

(cid:70)

1 INTRODUCTION

The robots are coming! They can perform tasks in environ-
ments that defy human presence, such as ﬁre ﬁghting in
dangerous areas or disinfection in contaminated hospitals.
Robots can handle increasingly difﬁcult tasks, ranging from
pick-and-place operations to complex services performed
while navigating in dynamic environments. Robots combine
skills to form complex behaviors, known as missions [1],
[2]. While skills are typically programmed at a relatively
low level of abstraction (such as controllers for sensors and
actuators), the coordination of skills to form missions is
either programmed at a low-level intimately tied to the
implementation of skills, or higher-level representations
(using behavior models). With the increasing complexity of
robot systems, using higher-level representations of missions
has become increasingly important to improve their software
quality and maintainability [3], [4], [5].

State machines have long been among the most common
modeling notations for mission speciﬁcation, but in recent
years, behavior tree are attracting the attention of roboti-
cists to express such high-level coordination. Behavior tree
were originally invented for computer games to deﬁne the
behavior of autonomous non-player characters. Similar to
autonomous robots, non-player characters are reactive and
make decisions in complex and unpredictable environments
[6], [7]. Their popularity in robotics stems from their modular-
ity and malleability when expanding or debugging missions
[8], [9], [10], [11], [12], [13], [14], [15]. Users appreciate a
purportedly easy-to-understand hierarchical structure, able
to represent layers of behavior.

Many researchers have praised behavior trees for their
modularity, ﬂexibility, reusability, and ability to express
reactive behavior [8], [9], [10], [11], [12], [14], [16]. However,
none of these claims has been studied for behavior tree
models in real-world projects—the main motivation behind
our study. To our knowledge, there has been no study to
understand the language implementations and tools for
behavior trees and state machines and the usage of existing
implementations in real-world projects. In this paper, we
explore the concepts offered by the two modeling languages
as realized in the existing implementations (libraries) and
how these are exploited by the users of these libraries, based
on open-source projects.

Goal and Research Questions

We present a study of behavior tree and state machine
languages and their use in real-world robotic applications.
Speciﬁcally, we ask the following research questions:

RQ1. What modeling concepts from behavior trees and state ma-
chines are available in real language implementations (libraries)?
We identiﬁed four languages implementations (libraries)
in robotics for both behavior modeling notations that support
the Robot Operating System (ROS) [17]—a middleware
and framework for developing robotics applications,
surrounded by the largest ecosystem of robotics libraries
(ROS packages)—and that are actively maintained and
documented. Then, we extracted and analyzed the concepts,
speciﬁcally their syntaxes and semantics, in behavior tree
and state machine languages. Our goal was to understand
the available behavior tree and state machine concepts in

practice, and the similarities and differences between the
two kinds of modeling notations.

RQ2. How are these languages (libraries) engineered in practice?
For the identiﬁed languages, we studied the key design
principles and language implementation architectures in
behavior trees and state machines libraries. By looking at the
languages implementations, we capture the used techniques
and practices in the robotic community. By analyzing these
languages that originate from practice by roboticists, we can
understand better the design concepts needed in the robotic
domain and discuss potential improvements.

RQ3. How are behavior tree and state machine models used in
robotics projects?

We mined GitHub for open-source repositories that use
the identiﬁed behavior tree and state machine libraries, and
we analyzed their usage in robotic applications. We checked
the usage trends of the languages, which can indicate their
popularity. We extracted a sample of the mined projects
and analyzed the usage of behavior tree and state machine
concepts and the structure of their models in the sampled
projects. Finally, we investigated the reuse mechanisms in the
projects using a mixture of visual and code-level inspections.
Reuse mechanisms are important to scale and to sustain
the use of behavior trees and state machines in practice. In
addition, reuse is one of the major issues in robotics software
engineering [1], [5], [18], [19], [20]. In summary, our goal is to
report on empirical results regarding the usage of behavior
trees and state machines in open-source robotic projects by
checking the popularity of the implementations, the structure
of the models, the usage frequency of the identiﬁed concepts,
and the state-of-practice of reuse in behavior tree and state
machine implementations.

Journal Extension

This paper is an extended version of a prior conference paper
[21]. In this work, we broaden the scope of our study to
include state machine languages. We extract their modeling
concepts and we compare them to behavior tree concepts that
were extracted in the former work. Also, we update the collec-
tion of real-world behavior tree robotic models, and we addi-
tionally mine real-world robotic projects using state machine
languages. Finally, a qualitative and quantitative discussion
is added to compare these behavior modeling languages by
comparing the same number of state machine and behavior
tree models. Thus, compared to the former work our focus is
shifted from only behavior trees to include a comparison with
state machines in terms of concepts and robotic applications.

Results

Our analysis of the modeling concepts offered in the behavior
tree and state machine languages (RQ1) shows similarities
between the identiﬁed implementations in terms of lan-
guages design and the offered concepts. Both the languages’
openness and the support for domain-speciﬁc patterns seem
common needs in robotics. Openness is a common feature
in the studied languages, which do not enforce ﬁxed model,
but allow, even expect, concrete projects to extend it by-need.
Another observation is that all of the studied libraries offer
constructs for frequent control ﬂow patterns. The range of
support differed between behavior tree and state machine

libraries, but regardless of that, accommodating the needs of
a speciﬁc domain users is a good language design practice.
We have observed in our analysis of the implementation
design of behavior tree and state machine languages (RQ2)
that having a visualization tool for model construction and
monitoring could provide better understanding of the model
and reuse of code. In the implementations that provided a
graphical notation with a GUI-based editor, projects were
using more often constructs built into the language, such as
Decorators in behavior trees and Concurrency container in
state machines (introduced shortly in Section 4). Meanwhile,
projects using implementations with no GUI leaked these
construct to the code instead of the model. This is closely
related to the fact that the implementations with no GUI are
considered internal domain speciﬁc languages (DSLs), and
the ones with GUI are external DSLs. It shows that external
DSLs enforce using the DSL constructs (decorators), while
in internal DSLs, it is easy to deviate and use ordinary pro-
gramming language constructs. Despite it being a pragmatic
practice, it will hinder maintainability and analyzability of
the behavior trees in the long term. The same argumentation
holds for state machines. Another observation is that all the
languages follow the models-at-runtime paradigm [22], [23].
Models are used for coordinating skills, actions, and tasks,
which are implemented by lower-level means, such as ROS
components.

Our analysis of robotics projects using behavior tree and
state machine languages (RQ3) has provided insights on
the usage of these languages in practice. The ﬁrst ﬁnding
showed that the usage of behavior trees is rapidly increasing
within real robotics projects. Second, the usage of the
libraries among developers from a structural perspective
was another similarity we observed. Developers kept the
structure of models somehow simple. Shallow behavior tree
and state machine models, and moderate sizes of models,
were observed among the majority of the different projects.
From our own experience in analyzing these models, we
noticed keeping the behavior model simple, regardless of the
type, helps in its understandability. Finally, code reuse among
users of the different libraries showed a similar pattern of
mechanisms usage, depending on whether a skill(action)
is being reused or a task (multiple actions combined in a
sub-tree or state machine).

Perspective

With this paper, we hope to raise the interest of two research
communities—software language engineering and software
modeling—in languages for robotic behavior. We hope that
observing the current state-of-practice can help improving on
it. We also hope that this analysis can inspire designers of be-
havior tree languages and state machines to revisit, or at least
justify, some design choices. In addition, taking improvement
points from each others could be a starting point, since some
of these tools are built with model-based design concepts in
mind and other good language design principles. Finally, we
contribute a dataset of real-world behavior models, hoping
to inspire the community to use and further develop these
languages, associated tools, and analysis techniques. An
accompanying online appendix [24] contains the models
dataset, mining and analysis scripts, and further details.

2 BACKGROUND

Behavior trees are well-suited to express the runtime behav-
ior of agents, which has fueled applications in computer
games and robotics. High-proﬁle games, such as Halo [7],
use behavior trees. In the robotic community, there has been
a growing interest in behavior trees. There was a dedicated
workshop on behavior trees in robotics at IROS’19,1 one of
the key research conferences in robotics. ROS, the main open
source platform for robotics software, has recently adopted
behavior trees as the main customization mechanism for
its navigation stack [25]. In addition, multiple projects in
RobMoSys, one of the leading model-driven communities in
robotics,2 have been launched to create a set of best practices
and tools for behavior trees (e.g., CARVE3 and MOOD2Be4).
The EU project Co4Robots5 developed a mission-speciﬁcation
DSL for multiple robots based on behavior tree concepts
[15], [26]. A number of libraries has been developed to
implement behavior trees, including common libraries such
as BehaviorTree.CPP and PyTrees. In this paper, we
explore the concepts offered by behavior tree languages and
how these are exploited by the users of these libraries, based
on open source projects.

1: An example behavior

a health
of
Fig.
and safety robot
from a GitHub project
kmi-robots/hans-ros-supervisor shown in the Groot
editing and animation tool from BehaviorTree.CPP.

inspector

tree

1. https://behavior-trees-iros-workshop.github.io/
2. https://robmosys.eu/
3. https://carve-robmosys.github.io/
4. https://robmosys.eu/mood2be
5. http://www.co4robots.eu

Root

Parallel

Condition

Sequence

Decorator

Selector

Action

Fig. 2: Behavior Trees node types (visual syntax)

Behavior Tree Illustrative Example

Figure 1 presents an example of a behavior tree model of a
health and safety inspector robot from the Knowledge Media
Institute.6 The robot performs an exploration sequence for
an area. The main operation is placed at the bottom, in the
sub-tree under ExplorationSeq: it consists of obtaining
the next waypoint, moving the mobile base to the waypoint,
and exploring the area. If obtaining a new waypoint fails
(empty stack) the ﬁrst task fails, which is inverted into a
success by an (Inverter) and this means that the sequence
of motions has been completed. Otherwise, the robot keeps
repeating the same operation (next point, move, explore) up
to 10 times, as long as the stack is not empty. The entire
computation is placed in an inﬁnite loop of alternating
obtaining new waypoints and performing the exploration
sequence (MainSeq) until the success of all children.

Behavior Tree Concepts

In general, behavior trees can be seen as graphical models
that are shaped as a directed tree with a dedicated root
node, with non-leaf nodes called control-ﬂow nodes and
with leaf nodes called execution nodes. A behavior tree is
executed by sending signals called ticks from the root node
down traversing the tree according to the semantics of the
control-ﬂow nodes. Ticks are issued with a speciﬁc frequency
[8], [27]. Upon receiving a tick, a node executes a task,
which can be a control-ﬂow task or, if a leaf node is ticked,
some speciﬁc robotic task. The latter classiﬁes into actions
(e.g., MoveBase in Fig. 1) and conditions, which can test
propositions (e.g., whether the robot is at its base) used to
control task execution. A ticked node returns its status to
its parent: (1) success when a task is completed successfully,
(2) failure when a task execution failed, and (3) running when
a task is still under execution.

The beneﬁt of using behavior trees lies in their ability to
express task coordination using a small, but extensible set
of control-ﬂow nodes. Most behavior tree languages offer
the control-ﬂow nodes sequence, selector, decorator, and
parallel, which we discuss in detail in Sect. 5. The visual
presentation of the main node types as used in robotics and
games [8], [27], [28] is summarized in Fig. 2. Our example
in Fig. 1 illustrates two sequence nodes (MainSeq and
ExplorationSeq) and two decorator nodes (Inverter
and RetryUntilSuccesful). Intuitively, sequence nodes
tick all of their children and require all of them to succeed
for the sequence node to succeed, while selector nodes only
require one child success to succeed. Decorator nodes allow
more complex control ﬂow, including for and while loops.
They are also extensible; developers can implement custom
decorator nodes. Finally, parallel nodes are generalizations
of sequence and selector nodes, allowing custom policies,

6. http://kmi.open.ac.uk/

Root??Root?RootInitial state

State

Transition

Final state

Composite
state with
nested-
states

Fig. 4: State Machines node (state) types and transitions
(visual syntax) according to UML

Just like behavior trees, state machines provide graphical
models to represent the behavior of a robotic agent when
executing tasks. A state machine model is a directed graph of
nodes and arcs often called states and transitions, respectively.
A state is associated with a skill, often called an action, to
be executed. Although it is called an action, the associated
skill could be an action or a condition, unlike in behavior
trees. A transition is often associated with a condition. If the
condition is satisﬁed, the associated transition is ﬁred to its
target state. The execution behavior of state machines can be
modeled using Moore automaton [33], in which a transition
from the current state to the next state is determined by
evaluating the transition condition (outcome of the current
state). When the condition is true, the robot transits to the
corresponding state. A state may have multiple outgoing
transitions, but a transition has only one target state.

Hierarchical state machines, also known as statecharts
[34], are an extension of state machines that allows nesting
(hierarchy) and concurrency [34], [35]. Thus, the hierarchical
state machine model is similar to state machines with
the ability to separate behaviors into sub-states, thereby
increasing the modularity of the model and decreasing the
number of transitions needed.

Fig. 3: A state machine example representing the same
mission in Fig. 1 using SMACH syntax.

such as cardinalities specifying the minimum or maximum
number of nodes that need to succeed.

State Machine Illustrative Example

3 METHODOLOGY

Figure 3 shows the same mission as in Fig. 1 for a health
and safety inspector robot represented by us using SMACH
syntax. The ExplorationSeq of the behavior tree model
is placed in a nested state machine Exploration_seq.
The model exit from the Exploration_seq in case the
navigation or exploration fails (Failure state is reached), or
no waypoints are left (Finished state is reached). As long
as the nested ExplorationSeq is successful (Explore
outcome is succeeded), it is iterated through ten times using
the Iterator container (described shortly in Sect. 4.2),
Interator_10_attempts.

State Machine Concepts

State machines and Hierarchical state machine have been
used for decades in different domains with slight variations
in syntax and semantics [30], [31]. While there exist multiple
syntaxes with minor modiﬁcations, the Uniﬁed Modeling
Language (UML) state diagram might be the most common
visual syntax, especially in the software modeling community
(see Fig. 4). In this work, we reﬂect on the syntax and
semantic that we observed in the robotic models using
state machine implementations, which are similar to Moore
machines [32] from the computational perspective.

We now describe our methodology for identifying and
analyzing behavior tree and state machine languages
(RQ1), for analyzing their implementations (RQ2), and for
identifying and analyzing real-world robotic projects using
these languages (RQ3).

3.1 Identifying Languages and Concepts (RQ1)

We started identifying behavior tree languages by searching
GitHub for popular behavior tree libraries in Python and
C++, the most used programming languages in robotics. A
similar search for state machine languages yielded hundreds
of results. Therefore, we decided to use the Robot Operating
System (ROS) wiki platform for ﬁnding state machine
languages. This platform is commonly used by developers to
publish their open-source languages and tools for developing
robotic applications. By searching the ROS wiki platform
instead of searching GitHub or Google, we ensure that the
identiﬁed languages support ROS, thus we exclude non-
robotic projects in later steps.

To ensure the relevance of the identiﬁed libraries for
real-world robotic applications for both behavior trees and
state machines, we focused on maintained libraries and
for that we applied the following exclusion criteria: (1) lack

CollectWayPointsPopWayPointMoveBaseExploresuccesssuccessSuccess/num_attmp=0FinishedCollectWayPointsPopWayPointMoveBaseExplorePopWayPointMoveBaseExploreIterator_10_attempsSucceededSucceededWaypoints left?FalseTrueSucceededCollectWayPointsInspect_SMPopWayPointMoveBaseExploreIterator_10_attempsSucceededSucceededSucceededWaypoints left?FalseTrueSucceededFinishedPopWayPointMoveBaseExploreIterator_10_attempsSucceededSucceededSucceededWaypoints left?FalseTrueSucceededFinishedflexbeSmachFail & num_attmp<10Fail &num_attmp>=10SuccessFail &num_attmp>=10/num_attemp++Fail &num_attmp>=10/num_attemp++CollectWayPointsPopWayPointMoveBaseExploresuccesssuccessFailFail & num_attmp<10Fail &num_attmp>=10SuccessSuccess/num_attmp=0CollectWayPointsPopWayPointMoveBaseExploreSuccessSuccessSuccess/num_attempts=0FailFailFailFailSuccess &num_attempts<10/num_attempts++Success&num_attempts>=10Model 22/11Model 02/12CollectWayPointsPopWayPointMoveBaseExploresuccesssuccessFailSuccess&num_attempts<10//num_attempts++Success&num_attempts>=10FailSuccess/num_attempts=0FailModel 02/12Model 22/11Model 22/11Model 02/12FinishedCollectWayPointsPopWayPointMoveBaseExplorePopWayPointMoveBaseExploreIterator_10_attemptsSuccessSuccessWaypoints left?FalseTrueSuccessCollectWayPointssucceededInspect_SMsucceededPopWayPointMoveBaseExploreIterator_10_attemptssucceededsucceededsucceededSucceededWaypoints left?FalseTruesucceededFinishedflexbeSmachFailFailedFailedCollectWayPointssucceededInspect_SMSuccessSmachFailedFinishedPopWayPointMoveBaseExploreExploration_seqsucceededsucceededFinishedFailedsucceededPopWayPointMoveBaseExploreExploration_seqsucceededsucceededFinishedFailedsucceededIterator_10_attemptsChoose_actionsChoose_actionsFailureFailedFailedFailureSuccessFinishedFailedFailureFailedTitleTitleTitleTitleCompositeStateCompositeStateevent[ guard ] / actionsTitleTitleState nameentry/action 1exit/action 2State nameentry/action 1exit/action 2S1S2CompositeStateCompositeStateevent[ guard ] / actionsTitleTitleTitleTitleS1S2TitleTitleevent[ guard ] / actionsTitleTitleof documentation, (2) out-dated libraries not maintained
anymore (last commit older than 2019), (3) no ROS support
(this was checked speciﬁcally for the identiﬁed behavior tree
implementations since we collected them through GitHub)
and (4) no mined projects.

Thereafter, to understand the key characteristics and
modeling concepts offered by the languages, we identiﬁed
their main concepts and studied the relation between them.
For our comparison, we collected behavior tree concepts
by exploratory literature search [8], [28], [36] and snow-
balling. For the identiﬁed languages, we inspected their
documentation [37], [38] and wrote scripts to understand
better their semantics. A similar approach was followed to
collect state machine concepts from the literature [39], [40],
[41] and the documentation of the identiﬁed libraries [42],
[43]. In this process, we focused on behavior tree concepts
and whether state machines offer direct support for similar
concepts or they need to be expressed indirectly. Our analysis
was iterative, to ensure a proper reﬂection of the concepts in
the different languages.

3.2 Language Implementations (RQ2)

After identifying the relevant libraries that support state
machine and behavior tree modeling languages and analyz-
ing their syntax and semantic, we wanted to understand
the implementation design of the libraries. We built our
ﬁndings from inspecting different sources. Speciﬁcally, we
inspected the implementations of the libraries on GitHub,
documentations [37], [38], [42], [43], [44], tutorials [45], [46],
[47], [48], and related publications [39], [40], [49], [50], [51].
We focused on the language design of the libraries and
offered concrete syntax. We went through the tutorials of the
libraries and related publications to reﬂect on the dynamicity
of the libraries. By dynamicity we refer to the ability of
runtime modiﬁcation of models. Finally, we examined the
model of concurrency used in the libraries by examining
their implementations on GitHub and documentation.

3.3 Identifying Languages Projects and Analysis (RQ3)

To understand the usage of the identiﬁed languages in robotic
projects (1) we mine GitHub for open-source repositories
using these languages in their robotic missions implemen-
tations, then (2) we compare the popularity of languages
in open-source projects over time and analyze a sample of
these projects usage of the languages concepts and models
structure, and ﬁnally (3) we observe how the language users
have carried-out code reuse in practice. In the followings, we
provide a detailed description of these steps.

Mining GitHub

Open-source projects have been used in software engineering
and robotic communities to understand real-world appli-
cations. Different open-source platforms like GitHub have
introduced great opportunities for researchers to identify
the different state-of-the-practice in robotics and software
engineering [52], [53], [54]. Motivated by our previous work
[21] and other researchers who mined GitHub, we use
GitHub as a source for mining open-source robotic projects.
For the identiﬁed behavior tree and state machine li-
braries, we investigated how they are used in the source

Fig. 5: Filtering steps to identify relevant repositories.

code of robotic projects. In BehaviorTree.CPP, the term
main tree to execute refers to the entry point tree in the XML
source code, while the term py trees ros, smach ros, and
ﬂexbe core are used to import the languages PyTrees_ros,
SMACH and FlexBe, respectively. These terms must be used
in the source code of targeted languages. We created a Python
script to mine GitHub repositories for those terms with a
simple text-match in source code using the code search API
from GitHub.

Next, we wanted to ﬁlter-out projects belonging to a
course or tutorial to reﬂect on actual usage of the libraries
in robotics. Inspired by the work of Malavolta et al [52]
in providing mining guidelines for robotic software, we
used a similar ﬁltering mechanism with minor changes to
adopt it to our goal. Figure 5 shows our ﬁltering mechanism.
After mining GitHub for open-source projects (step 1), we
excluded forked repositories using a Python script (step
2). By ﬁltering forked repositories, we exclude duplicate
models. After a quick inspection, we noticed that there
are duplicate repositories that were not forked, instead
they might have been cloned then re-uploaded to the
user’s GitHub account. To ﬁlter them out, we extracted
the repositories with the same project name belonging to
different GitHub users using a Python script, inspected
them manually to ensure they are duplicates, and deleted
them from our lists (step 3). In our previous inspection, we
noticed that repositories with the keyword (tool) in their
name often belonged to software tools where the targeted
libraries are requirements for their functionalities. Since our
goal is collecting the implementations of robotic projects
rather than supportive tools, we excluded repositories with
the keyword (tool) in their name using a Python script (step
4). We also excluded the following organizations as users
since they either correspond to tutorials repositories of the
libraries creators, or they are known tools using the identiﬁed
languages as requirements (BehaviorTree, splintered-reality,
team-vigir, ros-planning, ros-infrastructure, carla-simulator).
Finally, we used different Python scripts to inspect the
repositories name, readme, and description, and exclude
those with the following keywords: (assignment, course,

GitHubInitial searchFilter forked repositoryFilter repository belonging to a toolFilter duplicates based on nameFilter based on name\readme\descriptionDownload model filesDownloaded modelstutorial, introduction) (step 5). This ensures the exclusion of
projects belonging to (1) an assignment or to (2) a course. By
the end of this step, we had a list of relevant repositories that
match our criteria.

metrics between the two architectures and other metrics
only for one architecture. To distinguish between them, we
are using the abbreviations SM and BT to indicate which
architecture the metric belongs to. Those metrics are:

Our next step was downloading the ﬁles that contain
the models from these repositories (step 6). Through our
analysis while extracting concepts in Section 4, we identiﬁed
speciﬁc terms used in each language when constructing
the behavior model. In BehaviorTree.CPP, the term
main tree to execute refers to the entry point when construct-
ing the tree. In PyTrees_ros, add child is usually used
when adding nodes to the tree. Finally, StateMachine.add and
OperatableStateMachine.add are used in SMACH and FlexBe,
respectively, to add states. Using these terms, we matched the
ﬁles in the GitHub repositories that contain them and down-
loaded them. For all the previous steps, we used Python reg-
ular expression, Requests API and the code search API from
GitHub. All codes can be found in our online appendix [24].

Analyzing Models

To understand the usage of behavior trees and state machines
in robotics (RQ3), we analyzed the mined projects from two
different perspectives: the popularity of languages over time,
and the structure of models. As a start and to understand
the popularity of languages, we extracted the creation date
and last commit date for repositories to plot the number of
active projects per year. We assume a project is active in the
duration between its creation date and last commit. We used
all mined projects before ﬁltration and only excluded those
belonging to the languages organizations/creators, which
are the following: (BehaviorTree, team-vigir, pschillinger,
FlexBE,
ros-visualization). The
collected projects were mined until 31/12/2021 to capture
activity until the end of 2021.

splintered-reality,

ros,

Moving to the analysis of models, we are interested
in understanding the usage of behavior trees and state
machines in real robotic projects. Thus, we used the list
of relevant repositories from the ﬁltration step and their
downloaded models. At the time of the analysis of behavior
tree models, we got 75 models. An updated mining at the
beginning of 2022 to cover the projects until end of 2021
yielded new models and projects, but we decided to keep
the same sample since it covers different sizes of models and
domains. For state machine models, we randomly sampled
75 models to match the number of behavior tree models to
have comparable results. The state machine minning yielded
thousands of models, consequently we randomly sampled
projects. We deﬁned two project pools according to the model
size, one for normal size [2–6] and another for extreme size
[7–66], then we randomly sampled from each pool a number
of projects using the sampling API from Python DataFrame
library. The model size range for each pool was decided based
on the data distribution. The total sample size corresponded
to the number of models belonging to behavior tree projects
meeting our repository inclusion criteria (75 models).

We calculated metrics that capture core structural aspects
of the models and report on the usage of behavior tree and
state machine concepts. Since we are analyzing two different
types of structures, directed cyclic graphs in state machines
and directed acyclic trees in behavior trees, it is challenging
to use similar metrics. Thus, we calculated some common

• Model size (BT.size, SM.size): the total number of nodes
excluding the root node in behavior trees and the total
number of states in state machines.

• The tree depth (BT.depth): the number of edges from
the root node to the deepest node of the tree [55].
Considering the example in Fig. 1, the behavior tree
model has a BT.depth equals to ﬁve.

• Average branching factor (BT.ABF): the average number
of children of each node. Considering the example in
Fig. 1, the behavior tree model has a BT.ABF of 1.6.
• Nesting level (SM.nesting): the composition or nested
hierarchy level induced by counting the number of levels
within the state compositions [56], [57], [58]. We consider
the main state machine as level one. Considering the
example in Fig. 3, this state machine model has a nesting
level of three; where the main container Inspect_SM is
level-1, the nested container Iterator_10_attempts
is level-2 and the Exploration_seq is in level-3.
• Node type percentage (N.pct): the frequency of a node
type with respect to the total number of nodes. This
metric captures the usage of the different composite
node types in behavior trees and the different container
constructs in state machines.

The extraction of these metrics relies heavily on the imple-
mentations of the languages, thus we used different extrac-
tion methods for each language. For behavior tree languages,
we inspected the code of both the tutorials of the libraries and
a randomly sampled subset of mined models to understand
how users implement them. We noticed that users follow
different implementation styles, and that the models tend to
be deeply intertwined with the rest of the code. While some
metrics could be calculated automatically, for others the mod-
els needed to be manually extracted. To calculate BT.size and
N.pct, we extracted a function name for each node type based
on the documentation of the libraries, then used a Python
script to count the number of text matches. For leaf nodes,
no automatic counting was possible since the libraries do
not impose a speciﬁc implementation structure. We counted
and calculated the percentage of leaf nodes, BT.depth and
BT.ABF manually from the manually extracted models. To
extract behavior tree models, we were able to use a visual
editor shipped with one of the identiﬁed libraries (Groot for
BehaviorTree.CPP, explained shortly) where the behavior
tree language is realized as an external DSL. The other iden-
tiﬁed library (PyTrees_ros, explained shortly) constituted
an internal DSL, where we needed to manually extract the
model from the source code by identifying the respective
library API calls used to construct the model. There, we con-
sidered every tree with a root node as a behavior tree model.
Moving to state machine languages, we also checked the
code of tutorials of the libraries and a random sample of
mined models. An implementation pattern was clear for
each library, hence an automatic extraction of the metrics
was possible. Using Comby API, a parser that detects syntax
in code based on user-supplied patterns [59], we deﬁned
a syntax pattern to match the start and end of a state

machine container to isolate it from the rest of the code.
Then, we wrote a Python script to extract the state machine
model from the rest of the code. After extracting the model,
another script was used to count the number of states and
composite states to calculate SM.size and N.pct. Similar to
composite nodes count in behavior trees, a text match for
the function name was used to count the different container
types. Finally, we wrote a script for visualizing the extracted
model to facilitate model inspection using the state-machine-
cat (SMCat) API. We could not use the viewers provided
by FlexBe and SMACH because the models are intertwined
with the code and each project has different dependency
requirements to run it. It was easier to isolate the model
from the projects and visualize it using an external viewer.
We wrote a Python script to transfer the extracted model
code into the SMCat syntax and generate SMCat ﬁles. SMCat
was executed on those ﬁles to generate svg format ﬁles that
visualize a corresponding state machine model. Extracting
the SM.nesting required manual work. Using the extracted
visualized models, we went through all models and counted
the nesting levels. All scripts and svg ﬁles can be found in
our online appendix.

Analyzing Reuse

The ﬁnal aspect we analyzed is reuse because it is one of the
major issues in robotics software engineering [1], [5], [18],
[20]. By reuse we refer to reusing the code of a robotic skill
(also known as action) instead of writing from scratch a new
skill, or reusing the code of a repeated task (composed of
different skills) in the same mission or in different one.

We observed reuse in the sampled projects using a
mixture of visual and code-level inspection to detect any
reused skill or task. We inspected the reuse of a skill or task
in the model and across the different models of a project. A
task is usually expressed as a sub-tree in behavior trees and
as a composite state in state machines. A skill is expressed
as a leaf node in behavior trees and as an associated action
to a state in state machines. By ﬁrst checking the model
visualization, we could detect a task level and/or skill level
reuse in a model. We also relied in the task-level reuse
on similar model structure in case of a slightly different
combination of skills with a resembling structure. A deeper
inspection of the code-level implementation of models and
skills for those reused tasks and skills follows to understand
what type of reuse mechanisms are used.

4 LANGUAGE CONCEPTS (RQ1)

We now reﬂect on the language concepts, including their
syntax and semantics, offered by the identiﬁed behavior tree
and state machine libraries. The upper part of Table 1 lists
the behavior tree libraries we identiﬁed and considered in
this study. Seven libraries are from the robotics community
and one from outside. We focus on analyzing the implemen-
tations in the ﬁrst three ones, set in bold font. Among the
languages relevant for robotics, these three were actively
developed when we checked (2021/06/09). Together, they
support ROS systems implemented in Python and C++, the
two most popular programming languages in the robotics
community. The PyTrees library, the main behavior tree
implementation in the Python community, does not directly

TABLE 1: Behavior tree and state machine languages identi-
ﬁed. We analyzed those in bold

name

target
language

BehaviorTree.CPP
github.com/BehaviorTree/BehaviorTree.CPP

C++

PyTrees
github.com/splintered-reality/py trees

Python

PyTrees_ros
github.com/splintered-reality/py trees ros

Python

BT++
github.com/miccol/ROS-Behavior-Tree

C++

last

ROS doc. update

yes

[38] 2021/05

no

[37] 2021/05

yes

[44] 2021/05

yes

[60] 2018/10

SkiROS2
github.com/RVMI/skiros2

pi trees
github.com/pirobot/pi trees

Beetree
github.com/futureneer/beetree

Python

yes

[61] 2020/11

Python

yes

n/a

2017/10

Python

yes

n/a

2016/03

UE4 Behavior Tree
docs.unrealengine.com/en-US/Engine/ArtiﬁcialIntelligence/BehaviorTrees

UnrealScript no

[62] n/a

SMACH
github.com/ros/executive smach

Python

yes

[42] 2020/05

FlexBe
github.com/team-vigir/ﬂexbe behavior engine

Python

yes

[43] 2020/12

SMACC
github.com/reelrbtx/SMACC

C++

yes

[63] 2021/05

RSM
github.com/MarcoStb1993/robot statemachine

C++

yes

[64] 2020/03

Decision making
github.com/cogniteam/decision making

C++

yes

n/a

2016/07

target ROS, but robotics in general. A popular extension,
PyTrees_ros, provides bindings for ROS. Since PyTrees
and PyTrees_ros are similar, with the only difference of
ROS packaging, we decided to include PyTrees in the
language analysis even though it does not support ROS
directly.

We decided to discard the remaining languages from our
analysis. BT++ is now obsolete, superseded by Behavior-
Tree.CPP after the developer of BT++ joined the latter as
a contributor. SkiROS2 is a software platform for robotic
task-level programming that uses in its design concepts from
model-driven engineering and uses behavior trees as an exe-
cution engine. SkiROS2 is a new version of SkiROS [65], [66],
which is now obsolete. SkiROS2 does not have open-source
projects, so we needed to discard it from further analysis. Bee-
tree and pi trees are inactive experiments, now abandoned.
Unreal Engine 4 (UE4) Behavior Tree, probably the world’s
most used behavior tree dialect, is a well-documented library
with a graphical editor to model intelligent actor behavior in
games. However, the game development use case impacts the
implementation. It emphasizes event-driven programming
rather than time-triggered control, which is the major concern
in robotics. Since we focus on robotics and not computer
games, we will not discuss it any further.

The lower part of Table 1 lists the state machine libraries
we identiﬁed. We analyzed the ﬁrst two (in bold font) and
discarded the other three, since they match our exclusion

TABLE 2: Key concepts in our behavior tree languages compared to our state machine languages

behavior tree
concept/aspect PyTrees, PyTrees_ros, BehaviorTree.CPP

behavior tree languages

state machine languages
SMACH, FlexBe

programming
model

simple nodes

exit status

composite
nodes

root

sequence

selector

parallel

goto (jumps)

decorators
inverter
succeed
repeat

retry

dynamicity

openness

concurrency

Synchronized and asynchronized are supported, time-
triggered, activity-based. Reactive programming can
be implemented to an extent using the tick concept
and re-ordering of sub-trees.

Execute actions (arbitrary commands, both instanta-
neous and long-lasting) or evaluate conditions (value
translated to Success/Failure).
Each node reports success, failure, or an in-operation
state (“running”) each time it is triggered. Status
report causes the computation (the traversal) to
advance to the next node.

Deﬁne hierarchical traversal, the control-ﬂow for each
epoch (tick). Sequentially composed. Nodes may start
concurrent code though.
Serves as entry point for every traversal. Has exactly
one child node. Root node is re-entered at every epoch.
Trigger children in a sequence until the ﬁrst failure. If
no failure return success, otherwise fail.
Trigger children in a sequence until the ﬁrst success.
If no success return failure, otherwise succeed.
Generalize sequence/selector with a policy parameter.
Several polices available, e.g. meeting a minimum
number succeeding children.
No general jump construct, the computation always
traverses the tree.

Asynchronous, event-triggered, reactive

Basic state with associated action/conditions

Each state reports its status (also known as outcome).
Outcomes are user deﬁned. Execute function checks
periodically for outcome

Similar to container concept. Allow state nesting and
control ﬂow constructs.

Initial state (ﬁrst state added to the container).

Supported using a predeﬁned container.

No direct support, could use container to extend.

No direct support, could use guards to extend.

Supported.

Invert the Success/Failure status of the child
No direct support, could use container to extend.
Return success ignores the status returned by the child No direct support, could use container to extend.
Trigger the child node a set number of times, then
succeed. Fail if the child fails.

Run the child node and retry it immediately if it fails
for a maximum number of times, otherwise succeed.

Runtime modiﬁcations of model (node re-ordering)
possible due to the dynamic nature of the implemen-
tation.
New nodes and operators implemented by users as
needed.
interleaving and co-routines; declared via sequence,
selector, and parallel nodes.

No direct support. Could use the Iterator container in
SMACH as repeat-until loop where the desired outcome
for breaking the loop is user-deﬁned.
No direct support. Similar to repeat concept, Iterator
container can be modiﬁed and used.

Runtime modiﬁcations of model is possible (adding
and removing states, changing state instantiation, Re-
ordering states).
States and new control-ﬂow is possible using the
container concept.
interleaving; declared via concurrency container;
states are executed sequentially but not parallelly due
to using Python threading.

criteria (cf. Sect. 3.1: SMACC is an actively maintained
library that supports ROS systems implemented in C++.
Robot Statemachine (RSM) is another C++ implementation
with ROS support that also offers a GUI. Due to lack of
open-source projects on GitHub using SMACC and RSM,
we needed to discard them. Decision making is another
state machine library that supports ROS systems in C++,
but is no longer maintained. The two included libraries are
actively maintained when we checked (2021/06/09), have
good documentation, support ROS systems in Python, and
have multiple available projects on GitHub for mining.

The language concepts offered by our behavior tree
and state machine libraries are summarized and compared
in Table 2. The left-most column names concepts that are
pertinent to the behavior tree libraries, either due to inclusion
or a striking exclusion from the behavior tree libraries. The
last column comments brieﬂy on how the respective concepts
are handled in the state machine libraries. The remainder of

this section discusses the details, ﬁrst for behavior trees and
then for state machines.

4.1 Behavior Trees: Concepts and Semantics

Behavior trees can be seen as graphical models that are
shaped as trees, representing tasks for execution by an agent.
Robotics and gaming are domains where autonomous agents
tasks are frequently modeled using behavior trees [8].

A behavior tree model consists of composite control ﬂow
nodes that coordinate how the basic action nodes should be
scheduled by the agent. The visual presentation of the main
node types as used in robotics and games [8], [27], [28] is
summarized in Fig. 2. The four basic categories of control
ﬂow are: Sequence, Selector, Parallel, and Decorator. The
two basic execution nodes are Action and Condition. Each
tree has a designated Root node. To illustrate the abstract
syntax, we provide a meta-model we reverse-engineered
from BehaviorTree.CPP’s XML format in Fig. 6. Most of
these concepts are further detailed in Table 2.

use some form of concurrency to continue operation. The
execution engine will attempt to trigger them at the next
epoch again.

Composite Nodes
Composite nodes are internal nodes of a behavior tree. Their
main function is to deﬁne the order of traversal at every
time epoch (at every trigger). Unlike for simple nodes, which
need to be implemented by the user, the language provides
a range of predeﬁned composite nodes. The root node is
the composite node that serves as an entry point for every
traversal, it contains another node as the body. This node is
re-entered to start every traversal.

A sequence node triggers (visits) all children until the ﬁrst
failure (similar to a forall higher order function, which is
standard in many programming languages). A selector node
triggers all children until the ﬁrst success (similar to exist).
A parallel node is really a misnomer. It does not execute
nodes concurrently, but generalizes sequence and selector to
a range of policies; that is, the subset of children that shall
succeed or fail.

Since the execution is always a traversal of the entire
tree, there is no direct support for jumps (goto). Instead,
composite nodes can affect the traversal locally, in stark
contrast to state machines. In these languages, a typical
change of control allows an arbitrary change of state, often
cross-cutting the syntax tree.

Decorators
Decorators are unary composite nodes (only one child).
They decorate the sub-trees and modify their data or control
ﬂow. An Inverter ﬂips the return status of a child between
success and failure. A Succeeder always succeeds regardless
the status returned by its child node. A Repeat node, which is
stateful, acts like a for-loop: it continues to trigger the child
for a given number of ticks. It increments an internal counter
at every trigger. The node succeeds (and resets the counter)
on hitting a set bound. It fails (and resets the counter) if the
child fails. A Retry node resembles a repeat node. Its main
goal is to make a ﬂaky node succeed. Like Repeat it can run
a node up to a set number of times, but unlike Repeat, it
only retries when a node fails and it retries immediately
without waiting for the next epoch. It fails if the child failed
in a given number of attempts.

OBSERVATION 1. The concepts offered in behavior tree
languages, and their semantics, stem from domain needs.
Behavior trees gather a number of constructs based on
patterns that, according to users and developers, are
frequently found in high-level control of autonomous
systems.

The above discussion is based on a broad description
of behavior tree languages extracted from the available
literature and documentation of PyTrees, PyTrees_ros,
and BehaviorTree.CPP [37], [38]. Table 3 presents the
names of the basic Behavior Trees concepts in the two
dialects.

Fig. 6: A meta-model for BehaviorTree.CPP (reverse-
engineered from its XML format.)

The variant of behavior trees used in the analyzed
libraries is predominantly a timed-triggered activity-based
behavioral modeling language. The computation consists
of activities that have duration and the main control loop
triggers the entire model at (typically) ﬁxed intervals of time
like a circuit. Every tick (or epoch) triggers a traversal of
the entire tree, with diversions introduced by various types
of nodes. The traversal can start new activities, evaluate
conditions, access state, and execute basic actions for side
effects. Reactive programming seems not to be supported
ﬁrst-class, despite reappearing statements to the contrary,7
but can be simulated by sufﬁciently high-frequency model
execution.

The model has a global storage called blackboard, which
is a key-value store. No scopes are supported; all keys are
global. The blackboard is used for communicating, both
within the model and with the rest of the system. The
model and the system read and update the blackboard
asynchronously.

Simple Nodes

Simple nodes, or leaves in the syntax tree, are either con-
ditions or actions. Actions realize the basic computation
in the model. Users of the language need to implement
custom action nodes—classes obeying the Action interface
that contain Python or C++ code to be executed whenever
a node is ticked. Conditions calculate a value of a Boolean
predicate and convert it to a success or failure value.

Simple nodes, and by propagation also composite nodes,
return an explicit exit status, which can be a success, a failure,
or information that the action is still running. These values
propagate upwards during the tree traversal according to
the semantics of composite nodes, discussed below. The
semantics resembles that of a logical circuit, a neural network,
a ﬂow diagram, or a computation in the failure monad known
in pure functional programming (but the modeling language
is obviously far from pure). The model receives results from
simple nodes and converts them through the network.

The simplest Action nodes are synchronous, so they
terminate quickly and return success or failure immediately.
Asynchronous nodes may also return a ‘running’ status and

7. For example, the PyTrees documentation states that the language
provides a good blend of purposeful planning towards goals with enough
reactivity to shift in the presence of important events; https://py-trees.
readthedocs.io/en/devel/background.html

Openness
The openness and indeﬁniteness of behavior trees are prob-
ably their most interesting aspects, after the time-triggered

DecoratorParallelSelectorSequenceConditionActionSimpleNodeCompositeNodeSubTreeRootTreeNodeID: Stringname: StringBehaviorTreeID: String1main1*refers to11**TABLE 3: Behavior tree concepts and corresponding language
elements in BehaviorTree.CPP and PyTrees

concept

BehaviorTree.CPP

PyTrees

Simple
Node

subclasses of
ActionNode
ConditionNode

Composite subclasses of

ControlNode

Sequence Sequence,

Selector

SequenceStar
ReactiveSequence
Fallback,
FallbackStar
ReactiveFallback

Decorator subclasses of

Parallel

DecoratorNode
ParallelNode

behaviour.Behaviour

classes in
composites
composites.Sequence

composites.Selector
composites.Chooser

classes in
decorators
composites.Parallel

coroutine-based model of computation. Others have also
noticed this in the context of variability in DSLs [67].

Unlike in Ecore8 or UML, the language meta-model is not
ﬁxed. The basic implementation provides the meta-classes for
composite nodes, while it leaves the simple nodes abstract or
only gives them bare bones functionality (cf. Fig. 6). A user
of the language is expected to ﬁrst extend the meta-model by
implementing the basic action nodes, then link them together
in a syntax tree, possibly using an external XML ﬁle. This
practice vaguely resembles stereotyping [68]. Obviously, a
user of Ecore can extend the meta-model classes and give
them new functionality at runtime as well, however such use
of Ecore is considered advanced and is seen rather rarely. The
difference is that of degree: there is essentially no way to con-
sider using Behavior Trees without creating custom nodes.

Prerequisites (User Demographics)

The open nature of behavior tree means that the experience
of building and debugging models resembles very much
language-oriented programming as practiced in the model-
ing and language design research community. One constantly
deals with meta-classes, composing them, traversing them,
etc. Anybody familiar with building DSLs on top of Ecore
or similar frameworks will deﬁnitely experience a d´ej`a vu,
when using either PyTrees or BehaviorTree.CPP.

Given that many robotics engineers, and many ROS
users, lack formal training in computer science and software
engineering [69], it is surprising to us that this design
seems to be well received in the community. Even within
software engineering, language implementation and meta-
programming skills are often considered advanced. Yet, using
Behavior Trees requires such skills. A challenge for the
modeling community is lurking here: to design a Behavior
Trees language that, while remaining ﬂexible and easy to
integrate with large and complex existing code bases, is
much easier to use for a regular robotics programmer.

OBSERVATION 2. The ﬂexibility and extensibility of
behavior trees require language-oriented programming
skills from robotics developers. The software-language
engineering community could contribute by designing an
accessible, but still ﬂexible, dialect of Behavior Trees.

8. https://www.eclipse.org/modeling/emf/

Separation of Concerns

Behavior Trees are platform-speciﬁc models (PSMs) built
as part of a speciﬁc robotics system to control behaviors at
runtime. The models are used to simplify and conceptualize
the description of behavior. The ability to reuse the same
models with other hardware or similar systems is not
(yet!) a primary concern. Behavior tree not only are PSMs,
but tend to be very tightly integrated with the system.
Custom nodes tend to refer to system elements directly
and interact with the system API. As a result, it is hard
to use these models separately from the robot. While Groot
can visualize a standalone XML ﬁle of a model, a working
build environment of ROS is needed just to visualize the
syntax of a PyTrees_ros model. This may mean not only
an installation of suitable Python and ROS libraries, but,
for example, a working simulation of the robot, or even the
hardware environments. You need to launch the system and
inject a visualization call to inspect the model!

It is in principle possible with both libraries to build
models that are completely decoupled from the system. It
sufﬁces to route all communication with the system via the
blackboard. BehaviorTree.CPP provides dedicated XML
primitives for this purpose, allowing the entire behavior to
be programmed in XML, provided the rest of the system
can read from and write to the blackboard. This separation
allows models to be processed outside the system for
visualization, testing, grafting into other systems, and so
on. We deﬁnitely think this is a good architectural practice to
follow. Nevertheless, it is not what we observed in real-world
models (cf. Sect. 6). Most models mix the speciﬁcation of
behavior deeply with its implementation, making separation
virtually impossible.

OBSERVATION 3. Behavior tree models tend to be deeply
intertwined with behavioral glue code linking them to
the underlying software system. This makes operating on
models outside the system difﬁcult, hampering visualiza-
tion, testing, and reuse.

4.2 State Machines: Concepts and Semantics

State machines and Hierarchical state machines have been
used for decades in different domains, and in the literature
there exists a range of languages with slight differences in
syntax and semantics [30], [31]. In this work, we reﬂect on
the syntax and semantic that we observed in the robotic
models using the state machine languages FlexBe and
SMACH. These languages ressemble Moore machines [32]
from the computational perspective.

Just like behavior trees, state machines provide graphical
models to represent the behavior of a robotic agent when
executing tasks. A state machine model is a directed graph of
nodes and arcs often called states and transitions, respectively.
A state is associated with a skill, often called an action, to be
executed. Compared to the execution nodes in behavior
trees, states do not provide type distinction for its skill.
Although it is called an action, but the associated skill could
be an action or a condition. Moving to the control ﬂow
coordination between states, it is much simpliﬁed in state
machines compared to the different control ﬂow nodes in
behavior trees. A state has multiple outgoing transitions, but

a transition has only one target state, unlike some control ﬂow
nodes in behavior trees. A transition is often associated with
a condition and if the condition is satisﬁed, the associated
transition is ﬁred to its target state.

Hierarchical state machines, also known as state-
charts [34], are an extension of state machines that allows
nesting (hierarchy) and concurrency [34], [35]. Thus, the
hierarchical state machine model is similar to state machines
with the ability to separate behaviors into sub-states, thereby
increasing the modularity of the model and decreasing the
number of transitions needed.

State machines and hierarchical state machines have been
used for decades in different domains resulting in common
graphical syntax with minor differences. While there exist
different syntaxes with minor modiﬁcations, the Uniﬁed
Modeling Language (UML) state diagram might be the most
common visual syntax, especially in the software modeling
community (see Fig. 4).

State machine models are event-triggered. A state is
associated with an action and according to the execution
outcome of its action a transition is triggered to the next
state. Transitions are associated with the state outcome that
triggered them. A transition is deﬁned as a dictionary of key-
value of state outcomes and their target state. Compared to
behavior trees, state machines do not have an explicit notion
of ticks and of reoccurring traversals. States are only started
once at the beginning of the model execution, revisited only
if the control-ﬂow gets there. In FlexBe current state could
be interrupted and a transition based on external events
could be triggered allowing reactive programming. The
interruption is possible due to autonomy-level threshold
that is associated with a state to allow human-in-the-loop
decision incorporation. In contrast, no reactivity is available
in SMACH and the current active action blocks the execution
until an outcome is returned.

To deal with the data ﬂow between states and the
system, UserData, a locally scoped dictionary of key-value,
is used. Compared to blackboard, UserData deﬁnes local
input-output ports to access needed data, while blackboard is
more of a global storage accessed by any node. It has been
highlighted by online-discussion forms9 and researchers [50]
that the current implementations of blackboard is causing
name-clashes and unwanted overwrite when the behavior
trees grow. Interestingly by getting inspiration from the
scoped input-output ports in state machine languages,10 the
developers of behavior trees have introduced new changes
to scope blackboard.11

Hierarchical nesting is addressed by means of con-
tainers. A container is simply a Python module that
could be extended to support different execution seman-
tics. Both state machine libraries use containers to deﬁne
their own constructs, thereby gathering common high-
level control ﬂow patterns. We distinguish between nesting
container and control-ﬂow containers according to their
functionality. StateMachine, Concurrence, Sequence,

9. For example the problem is raised in BehaviorTree.CPP GitHub

issues page: #18 #41 #44

10. https://github.com/BehaviorTree/BehaviorTree.CPP/issues/41
11. https://www.behaviortree.dev/migrationguide/

https://py-trees.readthedocs.io/en/devel/changelog.html#
x-2019-11-15-blackboards-v2

and Iterator are some of the common types in SMACH.
StateMachine is for deﬁning a state machine model, and it
is used for creating hierarchical nesting (hierarchical state ma-
chines). Sequence acts similar to the behavior tree control-
ﬂow node sequence. The states are executed sequentially
according to a predeﬁned order. Iterator is a repeat-until
loop that iterates over states until a speciﬁed outcome is
reached. Finally, Concurrence allows multiple sub-states
to be active at the same time through threading. Similar to be-
havior trees Parallel node, no parallelism of execution is avail-
able. An outcome policy deﬁnes the concurrency container
outcome using a dictionary of key-value (container outcomes
are the keys and its sub-states potential outcomes are the
values). In FlexBe only nesting and concurrency behav-
iors are supported through OperatableStateMachine
and ConcurrencyContainer, respectively. An example
of SMACH iterator is provided in Figure 3.

In addition to offering frequent control-ﬂow patterns,
FlexBe provides meta-classes for common states through
the API flexbe_state and a separate state library
generic_flexbe_states, which we noticed they were
used in our model analysis (cf. Sect. 6.3). A documentation of
the states from flexbe_state is available in [41] appendix
A.1.

Providing constructs for frequent control ﬂow patterns
seems common in both behavior tree and state machine
languages. This might relate to the nature of robotic missions
that tend to have a sequence of actions or some iterative tasks,
enforcing the need for the behavior modeling language to
accommodate this type of behaviors. A clear difference is
spotted in the UML state diagrams, which is more used in
software behavior modeling, with no direct support for such
behaviors [21]. Implementing behavior design patterns as
language constructs in modeling languages is sometimes a
problematic design decision because it might increase the
language complexity. However, as stated by Bosch [70], it
is actually the lack of expressive construct that increase a
language complexity and users overhead. A language should
fulﬁll its domain needs, thus it is not strange for such design
decision by language developers.

OBSERVATION 4. Constructs for frequent control ﬂow
patterns seem a common need in modeling robotics
missions. The identiﬁed state machine and behavior tree
languages accommodate these needs using containers and
composite nodes concepts, respectively.

Openness

Openness is a common feature in the studied modeling
languages due to the nature of robotic missions. Similar to
behavior trees, state machine languages do not constrain
users with ﬁxed models and implementations. Users are
provided with meta-classes for containers and states, and
they can extend them. The extension of control-ﬂow types is
possible, however we have not observed any such customiza-
tion in the analyzed projects (see Sect. 6), just like behavior
tree projects. Further investigation by including the users of
languages is required to determine the reason.

This design pragmatically supports openness of the
language and makes adaptation to diverse scenarios in
robotics easy. The openness seems to be required due to

3

4

5

6

7

8

9

10

11

12

13

14

a lack of agreement in the robotics community about the
ideal control model for robot behavior. Since this question is
likely to remain open for a long time, the design allows users
to adapt the language as they see ﬁt when building robots.

5 LANGUAGE IMPLEMENTATION (RQ2)

This section focuses on analyzing the behavior tree libraries
in the ﬁrst three rows in Table 1, and the state machine
libraries in the ﬁrst two rows in the second half of the table,
all set in bold font. For the identiﬁed libraries, we broaden
the scope of our analysis by inspecting their implementations
techniques and practices.

5.1 Behavior Trees: Language Design and Architecture

Turning our attention to how behavior tree languages are
implemented from the language design perspective, the ﬁrst
striking observation is that both languages are predominantly
distributed as libraries, not as language tool chains, or model-
ing environments. BehaviorTree.CPP is implemented as a
C++ library, packaged as a ROS component, easy to integrate
with a ROS-based codebase [49]. In contrast, PyTrees is
a pure Python library. It has an extension PyTrees_ros
which packages PyTrees as a ROS package and adds ROS-
speciﬁc nodes.

Syntax and Visualization

Both dialects come with ways to visualize models as graphs,
and BehaviorTree.CPP even has a graphical editor and a
visual runtime monitor for its models called Groot (which the
graphical representation of a behavior tree was visualized in
Fig. 1).

Nevertheless, it is important to understand that behavior
trees are not a visual modeling language in a traditional
sense. First, in both libraries, the models are constructed
in a text editor, in a mixture of C++, respectively Python.
Second, the models are constructed directly in abstract
syntax, by instantiating and wiring abstract syntax types. For
convenience, and to support Groot, BehaviorTree.CPP
offers an XML format, which can be used to write the tree
syntax in static ﬁles. In Listing 1, the XML ﬁle for the mission
displayed in Figure 1 is shown. This ﬁle is interpreted at
runtime, and an abstract syntax tree is constructed from it
dynamically. Third, crucially, the types of nodes (and, thus,
the XML ﬁle in BehaviorTree.CPP) do not constitute the
entire meaning of the model. An important part of the model
is embedded in C++/Python code that is placed in the
methods of the custom node classes. This part of the model
is neither modiﬁable nor presentable in the graphical tools.
Finally, recall that BehaviorTree.CPP is realized as an
external DSL through Groot and the XML-like format, while
PyTrees_ros constitutes an internal DSL, since it does not
have similar tools. From our experience analyzing their mod-
els (cf. Sect. 6), we can conﬁrm that the BehaviorTree.CPP
models are much easier to comprehend, and the availability
of its visual editor Groot has made it faster to analyze the
behavior tree models than PyTrees_ros models.

Listing 1: The same example in Figure 1 shown in Behavior-
Tree.CPP XML notation.

1 <root main_tree_to_execute="MainTree" >
2

<BehaviorTree ID="MainTree">
<SequenceStar name="MainSeq">

<Action ID="CollectWaypoints"/>
<RetryUntilSuccesful num_attempts="10" >

<Negation>

<Sequence name="ExplorationSeq">
<Action ID="PopWaypoint"/>
<Action ID="MoveBase"/>
<Action ID="Explore"/>

</Sequence>

</Negation>

</RetryUntilSuccesful>
</SequenceStar>

</BehaviorTree>

15
16 </root>

Concurrency
The design of behavior tree languages does not prescribe
the model of concurrency, and implementations vary. For
instance, BehaviorTree.CPP implements asynchronous
nodes using coroutines [71]. A node that is not ready to ter-
minate can yield to the engine, and be restarted again at the
next epoch. This directly gives interleaving concurrency, but
can give true concurrency if the executed code uses threads
or parallel processes (which it would typically do in ROS).
Coroutine semantics is extremely rare in modeling languages.
It was present in Simula [72]. Statecharts had a weak form
of coroutines as ‘history states’ [34], and more recently they
were used cooperatively in ABS [73]. It is interesting that this
semantics is coming back, thanks to programming languages
re-discovering it. It is now supported in Python and included
in the 2020 C++ speciﬁcation.

OBSERVATION 5. Implementations of behavior tree lan-
guages support both interleaving and true concurrency
indirectly using threads and coroutines from the under-
lying ROS platform. The model of concurrency is not
deﬁned strictly in the language, but is, instead, left largely
to the users.

An internal or external DSL?
Both languages are unusually open. BehaviorTree.CPP is
technically an external DSL, but its implementation exposes
aspects of dynamic internal DSLs. The programmer can both
create models in XML (external, static), and create new node
types or modify the shape of the syntax tree at runtime
(dynamic). PyTrees is an entirely dynamic DSL, where new
node types and Python code can be freely mixed, like in
internal DSLs.

An interpreter or a compiler?
Both dialects are interpreted. Once the abstract syntax tree
is constructed, the user is supposed to call a method to
trigger the model once, or to trigger it continuously at a
ﬁxed frequency. This does not seem to depart far from other
applications of models-at-runtime [22], [23]. Behavior-
Tree.CPP uses template metaprogramming instead of code
generation, which allows to offer a bit of type-safety when
implementing custom tree nodes, without exposing users
to any specialized code-generation tools. Using the library
appears like using a regular C++ library. As expected, no
static type safety is offered in PyTrees.

5.2 State Machines: Language Design and Architecture

In this section, we present a broad description of state
machine languages extracted from SMACH and FlexBe
literature and documentation [39], [40], [42], [43], [51], [74].
Furthermore, we highlight aspects from the comparison to
behavior trees that is described in Table 2.

State MACHine (SMACH) [39] and Flexible Behavior
Engine (FlexBe) [41] are open-source software frameworks
written in Python for building and monitoring state machine
and hierarchical state machine (HSM). Similar to PyTrees,
SMACH can be used without ROS system and it has a ROS
binding through smach_ros.

Looking at how state machine languages are imple-
mented from a language design perspective, there is a
difference in how SMACH and FlexBe are realized. Although
FlexBe can be used directly as a Python library, it is used
as a modeling environment since it offers a graphical user
interface (GUI) called FlexBE App.12 FlexBE App is used to
construct state machines using a graphical notation, and to
monitor and modify the state machine during run-time. On
the other hand SMACH is mainly used as a pure Python library,
and it has a package smach_ros to integrate it with ROS. It
has a GUI called smach viewer13 for inspecting and debug-
ging an already created state machine, but not constructing
or modifying it. Although SMACH is ROS independent, its
viewer can not be run without having a running ROS.

Syntax and Visualization

State machine languages have their own notation, slightly
different from the UML standard in Fig. 4. SMACH uses ellipse
shape for state and double-frame ellipse shape for nested-
machine, and FlexBe uses rectangle shapes. FlexBe uses
dedicated notation for initial and ﬁnal states like UML, while
SMACH does not. Figure 3 shows a state machines example
using SMACH viewer syntax. If we want to represent the same
example in FlexBe, then an initial and end states should be
added.

The two languages are used differently for constructing
the state machine model. FlexBe mixes graphical and
textual syntax. The graphical syntax is constructed using
the FlexBE App (FlexBe graphical GUI) in a drag-and-
drop manner, then an interpreter auto-generate the textual
syntax as a Python code. Syntactic and minor semantic
veriﬁcations are ran before generating code to ensure model
consistency such as the existence and correctness of the
associated UserData with each state. The generated code
represent the model structure and certain parts of it can be
edited to provide ﬂexibility to developers. For each state,
a stub is auto-generated for class methods where users
need to implement their custom execution functionalities.
Meanwhile, SMACH users construct the model abstract syntax
directly in a text editor in Python.

Compared to behavior tree languages, we can observe
the maturity of state machine languages regarding the
construction of the model. It seems state machine languages,
speciﬁcally FlexBe, make partial use of model-based de-
sign processes through model-code separation of concerns
and (semi)automatic generation of code from the models.

12. https://github.com/FlexBE/ﬂexbe app
13. http://wiki.ros.org/smach viewer

BehaviorTree.CPP provides similar features by providing
a GUI for constructing the graphical model and generating
the textual syntax in an XML format from the model, which
is useful, but the language still requires manual repetitive
coding. While FlexBe reduces the manual coding by auto-
generating boilerplate code, such as the needed libraries
importation and default functions for the state initialization.
If adopted by behavior tree languages, this functionality
might open the opportunity for wider user audience and
reduce syntactic errors. However, since custom execution
functions still need some manual coding, it is not fully
applicable to have no programming background.

OBSERVATION 6. State machine languages have used
concepts from model-based design processes that reduce
users workload and code syntactic errors like code gen-
eration. Adopting these concepts in behavior trees could
increase the languages accessibility to wider audience.

Concurrency

Similar to behavior trees, the model of concurrency is not
strictly deﬁned in the implementation. So, it is possible to
use the ROS platform to indirectly accommodate the needed
behavior. One thing to keep in mind is that in both libraries
every state machine container is executed in its own thread,
and its UserData, the locally scoped dictionary of key-value
pairs, are not shared between the different state machine
containers. In case of parallelism, or any other paradigm for
multi-threading, it can get tricky to facilitate data sharing
between two running state machines.

Both dialects (libraries) offer a concurrency container. In
both implementations, Python threading is used allowing
multiple states to be active at the same time running on
their own rate. States are executed sequentially, but not
parallel due to using Python threading (interleaving). The
asynchronous nature of state machine makes using Python
threading convenient.

An internal or external DSL?
Openness of FlexBe is similar to other modeling languages
using model-based design. Similar to BehaviorTree.CPP,
it is realized as an external DSL, but exposes aspect of
dynamic internal DSLs. In FlexBe models can be created
using the graphical notation in FlexBE App with syntactical
and minor semantical veriﬁcation applied to created models
before auto-generating code. Auto-generated code for states
are stubs consisting of basic functions, e.g. a constructor,
execution function, etc. Developers are expected to complete
the auto-generated stubs for states in Python code. Extension
of the model and states is possible ofﬂine. Once the model
and states are instantiated, run-time modiﬁcation is limited
to the structure of the state machine model, e.g. add and
remove states, and transition function, while modifying the
implementation of a state is not possible. On the other hand,
SMACH is similar to PyTrees and it is realized as an internal
DSL, where extending the model and states is done easily by
simply editing the Python code.

An interpreter or a compiler?

Both libraries execute state machine through interpretation
at run-time. FlexBe allows modiﬁcations at run-time. In

FlexBe, modiﬁcation to a running state machine is simply
realized through patches (the standard, minimal summaries
of the modiﬁcations). Patches are applied by taking the
difference between old and new code and only re-importing
the changes to the source code. In order to apply the mod-
iﬁcations, the modiﬁed state is locked to prevent transitions
during the modiﬁcation using the Python threading lock,14
then the Python module is reloaded (using the built-in
reload()). No modiﬁcation is applied before the FlexBe
engine has run veriﬁcation checks to ensure consistency (cf.
Sect. 5.2). So, overall, the FlexBe developers implemented a
pragmatic state-machine swap at runtime, largely relying on
Python’s reload support. Finally, SMACH has no veriﬁcation
step for the created model before execution.

6 BEHAVIOR TREE AND STATE MACHINE MODELS
(RQ3)
Our mining returned hundreds of results per modeling
language. In the followings, we report our empirical in-
vestigation of state machines and behavior trees languages
usage in these projects. First, We present an overview of the
different languages popularity among mined open-source
projects, then we provide our analysis results for a sample
of these projects. Our analysis covers the structural aspect of
sampled models and code-reuse in their projects.

Fig. 7: An overview of the usage of state machines and
behavior trees languages in open-source projects on GitHub
over time.

6.1 Language Popularity
The initial mining returned 1,086 projects for state machines
languages and 271 projects for behavior trees languages that
used the languages identiﬁed terms in their code (see Sect. 3.3
for details). To visualize the languages usage in open-source
projects over-time, we tracked the number of active projects
per year per library in these mined projects and plotted each
library line trend.

An overview reﬂecting the different libraries usage over-
time is presented in Figure 7. Until 2015, SMACH was
the only available language between the other four and
its usage has been increasing steadily over the past ﬁve
years (1.2 times more each year). In 2015, the other four
languages were released, however their usage only started

14. https://docs.python.org/3/library/threading.html

to increase signiﬁcantly in 2018. In general, the use of the
languages have been growing over the past ﬁve years. In
2021 BehaviorTree.CPP and PyTrees usage in projects
reached almost ten times what they were in 2018. We
hypothesized that the usage of BehaviorTree.CPP has
signiﬁcantly increased in the last three years due to ROS
adopting it as the core component for its navigation stack
Navigation2 [25]. For PyTrees, it could be due to being the
only Python implementation for behavior trees offering a
stable and actively maintained language and a wide range
of constructs for nodes types. Although FlexBe usage in
open-source projects is lower than SMACH (78% less than
SMACH in 2021), its overall usage growth since 2018 is much
higher than SMACH. In 2021, the FlexBe usage was 6.5 times
more than it was in 2018, while SMACH only around 1.6 times
more than it was in 2018.

TABLE 4: Projects and models extracted per library

SMACH

FlexBe

Behavior-
Tree.CPP

PyTrees_ros

projects
models

560
2065

60
442

141
595

28
63

6.2 Characteristic of Models

After applying the multiple ﬁltration steps to the mined
projects, we ended up with 620 projects that have 2,507
state machine models used in their robotic projects and
169 projects that have 658 behavior tree models. Table 4
shows the number of projects and models per library. In
a project, a ﬁle with full deﬁnition of a model is counted
as a model, resulting in projects with multiple models. To
analyze languages models, we randomly sampled 75 models
per language. We analyzed a total of 150 models of behavior
trees and state machines (75 models each) belonging to
43 projects (25 behavior trees and 18 state machines), as
summarized on Table 5. The difference in the number of
projects stem from the choice to sample the same number
of models rather than projects.

In our sample dataset, we spotted eleven different
domains. An overview of analyzed projects domains are
presented in Figure 8. The dominating domains were robotic
patrolling, waiter robotics and pick&place missions. Some
of these projects belonged to labs or research groups:

• lawrence-iviani/lisa shared ws ﬂexbe integration;
• CNURobotics/chris turtlebot ﬂexible navigation;
• DeVinci-Innovation-Center/THEDRONELAB;
• CSULA-URC/CSULA-URC-2020-21;
• ajbandera/MiRON-project;
• IntelligentRoboticsLabs/robocup2020;
• kmi-robots/hans-ros-supervisor;
• MiRON-project/bundles.

Others belonged to companies producing robotic solutions:

• sweetie-bot-project/sweetie bot;
• rigbetellabs/tortoisebot waiter;
• Adlink-ROS/BT ros2.

20112012201320142015201620172018201920202021Year125102050100200300Number of Active ProjectsPyTrees ROSPyTreesBehaviorTree.CPP FlexBESMACHFig. 8: An overview of analyzed projects’ domains

TABLE 5: Subject projects identiﬁed from GitHub that use
behavior tree and state machine models to deﬁne robot
behavior

TABLE 5: Subject projects (continued)

project, GitHub link

sam march

KKalem/sam march
mobile robot project

simutisernestas/mobile robot project

smarc missions

smarc-project/smarc missions

dyno
samiamlabs/dyno
gizmo

peterheim1/gizmo

roborts project

Taospirit/roborts project

robotics-player

braineniac/robotics-player

Robotics-Behaviour-Planning

jotix16/Robotics-Behaviour-Planning

reﬁlls second review

reﬁlls-project/reﬁlls second review

pickplace

ipa-rar/pickplace

stardust

julienbayle/stardust
neuronbot2 multibot

skylerpan/neuronbot2 multibot

mecatro-P17

alexandrethm/mecatro-P17
Yarp-SmartSoft-Integration

language

PyTrees_ros

PyTrees_ros

PyTrees_ros

PyTrees_ros

PyTrees_ros

PyTrees_ros

PyTrees_ros

PyTrees_ros

PyTrees_ros

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

l

s
e
d
o
m

1

1

2

2

8

1

1

3

1

1

4

2

BehaviorTree.CPP

11

BehaviorTree.CPP

CARVE-ROBMOSYS/Yarp-SmartSoft-Integration

bundles

MiRON-project/bundles

BTCompiler

CARVE-ROBMOSYS/BTCompiler

BT ros2

Adlink-ROS/BT ros2
vizzy behavior trees

vislab-tecnico-lisboa/vizzy behavior trees

hans-ros-supervisor

kmi-robots/hans-ros-supervisor

Pilot-URJC

MROS-RobMoSys-ITP/Pilot-URJC

vizzy playground

vislab-tecnico-lisboa/vizzy playground

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

1

5

8

2

7

1

2

6

project, GitHub link

language

behavior tree rosC++

BehaviorTree.CPP

ParthasarathyBana/behavior tree rosC++

MiRON-project

ajbandera/MiRON-project

robocup2020

IntelligentRoboticsLabs/robocup2020

carve-scenarios-conﬁg

BehaviorTree.CPP

BehaviorTree.CPP

BehaviorTree.CPP

CARVE-ROBMOSYS/carve-scenarios-conﬁg

ROS Test ws

QuiN-cy/ROS Test ws

lisa shared ws ﬂexbe integration

FlexBe

FlexBe

lawrence-iviani/lisa shared ws ﬂexbe integration

sweetie bot

sweetie-bot-project/sweetie bot

chris turtlebot ﬂexible navigation

FlexBe

FlexBe

CNURobotics/chris turtlebot ﬂexible navigation

hand-eye-calibration

tku-iarc/hand-eye-calibration

dcma ﬂexbe

andy-Chien/dcma ﬂexbe

tortoisebot waiter

rigbetellabs/tortoisebot waiter

Anahita

AUV-IITK/Anahita

wrs 2021

hentaihusinsya/wrs 2021

Heihei

Luobokeng2021/Heihei

THEDRONELAB

FlexBe

FlexBe

FlexBe

SMACH

SMACH

SMACH

SMACH

DeVinci-Innovation-Center/THEDRONELAB

kobuki-ros-nav

vibin18/kobuki-ros-nav

visionx

tsoonjin/visionx

wpi sample return challenge 2015

SMACH

SMACH

SMACH

rcxking/wpi sample return challenge 2015

rbcar rsband

darshan-kt/rbcar rsband

vizzy

vislab-tecnico-lisboa/vizzy
omniWheelCareRobot-usual

Art-robot0/omniWheelCareRobot-usual

CSULA-URC-2020-21

CSULA-URC/CSULA-URC-2020-21

SMACH

SMACH

SMACH

SMACH

l

s
e
d
o
m

1

1

2

1

6

4

5

3

2

8

2

2

2

2

2

3

3

3

4

6

7

11

Yarp-SmartSoft-Integrationrbcar_rsbandvisionxHeiheidcma_flexbehand-eye-calibrationRobotics-Behaviour-Planningroborts_projectmecatro-P17PickplaceBT_ros2MiRON-projectbehavior_tree_roscppPick & PlaceStardustmobile_robot_projectROS_Test_wsNavigation with Verbal Communication and/or object detectionvizzy_behavior_treeschris_turtlebot_flexible_navigationrobotics-playervizzy_playgroundneuronbot2_multibotneuronbot2_multibotrefills_second_reviewCSULA-URC-2020-21wpi_sample_return_challenge_2015kobuki-ros-navtortoisebot_waiterService RobotPilot-URJCwrs_2021robocup2020carve-scenarios-configBTCompilervizzyomniWheelCareRobot-usualTHEDRONELABdynoUnderwater Vehicle Navigation &Testing HardwareHealth & Nursingbundleshans-ros-supervisorlisa_shared_ws_flexbe_integrationsweetie_botgizmosmarc_missionsDrone Sawrm Navigation &Drone-Based DeliveryCollaborative Mission & Interactive robotSam_marchAnahitaProjects DomainsYarp-SmartSoft-Integrationrbcar_rsbandHeiheihand-eye-calibrationRobotics-Behaviour-Planningroborts_projectBT_ros2MiRON-projectbehavior_tree_roscppPick & Placemobile_robot_projectROS_Test_wsRobotic patrolling robotics-playerrefills_second_reviewCSULA-URC-2020-21tortoisebot_waiterWaiter RoboticsPilot-URJCwrs_2021robocup2020carve-scenarios-configBTCompilervizzyomniWheelCareRobot-usualdynoMarine RoboticsHealth and Safety Inspectionlisa_shared_ws_flexbe_integrationsweetie_botgizmoDrone Swarms &Drone-Based DeliveryInteractive Robotics Companionsmarc_missionsvizzy_behavior_treesvizzy_playgroundneuronbot2_multibotneuronbot2_multibotTHEDRONELABSam_marchpy_trees_rosBehaviorTree.CPPFlexBeSMACHpy_trees_rosBehaviorTree.CPPFlexBeSMACHbundlesvisionxCleaning RoboticsCollaborative Assembling/Disassembling Bin Pickingmecatro-P17Stardustchris_turtlebot_flexible_navigationdcma_flexbeSpace RoboticsAnahitahans-ros-supervisorwpi_sample_return_challenge_2015kobuki-ros-navPickplaceWe noticed a variation between the structural properties
of behavior tree and state machine models. As a start, state
machine models have a right-skewed model size distribution
with an average model size of 9 across the population.
Similarly, behavior tree models have a right-skewed model
size distribution, but the average model size is three times
bigger than state machines (average model size is 26 across
population). Interestingly, the average branching factor
BT.ABF is 3, which is small, meaning the developers kept the
trees in a somehow manageable size. The reason behavior
tree models seem to have a bigger model size compared
to state machines could be linked to behavior tree models
representing both the execution nodes and control-ﬂow
nodes, which state machine models lack. Another reason
could be linked to state machine models becoming complex
once their size is big, affecting their understandability [75],
[76], thus developers try to keep them small. For behavior
trees, we cannot conﬁrm the optimal size of models, however
though our analysis of models we noticed the combination
of moderate size and branching of nodes make the model
easy to navigate and understand. By moderate we refer to
the average reported values for both BT.size and BT.ABF

Another structural property we were interested to capture
is nesting and depth. According to the existing empirical
studies [77], [78] nesting-level affects the understandability
of state machine models, so shallow models should be
preferred. In our sample, state machine models have an
average nesting level of one and behavior tree models
have an average depth of ﬁve (similar across languages
implementations). In state machine models, those using
FlexBe implemented hierarchical state machine, where
nesting level is bigger than one, more often than models
using SMACH (11 out of the 14 hierarchical state machine
models). It appears that in practice developers tend to keep
models shallow both when building state machine and
behavior tree models. Unfortunately, there is yet no study
on the impact of behavior trees depth on its complexity
that could justify the developers tendency to design shallow
models. A justiﬁcation could link the design decision to
understandability similar to state machine models, however
a proper investigation is required to conﬁrm.

We turn now to the use of different language constructs
in models, starting with behavior trees. In our behavior trees
sample, 66% of our dataset nodes are leaf nodes (1, 228 out
of 1, 850 total node types), and 34% are composite nodes.
Table 6 summarizes the usage of composite nodes for each
library and for the total population of behavior tree models.
Most of the composite nodes in our projects are of type
Sequence (56% of total composite nodes) followed by Selector
type (21% of total composite nodes). The Parallel concept,
which generalizes Sequence and Selector, was not used much,
only 7% of total composite nodes. This perhaps explains
why standard libraries of programming languages normally
do not include generalizations of existential and universal
quantiﬁer functions (exists and forall)—these use cases seem
to be rare. The re-entrant nature of the behavior tree language
allows to use Parallel to wait until a minimum number of
sub-trees succeed. This however does not seem to be used as
often as we expected.

Decorators are used relatively rarely in PyTrees_ros
models, they constitute 6% of the composite nodes. This

TABLE 6: Usage of different behavior trees composite nodes
to the total of them per library and in total for all models

library
BehaviorTree.CPP
PyTrees_ros

composite nodes

e
c
n
e
u
q
e
S

r
o
t
c
e
l
e
S

r
o
t
a
r
o
c
e
D

l
e
l
l
a
r
a
P

57% 19% 19% 6%
53% 28% 6% 13%

share in population of all models

56% 21% 16% 7%

is likely explained by the fact that it is easier to apply
the transforming operations directly in the Python code,
using Python syntax, than elevating it to behavior tree
abstract syntax constructors. The situation is different with
BehaviorTree.CPP, where decorators are used almost
three times as often (19% of composite nodes). Here, the
beneﬁt of using the decorators (data-ﬂow operators) of
behavior tree instead of C++ allows them to be visualized
and monitored in the graphical editor (Groot). No such tool
is available for PyTrees, so likely bigger parts of the model
may “leak” to the code. This demonstrates that users of
behavior trees often have a choice of what is in scope and
what is out of scope for a model. By model scope we refer to
the boundaries of a model where during domain analysis the
scope of what to put in a model or program-out is decided.
This is a property that clearly distinguishes GPLs from DSLs.
Yet, in our experience, the competence of deciding the model
scope and the precision level is only rarely (with exceptions
[79]) discussed in the teaching and the research literature.

Finally, we have observed that none of the models imple-
ment their own custom nodes. They relay on the extensibility
of behavior trees using new custom operator (decorators).
By using the available off-shelf decorators in Behavior-
Tree.CPP and PyTrees_ros, they were sufﬁcient to create
a custom behavior to change an action/condition status, or
customize an action length, e.g. want to execute an action
without waiting, retry an action n times before given up, or
repeat an action n times.
to

decorator
Fig.
RetryUntilSuccesful was used to create a conditional
loop that executes the sub-tree under (ExplorationSeq)
10 times, unless the task fails, which is inverted into a
success by an (Inverter). The developers were able to
model this without having to use while-loop or a similar
general control-ﬂow structure in the script.

Going

back

the

1,

OBSERVATION 7. The studied Behavior tree languages
offer a range of concepts that are well suited to roboticists,
but the offered concepts usage might differ according to
the language.

For state machine implementations, we are focusing
on the control-ﬂow containers as an equivalent concept to
composite nodes in behavior trees. As mentioned in Sect. 4.2,
SMACH offer different range of control-ﬂow containers, shar-
ing only Concurrence behavior with FlexBe. For this
reason Sequence and Iterator data is reported only for
SMACH. In general, control-ﬂow constructs in state machine
models are used far less than in behavior trees. Only 12%
of state machine models used some kind of control-ﬂow

TABLE 7: Frequency of reuse patterns per library for skill
and task level

library

SMACH
FlexBe

total for state
machines

Behavior-
Tree.CPP
PyTrees_ros

for be-

total
havior trees

intra-model
referencing
skills

tasks

-
-
1.3% -

1.3% -

clone-and-own

skills

tasks

20% 13%
16%
-

inter-model
referencing
skills

tasks

35% 8%
32% -

20% 29%

67% 8%

25% 13%

3%

39%

37% 3%

5%

5%

13% 9%

19% -

30% 18%

16% 48%

56% 3%

constructs, while in behavior tree models all of them used
some type of control-ﬂow nodes. Concurrence is used in
11% of models, with models using FlexBe being responsible
for the majority of this number (7 out of the 8 models used
FlexBe). Although Concurrence is used less in SMACH
than in FlexBe, it makes for 67% of the total control-ﬂow
constructs used in SMACH projects. Iterator is the second
most used control-ﬂow construct in projects using SMACH
with 33% of the total control-ﬂow types. Sequence is never
used in our sample.

It is not clear why the offered control-ﬂow constructs are
not as popular in state machines as in behavior trees, but it
might be related to the syntax of state machine models or
users not being familiar with them. By the syntax we mean
state machines have a structure that is easy to understand
and has been used for decades, where states represent the
status of a system and transitions facilitate the control-ﬂow
between states. Adding a layer of complexity to the model by
using the control-ﬂow constructs offered by the libraries is
less needed. Also, it might be a similar case to PyTrees_ros
Decorators usage, where it is easier to apply the pattern
directly in Python syntax, than elevating it to the state
machine abstract syntax.

6.3 Reuse

After presenting core structural characteristics of the models,
we now shift to reuse as one of the major issues in robotics
software engineering [1], [5], [18], [20], [80] and control
architectures [4], [36]. A qualitative analysis of the models
shows that reusing parts of the models plays a major role.
To facilitate reuse, a decomposition of a robotic mission or
behavior into modular components should be supported
by the modeling language. A behavior modeling language
supporting modular design, consequently reusable compo-
nents, is an important aspect for overcoming challenges
of robotics control architectures and enhancing robotics
software maintainability and quality [4], [5], [36], [80].

In our work, reusing refers to the ability to reuse skill
code (also known as action), or reusing code of a repeated
task (composed of different skills) in the same model or
across models in a project. We use skill-level and task-level
in the rest of our work to reference each. For skill-level
and task-level code reuse, we observed three patterns of
reusing: intra-model referencing, reuse by clone-and-own [81]
and inter-model referencing.

Intra-model referencing was mostly used by behavior tree
models. On the task-level, it is implemented by creating a
sub-tree for a repeated activity, then re-using it by reference
in multiple branches in the model after passing the new
values for its parameters (usually writing a new value to a
blackboard). A skill-level implementation deﬁnes a leaf node
as a function in the main model execution ﬁle, then reuses it
by reference after passing new values to its parameters.

Behavior tree models often exploited intra-model refer-
encing on skill-level (30% of behavior tree models), while
on task-level it was only used in 18% of the models. This
pattern was rarely used in state machine models. Only one
state machine model reused its skills by reference and few
reused on the task-level. Figure 9 shows an excerpt from one
of our behavior tree models, presenting the different tasks
for a robot in a retirement home. The red box highlights
an example of intra-model referencing, where the developer
wrapped the moving activity in the sub-tree (Recharge) and
reused it in multiple parts of the model. An example on the
skill-level is shown in the action moveRoboterPosition,
where it was used in multiple parts in the model, only
changing the values of parameters (name, approachRadius,
x, and y).

Reuse by clone-and-own was the top used pattern among
languages for task-level reuse. In projects with multiple
behavior tree models, we observed that, when two behavior
trees have the same activities, the similar parts (a sub-tree or
the entire model) are reused after some minor changes, such
as adding new nodes or removing old ones. Similarly in state
machines, minor modiﬁcations are introduced to a model by
adding or removing states to accommodate similar tasks. On
the skill-level, clone-and-own was mainly implemented by
minor modiﬁcations to the skill code.

Users of behavior trees and state machines favored using
clone-and-own for task-level reuse. It was the most used
pattern for task-level reuse compared to the other two
patterns (48% of models in behavior trees and 29% of models
in state machines used it). Clone-and-own was not as popular
for skill-level reuse as task-level reuse. It was the least used
pattern in behavior tree models (16% of behavior tree models)
and second used pattern in state machine models with only
20% of models reusing skills using this pattern. The Dyno
project in Fig. 10, a drone-based parcel delivery project,
includes two behavior tree models: one for a parcel delivery
mission (M1) and another one for a route scheduler mission
(M2). These models are an example of task-level clone-and-
own, where the developer reused the entire behavior tree
model for two different missions that share similar activities
after proper modiﬁcation depending on the mission.15

Inter-model referencing was the top used pattern among
languages for skill-level reuse. Repeated skills were imple-
mented as action nodes or associated with states in external
ﬁles that were imported later in the main model execution
ﬁle. This allows projects with multiple models having similar
skills to reuse these skills in different parts of the model.
Similar implementation paradigm was used for task-level by
deﬁning a repeated task as a behavior tree or state machine
model in an external ﬁle then it is imported and invoked in

15. The model can be found in full-size in the online appendix, [24]

in addition to the models of the other projects.

Fig. 9: Behavior tree model of a retirement home robot from project bundles. The red box highlights an example of a
intra-model referencing for a sub-tree Recharge (expanded on the right side). A legend is shown in Figure 2.

Fig. 10: An example of clone-and-own referencing in Behavior trees from project Dyno. Each model belong to a different
mission (M1) parcel delivery, and (M2) a route scheduler. Legend in Figure 2.

the main model execution ﬁle. The repeated task is plugged
as a sub-tree in the main behavior tree or as nested state
machine in the main state machine model.

Inter-model referencing was the most used pattern for
skill-level reuse among the different implementations (67%
of state machine models and 56% of behavior tree models
used it). For task-level, only two projects from the state
machine dataset used it and one project from the behavior
tree dataset (correspond to 8% of state machine models and
3% of behavior tree models).

An interesting observation was inter-model

refer-
encing reuse
through predeﬁned skills offered by
FlexBe developers as either an API flexbe_state, or
separate state libraries generic_flexbe_states and
Flexible Navigation. The skills were used in 73% of

FlexBe models. Similar behavior was observed across
projects of SMACH and PyTrees_ros libraries by reusing
ROS Navigation Stack skills such as move_base pack-
age (in 55% of SMACH projects and 60% of PyTrees_ros
projects). The data show predeﬁned skills APIs could facili-
tate reuse, so it could be a step worth taken by developers to
facilitate reuse.

In general, the choice of reuse mechanism is inﬂuenced
by the implementation of the libraries and whither we are
reusing skills or tasks. It was noticeable that inter-model ref-
erencing reuse was favorable for skill-level reuse among the
different libraries since deﬁning a skill in an external ﬁle and
importing it is pretty straight forward mechanism. For task-
level reuse, inter-model referencing reuse was the least used
method, while clone-and-own was more favorable. Similar

RootParallelVariantActionSequenceRecharge subTreeexpandedRepeatFallback?peoplerecognitionmoveRoboterPosition<approachRadius="200" x="5630" y="-12000">Switch2Recharge<SubTree>Recharge<SubTree>SearchThomasRoom1<SubTree>SearchThomasRoom2<SubTree>Recharge<SubTree>Recharge<SubTree>SequencemoveRoboterPosition<approachRadius="200" name="Door8" x="23200" y="-12000">moveRoboterPosition<approachRadius="10" name="GotoCharger" x="23200" y="-14800">Topics2BBMain Coordination TeePriorities/world_state/locations/world_state/objectsstartstopclearadd_deliveryQueue empty?Clear deliveries from queueClear?Set should moveStart?MoveMove to next objectMove or be canceledMoveCancelShould move?Clear should movePick up parcelMove to next locationDrop off parcelRemove first delivery from queueIdleRootClear Queue<SuccessIsFailure>Start<SuccessIsFailure>Clear QueueStart???Stop?Parcel delivery modelTopics2BBMain Coordination TeePriorities/world_state/locationsstartstopclearadd_locationQueue empty?Clear locations from queueClear?Set should moveStart?MoveMove to next waypointMoveCancelShould move?Stop?Clear should moveRemove first location from queueIdleRootClear Queue<SuccessIsFailure>Start<SuccessIsFailure>Clear QueueStart??Route scheduler modelMove or be canceled?missions might share a set of skills, but the combination of
them to form a task changes to accommodate speciﬁc needs,
thus clone-and-own is the top used pattern for task-level
reuse. Zooming into reuse among libraries, projects using
BehaviorTree.CPP have reported higher reuse frequency
compared to projects using PyTrees_ros. These numbers
can be related to BehaviorTree.CPP having a dedicated
XML format to express the behavior tree model and Groot for
visualizing the model, instead of intertwining the model with
the code like in PyTrees_ros. Visualization and abstraction
of the model could be an aspect to explore for pushing
toward reusing in robotic missions.

We conjecture that the identiﬁed simple reuse mecha-
nisms sufﬁce for the identiﬁed robotics projects. It is less
clear whether it would be useful to have safer and richer
reuse mechanisms known from mainstream programming
languages, including namespacing and safe reuse contracts
(interfaces), as they tend to be heavyweight for users to
learn and use. More research is needed to determine whether
sufﬁciently lightweight and safe reuse mechanism could be
realized.

7 THREATS TO VALIDITY

Internal Validity. We provide a dataset of behavior tree and
state machine models in robotics. Our dataset could have
projects from courses or tutorials, and we could have missed
some projects with behavior tree or state machine models
expressed in our libraries. To mitigate that, we applied a
multi-step ﬁltration mechanism that was adopted to our
observations during the mining process. We derived our
ﬁltration steps from our data observations. After each step,
we checked randomly a sample of the results to see if we
need to adopt our ﬁltration mechanism.

Another threat that could affect the results are possible
errors in our Python scripts calculating the model metrics.
In behavior trees, as a form of a quality check, we manually
counted node types and checked the script results against
them. We excluded commented parts and unused node types
in the behavior trees codes. In state machines, we rechecked
the automatic counting results by going through the models.
External Validity. A threat is the generalizability of our
quantitative results and the identiﬁed reuse patterns, since
we used a random sample of the mined models. We mitigated
that by aggregating the models into pools of sizes according
to their data distribution, then randomly sampling our
dataset. By that, we ensure capturing different projects
having different sizes of models. In addition, our project
domains presented in Fig. 8 shows our random sample covers
different domain categories.

The list of identiﬁed open source robotic projects might be
missing examples from Bitbucket and GitLab. Both platforms
are used in the robotics community, however, they do not
provide a code search API, which made it difﬁcult to conduct
a code-level search. We conducted a less precise query in
Bitbucket and GitLab using behavior trees and state machine
as a search term in the web interface. However for behavior
trees, we could not identify any real robotics projects from
that search. For state machines, GitLab returned results that
they were hard to check if they use any of the subject libraries.
We favored using GitHub due to the provided APIs ﬂexibility

and their integration with Python and other languages for
mining, and being a platform widely used by developers to
publish open-source projects compared to other platforms.

We have only considered projects using Python and C++
libraries with ROS support, while there might be other
open-source robotics projects out there. We acknowledge
that limiting our search to ROS-supported languages might
have resulted in missing other robotic projects. However, we
focused on the two dominant languages in ROS, assuming
that this is the most representative framework for open
source robotics.

8 RELATED WORK

State Machines have been proposed by various authors
to model the behavior of robots [82], [83], [84], [85], [86].
State machine models are usually commended for their
simplicity, ﬂexibility [82], [85] and widespread use, so many
developers are already familiar with them [84]. Balogh et al.
[51], [83] particularly appreciate the modularity property in
state machines where system behavior is broken into smaller
units, making it easy to diagnose malfunctions in a state or
transition action. Romay et al. [51] observed that FlexBe
is favored for its ﬂexibility and modularity as it provides
plugins for a number of tasks such as navigation. However,
many authors agree that ﬁnite state machines exhibit an
exponential blow-up in the number of states as the system
gets bigger, which makes its use in complex systems, such as
robotics exhausting.

Ambler [87] proposes a number of guidelines for model-
ing system behavior using state machines. For instance, each
state must exhibit unique behavior. Other guidelines focus
on comprehension (e.g., write transition names in past tense)
and on scalability, such as creating hierarchies and sub-states
or aggregating common transitions to reduce complexity.

State machines have been used in describing sequential
control behaviors in robotics and other autonomous systems
[83] and discrete event systems in mobile robots, with linear
and non-liner control systems [88]. Balogh et al. [51], [83]
use ﬁnite state machines for describing sequential control
behaviors in robotics and other autonomous systems.

State machines exhibit strength in describing interrupt-
driven behaviors, since the transitions are mostly triggered
by events which act as interrupts to the current state. Telle et
al. [86] propose behavior architecture, which describes how
the behavior of the robot is coordinated by a hierarchical
and asynchronous ﬁnite state machine. The architecture
coordinates complex behaviors of a humanoid robot, when
used as a service robot. Hierarchical state machines have
also been used by Foukarakis et al. [84] for modeling and
creating complex adaptive robot behaviors.

However, a number of limitations have also been ex-
pressed when using state machines for complex systems.
Harel et al. [34] argue that state machines are hard to read,
difﬁcult to draw and change, non-user-friendly, not good
for step-wise reﬁnement, and cannot be decomposed into
executable code, are cumbersome. While Iovino et al. [27]
claim that state machines were difﬁcult to extend, adopt
and reuse. The authors further reiterate the fact that n
state system will require n2 possible transitions making the
system complex to debug, update and extend. Yet, K ¨onig

et al. [33] argue that state machines have a low degree of
expressiveness.
Behavior Trees Guidelines how to apply behavior trees, as
well as important model properties relevant for multi-robot
systems, have been discussed before, by Colledanchise et
al. [8], [10], [11], [12], [89]. Motivated by their popularity in
the games domain, they explore the use in robotics and AI,
ranging from guaranteeing safety, to increasing robustness,
and demonstrating modularity by building a big system from
sub-trees as used in multi-robot and autonomous systems.
However, these works do not provide real-world robotic
projects to support the claims related to the model properties
of behavior trees: modularity, ﬂexibility, and reusability.
In contrast, our empirical study analyzes behavior tree
characteristics in real-world robotic projects, and in contrast
to those papers, we were able to observe reusability, ﬂexibility
and extensibility through analyzing the studied behavior tree
models. So, our work can be considered as complementary,
conﬁrming some of the declared claims about behavior trees.
The use of behavior trees in various robotics sub-domains
has also been discussed before. Colledanchise and ¨Ogren
[8], in their thorough introduction to behavior trees, discuss
model excerpts from industrial applications that the authors
are aware of (e.g., by the truck manufacturer SCANIA).
They also discuss the relationship of behavior trees to other
behavior models (e.g., ﬁnite state machine and decision tree).
A survey by Iovino et al. [27] of 160 research papers, devoted
to the development of behavior tree as a tool for AI in
games and robotics, highlights how behavior trees have
been used in different application areas such as games AI
and chatbots, mobile ground robots, aerial and underwater
robots. In contrast, we focus on comparing behavior trees
modeling concepts and design principles from a language
perspective, and, most importantly, we compare behavior
tree models with real ﬁnite state machine models that we
mined from real-world open-source robotics projects. We
provide these behavior tree and ﬁnite state machine models
as a community dataset, which non of the previous literature
did. The dataset can be used for further research.

Bagnell et al. [9] present a robotic system with perception,
planning, and control, where task control is driven by
behavior trees. The authors ﬁnd that behavior trees easily
describe complex manipulation tasks, and that behaviors
can be reused. They chose behavior trees, because they had a
team with a broad skill sets and needed a task orchestrating
model that is easy to use by each team member. Our
ﬁndings support their claim to some extent, assuming all
team members have basic programming skills. However,
according to one of our observations, we noticed that
behavior trees require language-oriented programming skills.

9 CONCLUSION

We presented a study of behavior tree and state machine
languages, and of their use in real-world robotics applica-
tions. We systematically compared the concepts of popular
behavior tree language implementations with each other
and with well-established implementations of the behavior
modeling language state machines. We mined open-source
projects from code repositories and extracted their behavior
tree and state machine models from the codebases, analyzing

their structure properties, use of concepts, and code reuse
mechanisms. We contribute a dataset of models in the online
appendix [24], together with scripts, and additional data.

Our analysis sheds light on languages designed outside
of the language-engineering community for the vibrant
and highly interesting domain of robotics. We believe that
studying modeling and language-engineering practices is
beneﬁcial for both communities, as it helps to improve
language-engineering methods and tools, as well as to
improve the actual practices and languages. In fact, our
results illustrate that many of the modeling and language-
engineering methods are relevant in practice, especially the
models-at-runtime paradigm, meta-model extensibility, and
model-based design. However, it also shows that developing
languages in a rather pragmatic way, without hundreds
of pages of speciﬁcation documents and with a basic, but
extensible meta-model, or even without an explicitly deﬁned
meta-model seems to be successful. Such a strategy seems to
attract practitioners not trained in language and modeling
technology, allowing practitioners who come from lower-
level programming paradigms to raise the level of abstraction
and effectively implement missions of robots in higher-level
representations.

Still, we have observed aspects of the modeling languages
and models that are clearly suboptimal from the language
design perspective, and pose interesting opportunities for
this community to make impact. The different implementa-
tions of the languages are highly extensible, but this comes at
a cost of not having proper concrete syntax, and a seemingly
high requirement that its users need to be familiar with
language-oriented programming. Moreover, the abstract-
syntax-oriented modeling encourages heavy coupling of the
model and the controlled system. This makes it really hard
to work with models separately—for instance, veriﬁcation,
testing, and even visualizing may be a challenge without a
working build system.

As highlighted by Colledanchise and Natale [50] behavior
tree implementations are less mature than state machine
available tools. In our analysis, we have observed that the
implementations of both modeling languages have good
design practices and some improvement aspects to learn
from each others.

As a start having a GUI that provides constructing,
editing and run-time monitoring of models is a good practice.
Both FlexBe and BehaviorTree.CPP provide similar
tools, which is reﬂected in the users of the libraries using
constructs and reuse code more often compared to the
other two implementations. Having a GUI can support in
visualization and model-abstraction.

BehaviorTree.CPP is built with separation of concerns
and separation of roles in mind [49], making it possible to
decouple models from the robotic system for visualization
and testing. It also enables stockholders with no advance
programming expertise to use behavior trees. During model
analysis, we managed to load models easily in Groot without
the need to set-up ROS or fulﬁll other requirements of the
robotic projects. Also, inspecting the XML code for the
models was easy to understand. These are two features
that we appreciated during analysis. The latter feature
was not observed in both state machine implementations
and PyTrees_ros, which required us to hack our way

to inspect models. However in terms of supporting users
with no advance programming, an improvement aspect
from FlexBe could be learned. FlexBe utilize auto-code
generation from model-based design for boilerplate code,
which BehaviorTree.CPP only provide minor support for
it. Although code generation is considered restrictive over
ﬂexible programming, learning how FlexBe only support
generating repetitive parts and still allow edits might be
valuable. In addition, providing syntactic and semantic
checks for model consistency are another good feature of
code generation.

Promoting and adopting model-driven engineering
(MDE) practices have been on the rise in the robotic commu-
nity to improve reusability and maintainability of systems
[5], [20], [80], [90], [91], [92], [93]. Through our analysis, we
observed common practices across the different languages
that are adopted from MDE and seem well received by
practitioners. In addition, improvements to these behavior
modeling languages could be adopted and evaluated in the
robotic community. In the future, we would like to provide
good design practices guidelines for behavior modeling
languages that promote MDE practices and at the same
time derived from the current state-of-practice. In addition
during our analysis we noticed most projects lack mission
speciﬁcation. So, we want to use our dataset to develop
automatic tools to generate mission speciﬁcation in natural
language from existing behavior tree models. By achieving
that we help in creating automated re-engineering tools for
legacy projects that could be reused by other practitioners
instead of starting from scratch.

ACKNOWLEDGMENTS

This work was partially supported by the Wallenberg AI,
Autonomous Systems and Software Program (WASP) funded
by the Knut and Alice Wallenberg Foundation.

REFERENCES

[1]

S. Garcia, D. Strueber, D. Brugali, T. Berger, and P. Pelliccione,
“Robotics software engineering: A perspective from the service
robotics domain,” in 28th ACM SIGSOFT International Symposium
on the Foundations of Software Engineering, ser. FSE, 2020.

[2] C. Menghi, C. Tsigkanos, P. Pelliccione, C. Ghezzi, and T. Berger,
“Speciﬁcation patterns for robotic missions,” IEEE Transactions on
Software Engineering, 2019, preprint.

[3] F. Michaud and M. Nicolescu, “Behavior-based systems,” in

Springer handbook of robotics. Springer, 2016, pp. 307–328.

[4] D. Kortenkamp, R. Simmons, and D. Brugali, “Robotic systems
architectures and programming,” in Springer handbook of robotics.
Springer, 2016, pp. 283–306.

[5] D. Brugali and A. Shakhimardanov, “Component-based robotic
engineering (part ii),” IEEE Robotics & Automation Magazine, vol. 17,
no. 1, pp. 100–112, 2010.

[6] F. W. Heckel, G. M. Youngblood, and N. S. Ketkar, “Represen-
tational complexity of reactive agents,” in IEEE Conference on
Computational Intelligence and Games (CIG).

IEEE, 2010.

[7] D. Isla, “Handling complexity in the Halo 2 AI,” GDC 2005 Proceed-
ings, 2005. [Online]. Available: https://www.gamasutra.com/view/
feature/130663/gdc 2005 proceeding handling .php?page=2
[8] M. Colledanchise and P. ¨Ogren, Behavior Trees in Robotics and Al: An

[9]

Introduction. CRC Press, 2018.
J. A. Bagnell, F. Cavalcanti, L. Cui, T. Galluzzo, M. Hebert,
M. Kazemi, M. Klingensmith, J. Libby, T. Y. Liu, N. Pollard et al.,
“An integrated system for autonomous robotics manipulation,” in
International Conference on Intelligent Robots and Systems (IROS),
2012.

[10] M. Colledanchise, A. Marzinotto, D. V. Dimarogonas, and P. Oegren,
“The advantages of using behavior trees in multi robot systems,” in
47th International Symposium on Robotics (ISR), 2016.

[11] M. Colledanchise and P. ¨Ogren, “How behavior trees modularize
hybrid control systems and generalize sequential behavior com-
positions, the subsumption architecture, and decision trees,” IEEE
Transactions on robotics, vol. 33, no. 2, pp. 372–389, 2016.

[12] M. Colledanchise, R. Parasuraman, and P. ¨Ogren, “Learning of
behavior trees for autonomous agents,” IEEE Transactions on Games,
vol. 11, no. 2, pp. 183–189, 2018.

[13] P. ¨Ogren, “Increasing modularity of uav control systems using
computer game behavior trees,” in AIAA Guidance, Navigation, and
Control Conference (GNC), 2012.

[14] F. Rovida, B. Grossmann, and V. Kr ¨uger, “Extended behavior
trees for quick deﬁnition of ﬂexible robotic tasks,” in IEEE/RSJ
International Conference on Intelligent Robots and Systems ( IROS ),
2017.

[15] S. Garc´ıa, P. Pelliccione, C. Menghi, T. Berger, and T. Bures, “High-
level mission speciﬁcation for multiple robots,” in 12th International
Conference on Software Language Engineering (SLE), 2019.

[16] A. Kl ¨ockner, “Interfacing behavior trees with the world using
description logic,” in AIAA Guidance, Navigation, and Control
Conference (GNC), 2013.

[17] M. Quigley, K. Conley, B. Gerkey, J. Faust, T. Foote, J. Leibs,
R. Wheeler, A. Y. Ng et al., “Ros: an open-source robot operating
system,” in ICRA workshop on open source software, vol. 3, no. 3.2.
Kobe, Japan, 2009, p. 5.

[18] I. A. Nesnas, R. Simmons, D. Gaines, C. Kunz, A. Diaz-Calderon,
T. Estlin, R. Madison, J. Guineau, M. McHenry, I.-H. Shu et al.,
“Claraty: Challenges and steps toward reusable robotic software,”
International Journal of Advanced Robotic Systems, vol. 3, no. 1, p. 5,
2006.

[19] S. Garcia, D. Strueber, D. Brugali, A. D. Fava, P. Pelliccione, and
T. Berger, “Software variability in service robotics,” Empirical
Software Engineering, 2022.

[20] S. Garcia, D. Strueber, D. Brugali, A. D. Fava, P. Schillinger,
P. Pelliccione, and T. Berger, “Variability modeling of service robots:
Experiences and challenges,” in 13th International Workshop on
Variability Modelling of Software-intensive Systems (VaMoS), 2019.
[21] R. Ghzouli, T. Berger, E. B. Johnsen, S. Dragule, and A. Wasowski,
“Behavior trees in action: a study of robotics applications,” in
Proceedings of the 13th ACM SIGPLAN International Conference on
Software Language Engineering, 2020, pp. 196–209.

[22] N. Bencomo, R. B. France, B. H. C. Cheng, and U. Aßmann, Eds.,
Models@run.time—Foundations, Applications, and Roadmaps, vol. 8378.
Springer, 2014.

[23] G. Blair, N. Bencomo, and R. B. France, “Models@run.time,” IEEE

Computer, vol. 42, no. 10, pp. 22–27, 2009.

[24] “Online appendix,” https://bitbucket.org/easelab/behaviortrees,

2020.

[25] S. Macenski, F. Mart´ın, R. White, and J. G. Clavero, “The marathon
2: A navigation system,” in 2020 IEEE/RSJ International Conference
on Intelligent Robots and Systems (IROS).
IEEE, 2020, pp. 2718–2725.
[26] S. Garcia, P. Pelliccione, C. Menghi, T. Berger, and T. Bures,
“Promise: High-level mission speciﬁcation for multiple robots,”
in 42nd International Conference on Software Engineering (ICSE),
Demonstrations Track, 2020.

[27] M. Iovino, E. Scukins, J. Styrud, P. ¨Ogren, and C. Smith, “A survey
of behavior trees in robotics and ai,” arXiv preprint arXiv:2005.05842,
2020.

[28] I. Millington and J. Funge, Artiﬁcial intelligence for games. CRC

Press, 2009.

[29] D. C. Conner and J. Willis, “Flexible navigation: Finite state
machine-based integrated navigation and control for ros enabled
robots,” in SoutheastCon 2017.

IEEE, 2017, pp. 1–8.

[30] M. L. Crane and J. Dingel, “Uml vs. classical vs. rhapsody
statecharts: not all models are created equal,” Software & Systems
Modeling, vol. 6, no. 4, pp. 415–435, 2007.

[31] M. Von der Beeck, “A comparison of statecharts variants,” in Formal
techniques in real-time and fault-tolerant systems. Citeseer, 1994, pp.
128–148.

[32] E. F. Moore et al., “Gedanken-experiments on sequential machines,”

Automata studies, vol. 34, pp. 129–153, 1956.

[33] L. K ¨onig, S. Mostaghim, and H. Schmeck, “Decentralized evolution
of robotic behavior using ﬁnite state machines,” International Journal
of Intelligent Computing and Cybernetics, 2009.

[34] D. Harel, “Statecharts: A visual formalism for complex systems,”
Science of computer programming, vol. 8, no. 3, pp. 231–274, 1987.
[35] G. L ¨uttgen, M. Von der Beeck, and R. Cleaveland, “A composi-
tional approach to statecharts semantics,” ACM SIGSOFT Software
Engineering Notes, vol. 25, no. 6, pp. 120–129, 2000.

[36] M. Colledanchise, “Behavior trees in robotics,” Ph.D. dissertation,

KTH Royal Institute of Technology, 2017.

[37] D. Stonier, N. Usmani, and M. Staniaszek, “Py trees library
documentation,” https://py-trees.readthedocs.io/en/devel/, 2020.
[38] D. Faconti and M. Colledanchise, “Behaviortree.cpp library docu-

mentation,” https://www.behaviortree.dev, 2018.

[39] J. Bohren and S. Cousins, “The SMACH high-level executive [ros
news],” IEEE Robotics & Automation Magazine, vol. 17, no. 4, pp.
18–20, 2010.

[40] P. Schillinger, S. Kohlbrecher, and O. von Stryk, “Human-robot
collaborative high-level control with an application to rescue
robotics,” in IEEE International Conference on Robotics and Automation
(ICRA), May 2016.

[41] P. Schillinger, “An approach for runtime-modiﬁable behavior con-
trol of humanoid rescue robots,” Technische Universitat Darmstadt,
2015.

[42] J. Bohren and S. Cousins, “Smach library documentation,” http:

//wiki.ros.org/smach/Documentation, 2010.

[43] P. Schillinger, “Flexbe library documentation,” http://philserver.

bplaced.net/fbe/documentation.php, 2016.

[44] D. Stonier, N. Usmani, and M. Staniaszek, “Py trees ros library
documentation,” http://docs.ros.org/kinetic/api/py trees ros/
html/index.html, 2020.

[45] D. Faconti and M. Colledanchise, “Behaviortree.cpp library tutori-
als,” https://www.behaviortree.dev/tutorial 01 ﬁrst tree/, 2018.
[46] D. Stonier, N. Usmani, and M. Staniaszek, “Py trees ros library
tutorials,” https://py-trees-ros-tutorials.readthedocs.io/en/devel/
tutorials.html, 2020.

[47] P. Schillinger, “Flexbe library tutorials,” http://wiki.ros.org/ﬂexbe/

Tutorials, 2021.

[48] J. Bohren and S. Cousins, “Smach library tutorials,” http://wiki.

ros.org/smach/Tutorials, 2021.

“MOOD2Be: Models

to design
[49] D. Faconti,
2020
robotic
Research
[Online].
Available: https://github.com/BehaviorTree/BehaviorTree.CPP/
blob/master/MOOD2Be ﬁnal report.pdf

European Union’s Horizon

Programme,

behaviors,”

and tools

Innovation

2019.

and

[50] M. Colledanchise and L. Natale, “On the implementation of
behavior trees in robotics,” IEEE Robotics and Automation Letters,
vol. 6, no. 3, pp. 5929–5936, 2021.

[51] A. Romay, S. Kohlbrecher, A. Stumpf, O. von Stryk, S. Maniatopou-
los, H. Kress-Gazit, P. Schillinger, and D. C. Conner, “Collaborative
autonomy between high-level behaviors and human operators
for remote manipulation tasks using different humanoid robots,”
Journal of Field Robotics, vol. 34, no. 2, pp. 333–358, 2017.

[52] M. AlMarzouq, A. AlZaidan, and J. AlDallal, “Mining github for
research and education: challenges and opportunities,” International
Journal of Web Information Systems, 2020.

[53] I. Malavolta, G. A. Lewis, B. Schmerl, P. Lago, and D. Garlan,
“Mining guidelines for architecting robotics software,” Journal of
Systems and Software, vol. 178, p. 110969, 2021.

[54] G. Robles, T. Ho-Quang, R. Hebig, M. R. Chaudron, and M. A.
Fernandez, “An extensive dataset of uml models in github,” in
2017 IEEE/ACM 14th International Conference on Mining Software
Repositories (MSR).
IEEE, 2017, pp. 519–522.

[55] S. R. Chidamber and C. F. Kemerer, “A metrics suite for object
oriented design,” IEEE Transactions on software engineering, vol. 20,
no. 6, pp. 476–493, 1994.

[56] T. Berger and J. Guo, “Towards system analysis with variability
model metrics,” in Proceedings of the Eighth International Workshop
on Variability Modelling of Software-Intensive Systems, 2014, pp. 1–8.
[57] J. A. Cruz-Lemus, M. Genero, and M. Piattini, “Using controlled
experiments for validating uml statechart diagrams measures,”
in Software Process and Product Measurement.
Springer, 2007, pp.
129–138.

[58] J. A. CRUZ-LEMUS, M. GENERO, and M. PIATTINI, “Metrics for
uml statechart diagrams,” in Metrics for Software Conceptual Models,
2005, pp. 237–272.

[59] R. van Tonder and C. Le Goues, “Lightweight multi-language syn-
tax transformation with parser parser combinators,” in Proceedings
of the 40th ACM SIGPLAN Conference on Programming Language
Design and Implementation, 2019, pp. 363–378.

[60] M.

Colledanchise,

“Bt++

library

documentation,”

https://github.com/miccol/ROS-Behavior-Tree/blob/master/
BTUserManual.pdf, 2017.

[61] F. Rovida, “Skiros2 library documentation,” https://github.com/

RVMI/skiros2/wiki, 2020.

[62] E. Games,

“Unreal

library
documentation,” https://docs.unrealengine.com/en-US/Engine/
ArtiﬁcialIntelligence/BehaviorTrees/BehaviorTreeUserGuide/
index.html, 2020.

behavior

engine

tree

4

[63] R. AI, “Smacc library documentation,” https://smacc.dev/, 2018.
[64] M. Steinbrink, P. Koch, S. May, B. Jung, and M. Schmidpeter, “State
machine for arbitrary robots for exploration and inspection tasks,”
in Proceedings of the 2020 4th International Conference on Vision, Image
and Signal Processing, 2020, pp. 1–6.

[65] F. Rovida, M. Crosby, D. Holz, A. S. Polydoros, B. Großmann,
R. Petrick, and V. Kr ¨uger, “Skiros—a skill-based robot control
platform on top of ros,” in Robot operating system (ROS). Springer,
2017, pp. 121–160.

[66] F. Rovida and V. Kr ¨uger, “Design and development of a software
architecture for autonomous mobile manipulators in industrial
environments,” in 2015 IEEE International Conference on Industrial
Technology (ICIT).
IEEE, 2015, pp. 3288–3295.

[67] J.-P. Tolvanen and S. Kelly, “How domain-speciﬁc modeling
languages address variability in product line development: In-
vestigation of 23 cases,” in 23rd International Systems and Software
Product Line Conference, ser. SPLC, 2019.

[68] O. M. Group, “Omg uniﬁed modeling language 2.5.1,” 2017.

[Online]. Available: https://www.omg.org/spec/UML/

[69] A. Alami, Y. Dittrich, and A. Wasowski, “Inﬂuencers of quality
assurance in an open source community,” in 11th International
Workshop on Cooperative and Human Aspects of Software Engineering
(CHASE), 2018.

[70] J. Bosch, “Design patterns as language constructs,” Journal of Object

Oriented Programming, 1997.

[71] M. E. Conway, “Design of a separable transition-diagram compiler,”

Commun. ACM, vol. 6, no. 7, pp. 396–408, Jul. 1963.

[72] O.-J. Dahl and C. Hoare, “Hierarchical program structures,” in
Structured Programming, O.-J. Dahl, E. W. Dijkstra, and C. Hoare,
Eds. Academic Press, 1972.

[73] E. B. Johnsen, R. H¨ahnle, J. Sch¨afer, R. Schlatte, and M. Steffen,
“ABS: A core language for abstract behavioral speciﬁcation,” in
9th International Symposium on Formal Methods for Components and
Objects (FMCO ), 2010.

[74] T. Der Einreichung et al., “An approach for runtime-modiﬁable

behavior control of humanoid rescue robots,” 2015.

[75] J. A. Cruz-Lemus, A. Maes, M. Genero, G. Poels, and M. Piattini,
“The impact of structural complexity on the understandability of
uml statechart diagrams,” Information Sciences, vol. 180, no. 11, pp.
2209–2220, 2010.

[76] M. Genero, D. Miranda, and M. Piattini, “Deﬁning and validating
metrics for uml statechart diagrams,” Proceedings of QAOOSE, vol.
2002, 2002.

[77] J. Cruz-Lemus, M. Genero, M. Piattini, and A. Toval, “Investigating
the nesting level of composite states in uml statechart diagrams,”
Proc. QAOOSE, vol. 5, pp. 97–108, 2005.

[78] J. A. Cruz-Lemus, M. Genero, M. Piattini, and A. Toval, “An
empirical study of the nesting level of composite states within
uml statechart diagrams,” in International Conference on Conceptual
Modeling. Springer, 2005, pp. 12–22.

[79] A. Wasowski and T. Berger, Domain-speciﬁc Languages: Effective
[Online]. Available:

Modeling, Automation, and Reuse, 2022.
http://dsl.design

[80] D. Brugali and P. Scandurra, “Component-based robotic engineer-
ing (part i)[tutorial],” IEEE Robotics & Automation Magazine, vol. 16,
no. 4, pp. 84–96, 2009.

[81] Y. Dubinsky, J. Rubin, T. Berger, S. Duszynski, M. Becker, and
K. Czarnecki, “An exploratory study of cloning in industrial
software product lines,” in 17th European Conference on Software
Maintenance and Reengineering (CSMR), 2013.

[82] D. Blank, D. Kumar, L. Meeden, and H. Yanco, “The pyro toolkit
for ai and robotics,” AI magazine, vol. 27, no. 1, pp. 39–39, 2006.
[83] R. Balogh and D. Obdrˇz´alek, “Using ﬁnite state machines in
introductory robotics,” in International Conference on Robotics and
Education RiE 2017. Springer, 2018, pp. 85–91.

[84] M. Foukarakis, A. Leonidis, M. Antona, and C. Stephanidis,
“Combining ﬁnite state machine and decision-making tools for

adaptable robot behavior,” in International Conference on Universal
Access in Human-Computer Interaction. Springer, 2014, pp. 625–635.
[85] D. O. Sales, P. Shinzato, G. Pessin, D. F. Wolf, and F. S. Osorio,
“Vision-based autonomous navigation system using ann and fsm
control,” in 2010 Latin American Robotics Symposium and Intelligent
Robotics Meeting.

IEEE, 2010, pp. 85–90.
[86] R. Tellez, F. Ferro, S. Garcia, E. Gomez, E. Jorge, D. Mora, and D. R.-
B. Faconti, “An autonomous lightweight human-size humanoid
robot,” in Proceedings of the Humanoids, 2008.

[87] S. W. Ambler, “Uml state machine diagrams,” in The Elements of
UML™ 2.0 Style,. Cambridge University Press, 2005, ch. 1, p.
103–112.

[88] S. Jeong, T. Ga, I. Jeong, and J. Choi, “Behavior tree driven multi-
mobile robots via data distribution service (dds),” in 2021 21st
International Conference on Control, Automation and Systems (ICCAS).
IEEE, 2021, pp. 1633–1638.

[89] M. Colledanchise and P. ¨Ogren, “How behavior trees modularize
robustness and safety in hybrid systems,” in International Conference
on Intelligent Robots and Systems (IROS), 2014.

[90] E. de Ara ´ujo Silva, E. Valentin, J. R. H. Carvalho, and R. da Silva Bar-
reto, “A survey of model driven engineering in robotics,” Journal of
Computer Languages, vol. 62, p. 101021, 2021.

[91] L. Gherardi and D. Brugali, “Modeling and reusing robotic software
architectures: The hyperﬂex toolchain,” in 2014 IEEE International
Conference on Robotics and Automation (ICRA).
IEEE, 2014, pp.
6414–6420.

[92] C. Schlegel, A. Lotz, M. Lutz, D. Stampfer, J. F. Ingl´es-Romero, and
C. Vicente-Chicote, “Model-driven software systems engineering in
robotics: covering the complete life-cycle of a robot,” it-Information
Technology, vol. 57, no. 2, pp. 85–98, 2015.

[93] D. L. Wigand, A. Nordmann, M. Goerlich, and S. Wrede, “Modu-
larization of domain-speciﬁc languages for extensible component-
based robotic systems,” in 2017 First IEEE International Conference
on Robotic Computing (IRC).

IEEE, 2017, pp. 164–171.

Razan Ghzouli is currently working towards a
PhD degree at Chalmers University of Technol-
ogy, Gothenburg, Sweden, where she is part
of the software engineering division at the De-
partment of Computer Science and Engineering.
She received her master degree in applied data
science from the university of Gothenburg, Swe-
den and her bachelor degree in computer and
automation engineering from Damascus univer-
sity, Syria. Her PhD focuses on facilitating the
migration to model-based design and systems to

enable reusable and maintainable robotic missions.

Swaib Dragule is a PhD Fellow in Computer
Science and Software Engineering at Chalmers
University of Technology and Makerere University.
He holds MSc. and BSc. in computer science. He
is an academic staff of Makerere university, Col-
lege of Computing and Information Sciences. His
research interests are in programming languages,
domain-speciﬁc languages, and robotics.

Thorsten Berger is a Professor in Computer
Science at Ruhr University Bochum in Germany.
After receiving the PhD degree from the Univer-
sity of Leipzig in Germany in 2013, he was a
Postdoctoral Fellow at the University of Waterloo
in Canada and the IT University of Copenhagen in
Denmark, and then an Associate Professor jointly
at Chalmers University of Technology and the
University of Gothenburg in Sweden. He received
competitive grants from the Swedish Research
Council, the Wallenberg Autonomous Systems
Program, Vinnova Sweden (EU ITEA), and the European Union. He is
a fellow of the Wallenberg Academy—one of the highest recognitions
for researchers in Sweden. He received two best-paper awards and
one most inﬂuential paper award. His service was recognized with
distinguished reviewer awards at the tier-one conferences ASE 2018 and
ICSE 2020. His research focuses on model-driven software engineering,
program analysis, and empirical software engineering.

Einar Broch Johnsen is a Professor at the
Department of Informatics of the University of
Oslo in Norway. He is the strategy director of
Sirius, a center for research-driven innovation
with long-term funding from the Research Council
of Norway. He has been prominently involved in
many national and European research projects;
in particular, he was the coordinator of the EU
FP7 project Envisage (2013-2016) on formal
methods for cloud computing and the scientiﬁc
coordinator of the EU H2020 project HyVar (2015-
2018) on hybrid variability systems. His research focuses on formal
methods, programming models and methodology, and program analysis
in domains such as distributed and concurrent systems, cloud computing,
digital twins and robotics.

Andrzej Wasowski is Professor of Software En-
gineering at the IT University of Copenhagen.
He has also worked at Aalborg University in
Denmark, and as visiting professor at INRIA
Rennes and University of Waterloo, Ontario. His
interests are in software quality, reliability, and
safety in high-stake high-value software projects.
This includes semantic foundations and tool
support for model-driven development, program
analysis tools, testing tools and methods, as well
as processes for improving and maintain quality
in software projects. Many of his projects involve commercial or open-
source partners, primarily in the domain of robotics and safety-critical
embedded systems. Recently he coordinates the Marie-Curie training
network on Reliable AI for Marine Robotics (REMARO). Wasowski holds
a PhD degree from the IT University of Copenhagen, Denmark (2005) and
a MSC Eng degree from the Warsaw University of Technology, Poland
(2000).

