A Declarative Modelling Framework for
the Deployment and Management of Blockchain Applications
Luciano Baresi∗, Giovanni Quattrocchi∗, Damian Andrew Tamburri+, Luca Terracciano∗
∗Dipartimento di Elettronica, Informazione e Bioingegneria, Politecnico di Milano, Milan, Italy,
name.surname@polimi.it
+Jheronimus Academy of Data Science, Tilburg University, ’s-Hertogenbosch, Netherlands, d.a.tamburri@tue.nl

2
2
0
2

p
e
S
2
1

]
E
S
.
s
c
[

1
v
2
9
0
5
0
.
9
0
2
2
:
v
i
X
r
a

ABSTRACT
The deployment and management of Blockchain applications re-
quire non-trivial eﬀorts given the unique characteristics of their in-
frastructure (i.e., immutability) and the complexity of the software
systems being executed. The operation of Blockchain applications
is still based on ad-hoc solutions that are error-prone, diﬃcult to
maintain and evolve, and do not manage their interactions with
other infrastructures (e.g., a Cloud backend).

This paper proposes KATENA, a framework for the deployment
and management of Blockchain applications. In particular, it fo-
cuses on applications that are compatible with Ethereum, a pop-
ular general-purpose Blockchain technology. KATENA provides
i) a metamodel for deﬁning Blockchain applications, ii) a set of
processes to automate the deployment and management of de-
ﬁned models, and iii) an implementation of the approach based
on TOSCA, a standard language for Infrastructure-as-Code, and
xOpera, a TOSCA-compatible orchestrator. To evaluate the ap-
proach, we applied KATENA to model and deploy three real-world
Blockchain applications, and showed that our solution reduces the
amount of code required for their operations up to 82.7%.

CCS CONCEPTS
• Information systems → Application Orchestration; • Com-
puter systems organization → Decentralized architectures; •
Software and its engineering → Model Driven Engineering.

KEYWORDS
blockchain, dApp, decentralized applications, orchestration,
devops,
iac, smart contract, ethereum,
TOSCA, deployment

infrastructure-as-code,

1 INTRODUCTION
Blockchain has emerged as a new disruptive technology that pro-
vides a decentralized and traceable ledger where users can safely
record transactions among one another in a trustless environment
with high-security guarantees. Many Blockchain implementations
turned into computing platforms by adding the possibility to de-
velop smart contracts: general-purpose computer programs that
are stored and executed on the Blockchain. Ethereum [10] is one
of the most popular platforms for Blockchain applications [1, 14]
and its runtime, the Ethereum Virtual Machine (EVM), has been
adopted by several other Blockchains [12]. Recently, many ap-
plications, for example, the ones related to ﬁnance [13], supply
chain [17], and collectibles [2], have adopted this computation

doi.org/10.5281/zenodo.7009710

paradigm, and have started to move critical components —or the
whole business logic— on-chain (i.e., on the Blockchain).

Smart contracts are interesting but challenging. They are trans-
parent, because the deployed code is publicly accessible and ev-
eryone can verify it, are highly available since every node in the
network can execute their code, and oﬀer interoperability among
applications within the same Blockchain since they share the same
infrastructure. In contrast, when a contract is deployed on the
Blockchain, its code can no longer be modiﬁed. This is critical
when bugs are found (e.g., security issues): attackers can easily op-
erate [23] on the bugged contract and there is no way for devel-
opers to ﬁx it. To overcome this limitation, upgradable smart con-
tracts [34] have been recently presented in the Ethereum ecosys-
tem. They exploit well-known design patterns to allow for the
seamless upgrade of smart contracts and are considered a de-facto
standard for Ethereum-based Blockchain developments [26]. Be-
sides the operations required to deploy “standard” smart contracts,
these patterns also require additional conﬁguration in the deploy-
ment scripts, adding a further degree of complexity.

While initially, the majority of Blockchain applications were rel-
atively small, that is, only composed of a few contracts, their com-
plexity is now increasing [30]. The deployment of the ﬁrst appli-
cations was “easy” and carried out through ad-hoc scripts written
in well-known imperative programming languages (e.g., Python,
Javascript). Developers had to provide a step-by-step description
of how the deployment had to be carried out. These “simple” ap-
proaches are now unﬁt to address more complex applications since
they are error-prone and lack reusability, portability, and agility in
evolving the system.

The growth in the complexity of “traditional” applications, and
the advent of virtualized resources —often available through the
cloud, has already imposed a paradigm shift for managing applica-
tion deployment and operation. Imperative approaches have been
abandoned in favor of declarative solutions, which only require an
application model, that is, a speciﬁcation of the application’s archi-
tecture and of its deployment. A so-called orchestrator then enacts
these speciﬁcations to deploy and manage the applications.

The peculiarities of Blockchain-based applications do not allow
one to simply reuse these solutions, but there is an emerging need
for declarative Blockchain-oriented orchestration solutions [28].
Cloud solutions assume that the infrastructure is provisioned and
managed by users and that applications are “easily” upgradable.
The Blockchain is diﬀerent: the infrastructure is abstracted away
from users, and applications require a non-trivial engineering ef-
fort to be updated. A declarative approach would help both in-
crease the eﬃciency of Blockchain operations, and provide a uni-
ﬁed approach to handle hybrid applications, that is, applications

 
 
 
 
 
 
MODELS’22, October 2022, Montreal, Canada

Baresi, Quattrocchi, Tamburri, Terracciano

whose application logic is executed partially on and partially oﬀ
the Blockchain.

This paper presents KATENA, a declarative framework for the
deployment and management of Ethereum and EVM-compatible
applications. KATENA features a model-driven engineering (MDE)
methodology [8] at its core. A metamodel deﬁnes a set of reusable
components for the creation of application models, ranging from
infrastructural nodes to smart contracts, and other components
that run outside the Blockchain (i.e., oﬀ-chain). Lifecycle oper-
ations (i.e., how to deploy and update a single component) are
embedded in each component, to further ease the modeling task.
KATENA also provides a set of processes to enact the deployment
and management of deﬁned models in a sound and automated way.
To assess KATENA, we implemented a prototype based on the
standard OASIS TOSCA speciﬁcation language [6] (Topology and
Orchestration Speciﬁcation for Cloud Applications) and xOpera1,
a TOSCA-compliant state-of-the-art orchestrator. We then con-
ducted an evaluation based on three case-studies [33], that is, three
real-world applications coming from diﬀerent domains and with
diﬀerent architectural complexity. The evaluation targeted explic-
itly a realistic assessment of the pains and gains of our approach
from both a qualitative and a quantitative perspective and com-
pared against state-of-the-art solutions, in particular with devel-
opment frameworks Truﬄe2 and Hardhat3. The comparison re-
veals that KATENA is capable of achieving at least the same re-
sults when compared to competing approaches, but with a con-
siderably smaller amount of code. Speciﬁcally, as the complexity
of featured applications increases, KATENA features ﬁles with as
much as 82.7% less code compared to existing solutions.

The rest of the paper is organized as follows. Section 2 intro-
duces the background implied by this work: Blockchain, smart
contracts, upgradeable Smart Contracts, and state-of-the-art de-
ployment frameworks. Section 3 presents the metamodel, the de-
ployment and management processes, and usage scenarios for
KATENA. Section 4 describes the prototype and implemented fea-
tures. Section 5 discusses the assessment we carried out to eval-
uate KATENA and its prototype. Section 6 surveys some related
approaches, and Section 7 concludes the paper.

2 BACKGROUND
The following sections introduce the background concepts re-
quired to fully understand our solution: Blockchain, smart con-
tracts, and the most signiﬁcant existing deployment frameworks.
The reader familiar with these concepts can easily skip or skim
through them.

2.1 Blockchain
A Blockchain is a decentralized peer-2-peer network of nodes that
comprises a ledger of user transactions, organized in an append-
only sequence (or chain) of blocks, and a shared state that is the
result of all executed transactions. A transaction represents a set
of actions, initiated by a user, that causes a change in the shared
state of the Blockchain. Since a Blockchain has a native currency

1https://github.com/xlab-si/xopera-opera
2https://truﬄesuite.com/
3https://hardhat.org/

(e.g., ether in Ethereum), a transaction can be of a mere mone-
tary nature (e.g., Alice sends 10 ether to Bob), but it can also re-
quire computation, by means of smart contracts, whose execution
must be paid for.

Blockchain solves the so-called Byzantine Generals Problem
[21], that is, the problem of validating a shared state in a trust-
less decentralized environment. To achieve this, every node main-
tains a local copy of the Blockchain (i.e., ledger, state, and smart
contracts) that is used for validating new transactions. Moreover,
Blockchains employ a decentralized consensus mechanism that
relies on cryptography and on incentives to reach an agreement
among the nodes on which transactions should consider valid.
Once the valid transactions are determined, they are packed into
a new block and honest participants are rewarded in terms of the
native currency.

To execute a transaction on a Blockchain, a user needs to own
a wallet, that is, a program that interacts with the Blockchain
through transactions. In addition, a wallet must have i) a public
key that serves as a public address to locate the wallet and ii) a
private key that, in combination with the public one, allows one to
create transactions with the wallet.

Several Blockchain support smart contracts, computer programs
stored in the Blockchain and executed within it. Some frame-
works oﬀer simpliﬁed and not Turing-complete programming lan-
guages (e.g., Bitcoin Script) while other ones, such as Ethereum
and EVM-compatible networks, enable general computation on a
Blockchain.

Developers write smart contracts in programming languages de-
veloped ad-hoc such as Solidity and Vyper, or in well-known pro-
gramming languages such as Rust and Javascript. In all these lan-
guages, smart contracts have an object-like structure with a con-
structor, state variables, and functions with their visibility modi-
ﬁers. Smart contracts can also make use of libraries, a particular
type of smart contract that has no internal state but only reusable
functions that can be called from other contracts.

Focusing on Ethereum and EVM-compatible blockchains, once
developers have ﬁnished writing smart contracts and libraries,
their code is compiled into bytecode that is executable by the EVM.
Moreover, a standardized description of the smart contract (or li-
brary) interface, called Application Binary Interface (ABI) is gener-
ated to allow on-chain and oﬀ-chain components to interact with
it.

The deployment of a smart contract and the libraries it uses is
done by sending a transaction to the network that includes the
bytecode. Once the transaction has been accepted, the bytecode
and the contract’s state are stored in the blockchain at a speciﬁc
address, which allows users and other contracts to locate it. Note
that each library is deployed separately from the smart contract
at a diﬀerent address. Smart contracts can also be deleted from
the Blockchain, freeing the storage and receiving a reward as an
incentive for doing that.

The execution of a smart contract does not come for free: every
instruction has a cost (in terms of native currency) that must be
paid to discourage ﬂooding the network (and thus trying to prevent
Denial of Service attacks). Only users can initiate the execution of
contracts by creating a transaction. Within ongoing transactions,
then a smart contract can call other smart contracts.

A Declarative Modelling Framework for the Deployment and Management of Blockchain Applications

MODELS’22, October 2022, Montreal, Canada

2.3 dApps and their Operations
A Blockchain application is often called decentralized application
or dApp. These applications can be grouped into: fully decentral-
ized Applications (f-dApp) and hybrid decentralized applications (h-
dApp). The former deploys all the application logic on-chain and
its only oﬀ-chain component is the frontend/client that is usu-
ally hosted on decentralized storage (e.g., IPFS4). The latter uses
Blockchain components only partially and a subset of the applica-
tion logic is deployed oﬀ-chain (e.g., on a Cloud backend) along
with its frontend.

Many frameworks exist to help developers create dApps: for
example, Truﬄe or Hardhat. Besides overseeing the compilation
of smart contracts, they handle their deployment through scripts
written using imperative programming languages, like Javascript
or Python. These scripts require users to provide a step-by-step
description of the deployment. In particular, one must take into ac-
count: (i) the links between smart contracts and required libraries,
(ii) the deployment order of contracts, and (iii) the connections be-
tween contracts that one can call the others when needed through
their addresses. For example, to deploy smart contracts 𝐴 and 𝐵,
where 𝐴 can call 𝐵 and 𝐵 uses library 𝐿 then the following steps
must be executed: i) link library 𝐿 in 𝐵, ii) deploy 𝐵 and retrieve its
address, iii) deploy 𝐴, and iv) store the address of 𝐵 in 𝐴. Moreover,
when a new version of 𝐵 is deployed, all the steps except for the
third must be (re)executed. This usually requires creating a new
script for the upgrade of each component.

Deployment scripts should also set up the connection to an ac-
tive Blockchain node, i.e., a Blockchain endpoint. This node can be
either self-hosted or provided by so-called node service providers
such as Infura5 or Alchemy6. Users can host Blockchain nodes on a
private server/device using a dedicated node implementation (e.g.,
Geth7). On the one hand, this way they have direct access to the
Blockchain network without any intermediary, on the other they
must maintain the node which could be complex and expensive
(e.g., run security updates, pay for electricity). Using node service
providers is easier but introduces a centralized party and additional
information is required to perform operations (e.g. authentication
with access keys).

Deployment scripts must take into account these diﬀerences,
resulting in an additional complexity to be tackled by develop-
ers. Moreover, users must take into account additional steps for
h-dApps including the deployment and conﬁguration of oﬀ-chain
components and the connection between them and on-chain ones
(e.g., setting in a Cloud backend the address of a smart contract
that is used during an oﬀ-chain computation). None of the exist-
ing development frameworks allows to do so and diﬀerent tools
must be integrated to set up the whole system.

4https://ipfs.io
5https://infura.io
6https://www.alchemy.com
7https://geth.ethereum.org

Figure 1: Pattern Diamond.

2.2 Upgradeable Smart Contracts
When a smart contract is deployed, it is written in the ledger and
cannot be changed anymore. For this reason, in the early days, the
code of a smart contract was considered to be immutable. However,
bug-free code is often a dream, and in the past years, there were
cases of money loss due to errors. This led to the use of well-known
design patterns to create upgradeable smart contracts. While this
collection includes several patterns, they all derive from two im-
portant ones called proxy and diamond.

Pattern proxy [15] places a proxy in front of a contract and all
the requests are received by the proxy and forwarded to the con-
tract. This proxy is nothing but another, simpler, contract with no
application logic. When a new version of a contract is deployed,
the proxy is conﬁgured to forward the requests to it, while users
can keep sending requests to the same proxy.

A pattern that fully exploits this principle is called diamond [24],
also known as multi-facet proxy. The core idea is identical to the
one used in proxy but is extended to enable calls to multiple smart
contracts. Developers deploy i) a proxy-like contract, called dia-
mond, that contains the application state but no logic, ii) a set
of smart contracts, called facets, each of them including a part of
the application logic but no state, and iii) two additional “special”
facets called diamondCut and diamondInit. The former is used to
add and remove facets, while the latter is used by diamondCut to
initialize the diamond’s state whenever its composition (i.e., its
facets) changes. Through a sophisticated delegation mechanism,
contract diamond can call all the functions declared in the facets
which in turn will alter the diamond’s state.

These concepts are exempliﬁed in Figure 1. The diamond con-
tract contains the application state. Users can add a facet (𝑓 𝑎𝑐𝑒𝑡 𝐴
in the ﬁgure) calling function 𝑐𝑢𝑡 (step 1 in the ﬁgure) that ex-
pects the address of a deployed facet and an initial (slice of) state.
This call adds the facet to the application by invoking diamondCut
(steps 2 − 3). diamondCut calls diamondInit that, in turn, updates
the state of the diamond (steps 4 − 5). Assuming that 𝑓 𝑎𝑐𝑒𝑡 𝐴 pro-
vides a function 𝑠𝑒𝑡𝐵 that changes attribute 𝐵 of the application’s
state, users can call function 𝑠𝑒𝑡𝐵 (step 6) on the diamond that del-
egates its execution to 𝑓 𝑎𝑐𝑒𝑡𝐴 (step 7). Finally, 𝑓 𝑎𝑐𝑒𝑡𝐴 state modi-
ﬁcations are reﬂected on the diamond’s state (step 8).

This pattern allows to separate the application logic in multiple
contracts (i.e., facets) that can be added and removed at will. More-
over, the same facets, being stateless, can be reused by multiple
diamonds.

MODELS’22, October 2022, Montreal, Canada

Baresi, Quattrocchi, Tamburri, Terracciano

3 KATENA
KATENA is based on a metamodel that deﬁnes a set of resuable
on- and oﬀ-chain components to model dApps: users create ap-
plication models by instantiating and composing them. Each ele-
ment deﬁnes the characteristics of a component type and the opera-
tions needed to manage its lifecycle (e.g., pre- and post-deployment
logic). The dependencies among components are also part of the
application model and create a dependency graph that constrains
the order in which components are managed. We identiﬁed 5 dif-
ferent dependency types: Library-Library (L-L), Library-Contract
(L-C), Contract-Contract (C-C), Lazy-Contract-Contract (Lazy-C-C),
and Oﬀ-chain-On-chain (O-O).

Library-related dependencies (L-L, L-C). When a library is
used in a smart contract (or in another library), the library address
should be directly embedded in the contract bytecode. Since the
address is not known a-priori (i.e., it will only be known after the
deployment of the library), its bytecode is ﬁlled with placeholders
in place of the addresses. After the deployment of the library, de-
velopers need to replace placeholders with its address.

Contract-related dependencies (C-C, Lazy-C-C). Unlike li-
braries, when a smart contract needs to communicate with another,
the ﬁrst stores the address of the second in a state (or storage) vari-
able. In C-C dependencies the address is passed to the constructor
and the state variable is initialized at contract creation time (i.e.,
when the constructor is called). Lazy-C-C dependencies cover the
case where the association is materialized only when a dedicated
function (e.g., a setter) is called. A pair of smart contracts may be
connected by both a C-C and Lazy-C-C dependencies, in case the
implementation supports both the scenarios. While C-C dependen-
cies impose a strict deployment order since one contract needs the
address of the other at creation time, Lazy-C-C dependencies are
more “dynamic” and the two contracts may be deployed in paral-
lel. However, only when both are successfully deployed the associ-
ation can be materialized through a function call.

Oﬀ-chain-On-chain dependencies (O-O). Oﬀ-chain compo-
nents need two pieces of information to communicate with a smart
contract. The ﬁrst one is a Blockchain endpoint, which does not
create a signiﬁcant dependency since is known beforehand. The
second is the smart contract address, which forces the deployment
of the oﬀ-chain components to be postponed until the deployment
of the smart contracts is completed.

It must be noted that dApp components may use already de-
ployed smart contracts belonging to other applications. We did not
describe these kinds of dependencies herein because they do not
aﬀect the deployment and operations order. However, our meta-
model, described in the following, provides means to model such
associations.

3.1 Metamodel
Figure 2 shows the KATENA metamodel —as UML class diagram.
All attributes are private and their respective getters and setters
are omitted for brevity. All the components are assumed to have
internal methods (not reported for the sake of brevity) that can
handle their lifecycle. They also have constraints between them.
For example, a smart contract A cannot require in its constructor

the address of smart contract B that, in turn, uses A in its construc-
tor. Our prototype (Section 4) implements the lifecycle operations,
checks these constraints and aborts the deployment process if they
are violated.

The diagram, which features the main architectural elements of
f- and h-dApps, is organized around three groups of elements: i)
network and general artefacts, ii) on-chain artefacts, and iii) oﬀ-
chain artefacts.

Network and General Artefacts. These entities model how
applications and users operate on a Blockchain infrastructure. Net-
work is the core (abstract) entity of the group and it is responsible
for providing an entry point for Blockchain interactions and oper-
ations. Subclasses of Network are SelfHostedNode and NodeService-
Provider that cover the two main setups for accessing a Blockchain
network described in Section 2.3. The former provides attributes
host and port that are used to connect to a speciﬁc Blockchain
node. This node could be either part of a public or private EVM-
compatible network (e.g., an owned Ethereum node), or a local de-
velopment environment such as Ganache 8) that provides means
to create a local Blockchain for testing activities. The latter allows
interacting with a Blockchain through a node service provider. It
requires two attributes: the url of the provider, and a secret (e.g, an
access key) for authenticating the user. The user’s wallet is mod-
elled as a separate entity (Wallet) that stores the publicKey and
the privateKey to access the funds and pay for the transactions
required to deploy the smart contracts and manage them (e.g., de-
pendency management).

On-chain Artefacts. These entities model the assets to be de-
ployed on the Blockchain. Their common characteristics are em-
bedded in the abstract class OnChainComponent. This class pro-
vides attributes and associations that are populated at diﬀerent
times: some are known before deployment, others only at speciﬁc
steps of the deployment (e.g., after a contract has been deployed).
Attribute abi is known beforehand since it stores the interface pro-
duced by the smart contract compilation. Attribute bytecode is also
known, but note that it could be subject to updates during the de-
ployment in case of L-L or L-C dependencies. We model these two
dependencies with association useLibrary. OnChainComponent is
deployed and managed on a given Blockchain (association useNet-
work). Association useWallet deﬁnes the wallet in charge of oper-
ating an instance of OnChainComponent.

Entity SmartContract is the basic building block to model
generic smart contracts. Attribute parameters deﬁnes the inputs
to be passed to the contract constructor. Some of these parame-
ters may be addresses of other smart contracts. KATENA models
two cases: i) the address belongs to an external contract already
deployed on the Blockchain (e.g., an integration with another on-
chain application), or ii) a contract of the application to be de-
ployed (Contract-Contract dependency). To model the ﬁrst case,
users must deﬁne association useReferenceInConstructor with an
instance of class SmartContractReference that only contains the ad-
dress of the contract to interface with. The second case impacts the
dependency graph and must be modeled using association useCon-
tractInConstructor with another instance of SmartContract.
8https://truﬄesuite.com/ganache/

A Declarative Modelling Framework for the Deployment and Management of Blockchain Applications

MODELS’22, October 2022, Montreal, Canada

Figure 2: KATENA metamodel.

Attributes destroyFunction and refundAddress help specify the
function that activates contract destruction and the address to send
money (in the native currency), respectively.

SmartContract provides two additional associations: useCon-
tract and UseReference. The former models Lazy-Contract-Contract
dependencies and their management after deployment. The asso-
ciation provides attribute functionName to identify the function
to invoke to set the required address. Similarly, the latter models
the case where the smart contract to be used belongs to an exter-
nal application whose address was not passed as parameter in the
constructor. This association connects the smart contract to an in-
stance of SmartContractReference.

Class Library inherits from OnChainComponent and models li-
braries and their associations with other components. Libraries
do not have a state, a constructor, and they cannot be removed
from the Blockchain. However, as described above, they can be
connected to other components using association useLibrary.

Upgradeable smart contracts are modeled by means of special-
purpose entities. Proxy provides an abstraction of standard ERC-
1967 [26]. Besides the properties inherited from SmartContract, as-
sociation implementation models the reference to the underlying
contract that implements the application logic.

Entity Diamond represents the diamond contract of the omony-
mous pattern. It is connected to instances of facets (entity Facet)
using association useFacet that inherits from useContract and mate-
rializes a Lazy-Contract-Contract dependency. Attribute functions
corresponds to a list of functions that can be called through an
instance of Diamond.

Two dedicated classes are created to properly model the dia-
mond pattern: DiamondCut and DiamondInit. They inherit from
Facet and they are directly linked to Diamond through associations
useCut and useInit, respectively.

Oﬀ-chain Artefacts. Class OﬀChainComponent deﬁnes an ab-
stract oﬀ-chain component of the dApp. Association useNetwork

connects an instance of OﬀChainComponent to a Blockchain net-
work. An oﬀ-chain component can use multiple smart contracts
using association useContract that materializes Oﬀ-chain-On-chain
dependencies.

Components deployed oﬀ-chain require the smart contracts’
ABI to interact with them. This aspect has not been modelled since
ABIs are usually already required during the development of the
oﬀ-chain components and so included already in its source code.

An OﬀChainComponent can be hosted on diﬀerent infrastruc-
tures and may require diﬀerent technologies for its deployment.
To oﬀer a uniﬁed approach for managing diﬀerent infrastruc-
tures, OﬀChainComponent is linked to an abstract OﬀChainNode
by means of association hostedOn. Oﬀ-chain nodes are also special-
ized into DecentralizedStorage for f-dApps and Server for h-dApps.
The Server node is then linked to Credential by means of associa-
tion useCredentials to obtain attribute sshKey required to connect
to the server.

3.2 Deployment and Management
The proposed metamodel allows users to create the application
model of their dApp through the composition of its elements, but it
does not encapsulate the mechanisms to process the entire model.
KATENA supplies two processes to deﬁne how to handle the de-
ployment and management of Blockchain applications. This way,
users work at a higher abstraction level since they are not required
to deﬁne how the deployment should carried out. They just need to
instantiate the components of interest along with their dependen-
cies. Figure 3 shows an object diagram of a dApp that includes all
the types of dependencies discussed at the beginning of Section 3.
It uses a frontend deployed on IPFS, a self-hosted node to connect
to the network, and a wallet to perform deployment transactions.

MODELS’22, October 2022, Montreal, Canada

Baresi, Quattrocchi, Tamburri, Terracciano

on-chain components have been updated, KATENA manages O-O
dependencies by setting, where needed, the addresses of the up-
dated or redeployed on-chain components.

3.3 Usage scenarios
We can now envisage three possible usage scenarios: local device,
private server, and public server.

KATENA can be adopted on a local device (e.g., a personal com-
puter). The keys are held by the application owner (i.e., a single
person) and stored on the device. Wallet keys are never sent to
private or public servers over the internet and therefore, the risk
of malicious attempts to steal them is low. On the other, only one
person can deploy elements.

If we think of a private server, KATENA can be hosted on a pri-
vate server, where a dedicated wallet can be created to store com-
pany funds and its credentials can be saved in a secure part of the
infrastructure. Compared to the case above, this approach enables
a permissioned deployment strategy where only people working
in the company or automated CI/CD pipelines can deploy the ap-
plications.

Finally, the last case is where KATENA is oﬀered as-a-Service,
that is, it is hosted on a public infrastructure and can be used by
many users at the same time. This scenario presents a trade-oﬀ
between security and the ownership of the contract. When a new
contract is deployed, the Blockchain stores the publicKey of the
wallet that initiates the transaction. If the deployment is delegated
to a third-party, the creator of the smart contract cannot be recog-
nized as the “owner” of the contract. The only way for an external
organization to “impersonate” another wallet is to have access to
its private keys.

This leads to two cases. In the ﬁrst, users upload their private
keys to the public platform and KATENA uses them to execute the
transactions for the deployment. This way users remain owners of
their contracts but they have to trust the platform. In the second
case, the platform has its own wallet where users send money to
perform operations. This avoids the disclosing of wallet informa-
tion but they lost contract ownership.

An additional solution is to create contracts with dynamic own-
ership. For example in Ethereum, the standardized Ownable9 con-
tracts allow to change contract ownership with an additional trans-
action (i.e., by invoking a dedicated function). This way, users can
rely on the platform wallet to deploy the contracts without expos-
ing their private keys, and instruct KATENA to perform an addi-
tional transaction after the deployment is completed that changes
the contract ownership to their public address.

4 PROTOTYPE
While the metamodel and processes we deﬁned are technology-
and language-agnostic,
exploited
TOSCA [6] and xOpera, a TOSCA orchestrator to realize a
prototype10.

to assess KATENA, we

TOSCA is a well-known standard language for modelling cloud
applications and infrastructures —that is, for specifying oﬀ-chain
components— in the form of YAML speciﬁcations. Its main entity

9https://eips.ethereum.org/EIPS/eip-2767
10Source code and experiments at: https://zenodo.org/badge/latestdoi/472717537.

Figure 3: An instance of KATENA metamodel.

The ﬁrst process deﬁnes the deployment of a Blockchain appli-
cation. It starts by setting up the connections with the on- and oﬀ-
chain infrastructures using subclasses of Network and OﬀChainN-
ode, respectively. Then, it creates the dependency graph by travers-
ing the relevant associations in the metamodel (e.g., useContract-
InConstructor, useLibrary). This graph is then used to oversee the
deployment of components, starting from those without dependen-
cies to the ones that use them, recursively, until all the dependen-
cies are satisﬁed.

First, KATENA deploys libraries with no dependencies (e.g., li-
brary 𝑚𝑎𝑡ℎ in the ﬁgure), and their address is retrieved. Then, these
addresses are used to solve all the L-L dependencies (e.g., between
libraries 𝑢𝑡𝑖𝑙𝑠 and 𝑚𝑎𝑡ℎ).

After libraries, KATENA deploys smart contracts starting with
the ones with no dependencies, followed by the ones with only
C-L dependencies (e.g., contract 𝑎𝑑𝑚𝑖𝑛), and ﬁnally, with contract-
related dependencies (e.g., contract 𝑒𝑣𝑒𝑛𝑡𝑠) until all on-chain com-
ponents are deployed. After that, Lazy-C-C dependencies (e.g., be-
tween contracts 𝑡𝑖𝑐𝑘𝑒𝑡𝑠 and 𝑎𝑑𝑚𝑖𝑛) are solved and the setup of
the smart contracts is completed. Once all smart contracts are de-
ployed, KATENA instantiates oﬀ-chain components, by exploiting
the required information to interact with on-chain components,
that is, Blockchain endpoint, and the contract addresses.

The second process is dedicated to managing and upgrading de-
ployed components, activities that may require redeploying exist-
ing components. KATENA ﬁrst identiﬁes the node to be replaced
and initiates the deployment of its upgraded version. If the compo-
nent is a library, KATENA solves L-L and L-C dependencies. In both
cases, since these components do not provide ways to change the
dependency dynamically, KATENA automatically deploys again
the dependent libraries and smart contracts by replacing in their
bytecode the old address with the one of the upgraded library. Af-
ter that (or if the new component is a smart contract), Lazy-C-C
and C-C dependencies are managed. In the ﬁrst case, KATENA sim-
ply calls the deﬁned function to update the dependency. In the sec-
ond one, the smart contract must be redeployed so that the address
of the upgraded library is properly passed to its constructor. Once

A Declarative Modelling Framework for the Deployment and Management of Blockchain Applications

MODELS’22, October 2022, Montreal, Canada

type, called node, is used to model programming and computa-
tional elements, such as executables, middleware infrastructures,
and physical or virtual computing resources. A node has proper-
ties and attributes. The former are values provided by users used
to create a node instance, while the latter are values that are set
by the orchestrator during the deployment or operation of the
node. One can also deﬁne some requirements, that is, a set of re-
lationships that must be satisﬁed before the node can be created.
A relationship is a link between two nodes that allow them to ac-
cess the other node’s properties and attributes. Relationships are
directed edges and they have properties and attributes. TOSCA dis-
tinguishes between node/relationship types (i.e., blueprints) and
instances. Both nodes and relationship types can inherit from al-
ready deﬁned types to increase re-usability. Both nodes and rela-
tionships have an associated interface that deﬁnes a sequence of
lifecycle operations. Each operation can be paired with scripts that
are executed at proper time through Ansible11, a well-known en-
gine that automates the conﬁguration and deployment of applica-
tions.

We materialized the metamodel and processes as a set of
reusable TOSCA types and interfaces. Users deﬁne application
models in the form of TOSCA speciﬁcations and no code gener-
ation is involved.

The prototype supports any EVM-compatible Blockchain, the
creation of “plain” smart contracts along with proxies, and ones
that use the diamond pattern. Moreover, the prototype can man-
age all the ﬁve types of dependencies described in Section 3. We
materialized each element of the metamodel as either a node or a
relationship type derived from the standard “root” types of TOSCA.
xOpera supports these types and automates their management.

In particular, while mapping our metamodel, we deﬁned node
types for entitiesWallet, Network, SelfHostedNode, SmartContract,
SmartContractReference, Proxy, Diamond, and DiamondCut. Each
of them was provided with properties and attributes. Moreover,
we implemented lifecycle operations of each node type by deriving
them from type tosca.interfaces.node.lifecycle.Standard.
This interface provides some standardized phases that can be fully
customized according to the application domain and they are sup-
ported by xOpera. We linked each phase we support to Ansi-
ble scripts that invoke Python programs, which, in turn, inter-
act with the selected EVM-compatible Blockchain through library
Web3.py12.

As an example, node type katena.nodes.library deﬁnes prop-
erties abi and attributes bytecode (generated by KATENA after
the compilation of the smart contract) and address (retrieved by
KATENA after the deployment). This type supports the standard
phases: i) create compiles and generates the library bytecode, and
ii) configure deploys the library on a selected Blockchain.

KATENA also deﬁnes a set of relationship types that ma-
terialize all the associations deﬁned in its metamodel. Node
types deﬁne how relationships are used by means of require-
ments. For example node type katena.nodes.smartcontract
type
comprises its requirements a set of relationships of

11https://www.ansible.com/
12https://web3py.readthedocs.io/en/stable/

katena.relationships.useContractInConstructor
port dependencies of type Contract-Contract.

to sup-

The lifecycle of a relationship is standardized in TOSCA
by type tosca.interfaces.relationship.Configure that we
employed in our implementation. As an example, relation-
ship katena.relationships.useFacet provides a property ex-
clude of type list that deﬁnes the function names of a dia-
mond facet that should not be callable by a diamond. More-
lifecycle phases:
over,
post_configure_source that
is activated when the source
node (i.e., a katena.nodes.smartcontract) completes phase
configure, and remove_target activated when the target node
(i.e., a katena.nodes.smartcontract)
is removed from the
Blockchain.

implements (using Ansible scripts)

it

The deﬁnition and the orchestration of the lifecycle phases of
both KATENA node and relationship types are the key contribu-
tions of the prototype. They allow for i) properly resolving the
ﬁve types of dependencies captured by our metamodel, ii) imple-
menting the deployment process described in Section 3.2, and iii)
reducing users’ eﬀort in deﬁning deployment models. In particular,
users just need to create instances of KATENA node types and con-
nect them with proper relationships. The actual deployment and
management operations are hidden in the node/relationship logic
and executed “behind the scenes” by xOpera.

Oﬀ-chain components (e.g., cloud infrastructures) are widely
supported in TOSCA and they can be easily mapped with the
Oﬀ-chain Artefacts entities deﬁned in the metamodel. Moreover,
thanks to the relationships we deﬁned, existing TOSCA node types
(e.g., tosca.nodes.Container.Application13 for containerized
applications) can be easily mixed with newly deﬁned on-chain
ones.

4.1 Example Scenario
Figure 4 provides an examplar KATENA ﬁle. The ﬁle deﬁnes the
deployment model of a simple dApp about on-chain voting that
is composed of a library, two smart contracts, and a containerized
backend. At lines 1-2 node instance ethereum is deﬁned with node
type katena.nodes.network.ethereum that implements an en-
trypoint for the Ethereum Blockchain (a subclass of metamodel’s
entity SelfHostedNode), the network where the smart contracts will
be deployed. The user wallet is deﬁned at lines 3-6. This node in-
stance uses type katena.nodes.wallet (entity Wallet) and pro-
vides property privateKey which value is read from an external
input ﬁle (omitted for brevity) using the TOSCA get_input syn-
tax.

Lines 7-13 declare the library (type katena.nodes.library.
mathLib) that provides property abi, and deﬁnes two require-
ments: i) useNetwork to deploy the application on Ethereum, and
ii) useWallet to set userWallet as source of transactions and
funds for the deployment. Lines 14-25 deﬁne votingContract, the
main smart contract (type katena.nodes.smartcontract) of the
application. In addition to useNetwork and useWallet, it provides
two requirements: i) useLibrary (type katena.relationships.
useLibrary) that implements an L-C dependency with mathLib,
and ii) useContractInContructor that materializes a C-C

13https://github.com/openstack/tosca-parser/blob/master/toscaparser/elements

MODELS’22, October 2022, Montreal, Canada

Baresi, Quattrocchi, Tamburri, Terracciano

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40

ethereum :

type : katena . nodes . network . ethereum

userWallet :

type : katena . nodes . wallet
properties :

privateKey : { get_input : UserKeyEthere um }

mathLib :

type : katena . nodes . library
requirements :

- useNetwork : ethereum
- useWallet : userWallet

properties :

abi : " MathImpl "

votingContra ct :

type : katena . nodes . smartcontract
requirements :

- useNetwork : ethereum
- useWallet : userWallet
- useLibrary : mathLib
- u s e C o n t r a c t I n C o ns t ru ct o r: r a n d o m G e n e r a t o r C on t ra c t

properties :

abi : " Voting "
parameters :

- 100
- 0.1

r a n d o m G e n e r a t o r C o nt ra c t:

type : katena . nodes . smartcontract
requirements :

- useNetwork : ethereum
- useWallet : userWallet
- useLibrary : mathLib

properties :

abi : " RandomGenera to r "

backend :

type : tosca . nodes . Container . Application
requirements :

- dependency :

node : votingContra ct
relationship : useContract

...

Figure 4: An exemplar KATENA deployment model.

dependency with contract randomGeneratorContract. More-
over, contract votingContract deﬁnes two properties: abi and
parameters for calling its constructor.

Similarly lines 26-33 declare smart contract randomGenerator-
Contract which will be deployed before votingContract given
the C-C dependency that connects them. Finally, lines 34−40 deﬁne
the dApp backend (details omitted for brevity). This node instance
inherits from type tosca.nodes.Container.Application, an ex-
isting TOSCA type. Given that the backend must interface with
contract votingContract (O-O dependency), the node instance
deﬁnes a dedicated requirement. In this case, the connection is
materialized through relationship dependency, a generic associa-
tion between two TOSCA node instances. TOSCA allows specify-
ing the type of this relationship and target node using sub-ﬁelds
relationship and node respectively.

5 EVALUATION
To assess the feasibility and beneﬁts of KATENA, we modelled and
deployed three real-world Blockchain applications covering a suf-
ﬁciently diverse set of control factors including: size (in terms of
source lines of code or SLOC), used design patterns, number of
smart contracts, complexity (measured as number of contracts de-
pendencies), application domain. These three applications are: i)

Application
ENS
DYDX
Dark Forest

Contracts
4
28
16

L-L
0
0
4
Table 1: Used applications.

C-C
4
21
1

C-L
0
2
13

Lazy-C-C
0
10
9

Ethereum Name Service14 (ENS), a decentralized DNS system run-
ning on Ethereum, ii) DYDX 15, a well-known Ethereum platform
for decentralized ﬁnance, and iii) Dark Forest16, a videogame de-
ployed on Ethereum. Table 1 shows control factors mapping onto
the observed cases, and shows, for each application, the number of
smart contracts and the number of dependencies divided by type.
On the one hand, the modelling itself of these three applications
accounts for the completeness of our modelling notation in ad-
dressing the domains covered by the target cases. On the other
hand, we performed a comparative analysis to show the diﬀer-
ences between KATENA and state-of-the-art solutions; said com-
parative analysis features mixed-methods research [7]. Note that
this evaluation focused on the deployment phase and on on-chain
components since i) management scripts were not included in the
analyzed application repositories, and ii) oﬀ-chain components are
not public and we could not ﬁnd information about them (backend
logic and components are usually not public). To perform the afore-
mentioned comparative analysis, we compared KATENA against
two popular Ethereum development and operation frameworks,
namely, Truﬄe and Hardhat. These technologies relate directly to
the observed cases in this study; speciﬁcally, ENS and Dark Forest
implement their deployment logic with Hardhat, while DYDX uses
Truﬄe.

5.1 Metrics and Experimental setup
The main objective of this evaluation is to compare KATENA
against state-of-the-art solutions. Our focus is on the ease of use
of our approach and the required eﬀort to deﬁne operation activ-
ities. Many metrics [11, 25] have been proposed to evaluate the
readability and complexity of code but, to the best of our knowl-
edge, none of them is applicable to both declarative and impera-
tive languages. Most of the metrics focus on imperative constructs
like nesting structures, conditional and error handling statements
that are not present, by design, in declarative languages. Thus, we
decided to evaluate the beneﬁts of our approach by measuring the
Number of Tokens (NoT), that is, the “words” in a ﬁle. In doing so we
included programming language keywords, removed commented
lines and lines with log commands, and considered symbol “.” as a
token separator (e.g., statement contract.deploy() contains two
tokens). Using this metric it is possible to estimate the eﬀort prac-
titioners should employ in writing deployment and management
scripts [25], and, thus, to fairly compare KATENA against state-of-
the-art solutions.

We also considered other metrics, such as Lines of Code (LoC) or
the number of characters in a ﬁle, but the comparison would have
not been balanced for the syntax and structural characteristics of
the languages employed. It is well-known that metric LoC does

14https://github.com/ensdomains/ens
15https://github.com/dydxprotocol/solo
16https://github.com/darkforest-eth/eth

A Declarative Modelling Framework for the Deployment and Management of Blockchain Applications

MODELS’22, October 2022, Montreal, Canada

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

1
2
3
4
5
6
7
8
9
10
11
12
13
14

KATENA

ensRegistry :

type : katena . nodes . smartcontract
requirements :

- useNetwork : ganache
- useWallet : userWallet

properties :

abi : " ENSRegistry "

publicResolv er :

type : katena . nodes . smartcontract
requirements :

- useNetwork : ganache
- useWallet : userWallet
- u s e s C o n t r a c t I n C on s tr u ct o r: ensRegistry

properties :

abi : " PublicResolve r "
parameters :

- "0 x 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 00 0 0 00 0 0 00 0 00 0 0"

Hardhat

const hre = require ( " hardhat " );
const ethers = hre.ethers;
const AD0 = " 0 x 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 00 0 0 00 0 00 0 0 00" ;
async function main () {
const ENSRegistry =

await e t h e r s . g e t C o n t r a c t Fa c to r y( " ENSRegistry ")

const PublicResolve r =

await e t h e r s . g e t C o n t r a c t Fa c to r y( " PublicResolve r " )

const ens = await E N S R e g i s t r y . d e pl o y()
await ens.deployed ()
const resolver =

await P u b l i c R e s o l v e r . d ep l oy( ens.address , AD0 );

await resolver.de pl oy ed ()

}

Figure 5: Deployment of ENS.

not represent a signiﬁcant measure of the size and complexity of
a program [3]. Moreover, KATENA ﬁles are structured on multiple
and short lines, while scripts adopted by the other solutions tend
to include long and complex statements on single lines. The num-
ber of characters is not a fair metric too since it is tightly coupled
with the programming language keywords and used naming con-
ventions, which would penalize the competitor solutions.

We performed the deployment of the applications on the
Ganache local Blockchain for both KATENA and competitors. For
KATENA orchestration, we used a local xOpera installation.

5.2 Evaluation Results and Discussion

The Ethereum Name Service is widely used, with over 465K ENS
names registered and 180K of them active [32]. It is composed of
four contracts that are used to register the DNS domain along with
its owner, and to provide additional features such as subdomains.
Its architecture is quite simple, it provides three Contract-Contract
relationships between the core registry, named ENSRegistry, and
the three others. Figure 5 shows a comparison between Hardhat
and KATENA on the implementation of one of these relationships
(between contract PublicResolver and ENSRegistry).

KATENA implements the relationship with requirement callsIn-
Constructor included in the publicResolver TOSCA node allowing
the orchestrator to understand the dependencies between the two
contracts and deploy them one after the other (and not in parallel).
In Hardhat, this is implemented as a sequence of asynchronous

calls (using syntax async/await) and through an imperative par-
adigm. While in KATENA the dependencies are explicitly declared
easing the understanding of the app structure, in Hardhat this only
emerges from the semantic of code and the actual dependencies are
“hidden” within the complexity of the rest of the code.

The NoT comparison shows that KATENA deployment ﬁle is
composed of 87 tokens, slightly lower than the 95 of Hardhat.
While the quantitative improvement is small, qualitatively it can
be observed that KATENA provides a higher-level approach to the
deployment and management of smart contracts. It abstracts away
the complexity of the instructions needed to enact the operations,
only requires users to prompt simple inputs, and rely on the or-
chestrator to automate the whole process. In Hardhat, users must
do two tasks at the same time: deﬁning the dependencies among
contracts and the instructions needed for the deployment, which
require dealing with complex asynchronous code, error handling,
and more.

DYDX is one of the largest exchanges for cryptocurrencies17
and it employs 28 smart contracts with the following dependencies:
2 Contract-Library, 21 Contract-Contract, and 10 Lazy-Contract-
Contract dependencies. Compared to ENS, DYDX uses Truﬄe
for its operation and the code is, generally, much more complex
given the higher amount of contracts and dependencies. Notably,
KATENA showed a signiﬁcant improvement compared to Truﬄe
in our quantitative evaluation. Our solution led to a reduction of
39.5% of NoT with 559 tokens against 923 of the original script. This
highlights that as the complexity of operations increases, KATENA
appears to achieve a larger reduction in the eﬀorts required to
write the scripts. Once again, this can be intuitively explained by
the more abstract and orchestration-driven approach of KATENA
that signiﬁcantly simpliﬁes the deployment and management pro-
cess.

Lastly, Dark Forest uses Hardhat for its operation, and it is
composed of 5 libraries and 11 smart contracts. Two signiﬁ-
cant characteristics of this application are the usage of the Dia-
mond pattern and Library-Library dependencies. Figure 6 shows
the diﬀerence in constructing a diamond using the two ap-
proaches. Users of KATENA can create diamonds with ad-hoc
types (katena.nodes.diamond) and requirements (useCut and
useFacet) which, behind the scenes, automate the wiring of the
dependencies and instruct the orchestrator on the instructions to
execute. On the other hand, Hardhat users must deal with complex
operations “manually”, and the resulting code does not allow them
to simply understand the structure of the application (as shown in
the ﬁgure).

The NoT comparison provides objective evidence for this intu-
ition showing a reduction of 82.7% of tokens (304 vs 1765 tokens)
when users employ KATENA instead of Hardhat. This result shows
that while state-of-the-art solutions do not scale well with opera-
tion complexity (i.e., the code to execute them becomes not only
longer but also more complex), KATENA allows for writing rela-
tively simple scripts that automate these complex processes. This
not only reduces user eﬀorts but also makes deployment and man-
agement scripts more readable, more maintainable, and less error-
prone.

17http://tiny.cc/forbes-crypto

MODELS’22, October 2022, Montreal, Canada

Baresi, Quattrocchi, Tamburri, Terracciano

1
2
3
4
5
6
7
8
9
10
11

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

KATENA

diamondCut :

type : katena . nodes . smartcontract
...

diamondLoupe :

type : katena . nodes . diamond . facet
...
diamond :

type : katena . nodes . diamond
requirements :

- useCut : diamondCut
- useFacet : diamondLoupe

Hardhat

const diamondCutFac et = await d e p l o y D i a m o n d C u t Fa ce t() ;
const loupeFacet = await deployLoupeF ac et () ;
const d i a m o n d S p e c F a ce t Cu ts = [
... c h a n g e s . g e t F a c et C ut s( ' LoupeFacet ' , loupeFacet ) ,
];
const diamond = await deployDiamond (

{

ownerAddress ,
d i a m o n d C u t A d dr es s : diamondCutFacet. ad dre ss ,

} , ...) ;

const initTx = await d i a m o n d C u t . d i a mo nd C ut(

diamondSpecFacetCuts ,
...) ;

const initReceipt = await initTx.wait () ;
if (! i n i t R e c e i p t . s ta tu s) {

throw Error (` Diamond cut failed `) ;

}

Figure 6: Diamond pattern used for Dark Forest.

5.3 Threats to validity
We conducted the experiments using three real-world applications
showing the advantages of KATENA compared to state-of-the-art
solutions. However, we must highlight threats that may constrain
the validity of obtained results [29].

Internal threats. The experiments were conducted using Gana-
che as target Blockchain. While Ganache is meant to only be used
for development purposes, it implements the behavior of the EVM
and therefore we do not expect any signiﬁcant change in the behav-
ior of KATENA when used in production-ready Blockchains. The
only practical diﬀerence is the cost of transactions (in Ganache
transactions are free while on a real Blockchain they can be ex-
pensive18). However, it must be noted that KATENA generates the
same transactions (and same deployments) as competitors, thus
cost does not represent a critical factor.

External threats. Our quantitative evaluation is based on the
NoT metric. This metric approximates the user eﬀort required to
write deployment scripts and can be subject to errors. To the best of
our knowledge there is no other metric in the literature that could
have allowed us to compare declarative and imperative languages.
To mitigate this factor, we analyzed KATENA and its competitors
with a qualitative approach ﬁrst, and only used the quantitative
measurements to conﬁrm our conjectures.

6 RELATED WORK
The automation of operations [31] [4] is a well-known problem
addressed by academia and industry but its application to the

18https://tinyurl.com/bored-ape-eth-costs

Blockchain is at its early stages. Industrial approaches, such as
Truﬄe and Hardhat, have tackled the problem by requiring users
to write imperative ad-hoc scripts tailored for each application.

Van den Heuvel et al [28] are the ﬁrst ones to foresee the need
for operations in Blockchain applications, proposing a preliminary
architecture of a low-code platform to facilitate the development
and deployment of Smart Contracts that focuses on the entire de-
velopment process. Compared to KATENA, they only provide an
abstract pipeline for the development and operation of Blockchain
applications without any sort of implementation. Moreover, they
mostly focus on the development phase (i.e., helping users write
the application logic), while KATENA focuses only on deployment
and management of existing applications.

Knecht et al [20] propose a tool that performs automated
analysis on Blockchain applications. The approach automatically
searches for bugs, evaluates the code quality, and veriﬁes proper-
ties using formal logic. We consider this work complementary to
KATENA and could enhance the automation features provided by
our solution.

If we focus on the operation of Blockchain applications, to the
best of our knowledge, KATENA is the ﬁrst comprehensive solu-
tion that provides: i) a declarative approach to deﬁne Blockchain
applications by employing a metamodel, ii) dedicated activities to
handle application deployment and runtime management, and iii)
a usable implementation that extends standard tools. Other exist-
ing approaches focus on the modelling of smart contracts but they
do not tackle their operation speciﬁcally as KATENA. For exam-
ple, Jiao et al [19] propose a semantic modelling framework for
smart contracts aimed to ﬁnd security vulnerabilities through for-
mal veriﬁcation. Other solutions [16][27] propose model-driven
approaches to automate the generation of the source code of the
smart contract.

Several solutions have been developed to support the deploy-
ment and evolution of complex software systems with model-
driven approaches, covering the deployment and runtime manage-
ment in a wide range of domains (but not Blockchain applications).
For example, some approaches used existing [9] speciﬁcation lan-
guages or developed new ones [18][5] to model cloud deployments.
Liu et al [22] address a speciﬁc type of architecture called Cloud
Data Architectures, modelling the applications in a data-centric
perspective. In this work, cloud resources are modelled as struc-
tured data, oﬀering the possibility of conﬁguring and executing
operations through a declarative language.

All these approaches use either textual or graphical declarative
languages to increase usability and reduce error-proneness. Some
of the design choices we made in KATENA were inspired by these
research eﬀorts.

7 CONCLUSIONS AND FUTURE WORK
The paper presents KATENA, a declarative framework for the de-
ployment and management of Blockchain applications. It provides
a metamodel to represent an application with components de-
ployed both on- and oﬀ-chain, facilities to model recurring design
patterns, and deﬁnes required processes. We implemented a proto-
type of KATENA that builds on TOSCA and xOpera. Our evaluation

A Declarative Modelling Framework for the Deployment and Management of Blockchain Applications

MODELS’22, October 2022, Montreal, Canada

[19] Jiao Jiao, Shang-Wei Lin, and Jun Sun. 2020. A Generalized Formal Semantic
Framework for Smart Contracts. In Fundamental Approaches to Software Engi-
neering (Lecture Notes in Computer Science, Vol. 12076). Springer, 75–96.

[20] Markus Knecht and Burkhard Stiller. 2017. SmartDEMAP: A Smart Contract
Deployment and Management Platform. In Proceedings of the Security of Net-
works and Services in an All-Connected World - International Conference on Au-
tonomous Infrastructure, Management, and Security (Lecture Notes in Computer
Science, Vol. 10356). Springer, 159–164.

[21] Leslie Lamport, Robert E. Shostak, and Marshall C. Pease. 2019. The Byzantine
generals problem. In Concurrency: the Works of Leslie Lamport. ACM, 203–226.
[22] Yun Mao, Changbin Liu, Jacobus E. van der Merwe, and Mary F. Fernández. 2011.
Cloud Resource Orchestration: A Data-Centric Approach. In Proceedings of the
Conference on Innovative Data Systems Research. CIDRDB, 241–248.

[23] Joanna Moubarak, Eric Filiol, and Maroun Chamoun. 2018. On blockchain secu-
rity and relevant attacks. In Proceedings of the IEEE Middle East and North Africa
Communications Conference. IEEE, 1–6.

[24] Nick Mudge. 2020. EIP-2535: Diamonds, Multi-Facet Proxy.
[25] Stefano Dalla Palma, Dario Di Nucci, Fabio Palomba, and Damian Andrew Tam-
burri. 2020. Toward a catalog of software quality metrics for infrastructure code.
Journal of Systems and Software 170 (2020), 110726.

[26] Francisco Giordano Santiago Palladino. 2019. EIP-1967: Standard Proxy Storage

Slots.

[27] Marek Skotnica, Jan Klicpera, and Robert Pergl. 2020. Towards model-driven
smart contract systems–code generation and improving expressivity of smart
contract modeling. In Proceedings of the CEUR Workshop. CEUR-WS.org, 1–15.

[28] Willem-Jan van den Heuvel, Damian Andrew Tamburri, Damiano D’Amici, Fabi-
ano Izzo, and Sandra Potten. 2021. ChainOps for Smart Contract-Based Dis-
tributed Applications. In Proceedings of the International Symposium of Business
Modeling and Software Design (Lecture Notes in Business Information Processing,
Vol. 422). Springer, 374–383.

[29] Claes Wohlin, Martin Höst, and Kennet Henningsson. 2006. Empirical Research
Methods in Web and Software Engineering. In Web Engineering. Springer, 409–
430.

[30] Kaidong Wu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2021. A ﬁrst look at
blockchain-based decentralized applications. Software: Practice and Experience
51, 10 (2021), 2033–2050.

[31] Michael Wurster, Uwe Breitenbücher, Michael Falkenthal, Christoph Krieger,
Frank Leymann, Karoline Saatkamp, and Jacopo Soldani. 2020. The essential
deployment metamodel: a systematic review of deployment automation tech-
nologies. Software-Intensive Cyber-Physical Systems 35, 1-2 (2020), 63–75.
[32] Pengcheng Xia, Haoyu Wang, Zhou Yu, Xinyu Liu, Xiapu Luo, and Guoai
Xu. 2021. Ethereum Name Service: the Good, the Bad, and the Ugly. arXiv
abs/2104.05185 (2021).

[33] Robert K. Yin. 2008. Case Study Research: Design and Methods (Applied Social

Research Methods) (fourth ed.). Sage Publications.

[34] Gavin Zheng, Longxiang Gao, Liqun Huang, and Jian Guan. 2021. Upgradable

Contract. Springer, 197–213.

shows that KATENA leads to a signiﬁcant (up to 82.7%) reduction
in code writing compared to state-of-the-art approaches.

Our future work comprises the extension of the metamodel to
support more design patterns and components. We will also em-
pirically assess how KATENA reduces the required time to write
deployment scripts compared to state-of-the-art solutions.

8 ACKNOWLEDGEMENTS
Luca Terracciano has been supported by project ICT4Dev, funded
by the Italian Agency for Development Cooperation. Luciano
Baresi and Giovanni Quattrocchi have been partially supported
by SISMA national research project (MIUR, PRIN 2017, Contract
201752𝐸𝑁 𝑌 𝐵).

REFERENCES
[1] Maher Alharby, Amjad Aldweesh, and Aad Van Moorsel. 2018. Blockchain-based
smart contracts: A systematic mapping study of academic research (2018). In
Proceedings of the International Conference on Cloud Computing, Big Data and
Blockchain. IEEE, 1–6.

[2] Muddasar Ali and Sikha Bagui. 2021. Introduction to NFTs: the future of digital
collectibles. International Journal of Advanced Computer Science and Applications
12, 10 (2021), 50–56.

[3] Marvin Muñoz Barón, Marvin Wyrich, and Stefan Wagner. 2020. An Empirical
Validation of Cognitive Complexity as a Measure of Source Code Understand-
ability. In Proceedings of the International Symposium on Empirical Software En-
gineering and Measurement. ACM, 5:1–5:12.

[4] James O. Benson, John J. Prevost, and Paul Rad. 2016. Survey of automated soft-
ware deployment for computational and engineering research. In Proceedings of
the IEEE International Systems Conference. IEEE, 1–6.

[5] Alexander Bergmayr, Javier Troya, Patrick Neubauer, Manuel Wimmer, and
Gerti Kappel. 2014. UML-based Cloud Application Modeling with Libraries,
Proﬁles, and Templates. In Proceedings of the International Workshop on Model-
Driven Engineering on and for the Cloud (CEUR Workshop Proceedings, Vol. 1242).
CEUR-WS.org, 56–65.

[6] Tobias Binz, Uwe Breitenbücher, Oliver Kopp, and Frank Leymann. 2014.
TOSCA: Portable Automated Deployment and Management of Cloud Applica-
tions. In Advanced Web Services. Springer, 527–549.

[7] Maura Borrego, Elliot P. Douglas, and Catherine T. Amelink. 2009. Quantitative,
Qualitative, and Mixed Research Methods in Engineering Education. Journal of
Engineering Education 98 (2009), 53–66.

[8] Marco Brambilla, Jordi Cabot, and Manuel Wimmer. 2012. Model-Driven Soft-
ware Engineering in Practice. Synthesis Lectures on Software Engineering, Vol. 1.
Morgan & Claypool.

[9] Gerd Breiter, Michael Behrendt, Manish Gupta, Simon Daniel Moser, Ruediger
Schulze, Isabell Sippli, and Thomas Spatzier. 2014. Software deﬁned environ-
ments based on TOSCA in IBM cloud implementations. IBM Journal of Research
and Development 58, 2/3 (2014), 9:1–9:10.

[10] Vitalik Buterin. 2013. Ethereum White Paper: A Next Generation Smart Contract

& Decentralized Application Platform.

[11] G. Ann Campbell. 2018. Cognitive complexity: an overview and evaluation. In
Proceedings of the International Conference on Technical Debt. ACM, 57–58.

[12] Chainlist. 2022. A list of EVM networks. https://chainlist.org
[13] Yan Chen and Cristiano Bellavitis. 2020. Blockchain disruption and decentral-
ized ﬁnance: The rise of decentralized business models. Journal of Business Ven-
turing Insights 13 (2020), e00151.

[14] Thomas Durieux, João F. Ferreira, Rui Abreu, and Pedro Cruz. 2020. Empirical
review of automated analysis tools on 47,587 ethereum smart contracts. In Pro-
ceedings of the International Conference on Software Engineering. ACM, 530–541.
[15] Erich Gamma, Richard Helm, Ralph Johnson, and John M. Vlissides. 1994. De-
sign Patterns: Elements of Reusable Object-Oriented Software (ﬁrst ed.). Addison-
Wesley Professional.

[16] Péter Garamvölgyi, Imre Kocsis, Benjamin Gehl, and Attila Klenik. 2018. To-
wards Model-Driven Engineering of Smart Contracts for Cyber-Physical Sys-
tems. In Proceedings of the International Conference on Dependable Systems and
Networks Workshops. IEEE Computer Society, 134–139.

[17] Petri Helo and Yuqiuge Hao. 2019. Blockchains in operations and supply chains:
A model and reference implementation. Computers & Industrial Engineering 136
(2019), 242–251.

[18] Saddam Hocine Hiba and Meriem Belguidoum. 2019. AutoCADep: An Ap-
proach for Automatic Cloud Application Deployment. In International Confer-
ence on Service-Oriented Computing Workshops (Lecture Notes in Computer Sci-
ence, Vol. 12019). Springer, 82–94.

