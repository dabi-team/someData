Author pre-print.
The ﬁnal publication is available at: https://doi.org/10.1007/s10270-022-01054-5.

Software and System Modeling manuscript No.
(will be inserted by the editor)

Real-time Collaborative Multi-Level Modeling by
Conﬂict-Free Replicated Data Types

Istvan David ⋅ Eugene Syriani

2
2
0
2

t
c
O
2
1

]
E
S
.
s
c
[

3
v
3
0
3
1
1
.
5
0
2
2
:
v
i
X
r
a

Received: date / Accepted: date

Abstract The need for real-time collaborative solu-
tions in model-driven engineering has been increasing
over the past years. Conﬂict-free replicated data types
(CRDT) provide scalable and robust replication mecha-
nisms that align well with the requirements of real-time
collaborative environments. In this paper, we propose a
real-time collaborative multi-level modeling framework
to support advanced modeling scenarios, built on a col-
lection of custom CRDT, speciﬁcally tailored for the
needs of modeling environments. We demonstrate the
beneﬁts of the framework through an illustrative mod-
eling case and compare it with other state-of-the-art
modeling frameworks.

Keywords Collaborative modeling, Real-time collab-
oration, Multi-level modeling, Conﬂict-free replicated
data types, Model-driven engineering

1 Introduction

Collaborative Model-Driven Software Engineering (MDSE)
[44] aims to establish a sound interplay between phys-
ically distanced stakeholders by combining the tech-
niques of collaborative software engineering [66] and
model-driven techniques [50]. Recent systematic stud-
ies [17, 28] report a substantial shift towards real-time
collaboration in MDSE. While real-time collaborative
MDSE opens up many opportunities, it also gives rise
to unique challenges, primarily: ensuring appropriate
convergence of distributed data, while still guarantee-
ing timely execution [55].

Optimistic replication has been suggested by Saito
and Shapiro [49] as a possible treatment, in which the

local replicas of stakeholders are allowed to diverge tem-
porarily. This divergence is admissible due to eventual
consistency mechanisms [65] ensuring that each remote
change will be observed by every stakeholder eventu-
ally and replicas converge. Strong eventual consistency
(SEC) [45] augments eventual consistency with a safety
guarantee: two replicas that have received the same set
of change updates will be in the same state, regard-
less of the order of updates. Although SEC aligns well
with the requirements of real-time collaborative MDSE
settings, it is not trivial to implement correctly [23].

Conﬂict-free Replicated Data Types (CRDT) have
been suggested by Shapiro et al. [52] as a scalable im-
plementation of SEC. CRDT have been traditionally
geared to support linear data, such as text. Since tradi-
tional software engineering relies on textual artifacts to
persist source code, mechanisms of real-time collabora-
tive textual editors can address the main challenges of
real-time collaborative source code development. How-
ever, MDSE relies on richer data types, such as multi-
graphs, that are also potentially disconnected. Thus,
CRDT cannot eﬃciently accommodate models as ﬁrst-
class citizens. Existing solutions either (i) focus exclu-
sively on textual modeling and reduce collaboration to
textual primitives which are well-supported by current
CRDT frameworks [48]; or (ii) work on models of lim-
ited complexity and do not support proper graph se-
mantics at the data level [25]. As a consequence, cur-
rent CRDT-based techniques fall short of supporting
intricate modeling scenarios.

Such an intricate modeling scenario is multi-level
modeling (MLM) [4]. MLM attempts to overcome the
limitations of traditional modeling architectures, such
as the OMG’s Meta-Object Facility (MOF)1 [5, 6, 30],

DIRO – Université de Montréal, Canada, E-mail:
van.david@umontreal.ca, syriani@iro.umontreal.ca

ist-

1

https://www.omg.org/mof/

Author pre-print. The ﬁnal publication is available at: https://doi.org/10.1007/s10270-022-01054-5.

 
 
 
 
 
 
2

I. David and E. Syriani

stemming from their restricted, two-level meta-modeling
approach. While two meta-layers might be enough for
simple modeling cases, such architectures fail to sup-
port scenarios in which diﬀerent kinds of conformance
might be required, or in which language designers need
the same level of control over indirect instances two or
more meta-levels below [20]. Misusing two-level model-
ing architectures to emulate multi-level modeling gives
rise to undesirable modeling problems. Such cases have
been reported by Brasileiro et al [11] who point out that
85% of wiki knowledge base classes allow for the infer-
ence of unsound conclusions. To react to these issues,
MLM approaches increase the ﬂexibility of the meta-
modeling architecture by allowing an arbitrary number
of meta-levels [20].

Augmenting multi-level modeling with real-time col-
laboration capabilities enables teamwork between stake-
holders acting (i) at diﬀerent levels of abstraction, or (ii)
at diﬀerent levels of decision making. Typical examples
include (i) changing a modeling language during oper-
ation to incorporate language elements required by the
technical stakeholders [33]; and (ii) restricting values of
attributes at higher levels of decision making and en-
forcing these values through the notion of potency [61].
However, current collaboration frameworks are limited
to two-level modeling architectures and no sound prac-
tices exist to engage in real-time collaborative multi-
level modeling among distributed stakeholders [17, 28].

Contributions. The main contribution of our work is a
novel real-time collaborative multi-level modeling frame-
work, called lowkey2. The framework supports a wide
range of modeling scenarios across an arbitrary number
of modeling and linguistic meta-levels. We achieve this
ﬂexibility by separating the linguistic metamodel(s) from
the physical metamodel. In this setting, domain-speciﬁc
models always conform to their linguistic metamod-
els, and they both (models and metamodels) conform
to the uniform physical metamodel provided by the
framework. Real-time synchronization between collab-
orating stakeholders is achieved by persisting the phys-
ical metamodel in CRDT that ensure the consistency
of domain-speciﬁc models in a domain-agnostic fash-
ion. This makes lowkey especially suitable for support-
ing approaches such as multi-view modeling [46]. Fur-
thermore, lowkey subsumes traditional modeling frame-
works, such as UML [27] and EMF [54], oﬀering a promis-
ing integration potential with existing model editors.

Structure. The rest of this paper is structured as fol-
lows. First, in Section 2, we provide an example to illus-
trate the concepts throughout the paper. In Section 3,

2

https://github.com/geodes-sms/lowkey

Fig. 1: The metamodel of the Mind maps.

we give an overview of the background of our work, and
review the related work. In Section 4, we present lowkey,
our framework for real-time collaborative modeling. In
Section 5, we demonstrate the feasibility of the frame-
work by applying it on the case study. In Section 6,
we discuss the lessons learned and compare lowkey with
similar frameworks. Finally, in Section 7, we draw the
conclusions.

2 Illustrative case

We rely on an illustrative case of developing a collab-
orative editor for modeling Mind maps [13]. The case
highlights multiple structural facets of (meta)modeling,
such as typing, inheritance, and various forms of well-
formedness through the collaborative modeling of mind
maps. We show how an editor built on top of lowkey
would enable this.

The metamodel of the case is shown in Fig. 1. MindMap

serves as the root element, containing the various types
of Topics, and the Marker s that can be associated with
speciﬁc Topics. The mindmap is hierarchical: the sin-
gle CentralTopic further contains an arbitrary number
of MainTopics, each containing an arbitrary number of
SubTopics. Finally, SubTopics can contain SubTopics to
arbitrary depths.

Based on the metamodel, the language engineer must
provide an editor that enables real-time collaborative
modeling of a MindMap instance. This entails the fol-
lowing operations: creating, editing, and deleting in-
stances of metamodel concepts; creating, editing, and
deleting links between elements. In addition, a mecha-
nism for reading the state of the local model is required.

Scenarios. Here are some modeling scenarios that may
occur as a result of applying these CRUD operations.

Cooperation. User A creates a MindMap instance and

User B sets its title.

Cooperation with of linguistic inconsistencies.

User A creates a CentralTopic instance, but does
not link it to the MindMap instance. User B links
the CentralTopic instance to the MindMap via a
composition reference.

MindMapname : EStringTopicname : EStringCentralTopicMainTopicSubTopicMarkersymbol : EString[0..1] marker[0..*] markers[1..1] topic[0..*] maintopics[0..*] subtopics[0..*] subsubtopicsReal-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

3

Conﬂict management. User B removes the Central-
Topic instance; in parallel, however, User A creates
a MainTopic instance and links it to the Central-
Topic instance.

Multi-level cooperation. Users A and B have cre-
ated multiple Marker s, and would like to categorize
them (e.g., as textual and graphical). The Language
Designer, who works one metalevel above Users A
and B, sets the potency of the Marker type from 1
to 2; thus, allowing a templating mechanism for A
and B.

Multi-level integrity. Subsequently, the Language De-
signer decides to revoke this level of ﬂexibility from
the users and sets the potency of the Marker class
to 1, rendering the inheritance chain inconsistent.

Requirements. Based on the requirements for eﬀective
real-time collaboration deﬁned by Sun et al. [55], we
formulate the following requirements for a solution in
the context of this illustrative case. These requirements
are evaluated in the feasibility study in Section 5.

R1. Convergence, i.e., every stakeholder’s local data
must exhibit the same state after updates have
been applied.

R2. Timely execution, i.e., operations must propagate
and the system must reconcile within a deadline
to provide a smooth user experience on the client
side.

R3. Causality preservation, i.e., updates must be or-
dered in the same causal way by each stakeholder.
R4. User intention preservation, i.e., the original user’s

intention must be preserved.

R5. Multi-level collaboration, i.e., ability to collaborate
and resolve inconsistencies across diﬀerent meta-
levels.

R6. Meta-model reuse, i.e., tool builders have to be able
to use previously deﬁned meta-models with only
minimal adaption.

R7. Tolerance of linguistic inconsistencies, i.e., the abil-
ity to synchronize and persist models into the phys-
ical representation despite linguistic non-conformance
of model elements.

3 Background

We discuss the existing work related to collaborative
modeling.

3.1 Collaborative MDSE

Collaborative software engineering enables eﬀective co-
operation among stakeholders [66], often in distributed

settings [32]. Distributed teams introduce challenges
to collaboration in terms of processes, project man-
agement, artifact sharing, and consistency [42]. These
challenges are further exacerbated in the engineering of
complex software-intensive systems that require collab-
oration between stakeholders of highly diverse exper-
tise. MDSE [50] provides stakeholders with techniques
for reasoning about the system at higher levels of ab-
straction than source code. As the combination of col-
laborative software engineering and MDSE, collabora-
tive MDSE exhibits the traits of both disciplines. Col-
laborative MDSE has become a prominent feature of
nowadays’ software engineering practice [10]. Version
control for modeling artifacts has been extensively em-
ployed to facilitate collaboration. Such approaches rely
either on lock mechanisms [35] or manual conﬂict reso-
lution [59]. As a consequence, they are not suitable for
real-time collaboration.

3.2 Real-time collaboration

Recent studies on collaborative model-driven software
engineering show a strong shift towards real-time col-
laboration [17, 28]. The main challenge in such a shift
is ensuring appropriate convergence of distributed repli-
cas, while still guaranteeing timely execution [55]. Con-
vergence of replicas is ensured by the consistency model
a distributed setting chooses. Strict consistency is a
theoretical model for guaranteeing deterministic consis-
tency by the total order of change updates that are ex-
changed instantaneously. However, due to its limited us-
ability, various relaxations have been provided, such as
sequential consistency [37], causal consistency [26], and
eventual consistency [65]. Strong eventual consistency
(SEC) [45] augments the liveness property of eventual
consistency (all change updates will be observed even-
tually) with a safety guarantee: two nodes that have
received the same set of change updates will be in the
same state, regardless of the order of updates. SEC is
an eﬃcient resolution of the CAP theorem by Brewer
[12], suggesting that distributed systems cannot provide
more than two out of the three properties of strong con-
sistency, availability, and partition tolerance. SEC re-
moves the problem of conﬂict resolution on local repli-
cas by introducing rules to ensure a unique outcome
for concurrent changes, deterministically resolving any
conﬂict. There is no need for a consensus or synchro-
nization since any kind of change is allowed and con-
ﬂicts are removed altogether. As such, this consistency
model is especially appropriate for real-time collabo-
ration. Nevertheless, SEC may be challenging or even
impossible to implement for certain data types.

4

I. David and E. Syriani

3.3 Conﬂict-free replicated data types

CRDT eliminate conﬂicts between the distributed stake-
holders’ operations; thus avoiding the complexity of
conﬂict resolution and roll-back. As a result, CRDT
exhibit promising fault tolerance and reliability prop-
erties.

CRDT come in two ﬂavors. State-based CRDT are
structured in a way that they adhere to a monotonic
semi-lattice. Shapiro et al. [52] show that state-based
objects that satisfy this property are SEC; hence, they
converge to a consistent state. Operation-based CRDT
require that concurrent operations are commutative. In-
dependent from the order of the received change up-
dates, the state of the local copy converges to the same
state. To achieve such a behavior, the supporting com-
munication protocol has to provide a causal ordering
mechanism, such as global timestamps. In our approach,
we have opted for the operation-based CRDT scheme
because of its reduced costs when exchanging model
changes between replicas.

Operation-based model representation [38] has been
proposed for reasoning about streams of model opera-
tions. The C-Praxis approach [41] deﬁnes six CRUD
model operations and deﬁnes how these operations in-
teract. The CRDT of lowkey are geared toward the more
complex semantics of graphs and, thus, they provide a
superset of these operations. Additionally, lowkey en-
ables working with multigraphs, hypergraphs, and dis-
connected graphs, allowing for more ﬂexibility in mod-
eling. Traditional operation-based approaches, such as
C-Praxis are built on MOF. Consequently, they fall
short of supporting arbitrary meta-levels of modeling.

3.3.1 The Last-Writer-Wins (LWW) paradigm

To ensure the convergence of local replicas, their dif-
ferences have to be resolved in an automated fashion.
Such a resolution mechanism can be implemented ei-
ther in the application or at the data level [40]. The
LWW paradigm [34] has been widely adopted as a data-
level implementation of operation-based conﬂict resolu-
tion [60, 47]. Conﬂicting operations are resolved using
a global ordering operator, e.g., a timestamp. Given
two changes, it is the more recent one that will prevail
[51]. To avoid potential data loss, each change update
is stored locally and the resolution of conﬂicts is carried
out by the local replica.

Fig. 2 shows an example resolution scenario under
LWW. User A (top blue) and User B (bottom green)
initially have their local replicas in consistent states:
the value of x and its timestamp t. At t = 1, User A
executes the update x = 15 on his local copy. A mes-

Fig. 2: Total order of updates in the LWW paradigm.

sage with this updated value and the timestamp is sent
to User B. However, before the message arrives, User A
executes another update: x = 20, at time t = 2. Again,
an update message is composed and sent to User B.
Due to network delays, the second update arrives to
User B earlier than the ﬁrst. Upon receiving the up-
date message, User B will reconcile this new value with
his local replica. As it stands, User B has x = 10 time-
stamped with t = 0; and an update that says x = 20
timestamped with t = 2. Under the LWW paradigm,
the latter value prevails, due to the more recent time-
stamp. Eventually, the ﬁrst message arrives. User B has
x = 20 timestamped with t = 2; and an update of x = 15
timestamped with t = 1. Under the LWW paradigm,
the former value should prevail. Thus, the update is
not performed on the local copy. Eventually, the repli-
cas are in consistent states: x = 20.

Despite the omitted update after receiving x = 15, t =
1, the message can still be stored in User B’s local repli-
cas. It is the responsibility of the CRDT implementa-
tion to decide whether to store outdated data or not.
Some use-cases might require such behavior. However,
the performance of CRDT is proportional with the data
they store [57], and often requires implementing com-
plex garbage collection mechanisms [8].

The LWW paradigm satisﬁes the requirements for
real-time collaboration deﬁned by Sun et al. [55]: (i)
convergence, i.e., every stakeholder’s local data must
exhibit the same state after updates have been applied;
(ii) user intention preservation, i.e., the original user’s
intention must be preserved; (iii) causality preservation,
i.e., updates must be ordered in the same causal way
by each stakeholder; and (iv) timely execution, i.e., op-
erations must propagate and the system must reconcile
within a deadline that provides a smooth user experi-
ence.

3.3.2 CRDT frameworks

Yjs3 is an open-source framework for peer-to-peer shared
editing of structured data, such as rich-text, or XML.

3

https://github.com/yjs/yjs

x = 10t = 0t = 0t = 1t = 2update(x=15, t=1)update(x=20, t=2)x = 10t = 0x = 15t = 1x = 20t = 2x = 20t = 2x = 20t = 2Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

5

Operations are stored in a linked list, resulting in a to-
tal order of operations, thus implementing CRDT. Tele-
type4 provides string-wise sequence CRDT for peer-to-
peer collaborative editing in the Teletype for Atom5 co-
operative source code development environment. Auto-
Couch [31] is a JSON framework combining the beneﬁts
of the Automerge CRDT library6 and the CouchDB7
database engine. Conﬂict-free JSON documents are repli-
cated both on the server side and client side, while en-
suring a responsive real-time user experience for web-
based applications.

These frameworks are similar to lowkey in their aim
to augment engineering tools with a CRDT-based col-
laboration service. However, they are primarily geared
toward linear data types, whereas the CRDT layer of
lowkey is primarily aimed at supporting a wide range
of modeling scenarios. Currently, no other modeling
framework implements support for graph CRDT as ﬁrst-
class citizens. Shapiro et al. [52] formalize graph CRDT
but provide no implementation. SyncMeta [25] (built
on top of Yjs) provides support for modeling graph-
like data structures. However, graphs are emulated by
linked lists and string comparisons at the CRDT level.

3.4 Multi-level modeling

Multi-level modeling (MLM) is a paradigm aiming to
improve the ﬂexibility of modeling architectures by in-
troducing arbitrary meta-levels [4]. A formal framework
of modeling at arbitrary meta-levels has been devel-
oped by Atkinson and Kühne [3], introducing the core
concepts of deep instantiation [5] and deep character-
ization [6]. Deep instantiation extends the traditional
two-level instantiation and allows classes to be instan-
tiated transitively. This is achieved by the notion of po-
tency that deﬁnes how many levels of instantiation the
class supports. Deep characterization allows meta-types
to inﬂuence the characteristics of their instances be-
yond those in the level immediately below. Our frame-
work embraces these concepts to provide collaborative
support in a highly generalized fashion. As shown by
Atkinson and Kühne [5], deep metamodeling can nat-
urally accommodate traditional modeling frameworks
built on shallow instantiation, such as UML and EMF.
Consequently, our framework is a good ﬁt with mod-
eling tools supporting UML and EMF modeling, but
lacking collaborative features.

4

5

6

7

https://github.com/atom/teletype-crdt
https://teletype.atom.io/
https://github.com/automerge/automerge
http://couchdb.apache.org/

The feasibility of multi-level modeling has been demon-

strated in tools such as MetaDepth [20] and Melanee
[2]. However, as pointed out recently by Kühne [36],
the divergence of MLM techniques has led to numerous
diﬀerent interpretations of the nature of levels, their
purpose, the appropriateness of implementation tech-
niques, etc. Often, the dual ontological and linguistic
instantiation of the Orthogonal Classiﬁcation Architec-
ture (OCA) [7] allows elements to be typed by linguistic
concepts and domain concepts at the same time [1, 5].
In this paper, we focus on a third orthogonal dimension,
the physical dimension that deals with the physical rep-
resentation of concepts. The physical–logical distinction
was ﬁrst introduced by Atkinson and Kühne [5]. Specif-
ically, we build on the adapted version of the physical
metamodel deﬁned by Van Mierlo et al [61]. The OCA
usually omits the physical dimension, lumping it into
the linguistic dimension and relying on its physical layer
for representation and serialization (e.g., XMI in MOF).
However, in collaboration techniques operating at the
data level—such as CRDT—the management of consis-
tency is achieved at the physical level of models. This
necessitates the separation of the physical and linguistic
dimensions. The explicit physical dimension enables en-
suring physical consistency while allowing linguistic in-
consistencies. Temporary linguistic inconsistencies are
often desirable, especially when complex modeling op-
erations are used, or when atomic modeling steps do
not result in a linguistically valid model (see Scenario 2
in Section 5.2). For the sake of conciseness, we choose to
treat the physical dimension of Atkinson and Kühne [5]
and the linguistic dimension of the OCA explicitly, and
treat the ontological dimension implicitly. However, be-
cause CRDT operates at the data level, our framework
is able to treat both linguistic and ontological confor-
mance.

4 A framework for real-time collaborative
metamodeling

We present the diﬀerent components of lowkey, our real-
time collaborative modeling framework.

4.1 Architecture

Fig. 3 outlines the architecture of the framework. In a
typical modeling setting, users are provided with (domain-
speciﬁc) Editors that enable interacting with the mod-
els of the linguistic modeling layer, through a generated
domain-speciﬁc API. The linguistic modeling layer en-
forces well-formedness rules deﬁned by the static se-
mantics of the language. Each element at the linguistic

6

I. David and E. Syriani

Fig. 3: Overview of the architecture and the roles of each layer

Fig. 4: The Physical metamodel and CRDT layers

modeling layer conforms to a physical metamodel, as
described by Van Mierlo et al. [61]. The physical mod-
eling layer is responsible for the uniform representation
of objects of the linguistic models and metamodels. In-
stances of the physical metamodel are serialized and
propagated to the collaborating stakeholders through
their network interface which communicates with the
server. Other clients receive these instances from the
server and merge them into the local working data rep-
resented in CRDT. The command language of the phys-
ical modeling layer enables a uniform treatment of lo-
cal updates (from the linguistic modeling layer ), and
remote updates (from the network interface).

4.2 Linguistic modeling layer

The linguistic modeling layer provides mechanisms for
modeling at arbitrary levels of abstraction. As a con-
sequence, this layer contains every domain model and
its metamodels the Editor manipulates. To this end, a
domain-speciﬁc API is generated for the metamodels.
In the illustrative case, the MindMap class and its in-

stance(s) are situated at this modeling layer; and meth-
ods for CRUD operations are generated.

The main responsibility of this layer is to enforce
the language-speciﬁc well-formedness rules deﬁned by
the meta-model and static semantics. Typical exam-
ples of language-speciﬁc well-formedness rules include
multiplicities, transitive containment by compositions,
and uniqueness of marker names.

4.3 Physical modeling layer

The main responsibility of the physical modeling layer
is to provide a metamodel that every linguistic concept
can conform to, regardless of which linguistic meta-
level they are situated at. For example, the physical
metamodel has to accommodate both the MindMap
class; its instance mindmap_0 ; and the Class class the
MindMap class corresponds to. In addition, the phys-
ical modeling layer may impose language-independent
well-formedness rules, such as each model having to ex-
hibit a graph structure.

CRDTEditorLinguistic well-formedness rulesUniform object representationCollaboration / persistenceComm.languagePullRouterNetwork interfaceSubDealergeneratedClientNetworkServerLinguistic modeling layerDomain-specific APIPubPushPhysicalmodeling layerserverPhysical metamodelLWWMapLWWVertexLWWEdgeLWWGraph10..*typed_by110..*InheritsCRDTPhysical metamodelClabject-is_abstract: Boolean-potency: Union(Integer, ∞)-id_field: StringAssociation-from_min: Integer-from_max: Union(Integer, ∞)-from_port: String-to_min: Integer-to_max: Union(Integer, ∞)-to_port: Stringpersisted aspersisted aspersisted aspersisted asModel-potency: Union(Integer, ∞)Node-id: UUID-name: StringCompositionAggregationAttribute-default: Any-type: Type-value: Any-potency: Union(Integer, ∞)0..*0..*Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

7

4.3.1 Physical metamodel

We adopt the physical metamodel from previous work
[61], as shown at the bottom of Fig. 4.

Node is the foundational concept of the metamodel,
which can be organized into Model s. Models, in turn,
are Nodes themselves, allowing for the hierarchical com-
position of Model s.

A consequence of metamodeling—and multi-level
modeling in particular—is that instantiable model ele-
ments can play the role of both instances and types [3].
To accommodate this dichotomy, Clabjects serve as the
physical metatype for every linguistic class and instance.
For example, in the mindmap metamodel, both the
CentralTopic class and its instance(s) are mapped onto
the Clabject physical type.

Associations link Clabjects to each other. The Asso-
ciation inherits from the Clabject, and transitively from
the Node. Due to the latter, Associations can be typed
by other Nodes. Due to the former, Associations can be
abstract and link other Associations. We allow this ﬂex-
ibility to accommodate the models of various modeling
frameworks and formalisms that typically implement
a subset of these modeling options. UML, for exam-
ple, restricts Associations from being abstract, and only
allows linking Clabjects. Composition and Aggregation
are specialized types of Association with conventional
semantics.

Attributes store information of speciﬁc Nodes. Specif-
ically, in Attributes, the type property maintains in-
formation about the linguistic type the Attribute cor-
responds to. For example, storing textual information
(such as the name of a Topic in the illustrative case) in
the Eclipse Modeling Framework (EMF) would mean
the type of the Attribute is EString. Attributes are spe-
cializations of the Node type. The inherited typed_by
relationship provides a mechanism for typing an At-
tribute at the physical level.

objects of the type-instance hierarchy become indepen-
dent of their physical representation, and their roles are
determined by purely linguistic concepts, such as being
metatypes or instances of each other. Therefore, we re-
fer to this level of objects as the linguistic metamodel.

The physical metamodel of traditional modeling frame-

works is typically coupled with the topmost meta-level
of their linguistic metamodels. For example, Ecore serves
as the core metamodel of EMF and also deﬁnes the
rules governing the serialization of EMF models into
XMI ﬁles.

By providing mechanisms for multi-level metamod-
eling, and clearly separating the physical metamodel
from the linguistic metamodel, our framework is able
to (i) support advanced metamodeling scenarios; and
(ii) accommodate traditional modeling frameworks, for
example, by restricting the ﬂexibility of the physical
metamodel. Similar avenues have been explored by mul-
tiple modern modeling frameworks, such as Melanee [2],
metaDepth [20], and the Modelverse [62].

4.3.3 Command language

The physical metamodel can be accessed and interacted
with through a command language. The brief deﬁnition
of the language is shown in Listing 1. The command lan-
guage deﬁnes four CRUD operations. Therefore, inte-
grating an editor with the physical metamodel requires
the appropriate facility that translates domain-speciﬁc
modeling operations to the operations of the command
language. We have opted for providing an external tex-
tual DSL because such languages are more trivially se-
rialized and propagated through standard network pro-
tocols than binary data.

4.3.2 Need for an explicit physical metamodel

4.4 CRDT layer

Instantiation mechanisms of current modeling frame-
works typically consider two levels: classes and their in-
stances (objects). Although this covers the majority of
practical use cases, some scenarios might require mul-
tiple levels of type-instance relationships [22]. Such a
type-instance hierarchy enables various beneﬁcial mech-
anisms, such as deep instantiation and deep characteri-
zation [5]. The role of a physical metamodel is to repre-
sent the objects of such a type-instance hierarchy uni-
formly, irrespective of what metalevel a speciﬁc object
is situated at; and to provide services such as the serial-
ization of these objects. By this separation of concerns,

The CRDT layer is responsible for persisting instances
of the physical metamodel. As shown in Fig. 4, each
element of the physical metamodel is associated with
exactly one CRDT. At run-time, as the classes of the
physical metamodel get instantiated, a corresponding
CRDT is instantiated as well. The model element main-
tains a reference to its persisting CRDT instance dur-
ing execution. Our CRDT implementations follow the
LWW paradigm and have been mainly implemented
by following the speciﬁcations outlined by Shapiro et
al. [51]. In the following, we brieﬂy elaborate on these
types.

8

I. David and E. Syriani

1 CREATE -name {name} -typedBy {type} [-attributeName {value}]*
2 LINK -from {fromClabject}.{associationName} -to {toClabject} [-attributeName {value}]*
3 UPDATE (-name {name} | -id {id}) [-attributeName {newValue}]*
4 DELETE (-name {name} | -id {id})

Listing 1: Command language for interacting with the physical metamodel

4.4.1 Timestamps for total order

To ensure the commutativity of operation-based CRDT,
an operator for total order is required. The most natural
choice in a distributed setting is a global timestamping
mechanism, as it makes the fewest assumptions about
the system. lowkey uses the Unix epoch time in nanosec-
onds to timestamp model updates with. As an alterna-
tive, Lamport clocks [37] or vector clocks [53] can be
used as suggested by Shapiro et al. [51]. Timestamped
model updates are subsequently forwarded to the col-
laborating stakeholders. The global nature of the time-
stamp ensures that each local replica sorts the updates
in the same order, ensuring the safety property of SEC
(c.f. Section 3.3). The appropriate granularity of time-
stamps is paramount in supporting complex CRDT.
Consider the underlying data structure in the illustra-
tive example in Fig. 2 being a graph, in which vertices
represent entities with associated attributes. Assigning
a timestamp to the whole graph would not allow inde-
pendent changes at ﬁner-grained levels, such as vertices.
Thus, we assign a timestamp to each instance of the el-
ements of the physical metamodel, and update it on
each CRUD operation.

Another useful operator could be the priority of
messages, e.g., to deﬁne hierarchical stakeholder roles
in which higher ranked roles can overwrite the changes
of lower-ranked roles. An important diﬀerence between
timestamps and priorities is the level of granularity.
Timestamps (e.g., at the level of nanoseconds) provide
better chances to unambiguously order two operations,
as compared to priorities (e.g., assigned from a range
between 1–5). Therefore, the ordering operator should
be carefully designed to ensure the total order. Further-
more, compound ordering operators can be used as well.
For example, the shortcomings of the priority operator
can be circumvented by combining it with timestamps.
Such compound operators are best deﬁned by linking
them through the absorption identity over the lattice
of change operations [15] to ensure a valid and sound
composition.

4.4.2 LWWRegister

The LWWRegister is the simplest CRDT in lowkey, con-
taining a single value. To implement LWW semantics,

its value v is equipped with a timestamp t. Thus, an
LWWRegister r is deﬁned as r = (v, t).

update The update operation permits to modify the
value of the register. Given a new timestamped value
), the update operation on register r = (v, t) is
(v
deﬁned as r ∶= (v

′ > t, and NOP otherwise.

) iﬀ t

′
, t

′
, t

′

′

4.4.3 LWWSet

The LWWSet S contains an arbitrary number of time-
stamped values (v, t) under set semantics. That is, for
S = ⟨(v, t)⟩, it holds that ∀si = (vi, ti), sj = (vj, tj) ∈
S ∶ vi ≠ vj. We have implemented the LWWSet as an
LWW-element-Set [51]. LWW-element-Sets are composed
of the add-set A and the remove-set (R). The two sets
are disjoint with the add-set containing values added to
S, and the remove-set containing values removed from
S. This structure ensures the commutativity of add
and remove operations: add(v, t) ◦ remove(v, t’) ≡ re-
move(v, t’) ◦ add(v, t).

lookup The lookup operation indicates if an element is
in the set. A value is considered to be in the LWWSet iﬀ
it can be found in the add-set, and it cannot be found
in the remove-set with a higher timestamp. It is deﬁned
as lookup ∶ v → B, where lookup(v) evaluates to true if
′
∃v, t ∄t

′ ∶ (v, t) ∈ A ∧ (v, t

) ∈ R, t

′ > t.

add The add operation inserts new values in the add-
set. It is deﬁned as add(v, t) ∶ S.A → S.A ∪ {(v, t)}.

remove The remove operation deletes values from the
set by adding them to the remove-set. It is deﬁned as
remove(v, t): S.R → S.R ∪ {(v, t)}.

4.4.4 LWWMap

The LWWMap is deﬁned as an extension of the LWWSet.
The data is stored as a key/value pair ((k, v), t).

lookup, query The lookup operation is modiﬁed so
that it looks up the key instead of the value. That is,
lookup ∶ k → B, where lookup(k) evaluates to true iﬀ
′ > t. The
∃k, t ∄t
query(k) method returns the value for a key k.

′ ∶ ((k, v), t) ∈ A ∧ ((k, v), t

) ∈ R, t

′

Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

9

add, remove Analogously to the add and remove of
the LWWSet: add((k, v), t): S.A → S.A ∪ {((k, v), t)};
and remove((k, v), t): S.R → S.R ∪ {((k, v), t)}.

′

′

is deﬁned as update(k, v, v

update This operation is the only substantial diﬀer-
ence the LWWMap introduces to the LWWSet. Updating a
timestamped with
key ((k, v), t) entry with a value v
′
′
) ◦
t
′ − (cid:15)). First, the entry with key k is re-
remove((k, v), t
moved, and the time of removal is timestamped with a
′
by the
value that is older than the new timestamp t
minimal time interval (cid:15) the system is able to detect. In
lowkey (cid:15) = 1 ns. Subsequently, the entry with key k and
the new value v

is added with the timestamp t

) = add((k, v

′
), t

, t, t

.

′

′

′

4.4.5 LWWGraph

The LWWGraph G is the extension of the LWWMap that
enables persisting attributes of the graph. This mech-
anism is used for storing the vertices and edges of the
graph. Vertices are stored in an LWWSet, denoted by V .
Each element of V is an LWWVertex. To enable storing
attributes and metadata of vertices, each LWWVertex is
an extension of the LWWMap. Analogously, the edge set E
is an LWWSet, containing LWWEdge instances. Formally:
G = (V, E), where
– V, E ⊢ LWWSet;
– V = ⟨(v, t)⟩, where v ⊢ LWWVertex and t is a time-

stamp;

– E = ⟨(e, t)⟩, where e ⊢ LWWEdge and t is a time-

stamp;

– ∀e ∈ E ∶ e.query(“source”), e.query(“target”) ∈ V

(denoted e.source and e.target).

– LWWGraph, LWWVertex, LWWEdge ⊢ LWWMap.

Due to the invariant property of E ⊆ V × V , op-
erations on V and E are not independent. Shapiro et
al. [51] suggest multiple ways to manage this issue. In
lowkey, we chose prioritizing the removeVertex opera-
tion to ensure CRDT behavior. That is, the operation
is only allowed to be executed if it does not leave a
dangling edge behind.

lookup and query Since both the LWWVertex and the
LWWEdge extend the LWWMap, their lookup and query
methods are identical to the ones discussed in Section 4.4.4.

removeEdge, removeVertex These operations reuse the
API of the LWWSet directly. Removing an edge is achieved
by adding the edge to the remove-set R of the edge
set E of graph G. Thus, removeEdge(e, t) ∶ G.E.R →
G.E.R ∪ {(e, t)}; and removeVertex(v, t) ∶ G.V.R →
G.V.R ∪ {(v, t)}. Furthermore, to ensure the CRDT be-
havior: removeVertex(v, t) ⇒ /∃ e ∈ E ∶ e.source=v ∨
e.target=v.

Additional methods of the LWWGraph are deﬁned for
querying various properties of the graph; and for adding
and removing vertices and edges by name and identi-
ﬁer. Additional methods of the LWWEdge and LWWVertex
types are deﬁned, e.g., for querying incoming and out-
going edges of a vertex, cascading the removal of dan-
gling edges upon a vertex removal, and assigning direc-
tion to edges.

4.5 Network architecture

lowkey follows a client-server network architecture with
multiple clients connecting to the same server, as out-
lined already in Section 4.1. The network architecture
is built on top of the ZeroMQ8 asynchronous messaging
library. It oﬀers eﬃcient scalability and latency prop-
erties; thus it aligns well with the requirements of real-
time collaboration.

4.5.1 Server and Client components

As shown in Fig. 3, our framework provides two net-
work components for connecting remote collaborating
stakeholders: the server and the client.

The server component is responsible for two tasks:
(i) collecting from, and distributing updates among clients;
and (ii) providing newly joined clients with the snap-
shot of the system so they have an initial local replica.
The client component is responsible for providing
networking capabilities to modeling tools and editors.
The Client interface is accessible from the API of the
framework and it is the tool builder’s responsibility to
properly implement its required functionality. Speciﬁ-
cally, the Client interface is properly implemented by
deﬁning the action the Sub socket executes periodically
during its polling loop.

4.5.2 Communication patterns

addEdge, addVertex These operations reuse the API
of the LWWSet directly. Adding an edge is achieved by
adding the edge to the add-set A of the edge set E
of graph G. Thus, addEdge(e, t) ∶ G.E.A → G.E.A ∪
{(e, t)}; and addVertex(v, t) ∶ G.V.A → G.V.A∪{(v, t)}.

Diﬀerent responsibilities of the server are implemented
with diﬀerent communication patterns, as summarized
in Fig. 3.

8

https://zeromq.org/

10

I. David and E. Syriani

Exchanging updates. To receive updates, a client must
ﬁrst subscribe to the updates by connecting to the Pub
(publisher) socket of the server with its own Sub (sub-
scriber) socket. The Pub-Sub pattern establishes a one-
way asynchronous communication channel with the client
receiving and processing messages in a polling loop. The
Pub socket broadcasts messages to every client con-
nected to the server. To send updates, a client must ﬁrst
connect to the Pull socket of the server with its Push
socket. Similar to the Pub-Sub pattern, the Pull-Push
pattern establishes a one-way connection. Note that the
Push socket is geared towards supporting pipelining
mechanisms, hence it does not broadcast messages.

Distributing system snapshots. Upon connecting to the
server, the client needs to obtain a snapshot of the
system. This is achieved by connecting to the Router
socket of the server via the Dealer socket of the client.
The Router-Dealer pattern implements a request-reply
mechanism with both ends acting asynchronously. As
opposed to the patterns used for exchanging updates,
this pattern does not maintain a connection after the
request-reply pair of messages has been exchanged.

To provide a snapshot to its clients, the server is
equipped with a memory that stores the history of pre-
viously exchanged messages (model updates). Once the
newly connected client requests the snapshot, the his-
tory of messages is replayed to it. The state of the sys-
tem is then built up locally by the client. We opted for
this mechanism to keep it aligned with our choice of
operation-based CRDT semantics (Section 3.3), and to
shift the workload to the client instead of the server.
Since operation-based and state-based CRDT are able
to emulate each other, it would be possible to commu-
nicate the whole state at once, but this would come at
the price of increased network traﬃc.

4.5.3 Update messages

Every update message has the following signature:
⟨clientId, command, timestamp⟩, where the clientId is
a UUID assigned to the client upon its creation, used
for avoiding double delivery problems; command corre-
sponds to the command language of the physical meta-
model shown in Listing 1; and timestamp is the time-
stamp of creation, as discussed in Section 4.4.1. Mes-
sages are serialized as text and sent through the TCP/IP
stack.

Upon reception, the command encapsulated in the
update message is executed on the local replica. In
the current implementation of lowkey, the scope of the
change is the root model in the modeling session. Ad-
vanced modeling scenarios might necessitate more com-

plex scope management. For example, multi-view mod-
eling requires support for namespaces in order to al-
low independent views to deﬁne syntactically similar or
identical concepts [14]. Such features are left for future
work.

5 Feasibility evaluation

Based on our illustrative case, we evaluate the feasibil-
ity of lowkey from two points of view. In both cases, our
objective is to assess whether lowkey can accommodate
the challenges outlined in the case study. First, in Sec-
tion 5.1, we provide a language engineer’s view by pre-
senting the process of metamodeling in lowkey. Then,
in Section 5.2, we provide a domain expert’s view by
demonstrating four collaborative modeling scenarios.

Study setup. We conduct the evaluation on three desk-
top machines with Python 3.7 and the required libraries
installed on them. We deploy the lowkey framework
as an editable local package. First, in Section 5.1, we
model the domain concepts of the Mind map editor on
one machine and generate a domain-speciﬁc API the
other two machines will use during collaboration. Sec-
ond, in Section 5.2, we deploy this domain-speciﬁc API
to two machines along with the Mind map editor and
conduct our experiments guided by the requirements
formulated in Section 2.

5.1 Language engineer’s view: metamodeling in lowkey

Fig. 5 shows how the metamodel of the illustrative case
(Fig. 1) is deﬁned within the lowkey framework in rela-
tion to the physical model (Fig. 4). The linguistic meta-
model represents the same domain as the metamodel in
Fig. 1, but instead of using UML to express it, here, we
use the physical metamodel of the lowkey framework.9
The color coding shows how every concept physically
conforms to the Clabject. This is due to the linguistic
metamodel being an instance of the physical metamodel.
In addition, the linguistic metamodel linguistically con-
forms to the linguistic meta-metamodel. The latter is
another instance of the physical metamodel ; thus, its
elements physically conform to the speciﬁc elements of
the physical metamodel (shown by color-coding). Spe-
ciﬁc Mind map instances are created in the linguistic

9 We remark, that multi-level modeling approaches tradition-
ally rely on the orthogonal linguistic and ontological dimensions,
and do not consider the physical dimension. In this paper, we only
consider the linguistic and physical dimensions to allow an easier
discussion. Our approach can be safely extended with ontological
aspects, similarly to the work of [61].

Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

11

instance model that linguistically conforms to the lin-
guistic metamodel, and physically conforms to the phys-
ical metamodel. As emphasized by the arrow notation,
the mindmap_0 object is a linguistic instance of the
MindMap class; which is, in turn, a linguistic instance
of the Class class. Each of these are physical instances
of the Clabject class. Similarly, the title of the mindmap
"todolist" is a linguistic instance of title: String = "";
which is, in turn, a linguistic instance of the Attribute
class.

Thanks to the clear physical conformance relation-
ships, every element at the physical instance level will
be persisted as a CRDT, irrespectively of their linguistic
meta-level. Therefore, stakeholders can safely collabo-
rate by editing any of the three linguistic metamodels.

Generating a domain-speciﬁc API.To enable interacting
with the linguistic metamodel, an API has to be pro-
duced. This process is fully automated with a template-
based code generator that produces a Python class for
every Clabject, and generates the appropriate acces-
sors (e.g., get, set, add, remove) for attributes and ref-
erences. Listing 2 shows the method signatures of the
Python code generated for the MindMap class.10

1 class MindMap(Clabject):
2

# Attribute: title, Type: String,
# Multiplicity: 1
def getTitle(self)
def setTitle(self, title)

# Reference: topic, Type: CentralTopic
# MultiplicityFrom: 1..1, MultiplicityTo: 1..1
# IsComposition: True
def getTopic(self)
def setTopic(self, topic: CentralTopic)
def removeTopic(self)

# Reference: markers, Type: Marker
# MultiplicityFrom: 0..1, MultiplicityTo: 0..*
# IsComposition: True
def getMarkers(self)
def addMarker(self, marker)
def removeMarker(self, marker)

Listing 2: Excerpt of the generated model API.

3

4

5

7

8

9

10

11

12

14

15

16

17

18

19

5.2 Domain expert’s view: collaboration in lowkey

After the linguistic metamodel has been deﬁned,
the domain experts can build the linguistic instance
model in a collaborative fashion. Fig. 6 illustrates this
collaboration by showing the objects of the linguistic
metamodel and the CRDT at the local replicas. For
space considerations, we omit the technical details, such
as clients connecting to the server; and only show the

CRDT for Client A. For testing, evaluation, and demon-
stration purposes, we implemented a simple Mind map
editor via the command line. The commands of the ed-
itor are shown in Listing 3. In the following, we out-
line typical collaboration scenarios based on our exper-
iments with the editor.

1. Cooperation

– Client A creates a MindMap instance by issuing the
CREATE MindMap mindmap_0 command. As shown in
Fig. 3, the command is parsed into Python source
code that uses the Domain-speciﬁc API (Listing 2)
of the linguistic level. The role of the linguistic level
is to enforce linguistic well-formedness rules. Since
the model with the single mindmap_0 object is well-
formed, the command is further translated to the
command language of the physical modeling layer
(Listing 1).

– The client sends this command to the Server, using
their respective Push-Pull sockets. The message is
stored in the list of updates at the Server.

– At the CRDT level, an LWWVertex is instantiated
to store the local data at the client side. The key-
value pairs of the LWWVertex store every informa-
tion required to reconstruct the linguistic object, i.e.,
(type, MindMap); (name, mindmap_0 ); and (title,
mindmap_0 ). In the current implementation of lowkey,
an LWWGraph is automatically instantiated to accom-
modate the LWWVertex and LWWEdge instances cre-
ated throughout the collaboration.

– The Server broadcasts the change to the collabora-
tors, i.e., Client B. Subsequently, an object from the
MindMap class is instantiated with the same ID as
the one at User A’s side.

– Client B changes the title attribute of the mindmap_0
object by issuing the UPDATE command. The change
is applied locally and forwarded to the Server after
the required conversion to the command language.
Client A receives the change from the Server and
updates its local replica.

– At the CRDT level, the LWWVertex is updated by
changing the title from mindmap_0 to todolist, re-
ﬂecting the changes by Client B. As explained in Sec-
tion 4.4, the previous and current values are stored
in the Add-set of the LWWVertex (inherited from the
LWWMap). Querying the CRDT instance yields todolist
as the value with the latest timestamp.

2. Cooperation with linguistic inconsistencies

10 The full example is available at https://github.com/
geodes-sms/lowkey.

– Client A creates a CentralTopic instance by the name
tasks. The centraltopic_0 object is not linked to the

12

I. David and E. Syriani

Fig. 5: The three-level hierarchy of linguistic models corresponding to the physical metamodel in the mindmap
case

1 READ -- Returns the mindmap model in a readable form
2 OBJECTS -- Lists every object in the local session
3 CREATE {type} {name} -- Creates an instance with name of the domain-specific type
4 LINK {source}.{port} TO {target} -- Links object target to object source via port
5 UPDATE {name} {attribute} {newValue} -- Updates attribute with name to newValue
6 DELETE {name} -- Deletes object name

Listing 3: MindMap DSL of the Editor

mindmap_0 object, violating the 1-1 relationship
between the MindMap and CentralTopic classes, pre-
scribed by the static semantics of the metamodel
(Fig. 1). In this example, we assume a less restrictive
linguistic modeling layer, in which static semantics
are not enforced. The physical modeling layer, how-
ever, enforces physical well-formedness rules, e.g., the
model has to correspond to a graph, which is allowed
to be disconnected. (This rule is deﬁned by the aggre-
gation between the Model and Node types in Fig. 4.)
The editor-level user operation, thus, is propagated
to the physical modeling layer, translated into the
command language: CREATE -typedBy CentralTopic
-name tasks. Because of the valid physical model,

the message is forwareded to the server and distributed
to Client B.

– At the CRDT level, a new LWWVertex is created to

store the CentralTopic instance.

– Client B links the CentralTopic instance to the MindMap
instance. The distribution of the tasks of object cre-
ation (Step 5) and linking (Step 6) creates a truly
collaborative setting, demonstrating cases in which
stakeholders of specialized expertise take care of par-
tial tasks, not necessarily resulting in a valid linguis-
tic model on every atomic operation. Client B cre-
ates an association of type topic between the two
objects, named topic_0. The operation results in a
valid linguistic model, the changes are propagated in

LWWMapLWWVertexLWWEdgeLWWGraph10..*typed_by110..*InheritsmarkersubTopicssubsubTopicstopic_0: topicmainTopics_0: mainTopicsmainTopics_1: mainTopicsLINGUISTIC DIMENSIONPHYSICAL DIMENSIONCRDTPhysical metamodelPhysical instance modelsLinguistic instance modelLinguistic metamodelLinguistic meta-metamodelmarkers-from_min: 1-from_max: 1-from_port: topic-to_min: 0-to_max: 1-to_port: mindmaptopicmainTopics-from_min: 1-from_max: 1-from_port: marker-to_min: 0-to_max: 1-to_port: topic-from_min: Integer-from_max: Union(Integer,∞)-from_port: String-to_min: Integer-to_max: Union(Integer,∞)-to_port: String10..*mindmap_0: MindMaptitle: “todolist”name: “tasks”maintopic_0: MainTopicname: “Read paper”maintopic_1: MainTopicname: “Write case study”CentralTopic-is_abstract: FalseSubTopic-is_abstract: FalseMainTopic-is_abstract: FalseMindMap-is_abstract: False-title: String = “”Marker-is_abstract: False-symbol: String = “”Topic-is_abstract: True-name: String = “”Clabject-is_abstract: Boolean-potency: Union(Integer, ∞)-id_field: Stringcentraltopic_0: CentralTopicAssociation-from_min: Integer-from_max: Union(Integer, ∞)-from_port: String-to_min: Integer-to_max: Union(Integer, ∞)-to_port: Stringpersisted aspersisted aspersisted aspersisted aslinguistic conformancephysical conformanceModel-potency: Union(Integer, ∞)Node-id: UUID-name: StringCompositionAggregationClass-name: String-is_abstract: Boolean-potency: Union(Integer, ∞)-id_field: StringAttribute-name: String-default: Any-type: Type-value: Any-potency: Union(Integer, ∞)Attribute-default: Any-type: Type-value: Any-potency: Union(Integer, ∞)0..*0..*Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

13

(a) Changes in the CRDT of Client A in Scenarios 1–3

(b) Changes in the CRDT of Client A in Scenarios 4–5

Fig. 6: Collaboration in lowkey outlining changes in the CRDT shown for Client A

User AServerUser BCREATE MindMap mindmap_0CREATE -typedBy MindMap -name mindmap_0-title mindmap_0CREATE -typedBy MindMap -name mindmap_0-title mindmap_0UPDATE mindmap_0 title todolistUPDATE -name mindmap_0 -title todolistUPDATE -name mindmap_0 -title todolistmindmap_0: MindMaptitle: “mindmap_0”mindmap_0: MindMaptitle: “mindmap_0”mindmap_0: MindMaptitle: “todolist”mindmap_0: MindMaptitle: “todolist”CREATE CentralTopic tasksCREATE -typedBy CentralTopic -name tasksmindmap_0: MindMaptitle: “todolist”centraltopic_0: CentralTopicname: “tasks”CREATE -typedBy CentralTopic -name tasksmindmap_0: MindMaptitle: “todolist”centraltopic_0: CentralTopicname: “tasks”LINK todolist.topic to tasksLINK -from mindmap_0 -to centraltopic_0LINK -from mindmap_0 -to centraltopic_0mindmap_0: MindMaptitle: “todolist”centraltopic_0: CentralTopicname: “tasks”mindmap_0: MindMaptitle: “todolist”centraltopic_0: CentralTopicname: “tasks”12topic_0: topictopic_0: topicCREATE MainTopic read_paperLINK tasks.mainTopics read_papermindmap_0: MindMaptitle: “todolist”centraltopic_0: CentralTopicname: “tasks”topic_0: topicmaintopic_0: MainTopicname: “read_paper”mainTopics_0: mainTopicsmindmap_0: MindMaptitle: “todolist”DELETE centraltopic_0CREATE -typedBy MainTopic -name read_paperLINK -from centraltopic_0 -to maintopic_0DELETE centraltopic_0centraltopic_0: CentralTopicname: “tasks”topic_0: topicDELETE centraltopic_0mindmap_0: MindMaptitle: “todolist”centraltopic_0: CentralTopicname: “tasks”topic_0: topicmaintopic_0: MainTopicname: “read_paper”mainTopics_0: mainTopics3CREATE -typedBy MainTopic -name read_paperLINK -from centraltopic_0 -to maintopic_0LWWVertextype: CentralTopicname: centraltopic_0title: tasksLWWVertextype: MindMapname: mindmap_0title: todolistLWWVertextype: MindMapname: mindmap_0title: todolistLWWEdgetype: topicname: topic_0LWWVertextype: MainTopicname: maintopic_0title: read_paperLWWEdgetype: mainTopicsname: mainTopics_0+#++++User AServerUser BLanguage designer4UPDATE -name Marker-potency 2Marker: Class @2potency: 2TextMarker: Marker @1marker_0: TextMarker @0symbol: “x”LWWVertextype: Markername: TextMarkerpotency: 1LWWVertextype: TextMarkersymbol: “x”potency: 0#+5UPDATE -name Marker-potency 1Marker: Class @1potency: 1TextMarker: Marker @0LWWVertextype: Markername: TextMarkerpotency: 0LWWVertextype: TextMarkersymbol: “x”potency: 0X#marker_0: TextMarker @0symbol: “x”14

I. David and E. Syriani

the usual way, and eventually, the change is reﬂected
in the replica of Client A.

the Marker class. These classes can be then instan-
tiated with a speciﬁc symbol.

– At the CRDT level, a new LWWEdge is created to
store the association. The LWWEdge is added to the
LWWGraph with the previous two LWWVertex as its
source and destination.

3. Conﬂict management

– Client A works on objects that Client B has deleted.
First, Client B deletes the centraltopic_0 object, and
as a consequence, the object is marked deleted in
the local replica. As explained in Section 4.4, CRDT
use soft delete to be able to restore data if needed.
The update message is sent to the server. In the
meantime, Client A creates an instance of the Main-
Topic class and links it to the centraltopic_0 ob-
ject via the mainTopics_0 reference. The two up-
date messages are propagated to the server. Client A
started its changes before the updates about Client
B’s changes have reached him. Subsequently, both
clients’ updates are sent to the other client, causing
inconsistency in the local replicas. However, both in-
consistencies are resolved immediately by the LWW
semantics of CRDT. Since Client A’s updates have
been created later, the timestamping mechanism will
resolve the inconsistencies by (i) leaving Client A’s
replica intact and (ii) re-adding the centraltopic_0
object to Client B’s replica.

– At the CRDT level, the local replica of Client B re-
moves the LWWVertex storing the CentralTopic in-
stance: the vertex is removed from the vertex set of
the LWWGraph. This is achieved by adding the ver-
tex to the Remove-set of the graph, as explained in
Section 4.4.4. Before this information is propagated,
Client A performs editing operations resulting in a
new LWWVertex and a new LWWEdge. The source of
the newly created LWWEdge is the LWWVertex removed
by Client B, hence the conﬂict. However, due to the
more recently created (and timestamped) LWWEdge,
the LWWVertex is not removed in the local replica of
Client A. After Client B is notiﬁed about the opera-
tions of Client A, the LWWVertex storing the Central-
Topic instance is re-added to its local replica, restor-
ing the consistency between the clients.

4. Multi-level cooperation

– Users A and B have created multiple instances of the
Marker class and would like to categorize them into
textual and graphical markers. One way to achieve
this is by allowing a templating mechanism to these
users so that they can create speciﬁc sub-classes of

– The Language designer increases the potency of the
Marker class from 1 to 2. The change is distributed
to the users.

– User A creates a new instance of the Marker class
by the name TextMarker. The potency of the newly
created clabject is set to 1, allowing one more in-
stantiation. Subsequently, he modiﬁes the previous
marker_0 in a way that it is typed by the newly cre-
ated TextMarker class. The potency of marker_0 is
set to 0, preventing any further instantiation.

5. Multi-level integrity

– After deﬁning the TextMarker type and creating the
marker_0 instance of it, the language designer de-
cides to revoke this level of ﬂexibility from the users
and sets the potency of the Marker class to 1. The
change is distributed to the users.

– The potency of the TextMarker instance is now au-
tomatically set to 0 by lowkey. However, this com-
promises the integrity of the instantiation chain as
the 0 potency of the TextMarker prohibits the in-
stantiation of marker_0. lowkey resolves this prob-
lem by prioritizing the integrity of the instantiation
chain and marking marker_0 as deleted. While the
physical integrity of the model is ensured, linguis-
tic well-formedness might be violated. For example,
the TextMarker object does not deﬁne a symbol at-
tribute, which might violate linguistic well-formedness
rules. As explained in Section 4.2, such rules are de-
ﬁned by language engineers and tool builders at the
linguistic modeling layer.

– Should the Language Designer set the potency of the
Marker class to 2 again, marker_0 instance becomes
available to the Domain experts again.

5.3 Summary

In this feasibility evaluation, we have demonstrated the
usage of lowkey in advanced modeling scenarios. Con-
cerning the requirements formulated in Section 2, we
have demonstrated that replicas converge (R1) and that,
in a timely fashion (R2). Both causality (R3) and user
intention is preserved (R4). The language engineer’s
point of view (Section 5.1) has shown the development
of domain-speciﬁc modeling languages with multi-level
modeling capabilities (R5). lowkey enabled reusing the
metamodel of the case (Fig. 1) that was previously de-
ﬁned in an external tool (R6). The domain expert’s

Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

15

Table 1: Comparison of related modeling frameworks

Framework Metamodeling

Multi-level
modeling

Real-time
collaboration

Consistency
model

Conﬂict mgmt/
Resolution

AToMPM [58]
Modelverse [62]
MetaDepth [20]
Melanee [2]
WebGME [39]
SpacEclipse [29]
FlexiSketch [67]
SyncMeta [25]
MetaEdit+ [35]
TGRL [48]
MONDO [24]

lowkey

Strong
N/A
N/A
N/A
Eventual
Strong
Strong
SEC
Strong
SEC
Strong

Manual resolution
N/A
N/A
N/A
Manual resolution
Manual resolution
Prevention
Prevention (CRDT)
Pessimistic locking
Prevention (CRDT)
Pessimistic locking

SEC

Prevention (CRDT)

point of view (Section 5.2) has demonstrated how real-
time collaboration is achieved by CRDT, irrespectively
of the level of linguistic abstraction (R5). In addition,
we have highlighted how the combination of CRDT and
the Phyical metamodel allows for seamless collabora-
tion in the presence of linguistic inconsistencies and
non-conformance (R7).

Limitations and Threats to validity. Our evaluation,
being a feasibility study, is limited in some aspects.
First, in Section 5.1, we used a simple editor developed
for our purposes. This setup does not allow for assessing
the ease of integration with more complex legacy edi-
tors. The main problems that might emerge while inte-
grating with an external editor are primarily associated
with architectural choices and the lack of technological
convergence. These limitations pose threat to the ex-
ternal validity of our feasibility evaluation. However,
these problems are largely mitigated by the relatively
loose restrictions the 0MQ-based architecture of lowkey
imposes.

Second, in Section 5.1, we used only three collab-
orators, while this number might be larger in realistic
settings. User intention [55] becomes harder to ensure as
the number of collaborators increases. The lower num-
ber of collaborators in our evaluation might threaten
conclusion validity. However, these threats are mainly
restricted to usability edge cases and do not aﬀect the
structural correctness of collaboratively developed mod-
els.

Finally, the relatively short example scenarios do
not allow observing scalability issues of CRDT caused
by the continuously growing number of accumulated
messages. However, scalability concerns have not been
the focus of this evaluation and we consider the topic
future work.

6 Discussion

In this section, we assess how lowkey compares to other
modeling and collaborative frameworks. Then, we re-
ﬂect on various aspects of the approach.

6.1 Comparison

We compare lowkey with frameworks that are closest in
their aim and feature set, shown in Table 1. These are
typically either modeling tools with multi-level model-
ing capabilities or tools with real-time collaborative fea-
tures. Our objective is to assess how lowkey compares in
terms of the key functionality of (i) metamodeling, (ii)
multi-level modeling, and (iii) real-time collaboration.
We ﬁnd that some tools partially overlap with lowkey
in terms of functionality; however, the combination of
the three key features is unique to lowkey.

Metamodeling, i.e., the ability to construct new
metamodels and modeling languages, is supported by
the majority of the sampled tools. MetaEdit+ [35] is
a widely adopted metamodeling framework. Locking at
the class level (not attributes) is the primary collabo-
rative mechanism, but there is no support for real-time
collaboration. MetaEdit+ represents a class of model-
ing tools that gained substantial industrial adoption,
and could beneﬁt from a real-time collaborative frame-
work such as lowkey. The two exceptions are TGRL [48]
and the MONDO framework [24]. TGRL is a tool for
requirements modeling in a collaborative way. MONDO
provides collaborative mechanisms for domain-speciﬁc
modeling.

Multi-level modeling, i.e., the ability to deﬁne
metamodels at an arbitrary number of meta-levels, is
supported by the mechanisms of deep characterization
[6] and deep instantiation [5]. AToMPM [58] is a web-
based multi-view modeling tool that allows for deﬁn-

16

I. David and E. Syriani

ing metamodels at arbitrary number of levels and in-
stantiating them by bootstrapping mechanisms. How-
ever, deep characterization and deep instantiation are
not supported. The Modelverse [62] is a modelware
back-end for storing and simulating models. It achieves
multi-level modeling by using a physical metamodel
similar to lowkey [61]. The same approach has been used
by deep metamodeling frameworks MetaDepth [20] and
Melanee [2]. Similar to lowkey, these tools use graphs
at the meta-circular level, i.e., the topmost linguistic
meta-level.

Real-time collaboration is becoming increasingly
adopted in model editors [17]. Tools such as WebGME
[39], SpacEclipse [29], FlexiSketch [67], and to some
extent SyncMeta [25] support metamodeling by shal-
low instantiation, augmented with real-time collabora-
tion capabilities. As a consequence of shallow instanti-
ation, these tools are restricted to a three-level meta-
hierarchy, such as OMG’s MOF or EMF [54]. A variety
of consistency models are employed in these tools to
support collaboration. Strong consistency, employed in
AToMPM, SpacEclipse, and FlexiSketch, ensures that
all participating nodes hold the exact same state of
the model at all times. However, due to its underlying
mechanisms, it signiﬁcantly hinders the scalability and
user experience of collaborative modeling tools [37]. In
AToMPM, real-time collaboration is supported in two
ways: at the levels of the abstract and concrete syn-
tax. In both cases, changes in the abstract syntax are
shared; in the latter case, changes in the representa-
tion are shared as well. Collaboration in SpacEclipse
and AToMPM requires manual conﬂict resolution,
while FlexiSketch uses preventive conﬂict management
techniques. WebGME relies on eventual consistency,
that provides the weaker guarantee that changes will
be eventually observed across each node [65]. However,
conﬂict resolution is not automated. Novel types of real-
time collaborative tools, such as TGRL and SyncMeta
employ strong eventual consistency (SEC) that com-
bines the beneﬁts of strong and eventual models [51]
and avoids conﬂicts altogether. TGRL and SyncMeta
implement real-time collaboration using the Teletype
and Yjs CRDT frameworks, respectively.

Summary. As shown in Table 1, lowkey provides a
unique combination of features for real-time collabo-
rative multi-level modeling. Typically, modeling frame-
works either provide multi-level modeling capabilities
without support for real-time collaboration (e.g., Mod-
elverse, MetaDepth); or provide real-time collaboration
capabilities without support for multi-level modeling
(e.g., WebGME, FlexiSketch). Closest to our work is
AToMPM, which provides limited facilities for multi-
level modeling, and supports real-time collaboration by

conservative consistency model and without automated
conﬂict resolution.

6.2 Physical metamodel

One of the main beneﬁts of the physical metamodel
is the uniform representation of objects and models,
irrespective of the linguistic meta-level they are situ-
ated at. This mechanism allows for the co-existence of
models with diﬀerent syntaxes and semantics. As a con-
sequence, the collaboration between diﬀerent modeling
tools becomes a more manageable endeavor.

We have chosen graphs as the meta-circular level.
That is, the physical metamodel corresponds to graphs,
and all linguistic models correspond to graphs as well.
As discussed in Section 6.1, graphs have been shown
to be an appropriate and versatile choice for such pur-
poses. We have implemented a directed multigraph for-
malism, i.e., edges have an unambiguous source and
target vertex, and multiple edges are allowed between
vertices. Directed edges enable navigability of associa-
tions in linguistic models, and the multigraph nature
enables deﬁning multiple diﬀerent associations between
the same pair of classes. Additionally, the physical meta-
model supports disconnected graphs. We found this prop-
erty useful in enabling the temporal tolerance of linguis-
tic inconsistencies. Additional graph properties can be
implemented and enforced, depending on the use-cases
to be supported by the framework.

Some scenarios might necessitate extending the phys-
ical metamodel with custom-built types. The feasibil-
ity of such techniques has been discussed in previous
work [19].

6.3 Temporal tolerance of linguistic inconsistencies

The separated physical metamodel allows for collabora-
tion in the presence of linguistic non-conformance (ver-
tical inconsistencies), enabling advanced collaboration
scenarios. For example, ensuring the consistency of a
model during the collaboration of stakeholders with dif-
ferent expertise might require tolerating linguistic non-
conformance. This has been demonstrated in Scenario 2
of Fig. 6. Here, the expertise of Client A is the instanti-
ation of objects and the expertise of Client B is organiz-
ing dangling objects into models. Already in this simple
example, we were able to introduce a non-conformance
between the instance model and the metamodel when
Client A did not link the newly created instance to
the root object immediately. In practical applications,
this issue is vastly exacerbated, as the number of stake-
holders, domains, formalisms, and tools increases. The

Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

17

CRDT persisting the physical metamodel ensure hori-
zontal consistency [64], i.e., stakeholders have a consis-
tent view of the system, even if these views are linguis-
tically incorrect. This enables a smooth collaboration
in the presence of linguistic non-conformance.

Tool builders can use lowkey for building safer appli-
cations with improved inconsistency management mech-
anisms. As demonstrated, temporal inconsistencies be-
tween modeling operations are naturally occurring phe-
nomena in modeling scenarios. The separation of physi-
cal and linguistic concerns enables well-formedness and
consistency rules to be captured at the most appropri-
ate levels of abstraction. For example, one might con-
strain their models at the physical level by enforcing
conformance to graphs and at the linguistic level to
class diagrams. Additionally, the domain-speciﬁc API
generation capabilities of lowkey—as demonstrated in
Section 5.1—further improve the safety of modeling
tools by allowing for a rich intermediate representa-
tion. Finally, tool integrators might want to consider
lowkey as the mediating layer in their tool chains. On
the one hand, lowkey is agnostic of the internal represen-
tations of the tools to be integrated, allowing to accom-
modate, in principle, any modeling formalism. On the
other hand, the multi-level metamodeling architecture
allows for ensuring consistency rules at arbitrary levels
of abstraction. The architecture of lowkey makes it espe-
cially suitable for developing complex applications and
tool chains. Tools to be integrated simply need to es-
tablish communication with the lowkey Server through
the 0MQ messaging broker used in our architecture.
The complexity of this step is substantially mitigated
by 0MQ’s support for a wide array of programming lan-
guages.

6.4 Support for complex modeling operations

Throughout this paper, we have assumed atomic change
operations (e.g., CRUD operations in the running ex-
ample). In practical modeling scenarios, more complex
domain-speciﬁc operations are often required to be sup-
ported, e.g., in the automation of large refactoring on
the model(s). In the running example, a promote oper-
ation could be deﬁned to move a subtopic with all its
children directly under the central topic, converting the
subtopic into a maintopic automatically. The need for
such strategies in multi-level modeling has been thor-
oughly discussed by de Lara and Guerra [21]. lowkey
provides the necessary mechanisms for implementing
complex operations in real-time collaborative multi-level
modeling settings. While complex modeling operations
are deﬁned at the level of the editor, lowkey allows for
treating these operations as ﬁrst-class citizens at the

CRDT API level, improving the safety of the software
application.

Depending on (i) the synchronicity of message trans-
mission between collaborators, and (ii) the timestamp-
ing strategy, there are at least three distinct ways to
treat complex operations in a CRDT-based collabora-
tive setting.

First, atomic operations can be aggregated at the
client side and transmitted all-at-once as soon as the
complex operation is composed, with each atomic op-
eration receiving the same timestamp. This strategy is
a natural choice in modeling editors in which atomic
operations of a complex functionality are conceptually
executed at the same time, with the complex opera-
tion being the unit of change. In other words, complex
operations are treated as transactions. The beneﬁt of
this strategy is that the aggregation logic of atomic op-
erations reﬂects the intentions of the originator: it is
the originator who decides which operations to com-
pose into a complex operation.

Second, similarly to the previous alternative, atomic
operations can be aggregated at the client side and
transmitted all-at-once, however, with each atomic op-
eration receiving its own timestamp. Conceptually, the
transmission of atomic operations is delayed until a
complex operation is built up at the client side. This al-
lows for beneﬁcial mechanisms at the originator’s side,
such as local undo-redo and rollback. At the receiving
end, atomic operations—–each with its own timestamp–
—have to be merged into the local replica. However,
the notion of aggregation is lost, unless the clients have
previously agreed on the same aggregation semantics.
Finally, atomic operations can be transmitted im-
mediately and aggregated at the receiving clients’ side.
Clearly, this is the opposite of the ﬁrst alternative where
the originator controls the aggregation. Here, it is the
receiving clients who decide what to aggregate and how.
This strategy is often used in stream processing and
complex event processing [16], where clients might be
interested in their own, domain-speciﬁc complex phe-
nomena. For example, a safety engineer who is part
of a collaboration might want to execute safety checks
after speciﬁc complex sequences of changes, but that
complex sequence might not interest others.

6.5 Opportunities in multi-view modeling

We anticipate multi-view modeling (MVM) [46] being
one of the main application areas of our approach. Views
are projections of one or multiple underlying models
[14], presenting stakeholders with only the essential in-
formation they require for their work. Views typically

18

I. David and E. Syriani

pertain to domains and expertise (e.g., the mechanical
and the electrical views in the design of a mechatronic
system), but they can pertain to speciﬁc use cases (e.g.,
electro-mechanic view) or expertise (e.g., chassis de-
sign). The architecture and services of lowkey align well
with the requirements of MVM. It is able to accom-
modate multiple diﬀerent metamodels, their instances,
and their views in a uniform fashion; thus allowing for
change propagation between linguistically and seman-
tically diﬀerent views. Model- and screen sharing [63]
are straightforward to implement, as tool builders can
outsource the data layer of their tools to lowkey.

Other approaches relying on an ensemble of multi-
ple models—such as multi-paradigm modeling (MPM)
[43], multi-modeling [9] and blended modeling [18]—
can beneﬁt from this approach as well. MPM advocates
modeling every aspect of the system at the most appro-
priate level(s) of abstraction using the most appropriate
formalism(s). The physical metamodel provides a basis
for synchronization among stakeholders, while diﬀerent
formalisms can be implemented at the linguistic level.
Similar techniques have been employed in the MPM
tool Modelverse [62].

6.6 Accommodating mainstream modeling frameworks

As demonstrated by Atkinson and Kühne [5], multi-
level modeling frameworks can emulate traditional mod-
eling frameworks using the notion of potency. Potency
is a constraint that speciﬁes how many times a class
can be instantiated transitively. As shown in Fig. 4,
the physical metamodel of lowkey deﬁnes a potency to
its Clabject element. By that, lowkey subsumes tradi-
tional modeling frameworks that operate on the mecha-
nism of shallow instantiation. We see an opportunity in
developing libraries for lowkey implementing the meta-
facilities of these traditional frameworks. The process
of adopting lowkey in already existing modeling tools
relying on such frameworks, e.g., MOF or EMF, can be
vastly improved and automated.

6.7 Limitations

Performance. The performance of CRDT is subject
to the number of objects present in the speciﬁc ap-
plication [56]. lowkey CRDT implement a soft delete
mechanism, i.e., objects are never removed from the
speciﬁc CRDT, but rather, “marked” as removed. The
LWWSet, for example, contains the removed elements in
its remove-set (see Section 4.4). As a consequence, the
performance of the CRDT layer will gradually decrease
as the number of objects increases. Our preliminary

measurements show linear degradation. Garbage col-
lection mechanisms have been suggested for managing
such limitations of CRDT-based applications [8].
Intention preservation [55] plays a key role in achiev-
ing an intuitive human-computer interaction and a smooth
user experience in collaborative settings. While the LWW
paradigm usually preserves the user’s intention, some
corner cases might result in model changes that are
less intuitive. The user makes decisions on changing
the model based on the model’s materialized view in
the modeling tool or browser. However, there might be
change updates from other collaborators on their way
that might arrive after the user carried out his changes.
These updates retroactively change the model in a way
that aﬀects the user’s reasoning. Since there is no way
to account for such messages, the user’s intention in
such corner cases cannot be guaranteed. While manual
conﬂict resolution would solve this issue, it would also
render real-time collaboration infeasible.
Timestamping mechanism. The current prototype
implementation of lowkey uses the time.time_ns() Python
function for timestamping changes. This function re-
turns time as an integer number of nanoseconds. How-
ever, this approach is prone to clock drift, which could
render CRDT inconsistent. Our working assumption is
that nanosecond-level drift does not aﬀect the dynam-
ics of collaborative modeling between humans, as the
interactions in such settings are at the level of sec-
onds. Nonetheless, lowkey can be extended by addi-
tional mechanisms to regularly synchronize clocks using
the Network Time Protocol (NTP)11 and other mech-
anisms described in Section 4.4.1.

7 Conclusion

In this paper, we have presented a real-time collabora-
tive framework for a wide range of advanced modeling
scenarios, supported by techniques of multi-level mod-
eling. Our framework provides a unique combination
of modeling capabilities and real-time collaboration. It
is built on a custom implementation of CRDT, geared
towards graph models, providing promising real-time
capabilities and scalability. We have deﬁned a mapping
of physical metamodels onto CRDT and demonstrated
the approach through an illustrative case.

We have identiﬁed multiple lines of future work. We
are planning to develop state-of-the-art collaborative
multi-view modeling mechanisms based on the frame-
work. To enable easier integration with legacy mod-
els, we will provide proﬁles for UML and EMF mod-
els, eﬀectively reproducing the respective meta-levels of

11

http://www.ntp.org/

Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

19

the OMG superstructure and Ecore. We plan to build
a family of modeling editors integrated with existing
modeling frameworks to augment them with real-time
collaborative capabilities. In more technical terms, we
are looking to improve the performance of the frame-
work by implementing advanced garbage collection mech-
anisms and a network stack with less overhead. We will
develop a benchmark for collaborative MDSE frame-
works to evaluate their scalability (with respect to con-
nected clients and messages exchanged), performance
(response time of a local operation being propagated to
each remote client), and usability in typical modeling
scenarios.

Acknowledgments

The authors would like to express their gratitude for
the insightful comments of the reviewers that helped
improve the initial manuscript.

References

1. Álvarez JM, Evans A, Sammut P (2001) Mapping
between levels in the metamodel architecture. In:
«UML» 2001 - The Uniﬁed Modeling Language,
Modeling Languages, Concepts, and Tools, 4th In-
ternational Conference, Toronto, Canada, October
1-5, 2001, Proceedings, Springer, LNCS, vol 2185,
pp 34–46

2. Atkinson C, Gerbig R (2016) Flexible Deep Mod-
eling with Melanee. In: Modellierung, GI, LNI, vol
255, pp 117–122

3. Atkinson C, Kühne T (2000) Meta-level

inde-
pendent modelling. In: European Conference on
Object-Oriented Programming, vol 12, p 16

4. Atkinson C, Kühne T (2001) The essence of multi-
level metamodeling. In: The Uniﬁed Modeling Lan-
guage, Modeling Languages, Concepts, and Tools,
Springer, LNCS, vol 2185, pp 19–33

5. Atkinson C, Kühne T (2002) Rearchitecting the
UML infrastructure. ACM Trans Model Comput
Simul 12(4):290–321

6. Atkinson C, Kühne T (2008) Reducing accidental
complexity in domain models. Software & Systems
Modeling 7(3):345–359

7. Atkinson C, Gutheil M, Kennel B (2009) A ﬂexible
infrastructure for multilevel language engineering.
IEEE Trans Software Eng 35(6):742–755

8. Bauwens J, Boix EG (2019) Memory eﬃcient
CRDTs in dynamic environments. In: International
Workshop on Virtual Machines and Intermediate
Languages, ACM, pp 48–57

9. Boronat A, Knapp A, Meseguer J, Wirsing M
(2008) What is a multi-modeling language? In: Re-
cent Trends in Algebraic Development Techniques,
19th International Workshop, Springer, LNCS, vol
5486, pp 71–87

10. Brambilla M, Cabot J, Wimmer M (2017) Model-
Driven Software Engineering in Practice, Second
Edition. Morgan & Claypool Publishers

11. Brasileiro F, Almeida JPA, de Carvalho VA, Guiz-
zardi G (2016) Applying a multi-level modeling
theory to assess taxonomic hierarchies in wikidata.
In: Bourdeau J, Hendler J, Nkambou R, Horrocks
I, Zhao BY (eds) Proceedings of the 25th Inter-
national Conference on World Wide Web, WWW
2016, Montreal, Canada, 2016, Companion Volume,
ACM, pp 975–980

12. Brewer E (2012) CAP twelve years later: How the
"rules" have changed. Computer 45(2):23–29
13. Buzan T (2006) The ultimate book of mind maps:
unlock your creativity, boost your memory, change
your life. HarperCollins UK

14. Corley J, Syriani E, Ergin H, Van Mierlo S (2016)
Modern Software Engineering Methodologies for
Mobile and Cloud Environments, IGI Global, chap
Cloud-based Multi-View Modeling Environments,
pp 120–139. 7

15. Davey BA, Priestley HA (2002) Introduction to
Lattices and Order, Second Edition. Cambridge
University Press

16. David I, Ráth I, Varró D (2018) Foundations
for streaming model transformations by complex
event processing. Software & Systems Modeling
17(1):135–162

17. David I, Aslam K, Faridmoayer S, Malavolta I, Syr-
iani E, Lago P (2021) Collaborative Model-Driven
Software Engineering: A Systematic Update. In:
Model Driven Engineering Languages and Systems,
ACM, pp 273–284

18. David I, Latifaj M, Pietron J, Zhang W, Ciccozzi
F, Malavolta I, Raschke A, Steghöfer JP, Hebig R
(2022) Blended Modeling in Commercial and Open-
source Model-Driven Software Engineering Tools:
A Systematic Study. Software & Systems Modeling
To appear.

19. David I, Syriani E, Masson C (2022) Extensible
Conﬂict-Free Replicated Datatypes for Real-time
Collaborative Software Engineering. In: Proceed-
ings of the 17th Conference on Computer Science
and Intelligence Systems (FedCSIS), IEEE, Soﬁa,
Bulgaria

20. de Lara J, Guerra E (2010) Deep Meta-modelling
with MetaDepth. In: Objects, Models, Compo-
nents, Patterns, Springer, LNCS, vol 6141, pp 1–20

20

I. David and E. Syriani

21. de Lara J, Guerra E (2018) Refactoring multi-
level models. ACM Trans Softw Eng Methodol
27(4):17:1–17:56

22. de Lara J, Guerra E, Cuadrado JS (2014) When
and How to Use Multilevel Modelling. ACM Trans
Softw Eng Methodol 24(2):12:1–12:46

23. De Porre K, Myter F, Troyer CD, Scholliers C,
Meuter WD, Boix EG (2019) Putting Order in
Strong Eventual Consistency. In: International Fed-
erated Conference on Distributed Computing Tech-
niques, Springer, Lecture Notes in Computer Sci-
ence, pp 36–56

24. Debreceni C, Bergmann G, Búr M, Ráth I, Varró
D (2017) The MONDO collaboration framework:
secure collaborative modeling over existing version
control systems. In: Foundations of Software Engi-
neering, ACM, pp 984–988

25. Derntl M, Nicolaescu P, Erdtmann S, Klamma R,
Jarke M (2015) Near Real-Time Collaborative Con-
ceptual Modeling on the Web. In: Conceptual Mod-
eling, Springer, LNCS, vol 9381, pp 344–357
26. Du J, Iorgulescu C, Roy A, Zwaenepoel W (2014)
GentleRain: Cheap and Scalable Causal Consis-
tency with Physical Clocks. In: Symposium on
Cloud Computing, ACM, pp 4:1–4:13

27. Fowler M, Scott K (2000) UML distilled - A brief
guide to the Standard Object Modeling Language
(2. ed.). Addison-Wesley-Longman

28. Franzago M, Ruscio DD, Malavolta I, Muc-
cini H (2018) Collaborative Model-Driven Soft-
ware Engineering: A Classiﬁcation Framework
and a Research Map. IEEE Trans Software Eng
44(12):1146–1175

29. Gallardo J, Bravo C, Redondo MA (2012) A model-
driven development method for collaborative mod-
eling tools. J Netw Comput Appl 35(3):1086–1105
30. Gonzalez-Perez C, Henderson-Sellers B (2008)
Metamodelling for software engineering. Wiley
31. Grosch P, Kraﬀt R, Wölki M, Bieniusa A (2020)
Autocouch: a JSON CRDT framework. In: Work-
shop on Principles and Practice of Consistency for
Distributed Data, ACM, pp 6:1–6:7

32. Herbsleb JD (2007) Global Software Engineering:
The Future of Socio-technical Coordination. In: In-
ternational Conference on Software Engineering,
IEEE, pp 188–198

33. Izquierdo JLC, Cabot J (2016) Collaboro: a collab-
orative (meta) modeling tool. PeerJ Comput Sci
2:e84

34. Johnson PR, Thomas R (1975) Maintenance of du-

plicate databases. RFC 677:1–10

35. Kelly S (2017) Collaborative modelling with ver-
sion control. In: Software Technologies: Applica-

tions and Foundations, Springer, LNCS, pp 20–29
36. Kühne T (2022) Multi-dimensional multi-level

modeling. Softw Syst Model 21(2):543–559

37. Lamport L (1978) Time, Clocks, and the Ordering
of Events in a Distributed System. Commun ACM
21(7):558–565

38. Le Noir J, Delande O, Exertier D, da Silva MAA,
Blanc X (2011) Operation based model represen-
tation: Experiences on inconsistency detection. In:
Modelling Foundations and Applications – 7th Eu-
ropean Conference, Springer, LNCS, vol 6698, pp
85–96

39. Maróti M, Kecskés T, Kereskényi R, Broll B, Völ-
gyesi P, Jurácz L, Levendovszky T, Lédeczi Á
(2014) Next Generation (Meta)Modeling: Web- and
Cloud-based Collaborative Tool Infrastructure. In:
Multi-Paradigm Modeling, CEUR-WS, pp 41–60
40. Meiklejohn C, Van Roy P (2015) Lasp: a language
for distributed, coordination-free programming. In:
Principles and Practice of Declarative Prog., ACM,
pp 184–195

41. Michaux J, Blanc X, Shapiro M, Sutra P (2011) A
semantically rich approach for collaborative model
edition. In: Proceedings of the 2011 ACM Sym-
posium on Applied Computing (SAC), ACM, pp
1470–1475

42. Mistrík I, Grundy J, van der Hoek A, Whitehead J
(2010) Collaborative Software Engineering: Chal-
lenges and Prospects. In: Collaborative Software
Engineering, Springer, pp 389–403

43. Mosterman PJ, Vangheluwe H (2004) Computer
Automated Multi-Paradigm Modeling: An Intro-
duction. Simulation 80(9):433–450

44. Muccini H, Bosch J, van der Hoek A (2018) Col-
laborative Modeling in Software Engineering. IEEE
Software 35(6):20–24

45. Preguiça NM, Marquès JM, Shapiro M, Letia M
(2009) A Commutative Replicated Data Type for
Cooperative Editing. In: International Conference
on Distributed Computing Systems, IEEE, pp 395–
403

46. Reineke J, Tripakis S (2014) Basic Problems in
Multi-View Modeling. In: Tools and Algorithms
for the Construction and Analysis of Systems,
Springer, LNCS, pp 217–232

47. Roh H, Jeon M, Kim J, Lee J (2011) Replicated
abstract data types: Building blocks for collabo-
rative applications. J Parallel Distributed Comput
71(3):354–368

48. Saini R, Mussbacher G (2021) Towards Conﬂict-
Free Collaborative Modelling using VS Code Ex-
tensions. In: Model-Driven Engineering Languages
and Systems: Companion Proceedings, ACM, pp

Real-time Collaborative Multi-Level Modeling by Conﬂict-Free Replicated Data Types

21

and simulation. In: Winter Simulation Conference,
IEEE, pp 944–955

63. Van Tendeloo Y, Vangheluwe H (2018) Unifying
model- and screen sharing. In: Enabling Technolo-
gies: Infrastructure for Collaborative Enterprises,
IEEE, pp 127–132

64. Vanherpen K, Denil J, David I, Meulenaere
PD, Mosterman PJ, Törngren M, Qamar A,
Vangheluwe H (2016) Ontological reasoning for
consistency in the design of cyber-physical systems.
In: Int. Workshop on Cyber-Physical Production
Systems, IEEE, pp 1–8

65. Vogels W (2009) Eventually Consistent. Communi-

cations of the ACM 52(1):40–44

66. Whitehead J (2007) Collaboration in Software En-
gineering: A Roadmap. In: International Confer-
ence on Software Engineering, IEEE, pp 214–225

67. Wüest D, Seyﬀ N, Glinz M (2012) FlexiSketch:
A Mobile Sketching Tool for Software Modeling.
In: Mobile Computing, Applications, and Services,
Springer, Lecture Notes of the Institute for Com-
puter Sciences, Social Informatics and Telecommu-
nications Engineering, vol 110, pp 225–244

35–44

49. Saito Y, Shapiro M (2005) Optimistic replication.

ACM Comput Surv 37(1):42–81

50. Schmidt DC (2006) Model-Driven Engineering.

IEEE Computer 39(2):25–31

51. Shapiro M, Preguiça N, Baquero C, Zawirski M
(2011) A comprehensive study of convergent and
commutative replicated data types. Tech. rep.,
Inria–Centre Paris-Rocquencourt; INRIA

52. Shapiro M, Preguiça NM, Baquero C, Zawirski M
(2011) Conﬂict-Free Replicated Data Types. In:
Stabilization, Safety, and Security of Distributed
Systems - 13th Int. Symposium, Springer, Lecture
Notes in Computer Science, vol 6976, pp 386–400
53. Singhal M, Kshemkalyani AD (1992) An eﬃcient
implementation of vector clocks. Inf Process Lett
43(1):47–52

54. Steinberg D, Budinsky F, Merks E, Paternostro M
(2008) EMF: Eclipse Modeling Framework. Pearson
Education

55. Sun C, Jia X, Zhang Y, Yang Y, Chen D (1998)
Achieving Convergence, Causality Preservation,
and Intention Preservation in Real-Time Cooper-
ative Editing Systems. ACM Trans Comput-Hum
Interact 5(1):63–108

56. Sun D, Sun C (2006) Operation Context and
Context-based Operational Transformation.
In:
Conference on Computer Supported Cooperative
Work, ACM, pp 279–288

57. Sun D, Sun C, Ng A, Cai W (2020) Real Diﬀerences
between OT and CRDT in Correctness and Com-
plexity for Consistency Maintenance in Co-Editors.
Proc ACM Hum-Comput Interact 4

58. Syriani E, Vangheluwe H, Mannadiar R, Hansen C,
Mierlo SV, Ergin H (2013) AToMPM: A Web-based
Modeling Environment. In: Model-Driven Engi-
neering Languages and Systems, CEUR-WS.org,
vol 1115, pp 21–25

59. Taentzer G, Ermel C, Langer P, Wimmer M (2010)
Conﬂict detection for model versioning based on
graph modiﬁcations. In: Graph Transformations
– 5th International Conference, ICGT, Springer,
LNCS, vol 6372, pp 171–186

60. Thomas RH (1979) A majority consensus approach
to concurrency control for multiple copy databases.
ACM Transactions on Database Systems (TODS)
4(2):180–209

61. Van Mierlo S, Barroca B, Vangheluwe H, Syriani E,
Kühne T (2014) Multi-level modelling in the mod-
elverse. In: Workshop on Multi-Level Modelling,
CEUR-WS, pp 83–92

62. Van Tendeloo Y, Vangheluwe H (2017) The Mod-
for Multi-Paradigm Modelling

elverse: A tool

