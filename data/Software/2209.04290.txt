2
2
0
2

g
u
A
5
1

]
E
S
.
s
c
[

1
v
0
9
2
4
0
.
9
0
2
2
:
v
i
X
r
a

Conformance Checking for Trace Fragments
Using Inï¬x and Postï¬x Alignments

Daniel Schuster1,2[0000âˆ’0002âˆ’6512âˆ’9580], Niklas FÂ¨ocking1, Sebastiaan J. van
Zelst1,2[0000âˆ’0003âˆ’0415âˆ’1036], and Wil M. P. van der Aalst1,2[0000âˆ’0002âˆ’0955âˆ’6940]

1 Fraunhofer Institute for Applied Information Technology FIT, Germany
{daniel.schuster,niklas.foecking,sebastiaan.van.zelst}@fit.fraunhofer.de
2 RWTH Aachen University, Aachen, Germany
wvdaalst@pads.rwth-aachen.de

Abstract. Conformance checking deals with collating modeled process
behavior with observed process behavior recorded in event data. Align-
ments are a state-of-the-art technique to detect, localize, and quantify
deviations in process executions, i.e., traces, compared to reference pro-
cess models. Alignments, however, assume complete process executions
covering the entire process from start to ï¬nish or preï¬xes of process exe-
cutions. This paper deï¬nes inï¬x/postï¬x alignments, proposes approaches
to their computation, and evaluates them using real-life event data.

Keywords: Process mining Â· Conformance checking Â· Alignments.

1

Introduction

Information systems track the execution of organizationsâ€™ operational processes
in detail. The generated event data describe process executions, i.e., traces. Con-
formance checking [2] compares traces from event data with process models.
Alignments [8], a state-of-the-art conformance checking technique, are widely
used, e.g., for quantifying process compliance and evaluating process models.

Most conformance checking techniques relate complete traces, covering the
process from start to ï¬nish, to reference process models. Processes are often
divided into stages representing diï¬€erent logical/temporal phases; thus, confor-
mance requirements can vary by stage. Conformance checking for trace fragments
covering conformance-critical phases is therefore useful. Also, event data often
needs to be combined from various data sources to analyze a process holistically.
Thus, conformance checking for trace fragments is valuable as complete traces
are not required. While there is the notion of preï¬x alignments [1], deï¬nitions
and calculation methods for inï¬x/postï¬x alignments do not yet exist.

This paper deï¬nes inï¬x/postï¬x alignments and presents their computation.
Fig. 1 outlines our contributions. The computation of inï¬x/postï¬x alignments
builds on existing work on calculating (preï¬x) alignments [1]. For (preï¬x) align-
ment computation, the synchronous product net (SPN) [1] is created that deï¬nes
the search space of the corresponding alignment computation, i.e., a shortest
path search. In this paper, we modify the SPN to adapt it for inï¬x/postï¬x

 
 
 
 
 
 
2

D. Schuster et al.

Fig. 1: Overview of our approach regarding inï¬x/postï¬x alignment computation

alignment computation by using an auxiliary process model (cf. Fig. 1) as input
instead of the reference process model. The actual search for the shortest path
in the state space of the SPN remains unchanged compared to (preï¬x) align-
ments apart from diï¬€erent goal states. We propose two approaches to derive an
auxiliary process model. One assumes sound workï¬‚ow nets [7], i.e., a subclass
of Petri nets often used to model business processes, and the second assumes
block-structured workï¬‚ow nets, i.e., process trees, a subclass of sound WF-nets.
In the remainder of this paper, we present related work (Sect. 2), preliminar-
ies (Sect. 3), deï¬ne inï¬x/postï¬x alignments (Sect. 4), present their computation
(Sect. 5), and evaluate the proposed computation (Sect. 6).

2 Related Work

We refer to [2,3] for overviews on conformance checking. Subsequently, we focus
on alignments [1,8], which provide a closest match between a trace and a valid ex-
ecution of a given process model. In [1,2] it is shown that alignment computation
can be reduced to a shortest path problem. Further improvements by using alter-
native heuristics during the search are proposed in [11]. However, the state space
of the shortest path problem can grow exponentially depending on the model
and the trace [2]. Therefore, approaches for approximating alignments exist, for
example, divide-and-conquer [6] and search space reduction approaches [10].

Alignments [1,8] are deï¬ned for complete traces that are aligned to a complete
execution of a given process model. Additionally, preï¬x alignments exist [1],
which are, for example, utilized for online conformance checking [5]. In this
paper, we deï¬ne inï¬x/postï¬x alignments and demonstrate their computation.
To the best of our knowledge, no related work exists on inï¬x/postï¬x alignments.

3 Background

Given a set X, a multiset B over X can contain elements of X multiple times.
For X={x, y, z}, the multiset [x5, y] contains 5 times x, once y and no z. The set

Paperâ€˜sscopeCompleteTraceorTraceprefixCompletealignmentorPrefixalignmentTraceinfixorTracepostfixInfix alignmentorPostfix alignmentSynchronousproductnet(SPN)ExistingworkSynchronousproductnet(SPN)Auxiliary process model Alignment computation(i.e., shortestpathserachon thestatespaceoftheSPN1)1 Note that the goal states differ depending on whether complete, prefix, infix, or postfix alignments are calculated.(Reference)processmodelConformance Checking for Trace Fragments

3

p1

t1 p2
a

p3

t2
b

t3
c

t4
d

p4

p5

t5 p7
Ï„

p6

p8

t6
e

t7
f
t8
g

t10
h

p12

p11

p9

t9
Ï„

p10

Fig. 2: Example Petri net, i.e., a sound WF-net, modeling a process consisting of
activities a, . . . , h. The initial marking mi=[p1], and the ï¬nal marking mf =[p12].

of all possible multisets over a base set X is denoted by B(X). We write xâˆˆB if
x is contained at least once in multiset B. Given two multisets b1, b2âˆˆB(X), we
denote their union by B1 (cid:93) B2. Finally, given two sets containing multisets, i.e.,
B1, B2 âŠ† B(X), we deï¬ne the Cartesian by B1Ã—B2 = {b1(cid:93)b2 | b1âˆˆB1 âˆ§ b2âˆˆB2}.
For example, (cid:8)[a2, b], [c](cid:9)Ã—(cid:8)[d3](cid:9) = (cid:8)[a2, b, d3], [c, d3](cid:9).

A sequence Ïƒ of length |Ïƒ|=n over a set X assigns an element to each index,
i.e., Ïƒ : {1, . . . , n}â†’X. We write a sequence Ïƒ as (cid:104)Ïƒ(1), Ïƒ(2), ..., Ïƒ(|Ïƒ|)(cid:105). The set
of all potential sequences over set X is denoted by X âˆ—. Given ÏƒâˆˆX âˆ— and xâˆˆX,
(cid:0)Ïƒ(i)=x(cid:1), e.g., bâˆˆ(cid:104)a, b(cid:105). Let ÏƒâˆˆX âˆ— and let X (cid:48)âŠ†X. We
we write xâˆˆÏƒ if âˆƒ1â‰¤iâ‰¤|Ïƒ|
if xâˆˆX (cid:48) and
recursively deï¬ne Ïƒâ†“X(cid:48) âˆˆX (cid:48)âˆ— with: (cid:104)(cid:105)â†“X(cid:48) =(cid:104)(cid:105), ((cid:104)x(cid:105)Â·Ïƒ)â†“X(cid:48) =(cid:104)x(cid:105)Â·Ïƒâ†“X(cid:48)
1 , . . . , xm
((cid:104)x(cid:105)Â·Ïƒ)â†“X(cid:48) =Ïƒâ†“X(cid:48) if x /âˆˆX (cid:48). For a sequence Ïƒ=(cid:104)(x1
n )(cid:105) âˆˆ
(X1Ã— . . . Ã—Xn)âˆ— containing n-tuples, we deï¬ne projection functions Ï€âˆ—
1(Ïƒ)=(cid:104)x1
1,
. . . , xm
n (cid:105). For instance, Ï€âˆ—
2((cid:104)(a, b), (c, d), (c, b)(cid:105))=(cid:104)b, d, b(cid:105).
Event data describe the execution of business processes. An event log can be
seen as a multiset of process executions, i.e., traces, of a single business process.
We denote the universe of process activity labels by A. Further, we deï¬ne a
complete/inï¬x/postï¬x trace as a sequence of executed activities, i.e., ÏƒâˆˆAâˆ—.

n), . . . , (xm

1 (cid:105), . . . , Ï€âˆ—

n(Ïƒ)=(cid:104)x1

n, . . . , xm

1, . . . , x1

3.1 Process Models

Next, we introduce formalisms to model processes: Petri nets [7] and process
trees. Fig. 2 shows an example Petri net. Next, we deï¬ne accepting Petri nets.

Deï¬nition 1 (Accepting Petri net). An accepting Petri net N = (P, T, F, mi,
mf , Î») consists of a ï¬nite set of places P , a ï¬nite set of transitions T , a ï¬nite set
of arcs F âŠ† (P Ã—T )âˆª(T Ã—P ), and a labeling function Î» : T â†’ Aâˆª{Ï„ }. We denote
the initial marking with mi âˆˆ B(P ) and the ï¬nal marking with mf âˆˆ B(P ).

In the remainder of this paper, we say Petri nets when referring to accepting
Petri nets. Given a Petri net N =(P, T, F, mi, mf , Î») and markings m, m(cid:48)âˆˆB(P ),
if a transition sequence ÏƒâˆˆT âˆ— leads from m to m(cid:48), we write (N, m) Ïƒâˆ’â†’(N, m(cid:48)). If
m(cid:48) is reachable from m, we write (N, m)(cid:32)(N, m(cid:48)). Further, we write (N, m)[t(cid:105)
if tâˆˆT is enabled in m. We let R(N, mi)={m(cid:48)âˆˆB(P ) | (N, mi)(cid:32)(N, m(cid:48))} denote
the state space of N , i.e., all markings reachable from mi. In this paper, we
assume that process models are sound workï¬‚ow nets (WF-nets) [7].

4

D. Schuster et al.

âˆ§

Ã—

â†’

n0

n1.4

n1.2

n2.3

d
n1.3

a
n1.1

Process trees represent block-structured
WF-nets, a subclass of sound WF-nets [4].
Fig. 3 shows an example tree modeling the
same behavior as the WF-net in Fig. 2.
Inner nodes represent control ï¬‚ow oper-
ators, and leaf nodes represent activities.
Four operators exist: sequence (â†’), par-
allel (âˆ§), loop ((cid:9)), and exclusive-choice
Fig. 3: Process tree T modeling the
(Ã—). Next, we deï¬ne process trees.
same process as the WF-net in Fig. 2
Deï¬nition 2 (Process Tree). Let (cid:76) ={â†’, Ã—, âˆ§, (cid:9)} be the set of operators. A
process tree T =(V, E, Î», r) consists of a totally ordered set of nodes V , a set of
edges EâŠ†V Ã—V , a labeling function Î»:V â†’Aâˆª{Ï„ }âˆª (cid:76), and a root node râˆˆV .
â€“ (cid:0){n}, {}, Î», n(cid:1) with dom(Î»)={n} and Î»(n)âˆˆAâˆª{Ï„ } is a process tree
â€“ given k>1 trees T1=(V1, E1, Î»1, r1), . . . , Tk=(Vk, Ek, Î»k, rk) with r /âˆˆV1âˆª . . . âˆªVk

c
n2.2

e
n3.1

f
n3.2

b
n2.1

h
n1.5

n2.4

âˆ§

g

and âˆ€i, jâˆˆ{1, . . . , k}(i(cid:54)=j â‡’ Viâˆ©Vj=âˆ…) then T =(V, E, Î», r) is a tree s.t.:

â€¢ V =V1âˆª . . . âˆªVkâˆª{r}
â€¢ E=E1âˆª . . . âˆªEkâˆª(cid:8)(r, r1), . . . , (r, rk)(cid:9)
â€¢ dom(Î»)=V with Î»(x)=Î»j(x) for all jâˆˆ{1, . . . , k}, xâˆˆVj,

Î»(r)âˆˆ (cid:76), and Î»(r)=(cid:9) â‡’ k=2

T denotes the universe of process trees. We refer to [4] for a deï¬nition of process
tree semantics. Given T =(V, E, Î», r)âˆˆT , the child function cT :V â†’V âˆ— returns
a sequence of child nodes, e.g., cT (n0)=(cid:104)n1.1, . . . , n1.5(cid:105), cf. Fig. 3. The parent
function pT :V (cid:57)V returns a nodeâ€™s parent; e.g., p(n2.4)=n1.4. For nâˆˆV , T (n)âˆˆT
denotes the subtree with root n; e.g., T (n2.3) denotes the subtree rooted at node
n2.3 (cf. Fig. 3). For T âˆˆT , we denote its language-equivalent WF-net by N T .

3.2 Alignments

This section introduces alignments [1,2]. Fig. 4 shows an example for the WF-net
shown in Fig. 2 and trace Ïƒ=(cid:104)d, a, e, h(cid:105). An alignmentâ€™s ï¬rst row, i.e., the trace
part, equals the given trace if the skip symbol (cid:29) is ignored. The second row, i.e.,
the model part, equals a sequence of transitions (ignoring (cid:29)) leading from the
initial to the ï¬nal marking. An alignment is composed of moves, for instance,
each column in Fig. 4 represents a move; we distinguish four:

â€“ synchronous moves indicate a match between the model and the trace,

â€“ log moves indicate a mismatch, i.e., the current activity in the trace is

not replayed in the model,

â€“ visible model moves indicate a mismatch, i.e., the model executes an

activity not observed in the trace at this stage, and

â€“ invisible model moves indicate no real mismatch, i.e., a model move on

a transition labeled with Ï„ .

Since we are interested in an alignment ï¬nding the closest execution of the model
to a given trace, the notion of optimality exists. An alignment for a model and
trace is optimal if no other alignment exist with less visible model and log moves.

Conformance Checking for Trace Fragments

5

d

(cid:29)

a
t1
(Î»(t1)=a)

(cid:29)
t3
(Î»(t3)=c)

(cid:29)
t2
(Î»(t2)=b)

(cid:29)
t4
(Î»(t4)=d)

(cid:29)

t5

e
t6
(Î»(t6)=e)

(cid:29)
t7
(Î»(t7)=f )

(cid:29)

t9

h
t10
(Î»(t10)=h)

Fig. 4: Optimal alignment for the WF-net shown in Fig. 2 and Ïƒ=(cid:104)d, a, e, h(cid:105)

d
t4
(Î»(t4)=d)

(cid:29)

t5

g
t8
(Î»(t8)=g)

b
t2
(Î»(t2)=b)

d
t4
(Î»(t4)=d)

(cid:29)

t5

f
t7
(Î»(t7)=f )

(a) Inï¬x alignment for Ïƒ=(cid:104)d, g(cid:105)
g
t8
(Î»(t8)=g)

(cid:29)
t10
(Î»(t10)=h)

d
t4
(Î»(t4)=d)

a

(b) Inï¬x alignment for Ïƒ=(cid:104)b, d, f (cid:105)
g
t8
(Î»(t8)=g)

(cid:29)
t10
(Î»(t10)=h)

d
t4
(Î»(t4)=d)

(cid:29)

(c) Postï¬x alignment for Ïƒ=(cid:104)d, g(cid:105)

(d) Postï¬x alignment for Ïƒ=(cid:104)a, d, g(cid:105)

Fig. 5: Optimal inï¬x and postï¬x alignments for the WF-net shown in Fig. 2

4

Inï¬x and Postï¬x Alignments

This section deï¬nes inï¬x and postï¬x alignments. Inï¬x alignments align a given
trace inï¬x against an inï¬x of the WF-netâ€™s language. Thus, the model part of an
inï¬x alignment starts at some reachable marking from the given WF-netâ€™s initial
marking and ends at an arbitrary marking. Fig. 5 depicts two inï¬x alignments for
the WF-net shown in Fig. 2. As for alignments, the ï¬rst row of an inï¬x alignment
corresponds to the given trace inï¬x (ignoring (cid:29)). The second row corresponds
to a ï¬ring sequence (ignoring (cid:29)) starting from a WF-netâ€™s reachable marking.
Postï¬x alignments follow the same concept as inï¬x alignments. A postï¬x
alignmentâ€™s model part starts at a reachable marking but ends at the WF-netâ€™s
ï¬nal marking. Fig. 5 shows examples of postï¬x alignments for the WF-net shown
in Fig. 2. As for alignments, the notion of optimality applies equally to inï¬x and
postï¬x alignments. Next, we deï¬ne complete, inï¬x, and postï¬x alignments.

Deï¬nition 3 (Complete/inï¬x/postï¬x alignment). Let ÏƒâˆˆAâˆ— be a com-
plete/inï¬x/postï¬x trace, N =(P, T, F, mi, mf , Î») be a WF-net, and (cid:29) /âˆˆAâˆªT . A
sequence Î³âˆˆ(cid:0)(Aâˆª{(cid:29)}) Ã— (T âˆª{(cid:29)})(cid:1)âˆ—
is an complete/inï¬x/postï¬x alignment if:
1. Ïƒ=Ï€âˆ—

1(Î³)â†“A

2. â€“ Complete alignment: (N, mi)

Ï€âˆ—
2 (Î³)â†“T
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (N, mf )

â€“ Inï¬x alignment:
(N, mi) (cid:32) (N, m1)
â€“ Postï¬x alignment:
Ï€âˆ—
2 (Î³)â†“T
(N, mi) (cid:32) (N, m1)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (N, mf ) for m1âˆˆR(N, mi)
(cid:0)Î»(t)(cid:54)=a â‡’ (a, t) /âˆˆÎ³(cid:1)
3. ((cid:29), (cid:29)) /âˆˆÎ³ âˆ§ âˆ€aâˆˆA,tâˆˆT

Ï€âˆ—
2 (Î³)â†“T
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (N, m2) (cid:32) (N, mf ) for m1, m2âˆˆR(N, mi)

6

D. Schuster et al.

5 Computing inï¬x/postï¬x alignments

The given reference process model cannot be immediately used to compute in-
ï¬x/postï¬x alignments because it requires starting in the initial marking mi.
Thus, our approach (cf. Fig. 1) constructs an auxiliary process model.

Reconsider the second requirement of the inï¬x/postï¬x alignments deï¬nition.
For both inï¬x/postï¬x alignments, the model part starts with a transition enabled
in marking m1 that is reachable from the initial marking mi. Hereinafter, we
refer to candidate markings for m1 (cf. Def. 3) as relevant markings. The central
question is how to eï¬ƒciently calculate relevant markings that might represent
the start of an inï¬x/postï¬x alignment in its model part. Below, we summarize
our overall approach for inï¬x/postï¬x alignment computation.
1. Calculate relevant markings in the given WF-net that may represent the
start of the inï¬x/postï¬x alignment in the model part, cf. m1 in Def. 3.

2. Create the auxiliary WF-net using the relevant markings (cf. Def. 4).
3. Create the SPN using the auxiliary WF-net and the given trace inï¬x/postï¬x.
4. Perform a shortest path search on the SPNâ€™s state space with corresponding

goal markings, i.e., goal states regarding the shortest path search.

â€“ Inï¬x alignment: goal markings contain the last place of the SPNâ€™s

trace net part

â€“ Postï¬x alignment: standard ï¬nal marking of the SPN [1,2]

5. Inï¬x/postï¬x alignment post-processing: removal of the invisible model move
that results from using the auxiliary WF-net instead of the original WF-net.
The ï¬rst two steps are essential, i.e., the generation of the auxiliary WF-net. The
subsequent SPN generation remains unchanged compared to alignments [1,2].
Likewise, the shortest path search on the SPNâ€™s state space is unchanged com-
pared to alignments; however, the goal marking(s) diï¬€er, see above. Subse-
quently, we present two approaches for constructing the auxiliary WF-net.

5.1 Baseline Approach for Auxiliary WF-net Construction

This section presents a baseline approach for constructing the auxiliary WF-net.
This approach assumes a sound WF-net N =(P, T, F, mi, mf , Î») as reference pro-
cess model. As sound WF-nets are bounded [9], their state space is ï¬nite. Thus,
we can list all reachable markings R(N, mi)={m1, . . . , mn}; the baseline ap-
proach considers all reachable markings as relevant markings. Given N , the
baseline approach adds a new place p0, representing also the new initial marking
[p0], and n silent transitions allowing to reach one of the markings {m1, . . . , mn}
from [p0]. Thus, when constructing the corresponding SPN using the auxiliary
WF-net, it is possible from the SPNâ€™s initial marking to execute a transition
representing an invisible model move that marks the model part at some reach-
able marking m1 (cf. Def. 3). Fig. 6 shows the auxiliary WF-net of the WF-net
shown in Fig. 2. Below we generally deï¬ne the auxiliary WF-net for a given set
of relevant markings. Note that for the auxiliary WF-net constructed by the
baseline approach, the set of relevant markings {m1, . . . , mn} = R(N, mi).

Conformance Checking for Trace Fragments

7

t(cid:48)
7
Ï„

t5 p7
Ï„

p6

p8

t(cid:48)
9
Ï„
t(cid:48)
8
Ï„
t6
e

t7
f

g
t8

p9

t9
Ï„

p10

t(cid:48)
10
Ï„

t(cid:48)
11
Ï„

p11

t10
h

t(cid:48)
12
Ï„

p12

t(cid:48)
2
Ï„
t1 p2
a
t(cid:48)
3
Ï„

p3

t(cid:48)
4
Ï„
t2
b

t3
c
t(cid:48)
5
Ï„

p4

p5

t4
d

t(cid:48)
6
Ï„

p(cid:48)
0

t(cid:48)
1
Ï„

p1

Fig. 6: Auxiliary WF-net constructed using the baseline approach (Sect. 5.1) of
the WF-net shown in Fig. 2. Red elements are not contained if the baseline
approach with subsequent ï¬ltering is used (for the example inï¬x Ïƒ=(cid:104)b, d, f (cid:105)).

Deï¬nition 4 (Auxiliary WF-net). Let N =(P, T, F, mi, mf , Î») be a WF-net
and {m1, . . . , mn}âŠ†R(N, mi) be the given set of relevant markings. We deï¬ne
the auxiliary WF-net N (cid:48) = (P (cid:48), T (cid:48), F (cid:48), m(cid:48)

i, m(cid:48)

f , Î»(cid:48)) with:

0 /âˆˆ P )

â€“ P (cid:48) = P âˆª {p(cid:48)
â€“ T (cid:48) = T âˆª {t(cid:48)
â€“ F (cid:48) = F âˆª {(p(cid:48)
â€“ m(cid:48)
i = [p(cid:48)
â€“ Î»(cid:48)(tj)=Î»(tj) for all tjâˆˆT and Î»(cid:48)(t(cid:48)

0} (assuming p(cid:48)
j | 1â‰¤jâ‰¤n}
0, t(cid:48)
0] and m(cid:48)

j) | 1â‰¤jâ‰¤n} âˆª {(t(cid:48)
f = mf

j, p) | 1â‰¤jâ‰¤n âˆ§ pâˆˆmj}

j)=Ï„ for all t(cid:48)

jâˆˆT (cid:48)\T

When creating the SPN using the auxiliary WF-net and a given trace in-
ï¬x/postï¬x, the added transitions in the auxiliary WF-net correspond to invisible
model moves. For example, reconsider the inï¬x alignment in Fig. 5a. The inï¬x
alignment for Ïƒ=(cid:104)d, g(cid:105) and auxiliary WF-net shown in Fig. 6 returned after step
5. As this invisible model move on t(cid:48)
4 contains an invisible model move on t(cid:48)
5
is the result of using the auxiliary WF-net instead of the original WF-net for
which we calculate an inï¬x/postï¬x alignment, we must remove it, i.e., Step 5.

Improved Baseline by Subsequent Filtering Instead of considering all
reachable markings as relevant markings, we ï¬lter markings not enabling tran-
sitions whose labels are contained in the given inï¬x/postï¬x Ïƒ. Reconsider the
auxiliary WF-net shown Fig. 6; red elements are not included if subsequent ï¬l-
tering is used for the example inï¬x Ïƒ=(cid:104)b, d, f (cid:105). For instance, t(cid:48)
1 is not included,
as the marking reached [p1] only enables t1 with Î»(t1)=a /âˆˆÏƒ. Below, we deï¬ne
the relevant markings for a WF-net N =(P, T, F, mi, mf , Î») and inï¬x/postï¬x Ïƒ.

(cid:8)mâˆˆR(N, mi) | âˆƒtâˆˆT

(cid:0)(N, m)[t(cid:105) âˆ§ Î»(t)âˆˆÏƒ(cid:1)(cid:9) âˆª (cid:8)mf

(cid:9)

Note that the auxiliary WF-net constructed by the baseline approach without
ï¬ltering is independent of the provided trace inï¬x/postï¬x. However, the auxiliary

8

D. Schuster et al.

p(cid:48)
0

p1

t1 p2
a
t(cid:48)
3
Ï„

p3

t5 p7
Ï„

p6

p8

t2
b

t3
c
t(cid:48)
5
Ï„

t4
d

p4

p5

t(cid:48)
8
Ï„
t6
e

t7
f

g
t8

t(cid:48)
12
Ï„

p12

t10
h

p11

p9

t9
Ï„

p10

Fig. 7: Auxiliary WF-net constructed using the advanced approach (cf. Sect. 5.2)
for the block-structured WF-net shown in Fig. 2 and the inï¬x Ïƒ=(cid:104)b, d, f (cid:105)

WF-net constructed by the baseline plus subsequent ï¬ltering depends on the
provided model and the trace inï¬x/postï¬x.

5.2 Advanced Auxiliary WF-net Construction for Process Trees

This section introduces an advanced approach for constructing an auxiliary WF-
net from a given block-structured WF-net, i.e., a process tree. Compared to the
baseline, the advanced approach aims to reduce the number of relevant markings.
Further, the advanced approach determines relevant markings directly instead
of computing all reachable markings and subsequently ï¬ltering (cf. Sect. 5.1).

Assume the WF-net from Fig. 2 and the inï¬x/postï¬x Ïƒ=(cid:104)b, d, f (cid:105). Reconsider
the auxiliary WF-net shown in Fig. 6; jumping to marking [p2, p3] within the
model using the transition t(cid:48)
2 does not make sense if we can also jump to marking
[p2, p5]. From [p2, p3] we can replay b and c. However, we need to replay b accord-
ing to Ïƒ. Thus, we would always favor the marking [p2, p5] over [p2, p3] since in
the latter one we have to eventually execute c after executing the b to proceed.
Hence, transition t(cid:48)
2 allowing to jump to [p2, p3] is not needed when computing
an optimal inï¬x/postï¬x alignment for (cid:104)b, d, f (cid:105). The proposed auxiliary WF-net
construction in this section is exploiting such conclusions.

Fig. 7 shows the auxiliary WF-net that is generated by the advanced ap-
proach. The shown auxiliary WF-net is speciï¬c for the WF-net shown in Fig. 2
and the inï¬x/postï¬x Ïƒ = (cid:104)b, d, f (cid:105). Compared to the auxiliary WF-net generated
by the baseline approach (cf. Fig. 6), the one shown in Fig. 7 contains less silent
transitions; leading to a reduced state space of the corresponding SPN. To com-
pute the relevant markings, the advanced approach systematically traverses the
given process tree as speciï¬ed in Alg. 1, which internally calls Alg. 2 and Alg. 3.

Restriction to Submodel In addition to the described approach, we can
further reduce the size of the auxiliary WF-net if we compute inï¬x alignments.
For a process tree T , we determine the minimal subtree that contains all leaf
nodes whose labels are contained in the given trace inï¬x. Since the other subtrees

Conformance Checking for Trace Fragments

9

Algorithm 1: Calculating relevant markings for process trees

input : T =(V, E, Î», r)âˆˆT , ÏƒâˆˆAâˆ—
output: M âŠ† B(P T )
begin

M â† {};
let N T = (P T , T T , F T , mT
A â† {a | aâˆˆA âˆ§ aâˆˆÏƒ};
forall n âˆˆ {n | nâˆˆV âˆ§ Î»(n)âˆˆA} do

M â† M âˆª BuMG(cid:0)T, n, null, N T , âˆ…, A(cid:1);

// initialize the set of markings for the auxiliary WF-net
i , mT

f , Î»T ) be the corresponding WF-net of T ;

// store all activity labels from Ïƒ in the set A
// iterate over leaves whose label is in Ïƒ
// call BuMG for each leaf n

return M âˆª {mT

f };

// mT

f is needed for postfix alignments to ensure that the

entire model is skippable (i.e., postfix alignment contains log moves only)

Algorithm 2: Bottom-up marking generation (BuMG)
input : T =(V, E, Î», r)âˆˆT , nâˆˆV, n(cid:48)âˆˆV, N T =(P T , T T , F T , mT
i , mT

f , Î»T )âˆˆN ,

M âŠ†B(P T ), AâŠ†A

output: M âŠ†B(P T )
begin

if Î»(n) âˆˆ A then

// n is a leaf node of T

let t âˆˆ T T be the transition representing n âˆˆ V ;
M â† {[p âˆˆ â€¢t]};

else if Î»(n) = âˆ§ then

S â† (cid:104)s1, . . . , sk(cid:105) = cT (n)â†“
forall sj âˆˆ S do

V \{n(cid:48) }

;

Msj â† TdMG(cid:0)T (sj ), N T (sj ), A, true(cid:1);

// initialize M with a marking enabling t
// n represents a parallel operator
// S âˆˆ V âˆ— contains the siblings of n(cid:48)

M â† M Ã— Ms1 Ã— Â· Â· Â· Ã— Msk ;

// Cartesian product because Î»(n) = âˆ§

if r = n then

return M ;

// node n is the root node of T

M â† BuMG(cid:0)T , pT (n), n, N T , M , A(cid:1);

// call BuMG on nâ€™s parent

Algorithm 3: Top-down marking generation (TdMG)

input : T =(V, E, Î», r)âˆˆT , N T =(P T , T T , F T , mT
addFinalMarkingâˆˆ{true, false}

i , mT

f , Î»T )âˆˆN , AâŠ†A,

output: M âŠ†B(P T )
begin

if Î»(r) âˆˆ A then

let t âˆˆ T T be the transition representing r;
M â† âˆ…;
if Î»(r) âˆˆ A then

// r is a leaf node

M â† M âˆª {[p âˆˆ â€¢t]};

// tâ€™s label is in the given trace infix/postfix

if addFinalMarking = true then

M â† M âˆª {[p âˆˆ tâ€¢]};

return M ;

else

S â† (cid:104)s1, . . . , sk(cid:105) = cT (r);
if Î»(r) =â†’ then

// r represents an operator
// S contains all children of the root node r

return TdMG(cid:0)T (s1), N T (s1), A, false(cid:1) âˆª Â· Â· Â· âˆª TdMG(cid:0)T (skâˆ’1), N T (skâˆ’1),
A, false(cid:1) âˆª TdMG(cid:0)T (sk), N T (sk ), A, addFinalMarking(cid:1);

if Î»(r) = âˆ§ then

return TdMG(cid:0)T (s1), A, N T (s1 ), true(cid:1) Ã— Â· Â· Â· Ã— TdMG(cid:0)T (sk), N T (sk ), A,
true(cid:1);

if Î»(r) âˆˆ {(cid:9), Ã—} then

return TdMG(cid:0)T (s1), N T (s1), A, addFinalMarking(cid:1) âˆª TdMG(cid:0)T (s2), N T (s2 ),
A, false(cid:1) âˆª Â· Â· Â· âˆª TdMG(cid:0)T (sk), N T (sk ), A, false(cid:1);

1

2

3

4

5

1

2

3

4

5

6

7

8

9

10

11

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

10

D. Schuster et al.

(a) BPI Ch. 2019 event log

(b) BPI Ch. 2020 event log

Fig. 8: Time spent for computing inï¬x alignments, i.e., Step 1-5 (cf. Sect. 5)

do not contain leaf nodes relevant for the given inï¬x, we can ignore them3. Next,
we call Alg. 1 for the determined subtree and execute the auxiliary WF-net for
the determined subtree and the corresponding relevant markings.

6 Evaluation

This section presents an evaluation of the inï¬x alignment computation. We use
real-life, publicly available event logs. We sampled 10,000 inï¬xes per log. Further,
we discovered a process model using the entire log with the inductive miner
infrequent [4]. The implementation and further results can be found online4.

Regarding the correctness of the proposed approaches: Baseline, Baseline +
subsequent ï¬ltering and the Advanced approach, we compare the cost of the
computed inï¬x alignments. As the baseline approach considers all reachable
markings as relevant, it is guaranteed that no other relevant markings exist. Per
trace inï¬x, we ï¬nd that all approaches yield inï¬x alignments with identical costs.
Fig. 8 shows the overall time spent for the alignment computation, i.e., Step 1
to 5 (cf. Sect. 5). We ï¬nd that using the advanced approach signiï¬cantly shortens
the overall alignment calculation time compared to the baseline approaches be-
cause the auxiliary WF-net produced by the advanced approach contains fewer
silent transitions than the one created by the baseline approach.

7 Conclusion

This paper extended the widely used conformance checking technique alignments
by deï¬ning inï¬x and postï¬x alignments. We presented two approaches for com-
puting them, i.e., a baseline approach and an advanced approach assuming pro-
cess trees as a reference model. Our results indicate that the advanced approach
outperforms the baseline if the reference process model is block-structured.

3 Note that if the determined subtree is placed within a loop, the subtree containing

the highest loop and the initial determined subtree has to be considered

4 https://github.com/ï¬t-daniel-schuster/conformance checking for trace fragments

                                       , Q I L [  / H Q J W K     & R Q V X P H G  7 L P H   L Q  V H F R Q G V  % D V H O L Q H % D V H O L Q H    V X E V H T X H Q W  I L O W H U L Q J $ G Y D Q F H G                        , Q I L [  / H Q J W K          & R Q V X P H G  7 L P H   L Q  V H F R Q G V  % D V H O L Q H % D V H O L Q H    V X E V H T X H Q W  I L O W H U L Q J $ G Y D Q F H GConformance Checking for Trace Fragments

11

References

1. Adriansyah, A.A.: Aligning observed and modeled behavior. Ph.D. thesis (2014)
2. Carmona, J., van Dongen, B., Solti, A., Weidlich, M.: Conformance Checking.

Springer (2018)

3. Dunzer, S., Stierle, M., Matzner, M., Baier, S.: Conformance checking: A state-of-
the-art literature review. In: Proceedings of the 11th International Conference on
Subject-Oriented Business Process Management. ACM Press (2019)

4. Leemans, S.J.J.: Robust Process Mining with Guarantees. Springer (2022)
5. Schuster, D., van Zelst, S.J.: Online Process Monitoring Using Incremental State-
Space Expansion: An Exact Algorithm. In: Business Process Management. Springer
(2020)

6. Taymouri, F., Carmona, J.: A Recursive Paradigm for Aligning Observed Behavior
of Large Structured Process Models. In: Business Process Management. Springer
(2016)

7. van der Aalst, W.M.P.: The Application of Petri Nets to Workï¬‚ow Management.

Journal of Circuits, Systems and Computers (1998)

8. van der Aalst, W.M.P., Adriansyah, A., van Dongen, B.: Replaying history on
process models for conformance checking and performance analysis. WIREs Data
Mining and Knowledge Discovery (2012)

9. van der Aalst, W.M.P., van Hee, K.M., ter Hofstede, A.H.M., Sidorova, N., Verbeek,
H.M.W., Voorhoeve, M., Wynn, M.T.: Soundness of workï¬‚ow nets: classiï¬cation,
decidability, and analysis. Formal Aspects of Computing (2011)

10. van Dongen, B., Carmona, J., Chatain, T., Taymouri, F.: Aligning Modeled and
Observed Behavior: A Compromise Between Computation Complexity and Qual-
ity. In: Advanced Information Systems Engineering. Springer (2017)

11. van Dongen, B.F.: Eï¬ƒciently Computing Alignments. In: Business Process Man-

agement. Springer (2018)

