2
2
0
2

r
a

M
3
2

]
E
N
.
s
c
[

1
v
8
3
1
2
1
.
3
0
2
2
:
v
i
X
r
a

A Search-Based Framework for Automatic Generation of Testing
Environments for Cyber-Physical Systems

Dmytro Humeniuk∗, Foutse Khomh and Giuliano Antoniol

Polytechnique Montréal, 2500 Chemin de Polytechnique, QC H3T 1J4, Montréal, Canada

A R T I C L E I N F O

A B S T R A C T

Keywords:
cyber-physical systems,
test scenario generation,
genetic algorithms,
virtual environments

Background. Many modern cyber-physical systems incorporate computer vision technologies,
complex sensors and advanced control software, allowing them to interact with the environment
autonomously. Examples include drone swarms, self-driving vehicles, autonomous robots, etc. Testing
such systems poses numerous challenges: not only should the system inputs be varied, but also the
surrounding environment should be accounted for. A number of tools have been developed to test
the system model for the possible inputs falsifying its requirements. However, they are not directly
applicable to autonomous cyber-physical systems, as the inputs to their models are generated while
operating in a virtual environment.
Aims. In this paper, we aim to design a search-based framework, named AmbieGen, for generating
diverse fault-revealing test scenarios for autonomous cyber-physical systems. The scenarios represent
an environment in which an autonomous agent operates. The framework should be applicable to
generating diﬀerent types of environments.
Method. To generate the test scenarios, we leverage the NSGA-II algorithm with two objectives. The
ﬁrst objective evaluates the deviation of the observed system’s behaviour from its expected behaviour.
The second objective is the test case diversity, calculated as a Jaccard distance with a reference test
case. To guide the ﬁrst objective we are using a simpliﬁed system model rather than the full model.
The full model is used to run the system in the simulation environment and can take substantial time
to execute (several minutes for one scenario). The simpliﬁed system model is derived from the full
model and can be used to get an approximation of the results obtained from the full model without
running the simulation.
Results. We evaluate AmbieGen on three scenario generation case studies, namely a smart-thermostat,
a robot obstacle avoidance system, and a vehicle lane-keeping assist system. For all the case studies,
our approach outperforms the available baselines in fault revealing and several other metrics such as
the diversity of the revealed faults and the proportion of valid test scenarios.
Conclusions. AmbieGen could ﬁnd scenarios, revealing failures for all the three autonomous agents
considered in our case studies. We compared three conﬁgurations of AmbieGen: based on a single
objective genetic algorithm, multi-objective, and random search. Both single and multi objective
conﬁgurations outperform the random search. Multi objective conﬁguration can ﬁnd the individuals of
the same quality as the single objective, producing more unique test scenarios in the same time budget.
Our framework can be used to generate virtual environments of diﬀerent types and complexity and
reveal the system’s faults early in the design stage.

1. Introduction

One of the rapidly developing families of cyber-physical
systems (CPS) are autonomous and vision based CPS. Ex-
amples include drone swarms, self driving cars, cave or
underwater exploring robots. Typically, in the CPS develop-
ment process the systems are validated and veriﬁed accord-
ing to the V-model approach [2]. Prior to running the tests
on a real system, the V-model includes model-in-the-loop
and software-in-the-loop testing stages. In these stages the
simulations of the system are run in a virtual environment.
The goal is to model the real environment eﬀect on CPS(s)
and generate test scenarios violating some critical proper-
ties of CPS. However, during these simulations, engineers
often lack tool support for generating the scenarios [9]. For
particular applications there exist content generation tech-
niques, like a Kruskal’s algorithm for maze generation [16]
or pre-conﬁgured scenarios, like the virtual worlds used in
computer games [40]. However, they do not always provide

∗Corresponding author, e-mail: dmytro.humeniuk@polymtl.ca
ORCID(s):

the needed scenario complexity and oftentimes the scenarios
have to be designed manually. Consider an autonomous
robotic system, that should navigate to a goal destination in
an environment with obstacles. The robots interact with the
physical world via sensors and actuators in a feedback loop,
avoiding the obstacles and searching the goal destination.
Test scenario for such system includes virtual environment
with obstacles , including moving and unexpected obstacles,
changing terrain structure and environmental conditions.
Manually designing all the possible scenarios in the virtual
environment is a tedious task.

In this paper, we propose a search based approach,
further referred to as “AmbieGen“ to automatically generate
test scenarios for cyber-physical systems. In the literature,
typically one objective, accounting for the scenario fault
revealing power [20], or two objectives, accounting for fault
revealing power and diversity [35], are used. To evaluate the
contribution of adding the ﬁrst and the second objectives we
consider three conﬁgurations of AmbieGen: based on ran-
dom search, single-objective genetic algorithm (AmbieGen

First Author et al.: Preprint submitted to Elsevier

Page 1 of 21

 
 
 
 
 
 
Short Title of the Article

SO) and multi-objective genetic algorithm NSGA-II (Amn-
bieGen MO). Preliminary results conﬁrm that using the two
objectives, maximizing both: scenario fault revealing power
and diversity, allows to ﬁnd more unique fault revealing
scenarios given the same time budget. To calculate the
ﬁrst objective we are using the simpliﬁed system model,
derived from the full model of the system, as suggested
by Menghi et al. [30].The full model is used to execute
the scenarios in the simulation environment and is usually
computationally expensive. The simpliﬁed model allows to
reduce the computational and time cost needed to produce
the test scenarios as it does not require the simulator to run
and provides the approximated outputs of the full model in
a reduced amount of time.

We evaluate our approach on three test generation case
studies. In the ﬁrst case study, a smart-thermostat agent
should follow the schedule with the expected precision. The
goal of the testing approach is to generate the temperature
schedule and a combination of environmental conditions
violating the requirement. In the second case study, an
autonomous robot should navigate to a goal location in an
indoor environment with obstacles, without bumping into
them. A test scenario should ﬁnd such an indoor environ-
ment that makes the robot violate the requirements. In the
third, an autonomous vehicle, with a lane-keeping assist
system (LKAS), should follow a road lane of the given
trajectory, without going out of its bounds. The testing
approach should generate a virtual road that forces the car
to go out of the road. AmbieGen could reveal on average 9
failures in two hours for the autonomous robot model and 14
failures in two hours for the self-driving car model executed
in the simulators . Given the same evaluation budget, in
all the case studies the multi-objective and single-objective
conﬁgurations of AmbieGen produced ﬁtter solutions with
a large eﬀect size, comparing to the random search. Multi-
objective conﬁguration allowed to produce more diverse sce-
narios with medium to large eﬀect size comparing to single-
objective, while ﬁnding solutions of the same or similar
quality.

This paper makes the following contributions:

1. We design a search-based framework for generat-
ing customized environments for testing autonomous
CPS.

2. We propose a novel technique for generating the vir-

tual roads and robot navigation maps.

3. Finally, we provide the code for replication of all of

our experiments [24].

Researchers and practitioners can leverage AmbieGen to
automatically generate scenarios for autonomous CPS that
will be further passed to the simulators to run tests on the
full CPS models.

The remainder of this paper is organized as follows.
Section 2 discusses the related works in the domain of CPS
testing. In Section 3 we formalize the problem of scenario
generation and provide the description of AmbieGen ap-
proach in Section 4. Section 5 describes the test generation

case studies used to evaluate our approach. In Section 6 we
formulate the research questions and our evaluation method-
ology. The same section reports our results and answers to
research questions. Section 7 discusses the results and the
main challenges of this study. In Section 8 we explain the
threats to the validity of our results. Section 9 concludes the
paper and discusses some avenues for future works.

2. Related literature

Typically, the cyber-physical systems are developed us-
ing a model-based design approach [2]: after establishing
the requirements of the system, model-in-the-loop testing
is performed. In this step, models of the hardware part
and the controller are created and tested in the simulation
environment. One of the limitations of simulation platforms
is that they do not provide clear guidance to engineers as
to which test scenarios should be selected for simulation.
Therefore, a number of approaches have been developed to
generate the testing scenarios.

General approaches for CPS testing. In the classical
approach, the exhaustive exploration of the state-space of the
model is performed [12]. It uses the abstract model, created
strictly according to the system requirements, to generate
the test cases for the model of the system under test (SUT).
If the outputs of the SUT model and abstract model are
diﬀerent, the fault in the SUT is revealed. As the system
models get more complex, the search space becomes in-
feasible. More recently, falsiﬁcation based approaches have
been proposed, verifying whether the model meets speciﬁc
requirements speciﬁed in a temporal logic notation such as
timed computation tree logic (TCTL), linear temporal logic
(LTL), metric temporal logic (MTL) or signal temporal logic
(STL) . The UPAAl SMC tool performs the statistical model
checking (SMC) of of a given model, with the requirements
speciﬁed using TCTL notation [17]. The core idea of SMC
is to monitor some simulations of the system, and then
compute the probability along with conﬁdence intervals that
a speciﬁc requirement holds for the SUT. A number of tools
were developed that instead of calculating the probability
that a system satisﬁes the property with a certain conﬁdence,
compute the worst expected system behaviour as a quanti-
tative value, called robustness. Examples of such tools are
S-Taliro [4], Breach [19] and ARIsTEO [30]. Diﬀerently
from others, ARIsTEO propose to apply falsiﬁcation testing
to the surrogate, i.e., approximated model of the SUT, that
closely mimics its behaviour but is signiﬁcantly cheaper to
execute. Arrieta et al., proposed a search based approach,
that does not use the system model [7]. They deﬁned three
cost eﬀectiveness measures to guide search towards gener-
ating optimal test cases: requirements coverage, test case
similarity (eﬀectiveness) and test execution time (cost).

In the described works, authors consider falsiﬁcation
of the model of the system that takes as an input a set of
signals 𝑈 = {𝑢1, 𝑢2, . . . , 𝑢𝑚} and produces a set of signals
𝑌 = {𝑦1, 𝑦2, . . . , 𝑦𝑛} as the output. In our work we focus
on testing autonomous systems, for which the input signals

First Author et al.: Preprint submitted to Elsevier

Page 2 of 21

Short Title of the Article

are rather complex and might represent sensors and camera
data, coming from diﬀerent sources. Imagine a self-driving
vehicle, using the lidar sensors and RGB camera to perceive
the environment. Directly generating a valid combination
of falsifying input signals (represented by lidar readings
and RGB camera readings) would be rather challenging.
Therefore, we focus on generating test cases that specify a
virtual environment for an autonomous system, rather than
the input signals. The input signals are generated in the vir-
tual environment during the simulation, based on the actions
taken by the autonomous agent. A number of approaches
have been proposed for generating virtual environments for
testing the autonomous driving and robotic systems.

Vehicular driving system testing. Abdessalem et al.
in [9] use a multi-objective search evolutionary algorithm
NSGA-2 to obtain test scenarios for Automated Emergency
Braking (AEB) system. They represent the test case as a
tuple with sets of static parameters, such as precipitation,
fogginess, roadshape and visibility range, as well as dynamic
parameters, such as initial vehicle speed, initial pedestrians
speed and location. The disadvantage of such encoding
is the limitation in describing the static parameters. Such
encoding does not allow to specify for example a complex
road topology, with a number of turns and intersections.
Also, we cannot account for the cases, where the static
parameters need to be changed during the test case. For
example, when the road material changes along the route,
i.e., asphalt surface changes to pavement. In order to gen-
erate challenging test cases, they use ﬁtness functions min-
imizing the distance to the pedestrian and time to collision,
calculated while executing the test case. To mitigate the
computation cost of executing physics-based simulations,
the simpliﬁed models of ADAS trained on neural networks
(NN) are used. Evidently, the NN has to be retrained each
time model parameters are changed.

AsFault tool was proposed to generate the road conﬁg-
uration to test car Lane Keeping Assist System (LKAS) by
Gambi et al., [20]. This system should allow an autonomous
car to always drive inside its lane. The test cases in this work
correspond to a road topology that a car needs to follow.
AsFault represents roads as set of polylines, i.e., discrete
sequences of points. One polyline corresponds to one road
segment. Roads are generated procedurally by stitching one
road segment to the next one. To evolve the roads, authors
use a customized mutation operator, that randomly replaces
a road segment and crossover operator that splits two roads at
a random point and recombines them, or recombines random
subsets of two roads. With such encoding combining the
road polylines to produce a valid road may be challenging.
Authors mention that if the search operator produces invalid
road topology, AsFault retries the application of the same
search operator with a probability of giving up which in-
creases per failed attempt. Therefore, one disadvantage of
such encoding is the diﬃculty in applying crossover and mu-
tation operators. Another disadvantage is the limitations in
encoding some important details of the test case such as the
other vehicles, obstacles or pedestrian locations. Authors do

not mention the possibility to encode such information with
AsFault. Finally, the selected ﬁtness function maximizes the
distance of ego-car from the center of the road lane. The real
simulation model is used for calculating the ﬁtness function
value, which increases the computation cost. To improve the
eﬃciency of the tool, authors ﬁlter out similar test cases by
calculating Jaccard index between them. However, they do
not maximize the diversity of the test cases explicitly.

Riccio and Tonella [36] propose DeepJanus, a tool
to explore the behavioural space of a deep learning (DL)
system to ﬁnd pairs of inputs at its frontier: one input on
which the DL system behaves as expected, and another
similar input on which it misbehaves. In this work they
consider two case studies: image classiﬁcation (from MNIST
database) and steering angle prediction for a vehicle LKAS
system. We will further focus on the later. The scenario
for the vehicle is represented as a road topology and it is
encoded as a list of coordinates of the control points. These
control points are further interpolated with Catmull-Rom
cubic splines to produce a road topology. This encoding is
limited in terms of increasing the complexity of the test case,
such as specifying the location of other vehicles, obstacles or
intersections. The tool is leveraging a two objective NSGA-
II algorithm to generate eﬀective test cases. Each individual
of the algorithm is encoded as a pair of road topologies.
The ﬁrst objective, 𝑓1
, aims to promote diversity between an
individual and existing individuals as well as minimize the
diﬀerence between the pair of road topologies constituting
the individual. Authors deﬁne a problem speciﬁc distance
metric used to evaluate the 𝑓1
. For the LKAS case study it
is calculated as the Levenshtein distance between the roads.
For image classiﬁcation, it is calculated as an Euclidean dis-
tance between pixel matrices. The second ﬁtness function,
, aims to minimize the distance of an individual to the
𝑓2
behavioural frontier. In the case of the LKAS system case
study it’s calculated based on the maximum deviation from
the lane center. If this deviation is higher than a certain
threshold for one of the roads of the individual, the 𝑓2
is
assigned a -1 value, otherwise it’s equal to the absolute
value of the maximal deviation. We can see that the ﬁtness
functions are designed to evaluate a pair of road topologies,
rather than a single road topology.

Autonomous robot testing approaches. Arnold et al.
[6] designed a tool to produce navigation maps to test
autonomous robot control algorithms. They use the Per-
lin noise to randomly generate the maps and then select
the ones, that correspond to a deﬁned set of unwanted
behaviours, such as stalling or colliding with a wall. No
optimization algorithms are used to increase the number of
fault-revealing scenarios.

Sotiropoulos et al. [39] generate navigation maps of
diﬀerent diﬃculty level by changing the number and position
of obstacles on the map. As in the previous work, the
procedural content generation with ﬁxed parameters is used
without optimization.

Nguyen et al. [33] propose a genetic algorithm based
approach to design test scenarios for a cleaner robot. The

First Author et al.: Preprint submitted to Elsevier

Page 3 of 21

Short Title of the Article

robot goal is to collect all the rubbish given a speciﬁc amount
of time, without bumping into obstacles. The scenario rep-
resents an area with obstacles and objects to collect. It is
encoded as a table with R x R cells. A cell containing an
object is denoted by 1, while a content–free cell is denoted
by 0. The limitation of such encoding is that it is problem
speciﬁc, i.e., it is suitable for encoding a map for the robot,
however it is rather diﬃcult to represent a road topology
using such encoding. The ﬁtness function is deﬁned as
closest distance to obstacles observed by the robot.

Considering the existing approaches for environment
generation, we can see that their implementation, including
the evolutionary algorithm representation, has such limita-
tions as problem speciﬁc or hardly customizable individual
representation, diﬃculties in search operator implementa-
tion. In our work we propose a test generation approach,
AmbieGen, with encoding that can be applied to test gen-
eration tasks for diﬀerent autonomous agents, can provide
a customizable scenario complexity level and allows to
easily implement the search operators. Furthermore, in our
approach we are using two objectives, accounting for both
fault revealing power 𝐹1
.
and diversity of the test cases 𝐹2
Implementation of 𝐹1
is problem speciﬁc and is deﬁned as
the diﬀerence between the expected and observed behaviour
of the the agent. Contrary to existing works, we are explicitly
promoting the diversity of the test cases as the second objec-
tive 𝐹2
of the genetic algorithm using a universal distance
metric, explained in Subsection 3.2. In our experiments we
show that adding the 𝐹2
allows to increase the diversity of
the test cases in the resulting test suite, without reducing
their fault revealing power. Overall, we surmise that our
framework can be leveraged for implementing search based
algorithms for test case generation for autonomous systems.

3. Problem formulation

A cyber-physical system is a reactive system, consisting
of a computing device (or a collection of them) interacting
with the environment via inputs and outputs [3].
In a
simulator, the autonomous CPS agent observes the virtual
environment at discrete timestamps 𝑡𝑖
using its local sen-
sors, e.g., temperature, lidar sensors or RGBD-cameras, and
measures its internal state 𝑠𝑡
it receives
a new observation 𝑜𝑡 ∈ 𝑂 and selects an action 𝑎𝑡 ∈ 𝐴
according to its control policy 𝜋(𝑠𝑡, 𝑜𝑡
). Here 𝐴 is a set of
possible actions and 𝑂 is a set of all possible observations
(the observation space), deﬁned by the environment where
the agent operates. Each test case represents an environment
for the agent as well as the mission it needs to accomplish
in it. We can formulate the problem as ﬁnding a test case,
forcing the agent to take such actions 𝑎𝑡
that lead to violation
of the established requirements and failure of the mission.

. At each timestep 𝑡𝑖

For example, to test a self-driving vehicle we should
consider such parameters as the road type and size, the
location of other vehicles or pedestrians, the driving weather
conditions, etc. Evidently, one of the most important require-
ments would be the collision avoidance. Generating such

Table 1
Scenario 𝑇 𝐶 representation

𝐸2

𝐸1

𝐸3
𝐴1 𝐴1𝑒1 𝐴1𝑒2 𝐴1𝑒3
𝐴2 𝐴2𝑒1 𝐴2𝑒2 𝐴2𝑒3
...
...
𝐴𝑛𝑒3
𝐴𝑛

...
𝐴𝑛𝑒1

...
𝐴𝑛𝑒2

𝐸𝑚
...
... 𝐴1𝑒𝑚
... 𝐴2𝑒𝑚
...
...
... 𝐴𝑛𝑒𝑚

scenarios manually is an extremely time consuming task: the
engineers would need to list the precise positions and head-
ing directions of the moving objects, specify diﬀerent types
of environmental conditions, etc. Therefore it is preferable
to generate such scenarios automatically. To control their
quality, optimization techniques should be used.

3.1. Scenario representation

In this subsection we formalize the deﬁnition of the
test scenarios. As it was mentioned earlier, one test case
represents an environment in which the agent operates as
well as the mission it needs to accomplish. We encode the
test case as a set of parameters, needed to generate the
deﬁned environment in the simulator.

First, we propose to divide the test case into at most
𝑚 parts. Each part can represent some aspect of the mission
to accomplish or a part of the virtual environment in which
the agent operates. We call these parts the environmental
elements 𝐸𝑖
. We describe each environmental element with
𝑛 parameters, which we further refer to as attributes.

As an example, let’s consider a car lane keeping assist
system (LKAS). It’s main goal is to keep the vehicle within
the road lane. One of the possible test cases to test this system
can be a road topology, that the vehicle needs to follow. To
design the test case, we suggest representing the road topol-
ogy as a combination of road segments of diﬀerent length
and curvature. Here, each road segment would correspond
to one environmental element and it’s parameters such as
length and curvature - the attributes of the environmental
element.

Each individual (test case TC) is represented as a 𝑛𝑥𝑚
matrix where the cell (𝑖, 𝑗) contains values deﬁning the TC.
, and is composed of
In a nutshell, a TC has 𝑛 attributes 𝐴𝑖
(in
at most 𝑚 elements. More precisely, cell (𝑖, 𝑗), alias 𝐸𝑗
. Without
), is the value sampled from the attribute 𝐴𝑖
line 𝐴𝑖
loss of generality, an attribute 𝐴𝑖
, takes value into a set of
possible realizations {𝑎0, 𝑎1, ..., 𝑎𝑛} or is deﬁned as a closed
interval [𝐴𝑖𝑚𝑖𝑛, 𝐴𝑖𝑚𝑎𝑥]. We allow for the cells to be empty, if
needed.

Turning to the LKAS example, we can describe each
road segment, i.e., environmental element, with such pa-
rameters as the length, the turning angle, the slope, the
road material, etc. Each road segment will have a value
for each of these parameters. By providing combinations of
road segments with diﬀerent parameter values, we generate
various road topologies.

First Author et al.: Preprint submitted to Elsevier

Page 4 of 21

Short Title of the Article

Finally, the test scenarios can have restrictions 𝑅, which
limit the scenario length 𝑀 or particular combinations of at-
tributes. In the LKAS example, for instance, we can limit the
total road length or a certain combination of road segments,
that create too sharp turns, etc.

We provide examples of application of this represen-
tation to generate diﬀerent test scenarios for autonomous
agents in the Section 5.

Having obtained the matrix with attributes, i.e., the test
scenario speciﬁcation, we can generate the corresponding
virtual environment in the simulator. According to the se-
lected timestamp in the simulator settings, the agent will
receive the inputs in the form of observations at each times-
tamp. Observations can be represented by a temperature or
lidar sensor readings, images from the RGB camera. After
receiving each observation, the agent performs an action.
Depending on the actions the agent takes it can fail or pass
the test case.

In the LKAS example, suppose the car uses its RGB
camera images to deﬁne its steering wheel angle. The stan-
dard camera frame rate to provide stable image for such
applications is more than 30 Hz [21]. Let’s consider 30 Hz
for this example. This means the car receives an input in the
form of the RGB image every 33,3 msec. For each received
input, it provides a value of the steering angle to use. This
value can be obtained, for instance, by querying a neural
network based model that classiﬁes steering angle values
based on the image of the road.

Initial encoding of the scenario is the matrix 𝑇 𝐶, con-
taining a high-level description of the environment. With
such representation it’s easy to implement the evolutionary
search operators by simply swapping the matrix columns be-
tween each other and randomly changing the cell values. By
swapping the columns, we imply reassigning the attributes
from one environmental element to another. To evaluate its
ﬁtness it ﬁrst needs to be converted to the environment con-
ﬁguration for the approximated model ("TC to environment"
module). For example, the scenarios for an autonomous
robot should be converted to a list of obstacle coordinates
in a map. Then an approximated model is used to execute
the scenarios and the ﬁtness function is calculated based on
the execution results ("Fitness function" module). Approxi-
mated model can be created either from real data or from the
full model data. Another possibility is to use a simpliﬁed
system model, based on already implemented robotics algo-
rithms, such as those available at python robotics project
[38]. Overall, to customize AmbieGen, the developer needs
to provide a list of attributes and their allowable ranges,
an implementation of the "TC to environment" and "Fit-
ness function" modules. The AmbieGen will integrate the
modules and implement the initial population generation,
crossover and mutation operators. Moreover, it’s simple to
control the level of complexity needed for the environment.
By adding more attributes, the complexity can be increased.
The limitation is the possibility of the simulator to interpret
more complex environment conﬁgurations, such as the ter-
rain type, the weather conditions, etc.

3.2. Search objectives deﬁnition

The main goal is to ﬁnd scenarios producing system
faults. At the same time, the scenarios should be diverse,
uncovering diﬀerent types of faults. From our experience,
using only one objective results in producing many similar
test cases in the last generation. Therefore we suggest adopt-
ing a multi-objective algorithm, where one of the objectives
is accounting for the diversity of the test cases. The idea of
adding a second objective for diversity is not new and was
addressed in the novelty search works, such as [32], and test
scenario generation tools [35].

To estimate the ﬁrst objective 𝐹1

, the fault revealing
power 𝜑 of the test case, we compute the diﬀerence between
the expected 𝐵(𝑇 𝐶) and observed system behaviour 𝐵𝑜(𝑇 𝐶)
after executing the test case:

𝐹1 = 𝜑(𝑇 𝐶) = 𝛿(𝐵(𝑇 𝐶), 𝐵𝑜(𝑇 𝐶)),

(1)

where 𝛿 is a developer deﬁned function for computing the
deviation between the expected and observed system be-
haviour and 𝑇 𝐶 is the test scenario speciﬁcation. The ex-
pected behaviour 𝐵(𝑇 𝐶) is typically deﬁned in the system
requirements or formulated by the developers e.g., "the car
should not deviate from the lane center for more than 1
meter". The observed behaviour corresponds to the model
under test (MUT) outputs after scenario execution. However,
the models of autonomous systems are rather complex and
take long time to execute in the simulators, i.e., up to sev-
eral minutes for one scenario. Moreover, executing the full
models in the simulation environments requires additional
system resources such as a GPU and high amount of RAM.
Therefore we suggest estimating the observed behaviour
𝐵𝑜(𝑇 𝐶) using the approximated (surrogate) system models.
Such models can be built based on the grey-box modelling
approach [37], where model structure is chosen from system
knowledge and parameters are selected to match sampled
data. When little knowledge is available about the model,
system identiﬁcation techniques [29] can be used, where the
modelled system is considered as a black box.

To estimate the second ﬁtness function 𝐹2

the vari-
ability 𝜐 of the test case, we compute the Jaccard distance
between it and a reference test case:

,

𝐹2 = 𝜐(𝑇 𝐶, 𝑇 𝐶𝑟𝑒𝑓 ) = 1 −

𝑇 𝐶 ∩ 𝑇 𝐶𝑟𝑒𝑓
𝑇 𝐶 ∪ 𝑇 𝐶𝑟𝑒𝑓

,

(2)

where 𝑇 𝐶 ∪ 𝑇 𝐶𝑟𝑒𝑓
elements in both test cases and 𝑇 𝐶 ∩ 𝑇 𝐶𝑟𝑒𝑓
of inputs with similar or same attributes.

to the total number of environmental
to the number

Finally, we deﬁne our search objectives:

𝑚𝑎𝑥𝑖𝑚𝑖𝑧𝑒 ∶ 𝜑(𝑇 𝐶),
𝑚𝑎𝑥𝑖𝑚𝑖𝑧𝑒 ∶ 𝜐(𝑇 𝐶, 𝑇 𝐶𝑟𝑒𝑓 ),
𝑠𝑢𝑏𝑗𝑒𝑐𝑡 𝑡𝑜 ∶ 𝐶1(𝑇 𝐶) = 𝜑(𝑇 𝐶) − 𝛼 > 0,

Where 𝐶1
is a constraint for the minimum value of the ﬁrst
objective, 𝛼 is the developer deﬁned threshold to identify
the test cases as having a risk of producing a failure. This

First Author et al.: Preprint submitted to Elsevier

Page 5 of 21

Short Title of the Article

constraint is introduced to avoid producing test cases with
low fault revealing power.

In our study we consider two conﬁgurations of our
approach: AmbieGen MO, described above and AmbieGen
SO based on a single objective genetic algorithm (GA) with
𝐹1

as a ﬁtness function.

4. Proposed approach description

To perform the search we are using evolutionary search
algorithms NSGA-II and GA [15], which have proven to be
eﬀective at similar tasks [1, 7]. Below, we present the GA
and NSGA-II conﬁgurations used in AmbieGen.

We implemented the AmbieGen MO and AmbieGen
SO using a python Pymoo framework [11]. The framework
provides the possibility to deﬁne custom solution represen-
tations, crossover and mutation operators.

Solution representation. Each individual in the popula-
tion corresponds to a test case. Individuals can have a vari-
able number of genes, i.e., environment elements depending
on the application. Internally, we represent the individual,
i.e., the test case, shown in table 1, as a dictionary, as shown
below:

{ " E1 " : { "A0 : " A0 ,
"An" : An } , " E i " :

"A1" : A1 ,
{ . . . } } ,

. . . ,

where 𝐸𝑖, corresponds to the element of the environment
that is described and 𝐴𝑛 to the value of the attribute from
the deﬁned attribute set 𝐴.

of each element 𝐸𝑖

Initial test case generation. The search begins by gen-
erating the initial test cases. One of the options is to
, ...,
assign arbitrary values to environmental attributes 𝐴0
from their allowable value ranges
𝐴𝑛
[𝐴𝑖𝑚𝑖𝑛, 𝐴𝑖𝑚𝑎𝑥] or realisation sets {𝑎0, 𝑎1, ..., 𝑎𝑛}. When some
distribution of attribute values is known to produce better
test cases, from both semantical and fault-revealing point
of view, we suggest using the Markov chain to assign the
values of certain attributes . For example, when generating
the road segments, the road consisting of only the straight
segments is very unlikely to produce faults. Such cases can
be avoided by assigning values with the Markov chain. To
build a Markov chain we need to deﬁne the state space
as well as the probability table of switching between these
states. As the state space we can use the possible values
of one of the attributes. In the case of the LKAS it can be
the three road segment types: going straight, turning left
and turning right. The state switching probability table can
be inferred from the domain knowledge. In the case of the
LKAS system, we want to lower the probability of getting
a sequence of only straight road segments. An example of a
Markov chain used to generate the initial test cases for the
LKAS is shown in Fig.1.

Fitness evaluation. We use two ﬁtness functions to
, corresponding to the function
evaluate each individual: 𝐹1
in (1) and 𝐹2
is calculated after
executing the test case with a surrogate model 𝑀 of the
system. This function is problem speciﬁc and should be

corresponding to (2). 𝐹1

Figure 1: Markov chain used to generate the intiial test cases
for the LKAS case study

proportional to the unwanted behaviour of the system. For
example, for evaluation of a self-driving car test case we can
compute the maximum deviation from the road lane center,
where bigger deviation is likely to produce more faults.

In our implementation we compute 𝐹2

as the Jaccard
distance between the individual and its parent, which acts
as a reference test scenario. The intuition is to promote
the modiﬁcations done to the test scenarios. However, a
diﬀerent reference test scenario can be used, such as the
closest individual from the Pareto optimal solutions.

As the Pymoo framework minimizes the ﬁtness func-
actual

tions, in our implementation we multiply 𝐹1
values by (-1).

and 𝐹2

Mating selection. To select the individuals for crossover
and mutation the binary tournament selection is used, which
is implemented by default in Pymoo. 𝑁 individuals are
selected, producing 𝑁 new individuals after crossover and
mutations.

is smaller than 𝑚2

(parent 1) and 𝑇 𝐶2
and 𝑚2

Crossover operator. We are using a one point crossover
operator, which is one of the commonly used operators for
variable-length solution representation. This operator cre-
ates two new test cases by exchanging information between
(parent 2),
two existing test cases 𝑇 𝐶1
with corresponding lengths of 𝑚1
. Let’s suppose that
. It is performed in two steps. First we
𝑚1
randomly select the crossover point 𝑘 with the index from 1
with the indices from
to 𝑚1−1. Then the elements of the 𝑇 𝐶1
𝑘 to 𝑚1
are
and elements of 𝑇 𝐶2
swapped. An illustration of the crossover operation between
two individuals is shown in Fig. 2. Individual 𝑇 𝐶1
length is
a size of 3. Both individuals
4 elements and individual 𝑇 𝐶2
is a value of the
and 𝐴2
have two types of attributes 𝐴1
attribute 𝐴𝑖
.
corresponding to the environmental element 𝐸𝑗
The crossover point is chosen to be 2 and is shown as a red
line.

with indices from 𝑘 to 𝑚2

. 𝐴𝑖𝑒𝑗

Mutation operators. We deﬁne three mutation opera-

tors:

• exchange operator:

two randomly
selected environmental elements of a chromosome are
exchanged the positions;

the attributes of

• change of variable operator: an environmental ele-
in a chromosome is randomly selected, then

ment 𝐸𝑖

First Author et al.: Preprint submitted to Elsevier

Page 6 of 21

Short Title of the Article

operation. Testing the controllers in the simulators for dif-
ferent temperature schedules is necessary in order to ensure
their precision and reveal the possible limitations. In this
study, the test generation goal is to create scenarios account-
ing for the scheduled temperature as well as environmental
conditions.

5.1.1. System under test description

In our case study we consider a simple real-world wire-
less thermostat system. It consists of one room with a heater,
sensor, and controller and is part of a larger system, de-
scribed in more details in [44]. The room dimensions are
approximately 2.5 m × 4 m and the height is about 2.6 m. The
heating element is a Steelpro 1.5 Kw electronic convector
2, which is controlled via a wireless Z-wave protocol based
switch. The temperature is measured by a Aeotec MultiSen-
sor 6 device 3, placed at about 2.2 m from the ﬂoor. The
controller is a Raspberry Pi 3B running Z-wave.me with
a RaZberry 4 4 daughter card acting as Z-wave network
controller. The Raspberry Pi has a user deﬁned schedule
of temperature levels; it reads the thermometer measured
values and if needed (according to the schedule and required
temperature) it switches on (oﬀ) the heating.

The data for the room temperature was collected for the
period from December 2019 to May 2020. From the data,
we could observe 7 patterns of temperature dynamics after
ON/OFF commands of the thermostat. As an example, in the
Fig. 3 you can see that the temperature decreases with dif-
ferent rates, which depends on such environmental factors as
indoor and outdoor temperature, humidity, etc. We represent
diﬀerent temperature dynamics patterns, accounting for the
diﬀerent environmental conditions, with diﬀerent thermostat
models.

The thermostat should be able to keep the scheduled
temperature with the precision of 1 degree Celcius, under
diﬀerent environmental conditions in the room. The goal
of the search is to ﬁnd the schedule and the corresponding
thermostat operating mode, to falsify this requirement.

5.1.2. Problem representation

For this problem we deﬁne three high-level input at-
the duration
tributes: 𝐴1
the goal temperature value, 𝐴2
of this temperature and the thermostat operation mode 𝐴3
.
Each test case contains 𝑚 environmental elements 𝐸. For
each of them we need to specify the value of each of the
attributes 𝐴1, 𝐴2, 𝐴3
. The allowable ranges for the attributes
are shown in Table 2.

An example of encoding of the individual representing
the temperature schedule illustrated in Fig. 3 (yellow line) is
shown in Table 3. Each environmental element represents a
part of the schedule, i.e, part of agent’s “mission”, as well as
the operating mode.

We deﬁne two restrictions 𝑅1

for the test scenar-
, the duration of the schedule 𝑇 cannot exceed 24

and 𝑅2

ios. For 𝑅1

2

3

4

2https://www.stelpro.com
https://aeotec.com/z-wave-sensor
https://z-wave.me/products/razberry

Figure 2: Crossover operator for two test cases with 5 and 6
environmental elements with the crossover point at the third
element

for one of the attributes 𝐴𝑛
the value is changed ac-
cording to its type and maximum as well as minimum
values.

• scramble operator: attributes of a number of envi-
ronmental elements 𝐸𝑖
in a chromosome are selected,
then their positions in the chromosome are randomly
exchanged.

Individual insertion. To insert the individuals the mu+lambda
approach is employed [10]. The idea is to merge the pop-
ulation and oﬀsprings together, and then from the merged
set, select the best possible non-dominated solutions of the
population size.

5. Test scenario generation case studies

In this section we demonstrate how AmbieGen can be
applied to three diﬀerent types of environment. We con-
sider the following test generation case studies: a smart-
thermostat, robot obstacle avoidance system, and vehicle
lane-keeping assist system (LKAS). In every case study
the autonomous agent controller has a diﬀerent level of
complexity: simple proportional–integral–derivative (PID)
controller for the thermostat, a robot controller based on
the nearness diagram navigation approach [31], and a deep
neural network based controller for the vehicle. We evaluate
AmbieGen by comparing the results obtained with random
search for all the three problems. For the LKAS system
case study we also compare our results with state-of-the art
approach, presented at SBST2021 tool competition1.

5.1. Wireless thermostat case study

Nowadays, home automation becomes more and more
popular. Automatic temperature control systems are one
of the most commonly used. Such systems consist of a
controller, temperature sensor and a heating element. The
controller goal is to keep the room temperature according to
the programmed schedule. The simplest solution is to send
"ON" and "OFF" commands to the heater, when the temper-
ature needs to be increased or decreased. More sophisticated
thermostats implement PID controllers to achieve smoother

1

https://sbst21.github.io/tools/

First Author et al.: Preprint submitted to Elsevier

Page 7 of 21

Short Title of the Article

(a) Slower decreasing temperature pattern

(b) Faster decreasing temperature pattern

Figure 3: Diﬀerent temperature dynamics patterns

Table 2
Attribute types for thermostat problem

Table 4
Model coeﬃcients

𝐴1, 𝑡𝑒𝑚𝑝𝑒𝑟𝑎𝑡𝑢𝑟𝑒, 𝑇 ◦ 𝐴2, 𝑑𝑢𝑟𝑎𝑡𝑖𝑜𝑛, 𝑚𝑖𝑛 𝐴3, 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛 𝑚𝑜𝑑𝑒
[60, 75,..., 240]

[16, 17,...,25],

[1, 2,..., 7 ]

Table 3
Example of individual representation for the ﬁrst case study

𝐴1, 𝑔𝑜𝑎𝑙 𝑡𝑒𝑚𝑝𝑒𝑟𝑎𝑡𝑢𝑟𝑒
𝐴2, 𝑑𝑢𝑟𝑎𝑡𝑖𝑜𝑛
𝐴3, 𝑚𝑜𝑑𝑒

𝐸1
17
5
1

𝐸2
23
4
3

𝐸3
17
12
2

𝐸4
21
2
4

𝐸5
17
1
1

hours:

𝑅1 ∶

𝑚
∑

𝑖=1

𝐴2𝑒𝑖 < 𝑇 , 𝑇 = 24

(3)

This equation represents the sum of the values of attribute
(duration of the set temperature) of each of the 𝑚 envi-
𝐴2
ronmental elements.

For 𝑅2

, the temperature cannot change too sharply, i.e.,
more than 5 degrees between two adjacent environmental
elements 𝐸𝑖

and 𝐸𝑖+1

:

𝑅2 ∶∣ 𝐴1𝑒𝑖

− 𝐴1𝑒𝑖+1

∣< 5, 𝑖 ∈ [1, 𝑚 − 1],

(4)

where 𝑚 is the number of environmental elements in the test
case.

5.1.3. Fitness function deﬁnition

To calculate one of the ﬁtness functions we need to create
a simpliﬁed model of the system. To this end, we extracted
the data from the experimental measurements and selected
the series of data points, corresponding to behaviour of the
thermostat after "switch on" and "switch oﬀ" commands in
diﬀerent thermostat operation modes. The next challenge is
to select the model structure. In our case it is possible to
build a ﬁrst-principles model, as the heating and cooling of a
closed space is guided by physical laws, such as Newton Law
of cooling [42]. The law has an exponential nature, therefore
our model structure is based on increasing and decreasing
exponential function.

Model
1
2
3

𝑘𝑜𝑛1
7.7
7.9
6

𝑘𝑜𝑛2
0.11887928
0.11180434
0.14704908

𝑘𝑜𝑓 𝑓 1
5.6
5.2
4.8

𝑘𝑜𝑓 𝑓 2
0.02929884
0.04803319
0.1203876

We propose the following time-discreet model structure

for the 𝑀1

("on") mode:

𝑌 = 𝑘𝑜𝑛1 ∗ (1 − 𝑒−𝑘𝑜𝑛2∗𝑡𝑖) + 𝑇0
("oﬀ") mode:

and for the 𝑀2

𝑌 = 𝑘𝑜𝑓 𝑓 1 ∗ (𝑒−𝑘𝑜𝑓 𝑓 2∗𝑡𝑖) + 𝑇0 − 𝑘𝑜𝑓 𝑓 1

(5)

(6)

, 𝑘𝑜𝑛2

, 𝑘𝑜𝑓 𝑓 1

, 𝑘𝑜𝑓 𝑓 2

- is the starting temperature and 𝑡𝑖

Here 𝑘𝑜𝑛1
are the unique coeﬃcients
deﬁning the model behaviour in a particular environment.
- the discreet time step
𝑇0
value, 𝑌 - the output temperature. We keep the coeﬃcients
in a table, such as Table 4, where coeﬃcients for the three
models are shown. As an example, in Fig. 4 you can see
how the model 1 with the coeﬃcients from the table, ﬁts
the data from real measurements. One model includes two
equations describing behaviour in "on" and "oﬀ" modes. In
total, we identiﬁed 7 models having diﬀerent coeﬃcients in
the equations, corresponding to the thermostat operating in
diﬀerent environmental conditions.

Figure 4: Model (red points) ﬁtting the experimental data
(blue points)

To obtain the coeﬃcients, we ﬁt the experimental data
by a curve with minimal deviation. We used python SciPy
library, namely 𝑐𝑢𝑟𝑣𝑒_𝑓 𝑖𝑡 function from 𝑂𝑝𝑡𝑖𝑚𝑖𝑧𝑒 class,
which is based on the non-linear least squares method [25].

First Author et al.: Preprint submitted to Elsevier

Page 8 of 21

Short Title of the Article

The average root mean square error between original and
approximated data did not exceed 0.5 degrees Celsius.

Next, we specify the requirement for our system and
introduce the ﬁtness function based on this requirement: the
root-mean square error between the scheduled temperature
and the temperature set with the thermostat should not
exceed 1 degree C◦.

To calculate the ﬁrst ﬁtness function, 𝐹1𝑡ℎ𝑒𝑟𝑚

, we execute
the test scenario 𝑇 𝐶 using the simpliﬁed model. We obtain
the output values of the room temperature set by the thermo-
stat 𝑌 and calculate the root-mean square error between 𝑌
and the temperature values deﬁned in the schedule 𝑆:

𝐹1𝑡ℎ𝑒𝑟𝑚 =

√
√
√
√

𝑛
∑

𝑖=1

(𝑌𝑖 − 𝑆𝑖)2
𝑛

,

(7)

(a) Randomly produced scenario

to 0.

where 𝑛 is the number of datapoints in the output. For the
test cases that do not satisfy the restrictions (3) and (4) we
set the 𝐹1𝑡ℎ𝑒𝑟𝑚

We calculate the second ﬁtness function, 𝐹2𝑡ℎ𝑒𝑟𝑚

accord-
ing to (2). In order to prevent obtaining the test cases with
low fault revealing power, we also add a search constraint
𝐶𝑡ℎ𝑒𝑟𝑚

:

𝐶𝑡ℎ𝑒𝑟𝑚 ∶ |𝐹1𝑡ℎ𝑒𝑟𝑚| − 1.5 > 0,

(8)

5.1.4. Genetic algorithm conﬁguration.

We used the following GA (AmbieGen SO) and NSGA-
II (AmbieGen MO) conﬁgurations for the smart thermo-
stat problem: population size: 250, number of generations:
200,mutation rate: 0.4, crossover rate: 1, algorithm type:
generational, number of evaluations: 50 000.

We are using a high mutation rate, as from our ex-
perience, it allowed to converge to better solutions faster.
In our implementation a 𝜇+𝜆 insertion approach is used,
where only the best individuals from previous generation
and oﬀsprings are inserted to the next generation. In the
generational GA the number of oﬀsprings inserted in the
population is equal to the population size. We limit the
number of evaluations to 50000, as typically after this num-
ber was enough for the algorithm to converge. The average
time to run 50000 evaluations was 136.691 sec for GA and
123.665 sec for NSGA-II.

5.1.5. Scenario generation

Finally, we discuss an example of the produced scenar-
ios. In Fig.5a you can see a scenario with a low ﬁtness value
of 0.76 degrees, indicating that the temperature deviates
from the schedule 0.76 degrees on average. On the contrary,
in Fig.5b the scenario produced by AmbieGen search has a
higher ﬁtness of 2.4 degrees. Clearly, this scenario is more
likely to be unacceptable to the user, comparing to the ﬁrst
one.

5.2. Autonomous navigating robot case study

The autonomous robotic systems are used in many do-
mains: from everyday tasks such as room cleaning to critical
missions such as navigation to harsh environments. For

(b) Search produced scenario

Figure 5: Examples of scenarios for the smart thermostat

every application, we need to have a high conﬁdence that
their behaviour will be safe. Running the simulations of
the system in various virtual environments can uncover the
possible failures of the robot in the early design stage.

In this case study we consider an autonomous mobile
robot, navigating in a space with obstacles. The robot has
to reach the goal location, relying only on its range sensors
and the planning algorithm. The goal is to generate the
environment, i.e., a room with obstacles that forces the robot
to fail. Similar test generation problems were addressed by
[39], [6]. In [6] the navigation maps are created using the
procedural content generation technique. Then robots are
assigned a randomized route to follow. The test scenario
is an environment populated with robots, obstructions, and
mission allocations. Sotiropoulos et al. characterize a map
by its size, percentage of obstruction (due to objects), and
its degree of smoothness (resulting from the ground local de-
formations). The robot is given a navigation mission, deﬁned
by a starting position and a target arrival position, situated
in the map boundaries. Both approaches only consider the
random generation.

5.2.1. System under test description

We ran the simulations in the Player/Stage simulation
environment (see Fig. 6), which is one of the most commonly
used in the robotics ﬁeld [27]. We also considered using
such simulators as Gazebo5, MORSE6, and Argos7. One
of the advantages of Player/Stage for our study was the
possibility to load the automatically generated environment
conﬁguration ﬁles as well as the big number of implemented
models and controllers. For Gazebo and MORSE the en-
vironments have to be manually created in a dedicated 3D

5

6

7

http://gazebosim.org/
https://github.com/morse-simulator/morse
https://www.argos-sim.info/

First Author et al.: Preprint submitted to Elsevier

Page 9 of 21

Short Title of the Article

design tool. For Argos, the maps can be generated automat-
ically, however the number of implementation examples is
limited. One of them, which includes a planning algorithm
implementation, is dedicated to robot swarms, which we
plan to explore more in the future [41].

For simulations we used a Pioneer 3-AT mobile robot 8
model provided by the Player/Stage simulator. The robot is
equipped with a SICK LMS200 laser with the sensing range
of 10 meters, it has four wheels and is capable of speeds of
up to 0.8m/s. One of the planning algorithms provided by
the simulator is using the nearness diagram (ND) navigation
method. This is a reactive navigation method, where the
motion commands are computed based on the robot sensor
data. The method computes the optimal motion command to
avoid collisions while moving the robot toward a given goal
location. Before the robot mission starts, it runs the A* plan-
ning algorithm to obtain the route towards the goal. Then it
uses its ND algorithm for navigation. To increase the chal-
lenge for the robot we applied the Ramer–Douglas–Peucker
algorithm 9 to reduce the number of waypoints in the created
route.

Given the goal location the robot should navigate to it
without bumping into obstacles. The testing approach objec-
tive is to ﬁnd environments, when the navigation algorithm
fails and the robot does not reach the goal or the robot hits an
obstacle during the navigation. The scenario is represented
as a bitmap, where the location of obstacles is speciﬁed, as
well as by a set of waypoints for the robot to follow. Failures
are detected by a daemon script that continuously monitors
the simulation environment.

(a) A perspective view in the
simulation environment

(b) A top view in the simulation
environment

Figure 6: Player/Stage simulation environment
tonomous robots

for au-

5.2.2. Problem representation

In this scenario generation case study the environment
is represented by a map with obstacles. We deﬁne the map
size to be 50 x 50 m. Each environment part 𝐸𝑖
corresponds
to a space of the size 1 x 50 m. There is one obstacle in
each environmental element. In total there are 50 elements
, and 50 obstacles in each test case. The scenario matrix
𝐸𝑖
size 𝑀 is ﬁxed and is equal to 50. We deﬁne three attributes

8

https://www.generationrobots.com/media/

Pioneer3AT-P3AT-RevA-datasheet.pdf

9

https://rdp.readthedocs.io/en/latest/

Table 5
Attribute types for autonomous robot problem

𝐴1, 𝑜𝑏𝑠𝑡𝑎𝑐𝑙𝑒 𝑡𝑦𝑝𝑒
[horizontal, vertical]

𝐴2, 𝑜𝑏𝑠𝑡𝑎𝑐𝑙𝑒 𝑠𝑖𝑧𝑒 𝐴3, 𝑜𝑏𝑠𝑡𝑎𝑐𝑙𝑒 𝑝𝑜𝑠𝑖𝑡𝑖𝑜𝑛

[5,6, ..., 15]

[1, 2, ..., 50 ]

Table 6
Example of individual representation for the second case study

𝐴1, 𝑜𝑏𝑠𝑡𝑎𝑐𝑙𝑒 𝑡𝑦𝑝𝑒
𝐴2, 𝑜𝑏𝑠𝑡𝑎𝑐𝑙𝑒 𝑠𝑖𝑧𝑒
𝐴3, 𝑜𝑏𝑠𝑡𝑎𝑐𝑙𝑒 𝑝𝑜𝑠𝑖𝑡𝑖𝑜𝑛

𝐸1
0
15
12

𝐸2
1
10
25

𝐸3
0
10
35

𝐸4
0
15
15

𝐸5
0
10
38

, the type of the obstacle, 𝐴2
describing the environment: 𝐴1
position of the obstacle and 𝐴3
the size of the obstacle. This
gives the size 𝑁 of the scenario matrix of 3. The values for
the attributes are speciﬁed in Table 5. We use two types of
obstacles - vertical and horizontal walls. The size is the total
obstacle length in meters. The position is the obstacle center
location in the element 𝐸𝑖

An example of individual encoding that represents a
map with obstacles in Fig. 7 is shown in Table 6. Here the
map size is 50 m x 25 m and each environmental element
represents a part of the map of the size 50 m x 5 m. For
each environmental element the location of the center of the
obstacle (marked with a green circle) is speciﬁed. Horizontal
obstacle is encoded with the value of 0 and the vertical
obstacle with the value of 1.

.

We deﬁne two restrictions. First, 𝑅1
. Second, 𝑅2

: only one obstacle
per element 𝐸𝑖
: the obstacles cannot cover com-
pletely or intersect with the initial and target robot location
points.

Figure 7: An example of the test case represented by an
individual in table 6

5.2.3. Fitness function deﬁnition

The intelligent robotic systems are typically equipped
with a planning algorithm that builds a path to the goal
location as the robot moves through the environment. The
trajectory is adjusted as the new obstacles are discovered by
the robot.

In the simpliﬁed case, the robot knows about the location
of all the obstacles in advance. Therefore, as the robot
approximated model we are using the Python robotics imple-
mentation of A* planning algorithm [38], which creates the

First Author et al.: Preprint submitted to Elsevier

Page 10 of 21

Short Title of the Article

route given the map, start and destination location. We have
selected the A* because it is a deterministic algorithm and
always ﬁnds a route, if it exists. The disadvantage is that the
computations take longer time, than for non-deterministic
planning algorithms such as RRT*.

The requirement for our system is that the robot should
navigate from the start to the goal location, without bumping
into an obstacle. To falsify this requirement, intuitively, the
test case should force the robot to follow a complex path to
the goal location.

The ﬁrst ﬁtness function, 𝐹1𝑟𝑜𝑏𝑜𝑡

, maximizes the distance
the robot would have to travel to ﬁnd the goal. Evidently,
travelling a longer distance, the robot takes a more complex
path to the goal location, that involves a higher number of
turns. For the test cases that do not meet the restrictions
is set to 0. The second ﬁtness function is
, 𝐹1𝑟𝑜𝑏𝑜𝑡
𝑅1
calculated according to (2).

and 𝑅2

5.2.4. Genetic algorithm conﬁguration

We used the following GA (AmbieGen SO) and NSGA-
II (AmbieGen MO) conﬁgurations: population size: 100,
number of generations: 400, mutation rate: 0.4, crossover
rate: 1, algorithm type: steady state with 50 oﬀsprings,
number of evaluations: 20,000.

For this problem we used a smaller number of oﬀsprings
to run more generations for the same time budget. The A*
algorithm implementation was computationally expensive to
execute. The average time to run 20,000 evaluations was
2,727.2 sec for AmbieGen SO and 2,394.9 sec for AmbieGen
MO.

5.2.5. Scenario generation

In Fig.8 we show examples of the generated scenarios,
i.e., rooms with obstacles obtained by random generation
Fig. 8a and with AbmieGen Fig. 8b. In Fig. 8a the length of
the robot path towards the goal is 78.76 meters, while in the
Fig. 8a it is 202.36 meters. Evidently, the second scenario
poses a more challenging navigation environment for the
robot, than the ﬁrst scenario. The video demonstration of
the fault revealed for the robot model in the Player/Stage
environment can be found via the link: https://figshare.
com/s/7208f6d5ce19e1476474.

(a) Random scenario

(b) Search produced scenario

Figure 8: Examples obtained robot navigation maps

5.3. Lane keeping assist system case study

Self-driving cars have a perspective of becoming a part
of our lives in the near future. These systems are safety-
critical and should be well tested to avoid unwanted con-
sequences. Running the simulations in the virtual environ-
ments can reveal the possible faults of their control algo-
rithms.

In this case study, we generate virtual roads to test car
Lane Keeping Assist System (LKAS). The ego-car, i.e., the
test subject, should follow the lane of a given trajectory. The
testing approach goal is to generate a valid road topology,
that forces the ego-car to drive oﬀ its lane . A number
of tools were suggested for automatic generation of virtual
roads, such as DeepJanus [36] and AsFault [20]. This year,
four tools, such as Frenetic, Deeper, Swat, and GA-Bézier
were presented at the SBST2021 tool competition [34]. The
SWAT tool is the submission of the random generator based
implementation of our approach for virtual road generation.

5.3.1. System under test description.

For simulating the car and the environment, we used the
simulation pipeline initially provided by [36] and adapted
for the SBST2021 tool competition. This environment uses
the BeamNG.tech driving simulator [8], a freely avail-
able research-oriented version of the commercial game
BeamNG.drive (see Fig. 9). The test subject is the builtin
driving agent, BeamNG.AI. The car controller adopts a
behavioural cloning approach, i.e., the deep learning com-
ponent (DN) learns a direct mapping from the sensor camera
input to the steering angle value to be passed to the actuators
[14].

Figure 9: The screenshot from a BeamNG simulation environ-
ment

5.3.2. Problem representation

In this case study, the test scenario is a ﬂat road sur-
rounded by plain green grass with the ﬁxed weather con-
ditions: sunny clear day. The road layout (i.e., number and
width of lanes) is ﬁxed and consists of two lanes.

We divide the road into 𝑚 road segments. Each envi-
ronment element 𝐸𝑖
corresponds to one road segment. To
describe the road segment we deﬁne three attributes: the type
: going straight, turning right and turning left.
of the road 𝐴1
: the angle
𝐴2
of the turn of the curved segment. The attributes representa-
tion is shown in Table 7. The test scenario contains 3 rows

: the length of the straight road segment, and 𝐴3

First Author et al.: Preprint submitted to Elsevier

Page 11 of 21

Table 7
Attribute types for vehicle problem

Table 9
Fine tuned values for the surrogate model

Short Title of the Article

𝐴1, 𝑟𝑜𝑎𝑑 𝑠𝑒𝑔𝑚𝑒𝑛𝑡 𝑡𝑦𝑝𝑒 𝐴2, 𝑠𝑡𝑟𝑎𝑖𝑔ℎ𝑡 𝑟𝑜𝑎𝑑 𝑙𝑒𝑛𝑔𝑡ℎ 𝐴3, 𝑟𝑜𝑎𝑑 𝑡𝑢𝑟𝑛 𝑎𝑛𝑔𝑙𝑒
[5, 6, ..., 50]

[5, 10,..., 85 ]

["straight",
"turn left",
"turn right"]

Table 8
Example of individual representation for the second case study

𝐴1, 𝑟𝑜𝑎𝑑 𝑡𝑦𝑝𝑒
𝐴2, 𝑠𝑡𝑟𝑎𝑖𝑔ℎ𝑡 𝑟𝑜𝑎𝑑 𝑙𝑒𝑛𝑔𝑡ℎ
𝐴3, 𝑡𝑢𝑟𝑛𝑖𝑛𝑔 𝑎𝑛𝑔𝑙𝑒

𝐸1
0
15
0

𝐸2
1
-
60

𝐸3
1
-
60

𝐸4
2
-
75

𝐸5
0
5
0

(𝑁 = 3) and a variable number of columns 𝑀, depending
on how many road segments ﬁt in a map. In our scenarios
and at SBST competition, the map size was 200 x 200 m.

Figure 10: An example of the test case represented by an
individual in table 8

An example of individual encoding that represents a
road topology illustrated in in Fig.10 is shown in Table 8.
Each environmental element, 𝐸𝑖, 𝑖 ∈ [1, 5], represent one
road segment. The road segments are encoded as follows: 0
- for straight type, 1 - turning right and 2 - turning left .

The test cases have the following restrictions : the roads
cannot be too sharp, cannot
intersect and should not go
out of the map bounds. Examples of valid and invalid roads
are shown in Fig. 11.

Figure 11: Examples of valid (a) and invalid roads: (b) - out
of bounds, (c) - too sharp, (d ) - intersecting

𝜈0
7

𝑘
3.5

𝛼
0.3

𝛽
0.1

5.3.3. Fitness function deﬁnition

To calculate the test scenario ﬁtness we need to create
the simpliﬁed model of the car. Similarly to the thermostat
problem, we built the car model from the ﬁrst principles as
the car movement can be described by a well known car
kinematic model [28]. To describe the car movement we use
the equations from [3], see Fig.12. To keep the car close to
the lane center we adopt Stanley control [22].

Figure 12: The simpliﬁed car model parameters

In the equations below, 𝑥, 𝑦 - are the current coordinates
of the car on the map, 𝜃 is the angle between car direction
and a reference plane, 𝑎 and 𝑏 - constants, corresponding to
velocity value, 𝑑 - the distance of the car from the closest
point on the road. When 𝑑 is smaller than a certain threshold
𝑒, the car goes straight, when 𝑑 is larger than 𝑒 - the car turns
either left or right. The turn angle is adopted depending on
the car speed and the deviation from the road lane center.

Therefore we have the following ﬁne-tunable param-
. In order to ﬁne
eters: 𝑘, 𝛼, 𝛽 and the initial speed 𝜈0
tune the parameters, we created a dataset with the road
points and the corresponding car model path 𝑆 recorded
by the simulator while executing the scenarios. Then we
compared the outputs of our model with the simulated car
path using such metric as a "Hausdorﬀ distance". A similar
metric, Frechet distance, was used in [26] to compare the
similarity between roads. The goal was to minimize the
Hausdorﬀ distance. To perform the optimization we use the
sci-py Nelder-Mead algorithm implementation. However,
other optimization algorithms can be used, such as genetic
algorithms. The set of the parameters that indicated the
lowest average Hausdorﬀ distance of 13.74 is shown in Table
9.

̇𝑥 = 𝜈 ⋅ 𝑐𝑜𝑠𝜃
̇𝑦 = 𝜈 ⋅ 𝑠𝑖𝑛𝜃

̇𝜃 =

tan−1( 𝑘
)
⎧
𝜈(𝑡)
⎪
− tan−1( 𝑘
⎨
𝜈(𝑡)
⎪
0
⎩

)

𝑖𝑓 𝑑 < −𝑒

𝑖𝑓 𝑑 > 𝑒
𝑖𝑓 − 𝑒 ≤ 𝑑 ≤ 𝑒

(9)

(10)

(11)

First Author et al.: Preprint submitted to Elsevier

Page 12 of 21

{

̇𝜈 =

−𝛼 𝑖𝑓 𝑑 < −𝑒, 𝑑 > 𝑒
𝛽

𝑖𝑓 − 𝑒 ≤ 𝑑 ≤ 𝑒

Short Title of the Article

(12)

Figure 13: The simpliﬁed and full car model trajectory given
the same road points

In Fig.13 we depict the surrogate (blue points) and the
full model (green points) follow the interpolated road points
(yellow). The Hausdorﬀ distance between the two roads is
5.153.

In this case study the requirement for the vehicle is to
stay within the road lane bounds and not go out of the lane
for more than a deﬁned threshold, proportional to the area
of the vehicle outside the lane. For instance, the threshold of
0.5 means, that the car is considered to be out of the lane if
more than the half of the vehicle lies outside the lane. In our
case study we use a threshold of 0.85.

Finally, as the ﬁtness function, 𝐹1𝑣𝑒ℎ

, we used the max-
imum deviation 𝑑 from the lane center after executing the
test case, as in [20] and [35]. The test cases with the highest
value of the ﬁtness function are most likely to violate the
requirement, as they force the car to deviate further from the
lane centre. For the test cases that don’t meet the restrictions,
is set to 0. The second ﬁtness function was calculated
𝐹1𝑣𝑒ℎ
according to (2).

5.3.4. Genetic algorithm conﬁguration.

We used the following GA and NSGA-II conﬁgurations:
population size: 500, number of generations: 200, mutation
rate: 0.4, crossover rate: 1, algorithm type: generational,
number of evaluations: 100 000.

We are using a higher population size, rather than the
bigger number of generations, as from our experience, with
bigger population the results were more consistent across
diﬀerent runs. The average time to run 100000 evaluations
was 1522.405 sec for GA and 1380.66 sec for NSGA-II.

Figure 14: The road points (black) generated after applying
aﬃne transformations to the initial vector 𝜈1

degrees anticlockwise ("turn left N degrees"). In the Fig. 15
we show examples of the generated test cases, that forced the
car to go out of the lane. The yellow points correspond to
the road lane center, the blue points - to the surrogate model
path, green points - the full model path. When the virtual
car went out of the lane bounds, the simulation recording
stopped, therefore we see the full model path only for the
part of the road. The video demonstration of the failure for
the car model can be found via the link: https://figshare.
com/s/b4a096f0a66e0abbe7b1.

6. Experimental evaluation
6.1. Research questions

We evaluate our approach using the three test case gen-
eration case studies described above. For each of the case
studies we answer the following research questions.

RQ1. (Comparing random, single-objective, and multi-

objective search). Considering the single and multi objec-
tive versions of AmbieGen as well as the random search,
which conﬁguration produces the test scenarios with the
higher fault revealing power given the same time budget?

Motivation: Firstly we would like to know if the use of
evolutionary search is beneﬁcial and allows to produce better
solutions, than simple random search. Next, we want to know
if adding additional ﬁtness function for diversity allows to
ﬁnd solutions with a higher fault revealing power. We expect
AmbieGen MO to produce solutions with the fault revealing
power, i.e., 𝐹1
ﬁtness function value at least as high as for
the solutions of AmbieGen SO. Previous works on novelty
search [18], [32] have shown that adding a ﬁtness function
for diversity may increase the convergence speed.

5.3.5. Scenario creation

To create the road points 𝑝1 − 𝑝7

, used to generate the
road, we applied aﬃne transformations to the initial vector
, according to the road types speciﬁed in the generated sce-
𝜈1
nario, i.e., "straight N meters", "turn right/left N degrees".
Our approach is described in a more detail in [23].

Experiment design: We give the same number of evalu-
ations to all the three algorithms and compare the average 𝐹1
ﬁtness function value of the best solutions found. We repeat
the measurements 30 times.

RQ2. (Comparing diversity of the solutions found by
the single-objective and multi-objective search). To what

For example, to obtain 𝜈2

we moved the 𝜈1

meters ("straight N meters"). To obtain 𝜈3

paralelly N
N

we turned 𝜈2

First Author et al.: Preprint submitted to Elsevier

Page 13 of 21

Short Title of the Article

(a) Scenario forcing the car to drive oﬀ the lane

(b) Scenario forcing the car to drive oﬀ the lane

Figure 15: Examples of fault revealing scenarios for vehicle lane keeping assist system

extent the diversity of the solutions found by the multi objec-
tive AmbieGen conﬁguration is higher than the diversity of
the single objective conﬁguration solutions?

Motivation: This research question is aimed to quantify
the diﬀerence between the diversity of the solutions pro-
duced by AmbieGen So and AmbieGen MO. We expect the
AmbieGen MO to produce more diverse scenarios.

Experiment design: Given the same time budget, we
compare the average diversity of the best 10 solutions found
by the single-objective algorithm and the average diversity
of the Pareto optimal solutions found by the multi-objective
algorithm. We repeat each measurement 30 times.

For the autonomous robot and lane keeping assistant case

study we also answer the following question:

RQ3. (Comparing our AmbieGen with the available
baselines) To what extent does our approach perform better
in generating test scenarios for the full model in comparison
with the available baselines?

Motivation: This research question is aimed to quantify
the eﬀectiveness of AmbieGen in the number of revealed
failures for the full models used in simulations.

Experiment design:
Autonomous robot case study. To the best of our knowl-
edge, there are no available test generation baselines for
the autonomous robot system. Therefore we compare the
generated scenarios with the random search by giving the
same time budget of two hours and executing the generated
environments in the robotic simulator. We repeat the exper-
iment 30 times.

Lane keeping assist system. For the lane keeping assist
system, we compare AmbieGen with the open-source ap-
proach that showed the best results in the SBST2021 tool
competition [34], i.e., Frenetic tool [13]. In the competition
the same test evaluation pipeline was provided to all the
participants. It allowed to compare the generated test cases
for the number of faults revealed (forcing the ego-car to go
out of the lane), the diversity of the revealed faults and the
proportion of valid test cases. We perform the same 2 hour
experiment as in the competition, averaging the results over
30 runs.

Table 10
Results of two-tailed non-parametric Mann-Whitney U test and
Cliﬀ’s delta eﬀect sizes for the thermostat case study

𝑆𝑂 (𝐺𝐴)

𝑀𝑂 (𝑁𝑆𝐺𝐴2) 𝑅𝑎𝑛𝑑𝑜𝑚

𝑆𝑂 (𝐺𝐴)
𝑀𝑂 (𝑁𝑆𝐺𝐴2)

𝑅𝑎𝑛𝑑𝑜𝑚

𝑝 = 0.378
0.133, 𝑛𝑒𝑔𝑙𝑖𝑔𝑖𝑏𝑙𝑒
𝑝 < 0.01
1, 𝑙𝑎𝑟𝑔𝑒

𝑝 < 0.01
1, 𝑙𝑎𝑟𝑔𝑒

For all the research questions, to conﬁrm the statistical
signiﬁcance of the results we performed a two-tailed non-
parametric Mann-Whitney U test and measured the eﬀect
size using the non-parametric measure Cliﬀ’s delta. We ran
all the experiments on a PC running Microsoft Windows 10
Home and featuring a quad-core AMD Ryzen 7 4800HS
CPU @ 2.90 GHz, 16 GB of Memory, and an NVidia
GeForce GTX 1660 GPU @ 6GB.

6.2. Results

RQ1.(Comparing random, single-objective, and multi-
objective search) In the Fig. 16, Fig. 17, and Fig. 18,
we present the best ﬁtness value found over generations
by Random search (green boxplots), AmbieGen SO (red
boxplots) and AmbieGen MO (blue boxplots) averaged
over 30 runs for the three problems. We considered the
ﬁtness function accounting for the fault revealing power and
described in Equation (1).

We compare the ﬁtness function values found after
the allowed number of evaluations with a two-tailed non-
parametric Mann-Whitney U test. The obtained p-values and
eﬀect sizes of the problems are shown in the Tables 10, 11,
and 12, respectively.

Thermostat case study. From Fig. 16 we can see that
on average random search (yellow) converges to values
of -1.608, while AmbieGen SO (red) and AmbieGen MO
(blue) ﬁnd the solutions with twice higher ﬁtness value of
-3. Statistical tests conﬁrm that AmbieGen outperforms the
random search with p < 0.01. We can observe that on average
the SO converges faster than MO, however, the diﬀerence
between the converged values is negligible.

First Author et al.: Preprint submitted to Elsevier

Page 14 of 21

Short Title of the Article

Table 12
Results of two-tailed non-parametric Mann-Whitney U test and
the Cliﬀ’s delta values for lane keeping assistant case study

𝑆𝑂 (𝐺𝐴) 𝑀𝑂 (𝑁𝑆𝐺𝐴2) 𝑅𝑎𝑛𝑑𝑜𝑚

𝑆𝑂 (𝐺𝐴)
𝑀𝑂 (𝑁𝑆𝐺𝐴2)

𝑅𝑎𝑛𝑑𝑜𝑚

𝑝 = 0.0501
0.295, 𝑠𝑚𝑎𝑙𝑙
𝑝 < 0.01
0.877, 𝑙𝑎𝑟𝑔𝑒

𝑝 < 0.01
0.886, 𝑙𝑎𝑟𝑔𝑒

no statistical diﬀerence in the produced solutions for the
thermostat and lane keeping assistance problem. For the au-
tonomous robot problem, the AmbieGen SO produces better
solutions with a large eﬀect size given 20000 evaluations.

Figure 18: Best ﬁtness function value over evaluations for the
lane keeping assistant case study

AmbieGen SO produced scenarios with highest
fault revealing power for the autonomous robot case
study. For the thermostat and LKAS case studies
the diﬀerence in the solution ﬁtness of AmbieGen
SO and MO was negligible. Overall, AmbieGen
outperforms the random search with "large" eﬀect
size in all case studies.

RQ2.(Comparing diversity of the solutions found by
the single-objective and multi-objective search). In Fig.
19, Fig.20, and Fig. 21, we compare how diverse are the
produced solutions by AmbieGen SO and AmbieGen MO.
For SO, we select 10 ﬁttest individuals and compute the
diversity according to (2) between each pair of individuals.
We report the average value. For NSGA-II, we compute the
diversity (2) between each pair of Pareto optimal solutions.
The size of the Pareto front was 7 individuals on average. All
the solutions in the Pareto front have a fault revealing (𝐹1
)
ﬁtness function value higher than a certain fault-revealing
threshold, established by the developer.
the problems,

the two-tailed non-parametric
Mann-Whitney U test conﬁrmed that AmbieGen MO pro-
duces more diverse solutions, than AmbieGen SO. For
the smart thermostat problem, the MO scenarios are more
diverse with a p-value smaller than 0.01 and a "large" eﬀect

For all

Figure 16: Best ﬁtness function value over evaluations for the
thermostat case study

Table 11
Results of two-tailed non-parametric Mann-Whitney U test and
the Cliﬀ’s delta values for the autonomous robot case study

𝑆𝑂 (𝐺𝐴) 𝑀𝑂 (𝑁𝑆𝐺𝐴2) 𝑅𝑎𝑛𝑑𝑜𝑚

𝑆𝑂 (𝐺𝐴)
𝑀𝑂 (𝑁𝑆𝐺𝐴2)

𝑅𝑎𝑛𝑑𝑜𝑚

𝑝 < 0.01
0.772, 𝑙𝑎𝑟𝑔𝑒
𝑝 < 0.01
1, 𝑙𝑎𝑟𝑔𝑒

𝑝 < 0.01
0.978, 𝑙𝑎𝑟𝑔𝑒

Autonomous robot case study. After 20000 evaluations,
on average, random search produced solutions with the
highest ﬁtness value of -158.89. AmbieGen outperforms
the random search, with the SO conﬁguration producing
42 % ﬁtter solutions of -278.2 and the MO conﬁguration
producing solutions of -251.6 ﬁtness value. Given the same
time budget, AmbieGen SO produces almost 10 % ﬁtter
solutions than AmbieGen MO.

Figure 17: Best ﬁtness function value over evaluations for the
autonomous robot case study

Lane keeping assistant case study. In 100000 evaluations
random search produced scenarios with the average highest
ﬁtness of -9. AmbieGen MO and SO produced almost 50
% ﬁtter solutions of -17 and -16, respectively. There was no
statistical diﬀerence between the best solutions of SO and
MO.

Overall, We can see that for all the problems, AmbieGen
ﬁnds on average from 40 % to 50 % better solutions, than
the random search. AmbieGen SO and AmbieGen MO show

First Author et al.: Preprint submitted to Elsevier

Page 15 of 21

Short Title of the Article

size of 0.852. For the autonomous robot problem, AmbieGen
MO scenarios are more diverse with a p-value smaller and
a "large" eﬀect size of 1. For the lane keeping assist system,
MO scenarios are more diverse with a p-value of 0.0109
(𝑝 ≤ 0.05) and a "medium" eﬀect size of 0.383.

Figure 19: Diversity of the test cases in the last generation for
the thermostat case study

(RQ1, RQ2 summary:) AmbieGen MO can ﬁnd sce-
narios of the same quality as AmbieGen SO and
better scenarios with a large eﬀect size than the
random search. Moreover, AmbieGen MO produces
a more diverse set of scenarios, than AmbieGen SO.
Overall, we recommend using the AmbieGen MO
conﬁguration.

RQ3.(Comparing AmbieGen with the available base-

lines).

Autonomous robot case study. In this subsection we
compare the number of faults revealed by the NSGA-II con-
ﬁguration of AmbieGen (AmbieGen MO) and the random
search. We created a scenario evaluation pipeline, where
ﬁrstly a two hour budget is given to produce the scenarios.
Then all the scenarios are passed to the simulator and exe-
cuted. The daemon script monitors the execution and reports
a failure when the robot stalls and does not reach a goal. We
repeated the experiment 30 times in both conﬁgurations. You
can see the average number of failures detected in Fig. 22.
AmbieGen produced on average 9 failures in two hours, in
comparison to the 2 failures of random search. AmbieGen
outperforms the random search with a p-value less than 0.01
and a large eﬀect size of 1.

Figure 20: Diversity of the test cases in the last generation for
the autonomous robot case study

Figure 21: Diversity of the test cases in the last generation for
the lane keeping assistant case study

In all the considered problems AmbieGen MO pro-
duced more diverse test cases: with "large" ef-
fect size for thermostat and robot case studies and
"medium" eﬀect size for the LKAS case study.

Figure 22: Number of faults revealed for the autonomous robot

Lane keeping assist system case study. In this subsec-
tion we report results of evaluating AmbieGen MO (Am-
bieGen) and the Frenetic tool (Frenetic). In addition we
evaluate the random search (RS) conﬁguration of AmbieGen
and the AmbieGen MO conﬁguration based on the full
model (Full).

For AmbieGen we used a simpliﬁed conﬁguration for
virtual road generation, where only, 5,100 evaluations are
performed (population size 100, number of generations 200,
number of oﬀsprings - 25) in order to produce more test
scenarios given a limited time budget. We gave the same time
budget (5,090 evaluations) for the random search to produce
the solutions.

Finally, for the full model we used a conﬁguration pre-
viously suggested by Gambi et al. [20] for Asfault tool,
that also uses the full model to guide the search. In this
conﬁguration the population size is 25, number of oﬀsprings
is 4 and the number of generations is limited by the time
budget, i.e, two hours.

First Author et al.: Preprint submitted to Elsevier

Page 16 of 21

Short Title of the Article

Table 13
Mann-Whitney test p value and Cliﬀ’s delta for the number of
faults

Table 14
Mann-Whitney test p value and Cliﬀ’s delta for the fault
sparsity

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛

𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐

𝐹 𝑢𝑙𝑙

𝑅𝑆

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛
𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐

𝐹 𝑢𝑙𝑙

𝑅𝑆

𝑝 = 0.917
0.0166, 𝑛𝑒𝑔𝑙𝑖𝑔𝑖𝑏𝑙𝑒
𝑝 < 0.01
0.996, 𝑙𝑎𝑟𝑔𝑒
𝑝 < 0.01
0.653, 𝑙𝑎𝑟𝑔𝑒

𝑝 < 0.01
0.991, 𝑙𝑎𝑟𝑔𝑒
𝑝 < 0.01
0.578, 𝑙𝑎𝑟𝑔𝑒

𝑝 < 0.01
0.951, 𝑙𝑎𝑟𝑔𝑒

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛

𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐

𝐹 𝑢𝑙𝑙

𝑅𝑆

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛
𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐

𝐹 𝑢𝑙𝑙

𝑅𝑆

𝑝 = 0.897
0.020, 𝑛𝑒𝑔𝑙𝑖𝑔𝑖𝑏𝑙𝑒
𝑝 = 0.0889
0.3238, 𝑠𝑚𝑎𝑙𝑙
𝑝 = 0.912
0.018, 𝑛𝑒𝑔𝑙𝑖𝑔𝑖𝑏𝑙𝑒

𝑝 = 0.0998
0.315, 𝑠𝑚𝑎𝑙𝑙
𝑝 = 0.794
0.042, 𝑛𝑒𝑔𝑙𝑖𝑔𝑖𝑏𝑙𝑒

𝑝 = 0.147
0.285, 𝑠𝑚𝑎𝑙𝑙

Approaches were evaluated using the SBST2021 code
pipeline [35], that integrates the test generators with the
BeamNG simulator by validating, executing, and evaluating
the generated test cases. We executed the SBST21 2 hour
experiment, where the failure is revealed when 0.85 percent
of the car area goes out of the lane. Also, the driving agent
travels up to 70 Km/h.

The test cases are compared in terms of the number of
faults Fig. 23, the diversity of the faults Fig. 24, and the
proportion of the valid test cases Fig. 25. The corresponding
statistical test and eﬀect size measures (Cliﬀ’s delta) are
shown in the Tables 13, 14 and 15.

Table 15
Mann-Whitney test p value and Cliﬀ’s delta for the proportion
of valid cases

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛

𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐

𝑅𝑆

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛
𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐

𝑅𝑆

𝑝 < 0.01
1, 𝑙𝑎𝑟𝑔𝑒
𝑝 < 0.01
0.997, 𝑙𝑎𝑟𝑔𝑒

𝑝 = 0.011
0.386, 𝑚𝑒𝑑𝑖𝑢𝑚

Table 16
Number of total, valid and invalid test cases

𝐴𝑚𝑏𝑖𝑒𝐺𝑒𝑛
𝐹 𝑟𝑒𝑛𝑒𝑡𝑖𝑐
𝑅𝑆

𝑇 𝐶𝑠
150
190.3
86.53

𝑉 𝑎𝑙𝑖𝑑
137.8
136.46
65.32

𝐼𝑛𝑣𝑎𝑙𝑖𝑑
12.23
53.83
21.21

Concerning the diversity of the revealed faults, all the
approaches have similar performance and do not show a
statistically signiﬁcant diﬀerence.

Figure 23: The number of revealed faults

In terms of the number of the revealed faults both,
AmbieGen and Frenetic, statistically outperform the random
search and the full model based search. Out of 30 runs,
on average, AmbieGen and Frenetic produce almost equal
amount of faults, i.e., 14.

Figure 24: The diversity of the revealed faults

Figure 25: The proportion of the valid test cases

Another important factor was the proportion of valid test
cases out of all the cases produced. From Table 15 we see
that AmbieGen produces a statistically larger proportion of
the valid test cases, than Frenetic and random search. For the
full model, the invalid scenarios were assigned the ﬁtness
value of 0 and not submitted for evaluation. In Table 16
we also indicate the average number of the total produced
test cases as well as the number of invalid and valid test
cases. For the full number, initially the 25 individuals were
produced that were later evolved by the search operators.

First Author et al.: Preprint submitted to Elsevier

Page 17 of 21

Short Title of the Article

SBST2021 code pipeline evaluates the test cases procedu-
rally, i.e., as soon as the valid test case is produced it is
executed. The new test case can only be produced, when the
execution of the previous one stops. The scenario execution
time depends on the generated road length, i.e., the longer
the road, the more time the car will spend in the simulation.
Therefore, we do not evaluate the approaches by the total
number of the produced scenarios, as it depends not only on
the eﬃciency of the algorithm, but also on the duration of the
generated scenarios. The random search generates the lowest
number of solutions as it only provides one solution after
5,090 evaluations. AmbieGen, on the contrary, provides
around 7 solutions on average, corresponding to the search
Pareto front after 5,090 evaluations.

AmbieGen reveals 9 failures in two hours, in com-
parison, random search could reveal only 2 failures
for the robot case study. Both AmbieGen and state of
the art Frenetic tool revealed 14 failures in two hours.
The revealed faults have similarly high diversity for
both tools. AmbieGen outperforms Frenetic in the
proportion of the valid generated scenarios. Am-
bieGen also outperforms the random search and the
full model conﬁguration in the number of revealed
faults.

7. Discussion

In this section we discuss the implications of our ﬁndings

for research and the practice.
Evolutionary algorithms for scenario generation. Evolu-
tionary algorithms were proven to be eﬀective, comparing to
random generation, to create virtual environments for testing
automotive systems in previous works such as [9], [20], [36].
The implementation of such algorithms to generate envi-
ronments is rather challenging as the customized solution
representation and search operators need to be developed.

In our work we extend the application of evolutionary
search for environment generation to such domains as smart-
homes and autonomous robots . This work is the ﬁrst stage in
designing a framework for generating virtual environments,
AmbieGen. We consider the complete virtual environment
to be composed of separate elements. Each element is de-
scribed with a ﬁxed number of attributes. During the search
we recombine the elements as well as their attributes. One
of the advantages of such representation is the simplicity of
implementation of initial population generation, crossover
and mutation search operators. Therefore the developer only
needs to consider a high level description of the problem
and not concentrate on the design of search operators and
solution representation. By adding more attributes, the sce-
nario complexity can be increased. For the smart-thermostat,
for example, we can add such attributes as the humidity
inside the room and temperature outside the room for each
time period. For the autonomous robot - the terrain type and
indicate the presence of other robots. For the car, for each

road section we can indicate the terrain type, the incline, the
location of the other vehicles, etc.

Overall, our study conﬁrms the eﬀectiveness of search
based approaches for environment generation. Our frame-
work is aimed to reduce the eﬀort of the developers of evo-
lutionary algorithms to test the autonomous CPS. We pro-
vide the structure of the solution representation and search
operators, which can be applied to generation of diﬀerent
types of environments. We provide examples of generating
smart-thermostat schedules, maps with obstacles and virtual
roads with search algorithm implementation based on Py-
moo framework.

Using simpliﬁed system models. We explore the possi-
bility to use the approximated system models, rather than the
full models to compute the ﬁtness function. Evidently, full
models can detect failures with a higher precision, however
they are more expensive to execute in terms of resources and
time budget. For instance, the recommended requirements
for running BeamNg simulator are 16 GB RAM, Nvidia
GeForce GTX 970 videocard and Intel Core i7-6700 3.4Ghz
processor or better. Our evaluations have shown that the
full model failures can be detected by an approximated
model. Moreover, given the same time budget the search
guided by the approximated model may reveal more faults,
than when guided by the full model. We advocate for the
development of more precise simpliﬁed CPS models and
making them open source, so that they can be easily used
by researchers to calculate the search ﬁtness functions. The
possibility to use the surrogate models was ﬁrst suggested by
[30], however it was used only to generate the CPS inputs.
In [9] the approximated models were used to generate the
environments, however no comparison with the full model
conﬁguration was provided.

Challenges. The challenging part of AmbieGen imple-
mentation is in evaluating the test scenario ﬁtness. It consists
of two stages: the ﬁrst is to convert the high level description
matrix 𝑇 𝐶 to the environment conﬁguration. For the smart
thermostat we needed to convert the 𝑇 𝐶 matrix to the list
of temperatures to follow, for an autonomous robot - to the
coordinates of obstacles in a map, which was rather simple.
For the LKAS case study we needed to transform the 𝑇 𝐶
matrix to a set of 2D coordinates, that will produce valid
roads after cubic spline approximation. This conversion was
more complex and we developed a new technique leveraging
aﬃne transformations to vectors. Next challenge was to
create an approximated model. For the autonomous robot we
used an implementation provided by the Python Robotics
project. For the LKAS, we implemented the model from
scratch. The available open source implementations were
rather time consuming to execute. We also created the model
from the real data for the thermostat case study as we did not
ﬁnd any open source full models.

Finally, it was challenging to ﬁnd baselines and pipelines
to evaluate the produced scenarios. For the autonomous
robot, we implemented a simple test evaluation pipeline,
based on the Player/Stage simulator. More advanced simu-
lators require the manual creation of the scenarios in the 3D

First Author et al.: Preprint submitted to Elsevier

Page 18 of 21

Short Title of the Article

design tools. Fortunately, for the LKAS case study we could
use the test evaluation pipeline provided by the SBST2021
competition.

In conclusion, we advocate for the creation of open
source approximated and full models of CPS. Moreover, it
is important to establish more test evaluation pipelines and
baselines, similar to the LKAS system for other domains of
CPS. Finally, we surmise that the CPS simulators should
provide a possibility to create environment from conﬁgura-
tion ﬁles or an API to automate the design of environments.

autonomous cyber-physical agents. However, we only con-
sidered a limited number of test subjects and limited levels of
environment complexity. Therefore more problems should
be addressed with diﬀerent agents and higher environment
complexity to make deﬁnitive conclusions about the general-
izability of AmbieGen. Nonetheless, our evaluations demon-
strated that AmbieGen was eﬀective in revealing unwanted
behaviours for all the three considered autonomous CPS
agents.

8. Threats to validity

We now discuss potential threats to the validity of the

results of our study, following existing guidelines [43].

Internal validity. To minimize the threats to internal
validity, relating to experimental errors and biases, whenever
available, we used standardized frameworks for develop-
ment and evaluation. We implemented all the evolutionary
search algorithms (GA and NSGA-II) using a standartd
Python Pymoo framework. To evaluate the scenarios for
the LKAS case study we used a standardized test pipeline
used for SBST2021 workshop tool competition. For the
autonomous robot case study we created a customized test
evaluation
pipeline, which is based on the open source Player/Stage
robotic simulator. It provides implementations of the widely
used robotic models, such as Pioneer 3-AT, and planning al-
gorithms. This simulator was previously used by researchers
to conduct similar evaluations, as in [6].

Conclusion validity. Conclusion validity is related to
random variations and inappropriate use of statistics. To
mitigate it, we followed the guidelines in [5] for search-
based algorithm evaluation. We ran each evaluation at least
30 times and ensured the statistical signiﬁcance of the results
by using a two-tailed non-parametric Mann-Whitney U test
and Cliﬀ’s delta.

Construct validity. Construct validity is related to the
degree to which an evaluation measures what it claims. To
compare the test generation algorithms we gave the same
time budget to all the algorithms to produce the solutions.
For all the algorithms we evaluated the best ﬁtness found,
accounting for the scenario fault revealing power. To com-
pare the tools in terms of number of revealed faults we gave
each tool the same time budget to produce the scenarios. To
measure the diversity of the test scenarios we used a standard
metric such as Jaccard distance, previously used in other
studies to compare the diﬀerence between the test cases.
The exact implementation of this metric is, however, case
study speciﬁc and thus can introduce some additional bias.
Furthermore, the results produced by AmbieGen depend on
the implementation of the approximated model. Presumably,
higher quality surrogate models can produce more failures of
the full model and improve the AmbieGen performance.

External validity. External validity relates to generaliz-
ability of our results. We demonstrated how our framework
can be applied to generate environments for three diﬀerent

9. Conclusions and future work

In this paper we presented the design of AmbieGen, a
framework for generating virtual environments for testing
autonomous cyber-physical systems. It leverages evolution-
ary search guided by the approximated model of system. We
applied it to generating scenarios for the smart-thermostat,
autonomous robotic system, and vehicle lane keeping as-
sist system. Given the same time budget, AmbieGen could
generate on average 40 - 50 % ﬁtter solutions, than ran-
dom search. Moreover, AmbieGen was eﬀective at detecting
faults of the full model. In two hours it could ﬁnd 9 failures of
the Pioneer 3-AT mobile robot in the Player/Stage simulator,
comparing to only two failures found by random search. For
the full model of the vehicle, equipped with lane keeping
assist system, AmbieGen found 14 failures on average, the
same as the state of the art baseline - Frenetic. Random
search only found 8 failures on average. AmbieGen outper-
formed Frenetic in the number of valid generated scenarios
with a large eﬀect size.

Comparing the two proposed conﬁgurations of Am-
bieGen, the single objective (AmbieGen SO) and multi ob-
jective (AmbieGen MO), AmbieGen SO may ﬁnd ﬁtter so-
lutions than AmbieGen MO given the same time budget. In
two hours, for the autonomous robot case study, AmbieGen
SO found 10 % ﬁtter solutions than AmbieGen MO. For the
other case studies the diﬀerence in the best found solutions
ﬁtness was insigniﬁcant. Overall, we recommend using the
multi objective conﬁguration of AmbieGen, AmbieGen MO,
as it always produced a more diverse set of solutions with
medium to large eﬀect size and on average could ﬁnd almost
as ﬁt solutions as AmbieGen SO.

We plan to continue the research in four directions. First
is creating more complex environments, taking into account
the weather, environmental conditions, and the moving ob-
stacles such as other robots or cars. We also plan to expand
the scenario generation to other CPS, such as drone and robot
swarms. Secondly, we will explore the possibility to create
more precise simpliﬁed models using the system identiﬁca-
tion techniques, including neural networks and NARIMAX
models. Thirdly, it is important to have the pipelines for
evaluating the generated scenarios. We plan to improve our
evaluation pipeline for autonomous robots by using more
sophisticated simulators such as Argos and Gazebo and more
complex models of robots. We will also work on developing
evaluation pipelines dedicated to other types of CPS. Finally,
we plan to implement AmbieGen as a python framework

First Author et al.: Preprint submitted to Elsevier

Page 19 of 21

Short Title of the Article

with an API for generating virtual environments and make
it open source.

10. Acknowledgements

This work is partly funded by the Natural Sciences and
Engineering Research Council of Canada (NSERC) [Grant
No: RGPIN-2019-06956] .

References
[1] Abdessalem, R.B., Nejati, S., Briand, L.C., Stifter, T., 2018. Testing
vision-based control systems using learnable evolutionary algorithms,
in: 2018 IEEE/ACM 40th International Conference on Software En-
gineering (ICSE), IEEE. pp. 1016–1026.

[2] Aerts, A., Reniers, M., Mousavi, M.R., 2017. Model-based testing
of cyber-physical systems, in: Cyber-Physical Systems. Elsevier, pp.
287–304.

[3] Alur, R., 2015. Principles of cyber-physical systems. MIT press.
[4] Annpureddy, Y., Liu, C., Fainekos, G., Sankaranarayanan, S., 2011.
S-taliro: A tool for temporal logic falsiﬁcation for hybrid systems, in:
International Conference on Tools and Algorithms for the Construc-
tion and Analysis of Systems, Springer. pp. 254–257.

[5] Arcuri, A., Briand, L., 2014. A hitchhiker’s guide to statistical tests for
assessing randomized algorithms in software engineering. Software
Testing, Veriﬁcation and Reliability 24, 219–250.

[6] Arnold, J., Alexander, R., 2013. Testing autonomous robot control
software using procedural content generation, in: International Con-
ference on Computer Safety, Reliability, and Security, Springer. pp.
33–44.

[7] Arrieta, A., Wang, S., Markiegi, U., Sagardui, G., Etxeberria, L.,
2017. Search-based test case generation for cyber-physical systems,
in: 2017 IEEE Congress on Evolutionary Computation (CEC), IEEE.
pp. 688–697.

[8] BeamNG.tech, 2021. Beamng gmbh. URL: https://www.beamng.gmbh/

research.

[9] Ben Abdessalem, R., Nejati, S., Briand, L.C., Stifter, T., 2016. Testing
advanced driver assistance systems using multi-objective search and
neural networks, in: Proceedings of the 31st IEEE/ACM International
Conference on Automated Software Engineering, pp. 63–74.
[10] Beyer, H.G., Schwefel, H.P., 2002. Evolution strategies–a compre-

hensive introduction. Natural computing 1, 3–52.

[11] Blank, J., Deb, K., 2020. Pymoo: Multi-objective optimization in

python. IEEE Access 8, 89497–89509.

[12] Broy, M., Jonsson, B., Katoen, J.P., Leucker, M., Pretschner, A., 2005.
Model-based testing of reactive systems, in: Volume 3472 of Springer
LNCS, Springer.

[13] Castellano, E., Cetinkaya, A., Ho Thanh, C., Klivovits, S., Zhang,
X., Arcaini, P., 2021. Frenetic at the SBST 2021 tool competi-
tion. International Conference on Software Engineering, Workshops,
Madrid, Spain URL: https://github.com/ERATOMMSD/frenetic-sbst21/
blob/main/src/frenetic-sbst21-preprint.pdf.

[14] Chen, C., Seﬀ, A., Kornhauser, A., Xiao, J., 2015. Deepdriving:
Learning aﬀordance for direct perception in autonomous driving, in:
2015 IEEE International Conference on Computer Vision (ICCV), pp.
2722–2730. doi:10.1109/ICCV.2015.312.

[15] Coello, C.A.C., Lamont, G.B., Van Veldhuizen, D.A., et al., 2007.
Evolutionary algorithms for solving multi-objective problems. vol-
ume 5. Springer.

[16] Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C., 2009. Intro-

duction to algorithms. MIT press.

[17] David, A., Larsen, K.G., Legay, A., Mikučionis, M., Poulsen, D.B.,
2015. Uppaal smc tutorial. International Journal on Software Tools
for Technology Transfer 17, 397–415.

[18] De Jong, E.D., Watson, R.A., Pollack, J.B., 2001. Reducing bloat and
promoting diversity using multi-objective methods, in: Proceedings
of the 3rd Annual Conference on Genetic and Evolutionary Compu-
tation, pp. 11–18.

[19] Donzé, A., 2010. Breach, a toolbox for veriﬁcation and parameter
synthesis of hybrid systems, in: International Conference on Com-
puter Aided Veriﬁcation, Springer. pp. 167–170.

[20] Gambi, A., Mueller, M., Fraser, G., 2019. Automatically testing
self-driving cars with search-based procedural content generation, in:
Proceedings of the 28th ACM SIGSOFT International Symposium on
Software Testing and Analysis, pp. 318–328.

[21] Handa, A., Newcombe, R.A., Angeli, A., Davison, A.J., 2012. Real-
time camera tracking: When is high frame-rate best?, in: European
Conference on Computer Vision, Springer. pp. 222–235.

[22] Hoﬀmann, G.M., Tomlin, C.J., Montemerlo, M., Thrun, S., 2007.
Autonomous automobile trajectory tracking for oﬀ-road driving: Con-
troller design, experimental validation and racing, in: 2007 American
control conference, IEEE. pp. 2296–2301.

[23] Humeniuk, D., Antoniol, G., Khomh, F., . Swat tool at the SBST 2021
tool competition. International Conference on Software Engineering,
Workshops, Madrid, Spain, 2021. URL: https://sbst21.github.io/
program/papers/SWAT_tool_at_SBST.pdf.

[24] Humeniuk, D., Khomh, F., Antoniol, G., 2021. A search-based frame-
work for automatic generation of testing environments for cyber-
physical systems. URL: https://github.com/dgumenyuk/Environment_
generation.git.

[25] Jones, E., Oliphant, T., Peterson, P., et al., 2001–. SciPy: Open source
scientiﬁc tools for Python. URL: https://docs.scipy.org/doc/scipy/
reference/generated/scipy.optimize.curve_fit.html.

[26] Klück, F., Klampﬂ, L., Wotawa, F., 2021. Automatic generation of
challenging road networks for alks testing based on bezier curves and
search. arXiv preprint arXiv:2103.01288 .

[27] Kranz, M., Rusu, R.B., Maldonado, A., Beetz, M., Schmidt, A., 2006.
A player/stage system for context-aware intelligent environments.
Proceedings of UbiSys 6, 17–21.

[28] Laumond, J.P., Sekhavat, S., Lamiraux, F., 1998. Guidelines in
nonholonomic motion planning for mobile robots, in: Robot motion
planning and control. Springer, pp. 1–53.

[29] Ljung, L., Glad, T., 1994. Modeling of dynamic systems. BOOK,

Prentice-Hall.

[30] Menghi, C., Nejati, S., Briand, L., Parache, Y.I., 2020.
testing of compute-intensive cyber-
Approximation-reﬁnement
physical models: An approach based on system identiﬁcation,
in: 2020 IEEE/ACM 42nd International Conference on Software
Engineering (ICSE), IEEE. pp. 372–384.

[31] Minguez, J., Montano, L., 2004. Nearness diagram (nd) navigation:
collision avoidance in troublesome scenarios. IEEE Transactions on
Robotics and Automation 20, 45–59. doi:10.1109/TRA.2003.820849.

[32] Mouret, J.B., 2011. Novelty-based multiobjectivization, in: New

horizons in evolutionary robotics. Springer, pp. 139–154.

[33] Nguyen, C.D., Miles, S., Perini, A., Tonella, P., Harman, M., Luck,
M., 2012. Evolutionary testing of autonomous software agents.
Autonomous Agents and Multi-Agent Systems 25, 260–283.

[34] Panichella, S., Gambi, A., Zampetti, F., Riccio, V., 2021. SBST
tool competition 2021., in: In International Conference on Software
Engineering, Workshops, Madrid, Spain, ACM.

[35] Riccio, V., Tonella, P., 2020a. Model-based exploration of the frontier
of behaviours for deep learning system testing, in: Proceedings of the
28th ACM Joint Meeting on European Software Engineering Confer-
ence and Symposium on the Foundations of Software Engineering,
pp. 876–888.

[36] Riccio, V., Tonella, P., 2020b. Model-based exploration of the frontier
of behaviours for deep learning system testing, in: Proceedings of the
ACM Joint European Software Engineering Conference and Sympo-
sium on the Foundations of Software Engineering, Association for
Computing Machinery. p. 13 pages. doi:10.1145/3368089.3409730.
[37] Romijn, R., Özkan, L., Weiland, S., Ludlage, J., Marquardt, W., 2008.
A grey-box modeling approach for the reduction of nonlinear systems.
Journal of Process Control 18, 906–914.

[38] Sakai, A., Ingram, D., Dinius, J., Chawla, K., Raﬃn, A., Paques,
Pythonrobotics: a python code collection of robotics

A., 2018.
algorithms. arXiv:arXiv:1808.10703.

First Author et al.: Preprint submitted to Elsevier

Page 20 of 21

Short Title of the Article

[39] Sotiropoulos, T., Guiochet, G., Ingrand, I., Waeselynck, W., 2016.
Virtual worlds for testing robot navigation: a study on the diﬃculty
level, in: 2016 12th European Dependable Computing Conference
(EDCC), IEEE. pp. 153–160.

[40] Sturtevant, N., 2012. Benchmarks for grid-based pathﬁnding. Trans-
actions on Computational Intelligence and AI in Games 4, 144 – 148.
URL: http://web.cs.du.edu/~sturtevant/papers/benchmarks.pdf.
[41] Varadharajan, V.S., St-Onge, D., Adams, B., Beltrame, G., 2020.
Swarm relays: Distributed self-healing ground-and-air connectivity
chains. IEEE Robotics and Automation Letters 5, 5347–5354.

[42] Winterton, R., 1999. Newton’s law of cooling. Contemporary Physics

40, 205–212.

[43] Yin, R.K., 2002. Applications of Case Study Research Second
Edition (Applied Social Research Methods Series Volume 34). {Sage
Publications, Inc}.

[44] Zid, C., Humeniuk, D., Khomh, F., Antoniol, G., 2020. Double cycle
hybrid testing of hybrid distributed iot system, in: Proceedings of the
IEEE/ACM 42nd International Conference on Software Engineering
Workshops, Association for Computing Machinery, New York, NY,
USA. p. 529–532. URL: https://doi.org/10.1145/3387940.3392218,
doi:10.1145/3387940.3392218.

First Author et al.: Preprint submitted to Elsevier

Page 21 of 21

