2
2
0
2

r
a

M
3
2

]
E
N
.
s
c
[

1
v
8
3
1
2
1
.
3
0
2
2
:
v
i
X
r
a

A Search-Based Framework for Automatic Generation of Testing
Environments for Cyber-Physical Systems

Dmytro Humeniukâˆ—, Foutse Khomh and Giuliano Antoniol

Polytechnique MontrÃ©al, 2500 Chemin de Polytechnique, QC H3T 1J4, MontrÃ©al, Canada

A R T I C L E I N F O

A B S T R A C T

Keywords:
cyber-physical systems,
test scenario generation,
genetic algorithms,
virtual environments

Background. Many modern cyber-physical systems incorporate computer vision technologies,
complex sensors and advanced control software, allowing them to interact with the environment
autonomously. Examples include drone swarms, self-driving vehicles, autonomous robots, etc. Testing
such systems poses numerous challenges: not only should the system inputs be varied, but also the
surrounding environment should be accounted for. A number of tools have been developed to test
the system model for the possible inputs falsifying its requirements. However, they are not directly
applicable to autonomous cyber-physical systems, as the inputs to their models are generated while
operating in a virtual environment.
Aims. In this paper, we aim to design a search-based framework, named AmbieGen, for generating
diverse fault-revealing test scenarios for autonomous cyber-physical systems. The scenarios represent
an environment in which an autonomous agent operates. The framework should be applicable to
generating diï¬€erent types of environments.
Method. To generate the test scenarios, we leverage the NSGA-II algorithm with two objectives. The
ï¬rst objective evaluates the deviation of the observed systemâ€™s behaviour from its expected behaviour.
The second objective is the test case diversity, calculated as a Jaccard distance with a reference test
case. To guide the ï¬rst objective we are using a simpliï¬ed system model rather than the full model.
The full model is used to run the system in the simulation environment and can take substantial time
to execute (several minutes for one scenario). The simpliï¬ed system model is derived from the full
model and can be used to get an approximation of the results obtained from the full model without
running the simulation.
Results. We evaluate AmbieGen on three scenario generation case studies, namely a smart-thermostat,
a robot obstacle avoidance system, and a vehicle lane-keeping assist system. For all the case studies,
our approach outperforms the available baselines in fault revealing and several other metrics such as
the diversity of the revealed faults and the proportion of valid test scenarios.
Conclusions. AmbieGen could ï¬nd scenarios, revealing failures for all the three autonomous agents
considered in our case studies. We compared three conï¬gurations of AmbieGen: based on a single
objective genetic algorithm, multi-objective, and random search. Both single and multi objective
conï¬gurations outperform the random search. Multi objective conï¬guration can ï¬nd the individuals of
the same quality as the single objective, producing more unique test scenarios in the same time budget.
Our framework can be used to generate virtual environments of diï¬€erent types and complexity and
reveal the systemâ€™s faults early in the design stage.

1. Introduction

One of the rapidly developing families of cyber-physical
systems (CPS) are autonomous and vision based CPS. Ex-
amples include drone swarms, self driving cars, cave or
underwater exploring robots. Typically, in the CPS develop-
ment process the systems are validated and veriï¬ed accord-
ing to the V-model approach [2]. Prior to running the tests
on a real system, the V-model includes model-in-the-loop
and software-in-the-loop testing stages. In these stages the
simulations of the system are run in a virtual environment.
The goal is to model the real environment eï¬€ect on CPS(s)
and generate test scenarios violating some critical proper-
ties of CPS. However, during these simulations, engineers
often lack tool support for generating the scenarios [9]. For
particular applications there exist content generation tech-
niques, like a Kruskalâ€™s algorithm for maze generation [16]
or pre-conï¬gured scenarios, like the virtual worlds used in
computer games [40]. However, they do not always provide

âˆ—Corresponding author, e-mail: dmytro.humeniuk@polymtl.ca
ORCID(s):

the needed scenario complexity and oftentimes the scenarios
have to be designed manually. Consider an autonomous
robotic system, that should navigate to a goal destination in
an environment with obstacles. The robots interact with the
physical world via sensors and actuators in a feedback loop,
avoiding the obstacles and searching the goal destination.
Test scenario for such system includes virtual environment
with obstacles , including moving and unexpected obstacles,
changing terrain structure and environmental conditions.
Manually designing all the possible scenarios in the virtual
environment is a tedious task.

In this paper, we propose a search based approach,
further referred to as â€œAmbieGenâ€œ to automatically generate
test scenarios for cyber-physical systems. In the literature,
typically one objective, accounting for the scenario fault
revealing power [20], or two objectives, accounting for fault
revealing power and diversity [35], are used. To evaluate the
contribution of adding the ï¬rst and the second objectives we
consider three conï¬gurations of AmbieGen: based on ran-
dom search, single-objective genetic algorithm (AmbieGen

First Author et al.: Preprint submitted to Elsevier

Page 1 of 21

 
 
 
 
 
 
Short Title of the Article

SO) and multi-objective genetic algorithm NSGA-II (Amn-
bieGen MO). Preliminary results conï¬rm that using the two
objectives, maximizing both: scenario fault revealing power
and diversity, allows to ï¬nd more unique fault revealing
scenarios given the same time budget. To calculate the
ï¬rst objective we are using the simpliï¬ed system model,
derived from the full model of the system, as suggested
by Menghi et al. [30].The full model is used to execute
the scenarios in the simulation environment and is usually
computationally expensive. The simpliï¬ed model allows to
reduce the computational and time cost needed to produce
the test scenarios as it does not require the simulator to run
and provides the approximated outputs of the full model in
a reduced amount of time.

We evaluate our approach on three test generation case
studies. In the ï¬rst case study, a smart-thermostat agent
should follow the schedule with the expected precision. The
goal of the testing approach is to generate the temperature
schedule and a combination of environmental conditions
violating the requirement. In the second case study, an
autonomous robot should navigate to a goal location in an
indoor environment with obstacles, without bumping into
them. A test scenario should ï¬nd such an indoor environ-
ment that makes the robot violate the requirements. In the
third, an autonomous vehicle, with a lane-keeping assist
system (LKAS), should follow a road lane of the given
trajectory, without going out of its bounds. The testing
approach should generate a virtual road that forces the car
to go out of the road. AmbieGen could reveal on average 9
failures in two hours for the autonomous robot model and 14
failures in two hours for the self-driving car model executed
in the simulators . Given the same evaluation budget, in
all the case studies the multi-objective and single-objective
conï¬gurations of AmbieGen produced ï¬tter solutions with
a large eï¬€ect size, comparing to the random search. Multi-
objective conï¬guration allowed to produce more diverse sce-
narios with medium to large eï¬€ect size comparing to single-
objective, while ï¬nding solutions of the same or similar
quality.

This paper makes the following contributions:

1. We design a search-based framework for generat-
ing customized environments for testing autonomous
CPS.

2. We propose a novel technique for generating the vir-

tual roads and robot navigation maps.

3. Finally, we provide the code for replication of all of

our experiments [24].

Researchers and practitioners can leverage AmbieGen to
automatically generate scenarios for autonomous CPS that
will be further passed to the simulators to run tests on the
full CPS models.

The remainder of this paper is organized as follows.
Section 2 discusses the related works in the domain of CPS
testing. In Section 3 we formalize the problem of scenario
generation and provide the description of AmbieGen ap-
proach in Section 4. Section 5 describes the test generation

case studies used to evaluate our approach. In Section 6 we
formulate the research questions and our evaluation method-
ology. The same section reports our results and answers to
research questions. Section 7 discusses the results and the
main challenges of this study. In Section 8 we explain the
threats to the validity of our results. Section 9 concludes the
paper and discusses some avenues for future works.

2. Related literature

Typically, the cyber-physical systems are developed us-
ing a model-based design approach [2]: after establishing
the requirements of the system, model-in-the-loop testing
is performed. In this step, models of the hardware part
and the controller are created and tested in the simulation
environment. One of the limitations of simulation platforms
is that they do not provide clear guidance to engineers as
to which test scenarios should be selected for simulation.
Therefore, a number of approaches have been developed to
generate the testing scenarios.

General approaches for CPS testing. In the classical
approach, the exhaustive exploration of the state-space of the
model is performed [12]. It uses the abstract model, created
strictly according to the system requirements, to generate
the test cases for the model of the system under test (SUT).
If the outputs of the SUT model and abstract model are
diï¬€erent, the fault in the SUT is revealed. As the system
models get more complex, the search space becomes in-
feasible. More recently, falsiï¬cation based approaches have
been proposed, verifying whether the model meets speciï¬c
requirements speciï¬ed in a temporal logic notation such as
timed computation tree logic (TCTL), linear temporal logic
(LTL), metric temporal logic (MTL) or signal temporal logic
(STL) . The UPAAl SMC tool performs the statistical model
checking (SMC) of of a given model, with the requirements
speciï¬ed using TCTL notation [17]. The core idea of SMC
is to monitor some simulations of the system, and then
compute the probability along with conï¬dence intervals that
a speciï¬c requirement holds for the SUT. A number of tools
were developed that instead of calculating the probability
that a system satisï¬es the property with a certain conï¬dence,
compute the worst expected system behaviour as a quanti-
tative value, called robustness. Examples of such tools are
S-Taliro [4], Breach [19] and ARIsTEO [30]. Diï¬€erently
from others, ARIsTEO propose to apply falsiï¬cation testing
to the surrogate, i.e., approximated model of the SUT, that
closely mimics its behaviour but is signiï¬cantly cheaper to
execute. Arrieta et al., proposed a search based approach,
that does not use the system model [7]. They deï¬ned three
cost eï¬€ectiveness measures to guide search towards gener-
ating optimal test cases: requirements coverage, test case
similarity (eï¬€ectiveness) and test execution time (cost).

In the described works, authors consider falsiï¬cation
of the model of the system that takes as an input a set of
signals ğ‘ˆ = {ğ‘¢1, ğ‘¢2, . . . , ğ‘¢ğ‘š} and produces a set of signals
ğ‘Œ = {ğ‘¦1, ğ‘¦2, . . . , ğ‘¦ğ‘›} as the output. In our work we focus
on testing autonomous systems, for which the input signals

First Author et al.: Preprint submitted to Elsevier

Page 2 of 21

Short Title of the Article

are rather complex and might represent sensors and camera
data, coming from diï¬€erent sources. Imagine a self-driving
vehicle, using the lidar sensors and RGB camera to perceive
the environment. Directly generating a valid combination
of falsifying input signals (represented by lidar readings
and RGB camera readings) would be rather challenging.
Therefore, we focus on generating test cases that specify a
virtual environment for an autonomous system, rather than
the input signals. The input signals are generated in the vir-
tual environment during the simulation, based on the actions
taken by the autonomous agent. A number of approaches
have been proposed for generating virtual environments for
testing the autonomous driving and robotic systems.

Vehicular driving system testing. Abdessalem et al.
in [9] use a multi-objective search evolutionary algorithm
NSGA-2 to obtain test scenarios for Automated Emergency
Braking (AEB) system. They represent the test case as a
tuple with sets of static parameters, such as precipitation,
fogginess, roadshape and visibility range, as well as dynamic
parameters, such as initial vehicle speed, initial pedestrians
speed and location. The disadvantage of such encoding
is the limitation in describing the static parameters. Such
encoding does not allow to specify for example a complex
road topology, with a number of turns and intersections.
Also, we cannot account for the cases, where the static
parameters need to be changed during the test case. For
example, when the road material changes along the route,
i.e., asphalt surface changes to pavement. In order to gen-
erate challenging test cases, they use ï¬tness functions min-
imizing the distance to the pedestrian and time to collision,
calculated while executing the test case. To mitigate the
computation cost of executing physics-based simulations,
the simpliï¬ed models of ADAS trained on neural networks
(NN) are used. Evidently, the NN has to be retrained each
time model parameters are changed.

AsFault tool was proposed to generate the road conï¬g-
uration to test car Lane Keeping Assist System (LKAS) by
Gambi et al., [20]. This system should allow an autonomous
car to always drive inside its lane. The test cases in this work
correspond to a road topology that a car needs to follow.
AsFault represents roads as set of polylines, i.e., discrete
sequences of points. One polyline corresponds to one road
segment. Roads are generated procedurally by stitching one
road segment to the next one. To evolve the roads, authors
use a customized mutation operator, that randomly replaces
a road segment and crossover operator that splits two roads at
a random point and recombines them, or recombines random
subsets of two roads. With such encoding combining the
road polylines to produce a valid road may be challenging.
Authors mention that if the search operator produces invalid
road topology, AsFault retries the application of the same
search operator with a probability of giving up which in-
creases per failed attempt. Therefore, one disadvantage of
such encoding is the diï¬ƒculty in applying crossover and mu-
tation operators. Another disadvantage is the limitations in
encoding some important details of the test case such as the
other vehicles, obstacles or pedestrian locations. Authors do

not mention the possibility to encode such information with
AsFault. Finally, the selected ï¬tness function maximizes the
distance of ego-car from the center of the road lane. The real
simulation model is used for calculating the ï¬tness function
value, which increases the computation cost. To improve the
eï¬ƒciency of the tool, authors ï¬lter out similar test cases by
calculating Jaccard index between them. However, they do
not maximize the diversity of the test cases explicitly.

Riccio and Tonella [36] propose DeepJanus, a tool
to explore the behavioural space of a deep learning (DL)
system to ï¬nd pairs of inputs at its frontier: one input on
which the DL system behaves as expected, and another
similar input on which it misbehaves. In this work they
consider two case studies: image classiï¬cation (from MNIST
database) and steering angle prediction for a vehicle LKAS
system. We will further focus on the later. The scenario
for the vehicle is represented as a road topology and it is
encoded as a list of coordinates of the control points. These
control points are further interpolated with Catmull-Rom
cubic splines to produce a road topology. This encoding is
limited in terms of increasing the complexity of the test case,
such as specifying the location of other vehicles, obstacles or
intersections. The tool is leveraging a two objective NSGA-
II algorithm to generate eï¬€ective test cases. Each individual
of the algorithm is encoded as a pair of road topologies.
The ï¬rst objective, ğ‘“1
, aims to promote diversity between an
individual and existing individuals as well as minimize the
diï¬€erence between the pair of road topologies constituting
the individual. Authors deï¬ne a problem speciï¬c distance
metric used to evaluate the ğ‘“1
. For the LKAS case study it
is calculated as the Levenshtein distance between the roads.
For image classiï¬cation, it is calculated as an Euclidean dis-
tance between pixel matrices. The second ï¬tness function,
, aims to minimize the distance of an individual to the
ğ‘“2
behavioural frontier. In the case of the LKAS system case
study itâ€™s calculated based on the maximum deviation from
the lane center. If this deviation is higher than a certain
threshold for one of the roads of the individual, the ğ‘“2
is
assigned a -1 value, otherwise itâ€™s equal to the absolute
value of the maximal deviation. We can see that the ï¬tness
functions are designed to evaluate a pair of road topologies,
rather than a single road topology.

Autonomous robot testing approaches. Arnold et al.
[6] designed a tool to produce navigation maps to test
autonomous robot control algorithms. They use the Per-
lin noise to randomly generate the maps and then select
the ones, that correspond to a deï¬ned set of unwanted
behaviours, such as stalling or colliding with a wall. No
optimization algorithms are used to increase the number of
fault-revealing scenarios.

Sotiropoulos et al. [39] generate navigation maps of
diï¬€erent diï¬ƒculty level by changing the number and position
of obstacles on the map. As in the previous work, the
procedural content generation with ï¬xed parameters is used
without optimization.

Nguyen et al. [33] propose a genetic algorithm based
approach to design test scenarios for a cleaner robot. The

First Author et al.: Preprint submitted to Elsevier

Page 3 of 21

Short Title of the Article

robot goal is to collect all the rubbish given a speciï¬c amount
of time, without bumping into obstacles. The scenario rep-
resents an area with obstacles and objects to collect. It is
encoded as a table with R x R cells. A cell containing an
object is denoted by 1, while a contentâ€“free cell is denoted
by 0. The limitation of such encoding is that it is problem
speciï¬c, i.e., it is suitable for encoding a map for the robot,
however it is rather diï¬ƒcult to represent a road topology
using such encoding. The ï¬tness function is deï¬ned as
closest distance to obstacles observed by the robot.

Considering the existing approaches for environment
generation, we can see that their implementation, including
the evolutionary algorithm representation, has such limita-
tions as problem speciï¬c or hardly customizable individual
representation, diï¬ƒculties in search operator implementa-
tion. In our work we propose a test generation approach,
AmbieGen, with encoding that can be applied to test gen-
eration tasks for diï¬€erent autonomous agents, can provide
a customizable scenario complexity level and allows to
easily implement the search operators. Furthermore, in our
approach we are using two objectives, accounting for both
fault revealing power ğ¹1
.
and diversity of the test cases ğ¹2
Implementation of ğ¹1
is problem speciï¬c and is deï¬ned as
the diï¬€erence between the expected and observed behaviour
of the the agent. Contrary to existing works, we are explicitly
promoting the diversity of the test cases as the second objec-
tive ğ¹2
of the genetic algorithm using a universal distance
metric, explained in Subsection 3.2. In our experiments we
show that adding the ğ¹2
allows to increase the diversity of
the test cases in the resulting test suite, without reducing
their fault revealing power. Overall, we surmise that our
framework can be leveraged for implementing search based
algorithms for test case generation for autonomous systems.

3. Problem formulation

A cyber-physical system is a reactive system, consisting
of a computing device (or a collection of them) interacting
with the environment via inputs and outputs [3].
In a
simulator, the autonomous CPS agent observes the virtual
environment at discrete timestamps ğ‘¡ğ‘–
using its local sen-
sors, e.g., temperature, lidar sensors or RGBD-cameras, and
measures its internal state ğ‘ ğ‘¡
it receives
a new observation ğ‘œğ‘¡ âˆˆ ğ‘‚ and selects an action ğ‘ğ‘¡ âˆˆ ğ´
according to its control policy ğœ‹(ğ‘ ğ‘¡, ğ‘œğ‘¡
). Here ğ´ is a set of
possible actions and ğ‘‚ is a set of all possible observations
(the observation space), deï¬ned by the environment where
the agent operates. Each test case represents an environment
for the agent as well as the mission it needs to accomplish
in it. We can formulate the problem as ï¬nding a test case,
forcing the agent to take such actions ğ‘ğ‘¡
that lead to violation
of the established requirements and failure of the mission.

. At each timestep ğ‘¡ğ‘–

For example, to test a self-driving vehicle we should
consider such parameters as the road type and size, the
location of other vehicles or pedestrians, the driving weather
conditions, etc. Evidently, one of the most important require-
ments would be the collision avoidance. Generating such

Table 1
Scenario ğ‘‡ ğ¶ representation

ğ¸2

ğ¸1

ğ¸3
ğ´1 ğ´1ğ‘’1 ğ´1ğ‘’2 ğ´1ğ‘’3
ğ´2 ğ´2ğ‘’1 ğ´2ğ‘’2 ğ´2ğ‘’3
...
...
ğ´ğ‘›ğ‘’3
ğ´ğ‘›

...
ğ´ğ‘›ğ‘’1

...
ğ´ğ‘›ğ‘’2

ğ¸ğ‘š
...
... ğ´1ğ‘’ğ‘š
... ğ´2ğ‘’ğ‘š
...
...
... ğ´ğ‘›ğ‘’ğ‘š

scenarios manually is an extremely time consuming task: the
engineers would need to list the precise positions and head-
ing directions of the moving objects, specify diï¬€erent types
of environmental conditions, etc. Therefore it is preferable
to generate such scenarios automatically. To control their
quality, optimization techniques should be used.

3.1. Scenario representation

In this subsection we formalize the deï¬nition of the
test scenarios. As it was mentioned earlier, one test case
represents an environment in which the agent operates as
well as the mission it needs to accomplish. We encode the
test case as a set of parameters, needed to generate the
deï¬ned environment in the simulator.

First, we propose to divide the test case into at most
ğ‘š parts. Each part can represent some aspect of the mission
to accomplish or a part of the virtual environment in which
the agent operates. We call these parts the environmental
elements ğ¸ğ‘–
. We describe each environmental element with
ğ‘› parameters, which we further refer to as attributes.

As an example, letâ€™s consider a car lane keeping assist
system (LKAS). Itâ€™s main goal is to keep the vehicle within
the road lane. One of the possible test cases to test this system
can be a road topology, that the vehicle needs to follow. To
design the test case, we suggest representing the road topol-
ogy as a combination of road segments of diï¬€erent length
and curvature. Here, each road segment would correspond
to one environmental element and itâ€™s parameters such as
length and curvature - the attributes of the environmental
element.

Each individual (test case TC) is represented as a ğ‘›ğ‘¥ğ‘š
matrix where the cell (ğ‘–, ğ‘—) contains values deï¬ning the TC.
, and is composed of
In a nutshell, a TC has ğ‘› attributes ğ´ğ‘–
(in
at most ğ‘š elements. More precisely, cell (ğ‘–, ğ‘—), alias ğ¸ğ‘—
. Without
), is the value sampled from the attribute ğ´ğ‘–
line ğ´ğ‘–
loss of generality, an attribute ğ´ğ‘–
, takes value into a set of
possible realizations {ğ‘0, ğ‘1, ..., ğ‘ğ‘›} or is deï¬ned as a closed
interval [ğ´ğ‘–ğ‘šğ‘–ğ‘›, ğ´ğ‘–ğ‘šğ‘ğ‘¥]. We allow for the cells to be empty, if
needed.

Turning to the LKAS example, we can describe each
road segment, i.e., environmental element, with such pa-
rameters as the length, the turning angle, the slope, the
road material, etc. Each road segment will have a value
for each of these parameters. By providing combinations of
road segments with diï¬€erent parameter values, we generate
various road topologies.

First Author et al.: Preprint submitted to Elsevier

Page 4 of 21

Short Title of the Article

Finally, the test scenarios can have restrictions ğ‘…, which
limit the scenario length ğ‘€ or particular combinations of at-
tributes. In the LKAS example, for instance, we can limit the
total road length or a certain combination of road segments,
that create too sharp turns, etc.

We provide examples of application of this represen-
tation to generate diï¬€erent test scenarios for autonomous
agents in the Section 5.

Having obtained the matrix with attributes, i.e., the test
scenario speciï¬cation, we can generate the corresponding
virtual environment in the simulator. According to the se-
lected timestamp in the simulator settings, the agent will
receive the inputs in the form of observations at each times-
tamp. Observations can be represented by a temperature or
lidar sensor readings, images from the RGB camera. After
receiving each observation, the agent performs an action.
Depending on the actions the agent takes it can fail or pass
the test case.

In the LKAS example, suppose the car uses its RGB
camera images to deï¬ne its steering wheel angle. The stan-
dard camera frame rate to provide stable image for such
applications is more than 30 Hz [21]. Letâ€™s consider 30 Hz
for this example. This means the car receives an input in the
form of the RGB image every 33,3 msec. For each received
input, it provides a value of the steering angle to use. This
value can be obtained, for instance, by querying a neural
network based model that classiï¬es steering angle values
based on the image of the road.

Initial encoding of the scenario is the matrix ğ‘‡ ğ¶, con-
taining a high-level description of the environment. With
such representation itâ€™s easy to implement the evolutionary
search operators by simply swapping the matrix columns be-
tween each other and randomly changing the cell values. By
swapping the columns, we imply reassigning the attributes
from one environmental element to another. To evaluate its
ï¬tness it ï¬rst needs to be converted to the environment con-
ï¬guration for the approximated model ("TC to environment"
module). For example, the scenarios for an autonomous
robot should be converted to a list of obstacle coordinates
in a map. Then an approximated model is used to execute
the scenarios and the ï¬tness function is calculated based on
the execution results ("Fitness function" module). Approxi-
mated model can be created either from real data or from the
full model data. Another possibility is to use a simpliï¬ed
system model, based on already implemented robotics algo-
rithms, such as those available at python robotics project
[38]. Overall, to customize AmbieGen, the developer needs
to provide a list of attributes and their allowable ranges,
an implementation of the "TC to environment" and "Fit-
ness function" modules. The AmbieGen will integrate the
modules and implement the initial population generation,
crossover and mutation operators. Moreover, itâ€™s simple to
control the level of complexity needed for the environment.
By adding more attributes, the complexity can be increased.
The limitation is the possibility of the simulator to interpret
more complex environment conï¬gurations, such as the ter-
rain type, the weather conditions, etc.

3.2. Search objectives deï¬nition

The main goal is to ï¬nd scenarios producing system
faults. At the same time, the scenarios should be diverse,
uncovering diï¬€erent types of faults. From our experience,
using only one objective results in producing many similar
test cases in the last generation. Therefore we suggest adopt-
ing a multi-objective algorithm, where one of the objectives
is accounting for the diversity of the test cases. The idea of
adding a second objective for diversity is not new and was
addressed in the novelty search works, such as [32], and test
scenario generation tools [35].

To estimate the ï¬rst objective ğ¹1

, the fault revealing
power ğœ‘ of the test case, we compute the diï¬€erence between
the expected ğµ(ğ‘‡ ğ¶) and observed system behaviour ğµğ‘œ(ğ‘‡ ğ¶)
after executing the test case:

ğ¹1 = ğœ‘(ğ‘‡ ğ¶) = ğ›¿(ğµ(ğ‘‡ ğ¶), ğµğ‘œ(ğ‘‡ ğ¶)),

(1)

where ğ›¿ is a developer deï¬ned function for computing the
deviation between the expected and observed system be-
haviour and ğ‘‡ ğ¶ is the test scenario speciï¬cation. The ex-
pected behaviour ğµ(ğ‘‡ ğ¶) is typically deï¬ned in the system
requirements or formulated by the developers e.g., "the car
should not deviate from the lane center for more than 1
meter". The observed behaviour corresponds to the model
under test (MUT) outputs after scenario execution. However,
the models of autonomous systems are rather complex and
take long time to execute in the simulators, i.e., up to sev-
eral minutes for one scenario. Moreover, executing the full
models in the simulation environments requires additional
system resources such as a GPU and high amount of RAM.
Therefore we suggest estimating the observed behaviour
ğµğ‘œ(ğ‘‡ ğ¶) using the approximated (surrogate) system models.
Such models can be built based on the grey-box modelling
approach [37], where model structure is chosen from system
knowledge and parameters are selected to match sampled
data. When little knowledge is available about the model,
system identiï¬cation techniques [29] can be used, where the
modelled system is considered as a black box.

To estimate the second ï¬tness function ğ¹2

the vari-
ability ğœ of the test case, we compute the Jaccard distance
between it and a reference test case:

,

ğ¹2 = ğœ(ğ‘‡ ğ¶, ğ‘‡ ğ¶ğ‘Ÿğ‘’ğ‘“ ) = 1 âˆ’

ğ‘‡ ğ¶ âˆ© ğ‘‡ ğ¶ğ‘Ÿğ‘’ğ‘“
ğ‘‡ ğ¶ âˆª ğ‘‡ ğ¶ğ‘Ÿğ‘’ğ‘“

,

(2)

where ğ‘‡ ğ¶ âˆª ğ‘‡ ğ¶ğ‘Ÿğ‘’ğ‘“
elements in both test cases and ğ‘‡ ğ¶ âˆ© ğ‘‡ ğ¶ğ‘Ÿğ‘’ğ‘“
of inputs with similar or same attributes.

to the total number of environmental
to the number

Finally, we deï¬ne our search objectives:

ğ‘šğ‘ğ‘¥ğ‘–ğ‘šğ‘–ğ‘§ğ‘’ âˆ¶ ğœ‘(ğ‘‡ ğ¶),
ğ‘šğ‘ğ‘¥ğ‘–ğ‘šğ‘–ğ‘§ğ‘’ âˆ¶ ğœ(ğ‘‡ ğ¶, ğ‘‡ ğ¶ğ‘Ÿğ‘’ğ‘“ ),
ğ‘ ğ‘¢ğ‘ğ‘—ğ‘’ğ‘ğ‘¡ ğ‘¡ğ‘œ âˆ¶ ğ¶1(ğ‘‡ ğ¶) = ğœ‘(ğ‘‡ ğ¶) âˆ’ ğ›¼ > 0,

Where ğ¶1
is a constraint for the minimum value of the ï¬rst
objective, ğ›¼ is the developer deï¬ned threshold to identify
the test cases as having a risk of producing a failure. This

First Author et al.: Preprint submitted to Elsevier

Page 5 of 21

Short Title of the Article

constraint is introduced to avoid producing test cases with
low fault revealing power.

In our study we consider two conï¬gurations of our
approach: AmbieGen MO, described above and AmbieGen
SO based on a single objective genetic algorithm (GA) with
ğ¹1

as a ï¬tness function.

4. Proposed approach description

To perform the search we are using evolutionary search
algorithms NSGA-II and GA [15], which have proven to be
eï¬€ective at similar tasks [1, 7]. Below, we present the GA
and NSGA-II conï¬gurations used in AmbieGen.

We implemented the AmbieGen MO and AmbieGen
SO using a python Pymoo framework [11]. The framework
provides the possibility to deï¬ne custom solution represen-
tations, crossover and mutation operators.

Solution representation. Each individual in the popula-
tion corresponds to a test case. Individuals can have a vari-
able number of genes, i.e., environment elements depending
on the application. Internally, we represent the individual,
i.e., the test case, shown in table 1, as a dictionary, as shown
below:

{ " E1 " : { "A0 : " A0 ,
"An" : An } , " E i " :

"A1" : A1 ,
{ . . . } } ,

. . . ,

where ğ¸ğ‘–, corresponds to the element of the environment
that is described and ğ´ğ‘› to the value of the attribute from
the deï¬ned attribute set ğ´.

of each element ğ¸ğ‘–

Initial test case generation. The search begins by gen-
erating the initial test cases. One of the options is to
, ...,
assign arbitrary values to environmental attributes ğ´0
from their allowable value ranges
ğ´ğ‘›
[ğ´ğ‘–ğ‘šğ‘–ğ‘›, ğ´ğ‘–ğ‘šğ‘ğ‘¥] or realisation sets {ğ‘0, ğ‘1, ..., ğ‘ğ‘›}. When some
distribution of attribute values is known to produce better
test cases, from both semantical and fault-revealing point
of view, we suggest using the Markov chain to assign the
values of certain attributes . For example, when generating
the road segments, the road consisting of only the straight
segments is very unlikely to produce faults. Such cases can
be avoided by assigning values with the Markov chain. To
build a Markov chain we need to deï¬ne the state space
as well as the probability table of switching between these
states. As the state space we can use the possible values
of one of the attributes. In the case of the LKAS it can be
the three road segment types: going straight, turning left
and turning right. The state switching probability table can
be inferred from the domain knowledge. In the case of the
LKAS system, we want to lower the probability of getting
a sequence of only straight road segments. An example of a
Markov chain used to generate the initial test cases for the
LKAS is shown in Fig.1.

Fitness evaluation. We use two ï¬tness functions to
, corresponding to the function
evaluate each individual: ğ¹1
in (1) and ğ¹2
is calculated after
executing the test case with a surrogate model ğ‘€ of the
system. This function is problem speciï¬c and should be

corresponding to (2). ğ¹1

Figure 1: Markov chain used to generate the intiial test cases
for the LKAS case study

proportional to the unwanted behaviour of the system. For
example, for evaluation of a self-driving car test case we can
compute the maximum deviation from the road lane center,
where bigger deviation is likely to produce more faults.

In our implementation we compute ğ¹2

as the Jaccard
distance between the individual and its parent, which acts
as a reference test scenario. The intuition is to promote
the modiï¬cations done to the test scenarios. However, a
diï¬€erent reference test scenario can be used, such as the
closest individual from the Pareto optimal solutions.

As the Pymoo framework minimizes the ï¬tness func-
actual

tions, in our implementation we multiply ğ¹1
values by (-1).

and ğ¹2

Mating selection. To select the individuals for crossover
and mutation the binary tournament selection is used, which
is implemented by default in Pymoo. ğ‘ individuals are
selected, producing ğ‘ new individuals after crossover and
mutations.

is smaller than ğ‘š2

(parent 1) and ğ‘‡ ğ¶2
and ğ‘š2

Crossover operator. We are using a one point crossover
operator, which is one of the commonly used operators for
variable-length solution representation. This operator cre-
ates two new test cases by exchanging information between
(parent 2),
two existing test cases ğ‘‡ ğ¶1
with corresponding lengths of ğ‘š1
. Letâ€™s suppose that
. It is performed in two steps. First we
ğ‘š1
randomly select the crossover point ğ‘˜ with the index from 1
with the indices from
to ğ‘š1âˆ’1. Then the elements of the ğ‘‡ ğ¶1
ğ‘˜ to ğ‘š1
are
and elements of ğ‘‡ ğ¶2
swapped. An illustration of the crossover operation between
two individuals is shown in Fig. 2. Individual ğ‘‡ ğ¶1
length is
a size of 3. Both individuals
4 elements and individual ğ‘‡ ğ¶2
is a value of the
and ğ´2
have two types of attributes ğ´1
attribute ğ´ğ‘–
.
corresponding to the environmental element ğ¸ğ‘—
The crossover point is chosen to be 2 and is shown as a red
line.

with indices from ğ‘˜ to ğ‘š2

. ğ´ğ‘–ğ‘’ğ‘—

Mutation operators. We deï¬ne three mutation opera-

tors:

â€¢ exchange operator:

two randomly
selected environmental elements of a chromosome are
exchanged the positions;

the attributes of

â€¢ change of variable operator: an environmental ele-
in a chromosome is randomly selected, then

ment ğ¸ğ‘–

First Author et al.: Preprint submitted to Elsevier

Page 6 of 21

Short Title of the Article

operation. Testing the controllers in the simulators for dif-
ferent temperature schedules is necessary in order to ensure
their precision and reveal the possible limitations. In this
study, the test generation goal is to create scenarios account-
ing for the scheduled temperature as well as environmental
conditions.

5.1.1. System under test description

In our case study we consider a simple real-world wire-
less thermostat system. It consists of one room with a heater,
sensor, and controller and is part of a larger system, de-
scribed in more details in [44]. The room dimensions are
approximately 2.5 m Ã— 4 m and the height is about 2.6 m. The
heating element is a Steelpro 1.5 Kw electronic convector
2, which is controlled via a wireless Z-wave protocol based
switch. The temperature is measured by a Aeotec MultiSen-
sor 6 device 3, placed at about 2.2 m from the ï¬‚oor. The
controller is a Raspberry Pi 3B running Z-wave.me with
a RaZberry 4 4 daughter card acting as Z-wave network
controller. The Raspberry Pi has a user deï¬ned schedule
of temperature levels; it reads the thermometer measured
values and if needed (according to the schedule and required
temperature) it switches on (oï¬€) the heating.

The data for the room temperature was collected for the
period from December 2019 to May 2020. From the data,
we could observe 7 patterns of temperature dynamics after
ON/OFF commands of the thermostat. As an example, in the
Fig. 3 you can see that the temperature decreases with dif-
ferent rates, which depends on such environmental factors as
indoor and outdoor temperature, humidity, etc. We represent
diï¬€erent temperature dynamics patterns, accounting for the
diï¬€erent environmental conditions, with diï¬€erent thermostat
models.

The thermostat should be able to keep the scheduled
temperature with the precision of 1 degree Celcius, under
diï¬€erent environmental conditions in the room. The goal
of the search is to ï¬nd the schedule and the corresponding
thermostat operating mode, to falsify this requirement.

5.1.2. Problem representation

For this problem we deï¬ne three high-level input at-
the duration
tributes: ğ´1
the goal temperature value, ğ´2
of this temperature and the thermostat operation mode ğ´3
.
Each test case contains ğ‘š environmental elements ğ¸. For
each of them we need to specify the value of each of the
attributes ğ´1, ğ´2, ğ´3
. The allowable ranges for the attributes
are shown in Table 2.

An example of encoding of the individual representing
the temperature schedule illustrated in Fig. 3 (yellow line) is
shown in Table 3. Each environmental element represents a
part of the schedule, i.e, part of agentâ€™s â€œmissionâ€, as well as
the operating mode.

We deï¬ne two restrictions ğ‘…1

for the test scenar-
, the duration of the schedule ğ‘‡ cannot exceed 24

and ğ‘…2

ios. For ğ‘…1

2

3

4

2https://www.stelpro.com
https://aeotec.com/z-wave-sensor
https://z-wave.me/products/razberry

Figure 2: Crossover operator for two test cases with 5 and 6
environmental elements with the crossover point at the third
element

for one of the attributes ğ´ğ‘›
the value is changed ac-
cording to its type and maximum as well as minimum
values.

â€¢ scramble operator: attributes of a number of envi-
ronmental elements ğ¸ğ‘–
in a chromosome are selected,
then their positions in the chromosome are randomly
exchanged.

Individual insertion. To insert the individuals the mu+lambda
approach is employed [10]. The idea is to merge the pop-
ulation and oï¬€springs together, and then from the merged
set, select the best possible non-dominated solutions of the
population size.

5. Test scenario generation case studies

In this section we demonstrate how AmbieGen can be
applied to three diï¬€erent types of environment. We con-
sider the following test generation case studies: a smart-
thermostat, robot obstacle avoidance system, and vehicle
lane-keeping assist system (LKAS). In every case study
the autonomous agent controller has a diï¬€erent level of
complexity: simple proportionalâ€“integralâ€“derivative (PID)
controller for the thermostat, a robot controller based on
the nearness diagram navigation approach [31], and a deep
neural network based controller for the vehicle. We evaluate
AmbieGen by comparing the results obtained with random
search for all the three problems. For the LKAS system
case study we also compare our results with state-of-the art
approach, presented at SBST2021 tool competition1.

5.1. Wireless thermostat case study

Nowadays, home automation becomes more and more
popular. Automatic temperature control systems are one
of the most commonly used. Such systems consist of a
controller, temperature sensor and a heating element. The
controller goal is to keep the room temperature according to
the programmed schedule. The simplest solution is to send
"ON" and "OFF" commands to the heater, when the temper-
ature needs to be increased or decreased. More sophisticated
thermostats implement PID controllers to achieve smoother

1

https://sbst21.github.io/tools/

First Author et al.: Preprint submitted to Elsevier

Page 7 of 21

Short Title of the Article

(a) Slower decreasing temperature pattern

(b) Faster decreasing temperature pattern

Figure 3: Diï¬€erent temperature dynamics patterns

Table 2
Attribute types for thermostat problem

Table 4
Model coeï¬ƒcients

ğ´1, ğ‘¡ğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’, ğ‘‡ â—¦ ğ´2, ğ‘‘ğ‘¢ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›, ğ‘šğ‘–ğ‘› ğ´3, ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘› ğ‘šğ‘œğ‘‘ğ‘’
[60, 75,..., 240]

[16, 17,...,25],

[1, 2,..., 7 ]

Table 3
Example of individual representation for the ï¬rst case study

ğ´1, ğ‘”ğ‘œğ‘ğ‘™ ğ‘¡ğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’
ğ´2, ğ‘‘ğ‘¢ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›
ğ´3, ğ‘šğ‘œğ‘‘ğ‘’

ğ¸1
17
5
1

ğ¸2
23
4
3

ğ¸3
17
12
2

ğ¸4
21
2
4

ğ¸5
17
1
1

hours:

ğ‘…1 âˆ¶

ğ‘š
âˆ‘

ğ‘–=1

ğ´2ğ‘’ğ‘– < ğ‘‡ , ğ‘‡ = 24

(3)

This equation represents the sum of the values of attribute
(duration of the set temperature) of each of the ğ‘š envi-
ğ´2
ronmental elements.

For ğ‘…2

, the temperature cannot change too sharply, i.e.,
more than 5 degrees between two adjacent environmental
elements ğ¸ğ‘–

and ğ¸ğ‘–+1

:

ğ‘…2 âˆ¶âˆ£ ğ´1ğ‘’ğ‘–

âˆ’ ğ´1ğ‘’ğ‘–+1

âˆ£< 5, ğ‘– âˆˆ [1, ğ‘š âˆ’ 1],

(4)

where ğ‘š is the number of environmental elements in the test
case.

5.1.3. Fitness function deï¬nition

To calculate one of the ï¬tness functions we need to create
a simpliï¬ed model of the system. To this end, we extracted
the data from the experimental measurements and selected
the series of data points, corresponding to behaviour of the
thermostat after "switch on" and "switch oï¬€" commands in
diï¬€erent thermostat operation modes. The next challenge is
to select the model structure. In our case it is possible to
build a ï¬rst-principles model, as the heating and cooling of a
closed space is guided by physical laws, such as Newton Law
of cooling [42]. The law has an exponential nature, therefore
our model structure is based on increasing and decreasing
exponential function.

Model
1
2
3

ğ‘˜ğ‘œğ‘›1
7.7
7.9
6

ğ‘˜ğ‘œğ‘›2
0.11887928
0.11180434
0.14704908

ğ‘˜ğ‘œğ‘“ ğ‘“ 1
5.6
5.2
4.8

ğ‘˜ğ‘œğ‘“ ğ‘“ 2
0.02929884
0.04803319
0.1203876

We propose the following time-discreet model structure

for the ğ‘€1

("on") mode:

ğ‘Œ = ğ‘˜ğ‘œğ‘›1 âˆ— (1 âˆ’ ğ‘’âˆ’ğ‘˜ğ‘œğ‘›2âˆ—ğ‘¡ğ‘–) + ğ‘‡0
("oï¬€") mode:

and for the ğ‘€2

ğ‘Œ = ğ‘˜ğ‘œğ‘“ ğ‘“ 1 âˆ— (ğ‘’âˆ’ğ‘˜ğ‘œğ‘“ ğ‘“ 2âˆ—ğ‘¡ğ‘–) + ğ‘‡0 âˆ’ ğ‘˜ğ‘œğ‘“ ğ‘“ 1

(5)

(6)

, ğ‘˜ğ‘œğ‘›2

, ğ‘˜ğ‘œğ‘“ ğ‘“ 1

, ğ‘˜ğ‘œğ‘“ ğ‘“ 2

- is the starting temperature and ğ‘¡ğ‘–

Here ğ‘˜ğ‘œğ‘›1
are the unique coeï¬ƒcients
deï¬ning the model behaviour in a particular environment.
- the discreet time step
ğ‘‡0
value, ğ‘Œ - the output temperature. We keep the coeï¬ƒcients
in a table, such as Table 4, where coeï¬ƒcients for the three
models are shown. As an example, in Fig. 4 you can see
how the model 1 with the coeï¬ƒcients from the table, ï¬ts
the data from real measurements. One model includes two
equations describing behaviour in "on" and "oï¬€" modes. In
total, we identiï¬ed 7 models having diï¬€erent coeï¬ƒcients in
the equations, corresponding to the thermostat operating in
diï¬€erent environmental conditions.

Figure 4: Model (red points) ï¬tting the experimental data
(blue points)

To obtain the coeï¬ƒcients, we ï¬t the experimental data
by a curve with minimal deviation. We used python SciPy
library, namely ğ‘ğ‘¢ğ‘Ÿğ‘£ğ‘’_ğ‘“ ğ‘–ğ‘¡ function from ğ‘‚ğ‘ğ‘¡ğ‘–ğ‘šğ‘–ğ‘§ğ‘’ class,
which is based on the non-linear least squares method [25].

First Author et al.: Preprint submitted to Elsevier

Page 8 of 21

Short Title of the Article

The average root mean square error between original and
approximated data did not exceed 0.5 degrees Celsius.

Next, we specify the requirement for our system and
introduce the ï¬tness function based on this requirement: the
root-mean square error between the scheduled temperature
and the temperature set with the thermostat should not
exceed 1 degree Câ—¦.

To calculate the ï¬rst ï¬tness function, ğ¹1ğ‘¡â„ğ‘’ğ‘Ÿğ‘š

, we execute
the test scenario ğ‘‡ ğ¶ using the simpliï¬ed model. We obtain
the output values of the room temperature set by the thermo-
stat ğ‘Œ and calculate the root-mean square error between ğ‘Œ
and the temperature values deï¬ned in the schedule ğ‘†:

ğ¹1ğ‘¡â„ğ‘’ğ‘Ÿğ‘š =

âˆš
âˆš
âˆš
âˆš

ğ‘›
âˆ‘

ğ‘–=1

(ğ‘Œğ‘– âˆ’ ğ‘†ğ‘–)2
ğ‘›

,

(7)

(a) Randomly produced scenario

to 0.

where ğ‘› is the number of datapoints in the output. For the
test cases that do not satisfy the restrictions (3) and (4) we
set the ğ¹1ğ‘¡â„ğ‘’ğ‘Ÿğ‘š

We calculate the second ï¬tness function, ğ¹2ğ‘¡â„ğ‘’ğ‘Ÿğ‘š

accord-
ing to (2). In order to prevent obtaining the test cases with
low fault revealing power, we also add a search constraint
ğ¶ğ‘¡â„ğ‘’ğ‘Ÿğ‘š

:

ğ¶ğ‘¡â„ğ‘’ğ‘Ÿğ‘š âˆ¶ |ğ¹1ğ‘¡â„ğ‘’ğ‘Ÿğ‘š| âˆ’ 1.5 > 0,

(8)

5.1.4. Genetic algorithm conï¬guration.

We used the following GA (AmbieGen SO) and NSGA-
II (AmbieGen MO) conï¬gurations for the smart thermo-
stat problem: population size: 250, number of generations:
200,mutation rate: 0.4, crossover rate: 1, algorithm type:
generational, number of evaluations: 50 000.

We are using a high mutation rate, as from our ex-
perience, it allowed to converge to better solutions faster.
In our implementation a ğœ‡+ğœ† insertion approach is used,
where only the best individuals from previous generation
and oï¬€springs are inserted to the next generation. In the
generational GA the number of oï¬€springs inserted in the
population is equal to the population size. We limit the
number of evaluations to 50000, as typically after this num-
ber was enough for the algorithm to converge. The average
time to run 50000 evaluations was 136.691 sec for GA and
123.665 sec for NSGA-II.

5.1.5. Scenario generation

Finally, we discuss an example of the produced scenar-
ios. In Fig.5a you can see a scenario with a low ï¬tness value
of 0.76 degrees, indicating that the temperature deviates
from the schedule 0.76 degrees on average. On the contrary,
in Fig.5b the scenario produced by AmbieGen search has a
higher ï¬tness of 2.4 degrees. Clearly, this scenario is more
likely to be unacceptable to the user, comparing to the ï¬rst
one.

5.2. Autonomous navigating robot case study

The autonomous robotic systems are used in many do-
mains: from everyday tasks such as room cleaning to critical
missions such as navigation to harsh environments. For

(b) Search produced scenario

Figure 5: Examples of scenarios for the smart thermostat

every application, we need to have a high conï¬dence that
their behaviour will be safe. Running the simulations of
the system in various virtual environments can uncover the
possible failures of the robot in the early design stage.

In this case study we consider an autonomous mobile
robot, navigating in a space with obstacles. The robot has
to reach the goal location, relying only on its range sensors
and the planning algorithm. The goal is to generate the
environment, i.e., a room with obstacles that forces the robot
to fail. Similar test generation problems were addressed by
[39], [6]. In [6] the navigation maps are created using the
procedural content generation technique. Then robots are
assigned a randomized route to follow. The test scenario
is an environment populated with robots, obstructions, and
mission allocations. Sotiropoulos et al. characterize a map
by its size, percentage of obstruction (due to objects), and
its degree of smoothness (resulting from the ground local de-
formations). The robot is given a navigation mission, deï¬ned
by a starting position and a target arrival position, situated
in the map boundaries. Both approaches only consider the
random generation.

5.2.1. System under test description

We ran the simulations in the Player/Stage simulation
environment (see Fig. 6), which is one of the most commonly
used in the robotics ï¬eld [27]. We also considered using
such simulators as Gazebo5, MORSE6, and Argos7. One
of the advantages of Player/Stage for our study was the
possibility to load the automatically generated environment
conï¬guration ï¬les as well as the big number of implemented
models and controllers. For Gazebo and MORSE the en-
vironments have to be manually created in a dedicated 3D

5

6

7

http://gazebosim.org/
https://github.com/morse-simulator/morse
https://www.argos-sim.info/

First Author et al.: Preprint submitted to Elsevier

Page 9 of 21

Short Title of the Article

design tool. For Argos, the maps can be generated automat-
ically, however the number of implementation examples is
limited. One of them, which includes a planning algorithm
implementation, is dedicated to robot swarms, which we
plan to explore more in the future [41].

For simulations we used a Pioneer 3-AT mobile robot 8
model provided by the Player/Stage simulator. The robot is
equipped with a SICK LMS200 laser with the sensing range
of 10 meters, it has four wheels and is capable of speeds of
up to 0.8m/s. One of the planning algorithms provided by
the simulator is using the nearness diagram (ND) navigation
method. This is a reactive navigation method, where the
motion commands are computed based on the robot sensor
data. The method computes the optimal motion command to
avoid collisions while moving the robot toward a given goal
location. Before the robot mission starts, it runs the A* plan-
ning algorithm to obtain the route towards the goal. Then it
uses its ND algorithm for navigation. To increase the chal-
lenge for the robot we applied the Ramerâ€“Douglasâ€“Peucker
algorithm 9 to reduce the number of waypoints in the created
route.

Given the goal location the robot should navigate to it
without bumping into obstacles. The testing approach objec-
tive is to ï¬nd environments, when the navigation algorithm
fails and the robot does not reach the goal or the robot hits an
obstacle during the navigation. The scenario is represented
as a bitmap, where the location of obstacles is speciï¬ed, as
well as by a set of waypoints for the robot to follow. Failures
are detected by a daemon script that continuously monitors
the simulation environment.

(a) A perspective view in the
simulation environment

(b) A top view in the simulation
environment

Figure 6: Player/Stage simulation environment
tonomous robots

for au-

5.2.2. Problem representation

In this scenario generation case study the environment
is represented by a map with obstacles. We deï¬ne the map
size to be 50 x 50 m. Each environment part ğ¸ğ‘–
corresponds
to a space of the size 1 x 50 m. There is one obstacle in
each environmental element. In total there are 50 elements
, and 50 obstacles in each test case. The scenario matrix
ğ¸ğ‘–
size ğ‘€ is ï¬xed and is equal to 50. We deï¬ne three attributes

8

https://www.generationrobots.com/media/

Pioneer3AT-P3AT-RevA-datasheet.pdf

9

https://rdp.readthedocs.io/en/latest/

Table 5
Attribute types for autonomous robot problem

ğ´1, ğ‘œğ‘ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ ğ‘¡ğ‘¦ğ‘ğ‘’
[horizontal, vertical]

ğ´2, ğ‘œğ‘ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ ğ‘ ğ‘–ğ‘§ğ‘’ ğ´3, ğ‘œğ‘ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ ğ‘ğ‘œğ‘ ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›

[5,6, ..., 15]

[1, 2, ..., 50 ]

Table 6
Example of individual representation for the second case study

ğ´1, ğ‘œğ‘ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ ğ‘¡ğ‘¦ğ‘ğ‘’
ğ´2, ğ‘œğ‘ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ ğ‘ ğ‘–ğ‘§ğ‘’
ğ´3, ğ‘œğ‘ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ ğ‘ğ‘œğ‘ ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›

ğ¸1
0
15
12

ğ¸2
1
10
25

ğ¸3
0
10
35

ğ¸4
0
15
15

ğ¸5
0
10
38

, the type of the obstacle, ğ´2
describing the environment: ğ´1
position of the obstacle and ğ´3
the size of the obstacle. This
gives the size ğ‘ of the scenario matrix of 3. The values for
the attributes are speciï¬ed in Table 5. We use two types of
obstacles - vertical and horizontal walls. The size is the total
obstacle length in meters. The position is the obstacle center
location in the element ğ¸ğ‘–

An example of individual encoding that represents a
map with obstacles in Fig. 7 is shown in Table 6. Here the
map size is 50 m x 25 m and each environmental element
represents a part of the map of the size 50 m x 5 m. For
each environmental element the location of the center of the
obstacle (marked with a green circle) is speciï¬ed. Horizontal
obstacle is encoded with the value of 0 and the vertical
obstacle with the value of 1.

.

We deï¬ne two restrictions. First, ğ‘…1
. Second, ğ‘…2

: only one obstacle
per element ğ¸ğ‘–
: the obstacles cannot cover com-
pletely or intersect with the initial and target robot location
points.

Figure 7: An example of the test case represented by an
individual in table 6

5.2.3. Fitness function deï¬nition

The intelligent robotic systems are typically equipped
with a planning algorithm that builds a path to the goal
location as the robot moves through the environment. The
trajectory is adjusted as the new obstacles are discovered by
the robot.

In the simpliï¬ed case, the robot knows about the location
of all the obstacles in advance. Therefore, as the robot
approximated model we are using the Python robotics imple-
mentation of A* planning algorithm [38], which creates the

First Author et al.: Preprint submitted to Elsevier

Page 10 of 21

Short Title of the Article

route given the map, start and destination location. We have
selected the A* because it is a deterministic algorithm and
always ï¬nds a route, if it exists. The disadvantage is that the
computations take longer time, than for non-deterministic
planning algorithms such as RRT*.

The requirement for our system is that the robot should
navigate from the start to the goal location, without bumping
into an obstacle. To falsify this requirement, intuitively, the
test case should force the robot to follow a complex path to
the goal location.

The ï¬rst ï¬tness function, ğ¹1ğ‘Ÿğ‘œğ‘ğ‘œğ‘¡

, maximizes the distance
the robot would have to travel to ï¬nd the goal. Evidently,
travelling a longer distance, the robot takes a more complex
path to the goal location, that involves a higher number of
turns. For the test cases that do not meet the restrictions
is set to 0. The second ï¬tness function is
, ğ¹1ğ‘Ÿğ‘œğ‘ğ‘œğ‘¡
ğ‘…1
calculated according to (2).

and ğ‘…2

5.2.4. Genetic algorithm conï¬guration

We used the following GA (AmbieGen SO) and NSGA-
II (AmbieGen MO) conï¬gurations: population size: 100,
number of generations: 400, mutation rate: 0.4, crossover
rate: 1, algorithm type: steady state with 50 oï¬€springs,
number of evaluations: 20,000.

For this problem we used a smaller number of oï¬€springs
to run more generations for the same time budget. The A*
algorithm implementation was computationally expensive to
execute. The average time to run 20,000 evaluations was
2,727.2 sec for AmbieGen SO and 2,394.9 sec for AmbieGen
MO.

5.2.5. Scenario generation

In Fig.8 we show examples of the generated scenarios,
i.e., rooms with obstacles obtained by random generation
Fig. 8a and with AbmieGen Fig. 8b. In Fig. 8a the length of
the robot path towards the goal is 78.76 meters, while in the
Fig. 8a it is 202.36 meters. Evidently, the second scenario
poses a more challenging navigation environment for the
robot, than the ï¬rst scenario. The video demonstration of
the fault revealed for the robot model in the Player/Stage
environment can be found via the link: https://figshare.
com/s/7208f6d5ce19e1476474.

(a) Random scenario

(b) Search produced scenario

Figure 8: Examples obtained robot navigation maps

5.3. Lane keeping assist system case study

Self-driving cars have a perspective of becoming a part
of our lives in the near future. These systems are safety-
critical and should be well tested to avoid unwanted con-
sequences. Running the simulations in the virtual environ-
ments can reveal the possible faults of their control algo-
rithms.

In this case study, we generate virtual roads to test car
Lane Keeping Assist System (LKAS). The ego-car, i.e., the
test subject, should follow the lane of a given trajectory. The
testing approach goal is to generate a valid road topology,
that forces the ego-car to drive oï¬€ its lane . A number
of tools were suggested for automatic generation of virtual
roads, such as DeepJanus [36] and AsFault [20]. This year,
four tools, such as Frenetic, Deeper, Swat, and GA-BÃ©zier
were presented at the SBST2021 tool competition [34]. The
SWAT tool is the submission of the random generator based
implementation of our approach for virtual road generation.

5.3.1. System under test description.

For simulating the car and the environment, we used the
simulation pipeline initially provided by [36] and adapted
for the SBST2021 tool competition. This environment uses
the BeamNG.tech driving simulator [8], a freely avail-
able research-oriented version of the commercial game
BeamNG.drive (see Fig. 9). The test subject is the builtin
driving agent, BeamNG.AI. The car controller adopts a
behavioural cloning approach, i.e., the deep learning com-
ponent (DN) learns a direct mapping from the sensor camera
input to the steering angle value to be passed to the actuators
[14].

Figure 9: The screenshot from a BeamNG simulation environ-
ment

5.3.2. Problem representation

In this case study, the test scenario is a ï¬‚at road sur-
rounded by plain green grass with the ï¬xed weather con-
ditions: sunny clear day. The road layout (i.e., number and
width of lanes) is ï¬xed and consists of two lanes.

We divide the road into ğ‘š road segments. Each envi-
ronment element ğ¸ğ‘–
corresponds to one road segment. To
describe the road segment we deï¬ne three attributes: the type
: going straight, turning right and turning left.
of the road ğ´1
: the angle
ğ´2
of the turn of the curved segment. The attributes representa-
tion is shown in Table 7. The test scenario contains 3 rows

: the length of the straight road segment, and ğ´3

First Author et al.: Preprint submitted to Elsevier

Page 11 of 21

Table 7
Attribute types for vehicle problem

Table 9
Fine tuned values for the surrogate model

Short Title of the Article

ğ´1, ğ‘Ÿğ‘œğ‘ğ‘‘ ğ‘ ğ‘’ğ‘”ğ‘šğ‘’ğ‘›ğ‘¡ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ´2, ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘–ğ‘”â„ğ‘¡ ğ‘Ÿğ‘œğ‘ğ‘‘ ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„ ğ´3, ğ‘Ÿğ‘œğ‘ğ‘‘ ğ‘¡ğ‘¢ğ‘Ÿğ‘› ğ‘ğ‘›ğ‘”ğ‘™ğ‘’
[5, 6, ..., 50]

[5, 10,..., 85 ]

["straight",
"turn left",
"turn right"]

Table 8
Example of individual representation for the second case study

ğ´1, ğ‘Ÿğ‘œğ‘ğ‘‘ ğ‘¡ğ‘¦ğ‘ğ‘’
ğ´2, ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘–ğ‘”â„ğ‘¡ ğ‘Ÿğ‘œğ‘ğ‘‘ ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„
ğ´3, ğ‘¡ğ‘¢ğ‘Ÿğ‘›ğ‘–ğ‘›ğ‘” ğ‘ğ‘›ğ‘”ğ‘™ğ‘’

ğ¸1
0
15
0

ğ¸2
1
-
60

ğ¸3
1
-
60

ğ¸4
2
-
75

ğ¸5
0
5
0

(ğ‘ = 3) and a variable number of columns ğ‘€, depending
on how many road segments ï¬t in a map. In our scenarios
and at SBST competition, the map size was 200 x 200 m.

Figure 10: An example of the test case represented by an
individual in table 8

An example of individual encoding that represents a
road topology illustrated in in Fig.10 is shown in Table 8.
Each environmental element, ğ¸ğ‘–, ğ‘– âˆˆ [1, 5], represent one
road segment. The road segments are encoded as follows: 0
- for straight type, 1 - turning right and 2 - turning left .

The test cases have the following restrictions : the roads
cannot be too sharp, cannot
intersect and should not go
out of the map bounds. Examples of valid and invalid roads
are shown in Fig. 11.

Figure 11: Examples of valid (a) and invalid roads: (b) - out
of bounds, (c) - too sharp, (d ) - intersecting

ğœˆ0
7

ğ‘˜
3.5

ğ›¼
0.3

ğ›½
0.1

5.3.3. Fitness function deï¬nition

To calculate the test scenario ï¬tness we need to create
the simpliï¬ed model of the car. Similarly to the thermostat
problem, we built the car model from the ï¬rst principles as
the car movement can be described by a well known car
kinematic model [28]. To describe the car movement we use
the equations from [3], see Fig.12. To keep the car close to
the lane center we adopt Stanley control [22].

Figure 12: The simpliï¬ed car model parameters

In the equations below, ğ‘¥, ğ‘¦ - are the current coordinates
of the car on the map, ğœƒ is the angle between car direction
and a reference plane, ğ‘ and ğ‘ - constants, corresponding to
velocity value, ğ‘‘ - the distance of the car from the closest
point on the road. When ğ‘‘ is smaller than a certain threshold
ğ‘’, the car goes straight, when ğ‘‘ is larger than ğ‘’ - the car turns
either left or right. The turn angle is adopted depending on
the car speed and the deviation from the road lane center.

Therefore we have the following ï¬ne-tunable param-
. In order to ï¬ne
eters: ğ‘˜, ğ›¼, ğ›½ and the initial speed ğœˆ0
tune the parameters, we created a dataset with the road
points and the corresponding car model path ğ‘† recorded
by the simulator while executing the scenarios. Then we
compared the outputs of our model with the simulated car
path using such metric as a "Hausdorï¬€ distance". A similar
metric, Frechet distance, was used in [26] to compare the
similarity between roads. The goal was to minimize the
Hausdorï¬€ distance. To perform the optimization we use the
sci-py Nelder-Mead algorithm implementation. However,
other optimization algorithms can be used, such as genetic
algorithms. The set of the parameters that indicated the
lowest average Hausdorï¬€ distance of 13.74 is shown in Table
9.

Ì‡ğ‘¥ = ğœˆ â‹… ğ‘ğ‘œğ‘ ğœƒ
Ì‡ğ‘¦ = ğœˆ â‹… ğ‘ ğ‘–ğ‘›ğœƒ

Ì‡ğœƒ =

tanâˆ’1( ğ‘˜
)
â§
ğœˆ(ğ‘¡)
âª
âˆ’ tanâˆ’1( ğ‘˜
â¨
ğœˆ(ğ‘¡)
âª
0
â©

)

ğ‘–ğ‘“ ğ‘‘ < âˆ’ğ‘’

ğ‘–ğ‘“ ğ‘‘ > ğ‘’
ğ‘–ğ‘“ âˆ’ ğ‘’ â‰¤ ğ‘‘ â‰¤ ğ‘’

(9)

(10)

(11)

First Author et al.: Preprint submitted to Elsevier

Page 12 of 21

{

Ì‡ğœˆ =

âˆ’ğ›¼ ğ‘–ğ‘“ ğ‘‘ < âˆ’ğ‘’, ğ‘‘ > ğ‘’
ğ›½

ğ‘–ğ‘“ âˆ’ ğ‘’ â‰¤ ğ‘‘ â‰¤ ğ‘’

Short Title of the Article

(12)

Figure 13: The simpliï¬ed and full car model trajectory given
the same road points

In Fig.13 we depict the surrogate (blue points) and the
full model (green points) follow the interpolated road points
(yellow). The Hausdorï¬€ distance between the two roads is
5.153.

In this case study the requirement for the vehicle is to
stay within the road lane bounds and not go out of the lane
for more than a deï¬ned threshold, proportional to the area
of the vehicle outside the lane. For instance, the threshold of
0.5 means, that the car is considered to be out of the lane if
more than the half of the vehicle lies outside the lane. In our
case study we use a threshold of 0.85.

Finally, as the ï¬tness function, ğ¹1ğ‘£ğ‘’â„

, we used the max-
imum deviation ğ‘‘ from the lane center after executing the
test case, as in [20] and [35]. The test cases with the highest
value of the ï¬tness function are most likely to violate the
requirement, as they force the car to deviate further from the
lane centre. For the test cases that donâ€™t meet the restrictions,
is set to 0. The second ï¬tness function was calculated
ğ¹1ğ‘£ğ‘’â„
according to (2).

5.3.4. Genetic algorithm conï¬guration.

We used the following GA and NSGA-II conï¬gurations:
population size: 500, number of generations: 200, mutation
rate: 0.4, crossover rate: 1, algorithm type: generational,
number of evaluations: 100 000.

We are using a higher population size, rather than the
bigger number of generations, as from our experience, with
bigger population the results were more consistent across
diï¬€erent runs. The average time to run 100000 evaluations
was 1522.405 sec for GA and 1380.66 sec for NSGA-II.

Figure 14: The road points (black) generated after applying
aï¬ƒne transformations to the initial vector ğœˆ1

degrees anticlockwise ("turn left N degrees"). In the Fig. 15
we show examples of the generated test cases, that forced the
car to go out of the lane. The yellow points correspond to
the road lane center, the blue points - to the surrogate model
path, green points - the full model path. When the virtual
car went out of the lane bounds, the simulation recording
stopped, therefore we see the full model path only for the
part of the road. The video demonstration of the failure for
the car model can be found via the link: https://figshare.
com/s/b4a096f0a66e0abbe7b1.

6. Experimental evaluation
6.1. Research questions

We evaluate our approach using the three test case gen-
eration case studies described above. For each of the case
studies we answer the following research questions.

RQ1. (Comparing random, single-objective, and multi-

objective search). Considering the single and multi objec-
tive versions of AmbieGen as well as the random search,
which conï¬guration produces the test scenarios with the
higher fault revealing power given the same time budget?

Motivation: Firstly we would like to know if the use of
evolutionary search is beneï¬cial and allows to produce better
solutions, than simple random search. Next, we want to know
if adding additional ï¬tness function for diversity allows to
ï¬nd solutions with a higher fault revealing power. We expect
AmbieGen MO to produce solutions with the fault revealing
power, i.e., ğ¹1
ï¬tness function value at least as high as for
the solutions of AmbieGen SO. Previous works on novelty
search [18], [32] have shown that adding a ï¬tness function
for diversity may increase the convergence speed.

5.3.5. Scenario creation

To create the road points ğ‘1 âˆ’ ğ‘7

, used to generate the
road, we applied aï¬ƒne transformations to the initial vector
, according to the road types speciï¬ed in the generated sce-
ğœˆ1
nario, i.e., "straight N meters", "turn right/left N degrees".
Our approach is described in a more detail in [23].

Experiment design: We give the same number of evalu-
ations to all the three algorithms and compare the average ğ¹1
ï¬tness function value of the best solutions found. We repeat
the measurements 30 times.

RQ2. (Comparing diversity of the solutions found by
the single-objective and multi-objective search). To what

For example, to obtain ğœˆ2

we moved the ğœˆ1

meters ("straight N meters"). To obtain ğœˆ3

paralelly N
N

we turned ğœˆ2

First Author et al.: Preprint submitted to Elsevier

Page 13 of 21

Short Title of the Article

(a) Scenario forcing the car to drive oï¬€ the lane

(b) Scenario forcing the car to drive oï¬€ the lane

Figure 15: Examples of fault revealing scenarios for vehicle lane keeping assist system

extent the diversity of the solutions found by the multi objec-
tive AmbieGen conï¬guration is higher than the diversity of
the single objective conï¬guration solutions?

Motivation: This research question is aimed to quantify
the diï¬€erence between the diversity of the solutions pro-
duced by AmbieGen So and AmbieGen MO. We expect the
AmbieGen MO to produce more diverse scenarios.

Experiment design: Given the same time budget, we
compare the average diversity of the best 10 solutions found
by the single-objective algorithm and the average diversity
of the Pareto optimal solutions found by the multi-objective
algorithm. We repeat each measurement 30 times.

For the autonomous robot and lane keeping assistant case

study we also answer the following question:

RQ3. (Comparing our AmbieGen with the available
baselines) To what extent does our approach perform better
in generating test scenarios for the full model in comparison
with the available baselines?

Motivation: This research question is aimed to quantify
the eï¬€ectiveness of AmbieGen in the number of revealed
failures for the full models used in simulations.

Experiment design:
Autonomous robot case study. To the best of our knowl-
edge, there are no available test generation baselines for
the autonomous robot system. Therefore we compare the
generated scenarios with the random search by giving the
same time budget of two hours and executing the generated
environments in the robotic simulator. We repeat the exper-
iment 30 times.

Lane keeping assist system. For the lane keeping assist
system, we compare AmbieGen with the open-source ap-
proach that showed the best results in the SBST2021 tool
competition [34], i.e., Frenetic tool [13]. In the competition
the same test evaluation pipeline was provided to all the
participants. It allowed to compare the generated test cases
for the number of faults revealed (forcing the ego-car to go
out of the lane), the diversity of the revealed faults and the
proportion of valid test cases. We perform the same 2 hour
experiment as in the competition, averaging the results over
30 runs.

Table 10
Results of two-tailed non-parametric Mann-Whitney U test and
Cliï¬€â€™s delta eï¬€ect sizes for the thermostat case study

ğ‘†ğ‘‚ (ğºğ´)

ğ‘€ğ‘‚ (ğ‘ğ‘†ğºğ´2) ğ‘…ğ‘ğ‘›ğ‘‘ğ‘œğ‘š

ğ‘†ğ‘‚ (ğºğ´)
ğ‘€ğ‘‚ (ğ‘ğ‘†ğºğ´2)

ğ‘…ğ‘ğ‘›ğ‘‘ğ‘œğ‘š

ğ‘ = 0.378
0.133, ğ‘›ğ‘’ğ‘”ğ‘™ğ‘–ğ‘”ğ‘–ğ‘ğ‘™ğ‘’
ğ‘ < 0.01
1, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ‘ < 0.01
1, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

For all the research questions, to conï¬rm the statistical
signiï¬cance of the results we performed a two-tailed non-
parametric Mann-Whitney U test and measured the eï¬€ect
size using the non-parametric measure Cliï¬€â€™s delta. We ran
all the experiments on a PC running Microsoft Windows 10
Home and featuring a quad-core AMD Ryzen 7 4800HS
CPU @ 2.90 GHz, 16 GB of Memory, and an NVidia
GeForce GTX 1660 GPU @ 6GB.

6.2. Results

RQ1.(Comparing random, single-objective, and multi-
objective search) In the Fig. 16, Fig. 17, and Fig. 18,
we present the best ï¬tness value found over generations
by Random search (green boxplots), AmbieGen SO (red
boxplots) and AmbieGen MO (blue boxplots) averaged
over 30 runs for the three problems. We considered the
ï¬tness function accounting for the fault revealing power and
described in Equation (1).

We compare the ï¬tness function values found after
the allowed number of evaluations with a two-tailed non-
parametric Mann-Whitney U test. The obtained p-values and
eï¬€ect sizes of the problems are shown in the Tables 10, 11,
and 12, respectively.

Thermostat case study. From Fig. 16 we can see that
on average random search (yellow) converges to values
of -1.608, while AmbieGen SO (red) and AmbieGen MO
(blue) ï¬nd the solutions with twice higher ï¬tness value of
-3. Statistical tests conï¬rm that AmbieGen outperforms the
random search with p < 0.01. We can observe that on average
the SO converges faster than MO, however, the diï¬€erence
between the converged values is negligible.

First Author et al.: Preprint submitted to Elsevier

Page 14 of 21

Short Title of the Article

Table 12
Results of two-tailed non-parametric Mann-Whitney U test and
the Cliï¬€â€™s delta values for lane keeping assistant case study

ğ‘†ğ‘‚ (ğºğ´) ğ‘€ğ‘‚ (ğ‘ğ‘†ğºğ´2) ğ‘…ğ‘ğ‘›ğ‘‘ğ‘œğ‘š

ğ‘†ğ‘‚ (ğºğ´)
ğ‘€ğ‘‚ (ğ‘ğ‘†ğºğ´2)

ğ‘…ğ‘ğ‘›ğ‘‘ğ‘œğ‘š

ğ‘ = 0.0501
0.295, ğ‘ ğ‘šğ‘ğ‘™ğ‘™
ğ‘ < 0.01
0.877, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ‘ < 0.01
0.886, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

no statistical diï¬€erence in the produced solutions for the
thermostat and lane keeping assistance problem. For the au-
tonomous robot problem, the AmbieGen SO produces better
solutions with a large eï¬€ect size given 20000 evaluations.

Figure 18: Best ï¬tness function value over evaluations for the
lane keeping assistant case study

AmbieGen SO produced scenarios with highest
fault revealing power for the autonomous robot case
study. For the thermostat and LKAS case studies
the diï¬€erence in the solution ï¬tness of AmbieGen
SO and MO was negligible. Overall, AmbieGen
outperforms the random search with "large" eï¬€ect
size in all case studies.

RQ2.(Comparing diversity of the solutions found by
the single-objective and multi-objective search). In Fig.
19, Fig.20, and Fig. 21, we compare how diverse are the
produced solutions by AmbieGen SO and AmbieGen MO.
For SO, we select 10 ï¬ttest individuals and compute the
diversity according to (2) between each pair of individuals.
We report the average value. For NSGA-II, we compute the
diversity (2) between each pair of Pareto optimal solutions.
The size of the Pareto front was 7 individuals on average. All
the solutions in the Pareto front have a fault revealing (ğ¹1
)
ï¬tness function value higher than a certain fault-revealing
threshold, established by the developer.
the problems,

the two-tailed non-parametric
Mann-Whitney U test conï¬rmed that AmbieGen MO pro-
duces more diverse solutions, than AmbieGen SO. For
the smart thermostat problem, the MO scenarios are more
diverse with a p-value smaller than 0.01 and a "large" eï¬€ect

For all

Figure 16: Best ï¬tness function value over evaluations for the
thermostat case study

Table 11
Results of two-tailed non-parametric Mann-Whitney U test and
the Cliï¬€â€™s delta values for the autonomous robot case study

ğ‘†ğ‘‚ (ğºğ´) ğ‘€ğ‘‚ (ğ‘ğ‘†ğºğ´2) ğ‘…ğ‘ğ‘›ğ‘‘ğ‘œğ‘š

ğ‘†ğ‘‚ (ğºğ´)
ğ‘€ğ‘‚ (ğ‘ğ‘†ğºğ´2)

ğ‘…ğ‘ğ‘›ğ‘‘ğ‘œğ‘š

ğ‘ < 0.01
0.772, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’
ğ‘ < 0.01
1, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ‘ < 0.01
0.978, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

Autonomous robot case study. After 20000 evaluations,
on average, random search produced solutions with the
highest ï¬tness value of -158.89. AmbieGen outperforms
the random search, with the SO conï¬guration producing
42 % ï¬tter solutions of -278.2 and the MO conï¬guration
producing solutions of -251.6 ï¬tness value. Given the same
time budget, AmbieGen SO produces almost 10 % ï¬tter
solutions than AmbieGen MO.

Figure 17: Best ï¬tness function value over evaluations for the
autonomous robot case study

Lane keeping assistant case study. In 100000 evaluations
random search produced scenarios with the average highest
ï¬tness of -9. AmbieGen MO and SO produced almost 50
% ï¬tter solutions of -17 and -16, respectively. There was no
statistical diï¬€erence between the best solutions of SO and
MO.

Overall, We can see that for all the problems, AmbieGen
ï¬nds on average from 40 % to 50 % better solutions, than
the random search. AmbieGen SO and AmbieGen MO show

First Author et al.: Preprint submitted to Elsevier

Page 15 of 21

Short Title of the Article

size of 0.852. For the autonomous robot problem, AmbieGen
MO scenarios are more diverse with a p-value smaller and
a "large" eï¬€ect size of 1. For the lane keeping assist system,
MO scenarios are more diverse with a p-value of 0.0109
(ğ‘ â‰¤ 0.05) and a "medium" eï¬€ect size of 0.383.

Figure 19: Diversity of the test cases in the last generation for
the thermostat case study

(RQ1, RQ2 summary:) AmbieGen MO can ï¬nd sce-
narios of the same quality as AmbieGen SO and
better scenarios with a large eï¬€ect size than the
random search. Moreover, AmbieGen MO produces
a more diverse set of scenarios, than AmbieGen SO.
Overall, we recommend using the AmbieGen MO
conï¬guration.

RQ3.(Comparing AmbieGen with the available base-

lines).

Autonomous robot case study. In this subsection we
compare the number of faults revealed by the NSGA-II con-
ï¬guration of AmbieGen (AmbieGen MO) and the random
search. We created a scenario evaluation pipeline, where
ï¬rstly a two hour budget is given to produce the scenarios.
Then all the scenarios are passed to the simulator and exe-
cuted. The daemon script monitors the execution and reports
a failure when the robot stalls and does not reach a goal. We
repeated the experiment 30 times in both conï¬gurations. You
can see the average number of failures detected in Fig. 22.
AmbieGen produced on average 9 failures in two hours, in
comparison to the 2 failures of random search. AmbieGen
outperforms the random search with a p-value less than 0.01
and a large eï¬€ect size of 1.

Figure 20: Diversity of the test cases in the last generation for
the autonomous robot case study

Figure 21: Diversity of the test cases in the last generation for
the lane keeping assistant case study

In all the considered problems AmbieGen MO pro-
duced more diverse test cases: with "large" ef-
fect size for thermostat and robot case studies and
"medium" eï¬€ect size for the LKAS case study.

Figure 22: Number of faults revealed for the autonomous robot

Lane keeping assist system case study. In this subsec-
tion we report results of evaluating AmbieGen MO (Am-
bieGen) and the Frenetic tool (Frenetic). In addition we
evaluate the random search (RS) conï¬guration of AmbieGen
and the AmbieGen MO conï¬guration based on the full
model (Full).

For AmbieGen we used a simpliï¬ed conï¬guration for
virtual road generation, where only, 5,100 evaluations are
performed (population size 100, number of generations 200,
number of oï¬€springs - 25) in order to produce more test
scenarios given a limited time budget. We gave the same time
budget (5,090 evaluations) for the random search to produce
the solutions.

Finally, for the full model we used a conï¬guration pre-
viously suggested by Gambi et al. [20] for Asfault tool,
that also uses the full model to guide the search. In this
conï¬guration the population size is 25, number of oï¬€springs
is 4 and the number of generations is limited by the time
budget, i.e, two hours.

First Author et al.: Preprint submitted to Elsevier

Page 16 of 21

Short Title of the Article

Table 13
Mann-Whitney test p value and Cliï¬€â€™s delta for the number of
faults

Table 14
Mann-Whitney test p value and Cliï¬€â€™s delta for the fault
sparsity

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›

ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘

ğ¹ ğ‘¢ğ‘™ğ‘™

ğ‘…ğ‘†

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›
ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘

ğ¹ ğ‘¢ğ‘™ğ‘™

ğ‘…ğ‘†

ğ‘ = 0.917
0.0166, ğ‘›ğ‘’ğ‘”ğ‘™ğ‘–ğ‘”ğ‘–ğ‘ğ‘™ğ‘’
ğ‘ < 0.01
0.996, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’
ğ‘ < 0.01
0.653, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ‘ < 0.01
0.991, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’
ğ‘ < 0.01
0.578, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ‘ < 0.01
0.951, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›

ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘

ğ¹ ğ‘¢ğ‘™ğ‘™

ğ‘…ğ‘†

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›
ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘

ğ¹ ğ‘¢ğ‘™ğ‘™

ğ‘…ğ‘†

ğ‘ = 0.897
0.020, ğ‘›ğ‘’ğ‘”ğ‘™ğ‘–ğ‘”ğ‘–ğ‘ğ‘™ğ‘’
ğ‘ = 0.0889
0.3238, ğ‘ ğ‘šğ‘ğ‘™ğ‘™
ğ‘ = 0.912
0.018, ğ‘›ğ‘’ğ‘”ğ‘™ğ‘–ğ‘”ğ‘–ğ‘ğ‘™ğ‘’

ğ‘ = 0.0998
0.315, ğ‘ ğ‘šğ‘ğ‘™ğ‘™
ğ‘ = 0.794
0.042, ğ‘›ğ‘’ğ‘”ğ‘™ğ‘–ğ‘”ğ‘–ğ‘ğ‘™ğ‘’

ğ‘ = 0.147
0.285, ğ‘ ğ‘šğ‘ğ‘™ğ‘™

Approaches were evaluated using the SBST2021 code
pipeline [35], that integrates the test generators with the
BeamNG simulator by validating, executing, and evaluating
the generated test cases. We executed the SBST21 2 hour
experiment, where the failure is revealed when 0.85 percent
of the car area goes out of the lane. Also, the driving agent
travels up to 70 Km/h.

The test cases are compared in terms of the number of
faults Fig. 23, the diversity of the faults Fig. 24, and the
proportion of the valid test cases Fig. 25. The corresponding
statistical test and eï¬€ect size measures (Cliï¬€â€™s delta) are
shown in the Tables 13, 14 and 15.

Table 15
Mann-Whitney test p value and Cliï¬€â€™s delta for the proportion
of valid cases

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›

ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘

ğ‘…ğ‘†

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›
ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘

ğ‘…ğ‘†

ğ‘ < 0.01
1, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’
ğ‘ < 0.01
0.997, ğ‘™ğ‘ğ‘Ÿğ‘”ğ‘’

ğ‘ = 0.011
0.386, ğ‘šğ‘’ğ‘‘ğ‘–ğ‘¢ğ‘š

Table 16
Number of total, valid and invalid test cases

ğ´ğ‘šğ‘ğ‘–ğ‘’ğºğ‘’ğ‘›
ğ¹ ğ‘Ÿğ‘’ğ‘›ğ‘’ğ‘¡ğ‘–ğ‘
ğ‘…ğ‘†

ğ‘‡ ğ¶ğ‘ 
150
190.3
86.53

ğ‘‰ ğ‘ğ‘™ğ‘–ğ‘‘
137.8
136.46
65.32

ğ¼ğ‘›ğ‘£ğ‘ğ‘™ğ‘–ğ‘‘
12.23
53.83
21.21

Concerning the diversity of the revealed faults, all the
approaches have similar performance and do not show a
statistically signiï¬cant diï¬€erence.

Figure 23: The number of revealed faults

In terms of the number of the revealed faults both,
AmbieGen and Frenetic, statistically outperform the random
search and the full model based search. Out of 30 runs,
on average, AmbieGen and Frenetic produce almost equal
amount of faults, i.e., 14.

Figure 24: The diversity of the revealed faults

Figure 25: The proportion of the valid test cases

Another important factor was the proportion of valid test
cases out of all the cases produced. From Table 15 we see
that AmbieGen produces a statistically larger proportion of
the valid test cases, than Frenetic and random search. For the
full model, the invalid scenarios were assigned the ï¬tness
value of 0 and not submitted for evaluation. In Table 16
we also indicate the average number of the total produced
test cases as well as the number of invalid and valid test
cases. For the full number, initially the 25 individuals were
produced that were later evolved by the search operators.

First Author et al.: Preprint submitted to Elsevier

Page 17 of 21

Short Title of the Article

SBST2021 code pipeline evaluates the test cases procedu-
rally, i.e., as soon as the valid test case is produced it is
executed. The new test case can only be produced, when the
execution of the previous one stops. The scenario execution
time depends on the generated road length, i.e., the longer
the road, the more time the car will spend in the simulation.
Therefore, we do not evaluate the approaches by the total
number of the produced scenarios, as it depends not only on
the eï¬ƒciency of the algorithm, but also on the duration of the
generated scenarios. The random search generates the lowest
number of solutions as it only provides one solution after
5,090 evaluations. AmbieGen, on the contrary, provides
around 7 solutions on average, corresponding to the search
Pareto front after 5,090 evaluations.

AmbieGen reveals 9 failures in two hours, in com-
parison, random search could reveal only 2 failures
for the robot case study. Both AmbieGen and state of
the art Frenetic tool revealed 14 failures in two hours.
The revealed faults have similarly high diversity for
both tools. AmbieGen outperforms Frenetic in the
proportion of the valid generated scenarios. Am-
bieGen also outperforms the random search and the
full model conï¬guration in the number of revealed
faults.

7. Discussion

In this section we discuss the implications of our ï¬ndings

for research and the practice.
Evolutionary algorithms for scenario generation. Evolu-
tionary algorithms were proven to be eï¬€ective, comparing to
random generation, to create virtual environments for testing
automotive systems in previous works such as [9], [20], [36].
The implementation of such algorithms to generate envi-
ronments is rather challenging as the customized solution
representation and search operators need to be developed.

In our work we extend the application of evolutionary
search for environment generation to such domains as smart-
homes and autonomous robots . This work is the ï¬rst stage in
designing a framework for generating virtual environments,
AmbieGen. We consider the complete virtual environment
to be composed of separate elements. Each element is de-
scribed with a ï¬xed number of attributes. During the search
we recombine the elements as well as their attributes. One
of the advantages of such representation is the simplicity of
implementation of initial population generation, crossover
and mutation search operators. Therefore the developer only
needs to consider a high level description of the problem
and not concentrate on the design of search operators and
solution representation. By adding more attributes, the sce-
nario complexity can be increased. For the smart-thermostat,
for example, we can add such attributes as the humidity
inside the room and temperature outside the room for each
time period. For the autonomous robot - the terrain type and
indicate the presence of other robots. For the car, for each

road section we can indicate the terrain type, the incline, the
location of the other vehicles, etc.

Overall, our study conï¬rms the eï¬€ectiveness of search
based approaches for environment generation. Our frame-
work is aimed to reduce the eï¬€ort of the developers of evo-
lutionary algorithms to test the autonomous CPS. We pro-
vide the structure of the solution representation and search
operators, which can be applied to generation of diï¬€erent
types of environments. We provide examples of generating
smart-thermostat schedules, maps with obstacles and virtual
roads with search algorithm implementation based on Py-
moo framework.

Using simpliï¬ed system models. We explore the possi-
bility to use the approximated system models, rather than the
full models to compute the ï¬tness function. Evidently, full
models can detect failures with a higher precision, however
they are more expensive to execute in terms of resources and
time budget. For instance, the recommended requirements
for running BeamNg simulator are 16 GB RAM, Nvidia
GeForce GTX 970 videocard and Intel Core i7-6700 3.4Ghz
processor or better. Our evaluations have shown that the
full model failures can be detected by an approximated
model. Moreover, given the same time budget the search
guided by the approximated model may reveal more faults,
than when guided by the full model. We advocate for the
development of more precise simpliï¬ed CPS models and
making them open source, so that they can be easily used
by researchers to calculate the search ï¬tness functions. The
possibility to use the surrogate models was ï¬rst suggested by
[30], however it was used only to generate the CPS inputs.
In [9] the approximated models were used to generate the
environments, however no comparison with the full model
conï¬guration was provided.

Challenges. The challenging part of AmbieGen imple-
mentation is in evaluating the test scenario ï¬tness. It consists
of two stages: the ï¬rst is to convert the high level description
matrix ğ‘‡ ğ¶ to the environment conï¬guration. For the smart
thermostat we needed to convert the ğ‘‡ ğ¶ matrix to the list
of temperatures to follow, for an autonomous robot - to the
coordinates of obstacles in a map, which was rather simple.
For the LKAS case study we needed to transform the ğ‘‡ ğ¶
matrix to a set of 2D coordinates, that will produce valid
roads after cubic spline approximation. This conversion was
more complex and we developed a new technique leveraging
aï¬ƒne transformations to vectors. Next challenge was to
create an approximated model. For the autonomous robot we
used an implementation provided by the Python Robotics
project. For the LKAS, we implemented the model from
scratch. The available open source implementations were
rather time consuming to execute. We also created the model
from the real data for the thermostat case study as we did not
ï¬nd any open source full models.

Finally, it was challenging to ï¬nd baselines and pipelines
to evaluate the produced scenarios. For the autonomous
robot, we implemented a simple test evaluation pipeline,
based on the Player/Stage simulator. More advanced simu-
lators require the manual creation of the scenarios in the 3D

First Author et al.: Preprint submitted to Elsevier

Page 18 of 21

Short Title of the Article

design tools. Fortunately, for the LKAS case study we could
use the test evaluation pipeline provided by the SBST2021
competition.

In conclusion, we advocate for the creation of open
source approximated and full models of CPS. Moreover, it
is important to establish more test evaluation pipelines and
baselines, similar to the LKAS system for other domains of
CPS. Finally, we surmise that the CPS simulators should
provide a possibility to create environment from conï¬gura-
tion ï¬les or an API to automate the design of environments.

autonomous cyber-physical agents. However, we only con-
sidered a limited number of test subjects and limited levels of
environment complexity. Therefore more problems should
be addressed with diï¬€erent agents and higher environment
complexity to make deï¬nitive conclusions about the general-
izability of AmbieGen. Nonetheless, our evaluations demon-
strated that AmbieGen was eï¬€ective in revealing unwanted
behaviours for all the three considered autonomous CPS
agents.

8. Threats to validity

We now discuss potential threats to the validity of the

results of our study, following existing guidelines [43].

Internal validity. To minimize the threats to internal
validity, relating to experimental errors and biases, whenever
available, we used standardized frameworks for develop-
ment and evaluation. We implemented all the evolutionary
search algorithms (GA and NSGA-II) using a standartd
Python Pymoo framework. To evaluate the scenarios for
the LKAS case study we used a standardized test pipeline
used for SBST2021 workshop tool competition. For the
autonomous robot case study we created a customized test
evaluation
pipeline, which is based on the open source Player/Stage
robotic simulator. It provides implementations of the widely
used robotic models, such as Pioneer 3-AT, and planning al-
gorithms. This simulator was previously used by researchers
to conduct similar evaluations, as in [6].

Conclusion validity. Conclusion validity is related to
random variations and inappropriate use of statistics. To
mitigate it, we followed the guidelines in [5] for search-
based algorithm evaluation. We ran each evaluation at least
30 times and ensured the statistical signiï¬cance of the results
by using a two-tailed non-parametric Mann-Whitney U test
and Cliï¬€â€™s delta.

Construct validity. Construct validity is related to the
degree to which an evaluation measures what it claims. To
compare the test generation algorithms we gave the same
time budget to all the algorithms to produce the solutions.
For all the algorithms we evaluated the best ï¬tness found,
accounting for the scenario fault revealing power. To com-
pare the tools in terms of number of revealed faults we gave
each tool the same time budget to produce the scenarios. To
measure the diversity of the test scenarios we used a standard
metric such as Jaccard distance, previously used in other
studies to compare the diï¬€erence between the test cases.
The exact implementation of this metric is, however, case
study speciï¬c and thus can introduce some additional bias.
Furthermore, the results produced by AmbieGen depend on
the implementation of the approximated model. Presumably,
higher quality surrogate models can produce more failures of
the full model and improve the AmbieGen performance.

External validity. External validity relates to generaliz-
ability of our results. We demonstrated how our framework
can be applied to generate environments for three diï¬€erent

9. Conclusions and future work

In this paper we presented the design of AmbieGen, a
framework for generating virtual environments for testing
autonomous cyber-physical systems. It leverages evolution-
ary search guided by the approximated model of system. We
applied it to generating scenarios for the smart-thermostat,
autonomous robotic system, and vehicle lane keeping as-
sist system. Given the same time budget, AmbieGen could
generate on average 40 - 50 % ï¬tter solutions, than ran-
dom search. Moreover, AmbieGen was eï¬€ective at detecting
faults of the full model. In two hours it could ï¬nd 9 failures of
the Pioneer 3-AT mobile robot in the Player/Stage simulator,
comparing to only two failures found by random search. For
the full model of the vehicle, equipped with lane keeping
assist system, AmbieGen found 14 failures on average, the
same as the state of the art baseline - Frenetic. Random
search only found 8 failures on average. AmbieGen outper-
formed Frenetic in the number of valid generated scenarios
with a large eï¬€ect size.

Comparing the two proposed conï¬gurations of Am-
bieGen, the single objective (AmbieGen SO) and multi ob-
jective (AmbieGen MO), AmbieGen SO may ï¬nd ï¬tter so-
lutions than AmbieGen MO given the same time budget. In
two hours, for the autonomous robot case study, AmbieGen
SO found 10 % ï¬tter solutions than AmbieGen MO. For the
other case studies the diï¬€erence in the best found solutions
ï¬tness was insigniï¬cant. Overall, we recommend using the
multi objective conï¬guration of AmbieGen, AmbieGen MO,
as it always produced a more diverse set of solutions with
medium to large eï¬€ect size and on average could ï¬nd almost
as ï¬t solutions as AmbieGen SO.

We plan to continue the research in four directions. First
is creating more complex environments, taking into account
the weather, environmental conditions, and the moving ob-
stacles such as other robots or cars. We also plan to expand
the scenario generation to other CPS, such as drone and robot
swarms. Secondly, we will explore the possibility to create
more precise simpliï¬ed models using the system identiï¬ca-
tion techniques, including neural networks and NARIMAX
models. Thirdly, it is important to have the pipelines for
evaluating the generated scenarios. We plan to improve our
evaluation pipeline for autonomous robots by using more
sophisticated simulators such as Argos and Gazebo and more
complex models of robots. We will also work on developing
evaluation pipelines dedicated to other types of CPS. Finally,
we plan to implement AmbieGen as a python framework

First Author et al.: Preprint submitted to Elsevier

Page 19 of 21

Short Title of the Article

with an API for generating virtual environments and make
it open source.

10. Acknowledgements

This work is partly funded by the Natural Sciences and
Engineering Research Council of Canada (NSERC) [Grant
No: RGPIN-2019-06956] .

References
[1] Abdessalem, R.B., Nejati, S., Briand, L.C., Stifter, T., 2018. Testing
vision-based control systems using learnable evolutionary algorithms,
in: 2018 IEEE/ACM 40th International Conference on Software En-
gineering (ICSE), IEEE. pp. 1016â€“1026.

[2] Aerts, A., Reniers, M., Mousavi, M.R., 2017. Model-based testing
of cyber-physical systems, in: Cyber-Physical Systems. Elsevier, pp.
287â€“304.

[3] Alur, R., 2015. Principles of cyber-physical systems. MIT press.
[4] Annpureddy, Y., Liu, C., Fainekos, G., Sankaranarayanan, S., 2011.
S-taliro: A tool for temporal logic falsiï¬cation for hybrid systems, in:
International Conference on Tools and Algorithms for the Construc-
tion and Analysis of Systems, Springer. pp. 254â€“257.

[5] Arcuri, A., Briand, L., 2014. A hitchhikerâ€™s guide to statistical tests for
assessing randomized algorithms in software engineering. Software
Testing, Veriï¬cation and Reliability 24, 219â€“250.

[6] Arnold, J., Alexander, R., 2013. Testing autonomous robot control
software using procedural content generation, in: International Con-
ference on Computer Safety, Reliability, and Security, Springer. pp.
33â€“44.

[7] Arrieta, A., Wang, S., Markiegi, U., Sagardui, G., Etxeberria, L.,
2017. Search-based test case generation for cyber-physical systems,
in: 2017 IEEE Congress on Evolutionary Computation (CEC), IEEE.
pp. 688â€“697.

[8] BeamNG.tech, 2021. Beamng gmbh. URL: https://www.beamng.gmbh/

research.

[9] Ben Abdessalem, R., Nejati, S., Briand, L.C., Stifter, T., 2016. Testing
advanced driver assistance systems using multi-objective search and
neural networks, in: Proceedings of the 31st IEEE/ACM International
Conference on Automated Software Engineering, pp. 63â€“74.
[10] Beyer, H.G., Schwefel, H.P., 2002. Evolution strategiesâ€“a compre-

hensive introduction. Natural computing 1, 3â€“52.

[11] Blank, J., Deb, K., 2020. Pymoo: Multi-objective optimization in

python. IEEE Access 8, 89497â€“89509.

[12] Broy, M., Jonsson, B., Katoen, J.P., Leucker, M., Pretschner, A., 2005.
Model-based testing of reactive systems, in: Volume 3472 of Springer
LNCS, Springer.

[13] Castellano, E., Cetinkaya, A., Ho Thanh, C., Klivovits, S., Zhang,
X., Arcaini, P., 2021. Frenetic at the SBST 2021 tool competi-
tion. International Conference on Software Engineering, Workshops,
Madrid, Spain URL: https://github.com/ERATOMMSD/frenetic-sbst21/
blob/main/src/frenetic-sbst21-preprint.pdf.

[14] Chen, C., Seï¬€, A., Kornhauser, A., Xiao, J., 2015. Deepdriving:
Learning aï¬€ordance for direct perception in autonomous driving, in:
2015 IEEE International Conference on Computer Vision (ICCV), pp.
2722â€“2730. doi:10.1109/ICCV.2015.312.

[15] Coello, C.A.C., Lamont, G.B., Van Veldhuizen, D.A., et al., 2007.
Evolutionary algorithms for solving multi-objective problems. vol-
ume 5. Springer.

[16] Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C., 2009. Intro-

duction to algorithms. MIT press.

[17] David, A., Larsen, K.G., Legay, A., MikuÄionis, M., Poulsen, D.B.,
2015. Uppaal smc tutorial. International Journal on Software Tools
for Technology Transfer 17, 397â€“415.

[18] De Jong, E.D., Watson, R.A., Pollack, J.B., 2001. Reducing bloat and
promoting diversity using multi-objective methods, in: Proceedings
of the 3rd Annual Conference on Genetic and Evolutionary Compu-
tation, pp. 11â€“18.

[19] DonzÃ©, A., 2010. Breach, a toolbox for veriï¬cation and parameter
synthesis of hybrid systems, in: International Conference on Com-
puter Aided Veriï¬cation, Springer. pp. 167â€“170.

[20] Gambi, A., Mueller, M., Fraser, G., 2019. Automatically testing
self-driving cars with search-based procedural content generation, in:
Proceedings of the 28th ACM SIGSOFT International Symposium on
Software Testing and Analysis, pp. 318â€“328.

[21] Handa, A., Newcombe, R.A., Angeli, A., Davison, A.J., 2012. Real-
time camera tracking: When is high frame-rate best?, in: European
Conference on Computer Vision, Springer. pp. 222â€“235.

[22] Hoï¬€mann, G.M., Tomlin, C.J., Montemerlo, M., Thrun, S., 2007.
Autonomous automobile trajectory tracking for oï¬€-road driving: Con-
troller design, experimental validation and racing, in: 2007 American
control conference, IEEE. pp. 2296â€“2301.

[23] Humeniuk, D., Antoniol, G., Khomh, F., . Swat tool at the SBST 2021
tool competition. International Conference on Software Engineering,
Workshops, Madrid, Spain, 2021. URL: https://sbst21.github.io/
program/papers/SWAT_tool_at_SBST.pdf.

[24] Humeniuk, D., Khomh, F., Antoniol, G., 2021. A search-based frame-
work for automatic generation of testing environments for cyber-
physical systems. URL: https://github.com/dgumenyuk/Environment_
generation.git.

[25] Jones, E., Oliphant, T., Peterson, P., et al., 2001â€“. SciPy: Open source
scientiï¬c tools for Python. URL: https://docs.scipy.org/doc/scipy/
reference/generated/scipy.optimize.curve_fit.html.

[26] KlÃ¼ck, F., Klampï¬‚, L., Wotawa, F., 2021. Automatic generation of
challenging road networks for alks testing based on bezier curves and
search. arXiv preprint arXiv:2103.01288 .

[27] Kranz, M., Rusu, R.B., Maldonado, A., Beetz, M., Schmidt, A., 2006.
A player/stage system for context-aware intelligent environments.
Proceedings of UbiSys 6, 17â€“21.

[28] Laumond, J.P., Sekhavat, S., Lamiraux, F., 1998. Guidelines in
nonholonomic motion planning for mobile robots, in: Robot motion
planning and control. Springer, pp. 1â€“53.

[29] Ljung, L., Glad, T., 1994. Modeling of dynamic systems. BOOK,

Prentice-Hall.

[30] Menghi, C., Nejati, S., Briand, L., Parache, Y.I., 2020.
testing of compute-intensive cyber-
Approximation-reï¬nement
physical models: An approach based on system identiï¬cation,
in: 2020 IEEE/ACM 42nd International Conference on Software
Engineering (ICSE), IEEE. pp. 372â€“384.

[31] Minguez, J., Montano, L., 2004. Nearness diagram (nd) navigation:
collision avoidance in troublesome scenarios. IEEE Transactions on
Robotics and Automation 20, 45â€“59. doi:10.1109/TRA.2003.820849.

[32] Mouret, J.B., 2011. Novelty-based multiobjectivization, in: New

horizons in evolutionary robotics. Springer, pp. 139â€“154.

[33] Nguyen, C.D., Miles, S., Perini, A., Tonella, P., Harman, M., Luck,
M., 2012. Evolutionary testing of autonomous software agents.
Autonomous Agents and Multi-Agent Systems 25, 260â€“283.

[34] Panichella, S., Gambi, A., Zampetti, F., Riccio, V., 2021. SBST
tool competition 2021., in: In International Conference on Software
Engineering, Workshops, Madrid, Spain, ACM.

[35] Riccio, V., Tonella, P., 2020a. Model-based exploration of the frontier
of behaviours for deep learning system testing, in: Proceedings of the
28th ACM Joint Meeting on European Software Engineering Confer-
ence and Symposium on the Foundations of Software Engineering,
pp. 876â€“888.

[36] Riccio, V., Tonella, P., 2020b. Model-based exploration of the frontier
of behaviours for deep learning system testing, in: Proceedings of the
ACM Joint European Software Engineering Conference and Sympo-
sium on the Foundations of Software Engineering, Association for
Computing Machinery. p. 13 pages. doi:10.1145/3368089.3409730.
[37] Romijn, R., Ã–zkan, L., Weiland, S., Ludlage, J., Marquardt, W., 2008.
A grey-box modeling approach for the reduction of nonlinear systems.
Journal of Process Control 18, 906â€“914.

[38] Sakai, A., Ingram, D., Dinius, J., Chawla, K., Raï¬ƒn, A., Paques,
Pythonrobotics: a python code collection of robotics

A., 2018.
algorithms. arXiv:arXiv:1808.10703.

First Author et al.: Preprint submitted to Elsevier

Page 20 of 21

Short Title of the Article

[39] Sotiropoulos, T., Guiochet, G., Ingrand, I., Waeselynck, W., 2016.
Virtual worlds for testing robot navigation: a study on the diï¬ƒculty
level, in: 2016 12th European Dependable Computing Conference
(EDCC), IEEE. pp. 153â€“160.

[40] Sturtevant, N., 2012. Benchmarks for grid-based pathï¬nding. Trans-
actions on Computational Intelligence and AI in Games 4, 144 â€“ 148.
URL: http://web.cs.du.edu/~sturtevant/papers/benchmarks.pdf.
[41] Varadharajan, V.S., St-Onge, D., Adams, B., Beltrame, G., 2020.
Swarm relays: Distributed self-healing ground-and-air connectivity
chains. IEEE Robotics and Automation Letters 5, 5347â€“5354.

[42] Winterton, R., 1999. Newtonâ€™s law of cooling. Contemporary Physics

40, 205â€“212.

[43] Yin, R.K., 2002. Applications of Case Study Research Second
Edition (Applied Social Research Methods Series Volume 34). {Sage
Publications, Inc}.

[44] Zid, C., Humeniuk, D., Khomh, F., Antoniol, G., 2020. Double cycle
hybrid testing of hybrid distributed iot system, in: Proceedings of the
IEEE/ACM 42nd International Conference on Software Engineering
Workshops, Association for Computing Machinery, New York, NY,
USA. p. 529â€“532. URL: https://doi.org/10.1145/3387940.3392218,
doi:10.1145/3387940.3392218.

First Author et al.: Preprint submitted to Elsevier

Page 21 of 21

