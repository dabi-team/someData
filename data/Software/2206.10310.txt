2
2
0
2

n
u
J

6

]

B
D
.
s
c
[

1
v
0
1
3
0
1
.
6
0
2
2
:
v
i
X
r
a

PREPRINT (SOFTWARE—PRACTICE AND EXPERIENCE)
PREPRINT VERSION 0000; 00:1–34
Published online in Wiley InterScience (www.interscience.wiley.com). DOI: 10.1002/preprint

Modeling Big Data based Systems through Ontological Trading

Luis Iribarne*, José Andrés Asensio, Nicolás Padilla, Javier Criado

Applied Computing Group, Department of Informatics, University of Almería (Spain)

SUMMARY

One of the great challenges the information society faces is dealing with the huge amount of information
generated and handled daily on the Internet. Today, progress in Big Data proposals attempt to solve
this problem, but there are certain limitations to information search and retrieval due basically to the
large volumes handled, the heterogeneity of the information and its dispersion among a multitude of
sources. In this article, a formal framework is deﬁned to facilitate the design and development of an
Environmental Management Information System which works with an heterogeneous and large amount
of data. Nevertheless, this framework can be applied to other information systems that work with Big Data,
since it does not depend on the type of data and can be utilized in other domains. The framework is based on
an Ontological Web-Trading Model (OntoTrader) which follows Model-Driven Engineering and Ontology-
Driven Engineering guidelines to separate the system architecture from its implementation. The proposal
is accompanied by a case study, SOLERES-KRS, an Environmental Knowledge Representation System
designed and developed using Software Agents and Multi-Agent Systems. Copyright © 0000 John Wiley &
Sons, Ltd.

Received . . .

KEY WORDS:

Information Systems; Trading services; Ontologies; Model-Driven Engineering (MDE);
Ontology-Driven Engineering (ODE); Multi-Agent Systems

1. INTRODUCTION

New Big Data techniques [9] [3] are starting to come into use to develop Information Systems,
and especially Web-based Systems, for solving one of the major problems facing our information
society, the huge amount of information managed in almost any area of society. Current information
system development rules promote elimination of space-time barriers and facilitate asynchronous,
ubiquitous communication with their wide variety of users (administrators, technicians, politicians,
etc.), providing them with interactive information and graphical resources to assist them in problem-
solving and decision-making. Even so, these users often experience information overloads, and must
discriminate information in contents. This is because information search and retrieval must confront
the huge and heterogeneous volume managed, and integrate many sources or the repositories
where it is stored. Many techniques in different areas have to be applied to address this problem:
information representation, information storage and retrieval, information ﬁltering, studies on
information search behavior, human-computer interaction, etc.

Furthermore, current information system development requires integrity, scalability, accessibility,
adaptability, extendability, etc., making rules and standards necessary for their construction.
In particular, the design of Web-based Information Systems which handle large volumes of
information, such as Environmental Management Information Systems (like the SOLERES system,

*Correspondence to: Luis Iribarne, Applied Computing Group, Department of Informatics, University of Almería, Spain
Email: luis.iribarne@ual.es

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls [Version: 2010/05/13 v3.00]

 
 
 
 
 
 
2

L. IRIBARNE ET AL.

used as an experimental example in this article), must use standard methods and techniques enabling
a common vocabulary to represent the knowledge and real-time interaction mechanisms between
user and system, and between system and third-parties or even components of the system itself.
This has led to the use of new open distributed paradigms [69] and concepts such as Web semantics,
data mining and query components related to this type of system [61]. One of their intrinsic
characteristics is management of very disparate sources of knowledge for frequent use by a wide
variety of users (administrators, technicians, politicians, etc.) who must cooperate with each other
for better decision-making.

This article presents a framework for design and development of information systems that
rely on some of the main aspects of Big Data, i.e., the volume, velocity and variety of the
information managed [44]. Speciﬁcally this framework is focused on solving problems related to the
heterogeneity (i.e., variety) of the data through the use of mediation mechanisms between exporters
and importers of such information. Nevertheless, volume and velocity issues are also addressed
in this approach since the proposed infrastructure has been developed in order to manage a large
amount of data and to perform query and retrieval operations in assumable times of Web domain
(for example, balancing the workload on different nodes of the infrastructure). Previous conditions
result in a proposal for modeling systems which are based on Big Data concepts, although they may
not be considered (from a strict point of view) as Big Data systems. The framework proposed, called
Trading-based Knowledge Representation System (TKRS) is constructed following the rules and
guidelines of Model-Driven Engineering (MDE) and Ontology-Driven Engineering (ODE), thereby
enabling separation of the system architecture deﬁnition from its implementation. In TKRS, the
system is considered (in the design stage) a distributed architecture consisting of a set of nodes
(or ambients) which are in turn made up of a series of modules with certain preset functionalities
for system deployment. A graphical editor implemented speciﬁcally for designing the architecture
makes it possible to obtain a system model in a few simple steps. Node functionality is deﬁned
in the design stage as a type of capability the system must have, and may be implemented in
different programming languages in the development stage. The TKRS framework has a system
component implementation repository model connecting each component in the architecture to
its corresponding implementation. TKRS uses model-to-model (M2M) transformations to relate
architecture models to implementations in a system conﬁguration model. Based on the conﬁguration
model, a concrete instance of the system (executable code) is acquired for the speciﬁc platform
selected by applying a model-to-text (M2T) transformation.

The keystone of the TKRS framework is its three-level data model. The framework considers the
original data sources, which reside in their places of origin, ﬁrst. The system manages part of the
data from these original external data sources to process information related to its business logic.
For example, in digital document data systems, the sources may reside in proprietary repositories in
different entities or organizations. Each document is registered in the TKRS as a summary sheet (or
template) of the document (or metadata). The metadata are modeled as a business logic information
ontology. Therefore, each document that is entered in the system represents an instance of the
ontology. As a search and retrieval mechanism, the TKRS uses a trading model called OntoTrader
[35] which extends the traditional ODP [37] trading function. A trader (and by extension our
OntoTrader) is a yellow-page service that handles a small collection of data for locating more
detailed information. In TKRS, the OntoTrader trading model manages a meta-metadata repository
of templates or documents (metadata). This trading service integrates the available information
sources and system components, and improves information search and retrieval. Interaction with
different trading model interfaces is deﬁned by a series of service/process ontologies. The term
ontological trading model comes from the use of these ontologies with those for data.

In this article, as an experimental case study, the TKRS framework is applied in SOLERES, a
Web-based Environmental Management Information System that basically manages cartography
and satellite images. In this system, the business logic consists of processing the information to
make cartographic information and satellite information correspond. This correspondence involves
previously processing the cartography, dividing it into sectors, and classifying the satellite image
to be matched. Cartography and its sectorization, and the satellite image and its classiﬁcation are

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

3

modeled as an ontology and stored in TKRS as an instance of this ontology. A data subset of
this instance is registered in the trader to facilitate search, location and retrieval of information
in the system. The SOLERES system emerged from a multidisciplinary research project funded by
the Spanish Ministry of Science and Innovation and was supported by the application, integration
and development of studies in satellite imaging, neural networks, cooperative systems based on
multi-agent architectures, and software systems based on commercial components (third-party
components). The goal of the project was to study the possibility and feasibility of correlating
environmental variables used in creating ecological maps (based on cartography) with satellite
or ﬂight information, as was ﬁnally demonstrated. This correlation enables automatic creation of
ecological maps in far less time and at lower economic and human costs than what has been done
to date. For more information on this project see http://acg.ual.es/soleres.

As mentioned above, the TKRS framework was constructed following an MDE development
methodology. Figure 1 shows a summary of its architecture. Three basic types of models
are managed in it: (a) architecture models, (b) implementation repository models, and (c)
conﬁguration models. The ﬁrst step is to make a Platform Independent Model (PIM) of the system
architecture (in M2 level, i.e., PIM/M2) and the implementation repository (also in PIM/M2) to
be modeled by deﬁning the two metamodels. Then, system conﬁguration is modeled using a
Platform Speciﬁc Model (PSM) also in M2 level (PSM/M2), and it relates the architecture to a
concrete implementation. For this, ﬁrst a M2M transformation must be performed of both the
architecture model (PIM/M1 to PSM/M1) and the repository model (also PIM/M1 to PSM/M1).
Finally, based on the conﬁguration model (PSM/M1), another transformation, now M2T, generates
the implementation code for the speciﬁc platform. Eclipse-based technologies, such as Eclipse
Modeling Framework (EMF), Graphical Modeling Framework (GMF), XText and Xpand are used
to develop it. Thus, the metamodels are deﬁned by a graphical editor and stored in “.ecore” ﬁles, the
models created based on them are represented in “.xmi”, and the conﬁguration models are expressed
by a Domain Speciﬁc Language (DSL) which generates “.conﬁg” ﬁles.

The rest of the article is organized as follows. The three main parts of the framework, (a) the
architecture, (b) the implementation repository, and (c) the conﬁgurations, are modeled in Section
2. Then, a mathematical formalization is presented in Section 3. In Section 4, the SOLERES-KRS
case study, in which the TKRS proposal is validated, is presented. Section 5 describes some related
studies. Finally, in Section 6, some conclusions and future work are discussed.

Figure 1. Framework for design and development of TKRS systems

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

TKRSystem frameworkTKRS Model Implementation Repository Metamodel (.ecore)   [PIM/M2]TKRS Metamodel (.ecore)   [PIM/M2]Configuration Metamodel  (.ecore)   [PSM/M2]TKRS Model (.xmi)   [PIM/M1]Implementation Repository Model  (.xmi)   [PIM/M1] (.config)   [PSM/M1]Implementation Repository Model (.config)   [PSM/M1]Configuration Model  (.config)   [PSM/M1]Code M1 (.sh)Code  (.java)M2M3CODE   Transformation  Transformation  Transformation MDAMDECIMPIMPSM<<import>><<import>>4

L. IRIBARNE ET AL.

2. MODELING THE TKRS FRAMEWORK

As the TKRS framework uses an MDE approach with model transformation, several metamodels
had to be designed for the framework proposed. A transformer is a process that uses an M1 input
model according to a preset MM1 metamodel, and transforms it into M2 according to its MM2
metamodel based on a set of preset rules. As mentioned above, the TKRS framework uses three
basic models: architecture, implementation and conﬁguration. It was therefore necessary to create a
metamodel for each one, as described in the following sections.

2.1. Modeling the TKRS architecture

This section presents the TKRS architecture metamodel shown in Figure 2. It may be observed that
the TKRS is a type of distributed node architecture, where each node consists of a set of Modules,
as described below. Each node has at least one service module with a set of services for registering
modules and components, verifying states, etc. Each node also has a management module which
mediates between the user interface and the rest of the system modules, managing user demands,
and a query module related to solution of the user information queries. In addition, a node can also
have one or more trading modules, which enable the search and location of information in the system
(and here is where the OntoTrader model comes in) although it is not an indispensable requirement,
and one or more processing modules, responsible for the management of knowledge bases. These
may be grouped in larger logical units called ambients by any type of criterion, such as location.
The system must have at least one trading module and one processing module in one of its nodes.

The metamodel proposed in Figure 2 (PIM/M2 in Figure 1) was deﬁned using EMF [25],
and TKRS models reﬂecting the concepts, relationships and restrictions can be created based
on it. For example, the Node metaclass has an identiﬁer (name), an IP address (ip) and two
communication ports (port and dbport). It can also give the deﬁnition of an abstract Module
metaclass, with an attribute name, which the different types of modules inherit. The trading module,
which provides the ontological trading service with form, sets ﬁve Boolean attributes that show
whether it implements the various interfaces or not: Lookup, Register, Admin, Link and Proxy.
The Lookup and Register interfaces are necessary, because each trading module is linked to a
metadata repository. This metamodel also deﬁnes trading module federation by the isFederatedWith
relationship, and a connection between each processing module and each query module, by means
of the usesRegisterInterface and usesLookupInterface relationships, respectively, with a trading
module. These relationships are analyzed in Subsection 2.1.1.

Figure 2. TKRS architecture metamodel

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

Package-name : EStringTKRS-name : EString-ip : EString-port : EString-dbport : EStringNodeServiceModuleQueryModule-lookupInterface : EBoolean-registerInterface : EBoolean-adminInterface : EBoolean-linkInterface : EBoolean-proxyInterface : EBooleanTradingModule-ambient : EStringProcessingModuleManagementModule-name : EStringModulehasNode1..*isFederatedWith0..*1hasManagementModule1..*hasServiceModule1..*hasQueryModule1..*hasTKRS1hasNode1hasProccesingModule0..*hasTKRS1hasTradingModule0..*MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

5

The creation of TKRS models (PIM/M1 in Figure 1) using the metamodel described, is done by
a GMF graphical model editor, which along with OCL (Object Constraint Language) rules, enables
all the restrictions to be represented. For a more detailed description of this tool see [6].

2.1.1. Integrating the ontological trading service. One of the characteristics of TKRS design is
that the OntoTrader model is the axis of its architecture. As already mentioned, the ontological
trading model proposed is based on the OMG ODP speciﬁcation [37] and has been adapted to
handle documents with metadata of any type of information not just service speciﬁcations. This
model is a stand-alone trading service that implements the Lookup, Register and Admin interfaces,
as shown in the conceptual model shown in Figure 3. The Lookup interface is only concerned with
information queries, the Register interface enables full management of the service information, and
ﬁnally, conﬁguration parameters and trading policies can be modiﬁed from the Admin interface.

The service/process ontologies are used to deﬁne the behavior and interaction protocols of objects
or components interacting with the trading service interfaces. All the ontologies were modeled as
concepts (domain entities), actions performed in the domain (actions which affect concepts) and
predicates (expressions related to concepts), represented in UML class diagrams by the stereotypes
<<Concept>>, <<Action>> and <<Predicate>>, respectively. Each of these is analyzed in
more detail in the following Sections.

The ontological trading service is encapsulated in the TKRS architecture trading module, and the
service/process ontologies (Lookup, Register and Admin) use the rest of the modules to interact with
it, and even to communicate with each other. Table I shows the ontologies that each of the TKRS
system modules use. The inﬂuence of the OntoTrader model on management and information query
is analyzed below.

Figure 3. Conceptual model of stand-alone trading

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

6

L. IRIBARNE ET AL.

Table I. Use of service/process ontologies in TKRS

Source
Management module
Query module
Query module
Query module
Trading module
Processing module
Management module
Processing module
Management module

Target
Query module
Trading module
Processing module

Ontology
Lookup Ontology
Lookup Ontology
Lookup Ontology
Lookup Ontology Management module
Lookup Ontology
Lookup Ontology
Register Ontology
Register Ontology
Admin Ontology

Query module
Query module
Processing module
Trading module
Trading module

Four actions are implicit in information management: data insertion, modiﬁcation, elimination
and description. All of them originate from a query made from the interface by a user or a group
of users. This query is picked up by the management module and transferred to the processing
module speciﬁed by the user: (a) if data are to be inserted, this module stores the metadata in a
local repository and generates a new meta-metadata record from them, which stores it in a local
meta-metadata repository, and also transfers them to a trading module with which it is associated,
concluding the action. Thus, the trading module has an overall repository with all the meta-metadata
of all the processing modules associated with it (fundamental to information search and retrieval);
(b) if data are to be modiﬁed or deleted, ﬁrst the local processing module repositories are affected,
and then the action is transferred to the trading module so it can act accordingly, the same as
for insertion; (c) data description is solved directly in the processing module, which returns the
information demanded by the user based on which it is stored in its metadata repositories.

The OntoTrader trading service information retrieval process follows a “Query-Search/Recovery-
Response” mechanism (QS/RR), based on a three-level client/server model < O, M, I >. This
model is conﬁgured in the TKRS as follows (summarized in Figure 4): on Level 1 (N1) are
queries generated and processed by a component or object in the user interface and received in
the system by management modules O, on Level 3 (N3) are the processing modules, and their
metadata repositories I, and middleware M, which enables location of information sources, are on
Level 2 (N2), where the query and trading modules with their meta-metadata repositories operate.
As an indispensable premise for it to function, each object must be associated with a trading service,
which means that each query module and each processing module must be associated with a trading
module, and is the reason why each processing module and each query module in the metamodel
deﬁned in Section 2 is connected to a trading module (by means of the usesRegisterInterface and
usesLookupInterface relationships, respectively). The management modules are mere organizers
transmitting queries to the query modules. The reﬂection, delegation and federation scenarios,
summarized graphically in Figure 5, would be:

• In the reﬂection model, the query generated in interface O can be satisﬁed with meta-metadata
documents stored in the repository associated with a trading module M. The query would then
be transferred from the interface to a management module, and from there to a query module,
which is the one that really plans it, and then to the trading module. In this case, the model’s
< O, M > pair intervenes.

Figure 4. OntoTrader ontological trading service operation models

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

IMMN2N3ReflectionDelegationFederationOMOIMIMOMN1MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

7

Figure 5. TKRS operating diagram during a query

• The delegation model negotiates with the trading service indirectly. The query generated in
interface O goes to a query module that breaks it down into two or more subqueries. One
transfers it to the associated trading module M to locate the origin of the information in its
repository, and the query module reformulates the subquery or subqueries and transfers it
to the processing module repositories I indicated by the other. In this case, elements from
< O, M, I > intervene.

• In the federation model, two or more trading modules are conﬁgured to use a delegation
mechanism. As in the ﬁrst case, the query from interface O arrives at the ﬁrst trading module
associated with query module M it comes across, which propagates it to another trading
module M with which it is federated and will locate the external information sources I. In
this case, the intervening elements are < O, M, M, I >.

2.1.2. Trading ontologies. The three main ontologies used for trading are Lookup, Register and
Admin, as deﬁned below.

Lookup Ontology: The Lookup ontology searches for and retrieves information in a speciﬁc
repository following previously set criteria or policies. Figure 6 shows the structure of this ontology.
The Query action makes use of the QueryForm and PolicySeq concepts. The ﬁrst represents a query
expressed in a speciﬁc language and has several properties: id, uri, type, source and target. The
property id is a query identiﬁer, uri is a reference to the ﬁle that stores the query expressed in a
certain language. Table II shows an example of a query in SPARQL [56] in the EID repository
in the SOLERES case study analyzed in Section 4 to get “the name of the variables used in the
classiﬁcations made during 2008”. It is important to note that this query example is related to the
type of information that is managed in the case study and, if different information is used, this code
snippet must be changed accordingly. The property type shows the exact type of query (for example,
if it is a query about the repository or another previous query). And source identiﬁes the object or
component the query comes from, and ﬁnally, target, enables its destination object or component to
be identiﬁed.

The PolicySeq concept also represents a set of query policies. The Policy is an abstract concept
used to represent a speciﬁc policy by means of the tuple (name, value). Therefore, its only property
is a value representing a given Policy. The three policies deﬁned are: def_search_cardPolicy,
max_search_cardPolicy and exact_type_matchPolicy. The ﬁrst shows the number of documents
to be located in the query, max_search_cardPolicy and exact_type_matchPolicy state whether the
documents to be located must coincide exactly with the query conditions or not (true if the

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

Processing moduleInterface Trading moduleQuery moduleTrading moduleFederationQuery moduleSubquerySubquerySubquerySubqueryQueryQueryResultResult8

L. IRIBARNE ET AL.

Figure 6. Lookup ontology conceptual model

Table II. Example query expressed in SPARQL

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

PREFIX eid: <http://www.ual.es/acg/ont/TKRS/EIDOntology.owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT DISTINCT ?EID__VariableName
WHERE
{

?EID__EID eid:EID_eimId ?EID__EID_eimID .
?EID__EID eid:EID_hasClassification ?EID__Classification .
?EID__Classification eid:Classification_hasLayer ?EID__Layer .
?EID__Layer eid:Layer_hasVariable ?EID__Variable .
?EID__Variable eid:Variable_name ?EID__VariableName .
?EID__Classification eid:Classification_hasTime ?EID__Time .
?EID__Time eid:Time_year ?EID__TimeYear .
FILTER (?EID__TimeYear = 2008) .

}
ORDER BY ASC(?EID__VariableName)

documents returned must meet the conditions set by the query 100%, false if the documents located
do not necessarily have to coincide exactly with the conditions).

The output of the Query action may be a controlled exception or the result of the query itself,
all of them represented by the abstract predicate Message they inherit from. This predicate has the
property returned_message, which contains the text of the output message. Exceptions that could
arise are: UnknownQueryForm, PolicyTypeMismatch, InvalidPolicyValue, DuplicatePolicyName
and QueryError. The exception UnknownQueryForm shows that the query could not be answered
because the ﬁle speciﬁed in the uri was not accessible; PolicyTypeMismatch shows that the type
of Policy value was not right; InvalidPolicyValue shows that the Policy value was not within the
permissible range for this Policy; DuplicatePolicyName shows that more than one value for the
same Policy within PolicySeq was speciﬁed; and ﬁnally, the exception QueryError shows that there
was an error in executing the query.

When the query is made successfully, the predicate EmptyOfferSeq is employed if no document
is returned, or NotEmptyOfferSeq if it is. This predicate in turn makes use of the OfferSeq and
OfferSeqMatch concepts to store the set of documents located and the percentage of coincidence of
each document found, respectively, depending on the conditions of the query. The OfferSeq concept
has the properties of the query id and the uri of the ﬁle that stores the documents found, just as the
OfferSeqMatch concept, where the uri now refers to another ﬁle which contains a set of documents
in the form of the tuples <identiﬁer_of_record_found, percentage_of_coincidence>.

Table III summarizes the concepts, actions and predicates in the Lookup ontology. Abstract

predicates Message and Policy are not included.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

<<Action>>Query-id : unsigned long-uri : string-type : string-source : string-target : string<<Concept>>QueryForm<<Concept>>PolicySeq-id : unsigned long-uri : string<<Concept>>OfferSeq-id : unsigned long-uri : string<<Concept>>OfferSeqMatch<<Concept>>Policy-value : unsigned long<<Concept>>def_search_cardPolicy-value : unsigned long<<Concept>>max_search_cardPolicy-value : boolean<<Concept>>exact_type_matchPolicy<<Predicate>>UnknownQueryForm<<Predicate>>PolicyTypeMismatch<<Predicate>>InvalidPolicyValue<<Predicate>>DuplicatePolicyName<<Predicate>>QueryError<<Predicate>>EmptyOfferSeq<<Predicate>>NotEmptyOfferSeq-returned_message : string<<Predicate>>Message0..11..*1..30..1ConceptActionPredicateMODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

9

Table III. Lookup, Register and Admin ontology elements

Ontology
Lookup

Register

Concepts
QueryForm
PolicySeq
def_search_cardPolicy
max_search_cardPolicy
exact_type_matchPolicy
OfferSeq
OfferSeqMatch
Offer
OfferId

Actions
Query

Export
Modify
Withdraw
Describe

Admin

Def_search_card
Max_search_card
Offer_repos

SetDef_search_card
SetMax_search_card
SetOffer_repos
GetDef_search_card
GetMax_search_card
GetOffer_repos

Predicates
UnknownQueryForm
PolicyTypeMismatch
InvalidPolicyValue
DuplicatePolicyName
QueryError
EmptyOfferSeq
NotEmptyOfferSeq
IllegalOffer
UnknownOffer
DuplicateOffer
IllegalOfferId
UnknownOfferId
QueryError
ExportedOffer
ModiﬁedOffer
WithdrawnOffer
NotDescribedOffer
DescribedOffer
ModiﬁedDef_search_card
ModiﬁedMax_search_card
ModiﬁedOffer_repos
ReturnedDef_search_card
ReturnedMax_search_card
ReturnedOffer_repos
InvalidValue

Register Ontology: The metadata documents stored by the trading service in its repository are
managed by the Register ontology which supports the creation, modiﬁcation, elimination and
description of documents. This ontology includes the Export, Modify, Withdraw and Describe
actions. The Export action inserts a document previously speciﬁed in the Offer concept, which
is stored in a ﬁle referenced by the concept’s uri property. The Modify action represents a document
modiﬁcation of a document and uses the Offer concept to refer to the new document with the
changed information and the OfferId concept to represent the identiﬁer of the document that is
going to be modiﬁed. Finally, the Withdraw and Describe actions represent the elimination and
description, respectively, of a particular document speciﬁed by the OfferId concept. Figure 7 shows
the structure of the Register ontology.

Figure 7. Register ontology conceptual model

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

<<Action>>Export<<Action>>Modify<<Action>>Withdraw<<Action>>Describe-uri : string<<Concept>>Offer-id : unsigned long<<Concept>>OfferId-returned_message : string<<Predicate>>Message<<Predicate>>IllegalOffer<<Predicate>>UnknownOffer<<Predicate>>DuplicateOffer<<Predicate>>IllegalOfferId<<Predicate>>UnknownOfferId<<Predicate>>QueryError<<Predicate>>ExportedOffer<<Predicate>>ModifiedOffer<<Predicate>>WithdrawnOffer<<Predicate>>NotDescribedOffer<<Predicate>>DescribedOfferConceptActionPredicate10

L. IRIBARNE ET AL.

The result of an action may produce a controlled exception in the system or a valid result.
Both are represented by a predicate that inherits from the abstract predicate Message, as in the
Lookup ontology. The exceptions that can occur are IllegalOffer, UnknownOffer, DuplicateOffer,
IllegalOfferId, UnknownOfferId and QueryError. The ﬁrst three can come from the actions Export
and Modify: the exception IllegalOffer shows that the metadata document that it is intended to insert
or modify is incorrect, UnknownOffer shows that the document cannot be found for its insertion or
modiﬁcation because the ﬁle speciﬁed in the uri is inaccessible, and the exception DuplicateOffer
shows that the document already exists in the repository. The actions Modify, Withdraw and
Describe can also generate the exceptions IllegalOfferId and UnknownOfferId: The ﬁrst shows that
the id of the document that it is intended to modify, eliminate or describe is incorrect, while the
second shows that there is no document in the repository with this id for its modiﬁcation, elimination
or description. Finally, the Describe action can generate the exception QueryError, which shows that
there has been an error in making the query for the document speciﬁed for its description.

The ontology also deﬁnes the ExportedOffer, ModiﬁedOffer and WithdrawnOffer predicates to
show that the Export, Modify and Withdraw actions, respectively, have been performed successfully.
The ExportedOffer predicate makes use of the OfferId concept to show the id assigned to the new
document. The NotDescribedOffer predicate of the Describe action shows the document was not
located, and DescribedOffer that it was. This predicate makes use of the Offer concept to return the
document requested.

Table III also summarizes Register ontology concepts, actions and predicates. The abstract

predicate Message is not included.

Admin Ontology: The Admin ontology is used for actions that modify the main conﬁguration
parameters and trading service policies. This ontology enables the maximum number of results
found after executing a query to be modiﬁed, for example. Figure 8 shows its structure. This
ontology deﬁnes three pairs of actions: SetDef_search_card/GetDef_search_card sets and obtains
the predetermined number of metadata documents that are retrieved in a search and uses the
Def_search_card concept to store this information, SetMax_search_card/GetMax_search_card
sets and obtains the maximum number of documents that are retrieved in a search and uses
the Max_search_card concept to store this information, and SetOffer_repos/GetOffer_repos can
set/obtain the address (in URI format) of the repository with the metadata documents that uses the
trading service (the Offer_repos concept is used to store the address).

Figure 8. Admin ontology conceptual model

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

<<Concept>>Def_search_card<<Concept>>Max_search_card<<Concept>>Offer_repos<<Action>>SetDef_search_card<<Action>>SetMax_search_card<<Action>>SetOffer_repos<<Action>>GetDef_search_card<<Action>>GetMax_search_card<<Action>>GetOffer_repos<<Predicate>>ModifiedDef_search_card<<Predicate>>ModifiedMax_search_card<<Predicate>>ModifiedOffer_repos<<Predicate>>ReturnedDef_search_card<<Predicate>>ReturnedMax_search_card<<Predicate>>ReturnedOffer_repos<<Predicate>>InvalidValue-returned_message : string<<Predicate>>MessageConceptActionPredicateMODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

11

When the “Set” actions are performed successfully,

the Modi-
the trader
ﬁedDef_search_card and ModiﬁedOffer_repos predicates to show that
the
Def_search_card, ModiﬁedMax_search_card and Offer_repos parameters, respectively, have been
set satisfactorily. On the other hand, it could return the ReturnedDef_search_card, Returned-
Max_search_card and ReturnedOffer_repos predicates to show that the values of the “Get”
action parameters have been returned correctly. The only controlled exception that could occur
is the InvalidValue predicate which could come from the actions SetDef_search_crad, Set-
Max_search_card or SetOffer_repos. This exception shows that the value speciﬁed for the parameter
in question is invalid. As in the Lookup and Register ontologies, all the predicates inherit from
the abstract predicate Message, which contains the property returned_message to store the output
message text.

returns
the values of

Table III summarizes the concepts, actions and predicates in the Admin ontology. The abstract

predicate Message is not included.

2.1.3. Representing knowledge. The TKRS can manage a large volume of data originating in one
or more external sources directly related to one or more processing modules. These data originally
make up the ﬁrst level of the system data architecture. Although one of the main purposes of TKRS
is to improve information search and retrieval, it is obviously inappropriate to work directly with
the data given their probable volume, so a second level of metadata is generated and stored in the
processing modules. The volume of these metadata is already much smaller, and although it may
sometimes be necessary to recur to the lower level of data to solve a query, most of them can be
solved on this higher level. However, should it be necessary, the metadata would act as a ﬁlter
reducing the volume of information and therefore query execution time.

Since the system is distributed, a new level, called the meta-metadata level (which has certain
information relating the different processing modules and is used by the trading modules), is
included in the architecture. The ontologies have a basic role in the deﬁnition of these metadata and
meta-metadata, in addition to the one they already have in deﬁning system component interaction
and communication protocols. Figure 9 shows the three levels of data architecture.

2.2. Modeling the TKRS implementation repository

After the TKRS architecture has been modeled (Metamodel PIM/M2 in Figure 1), the next step
is to model system implementation, since there may be more than one implementation depending
on the development platform used, so they are all grouped together in a single repository. The
structure of this implementation repository is very basic, and as observed in Figure 10, which
shows the repository metamodel (PIM/M2), it is made up of platforms (metaclass Platform) and
implementations of each of the system modules in these platforms. The Platform metaclass includes
a required attribute (name) specifying the name of the development platform used. A module
(CompositeModule metaclass) can in turn be made up of one or more modules (CompositeModule
or SimpleModule). The abstract metaclass Module (from which both simple and composite modules
inherit) is also included, and two obligatory attributes, name and uri, specify the name of the module
and a reference to the location of the implementation ﬁles, respectively. Finally, each module has a

Figure 9. TKRS three-level data architecture

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

Processing Module Trading Module L1 (Data)L2 (Metadata)L3 (Meta-metadata)12

L. IRIBARNE ET AL.

Figure 10. Metamodel of a TKRS implementation repository

reference to its container module, if any, and its platform. This metamodel was again deﬁned using
EMF, and the reﬂective ecore model editor can be used to create concrete implementation repository
models, implemented as analyzed in Section 4.2 based on the Multi-Agent Systems technology.

2.3. Modeling the TKRS conﬁguration

When the TKRS architecture and a repository of implementations on different platforms
(Metamodel PIM/M2 in Figure 1) have been deﬁned, the next step for ﬁnal system deployment in a
given environment consists of setting up a mechanism to relate each element in the architecture to its
implementation. This is exactly what is proposed below. As shown in Figure 11, a new metamodel
(PSM/M2) was deﬁned in which the Statement metaclass relates each metamodel module in the
TKRS architecture to the Module abstract metaclass in the implementation repository metamodel by
means of the Module abstract metaclass. Furthermore, to be able to work with both the architecture
and repository models, it includes the Import metaclass with the attribute importedNamespace so
the conﬁguration models can import them. This metamodel, like the metamodels above, was deﬁned
using EMF, but to facilitate the creation of conﬁguration models, a Domain Speciﬁc Language
(DSL) was developed using Eclipse XText. This tool can deﬁne a grammar based on a metamodel
which describes both the concrete syntax of the language desired to implement and the procedure
the parser must follow to generate a model.

Table IV shows the grammar deﬁned for the conﬁguration language. The grammar statement
appears in line #1, showing its location, and then, use of the org:eclipse:xtext:common:Terminals,
which deﬁnes rules for common terminals such as ID, STRING and INT. From line #3 to #6 “.ecore”

Figure 11. TKRS conﬁguration metamodel

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

-name : EStringPackage-name : EStringPlatform-name : EString-uri : EStringModuleCompositeModuleSimpleModulehasSubmodule1..*hasPlatform0..1hasModule1..*hasSupermodule0..1hasPlatform1..*-name : EStringPackage-importnamespace : EStringImportStatementTKRS PackageTKRSModuleImplementation Repository PackagePlatformModulehasImplementationRepositoryModule1hasImport0..*0..*hasImplementationPlatformhasStatement0..*hasTKRShasTKRSModule0..11MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

13

Table IV. Deﬁnition of the TKRS conﬁguration grammar

01 grammar org.xtext.TKRS.config.Config with org.eclipse.xtext.common.Terminals
02
03 import "platform:/resource/TKRS/metamodels/Configuration.ecore"
04 import "platform:/resource/TKRS/metamodels/TKRS.ecore" as TKRSPackage
05 import "platform:/resource/TKRS/metamodels/ImplementationRepository.ecore"

as ImplementationRepositoryPackage

06 import "http://www.eclipse.org/emf/2002/Ecore" as ecore
07
08 Package returns Package:
09
10
11
12

{Package}
’Package’ name=EString
( hasImport+=Import (hasImport+=Import)* )? ( hasTKRS=TKRS )?
(’ImplementationRepository’ ’{’ hasImplementationRepository+=Platform

(hasImplementationRepository+=Platform)* ’}’ )?

(’Configuration’ ’{’ hasStatement+=Statement (hasStatement+=Statement)* ’}’ )?;

13
14
15 Import returns Import: ’import’ importedNamespace=ImportedFQN;
16
17 ImportedFQN: FQN (’.’ ’*’)?;
18
19 FQN: ID (’.’ ID)*;
20
21 TKRS returns TKRSPackage::TKRS: ’TKRS’ name=EString ’{’ hasNode+=Node (hasNode+=Node)* ’}’;
22
23 Node returns TKRSPackage::Node:’Node’ name=EString ’{’
24
25
26
27
28
29
30
31
32
33
34 TKRSModule returns TKRSPackage::Module:ManagementModule | QueryModule | TradingModule | ProcessingModule |

’ip’ ip=EString
’port’ port=EString
’dbport’ dbport=EString
hasServiceModule=ServiceModule
hasManagementModule=ManagementModule
( hasTradingModule+=TradingModule (hasTradingModule+=TradingModule)* )?
hasQueryModule+=QueryModule (hasQueryModule+=QueryModule)*

( hasProcessingModule+=ProcessingModule (hasProcessingModule+=ProcessingModule)* )?

’hasTKRS’ hasTKRS=[TKRSPackage::TKRS|EString] ’}’;

ServiceModule;

’hasNode’ hasNode=[TKRSPackage::Node|EString] ’}’;

’hasNode’ hasNode=[TKRSPackage::Node|EString] ’}’;

’usesLookupInterface’ usesLookupInterface=[TKRSPackage::TradingModule|EString]
’hasNode’ hasNode=[TKRSPackage::Node|EString] ’}’;

’ambient’ ambient=EString
’usesRegisterInterface’ usesRegisterInterface=[TKRSPackage::TradingModule|EString]
’hasNode’ hasNode=[TKRSPackage::Node|EString] ’}’;

’usesLookupInterface’ lookupInterface=EBoolean
’usesRegisterInterface’ registerInterface=EBoolean
’usesAdminInterface’ adminInterface=EBoolean
’usesLinkInterface’ linkInterface=EBoolean
’usesProxyInterface’ proxyInterface=EBoolean
(’isFederatedWith’ isFederatedWith+=[TKRSPackage::TradingModule|EString]
(isFederatedWith+=[TKRSPackage::TradingModule|EString])* )?
’hasNode’ hasNode=[TKRSPackage::Node|EString] ’}’;

35
36 ServiceModule returns TKRSPackage::ServiceModule:’ServiceModule’ name=EString ’{’
37
38
39 ManagementModule returns TKRSPackage::ManagementModule:’ManagementModule’ name=EString ’{’
40
41
42 QueryModule returns TKRSPackage::QueryModule: ’QueryModule’ name=EString ’{’
43
44
45
46 TradingModule returns TKRSPackage::TradingModule:’TradingModule’ name=EString ’{’
47
48
49
50
51
52
53
54
55
56 ProcessingModule returns TKRSPackage::ProcessingModule:’ProcessingModule’ name=EString ’{’
57
58
59
60
61 Platform returns ImplementationRepositoryPackage::Platform:’Platform’ name=EString ’{’
62
63
64 IRModule returns ImplementationRepositoryPackage::Module: CompositeModule | SimpleModule;
65
66 CompositeModule returns ImplementationRepositoryPackage::CompositeModule:’CompositeModule’ name=EString ’{’
67
68
69
70
71
72
73
74
75
76
77 Statement returns Statement:’Statement ’{’
78
79
80
81
82 EString returns ecore::EString: STRING | ID;
83 EBoolean returns ecore::EBoolean: ’true’ | ’false’;

’uri’ uri=EString
hasSubmodule+=IRModule (hasSubmodule+=IRModule)*
(’hasPlatform’ hasPlatform=[ImplementationRepositoryPackage::Platform|EString])?
(’hasSuperModule’ hasSuperModule=[ImplementationRepositoryPackage::Module|EString])? ’}’;

’uri’ uri=EString
(’hasPlatform’ hasPlatform=[ImplementationRepositoryPackage::Platform|EString])?
(’hasSuperModule’ hasSuperModule=[ImplementationRepositoryPackage::Module|EString])? ’}’;

’hasTKRSModule’ hasTKRSModule=[TKRSPackage::Module|EString]
’hasImplementationRepositoryModule’ hasImplementationRepositoryModule=
[ImplementationRepositoryPackage::Module|EString] ’}’;

SimpleModule returns ImplementationRepositoryPackage::SimpleModule:’SimpleModule’ name=EString ’{’

hasModule+=IRModule (hasModule+=IRModule)* ’}’;

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

14

L. IRIBARNE ET AL.

ﬁles are declared with the metamodels used, and in the following lines, mapping between the text
and the model language is deﬁned. The input rule for the parser appears in line #8. This rule shows
that each Package entity begins with the reserved word Package followed by its name and the symbol
“{”. In continuation, this entity deﬁnes a clause so the architecture models and implementation
repository (PSM/M1 in Figure 1) can be imported, although an M2M transformation must be applied
to it before it can reference its elements from the conﬁguration model, and continue with deﬁnition
of all the elements in the three metamodels. It ends with the symbol “}”. As all the elements are
deﬁned the same way, one of them is given as a concrete example to make it easier to understand.
The rule deﬁned starting in line #23 shows that each Node forming part of the TKRS begins with the
reserved word Node followed by its name and the “{” symbol. Then its attributes are included with
another reserved word (such as ip, port, etc.), followed by the attribute value. In continuation, this
entity deﬁnes the modules that comprise it (with hasServiceModule, hasManagementModule, etc.,
relationships), referring to the system it operates in using the hasTKRS relationship, and ends with
the “}” symbol. The system conﬁguration models (PSM/M1) are created using an Eclipse editor.
The SOLERES-KRS conﬁguration model is shown in Section 4.3.

It is already possible to deploy the system in a real environment based on the conﬁguration
model. To show an example of how this process can be automated, an M2T transformation has been
implemented using the Eclipse Xpand tool, which enables the ﬁles necessary for a Java environment
to be generated from the model created with the DSL editor. Table V shows the transformation
template deﬁned. This template describes the mapping between each entity of the model and its
corresponding code. The sentence described starting in line #5 refers to the Package entity. This
deﬁnition generates a script ﬁle (make.sh) in line #8 containing operating system commands like
mkdir, cd or wget to create a folder structure containing the necessary ﬁles. Line #13 now
generates a Java ﬁle called “TKRS.java” for each system node which is placed in a folder that
receives its name from the value of the node attribute name, and which is, in turn, the subfolder of
another with the value of the system attribute name. The content of these ﬁles is stated starting in
line #14. The attributes (lines #20-#38), check whether the node has each of the modules deﬁned in
the TKRS to include the corresponding attribute (for example, the QueryModule is found in lines
#23-#29). The class constructor (lines #40-#60) is where the attributes deﬁned above are initialized,
etc. When the transformation has been executed, TKRS implementation is complete.

Once the TKRS framework has been described in terms of its (a) architecture, (b) modules of the
trading service, (c) ontologies for using lookup, register and admin interfaces, (d) structure of data
repository, and (e) conﬁguration mechanisms, is important to formally deﬁne all these elements of
the framework. Therefore, the following section provides the necessary deﬁnitions to describe the
different parts of our approach, and is complemented by some algebraic expressions which help in
such explanations.

3. FORMALIZATION

This section formally describes the TKRS infrastructure using Descriptive Logic (DL) expressions.
This notation allows us to deﬁne each of the parts and elements that must be taken into account to
deploy a system based on large volumes of data (Big Data management).

Deﬁnition 1 (TKRS). A TKRS system T is determined by two ﬁnite sets T = {HT , N }, where:
(a) HT represents a set of properties HT = {H1
T is the name of the system (name in
the conceptual model), and (b) N represents a set of nodes (Node) (N (cid:54)= ∅).

T }, where H1

Deﬁnition 2 (Node). A node N is in turn determined by another two ﬁnite sets N = {HN , M},
where these sets are deﬁned as follows:

- HN is a set of properties HN = {H1
N is an IP, H3

name, H2
conﬁguration and access to the repository (dbport).

N , · · · , Hl

N is a communications port, and H4

N } | l = {1, · · · , 4}, where: H1

N is the node
N is a secondary port for

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

15

Table V. M2T transformation template using Eclipse Xpand

«REM» ------------------------------------------------------------------------ «ENDREM»
«FILE "make.sh"»
#!/bin/bash
clear
«FOREACH this.hasStatement.first().hasISModule.hasNode.hasTKRS.hasNode AS node»

«REM» -------------------------------------------------------------------- «ENDREM»
«FILE node.hasTKRS.name + "/" + node.name + "/TKRS.java"»

import «node.hasTKRS.name».«node.name».modules.*;

«IF node==statement.hasTKRSModule.hasNode»

«IF statement.hasTKRSModule.metaType.name=="TKRSPackage::QueryModule"»

private QueryModule queryModule = null;

«IF node==statement.hasTKRSModule.hasNode»

«IF statement.hasTKRSModule.metaType.name=="TKRSPackage::TradingModule"»

private TradingModule tradingModule = null;

...
// the same for ServiceModule, ManagementModule and ProcessingModule

«ENDIF»
«ENDFOREACH»
«FOREACH this.hasStatement AS statement»

private String ip = null;
private int port = -1;
private int dbport = -1;
«FOREACH this.hasStatement AS statement»

«ENDIF»

«ENDIF»

public class TKRS {

«ENDIF»
«ENDFOREACH»

«IF !this.hasStatement.isEmpty»

package «node.hasTKRS.name».«node.name»;

«IMPORT org::xtext::tkrs::config::config»

1 «REM»
2
3 «ENDREM»
4
5 «DEFINE Package FOR ConfigurationPackage::Package»
6
7
8
9
10
11
12
13
14
15
16
17
18
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79 «ENDDEFINE»

«ENDIF»
«ENDFOREACH»

}
// CODE

public TKRS() {

«ENDIF»

«ENDIF»

«ENDIF»

}

«IF node==statement.hasTKRSModule.hasNode»

this.ip = "«node.ip»";
this.port = «node.port»;
this.dbport = «node.dbport»;
«FOREACH this.hasStatement AS statement»

«ENDIF»
«ENDFOREACH»
«FOREACH this.hasStatement AS statement»

«IF node==statement.hasTKRSModule.hasNode»

«IF statement.hasTKRSModule.metaType.name=="TKRSPackage::QueryModule"»

this.queryModule = new QueryModule();

«IF node==statement.hasTKRSModule.hasNode»

«IF statement.hasTKRSModule.metaType.name=="TKRSPackage::TradingModule"»

this.tradingModule = new TradingModule();

...
// the same for ServiceModule, ManagementModule and ProcessingModule

«ENDFILE»
«REM» -------------------------------------------------------------------- «ENDREM»
mkdir /«this.hasStatement.first().hasTKRSModule.hasNode.hasTKRS.name»/«node.name»/modules
cd /«this.hasStatement.first().hasTKRSModule.hasNode.hasTKRS.name»/«node.name»/modules
«FOREACH this.hasStatement AS statement»

wget «statement.hasImplementationRepositoryModule.uri»

«ENDIF»
«ENDFOREACH»
cd /«this.hasStatement.first().hasTKRSModule.hasNode.hasTKRS.name»/«node.name»
javac TKRS.java

«ENDFOREACH»
cd /
«ENDFILE»
«REM» ------------------------------------------------------------------------ «ENDREM»

- M is a set of modules (Module) M = {V, G, Q, I, E}, where: V is a ﬁnite set of service
modules V = {V1, · · · , Vo} | o = {1, · · · , n} (V (cid:54)= ∅), G is a ﬁnite set of management
modules G = {G1, · · · , Gp} | p = {1, · · · , n} (G (cid:54)= ∅), Q is a ﬁnite set of query modules

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

16

L. IRIBARNE ET AL.

Q = {Q1, · · · , Qq} | q = {1, · · · , n} (Q (cid:54)= ∅), I is a ﬁnite set of trading modules
I = {I1, · · · , Ir} | r = {1, · · · , n}, and E is a ﬁnite set of processing modules E =
{E1, · · · , Es} | s = {1, · · · , n}.

In the TKRS system T , it has to be given that I (cid:54)= ∅ and E (cid:54)= ∅, at least in one of its nodes.

Deﬁnition 3 (Service module). A service module Vn is identiﬁed by the property H1
V , which
represents the module name. The service module provides a series of services to the other modules,
including registering modules and components, verifying state, etc., as deﬁned below.

Deﬁnition 4 (Management module). A management module Gn is identiﬁed by the property H1
G,
which represents the module name. The management module acts as a hub for the user interface
and the rest of the modules, enabling their conﬁguration and being responsible for managing user
demands.

Deﬁnition 5 (Query module). A query module Qn is identiﬁed by the property H1
Q, which
represents the module name. The query module is concerned exclusively with the information
queries made by users.

I, · · · , Ht

I} | t = {1, · · · , 6}, and where: H1

Deﬁnition 6 (Trading module). A trading module In is deﬁned by the set of properties In =
{H1
I is a property that shows
whether the module implements the trading service’s Lookup interface, H3
I is a property which
shows whether or not the module implements the trading service’s mandatory Register interface,
H4
I is a property that shows whether the module implements the trading service’s Admin interface
or not, H5
I is a property which shows whether or not the module implements the trading service’s
Link interface, and H6
I is a property that shows whether or not the module implements the trading
service’s Proxy interface.

I is the module name, H2

The trading module enables search and location of system information, setting up a ﬁlter based

on the query parameters.

Deﬁnition 7 (Processing module). A processing module En is deﬁned by the pair of properties
En = {H1
E is the name of the ambient the module
belongs to, since processing modules can be grouped by different criteria, such as their location, the
information they manage, etc.

E is the module name, and H2

E }, where: H1

E , H2

The processing module is responsible for managing knowledge sources.

Deﬁnition 8 (Query Relationship). Given a query module Qn and a trading module In, the query
relationship RK is deﬁned as RK ⊆ Qn × In. Its purpose is to deﬁne the relationship between the
two modules for information queries.

Deﬁnition 9 (Register relationship). Given a processing module En and a trading module In, the
register relationship RG is deﬁned as RG ⊆ En × In. Its purpose consists of deﬁning the relationship
between the two modules for information management.

Deﬁnition 10 (Federation relationship). Given two trading modules In and Im (In (cid:54)= Im), the
federation relationship RF is deﬁned as RF ⊆ In × Im. Its purpose consists of deﬁning the
relationship between the two modules for the federation. The interfaces Link of the modules must
be active (linkInterface = true).

Deﬁnition 11 (Service/process ontologies). Service/process ontologies S are deﬁned as a ﬁnite set
S = {C, A, P}, where: C is a ﬁnite set of concepts, C = {c1, · · · , ci} | i = {1, · · · , n} , n ∈ N ; A is
a ﬁnite set of actions, A = {a1, · · · , aj} | j = {1, · · · , n} , n ∈ N ; and P is a ﬁnite set of predicates,
P = {p1, · · · , pk} | k = {1, · · · , n} , n ∈ N .

The service/process ontologies give the possible actions A that can be taken by means of each
trading service interface, the information C necessary to perform them and the result P when

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

17

completed (either a controlled exception during the action or else that it has been performed
satisfactorily).

Given a set of concepts Cn | Cn ⊂ C, a set of actions An | An ⊂ A and a set of predicates

Pn | Pn ⊂ P, then:

(i) Cn × An × Pn ⇒ Sn

where Sn is a concrete ontology of the ﬁve associated with the different trading service interfaces:
Lookup, Register, Admin, Link and Proxy.

A trader should have at least the functionality of the Lookup and Register interfaces, along
with their corresponding ontologies: the ﬁrst to enable documents stored in the repository to be
queried, and the second to manage these documents. The presence of the rest of the interfaces is not
obligatory: the Admin ontology would facilitate conﬁguration of trader parameters and policies (for
example, number of federated traders allowed, search policies, etc.); the Link ontology refers to how
the traders interconnect (federation process); and ﬁnally, the Proxy ontology models old properties
in trading federation systems.

The formalization of each of the ontologies related to the corresponding stand-alone trading

service model interface described in Section 2 is shown below.

Deﬁnition 12 (Lookup Ontology). Given the set of concepts CL, the set of actions AL and the
set of predicates PL, all of them referring to the Lookup ontology SL, this ontology is deﬁned as
CL × AL × PL ⇒ SL, where:

(i) CL = {C1

L} | i = {1, · · · , 4}, where: C1

L, · · · , Ci
L is a sequence of policies to be followed with the query (PolicySeq), C3

L is a query (QueryForm in the conceptual
L is a
L is a sequence with the percentage of coincidences of each

model), C2
sequence of results (OfferSeq), C4
result (OfferSeqMatch).
L}, where: A1
L, · · · , P k

(ii) AL = {A1
(iii) PL = {P 1

L is the action of consulting metadata (Query).

L} | k = {1, · · · , 7}, where: P 1

L is a controlled exception during
the actions of set AL (UnknownQueryForm, PolicyTypeMismatch, InvalidPolicyValue,
DuplicatePolicyName and QueryError, respectively); and P 6
L are actions AL
performed satisfactorily (EmptyOfferSeq and NotEmptyOfferSeq, respectively).

L and P 7

L, · · · , P 5

Deﬁnition 13 (Request relationship – Lookup ontology). Given the concepts C1
A1
(C1

L in the Lookup SL ontology, the relationship of request RL is deﬁned as RL ⊆ (C1
L × A1

L and C2

L × C2

L).

L, and action
L × A1
L) ∪

Deﬁnition 14 (Response relationship – Lookup ontology). Given an action A1
{1, · · · , 7} and concepts C3
L × P k
deﬁned as RL ⊆ (A1

L | k =
L in Lookup SL ontology, the relationship of response RL is
L × P k

L and C4
L) ∪ (A1

L, a predicate P k

L) ∪ (A1

L × P k

L × C3

L × C4

L × C3

L).

Deﬁnition 15 (Uses of the Lookup ontology). Given action A1
and concepts C3
uses:

L | k = {1, · · · , 7}
L in the Lookup SL ontology, the following conditions f (SL) hold true for its

L, a predicate P k

L and C4

f (SL) =






(A1
(A1
(A1

L × P k
L × P k
L × P k

L) ⇒ P k
L × C3
L × C3

L = P 1
L) ⇒ P k
L × C4

L ∨ P 2
L ∨ P 3
L = P 7
L
L = P 7
L) ⇒ P k
L

L ∨ P 4

L ∨ P 5

L ∨ P 6
L

(1)

Deﬁnition 16 (Register Ontology). Given the set of concepts CR, set of actions AR and set
of predicates PR, all of them referring to Register ontology SR, this ontology is deﬁned as
CR × AR × PR ⇒ SR, where:

(i) CR = {C1
model); C2

R}, where: C1

R, C2
R is the unique identiﬁer of a metadata document (OfferId).

R is the URI of a metadata document (Offer in the conceptual

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

18

L. IRIBARNE ET AL.

(ii) AR = {A1

R, · · · , Aj

R is the action of eliminating a metadata document (Withdraw); and A4

R} | j = {1, · · · , 4}, where: A1

R is the action of adding a metadata
R represents the action of modifying a metadata document (Modify);
R is the action of

document (Export); A2
A3
querying a metadata document (Describe).

(iii) PR = {P 1

R, · · · , P k

R} | k = {1, · · · , 11}, where: P 1

R are controlled exceptions
during set of actions AR (IllegalOffer, UnknownOffer, DuplicateOffer, IllegalOfferId,
respectively); P 7
UnknownOfferId and QueryError,
R show that actions AR
have been performed satisfactorily (Exported-Offer, WithdrawnOffer, DescribedOffer,
NotDescribedOffer and Modiﬁed-Offer, respectively).

R, · · · , P 11

R, · · · , P 6

Deﬁnition 17 (Request relationship – Register ontology). Given the concepts C1
actions A1
R × A1
(C1

R, and
R in Register ontology SR, the relationship of request RR is deﬁned as RR ⊆
R).

R, · · · , A4
R) ∪ (C2

R and C2

R) ∪ (C2

R) ∪ (C2

R × A3

R × A2

R × A4

R × C1

R × P k

Deﬁnition 18 (Response relationship – Register ontology). Given the actions A1
predicate P k
of response RR is deﬁned as RR ⊆ (A1
(A1
R) ∪ (A3

R, a
R in Register ontology SR, the relationship
R × P k
R) ∪
R × C1
R).

R | k = {1, · · · , 11} and concepts C1

R × P k
R × C2
R) ∪ (A4
Deﬁnition 19 (Uses of the Register ontology). Given actions A1
{1, · · · , 11} (deﬁned in Deﬁnition 16.iii) and concepts C1
following conditions f (SR) hold true for its uses:

R, a predicate P k
R | k =
R in Register ontology SR,the

R) ∪ (A3
R × P k
R, · · · , A4

R) ∪ (A2
R × C1

R × P k
R × P k

R, · · · , A4

R and C2

R) ∪ (A4

R) ∪ (A2

R and C2

R × P k

R × P k

R × C2



f (SR) =

R = P 4
R = P 4
R = P 4
R = P 6
R) ⇒ P k
R) ⇒ P k
R) ⇒ P k
R) ⇒ P k
Deﬁnition 20 (Admin Ontology). Given set of concepts CA, set of actions AA and set of predicates
PA, all referring to Admin SA, this ontology is deﬁned as CA × AA × PA ⇒ SA, where:

R ∨ P 3
R ∨ P 2
R
R ∨ P 5
R ∨ P 2
R ∨ P 1
R ∨ P 5
R
R ∨ P 10
R ∨ P 4
R
R = P 7
R
R = P 11
R
R = P 8
R
R = P 9
R

R) ⇒ P k
R) ⇒ P k
R) ⇒ P k
R) ⇒ P k
R × C2
R × C2
R × C1
R × C1

R × P k
R × P k
R × P k
R × P k
R × P k
R × P k
R × P k
R × P k

(A1
(A2
(A3
(A4
(A1
(A2
(A3
(A4




R ∨ P 3
R

(2)

(ii) AA = {A1

(i) CA = {C1

A, C2

A, C3

A}, where: C1
(Def_search_card in the conceptual model); C2
located in a search (Max_search_card); C3
documents used by the trading service (Offer_repos).

A is the default number of documents to be located in a search
A is the maximum number of documents to be
A is the URI of the repository with the metadata

A, · · · , Aj

A} | j = {1, · · · , 6}, where: A1

A is the action of setting the default number
of documents to be located in a search (SetDef_search_card); A2
A is the action of setting the
maximum number of documents to be located in a search (SetMax_search_card); A3
A is the
action of setting the URI of the repository with the metadata documents used by the trading
service (SetOffer_repos); A4
A is the action of returning the default number of documents to
be located in a search (GetDef_search_card); A5
A is the action of returning the maximum
number of documents to be located in a search (GetMax_search_card); and A6
A is the action
of returning the URI of the repository with the metadata documents used by the trading service
(GetOffer_repos).

(iii) PA = {P 1

A, · · · , P k

A} | k = {1, · · · , 7}, where: P 1

A is a controlled exception during the
actions in set AA (InvalidValue); P 2
A, · · · , P 7
A are actions AA performed satisfacto-
rily (ModiﬁedDef_search_card, ModiﬁedMax_search_card, ModiﬁedOffer_repos, Returned-
Def_search_card, ReturnedMax_search_card and ReturnedOffer_repos, respectively).

Deﬁnition 21 (Request relationship – Admin ontology). Given concepts C1
A1
(C1

A, and actions
A in the Admin ontology SA, the relationship of request RA is deﬁned as RA ⊆
A) ∪ (A5

A, · · · , A6
A × A1

A, · · · , C3

A) ∪ (A4

A) ∪ (A6

A) ∪ (C2

A) ∪ (C3

A × A2

A × A3

A × C2

A × C1

A × C3

A).

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

19

A, · · · , C3

A | k = {1, · · · , 7} and concepts C1

Deﬁnition 22 (Response relationship – Admin ontology). Given actions A1
P k
RA is deﬁned as RA ⊆ (A1
A) ∪ (A5
A) ∪ (A2
A × P k
A × P k
C1
Deﬁnition 23 (Uses of the Admin ontology). Given actions A1
{1, · · · , 7} and concepts C1
A, · · · , C3
hold true for its uses:

A, a predicate
A in Admin ontology SA, the relationship of response
A × P k
A ×
A × P k
A).
A, · · · , A6

A | k =
A in the Admin ontology SA, the following conditions f (SA)

A, a predicate P k

A, · · · , A6

A) ∪ (A4

A) ∪ (A2

A) ∪ (A6

A) ∪ (A1

A) ∪ (A3

A × P k

A × P k

A × P k

A × P k

A × C2

A × C1

A × C3

A × C2

A × C3

f (SA) =






(A1
(A2
(A3
(A4
(A5
(A6
(A1
(A2

A × P k
A × P k
A × P k
A × P k
A × P k
A × P k
A × P k
A × P k

A × C1
A × C2
A × C3
A × C1
A × C2
A × C3
A) ⇒ P k
A) ⇒ P k

A = P 2
A) ⇒ P k
A
A = P 3
A) ⇒ P k
A
A = P 4
A) ⇒ P k
A
A = P 5
A) ⇒ P k
A
A = P 6
A) ⇒ P k
A
A) ⇒ P k
A = P 7
A
A = P 1
A
A = P 1
A

(3)

Deﬁnition 24 (Platform). A platform is determined by the pair L = {HL, W}, where:

(i) HL is the property H1
L which gives the name of the platform (name).
(ii) W is a set of module implementations (Module) W = {X , Y} (W (cid:54)= ∅), where: X is a ﬁnite
set of composite module implementations in which X = {X1, · · · , Xu} | u = {1, · · · , n}; and
Y is a ﬁnite set of simple module implementations Y = {Y1, · · · , Yv} | v = {1, · · · , n}.

Deﬁnition 25 (Composite module implementation). An implementation of a composite module Xu
is deﬁned in turn by three ﬁnite sets Xu = {HX , X , Y}, where:

(i) HX is the pair of properties HX = {H1

implementation (name); and H2

X }, where: H1
X is the location of the implementation ﬁles (uri).

X , H2

X is the name of the module

(ii) X is a ﬁnite set of implementations of composite modules X = {X1, · · · , Xu} | u =

{1, · · · , n}.

(iii) Y is a ﬁnite set of simple implementation modules Y = {Y1, · · · , Yv} | v = {1, · · · , n}.

Deﬁnition 26 (Simple module implementation). An implementation of a simple module
(SimpleModule in the conceptual model) Yv is deﬁned by a ﬁnite set Yv = {HY }, where: HY is
a set of properties HY = {H1
Y is the name of the implementation module
(name); and H2

Y is the location of the implementation ﬁles (uri).

Y }, and where: H1

Y , H2

Deﬁnition 27 (Platform relationship). Given an implementation of a composite module Xu or
of a simple module Yv, and a platform L, the relationship of platform RP is deﬁned as RP ⊆
(L × Xu) ∨ (L × Yv). Its purpose is to deﬁne the relationship of an implementation belonging to a
platform.

Deﬁnition 28 (Containment relationship of ). Given a composite module implementation Xu and
a simple module implementation Yv or another implementation of a composite module Xu(cid:48), the
relationship of containment RC is deﬁned as: RC ⊆ (Xu × Yv) ∨ (Xu × Xu(cid:48)). Its purpose is to
deﬁne the relationship of containment between two module implementations.

Deﬁnition 29 (Conﬁguration). A conﬁguration F is determined by a ﬁnite set F = {Z}, where: Z
is the set of statements with the implementation relationships (Z (cid:54)= ∅).

Deﬁnition 30 (Implementation relationship). Given a module Mn and the implementation of this
module Wn, the relationship of implementation RI is deﬁned as RI ⊆ Mn × Wn. Its purpose
consists of deﬁning the relationship between a module and its corresponding implementation.

The framework deﬁned above is difﬁcult to understand without explaining its behavior when
it is applied to a domain or example scenario. For this reason, the following section is intended
to illustrate a case study of an information systems which has been successfully designed and
developed based our proposal.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

20

L. IRIBARNE ET AL.

4. CASE STUDY: SOLERES-KRS

This section presents a case study for application of the TKRS framework in Environmental
Management Information Systems (EMIS), in which large volumes of environmental data are
usually used. Some environmental authorities, organizations or institutions use ecological maps
for their evaluation of environmental impact, territorial management, monitoring impact of certain
activities on protected spaces, etc. The cost of making these ecological maps is very high, because
they are based on ﬁeldwork and periodic updating (yearly). However, in some environmental
management actions, where studies of the current situation in the territory are needed (for example,
evaluation of growth of greenhouses in eastern Almería Province), these ecological maps do not
provide the updated environmental information required for decision-making, and new ﬁeldwork
is necessary. This environmental information is not available in other spatial information sources,
such as satellite (or ﬂight) images, which is much faster (daily) and more economical to acquire.

Prior studies have explored the possibility and feasibility of establishing a correlation between
environmental variables (cartography) used in making ecological maps and the information
from satellite images (correlation ﬁnally demonstrated) that would enable them to be acquired
automatically, much faster and at a much lower economic and human cost. To do this, an ecological
map is acquired based on a map or a set of cartographic maps of the study area, and by sectorization
(which receives another further series of inputs). Then, based on a satellite image or set of images
of the same zone, by classiﬁcation (which also receives another series of inputs), a classiﬁed image
is acquired. Once the ecological map has been made and the image has been classiﬁed, a neural
network correlates them.

All the information used during the above processes must somehow be stored and managed.
Therefore, another study consisted of developing an information management and usage system
(in this case environmental) to assist human-computer interaction (HCI) with user interfaces that
adapt to user proﬁle habits [33, 34, 19], and with intelligent software agents that mediate for users
in information search and usage. Thus, decision-making and prediction/prevention tasks (which are
addressed in the majority of the EMIS and GIS) are facilitated.

This system, called SOLERES, can be observed in Figure 12. It is in turn made up of two
subsystems, (1) the Knowledge Representation System (SOLERES-KRS or SKRS), responsible

Figure 12. SOLERES system Architecture

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

External repositories of environmental information<<Repository>>Cartographic mapsSOLERES-KRS<<Repository>>Satellite imagesSOLERES-HCIEPU<<Agent>>ProcessingTrading<<Agent>>Trading<<Repository>>EIM<<Repository>>EID (local)<<Repository>>EID (global)Management<<Agent>>ManagementQuery<<Agent>>QueryServices<<Agent>>Service<<use>><<use>><<generate>><<generate>>client sideserver sideMODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

21

for environmental information management, and (2) SOLERES-HCI [31, 5], related to the user
interfaces that assist in making use of this information. This section concentrates exclusively on
the development of the SOLERES-KRS following the design of TKRS system framework. The
information domain which the SOLERES-KRS manages is basically two large, bulky sources of
original information: (a) cartographic information, and (b) information from satellite images of the
study area (regions in southeast Spain). Given the volume of information, and that it can come from
different sources, a distributed solution was chosen in which the information is distributed into units
or areas called Environmental Process Units (EPU in Figure 12), which work with the metadata
found from it, i.e., the Environmental Information Maps (EIM). The Trading modules have a dual
function: (i) integrating the information from the different EPUs and (ii) facilitating its search and
retrieval. As mentioned in Section 2.3, trading modules use new meta-metadata based on from the
EIMs, which are stored locally in a repository (also generated by the EPUs, and therefore, a copy
is stored in another local repository). These “meta-metadata” are called Environmental Information
metaData (EID). The modules mentioned, along with Query, Management and Services, which
appear in Figure 12, make up the TKRS architecture. EID and EIM documents form the speciﬁc kind
of information managed by the TKRS framework in this case study. Therefore, the implementation
of the operations linked to the database storing the information must be modiﬁed according to its
structure if the TKRS framework is applied to other domains.

Finally, it should be emphasized that each system user would receive support from a SOLERES-
HCI agent which would manage presentation and interaction with the user interface, mediating
between the user it represents and other users in the system by means of their respective agents, and
also managing environmental queries, like a virtual consultant or advisor who interacts with other
SOLERES-KRS subsystem agents.

4.1. Design of the system architecture

Brieﬂy, the TKRS architecture described in Section 2 is made up of a set of nodes, each of
which consists in turn of a series of modules: services, management, query, trading and processing
modules. These modules are required or not by the nodes. Keeping this architecture model in mind,
the choice of agent technology for implementation of the SOLERES-KRS and its characteristics as
described, the general system architecture would be deﬁned as shown in Figure 13 [32, 20] (this
diagram does not include agents related to the service module).

Figure 13. SOLERES-KRS general architecture

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

Interface Agent #1 Management Agent Query Agent #1 Trading Agent #1 Processing Agent #1 Interface Agent #n Query Agent #n Trading Agent #n Processing Agent #n ............Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Admin Ont.Admin Ont.Register Ont.Register Ont.EIM #1EIM #nEID #nEID #nEID #1EID #1Node #1Interface Agent #1 Management Agent Query Agent #1 Trading Agent #1 Processing Agent #1 Interface Agent #n Query Agent #n Trading Agent #n Processing Agent #n ............Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Lookup Ont.Admin Ont.Admin Ont.Register Ont.Register Ont.EIM #1EIM #nEID #nEID #nEID #1EID #1Node #nLookup Ont.HCIHCIKRSKRS22

L. IRIBARNE ET AL.

The management module is implemented with a Management Agent, which acts as a mediator
between the SOLERES-HCI Interface Agents and the rest of the SOLERES-KRS agents to manage
all the user demands. The query module, with a Query Agent, solves the ecological information
queries directly, the trading module facilitates search and location of this information using the EIDs
stored in its repository using a Trading Agent, and the processing module, with a Processing Agent,
which represents the EPUs, is responsible for the knowledge sources (management of EIMs, export
of EIDs to the associated trading agent, etc.). There are a series of agents in the service module
typical of the development environment used (JADE), such as the Agent Management System
(AMS) or the Directory Facilitator (DF), which provides a white pages service for managing all
the agents, and another yellow pages service.

Figure 14 does show the concrete SOLERES-KRS architecture model that was constructed using
the TKRS architecturel metamodel of Section 2. This model has been designed using the GMF editor
mentioned above, which allows us to build models conforming the metamodel shown in Figure 2.
As observed, the system is made up of three nodes, each of which has a management agent (which
make up the TKRS management module), a query agent (query module) and agents corresponding
to the obligatory service module. “Node 1” and “Node 2’ also contain a trading agent (trading
module) and, additionally, “Node 1” is made up of a processing agent (processing module, EPU),
meeting the minimum TKRS demands. The trading agents in the above nodes are federated (shown
with a dashed arrow) and their query agents are associated with the trading agents in their respective
nodes, while the processing agent in “Node 1” and the query agent in “Node 3” are associated with
the trading agent in “Node 2” (all of these associations are shown with continuous arrows).

4.2. Implementation based on a Multi-Agent System

The selection of the Multi-Agent System (MAS) technology for implementing the TKRS was
determined by the characteristics of software agents (autonomy, persistence, sociability, reactivity,
pro-activity, intelligence, etc.). Basically, as shown in the section above and the conceptual model in
Figure 15, each of the system modules can be implemented by an agent or set of agents. However,
in the service module, a specialized agent can be created for each type of service. For example,
there may be an ontology agent for managing ontologies, so when any system agent needs to send a
message to another agent making use of one of the service/process ontologies or needs to manage a
metadata or meta-metadata register, to avoid having to specialize in these tasks, it uses an ontology
agent. Figure 16 shows the model of a repository (PIM/M1) with TKRS implementation based

Figure 14. SOLERES-KRS architecture model made up of three nodes and represented using the GMF tool

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

Node1: query, trading and processingfunctionalityNode2: queryand trading functionalityNode3: queryfunctionalityfederationof trading modulesassociationbetweenmodulesMODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

23

Figure 15. Conceptual model of a TKRS implementation based on MAS

Figure 16. Repository model using Eclipse Reﬂective Ecore Model Editor

on MAS as described for a Java environment, using the reﬂective ecore model editor. The top
of this ﬁgure shows how each of the system modules is implemented as a simple module, while
the bottom shows management module implementation properties: their name, location and the
platform developed in.

It was already advanced in Section 4, that SOLERES-KRS was going to be made up of a set of
distributed EPUs (working independently in system knowledge management), the Environmental
Information Maps (EIM) and their corresponding Environmental Information metaData (EID).
Cooperation among them was achieved by developing a trading service based on the OntoTrader
speciﬁcation and implemented with trading agents (or traders). These agents act as mediators
(although indirectly) between the SOLERES-HCI interface agents and the EPU processing agents
(exporters) to satisfy user information demands. For each trading agent to be able to perform its
information search task, each EPU exports its EIDs to the trading agent with which it is associated,
so it has an overall repository in which the EIDs of all the EPUs associated with it are stored.
The query agents have an importer role, and their function is to ﬁnd the information demanded
by the users by means of the trading agent, either with the meta-metadata it stores or else with
metadata ﬁltered by the trading agent and stored by the processing agents. The management agent
is the trading service administrator, which deﬁnes, administers and veriﬁes that the service rules are
complied with. This agent is also the direct mediator with SOLERES-HCI and controls the rest of
the subsystem environment by planning the tasks performed.

The three service/process ontologies speciﬁed in Section 2 were implemented to deﬁne the
protocols for behavior and interaction with trading agents through their interfaces, and by extension,
with any other system agent [7]. When one agent needs another to perform a speciﬁc action, it
constructs a message in which the action is described using one of these ontologies and sends it to the
second agent. This one receives the message, extracts the ontology content, performs the appropriate
action and uses the same ontology to show the result of the action to the ﬁrst. This process is repeated
for the various actions in which more than one agent intervene. Table VI gives the deﬁnition of the
Lookup ontology in OWL/XML notation, where there are three main classes, Concept, Action and
Predicate, from which the rest inherit. For example, QueryForm is a subclass of Concept, Query

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

PlatformOntologyAgentManagementAgentTradingAgentQueryAgentProcessingAgent<<Interface>>ServiceModule<<Interface>>ManagementModule<<Interface>>TradingModule<<Interface>>ProcessingModule<<Interface>>QueryModule24

L. IRIBARNE ET AL.

Table VI. Deﬁnition of the Lookup ontology in OWL/XML

xmlns:owl = "&owl;" xmlns:rdf = "&rdf;" xmlns:rdfs = "&rdfs;" xmlns:xsd = "&xsd;">

<!ENTITY lookup "http://www.ual.es/acg/ont/TKRS/LookupOntology.owl#">
<!ENTITY owl "http://www.w3.org/2002/07/owl#">
<!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#">
<!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"> ]>

<owl:Ontology rdf:about="&lookup;"><rdfs:label>Lookup Ontology</rdfs:label></owl:Ontology>
<owl:Class rdf:ID="Concept"/>
<owl:Class rdf:ID="Action"/>
<owl:Class rdf:ID="Predicate"/>
<owl:Class rdf:ID="QueryForm"><rdfs:subClassOf rdf:resource="#Concept"/></owl:Class>
<owl:FunctionalProperty rdf:ID="queryFormURI">

01 <?xml version="1.0"?>
02
03 <!DOCTYPE rdf:RDF [
04
05
06
07
08
09
10 <rdf:RDF xml:base = "&lookup;" xmlns = "&lookup;" xmlns:lookup = "&lookup;"
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</owl:FunctionalProperty>
27
<owl:Class rdf:about="#Query"><rdfs:subClassOf rdf:resource="#Action"/></owl:Class>
28
<owl:Class rdf:ID="QueryError"><rdfs:subClassOf rdf:resource="#Predicate"/></owl:Class>
30
<owl:Class rdf:ID="EmptyOfferSeq"><rdfs:subClassOf rdf:resource="#Predicate"/></owl:Class>
31
<owl:Class rdf:ID="NotEmptyOfferSeq"><rdfs:subClassOf rdf:resource="#Predicate"/></owl:Class>
32
33
...
34 </rdf:RDF>

</owl:FunctionalProperty>
<owl:Class rdf:ID="OfferSeq"><rdfs:subClassOf rdf:resource="#Concept"/></owl:Class>
<owl:FunctionalProperty rdf:ID="offerSeqURI">

<rdf:type rdf:resource="&owl;DatatypeProperty"/>
<rdfs:domain rdf:resource="#OfferSeq"/>
<rdfs:range rdf:resource="&xsd;string"/>

<rdf:type rdf:resource="&owl;DatatypeProperty"/>
<rdfs:domain rdf:resource="#QueryForm"/>
<rdfs:range rdf:resource="&xsd;string"/>

of Action and QuerryError of Predicate. The type, domain and range are deﬁned for each of the
concept properties. Thus the domain of the queryFormURI property is the DatatypeProperty type
and its range is the data string type.

4.3. System conﬁguration

Brieﬂy reviewing the TKRS framework [6], when the system architecture and the implementation
repository model have been deﬁned using the system conﬁguration model and a series of M2M and
M2T transformations, it can be deployed in a given environment. This is precisely what has been
done below. The SOLERES-KRS architecture model and the agent-based TKRS implementation
repository model were deﬁned in the two sections above, respectively. For their elements to be
referenced by the conﬁguration model, each was transformed by a M2M operation, resulting in the
new representation which appears in Tables VII and VIII. The generated models are based on the
grammar developed in Section 2.3.

In Table VII, which shows the architecture model, note that the TKRS entity is followed by the
system name, SOLERES-KRS, and contains three Node entities corresponding to its three nodes
(lines #3 to #28, #29 to #48 and #49 to #60, respectively). Each of them is followed by the name of
the node (for example, the ﬁrst, Node_1) and in parentheses the attributes (ip, port, etc.) followed
by their value (in the case of the ip address of Node_1, “192.168.1.11”). Then, modules include
their type (ServiceModule, ManagementModule, etc.) followed by their name (ServiceModule_1_1,
ManagementModule_1_1, etc.). The corresponding attributes are also deﬁned in parentheses (those
modules which have them), and the node it belongs to is given by the relationship hasNode. Finally,
each node refers to the system in which it operates through the relationship hasTKRS. Similarly,
Table VIII shows the repository model, where for the Java_JADE platform, ﬁve SimpleModules are
speciﬁed (lines #5 to #24), each followed by its name (for example, the ﬁrst, ServiceModuleImpl)
and they deﬁne the attribute uri (“http//.../acg/rep/TKRS/ServiceModule.class”), as well as the
platform to which it belongs (“Java_JADE”) through the relationship hasPlatform.

The SOLERES-KRS conﬁguration model can now ﬁnally be deﬁned (Table IX), where by
means of a set of sentences (Statements), the models that form part of each system node are
associated with their corresponding implementation in the repository (following the PIM/PSM

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

25

Table VII. SOLERES-KRS architecture model expressed using the grammar deﬁned

01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61

Package SOLERES
TKRS SOLERES_KRS {
Node Node_1 {

ip "192.168.1.11"
port "1099"
dbport "3306"
ServiceModule ServiceModule_1_1 { hasNode Node_1 }
ManagementModule ManagementModule_1_1 { hasNode Node_1 }
QueryModule QueryModule_1_1 {

usesLookupInterface TradingModule_1_1
hasNode Node_1

}
TradingModule TradingModule_1_1 {

usesLookupInterface true
usesRegisterInterface true
usesAdminInterface false
usesLinkInterface true
usesProxyInterface false
isFederatedWith "Node_2.TradingModule_2_1"
hasNode Node_1

}
ProcessingModule ProcessingModule_1_1 {

ambient Ambient_1
usesRegisterInterface "Node_2.TradingModule_2_1"
hasNode Node_1

}
hasTKRS SOLERES_KRS

}
Node Node_2 {

ip "192.168.1.12"
port "1099"
dbport "3306"
ServiceModule ServiceModule_2_1 { hasNode Node_2 }
ManagementModule ManagementModule_2_1 { hasNode Node_2 }
QueryModule QueryModule_2_1 {

usesLookupInterface TradingModule_2_1
hasNode Node_2

}
TradingModule TradingModule_2_1 {

usesLookupInterface true
usesRegisterInterface true
usesAdminInterface false
usesLinkInterface true
usesProxyInterface false
hasNode Node_2

}
hasTKRS SOLERES_KRS

}
Node Node_3 {

ip "192.168.1.13"
port "1099"
dbport "3306"
ServiceModule ServiceModule_3_1 { hasNode Node_3 }
ManagementModule ManagementModule_3_1 { hasNode Node_3 }
QueryModule QueryModule_3_1 {

usesLookupInterface "Node_2.TradingModule_2_1"
hasNode Node_3

}
hasTKRS SOLERES_KRS

}

}

architecture deﬁned). For example, the ﬁrst of them (lines #4 to #6) is associated with the
SOLERES.KRS.Node_1.ServiceModule_1_1 in the architecture by means of the hasTKRSModule
relationship with the ACG_Repository.Java_JADE.ServiceModuleImpl implementation (by the
relationship hasImplementationRepositoryModule) and so on.

Finally, the code for deploying the system in a real environment is obtained based on the
deﬁnition of this conﬁguration model and the M2T transformation, presented in Subsection 2.3. This
transformation generates several ﬁles: a script ﬁle (see Table X) with operating system commands
such as mkdir, cd and wget to create a folder structure that includes the system implementation
ﬁles, and for compiling (javac TKRS.java), and there is a set of Java ﬁles (one for each node in
the system) located in the corresponding structure folder. In this ﬁles, conﬁguration and initialization
operations (in the class constructor) of all its parameters (class attributes) are performed based on
the speciﬁc values in the architecture design.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

26

L. IRIBARNE ET AL.

Table VIII. TKRS repository model expressed using the grammar deﬁned

01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Package UAL_Repository

ImplementationRepository {

Platform Java_JADE {

SimpleModule ServiceModuleImpl {

uri "http://.../acg/rep/TKRS/ServiceModule.class"
hasPlatform Java_JADE

}
SimpleModule ManagementModuleImpl {

uri "http://.../acg/rep/TKRS/ManagementModule.class"
hasPlatform Java_JADE

}
SimpleModule QueryModuleImpl {

uri "http://.../acg/rep/TKRS/QueryModule.class"
hasPlatform Java_JADE

}
SimpleModule TradingModuleImpl {

uri "http://.../acg/rep/TKRS/TradingModule.class"
hasPlatform Java_JADE

}
SimpleModule ProcessingModuleImpl {

uri "http://.../acg/rep/TKRS/ProcessingModule.class"
hasPlatform Java_JADE

}

}

}

Table IX. SOLERES-KRS conﬁguration model expressed using the grammar deﬁned

01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40

Package SOLERES_Configuration

Configuration {
Statement {

hasTKRSModule "SOLERES.KRS.Node_1.ServiceModule_1_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ServiceModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_1.ManagementModule_1_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ManagementModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_1.QueryModule_1_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.QueryModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_1.TradingModule_1_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.TradingModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_1.ProcessingModule_1_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ProcessingModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_2.ServiceModule_2_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ServiceModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_2.ManagementModule_2_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ManagementModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_2.QueryModule_2_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.QueryModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_2.TradingModule_2_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.TradingModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_3.ServiceModule_3_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ServiceModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_3.ManagementModule_3_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.ManagementModuleImpl" }

Statement {

hasTKRSModule "SOLERES.KRS.Node_3.QueryModule_3_1"
hasImplementationRepositoryModule "ACG_Repository.Java_JADE.QueryModuleImpl" }

}

Figure 17 shows the content of one of these Java ﬁles, which corresponds to the implementation
of the corresponding node deﬁned in Figure 14 (extracted from it and placed next to this
table for the explanation). It shows the TKRS class speciﬁcation, which forms part of the
SOLERES_KRS.Node_1 (line #1) package, where Node 1 of the SOLERES-KRS is conﬁgured.
The classes that implement the different TKRS modules are imported in line #3. The attributes

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

27

Table X. Script ﬁle for SOLERES-KRS deployment

01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

#!/bin/bash
clear
mkdir /SOLERES_KRS/Node_1/modules
cd /SOLERES_KRS/Node_1/modules
wget http://.../acg/rep/TKRS/ServiceModule.class
wget http://.../acg/rep/TKRS/ManagementModule.class
wget http://.../acg/rep/TKRS/TradingModule.class
wget http://.../acg/rep/TKRS/QueryModule.class
wget http://.../acg/rep/TKRS/ProcessingModule.class
cd /SOLERES_KRS/Node_1
javac TKRS.java
mkdir /SOLERES_KRS/Node_2/modules
cd /SOLERES_KRS/Node_2/modules
wget http://.../acg/rep/TKRS/ServiceModule.class
wget http://.../acg/rep/TKRS/ManagementModule.class
wget http://.../acg/rep/TKRS/TradingModule.class
wget http://.../acg/rep/TKRS/QueryModule.class
cd /SOLERES_KRS/Node_2
javac TKRS.java
mkdir /SOLERES_KRS/Node_3/modules
cd /SOLERES_KRS/Node_3/modules
wget http://.../acg/rep/TKRS/ServiceModule.class
wget http://.../acg/rep/TKRS/ManagementModule.class
wget http://.../acg/rep/TKRS/QueryModule.class
cd /SOLERES_KRS/Node_3
javac TKRS.java
cd /

private String ip = null;
private int port = -1;
private int dbport = -1;
private ServiceModule serviceModule = null;

private ManagementModule managementModule = null;
private QueryModule queryModule = null;
private TradingModule tradingModule = null;
private ProcessingModule processingModule = null;

1 package SOLERES_KRS.Node_1;
2
3 import SOLERES_KRS.Node_1.modules.*;
4
5 public class TKRS {
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27 }

}
// CODE

public TKRS() {

this.ip = "192.168.1.11";
this.port = 1099;
this.dbport = 3306;
this.serviceModule = new ServiceModule();
this.managementModule = new ManagementModule();
this.queryModule = new QueryModule();
this.tradingModule = new TradingModule();
this.processingModule = new ProcessingModule();
// CODE

Figure 17. Java ﬁle for conﬁguration of SOLERES-KRS Node 1

are stated in lines #6-#13 and among them are both node properties (ip, port, etc.), and the TKRS
modules it includes (in this case, all). In the class constructor (lines #15-#25), the above attributes
are initialized with the values shown by means of the graphics tool, etc. This is repeated for Nodes
2 and 3 of the system architecture.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

28

L. IRIBARNE ET AL.

5. RELATED WORK

As mentioned above, one of the biggest challenges of the Information Society consists of addressing
the continuous growth of the information volume handled in most areas, but not only its collection
or storage, but also its processing and analysis. The concept of Big Data arises around this kind
of operations. In [44], the author writes about its origin and presents its relation with the data
processing platforms. Meanwhile, in [38], a review is performed presenting the four main challenges
(known as the four Vs) of Gartner (increasing Volume of data, increasing Velocity, increasing
Variety of data types and structures, and increasing Variability of data), and the authors propose
the ﬁfth V of Big Data, the Value, in order to improve decision-making operations. [59] focuses on
the challenge of transforming big data into smart data by using metadata (in the form of ontologies,
domain models, or vocabularies), and employing semantics and intelligent processing mechanisms.
[36] also reviews the ﬁve Vs of Big Data, as well as the technologies used for its management.
Frequently, the information managed is unstructured and does not follow any model; in contrast,
we propose an approach based on MDE techniques thus facilitating structured representation and
management. [8] focuses on the analysis of this type of information and shows the Apache Hadoop
Project and MapReduce as an approximation. In [40] the authors also discuss the evolution of the
Big Data computing, its taxonomy, the technologies, etc., but they progress and integrate it with
the concept of cloud. The proposal presented in this paper is based on an Ontological Web-Trading
Model, as another approach to support the Vs of the Big Data mentioned above.

There are not really many studies related to the framework for design and development of
Web-based Information Management Systems that use trading and ontologies as the solution
for handling Big Data. The characteristics of most of the trading services in the literature
[10, 52, 41, 11, 47, 54, 57] are similar, because they are all based on the ODP [37] trading model
(also standardized by the OMG). One of the studies in this area that seems to differ from the rest is
WebTrader [64], a study that presents a trading model for developing Internet-based software and
uses XML to describe component services. The Pilarcos Project, a research project of the TEKES
National Technology Agency of Finland, Helsinki University Computer Science Department and
Nokia, SysOpen and Tellabs should also be mentioned. It defends, among other characteristics, the
need for a trading service based on ODP/OMG for developing middleware solutions with automatic
management of federated applications. The main drawback of these proposals is the use of only
component speciﬁcations.

There are also ODP trading service implementation approaches that differ in their interaction
and communication among objects or components, or description of the communication language.
For example, in [18], the authors present a trading service called DOKTrader, which acts on a
federated database system, the Distributed Object Kernel (DOK). Another example may be found
in [46], in which a framework for developing distributed applications in a Common Open Service
Market (COSM) is created, making use of a Service Interface Description Language (SIDL) to
describe the services managed by the trader. [42] present a web market service driven by ontologies.
In this system, an ontological communication language is used for representing queries, offers
and agreements. In [63], an ontology is also used to describe and facilitate Dynamic Process
Collaboration (DPC). The OntoTrader model which our TKRS framework uses, attempts to provide
a trading service promoting both interoperability of objects or web components in open distributed
systems, and improve search and retrieval of the information in them. This model not only enables
information management in any application domain, but also the speciﬁcations of the services
offered by the components, and sets a common standard for communication with the trading service
through its various interfaces. To do this it makes use of a series of ontologies, more speciﬁcally, a
data ontology and a service/process ontology for each of these interfaces.

There are many independent examples of ontology application in systems where information
semantics are fundamental. For example, in [15], the authors present an environmental decision
support system called OntoWEDSS, where an ontology is used to model wastewater treatment,
providing a common vocabulary and explicit conceptualization. Another example may be found
in [22], where an air quality monitoring system uses an ontology to deﬁne messages and

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

29

communication actions concisely and without ambiguities. In [14], the authors present Ecolingua, an
EngMath family ontology, for representing quantitative ecological data. All these examples show
the use of ontologies for constructing models that describe the entities in a given domain and to
characterize their associated relationships and restrictions. In [70], the authors present an ontology
for representing geographic data and related functions. To satisfy the need for an interoperable
GIS, in [4], the authors propose the design of a geo-ontology model for integrating geographic
information. Application of ontologies has also been explored in the ﬁeld of geographic information
retrieval [60]. A different use appears in [29], where an OWL extension has new primitives for
modeling locations and spatial relationships with a geographic ontology. Extensions of existing
ontologies have also appeared in this knowledge domain. Thus in [58], the authors propose a
geographic ontology based on GML (Geography Markup Language) [49] and extends the OWL-
S proﬁle to geographic proﬁles. Another case is an extension of the NASA SWEET (Semantic
Web for Earth and Environmental Terminology) ontology, which includes part of the hydrogeology
domain [62].

As observed, an object-oriented approach has been used for modeling the different ontologies,
selecting two representations, one visual with UML and the other textual with OWL. In the
literature, there are many studies of environmental modeling which also make use of this approach
(some of them are summarized in Table XI). Some researchers suggest the use of UML as a
language for geographical representation of ontological modeling [17, 26, 39], showing it to be
a resource for information exchange among specialists that is easy to read and interpret. In some
cases, the UML models need to be transformed into ontological representations using speciﬁc model
transformation tools. In [27], the author deﬁnes XSLT transformations to construct an ontology
in XMI format based on a logic model in UML. Another example of model transformation is
OUP (Ontology UML Proﬁle) [23], which enables ODM/MDA standards to be used. XSLT is also
used to transform OUP ontologies into OWL. In [28], the authors generate GML models from
conceptual UML models which comply with the ISO 19118 standard. ONTOMET [13] is a UML-
based framework for geospatial information communities which provides a ﬂexible environment and
enable interoperation of formal metadata speciﬁcations, domain vocabularies and extensions. GSIP
(GEOINT Structure Implementation Proﬁle) and GEOUML are two UML modeling approaches
based on the ISO/TC211 standard: GSIP [50] uses a UML data model based on ISO/TC211 data
models for characteristics, spatial geometry, topology, time and cover, and GEOUML [12] is a UML
framework for conceptual modeling of GIS based on ISO 19100* standards.

On the other hand, OWL [66] is a standard W3C language following an object-oriented
philosophy for deﬁning Web ontologies, although today it has spread widely and may be found
in almost any domain. For its functioning, OWL relies on other languages such as XML, RDF,
and RDF-S (RDF-Schema). There are also plenty of OWL-based approaches in the literature for
deﬁning ontological models in EMIS. In particular, HYMPAS-OWL [1] and ETHAN [55] should be
mentioned because they are applied to ecological domains (more related to the SOLERES system
domain). The ﬁrst consists of three different applications for hydrological modeling. It facilitates
layers with spatial information on a map which includes groundwater, roads, railroads, borders,
streams and lakes, and covers all of the United States except Alaska. The ETHAN ontologies
concentrate on biological taxonomies and characteristics associated with natural history.

Table XI. UML and OWL approaches for environmental modeling

Name
Gasevic
Pan
OUP
Gronmo et al.
ONTOMET
GSIP
GEOUML
Geographical-Space
GeoOWL
HYMAPS-OWL

OO Approach
UML
UML
UML and OWL
UML
UML and OWL
UML and OWL
UML
UML
OWL
OWL

Technologies
XSLT, Model Transform.
Model Transform.
ODM, MDA, XSLT
GML, ISO 19188
ISO 19115
ISO/TC211
ISO/TC211, ISO 19100*
Semantic Reasoning
ISO/TC211
Decision support system

Organization
Belgrade Univ.
IBM China Research Lab
Belgrade Univ.
SINTEF Telecom & Informatics
Univ. Drexel, USA
Nat. Geospatial-Intell. Agency
Dpt. Informatics, U.Verona, Italia
Univ. Wuhan, China
W3C
Univ. Purdue, USA

Domain
General Ontology
General Ontology
General Ontology
Geographical Info.
Geospatial & Hydrology Info.
Geospatio-temporal Info.
GIS
Geospatial Info.
Geographical Info.
Ecological & Hydrolog. Info.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

30

L. IRIBARNE ET AL.

Table XII. Comparison of EMIS architectures

Trading
System
InfoSleuth
No
EDEN-IW No
No
NZDIS
No
FSEP
No
MAGIC
No
DIAMON
Yes
BUSTER
Yes
SOLERES

Ontologies
Yes
Yes
No
No
No
No
Yes
Yes

User Agent
Yes
Yes
Yes
No
Yes
Yes
No
Yes

Technologies
XML/RDF, KQML, OKBC
JADE, DAML+OIL
CORBA/OQL, MOF
JACK
FIPA-ACL, CORBA
Java/C++, FIPA-ACL
OIL, FIPA-OS
JADE, OWL, SPARQL, UML

Domain
Water resources
Water resources
Environmental data
Metheorology
Water management
Water management
Geographic information
Ecology

As expected, the progress of technologies has positively inﬂuenced the design and development of
WIS. Technologies such as trading services, ontologies and software agents have been incorporated
in them offering a wide range of possibilities. Since the domain of the case study analyzed in this
article is the environment, a rather exhaustive review was made of systems in this ﬁeld which have
been designed based on them. They can all be classiﬁed in one of three categories: environmental
information management, assistance in decision-making for solving environmental problems, and
simulation. Table XII shows a comparison of systems related to the SOLERES system studied.
Characteristics kept in mind were: (a) use of trading mechanisms, (b) use of modeling and design
of ontologies, (c) incorporation of some type of interface agent or similar, and (d) the technology
employed for its implementation. This table shows that none of the systems except SOLERES and
BUSTER [65] use a trading service as such, and even in BUSTER this trading service is only
partially implemented. And except for InfoSleuth [30], where the agents use ontologies to describe
the services they offer and the information to which they have access, they do not use ontologies
like SOLERES either. In EDEN-IW [24], the ontologies were modeled following Semantic Web
technology rules, and again, BUSTER, which uses a hybrid ontology where each information
source has an associated ontology to deﬁne its semantics. With regard to the use of agents, all
the systems except FSEP [21] and BUSTER, have some type of interface agent that mediates for
the user. It should be mentioned that SOLERES is the only system that combines all three of these
characteristics. Finally, the use of multiple and varied technologies for the implementation of these
systems, such as Java/C++, JADE, XML/RDF, DAML+OIL, etc., should be mentioned.

6. CONCLUSIONS AND FUTURE WORK

The exponential growth of information and information sources in large Web-based Information
Systems hinders management tasks and information processing. Information search and retrieval
operations are especially costly when working with heterogeneous database which because of their
distributed nature have grown over time. In this context, the recent Big Data concept attempts to
solve problems of data management and analysis in systems managing a large and varied volume of
information and information sources. One example of this occurs in many current geographic and
environmental information management systems, where large amounts of data are generated and
have to be managed for studies and simulations for decision-making. Over time, these systems end
up supporting large volumes of environmental data which make information search and retrieval
operations very costly.

This article presented an ontological trading model called OntoTrader, which evolved from
the traditional ODP (Open Distributed Processing) model, extending it to management not only
of services, but of any type of information, which uses a “Query-Search/Recovery-Response”
mechanism to improve information search and retrieval in Big Data systems. An architecture with
two important innovations is proposed for its design. The ﬁrst is the use of a document repository
which could be instances of any ontology representing the metadata of the information in a speciﬁc
domain, and the second is deﬁnition of an associated service/process ontology for each of the trading
service interfaces, which improves the communication model and interaction with it.

This article reported on modeling and formalizing of an ontological trading framework called
TKRS (Trading-based Knowledge Representation System) for Web-based Information Management

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

31

Systems that handle large volumes of data. This framework was constructed following MDE
(Model-Driven Engineering) and ODE (Ontology-Driven Engineering) guidelines and rules, which
enable the architectural deﬁnition of the system to be separated from its implementation. The TKRS
considers the system a distributed architecture comprised of a set of functional nodes (or ambients).
A graphical editor developed in GMF (Graphical Modeling Framework) makes it possible to
generate the architecture of the system model to be deployed during the design stage. System
node functionality is deﬁned in the design stage as a type of capability the system must have,
and can be implemented in different programming languages in the development stage. A system
component implementation repository model and a system conﬁguration model which connects
each component in the architecture to its corresponding implementation were deﬁned in the TKRS
framework. TKRS uses M2M (model-to-model) transformations to obtain a system conﬁguration
model that relates architecture models to implementations. Based on the conﬁguration model, a
concrete instance of the system (executable code) was obtained for the speciﬁc platform selected by
applying an M2T (model-to-text) transformation.

Finally, the article presented a real case study, the design and implementation of SOLERES-KRS,
a subsystem responsible for managing knowledge in the SOLERES environmental management
system, which handles large volumes of cartographic maps, satellite images and ecological maps.
The TKRS guidelines were followed for its construction and the software agent technology was
selected for its implementation. Due to the nature of the TKRS framework, two data ontologies
were used, the EIM ontology to represent the environmental information metadata, and the EID
ontology to represent the meta-metadata used by the trading agents that implement the OntoTrader
model. Communication and coordination of the different agents make use of three service/process
ontologies. The system was designed with the TKRS model editor developed in GMF and a JADE
implementation of the Multi-Agent System. The ontologies used by the agents for communicating
and interacting, and the ontologies representing the system knowledge are expressed in OWL/XML,
previously designed using UML modeling techniques.

As future lines of work, in the ﬁrst place, it would be of interest to modify the stand-alone
design of the OntoTrader trading service to implement the Link and Proxy interfaces, along with the
corresponding service/process ontologies, so it would be full-service trader. In the second place, it
is intended to use the trading service to automatically establish the connection between architectural
elements and their corresponding implementations. At present, this is being supervised by the
DSL deﬁned. This would imply that the trading service itself would independently locates the
best components for TKRS implementation automatically, based on the deﬁnition of the system
architecture with the graphical editor. Finally, it may be useful to have an Integrated Development
Environment (IDE) for design of implementation repository models and an application that would
integrate all the tools used in the TKRS framework design and implementation tasks.

ACKNOWLEDGEMENTS

This work was funded by the EU ERDF and the Spanish Ministry of Economy and Competitiveness
(MINECO) under Project TIN2013-41576-R and the Andalusian Regional Government (Spain)
under Project P10-TIC-6114.

REFERENCES

1. ABED (2010). A web GIS for hydrolic model operation. Agricultural & Biological Engineering Department,

Purdue University. https://engineering.purdue.edu/mapserve/LTHIA7/index.html.

2. Albert, M., Längle, T., Woern, H., and FR, K.U.G. (2002). Development tool for distributed monitoring and

diagnosis systems. Defense Technical Information Center.

3. Alexander, F.J., Adolfy, H., and Szalay, A. (2011). special issue on Big Data. Computing in Science & Engineering,

13(6).

4. An, Y. and Zhao, B. (2007). Geo ontology design and comparison in geographic information integration. In Fourth
Int. Conference on Fuzzy Systems and Knowledge Discovery (FSKD), volume 4, pages 608–612. IEEE Computer
Society.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

32

L. IRIBARNE ET AL.

5. Asensio, J. A., Iribarne, L., Padilla, N., and Ayala, R. (2008). Implementing trading agents for adaptable and
evolutive UI-COTS components architectures. In Proceedings of the International Conference on e-Business (ICE-
B), pages 259–262, Porto, Portugal. INSTICC Press.

6. Asensio, J. A., Iribarne, L., Padilla, N., and Vicente-Chicote, C. (2011). A model-driven approach for deploying
trading-based knowledge representation systems. In On the Move to Meaningful Internet Systems: OTM 2011
Workshops, volume 7046 of Lecture Notes in Computer Science, pages 180–189. Springer.

7. Asensio, J. A., Padilla, N., and Iribarne, L. (2012). An ontology-driven case study for the knowledge representation
of management information systems. In Information Systems, E-learning, and Knowledge Management Research,
volume 278 of Communications in Computer and Information Science (CCIS), pages 426–432. Springer.

8. Bakshi, K. (2012). Considerations for big data: Architecture and approach. In IEEE Aerospace Conference, pages

1–7. IEEE.

9. Bayard Cushing, J. (2013). Beyond Big Data? Computing in Science & Engineering, 15(5):4–5.
10. Bearman, M. (1997). Tutorial on ODP trading function. Faculty of Information Sciences Engineering. University

of Canberra.

11. Beitz, A. and Bearman, M. (1994). An ODP trading service for DCE. In Proceedings of the First International

Workshop on Services in Distributed and Networked Environments, pages 42–49. IEEE.

12. Belussi, A., Negri, M., and Pelagatti, G. (2004). GeoUML: A geographic conceptual model deﬁned through
specialization of ISO TC211 standards. In Proceedings of the 10th EC GI & GIS Workshop, pages 1–10, Warsaw,
Poland.

13. Bermudez, L. E. (2004). Ontomet: Ontology metadata framework. Philadelphia, PA. Drexel University.
14. Brilhante, V. B. (2004). An ontology for quantities in ecology. In Advances in Artiﬁcial Intelligence - 17th Brazilian
Symposium on Artiﬁcial Intelligence (SBIA), Proceedings, Lecture Notes in Computer Science, pages 144–153.
Springer.

15. Ceccaroni, L., Cortés, U., and Sànchez-Marrè, M. (2004). OntoWEDSS: Augmenting environmental decision-

support systems with ontologies. Environmental Modelling and Software, 19(9):785–797.

16. Collins, J., Ketter, W., and Gini, M. L. (2009). Flexible decision control in an autonomous trading agent. Electronic

Commerce Research and Applications, 8(2):91–105.

17. Craneﬁeld, S. and Purvis, M. (1999). UML as an ontology modelling language. In Proc. of the Workshop on
Intelligent Information Integration, 16th International Joint Conference on Artiﬁcial Intelligence (IJCAI), pages
46–53.

18. Craske, G., Tari, Z., and Kumar, K. R. (1999). DOK-Trader: A CORBA persistent trader with query routing

facilities. In Distributed Objects and Applications (DOA), pages 230–240.

19. Criado, J., Padilla, N., Iribarne, L., and Asensio, J. A. (2010). User interface composition with COTS-UI and
trading approaches: Application for Web-based Environmental Information Systems. In Knowledge Management,
Information Systems, E-Learning, and Sustainability Research, Part I, volume 111 of Communications in Computer
and Information Science (CCIS), pages 259–266. Springer.

20. Criado, J., Padilla, N., Iribarne, L., Asensio, J. A., and Muñoz, F. (2010). Ontological trading in a multi-agent
system. In Trends in Practical Applications of Agents and Multiagent Systems - 8th International Conference on
Practical Applications of Agents and Multiagent Systems (PAAMS), Special Sessions and Workshops, volume 71
of Advances in Intelligent and Soft Computing (AISC), pages 321–329, Salamanca, Spain. Springer.

21. Dance, S., Gorman, M., Padgham, L., and Winikoff, M. (2003). An evolving multi agent system for meteorological
alerts. In: Proceedings of the second international joint conference on Autonomous agents and multiagent systems,
pp. 966–967. ACM New York, NY, USA.

22. Di Lecce, V., Pasquale, C., and Piuri, V. (2004). A basic ontology for multi agent system communication
in an environmental monitoring system. In IEEE International Conference on Computational Intelligence for
Measurement Systems and Applications (CIMSA), pages 45–50, Boston, MA. Institute of Electrical and Electronics
Engineers.

23. Djuric, D., Gasevic, D., Devedzic, V., and Damjanovic, V. (2005). A UML proﬁle for OWL ontologies. In
Model Driven Architecture, European MDA Workshops: Foundations and Applications (MDAFA), volume 3599
of Lecture Notes in Computer Science, pages 204–219. Springer.

24. EDEN-IW (2001). Environmental data exchange network for inland water. Tech. rep., http://www.eden-iw.org.
25. EMF (2013). Eclipse Modeling Framework. http://www.eclipse.org/modeling/emf/.
26. Falkovych, K., Sabou, M., and Stuckenschmidt, H. (2003). UML for the semantic web: Transformation-based

approaches. In Knowledge Transformation for the Semantic Web, pages 92–106.

27. Gasevic, D., Djuric, D., Devedzic, V., and Damjanovic, V. (2004). Converting UML to OWL ontologies. In
Proceedings of the 13th International Conference on World Wide Web - WWW (Alternate Track Papers & Posters),
pages 488–489. ACM.

28. Gronmo, R., Solheim, I., and Skogan, D. (2002). Experiences of UML-to-GML encoding. In Proceedings of the

5th AGILE Conference, pages 1–8.

29. Huang, M. (2008). A new method to formal description of spatial ontology. Information Technology and

Environmental System Sciences, (3):417–421.

30. InfoSleuth (2005). The infosleuth agent system. Tech. rep., http://www.argreenhouse.com/InfoSleuth/.
31. Iribarne, L., Asensio, J. A., Padilla, N., and Ayala, R. (2008). SOLERES-HCI: Modelling a Human-Computer
Interaction framework for open EMS. In The Open Knowledge Society, volume 19 of Communications in Computer
and Inf. Science (CCIS), pages 320–327. Springer.

32. Iribarne, L., Padilla, N., Asensio, J. A., Muñoz, F., and Criado, J. (2010). Involving web-trading agents & MAS
– an implementation for searching and recovering environmental information. In Int. Conference on Agents and
Artiﬁcial Intelligence (ICAART), volume 2, pages 268–273, Valencia, Spain. INSTICC Press.

33. Iribarne, L., Padilla, N., Criado, J., Asensio, J. A., and Ayala, R. (2010). A model transformation approach for
automatic composition of COTS user interfaces in web-based information systems. Journal of Information Systems
Management (JISM), 27(3):207–216.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

MODELING BIG DATA BASED SYSTEMS THROUGH ONTOLOGICAL TRADING

33

34. Iribarne, L., Criado, J., Padilla, N., and Asensio, J. A. (2011). Using COTS-widgets architectures for describing
user interfaces of Web-based Information Systems. International Journal of Knowledge Society Research (IJKSR),
2(3):61–72.

35. Iribarne, L., Padilla, N., Ayala, R., Asensio, J.A., Criado, J. (2014). OntoTrader: An Ontological Web-Trading agent
approach for Environmental Information retrieval. The Scientiﬁc World Journal, Volume 2014 (2014), Article ID
560296, 25 pages.

36. Ishwarappa, Anuradha, J. (2015). A Brief Introduction on Big Data 5Vs Characteristics and Hadoop Technology.

Procedia Computer Science, 48:319-324.

37. ITU-T and ISO/IEC (1998). Information Technology – Open Distributed Processing – ODP Trading Function –

Part 1: Speciﬁcation. ITU-T Rec. X.950 – ISO/IEC 13235-1.

38. Kaisler, S., Armour, F., Espinosa, J.A. (2014). Introduction to big data: Challenges, opportunities, and realities

minitrack. In 47th Hawaii International Conference on System Sciences (HICSS), pages 728. IEEE.

39. Kogut, P., Craneﬁeld, S., Hart, L., Dutra, M., Baclawski, K., Kokar, M., and Smith, J. (2002). UML for ontology

development. Knowledge Engineering Review, 17(1):61–64.

40. Kune, R., Konugurthi, P.K., Agarwal, A., Chillarige, R.R., Buyya, R. (2016). The anatomy of big data computing.

Software: Practice and Experience, 46(1):79–105.

41. Kutvonen, L. (1996). Overview of the DRYAD trading system implementation. In The IFIP/IEEE International
Conference on Distributed Platforms: Client/Server and Beyond: DCE, CORBA, ODP and Advanced Distributed
Applications - ICDP, pages 314–326. Chapman & Hall.

42. Lamparter, S. and Schnizler, B. (2006). Trading services in ontology-driven markets. In ACM Symposium on

Applied Computing (SAC), pages 1679–1683.

43. Lieberman, J., Singh, R., and Goad, C. (2007). W3C Geospatial Ontologies. W3C Incubator Group Report.

http://www.w3.org/2005/Incubator/geo/XGR-geo-ont-20071023/.

44. Madden, S. (2012). From databases to big data. IEEE Internet Computing, 16(3):4–6.
45. Mathe, J. L., Werner, J., Lee, Y., Malin, B., and Ledeczi, A. (2008). Model-based design of clinical information

systems. Methods of Information in Medicine, 47(5):399–408.

46. Merz, M., Müller, K., and Lamersdorf, W. (1994). Service trading and mediation in distributed computing systems.

In Int. Conf. on Distributed Computing Systems (ICDCS), pages 450–457.

47. Müller, K., Merz, M., and Lamersdorf, W. (1995). The TRADEr: Integrating trading into DCE. In The 3rd IFIP

Conference on Open Distributed Processing, pages 476–487. Chapman & Hall.

48. NZDIS (2001). New Zealand Distributed Information Systems project. Tech. rep., http://nzdis.otago.ac.nz.
49. OGC

Geography

Geospatial

Language

(2007a).

(GML).

Open

Consortium.

Markup
http://www.opengeospatial.org/standards/gml/.

50. OGC (2007b). GEOINT structure implementation proﬁle schema processing. Open Geospatial Consortium.
51. Okawa, T., Kaminishi, T., Hirabayashi, S., Koizumi, H., and Sawamoto, J. (2008). An information system
development method based on the link of business process modeling with executable UML modeling and its
evaluation by prototyping. In AINA Workshops, pages 1057–1064.

52. OOC (2001). ORBacus trader. ORBacus for C++ and Java.
53. Pan, Y., Xie, G. T., Ma, L., Yang, Y., Qiu, Z., and Lee, J. (2006). Model-Driven Ontology Engineering. In J. Data

Semantics VII, volume 4244 of Lecture Notes in Computer Science, pages 57–78. Springer.

54. PrismTech (2001). OpenFusion trading service whitepaper. PrismTech. http://www.prismtech.com/openfusion/re-

sources/white-papers/.

55. Project Spire (2003). ETHAN. http://www.csee.umbc.edu/csee/research/spire/.
56. Quilitz, B., and Leser, U. (2008). Querying distributed RDF data sources with SPARQL. In The Semantic Web:
Research and Applications, volume 5021 of Lecture Notes in Computer Science, pages 524–538. Springer Berlin
Heidelberg.

57. Schmidt, D. C. (2001). The ADAPTATIVE communication environment (TAO): AceORB. University of California.

http://www.theaceorb.com/.

58. Shen, J., Krishna, A., Yuan, S., Cai, K., and Qin, Y. (2008). A pragmatic gis-oriented ontology for location based
services. In Australian Software Engineering Conference (ASWEC), pages 562–569. IEEE Computer Society.
59. Sheth, A. (2014). Transforming Big Data into Smart Data: Deriving value via harnessing Volume, Variety, and
Velocity using semantic techniques and technologies. In IEEE 30th International Conference on Data Engineering
(ICDE), pages 2. IEEE.

60. Song, J., Zhu, Y., and Wang, J. (2007). A study of semantic retrieval system based on geo-ontology with spatio-
temporal characteristic. In Proceedings of International Symposium on Distributed Computing and Applications to
Business, Engineering and Science (DCABES), volume I-II, pages 1029–1034.

61. Taniar, D. and Rahayu, J. W. (2004). Web Information Systems. Print. IGI Global, Hershey.
62. Tripathi, A. and Babaie, H. A. (2008). Developing a modular hydrogeology ontology by extending the SWEET

upper-level ontologies. Computers & Geosciences, 34(9):1022–1033.

63. Tsai, W.-T., Huang, Q., Xu, J., Chen, Y., and Paul, R. A. (2007). Ontology-based dynamic process collaboration in

service-oriented architecture. In Service-Oriented Comp. and App. (SOCA), pages 39–46.

64. Vasudevan, V. and Bannon, T. (1999). WebTrader: Discovery and programmed access to web-based services. In

Poster at the 8th International WWW Conference (WWW8), Toronto, Canada.

65. Vögele, T., Hübner, S., and Schuster, G. (2003). BUSTER ? An Information Broker for the Semantic Web. KI-

Künstliche Intelligenz 3(3), 31–34.

66. W3C (2004a). OWL Web Ontology Language reference. World Wide Web Consortium. http://www.w3.org/OWL/.
67. Wang, Y., Dai, J., Sheng, J., Zhou, K., and Gong, J. (2007). Geoontology design and its logic reasoning. In SPIE

Proceedings - Geospatial Information Science, volume 6753, pages 675309-1 – 675309-11.

68. Wörn, H., Längle, T., and Albert, M. (2002). Multi-agent architecture for monitoring and diagnosing complex
systems. In: The 4th International Workshop on Computer Science and Information Technologies (CSIT) University
of Patras/Greece.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

34

L. IRIBARNE ET AL.

69. Xiao-feng, M., Bao-wen, X., Qing, L., Ge, Y., Jun-yi, S., Zhengding, L., and Yan-xiang, H. (2006). A survey of

web information technology and application. Wuhan University Journal of Natural Sciences, 11:1–5.

70. Zhan, Q., Li, D., and Shao, Z. (2007). An architecture for ontology-based geographic information semantic grid
service. In Geoinformatics 2007: Geospatial Information Technology and Applications, SPIE Proceedings, volume
6754, pages 67541U – 67541U-9.

71. Ziming, Z. and Liyi, Z. (2007). An integrated approach for developing e-commerce system. In International
Conference on Wireless Communications, Networking and Mobile Computing (WiCom), pages 3596–3599.

Copyright © 0000 John Wiley & Sons, Ltd.
Prepared using speauth.cls

PREPRINT VERSION (0000)
DOI: 10.1002/preprint

