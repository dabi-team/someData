2
2
0
2

r
p
A
4
1

]
L
P
.
s
c
[

1
v
2
1
1
7
0
.
4
0
2
2
:
v
i
X
r
a

A Formally Certiï¬ed End-to-End Implementation of
Shorâ€™s Factorization Algorithm

Yuxiang Peng1,2, Kesha Hietala1, Runzhou Tao3, Liyi Li1,2, Robert Rand4, Michael
Hicks1,2, and Xiaodi Wu1,2, *

1Department of Computer Science, University of Maryland, College Park, USA
2Joint Center for Quantum Information and Computer Science, University of Maryland, College Park, USA.
3Department of Computer Science, Columbia University, USA
4Department of Computer Science, University of Chicago, USA
*xiaodiwu@umd.edu

ABSTRACT

Quantum computing technology may soon deliver revolutionary improvements in algorithmic performance, but these are only
useful if computed answers are correct. While hardware-level decoherence errors have garnered signiï¬cant attention, a less
recognized obstacle to correctness is that of human programming errorsâ€”â€œbugsâ€. Techniques familiar to most programmers
from the classical domain for avoiding, discovering, and diagnosing bugs do not easily transfer, at scale, to the quantum
domain because of its unique characteristics. To address this problem, we have been working to adapt formal methods to
quantum programming. With such methods, a programmer writes a mathematical speciï¬cation alongside their program, and
semi-automatically proves the program correct with respect to it. The proofâ€™s validity is automatically conï¬rmedâ€”certiï¬edâ€”by
a â€œproof assistantâ€. Formal methods have successfully yielded high-assurance classical software artifacts, and the underlying
technology has produced certiï¬ed proofs of major mathematical theorems. As a demonstration of the feasibility of applying
formal methods to quantum programming, we present the ï¬rst formally certiï¬ed end-to-end implementation of Shorâ€™s prime
factorization algorithm, developed as part of a novel framework for applying the certiï¬ed approach to general applications. By
leveraging our framework, one can signiï¬cantly reduce the effects of human errors and obtain a high-assurance implementation
of large-scale quantum applications in a principled way.

1 Introduction

Leveraging the bizarre characteristics of quantum mechanics,
quantum computers promise revolutionary improvements in
our ability to tackle classically intractable problems, including
the breaking of crypto-systems, the simulation of quantum
physical systems, and the solving of various optimization and
machine learning tasks.

Problem: Ensuring quantum programs are correct As
developments in quantum computer hardware bring this
promise closer to reality, a key question to contend with is:
How can we be sure that a quantum computer program, when
executed, will give the right answer? A well-recognized threat
to correctness is the quantum computer hardware, which is
susceptible to decoherence errors. Techniques to provide
hardware-level fault tolerance are under active research1, 2.
A less recognized threat comes from errorsâ€”bugsâ€”in the
program itself, as well as errors in the software that prepares
a program to run on a quantum computer (compilers, linkers,
etc.). In the classical domain, program bugs are commonplace
and are sometimes the source of expensive and catastrophic
failures or security vulnerabilities. There is reason to believe
that writing correct quantum programs will be even harder, as
shown in Figure 1 (a).

Quantum programs that provide a performance advantage
over their classical counterparts are challenging to write and
understand. They often involve the use of randomized algo-

rithms, and they leverage unfamiliar quantum-speciï¬c con-
cepts, including superposition, entanglement, and destructive
measurement. Quantum programs are also hard to test. To
debug a failing test, programmers cannot easily observe (mea-
sure) an intermediate state, as the destructive nature of mea-
surement could change the state, and the outcome. Simulating
a quantum program on a classical computer can help, but is
limited by such computersâ€™ ability to faithfully represent a
quantum state of even modest size (which is why we must
build quantum hardware). The fact that near-term quantum
computers are error-prone adds another layer of difï¬culty.

Proving programs correct with formal methods As a po-
tential remedy to these problems, we have been exploring how
to use formal methods (aka formal veriï¬cation) to develop
quantum programs. Formal methods are processes and tech-
niques by which one can mathematically prove that software
does what it should, for all inputs; the proved-correct artifact
is referred to as formally certiï¬ed. The development of formal
methods began in the 1960s when classical computers were in
a state similar to quantum computers today: Computers were
rare, expensive to use, and had relatively few resources, e.g.,
memory and processing power. Then, programmers would be
expected to do proofs of their programsâ€™ correctness by hand.
Automating and conï¬rming such proofs has, for more than 50
years now, been a grand challenge for computing research3.
While early developments of formal methods led to dis-
appointment4, the last two decades have seen remarkable

1

 
 
 
 
 
 
Figure 1. Comparison of developing quantum programs with testing (a) and with formal methods (b). In the testing scheme,
programmers will generate test cases according to the speciï¬cations of the desired quantum semantics of the target applications,
and execute them on hardware for debugging purposes. One approach is through runtime assertions on the intermediate
program states during the execution. Intermediate quantum program states, however, will collapse when observed for
intermediate values, which implies that assertions could disturb the quantum computation itself. Moreover, many quantum
algorithms generate samples over an exponentially large output domain, whose statistical properties could require exponentially
many samples to be veriï¬ed information-theoretically. Together with the fact that quantum hardware is noisy and error-prone,
interpreting the readout statistics of quantum hardware for testing purposes is extremely expensive and challenging. One can
avoid the difï¬culty of working with quantum hardware by simulating quantum programs on classical machines, which,
however, requires exponential resources in simulation and is not scalable at all. Finally, correctness is only guaranteed on test
cases in this scheme. In the formal methods approach, programmers will develop quantum programs, their desired
speciï¬cations, and mechanized proofs that the two correspond. All these three componentsâ€”programs, speciï¬cations, and
proofsâ€”will be validated statically by the compiler of a proof assistant with built-in support to handle quantum programs.
Once everything passes the compilerâ€™s check, one has a certiï¬ed implementation of the target quantum application, which is
guaranteed to meet desired speciï¬cations on all possible inputs, even without running the program on any real machine.

progress. Notable successes include the development of
the seL4 microkernel5 and the CompCert C compiler6. For
the latter, the beneï¬ts of formal methods have been demon-
strated empirically: Using sophisticated testing techniques, re-
searchers found hundreds of bugs in the popular mainstream C
compilers gcc and clang, but none in CompCertâ€™s veriï¬ed
core7. Formal methods have also been successfully deployed
to prove major mathematical theorems (e.g., the Four Color
theorem8) and build computer-assisted proofs in the grand
uniï¬cation theory of mathematics9, 10.

Formal methods for quantum programs Our key obser-
vation is that the symbolic reasoning behind the formal ver-
iï¬cation is not limited by the aforementioned difï¬culties of
testing directly on quantum machines or the classical simu-
lation of quantum machines, which lends itself to a viable
alternative to the veriï¬cation of quantum programs. Our re-
search has explored how formal methods can be used with
quantum programs.

As shown in Figure 1 (b), to develop quantum programs
with formal methods we can employ a proof assistant, which
is a general-purpose tool for deï¬ning mathematical structures,
and for semi-automatically mechanizing proofs of proper-
ties about those structures. The proof assistant conï¬rms that
each mechanized proof is logically correct. Using the Coq
proof assistant11, we deï¬ned a simple quantum intermediate
representation12 (SQIR) for expressing a quantum program
as a series of operationsâ€”essentially a kind of circuitâ€”and
speciï¬ed those operationsâ€™ mathematical meaning. Thus we
can state mathematical properties about a SQIR program and
prove that they always hold without needing to run that pro-
gram. Then we can ask Coq to extract the SQIR program
to OpenQASM 2.013 to run it on speciï¬c inputs on a real
machine, assured that it is correct.

Adapting formal methods developed for classical programs
to work on quantum ones are conceptually straightforward
but pragmatically challenging. Consider that classical pro-
gram states are (in the simplest terms) maps from addresses

2/18

Classical SimulationCorrectness on Test CasesTestingRuntime AssertionsTestCasescollapse of statesexponential resourcesnoisy machineexponentiallymanysamplesExecutableQuantumSoftwareProgrammersOutputAnalysisOutputAnalysisQuantum HardwareDesiredSpecificationsQuantum ProgramsFormal methodsMechanized ProofsProof Assistant withQuantum Program InfrastructureProgrammersExecutableQuantumSoftwareGuaranteedCorrectnessonAllInputsQuantumHardware(b)OutputwithGuarantees(a)Quantum ProgramsDesiredSpecificationsto bits (0 or 1); thus, a state is essentially a length-n vector of
booleans. Operations on states, e.g., ripple-carry adders, can
be deï¬ned by boolean formulae and reasoned about symboli-
cally.

Quantum states are much more involved: In SQIR an n-
qubit quantum state is represented as a length-2n vector of
complex numbers and the meaning of an n-qubit operation is
represented as a 2n Ã— 2n matrixâ€”applying an operation to a
state is tantamount to multiplying the operationâ€™s matrix with
the stateâ€™s vector. Proofs over all possible inputs thus involve
translating such multiplications into symbolic formulae and
then reasoning about them.

Given the potentially large size of quantum states, such
formulae could become quite large and difï¬cult to reason
about. To cope, we developed automated tactics to trans-
late symbolic states into normalized algebraic forms, mak-
ing them more amenable to automated simpliï¬cation. We
also eschew matrix-based representations entirely when an
operation can be expressed symbolically in terms of its ac-
tion on basis states. With these techniques and others14, we
proved the correctness of key components of several quantum
algorithmsâ€”Groverâ€™s search algorithm15 and quantum phase
estimation (QPE)16â€”and demonstrated advantages over com-
peting approaches17â€“20.

With this promising foundation in place, several challenges
remain. First, both Groverâ€™s and QPE are parameterized by
oracles, which are classical algorithmic components that must
be implemented to run on quantum hardware. These must
be reasoned about, too, but they can be large (many times
larger than an algorithmâ€™s quantum scaffold) and can be chal-
lenging to encode for quantum processing, bug-free. Another
challenge is proving the end-to-end properties of hybrid quan-
tum/classical algorithms. These algorithms execute code on
both classical and quantum computers to produce a ï¬nal result.
Such algorithms are likely to be common in near-term deploy-
ments in which quantum processors complement classical
ones. Finally, end-to-end certiï¬ed software must implement
and reason about probabilistic algorithms, which are correct
with a certain probability and may require multiple runs.

Shorâ€™s algorithm, and the beneï¬t of formal methods To
close these gaps, and thereby demonstrate the feasibility of
the application of formal methods to quantum programming,
we have produced the ï¬rst fully certiï¬ed version of Shorâ€™s
prime factorization algorithm16. This algorithm has been
a fundamental motivation for the development of quantum
computers and is at a scale and complexity not reached in
prior formalization efforts. Shorâ€™s is a hybrid, probabilistic
algorithm, and our certiï¬ed implementation of it is complete
with both classical and quantum components, including all
needed oracles.

2 Certiï¬ed End-to-End Implementation of

Shorâ€™s Prime-Factoring Algorithm

Shorâ€™s algorithm leverages the power of quantum computing
to break widely-used RSA cryptographic systems. A recent

study21 suggests that with 20 million noisy qubits, it would
take a few hours for Shorâ€™s algorithm to factor a 2048-bit
number instead of trillions of years by modern classical com-
puters using the best-known methods. As shown in Figure 2,
Shor developed a sophisticated, quantum-classical hybrid al-
gorithm to factor a number N: the key quantum partâ€”order
ï¬ndingâ€”preceded and followed by classical computationâ€”
primality testing before, and conversion of found orders to
prime factors, after. The algorithmâ€™s correctness proof criti-
cally relies on arguments about both its quantum and classical
parts, and also on several number-theoretical arguments.

While it is difï¬cult to factor a number, it is easy to conï¬rm a
proposed factorization (the factoring problem is inside the NP
complexity class). One might wonder: why prove a program
correct if we can always efï¬ciently check its output? When
the check shows an output is wrong, this fact does not help
with computing the correct output and provides no hint about
the source of the implementation error. By contrast, formal
veriï¬cation allows us to identify the source of the error: itâ€™s
precisely the subprogram that we could not verify.

Moreover, because inputs are reasoned about symbolically,
the complexity of all-input certiï¬cation can be (much) less
than the complexity of single-output correctness checking.
For example, one can symbolically verify that a quantum cir-
cuit generates a uniform distribution over n bits, but directly
checking whether the output samples from a uniform distri-
bution over n bits could take as many as 2Î˜(n) samples22. As
such, with formal methods, one can certify implementation for
major quantum applications, like quantum simulation which
is BQP-complete23 and believed to lie outside NP.

Overview of our implementation We carried out our work
using the Coq proof assistant, using the small quantum in-
termediate representation SQIR12 as a basis for expressing
the quantum components of Shorâ€™s algorithm. SQIR is a
circuit-oriented quantum programming language that closely
resembles IBMâ€™s OpenQASM 2.013 (a standard representa-
tion for quantum circuits executable on quantum machines)
and is equipped with mathematical semantics using which
we can reason about the properties of quantum algorithms
in Coq14. An instantiation of the scheme in Figure 1 (b) for
Shorâ€™s algorithm is given in Figure 3 (b). The certiï¬ed code
is bounded by the green box; we proved its gate count, the
likelihood of success, and correctness when successful.

The core of the algorithm is the computation of the or-
der r of a modulo N, where a is (uniformly) randomly drawn
from the numbers 1 through N; this component is bounded by
the dark box in Figure 2. The quantum component of order
ï¬nding applies quantum phase estimation (QPE) to an oracle
implementing an in-place modular multiplier (IMM). The cor-
rectness of QPE was previously proved in SQIR with respect
to an abstract oracle14, but we must reason about its behavior
when applied to this IMM oracle in particular. The oracle
corresponds to pure classical reversible computation when
executed coherently, leveraging none of the unique features of

3/18

Figure 2. Overview of Shorâ€™s factoring algorithm, which ï¬nds a non-trivial factor of integer N. The classical pre-processing
will identify cases where N is prime, even, or a prime power, which can be efï¬ciently tested for and solved by classical
algorithms. Otherwise, one will proceed to the main part of Shorâ€™s algorithm (enclosed in the green frame) to solve the case
where N = pkq. One starts with a random integer sample a between 1 and N. When a is a co-prime of N, i.e., the greatest
common divisor gcd(a, N) = 1, the algorithm leverages a quantum computer and classical post-processing to ï¬nd the order r of
a modulo N (i.e., the smallest positive integer r such that ar â‰¡ 1( mod N)). The quantum part of order ï¬nding involves
quantum phase estimation (QPE) on modular multipliers for (a, N). The classical post-processing ï¬nds the continued fraction
expansion (CFE) [a1, a2, Â· Â· Â· , a2m] of the output s/2m â‰ˆ k/r of quantum phase estimation to recover the order r. Further
classical post-processing will rule out cases where r is odd before outputting the non-trivial factor. To formally prove the
correctness of the implementation, we ï¬rst prove separately the correctness of the quantum component (i.e., QPE with in-place
modular multiplier circuits for any (a, N) on n bits) and the classical component (i.e., the convergence and the correctness of
the CFE procedure). We then integrate them to prove that with one randomly sampled a, the main part of Shorâ€™s algorithm, i.e.,
the quantum order-ï¬nding step sandwiched between the pre and post classical processing, will succeed in identifying a
non-trivial factor of N with probability at least 1/polylog(N). By repeating this procedure polylog(N) times, our certiï¬ed
implementation of Shorâ€™s algorithm is guaranteed to ï¬nd a non-trivial factor with a success probability close to 1.

quantum computers, but SQIR was not able to leverage this
fact to simplify the proof.

In response, we developed the reversible circuit intermedi-
ate representation (RCIR) in Coq to express classical func-
tions and prove their correctness, which can be translated
into SQIR as shown in Figure 3 (a). RCIR helps us easily
build the textbook version of IMM24 and prove its correct-
ness and resource usage (Figure 3 (c.i)). Integrating the QPE

implementation in SQIR with the translation of IMMâ€™s imple-
mentation from RCIR to SQIR, we implement the quantum
component of order-ï¬nding as well as the proof for its cor-
rectness and gate count bound (Figure 3 (c.ii)). It is worth
mentioning that such a proved-correct implementation of the
quantum component of order ï¬nding was reported in Why3
using QBRICKS20. However, the certiï¬ed implementation of
the classical part of order ï¬nding and the remainder of Shorâ€™s

4/18

ğ‘›ğ¼ğ‘€ğ‘€(ğ‘˜,ğ‘)|ğ‘¥modğ‘âŸ©|ğ‘¥â‹…ğ‘˜modğ‘âŸ©In-place Modular Multiplierğ‘šğ‘„ğ¹ğ‘‡ğ‘š|ğ‘¥âŸ©à·ğ‘˜=02ğ‘šâˆ’1ğœ”2ğ‘šğ‘¥ğ‘˜2ğ‘š|ğ‘˜âŸ©Quantum Fourier Transformğ‘›ğ¼ğ‘€ğ‘€(20ğ‘,ğ‘)|1âŸ©â‹®â‹®|0âŸ©|0âŸ©|0âŸ©ğ»â‹¯â‹¯ğ¼ğ‘€ğ‘€(2ğ‘šğ‘,ğ‘)|ğ‘ âŸ©Quantum Phase Estimation on Modular Exponentiation for (ğ‘,ğ‘)ğ»â‹¯ğ»â‹¯ğ¼ğ‘€ğ‘€(21ğ‘,ğ‘)ğ‘„ğ¹ğ‘‡ğ‘šâˆ’1ğ‘ğ‘–ğ‘ğ‘–=1ğ‘1+1â‹±||+1ğ‘ğ‘–â„™âˆƒğ‘–,ğ‘ğ‘–=ğ‘Ÿâ‰¥1poly(ğ‘š)Continued Fraction Expansion on ğ‘ /2ğ‘šFind order ğ’“for ğ’‚modulo ğ‘µFind a non-trivial factor of ğ‘µğ‘is prime?Abortğ‘=2ğ‘€?Return 2ğ‘=ğ‘ğ‘˜?Return ğ‘ğ‘=ğ‘ğ‘˜ğ‘Randomly pick 1<ğ‘<ğ‘gcdğ‘,ğ‘=1?YesNoYesYesNoNoYesNoReturn gcd(ğ‘,ğ‘)1<gcdğ‘ğ‘Ÿ/2âˆ’1,ğ‘<ğ‘?Return gcdğ‘ğ‘Ÿ/2âˆ’1,ğ‘YesNoGuaranteed correctness:success probability â‰¥1/polylogğ‘ğ‘ 2ğ‘šâ‰ˆğ‘˜ğ‘Ÿâ‡’ğ‘1,ğ‘2,â€¦,ğ‘2ğ‘š1<gcdğ‘ğ‘Ÿ/2+1,ğ‘<ğ‘?Return gcdğ‘ğ‘Ÿ/2+1,ğ‘YesFailNoğ‘Ÿodd?YesFailNoClassicallyefficient Figure 3. Technical illustration of our fully certiï¬ed implementation of Shorâ€™s algorithm. (a) The schematic framework of our
implementation in Coq. SQIR is an intermediate representation of quantum circuits resembling IBM OpenQASM 2.0 but
equipped with mechanized mathematical semantics in Coq. RCIR is an intermediate representation of classical reversible
circuits developed for the implementation of in-place modular multiplier (IMM) that can be translated to SQIR. These three
languages (Coq, SQIR, and RCIR) handle different parts of the end-to-end implementation of Shorâ€™s algorithm as well as their
correctness proof. (b) An instantiation of the formal methods scheme in Shorâ€™s implementation. Speciï¬cations of correctness
and resource consumption (gate count bounds), together with their mechanized proofs (including certiï¬ed math statements in
number theory), are developed and validated in the Coq proof assistant. (c) Showcases of major components of our end-to-end
implementation and corresponding proofs. Codes are adjusted for pretty-printing. (c.i) The implementation of IMM. We use
the example of the Ripple-Carry Adder (RCA) to illustrate the speciï¬cations and proofs. (c.ii) The implementation of quantum
phase estimation over IMM in SQIR (QPE_IMM). The correctness speciï¬cation states that, under some premises, the probability
of measuring the closest integer to 2mk/r, where r is the order of a modulo N, is larger than a positive constant 4/Ï€ 2. We also
certify the gate count of the implementation of QPE_IMM. (c.iii) The implementation of classical post-processing for order
ï¬nding and factorization. Continued fraction expansion CFE is applied to the outcome of QPE_IMM to recover the order with a
certiï¬ed success probability at-least 1/polylog(N). The success probability of factorization is also certiï¬ed to be at least
1/polylog(N), which can be boosted to 1 minus some exponentially decaying error term after repetitions. These analyses
critically rely on number theoretical statements like Legendreâ€™s theorem, lower bounds for Eulerâ€™s totient function, and Eulerâ€™s
criterion for quadratic residues, which have been proven constructively in Coq in our implementation.

5/18

RCIRSQIRCoqTranslateClassical Reversible CircuitsQuantum CircuitsClassical ProceduresImplementAnalyzeIn-place Modular MultiplierQuantum Phase EstimationOF/Fact. Post-processingComponents of Shorâ€™s algorithmImplementation CodesAnalysesCorrectnessSpecificationsProofsRipple-Carry AdderModular AdderModular ShifterModular MultiplierIn-place Modular MultiplierRCA codes in RCIRFixpointMAJseqin :=matchiwith| 0 => MAJ 0 (1+n) 1| S i' => MAJseqi' n;MAJ i(1+n+i) (1+i)end.FixpointUMAseq i n :=matchi with| 0 => UMA 0 (1+n) 1| S i' => UMA i (1+n+i) (1+i);UMAseq i' nend.Definition RCA n :=MAJseq (n-1) n; UMAseq (n-1) n.ImplementationCorrectness specificationsLemmaRCA_correct:âˆ€nxycâˆ¶â„•,0<nâ†’rc_exec(RCA n) c1[x]n[y]n=c1[x]n[x+y+c]n.LemmaIMM_correct:âˆ€nxkNâˆ¶â„•,1<N<2nâ†’x<Nâ†’k<Nâ†’(gcdkN)=1â†’letsâ‰”3n+11inrc_exec(IMM k N n) [x]n[0]s=[kâ‹…xmodN]n[0]s.Gate count specificationsLemmaMAJseq_gate_count:âˆ€nmâˆ¶â„•,rc_count(MAJseqn m) â‰¤3â‹…n.LemmaRCA_gate_count:âˆ€nâˆ¶â„•,0<nâ†’rc_count(RCA n) â‰¤6â‹…n.LemmaIMM_gate_count:âˆ€nkNâˆ¶â„•,1<nâ†’rc_count(IMM k N n)â‰¤212â‹…n2+943â‹…n+967.Proofintros n m.inductionn.-simpl. lia.-simpl. lia.Qed.(i) In-place modular multiplier (IMM) in RCIRImplementationCorrectness specificationsGate count specifications(ii) Quantum phase estimation over IMM in SQIRFixpointctrl_modexpm n a N k :=matchk with| 0    => SKIP| S k' => ctrl_modexpm n a N k';control (m-k) (map_qubits(Î»q â‡’m+q)(IMM (a2kâ€²mod N) N n))end.DefinitionQPE_IMM m n a N :=nparm U_H;ctrl_modexpm n a N m; invert (QFT m).Definition |ÏˆkâŸ©(a N nâˆ¶â„•) :=letrâ‰”ordaNin1rÏƒx=0râˆ’1Ï‰râˆ’kâ‹…xaxmodNn.LemmaQPE_IMM_correct:âˆ€aNnmkâˆ¶â„•,let (r,s)â‰”(ordaN,3n+11)in1<N<2nâ†’a<Nâ†’(gcdaN)=1â†’k<râ†’â„™â‰¥4ğœ‹2LemmaQPE_IMM_gate_count:âˆ€aNnmâˆ¶â„•,0<nâ†’0<mâ†’uc_count(QPE_IMM m n a N)â‰¤(212â‹…n2+975â‹…n+1031)â‹…m+m2+4â‹…m.ImplementationCorrectness specifications(iii) Continued Fraction Expansion (CFE) in Order Finding (OF) &Classical Post-Processing in Shorâ€™s Factoring Algorithm (FAC)FixpointCFE n a b q1q2:=matchn with| 0   => q1| S n => if(a =? 0) thenq1else let c := (b / a)%â„•inCFE n (b mod a) a (cq1+q2) q1end.FixpointOF_postâ€™ s out a N m :=matchs with| 0 => 0  | S s' => letu := OF_post' sâ€™ out a N m inletv := CFE sâ€™ out (2^m) 1 0 inif(u <>? 0) thenu elseif(a^vmod N =? 1) thenv else0end.DefinitionOF_postout a N m := OF_post' (2*m+2) out a N m.DefinitionFAC_postout a N m :=letr := OF_postout a N m inletp := gcd(a^(r/2)+1) N inletq := gcd(a^(r/2)-1) N inif ((1<?p) && (p<?N))then pelse q.DefinitionE2E_FAC N rs:=iterate rs(run_shorN)LemmaOF_post_correct: âˆƒÎ²,Î²>0âˆ§âˆ€aNâˆ¶â„•,0<a<Nâ†’(gcdaN)=1â†’let (m,n)â‰”(log22N2,log22N)inlet (s,f)â‰”(3n+11,(Î»out).OF_postout a N m) inLemmaFAC_correct: âˆƒÎ²,Î²>0âˆ§âˆ€(Ntâˆ¶â„•),Â¬ (prime N)â†’Odd Nâ†’(âˆ€p k, prime p â†’N â‰ pk)â†’let (m,n,s)â‰”(log22N2,log22N,3log22N+11)inTheorem Legendre_CFE: âˆ€pqabâˆ¶â„•,0<qâ†’a<bâ†’(gcdp q)=1â†’abâˆ’pq<12q2â†’âˆƒs,s<2log2b+2âˆ§CFE s a b 1 0 = q.Theorem Euler_totient_lb: âˆ€nâˆ¶â„•,nâ‰¥2â†’ğœ‘nnâ‰¥ğ‘’âˆ’2log2n4.TheoremEuler_criterion:âˆ€apkâˆ¶â„•,prime pâ†’0<kâ†’gcdpa=1â†’2<pâ†’ağœ‘pk/2â‰¡àµ1modpkaisaq.r.âˆ’1modpkaisaq.n.r.0mÏˆkn2mâ‹…k/rm0sQPE_IMMm n a Nâ„™outres=(ordaN)â‰¥Î²log2N4.0m1noutm0sQPE_IMMm n a Nfresâ„™out,aâˆˆâ„¤Nletfâ‰”(Î»out).FAC_postoutaNminFAC_succresNâ‰¥Î²log2N4(a)(b)(c)Embedded inImplementAnalyzeImplementAnalyzeResourcesMathâˆ§â„™rsâˆˆUnif0,1tFAC_fail(E2E_FACNrs)Nâ‰¤1âˆ’Î²log2N4t.Number theory theoremsalgorithm was not pursued20. Moreover, QBRICKSâ€™ use of
Why3 requires a larger trust base than Coq.

After executing the quantum part of the algorithm, some
classical code carries out continued fraction expansion (CFE)
to recover the order r. Roughly speaking, the output of QPE
over the IMM unitary is a close approximation of k/r for a
uniformly sampled k from {0, 1, Â· Â· Â· , r âˆ’ 1}. CFE is an iter-
ative algorithm and its efï¬ciency to recover k/r in terms of
the number of iterations is guaranteed by Legendreâ€™s theorem
which we formulated and constructively proved in Coq with
respect to the CFE implementation. When the recovered k and
r are co-primes, the output r is the correct order. The algo-
rithm is probabilistic, and the probability that co-prime k and
r are output is lower bounded by the size of Zr which consists
of all positive integers that are smaller than r and coprime to
it. The size of Zr is the deï¬nition of the famous Eulerâ€™s totient
function Ï•(r), which we proved is at least eâˆ’2/(cid:98)log(r)(cid:99)4 in
Coq based on the formalization of Eulerâ€™s product formula
and Eulerâ€™s theorem by de Rauglaudre25. By integrating the
proofs for both quantum and classical components, we show
that our implementation of the entire hybrid order-ï¬nding
procedure will identify the correct order r for any a given that
gcd(a, N) = 1 with probability at least 4eâˆ’2/Ï€ 2(cid:98)log2(N)(cid:99)4
(Figure 3 (c.iii)).

With the properties and correctness of order ï¬nding estab-
lished, we can prove the success probability of the algorithm
overall. In particular, we aim to establish that the order ï¬nding
procedure combined with the classical post-processing will
output a non-trivial factor with a success probability of at least
2eâˆ’2/Ï€ 2(cid:98)log2(N)(cid:99)4, which is half of the success probability
of order ï¬nding. In other words, we prove that for at least
a half of the integers a between 1 and N, the order r will
be even and either gcd(ar/2 + 1, N) or gcd(ar/2 âˆ’ 1, N) will
be a non-trivial factor of N. Shorâ€™s original proof16 of this
property made use of the existence of the group generator of
Z
pk , also known as primitive roots, for odd prime p. How-
ever, the known proof of the existence of primitive roots is
non-constructive26 meaning that it makes use of axioms like
the law of the excluded middle, whereas one needs to provide
constructive proofs27 in Coq and other proof assistants.

To address this problem, we provide a new, constructive
proof of the desired fact without using primitive roots. Pre-
cisely, we make use of the quadratic residues in modulus pk
and connect whether a randomly chosen a leads to a non-
trivial factor to the number of quadratic residues and non-
residues in modulus pk. The counting of the latter is estab-
lished based on Eulerâ€™s criterion for distinguishing between
quadratic residues and non-residues modulo pk which we have
constructively proved in Coq.

Putting it all together, we have proved that our imple-
mentation of Shorâ€™s algorithm successfully outputs a non-
trivial factor with a probability of at least 2eâˆ’2/Ï€ 2(cid:98)log2(N)(cid:99)4
for one random sample of a. Furthermore, we also prove
in Coq that its failure probability of t repetitions is upper
bounded by (1 âˆ’ 2eâˆ’2/Ï€ 2(cid:98)log2(N)(cid:99)4)t , which boosts the suc-
cess probability of our implementation arbitrarily close to 1

after O(log4(N)) repetitions.

We also certify that the gate count in our implementa-
tion of Shorâ€™s algorithm using OpenQASMâ€™s gate set is up-
per bounded by (212n2 + 975n + 1031)m + 4m + m2 in Coq,
where n refers to the number of bits representing N and m the
number of bits in QPE output. Note further m, n = O(log N),
which leads to an O(log3 N) overall asymptotic complexity
that matches the original paper.

3 Executing Shorâ€™s algorithm

Having completed our certiï¬ed-in-Coq implementation of
Shorâ€™s algorithm, we extract the programâ€”both classical and
quantum partsâ€”to code we can execute. Extraction is sim-
ply a lightweight translation from Coqâ€™s native language to
Objective Caml (OCaml), a similar but an executable alterna-
tive29 which runs on a classical computer. The quantum part
of Shorâ€™s algorithm is extracted to OCaml code that, when
executed, generates the desired quantum circuits in Open-
QASM 2.0 for the given input parameters; this circuit will
be executed on a quantum computer. The classical pre- and
post-processing codes extract directly to OCaml. A schematic
illustration of this end-to-end quantum-classical hybrid ex-
ecution is given in Figure 4 (a) for both order ï¬nding and
factorization.

In principle, the generated Shorâ€™s factorization circuits
could be executed on any quantum machine. However, for
small instances, as we elaborate on later, the size of these
quantum circuits is still challenging for existing quantum
machines to execute. Instead, we use a classical simulator
called DDSIM28 to execute these quantum circuits, which
necessarily limits the scale of our empirical study.

It is worth mentioning that experimental demonstration
of Shorâ€™s algorithm already exists for small instances like
N =1530â€“34 or 2135, which uses around 5 qubits and 20 gates.
These experimental demonstrations are possible because they
leverage quantum circuits that are specially designed for ï¬xed
inputs but cannot extend to work for general ones. In our
implementation, an efï¬cient circuit constructor will generate
the desired quantum circuit given any input. Even for small
instances (order ï¬nding with input (a = 3, N = 7) and factor-
ization with N = 15), the generated quantum circuits would
require around 30 qubits and over 10k gates, whose details of
the simulator-based execution are shown in Figure 4 (b).

In Figure 4 (c), we conduct a more comprehensive empiri-
cal study on the gate count and success probability of order
ï¬nding and factorization instances with input size (log(N))
from 2 to 10 bits, i.e., N â‰¤ 1024. Red circles refer to instances
(i.e. a few speciï¬c Ns) that can be simulated by DDSIM.
The empirical success probability for other Ns up to 1024 are
calculated directly using formulas in Shorâ€™s original analysis
with speciï¬c inputs, whereas our certiï¬ed bounds are loose in
the sense that they only hold for each input size. These empir-
ical values are displayed in a blue interval called the empirical
range per input size. It is observed that (1) certiï¬ed bounds
hold for all instances (2) empirical bounds are considerably

6/18

Figure 4. End-to-End Execution of Shorâ€™s algorithm. (a) A schematic illustration of the end-to-end quantum-classical hybrid
execution. Programmers write programs, speciï¬cations, and proofs in Coq, where Coq programs are extracted to OCaml for
practical execution. Given an input parameter a, N for order ï¬nding (or N for factorization), the extracted OCaml program
generates an OpenQASM ï¬le for a quantum processing unit and an executable for a classical machine to pre and post classical
processing. (b) Examples of end-to-end executions of order ï¬nding (OF) and factorization (FAC). The left example ï¬nds the
order for a=3 and N=7. The generated OpenQASM ï¬le uses 29 qubits and contains around 11k gates. We employed JKQ
DDSIM28 to simulate the circuit for 100k shots, and the frequency distribution is presented. The trials with post-processing
leading to the correct order r=6 are marked green. The empirical success probability is 28.40%, whereas the proved success
probability lower bound is 0.34%. The right example shows the procedure factorizing N=15. For each randomly picked a, the
generated OpenQASM ï¬le uses 35 qubits and contains around 22k gates, which are simulated by JKD DDSIM with the
outcome frequency presented in the ï¬gure. The cases leading to a non-trivial factor are marked green. The empirical success
probability is 43.77%, whereas the proved success probability lower bound is 0.17%. (c) Empirical statistics of the gate count
and success probability of order ï¬nding and factorization for every valid input N with respect to input size n from 2 to 10 bits.
We draw the bounds certiï¬ed in Coq as red curves. Whenever the simulation is possible with DDSIM, we draw the empirical
bounds as red circles. Otherwise, we compute the corresponding bounds using analytical formulas with concrete inputs. These
bounds are drawn as blue intervals called empirical ranges (i.e., minimal to maximal success probability) for each input size.

7/18

OpenQASMOCamlExecutableOpenQASM35qubits~22k gatesğ‘=15OCamlExecutableOpenQASM29qubits~11k gatesMachinesLow-level CodeRCIRSQIRCertified CodeInputQPUCPUHigh-level CodeOutputOrder finding (OF) exampleOF circuitconstructorOF post-processingSimulation resultsEstimated 2ğ‘šâ‹…ğ‘˜/ğ‘ŸFrequencyorder foundorder not foundFactorization (FAC) example(a)(b)(c)ğ‘=3ğ‘=7SimulatorPCFAC circuitconstructorFAC post-processingSimulatorPCEmpirical vs. certified FAC success probability w.r.t.inputsizeProbabilityğ‘›=logğ‘ğ‘=15ğ‘=21ğ‘=51ğ‘=55ğ‘=63ğ‘=105ğ‘=77ğ‘=255ğ‘›=logğ‘Empirical vs. certified OFsuccess probability w.r.t.inputsizeğ‘=3ğ‘=2ğ‘=41ğ‘=18ğ‘=21ğ‘=4ğ‘=15ğ‘=7ğ‘=7ğ‘=3ğ‘=61ğ‘=39ğ‘=170ğ‘=99ğ‘=384ğ‘=101ğ‘=1020ğ‘=97ProbabilityEmpirical vs. certified OF&FACgate countw.r.t.inputsizeğ‘›=logğ‘CircuitconstructorPre-& post-processingCoqGateCountOrderFinding:ğ‘,ğ‘â†’theorderofğ‘moduloğ‘Factorization:ğ‘â†’anon-trivialfactorofğ‘Simulation resultsa non-trivial factor foundno non-trivial factor foundEstimated 2ğ‘šâ‹…ğ‘˜/ğ‘ŸRandomlySampledğ‘x86-64better than certiï¬ed ones for studied instances. The latter is
likely due to the non-optimality of our proofs in Coq and the
fact that we only investigated small-size instances.

4 Conclusions

The nature of quantum computing makes programming, test-
ing, and debugging quantum programs difï¬cult, and this dif-
ï¬culty is exacerbated by the error-prone nature of quantum
hardware. As a long-term remedy to this problem, we propose
to use formal methods to mathematically certify that quantum
programs do what they are meant to. To this end, we have
leveraged prior formal methods work for classical programs,
and extended it to work on quantum programs. As a showcase
of the feasibility of our proposal, we have developed the ï¬rst
formally certiï¬ed end-to-end implementation of Shorâ€™s prime
factorization algorithm.

The complexity of software engineering of quantum ap-
plications would grow signiï¬cantly with the development of
quantum machines in the near future. We believe that our
proposal is a principled approach to mitigating human er-
rors in this critical domain and achieving high assurance for
important quantum applications.

Acknowledgement

We thank Andrew Childs, Steven Girvin, Liang Jiang, and Pe-
ter Shor for helpful feedback on the manuscript. This material
is based upon work supported by the Air Force Ofï¬ce of Scien-
tiï¬c Research under award number FA95502110051, the U.S.
Department of Energy, Ofï¬ce of Science, Ofï¬ce of Advanced
Scientiï¬c Computing Research, Quantum Testbed Pathï¬nder
Program under Award Number DE-SC0019040, and the U.S.
National Science Foundation grant CCF-1942837 (CAREER).
Any opinions, ï¬ndings, conclusions, or recommendations ex-
pressed in this material are those of the author(s) and do not
necessarily reï¬‚ect the views of these agencies.

References

1. Campbell, E. T., Terhal, B. M. & Vuillot, C. Roads
towards fault-tolerant universal quantum computation.
Nature 549, 172â€“179 (2017). URL https://doi.or
g/10.1038/nature23460.

2. Terhal, B. M. Quantum error correction for quantum
memories. Rev. Mod. Phys. 87, 307â€“346 (2015). URL
https://link.aps.org/doi/10.1103/Rev
ModPhys.87.307.

3. Hoare, T. The verifying compiler: A grand challenge for
computing research. J. ACM 50, 63â€“69 (2003). URL
https://doi.org/10.1145/602382.602403.

4. De Millo, R. A., Lipton, R. J. & Perlis, A. J. Social
processes and proofs of theorems and programs. Commun.
ACM 22, 271â€“280 (1979). URL https://doi.org/
10.1145/359104.359106.

5. Klein, G. et al. SeL4: Formal veriï¬cation of an OS kernel.
In Proceedings of the ACM SIGOPS 22nd Symposium
on Operating Systems Principles, SOSP â€™09, 207â€“220
(Association for Computing Machinery, New York, NY,
USA, 2009). URL https://doi.org/10.1145/
1629575.1629596.

6. Leroy, X. Formal veriï¬cation of a realistic compiler.
Commun. ACM 52, 107â€“115 (2009). URL https://
doi.org/10.1145/1538788.1538814.

7. Yang, X., Chen, Y., Eide, E. & Regehr, J. Finding and
understanding bugs in c compilers. In Proceedings of the
32nd ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation, PLDI â€™11, 283â€“294
(Association for Computing Machinery, New York, NY,
USA, 2011). URL https://doi.org/10.1145/
1993498.1993532.

8. Gonthier, G. et al. Formal proofâ€“the four-color theorem.

Notices of the AMS 55, 1382â€“1393 (2008).

9. Castelvecchi, D. Mathematicians welcome computer-
assisted proof in â€˜grand uniï¬cationâ€™ theory. Nature 595,
18â€“19 (2021).

10. Hartnett, K. Proof assistant makes jump to big-league
math. https://www.quantamagazine.org/l
ean-computer-program-confirms-peter-
scholze-proof-20210728/ (2021).

11. Coq Development Team, T. The Coq Proof Assistant
Reference Manual, version 8.13 (2021). URL http:
//coq.inria.fr.

12. Hietala, K., Rand, R., Hung, S.-H., Wu, X. & Hicks, M.
A veriï¬ed optimizer for quantum circuits. Proc. ACM
Program. Lang. 5 (2021). URL https://doi.org/
10.1145/3434318.

13. Cross, A. W., Bishop, L. S., Smolin, J. A. & Gambetta,
J. M. Open quantum assembly language. arXiv preprint
arXiv:1707.03429 (2017).

14. Hietala, K., Rand, R., Hung, S.-H., Li, L. & Hicks, M.
Proving quantum programs correct. In Proceedings of the
Conference on Interative Theorem Proving (ITP) (2021).

15. Grover, L. K. A fast quantum mechanical algorithm for
database search. In Proceedings of the Twenty-Eighth
Annual ACM Symposium on Theory of Computing, STOC
â€™96, 212â€“219 (Association for Computing Machinery,
New York, NY, USA, 1996). URL https://doi.or
g/10.1145/237814.237866.

16. Shor, P. W. Polynomial-time algorithms for prime factor-
ization and discrete logarithms on a quantum computer.
SIAM J. Comput. 26, 1484â€“1509 (1997). URL https:
//doi.org/10.1137/S0097539795293172.

17. Paykin, J., Rand, R. & Zdancewic, S. Qwire: A core
language for quantum circuits. In Proceedings of the 44th
ACM SIGPLAN Symposium on Principles of Program-
ming Languages, POPL 2017, 846â€“858 (Association for

8/18

Computing Machinery, New York, NY, USA, 2017). URL
https://doi.org/10.1145/3009837.3009
894.

18. Liu, J. et al. Formal veriï¬cation of quantum algorithms
using quantum hoare logic. In Dillig, I. & Tasiran, S.
(eds.) Computer Aided Veriï¬cation, 187â€“207 (Springer
International Publishing, Cham, 2019).

19. Unruh, D. Quantum relational hoare logic. Proc. ACM
Program. Lang. 3 (2019). URL https://doi.org/
10.1145/3290346.

20. Chareton, C., Bardin, S., Bobot, F., Perrelle, V. & Val-
iron, B. An automated deductive veriï¬cation framework
for circuit-building quantum programs. Programming
Languages and Systems: 30th European Symposium on
Programming, ESOP 2021, Held as Part of the European
Joint Conferences on Theory and Practice of Software,
ETAPS 2021, Luxembourg City, Luxembourg, March 27
â€“April 1, 2021, Proceedings 12648, 148â€“177 (2021). URL
https://www.ncbi.nlm.nih.gov/pmc/art
icles/PMC7984546/.

21. Gidney, C. & EkerËša, M. How to factor 2048 bit RSA in-
tegers in 8 hours using 20 million noisy qubits. Quantum
5, 433 (2021). URL https://doi.org/10.22331
/q-2021-04-15-433.

algorithm using photonic qubits. Physical Review Letters
99, 250504 (2007).

32. Lanyon, B. P. et al. Experimental demonstration of a
compiled version of shorâ€™s algorithm with quantum en-
tanglement. Physical Review Letters 99, 250505 (2007).

33. Lucero, E. et al. Computing prime factors with a joseph-
son phase qubit quantum processor. Nature Physics 8,
719â€“723 (2012).

34. Monz, T. et al. Realization of a scalable shor algorithm.

Science 351, 1068â€“1070 (2016).

35. Martin-Lopez, E. et al. Experimental realization of shorâ€™s
quantum factoring algorithm using qubit recycling. Na-
ture photonics 6, 773â€“776 (2012).

36. Curry, H. B. Functionality in combinatory logic. Proceed-
ings of the National Academy of Sciences of the United
States of America 20, 584 (1934).

37. Howard, W. A. The formulÃ¦-as-types notion of construc-
tion. In Groote, P. D. (ed.) The Curry-Howard Isomor-
phism (Academia, 1995).

38. De Bruijn, N. G. The mathematical language AU-
In
TOMATH, its usage, and some of its extensions.
Symposium on automatic demonstration, 29â€“61 (Springer,
1970).

22. Paninski, L. A coincidence-based test for uniformity
given very sparsely sampled discrete data. IEEE Transac-
tions on Information Theory 54, 4750â€“4755 (2008).

39. Milner, R. Implementation and applications of Scottâ€™s
logic for computable functions. ACM sigplan notices 7,
1â€“6 (1972).

23. Lloyd, S. Universal quantum simulators. Science 273,

1073â€“1078 (1996).

24. Ruiz, A. L., Morales, E. C., Roure, L. P. & RÂ´Ä±os, A. G.

Algebraic circuits (Springer, 2014).

25. De Rauglaudre, D. Coq proof of the euler product formula
for the riemann zeta function. https://github.c
om/roglo/coq euler prod form (2020).

26. Hardy, G. H. & Wright, E. M. An Introduction to the

Theory of Numbers (Oxford, 1975), fourth edn.

27. Bauer, A. Five stages of accepting constructive mathe-
matics. Bulletin of the American Mathematical Society
(2016).

28. JKQ DDSIM â€“ a quantum circuit simulator based on
decision diagrams written in C++. https://github
.com/iic-jku/ddsim (2021).

29. Program extraction. https://coq.inria.fr/r
efman/addendum/extraction.html. Accessed:
2021-09-24.

30. Vandersypen, L. M. et al. Experimental realization of
shorâ€™s quantum factoring algorithm using nuclear mag-
netic resonance. Nature 414, 883â€“887 (2001).

31. Lu, C.-Y., Browne, D. E., Yang, T. & Pan, J.-W. Demon-
stration of a compiled version of shorâ€™s quantum factoring

40. Coquand, T. & Huet, G. Constructions: A higher order
In Buch-
proof system for mechanizing mathematics.
berger, B. (ed.) EUROCAL â€™85, 151â€“184 (Springer Berlin
Heidelberg, Berlin, Heidelberg, 1985).

41. Inria, CNRS and contributors. Calculus of inductive
constructions. URL https://coq.inria.fr/dis
trib/current/refman/language/cic.html.
Accessed: 2021-12-10.

42. Bhargavan, K. et al. Everest: Towards a veriï¬ed, drop-in
replacement of HTTPS. In 2nd Summit on Advances in
Programming Languages (2017). URL http://drop
s.dagstuhl.de/opus/volltexte/2017/71
19/pdf/LIPIcs-SNAPL-2017-1.pdf.

43. ZinzindohouÂ´e, J.-K., Bhargavan, K., Protzenko, J. &
Beurdouche, B. Hacl*: A veriï¬ed modern crypto-
graphic library. In Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security,
CCS â€™17, 1789â€“1806 (Association for Computing Ma-
chinery, New York, NY, USA, 2017). URL https:
//doi.org/10.1145/3133956.3134043.

44. mathlib Community, T. The lean mathematical library.
Proceedings of the 9th ACM SIGPLAN International Con-
ference on Certiï¬ed Programs and Proofs (2020). URL
http://dx.doi.org/10.1145/3372885.337
3824.

9/18

45. Castelvecchi, D. Mathematicians welcome computer-
assisted proof in â€˜grand uniï¬cationâ€™ theory. https:
//www.nature.com/articles/d41586-021
-01627-2 (2021).

46. Library Coq.Reals.Reals. https://coq.inria.fr
/library/Coq.Reals.Reals.html. Accessed:
2021-09-24.

47. Boldo, S., Lelay, C. & Melquiond, G. Coquelicot: A user-
friendly library of real analysis for coq. Mathematics
in Computer Science 9, 41â€“62 (2015). URL https:
//doi.org/10.1007/s11786-014-0181-1.

48. Paykin, J., Rand, R. & Zdancewic, S. QWIRE: A core lan-
guage for quantum circuits. SIGPLAN Not. 52, 846â€“858
(2017). URL https://doi.org/10.1145/3093
333.3009894.

49. Knuth, D. E. The Art of Computer Programming, Volume
1 (3rd Ed.): Fundamental Algorithms (Addison Wesley
Longman Publishing Co., Inc., USA, 1997).

50. Cuccaro, S. A., Draper, T. G., Kutin, S. A. & Moulton,
D. P. A new quantum ripple-carry addition circuit. arXiv

preprint quant-ph/0410184 (2004).

51. Draper, T. G. Addition on a quantum computer. arXiv

preprint quant-ph/0008033 (2000).

52. Draper, T. G., Kutin, S. A., Rains, E. M. & Svore, K. M. A
logarithmic-depth quantum carry-lookahead adder. arXiv
preprint quant-ph/0406142 (2004).

53. Van Meter, R. & Itoh, K. M. Fast quantum modular

exponentiation. Physical Review A 71, 052320 (2005).

54. Pavlidis, A. & Gizopoulos, D. Fast quantum modular
exponentiation architecture for shorâ€™s factorization algo-
rithm. arXiv preprint arXiv:1207.0511 (2012).

55. Rosser, J. B. & Schoenfeld, L. Approximate formulas
for some functions of prime numbers. Illinois J. Math. 6,
64â€“94 (1962). URL https://doi.org/10.1215/
ijm/1255631807.

56. Boldo, S. & Melquiond, G. Flocq: A uniï¬ed library
In 2011
for proving ï¬‚oating-point algorithms in coq.
IEEE 20th Symposium on Computer Arithmetic, 243â€“252
(2011).

10/18

Supplementary Materials

All codes in the implementation are available at http
s://github.com/inQWIRE/SQIR/tree/main/
examples/shor. The entire implementation includes
approximately 14k lines of code.

A Preliminaries in Formal Methods

We assume a background in quantum computing.

A.1 Proof Assistants
A proof assistant is a software tool for formalizing mathe-
matical deï¬nitions and stating and proving properties about
them. A proof assistant may produce proofs automatically
or assist a human in doing so, interactively. Either way, the
proof assistant conï¬rms that a proof is correct by employing a
proof veriï¬er. Since a proofâ€™s correctness relies on the veriï¬er
being correct, a veriï¬er should be small and simple and the
logical rules it checks should be consistent (which is usually
proved meta-theoretically).

Most modern proof assistants implement proof veriï¬ca-
tion by leveraging the Curry-Howard correspondence, which
embodies a surprising and powerful analogy between formal
logic and programming language type systems36, 37. In par-
ticular, logical propositions are analogous to programming
language types, and proofs are analogous to programs. As an
example, the logical implication in proof behaves like a func-
tion in programs: Given a proof (program expression a) of
proposition (type) A, and a proof that A implies B (a function
f of type A â†’ B), we can prove the proposition B (produce a
program expression of type B, i.e., via the expression f (a)).
We can thus represent a proof of a logical formula as a typed
expression whose type corresponds to the formula. As a re-
sult, proof veriï¬cation is tantamount to (and implemented as)
program type checking.

Machine-aided proofs date back to the Automath project
by de Bruijn38, which was the ï¬rst practical system exploiting
the Curry-Howard correspondence. Inspired by Automath,
interactive theorem provers (ITPs) emerged. Most modern
proof assistants are ITPs. Milner proposed Stanford LCF39,
introducing proof tactics, which allow users to specify partic-
ular automated proof search procedures when constructing a
proof. A tactic reduces the current proof goal to a list of new
subgoals. The process of producing a machine-aided proof
is to sequentially apply a list of tactics to transform a proof
goal into predeï¬ned axioms. Users have direct access to the
intermediate subgoals to decide which tactic to apply.

While ITPs were originally developed to formalize mathe-
matics, the use of the Curry-Howard correspondence makes
it straightforward to also support writing proved-correct, i.e.,
veriï¬ed, computer programs. These programs can be extracted
into runnable code from the notation used to formalize them
in the proof assistant.

Modern ITPs are based on different variants of type the-
ories. The ITP employed in this project, Coq40, is based

on the Calculus of Inductive Constructions41. Coq features
propositions as types, higher order logic, dependent types,
and reï¬‚ections. A variety of proof tactics are included in Coq,
like induction. These features have made Coq widely used by
the formal methods community.

Coq is a particularly exciting tool that has been used both
to verify complex programs and to prove hard mathematical
theorems. The archetype of a veriï¬ed program is the Com-
pCert compiler6. CompCert compiles code written in the
widely used C programming language to instruction sets for
ARM, x86, and other computer architectures. Importantly,
CompCertâ€™s design precisely reï¬‚ects the intended program
behaviorâ€”the semanticsâ€”given in the C99 speciï¬cation, and
all of its optimizations are guaranteed to preserve that be-
havior. Coq has also been used to verify proofs of the no-
toriously hard-to-check Four Color Theorem, as well as the
Feitâ€“Thompson (or odd order) theorem. Coqâ€™s dual uses for
both programming and mathematics make it an ideal tool for
verifying quantum algorithms.

Coq isnâ€™t the only ITP with a number of success stories.
The Fâˆ— language is being used to certify a signiï¬cant number
of internet security protocols, including Transport Layer Secu-
rity (TLS)42 and the High Assurance Cryptographic Library,
HACLâˆ—43, which has been integrated into the Firefox web
browser. Isabelle/HOL was used to verify the seL4 operating
system kernel5. The Lean proof assistant (also based on the
Calculus of Inductive Constructions) has been used to verify
essentially the entire undergraduate mathematics curriculum
and large parts of a graduate curriculum44. Indeed, Lean has
reached the point where it can verify cutting-edge proofs, in-
cluding a core theorem in Peter Scholzeâ€™s theory of condensed
mathematics, ï¬rst proven in 201910, 45. Our approach to certi-
fying quantum programs could be implemented using these
other tools as well.

A.2 SQIR
To facilitate proofs about quantum programs, we developed
the small quantum intermediate representation (SQIR)12, 14,
a circuit-oriented programming language embedded in Coq,
which means that a SQIR program is deï¬ned as a Coq data
structure speciï¬ed using a special syntax, and the semantics
of a SQIR program is deï¬ned as a Coq function over that
data structure (details below). We construct quantum circuits
using SQIR, and then state and prove speciï¬cations using our
Coq libraries for reasoning about quantum programs. SQIR
programs can be extracted to OpenQASM 2.013, a standard
representation for quantum circuits executable on quantum
machines.

A SQIR program is a sequence of gates applied to natural
number arguments, referring to names (labels) of qubits in
a global register. Using predeï¬ned gates SKIP (no-op), H
(Hadamard), and CNOT (controlled not) in SQIR, a circuit that
generates the Greenbergerâ€“Horneâ€“Zeilinger (GHZ) state with
three qubits in Coq is deï¬ned by

Definition GHZ3 : ucom base 3 := H 0; CNOT 0 1; CNOT 0 2.

11/18

The type ucom base 3 says that the resulting circuit is a uni-
tary program that uses our base gate set and three qubits.
Inside this circuit, three gates are sequentially applied to the
qubits. More generally, we could write a Coq function that
produces a GHZ state generation circuit: Given a parameter
n, function GHZ produces the n-qubit GHZ circuit.
Fixpoint GHZ (n : N) : ucom base n :=

match n with
| 0 â‡’ SKIP
| 1 â‡’ H 0
| S (S n') â‡’ GHZ (S n'); CNOT n' (S n')
end.

These codes deï¬ne a recursive prograom GHZ on one natural
number input n through the use of match statement. Speciï¬-
cally, match statement returns SKIP when n=0, H 0 when
n=1, and recursively calls on itself for n-1 otherwise. One
can observe that GHZ 3 (calling GHZ with argument 3) will
produce the same SQIR circuit as deï¬nition GHZ3, above.

The function uc_eval deï¬nes the semantics of a SQIR
program, essentially by converting it to a unitary matrix of
complex numbers. This matrix is expressed using axiomatized
reals from the Coq Standard Library46, complex numbers from
Coquelicot47, and the complex matrix library from QWIRE48.
Using uc_eval, we can state properties about the behavior
of a circuit. For example, the speciï¬cation for GHZ says that
it produces the mathematical GHZ state when applied to the
all-zero input.
Theorem GHZ_correct : âˆ€ n : N, 0 < n â†’

uc_eval (GHZ n) Ã— |0(cid:105)âŠ—n = 1âˆš

2 * |1(cid:105)âŠ—n.
This theorem can be proved in Coq by induction on n.

2 * |0(cid:105)âŠ—n + 1âˆš

To date, SQIR has been used to implement and verify a num-
ber of quantum algorithms14, including quantum teleportation,
GHZ state preparation, the Deutsch-Jozsa algorithm, Simonâ€™s
algorithm, the quantum Fourier transform (QFT), Groverâ€™s
algorithm, and quantum phase estimation (QPE). QPE is a key
component of Shorâ€™s prime factoring algorithm (described in
the next section), which ï¬nds the eigenvalue of a quantum
programâ€™s eigenstates.

Using SQIR, we deï¬ne QPE as follows:

Fixpoint controlled_powers {n} f k kmax :=

match k with
â‡’ SKIP
| 0
| 1
â‡’ control (kmax-1) (f O)
| S k' â‡’ controlled_powers f k' kmax ;

control (kmax-k'-1) (f k')

end.

Definition QPE k n (f : N â†’ base_ucom n) :=

let f' := (fun x â‡’ map_qubits (fun q â‡’ k+q) (f x)) in
npar k U_H ;
controlled_powers f' k k ;
invert (QFT k).

QPE takes as input the precision k of the resulting estimate,
the number n of qubits used in the input program, and a
circuit family f. QPE includes three parts: (1) k parallel
applications of Hadamard gates; (2) exponentiation of the
target unitary; (3) an inverse QFT procedure. (1) and (3) are
implemented by recursive calls in SQIR. Our implementation

of (2) inputs a mapping from natural numbers representing
which qubit is the control, to circuits implementing repetitions
of the target unitary, since normally the exponentiation is
decomposed into letting the x-th bit control 2x repetition of
the target unitary. Then controlled_powers recursively
calls itself, in order to map the circuit family on the ï¬rst n
qubits to the exponentiation circuit. In Shorâ€™s algorithm, (2)
is efï¬ciently implemented by applying controlled in-place
modular multiplications with pre-calculated multipliers. The
correctness of QPE is also elaborated14.

B Shorâ€™s Algorithm and Its Implementation

Shorâ€™s factorization algorithm consists of two parts. The
ï¬rst employs a hybrid classical-quantum algorithm to solve
the order ï¬nding problem; the second reduces factorization to
order ï¬nding. In this section, we present an overview of Shorâ€™s
algorithm (see Figure 2 for a summary). In next sections, we
discuss details about our implementation (see Figure 3) and
certiï¬ed correctness properties.

B.1 A Hybrid Algorithm for Order Finding
The multiplicative order of a modulo N, represented by
ord(a, N), is the least integer r larger than 1 such that ar â‰¡ 1
(mod N). Calculating ord(a, N) is hard for classical comput-
ers, but can be efï¬ciently solved with a quantum computer,
for which Shor proposed a hybrid classical-quantum algo-
rithm16. This algorithm has three major components: (1)
in-place modular multiplication on a quantum computer; (2)
quantum phase estimation; (3) continued fraction expansion
on a classical computer.

In-place Modular Multiplication An in-place modular mul-
tiplication operator IMM(a, N) on n working qubits and s
ancillary qubits satisï¬es the following property:

âˆ€x < N, IMM(a, N)|x(cid:105)n|0(cid:105)s = |(a Â· x) mod N(cid:105)n|0(cid:105)s,

where 0 < N < 2nâˆ’1. It is required that a and N are co-prime,
otherwise the operator is irreversible. This requirement im-
plies the existence of a multiplicative inverse aâˆ’1 modulo N
such that a Â· aâˆ’1 â‰¡ 1 (mod N).

Quantum Phase Estimation Given a subroutine U and an
eigenvector |Ïˆ(cid:105) with eigenvalue eiÎ¸ , quantum phase estima-
2Ï€ 2m with high success
tion (QPE) ï¬nds the closest integer to Î¸
probability, where m is a predeï¬ned precision parameter.

Shorâ€™s algorithm picks a random a from [1, N) ï¬rst, and
applies QPE on IMM(a, N) on input state |0(cid:105)m |1(cid:105)n |0(cid:105)s where
m = (cid:98)log2 2N2(cid:99), n = (cid:98)log2 2N(cid:99) and s is the number of ancil-
lary qubits used in IMM(a, N). Then a computational basis
measurement is applied on the ï¬rst m qubits, generating an
output integer 0 â‰¤ out < 2m. The distribution of the out-
put has ord(a, N) peaks, and these peaks are almost equally
spaced. We can extract the order by the following procedure.

12/18

Continued Fraction Expansion The post-processing of
Shorâ€™s algorithm invokes the continued fraction expansion
(CFE) algorithm. A k-level continued fraction is deï¬ned re-
cursively by

can be efï¬ciently computed by a classical computer49. By
repeating the random selection of a and the above procedure
for constant times, the success probability to ï¬nd a non-trivial
factor of N is close to 1.

(cid:104)(cid:105) = 0,

(cid:104)a1, a2, ..., ak(cid:105) =

1
a1 + (cid:104)a2, a3, ..., ak(cid:105)

.

k-step CFE ï¬nds a k-level continued fraction to approximate
a given real number. For a rational number 0 â‰¤ a
b < 1, the
ï¬rst term of the expansion is (cid:98) b
a (cid:99) if a (cid:54)= 0, and we recursively
expand b mod a
for at most k times to get an approximation of
a
b by a k-level continued fraction. In Coq, the CFE algorithm
is implemented as
Fixpoint CFE_ite (k a b p1 q1 p2 q2 : N) : N Ã— N :=

a

match k with
| 0 â‡’ (p1, q1)
| S k' â‡’ if a = 0 then (p1, q1)
else let (c, d) := ((cid:98) b
CF_ite k' d a (c Â· p1 + p2) (c Â· q1 + q2) p1 q1

a (cid:99), b mod a) in

end.

Definition CFE k a b := snd (CF_ite (k+1) a b 0 1 1 0).

Function CFE_ite takes in the number of iterations k, target
fraction a/b, the fraction from the (k âˆ’ 1)-step expansion,
and the (k âˆ’ 2)-step expansion. Function CFE k a b represents
the denominator in the simpliï¬ed fraction equal to the k-level
continued fraction that is the closest to a
b .

The post-processing of Shorâ€™s algorithm expands out
2m us-
ing CFE, where out is the measurement result and m is the
precision for QPE deï¬ned above. It ï¬nds the minimal step k
such that aCFE k out 2m
â‰¡ 1 (mod N) and k â‰¤ 2m + 1. With
probability no less than 1/polylog(N), there exists k such that
CFE k out 2m is the multiplicative order of a modulo N.
We can repeat the QPE and post-processing for polylog(N)
times. Then the probability that the order exists in one of
the results can be arbitrarily close to 1. The minimal valid
post-processing result is highly likely to be the order.

B.2 Reduction from Factorization to Order Finding
To completely factorize composite number N, we only need
to ï¬nd one non-trivial factor of N (i.e., a factor that is not
1 nor N). If a non-trivial factor d of N can be found, we
can recursively solve the problem by factorizing d and N
d
separately. Because there are at most log2(N) prime factors
of N, this procedure repeats for at most polylog(N) times. A
classical computer can efï¬ciently ï¬nd a non-trivial factor in
the case where N is even or N = pk for prime p. However,
Shorâ€™s algorithm is the only known (classical or quantum)
algorithm to efï¬ciently factor numbers for which neither of
these is true.

Shorâ€™s algorithm randomly picks an integer 1 â‰¤ a < N. If
the greatest common divisor gcd(a, N) of a and N is a non-
trivial factor of N, then we are done. Otherwise we invoke the
hybrid order ï¬nding procedure to ï¬nd ord(a, N). With prob-
(cid:17)
(cid:17)

ability no less than one half, one of gcd
is a non-trivial factor of N. Note that gcd

(cid:16)
a(cid:98) ord(a,N)
(cid:16)
a(cid:98) ord(a,N)

(cid:99) Â± 1, N
(cid:99) Â± 1, N

2

2

B.3 Implementation of Modular Multiplication
One of the pivoting components of Shorâ€™s order ï¬nding proce-
dure is a quantum circuit for in-place modular multiplication
(IMM). We initially tried to deï¬ne this operation in SQIR
but found that for purely classical operations (that take ba-
sis states to basis states), SQIRâ€™s general quantum semantics
makes proofs unnecessarily complicated. In response, we
developed the reversible circuit intermediate representation
(RCIR) to express classical functions and prove their correct-
ness. RCIR programs can be translated into SQIR, and we
prove this translation correct.

RCIR contains a universal set of constructs on classical

RCIR
bits labeled by natural numbers. The syntax is:

R := skip | X n | ctrl n R | swap m n | R1; R2.

Here skip is a unit operation with no effect, X n ï¬‚ips the n-th
bit, ctrl n R executes subprogram R if the n-th bit is 1 and
otherwise has no effect, swap m n swaps the m-th and n-th
bits, and R1; R2 executes subprograms R1 and R2 sequentially.
We remark that swap is not necessary for the expressiveness
of the language, since it can be decomposed into a sequence of
three ctrl and X operations. We include it here to facilitate
swap-speciï¬c optimizations of the circuit.

As an example, we show the RCIR code for the MAJ (ma-
jority) operation50, which is an essential component of the
ripple-carry adder.

Definition MAJ a b c :=

ctrl c (X b) ; ctrl c (X a) ; ctrl a (ctrl b (X c)).

It takes in three bits labeled by a, b, c whose initial val-
ues are va, vb, vc correspondingly, and stores va xor vc
in a, vb xor vc in b, and MAJ(va, vb, vc) in c. Here
MAJ(va, vb, vc) is the majority of va, vb and vc, the value that
appears at least twice.

To reverse a program written in this syntax, we deï¬ne
a reverse operator by skiprev = skip, (X n)rev = X n,
(ctrl n R)rev = ctrl n Rrev, (swap m n)rev = swap m n,
; Rrev
(R1; R2)rev = Rrev
. We prove that the reversed circuit
1
will cancel the behavior of the original circuit.

2

We can express the semantics of a RCIR program as a func-
tion between Boolean registers. We use notation [k]n to repre-
sent an n-bit register storing natural number k < 2n in binary
representation. Consecutive registers are labeled sequentially
by natural numbers. If n = 1, we simplify the notation to [0]
or [1].

The translation from RCIR to SQIR is natural since every
RCIR construct has a direct correspondence in SQIR. The
correctness of this translation states that the behavior of a
well-typed classical circuit in RCIR is preserved by the gen-
erated quantum circuit in the context of SQIR. That is, the

13/18

translated quantum circuit turns a state on the computational
basis into another one corresponding to the classical state after
the execution of the classical reversible circuit.

Details of IMM Per Appendix B.1, the goal is to construct a
reversible circuit IMMc(a, N) in RCIR satisfying

âˆ€x < N,

[x]n[0]s

IMMc(a,N)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ [a Â· x mod N]n[0]s.

so that we can translate it into a quantum circuit in SQIR.
Adapting the standard practice24, we implement modular mul-
tiplication based on repeated modular additions. For addition,
we use Cuccaro et al.â€™s ripple-carry adder (RCA)50. RCA
realizes the transformation

[c][x]n[y]n

RCAâˆ’âˆ’â†’ [c][x]n[(x + y + c) mod 2n]n,
for ancillary bit c âˆˆ {0, 1} and inputs x, y < 2nâˆ’1. We use Cu-
carro et al.â€™s RCA-based deï¬nitions of subtractor (SUB) and
comparator (CMP), and we additionally provide a n-qubit reg-
ister swapper (SWP) and shifter (SFT) built using swap gates.
These components realize the following transformations:

[0][x]n[y]n

[0][x]n[y]n

[x]n[y]n

[x]n

SUBâˆ’âˆ’â†’ [0][x]n[(y âˆ’ x) mod 2n]n
CMPâˆ’âˆ’âˆ’â†’ [x â‰¥? y][x]n[y]n
SW Pâˆ’âˆ’â†’ [y]n[x]n
SFTâˆ’âˆ’â†’ [2x]n

Here x â‰¥? y = 1 if x â‰¥ y, and 0 otherwise. SFT is correct
only when x < 2nâˆ’1. With these components, we can build a
modular adder (ModAdd) and modular shifter (ModSft) using
two ancillary bits at positions 0 and 1.
Definition ModAdd n :=

SWP02 n; RCA n; SWP02 n; CMP n;
ctrl 1 (SUB n); SWP02 n; (CMP n)rev; SWP02 n.
Definition ModSft n := SFT n; CMP n; ctrl 1 (SUB n).

SWP02 is the register swapper applied to the ï¬rst and third
n-bit registers. These functions realize the following transfor-
mations:

[0][0][N]n[x]n[y]n

[0][0][N]n[x]n

ModAdd
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ [0][0][N]n[x]n[(x + y) mod N]n
ModSft
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ [0][N â‰¤? 2x][N]n[2x mod N]n

Note that (a Â· x) mod N can be decomposed into
(cid:32)nâˆ’1
âˆ‘
i=0

(1 â‰¤? ai) Â· 2i Â· x

(a Â· x) mod N =

(cid:33)

mod N,

where ai is the i-th bit in the little-endian binary representation
of a. By repeating ModSfts and ModAdds, we can perform
(a Â· x) mod N according to this decomposition, eventually gen-
erating a circuit for modular multiplication on two registers
(MM(a, N)), which implements

[x]n[0]n[0]s

MM(a,N)
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ [x]n[a Â· x mod N]n[0]s.

Here s is the number of additional ancillary qubits, which is
linear to n. Finally, to make the operation in-place, we exploit
the modular inverse aâˆ’1 modulo N:
Definition IMM a N n :=

MM a N n; SWP01 n; (MM aâˆ’1 N n)rev.

There is much space left for optimization in this implemen-
tation. Other approaches in the literature21, 51â€“54 may have a
lower depth or fewer ancillary qubits. We chose this approach
because its structure is cleaner to express in our language, and
its asymptotic complexity is feasible for efï¬cient factorization,
which makes it great for mechanized proofs.

B.4 Implementation of Shorâ€™s algorithm
Our ï¬nal deï¬nition of Shorâ€™s algorithm in Coq uses the IMM
operation along with a SQIR implementation of QPE described
in the previous sections. The quantum circuit to ï¬nd the
multiplicative order ord(a, N) is then

Definition shor_circuit a N :=

let m := log2 (2*NË†2) in
let n := log2 (2*N) in
let f i := IMM (modexp a (2Ë†i) N) N n in
X (m + n - 1); QPE m f.

We can extract the distribution of the result of the random
procedure of Shorâ€™s factorization algorithm
Definition factor (a N r : N) :=

let cand1 := Nat.gcd (a Ë† (r / 2) - 1) N in
let cand2 := Nat.gcd (a Ë† (r / 2) + 1) N in
if (1 <? cand1) && (cand1 <? N) then Some cand1
else if (1 <? cand2) && (cand2 <? N) then Some cand2
else None.

Definition shor_body N rnd :=
let m := log2 (2*NË†2) in
let k := 4*log2 (2*N)+11 in
let distr := join (uniform 1 N)

(fun a â‡’ run (to_base_ucom (m+k)
(shor_circuit a N))) in

let out := sample distr rnd in
let a := out / 2Ë†(m+k)) in
let x := (out mod (2Ë†(m+k))) / 2Ë†k in
if Nat.gcd a N =? 1%N
then factor a N (OF_post a N x n)
else Some (Nat.gcd a N).

Definition end_to_end_shor N rnds :=

iterate rnds (shor_body N).

Here factor is the reduction ï¬nding non-trivial factors
from multiplicative order, shor body generates the distribu-
tion and sampling from it, and end to end shor iterates
shor body for multiple times and returns a non-trivial factor
if any of them succeeds.

C Certiï¬cation of the Implementation

In this section, we summarize the facts we have proved in Coq
in order to fully verify Shorâ€™s algorithm, as presented in the
previous section.

14/18

C.1 Certifying Order Finding
For the hybrid order ï¬nding procedure in Appendix B.1, we
verify that the success probability is at least 1/polylog(N).
Recall that the quantum part of order ï¬nding uses in-place
modular multiplication (IMM(a, N)) and quantum phase esti-
mation (QPE). The classical part applies continued fraction
expansion to the outcome of quantum measurements. Our
statement of order ï¬nding correctness says:

Lemma Shor_OF_correct :

âˆ€ (a N : N),

(1 < a < N) â†’ (gcd a N = 1) â†’
P[Shor_OF a N = ord a N] â‰¥
(cid:98)log2 (N)(cid:99)4 .

Î²

where Î² = 4eâˆ’2
Ï€2 . The probability sums over possible outputs
of the quantum circuit and tests if post-processing ï¬nds ord
a N.

Certifying IMM We have proved that our RCIR implemen-
tation of IMM satisï¬es the equation given in Appendix B.3.
Therefore, because we have a proved-correct translator from
RCIR to SQIR, our SQIR translation of IMM also satisï¬es
this property. In particular, the in-place modular multiplica-
tion circuit IMM(a, N) with n qubits to represent the register
and s ancillary qubits, translated from RCIR to SQIR, has the
following property for any 0 â‰¤ N < 2n and a âˆˆ ZN:
Definition IMMBehavior a N n s c :=

âˆ€ x : N, x < N â†’

(uc_eval c) Ã— (|x(cid:105)n âŠ— |0(cid:105)s) = |a Â· x mod N(cid:105)n âŠ— |0(cid:105)s.

Lemma IMM_correct a N :=
let n := log2 (2*N) in
let s := 3*n + 11 in
IMMBehavior a N n s (IMM a n).

Here IMMBehavior depicts the desired behavior of an in-
place modular multiplier, and we have proved the constructed
IMM(a, N) satisï¬es this property.

Certifying QPE over IMM We certify that QPE outputs the
closest estimate of the eigenvalueâ€™s phase corresponding to
the input eigenvector with probability no less than 4
Ï€2 :

Lemma QPE_semantics :

âˆ€ m n z Î´ (f : N â†’ base_ucom n) (|Ïˆ(cid:105) : Vector 2n),

n > 0 â†’ m > 1 â†’ âˆ’ 1
Pure_State_Vector |Ïˆ(cid:105) â†’
(âˆ€ k, k < m â†’

2m+1 â‰¤ Î´ < 1

2m+1 â†’

uc_WT (f k) âˆ§ (uc_eval (f k)) |Ïˆ(cid:105) = e2k+1 Ï€i( z

2m +Î´ ) |Ïˆ(cid:105)) â†’

(cid:107)(cid:104)z, Ïˆ| (uc eval (QPE k n f)) |0, Ïˆ(cid:105)(cid:107)2 â‰¥ 4

Ï€2 .

To utilize this lemma with IMM(a, N), we ï¬rst analyze the
eigenpairs of IMM(a, N). Let r = ord(a, N) be the multiplica-
tive order of a modulo N. We deï¬ne

|Ïˆ j(cid:105)n =

1
r âˆ‘
âˆš

l<r

Ï‰ âˆ’ jÂ·l
r

|al mod N(cid:105)n

in SQIR and prove that it is an eigenvector of any circuit sat-
isfying IMMBehavior, including IMM(a2k
, N), with eigen-
value Ï‰ jÂ·2k
2Ï€i
r
r-th primitive root in the complex plane.

for any natural number k, where Ï‰r = e

is the

r

Lemma IMMBehavior_eigenpair :

âˆ€ (a r N j n s k : N) (c : base_ucom (n+s)),

Order a r N â†’ N < 2n â†’

IMMBehavior a2k
(uc_eval (f k)) |Ïˆj(cid:105)n âŠ— |0(cid:105)s = e2k+1 Ï€i

N n s c â†’

j
r |Ïˆj(cid:105)n âŠ— |0(cid:105)s .

Here Order a r N is a proposition specifying that r is the
order of a modulo N. Because we cannot directly prepare
|Ïˆ j(cid:105), we actually set the eigenvector register in QPE to the
state |1(cid:105)n âŠ— |0(cid:105)s using the identity:
Lemma sum_of_Ïˆ_is_one :

âˆ€ a r N n : N,

Order a r N â†’ N < 2n â†’ 1âˆš

r âˆ‘k<r |Ïˆ j(cid:105)n = |1(cid:105)n.

By applying QPE_semantics, we prove that for any 0 â‰¤ k <
r, with probability no less than 4
Ï€2r , the result of measuring
QPE applied to |0(cid:105)m âŠ— |1(cid:105)n âŠ— |0(cid:105)s is the closest integer to k
r 2m.
Certifying Post-processing Our certiï¬cation of post-
processing is based on two mathematical results (also formally
certiï¬ed in Coq): the lower bound of Eulerâ€™s totient function
and the Legendreâ€™s theorem for continued fraction expansion.
Let Zâˆ—
n be the integers smaller than n and coprime to n. For a
positive integer n, Eulerâ€™s totient function Ï•(n) is the size of
Zâˆ—

n. They are formulated in Coq as follows.

Theorem Euler_totient_lb : âˆ€ n, n â‰¥ 2 â†’ Ï•(n)
Lemma Legendre_CFE :
âˆ€ a b p q : N,

n â‰¥ eâˆ’2

(cid:98)log2 n(cid:99)4 .

a < b â†’ gcd p q = 1 â†’ 0 < q â†’
âˆƒ s, s â‰¤ 2 log2(b) + 1 âˆ§ CFE s a b = q.

(cid:12)
(cid:12)
(cid:12)

a

b âˆ’ p

q

(cid:12)
(cid:12) < 1
(cid:12)

2q2 â†’

The veriï¬cation of these theorems is discussed later.

r 2m for any k âˆˆ Zâˆ—

By Legendreâ€™s theorem for CFE, there exists a s â‰¤ 2m + 1
such that CFE s out 2m = r, where out is the closest integer
to k
r . Hence the probability of obtaining
4
Ï€2r . Note that r â‰¤ Ï•(N) < N.
the order (r) is the sum âˆ‘kâˆˆZâˆ—
r
With the lower bound on Eulerâ€™s totient function, we obtain
a lower bound of 1/polylog(N) of successfully obtaining the
order r = ord(a, N) through the hybrid algorithm, ï¬nishing
the proof of Shor_OF_correct.

Lower Bound of Eulerâ€™s Totient Function We build our
proof on the formalization of Eulerâ€™s product formula and
Eulerâ€™s theorem by de Rauglaudre25. By rewriting Eulerâ€™s
product formula into exponents, we can scale the formula into
1
exponents of Harmonic sequence âˆ‘0<iâ‰¤n
i . Then an upper
bound for the Harmonic sequence sufï¬ces for the result.

In fact, a tighter lower bound of Eulerâ€™s totient function
exists55, but obtaining it involves evolved mathematical tech-
niques which are hard to formalize in Coq since they involved
analytic number theory. Fortunately, the formula certiï¬ed
above is sufï¬cient to obtain a success probability of at least
1/polylog(N) for factorizing N.

Legendreâ€™s Theorem for Continued Fraction Expansion
The proof of Legendreâ€™s theorem consists of facts: (1) CFE s a
b monotonically increases, and reaches b within 2 log2(b) + 1
steps, and (2) for CFE s a b â‰¤ q < CFE (s+1) a b satisfying
(cid:12)
b âˆ’ p
a
(cid:12)
2q2 , the only possible value for q is CFE s a b.
(cid:12)
These are certiï¬ed following basic analysis to the continued
fraction expansion26.

(cid:12)
(cid:12) < 1
(cid:12)

q

15/18

C.2 Certifying Shorâ€™s Reduction
We formally certify that for half of the possible choices of a,
ord a n can be used to ï¬nd a nontrivial factor of N:
Lemma reduction_fact_OF :

âˆ€ (p k q N : N),

k > 0 â†’ prime p â†’ 2 < p â†’ 2 < q â†’
gcd p q = 1 â†’ N = pk âˆ— q â†’
|ZN| â‰¤ 2 Â· âˆ‘aâˆˆZN [1 < gcd (a(cid:98) ord a N

(cid:99) Â± 1) N < N].

2

The expression [1 < (gcd (a(cid:98) ord a N
(cid:99) Â± 1) N) < N]
equals to 1 if at least one of gcd(a(cid:98) ord a N
(cid:99) + 1, N) or
gcd(a(cid:98) ord a N
(cid:99) âˆ’ 1, N) is a nontrivial factor of N, other-
wise it equals to 0. In the following we illustrate how we
achieve this lemma.

2

2

2

From 2-adic Order to Non-Trivial Factors The proof pro-
ceeds as follows: Let d(x) be the largest integer i such that
2i is a factor of x, which is also known as the 2-adic or-
der. We ï¬rst certify that d(ord(a, pk)) (cid:54)= d(ord(a, q)) indi-
cates a(cid:98) ord(a,N)

(cid:99) (cid:54)â‰¡ Â±1 (mod N)

2

Lemma d_neq_sufficient :

âˆ€ a p q N,

2 < p â†’ 2 < q â†’ gcd p q = 1 â†’ N = pq â†’
d (ord a p) (cid:54)= d (ord a q) â†’
a(cid:98) ord a N
(cid:99) (cid:54)â‰¡ Â±1 (mod N).

2

âˆ€ a p k,

k (cid:54)= 0 â†’ prime p â†’ 2 < p â†’
(âˆ€ x, x2 (cid:54)â‰¡ a mod pk) â†’
d (ord a pk) = d (Ï• (pk)).

These lemmas are obtained via Eulerâ€™s Criterion, which
describes the difference between multiplicative orders of
quadratic residues and quadratic non-residues. The detailed
discussion is put later.

We claim that the number of quadratic residues in Z

pk
equals to the number of quadratic non-residues in Z
pk , whose
detailed veriï¬cation is left later. Then no matter what i is,
at least half of the elements in Z
pk satisfy d(ord(x, pk)) (cid:54)= i.
This makes the probability of ï¬nding an a âˆˆ Z
pkq satisfying
d(ord(a, pk)) (cid:54)= d(ord(a, q)) at least one half, in which case
(cid:17)
N is a nontrivial factor of N.
one of gcd

(cid:16)
a(cid:98) ord a N

(cid:99) Â± 1

2

Eulerâ€™s Criterion We formalize a generalized version of
Eulerâ€™s criterion: for odd prime p and k > 0, whether an
integer a âˆˆ Z
pk is a quadratic residue modulo pk is determined

by the value of a

Ï•(pk )

2 mod pk.

Lemma Euler_criterion_qr :

âˆ€ a p k,

k (cid:54)= 0 â†’ prime p â†’ 2 < p â†’ gcd a p = 1 â†’
(âˆƒ x, x2 â‰¡ a mod pk) â†’

This condition is sufï¬cient to get a nontrivial factor of N by
Eulerâ€™s theorem and the following lemma

Ï•(pk )
2

a

mod pk = 1.

Lemma Euler_criterion_qnr :

Lemma sqr1_not_pm1 :

âˆ€ x N,

1 < N â†’ x2 â‰¡ 1 (mod N) â†’ x (cid:54)â‰¡ Â±1 (mod N) â†’
1 < gcd (x - 1) N < N âˆ¨ 1 < gcd (x + 1) N < N.

By the Chinese remainder theorem, randomly picking a
in ZN is equivalent to randomly picking b in Z
pk and ran-
domly picking c in Zq. a â‰¡ b mod pk and a â‰¡ c mod q, so
ord(a, pk) = ord(b, pk) and ord(a, q) = ord(c, q). Because the
random pick of b is independent from the random pick of c,
it sufï¬ces to show that for any integer i, at least half of the
elements in Z

pk satisfy d(ord(x, pk)) (cid:54)= i.

Detouring to Quadratic Residue Shorâ€™s original proof16 of
this property made use of the existence of a group generator
of Z
pk , also known as primitive roots, for odd prime p. But
the existence of primitive roots is non-constructive, hence
hard to present in Coq. We manage to detour from primitive
roots to quadratic residues in modulus pk in order to avoid
non-constructive proofs.

A quadratic residue modulo pk is a natural number a âˆˆ Z
pk
such that there exists an integer x with x2 â‰¡ a mod pk.
We observe that a quadratic residue a âˆˆ Z
pk will have
d(ord(x, pk)) < d(Ï•(pk)), where Ï• is the Eulerâ€™s totient func-
tion. Conversely, a quadratic non-residue a âˆˆ Z
pk will have
d(ord(x, pk)) = d(Ï•(pk)):

Lemma qr_d_lt :

âˆ€ a p k,

k (cid:54)= 0 â†’ prime p â†’ 2 < p â†’
(âˆƒ x, x2 â‰¡ a mod pk) â†’
d (ord a pk) < d (Ï• (pk)).

Lemma qnr_d_eq :

âˆ€ a p k,

k (cid:54)= 0 â†’ prime p â†’ 2 < p â†’ gcd a p = 1 â†’
(âˆ€ x, x2 (cid:54)â‰¡ a mod pk) â†’

Ï•(pk )
2

a

mod pk = pk - 1.

These formulae can be proved by a pairing function over Z

pk :

x (cid:55)â†’ (a Â· xâˆ’1) mod pk,

where xâˆ’1 is the multiplicative inverse of x modulo pk. For a
quadratic residue a, only the two solutions of x2 â‰¡ a mod pk
do not form pairing: each of them maps to itself. For each
pair (x, y) there is x Â· y â‰¡ a mod pk, so reordering the product
pk x with this pairing proves the Eulerâ€™s criterion.
âˆxâˆˆZ

With Eulerâ€™s criterion, we can reason about the 2-adic order
of multiplicative orders for quadratic residues and quadratic
non-residues, due to the deï¬nition of multiplicative order and
ord(a, pk)|Ï•(pk).

Counting Quadratic Residues Modulo pk For odd prime
p and k > 0, there are exactly Ï•(pk)/2 quadratic residues mod-
ulo pk in Z

pk , and exactly Ï•(pk)/2 quadratic non-residues.

Lemma qr_half :

âˆ€ p k,

k (cid:54)= 0 â†’ prime p â†’ 2 < p â†’
|Z
pk [âˆƒx, x2 â‰¡ a mod pk].

pk | = 2 Â· âˆ‘aâˆˆZ

Lemma qnr_half :

âˆ€ p k,

k (cid:54)= 0 â†’ prime p â†’ 2 < p â†’
|Z
pk [âˆ€x, x2 (cid:54)â‰¡ a mod pk].

pk | = 2 Â· âˆ‘aâˆˆZ

Here [âˆƒx, x2 â‰¡ a mod pk] equals to 1 if a is a quadratic
residue modulo pk, otherwise it equals to 0. Similarly,

16/18

[âˆ€x, x2 (cid:54)â‰¡ a mod pk] represents whether a is a quadratic non-
residue modulo pk. These lemmas are proved by the fact that
a quadratic residue a has exactly two solutions in Z
pk to the
equation x2 â‰¡ a mod pk. Thus for the two-to-one self-map
over Z

pk

x (cid:55)â†’ x2 mod pk,

the size of its image is exactly half of the size of Z
pk . To
prove this result in Coq, we generalize two-to-one functions
with mask functions of type N â†’ B to encode the available
positions, then reason by induction.

C.3 End-to-end Certiï¬cation
We present the ï¬nal statement of the correctness of the end-
to-end implementation of Shorâ€™s algorithm.

Theorem end_to_end_shor_fails_with_low_probability :

âˆ€ N niter,

Â¬ (prime N) â†’ Odd N â†’
(âˆ€ p k, prime p â†’ N (cid:54)= pË†k) â†’
P
rndsâˆˆUniform([0,1]niter )[end_to_end_shor N rnds = None]
â‰¤ (1 - (1/2) * (Î² / (log2 N)Ë†4))Ë†niter.

Then r can be less than an arbitrarily small positive constant
2 N, which is O(log4 N).
Îµ log4
Î² ln 1
Îµ by enlarging niter to 2
This theorem can be proved by combining the success prob-
ability of ï¬nding the multiplicative order and the success
probability of choosing proper a in the reduction from factor-
ization to order ï¬nding. We build an ad-hoc framework for
reasoning about discrete probability procedures to express the
probability here.

C.4 Certifying Resource Bounds
We provide a concrete polynomial upper bound on the re-
source consumption in our implementation of Shorâ€™s algo-
rithm. The aspects of resource consumption considered here
are the number of qubits and the number of primitive gates
supported by OpenQASM 2.013. The number of qubits is
easily bounded by the maximal index used in the SQIR pro-
gram, which is linear to the length of the input. For gate count
bounds, we reason about the structure of our circuits. We ï¬rst
generate the gate count bound for the RCIR program, then
we transfer this bound to the bound for the SQIR program.
Eventually, the resource bound is given by

Lemma ugcount_shor_circuit :

âˆ€ a N,

0 < N â†’
let m := Nat.log2 (2*(NË†2)) in
let n := Nat.log2 (2*N) in
ugcount (shor_circuit a N) â‰¤
(212*n*n + 975*n + 1031)*m + 4*m + m*m.

Here ugcount counts how many gates are in the circuit.
Note m, n = O(log N). This gives the gate count bound for one
iteration as (212n2 + 975n + 1031)m + 4m + m2 = O(log3 N),
which is asymptotically the same as the original paper16, and
similar to other implementations of Shorâ€™s algorithm21, 54 (up
to O(log log N) multiplicative difference because of the differ-
ent gate sets).

D Running Certiï¬ed Code

The codes are certiï¬ed in Coq, which is a language designed
for formal veriï¬cation. To run the codes realistically and ef-
ï¬ciently, extractions to other languages are necessary. Our
certiï¬cation contains the quantum part and the classical part.
The quantum part is implemented in SQIR embedded in Coq,
and we extract the quantum circuit into OpenQASM 2.013
format. The classical part is extracted into OCaml code fol-
lowing Coqâ€™s extraction mechanism29. Then the OpenQASM
codes can be sent to a quantum computer (in our case, a clas-
sical simulation of a quantum computer), and OCaml codes
are executed on a classical computer.

With a certiï¬cation of Shorâ€™s algorithm implemented inside
Coq, the guarantees of correctness on the extracted codes
are strong. However, although our Coq implementation of
Shorâ€™s algorithm is fully certiï¬ed, extraction introduces some
trusted code outside the scope of our proofs. In particular,
we trust that extraction produces OCaml code consistent with
our Coq deï¬nitions and that we do not introduce errors in
our conversion from SQIR to OpenQASM. We â€œtestedâ€ our
extraction process by generating order-ï¬nding circuits for
various sizes and conï¬rming that they produce the expected
results in a simulator.

the quantum part, we extract

D.1 Extraction
For
the Coq program
generating SQIR circuits into the OCaml program gen-
erating the corresponding OpenQASM 2.0 assembly
ï¬le. We substitute the OpenQASM 2.0 gate set for
the basic gate set
in SQIR, which is extended with:
X, H,U1,U2,U3,CU1, SWAP,CSWAP,CX,CCX,C3X,C4X.
Here X, H are the Pauli X gate and Hadamard gate. U1,U2,U3
are single-qubit rotation gates with different parametriza-
tion13. CU1 is the controlled version of the U1 gate. SWAP
and CSWAP are the swap gate and its controlled version.
CX,CCX,C3X, and C4X are the controlled versions of the X
gate, with a different number of control qubits. Speciï¬cally,
CX is the CNOT gate. The proofs are adapted with this gate
set. The translation from SQIR to OpenQASM then is direct.
For the classical part, we follow Coqâ€™s extraction mecha-
nism. We extract the integer types in Coqâ€™s proof to OCamlâ€™s
Z type, and several number theory functions to their correspon-
dence in OCaml with the same behavior but better efï¬ciency.
Since our proofs are for programs with classical probabilistic
procedures and quantum procedures, we extract the sampling
procedures with OCamlâ€™s built-in randomization library.

One potential gap in our extraction of Coq to OCaml is
the assumption that OCaml ï¬‚oats satisfy the same proper-
ties as Coq Real numbers. It is actually not the case, but we
did not observe any error introduced by this assumption in
our testing. In our development, we use Coqâ€™s axiomatized
representation of reals46, which cannot be directly extracted
to OCaml. We chose to extract it to the most similar native
data type in OCamlâ€“ï¬‚oating-point numbers. An alternative
would be to prove Shorâ€™s algorithm correct with gate parame-
ters represented using some Coq formalism for ï¬‚oating-point
numbers56, which we leave for future work.

17/18

D.2 Experiments
We test the extracted codes by running small examples on
them. Since nowadays quantum computers are still not capa-
ble of running quantum circuits as large as generated Shorâ€™s
factorization circuits (âˆ¼30 qubits, âˆ¼ 104 gates for small cases),
we run the circuits with the DDSIM simulator28 on a laptop
with an Intel Core i7-8705G CPU. The experiment results are
included in Figure 4 (b) (c).

As a simple illustration, we showcase the order ï¬nding for
a = 3 and N = 7 on the left of Figure 4 (b). The extracted
OpenQASM ï¬le makes use of 29 qubits and contains around
11000 gates. DDSIM simulator executes the ï¬le and generates
simulated outcomes for 105 shots. The measurement results
of QPE are interpreted in binary representation as estimated
2m Â· k/r. In this case, the outcome ranges from 0 to 63, with
different frequencies. We apply OCaml post-processing codes
for order ï¬nding on each outcome to ï¬nd the order. Those
measurement outcomes reporting the correct order (which is 6)
are marked green in Figure 4 (b). The frequency summation of
these measurement outcomes over the total is 28.40%, above
the proven lower bound of the success probability of order
ï¬nding which is 0.17% for this input.

We are also able to simulate the factorization algorithm for
N = 15. For any a coprime to 15, the extracted OpenQASM
codes contain around 35 qubits and 22000 gates. Fortunately,
DDSIM still works efï¬ciently on these cases due to the well-
structured states of these cases, taking around 10 seconds for
each simulation. We take 7 Ã— 105 shots in total. When N = 15,
the measurement outcomes from QPE in order ï¬nding are
limited to 0, 64, 128, 192 because the order of any a coprime
to 15 is either 2 or 4, so 2m Â· k/r can be precisely expressed
as one of them without approximation. The frequency of
the simulation outcomes for N = 15 is displayed on the right
of Figure 4 (b). We then apply the extracted OCaml post-
processing codes for factorization to obtain a non-trivial factor
of N. The overall empirical success probability is 43.77%,
above our certiï¬ed lower bound of 0.17%.

We have also tested larger cases on DDSIM simulator28
for input size ranging from 2 bits to 10 bits (correspond-
ingly, N from 3 to 1023), as in Figure 4 (c). Since the
circuits generated are large, most of the circuits can-
not be simulated in a reasonable amount of time (we
set the termination threshold 1 hour). We exhibit se-
lected cases that DDSIM is capable of simulating: N =
15, 21, 51, 55, 63, 77, 105, 255 for factorization, and (a, N) =
(2, 3), (3, 7), (7, 15), (4, 21), (18, 41), (39, 61), (99, 170),
(101, 384), (97, 1020) for order ï¬nding. These empirically

investigated cases are drawn as red circles in Figure 4 (c).
Most larger circuits that are simulated by DDSIM have the
multiplicative order a power of 2 so that the simulated state is
efï¬ciently expressible. For each input size, we also calculate
the success probability for each possible input combination
by using the analytical formulae of the success probability
with concrete inputs. Shor shows the probability of obtaining
a speciï¬c output for order ï¬nding is16

P[out = u] =

1
22m âˆ‘

0â‰¤k<r

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
vâ‰¡k

âˆ‘
0â‰¤v<r
(mod r)

e2Ï€iuv/2m

(cid:12)
2
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

.

Here r is the order, and m is the precision used in QPE. The
success probability of order ï¬nding then is a summation of
those u for which the post-processing gives correct r. For
most output u, the probability is negligible. The output tends
to be around 2mk/r, so the sum is taken over integers whose
distance to the closest 2mk/r (for some k) is less than a thresh-
old, and the overall probability of getting these integers is at
least 95%. Hence the additive error is less than 0.05. These
empirical results are drawn as blue intervals (i.e., minimal to
maximal success probability) in Figure 4 for each input size,
which is called the empirical range of success probability. The
certiï¬ed probability lower bounds are drawn as red curves in
Figure 4 as well. The empirical bounds are signiï¬cantly larger
than the certiï¬ed bounds for small input sizes because of loose
scaling in proofs, and non-optimality in our certiï¬cation of
Eulerâ€™s totient functionâ€™s lower bounds. Nevertheless, asymp-
totically our certiï¬ed lower bound is sufï¬cient for showing
that Shorâ€™s algorithm succeeds in polynomial time with large
probability.

We also exhibit the empirical gate count and certiï¬ed gate
count for order ï¬nding and factorization circuits. In fact, the
circuits for order ï¬nding are exactly the factorization circuits
after a is picked, so we do not distinguish these two problems
for gate count. On the right of Figure 4 (c), we exhibit these
data for input sizes ranging from 2 to 10. We enumerate all the
inputs for these cases and calculate the maximal, minimal, and
average gate count and draw them as blue curves and intervals.
The certiï¬ed gate count only depends on the input size, which
is drawn in red. One can see the empirical results satisfy the
certiï¬ed bounds on gate count. Due to some scaling factors
in the analytical gate count analysis, the certiï¬ed bounds are
relatively loose. Asymptotically, our certiï¬ed gate count is
the same as the original paperâ€™s analysis.

18/18

