2
2
0
2

y
a
M
9
2

]
E
S
.
s
c
[

1
v
6
8
5
4
1
.
5
0
2
2
:
v
i
X
r
a

Formal Methods for Characterization
and Analysis of Quality Speciﬁcations
in Component-based Systems

Aritra Hazra

Department of Computer Science and Engineering, Indian Institute of Technology Kharagpur, India.

Abstract. Component-based design paradigm is of paramount importance due to proliﬁc growth in the
complexity of modern-day systems. Since the components are developed primarily by multi-party vendors and
often assembled to realize the overall system, it is an onus of the designer to certify both the functional and
non-functional requirements of such systems. Several of the earlier works concentrated on formally analyzing
the behavioral correctness, safety, security, reliability and robustness of such compositional systems. However,
the assurance for quality measures of such systems is also considered as an important parameter for their
acceptance. Formalization of quality measures is still at an immature state and often dictated by the user
satisfaction. This paper presents a novel compositional framework for reliable quality analysis of component-
based systems from the formal quality speciﬁcations of its constituent components. The proposed framework
enables elegant and generic computation methods for quality attributes of various component-based system
structures. In addition to this, we provide a formal query-driven quality assessment and design exploration
framework which enables the designer to explore various component structures and operating setups and
ﬁnally converge into better acceptable systems. A detailed case-study is presented over a component-based
system structure to show the eﬃcacy and practicality of our proposed framework.

Keywords: Component-Based Systems, Speciﬁcation, Quality, Reliability, Series-Parallel Composition.

1. Introduction

Component-based design engineering is of paramount importance across all engineering disciplines where
complex systems can be obtained by assembling components as basic building blocks [13, 25, 27, 30]. Such
paradigms are becoming prevalent due to increasing complexity of hardware and software systems and com-
ponents requiring procurement from multi-party vendors for product completion. Components are design
abstractions that ignore implementation details and are conceptualized formally using behavioral, interac-
tion and execution models. These models are, then, hierarchically composed to build the overall system

Correspondence and oﬀprint requests to: Aritra Hazra, Department of Computer Science and Engineering, Indian Institute of
Technology Kharagpur, Paschim Medinipur, West Bengal, India, PIN – 721302. E-mail: aritrah@cse.iitkgp.ac.in

 
 
 
 
 
 
2

Aritra Hazra

architecture where the formalism for the composite model is attributed from the notion of transfer func-
tions, interfaces and contracts [1, 2, 6, 34]. Component-based engineering broadly involves model-based
development of systems [33, 36], platform-based design methodologies [31] and developing software modules,
supported by a large number of existing tools and standards, involving object-oriented languages (such as
C++, System-C) and modeling languages (such as Stateﬂow/Statechart, UML, SysML) [5, 16, 17].

The computer scientists and researchers have responded to the challenge of designing complex systems
adopting various formal methods and compositional algebra based frameworks [34, 35]. Typically, the com-
ponent interactions and concurrency have been modeled formally using automated compositional reasoning
and connector algebra [3, 4, 32]. With the wider adoption of such structured frameworks for system mod-
eling, it also becomes a primary concern for the designers to ensure the correct operability of composite
systems. Over the past few decades, model-based testing [37, 38] and model checking paradigms are explored
to ensure the functional correctness, timing and safety behaviors [8, 9]. Additionally, several formal methods
are proposed to enforce correct-by-construction approaches while designing system-level composite architec-
tures [15, 29]. In recent times, the certiﬁcation regime has also been extended towards formal assurance of the
non-functional requirements as well, such as power [21, 22], reliability [14, 19, 20] and security [10, 18, 24],
for component-based systems. Though the composition modeling is primarily formalized by the help of be-
havioral component models, formal component interactions and architectural properties, but there is a gap
in modeling and assessment of system-level quality from the quality standards of its constituent components.
Quality measures of a system (often considered as a non-functional attribute) primarily reﬂects how
perfectly an operation can be performed by the system and it is often attributed from the composed quality
goals attained by its constituent components. It leads to the satisfaction of the users who are being serviced
by the output of that system. A real-life example can be witnessed in case of video rendering (one can
consider YouTube as an example) during the transmission/streaming where multiple levels of video quality
can be produced. Typically, a high quality video input is being processed in multiple operating modes and
the output video is produced in various quality levels depending on the bandwidth of the transmission and
receiver channel. The two interesting non-functional behaviors in such a procedure is the reliability (or the
availability) of the output video and also its quality parameters. The notion of reliability and availability
in system design has been extensively studied [26]. However, at recent times, there is a growing need to
incorporate the quality measures also into the main-stream formal system design process. The existing
formalism for component-based rigorous system designs [34] do not consider into account quality attributes
and associated speciﬁcations into their present modeling setup, hence the notion and formal treatment of
quality measures in component-based systems are still remaining at a premature stage.

As per the best of our knowledge, there are very few works in formal system quality analysis. Some of the
early works have subjectively quantiﬁed the notion of quality of systems and informally established the same
by interaction of components and by following strict designing principles [7]. In embedded system design
parlance, architectural quality assurance frameworks, leveraging na¨ıve formal veriﬁcation and model-based
techniques, are formalized in [23, 28]. The notion of symbolic quality and its control was introduced in [11],
where the authors propose an optimal quality schedule to ensure Quality-of-Service (QoS). On the same line,
the work presented in [12] proposes a ﬁne grain symbolic quality control method for multimedia applications
using speed diagrams. The proposed methods takes as input an application software composed of actions,
whose execution times are unknown increasing functions considering quality level parameters (considered as
integers). The quality controller is able to compute adequate action schedules and choose pre-deﬁned quality
levels, in order to meet QoS requirements for a given platform. However, all these existing works do not
provide the formal basis for designing and reasoning system involving component-level quality compositions;
rather these methods invokes a quality manager to change action quality levels based on the knowledge of
control constraints and ﬁnally computing a set of optimal schedules improving overall system performance.
Formal characterization of system quality has several deeper underpinnings in relation with the under-
lying system behavior. The choice of quality may have certain dependence with the system reliability, since
some good quality component failure may degrade the overall quality of the system as well. So, formalizing
the notions of quality should also incorporate the component-based system reliability formalism into its
characterization. Existing literature provides several stand-alone techniques for calculating the reliability of
systems based on symbolic/algebraic compositions of component-level reliability expressions from its given
component structures [26]. However, there is a lack of eﬀort in formally capturing quality measures for a
design in similar terms, and thereby building a suitable framework to assess the compositional quality of
component-based systems. This article is an enabler in this direction.

Formally, we deﬁne the quality of a component as a set of random variables each associated with a prob-

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

3

Section−2

QRSpec P

QRSpec P

1

2

QRModel Q1

QRModel Q

2

Formal
Modeling
Engine

QRSpec P

n

Section−3

QRModel Q

n

Component−level
Formal Quality−Reliability
Specifications

Formal Characterization
of Component Specs

Section−2

Architectural
System
Description

Component−based
Series / Parallel
System Structures

System−level
QR Query
Specification

Structured
Query
Description
Language

Section−4

Section−6

Formal
Composition
Engine

Series/Parallel and
Path−Enumeration 
based Composition

System
QRModel

Query Processing
and Analysis Engine

System−level
QR Assessment
Report

Manual Inspection

Section−5

QRSpec
Synthesis
Engine

System
QRSpec

Conformance
Checking

System−level
Quality−Reliability
Specifications

X

Fig. 1. The Overall Framework of Characterization and Assessment of Quality Speciﬁcations

ability value. We assume that for a given minimum input quality value/level, the corresponding minimum
output quality value/level for any component is associated with a reliability value, which dictates its prob-
ability of successful execution without compromising the mentioned quality. The set of quality levels with
diﬀerent reliability values for a component arises due to a bound on limited execution time and cost of the
component comprising the system [12]. Apart from the failure that can occur in a component structure, its
operation can also be manually suspended by controlling it (for example, switching it oﬀ or executing it in
a low functional/power modes) systematically. Such control of component suspension is very important at
present context, considering the criticality of power, security and other performance criteria under restricted
design setup. Clearly, a component has the output quality zero when its reliability is also zero (irrespective
of input quality), meaning that failure is imminent, or its operation has been suspended (controlled). So,
it is imperative to formulate algebra for component quality and reliability composition in order to reason
about the quality of a system constructed hierarchically from set of component structures.

Given a set of formal quality and reliability speciﬁcations for a set of components, it is non-trivial to
deﬁne the quality and reliability measures of the composite system structure. The composition is not similar
to reliability analysis, since there is a choice here to maximize the overall quality during the compositional
exploration considering the functional reliability of its constituent components (and their failures). This
choice is complicated because there can be multiple ways during system execution to produce the range of
quality expressions. For example, when several components, each having a set of quality speciﬁcations, are
all connected in parallel, the overall quality measure of such a setup may be generated by – (i) computing the
highest quality value/level among the operational components every time, (ii) assuming a pre-selected order
among the operability of the constituent components, or (iii) reporting the quality from a ﬁxed component
(for simplicity) and the quality becomes zero when that component fails – thereby keeping the possibility for
varied range of behavioral options. On the other hand, for series composition, the quality value is dictated
by the series of components and becomes zero if any one of the components fails. Apart from such choices,
the option to suspend/control the component execution in any operating mode brings inherent challenges in
assessment of overall system quality attributes.

This work proposes novel methods for formal characterization and assessment of quality speciﬁcations for
component-based systems that are built involving of series and parallel compositions of component structures
at an architectural level. Figure 1 presents the overall ﬂow (steps) of the work presented in this article. To start
with, the component-level quality and reliability speciﬁcations (QRSpec) are drafted, which are then formally
characterized into a set of component-level QRModel. Next, depending on the system structure, a generic series
and parallel composition algebra is followed to formally compose these component models into a composite
system-level QRModel. Now, the system level (architectural) QRSpec can also be reverse-synthesized, which
may help in – (i) understanding the non-functional performance boundaries (and extremities) of the system
under various component-level operating conditions, and (ii) performing a conformance check with respect
to the given system conﬁguration, in case the system speciﬁcations are known a priori, to compare and know
the functional coverage of the system. However, QRSpec only deﬁnes an abstraction in terms of specifying
the underlying detailed QRModel of the system. Many other interesting observations can be gleaned from
QRModel that are not reﬂected directly through QRSpec, and these will be useful for the designers, who

4

Aritra Hazra

may want to explore various structures and combinations of available component to converge into the best
possible system architecture. For that, the designer are given an option to formulate their queries over the
system attributes systematically using a proposed structured query description language (SQDL), using which
the information gets automatically extracted from the QRModel so that system-level quality and reliability
(non-functional) assessments can be performed. In particular, the key contributions out of this work are:

• We deﬁne the speciﬁcation formalism for component-level and system-level quality attributes.
• We introduce a uniform formal characterization of quality conﬁgurations for components and subsystems.
• We propose a novel series/parallel quality composition mechanism to hierarchically derive quality con-

ﬁgurations for any given system architecture from its component-level quality models.

• We derive the (abstracted) system quality speciﬁcation from the formal representation of system quality

measures through reverse-synthesis to check for conformance and estimate coverage.

• We design a query-driven framework to aid designers for better system exploration and quality assessment.
• We provide a detailed case-study to show the eﬃcacy and practicality of our proposed formal framework.
The rest of the paper is organized as follows1. Section 2 describes the formal modeling of component-based
systems and the notion of quality speciﬁcations for the components and subsystems. Section 3 presents
the formal characterization of quality measures from quality speciﬁcations. Section 4 introduces the prim-
itive composition techniques for series and parallel system structures and formulate generic composition
principles for systems. Section 5 elaborates on the synthesis of quality speciﬁcations from formal models
and conformance checking part. Section 6 proposes the query processing and analysis platform for system-
level assessment and design exploration. Section 7 illustrates our proposed framework empirically over few
case-studies of composite structures. Finally, Section 8 concludes the work presented in this article.

2. Formal Model and Speciﬁcation

Component-based design approaches follow the development of an overall system starting from unit-level
component structures and laying their speciﬁcations. In this section, we ﬁrst formalize the description of
such component-based systems and the notion of formal quality speciﬁcations.

2.1. Component-based Systems

Several components may be connected with each other in series and parallel structures to form a system.
Formally, such a component-based system, Υ, can be expressed as,

Υ = hI, O, C, V, E, Li, where:

• I = {I1, I2, . . . , Iu} denotes the set of u input nodes of the system.
• O = {O1, O2, . . . , Ov} denotes the set of v output nodes of the system.
• C = {C1, C2, . . . , Cn} denotes the set of n components of the system, where each component Ci (with a
single input and single output) has their own non-functional speciﬁcation, Pi (deﬁned in next subsection).

• V = {V1, V2, . . . , Vz} denotes the set of z vertices (z ≥ n).
• E ⊆ (I ∪ V) × (V ∪ O) denotes the set of edges representing the connectors among the vertices including

the input/output nodes of the system.

• L : V → C is a function that labels each vertices with a component. There may be multiple vertices
labeled with a same component indicating that the component is used in multiple places in the system.

The following example of a component-based system illustrates the above mentioned formalism in details.

Example 1. Consider the example of a series/parallel component-based system, Υsp, given in Figure 2.
Here, C = {C1, C2, C3}, I = {I1} and O = {O1}. The overall system architecture can be represented
using a directed acyclic graph with the set of vertices, V = {V1, V2, V3, V4}, and the set of edges, E =
{(I1, V1); (I1, V2); (I1, V3); (V3, V4); (V1, O1); (V2, O1); (V4, O1)}. Moreover, the vertices are labeled using three
components forming the system architecture as, L(V1) = C1, L(V2) = C2, L(V3) = C3, and L(V4) = C2. ✷

1 Sections are also highlighted in Figure 1 to provide a meaningful organization to this article.

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

5

V1

V2

C 1

C 2

O 1

V4

C 2

I1

V3

C 3

Fig. 2. Component-based System Structure, Υsp, having Series and Parallel Component Organization

A few pertinent points to note here are as follows.

• The series and parallel system structure is useful in designing many safety-critical systems where the same
input-output design functionality can get realized via redundant parallel paths in order to tolerate some
intermediate component failures. Typically, the functionalities from a set of parallel executions/paths are
converged using a voting mechanism (choosing consistent outcomes from m-out-of-n paths). For example,
in Figure 2, three parallel paths, i.e. via C1, via C2, or via C3 − C2, may yield the same input-output
functionality, though their way of implementation may vary (due to procurement of each component from
diﬀerent sources). From a functional perspective, we may vote and produce output by taking consistent
outcomes from 2-out-of-3 paths2. However, whenever the parallel paths converge, the overall output
quality may come from either choosing the maximum quality across all paths, or choosing quality values
from some pre-deﬁned ordering of paths (we discuss this in details in the following sections). Further,
we assume that the voting component is fully reliable and do not degrade the quality parameters while
bypassing through it. In practical cases, we can take quality and reliability speciﬁcations also for the voter
and treat it like another component being placed in series whenever a set of parallel paths converge.
• When the same component is placed in multiple positions of the overall system, it indicates diﬀerent
instantiation (in case of hardware systems) or diﬀerent invocations (in case of software systems) of the
same object (deﬁned once). So, going by this analogy, in Figure 2, where there is two installation of
same component C2, if C2 fails, then the operating probability of C2 becomes 0 and hence two paths
(I1 → V3 → V4 → O1 and I1 → V2 → O1) fail together (out of three possible) from input to output.
• On the other hand, whenever there is a need to place a duplicate but identical component in the other
places, a diﬀerent component name (with same speciﬁcations though) needs to used in every other
constellations. For example, it may be the case in Figure 2 that C1 and C3 are identical components in
terms of their functionality, but separately deﬁned.

• In practical conditions, sometimes to save power and other design overhead, some redundant components
may be suspended or switched oﬀ (usually controlled by the designer). Component failure and suspension
are diﬀerent, because in ﬁrst case, if the component has an operating reliability of r, then it has its failure
probability of (1−r); whereas the latter makes the component to bypass assuming a reliability of 1 for the
suspended component. For example, in Figure 2, if we suspend C3, then the path via I1 → V3 → V4 → O1
is blocked due to suspension of C3, but C3 will have reliability as 1.

2.2. Quality and Reliability Speciﬁcations

Typically, in component-based system design, the quality and reliability attributes, often known as non-
functional requirements, are laid from an architectural level of the system and are analyzed over the system
structures. We term such non-functional quality and reliability speciﬁcations as QRSpec. First, let us formally
deﬁne such a high-level QRSpec of a component as well as an overall system.

2.2.1. Component-level Speciﬁcations

Every unit-level component within a system operates in multiple modes (each mode having a given opera-
tional reliability value between [0, 1]) provided it does not undergo any failure3. Now, corresponding to every

2 To reduce clutter and without loss of generality, we have not explicitly shown the voting component in the system structure.
3 We treat component failure also as an operational mode with reliability being 0.

6

Aritra Hazra

quality level of the input for a component, it produces the output in some deﬁned quality levels depending
on its mode of operation. Formally, we represent the QRSpec for a unit-level component, Ci, as:

Pi = h{Ci}, Mi, Zi, QI

i , QO

i i, where:

• {Ci} is the participating component.
i , m2
• Mi = {m0

i , . . . , mdi

i , m1
failure mode (di ∈ N).

i }, denotes the set of (di + 1) operational modes of Ci including m0

i as the

• Zi : Mi → R[0,1], is a function that associates a reliability value (within [0, 1]) to each operational mode

i ) = 0 and ∀k (1 ≤ k ≤ di), Zi(mk

i ) > 0.

i }, denotes the set of li non-negative input quality values (or levels), where ∀j (1 ≤

• QI

of the component. Here, Zi(m0
i , . . . , qli
i , q2
i ∈ R+ and qj

i = {q1
j < li), qj

i > qj+1

i

.

• QO
i

: Mi ×QI

i → R+, is a function that maps each input quality level to an output quality (a non-negative

i , qj

i , qj

i (m0

i (mk

i (mk

i ) ≤ qj

i and QO

i ) = 0, as m0
i
i , then the

real number) corresponding to every operational modes.
It may be noted that, ∀k (1 ≤ k ≤ di), ∀j (1 ≤ j ≤ li), QO
indicates the mode where Ci failed completely. Moreover, if the input quality (q) falls below qli
output quality becomes zero, i.e. QO

i , q) = 0, when q < qli
i .
Here, every operating mode for a component has a reliability and can produces diﬀerent quality output values
based on given input quality ranges. The following example illustrates the component QRSpec formalism.
Example 2. Let the QRSpec for a component, C1, is given as, P1 = hM1, Z1, QI
• C1 operates in two operational modes along with a permanent failure mode. Therefore, M1 = {m0
• The operational reliability values are, Z1(m1
• The input quality levels are speciﬁed as, QI
• The corresponding output quality values are, QO
1 (m2

QO
1 (m2
It intuitively means that, the output quality levels maintained by C1 at mode m1
10 when the input quality value is at least 50, within [30, 50) and within [10, 30), respectively.
Implicitly, for any q ∈ R+, QO

1) = 0.8, Z1(m2
1 = {50, 30, 20}.
1 (m1
1, 20) = 10.

1 are at least 40, 25 and

1) = 0.7, and Z1(m0

1, q) = 0 and when q < 20, QO

1, 50) = 40, QO

1, 30) = 25, QO

1, 30) = 25, QO

1, 50) = 35, QO

1, 20) = 10 and

1 i, where:

1, q) = 0.

1) = 0.

1, QO

1 (m1

1 (m1

1 (m0

1 (m2

1 (m1

1, m1

1, m2

1}.

2) = 0.95 and Z2(m0

Similarly, let the quality speciﬁcation for C2 is given as, P2 = hM2, Z2, QI
Z2(m1
2 (m1
3, QO
3 (m1

2, 40) = 30 and QO
Also, let the quality speciﬁcation for C3, is given as, P3 = hM3, Z3, QI
3 = {50, 20, 10}; QO
3 (m2
3, 10) = 5.

3) = 0.8 and Z3(m0
3, 50) = 40, QO
3 (m2

3) = 0.9, Z3(m2
3, 10) = 5 and QO

3) = 0; QI
3 (m2

2 = {40, 10}; QO

3, 20) = 15, QO

Z3(m1
QO
3 (m1

2) = 0; QI

1 (m1

2 i, where: M2 = {m0

1 (m2

1, q) = 0 and QO
2, QO
2, 10) = 10.
3 i, where: M3 = {m0
3, 50) = 45, QO
3 (m1

2, m1

2};

3, m2

3, m1
3};
3, 20) = 20,
✷

2.2.2. System-level Speciﬁcations

A system architecture is built using a set of inter-connected components which are glued with each other in
a series/parallel manner. Formally, we deﬁne the QRSpec for an overall system, Υ, as4:

PΥ = hCΥ, MΥ, ZΥ, QI

Υ, QO

Υi, where:

• CΥ = {C1, C2, . . . , Cn}, is the set of n components used to form the system, Υ.

The quality speciﬁcation for each component, Ci (1 ≤ i ≤ n), is denoted by, Pi = hMi, Zi, QI

i , QO

i i.

• MΥ = (M1 × M2 × · · · × Mn), denotes the set of dΥ operational modes of Υ, where each mode is an

n-tuple and hence dΥ =

n
i=1(di + 1).

Q

• ZΥ : MΥ → R[0,1], is a function that associates a reliability value (within [0, 1]) to each operational mode

of the system.

4 It may be noted that, component-level QRSpec can also be viewed as a system-level QRSpec where CΥ = {Ci}, i.e., the system,
Υ, comprises of a single component, Ci. Hence, from the next section onwards, we do not diﬀerentiate between component and
system as such, since their formal modeling and treatment remains uniform.

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

7

I

C

3

C

2

O

I

C

1

C

2

O

[ Series Structure ]

[ Parallel Structure ]

Fig. 3. (a) 2-Component Series System, ΥS

(b) 2-Component Parallel System, ΥP

ΥS

ΥS

System Mode
≡ (m0
≡ (m0
≡ (m1
≡ (m1
≡ (m2
≡ (m2

3, m0
2)
3, m1
2)
3, m0
2)
3, m1
2)
3, m0
2)
3, m1
2)

m0
m0
m0
m1
m0
m2

ΥS

ΥS

ΥS

ΥS

Reliability
0.000
0.000
0.000
0.855
0.000
0.760

Input Quality
h0i
h0i
h0i
h50, 20i
h0i
h50, 20i

Output Quality
h0i
h0i
h0i
h30, 10i
h0i
h30, 10i

ΥP

ΥP

System Mode
≡ (m0
≡ (m0
≡ (m1
≡ (m1
≡ (m2
≡ (m2

1, m0
2)
1, m1
2)
1, m0
2)
1, m1
2)
1, m0
2)
1, m1
2)

m0
m1
m2
m3
m4
m5

ΥP

ΥP

ΥP

ΥP

Reliability
0.000
0.950
0.800
0.990
0.700
0.985

Input Quality
h0i
h40, 10i
h50, 30, 20i
h50, 40, 30, 10i
h50, 30, 20i
h50, 40, 30, 10i

Output Quality
h0i
h30, 10i
h40, 25, 10i
h40, 30, 25, 10i
h35, 25, 10i
h35, 30, 25, 10i

Table 1. Mode-wise Reliability and Quality Values for ΥS

Table 2. Mode-wise Reliability and Quality Values for ΥP

n

QI

• QI

Υ ⊆

Si=1
Υ : MΥ×QI

• QO

i , denotes the set of non-negative input quality values (levels);

Υ → R+, is a function that maps each input quality level to an output quality (a non-negative

real number) for every operational modes.

The following example demonstrates the QRSpec of two elementary systems, ΥP and ΥS, each having two
components connected simply in parallel and series, respectively.

Example 3. First, let us consider another elementary system, ΥS, comprised of two components, C2 and
C3 (as introduced in Example 2), where C2 is connected with C3 in series (refer to Figure 3(a)). Now, the
QRSpec for ΥS is given as, PΥS = hCΥS , MΥS , ZΥS , QI

ΥS , QO

ΥS i, where:

• The participating components are, CΥS = {C2, C3} with QRSpec, P2 and P3, respectively.
• The three operational modes of ΥS are, MΥS = {m0

m0

2) ≡ (m0

ΥS ≡ (m0

3, m0
Eﬀectively, only two modes, (m1
all failure modes.

3, m1

2) ≡ (m1
3, m1

3, m0
2) and (m2

2) ≡ (m2
3, m1

ΥS , m2

ΥS , m1
3, m0

2), m1

ΥS }, where:
3, m1

ΥS ≡ (m1

2), m2

ΥS ≡ (m2

3, m1

2).

2), are non-failure (operating) modes and the rest are

• Since C2 and C3 are in series, so the reliability corresponding to every mode of MΥS is be computed as,

(mj

= Z1(mj

ZΥS (cid:0)

3).Z2(mk
3, mk
2)
(cid:1)
• The input quality levels are, QI
• The output quality value function (QO

ational mode of ΥS is also given in Table 15.

2) (0 ≤ j ≤ 2 and 0 ≤ k ≤ 1) and shown in Table 1.
ΥS = {50, 20} (due to series connected components).

ΥS ), with respect to the input quality values/levels for every oper-

Now, let us consider an elementary system, ΥP , comprised of two components, C1 and C2 (as introduced
in Example 2), where C1 is connected with C2 in parallel (refer to Figure 3(b)). Now, the QRSpec for ΥP is
given as, PΥP = hCΥP , MΥP , ZΥP , QI

ΥP i, where:

ΥP , QO

• The participating components are, CΥP = {C1, C2} with QRSpec, P1 and P2, respectively.
• The six operational modes of ΥP are, MΥP = {m0
ΥP }, where:
2), m5
1, m0

ΥP , m2
ΥP ≡ (m1

ΥP , m5
ΥP ≡ (m2

ΥP , m4
2), m4

ΥP , m3
1, m1

ΥP ≡ (m0

ΥP ≡ (m1

ΥP ≡ (m0

ΥP , m1

2), m2

2), m3

2), m1

1, m0

1, m0

1, m1

m0

ΥP ≡ (m2

1, m1

2).

3, m1

5 To intuitively explain (detailed methodology is presented later) the last row of Table 1, note that the system mode, m2
(m2
least 50 and within [20, 50) can be computed as, QO
ΥS (cid:0)(m2
QO
3, 20)(cid:1) = QO

≡
2), is dictated by the operating modes of C3 and C2. The output quality values corresponding to input quality level at
2), 50(cid:1) = QO
2, 40(cid:1) = 30, and similarly,
2 (cid:0)m1

2, 10(cid:1) = 10 (since C2 is placed after C3 in series).

3, m1
2, 15(cid:1) = QO

ΥS (cid:0)(m2
2 (cid:0)m1

3, 50)(cid:1) = QO

2), 20(cid:1) = QO

2 (cid:0)m1

2 (cid:0)m1

2 (cid:0)m1

3 (m2

3 (m2

3, m1

2, QO

2, QO

ΥS

8

Aritra Hazra

• Since C1 and C2 are in parallel, so the reliability corresponding to every mode of MΥP is be computed
1 − Z2(mk
(cid:1)i (0 ≤ j ≤ 2 and 0 ≤ k ≤ 1) and shown in Table 2.
2)
(cid:0)

1 − Z1(mj
.
1)
(cid:1)
(cid:0)

= h1 −

(mj

as, ZΥP (cid:0)

1, mk
2)
(cid:1)
• The input quality levels are, QI
• The output quality value function (QO

ational mode of ΥP is also given in Table 26.

ΥP = {50, 40, 30, 20, 10} (due to parallel connected components).

ΥP ), with respect to the input quality values/levels for every oper-
✷

It is worthy to note here is that, the architectural QRSpec of a system derives its operating modes and quality-
reliability attributes with respect to component failures as well as component suspensions. Though the above
example only deals with component failures (not provisionize component suspensions), however as pointed at
the end of Section 2.1 (and also in Section 1), the designer may explore various quality attributes of a system
also involving suspended components. Exploration of such orchestrations in component behaviors needs a
generic compositional framework through which one can automatically derive out the system-level QRSpec
from the QRSpec of its component modules involving both failure and suspended components. In subsequent
sections, we present the generic procedures to formally derive system-level QRSpec from component QRSpec.

3. Formal Characterization of Quality Conﬁgurations

In this section, we present a formal characterization of the system-level quality measures under various
operating conﬁgurations of its constituent components as state transition models, also termed as QRModel,
which enables further compositional interpretation of the QRSpec. Formally, we characterize the quality
measure under diﬀerent operating conﬁgurations of a subsystem, Υ (having one or more components), with
the QRSpec, PΥ = hCΥ, MΥ, ZΥ, QI

Υi, in terms of the following QRModel as,

Υ, QO

QΥ = hCΥ, QI

Υ, RΥ, SΥ, s1

Υ, ΓΥ, QO

Υ, TΥ, ExprΥi, where:
• CΥ = {C1, C2, . . . , Cn} is the ordered set of n participating components in the system, Υ.
• QI

Υ }, denotes the set of lΥ non-negative input quality values (or levels), where ∀j (1 ≤

Υ = {q1
j < lΥ), qj

Υ, . . . , qlΥ
Υ, q2
Υ ∈ R+ and qj

Υ > qj+1
Υ .

n
i=1 di) symbolic reliability variables, such that each
P
y), where 1 ≤

y of Cy, has the reliability value of Zy(mt

• RΥ = {rΥ,1, rΥ,2, . . . , rΥ,eΥ } is the set of eΥ(=
rΥ,k, corresponding to the operating mode mt
y−1
i=1 di.

Q

P

P

P
Υ, . . . , snΥ

y
i=1 di ≤ eΥ and t = k −

Υ } is the set of nΥ operational states characterizing the quality measures. Here,

y−1
i=1 di < k ≤
Υ, s2
• SΥ = {s1
n
i=1(2di+1 − 1), where each Ci can operate in di number of modes (1 ≤ i ≤ n).
nΥ =
Υ ∈ SΥ is the start/initial operating state.

• s1
• ΓΥ : SΥ → {1, 0, X, Y}eΥ denotes the eΥ-length conﬁguration function of a state corresponding to dΥ
operational modes in MΥ (excluding failure mode, m0
Υ ∈ MΥ, which can be expressed as the state having
n
all 0’s in the eΥ-length conﬁguration). Here, eΥ =
i=1 di, where di is the number of operating modes
P
(excluding the failure mode) of Ci (1 ≤ i ≤ n). Typically, Ci shall execute in the operating mode, mj
i ,
when all modes mk
For a state, sj
represent the kth and k-to-k′ conﬁguration location(s) of sj

Υ)[k] ∈ {1, 0, X, Y} and ΓΥ(sj

Υ)[k..k′] ∈ {1, 0, X, Y}(k′

i (1 ≤ k < j ≤ di) have failed.

−k+1) (1 ≤ k < k′ ≤ eΥ)

Υ ∈ SΥ, ΓΥ(sj

Υ, respectively. Formally,

ΓΥ(sj

Υ)[k] =

indicating Cy is operating in mode mt
y
indicating Cy is has failed in mode mt
y
indicating Cy is not availing mode mt
y
indicating Cy has suspended mode mt
y

1,
0,
X,
Y,






where 1 ≤

y−1

X
i=1

di < k ≤

y

X
i=1

di ≤ eΥ and t = k−

y−1

X
i=1

di

1, m1

6 To intuitively explain (detailed methodology is presented later) the last row of Table 2, note that the system mode, m5
≡
(m2
2), is dictated by the operating modes of C1 and C2. The (best possible) output quality value with respect to input quality
level at least 40 can be computed as, QO
2, 40)] =
MAX[25, 30] = 30. Similarly, we can also ﬁnd all the (best possible) output quality values, 35, 30, 25 and 10 for the corresponding
input quality values, which are at least 50, within [40, 50), within [30, 40) and within [10, 30), respectively.

2), 40(cid:1) = MAX[QO

2, 40)] = MAX[QO

ΥP (cid:0)(m2

1, 40), QO

1, 30), QO

2 (m1

2 (m1

1 (m2

1 (m2

1, m1

ΥP

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

9

Υ)[k] = 1, we have, ΓΥ(sj

Additionally, when ΓΥ(sj
ΓΥ(sj

Υ)[k′] = 0/Y (∀k′ such that (
P
Υ) ≡ ΓΥ(sj
Υ)[1..eΥ].

y−1
i=1 di) < k′ < k), and

• QO

y

P

Υ)[k′′] = X (∀k′′ such that k < k′′ ≤ (

i=1 di)). Moreover, ΓΥ(sj
Υ → R+, is a function that maps each input quality level to an output quality (a non-negative

Υ : SΥ ×QI

real number) corresponding to every operational modes.
It may be noted that, ∀k (1 ≤ k ≤ nΥ), ∀j (1 ≤ j ≤ lΥ), QO
Υ) =
0, whenever ΓΥ(s) = 0eΥ and ΓΥ(s′) = YeΥ indicating the operating modes where CΥ completely failed
or fully suspended, respectively. Moreover, if the input quality (q) falls below qlΥ
Υ , then the output quality
becomes zero, i.e. QO
Υ ∪ T C

Υ denotes the set of transitions from one state to another and TΥ ⊆ SΥ × SΥ. T F

Υ, q) = 0, whenever q < qlΥ
Υ .

Υ and T C
Υ

Υ and QO

Υ) = QO

Υ) ≤ qj

Υ(s′, qj

Υ(s, qj

Υ, qj

Υ(sk

Υ(sk

are the transitions indicating failure and suspension of an operating mode, respectively.

• TΥ = T F

– The transition, T F

Υ (sj

Υ, sk

Υ), from the state sj

Υ ∈ SΥ to the state sk

Υ ∈ SΥ (1 ≤ j, k ≤ nΥ) is permissible

only when either of the following two conditions happen:
(a) ∃w′ (1 ≤ w′ ≤ eΥ), such that ΓΥ(sj

eΥ and w 6= w′), ΓΥ(sj

Υ)[w] = ΓΥ(sk

Υ)[w].

Υ)[w′] = 1 and ΓΥ(sk

Υ)[w′] = 0, whereas ∀w (1 ≤ w ≤

(b) ∃w′ (2 ≤ w′ ≤ eΥ), such that ΓΥ(sj

Υ)[w′ − 1] = 1, ΓΥ(sj

Υ)[w′] = X and ΓΥ(sk

0, ΓΥ(sk

Υ)[w′] = 1, whereas ∀w (1 ≤ w ≤ eΥ and w 6= w′ or w 6= w′ − 1), ΓΥ(sj

Υ)[w′ − 1] =
Υ)[w].

Υ)[w] = ΓΥ(sk

– The transition, T C

Υ (sj

Υ, sk

Υ), from the state sj

Υ ∈ SΥ to the state sk

Υ ∈ SΥ (1 ≤ j, k ≤ nΥ) is permissible

only when either of the following two conditions happen:
(a) ∃w′ (1 ≤ w′ ≤ eΥ), such that ΓΥ(sj

eΥ and w 6= w′), ΓΥ(sj

Υ)[w] = ΓΥ(sk

Υ)[w].

Υ)[w′] = 1 and ΓΥ(sk

Υ)[w′] = Y, whereas ∀w (1 ≤ w ≤

(b) ∃w′ (2 ≤ w′ ≤ eΥ), such that ΓΥ(sj

Υ)[w′ − 1] = 1, ΓΥ(sj

Y, ΓΥ(sk

Υ)[w′] = 1, whereas ∀w (1 ≤ w ≤ eΥ and w 6= w′), ΓΥ(sj

Υ)[w′] = X and ΓΥ(sk
Υ)[w] = ΓΥ(sk
Υ)[w].

Υ)[w′ − 1] =

• ExprΥ is a function that produces an algebraic operational probability expression7 containing the symbolic
Υ ∈ SΥ (1 ≤ j ≤ nΥ). Formally,

reliability variables from RΥ based on the conﬁguration of an input state, sj

eΥ

Υ) =

∀j (1 ≤ j ≤ nΥ), ExprΥ(sj

Υ)[k] = 1
Υ)[k] = 0
Υ)[k] = X or Y
Substituting the reliability values for each rΥ,j ∈ RΥ (1 ≤ j ≤ eΥ) in the expression ExprΥ, we can get
the successful operating probability value for the mode of operation in state sj
Υ.
The following example illustrates such formal QRModel characterization in details.

(rΥ,k), when ΓΥ(sj
(1 − rΥ,k), when ΓΥ(sj
1, when ΓΥ(sj

where, relj

Υ[k] =

Υ[k],

relj

Y
k=1






Example 4. Consider the three components, C1, C2 and C3, having the QRSpec, P1, P2 and P3, as presented
in Example 2. The QRModel for these three components, which are represented by the state transition diagram
and the conﬁguration details corresponding to every state, are illustrated in Figure 4 with Table 3. For C1,
we have the QRModel, Q1 = h{C1}, QI
1, R1, S1, s1
• The input quality levels are speciﬁed as, QI
• The symbolic reliability variables are, R1 = {r1,1, r1,2}.
• The 7 operational states are, S1 = {s1
• The 2-length operational state conﬁgurations are, Γ1(s1
1, 50) = 40, QO
• The output quality are deﬁned as, QO

1) = 00, . . . , Γ1(s7
1 (s1
1 (s1
All output quality values at all other operating states are deﬁned similarly.

1) = 1X, . . . , Γ1(s4
1, 30) = 25, QO
1 (s1

1, Γ1, QO
1 = {50, 30, 20}.

1 , Expr1i, where:

1, 20) = 10.

1, . . . , s7

1 ∪ T C

1) = YY.

1 , T F

1, s2

1}.

7 The need to upkeep such algebraic expressions, in its complete form without calculating values instantly, is to enable seamless
reliability composition (which will be explained in later sections) where same component participates (i.e. instantiated or
invoked) multiple times in a component-based system with series/parallel system setup.

10

Aritra Hazra

C

1

s1
1

1X

Failure

Suspend

4
s1

00

C

3

2
s1

01

Failure

Suspend

5
s1

0Y

3
s1

Y1

Failure

6
s1

Y0

Suspend

7
s1

YY

s1
3

1X

Failure

Suspend

2
s3

01

Failure

Suspend

4
s3

00

5
s3

0Y

3
s3

Y1

Failure

6
s3

Y0

Suspend

7
s3

YY

2C

1
s2

1

Failure

Suspend

2s
2

0

3
s2

Y

Fig. 4. State Transition Diagram corresponding to QRModel, Qi, for three Components, Ci (1 ≤ i ≤ 3)

Component
Name

C1

C2

C3

State Operating Mode

ID
s1
1
s2
1
s3
1
s4
1
s5
1
s6
1
s7
1
s1
2
s2
2
s3
2
s1
3
s2
3
s3
3
s4
3
s5
3
s6
3
s7
3

Conﬁguration
1X
01
Y1
00
0Y
Y0
YY
1
0
Y
1X
01
Y1
00
0Y
Y0
YY

Input Quality
Values (Levels)
h50, 30, 20i
h50, 30, 20i
h50, 30, 20i
h0i
h0i
h0i
h0i
h40, 10i
h0i
h0i
h50, 20, 10i
h50, 20, 10i
h50, 20, 10i
h0i
h0i
h0i
h0i

Output Quality
Values (Levels)
h40, 25, 10i
h35, 25, 10i
h35, 25, 10i
h0i
h0i
h0i
h0i
h30, 10i
h0i
h0i
h45, 20, 5i
h40, 15, 5i
h40, 15, 5i
h0i
h0i
h0i
h0i

Operating Mode Probability
Value
Algebraic Expression
0.80
r1,1
0.14
(1 − r1,1).r1,2
0.70
r1,2
0.06
(1 − r1,1).(1 − r1,2)
0.20
(1 − r1,1)
0.30
(1 − r1,2)
1.00
1
0.95
r2,1
0.05
(1 − r2,1)
1.00
1
0.90
r3,1
0.08
(1 − r3,1).r3,2
0.80
r3,2
0.02
(1 − r3,1).(1 − r3,2)
0.10
(1 − r3,1)
0.20
(1 − r3,2)
1.00
1

Table 3. QRModel Conﬁguration Details, Qi, for Three Components, Ci (1 ≤ i ≤ 3)

1)}.

1 = {(s1

1); (s2
1, s3

1, s6
1); (s3

1, s2
1 = {(s1

1) = 0.8 and r1,2 = Z1(m2

1) = 0.7. Whenever C1 is operating in m1

1); (s3
1)}.
1, s7
1, s5
1) = (r1,1), Expr1(s2

• The failure state transitions are, T F
1, s4
• The suspend state transitions are, T C
1); (s2
• The operational probability expressions are, Expr1(s1
1) = (1 − r1,1)(r1,2), . . . so on.
The intuitive explanation of such a QRModel for C1 is as follows. C1 can operate in two modes with reliability,
r1,1 = Z1(m1
1 with the reliability 0.8 (as
well as the operational probability = 0.8), the output quality values are 40, 25 and 10 units when the input
quality levels are at least 50, within [30, 50) and within [20, 30) units, respectively. Now, when C1 fails in
the ﬁrst mode of operation and moves to operate in mode m2
1, then the reliability becomes 0.7 (however,
the operational probability becomes = (1 − 0.8) × 0.7 = 0.14 as derived from Expr1(s2
1)) in the next/second
operational mode, the output quality values are 35, 25 and 10 units when the input quality levels are at
least 50, within [30, 50) and within [20, 30) units, respectively. Finally, when C1 completely fails to operate
in any of these two modes and enters m0
1 (having the operating probability = (1 − 0.8) × (1 − 0.7) = 0.06
derived from Expr1(s4
1)), the output quality is 0 (zero) irrespective of its input quality levels. In addition to
this, when C1 is suspended (controlled) at mode m1
1 with the
reliability 0.7 (i.e., having the operational probability = 1.0 × 0.7 = 0.7), and the output quality values are
35, 25 and 10 units when the input quality levels are at least 50, within [30, 50) and within [20, 30) units,
respectively. When C1 is suspended in both its operating mode, the output quality is 0 (zero) irrespective
✷
of the input quality levels, since it is not operating at all.

1, then it automatically enters/operates at m2

It may be noted that the formal representation of the quality measures in the component-level and the system-

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

11

level are generic and representation-wise similar. Since the underlying representation of the component
QRModel is a generic state-transition system, so our proposed compositional framework will formally derive
composite state-transition model to represent system QRModel, as described in the next section in details.

4. A Generic Quality Composition Framework

This section presents the formal approaches to (a) hierarchically compose (series/parallel) formal quality
measures (QRModel) of components and sub-systems, and (b) then obtain system QRSpec directly from such
formally represented composed quality measures. The ﬁrst part will be enabled by the proposed algebra for
quality composition of series and parallel component structures and then extend our approach to show its
applicability over generic component structures as well.

4.1. Problem Statement

The formal problem statement for quality assessment of a generic component-based system is described as:

Given – A component-based system, Υ = hI, O, C, V, E, Li with n connected subsystem structures, where
i , Ri, Si, s1
Objective – Derive the composed QRModel, QΥ = hCΥ, QI

each Ci ∈ C has the QRModel, Qi = h{Ci}, QI

i , Γi, QO
Υ, RΥ, SΥ, s1

Υ, TΥ, ExprΥi, for the overall

i , Ti, Exprii.

Υ, ΓΥ, QO

system structure, Υ.

The generic framework to the above problem can be obtained by hierarchical compositions of elementary
series and parallel component structures in component-based systems. Therefore, given the two subsystem
structures, Υi and Υj, having their QRModel as, QΥi = hCΥi , QI
Υi, TΥi, ExprΥii and
QΥj = hCΥj , QI
Υj , TΥj , ExprΥj i respectively, we formulate the following two primi-
tive quality composition sub-problems to establish the generic compositional framework.

Υj , RΥj , SΥj , s1

Υi, RΥi, SΥi, s1

Υj , ΓΥj , QO

Υi, ΓΥi , QO

Series Composition Problem: Derive the compositional QRModel, QΥS = QΥi ◦ QΥj , when Υi and Υj

are connected in series (Υi followed by Υj) forming the system, ΥS ≡ Υi ◦ Υj.

Parallel Composition Problem: Derive the compositional QRModel, QΥP = QΥi || QΥj , when Υi and

Υj are connected in parallel forming the system, ΥP ≡ Υi || Υj.

4.2. Approaches for Quality Composition

The composition of quality measures for the series and parallel subsystems can be carried out using various
principles. Here, we introduce the compositional algebra for the primitive (series and parallel) operations.

4.2.1. Series Composition

Let the two subsystem structures, Υi and Υj have the respective QRModel as,
QΥi = hCΥi , QI

Υi, TΥi, ExprΥii and QΥj = hCΥj , QI

Υi, RΥi, SΥi, s1

Υi , ΓΥi, QO

Υj , RΥj , SΥj , s1

Υj , ΓΥj , QO

Υj , TΥj , ExprΥj i.

ΥS = QI

ΥS , RΥS , SΥS , s1

These are appended in series forming the composite system, ΥS ≡ Υi ◦ Υj, whose QRModel, can be derived
as follows: QΥi ◦ QΥj ≡ QΥS = hCΥS , QI
• CΥS = CΥi ∪ CΥj , denotes the set of participating components in ΥS.
• QI
• RΥS = RΥi ∪ RΥj , denotes the combined set of all symbolic reliability variables with |RΥS | = eΥS .
• SΥS is the set of states (with s1
• ΓΥS : SΥS → {1, 0, X, Y}eΥS is the eΥS -length state conﬁguration, such that for a state, sk
Υi ∈ SΥi (1 ≤ a ≤ nΥi) and sb

ΥS ∈ SΥS being the start state) representing state conﬁgurations of QΥS .
ΥS ∈ SΥS , the
Υj ∈ SΥj (1 ≤

lΥi
Υi } denotes the set of lΥS = lΥi input quality values (levels) used by CΥi .

ΥS , TΥS , ExprΥS i, where:

ΥS , ΓΥS , QO

Υi = {q1

Υi, . . . , q

Υi, q2

composed state conﬁguration, sk
b ≤ nΥj ), denoted as ΓΥS (sk

ΥS is obtained from states sa
Υi) ⊙ ΓΥj (sb

ΥS ) = ΓΥi (sa

(eΥi ≤ eΥS ≤ eΥi + eΥj )

Υj ), as follows:

12

Aritra Hazra

ΥS )[1..eΥi] = ΓΥi(sa
– ΓΥS (sk
– ∀v (1 ≤ v ≤ eΥj ), ∃u (u ≤ v), ΓΥS (sk

Υi )[1..eΥi], and

ΥS )[eΥi +u] = ΓΥj (sb

Υj )[v] (1 ≤ u ≤ eΥS −eΥi) when rΥj ,v ∈ RΥj

but rΥj ,v /∈ RΥi .
Intuitively, the last rule prevents the composed conﬁguration to create duplicate conﬁguration entries
in case of multiple occurrence of the same component in both CΥi and CΥj subsystems.

• QO

ΥS : SΥS × QI

ΥS → R+ indicates the function to compute the output quality value.

For a state, sk
ΥS ∈ SΥS , where ΓΥS (sk
ΥS ) = ΓΥi(sa
∀ki (1 ≤ ki ≤ lΥi), ∃kj (1 ≤ kj ≤ lΥj ) such that QO
as well as ∄k′ (1 ≤ k′ ≤ lΥj ) so that qkj

Υj < qk

Υi ) ⊙ ΓΥj (sb
ΥS , qki
ΥS (sk
Υi, qki

Υi (sa

Υj ≤ QO

Υi
Υi).

′

Υj ) (sa
) = QO

Υi ∈ SΥi, sb
Υj , qkj
Υj (sb

Υj

Υj ∈ SΥj ), we have:
) and QO
Υi(sa

Υi , qki

Υi

) ≥ qkj
Υj

,

Υi , sa′

ΥS ∪T C

ΥS , where T F

Υi) and TΥj (sb

ΥS ∈ SΥS , if ΓΥS (sk

• TΥS ⊆ SΥS ×SΥS denotes the transition relation and let TΥS = T F
of failure and suspend transitions, respectively. Suppose, TΥi(sa
QΥi and QΥj , respectively where sa
For sk
(∃sk′

Υi, sa′
ΥS ) = ΓΥi(sa

ΥS ∈ SΥS ) such that one of the following three conditions hold:
(i) ΓΥS (sk′
(ii) ΓΥS (sk′
(iii) ΓΥS (sk′

ΥS ) = ΓΥi (sa
ΥS ) = ΓΥi (sa′
ΥS ) = ΓΥi (sa′
Υi , sa′

Υi) ⊙ ΓΥj (sb′
Υi) ⊙ ΓΥj (sb
Υi) ⊙ ΓΥj (sb′
Υi; TΥj (sb

(a) TΥi(sa

Υi) ∈ T F

Υj ), or
Υj ), or
Υj ) along with either of the following two constraints:
Υj , sb′
(b) TΥi(sa
Υi; TΥj (sb

Υi) ∈ T C

Υj ) ∈ T F

Υj , or

Υi , sa′

Υi ∈ SΥi (1 ≤ a, a′ ≤ nΥi) and sb
ΥS , sk′
Υi ) ⊙ ΓΥj (sb

Υj ), then TΥS (sk

ΥS and T C
Υj , sb′

ΥS are the set
Υj ) are transition in
Υj , sb′
Υj ∈ SΥj (1 ≤ b, b′ ≤ nΥj ).
ΥS ) is a permissible transition

Υj , sb′

Υj ) ∈ T C
Υj .

Further, it is important to note the categorization of transitions (failure or suspended) here as follows:

– TΥS (sk

Υj ) ∈ T F
Υi) ∈ T F

ΥS , sk′
(a) TΥi(sb
(b) TΥi(sa
ΥS , sk′
(a) TΥi(sb
(b) TΥi(sa

ΥS (is a failure transition), whenever either of the following happens:
Υj and Condition-(i) / Condition-(iii-a) is satisﬁed from above, or
Υi and Condition-(ii) / Condition-(iii-a) is satisﬁed from above.
ΥS (is a suspend transition), whenever either of the following happens:
Υj and Condition-(i) / Condition-(iii-b) is satisﬁed from above, or
Υi and Condition-(ii) / Condition-(iii-b) is satisﬁed from above.
• ExprΥS indicates the function for deriving algebraic reliability expression. For a state, sk

ΥS ) ∈ T F
Υj , sb′
Υi , sa′
ΥS ) ∈ T C
Υj , sb′
Υi , sa′

Υj ) ∈ T C
Υi) ∈ T C

– TΥS (sk

ΓΥS (sk

ΥS ) = ΓΥi (sa

Υi) ⊙ ΓΥj (sb

Υj ) with sa

Υi ∈ SΥi , sb

Υj ∈ SΥj , we have:

ΥS ∈ SΥS , where

ExprΥS (sk

ΥS ) ←

ExprΥi(sa
(cid:2)

Υi )
(cid:3)

.

ExprΥj (sb
(cid:2)

Υj )

(cid:3) (cid:12)
(cid:12)
(cid:12)

rp
Υi,ki

=rΥi,ki

and rp

Υj ,kj

=rΥj ,kj

(1 ≤ ki ≤ eΥi, 1 ≤ kj ≤ eΥj , and p ∈ N)

which means that, after making the simpliﬁed expression of ExprΥS (sk
ΥS ), all the common symbolic
reliability variables, leading to the raise in their power of terms, are normalized. Intuitively, this step
takes care of the eﬀect of having multiple instantiation/invocation of the same component inside the
system structure while calculating operating probability from the generated expressions [26].

The following example demonstrates the QRModel derivation for a series system from the given QRModel for
each of its constituent components/subsystems.

Example 5. Let us revisit the 2-component series system (ΥS) shown in Figure 3(a) and determine the
QRModel for this, say QΥS , comprising of the component C3 followed by the component C2. Formally,
QΥS = Q3 ◦ Q2, where Q3 and Q2 are already deﬁned in Example 4 (with Figure 4 and Table 3). Here for
ΥS, the derived QRModel, QΥS , which is represented by the state transition diagram and the conﬁguration
details corresponding to every state, is expressed in Figure 5 with Table 4. For ΥS, we have:

• The set of 2 participating components as, CΥS = {C3, C2}

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

13

1
3

1
(s  , s  )
2
1s
1X1
Ys

F

F

C

1
3

2
(s  , s  )
2
2
s
1X0
Ys

F

C

2
3

2
(s  , s  )
2
6
s
010
Ys

F

C

3
3

2
(s  , s  )
2
7
s
Y10
Ys

C

F

2
3

1
(s  , s  )
2
3
s
011
Ys

F

F

C

C

4
3

1
(s  , s  )
2
8
s
001
Ys

2
3

3
(s  , s  )
2
9
s
01Y
Ys

F

C

F

C

F

C

C

1
3

3
(s  , s  )
2
4
s
1XY
Ys

3
3

1
(s  , s  )
2
5
s
Y11
Ys

F

F

C

C

F

C

5
1
(s  , s  )
3
2
10
Ys

s

0Y1

3
3
(s  , s  )
2
3
11
Y1Y
Ys
C

s

F

6
1
(s  , s  )
2
3
12
Y01
Ys

s

F

C

7
1
(s  , s  )
2
3
13
YY1
Ys

s

F

C

000

s

14
Ys
4(s  , s  )2
2

3

s

15
0Y0
Ys
2
5
(s  , s  )
3
2

s

16
Y00
Ys
2
6
(s  , s  )
3
2

s

17
YY0
Ys
2
(s  , s  )
2

7
3

s

18
00Y
Ys
3
4
(s  , s  )
3
2

s19
0YY
Ys
3
5
(s  , s  )
3
2

s

20
Y0Y
Ys
3
6
(s  , s  )
2
3

s

21
YYY
Ys
3
7
(s  , s  )
3
2

Fig. 5. State Transition Diagram for the Example QRModel after Series Composition: QΥS = Q3 ◦ Q2

State
ID
s1
ΥS
s2
ΥS
s3
ΥS
s4
ΥS
s5
ΥS
s6
ΥS
s7
ΥS
s8
ΥS
s9
ΥS
s10
ΥS
s11
ΥS
s12
ΥS
s13
ΥS
s14
ΥS
s15
ΥS
s16
ΥS
s17
ΥS
s18
ΥS
s19
ΥS
s20
ΥS
s21
ΥS

Composite Operating Mode
State Pair
3, s1
(s1
2)
3, s2
(s1
2)
3, s1
(s2
2)
3, s3
(s1
2)
3, s1
(s3
2)
3, s2
(s2
2)
3, s2
(s3
2)
3, s1
(s4
2)
3, s3
(s2
2)
3, s1
(s5
2)
3, s3
(s3
2)
(s6
3, s1
2)
3, s1
(s7
2)
3, s2
(s4
2)
3, s2
(s5
2)
3, s2
(s6
2)
3, s2
(s7
2)
3, s3
(s4
2)
3, s3
(s5
2)
3, s3
(s6
2)
3, s3
(s7
2)

Conﬁguration
1X1
1X0
011
1XY
Y11
010
Y10
001
01Y
0Y1
Y1Y
Y01
YY1
000
0Y0
Y00
YY0
00Y
0YY
Y0Y
YYY

Input Quality
Values (Levels)
h50, 20i
h0i
h50, 20i
h0i
h50, 20i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i

Output Quality
Values (Levels)
h30, 10i
h0i
h30, 10i
h0i
h30, 10i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i

Operating Mode Probability
Algebraic Expression
r3,1.r2,1
r3,1.(1 − r2,1)
(1 − r3,1).23,2.r2,1
r3,1
r3,2.r2,1
(1 − r3,1).r3,2.(1 − r2,1)
r3,2.(1 − r2,1)
(1 − r3,1).(1 − r3,2).r2,1
(1 − r3,1).r3,2
(1 − r3,1).r2,1
r3,2
(1 − r3,2).r2,1
r2,1
(1 − r3,1), (1 − r3,2).(1 − r2,1)
(1 − r3,1).(1 − r2,1)
(1 − r3,2).(1 − r2,1)
(1 − r2, 1)
(1 − r3,1).(1 − r3,2)
(1 − r3,1)
(1 − r3,2)
1

Value
0.855
0.045
0.076
0.900
0.760
0.004
0.040
0.019
0.080
0.095
0.800
0.190
0.950
0.001
0.005
0.010
0.050
0.020
0.100
0.200
1.000

Table 4. QRModel Conﬁguration Details after the Example Series Composition: QΥS = Q3 ◦ Q2

• The set of 3 input quality levels as, QI
• The set of 3 symbolic reliability variables as, RΥS = {r3,1, r3,2, r2,1} with values, 0.9, 0.8, 0.95, respectively.
• The set of 21 states, SΥS = {s1
ΥS , s2
• The state conﬁgurations are given as,

ΥS = {50, 20, 10}.

ΥS , . . . , s21

ΥS }.

ΓΥS (s1

ΥS ) = ΓΥ3 (s1

3) ⊙ ΓΥ2(s1

2) = 1X1, ΓΥS (s2

ΥS ) = ΓΥ3 (s1

3) ⊙ ΓΥ2 (s2

2) = 1X0, . . . so on.

QO

• All derived output quality values are given in Figure 5. To exemplify the derivation,
3 (s1
2 (s1

2, 45) = QO
• All state transitions (both failure and suspension) are shown in Figure 5. To exemplify the derivation,

3, 50) = 45 > 40).

ΥS , 50) = QO

3, 50)) = QO

2, 40) = 30

(since, QO

ΥS (s1

2, QO

3 (s1

2 (s1

2 (s1

14

Aritra Hazra

– The failure transitions are, T F

ΥS =

(s1

ΥS , s2

ΥS ), (s1

ΥS , s3

ΥS ), . . .

(marked with dotted edges and labeled using F)

(cid:8)

.
(cid:9)

– The suspend transitions are, T C

ΥS , s4
(marked with solid edges and labeled using C)

ΥS =

(s1

(cid:8)

ΥS ), (s1

ΥS , s5

ΥS ), . . .

.

(cid:9)

ExprΥS (s1

• All algebraic operational probability expressions are shown in Figure 5. To exemplify the derivation,
ΥS ) = (1 − r3,1).r3,2.r2,1; . . . so on.

ΥS ) = r3,1.(1 − r2,1); ExprΥS (s3
There may be multiple choices from an operational state upon its failure or suspend and such a choice can
✷
lead to any one among these options non-deterministically.

ΥS ) = r3,1.r2,1; ExprΥS (s2

4.2.2. Parallel Composition

Let the two subsystem structures, Υi and Υj have the respective QRModel as,

QΥi = hCΥi , QI

Υi, RΥi, SΥi, s1

Υi , ΓΥi, QO

Υi, TΥi, ExprΥii and QΥj = hCΥj , QI

Υj , RΥj , SΥj , s1

Υj , ΓΥj , QO

Υj , TΥj , ExprΥj i.

These are connected in parallel forming the composite system, ΥP ≡ Υi || Υj, whose QRModel, can be derived
as follows: QΥi || QΥj ≡ QΥP = hCΥP , QI

ΥP , TΥP , ExprΥP i, where:

ΥP , RΥP , SΥP , s1

ΥP , ΓΥP , QO

Υi ∪ QI

ΥP = QI

Υj , denotes the combined set of lΥP input quality values (levels) used by CΥi and CΥj .

• CΥP = CΥi ∪ CΥj , denotes the set of participating components in ΥP .
• QI
• RΥP = RΥi ∪ RΥj , denotes the combined set of all symbolic reliability variables with |RΥP | = eΥP .
• SΥP is the set of states (with s1
• ΓΥP : SΥP → {1, 0, X, Y}eΥP is the eΥP -length state conﬁguration, such that for a state, sk
Υi ∈ SΥi (1 ≤ a ≤ nΥi ) and sb

ΥP ∈ SΥP being the start state) representing state conﬁgurations of QΥP .
ΥP ∈ SΥP , the
Υj ∈ SΥj (1 ≤

composed state conﬁguration, sk
b ≤ nΥj ), denoted as ΓΥP (sk

ΥP is obtained from states sa
Υi ) ⊙ ΓΥj (sb

ΥP ) = ΓΥi(sa

(eΥi ≤ eΥP ≤ eΥi + eΥj )

Υj ), as follows:

ΥP )[1..eΥi] = ΓΥi(sa
– ΓΥP (sk
– ∀v (1 ≤ v ≤ eΥj ), ∃u (u ≤ v), ΓΥP (sk

Υi )[1..eΥi], and

ΥP )[eΥi +u] = ΓΥj (sb

Υj )[v] (1 ≤ u ≤ eΥP −eΥi) when rΥj ,v ∈ RΥj

but rΥj ,v /∈ RΥi .
Intuitively, the last rule prevents the composed conﬁguration to create duplicate conﬁguration entries
in case of multiple occurrence of the same component in both CΥi and CΥj subsystems.

• QO

ΥP : SΥP × QI

ΥP → R+ indicates the function to compute the output quality value.

For a state, sk
from qx

Υi, qx′

ΥP ∈ SΥP , where ΓΥP (sk
Υj , qy′

Υj ∈ QI

Υi, qy

Υi ∈ QI

ΥP ) = ΓΥi(sa

Υi ) ⊙ ΓΥj (sb

Υj ) (sa

Υi ∈ SΥi, sb

Υj ∈ SΥj ), we generate:

Υj (where 1 ≤ x, x′ ≤ lΥi, 1 ≤ y, y′ ≤ lΥj ) and ∀w (1 ≤ w ≤ lΥP ),

✄ Maximum Quality Output: In this case, the overall quality measure is produced by choosing the max-
imum quality value from various operational modes of the components. Formally, we express this as:

QO

ΥP (sk

ΥP , qw

ΥP ) =

MAX
(cid:2)






QO

Υi(sa

Υi , qx

Υi), QO

Υj (sb

Υj , qy

Υj )
(cid:3)

Υi ≤ qw

Υj ≤ qx
Υj

Υi such that qx

ΥP , and
Υi < qx′
≤ qw
Υj < qy′

Υj such that qy
Υi such that qy

Υi , ∃qy
, when ∃qx
∄qy′
∄qx′
Υj
or, ∃qy
, ∃qx
Υj
∄qy′
∄qx′
Υi
Υi), when ∀qy
Υj , ∃qx
∄qx
Υi such that qx
Υi , ∃qy
), when ∀qx
Υj
∄qy′
Υj
0, when ∀qx

Υj ≤ qx
Υj < qy′
Υi < qy
Υi < qx′
Υi ≤ qw
Υi such that qx
Υi < qx
Υi ≤ qw
ΥP
such that qy
≤ qw
ΥP < qx
Υj
< qy′
such that qy
≤ qw
ΥP
Υj
Υj
Υj such that qw
ΥP < qx
Υi, and qw

Υi ≤ qy
ΥP < qy

Υj such that qx

Υj , and

Υi, and

ΥP , and

′

′

Υj

Υi ≤ qw
ΥP

Υj ≤ qw
ΥP

ΥP < qy

Υj

Υi , ∀qy
(otherwise)

QO

Υi(sa

Υi , qx

QO

Υj (sb

Υj , qy

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

15

Here, the output quality measure is derived based on the best output value possible (given an input level)
considering both the output functions of CΥi and CΥj .

✄ Ordered Quality Output: In this case, the out quality is governed by a pre-deﬁned ordering among the
components/subsystems, say, CΥi ≺ CΥj . Formally, we express this as:
such that qw
Υj such that qy
< qy′

Υi, and qw
ΥP < qx

Υi , ∀qy
Υi , ∃qy

ΥP < qx
Υj ≤ qw
≤ qw
ΥP

such that qy
Υj

ΥP < qy

Υi, and

ΥP , qw

Υj , qy

ΥP (sk

ΥP ) =

Υj (sb

QO

QO

Υj

Υj

Υj

0, when ∀qx
Υj ), when ∀qx
∄qy′
Υj
Υi ), otherwise

QO

Υi(sa

Υi, qx





Here, the output quality measure is derived based on the following (ordering) rules:

– When both the subsystems, CΥi and CΥj , are operational then it is the output quality measure
provided by CΥi, provided its input quality level is above the lowest input quality value supported
(only otherwise we switch to CΥj ’s output quality function),

– When the subsystem CΥi fails or suspended completely and CΥj remains operational, then it is the

output quality measure provided by CΥj , and

– It is 0 (zero) when both CΥi and CΥj fails or suspended completely.
ΥP ∪T C

• TΥP ⊆ SΥP ×SΥP denotes the transition relation and let TΥP = T F
of failure and suspend transitions, respectively. Suppose, TΥi(sa
QΥi and QΥj , respectively where sa
For sk
(∃sk′
(i) ΓΥP (sk′
(iii) ΓΥP (sk′
(a) TΥi(sa

ΥP ∈ SΥP ) such that one of the following three conditions hold:
Υi) ⊙ ΓΥj (sb′
ΥP ) = ΓΥi(sa′
Υj ),
Υi) ⊙ ΓΥj (sb′
Υj ) along with either of the following two constraints:
Υj , sb′
Υi; TΥj (sb

Υi ∈ SΥi (1 ≤ a, a′ ≤ nΥi) and sb
ΥP , sk′
Υi) ⊙ ΓΥj (sb

ΥP ) = ΓΥi (sa
ΥP ) = ΓΥi(sa′
Υi, sa′
Υi ) ∈ T F

Υi, sa′
ΥP ) = ΓΥi (sa

ΥP ∈ SΥP , if ΓΥP (sk

Υj ), then TΥP (sk

Υi) and TΥj (sb

ΥP , where T F

Υi ) ⊙ ΓΥj (sb

(ii) ΓΥP (sk′

Υi; TΥj (sb

(b) TΥi(sa

Υi ) ∈ T C

Υj ) ∈ T F

Υj ), or

Υi , sa′

Υi, sa′

Υj , or

or

ΥP and T C
Υj , sb′

ΥP are the set
Υj ) are transition in
Υj , sb′
Υj ∈ SΥj (1 ≤ b, b′ ≤ nΥj ).
ΥP ) is a permissible transition

Υj , sb′

Υj ) ∈ T C
Υj .

Further, it is important to note the categorization of transitions (failure or suspended) here as follows:

ΥP , sk′

– TΥP (sk

Υj ) ∈ T F
Υi) ∈ T F

(a) TΥi(sb
(b) TΥi(sa
ΥP , sk′

ΥP (is a failure transition), whenever either of the following happens:
Υj and Condition-(i) / Condition-(iii-a) is satisﬁed from above, or
Υi and Condition-(ii) / Condition-(iii-a) is satisﬁed from above.
ΥP (is a suspend transition), whenever either of the following happens:
Υj and Condition-(i) / Condition-(iii-b) is satisﬁed from above, or
Υi and Condition-(ii) / Condition-(iii-b) is satisﬁed from above.
• ExprΥP indicates the function for deriving algebraic reliability expression. For a state, sk

ΥP ) ∈ T F
Υj , sb′
Υi , sa′
ΥP ) ∈ T C
Υj , sb′
Υi , sa′

(a) TΥi(sb
(b) TΥi(sa

Υj ) ∈ T C
Υi) ∈ T C

– TΥP (sk

ΓΥP (sk

ΥP ) = ΓΥi (sa

Υi) ⊙ ΓΥj (sb

Υj ) with sa

Υi ∈ SΥi, sb

Υj ∈ SΥj , we have:

ΥP ∈ SΥP , where

ExprΥP (sk

ΥP ) ←

ExprΥi(sa
(cid:2)

.
Υi )
(cid:3)

(cid:2)

ExprΥj (sb

Υj )

rp
Υi,ki

=rΥi,ki

and rp

Υj ,kj

=rΥj ,kj

(1 ≤ ki ≤ eΥi, 1 ≤ kj ≤ eΥj , and p ∈ N)

(cid:3) (cid:12)
(cid:12)
(cid:12)

which means that, after making the simpliﬁed expression of ExprΥP (sk
ΥP ), all the common symbolic
reliability variables, leading to the raise in their power of terms, are normalized. Intuitively, this step
takes care of the eﬀect of having multiple instantiation/invocation of the same component inside the
system structure while calculating operating probability from the generated expressions [26].

The following example demonstrates the QRModel derivation of a parallel system from the given QRModel for
each of its constituent components/subsystems.

Example 6. Let us revisit the 2-component parallel system (ΥP ) shown in Figure 3(b) and determine the

16

Aritra Hazra

1
1

1
(s  , s  )
2
1s
1X1
Yp

F

F

C

1
2
(s  , s  )2
1
s2
Yp

1X0

F

C

1

2(s  , s  )
1
2
s3
011
Yp

F

F

C

C

C

1
3
(s  , s  )2
1
s4
Yp

1XY

1

3(s  , s  )
1
2
s5
Y11
Yp

F

2
1

2
(s  , s  )
2
s6
010
Yp

F

C

3
1

2
(s  , s  )
2
s7
Y10
Yp

C

F

4
1
(s  , s  )2
1
s8
Yp

001

2
3
(s  , s  )2
1
s9
Yp

01Y

F

C

F

C

F
5
1
(s  , s  )2
1
s10
Yp

0Y1

F

C

C

C

F

C

3
3
(s  , s  )
2
1
s11
Y1Y
Yp
C

F

6
1
(s  , s  )2
1
s12
Yp

Y01

F

C

7
1
(s  , s  )2
1
s13
Yp

YY1

F

C

000

s14
Yp
4(s  , s  )2
2

1

s15
0Y0
Yp
2
5
(s  , s  )
1
2

s16
Y00
Yp
2
6
(s  , s  )
1
2

s17
YY0
Yp
2
(s  , s  )
2

7
1

s18
00Y
Yp
3
4
(s  , s  )
1
2

s19
0YY
Yp
3
5
(s  , s  )
1
2

s20
Y0Y
Yp
3
6(s  , s  )
2

1

s21
YYY
Yp
3
7(s  , s  )
2

1

Fig. 6. State Transition Diagram for the Example QRModel after Parallel Composition: QΥP = Q1 || Q2

State
ID
s1
ΥP
s2
ΥP
s3
ΥP
s4
ΥP
s5
ΥP
s6
ΥP
s7
ΥP
s8
ΥP
s9
ΥP
s10
ΥP
s11
ΥP
s12
ΥP
s13
ΥP
s14
ΥP
s15
ΥP
s16
ΥP
s17
ΥP
s18
ΥP
s19
ΥP
s20
ΥP
s21
ΥP

Composite Operating Mode
State Pair
1, s1
(s1
2)
1, s2
(s1
2)
(s2
1, s1
2)
1, s3
(s1
2)
1, s1
(s3
2)
1, s2
(s2
2)
1, s2
(s3
2)
1, s1
(s4
2)
1, s3
(s2
2)
1, s1
(s5
2)
1, s3
(s3
2)
(s6
1, s1
2)
1, s1
(s7
2)
1, s2
(s4
2)
1, s2
(s5
2)
1, s2
(s6
2)
1, s2
(s7
2)
1, s3
(s4
2)
1, s3
(s5
2)
1, s3
(s6
2)
1, s3
(s7
2)

Conﬁguration
1X1
1X0
011
1XY
Y11
010
Y10
001
01Y
0Y1
Y1Y
Y01
YY1
000
0Y0
Y00
YY0
00Y
0YY
Y0Y
YYY

Input Quality
Values (Levels)
h50, 40, 30, 10i
h50, 30, 20i
h50, 40, 30, 10i
h50, 30, 20i
h50, 40, 30, 10i
h50, 30, 20i
h50, 30, 20i
h40, 10i
h50, 30, 20i
h40, 10i
h50, 30, 20i
h40, 10i
h40, 10i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i

Output Quality
Values (Levels)
h40, 30, 25, 10i
h40, 25, 10i
h35, 30, 25, 10i
h40, 25, 10i
h35, 30, 25, 10i
h35, 25, 10i
h35, 25, 10i
h30, 10i
h35, 25, 10i
h30, 10i
h35, 25, 10i
h30, 10i
h30, 10i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i

Operating Mode Probability
Algebraic Expression
r1,1.r2,1
r1,1.(1 − r2,1)
(1 − r1,1).23,2.r2,1
r1,1
r1,2.r2,1
(1 − r1,1).r1,2.(1 − r2,1)
r1,2.(1 − r2,1)
(1 − r1,1).(1 − r1,2).r2,1
(1 − r1,1).r1,2
(1 − r1,1).r2,1
r1,2
(1 − r1,2).r2,1
r2,1
(1 − r1,1).(1 − r1,2).(1 − r2,1)
(1 − r1,1).(1 − r2,1)
(1 − r1,2).(1 − r2,1)
(1 − r2, 1)
(1 − r1,1).(1 − r1,2)
(1 − r1,1)
(1 − r1,2)
1

Value
0.760
0.040
0.133
0.800
0.665
0.007
0.035
0.057
0.140
0.190
0.700
0.285
0.950
0.003
0.010
0.015
0.050
0.060
0.200
0.300
1.000

Table 5. QRModel Conﬁguration Details after the Example Parallel Composition: Qmax
ΥP

= Q1 || Q2 (Max. Quality O/P)

Here for ΥP , the derived QRModel, Qmax

QRModel for this, say QΥP , comprising of the component C1 connected in parallel with the component C2.
Formally, QΥP = Q1 || Q2, where Q3 and Q2 are already deﬁned in Example 4 (with Figure 4 and Table 3).
ΥP , considering both the maximum and the ordered quality
output, which are represented by the state transition diagram and the conﬁguration details corresponding
to every state, is expressed in Figure 6 with Table 5 and Figure 6 with Table 6, respectively. Note that, the
state transition, mode conﬁguration and the operating mode reliability attributes are same for both these
variants, however the input-output quality measures diﬀer due to their varied treatment. For ΥP , we have:

ΥP and Qord

• The set of 2 participating components as, CΥP = {C1, C2}
• The set of 3 input quality levels as, QI

ΥP = {50, 40, 30, 20, 10}.

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

17

State
ID
s1
ΥP
s2
ΥP
s3
ΥP
s4
ΥP
s5
ΥP
s6
ΥP
s7
ΥP
s8
ΥP
s9
ΥP
s10
ΥP
s11
ΥP
s12
ΥP
s13
ΥP
s14
ΥP
s15
ΥP
s16
ΥP
s17
ΥP
s18
ΥP
s19
ΥP
s20
ΥP
s21
ΥP

Composite Operating Mode
State Pair
1, s1
(s1
2)
1, s2
(s1
2)
1, s1
(s2
2)
1, s3
(s1
2)
1, s1
(s3
2)
1, s2
(s2
2)
1, s2
(s3
2)
1, s1
(s4
2)
1, s3
(s2
2)
1, s1
(s5
2)
1, s3
(s3
2)
1, s1
(s6
2)
1, s1
(s7
2)
1, s2
(s4
2)
1, s2
(s5
2)
1, s2
(s6
2)
(s7
1, s2
2)
1, s3
(s4
2)
1, s3
(s5
2)
1, s3
(s6
2)
1, s3
(s7
2)

Conﬁguration
1X1
1X0
011
1XY
Y11
010
Y10
001
01Y
0Y1
Y1Y
Y01
YY1
000
0Y0
Y00
YY0
00Y
0YY
Y0Y
YYY

Input Quality
Values (Levels)
h50, 30, 20i
h50, 30, 20i
h50, 30, 20i
h50, 30, 20i
h50, 30, 20i
h50, 30, 20i
h50, 30, 20i
h40, 10i
h50, 30, 20i
h40, 10i
h50, 30, 20i
h40, 10i
h40, 10i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i

Output Quality
Values (Levels)
h40, 25, 10i
h40, 25, 10i
h35, 25, 10i
h40, 25, 10i
h35, 25, 10i
h35, 25, 10i
h35, 25, 10i
h30, 10i
h35, 25, 10i
h30, 10i
h35, 25, 10i
h30, 10i
h30, 10i
h0i
h0i
h0i
h0i
h0i
h0i
h0i
h0i

Operating Mode Probability
Algebraic Expression
r1,1.r2,1
r1,1.(1 − r2,1)
(1 − r1,1).23,2.r2,1
r1,1
r1,2.r2,1
(1 − r1,1).r1,2.(1 − r2,1)
r1,2.(1 − r2,1)
(1 − r1,1).(1 − r1,2).r2,1
(1 − r1,1).r1,2
(1 − r1,1).r2,1
r1,2
(1 − r1,2).r2,1
r2,1
(1 − r1,1).(1 − r1,2).(1 − r2,1)
(1 − r1,1).(1 − r2,1)
(1 − r1,2).(1 − r2,1)
(1 − r2, 1)
(1 − r1,1).(1 − r1,2)
(1 − r1,1)
(1 − r1,2)
1

Value
0.760
0.040
0.133
0.800
0.665
0.007
0.035
0.057
0.140
0.190
0.700
0.285
0.950
0.003
0.010
0.015
0.050
0.060
0.200
0.300
1.000

Table 6. QRModel Conﬁguration Details after the Example Parallel Composition: Qord
ΥP

= Q1 || Q2 (Ord. Quality O/P)

• The set of 3 symbolic reliability variables as, RΥP = {r1,1, r1,2, r2,1} with values, 0.8, 0.7, 0.95, respectively.
• The set of 21 states, SΥP = {s1
ΥP , s2
• The state conﬁgurations are given as,

ΥP , . . . , s21

ΥP }.

ΓΥP (s1

ΥP ) = ΓΥ1 (s1

1) ⊙ ΓΥ2(s1

2) = 1X1, ΓΥP (s2

ΥP ) = ΓΥ1(s1

1) ⊙ ΓΥ2(s2

2) = 1X0, . . . so on.

• Under maximum quality output criteria, all derived output quality values are given in Table 5. To exem-

ΥP (s1

1, 50), QO
1 (s1
2 whereas {40} ∈ QI

plify the derivation,
QO
QO
ΥP , 50) = MAX
(cid:2)
(since {50} /∈ QI
Under ordered quality output criteria (with C1 ≺ C2 as given order), all derived output quality values are
given in Table 6. To exemplify the derivation, let us understand the following two derivation:
– QO
– QO

1, 50) = 40 (since C1 ≺ C2 and C1 has not failed),
2, 40) = 30 (since C1 has completely failed, C2 dictates the output quality)

1, 50), QO
2 (s1
= MAX
40, 30
(cid:2)
2 and 50 > 40 being the immediate next input level)

ΥP , 50) = QO
ΥP , 40) = QO

QO
= MAX
(cid:2)

ΥP (s1
ΥP (s8

1 (s1
2 (s1

2, 50)
(cid:3)

2, 40)
(cid:3)

1 (s1

2 (s1

= 40.

(cid:3)

• All state transitions (both failure and suspension) are shown in Figure 6. To exemplify the derivation,
ΥP ), (s1

– The failure transitions are, T F

ΥP ), . . .

ΥP , s3

ΥP , s2

ΥP =

(s1

(marked with dotted edges and labeled using F)

(cid:8)

.
(cid:9)

– The suspend transitions are, T C

ΥP , s4
(marked with solid edges and labeled using C)

ΥP =

(s1

(cid:8)

ΥP ), (s1

ΥP , s5

ΥP ), . . .

.
(cid:9)

• All algebraic operational probability expressions are shown in Table 5 or in Table 6 (these are same for

both variants). To exemplify the derivation,
ExprΥP (s1
ΥP ) = r1,1.r2,1; ExprΥP (s2

ΥP ) = r1,1.(1 − r2,1); ExprΥP (s3
There may be multiple choices from an operational state upon its failure or suspend and such a choice can
✷
lead to any one among these options non-deterministically.

ΥP ) = (1 − r1,1).r1,2.r2,1; . . . so on.

It may be noted that, the series and parallel composition mechanisms with respect to given subsystem
structures are similar except the computation of output quality values. This is due to the fact that the
underlying model of computation is a state transition diagram which composes pair of states from two
subsystems, thereby maintaining identical conﬁgurations in both cases.

18

Aritra Hazra

4.3. Generic Composition Procedures

In order to compute the composed QRModel for a generic series/parallel system structure, we hierarchically
use the series and the parallel composition operations, as mentioned above.

4.3.1. Properties of Composition Operations

Such compositional rules can be applied hierarchically due to the satisfaction of some inherent properties of
composition operations, which are listed below.

(Assume: Qa, Qb, Qc are three QRModels.)

Idempotent Properties:

(a) Series ( ◦ ) composition operation is not idempotent, i.e., Qa ◦ Qa 6≡ Qa.
(b) Parallel ( || ) composition operation is idempotent, i.e., Qa || Qa ≡ Qa.

Associative Properties:

(a) Series ( ◦ ) composition operation is associative, i.e., (Qa ◦ Qb) ◦ Qc ≡ Qa ◦ (Qb ◦ Qc).
(b) Parallel ( || ) composition operation is associative, i.e., (Qa || Qb) || Qc ≡ Qa || (Qb || Qc).

Commutative Properties:

(a) Series ( ◦ ) composition operation is not commutative, i.e., Qa ◦ Qb 6≡ Qb ◦ Qa.
(b) Parallel ( || ) composition operation is commutative, i.e., Qa || Qb ≡ Qb || Qa.

Distributive Properties:

(a) Series ( ◦ ) composition operation is distributive over Parallel ( || ) composition operation, i.e.,

Qa ◦ (Qb || Qc) ≡ (Qa ◦ Qb) || (Qa ◦ Qc).

(b) Parallel ( || ) composition operation is not distributive over Series ( ◦ ) composition operation, i.e.,

Qa || (Qb ◦ Qc) 6≡ (Qa || Qb) ◦ (Qa || Qc).

The distributive nature of ◦ over || establishes the fact that any series-parallel composition is equivalent
to parallel composition of all paths (where each path components are composed in series) from input to
output (which is basically the path-enumeration based rule).

4.3.2. Composition Rules

As an example, the QRModel for the system, Υsp (refer to Figure 2), can be computed in two ways leveraging
the generic composition techniques proposed above.

• Using Series/Parallel-Structure based Composition Rule: The QRModel for the two subsystems, ΥS (the
system structure is shown in Figure 3(a)) and ΥP (the system structure is shown in Figure 3(b)), are
already computed in Example 5 and Example 6, respectively. The QRModel for the overall system, Υsp
(shown in Figure 2), i.e. QΥsp , is the parallel quality composition of QΥP and QΥS again, and it can be
formally derived as: QΥsp = (QΥP || QΥS ) = (cid:16)(Q1 || Q2) || (Q3 ◦ Q2)(cid:17)

• Using Path-Enumeration based Composition Rule: There are three paths from input to output of Υsp,
namely through C1, through C2 and through C3-C2. The quality measure for the overall system, Υsp,
that is QΥsp, is the parallel quality composition of C1 (say Q1), C2 (say Q2) and ΥS (say QΥS ), and it
can be derived expressed as: QΥsp = (Q1 || Q2 || QΥS ) = (cid:16)Q1 || Q2 || (Q3 ◦ Q2)(cid:17)

It is worthy to note two points here as follows:

• The order of serial and parallel compositions may be arbitrary in a composite expression as long as their

associative, commutative and distributive properties, as discussed above, remain intact.

• The quality conﬁguration model for non-series/parallel systems is determined using the path-enumeration
techniques. Here, we can apply the series composition rules over all the component structures that reside
in every path from input to the output of the system. Finally, the parallel composition is applied over
each of these new composed quality measures for each end-to-end path to get the overall system quality.

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

19

5. Conformance Check for System-level QRSpec from QRModel Conﬁgurations

The QRModel of a system describes the formal characterization of its quality attributes using an under-
lying state-transition model based conﬁguration. Such a formalization is useful for assessing quality and
reliability properties of systems, which we shall be detailing in the next section. However, from an user
perspective, the architectural QRSpec of systems forms a foundational basis, as deﬁned in Section 2.2.
Such type of speciﬁcation, depicting system fault-tolerant behavior with only with failure provisions, is
na¨ıve and abstract. So, it is imperative to infer the high-level speciﬁcations expressing the system-level
quality and reliability measures by reﬁning our formal modeling. In the following, we present the steps
to automatically extract back the QRSpecs, PΥ = hCΥ, MΥ, ZΥ, QI
Υi, from the underlying QRModel,
QΥ = hCΥ, QI

Υ, TΥ, ExprΥi, of the system, Υ.

Υ, RΥ, SΥ, s1

Υ, ΓΥ, QO

Υ, QO

Step-1: Make abstractions to the QRModel representation (state-transition system), QΥ, keeping only the
failure (marked as F) transitions and relevant states to build a new conﬁguration, say Q′
Υ. This can be
easily obtained by doing a depth-ﬁrst or breadth-ﬁrst traversal starting from the initial state of QΥ and
progressing only through the F-marked transitions.

Step-2: Represent the composed system modes with respect to the operating modes of each n participating
components together as an n-tuple. If Υ comprises of n components, where each component Ci (1 ≤ i ≤ n)
operates in mi number of operational modes (excluding the failure mode), then the length every state
conﬁguration is eΥ =
∃ki (1 ≤ δ < ki ≤ δ + di ≤ eΥ), where δ =

n
i=1 di. Here, if for some state s ∈ SΥ in Q′

i−1
j=0 dj (1 ≤ i ≤ n), such that the following holds:

Υ, we ﬁnd that,

P

P

ΓΥ(s)[(δ + 1)..(δ + ki − 1)] = 0(ki−1), ΓΥ(s)[δ + ki] = 1 and ΓΥ(s)[(δ + ki + 1)..(δ + di)] = X(di−ki),

Υ =

mk1
(cid:0)

1 , mk2

1 , mk2

then the operating mode for the participating component, Ci, is mki
mk1
2 , . . . , mkn
n (cid:1)
(cid:0)
Υ, in state, s. Formally, ms

i . The combination of the modes,
, for all the components, C1, C2, . . . , Cn, gives the operating modes for the system,

2 , . . . , mkn
n (cid:1)
Step-3: Estimate the reliability of each mode from the system structure, Υ = hI, O, C, V, E, Li. To do so, tra-
ditional reliability estimation methods [26] are followed using typical path-enumeration or series/parallel
approaches utilizing the reliability value Zi(mj
i ) for mode mj
i of component Ci (1 ≤ i ≤ n, 1 ≤ j ≤ di).
Step-4: Establish the output quality value function QO
Υ at each of the composite operational modes of the
Υ. The QRModel directly lists the output quality values corresponding to each state
Υ can be found

abstracted QRModel, Q′
Υ. However, QI
(modes) of Υ with respect to the mentioned input level, thereby deﬁning QO
taking the union of input quality levels present in every state/mode of Q′
Υ.

∈ MΥ.

The above steps reverse synthesize the QRSpec model by only keeping the component mode failure option in
the overall system behavior. Let us present an example to illustrate these mentioned steps in details.

Example 7. First, let us revisit the QRModel, QΥS , obtained for system, ΥS, in Example 5 (and Figure 5
with Table 4). Step-1 abstracts QΥS to form Q′
ΥS which is shown in Figure 7(a) with Table 9 (for ΥS).
According to Step-2, the generated composite modes are labeled against the states of Q′
ΥS as mentioned
in Table 7 (also refer to Figure 7(a)). Then, from the system structure of ΥS (also schematic is shown
in Figure 3(a)), we derive in Step-3 the reliability of each composite modes by taking product of the two
3, mj
component-level reliability values, i.e. ZΥS (cid:0)
2) (0 ≤ i ≤ 2, 0 ≤ j ≤ 1). As part
2)
(cid:1)
of Step-4, the input-output quality levels (values) can be directly found from QRModel, QΥS (Figure 5 with
Table 4). We ﬁnd that the outcomes of Step-3 and Step-4 (presented in Tables 7-9) are similar to what has
been (already) speciﬁed as reliability and input-output quality value-pairs in Table 1.

3).Z2(mj

= Z3(mi

to form Q′max

Similarly, let us revisit the QRModel, Qmax

ΥP , obtained for system, ΥP , in Example 6 (and Figure 6 with
Table 5). Step-1 abstracts Qmax
ΥP which is shown in Figure 7(b) with Table 9 (for ΥP ).
ΥP
According to Step-2, the generated composite modes are labeled against the states of Q′max
ΥP as mentioned
in Table 8 (also refer to Figure 7(b)). Then, from the system structure of ΥP (also schematic is shown in
Figure 3(b)), we derive in Step-3 the reliability of each composite modes by composing the two component-
1, mj
(0 ≤ i ≤ 2, 0 ≤ j ≤ 1).
2)
level reliability values in parallel, i.e. ZΥP (cid:0)
(cid:1)
As part of Step-4, the input-output quality levels (values) can be directly found from QRModel, Qmax
ΥP (Figure 6

1−Z2(mj
2)
(cid:1)
(cid:0)

1−Z1(mi
1)
(cid:1)
(cid:0)

= 1−

(mi

(mi

.

20

Aritra Hazra

1
1
(m  , m  )2
3
1s
Ys

1X1

F

F

1
1
(m  , m  )2
1
1s
Yp

1X1

F

F

(m  , m  )

0
2

1
3

2
s
Ys

1X0

2
1
(m  , m  )2
3
3
s
Ys

011

1
1

(m  , m  )
s2
Yp

0
2
1X0

1
2

2
(m  , m  )
1
s3
Yp

011

F

F

F

F

F

F

2
3

(m  , m  )
6
s
Ys

0
2
010

0
1
(m  , m  )2
3
8
s
Ys

001

2
1

0
2

(m  , m  )
s6
Yp

010

0
1
(m  , m  )2
1
s8
Yp

001

F

F

s

14
000
Ys
0
0
(m  , m  )2
3

F

F

000

s14
Yp
0
0
(m  , m  )2
1

(a) Abstracted QRModel to Infer QRSpec of Ys

(b) Abstracted QRModel to Infer QRSpec of Yp

Fig. 7. State Transition Diagram with State Labels as Composite Component-Mode Tuples for the Abstracted QRModel, Q′
and Q′max

ΥP , Inferred from Quality Conﬁgurations, QΥS and Qmax
ΥP

, respectively (Introduced in Examples 5-6)

ΥS

System
State
s1
ΥS
s2
ΥS
s3
ΥS
s6
ΥS
s8
ΥS
s14
ΥS

Component Mode
(Composite Tuple)
3, m1
2)
3, m0
2)
3, m1
2)
3, m0
2)
3, m1
2)
3, m0
2)

ΥS
ΥS
ΥS
ΥS
ΥS
ΥS
Table 7. Composite Operating Modes w.r.t. Q′

System
Mode
m1
m0
m2
m0
m0
m0

(m1
(m1
(m2
(m2
(m0
(m0

ΥS

Component Mode
(Composite Tuple)
1, m1
2)
1, m0
2)
1, m1
2)
1, m0
2)
1, m1
2)
1, m0
2)

ΥP
ΥP
ΥP
ΥP
ΥP
ΥP
Table 8. Composite Operating Modes w.r.t. Q′max

System
State
s1
ΥP
s2
ΥP
s3
ΥP
s6
ΥP
s8
ΥP
s14
ΥP

System
Mode
m3
m2
m5
m4
m1
m0

(m1
(m1
(m2
(m2
(m0
(m0

ΥP States

States

with Table 5). We ﬁnd that the outcomes of Step-3 and Step-4 (presented in Tables 8-9) are similar to what
has been (already) speciﬁed as reliability and input-output quality value-pairs in Table 2.

In order to complete the conformance checking of automatically inferred QRSpec, PΥS and PΥP , from
ΥP , respectively, the reader may cross-check Table 1 (from Example 3) with Tables 7-9
✷

QRModel, QΥS and Qmax
and Figure 7(a), as well as Table 2 (from Example 3) with Tables 8-9 and Figure 7(b).

It may be noted that, the above mentioned steps provide an generic inferencing procedure, aiding to the

System State Operating Mode
Name

ΥS

ΥP

ID
s1
ΥS
s2
ΥS
s3
ΥS
s6
ΥS
s8
ΥS
s14
ΥS
s1
ΥP
s2
ΥP
s3
ΥP
s6
ΥP
s8
ΥP
s14
ΥP

Conﬁguration
1X1
1X0
011
010
001
000
1X1
1X0
011
010
001
000

Input Quality
Values (Levels)
h50, 20i
h0i
h50, 20i
h0i
h0i
h0i
h50, 40, 30, 10i
h50, 30, 20i
h50, 40, 30, 10i
h50, 30, 20i
h40, 10i
h0i

Output Quality
Values (Levels)
h30, 10i
h0i
h30, 10i
h0i
h0i
h0i
h40, 30, 25, 10i
h40, 25, 10i
h35, 30, 25, 10i
h35, 25, 10i
h30, 10i
h0i

Operating Mode Probability
Algebraic Expression
r3,1.r2,1
r3,1.(1 − r2,1)
(1 − r3,1).23,2.r2,1
(1 − r3,1).r3,2.(1 − r2,1)
(1 − r3,1).(1 − r3,2).r2,1
(1 − r3,1).(1 − r3,2).(1 − r2,1)
r1,1.r2,1
r1,1.(1 − r2,1)
(1 − r1,1).23,2.r2,1
(1 − r1,1).r1,2.(1 − r2,1)
(1 − r1,1).(1 − r1,2).r2,1
(1 − r1,1).(1 − r1,2).(1 − r2,1)

Value
0.855
0.045
0.076
0.004
0.019
0.001
0.760
0.040
0.133
0.007
0.057
0.003

Table 9. Abstracted QRModel Conﬁguration Details, Q′

ΥS and Q′max

ΥP , obtained from QΥS and Qmax
ΥP

for ΥS and ΥP

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

21

automatic synthesis of QRSpec (PΥ) which may further be checked for conformance against the already laid
speciﬁcations to ensure the correctness of the built system in terms of its quality and reliability artifacts. Such
conformance checking may happen either through manual inspection, or through a systematic query-based
engine (which is able to provide more detailed information from underlying QRModel), by which designers
may explore the quality and reliability measures of a system under various operational setup of its constituent
components leading to comprehensive coverage. The following section presents this part in details.

6. Query Processing and Analysis over System-level QRModel

To explore the system completeness with respect to quality and reliability speciﬁcations, we ﬁrst develop a
language through which we can interact with the system-level QRModel in order to extract various relevant
parameters under diﬀerent operating conditions of the system. Such an exploration can be performed at
architectural-level and it helps the designer to determine the coverage of the system in terms of its best
and worst possible measures of quality and reliability attributes attainable with the given compositional
structure having the possibility of component failures and suspensions as part of the operating setups.

6.1. Structured Query Description Language (SQDL)

We propose a structured query description language, named as SQDL, to express various queries related to
a given component-based system structure. SQDL enjoys similar and simple syntactic sugar as that of SQL
(Structured Query Language). The detailed syntax for expressing each query-block is given below.

begin_query [ IDENTIFIER ]

select

[ - input_quality ]
[ - output_quality ]
[ - operating_mode ]
[ - reliability ]
[ - operate_prob ]
[ - failure ]
[ - suspend ]

from

- system SYSTEM_STRUCTURE_FILE
- qrspec COMPONENT_QRSPEC_FILE

where

VALUE_LIST ]

[ - input_quality
[ - output_quality [ - minimum VALUE_LIST ] [ - maximum VALUE_LIST ] ]
[ - reliability
[ - operate_prob
[ - failure
[ - suspend

[ - minimum VALUE ] [ - maximum VALUE ]
[ - minimum VALUE ] [ - maximum VALUE ]
[ - minimum NUMBER ] [ - maximum NUMBER ]
[ - minimum NUMBER ] [ - maximum NUMBER ]

]
]
]
]

end_query

It may be noted that, each three-part (select - from - where) query speciﬁcation is encapsulated
using “begin query ... end query” block and all small-letter phrases (that followed after a ‘–’) indicate
the reserved keywords for query speciﬁcation. The syntax, [...], indicates that those attributes are optional
in query speciﬁcation. Each query is given a name which is indicated by the IDENTIFIER. The input system
structure description and the component-level QRSPEC deﬁnitions are provided using SYSTEM STRUCTURE FILE
and COMPONENT QRSPEC FILE. Moreover, using the placeholders, VALUE, VALUE LIST and NUMBER, we indicate
a real number, a list of real values (within {...} separated by comma), and an integer, respectively.

Semantically, the architectural component-based system structure with the QRSpec deﬁnitions for each
component is chosen from the ﬁles mentioned in from block. The select block proposes to extract the
following information: (i) the coverage for input-output quality ranges supported by the system, (ii) the

22

Aritra Hazra

ranges for its reliability and operating probability, (iii) the supporting operational modes of the components,
(iv) the minimum and maximum failures or suspensions admissible by the system. These extraction are
subject to the constraints of the system as speciﬁed under where block having the options of constraining
for the following: (i) the prescribed quality values to be attained, (ii) the highest and lowest reliability and
operating probability allowed, (iii) the predicted choice of failures and suspensions required during operations.
The following example presents two queries and their representations in SQDL to bring out the essence.

Example 8. Let us ﬁrst specify (in English) the intent of two example queries over a system as follows:

Query1: What are the operating modes with their respective set of input-output quality levels (values) and
reliability values supported by the system, when we try to operate it maintaining the input quality levels
at least 30, with the system reliability guarantee be above 0.85 and allowing a maximum of 2 component
failures and without suspending any component?

Query2: How many component failures can be tolerated and in which operating modes (with their operating
probability) the system can operate in those cases, when we want to maintain the minimum output-quality
values as h30, 25, 10, 5i corresponding to the given input-quality levels h40, 30, 15, 5i, respectively, with the
system reliability guarantee be above 0.95 and a maximum of 1 component may be suspended?

We may express these queries using our proposed SQDL framework as:

begin_query Query1

select

- input_quality
- output_quality
- operating_mode
- reliability

from

- system file.sys
- qrspec spec.qr

where

- input_quality { 30 }
- reliability

- minimum 0.85

- failure

- maximum 2

- control

- maximum 0

end_query

begin_query Query2

select

- operating_mode
- operate_prob
- failure

from

- system file.sys
- qrspec spec.qr

where

- input_quality { 40,30,15,5 }
- output_quality

- minimum { 30,25,10,5 }

- reliability

- minimum 0.95

- suspend

- maximum 1

end_query

Note that, the system structure will be supplied as a directed acyclic graph (as deﬁned formally in
Section 2.1) through the formatted ﬁle, file.sys and the QRSpec for each component module (as deﬁned
✷
formally in Section 2.2) will be described through the formatted ﬁle, spec.qr.

Interestingly, this query platform can also be used to easily abstract any system behavior out of its QRModel.
So, in order to infer back the QRSpec (as discussed in Section 5), we may write a simple query only constraining
the maximum number of control to be 0 and hence retrieving all possible failure options of the system.

In the next subsection, we discuss how the query is processed to retrieve results from the system QRModel.

6.2. Query-driven System Behavior Assessment

The query-driven analysis framework helps the component-based system designer by providing a meaningful
coverage information related to the quality and reliability attributes of systems through extraction of a
range of admissible design conﬁgurations. Thereby, it also helps the designer to explore through multiple
system setups and ﬁnally converge into meaningful compositions of reliable and quality system design. The
processing and retrieval of quality measures by our proposed framework are done involving three basic steps.

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

23

Mode Conﬁguration
1X1
011
001

C1 = (m1
C1 = (m1
C1 = (m1

Component Operating Modes
1 : NA) C2 = (m1
1 : OP) C2 = (m1
1 : FL) C2 = (m1

1 : OP, m2
1 : FL, m2
1 : FL, m2

2 : OP)
2 : OP)
2 : OP)

Input Quality Levels Output Quality Values

h50, 40, 30i
h50, 40, 30i
h40i

h40, 30, 25i
h35, 30, 25i
h30i

Reliability
0.990
0.985
0.950

Table 10. Extracted Results over ΥP from Query1

(OP: Operating, FL: Failed, NA: Not-Availed)

Mode Conﬁguration
1X1
011
001
0Y1
Y11
Y01

C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1

Component Operating Modes
1 : NA) C2 = (m1
1 : OP) C2 = (m1
1 : FL) C2 = (m1
1 : SU) C2 = (m1
1 : OP) C2 = (m1
1 : FL) C2 = (m1

1 : OP, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : SU, m2
1 : SU, m2

2 : OP)
2 : OP)
2 : OP)
2 : OP)
2 : OP)
2 : OP)

Operating Probability # Failure

0.760
0.133
0.057
0.190
0.665
0.285

0
0
1*
0
0
0

Table 11. Extracted Results over ΥP from Query2
[* Maximum Number of Failures that can be Tolerated = 1 (though failure in C2 is not admissible!) ]

(OP: Operating, FL: Failed, SU: Suspended, NA: Not-Availed)

(i) Developing QRModel. From the system architecture description and the component QRSpec (as speciﬁed
in from part of the query), we follow the component characterization (as proposed in Section 3) and
generic composition procedures (proposed in Section 4) to build the system QRModel automatically.
(ii) Constraining QRModel. After parsing SQDL queries, we impose the restriction over the built QRModel

adhering to the constraints mentioned under the where block of a query.

(iii) Exploring QRModel. This is a simple search and data retrieval step from the underlying state-transition
system to gather relevant information from QRModel as asked in the select block of the query.

Let us elucidate the outcome of the above-mentioned three-step process by an example.

Example 9. We again revisit the parallel system, ΥP and seek for the answers of the two queries (Query1
and Query2) introduced in Example 8. Table 10 and Table 11 present the snapshots of the information
retrieved over the ΥP system.

Some interesting observations can be made for the system, ΥP , from Table 10. Though we asked for the
output quality for the input quality of at least 30 units, but the mode conﬁguration 001 (where C1 fails
completely in both modes) can only provide meaningful output with input level being at least 40 and the
output quality falls to 0 (zero), when input quality is set within [30, 40). Moreover, the system can maintain
a reliability of at least 0.9 (higher than given) in the given setup with at most 1 failure admissible. However,
the reliability can ranges upto [0.985 − 0.990] under the assumption of non-failing components.

Similarly, from the component operating modes listed in Table 11, it is evident that indicates that it is
never possible in ΥP to maintain the reliability threshold of 0.95 when the component C2 fails. It is also
shown that only a maximum of 1 failure is admissible to guarantee the query constraint here, but it must be
C1 in the worst case. Moreover, there are few possible provisions to suspend C1, if required without violating
the given Query2 constraints.

When the same queries are solved over the series system, ΥS, we ﬁnd that there is only one conﬁguration
(i.e. 1X1) admissible for Query1 with reliability of 0.855 and input-output quality of 50 → 30; but for Query2,
✷
there is none adhering to the setup constraints.

Though we provided a simple example system to illustrate the query-based assessment mechanism, but our
proposed framework is well-generalized to handle any complex systems structure that can be represented by
a directed acyclic graph, and with generic queries expressed using SQDL.

7. Case-Study

Let us revisit the example component-based system structure, Υsp that is introduced in the beginning of this
article (refer to Example 1 and Figure 2). We show the applicability of our proposed quality characterization
and query-based assessment framework in details over this system to establish that the method can be
applied in general to any composite structures.

For Υsp, the automatically derived formal QRModel has 147 states and 174 failure transitions as well as
174 suspend transitions. When we synthesize the formal QRSpec by abstracting the QRModel (keeping only

24

Aritra Hazra

1
1
(m  , m  , m  )
2
3

1
1

1
s
Ysp

1X11X

F

F

F

1
1
(m  , m  , m  )
2
3

2
1

2
s
Ysp

0111X

0
1
(m  , m  , m  )
2
3

1
1

3
s
Ysp

1X01X

F

F

F

F

F

1
1
(m  , m  , m  )
2
3

0
1

5
s
Ysp

0011X

F

F

0
1
(m  , m  , m  )
3
2

2
1

6
s
Ysp

F

0101X

F

2
1
(m  , m  , m  )
3
2

2
1

7
s
Ysp

F

01101

F

FF

2
1
(m  , m  , m  )
3
2

1
1

1X101

4
s
Ysp
F

F

F

2
0
(m  , m  , m  )
3
2

1
1

8
s
Ysp

F

1X001

F

(m  , m  , m  )0
1
2
3

1
1

9
s
Ysp

1X100

F

F

0
1
(m  , m  , m  )
2
3

0
1
10
Ysp

s

0001X

F

2
1
(m  , m  , m  )
3
2

0
1
11
Ysp

s

00101

2
0
(m  , m  , m  )
3
2

2
1
12
Ysp

s

01001

0
1
(m  , m  , m  )
3
2

2
1
13
Ysp

s

01100

F

F

F

F

F

F

F

1
1
14
Ysp

s

0
0
(m  , m  , m  )
3
2

1X000

2
0
(m  , m  , m  )
3
2

0
1
15
Ysp

s

00001

F

0
1
(m  , m  , m  )
3
2

0
1
16
Ysp

s

00100

F

F

0
0
(m  , m  , m  )
3
2

2
1
17
Ysp

s

01000

0
0
(m  , m  , m  )
3
2

0
1
18
Ysp

s

00000

Fig. 8. State Transition Diagram with State Labels as Composite Component-Mode Tuples for the Abstracted QRModel, Q′
,
Υsp
Inferred from Quality Conﬁgurations, QΥsp , which has a total of 147 states with 348 failure and suspend transitions (174 each)

State
ID

s1
Υsp
s2
Υsp
s3
Υsp
s4
Υsp
s5
Υsp
s6
Υsp
s7
Υsp
s8
Υsp
s9
Υsp
s10
Υsp
s11
Υsp
s12
Υsp
s13
Υsp
s14
Υsp
s15
Υsp
s16
Υsp
s17
Υsp
s18
Υsp

Operating
Mode Conﬁg.
1X11X
0111X
1X01X
1X101
0011X
0101X
01101
1X001
1X100
0001X
00101
01001
01100
1X000
00001
00100
01000
00000

Component Mode
(Composite Tuple)
1, m1
1, m1
1, m0
1, m1
1, m1
1, m0
1, m1
1, m0
1, m1
1, m0
1, m1
1, m0
1, m1
1, m0
1, m0
1, m1
1, m0
1, m0

2, m1
3)
2, m1
3)
2, m1
3)
2, m2
3)
2, m1
3)
2, m1
3)
2, m2
3)
2, m2
3)
2, m0
3)
2, m1
3)
2, m2
3)
2, m2
3)
2, m0
3)
2, m0
3)
2, m2
3)
2, m0
3)
2, m0
3)
2, m0
3)

(m1
(m2
(m1
(m1
(m0
(m2
(m2
(m1
(m1
(m0
(m0
(m2
(m2
(m1
(m0
(m0
(m2
(m0

Input Quality
Values (Levels)
h50, 40, 30, 10i
h50, 40, 30, 10i
h50, 30, 20i
h50, 40, 30, 10i
h40, 10i
h50, 30, 20i
h50, 40, 30, 10i
h50, 30, 20i
h50, 40, 30, 10i
h0i
h50, 20i
h50, 30, 20i
h50, 40, 30, 10i
h50, 30, 20i
h0i
h40, 10i
h50, 30, 20i
h0i

Output Quality
Values (Levels)
h40, 30, 25, 10i
h35, 30, 25, 10i
h40, 25, 10i
h40, 30, 25, 10i
h30, 10i
h35, 25, 10i
h35, 30, 25, 10i
h40, 25, 10i
h40, 30, 25, 10i
h0i
h30, 10i
h35, 25, 10i
h35, 30, 25, 10i
h40, 25, 10i
h0i
h30, 10i
h35, 25, 10i
h0i

Operating Mode Probability

Algebraic Expression
r1,1 .r2,1.r3,1
(1 − r1,1 ).r1,2 .r2,1.r3,1
r1,1.(1 − r2,1 ).r3,1
r1,1 .r2,1.(1 − r3,1 ).r3,2
(1 − r1,1).(1 − r1,2 ).r2,1 .r3,1
(1 − r1,1).r1,2 .(1 − r2,1 ).r3,1
(1 − r1,1 ).r1,2 .r2,1.(1 − r3,1 ).r3,2
r1,1.(1 − r2,1 ).(1 − r3,1 ).r3,2
r1,1.r2,1 .(1 − r3,1).(1 − r3,2)
(1 − r1,1).(1 − r1,2).(1 − r2,1).r3,1
(1 − r1,1).(1 − r1,2 ).r2,1 .(1 − r3,1 ).r3,2
(1 − r1,1).r1,2 .(1 − r2,1 ).(1 − r3,1 ).r3,2
(1 − r1,1).r1,2 .r2,1 .(1 − r3,1).(1 − r3,2)
r1,1 .(1 − r2,1 ).(1 − r3,1 ).(1 − r3,2 )
(1 − r1,1).(1 − r1,2).(1 − r2,1).(1 − r3,1).r3,2
(1 − r1,1).(1 − r1,2).r2,1 .(1 − r3,1 ).(1 − r3,2 )
(1 − r1,1).r1,2 .(1 − r2,1 ).(1 − r3,1 ).(1 − r3,2 )
(1 − r1,1 ).(1 − r1,2 ).(1 − r2,1 ).(1 − r3,1 ).(1 − r3,2)

Value
0.68400
0.11970
0.03600
0.06080
0.05130
0.00630
0.01064
0.00320
0.01520
0.00270
0.04560
0.00056
0.00266
0.00080
0.00024
0.00114
0.00014
0.00006

Table 12. Abstracted QRModel Conﬁguration Details, Q′

Υsp (presenting the QRSpec for Υsp), as obtained from QΥsp

failure transitions and the states reachable by failure transitions from the initial state in the underlying state-
transition system), we get the abstract state-transition system as shown in Figure 8 with its speciﬁcation
conﬁgurations given in Table 12. In this QRSpec model formed, we have 18 states (combined component
modes) and 33 transitions.

Table 13 and Table 14 present the results extracted if we execute the same two queries as proposed in
Example 8. For Query1, it may be found (from Table 13) that there is no meaningful (guaranteed) output
quality when input quality is in the range [30, 40) and we have complete failure of C1. However, the reliability

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

25

Mode
Conﬁg.
1X11X
0111X
0011X
01101
1X101
1X100

Component-level Operating Mode Combinations

C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1

1 : OP, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : OP, m2
1 : OP, m2

1 : NA) C2 = (m1
1 : OP) C2 = (m1
1 : FL) C2 = (m1
1 : OP) C2 = (m1
1 : NA) C2 = (m1
1 : NA) C2 = (m1

2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1

3 : OP, m2
3 : OP, m2
3 : OP, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2

3 : NA)
3 : NA)
3 : NA)
3 : OP)
3 : OP)
3 : FL)

Input Quality
Levels (Values)
h50, 40, 30i
h50, 40, 30i
h40i
h50, 40, 30i
h50, 40, 30i
h50, 40, 30i

Output Quality
Levels (Values)
h40, 30, 25i
h35, 30, 25i
h30i
h35, 30, 25i
h40, 30, 25i
h40, 30, 25i

Reliability
Value
0.990
0.985
0.950
0.985
0.990
0.990

Table 13. Extracted Results over Υsp from Query1

(OP: Operating, FL: Failed, NA: Not-Availed)

Mode
Conﬁg.
1X11X
0111X
0011X
00101
00100
0010Y
001Y1
001Y0
0Y11X
0Y101
0Y100
01101
01100
0110Y
011Y1
011Y0
Y111X
Y011X
Y0101
Y0100
Y1101
Y1100
1X101
1X100
1X10Y
1X1Y1
1X1Y0

Component-level Operating Mode Combinations

C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1
C1 = (m1

1 : OP, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : FL, m2
1 : SU, m2
1 : SU, m2
1 : SU, m2
1 : SU, m2
1 : SU, m2
1 : SU, m2
1 : OP, m2
1 : OP, m2
1 : OP, m2
1 : OP, m2
1 : OP, m2

1 : NA) C2 = (m1
1 : OP) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : SU) C2 = (m1
1 : SU) C2 = (m1
1 : SU) C2 = (m1
1 : OP) C2 = (m1
1 : OP) C2 = (m1
1 : OP) C2 = (m1
1 : OP) C2 = (m1
1 : OP) C2 = (m1
1 : OP) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : FL) C2 = (m1
1 : OP) C2 = (m1
1 : OP) C2 = (m1
1 : NA) C2 = (m1
1 : NA) C2 = (m1
1 : NA) C2 = (m1
1 : NA) C2 = (m1
1 : NA) C2 = (m1

2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1
2 : OP) C3 = (m1

3 : OP, m2
3 : OP, m2
3 : OP, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : SU, m2
3 : SU, m2
3 : OP, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : SU, m2
3 : SU, m2
3 : OP, m2
3 : OP, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : FL, m2
3 : SU, m2
3 : SU, m2

3 : NA)
3 : NA)
3 : NA)
3 : OP)
3 : FL)
3 : SU)
3 : OP)
3 : FL)
3 : NA)
3 : OP)
3 : FL)
3 : OP)
3 : FL)
3 : SU)
3 : OP)
3 : FL)
3 : NA)
3 : NA)
3 : OP)
3 : FL)
3 : OP)
3 : FL)
3 : OP)
3 : FL)
3 : SU)
3 : OP)
3 : FL)

Operating
Probability
0.68400
0.11970
0.05130
0.00456
0.00114
0.00570
0.04560
0.01140
0.17100
0.01520
0.00380
0.01064
0.00266
0.01330
0.10640
0.02660
0.59850
0.25650
0.02280
0.00570
0.05320
0.01330
0.06080
0.01520
0.07600
0.60800
0.15200

No. of
Failure
0
0
1
1
2*
1
1
1
0
0
1
0
1
0
0
0
0
0
0
1
0
1
0
1
0
0
0

Table 14. Extracted Results over Υsp from Query2
[* Maximum Number of Failures that can be Tolerated = 2 (though failure in C2 is not admissible!) ]

(OP: Operating, FL: Failed, SU: Suspended, NA: Not-Availed)

can ranges upto [0.985−0.999] under the no component failure assumption. Similarly, for Query2, it is evident
(from Table 14) that non-failure of C2 is must with respect to the given constraints (primarily keeping the
system reliability above 0.95) in the query. Additionally, there are still some provisions of suspending at
most one component yet satisfying the query requirements, even in case of failure in one of the components.
It may be further noted that, for Υsp, the reliability computation is primarily dictated by C1 and C2
components. This is because of the instantiation/invocation of same component, C2, present in two parallel
paths from input to output – which makes the system to only operate through C1 in case of failure/suspension
of C2 (since C2 failure closing the C3 − C2 path too). Therefore, the computed reliability value of the overall
1) + Z2(mj
Z1(mi
system always comes from the computation of,
, depending on the
(cid:2)
1 and mj
modes, mi
2 of C1 and C2 (0 ≤ i ≤ 2, 0 ≤ j ≤ 1), respectively, independent of the involvement
8. This is also the reason why C2 is critical to maintain high reliability for the
of reliability values from C3
operability of Υsp, as also evident from the outcomes of Query1 and Query2.

1).Z2(mj
2)
(cid:3)

2) − Z1(mi

8 The reliability of Υsp in every mode is computed as: (Here, 0 ≤ i, k ≤ 2 and 0 ≤ j ≤ 1)

ZΥsp (cid:0)mi

1, mj

2, mk

3 (cid:1) = 1 − (cid:2)1 − Z1(mi

1)(cid:3).(cid:2)1 − Z2(mj

2)(cid:3).(cid:2)1 − Z3(mk

3 ).Z2(mj

2)(cid:3) = (cid:2)Z1(mi

1) + Z2(mj

2) − Z1(mi

1).Z2(mj

2)(cid:3)

26

(a)

Ip

(b)

Ip

Aritra Hazra

C 1

C 2

C 1

C 2

C 3

C 3

C 5

C 4

C 5

C 4

C 6

(c)

Op

Ip

Op

C

1

C 2

C

3

C

4

(d)

Ip

C 1

C 2

C 3

C 4

Op

Op

(e)

C 5

Ip

C 1

C 2

C 3

C 4

Op

C 6

Fig. 9. Some General Composite System Structures Explored by our Framework

Exploration over Miscellaneous System Structures: We also explored our proposed approach over some general
system structures, ﬁve such composite system variations are shown in Figure 9. We also tried diﬀerent queries
on these variations and found that our framework helps in analyzing the non-functional quality requirements.
Moreover, each of the building block of these systems can also be a subsystem by itself and our framework
is capable of handling such compositions, which can be primarily derived in a hierarchical manner.

8. Conclusion

In this work, we propose a novel framework (Figure 1) to formally deﬁne and characterize the non-functional
speciﬁcations, such as quality and reliability, of a component-based system and analyze the same. From
the component-level quality conﬁgurations, we deduce system-level quality measures following a generic se-
ries and parallel composition techniques. We have further shown how to synthesize back the system-level
non-functional speciﬁcations from the derived quality models of the composite system. We ﬁnd interesting
ramiﬁcations of such an extraction of non-functional speciﬁcations from an architectural level, since it may
be used to assess the functional coverage that the quality measure achieves and it may also be correlated with
the design intent (if speciﬁed) to check for its conformance with the desired and laid speciﬁcations. We also
establish a query-driven analysis framework to extract relevant non-functional features of the overall system
in greater details leveraging the internally derived quality conﬁguration model. To the best of our knowl-
edge, this is the ﬁrst work that tries to provide a formal and automated analysis for compositional quality
requirements from an architectural level of system design. We believe that such an assessment framework
will be useful in formally certifying the non-functional requirements of component-based systems.

Additionally, the query-driven quality assessment counterpart equips the system designers presenting
them deeper insights while exploring through the possible component-level conﬁgurations and thereby the
designers may ﬁnd it easier to explore and converge into the best possible system structures. In case that the
desired system-level speciﬁcation is not met by the derived composite structure, such an assessment tool,
adding to our proposed compositional framework, will always help to understand the gap in terms of non-
admissible quality conﬁgurations and/or prohibitive operational setups from its constituent components. As
part of the future work, we shall explore the possibility to automatically bridge the gap by minimal addition
or alteration to the existing composite structure. Besides, this being the maiden work, we have considered
a rudimentary notion of quality which can be deﬁned generically (and simply) in terms of some levels (as
real values). In future, we plan to extend this deﬁnition of quality also as a function of component activity
and interactions by possibly modeling the same involving logical properties. We also plan to integrate our
proposed framework with industrial system design and validation ﬂow and devise suitable metrics for quality
and reliability coverage for comprehensive certiﬁcation of component-based systems from architectural level.

References

[1]

[2]

[3]

A. Basu, S. Bensalem, M. Bozga, P. Bourgos, and J. Sifakis. Rigorous System Design: The BIP Approach. In
Proceedings of Mathematical and Engineering Methods in Computer Science (MEMICS), pages 1–19, 2011.
A. Basu, S. Bensalem, M. Bozga, J. Combaz, M. Jaber, T.-H. Nguyen, and J. Sifakis. Rigorous Component-Based
System Design Using the BIP Framework. IEEE Software, 28(3):41–48, 2011.
S. Bliudze and J. Sifakis. A Notion of Glue Expressiveness for Component-Based Systems. In Proceedings of 19th
International Conference on Concurrency Theory (CONCUR), pages 508–522, 2008.

Formal Methods for Characterization and Analysis of Quality Speciﬁcations in Component-based Systems

27

[4]

[5]
[6]

[7]

[8]
[9]
[10]

[11]

[12]

[13]

[14]

[15]

[16]
[17]

[18]

[19]

[20]

[21]

[22]

[23]

[24]

[25]

[26]
[27]

[28]

[29]

[30]
[31]
[32]
[33]
[34]

[35]

[36]
[37]
[38]

In

In 1st International Symposium on

S. Bliudze and J. Sifakis. Causal Semantics for the Algebra of Connectors. Formal Methods in System Design,
36:179–199, December 2008.
C. Bock. SysML and UML 2 support for Activity Modeling. Systems Engineering, 9(2):160–186, 2006.
P. Bourgos, A. Basu, M. Bozga, S. Bensalem, J. Sifakis, and K. Huang. Rigorous System Level Modeling and
Analysis of Mixed HW/SW Systems.
In Proceeding of 9th ACM/IEEE International Conference on Formal
Methods and Models for Codesign (MEMOCODE), pages 11–20, 2011.
X. Cai, M. Lyu, K.-F. Wong, and R. Ko. Component-based software engineering: Technologies, development
frameworks, and quality assurance schemes.
In 7th Asia-Paciﬁc Software Engineering Conference (APSEC),
pages 372–379, February 2000.
E. M. Clarke, O. Grumberg, D. Kroening, D. Peled, and H. Veith. Model Checking. MIT Press, December 2018.
E. M. Clarke, T. A. Henzinger, H. Veith, and R. Bloem. Handbook of Model Checking. Springer, 2018.
M. R. Clarkson and F. B. Schneider. Hyperproperties. Journal of Computer Security, 18(6):1157–1210, September
2010.
J. Combaz, J.-C. Fernandez, T. Lepley, and J. Sifakis. QoS Control for Optimality and Safety. In Proceedings of
5th ACM International Conference on Embedded Software, page 90–99, 2005.
J. Combaz, J.-C. Fernandez, J. Sifakis, and L. Strus. Symbolic Quality Control for Multimedia Applications. In
International Journal of Real-Time Systems (RTS), Springer, 40(1):1–43, October 2008.
A. Ferrari and A. L. Sangiovanni-Vincentelli. System Design: Traditional Concepts and New Paradigms.
Proceedings of IEEE International Conference on Computer Design (ICCD, pages 2–12, 1999.
S. K. Ghosh, A. Hazra, and S. Dey. RELSPEC: A Framework for Early Reliability Reﬁnement of Embedded
Applications. In 28th International Conference on VLSI Design (VLSID), pages 41–46, 2015.
G. Goessler and J. Sifakis. Composition for Component-Based Modeling.
Formal Methods for Components and Objects (FMCO), pages 443–466, January 2002.
T. Groetker, S. Liao, G. Martin, and S. Swan. System Design with SystemC. Springer, 2002.
D. Harel. Statecharts: a Visual Formalism for Complex Systems. Science of Computer Programming, 8(3):231–274,
1987.
D. Hatebur, M. Heisel, and H. Schmidt. Analysis and Component-based Realization of Security Requirements. In
3rd International Conference on Availability, Reliability and Security, pages 195–203, 2008.
A. Hazra, P. Dasgupta, and P. P. Chakrabarti. Formal Assessment of Reliability Speciﬁcations in Embedded
Cyber-Physical Systems. Journal of Applied Logic, 18:71–104, November 2016.
A. Hazra, P. Ghosh, S. G. Vadlamudi, P. P. Chakrabarti, and P. Dasgupta. Formal Methods for Early Analysis of
Functional Reliability in Component-Based Embedded Applications. IEEE Embedded Systems Letters, 5(1):8–11,
March 2013.
A. Hazra, S. Goyal, P. Dasgupta, and A. Pal. Formal Veriﬁcation of Architectural Power Intent. IEEE Transactions
on Very Large Scale Integration (VLSI) Systems, 21(1):78–91, January 2013.
A. Hazra, R. Mukherjee, P. Dasgupta, A. Pal, K. M. Harer, A. Banerjee, and S. Mukherjee. POWER-TRUCTOR:
An Integrated Tool Flow for Formal Veriﬁcation and Coverage of Architectural Power Intent. IEEE Transactions
on Computer-Aided Design of Integrated Circuits and Systems, 32(11):1801–1813, November 2013.
Andreas Johnsen. Quality Assurance for Dependable Embedded Systems. PhD Dissertation, Maelardalen University,
Sweden, 2018.
Keerthi K., I. Roy, A. Hazra, and C. Rebeiro. Formal Veriﬁcation for Security in IoT Devices. In R. S. Chakraborty,
J. Mathew, and A. V. Vasilakos, editors, Security and Fault Tolerance in Internet of Things, pages 179–200.
Springer International Publishing, 2019.
G. Karsai, J. Sztipanovits, A. Ledeczi, and T. Bapty. Model-Integrated Development of Embedded Software.
Proceedings of IEEE, 91(1):145–164, January 2003.
I. Koren and C. M. Krishna. Fault-Tolerant Systems. Morgan Kaufmann, 2007.
E. A. Lee and A. L. Sangiovanni-Vincentelli. Component-based design for the Future. In Proceedings of Design,
Automation and Test in Europe (DATE), pages 1–5, 2011.
W. Li, F. Le Gall, P. Vlacheas, and A. Cheptsov. Quality assurance for component-based systems in embed-
ded environments. In International Conference on Internet of Things, Embedded Systems and Communications
(IINTEC), pages 171–176, 12 2018.
A. Paul, E. Baranov, S. Bliudze, M. Jaber, and J. Sifakis. A General Framework for Architecture Composability.
Formal Aspects of Computing, 28:1–25, December 2015.
A. Roychoudhury. Embedded Systems and Software Validation. Morgan Kaufmann, 2009.
A. L. Sangiovanni-Vincentelli and R. Passerone. Platform-Based Design. Springer, 2022.
C. Seceleanu and I. Crnkovic. Component Models for Reasoning. IEEE Computer, 46(11):40–47, 2013.
B. Selic. The Pragmatics of Model-driven Development. IEEE Software, 20(5):19–25, 2003.
J. Sifakis. Rigorous System Design. Foundations and Trends in Electronic Design Automation, 6(4):293–362, July
2012.
J. Sifakis, S. Bensalem, S. Bliudze, and M. Bozga. A Theory Agenda for Component-Based Design. In R. De
Nicola and R. Hennicker, editors, Software, Services, and Systems, pages 409–439. Oxford University Press, 2015.
J. Sztipanovits and G. Karsai. Model-Integrated Computing. IEEE Computer, 30(4):110–111, 1997.
M. Utting and B. Legeard. Practical Model-Based Testing: A Tools Approach. Morgan-Kaufmann, 2007.
J. Zander, I. Schieferdecker, and P. Mosterman. Model-Based Testing for Embedded Systems. CRC Press, September
2011.

