2
2
0
2

p
e
S
6
2

]
E
S
.
s
c
[

2
v
2
5
0
4
0
.
9
0
2
2
:
v
i
X
r
a

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Nick Feng
fengnick@cs.toronto.edu
University of Toronto
Toronto, Ontario, Canada

Mehrdad Sabetzadeh
mehrdad@cs.uottawa.ca
University of Ottawa
Ottawa, Ontario, Canada

Lina Marsso
lina.marsso@utoronto.ca
University of Toronto
Toronto, Ontario, Canada

Marsha Chechik
chechik@cs.toronto.edu
University of Toronto
Toronto, Ontario, Canada

ABSTRACT
Legal properties involve reasoning about data values and time. Met-
ric first-order temporal logic (MFOTL) provides a rich formalism
for specifying legal properties. While MFOTL has been successfully
used for verifying legal properties over operational systems via run-
time monitoring, no solution exists for MFOTL-based verification in
early-stage system development captured by requirements. Given a
legal property and system requirements both formalized in MFOTL,
the compliance of the property can be verified on the requirements
via satisfiability checking. In this paper, we propose a practical,
sound, and complete (within a given bound) satisfiability checking
approach for MFOTL. The approach, based on satisfiability mod-
ulo theories (SMT), employs a counterexample-guided strategy to
incrementally search for a satisfying solution. We implemented
our approach in a tool called LEGOS, and evaluated it on five case
studies spanning the healthcare, business administration, banking
and aviation domains. Our results indicate that our approach can
efficiently determine whether legal properties of interest are met,
or generate counterexamples that lead to compliance violations.

KEYWORDS
Requirements Engineering, Metric First-order Temporal Logic (MFOTL),
Satisfiability Modulo Theories (SMT).

1 INTRODUCTION
Software systems, such as medical systems or banking systems,
are increasingly required to comply with laws, regulations and
policies aimed at ensuring safety, security, data protection and
privacy [22, 38]. The properties stipulated by these laws, regulations
and policies – which we refer to as legal properties (LP) hereafter –
typically involve reasoning about actions, ordering and time. As an
example, consider the following LP, 𝑃1, derived from a health-data
regulation (s. 11, PHIPA [24]): "If personal health information is
not accurate or not up-to-date, it should not be accessed". In this
property, the accuracy and the freshness of the data depend on how
and when the data was collected and updated before being accessed.
More precisely, this property constrains the data action access to
have accurate and up-to-date data values, which further constrains
the order and time of access with respect to other data actions.

System compliance with LPs can be checked on the system de-
sign or on an operational model of a system implementation. In this

paper, we focus on the early stage, where one can check whether
a formalization of the system requirements satisfies an LP. The
formalization can be done using a descriptive formalism like tem-
poral logic, instead of using an operational one, based on transition
systems [28, 37]. For instance, the requirement (req0) of a data
collection system: "no data can be accessed prior to 15 days after
the data has been collected" needs to be formalized for verifying
compliance of 𝑃1. It is important to formalize the data and time
constraints of both the system requirements and LPs, such as the
ones of 𝑃1 and req0.

Metric first-order temporal logic (MFOTL) enables the specifica-
tion of data and time constraints [4] and has an expressive formal-
ism for capturing LPs and the related system requirements that
constrain data and time [1]. Existing work on MFOTL verification
has focused primarily on detecting violations at run-time through
monitoring [1], with MFOTL formulas being checked on execution
logs. There is an unsatisfied need on determining the satisfiability
of MFOTL specifications, i.e., looking for legal-property violations
possible in MFOTL specification, which is important for designing
and debugging MFOTL requirements to satisfy legal properties.

MFOTL satisfiability checking is generally undecidable since
MFOTL is an extension of first-order logic (FOL). Restrictions are
thus necessary for making the problem decidable. In this paper,
we restrict ourselves to safety properties. While we are not aware
of non-safety LP properties, it is conceivable that they may exist.
For safety properties, LP violations are finite sequences of data
actions, captured via a finite-length counterexample. For example,
a possible violation of 𝑃1 is a sequence consisting of storing a value
𝑣 in a variable 𝑑, updating 𝑑’s value to 𝑣 ′, then reading 𝑑 again and
not obtaining 𝑣 ′. Since we are interested in finite counterexamples,
bounded verification is a natural strategy to pursue for achieving
decidability. SAT solvers have been previously used for bounded
satisfiability checking of metric temporal logic (MTL) [28, 37]. How-
ever, MTL cannot effectively capture quantified data constraints
(e.g., "Every used data must be up-to-date.") in LPs, hence the so-
lution is not applicable directly. As an extension to MTL, MFOTL
can effectively capture data constraints used in LP. Yet, to the best
of our knowledge, there has not been any prior work on bounded
MFOTL satisfiability checking.

To establish a bound in bounded verification, researchers pre-
dominantly relied on bounding the size of the universe, e.g., every

 
 
 
 
 
 
Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

data type has a bounded domain in Alloy [23]. In our work, bound-
ing the universe would be too restrictive because LPs routinely refer
to variables with large ranges, e.g., timed actions spanning several
years. Instead, we bound the number of data actions in a run, which
bounds the number of actions in the counterexample.

Equipped with the proposed notion of a bound, we develop an
incremental approach (IBSC) for bounded satisfiability checking of
MFOTL. We first translate the MFOTL property and requirements
into FOL formulas with quantifiers over data actions. We then in-
crementally ground the FOL constraints to eliminate the quantifiers
by considering an increasing number of data actions. Subsequently,
we check the satisfiability of the resulting constraints using SMT
solver Z3 [10]. Specifically, we make the following contributions:
(1) we propose a translation of MFOTL formulas to FOL; (2) we
provide a novel bounded satisfiability checking solution for the
translated FOL formulas with incremental and counter-example
guided over/ under-approximation. We implemented our approach
IBSC in a tool called LEGOS, and empirically evaluate it on five case
studies with a total of 24 properties showing that it can effectively
and efficiently find LP violations or prove satisfiability.

The rest of this paper is organized as follows. Sec. 2 provides
background and establishes our notation. Sec. 3 defines the bounded
satisfiability checking (BSC) problem. Sec. 4 provides an overview
of our solution and the translation of MFOTL to FOL. Sec. 5 presents
our solution, the algorithm and its proof of correctness and termi-
nation. Sec. 6 reports on the experiments we have performed to
validate our bounded satisfiability checking solution for MFOTL .
Sec. 7 discusses related work. Sec. 8 concludes the paper.

2 PRELIMINARIES
In this section, we introduce the necessary background on metric
first order temporal logic (MFOTL).

Syntax. We begin with the syntax of MFOTL [4].

Definition 1. Let I be a non-empty interval over N. An interval
𝐼 ∈ I can be expressed as [b, b’) where 𝑏 ∈ N and 𝑏 ′ ∈ N ∪ ∞. A
signature 𝑆 is a tuple (𝐶, 𝑅, 𝜄), where 𝐶 is a set of constant and 𝑅 is a
finite set predicate symbols, respectively. Without loss of generality, we
assume all constants are from the integer domain I where the theory
of linear integer arithmetic (LIA) holds. The function 𝜄 : 𝑅 → N
associates each predicate symbol 𝑟 ∈ 𝑅 with an arity 𝜄 (𝑟 ) ∈ N. Let 𝑉
be a countable infinite set of variables from domain I and a term 𝑡 is
defined inductively as 𝑡 : 𝑐 | 𝑣 | 𝑡 + 𝑡 | 𝑐 × 𝑡. We denote ¯𝑡 as a vector of
terms and ¯𝑡 𝑘
𝑥 as the vector that contains 𝑥 at index 𝑘. The syntax of
MFOTL formulas is defined as follows:

(1) ⊤ and ⊥, representing values “true” and “false”;
(2) 𝑡 = 𝑡 ′ and 𝑡 > 𝑡 ′, for term 𝑡 and 𝑡 ′
(3) 𝑟 (𝑡1...𝑡𝜄𝑟 ) for 𝑟 ∈ 𝑅 and 𝑡1...𝑡𝜄 are terms.
(4) 𝜙 ∧ 𝜓 , ¬𝜙 for MFOTL formulas 𝜙 and 𝜓 ;
(5) ∃𝑥 · (𝑟 (¯𝑡 𝑘

𝑥 ) ∧ 𝜙) for MFOTL formula 𝜙, relation symbol 𝑟 ∈ 𝑅,

variable 𝑥 ∈ 𝑉 and a vector of terms ¯𝑡𝑖
𝐼 𝜙,

(6) 𝜙 U𝐼 𝜓 , 𝜙 S𝐼 𝜓 ,
an interval 𝐼 ∈ I.
(cid:32)

(cid:35)

𝑥 such that 𝑥 = ¯𝑡𝑖

𝑥 [𝑖]

𝐼 𝜙 for MFOTL formulas 𝜙 and 𝜓 , and

𝐼 and

The temporal operators U𝐼 , S𝐼 ,

¯𝑡, 𝑟 (¯𝑡) holds and 𝑥 appears in ¯𝑡). Similarly, universal quantifica-
tion must be guarded as ∀𝑥 · (𝑟 (¯𝑡) ⇒ 𝜙) where 𝑥 ∈ ¯𝑡. Under the
restricted quantification, ∃𝑥 · ¬𝑟 (𝑥) (and ∀𝑥 · 𝑟 (𝑥)) are not allowed.
𝐼 require the satisfac-
tion of the formula within the time interval given by 𝐼 . We write
[𝑏, ) as a shorthand for [𝑏, ∞), if 𝐼 is omitted, then the interval is
assumed to be [0, ∞). Other classical unary temporal operators
♢𝐼 (i.e., eventually), □𝐼 (i.e., always), and ♦𝐼 (i.e., once) are defined
as follows: ♢𝐼 𝜙 = ⊤ U𝐼 𝜙, □𝐼 𝜙 = ¬♢𝐼 ¬𝜙, and ♦𝐼 𝜙 = ⊤ S𝐼 𝜙.
Other common logical operator such as ∨ (disjunction) and ∀ (uni-
versal quantification) are expressed through negation of ∧ and ∃,
respectively.

(cid:32)

(cid:35)

Example 1. Suppose a data collection centre (DCC) collects and
accesses personal data information with three requirements: 𝑟𝑒𝑞0
stating that no data is allowed to be accessed before being having
been collected for 15 days (360 hours); 𝑟𝑒𝑞1: data can only be up-
dated after having been collected or last updated for more than a
week (168 hours); and 𝑟𝑒𝑞2: data can only be accessed if has been
collected or updated within a week (168 hours). The signature 𝑆𝑑𝑎𝑡𝑎
for DCC contains three binary relations (𝑅𝑑𝑎𝑡𝑎): Collect, Update,
and Access, such that Collect(𝑑, 𝑣), Update(𝑑, 𝑣) and Access(𝑑, 𝑣)
hold at a given time point if and only if data at id 𝑑 is collected,
updated, and accessed with value 𝑣 at this time point, respectively.
The MFOTL formulas for 𝑃1, 𝑟𝑒𝑞0, 𝑟𝑒𝑞1 and 𝑟𝑒𝑞2 are shown in
Fig. 1. For instance, the formula 𝑟𝑒𝑞0 specifies that if a data value
stored at id 𝑑 is accessed, then some data must have been collected
and stored at id 𝑑 before, and the collection must have occurred
prior to 360 hours ago (♦[360,) ]).

Semantics. A first-order (FO) structure 𝐷 over the signature 𝑆 =
(𝐶, 𝑅, 𝜄) comprises a domain |𝐷 | ≠ ∅ and an interpretation for
𝑐𝐷 ∈ |𝐷 | and 𝑟 𝐷 ⊆ |𝐷 |𝜄 (𝑟 ) for each 𝑐 ∈ 𝐶 and 𝑟 ∈ 𝑅. The semantics
of MFOTL formulas is defined over a sequence of FO structures
¯𝐷 = (𝐷0, 𝐷1, . . .) and a sequence of natural numbers representing
time ¯𝜏 = (𝜏0, 𝜏1, . . .), where (a) ¯𝜏 is a monotonically increasing
sequence; (b) |𝐷𝑖 | = |𝐷𝑖+1| for all 𝑖 > 0 (all 𝐷𝑖 have a fixed domain);
and (c) each constant symbol 𝑐 ∈ 𝐶 has the same interpretation
across ¯𝐷 (i.e., 𝑐𝐷𝑖 = 𝑐𝐷𝑖+1 )

Property (a) ensures that time never decreases as the sequence
progresses; and (b) ensures that the domain is fixed. ¯𝐷 is similar to
timed words in metric time logic (MTL), but instead of associating a
set of propositions to each time point, MFOTL uses a structure 𝐷 to
interpret the symbols in the signature 𝑆. Intuitively, the semantics
of MFOTL is defined over a trace of timed first-order structures
𝜎 = ( ¯𝐷, ¯𝜏), where every structure 𝐷𝑖 ∈ ¯𝐷 contains a set of holding
relations 𝑟 𝐷𝑖 , and these relations occur at a time specified by 𝜏𝑖 ∈ ¯𝜏.
Example 2. Consider the signature 𝑆𝑑𝑎𝑡𝑎 in the DCC example. Let
𝜏1 = 0 and 𝜏2 = 361, and let 𝐷1 and 𝐷2 be two first order structures
with 𝑟 𝐷1 = Collect(0, 0) and 𝑟 𝐷2 = Access(0, 0), respectively. The
trace 𝜎1 = ([𝐷1; 𝐷2], [𝜏1; 𝜏2]) is a valid trace shown in Fig. 2 and
representing two timed relations: (1) data value 0 collected and
stored at id 0 at hour 0 and (2) data value 0 is read by accessing id 0
at hour 361.

We considered a restricted form of quantification (syntax rule 5)
similar to guarded quantification [20, 21]. Every existentially quan-
tified variable 𝑥 must be guarded by some relation 𝑟 (i.e., for some

A valuation function 𝑣 : 𝑉 → | ¯𝐷 | maps a set of variables 𝑉 to
their interpretations in the domain | ¯𝐷 |. For vectors ¯𝑥 = (𝑥1, . . . , 𝑥𝑛)
and ¯𝑑 = (𝑑1, ..., 𝑑𝑛) ∈ | ¯𝐷 |𝑛, the update operation 𝑣 [¯𝑥 → ¯𝑑] produces

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Report, September 8th, 2022,

𝑃1 = □ ∀𝑑, 𝑣, 𝑣 ′(Access(𝑑, 𝑣)∧ 𝑣 ′ ≠ 𝑣) =⇒ ¬Update(𝑑, 𝑣 ′) S (Update(𝑑, 𝑣) ∨ Collect(𝑑, 𝑣)))
If a personal health information is not accurate or not up-to-date, it should not be accessed.
¬𝑃1 = ♢ ∃𝑑, 𝑣, 𝑣 ′(Access(𝑑, 𝑣) =⇒ (𝑣 ′ ≠ 𝑣 ∧ ¬Update(𝑑, 𝑣) S (Update(𝑑, 𝑣 ′) ∨ Collect(𝑑, 𝑣 ′))))
𝑟𝑒𝑞0 = □ ∀𝑑, 𝑣 (Access(𝑑, 𝑣) =⇒ ♦[360,) ∃𝑣 ′ · Collect(d, v’))
No data is allowed to be accessed before having been collected for at least 15 days (360 hours).
𝑟𝑒𝑞1 = □ ∀𝑑, 𝑣 (Update(𝑑, 𝑣) =⇒ ¬(∃𝑣 ′′ · ((Update(𝑑, 𝑣 ′′) ∧ 𝑣 ′′ ≠ 𝑣) ∨ Collect(d, v”)) ∨ ♦[1,168] ∃𝑣 ′ · (Collect(𝑑, 𝑣 ′) ∨ Update(𝑑, 𝑣 ′))))
Data can only be updated after having been collected or last updated for more than a week (168 hours).
𝑟𝑒𝑞2 = □ ∀𝑑, 𝑣 (Access(𝑑, 𝑣) =⇒ ♦[0,168] Collect(𝑑, 𝑣) ∨ Update(𝑑, 𝑣))
Data can only be accessed if has been collected or updated within a week (168 hours).
𝑟𝑒𝑞3 = □ ∀𝑑, 𝑣 (Collect(𝑑, 𝑣) =⇒ ¬(∃𝑣 ′′ · (Collect(𝑑, 𝑣 ′′) ∧ 𝑣 ≠ 𝑣 ′′) ∨ ♦[1,) ∃𝑣 ′ · Collect(𝑑, 𝑣 ′))) Data cannot be re-collected.

Figure 1: Several requirements and the legal property 𝑃 1 of DCC, with the signature 𝑆𝑑𝑎𝑡𝑎 = ( ∅, {Collect, Update, Access}, 𝜄𝑑𝑎𝑡𝑎), where
𝜄𝑑𝑎𝑡𝑎 (Collect) = 𝜄𝑑𝑎𝑡𝑎 (Update) = 𝜄𝑑𝑎𝑡𝑎 (Access) = 2.

𝐶𝑜𝑙𝑙𝑒𝑐𝑡 (0, 0)
𝜎1

𝜏0 = 0
𝐶𝑜𝑙𝑙𝑒𝑐𝑡 (1, 0)
𝜎2

𝜏0 = 0
𝑈 𝑝𝑑𝑎𝑡𝑒1 (0, 0)
𝜎3

𝜏0 = 0
𝐶𝑜𝑙𝑙𝑒𝑐𝑡2 (0, 1),
𝑈 𝑝𝑑𝑎𝑡𝑒1 (0, 0)
𝜎4

𝜏0 = 0
𝐶𝑜𝑙𝑙𝑒𝑐𝑡2 (0, 1)
𝜎5

data actions
time

𝐴𝑐𝑐𝑒𝑠𝑠 (1, 0)

𝜏2 = 361

𝐴𝑐𝑐𝑒𝑠𝑠 (0, 0)

𝜏1 = 361
𝐶𝑜𝑙𝑙𝑒𝑐𝑡 (1, 15)

𝜏1 = 20
𝐴𝑐𝑐𝑒𝑠𝑠1 (0, 1)

𝜏1 = 1

𝐴𝑐𝑐𝑒𝑠𝑠1 (0, 1)

𝜏1 = 2

𝐶𝑜𝑙𝑙𝑒𝑐𝑡1 (0, 0) 𝐴𝑐𝑐𝑒𝑠𝑠1 (0, 1)

𝜏0 = 0
Figure 2: Several traces from the DCC example.

𝜏1 = 1

𝜏2 = 2

a new valuation function 𝑣 ′ s.t. 𝑣 ′(𝑥𝑖 ) = 𝑑𝑖 for 1 ≤ 𝑖 ≤ 𝑛, and
𝑣 (𝑥 ′) = 𝑣 ′(𝑥 ′) for every 𝑥 ′ ∉ ¯𝑥. For any constant 𝑐, 𝑣 (𝑐) = 𝑐.

Definition 2. Let ¯𝐷 be a sequence of FO structures over signature
𝑆 = (𝐶, 𝑅, 𝜄) and ¯𝜏 be a sequence of natural numbers. Let 𝜙 be an
MFOTL formula over 𝑆, 𝑣 be a valuation function and 𝑖 ∈ N. The
relation ( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝜙 is defined as follows:

𝑥 ) ∧ 𝜙)

( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝑡 = 𝑡 ′
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝑡 > 𝑡 ′
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝑟 (𝑡1, .., 𝑡𝑖 (𝑟 ) )
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= ¬𝜙
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝜙 ∧ 𝜓
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= ∃𝑥 · (𝑟 (¯𝑡𝑖
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |=
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |=
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝜙 U𝐼 𝜓

iff 𝑣 (𝑡) = 𝑣 (𝑡 ′)
iff 𝑣 (𝑡) > 𝑣 (𝑡 ′)
iff 𝑟 (𝑣 (𝑡1), .., 𝑣 (𝑡𝑖 (𝑟 )) ) ∈ 𝑟 𝐷𝑖
iff ( ¯𝐷, ¯𝜏, 𝑣, 𝑖) ̸|= 𝜙
iff ( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝜙 and ( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝜓
iff ( ¯𝐷, ¯𝜏, 𝑣 [𝑥 → 𝑑], 𝑖) |= (𝑟 (¯𝑡𝑖
iff ( ¯𝐷, ¯𝜏, 𝑣, 𝑖 + 1) |= 𝜙 and 𝜏𝑖+1 − 𝜏𝑖 ∈ 𝐼
iff 𝑖 ≥ 1 and ( ¯𝐷, ¯𝜏, 𝑣, 𝑖 − 1) |= 𝜙 and 𝜏𝑖 − 𝜏𝑖−1 ∈ 𝐼
iff exists 𝑗 ≥ 𝑖 and ( ¯𝐷, ¯𝜏, 𝑗, 𝑣) |= 𝜓 and 𝜏 𝑗 − 𝜏𝑖 ∈ 𝐼
and for all 𝑘 ∈ N 𝑖 ≤ 𝑘 < 𝑗 ⇒ ( ¯𝐷, ¯𝜏, 𝑘, 𝑣) |= 𝜙
iff exists 𝑗 ≤ 𝑖 and ( ¯𝐷, ¯𝜏, 𝑗, 𝑣) |= 𝜓 and 𝜏𝑖 − 𝜏 𝑗 ∈ 𝐼
and for all 𝑘 ∈ N 𝑖 ≥ 𝑘 > 𝑗 ⇒ ( ¯𝐷, ¯𝜏, 𝑘, 𝑣) |= 𝜙
𝐼 , U𝐼 and S𝐼 are augmented with an interval
𝐼 ∈ I which defines the satisfaction of the formula within a time
range specified by 𝐼 relative to the current time at step 𝑖, i.e., 𝜏𝑖 .

( ¯𝐷, ¯𝜏, 𝑣, 𝑖) |= 𝜙 S𝐼 𝜓

The operators

𝐼 𝜙
𝐼 𝜙

(cid:32)
(cid:35)

(cid:32)

(cid:35)

𝐼 ,

𝑥 )) ∧ 𝜙 for some 𝑑 ∈ | ¯𝐷 |

Example 3. Consider the DCC example, the MFOTL formula 𝑟𝑒𝑞0,
and the trace 𝜎1 = (( ¯𝐷 = [𝐷1; 𝐷2]), (¯𝜏 = [𝜏1; 𝜏2])) (in Fig. 2). For
a valuation function 𝑣 = ∅, we have ( ¯𝐷, ¯𝜏, 𝑣, 0) |= 𝑟𝑒𝑞0 because data
stored at id 0 is accessed at hour 361 (Access(0, 0) ∈ 𝑟 𝐷2 ∧𝜏2 = 361),
and data value 0 was collected and stored at id 0 361 hours ago
(Collect(0, 0) ∈ 𝑟 𝐷1 and 𝜏2 − 𝜏1 ∈ [360, )).
Definition 3 (MFOTL Satisfiability). An MFOTL formula 𝜙 is
satisfiable if there exists a sequence of FO structures ¯𝐷 and natural

numbers ¯𝜏, and a valuation function 𝑣 such that ( ¯𝐷, ¯𝜏, 𝑣, 0) |= 𝜙. 𝜙 is
unsatisfiable otherwise.

In the DCC example, the MFOTL formula 𝑟𝑒𝑞0 is
Example 4.
satisfiable because ( ¯𝐷, ¯𝜏, 𝑣, 0) |= 𝑟𝑒𝑞0 (where 𝜎1 = ( ¯𝐷, ¯𝜏) in Fig. 2).
Let 𝑟𝑒𝑞′
0 = ♢[0,359] ∃𝑣 · (Access(0, 𝑣)) be another MFOTL formula.
𝑟𝑒𝑞′
0 ∧ 𝑟𝑒𝑞0 is unsatisfiable because if data stored at id 0 is accessed
between 0 and 359 hours, then it is impossible to collect the data at
least 360 hours prior to its access.

3 BOUNDED SATISFIABILITY CHECKING
The satisfiability of MFOTL properties is generally undecidable
since MFOTL is expressive enough for describing the blank tape
problem [33] (which has been shown to be undecidable). Despite the
undecidability result, we can derive a bounded version of the prob-
lem, bounded satisfiability checking (BSC), for which a sound and
complete decision procedure exists. When facing a hard instance
for the satisfiability checking problem, the solution to BSC provides
bounded guarantees (i.e., exists a solution or there is no solution
within the given bound). In this section, we first define satisfiability
checking and then the BSC problems of MFOTL formulas.

Satisfiability checking [34] is a verification technique that extends
model checking by replacing a state transition system with a set of
temporal logic formulas. In the following, we define satisfiability
checking of MFOTL formulas.

Definition 4 (Satisfiability Checking of MFOTL Formulas).
Let 𝜙 be an MFOTL formula over a signature 𝑆 = (𝐶, 𝑅, 𝜄), and let
𝑟𝑒𝑞𝑠 be a set of MFOTL requirements over 𝑆. Reqs complies 𝜙 (denoted
as Reqs ⇒ 𝜙) iff (cid:211)𝜓 ∈𝑀 𝜓 ∧ ¬𝜙 is unsatisfiable. We call a solution
to (cid:211)𝜓 ∈𝑀 𝜓 ∧ ¬𝜙 (if one exists) a counterexample to Reqs ⇒ 𝜙.
Example 5. Consider our DCC system requirements and the
privacy data property 𝑃1 stating that if personal health informa-
tion is not accurate or not up-to-date, it should not be accessed
(see Fig. 1). 𝑃1 is not respected by the set of DCC requirements
{𝑟𝑒𝑞0, 𝑟𝑒𝑞1, 𝑟𝑒𝑞2} because ¬𝑃1 ∧ 𝑟𝑒𝑞0 ∧ 𝑟𝑒𝑞1 ∧ 𝑟𝑒𝑞2 is satisfiable.
The counterexample 𝜎2 (shown in Fig. 2) indicates that data can be
re-collected, and the re-collection does not have the same time re-
striction as the updates. If a fourth policy requirement 𝑟𝑒𝑞3 (Fig. 1)
is added to prohibit re-collection of collected data, then property
𝑃1 would be respected ({𝑟𝑒𝑞0, 𝑟𝑒𝑞1, 𝑟𝑒𝑞2, 𝑟𝑒𝑞3} ⇒ 𝑃1).
Definition 5 (Finite trace and bounded trace). The volume of
a trace 𝜎 = ( ¯𝐷, ¯𝜏, 𝑣) is the total number of relations that hold across
¯𝐷, denoted as 𝑣𝑜𝑙 (𝜎) = (cid:205)𝑟 ∈𝑅 (cid:205)𝐷𝑖 ∈ ¯𝐷 (|𝑟 𝐷𝑖 |). The trace 𝜎 is finite if

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

𝑣𝑜𝑙 (𝜎) is finite. The trace is bounded by volume if there exists an
upper bound 𝑏𝑣𝑜𝑙 ∈ N such that 𝑣𝑜𝑙 (𝜎) ≤ 𝑏𝑣𝑜𝑙 . In the rest of paper,
we refer to volume-bounded traces as bounded traces.

Example 6. The volume of trace 𝜎4 in Fig. 2, 𝑣𝑜𝑙 (𝜎4) = 3 since
there are three relations: Collect(1, 15), Update(1, 0), and Access(1,
15). Note that the volume and the length for this trace are different.
The length, | ¯𝐷 |, corresponds to the number of time points while
the volume is the total number of holding relations across all time
points. More than one relation can hold for a single time point.

Definition 6 (Bounded satisfiability checking of MFOTL prop-
erties). Let 𝜙 be an MFOTL property, Reqs be a set of MFOTL re-
quirements, and 𝑏𝑣𝑜𝑙 be a natural number. The bounded satisfiability
checking problem determines the existence of a counterexample 𝜎 to
Reqs ⇒ 𝜙 such that 𝑣𝑜𝑙 (𝜎) ≤ 𝑏𝑣𝑜𝑙 .

4 CHECKING BOUNDED SATISFIABILITY
In this section, we present an overview of the bounded satisfiability
checking (BSC) process that translates MFOTL formula into first-
order logic (FOL) formulas, and looks for a satisfying solution for
the FOL formulas. Then, we provide the translation of MFOTL
formulas to FOL and discuss the complexity of the process.

4.1 Overview of BSC for MFOTL Formulas
We aim to address the bounded satisfiability checking problem
(Def. 6), looking for a satisfying run 𝜎 within a given volume bound
𝑏𝑣𝑜𝑙 that limits the number of relations in 𝜎. First, we translate
the MFOTL formulas to FOL formulas, where each relation in a
trace is mapped to a relational object in the FO domain. The con-
sidered constraints in the formulas include the ones of the system
requirements and the legal property, and optional data constraints
specifying the data domain of the system. Second, we search for a
satisfying solution to the FOL constraints; an SMT solver is used
here to determine the satisfiability of the FOL constraints and the
data domain constraints. The answer from the SMT solver is ana-
lyzed to return an answer to the satisfiability checking problem (a
counterexample 𝜎, or "bounded-UNSAT").

4.2 Translation of MFOTL to First-Order Logic
The translation is a two-step procedure: (1) defining the FOL search
domain and (2) translating MFOTL formulas to FOL formulas. This
translation enables to search for a solution of the bounded satisfia-
bility problem in the FOL domain.

4.2.1 Domain of the Search Space. Any volume-bounded trace
𝜎 = ( ¯𝐷, ¯𝜏, 𝑣) (bounded by 𝑏𝑣𝑜𝑙 ) can be mapped to a single FO
structure (𝐷𝐴𝑈 , 𝑣 ′) by associating the time information in 𝜏𝑖 to
every relation in 𝐷𝑖 for every (𝐷𝑖, 𝜏𝑖 ) in the trace. More specifically,
let 𝐷𝐴𝑈 be the domain defined over signature 𝑆 = (𝐶, 𝑅, 𝜄) (the
same signature as ¯𝐷). 𝐷𝐴𝑈 contains all constants 𝑐 ∈ 𝐶 and 𝑏𝑣𝑜𝑙
relational objects (denoted 𝑜). Each 𝑜 has variables 𝑛𝑎𝑚𝑒 and 𝑡𝑖𝑚𝑒,
and a vector of argument variables (𝑎𝑟𝑔1, . . . , 𝑎𝑟𝑔𝜄 (𝑛𝑎𝑚𝑒) ) associated
with it. Each 𝑜 represents an occurrence of a relation of 𝑜.𝑛𝑎𝑚𝑒
at time 𝑜.𝑡𝑖𝑚𝑒. The following relationship holds for (𝐷𝐴𝑈 , 𝑣 ′) and
( ¯𝐷, ¯𝜏, 𝑣): ∀𝑟 ∈ 𝑅, 𝑟 (𝑡1, 𝑡2...𝑡𝜄 (𝑟 ) ) ∈ 𝑟 𝐷𝑖 ,

iff exists a relational object 𝑜 (𝑎𝑟𝑔1, 𝑎𝑟𝑔2....𝑎𝑟𝑔𝜄 (𝑟 ) ) ∈ 𝐷𝐴𝑈 s.t.
𝑣 (𝑡1) = 𝑣 ′(𝑎𝑟𝑔1), 𝑣 (𝑡2) = 𝑣 ′(𝑎𝑟𝑔2), ..., 𝑣 (𝑡𝜄 (𝑟 ) ) = 𝑣 ′(𝑎𝑟𝑔𝜄 (𝑟 ) )
∧𝜏𝑖 = 𝑣 ′(𝑜.𝑡𝑖𝑚𝑒) ∧ 𝑣 ′(𝑜.𝑛𝑎𝑚𝑒) = 𝑟 .

Intuitively, each holding relation in the trace 𝜎 is mapped to a re-
lational object where the holding time of the relation 𝜏𝑖 is explicitly
associated with the relational object’s 𝑡𝑖𝑚𝑒. Therefore, if a relation
does not hold at a given time, then there is no relational object
which the relation can be mapped to. The name of the relation
𝑜.𝑛𝑎𝑚𝑒 defines the class 𝐶𝑙𝑠 of relational objects in 𝐷𝐴𝑈 . For ex-
ample, ∀𝑜 : 𝐶𝑙𝑠 selects every relational object where 𝑜.𝑛𝑎𝑚𝑒 = 𝐶𝑙𝑠.
In the rest of the paper, to avoid confusion, class names and rela-
tion names are capitalized (e.g., Collect) while individual relational
object names are not (e.g., 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1).

Example 7. Consider the trace 𝜎2 = ( ¯𝐷, ¯𝜏), where ¯𝐷 = [𝐷1; 𝐷2; 𝐷3]
and ¯𝜏 = [𝜏1; 𝜏2; 𝜏3] in Fig. 2. The first-order structure of 𝜎2 is
(𝐷𝐴𝑈 , 𝑣 ′), where 𝐷𝐴𝑈 contains three relational objects. Two of
these objects are from the class 𝐶𝑜𝑙𝑙𝑒𝑐𝑡, and the third one is from the
class 𝐴𝑐𝑐𝑒𝑠𝑠. Let 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 be the relational object corresponding to
the relation 𝐶𝑜𝑙𝑙𝑒𝑐𝑡(1, 0) in 𝐷1 with 𝜏1 = 0. We have: 𝑣 ′(𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.𝑎𝑟𝑔1) =
1, 𝑣 ′(𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.𝑎𝑟𝑔2) = 0 and 𝑣 ′(𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.𝑡𝑖𝑚𝑒) = 0.

For the FO domain 𝐷𝐴𝑈 , let |𝐷𝐴𝑈 | denote the domain size, i.e.,
the number of its relational objects. Therefore, for any trace 𝜎
bounded by 𝑏𝑣𝑜𝑙 , we can map 𝜎 to a first order structure (𝐷𝐴𝑈 , 𝑣 ′)
where the domain size of |𝐷𝐴𝑈 | is also bounded by 𝑏𝑣𝑜𝑙 . Since
MFOTL formulas specify constraints on 𝜎, 𝑣 ′ in 𝐷𝐴𝑈 should satisfy
FOL formulas corresponding to these MFOTL constraints.

4.2.2 From MFOTL Formulas to FOL Formulas. Recall that
the semantics of MFOTL formulas is defined over a trace 𝜎 =
( ¯𝐷, ¯𝜏, 𝑣, 𝑖) at a time point 𝑖 where ¯𝐷 = [𝐷1; 𝐷2; ...] is a sequence of
FO structures and ¯𝜏 = [𝜏1; 𝜏2; ] is a sequence of time values. The
time value of the time point 𝑖 is given by 𝜏𝑖 , and if 𝑖 is not specified,
then 𝑖 = 1. The semantics of FOL formulas is defined on a single
FO structure (𝐷𝐴𝑈 , 𝑣 ′) where the time information is associated
with relational objects in the domain 𝐷𝐴𝑈 . Therefore, the time
point 𝑖 (and its time value 𝜏𝑖 ) needs to be considered during the
translation from MFOTL to FOL since the same MFOTL formula at
different time points represents different constraints over the trace
𝜎. Formally, our translation function translate, abbreviated to 𝑇
for succinctness, translates an MFOTL formula 𝜙 into a function
𝑓 : 𝜏 → 𝜙 𝑓 , where 𝜙 𝑓 is an FOL formula over relational objects.
The FOL formula 𝜙 𝑓 corresponding to the MFOTL formula 𝜙 at time
step 𝑖 is 𝜙 𝑓 = 𝑇 (𝜙, 𝜏𝑖 ). The translation rules for 𝑇 are as follows:

𝑇 (𝑡 = 𝑡 ′, 𝜏𝑖 )
→ 𝑡 = 𝑡 ′
→ 𝑡 > 𝑡 ′
𝑇 (𝑡 > 𝑡 ′, 𝜏𝑖 )
𝑇 (𝑟 (𝑡1, .., 𝑡𝜄 (𝑟 ) ), 𝜏𝑖 ) → ∃𝑜 (𝑎𝑟𝑔1, .., 𝑎𝑟𝑔𝑖 (𝑟 ) ) : 𝑟 ∧ (cid:211)𝜄 (𝑟 )

𝑗=1 (𝑎𝑟𝑔𝑗 = 𝑡 𝑗 )

∧(𝜏𝑖 = 𝑜.𝑡𝑖𝑚𝑒)

→ ¬𝑇 (𝜙, 𝜏𝑖 )
→ 𝑇 (𝜙, 𝜏𝑖 ) ∧ 𝑇 (𝜓, 𝜏𝑖 )

𝑇 (¬𝜙, 𝜏𝑖 )
𝑇 (𝜙 ∧ 𝜓, 𝜏𝑖 )
𝑇 (∃𝑥 · 𝑟 (¯𝑡𝑖
𝐼 𝜙, 𝜏𝑖 )
𝑇 (
𝑇 (
𝐼 𝜙, 𝜏𝑖 )
𝑇 (𝜙 U𝐼 𝜓, 𝜏𝑖 )

(cid:32)
(cid:35)

𝑇 (𝜙 S𝐼 𝜓, 𝜏𝑖 )

𝑥 ) ∧ 𝜙, 𝜏𝑖 ) → ∃𝑜 : 𝑟 · 𝑇 ((𝑟 (¯𝑡𝑖

𝑥 ) ∧ 𝜙) [𝑥 → 𝑜.𝑎𝑟𝑔𝑖 ], 𝜏𝑖 )

→ 𝑇 (𝜙, 𝜏𝑖+1) ∧ (𝜏𝑖+1 − 𝜏𝑖 ) ∈ 𝐼
→ 𝑇 (𝜙, 𝜏𝑖−1) ∧ (𝜏𝑖 − 𝜏𝑖−1) ∈ 𝐼
→ ∃𝑡𝑖𝑚𝑒 · (𝑡𝑖𝑚𝑒 ≥ 𝜏𝑖 ∧ (𝑡𝑖𝑚𝑒 − 𝜏𝑖 ) ∈ 𝐼 ∧ 𝑇 (𝜓, 𝑡𝑖𝑚𝑒)
and ∀𝑡𝑖𝑚𝑒 ′ · (𝜏𝑖 ≤ 𝑡𝑖𝑚𝑒 ′ < 𝑡𝑖𝑚𝑒 ⇒ 𝑇 (𝜙, 𝑡𝑖𝑚𝑒 ′)))
→ ∃𝑡𝑖𝑚𝑒 · (𝑡𝑖𝑚𝑒 ≤ 𝜏𝑖 ∧ (𝜏𝑖 − 𝑡𝑖𝑚𝑒) ∈ 𝐼 ∧ 𝑇 (𝜓, 𝑡𝑖𝑚𝑒)
and ∀𝑡𝑖𝑚𝑒 ′ · (𝜏𝑖 ≥ 𝑡𝑖𝑚𝑒 ′ > 𝑡𝑖𝑚𝑒 ⇒ 𝑇 (𝜙, 𝑡𝑖𝑚𝑒 ′)))

𝑇 (𝜙)

→ 𝑇 (𝜙, 𝜏1)

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Report, September 8th, 2022,

bound (Nat)

requirements (MFOTL)

property (MFOTL)

data domain con-
straints (FOL)

Translate

formulas (FOL)
+ domain

Ground

formulas
(FOL)

quantifier-free
formulas (FOL)

search

answer

query

Solve
(SMT solver)

counterexample
| bounded-UNSAT
( | UNSAT)

Figure 3: Overview of the naive and our incremental (IBSC) MFOTL bounded satisfiability checking approaches. Solid boxes and arrows are
shared between the two approaches. Blue dashed arrow is specific to the naive approach. Red dotted arrows and the additional red output in
bracket are specific to IBSC.

Proposition 1 (Quantifiers on relational objects). For a MFOTL
formula 𝜙, the FOL formula 𝑇 (𝜙) only contains quantifiers exclusively
on relational objects.

Example 8. Consider a formula 𝑒𝑥𝑝 = □ ∀𝑑 · (𝐴(𝑑) =⇒ ♢[5,10] 𝐵(𝑑))
where 𝐴 and 𝐵 are unary relations. The translated FOL formula

∀𝑎 : 𝐴 · (∃𝑏 : 𝐵 · 𝑎.𝑎𝑟𝑔1 = 𝑏.𝑎𝑟𝑔1 ∧ 𝑎.𝑡𝑖𝑚𝑒 + 5 ≤ 𝑏.𝑡𝑖𝑚𝑒 ≤ 𝑎.𝑡𝑖𝑚𝑒 + 10)

Given an MFOTL property 𝜙 and a set of 𝑀𝐹𝑂𝑇 𝐿 requirements
𝑅𝑒𝑞𝑠, a volume bound 𝑏𝑣𝑜𝑙 , the BSC problem can be solved by search-
ing for a satisfying solution 𝑣 ′ for the FOL formula𝑇 (𝜙) (cid:211)𝜓 ∈𝑅𝑒𝑞𝑠 𝑇 (𝜓 )
in a domain 𝐷𝐴𝑈 with at most 𝑏𝑣𝑜𝑙 relational objects.

4.3 Checking MFOTL Satisfiability
Below, we define a naive procedure NBSC (shown in Fig. 3) for
checking satisfiability of MFOTL formulas translated into FOL. We
then discuss the complexity of this naive procedure. Even though
we do not use this naive procedure in this paper, its complexity
corresponds to the upper-bound of our proposed approach in Sec. 5.

Searching for a satisfying solution. Let 𝑇 (𝜙) be an FOL formula
translated from an MFOTL formula 𝜙, and let 𝑘 be the maximum
quantifier nesting in 𝑇 (𝜙). NBSC solves 𝑇 (𝜙) via quantifier elimi-
nation. By Proposition 1, only relational objects can be quantified.
Given a bound 𝑛, the number of relational objects in any satisfying
solution of 𝑇 (𝜙) should be at most 𝑛. Therefore, NBSC eliminates
quantifiers in 𝑇 (𝜙) by assuming presence of 𝑛 relational objects
and then iterates over them. For example, the formula ∀𝑟 : 𝑅 · 𝜓 (𝑟 )
is converted to 𝜓 (𝑟1) ∧ 𝜓 (𝑟2) . . . ∧ 𝜓 (𝑟𝑛). After eliminating all
quantifiers in the formula 𝑇 (𝜓 ), NBSC calls an SMT solver on the
quantifier-free formula to obtain the satisfiability result.
Complexity. The size of the quantifier-free formula is 𝑂 (𝑛𝑘 ), where
𝑘 is the maximum depth of quantifier nesting. Since the background
theory used in 𝜙 is restricted to LIA, the complexity of solving the
formula is NP-complete [32]. Since Translate is linear in the size
of the formula 𝜙, the complexity of our approach is dominated by
solving the translated formula which is NP-complete with respect
to the size of the formula, 𝑛𝑘 .

5 INCREMENTAL SEARCH FOR BOUNDED

COUNTEREXAMPLES

The naive BSC approach (NBSC) defined in Sec. 4.3 is inefficient
for solving the translated FOL formulas given a larger bound 𝑛
since its quantifier elimination creates a quantifier-free formula of
size 𝑂 (𝑛𝑘 ) even if satisfiability may be determined using a smaller

bound. Moreover, NBSC cannot detect unbounded unsatisfiabil-
ity, and cannot provide optimality guarantees on the volume of
counterexamples which are important for establishing the proof of
unbounded correctness and localizing faults [16], respectively. In
this section, we propose an incremental procedure, IBSC, that can
detect unbounded unsatisfiability and provide shortest counterex-
amples. An overview of IBSC is shown in Fig. 3.

IBSC maintains an under-approximation of the search domain
and the FOL constraints. It uses the search domain to ground the
FOL constraints, and an off-the-shelf SMT solver to determine sat-
isfiability of the grounded constraints and the data domain con-
straints. It analyzes the SMT result and accordingly either expands
the search domain, refines the FOL constraints, or returns an an-
swer to the satisfiability checking problem (a counterexample 𝜎,
"bounded-UNSAT", or "UNSAT"). The procedure continues until an
answer is obtained or until the domain exceeds the bound 𝑏𝑣𝑜𝑙 , in
which case a “bounded-UNSAT” answer is returned. If the bound
increases, 𝜎 with the minimal volume and the UNSAT value are
preserved while bounded-UNSAT may turn into 𝜎 or UNSAT.

In the following, we describe IBSC in more detail. We explain the
key component of IBSC, computing over and under-approximation
queries in Sec. 5.1, the algorithm itself in Sec. 5.2, and analysis of
its soundness, completeness, and the solution optimality in Sec. 5.3.

5.1 Over- and Under-Approximation
IBSC searches for a counter-example in a FO domain 𝐷𝐴𝑈 whose
size is bounded by a given volume bound 𝑏𝑣𝑜𝑙 . Instead of directly
searching inside 𝐷𝐴𝑈 , IBSC starts with an under-approximated
domain 𝐷𝐴𝑈 ↓ ⊆ 𝐷𝐴𝑈 where every relational object in 𝐷𝐴𝑈 ↓ is
in also 𝐷𝐴𝑈 . With 𝐷𝐴𝑈 ↓, we can create an over- and an under-
approximation query to the bounded satisfiability problem. Such
queries are used to check satisfiability of FO formulas with domain
𝐷𝐴𝑈 ↓. IBSC starts with a small domain 𝐷𝐴𝑈 ↓ and gradually ex-
pands it until either SAT or UNSAT is returned, or the domain size
exceeds some limit (bounded-UNSAT).

Over-approximation. Let 𝜙 𝑓 be an FOL formula with quantifiers
over relational objects, and 𝐷𝐴𝑈 ↓ be an FO domain of relation ob-
jects. The procedure Ground (𝐺) encodes 𝜙 𝑓 into a quantifier-free
FOL formula 𝜙𝑔 s.t. the unsatisfiability of 𝜙𝑔 implies the unsatisfia-
bility of 𝜙 𝑓 . We call 𝜙𝑔 an over-approximation of 𝜙 𝑓 .

The procedure 𝐺 (Alg. 2) recursively traverses the AST of the
input FOL formula. To eliminate the existential quantifier in ∃𝑟 :
𝐶𝑙𝑠 · 𝑏𝑜𝑑𝑦 (L:2), 𝐺 creates a new relational object 𝑛𝑒𝑤𝑅 (uncon-
strained) of class 𝐶𝑙𝑠 (L: 5), and replaces 𝑟 with 𝑛𝑒𝑤𝑅 in 𝑏𝑜𝑑𝑦 (L:6).

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

To eliminate the universal quantifier in ∀𝑟 : 𝐶𝑙𝑠 · 𝑏𝑜𝑑𝑦 (L: 8), 𝐺 ex-
pands the quantifier into a conjunction of clauses where each clause
is 𝑏𝑜𝑑𝑦 [𝑟 ← 𝑟𝑖 ] (i.e., 𝑟 is replaced by 𝑟𝑖 in 𝑏𝑜𝑑𝑦) for each relational
object 𝑟𝑖 of class 𝐶𝑙𝑠 in 𝐷𝐴𝑈 ↓ (L:10). Intuitively, an existentially-
quantified relational object is instantiated with a new relational
object, and an universally quantified relational object is instantiated
with every existing relational object of the same class in 𝐷𝐴𝑈 ↓.
Example 9. Consider the following FOL formula:
𝑒𝑥𝑝 𝑓 = ∃access : Access · (∀update : Update)·
(𝑎𝑐𝑐𝑒𝑠𝑠.𝑎𝑟𝑔1 = 𝑢𝑝𝑑𝑎𝑡𝑒.𝑎𝑟𝑔1 ⇒ 𝑎𝑐𝑐𝑒𝑠𝑠.𝑡𝑖𝑚𝑒 ≥ 𝑢𝑝𝑑𝑎𝑡𝑒.𝑡𝑖𝑚𝑒 + 5)
Let 𝐷𝐴𝑈 ↓1 = {𝑢𝑝𝑑𝑎𝑡𝑒1, 𝑢𝑝𝑑𝑎𝑡𝑒2}. 𝐺(𝑒𝑥𝑝 𝑓 , 𝐷𝐴𝑈 ↓1) instantiates
∃access : Access with a new relational object, 𝑎𝑐𝑐𝑒𝑠𝑠1, and instan-
tiates ∀update : Update with two relational objects, 𝑢𝑝𝑑𝑎𝑡𝑒1 and
𝑢𝑝𝑑𝑎𝑡𝑒2 in 𝐷𝐴𝑈 ↓1. The grounded formula is

𝑒𝑥𝑝𝑔 = 𝑎𝑐𝑐𝑒𝑠𝑠1∧
(𝑢𝑝𝑑𝑎𝑡𝑒1.𝑎𝑟𝑔1 = 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔1 ⇒ 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑡𝑖𝑚𝑒 ≥ 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 + 5)
∧ (𝑢𝑝𝑑𝑎𝑡𝑒2.𝑎𝑟𝑔1 = 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔1 ⇒ 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑡𝑖𝑚𝑒 ≥ 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 + 5).

Proposition 2. For every FOL formula 𝜙 𝑓 translated from MFOTL
formula 𝜙 and domain 𝐷𝐴𝑈 ↓, the grounded formula 𝜙𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ↓)
is quantifier-free and contains a finite number of variables and terms.

Lemma 1 (Over-approximation Query). For an FOL formula 𝜙 𝑓 ,
and a domain 𝐷𝐴𝑈 ↓, if 𝜙𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ↓) is UNSAT, then so is 𝜙 𝑓 .
Proof. We prove Lemma 1 by contradiction. Suppose 𝜙𝑔 is UN-
SAT but there exists a solution 𝑣 𝑓 for 𝜙 𝑓
in some domain 𝐷𝐴𝑈
(𝐷𝐴𝑈 may be different from 𝐷𝐴𝑈 ↓). We show that we can always
construct a solution 𝑣𝑔 that satisfies 𝜙𝑔, which causes a contradic-
tion. First, we construct a solution 𝑣 ′
𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ) from
the solution 𝑣 𝑓 (for 𝜙 𝑓 ). Then, we construct a solution 𝑣𝑔 for 𝜙𝑔
from the solution 𝑣 ′

𝑔 for 𝜙 ′

𝑔 for 𝜙 ′
𝑔.

𝑔 for 𝜙 ′

We can construct a solution 𝑣 ′

𝑔 in 𝐷𝐴𝑈 ∪ 𝑁 𝑒𝑤𝑅𝑠 where
𝑁 𝑒𝑤𝑅𝑠 are the new relational objects added by 𝐺. The encoding
of 𝐺 uses the standard way for expanding universally quantified
expression by enumerating every relation object in 𝐷𝐴𝑈 (L:10).
For every existentially quantified expression, there exists some
relation object 𝑟 ∈ 𝐷𝐴𝑈 enabled by 𝑣 𝑓 that satisfies the expression
𝑔 contains a new relational object 𝑟 ′ ∈ 𝑁 𝑒𝑤𝑅𝑠 for
in 𝜙 𝑓 , whereas 𝜙 ′
satisfying the same expression (L:6). Let 𝑣 𝑓 (𝑟 ) = 𝑣 ′
𝑔 (𝑟 ′) for 𝑟 and
𝑟 ′, and then 𝑣 ′

𝑔 is a solution to 𝜙 ′
𝑔.
To construct the solution 𝑣𝑔 for 𝜙𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ↓) from the
solution 𝑣 ′
𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ), we consider the expansion of
universally quantified expression in 𝜙 𝑓 (L:8). For every relational
objects in 𝑟 + ∈ 𝐷𝐴𝑈 − 𝐷𝐴𝑈 ↓, 𝐺 creates constraints (L:10) in 𝜙 ′
𝑔,
but not in 𝜙𝑔. On the other hand, for every relational objects in
𝑟 − ∈ 𝐷𝐴𝑈 ↓−𝐷𝐴𝑈 , we disable 𝑟 − in the solution 𝑣𝑔, (i.e., 𝑣𝑔 (𝑟 −) = ⊥).
Therefore, the constraints instantiated by 𝑟 − (at L:10) in 𝜙𝑔 are
vacuously satisfied.

𝑔 for 𝜙 ′

For every relational object 𝑟 ∈ 𝐷𝐴𝑈 ↓ ∩𝐷𝐴𝑈 , we let 𝑣𝑔 (𝑟 ) = 𝑣 ′

𝑔 (𝑟 ),
and all shared constraints in 𝜙𝑔 and 𝜙 ′
𝑔 are satisfied by 𝑣𝑔 and 𝑣 ′
𝑔,
□
respectively. Therefore, 𝑣𝑔 is a solution to 𝜙𝑔. Contradiction.
Under-approximation. Let 𝜙 𝑓 be an FOL formula, and 𝐷𝐴𝑈 ↓ be
an FO domain. The over-approximation 𝜙𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ↓) contains
a set of new relational objects introduced by 𝐺 (L:5), denoted by
𝑁 𝑒𝑤𝑅𝑠. Let NoNewR(𝑁 𝑒𝑤𝑅𝑠, 𝐷𝐴𝑈 ↓) be constraints that enforce
that every new relational object 𝑟 in 𝑁 𝑒𝑤𝑅𝑠 be identical to some

relational objects in 𝐷𝐴𝑈 ↓. Formally,

NoNewR(𝑁 𝑒𝑤𝑅𝑠, 𝐷𝐴𝑈 ↓) =

(cid:219)

(cid:220)

(𝑟 = 𝑟 ′).

𝑟 ∈𝑁 𝑒𝑤𝑅𝑠

𝑟 ′ ∈𝐷𝐴𝑈 ↓

𝑔 = 𝜙𝑔 ∧ NoNewR(𝑁 𝑒𝑤𝑅𝑠, 𝐷𝐴𝑈 ↓). If 𝜙 ⊥
Let 𝜙 ⊥
𝑔 has a satisfying
solution, then there is a solution for 𝜙 𝑓 . We call 𝜙 ⊥
𝑔 an under-
approximation of 𝜙 𝑓 and denote the procedure for computing it by
UnderApprox(𝜙 𝑓 , 𝐷𝐴𝑈 ↓).
Example 10. Consider the FOL formula 𝑒𝑥𝑝 𝑓 in Ex. 9 and 𝐷𝐴𝑈 ↓2 =
{𝑢𝑝𝑑𝑎𝑡𝑒1, 𝑢𝑝𝑑𝑎𝑡𝑒2, 𝑎𝑐𝑐𝑒𝑠𝑠1}.

𝐺 (𝑒𝑥𝑝 𝑓 , 𝐷𝐴𝑈 ↓2) = 𝑎𝑐𝑐𝑒𝑠𝑠2∧
(𝑢𝑝𝑑𝑎𝑡𝑒1.𝑎𝑟𝑔1 = 𝑎𝑐𝑐𝑒𝑠𝑠2.𝑎𝑟𝑔1 ⇒ 𝑎𝑐𝑐𝑒𝑠𝑠2.𝑡𝑖𝑚𝑒 ≥ 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 + 5)∧
(𝑢𝑝𝑑𝑎𝑡𝑒2.𝑎𝑟𝑔1 = 𝑎𝑐𝑐𝑒𝑠𝑠2.𝑎𝑟𝑔1 ⇒ 𝑎𝑐𝑐𝑒𝑠𝑠2.𝑡𝑖𝑚𝑒 ≥ 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 + 5),

𝑔 = UnderApprox(

𝑔 , then there exists a solution to 𝜙 𝑓 .

where 𝑎𝑐𝑐𝑒𝑠𝑠2 is the new relational object introduced in the grounded
formula. In 𝜙 ⊥
𝑔 , 𝑎𝑐𝑐𝑒𝑠𝑠2 is constrained to be some relational objects
in 𝐷𝐴𝑈 ↓2 (see NoNewR({𝑎𝑐𝑐𝑒𝑠𝑠2}, 𝐷𝐴𝑈 ↓2)). Therefore, 𝜙 ⊥
𝑔 query
is 𝐺 (𝑒𝑥𝑝 𝑓 , 𝐷𝐴𝑈 ↓2) ∧ 𝑎𝑐𝑐𝑒𝑠𝑠2 = 𝑎𝑐𝑐𝑒𝑠𝑠1.
Lemma 2 (Under-Approximation Query). For an FOL formula
𝜙 𝑓 , and a domain 𝐷𝐴𝑈 ↓, let 𝜙𝑔 = 𝐺 (𝜙 𝑓 , 𝐷𝐴𝑈 ↓) and 𝜙 ⊥
𝜙 𝑓 , 𝐷𝐴𝑈 ↓). If 𝜎 is a solution to 𝜙 ⊥
Proof. By construction, NoNewR(𝑁 𝑒𝑤𝑅𝑠, 𝐷𝐴𝑈 ↓) guarantees that
if 𝜎 is a solution to 𝜙 ⊥
𝑔 in the domain 𝐷𝐴𝑈 ↓, there exists a solution 𝜎 ′
to 𝜙𝑔 in the domain 𝐷𝐴𝑈 ↓ ∪ 𝑁 𝑒𝑤𝑅𝑠. Since every relational object
𝑟 ∈ 𝐷𝐴𝑈 ↓ has been used to instantiate a universally-quantified
expression (L:10 of Alg. 2), 𝜎 ′ is also a solution to 𝜙 𝑓 .
□
Suppose for some domain 𝐷𝐴𝑈 ↓, an over-approximation query
𝜙𝑔 for an FOL formula 𝜙 𝑓 is satisfiable while the under-approximation
query 𝜙 ⊥
𝑔 is UNSAT. Then we cannot conclude satisfiability of 𝜙 𝑓
for 𝐷𝐴𝑈 ↓. However, the solution to 𝜙𝑔 provides hints on how to
expand 𝐷𝐴𝑈 ↓ to potentially obtain a satisfying solution for 𝜙 𝑓 .
Corollary 1 (Necessary relational objects). For a satisfying FOL
formula 𝜙 𝑓 and a domain 𝐷𝐴𝑈 ↓, let 𝜙𝑔 and 𝜙 ⊥
𝑔 be the over- and under-
approximation queries of 𝜙 𝑓 based on 𝐷𝐴𝑈 ↓, respectively. Suppose
𝜙𝑔 is satisfiable, and 𝜙 ⊥
𝑔 is UNSAT, then every solution to 𝜙 𝑓 contains
some relational object mentioned in the formula 𝜙𝑔 but not in 𝐷𝐴𝑈 ↓.
𝑔 are over- and under- approxima-
tion of 𝜙 𝑓 , respectively. Cor. 1 shows that any domain 𝐷𝐴𝑈 that
contains a satisfying solution to 𝜙 𝑓 must consider some relational
objects from some solution to 𝜙𝑔.

Cor. 1 holds because 𝜙𝑔 and 𝜙 ⊥

5.2 Counterexample-Guided Constraint

Solving Algorithm

Let an MFOTL formula 𝜙, a set of MFOTL requirements Reqs, an
optional volume bound 𝑏𝑣𝑜𝑙 , and optionally a set of FOL data do-
main constraints 𝑇𝑑𝑎𝑡𝑎 be given. IBSC, shown in Alg. 1, searches
for a solution 𝜎 to 𝜙 (cid:211)𝜓 ∈Reqs 𝜓 (while respecting 𝑇𝑑𝑎𝑡𝑎), bounded
by 𝑏𝑣𝑜𝑙 . If no such solution is possible regardless of the bound,
IBSC returns UNSAT. If no solution can be found within the given
bound, but a solution may exist for a larger bound, then IBSC re-
turns bounded-UNSAT. If 𝑏𝑣𝑜𝑙 is not specified, IBSC will perform
the search unboundedly until a solution or UNSAT is returned.

IBSC first translates 𝜙 and every 𝜓 ∈ Reqs into FOL formulas
in Reqs𝑓 , denoted by 𝜙 𝑓 and 𝜓𝑓 , respectively. Then IBSC searches

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

↓

for a satisfying solution to 𝜙 𝑓 ∧ (cid:211)𝜓𝑓 ∈Reqs𝑓
𝜓𝑓 (denote as 𝜙𝑃 ∧Reqs)
in the FO domain 𝐷𝐴𝑈 of volume which is at most 𝑏𝑣𝑜𝑙 . Instead
of searching in 𝐷𝐴𝑈 directly, IBSC searches for a solution of 𝜙 𝑓 ∧
(cid:211)𝜓𝑓 ∈Reqs
𝜓𝑓 in 𝐷𝐴𝑈 ↓, where Reqs↓ ⊆ Reqs𝑓 and 𝐷𝐴𝑈 ↓ ⊆ 𝐷𝐴𝑈 .
IBSC initializes Reqs↓ and 𝐷𝐴𝑈 ↓ as empty sets (LL:3-4). Then, for the
FOL formula 𝜙𝑃 ∧Reqs, IBSC creates an over- and under-approximation
query 𝜙𝑔 (L:8) and 𝜙 ⊥
𝑔 (L:10), respectively (described in Sec. 5.1).
IBSC first solves the over-approximation query 𝜙𝑔 by querying an
SMT solver (L:14). If 𝜙𝑔 is unsatisfiable, then 𝜙𝑃 ∧Reqs is unsatisfiable
(Lemma 1), and IBSC returns UNSAT (L:12).

𝑔 (L:11). If 𝜙 ⊥

If 𝜙𝑔 is satisfiable, then IBSC solves the under-approximation
query 𝜙 ⊥
𝑔 is unsatisfiable, then the current domain
𝐷𝐴𝑈 ↓ is too small, and IBSC expands it (LL:15-22). This is because
satisfiability of 𝜙𝑔 indicates the possibility of finding a satisfying
solution after adding at least one of the new relational objects in
the solution of 𝜙𝑔 to 𝐷𝐴𝑈 ↓ (Cor. 1). The expansion aims to identify
a minimum solution 𝜎𝑚𝑖𝑛 for 𝜙𝑔 that requires the smallest number
of relational objects (L:16). For every relational object 𝑟 ′ ∈ 𝜎𝑚𝑖𝑛, 𝑟 ′
is added to 𝐷𝐴𝑈 ↓ if it is not already in 𝐷𝐴𝑈 ↓ (L:18). To obtain 𝜎𝑚𝑖𝑛,
we follow MaxRes [31] methods: we analyze the UNSAT core of 𝜙 ⊥
𝑔
and incrementally weaken 𝜙 ⊥
𝑔 towards 𝜙𝑔 (i.e., the weakened query
𝜙 ⊥′
𝑔 is an “over-under approximation” that satisfies the condition
𝑔 ⇒ 𝜙 ⊥′
𝜙 ⊥
𝑔 ⇒ 𝜙𝑔) until a satisfying solution 𝜎𝑚𝑖𝑛 is obtained for
the weakened query. However, if the volume of 𝜎𝑚𝑖𝑛 exceeds 𝑏𝑣𝑜𝑙
(L:19), then bounded-UNSAT is returned (L:20).

On the other hand, if 𝜙 ⊥

𝑔 yields a solution 𝜎, then 𝜎 is checked
on Reqs𝑓 (L:23). If 𝜎 satisfies every 𝜓𝑓 in Reqs𝑓 , then 𝜎 is returned
(L:24). If 𝜎 violates some requirements in Reqs𝑓 , then the violating
requirement 𝑙𝑒𝑠𝑠𝑜𝑛 is added to Reqs↓ to be considered in the search
for the next solutions (L:28).

If IBSC does not find a solution or does not return UNSAT, it
means that no solution is found because the 𝐷𝐴𝑈 ↓ is too small
or the Reqs↓ are too weak. IBSC then starts again with either the
expanded domain 𝐷𝐴𝑈 ↓ or the refined set of requirements Reqs↓.
It computes the over- and under-approximation queries (𝜙𝑔 and
𝜙 ⊥
𝑔 ) again and repeats the steps. Due to structural similarities of 𝜙𝑔
and 𝜙 ⊥
𝑔 between iterations, incremental encoding and solving are
enabled to allow SMT solvers to internally reuse learned clauses
from previous iterations.

Example 11. Consider the DCC example in Sec. 2. Suppose IBSC
is invoked to find a counterexample for property 𝑃1 (shown in
Fig. 1) subject to requirements Reqs = {𝑟𝑒𝑞1, 𝑟𝑒𝑞2} with the bound
𝑏𝑣𝑜𝑙 = 4. IBSC translates the requirements and the property to FOL,
and initializes Reqs↓ and 𝐷𝐴𝑈 ↓ to empty sets. For each iteration,
we use 𝜙𝑔 and 𝜙 ⊥
𝑔 to represent the over- and under-approximation
queries computed on LL:8-10, respectively.

1st iteration: 𝐷𝐴𝑈 ↓ = ∅ and Reqs↓ = ∅. 𝜙𝑔 introduces three
new relational objects (from ¬𝑃1): 𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 and 𝑢𝑝𝑑𝑎𝑡𝑒1
such that: (C1) 𝑎𝑐𝑐𝑒𝑠𝑠1 occurs after 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 and 𝑢𝑝𝑑𝑎𝑡𝑒1; (C2)
𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔1 = 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.𝑎𝑟𝑔1 = 𝑢𝑝𝑑𝑎𝑡𝑒1.𝑎𝑟𝑔1; (C3) 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔2 ≠
𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.𝑎𝑟𝑔2∧𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔2 ≠ 𝑢𝑝𝑑𝑎𝑡𝑒1.𝑎𝑟𝑔2; and (C4) either 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1
or 𝑢𝑝𝑑𝑎𝑡𝑒1 must be present in the counterexample. 𝜙𝑔 is satisfiable,
but 𝜙 ⊥
𝑔 is UNSAT since 𝐷𝐴𝑈 ↓ is an empty set. WLOG, we assume
𝐷𝐴𝑈 ↓ is expanded by adding 𝑎𝑐𝑐𝑒𝑠𝑠1 and 𝑢𝑝𝑑𝑎𝑡𝑒1.

Report, September 8th, 2022,

Algorithm 1 IBSC: search for a bounded (by 𝑏𝑣𝑜𝑙 ) solution to
𝑇 (𝜙) (cid:211)𝜓 ∈Reqs 𝑇 (𝜓 ).

Input an MFOTL formula 𝜙.
Input a set of MFOTL requirements Reqs = {𝜓1,𝜓2, ... }.
Optional Input 𝑏𝑣𝑜𝑙 , the volume bound of the counterexample.
Optional Input data constraints 𝑇𝑑𝑎𝑡𝑎, default ⊤.
Output a counterexample 𝜎, UNSAT or bounded-UNSAT.

𝑔 ∧ 𝑇𝑑𝑎𝑡𝑎)

return UNSAT

end if
𝜎 ← Solve(𝜙 ⊥
if 𝜎 = UNSAT then //expand 𝐷𝐴𝑈 ↓

𝜙 ← 𝜙 𝑓 ∧ Reqs
↓
//over-approximation query
𝜙𝑔 ← 𝐺 (𝜙, 𝐷𝐴𝑈 ↓)
//under-approximation query
𝜙 ⊥
𝑔 ← UnderApprox(𝜙, 𝐷𝐴𝑈 ↓)
if Solve(𝜙𝑔 ∧ 𝑇𝑑𝑎𝑡𝑎) = UNSAT then

1: Reqs𝑓 ← { 𝜓𝑓 = 𝑇 (𝜓 ) | 𝜓 ∈ Reqs}
2: 𝜙 𝑓 ← 𝑇 (𝜙)
↓ ← ∅ //initially do not consider any requirement
3: Reqs
4: 𝐷𝐴𝑈 ↓ ← ∅ //start with empty set of relational objects
5: while ⊤ do
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
end if
30:
31: end while

𝜎𝑚𝑖𝑛 ← Minimize(𝜙𝑔)
//add relational object from the minimal solution
𝐷𝐴𝑈 ↓ += {𝑎𝑐𝑡 | 𝑎𝑐𝑡 ∈ 𝜎𝑚𝑖𝑛 }
if 𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛) > 𝑏𝑣𝑜𝑙 then
return bounded-UNSAT

𝑙𝑒𝑠𝑠𝑜𝑛 ← some 𝜓 ∈ Reqs𝑓 such that 𝜎 ̸|= 𝜓
//add violating requirement to Reqs
↓
Reqs
↓

if 𝜎 |= 𝜓 for every 𝜓 ∈ Reqs𝑓 then

else //checks all requirements

.add(𝑙𝑒𝑠𝑠𝑜𝑛)

return 𝜎

end if

end if

else

Algorithm 2 𝐺: ground a quantified FOL formula.

Input an FOL formula 𝜙 𝑓 .
Input a domain of relational objects 𝐷𝐴𝑈 ↓.
Output a grounded quantifier-free formula 𝜙𝑔 over relational objects.

𝐶𝑙𝑠 ← 𝜙 𝑓 .𝑐𝑙𝑎𝑠𝑠
//creates a new relational object of class 𝐶𝑙𝑠
𝑛𝑒𝑤𝑅 ← NewAct(𝐶𝑙𝑠)
return 𝐺 (𝜙 𝑓 .body[𝜙 𝑓 .ℎ𝑒𝑎𝑑𝐴𝑐𝑡 ← 𝑛𝑒𝑤𝑅], 𝐷𝐴𝑈 ↓)

1: if is_atom(𝜙 𝑓 ) then return 𝜙 𝑓 end if
2: if 𝜙 𝑓 .𝑜𝑝 = ∃ then //process the existential operator
3:
4:
5:
6:
7: end if
8: if 𝜙 𝑓 .𝑜𝑝 = ∀ then //process the universal operator
9:
10:
11: end if
12: return 𝜙 𝑓 .𝑜𝑝(𝐺 (𝜙𝑐ℎ𝑖𝑙𝑑 , 𝐷𝐴𝑈 ↓) for 𝜙𝑐ℎ𝑖𝑙𝑑 in 𝜙 𝑓 .body)

𝐶𝑙𝑠 ← 𝜙 𝑓 .𝑐𝑙𝑎𝑠𝑠
return (cid:211)

[𝑟 :𝐶𝑙𝑠 ]∈𝐷𝐴𝑈 ↓

𝑟 ⇒ 𝐺 (𝜙 𝑓 .body[𝜙 𝑓 .ℎ𝑒𝑎𝑑 ← 𝑟 ], 𝐷𝐴𝑈 ↓)

2nd iteration: 𝐷𝐴𝑈 ↓ = {𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑢𝑝𝑑𝑎𝑡𝑒1} and Reqs↓ = ∅. 𝜙𝑔
𝑔 is now satisfiable since 𝑎𝑐𝑐𝑒𝑠𝑠1 and 𝑢𝑝𝑑𝑎𝑡𝑒1

stays the same, and 𝜙 ⊥

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

are in 𝐷𝐴𝑈 ↓. Suppose the solution is 𝜎3 (see Fig. 2). However, 𝜎3
violates 𝑟𝑒𝑞2, so 𝑟𝑒𝑞2 is added to Reqs↓.

3rd iteration: 𝐷𝐴𝑈 ↓ = {𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑢𝑝𝑑𝑎𝑡𝑒1} and Reqs↓ = {𝑟𝑒𝑞2}.
𝜙𝑔 introduces two new relational objects (from 𝑟𝑒𝑞2): 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2 and
𝑢𝑝𝑑𝑎𝑡𝑒2 such that (C5) 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2.𝑡𝑖𝑚𝑒 ≤ 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑡𝑖𝑚𝑒 ≤ 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2.𝑡𝑖𝑚𝑒+
168; (C6) 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 ≤ 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑡𝑖𝑚𝑒 ≤ 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 + 168; (C7)
𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔1 = 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2.𝑎𝑟𝑔1 = 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑎𝑟𝑔1; (C8) 𝑎𝑐𝑐𝑒𝑠𝑠1.𝑎𝑟𝑔2 =
𝑐𝑜𝑙𝑙𝑒𝑐𝑡2.𝑎𝑟𝑔2 = 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑎𝑟𝑔2; and (C9) 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2 or 𝑢𝑝𝑑𝑎𝑡𝑒2 exists.
𝜙𝑔 is satisfiable, but 𝜙 ⊥
𝑔 is UNSAT because 𝑢𝑝𝑑𝑎𝑡𝑒2 ∉ 𝐷𝐴𝑈 ↓ and
𝑢𝑝𝑑𝑎𝑡𝑒1 ≠ 𝑢𝑝𝑑𝑎𝑡𝑒2 (C8 conflicts with C3). Therefore, 𝐷𝐴𝑈 ↓ needs
to be expanded. Assume 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2 is added.

4th iteration: 𝐷𝐴𝑈 ↓ = {𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑢𝑝𝑑𝑎𝑡𝑒1, 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2} and Reqs↓ =
{𝑟𝑒𝑞2}. 𝜙𝑔 stays the same, and 𝜙 ⊥
𝑔 is now satisfiable since 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2
is in 𝐷𝐴𝑈 ↓. Suppose the solution is 𝜎4 (see Fig. 2). Since 𝜎4 violates
𝑟𝑒𝑞1, 𝑟𝑒𝑞1 is added to Reqs↓.

5th iteration: 𝐷𝐴𝑈 ↓ = {𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑢𝑝𝑑𝑎𝑡𝑒1, 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2} and Reqs↓ =
{𝑟𝑒𝑞1, 𝑟𝑒𝑞2}. Since 𝑟𝑒𝑞1 is in Reqs↓, 𝜙𝑔 adds the following con-
straints (from 𝑟𝑒𝑞1): (C9) ¬(𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 − 168 ≤ 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.𝑡𝑖𝑚𝑒 ≤
𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒). Since (C9) conflicts with (C8),(C7) and (C1), 𝑢𝑝𝑑𝑎𝑡𝑒2
cannot be in the solution of 𝜙𝑔. 𝜙𝑔 is satisfiable if 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 (intro-
duced in the 1st iteration) or 𝑢𝑝𝑑𝑎𝑡𝑒2 (3rd iteration) are in the
solution. But 𝜙 ⊥
𝑔 is UNSAT since 𝐷𝐴𝑈 ↓ does not contain 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 or
𝑢𝑝𝑑𝑎𝑡𝑒2. Thus, 𝐷𝐴𝑈 ↓ is refined. Assume 𝑢𝑝𝑑𝑎𝑡𝑒2 is added to 𝐷𝐴𝑈 ↓.
6th iteration: 𝐷𝐴𝑈 ↓ = {𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑢𝑝𝑑𝑎𝑡𝑒1, 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2, 𝑢𝑝𝑑𝑎𝑡𝑒2} and
Reqs↓ = {𝑟𝑒𝑞1, 𝑟𝑒𝑞2}. 𝜙𝑔 adds the constraints (C10) 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 ≥
𝑢𝑝𝑑𝑎𝑡𝑒1.𝑡𝑖𝑚𝑒 + 168. 𝜙𝑔 (from 𝑟𝑒𝑞1) and (C11) 𝑢𝑝𝑑𝑎𝑡𝑒2.𝑡𝑖𝑚𝑒 ≤
𝑢𝑝𝑑𝑎𝑡𝑒1.𝑡𝑖𝑚𝑒 (from ¬𝑃). Since (C10) conflicts with (C11), 𝑢𝑝𝑑𝑎𝑡𝑒2
cannot exist in the solution of 𝜙𝑔. Thus, 𝜙𝑔 is satisfiable only if
𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 is in the solution. 𝜙 ⊥
𝑔 is UNSAT because 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1 ∉ 𝐷𝐴𝑈 ↓.
Therefore, 𝐷𝐴𝑈 ↓ is expanded by adding 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1.

final iteration: 𝐷𝐴𝑈 ↓ = {𝑎𝑐𝑐𝑒𝑠𝑠1, 𝑢𝑝𝑑𝑎𝑡𝑒1, 𝑐𝑜𝑙𝑙𝑒𝑐𝑡2, 𝑢𝑝𝑑𝑎𝑡𝑒2, 𝑐𝑜𝑙𝑙𝑒𝑐𝑡1}

and Reqs↓ = {𝑟𝑒𝑞1, 𝑟𝑒𝑞2}. 𝜙 ⊥
solution 𝜎5 in Fig. 2. 𝜎5 satisfies 𝑟𝑒𝑞1 and 𝑟𝑒𝑞2, and is returned.

𝑔 becomes satisfiable, and yields the

5.3 Correctness, Termination, Optimality
In this section, we first prove correctness of the IBSC algorithm,
then show that IBSC always terminates when 𝑏𝑣𝑜𝑙 ≠ ∞ and finally
prove that IBSC always finds a solution with a minimum volume.

Theorem 1 (Soundness). If the algorithm IBSC terminates on input
𝜙, Reqs and 𝑏𝑣𝑜𝑙 , then it returns the correct result, i.e., a counter-
example 𝜎, "UNSAT" or "bounded-UNSAT", when they apply.

Proof. Let 𝜙 𝑓 be the FOL formula 𝑇 (𝜙) (cid:211)𝜓 ∈Reqs 𝑇 (𝜓 ). We consider
correctness of IBSC for three possible outputs: the satisfying solu-
tion 𝜎 to 𝜙 𝑓 (L:24), the UNSAT determination of 𝜙 𝑓 (L:12), and the
bounded-UNSAT determination of 𝜙 𝑓 (L:20).

IBSC returns a satisfying solution 𝜎 only if (1) 𝜎 is a solution
𝜙 ⊥
𝑔 (L:25) and (2) 𝜎 |= 𝑇 (𝜓 ) for every 𝜓 ∈ 𝑅𝑒𝑞𝑠 (L:23). By (1) and
Lemma 2, 𝜎 is a solution to 𝑇 (𝜙) (cid:211)𝜓 ∈Reqs
𝑇 (𝜓 ). Together with (2),
𝜎 is a solution to 𝜙 𝑓 .

↓

IBSC returns UNSAT iff 𝜙𝑔 is UNSAT (L:11). By Lemma 1, we
𝑇 (𝜓 ) is UNSAT. Since Reqs↓ ⊆ 𝑅𝑒𝑞𝑠, the orig-

show 𝑇 (𝜙) (cid:211)𝜓 ∈Reqs
inal formula 𝜙 𝑓 is also UNSAT.

↓

IBSC returns bounded-UNSAT iff the volume of the minimum
solution 𝜎𝑚𝑖𝑛 to the over-approximated query 𝜙𝑔 is larger than 𝑏𝑣𝑜𝑙
(L:19). Since 𝜙𝑔 is an over-approximation of the original formula 𝜙 𝑓 ,

any solution 𝜎 to the 𝜙 𝑓 has volume at least 𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛). Therefore,
□
when 𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛) > 𝑏𝑣𝑜𝑙 , 𝑣𝑜𝑙 (𝜎) > 𝑏𝑣𝑜𝑙 for every solution.

Theorem 2 (Termination). For an input property 𝜙, requirements
Reqs, and a bound 𝑏𝑣𝑜𝑙 ≠ ∞, IBSC eventually terminates.

Proof. To prove that IBSC always terminates when the input 𝑏𝑣𝑜𝑙 ≠
∞, we need to show that IBSC does not get stuck at solving the
SMT query via solve (LL:14-11), nor refining Reqs↓ (LL:23-29), nor
expanding 𝐷𝐴𝑈 ↓ (LL:18-22).

A call to solve (LL:14-11) always terminates. By Prop. 1, 𝑇 (𝜙)
may contain quantifiers exclusively over relational objects. By
Prop. 2 both the under- and the over-approximated queries 𝜙𝑔
and 𝜙 ⊥
𝑔 are quantifier-free. Since the background theory for 𝜙 is
LIA, then 𝜙𝑔 and 𝜙 ⊥
𝑔 are a quantifier-free LIA formula whose satis-
fiability is decidable.

If the requirement checking fails on L: 23, a violating requirement
𝑙𝑒𝑠𝑠𝑜𝑛 is added to Reqs↓ (LL:26-28) which ensures that any future
solution 𝜎 ′ satisfies 𝑙𝑒𝑠𝑠𝑜𝑛. Therefore, 𝑙𝑒𝑠𝑠𝑜𝑛 is never added to Reqs↓
more than once. Given that Reqs is a finite set of MFOTL formulas, at
most |Reqs| lessons can be learned before the algorithm terminates.
The under-approximated domain 𝐷𝐴𝑈 ↓ can be expanded a fi-
nite number of times because the size of the minimum solution
𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛) to 𝜙𝑔 (computed on L:16) is monotonically non-decreasing
between each iteration of the loop (LL:5-31). The size will eventually
increase since each relational object in 𝐷𝐴𝑈 ↓ can introduce a finite
number of options for adding a new relational object through the
grounded encoding of 𝜙𝑔 on L:10, e.g., 𝑟 ⇒ (cid:212)𝑛
𝑖=0 ∃𝑟𝑖 . After explor-
ing all options to 𝐷𝐴𝑈 ↓, 𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛) must increase if the algorithm
has not already terminated. Therefore, if 𝑏𝑣𝑜𝑙 ≠ ∞, then eventually
𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛) > 𝑏𝑣𝑜𝑙 , and the algorithm will return bounded-UNSAT
□
instead of expanding 𝐷𝐴𝑈 ↓ indefinitely (LL:15-22).

Theorem 3 (Solution optimality). For a property 𝜙 and require-
ments Reqs, let 𝜙 𝑓 be the FOL formula 𝑇 (𝜙) (cid:211)𝜓 ∈Reqs 𝑇 (𝜓 ). If IBSC
finds a solution 𝜎 for 𝜙 𝑓 , then for every 𝜎 ′ |= 𝜙 𝑓 , 𝑣𝑜𝑙 (𝜎) ≤ 𝑣𝑜𝑙 (𝜎 ′).

Proof. IBSC returns a solution 𝜎 on L:24 only if 𝜎 is a solution to
the under-approximation query 𝜙 ⊥
𝑔 (computed on L:10) for some
domain 𝐷𝐴𝑈 ↓ ≠ ∅. 𝐷𝐴𝑈 ↓ is last expanded in some previous it-
erations by adding relational objects to the minimum solution
𝜎𝑚𝑖𝑛 (L:16) of the over-approximation query 𝜙 ′
𝑔 (L:18). Therefore,
the returned 𝜎 has the same number of relational objects as 𝜎𝑚𝑖𝑛
(𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛) = 𝑣𝑜𝑙 (𝜎)). Since 𝜙𝑔 is an over-approximation of the
original formula 𝜙 𝑓 , any solution 𝜎 ′ to 𝜙 𝑓 has volume that is at
least 𝑣𝑜𝑙 (𝜎𝑚𝑖𝑛). Therefore, 𝑣𝑜𝑙 (𝜎) ≤ 𝑣𝑜𝑙 (𝜎 ′).
□

Remark. IBSC finds the optimal solution because it always looks
for the minimum solution 𝜎𝑚𝑖𝑛 to the over-approximation query
𝜙𝑔 (L:16) and uses it for domain expansion (L:18). However, looking
for the minimum solution adds cost. If the solution optimality is not
required, IBSC can be configured to heuristically find a solution 𝜎
to 𝜙𝑔 such that 𝑣𝑜𝑙 (𝜎) ≤ 𝑏𝑣𝑜𝑙 . For example, greedy best-first search
(𝑔𝐵𝐹𝑆) finds a solution to 𝜙𝑔 that minimizes the number of relational
objects that are not already in 𝐷𝐴𝑈 ↓, and then uses it to expand
𝐷𝐴𝑈 ↓. We configured a non-optimal version of IBSC (𝑛IBSC) that
uses 𝑔𝐵𝐹𝑆 heuristics, and evaluate its performance in Sec. 6.

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

names

case study statistics
#𝑟𝑒𝑞𝑠 #𝑟𝑒𝑙𝑠 #𝑎𝑟𝑔𝑠 #𝑝𝑟𝑜𝑝𝑠

configuration values

18
45
14
10

22
28
7
3

PHIM
CF@H
PBC
BST

[1 − 4]
[2 − 3]
[1 − 2]
[1 − 3]

#c = 2, #p = 2, #d = 5
#u = 2, #d = 10
#u = 5, #d = 10
#e = 1, #cus = 2, #t = 4, sup = 10

7
7
1
3
Table 1: Case study statistics. The numbers of requirements, re-
lations, relation arguments, and properties are denoted as #𝑟𝑒𝑞𝑠,
#𝑟𝑒𝑙𝑠, #𝑎𝑟𝑔𝑠, and #𝑝𝑟𝑜𝑝𝑠, respectively. Initial configurations with
data constraints specific to each case study: PHIM – the number
of custodians (#𝑐), patients (#𝑝), and data (#𝑑); CF@H and PBC
– the number of users (#𝑢), and data (#𝑑); BST – the number of em-
ployees (#𝑒), customers (#𝑐𝑢𝑠), transactions (#𝑡 ), and maximum
amount for a transaction (sup).

6 EVALUATION
To evaluate our approach, we developed LEGOS, a tool that im-
plements our MFOTL bounded satisfiability checking algorithm
IBSC (Algorithm 1). It includes Python API for specifying system
requirements and MFOTL safety properties. We use pySMT [15]
to formulate SMT queries and Z3 [10] to check their satisfiability.
LEGOS and the evaluation artifacts are included in supplemen-
tary material. In this section, we evaluate the effectiveness of our
approach using five case studies, aiming to answer the following
research question (RQ): How effective is our approach at determin-
ing the bounded satisfiability of MFOTL formulas? We measure
effectiveness in terms of the ability to determine satisfiability (i.e.,
the satisfying solution and its volume, UNSAT, or bounded UNSAT),
and performance, i.e., time and memory usage.

Cases studies. The case studies shown in Tab. 1, are summarized
below: (1) PHIM (derived from [1, 13]): a computer system for keep-
ing track of personal health information with cost management;
(2) CF@H2: a system for monitoring a COVID patients at home
and enabling doctors to monitor patient data; (3) PBC [5]: an ap-
proval policy for publishing business reports within a company; (4)
BST [5]: a banking system that processes customer transactions;
and (5) NASA [14, 30]: an automated air-traffic control system
design that aims to avoid aircraft collisions. 3 Case studies were
selected for (i) the purpose of comparison with existing works (i.e.,
NASA); (ii) checking whether our approach scales with case studies
involving data/time constraints (PBC, BST, PHIM and CF@H); or
(iii) evaluating the applicability of our approach with real-word
case studies (CF@H and NASA). In addition to prior case stud-
ies, we include PHIM and CF@H which have complex data/time
constraints. The number of requirements for the five case studies
ranges between ten (BST) and 194 (NASA). The number of relations
present in the MFOTL requirements ranges from three (BST) to 28
(CF@H), and the number of arguments in these relations ranges
from 1 (PHM, PBC, and BST) to 79 (NASA). Examples of properties
and requirements considered in this evaluation are shown in Fig. 1.

Experimental setup. Given a set of requirements, data constraints
and properties of interest for each case study, we measured the run-
time (time) and peak memory usage (mem.) of performing bounded

1available at https://github.com/agithubuserseva/IBSC
2https://covidfreeathome.org/
3The requirements and properties for the NASA case study are originally expressed in
LTL, which is subsumed by MFOTL.

Report, September 8th, 2022,

satisfaction checking of MFOTL properties, and the volume 𝑣𝑜𝑙𝜎
(the number of relational objects) of the solution (𝜎) with (IBSC)
and without (𝑛IBSC) the optimality guarantees (see Remark 5.3 for
finding non-optimal solutions). We conduct two experiments: the
first one evaluates the efficiency and scalability of our approach;
the second one compares our approach with satisfiability checking.
Since there is no existing work for checking MFOTL satisfiabil-
ity, we compared with LTL satisfiability checking because MFOTL
subsumes LTL. To study the scalability of our approach, our first
experiment considers four different configurations obtained by
increasing the data domain constraints of the case studies require-
ments. The initial configuration (small) is described in Tab. 1. The
medium and large configurations are obtained by multiplying the
initial data constraints and volume bound by ten and hundred,
respectively. The last (unbounded) configuration does not bound
either the data domain or the volume. To study performance of
our approach relative to existing work, our second experiment con-
siders two configurations of the NASA case study verified in [28]
using the state of the art symbolic model checker nuXmv [8]. We
compare our approach’s result against the reproduced result of
nuXmv verification. For both experiments, we report the analysis
outcomes, i.e., the satisfying solution and its volume, UNSAT, or
bounded UNSAT; and performance, i.e., time and memory usage.
The experiments were conducted using a ThinkPad X1 Carbon with
an Intel Core i7 1.80 GHz processor, 8 GB RAM, and running 64-bit
Ubuntu GNU/Linux 8.

Results of the first experiment are summarized in Tab. 2. Out
of the 72 trials, our approach found 31 solutions. It also returned
five bounded-UNSAT answers, and 36 UNSAT answers. The results
show that our approach is effective in checking satisfiability of
case studies with different size. More precisely, we observe that it
takes under three seconds to return UNSAT and between .04 sec-
onds (𝑏𝑠2:medium) and 32 minutes (𝑝ℎ7:medium:IBSC) to return
a solution. In the worst case, IBSC took 32 minutes for checking
𝑝ℎ7 where the property and requirements contain complex con-
straints. Effectively, 𝑝ℎ7 requires the deletion of data stored at id 10,
while PHIM requires that the cost of deletion increases over time.
Therefore, the user has to perform a number of actions to obtain a
sufficient balance to delete the data. Additionally, each action that
increases the user’s balance has its own preconditions, effects, and
time cost, making the process of choosing the sequence of actions
to meet the increasing deletion cost non-trivial.

We can see a difference in time between cf2 ‘big’ and ‘unbounded’,
this is because the domain expansion followed two different paths
and one produces significantly easier SMT queries. Since our ap-
proach is guided by counter-examples (i.e., the path is guided by
the solution from the SMT solver (Alg.1-L:16)), our approach does
not have direct control over the exact path selection. In future work,
we aim to add optimizations to avoid/backtrack from hard paths.
We observe that the data domain constraint and volume bound
used in different configurations do not affect the performance of
IBSC when the satisfiability of the instances does not depend on
them which is the case for all the instances except for 𝑝ℎ6−7:small,
𝑐 𝑓1−3 : 𝑠𝑚𝑎𝑙𝑙, and 𝑏𝑠3:small. As mentioned in Sec. 4, the data do-
main constraint ensures that satisfying solutions have realistic data
values. For 𝑝ℎ1 − 𝑝ℎ4, the bound used in small, medium and large

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

case studies

𝑝ℎ1
𝑝ℎ2
𝑝ℎ3
𝑝ℎ4
𝑝ℎ5
𝑝ℎ6
𝑝ℎ7
𝑐 𝑓1
𝑐 𝑓2
𝑐 𝑓3
𝑐 𝑓4
𝑐 𝑓5
𝑐 𝑓6
𝑐 𝑓7
𝑝𝑏1
𝑏𝑠1
𝑏𝑠2
𝑏𝑠3

PHIM

CF@H

PBC

BST

small
time
(sec)
𝑛IBSC | IBSC 𝑛IBSC | IBSC 𝑛IBSC | IBSC

mem.
(MB)

out.

U
U
U
U
U
b-U
U

b-U
b-U
b-U
b-U
8 | 8
8 | 8
U

U

U
2 | 2
U

0.04 | 0.03
0.03 | 0.03
0.03 | 0.03
0.04 | 0.04
0.02 | 0.02
0.18 | 0.20
0.11 | 0.11

4.80 | 6.90
0.87 | 0.93
1.38 | 1.31
1.52 | 0.73
1.20 | 1.17
1.06 | 1.16
0.58 | 0.58

0.04 | 0.04

0.04 | 0.03
0.04 | 0.04
0.02 | 0.02

29 | 29
138 | 138
134 | 137
136 | 138
135 | 135
139 | 139
139 | 139

114 | 176
70 | 70
145 | 145
74 | 68
146 | 147
146 | 147
141 | 142

29 | 140

64 | 63
62 | 64
62 | 62

out.

𝑛IBSC | IBSC

U
U
U
U
U
U
29 | 29

U
14 | 14
16 | 16
14 | 14
8 | 8
8 | 8
U

U

U
2 | 2
5 | 5

medium
time
(sec)
𝑛IBSC | IBSC

0.03 | 0.03
0.03 | 0.03
0.03 | 0.03
0.04 | 0.04
0.02 | 0.02
0.72 | 0.82
13.80 | 1905.40

2.87 | 3.55
3.21 | 425.41
6.05 | 90.78
4.54 | 65.59
0.48 | 0.54
0.52 | 0.61
0.38 | 0.36

0.16 | 0.17

0.29 | 0.24
0.04 | 0.04
0.4 | 0.9

mem.
(MB)
𝑛IBSC | IBSC

136 | 136
136 | 137
138 | 138
138 | 135
608 | 608
144 | 144
193 | 599

81 | 86
79 | 334
168 | 403
90 | 261
141 | 142
142 | 142
140 | 141

140 | 139

70 | 68
62 | 62
70 | 73

big
time
(sec)
𝑛IBSC | IBSC 𝑛IBSC | IBSC 𝑛IBSC | IBSC

mem.
(MB)

out.

U
U
U
U
56 | 56
U
30 | 29

U
14 | 14
16 | 16
14 | 14
8 | 8
8 | 8
U

9 | 9

U
2 | 2
5 | 5

0.04 | 0.04
0.03 | 0.04
0.05 | 0.05
0.05 | 0.05
30.51 | 30.51
0.88 | 0.70
20.25 | 682.22

2.98 | 1.71
2.40 | 778.36
3.54 | 371.65
5.63 | 57.30
0.69 | 0.57
0.60 | 0.73
0.47 | 0.44

0.28 | 0.29

0.31 | 0.30
0.04 | 0.04
0.39 | 0.85

136 | 136
136 | 136
137 | 138
138 | 138
390 | 390
142 | 142
193 | 601

85 | 76
76 | 80
157 | 846
95 | 261
141 | 141
141 | 141
140 | 141

141 | 141

69 | 68
64 | 64
70 | 74

out.

𝑛IBSC | IBSC

U
U
U
U
56 | 56
U
32 | 29

U
14 | 14
16 | 16
14 | 14
8 | 8
8 | 8
U

9 | 9

U
2 | 2
5 | 5

unbounded
time
(sec)
𝑛IBSC | IBSC

0.06 | 0.05
0.05 | 0.06
0.06 | 0.06
0.06 | 0.07
21.64 | 21.60
0.91 | 0.91
20.96 | 1035.87

1.71 | 0.74
3.32 | 16.97
5.35 | 24.07
5.65 | 1227.02
0.72 | 0.76
0.72 | 0.72
0.30 | 0.34

0.27 | 0.28

0.25 | 0.25
0.04 | 0.04
0.40 |0.70

mem.
(MB)
𝑛IBSC | IBSC

64 | 64
64 | 61
64 | 64
64 | 64
393 | 390
70 | 70
123 | 383

74 | 68
80 | 205
86 | 164
89 | 294
69 | 69
69 | 69
66 | 67

67 | 67

69 | 69
64| 64
70 | 72

Table 2: Run-time performance for four case studies and 18 properties. We record the outcome (out.) of the algorithm with (IBSC) or without
(𝑛IBSC) the optimal solution guarantee: UNSAT (U), bounded-UNSAT (b-U), or the volume of the counterexample 𝜎 (a natural number, cor-
responding to vol𝜎 ). We consider four different configurations: small (see Tab. 1) medium (x10), big (x100), and unbounded (∞) data domain
constraints and volume bound. The different vol𝜎 between IBSC and 𝑛IBSC are in bold.

NASA

configuration 1

configuration 2

IBSC
time mem.
(MB)
(sec)

nuXmv
time mem.
(MB)
(sec)

out.

out.

IBSC
time mem.
(MB)
(sec)

nuXmv
time mem.
(MB)
(sec)

out.

out.

U
U
U
U
U
U

U
U
U
U
U
U

U
U
U
U
U
U

U
U
U
U
U
U

90
90
90
91
90
90

154
141
141
80
140
62

141
141
141
66
141
62

𝑛𝑎1
𝑛𝑎2
𝑛𝑎3
𝑛𝑎4
𝑛𝑎5
𝑛𝑎6

0.88
0.47
0.49
0.54
0.52
0.57

0.13
0.15
0.13
0.15
0.15
0.03

0.80
0.16
0.16
0.77
0.14
0.03

1.65
1.50
1.48
1.43
1.43
1.40

82
70
83
83
82
72
Table 3: Run-time performance of our approach (IBSC) and the
state of the art model checker (nuXmv) on the NASA case study.
The configurations considered are described in Tab. 1. The configu-
rations considered are modifying the number of ground-separated
(#𝐺𝑆𝐸𝑃 ) and of self-separating aircraft (#𝑆𝑆𝐸𝑃 ) as follow, configu-
ration 1: #𝐺𝑆𝐸𝑃 = 3 and #𝑆𝑆𝐸𝑃 = 0; and configuration 2: #𝐺𝑆𝐸𝑃 =
2 and #𝑆𝑆𝐸𝑃 = 2.

configurations creates additional constraints in the SMT queries
for each relational object, and therefore results in a larger peak
memory than the unbounded configuration.

Finding the optimal solution (by IBSC), in contrast to finding
a satisfying solution without the optimal guarantee (by 𝑛IBSC),
imposes a substantial computational cost while rarely achieving
a volume reduction. The non-optimal heuristic 𝑛IBSC often out-
performed the optimal approach for satisfiable instances. Out of
31 satisfiable instances, 𝑛IBSC solved 12 instances 3 times faster,
10 instances 10 times faster and seven instances 20 times faster
than IBSC. Compared to the non-optimal solution, the optimal so-
lution reduced the volume for only two instances: 𝑝ℎ7:large and
𝑝ℎ7:unbounded by one (3%) and three (9%), respectively. On all
other satisfying instances, IBSC and 𝑛IBSC both find the optimal
solutions. When there is no solution, both IBSC and 𝑛IBSC are
equally efficient.

Results of the second experiment are summarized in Tab. 3. Our
approach and nuXmv both correctly verified that all six proper-
ties were UNSAT in both NASA configurations. We observe that

performance of our approach is comparable to nuXmv for the first
configuration with .10 to .20 seconds of difference on average. Yet,
for the second configuration, our approach terminates in less than
0.20 sec and nuXmv takes 1.50 seconds on average. We conclude
that our approach’s performance is comparable to that of nuXmv
for LTL satisfiability checking even though our approach is not
specifically designed for LTL.

Summary. In summary, we have demonstrated that our approach
is effective at determining the bounded satisfiability of MFOTL
formulas using case studies with different sizes and from different
application domains. When restricted to LTL, our approach is at
least as effective as the existing work on LTL satisfiability checking
which uses the state of the art symbolic model checker. Impor-
tantly, IBSC can often determine satisfiability of instances without
reaching the volume bound, and its performance is insensitive to
data domain. A current limitation of IBSC is its inability to directly
support constraint over aggregated values in the input formulas.
As a walk-around, aggregated values are captured using auxiliary
predicates (e.g., the balance of a user in 𝑝ℎ7) and data constraints to
simulate the aggregation process (e.g., how the balance is updated
with respect to relevant data actions). However, the evaluation re-
sults shows that the walk-around costs the efficiency of IBSC. Thus,
we need to study how to extend IBSC to efficiently handle aggre-
gation. We also observed that IBSC’s optimal guarantee imposes a
substantial computational cost while rarely achieving a volume re-
duction over non-optimal solutions obtained by 𝑛IBSC. We need to
investigate the trade-off between optimality and efficiency, as well
as evaluate performance of IBSC on a broader range of benchmarks.

7 RELATED WORK
Below, we compare with the existing approaches for verifying legal
properties as well as with the approaches that address the satisfia-
bility checking of temporal logic and first-order logic.

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Legal compliance. Various techniques have been proposed for
operationalizing legal provisions and ensuring that systems comply
with these provisions, e.g., [7, 19, 22, 39]. MFOTL has been used in
the context of runtime policy monitoring and enforcement, e.g., for
monitoring security policies [3] and data privacy rules [1]. While
our work is based on the same logic, our intended use case and the
type of reasoning we perform are different: we use MFOTL to spec-
ify requirements and properties and then look for legal-property
violations. Crucially, while previous work requires a system imple-
mentation, our approach enables early validation of legal property
compliance by checking the requirements.

Satisfiability checking of temporal properties. Temporal logic
satisfiability checking has been studied for the verification of system
designs. Satisfiability checking for Linear Temporal Logic (LTL) can
be performed by reducing the problem to model checking [37], by
applying automata-based techniques [29], or by SAT solving [6, 25–
27]. Satisfiability checking for metric temporal logic (MTL) [34]
and its variants, e.g., mission-time LTL [28] and signal temporal
logic [2], has been studied for the verification of real-time system
designs. These existing techniques are inadequate for our needs:
LTL and MTL cannot effectively capture quantified data constraints
commonly used in legal properties. MFOTL does not have such a
limitation as it extends MTL and LTL with first-order quantifiers,
thereby supporting the specification of data constraints.

Finite model finding for first-order logic. Finite-model find-
ers [9, 36] look for a model by checking universal quantifiers exhaus-
tively over candidate models with progressively larger domains;
we look for finite-volume solutions using a similar approach. On
the other hand, we consider an explicit bound on the volume of
the solution, and are able to find the solution with the smallest vol-
ume. SMT solvers support quantifiers with quantifier instantiation
heuristics [17, 18] such as E-matching [11, 12] and conflict-based
instantiation [35]. Quantifier instantiation heuristics are nonethe-
less generally incomplete, whereas, in our approach, we obtain
completeness by bounding the volume of the satisfying solution.

8 CONCLUSION
In this paper, we proposed an incremental bounded satisfiability
checking approach, called IBSC, aimed to enable verification of
legal properties, expressed in MFOTL, against system requirements.
IBSC first translates MFOTL formulas to first-order logic (FOL)
and then searches for a satisfying solution to the translated FOL
formulas in a bounded search space by deriving over- and under-
approximating SMT queries. IBSC starts with a small search space
and incrementally expands it until an answer is returned or until
the bound is exceeded. We implemented IBSC on top of the SMT
solver Z3. Experiments using five case studies showed that our
approach was effective for identifying errors in requirements from
different application domains.

To the best of our knowledge, we are the first to study satis-
fiability checking for MFOTL. Our approach is meant for use in
early-stage system development and to support building systems
that comply to legal properties before detailed behavioural models
or a system implementation become available.

Our approach is currently limited to verifying safety properties.
In the future, we plan to extend our approach so that it can handle

Report, September 8th, 2022,

broader property types, including liveness and fairness. IBSC’s
performance and scalability depend crucially on how the domain
of relational objects is maintained and expanded (currently, this is
done using two heuristics). As a future work, we would like to study
the effectiveness of other heuristics to improve IBSC’s scalability
(e.g., random restart, expansion with domain-specific heuristics).
We also aim to study how to learn/infer MFOTL properties during
the search to further improve the efficiency of our approach.

REFERENCES
[1] Emma Arfelt, David A. Basin, and Søren Debois. Monitoring the GDPR.

In
Kazue Sako, Steve A. Schneider, and Peter Y. A. Ryan, editors, Computer Security
- ESORICS 2019 - 24th European Symposium on Research in Computer Security,
Luxembourg, September 23-27, 2019, Proceedings, Part I, volume 11735 of Lecture
Notes in Computer Science, pages 681–699. Springer, 2019.

[2] Kyungmin Bae and Jia Lee. Bounded model checking of signal temporal logic
properties using syntactic separation. Proc. ACM Program. Lang., 3(POPL):51:1–
51:30, 2019.

[3] David A. Basin, Felix Klaedtke, and Samuel Müller. Monitoring security policies
with metric first-order temporal logic. In James B. D. Joshi and Barbara Carmi-
nati, editors, Proceedings of the 15th Symposium on Access Control Models and
Technologies (SACMAT’2010), Pittsburgh, Pennsylvania, USA, pages 23–34. ACM,
2010.

[4] David A. Basin, Felix Klaedtke, and Samuel Müller. Policy monitoring in first-
order temporal logic. In Tayssir Touili, Byron Cook, and Paul B. Jackson, editors,
Computer Aided Verification, 22nd International Conference, CAV 2010, Edinburgh,
UK, July 15-19, 2010. Proceedings, volume 6174 of Lecture Notes in Computer
Science, pages 1–18. Springer, 2010.

[5] David A. Basin, Felix Klaedtke, Samuel Müller, and Eugen Zalinescu. Monitoring

metric first-order temporal properties. J. ACM, 62(2):15:1–15:45, 2015.

[6] Marcello M. Bersani, Achille Frigeri, Angelo Morzenti, Matteo Pradella, Matteo
Rossi, and Pierluigi San Pietro. Constraint LTL satisfiability checking without
automata. J. Appl. Log., 12(4):522–557, 2014.

[7] Travis D. Breaux, Matthew W. Vail, and Annie I. Antón. Towards regulatory
compliance: Extracting rights and obligations to align requirements with regu-
lations. In 14th IEEE International Conference on Requirements Engineering (RE
2006), 11-15 September 2006, Minneapolis/St.Paul, Minnesota, USA, pages 46–55.
IEEE Computer Society, 2006.

[8] Roberto Cavada, Alessandro Cimatti, Michele Dorigatti, Alberto Griggio, Alessan-
dro Mariotti, Andrea Micheli, Sergio Mover, Marco Roveri, and Stefano Tonetta.
The nuxmv symbolic model checker. In CAV, pages 334–342, 2014.

[9] Koen Claessen and Niklas Sörensson. New techniques that improve mace-style
finite model finding. In Proceedings of the CADE-19 Workshop: Model Computation-
Principles, Algorithms, Applications, pages 11–27. Citeseer, 2003.

[10] Leonardo De Moura and Nikolaj Bjørner. Z3: An efficient smt solver. In Inter-
national conference on Tools and Algorithms for the Construction and Analysis of
Systems, pages 337–340. Springer, 2008.

[11] Leonardo Mendonça de Moura and Nikolaj Bjørner. Efficient e-matching for SMT
solvers. In Frank Pfenning, editor, Proceedings of the 21st International Conference
on Automated Deduction (CADE’2007), Bremen, Germany, volume 4603 of Lecture
Notes in Computer Science, pages 183–198. Springer, 2007.

[12] David Detlefs, Greg Nelson, and James B. Saxe. Simplify: a theorem prover for

program checking. J. ACM, 52(3):365–473, 2005.

[13] Nick Feng, Lina Marsso, and Hubert Garavel. Health record. Model checking
context model (MCC’21), Dept. of Computer Science - University of Toronto,
2021.

[14] Marco Gario, Alessandro Cimatti, Cristian Mattarei, Stefano Tonetta, and
Kristin Yvonne Rozier. Model checking at scale: Automated air traffic control
design space exploration.
In Swarat Chaudhuri and Azadeh Farzan, editors,
Proceedings of the 28th International Conference on Computer Aided Verification
(CAV’2016), Toronto, ON, Canada, volume 9780 of LNCS, pages 3–22. Springer,
2016.

[15] Marco Gario and Andrea Micheli. Pysmt: a solver-agnostic library for fast

prototyping of smt-based algorithms. In SMT Workshop 2015, 2015.

[16] Paul Gastin, Pierre Moro, and Marc Zeitoun. Minimization of counterexamples
in SPIN. In Susanne Graf and Laurent Mounier, editors, Proceedings of the 11th
International Workshop on Model Checking Software (SPIN’04), Barcelona, Spain,
volume 2989 of Lecture Notes in Computer Science, pages 92–108. Springer, 2004.
[17] Yeting Ge, Clark W. Barrett, and Cesare Tinelli. Solving quantified verification
conditions using satisfiability modulo theories. In Frank Pfenning, editor, Pro-
ceedings of the 21st International Conference on Automated Deduction (CADE’2007),
Bremen, Germany, volume 4603 of Lecture Notes in Computer Science, pages 167–
182. Springer, 2007.

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

[39] Damiano Torre, Mauricio Alférez, Ghanem Soltana, Mehrdad Sabetzadeh, and
Lionel C. Briand. Model driven engineering for data protection and privacy:
Application and experience with GDPR. CoRR, abs/2007.12046, 2020.

[18] Yeting Ge and Leonardo Mendonça de Moura. Complete instantiation for quanti-
fied formulas in satisfiabiliby modulo theories. In Ahmed Bouajjani and Oded
Maler, editors, Proceedings of the 21st International Conference on Computer Aided
Verification (CAV’2009), Grenoble, France, volume 5643 of Lecture Notes in Com-
puter Science, pages 306–320. Springer, 2009.

[19] Sepideh Ghanavati, Daniel Amyot, and Liam Peyton. Towards a framework for
tracking legal compliance in healthcare. In John Krogstie, Andreas L. Opdahl, and
Guttorm Sindre, editors, Advanced Information Systems Engineering, 19th Interna-
tional Conference, CAiSE 2007, Trondheim, Norway, June 11-15, 2007, Proceedings,
volume 4495 of Lecture Notes in Computer Science, pages 218–232. Springer, 2007.
[20] Sylvain Hallé and Roger Villemaire. Runtime enforcement of web service message

contracts with data. IEEE Trans. Serv. Comput., 5(2):192–206, 2012.

[21] Ian M. Hodkinson. Loosely guarded fragment of first-order logic has the finite

model property. Stud Logica, 70(2):205–240, 2002.

[22] Shareeful Islam, Haralambos Mouratidis, and Stefan Wagner. Towards a frame-
work to elicit and manage security and privacy requirements from laws and
regulations. In Roel J. Wieringa and Anne Persson, editors, Proceedings of the
16th International Conference on Requirements Engineering: Foundation for Soft-
ware Quality (REFSQ’2010), Essen, Germany, volume 6182 of LNCS, pages 255–261.
Springer, 2010.

[23] Daniel Jackson. Alloy: a lightweight object modelling notation. ACM Trans.

Softw. Eng. Methodol., 11(2):256–290, 2002.

[24] Legislative Assembly of Ontario. Personal health information protection act

(PHIPA), 2004.
https://www.ontario.ca/laws/statute/04p03.

[25] Jianwen Li, Geguang Pu, Lijun Zhang, Moshe Y. Vardi, and Jifeng He. Accelerating
LTL satisfiability checking by SAT solvers. J. Log. Comput., 28(6):1011–1030,
2018.

[26] Jianwen Li, Geguang Pu, Yueling Zhang, Moshe Y. Vardi, and Kristin Y. Rozier.
Sat-based explicit ltlf satisfiability checking. Artif. Intell., 289:103369, 2020.
[27] Jianwen Li, Kristin Y. Rozier, Geguang Pu, Yueling Zhang, and Moshe Y. Vardi.
Sat-based explicit ltlf satisfiability checking. In The Thirty-Third AAAI Confer-
ence on Artificial Intelligence, AAAI 2019, The Thirty-First Innovative Applications
of Artificial Intelligence Conference, IAAI 2019, The Ninth AAAI Symposium on
Educational Advances in Artificial Intelligence, EAAI 2019, Honolulu, Hawaii, USA,
January 27 - February 1, 2019, pages 2946–2953. AAAI Press, 2019.

[28] Jianwen Li, Moshe Y. Vardi, and Kristin Y. Rozier. Satisfiability checking for
In Isil Dillig and Serdar Tasiran, editors, Computer Aided
mission-time LTL.
Verification - 31st International Conference, CAV 2019, New York City, NY, USA,
July 15-18, 2019, Proceedings, Part II, volume 11562 of Lecture Notes in Computer
Science, pages 3–22. Springer, 2019.

[29] Jianwen Li, Lijun Zhang, Geguang Pu, Moshe Y. Vardi, and Jifeng He. LTL
satisfiability checking revisited. In Proceedings of the 20th International Symposium
on Temporal Representation and Reasoning, Pensacola, FL, USA, 2013, pages 91–98.
IEEE Computer Society, 2013.

[30] Cristian Mattarei, Alessandro Cimatti, Marco Gario, Stefano Tonetta, and Kristin Y.
Rozier. Comparing different functional allocations in automated air traffic control
design. In Roope Kaivola and Thomas Wahl, editors, Formal Methods in Computer-
Aided Design (FMCAD’2015), Austin, Texas, USA, pages 112–119. IEEE, 2015.
[31] Nina Narodytska and Fahiem Bacchus. Maximum satisfiability using core-guided
maxsat resolution. In Carla E. Brodley and Peter Stone, editors, Proceedings of
the 28th International Conference on Artificial Intelligence (AAAI’14), Québec City,
Canada, pages 2717–2723. AAAI Press, 2014.

[32] Christos H. Papadimitriou. On the complexity of integer programming. J. ACM,

28(4):765–768, 1981.

[33] Emil L. Post. Recursive unsolvability of a problem of thue. J. Symb. Log., 12(1):1–

11, 1947.

[34] Matteo Pradella, Angelo Morzenti, and Pierluigi San Pietro. Bounded satisfiability
checking of metric temporal logic specifications. ACM Trans. Softw. Eng. Methodol.,
22(3):20:1–20:54, 2013.

[35] Andrew Reynolds, Cesare Tinelli, and Leonardo Mendonça de Moura. Find-
ing conflicting instances of quantified formulas in SMT. In Formal Methods in
Computer-Aided Design (FMCAD’2014), Lausanne, Switzerland, pages 195–202.
IEEE, 2014.

[36] Andrew Reynolds, Cesare Tinelli, Amit Goel, Sava Krstic, Morgan Deters, and
Clark W. Barrett. Quantifier instantiation techniques for finite model finding in
SMT. In Maria Paola Bonacina, editor, Automated Deduction - CADE-24 - 24th
International Conference on Automated Deduction, Lake Placid, NY, USA, June
9-14, 2013. Proceedings, volume 7898 of Lecture Notes in Computer Science, pages
377–391. Springer, 2013.

[37] Kristin Y. Rozier and Moshe Y. Vardi. LTL satisfiability checking. In Dragan
Bosnacki and Stefan Edelkamp, editors, Proceedings of the 14th International
Workshop on Model Checking Software (SPIN’07), Berlin, Germany, volume 4595
of Lecture Notes in Computer Science, pages 149–167. Springer, 2007.

[38] Lijun Shan, Behrooz Sangchoolie, Peter Folkesson, Jonny Vinter, Erwin Schoitsch,
and Claire Loiseaux. A survey on the application of safety, security, and privacy
standards for dependable systems. In Proceedings of the 15th European Dependable
Computing Conference (EDCC’2019), Naples, Italy, pages 71–72. IEEE, 2019.

