2
2
0
2

p
e
S
6
2

]
E
S
.
s
c
[

2
v
2
5
0
4
0
.
9
0
2
2
:
v
i
X
r
a

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Nick Feng
fengnick@cs.toronto.edu
University of Toronto
Toronto, Ontario, Canada

Mehrdad Sabetzadeh
mehrdad@cs.uottawa.ca
University of Ottawa
Ottawa, Ontario, Canada

Lina Marsso
lina.marsso@utoronto.ca
University of Toronto
Toronto, Ontario, Canada

Marsha Chechik
chechik@cs.toronto.edu
University of Toronto
Toronto, Ontario, Canada

ABSTRACT
Legal properties involve reasoning about data values and time. Met-
ric first-order temporal logic (MFOTL) provides a rich formalism
for specifying legal properties. While MFOTL has been successfully
used for verifying legal properties over operational systems via run-
time monitoring, no solution exists for MFOTL-based verification in
early-stage system development captured by requirements. Given a
legal property and system requirements both formalized in MFOTL,
the compliance of the property can be verified on the requirements
via satisfiability checking. In this paper, we propose a practical,
sound, and complete (within a given bound) satisfiability checking
approach for MFOTL. The approach, based on satisfiability mod-
ulo theories (SMT), employs a counterexample-guided strategy to
incrementally search for a satisfying solution. We implemented
our approach in a tool called LEGOS, and evaluated it on five case
studies spanning the healthcare, business administration, banking
and aviation domains. Our results indicate that our approach can
efficiently determine whether legal properties of interest are met,
or generate counterexamples that lead to compliance violations.

KEYWORDS
Requirements Engineering, Metric First-order Temporal Logic (MFOTL),
Satisfiability Modulo Theories (SMT).

1 INTRODUCTION
Software systems, such as medical systems or banking systems,
are increasingly required to comply with laws, regulations and
policies aimed at ensuring safety, security, data protection and
privacy [22, 38]. The properties stipulated by these laws, regulations
and policies â€“ which we refer to as legal properties (LP) hereafter â€“
typically involve reasoning about actions, ordering and time. As an
example, consider the following LP, ğ‘ƒ1, derived from a health-data
regulation (s. 11, PHIPA [24]): "If personal health information is
not accurate or not up-to-date, it should not be accessed". In this
property, the accuracy and the freshness of the data depend on how
and when the data was collected and updated before being accessed.
More precisely, this property constrains the data action access to
have accurate and up-to-date data values, which further constrains
the order and time of access with respect to other data actions.

System compliance with LPs can be checked on the system de-
sign or on an operational model of a system implementation. In this

paper, we focus on the early stage, where one can check whether
a formalization of the system requirements satisfies an LP. The
formalization can be done using a descriptive formalism like tem-
poral logic, instead of using an operational one, based on transition
systems [28, 37]. For instance, the requirement (req0) of a data
collection system: "no data can be accessed prior to 15 days after
the data has been collected" needs to be formalized for verifying
compliance of ğ‘ƒ1. It is important to formalize the data and time
constraints of both the system requirements and LPs, such as the
ones of ğ‘ƒ1 and req0.

Metric first-order temporal logic (MFOTL) enables the specifica-
tion of data and time constraints [4] and has an expressive formal-
ism for capturing LPs and the related system requirements that
constrain data and time [1]. Existing work on MFOTL verification
has focused primarily on detecting violations at run-time through
monitoring [1], with MFOTL formulas being checked on execution
logs. There is an unsatisfied need on determining the satisfiability
of MFOTL specifications, i.e., looking for legal-property violations
possible in MFOTL specification, which is important for designing
and debugging MFOTL requirements to satisfy legal properties.

MFOTL satisfiability checking is generally undecidable since
MFOTL is an extension of first-order logic (FOL). Restrictions are
thus necessary for making the problem decidable. In this paper,
we restrict ourselves to safety properties. While we are not aware
of non-safety LP properties, it is conceivable that they may exist.
For safety properties, LP violations are finite sequences of data
actions, captured via a finite-length counterexample. For example,
a possible violation of ğ‘ƒ1 is a sequence consisting of storing a value
ğ‘£ in a variable ğ‘‘, updating ğ‘‘â€™s value to ğ‘£ â€², then reading ğ‘‘ again and
not obtaining ğ‘£ â€². Since we are interested in finite counterexamples,
bounded verification is a natural strategy to pursue for achieving
decidability. SAT solvers have been previously used for bounded
satisfiability checking of metric temporal logic (MTL) [28, 37]. How-
ever, MTL cannot effectively capture quantified data constraints
(e.g., "Every used data must be up-to-date.") in LPs, hence the so-
lution is not applicable directly. As an extension to MTL, MFOTL
can effectively capture data constraints used in LP. Yet, to the best
of our knowledge, there has not been any prior work on bounded
MFOTL satisfiability checking.

To establish a bound in bounded verification, researchers pre-
dominantly relied on bounding the size of the universe, e.g., every

 
 
 
 
 
 
Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

data type has a bounded domain in Alloy [23]. In our work, bound-
ing the universe would be too restrictive because LPs routinely refer
to variables with large ranges, e.g., timed actions spanning several
years. Instead, we bound the number of data actions in a run, which
bounds the number of actions in the counterexample.

Equipped with the proposed notion of a bound, we develop an
incremental approach (IBSC) for bounded satisfiability checking of
MFOTL. We first translate the MFOTL property and requirements
into FOL formulas with quantifiers over data actions. We then in-
crementally ground the FOL constraints to eliminate the quantifiers
by considering an increasing number of data actions. Subsequently,
we check the satisfiability of the resulting constraints using SMT
solver Z3 [10]. Specifically, we make the following contributions:
(1) we propose a translation of MFOTL formulas to FOL; (2) we
provide a novel bounded satisfiability checking solution for the
translated FOL formulas with incremental and counter-example
guided over/ under-approximation. We implemented our approach
IBSC in a tool called LEGOS, and empirically evaluate it on five case
studies with a total of 24 properties showing that it can effectively
and efficiently find LP violations or prove satisfiability.

The rest of this paper is organized as follows. Sec. 2 provides
background and establishes our notation. Sec. 3 defines the bounded
satisfiability checking (BSC) problem. Sec. 4 provides an overview
of our solution and the translation of MFOTL to FOL. Sec. 5 presents
our solution, the algorithm and its proof of correctness and termi-
nation. Sec. 6 reports on the experiments we have performed to
validate our bounded satisfiability checking solution for MFOTL .
Sec. 7 discusses related work. Sec. 8 concludes the paper.

2 PRELIMINARIES
In this section, we introduce the necessary background on metric
first order temporal logic (MFOTL).

Syntax. We begin with the syntax of MFOTL [4].

Definition 1. Let I be a non-empty interval over N. An interval
ğ¼ âˆˆ I can be expressed as [b, bâ€™) where ğ‘ âˆˆ N and ğ‘ â€² âˆˆ N âˆª âˆ. A
signature ğ‘† is a tuple (ğ¶, ğ‘…, ğœ„), where ğ¶ is a set of constant and ğ‘… is a
finite set predicate symbols, respectively. Without loss of generality, we
assume all constants are from the integer domain I where the theory
of linear integer arithmetic (LIA) holds. The function ğœ„ : ğ‘… â†’ N
associates each predicate symbol ğ‘Ÿ âˆˆ ğ‘… with an arity ğœ„ (ğ‘Ÿ ) âˆˆ N. Let ğ‘‰
be a countable infinite set of variables from domain I and a term ğ‘¡ is
defined inductively as ğ‘¡ : ğ‘ | ğ‘£ | ğ‘¡ + ğ‘¡ | ğ‘ Ã— ğ‘¡. We denote Â¯ğ‘¡ as a vector of
terms and Â¯ğ‘¡ ğ‘˜
ğ‘¥ as the vector that contains ğ‘¥ at index ğ‘˜. The syntax of
MFOTL formulas is defined as follows:

(1) âŠ¤ and âŠ¥, representing values â€œtrueâ€ and â€œfalseâ€;
(2) ğ‘¡ = ğ‘¡ â€² and ğ‘¡ > ğ‘¡ â€², for term ğ‘¡ and ğ‘¡ â€²
(3) ğ‘Ÿ (ğ‘¡1...ğ‘¡ğœ„ğ‘Ÿ ) for ğ‘Ÿ âˆˆ ğ‘… and ğ‘¡1...ğ‘¡ğœ„ are terms.
(4) ğœ™ âˆ§ ğœ“ , Â¬ğœ™ for MFOTL formulas ğœ™ and ğœ“ ;
(5) âˆƒğ‘¥ Â· (ğ‘Ÿ (Â¯ğ‘¡ ğ‘˜

ğ‘¥ ) âˆ§ ğœ™) for MFOTL formula ğœ™, relation symbol ğ‘Ÿ âˆˆ ğ‘…,

variable ğ‘¥ âˆˆ ğ‘‰ and a vector of terms Â¯ğ‘¡ğ‘–
ğ¼ ğœ™,

(6) ğœ™ Uğ¼ ğœ“ , ğœ™ Sğ¼ ğœ“ ,
an interval ğ¼ âˆˆ I.
(cid:32)

(cid:35)

ğ‘¥ such that ğ‘¥ = Â¯ğ‘¡ğ‘–

ğ‘¥ [ğ‘–]

ğ¼ ğœ™ for MFOTL formulas ğœ™ and ğœ“ , and

ğ¼ and

The temporal operators Uğ¼ , Sğ¼ ,

Â¯ğ‘¡, ğ‘Ÿ (Â¯ğ‘¡) holds and ğ‘¥ appears in Â¯ğ‘¡). Similarly, universal quantifica-
tion must be guarded as âˆ€ğ‘¥ Â· (ğ‘Ÿ (Â¯ğ‘¡) â‡’ ğœ™) where ğ‘¥ âˆˆ Â¯ğ‘¡. Under the
restricted quantification, âˆƒğ‘¥ Â· Â¬ğ‘Ÿ (ğ‘¥) (and âˆ€ğ‘¥ Â· ğ‘Ÿ (ğ‘¥)) are not allowed.
ğ¼ require the satisfac-
tion of the formula within the time interval given by ğ¼ . We write
[ğ‘, ) as a shorthand for [ğ‘, âˆ), if ğ¼ is omitted, then the interval is
assumed to be [0, âˆ). Other classical unary temporal operators
â™¢ğ¼ (i.e., eventually), â–¡ğ¼ (i.e., always), and â™¦ğ¼ (i.e., once) are defined
as follows: â™¢ğ¼ ğœ™ = âŠ¤ Uğ¼ ğœ™, â–¡ğ¼ ğœ™ = Â¬â™¢ğ¼ Â¬ğœ™, and â™¦ğ¼ ğœ™ = âŠ¤ Sğ¼ ğœ™.
Other common logical operator such as âˆ¨ (disjunction) and âˆ€ (uni-
versal quantification) are expressed through negation of âˆ§ and âˆƒ,
respectively.

(cid:32)

(cid:35)

Example 1. Suppose a data collection centre (DCC) collects and
accesses personal data information with three requirements: ğ‘Ÿğ‘’ğ‘0
stating that no data is allowed to be accessed before being having
been collected for 15 days (360 hours); ğ‘Ÿğ‘’ğ‘1: data can only be up-
dated after having been collected or last updated for more than a
week (168 hours); and ğ‘Ÿğ‘’ğ‘2: data can only be accessed if has been
collected or updated within a week (168 hours). The signature ğ‘†ğ‘‘ğ‘ğ‘¡ğ‘
for DCC contains three binary relations (ğ‘…ğ‘‘ğ‘ğ‘¡ğ‘): Collect, Update,
and Access, such that Collect(ğ‘‘, ğ‘£), Update(ğ‘‘, ğ‘£) and Access(ğ‘‘, ğ‘£)
hold at a given time point if and only if data at id ğ‘‘ is collected,
updated, and accessed with value ğ‘£ at this time point, respectively.
The MFOTL formulas for ğ‘ƒ1, ğ‘Ÿğ‘’ğ‘0, ğ‘Ÿğ‘’ğ‘1 and ğ‘Ÿğ‘’ğ‘2 are shown in
Fig. 1. For instance, the formula ğ‘Ÿğ‘’ğ‘0 specifies that if a data value
stored at id ğ‘‘ is accessed, then some data must have been collected
and stored at id ğ‘‘ before, and the collection must have occurred
prior to 360 hours ago (â™¦[360,) ]).

Semantics. A first-order (FO) structure ğ· over the signature ğ‘† =
(ğ¶, ğ‘…, ğœ„) comprises a domain |ğ· | â‰  âˆ… and an interpretation for
ğ‘ğ· âˆˆ |ğ· | and ğ‘Ÿ ğ· âŠ† |ğ· |ğœ„ (ğ‘Ÿ ) for each ğ‘ âˆˆ ğ¶ and ğ‘Ÿ âˆˆ ğ‘…. The semantics
of MFOTL formulas is defined over a sequence of FO structures
Â¯ğ· = (ğ·0, ğ·1, . . .) and a sequence of natural numbers representing
time Â¯ğœ = (ğœ0, ğœ1, . . .), where (a) Â¯ğœ is a monotonically increasing
sequence; (b) |ğ·ğ‘– | = |ğ·ğ‘–+1| for all ğ‘– > 0 (all ğ·ğ‘– have a fixed domain);
and (c) each constant symbol ğ‘ âˆˆ ğ¶ has the same interpretation
across Â¯ğ· (i.e., ğ‘ğ·ğ‘– = ğ‘ğ·ğ‘–+1 )

Property (a) ensures that time never decreases as the sequence
progresses; and (b) ensures that the domain is fixed. Â¯ğ· is similar to
timed words in metric time logic (MTL), but instead of associating a
set of propositions to each time point, MFOTL uses a structure ğ· to
interpret the symbols in the signature ğ‘†. Intuitively, the semantics
of MFOTL is defined over a trace of timed first-order structures
ğœ = ( Â¯ğ·, Â¯ğœ), where every structure ğ·ğ‘– âˆˆ Â¯ğ· contains a set of holding
relations ğ‘Ÿ ğ·ğ‘– , and these relations occur at a time specified by ğœğ‘– âˆˆ Â¯ğœ.
Example 2. Consider the signature ğ‘†ğ‘‘ğ‘ğ‘¡ğ‘ in the DCC example. Let
ğœ1 = 0 and ğœ2 = 361, and let ğ·1 and ğ·2 be two first order structures
with ğ‘Ÿ ğ·1 = Collect(0, 0) and ğ‘Ÿ ğ·2 = Access(0, 0), respectively. The
trace ğœ1 = ([ğ·1; ğ·2], [ğœ1; ğœ2]) is a valid trace shown in Fig. 2 and
representing two timed relations: (1) data value 0 collected and
stored at id 0 at hour 0 and (2) data value 0 is read by accessing id 0
at hour 361.

We considered a restricted form of quantification (syntax rule 5)
similar to guarded quantification [20, 21]. Every existentially quan-
tified variable ğ‘¥ must be guarded by some relation ğ‘Ÿ (i.e., for some

A valuation function ğ‘£ : ğ‘‰ â†’ | Â¯ğ· | maps a set of variables ğ‘‰ to
their interpretations in the domain | Â¯ğ· |. For vectors Â¯ğ‘¥ = (ğ‘¥1, . . . , ğ‘¥ğ‘›)
and Â¯ğ‘‘ = (ğ‘‘1, ..., ğ‘‘ğ‘›) âˆˆ | Â¯ğ· |ğ‘›, the update operation ğ‘£ [Â¯ğ‘¥ â†’ Â¯ğ‘‘] produces

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Report, September 8th, 2022,

ğ‘ƒ1 = â–¡ âˆ€ğ‘‘, ğ‘£, ğ‘£ â€²(Access(ğ‘‘, ğ‘£)âˆ§ ğ‘£ â€² â‰  ğ‘£) =â‡’ Â¬Update(ğ‘‘, ğ‘£ â€²) S (Update(ğ‘‘, ğ‘£) âˆ¨ Collect(ğ‘‘, ğ‘£)))
If a personal health information is not accurate or not up-to-date, it should not be accessed.
Â¬ğ‘ƒ1 = â™¢ âˆƒğ‘‘, ğ‘£, ğ‘£ â€²(Access(ğ‘‘, ğ‘£) =â‡’ (ğ‘£ â€² â‰  ğ‘£ âˆ§ Â¬Update(ğ‘‘, ğ‘£) S (Update(ğ‘‘, ğ‘£ â€²) âˆ¨ Collect(ğ‘‘, ğ‘£ â€²))))
ğ‘Ÿğ‘’ğ‘0 = â–¡ âˆ€ğ‘‘, ğ‘£ (Access(ğ‘‘, ğ‘£) =â‡’ â™¦[360,) âˆƒğ‘£ â€² Â· Collect(d, vâ€™))
No data is allowed to be accessed before having been collected for at least 15 days (360 hours).
ğ‘Ÿğ‘’ğ‘1 = â–¡ âˆ€ğ‘‘, ğ‘£ (Update(ğ‘‘, ğ‘£) =â‡’ Â¬(âˆƒğ‘£ â€²â€² Â· ((Update(ğ‘‘, ğ‘£ â€²â€²) âˆ§ ğ‘£ â€²â€² â‰  ğ‘£) âˆ¨ Collect(d, vâ€)) âˆ¨ â™¦[1,168] âˆƒğ‘£ â€² Â· (Collect(ğ‘‘, ğ‘£ â€²) âˆ¨ Update(ğ‘‘, ğ‘£ â€²))))
Data can only be updated after having been collected or last updated for more than a week (168 hours).
ğ‘Ÿğ‘’ğ‘2 = â–¡ âˆ€ğ‘‘, ğ‘£ (Access(ğ‘‘, ğ‘£) =â‡’ â™¦[0,168] Collect(ğ‘‘, ğ‘£) âˆ¨ Update(ğ‘‘, ğ‘£))
Data can only be accessed if has been collected or updated within a week (168 hours).
ğ‘Ÿğ‘’ğ‘3 = â–¡ âˆ€ğ‘‘, ğ‘£ (Collect(ğ‘‘, ğ‘£) =â‡’ Â¬(âˆƒğ‘£ â€²â€² Â· (Collect(ğ‘‘, ğ‘£ â€²â€²) âˆ§ ğ‘£ â‰  ğ‘£ â€²â€²) âˆ¨ â™¦[1,) âˆƒğ‘£ â€² Â· Collect(ğ‘‘, ğ‘£ â€²))) Data cannot be re-collected.

Figure 1: Several requirements and the legal property ğ‘ƒ 1 of DCC, with the signature ğ‘†ğ‘‘ğ‘ğ‘¡ğ‘ = ( âˆ…, {Collect, Update, Access}, ğœ„ğ‘‘ğ‘ğ‘¡ğ‘), where
ğœ„ğ‘‘ğ‘ğ‘¡ğ‘ (Collect) = ğœ„ğ‘‘ğ‘ğ‘¡ğ‘ (Update) = ğœ„ğ‘‘ğ‘ğ‘¡ğ‘ (Access) = 2.

ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡ (0, 0)
ğœ1

ğœ0 = 0
ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡ (1, 0)
ğœ2

ğœ0 = 0
ğ‘ˆ ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1 (0, 0)
ğœ3

ğœ0 = 0
ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2 (0, 1),
ğ‘ˆ ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1 (0, 0)
ğœ4

ğœ0 = 0
ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2 (0, 1)
ğœ5

data actions
time

ğ´ğ‘ğ‘ğ‘’ğ‘ ğ‘  (1, 0)

ğœ2 = 361

ğ´ğ‘ğ‘ğ‘’ğ‘ ğ‘  (0, 0)

ğœ1 = 361
ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡ (1, 15)

ğœ1 = 20
ğ´ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1 (0, 1)

ğœ1 = 1

ğ´ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1 (0, 1)

ğœ1 = 2

ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 (0, 0) ğ´ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1 (0, 1)

ğœ0 = 0
Figure 2: Several traces from the DCC example.

ğœ1 = 1

ğœ2 = 2

a new valuation function ğ‘£ â€² s.t. ğ‘£ â€²(ğ‘¥ğ‘– ) = ğ‘‘ğ‘– for 1 â‰¤ ğ‘– â‰¤ ğ‘›, and
ğ‘£ (ğ‘¥ â€²) = ğ‘£ â€²(ğ‘¥ â€²) for every ğ‘¥ â€² âˆ‰ Â¯ğ‘¥. For any constant ğ‘, ğ‘£ (ğ‘) = ğ‘.

Definition 2. Let Â¯ğ· be a sequence of FO structures over signature
ğ‘† = (ğ¶, ğ‘…, ğœ„) and Â¯ğœ be a sequence of natural numbers. Let ğœ™ be an
MFOTL formula over ğ‘†, ğ‘£ be a valuation function and ğ‘– âˆˆ N. The
relation ( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğœ™ is defined as follows:

ğ‘¥ ) âˆ§ ğœ™)

( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğ‘¡ = ğ‘¡ â€²
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğ‘¡ > ğ‘¡ â€²
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğ‘Ÿ (ğ‘¡1, .., ğ‘¡ğ‘– (ğ‘Ÿ ) )
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= Â¬ğœ™
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğœ™ âˆ§ ğœ“
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= âˆƒğ‘¥ Â· (ğ‘Ÿ (Â¯ğ‘¡ğ‘–
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |=
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |=
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğœ™ Uğ¼ ğœ“

iff ğ‘£ (ğ‘¡) = ğ‘£ (ğ‘¡ â€²)
iff ğ‘£ (ğ‘¡) > ğ‘£ (ğ‘¡ â€²)
iff ğ‘Ÿ (ğ‘£ (ğ‘¡1), .., ğ‘£ (ğ‘¡ğ‘– (ğ‘Ÿ )) ) âˆˆ ğ‘Ÿ ğ·ğ‘–
iff ( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) Ì¸|= ğœ™
iff ( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğœ™ and ( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğœ“
iff ( Â¯ğ·, Â¯ğœ, ğ‘£ [ğ‘¥ â†’ ğ‘‘], ğ‘–) |= (ğ‘Ÿ (Â¯ğ‘¡ğ‘–
iff ( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘– + 1) |= ğœ™ and ğœğ‘–+1 âˆ’ ğœğ‘– âˆˆ ğ¼
iff ğ‘– â‰¥ 1 and ( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘– âˆ’ 1) |= ğœ™ and ğœğ‘– âˆ’ ğœğ‘–âˆ’1 âˆˆ ğ¼
iff exists ğ‘— â‰¥ ğ‘– and ( Â¯ğ·, Â¯ğœ, ğ‘—, ğ‘£) |= ğœ“ and ğœ ğ‘— âˆ’ ğœğ‘– âˆˆ ğ¼
and for all ğ‘˜ âˆˆ N ğ‘– â‰¤ ğ‘˜ < ğ‘— â‡’ ( Â¯ğ·, Â¯ğœ, ğ‘˜, ğ‘£) |= ğœ™
iff exists ğ‘— â‰¤ ğ‘– and ( Â¯ğ·, Â¯ğœ, ğ‘—, ğ‘£) |= ğœ“ and ğœğ‘– âˆ’ ğœ ğ‘— âˆˆ ğ¼
and for all ğ‘˜ âˆˆ N ğ‘– â‰¥ ğ‘˜ > ğ‘— â‡’ ( Â¯ğ·, Â¯ğœ, ğ‘˜, ğ‘£) |= ğœ™
ğ¼ , Uğ¼ and Sğ¼ are augmented with an interval
ğ¼ âˆˆ I which defines the satisfaction of the formula within a time
range specified by ğ¼ relative to the current time at step ğ‘–, i.e., ğœğ‘– .

( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) |= ğœ™ Sğ¼ ğœ“

The operators

ğ¼ ğœ™
ğ¼ ğœ™

(cid:32)
(cid:35)

(cid:32)

(cid:35)

ğ¼ ,

ğ‘¥ )) âˆ§ ğœ™ for some ğ‘‘ âˆˆ | Â¯ğ· |

Example 3. Consider the DCC example, the MFOTL formula ğ‘Ÿğ‘’ğ‘0,
and the trace ğœ1 = (( Â¯ğ· = [ğ·1; ğ·2]), (Â¯ğœ = [ğœ1; ğœ2])) (in Fig. 2). For
a valuation function ğ‘£ = âˆ…, we have ( Â¯ğ·, Â¯ğœ, ğ‘£, 0) |= ğ‘Ÿğ‘’ğ‘0 because data
stored at id 0 is accessed at hour 361 (Access(0, 0) âˆˆ ğ‘Ÿ ğ·2 âˆ§ğœ2 = 361),
and data value 0 was collected and stored at id 0 361 hours ago
(Collect(0, 0) âˆˆ ğ‘Ÿ ğ·1 and ğœ2 âˆ’ ğœ1 âˆˆ [360, )).
Definition 3 (MFOTL Satisfiability). An MFOTL formula ğœ™ is
satisfiable if there exists a sequence of FO structures Â¯ğ· and natural

numbers Â¯ğœ, and a valuation function ğ‘£ such that ( Â¯ğ·, Â¯ğœ, ğ‘£, 0) |= ğœ™. ğœ™ is
unsatisfiable otherwise.

In the DCC example, the MFOTL formula ğ‘Ÿğ‘’ğ‘0 is
Example 4.
satisfiable because ( Â¯ğ·, Â¯ğœ, ğ‘£, 0) |= ğ‘Ÿğ‘’ğ‘0 (where ğœ1 = ( Â¯ğ·, Â¯ğœ) in Fig. 2).
Let ğ‘Ÿğ‘’ğ‘â€²
0 = â™¢[0,359] âˆƒğ‘£ Â· (Access(0, ğ‘£)) be another MFOTL formula.
ğ‘Ÿğ‘’ğ‘â€²
0 âˆ§ ğ‘Ÿğ‘’ğ‘0 is unsatisfiable because if data stored at id 0 is accessed
between 0 and 359 hours, then it is impossible to collect the data at
least 360 hours prior to its access.

3 BOUNDED SATISFIABILITY CHECKING
The satisfiability of MFOTL properties is generally undecidable
since MFOTL is expressive enough for describing the blank tape
problem [33] (which has been shown to be undecidable). Despite the
undecidability result, we can derive a bounded version of the prob-
lem, bounded satisfiability checking (BSC), for which a sound and
complete decision procedure exists. When facing a hard instance
for the satisfiability checking problem, the solution to BSC provides
bounded guarantees (i.e., exists a solution or there is no solution
within the given bound). In this section, we first define satisfiability
checking and then the BSC problems of MFOTL formulas.

Satisfiability checking [34] is a verification technique that extends
model checking by replacing a state transition system with a set of
temporal logic formulas. In the following, we define satisfiability
checking of MFOTL formulas.

Definition 4 (Satisfiability Checking of MFOTL Formulas).
Let ğœ™ be an MFOTL formula over a signature ğ‘† = (ğ¶, ğ‘…, ğœ„), and let
ğ‘Ÿğ‘’ğ‘ğ‘  be a set of MFOTL requirements over ğ‘†. Reqs complies ğœ™ (denoted
as Reqs â‡’ ğœ™) iff (cid:211)ğœ“ âˆˆğ‘€ ğœ“ âˆ§ Â¬ğœ™ is unsatisfiable. We call a solution
to (cid:211)ğœ“ âˆˆğ‘€ ğœ“ âˆ§ Â¬ğœ™ (if one exists) a counterexample to Reqs â‡’ ğœ™.
Example 5. Consider our DCC system requirements and the
privacy data property ğ‘ƒ1 stating that if personal health informa-
tion is not accurate or not up-to-date, it should not be accessed
(see Fig. 1). ğ‘ƒ1 is not respected by the set of DCC requirements
{ğ‘Ÿğ‘’ğ‘0, ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘2} because Â¬ğ‘ƒ1 âˆ§ ğ‘Ÿğ‘’ğ‘0 âˆ§ ğ‘Ÿğ‘’ğ‘1 âˆ§ ğ‘Ÿğ‘’ğ‘2 is satisfiable.
The counterexample ğœ2 (shown in Fig. 2) indicates that data can be
re-collected, and the re-collection does not have the same time re-
striction as the updates. If a fourth policy requirement ğ‘Ÿğ‘’ğ‘3 (Fig. 1)
is added to prohibit re-collection of collected data, then property
ğ‘ƒ1 would be respected ({ğ‘Ÿğ‘’ğ‘0, ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘2, ğ‘Ÿğ‘’ğ‘3} â‡’ ğ‘ƒ1).
Definition 5 (Finite trace and bounded trace). The volume of
a trace ğœ = ( Â¯ğ·, Â¯ğœ, ğ‘£) is the total number of relations that hold across
Â¯ğ·, denoted as ğ‘£ğ‘œğ‘™ (ğœ) = (cid:205)ğ‘Ÿ âˆˆğ‘… (cid:205)ğ·ğ‘– âˆˆ Â¯ğ· (|ğ‘Ÿ ğ·ğ‘– |). The trace ğœ is finite if

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

ğ‘£ğ‘œğ‘™ (ğœ) is finite. The trace is bounded by volume if there exists an
upper bound ğ‘ğ‘£ğ‘œğ‘™ âˆˆ N such that ğ‘£ğ‘œğ‘™ (ğœ) â‰¤ ğ‘ğ‘£ğ‘œğ‘™ . In the rest of paper,
we refer to volume-bounded traces as bounded traces.

Example 6. The volume of trace ğœ4 in Fig. 2, ğ‘£ğ‘œğ‘™ (ğœ4) = 3 since
there are three relations: Collect(1, 15), Update(1, 0), and Access(1,
15). Note that the volume and the length for this trace are different.
The length, | Â¯ğ· |, corresponds to the number of time points while
the volume is the total number of holding relations across all time
points. More than one relation can hold for a single time point.

Definition 6 (Bounded satisfiability checking of MFOTL prop-
erties). Let ğœ™ be an MFOTL property, Reqs be a set of MFOTL re-
quirements, and ğ‘ğ‘£ğ‘œğ‘™ be a natural number. The bounded satisfiability
checking problem determines the existence of a counterexample ğœ to
Reqs â‡’ ğœ™ such that ğ‘£ğ‘œğ‘™ (ğœ) â‰¤ ğ‘ğ‘£ğ‘œğ‘™ .

4 CHECKING BOUNDED SATISFIABILITY
In this section, we present an overview of the bounded satisfiability
checking (BSC) process that translates MFOTL formula into first-
order logic (FOL) formulas, and looks for a satisfying solution for
the FOL formulas. Then, we provide the translation of MFOTL
formulas to FOL and discuss the complexity of the process.

4.1 Overview of BSC for MFOTL Formulas
We aim to address the bounded satisfiability checking problem
(Def. 6), looking for a satisfying run ğœ within a given volume bound
ğ‘ğ‘£ğ‘œğ‘™ that limits the number of relations in ğœ. First, we translate
the MFOTL formulas to FOL formulas, where each relation in a
trace is mapped to a relational object in the FO domain. The con-
sidered constraints in the formulas include the ones of the system
requirements and the legal property, and optional data constraints
specifying the data domain of the system. Second, we search for a
satisfying solution to the FOL constraints; an SMT solver is used
here to determine the satisfiability of the FOL constraints and the
data domain constraints. The answer from the SMT solver is ana-
lyzed to return an answer to the satisfiability checking problem (a
counterexample ğœ, or "bounded-UNSAT").

4.2 Translation of MFOTL to First-Order Logic
The translation is a two-step procedure: (1) defining the FOL search
domain and (2) translating MFOTL formulas to FOL formulas. This
translation enables to search for a solution of the bounded satisfia-
bility problem in the FOL domain.

4.2.1 Domain of the Search Space. Any volume-bounded trace
ğœ = ( Â¯ğ·, Â¯ğœ, ğ‘£) (bounded by ğ‘ğ‘£ğ‘œğ‘™ ) can be mapped to a single FO
structure (ğ·ğ´ğ‘ˆ , ğ‘£ â€²) by associating the time information in ğœğ‘– to
every relation in ğ·ğ‘– for every (ğ·ğ‘–, ğœğ‘– ) in the trace. More specifically,
let ğ·ğ´ğ‘ˆ be the domain defined over signature ğ‘† = (ğ¶, ğ‘…, ğœ„) (the
same signature as Â¯ğ·). ğ·ğ´ğ‘ˆ contains all constants ğ‘ âˆˆ ğ¶ and ğ‘ğ‘£ğ‘œğ‘™
relational objects (denoted ğ‘œ). Each ğ‘œ has variables ğ‘›ğ‘ğ‘šğ‘’ and ğ‘¡ğ‘–ğ‘šğ‘’,
and a vector of argument variables (ğ‘ğ‘Ÿğ‘”1, . . . , ğ‘ğ‘Ÿğ‘”ğœ„ (ğ‘›ğ‘ğ‘šğ‘’) ) associated
with it. Each ğ‘œ represents an occurrence of a relation of ğ‘œ.ğ‘›ğ‘ğ‘šğ‘’
at time ğ‘œ.ğ‘¡ğ‘–ğ‘šğ‘’. The following relationship holds for (ğ·ğ´ğ‘ˆ , ğ‘£ â€²) and
( Â¯ğ·, Â¯ğœ, ğ‘£): âˆ€ğ‘Ÿ âˆˆ ğ‘…, ğ‘Ÿ (ğ‘¡1, ğ‘¡2...ğ‘¡ğœ„ (ğ‘Ÿ ) ) âˆˆ ğ‘Ÿ ğ·ğ‘– ,

iff exists a relational object ğ‘œ (ğ‘ğ‘Ÿğ‘”1, ğ‘ğ‘Ÿğ‘”2....ğ‘ğ‘Ÿğ‘”ğœ„ (ğ‘Ÿ ) ) âˆˆ ğ·ğ´ğ‘ˆ s.t.
ğ‘£ (ğ‘¡1) = ğ‘£ â€²(ğ‘ğ‘Ÿğ‘”1), ğ‘£ (ğ‘¡2) = ğ‘£ â€²(ğ‘ğ‘Ÿğ‘”2), ..., ğ‘£ (ğ‘¡ğœ„ (ğ‘Ÿ ) ) = ğ‘£ â€²(ğ‘ğ‘Ÿğ‘”ğœ„ (ğ‘Ÿ ) )
âˆ§ğœğ‘– = ğ‘£ â€²(ğ‘œ.ğ‘¡ğ‘–ğ‘šğ‘’) âˆ§ ğ‘£ â€²(ğ‘œ.ğ‘›ğ‘ğ‘šğ‘’) = ğ‘Ÿ .

Intuitively, each holding relation in the trace ğœ is mapped to a re-
lational object where the holding time of the relation ğœğ‘– is explicitly
associated with the relational objectâ€™s ğ‘¡ğ‘–ğ‘šğ‘’. Therefore, if a relation
does not hold at a given time, then there is no relational object
which the relation can be mapped to. The name of the relation
ğ‘œ.ğ‘›ğ‘ğ‘šğ‘’ defines the class ğ¶ğ‘™ğ‘  of relational objects in ğ·ğ´ğ‘ˆ . For ex-
ample, âˆ€ğ‘œ : ğ¶ğ‘™ğ‘  selects every relational object where ğ‘œ.ğ‘›ğ‘ğ‘šğ‘’ = ğ¶ğ‘™ğ‘ .
In the rest of the paper, to avoid confusion, class names and rela-
tion names are capitalized (e.g., Collect) while individual relational
object names are not (e.g., ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1).

Example 7. Consider the trace ğœ2 = ( Â¯ğ·, Â¯ğœ), where Â¯ğ· = [ğ·1; ğ·2; ğ·3]
and Â¯ğœ = [ğœ1; ğœ2; ğœ3] in Fig. 2. The first-order structure of ğœ2 is
(ğ·ğ´ğ‘ˆ , ğ‘£ â€²), where ğ·ğ´ğ‘ˆ contains three relational objects. Two of
these objects are from the class ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡, and the third one is from the
class ğ´ğ‘ğ‘ğ‘’ğ‘ ğ‘ . Let ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 be the relational object corresponding to
the relation ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡(1, 0) in ğ·1 with ğœ1 = 0. We have: ğ‘£ â€²(ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.ğ‘ğ‘Ÿğ‘”1) =
1, ğ‘£ â€²(ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.ğ‘ğ‘Ÿğ‘”2) = 0 and ğ‘£ â€²(ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.ğ‘¡ğ‘–ğ‘šğ‘’) = 0.

For the FO domain ğ·ğ´ğ‘ˆ , let |ğ·ğ´ğ‘ˆ | denote the domain size, i.e.,
the number of its relational objects. Therefore, for any trace ğœ
bounded by ğ‘ğ‘£ğ‘œğ‘™ , we can map ğœ to a first order structure (ğ·ğ´ğ‘ˆ , ğ‘£ â€²)
where the domain size of |ğ·ğ´ğ‘ˆ | is also bounded by ğ‘ğ‘£ğ‘œğ‘™ . Since
MFOTL formulas specify constraints on ğœ, ğ‘£ â€² in ğ·ğ´ğ‘ˆ should satisfy
FOL formulas corresponding to these MFOTL constraints.

4.2.2 From MFOTL Formulas to FOL Formulas. Recall that
the semantics of MFOTL formulas is defined over a trace ğœ =
( Â¯ğ·, Â¯ğœ, ğ‘£, ğ‘–) at a time point ğ‘– where Â¯ğ· = [ğ·1; ğ·2; ...] is a sequence of
FO structures and Â¯ğœ = [ğœ1; ğœ2; ] is a sequence of time values. The
time value of the time point ğ‘– is given by ğœğ‘– , and if ğ‘– is not specified,
then ğ‘– = 1. The semantics of FOL formulas is defined on a single
FO structure (ğ·ğ´ğ‘ˆ , ğ‘£ â€²) where the time information is associated
with relational objects in the domain ğ·ğ´ğ‘ˆ . Therefore, the time
point ğ‘– (and its time value ğœğ‘– ) needs to be considered during the
translation from MFOTL to FOL since the same MFOTL formula at
different time points represents different constraints over the trace
ğœ. Formally, our translation function translate, abbreviated to ğ‘‡
for succinctness, translates an MFOTL formula ğœ™ into a function
ğ‘“ : ğœ â†’ ğœ™ ğ‘“ , where ğœ™ ğ‘“ is an FOL formula over relational objects.
The FOL formula ğœ™ ğ‘“ corresponding to the MFOTL formula ğœ™ at time
step ğ‘– is ğœ™ ğ‘“ = ğ‘‡ (ğœ™, ğœğ‘– ). The translation rules for ğ‘‡ are as follows:

ğ‘‡ (ğ‘¡ = ğ‘¡ â€², ğœğ‘– )
â†’ ğ‘¡ = ğ‘¡ â€²
â†’ ğ‘¡ > ğ‘¡ â€²
ğ‘‡ (ğ‘¡ > ğ‘¡ â€², ğœğ‘– )
ğ‘‡ (ğ‘Ÿ (ğ‘¡1, .., ğ‘¡ğœ„ (ğ‘Ÿ ) ), ğœğ‘– ) â†’ âˆƒğ‘œ (ğ‘ğ‘Ÿğ‘”1, .., ğ‘ğ‘Ÿğ‘”ğ‘– (ğ‘Ÿ ) ) : ğ‘Ÿ âˆ§ (cid:211)ğœ„ (ğ‘Ÿ )

ğ‘—=1 (ğ‘ğ‘Ÿğ‘”ğ‘— = ğ‘¡ ğ‘— )

âˆ§(ğœğ‘– = ğ‘œ.ğ‘¡ğ‘–ğ‘šğ‘’)

â†’ Â¬ğ‘‡ (ğœ™, ğœğ‘– )
â†’ ğ‘‡ (ğœ™, ğœğ‘– ) âˆ§ ğ‘‡ (ğœ“, ğœğ‘– )

ğ‘‡ (Â¬ğœ™, ğœğ‘– )
ğ‘‡ (ğœ™ âˆ§ ğœ“, ğœğ‘– )
ğ‘‡ (âˆƒğ‘¥ Â· ğ‘Ÿ (Â¯ğ‘¡ğ‘–
ğ¼ ğœ™, ğœğ‘– )
ğ‘‡ (
ğ‘‡ (
ğ¼ ğœ™, ğœğ‘– )
ğ‘‡ (ğœ™ Uğ¼ ğœ“, ğœğ‘– )

(cid:32)
(cid:35)

ğ‘‡ (ğœ™ Sğ¼ ğœ“, ğœğ‘– )

ğ‘¥ ) âˆ§ ğœ™, ğœğ‘– ) â†’ âˆƒğ‘œ : ğ‘Ÿ Â· ğ‘‡ ((ğ‘Ÿ (Â¯ğ‘¡ğ‘–

ğ‘¥ ) âˆ§ ğœ™) [ğ‘¥ â†’ ğ‘œ.ğ‘ğ‘Ÿğ‘”ğ‘– ], ğœğ‘– )

â†’ ğ‘‡ (ğœ™, ğœğ‘–+1) âˆ§ (ğœğ‘–+1 âˆ’ ğœğ‘– ) âˆˆ ğ¼
â†’ ğ‘‡ (ğœ™, ğœğ‘–âˆ’1) âˆ§ (ğœğ‘– âˆ’ ğœğ‘–âˆ’1) âˆˆ ğ¼
â†’ âˆƒğ‘¡ğ‘–ğ‘šğ‘’ Â· (ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥ ğœğ‘– âˆ§ (ğ‘¡ğ‘–ğ‘šğ‘’ âˆ’ ğœğ‘– ) âˆˆ ğ¼ âˆ§ ğ‘‡ (ğœ“, ğ‘¡ğ‘–ğ‘šğ‘’)
and âˆ€ğ‘¡ğ‘–ğ‘šğ‘’ â€² Â· (ğœğ‘– â‰¤ ğ‘¡ğ‘–ğ‘šğ‘’ â€² < ğ‘¡ğ‘–ğ‘šğ‘’ â‡’ ğ‘‡ (ğœ™, ğ‘¡ğ‘–ğ‘šğ‘’ â€²)))
â†’ âˆƒğ‘¡ğ‘–ğ‘šğ‘’ Â· (ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤ ğœğ‘– âˆ§ (ğœğ‘– âˆ’ ğ‘¡ğ‘–ğ‘šğ‘’) âˆˆ ğ¼ âˆ§ ğ‘‡ (ğœ“, ğ‘¡ğ‘–ğ‘šğ‘’)
and âˆ€ğ‘¡ğ‘–ğ‘šğ‘’ â€² Â· (ğœğ‘– â‰¥ ğ‘¡ğ‘–ğ‘šğ‘’ â€² > ğ‘¡ğ‘–ğ‘šğ‘’ â‡’ ğ‘‡ (ğœ™, ğ‘¡ğ‘–ğ‘šğ‘’ â€²)))

ğ‘‡ (ğœ™)

â†’ ğ‘‡ (ğœ™, ğœ1)

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Report, September 8th, 2022,

bound (Nat)

requirements (MFOTL)

property (MFOTL)

data domain con-
straints (FOL)

Translate

formulas (FOL)
+ domain

Ground

formulas
(FOL)

quantifier-free
formulas (FOL)

search

answer

query

Solve
(SMT solver)

counterexample
| bounded-UNSAT
( | UNSAT)

Figure 3: Overview of the naive and our incremental (IBSC) MFOTL bounded satisfiability checking approaches. Solid boxes and arrows are
shared between the two approaches. Blue dashed arrow is specific to the naive approach. Red dotted arrows and the additional red output in
bracket are specific to IBSC.

Proposition 1 (Quantifiers on relational objects). For a MFOTL
formula ğœ™, the FOL formula ğ‘‡ (ğœ™) only contains quantifiers exclusively
on relational objects.

Example 8. Consider a formula ğ‘’ğ‘¥ğ‘ = â–¡ âˆ€ğ‘‘ Â· (ğ´(ğ‘‘) =â‡’ â™¢[5,10] ğµ(ğ‘‘))
where ğ´ and ğµ are unary relations. The translated FOL formula

âˆ€ğ‘ : ğ´ Â· (âˆƒğ‘ : ğµ Â· ğ‘.ğ‘ğ‘Ÿğ‘”1 = ğ‘.ğ‘ğ‘Ÿğ‘”1 âˆ§ ğ‘.ğ‘¡ğ‘–ğ‘šğ‘’ + 5 â‰¤ ğ‘.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤ ğ‘.ğ‘¡ğ‘–ğ‘šğ‘’ + 10)

Given an MFOTL property ğœ™ and a set of ğ‘€ğ¹ğ‘‚ğ‘‡ ğ¿ requirements
ğ‘…ğ‘’ğ‘ğ‘ , a volume bound ğ‘ğ‘£ğ‘œğ‘™ , the BSC problem can be solved by search-
ing for a satisfying solution ğ‘£ â€² for the FOL formulağ‘‡ (ğœ™) (cid:211)ğœ“ âˆˆğ‘…ğ‘’ğ‘ğ‘  ğ‘‡ (ğœ“ )
in a domain ğ·ğ´ğ‘ˆ with at most ğ‘ğ‘£ğ‘œğ‘™ relational objects.

4.3 Checking MFOTL Satisfiability
Below, we define a naive procedure NBSC (shown in Fig. 3) for
checking satisfiability of MFOTL formulas translated into FOL. We
then discuss the complexity of this naive procedure. Even though
we do not use this naive procedure in this paper, its complexity
corresponds to the upper-bound of our proposed approach in Sec. 5.

Searching for a satisfying solution. Let ğ‘‡ (ğœ™) be an FOL formula
translated from an MFOTL formula ğœ™, and let ğ‘˜ be the maximum
quantifier nesting in ğ‘‡ (ğœ™). NBSC solves ğ‘‡ (ğœ™) via quantifier elimi-
nation. By Proposition 1, only relational objects can be quantified.
Given a bound ğ‘›, the number of relational objects in any satisfying
solution of ğ‘‡ (ğœ™) should be at most ğ‘›. Therefore, NBSC eliminates
quantifiers in ğ‘‡ (ğœ™) by assuming presence of ğ‘› relational objects
and then iterates over them. For example, the formula âˆ€ğ‘Ÿ : ğ‘… Â· ğœ“ (ğ‘Ÿ )
is converted to ğœ“ (ğ‘Ÿ1) âˆ§ ğœ“ (ğ‘Ÿ2) . . . âˆ§ ğœ“ (ğ‘Ÿğ‘›). After eliminating all
quantifiers in the formula ğ‘‡ (ğœ“ ), NBSC calls an SMT solver on the
quantifier-free formula to obtain the satisfiability result.
Complexity. The size of the quantifier-free formula is ğ‘‚ (ğ‘›ğ‘˜ ), where
ğ‘˜ is the maximum depth of quantifier nesting. Since the background
theory used in ğœ™ is restricted to LIA, the complexity of solving the
formula is NP-complete [32]. Since Translate is linear in the size
of the formula ğœ™, the complexity of our approach is dominated by
solving the translated formula which is NP-complete with respect
to the size of the formula, ğ‘›ğ‘˜ .

5 INCREMENTAL SEARCH FOR BOUNDED

COUNTEREXAMPLES

The naive BSC approach (NBSC) defined in Sec. 4.3 is inefficient
for solving the translated FOL formulas given a larger bound ğ‘›
since its quantifier elimination creates a quantifier-free formula of
size ğ‘‚ (ğ‘›ğ‘˜ ) even if satisfiability may be determined using a smaller

bound. Moreover, NBSC cannot detect unbounded unsatisfiabil-
ity, and cannot provide optimality guarantees on the volume of
counterexamples which are important for establishing the proof of
unbounded correctness and localizing faults [16], respectively. In
this section, we propose an incremental procedure, IBSC, that can
detect unbounded unsatisfiability and provide shortest counterex-
amples. An overview of IBSC is shown in Fig. 3.

IBSC maintains an under-approximation of the search domain
and the FOL constraints. It uses the search domain to ground the
FOL constraints, and an off-the-shelf SMT solver to determine sat-
isfiability of the grounded constraints and the data domain con-
straints. It analyzes the SMT result and accordingly either expands
the search domain, refines the FOL constraints, or returns an an-
swer to the satisfiability checking problem (a counterexample ğœ,
"bounded-UNSAT", or "UNSAT"). The procedure continues until an
answer is obtained or until the domain exceeds the bound ğ‘ğ‘£ğ‘œğ‘™ , in
which case a â€œbounded-UNSATâ€ answer is returned. If the bound
increases, ğœ with the minimal volume and the UNSAT value are
preserved while bounded-UNSAT may turn into ğœ or UNSAT.

In the following, we describe IBSC in more detail. We explain the
key component of IBSC, computing over and under-approximation
queries in Sec. 5.1, the algorithm itself in Sec. 5.2, and analysis of
its soundness, completeness, and the solution optimality in Sec. 5.3.

5.1 Over- and Under-Approximation
IBSC searches for a counter-example in a FO domain ğ·ğ´ğ‘ˆ whose
size is bounded by a given volume bound ğ‘ğ‘£ğ‘œğ‘™ . Instead of directly
searching inside ğ·ğ´ğ‘ˆ , IBSC starts with an under-approximated
domain ğ·ğ´ğ‘ˆ â†“ âŠ† ğ·ğ´ğ‘ˆ where every relational object in ğ·ğ´ğ‘ˆ â†“ is
in also ğ·ğ´ğ‘ˆ . With ğ·ğ´ğ‘ˆ â†“, we can create an over- and an under-
approximation query to the bounded satisfiability problem. Such
queries are used to check satisfiability of FO formulas with domain
ğ·ğ´ğ‘ˆ â†“. IBSC starts with a small domain ğ·ğ´ğ‘ˆ â†“ and gradually ex-
pands it until either SAT or UNSAT is returned, or the domain size
exceeds some limit (bounded-UNSAT).

Over-approximation. Let ğœ™ ğ‘“ be an FOL formula with quantifiers
over relational objects, and ğ·ğ´ğ‘ˆ â†“ be an FO domain of relation ob-
jects. The procedure Ground (ğº) encodes ğœ™ ğ‘“ into a quantifier-free
FOL formula ğœ™ğ‘” s.t. the unsatisfiability of ğœ™ğ‘” implies the unsatisfia-
bility of ğœ™ ğ‘“ . We call ğœ™ğ‘” an over-approximation of ğœ™ ğ‘“ .

The procedure ğº (Alg. 2) recursively traverses the AST of the
input FOL formula. To eliminate the existential quantifier in âˆƒğ‘Ÿ :
ğ¶ğ‘™ğ‘  Â· ğ‘ğ‘œğ‘‘ğ‘¦ (L:2), ğº creates a new relational object ğ‘›ğ‘’ğ‘¤ğ‘… (uncon-
strained) of class ğ¶ğ‘™ğ‘  (L: 5), and replaces ğ‘Ÿ with ğ‘›ğ‘’ğ‘¤ğ‘… in ğ‘ğ‘œğ‘‘ğ‘¦ (L:6).

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

To eliminate the universal quantifier in âˆ€ğ‘Ÿ : ğ¶ğ‘™ğ‘  Â· ğ‘ğ‘œğ‘‘ğ‘¦ (L: 8), ğº ex-
pands the quantifier into a conjunction of clauses where each clause
is ğ‘ğ‘œğ‘‘ğ‘¦ [ğ‘Ÿ â† ğ‘Ÿğ‘– ] (i.e., ğ‘Ÿ is replaced by ğ‘Ÿğ‘– in ğ‘ğ‘œğ‘‘ğ‘¦) for each relational
object ğ‘Ÿğ‘– of class ğ¶ğ‘™ğ‘  in ğ·ğ´ğ‘ˆ â†“ (L:10). Intuitively, an existentially-
quantified relational object is instantiated with a new relational
object, and an universally quantified relational object is instantiated
with every existing relational object of the same class in ğ·ğ´ğ‘ˆ â†“.
Example 9. Consider the following FOL formula:
ğ‘’ğ‘¥ğ‘ ğ‘“ = âˆƒaccess : Access Â· (âˆ€update : Update)Â·
(ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ .ğ‘ğ‘Ÿğ‘”1 = ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’.ğ‘ğ‘Ÿğ‘”1 â‡’ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ .ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’.ğ‘¡ğ‘–ğ‘šğ‘’ + 5)
Let ğ·ğ´ğ‘ˆ â†“1 = {ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2}. ğº(ğ‘’ğ‘¥ğ‘ ğ‘“ , ğ·ğ´ğ‘ˆ â†“1) instantiates
âˆƒaccess : Access with a new relational object, ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, and instan-
tiates âˆ€update : Update with two relational objects, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1 and
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 in ğ·ğ´ğ‘ˆ â†“1. The grounded formula is

ğ‘’ğ‘¥ğ‘ğ‘” = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1âˆ§
(ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.ğ‘ğ‘Ÿğ‘”1 = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”1 â‡’ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ + 5)
âˆ§ (ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘ğ‘Ÿğ‘”1 = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”1 â‡’ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ + 5).

Proposition 2. For every FOL formula ğœ™ ğ‘“ translated from MFOTL
formula ğœ™ and domain ğ·ğ´ğ‘ˆ â†“, the grounded formula ğœ™ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“)
is quantifier-free and contains a finite number of variables and terms.

Lemma 1 (Over-approximation Query). For an FOL formula ğœ™ ğ‘“ ,
and a domain ğ·ğ´ğ‘ˆ â†“, if ğœ™ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“) is UNSAT, then so is ğœ™ ğ‘“ .
Proof. We prove Lemma 1 by contradiction. Suppose ğœ™ğ‘” is UN-
SAT but there exists a solution ğ‘£ ğ‘“ for ğœ™ ğ‘“
in some domain ğ·ğ´ğ‘ˆ
(ğ·ğ´ğ‘ˆ may be different from ğ·ğ´ğ‘ˆ â†“). We show that we can always
construct a solution ğ‘£ğ‘” that satisfies ğœ™ğ‘”, which causes a contradic-
tion. First, we construct a solution ğ‘£ â€²
ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ ) from
the solution ğ‘£ ğ‘“ (for ğœ™ ğ‘“ ). Then, we construct a solution ğ‘£ğ‘” for ğœ™ğ‘”
from the solution ğ‘£ â€²

ğ‘” for ğœ™ â€²

ğ‘” for ğœ™ â€²
ğ‘”.

ğ‘” for ğœ™ â€²

We can construct a solution ğ‘£ â€²

ğ‘” in ğ·ğ´ğ‘ˆ âˆª ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘  where
ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘  are the new relational objects added by ğº. The encoding
of ğº uses the standard way for expanding universally quantified
expression by enumerating every relation object in ğ·ğ´ğ‘ˆ (L:10).
For every existentially quantified expression, there exists some
relation object ğ‘Ÿ âˆˆ ğ·ğ´ğ‘ˆ enabled by ğ‘£ ğ‘“ that satisfies the expression
ğ‘” contains a new relational object ğ‘Ÿ â€² âˆˆ ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘  for
in ğœ™ ğ‘“ , whereas ğœ™ â€²
satisfying the same expression (L:6). Let ğ‘£ ğ‘“ (ğ‘Ÿ ) = ğ‘£ â€²
ğ‘” (ğ‘Ÿ â€²) for ğ‘Ÿ and
ğ‘Ÿ â€², and then ğ‘£ â€²

ğ‘” is a solution to ğœ™ â€²
ğ‘”.
To construct the solution ğ‘£ğ‘” for ğœ™ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“) from the
solution ğ‘£ â€²
ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ ), we consider the expansion of
universally quantified expression in ğœ™ ğ‘“ (L:8). For every relational
objects in ğ‘Ÿ + âˆˆ ğ·ğ´ğ‘ˆ âˆ’ ğ·ğ´ğ‘ˆ â†“, ğº creates constraints (L:10) in ğœ™ â€²
ğ‘”,
but not in ğœ™ğ‘”. On the other hand, for every relational objects in
ğ‘Ÿ âˆ’ âˆˆ ğ·ğ´ğ‘ˆ â†“âˆ’ğ·ğ´ğ‘ˆ , we disable ğ‘Ÿ âˆ’ in the solution ğ‘£ğ‘”, (i.e., ğ‘£ğ‘” (ğ‘Ÿ âˆ’) = âŠ¥).
Therefore, the constraints instantiated by ğ‘Ÿ âˆ’ (at L:10) in ğœ™ğ‘” are
vacuously satisfied.

ğ‘” for ğœ™ â€²

For every relational object ğ‘Ÿ âˆˆ ğ·ğ´ğ‘ˆ â†“ âˆ©ğ·ğ´ğ‘ˆ , we let ğ‘£ğ‘” (ğ‘Ÿ ) = ğ‘£ â€²

ğ‘” (ğ‘Ÿ ),
and all shared constraints in ğœ™ğ‘” and ğœ™ â€²
ğ‘” are satisfied by ğ‘£ğ‘” and ğ‘£ â€²
ğ‘”,
â–¡
respectively. Therefore, ğ‘£ğ‘” is a solution to ğœ™ğ‘”. Contradiction.
Under-approximation. Let ğœ™ ğ‘“ be an FOL formula, and ğ·ğ´ğ‘ˆ â†“ be
an FO domain. The over-approximation ğœ™ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“) contains
a set of new relational objects introduced by ğº (L:5), denoted by
ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ . Let NoNewR(ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ , ğ·ğ´ğ‘ˆ â†“) be constraints that enforce
that every new relational object ğ‘Ÿ in ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘  be identical to some

relational objects in ğ·ğ´ğ‘ˆ â†“. Formally,

NoNewR(ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ , ğ·ğ´ğ‘ˆ â†“) =

(cid:219)

(cid:220)

(ğ‘Ÿ = ğ‘Ÿ â€²).

ğ‘Ÿ âˆˆğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ 

ğ‘Ÿ â€² âˆˆğ·ğ´ğ‘ˆ â†“

ğ‘” = ğœ™ğ‘” âˆ§ NoNewR(ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ , ğ·ğ´ğ‘ˆ â†“). If ğœ™ âŠ¥
Let ğœ™ âŠ¥
ğ‘” has a satisfying
solution, then there is a solution for ğœ™ ğ‘“ . We call ğœ™ âŠ¥
ğ‘” an under-
approximation of ğœ™ ğ‘“ and denote the procedure for computing it by
UnderApprox(ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“).
Example 10. Consider the FOL formula ğ‘’ğ‘¥ğ‘ ğ‘“ in Ex. 9 and ğ·ğ´ğ‘ˆ â†“2 =
{ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2, ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1}.

ğº (ğ‘’ğ‘¥ğ‘ ğ‘“ , ğ·ğ´ğ‘ˆ â†“2) = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2âˆ§
(ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.ğ‘ğ‘Ÿğ‘”1 = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2.ğ‘ğ‘Ÿğ‘”1 â‡’ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ + 5)âˆ§
(ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘ğ‘Ÿğ‘”1 = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2.ğ‘ğ‘Ÿğ‘”1 â‡’ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ + 5),

ğ‘” = UnderApprox(

ğ‘” , then there exists a solution to ğœ™ ğ‘“ .

where ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2 is the new relational object introduced in the grounded
formula. In ğœ™ âŠ¥
ğ‘” , ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2 is constrained to be some relational objects
in ğ·ğ´ğ‘ˆ â†“2 (see NoNewR({ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2}, ğ·ğ´ğ‘ˆ â†“2)). Therefore, ğœ™ âŠ¥
ğ‘” query
is ğº (ğ‘’ğ‘¥ğ‘ ğ‘“ , ğ·ğ´ğ‘ˆ â†“2) âˆ§ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 2 = ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.
Lemma 2 (Under-Approximation Query). For an FOL formula
ğœ™ ğ‘“ , and a domain ğ·ğ´ğ‘ˆ â†“, let ğœ™ğ‘” = ğº (ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“) and ğœ™ âŠ¥
ğœ™ ğ‘“ , ğ·ğ´ğ‘ˆ â†“). If ğœ is a solution to ğœ™ âŠ¥
Proof. By construction, NoNewR(ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ , ğ·ğ´ğ‘ˆ â†“) guarantees that
if ğœ is a solution to ğœ™ âŠ¥
ğ‘” in the domain ğ·ğ´ğ‘ˆ â†“, there exists a solution ğœ â€²
to ğœ™ğ‘” in the domain ğ·ğ´ğ‘ˆ â†“ âˆª ğ‘ ğ‘’ğ‘¤ğ‘…ğ‘ . Since every relational object
ğ‘Ÿ âˆˆ ğ·ğ´ğ‘ˆ â†“ has been used to instantiate a universally-quantified
expression (L:10 of Alg. 2), ğœ â€² is also a solution to ğœ™ ğ‘“ .
â–¡
Suppose for some domain ğ·ğ´ğ‘ˆ â†“, an over-approximation query
ğœ™ğ‘” for an FOL formula ğœ™ ğ‘“ is satisfiable while the under-approximation
query ğœ™ âŠ¥
ğ‘” is UNSAT. Then we cannot conclude satisfiability of ğœ™ ğ‘“
for ğ·ğ´ğ‘ˆ â†“. However, the solution to ğœ™ğ‘” provides hints on how to
expand ğ·ğ´ğ‘ˆ â†“ to potentially obtain a satisfying solution for ğœ™ ğ‘“ .
Corollary 1 (Necessary relational objects). For a satisfying FOL
formula ğœ™ ğ‘“ and a domain ğ·ğ´ğ‘ˆ â†“, let ğœ™ğ‘” and ğœ™ âŠ¥
ğ‘” be the over- and under-
approximation queries of ğœ™ ğ‘“ based on ğ·ğ´ğ‘ˆ â†“, respectively. Suppose
ğœ™ğ‘” is satisfiable, and ğœ™ âŠ¥
ğ‘” is UNSAT, then every solution to ğœ™ ğ‘“ contains
some relational object mentioned in the formula ğœ™ğ‘” but not in ğ·ğ´ğ‘ˆ â†“.
ğ‘” are over- and under- approxima-
tion of ğœ™ ğ‘“ , respectively. Cor. 1 shows that any domain ğ·ğ´ğ‘ˆ that
contains a satisfying solution to ğœ™ ğ‘“ must consider some relational
objects from some solution to ğœ™ğ‘”.

Cor. 1 holds because ğœ™ğ‘” and ğœ™ âŠ¥

5.2 Counterexample-Guided Constraint

Solving Algorithm

Let an MFOTL formula ğœ™, a set of MFOTL requirements Reqs, an
optional volume bound ğ‘ğ‘£ğ‘œğ‘™ , and optionally a set of FOL data do-
main constraints ğ‘‡ğ‘‘ğ‘ğ‘¡ğ‘ be given. IBSC, shown in Alg. 1, searches
for a solution ğœ to ğœ™ (cid:211)ğœ“ âˆˆReqs ğœ“ (while respecting ğ‘‡ğ‘‘ğ‘ğ‘¡ğ‘), bounded
by ğ‘ğ‘£ğ‘œğ‘™ . If no such solution is possible regardless of the bound,
IBSC returns UNSAT. If no solution can be found within the given
bound, but a solution may exist for a larger bound, then IBSC re-
turns bounded-UNSAT. If ğ‘ğ‘£ğ‘œğ‘™ is not specified, IBSC will perform
the search unboundedly until a solution or UNSAT is returned.

IBSC first translates ğœ™ and every ğœ“ âˆˆ Reqs into FOL formulas
in Reqsğ‘“ , denoted by ğœ™ ğ‘“ and ğœ“ğ‘“ , respectively. Then IBSC searches

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

â†“

for a satisfying solution to ğœ™ ğ‘“ âˆ§ (cid:211)ğœ“ğ‘“ âˆˆReqsğ‘“
ğœ“ğ‘“ (denote as ğœ™ğ‘ƒ âˆ§Reqs)
in the FO domain ğ·ğ´ğ‘ˆ of volume which is at most ğ‘ğ‘£ğ‘œğ‘™ . Instead
of searching in ğ·ğ´ğ‘ˆ directly, IBSC searches for a solution of ğœ™ ğ‘“ âˆ§
(cid:211)ğœ“ğ‘“ âˆˆReqs
ğœ“ğ‘“ in ğ·ğ´ğ‘ˆ â†“, where Reqsâ†“ âŠ† Reqsğ‘“ and ğ·ğ´ğ‘ˆ â†“ âŠ† ğ·ğ´ğ‘ˆ .
IBSC initializes Reqsâ†“ and ğ·ğ´ğ‘ˆ â†“ as empty sets (LL:3-4). Then, for the
FOL formula ğœ™ğ‘ƒ âˆ§Reqs, IBSC creates an over- and under-approximation
query ğœ™ğ‘” (L:8) and ğœ™ âŠ¥
ğ‘” (L:10), respectively (described in Sec. 5.1).
IBSC first solves the over-approximation query ğœ™ğ‘” by querying an
SMT solver (L:14). If ğœ™ğ‘” is unsatisfiable, then ğœ™ğ‘ƒ âˆ§Reqs is unsatisfiable
(Lemma 1), and IBSC returns UNSAT (L:12).

ğ‘” (L:11). If ğœ™ âŠ¥

If ğœ™ğ‘” is satisfiable, then IBSC solves the under-approximation
query ğœ™ âŠ¥
ğ‘” is unsatisfiable, then the current domain
ğ·ğ´ğ‘ˆ â†“ is too small, and IBSC expands it (LL:15-22). This is because
satisfiability of ğœ™ğ‘” indicates the possibility of finding a satisfying
solution after adding at least one of the new relational objects in
the solution of ğœ™ğ‘” to ğ·ğ´ğ‘ˆ â†“ (Cor. 1). The expansion aims to identify
a minimum solution ğœğ‘šğ‘–ğ‘› for ğœ™ğ‘” that requires the smallest number
of relational objects (L:16). For every relational object ğ‘Ÿ â€² âˆˆ ğœğ‘šğ‘–ğ‘›, ğ‘Ÿ â€²
is added to ğ·ğ´ğ‘ˆ â†“ if it is not already in ğ·ğ´ğ‘ˆ â†“ (L:18). To obtain ğœğ‘šğ‘–ğ‘›,
we follow MaxRes [31] methods: we analyze the UNSAT core of ğœ™ âŠ¥
ğ‘”
and incrementally weaken ğœ™ âŠ¥
ğ‘” towards ğœ™ğ‘” (i.e., the weakened query
ğœ™ âŠ¥â€²
ğ‘” is an â€œover-under approximationâ€ that satisfies the condition
ğ‘” â‡’ ğœ™ âŠ¥â€²
ğœ™ âŠ¥
ğ‘” â‡’ ğœ™ğ‘”) until a satisfying solution ğœğ‘šğ‘–ğ‘› is obtained for
the weakened query. However, if the volume of ğœğ‘šğ‘–ğ‘› exceeds ğ‘ğ‘£ğ‘œğ‘™
(L:19), then bounded-UNSAT is returned (L:20).

On the other hand, if ğœ™ âŠ¥

ğ‘” yields a solution ğœ, then ğœ is checked
on Reqsğ‘“ (L:23). If ğœ satisfies every ğœ“ğ‘“ in Reqsğ‘“ , then ğœ is returned
(L:24). If ğœ violates some requirements in Reqsğ‘“ , then the violating
requirement ğ‘™ğ‘’ğ‘ ğ‘ ğ‘œğ‘› is added to Reqsâ†“ to be considered in the search
for the next solutions (L:28).

If IBSC does not find a solution or does not return UNSAT, it
means that no solution is found because the ğ·ğ´ğ‘ˆ â†“ is too small
or the Reqsâ†“ are too weak. IBSC then starts again with either the
expanded domain ğ·ğ´ğ‘ˆ â†“ or the refined set of requirements Reqsâ†“.
It computes the over- and under-approximation queries (ğœ™ğ‘” and
ğœ™ âŠ¥
ğ‘” ) again and repeats the steps. Due to structural similarities of ğœ™ğ‘”
and ğœ™ âŠ¥
ğ‘” between iterations, incremental encoding and solving are
enabled to allow SMT solvers to internally reuse learned clauses
from previous iterations.

Example 11. Consider the DCC example in Sec. 2. Suppose IBSC
is invoked to find a counterexample for property ğ‘ƒ1 (shown in
Fig. 1) subject to requirements Reqs = {ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘2} with the bound
ğ‘ğ‘£ğ‘œğ‘™ = 4. IBSC translates the requirements and the property to FOL,
and initializes Reqsâ†“ and ğ·ğ´ğ‘ˆ â†“ to empty sets. For each iteration,
we use ğœ™ğ‘” and ğœ™ âŠ¥
ğ‘” to represent the over- and under-approximation
queries computed on LL:8-10, respectively.

1st iteration: ğ·ğ´ğ‘ˆ â†“ = âˆ… and Reqsâ†“ = âˆ…. ğœ™ğ‘” introduces three
new relational objects (from Â¬ğ‘ƒ1): ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 and ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1
such that: (C1) ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1 occurs after ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 and ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1; (C2)
ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”1 = ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.ğ‘ğ‘Ÿğ‘”1 = ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.ğ‘ğ‘Ÿğ‘”1; (C3) ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”2 â‰ 
ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.ğ‘ğ‘Ÿğ‘”2âˆ§ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”2 â‰  ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.ğ‘ğ‘Ÿğ‘”2; and (C4) either ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1
or ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1 must be present in the counterexample. ğœ™ğ‘” is satisfiable,
but ğœ™ âŠ¥
ğ‘” is UNSAT since ğ·ğ´ğ‘ˆ â†“ is an empty set. WLOG, we assume
ğ·ğ´ğ‘ˆ â†“ is expanded by adding ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1 and ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.

Report, September 8th, 2022,

Algorithm 1 IBSC: search for a bounded (by ğ‘ğ‘£ğ‘œğ‘™ ) solution to
ğ‘‡ (ğœ™) (cid:211)ğœ“ âˆˆReqs ğ‘‡ (ğœ“ ).

Input an MFOTL formula ğœ™.
Input a set of MFOTL requirements Reqs = {ğœ“1,ğœ“2, ... }.
Optional Input ğ‘ğ‘£ğ‘œğ‘™ , the volume bound of the counterexample.
Optional Input data constraints ğ‘‡ğ‘‘ğ‘ğ‘¡ğ‘, default âŠ¤.
Output a counterexample ğœ, UNSAT or bounded-UNSAT.

ğ‘” âˆ§ ğ‘‡ğ‘‘ğ‘ğ‘¡ğ‘)

return UNSAT

end if
ğœ â† Solve(ğœ™ âŠ¥
if ğœ = UNSAT then //expand ğ·ğ´ğ‘ˆ â†“

ğœ™ â† ğœ™ ğ‘“ âˆ§ Reqs
â†“
//over-approximation query
ğœ™ğ‘” â† ğº (ğœ™, ğ·ğ´ğ‘ˆ â†“)
//under-approximation query
ğœ™ âŠ¥
ğ‘” â† UnderApprox(ğœ™, ğ·ğ´ğ‘ˆ â†“)
if Solve(ğœ™ğ‘” âˆ§ ğ‘‡ğ‘‘ğ‘ğ‘¡ğ‘) = UNSAT then

1: Reqsğ‘“ â† { ğœ“ğ‘“ = ğ‘‡ (ğœ“ ) | ğœ“ âˆˆ Reqs}
2: ğœ™ ğ‘“ â† ğ‘‡ (ğœ™)
â†“ â† âˆ… //initially do not consider any requirement
3: Reqs
4: ğ·ğ´ğ‘ˆ â†“ â† âˆ… //start with empty set of relational objects
5: while âŠ¤ do
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
end if
30:
31: end while

ğœğ‘šğ‘–ğ‘› â† Minimize(ğœ™ğ‘”)
//add relational object from the minimal solution
ğ·ğ´ğ‘ˆ â†“ += {ğ‘ğ‘ğ‘¡ | ğ‘ğ‘ğ‘¡ âˆˆ ğœğ‘šğ‘–ğ‘› }
if ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›) > ğ‘ğ‘£ğ‘œğ‘™ then
return bounded-UNSAT

ğ‘™ğ‘’ğ‘ ğ‘ ğ‘œğ‘› â† some ğœ“ âˆˆ Reqsğ‘“ such that ğœ Ì¸|= ğœ“
//add violating requirement to Reqs
â†“
Reqs
â†“

if ğœ |= ğœ“ for every ğœ“ âˆˆ Reqsğ‘“ then

else //checks all requirements

.add(ğ‘™ğ‘’ğ‘ ğ‘ ğ‘œğ‘›)

return ğœ

end if

end if

else

Algorithm 2 ğº: ground a quantified FOL formula.

Input an FOL formula ğœ™ ğ‘“ .
Input a domain of relational objects ğ·ğ´ğ‘ˆ â†“.
Output a grounded quantifier-free formula ğœ™ğ‘” over relational objects.

ğ¶ğ‘™ğ‘  â† ğœ™ ğ‘“ .ğ‘ğ‘™ğ‘ğ‘ ğ‘ 
//creates a new relational object of class ğ¶ğ‘™ğ‘ 
ğ‘›ğ‘’ğ‘¤ğ‘… â† NewAct(ğ¶ğ‘™ğ‘ )
return ğº (ğœ™ ğ‘“ .body[ğœ™ ğ‘“ .â„ğ‘’ğ‘ğ‘‘ğ´ğ‘ğ‘¡ â† ğ‘›ğ‘’ğ‘¤ğ‘…], ğ·ğ´ğ‘ˆ â†“)

1: if is_atom(ğœ™ ğ‘“ ) then return ğœ™ ğ‘“ end if
2: if ğœ™ ğ‘“ .ğ‘œğ‘ = âˆƒ then //process the existential operator
3:
4:
5:
6:
7: end if
8: if ğœ™ ğ‘“ .ğ‘œğ‘ = âˆ€ then //process the universal operator
9:
10:
11: end if
12: return ğœ™ ğ‘“ .ğ‘œğ‘(ğº (ğœ™ğ‘â„ğ‘–ğ‘™ğ‘‘ , ğ·ğ´ğ‘ˆ â†“) for ğœ™ğ‘â„ğ‘–ğ‘™ğ‘‘ in ğœ™ ğ‘“ .body)

ğ¶ğ‘™ğ‘  â† ğœ™ ğ‘“ .ğ‘ğ‘™ğ‘ğ‘ ğ‘ 
return (cid:211)

[ğ‘Ÿ :ğ¶ğ‘™ğ‘  ]âˆˆğ·ğ´ğ‘ˆ â†“

ğ‘Ÿ â‡’ ğº (ğœ™ ğ‘“ .body[ğœ™ ğ‘“ .â„ğ‘’ğ‘ğ‘‘ â† ğ‘Ÿ ], ğ·ğ´ğ‘ˆ â†“)

2nd iteration: ğ·ğ´ğ‘ˆ â†“ = {ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1} and Reqsâ†“ = âˆ…. ğœ™ğ‘”
ğ‘” is now satisfiable since ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1 and ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1

stays the same, and ğœ™ âŠ¥

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

are in ğ·ğ´ğ‘ˆ â†“. Suppose the solution is ğœ3 (see Fig. 2). However, ğœ3
violates ğ‘Ÿğ‘’ğ‘2, so ğ‘Ÿğ‘’ğ‘2 is added to Reqsâ†“.

3rd iteration: ğ·ğ´ğ‘ˆ â†“ = {ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1} and Reqsâ†“ = {ğ‘Ÿğ‘’ğ‘2}.
ğœ™ğ‘” introduces two new relational objects (from ğ‘Ÿğ‘’ğ‘2): ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2 and
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 such that (C5) ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤ ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2.ğ‘¡ğ‘–ğ‘šğ‘’+
168; (C6) ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤ ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ + 168; (C7)
ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”1 = ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2.ğ‘ğ‘Ÿğ‘”1 = ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘ğ‘Ÿğ‘”1; (C8) ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1.ğ‘ğ‘Ÿğ‘”2 =
ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2.ğ‘ğ‘Ÿğ‘”2 = ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘ğ‘Ÿğ‘”2; and (C9) ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2 or ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 exists.
ğœ™ğ‘” is satisfiable, but ğœ™ âŠ¥
ğ‘” is UNSAT because ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 âˆ‰ ğ·ğ´ğ‘ˆ â†“ and
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1 â‰  ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 (C8 conflicts with C3). Therefore, ğ·ğ´ğ‘ˆ â†“ needs
to be expanded. Assume ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2 is added.

4th iteration: ğ·ğ´ğ‘ˆ â†“ = {ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1, ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2} and Reqsâ†“ =
{ğ‘Ÿğ‘’ğ‘2}. ğœ™ğ‘” stays the same, and ğœ™ âŠ¥
ğ‘” is now satisfiable since ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2
is in ğ·ğ´ğ‘ˆ â†“. Suppose the solution is ğœ4 (see Fig. 2). Since ğœ4 violates
ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘1 is added to Reqsâ†“.

5th iteration: ğ·ğ´ğ‘ˆ â†“ = {ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1, ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2} and Reqsâ†“ =
{ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘2}. Since ğ‘Ÿğ‘’ğ‘1 is in Reqsâ†“, ğœ™ğ‘” adds the following con-
straints (from ğ‘Ÿğ‘’ğ‘1): (C9) Â¬(ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ âˆ’ 168 â‰¤ ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’). Since (C9) conflicts with (C8),(C7) and (C1), ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2
cannot be in the solution of ğœ™ğ‘”. ğœ™ğ‘” is satisfiable if ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 (intro-
duced in the 1st iteration) or ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 (3rd iteration) are in the
solution. But ğœ™ âŠ¥
ğ‘” is UNSAT since ğ·ğ´ğ‘ˆ â†“ does not contain ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 or
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2. Thus, ğ·ğ´ğ‘ˆ â†“ is refined. Assume ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2 is added to ğ·ğ´ğ‘ˆ â†“.
6th iteration: ğ·ğ´ğ‘ˆ â†“ = {ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1, ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2} and
Reqsâ†“ = {ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘2}. ğœ™ğ‘” adds the constraints (C10) ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¥
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.ğ‘¡ğ‘–ğ‘šğ‘’ + 168. ğœ™ğ‘” (from ğ‘Ÿğ‘’ğ‘1) and (C11) ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2.ğ‘¡ğ‘–ğ‘šğ‘’ â‰¤
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1.ğ‘¡ğ‘–ğ‘šğ‘’ (from Â¬ğ‘ƒ). Since (C10) conflicts with (C11), ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2
cannot exist in the solution of ğœ™ğ‘”. Thus, ğœ™ğ‘” is satisfiable only if
ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 is in the solution. ğœ™ âŠ¥
ğ‘” is UNSAT because ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1 âˆ‰ ğ·ğ´ğ‘ˆ â†“.
Therefore, ğ·ğ´ğ‘ˆ â†“ is expanded by adding ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1.

final iteration: ğ·ğ´ğ‘ˆ â†“ = {ğ‘ğ‘ğ‘ğ‘’ğ‘ ğ‘ 1, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’1, ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡2, ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’2, ğ‘ğ‘œğ‘™ğ‘™ğ‘’ğ‘ğ‘¡1}

and Reqsâ†“ = {ğ‘Ÿğ‘’ğ‘1, ğ‘Ÿğ‘’ğ‘2}. ğœ™ âŠ¥
solution ğœ5 in Fig. 2. ğœ5 satisfies ğ‘Ÿğ‘’ğ‘1 and ğ‘Ÿğ‘’ğ‘2, and is returned.

ğ‘” becomes satisfiable, and yields the

5.3 Correctness, Termination, Optimality
In this section, we first prove correctness of the IBSC algorithm,
then show that IBSC always terminates when ğ‘ğ‘£ğ‘œğ‘™ â‰  âˆ and finally
prove that IBSC always finds a solution with a minimum volume.

Theorem 1 (Soundness). If the algorithm IBSC terminates on input
ğœ™, Reqs and ğ‘ğ‘£ğ‘œğ‘™ , then it returns the correct result, i.e., a counter-
example ğœ, "UNSAT" or "bounded-UNSAT", when they apply.

Proof. Let ğœ™ ğ‘“ be the FOL formula ğ‘‡ (ğœ™) (cid:211)ğœ“ âˆˆReqs ğ‘‡ (ğœ“ ). We consider
correctness of IBSC for three possible outputs: the satisfying solu-
tion ğœ to ğœ™ ğ‘“ (L:24), the UNSAT determination of ğœ™ ğ‘“ (L:12), and the
bounded-UNSAT determination of ğœ™ ğ‘“ (L:20).

IBSC returns a satisfying solution ğœ only if (1) ğœ is a solution
ğœ™ âŠ¥
ğ‘” (L:25) and (2) ğœ |= ğ‘‡ (ğœ“ ) for every ğœ“ âˆˆ ğ‘…ğ‘’ğ‘ğ‘  (L:23). By (1) and
Lemma 2, ğœ is a solution to ğ‘‡ (ğœ™) (cid:211)ğœ“ âˆˆReqs
ğ‘‡ (ğœ“ ). Together with (2),
ğœ is a solution to ğœ™ ğ‘“ .

â†“

IBSC returns UNSAT iff ğœ™ğ‘” is UNSAT (L:11). By Lemma 1, we
ğ‘‡ (ğœ“ ) is UNSAT. Since Reqsâ†“ âŠ† ğ‘…ğ‘’ğ‘ğ‘ , the orig-

show ğ‘‡ (ğœ™) (cid:211)ğœ“ âˆˆReqs
inal formula ğœ™ ğ‘“ is also UNSAT.

â†“

IBSC returns bounded-UNSAT iff the volume of the minimum
solution ğœğ‘šğ‘–ğ‘› to the over-approximated query ğœ™ğ‘” is larger than ğ‘ğ‘£ğ‘œğ‘™
(L:19). Since ğœ™ğ‘” is an over-approximation of the original formula ğœ™ ğ‘“ ,

any solution ğœ to the ğœ™ ğ‘“ has volume at least ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›). Therefore,
â–¡
when ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›) > ğ‘ğ‘£ğ‘œğ‘™ , ğ‘£ğ‘œğ‘™ (ğœ) > ğ‘ğ‘£ğ‘œğ‘™ for every solution.

Theorem 2 (Termination). For an input property ğœ™, requirements
Reqs, and a bound ğ‘ğ‘£ğ‘œğ‘™ â‰  âˆ, IBSC eventually terminates.

Proof. To prove that IBSC always terminates when the input ğ‘ğ‘£ğ‘œğ‘™ â‰ 
âˆ, we need to show that IBSC does not get stuck at solving the
SMT query via solve (LL:14-11), nor refining Reqsâ†“ (LL:23-29), nor
expanding ğ·ğ´ğ‘ˆ â†“ (LL:18-22).

A call to solve (LL:14-11) always terminates. By Prop. 1, ğ‘‡ (ğœ™)
may contain quantifiers exclusively over relational objects. By
Prop. 2 both the under- and the over-approximated queries ğœ™ğ‘”
and ğœ™ âŠ¥
ğ‘” are quantifier-free. Since the background theory for ğœ™ is
LIA, then ğœ™ğ‘” and ğœ™ âŠ¥
ğ‘” are a quantifier-free LIA formula whose satis-
fiability is decidable.

If the requirement checking fails on L: 23, a violating requirement
ğ‘™ğ‘’ğ‘ ğ‘ ğ‘œğ‘› is added to Reqsâ†“ (LL:26-28) which ensures that any future
solution ğœ â€² satisfies ğ‘™ğ‘’ğ‘ ğ‘ ğ‘œğ‘›. Therefore, ğ‘™ğ‘’ğ‘ ğ‘ ğ‘œğ‘› is never added to Reqsâ†“
more than once. Given that Reqs is a finite set of MFOTL formulas, at
most |Reqs| lessons can be learned before the algorithm terminates.
The under-approximated domain ğ·ğ´ğ‘ˆ â†“ can be expanded a fi-
nite number of times because the size of the minimum solution
ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›) to ğœ™ğ‘” (computed on L:16) is monotonically non-decreasing
between each iteration of the loop (LL:5-31). The size will eventually
increase since each relational object in ğ·ğ´ğ‘ˆ â†“ can introduce a finite
number of options for adding a new relational object through the
grounded encoding of ğœ™ğ‘” on L:10, e.g., ğ‘Ÿ â‡’ (cid:212)ğ‘›
ğ‘–=0 âˆƒğ‘Ÿğ‘– . After explor-
ing all options to ğ·ğ´ğ‘ˆ â†“, ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›) must increase if the algorithm
has not already terminated. Therefore, if ğ‘ğ‘£ğ‘œğ‘™ â‰  âˆ, then eventually
ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›) > ğ‘ğ‘£ğ‘œğ‘™ , and the algorithm will return bounded-UNSAT
â–¡
instead of expanding ğ·ğ´ğ‘ˆ â†“ indefinitely (LL:15-22).

Theorem 3 (Solution optimality). For a property ğœ™ and require-
ments Reqs, let ğœ™ ğ‘“ be the FOL formula ğ‘‡ (ğœ™) (cid:211)ğœ“ âˆˆReqs ğ‘‡ (ğœ“ ). If IBSC
finds a solution ğœ for ğœ™ ğ‘“ , then for every ğœ â€² |= ğœ™ ğ‘“ , ğ‘£ğ‘œğ‘™ (ğœ) â‰¤ ğ‘£ğ‘œğ‘™ (ğœ â€²).

Proof. IBSC returns a solution ğœ on L:24 only if ğœ is a solution to
the under-approximation query ğœ™ âŠ¥
ğ‘” (computed on L:10) for some
domain ğ·ğ´ğ‘ˆ â†“ â‰  âˆ…. ğ·ğ´ğ‘ˆ â†“ is last expanded in some previous it-
erations by adding relational objects to the minimum solution
ğœğ‘šğ‘–ğ‘› (L:16) of the over-approximation query ğœ™ â€²
ğ‘” (L:18). Therefore,
the returned ğœ has the same number of relational objects as ğœğ‘šğ‘–ğ‘›
(ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›) = ğ‘£ğ‘œğ‘™ (ğœ)). Since ğœ™ğ‘” is an over-approximation of the
original formula ğœ™ ğ‘“ , any solution ğœ â€² to ğœ™ ğ‘“ has volume that is at
least ğ‘£ğ‘œğ‘™ (ğœğ‘šğ‘–ğ‘›). Therefore, ğ‘£ğ‘œğ‘™ (ğœ) â‰¤ ğ‘£ğ‘œğ‘™ (ğœ â€²).
â–¡

Remark. IBSC finds the optimal solution because it always looks
for the minimum solution ğœğ‘šğ‘–ğ‘› to the over-approximation query
ğœ™ğ‘” (L:16) and uses it for domain expansion (L:18). However, looking
for the minimum solution adds cost. If the solution optimality is not
required, IBSC can be configured to heuristically find a solution ğœ
to ğœ™ğ‘” such that ğ‘£ğ‘œğ‘™ (ğœ) â‰¤ ğ‘ğ‘£ğ‘œğ‘™ . For example, greedy best-first search
(ğ‘”ğµğ¹ğ‘†) finds a solution to ğœ™ğ‘” that minimizes the number of relational
objects that are not already in ğ·ğ´ğ‘ˆ â†“, and then uses it to expand
ğ·ğ´ğ‘ˆ â†“. We configured a non-optimal version of IBSC (ğ‘›IBSC) that
uses ğ‘”ğµğ¹ğ‘† heuristics, and evaluate its performance in Sec. 6.

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

names

case study statistics
#ğ‘Ÿğ‘’ğ‘ğ‘  #ğ‘Ÿğ‘’ğ‘™ğ‘  #ğ‘ğ‘Ÿğ‘”ğ‘  #ğ‘ğ‘Ÿğ‘œğ‘ğ‘ 

configuration values

18
45
14
10

22
28
7
3

PHIM
CF@H
PBC
BST

[1 âˆ’ 4]
[2 âˆ’ 3]
[1 âˆ’ 2]
[1 âˆ’ 3]

#c = 2, #p = 2, #d = 5
#u = 2, #d = 10
#u = 5, #d = 10
#e = 1, #cus = 2, #t = 4, sup = 10

7
7
1
3
Table 1: Case study statistics. The numbers of requirements, re-
lations, relation arguments, and properties are denoted as #ğ‘Ÿğ‘’ğ‘ğ‘ ,
#ğ‘Ÿğ‘’ğ‘™ğ‘ , #ğ‘ğ‘Ÿğ‘”ğ‘ , and #ğ‘ğ‘Ÿğ‘œğ‘ğ‘ , respectively. Initial configurations with
data constraints specific to each case study: PHIM â€“ the number
of custodians (#ğ‘), patients (#ğ‘), and data (#ğ‘‘); CF@H and PBC
â€“ the number of users (#ğ‘¢), and data (#ğ‘‘); BST â€“ the number of em-
ployees (#ğ‘’), customers (#ğ‘ğ‘¢ğ‘ ), transactions (#ğ‘¡ ), and maximum
amount for a transaction (sup).

6 EVALUATION
To evaluate our approach, we developed LEGOS, a tool that im-
plements our MFOTL bounded satisfiability checking algorithm
IBSC (Algorithm 1). It includes Python API for specifying system
requirements and MFOTL safety properties. We use pySMT [15]
to formulate SMT queries and Z3 [10] to check their satisfiability.
LEGOS and the evaluation artifacts are included in supplemen-
tary material. In this section, we evaluate the effectiveness of our
approach using five case studies, aiming to answer the following
research question (RQ): How effective is our approach at determin-
ing the bounded satisfiability of MFOTL formulas? We measure
effectiveness in terms of the ability to determine satisfiability (i.e.,
the satisfying solution and its volume, UNSAT, or bounded UNSAT),
and performance, i.e., time and memory usage.

Cases studies. The case studies shown in Tab. 1, are summarized
below: (1) PHIM (derived from [1, 13]): a computer system for keep-
ing track of personal health information with cost management;
(2) CF@H2: a system for monitoring a COVID patients at home
and enabling doctors to monitor patient data; (3) PBC [5]: an ap-
proval policy for publishing business reports within a company; (4)
BST [5]: a banking system that processes customer transactions;
and (5) NASA [14, 30]: an automated air-traffic control system
design that aims to avoid aircraft collisions. 3 Case studies were
selected for (i) the purpose of comparison with existing works (i.e.,
NASA); (ii) checking whether our approach scales with case studies
involving data/time constraints (PBC, BST, PHIM and CF@H); or
(iii) evaluating the applicability of our approach with real-word
case studies (CF@H and NASA). In addition to prior case stud-
ies, we include PHIM and CF@H which have complex data/time
constraints. The number of requirements for the five case studies
ranges between ten (BST) and 194 (NASA). The number of relations
present in the MFOTL requirements ranges from three (BST) to 28
(CF@H), and the number of arguments in these relations ranges
from 1 (PHM, PBC, and BST) to 79 (NASA). Examples of properties
and requirements considered in this evaluation are shown in Fig. 1.

Experimental setup. Given a set of requirements, data constraints
and properties of interest for each case study, we measured the run-
time (time) and peak memory usage (mem.) of performing bounded

1available at https://github.com/agithubuserseva/IBSC
2https://covidfreeathome.org/
3The requirements and properties for the NASA case study are originally expressed in
LTL, which is subsumed by MFOTL.

Report, September 8th, 2022,

satisfaction checking of MFOTL properties, and the volume ğ‘£ğ‘œğ‘™ğœ
(the number of relational objects) of the solution (ğœ) with (IBSC)
and without (ğ‘›IBSC) the optimality guarantees (see Remark 5.3 for
finding non-optimal solutions). We conduct two experiments: the
first one evaluates the efficiency and scalability of our approach;
the second one compares our approach with satisfiability checking.
Since there is no existing work for checking MFOTL satisfiabil-
ity, we compared with LTL satisfiability checking because MFOTL
subsumes LTL. To study the scalability of our approach, our first
experiment considers four different configurations obtained by
increasing the data domain constraints of the case studies require-
ments. The initial configuration (small) is described in Tab. 1. The
medium and large configurations are obtained by multiplying the
initial data constraints and volume bound by ten and hundred,
respectively. The last (unbounded) configuration does not bound
either the data domain or the volume. To study performance of
our approach relative to existing work, our second experiment con-
siders two configurations of the NASA case study verified in [28]
using the state of the art symbolic model checker nuXmv [8]. We
compare our approachâ€™s result against the reproduced result of
nuXmv verification. For both experiments, we report the analysis
outcomes, i.e., the satisfying solution and its volume, UNSAT, or
bounded UNSAT; and performance, i.e., time and memory usage.
The experiments were conducted using a ThinkPad X1 Carbon with
an Intel Core i7 1.80 GHz processor, 8 GB RAM, and running 64-bit
Ubuntu GNU/Linux 8.

Results of the first experiment are summarized in Tab. 2. Out
of the 72 trials, our approach found 31 solutions. It also returned
five bounded-UNSAT answers, and 36 UNSAT answers. The results
show that our approach is effective in checking satisfiability of
case studies with different size. More precisely, we observe that it
takes under three seconds to return UNSAT and between .04 sec-
onds (ğ‘ğ‘ 2:medium) and 32 minutes (ğ‘â„7:medium:IBSC) to return
a solution. In the worst case, IBSC took 32 minutes for checking
ğ‘â„7 where the property and requirements contain complex con-
straints. Effectively, ğ‘â„7 requires the deletion of data stored at id 10,
while PHIM requires that the cost of deletion increases over time.
Therefore, the user has to perform a number of actions to obtain a
sufficient balance to delete the data. Additionally, each action that
increases the userâ€™s balance has its own preconditions, effects, and
time cost, making the process of choosing the sequence of actions
to meet the increasing deletion cost non-trivial.

We can see a difference in time between cf2 â€˜bigâ€™ and â€˜unboundedâ€™,
this is because the domain expansion followed two different paths
and one produces significantly easier SMT queries. Since our ap-
proach is guided by counter-examples (i.e., the path is guided by
the solution from the SMT solver (Alg.1-L:16)), our approach does
not have direct control over the exact path selection. In future work,
we aim to add optimizations to avoid/backtrack from hard paths.
We observe that the data domain constraint and volume bound
used in different configurations do not affect the performance of
IBSC when the satisfiability of the instances does not depend on
them which is the case for all the instances except for ğ‘â„6âˆ’7:small,
ğ‘ ğ‘“1âˆ’3 : ğ‘ ğ‘šğ‘ğ‘™ğ‘™, and ğ‘ğ‘ 3:small. As mentioned in Sec. 4, the data do-
main constraint ensures that satisfying solutions have realistic data
values. For ğ‘â„1 âˆ’ ğ‘â„4, the bound used in small, medium and large

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

case studies

ğ‘â„1
ğ‘â„2
ğ‘â„3
ğ‘â„4
ğ‘â„5
ğ‘â„6
ğ‘â„7
ğ‘ ğ‘“1
ğ‘ ğ‘“2
ğ‘ ğ‘“3
ğ‘ ğ‘“4
ğ‘ ğ‘“5
ğ‘ ğ‘“6
ğ‘ ğ‘“7
ğ‘ğ‘1
ğ‘ğ‘ 1
ğ‘ğ‘ 2
ğ‘ğ‘ 3

PHIM

CF@H

PBC

BST

small
time
(sec)
ğ‘›IBSC | IBSC ğ‘›IBSC | IBSC ğ‘›IBSC | IBSC

mem.
(MB)

out.

U
U
U
U
U
b-U
U

b-U
b-U
b-U
b-U
8 | 8
8 | 8
U

U

U
2 | 2
U

0.04 | 0.03
0.03 | 0.03
0.03 | 0.03
0.04 | 0.04
0.02 | 0.02
0.18 | 0.20
0.11 | 0.11

4.80 | 6.90
0.87 | 0.93
1.38 | 1.31
1.52 | 0.73
1.20 | 1.17
1.06 | 1.16
0.58 | 0.58

0.04 | 0.04

0.04 | 0.03
0.04 | 0.04
0.02 | 0.02

29 | 29
138 | 138
134 | 137
136 | 138
135 | 135
139 | 139
139 | 139

114 | 176
70 | 70
145 | 145
74 | 68
146 | 147
146 | 147
141 | 142

29 | 140

64 | 63
62 | 64
62 | 62

out.

ğ‘›IBSC | IBSC

U
U
U
U
U
U
29 | 29

U
14 | 14
16 | 16
14 | 14
8 | 8
8 | 8
U

U

U
2 | 2
5 | 5

medium
time
(sec)
ğ‘›IBSC | IBSC

0.03 | 0.03
0.03 | 0.03
0.03 | 0.03
0.04 | 0.04
0.02 | 0.02
0.72 | 0.82
13.80 | 1905.40

2.87 | 3.55
3.21 | 425.41
6.05 | 90.78
4.54 | 65.59
0.48 | 0.54
0.52 | 0.61
0.38 | 0.36

0.16 | 0.17

0.29 | 0.24
0.04 | 0.04
0.4 | 0.9

mem.
(MB)
ğ‘›IBSC | IBSC

136 | 136
136 | 137
138 | 138
138 | 135
608 | 608
144 | 144
193 | 599

81 | 86
79 | 334
168 | 403
90 | 261
141 | 142
142 | 142
140 | 141

140 | 139

70 | 68
62 | 62
70 | 73

big
time
(sec)
ğ‘›IBSC | IBSC ğ‘›IBSC | IBSC ğ‘›IBSC | IBSC

mem.
(MB)

out.

U
U
U
U
56 | 56
U
30 | 29

U
14 | 14
16 | 16
14 | 14
8 | 8
8 | 8
U

9 | 9

U
2 | 2
5 | 5

0.04 | 0.04
0.03 | 0.04
0.05 | 0.05
0.05 | 0.05
30.51 | 30.51
0.88 | 0.70
20.25 | 682.22

2.98 | 1.71
2.40 | 778.36
3.54 | 371.65
5.63 | 57.30
0.69 | 0.57
0.60 | 0.73
0.47 | 0.44

0.28 | 0.29

0.31 | 0.30
0.04 | 0.04
0.39 | 0.85

136 | 136
136 | 136
137 | 138
138 | 138
390 | 390
142 | 142
193 | 601

85 | 76
76 | 80
157 | 846
95 | 261
141 | 141
141 | 141
140 | 141

141 | 141

69 | 68
64 | 64
70 | 74

out.

ğ‘›IBSC | IBSC

U
U
U
U
56 | 56
U
32 | 29

U
14 | 14
16 | 16
14 | 14
8 | 8
8 | 8
U

9 | 9

U
2 | 2
5 | 5

unbounded
time
(sec)
ğ‘›IBSC | IBSC

0.06 | 0.05
0.05 | 0.06
0.06 | 0.06
0.06 | 0.07
21.64 | 21.60
0.91 | 0.91
20.96 | 1035.87

1.71 | 0.74
3.32 | 16.97
5.35 | 24.07
5.65 | 1227.02
0.72 | 0.76
0.72 | 0.72
0.30 | 0.34

0.27 | 0.28

0.25 | 0.25
0.04 | 0.04
0.40 |0.70

mem.
(MB)
ğ‘›IBSC | IBSC

64 | 64
64 | 61
64 | 64
64 | 64
393 | 390
70 | 70
123 | 383

74 | 68
80 | 205
86 | 164
89 | 294
69 | 69
69 | 69
66 | 67

67 | 67

69 | 69
64| 64
70 | 72

Table 2: Run-time performance for four case studies and 18 properties. We record the outcome (out.) of the algorithm with (IBSC) or without
(ğ‘›IBSC) the optimal solution guarantee: UNSAT (U), bounded-UNSAT (b-U), or the volume of the counterexample ğœ (a natural number, cor-
responding to volğœ ). We consider four different configurations: small (see Tab. 1) medium (x10), big (x100), and unbounded (âˆ) data domain
constraints and volume bound. The different volğœ between IBSC and ğ‘›IBSC are in bold.

NASA

configuration 1

configuration 2

IBSC
time mem.
(MB)
(sec)

nuXmv
time mem.
(MB)
(sec)

out.

out.

IBSC
time mem.
(MB)
(sec)

nuXmv
time mem.
(MB)
(sec)

out.

out.

U
U
U
U
U
U

U
U
U
U
U
U

U
U
U
U
U
U

U
U
U
U
U
U

90
90
90
91
90
90

154
141
141
80
140
62

141
141
141
66
141
62

ğ‘›ğ‘1
ğ‘›ğ‘2
ğ‘›ğ‘3
ğ‘›ğ‘4
ğ‘›ğ‘5
ğ‘›ğ‘6

0.88
0.47
0.49
0.54
0.52
0.57

0.13
0.15
0.13
0.15
0.15
0.03

0.80
0.16
0.16
0.77
0.14
0.03

1.65
1.50
1.48
1.43
1.43
1.40

82
70
83
83
82
72
Table 3: Run-time performance of our approach (IBSC) and the
state of the art model checker (nuXmv) on the NASA case study.
The configurations considered are described in Tab. 1. The configu-
rations considered are modifying the number of ground-separated
(#ğºğ‘†ğ¸ğ‘ƒ ) and of self-separating aircraft (#ğ‘†ğ‘†ğ¸ğ‘ƒ ) as follow, configu-
ration 1: #ğºğ‘†ğ¸ğ‘ƒ = 3 and #ğ‘†ğ‘†ğ¸ğ‘ƒ = 0; and configuration 2: #ğºğ‘†ğ¸ğ‘ƒ =
2 and #ğ‘†ğ‘†ğ¸ğ‘ƒ = 2.

configurations creates additional constraints in the SMT queries
for each relational object, and therefore results in a larger peak
memory than the unbounded configuration.

Finding the optimal solution (by IBSC), in contrast to finding
a satisfying solution without the optimal guarantee (by ğ‘›IBSC),
imposes a substantial computational cost while rarely achieving
a volume reduction. The non-optimal heuristic ğ‘›IBSC often out-
performed the optimal approach for satisfiable instances. Out of
31 satisfiable instances, ğ‘›IBSC solved 12 instances 3 times faster,
10 instances 10 times faster and seven instances 20 times faster
than IBSC. Compared to the non-optimal solution, the optimal so-
lution reduced the volume for only two instances: ğ‘â„7:large and
ğ‘â„7:unbounded by one (3%) and three (9%), respectively. On all
other satisfying instances, IBSC and ğ‘›IBSC both find the optimal
solutions. When there is no solution, both IBSC and ğ‘›IBSC are
equally efficient.

Results of the second experiment are summarized in Tab. 3. Our
approach and nuXmv both correctly verified that all six proper-
ties were UNSAT in both NASA configurations. We observe that

performance of our approach is comparable to nuXmv for the first
configuration with .10 to .20 seconds of difference on average. Yet,
for the second configuration, our approach terminates in less than
0.20 sec and nuXmv takes 1.50 seconds on average. We conclude
that our approachâ€™s performance is comparable to that of nuXmv
for LTL satisfiability checking even though our approach is not
specifically designed for LTL.

Summary. In summary, we have demonstrated that our approach
is effective at determining the bounded satisfiability of MFOTL
formulas using case studies with different sizes and from different
application domains. When restricted to LTL, our approach is at
least as effective as the existing work on LTL satisfiability checking
which uses the state of the art symbolic model checker. Impor-
tantly, IBSC can often determine satisfiability of instances without
reaching the volume bound, and its performance is insensitive to
data domain. A current limitation of IBSC is its inability to directly
support constraint over aggregated values in the input formulas.
As a walk-around, aggregated values are captured using auxiliary
predicates (e.g., the balance of a user in ğ‘â„7) and data constraints to
simulate the aggregation process (e.g., how the balance is updated
with respect to relevant data actions). However, the evaluation re-
sults shows that the walk-around costs the efficiency of IBSC. Thus,
we need to study how to extend IBSC to efficiently handle aggre-
gation. We also observed that IBSCâ€™s optimal guarantee imposes a
substantial computational cost while rarely achieving a volume re-
duction over non-optimal solutions obtained by ğ‘›IBSC. We need to
investigate the trade-off between optimality and efficiency, as well
as evaluate performance of IBSC on a broader range of benchmarks.

7 RELATED WORK
Below, we compare with the existing approaches for verifying legal
properties as well as with the approaches that address the satisfia-
bility checking of temporal logic and first-order logic.

Bounded Satisfiability Checking of
Metric First-Order Temporal Logic

Legal compliance. Various techniques have been proposed for
operationalizing legal provisions and ensuring that systems comply
with these provisions, e.g., [7, 19, 22, 39]. MFOTL has been used in
the context of runtime policy monitoring and enforcement, e.g., for
monitoring security policies [3] and data privacy rules [1]. While
our work is based on the same logic, our intended use case and the
type of reasoning we perform are different: we use MFOTL to spec-
ify requirements and properties and then look for legal-property
violations. Crucially, while previous work requires a system imple-
mentation, our approach enables early validation of legal property
compliance by checking the requirements.

Satisfiability checking of temporal properties. Temporal logic
satisfiability checking has been studied for the verification of system
designs. Satisfiability checking for Linear Temporal Logic (LTL) can
be performed by reducing the problem to model checking [37], by
applying automata-based techniques [29], or by SAT solving [6, 25â€“
27]. Satisfiability checking for metric temporal logic (MTL) [34]
and its variants, e.g., mission-time LTL [28] and signal temporal
logic [2], has been studied for the verification of real-time system
designs. These existing techniques are inadequate for our needs:
LTL and MTL cannot effectively capture quantified data constraints
commonly used in legal properties. MFOTL does not have such a
limitation as it extends MTL and LTL with first-order quantifiers,
thereby supporting the specification of data constraints.

Finite model finding for first-order logic. Finite-model find-
ers [9, 36] look for a model by checking universal quantifiers exhaus-
tively over candidate models with progressively larger domains;
we look for finite-volume solutions using a similar approach. On
the other hand, we consider an explicit bound on the volume of
the solution, and are able to find the solution with the smallest vol-
ume. SMT solvers support quantifiers with quantifier instantiation
heuristics [17, 18] such as E-matching [11, 12] and conflict-based
instantiation [35]. Quantifier instantiation heuristics are nonethe-
less generally incomplete, whereas, in our approach, we obtain
completeness by bounding the volume of the satisfying solution.

8 CONCLUSION
In this paper, we proposed an incremental bounded satisfiability
checking approach, called IBSC, aimed to enable verification of
legal properties, expressed in MFOTL, against system requirements.
IBSC first translates MFOTL formulas to first-order logic (FOL)
and then searches for a satisfying solution to the translated FOL
formulas in a bounded search space by deriving over- and under-
approximating SMT queries. IBSC starts with a small search space
and incrementally expands it until an answer is returned or until
the bound is exceeded. We implemented IBSC on top of the SMT
solver Z3. Experiments using five case studies showed that our
approach was effective for identifying errors in requirements from
different application domains.

To the best of our knowledge, we are the first to study satis-
fiability checking for MFOTL. Our approach is meant for use in
early-stage system development and to support building systems
that comply to legal properties before detailed behavioural models
or a system implementation become available.

Our approach is currently limited to verifying safety properties.
In the future, we plan to extend our approach so that it can handle

Report, September 8th, 2022,

broader property types, including liveness and fairness. IBSCâ€™s
performance and scalability depend crucially on how the domain
of relational objects is maintained and expanded (currently, this is
done using two heuristics). As a future work, we would like to study
the effectiveness of other heuristics to improve IBSCâ€™s scalability
(e.g., random restart, expansion with domain-specific heuristics).
We also aim to study how to learn/infer MFOTL properties during
the search to further improve the efficiency of our approach.

REFERENCES
[1] Emma Arfelt, David A. Basin, and SÃ¸ren Debois. Monitoring the GDPR.

In
Kazue Sako, Steve A. Schneider, and Peter Y. A. Ryan, editors, Computer Security
- ESORICS 2019 - 24th European Symposium on Research in Computer Security,
Luxembourg, September 23-27, 2019, Proceedings, Part I, volume 11735 of Lecture
Notes in Computer Science, pages 681â€“699. Springer, 2019.

[2] Kyungmin Bae and Jia Lee. Bounded model checking of signal temporal logic
properties using syntactic separation. Proc. ACM Program. Lang., 3(POPL):51:1â€“
51:30, 2019.

[3] David A. Basin, Felix Klaedtke, and Samuel MÃ¼ller. Monitoring security policies
with metric first-order temporal logic. In James B. D. Joshi and Barbara Carmi-
nati, editors, Proceedings of the 15th Symposium on Access Control Models and
Technologies (SACMATâ€™2010), Pittsburgh, Pennsylvania, USA, pages 23â€“34. ACM,
2010.

[4] David A. Basin, Felix Klaedtke, and Samuel MÃ¼ller. Policy monitoring in first-
order temporal logic. In Tayssir Touili, Byron Cook, and Paul B. Jackson, editors,
Computer Aided Verification, 22nd International Conference, CAV 2010, Edinburgh,
UK, July 15-19, 2010. Proceedings, volume 6174 of Lecture Notes in Computer
Science, pages 1â€“18. Springer, 2010.

[5] David A. Basin, Felix Klaedtke, Samuel MÃ¼ller, and Eugen Zalinescu. Monitoring

metric first-order temporal properties. J. ACM, 62(2):15:1â€“15:45, 2015.

[6] Marcello M. Bersani, Achille Frigeri, Angelo Morzenti, Matteo Pradella, Matteo
Rossi, and Pierluigi San Pietro. Constraint LTL satisfiability checking without
automata. J. Appl. Log., 12(4):522â€“557, 2014.

[7] Travis D. Breaux, Matthew W. Vail, and Annie I. AntÃ³n. Towards regulatory
compliance: Extracting rights and obligations to align requirements with regu-
lations. In 14th IEEE International Conference on Requirements Engineering (RE
2006), 11-15 September 2006, Minneapolis/St.Paul, Minnesota, USA, pages 46â€“55.
IEEE Computer Society, 2006.

[8] Roberto Cavada, Alessandro Cimatti, Michele Dorigatti, Alberto Griggio, Alessan-
dro Mariotti, Andrea Micheli, Sergio Mover, Marco Roveri, and Stefano Tonetta.
The nuxmv symbolic model checker. In CAV, pages 334â€“342, 2014.

[9] Koen Claessen and Niklas SÃ¶rensson. New techniques that improve mace-style
finite model finding. In Proceedings of the CADE-19 Workshop: Model Computation-
Principles, Algorithms, Applications, pages 11â€“27. Citeseer, 2003.

[10] Leonardo De Moura and Nikolaj BjÃ¸rner. Z3: An efficient smt solver. In Inter-
national conference on Tools and Algorithms for the Construction and Analysis of
Systems, pages 337â€“340. Springer, 2008.

[11] Leonardo MendonÃ§a de Moura and Nikolaj BjÃ¸rner. Efficient e-matching for SMT
solvers. In Frank Pfenning, editor, Proceedings of the 21st International Conference
on Automated Deduction (CADEâ€™2007), Bremen, Germany, volume 4603 of Lecture
Notes in Computer Science, pages 183â€“198. Springer, 2007.

[12] David Detlefs, Greg Nelson, and James B. Saxe. Simplify: a theorem prover for

program checking. J. ACM, 52(3):365â€“473, 2005.

[13] Nick Feng, Lina Marsso, and Hubert Garavel. Health record. Model checking
context model (MCCâ€™21), Dept. of Computer Science - University of Toronto,
2021.

[14] Marco Gario, Alessandro Cimatti, Cristian Mattarei, Stefano Tonetta, and
Kristin Yvonne Rozier. Model checking at scale: Automated air traffic control
design space exploration.
In Swarat Chaudhuri and Azadeh Farzan, editors,
Proceedings of the 28th International Conference on Computer Aided Verification
(CAVâ€™2016), Toronto, ON, Canada, volume 9780 of LNCS, pages 3â€“22. Springer,
2016.

[15] Marco Gario and Andrea Micheli. Pysmt: a solver-agnostic library for fast

prototyping of smt-based algorithms. In SMT Workshop 2015, 2015.

[16] Paul Gastin, Pierre Moro, and Marc Zeitoun. Minimization of counterexamples
in SPIN. In Susanne Graf and Laurent Mounier, editors, Proceedings of the 11th
International Workshop on Model Checking Software (SPINâ€™04), Barcelona, Spain,
volume 2989 of Lecture Notes in Computer Science, pages 92â€“108. Springer, 2004.
[17] Yeting Ge, Clark W. Barrett, and Cesare Tinelli. Solving quantified verification
conditions using satisfiability modulo theories. In Frank Pfenning, editor, Pro-
ceedings of the 21st International Conference on Automated Deduction (CADEâ€™2007),
Bremen, Germany, volume 4603 of Lecture Notes in Computer Science, pages 167â€“
182. Springer, 2007.

Report, September 8th, 2022,

Nick Feng, Lina Marsso, Mehrdad Sabetzadeh, and Marsha Chechik

[39] Damiano Torre, Mauricio AlfÃ©rez, Ghanem Soltana, Mehrdad Sabetzadeh, and
Lionel C. Briand. Model driven engineering for data protection and privacy:
Application and experience with GDPR. CoRR, abs/2007.12046, 2020.

[18] Yeting Ge and Leonardo MendonÃ§a de Moura. Complete instantiation for quanti-
fied formulas in satisfiabiliby modulo theories. In Ahmed Bouajjani and Oded
Maler, editors, Proceedings of the 21st International Conference on Computer Aided
Verification (CAVâ€™2009), Grenoble, France, volume 5643 of Lecture Notes in Com-
puter Science, pages 306â€“320. Springer, 2009.

[19] Sepideh Ghanavati, Daniel Amyot, and Liam Peyton. Towards a framework for
tracking legal compliance in healthcare. In John Krogstie, Andreas L. Opdahl, and
Guttorm Sindre, editors, Advanced Information Systems Engineering, 19th Interna-
tional Conference, CAiSE 2007, Trondheim, Norway, June 11-15, 2007, Proceedings,
volume 4495 of Lecture Notes in Computer Science, pages 218â€“232. Springer, 2007.
[20] Sylvain HallÃ© and Roger Villemaire. Runtime enforcement of web service message

contracts with data. IEEE Trans. Serv. Comput., 5(2):192â€“206, 2012.

[21] Ian M. Hodkinson. Loosely guarded fragment of first-order logic has the finite

model property. Stud Logica, 70(2):205â€“240, 2002.

[22] Shareeful Islam, Haralambos Mouratidis, and Stefan Wagner. Towards a frame-
work to elicit and manage security and privacy requirements from laws and
regulations. In Roel J. Wieringa and Anne Persson, editors, Proceedings of the
16th International Conference on Requirements Engineering: Foundation for Soft-
ware Quality (REFSQâ€™2010), Essen, Germany, volume 6182 of LNCS, pages 255â€“261.
Springer, 2010.

[23] Daniel Jackson. Alloy: a lightweight object modelling notation. ACM Trans.

Softw. Eng. Methodol., 11(2):256â€“290, 2002.

[24] Legislative Assembly of Ontario. Personal health information protection act

(PHIPA), 2004.
https://www.ontario.ca/laws/statute/04p03.

[25] Jianwen Li, Geguang Pu, Lijun Zhang, Moshe Y. Vardi, and Jifeng He. Accelerating
LTL satisfiability checking by SAT solvers. J. Log. Comput., 28(6):1011â€“1030,
2018.

[26] Jianwen Li, Geguang Pu, Yueling Zhang, Moshe Y. Vardi, and Kristin Y. Rozier.
Sat-based explicit ltlf satisfiability checking. Artif. Intell., 289:103369, 2020.
[27] Jianwen Li, Kristin Y. Rozier, Geguang Pu, Yueling Zhang, and Moshe Y. Vardi.
Sat-based explicit ltlf satisfiability checking. In The Thirty-Third AAAI Confer-
ence on Artificial Intelligence, AAAI 2019, The Thirty-First Innovative Applications
of Artificial Intelligence Conference, IAAI 2019, The Ninth AAAI Symposium on
Educational Advances in Artificial Intelligence, EAAI 2019, Honolulu, Hawaii, USA,
January 27 - February 1, 2019, pages 2946â€“2953. AAAI Press, 2019.

[28] Jianwen Li, Moshe Y. Vardi, and Kristin Y. Rozier. Satisfiability checking for
In Isil Dillig and Serdar Tasiran, editors, Computer Aided
mission-time LTL.
Verification - 31st International Conference, CAV 2019, New York City, NY, USA,
July 15-18, 2019, Proceedings, Part II, volume 11562 of Lecture Notes in Computer
Science, pages 3â€“22. Springer, 2019.

[29] Jianwen Li, Lijun Zhang, Geguang Pu, Moshe Y. Vardi, and Jifeng He. LTL
satisfiability checking revisited. In Proceedings of the 20th International Symposium
on Temporal Representation and Reasoning, Pensacola, FL, USA, 2013, pages 91â€“98.
IEEE Computer Society, 2013.

[30] Cristian Mattarei, Alessandro Cimatti, Marco Gario, Stefano Tonetta, and Kristin Y.
Rozier. Comparing different functional allocations in automated air traffic control
design. In Roope Kaivola and Thomas Wahl, editors, Formal Methods in Computer-
Aided Design (FMCADâ€™2015), Austin, Texas, USA, pages 112â€“119. IEEE, 2015.
[31] Nina Narodytska and Fahiem Bacchus. Maximum satisfiability using core-guided
maxsat resolution. In Carla E. Brodley and Peter Stone, editors, Proceedings of
the 28th International Conference on Artificial Intelligence (AAAIâ€™14), QuÃ©bec City,
Canada, pages 2717â€“2723. AAAI Press, 2014.

[32] Christos H. Papadimitriou. On the complexity of integer programming. J. ACM,

28(4):765â€“768, 1981.

[33] Emil L. Post. Recursive unsolvability of a problem of thue. J. Symb. Log., 12(1):1â€“

11, 1947.

[34] Matteo Pradella, Angelo Morzenti, and Pierluigi San Pietro. Bounded satisfiability
checking of metric temporal logic specifications. ACM Trans. Softw. Eng. Methodol.,
22(3):20:1â€“20:54, 2013.

[35] Andrew Reynolds, Cesare Tinelli, and Leonardo MendonÃ§a de Moura. Find-
ing conflicting instances of quantified formulas in SMT. In Formal Methods in
Computer-Aided Design (FMCADâ€™2014), Lausanne, Switzerland, pages 195â€“202.
IEEE, 2014.

[36] Andrew Reynolds, Cesare Tinelli, Amit Goel, Sava Krstic, Morgan Deters, and
Clark W. Barrett. Quantifier instantiation techniques for finite model finding in
SMT. In Maria Paola Bonacina, editor, Automated Deduction - CADE-24 - 24th
International Conference on Automated Deduction, Lake Placid, NY, USA, June
9-14, 2013. Proceedings, volume 7898 of Lecture Notes in Computer Science, pages
377â€“391. Springer, 2013.

[37] Kristin Y. Rozier and Moshe Y. Vardi. LTL satisfiability checking. In Dragan
Bosnacki and Stefan Edelkamp, editors, Proceedings of the 14th International
Workshop on Model Checking Software (SPINâ€™07), Berlin, Germany, volume 4595
of Lecture Notes in Computer Science, pages 149â€“167. Springer, 2007.

[38] Lijun Shan, Behrooz Sangchoolie, Peter Folkesson, Jonny Vinter, Erwin Schoitsch,
and Claire Loiseaux. A survey on the application of safety, security, and privacy
standards for dependable systems. In Proceedings of the 15th European Dependable
Computing Conference (EDCCâ€™2019), Naples, Italy, pages 71â€“72. IEEE, 2019.

