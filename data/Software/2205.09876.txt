2
2
0
2

l
u
J

4
1

]
h
p
-
p
e
h
[

3
v
6
7
8
9
0
.
5
0
2
2
:
v
i
X
r
a

Hunting for vampires and other unlikely forms
of parity violation at the Large Hadron Collider

Christopher G. Lester∗1, Radha Mastandrea∗2, Daniel Noel∗1, and
Rupert Tombs∗1

1Cavendish Laboratory, University of Cambridge, CB3 0HE, United Kingdom
2Department of Physics, University of California, Berkeley, CA 94720, USA

13th July 2022

Abstract

Non-Standard-Model parity violation may be occurring in LHC collisions. Any
such violation would go unseen, however, as searches are for it are not currently
performed. One barrier to searches for parity violation is the lack of model-
independent methods sensitive to all of its forms. We remove this barrier by
demonstrating an eﬀective and model-independent way to search for parity-
violating physics at the LHC. The method is data-driven and makes no reference
to any particular parity-violating model. Instead, it inspects data to construct
sensitive parity-odd event variables (using machine learning tools), and uses these
variables to test for parity asymmetry in independent data. We demonstrate
the eﬃcacy of this method by testing it on data simulated from the Standard
Model and from a non-standard parity-violating model. This result enables the
possibility of investigating a variety of previously unexplored forms of parity
violation in particle physics.

Data and software are shared at https://zenodo.org/record/6827724.

1

Introduction

Sources of parity violation which are due to eﬀects beyond the Standard Model
have the potential to be observed in Large Hadron Collider data. Alas, there
are many new and unexpected ways in which parity can be violated, and no
continuous parity-odd event variable is sensitive to them all [1]. Furthermore,
since there are not many commonly-studied1 theoretical models which predict
forms of parity violation which could be visible at the LHC, there are few guides

∗Authors are listed in alphabetical order.
1See later comments that BSM parity-violation models, if they are to have observable signals
in the context of this work, must abandon at least one of: (i) locality, (ii) Lorentz-invariance,
or (iii) a basis in quantum ﬁeld theory. Vampires are not visible when mirrored [2] and so
presumably the laws of physics describing them derive their parity-violation from the loss of at
least one of the above three properties!

1

 
 
 
 
 
 
as to where and how to look for non-standard parity-violating signals. The
absence of practical, general, and scalable ways of performing such searches has
been, until very recently, a signiﬁcant barrier to performing them.2

The primary purpose of this paper is to demonstrate that the data-driven
parity-violation search strategies proposed by [4] and [5] are, in fact, capable of
removing the above barrier to realistic searches for parity violation in particle
physics. Our work is necessary because the methods proposed in [4] are demon-
strated only with toy examples from outside of particle physics, while those
in [5] use neither real nor simulated particle physics datasets holding signatures
of parity-violation. The present work will demonstrate the viability of the new
approaches by showing sensitivity to a range of parameters within an example
parity-violating model, which is described within the Lorentz-invariance violating
framework of the minimal Standard Model Extension [6]. For this model, we
generate Monte Carlo simulated events assuming a barrel-shaped LHC detector
such as ATLAS, CMS, or ALICE.

Speciﬁcally, [4] points out that a clear signal for parity violation can be
obtained from a parity-odd event variable if it is seen to have an asymmetric
distribution. An optimization using one part of a dataset can be used to create
such a variable, while another part of the dataset can be used to test for the
suspected asymmetry in the distribution of that variable. For the reasons
given in [4], this method presents a very general, ﬂexible, and scalable way of
maintaining sensitivity to all potential source of new physics which are able to
generate events which are distinguishable (in distribution) from their parity-
ﬂipped partners — that is to say any models with ‘manifestly’ parity violating
signatures. Whether any given source is observable would, of course, always
depend on the sizes of systematic uncertainties and the amount of data taken.
It would also depend on whether the particular choice of parity-odd function(s)
that someone implementing [4] had decided to use were sensitive to the form of
parity violation which the given source induces in its events. However, those are
questions of implementation rather than intrinsic limitations. The generality of
the method itself is an unavoidable consequence of the fact that it is, in eﬀect,
simply a codiﬁcation of what it means for a model to have ‘manifestly’ parity
violating consequences. In this sense, electing to use [4] does not place limits on
what can be seen.

Known ineﬃciencies and acceptance eﬀects, which act to ﬁlter data from
observation in the detector, can also be easily corrected for in the manner
described in [5] if they are well understood. Such ﬁltering eﬀects are not,
however, included in any detector models in this work.

Our approach can be viewed as an adoption of standard practice from the
ﬁeld of machine learning:
in training, a general-purpose ‘machine’ generates
hypotheses about the structure of the data distribution. Then in testing, those
hypotheses are tested on independent data. By doing this with parity-odd
algorithms, success in the testing phase becomes evidence for parity violation.
Various end-stage techniques could be used to assess the strength of that
evidence. To follow existing practice for LHC searches, the parity-odd variables

2Only a single search, [3], has been performed on real LHC data so far! Furthermore, [3]
described many of its own choices as arbitrary and lacking in any strong theoretical motivation
or generality. As a result, its null result is of limited value, even if there is value in the
existence of the work as a proof-of-principle that data-data searches for non-standard sources
of parity-violation can be performed.

2

can be histogrammed and interpreted with conventional statistical methods.
This approach, which we illustrate in Appendix A.1, allows one to implement
systematic uncertainties at testing time as histogram variations that allow weakly
broken parity symmetry

The nature of parity violation and its possible visibility at the LHC is
discussed in Section 2. Parity-violating physics in an example quantum ﬁeld
theory, and the simulation of its eﬀects, are described in Section 3. Machine
learning implementations of parity-odd, symmetry-invariant event variables are
presented in Section 4. The varied successes of these variables in detecting parity
violation in simulated data are displayed in Section 5.

2 Parity violation at the LHC

It is experimentally possible to see parity violation in particle physics data.
Whether it will be seen depends both on whether nature produces parity violating
eﬀects and whether the appropriate data analysis is performed.

Particles and particle physics data are typically described as being sampled
from a diﬀerential cross-section σ(x), where x is some representation of those
data. We would like to test whether σ(x) violates parity symmetry; that is,
we want to answer the question “is σ(x) diﬀerent from σ(Px)?” for the parity
operator P. However, we have ﬁnite data. With ﬁnite data, asymmetries may
be too subtle to notice, and with continuous distributions asymmetries may hide
in intricate patterns which we as analysts would never think to check. We can,
however, take opportunities to disprove parity symmetry if nature happens to
give clear signals.

We can maintain sensitivity to all forms of parity violation by considering only
parity-odd event variables [1].3 To test parity symmetry, we can therefore take
any parity-odd event variable f (x), for which f (x) = −f (Px), and compare the
positive and negative halves of its distribution under σ(x). If parity symmetry
is respected by σ(x), then events and their parity-ﬂipped versions must all be
produced at equal rates. Equivalently, there must be equal event rates at all ±f
points. However, if an experiment sees an asymmetric distribution in f (x), for
example by histogramming many data, then parity symmetry must be violated
in σ(x).

Hadron-hadron collisions, such as those currently produced at the LHC, have
many symmetries. Two identical, unpolarized beams are collided head-on (to
a good approximation), and, since physical space is known to be isotropic (to
a very good approximation), the scattering processes must be invariant to all
rotations which do not change the beams. These rotations include both those
about the beam axis (by any angle), and those which swap the two beams by
rotating 180◦ about a perpendicular axis. Furthermore, data often comprise
unordered sets of four-momenta for otherwise-identical particles; although these
always take some conventional order in practice, nature does not care about any
ordering we assign.

When analysing such symmetric data, it is helpful to be blind to trans-
formations under their symmetries; otherwise, the handling of symmetrically

3This statement is precisely formulated in Theorem 2.26 and summarized in Section 2.9 of [1].
Essentially, the absolute value of a parity-odd variable is parity-even, and all parity-asymmetric
variables can be constructed as functions of even and odd parts.

3

equivalent, yet diﬀerently represented data introduces unnecessary complexity.
This is one beneﬁt of rotation-invariant event variables at the LHC, such as those
based on masses or transverse momenta pT, and to collapsing the permutation
symmetry of particles by pT-ordering their representations.

Furthermore, our aim is only to test for violation of parity symmetry, and
not for violations of other symmetries such as spacetime isotropy. Blinding our
analysis to violations of other symmetries, therefore, helps the method to focus
more precisely on the task of testing parity violation itself. For these reasons,
when constructing parity-odd event variables in this paper, we choose to make
them also rotation-, beam-swap- and permutation-invariant. This invariance is
achieved by design in both data representations and function architectures.

One example of a parity-odd, rotation-, beam-swap- and permutation-invariant

event variable is

α = arcsin

(cid:18) (cid:126)p j1 × (cid:126)p j2
|(cid:126)p j1 × (cid:126)p j2 |

(cid:19)

·

(cid:126)p j3
|(cid:126)p j3 |

(1)

in which (cid:126)p ji is the momentum of the ith hardest jet. This α variable was proposed
and used in [3] to demonstrate that parity violation can be searched for in events
with three or more jets. It has rotation invariance from the basis-independence
of dot and cross products, permutation invariance from the pT-ordering of jets,
and parity-oddness since the three momentum vectors each pick up a factor
of −1 under the parity ﬂip. It also has, however, “no claims of generality or
optimality” [3]. Indeed, Figure 1 illustrates that it does not have good sensitivity
to parity violation in a sample of simulated data, described below in Section 3,
while an observable f , created using the methods of this paper, does.

Unfortunately, parity violation in data does not necessarily imply parity
violation in nature. Data result from compositions of natural physical processes
with the actions of experimental hardware and software, and any of these parts
could introduce asymmetries. Fortunately, any detector eﬀect that can be
anticipated and that acts as a ﬁlter (reducing data rates in certain selections),
can be removed (i.e., the possibility of false positive excluded) using the method
of [5].

Nonetheless, unknown unknowns could still cause problems. A positive signal
for parity violation therefore provides either: (a) evidence for parity violation
in nature, or (b) evidence for detector eﬀects and/or calibrations that need to
be improved. Both possibilities are interesting and valuable, since one tells
us something new about nature, while the other tells us how to improve our
detector calibrations which will beneﬁt other analyses (even those not interested
in symmetry violations) being performed by the same detector.

3 Parity violating physics

3.1 PV-mSME (Parity Violating minimal Standard Model

Extension)

Nature may, one day, not be described by a quantum ﬁeld theory (QFT). At
present, however, the majority of existing theories are QFTs, and so we choose
to illustrate our method with one. Locally Lorentz invariant QFTs which violate

4

Figure 1: Distributions of two diﬀerent parity-odd variables for the same parity-
violating model of physics: (left) α as deﬁned in Equation 1 and (right) a
parity-odd neural network looking at reconstructed jet momenta. Samples
are normalized to the Standard Model cross-section at 1 fb−1 of LHC
s =
13 TeV proton-proton collision data. The histograms contain only data from an
independent testing set containing 20% of the total yield. Each function F (·)
is a transformation ﬁtted to training data to make each distribution close to
uniform. Error bars are of size ±
n to show the size of statistical uncertainty
at the chosen luminosity.

√

√

parity4 must necessarily violate charge-parity (CP) symmetry for the reason
explained in Footnote 1 of [3]. Although one could therefore choose to illustrate
our method by searching for parity violation in a CP-violating model, doing so is
unlikely to be competitive with pre-existing methods as tests of CP-violation are
highly developed with a mature ﬁeld; in any case, the amount of CP-violation in
the Standard Model is known to be small.

We therefore choose to use a Lorentz-violating extension of the Standard
Model, namely the ‘minimal Standard Model Extension’ (mSME) of [6]. We do
not work with the full generality of the mSME, but instead use only a small
subset of its parity-violating sector, which we name the ‘PV-mSME’. Within
the PV-mSME, we control the strength of parity violation with a single real
parameter λPV, which is described below.

The mSME makes many extensions to the Standard Model, among which is
a term LCPT-even
(deﬁned in Equation 11 of [6]) which modiﬁes the quark-quark-
gluon Feynman Rule. We choose to use only this extension from the mSME, in
order to generate parity violation in strongly produced multi-jet events, which
are attractive to study since they have large cross-sections at the LHC and are
not expected to show parity violation in the Standard Model. Multi-jet events
were also previously studied parity violation in [3]. Furthermore, we choose
couplings to switch on only its axial vector part with the intention of violating

quark

4To be precise, one should say: ‘Locally Lorentz invariant QFTs for which parity violation
is theoretically observable in data derived from collisions of unpolarized particles in the case
that the ﬁnal-state event data recorded contain only four-momenta which are not decorated
with additional labels (such as helicities or ﬂavours).

5

parity in interference with the Standard Model vector interactions.

The Standard Model quark-quark-gluon vertex from takes the form

f SM
ν = −igs

λa
ij
2

γν,

(2)

to which the PV-mSME adds an axial vector part shaped by a coupling matrix
(cA)µν,

f PV-mSME
ν

= −igs

λa
ij
2

(cid:0)γν + γµ(cA)µνγ5λPV

(cid:1) ,

(3)



in which the strength parameter λPV is varied to control the magnitude of parity
violation in the model. Motivated by reasons given in Appendix C, we deﬁne
(cA)µν to be


0
0


0

1





(cA)µν =

0
0 −1
0
1
0
0
such that the value λPV = 1 results in PV-mSME terms having similar magni-
tudes to Standard Model terms in matrix elements. Clearly, the Standard Model
is recovered for λPV = 0.

0 −1
0
0
0

Although we are not aware of direct constraints on this exact usage of the
mSME, data from astrophysics and deep inelastic scattering have been used
to limit the couplings in this mSME quark sector to very small values of at
most 10−4 in magnitude [7, 8]. Large λPV values would therefore be excluded by
current data if tested.

(4)

Unlike the common background-plus-signal scenario, PV-mSME cross-sections
do not add linearly since they interfere with the Standard Model, nor do they
scale linearly with the coeﬃcient λPV. Indeed, squared matrix elements computed
from a diagram with n quark-quark-gluon vertices will, in general, contain terms
with all powers from (λPV)0 up to and including (λPV)2n.

Couplings in the mSME break spatial isotropy; they induce special spatial
directions in which particles have diﬀering behaviours. Having constant couplings,
as we do from Equation 4, therefore ignores rotations of the detector through
space. Detectors at the LHC do, in fact, rotate — with Earth through the day,
and about the sun throughout the year, and so on. Rotations could be controlled
for, for example, by selecting data from only times when the detector is aligned
within a small solid angle of a special direction, or by relocating the LHC to a
non-rotating spaceship. Neither solution is practical, since the ﬁrst slashes the
event rate, and the second is beyond CERN’s budget. Alternatively, one could
employ a diﬀerent, fully rotation-aware method of data generation and analysis,
which we discuss further in Appendix A.4.

Faced with the decision of whether to account for the Earth’s rotation, we
elect to make no correction and choose to leave our PV-mSME coupling matrixes
constant in the laboratory frame. In eﬀect, this means we are working with a
model in which Lorentz violating couplings are ‘dragged around’ by Earth, or
where Earth does not spin. We make this choice, despite it being unphysical,
because making those corrections would complicate the analysis without adding
anything useful. Moreover, if we were to correct for Earth’s rotations we would

6

be building assumptions into our analysis that are not explicitly related to parity,
and we do not wish to do so.

Alternatively, our choice of constant couplings could be implemented by
selecting data collected at dates and times when the detector aligned with a
special direction. In reality, direction dependence might be handled better by
encoding the detector’s alignment in additional event variables, so that algorithms
can learn alignment-dependent parity violation. We demonstrate a simple form
of this rotation-encoding in Appendix A.4, and ﬁnd that weaker signals of parity
violation can still be observed in the PV-mSME on a rotating planet.

Despite this unphysical use of the mSME, our PV-mSME remains a parity
violating quantum ﬁeld theory, and provides a parity violating model with which
we can demonstrate our methods

3.2 Simulation

A complete simulation pipeline is performed to produce realistic simulations of
proton-proton collisions scattering to jets in the PV-mSME with various settings
of λPV between 0 and 1. This pipeline comprises several standard steps: partons
are ﬁrst simulated in a hard scatter of protons to three or four gluons or light
quarks,5 then dressed with an underlying event, parton shower and pileup overlay,
and hadronized into observable particles. A detector response to these energetic
particles is simulated and processed into event variables.

We introduce PV-mSME eﬀects through matrix elements in the hard scat-
ter only; any changes that it should make to parton distributions, showering,
hadronization, and detector physics are ignored in this work.

Triggering is modelled by selecting only events with at least three central
jets with pT > 220 GeV; this selection is designed to approximate the eﬃciency
plateau of the three-jet trigger in a general-purpose LHC detector.

Details of the simulation software and settings are given in Appendix B.
Although we primarily target events with three jets, we include four-parton
processes at truth level as a sub-leading eﬀect to increase physical accuracy.
At reconstruction level after kinematic selections, the Standard Model cross-
section of this multi-jet process is 0.22 nb of which 0.7% is attributed to four-
parton processes at truth level. This increases with λPV to 0.31 nb (9%) for
λPV = 0.3 and 2.6 nb (27%) for λPV = 1. Evidently, large λPV drastically
increases production rates and jet multiplicities. Kinematic shapes also change
signiﬁcantly, as demonstrated in Figure 2. Our interest, however, is in the
parity violation of these kinematic distributions, independent of other eﬀects.
We therefore normalize the PV-mSME distributions to the Standard Model
cross-section wherever relevant.

3.2.1 Data formats

Simulation results are processed into two kinds of event variables for analysis;
the ﬁrst is standard, using estimated four-momenta of jets, while the second
bypasses jet reconstruction to produce low-resolution images of energy deposits
in the (cylindrical) calorimeters, projected into the η–φ plane, where η is the
pseudorapidity and φ is an angle about the beam pipe.

5Note that a 2 → 2 scattering process could never be parity violating, as all participating

4-momenta lie in a plane.

7

Figure 2: Distributions of kinematic variables of reconstructed jets with varied
λPV in the PV-mSME. (left) Transverse momentum of the hardest jet and (right)
the scalar sum of transverse momenta of the hardest four jets in the event. The
ﬁve coloured lines linearly interpolate from the Standard Model (λPV = 0) to
λPV = 1.

These images consist of 32 × 32 pixels that cover the entire 2π range in
φ and |η| < 3.2, which corresponds to the extent of the ATLAS calorimeters,
excluding the forward calorimeter [9]. Images are constructed either directly
from calorimeter energy deposits or indirectly from jets by histogramming their
transverse momenta in two-dimensional η–φ histograms, where every jet with
pT > 30 GeV and |η| < 2.8 is included. Images of an example event are shown
in Figure 3.

To assess both how sensitivity degrades with noise and how well machine
learning tools perform with diﬀerent data formats, we use three representations
of the simulated data. These are:

• ‘truth-jet’: the true momenta of partons from the hard scatter,

• ‘reco-jet’: reconstructed momenta of the four hardest jets, and

• ‘calo-image’: images of calorimeter energy deposits.

The next section describes how of these data representations is used with each
machine learning model.

4 Methods

As stated in Section 2, we can search for parity-violating physics using a parity-
odd event variable f (x). Such a variable can easily be constructed from an
arbitrary function g(x) since

f (x) = g(x) − g(Px)

(5)

8

Figure 3: Energy deposits in the calorimeter (left) and the pT of reconstructed
jets (right) for an example Standard Model event.

is parity odd.6 All of our models use this construction. Machine learning
algorithms present practical, general, and scalable ways to assign functional
forms to g(x), and our method does not depend on the exact algorithm chosen.
To demonstrate that, we use boosted decision trees (BDTs), neural networks
(NNs), and convolutional neural networks (CNNs) to build the functions g(x).
The BDT and NN approaches use vectors of jet momentum features derived
from truth-jet and reco-jet data, whereas the CNN approach uses either calo-
image data or jet features transformed into images as described in Section 4.1.2.

4.1 Symmetries

We ensure that rotational and permutation symmetries are preserved in our
parity-odd event variables, for reasons discussed in Section 2. This section
describes how those symmetries are enforced for the various models and data
formats.

4.1.1

Invariant jets

Jet permutation symmetry is ensured by sorting objects from hardest to softest
in pT. Invariance to rotations (along and about the beam axis) is ensured by
rotating all momenta to an orthonormal basis {ˆx, ˆy, ˆz} based on the hardest jet
momentum (cid:126)p j1; ˆx is taken in the transverse direction of (cid:126)p j1 , ˆz is taken along
the beam axis with the sign of its longitudinal momentum (cid:126)p j1
, and the third
z
basis vector is taken as their cross product; ˆy = ˆz × ˆx.

Mutual transformation of the hardest jet with all other momenta under
rotations means that the projection of momenta onto this basis is unchanged
under rotations (up to numerical precision). Deﬁning each element of momentum
a = (cid:126)p ji · ˆa for a ∈ {x, y, z}, it is clear
in this new rotation-invariant basis as (cid:126)q ji
6Numerically, this works for all numbers except signed zeros, since if g(x) − g(Px) = +0.0,
then g(Px) − g(x) = +0.0, not −0.0, in standard ﬂoating-point arithmetic. Zeros of f (x) must
therefore be excluded from parity-odd interpretations.

9

that (cid:126)q j1
deﬁnition and not useful, so we discard it.

y = (cid:126)p j1 · ˆy = 0. That is, the y component of the hardest jet is zero by

Parity ﬂipping momenta in laboratory coordinates leads only to changing

the signs of (cid:126)q ji
y

components, since under parity

ˆx → −ˆx ,
ˆz → −ˆz , but
ˆy → −ˆz × −ˆx = +ˆy ;

(6)

(7)

(8)

and (cid:126)q ji
z

components are parity-even, and (cid:126)q ji
y

the (cid:126)q ji
components are parity-odd.
x
Both parity-odd and parity-even event variables can be useful in the search for
parity violation; although parity-ﬂipped events diﬀer only in their parity-odd
parts, the even parts are context which can be required to separate regions in
which the parity ﬂipped versions occur at diﬀerent rates [10].

4.1.2

Invariant images

Invariance to rotations (about and along the beam axis) is built into the CNN
structure. For invariance to φ-rotations, note that a rotational symmetry in φ
corresponds to a wrap-around translational symmetry in φ when considering the
η–φ plane.

Each image is padded cyclically around the φ axis before applying each
convolutional layer; this maintains equivariance. Invariance to φ rotations is
achieved by performing a max-pool operation over the entire φ-axis after the
convolutions. This pooling selects the largest pixel value for each slice in φ,
which is clearly invariant to φ rotations of those pixels. This design gives perfect
invariance to discrete rotations of 2π/32, but the CNN is not perfectly blind to
other rotations prior to pixelization; this could incur some costs for the reasons
discussed in Section 2 which encourage invariance.

For invariance to discrete beam-ﬂip rotations, Rπ (rotation by 180◦ about
an axis perpendicular to the beams), we construct Rπ-invariant g(x) functions
(of Equation 5) as g(x) = h(x) + h(Rπx), similarly to how parity-oddness is
achieved. Then,

f (x) = [h(x) + h(Rπx)] − [h(Px) + h(RπPx)],

(9)

and we learn a form for h(x) with a CNN. This maintains the parity-odd property
f (x) = −f (Px) and introduces the beam-ﬂip symmetry f (x) = f (Rπx), since
RπRπx = x.

The parity ﬂip operator transforms η → −η and φ → φ + π mod 2π. With
the rotationally invariant CNN, φ changes are inconsequential, so the parity ﬂip
operator is just a negation of η, or equivalently a mirror image through the line
η = 0.

An example event image is shown in Figure 4, along with its transformed
copies. From the network outputs reported in the caption, we see that the
network is indeed parity-odd whilst being symmetric to beam-ﬂips. In addition,
by comparing the outputs with a translation in φ, we can see that the network
is invariant to translations in φ. This illustrates how a parity ﬂip on an image in
the η–φ plane is equivalent to a ﬂip in η.

10

(a)

(b)

(c)

(d)

Figure 4: Histogrammed pT of reconstructed jets for a Standard Model event
projected in the η–φ plane. (a) the original event image (b) rotated 180° about
the x-axis (c) parity ﬂipped (d) parity ﬂipped and rotated by π/2 in φ. The net
output f (x) is −0.132 for (a) and (b), and 0.132 for (c) and (d); the symmetries
we build into the network can be identiﬁed here.

11

4.2 Training

Models are trained from gradients of the ‘which is real?’ objective function
introduced in [5], which is a special case of the standard ‘cross-entropy’ (negative
binomial log-likelihood) loss function [11] for binary classiﬁcation. Its class labels
are the ‘real–fake’ or ‘fake–real’ orderings of an {x, Px} or {Px, x} pair, where
each pair contains both a real observed event x and its parity-ﬂipped ‘fake’
representation Px. Since the function being trained is parity odd, taking the
form of Equation 5, this loss is the same whether looking at orderings {x, Px}
with label real-fake or {Px, x} with label fake-real. We can therefore make every
label real–fake without consequence, and use the loss function

Lwhich-is-real? = −

= −

1
N

1
N

N
(cid:88)

i=1

N
(cid:88)

i=1

log p(real–fake | {xi, Pxi})

− log(1 + e−f (x))

(10)

(11)

for a batch of N events, which follows from our choice to convert f to a probability
through the logistic function. Functional forms for f (x) are assigned by machine
learning models through their stochastic optimizations of this loss function.

Just as classiﬁers end up learning divergences between data distributions, this
process learns divergences between the data distribution and its parity ﬂipped
version. Since probabilities assigned by classiﬁers are invertible to likelihood
ratios, classiﬁers approximate optimal event variables for separating their target
classes, and indeed they have become standard practice for this task in high
energy physics. By the same reasoning, the parity-odd functions constructed
here approximate optimal event variables for separating events from their parity-
mirror images.

As an evaluation metric, we compare each learned model to the parity-
symmetric hypothesis, which assigns probability psym = 1/2 to each ordering.
The mean log-likelihood ratio between these models is

Q =

1
N

N
(cid:88)

i=1

log p(real–fake | {xi, Pxi}) − log

1
2

,

(12)

which is positive only if the parity-odd model has made better predictions than
the parity-even psym.

For perfect classiﬁcation, where each event is unambiguously distinguished
from its parity-ﬂipped counterpart, p(real–fake | {xi, Pxi}) = 1 for all events,
and Q has a maximum of log 2 ≈ 0.693. If both asymmetric and symmetric
models predict equally well, then Q takes a value of 0, and Q is not bounded
from below.

A positive Q with suﬃciently large N is evidence for parity violation, since
they imply a large likelihood ratio. We also present error bars for estimates of
the limiting value of Q as N → ∞, which are constructed in the usual way from
the mean and standard deviation of its summands.

4.3 Machine learning models

This section details the BDT, NN and CNN machine learning algorithms we
use for the results in this paper. The dataset is split into subsets training : val-

12

idation : testing in the ratio 60 : 20 : 20. Initial tuning was performed on the
training and validation sets, primarily aiming for sensitivity to the λPV = 1.
Early stopping methods are used to increase robustness to data from diﬀerent
models. The testing set was not looked at until all models and data were ﬁnalized
in preparation of the results presented in this paper.

For input features, both the BDT and NN models use only jet momenta
from the truth-jet or reco-jet datasets in the rotation-invariant coordinates (cid:126)q ji
a
of Section 4.1.1. Where no fourth jet exists, we set its momenta to zero. No
derived features are included. Separately, the CNN model processes only image
data.

4.3.1 Boosted decision tree

The BDT uses XGBoost [12] in its scikit-learn interface [13, 14] with the loss
function of Equation 10 implemented as described in [5]. Tuning found that
parameters that slow the learning process were eﬀective, plausibly due to the
subtlety of parity violation in the PV-mSME; all BDTs are trained with a learning
rate of 0.1, with n_estimators=1000, min_child_weight=10000, and tree_method
="hist".

To implement early stopping, we evaluate every 50th iteration of the BDT
on validation data, and choose the iteration with the best Q on the validation
set to use in testing.

4.3.2 Neural network

The NN is a multilayer perceptron with ReLU activation functions, three hidden
layers of widths (100, 100, 10), and 50% dropout between the second and third
hidden layers. It is implemented using the Haiku [15] neural network library
in JAX [16] and optimized with Adam [17] (default settings and learning rate
0.001) implemented in Optax [18]. Network inputs are pre-scaled by a mean and
standard deviation in each coordinate.

Training is performed in steps with 10 000 examples per batch, and is evalu-
ated on a validation set after each 1000th step. Training is terminated when the
validation score does not increase for 10 consecutive rounds of evaluation, up to
a maximum of 100 rounds in total.

4.3.3 Convolutional neural network

The CNN is implemented using PyTorch [19]. It is trained with Adam [17]
using a learning rate of 0.001 and L2 regularization penalty of 0.1. The CNN
design consists of two convolutional layers with 5 × 5 kernels, each outputting 6
channels. These are followed by two fully connected layers of widths 96 and 10.
The Leaky ReLU activation function is used, with a negative slope of 0.01, to
generate non-linearity between layers. Invariance to rotations are built into the
CNN design as described in Section 4.1.2.

We again use early stopping to train on batches of 512 images until the
validation score saturates, The validation score Q is evaluated every 1000th step,
and termination occurs when it has not increased for 10 consecutive evaluation
rounds.

13

Figure 5: Test set evaluation score Q as a function of the coupling λPV, displayed
for BDT, NN and CNN models applied to truth-jet, reco-jet and calorimeter-
image datasets. A new model is trained and tested for each value of λPV. All
points use approximately two million events in their testing sets. Markers at
each λPV point are slightly oﬀset to aid visibility.

5 Results

Test results displayed in Figure 5 show positive Q values, which demonstrate
sensitivity of our method to parity violation in simulated PV-mSME data for
λPV ≈ 0.3 and above. All models and data representations are eﬀective, but
some are more eﬀective than others. As might be hoped, Q are seen to increase
with λPV.

A representative output distribution from the NN trained on reco-jet outputs
with λPV = 1 is shown in Figure 6. On the right of this plot, the variable is
re-scaled to target a uniform distribution, as in Figure 1. The clear asymmetry
between the two halves of the histogram demonstrates that parity violation
in this dataset is visible with the trained event variable. Here, the evaluation
score (from Equation 12) is Q = (1.06 ± 0.03) × 10−3 with 2.3 million testing
data. Since the training and validation sets consume four times as many data
again, this corresponds to a luminosity about of 53 fb−1 at the Standard Model
cross-section of 0.22 nb.

It can be helpful to understand some of what a classiﬁer is doing. For this
NN model and dataset, visualizations of what has been learnt in kinematic space
are given in Appendix A.2.

Despite the considerable noise from the various phases of physics and detector
simulation, there is a trend for models to perform better on reco-jets than truth-
jets. Not only is the method robust to simulation and reconstruction noise, but
it also appears to be able to scrape additional information from that noise!

Flavour information may play a signiﬁcant part; ﬂavour is hidden from

14

Figure 6: Distribution of the parity-odd NN variable f : (left) unscaled, and
(right) transformed to target a uniform distribution. The positive and negative
halves of the distributions are overlaid. Testing data are plotted with statistical
error bars.

the truth-jet event variables, but does aﬀect showering and hadronization into
reco-jets. Diﬀerent characteristics between gluons and the quark ﬂavours may
leave traces in the distributions of reconstructed jets, which the algorithms see.
Further study of ﬂavour information in truth data, presented in Appendix A.3,
ﬁnds that ﬂavour information greatly increases sensitivity to parity violation.

Similarly, eﬀects due to colour connections between partons may also play
a role. The strikingly stronger performance for the CNN with calo-images is
consistent with these ideas, as it preserves some more details than clustered
jets. The CNN working with calo-images additionally accesses softer and more
numerous jets than the other representations, which only have jets selected above
pT thresholds.

However, this discussion of information content may be too hasty; since all
results depend entirely on the successes of learning algorithms, all diﬀerences
can also be explained by how well those algorithms have performed. That
performance is inﬂuenced both by algorithm design and tuning (on the training
and validation sets), which was conducted manually by us as users.

6 Discussion and conclusions

We have demonstrated a method to perform model-independent searches for
parity-violating non-Standard-Model physics in LHC data. This method works
by training parity-odd event variables on one dataset, and evaluating them
on another. Various technologies may be used to implement these parity-odd
functions — BDTs, NNs, and CNNs are all demonstrated to be eﬀective.

Previous work [4, 5] has been extended with closer approximations to real
particle physics data by simulating collider events in a parity violating quantum
ﬁeld theory, with reconstruction from a detector simulation and approximated
triggering. We see from Figure 1 that this method achieves greater sensitivity

15

than the previous search for parity violating physics at the LHC [3].

Parity violation may manifest itself in unexpected and unforeseen ways in
nature, and in ways that are detectable at the LHC. Indeed, parity-violating
signals may already have been produced, but they have not yet been sought; to
ﬁnd parity violation, it is ﬁrst necessary to search. The methods developed in
this paper shrink a boundless space of previously unexplored parity violating
models to a manageable size.

Acknowledgements

We thank members of both the Cambridge ATLAS and Pheno Working groups
for valuable feedback and for enduring our endless mutterings about parity
and tests for symmetry violations. In particular, DN would like to thank Tina
Potter. Furthermore, without Olivier Mattelaer’s valued assistance on matters
relating to MadGraph the paper would have been impossible in its present form.
The support of Peterhouse in hosting workshops associated with this paper is
also acknowledged. RT, DN and CGL are all supported by the Science and
Technology Facilities Research Council.

References

[1] Christopher G. Lester. Chiral Measurements, 2021. arXiv:2111.00623.

[2] Bram Stoker. Dracula. Archibald Constable and Company, May 1899.

[3] Christopher G. Lester and Matthias Schott. Testing non-standard sources
of parity violation in jets at the LHC, trialled with CMS Open Data. JHEP,
12:120, 2019. arXiv:1904.11195, doi:10.1007/JHEP12(2019)120.

[4] Christopher G. Lester and Rupert Tombs. Stressed GANs snag desserts,
a.k.a Spotting Symmetry Violation with Symmetric Functions, 2021. arXiv:
2111.00616.

[5] Rupert Tombs and Christopher G. Lester. A method to challenge symmetries

in data with self-supervised learning, 2021. arXiv:2111.05442.

[6] D. Colladay and V. Alan Kostelecký.

Lorentz-violating exten-
sion of the standard model.
Phys. Rev. D, 58:116002, Oct 1998.
URL: https://link.aps.org/doi/10.1103/PhysRevD.58.116002, doi:
10.1103/PhysRevD.58.116002.

[7] V. Alan Kostelecký and Neil Russell. Data tables for Lorentz and CPT
violation. Rev. Mod. Phys., 83:11–31, Mar 2011. Table D37. URL:
https://link.aps.org/doi/10.1103/RevModPhys.83.11, doi:10.1103/
RevModPhys.83.11.

[8] V. Alan Kostelecký, E. Lunghi, and A.R. Vieira.

Lorentz viola-
tion and deep inelastic scattering. Physics Letters B, 769:272–280,
2017. URL: https://www.sciencedirect.com/science/article/pii/
S0370269317302356, doi:https://doi.org/10.1016/j.physletb.2017.
03.047.

16

[9] ATLAS Collaboration. The ATLAS experiment at the CERN Large Hadron
Collider. Journal of instrumentation, 3(S08003), Aug 2008. doi:10.1088/
1748-0221/3/08/s08003.

[10] Christopher G. Lester, Ward Haddadin, and Ben Gripaios. Lorentz and
permutation invariants of particles III: constraining non-standard sources
of parity violation, 2021. arXiv:2008.05206.

[11] Kevin P. Murphy. Machine learning a probabilistic perspective. Adaptive
computation and machine learning series. MIT Press, Cambridge, MA, 2012.

[12] Tianqi Chen and Carlos Guestrin. XGBoost: A Scalable Tree Boosting
System. In Proceedings of the 22nd acm sigkdd international conference
on knowledge discovery and data mining, pages 785–794, 2016. arXiv:
1603.02754.

[13] Fabian Pedregosa et al. Scikit-Learn: Machine Learning in Python. J.

Mach. Learn. Res., 12:2825–2830, Nov 2011.

[14] Lars Buitinck et al. API design for machine learning software: experiences
from the scikit-learn project.
In ECML PKDD Workshop: Languages
for Data Mining and Machine Learning, pages 108–122, 2013. arXiv:
1309.0238.

[15] Tom Hennigan, Trevor Cai, Tamara Norman, and Igor Babuschkin. Haiku:
Sonnet for JAX, 2020. URL: http://github.com/deepmind/dm-haiku.

[16] James Bradbury et al. JAX: composable transformations of Python+NumPy

programs, 2018. URL: http://github.com/google/jax.

[17] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic
In ICLR (Poster), 2015. URL: http://arxiv.org/abs/

optimization.
1412.6980.

[18] Matteo Hessel et al. Optax: composable gradient transformation and
optimisation, in JAX!, 2020. URL: http://github.com/deepmind/optax.

[19] Adam Paszke

PyTorch:

et al.
Performance Deep Learning Library.
formation Processing Systems, volume 32. Curran Associates,
2019.
bdbca288fee7f92f2bfa9f7012727740-Paper.pdf.

An Imperative Style, High-
In Advances in Neural In-
Inc.,
URL: https://proceedings.neurips.cc/paper/2019/file/

[20] Particle Data Group. Review of Particle Physics. Progress of Theoretical and
Experimental Physics, 2020(8), 08 2020. 083C01. arXiv:https://academic.
oup.com/ptep/article-pdf/2020/8/083C01/34673722/ptaa104.pdf,
doi:10.1093/ptep/ptaa104.

[21] Johan Alwall et al. The automated computation of tree-level and next-
to-leading order diﬀerential cross sections, and their matching to parton
shower simulations. Journal of High Energy Physics, 7:1–157, 2014. arXiv:
1405.0301, doi:10.1007/JHEP07(2014)079.

17

[22] Leif Lönnblad. Correcting the colour-dipole cascade model with ﬁxed order
matrix elements. Journal of High Energy Physics, 2002(05):046, 2002.
arXiv:hep-ph/0112284, doi:10.1088/1126-6708/2002/05/046.

[23] Richard D. Ball et al. Parton distributions with LHC data. Nuclear
Physics B, 867(2):244–289, 2013. URL: https://www.sciencedirect.
com/science/article/pii/S0550321312005500, doi:https://doi.org/
10.1016/j.nuclphysb.2012.10.003.

[24] Christian Bierlich et al. A comprehensive guide to the physics and usage
of PYTHIA 8.3. Unpublished, March 2022. arXiv:2203.11601, doi:10.
48550/arXiv.2203.11601.

[25] J de Favereau et al. DELPHES 3: a modular framework for fast simulation of
a generic collider experiment. Journal of High Energy Physics, 2014(02):26,
2014. arXiv:1307.6346, doi:10.1007/JHEP02(2014)057.

[26] Matteo Cacciari, Gavin P. Salam, and Gregory Soyez. The anti-kt jet
clustering algorithm. Journal of High Energy Physics, 2008(04):063, 2008.
arXiv:0802.1189, doi:10.1088/1126-6708/2008/04/063.

[27] Matteo Cacciari, Gavin P. Salam, and Gregory Soyez. FastJet User Manual.
Eur. Phys. J. C, 72:1896, 2012. arXiv:1111.6097, doi:10.1140/epjc/
s10052-012-1896-2.

[28] Matteo Cacciari and Gavin P. Salam. Dispelling the N 3 myth for the
kt jet-ﬁnder. Phys. Lett. B, 641:57–61, 2006. arXiv:hep-ph/0512210,
doi:10.1016/j.physletb.2006.08.037.

A Additional content

A.1

Interpretations

The two lines in Figure 6 represent histogram yields in diﬀerent bins, which are
separated by the parity ﬂip operation. An example statistical interpretation of
histograms like these is illustrated in Figure 7, which uses the common method of
ﬁtting two likelihood models; in this case, one model is one parity-even and the
other is not. The parity even model must assign equal background expectations
to both bins, up to modiﬁcations by known biases or systematic uncertainties.
The parity-odd model can assign diﬀerent expectations, so ﬁts both bins perfectly.

A.2 Output visualization

Visualizations of what has been learned by an algorithm can be interesting and
useful checks. In this appendix, we visualize the NN parity variable trained on
reco-jet data with scatter plots in which every point x is coloured by its NN
output f (x). These plots are shown in Figure 8.

Most events have |f (x)| (cid:28) 1, as shown in Figure 6, so parity-violating phase

space is highlighted by the opacity of scattered data points with |f (x)|.

In the rotation-invariant coordinates (cid:126)q ji
a

, described in Section 4.1.1, only the
non-zero ˆy components are parity odd; all other event variables are parity even.
To show parity violation, we therefore include at least one y component in each

18

Figure 7: Illustrated analysis of parity-opposite histograms in a minimal two-bin
example. A parity-asymmetric model assigns separate expectations in each
bin, so is able to ﬁt both perfectly. The purple line shows the best ﬁt from a
parity-symmetric model, for which both expectations must be equal. The orange
histogram modiﬁes the parity-symmetric model with constrained ‘systematic’
variations, which can allow small amounts of parity violation to account for
known biases or uncertainties; these variations give a slightly better ﬁt, reducing
the signiﬁcance. We assign signiﬁcances σ from maximum likelihood ratios by
σ2 = −2 log[max L1(θ)/ max L2(θ)], where L1(θ) and L2(θ) are the likelihood
functions of two alternative models.

19

plot. Any scatter plot in only parity-even variables cannot see parity violation
and appears as a monochrome blob.

A.3 Truth information

Although parton ﬂavour and helicity are features of the simulations, they are
not included in the truth-jet dataset. Flavour and helicity are, however, parity-
even event variables which could be approximately ‘tagged’ for with data in
appropriate detectors. This appendix investigates the eﬀects of including ﬂavour
and helicity as additional features in variable training. Flavour is encoded with
the PDG Monte Carlo Particle Numbering Scheme [20], and helicity is encoded
by ±1, which are both pre-scaled by a mean and standard deviation for the NN.
Flavour information drastically boosts sensitivity, as demonstrated in Figure 9

for the same λPV = 0 . . . 1 scan as used Figure 5.

To investigate both the switch-on in sensitivity and the joint eﬀect with
helicity, a narrower scan is performed in Figure 10 for λPV = 0 . . . 0.2. Helicity
appears to not help, and in fact hurts performance, as might be expected from
the inclusion of irrelevant information.

A.4 Rotated PV-mSME
The use of a constant coupling matrix (cA)µν in Section 3 means that the main
PV-mSME results of the paper assume either: (i) that the detector does not
rotate in space; or (ii) that the detector rotates with the earth, but the data being
analysed are only those which were recorded when the detector had a particular
orientation in space; or (iii) that the frame in which the Lorentz-violating eﬀects
are constant is ‘earth centric’ or ‘dragged around’ by the earth. The ﬁrst is
not physical, the second would decimate the cross-section available for analysis,
while the third is unlikely on physical grounds. Despite those drawbacks, we
justify the decision to use a constant coupling matrix (cA)µν in Section 3 on the
grounds that it allows a proof-of-principle to be demonstrated in the simplest
manner with the fewest distractions.

However: since the earth does rotate, it is interesting to ask what magnitude
of degradation would be seen in our results if the earth’s rotation were allowed
to induce a corresponding time-dependence into the couplings (cA)µν in the
detector frame. Practically, this means adding the orientation of the detector
to each event in the data so that the learning algorithms can learn about
alignment-dependent parity violation. If, for example, the data were only parity
violating in alignments close to a special axis, the algorithms could learn that and
automatically implement an eﬀective selection by mapping all other data to 0 in
their parity-odd output. And they could learn about other alignment-dependent
parity-violating eﬀects if they existed.

To demonstrate this approach, we imagine a simple case of an East-West
aligned detector (as ATLAS is, approximately), and consider daily rotations of a
planet which is otherwise ﬂoating stationarily in space (that is, not otherwise
orbiting a star about a diﬀerent axis). Since our analysis is invariant to rotations
in φ (about the beam axis), this daily rotation has an eﬀect equivalent to
rotating the detector about a single transverse axis (by an angle θ), independent
of latitude.7

7The latitude of Geneva is therefore not an input to the analysis, and no generality is lost

20

(a) transverse–transverse

(b) transverse–longitudinal

Figure 8: Kinematic distributions of the parity-odd variable f from the reco-jet
NN with λPV = 1 in the rotation-invariant (cid:126)q ji
coordinates deﬁned in Section 4.1.1.
a
The plots contain one million data from the testing dataset, scattered with colour
and transparency set by the value of f . Although each point has relatively low
transparency, overlaid points accumulate to the observed distributions. As seen
from Figure 6, the vast majority of data have small |f |; only the most parity-
violating phase space is visible here. If the NN is accurate, then colours in blue
(f < 0) should have lower density than those in orange (f > 0); as seen, the
diﬀerence is subtle.

21

Figure 9: Test set evaluation score Q as for small values of λPV, displayed for
BDT and NN models applied to truth-jet data with and without the inclusion
of parton ﬂavour information. Small values of λPV are further investigated in
Figure 10. All points use approximately two million events in their testing sets.
Markers at each λPV point are slightly oﬀset to aid visibility.

To study this example, we simulate truth-jet datasets from the PV-mSME
with its coupling matrix rotated for 24 diﬀerent earth-rotation angles θ spaced
evenly in [0, 2π),8 such that an angle of 0 recovers the PV-mSME. In addition to
the invariant jet momentum features described in Section 4.1.1 we also encode
the θ rotation of each event with the two features sin θ and cos θ.9 Training,
validation, and testing sets are prepared by subsampling and shuﬄing portions
of these data; we take samples from each rotation with rates proportional to
their production cross-sections, which we calculate from MadGraph and the
eﬃciency of our kinematic selections.

Cross-sections in the rotated PV-mSME vary hugely with θ. (Although this
anisotropy is a clear sign of new physics, it is not a direct sign of parity violation.)
These variations are approximately sinusoidal, with minima at 0 and π, maxima
at π/2 and 3π/2, and a maximum-over-minimum ratio of 13.5. Since parity
violation is strongest at 0 and π (as designed in Appendix C), this drastically
dilutes the observable parity violation. When training our standard learning
models (described in Section 4.3) on these rotated data, they report Q ≤ 0 in
validation, so not ﬁnd parity violation.

After tuning new model designs towards these diﬀerent data, however, we

as a consequence. Put another way: any approximately east-west-aligned and φ-symmetric
detector may be assumed to be near the North Pole, without loss of generality.

8Continuous rotations would be more realistic, but we opt for this discrete approximation

to avoid substantial changes to the simulation software.

9This (sin θ, cos θ) pair-encoding avoids the discontinuities of θ (at 0 or 2π), and relates
linearly to dot products with directions. Empirically, it appeared to improve results in
preliminary tests on the validation set.

22

Figure 10: Test set evaluation score Q for small values of the coupling λPV,
displayed for the NN model applied to truth-jet data with and without the
inclusion of parton helicity and ﬂavour information. This ﬁgure explores small
values of λPV to observe the switch-on of sensitivity in the leftmost parts of
Figure 9. All points use approximately two million events in their testing sets.
The algorithm has performed poorly for some points; it is not perfect! Markers
at each λPV point are slightly oﬀset to aid visibility.

23

do ﬁnd some evidence for parity violation in these rotated samples. With the
diluted parity violation in the rotated sample, the standard NN tended to collapse
towards all-0 outputs; this error was avoided by simplifying its design to three
hidden layers of widths (20, 20, 10), and no dropout layer. For statistically
signiﬁcant results, we also triple the data size from 10 million (as stated in
Section B) to 30 million, with the same training : validation : testing split of
60 : 20 : 20.

After ﬁnalizing this tuned NN, we ﬁnd Q = (7.6 ± 2.6) × 10−6 in the testing
set, which is a positive indication of parity violation. This result is weaker than
our other examples of evidence for parity violation, such as the results displayed
in Figure 5, but still corresponds to a substantial log likelihood ratio of 45.6 in
favour of the parity violating NN model.

B Simulation details

We simulate parton scattering at leading order using MadGraph5_aMC@NLO
v3.3.0 [21]. By default, MadGraph evaluates its matrix elements in the centre of
mass frame; since the mSME is not Lorentz invariant, we modify code generated
by MadGraph to evaluate its matrix elements in the lab frame instead. We
use a custom implementation of the PV-mSME quark-quark-gluon vertices in
a model imported into MadGraph. The simulated hard scatter is of LHC-like
proton-proton collisions at
s = 13 TeV scattering to three or four gluons or light
quarks (up, down, strange, or charm) each with pT > 200 GeV and |η| < 3.2, and
selected for CKKW-L merging with kDurham
= 200 GeV [22]. Other MadGraph
T
parameters of are left at their default values — in particular, partonic jets must
be separated by ∆Rjj > 0.4, and we use the NNPDF2.3LO1 PDF set [23].

√

The parton shower and hadronization are simulated with Pythia 8.235 [24].
Detector reconstruction is performed with the Delphes 3.5.0 [25] approximation
to the ATLAS detector. The output from Delphes includes anti-kT jets [26]
at ∆R = 0.4, and energy deposits in the calorimeters. Delphes performs jet
clustering with the FastJet package [27, 28].

The eﬀect of pileup is simulated in Delphes by overlaying a mean of 50
minimum-bias events to each event. Delphes sub-samples from a single batch
of pileup events for each batch of events processed; this raises a risk of bias if
pileup events are repeated enough for our learning algorithms to recognize them
individually. We mitigate this risk by using large numbers of pileup events and
not sharing any between training and testing datasets. We generate events in
batches of 200 000, and for each batch simulate 200 000 uniquely-seeded pileup
events.

To approximate the eﬃciency plateau of a three-jet trigger, events are accepted
only if they are reconstructed with at least three jets with pT > 220 GeV
and |η| < 2.8. Additional reconstructed jets are included only if they satisfy
pT > 30 GeV and |η| < 2.8.

We generate 500 batches of 200 000 truth events for each model speciﬁcation.
These events acquire weights in their processing to reconstruction level, which
we unweight by downsampling with respect to the maximum of all weights in the
simulation. Depending on λPV, around 20–30% of events survive triggering and
kinematic selections, and of those accepted around 60–40% survive unweighting.
After these reductions, the reco sets include 9.2 million events at λPV = 0, and

24

11.5 million events at λPV = 1. Truth sets have more events available since they
do not suﬀer from unweighting, so approximately match reco we use exactly
10 million truth events for each model.

C PV-mSME details

C.1 Notation

Our notation is related to Equation 11 of [6], which deﬁnes coupling matri-
ces (cX )µνAB for X ∈ {Q, U, D} with generation indices A and B. The PV-
mSME deﬁnes these coupling matrices to be diagonal in the ﬁrst two gen-
erations: (cX )µνAB = (cX )µν diag(1, 1, 0)AB. Couplings split into an axial
part (cA)µν = (cU )µν − (cQ)µν, and a vector part which we deﬁne to vanish
(cV )µν = (cD)µν + (cQ)µν = 0 The PV-mSME therefore couples quarks within
the ﬁrst two generations only, has the same couplings within each of those
generations, and does not mix between them.

After some rearrangement, the quark-quark-gluon Feynman Rule of Equa-

tion 3 can be read from the Lagrangian in these terms.

As stated in [6], the full coupling matrices must be Hermitian in their
generation indices and traceless in their Lorentz indices. Since our couplings
are on the generation diagonal, they must be real to satisfy the Hermitivity
constraint.

C.2 Couplings

Within those real and traceless constraints, the speciﬁc form of the PV-mSME
coupling matrix (cA)µν of Equation 4 is chosen primarily from empirical results
of numerical experiments. However, it has some plausible justiﬁcations, which
we develop here.

We seek couplings which not only generate parity violation, but which make
it visible when blind to rotations by φ about the beam axis and by 180◦ about a
perpendicular axis (to swap the beams). Variation of a diﬀerential cross-section
under these rotations is of no beneﬁt, since the rotation-invariant observer sees
only an average. Variations may plausibly, however, cause parity violation to
be ‘washed out’ from a rotation-invariant perspective. We therefore attempt
to choose couplings which minimize the dependence of cross-sections on these
rotations.

The PV-mSME introduces terms into matrix elements that do not appear in
the Standard Model alone. Among these non-standard terms are expressions of
the form (cA)µνpµqν, which we abbreviate here as ξ = pT Cq. Parameterizing
axial and beam-swap rotations with the matrix

S(φ, ±) =


1
0


0

0

0

0

cos φ ∓ sin φ
sin φ ± cos φ

0

0







0
0
0
±1

,

(13)

ξ may be seen to transform to ξ(φ, ±) = pT S(φ, ±)T CS(φ, ±)q. If one were to
require that ξ(φ, ±) be independent of φ for all p and q, then one would need to

25

take C to be of the form

C =







c00
0
0
c30

0

0
c22 −c21
c22
c21
0
0







.

c03
0
0
c33

(14)

If one were to subsequently require that ξ(φ, ±) be proportional to ± for all p
and q, then the diagonal elements of C would be set to zero, resulting in:

ξ(φ, ±) = ±(p0q3c03 + p3q0c30 + p2q1c21 − p1q2c21) .

(15)

This choice (ﬁxed magnitude but not ﬁxed sign) does not lead matrix elements
to be invariant under beam swaps, but does give opportunities for them to have
reduced dependence on this operation, perhaps arising from even powers or
cancellations against sign-ﬂipped terms.

Pleasingly, the form shown in (15) contains both parity even (p1q2, p2q1) and
parity odd (p0q3, p3q0) terms. Violation of parity requires interference between
parity-odd and parity-even terms; parity odd terms alone are not suﬃcient, since
cross-sections are proportional to the modulus of the matrix element squared.
Requiring ξ(φ, ±) to be parity asymmetric (for some p and q) therefore forces
c21 and at least one of c30 and c03 to be non-zero. Without loss of generality we
can therefore choose c21 = 1, absorbing any overall scale into λPV, and are left
with the freedom to choose values for c30 and c03.

In summary, requiring ξ(φ, ±) to be independent of φ, invariant in magnitude

to ± ﬂips, and parity asymmetric implies

C =







0
0
0
c30

0
0
0 −1
0
1
0
0







,

c03
0
0
0

(16)

where at least one of c30 and c03 is non-zero.

The PV-mSME choice is c30 = 1 and c03 = −1. This empirically generates
visible parity violation, and has diﬀerential cross-sections which are close to
rotation-invariant when explored from individual points in phase space. Numeri-
cal matrix elements calculated with MadGraph are illustrated at example phase
points in Figure 11, along with some eﬀects from diﬀerently assigned couplings.
In the top row of Figure 11, Standard Model and PV-mSME rings appear
to be rotation-invariant, but they are not exactly. On closer inspection, the
PV-mSME shows sinusoidal variations of a few parts per million, whereas the
Standard Model varies only by numerical rounding errors in parts per 1015.

26

Figure 11: Helicity-summed, magnitude-squared matrix elements |M|2 displayed
as radial distances, such that diﬀerences between the orange and blue lines
indicate parity violation. Momenta are rotated by S(φ, ±), where φ is the
angle from the vertical axis. Parton distribution functions are invariant under
these rotations, so |M|2 is proportional to the diﬀerential cross-section. The
Standard Model is invariant under rotation and parity operations. The PV-
mSME has (cA)µν couplings from Equation 4; latter columns modify the (cA)µν
coupling matrix by their stated assignments. Top: (cid:126)pg = (200, 400, −600), (cid:126)pu =
(−200, −150, 200), and (cid:126)pd = (0, −250, 1200) GeV. Bottom: (cid:126)pg = (100, 250, 250),
(cid:126)pu = (200, 250, 400), and (cid:126)p¯u = (−300, −500, −300) GeV.

27

