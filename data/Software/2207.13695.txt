Preprint manuscript No.
(will be inserted by the editor)

A detailed introduction to density-based topology optimisation
of ﬂuid ﬂow problems with implementation in MATLAB

Joe Alexandersen

2
2
0
2

l
u
J

9
1

]
E
C
.
s
c
[

1
v
5
9
6
3
1
.
7
0
2
2
:
v
i
X
r
a

Received: date / Accepted: date

Abstract This article presents a detailed introduction
to density-based topology optimisation of ﬂuid ﬂow prob-
lems. The goal is to allow new students and researchers
to quickly get started in the research area and to skip
many of the initial steps, often consuming unnecessarily
long time from the scientiﬁc advancement of the ﬁeld.
This is achieved by providing a step-by-step guide to the
components necessary to understand and implement
the theory, as well as extending the supplied MATLAB
code. The continuous design representation used and
how it is connected to the Brinkman penalty approach,
for simulating an immersed solid in a ﬂuid domain, is il-
lustrated. The diﬀerent interpretations of the Brinkman
penalty term and how to chose the penalty parameters
are explained. The accuracy of the Brinkman penalty
approach is analysed through parametric simulations
of a reference geometry. The chosen ﬁnite element for-
mulation and the solution method is explained. The
minimum dissipated energy optimisation problem is de-
ﬁned and how to solve it using an optimality criteria
solver and a continuation scheme is discussed. The in-
cluded MATLAB implementation is documented, with
details on the mesh, pre-processing, optimisation and
post-processing. The code has two benchmark exam-
ples implemented and the application of the code to
these is reviewed. Subsequently, several modiﬁcations to
the code for more complicated examples are presented

This paper is dedicated to my former supervisor and colleague
Ole Sigmund, the pioneer of educational topology optimisa-
tion codes and so much more.

J. Alexandersen
Department of Mechanical and Electrical Engineering
University of Southern Denmark
Campusvej 55, DK-5230 Odense M
Tel.: +45 65507465
E-mail: joal@sdu.dk

through provided code modiﬁcations and explanations.
Lastly, the computational performance of the code is
examined through studies of the computational time
and memory usage, along with recommendations to de-
crease computational time through approximations.

Keywords topology optimisation · ﬂuid ﬂow ·
education · MATLAB

1 Introduction

1.1 Topology optimisation

The topology optimisation method emerged from sizing
and shape optimisation at the end of the 1980s in the
ﬁeld of solid mechanics. The homogenisation method
by Bendsøe and Kikuchi (1988) is cited as being the
seminal paper on topology optimisation. Topology op-
timisation is posed as a material distribution technique
that answers the question “where should material be
placed?” or alternatively “where should the holes be?”.
This diﬀerentiates it from the classical disciplines of siz-
ing and shape optimization, since it does not need an
initial structure with the topology deﬁned a priori. Al-
though a range of topology optimisation approaches ex-
ists, such as the level set and phase ﬁeld methods, the
most popular method remains the so-called “density-
based” method. The review papers by Sigmund and
Maute (2013) and Deaton and Grandhi (2014) give a
general overview of topology optimisation methods and
applications.

Due to the maturity of the method for solid mechan-
ics, most ﬁnite element analysis (FEA) and computer-
aided design (CAD) packages now have built-in topol-
ogy optimisation capabilities. Further, many public codes

 
 
 
 
 
 
2

Joe Alexandersen

have been made available, often together with educa-
tional articles explaining their use. The ﬁrst published
code was the famous “99-line” MATLAB code by Sig-
mund (2001), used broadly around the world in teach-
ing and initial experiments with topology optimisation.
Subsequently, this code was updated to a more eﬃ-
cent “88-line” version by Andreassen et al. (2011) and
most recently a hyper-eﬃcient “neo99” version by Fer-
rari and Sigmund (2020). Over the years, many edu-
cational codes have been published for topology op-
timisation using e.g. level set methods (Challis, 2010;
Wei et al., 2018), unstructured polygonal meshes (Tal-
ischi et al., 2012), energy-based homogenisation (Xia
and Breitkopf, 2015), truss ground structures (Zegard
and Paulino, 2014) and large-scale parallel computing
(Aage et al., 2015). The recent review paper by Wang
et al. (2021) provides a comprehensive overview of edu-
cational articles in the ﬁeld of structural and multidis-
ciplinary optimisation.

1.2 Fluid ﬂow

The density-based topology optimisation approach was
extended to the design of Stokes ﬂow problems by Bor-
rvall and Petersson (2003) and further to Navier-Stokes
ﬂow by Gersborg-Hansen et al. (2005). Since those sem-
inal papers, topology optimisation has been applied to a
large range of ﬂow-based problems. The recent review
paper by Alexandersen and Andreasen (2020) details
the many contributions to this still rapidly developing
ﬁeld. Topology optimisation of pure ﬂuid ﬂow has now
become reasonably mature, with only minor recent con-
tributions for steady laminar ﬂow (Alexandersen and
Andreasen, 2020). Therefore, research eﬀorts should be
focused on building further upon this technology, call-
ing for an educational article and a simple code that
allows for quickly getting started and skipping initial
repetitive implementations.

Pereira et al. (2016) presented an extension of their
polygonal mesh code (Talischi et al., 2012) to Stokes
ﬂow topology optimisation. Whereas Pereira et al. (2016)
focused on stable discretisations of polygonal elements
for Stokes ﬂow, this educational article focuses on giv-
ing a detailed and complete introduction to density-
based topology optimisation of ﬂuid ﬂow problems gov-
erned by the Navier-Stokes equations. The aim is to
serve as the ﬁrst point of contact for new students and
researchers to quickly get started in the research area
and to skip many of the initial steps, often consum-
ing unnecessarily long time from the scientiﬁc advance-
ment of the ﬁeld. The goal is not to give an overarching
overview of the literature on the subject, so references

herein are rather sparse on purpose and the reader is re-
ferred to the recent review paper instead (Alexandersen
and Andreasen, 2020).

This article provides a step-by-step introduction to
all the needed steps, along with a relatively simple and
eﬃcient implementation in MATLAB - where compati-
bility of the main ﬁles with the open-source alternative
GNU Octave has been ensured. The code presented in
this paper builds on the “88-line” code by Andreassen
et al. (2011) and uses the same basic code structure and
variable names.

1.3 Paper layout

The article is structured as follows:

– Section 2 introduces the design representation used
for density-based topology optimisation of ﬂuid ﬂow
problems;

– Section 3 presents the physical formulation and an
in-depth investigation of the error convergence for
important problem parameters;

– Section 4 details the ﬁnite element discretisation

and the state solution procedure used;

– Section 5 discusses the optimisation formulation,
sensitivity analysis and design solution procedure;
– Section 6 introduces the two benchmark examples

included in the code;

– Section 7 presents a description of the accompany-

ing MATLAB implementation;

– Section 8 shows results obtained using the code for

the benchmark examples;

– Section 9 discusses modiﬁcations to the code for

solving more advanced problems;

– Section 10 discusses the computational time and

memory usage;

– Section 11 presents concluding remarks.

2 Design representation

This section describes the design representation intro-
duced to model solid domains immersed in a ﬂuid, al-
lowing for density-based topology optimisation. First,
the true separated discrete domains that should be rep-
resented are introduced, and secondly, a continuous de-
sign representation is described.

2.1 Discrete separate domains

Figure 1a shows an arbitrary example of a truly discrete
problem with separated ﬂuid and solid domains, de-
noted as Ωf and Ωs, respectively. Both Ωf and Ωs can

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

3

transition region of intermediate design ﬁeld values as
shown in Figure 1b. Generally, during the optimisation
process there will be many regions of intermediate val-
ues, whereas a converged design will have signiﬁcantly
less, if any – depending on various details as will be
discussed later. By coupling the continuous design rep-
resentation to coeﬃcients of the governing equations,
it is possible to model an immersed geometry which is
implicitly deﬁned by the design ﬁeld.

(a) Discrete separation of domains

3 Physical formulation

This section presents the physical formulation of the
ﬂuid ﬂow problems treated in this article. The Navier-
Stokes equations are the governing equations and a so-
called Brinkman penalty term is introduced to facilitate
density-based topology optimisation.

3.1 Governing equations

This article restricts itself to steady-state laminar and
incompressible ﬂow, governed by the Navier-Stokes equa-
tions:

(b) Continuous design representation

Fig. 1: Arbitrary computational domain consisting of
ﬂuid and solid domains.

ρuj

∂ui
∂xj

− µ

∂
∂xj

(cid:18) ∂ui
∂xj

+

∂uj
∂xi

(cid:19)

+

∂p
∂xi

− fi = 0

(2a)

∂ui
∂xi

= 0

(2b)

be comprised as the union of non-overlapping subdo-
mains, as illustrated for Ωs in Figure 1a. The interface
between the solid and ﬂuid domains is clearly deﬁned
due to the separation of the two domains.

where ui is the i-th component of the velocity vector
u, p is the pressure, ρ is the density, µ is the dynamic
viscosity, and fi is the i-th component of the body force
vector f. The Reynolds number is commonly used to
describe a ﬂow and is deﬁned as:

2.2 Continuous relaxed representation

In order to perform density-based topology optimisa-
tion using gradient-based methods, the discrete repre-
sentation must be relaxed. Firstly, a spatially-varying
ﬁeld, γ(x), is introduced, which will be termed the de-
sign ﬁeld. It is equivalent to the characteristic function
of the ﬂuid domain Ωf :

Re =

ρU L
µ

(3)

where U and L are the reference velocity and length-
scale, respectively. The Reynolds number describes the
ratio of inertial to viscous forces in the ﬂuid: if Re < 1,
the ﬂow is dominated by viscous diﬀusion; if Re > 1,
the ﬂow is dominated by inertia.

γ(x) =

(cid:26) 1 if x ∈ Ωf
0 if x ∈ Ωs

3.2 Brinkman penalty term

(1)

Secondly, the design ﬁeld is relaxed from binary val-
ues to a continuous ﬁeld, allowing intermediate values:
γ(x) ∈ [0; 1]. Figure 1b shows a continuous relaxed rep-
resentation of the discrete separated domains of Figure
1a. The continuous representation has an implicit rep-
resentation of the solid-ﬂuid interface, represented by a

In order to facilitate topology optimisation, an artiﬁcial
body force is introduced, termed the Brinkman penalty
term:

fi = −αui

(4)

which represents a resistance term and a momentum
sink, drawing energy from the ﬂow. The Brinkman penalty

4

Joe Alexandersen

factor, α, is a spatially-varying parameter deﬁned as
follows for the separated domains introduced in Figure
1a:

α(x) =

(cid:26) 0 if x ∈ Ωf
∞ if x ∈ Ωs

(5)

where the 0 in the ﬂuid domain recovers the original
equations and the inﬁnite value inside the solid domain
theoretically ensures identically zero velocities. This al-
lows for extending the Navier-Stokes equations to the
entire computational domain:

ρuj

∂ui
∂xj

− µ

∂
∂xj

(cid:18) ∂ui
∂xj
∂p
∂xi

+

(cid:18) ∂ui
∂xj

(cid:19)

+

∂uj
∂xi

+ α (γ(x)) ui = 0

+

∂uj
∂xi

(cid:19) ∂ui
∂xi

= 0






for x ∈ Ω

(6)

where solid domains are modelled as immersed geome-
tries through the Brinkman penalty term.

The Brinkman penalty term can be interpreted in

three diﬀerent ways:

1. Volumetric penalty term to ensure zero velocities in

the solid regions

2. Friction term from out-of-plane viscous resistance
3. Friction term from an idealised porous media

The ﬁrst interpretation is a purely algorithmic approach,
where the only purpose is to simulate an immersed fully
solid geometry inside a ﬂuid domain. The second and
third are both physical interpretations, but require dif-
ferent lower and upper bounds of Equation 5 formulated
based on physical parameters. The second interpreta-
tion is limited to only two-dimensional problems, where
the computational domain has a ﬁnite and relatively
small out-of-plane thickness. The ﬁrst and third inter-
pretations can be applied to three-dimensional prob-
lems.

The seminal work by Borrvall and Petersson (2003)
for Stokes ﬂow and Gersborg-Hansen et al. (2005) for
Navier-Stokes ﬂow, both introduced a design parametri-
sation based on the out-of-plane channel height for two-
dimensional problems following the second interpreta-
tion above. Both works also note the comparison to the
third interpretation and Gersborg-Hansen et al. (2005)
argues for the ﬁrst interpretation as the ultimate goal of
topology optimisation for ﬂuid ﬂow. The recent review
paper by Alexandersen and Andreasen (2020) shows
that the dominant interpretation is the ﬁrst, a purely
algorithmic approach to ensure zero velocities. This is
because it easily extends to three-dimensions and no

Fig. 2: Interpolation of α for various qα.

physical reﬂections are required. However, as it will be
discussed in Sections 3.2.2 and 3.2.3 and shown in Sec-
tion 3.3, it is highly relevant to couple the parameters
to the physical interpretations to ensure correct scaling
of the equations.

3.2.1 Numerical relaxation

In practise, the bounds of the Brinkman penalty fac-
tor are deﬁned as follows, based on the design ﬁeld, γ,
introduced in Figure 1b:

α(γ(x)) =

(cid:26) αmin if γ(x) = 1
αmax if γ(x) = 0

(7)

For numerical reasons, a ﬁnite value must be used in
the solid domain, αmax, being large enough to ensure
negligible velocities but small enough to ensure sta-
bility. The choice of this maximum value will be dis-
cussed in Sections 3.2.3 and 3.3. Furthermore, if two-
dimensional problems with a ﬁnite out-of-plane thick-
ness are treated, a minimum value, αmin, should remain
to account for the out-of-plane viscous resistance as dis-
cussed in Section 3.2.2.

In order to interpolate between solid and ﬂuid do-
mains, the Brinkman penalty factor is interpolated us-
ing the following function:

α(γ) = αmin + (αmax − αmin)

1 − γ
1 + qαγ

(8)

where qα is a parameter determining the shape of the
interpolation, as illustrated in Figure 2 for αmin = 0 and
αmax = 104. This function is not the same as introduced
by Borrvall and Petersson (2003), but rather the Ra-
tional Approximation of Material Properties (RAMP)

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

5

function (Stolpe and Svanberg, 2001). This ensures a
linear interpolation is directly achieved by setting qα to
0, whereas the function used by Borrvall and Petersson
(2003) only has the linear case as an asymptotic limit.
Eﬀectively, qα herein is the inverse of the q used by
Borrvall and Petersson (2003).

3.2.2 Minimum penalty factor

3.2.4 Note on physical interpretations

It is easily seen from Equations 9 and 10, that the two
physical interpretations are analogous by connecting
the permeability to the out-of-plane thickness:

κ =

2h2
5

(11)

The seminal work by Borrvall and Petersson (2003)
for Stokes ﬂow and Gersborg-Hansen et al. (2005) for
Navier-Stokes ﬂow, introduced topology optimisation
of ﬂuid ﬂow problems using a design parametrisation
based on the out-of-plane channel height for two-dimensional
problems. By assuming parallel plates distanced 2h apart
and a fully-developed pressure-driven ﬂow (Poiseuille
ﬂow), an out-of-plane parabolic velocity proﬁle is as-
sumed between the two plates. This allows for ana-
lytical through-thickness integration, yielding an addi-
tional term to the momentum equations from the out-
of-plane viscous resistance in the form of Equation 4.
When treating two-dimensional problems with a ﬁnite
out-of-plane thickness and lateral no-slip walls, the min-
imum Brinkman penalty must be set to:

as noted by both Borrvall and Petersson (2003) and
Gersborg-Hansen et al. (2005).

3.2.5 Dissipated energy

This article focuses on minimising the dissipated energy
by a ﬂow through a channel structure. The dissipated
energy due to viscous resistance is deﬁned as:

φ =

1
2

(cid:90)

Ωf

µ

∂ui
∂xj

(cid:18) ∂ui
∂xj

+

∂uj
∂xi

(cid:19)

dV

(12)

The dissipated energy is often used as the objective
functional of topology optimisation and it is, thus, rel-
evant to investigate the accuracy of this measure when
using the Brinkman penalty method.

αmin =

5µ
2h2

(9)

3.3 Eﬀect of varying parameters

where h is half of the domain thickness. However, when
treating three-dimensional problems, the minimum Brinkman
penalty factor should be set to 0 to recover the original
unencumbered Navier-Stokes momentum equations.

This section presents the eﬀect of varying the Reynolds
number Re and Brinkman penalty factor α on the ac-
curacy of the Brinkman-penalised Navier-Stokes equa-
tions.

3.2.3 Maximum penalty factor

3.3.1 Example setup

Finding the correct maximum penalty factor is not triv-
ial. It must be large enough to ensure negligible ﬂow
through solid regions, but small enough to ensure nu-
merical stability. While the Brinkman term is often seen
purely as a volumetric penalty approach for imposing
the no-ﬂow conditions inside the solid, it is beneﬁcial
to ensure consistent dimensional scaling of the penalty
factor. This can be done by relating it to the friction
factor from a ﬁctitious porous media:

αmax =

µ
κ

(10)

where κ is the permeability of the ﬁctitious porous me-
dia. This permeability must then be small enough to
ensure negligible velocities inside the solid regions, but
as will be shown in Section 8.1.3, the minimum dis-
sipated energy optimisation is pretty forgiving. For a
given constant permeability, Equation 10 ensures an al-
most constant ratio between the order of magnitude for
the velocities in the ﬂow and solid regions for a range
of Reynolds numbers, as demonstrated in Section 3.3.

Figure 3 presents the problem setup used to explore
the accuracy of the Brinkman-penalised Navier-Stokes
equations. A hollow box obstacle is placed inside a chan-
nel, where a fully-developed parabolic ﬂow with a max-
imum of Uin enters at the left-hand side inlet and exits
at the right-hand side zero normal-stress outlet. This
model will be solved using both a discrete design rep-
resentation, modelling only the ﬂuid domain, and a
continuous design representation, with the Brinkman-
penalised Navier-Stokes equations in the entire compu-
tational domain. The same locally-reﬁned mesh is used
for both models to ensure that the discretisation error
does not aﬀect the comparison in a signiﬁcant sense.

The porous media deﬁnition in Equation 10 is cho-
sen for the Brinkman penalty factor and the problem
is non-dimensionalised by setting the inlet velocity to
Uin = 1, the density to ρ = 1, the dynamic viscosity to
µ = 1/Re, and the permeability to κ = Da. The Darcy
number, Da = κ
L2 , is the non-dimensional permeability.
The Reynolds and Darcy numbers will be varied.

6

Joe Alexandersen

For ﬂuid dissipation problems, this is not really an issue
because this pressure is not important for the overall
dissipation and since disconnected ﬂuid regions never
occur in the optimised designs. But for ﬂuid-structure-
interaction, where the ﬂuid exerts a pressure on the
solid, the internal non-zero pressure can be an issue
(Lundgaard et al., 2018).

(a) Domain and boundary deﬁnitions

3.3.3 Error convergence study

To clearly show the convergence of the approximate so-
lution from the continuous representation towards the
true solution from the discrete representation, a number
of error measures are computed. The spatial average of
the velocity magnitude inside the solid structure and
inside the cavity are computed as:

εu,s =

εu,c =

1
|Ωs|

1
|Ωc|

(cid:90)

Ωs

(cid:90)

Ωc

(cid:107)u(cid:107)2 dV

(cid:107)u(cid:107)2 dV

(13a)

(13b)

These are seen as directly equivalent to a relative error
measure, since the true solution for these quantities are
zero and the reference (inlet) value is 1. Furthermore,
the relative error is found for the dissipated energy and
the pressure drop:

εφ =

|φdisc − φcont|
φdisc

ε∆p =

|∆pdisc − ∆pcont|
∆pdisc

(14a)

(14b)

where subscripts ‘disc’ and ‘cont’ denote discrete and
continuous design representations, respectively, φ is the
dissipated energy of the ﬂuid subdomain deﬁned in Equa-
tion 12 and ∆p is the pressure drop from inlet to outlet
as computed from:

∆p =

1
|Γin|

(cid:90)

Γin

p dS −

1
|Γout|

(cid:90)

Γout

p dS

(15)

Figure 7 shows the error measures as a function of
the Darcy number for Re = 20. It is clearly seen that
the velocity error measures converge at an order of 1
and the pressure and dissipation measures at an order
of 1⁄2. This shows that compared to the velocity ﬁeld,
the pressure ﬁeld needs a signiﬁcantly higher Brinkman
penalty factor to reach a certain accuracy. The dissi-
pated energy also requires a larger Brinkman penalty
factor to achieve a certain accuracy. However, this is
not necessarily important for minimum dissipated en-
ergy optimisation as will be demonstrated in Section
8.1.3. Additional accuracy becomes important if these

(b) Dimensionless lengths

Fig. 3: Problem setup for the example used in Section
3.3.

3.3.2 Fluid solution

Figure 4 shows the velocity magnitude and pressure
ﬁelds using the discrete design representation for Re =
20. Since the ﬂuid cavity inside the solid structure is dis-
connected, the pressure is here set equal to a reference
pressure of 0. It can be seen that the ﬂow moves above
the obstacle and leaves a re-circulation zone behind it.
Figure 5 shows the velocity magnitude ﬁeld using
the Brinkman approach for Re = 20 and Da ∈ {10−4,
10−6, 10−8}. For the highest permeability case, Da =
10−4, it is seen that a signiﬁcant amount of ﬂuid passes
through the solid structure and clearly non-zero veloci-
ties exist in the cavity. When this is increased to Da =
10−6, the ﬂow solution becomes more accurate, but the
recirculation zone behind the obstacle is not fully cap-
tured. This is improved for the last case, Da = 10−8,
but even here ﬂow is passing through the obstacle. This
will always be the case for the Brinkman penalty ap-
proach, but the velocities can be driven towards zero
by decreasing the permeability suﬃciently.

Figure 6 shows the pressure ﬁeld using the Brinkman
approach for Re = 20 and Da ∈ {10−4, 10−6, 10−8}.
Due to the continuous nature of the design representa-
tion, pressure gradients exist inside the solid structure
and a non-zero pressure exists in the cavity. The cavity
pressure approximately becomes the mean of the high
and low surface pressures - for this case ≈ (4+0)/2 = 2.

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

7

(a) Velocity magnitude

(b) Pressure ﬁeld

Fig. 4: Velocity magnitude and pressure ﬁelds using the discrete design representation for Re = 20.

(a) Da = 10−4

(a) Da = 10−4

(b) Da = 10−6

(b) Da = 10−6

(c) Da = 10−8

(c) Da = 10−8

Fig. 5: Velocity magnitude ﬁelds using the Brinkman
approach for Re = 20 and Da ∈ {10−4, 10−6, 10−8}.

Fig. 6: Pressure ﬁelds using the Brinkman approach for
Re = 20 and Da ∈ {10−4, 10−6, 10−8}.

functionals are used as constraints where the limit rep-
resents a physical value. The constraint looses its physi-
cality, if the functional is not resolved to a large enough
accuracy1. However, if treated in relative terms as in
Section 9.2.2, then this is less of an issue. The accuracy

1 This is very similar to stress constraints in structural
topology optimisation, where a maximum stress limit be-
comes meaningless, unless the stresses and aggregated maxi-
mum is accurate Le et al. (2010); da Silva et al. (2019).

of the pressure ﬁeld is also very important if it is used
to drive additional physics, such as ﬂuid-structure in-
teraction (FSI) which was clearly shown by Lundgaard
et al. (2018).

Figure 8 shows the error measures as a function
of the Reynolds number for Da = 10−6. It can be
seen that deﬁning the Brinkman penalty factor using
Equation 10 ensures a constant error for a range of
Reynolds numbers. However, as the Reynolds number

8

Joe Alexandersen

Fig. 9: Element degrees-of-freedom (DOFs) and nodal
numbering.

moderate Reynolds numbers treatable with the present
steady-state implementation. An alternative scaling law
proposed by Kondoh et al. (2012) is discussed in Ap-
pendix A.

Fig. 7: Error measures as a function of permeabil-
ity for a Reynolds number of Re = 20 and Da ∈
{10−2, 10−3, 10−4, 10−5, 10−6, 10−7, 10−8} .

4 Discretisation and solution

4.1 Finite element formulation

The governing equations in Equation 2 are discretised
using a stabilised continuous Galerkin ﬁnite element
formulation. Both the velocity and pressure ﬁelds are
approximated using piecewise bi-linear interpolation func-
tions and the design ﬁeld is approximated using piece-
wise constant values, rendering a u1p1g0 element as
shown in Figure 9. This yields 8 velocity degrees-of-
freedom (DOFs), 4 pressure DOFs, and 1 design DOF
per element. Due to the equal-order interpolation for ve-
locity and pressure, Pressure-Stabilising Petrov-Galerkin
(PSPG) stabilisation is applied to get a stable ﬁnite ele-
ment formulation. Furthermore, to avoid spurious oscil-
lations due to convection, Streamline Upwind Petrov-
Galerkin (SUPG) stabilisation is also applied. The de-
tailed formulation is given in Appendix B.

The discretisation gives rise to a non-linear system

of equations, which is posed in residual form:

r(s, γ) = A(s, γ) s = 0

(16)

where A is the system coeﬃcient matrix, s = (cid:2)uT pT (cid:3)T
is the vector of global state DOFs, u is the vector of
velocity DOFs, p is the vector of pressure DOFs, and
γ is the vector of design ﬁeld values. There are many
non-linear and design-dependent terms in the system:
the convection term is dependent on the velocity ﬁeld;
the Brinkman term is dependent on the design ﬁeld; and
the stabilisation terms are dependent on both the veloc-
ity and design ﬁeld (either directly through convection
and Brinkman terms or indirectly through the stabili-
sation parameter). Thus, a robust non-linear solver is
needed and the Newton solver is detailed in the subse-
quent section. Furthermore, derivation of accurate par-

Fig. 8: Error measures as a function of Reynolds num-
ber for a Darcy number of Da = 10−6 and Re ∈
{0.01, 0.1, 1, 5, 10, 50, 100, 150}.

becomes larger than 10, the error begins to slowly grow.
This makes sense, since the porous media analogy is
based on scaling with the viscous diﬀusion term and a
Brinkman porous media model. As the Reynolds num-
ber increases, the convective term begins to dominate in
Equation 6 and, thus, it makes sense that the penalty
term should scale diﬀerently. However, the slight in-
crease in the errors are not seen as signiﬁcant for the

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

9

tial derivatives, such as the Jacobian matrix and those
necessary for optimisation, can be cumbersome. There-
fore, these derivatives will be automatically computed
using the Symbolic Toolbox in MATLAB.

5 Optimisation formulation

5.1 Objective functional

4.2 Newton solver

To solve the non-linear system of equations, a damped
Newton method is used. At each non-linear iteration, k,
the following linearised problem is solved for the New-
ton step, ∆sk:

The dissipated energy was originally introduced as the
objective functional by Borrvall and Petersson (2003).
Equation 12 is the dissipated energy in the ﬂuid do-
main due to viscous resistance only. The addition of the
Brinkman penalty term introduces a body force, which
must be taken into account in the dissipated energy:

φ =

1
2

(cid:90)

Ω

(cid:18)

µ

∂ui
∂xj

(cid:18) ∂ui
∂xj

+

∂uj
∂xi

(cid:19)

(cid:19)

+ α(x)uiui

dV (20)

∂r
∂s

(cid:12)
(cid:12)
(cid:12)
(cid:12)k−1

∆sk = −r(sk−1)

(17)

which is now integrated over the entire computational
domain.

where the solution is then updated according to:

sk = sk−1 + δk∆sk

5.2 Volume constraint

(18)

with δk ∈ [0.01; 1] being the damping factor2. In or-
der to gain robust convergence for moderate Reynolds
numbers, the damping factor is updated according to
the minimum of a quadratic ﬁt of the residual norm
dependence on δ. The residual and its 2-norm is calcu-
lated for δ ∈ {0, 0.5, 1}, with the current value (δ = 0)
already known. A quadratic equation is then ﬁtted to
the residual norms with the unique minimising damp-
ing factor expressed analytically. The damping factor is
then set to:

(cid:18)

(cid:18)

δk = max

0.01, min

1,

3||r0||2 − 4||r0.5||2 + ||r1||2
4||r0||2 − 8||r0.5||2 + 4||r1||2

(cid:19)(cid:19)

(19)

where rδ is the residual evaluated for the solution up-
dated with a given δ.

The Newton solver is run until the current resid-
ual norm has been reduced relative to the initial be-
low a predeﬁned threshold. To speed up convergence,
the state solution from the previous design iteration is
used as the initial solution for the Newton solver. If the
solver does not converge before a maximum iteration
number is reached, it tries again from a zero (except
for boundary conditions) initial solution. If that also
fails, the Reynolds number may be too large to have a
steady-state solution for the problem. It is also possible
that the problem is so non-linear, that it might need
ramping of the inlet velocity or Reynolds number.

In order to avoid trivial solutions, a maximum allowable
volume of ﬂuid is imposed as a constraint. The relative
volume of ﬂuid is in continuous form deﬁned as:

V =

1
|Ω|

(cid:90)

Ω

γ(x) dV

(21)

which represents the volumetric average of the design
ﬁeld. The relative ﬂuid volume should be restricted to
be below Vf ∈]0; 1[, which is the fraction of the total
domain allowed to be ﬂuid. After discretisation as de-
scribed in Section 4, the relative volume is computed
by:

V =

1
nel

nel(cid:88)

e=1

γe

(22)

where nel is the number of elements and it has been
exploited that all elements have the same volume in
the current implementation.

5.3 Optimisation problem

The ﬁnal discretised optimisation problem is:

minimise:
γ

fφ (s(γ), γ) = φ

subject to: V (γ) ≤ Vf

with:

r(s(γ), γ) = 0

(23)

2 The lower bound is chosen to avoid stagnation.

0 ≤ γi ≤ 1, i = 1, . . . , nel

10

5.4 Adjoint sensitivity analysis

The gradients of any functionals dependent on the state
ﬁeld are found using adjoint sensitivity analysis. A gen-
eral description is given in Appendix C. The sensitivi-
ties for a generic functional f are found from:

df
dγe

=

∂f
∂γe

− λT ∂r
∂γe

(24)

where λ is the vector of adjoint variables for the state
residual constraint found from the adjoint problem:

T

∂r
∂s

λ =

T

∂f
∂s

(25)

The above is valid for any equation system formulated
as a residual, r, and any state-dependent functional, f ,
be it objectives or constraints. For a given system, two
partial derivatives of the residual are necessary, and for
a given functional, two partial derivatives of the func-
tional are necessary: with respect to the design ﬁeld and
the state ﬁeld. These partial derivatives can be found
analytically by hand, but in the presented implementa-
tion they are found automatically using symbolic dif-
ferentiation in MATLAB.

5.5 Optimality criteria optimiser

An optimality criteria (OC) based optimisation algo-
rithm is used in the presented code. The implemented
OC method is the modiﬁed version suggested by Bendsøe
and Sigmund (2004) for compliant mechanism prob-
lems, where the design gradients can be both positive
and negative:

γnew
e =






γL
e
γU
e
γeBe

if γeBe
if γeBe
η otherwise

η ≤ γL
e
η ≥ γU
e

Joe Alexandersen

by the negative gradients (more ﬂuid is better). How-
ever, this has worked extremely well for the problems
at hand, because mostly the dissipated energy gradients
are negative.

The Lagrange multiplier is found using bisection. To
speed up the process, the upper bound estimate sug-
gested by Ferrari and Sigmund (2020) is modiﬁed for
η = 1
3 :





¯l =

1
nelVf

ne(cid:88)

e=1

(cid:32)

γe

−

∂φ
∂γe
∂V
∂γe

3
3 

(cid:33) 1



(29)

5.6 Continuation scheme

As shown by Borrvall and Petersson (2003), the min-
imisation of dissipated energy is self-penalising for the
Brinkman approach with linear interpolation of α(γ).
This means that intermediate design values are not ben-
eﬁcial and the optimal solutions are discrete 0-1. How-
ever, it is often beneﬁcial to relax the problem using
the interpolation factor, qα, in the initial stages of the
optimisation process in order to avoid convergence to
particularly poor local minima. Therefore, it is common
to solve the minimisation problem for a sequence of qα,
known as a continuation scheme.

In the presented code, a heuristic approach is imple-
mented to automatically choose the interpolation fac-
tor. The sequence for the continuation scheme is given
by:

qα ∈

(cid:26)

q0
α,

(cid:27)

q0
α
2

,

q0
α
10

,

q0
α
20

where:

(26)

q0
α =

(αmax − α0) − x0 (αmax − αmin)
x0 (α0 − αmin)

(30)

(31)

where η = 1
at each iteration are given as:

3 is a damping factor and the upper bounds

γL
e = max(0, γe − m)

γU
e = min(1, γe + m)

(27a)

(27b)

with m being the movelimit. The optimality criteria
ratio is given as:

(cid:32)

Be = max

ε,

(cid:33)

− ∂φ
∂γe
l ∂V
∂γe

(28)

where ε is a small positive number (e.g. 10−10) and l
is the Lagrange multiplier for the volume constraint.
This means that positive gradients (less ﬂuid is bet-
ter) are ignored and the design process is driven only

is the initial interpolation factor necessary to ensure an
initial Brinkman penalty of α0 for an initial design ﬁeld
value of x0. The interpolation factor is changed when
the subproblem is considered converged or after a pre-
deﬁned number of design iterations. For the problems
implemented in the presented code, an initial Brinkman
penalty of α0 = 2.5µ
0.12 works very well. However, do bear
in mind that this is a heuristic value and will not work
for all problems and all settings.

Due to the non-convexity, the initial Brinkman penalty

of the domain plays an important role in which direc-
tion the design will progress. The initial ﬂow ﬁeld de-
termines the exploration of the design space, because if
the ﬂow is not moving through some parts of the design
domain, sensitivities will often be near zero in those ar-
eas. Therefore, it is often beneﬁcial to start with an

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

11

Fig. 10: Problem setup for the double pipe problem.

initial Brinkman penalty that allows for the ﬂuid to
move into most areas of the domain. This was for in-
stance recently observed in the topology optimisation
of heat exchanger designs by Høghøj et al. (2020).

6 Benchmark examples

6.1 Double pipe problem

This problem was ﬁrst introduced by Borrvall and Pe-
tersson (2003) and is illustrated in Figure 10. On the
left-hand side, there are two inlets at which parabolic
normal velocity proﬁles are prescribed with a maximum
velocity of Uin. On the right-hand side, there are two
zero-pressure outlets at which the ﬂow is speciﬁed to
exit in the normal direction. This is a more realistic
boundary condition traditionally used in the compu-
tational ﬂuid dynamics community, compared to pre-
scribed parabolic ﬂow proﬁles at the outlets (Borrvall
and Petersson, 2003). However, this does introduce new
and better minima as was shown by Papadopoulos et al.
(2021), which makes the problem more diﬃcult.

Fig. 11: Problem setup for the pipe bend problem.

(a) Local nodal numbering

(b) Global nodal and element numbering

Fig. 12: Local and global numbering. Numbers with-
out circles indicate nodal numbering and number with
circles indicate element numbering.

7 MATLAB implementation

7.1 Mesh and numbering

6.2 Pipe bend problem

This problem was also introduced by Borrvall and Pe-
tersson (2003) and is illustrated in Figure 11. On the
left-hand side, there is an inlet at which a parabolic
normal velocity proﬁle is prescribed with a maximum
velocity of Uin. On the bottom, there is a zero-pressure
outlet at which the ﬂow is speciﬁed to exit in the normal
direction - a minor change from Borrvall and Petersson
(2003) as for the double pipe problem.

Figure 12 shows the local and global numbering used
in the presented implementation. As shown in Figure
12b, for the global numbering of both the nodes and el-
ements begins in the upper-left corner, increasing from
top to bottom and then from left to right. The origin of
the global coordinate system is placed in the upper-left
corner, with the ﬁrst spatial direction, x1, being posi-
tive from left to right and the second spatial direction,
x2, being positive from top to bottom. This orientation

12

Joe Alexandersen

has been chosen to simplify easy plotting of the various
spatial ﬁelds in MATLAB. The velocity and pressure
DOFs follow the ordering of the nodes and the design
ﬁeld follows the ordering of the elements.

7.2 Brief description of code

The full code consists of multiple ﬁles, the main ones of
which are available in Appendices D-H. The full code
base is available on GitHub (Alexandersen, 2022).

The main ﬁle topFlow.m (Appendix D) can be di-
vided into three parts: pre-processing, optimisation loop,
and post-processing. Each part will be very brieﬂy de-
scribed herein, except the deﬁnition of problem param-
eters which is treated in detail below since this will be
of importance to the subsequent deﬁnition of examples
and results. A detailed description of the code is avail-
able in the Supplementary Material.

7.2.1 Deﬁnition of input parameter (lines 6-29)

The pre-processing part starts with the setting of in-
put parameters (lines 6-29) to deﬁne the problem and
optimisation parameters. In the presented code, two
diﬀerent problems are already implemented and the
probtype variable determines which one is to be op-
timised:

7 % PROBLEM TO SOLVE (1 = DOUBLE PIPE; 2 = ...

PIPE BEND)

8 probtype = 1;

Next the dimensions of the domain and the discretisa-
tion are given:

9 % DOMAIN SIZE
10 Lx = 1.0; Ly = 1.0;
11 % DOMAIN DISCRETISATION
12 nely = 30; nelx = nely*Lx/Ly;

where Lx and Ly are the dimensions in the x - and y-
directions, respectively. The number of elements in the
x-direction, nelx, is automatically determined from the
supplied number of elements in the y-direction, nely, to
ensure square elements. The implementation can handle
rectangular elements, so nelx can be decoupled from
nely if necessary.

The allowable volume fraction Vf is stored in the
volfrac variable and the initial design ﬁeld value is set
to be the same to fulﬁll the volume constraint from the
start:

13 % ALLOWABLE FLUID VOLUME FRACTION
14 volfrac = 1/3; xinit = volfrac;

The inlet velocity Uin is stored in the variable Uin and
the ﬂuid density, ρ and dynamic viscosity, µ, are stored
in the variables rho and mu, respectively:

% PHYSICAL PARAMETERS
Uin = 1e0; rho = 1e0; mu = 1e0;

The maximum and minimum Brinkman penalty fac-
tors are per default deﬁned with respect to an out-of-
plane thickness according to Equation 9 (Borrvall and
Petersson, 2003) and the heuristic continuation scheme
is automatically computed and stored in qavec:

% BRINKMAN PENALISATION
alphamax = 2.5*mu/(0.01ˆ2); alphamin = ...

2.5*mu/(100ˆ2);
% CONTINUATION STRATEGY
ainit = 2.5*mu/(0.1ˆ2);
qinit = (−xinit*(alphamax−alphamin) − ...

ainit + ...
alphamax)/(xinit*(ainit−alphamin));
qavec = qinit./[1 2 10 20]; qanum = ...

length(qavec); conit = 50;

where ainit is the initial Brinkman penalty, qinit is
the initial interpolation factor computed using Equa-
tion 31, qanum is the number of continuation steps, and
conit is the maximum number of iterations per contin-
uation step.

Various optimisation parameters are then deﬁned:

% OPTIMISATION PARAMETERS
maxiter = qanum*conit; mvlim = 0.2; ...

plotdes = 0;

chlim = 1e−3; chnum = 5;

where maxiter is the maximum number of total design
iterations, mvlim is the movelimit m for the OC update,
chlim is the stopping criteria, chnum is the number of
subsequent iterations the convergence criteria must be
met, and plotdes is a Boolean determining whether to
plot the design during the optimisation process (0 =
no, 1 = yes).

The parameters for the Newton solver are deﬁned:

% NEWTON SOLVER PARAMETERS
nltol = 1e−6; nlmax = 25; plotres = 0;

where nltol is the required residual tolerance for con-
vergence, nlmax is the maximum number of non-linear
iterations, and plotres is a Boolean determining whether
to plot the convergence of the residual norm over the
optimisation process (0 = no, 1 = yes).

Finally, the option to export the contour of the ﬁnal
design as a DXF (Data Exchange Format) ﬁle can be
activated:

% EXPORT FILE
filename='output'; exportdxf = 0;

where filename is a speciﬁed ﬁlename and exportdxf
is a Boolean determining whether to export the design
(0 = no, 1 = yes).

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

13

7.2.2 Other pre-processing (lines 30-66)

Subsequently, various arrays are deﬁned (lines 30-44)
for the quick assembly of the matrices and vectors from
the ﬁnite element analysis based on the sparse function
in MATLAB. The boundary conditions for the avail-
able problems are deﬁned in the separate MATLAB
ﬁle problems.m (Appendix E) and matrices for quick
enforcement of Dirichlet conditions are built (lines 45-
51). Finally, various arrays, counters and constants are
initialised (lines 52-66).

Parameter Value
Lx
Ly
ρ
µ
αmax
αmin
Vf
ne
x
ne
y

1
1
10−3
1
2.5µ/(0.012)
2.5µ/(1002)
1/3
102
102

Code
Lx = 1.0
Ly = 1.0
rho = 1e-3
mu = 1.0
alphamax = 2.5*mu/(0.01^2)
alphamin = 2.5*mu/(100^2)
volfrac = 1/3
nelx = 102
nely = 102

Table 1: Parameter values used for double pipe solu-
tions in Figures 13 and 14.

7.2.3 Optimisation loop (lines 67-167)

Prior to the optimisation loop start, some information
is output to the screen and timers are initiated (lines
67-73). The optimisation starts using a while loop (line
74) and computation of the greyscale indicator (Sig-
mund, 2007) and material interpolation per Equation 8
(lines 76-80). The non-linear solver loop iteratively up-
dates the solution (lines 81-112) using Newton’s method
according to Section 4.2. The ﬁnite element analysis is
carried out according to Section 4.1 (lines 85-93) using
function RES and JAC to build to residual vector and Ja-
cobian matrix, respectively. For the converged solution,
the objective functional is evaluated (line 114) using the
function PHI according to Section 5.1 and the volume
is evaluated for the current design (line 117) according
to Section 5.2. The current solution is evaluated (lines
124-126) and if it is not considered converged, then the
adjoint problem is formed and solved (lines 131-136)
and the sensitivities are computed (lines 137-144) ac-
cording to Section 5.4. Subsequently, the design ﬁeld is
updated using the optimality criteria optimiser (lines
145-154) according to Section 5.5. Before repeating the
process for the new design, the interpolation parameter
is updated if necessary according to the continuation
scheme (lines 155-159) in Section 5.6.

The functions for evaluating the residual vector, Ja-
cobian matrix, objective functional, and their partial
derivatives, are all automatically built using the ﬁle
analyticalElement.m. This script uses the MATLAB
Symbolic Toolbox to symbolically derive and diﬀeren-
tiate the required vectors and matrices.

7.2.4 Post-processing (lines 168-170)

The results are post-processed and plotted in an exter-
nal ﬁle postproc.m (line 169), where 5 standard plots
are made:

1. Design ﬁeld γ(x)
2. Brinkman penalty ﬁeld, α(γ(x))
√
3. Velocity magnitude ﬁeld, U =

uiui

4. Pressure ﬁeld, p
5. Velocity and design ﬁeld along a cut-line

Finally, if requested by setting exportdxf = 1, the con-
tour of the ﬁnal optimised design is exported to DXF
format for veriﬁcation analysis in external software.

8 Examples

8.1 Double pipe problem

This problem was introduced in Section 6.1 and is the
default for the provided code when probtype = 1. It
was originally introduced by Borrvall and Petersson
(2003) for Stokes ﬂow, but will herein also be optimised
for Navier-Stokes ﬂow.

8.1.1 Stokes ﬂow

In order to make the results directly comparable to
those of Borrvall and Petersson (2003), the parameter
values are set as in Table 1. To simulate Stokes ﬂow ide-
ally the density would be set to 0, but due to the current
implementation not being able to handle that, the den-
sity is set to a small number, ρ = 10−3 instead. This
yields an inlet Reynolds number of Rein = 1.67 × 10−4,
which is suﬃciently small to ensure Stokes ﬂow.

Figure 13 shows the optimised design and corre-
sponding physical ﬁelds for a square domain with Rein =
1. From Figure 13b it can be seen that the converged
design in Figure 13a ensures the lowest and highest
Brinkman penalty factor in the ﬂuid region and solid
region, respectively. This results in negligible velocities
in the solid region with the ﬂow passing easily through
the channels, as seen in Figure 13c. Figure 13d shows
the pressure ﬁeld, where it can be seen that a con-
tinuous pressure ﬁeld exists even in the solid region.
The ﬁnal objective value is φ = 22.0956, which is very
close to the value of 25.67 reported by Borrvall and
Petersson (2003). Diﬀerences can be attributed to dif-
ferent implementations, most likely the fact that the

14

Joe Alexandersen

Parameter Value
ρ
µ

1
1/6Rein

Code
rho = 1.0
mu = 1/(6*20)

Table 2: Updated values used for double pipe solutions
in Figure 15. Other values are given in Table 1.

present uses stabilised linear ﬁnite elements in contrast
to mixed-order quadratic-linear elements (Borrvall and
Petersson, 2003). The level of intermediate design vari-
ables since the ﬁnal interpolation factors are almost the
same, at 9.85 for the present code and an equivalent of
10 in Borrvall and Petersson (2003), and the level of
greyscale is therefore similar.

An elongated domain is investigated by setting Lx =
1.5 similar to Borrvall and Petersson (2003), with the
number of elements increased proportionally in the same
direction. Figure 14 shows the optimised design and cor-
responding physical ﬁelds. The optimised design is now
a “double wrench” design, where the channels merge at
the centre to minimise viscous losses along the channel
walls. The ﬁnal objective value is φ = 23.5732, which
is very close to the value of 27.64 reported by Borrvall
and Petersson (2003).

8.1.2 Navier-Stokes

In order to non-dimensionalise the problem and con-
trol it using the Reynolds number, Rein, the density is
set to ρ = 1 (rho = 1.0) and the viscosity is set to
µ = 1/6Rein (mu = 1/(6*20)). The 6 in the denomina-
tor ensures that the Reynolds number, Rein, is based
on the inlet height which is Ly
6 as shown in Figure 10.
Other parameter values are as previously.

Figure 15 shows the optimised designs obtained for
increasing Reynolds number. It is observed that for
Rein = 40 and above, the OC solver converges to the lo-
cal minimum of two “straight” channels. It is observed
using COMSOL simulations, that this local minimum
is worse than the double wrench channel for Reynolds
numbers up to 200. The MMA solver introduced in Sec-
tion 9.2.1 is actually able to converge to a signiﬁcantly
better design for Rein = 40.

8.1.3 Variation of αmax

To demonstrate the robustness of the proposed heuris-
tic initial Brinkman penalty and continuation scheme,
as well as the insensitivity of minimum dissipation opti-
misation to the maximum Brinkman penalty, the dou-
ble pipe problem will be optimised for Rein = 20 using
5 additional αmax. Getting to the double wrench chan-
nel for Rein = 20 seems pretty diﬃcult and the poorer

(a) Design ﬁeld

(b) Brinkman penalty ﬁeld

(c) Velocity magnitude ﬁeld

(d) Pressure ﬁeld

Fig. 13: Optimised design and corresponding physical
ﬁelds for the double pipe problem with Lx = 1 and
Rein = 10−3. Final values: φ = 22.0956 after 63 itera-
tions.

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

15

(a) Design ﬁeld

(a) Rein = 20

(b) Brinkman penalty ﬁeld

(b) Rein = 40

Fig. 15: Optimised designs for the double pipe problem
with increasing Reynolds number and Lx = 1.5. Final
values: (a) φ = 0.2126 after 102 iterations; (b) φ =
0.1380 after 59 iterations.

local minima double pipe design is obtained very eas-
ily. Having a constant ﬁxed initial Brinkman penalty,
αinit, of the entire design domain ensures that the same
initial ﬂow ﬁeld is obtained independent of maximum
Brinkman penalty, αmax.

The values predicted by the presented MATLAB
code are compared to veriﬁcation analyses using COM-
SOL of post-processed designs. The export.m ﬁle pro-
vides export capabilities of the design ﬁeld contour to
the DXF ﬁle format. The DXF ﬁle can then be im-
ported into COMSOL and used to trim the computa-
tional domain. An example COMSOL ﬁle is included in
the Supplementary Material.

Figure 16 shows the dissipated energy of the ﬁnal
optimised designs. The ﬁnal designs look basically iden-
tical to Figure 15a and are, thus, not shown here. It
can be seen that the post-processed performance of
the designs are more or less constant independent of
αmax. The values predicted by the continuous Brinkman
model are seen to be quite far oﬀ for lower maximum
penalties. However, this shows that even a low maxi-
mum Brinkman penalty, which in theory yields a large
error in the prediction of the dissipated energy (Figure

(c) Velocity magnitude ﬁeld

(d) Pressure ﬁeld

Fig. 14: Optimised design and corresponding physical
ﬁelds for the double pipe problem with Lx = 1.5 and
Rein = 10−3. Final values: φ = 23.5732 after 87 itera-
tions.

16

Joe Alexandersen

Fig. 16: Rein = 20

Parameter Value
Lx
Ly
ρ
µ
αmax
αmin
Vf
ne
x
ne
y

1
1
10−3
1
2.5µ/(1/0.012)
2.5µ/(1002)
0.25
100
100

Code
Lx = 1.0
Ly = 1.0
rho = 1e-3
mu = 1.0
alphamax = 2.5*mu/(1/0.01^2)
alphamin = 2.5*mu/(100^2)
volfrac = 0.25
nelx = 100
nely = 100

Table 3: Parameter values used for pipe bend solution
in Figure 17.

7), ends up giving the same or close to the same ﬁnal
design and performance. This insensitivity was already
noted originally by Borrvall and Petersson (2003), but
not explicitly shown.

This conclusion is somewhat disconnected from the
investigations of the ﬂow accuracy in Section 3.3 and
Figure 5. However, in contrast to the reference geome-
try in Section 3.3, the ﬁnal optimised design for mini-
mum dissipated energy do not have re-circulation zones,
since this is detrimental to the energy functional. There-
fore, for the optimised designs, a lower maximum Brinkman
penalty appears to be forgiving.

8.2 Pipe bend problem

Fig. 17: Optimised design for the pipe bend problem
using values from Borrvall and Petersson (2003). Final
values: φ = 9.1862 after 66 iterations.

Parameter Value
Lx
Ly
ρ
µ
αmin
αmax
Vf
ne
x
ne
y

1
1
10−3
1/(5 Rein)
2.5µ/(1/52)
104αmin
0.25
100
100

Code
Lx = 1.0
Ly = 1.0
rho = 1.0
mu = 1/(5*10)
alphamin = 2.5*mu/(1/5^2)
alphamax = 1e4*alphamin
volfrac = 0.25
nelx = 100
nely = 100

Table 4: Parameter values used for pipe bend solution
in Figure 18.

8.2.1 Stokes ﬂow

In order to make the results comparable to those of
Borrvall and Petersson (2003), the parameter values are
set as in Table 3. As previously, the density is set to a
small number, ρ = 10−3, yielding an inlet Reynolds
number of Rein = 2 × 10−4 which is small enough to
approximate Stokes ﬂow.

Figure 17 shows the optimised design obtained using
the values from Borrvall and Petersson (2003) listed in
Table 3. The design is a straight channel from the inlet
to the outlet with a ﬁnal objective value of φ = 22.0956,
which is very close to the value of 25.67 reported by Bor-
rvall and Petersson (2003). The streamlines show that
the maximum Brinkman penalty is not large enough to
provide enough resistance to ﬂow through the solid re-
gions. However, as previously shown, while increasing
the αmax may increase the accuracy of the ﬂow mod-
elling, almost identical optimised designs are obtained
for minimum dissipated energy.

This problem was introduced in Section 6.2 and is se-
lected in the code by setting probtype = 2. It was orig-
inally introduced by Borrvall and Petersson (2003) for
Stokes ﬂow and also treated by Gersborg-Hansen et al.
(2005) for Navier-Stokes ﬂow.

8.2.2 Navier-Stokes ﬂow

In order to investigate the eﬀect of inertia, the out-of-
plane channel height is set to the width of the inlet. This
ensures a hydraulic diameter of the inlet width/height

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

17

Fig. 18: Design contours for the pipe bend problem
with increasing Reynolds number. Final values: (a) φ =
2.484 × 10−1 after 58 iterations; (b) φ = 2.830 × 10−2
after 63 iterations; (c) φ = 6.502 × 10−3 after 40 itera-
tions.

Optimised for:

Analysed at: Re = 10 Re = 100 Re = 500

Re = 10 [×10−1]
Re = 100 [×10−2]
Re = 500 [×10−3]

2.484
2.889
8.459

2.731
2.830
6.553

3.071
3.105
6.502

Table 5: Cross-check table of the optimised designs
for the pipe bend problem shown in Figure 18. Values
should be multiplied by. The best performing design for
each analysis Reynolds number is highlighted in bold.

Fig. 19: Problem setup for the modiﬁed rugby ball prob-
lem.

9 Modiﬁcations

This Section presents a series of extensions to the pro-
vided code, showing how it is possible to extend it to
solve a range of more complicated examples including
ﬁxed regions and other objective functionals.

9.1 Fixed regions of solid and ﬂuid

and a well-deﬁned Reynolds number. The problem is
non-dimensionalised and controlled using the inlet Reynolds
number, Rein, leading to the parameter values listed in
Table 4. The 5 in the denominator of the viscosity en-
sures that the Reynolds number is based on the inlet
width, which is Ly

5 as shown in Figure 11.
Figure 18 shows the contours of the optimised de-
signs for increasing Reynolds number. For a low Reynolds
number, Rein = 10, a more or less straight pipe is
formed similar to that for Stokes ﬂow. When the Reynolds
number increases, inertia begins to play a role and the
curvature of the pipe changes to accommodate this.
This is conﬁrmed by the cross-check of the three designs
with the objective values in Table 5. A cross-check is
strictly necessary prior to drawing conclusions from de-
signs optimised for diﬀerent conditions. A cross-check
is where the optimised designs are tested for the other
ﬂow conditions and compared. A successful cross-check
is where the design optimised for certain conditions is
also the best for these conditions. This means it has the
lowest value in its own row, such that the diagonal has
the best values as highlighted in bold in Table 5.

It is common that the design domain is only a subset of
the computational domain, where the rest is deﬁned as
ﬁxed solid or ﬂuid domains. In the discretised problem
this can be handled by restricting optimisation to the
active elements in the deﬁned design domain, with pas-
sive elements in the ﬁxed domains remaining constant
at their prescribed value.

The implementation of passive and active elements
will be illustrated using the so-called rugby ball prob-
lem, introduced by Borrvall and Petersson (2003) in the
context of topology optimisation, but it has its roots
in the work by Pironneau (1973). Figure 19 shows the
external ﬂow problem with a free ﬂow velocity of Uin
applied around the entire outer boundary and a single
zero-pressure point constraint in the upper-left corner.
A thin region next to the boundary all the way around
the outside will be prescribed as ﬂuid regions and a
solid square will be prescribed in the centre of the do-
main. The solid square is not imposed originally, but
is done so here to demonstrate the deﬁnition of both
types of passive domains. Table 6 lists the parameter
values used herein.

18

Joe Alexandersen

Parameter Value
Lx
Ly
ρ
µ
αmax
αmin
Vf
ne
x
ne
y

1
1
10−3
1
2.5µ/(0.012)
2.5µ/(1002)
0.94
100
100

Code
Lx = 1.0
Ly = 1.0
rho = 1e-3
mu = 1.0
alphamax = 2.5*mu/(0.01^2)
alphamin = 2.5*mu/(100^2)
volfrac = 0.94
nelx = 100
nely = 100

Table 6: Parameter values used for rugby ball solutions
in Figure 20.

First of all, the new problem should be added to
problems.m. Add the following after line 56 to create
a third problem:

elseif (probtype == 3) % RUGBY BALL PROBLEM
if ( mod(nelx,5) > 0 | | mod(nely,5) > 0 )
error('ERROR: Number of elements per side ...

must be divisable by 5.');

end

The element number check is needed, since the solid
square will be deﬁned in terms of ﬁfths of the domain
height and width. Then deﬁne the boundary conditions
and Reynolds number as follows:

nodesOuter = [1:nody−1 nody:nody:nodtot ...

nody+1:nody:nodtot ...
(nodx−1)*nody+1:nodtot−1];

nodesPressure = 1;
fixedDofsOuterX = 2*nodesOuter−1; ...
fixedDofsOuterY = 2*nodesOuter;

fixedDofsU = [fixedDofsOuterX ...

fixedDofsOuterY];

fixedDofsP = 2*nodtot+nodesPressure;
fixedDofs = [fixedDofsU fixedDofsP];
% DIRICHLET VECTORS
DIRU=zeros(nodtot*2,1); DIRP=zeros(nodtot,1);
DIRU(fixedDofsOuterX) = Uin; DIR = [DIRU; ...

DIRP];

% INLET REYNOLDS NUMBER
Renum = Uin*Ly*rho/mu;

The ﬂuid region will be deﬁned as a single element wide
layer around the outer edge:

% PASSIVE ELEMENTS
fluid = [1:nely nely:nely:neltot ...

(nely+1):nely:neltot ...
(nelx−1)*nely+1:neltot−1];

The solid square is deﬁned as the central one ﬁfth of
the domain height and width:

x = 2*nelx/5:3*nelx/5; y = 2*nely/5:3*nely/5;
[X,Y] = meshgrid(x,y);
solid = sub2ind([nely nelx],Y(:),X(:))';

Finally, all elements of the computational domain will
be classiﬁed as either passive or active:

passive = [solid fluid]';

active = setdiff(1:neltot,passive)';
nactive = length(active);

where nactive is the number of active elements to be
used in the main script. In order to make the updated
code backwards compatible with the ﬁrst two problems
deﬁned in problem.m, the following must be added at
the bottom of each deﬁnition:

% PASSIVE ELEMENTS
solid = []; fluid = [];
passive = [solid fluid]'; ...
active = setdiff(1:neltot,passive)';
nactive = length(active);

Now, modiﬁcations needs to be made to the main
script topFlow.m in order to ensure that passive ele-
ments are given their prescribed value and that the op-
timisation is only applied to the active elements. After
line 57, where the initial design ﬁeld is deﬁned, add the
corrections for the prescribed values:

xPhys(solid) = 0.0; xPhys(fluid) = 1.0;

Next, the greyscale indicator should be calculated for
the design domain only, so change line 77 to:

Md = 100*full(4*sum(xPhys(active).* ...

(1−xPhys(active)))/nactive);

The volume constraint should also be modiﬁed to only
account for the design domain. The evaluation on line
117 should be updated to:

V = mean(xPhys(active));

and the sensitivities updated accordingly on line 144:

dV = ones(nely,nelx)/nactive; dV(passive) ...

= 0.0;

The sensitivities of the objective for the passive ele-
ments should also be set to 0, so add the following after
the sensitivity calculation on line 142:

sens(passive) = 0.0;

In order to only update the active elements, the pre-
and post-steps of the OC solver should be updated.
Lines 146-147 should be updated to:

xnew = xPhys(active); ...
xlow = xPhys(active)−mvlim; ...
xupp = xPhys(active)+mvlim;
ocfac = xPhys(active).*max(1e−10, ...

(−sens(active)./dV(active))).ˆ(1/3);

and line 154 should be updated to:

xPhys(active) = xnew;

In order to solve the rugby ball problem, it is not
necessary to use a continuation strategy for the interpo-
lation parameter. As noted by Borrvall and Petersson
(2003), the problem is very well-conditioned and it is
plenty to use a single parameter value from the start.

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

19

9.2 Other objective functionals

In order to treat other objective functionals than the
dissipated energy, a general optimisation solver is needed.
Herein the popular Method of Moving Asymptotes (MMA)
will be implemented.

9.2.1 Method of Moving Asymptotes (MMA)

The Method of Moving Asymptotes (MMA) by Svan-
berg (1987) is a very popular optimisation solver within
the topolog optimisation community because it handles
general optimisation problems with many design vari-
ables extremely well. The MATLAB version of MMA
is freely available for download under the GNU GPLv3
license SMOPTIT (2022) and the ﬁles mmasub.m and
subsolv.m are needed.

In order to use MMA, there are a series of variables
and parameters that must be deﬁned under the initial-
isation block. After line 66, add the following:

% Initialise MMA parameters
numconstr = 1;
xold1 = xPhys(:); xold2 = xPhys(:); xnew = ...

xPhys(:);
low = 0; upp = 0;
a0 = 1; ai = 0*ones(numconstr,1);
c = 1000*ones(numconstr,1); ...
d = ones(numconstr,1);

where numconstr is the number of constraints and a0,
ai, c and d all are parameters for setting the type of
problem to be solved by MMA. Please see the document
by Svanberg (2007) for details on these parameters. In
this document, it is also discussed that MMA works
best when the objective and constraint functionals are
scaled properly. A block computing the scaling should
be added after line 117:

%% MMA SCALING
if (loop == 0); obj0 = obj/10; end
f0 = obj/obj0; fi = V/volfrac − 1;

This scales the objective to start at 10 for the ﬁrst iter-
ation and the volume constraint to be at most 1 in mag-
nitude. The constraint is scaled to be at most around
one, by normalising the volume:

fi =

V
Vf

− 1

(32)

which should be less than 0. The sensitivities should of
course be scaled accordingly, which will come later. In
order to monitor the scaled values during the optimi-
sation, add the following output in the result printing
block of the code after line 128:

fprintf('

MMA: f0 = %4.3e − f1 = ...

%4.3e \n',f0,fi);

(a) Vf = 0.94

(b) Vf = 0.99

Fig. 20: Optimised designs for the modiﬁed rugby ball
problem with diﬀerent allowable ﬂuid volume fractions.
Final values: (a) φ = 13.503 after 19 iterations; (b)
φ = 9.839 after 17 iterations.

Therefore, the ﬁrst deﬁnition of line 22 should be up-
dated to qavec = 10 and lines 20 and 21 can be deleted.
Beware that changing αmax will now change the initial
Brinkman penalty.

Figure 20 shows the optimised design for volfrac
= 0.94 and volfrac = 0.99. In order to compare di-
rectly with the results of Borrvall and Petersson (2003),
the volume fraction has to account for the enforced solid
square, which means 0.04 has been added. Figure 20a
is visually identical to the result obtained by Borrvall
and Petersson (2003), with a ﬁnal dissipated energy of
φ = 13.503 compared to 14.44. Figure 20b shows the op-
timised design for a higher ﬂuid volume fraction, where
the enforced solid square is clearly seen. In contrast to
before, the design is now completely diﬀerent since the
solid square dominates the design and triangles have
been added in the up- and downwind directions to min-
imise dissipation. This also causes a signiﬁcantly higher
dissipated energy of φ = 9.839 compared to the freely-
optimised design by Borrvall and Petersson (2003) with
8.35.

20

Joe Alexandersen

pressure and straight-out ﬂow condition is imposed.
The optimisation problem is formulated as a minimi-
sation problem:

minimise:
γ

fu (s(γ)) = −Up

subject to: V (γ) ≤ Vf

pin (s(γ)) ≤ βpref
r(s(γ), γ) = 0

with:

0 ≤ γi ≤ 1, i = 1, . . . , nel

(33)

Fig. 21: Optimised design for the double pipe problem
using MMA and a random initial design ﬁeld. Final
values: φ = 0.0876 after 200 iterations (maximum).

The entire OC solver block (lines 145-154) can now be
replaced with:

%% MMA UPDATE
df0 = sens(:)/obj0; dfi = dV(:)'/volfrac;
xlow = max(0,xPhys(:)−mvlim); ...
xupp = min(1,xPhys(:)+mvlim);

[xnew,¬,¬,¬,¬,¬,¬,¬,¬,low,upp] = ...

mmasub(numconstr,neltot,loop,xPhys(:), ...
xlow,xupp,xold1,xold2,f0,df0,fi,dfi, ...
low,upp, a0,ai,c,d);

xold2 = xold1; xold1 = xPhys(:); xPhys(:) ...

= xnew;

As was shown by Papadopoulos et al. (2021) for
Stokes ﬂow, even better minima exists for the double
pipe problem when using open boundary conditions at
the outlet as in Figure 10. The better designs still uses
merged channels, but only a single of the outlets are
used. By decreasing the stopping tolerance for the rel-
ative change in the objective to chlim = 1e-4, MMA
is actually able to ﬁnd the better performing design
shown in Figure 21. This is likely because MMA uses
all gradients, both positive and negative, whereas OC
only uses positive gradients (add ﬂuid). Removing one
of the outlet channels requires to remove ﬂuid caused
by negative gradients.

9.2.2 Flow reversal

Gersborg-Hansen et al. (2005) introduced the ﬂow re-
versal problem, which is analogous to the compliant
mechanism problem in topology optimisation of solid
mechanics. Instead of giving the exact code modiﬁca-
tions needed, instructions will be given and the imple-
mentation will be left as an exercise for the reader.

The goal is to maximise the velocity of the ﬂow in
the reverse direction of the incoming ﬂow, denoted Up
as seen in Figure 22. A parabolic ﬂow proﬁle enters the
domain at the left-hand side and at the outlet a zero-

where the minus infront of Up is to turn the maximi-
sation problem into a minimisation problem. The ve-
locity to be maximised is deﬁned as the negative of
the velocity component in the x2-direction at the point
(x1, x2) =

(cid:16) Lx

(cid:17)

:

2 , Ly

2

Up = −u2

(cid:19)

(cid:18) Lx
2

,

Ly
2

(34)

For the discretised problem, the objective functional
then becomes:

fu = lu

T s

(35)

where lu is a vector of zeros except at the velocity DOF
of interest, where a 1 is placed. The vector product
then extracts the velocity value at the DOF of interest.
According to Equation 25, the adjoint right-hand side
is easily found to be simply this vector:

T

∂fu
∂s

= lu

(36)

This problem is more complex than minimum dissi-
pation, since it includes a constraint on the inlet pres-
sure, pin, and thus requires solving an additional adjoint
problem. The inlet pressure is deﬁned as:

pin =

1
|Γin|

(cid:90)

Γin

p dS

(37)

which is equivalent to the pressure drop since zero pres-
sure is imposed at the outlet. When discretised, this can
be formulated as:

pin = lp

T s

(38)

where lp results from the integration of the shape func-
tions for pressure over the inlet boundary. This can be
approximated as a vector of zeros with 1
on the pres-
nin
sure DOFs along the inlet boundary, where nin is the
number of nodes along the inlet boundary. According to
Equation 25, the adjoint right-hand side is easily found
to be simply the vector:

T

∂pin
∂s

= lp

(39)

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

21

Fig. 22: Problem setup for the ﬂow reversal problem.

To evaluate the objective and inlet pressure, the
user must ﬁrst deﬁne the vectors lu and lp under pre-
processing and then the values can be evaluated in the
optimisation loop using the vector products given by
Equations 35 and 38. To evaluate the sensitivities, two
adjoint problems must be solved. In order to do so eﬃ-
ciently, the right-hand side of the adjoint problem can
be deﬁned as an array with two columns RHS = [lu
lp], where lu and lp are lu and lp, respectively. When
solving the adjoint problem, L = J’\RHS, MATLAB
solves both adjoint problems using the same factori-
sation of the Jacobian matrix. This yields two columns
of L corresponding to the adjoint solution for the ob-
jective and inlet pressure, respectively. The sensitivities
can then be computed separately for the two function-
als. Please note that for both functionals, the partial
derivative with respect to the design variables, ∂f
∂γ , are
zero.

The problem now has two constraints, one on the
ﬂuid volume and one on the inlet pressure, so numconstr
should be set to 2. Furthermore, the arrays of con-
straints and sensitivities, fi and dfi, should now have
two rows each corresponding to the two constraints.
The inlet pressure constraint should be scaled similarly
to the volume constraint, pin/pmax - 1, where pin is
pin and pmax is pmax, which should be deﬁned under
the deﬁnition of input parameters. Better behaviour of
MMA has been observed by setting the scaling of the
objective functional to just the initial objective value,
rather than a tenth of this value.

It is possible for the optimiser to get stuck at a so-
lution with zero velocity at the DOF of interest. This
occurs mainly when the initial design ﬁeld is constant
and symmetric. In order to push the optimiser away
from this local minima, a random initial design ﬁeld is
recommended for this problem. It is recommended to
generate it using the rand function in MATLAB and
save the generated design ﬁeld once. In order to ensure
the random design ﬁeld is close to the prescribed de-
sign ﬁeld value, in order to ensure the initial Brinkman
penalty is hit, the design ﬁeld can be deﬁned as:

Parameter Value
ρ
Lx
Ly
µ
αmin
αmax
Vf
ne
x
ne
y

1
5
1
1/(Rein)
0
µ/10−5
0.6
250
50

Code
rho = 1.0
Lx = 5.0
Ly = 1.0
mu = 1/1
alphamin = 0.0
alphamax = mu/(1e-5)
volfrac = 0.6
nelx = 250
nely = 50

Table 7: Parameter values for the ﬂow reversal problem
in Section 9.2.2.

xPhys = xinit + 0.1*(−0.5 + ...

rand(nely,nelx)); save('xRand.mat');

The same ﬁeld should then be loaded when changing
design parameters, ensuring a fair comparison between
diﬀerent parameter settings:

load('xRand.mat','xPhys');

The problem parameters are deﬁned in Table 7. The
maximum Brinkman penalty is set one order of magni-
tude higher than Gersborg-Hansen et al. (2005) used,
since their value seems to still allow signiﬁcant ﬂow
through solid feature, especially the thin features that
appear. The maximum pressure drop is set to diﬀerent
factors, β, relative to the pressure drop of an empty
channel, pref .

Figure 23 shows two optimised designs for Rein = 1
that qualitatively agree with those presented by Gersborg-
Hansen et al. (2005). Both designs have a characteris-
tic S-shaped ﬂow feature at the centre, the purpose of
which is to reverse the ﬂow direction as requested. It
can be seen that for the larger pressure drop, a single
channel connects the inlet to the outlet and because
all the ﬂuid has to pass through, the velocity becomes
large at the centre. For the smaller pressure drop, the
topology changes and a bypass channel is included to
reduce the pressure drop. The 46% reduction in pres-
sure drop leads to a signiﬁcant reduction of 79% in the
objective value.

22

Joe Alexandersen

(a) Design ﬁeld - β = 15

(b) Velocity magnitude - β = 15

(c) Design ﬁeld - β = 8

(d) Velocity magnitude - β = 8

Fig. 23: Optimised designs and velocity ﬁelds for the ﬂow reversal problem with Rein = 1 and variable maximum
pressure drop relative to pref = 39.870. Final values: (a,b) Up = 3.362 after 80 iterations; (c,d) Up = 0.693 after
112 iterations.

Figure 24 shows the optimised designs for Rein =
100 for two diﬀerent maximum pressure drops. It can
be seen that for this higher Reynolds number, the by-
pass channel is present for both designs. This is because
inertia is dominant in the ﬂow and having a sharp S-
turn for the entire ﬂow volume as in Figure 23a, causes
a 12 times higher pressure drop compared to the design
with the smallest bypass channel in Figure 24b.

9.2.3 Drag and lift

This example is inspired by the work of Kondoh et al.
(2012), who presented drag minimisation and lift max-
imisation using topology optimisation based on a va-
riety of objective function formulations. The simplest
deﬁnition of calculating the drag and lift force are based
on body forces resulting from the Brinkman penalty:

D =

L =

(cid:90)

Ω

(cid:90)

Ω

αu1 dV

αu2 dV

(40a)

(40b)

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

23

(a) β = 15

(b) β = 30

Fig. 24: Optimised designs and velocity ﬁelds for the ﬂow reversal problem with Rein = 100 and variable maximum
pressure drop relative to pref = 0.39819. Final values: (a) Up = 2.264 after 102 iterations; (b) Up = 4.075 after 88
iterations.

where D is the drag force and L is the lift force. Be-
ing a volumetric integration over the computational do-
main, the minimum drag objective can easily be im-
plemented by changing the objective functional in the
element derivation code analyticalElement.m to:

phi = alpha*ux(1);

for drag and equivalent for lift. However, because the
drag and lift only relate to either the x1 or x2 velocity
DOFs, respectively, the automatically generated output
from the Symbolic Toolbox for the partial derivatives
∂D
∂s and ∂L
∂s will contain single scalar zeros, instead of
vectors of zeros for a vectorised function. The output
should be modiﬁed from:

out1 = [t2;0;t2;0;t20;t2;0];

to:

out1 = [t2;zeros(1,length(t2));t2; ...

(1,length(t2));t2;zeros(1,length(t2)); ...
t2;zeros(1,length(t2))];

Figure 25 shows the problem setup for the drag and
lift problem. Similar to the rugby ball problem, a con-
stant velocity is imposed in the x1-direction along the
entire outer boundary with a single reference pressure
point in the upper-left corner. The design domain is a
subset of the computational ﬂow inspired by the work
of Kondoh et al. (2012). However, details of the phys-
ical dimensions are missing from the original work, so
the values used herein are given in Table 8. Kondoh
et al. (2012) deﬁnes the Reynolds number in term of

Parameter Value
ρ
Lx
Ly
Lc
µ
αmin
αmax
Vf
ne
x
ne
y
qα
Max. iter.

1
3
1
(cid:112)Vf |Ωd|
UinLcρ/Rein
0
µ/(10−5Lc)
0.85
300
100
10
100

Code
rho = 1.0
Lx = 3.0
Ly = 1.0
Lc = sqrt(volfrac*Lx/2*Ly/2)
mu = Uin*Lc*rho/1
alphamin = 0.0
alphamax = mu/(1e-5*Lc)
volfrac = 0.85
nelx = 300
nely = 100
qavec = 10
conit = 100

Table 8: Parameter values for the drag and lift problem
in Section 9.2.3.

a characteristic length given by the square root of the
area of the solid proﬁle:

(cid:113)

Lc =

Vf |Ωd|

(41)

where |Ωd| is the size of the design domain and Vf the
prescribed volume fraction. The maximum Brinkman
(10−5Lc) in order to ensure
penalty is deﬁned as αmax =
a value of 105 for a Reynolds number of 1.

µ

24

Joe Alexandersen

Fig. 25: Problem setup for the drag and lift problem.

The optimisation problem for minimum drag is for-

mulated as:

minimise:
γ

fD (s(γ), γ) = D

subject to: V (γ) ≤ Vf

with:

r(s(γ), γ) = 0

0 ≤ γi ≤ 1, i = 1, . . . , nel

(42)

which only requires a single adjoint problem for the
drag force, similar to the minimum dissipation problem.
For maximum lift, a maximum constraint on the drag
force is necessary to avoid very thin and sharply rotated
designs:

minimise:
γ

fL (s(γ), γ) = −L

subject to: V (γ) ≤ Vf

D (s(γ), γ) ≤ βDref
r(s(γ), γ) = 0

with:

0 ≤ γi ≤ 1, i = 1, . . . , nel

(43)

which means that a second adjoint problem is neces-
sary, similar to the ﬂow reversal problem. The maxi-
mum drag is set to diﬀerent factors, β, relative to that
of the drag minimised design, Dref. Kondoh et al. (2012)
also impose a constraint on the centre-of-gravity of the
proﬁle3, which is not included herein for simplicity. Fur-
thermore, similar to the rugby ball problem, a single
interpolation factor of qα = 10 is suﬃcient for this ex-
ternal ﬂow problem.

The MMA version of the code is required and this
can easily be updated to handle passive elements by
following the same steps as in Section 9.1 and basically
replacing xPhys, sens and dV with only the active ele-
ments (active) in the deﬁnition of arrays for MMA and
changing neltot to nactive in the call to MMA. It is

3 The constraint is not formulated explicitly anywhere in

the paper.

important to scale the drag constraint similarly to the
volume constraint, D/(βDref) − 1 ≤ 0, when inputting it
to MMA. Furthermore, the objective functional should
be scaled using the absolute of the initial value, espe-
cially for the maximisation of lift since otherwise the
sign changes incorrectly.

Figure 26 shows optimised designs for increasing
Reynolds number. The optimised designs are qualita-
tively similar to those presented by Kondoh et al. (2012).
It can be seen that for Re = 10, a more or less symmet-
ric proﬁle is observed. For Re = 100 and Re = 1000,
the proﬁles become elongated and tapered towards the
trailing edge as is well-known from aerodynamics.

Figure 27 shows optimised designs for maximum lift
at Re = 10. The drag optimised design from Figure 26a
is used as the initial design ﬁeld and the drag is con-
strained to be less than 10%, 20% and 100% higher than
the drag optimised case. It can be seen that the opti-
mised design becomes further elongated as larger drag
is allowed. The optimised designs are qualitatively sim-
ilar to those presented by Kondoh et al. (2012), except
the design for β = 2.0 which has a blunt tip due to
reaching the edge of the design domain.

9.3 Other extensions

Due to the similarity in structure of the presented code
to the well-known 88-line code for static mechanics,
many of the extensions made available to that code are
applicable here. For some problems, it might be relevant
to include length-scale control. For that purpose, ﬁlter-
ing, projection and robust formulations can be directly
copied from extensions to the 88-line code.

The purpose of the presented code is to stand on its
own as an introductory tool for newcomers to the ﬁeld.
However, it is also the idea that it will serve as the basis
for extension to ﬂow-driven multiphysics. A sequel pa-

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

25

(a) Re = 10

(b) Re = 100

(c) Re = 1000

Fig. 26: Optimised designs for minimum drag for increasing Reynolds number. Final values: (a) D = 2.4207 after
38 iterations; (b) D = 0.3399 after 37 iterations; (c) D = 0.0800 after 44 iterations.

per is planned treating ﬂuid-structure-interaction and
conjugate heat transfer.

10.1 Computational time

10 Computational performance

This subsection covers the computational time and mem-
ory use of the code. The results are given using both
a workstation and a laptop to compare the upper and
lower bounds of performance. The workstation was run-
ning Ubuntu 18.04.6LTS with an Intel Core i9-9980XE
CPU with 18 cores at 3.0GHz and 128GB of memory.
The laptop was running Windows 10 with an Intel Core
i5-8350U CPU with 4 cores at 1.7GHz and 8GB of mem-
ory. Both machines were running MATLAB R2021b
and had all unnecessary processes shut down. MAT-
LAB was completely shut down and restarted to clear
all memory cache between runs.

Due to the non-linear governing equations and the vastly
more complex ﬁnite element formulation, the present
code is signiﬁcantly slower than the available codes for
static mechanics. The computational time of a selected
number of results from the paper are listed in Table
9. It can be seen that overall all the examples can be
generated in 10 minutes or less on both of the types of
machine. Generally, the laptop takes around 50% longer
than the workstation, which is mostly attributed to the
signiﬁcantly lower clock-speed of the CPU, but a high
number of cores are likely also helpful for the vectorised
assembly procedure.

The computational time can easily be decreased by

doing one or both of the following:

1. Loosening the tolerance of the non-linear solver
2. Re-using the last Jacobian from the non-linear solver

for the adjoint solver

The tolerance of the non-linear solver, nltol, deter-
mines the number of iterations needed to provide a so-
lution with the required accuracy. Loosening the toler-

26

Joe Alexandersen

(a) β = 1.1

(b) β = 1.2

(c) β = 2.0

Fig. 27: Optimised designs for maximum lift at Re = 10 under increasing drag constraint relative to Dref = 2.4207
on the drag. Final values: (a) L = 2.0148 after 100 iterations (maximum); (b) L = 3.1882 after 100 iterations
(maximum); (c) L = 7.2880 after 60 iterations.

Problem
Double pipe
Pipe bend
Rugby ball
Flow reversal
Maximum lift

Re
20
500
1
100
10

Elements
15606
10000
10000
12500
30000

Iter. Total [min]
102
40
19
90
100

4.10
1.34
0.49
3.96
7.07

Workstation
Iteration [s] Memory [GB] Total [min]
1.6
1.6
1.6
1.4
2.3

6.08
1.2
1.3
6.00
10.60

2.41
2.01
1.55
2.33
4.24

Laptop

Iteration [s] % slower

3.58
2.92
2.26
3.50
6.36

48
44
47
52
50

Table 9: Computational time for selected results from the paper using both a workstation and a laptop with
speciﬁcations given in the text. Total time is given in minutes and the average time per design iteration is given in
second. The values correspond to the following results: double pipe = Figure 15a; pipe bend = Figure 18; rugby
ball = Figure 20a; ﬂow reversal = Figure 24a; maximum lift = Figure 27b.

ance (increasing the number) gives a less accurate solu-
tion to the non-linear system of equations in Equation
16. This means that errors will be introduced into the
adjoint sensitivity analysis due to a non-zero residual.
However, as detailed by Amir et al. (2010, 2014) for
linear solvers, solver tolerances can be loosened signiﬁ-
cantly without impacting accuracy signiﬁcantly.

The transposed Jacobian is necessary for solving the
adjoint problem and by default it is built using the ﬁ-
nal converged (to the desired accuracy) state solution.

This ensures an accurate (to solution accuracy) evalua-
tion of the adjoint variables and, thus, the sensitivities.
However, if the non-linear tolerance is tight (a low num-
ber), the state ﬁeld will not have changed signiﬁcantly
from the second-to-last non-linear iteration to the last
one. Therefore, the Jacobian already built for the last
non-linear iteration can be used for solving the adjoint
problem and this saves the time of assemblying the Ja-
cobian a single time per design iteration.

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

27

Standard

Re-use Jacobian

Loose tolerance

Both modiﬁcations

Problem
Double pipe
Flow reversal
Maximum lift

Obj.
2.126
2.264
3.188

Obj.
Iter.
2.129
102
102
2.257
100m 3.232

Iter.
100
105
100m

Time [%] Obj.
2.129
2.232
3.243

89.7
88.7
91.2

Iter.
100
89
100m

Time [%] Obj.
2.130
2.260
3.330

65.4
67.4
68.6

Iter.
99
83
100m

Time [%]
55.9
63.7
58.3

Table 10: Final objective value, number of design iterations, and average computational time per design iteration
for selected results from the paper using a laptop with re-use of Jacobian from non-linear solver for the adjoint
solver and/or loose tolerance of non-linear solver. All objective values are evaluated with the default tolerance of
nltol = 1e-6. For the double pipe, the objective values should be multiplied by 10−1. All runs for maximum lift
maxed out at 100 iterations (100m).

Table 10 shows the computational time for three
examples using the two computational time reduction
methods on the laptop. It can be seen that re-using the
Jacobian can reduce the computational time per design
iteration, but only by 8-11%. Loosening the tolerance to
nltol = 1e-2, compared to the default value of nltol
= 1e-6, reduces the computational cost more signiﬁ-
cantly more by 31-35%. Generally, the looser tolerance
reduces the number of non-linear iterations by 1 or 2
per design iteration, depending on the non-linearity of
the ﬂow problem. Lastly, combining the two modiﬁca-
tions together yields a total reduction of 36-44%. The
reduction in computational time does come at a cost
of accuracy, which is reﬂected in the diﬀerent number
of design iterations and diﬀerent ﬁnal values of the ob-
jective functionals. Despite the diﬀerences in objective
values, visually-identical optimised designs are obtained
for all cases. However, this may not be a general con-
clusion and it will depend on the physical problem and
optimisation problem to be solved.

10.2 Memory use

The memory use of the code is of interest, because the
local ﬁnite element matrices are formed all-at-once us-
ing the vectorised functionality of the auto-generated
functions from the Symbolic Toolbox. Ideally, this means
that the computer should be able to store all local ﬁnite
element matrices in memory all at once - in addition to
the factorisation of the Jacobian matrix for the solution
of the systems of equations.

Table 9 also shows the amount of peak RAM mem-
ory used for the 5 examples, when run on the worksta-
tion (similar values were observed on the laptop). This
is in addition to the approximately 1.2GB that MAT-
LAB used in idle after startup. The laptop was able
to handle a mesh of 90 thousand elements (300 × 300)
without exceeding the 8GB of RAM and avoiding to
resort to swap storage. A design iteration for the pipe
bend problem took around 30 seconds for 5 Newton it-
erations. The workstation could easily handle a mesh

of 1 million elements (1000 × 1000), peaking at 50GB
of RAM memory use and solving one design iteration
in around 400 seconds (6.7 minutes).

By default, the topFlow.m script starts with the
clear command. This ensures that any cached func-
tions are not cleared and should speed up running of
the code, after the ﬁrst initial run. However, memory
use can build up and if time is not an issue, the com-
mand can be updated to clear all. This clears the
memory everytime the script is run. Beware that in
this case, the initial design iterations will be slower,
because MATLAB realises many of the functions are
being called repeatedly.

11 Concluding remarks

This article presents a detailed introduction to density-
based topology optimisation of ﬂuid ﬂow problems. The
goal is to be the ﬁrst point of contact for new students
and researchers, allowing them to quickly get started
in the research area and to skip many of the initial
steps, often consuming unnecessarily long time from the
scientiﬁc advancement of the ﬁeld.

A step-by-step guide is provided to the components
necessary to understand and implement topology opti-
misation for ﬂuid ﬂow. The continuous design represen-
tation and Brinkman penalty approach are examined
in detail using parametric simulations of a reference
geometry, as well as through optimisation examples.
Under the way, several recommendations are given to
the choice of minimum, maximum and initial Brinkman
penalty value.

The guide is aided by a MATLAB code based on
the well-known “88-line” code for static mechanics, but
with signiﬁcant modiﬁcations to treat Navier-Stokes ﬂow.
The code uses vectorised functions for building all element-
level matrices and vectors, which have been generated
using the MATLAB Symbolic Toolbox. All partial deriva-
tives necessary for both the Newton solver and adjoint
sensitivity analysis are automatically computed using
symbolic diﬀerentiation.

28

Joe Alexandersen

The extendability of the code is demonstrated through

various additional modiﬁcations and explanations. The
code is shown to be eﬃcient, but the computational
time is signiﬁcantly higher than that for static mechan-
ics, due to the signiﬁcantly more complex ﬁnite element
formulation and the non-linear nature of the governing
equations.

Acknowledgements The author would like to acknowledge
Yupeng Sun, for providing feedback on a close-to-ﬁnished
manuscript, and Christian Lundgaard, for providing feedback
on a very early draft. The author also wishes to thank the
DTU TopOpt group for discussions over the many years it
has taken to form the experienced embodied in this article.

Conﬂict of interest

The author has no conﬂict of interest.

Reproduction of results

The code to reproduce all results is either directly pro-
vided or the required modiﬁcations are explained thor-
oughly. Upon proof-of-attempt, the code for the exam-
ples not provided can be obtained from the author.
Lastly, manual derivations of the analytical sensitivi-
ties can be provided upon request.

References

Aage N, Andreassen E, Lazarov BS (2015) Topol-
ogy optimization using PETSc: An easy-to-use, fully
parallel, open source topology optimization frame-
work. Structural and Multidisciplinary Optimization
51(3):565–572, DOI 10.1007/s00158-014-1157-0

Alexandersen J (2022) Code base on GitHub,. GitHub

URL Link will be added upon publication.

Alexandersen J, Andreasen CS (2020) A review of
topology optimisation for ﬂuid-based problems. Flu-
ids 5(1), DOI 10.3390/ﬂuids5010029

Amir O, Stolpe M, Sigmund O (2010) Eﬃcient use
of
iterative solvers in nested topology optimiza-
tion. Structural and Multidisciplinary Optimization
42(1):55–72, DOI 10.1007/s00158-009-0463-4

Amir O, Aage N, Lazarov BS (2014) On multigrid-CG
for eﬃcient topology optimization. Structural and
Multidisciplinary Optimization 49(5):815–829, DOI
10.1007/s00158-013-1015-5

Andreassen E, Clausen A, Schevenels M, Lazarov
BS, Sigmund O (2011) Eﬃcient topology optimiza-
tion in MATLAB using 88 lines of code. Structural
and Multidisciplinary Optimization 43(1):1–16, DOI
10.1007/s00158-010-0594-7

Bendsøe MP, Kikuchi N (1988) Generating optimal
topologies in structural design using a homoge-
nization method. Computer Methods in Applied
Mechanics and Engineering 71(2):197–224, DOI
https://doi.org/10.1016/0045-7825(88)90086-2

Bendsøe MP, Sigmund O (2004) Topology Optimiza-
tion: Theory, Methods, and Applications, 2nd edn.
Springer-Verlag Berlin Heidelberg, DOI 10.1007/978-
3-662-05086-6

Borrvall T, Petersson J (2003) Topology optimization
of ﬂuids in Stokes ﬂow. International Journal for
Numerical Methods in Fluids 41(1):77–107, DOI
10.1002/ﬂd.426

Challis VJ (2010) A discrete level-set topology op-
timization code written in Matlab. Structural and
Multidisciplinary Optimization 41(3):453–464, DOI
10.1007/s00158-009-0430-0

Choi KK, Kim NH (2005a) Structural Sensitivity Anal-
ysis and Optimization 1. Mechanical Engineering Se-
ries, Springer, DOI 10.1007/b138709

Choi KK, Kim NH (2005b) Structural Sensitivity Anal-
ysis and Optimization 2. Mechanical Engineering Se-
ries, Springer, DOI 10.1007/b138895

Deaton JD, Grandhi RV (2014) A survey of struc-
tural and multidisciplinary continuum topology opti-
mization: post 2000. Structural and Multidisciplinary
Optimization 49(1):1–38, DOI 10.1007/s00158-013-
0956-z

Ferrari F, Sigmund O (2020) A new generation 99
line Matlab code for compliance topology optimiza-
tion and its extension to 3D. Structural and Mul-
tidisciplinary Optimization 62(4):2211–2228, DOI
10.1007/s00158-020-02629-w

Gersborg-Hansen A, Sigmund O, Haber RB (2005)
Topology optimization of
channel ﬂow prob-
lems. Structural and Multidisciplinary Optimization
30(3):181–192, DOI 10.1007/s00158-004-0508-7

Høghøj LC, Nørhave DR, Alexandersen J, Sig-
mund O, Andreasen CS (2020) Topology optimiza-
tion of two ﬂuid heat exchangers. International
Journal of Heat and Mass Transfer 163, DOI
10.1016/j.ijheatmasstransfer.2020.120543

Kondoh T, Matsumori T, Kawamoto A (2012) Drag
minimization and lift maximization in laminar ﬂows
via topology optimization employing simple objec-
tive function expressions based on body force integra-
tion. Structural and Multidisciplinary Optimization
45(5):693–701, DOI 10.1007/s00158-011-0730-z

Le C, Norato J, Bruns T, Ha C, Tortorelli D
(2010) Stress-based topology optimization for con-
tinua. Structural and Multidisciplinary Optimization
41(4):605–620, DOI 10.1007/s00158-009-0440-y

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

29

Lundgaard C, Alexandersen J, Zhou M, Andreasen CS,
Sigmund O (2018) Revisiting density-based topol-
ogy optimization for ﬂuid-structure-interaction prob-
lems. Structural and Multidisciplinary Optimization
58(3):969–995, DOI 10.1007/s00158-018-1940-4

Michaleris P, Tortorelli DA, Vidal CA (1994) Tan-
gent operators and design sensitivity formulations for
transient non-linear coupled problems with applica-
tions to elastoplasticity. International Journal for Nu-
merical Methods in Engineering 37(14):2471–2499,
DOI https://doi.org/10.1002/nme.1620371408

Papadopoulos IPA, Farrell PE, Surowiec TM (2021)
Computing multiple solutions of topology optimiza-
tion problems. SIAM Journal on Scientiﬁc Comput-
ing 43(3):A1555–A1582, DOI 10.1137/20m1326209
Pereira A, Talischi C, Paulino GH, M Menezes IF, Car-
valho MS (2016) Fluid ﬂow topology optimization
in PolyTop: stability and computational implementa-
tion. Structural and Multidisciplinary Optimization
54(5):1345–1364, DOI 10.1007/s00158-014-1182-z
Pironneau O (1973) On optimum proﬁles in Stokes
ﬂow. Journal of Fluid Mechanics 59(1):117–128, DOI
10.1017/S002211207300145X

Sigmund O (2001) A 99 line topology optimiza-
tion code written in matlab. Structural and Mul-
tidisciplinary Optimization 21(2):120–127, DOI
10.1007/s001580050176

Sigmund O (2007) Morphology-based black and white
ﬁlters for topology optimization. Structural and
Multidisciplinary Optimization 33(4):401–424, DOI
10.1007/s00158-006-0087-x

Sigmund O, Maute K (2013) Topology optimization ap-
proaches. Structural and Multidisciplinary Optimiza-
tion 48(6):1031–1055, DOI 10.1007/s00158-013-0978-
6

da Silva GA, Beck AT, Sigmund O (2019) Stress-
constrained topology optimization considering uni-
form manufacturing uncertainties. Computer Meth-
ods in Applied Mechanics and Engineering 344:512–
537, DOI https://doi.org/10.1016/j.cma.2018.10.020
op-
URL

Svanberg matematisk

SMOPTIT
timering
http://www.smoptit.se/

(2022)
och

SMOPTIT

AB,.

IT

Stolpe M, Svanberg K (2001) An alternative interpola-
tion scheme for minimum compliance topology opti-
mization. Structural and Multidisciplinary Optimiza-
tion 22(2):116–124, DOI 10.1007/s001580100129
Svanberg K (1987) The method of moving asymp-
opti-
for Numerical

totes
mization.
Methods
https://doi.org/10.1002/nme.1620240207

Journal
International
in Engineering 24(2):359–373, DOI

a new method for

structural

-

Svanberg K (2007) MMA and GCMMA – two meth-
ods for nonlinear optimization. Report, KTH, URL
https://people.kth.se/˜krille/mmagcmma.pdf

Talischi C, Paulino GH, Pereira A, Menezes IFM
(2012) PolyTop: a Matlab implementation of a gen-
eral topology optimization framework using unstruc-
tured polygonal ﬁnite element meshes. Structural and
Multidisciplinary Optimization 45(3):329–357, DOI
10.1007/s00158-011-0696-x

Wang C, Zhao Z, Zhou M, Sigmund O, Zhang XS
(2021) A comprehensive review of educational ar-
ticles on structural and multidisciplinary optimiza-
tion. Structural and Multidisciplinary Optimization
64(5):2827–2880, DOI 10.1007/s00158-021-03050-7
Wei P, Li Z, Li X, Wang MY (2018) An 88-line MAT-
LAB code for the parameterized level set method
based topology optimization using radial basis func-
tions. Structural and Multidisciplinary Optimization
58(2):831–849, DOI 10.1007/s00158-018-1904-8

Xia L, Breitkopf P (2015) Design of materials us-
ing topology optimization and energy-based homog-
enization approach in Matlab. Structural and Mul-
tidisciplinary Optimization 52(6):1229–1241, DOI
10.1007/s00158-015-1294-0

Zegard T, Paulino GH (2014) GRAND — Ground
structure based topology optimization for arbi-
trary 2d domains using MATLAB. Structural and
Multidisciplinary Optimization 50(5):861–882, DOI
10.1007/s00158-014-1085-z

A Alternative scaling of Brinkman penalty
factor

The order of magnitude of the convective term is constant
due to the non-dimensional formulation of Equation 2. Thus,
the Brinkman penalty factor should no longer become smaller
with increasing Reynolds number. Kondoh et al. (2012) sug-
gested the following scaling:

αmax =

(cid:18)

1 +

1
Re

(cid:19) 1
Da

(44)

which aims to ensure that the Brinkman penalty factor is
large enough even for increasing Reynolds numbers. From a
scaling point of view, it can be argued that 1
Da makes sense
for purely convective ﬂow, which is recovered from the above
for Re −→ ∞.

Figure 28 shows the error measures as a function of Reynolds

number when using Equation 44. In practise, it is seen that
the error decreases for increasing Reynolds number over 1,
meaning the ﬂow in the solid is penalised increasingly hard.
It appears that the error is beginning to stagnate. However,
the ﬂow becomes non-steady for Re > 150 and, thus, the limit
cannot be investigated presently. This is an area worth more
investigation, as the community transitions to treating larger
Reynolds number ﬂows.

30

Joe Alexandersen

based on three limit cases:

τ1 =

τ3 =

τ4 =

h
uiui

√

2
ρh2
12µ
ρ
α

(48a)

(48b)

(48c)

where τ1 is the convective limit, τ3 is the diﬀusive limit, and
τ4 is the reactive limit4. The reactive limit τ4 is very impor-
tant to ensure stability in the solid domain and at the inter-
face, especially for large Brinkman penalty parameters. The
stabilisation parameters are assumed to be constant within
each element and τ1 is, thus, computed based on the velocity
components evaluated in the element centroid.

C Adjoint sensitivity analysis

Adjoint sensitivity analysis need not be diﬃcult or especially
derived for every type of problem. The derivation is very sim-
ply by posing the system of equations (be they uncoupled,
weakly coupled or strongly coupled) as a common residual:

r = A s − b = 0

(49)

where A is the system coeﬃcient matrix, s is the vector of
all state variables and b is the forcing vector. To ﬁnd the
derivatives of a given functional f , the Lagrangian L is deﬁned
as:

L = f − λT r

(50)

where λ is the vector of adjoint variables. The total deriva-
tive with respect to a design variable γe is then taken of the
Lagrangian:

dL
dγe

=

df
dγe

− λT dr
dγe

where the total derivative is given by:

df
dγe

=

∂f
∂γe

+

∂f
∂s

∂s
∂γe

(51)

(52)

Fig. 28: Error measures, when penalising using Equa-
tion 44, as a function of Reynolds number
for
a Darcy number of Da = 10−6 and Re ∈
{0.01, 0.1, 1, 5, 10, 50, 100, 150}.

B Finite element formulation

The weak form of the momentum conservation equations is
derived by multiplying the strong form by the test function
wi for the velocity ﬁeld, integrating over the volume, apply-
ing integration-by-parts and introducing a zero normal stress
natural boundary condition:

(cid:90)

ρwiuj

Ω
(cid:90)

−

Ω

ne(cid:88)

+

∂wi
∂xi
(cid:90)

e=1

Ωe

∂ui
∂xj

dV +

(cid:32)

(cid:90)

Ω

µ

∂wi
∂xj

∂ui
∂xj

+

∂uj
∂xi

(cid:33)

dV

(cid:90)

p dV +

αwiui dV

Ω
∂ui
∂xk

(cid:32)

ρuj

τ wk

∂ui
∂xj

+

∂p
∂xi

(cid:33)

+ αui

dV = 0

(45)

where the last integral is the additional SUPG stabilisation
terms with τ as the stabilisation parameter. Likewise, the
weak form of the mass conservation equation is derived by
multiplying the strong form with the test function q for the
pressure ﬁeld:

(cid:90)

Ω

q

∂ui
∂xi

dV

ne(cid:88)

(cid:90)

+

e=1

Ωe

τ
ρ

∂q
∂xi

(cid:32)

uj

∂ui
∂xj

+

∂p
∂xi

(cid:33)

+ αui

dV = 0

(46)

where the last integral is the additional PSPG stabilisation
terms with τ as the stabilisation parameter. The diﬀusive
term has been left out of the SUPG and PSPG stabilisation,
since it is negligible for bi-linear interpolation functions due
to the second-order derivative.

The stabilisation parameter is computed using an approx-

imate minimum function:

τ =

(cid:16)

τ1

−2 + τ3

−2 + τ4

−2(cid:17)−1/2

(47)

due to the implicit dependence of f on the state ﬁeld. Ex-
panding the total derivative of the Lagrangian gives:

dL
dγe

=

∂f
∂γe

+

∂f
∂s

∂s
∂γe

− λT

(cid:18) ∂r
∂γe

+

∂r
∂s

∂s
∂γe

(cid:19)

which can be rewritten to:

dL
dγe

=

∂f
∂γe

− λT ∂r
∂γe

+

(cid:18) ∂f
∂s

− λT ∂r
∂s

(cid:19) ∂s
∂γe

(53)

(54)

by collecting the terms multiplied by the derivative of the
state ﬁeld. The adjoint problem is then deﬁned as what is
inside the brackets:

T

∂r
∂s

λ =

T

∂f
∂s

(55)

4 τ2 is for the transient case, which is traditionally num-
bered as number 2, and left out since steady-state ﬂow is
treated herein.

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

31

When λ is the solution to the adjoint problem, the terms
inside the brackets become zero and it is avoided to compute
the design sensitivities of the state ﬁeld:

dL
dγe

=

∂f
∂γe

− λT ∂r
∂γe

(56)

Since the state solution will be updated after a design change
to make the residual equal to zero, the total derivative of the
residual with respect to the design variable is equal to zero.
Thus, the total derivative of the Lagrangian will be equal to
that of the functional and Equation 51 gives:

dL
dγe

=

df
dγe

(57)

Thus, the ﬁnal sensitivities of the given functional become:

df
dγe

=

∂f
∂γe

− λT ∂r
∂γe

(58)

The above result is valid for ALL systems of equations, be
they linear/non-linear or un/weakly/strongly coupled. This
is the methodology laid forth in various textbooks, e.g. the
“Structural Sensitivity Analysis and Optimization” series by
Choi and Kim (2005a,b), and papers from the 1990s Micha-
leris et al. (1994).

32

D MATLAB code: topFlow.m

Joe Alexandersen

NAVIER−STOKES TOPOLOGY OPTIMISATION CODE, MAY 2022

1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
2 %
3 % COPYRIGHT (c) 2022, J ALEXANDERSEN. BSD 3−CLAUSE LICENSE %
4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5 clear; close all; clc;
6 %% DEFINITION OF INPUT PARAMETERS
7 % PROBLEM TO SOLVE (1 = DOUBLE PIPE; 2 = PIPE BEND)
8 probtype = 1;
9 % DOMAIN SIZE
10 Lx = 1.0; Ly = 1.0;
11 % DOMAIN DISCRETISATION
12 nely = 30; nelx = nely*Lx/Ly;
13 % ALLOWABLE FLUID VOLUME FRACTION
14 volfrac = 1/3; xinit = volfrac;
15 % PHYSICAL PARAMETERS
16 Uin = 1e0; rho = 1e0; mu = 1e0;
17 % BRINKMAN PENALISATION
18 alphamax = 2.5*mu/(0.01ˆ2); alphamin = 2.5*mu/(100ˆ2);
19 % CONTINUATION STRATEGY
20 ainit = 2.5*mu/(0.1ˆ2);
21 qinit = (−xinit*(alphamax−alphamin) − ainit + alphamax)/(xinit*(ainit−alphamin));
22 qavec = qinit./[1 2 10 20]; qanum = length(qavec); conit = 50;
23 % OPTIMISATION PARAMETERS
24 maxiter = qanum*conit; mvlim = 0.2; plotdes = 0;
25 chlim = 1e−3; chnum = 5;
26 % NEWTON SOLVER PARAMETERS
27 nltol = 1e−6; nlmax = 25; plotres = 0;
28 % EXPORT FILE
29 filename='output'; exportdxf = 0;
30 %% PREPARE FINITE ELEMENT ANALYSIS
31 dx = Lx/nelx; dy = Ly/nely;
32 nodx = nelx+1; nody = nely+1; nodtot = nodx*nody;
33 neltot = nelx*nely; doftot = 3*nodtot;
34 % NODAL CONNECTIVITY
35 nodenrs = reshape(1:nodtot,nody,nodx);
36 edofVecU = reshape(2*nodenrs(1:end−1,1:end−1)+1,neltot,1);
37 edofMatU = repmat(edofVecU,1,8)+repmat([0 1 2*nely+[2 3 0 1] −2 −1],neltot,1);
38 edofVecP = reshape(nodenrs(1:end−1,1:end−1),neltot,1);
39 edofMatP = repmat(edofVecP,1,4)+repmat([1 nely+[2 1] 0],neltot,1);
40 edofMat = [edofMatU 2*nodtot+edofMatP];
41 iJ = reshape(kron(edofMat,ones(12,1))',144*neltot,1);
42 jJ = reshape(kron(edofMat,ones(1,12))',144*neltot,1);
43 iR = reshape(edofMat',12*neltot,1); jR = ones(12*neltot,1);
44 jE = repmat(1:neltot,12,1);
45 %% DEFINE BOUNDARY CONDITIONS
46 % DEFINE THE PROBLEMS IN SEPARATE MATLAB FILE
47 run('problems.m');
48 % NULLSPACE MATRICES FOR IMPOSING BOUNDARY CONDITIONS
49 EN=speye(doftot); ND=EN; ND(fixedDofs,fixedDofs)=0.0; EN=EN−ND;
50 % VECTORS FOR FREE DOFS
51 alldofs = 1:doftot; freedofs = setdiff(alldofs,fixedDofs);
52 %% INITIALISATION
53 % SOLUTION VECTOR
54 S = zeros(doftot,1); dS = S; L = S;
55 S(fixedDofs) = DIR(fixedDofs);
56 % DESIGN FIELD
57 xPhys = xinit*ones(nely,nelx);
58 % COUNTERS
59 loop = 0; loopcont = 0; nlittot = 0; chcnt = 0;
60 % CHANGE
61 change = Inf; objOld = Inf;
62 % CONTINUATION
63 qastep = 1; qa = qavec(1);
64 % VECTORISED CONSTANTS
65 dxv = dx*ones(1,neltot); dyv = dy*ones(1,neltot);
66 muv = mu*ones(1,neltot); rhov = rho*ones(1,neltot);
67 %% OUTPUT PROBLEM INFORMATION
68 fprintf('=========================================================\n');
69 fprintf('

Problem number: %2i − Reynolds number: %3.2e\n',probtype,Renum);

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

33

70 fprintf('=========================================================\n');
71 fprintf('
72 %% START ITERATION
73 destime = tic; ittime = tic;
74 while (loop ≤ maxiter)

Design it.:

0\n');

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

if (plotdes); figure(1); imagesc(xPhys); colorbar; caxis([0 1]); axis equal; axis off; ...

drawnow; end

%% GREYSCALE INDICATOR
Md = 100*full(4*sum(xPhys(:).*(1−xPhys(:)))/neltot);
%% MATERIAL INTERPOLATION
alpha = alphamin + (alphamax−alphamin)*(1−xPhys(:))./(1+qa*xPhys(:));
dalpha = (qa*(alphamax − alphamin)*(xPhys(:) − 1))./(xPhys(:)*qa + 1).ˆ2 − (alphamax − ...

alphamin)./(xPhys(:)*qa + 1);

%% NON−LINEAR NEWTON SOLVER
normR = 1; nlit = 0; fail = −1; nltime = tic;
while (fail (cid:54)= 1)

nlit = nlit+1; nlittot = nlittot+1;
% BUILD RESIDUAL AND JACOBIAN
sR = RES(dxv,dyv,muv,rhov,alpha(:)',S(edofMat'));
R = sparse(iR,jR,sR(:)); R(fixedDofs) = 0;
if (nlit == 1); r0 = norm(R); end
r1 = norm(R); normR = r1/r0;
if (plotres); figure(6); semilogy(nlittot,normR,'x'); axis square; grid on; hold on; end
if (normR < nltol); break; end
sJ = JAC(dxv,dyv,muv,rhov,alpha(:)',S(edofMat'));
J = sparse(iJ,jJ,sJ(:)); J = (ND'*J*ND+EN);
% CALCULATE NEWTON STEP
dS = −J\R;
% L2−NORM LINE SEARCH
Sp = S + 0.5*dS;
sR = RES(dxv,dyv,muv,rhov,alpha(:)',Sp(edofMat'));
R = sparse(iR,jR,sR(:)); R(fixedDofs) = 0; r2 = norm(R);
Sp = S + 1.0*dS;
sR = RES(dxv,dyv,muv,rhov,alpha(:)',Sp(edofMat'));
R = sparse(iR,jR,sR(:)); R(fixedDofs) = 0; r3 = norm(R);
% SOLUTION UPDATE WITH "OPTIMAL" DAMPING
lambda = max(0.01,min(1.0,(3*r1 + r3 − 4*r2)/(4*r1 + 4*r3 − 8*r2)));
S = S + lambda*dS;
% IF FAIL, RETRY FROM ZERO SOLUTION
if (nlit == nlmax && fail < 0); nlit = 0; S(freedofs) = 0.0; normR=1; fail = fail+1; end
if (nlit == nlmax && fail < 1); fail = fail+1; end

end
nltime=toc(nltime);
fprintf('
if (fail == 1); error('ERROR: Solver did not converge after retry from zero!\n

Newton it.: %2i − Res. norm: %3.2e − Sol. time: %6.3f sec\n',nlit,normR,nltime);

Stopping ...

optimisation.\n'); end

Obj.: %3.2e − Constr.: %3.2e − Md: %3.2f\n',obj,V,Md);
Change: %4.3e − It. time: %6.3f sec\n',change,ittime);
Contin. step: %2i − qa: %4.3e\n',qastep,qa);

%% OBJECTIVE EVALUATION
obj = sum( PHI(dxv,dyv,muv,alpha(:)',S(edofMat')) );
change = abs(objOld−obj)/objOld; objOld = obj;
%% VOLUME CONSTRAINT
V = mean(xPhys(:));
%% PRINT RESULTS
ittime = toc(ittime);
fprintf('
fprintf('
fprintf('
ittime = tic;
%% EVALUATE CURRENT ITERATE − CONTINUE UNLESS CONSIDERED CONVERGED
if (change < chlim); chcnt = chcnt + 1; else; chcnt = 0; end
if (qastep == qanum && ( (chcnt == chnum) | | (loopcont == conit) ) ); break; end
%% PRINT HEADER FOR ITERATION
loop = loop + 1; loopcont = loopcont + 1;
fprintf('−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n');
fprintf('
%% ADJOINT SOLVER
sR = [dPHIds(dxv,dyv,muv,alpha(:)',S(edofMat')); zeros(4,neltot)];
RHS = sparse(iR,jR,sR(:)); RHS(fixedDofs) = 0;
sJ = JAC(dxv,dyv,muv,rhov,alpha(:)',S(edofMat'));
J = sparse(iJ,jJ,sJ(:)); J = (ND'*J*ND+EN);
L = J'\RHS;
%% COMPUTE SENSITIVITIES

Design it.:%4i\n',loop);

34

Joe Alexandersen

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

% OBJECTIVE
sR = dRESdg(dxv,dyv,muv,rhov,alpha(:)',dalpha(:)',S(edofMat'));
dRdg = sparse(iR(:),jE(:),sR(:));
dphidg = dPHIdg(dxv,dyv,muv,alpha(:)',dalpha(:)',S(edofMat'));
sens = reshape(dphidg − L'*dRdg,nely,nelx);
% VOLUME CONSTRAINT
dV = ones(nely,nelx)/neltot;
%% OPTIMALITY CRITERIA UPDATE OF DESIGN VARIABLES AND PHYSICAL DENSITIES
xnew = xPhys; xlow = xPhys(:)−mvlim; xupp = xPhys(:)+mvlim;
ocfac = xPhys(:).*max(1e−10,(−sens(:)./dV(:))).ˆ(1/3);
l1 = 0; l2 = ( 1/(neltot*volfrac)*sum( ocfac ) )ˆ3;
while (l2−l1)/(l1+l2) > 1e−3
lmid = 0.5*(l2+l1);
xnew(:) = max(0,max(xlow,min(1,min(xupp,ocfac/(lmidˆ(1/3))))));
if mean(xnew(:)) > volfrac; l1 = lmid; else; l2 = lmid; end

end
xPhys = xnew;
%% CONTINUATION UPDATE
if (qastep < qanum && (loopcont == conit | | chcnt == chnum) )

loopcont = 0; chcnt = 0;
qastep = qastep + 1; qa = qavec(qastep);

end

Electrical Engineering

Department of Mechanical and

Number of design iterations: %4i\n',loop);
Final objective: %4.3e\n',obj);
Total time taken: %6.2f min\n',destime/60);

159
160 end
161 %% PRINT FINAL INFORMATION
162 destime = toc(destime);
163 fprintf('=========================================================\n');
164 fprintf('
165 fprintf('
166 fprintf('
167 fprintf('=========================================================\n');
168 %% PLOT RESULTS
169 run('postproc.m');
170 if (exportdxf); run('export.m'); end
171 %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
172 % This code was written by: Joe Alexandersen
%
173 %
%
174 %
%
175 %
%
176 %
%
177 % Please send your comments and questions to: joal@sdu.dk
%
178 %
%
179 % The code is intended for educational purposes and theoretical details
%
180 % are discussed in the paper: "A detailed introduction to density−based
%
181 % topology optimisation of fluid flow problems including implementation
%
182 % in MATLAB", J. Alexandersen, SMO 2022, doi:
%
183 %
%
184 % A preprint version of the paper can be downloaded from the author's
%
185 % website: joealexandersen.com
%
186 % The code is available from GitHub: github.com/sdu−multiphysics/topflow
%
187 %
%
188 % The basic structure of the code is based on the 88−line code for
%
189 % elastic compliance from: "Efficient topology optimization in MATLAB
%
190 % using 88 lines of code", E. Andreassen, A. Clausen, M. Schevenels,
%
191 % B. S. Lazarov and O. Sigmund, SMO 2010, doi:10.1007/s00158−010−0594−7
%
192 %
%
193 % Disclaimer:
%
194 % The author does not guarantee that the code is free from errors.
%
195 % Furthermore, the author shall not be liable in any event caused by the
%
196 % use of the program.
197 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

University of Southern Denmark
DK−5230 Odense M, Denmark.

E MATLAB code: problems.m

NAVIER−STOKES TOPOLOGY OPTIMISATION CODE, MAY 2022

1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2 %
%
3 % COPYRIGHT (c) 2022, J ALEXANDERSEN. BSD 3−CLAUSE LICENSE %
4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5 %% DEFINE THE PROBLEMS TO BE SOLVED
6 if (probtype == 1) % DOUBLE PIPE PROBLEM

%%%%

7

8

if ( mod(nely,6) > 0 > 0 )

error('ERROR: Number of elements in y−dir. must be divisable by 6.');

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

35

elseif ( nely < 30 )

error('ERROR: Number of elements in y−dir. must be above 30.');

= [inlet1:(inlet1+inletLength)' inlet2:(inlet2+inletLength)'];

end
inletLength = 1/6*nely; inlet1 = 1/6*nely+1; inlet2 = 4/6*nely+1;
outletLength = 1/6*nely; outlet1 = 1/6*nely+1; outlet2 = 4/6*nely+1;
nodesInlet
nodesOutlet = (nodx−1)*nody+[outlet1:(outlet1+outletLength)' outlet2:(outlet2+outletLength)'];
nodesTopBot = [1:nely+1:nodtot nody:nody:nodtot];
nodesLefRig = [2:nely (nelx)*nody+2:nodtot−1];
fixedDofsTBx = 2*nodesTopBot−1; fixedDofsTBy = 2*nodesTopBot;
fixedDofsLRx = 2*setdiff(nodesLefRig,[nodesInlet nodesOutlet])−1;
fixedDofsLRy = 2*nodesLefRig;
fixedDofsInX
fixedDofsOutY = 2*nodesOutlet; fixedDofsOutP = 2*nodtot+nodesOutlet;
fixedDofsU = [fixedDofsTBx fixedDofsTBy fixedDofsLRx fixedDofsLRy ...
fixedDofsInX fixedDofsInY fixedDofsOutY];

= 2*nodesInlet−1; fixedDofsInY

= 2*nodesInlet;

= [fixedDofsU fixedDofsP];

fixedDofsP = [fixedDofsOutP];
fixedDofs
% DIRICHLET VECTORS
u = @(y) −4*y.ˆ2+4*y; Uinlet = Uin*u([0:inletLength]'/inletLength);
DIRU=zeros(nodtot*2,1); DIRU(fixedDofsInX) = [Uinlet' Uinlet'];
DIRP=zeros(nodtot,1); DIR = [DIRU; DIRP];
% INLET REYNOLDS NUMBER
Renum = Uin*(inletLength*Ly/nely)*rho/mu;

32
33 elseif (probtype == 2) % PIPE BEND PROBLEM

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56
57 end

if ( mod(nelx,10) > 0 | | mod(nely,10) > 0 )

error('ERROR: Number of elements per side must be divisable by 10.');

= [inlet1:(inlet1+inletLength)];

end
inletLength = 2/10*nely; inlet1 = 1/10*nely+1;
outletLength = 2/10*nelx; outlet1 = 7/10*nelx+1;
nodesInlet
nodesOutlet = nody*[outlet1:(outlet1+outletLength)];
nodesTopBot = [1:nely+1:nodtot nody:nody:nodtot];
nodesLefRig = [2:nely (nodx−1)*nody+2:nodtot−1];
fixedDofsTBx = 2*nodesTopBot−1; fixedDofsTBy = 2*setdiff(nodesTopBot,nodesOutlet);
fixedDofsLRx = 2*setdiff(nodesLefRig,nodesInlet)−1; fixedDofsLRy = 2*nodesLefRig;
fixedDofsInX
fixedDofsOutX = 2*nodesOutlet−1; fixedDofsOutP = 2*nodtot+nodesOutlet;
fixedDofsU = [fixedDofsTBx fixedDofsTBy fixedDofsLRx fixedDofsLRy ...
fixedDofsInX fixedDofsInY fixedDofsOutX];

= 2*nodesInlet−1; fixedDofsInY

= 2*nodesInlet;

= [fixedDofsU fixedDofsP];

fixedDofsP = [fixedDofsOutP];
fixedDofs
% DIRICHLET VECTORS
DIRU=zeros(nodtot*2,1); DIRP=zeros(nodtot,1);
u = @(y) −4*y.ˆ2+4*y; Uinlet = Uin*u([0:inletLength]'/inletLength);
DIRU(fixedDofsInX) = Uinlet'; DIR = [DIRU; DIRP];
% INLET REYNOLDS NUMBER
Renum = Uin*(inletLength*Ly/nely)*rho/mu;

F MATLAB code: postproc.m

NAVIER−STOKES TOPOLOGY OPTIMISATION CODE, MAY 2022

1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2 %
%
3 % COPYRIGHT (c) 2022, J ALEXANDERSEN. BSD 3−CLAUSE LICENSE %
4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5 %% POST−PROCESSING
6 % SETTING UP NODAL COORDINATES FOR STREAMLINES
7 [X,Y] = meshgrid(0.5:nodx,0.5:nody); sx = 0.5*ones(1,21); sy = linspace(0,nody,21);
8 U = S(1:(nely+1)*(nelx+1)*2); umag=reshape(sqrt(U(1:2:end).ˆ2+U(2:2:end).ˆ2),nely+1,nelx+1);
9 % DESIGN FIELD
10 figure(1); imagesc(xPhys); colorbar; caxis([0 1]); axis equal; axis off;
11 h = streamline(X,Y,reshape(U(1:2:end),nody,nodx),−reshape(U(2:2:end),nody,nodx),sx,sy); ...

set(h,'Color','black');

12 % BRINKMAN PENALTY FACTOR
13 figure(2); imagesc(reshape(log10(alpha),nely,nelx)); colorbar; caxis([0 log10(alphamax)]); axis ...

equal; axis off; %colormap turbo;

14 % VELOCITY MAGNITUDE FIELD
15 figure(3); imagesc(umag); colorbar; axis equal; axis on; hold on; %colormap turbo;
16 h = streamline(X,Y,reshape(U(1:2:end),nody,nodx),−reshape(U(2:2:end),nody,nodx),sx,sy); ...

set(h,'Color','black');

36

Joe Alexandersen

17 % PRESSURE FIELD
18 P = S(2*nodtot+1:3*nodtot);
19 figure(4); imagesc(reshape(P,nody,nodx)); colorbar; axis equal; axis off; %colormap turbo;
20 h = streamline(X,Y,reshape(U(1:2:end),nody,nodx),−reshape(U(2:2:end),nody,nodx),sx,sy); ...

set(h,'Color','black');

21 % VELOCITY ALONG A LINE
22 if (probtype == 2)

uline=flipud(diag(fliplr(umag))); xline=flipud(diag(fliplr(xPhys)));

23
24 else

uline=umag(:,floor((end−1)/2)); xline=xPhys(:,floor(end/2));

25
26 end
27 figure(5);
28 subplot(3,1,1); plot(uline,'−x'); grid on;
29 subplot(3,1,2); plot(log10(uline),'−x'); grid on;
30 subplot(3,1,3); plot(xline,'−x'); grid on; drawnow

G MATLAB code: export.m

NAVIER−STOKES TOPOLOGY OPTIMISATION CODE, MAY 2022

1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2 %
%
3 % COPYRIGHT (c) 2022, J ALEXANDERSEN. BSD 3−CLAUSE LICENSE %
4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5 %% DXF
6 xMod = padarray(padarray(xPhys,[1 1],'replicate'),[1 1],1);
7 figure('visible','off');
8 C = contour(flipud(xMod),[0.5 0.5]);
9 C = unique(C','rows','stable')';
10 C = C−2.5; C(1,:) = C(1,:)*dx; C(2,:) = C(2,:)*dy;
11 h = sqrt(dxˆ2+dyˆ2);
12 ind = 1:size(C,2);
13 ind1 = intersect(find(C(1,:)<Lx+2*dx),find(C(2,:)<Ly+2*dy));
14 ind2 = intersect(find(C(1,:)>0−dx),find(C(2,:)>0−dy));
15 ind = intersect(ind1,ind2);
16 X = []; Y = []; c = 0;
17 indused = [];
18 for i = 1:(length(ind))

19

20

21

22

23

24

25

26

27

28

x0 = C(1,ind(i)); y0 = C(2,ind(i));
redind = ind([1:max(1,i−5) i+1:min(length(ind),i+2)]);
redind = setdiff(redind,indused(max(1,c−10):end));
R = sqrt( (C(1,redind)−x0).ˆ2 + (C(2,redind)−y0).ˆ2 );
[minR,idx] = min(R);
if (minR < 2*h && minR > 0)

c = c + 1;
indused(c) = i;
X(c,:) = [x0 C(1,redind(idx))];
Y(c,:) = [y0 C(2,redind(idx))];

end

29
30 end
31 fid=fopen([filename '.dxf'],'w');
32 fprintf(fid,'0\nSECTION\n2\nENTITIES\n0\n');
33 for i=1:size(X,1)

34

35

36

fprintf(fid,'LINE\n8\n0\n');
fprintf(fid,'10\n%.4f\n20\n%.4f\n30\n%.4f\n',X(i,1),Y(i,1),0);
fprintf(fid,'11\n%.4f\n21\n%.4f\n31\n%.4f\n',X(i,2),Y(i,2),0);
fprintf(fid,'0\n');

37
38 end
39 fprintf(fid,'ENDSEC\n0\nEOF\n');
40 fclose(fid);

H MATLAB code: analyticalElement.m

NAVIER−STOKES TOPOLOGY OPTIMISATION CODE, MAY 2022

1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2 %
%
3 % COPYRIGHT (c) 2022, J ALEXANDERSEN. BSD 3−CLAUSE LICENSE %
4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5 clear; close all; clc;
6 %% Switches
7 buildJR = 1; exportJR = 1;
8 buildPhi = 1; exportPhi = 1;
9 %% Initialisation
10 syms rho mu alpha dalpha xi eta dx dy;

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

37

11 syms u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4;
12 time = tic;
13 %% Shape functions and matrices
14 xv = [−1 1 1 −1]'; yv = [−1 −1 1 1]';
15 Np = 1/4*(1+xi*xv').*(1+eta*yv');
16 Nu = sym(zeros(2,8));
17 Nu(1,1:2:end−1) = Np;
18 Nu(2,2:2:end) = Np;
19 %% Nodal coordinates, interpolation and coordinate transforms
20 xc = dx/2*xv; yc = dy/2*yv;
21 x = Np*xc; y = Np*yc;
22 J = [diff(x,xi) diff(y,xi); diff(x,eta) diff(y,eta)];
23 iJ = inv(J); detJ = det(J);
24 %% Derivatives of shape functions
25 dNpdx = iJ(:,1)*diff(Np,xi) + iJ(:,2)*diff(Np,eta);
26 dNudx = sym(zeros(2,8,2));
27 for i = 1:2

dNudx(i,:,:) = transpose(iJ(:,1)*diff(Nu(i,:),xi) + iJ(:,2)*diff(Nu(i,:),eta));

28
29 end
30 %% Nodal DOFs
31 u = [u1; u2; u3; u4; u5; u6; u7; u8];
32 p = [p1; p2; p3; p4]; s = [u; p];
33 ux = Nu*u; px = Np*p;
34 dudx = [dNudx(:,:,1)*u dNudx(:,:,2)*u];
35 dpdx = dNpdx*p;
36 %% Stabilisation parameters
37 h = sqrt(dxˆ2 + dyˆ2);
38 u0 = subs(ux,[xi,eta],[0,0]);
39 ue = sqrt(transpose(u0)*u0);
40 tau1 = h/(2*ue);
41 tau3 = rho*hˆ2/(12*mu);
42 tau4 = rho/alpha;
43 tau = (tau1ˆ(−2) + tau3ˆ(−2) + tau4ˆ(−2))ˆ(−1/2);
44 %% Loop over the tensor weak form to form residual
45 if (buildJR)

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

Ru = sym(zeros(8,1)); Rp = sym(zeros(4,1));
% Momentum equations
for g = 1:8

for i = 1:2

Ru(g) = Ru(g) + alpha*Nu(i,g)*ux(i); % Brinkman term
for j = 1:2

Ru(g) = Ru(g) + mu*dNudx(i,g,j)*( dudx(i,j) + dudx(j,i) ); % Viscous term
Ru(g) = Ru(g) + rho*Nu(i,g)*ux(j)*dudx(i,j); % Convection term
Ru(g) = Ru(g) + tau*ux(j)*dNudx(i,g,j)*alpha*ux(i); % SUPG Brinkman term
for k = 1:2

Ru(g) = Ru(g) + tau*ux(j)*dNudx(i,g,j)*rho*ux(k)*dudx(i,k); % SUPG convection term

end
Ru(g) = Ru(g) + tau*ux(j)*dNudx(i,g,j)*dpdx(i); % SUPG pressure term

end
Ru(g) = Ru(g) − dNudx(i,g,i)*px; % Pressure term

end

end
% Incompressibility equations
for g = 1:4

for i = 1:2

Rp(g) = Rp(g) + Np(1,g)*dudx(i,i); % Divergence term
Rp(g) = Rp(g) + tau/rho*dNpdx(i,g)*alpha*ux(i); % PSPG Brinkman term
for j = 1:2

Rp(g) = Rp(g) + tau*dNpdx(i,g)*ux(j)*dudx(i,j); % PSPG convection term

end
Rp(g) = Rp(g) + tau/rho*dNpdx(i,g)*dpdx(i); % PSPG pressure term

end

end
fprintf('Simplifying Ru... \n');
Ru = simplify(detJ*Ru);
fprintf('Simplifying Rp... \n');
Rp = simplify(detJ*Rp);
%% Integrate analytically
fprintf('Integrating Ru... \n');
Ru = int(int(Ru,xi,[−1 1]),eta,[−1 1]);
fprintf('Integrating Rp... \n');

Joe Alexandersen

38

82

83

84

85

86

87

88

89

90

91

92

Rp = int(int(Rp,xi,[−1 1]),eta,[−1 1]);
fprintf('Simplifying Ru... \n');
Ru = simplify(Ru);
fprintf('Simplifying Rp... \n');
Rp = simplify(Rp);
%% Differentiate residual to form Jacobian
Re = [Ru; Rp];
Je = sym(zeros(12,12));
for b = 1:12

fprintf('Computing dR/ds%2i... \n',b);
Je(:,b) = diff(Re,s(b));

end

93
94 end
95 %% Export residual and Jacobian
96 if (exportJR)

97

98

99

100

fprintf('Exporting residual... \n');
f = matlabFunction(Re,'File','RES','Comments','Version: ...

0.99','Vars',{dx,dy,mu,rho,alpha,transpose([u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4])});

fprintf('Exporting Jacobian... \n');
f = matlabFunction(Je(:),'File','JAC','Comments','Version: ...

0.99','Vars',{dx,dy,mu,rho,alpha,transpose([u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4])});

101 end
102 %%
103 time = toc(time);
104 fprintf('Finished analysis part in %1.3e seconds. \n',time)
105 %% OPTIMISATION PART
106 time = tic;
107 if (buildPhi)

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

%% Compute objective functional
fprintf('Computing phi... \n');
phi = 1/2*alpha*transpose(ux)*ux;
for i = 1:2

for j = 1:2

phi = phi + 1/2*mu*dudx(i,j)*( dudx(i,j) + dudx(j,i) );

end

end
%% Intregrate and simplify objective functional
fprintf('Integrating phi... \n');
phi = int(int(detJ*phi,xi,[−1 1]),eta,[−1 1]);
phi = simplify(phi);
%% Compute the partial derivative wrt. design field
fprintf('Computing dphi/dgamma... \n');
dphidg = simplify( diff(phi,alpha)*dalpha );
%% Compute the partial derivative wrt. state field
dphids = sym(zeros(12,1));
for a = 1:12

fprintf('Computing dphi/ds%2i... \n',a);
dphids(a) = simplify(diff(phi,s(a)));

end

128
129 end
130 %% Compute partial derivative of residual wrt. design field
131 if (buildJR)

132

fprintf('Computing dr/dgamma... \n');
drdg = simplify( diff(Re,alpha)*dalpha );

133
134 end
135 %% Export optimisation functions
136 if (exportPhi)

137

138

139

140

141

142

fprintf('Exporting phi... \n');
f = matlabFunction(phi,'File','PHI','Comments','Version: ...

0.9','Vars',{dx,dy,mu,alpha,transpose([u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4])});

fprintf('Exporting dphi/dg... \n');
f = matlabFunction(dphidg,'File','dPHIdg','Comments','Version: ...

0.9','Vars',{dx,dy,mu,alpha,dalpha,transpose([u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4])});

fprintf('Exporting dphi/ds... \n');
f = matlabFunction(dphids(1:8),'File','dPHIds','Comments','Version: ...

0.9','Vars',{dx,dy,mu,alpha,transpose([u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4])});

143 end
144 if (exportJR)

145

146

fprintf('Exporting dr/ds... \n');
f = matlabFunction(drdg,'File','dRESdg','Comments','Version: ...

0.9','Vars',{dx,dy,mu,rho,alpha,dalpha,transpose([u1 u2 u3 u4 u5 u6 u7 u8 p1 p2 p3 p4])});

A detailed introduction to density-based topology optimisation of ﬂuid ﬂow problems

39

147 end
148 %%

