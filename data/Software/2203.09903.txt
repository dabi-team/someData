preprint version (2022-03-18) This version of the contribution has been accepted for
publication after peer review but is not the Version of Record and does not reﬂect
post-acceptance improvements, or any corrections.
22nd International Conference on Web Engineering (ICWE 2022)
To be published in the SpringerLink Digital Library:
https://link.springer.com/conference/icwe

Conﬁgurable Per-Query Data Minimization for
Privacy-Compliant Web APIs

Frank Pallas[0000−0002−5543−0265], David Hartmann[0000−0001−9745−5287],
Paul Heinrich[0000−0001−9068−3260], Joseﬁne Kipke[0000−0002−6782−8393], and
Elias Gr¨unewald[0000−0001−9076−9240]

TU Berlin, Information Systems Engineering, Berlin, Germany
{fp,dh,ph,jk,eg}@ise.tu-berlin.de

Abstract. The purpose of regulatory data minimization obligations is
to limit personal data to the absolute minimum necessary for a given
context. Beyond the initial data collection, storage, and processing, data
minimization is also required for subsequent data releases, as it is the case
when data are provided using query-capable Web APIs. Data-providing
Web APIs, however, typically lack sophisticated data minimization fea-
tures, leaving the task open to manual and all too often missing imple-
mentations. In this paper, we address the problem of data minimization
for data-providing, query-capable Web APIs. Based on a careful analysis
of functional and non-functional requirements, we introduce Janus, an
easy-to-use, highly conﬁgurable solution for implementing legally com-
pliant data minimization in GraphQL Web APIs. Janus provides a rich
set of information reduction functionalities that can be conﬁgured for
diﬀerent client roles accessing the API. We present a technical proof-of-
concept along with experimental measurements that indicate reasonable
overheads. Janus is thus a practical solution for implementing GraphQL
APIs in line with the regulatory principle of data minimization.

Keywords: privacy, data protection, data minimization, anonymiza-
tion, Web APIs, GraphQL, privacy engineering

1

Introduction

Data minimization is one of the core principles of privacy regulations such as
the GDPR. Basically, it requires to limit personal data to the absolute mini-
mum necessary in a given context. Beyond collection, storage and processing of
personal data, this minimization obligation also applies to subsequent data re-
leases. Any such release of personal data – between diﬀerent departments of an
organization or to external parties – must thus also be conﬁned to the absolute
minimum required by the particular recipient. Depending on the usecase and the
client role, this can require to pseudonymize data, to strip oﬀ certain sensitive
attributes, or to apply information reduction methods such as generalization or
noising to avoid re-identiﬁcation.

2
2
0
2

r
a

M
8
1

]

R
C
.
s
c
[

1
v
3
0
9
9
0
.
3
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
2

F. Pallas et al.

Real-world usecases involving such releases of personal data today typi-
cally employ query-capable Web APIs following paradigms such as REST [7] or
GraphQL [3]. Existing technology stacks broadly used in industry to implement
such APIs do, however, so far not provide the means necessary for implementing
above-mentioned data minimization techniques in a developer-friendly, coherent,
and reliable fashion easily adoptable to the diﬀerent minimization requirements
applicable for diﬀerent usecases and data-requesting parties (or roles). Beyond
fundamental mechanisms for access control, data controllers providing personal
data via Web APIs are thus currently left without proper technical support for
meeting regulatory requirements. The only alternative currently lies in individ-
ually implemented external wrapper components, which raise signiﬁcant eﬀorts
and are error-prone.

We herein close this gap by introducing the concept of per-query role-based
data minimization for data-providing Web APIs. We identify a set of functional
and non-functional requirements that must be met by a technical mechanism
in order to fulﬁll regulatory requirements and be practically applicable. On this
basis, we present Janus, a ready-to-use extension to one of the most widely used
software stacks for building GraphQL APIs – Apollo – that facilitates low-eﬀort
integration of a broad variety of data reduction techniques. All components are
provided under an open source license in publicly available repositories.

The remainder of this paper is structured as follows: Section 2 provides rele-
vant preliminaries on legal requirements for data minimization and on respective
technical measures for implementing it in practice. A motivating and illustra-
tive scenario is also provided here. On this basis, we distill functional and non-
functional requirements in section 3 and elaborate on the integration approach,
architecture, provided functionality, and performance assessment of our proto-
typical implementation in section 4. Limitations of our approach, pathways for
future work and a conclusion are provided in section 5.

2 Preliminaries

In the following, we set out the necessary preliminaries to contextualize our
approach in the light of legal and technical givens and provide an illustrative
scenario mitivating and guiding our subsequent considerations.

2.1 Regulatory Background

As brieﬂy touched above, data minimization is a core concept of modern privacy
regulations. The GDPR [6] can be taken as a representative for comparably
structured legislations such as California’s CCPA or China’s PIPL here: In Art.
5 (1c), it requires that “personal data shall be [. . . ] limited to what is necessary
in relation to the purposes for which they are processed”. Noteworthily, data
minimization must not only be applied to the collection of personal data but
also for their processing and for providing access to them [5, 6].

Per-Query Data Minimization for Privacy-Compliant Web APIs

3

In practice, this can be done in two diﬀerent veins: First, the amount of data
can be minimized. As the European Data Protection Board points out [5], this
refers to the “quantitative and qualitative” amount, thus including “the volume
of personal data, as well as the types, categories and level of detail”. Insofar, the
data minimization principle requires to remove as many attributes of the data
as possible and to limit the level of detail for the remaining ones to the absolute
minimum required in a given context.

Second, the minimization principle does not require to minimize the amount
of data in general but only that of personal data. Another viable approach is thus
to anonymize (“de-personalize”) initially personal data. In so doing, the mere
removal of explicit identiﬁers such as names is, however, typically not suﬃcient
due to re-identiﬁcation risks. Diﬀerent information reduction techniques (see
section 2.2) can reduce these risks and ultimately render data non-personal.

For both approaches, the required level of information reduction and de-
personalization cannot be determined universally but must be assessed on a
per-case basis, taking into account factors such as the nature and scope of the
data, the context it is to be processed in, etc. [8]. This particularly also includes
the distinction between diﬀerent data recipients: releasing data to an academic
research group will, for instance, typically require less strict minimization than
providing it to an international insurance company or even the general public.

2.2 Information Reduction & Anonymization

From the technical perspective, information reduction and anonymization can
take place in diﬀerent forms [10, 16, 17]: Attribute suppression means to com-
pletely remove certain attributes (such as an explicit identiﬁer or a particular
characteristic) from a data point. Generalization, in turn, reduces the level of
detail at which an attribute is included. Typical examples here comprise the
replacement of detailed dates-of-birth with more general year-of-birth ranges,
blinding digits from a ZIP code (sometimes considered as a separate technique
of character replacement ), and so forth. Hashing herein refers to substituting
a value with the result of a (basically) non-revertible hash-function, retaining
uniqueness and validatability without revealing the underlying plain-text data.1
Beyond these mechanisms, anonymity measures such as k-anonymity [20],
ℓ-diversity [15], or t-closeness [14] were introduced to guarantee certain levels
of non-identiﬁability within a dataset. However, these measures as well as the
techniques and algorithms for implementing them are targeted at (rather) static
datasets that are to be released only once or on rather infrequent occasions. In
the context of query-capable APIs delivering continuously changing data, such
anonymization schemes cannot be reasonably applied.

For such contexts, diﬀerent forms of noising (sometimes also referred to
as perturbation) are thus proposed. Advanced approaches of “diﬀerential pri-

1 Hashing is thus often considered as a particular form of pseudonymization when
applied to identiﬁers. A substantial reversion risk may, however, still exist – for a
detailed discussion, see [8].

4

F. Pallas et al.

vacy” [4] here provide statistical guarantees but can only be applied to aggre-
gating queries such as sum, count, etc. and are thus limited to a particular class
of usecases. When data are needed in non-aggregated form, in turn, noising is
typically done in a way that makes individual values “less accurate whilst re-
taining the overall distribution” [2], e.g. through in-/decreasing numerical values
according to typical probability distributions with the level of noise depending
on “the level of information [detail] required and the impact on individuals’
privacy” [2].

2.3 Data-Providing Web APIs and Data Minimization

The broad reception of these and further techniques and their importance for
achieving regulatory compliance notwithstanding, established and easily re-usable
technical implementations are currently missing. Where available at all, respec-
tive programming libraries so far only provide the mathematical or algorithmical
core functionality while lacking coherent and low-eﬀort integration into current
application architectures and, in particular, programming stacks for building
data-providing Web APIs.

Such APIs today mostly follow one of the two paradigmatic approaches of
REST and GraphQL. Of these, GraphQL provides signiﬁcant beneﬁts over REST
in matters such as request-response-latencies or the amount of data to be trans-
ferred in real-world usecases [22, 23]. Together with its capabilities for client-
speciﬁed queries [3], this increasingly makes GraphQL the paradigm of choice
for implementing data-providing Web APIs, especially when relevant data struc-
tures become more complex and when diﬀerent parties only need certain subsets
of the data. We therefore focus on GraphQL herein.

In service-oriented architectures, such APIs are used by external parties (such
as the users of a given app or third parties) as well as by internal ones. As
soon as this involves personal data, the minimization principle comes into play,
requiring the provided data to be limited to the amount absolutely necessary
for the respective party and/or role. However, technical tools for doing so in
established GraphQL programming stacks are rare. Existing approaches such as
GraphQL Shield [25] or GraphQL RBAC [24] only implement simple permission
layers and do not support the implementation of further information reduction
and anonymization functionalities.

Altogether, we thus know a broad variety of fundamental information reduc-
tion and anonymization techniques aimed at the data minimization principle.
When used in proper combination, they may, depending on the type of data, the
context, and the party receiving the data, even allow to render data non-personal
from the regulatory perspective. At the same time, the practical application of
these techniques in real-world Web APIs is – like for other privacy / data protec-
tion principles and technologies [12, 18] – hindered by a lack of easily adoptable
technical solutions that smoothly integrate into established technology stacks
and development practices [13].

Per-Query Data Minimization for Privacy-Compliant Web APIs

5

2.4 Illustrative Scenario

To guide and illustrate our subsequent considerations, we assume the exemplary
scenario of a period tracking app implementing a common architecture with a
smartphone- or web-application sending and retrieving data to/from a Web API,
which, in turn, stores and retrieves data in/from a backend database.

Basically, such period tracking apps provide valuable insights for their users
regarding estimated pain, contraception and ovulation. At the same time, how-
ever, the web API may also be used for sharing menstrual data with other
parties to generate additional beneﬁts: With suﬃciently minimized and/or de-
personalized menstrual data being queryable from the API, a scientiﬁc research
group would, for instance, be able to gain new insights on the relationship be-
tween health and periods. Public health programs, in turn, would be able to
better recognize and counteract existing challenges related to menstrual hygiene
(including, e.g., a lack of infrastructure available) based on such data [19]. In-
ternal processes of app development might also beneﬁt from appropriately min-
imized usage data and, last but not least, even users themselves could proﬁt
from queries like “how severe is my pain compared to other users of the same
age cohort” being facilitated by the API and therefore available in the app.

In all these and many further usecases, the sharing of — suﬃciently mini-
mized – period data with parties beyond the data subjects themselves proposes
noteworthy societal or individual beneﬁts. On the other hand, given the sensitive
nature of such data, the technical mechanisms for doing so must also be reliable
and ideally not implemented individually in an ad-hoc fashion, motivating the
development of a re-usable component that can be easily integrated into existing
Web API frameworks. Any such component must fulﬁll several functional and
non-functional requirements which shall be laid out below.

3 Requirements

In line with other endeavors of practical privacy engineering (such as [11, 12, 18]),
we formulate a set of functional and non-functional requirements that need to
be fulﬁlled. Functional requirements here refer to the core functionality that
needs to be provided while non-functional requirements address the practical
applicability in real-world technology stacks and architectures.

3.1 Functional Requirements

Attribute-Level Role-Based Access Control (FR1): The ﬁrst step towards data
minimization depending on diﬀerent parties or roles accessing a GraphQL API
is to restrict access to single attributes of data items depending on the accessing
party. In our illustrative scenario, an external academic research team might,
for instance, be allowed to access detailed menstrual data but only without
identiﬁers such as names etc., while internal account management might access
these identiﬁers but not the sensitive attributes like menstrual cycles or pain.

6

F. Pallas et al.

Any solution must therefore implement access control on a per-attribute level.
To integrate well with broadly established practices in access management and
control in general, doing so on the basis of roles appears most appropriate.

Attribute-Level Role-Based Information Reduction (FR2): Besides the mere block-
ing of access to single attributes, it must be possible to implement data mini-
mization through applying diﬀerent forms of information reduction to diﬀerent
attributes, again according to diﬀerent roles performing data access. In the just-
mentioned example, the detailed data provided to an academic research team
might have to be subject to generalization of age cohorts to meet regulatory
requirements while an internal product improvement team may only see noised
usage patterns.

Rich and Extendible Set of Information Reduction Methods (FR3): As eﬀective
data minimization is subject to highly case-speciﬁc requirements that must be
met for achieving regulatory compliance, a diversity of diﬀerent information re-
duction techniques can be necessary, ranging from numerical categorization over
character replacements to diﬀerent approaches of statistical noising. This calls
for a rich set of such functionalities – covering numerical and non-numerical val-
ues – to be built upon when deﬁning case- and role-speciﬁc information reduction
schemes. Ideally, this set should be easily extensible in onward development to
accommodate additionally identiﬁed information reduction needs.

Conﬁgurability (FR4): In addition, any technical solution must be highly conﬁg-
urable and allow for adjustable levels of information reduction to satisfy diﬀerent
regulatory requirements while meeting certain accuracy constraints [9].

3.2 Nonfunctional Requirements

Low Integration Overhead (NFR1): Smooth and low-eﬀort integration into at
least one software stack widely used in practice for implementing data-providing
Web APIs fosters practical applicability and viability. At the same time, the con-
nection to an externally maintained role-deﬁnition and authentication subsystem
– e.g., via widely-used JSON Web Tokens (JWTs) – is a necessary precondition
for being interoperable with already existing system architectures.

Reusability (NFR2): Reusability in a broad variety of application architectures,
thorough documentation, and public availability foster software artifacts’ prac-
tical adoption. This also comprises the availability under an open source licence
for commercial use via common code repositories and distribution via package
managers. The latter, eventually, introduce quality assurance, e.g., through code
linting, automatic update mechanisms, and security alerts.

Per-Query Data Minimization for Privacy-Compliant Web APIs

7

Reasonable Performance Overhead (NFR3): Article of the 25 GDPR states that
technical measures for materializing privacy principles must be applied “depend-
ing on the cost of implementation”. Any solution must thus not introduce dis-
proportional performance overheads. The overheads must, in turn, be exper-
imentally determined in realistic settings and with diﬀerent conﬁgurations to
demonstrate the practical viability.

4 Approach & Implementation

To fulﬁll these requirements, we introduce the concept of per-query role-based
data minimization in Web APIs and provide a ready-to-use implementation for
Apollo, one of the most-widely used software stacks for implementing GraphQL
APIs. Given its broad adoption in practice, building upon Apollo is a promis-
ing starting point for keeping integration overhead low for practitioners (see
NFR1 ). Besides mere adoption, Apollo also provides a mature framework for
implementing custom extensions (for details, see below) and thus allows to inte-
grate our intended functionality in a modular and low-eﬀort fashion, supporting
the fulﬁllment of NFR1 even further.

Following this fundamental choice of Apollo as our target platform, the in-
tegration approach, implementation details, practical usage, and experimentally
determined overheads of our prototypical implementation Janus shall be laid
out below.

4.1 Architecture Integration

As delineated in FR1 and FR2, Janus must provide functionalities for attribute-
level access control and information reduction. Basically, these can be imple-
mented in GraphQL using either a middleware- or a schema-directive-driven ap-
proach. Both can extend Apollo’s integrated resolver functionality to ﬁrst query
a data ﬁeld and then subject it to further processing, thus smoothly integrat-
ing into Apollo’s general design and processing ﬂow (see NFR1 ). However, they
function in a signiﬁcantly diﬀerent manner: In the middleware-driven approach,
the resolver can be provided with middleware functions that execute any logic
before and after the resolution of the ﬁeld. Furthermore, middleware functions
can call subsequent ones when passing the execution and modify the request and
response object at any time, thus possibly creating an onion-like resolving ﬂow.
GraphQL schema directives, in turn, deﬁne post-processing steps to be ex-
ecuted on already resolved data ﬁelds before returning them through the API.
Conﬁgured directly in the schema by adding the directive behind the targeted
data ﬁeld, directives can be used on speciﬁed ﬁelds or types of schemas. It is also
possible to deﬁne a directive pipeline with subsequent directives. Compared with
the middleware approach, integrating additional functionality via schema direc-
tives is simpler and provides more clarity (expectably leading to less integration
overhead for developers, see NFR1 ) while still allowing to implement a suﬃcient
level of logical complexity through combining multiple schema directives. We

8

F. Pallas et al.

Fig. 1. Apollo server architecture and Janus integration.

thus chose the approach of schema directives for integrating our functionality
into the Apollo stack at runtime, employing the SchemaDirectiveVisitor class
provided by the graphql-tools 2 library.

Both, access control and information reduction are to be implemented on
the basis of roles (see FR1 and FR2 ). We thus need a mechanism for managing
users, assigning them to roles, letting them log in and then make requests on the
basis of these roles. On the server side, in turn, above-mentioned schema direc-
tives must be deﬁned depending on these roles and requests must be processed
accordingly. To ensure integratability with a wide variety of pre-existing systems
and architectures here (NFR1 ), we opted to keep role management, authenti-
cation, etc. external to our solution and to base our functionality on externally
maintained roles provided via JSON Web Tokens. Janus simply needs the role
parameter to be passed for mapping the role to a set of schema directives to be
applied. Figure 1 depicts the resulting general architecture.

4.2 Implementation

Given this general architecture and integration approach, Janus’ functionality
is implemented in two separate modules with well-distinguished scopes: First,
a module is needed that provides a rich set of information reduction methods
for various data types (FR3 ). These are provided in the package janus-value-
anonymizer, which is publicly available under an open source license on Github
as well as in the npm package managing system (thus meeting NFR2 ).3Possible
extensions with additional information reduction methods (as required in FR3 )
can easily be introduced in this module. In addition, this module can also be used
in other contexts than Janus-enabled Apollo / GraphQL APIs, thus providing
additional beneﬁts in matters of reusability (NFR2 ).

Second, a module is needed that speciﬁcally wraps the access control and
information reduction functionality for an Apollo GraphQL server via custom
directives. This is done in a separate package comprising a collection of respective

2 https://github.com/ardatan/graphql-tools
3 https://github.com/PrivacyEngineering/janus-value-anonymizer

Per-Query Data Minimization for Privacy-Compliant Web APIs

9

Fig. 2. General sequence of operations triggered by a http request containing an ex-
emplary data object.

directives called janus-graphql-anonym-directives which is also available under
an open source license and provided via Github and npm.4

Given this natural two-way split, the ﬂow of a request for a single data ob-
ject – including the authentication and role-speciﬁc token provision exemplarily
implemented in Apollo – and the corresponding processing steps are depicted
in ﬁgure 2: After a http(s) request (including a previously generated role-token)
is sent by the client, the respective data is fetched from the database by the
resolver and returned to the server. Directives added to the corresponding data
ﬁelds in the schema are called by the Apollo server directly after the resolver
has fetched the data. The directives, in turn, use the JWT tokens to extract
the provided role of the current requester. Depending on that role, the directive
requests the role-dependent parameters from the developer’s implementation of
the directives (see section 4.3). Based on these parameters, the directive then
executes the information reduction function(s) and hands over the processed
object back to the Apollo Server which ﬁnally returns it back to the requester.

4 https://github.com/PrivacyEngineering/janus-graphql-anonym-directives

10

F. Pallas et al.

4.3 Usage & Conﬁguration Mechanism

After installing Janus and integrating it into a given Apollo deployment, multi-
ple custom directives for simple attribute suppression (implementing basic per-
attribute access control, FR1 ) and the three more advanced information reduc-
tion techniques generalization, noise, and hashing (FR2 ) can be easily speciﬁed
and parameterized. Noteworthily, the speciﬁcation mechanism allows for role-
dependent behavior as well as for the integration of components external to
Janus itself. Besides ﬂexible conﬁgurability (FR4 ), this may also help lowering
the integration overhead (cf. NFR1 ), especially in complex enterprise environ-
ments.5 A so-speciﬁed custom directive can then be added to a GraphQL schema
by appending its name at the end of the deﬁnition for the data ﬁeld it shall be
applied to, using the common, decorator-style syntax (e.g., @noise) as depicted
in listing 1.1.

Listing 1.1. Adding the directive to the schema.

directive @noise on FIELD_DEFIN IT IO N
...
type Symptom {

pain : Float @noise
...

}

4.4 Information Reduction Techniques

Having laid out the general architecture, implementation, and usage of Janus,
the provided information reduction mechanisms shall be elaborated on in some
more detail. The most fundamental approach for information reduction is the
complete suppression of single attributes (such as names, identiﬁers, etc.). This
functionality can be implemented through the suppression directive, which ef-
fectively implements per-attribute role based access control and can be applied
to ﬁelds of any data type. In case the requester does not hold a role allowed to
access a data ﬁeld the directive is attached to, it simply suppresses that ﬁeld’s
data and returns null instead.

Besides this basic role-based access control, Janus comprises three advanced
information reduction methods – generalization, noise, and hashing – which func-
tion on diﬀerent data types and can be selectively applied, independent of each
other.6

5 Details on the necessary steps for installation, integration, and directive speciﬁ-
cation are provided at https://github.com/PrivacyEngineering/janus-graphql-
anonym-directives.

6 Details on available parameters etc. are again provided at https://github.com/

PrivacyEngineering/janus-value-anonymizer.

Per-Query Data Minimization for Privacy-Compliant Web APIs

11

Generalization: The generalization method supports the data types number,
string, and date. Since a schema in GraphQL has explicitly typed ﬁelds, it is,
however, not possible to turn a number value (integer or ﬂoat) into another data
type that represents a range of numbers without contradicting the schema deﬁ-
nition. For the generalization of number values, we thus let single numbers rep-
resent a range. If, for example, a generalization step size of 10 is used, delimiter-
based generalization results would be 0 (representing 0-9), 10 (for 10-19), 20 (for
20-29), and so forth. This ensures that exactly one number represents one range.
Because generalization is a core method for implementing data minimization,
it is also implemented for dates and strings. For dates, natural generalization
boundaries are given by the diﬀerent units (second, minute, etc.). For strings, in
turn, it is possible to specify how many letters should appear in plain text and
at what point they should be hidden with asterisks (∗).

Noise: The noise function can be used on the data types number and date.
When using noise, one has to deﬁne the mathematical probability distribution
to be used for sampling the noise value that is added to the original value.
Every distribution available in the probability-distributions package7 (such as
Laplacian, Normal, etc.) can be used here. Together with a map of conﬁguration
parameters corresponding to the distribution, developers have a broad ﬂexibility
in implementing the noise behavior. Since noise is mainly useful on numeric
values, it is implemented for integers, ﬂoats and dates.

Hashing: Hash-based data minimization is implemented using the (so far) secure
hashing function SHA3 with output lengths as available in the crypto-js 8 library
(224, 256, 384, or 512 bits). Other hashing algorithms more resistant to brute-
forcing [8] as well as capabilities for including salt are not implemented at the
moment but might be easily added in the future.

4.5 Preliminary Performance Evaluation

To experimentally determine the performance overhead caused by the integra-
tion of Janus and, thus, to validate the fulﬁllment of NFR3, we prototypically
implemented a GraphQL API backend for the period tracking scenario envi-
sioned in section 2.4 and ran several performance tests against this API with
and without Janus being active. This exemplary backend mainly consists of a
GraphQL web server based on Apollo and a PostgreSQL database holding the
data to be provided. The data model comprises a realistic composition of 1:1,
1:n, and n:m relationships between entities. The data minimization directives
are included as described above.9

7 https://www.npmjs.com/package/probability-distributions
8 https://www.npmjs.com/package/crypto-js
9 The

exemplary implementation can be
PrivacyEngineering/janus-period-tracking-app

found here: https://github.com/

12

F. Pallas et al.

50

40

s
d
n
o
c
e
S

30

20

10

0

23.9

18.3

5.6

5.5

46.7

100

91.3

89.3

d
n
o
c
e
s

r
e
p

s
t
s
e
u
q
e
R

80

60

40

20

0

39.7

32.1

19.4

17.6

18.1

5.4

4.1

2.2

100

1000
Number of Data Objects

2.0

2.0

1.2

1.0

0.8

10000

Fig. 3. Mean latency (seconds)
with generalization, noise, and
hash information reduction for
1000 data objects.

Fig. 4. Mean throughput (in requests per sec-
ond) for diﬀerent object frequencies for no op-
eration, baseline, generalization, noise and hash
information reduction methods.

For the experiments, we applied established principles of security-/privacy-
related performance benchmarking [18], using realistic datasets and state-of-the-
art public cloud instances on Microsoft Azure in the same region. We measured
two metrics by running respective experiments against the API instances without
(“Baseline”) and with Janus installed: 1) the latency added by our information
reduction directives and 2) the imposed reduction in matters of throughput. For
covering aspects like general directive invocation overhead etc. separately, we
also included a “no-operation” directive. In this case, requested data traversed
through the directive loop before being delivered, albeit without applying any
information reduction.10

Latency: Figure 3 depicts the latencies observed for the diﬀerent directives with
1000 data objects being requested. Noteworthily, the no-op directive does not
signiﬁcantly diﬀer from the baseline, validating the eﬃciency of our general,
directive-based integration approach. When Janus is used with the general-
ization, noise and hashing information reduction methods, latencies increase at
diﬀerent rates: Generalization and noise lead to 3-4.5-fold latencies while hashing
results in a factor of 8.5. These results are substantial, but given the comparably
time-consuming operations Janus introduces compared to simply handing over
the data from the resolver to the API endpoint, they fall within expectable and
justiﬁed ranges. Interestingly, the relative overhead decreases signiﬁcantly with
more objects being requested and processed. For instance, moving from 1.000 to
10.000 objects results in a 8.5-fold latency for the baseline but only a 2.6-fold
one with hashing being performed. We assume either some sort of static de-
lay factor introduced by crypto-js or a general, Janus-independent side-eﬀect of
Apollo when serializing larger responses. In any case, this aspect clearly deserves
further examination in the future.

10 More details on the experiment setting are left out here due to space constraints but
can be provided upon request. Employed scripts are available at https://github.
com/PrivacyEngineering/janus-performance-evaluation.

 
 
Per-Query Data Minimization for Privacy-Compliant Web APIs

13

Throughput: Figure 4 shows the measured throughput for 100, 1.000 and 10.000
data objects comparing all information reduction methods with non-operational
directives and the baseline. Again, baseline and no-op do not diﬀer signiﬁcantly
(with no-op in fact being slightly more performant). Of the remaining ones,
generalization has the lowest impact, followed by noise and hashing. Like for the
latency experiments, overheads are substantial compared to simply delivering
results without any further processing, but stay within expectable and justiﬁed
ranges given the computational eﬀorts required by information reduction. The
relative loss factor again decreases with larger responses containing 10.000 data
elements for all information reduction methods. This speaks in favor of above-
mentioned assumption of a serialization-related side-eﬀect.

Given the computational overheads necessarily induced by the implemented
information reduction methods compared to simply delivering data without fur-
ther processing, these overheads are far from being unexpected. Especially for
cases where data minimization is an indispensable precondition for implementing
legally compliant API-based data provision to diﬀerent parties at all, however,
the observed overheads will presumably be considered reasonable (see NFR3 ). In
addition, Janus’ concept of per-query and role-based data minimization allows
to selectively apply information reduction techniques where actually required,
facilitating ﬁne-tuned and diﬀerentiated adjustments.

Last but not least, the relative overhead of Janus will expectably decline in
more complex application architectures involving a multitude of further factors
such as data preprocessing, additional database calls, mobile data transfers, etc.
(for a vivid example on the eﬀect of such factors, see [18]).

5 Limitations, Future Work & Conclusion

Introducing the concept of per-query role-based access control and information
reduction to the domain of data-providing, query-capable Web APIs, identifying
respective requirements, and providing a ﬁrst practically usable prototype for an
established GraphQL stack were the deﬁnite foci of the work presented herein.
Given the rather initial state, several limitations naturally remain and various
aspects had to be left open for future work.

First of all, we refrained from adding overall complexity by complementing
our approach with consent management mechanisms. Clearly, policy languages
such as the extensive XACML [1] or the lightweight YaPPL [21] would have
provided more detailed and individually adjustable control over data releases.
However, they would also require a signiﬁcantly more extensive user manage-
ment and custom vocabulary deﬁnitions and also introduce extra performance
overhead. Moreover, client-side complexity would drastically increase as well,
which impedes the low-eﬀort integration of our component.

Additionally, the provision of further well-known anonymization and infor-
mation reduction techniques would clearly advance Janus’ scope of application.
In particular, the integration of ε-diﬀerential privacy with custom additive noise
mechanisms is an obvious candidate here and would allow for aggregating queries

14

F. Pallas et al.

with clearly speciﬁed guarantees. Similarly, the existing information reduction
methods could also be advanced with more complex functionalities like string
ranges etc. Based on the general architecture provided herein, we expect such
extensions to be straightforward implementation tasks based on available ready-
to-use packages, which we invite the community for doing so.

Finally, more in-depth examinations of the so far only preliminarily assessed
performance impacts are a clear subject for future work. For instance, the ef-
fects observed for larger responses in section 4.5 deserve closer inspection, the
overall impact of Janus in more complex end-to-end settings is so far unvali-
dated, the eﬀect of combining diﬀerent information reduction methods should
be illuminated, etc. All this should, of course, go hand in hand with dedicated
performance optimizations of the initial, unoptimized prototype implementation
presented and provided herein.

These open issues notwithstanding, we herein presented the ﬁrst-of-its-kind
re-usable component that combines role-based access control with per-query data
minimization for modern Web and in particular GraphQL APIs. The application
scenarios for Janus in the course of practical privacy engineering are manifold
and were illustrated with a period-tracking application example without limit-
ing its generality for other real-world scenarios. The performance impacts were
shown to be non-negligible but still appear to be acceptable, especially for use-
cases that would not be implementable in a legally compliant way without solid
information reduction being applied before the release of initially personal data.
We emphasize the particular importance of both legal and technical require-
ments that guided the design of Janus’ general architecture and its implemen-
tation. Under these practice-oriented guidelines, we are convinced of the possible
low-eﬀort integratability of our open source component into many real-world sys-
tems for eﬀectively heightening the level of privacy. Noteworthily, Janus does
not, per se, provide any guarantees in matters of regulatory compliance, given
the multitude of factors inﬂuencing what needs to be implemented in a particular
case. It does, however, equip developers of data-providing GraphQL APIs with
the technical capabilities for fulﬁlling case-dependent legal data minimization
obligations in a handy, highly conﬁgurable, and easy to use manner.

References

1. Anderson, A., Nadalin, A., Parducci, B., Engovatov, D., Lockhart, H., Kudo, M.,
Humenn, P., Godik, S., Anderson, S., Crocker, S., et al.: Extensible Access Control
Markup Language (XACML) Version 1.0. OASIS (2003)

2. Art. 29 Data Protection Working Party: Opinion 05/2014 on anonymisa-
tion techniques – wp216 (2014), https://ec.europa.eu/justice/article-29/
documentation/opinion-recommendation/files/2014/wp216_en.pdf

3. Brito, G., Mombach, T., Valente, M.T.: Migrating to graphql: A prac-
tical assessment.
In: 2019 IEEE 26th International Conference on Soft-
ware Analysis, Evolution and Reengineering (SANER). pp. 140–150 (2019).
https://doi.org/10.1109/SANER.2019.8667986

4. Dwork, C.: Diﬀerential privacy: A survey of results. In: International conference
on theory and applications of models of computation. pp. 1–19. Springer (2008)

Per-Query Data Minimization for Privacy-Compliant Web APIs

15

5. European Data Protection Board: Guidelines 4/2019 on article 25 – data protec-
tion by design and by default (2019), https://edpb.europa.eu/sites/default/
files/consultation/edpb_guidelines_201904_dataprotection_by_design_
and_by_default.pdf

6. European Parliament and Council of the European Union: Regulation (EU)

2016/679 of 27 April 2016. General Data Protection Regulation (2018)

7. Fielding, R.: Representational state transfer. Architectural Styles and the Design

of Network-based Software Architecture pp. 76–85 (2000)

8. Finck, M., Pallas, F.: They who must not be identiﬁed—distinguishing personal
from non-personal data under the GDPR. International Data Privacy Law 10(1),
11–36 (03 2020). https://doi.org/10.1093/idpl/ipz026

9. Ghinita, G., Karras, P., Kalnis, P., Mamoulis, N.: A framework for eﬃcient data
anonymization under privacy and accuracy constraints. ACM Transactions on
Database Systems (TODS) 34(2), 1–47 (2009)

10. Gruschka, N., Mavroeidis, V., Vishi, K., Jensen, M.: Privacy issues and data pro-
tection in big data: a case study analysis under gdpr. In: 2018 IEEE International
Conference on Big Data (Big Data). pp. 5027–5033. IEEE (2018)

11. Gr¨unewald, E., Pallas, F.: TILT: A GDPR-Aligned Transparency Information Lan-
guage and Toolkit for Practical Privacy Engineering. In: Proceedings of the 2021
Conference on Fairness, Accountability, and Transparency. ACM, New York, NY,
USA (2021). https://doi.org/10.1145/3442188.3445925

12. Gr¨unewald, E., Wille, P., Pallas, F., Borges, M.C., Ulbricht, M.R.: TIRA: An
OpenAPI Extension and Toolbox for GDPR Transparency in RESTful Architec-
tures. In: 2021 International Workshop on Privacy Engineering. IEEE (2021)
13. Kostova, B., G¨urses, S., Troncoso, C.: Privacy engineering meets software engineer-

ing. on the challenges of engineering privacy by design. arXiv:2007.08613 (2020)

14. Li, N., Li, T., Venkatasubramanian, S.: t-Closeness: Privacy Beyond k-Anonymity
and l-Diversity. In: 23rd International Conference on Data Engineering. pp. 106–
115. IEEE (2007). https://doi.org/10.1109/ICDE.2007.367856

15. Machanavajjhala, A., Kifer, D., Gehrke, J., Venkitasubramaniam, M.: l-diversity:
Privacy beyond k-anonymity. ACM Transactions on Knowledge Discovery from
Data 1(1), 3 (Mar 2007). https://doi.org/10.1145/1217299.1217302

16. Majeed, A., Lee, S.: Anonymization techniques for privacy preserving data
IEEE Access 9, 8512–8545 (2021).

publishing: A comprehensive survey.
https://doi.org/10.1109/ACCESS.2020.3045700

17. Marques., J., Bernardino., J.: Analysis of data anonymization techniques. In:
Proceedings of the 12th International Joint Conference on Knowledge Discov-
ery, Knowledge Engineering and Knowledge Management - KEOD. pp. 235–241.
SciTePress (2020). https://doi.org/10.5220/0010142302350241

18. Pallas, F., Ulbricht, M.R., Tai, S., Peikert, T., Reppenhagen, M., Wenzel,
D., Wille, P., Wolf, K.: Towards application-layer purpose-based access con-
trol. In: 35th Symposium on Applied Computing. pp. 1288–1296. ACM (2020).
https://doi.org/10.1145/3341105.3375764

19. Smith, A.D., Muli, A., Schwab, K.J., Hennegan, J.: National monitoring for men-
strual health and hygiene: Is the type of menstrual material used indicative of
needs across 10 countries? International Journal of Environmental Research and
Public Health 17(8) (2020)

20. Sweeney, L.: k-Anonymity: A Model For Protecting Privacy. International Journal
of Uncertainty, Fuzziness and Knowledge-Based Systems 10(05), 557–570 (Oct
2002). https://doi.org/10.1142/S0218488502001648

16

F. Pallas et al.

21. Ulbricht, M.R., Pallas, F.: YaPPL - A Lightweight Privacy Preference Language for
Legally Suﬃcient and Automated Consent Provision in IoT Scenarios. In: Garcia-
Alfaro, J., Herrera-Joancomart´ı, J., Livraga, G., Rios, R. (eds.) Data Privacy
Management, Cryptocurrencies and Blockchain Technology. pp. 329–344. Springer
(2018)

22. Vogel, M., Weber, S., Zirpins, C.: Experiences on migrating restful web services
to graphql. In: Braubach, L., Murillo, J.M., Kaviani, N., Lama, M., Burgue˜no, L.,
Moha, N., Oriol, M. (eds.) Service-Oriented Computing – ICSOC 2017 Workshops.
pp. 283–295. Springer, Cham (2018)

23. Wittern, E., Cha, A., Davis, J.C., Baudart, G., Mandel, L.: An empirical study
of GraphQL schemas. In: Yangui, S., Bouassida Rodriguez, I., Drira, K., Tari,
Z. (eds.) Service-Oriented Computing, vol. 11895, pp. 3–19. Springer (2019).
https://doi.org/10.1007/978-3-030-33702-5 1

24. Yang, F.: GraphQL role-based access control (RBAC) middleware (2018),

https://github.com/Canner/graphql-rbac

25. Zavadlal, M.: GitHub - maticzav/graphql-shield: A GraphQL tool to ease the
creation of permission layer. (2021), https://github.com/maticzav/graphql-
shield

This figure "architecture_v3.png" is available in "png"(cid:10) format from:

http://arxiv.org/ps/2203.09903v1

