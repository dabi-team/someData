2
2
0
2

r
p
A
9

]
E
S
.
s
c
[

1
v
2
6
5
4
0
.
4
0
2
2
:
v
i
X
r
a

What are the characteristics of highly-selected packages? A case
study on the npm ecosystem

Suhaib Mujahida, Rabe Abdalkareemb and Emad Shihaba

aData-driven Analysis of Software (DAS) Lab, Concordia University, Montreal, Canada
bSchool of Computer Science, Carleton University, Ottawa, Canada

A R T I C L E I N F O

Abstract

Keywords:
highly-selected packages
package quality
software ecosystem
npm

With the popularity of software ecosystems, the number of open source components (known as
packages) has grown rapidly. Identifying high-quality and well-maintained packages from a large
pool of packages to depend on is a basic and important problem, as it is beneÔ¨Åcial for various
applications, such as package recommendation and package search. However, no systematic and
comprehensive work focuses on addressing this problem except in online discussions or informal
literature and interviews. To Ô¨Åll this gap, in this paper, we conducted a mixed qualitative and
quantitative analysis to understand how developers identify and select relevant open source pack-
ages. In particular, we started by surveying 118 JavaScript developers from the npm ecosystem
to qualitatively understand the factors that make a package to be highly-selected within the npm
ecosystem. The survey results showed that JavaScript developers believe that highly-selected
packages are well-documented, receive a high number of stars on GitHub, have a large num-
ber of downloads, and do not suÔ¨Äer from vulnerabilities. Then, we conducted an experiment
to quantitatively validate the developers‚Äô perception of the factors that make a highly-selected
package. In this analysis, we collected and mined historical data from 2,527 packages divided
into highly-selected and not highly-selected packages. For each package in the dataset, we col-
lected quantitative data to present the factors studied in the developers‚Äô survey. Next, we used
regression analysis to quantitatively investigate which of the studied factors are the most impor-
tant. Our regression analysis complements our survey results about highly-selected packages. In
particular, the results showed that highly-selected packages tend to be correlated by the number
of downloads, stars, and how large the package‚Äôs readme Ô¨Åle is.

1. Introduction

In recent years, the proliferation of software ecosystems has led to a vast and rapid growth of the number of open-
source packages.1 For example, as of January 2022, there were over a million packages available on the registry of the
Node Package Manager (npm), one of the largest software ecosystems. Furthermore, the number of packages grew by
around 60% between January 2019 and January 2022 [13]. With the massive number of packages out there, Ô¨Ånding
the right package to use can be challenging, considering that many packages provide similar functionalities. However,
there are some packages that stand out and experience high interest from developers. We believe that understanding
the characteristics of these highly-selected packages is very important since it helps developers answer the essential
question: which packages a developer should select among many existing options. In addition, such understanding can
help to improve the performance of package recommendation systems [63, 38, 52, 48] and enhance the user experience
of package search engines [5, 52, 11]. Furthermore, for package developers, understanding the characteristics of highly-
selected packages can be helpful for various purposes, such as improving their packages to meet the requirements and
experiences that users look for, acquiring the community‚Äôs attention, and eventually increasing the package usage and
overall reputation. Those potential implications of understanding the factors of highly-selected motivate use to study
them.

Previous studies examined diÔ¨Äerent aspects of packages published in software ecosystems, such as centrality and
popularity [4, 5, 31, 45, 39], and a few examined the selection factors of relevant packages [31, 27]. The main limitation
of prior works is that they were based on a purely quantitative analysis of popular packages or only interviewing
developers in a speciÔ¨Åc industrial context. That said, understanding the characteristics of highly-selected packages

suhaib.mujahid@concordia.ca (S. Mujahid); rabe.abdalkareem@carleton.ca (R. Abdalkareem);

emad.shihab@concordia.ca (E. Shihab)

ORCID(s): 0000-0003-2738-1387 (S. Mujahid); 0000-0001-9914-5434 (R. Abdalkareem); 0000-0003-1285-9878 (E. Shihab)
1In this paper, we use the term package referring to open source components published on software ecosystems.

Mujahid et al.: Preprint submitted to Elsevier

Page 1 of 17

 
 
 
 
 
 
Characteristics of highly-selected packages

Figure 1: An overview of our study design.

is still the subject of much discussion and reÔ¨Ånement. This is because several facts include personality aspects and
examining diÔ¨Äerent data modalities from several sources, and a developer is typically a familiar user of a speciÔ¨Åc
package. Thus, in this paper, we divided the study into two parts - qualitative and quantitative [28]. Figure 1 shows
an overview of our study design. In the Ô¨Årst part (referred from now on as qualitative analysis), we conducted a user
study survey that involves 118 JavaScript developers. We asked our survey participants to Ô¨Åll in a form composed of
17 statements about factors they use when selecting npm packages. Then, we qualitatively analyzed the developers
answers to the 17 questions using descriptive statistics.

In order to provide validation to the Ô¨Åndings of the qualitative analysis, we conducted quantitative analysis on a set
of 2,527 npm packages grouped into highly-selected and not highly-selected packages. Similar to prior work [6, 32, 55],
we estimated the highly-selected packages based on the number of directly dependent packages (i.e., clients packages)
within the npm ecosystem. Then, we mined and analyzed the selected packages and collected quantitative data to
present the factors studied in our survey. Next, we used regression analysis to quantitatively investigate which of the
studied factors are the most important for developers to select a package to use.

The survey results showed that JavaScript developers believe that when selecting a package to use, they look for
packages that are: well-documented, receive a high number of stars on GitHub, have a large number of downloads,
and do not suÔ¨Äer from security vulnerabilities. Moreover, our regression analysis complemented our survey results
about highly-selected packages. For example, our developers‚Äô survey and regression analysis revealed that developers
select packages with a high number of stars and downloads. Also, it described the diÔ¨Äerences between the developers‚Äô
perceptions about highly-selected packages and their characteristics. In general, our work makes the following key
contributions:

‚Ä¢ We performed a mixed qualitative and quantitative analysis to investigate the characteristics of highly-selected
packages on the npm ecosystem. We presented our results from surveying 118 JavaScript developers and vali-
dated the survey results through a quantitative analysis of 2,427 npm packages.

‚Ä¢ We identiÔ¨Åed the most important factors that packages‚Äô users should consider when selecting an npm package

to use in their projects.

‚Ä¢ We also provided practical implications for packages‚Äô maintainers, the npm ecosystem‚Äôs maintainers, and re-

searchers and outline future research avenues.

The remainder of this paper is structured as follows. Section 2 describes the study design and presents the results
of the qualitative analysis. Section 3 describes the study design and presents the results of the quantitative analysis.
We discuss the implications of our study in Section 4. In Section 5, we present the work that is related to our study.
We discuss the threats that may aÔ¨Äect the validity of the results in Section 6. Finally, Section 7 concludes our work.

2. Qualitative Analysis

This analysis aims to survey JavaScript developers to understand the characteristics of packages that JavaScript

developers look for when selecting an npm package to use. In this study, we surveyed 118 JavaScript developers.

Mujahid et al.: Preprint submitted to Elsevier

Page 2 of 17

Qualitative Study 1. Qualitative Analysis: surveying  Javascript developers about package usage factors.2. Quantitative Analysis: using a logistic regression model to validate the developers‚Äô perceptions.Survey: 118 JavaScript Developer responses.Github Data: we collected repository level factors.Snyk Data: we collected security vulnerability factors. npm Data: we collected package level factors.Characteristics of highly-selected packages

2.1. Study Design

This section presents our survey design, participant recruitment, and data analysis methods.

2.1.1. Survey Design

To understand which factors developers look for when selecting an npm package, we designed a survey containing
three main parts. The Ô¨Årst part contained questions related to the background of the participants. We asked these
questions to ensure that our survey participants have suÔ¨Écient experience in software development and in selecting
and using npm packages. In this part, we asked the following questions:

1. How would you best describe yourself? A question with the following choices and the last choice is a free-text

form: Full-time, Part-time, Free-lancer, and Other.

2. For how long have you been developing software? A selection question with the following options: <1 year, 1‚àí3,

4‚àí5, more than 5 years.

3. How many years of JavaScript development experience do you have? A selection question with the following

options: <1 year, 1‚àí3, 4‚àí5, more than 5 years.

4. How many years of experience do you have using the Node Package Manager (npm)? A selection question with

the following options: <1 year, 1‚àí3, 4‚àí5, more than 5 years.

5. How often do you search for npm packages? A question with the following options: Never, Rarely (e.g., once a

year), Sometimes (e.g., once a month), Often (e.g., once a week), Very often (e.g., everyday).

6. Which search engine interface do you use to Ô¨Ånd relevant npm packages? A question with the following multiple
choices and the last choice is a free-text form: Online search on the npm web page (i.e., npms), Command line
search, Google or other general web search engines, and Other.

In the second part of the survey, we had a list of statements that present seventeen factors that can aÔ¨Äect selecting
npm packages. In particular, we asked the question ‚ÄúHow important are the following factors when selecting a relevant
npm package?‚Äù Table 1 reports the seventeen factors statements. For each statement, the table presents each factor‚Äôs
deÔ¨Ånition and the rationale behind asking about it. In the survey, we asked participants to rate these statements using
a Likert-scale ranges from 1 = not important to 5 = very important [42]. We chose to investigate these factors for two
main reasons. First, our literature review indicated that these factors are known to impact the use and selection of npm
packages. Second, we focued on studying factors that developers can easily observe through examining the package
source code or its software repository, e.g., from the GitHub website.

In the last part of our survey, we asked the participants an open-ended question about whether they had any addi-
tional comments or other factors that they look for when they select a package. We asked this open-ended question
to give our survey participants maximum Ô¨Çexibility to express their opinion and experience with the selection of npm
packages, which also complies with the survey design guidelines [15].

Once we had our survey questions, we shared the survey with three of our colleagues who are experts in JavaScript
programming and using packages from npm. We performed this pilot survey to discover potential misunderstandings
or unexpected questions early on and improve our survey [15].

2.1.2. Participant Recruitment

To identify the participants in our survey, we needed to reach out to developers who are the experts in selecting
and using JavaScript packages. Thus, we resorted to the public registry of npm [41]. The registry contains information
on each package published on npm, including information about the developers maintaining the package. We used the
npm registry to collect a list of emails and names of JavaScript developers who selected and used a suÔ¨Écient number
of npm packages. To do so, we analyzed the npm registry, and for each package, we extracted and counted the number
of its dependencies and the contacts information of the developers who are maintaining the package. Then, we selected
the top thousand developers based on the number of their distinct package dependencies. It is important to note that
we selected developers who use a large number of packages since they likely went through the process of selecting
npm packages several times.

Once we identiÔ¨Åed this initial sample of developers, we examined all the names and email addresses of the identiÔ¨Åed
developers to exclude duplicated emails and names. Based on this step, we identiÔ¨Åed 931 unique JavaScript developers.

Mujahid et al.: Preprint submitted to Elsevier

Page 3 of 17

Characteristics of highly-selected packages

Table 1
List of factors used in selecting a packages from the npm ecosystem.

Factor

Forks

Watchers

Contributors

Downloads

Stars

The survey statements

Rationale

The number of forks for the pack-
age‚Äôs source code on GitHub.

The number of forks that packages receive indicates that the packages are active,
and many developers are contributing to these packages [20].

The number of watchers of the
package‚Äôs GitHub repository.

Developers can watch package repositories on GitHub so they can receive noti-
Ô¨Åcations about package development activities [49]. The higher the number of
watchers on a package indicates that the package is well-known and used by many
developers. We consider that packages with an increased number of watchers refer
to highly-selected packages.

The number of contributors to a
package‚Äôs GitHub repository.

The higher the number of contributors to a package repository shows that the
package is more likely to attract developers [59].

The number of downloads the pack-
age has.

The packages that have a higher number of downloads indicate that the packages
are highly selected and used [5].

The number of stars of a packages
on GitHub.

A high number of stars that a npm package receives on GitHub could indicate to
developers that the package is more likely popular, which may attract them to
use the package [8, 12].

Dependencies

The number of dependencies the
npm package has.

License

Wether the npm package has a
permissive or restrictive software li-
cense.

Documentation Whether the npm package reposi-
tory has online documentation, e.,g.
README Ô¨Åle.

A larger number of dependencies could not attract more developers to use the
packages since prior work shows that packages with a more considerable depen-
dency may lead to dependency hell [3].

When evaluating a package, it is also essential to consider non-functional require-
ments, such as the license. Using a package with no license or with a license
that does not match the developer organization‚Äôs usage and policies can quickly
become a problem [36, 53].

The package that is well-documented and has a very organized README Ô¨Åle is
more likely to be used by many developers [7, 24].

Test Code

Build Status

Whether the npm package has test
cases written.

Packages that have test code written are more likely to attract developers to use
them since it indicates that the packages are well-tested [3].

The build status of the npm package
for example from Travis CI.

The presence of a high number of failed builds in the package repository may lead
developers not to use the package [5].

Vulnerabilities

If the npm package depends on vul-
nerable dependencies.

If a npm package is aÔ¨Äected by vulnerabilities, it may concern developers and
deter them from selecting and using the package [5, 4].

Badges

Website

Releases

If
the
badges.

package

repository

has

The presence of badges in the package repository indicates that the package is of
good quality that attracts developers to use the package [56].

If the package has a custom website. The presence of a website for the package indicates that the package is sup-
ported by an organization, which is usually a signal that there is more than one
maintainers or major contributor (i.e., there is support by an organization) [44].

The release frequency of the pack-
age.

A package with several releases indicates that the package is well maintained.

Closed Issues

The number of closed issues in the
package‚Äôs repository.

Commit
quency

Fre-

The commit frequency in the pack-
age repository.

The number of closed issues indicates how well-maintained the package is and
reveals how maintainers of the package respond to issues. Packages with a large
percentage of closed issues attract more developers to use the package [5].

Developers mainly look for well-maintained and active packages to use. Prior
work also shows that the number of commits a package receives can give a good
indication of how active the package is, which results in high selection [5].

Usage

The number of projects using the
package on GitHub.

Packages that are used by many other developers are more likely to attract more
developers to use [4].

Next, we sent email invitations of our survey to the 931 unique developers. However, since some of the emails were
returned for several reasons (e.g., invalid emails), we successfully reached 895 developers. In the end, we received 118
responses for our survey after having the survey available online for ten days. This number of responses translates to
a 13.18% response rate, which is comparable to the response rate reported in other software engineering surveys [50].

Mujahid et al.: Preprint submitted to Elsevier

Page 4 of 17

Characteristics of highly-selected packages

Table 2
Participants‚Äô position, and their experience in software development, JavaScript, and use of the npm package manager
platform.

Developers‚Äô
Position

Full-time
Part-time
Freelancer
Other

Occurrences

Development
Experience

Occurrences

Experience
in JavaScript

Occurrences

Experience in
Using npm

Occurrences

84
9
15
10

< 1
1 - 3
4 - 5
> 5

2
21
15
80

< 1
1 - 3
4 - 5
> 5

0
25
37
56

< 1
1 - 3
4 - 5
> 5

0
59
20
39

2.1.3. Survey Participants

Table 2 shows the positions of the participants, the development experience of the participants, the JavaScript

experience of the participants, and their experiences in using npm ecosystem.

As for the participants‚Äô positions, 84 participants identiÔ¨Åed themselves as full-time developers and 9 participants
as part-time developers. Interestingly, 15 participants identiÔ¨Åed themselves as freelancers. The remaining ten partic-
ipants identiÔ¨Åed themselves as having other positions not listed in the question, including open-source developers, IT
specialists, and PhD students.

Of the 118 participants in our survey, 80 participants have more than 5 years of development experience and 15
responses have between 4 to 5 years. Also, 21 participants claimed to have between 1 to 3 years of experience, and
only two participants have less than two years of development experience. In addition, 56 participants have more than
5 years of experience in JavaScript, 37 participants have experience in using JavaScript between 4 to 5 years, and 25
participants claimed to have between 1 to 3 years of experience.

We also asked our survey participants about their experience in using packages from the npm ecosystem. The
majority of our survey participants indicated that they have more than one year of experience using npm. SpeciÔ¨Åcally,
39 participants have more than 5 years of experience using npm and 20 responses have between 4 to 5 years. Finally,
59 participants claimed to have between 1 to 3 years of experience.

In addition, to inquire our survey participants about their development experience, we asked them how often they
search for npm packages and which search engine they used to perform their search. Figure 2 reports the result related
to participants‚Äô habits about how often they search for npm packages. Of the 118 participants, 15% indicated that they
search for npm packages very often, and 42% indicated that they often search for new npm packages. Almost all the
remaining participants (38%) indicated they sometimes look for npm packages. Interestingly, only 4% of our survey
participants reported that they rarely do search for packages, and no one indicated that she/he never looks for npm
packages. Our survey participants also reported that they mainly use web search engines (e.g., Google) when they
search for npm packages to use. Interestingly, only 20% of them indicated they use other search engines.

Overall, the background information about the developers who participated in our survey shows that they are expe-
rienced in JavaScript and selecting npm packages, which gives us conÔ¨Ådence in the Ô¨Ånding based on their experiences.

Figure 2: Survey responses regarding how often our survey participants search for npm packages.
In our survey, the
question has the following answers: never, rarely (e.g., once a year), sometimes (e.g., once a month), often (e.g., once a
week), very often (e.g., everyday).

Mujahid et al.: Preprint submitted to Elsevier

Page 5 of 17

Very oftenOftenSometimesRarelyNever01020304050Responses Count15%42%38%4%0%Characteristics of highly-selected packages

Table 3
Survey results of the factors used in selecting a package from the npm ecosystem.

Factor

Distribution
1 2 3 4 5

Median

IQR Mean

SD

Documentation

Downloads

Stars

Vulnerabilities

Release

Commit frequency

Closed issue

License

Usage

Test Code

Dependencies

Contributors

Build Status

Website

Watchers

Badges

Forks

5.0

4.5

4.0

4.0

4.0

3.0

3.0

3.0

3.0

3.0

3.0

3.0

3.0

3.0

3.0

2.0

2.0

0.0

1.0

2.0

2.0

1.0

1.0

1.0

3.0

2.0

2.0

2.0

2.0

2.0

3.0

3.0

2.0

2.0

4.64

4.30

3.97

3.70

3.48

3.33

3.29

3.26

3.19

3.14

3.12

3.03

2.89

2.67

2.53

2.25

2.12

0.77

0.88

1.13

1.24

1.10

1.23

1.09

1.39

1.33

1.31

1.33

1.40

1.31

1.32

1.25

1.20

1.25

2.1.4. Analysis Method

To analyze our survey responses about the diÔ¨Äerent factors used to select npm packages, we Ô¨Årst showed the
distribution of the Likert-scale for each factor, which ranges from 1 = not important to 5 = very important [42].
Second, for all responses of each factor, we calculated values of the median, the interquartile range (IQR), the mean,
and the standard deviation (SD).

In addition, to analyze the free-text answers from the open-ended question related to developers‚Äô opinions, we
performed an iterative coding process to understand whether the responses indicated any other factors that we did not
consider in our survey [46]. The Ô¨Årst two authors iteratively developed a set of codes based on an inductive analysis
approach [47]. In total, the authors manually examined 30 responses from the developers who answered the optional
open-ended question. However, based on this analysis, we did not Ô¨Ånd any new factors that we did not consider in
our survey. In fact, all the responses to this open-ended question supported the developers‚Äô opinions about the studied
factors.

2.2. Study Results

Table 3 shows the factors‚Äô name and the 5-point Likert-scale distribution for each factor from our survey responses.
The table also shows the scale‚Äôs median alongside the value of IQR and mean alongside SD. Overall, based on our
survey results, we can divide the factors used by developers when selecting packages into three groups: 1) important
factors (e.g., documentation, downloads, and stars), 2) somewhat important factors (e.g., license and testing), and
3) unimportant factors (e.g., watchers and badges). In the following, we discuss the developers‚Äô perceptions in more
detail:

Documentations: On a 5-point scale, participants indicated that the most important factor when looking for an
npm package to select is how well a package is documented. Table 3 shows that the majority 93% (median = 5.00
and mean = 4.65) of the responses agree with the statement that the GitHub repository of a npm package that they are
examining to select should have some form of documentation. In addition, to conÔ¨Årm this statement, developer P40
stated that ‚ÄúSample code documentation on its usage‚Äù are important factors when selecting an npm package to use.

Downloads: The second most important factor reported by our survey participants is the number of downloads
that the packages have. More than 85% (median = 4.5 and mean = 4.30 on the 5-point scale) of the responses said

Mujahid et al.: Preprint submitted to Elsevier

Page 6 of 17

Characteristics of highly-selected packages

that they considered the number of downloads a package has when searching for a package to use. These results give
a high indication that developers still consider the download count of packages as a sign of the community interest,
which means that the package is a good option to select.

Stars: Our survey showed that developers also look for the number of stars the packages have when searching for
a package to select. On the 5-points scale, developers believed that the reputation of the packages in terms of start
count is an important indicator with median = 4.0 and mean = 3.97. For example, developer P74 stated that ‚Äúreputa-
tion/popularity‚Äù are the most important factors when selecting an npm package to use.

Vulnerabilities: The fourth most important factor developers consider when searching for a new npm package to
use is that the packages do not depend on vulnerable code. On a 5-point scale, 62% of the developers saw vulnerabilities
as an essential factor when Ô¨Ånding and selecting relevant npm packages. Furthermore, some developers in our survey
emphasized the essentiality of this factor, participant P58 said ‚Äú... not dependent on other out of date or vulnerable
packages.‚Äù Also, participant P45 stated that they look for packages that are free of vulnerable code and the maintainers
of the packages use tools to scan for vulnerabilities such as Snyk and dependabot tools.

Our survey also revealed that there are some other factors that developers did not have an agreement on whether
they are essential when they search for packages to select or not. We found that factors such as release (median = 4.0
and mean = 3.48), commits frequency (median = 3.0 and mean = 3.33), and test code (median = 3.0 and mean = 3.14)
do not have a consistent agreement amongst the participants in our survey. However, some participants explicitly high-
lighted the importance of some of these factors, such as developer P69, who said ‚Äúexamining the package repository
and see the recent and historical activity/commits/updates would help making the decision‚Äù. Another developer, P1
explained that ‚Äú. . . the test coverage status is useful, but can be veriÔ¨Åed manually in the code when deciding to use
the package. The last date a commit was made is very important. The more recent the better. The last date a release
was made is very important. The more recent the better.‚Äù In addition, we observed from Table 3 that developers in
our survey did not have a consistent agreement about factors such as license and number of dependent applications,
number of dependencies that the package uses, the number of closed issues, and the number of contributors, which
have, on a 5-point scale, values with a mean of 3.26, 3.19, 3.12, and 3.03, respectively.

The other interesting group of the studied factors that developers tend not to consider when examining an npm
package to use are: forks, badges, watchers, website, and build status. Our analysis showed that these factors received
median values between 2.0 and 3.0 and mean values between 2.12 and 2.89 on a 5-point scale. However, only one
developer from our survey supported the idea that examining the build status is essential when selecting a package to
use and said P1 ‚ÄúThe build status is important no matter if it comes from Travis CI or other providers ...‚Äù.

Finally, we observed that developers mentioned a few other factors when looking for npm packages. Our survey
participants indicated that if there is a big software company that supports the package. For example, developers P39
said ‚ÄúThe source of the package, if it is by a company that actively supports open source and maintains their open
source packages (ex: Facebook, Formidable labs, InÔ¨Ånite Red), brings more points‚Äù. Also, another participant stated
the same, P11 ‚ÄúPrivate support for big companies in open source projects or libs (angular-google, react-facebook,
etc) that means the package usually follow good practices, test, linter, ci, etc, and the team that maintains the package
is really good.‚Äù

In addition, two other developers in our survey indicated that support of community discussions about the packages
matters. For example, P94 mentions ‚ÄúWhether the package is actively maintained by developers well known and
reputed in the community & whether the package has good typescript support‚Äù and P60 said ‚ÄúIf the library is supported
with an online community where usage is discussed‚Äù. Another developer, P20 stated ‚ÄúReferences on other professional
webpages about the package‚Äù.

In summary, JavaScript developers have access to a wealth of information about a large number of npm packages
that can be used when deciding which packages to select. Our survey shows that developers mainly consider
packages that are well-documented, popular, and do not suÔ¨Äer from security vulnerabilities. Moreover, when we
conducted our survey, among the 118 respondents, 73 (62%) provided their emails and showed interest in our
Ô¨Åndings. This indicates the strong relevance and importance of the Ô¨Åndings to the practitioners and the overall
JavaScript development community.

Mujahid et al.: Preprint submitted to Elsevier

Page 7 of 17

Characteristics of highly-selected packages

Figure 3: A histogram for the used npm packages.

3. Quantitative Analysis

The goal of this analysis is to triangulate our qualitative Ô¨Åndings. In particular, we wanted to quantitatively val-
idate the developers‚Äô perception about the factors that highly-selected npm packages possess. In this analysis, we
examined 2,592 npm packages divided into highly-selected and not highly-selected packages. For each package in our
dataset, we collected quantitative data to present the factors studied in our survey. Then, we used regression analysis
to quantitatively investigate which of the studied factors are the most important.

3.1. Study Design

In this section, we described our methodology of collecting a dataset of highly-selected and not highly-selected
npm packages. We also described how we collected the studied factors, which served as the dependent variables in
our study. Finally, we presented our analysis method and steps.

3.1.1. Data Collection

To quantitatively examine the factors that make some npm packages highly-selected, we wanted to have a suÔ¨Écient
number of packages that present both highly-selected and not highly-selected packages. To do so, we resorted to study
packages from the npm ecosystem. We started by retrieving the metadata information of all the npm packages that
are published on the npm ecosystem. In particular, we wrote a crawler to interact with the npm registry and download
the package.json Ô¨Åle of every npm package [41]. It is important to note that the package.json contains all the package
information, including the names of other packages that the package depends on them. Once we have the package.json,
we started recursively analyzing the package.json Ô¨Åle of every package to extract its dependencies. After that, for each
package in the npm ecosystem, we counted the number of other packages that are listed as dependencies, i.e., the
number of dependent packages.

It is important to note that we chose to use the number of dependent packages as a proxy of highly-selected packages
from the npm ecosystem over other measurements, particularly download count, for two main reasons. First, the
npm provides only an accumulated download count over time, which does not show the current stats of the package.
Second, the download count that npm provides could include crawlers and downloads due to transitive dependencies.
Furthermore, in our process, we considered only the direct dependent packages from the npm registry and avoided
including dependent applications from open-source hosting services like GitHub. We did this since our goal is to
proxy how many times a developer went through the process of selecting a package and decided to select the subject
package. Moreover, platforms like GitHub hosts millions of applications created using predeÔ¨Åned project templates
or bootstrapping tools. For example, the tool Create React App alone bootstrapped millions public applications on
GitHub, which may not be completed. Considering such applications from GitHub will amplify the decision taken
by the creators of such tools or templates to overtake the decisions of millions of developers. In addition, we did not
consider the number of transitive dependents because it does not reÔ¨Çect how many times developers have selected a
package.

In total, we analyzed the package.json Ô¨Åle of 1,423,956 npm packages. After that, we chose to study 6,924 packages

Mujahid et al.: Preprint submitted to Elsevier

Page 8 of 17

56789101112Number of Dependents (log scale)0500100015002000CountCharacteristics of highly-selected packages

Table 4
List of factors values with their description.

Factor

Type

Description

Stars count on GitHub
Count of dependencies from package.json

Forks count on GitHub

Contributors count on GitHub

Number
Forks
Watchers
Number Watcher count on GitHub
Number
Contributors
Downloads
Number Downloads count from npm
Number
Stars
Dependencies
Number
Boolean Weather has a permissive license
License
Documentation
Size of README Ô¨Åle
Number
Boolean Whether has a test script
Test Code
Build Status
Number
Number
Vulnerabilities
Number
Badges
Boolean Weather has a website
Website
Number
Releases
Closed Issues
Number
Commit Frequency Number
Number
Usage

Frequency of releases
Count of closed issues on GitHub
Count of commits in the last year
Count of dependent repositories on GitHub

Percentage of failed jobs on last commit
Percentage of vulnerable versions
Count of badges in the README Ô¨Åle

that have more than 100 dependent packages, i.e., the number of packages that depend on the selected packages. We
decided to study npm packages that have more than 100 dependent packages for two main reasons. First, we found that
prior work indicated that npm ecosystem has many packages that are not used, e.g., toy packages (e.g., [62, 3]). Thus,
selecting packages with more than 100 direct dependent packages eliminated incompetent packages. Second, since
we wanted to examine highly-selected npm packages, we focused on packages that can potentially be used and appear
as an option for developers when searching for an npm package to use, for example, packages that are widely adopted
by other packages. Moreover, we selected this threshold after examining the distribution of the number of dependent
packages across all packages in the npm ecosystem.

Next, we sorted the selected npm packages based on their number of dependent packages. Figure 3 presents the
distribution of the number of dependent packages. We considered the top 20% based on the number of dependent
packages as highly-selected packages and the bottom 20% as not highly-selected packages. We resorted to using these
thresholds to have an essential distinction between the two samples, which element gray area between them. Also,
prior studies used a similar sampling technique [6, 32, 55]. In the end, we had 1,385 highly-selected packages and
1,385 not highly-selected packages. We used these packages in our quantitative analysis.

3.1.2. Package Usage Factors

Since we wanted to use regression analysis to understand the most important factors in determining highly-selected
packages, we collected seventeen package factors. These factors are based on the ones we studied in the qualitative
analysis. Since these factors present information that developers can observe by examining online sources about the
npm packages, we resorted to extracting these factors from four diÔ¨Äerent sources: 1) GitHub, which presents the pack-
age‚Äôs source code and other development activities such as issues and commits, 2) npm, which contains information
about npm packages that developers can examine on the npm website, 3) npms, which is the oÔ¨Écial search engine
used by the npm platform and provides metadata about the packages, and 4) Snyk, which is a service that provides
a dataset of vulnerable npm packages and their versions. Table 4 shows the factors with their names, value types,
and descriptions. In the following, we presented the detailed process of extracting the studied factors from each data
source:

GitHub: to collect the repository level factors, we used the oÔ¨Écial GraphQL API [18] to collect the number of
forks, watchers, stars, and closed issues for each npm package in our dataset. Since GraphQL API does not provide
direct access to the number of contributors and build status of each package repository, we used the GitHub REST
API [19] to count the number of contributors and the list of build status. In addition, to measure the commits frequency,
we cloned the GitHub repositories for each of the studied packages and counted the number of commits on all branches

Mujahid et al.: Preprint submitted to Elsevier

Page 9 of 17

Characteristics of highly-selected packages

that were committed in the latest year. Finally, we wrote a web crawler to collect the package usage factor from the
GitHub web interface, which presents the number of other GitHub repositories that depend on the package.

npm: from the oÔ¨Écial npm registry, we retrieved the list of releases for each package in our dataset. Then, we
calculated the release frequency factor by dividing the number of releases by the number of days. Likewise, to present
the dependencies factor, we used the registry to count the number of dependencies that a package uses in its last
version. Also, to calculate the documentations factor for each package, we considered the size of the readme Ô¨Åle. We
then measured its size in terms of the number of its characters.

Also, we used both the npm registry and GitHub GraphQL API consecutively to retrieve the name of the license that
a package declares. We then classiÔ¨Åed the licenses into three categories: 1) permissive licenses, 2) semi-permissive
licenses, and 3) restrictive licenses [53]. Finally, we retrieved the list of badges for each package using a tool called
detect-readme-badges2. Once we had the list of badges, we calculated the badges factor by counting the number of
badges used by the package.

npms: for the download factor, we used the oÔ¨Écial npm search (npms3) through its API to collect the number of
downloads. Next, we examined whether the package has test code to represent the test code factor. Additionally, we
used the npms API to determine the website factor. To do so, we extracted the website URL for each package in our
dataset. Since some packages refer to their GitHub repository as their main website, we Ô¨Ålter out those URL addresses.
Snyk: to collect the vulnerabilities factor for each package in our dataset, we wrote a web crawler to collect the list
of vulnerable releases from the Snyk web interface. Then, we divided the number of vulnerable releases by the total
number of releases for each package to calculate the vulnerabilities factor.

Table 4 shows the name, value type, and description of the factors that we used to build our logistic regression
models. Since some packages do not have values for some factors, we Ô¨Ålter out these packages from our dataset. In the
end, we were able to collect factor values for 1,332 highly-selected packages and 1,195 not highly-selected packages.

3.2. Analysis Method

To quantitatively examine the most impactful factors that determine highly-selected packages, we used logistic
regression analysis. In our study, we examined the studied 2,527 packages, which we classiÔ¨Åed into highly-selected
and not highly-selected packages. We then built a logistic regression to model the dependent variable, whether a
package is highly-selected or not highly-selected. In the following sections, we described the steps used to build the
logistic regression model.

3.2.1. Correlation Analysis

Since the interpretation of the logistic regression model can be aÔ¨Äected by the highly correlated factors [37],
we Ô¨Årst started by removing highly correlated factors in our dataset. Thus, we computed the correlation among the
independent variables using Spearman‚Äôs rank correlation coeÔ¨Écient. We used Spearman correlation because it is
resilient to non-normally distributed data, which is the case for our independent variables [30]. We considered any
pair of independent variables that have a Spearman‚Äôs coeÔ¨Écient of more than 0.8 to be highly correlated. We selected
the cutoÔ¨Ä of 0.8 Spearman since prior work suggested and used the same threshold for software engineering data
(e.g., [55, 34]). Figure 4 shows the hierarchical clustering based on the Spearman correlation among our independent
variables. From Figure 4, we observed that three factors are highly correlated, which are stars, forks, and watchers.
Finally, for these three factors, we only kept the factor that is easy to interpret, which is the number of stars. After this
analysis, we ended up having Ô¨Åfteen unique variables.

3.2.2. Redundancy Analysis

Once we removed the highly correlated factors, we also applied redundancy analysis to detect variables that do not
add information to the regression analysis [23]. Thus, we removed them so they do not aÔ¨Äect the interpretation of our
logistic regression model. In our dataset, we did not Ô¨Ånd redundant variables among the remaining Ô¨Åfteen factors.

3.2.3. Logistic Regression

To build our logistic regression model, we followed steps that have been applied in prior studies (e.g., [32]). After
identifying the factors that may impact the selection of an npm package, we used logistic regression to model the highly-
selected packages. Since prior studies showed that using logistic regression may be aÔ¨Äected by the estimated regression

2https://www.npmjs.com/package/detect-readme-badges
3https://npms.io

Mujahid et al.: Preprint submitted to Elsevier

Page 10 of 17

Characteristics of highly-selected packages

Figure 4: The hierarchical clustering shows the factors that might impact the selection of npm packages. We apply the
Spearman correlation test and use a cut-oÔ¨Ä value of 0.8, to eliminate highly correlated factors. This analysis left us with
Ô¨Åfteen factors that is used in the regression analysis.

coeÔ¨Écient [23, 32], we trained our model using several bootstrap iterations. Similar to prior work (e.g., [32]), we
created 100 rounds of bootstrap samples with a replacement for training and testing sets that ensure the testing samples
were not included in the training set and vice versa. Then, we built a logistic regression model on the created bootstrap
training samples, one for each iteration (i.e., 100 times) and test it on the testing samples. In the end, we calculated the
mean of the sample statistics out of the 100 bootstrap samples.

3.2.4. Evaluating Performance

Once we built our logistic regression model, we next wanted to examine the performance of the built model. Hence,
we used the area under the receiver operating characteristic curve (ROC-AUC), which is an evaluation measurement
known for its statistical consistency [9]. An ROC-AUC value ranges between 0 and 1, where 1 indicates perfect
prediction results, and 0 indicates completely wrong predictions. Accordingly, prior studies showed that achieving a
0.5 ROC-AUC value indicates that the model‚Äôs predictions are as good as random. However, a ROC-AUC value equal
to or more than 0.7 indicates an acceptable model performance for software engineering datasets [40, 33, 60]. In our
study, the logistic regression model achieved an ROC-AUC value of 0.74.

3.2.5. Factors Importance

To investigate which of the examined factors are the most impactful in our logistic regression modeling of highly-
selected packages, we used the Wald ùúí 2 maximum likelihood tests value of the independent factors in our model [23].
The higher the Wald ùúí 2 statistics value of an independent factor, the greater the probability that its impact is signiÔ¨Åcant.
We also generated nomogram charts to present the studied factors‚Äô importance on our logistic regression model [23,
26]. Nomograms are easily explainable charts that provide a way to explore the explanatory power of the studied
factors. Since Wald ùúí 2 test provides us with only the explanatory power, we used the nomogram to show us the exact
interpretation of how the variation in each factor inÔ¨Çuences the outcome of the regression model. Furthermore, the
Wald ùúí 2 does not indicate whether the studied factors have positive or negative roles in determining highly-selected
packages or not, while the nomogram provides such information.

Figure 5 shows the generated nomogram of the logistic regression model. The line against each factor in the Ô¨Ågure
presents the range of values for that factor. We used the points line at the top of the Ô¨Ågure to measure the volume of
each factor contribution, while the total points line at the bottom of the Ô¨Ågure presents the total points generated by all
the factors. In our analysis, the higher the number of points assigned to a factor on the x-axis (e.g., the number of stars
has 100 points), the larger its impact is on the logistic regression model.

3.3. Study Results

Table 5 shows the values of the Wald ùúí 2 and the ùëù-value for the selected Ô¨Åfteen factors that may impact the highly-
selected npm packages. Figure 5 also shows the estimated eÔ¨Äect of our factors using nomogram analysis [26]. Overall,

Mujahid et al.: Preprint submitted to Elsevier

Page 11 of 17

documentationstest_codelicenseclosed_issuedownloadsusagevulnerabilitieswebsitecontributorswatchersforksstarsreleasecommits_frequencybuild_statusdependenciesbadges1.00.80.60.40.20.0Spearman CorrelationCharacteristics of highly-selected packages

Table 5
The result of our logistic regression analysis for investigating the most important factors.

Factors

Wald ùúí 2

ùëù-value

Downloads
Stars
Closed Issue
Vulnerabilities
Badges
Documentation
Dependencies
Build Status
Test Code
Contributors
Commits Frequency
Release
License
Usage
Website

***
***
***
***
***
***
**
*
*
*

63.00
24.21
17.62
16.47
12.21
11.61
8.04
5.54
4.62
4.41
2.34
2.32
1.68
1.15
0.02

0.000
0.000
0.000
0.000
0.001
0.001
0.005
0.019
0.032
0.036
0.126
0.127
0.196
0.283
0.880

Signif. codes: 0 ‚Äò***‚Äô 0.001 ‚Äò**‚Äô 0.01 ‚Äò*‚Äô 0.05 ‚Äò.‚Äô 0.1 ‚Äò ‚Äô 1

we observed that the regression analysis complemented the main qualitative Ô¨Åndings. However, it controverted with
the importance of some factors.

From Table 5, we observed that the number of downloads has the most explanatory power with a Wald ùúí 2 value
equal to 63.00 when we modeled the probability of highly-selected npm packages. The second most important factor
in modeling highly-selected packages is the number of stars a package has (Wald ùúí 2 = 24.21). Figure 5 also shows
that npm packages that have a high number of downloads and received a high number of stars have a high chance to
be highly-selected packages.

Our regression analysis also showed that documentation and vulnerability factors have explanatory power as well.
Interestingly, developers reported these two factors in our survey to have a high impact when selecting npm packages.
With a Wald ùúí 2 value equal to 16.47, packages that have a high percentage of vulnerable versions have higher impact
power and the same apply for the size of the readme Ô¨Åles with Wald ùúí 2 = 11.61. In addition, Figure 5 conÔ¨Årms
that documentation and vulnerabilities have a positive contribution to the probability of a npm package being highly-
selected.

Interestingly, our regression analysis showed two of the studied factors that have an explanatory power when they
are used to model the probability of highly-selected npm packages, which are the number of badges that the package has
and the number of closed issues on Github. However, our survey results showed that developers tend not to consider
these factors when searching for an npm package to use. Table 5 shows that the number of closed issues is the third
most important factor with a Wald ùúí 2 value equal to 17.62 while the number of badges is placed Ô¨Åfth, having a value
of Wald ùúí 2 equal to 12.21. Furthermore, Figure 5 shows the number of badges has a positive contribution with the
probability that the package will be highly-selected packages.

In addition, our nomogram analysis shows that the number of contributors as a factor has a negative contribution
to the probability of a package being highly-selected. In contrast, the regression analysis showed that this factor has a
modest explainable power (Wald ùúí 2 = 4.41).

In summary, our quantitative analysis complemented developers‚Äô perceptions about the factors that they look for
when selecting an npm package to use. In particular, our results showed that highly-selected npm packages tend to
possess characteristics that include a high number of downloads, stars, and a higher ratio of closed issues. Lastly,
in contrast to our qualitative analysis results, our regression analysis showed that a higher number of badges is an
essential characteristic of highly-selected npm packages.

Mujahid et al.: Preprint submitted to Elsevier

Page 12 of 17

Characteristics of highly-selected packages

Figure 5: The nomogram visually presents the impact of each of the studied factors in determining highly-selected npm
packages.The logistic regression model used to generate this nomogram achieved a median ROC-AUC of 0.74 on 100
out-of-sample bootstrap iterations.

4. Discussion

Our study has many direct beneÔ¨Åts for the ecosystem maintainers and the npm community, particularly package

owners and developers who use the npm packages. We discussed these implications and beneÔ¨Åts in the following.

The npm software ecosystem maintainers should pay attention to certain aspects of the packages when build-
ing package search or recommendation tools. Several package search tools have been proposed and deployed, which
can be classiÔ¨Åed into two main categories. The Ô¨Årst category based on keyword search [1, 54, 29]. These tools are
limited since they do not take into consideration the quality aspect of the packages. Tools from the second category
provide package search while considering some quality aspects of the packages, e.g., the npms tool [11]. While npms
is the oÔ¨Écial search tool used by the oÔ¨Écial npm website, it has some limitations. The main limitation of npms is
that it assigns diÔ¨Äerent weights of the used aspects without a clear justiÔ¨Åcation, which negatively aÔ¨Äects the quality
of the search engine [5]. Our examination of npms‚Äô source code and documentation shows that npms arbitrarily gives
weights to certain aspects when ranking the packages. We recommend that the npm ecosystem could use our results
to build more robust search tools. For example, the npm maintainers can integrate our rank of the important factors to
weigh each factor‚Äôs contribution when used in a search tool, which they are based on developers‚Äô perceptions.

Several package characteristics should be carefully examined by developers when choosing an npm package
to depend on in their projects. As mentioned earlier, our results indicated that highly-selected packages possess
speciÔ¨Åc characteristics. For example, our regression analysis results showed that the number of closed issues in the
package repository is commonly related to highly-selected packages. We believe that JavaScript developers can use
our results to build systematic guidelines for choosing an npm package to use. In fact, there have been several attempts
to help developers create such a guideline [17, 57, 48]. However, their main drawback is that they focused on selecting
packages in a speciÔ¨Åc context or propose general guidelines to select open source components. In addition, they do
not consider package characteristics that npm provide, such as the number of downloads.

To promote their packages, the owner of npm packages should provide clear indications of their packages‚Äô
characteristics. Gaining more popularity within the software ecosystem requires putting more eÔ¨Äort into signalling
the published packages‚Äô quality. Overall, all the package factors that our qualitative and quantitative results highlighted
are essential factors that package owners can employ to attract more users. For example, many responses indicated
that package documentation is an important factor when looking for a package to use. Based on these Ô¨Åndings, we
recommend developers invest more eÔ¨Äort in making their package documentation, particularly readme Ô¨Åles, clearer

Mujahid et al.: Preprint submitted to Elsevier

Page 13 of 17

Points0102030405060708090100contributors3501250115015011downloads132500001360000013950000131.3e+081.6e+081.9e+082.2e+082.5e+082.8e+083.1e+08stars01000025000400005500070000850001e+05115000130000145000160000175000dependencies020406080100120140license01documentations0160003800060000build_status00.20.40.60.81vulnerabilities00.20.50.81badges0510152025303540website0test_code01release65.554.543.532.521.510.50closed_issue00.30.60.9usage0400001e+05160000220000commits_frequency040009000140001900024000Total Points050100150200250300350Linear Predictor‚àí6‚àí4‚àí2024681012Characteristics of highly-selected packages

and up to date.

5. Related Work

The increasing trend of depending on software ecosystems by developers has motivated researchers to understand

the developer‚Äôs perspective about using third-party packages.

HaeÔ¨Çiger, von Krogh and Spaeth [21] studied the reuse pattern and practices in open source applications. Their
study showed that experienced developers reuse more code than less experienced developers. Abdalkareem et al. [3, 2]
studied an emerging code reuse practice in the form of lightweight packages in the software ecosystem. Their study
was conducted to understand why developers use trivial packages. Their results showed that these packages are preva-
lent in PyPI (Python Package Index), but 70.3% of the developers considered using these packages is a bad practice.
In addition, Xu, An, Thung, Khomh and Lo [58] studied the reason behind the reusing and re-implementing of exter-
nal packages in software applications. They found that developers often replace their self-implemented methods with
external libraries because they were initially unaware of the library or it was unavailable back then. Later on, when
they became aware of a well-maintained and tested package, they replace their own code with that package. Although
developers preferred to reuse code than re-implement it, they replaced an external heavy package with their imple-
mentation when they believed that they were only using a small part of its functionalities or if it became deprecated.
Haenni, Lungu, Schwarz and Nierstrasz [22] conducted a survey with developers about their decision-making while
introducing a dependency to their applications. Surprisingly, the study found that developers generally do not apply
rationale while selecting the packages; they used any package that accomplishes the required tasks.

Other work also focused on examining the popularity growth of packages within an ecosystem. For example, Qiu
et al. [45] studied the growth of popular npm package. Their Ô¨Ånding showed that lifetime, number of dependents,
and added new functionalities play signiÔ¨Åcant roles in popularity growth. Chatzidimitriou., Papamichail., Diaman-
topoulos., Oikonomou. and Symeonidis. [10] used network analysis and information retrieval techniques to study the
dependencies that co-occur in the development of npm packages. Then, they used the constructed network to identify
the communities that have been evolved as the main drivers for npm‚Äôs exponential growth. Their Ô¨Åndings showed
that several clusters of packages can be identiÔ¨Åed. Zerouali et al. [62] examined a large number of npm packages by
extracting nine popularity metrics. They focused on understanding the relationship between the popularity metrics.
They found that the studied popularity metrics were not strongly correlated.

Other work focused on understanding the process used by developers to select packages and attempted to provide
some guidelines. Pano, Graziotin and Abrahamsson [43] focused on understanding factors that developers look for
when selecting a JavaScript framework (e.g., react). Based on interviewing 18 decision-makers, they observed a list
of factors when choosing a new JavaScript framework, including the community‚Äôs size behind the framework. del
Bianco, Lavazza, Morasca and Taibi [14] provided a list of factors that inÔ¨Çuence the trustworthiness of open source
software components. Their list had Ô¨Åve categories, including quality and economic categories. Also, in their study,
Hauge, Osterlie, Sorensen and Gerea [25] observed that many organizations apply informal selection process based on
previous experience, recommendations from experts, and information available on the Internet. Franch and Carvallo
[17] investigated to adapt the ISO quality model and assign metrics to be used as a measure for selecting software
components. Their study suggested that relationships between quality entities need to describe explicitly.

The main goal of our study is to examine the characteristics of highly-selected packages within the npm ecosystem.
In many ways, our study is complementary to prior work since we focus on understanding factors that make a package
highly-selected. That said, our study is one of the only studies to use mixed research methods, which provide us with
more complete and synergistic utilization of data than any separate quantitative and qualitative data collection and
analysis.

6. Threats to Validity

In this section, we discuss the potential threats to the validity of our work.

6.1. Internal Validity

Internal validity concerns factors that could have inÔ¨Çuenced our results. To qualitatively understand the factors
that may impact the use of an npm package, we surveyed JavaScript developers. While we carefully designed our
survey based on the guideline provided in [15], our survey might have been inÔ¨Çuenced by some factors. First, our

Mujahid et al.: Preprint submitted to Elsevier

Page 14 of 17

Characteristics of highly-selected packages

survey participants might poorly understand some of the factor statements. To mitigate this limitation, we conducted
a pilot survey where we gave our survey to three expert JavaScript developers and incorporated their feedback about
the survey. Second, we had a list of well-deÔ¨Åned factors that may impact selecting an npm package. Even though
we choose to study these factors since they are used in the literature and can be easily examined by developers, we
may miss some other factors. To mitigate this threat, in our survey, we had one open-ended question, where we asked
developers to provide us with any factors that are missed in our survey [15]. That said, none of our survey responses
reported any new factors that can be quantitative.

To recruit participants in our survey, we resorted to developers who publish and use packages from the npm ecosys-
tem. At the beginning of the survey, we articulated that the purpose of our study is to understand how developers select
npm packages. This description may attract more attention from developers, who use npm packages more.

6.2. Construct Validity

Construct validity considers the relationship between theory and observation in case the measured variables do
not measure the actual factors. In our study on the npm ecosystem, we used npms platform [11] to measure various
quantitative factors related to download counts, testing, and having a website. Our measurements are only as accurate
as npms; however, given that npms is the main search tool for npm, we are conÔ¨Ådent in the npms metrics. We also
used Snyk [51] to calculate the number of vulnerabilities that aÔ¨Äect the studied packages. Thus, our analyses are
as accurate as Snyk dataset. That said, we resorted to using the Snyk data since it has been used by other prior
work (e.g., [35, 61]). In addition, we wrote a crawler to extract factors from the Github platform through the use of
Github API, so our collected data might be aÔ¨Äected by the accuracy of this public API. Furthermore, In our study,
we investigated package factors that can be observed in a mechanical way (e.g., examine the Github repository of
the package). However, developers might select npm packages based on a discussion or recommendation by other
developers. Thus, our studied factors may not present the whole picture.

6.3. External Validity

Threats to external validity concern the generalization of our Ô¨Åndings. In our study, we investigated the factor that
impacts highly-selected packages that are published on the npm ecosystem. Our results might not be generalized to
other software ecosystems, such as maven for Java or PyPi for Python. However, since npm ecosystem is the most
popular software ecosystem, this gave us conÔ¨Ådence in our results. Also, scientiÔ¨Åc literature showed that studying
individual cases has signiÔ¨Åcantly increased our knowledge in areas such as economics, social sciences, and software
engineering [16]. Second, our dataset that was used in the quantitative analysis presents only open-source packages
hosted on GitHub that do not reÔ¨Çect proprietary packages or packages that are hosted on other platforms such as
GitLab and BitBucket. Furthermore, we surveyed 118 JavaScript developers, so we do not claim that our results are
generalized to other developers who do not know JavaScript or the npm software ecosystem.

Finally, one criticism of empirical studies results is ‚ÄúI know it all along‚Äù thought or nothing new is learned. How-
ever, such common knowledge has rarely been shown to be trusted and is often quoted without scientiÔ¨Åc and research
evidence. Our paper provides such evidence and supports common knowledge (e.g., ‚Äúpackages with good documen-
tations tend to be highly-selected packages‚Äù) while some are challenged (e.g., ‚Äúdevelopers do not consider the number
of badges when selecting a new package to use.‚Äù).

7. Conclusion

In this work, we used a mixed qualitative and quantitative approach to investigate the characteristic of highly-
selected npm packages. We started by identifying seventeen packages selection factors based on our literature review
and used by existing online package search tools. Then, we qualitatively investigated the factors developers look for
when choosing an npm package by surveying 118 JavaScript developers. Second, we quantitatively examined these
factors by building a logistic regression model using a dataset of 2,527 npm packages divided into highly-selected and
not highly-selected packages.

Among our main Ô¨Åndings, we highlighted that JavaScript developers believe that highly-selected packages are well-
document, receive a high number of stars on GitHub, have a large number of downloads, and do not suÔ¨Äer from secu-
rity vulnerabilities. Moreover, our regression analysis complemented what developers believe about highly-selected
packages and showed the divergences between the developers‚Äô perceptions and the characteristics of highly-selected
packages.

Mujahid et al.: Preprint submitted to Elsevier

Page 15 of 17

Characteristics of highly-selected packages

8. Acknowledgments

The authors would like to thank all the developers and managers who provided their valuable feedback during the

survey.

References
[1] , 2017a. npm. https://www.npmjs.com/. (Accessed on 11/24/2017).
[2] Abdalkareem, R., 2017. Reasons and drawbacks of using trivial npm packages: the developers‚Äô perspective, in: Proceedings of the 2017 11th

joint meeting on foundations of software engineering, pp. 1062‚Äì1064.

[3] Abdalkareem, R., Nourry, O., Wehaibi, S., Mujahid, S., Shihab, E., 2017. Why do developers use trivial packages? an empirical case study
on npm, in: Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering, Association for Computing Machinery. p.
385‚Äì395.

[4] Abdalkareem, R., Oda, V., Mujahid, S., Shihab, E., 2020. On the impact of using trivial packages: an empirical case study on npm and PyPI.

Empirical Software Engineering 25, 1573‚Äì7616.

[5] Abdellatif, A., Zeng, Y., Elshafei, M., Shihab, E., Shang, W., 2020. Simplifying the search of npm packages. Information and Software

Technology 126, 106365.

[6] Bavota, G., Linares-V√°squez, M., Bernal-C√°rdenas, C.E., Penta, M.D., Oliveto, R., Poshyvanyk, D., 2015. The impact of API change- and

fault-proneness on the user ratings of android apps. IEEE Transactions on Software Engineering 41, 384‚Äì407.

[7] Begel, A., Bosch, J., Storey, M., 2013. Social networking meets software development: Perspectives from GitHub, MSDN, Stack Exchange,

and TopCoder. IEEE Software 30, 52‚Äì66.

[8] Borges, H., Valente, M.T., 2018. What‚Äôs in a GitHub star? understanding repository starring practices in a social coding platform. Journal of

Systems and Software 146, 112 ‚Äì 129.

[9] Bradley, A.P., 1997. The use of the area under the roc curve in the evaluation of machine learning algorithms. Pattern recognition 30,

1145‚Äì1159.

[10] Chatzidimitriou., K.C., Papamichail., M.D., Diamantopoulos., T., Oikonomou., N., Symeonidis., A.L., 2019. npm packages as ingredients:
A recipe-based approach, in: Proceedings of the 14th International Conference on Software Technologies - Volume 1: ICSOFT,, INSTICC.
SciTePress. pp. 544‚Äì551.

[11] Cruz, A., Duarte, A., 2018. npms. https://npms.io/about. (Accessed on 01/30/2021).
[12] Dabbish, L., Stuart, C., Tsay, J., Herbsleb, J., 2012. Social coding in GitHub: Transparency and collaboration in an open software repository,

in: Proceedings of the ACM 2012 Conference on Computer Supported Cooperative Work, ACM. pp. 1277‚Äì1286.

[13] DeBill, E., 2022. Modulecounts. http://www.modulecounts.com/. (Accessed on 01/25/2022).
[14] del Bianco, V., Lavazza, L., Morasca, S., Taibi, D., 2011. A survey on open source software trustworthiness. IEEE Software 28, 67‚Äì75.
[15] Dillman, D.A., 2011. Mail and Internet surveys: The tailored design method‚Äì2007 Update with new Internet, visual, and mixed-mode guide.

John Wiley & Sons.

[16] Flyvbjerg, B., 2006. Five misunderstandings about case-study research. Qualitative inquiry 12, 219‚Äì245.
[17] Franch, X., Carvallo, J.P., 2003. Using quality models in software package selection. IEEE software 20, 34‚Äì41.
[18] GitHub, 2021a. GitHub GraphQL API - GitHub docs. https://docs.github.com/en/graphql. (accessed on 01/27/2022).
[19] GitHub, 2021b. GitHub REST API - GitHub docs. https://docs.github.com/en/rest. (accessed on 01/27/2022).
[20] Gousios, G., Pinzger, M., Deursen, A.v., 2014. An exploratory study of the pull-based software development model, in: Proceedings of the

36th International Conference on Software Engineering, p. 345‚Äì355.

[21] HaeÔ¨Çiger, S., von Krogh, G., Spaeth, S., 2008. Code reuse in open source software. Manage. Sci. 54, 180‚Äì193.
[22] Haenni, N., Lungu, M., Schwarz, N., Nierstrasz, O., 2013. Categorizing developer information needs in software ecosystems, in: Proceedings

of the 2013 International Workshop on Ecosystem Architectures, ACM. pp. 1‚Äì5.

[23] Harrell Jr, F.E., 2015. Regression modeling strategies: with applications to linear models, logistic and ordinal regression, and survival analysis.

Springer.

[24] Hata, H., Todo, T., Onoue, S., Matsumoto, K., 2015. Characteristics of sustainable oss projects: A theoretical and empirical study, in: 2015

IEEE/ACM 8th International Workshop on Cooperative and Human Aspects of Software Engineering, IEEE. pp. 15‚Äì21.

[25] Hauge, O., Osterlie, T., Sorensen, C., Gerea, M., 2009. An empirical study on selection of open source software - preliminary results, in: 2009

ICSE Workshop on Emerging Trends in Free/Libre/Open Source Software Research and Development, IEEE. pp. 42‚Äì47.

[26] Iasonos, A., Schrag, D., Raj, G.V., Panageas, K.S., 2008. How to build and interpret a nomogram for cancer prognosis. Journal of clinical

oncology 26, 1364‚Äì1370.

[27] Jadhav, A.S., Sonar, R.M., 2009. Evaluating and selecting software packages: A review. Information and Software Technology 51, 555‚Äì563.
[28] John, W., Creswell, P.C., CLARK, V., 2000. Designing and conducting mixed methods research, SAG.
[29] Kashcha, A., 2017. npm packages sorted by pagerank. http://anvaka.github.io/npmrank/online/. (Accessed on 11/24/2017).
[30] Kendall, M.G., 1938. A new measure of rank correlation. Biometrika 30, 81‚Äì93.
[31] Larios Vargas, E., Aniche, M., Treude, C., Bruntink, M., Gousios, G., 2020. Selecting Third-Party Libraries: The Practitioners‚Äô Perspective.

ACM. p. 245‚Äì256.

[32] Lee, D., Rajbahadur, G.K., Lin, D., Sayagh, M., Bezemer, C.P., Hassan, A.E., 2020. An empirical study of the characteristics of popular

minecraft mods. Empirical Software Engineering 25, 3396‚Äì3429.

[33] Lessmann, S., Baesens, B., Mues, C., Pietsch, S., 2008. Benchmarking classiÔ¨Åcation models for software defect prediction: A proposed

framework and novel Ô¨Åndings. IEEE Transactions on Software Engineering 34, 485‚Äì496.

Mujahid et al.: Preprint submitted to Elsevier

Page 16 of 17

Characteristics of highly-selected packages

[34] Li, H., Shang, W., Zou, Y., Hassan, A.E., 2017. Towards just-in-time suggestions for log changes. Empirical Software Engineering 22,

1831‚Äì1865.

[35] Mahmoud Alfadel, Diego Elias Costa, E.S., 2021. Empirical analysis of security vulnerabilities in Python packages, in: Proceedings of the

IEEE International Conference on Software Analysis, Evolution and Reengineering (to appear).

[36] Meloca, R., Pinto, G., Baiser, L., Mattos, M., Polato, I., Wiese, I.S., German, D.M., 2018. Understanding the usage, impact, and adoption of
non-osi approved licenses, in: Proceedings of the 15th International Conference on Mining Software Repositories, Association for Computing
Machinery. pp. 270‚Äì280.

[37] Midi, H., Sarkar, S.K., Rana, S., 2010. Collinearity diagnostics of binary logistic regression model. Journal of Interdisciplinary Mathematics

13, 253‚Äì267.

[38] de la Mora, F.L., Nadi, S., 2018. An empirical study of metric-based comparisons of software libraries, in: Proceedings of the 14th International
Conference on Predictive Models and Data Analytics in Software Engineering, Association for Computing Machinery, New York, NY, USA.
p. 22‚Äì31.

[39] Mujahid, S., Costa, D.E., Abdalkareem, R., Shihab, E., Saied, M.A., Adams, B., 2021. Toward using package centrality trend to identify

packages in decline. IEEE Transactions on Engineering Management , 1‚Äì15doi:10.1109/TEM.2021.3122012.

[40] Nam, J., Kim, S., 2015. Clami: Defect prediction on unlabeled datasets (t), in: 2015 30th IEEE/ACM International Conference on Automated

Software Engineering (ASE), IEEE. pp. 452‚Äì463.

[41] npm, 2017b. registry | npm docs. https://docs.npmjs.com/cli/v6/using-npm/registry. (accessed on 12/24/2020).
[42] Oppenheim, A.N., 1992. Questionnaire Design, Interviewing and Attitude Measurement. Pinter Publishers.
[43] Pano, A., Graziotin, D., Abrahamsson, P., 2018. Factors and actors leading to the adoption of a JavaScript framework. Empirical Software

Engineering 23, 3503‚Äì3534.

[44] Qiu, H.S., Li, Y.L., Padala, S., Sarma, A., Vasilescu, B., 2019. The signals that potential contributors look for when choosing open-source

projects, in: ACM Conference on Computer-Supported Cooperative Work and Social Computing, ACM.

[45] Qiu, S., Kula, R.G., Inoue, K., 2018. Understanding popularity growth of packages in JavaScript package ecosystem, in: 2018 IEEE Interna-

tional Conference on Big Data, Cloud Computing, Data Science & Engineering (BCD), IEEE. pp. 55‚Äì60.

[46] Rea, L.M., Parker, R.A., 2014. Designing and conducting survey research: A comprehensive guide. John Wiley & Sons.
[47] Seaman, C.B., 1999. Qualitative methods in empirical studies of software engineering.

IEEE Transactions on software engineering 25,

557‚Äì572.

[48] Semeteys, R., 2008. Method for qualiÔ¨Åcation and selection of open source software. Open Source Business Resource .
[49] Sheoran, J., Blincoe, K., Kalliamvakou, E., Damian, D., Ell, J., 2014. Understanding "watchers" on GitHub, in: Proceedings of the 11th

Working Conference on Mining Software Repositories, ACM. pp. 336‚Äì339.

[50] Smith, E., Loftin, R., Murphy-Hill, E., Bird, C., Zimmermann, T., 2013. Improving Developer Participation Rates in Surveys, in: 2013 6th

International Workshop on Cooperative and Human Aspects of Software Engineering (CHASE), IEEE. pp. 89‚Äì92.
[51] Snyk, 2021. Snyk | developer security | develop fast. stay secure. https://snyk.io/. (accessed on 01/31/2022).
[52] StackOverÔ¨Çow, 2017. node.js - how to Ô¨Ånd search/Ô¨Ånd npm packages - stack overÔ¨Çow. https://stackoverflow.com/questions/

10568512/how-to-find-search-find-npm-packages. (Accessed on 11/24/2017).

[53] Team, S.E., 2019.

Top open source licenses and legal risk.

https://www.synopsys.com/blogs/software-security/

top-open-source-licenses/. (accessed on 12/20/2020).

[54] Temple, C., 2017. npm discover ¬∑ see what everyone else is using. http://www.npmdiscover.com/. (Accessed on 11/24/2017).
[55] Tian, Y., Nagappan, M., Lo, D., Hassan, A.E., 2015. What are the characteristics of high-rated apps? a case study on free android applications,

in: 2015 IEEE International Conference on Software Maintenance and Evolution (ICSME), pp. 301‚Äì310.

[56] Trockman, A., Zhou, S., K√§stner, C., Vasilescu, B., 2018. Adding sparkle to social coding: an empirical study of repository badges in the npm

ecosystem, in: Proceedings of the 40th International Conference on Software Engineering, ACM. pp. 511‚Äì522.

[57] Wasike, S.N., 2010. Selection process of open source software component.
[58] Xu, B., An, L., Thung, F., Khomh, F., Lo, D., 2019. Why reinventing the wheels? an empirical study on library reuse and re-implementation.

Empirical Software Engineering .

[59] Yamashita, K., Kamei, Y., McIntosh, S., Hassan, A.E., Ubayashi, N., 2016. Magnet or sticky? measuring project characteristics from the

perspective of developer attraction and retention. Journal of Information Processing 24, 339‚Äì348.

[60] Yan, M., Xia, X., Shihab, E., Lo, D., Yin, J., Yang, X., 2019. Automating change-level self-admitted technical debt determination. IEEE

Transactions on Software Engineering 45, 1211‚Äì1229.

[61] Zapata, R.E., Kula, R.G., Chinthanet, B., Ishio, T., Matsumoto, K., Ihara, A., 2018. Towards smoother library migrations: A look at vulnerable
dependency migrations at function level for npm JavaScript packages, in: 2018 IEEE International Conference on Software Maintenance and
Evolution (ICSME), IEEE. pp. 559‚Äì563.

[62] Zerouali, A., Mens, T., Robles, G., Gonzalez-Barahona, J.M., 2019. On the diversity of software package popularity metrics: An empirical
study of npm, in: 2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER), IEEE. pp. 589‚Äì593.
[63] Zheng, W., Zhang, Q., Lyu, M., 2011. Cross-library API recommendation using web search engines, in: Proceedings of the 19th ACM

SIGSOFT symposium and the 13th European conference on Foundations of software engineering, ACM. pp. 480‚Äì483.

Mujahid et al.: Preprint submitted to Elsevier

Page 17 of 17

