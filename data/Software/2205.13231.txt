2
2
0
2

y
a
M
6
2

]
E
S
.
s
c
[

1
v
1
3
2
3
1
.
5
0
2
2
:
v
i
X
r
a

Giving Back: Contributions Congruent to Library
Dependency Changes in a Software Ecosystem

Supatsara Wattanakriengkrai, Dong Wang, Raula Gaikovina Kula, Christoph Treude,
Patanamon Thongtanunam, Takashi Ishio, and Kenichi Matsumoto

1

Abstract—Popular adoption of third-party libraries for contemporary software development has led to the creation of large
inter-dependency networks, where sustainability issues of a single library can have widespread network effects. Maintainers of these
libraries are often overworked, relying on the contributions of volunteers to sustain these libraries. In this work, we measure
contributions that are aligned with dependency changes, to understand where they come from (i.e., non-maintainer, client maintainer,
library maintainer, and library and client maintainer), analyze whether they contribute to library dormancy (i.e., a lack of activity), and
investigate the similarities between these contributions and developers’ typical contributions. Hence, we leverage socio-technical
techniques to measure the dependency-contribution congruence (DC congruence), i.e., the degree to which contributions align with
dependencies. We conduct a large-scale empirical study to measure the DC congruence for the NPM ecosystem using 1.7 million
issues, 970 thousand pull requests (PR), and over 5.3 million commits belonging to 107,242 NPM packages. At the ecosystem level,
we pinpoint in time peaks of congruence with dependency changes (i.e., 16% DC congruence score). Surprisingly, these contributions
came from the ecosystem itself (i.e., non-maintainers of either client and library). At the project level, we ﬁnd that DC
congruence shares a statistically signiﬁcant relationship with the likelihood of a package becoming dormant. Finally, by comparing
source code of contributions, we ﬁnd that congruent contributions are statistically different to typical contributions. Our work has
implications to encourage and sustain contributions, especially to support library maintainers that require dependency changes.

Index Terms—Software Ecosystem, Dependency Changes, NPM ecosystem

(cid:70)

1 INTRODUCTION

The adoption of third-party libraries for contemporary soft-
ware development has led to the emergence of massive
library platforms (i.e., package ecosystems) such as NPM
for JavaScript1 which is reported to be relied upon by
more than 11 million developers worldwide, and contains
more than one million packages [1]. Other examples in-
clude the 427,286 Maven libraries for Java Virtual Machine
languages,2 and the 324,779 PyPI packages for the Python
community,3 to name a few. These package ecosystems
comprise of a complex inter-connected network of depen-
dencies, where developers adopt many other packages for
their work. As an example, NPM packages directly depend
on between 5 to 6 other packages in the ecosystem on
average [35], [61].

The reliance on other packages in often brittle depen-
dency chains [32] implies that local sustainability issues
around individual packages can have widespread network
effects [55]. Contributors and maintainers of these pack-
ages are often overworked volunteers, who can decide to

•

S. Wattanakriengkrai, R. Kula, T. Ishio, and K. Matsumoto are with Nara
Institute of Science and Technology, Japan.
E-mail: {wattanakri.supatsara.ws3, raula, ishio, matumoto}@is.naist.jp.

• D. Wang is with Kyushu University, Japan.

E-mail: wang.dong.vt8@is.naist.jp.

• C. Treude and P. Thongtanunam are with the University of Melbourne,

Australia.
E-mail: {christoph.treude, patanamon.t}@unimelb.edu.au.

1. https://www.npmjs.com/
2. https://search.maven.org/stats
3. https://pypi.org/

stop contributing at any time [46]. Sustained contributions
are crucial to be able to respond to breaking changes
from elsewhere in the ecosystem or apply critical security
patches [64]. In response to recent attacks on open source
libraries,4 Google has deployed an ”Open Source Mainte-
nance Crew”, tasked to assist upstream maintainers of criti-
cal open-source libraries that are used by major technology
vendors, including Microsoft, Google, IBM and Amazon
Web Services. Yet, the extent, origins and motivations be-
hind these contributions are unclear.

To gain intuition about the motivations of contributors,
we ﬁrst contacted a few Node.js developers to ask why they
contribute to other NPM packages, i.e., packages which they do not
own? Most of them responded that they contributed because
their code depends on those packages, e.g., “I rely on them
[other packages] or want to rely on them and need to add/ﬁx
something in order to do so.” and “When they’re broken and need
ﬁxing (and it’s blocking my work), that’s usually when I jump in.”
One developer also noted that the ultimate goal of making
contributions is to support the entire ecosystem: “In my
experience with the Open Source world, the line between making
contributions to my own projects or to other’s becomes diffuse.
Everybody is looking for the same: making better systems.” These
responses motivated us to hypothesize that contributions
congruent with dependency changes at the project level,
could be aligned and detected at ecosystem level. In other
words, we hypothesize that contributions and dependency
changes are aligned in a package ecosystem.

4. Article

at

https://www.zdnet.com/article/

google-here-comes-our-open-source-maintenance-crew/

 
 
 
 
 
 
Hence, in this work, we set out to investigate how
developer contributions align with package dependencies
in an ecosystem. To measure this alignment, we adopt the
concept of socio-technical congruence which measures the
alignment between task dependencies among people and
coordination activities. Borrowing this concept, we measure
the dependency-contribution (DC) congruence, i.e., the de-
gree to which the contributions align with dependencies.
Through the case of the NPM ecosystem, we conduct a large
scale empirical study to examine the DC congruence and
the package dormancy using over 5.3 million commits,
1.7 million issues, and 970 thousands pull requests (PRs)
belonging to 107,242 packages. We formulate the following
research questions.
• (RQ1) How do developer contributions align with their depen-
dencies? Motivation: The motivation for the ﬁrst research
question is to examine the extent of the alignment at the
ecosystem level, and conﬁrm our hypothesis. We focus
on the following sub-questions: RQ1a. To what degree do
developer contributions align with dependencies? and RQ1b.
How do different contribution types and dependency changes
contribute to DC congruence? Results: The alignment between
developer contributions and dependency changes varies
over time, with the highest values generally observed in
earlier stages of the NPM ecosystem. The peaks we identify
in the data correspond to a DC congruence of 0.16, i.e., 16%
of the dependency changes receive aligned contributions.
These contributions are most aligned with downgrading a
dependency, and mainly come from developers that are not
maintainers of both the client and library.
• (RQ2) What is the relationship between the DC congruence and
the likelihood of packages becoming dormant? Motivation: Since
package sustainability heavily relies on contributions [47],
we would like to investigate the association between the
DC congruence and the package dormancy.

Results: Our survival analysis shows that the various
types of DC congruence share an inverse relationship with
the likelihood that a package becomes dormant, i.e., the
lower the DC congruence, the more likely the package be-
comes dormant. For instance, packages that received more
congruent contributions (i.e., issues) from non-maintainers
are less likely to become dormant.
• (RQ3) Do the contributions differ depending on their align-
ment with dependencies? Motivation: In addition to measuring
DC congruence (RQ1 and RQ2), since developers may be
motivated to submit aligned contributions based on their
dependencies, for RQ3, we would like to conﬁrm the ex-
tent to which these contributions differ from their typical
contributions. Hence, we conduct a deeper investigation
on the similarity of contributions given different types of
contributions identiﬁed in the ﬁrst two research questions.

Results: Comparing contribution similarity in terms of
source code and ﬁle paths, we ﬁnd statistical differences in
source code content of aligned contributions submitted to
dependencies when compared to those that are not aligned.
In other words, these congruent contributions are not the
typical source code submitted by that contributor.

We provide an online appendix, containing datasets and
source code related to (a) the ecosystem-level and package-
level DC congruence results, (b) the metric data for our sur-
vival model analysis, and (c) the ﬁle path and source code

Npkg.i

2

c

c

Ndev.x

Npkg.k

Npkg.j

(a) Nodes and edges from time period Oct 1 to Dec 31, 2015

Ndev.x

Ndev.y

c

c

c

Npkg.i

s

Npkg.k

Npkg.j

(b) Node and Edges from time period Jan 1 to Mar 31, 2016

Npkg.i

cli&lib-maintain

cli-maintain

Npkg.k

Npkg.j

(c) Removing the developer nodes, we transform Fig. 1b to
create the contribution relationships between packages from
time period Jan 1 to Mar 31, 2016

Figure 1: Example graph representation of the relationships
between contributions and dependencies

similarities between contribution types, which is available
at https://doi.org/10.5281/zenodo.5677371.

2 DEPENDENCIES AND CONTRIBUTIONS
In this section, we describe how we measure the DC con-
gruence, i.e., the degree to which contributions align with
dependencies as a graph. The graph is temporal, i.e., it is
constructed based on a time period.

2.1 A Dependency-Contribution Graph

Figure 1 shows a visual example to illustrate a Dependency-
Contribution graph (DC graph) that captures the relation-
ship between contributions and dependencies in the ecosys-
tem. Let G = (N, E) be a directed graph where N represents
a set of nodes and E represents a set of edges. N has two
types of nodes (i.e., Ndev and Npkg), where Ndev refers to a
developer, while Npkg refers to a software package. Ndev has
an attribute <userid> where userid is the unique identiﬁer
of the developer. Npkg has the attributes <name, time>
where name is the unique name of the package and time
is when the package was ﬁrst created.

Table 1: Classiﬁcation of contributions by maintainer role to both client and library packages.

3

Contribution Type Description

cli&lib-maintain

Contributions from a developer who commits to both client and library packages.

cli-maintain

Contributions from a developer who commits to a client and submits to a library.

lib-maintain

Contributions from a developer who submits to a client and commits to a library.

non-maintain

Contributions from a developer who submits to both client and library packages.

Algorithm

Ec−c = {Npkg.c → Npkg.l ∈ Et1−t2 |
c
c
∃Ndev.d. Ndev.d
=⇒ Npkg.l}
=⇒ Npkg.c ∧ Ndev.d
Ec−s = {Npkg.c → Npkg.l ∈ Et1−t2 |
s
c
=⇒ Npkg.l}
=⇒ Npkg.c ∧ Ndev.d
∃Ndev.d. Ndev.d
Es−c = {Npkg.c → Npkg.l ∈ Et1−t2 |
c
s
=⇒ Npkg.l}
=⇒ Npkg.c ∧ Ndev.d
∃Ndev.d. Ndev.d
Es−c = {Npkg.c → Npkg.l ∈ Et1−t2 |
s
s
=⇒ Npkg.l}
=⇒ Npkg.c ∧ Ndev.d
∃Ndev.d. Ndev.d

The edges (E) represent the relationships between nodes
in terms of contributions and dependencies. Hence, we
deﬁne two edge types in our graph,
i.e., package de-
pendencies and contributions to packages (see details in
Sections 2.2 and 2.3). The graph edges have a temporal
attribute which provides information when the dependency
(or contribution) event occurs. Since the contribution and
dependency relationships are dynamic (i.e., changing over
time), we capture and analyze these relationships based on
a speciﬁc period of time. Hence, we deﬁned a temporal
graph Gt1−t2 where t1 and t2 are between two time points
which we capture the contribution and dependency rela-
tionships. The temporal graph Gt1−t2 is formally deﬁned
as: Gt1−t2 = (Nt1−t2, Et1−t2) where Nt1−t2 is a set of
package and developer nodes that have relationships with
others within a period of t1 until t2, and Et1−t2 is a set of
edges where the contributions or dependency events (e.g., a
dependency change) between the packages in Nt1−t2 occur
during the period of t1 until t2. It is important to note that
for any time-period (i.e., t1 to t2), a package node must be
created before t1. This means that any package created in
one time period will only be considered in the next time
period.

illustrative

1 provides

time periods

examples of
(i.e., GOct2015−Dec2015

two
Figure
subsequent
and
GJan2016−M ar2016). Speciﬁcally, GOct2015−Dec2015 captures
the relationships between nodes in the time period of 1
October until 31 December 2015 which shows that only a
developer Ndev.x contributed to package Npkg.i and Npkg.j,
note that Npkg.i depends on Npkg.j and Npkg.k, and Npkg.j
depends on Npkg.k as shown by the edges in the graph.
Then in, GJan2016−M ar2016, developer Ndev.x contributed to
packages Npkg.i and Npkg.k, and another developer Ndev.y
contributed to Npkg.i and Npkg.j.

2.2 Graph Edges: Package Dependencies
Deﬁnition 2.2.1 (Edge: Npkg → Npkg). The ﬁrst edge type
represents dependency relationships between two packages.
For example, Npkg.i → Npkg.j means that a package Npkg.i
uses (i.e., depends on) a package Npkg.j, where Npkg.i is a
client to the Npkg.j library.

Edge Attributes: Dependency changes. The depen-
dency edge has the attributes <change, time> which is the
current change of the dependency relationship. We capture
the edge dependency change within a time period (between
t1 − t2). It is important to note that the edge of dependency
change that occurs in a time period will be kept in the
subsequent time periods until a new dependency event

occurs. In other words, the latest dependency change is
carried over into the next time period. We categorize the
dependency change into four types : (i) is-added, i.e., a
dependency has been added to a package, (ii) is-removed,
i.e., the dependency has been removed from a package, (iii)
is-upgraded, i.e., a dependency version has a been changed
to a more recent version of a library, and (iv) is-downgraded,
i.e., a dependency version has been changed to an older
version of a library.

2.3 Graph Edges: Contributions to Package
Deﬁnition 2.3.1 (Edge: Ndev =⇒ Npkg). The second edge
type represents the contribution relationship between a
developer and a package. For example, Ndev.x =⇒ Npkg.i
means that a developer Ndev.x contributes to a package
Npkg.i.

Edge Attributes: Developer roles. The contribution edge
has two attributes <role, time> where the time is when the
contribution was made. The role refers to the access levels of
the developer to the package when making a contribution.
There are two developer roles: a committer(c), who has
the ability to merge any submitted contributions, and a
submitter(s), who can only submit contributions to a
package but does not have the permission to merge the
contribution.

We now deﬁne four types of contributions between
packages. When capturing these contribution relationships
between packages, as a minimum, we capture developers
who made at least two contributions to the two different
packages that have a dependency relationship between
them. Formally, given a dependency relationship between
the client and library packages, we deﬁne the types of
contribution (see Table 1) as follow: (i) cli&lib-maintain,
i.e., contributions from a developer who is a committer
to both client and library packages, (ii) cli-maintain, i.e.,
contributions from a developer who is a committer to a
client that submits to a library, (iii) lib-maintain, i.e., contri-
butions from a developer who is a submitter to a client that
commits to a library, (iv) non-maintain, i.e., contributions
from a developer who is a submitter to both client and
library packages. Therefore, the DC graph in Figure 1b can
be transformed to the contribution graph in Figure 1c, where
Ndev.y commits to Npkg.i and Ndev.y submits to Npkg.j,
making these contributions a cli-maintain type.

2.4 Congruence Calculation

To measure the DC congruence, we use the adjacency matrix
to capture the contribution and dependency relationships in

a temporal graph Gt1−t2.

Matrix Construction. Based on the contribution and
dependency edges, we calculate the congruence at two
levels: 1) ecosystem level and 2) package level. Speciﬁcally,
we construct a contribution matrix (CE) and a dependency
matrix (CD). We then measure the congruence between
the contributions and dependencies based on the deﬁnition
of socio-technical congruence by Cataldo et al. [7] and
Wagstrom et al. [56]. Brieﬂy stated, they deﬁned socio-
technical congruence as the match between the coordination
requirements established by the dependencies among tasks
and the actual coordination activities performed by the
developers. We provide a formal deﬁnition for each matrix
and congruence calculation as shown below.

Deﬁnition 2.4.1 (CD adjacency matrix). The dependency
matrix (CD) of a Gt1−t2 captures the relationships between
packages in Nt1−t2 based on the dependency changes in
Et1−t2. The CD matrix has a size of |Nt1−t2| × |Nt1−t2|
where its elements indicate whether there is a dependency
relationship between the two packages or not. In other
words, CD[i, j] = 1 if there exists an edge Npkg.i →
Npkg.j ∈ Et1−t2, otherwise 0. For example, the graph
GJan2016−M ar2016 in Figure 1b has three dependency re-
lationships, i.e., Npkg.i → Npkg.j, Npkg.i → Npkg.k, and
Npkg.j → Npkg.k. Hence, the dependency matrix CD of
GJan2016−M ar2016 can be constructed as:

(cid:34)

Npkg.i
Npkg.j
Npkg.k

Npkg.i Npkg.j Npkg.k
1
0
0

0
0
0

1
1
0

(cid:35)

Furthermore, we calculate the CD adjacency matrix for
each type of dependency change (as described in Section
2.2), resulting in a total of four matrices.

Deﬁnition 2.4.2 (CE adjacency matrix). The contribution
matrix (CE) of a Gt1−t2 captures the relationship between
packages in Nt1−t2 based on the contributions of the as-
sociated developers in Et1−t2. The CE matrix has a size
of |Nt1−t2| x |Nt1−t2| where its elements indicate whether
there are contributions between two packages or not. In
other words, CE[i, j] = 1 if there exists an edge between
any two packages for any developer contribution, otherwise
0. Note that to create the contribution matrix, we use the
contribution graph (like in Figure 1c) which is transformed
from the DC graph (like Figure 1b) based on the developer
roles and dependency relationships. For example, the con-
tribution matrix CE for the cli-maintain contribution of the
graph GJan2016−M ar2016 in Figure 1c can be constructed as:





Npkg.i
Npkg.j
Npkg.k

Npkg.i Npkg.j Npkg.k
1
0
0

0
0
0

0
0
0





where there is a committer (Ndev.y) of a client package
(Npkg.i) contributing to a library package (Npkg.j). We cal-
culate the CE adjacency matrix for each type of contribution
(as described in Section 2.3), resulting in a total of four
matrices.

Deﬁnition 2.4.3 (Ecosystem-level DC Congruence). To mea-
sure the alignment between contributions and dependencies

of packages at the ecosystem level, we adapt the deﬁnition
of socio-technical congruence by Cataldo [7] as follows:

EcosystemC(Gt1−t2) =

Σ(CD ∧ CE)
ΣCD

(1)

4

In sum, Ecosystem-level DC Congruence is the ratio of de-
pendencies that receive aligned contributions divided by the
total number of dependencies in the ecosystem. For exam-
ple, given GJan2016−M ar2016 in Figure 1b and all the depen-
dency relationships in the graph have a type of “is.added”,
we want to calculate the DC congruence between depen-
dencies of is.added and cli-maintain contributions. Hence,
Σ(CD ∧ CE) = 1 as there is a cli-maintain contribution rela-
tionship that matches with the dependency relationship (i.e.,
Npkg.i → Npkg.j) between the DC graph (in Figure 1b) and
the contribution graph (in Figure 1c). Finally, the DC congru-
ence at the ecosystem level of the graph GJan2016−M ar2016
is EcosystemC(GJan2016−M ar2016) = 1

3 = 0.333.

DC Congruence Values. For each time period, we con-
struct the matrices (CD and CE) for each dependency
change (cf. Table 1) and the four contribution types (i.e.,
cli&lib-maintain, cli-maintain,
lib-maintain, and cli&lib-
maintain contributions). Hence, for each time period, we
calculate a total of 16 values of DC congruence (four CD
matrices multiplied by four CE matrices).

Deﬁnition 2.4.4 (Package-level DC Congruence). To quan-
tify how the congruence related to a package contributed
to the congruence value of the whole ecosystem, we also
measure congruence of each package (i.e., the congruence
at the package level). To do so, we adapt the individualized
socio-technical congruence deﬁnition of Wagstrom [56] as
follows:

P gkC(Gt1−t2, p) =

Σ(CD[p, ] ∧ CE[p, ]) + Σ(CD[, p] ∧ CE[, p])
Σ(CD[p, ]) + Σ(CD[, p])

(2)
where p is a package of interest (Npkg.p) in the graph Gt1−t2.
The numerator calculates the number of dependencies for
package p that receive aligned contributions over both the
rows and columns for that package. The denominator sim-
ply sums up the number of dependencies incident upon
package p. For example, given GJan2016−M ar2016 in Figure
1b and all the dependency relationships in the graph have
a type of “is.added”, we want to calculate the package-level
DC congruence of the package Npkg.k between dependen-
cies of is.added and cli&lib-maintain contributions. Hence,
Σ(CD[Npkg.k, ])+Σ(CD[, Npkg.k]) = 2 as the package Npkg.k
has two dependency relationships (i.e., Npkg.i → Npkg.k
and Npkg.j → Npkg.k), and Σ(CD[Npkg.k, ] ∧ CE[Npkg.k, ]) +
Σ(CD[, Npkg.k] ∧ CE[, Npkg.k]) = 1 as there is a cli&lib-
maintain contribution relationship that matches with the
dependency relationship (i.e., Npkg.i → Npkg.k) between
the DC graph (in Figure 1b) and the contribution graph
(in Figure 1c). Finally, the package-level congruence of the
package Npkg.k is calculated as follows.

P gkC(GJan2016−M ar2016, Npkg.k) =

1
2

= 0.5

Intuitively, we can interpret the congruence values (0 to
1) as the extent to which contributions align with depen-
dency changes. A high congruence value at the ecosystem

Table 2: Dataset snapshot statistics.

2014
2015
2016
2017
2018
2019
2020

# Npkg
17,859
57,534
92,748
105,058
106,815
107,146
107,242
Total

# PRs
22,239
98,975
242,424
186,257
139,016
166,588
115,186
970,685

# issues
55,081
222,146
427,001
352,411
267,318
259,560
171,435
1,754,952

# commits
473,591
1,255,065
1,415,015
886,796
527,252
428,191
339,219
5,325,129

# dev
11,031
46,029
82,991
96,916
86,978
69,285
43,815
437,045

level would indicate that a large number of dependency
relationships receive aligned contributions, while a low
value would indicate that there is a small number of aligned
contributions in the ecosystem. Similarly, at the individual
level, a higher congruence value would indicate that a
large number of contributions aligned with dependency
relationships of that package.

3 DATA PREPARATION
To evaluate our congruence models and answer our RQs, we
perform an empirical study on the NPM package ecosystem.
We selected the NPM JavaScript ecosystem as it is one of the
largest package collections on GitHub, and also has been
the focus of recent studies [32], [2], [17]. In this work, we
focus on the NPM packages linked to their GitHub repos-
itories, since we will analyze developer contributions (i.e.,
PRs and issues). Similar to ‘all-the-package-repos’ [23] and
Chinthanet et al. [9], we use a listing of NPM packages from
the NPM registry and then matched them to repositories
available on GitHub. The listing of NPM packages was
acquired in Nov. 2020. To collect the required information,
we use the GitHub Rest API5 to collect PRs, issues, com-
mits, and other metadata (e.g., license type) of the package
repositories included in the latest data snapshot. The issues
are used to answer RQ1 and RQ2, while the commits are
used to answer RQ2 and the PRs are used to answer all
RQs. To overcome the GitHub API limit, we use ﬁve GitHub
tokens that were generated by the ﬁrst ﬁve authors during
the collection process. With these tokens, the API rate limit
is 25,000 (5,000 * 5) requests per hour. We took one month,
from November 1 to November 30, 2020, to acquire all
information.

Table 2 provides an overview of the number of NPM
packages that have repositories available on GitHub for
each year. Overall, the number of NPM packages starts
from small (i.e., 17,859 packages), but then reaches over a
hundred thousand packages (i.e., 107,242) as of Nov. 2020.
Similar to previous work which considered the temporal
dimension [40], [5], [42], we split the data of each year
into quarters: (Q1) January 1 to March 31, (Q2) April 1 to
June 30, (Q3) July 1 to September 30, and (Q4) October 1
to December 31 to establish the temporal intervals of our
graph (i.e., Gt1−t2).

Extracting Contributions, Roles and Dependencies
Once the time-intervals were established, we then ex-
tract the developer contributions and dependency changes
within each quarter. For the contribution activities, we
generate the graph nodes by identifying PRs and issues

5

that occurred during the quarter. To classify the role of the
contributor, we use the GitHub Rest API to identify whether
or not the developer who submitted a contribution (i.e.,
a PR or an issue) had committed any prior commits into
the main branch of the repository. For the dependencies
and their changes, similar to prior work [12], we parse
the package.json ﬁle to extract both development and
runtime dependencies for each package during that time-
period. To identify the dependency changes during the
time-period, we use the PyDriller package6 to mine the
dependency changes (cf. Table 1) of package.json in the
Git history. More speciﬁcally, we focus on the Modiﬁcation
object provided by the PyDriller to investigate commits to
package.json.

Calculating Ecosystem-Level DC Congruence (RQ1)
Answering RQ1 involves computing the DC congruence at
the ecosystem level. Hence, for all time-periods, we con-
struct CE and CD matrices of all the combinations of
contribution types against the different dependency changes
for PRs and issues separately (see Section 2.4). To ease
computational power, we ﬁlter out all rows and columns
of the CE and CD matrices that have only zeros. Since we
analyze PRs and issues separately, we generated a total of
32 instances for each quarter, resulting in 864 matrices. We
took around 21 days of execution based on two standard
computing machines with an Intel Core 2.60GHz, with 40
cores and 252GB of RAM.

Calculating Package-Level DC Congruence (RQ2) An-
swering RQ2 involves computing the package-level DC con-
gruence. Using the constructed matrices (before ﬁltering the
rows and columns with zeros) from RQ1, we calculate the
package-level DC congruences for each time-period. Similar
to RQ1, we generated a total of 32 DC congruence values
for each package in each quarter. Since the experiment was
conducted in parallel with RQ1, the computational time and
resources are the same.

Sampling Contributions (RQ3) Answering RQ3 in-
volves a quantitative analysis of developer contributions.
Hence, we drew a statistically representative random sam-
ple of 383 developers. Our sample size allows us to gen-
eralize conclusions about the ratio of developers to all
developers with a conﬁdence level of 95% and a conﬁdence
interval of 5%, as suggested by prior work [26] based on the
Sample Size Calculator.7 To collect the most recent contribu-
tions of the sampled developers, we extracted contributions
belonging to the most recent quarter. To do so, we ﬁrst
identiﬁed the last contribution, i.e., the last submitted PRs in
our dataset, and then we extracted all their PRs submitted
within that time-period. In the end, we collected 8,938 PRs.
Since our approach involves similarity analysis of the source
code (at least one .js ﬁle) and ﬁle-path components, we
obtained 3,714 (42%) PRs from the 383 developers with the
four developer contribution types (see Section 2.3).

4 RESULTS

In this section, we present the results to answer our RQs.

5. https://docs.github.com/en/rest

6. https://github.com/ishepard/pydriller
7. https://www.surveysystem.com/sscalc.htm

6

Figure 2: Ecosystem-level DC congruence over time. The red text indicates quarters in which congruence values are highest.

Table 3: Summary statistics of ecosystem-level DC congru-
ence of contribution types.

dependencies had the highest congruence values (DC con-
gruence of 0.16).

Contribution Type Max Min Mean Median

non-maintain
cli&lib-maintain
cli-maintain
lib-maintain

0.166
0.095
0.166
0.083

0.001
0.000
0.000
0.000

0.030
0.013
0.006
0.003

0.020
0.006
0.003
0.002

4.1 Assistance from the Ecosystem (RQ1)

Approach. To answer RQ1, we analyze the DC congruence in
terms of developer contributions and dependency changes.
In particular, we address each of the sub-questions as follow:
To answer RQ1a: To what degree do developer contributions
align with dependencies?, we summarize the DC congru-
ence in terms of the distribution by contribution type. To
answer RQ1b: How do different contribution types and depen-
dency changes contribute to DC congruence, we analyze trends
of DC congruence related to different contribution types and
dependency changes.

For RQ1b, we use the Spearman rank-order correlation
coefﬁcient to analyze the correlations between the different
dependency changes for each kind of contribution. A corre-
lation between 0 – 0.09 is considered as negligible, 0.1 – 0.39
as weak, 0.4 – 0.69 as moderate, 0.7 – 0.89 as strong, and
0.9 – 1 as very strong. To analyze the Spearman rank-order
correlation coefﬁcients, we use the dataframe.corr() function
of the pandas package.8

Aligning contributions to their dependencies (RQ1a).
Table 3 shows that the congruence between contributions
and dependency changes is low (i.e., 0.001 to 0.166) when
compared to other social-technical applications, such as
aligning coordination and organization architectures [49].
However, relatively, we ﬁnd that non-maintain contribu-
tions that aligned with downgrading dependencies and
cli-maintain contributions that aligned with downgrading

8. https://pandas.pydata.org/

From Figure 2, we ﬁnd that the highest congruence val-
ues occur generally in the second quarter of 2014, followed
by the ﬁrst quarter of 2015. This could be explained by the
ecosystem size (17,859 and 57,534 packages in 2014 and 2015
respectively).

Attributes that correlate with the DC congruence (RQ1b)
From Figure 2, we are able to make two observations. First,
we ﬁnd that there is higher congruence with contributions
when a dependency is downgraded (see the purple lines in
Figure 2). This ﬁnding is consistent between all contribution
types and between issues and PRs, except for the congru-
ence between lib-maintain PRs and dependency upgrades.
The second observation is that the non-maintain contribu-
tions are most congruent with dependency changes. This
is consistent from both the issue and PRs. This provides
evidence that package dependency changes are satisﬁed by
contributions that come from the ecosystem and not the
maintainers of either that package or clients.

Table 4 shows evidence that all dependency changes are
correlated with each other. Statistically, we tested to ﬁnd that
any dependency changes are moderately to strongly corre-
lated to each other for all contribution types, except for the
lib-maintain contributions (is-added to is-downgraded, and
is-removed to is-downgraded). We now return to answer
RQ1, which we summarize below:

201420152016201720182019202000.050.10.1520142015201620172018201920202014201520162017201820192020201420152016201720182019202000.050.10.15is-addedis-removedis-upgradedis-downgradedYearYearYearYearEcosystemCEcosystemCnon-maintaincli&lib-maintaincli-maintainlib-maintainPRIssueQ2 2014Q2 2014Q1 2015Q1 2015Q2 2014Q2 2014Q2 2014Q3 2020Table 4: Correlations between different dependency changes for each type of contribution

7

non-maintain

cli&lib-maintain

cli-maintain

lib-maintain

Dependency change to Dependency change

PR
corr. strength

issue
corr. strength

PR
corr. strength

issue
corr. strength

PR
corr. strength

issue
corr. strength

PR
corr. strength

issue
corr. strength

is-added to is-removed
is-added to is-upgraded
is-added to is-downgraded
is-removed to is-upgraded
is-removed to is-downgraded
is-upgraded to is-downgraded

Strong
Strong
Moderate
Strong
Moderate
Strong

Strong
Strong
Moderate
Strong
Moderate
Strong

Moderate
Moderate
Moderate
Strong
Strong
Strong

Strong
Strong
Strong
Strong
Strong
Moderate

Strong
Very strong
Strong
Strong
Moderate
Very Strong

Very strong
Very Strong
Strong
Very strong
Strong
Strong

Moderate
Strong
Weak
Moderate
Weak
Moderate

Strong
Very strong
Weak
Strong
Moderate
Moderate

Correlation: Negligible is 0 to 0.09, Weak is 0.1 to 0.39, Moderate is 0.4 to 0.69, Strong is 0.7 to 0.89, Very strong is 0.9 to 1.

RQ1 Summary

The alignment between developer contributions and
dependency changes varies over time, with the high-
est values generally observed in earlier stages of the
NPM ecosystem. The peaks we identify in the data
correspond to a DC congruence of 0.16, i.e., 16% of
the dependency changes receive aligned contribu-
tions. Furthermore, we show that contributions are
most congruent with downgrading a dependency,
and mainly come from the ecosystem and not the
maintainers of either that package or clients.

4.2 Contribution Congruence and Package’s Dormancy
(RQ2)

Approach. To address RQ2, we analyze the relationship be-
tween the DC congruence and the likelihood of packages
becoming dormant. In particular, we leverage survival anal-
ysis techniques which allow us to model the relationship
across different time periods. We use a Cox proportional-
hazard model (i.e., a commonly-used survival analysis
model) [16] to capture the risk of an event (i.e., a package
becomes dormant) in relation to factors of interest (e.g., the
DC congruence) in the elapsed time.

To do so, we extract the event and the factors for each
package in each time period (i.e., a quarter). In our Cox
model, the dependent variable is the event that a pack-
age becomes dormant at a particular time point. In line
with prior work [11], [58], [55], a project is regarded as
dormant if it is no longer being maintained or does not
have development activity. Speciﬁcally, similar to the work
of [55], we consider a package as dormant in the quarter
q if it had an average number of commits less than one
for four consecutive quarters (i.e., from the quarter q until
the quarter (q + 3)). For example,
in the ﬁrst, second,
third, and fourth quarters in 2018, a package that has 1,
0, 0, and 1 commits, respectively is considered as dormant
since the ﬁrst quarter in 2018 because the average number
of commits for four consecutive quarters is 0.5 ( 2
4 ). Note
that we exclude packages that have the ﬁrst commit after
October 2019, since their historical data is not sufﬁcient to
identify whether the package is dormant or not (i.e., less
than four consecutive quarters). As our RQ1 shows that the
correlations between different dependency changes for all
contribution types vary, it is also possible that these DC
congruence may provide various signals to the package
dormancy given different dependency changes and contri-
bution types. Thus, for independent variables in our Cox

Table 5: Project characteristics [55] that are used as control
variables in our Cox model.

Metric
#Commits
#Contributors

Core Team Size

#Issues
#Non-Developer Is-
sue Reporters
License Type

Description
The number of commits occurring in the observed quarter.
The number of GitHub users who have authored commits in the
observed quarter.
The number of GitHub users responsible for 90% of contributions in
the observed quarter.
The number of issues created in the observed quarter.
The number of GitHub users who did not author any commits but
created an issue in the observed quarter.
The license type that the studied package used in the observed quar-
ter: Strong copy-left (e.g., GPL, Affero), Weak-copy-left (e.g., LGPL,
MPL, OPL), or non-copy-left (e.g., Apache, BSD)

model, we use 32 metrics which measure the package-level
DC congruence (see Section 3). Since prior work has shown
that project characteristics can be associated with the chance
of packages becoming dormant [55], we also include six
project characteristics (see Table 5) as control variables in
our Cox model.

To construct the Cox model, we use a similar approach
as Valiev et al. [55], which has the following four steps.
First, we perform log-transform on the independent vari-
ables with skewed distribution to stabilize the variance and
reduce heteroscedasticity, which will improve the model ﬁt.
We manually observe the skewness of the distribution using
histogram plots. Second, we check for the multicolinearity
between independent variables using the variance inﬂation
factor (VIF) test. We remove the variables that have VIF
scores above the recommended maximum of 5 [13]. Third,
we test the assumption of constant hazard ratios overtime.
To do so, we employ graphical diagnostics of Schoenfeld
residuals [25]. We observe that Schoenfeld residuals of the
remaining variables have a random pattern against time,
which implies that the Cox model assumptions are not
violated. Finally, we use coxph in the R survival package
to build a Cox proportional-hazards model.

To analyze the association between each independent
variable and the likelihood of a package becoming dormant,
we examine the coefﬁcient values and effect sizes of the
independent variables. The coefﬁcient values in the Cox
model are hazard ratios, where a hazard ratio above 1
implies that a variable is positively associated with the event
probability, while a hazard ratio below 1 indicates an inverse
association. For the effect size, we perform ANOVA type-II
to obtain Log-likelihood Ratio χ2 (LR χ2). The larger the LR
χ2 of the variable is, the stronger the relation of the variable
to the likelihood of a package becoming dormant.

Table 6 shows that our Cox proportional-hazard model
achieves an adjusted R2 of 30.7%, suggesting that the
goodness-of-ﬁt of our model is acceptable as the model is
supposed to be explanatory and not for prediction [41].

Table 6: Survival analysis statistics

NPM Ecosystem Survival Analysis
response: dormant = TRUE
R2 = 30.7%

Number of commits
Log number of contributors
Log number of non-developer issues
Core size of the team
Strong copy-left license (vs none)
Weak copy-left license (vs none)
Non-copy-left license (vs none)

Coeffs (Err.)

LR Chisq

0.98 (<0.01)∗∗∗
7.85 (0.01)∗∗∗
0.68 (0.01)∗∗∗
0.14 (0.02)∗∗∗
0.88 (0.02)∗∗∗
0.69 (0.03)∗∗∗
0.82 (<0.01)∗∗∗

5437.5∗∗∗
23699.3∗∗∗
4781.0∗∗∗
13378.8∗∗∗
839.3∗∗∗

Contribution Type Dependency Change

Type

Coeffs (Err.)

LR Chisq

non-maintain
non-maintain
non-maintain
non-maintain
cli-maintain
cli-maintain
cli-maintain
cli-maintain
lib-maintain
lib-maintain
lib-maintain
non-maintain
non-maintain
non-maintain
non-maintain
cli&lib-maintain
cli&lib-maintain
cli&lib-maintain
cli&lib-maintain
cli-maintain
cli-maintain
cli-maintain
cli-maintain
lib-maintain
lib-maintain
lib-maintain
lib-maintain

is-added
is-removed
is-downgraded
is-upgraded
is-added
is-removed
is-downgraded
is-upgraded
is-added
is-removed
is-downgraded
is-added
is-removed
is-downgraded
is-upgraded
is-added
is-removed
is-downgraded
is-upgraded
is-added
is-removed
is-downgraded
is-upgraded
is-added
is-removed
is-downgraded
is-upgraded

issue
issue
issue
issue
issue
issue
issue
issue
issue
issue
issue
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR
PR

1.33 (0.32)
0.92 (0.15)
1.26 (0.21)
0.67 (0.08)∗∗∗
0.82 (0.18)
0.62 (0.29)
0.77 (0.45)
0.66 (0.16)∗∗
0.64 (0.27)
1.33 (0.32)
0.71 (0.58)
0.95 (0.14)
0.99 (0.18)
0.51 (0.24)∗∗
0.87 (0.09)
0.87 (0.07)
1.31 (0.10)∗∗∗
0.60 (0.19)∗∗
0.98 (0.05)
1.27 (0.26)
1.27 (0.37)
0.79 (0.58)
1.08 (0.21)
0.97 (0.38)
0.49 (0.51)
0.14 (1.37)
0.42 (0.20)∗∗∗

0.7
0.3
1.1
24.0∗∗∗
1.2
3.1
0.4
7.6∗∗
3.1
0.7
0.4
0.2
0.0
7.1∗∗
1.5
3.9∗
6.3∗
8.0∗∗
0.1
0.8
0.4
0.2
0.1
0.0
1.9
2.8
22.0∗∗∗

∗ p<0.05; ∗∗ p<0.01; ∗∗∗ p<0.001
#Issues, is-added and cli&lib-maintain and issue, is-downgraded and
cli&lib-maintain and issue, is-removed and cli&lib-maintain and issue,
is-upgraded and cli&lib-maintain and issue, and is-upgraded and lib-
maintain and issue are removed during VIF analysis.

Association between the contribution congruence and
the chance of packages becoming dormant. We found that
six congruence-related variables are signiﬁcantly associated
with the likelihood of a package becoming dormant in our
Cox model, i.e., is-removed and cli&lib-maintain and PR, is-
downgraded and cli&lib-maintain and PR, is-downgraded and
non-maintain and PR, is-upgraded and cli-maintain and issue,
is-upgraded and lib-maintain and PR, and is-upgraded and non-
maintain and issue. Among these six variables, is-upgraded
and lib-maintain and PR and is-upgraded and non-maintain and
issue have the largest LR χ2 values (see Table 6). Their co-
efﬁcient values also indicate an inverse association with the
likelihood of a package becoming dormant. In other words,
the coefﬁcient value of is-upgraded and lib-maintain and PR
indicates that the higher the number of lib-maintain PRs
that are aligned with a dependency upgrade, the lower the
likelihood that a package becomes dormant. Similarly, the
coefﬁcient value of is-upgraded and non-maintain and issue
indicates that the higher the number of non-maintain issues
that are aligned with a dependency upgrade, the lower the
likelihood that a package becomes dormant. The coefﬁcient
values of is-upgraded and lib-maintain and PR, is-downgraded
and non-maintain and PR, and is-upgraded and cli-maintain and
issue also show the same direction of the association. These
results suggest that a package is less likely to become dor-
mant if the contributions (i.e., PRs and issues) are aligned
with the events of upgrading or downgrading dependen-

8

cies.

RQ2 Summary

Our survival analysis shows that the different types
of DC congruence share an inverse association with
the likelihood of a package becoming dormant. For
instance, the higher the number of issues from spe-
ciﬁc types (i.e., non-maintain, cli-maintain) that are
aligned with a dependency upgrade, the lower the
likelihood that a package becomes dormant.

4.3 Similarities between Contributions (RQ3)

Approach. To answer RQ3, we investigate whether the type
of aligned contributions submitted to dependencies are the
same as other contributions by analyzing the source code
similarity and ﬁle location similarity. Hence, we focus on
client contributions (i.e., cli-maintain), comparing against
contributions from the ecosystem (i.e., non-maintain), and
then the rest of maintainer contributions (i.e., cli&lib-
maintain and lib-maintain). We compute similarity based
on two common methods to compare the content of PRs,
which is (i) source code and (ii) ﬁle path similarity [57], [38],
[29]. More speciﬁcally, we use the source code similarity to
measure whether the two contributions share similar source
code; and use the ﬁle path similarity to measure whether
the two contributions modify similar components. From our
sample, we compare the similarities between PRs of the
same contribution type of a developer. As a PR may modify
multiple ﬁles, we compare all components (i.e., source code
lines and ﬁle paths).

Our source code similarity measure is based on the Jac-
card index of tokens which approximates the edit distance
between two PRs [53]. Following the analysis of repeated
bug ﬁxes [63], to compare a pair of PRs, we take only added
lines by the PRs into account. Formally, for any PR (p), the
source code similarity is deﬁned as follows:

SourceCodeSim(p1, p2) =

|trigrams(p1) ∩ trigrams(p2)|
|trigrams(p1) ∪ trigrams(p2)|
(3)
where trigrams(p) is a multiset of trigrams (3-grams) of
source code tokens extracted from all source code lines
added by a PR (p). A higher similarity indicates that a
larger amount of source code is shared. The similarity is
an extension of ﬁle similarity deﬁned by Ishio et al. [28]
for PRs. This measure has been widely adapted in various
software engineering studies [28], [31], [60] and less affected
by moved code in a PR, compared with other measures. On
that same note, we apply the ﬁle location-based model that
is used in typical code review recommendations [51], [62],
[57] to compute ﬁle path similarity that is deﬁned as follows:

StringSimLCx(f1, f2) =

LCx(f1, f2)
max(Length(f1), Length(f2))

where the LCx(f1, f2) function has a parameter to spec-
ify how to compare ﬁle path components f1 and f2. Four
different comparison techniques, i.e., Longest Common Pre-
ﬁx (LCP), Longest Common Sufﬁx (LCS), Longest Common
Substring (LCSubstr), and Longest Common Subsequence

9

ﬁle paths are relatively low (i.e., scores of 0.01 to 0.17).
This could be explained by our method to aggregate all
source code and ﬁle paths for comparison, which is different
to typical ﬁle-level similarity comparison techniques [44].
Relatively, we see that the ﬁle path similarity is higher than
the source code similarity.

In terms of statistical signiﬁcance, from Figure 3, we
make three key observations. First, ﬁle path content between
cli&lib-maintain and lib-maintain and non-maintain con-
tributions are different. Second, we ﬁnd differences in the
source code content between cli-maintain and other contri-
butions. This suggests that the content of aligned contribu-
tions submitted to packages that developers depend on may
differ from the other contributions made to either their own
packages or other packages. Conversely, we ﬁnd that there is
no signiﬁcant difference in the source code between cli&lib-
maintain and lib-maintain and non-maintain contributions,
which suggests that developers may be submitting similar
code, regardless of whether they are maintaining packages
or not. Conﬁrming statistical signiﬁcance, we show that the
effect size ranges from negligible to medium strength as
shown in Table 7.
RQ3 Summary

Comparing contribution similarity in terms of source
code and ﬁle paths, we ﬁnd statistical differences in
source code content of aligned contributions sub-
mitted to dependencies when compared to those
that are not aligned. In other words, congruent
contributions are not typical contributions by that
contributor.

5 DISCUSSION
We now discuss our results, implications, and threats to
validity.

5.1 Peaks of DC Congruence and Global Events

The results in RQ1 (i.e., Figure 2) show that DC congru-
ence is changing over time. Interestingly, we ﬁnd that the
ofﬁcial NPM blog10 showed two dependency events that
may correlate with the observed peaks. It is also important
to note that we do not aim to draw a causal relationship, but
only observe correlations.
• June, 2015 - NPM 3 is released. According the NPM blog,11
the release has a notable breaking change when migrating to
NPM version 3. According to our DC congruence values in
Figure 2, we see the peak changes in the non-maintain con-
tribution and dependency remove congruence (i.e., 0.019 for
issues and 0.013 for PRs), and cli-maintain contribution and
dependency downgrade congruence (i.e., 0.031 for issues
and 0.027 for PRs).
• March 2016 - Left-pad incident. NPM attracted press atten-
tion after a package called left-pad, which many popu-
lar JavaScript packages depended on, was unpublished. It
caused widespread disruption, leading NPM to change its

10. Available at https://blog.npmjs.org/
11. https://blog.npmjs.org/post/122450408965/npm-weekly-20-

Figure 3: Comparisons of contribution types. (ns: no signiﬁ-
cance, **: p-value < 0.01, ***: p-value < 0.001, ****: p-value < 0.0001)

Table 7: Statistical comparisons of contribution types.

Source Code

File Path

cli-maintain vs (cli&lib-maintain and lib-maintain)
non-maintain vs (cli&lib-maintain and lib-maintain)
cli-maintain vs non-maintain

Small
Negligible
Small

Negligible
Medium
Medium

Effect size: Negligible |δ| < 0.147, Small 0.147 ≤ |δ| < 0.33,
Medium 0.33 ≤ |δ| < 0.474, Large 0.474 ≤ |δ|

(LCSubseq) are used in the LCx function. The comparison
function value is normalized by the maximum length of
each ﬁle path in f1 and f2, i.e., the number of ﬁle path
components. To calculate the ﬁle path similarity between
two PRs, we do a pairwise comparison of all ﬁle paths in the
two PRs and then summarize these by taking the average
score. Since we use four different comparison techniques,
four similarity scores between two PRs are retrieved and we
also summarize these by taking the average score. A higher
similarity indicates that a larger amount of components are
shared in the PRs.

Once we compute the similarity between PRs in
each contribution types (i.e., cli-maintain, non-maintain,
and cli&lib-maintain and lib-maintain), we now analyze
whether the similarity of the cli-maintain contributions is
different from the similarity of the other contributions. To
visualize this, we will use a box-plot to show the distribu-
tions of similarities between PRs in each of the contribution
types.

To statistically conﬁrm the differences in the three con-
tribution types, we use the Kruskal-Wallis H test [33]. This
is a non-parametric statistical test to use when comparing
two or more than two types. We test the null hypothesis
that ‘two different types have similar contributions.’ We also
measure the effect size using Cliff’s δ, a non-parametric
effect size measure [10]. Effect size is analyzed as follows:
(1) |δ| < 0.147 as Negligible, (2) 0.147 ≤ |δ| < 0.33 as Small,
(3) 0.33 ≤ |δ| < 0.474 as Medium, or (4) 0.474 ≤ |δ| as
Large. We use the cliffsDelta9 package to analyze Cliff’s δ.

Similarities/differences between client contributions and
other contributions. Figure 3 shows that overall the simi-
larities of contents of PRs in terms of the source code and

9. https://github.com/neilernst/cliffsDelta

npm-3-is-here-ish.html

cli&lib-maintainand lib-maintaincli-maintainnon-maintainPairwise comparisons103102101100Similarity Score (logarithmic scale)**ns******ns****Source CodeFile Pathpolicies regarding unpublishing packages. According to our
DC congruence values in Figure 2, we see peak changes in
the non-maintain contribution and dependency downgrade
congruence (i.e., 0.103 for issues and 0.086 for PRs), and non-
maintain contribution and dependency upgrade congruence
(i.e., 0.051 for issues and 0.037 for PRs).

5.2 Implications

Package developers: You should welcome contributions
from the ecosystem and offer them ways to get involved.
RQ1 results suggest that contributions that align with de-
pendency changes come from the ecosystem itself, many
of them not having any self-interest (i.e., relying on these
packages). The results of our survival analysis in RQ2 show
that a package that received contributions aligned with
the dependency changes is less likely to become dormant,
which implies that packages are indeed dependent on the
ecosystem support. RQ3 shows that cli-maintain contri-
butions differ in source code content when compared to
developers’ typical contributions. These ﬁndings underline
the important role of the ecosystem.

Package users: You might have to contribute to pack-
ages you are using to reduce the risks of packages
becoming dormant (in multiple possible ways). In our
RQ2, we found that a large number of packages become
dormant in the early stages, with more than 90% of packages
becoming inactive until the end-time of our study. Taking
into account that contributions aligned with dependencies
share a relationship with the likelihood of a package be-
coming dormant, we encourage package users to take any
opportunity to contribute back to packages that they depend
on.

Currently there is numerous tools to assist with aware-
ness of when a new version of an existing dependency is
available (bots like dependabot12), however, making users
aware of raised issues, and potential threats (such as vul-
nerabilities) to their dependency may cause these users to
assist. Furthermore, the results of RQ3 show that aligned
contributions submitted to dependencies are different in
source code, which conﬁrms our hypothesis and indicates
that package users might be willing to go out of their way
to assist with the dependency that they rely on.

Researchers: Ecosystem-level is important, do not put
all contributions into the same bucket when analyzing
open source contributions. Our results highlight the impor-
tant relationship between dependencies in an ecosystem and
contributions. Researchers interested in studying character-
istics of open-source developers, e.g., motivation [22] or suc-
cess [52], should consider whether or not the contribution is
from the ecosystem. This also applies to researchers working
on helping newcomers make their ﬁrst contribution in open
source projects. Several approaches have been proposed to
help newcomers ﬁnd good ﬁrst issues, e.g., Tan et al. [50].
These approaches generally ignore the relationship of a
newcomer to the repository that contains the issues.

Ecosystem Governance: We suggest that policies and
good governance is needed to help ecosystem members.
Our results suggest that contributions congruent with de-
pendency changes are from other packages that belong

12. https://github.com/dependabot

10

to the same ecosystem, suggesting that it may impact on
ecosystem health, resilience, and governance. This points to
implications such as implementing collective support into
existing policies and governance. Examples include ecosys-
tem guidelines for maintainers and users13. Particularly,
RQ2 results indicated that a package is less likely to become
dormant if contributions are aligned with dependencies.
One example of challenges in the relationship between
ecosystem members that depend on each other is illustrated
by the following quote: ‘... maintainers have been working
sleeplessly on mitigation measures; ﬁxes, docs, CVE, replies
to inquiries, etc. Yet nothing is stopping people to bash us,
for work we aren’t paid for, for a feature we all dislike yet
needed to keep due to backward compatibility concerns ...’14
One strategy to prevent member packages from becoming
dormant, is to promote explicit best practices and some
ecosystem-wide policies that encourage members contribute
to each other. One example is how the NPM ecosystem has a
global blog and central vulnerability advisory15, to provide
a global awareness of ecosystem threats.

5.3 Threats to Validity

Internal Validity - We discuss ﬁve threats to internal va-
lidity. The ﬁrst threat is the correctness of techniques used
in our mining task. We use the listed dependencies and
version numbers as deﬁned in the package.json meta-ﬁle.
Since we based our mining techniques on prior work, we are
conﬁdent that our results are replicable. The second threat
is related to the constructed matrices for measuring the
DC congruence. Since we pioneer the investigation of DC
congruence, we constructed binary matrices in this study.
We will calculate weight matrices, e.g., a matrix captures the
number of contributions (issues and PRs) to investigate the
impacts of contributions on the DC congruence, in future
work. The third threat is related to the results derived
from the survival model. Although we observe association
between explanatory and dependent variables, we cannot
infer causal effect of explanatory variables. Thus, future
in-depth qualitative analysis or experimental studies are
needed. The fourth threat is related to the factors used in
our survival model. Other factors might also inﬂuence the
chance of packages becoming dormant. Since our factors are
based on Valiev et al. [55], we are conﬁdent in the factors
used in our study. Finally, tool selection has its threats, as
different tools and techniques may lead to different results
(e.g., Jaccard index for the source code similarity calculation
and the statistical testing). Our approach involves the use
of Pydriller and GitHub Rest API. We are conﬁdent in our
results, since all employed tools and techniques are those
that have been used in prior work and are well-known in
the software engineering community.

External Validity - The main threat to external valid-
ity is the generalizability of our results to other package

13. NPM ecosystem governance

https://github.com/nodejs/

package-maintenance/blob/main/Governance.md

14. https://twitter.com/yazicivo/status/1469349956880408583?

lang=en

15. https://docs.github.com/en/code-security/supply-
chain-security/managing-vulnerabilities-in-your-projects-
dependencies/browsing-security-vulnerabilities-in-the-github-
advisory-database

ecosystems. Since the NPM ecosystem is the largest package
ecosystem, we believe that our model and measurements
could easily be applied to other ecosystems that have similar
package management systems, such as PyPI for Python and
Maven for Java. We will explore this in future work.

6 RELATED WORK

Socio-Techical Congruence (STC). Cataldo et al. [8] pio-
neered the concept of socio-technical congruence (STC), the
match between task dependencies among people and coor-
dination activities performed by individuals. Their follow-
up studies (Cataldo et al. [7], Cataldo and Herbsleb [6]) then
investigated software quality and development productiv-
ity. Further studies also presented STC measures from dif-
ferent perspectives. For instance, Valetto et al. [54] proposed
a measure of STC in the view of network analysis, while
Kwan et al. [36] measured weight STC and the impact of
STC on software build success (Kwan et al. [37]). Addi-
tionally, Wagstrom et al. [56] measured individualized STC.
Other studies then measured STC from other perspectives
such as dependencies, knowledge, and resources [30], global
software development [43], and for ﬁle-level analysis [66]
and [39]. Different from these studies, we formulate the time-
based ecosystem-level DC congruence, adapting the STC
measure proposed by Cataldo et al. [8]. Further, we analyze
the time-based package-level DC congruence, making an
adjustment on the STC measure proposed by Wagstrom et
al. [56].

Package Dependency Changes. The research commu-
nity has carried out a large body of research on understand-
ing the large networks of software package dependencies.
Some studies focused on a single ecosystem, focusing on
the updating and lags within that ecosystem. For instance,
Wittern et al [61] analyzed a subset of NPM packages,
focusing on the evolution of characteristics such as their
dependencies and update frequency. Abdalkareem et al. [2]
also empirically analyzed “trivial” NPM packages, to sug-
gest that depending on trivial packages can be useful and
risk-free if they are well implemented and tested. Zerouali
et al
. [65] analyzed the package update practices and
technical lag to show a strong presence of technical lag
caused by the speciﬁc use of dependency constraints. Re-
cent studies include understanding the lag when updating
security vulnerabilities [9] and dependency downgrades
[12] for the NPM ecosystem. There are works that studied
other ecosystems. Robbes et al. [45] showed that a number
of API changes caused by deprecation can have a large
impact on the Pharo ecosystem. Blincoe et al. [4] proposed a
new method for detecting technical dependencies between
projects on GitHub and IBM. Bavota et al. [3] studied
Apache projects to discover that a client project tends to
upgrade a dependency only when substantial changes (e.g.,
new features) are available. Kula et al . [34] revealed that
affected developers are not likely to respond to a security
advisory for Maven libraries, while Wang et al. [59] revealed
that developers need convincing and ﬁne-grained informa-
tion for the migration decision. Most recently, He et al. [27]
proposed a framework for quantifying dependency changes
and library migrations based on version control data using
Java projects.

11

Other studies focused on analyzing multiple ecosystems,
comparing the different attributes between them. Decan et
al . [17] showed the comparison of dependency evolution
and issue from three different ecosystems. Similarily, Kikas
et al. [32], studied the dependency network structure and
evolution of the JavaScript, Ruby, and Rust ecosystems.
Dietrich et al. [20] studied how developers declare depen-
dencies across 17 different package managers. Stringer et
al. [48] analyzed technical lag across 14 package managers
and discovered that technical lag is prevalent across package
managers but preventable by using semantic versioning
based declaration ranges. Differently, in our work, we focus
on how developer contributions align with dependency
changes at the ecosystem level, our motivation is different,
as we explore how dependency changes correlate with a
package becoming dormant.

Sustainability of Software Ecosystem As with prior
work [14], we view software ecosystems as socio-technical
networks consisting of
technical components (software
packages) and social components (communities of develop-
ers) that maintain the technical components. Sustainability
is particular visible in the complex and often brittle depen-
dency chains in OSS package ecosystems like NPM, PyPi,
and CRAN [18]. Other studies have studied sustainability
for R [21], Ruby [15], Python [55], and NPM [19]. Through
a longitudinal empirical study of Cargo’s dependency net-
work, Golzadeh [24] revealed that dependencies to a project
lead to active involvement in that project. However, the
effect of DC congruence from different types of contri-
butions on the ecosystem sustainability is still unknown.
Different to these studies, we take a quantitative approach to
investigate the relationship between the DC congruence and
the likelihood of packages becoming dormant.

7 CONCLUSION

This work investigates how developers whose code de-
pends on other packages in the NPM ecosystem, submit
contributions to assist these packages. Borrowing socio-
technical techniques, we were able to measure the congru-
ence between these aligned contributions, and changes in
dependencies for the ecosystem. Results indicate that pack-
ages indeed rely on the ecosystem for contributions, and
that these aligned contributions share a relationship with
the likelihood of a package becoming dormant, suggesting
that the alignment between contributions and dependency
changes could be used as an indicator of package dormancy.
Moreover, the aligned contributions submitted to depen-
dencies differ from developers’ typical contributions. Our
results show that developers do depend on the ecosystem,
and should be encouraged to support packages that they
depend on.

ACKNOWLEDGEMENT

This work is supported by Japanese Society for the
Promotion of Science (JSPS) KAKENHI Grant Numbers
20K19774 and 20H05706. P. Thongtanunam was partially
supported by the Australian Research Council’s Discovery
Early Career Researcher Award (DECRA) funding scheme
(DE210101091).

REFERENCES

[1]
“npm,” https://www.npmjs.com/, (Accessed on 05/16/2021).
[2] R. Abdalkareem, O. Nourry, S. Wehaibi, S. Mujahid, and E. Shihab,
“Why do developers use trivial packages? an empirical case study
on npm,” in Proceedings of the 2017 11th Joint Meeting on Foundations
of Software Engineering, 2017, p. 385–395.

[3] G. Bavota, G. Canfora, M. Di Penta, R. Oliveto, and S. Panichella,
“How the apache community upgrades dependencies: An evo-
lutionary study,” Empirical Software Engineering, vol. 20, no. 5, p.
1275–1317, 2015.

[4] K. Blincoe, F. Harrison, N. Kaur, and D. Damian, “Reference cou-
pling: An exploration of inter-project technical dependencies and
their characteristics within large software ecosystems,” Information
and Software Technology, vol. 110, pp. 174–189, 2019.

[5] C. Brindescu, I. Ahmed, C. Jensen, and A. Sarma, “An empirical
investigation into merge conﬂicts and their effect on software
quality,” Empirical Software Engineering, vol. 25, no. 1, p. 562–590,
2020.

[6] M. Cataldo and J. D. Herbsleb, “Coordination breakdowns and
their impact on development productivity and software failures,”
IEEE Transactions on Software Engineering, pp. 343–360, 2013.
[7] M. Cataldo, J. D. Herbsleb, and K. M. Carley, “Socio-technical
congruence: A framework for assessing the impact of technical
and work dependencies on software development productivity,”
in Proceedings of the Second ACM-IEEE International Symposium on
Empirical Software Engineering and Measurement, 2008, p. 2–11.
[8] M. Cataldo, P. A. Wagstrom, J. D. Herbsleb, and K. M. Carley,
“Identiﬁcation of coordination requirements: Implications for the
design of collaboration and awareness tools,” in Proceedings of the
2006 20th Anniversary Conference on Computer Supported Cooperative
Work, 2006, p. 353–362.

[9] B. Chinthanet, R. G. Kula, S. McIntosh, T. Ishio, A. Ihara, and
K. Matsumoto, “Lags in the release, adoption, and propagation of
npm vulnerability ﬁxes,” Empirical Software Engineering, pp. 1–28,
2021.

[10] N. Cliff, “Dominance statistics: Ordinal analyses to answer ordinal
questions,” Psychological Bulletin, vol. 114, pp. 494–509, 1993.
[11] J. Coelho and M. T. Valente, “Why modern open source projects
fail,” in Proceedings of the 2017 11th Joint Meeting on Foundations of
Software Engineering, 2017, pp. 186–196.

[12] F. R. Cogo, G. A. Oliva, and A. E. Hassan, “An empirical study
of dependency downgrades in the npm ecosystem,” IEEE Transac-
tions on Software Engineering, pp. 1–1, 2019.

[13] J. Cohen, P. Cohen, S. G. West, and L. S. Aiken, “Applied multiple
regression,” Correlation Analysis for the Behavioral Sciences, 1983.
[14] E. Constantinou and T. Mens, “An empirical comparison of devel-
oper retention in the rubygems and npm software ecosystems,”
vol. 13, p. 101–115, 2017.

[15] ——, “Socio-technical evolution of the ruby ecosystem in github,”
2017 IEEE 24th International Conference on Software Analysis, Evolu-
tion and Reengineering, pp. 34–44, 2017.

[16] D. R. Cox and D. Oakes, Analysis of survival data. CRC Press, 1984.
[17] A. Decan, T. Mens, and M. Claes, “An empirical comparison of
dependency issues in oss packaging ecosystems,” in 2017 IEEE
24th International Conference on Software Analysis, Evolution and
Reengineering, 2017, pp. 2–12.

[18] A. Decan, T. Mens, and P. Grosjean, “An empirical comparison
of dependency network evolution in seven software packaging
ecosystems,” Empirical Software Engineering, 2019.

[19] T. Dey, Y. Ma, and A. Mockus, “Patterns of effort contribution and
demand and user classiﬁcation based on participation patterns in
npm ecosystem,” 2019, p. 36–45.

[20] J. Dietrich, D. Pearce, J. Stringer, A. Tahir, and K. Blincoe, “Depen-
dency versioning in the wild,” in 2019 IEEE/ACM 16th International
Conference on Mining Software Repositories, 2019, pp. 349–359.
[21] D. M. German, B. Adams, and A. E. Hassan, “The evolution of the
r software ecosystem,” in 2013 17th European Conference on Software
Maintenance and Reengineering, 2013, pp. 243–252.

[22] M. Gerosa, I. Wiese, B. Trinkenreich, G. Link, G. Robles, C. Treude,
I. Steinmacher, and A. Sarma, “The shifting sands of motivation:
Revisiting what drives contributors in open source,” in 2021
IEEE/ACM 43rd International Conference on Software Engineering,
2021, pp. 1046–1058.

[23] GitHub - nice-registry/all-the-package-repos, “Normalized repos-
itory urls for every package in the npm registry. updated
daily.” https://github.com/nice-registry/all-the-package-repos,
2017, (Accessed on 08/28/2021).

12

[24] M. Golzadeh, “Analysing socio-technical congruence in the pack-
age dependency network of cargo,” in Proceedings of the 2019 27th
ACM Joint Meeting on European Software Engineering Conference and
Symposium on the Foundations of Software Engineering, 08 2019.
[25] P. M. Grambsch and T. M. Therneau, “Proportional hazards tests
and diagnostics based on weighted residuals,” Biometrika, pp. 515–
526, 1994.

[26] H. Hata, C. Treude, R. Kula, and T. Ishio, “9.6 million links in
source code comments: Purpose, evolution, and decay,” in Pro-
ceedings of the 41st International Conference on Software Engineering,
2019, pp. 1211–1221.

[27] H. He, R. He, H. Gu, and M. Zhou, “A large-scale empirical study
on java library migrations: Prevalence, trends, and rationales,”
in Proceedings of the 29th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software
Engineering, 2021, p. 478–490.

[28] T. Ishio, Y. Sakaguchi, K. Ito, and K. Inoue, “Source ﬁle set
search for clone-and-own reuse analysis,” in 2017 IEEE/ACM 14th
International Conference on Mining Software Repositories, 2017, pp.
257–268.

[29] J. Jiang, D. Lo, J. Zheng, X. Xia, Y. Yang, and L. Zhang, “Who
should make decision on this pull request? analyzing time-
decaying relationships and ﬁle similarities for integrator predic-
tion,” Journal of Systems and Software, vol. 154, pp. 196–210, 2019.

[30] L. Jiang, K. Carley, and A. Eberlein, “Assessing team performance
from a socio-technical congruence perspective,” 2012 International
Conference on Software and System Process, ICSSP 2012 - Proceedings,
2012.

[31] M. A. C. Jiffriya, M. A. C. A. Jahan, and R. G. Ragel, “Plagiarism
detection on electronic text based assignments using vector space
model,” in 7th International Conference on Information and Automa-
tion for Sustainability, 2014, pp. 1–5.

[32] R. Kikas, G. Gousios, M. Dumas, and D. Pfahl, “Structure and
evolution of package dependency networks,” in Proceedings of the
14th International Conference on Mining Software Repositories, 2017,
p. 102–112.

[33] W. H. Kruskal and W. A. Wallis, “Use of ranks in one-criterion
variance analysis,” Journal of the American Statistical Association,
pp. 583–621, 1952.

[34] R. G. Kula, D. M. German, A. Ouni, T. Ishio, and K. Inoue, “Do
developers update their library dependencies?” Empirical Software
Engineering, pp. 384–417, 2018.

[35] R. G. Kula, A. Ouni, D. M. German, and K. Inoue, “On the impact
of micro-packages: An empirical study of the npm javascript
ecosystem,” arXiv preprint arXiv:1709.04638, 2017.

[36] I. Kwan, A. Schr ¨oter, and D. Damian, “A weighted congruence
measure,” in 2nd International Workshop on Socio-Technical Congru-
ence, 2009, pp. 1–10.

[37] I. Kwan, A. Schroter, and D. Damian, “Does socio-technical con-
gruence have an effect on software build success? a study of
coordination in a software project,” IEEE Transactions on Software
Engineering, pp. 307–324, 2011.

[38] Z. Li, Y. Yu, T. Wang, G. Yin, X. jun Mao, and H. Wang, “Detecting
duplicate contributions in pull-based model combining textual
and change similarities,” Journal of Computer Science and Technology,
vol. 36, pp. 191–206, 2021.

[39] W. Mauerer, M. Joblin, D. Tamburri, C. Paradis, R. Kazman, and
S. Apel, “In search of socio-technical congruence: A large-scale
longitudinal study,” IEEE Transactions on Software Engineering, pp.
1–1, 2019.

[40] E. Mirsaeedi and P. C. Rigby, “Mitigating turnover with code re-
view recommendation: Balancing expertise, workload, and knowl-
edge distribution,” in Proceedings of the ACM/IEEE 42nd Interna-
tional Conference on Software Engineering, 2020, p. 1183–1195.
[41] F. Moksony, “Small is beautiful: The use and interpretation of r2
in social research,” Szociologiai Szemle, pp. 130–138, 01 1999.
[42] M. Nassif and M. Robillard, “Revisiting turnover-induced knowl-
edge loss in software projects,” in 2017 IEEE International Confer-
ence on Software Maintenance and Evolution, 2017, pp. 261–272.
[43] J. Portillo-Rodr´ıguez, “An agent architecture with which to im-
prove coordination and communication in global software engi-
neering,” University of Castilla-La Mancha, Ciudad Real, Spain, 2013.
[44] C. Ragkhitwetsagul, J. Krinke, and D. Clark, “A comparison
of code similarity analysers,” Empirical Software Engineering, pp.
2464–2519, 2018.

[45] R. Robbes, M. Lungu, and D. R ¨othlisberger, “How do developers
react to api deprecation? the case of a smalltalk ecosystem,” in

[66] W. Zhang, S.-C. Cheung, Z. Chen, Y. Zhou, and B. Luo, “File-
level socio-technical congruence and its relationship with bug
proneness in oss projects,” Journal of Systems and Software, pp. 21–
40, 2019.

13

Proceedings of the ACM SIGSOFT 20th International Symposium on
the Foundations of Software Engineering, 2012.

[46] G. Robles and J. M. Gonzalez-Barahona, “Contributor turnover in
libre software projects,” in IFIP International Conference on Open
Source Systems. Springer, 2006, pp. 273–286.

[47] I. Samoladas, L. Angelis, and I. Stamelos, “Survival analysis on
the duration of open source projects,” Information and Software
Technology, vol. 52, no. 9, p. 902–922, 2010.

[48] J. Stringer, A. Tahir, K. Blincoe, and J. Dietrich, “Technical lag of
dependencies in major package managers,” in Proceedings of the
27th Asia-Paciﬁc Software Engineering Conference, 2020, pp. 228–237.
[49] M. Syeed and I. Hammouda, “Socio-Technical congruence in OSS
Projects: Exploring Conway’s law in FreeBSD OSS evolution,”
2013.

[50] X. Tan, M. Zhou, and Z. Sun, “A ﬁrst look at good ﬁrst issues on
github,” in Proceedings of the 28th ACM Joint Meeting on European
Software Engineering Conference and Symposium on the Foundations of
Software Engineering, 2020, p. 398–409.

[51] P. Thongtanunam, C. Tantithamthavorn, R. G. Kula, N. Yoshida,
H. Iida, and K.-i. Matsumoto, “Who should review my code? a
ﬁle location-based code-reviewer recommendation approach for
modern code review,” in 2015 IEEE 22nd International Conference
on Software Analysis, Evolution, and Reengineering, 2015, pp. 141–
150.

[52] B. Trinkenreich, M. Guizani, I. Wiese, T. Conte, M. Gerosa,
A. Sarma, and I. Steinmacher, “The pot of gold at the end of
the rainbow: What is success for open source contributors?” arXiv
preprint arXiv:2105.08789, 2021.

[53] E. Ukkonen, “Approximate string-matching with q-grams and
maximal matches,” Theoretical Computer Science, pp. 191–211, 1992.
[54] G. Valetto, M. Helander, K. Ehrlich, S. Chulani, M. Wegman, and
C. Williams, “Using software repositories to investigate socio-
technical congruence in development projects,” in 4th International
Workshop on Mining Software Repositories, 2007, pp. 25–25.

[55] M. Valiev, B. Vasilescu, and J. Herbsleb, “Ecosystem-level determi-
nants of sustained activity in open-source projects: A case study
of the pypi ecosystem,” in Proceedings of the 2018 26th ACM Joint
Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering, 2018, p. 644–655.

[56] P. Wagstrom, J. D. Herbsleb, and K. M. Carley, “Communication,
team performance, and the indiviual: Bridging technical depen-
dencies,” Academy of Management Proceedings, vol. 2010, no. 1, pp.
1–7, 2010.

[57] D. Wang, R. G. Kula, T. Ishio, and K. Matsumoto, “Automatic
patch linkage detection in code review using textual content and
ﬁle location features,” Information and Software Technology, 2021.

[58] J. Wang, “Survival factors for free open source software projects:
A multi-stage perspective,” European Management Journal, vol. 30,
no. 4, pp. 352–371, 2012.

[59] Y. Wang, B. Chen, K. Huang, B. Shi, C. jian Xu, X. Peng, Y. Liu, and
Y. Wu, “An empirical study of usages, updates and risks of third-
party libraries in java projects,” 2020 IEEE International Conference
on Software Maintenance and Evolution, pp. 35–45, 2020.

[60] Y. Win and T. Masada, “Exploring technical phrase frames from
research paper titles,” in 2015 IEEE 29th International Conference on
Advanced Information Networking and Applications Workshops, 2015,
pp. 558–563.

[61] E. Wittern, P. Suter, and S. Rajagopalan, “A look at the dynamics
of the javascript package ecosystem,” in Proceedings of the 13th
International Conference on Mining Software Repositories, 2016, pp.
351–361.

[62] Y. Yu, H. Wang, G. Yin, and T. Wang, “Reviewer recommendation
for pull-requests in github: What can we learn from code review
and bug assignment?” Information and Software Technology, pp. 204–
218, 2016.

[63] R. Yue, N. Meng, and Q. Wang, “A characterization study of re-
peated bug ﬁxes,” in 2017 IEEE International Conference on Software
Maintenance and Evolution, 2017, pp. 422–432.

[64] R. E. Zapata, R. G. Kula, B. Chinthanet, T. Ishio, K. Matsumoto,
and A. Ihara, “Towards smoother library migrations: A look
at vulnerable dependency migrations at function level for npm
javascript packages,” in 2018 IEEE International Conference on Soft-
ware Maintenance and Evolution, 2018, pp. 559–563.

[65] A. Zerouali, E. Constantinou, T. Mens, G. Robles, and J. Gonzalez-
Barahona, “An empirical analysis of technical lag in npm package
dependencies,” in New Opportunities for Software Reuse, 2018, pp.
95–110.

