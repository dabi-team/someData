2

2

0

2

n

u

J

7

1

]

R

C

.

s

c

[

1

v

2

2

7

8

0

.

6

0

2

2

:

v

i

X

r

a

© 2022 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, including
reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or reuse of any
copyrighted component of this work in other works. This is the author’s version of the work. The deﬁnitive version will be published in the proceedings of the
42nd IEEE International Conference on Distributed Computing Systems (ICDCS’22).

WATZ: A Trusted WebAssembly Runtime
Environment with Remote Attestation for TrustZone

J¨ames M´en´etrey , Marcelo Pasin , Pascal Felber

, Valerio Schiavoni

University of Neuchˆatel, Switzerland — ﬁrst.last@unine.ch

Abstract—WebAssembly (Wasm) is a novel low-level bytecode
format that swiftly gained popularity for its efﬁciency, versatility
and security, with near-native performance. Besides, trusted
execution environments (TEEs) shield critical software assets
against compromised infrastructures. However, TEEs do not
guarantee the code to be trustworthy or that it was not tampered
with. Instead, one relies on remote attestation to assess the
code before execution. This paper describes WATZ, which is (i)
an efﬁcient and secure runtime for trusted execution of Wasm
code for Arm’s TrustZone TEE, and (ii) a lightweight remote
attestation system optimised for Wasm applications running in
TrustZone, as it lacks built-in mechanisms for attestation. The
remote attestation protocol is formally veriﬁed using a state-of-
the-art analyser and model checker. Our extensive evaluation of
Arm-based hardware uses synthetic and real-world benchmarks,
illustrating typical tasks IoT devices achieve. WATZ’s execution
speed is on par with Wasm runtimes in the normal world and
reaches roughly half the speed of native execution, which is
compensated by the additional security guarantees and the inter-
operability offered by Wasm. WATZ is open-source and available
on GitHub along with instructions to reproduce our experiments.

I. INTRODUCTION

Security is critical when designing and deploying distributed
applications for mutually distrusting stakeholders, e.g., hosting
companies. The problem grows in complexity in heteroge-
neous systems, when one considers decentralised operations of
IoT, edge and cloud devices, all at risk of being compromised.
Trusted execution environments (TEEs), e.g., Intel SGX [1]
and Arm TrustZone [2], offer hardware support for securely
executing applications in shielded environments. While TEEs
are promoted by the commercial offerings of major cloud
providers, they do not guarantee that the code itself is trustwor-
thy and has not been tampered with. Remote attestation [3]–[7]
is typically used to assess the code before its execution. How-
ever, while this key security feature is provided by some TEEs
(e.g., Intel SGX [8]), Arm TrustZone lacks built-in support
for remote attestation. Given the swift growth of popularity of
Arm-based architectures in the IoT edge computing [9] and
its recent adoption in the general computer market [10], this
is concerning. In addition, recent attacks have shown how to
compromise IoT devices via malicious ﬁrmware updates [11]
or software ﬂaws [12],
typically beyond the threat model
of TrustZone. Nonetheless, the inability of manufacturers to
verify the authenticity of their software upon execution makes
these platforms inadequate for handling sensitive tasks and
data, in particular when dealing with recent scenarios such as
trustworthy machine learning systems at the edge [13].

WebAssembly (Wasm) [14] is a new bytecode standard for
running applications at near-native speed. It enables developers
to build their software components with the productivity
beneﬁts of modern programming languages while supporting
legacy code, since modern compilers support Wasm [15].
TrustZone is a constrained environment that runs small exe-
cutables using a specialised API. Wasm ﬁts well in this model,
thanks to its small runtime overhead, portability, supporting
non-standard system interfaces, and fast as the bytecode can
be compiled just-in-time and ahead-of-time.

Embedding Wasm in TrustZone can be helpful in many use
cases. The smartphone industry could rely on Wasm as an
interoperable bytecode to execute secure applications inside
TrustZone, as exclusively reserved for the manufacturer’s
needs or for strategic partners [16]. Automotive applications
could rely on IoT devices to run machine learning algorithms
inside enclaves, ensuring the validity of the results via attes-
tation and using Wasm to leverage legacy machine learning
frameworks. We demonstrate the latter in §VI-F.

We present WATZ, an efﬁcient and secure runtime for
trusted execution of Wasm code inside TrustZone, adding sup-
port for remote attestation. We leverage the sandbox isolation
of Wasm to mitigate, and possibly prevent, vertical privilege
escalations and lateral attacks. We combine TrustZone with
Wasm bytecode to issue trustworthy evidence, attesting the
genuineness of running software. In §IV, we adapted and fully
implemented the remote attestation protocol from SGX [17],
using a public-key infrastructure. As such, we facilitate the
deployment of fully decentralised applications spanning var-
ious devices at the core or the edge of the network. WATZ
extends OP-TEE [18], a popular open-source trusted OS, and
we validated our prototype with Arm hardware.

The main research questions that WATZ intends to answer,

and the main contributions of this work are the following.

RQ1: Are there system challenges when embedding Wasm

into Arm TrustZone?

TrustZone requires using a trusted operating system, which
declares a non-standardised API to interact with system re-
sources. This, coupled with the constrained nature of TEEs
(e.g., no system call, limited memory), increases the complex-
ity of hosting general-purpose applications compiled in Wasm.
We show (§III) that WATZ is the ﬁrst system to run Wasm ap-
plications in TrustZone, while leveraging the WASI standard, a
POSIX-like layer for Wasm, to interact with the TEE facilities.
As such, hosted applications seamlessly communicate with

 
 
 
 
 
 
TrustZone, while abstracting from that trusted environment’s
speciﬁc API. This software encapsulation strategy for Trust-
Zone enhances the state of the art: each software deployed
in the trusted world is fully isolated and cannot interfere with
others, similarly to SGX enclaves, thanks to the robust sandbox
provided by Wasm. Our WATZ prototype supports a subset of
WASI API to run general-purpose software and to evaluate a
database engine (SQLite [19]), as well as a machine learning
library (Genann [20]). We plan to widen the WASI support
for additional system calls, e.g., ﬁle system and networking.

RQ2: How can relying parties trust the remote execution

of Wasm applications?

Given the lack of built-in remote attestation in TrustZone,
we propose a protocol (§IV) to attest Wasm code embedded
in our trusted environment. Hence, we ensure executed Wasm
binaries are trustworthy, similarly to Intel SGX. We identify
the hardware requirements of IoT devices to provide attestable
guarantees (e.g., root of trust, secure boot), showing how to
be combined with the trusted environment to verify Wasm bi-
naries. We contribute an extension of the WASI speciﬁcations,
called WASI-RA, to enable the hosted Wasm applications to
attest against trusted parties and communicate shared secrets
and conﬁdential data, based on Intel SGX’s remote attestation
protocol. Finally, we demonstrate that WATZ is an end-to-
end solution that leverages the ﬁngerprint (i.e., a hash of the
bytecode) of isolated Wasm applications, hardware elements
and the attestation mechanism to induce trust into IoT devices.

RQ3: How does the performance of Wasm applications

compare when hosted in the trusted environment?

We extensively evaluate WATZ (§VI) against micro- and
macro-benchmarks, together with SQLite and Genann. Per-
formance is on par with Wasm applications executed outside
of the TEE, and up to 2.12× compared to native execution,
deemed negligible compared to the beneﬁts WATZ offers. We
contribute and describe an extension of the trusted kernel (OP-
TEE) to execute ahead-of-time compiled Wasm applications to
achieve these performance results. Besides, we perform a se-
curity analysis of WATZ (§VII), as well as formal veriﬁcation
of the remote attestation protocol.

Roadmap. The remainder of the paper is organised as fol-
lows. We ﬁrst present background information and related
work in §II. §III introduces the overall design and architecture
of our WATZ runtime. The remote attestation mechanism of
WATZ is described in §IV. We elaborate on some implemen-
tation details in §V and present our extensive evaluation of
WATZ in §VI. We analyse the security of our approach in
§VII, before concluding in §VIII.

II. BACKGROUND AND RELATED WORK

Our WATZ runtime supports trusted execution of Wasm
code inside TrustZone with remote attestation mechanisms.
This section brieﬂy introduces the underlying technologies and
highlights how our approach improves related work.

Arm TrustZone.
It provides the hardware elements enabling
TEEs on Arm processors [21]. TrustZone enables a single TEE
per system, called secure world, as opposed to the normal
world, the untrusted environment. The CPU lives between
two security states: secure and normal worlds, switching
via a secure monitor instruction (SMC). System resources are
strictly isolated: the normal world cannot access the resources
(e.g., memory, peripherals, etc.) reserved for the secure world.
During the secure bootstrap of the secure world, an integrity
check of its software image establishes a chain of trust.

OP-TEE [18] is a popular open-source runtime environment
with native support for TrustZone. It offers a developer-
friendly setup [22] to build trusted applications. OP-TEE
follows the TEE architecture and API standardised by Glob-
alPlatform (GP API) [23], built around three components: a
client application, a dedicated Linux driver and the OP-TEE
OS. The OS of the normal world is referred to as rich execution
environment (REE). The host application runs in the normal
world, as a client of a trusted application (TA) in the secure
world. Host applications leverage client APIs.

WebAssembly. Wasm [14] is a W3C open standard for a
portable, compact,
low-level, stack-based binary code for-
mat. Initially intended for building browser applications, the
speciﬁcations allow for standalone execution running outside
browsers. We exploit the Wasm’s sandbox capabilities, includ-
ing software fault isolation [24] and control-ﬂow integrity [25]
to isolate Wasm code from the trusted OS. We also leverage
the WebAssembly system interface (WASI) [26], a POSIX-
like interface used by Wasm programs to interact with the
underlying OS. WASI acts as a mediator between the Wasm
application and the GP API. As a result, many programming
languages (e.g., C/C++, Rust, Swift, Go) can target Wasm with
WASI so they require no modiﬁcation to run as Wasm binaries.

WebAssembly and TEEs. Few options exist to host Wasm
applications inside TEEs. TWINE [27], an embedded trusted
runtime for WebAssembly, executes Wasm applications inside
Intel SGX enclaves. TWINE relies on the WebAssembly micro
runtime (WAMR) [28], enabled with WASI to interact with
a secure ﬁle system. Enarx [29] targets Intel SGX enclaves
and AMD SEV virtual machines. Veracruz [30] only supports
VM-based TEEs, such as Arm CCA [31] and AWS Nitro [32]
enclaves, having recently dropped SGX and TrustZone en-
claves considered too constraining [33]. AccTEE [34] and Se-
Lambda [35] run Wasm binaries in Intel SGX enclaves using
the V8 JavaScript/Wasm engine. AccTEE provides trusted
resource accounting, while Se-Lambda deploys serverless pro-
grams over function-as-a-service. Contrary to the mentioned
solutions, WATZ runs on Arm TrustZone, leverages WASI for
system interactions and supports trustworthy code execution,
thanks to the close integration with Wasm and the remote
attestation mechanism. We propose a functional paradigm for
Arm TrustZone: every hosted Wasm application is isolated
from the rest of the trusted world via the Wasm sandbox.
We note that OP-TEE requires every TA to be signed to be
trusted and executable in the trusted world. This is a signiﬁcant

AOT WASI RA
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:55)
(cid:55)
(cid:51)
(cid:55)
(cid:51)
(cid:55)
(cid:51)
(cid:51)

(cid:51)
TWINE
(cid:55)
Veracruz
(cid:55)
Enarx
(cid:55)
AccTEE
Se-Lambda (cid:55)
(cid:55)
Teaclave
(cid:51)
WATZ

RA in
WASI
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)

µRT
(cid:51)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)

IoT
TEE
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)

TEE(s)

SGX
Nitro, CCA
SGX, SEV
SGX
SGX
SGX
TrustZone

TABLE I: Comparison of the related work features.

impediment when offering trusted execution for third parties,
which is solved with WATZ. This approach maintains the
security of TrustZone thanks to the isolation of Wasm sandbox.
Table I compares WATZ against state-of-the-art TEE run-
times for Wasm along the following dimensions: AOT (process
ahead-of-time compiled Wasm bytecode), WASI (enable sys-
tem interaction), RA (support remote attestation), RA in WASI
(provide a WASI API to control the remote attestation in the
hosted Wasm application), µRT (use a small runtime, less than
1 MB in memory), IoT TEE (designed for IoT devices), and
TEE(s) (summarises the TEE technologies).

Remote attestation (RA). It veriﬁes the genuineness of
software in a remote process. It relies on a challenge-response
protocol [36]. An attester must prove the software’s uncom-
promised state. It shares evidence (a quote in the SGX jargon)
to a veriﬁer, which assesses its genuineness. The evidence
is a cryptographically signed proof of claims, i.e., pieces of
asserted information, such as a code measurement hash. The
veriﬁer is conﬁgured with references values, compared against
the received claims for validation. Finally, endorsements are
secure statements used by the veriﬁer to identify the devices
eligible to issue trustworthy evidence.

Remote attestation can be based on software, hardware or a
combination of both [37], [38]. Recent work addresses the
remote attestation mechanisms and protocols, including for
IoT and edge devices [4], [39]–[44]. Intel SGX has built-in
support for remote attestation [45]. WATZ follows the same
principles to deliver RA on code executed on Arm processors.
Ling et al. [46] proposed a trusted boot mechanism with
remote attestation of software running in Arm’s normal world.
Similarly to WATZ, they leveraged OP-TEE to ensure the boot
and runtime state of IoT devices are trustworthy. However,
their approach depends on the integrity of the normal world
kernel. Our proposal does not rely on a dependable OS in the
normal world: the attested software runs isolated in the secure
world. WATZ extends the design of Intel’s remote attestation
protocol to use software enclaves created in the trusted world,
through isolation within Wasm sandboxes. WATZ is strongly
integrated with Wasm by providing WASI-RA. As such, it
is the ﬁrst system enabling the hosted Wasm applications to
control the remote attestation process. WATZ measures the
Wasm bytecode that bootstraps the enclave to issue evidence.
third parties will remotely appraise software
As a result,
and authenticate IoT edge devices by leveraging TrustZone,
a hardware-based root of trust and secure boot, to build a
hardware-enforced attesting environment.

Fig. 1: Overall architecture of WATZ.

III. WATZ: SYSTEM OVERVIEW
This section introduces WATZ’s threat model, design, ar-

chitecture, and details of the trusted runtime.

Threat model. We consider the following aspects.

(a) Hardware. WATZ leverages the following hardware
capabilities: (i) TrustZone security extensions, (ii) a root of
trust, and (iii) secure boot. While we consider a powerful
attacker with physical access to the devices, we assume that the
protections offered by hardware cannot be subverted. As such,
the adversary may fully control the system on a chip (SoC)
as well as its peripherals, but excluding all the components
belonging to TrustZone. Consequently, WATZ cannot defend
itself from physical attacks to the volatile memory space as-
signed to TrustZone, which is not encrypted, unlike Intel SGX.
We also consider storage rollback attacks out of scope, which
can be mitigated using hardware monotonic counters [47].

(b) Secure world. We assume the secure monitor, bootloader
and trusted OS do not contain vulnerabilities enabling an
attacker to breach the TEE. The cryptographic primitives and
algorithms are considered correct. Code and data inside the
TEE are trusted and cannot be accessed from the normal world,
except through dedicated channels controlled by WATZ. Fi-
nally, side-channel attacks [48]–[52] are out of scope.

(c) Normal world. We make no assumption regarding the
normal world, which includes the rich OS and the user space.
Compromised OSes may arbitrarily respond to trusted OS
calls, causing its malfunction. The trusted applications relying
on the normal world should be carefully crafted to ignore
abnormal responses or even abort execution in such cases.

Design overview. WATZ is a trusted runtime to execute
Wasm applications with remote attestation capabilities. Fig. 1
illustrates its components. Its small footprint (265 kB on disk,
including the runtime and WATZ’s components) brings several
advantages. Smaller programs offer smaller attack surfaces.
TEEs and small devices (edge or IoT) are usually tight in
memory. Its small footprint allows deploying and running
a complete Wasm virtual machine inside TrustZone using a
small edge-scale Arm processor. We estimate that the increase
of the trusted computing base (TCB) due to the embedding of
the Wasm runtime in the TEE is outweighed by its beneﬁts.
To provide trusted OS features to Wasm applications, we
contribute an adaptation layer that binds WASI to the API
existing in the trusted environment (GP API in our prototype).
This, in conjunction with the reliance of Wasm applications on
WASI, allows WATZ to run unmodiﬁed Wasm applications,
while beneﬁting from a TEE. While we support a subset of the

HardwareKernel spaceUser spaceLinuxNormal worldHardwareKernel spaceUser spaceSecure worldWaTZ runtimeWasm system interface (WASI)Wasm binaryOP-TEERoot of trustSecure bootWaTZ attestation serviceSandboxWasm binaryUser application!WASI API enabling to execute general-purpose software, the
adaptation layer is effortlessly extensible to support additional
system calls, such as ﬁle system and networking.

To offer remote attestation, we designed and implemented
WASI-RA, an extension of WASI enabling the hosted Wasm
applications to interact with the process of attestation. We
guarantee that WATZ is booted correctly and was not tampered
with using a secure boot system. When WATZ loads a Wasm
application, its bytecode is stored in the secure memory and
measured to produce a hash. Using our interface, a Wasm
attester can request WATZ to generate trusted evidence based
on the hardware secret and the hash of the Wasm bytecode.
Further, WATZ includes a remote attestation protocol to enable
a third-party veriﬁer to check if evidence is genuine, which
relies on the measured ﬁngerprint of the Wasm applications.
Upon positive attestation, our protocol simpliﬁes the establish-
ment of a hybrid cryptosystem for the veriﬁer and the attester,
which can be later used to create secure channels.

it

Embedded runtime. We built WATZ as an embedded Wasm
runtime with a WASI interface as this design provides several
advantages, i.e., removing some barriers for building TAs.
First, WATZ opens the choice for programming languages.
the compiler can emit Wasm bytecode and
Provided that
supports WASI,
is a clear advantage over vanilla OP-
TEE, which limits developers to C only. Second, this hides
the complexity of writing code dedicated to OP-TEE since
WASI calls are generated by the compiler and they abstract
the implementation details of GP API. Furthermore, Web-
Assembly separates the virtual address spaces used for Wasm
applications and the native runtime process, and code, stacks
and heap are handled separately, making memory-oriented
attacks or developer mistakes more unlikely. Besides, WASI
ensures that the applications do not harm the secure world
and acts as a gatekeeper to run operations outside of the
runtime. Finally, applications are not tightly coupled to the
underlying TEE, and WATZ can load any regular Wasm/WASI
application without changes. As a result, Wasm brings more
ﬂexibility, versatility and security compared to their native
counterpart, allied with its strong sandboxing mechanism that
isolates each hosted Wasm application. This newly introduced
isolation layer extends the single trusted world of TrustZone to
an environment with multiple secure and mutually distrusting
enclaves, similarly to the isolation scheme offered by Intel
SGX. Hence, WATZ changes the paradigm of software de-
ployment and execution of the secure world to a more relaxed
approach, which previously required a trusted application to
be signed, while not introducing any security drawback.

Instances of trusted Wasm applications are started by a user
space process in the normal world, which uses the standard
OP-TEE API to prepare a buffer containing the Wasm applica-
tion and trigger WATZ in the secure world. Once in the secure
world, WATZ copies the bytecode into a secure, sandboxed
memory, calculates the hash for future attestation and starts
the execution immediately. Wasm applications natively use
the standard WASI interface to interact with the OS, which,

in turn, diverts the calls to WATZ. We implemented the
WATZ attestation service as a new kernel module for OP-
TEE, enabling the runtime to generate evidence for relying
parties to prove the applications’ authenticity. While several
open-source alternatives exist
to execute Wasm code, we
settled for WAMR [28], a lightweight and embeddable runtime
implemented in C, ideal for TEEs in general (small TCB) and
OP-TEE in particular, since TAs are written in C.

Execution modes. WAMR can execute code in three modes,
each with its beneﬁts and drawbacks: interpreted, compiled
just-in-time (JIT) and compiled ahead-of-time (AOT). Inter-
preted is the simplest yet slowest, as it does not require pre-
processing the bytecode. When using JIT compilation, the
bytecode is translated into native code whenever executed, but
embedding a compiler in the runtime increases its complexity,
size and dependencies. Indeed, WAMR uses LLVM [15] as
its JIT and AOT compiler, which is not trivial to port to a
restricted environment like OP-TEE. With AOT compilation,
the bytecode is translated before execution, so the runtime
does not need to include a compiler, but requires the TA to
allocate executable memory. We opted for AOT compilation
for WATZ’s runtime. However, OP-TEE’s memory manage-
ment API cannot modify the pages’ protection to mark them
as executable [53]. Hence, we extended the trusted kernel to
provide such capabilities to TAs. The AOT execution speed is
on average 28× faster than with interpretation.

IV. REMOTE ATTESTATION OF WEBASSEMBLY

This section presents the remote attestation mechanism, ﬁrst
by explaining how the hardware is trusted, extending this
principle to the secure OS and WATZ.

Root of trust. We designed WATZ for devices that expose
a hardware root of trust to the secure world. We extended OP-
TEE to deterministically derive a key pair from the hardware
root of trust. Normal and secure OS can hence be updated
without losing the key materials, and on-chip key genera-
tion guarantees that the private key never leaves the trusted
kernel OS. The public key is then exported and used as an
endorsement value to be veriﬁed during remote attestation
requests. This key pair, called attestation keys, is at the core
of WATZ’s mechanisms to provide attestable signatures and
guarantee platform authenticity.

Secure boot. Secure boot is a security mechanism to ensure
that the device is booting in a trusted state. WATZ requires the
device to implement secure boot, so only trusted entities are
able to provision software to boot the secure world (a couple
of bootloaders and the trusted OS). Therefore, this enforces
a chain of
that protects the attestation keys against
extraction from the secure kernel OS. The boot sequence is
as follows: the ﬁrst-stage bootloader (ROM) veriﬁes if the
second-stage bootloader is genuine, based on the public key
stored in one-time programmable fuses (eFuses) [54]. The
previous booting component recursively veriﬁes the next boot
stages until the secure world is fully booted.

trust

trust:

Proof of
the evidence. WATZ generates crypto-
graphically signed reports, called evidence, asserting that an
executing Wasm application is trustworthy and the device
genuine, by producing a hash of the Wasm AOT bytecode
stored in the secure memory at launch time. We offer an
API to Wasm applications (see WASI-RA in §V) to issue
evidence and establish a secure communication channel with
a veriﬁer. Then, the evidence is checked by the veriﬁer using
the corresponding public key of the device and examines the
code measurement to match its reference values.

The evidence is created by interacting with the attestation
service, implemented as a kernel module in OP-TEE (shown in
Fig. 1). The evidence includes (i) an anchor, which is a value
deﬁned by the transport layer to bind security parameters to a
particular session (e.g., a public session key), (ii) the version of
WATZ, enabling the relying party to exclude outdated systems,
(iii) the claim, i.e., the bytecode hash, (iv) the public key of the
attestation service, for the veriﬁer to determine if the device
is endorsed, and (v) the digital signature of the evidence.

Security requirements. Our remote attestation protocol sat-
isﬁes a number of security requirements as speciﬁed below:
1) Mutual key establishment: A shared secret key is estab-
lished for communication between the attester and the
veriﬁer, using the elliptic-curve Difﬁe–Hellman ephemeral
(ECDHE) key-agreement protocol.

2) Mutual entity authentication: The attester and the veriﬁer
are mutually authenticated to prevent masquerading attacks.
From the attester’s standpoint, the veriﬁer’s public key must
be hardcoded into the Wasm application. This, combined
with the application measurement, ensures that an attacker
cannot change the key so that
the software can only
communicate with the intended remote service.

3) Half trust assurance: The attester attests the Wasm applica-
tion and the platform integrity to the veriﬁer. The veriﬁer
does not provide a similar proof to the attester, and the
attester assumes the entity authentication is sufﬁcient.
4) Freshness: ECDHE (ephemeral) requires the key pairs to

be fresh, hence preventing replay attacks.

5) Forward secrecy: Compromised long-term secrets do not
affect the security of earlier or future exchanges. Similarly
to freshness, ECDHE achieves this goal, which means the
keys are renewed for every tentative of remote attestation.

WATZ protocol for remote attestation. The GP API de-
ﬁnes an interface to establish a secure communication channel
using TLS. However, OP-TEE lacks the corresponding imple-
mentation [55], [56]. We extended and implemented the RA
protocol of Intel SGX [17] (itself inspired by SIGMA [57])
to not rely on TLS. We changed the protocol compared to the
original in various aspects: (i) removed the SGX speciﬁcities,
such as the interaction with the quoting enclave, as the kernel
module of WATZ provides the measurements, (ii) merged the
two ﬁrst messages to communicate from the client to the server
as they tightly relate, (iii) provided a ﬁxed structure for the last
message to seamlessly handle conﬁdential data, eliminating
the burden of a hosted Wasm application from decrypting that

:= Gv (cid:107) V (cid:107) SIGNV (Gv (cid:107) Ga)

msg0
msg1

msg2

msg3

:= Ga
:= content1 (cid:107) MACKm (content1)
(cid:44)→ content1
:= content2 (cid:107) MACKm (content2)
(cid:44)→ content2
(cid:44)→ evidence
(cid:44)→ anchor
:= iv (cid:107) AES-GCMKe (data)

:= Ga (cid:107) evidence (cid:107) SIGNA(evidence)
:= (anchor (cid:107) A (cid:107) . . .)
:= HASH(Ga (cid:107) Gv)

TABLE II: The remote attestation protocol of WATZ.

content, (iv) omitted Intel’s SGX Enhanced Privacy ID (EPID)
for conciseness, and (v) removed the dependency on Intel’s
PKI, since the device’s key pair is emitted by WATZ based
on the embedded root of trust. Table II formalises the remote
attestation protocol. Below, we detail each protocol’s message
and the required cryptographic operations.
(a) Message 0 (attester→veriﬁer): The attester generates a
session key pair < a, Ga > and sends the public part Ga.
(b) Message 1 (attester←veriﬁer): Upon reception of msg0, the
veriﬁer generates a session key pair < v, Gv >. It computes
the shared secret from the public session key of the attester Ga
and its private session key v, which gives Gav. This shared
secret is derived into a key derivation key (KDK), which is
further derived into two shared secrets: Km for calculating
MACs and Ke for future messages encryption in the session.
These derivations are the same as in Intel SGX [17]. A reply
message is sent to the attester, containing Gv, the veriﬁer’s
ECDSA public key V (its identity), and a signature of both
public session keys. The message is appended with a MAC.
(c) Message 2 (attester→veriﬁer): The attester veriﬁes the
signature of the public session keys: different session keys
may reveal a masquerading or replay attack, and assesses the
MAC of msg1. It also checks whether the service public key
V matches the hardcoded key in the Wasm application. Doing
so ensures the attester communicates with the intended service
and prevents an attacker from altering that key as it is part of
the code measurement. The attester computes the shared secret
from the public session key of the veriﬁer Gv and the private
session key a, which gives Gva that is equal to Gav computed
by the veriﬁer. The key derivations follow the same process
as in msg1. The attester creates msg2 by concatenating its
public session key Ga with a newly generated evidence (see
§IV for details) signed by the attester A, where the anchor of
the transport layer is the hashed concatenation of the public
session keys. Finally, it appends a MAC.
(d) Message 3 (attester←veriﬁer): The veriﬁer checks the
MAC of msg2 and veriﬁes that Ga matches the one received
in msg0. It also examines whether the anchor corresponds to
the public session keys, revealing a masquerading or replay
attack. It extracts the evidence’s public attestation key and
checks against its list of endorsed public keys to determine
whether this is a known device. If the key is found,
the
digital signature of the evidence is checked, which indicates
whether the hardware is genuine. Finally, to verify that the
Wasm application is trustworthy, its code measurement claim
is compared with a list of possible reference values. If all

Fig. 2: Components of the prototype.

veriﬁcations pass, the protocol sends msg3 with an arbitrary
conﬁdential data, called secret blob, encrypted with AES-
GCM, which requires iv (an initialisation vector).

We simpliﬁed the protocol by omitting the use of session
identiﬁers. Such identiﬁers are needed for having multiple
sessions with concurrent remote attestation requests. We also
reduced the complexity by keeping the evidence in clear. If
the secrecy of this structure is a concern, the protocol can be
extended to protect the evidence using AES-GCM. Later, in
§VII, we describe how we formally veriﬁed this protocol.

V. IMPLEMENTATION

This section described the implementation details of WATZ.
Note that our prototype requires the following features from
the underlying hardware platform: (i) a root of trust, (ii) a
secure boot to harden a chain of trust, and (iii) the TrustZone
extensions in the CPU. As said, WATZ relies on OP-TEE, and
we detail the extensions in the following.

Overview. Fig. 2 illustrates the components of our prototype,
which reﬂects the architecture deﬁned in §III. It comprises
an attester and a veriﬁer. Initially ((cid:202)), a Wasm application
is loaded by the normal world in the TEE. WATZ runtime
copies the bytecode into the secure memory, measures it and
executes the application. Later on, the hosted application can
use remote attestation to fetch the secret blob from a relying
party. This consists of contacting a veriﬁer to create a secure
communication channel ((cid:203)). An anchor value is associated
with the RA handshake, which is forwarded to the attestation
service in the trusted kernel to issue evidence ((cid:204)). Lastly,
the veriﬁer checks whether the device is genuine, based on
the evidence: if trustworthy, it sends the secret blob using
the secure channel ((cid:205)). In the remainder of this section, we
describe further details of the inner working of WATZ.

The runtime (attester). Our Wasm runtime is a trusted
application written in C (1.6 k SLOC), statically linked to a
modiﬁed version of WAMR. As Wasm applications call the
OS using WASI, we implemented a WASI interface, mapping
its calls to the functions available in the GP API. To ﬁnd all
the required calls used to execute our experiments properly,
we ﬁrst manually coded dummy functions for all 45 WASI
API functions, throwing exceptions when called. Then, we
implemented adapters for the WASI functions necessary for
our benchmarks (0.9 k SLOC) to use whatever was available
in GP. While our experiments could successfully be executed
without adding extra features to GP, many standard function-
alities (e.g., thread management) are not supported by TAs.
However, we note that with some extra engineering efforts,

WATZ may be completed to support ﬁle system interaction via
the Trusted Storage API and support other missing functions
leveraging (parts of) an embedded C library or a library kernel.
The GP API includes TCP/IP sockets, implemented by OP-
TEE. Under the hood, the trusted kernel redirects the commu-
nication to the normal world, using a small shared memory
buffer to transfer data. OP-TEE comes with a built-in user
space supplicant daemon that runs in the normal world and is
responsible for services such as network communication.

When starting a Wasm application, its AOT compiled byte-
code is copied by the runtime from the normal world. The
implementation of OP-TEE does not allow TAs to access
memory from the normal world directly. Instead, the normal
world allocates a shared memory buffer accessible by both
worlds. OP-TEE limits the amount of memory available for
shared buffers. We increased the limit to 9 MB (the largest
value that would not break OP-TEE). A similar problem occurs
when allocating memory inside the trusted world, which we
modiﬁed to allow up to 27 MB. Pushing further the memory
limits leads to OP-TEE malfunctions. A quick investigation of
its code indicates the likely reasons to be in the data structures
used to maintain memory regions, not the Arm architecture
itself [56]. According to the GitHub repository, increasing
the memory cap of OP-TEE is a recurring request, and
workarounds vary depending on the hardware. We believe that
such limits could be removed (or pushed much further away)
in future versions of OP-TEE. As our implementation and
experiments did not require substantial amounts of memory,
we did not address these constraints.

Wasm applications are loaded by the runtime rather than
by the regular native loader of OP-TEE. As such, WATZ is
required to allocate executable memory pages to store the AOT
compiled bytecode. We extended OP-TEE to provide such
capability by implementing an additional system call simi-
larly to POSIX mprotect. Consequently, WATZ can allocate
executable memory pages to run AOT Wasm bytecode, which
is ARM64 assembly code. We plan to submit a pull request
with this improvement to the OP-TEE upstream repository.
The server (veriﬁer). Our prototype implements a server
application that acts as a veriﬁer in the remote attestation
protocol. It comprises two parts: (i) the listener in the normal
world and (ii) the veriﬁer as a TA in the secure world. While
the veriﬁer is currently implemented as a TA written in C
(1.4 k SLOC), any environment that supports the cryptographic
operations mentioned in §IV can host this service. As such, the
remote attestation server could be executed in an Intel SGX
enclave or as a plain service in a regular OS.

Contrarily to the attester, the veriﬁer must have a dedicated
application in the untrusted side of the TEE because the GP
API for sockets lacks the capability of listening for incoming
connections. For that matter, the messages are received in the
listener application and forwarded to the TA. Similarly, the
messages generated by the TA are handed to the untrusted
application for delivery. Messages are stored in shared memory
buffers, and their handling occurs in the secure memory, acting
as the TEE-supplicant provided by OP-TEE.

AttesterUser spaceNormal worldKernelUser spaceSecure worldWaTZ runtimeWasm binaryWaTZ att. svc.Wasm binaryUser app.!+ hashWASI➊➋TEEsupplicant➍➌User spaceSecure worldConfidentialdata!User spaceNormal worldVeriﬁerlistener➋➍WaTZveriﬁer➋➍VeriﬁerThe attestation service. We designed WATZ to ofﬂoad the
signing of evidence to a dedicated trusted kernel module,
called the attestation service (0.5 k SLOC). It plays a critical
role in WATZ as it has access to the private attestation key.
The attestation service, located in the kernel space of OP-TEE,
prevents the key materials from being exposed to the TAs in
the user space. Hence, the Wasm runtime communicates claims
to the attestation service for evidence generation.

In order to establish a root of trust, our hardware is
equipped with a cryptographic accelerator and assurance mod-
is a unique 256-bit one-
ule (CAAM). The root of trust
time programmable key (OTPMK), fused into hardware at
manufacturing time. The CAAM provides two different hashes
of OTPMK, depending on if the requesting thread is in the
normal or in the secure world. This hash is called the master
key veriﬁcation blob (MKVB). The MKVB is then used as a
seed to provision secrets only known by a kernel module in
OP-TEE [54], [58]. We modiﬁed OP-TEE to expose the total
size of the MKVB as it only supported 128-bit hardware keys.
We used the library LibTomCrypt [59] for cryptographic
operations, since OP-TEE already uses it. We decided to use
elliptic-curve cryptography (ECC) to reduce the key size for
faster transmission and lower processor consumption, while
offering the same level of security compared to RSA with
a large modulus [60]. We selected the curve secp256r1 as
recommended by the NIST [61], as well as the follow-
ing algorithms: (i) elliptic-curve digital signature algorithm
(ECDSA) (256-bit) for the attestation key pair, (ii) ephemeral
elliptic-curve Difﬁe–Hellman (ECDHE) (256-bit) for the ses-
sion keys of the remote attestation protocol, (iii) AES-GCM
(128-bit) for data encryption and authentication, (iv) SHA
(256-bit) for the anchor in the evidence, and (v) AES-CMAC
(128-bit) for the message authentication code (MAC) of the
messages, to derive the KDK and shared keys.

We also extended OP-TEE to generate an attestation key
pair at each boot, in a deterministic manner, based on the
hardware root of trust. To accomplish this task, we modiﬁed
LibTomCrypt in OP-TEE to include a pseudorandom number
generator (PRNG) named Fortuna, as the OP-TEE’s PRNG
does not support seeds. Furthermore, we changed the wrapper
of LibTomCrypt to generate an ECC key pair with a seed
fed into Fortuna. The current implementation of the wrapper
for key generations relies on a single instance of PRNG that
uses hardware randomness. The generation of the ECDSA key
pair is done in two steps: ﬁrst the MKVB is derived using
the built-in function huk subkey derive, then the resulting
value is used as a seed for Fortuna, and the ECDSA key pair
is generated using that PRNG instance.
Extension to WASI: WASI-RA. We propose WASI-RA, an
extension to WASI for remote attestation, implementing the
mechanism designed in WATZ. This enables hosted Wasm
applications to control
the remote attestation ﬂow. In the
remainder of this section, we brieﬂy describe these functions.
The Wasm runtime exposes two functions for evidence
generation to Wasm applications: wasi ra collect quote
and wasi ra dispose quote. The former issues evidence

based on an anchor given as a parameter, ensuring freshness
and uniqueness. The evidence is returned in the form of an
opaque handle. The latter requires a handle of evidence and
disposes of it. These two functions are deliberately not coupled
to the attestation protocol to be used with other transport layers
(e.g., TLS).

The remaining WASI-RA functions implement the attes-
tation protocol. wasi ra net handshake sends and re-
ceives msg0 and msg1 (i.e.,
the handshake), according to
a host address and the identity (public ECDSA key) of
the veriﬁer. The remote party’s identity is usually hard-
coded in the application, so the code measurement en-
ables the server to detect whether it has been maliciously
changed. A remote attestation context and an anchor are
returned in opaque values;
the latter is used to generate
evidence. The functions wasi ra net send quote and
wasi ra net receive data send the evidence (msg2) and
receive the secret blob (msg3), respectively. The secret blob
is retrieved as a byte array with a variable size. Finally,
the context of the remote attestation is disposed of using
wasi ra net dispose.

VI. EVALUATION

Our evaluation answers the following questions: (i) are time
measurements sufﬁciently accurate inside TrustZone, and if
not, how can we improve this? (ii) what is the performance
overhead for compute-bound Wasm applications in TrustZone?
(iii) how do real-world applications, compiled as Wasm,
perform in TrustZone? (iv) what are the cost factors of our RA
protocol? (v) what is the overhead of running a machine learn-
ing application using the RA protocol? We respectively answer
these questions by assessing the usage of monotonic timers
(§VI-A), using a general-purpose computing-bound evaluation
with PolyBench/C (§VI-C), evaluating SQLite as a real-world
embeddable database (§VI-D), breaking down the cost of our
remote attestation operations (§VI-E) and assessing an end-to-
end machine learning scenario using Genann (§VI-F).

Experimental setup. All experiments run on an off-the-
shelf NXP MCIMX8M evaluation board, equipped with i.MX
8MQ, an Arm Cortex-A53 (1.5 GHz) SoC with the Armv8-A
architecture. In the $100 price range, this board supports the
hardware root of trust, secure boot, and the CPU fully supports
TrustZone. The normal world OS is compiled using BuildRoot
2021.02, with the Linux kernel 5.13 forked by Linaro to ensure
compatibility with OP-TEE. The secure world OS runs OP-
TEE 3.13. The bootloaders are U-Boot 2020.10-rc2 and Arm
Trusted Firmware 2.3.

We show the median and standard deviation of multiple
runs for each experiment, as speciﬁed with each benchmark.
For most experiments, the standard deviation is very small.
The native benchmarks are compiled, using GCC 9.2.1 and
-O3 optimisation. The Wasm benchmarks are compiled by
WASI-SDK, which uses Clang 11 with the same optimisation
ﬂag. Our implementation is open-source, and instructions to
reproduce our experiments are available on GitHub [62].

Fig. 3: Time retrieval and world transition latencies.

A. Time measurements in TrustZone

The time resolution of the measurements inside TrustZone,
is in milliseconds. To
offered by default from OP-TEE,
achieve nanosecond resolution, we implemented and evaluated
the following changes across all involved software stacks to
retrieve the same time as provided by the monotonic clock of
the Linux kernel in the normal world. For native applications
compiled for the normal world, the time is returned using the
standard POSIX function clock gettime. However, native
applications in the secure world do not have a standardised
way to retrieve the same time. Hence, we modiﬁed the
OP-TEE driver to add a function for passing the value of
the monotonic clock to the secure world. We also extended
the GP’s type TEE Time to measure our experiments with
a nanosecond precision. Finally, Wasm applications rely on
WASI with the function clock time get. Doing so, WASI-
SDK [63] seamlessly maps it to the POSIX clock gettime.
Trusted applications require to specify the heap and stack
sizes at compile time. As such, we allocated a heap size
of 2 MB and a stack size of 3 KB for this benchmark. This
amount comprises the memory of the runtime, the bytecode
of the Wasm application and the space of the virtual heap and
stack allocated by WATZ to execute the Wasm program.

Fig. 3a shows the latencies to fetch the time in two settings,
respectively, from native trusted applications and Wasm in
TEE. We ran each experiment 1000 times. The time required
in normal world for native and Wasm programs is under 1 µs
(not shown). The average latency of retrieving the time in
the secure world is 10 µs for native applications and 13 µs for
Wasm applications. The increase is due to a transition to the
normal world for each query. The benchmarks presented in
the following of this section take such latency into account.

Fig. 3b shows the time to switch between worlds, a fre-
quent operation when an application is partitioned to execute
sensitive operations in TrustZone. In WATZ, the server of the
veriﬁer invokes functions inside the TEE once received by the
TCP server. Our micro-benchmark registers the time in the
normal world, before and after the TEE invocation. Similarly,
we measured the time in the secure world, upon a function call.
We observed an average time of 86 µs to call a function in the
secure world, and 20 µs to return, as observed earlier [64].

B. Startup Overhead

Next, we evaluated the startup overhead of Wasm applica-
tions loaded into WATZ. For that purpose, we created nine
Wasm programs with a code size that varies from 1 to 9 MB.
The AOT compiled Wasm binaries have been generated by
unrolling thousands of loop iterations to output an amount of

Fig. 4: Startup breakdown of Wasm applications in WATZ.

code with a size of 1 MB. That output is replicated multiple
times to create the nine variants. Afterwards, we measured the
time from the instruction that requests the launch of Wasm
application in the normal world until the ﬁrst instruction in
the Wasm application is executed. Finally, the Wasm program
stops after the ﬁrst Wasm instruction since we measure the
startup time, preventing the loops from being executed.

We allocated a heap size of 23 MB, which is the smallest
amount of memory to launch the application of the largest size
(9 MB). We identiﬁed that the overhead of memory, roughly
twice the application code size, was bound to the reloca-
tion symbols LLVM generated in the AOT compiled Wasm
programs. The Wasm runtime (WAMR) allocates a dedicated
structure for each relocation entry. Hence, we determined that
the loading operation of an AOT compiled Wasm binary in
the runtime may double the size to allocate, depending on the
structure of the code. One way to reduce that overhead is the
use of the experimental feature of the ahead-of-time compiler
called execution in place, which generates as few as possible
AOT relocations. We leave this optimisation as future work
since this feature still has known issues.

Fig. 4 shows a breakdown summary of the various internal
operations when loading the previously mentioned Wasm
applications within WATZ. The large majority is dedicated
to allocating the memory for the Wasm AOT bytecode (5%),
initialising the Wasm runtime (16%) and loading the bytecode
(73%). The memory allocation creates two buffers: (1) to store
the Wasm AOT bytecode in the secure memory and, (2) for the
heap of the Wasm application. The initialisation of the runtime
consists of creating the Wasm runtime environment, initialising
the memory allocator, and registering native symbols (i.e., the
binding of the native functions imported by the Wasm appli-
cation). The loading phase parses the bytecode and creates the
internal structures required to run Wasm applications, similarly
to loading a normal world process. This phase notably includes
the loading of the relocation entries. Hashing the bytecode
takes 4% of the time on average. The hash is later embedded
in the evidence issued during the remote attestation process.
Each of the remaining categories (i.e., the time to transition to
the secure world, Wasm instantiation and execution) takes less
than 1% of the startup time. Compared to the baseline Wasm
runtime in the normal world (WAMR), the overhead added by
WATZ is the transition time and the hashing operation, which
represents roughly an increase of 5%.

NativeTAWaTZ051015201013Latency[µs]Jbetter(a)TimeretrievalEnterLeave0501008620(b)TrustZonelatency050100150200250300350400450500123456789Time[ms](JLowerisbetter)Applicationsize[MB]TEE:TransitionMemoryallocationHashingWasm:InitialisationLoadingInstantiateExecutionFig. 5: Performance of PolyBench/C, normalised against native (unsecure/REE world).

Fig. 6: Performance of SQLite’s Speedtest1, normalised against native (unsecure/REE world).

C. Wasm micro-benchmarks: PolyBench/C

D. Wasm macro-benchmarks: SQLite

PolyBench/C [65] is a CPU-bound benchmark suite com-
monly used to evaluate compiler optimisations [66] and often
used for comparative analysis of Wasm environments [34],
[67], [68]. We use all the tests in the PolyBench/C suite
(v4.2.1b), executed individually 50 times. We compare Wasm
executed ahead-of-time in the normal world (using WAMR)
and in the secure world (using WATZ), against native execu-
tion (Arm, baseline). Due to memory limitations in the secure
world imposed by OP-TEE, we rely on the built-in medium
dataset of PolyBench/C for all 30 applications. We allocated a
heap size of 12 MB for WATZ, which is sufﬁcient to execute
all the tests of the benchmark suite.

Fig. 5 shows these results. In both normal and secure worlds,
we observe that Wasm’s slowdown is on average 1.34× when
compared to native execution. Therefore, WATZ does not add
additional penalties when executed in the secure world. The
difference observed between WAMR and WATZ are insigniﬁ-
cant (less than 0.02%), since TrustZone does not introduce any
security mechanism that slows down the computation speed.
These results conﬁrm previous work comparing the slowdown
of Wasm applications against their native counterpart using
JIT and AOT compilation [27], [67]. A qualitative comparison
of our results with those found for PolyBench/C in Intel
SGX [27] shows that TrustZone does not affect the execution
runtime negatively. Unlike our proposal, Intel SGX introduces
noticeable performance overheads on AOT compiled Wasm
execution. We think the difference is natural because of the
additional security guarantees provided by SGX, with trans-
parent encryption and veriﬁcation of memory pages stored in
volatile memory [1].

SQLite [19] is a widespread, portable, low memory foot-
print, full-ﬂedged embeddable database, well suited for con-
strained environments. Our tests use SQLite v3.36, leveraging
its built-in benchmarking suite Speedtest1 [69]. We use the
native execution of SQLite (ARM64) in the normal and secure
worlds as an empirical baseline. As such, we adapted SQLite
to be embedded within a trusted application and run in OP-
TEE. We instantiate exclusively in-memory databases, as we
have left the implementation of WASI’s ﬁle system API for
future work. Each benchmark in the suite assesses a single
aspect of the database engine (e.g., selections with joins,
updates of data or changes of the schema, etc.). We conﬁgured
SQLite to use a 2048-page cache of 4 kB each (for a cache
size of 8 MB), with the default (normal) synchronous mode
and the default (delete) journal mode. In addition, we enabled
an alternate memory allocator to pre-allocate the memory used
by the database. To ﬁt in the restricted memory of the secure
world imposed by OP-TEE, we scale down the input dataset
to 60% (argument --size). As such, we compiled the trusted
application of WATZ to use 25 MB of heap memory.

Notice that TrustZone does not impose such memory limi-
tations. Hence the entire dataset can be used as soon as OP-
TEE lifts memory restrictions. Provided the memory can be
enlarged, we do not foresee any impediment for WATZ to
operate on software with large memory footprints, such as
deep learning systems for instance. The experiments ran 50
times, and we report medians and standard deviations in Fig. 6.
the execution time of
Speedtest1 in the normal world, using native execution as
a baseline. Overall, our observations are twofold: (1) in the
normal world, the slowdown of WAMR on average is 2.1×,
and (2) in the secure world, the slowdown of native execution
and WATZ on average are 1.31× and 2.12× respectively.

Results are normalised against

2mm3mmadiatabicchocorcovderdoidurf2dflogemgesgevgrah3dj1dj2dluludmvtnuss2ds2ksymsyrtritrm12341.141.161.031.471.261.291.071.061.151.251.491.831.132.471.151.261.031.471.981.771.11.271.131.351.121.721.11.891.141.091.131.151.031.471.261.291.071.061.141.241.491.821.132.461.161.271.031.471.991.761.11.271.141.331.121.721.11.881.151.08Normalisedruntime◀betterNative:REE(=1)Wasm:REE(WAMR)TEE(WaTZ)16016117032014014524014228031023015041026011012340.990.981.010.991.31.141.21.181.221.181.41.381.10.961.281.851.881.891.961.941.981.961.961.951.992.052.012.12.092.081.851.871.911.941.941.961.971.971.972.032.042.062.082.092.1Native:REE(=1)TEEWasm:REE(WAMR)TEE(WaTZ)130100980250400270510120300210190180290990500520123411.31.231.621.511.341.221.51.741.271.711.71.661.281.531.782.122.112.062.142.152.142.232.222.212.22.222.232.232.322.322.522.12.112.122.132.142.182.232.242.262.262.282.282.282.32.352.54Normalisedruntime◀better(a) Attester
Memory management
Key generation
Symmetric cryptography
Asymmetric cryptography
(b) Veriﬁer
Memory management
Key generation
Symmetric cryptography
Asymmetric cryptography
†
Generation of the message.

†msg0
7 µs

†msg2
‡msg1
5 µs
50 µs
(cid:192) 236 ms (cid:196) 235 ms
—
79 µs
—
88 µs
— (cid:195) 159 ms (cid:197) 238 ms
‡msg0
‡msg2
†msg1
52 µs
7 µs
7 µs
(cid:193) 471 ms
—
—
80 µs
—
85 µs
— (cid:194) 236 ms (cid:198) 159 ms

‡Handling the message.

TABLE III: Execution time of msg0, msg1 and msg2.

As a result,
the execution speed overhead of Wasm over
native execution in the TEE on average is 1.61×. This macro-
benchmark also demonstrates that WATZ has low to no-
overhead execution in TrustZone, compared to Wasm in the
normal world. Conversely,
the native TA suffers from an
overhead compared to the native application in the normal
world. These slowdown differences are explained because the
compiled binary in the normal world is optimised for using the
underlying hardware, unlike Wasm applications that are ahead-
of-time compiled from the intermediate Wasm bytecode. Most
of the experiments located on the top of Fig. 6 perform read
queries on the database and have a lower impact on the
performance, with an average of 2.04× (i.e., experiments 130-
145, 160-170, 260, 310, 320, 410, 510, 520). Instead, most of
the bottom experiments are write-intensive, by inserting data in
the database structure, with a slowdown on average of 2.23×
(i.e., experiments 100-120, 180, 190, 210, 290, 300, 400,
500). Similarly to the micro-benchmarks, we identify minor
discrepancies where the TEE applications are faster (equal
to or less than 0.04%). We also consider them insigniﬁcant
and are deemed equal to the performance measured in their
unsecured counterpart.

In summary, our analysis of Wasm runtime performance
in WATZ shows overheads of 1.34× and 2.12× for the
micro- and the macro-benchmarks, respectively. We estimate
that the security beneﬁts of TrustZone largely compensate
for these performance penalties. Besides, we did not observe
any noticeable overhead using WATZ compared to WAMR.
Thanks to WebAssembly, our tool provides great freedom for
the developers who build secure software using various tech-
nologies without being bound to the programming restrictions
of OP-TEE. On this topic, we noted that the adaptation of
SQLite to be executed in OP-TEE as a native TA has been
substantially more laborious than compiling it in Wasm with
WASI support. Indeed, the specialised API offered for trusted
applications required to modify the source code of SQLite
at various locations to replace missing POSIX functions and
undeﬁned data structures. On the other hand, WASI-SDK, the
framework used to compile C programs in Wasm, provides all
the function and structure deﬁnitions needed for a seamless
compilation. Finally, we leveraged the robust sandbox of
WATZ to ensure isolation between each hosted application
in the secure world with acceptable costs.

Fig. 7: Execution time of msg3.

E. Remote attestation micro-benchmarks

We now evaluate the remote attestation protocol. For the
sake of these tests, the attester (client) and the veriﬁer (server)
applications run on the same development board.

We measure the execution time of each message in the
remote attestation protocol and highlight
the various cost
factors. The sizes of msg0, msg1 and msg2 are ﬁxed, and
the execution time of their generation and handling are not
bound to the size of the Wasm application being measured.
On the other hand, msg3 requires a time that is proportional
to the size of the secret blob transferred to the application.
As a consequence, we analyse the execution time of the
three ﬁrst messages regardless of Wasm AOT bytecode size
in Table III. Fig. 7 depicts the execution time of the fourth
message, according to the size of data to transmit securely. We
evaluate the transfer of conﬁdential information, from 512 kB
to 3 MB. We compiled the attester and the veriﬁer of WATZ
to approximately split the heap memory equally as they are
located on the same hardware: 14 MB and 13 MB, respectively.
We noticed that our implementation requires twice the size of
the transmitted data in memory, in each trusted application.
Indeed, we needed to allocate a buffer for the plaintext and
a buffer for the ciphertext. For the largest data to transfer
(3 MB), this represents 6 MB in each TA, leading to a memory
occupancy of 12 MB in total. We leave the optimisation of
encryption and decryption using a single buffer for future
work. In addition to the details below, we report that most
of the time is dedicated to complete asymmetric cryptography
operations, i.e., keys and signatures generation.

a) Message 0: The attester generates an ECDHE key
pair and sends the public key ((cid:192) in Table III). When handling
message 0, the veriﬁer generates an ECDHE key pair and
derives the shared secrets to establish a secure channel ((cid:193)).
b) Message 1: The veriﬁer signs the ECDHE public
keys ((cid:194)) and generates a MAC. The asymmetric signature
takes most of the time, up to 2 774× the execution time of
the (symmetric) MAC, as expected [70]. The derivation of
the shared secrets is also performed on the attester’s side
when handling msg1 ((cid:196)). Hence the time the attester takes
to generate its keys ((cid:192), (cid:196)) is similar to the time the veriﬁer
takes to do the same ((cid:193)).

c) Message 2: The attester issues the evidence, which
requires a digital signature ((cid:197)), and a MAC. Upon reception,
the veriﬁer checks the MAC and the evidence signature ((cid:198)).
The time to sign ((cid:197)) and verify the signature ((cid:198)) of msg2 is
similar to the time required for the same operations on msg1
((cid:194) and (cid:195)). The same cryptographic operations are performed
in both cases, using different data.

0246810121416180.51.01.52.02.53.0Time[ms](JLowerisbetter)Datasize[MB]EncryptDecrypthandshake
1.34 s
(cid:44)→ Baseline
1.58 s
1.58 s

collect quote
239 ms
Size
0.1 MB
1 MB

send quote
1 ms
receive data
168 ms
209 ms

Baseline
1.58 s
Total
1.75 s
1.79 s

TABLE IV: Execution time of WASI-RA API.

Fig. 8: Execution time of the training phase.

d) Message 3: Finally, the veriﬁer generates msg3 with
the secret blob, encrypted and authenticated using AES-GCM.
We omitted the time consumed by memory management (less
than 1%). As seen in Fig. 7, the execution time evolves pro-
portionally between the veriﬁer’s encryption and the attester’s
decryption. Since AES-GCM is symmetric, it is faster than
signing the three ﬁrst messages, starting from 3 ms for 0.5 MB
of encrypted data and reaching 17 ms for 3 MB.

F. Remote attestation macro-benchmarks: Genann

We conclude our evaluation of WATZ with Genann [20], a
neural network library extensively used in literature [71], [72].
This library supports feedforward artiﬁcial neural networks
(ANN) and has zero external dependencies, making it a
convenient target to be compiled in Wasm and tested in a
constrained memory environment. The benchmark is based on
a built-in Genann example, where an ANN is trained on a
subset of the Iris dataset [73]. The ANN comprises 4 inputs, 1
hidden layer of 4 neurons and 3 outputs (1 per class). The input
dataset includes 50 records per class (ﬁle size of 4.45 kB).
We replicated the dataset to reach the breakpoint sizes, from
100 kB to 1 MB. Tests are executed 20 times. The attester
is launched with Genann as a trusted Wasm application. We
allocated 17 MB for the attester, enough space to handle the
Wasm runtime, the attestation with the transfer of the dataset
and the heap required by Genann. The remaining memory is
allocated for the veriﬁer (10 MB). Once executed, it triggers a
remote attestation request to retrieve the dataset, used to train
and predict the classiﬁcation. We use this end-to-end example
to demonstrate a real-world workﬂow using WATZ and assess
a few cost factors, such as the impact on the execution time
when the size of the conﬁdential information varies. Similarly
to the micro-benchmarks of remote attestation (§VI-E), the
attester and veriﬁer are co-located on the same device.

Table IV shows the execution time of WASI-RA, the API
exposed to the Wasm applications to request remote attestation
and evidence generation. The function retrieving the secret
blob is indicated according to the lower and upper bounds of
the dataset size. This end-to-end benchmark includes client and
server time to generate and handle the messages, the overhead
caused by the socket connection and the penalty of the normal
and secure world switching.

Most of the execution time is spent on the handshake:
msg0 and msg1 handle the key generation and half on the
asymmetric operations, as seen in Table III. The generation
of the evidence is the second most time-consuming operation
due to the digital signature ((cid:198) in Table III). The sending
of the evidence consumes only a marginal time. Lastly, we
evaluated several dataset sizes to assess the execution time

of the function that receives the conﬁdential information. We
report an execution time ranging from 168 ms for 100 KB up
to 209 ms for 1 MB. According to the micro-benchmark in
subsection VI-E, the cryptographic operations of msg3 takes a
negligible amount of time: 5.8 ms for 1 MB of data, unlike this
macro-benchmark. This difference is due to the attester waiting
for the end of the evidence veriﬁcation on the veriﬁer’s side,
reported for lasting 159 ms in Table III ((cid:198)). We conﬁrmed this
was the cause by waiting before receiving the data, which leads
to a reception duration of only 70 ms for 1 MB. This points
out the importance of having appropriate hardware for crypto-
graphic operations on the veriﬁer’s side. Further, we evaluate
the training time of the model (Fig. 8) for different dataset
sizes. The dataset is fetched from a regular ﬁle in the normal
world (using WAMR). In WATZ, it is read via a secure channel
established during the remote attestation. WATZ achieves a
1.4% speedup, roughly matching previous experiments with
no runtime overheads. The time difference between the two
systems is yet to be further investigated. Indeed, using the
same AOT binary and supplying the same data to Genann’s
training function yields better performance in OP-TEE. We
excluded the cause of better benchmark scheduling, since OP-
TEE relies on the REE Linux scheduler. Finally, we report
how the performance obtained here conﬁrms similar results in
literature [44], where an equally powerful TrustZone hardware
(HiKey Arm Cortex-A53, at 1.2 GHz) is used to benchmark
remote attestation protocols using TrustZone.

VII. SECURITY ANALYSIS

This section provides a security analysis of the concepts

within WATZ and discusses their strengths and limitations.

Secure boot. The ROM and the eFuses ensure that the board
is booting the secure OS in a genuine state. Assuming an
attacker replaces the image of the trusted OS, the software
signature will no longer match the binaries, which aborts the
boot sequence. Since the signature’s public key is stored in the
eFuses, it cannot be altered to install a compromised system.
Consequently, only a genuine version of the secure kernel OS
can access the root of trust. Nonetheless, the system does not
protect against rollback attacks. This can be locally mitigated
using monotonic counters bound to the hardware, and remotely
mitigated by checking the version of WATZ in the evidence
during remote attestation requests. While not available in the
SoC of our evaluation board, the security guarantees of WATZ
may be further extended using a measured boot in addition to
the secure boot. Measured boot is a security mechanism that
enables the attester to collect the code measurement of every
loaded software (e.g., bootloader, trusted OS) and accumu-
late them in special registers. Once these values (considered

100200300400500600700800900100001020301.63.24.86.48.09.911.813.615.517.31.63.24.76.37.99.811.613.415.217.1Datasetsize[KB]Time[s]◀betterWAMRWaTZadditional claims) are collected, they are signed and exported,
typically using a trusted platform module (TPM). These claims
may be later incorporated into evidence produced by WATZ
as a system-wide measurement. Consequently, veriﬁers may
also appraise the startup components to identify a potentially
hijacked secure boot.

Trusted Wasm runtime. The runtime offers execution and
attestation facilities similar to Intel SGX. The normal world
requests WATZ to start Wasm applications and, as a result,
they are executed in isolation inside TrustZone. Due to the
memory sandboxing inherited from Wasm, malicious applica-
tions loaded in WATZ cannot compromise the secure world or
access resources owned by other applications. This aspect is
different from the regular TAs in OP-TEE, because a signing
key is needed to deploy software in the secure world, which
prevents the execution of arbitrary software [74]. Moreover,
the communication of the signing key to allow third-party
developers to execute trustworthy code in OP-TEE may lead
to impersonation attacks on already deployed applications,
ultimately leaking secrets stored in persistent storage [75]. As
such, the Wasm sandbox offers a safe and efﬁcient isolation
mechanism to host software made by different parties. The
reliance on a runtime has the downside of increasing the
size of the trusted computing base. Furthermore, zero-day
vulnerabilities found in the Wasm sandbox may lead to data
leakage or arbitrary code execution, because the isolation
offered by Wasm is implemented in software, as opposed
to the isolation mechanisms of SGX enclaves. We note this
risk also applies to the trusted applications of OP-TEE, since
vulnerabilities found in the trusted OS may lead to privilege
escalations and, therefore, weaken the isolation of the trusted
applications. We mitigate this issue by providing the version of
WATZ in the evidence, so the veriﬁer can determine whether
the deployed runtime is up to date, i.e., detect whether the
attester has mitigation patches applied.

Remote attestation protocol. We evaluated the correctness
of our remote attestation protocol with Scyther [76], a state-of-
the-art formal analyser. This tool is known to analyse security
protocols, security requirements and identify vulnerabilities
formally. Scyther is based on the protocol semantics model for
the Dolev-Yao intruder model [77], which assumes that an ad-
versary has complete control over the communication channel
(an attacker can do everything except breaking cryptography).
We conﬁgured Scyther to check the secrecy of the private
session keys, the shared secret and the secret blob. Besides,
we veriﬁed the following claims of authentication: aliveness,
weak agreement, non-injective agreement, non-injective syn-
chronisation and reachability (i.e.,
the protocol ended on
both parties). While we omit
these terms for
conciseness [78], [79], they represent essential characteristics
of a security protocol. Scyther revealed no attack or ﬂaw in
our proposal. The script of the protocol is available in the
repository of WATZ [62].

to present

VIII. CONCLUSION

To the best of our knowledge, WATZ is the ﬁrst Wasm
runtime executing entirely inside Arm TrustZone with full
support for remote attestation, optimised explicitly for Wasm
to establish trust on hosted applications.

In many ways, WATZ offers a model similar to Intel SGX
while overcoming the limitations of TrustZone, extending
the paradigm of a single trusted world into fully isolated
and mutually distrusting enclaves. It comprises a trusted
environment for running unmodiﬁed Wasm applications that
cannot be tampered with. It relies on a hardware root of trust
and a secure boot, shielded by Arm TrustZone. Our WASI
extensions for remote attestation and the attestation protocol
establish trust on remotely executed Wasm applications inside
WATZ and securely provision conﬁdential data, such as shared
keys to join a channel or decrypt a conﬁguration ﬁle. Our
extensive experimental evaluation assesses the costs of the
WATZ mechanisms with typical tasks IoT devices carry out.
As a result, our implementation is lightweight, achieving
results on par with Wasm running in the normal world.

We have a strong commitment to open-source and repro-
ducibility: some of our improvements are already pushed to the
open software projects we depend on, and we intend to keep
doing so. The code of WATZ and the experiments presented
in this paper are available on GitHub [62].

ACKNOWLEDGMENTS

This publication incorporates results from the VEDLIoT
project, which received funding from the European Union’s
Horizon 2020 research and innovation programme under grant
agreement No 957197.

REFERENCES

[1] V. Costan and S. Devadas, “Intel SGX explained,” Cryptology ePrint

Archive, Report 2016/086, 2016.

[2] S. Pinto and N. Santos, “Demystifying Arm TrustZone: A comprehen-

sive survey,” ACM Comput. Surv., vol. 51, no. 6, Jan. 2019.

[3] I. D. O. Nunes, K. Eldefrawy, N. Rattanavipanon, M. Steiner, and
G. Tsudik, “VRASED: A veriﬁed hardware/software co-design for
remote attestation,” in USENIX Security ’19.

[4] F. Brasser, K. B. Rasmussen, A.-R. Sadeghi, and G. Tsudik, “Remote
attestation for low-end embedded devices: the prover’s perspective,” in
DAC ’16.

IEEE.

[5] K. Eldefrawy, G. Tsudik, A. Francillon, and D. Perito, “Smart: Secure
and minimal architecture for (establishing dynamic) root of trust.” in
NDSS, 2012.

[6] A. Ibrahim, A.-R. Sadeghi, and S. Zeitouni, “SeED: secure non-
interactive attestation for embedded devices,” in WiSec ’17. ACM.
[7] P. Koeberl, S. Schulz, A.-R. Sadeghi, and V. Varadharajan, “TrustLite: A
security architecture for tiny embedded devices,” in EuroSys ’14. ACM.
[8] M. U. Sardar, D. L. Quoc, and C. Fetzer, “Towards formalization of
enhanced privacy ID (EPID)-based remote attestation in Intel SGX,” in
DSD ’20.

IEEE.

[9] “State of the IoT 2020: 12 billion IoT connections,” Nov. 2020.

[Online]. Available: https://iot-analytics.com/?p=137408

[10] Apple, “Apple unleashes M1,” Nov. 2020.

[Online]. Available:

https://www.apple.com/newsroom/2020/11/apple-unleashes-m1/
[11] K. Liu, M. Yang, Z. Ling, H. Yan, Y. Zhang, X. Fu, and W. Zhao, “On
manually reverse engineering communication protocols of Linux-based
IoT systems,” IEEE Internet of Things Journal, vol. 8, no. 8, 2021.
[12] Z. Ling, J. Luo, Y. Xu, C. Gao, K. Wu, and X. Fu, “Security vulner-
abilities of internet of things: A case study of the smart plug system,”
IEEE Internet of Things Journal, vol. 4, no. 6, 2017.

[13] H. Li, K. Ota, and M. Dong, “Learning IoT in edge: Deep learning for
the internet of things with edge computing,” IEEE Network, vol. 32,
no. 1, 2018.

[14] A. Haas, A. Rossberg, D. L. Schuff, B. L. Titzer, M. Holman,
D. Gohman, L. Wagner, A. Zakai, and J. Bastien, “Bringing the web up
to speed with WebAssembly,” in PLDI ’17. ACM.

[15] C. Lattner and V. Adve, “LLVM: A compilation framework for lifelong

program analysis & transformation,” in CGO ’04.

[16] Samsung.

TEEGRIS.

[Online].

developer.samsung.com/teegris/overview.html

IEEE.
Available:

https://

[17] Intel Corporation. (2018) SGX remote attestation end-to-end example.

[Online]. Available: https://intel.ly/3AlpKxF

[18] Linaro. OP-TEE. [Online]. Available: https://op-tee.org
[19] L. Junyan, X. Shiguo, and L. Yijie, “Application research of embedded

database SQLite,” in IFITA ’09.

IEEE.

[20] Genann. [Online]. Available: https://github.com/codeplea/genann
[21] B. Ngabonziza, D. Martin, A. Bailey, H. Cho, and S. Martin, “TrustZone

explained: Architectural features and use cases,” in CIC ’16.

IEEE.

[22] C. G¨ottel, P. Felber, and V. Schiavoni, “Developing secure services for
IoT with OP-TEE: a ﬁrst look at performance and usability,” in IFIP
DAIS ’19. Springer.

[23] GlobalPlatform. [Online]. Available: https://globalplatform.org
[24] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, “Efﬁcient

software-based fault isolation,” in SOSP ’93. ACM.

[25] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow

integrity,” in CCS ’05. ACM.

[26] WebAssembly system interface. [Online]. Available: https://wasi.dev
[27] J. M´en´etrey, M. Pasin, P. Felber, and V. Schiavoni, “TWINE: An

embedded trusted runtime for WebAssembly,” in ICDE ’21.

IEEE.

[28] WebAssembly micro runtime. [Online]. Available: https://github.com/

bytecodealliance/wasm-micro-runtime
[29] Enarx. [Online]. Available: https://enarx.dev
[30] Veracruz. [Online]. Available: https://veracruz-project.com
[31] Arm, “Introducing Arm conﬁdential compute architecture,” Tech. Rep.

DEN0125, 2021.

[32] AWS nitro enclaves. [Online]. Available: https://go.aws/3ISjRLx
[33] Status of Intel SGX and Arm TrustZone support. [Online]. Available:

https://github.com/veracruz-project/veracruz/issues/330

[34] D. Goltzsche, M. Nieke, T. Knauth, and R. Kapitza, “AccTEE: A
WebAssembly-based two-way sandbox for trusted resource accounting,”
in Middleware ’19. ACM.

[35] W. Qiang, Z. Dong, and H. Jin, “Se-Lambda: Securing privacy-
sensitive serverless applications using SGX enclave,” in SecureComm
’18, R. Beyah, B. Chang, Y. Li, and S. Zhu, Eds. Springer.

[36] H. Birkholz, D. Thaler, M. Richardson, N. Smith, and W. Pan, “Remote
attestation procedures architecture,” IETF, Tech. Rep., apr 2021.
[37] T. Abera, N. Asokan, L. Davi, F. Koushanfar, A. Paverd, A.-R. Sadeghi,
and G. Tsudik, “Invited: Things, trouble, trust: On building trust in IoT
systems,” in DAC ’16.

IEEE.

[38] O. Arias, F. Rahman, M. Tehranipoor, and Y. Jin, “Device attestation:

past, present, and future,” in DATE ’18.

IEEE.

[39] J. M´en´etrey, C. G¨ottel, A. Khurshid, M. Pasin, P. Felber, V. Schiavoni,
and S. Raza, “Attestation mechanisms for trusted execution environments
demystiﬁed,” in IFIP DAIS ’22. Springer.

[40] V. Costan, I. Lebedev, and S. Devadas, “Sanctum: Minimal hardware
extensions for strong software isolation,” in USENIX Security ’16.
[41] S. Zhao, Q. Zhang, Y. Qin, W. Feng, and D. Feng, “SecTEE: A software-
based approach to secure enclave architecture using TEE,” in CCS ’19.
ACM.

[42] J. Ahn, I.-G. Lee, and M. Kim, “Design and implementation of
hardware-based remote attestation for a secure internet of things,” Wirel.
Pers. Commun., vol. 114, no. 1, sep 2020.

[43] G. Chen and Y. Zhang, “Mage: Mutual attestation for a group of enclaves

without trusted third parties,” arXiv preprint arXiv:2008.09501, 2020.

[44] C. Shepherd, R. N. Akram, and K. Markantonakis, “Establishing mutu-
ally trusted channels for remote sensing devices with trusted execution
environments,” in ARES ’17. ACM.

[45] I. Anati, S. Gueron, S. Johnson, and V. Scarlata, “Innovative technology

for CPU based attestation and sealing,” in HASP ’13. ACM.

[46] Z. Ling, H. Yan, X. Shao, J. Luo, Y. Xu, B. Pearson, and X. Fu, “Secure
boot, trusted boot and remote attestation for Arm TrustZone-based IoT
nodes,” J. Syst. Archit., vol. 119, no. C, oct 2021.

[47] A. Martin, C. Lian, F. Gregor, R. Krahn, V. Schiavoni, P. Felber,
and C. Fetzer, “ADAM-CS: Advanced asynchronous monotonic counter
service,” in IFIP DSN ’21.

IEEE.
[48] K. Ryan, “Hardware-backed heist: Extracting ECDSA keys from Qual-

comm’s TrustZone,” in CCS ’19. ACM.

[49] P. Qiu, D. Wang, Y. Lyu, and G. Qu, “Voltjockey: Breaching TrustZone
by software-controlled voltage manipulation over multi-core frequen-
cies,” in CCS ’19. ACM.

[50] J. A. Halderman, S. D. Schoen, N. Heninger, W. Clarkson, W. Paul, J. A.
Calandrino, A. J. Feldman, J. Appelbaum, and E. W. Felten, “Lest we
remember: Cold boot attacks on encryption keys,” in USENIX Security
’08.

[51] N. Zhang, K. Sun, D. Shands, W. Lou, and Y. T. Hou, “TruSense:

Information leakage from TrustZone,” in INFOCOM ’18.

IEEE.

[52] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Ham-
burg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom,
“Spectre attacks: Exploiting speculative execution,” in SP ’19.
IEEE.
[53] OP-TEE: Can heap memory contain executable code? [Online].

Available: https://github.com/OP-TEE/optee os/issues/4396

[54] NXP, Security reference manual for i.MX8M, Nov. 2018.
[55] GlobalPlatform, TLS speciﬁcation of TEE sockets API speciﬁcation,
Feb. 2021. [Online]. Available: https://globalplatform.org/?p=4163
frequently asked questions.
https://optee.readthedocs.io/en/latest/faq/faq.html

[56] Linaro. OP-TEE,

[Online]. Available:

[57] H. Krawczyk, “Sigma: The ‘SIGn-and-MAc’ approach to authenticated
Difﬁe-Hellman and its use in the IKE protocols,” in CRYPTO ’03,
D. Boneh, Ed. Springer.

[58] R. Czerwinski, “OP-TEE is ready: Let’s use it!” in LFELC ’20.
[59] LibTomCrypt. [Online]. Available: http://www.libtom.net/LibTomCrypt
[60] K. Lauter, “The advantages of elliptic curve cryptography for wireless
security,” IEEE Wireless Communications, vol. 11, no. 1, 2004.
[61] NIST, “Recommendation for key management,” Tech. Rep., may 2020.
[62] J. M´en´etrey. WATZ runtime and experiments. [Online]. Available:

https://github.com/jamesmenetrey/unine-watz

[63] WASI-SDK.
wasi-sdk

[Online]. Available: https://github.com/WebAssembly/

[64] J. Amacher and V. Schiavoni, “On the performance of Arm TrustZone,”

in IFIP DAIS ’19. Springer.

[65] PolyBench/C. [Online]. Available: http://polybench.sf.net
[66] M. Schordan, P.-H. Lin, D. Quinlan, and L.-N. Pouchet, “Veriﬁcation
of polyhedral optimizations with constant loop bounds in ﬁnite state
space computations,” in Leveraging Applications of Formal Methods,
Veriﬁcation and Validation. Specialized Techniques and Applications,
T. Margaria and B. Steffen, Eds. Springer Berlin Heidelberg, 2014.

[67] A. Jangda, B. Powers, E. D. Berger, and A. Guha, “Not so fast: Ana-
lyzing the performance of WebAssembly vs. native code,” in USENIX
ATC ’19.

[68] S. Shillaker and P. Pietzuch, “Faasm: Lightweight isolation for efﬁcient

stateful serverless computing,” in USENIX ATC ’20.

[69] SQLite, speedtest1. [Online]. Available: https://sqlite.org/cpu.html
[70] C. Paar and J. Pelzl, Understanding cryptography: a textbook for
students and practitioners. Springer Science & Business Media, 2009.
[71] R. Cantoro, N. I. Deligiannis, M. S. Reorda, M. Traiola, and E. Valea,
“Evaluating data encryption effects on the resilience of an artiﬁcial
neural network,” in DFT ’20.
IEEE.

[72] B. Amornpaisannon, A. Diavastos, L.-S. Peh, and T. E. Carlson, “Laser

attack benchmark suite,” in ICCAD ’20.

IEEE.

[73] D. Dua and C. Graff. (2017) UCI machine learning repository. [Online].

Available: http://archive.ics.uci.edu/ml

[74] Linaro. OP-TEE trusted

[On-
line]. Available: https://optee.readthedocs.io/en/latest/building/trusted
applications.html

applications: Signing

of TAs.

[75] OP-TEE: Can an impersonate TA access the storage of another TA
by reusing its UUID? [Online]. Available: https://github.com/OP-TEE/
optee os/issues/4447

[76] C. J. F. Cremers, “The Scyther tool: Veriﬁcation, falsiﬁcation, and
analysis of security protocols,” in CAV ’08, A. Gupta and S. Malik,
Eds. Springer.

[77] D. Dolev and A. Yao, “On the security of public key protocols,” IEEE

Transactions on Information Theory, vol. 29, no. 2, 1983.

[78] C. J. F. Cremers and S. Mauw, Operational semantics and veriﬁcation

of security protocols. Springer, 2012.

[79] G. Lowe, “A hierarchy of authentication speciﬁcations,” in CSFW ’97.

ACM.

