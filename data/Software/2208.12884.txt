2
2
0
2

g
u
A
6
2

]

R
C
.
s
c
[

1
v
4
8
8
2
1
.
8
0
2
2
:
v
i
X
r
a

A Note on Copy-Protection from Random Oracles

Prabhanjan Ananth∗
UCSB

Fatih Kaleoglu†
UCSB

Abstract

Quantum copy-protection, introduced by Aaronson (CCC’09), uses the no-cloning principle of
quantum mechanics to protect software from being illegally distributed. Constructing copy-
protection has been an important problem in quantum cryptography.

Since copy-protection is shown to be impossible to achieve in the plain model, we investigate
the question of constructing copy-protection for arbitrary classes of unlearnable functions in the
random oracle model. We present an impossibility result that rules out a class of copy-protection
schemes in the random oracle model assuming the existence of quantum fully homomorphic
encryption and quantum hardness of learning with errors. En route, we prove the impossibility
of approximately correct copy-protection in the plain model.

1

Introduction

Quantum copy-protection, introduced by Aaronson [Aar09], is a foundational concept in quantum
cryptography. It stipulates that the no-cloning principle of quantum mechanics [Die82, WZ82] can
be employed to protect against illegal distribution of software. In more detail, an eﬃcient adversary,
on input a copy-protected software (represented as a quantum state), cannot create two copies of
software, possibly entangled with each other, such that both copies compute the same functionality
as the original software.

The primitive of copy-protection can be classiﬁed under the broad area of unclonable cryptogra-
phy, which deals with using the no-cloning principle to design cryptographic primitives with security
properties that are classically unachievable. Many interesting primitives in this category, such as
quantum money [Wie83, AC12, Zha19b, RS19], one-shot signatures [AGKZ20], single-decryptor
encryption [GZ20, CLLZ21], unclonable encryption [Got02, BL20], and encryption with certiﬁable
deletion [BI20], can be seen as copy-protecting speciﬁc functionalities.

The focus of our work is on understanding the feasibility of constructing copy-protection for
all classes of unlearnable functions. Ananth and La Placa [ALP21] show that there are functions
that cannot be copy-protected in the plain model. Thus, one has to rely on alternate models to
construct copy-protection.

In this work, we restrict our attention to the random oracle model. Interestingly, random ora-
cles have been helpful for achieving copy-protection for speciﬁc classes of functions. Coladangelo,
Majenz and Poremba [CMP20] showed the existence of copy-protection for multi-bit output func-
tions in the random oracle model. Ananth, Kaleoglu, Liu, Li and Zhandry [AKL+22] presented a

∗prabhanjan@cs.ucsb.edu
†kaleoglu@ucsb.edu

1

 
 
 
 
 
 
new construction of copy-protection for single-bit output point functions also in the random oracle
model. However, the existence of copy-protection for all classes of unlearnable functions in the
random oracle model is still yet to be explored.

Before we delve into this direction further, we ﬁrst need to model the type of access the al-
gorithms in the copy-protection scheme and the adversarial entities will have, with the random
oracle. There are two types of accesses we can consider. The ﬁrst one is classical access, where the
interface is entirely classical: the algorithms submit a binary string x to the oracle and get back
f (x), where f is a classical random function implemented by the oracle. We will refer to this setting
as classical-accessible random oracle model (CAROM). The second type is quantum access: the
.
n αx
algorithms submit a query of the form
i
}
This setting was deﬁned by Boneh, Dagdelen, Fischlin, Lehmann, Schaﬀner and Zhandry [BDF+11]
as the quantum random oracle model (QROM).

and get back

n αx
}

f (x)

x
|

x
|

P

P

yx

yx

⊕

0,1

0,1

i|

i|

∈{

∈{

i

x

x

As argued in [BDF+11], QROM is the preferred model over CAROM under most circumstances.
For instance, if the adversary has access to any classical code that computes the function f , then
it can always run this code coherently, thus achieving quantum access. Nonetheless, as per the
impossibility result of [ALP21], one cannot simply instantiate a generic copy-protection scheme in
QROM by replacing the random function f with a concrete function, e.g. a heuristically secure hash
function such as SHA-512 or an obfuscated pseudorandom function. In contrast, classical-access is
appropriate for alternative methods of instantiation, such as using trusted hardware or a trusted
party, where classical interface can be enforced. Therefore, we argue that achieving copy-protection
in CAROM is still meaingful.

1.1 Our Result

We make progress towards understanding the feasibility of copy-protection in the random ora-
cle model. It turns out that proving impossibility of copy-protection in the QROM seems quite
challenging and thus, we focus on the CAROM setting. Note that QROM and CAROM are incom-
parable models, since QROM gives more power to both the honest algorithms and the adversary.
We show that copy-protection of arbitrary unlearnable functions is impossible in CAROM. This
implies that if copy-protection is possible with a random oracle, then honest algorithms must query
the oracle in superposition.

Theorem 1. Assuming unbounded fully homomorphic encryption for quantum computations [Mah18,
Bra18] and quantum hardness of learning with errors (QLWE), there exists a class of unlearnable
functions

such that quantum copy-protection for

is impossible in CAROM.

F

F

The above result suggests that if one were to base copy-protection in the classical-accessible oracle
models then the oracle needs to have some structure. We note that in both the works of [CMP20]
and [AKL+22], the copy-protection algorithm only makes classical queries to the oracle whereas
the evaluation algorithm makes quantum queries.

At the heart of the above theorem is a new impossibility result for copy-protection in the
plain model. Speciﬁcally, we show that even copy-protection with approximate correctness can be
ruled out in the plain model (Theorem 17), while prior works [ALP21, ABDS21] only ruled out
copy-protection with statistical correctness.

We combine this impossibility result with a generic transformation from a copy-protection
scheme in CAROM to an approximate copy-protection scheme in the plain model (Lemma 21)
to rule out copy-protection of arbitrary unlearnable functions in CAROM (Theorem 22). Our

2

transformation crucially relies on recording the oracle queries of the honest algorithms and eﬃcient
simulation of a random oracle consistent with a prerecorded database. Recording quantum queries
to a random oracle can be achieved using Zhandry’s compressed oracle technique [Zha19a], but
to our knowledge it is not known how to eﬃciently simulate a quantum random oracle consistent
with a prerecorded database. Therefore, any construction in QROM where honest parties make
superposition queries to the oracle would circumvent our impossibility result.

1.2 Related Work

Aaronson [Aar09] was the ﬁrst to study copy-protection in the oracle models. Their construction
relied upon oracles implementing quantum functionalities. Recently, Aaronson, Liu, Liu, Zhandry
and Zhang [ALL+21] constructed copy-protection in a quantum-accessible oracle model. As men-
tioned earlier, two works [CMP20, AKL+22] present constructions of copy-protection for point
functions in the quantum random oracle model.

In a recent exciting work, Coladangelo, Liu, Liu and Zhandry [CLLZ21] proposed the ﬁrst con-
struction of copy-protection for a restricted class of functions, namely pseudorandom functions, in
the plain model, based on post-quantum indistinguishability obfuscation and post-quantum one-
way functions. Another work by Ananth and Kaleoglu [AK21] present a construction of approxi-
mately correct copy-protection for a class of point functions from post-quantum one-way functions.
Some recent works [ALP21, ALL+21, KNY21, BJL+21] present constructions of weaker notions of
copy-protection.

2 Overview of Techniques

In this section, we explain the main ideas behind our result. Inspired by the ideas developed in
the program obfuscation literature [BV16, CKP15], we design a two step approach to proving this
impossibility result.

• Ruling out approximate copy-protection in the plain model: In the ﬁrst step, we rule out a
notion of copy-protection where correctness is only guaranteed for a large constant fraction
of inputs.

• From CP using oracles to approximate CP in the plain model: In the second step, we show
that copy-protection in the classical-accessible random oracle model implies approximate
copy-protection in the plain model. In other words, given any copy-protection in the classical-
accessible random oracle model, we can generically get rid of the random oracle model at the
cost of weakening the correctness guarantee.

Ruling out Approximate Copy-Protection. We show that copy-protection, where correctness
is guaranteed for a fraction of inputs, say (1
ε), is impossible to achieve in the plain model. This
strengthens the previous result [ALP21] which ruled out copy-protection with correctness negligibly
close to 1.

−

Our goal is to transform this scheme, call it CP , such that in the transformed scheme, call it
ε)
CP ′, on every input, the evaluation of the copy-protected state is correct with probability (1
(i.e., per-input (1
ε)-correctness); assume for now, that C is a boolean circuit with 1-bit output.
The scheme CP ′ is designed as follows: to copy-protect C, compute a copy-protection of a circuit

−

−

3

G, with respect to the scheme CP , such that G takes as input an encryption of x, homomorphically
computes C on encryption of x and outputs the result. The output is copy-protection of G along
with the public key-secret key pair of the encryption scheme. During the evaluation process of
CP ′, ﬁrst encrypt the input x, run the CP copy-protection of G to obtain encryption of C(x) and
ﬁnally, decrypt the answer to obtain C(x) in the clear.

This idea was notably developed by Bitansky and Vaikuntanathan [BV16] in the context of
indistinguishability obfuscation. To make this idea work, we would need fully homomorphic en-
cryption schemes for quantum computations (QFHE). Moreover, we require the QFHE scheme to
satisfy circuit privacy; that is, the homomorphically evaluated ciphertext does not leak information
about the circuit being used during evaluation. This property is necessary because the evaluator
who obtains a classical description of the function can trivially break the copy-protection security.
Fortunately, a recent work by Chardouvelis, D¨ottling, and Malavolta [CDM20] demonstrates the
existence of a QFHE scheme satisfying the circuit privacy property we need1.

−

ε)-fraction of inputs to per-input (1

Failure of Majority Argument. Suppose we manage to reduce the feasibility of copy-protection with
ε)-correctness. The next step would
correctness over a (1
be to rule out copy-protection with per-input correctness. A natural attempt would be to consider
multiple copies of copy-protection and take a majority vote; this would improve the correctness to
be close to 1. While this argument would work for program obfuscation, this unfortunately fails in
the context of copy-protection. The reason is simple: once you have many copies of copy-protection,
an adversary can now distribute each copy to a diﬀerent individual, thus breaking the security of
copy-protection.

−

Thus, we need to ﬁgure out an alternate method to rule out quantum copy-protection with per-
input correctness guarantees. As done in prior works, we rely upon non-black box techniques to rule
out copy-protection. We need to be especially careful when invoking non-black box arguments in
the per-input (1
ε)-correctness setting, as every evaluation of the copy-protected state signiﬁcantly
degrades the correctness guarantee of the original state. If ε is the correctness error then after k
evaluations, the trace distance between the original state and the new state is k√ε (by quantum
1
union bound).
√ε then the new state is useless. Luckily, the quantum non-black box
technique of [ALP21] involves the attacker only making two evaluations of the copy-protected
state.

If k

≥

−

In the technical sections, we combine the self-reducibility technique (presented above) with the

non-black box technique of [ALP21] to rule out copy-protection for (1

ε)-fraction of inputs.

−

From CP using oracles to approximate CP. The next step would be to rule out copy-
protection in the classical-accessible random oracle model. We rely upon “de-oracle-izing” tech-
niques developed in the context of obfuscation [CKP15]; the idea is to remove the use of random
oracle in the construction at the cost of weakening the correctness guarantee. While the overall
template is inspired from [CKP15], the actual construction is diﬀerent.

In more detail, given a copy-protection scheme (CP, Eval) in the classical-accessible random
oracle model, where CP represents the copy-protection algorithm and Eval represents the evaluation
algorithm, deﬁne a copy-protection scheme (

Eval) in the plain model as follows:

CP,

1We note that the deﬁnition considered in [CDM20] is weak: for example, they do not even handle adversaries
g
who can entangle the quantum messages with their private state. We provide a stronger deﬁnition in this paper and
remark that the construction provided in [CDM20] already satisﬁes this stronger deﬁnition.

f

4

1. Using a random oracle

CP(f ) runs CPO(f ) to obtain a copy-protected
program ρf . It then runs a random (polynomial) number of test executions EvalO(ρf , xi) for
randomly chosen inputs xi. It records all the queries made by Eval during the test executions
in a database D. Finally, it samples a set of random oracle answers R and outputs (ρ, D, R).

simulated on-the-ﬂy,

f

O

2.

Eval((ρf , D, R), x) simulates a random oracle
not recorded in D. It runs EvalO
g

′

O′ using the database D and using R for queries

(ρf , x) and outputs the answer.

The key diﬀerence between our construction and the construction of [CKP15] is that we choose the
number of test executions at random. In the classical world, running more test executions can never
hurt the simulation. In the quantum world, on the other hand, every test execution can signiﬁcantly
alter the state ρf by performing measurements. This could be true even if ρf is reusable, in the sense
that its correctness guarantee is preserved after polynomially many evaluations2. For instance, the
state ρf could maintain a counter which aﬀects the oracle queries made by Eval. To ensure that
Eval needs to answer are captured in the database D with probability close to 1,
the oracle queries
even if ρf keeps changing, we choose the number of test queries at random and suﬃciently large.
Perhaps surprisingly, our technique also improves the classical impossibility of obfuscation in
the random oracle model! Speciﬁcally, it reduces the number of test executions needed by a factor
of N when compared to [CKP15], where N is a query-bound for Eval.

g

2.1 Acknowledgements

We thank Luowen Qian for valuable discussions.

2.2 Organization

Preliminaries are described in Section 3. The impossibility of approximate copy-protection in the
plain model is presented in Section 4.1. We prove the impossibility of copy-protection in CAROM
in Section 4.2.

3 Preliminaries

3.1 Notation
We denote by x $
X the sampling of an element x from the uniform distribution over X. We
←−
denote by λ the security parameter. We use the terms function and circuit interchangeably. We
denote by negl(
has oracle
) a generic negligible function. [N ] :=
·
access to
noticable
if there exists a polynomial p such that ǫ(n) > 1
p(n) for suﬃciently large n. We say overwhelming
negl(λ). We sometimes shorten a string of zeros to 0, when the
probability to mean probability 1
length will be understood from the context. We write
is run
on input x using speciﬁed randomness r.

AO to emphasize this fact. We call a function ǫ : Z+

(x; r) when a classical algorithm

. If an algorithm
}

1, 2, . . . , N
{

, we may write

A
0
}
∪{

R+

→

A

A

O

−

2These forced measurements are a unique feature of the classical-accessible oracle setting, since quantum queries

need not be measured at the time of the query by the deferred measurement principle.

5

3.2 Quantum Computing Basics

D

) the set of valid mixed quantum states over Hilbert space

For a ﬁnite set (register) X we denote by
We denote by
(
H
positive-semideﬁnite operators over
a quantum polynomial time (QPT) algorithm as a family of generalized quantum circuits
such that each
most p(λ) gates from a universal gate set (such as

N
λ contains at most p(λ) input/output qubits (including auxiliary qubits) and at
CN OT, H, T

X.
i}x
∈
linear,
with unit trace, also known as density operators. We deﬁne

X the Hilbert Space generated by the basis

{|
, i.e.

}λ
∈

{A

H

H

H

A

x

λ

).
), for some polynomial p(
·
}

{

3.2.1 Trace Distance

A common way to measure dissimilarity between two quantum states ρ, σ
ized) trace distance, deﬁned as

(
H

∈ D

) is the (normal-

T (ρ, σ) :=

1
2 |

ρ

σ

tr =
|

−

1
2

Tr

σ)2

.

(ρ

−

(cid:17)

(cid:16)p

It is a fact that no quantum algorithm can increase the trace distance between two quantum states,
, ρ, σ. When two quantum states ρ(λ), σ(λ) depend on a
i.e. T (
T (ρ, σ) for any
negl(λ), we write ρ
security parameter and satisfy T (ρ, σ)
s σ, meaning ρ and σ are statistically
close.

A
≤

(σ))

(ρ),

A

A

≈

≤

3.2.2 Measurement

A quantum measurement on a Hilbert Space
with a ﬁnite set of outcomes [m] can be represented
),
[m] M †i Mi = I. Given a quantum state ρ
by a set of operators (Mi)i
∈
the probability of outcome i is given by Tr(MiρM †i ), whereas the post-measurement state after
P
. If the measurement outcome is not revealed, then the
measuring outcome i is given by

[m] satisfying
∈

(
H

∈ D

H
i

MiρM †
i
Tr(MiρM †
i )
post-measurement state equals the mixture

i

[m] MiρM †i .
∈

P
3.2.3 Almost As Good As New Lemma

The following lemma from [Aar04] is widely used in literature3.

Lemma 2 (Almost as Good as New Lemma). Let ρ be a quantum state and (M0, M1) be a 2-
outcome measurement such that Tr(M0ρM †0 )
ε. Then, after this measurement is performed
1
√ε. In addition, the recovery procedure
on ρ, it is possible to recover a state ρ′ such that T (ρ, ρ′)
is independent of ρ, and is eﬃcient (runs in polynomial time) given that (M0, M1) is eﬃcient.

−

≥

≤

Corollary 3. Let
string x, outputs a classical string y. Suppose that

A

be a quantum algorithm that given as input a quantum state ρ and a classical

Pr [f (x)

(ρ, x)]

1

−

≥

ε(x),

← A

(1)

where ρ is a quantum input state, x is a classical input, and f (x) is a classical deterministic
A′(ρ, x) outputs a classical
function. Then, there exists a quantum algorithm
string y identically distributed to output of
A′ outputs a residual state
is eﬃcient.
ε(x). Moreover,
ρ′ satisfying T (ρ, ρ′)

A′ such that (1)
(ρ, x), and (2) in addition

A
A′ is eﬃcient given that

A

≤

3In quantum information theory, it is known as the gentle measurement lemma [Win99].

p

6

so that it applies a unitary transfor-
Sketch. By deferred measurement principle, we can modify
A
mation followed by measuring and outputting a value y. Fix x
X, then the statement follows after
applying Lemma 2 with respect to the 2-outcome measurement which checks whether y = f (x) or
not.

∈

3.3 Quantum Fully Homomorphic Encryption

A fully homomorphic encryption scheme allows for publicly evaluating an encryption of x using a
function f to obtain an encryption of f (x). Traditionally f has been modeled as classical circuits
but in this work, we consider the setting when f is modeled as quantum circuits and when the
messages are quantum states. This notion is referred to as quantum fully homomorphic encryption
(QFHE). We state our deﬁnition borrowed directly from4 [BJ15].

Deﬁnition 4. Let
be
the Hilbert space associated with the ciphertexts. A quantum fully homomorphic encryption (QFHE)
scheme is a tuple of QPT algorithms QFHE = (Gen, Enc, Dec, Eval):

be the Hilbert space associated with the message space (plaintexts) and

M

C

• QFHE.Gen(1λ): Takes as input a security parameter λ in unary; outputs a classical public-

secret key pair, (PK, SK).

• QFHE.Enc(PK,

) :
·
ρ; outputs a quantum ciphertext σ.

)
(
M

→ D

(
C

D

): Takes as input a public key PK and a quantum message

• QFHE.Dec(SK,

(
) :
M
·
σ; outputs a quantum message ρ.

→ D

(
C

D

)

): Takes as input a secret key SK and a quantum ciphertext

,

• QFHE.Eval(PK,
n)
(
C⊗
D
n)
quantum circuit
(
M⊗
outputs a tuple of quantum ciphertexts σ′ ∈ D

(
C⊗
→ D
(
M⊗
→ D

) :
·
:

E
E

D

m).

(
C⊗

m): Takes as input a public key PK, description of a
n));
m), and a tuple of quantum ciphertexts σ

(
D

(
C⊗

∈

Semantic security and compactness are deﬁned analogously to the classical setting, and we defer
to [BJ15] for a deﬁnition. For the impossibility result, we require a QFHE scheme where cipher-
k, we want
0, 1
texts of classical plaintexts are also classical. Given any classical message x
∈ {
}
l (here, l is the
QFHE.Enc(PK,
0, 1
) to be a computational basis state
}
|
length of ciphertexts for k-qubit messages). In this case, we write QFHE.EncPK(x). We also want
n and
the same to be true for evaluated ciphertexts, i.e.
0, 1
}
y

for some x

for some z

) =
|

y
ih

z
ih

x
(
|

∈ {

∈ {

x
|

y
|

z
|

ih

ih

if

x

x

E

|

|

m, then
0, 1
}

∈ {

QFHE.EncPK(y)

QFHE.Eval(PK,

E

←

, QFHE.EncPK(x))

is a classical ciphertext of y.

3.3.1 Circuit Privacy

An additional property we need a QFHE scheme to satisfy is called malicious circuit privacy.
Informally, it states that the evaluation algorithm does not leak any information about the circuit
, an adversary cannot learn
being evaluated, i.e. given a homomorphic evaluation of a circuit

E

4With the slight modiﬁcation that the evaluation key is included as part of the public key.

7

any information she would not have learned given only black-box access to
deﬁnition below, adapted from5 [CDM20]:

E

. We give the formal

Deﬁnition 5 (Malicious Circuit Privacy). A QFHE scheme QFHE = (QFHE.Gen, QFHE.Enc,
QFHE.Dec, QFHE.Eval) satisﬁes malicious circuit privacy if there exist unbounded quantum al-
gorithms QFHE.Ext and QFHE.Sim such that for any (possibly invalid) public key PK∗, any quan-
poly(λ), and any
tum circuit
n
(
ρ
C⊗

m), any ancillary register A with

n)
(
M⊗
D
A) we have

E
⊗ H

(
M⊗

M⊗

→ D

A =

∈ D

H

:

(QFHE.Eval(PK∗,

idA) ρ

s QFHE.Sim(1λ, (

idAB)(

ρ)),

E

≈
B) is obtained by applying QFHE.Ext(1λ, PK∗,

E ⊗

⊗

,

)
·

ρ

where
A
register of ρ, and B is an ancillary register.

(
C⊗

⊗ H

⊗ H

∈ D

n

) to the
·
e

C⊗

n (ciphertext)

e

The deﬁnition can be alternatively stated as follows: for an unbounded adversary, one query
QFHE.Eval evaluation of the circuit
itself. Note also
that A is a hidden register held by an adversary that could be entangled with the ciphertext, so it
is not accessible by the algorithms QFHE.Eval and QFHE.Ext.

is no more powerful than one query to

E

E

Instantiation. Malicious Circuit Privacy can be achieved using a regular QFHE scheme [CDM20].
We state their result as a theorem:

Theorem 6. Assuming QLWE and circular security6, there exists a QFHE scheme with malicious
circuit privacy, which reduces to a classical FHE scheme for classical inputs.

3.4 Compute-and-Compare Circuits and Quantum-Secure Lockable Obfusca-

tion

Compute-and-compare Circuits. The subclass of circuits that we are interested in is called
compute-and-compare circuits, denoted by
cnc. A compute-and-compare circuit is of the following
form: C[C, α, β], where α is called a lock and C has output length

C

, is deﬁned as follows:
α
|
|

C[C, α](x) =

β,

if C(x)=α,

0, otherwise

n
Deﬁnition 7 (Quantum-Secure Lockable Obfuscation). An obfuscation scheme (Obf, ObfEval) for a
cnc is said to be a quantum-secure lockable obfuscation
class of compute-and-compare circuits
scheme if the following properties are satisﬁed:
• It satisﬁes the functionality of obfuscation.

C

• Security: For every polynomial-sized circuit C, string β

poly(λ),for every QPT ad-
0, 1
}
there exists a QPT simulator Sim such that the following holds: sample α $
←−

∈ {

versary
A
poly(λ),
0, 1
}
{

where C is a circuit parameterized by C, α, β with ε

Obf

1λ, C
(cid:16)

(cid:17)o

Q,ε

≈

n

Sim

n

C

|

,

(cid:17)o

1λ, 1|
(cid:16)
≤

1
2|α| .

5The diﬀerence is that we sensibly strengthen the deﬁnition to account for adversaries with a possibly entangled
auxiliary register B. Even though this was not formally considered by [CDM20], a quick analysis of their argument
reveals that their construction indeed satisﬁes this stronger deﬁnition of circuit privacy.

6This assumption is needed to evaluate circuits with unbounded depth in both classical and quantum FHE.

8

Instantiation. The works of [WZ17, GKW17, GKVW19] construct a lockable obfuscation scheme
based on polynomial-security of learning with errors. Since learning with errors is conjectured to
be hard against QPT algorithms, the obfuscation schemes of [WZ17, GKW17, GKVW19] are also
secure against QPT algorithms. Thus, we have the following theorem.

Theorem 8 ([GKW17, WZ17, GKVW19]). Assuming quantum hardness of learning with errors,
there exists a quantum-secure lockable obfuscation scheme.

3.5 Classical-Accessible Oracles

classical-accessible if it only accepts a classical query x

can be described as the following quantum operation: measure the

:

X → Y

We call an oracle
O
which it responds with the classical value
algorithm
of
A
register.
ancillary register corresponding to the internal state of

in the computational basis to obtain x

In other words, if

∈ X

A

A

O

queries the oracle in state

(x). More formally, a query to

, then XOR the value
x,y,z αx,y,z

∈

O

X, to
made by a quantum
(query) register
X
(answer)
(x) to the
O
is an
z
y
x
i|
i|
|
, then the state after the query equals
P
2, where βy,z = αx,y,z/√px.
|

Y
, where
i

Z

A
αx,y,z

y,z βy,z

x
|

y
i|

(x)

z
i|

i

⊕ O

with probability px =

y,z |

P
3.5.1 Classical-Accessible Random Oracle Model

P

In classical-accessible random oracle model (CAROM), the function in question is assumed to be
a uniformly random function

and modeled as a classical-accessible oracle.

:

O

X → Y

A classical-accessible random oracle

: X

O

• Create an empty database D

X

⊂

×

→
Y .

Y can be eﬃciently simulated on-the-ﬂy as follows:

• On query x

X, check if D contains x. If yes, answer consistently; otherwise sample y $
←−

∈

Y ,

add (x, y) to D, and answer with y.

A classical-accessible oracle simulated on-the-ﬂy is perfectly indistinguishable from a classical-
accessible random oracle.

3.6 Copy-Protection

Below we present the deﬁnition of a copy-protection scheme, adapted from [BJL+21] and originally
due to [Aar09].

Deﬁnition 9 (Copy-Protection Scheme). Let
tions of the form f : X
(CP, Eval) such that for some output space

→

F
Y . A copy protection scheme for

F

(λ) be a class of eﬃciently computable func-
is a pair of QPT algorithms

=

F

Z ):

(
H

D

• Copy Protected State Generation: CP(1λ, df ) takes as input the security parameter 1λ
(that eﬃciently computes f ). It outputs a

and a classical description df of a function f
Z).
mixed state ρf

(

∈ F

∈ D

H

• Evaluation: Eval(1λ, ρ, x) takes as input the security parameter 1λ, a mixed state ρ

(
H

D

Z ), and an input value x

y
X. It outputs a bipartite state ρ′ ⊗ |

y
ih

∈

| ∈ D

Z)

(

H

⊗ D

(
H

9

∈
Y ).

We will sometimes abuse the notation and write Eval(1λ, ρ, x) to denote either the classical output
y
Y or the residual state ρ′ alone when the other is insigniﬁcant. Note that when we work
in CAROM, the algorithms (CP, Eval) will have access to the random oracle and be written as
(CPO, EvalO).

∈

There are three properties we require of a copy-protection scheme: correctness, reusability, and

security.

is honestly evaluated using Eval on any input x

Informally speaking, if an honestly generated copy-protected state ρf for a function
X, the output should be f (x). We present

Correctness:
f
the formal deﬁnition below:

∈ F

∈

Deﬁnition 10 (Correctness). A copy-protection scheme (CP, Eval) for
:
lowing holds for every x

X, f

∈

∈ F

is δ-correct if the fol-

F

Pr

f (x)

Eval(1λ, ρf , x) : ρf

←

←

h

CP(1λ, df )
i

δ.

≥

Correctness property can be relaxed by averaging over inputs x sampled from a distribution

.

D

Deﬁnition 11 (Mean-Correctness). Let
(CP, Eval) for

is (

D

X , δ)-mean-correct if the following holds for every f

X be a distribution over X. A copy-protection scheme

:

∈ F

F

D

Pr

f (x)

h

CP(1λ,df )
Eval(1λ, ρf , x) : ρf ←
x
X

←D

←

δ.

≥

i

Reusability: The correctness notions we deﬁne above are for a single evaluation. In practice,
we would like our copy-protected program to evaluate polynomially many inputs without losing its
functionality. Accordingly, we deﬁne reusability below as a stronger version of these correctness
notions.

Deﬁnition 12 (Reusability). Let (CP, Eval) be a δ-correct copy-protection scheme for
(CP, Eval) is called reusable if the following holds for every m = poly(λ), every (x1, . . . , xm)
and every f

F

:

. Then,
X m

∈

∈ F

Pr

f (xm)

(cid:20)

←

Eval(1λ, ρm

f , xm) :

ρi+1
f ←

ρ1
f ←
Eval(1λ,ρi

CP(1λ,df )
f ,xi), 1

≤

i

≤

m

−

1

≥

(cid:21)

negl(λ).

δ

−

Similarly, let (CP, Eval) be a (

X , δ)-mean-correct copy-protection scheme for

is called reusable if the following holds for any m = poly(λ) and any f

D

:

∈ F

. Then, (CP, Eval)

F

f (xm)

Pr

"

←

Eval(1λ, ρm

f , xm) :

ρi+1
f ←

ρ1
f ←
xi
←D
Eval(1λ,ρi

CP(1λ,df )
i
m
X , 1
≤
≤
f ,xi), 1

≤

i

≤

m

−

1# ≥

negl(λ).

δ

−

Remark 13. In the plain model or the quantum-accessible oracle models, reusability is implied by
correctness by Corollary 3. In particular, δ = 1
1/poly(λ)
−
yields γ = 1/poly(λ). However, in the classical-accessible setting such an implication is unclear
due to the fact that the oracle queries force an intermediate measurement that cannot be pushed to
the end.

negl(λ) yields γ = negl(λ) and δ = 1

−

10

Security: Security in the context of copy-protection means that given a copy-protected program
ρf of a function f
, no QPT adversary can produce two programs that can both be used to
compute f . This is captured in the following deﬁnition adapted from the ”malicious-malicious
security” deﬁnition in [BJL+21]:

∈ F

Deﬁnition 14 (Piracy Experiment). A piracy experiment is a game deﬁned by a copy-protection
scheme (CP, Eval), a distribution
over
X. It is the following game between a challenger and an adversary, which is a triplet of algorithms
(
A

, and a class of distributions DX =

DX (f )
f
}
{

over

DF

∈F

F

):

,

,

C

B
• Setup Phase: The challenger samples a function f

CP(1λ, df ) to

.

and sends ρf

A
applies a CPTP map to split ρf into a bipartite state ρBC ; she sends

← DF

←

A
and the C register to

. No communication is allowed between

C

and

C

B

• Splitting Phase:
the B register to
after this phase.

B

• Challenge Phase: The challenger samples (xB, xC )

DX(f )

×

←

DX(f ) and sends xB, xC

to

,

, respectively.

B

C
• Output Phase:

Y , respectively, and send to the chal-
Y and yC
lenger. The challenger outputs 1 if yB = f (xB) and yC = f (xC), indicating that the adversary
has succeeded, and 0 otherwise.

and

∈

∈

B

C

output7 yB

The bit output by the challenger is denoted by PirExpCP,Eval
DF ,DX

(1λ, (

A

,

,

B

C

)).

Deﬁnition 15 (Copy-Protection Security). Let (CP, Eval) be a copy-protection scheme for a class
a class of
be a distribution over
)
,

, DX, δ)-secure if any QPT adversary (

of functions f : X

F
→
distributions over X. Then, (CP, Eval) is called (
satisﬁes

DX(f )
{

and DX =

Y . Let

DF

DF

}f

A

∈F

F

B

C

,

PirExpCP,Eval
DF ,DX
Note that this deﬁnition is referred to as malicious-malicious security because the adversary is free
to choose the registers B, C as well as the evaluation algorithms used by

1λ, (
(cid:16)

b = 1 : b

and

(cid:17)i

←

Pr

A

≤

δ.

B

C

h

)

,

,

.

B

C

3.7 Quantum-Unlearnability

Below we state the deﬁnition of a quantum unlearnable circuit class from [ALP21], which states
that a QPT adversary cannot output a quantum implementation of C

given oracle access:

∈ C

Deﬁnition 16. A circuit class
if for any quantum adversary

C

is ν-quantum unlearnable with respect to distribution
C making at most poly(λ) queries, we have

C
A

over

DC

Pr

x, Pr[U ∗(ρ∗, x) = C(x)]

∀

ν :

≥

C
(U ∗,ρ∗)

←DC
←A

C(·)(1λ)

negl(λ).

≤

h

i

is simply called ν-quantum un-

If there exists a distribution
learnable.

C satisfying this property, then

D

C

7Since B and C cannot communicate, the order in which they use their share of the copy-protected program is

insigniﬁcant.

11

4

Impossibility in Classical-Accessible Random Oracle Model

We show the infeasibility of copy-protection in the classical-accessible random oracle model (CAROM).
We prove this in two steps:

• First, we show the impossibility of approximately correct copy-protection (even without

reusability) in the plain model.

• Next, we show that any copy-protection in CAROM can be transformed into approximately-
correct copy-protection in the plain model. Invoking the above result, it follows that copy-
protection in CAROM is impossible.

4.1

Impossibility of Approximate Copy-Protection

Following the approach of [ALP21], we will construct a class of circuits, which cannot be learned
via oracle access, yet can be learned given the quantum circuit. The key tool enabling the latter is
the power of homomorphic evaluation. The class of circuits we construct is related to but diﬀerent
from that constructed by [ALP21].

Theorem 17. Assuming the existence of QFHE with malicious circuit privacy and QLWE, there
of circuits of the form G : X
exists an unlearnable class
over X such that there exists no copy-protection scheme (CP, Eval) in the plain model for
(
1
D
and for any

→
, DX, δ(λ))-security for any (ε, δ) satisfying δ

ε(λ))-mean-correctness and (

Y and an input distribution

X
D
with
3√ε

G
−

X , 1

DG

≤

−

G

, DX.

DG

Proof. Let Obf be a quantum-secure lockable obfuscation scheme (see Section 3.4) and QFHE be a
quantum fully homomorphic encryption scheme satisfying malicious circuit privacy (see Section 3.3).
used in the impossibility result of [ALP21], presented in Figure 1.
We ﬁrst recall the circuit class
Every circuit in

are parameters described below.

, where a, b, r, PK,

is of the form Ca,b,r,PK,

C

C
λ.
0, 1
}

• a, b, r
• (PK, SK) is in the support of QFHE.Gen(1λ).
•
is in the support of Obf(CC[QFHE.Dec(SK,

∈ {

O

O

O

), b, (SK
·
Let ^QFHE = (^QFHE.Setup, ^QFHE.Enc, ^QFHE.Dec, ^QFHE.Eval) be a QFHE scheme with mali-

r)]).

||

cious circuit privacy (Deﬁnition 5).

Using

, we deﬁne8 another class of circuits

C

protected. Every circuit in
circuit Ca,b,r,PK,

.

G

O ∈ C

cannot be copy-
in Figure 2. We show that
is of the form GCa,b,r,PK,O , which is a ﬁxed circuit parameterized by a

G

G

Unlearnability. We will ﬁrst show that

is unlearnable with respect to a distribution

G

(λ) outputs a circuit from

λ by sampling a, b, r

QFHE.Gen(1λ), and ﬁnally computing an obfuscation

C

which we deﬁne as follows:
puting (PK, SK)
(b, (SK
mined by the description of C

←

DC

We cite the following result:

∈ C

DC

r))]), where CC is a compute-and-compare circuit. Since every GC
|

,

(λ) induces a distribution

(λ) on

DG

G

(λ),
DC
λ, then com-
0, 1
}

$
←− {
Obf(CC[QFHE.Dec(SK,
is uniquely deter-
.

∈ G
given by GC : C

← DC

),
·

O ←

8In both C and G, we assume padding with zeros appropriately to make input/output lengths compatible.

12

Ca,b,r,PK,

(x):

O

1. If x = 0, output QFHE.Enc (PK, a; r)

as follows:

PK, where

|O|

O

is generated

Obf(CC[QFHE.Dec(SK,

O ←
and-compare circuit.

), b, (SK
·

r)]), where CC is a compute-
|

2. Else if x = a, output b.

3. Otherwise, output 0

Figure 1: Description of a circuit Ca,b,r,PK,

in

.

C

O

GCa,b,r,PK,O (

PK, X):

f

1. Parse X as ciphertext CT .

2. Compute and output CT ∗ ←

^QFHE.Eval fPK(Ca,b,r,PK,

, CT ).

O

Figure 2: Description of a circuit G

∈ G

, used for proving impossibility of approximate CP

Lemma 18 (Proposition 46 in [ALP21]). For any non-negligible function ν = ν(λ),
unlearnable with respect to

(λ).

DC

is ν-quantum

C

Using this as a black-box, we can now prove unlearnability of

Lemma 19.

G

is unlearnable with respect to the distribution

DG

Proof. Suppose that there exists an unbounded quantum adversary
poly(λ) queries and satisﬁes

A

GC (
·

) which makes at most

:

G
(λ).

Pr

x, Pr[U ∗(ρ∗, x) = G(x)]

∀

ν(λ) :

≥

C
(U ∗,ρ∗)

←DC
←A

GC (·)(1λ)

µ(λ)

≥

) to construct an adversary which violates

i

h

for some non-negligible functions ν, µ. We will use
the unlearnability of C.
We will proceed in two steps:

GC (
·

A

• By malicious circuit privacy of ^QFHE, there exists an unbounded quantum adversary (

)

A′)C(

·

) and satisﬁes
which makes at most poly(λ) queries to C(
·
ν(λ)

x, Pr[U ∗(ρ∗, x) = G(x)]

Pr

negl(λ) :

≥

−

∀
h
µ(λ)

≥

negl(λ).

−

13

(U ∗,ρ∗)

C

←DC
(
A

←

′)C(·)(1λ)
i

(2)

A′ simply uses (^QFHE.Sim, ^QFHE.Ext) and oracle access to C(
• Using (
satisﬁes

) to simulate the queries of
A
·
) which makes at most poly(λ) queries to C(
) and
·

), we will construct (

A′)C(

.

·

·

A′)C(
f

x, Pr[U ∗(ρ∗, x) = C(x)]

Pr

≥

∀
h
µ(λ)

negl(λ).

−

ν(λ)

−

≥

negl(λ) :

(U ∗,ρ∗)

C

←DC
f
(
A

←

′)C(·)(1λ)
i

(3)

·

) does the following:

A′)C(
(
– Run (
f
– Output (U ∗, ρ), where U ∗(ρ, x) does the following:
^QFHE.Setup(1λ) and CT

)(1λ) to obtain (U, ρ)

A′)C(

·

1. Compute (PK, SK)
2. Compute CT∗

←

U (ρ, (PK, CT)).
←
^QFHE.Dec(SK, CT∗).

3. Output y

←

^QFHE.Enc(PK, x)

←

Conditioned on (U, ρ) satisfying the event in eq. (2), (U, ρ∗) will satisfy the event in eq. (3)
by correctness of ^QFHE evaluation, thereby violating µ-quantum unlearnability of

.

C

Lemma 20. There exists
model for
ε, δ satisfying δ

with (

X, 1

D
1

−
3√ε.

G

≤

−

Proof. Deﬁne

X such that there is no copy-protection scheme (CP, Eval) in the plain
, DX, δ(λ))-security for any DX and any

D
ε(λ))-mean-correctness and (

DG

X :=

D

^QFHE.Enc fPK(x) :
(cid:26)

fPK, fSK)
(
x

←
$
←−{

^QFHE.Setup(1λ)
poly(λ)

0,1

(cid:27)
Suppose there is an approximate copy-protection scheme (CP, Eval) for

ε(λ)-mean-
G
correctness. Let ρ
in Figure 3 that given
ρ, can recover an approximate classical description of G with probability greater than δ(λ), hence
violating security9.

CP(1λ, GCa,b,r,PK,O ). We construct a QPT adversary

with 1

←

A

−

}

Analysis of

A

(ρ): By approximate correctness of (CP, Eval), we have

Pr

GC(x)

Eval(1λ, ρ, x) : ρ

←

←

CP(1λ,GC )
x
X

←D

Eval(1λ, ρ, ^QFHE.Enc fPK(x)) :

i

h
= Pr

GC (x)

←

"

1

−

≥

ε(λ).

ρ
←
fPK, fSK)
(
x

CP(1λ,GC )
^QFHE.Setup(1λ)
poly(λ)

←
$
←−{

0,1

}

#

(4)

9The attack is simply to recover the classical description and send it to both parties at the splitting phase. Note

that this attack succeeds irrespective of the test distributions DX .

14

(ρ):

A

1. Compute (

PK,

SK)

^QFHE.Setup(1λ).

←

2. Compute CT
f

^QFHE.Enc fPK(0).
f

←

3. Run the copy-protection evaluation, ρ′ ⊗
4. Run the decryption, (CTa

PK)
classical, maintain a copy of CTa.

|O|

←

CT ∗ ←

Eval(1λ, ρ, CT ).

^QFHE.Dec fSK(CT ∗). Since CTa is

5. Run the QFHE homomorphic evaluation,

CT∗b ←

QFHE.EvalPK(Φ, CTa),

where Φ is a quantum circuit that on input σ, does the following:

(a) Compute σ1 ←
(b) Compute σ2 ←
(c) Compute σ3 ←
6. Compute the unitary

7. Compute a

←

8. Output GCa,b,r′,PK,O .

PK, σ).

^QFHE.Enc(
QFHE.Eval(PK, Eval(1λ,
f
^QFHE.Dec(
SK, σ2) and output σ3.

,
·

), QFHE.Enc(
·

PK, ρ′), σ1).

f

f

on CT∗b and measure basis to obtain (sk′|
QFHE.Dec(sk′, CT∗b).

QFHE.Dec(sk′, CTa) and b

O

r′).

←

Figure 3: Description of

A

Eval(1λ, ρ, ^QFHE.Enc fPK(x)) :

←

Deﬁne

ζx := Pr

GC (x)

so that eq. (4) can be written as

h

ρ
←
fPK, fSK)
(

CP(1λ,GC )
^QFHE.Setup(1λ)
i

←

E

[ζx]

1

−

≥

ε(λ).

poly(λ)

x

$
←−{

0,1

}

,

(5)

(6)

We observe that
ζx
|
is not negligible. Deﬁne an adversary
ciphertext CT

| ≤
^QFHE.Enc(

PK, x),

ζx′

−

negl(λ) for any x, x′ ∈ {

poly(λ). To see this, suppose the diﬀerence
0, 1
}
A′ who can break semantic security of ^QFHE. Given a

A′ does the following:

←

• Sample ρ

CP(1λ, GC )

f

←

• Output 1 if GC(x)

←

Eval(1λ, ρ, CT ), and 0 otherwise.

15

A′ outputs 1 with probability ζx, hence she can distinguish encryptions of x and x′, contradiction.
negl(λ) for all x. Let E1 be the event that CT ∗ = ^QFHE.Enc(
PK, QFHE.EncPK(a)
Hence,

ζx
|

ζ0| ≤

−

PK), then by eq. (6) we have

|O|

f
negl(λ).

−

(7)

Pr [E1] = ζ0 ≥

E

[ζx

−

negl(λ)]

1

ε(λ)

≥

−

}

x

1

0,1

≥

≤

−

A

p

poly(λ)

E1]

negl(λ).

$
←−{
At this stage, by modifying Eval if necessary, we can assume T (ρ′, ρ)
lary 3. Let E2 be the event

ε(λ) + negl(λ) by Corol-
succeeds in step 4; in particular, E2 implies CTa = QFHE.Enc(PK, a).

By ^QFHE correctness we have Pr [E2 |
Conditioned on E2, step 5b is nothing but a QFHE homomorphic evaluation of Eval(1λ, ρ′, σ1),
^QFHE.Enc fPK(CTa). Equation (7) holds for any ζx′ including ζCTa, hence Eval(1λ, ρ, σ1)
where σ1 ←
negl(λ), i.e. it will output a QFHE encryption of b. Since
will succeed with probability 1
ρ′ is √ε-close to ρ in trace distance, it follows that Eval(1λ, ρ′, CTa) will succeed with probability
negl(λ). This inequality together with correctness of ^QFHE and correctness of
1
−
−
QFHE homomorphic evaluation imply that Pr [E3 |
ε(λ),
1
−
where E3 is the event that CT∗b ∈
QFHE.EncPK(b). Conditioned on E1, E2, E3, the adversary can
negl(λ) by correctness of QFHE and Obf.
recover the true classical description with probability 1
Thus,

A′ succeeds in recovering the classical description of GC wiith probability at least
E2]

Pr [E3]

Pr [E1]

negl(λ)

negl(λ)

negl(λ)

ε(λ)

ε(λ)

ε(λ)

ε(λ)

ε(x)

E1]

E2]

p

p

p

−

−

−

≥

−

−

≥

−

−

2

1

−
ε(λ)

−
ε(λ),

(1

1

−
3

−

≥

≥

≥

Pr [E3 |
negl(λ)) (1
−

·
negl(λ))(1

Pr [E2 |
−

·
ε(λ))

−
negl(λ)

−

≥

2

p

p
which suﬃces for the proof.

4.2

Impossibility of Copy-Protection in CAROM

Assuming impossibility of approximate copy-protection in the plain model, we will show that it is
negl(λ))-correctness
impossible to have a copy-protection scheme in CAROM which satisﬁes (1
-security. The proof will follow closely the proof in [CKP15], which shows impos-
and
sibility of classical virtual-black-box obfuscation in the random oracle model assuming its impossi-
bility in the plain model.

1
poly(λ)

−

−

(cid:16)

(cid:17)

1

Lemma 21. Let δ = δ(λ) be a function and

be a class of functions of the form f : X

Y . Let

F
, X, respectively, and DX =

f

,

D

X be distributions over

DF
over X. Assume that
negl(λ))-mean-correctness and (
scheme (CPO, EvalO) in CAROM for
with (
security. Then, for any noticeable function ε there exists a copy-protection scheme (
the plain model with (

be a class of distributions
D
{
X can be eﬃciently sampled. Suppose there exists a reusable copy-protection
, DX , δ)-
CP) in

ε(λ))-mean-correctness and (

, DX, δ)-security.

DF
Eval,

X , 1

X , 1

g

f
}

∈F

−

D

D

F

F

X

→

DF
Combining Lemma 21 with Theorem 17, we have the following.

−

D

g

f

16

Theorem 22 (Main Theorem). There exists an unlearnable class of circuits
distribution
(
X , 1
D
and any distributions

(λ) and an input
X such that there does not exist a reusable copy-protection scheme in CAROM with
ε(λ))-security for any noticeable function ε

negl(λ))-mean-correctness and (

, DX, 1

DF

−

−

=

D

G

G

, DX.

DF

Proof of Lemma 21. Let10 (CPO, EvalO) be given as in the lemma statement. Since CPO and EvalO
both run in polynomial time, the numbers of queries they make to
are bounded by some
M = poly(λ) and N = poly(λ), respectively. We will construct a valid copy-protection scheme
2M
CP,
.
(
ε ⌉

in the plain model. Let T :=

Eval) for

O

F

⌈

g

Copy Protection:
f
df of a function f

∈ F
f

CP(1λ, df ) takes as input the security parameter 1λ and the classical description

, and it does the following:

1. Simulate on-the-ﬂy a classical random oracle

to be used in any of the steps below.

O

2. Run ρf

←

CPO(1λ, df ).

3. Set ρ1

f := ρf . Pick S

$
←− {
X .

(a) Sample xi
← D
(b) Compute ρi+1
f ⊗ |
their answers in a database Di

| ←

yi

yi

ih

Eval.

0, 1, . . . , T

. For i = 1 to S:
1
}

−

EvalO(1λ, ρi

f , xi) and record the queries made by Eval with

4. Sample random oracle answers r1, r2, . . . , rN

$
←−
queries not recorded in any of the databases Di
Eval.

Y . These will be used by

Eval to answer

5. Output the state

DEval

ρf := ρS+1

N
j=1 |
ρf , x) takes as input the security parameter 1λ, a copy-protected state
f

, where DEval :=
|

f ⊗ |

DEval

Eval.

N

S

rj

rj

ih

ih

|

ρ, and

g
S
i=1 Di

Evaluation:
an input x

Eval(1λ,
X, and it does the following:
g

∈
1. Parse the state

f
ρf as ρf
the database D and the oracle answers

⊗ |

D

D

ih

|

N
rj
j=1 |
rj
{

rj
ih
|
N
j=1.
}

N

f

by measuring the registers corresponding to

e

y
ih

y
2. Run ρ′f ⊗ |

EvalO(1λ, ρf , x), answering the oracle queries of Eval as follows: to answer
the jth query made by Eval, answer consistently if the query is in D, and answer using rj
if the query is not in D (without loss of generality Eval does not make repeated queries).
Output the state

| ←

D

D
ρ′f ⊗ |
(cid:16)

ih

|

N
j=1 |

rj

ih

rj

y
⊗ |

y
ih

.
|

N

∈ F

. By (

|
(cid:17)
X , 1

D

Approximate Correctness: Fix f
of (CPO, EvalO), we have

negl(λ))-mean-correctness and reusability

−

Pr

f (xS+1)

"

←

EvalO(1λ, ρS+1

f

, xS+1) :

CP(1λ,df )
ρ1
f ←
i
xi
S+1
X , 1
≤
←D
≤
EvalO(1λ,ρi
f ,xi), 1

ρi+1
f ←

negl(λ).

1

−

(8)

S# ≥

i

≤

≤

10In [CKP15], the number of test executions (T ) has an extra factor of N . Our modiﬁed analysis could also be

applied to their construction to get rid of the factor of N .

17

D (1λ, ρf , x), where
g

Eval emulates EvalO, using the database D = DEval to answer oracle queries and using
Recall that
the independent random answers rj when the query is not in D. This is equivalent to running
EvalO
D is deﬁned as a random oracle conditioned to be consistent with D.
O
CP. Let E be the event that Eval(1λ, ρf , x)
Let DCP be the set of queries made by CP in step 2 of
Eval.11 Keep in mind that
does not make any oracle query in DCP
Eval emulates EvalO at the time of the (S + 1)st test execution. Hence, E is equivalently the event
that Eval(1λ, ρS+1
and xS+1 are as in eq. (8).
g
D (1λ, ρf , x) are
Conditioned on E, the emulation of
Eval by lower-bounding
perfectly indistinguishable. Hence, we can lower-bound the correctness of
the probability of E:

DEval, where ρS+1
Eval is ﬂawless, i.e. EvalO(1λ, ρf , x) and EvalO

DEval during the execution of
f

, xS+1) makes no query in DCP

g

g

\

\

f

f

Pr

f (x)

Eval(1λ,

←

fCP(1λ,df )
ρf , x) : fρf ←
x
←D

X

h
= 1

g
f
= f (x) :

Pr

y
"

−

i

X

←

CPO(1λ,df )

fCP(1λ,df )
fρf ←
x
←D
gEval(1λ,fρf ,x)#
y
ρf ←
$
0,1,...,T
S
1
←−{
−
}
xi
S+1
i
X , 1
≤
←D
≤
EvalO(1λ,ρi
f ,xi), 1
EvalOD (1λ,ρS+1
ρf ←
$
0,1,...,T
S
1
←−{
−
}
S+1
i
X , 1
xi
≤
←D
≤
EvalO(1λ,ρi
f ,xi), 1
EvalOD (1λ,ρS+1

ρi+1
f ←
y

ρi+1
f ←
y

CPO(1λ,df )

≤
≤
,xS+1)

= f (xS+1) :







←

S

i

f

f

←

i

≤
≤
,xS+1)

g

E

+ Pr [

¬

E]









S

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(9)

= f (xS+1) :

= 1

−

Pr 
y





1

−

≥



Pr [E]

Pr 

y

·




Pr [

−

(8)

≥

1





E]

¬

−

negl(λ).

Therefore, the following claim will suﬃce for the proof together with eq. (9):

Claim 23. Pr [

¬

E]

≤

ε(λ)
2 .

Proof. Consider the following experiment, which consists of T executions of EvalO with random
inputs:

1. Let

be a random oracle.

O
2. Compute ρf

CPO(1λ, df ).

←

3. Set ρ1

f := ρf . For i = 1 to T :

(a) Sample xi
← D
(b) Compute ρi+1
f ⊗ |
Eval in this step.

X .

yi

yi

ih

| ←

EvalO(1λ, ρi

f , xi). Let Di

Eval be the set of inputs queried by

11Here by a slight abuse of notation we only consider the input x ∈ X of the query and not the answer y ∈ Y .

18

6
6
6
j<i Dj

Di

1

(cid:0)

\

DCP

Eval ∩

Let wi =
Eval
new queries from DCP made by EvalO at the ith step above. Let pi = Pr [wi
S
that a new query is made at the ith step. Recall that
uniformly at random, hence Pr [
i

[T ]. Now, by linearity of expectation we have

T
i=1 pi is the probability that wi

1] be the probability
≥
Eval chooses the number of test executions
1 for a random

be the random variable corresponding to the number of

E] = 1
T

g

≥

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

¬

(cid:1)

≤

∈

T

T

i=1
X

Therefore, Pr [

¬

pi

≤

i=1
X
E] = 1
T

E [wi] = E

T
i=1 pi

≤

T

"

i=1
X
M
T ≤

P

wi

#

= E



ε
2 as desired.

T

∩ 

j=1
[



DCP

≤ |

| ≤

M.

Dj

Eval







(cid:12)
(cid:12)
(cid:12)
(cid:12)

DCP
(cid:12)
(cid:12)
(cid:12)
(cid:12)



Copy-Protection Security: Suppose there is an adversary

P

pirating experiment for (

CP,

Eval) with probability ε, i.e.

,

,

B

A

e

e

(cid:16)

which succeeds in the

C

(cid:17)
e

Pr

b = 1 : b
g

f
h

PirExp

←

fCP, gEval
DF ,DX

1λ,
(cid:16)
AO,
(cid:0)

(cid:16)
e
BO,
CO

,

,

B

A

C

= ε.

(cid:17)(cid:17)i
e

Using

,
A

,

B

C

, we will construct an adversary

e
which succeeds in the pirating ex-

(cid:16)

(cid:17)
periment for (CP, Eval) with probability ε. This will immediately imply δ-security of (
e
the δ-security of (CP, Eval).

e

e

(cid:1)

CP,

Eval) by

, respectively, so that they do not make any queries.

f

g

We set
We deﬁne

BO and

CO to be identical to
C
, as follows:
AO, which has oracle access to
e
1. Given a copy-protected program ρf =: ρ1

and

f , pick S

O

B

e

S:

$
←− {

0, 1, . . . , T

1
}

−

and repeat for i = 1 to

(a) Sample xi
(b) Run ρi+1

← D
yi

X
yi

f ⊗ |

ih

| ←

recording them with their answers in a database Di

Eval.

EvalO(1λ, ρi

f , xi), forwarding the oracle queries of Eval to

and

O

2. Sample random oracle answers r1, r2, . . . , rN

3. Set

ρf := ρS+1

DEval

DEval

ih

|

N
j=1 |

rj

rj

ih

f ⊗ |
on the state

ρf .

N

4. Run

f
A

Y .

$
←−
, where DEval :=
|

S
i=1 Di

Eval.

S

By construction, the bipartite state received by
f

. This is because the on-the-ﬂy simulation done by

BO and

CO is identical to that received by
B
CP is perfectly indistinguishable from the

e

and
real oracle answers provided by

C

. Therefore,

Pr

= Pr

h

h

as desired.

O
b = 1 : b

b = 1 : b

f
1λ, (

1λ,

(cid:16)

(cid:16)

,

,

B

C

A

)

(cid:17)i

,

,

B

A

e

e

(cid:16)

C

(cid:17)(cid:17)i
e

= ε

PirExpCP,Eval
DF ,DX
fCP, gEval
DF ,DX

PirExp

←

←

19

References

[Aar04]

Scott Aaronson. Limitations of quantum advice and one-way communication.
In
Proceedings of the 19th IEEE Annual Conference on Computational Complexity, CCC
’04, page 320–332, USA, 2004. IEEE Computer Society.

[Aar09]

Scott Aaronson. Quantum copy-protection and quantum money. In 2009 24th Annual
IEEE Conference on Computational Complexity, pages 229–242. IEEE, 2009.

[ABDS21] Gorjan Alagic, Zvika Brakerski, Yfke Dulek, and Christian Schaﬀner. Impossibility of

quantum virtual black-box obfuscation of classical circuits. In CRYPTO, 2021.

[AC12]

In
Scott Aaronson and Paul Christiano. Quantum money from hidden subspaces.
Proceedings of the forty-fourth annual ACM symposium on Theory of computing, pages
41–60, 2012.

[AGKZ20] Ryan Amos, Marios Georgiou, Aggelos Kiayias, and Mark Zhandry. One-shot signa-
tures and applications to hybrid quantum/classical authentication. In Proceedings of
the 52nd Annual ACM SIGACT Symposium on Theory of Computing, pages 255–268,
2020.

[AK21]

Prabhanjan Ananth and Fatih Kaleoglu. Uncloneable encryption, revisited. In TCC,
2021.

[AKL+22] Prabhanjan Ananth, Fatih Kaleoglu, Xingjian Li, Qipeng Liu, and Mark Zhandry. On

the feasibility of unclonable encryption, and more. In CRYPTO, 2022.

[ALL+21]

Scott Aaronson, Jiahui Liu, Qipeng Liu, Mark Zhandry, and Ruizhe Zhang. New
approaches for quantum copy-protection. In CRYPTO, 2021.

[ALP21]

Prabhanjan Ananth and Rolando L La Placa. Secure software leasing. In Eurocrypt,
2021.

[BDF+11] Dan Boneh, ¨Ozg¨ur Dagdelen, Marc Fischlin, Anja Lehmann, Christian Schaﬀner, and
Mark Zhandry. Random oracles in a quantum world. In International conference on the
theory and application of cryptology and information security, pages 41–69. Springer,
2011.

[BI20]

[BJ15]

Anne Broadbent and Rabib Islam. Quantum encryption with certiﬁed deletion.
Theory of Cryptography Conference, pages 92–122. Springer, 2020.

In

Anne Broadbent and Stacey Jeﬀery. Quantum homomorphic encryption for circuits
of low t-gate complexity. In Annual Cryptology Conference, pages 609–629. Springer,
2015.

[BJL+21] Anne Broadbent, Stacey Jeﬀery, S´ebastien Lord, Supartha Podder, and Aarthi Sun-

daram. Secure software leasing without assumptions. In TCC, 2021.

[BL20]

Anne Broadbent and S´ebastien Lord. Uncloneable quantum encryption via oracles. In
TQC, 2020.

20

[Bra18]

[BV16]

Zvika Brakerski. Quantum fhe (almost) as secure as classical. In Annual International
Cryptology Conference, pages 67–95. Springer, 2018.

Nir Bitansky and Vinod Vaikuntanathan. Indistinguishability obfuscation: from ap-
In Theory of Cryptography Conference, pages 67–95. Springer,
proximate to exact.
2016.

[CDM20] Orestis Chardouvelis, Nico Doettling, and Giulio Malavolta. Rate-1 secure func-
tion evaluation for bqp. Cryptology ePrint Archive, Report 2020/1454, 2020.
https://ia.cr/2020/1454.

[CKP15]

Ran Canetti, Yael Tauman Kalai, and Omer Paneth. On obfuscation with random
oracles. In Yevgeniy Dodis and Jesper Buus Nielsen, editors, Theory of Cryptography,
pages 456–467, Berlin, Heidelberg, 2015. Springer Berlin Heidelberg.

[CLLZ21] Andrea Coladangelo, Jiahui Liu, Qipeng Liu, and Mark Zhandry. Hidden cosets and

applications to unclonable cryptography. In CRYPTO, 2021.

[CMP20]

Andrea Coladangelo, Christian Majenz, and Alexander Poremba. Quantum copy-
protection of compute-and-compare programs in the quantum random oracle model.
arXiv preprint arXiv:2009.13865, 2020.

[Die82]

DGBJ Dieks. Communication by epr devices. Physics Letters A, 92(6):271–272, 1982.

[GKVW19] Rishab Goyal, Venkata Koppula, Satyanarayana Vusirikala, and Brent Waters. On

perfect correctness in (lockable) obfuscation. 2019.

[GKW17] Rishab Goyal, Venkata Koppula, and Brent Waters. Lockable obfuscation. In 2017
IEEE 58th Annual Symposium on Foundations of Computer Science (FOCS), pages
612–621. IEEE, 2017.

[Got02]

Daniel Gottesman. Uncloneable encryption. arXiv preprint quant-ph/0210062, 2002.

[GZ20]

Marios Georgiou and Mark Zhandry. Unclonable decryption keys.
ePrint Arch, 877(2020):3, 2020.

IACR Cryptol.

[KNY21]

Fuyuki Kitagawa, Ryo Nishimaki, and Takashi Yamakawa. Secure software leasing
from standard assumptions. In TCC, 2021.

[Mah18]

Urmila Mahadev. Classical homomorphic encryption for quantum circuits. In 2018
IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS), pages
332–338. IEEE, 2018.

[RS19]

Roy Radian and Sattath. Semi-quantum money. Proceedings of the 1st ACM Confer-
ence on Advances in Financial Technologies, Oct 2019.

[Wie83]

Stephen Wiesner. Conjugate coding. ACM Sigact News, 15(1):78–88, 1983.

[Win99]

A. Winter. Coding theorem and strong converse for quantum channels. IEEE Trans-
actions on Information Theory, 45(7):2481–2485, 1999.

21

[WZ82]

[WZ17]

William K Wootters and Wojciech H Zurek. A single quantum cannot be cloned.
Nature, 299(5886):802–803, 1982.

Daniel Wichs and Giorgos Zirdelis. Obfuscating compute-and-compare programs under
In 2017 IEEE 58th Annual Symposium on Foundations of Computer Science
lwe.
(FOCS), pages 600–611. IEEE, 2017.

[Zha19a] Mark Zhandry. How to record quantum queries, and applications to quantum in-
In Alexandra Boldyreva and Daniele Micciancio, editors, Advances
diﬀerentiability.
in Cryptology – CRYPTO 2019, pages 239–268, Cham, 2019. Springer International
Publishing.

[Zha19b] Mark Zhandry. Quantum lightning never strikes the same state twice.

In Annual
International Conference on the Theory and Applications of Cryptographic Techniques,
pages 408–438. Springer, 2019.

22

