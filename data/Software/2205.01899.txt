A Tool For Debugging Quantum Circuits

Sara Ayman Metwalli
Keio Quantum Computing Center
Keio University
Fujisawa, Japan
sara@sfc.wide.ad.jp

Rodney Van Meter
Keio Quantum Computing Center
Keio University
Fujisawa, Japan
rdv@sfc.wide.ad.jp

2
2
0
2

y
a
M
4

]
h
p
-
t
n
a
u
q
[

1
v
9
9
8
1
0
.
5
0
2
2
:
v
i
X
r
a

Abstract—As the scale of quantum programs grows to match
that of classical software, the nascent ﬁeld of quantum software
engineering must mature and tools such as debuggers will become
increasingly important. However, developing a quantum debug-
ger is challenging due to the nature of a quantum computer;
sneaking a peek at the value of a quantum state will cause either
partial or complete collapse of the superposition and may destroy
the necessary entanglement. As a ﬁrst step to developing a full
quantum circuit debugger, we have designed and implemented
a quantum circuit debugging tool. The tool allows the user to
divide the circuit vertically or horizontally into smaller chunks
known as slices, and manage their simulation or execution for
either interactive debugging or automated testing. The tool also
enables developers to track gates within the overall circuit and
each chunk to understand their behavior better. Feedback on
usefulness and usability from early users shows that using the
tool to slice and test their circuits has helped make the debugging
process more time-efﬁcient for them.

Index Terms—Quantum circuits, Debugging, Quantum Soft-

ware

I. INTRODUCTION

A. The Need For a Quantum Debugging Tool

The forty-year history of quantum computers has taken us
through initial curiosity, naive optimism, then dismay at the
scale of proposed error-corrected systems, and into today’s
excitement over the availability of real, but still small and
error-prone, systems [1]–[3]. Algorithms have followed a sim-
ilar roller coaster, arriving at the point where modest demon-
stration implementations of algorithms originally deﬁned as
abstract equations in theory papers are now common [4]. The
challenge on both hardware and software now is scalability:
more qubits and larger, more sophisticated programs where,
unlike today’s demonstrations, the results are not a priori
known. Working at large scale implies the need for a mature
software engineering (SE) approach, including tools for all
phases of the life cycle.

Software engineering follows a certain cycle, and is a
reasonably mature process. Two important phases are the
design and development of the key conceptual elements, and
testing and ﬁxing bugs 1. The conceptual elements may be
supported with formal speciﬁcations, pseudocode, libraries,
modeling tools and languages, etc. Bugs arise from mistakes in
the speciﬁcation of a program, or from mistakes in translating
the speciﬁcation into code (or, sometimes, from bugs in the
tools themselves). A variety of methods, both formal and
informal, are used to ﬁnd such bugs and to prevent their

recurrence once isolated and ﬁxed. Unit testing, regression
testing and continuous integration, path coverage testing, and
the many types of test cases that software testers construct all
contribute to locating and eliminating the different types of
bugs. Using these techniques and tools, it is now possible to
construct and support systems as complex as tens of millions
of lines of code, as in the Linux kernel and other similar
systems.

If we consider the quantum software development cycle
described in [5] as shown in Fig. 1, we can ﬁnd general
similarities to the classical software development cycle. There
are two major differences in debugging quantum programs.
Quantum computers can operate on superpositions of values,
each with a complex amplitude [6], [7]. It might be assumed
that the exponential growth in the state space poses a funda-
mental problem, but in fact the problem is more nuanced. n
classical bits can carry any of 2n values, yet we do not worry
about testing all 2n input values for a program, let alone all of
the astronomical number of possible states when we include
temporary variables. (After all, a system with 1GB of RAM
has 28,589,934,592 possible states, almost all of which will never
be reached.) Instead, we focus on key paths and expected input
values, and work to build robust error handling for the vast
majority of unwanted states. With quantum, the process is
different, and we often have to consider the behavior of all
of the possible inputs.

The ﬁrst, most important, challenge lies in the nature of
quantum algorithms: their goal is not to simply ﬁnd a solution
to a problem, but instead to build interference patterns that
raise the amplitude of correct solutions to problems at the
expense of incorrect solutions. Algorithms consist of blocks
that perform essentially classical computations, and blocks that
use the state so created to effect constructive and destructive
interference. Thus, when dealing with quantum circuits, we
can divide the behaviour of blocks (or slices) into two main
categories:

• Pseudo-classical slices: These are circuits that imitates the
behaviour of classical gates but perform on superposition,
such as quantum adders and Grover’s oracle.

• Full-quantum slices: These are circuits that alter the
distribution of amplitudes, especially by creating inter-
ference patterns, such as the Grover diffusion operator
and the quantum Fourier transform.

 
 
 
 
 
 
Based on the different characteristics of those types, the
process of debugging them will differ greatly. It will even
differ within each type. If we look closely to the pseudo-
classical circuits, we can further categorize it into simple and
complex pseudo classical circuits. These two cases, which are
essentially classical reversible logic [8], [9], are distinguished
primarily by the difﬁculty of generating test cases with ad-
equate coverage. For an adder, for example, we might test a
few simple inputs, test overﬂow cases, and reason by induction
about the rest. For a complex slice, we want to know if it
correctly identiﬁes a solution to the problem, but we do not
a priori know a solution. (If we did, we would have no need
for the computer!) This is often addressed by building simple,
small test cases, then extending to larger problems. In quantum
systems, we can stick with similar techniques and basic unit
testing and debugging, without the need to address the issue
of exponentially large superpositions.

The challenge arises when we are addressing the full-
quantum slices, because these circuits contain quantum prop-
really debug using traditional debugging
erties we can’t
techniques. How do we debug the changing amplitudes and
conﬁrm the interference patterns we need? Similar to the
pseudo-classical circuits, we can further separate full-quantum
circuits based on their size and complexity, into simple and
complex circuits. Although creating test vectors for either type
is not as simple as doing so for the pseudo-classical circuits,
coming up with test vectors for simple full-quantum circuits
should be more straightforward than the complex ones. For
example, creating test vectors for a 4-qubit quantum circuit
with only 4 Hadamard gates is simpler than creating test
vectors for a circuit of 10-qubits and 50 different quantum
gates.

Another major challenge is quantum circuits that are
problem-speciﬁc. Rather than a data-independent loop struc-
ture, for example, input values are generally expressed as a
series of gates. A graph state problem, for example, might be
compiled to include gates corresponding to each edge in the
graph [10]. Thus, extending from the simple test cases to a
speciﬁc problem can be an error-prone process, and our SE
methods and tools must address this issue.

B. The state of quantum software today

In the future, we can expect that problem-speciﬁc com-
pilation will become an automated process, but today the
programmer speciﬁes gates by hand, making validation an
important step. However, supporting both newcomers to the
ﬁeld as well as experienced quantum programmers as they
attempt to build intuition and learn to create the interference
patterns that drive quantum algorithms will require building
new tools and deﬁning new concepts [11].

Today, there are approaches developers could take to trans-
form their algorithms and ideas into quantum circuits [12],
[13], and if they are small/ medium-scale, they can attempt
to execute it on an actual quantum hardware. These available
approaches differ based on the core programming model. We
can generally divide these approaches into four categories.

• High-level quantum programming language supporting
the developer’s quantum intuition and allowing them to
use it to build and design quantum algorithms. Exam-
ples of such programming languages are Sliq [14] and
Quipper [15].

• Gate-level programming. In this option, the developer
translates his idea into a sequence of gates and then either
simulates this circuit, visualizes it or runs on a hardware
device. We can divide options within this category even
further.

– Building the circuit using code, often using a
classical-language-supported library or package. Ex-
amples of this option are Qiskit [16], Cirq [17], and
PyQuil [18].

– Using a drag-and-drop tool to build the circuit and
then simulate the results and view them visually.
These tools include, QUI [19],
the IBM Circuit
Composer [20], and Quirk [21].

– Using

the Quantum Assembly

language,

or

QASM [22].

• Building the circuit using other compilation paradigms.
– Using a low-level approach, for example, using
the quan-
pulses and signals to directly control
tum hardware, the main example for that is Open-
Pulse [16].

– Using a more quantum physics and mechanics ap-

proach like using the ZX-calculus [23].

– Circuit optimizer, back-end compilers and inter-
preters. For example Tket [24], TriQ [25], and Qb-
solv [26].

All of these tools, regardless of their compilation model,
focus on the current generation of hardware, on small pro-
grams and on the important problems of optimization and
mapping to speciﬁc processors [27]–[29], as well as tackling
designing and implementing programs for hybrid, or adaptive,
algorithms [30]–[34]. For now, most of these tools leave it
to the programmer to mentally plan the algorithm and to
examine the outputs to assess whether the program operates
as intended, though some researchers are working to advance
formal veriﬁcation methods into the quantum arena [35].
However, we need to start building tools for the future of
quantum, because as we move toward large scale, key elements
are missing in the current quantum software development
tool-chain, including a quantum debugger and the tools for
automating program testing such as unit tests. Both of these
depend on the ability to isolate a portion of a quantum
circuit, examine and understand its inner functionality. More
speciﬁcally, the programmer needs to understand the interfaces
among the parts, and to prepare input vectors and check their
corresponding outputs without paying exponential costs in
state or time spaces, whether the circuit is being simulated
or executed on an a quantum computer. This, however, will
not be possible as the circuit size increases and classical
devices fail to simulate them. Inevitably, of course, working
on a sub-circuit in this fashion raises questions about how to

Fig. 1: A general life cycle of classical software vs quantum software as described in [5].

assess correctness without the exponential number of terms in
a quantum superposition. As quantum debugging becomes a
focus and an essential skill for the current and next generations
of quantum circuits and developers, the value of a tool that
enables the understanding of the circuit as well as the error
reasons will only increase.

Solving the challenge of debugging quantum circuits is not
going to be a simple task, but it is deﬁnitely a challenge that we
need to address and attempt to solve the best we can, and that
is the target of this work. In this paper, we present our quantum
circuit debugging implemented and developed using Python
and Qiskit . The tool will allow developers to divide their
circuits into smaller chunks, categorize these chunks, and test
them making the process of locating and ﬁxing bugs relatively
easier. This paper is structured as follows, we will ﬁrst go
over the difference between classical and quantum software
development cycles, then move on to an overview of the tool,
its APIs, and a usage example, the results of experimenting
with the tool and will be concluded with discussions about
related works, current, and future versions of the tool.

II. TOWARDS A QUANTUM DEBUGGING TOOL

A. The First Step: A Quantum Circuit Slicer

The current state of classical debuggers is the result of
decades of research [36], development, and experiments [37].
One of the most basic concept used in classical debugging is
the concept of program slicing [38]. A program tool is used
to divide a big body of code into smaller, easy to test and
manage chunks. Each of these chunks is called a slice.

Slices are formed in two ways, either manually using
breakpoints [39], or using a form of automatic/semi-automatic
slicing. Using breakpoints, the debugger can divide the code
so that the user can observe its behaviour and the variables’

contents within each slice. There are different types of au-
tomated program slicing, the basic two are static slicing and
dynamic slicing. Static slicing works by slicing the program
based on a variable or set of variable by eliminating the lines
of code that don’t include or affect that variable directly or
indirectly. In dynamic slicing, on the other hand, the slice is
formed using variable(s) and condition(s). The variable(s) and
condition used to form the slices are called the slicing criteria.
As discussed in section I-A, as the availability, interest, and
current size of the available systems continue to increase, the
size of circuits implemented will also increase. Hence, we
implemented a quantum circuit debugging tool that includes
a circuit slicer based on the concepts of manual slicing and
breakpoints. A quantum circuit slicer will divide a large circuit
into smaller, simulatable sub-circuits to prove the use of the
circuit both in the current NISQ (Noisy Intermediate-scale
Quantum Computers) era [1] and the future era of fault tolerant
quantum computing.

Generally, quantum algorithms tend to follow a set of
steps to solve a problem. All quantum algorithms start with
preparing the qubits in a speciﬁc state or in a uniform
superposition, then perform some arithmetic and calculations,
followed by redistribution of the amplitudes. Depending on the
algorithm and the problem being solved, some may include
some classical pre-processing or post-processing after the
measurement procedure Fig. ??. For example, let us consider
Grover’s algorithm, which consists of three algorithms steps,
preparing the qubits in a uniform superposition, followed by
a problem-speciﬁc oracle and then a diffusion operator. In the
algorithm the oracle and diffusion will repeat multiple times
until the answer is reached.

We implemented a manual slicer, where the user inserts
breakpoint (in a quantum context, breakbarriers) in the circuit

Fig. 2: The different steps needed to implement and execute quantum algorithms.

and then simulate the resultant slices or run them on an actual
device to observe their behaviour. To make the tool useful
for all sizes of circuits and devices, it has to be able to slice
the circuits on two axes, the gate axis (vertically) and the
register axis (horizontally) Fig. 4. That is, the user can insert
breakbarriers vertically in the circuit to divide it into smaller
circuits, as well as horizontally to remove any qubits that are
unused in any of the slices.

1) Vertical Slicing: To explain the methodology and con-
cept of slicing, let us think of a circuit corresponding to
Grover’s algorithm [40]. We can use breakbarriers to form
divide the circuit into slices based on each algorithmic step.
Grover’s algorithm consists of three main algorithmic steps:
initial state preparation, an oracle, and the diffusion operator.
In order to keep things simple, assume the Grover’s algorithm
we are slicing consists of one iteration of the algorithm. to
slice this circuit we will insert two breakbarriers, one after the
state preparation and one after the oracle. This will result in
three sub-circuits each performs a speciﬁc step in the overall
algorithm.

The circuit slicer offers two options for vertical slicing

Fig. 3:

• Stand-alone slices: the slices are deﬁned by the break-

points.

• Accumulated slices: Each slice is added to the slice before

it to create a new slice.

2) Horizontal Slicing: Sometimes after slicing the circuit
vertically, we may end up with a slice that contains some
unused qubits. Since our goal of slicing the circuit is creating
smaller, simulatable, executable circuits, having unused qubits
is redundant. Hence we can do some horizontal slicing to
remove these unused qubits from the slice. The current version
of the tool only allows for automatic slicing of unused qubits.
Future expansion will allow users to manually insert horizontal
breakbarriers in case of slices with two independent registers
or set of qubits.

B. Testing the individual slices

An important question we need to answer is, how can we
test the individual slices resulted from the tool? In order to

know what debugging or testing technique to use with each
slice, we need to be able to obtain the categorization of each
slice ﬁrst.

The current version of the QCS categorizes the slices by
investigate the size of the circuit and the type of gates involved
in it and how they effect the states entanglement and the
interference patterns of the circuit. Moreover, to better help
the developer during the testing process, the tool allows the
developer to choose a slice and a preparation state to set it
in for debugging. The developer can choose to test any given
slice on a uniform superposition state, a speciﬁc state or a
symmetric state. Currently, the tool can prepare any number
of qubits in three commonly used symmetric states, the GHZ
state, W state [41] and Dicke state [42]. In addition to passing
the slice and the initial state wanted to the testing function,
the user needs to input a test vector (or a list of test vectors)
for the tool to examine the slice’s behaviour.

C. Gates tracking

it

When an error occurs while executing a circuit on an
is often due to one of two reasons,
actual hardware,
either it is a machine-related one or a semantic (logical) one.
Machine-related errors are low-level, hardware-speciﬁc faults
such as gate errors, readout errors, thermal relaxation errors,
measurements errors, etc [43]–[45]. Fixing these types of
errors requires implementing quantum error correction, some
efﬁcient error minimizing technique [46] (or getting very, very
lucky on a given run). However, if the circuit is simulated, only
semantic errors can occur.

Semantic errors, on the other hand, result in incorrect results
on the simulator or even when the machine works properly.
These type of errors exist also on the classical realm, and
causes the program to misbehave even if the code didn’t
include syntactic errors. Semantic errors are more difﬁcult to
resolve in quantum circuits than in classical programs, in part
because most quantum algorithms select an outcome from a
probability distribution at the end of a run, and in part because
of their use of superposition, entanglement and interference.
Thus, isolating the section of the circuit containing the error
requires careful reasoning and the ability to narrow down

Fig. 3: A generic Grover’s algorithm circuit sliced using both stand-alone slicing and accumulated slicing.

operation to make the error as reproducible, and visible, as
possible.

a whole new type. That was accomplished by adding two
methods:

One aspect of this is the need for the programmer to
work both forward and backward through the tool-chain,
examining the circuit at the gate level as well as the higher-
level functions that generated the circuit. QCS provides an
option for the programmer to track where in the code was
each gate added to the circuit. Currently this is done through
using an analogous to the traceback information, by printing
the line of code, function or module where the gate was
added. Another approach we are considering is the including
of debugging symbols in an object ﬁle, making it easy to match
the gate causing the circuit to malfunction to the corresponding
line of code.

D. The Tool’s API overview

The tool discussed in this paper is built using Python on
top of the Qiskit module. In Qiskit, any quantum circuit is
built using an object class QuantumCircuit. Any QuantumCir-
cuit object can contain QuantumRegisters, ClassicalRegisters,
different quantum gates and measurement operations. The
Qiskit QuantumCircuit object contains many proprieties and
characteristics. In order to build our tool, we extended this
class to include few new commands to include breakbarriers
to cut the circuit and gate tracking option. In addition to these,
we added new functionalities to perform the horizontal and
vertical slicing. We can divide the functionality the debugging
tool adds to Qiskit into two categories, methods added to the
QuantumCircuit class and the debugger’s core functionality.

1) Methods Added to The QuantumCircuit Class: Since
all quantum circuits that can be built using Qiskit use the
QuantumCircuit object, we decided to extended that class
to include the debugging-needed methods instead of creating

1) breakbarrier(): a new object

type based on
Qiskit’s barrier class that is used to pinpoint where the
tool is going to cut the circuit when using the Vertical
tool function (VSlicer).

2) gateInfo(): a method that, when the debugging
mode is enabled, is used to store information about all
gates added to the circuit. The information is the gate
type, the number of occurrences and where in the code
this gate was added to the circuit.

2) The Debugger’s Core Functionality: In addition to the
methods added to the QuantumCircuit class, we deﬁned new
functions that make use of these new methods to enable the
debugger functionality. We mainly added four functions.

1) startDebug(): This function enables the debugging
mode by extending the QuantumCircuit Class to include
both breakbarrier and gateInfo methods.

2) VSlicer(): This function takes a QuantumCircuit
object that contains breakbarriers and then divides the
circuit based on the location of those breakbarrier and
return the original circuit as well as a list of sub-circuits
corresponding to the dividing the circuit based on the
breakbarrier locations.

3) HSlicer(): This function removes unused qubits or
QuantumRegisters from a sub-circuit after using the
vertical slicer.

4) gateLoc(): This function takes a circuit or a sub-
circuit and a gate, then displays how many times and
where in the code was this gate added to the circuit.
A summary of the methods and functions added to Qiskit

to allow the tool to function in Table. I.

Fig. 4: A generic circuit for Grover’s algorithm sliced into 3 vertical slices, then the ﬁrst slice is horizontally re-sliced to
remove unused qubits.

Instruction
breakbarrier
gateInfo

VSlicer

HSlicer

startDebug()

gateLoc

Oprands
QauntumCircuit method
QuantumCircuit method
Takes a QuantumCircuit object
Returns a list of sub-circuits
Takes a QuantumCircuit slice
Returns a list of sub-circuits
Enter debugging mode function
Takes a QuantumCircuit and a Gate
Prints Gate information

TABLE I: tool API overview

Description
A method used on a QuantumCircuit object to slice it into smaller sub-circuits.
A method used to keep track of all gates added to the circuit when debugging mode is enabled.

Vertical tool function that cuts the circuit based on the breakbarriers added to the QuantumCircuit object.

The horizontal tool function cuts the slice horizontally to remove unused QuantumRegisters.

Adding this function will start debugging mode by adding breakbarrier to the QuantumCircuit object and start gate tracking.

A function that displays the information of a certain gate from the gateInfo method.

III. THE SLICER IN ACTION

To better understand how the slicer can help developers
understand their circuits and locate errors in it, let’s consider
an actual example of an implementation of Grover’s algorithm
applied to the triangle ﬁnding problem, where a graph is
given and we try to ﬁnd a 3-node complete graph (a triangle)
within the larger graph. This problem has been addressed
both classically [47], [48] and quantumly [49], [50]. Although
there are various ways this problem can be solved quantumly,
using Grover is one of the simplest, most straightforward
approaches.

For this example problem, let’s consider the 4-node graph
in Fig. 5. As we mentioned earlier, an arbitrary implementa-
tion of Grover’s algorithm consist of three algorithmic steps,
stage preparation, the oracle and the diffusion operator. The
oracle and diffusion operator need to be repeated a total
number of opt_iter cyclically. This optimal number of
times depends on two factors, the size of the search space N
and the number of answers for our problem m (how many
triangles in the graph, in this case one) and is calculated
using opt iter =
[51]. In our example, the search
space is the entire Hilbert space; which contains 24 cases

(cid:113) N
m

(cid:106) π
4

(cid:107)

Fig. 5: A 4-node graph with a triangle between nodes 1,2, and
3.

|0000(cid:105), |0001(cid:105), ....., |1111(cid:105). Using that formula and in case of
m = 1, the opt_iter will be 3.

We will use a simple oracle circuit packaged in a function
that aims to mark the correct answer, in our example state
|0111(cid:105). The code has of three sections, the state preparation,
which consist of Hadamard gates to form the complete Hilbert
space, the oracle which marks the state |0111(cid:105), and the dif-
fusion operator. For this speciﬁc example, dividing the circuit

into three independent steps was relatively simple, because we
just followed the algorithmic steps.

To implement this circuit we need 6 ancillary qubits, and a
3 qubits a ﬂag that would be in state |111(cid:105) only if a triangle
is found in the graph. We can write this using Python and
Qiskit as shown in Listing. 1.

1 from qiskit import QuantumRegister,

ClassicalRegister, QuantumCircuit

2 import numpy as np
3 import math as m
4 def grover():
5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

# Hilbert space size

n_nodes = 4
N = 2**n_nodes
#Defone needed qubits
nodes_qubits = QuantumRegister(n_nodes, name=’
nodes’)
ancilla = QuantumRegister(6, name = ’anc’)
flag = QuantumRegister(3, name=’check_qubits’)
class_bits = ClassicalRegister(n_nodes, name=’
class_reg’)
tri_flag = ClassicalRegister(3, name=’tri_flag’)
qc = QuantumCircuit(nodes_qubits, ancilla, flag,

class_bits, tri_flag)

# Initialize quantum flag qubits in |-> state
qc.x(flag[2])
qc.h(flag[2])
# Initializing i/p qubits in superposition
qc.h(nodes_qubits)
# Calculate optimal iteration count
iterations = round(m.pi/4.sqrt(N))
#in case of debugging, we will make iteration =
1
for i in np.arange(iterations):

oracle(n_nodes, qc, nodes_qubits, ancilla,

flag)

diffusion(qc, nodes_qubits, ancilla)
qc.breakbarrier() #for debugging only, must

be used after startDebug() is called
return qc

Listing 1: Python and Qiskit code implementing Grover’s
algorithm for the triangle ﬁnding problem.

Now, let’s assume we ran this code and the results didn’t
come out as we expected; that is, the correct answer wasn’t
marked correctly, which means it doesn’t have a higher
probability of being measured. To try and locate the error,
let’s use the slicer to examine each step of the code closely.
To do that we will ﬁrst need to access debugger mode by
calling the startDebug function and then apply breakbarrier
to the circuit using the Vslicer function with the mini mode.
Applying the Vslicer function to our circuit will result in
a list of three slices. We can rename those slices to make
them easier to handle and address as in Listing. 2. Since the
algorithm will be repeated 3 times, the resultant circuit will
end up with repeated, identical parts. Hence, there will be
three copies of each the Oracle and the diffusion circuits. So,
for debugging purposes, we can focus on one iteration only.

1 from qcs.qcs import startDebug
2 from qcs.slicer import Vslicer, Hslicer
3 #start debug mode of the quantum circuit
4 QuantumCircuit = startDebug()
5 qc = grover()

6 # Vslicer() returns a list; in this example we know

a priori it will be length 3 because we have 3
algorithmic steps that we sliced the circuit
based on

7 state_prep, orac, diff = Vslicer(qc, mode = "mini")
8 #Apply the horizontal slicer on the state

preparation and diffusion sections to remove the
ancilla and flag qubits so we can only test the
operational qubits.
9 state_prep = Hslicer(state_prep)
10 diff = Hslicer(diff)
11 #Testing the state preparation
12 TestQReg = QuantumRegister(4)
13 TestCir = QuantumCircuit(TestQReg)
14 TestCir.append(state_prep, qargs=TestQReg)

Listing 2: The triangle ﬁnding problem in debugging mode.

Although the ﬁrst section in the circuit (the state prepara-
tion) is a full-quantum circuit, it is relatively simple to test.
If we think about all possible circuits that may fall under the
category full-quantum, we see that we can further categorize
these circuits. Some which only has a few number of qubits
and gates can be tested and veriﬁed rather easier than large
circuits with many gates. In the case on this example, the
circuit only has 4 Hadamard gates applied to 4 qubits. The
Hadamard gate is responsible for creating the superposition.
In this case, a superposition over 4 qubits, that is 24 states.
Testing this slice is not difﬁcult. Before we move on to testing
the slice, we ﬁrst need to remove the qubits that are not used.
In the state preparation section of the algorithm, we need to
focus on the four qubits representing the nodes of the graph,
hence, using the Hslicer function we can remove the unused
qubits allowing us to examine the four operational qubits.

To test the state prep, we will create a test circuit, and will
call it testCir1. This circuit will contain 4 qubits and the
state_prep slice as in Listing. 2.

When we run this test, we will get the expected 16 inter-
mediate states which is the equal superposition of all possible
4-qubit states ( 1
i=0 |i(cid:105)). Which leads us to conclude that
4
the error is not in the state preparation section. So, we will
move on to the oracle slice.

(cid:80)15

The oracle slice in this example is a simple pseudo-classical
slice, and we can test it by initializing an empty circuit with
the same number of qubits as our original circuit and set
the ﬂag qubit to the state |−(cid:105) and then apply the oracle to
a superposition of the operational qubits. We can write this in
Python as in Listing. 3.

1 from qiskit import QuantumRegister,

ClassicalRegister, QuantumCircuit, Aer, execute

2 from qcs.qcs import startDebug
3 from qcs.slicer import Vslicer, Hslicer
4 M_simulator = Aer.backends(name=’qasm_simulator’)
5 #Testing the oracle
6 TestQReg = QuantumRegister(4)
7 Anc = QuantumRegister(6)
8 flagQubits = QuantumRegister(3)
9 TestCReg = ClassicalRegister(4)
10 flagBits = ClassicalRegister(3)
11 TestCir = QuantumCircuit(TestQReg, TestCReg, Anc,

flagQubits, flagBits)

12 TestCir.append(orac, qargs=[TestQReg, Anc,

flagQubits])

13 #Measuring the operation and flag qubits

14 qc.measure(TestQReg,TestCReg)
15 qc.measure(flagQubits, flagBits)
16 M = execute(qc, M_simulator, shots= 1024).result().

get_counts(qc)

Listing 3: Testing the oracle. At the end of this code, M
contains classical measurement counts that can be compared
against expected values, either by hand during debugging or
in a scripted test suite for regression and SQA.

3

4

5

6

7

8

result
in multiple states with
Running this test will
different combination of
the node qubits and the ﬂag
qubits with different possibilities based on the number
of shots used in the execute function. For example, a
like,
run to the oracle testing slice will get a result
(26|0101(cid:105)|000(cid:105), ..., 33|0111(cid:105)|111(cid:105), 35|0110(cid:105)|000(cid:105)).
The
numbers before each state is the probability of the state being
measured within 1024 shots. These numbers are not constant
and will differ on each run and with different number of
shots. What we are looking for in this test is a case where
the ﬂag qubits are in the state |111(cid:105), the operational qubits
state that accompany this ﬂag qubits state is the answer
the oracle’s marks. In this test, we can see that the oracle
marks the correct answer which is |0111(cid:105). In our example,
the number of states we need to examine is small and can
be tracked by eye, which is not the case as the circuit size
increases. In those cases, a simple program can be written to
search for the |111(cid:105) ﬂag qubits state, using regular expression
or another search technique that will make the process of
ﬁnding what the oracle marks faster and more efﬁcient.

execute a rotation about the average to increase the probability
of measuring the correct answer, or the answer marked by
the oracle. Generally, if we used the Hadamard gates as the
form of state preparation, the diffusion operator should look
as shown in Fig. 6-A. For our example, the diffusion operator
code is shown in Listing. 4

1 def grover_diff(qc, nodes_qubits, ancilla):
2

qc.h(nodes_qubits)
qc.x(nodes_qubits)
#Apply 3 control qubits Z gate
cnz(qc,len(nodes_qubits)-1,nodes_qubits,ancilla)
qc.x(nodes_qubits)
qc.x(nodes_qubits[0])
qc.h(nodes_qubits)

Listing 4: The function constructing the diffusion operator
(that results in an error due to an extra NOT gate in line 7).

Now we know that

the reason our circuit

is giving a
wrong answer is probably because of a bug in the diffusion
operator (a full-quantum circuit). Unlike the state preparation,
the diffusion operator is somewhat more difﬁcult to test. So,
we need to look at the deﬁnition of the diffusion operator.
Mathematically, the diffusion operator D is deﬁned as D =
state prep R state prep†, where R is a a zero reﬂection
or a zero-phase shift. This phase shift can be calculated by
R = 2|0(cid:105)⊗n(cid:104)0|⊗n − In, where In is the identity matrix on n
qubits [40], [52], [53]. When we examine this equation and
try to test if the function in Listing. 4 correctly implement it,
we can see that we have something missing.

We can tell that our diffusion function is missing some NOT
gates. To correctly implement the diffusion operator, we need a
multi-controlled Z gate sandwiched by NOT gates. Because we
have 4 qubits, then we will need a 3control Z gate surrounded
by 8 NOT gates Fig. 6-B.

Now, we can use the gateLoc function to obtain extra
information about the NOT gate within the diffusion operator.
We can simply do that by calling the function as gateLoc(diff,
”x”).

1 --------------------------
2 There are 3 times where the x gate was added to the

circuit.

3 It was added to the circuit in the following

locations:

4 File_directory, File_name, line 25, in <module>
diffusion(qc, nodes_qubits, ancilla)
5

6
7 File "file_name", line 3, in grover_diff
8

qc.x(nodes_qubits)

9
10 File "file_name", line 6, in grover_diff
11

qc.x(nodes_qubits)

12
13 File "file_name", line 7, in grover_diff
14
15 --------------------------

qc.x(nodes_qubits[0])

Fig. 6: The general construction of the diffusion operator.

The last part of the circuit we need to test is the diffusion
operator. Since we already tested the other parts of the circuit
and made sure that
they function properly, we can, with
some conﬁdence, say that the error occurs in the diffusion
operator. The diffusion operator is added to the circuit to

Listing 5: The output of the gateLoc function when querying
the NOT gate in the diffusion operator

Examining the output of gateLoc in Listing. 5, we can see
that the slicer tells us that the NOT gate were added to the
circuit 3 times. We should pay attention here that two of those

three times, the gate was applied to an entire register. That is,
in lines 3 and 6 of the diffusion function Listing. 4 that NOT
was applied to all qubits within the nodes_qubits register.
So, based on that we can conclude that the NOT gate was
added a total of 9 times and not the correct amount of 8. By
removing the extra NOT gate added in line 7 in Listing. 4, and
then testing the entire circuit, we can see that we successfully
located the error and ﬁxed it.

The example in this section is a simple, short one for
the purpose of illustrating the functionality of the debugger.
However, the same concepts and methodology applied to it
can be extended to any other quantum circuit with any size
and number of qubits.

IV. EVALUATION

Our main goal in developing a quantum circuit slicing tool is
to assist developers and quantum computing learners to better
understand their circuits and to be able to extend and alter
them. In order to evaluate our tool, we released a beta version
to a group of quantum programmers/ researchers with different
levels of expertise in the ﬁeld of quantum computing, from
absolute beginners to experts.

We focused on assessing a couple factors:

the ease of
installing and using the tool, the usefulness of the tool in
understanding the circuit and how much it helped in locating
a bug in exercises we created or a quantum circuit containing
an error that the programmers/ researchers chose. In addition,
we sought out how the programmers/ researchers utilized the
tool in order to decide the development of future versions of
the tool. We as well as a group of researchers used the beta
version of the slicer on some quantum circuits and answer a
survey about their experiences using the tool and the properties
of the circuits they are used it on. The algorithm names, size,
and other information about the circuits used to test the slicer
are in Table II. All of the circuits used for the initial testing
of the tool contained reproducible bugs resulting from either
an incorrect implementation of the algorithm or by an error in
applying the gates to certain qubits.

After using the current version of the tool, the software
developers agreed that using the tool made locating the bug in
the circuit a more efﬁcient task. Using the tool helped them
decrease much of the manual load they would often do when
attempting to debug and test their quantum circuits.

V. RELATED WORK AND DISCUSSION

Debugging quantum computing has been a concern of many
researchers since the beginning or quantum computing. Some
researchers have been making more progress designing and
establishing a framework to debug computing in the recent
years, targeting different levels of the design. If we desire
to debug a quantum computer, we will need to be more
speciﬁc about the level of implementation the debugger will
be targeting. In quantum computing, there are different levels
of implementation starting with the higher level, which is the
algorithmic implementation, then the circuit level, and the
lower level the consists of electrical pulses executed on an

actual hardware. One of the examples of a quantum debugger
is the effort done by Q#. Q# is a full-on quantum development
environment developed by Microsoft to be similar to C#. Q#
offers various ways to debug a quantum circuit, in particular
NISQ era quantum programs. They offer the use of one of
the most common testing approaches in classical debugging,
which is unit testing. Unit testing is a useful testing and
debugging technique if the results of the circuit are known.
If the circuit behaviour is not easy to understand however,
writing test cases for it will not be an easy task and hence unit
testing will not be as useful. Another tool Q# offers, is facts
and assertion and those deal in case your function or circuit
does not run on the hardware or if the hardware returns a ”no
results”.

Besides Q#, there is some work done on debugging quantum
circuits at run time [54], or using statistical methods [55].
Some work have also been done on trying to establish a quan-
tum programming development cycle, similar to the classical
software cycle to suggest different techniques that can be used
in each step [5] [56] and the debugging tactics for quantum
algorithms [56].

Moreover, since understanding the ﬂow of quantum pro-
grams and the causes of errors is essential to the ability of de-
bugging quantum circuits, researchers focused on reproducible
bugs and categorizing the occurrences of bugs in quantum
programs [57], [58]. In one of these works [59], the possible
bugs that might occur when implementing quantum algorithms
were divided into 4 categories: bugs due to the API used to
implement the algorithm, bugs due to a fault in the logic of the
application, math-related bugs, or bugs due to an error aside
of the above reasons.

All

these efforts focus on addressing the debugging of
quantum programs, none actually offers a systematic approach
to debugging quantum circuits. The tool proposed in this paper
should help the developers ﬁnd and ﬁx the different types of
bugs from one caused because of the API used to the ones
resultant from a faulty implementation of the algorithm. In
addition, we address the higher level algorithmic side of the
implementation. Our tool does not only aim at debugging a
circuit, but to also help programmers understand their circuit
better. Because if they do, they will be able to perform more
efﬁcient debugging process.

VI. CONCLUSION & FUTURE WORK

When dealing with quantum circuits, validating the correct-
ness of the answer remains the biggest challenge quantum
technology faces today and if a debugging tool is not devel-
oped, this challenge will get more difﬁcult as the circuit size
increase and the ability of current hardware improves.

We tested the functionality of the debugging tool by re-
leasing a beta version for a small group of developers to
test and use on some small and medium-scale circuits. The
developers used the core functionality of the tool to simplify
their circuits, better understand its behaviour, and locate bugs
using the gate tracker functionality. After using the tool, the
developers answered a survey to help us understand their

TABLE II: QCS experiments details displaying information about the circuits used in experiments based on Qiskit

Algorithm
QFT
Full Adder
Simon’s algorithm for 2 qubits with the secret string 11
Grover for triangle ﬁnding
4-qubit Quantum counting

LOC
8
26
28
115
86

Circuit size
7
11
11
172
470

No. of qubits
3
4
6
13
8

gates
[3*H, 3*CP, 1*SWAP]
[3*CCNOT, 5*CNOT]
[6*H, 5*CNOT]
[42*CCNOT, 25*H, 17*X, 16*CNOT, 12*MCCNOT, 2*CZ]
[192*H, 180*NOT, 30*CCNOT, 30*MCT, 30*Z, 2*SWAP, 6*CU1]

No. of slices
4
4
3
3
6

No. of algorithmic steps
5
4
3
3
3

Ave. size of the slice
2 gates/ slice
2 gates slice
3 gates/ slice
28 gates/ slice
40 gates/slice

experience and assist us in improving the tool in the future.
Moreover, we examined how our tool would ﬁt in with other
existing efforts towards better understanding quantum circuits
and hence debugging them.

The debugging tool proposed in this paper is the start of
a larger tool that can transform the future of debugging and
understanding quantum circuits and we plan on expanding it
further in the future. Further expansion of the tool that are
currently underdevelopment is:

• Tune the categorization criteria to more accurately cate-
gorize the slices. We believe a more detailed categoriza-
tion will lead to easier debugging.

• Expand the gate tracking function to make it more ﬂexible
and to make the query function more efﬁcient by letting
the user deﬁne further information about
the gate in
question, such as speciﬁc range in the code or within
a function.

• Develop an automated testing function for commonly
used subroutines in quantum algorithms such as QFT,
quantum walks and Grover’s diffusion operator.

Finally, to achieve our optimal goal of easing up the process
of building, understanding and debugging quantum circuits,
we are working on developing a graphical interface where the
user can slice, examine and test the circuit without needing to
write any code.

ACKNOWLEDGMENT

This work was supported by MEXT Quantum Leap Flagship

Program Grant Number JPMXS0118067285.

REFERENCES

[1] J. Preskill, “Quantum computing in the nisq era and beyond,” Quantum,

vol. 2, p. 79, 2018.

[2] T. Ladd, F. Jelezko, R. Laﬂamme, Y. Nakamura, C. Monroe, and
J. O’Brien, “Quantum computers,” Nature, vol. 464, pp. 45–53, Mar.
2010.

[3] R. Van Meter, “A #quantumcomputerarchitecture tweetstorm,” Sep.
2019. [Online]. Available: https://doi.org/10.5281/zenodo.3496597
[4] A. Montanaro, “Quantum algorithms: an overview,” npj Quantum Infor-

mation, vol. 2, p. 15023, 2016.

[5] B. Weder, J. Barzen, F. Leymann, M. Salm, and D. Vietz, “The
quantum software lifecycle,” in Proceedings of the 1st ACM SIGSOFT
International Workshop on Architectures and Paradigms for Engineering
Quantum Software, 2020, pp. 2–9.

[6] R. S. Sutor, Dancing with Qubits. Packt Publishing, 2019.
[7] J. Preskill, “Lecture notes for ph/cs 219 at caltech,” available on
[Online]. Available: http://www.theory.caltech.edu/

the web, 2019.
∼preskill/ph219/index.html#lecture

[8] C. H. Bennett, “Logical reversibility of computation,” IBM J. Res.

Develop., vol. 17, pp. 525–532, 1973.

[9] ——, “Notes on the history of reversible computation,” IBM J. of
Research and Development, vol. 32, no. 1, 1988, reprinted in IBM J.
R.&D. Vol. 44 No. 1/2, Jan./Mar. 2000, pp. 270–277.

[10] S. A. Metwalli, F. Le Gall, and R. Van Meter, “Finding small and
large k-clique instances on a quantum computer,” IEEE Transactions
on Quantum Engineering, 2020.

[11] S. Ali, T. Yue, and R. Abreu, “When software engineering meets
quantum computing,” Commun. ACM, vol. 65, no. 4, p. 84–88, mar
2022. [Online]. Available: https://doi.org/10.1145/3512340

[12] B. Heim, M. Soeken, S. Marshall, C. Granade, M. Roetteler, A. Geller,
M. Troyer, and K. Svore, “Quantum programming languages,” Nature
Reviews Physics, vol. 2, no. 12, pp. 709–722, 2020.

[13] S. Gay, “Quantum programming languages: Survey and bibliography,”
Bulletin of the European Association for Theoretical Computer Science,
Jun. 2005.

[14] B. Bichsel, M. Baader, T. Gehr, and M. Vechev, “Silq: A high-level
quantum language with safe uncomputation and intuitive semantics,” in
Proceedings of the 41st ACM SIGPLAN Conference on Programming
Language Design and Implementation, 2020, pp. 286–300.

[15] A. S. Green, P. L. Lumsdaine, N. J. Ross, P. Selinger, and B. Valiron,
“Quipper: a scalable quantum programming language,” in Proceedings
of the 34th ACM SIGPLAN conference on Programming language design
and implementation, 2013, pp. 333–342.

[16] G. Aleksandrowicz, T. Alexander, P. Barkoutsos, L. Bello, Y. Ben-
Haim, D. Bucher, F. Cabrera-Hern´andez, J. Carballo-Franquis, A. Chen,
C. Chen et al., “Qiskit: An open-source framework for quantum com-
puting,” vol. 16, 2019.

[17] Google AI, “Cirq, a python framework for creating, editing, and
invoking noisy intermediate scale quantum (nisq) circuits,” 2018.
[Online]. Available: https://github.com/quantumlib/Cirq

[18] Rigetti Computing, “Pyquil: Quantum programming in python.”

[Online]. Available: https://github.com/rigetti/pyquil

[19] University of Melbourne, “Qui, a quantum user interface tool,” 2018.

[Online]. Available: https://qui.research.unimelb.edu.au

[20] A. C. Santos, “The ibm quantum computer and the ibm quantum

experience,” arXiv preprint arXiv:1610.06980, 2016.

[21] C. Gidney, “Tools.” [Online]. Available: https://algassert.com/
[22] A. W. Cross, L. S. Bishop, J. A. Smolin, and J. M. Gambetta, “Open
quantum assembly language,” arXiv preprint arXiv:1707.03429, 2017.
[23] A. Kissinger and J. van de Wetering, “Pyzx: Large scale automated
diagrammatic reasoning,” arXiv preprint arXiv:1904.04735, 2019.
[24] S. Sivarajah, S. Dilkes, A. Cowtan, W. Simmons, A. Edgington, and
R. Duncan, “t— ket¿: a retargetable compiler for nisq devices,” Quantum
Science and Technology, vol. 6, no. 1, p. 014003, 2020.

[25] P. Murali, N. M. Linke, M. Martonosi, A. J. Abhari, N. H. Nguyen,
and C. H. Alderete, “Full-stack, real-system quantum computer studies:
Architectural comparisons and design insights,” in 2019 ACM/IEEE
46th Annual International Symposium on Computer Architecture (ISCA).
IEEE, 2019, pp. 527–540.

[26] M. Booth, J. Berwald, U. Chukwu, J. Dawson, R. Dridi, D. Le,
M. Wainger, and S. P. Reinhardt, “Qci qbsolv delivers strong clas-
sical performance for quantum-ready formulation,” arXiv preprint
arXiv:2005.11294, 2020.

[27] F. T. Chong, D. Franklin, and M. Martonosi, “Programming languages
and compiler design for realistic quantum hardware,” Nature, vol. 549,
no. 7671, pp. 180–187, 2017.

[28] M. Y. Siraichi, V. F. d. Santos, S. Collange, and F. M. Q.
Pereira, “Qubit allocation,” in Proceedings of the 2018 International
Symposium on Code Generation and Optimization, ser. CGO 2018.
New York, NY, USA: ACM, 2018, pp. 113–125. [Online]. Available:
http://doi.acm.org/10.1145/3168822

[29] S. Nishio, Y. Pan, T. Satoh, H. Amano, and R. Van Meter, “Extracting
success from ibm’s 20-qubit machines using error-aware compilation,”
J. Emerg. Technol. Comput. Syst., vol. 16, no. 3, May 2020. [Online].
Available: https://doi.org/10.1145/3386162

[30] E. Farhi, J. Goldstone, and S. Gutmann, “A quantum approximate
optimization algorithm,” arXiv preprint arXiv:1411.4028, 2014.
[31] T. Hogg and D. Portnov, “Quantum optimization,” Information
Sciences, vol. 128, no. 3, pp. 181 – 197, 2000. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/S0020025500000529

ACM Program. Lang., vol. 4, no. OOPSLA, Nov. 2020. [Online].
Available: https://doi.org/10.1145/3428218

[55] Y. Huang and M. Martonosi, “Statistical assertions for validating patterns
and ﬁnding bugs in quantum programs,” in Proceedings of the 46th
International Symposium on Computer Architecture, 2019, pp. 541–553.
[56] A. Miranskyy, L. Zhang, and J. Doliskani, “On testing and debugging

quantum software,” arXiv preprint arXiv:2103.09172, 2021.

[57] P. Zhao, J. Zhao, Z. Miao, and S. Lan, “Bugs4q: A benchmark of real
bugs for quantum programs,” in 2021 36th IEEE/ACM International
Conference on Automated Software Engineering (ASE).
IEEE, 2021,
pp. 1373–1376.

[58] J. Campos and A. Souto, “Qbugs: A collection of reproducible bugs
in quantum algorithms and a supporting infrastructure to enable con-
trolled quantum software testing and debugging experiments,” in 2021
IEEE/ACM 2nd International Workshop on Quantum Software Engineer-
ing (Q-SE).

IEEE, 2021, pp. 28–32.

[59] J. Luo, P. Zhao, Z. Miao, S. Lan, and J. Zhao, “A comprehensive study
of bug ﬁxes in quantum programs,” arXiv preprint arXiv:2201.08662,
2022.

[32] J. R. McClean, J. Romero, R. Babbush, and A. Aspuru-Guzik, “The
theory of variational hybrid quantum-classical algorithms,” New Journal
of Physics, vol. 18, no. 2, p. 023023, 2016.

[33] A. Peruzzo, J. McClean, P. Shadbolt, M.-H. Yung, X.-Q. Zhou, P. J.
Love, A. Aspuru-Guzik, and J. L. O’Brien, “A variational eigenvalue
solver on a photonic quantum processor,” Nature communications, vol. 5,
2014.

[34] C. A. Trugenberger, “Quantum optimization for combinatorial searches,”
New Journal of Physics, vol. 4, pp. 26–26, apr 2002. [Online]. Available:
https://doi.org/10.1088%2F1367-2630%2F4%2F1%2F326

[35] R. Rand, J. Paykin, and S. Zdancewic, “Qwire practice: Formal veri-
ﬁcation of quantum circuits in coq,” arXiv preprint arXiv:1803.00699,
2018.

[36] F. Tip, “A survey of program slicing techniques,” Journal of Program-

ming Languages, vol. 3, pp. 121–189, 1995.

[37] A. Kotok, “DEC debugging tape,” Memo MIT-1 (rev.), MIT (Dec.
[Online]. Available: https://www.computerhistory.org/

1961), 1961.
pdp-1/189cc577e7b13aafbb0efab4c547d262/

[38] B. Xu, J. Qian, X. Zhang, Z. Wu, and L. Chen, “A brief survey of
program slicing,” ACM SIGSOFT Software Engineering Notes, vol. 30,
no. 2, pp. 1–36, 2005.

[39] B. W. Lampson and K. A. Pier, “A processor for a high-performance
personal computer,” in Proceedings of the 7th annual symposium on
Computer Architecture, 1980, pp. 146–160.

[40] L. K. Grover, “A fast quantum mechanical algorithm for database
search,” in Proceedings of the twenty-eighth annual ACM symposium
on Theory of computing, 1996, pp. 212–219.

[41] D. Cruz, R. Fournier, F. Gremion, A. Jeannerot, K. Komagata, T. Tosic,
J. Thiesbrummel, C. L. Chan, N. Macris, M.-A. Dupertuis et al.,
“Efﬁcient quantum algorithms for ghz and w states, and implementation
on the ibm quantum computer,” Advanced Quantum Technologies, vol. 2,
no. 5-6, p. 1900015, 2019.

[42] R. H. Dicke, “Coherence in spontaneous radiation processes,” Physical

review, vol. 93, no. 1, p. 99, 1954.

[43] S. S. Tannu and M. K. Qureshi, “Mitigating measurement errors in quan-
tum computers by exploiting state-dependent bias,” in Proceedings of the
52nd Annual IEEE/ACM International Symposium on Microarchitecture,
2019, pp. 279–290.

[44] K. Temme, S. Bravyi, and J. M. Gambetta, “Error mitigation for
short-depth quantum circuits,” Phys. Rev. Lett., vol. 119, p. 180509, Nov
2017. [Online]. Available: https://link.aps.org/doi/10.1103/PhysRevLett.
119.180509

[45] S. Endo, S. C. Benjamin, and Y. Li, “Practical quantum error mitigation
for near-future applications,” Phys. Rev. X, vol. 8, p. 031027, Jul
2018. [Online]. Available: https://link.aps.org/doi/10.1103/PhysRevX.8.
031027

[46] Y. Li and S. C. Benjamin, “Efﬁcient variational quantum simulator
incorporating active error minimization,” Phys. Rev. X, vol. 7, p.
021050, Jun 2017. [Online]. Available: https://link.aps.org/doi/10.1103/
PhysRevX.7.021050

[47] J. L. Castellanos, S. G´omez, and V. Guerra, “The triangle method for
ﬁnding the corner of the l-curve,” Applied Numerical Mathematics,
vol. 43, no. 4, pp. 359–373, 2002.

[48] V. V. Williams, J. R. Wang, R. Williams, and H. Yu, “Finding four-node
subgraphs in triangle time,” in Proceedings of the twenty-sixth annual
ACM-SIAM symposium on discrete algorithms. SIAM, 2014, pp. 1671–
1680.

[49] F. Le Gall, “Improved quantum algorithm for triangle ﬁnding via
combinatorial arguments,” in 2014 IEEE 55th Annual Symposium on
Foundations of Computer Science.

IEEE, 2014, pp. 216–225.

[50] F. Magniez, M. Santha, and M. Szegedy, “Quantum algorithms for the
triangle problem,” SIAM Journal on Computing, vol. 37, no. 2, pp. 413–
424, 2007.

[51] M. Boyer, G. Brassard, P. Høyer, and A. Tapp, “Tight bounds on quan-
tum searching,” Fortschritte der Physik: Progress of Physics, vol. 46,
no. 4-5, pp. 493–505, 1998.

[52] G. Brassard, P. Hoyer, M. Mosca, and A. Tapp, “Quantum amplitude
ampliﬁcation and estimation,” Contemporary Mathematics, vol. 305, pp.
53–74, 2002.

[53] M. A. Nielsen and I. Chuang, “Quantum computation and quantum

information,” 2002.

[54] G. Li, L. Zhou, N. Yu, Y. Ding, M. Ying, and Y. Xie, “Projection-based
runtime assertions for testing and debugging quantum programs,” Proc.

