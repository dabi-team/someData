2
2
0
2

n
u
J

3

]

B
D
.
s
c
[

1
v
3
4
6
1
0
.
6
0
2
2
:
v
i
X
r
a

ChaTEAU: A Universal Toolkit for Applying the Chase

Tanja Auge
tanja.auge@uni-rostock.de
University of Rostock
Rostock, Germany

Nic Scharlau
Andreas GÃ¶rres
Jakob Zimmer
University of Rostock
Rostock, Germany

Andreas Heuer
andreas.heuer@uni-rostock.de
University of Rostock
Rostock, Germany

ABSTRACT

What do applications like semantic optimization, data exchange
and integration, answering queries under dependencies, query re-
formulation with constraints, and data cleaning have in common?
All these applications can be processed by the Chase, a family of
algorithms for reasoning with constraints. While the theory of the
Chase is well understood, existing implementations are confined
to specific use cases and application scenarios, making it difficult to
reuse them in other settings. ChaTEAU overcomes this limitation:
It takes the logical core of the Chase, generalizes it, and provides a
software library for different Chase applications in a single toolkit.

1 INTRODUCTION

The Chase is a widely applicable technique for reasoning with con-
straints. It takes a parameter âˆ— and an object âƒ as input, and forms
a result that corresponds to the combination of both. In this way,
the parameter is incorporated into the object, so that âˆ— is explicitly
contained in âƒ, denoted Chaseâˆ— (âƒ) = âˆ—â—‹. The versatile applicabil-
ity of the Chase is due to the fact that one can pass different types
of objects and parameters as input. Instead of considering queries
and instances separately (as other implementations do), ChaTEAU
generalizes both to a Chase object. Similarly, the Chase parame-
ter in ChaTEAU generalizes dependencies, queries, and views by
treating them uniformly as logic formulas.

Applying the Chase to instances [5] and queries [7] behaves in
a similar manner, because the structure of queries and instances is
also quite similar. However, existing Chase tools such as PDQ [4],
Llunatic [8], or Graal [3] are limited to specific use cases, e.g., seman-
tic optimization, data cleaning and exchange, or query answering
with existential rules. These different use cases can be reduced to
the processing of instances and queries. With ChaTEAU (Chase
for Transforming, Evolving, and Adapting databases and queries,
Universal Approach) we have developed and implemented a uni-
versal Chase tool that abstracts instances and queries to a general
Chase object and parameter. The software, examples, and further
information are available at our Git repository1.

The uniform treatment of Chase use cases and variants in
ChaTEAU makes it ideal for embedding it in different applications,
e.g., for data exchange, data cleaning, or query reformulations with
constraints. For specific applications, additional extensions such
as provenance or a second Backchase-phase may be necessary.
These extensions are being added gradually to ChaTEAU and can
be selected individually depending on the target use case. We are
currently integrating where-, why- and how-provenance [10] to
provide provenance-supported applications as well.

1Git repository: https://git.informatik.uni-rostock.de/ta093/ChaTEAU-demo

Structure of the article: Section 2 describes our Chase gener-
alization; Section 3 discusses the ChaTEAU implementation. Finally,
the ChaTEAU demonstration and GUI are presented in Section 4,
using a concrete example.

2 GENERALIZATION OF THE CHASE

Recall that the Chase modifies a given object âƒ, called Chase object,
by incorporating a parameter âˆ— (the Chase parameter), which we
can write as Chaseâˆ— (âƒ) = âˆ—â—‹. While âƒ can represent both queries
and instances, we understand âˆ— as set of constraints formalized as
(s-t) tgds and/or egds. An equality generating dependency (egd) is a
formula of the form âˆ€x(ğœ™ (x) â†’ (ğ‘¥1 = ğ‘¥2)). A formula of the form
âˆ€x(ğœ™ (x) â†’ âˆƒy : ğœ“ (x, y)) is called (source-to-target) tuple generat-
ing dependency ((s-t) tgd) with ğœ™ (body) and ğœ“ (head) conjunctions
of atomic formulas over a source and target schema, respectively. If
the source and target schemas are the same, the constraint is simply
a tgd. As their names suggest, egds and tgds derive new equalities
and new tuples (with âˆƒ-quantified variables), respectively.

First approaches to extend the Standard Chase [5] to arbitrary
objects and parameters can be found in [2]. Note that the Chase
parameter âˆ— either represents intra-database dependencies (as tgds
or egds) or inter-database dependencies (as s-t tgds). The hierarchy
in Figure 1 shows how other dependencies can be represented as
either (s-t) tgds or egds.

The Chase object âƒ is either a query ğ‘„ or a database instance ğ¼ .
In both cases, variables and null values can be replaced by other
variables and null values or constants. The variable substitution
rules depend on certain conditions. Letâ€™s have a closer look at them.

Chase Parameter. The Chase parameter âˆ— consists of a set of
dependencies Î£ in the form of egds or (s-t) tgds. These are gen-
eralizations of the classical functional dependencies (FD) and join
dependencies (JD). Any condition that can be written as a set of
(s-t) tgds and egds can be used as a Chase parameter. This includes
views, queries, and integrity constraints as seen in Figure 1.

Chase Object. The database tuple student(3, â€™Maxâ€™, â€™Mathâ€™)
and the query atom student(ğ‘¦id, ğ‘¥name, â€™Mathâ€™) are very similar
in structure. A Chase object is an abstraction of both. The tuple
consists of constants (ğ‘ğ‘– ) and null values (ğœ‚1) while the expres-
sion contains (implicitly) âˆ€-quantified variables (ğ‘¥ğ‘– ), âˆƒ-quantified
variables (ğ‘¦ğ‘– ) and constants (ğ‘ğ‘– ).

A database instance ğ¼ over schema ğ‘… consists of finite relations
, ..., ğ‘…ğ¼
ğ‘…ğ¼
ğ‘˜ , where each relation ğ‘…ğ¼
ğ‘– has the same arity as the relation
1
symbol ğ‘…ğ‘– . Each tuple (ğ‘¥1, ..., ğ‘¥ğ‘›) in ğ‘…ğ¼
ğ‘– consists of constants ğ‘ğ‘– or
null values ğœ‚ğ‘– . A conjunctive query is a first-order formula of the
form âˆƒğ‘¦ : ğœ™ (ğ‘¥, ğ‘¦) â†’ ğœ“ (ğ‘¥) with ğœ™ (ğ‘¥, ğ‘¦) a conjunction of logic atoms
(the body) and ğœ“ (ğ‘¥) a single atom (the head). The terms in ğœ™ are

 
 
 
 
 
 
âˆ€-quantified or âˆƒ-quantified variables, or constants. The head ğœ“
must not contain âˆƒ-variables.

A query ğ‘„ can be transformed into a frozen instance ğ¼ğ‘„ , in which
each atom of ğ‘„â€™s body is represented as a tuple in ğ¼ğ‘„ [6]. There are
different ways to deal with the variables in ğ‘„. Often âˆƒ-variables
are transformed into null values and âˆ€-variables are treated as
labeled null values or special constants. For the transformation of
a conjunctive query ğ‘„ into a generalized instance, the atoms in
the body have to be written as generalized tuples. We create tuples
with âˆƒ- and âˆ€-variables, e.g., as follows:

ğ‘„ = âˆƒğ‘¦id : student(ğ‘¦id, ğ‘¥name, â€™Mathâ€™) â†’ (ğ‘¥name)
ğ¼ğ‘„

= {student(ğ‘¦id, ğ‘¥name, â€™Mathâ€™)}.

These generalized tuples can be extended to a generalized instance,
as described in Definition 2.1. While ChaTEAU can handle general
s-t tgds, here we focus on queries, which can be seen as s-t tgds
with a single atom in the head.

Definition 2.1. Let ğ¼ be an instance and ğ‘„ a conjunctive query. A

generalized instance is either:

â€¢ a set of (conventional) relations ğ‘…ğ¼
1

, ..., ğ‘…ğ¼

ğ‘˜ , i.e., where tuples

consist of constants and null values, or

â€¢ a set of generalized tuples, consisting of the atoms of ğœ™ (ğ‘¥, ğ‘¦),

with constants, âˆ€-variables, and âˆƒ-variables.

The Chase for Generalized Instances. Due to the different
kinds of Chase objects ğ‘‚ğ‘– , the Chase steps ğ¼ğ‘‚ğ‘– â†’ ğ¼ğ‘‚ğ‘–+1 have to
be generalized too, when using (s-t) tgds and egds. In ChaTEAU,
we thus extend the Standard Chase [5] to a Chase for generalized
instances (see Algorithm 1).

The main task of the Chase is to infer new facts. To this end, we
need to find mappings (homomorphisms) between the dependencies
Î£ and the Chase object ğ‘‚. Using these, the Chase maps a set of
dependencies Î£ into ğ‘‚. The result is a modified Chase object ğ‘‚ â€².
Between ğ‘‚ and ğ‘‚ â€² we also have a homomorphism.

Definition 2.2. Let ğœ™ (x) be the body and ğœ“ (x, y) the head of a
dependency. Let ğ¼ğ‘‚1 and ğ¼ğ‘‚2 be generalized instances. We define
the following possible substitution rules:

(1) a constant can be mapped to itself: ğ‘ğ‘– â†¦â†’ ğ‘ğ‘–
(2) a null value can be mapped to a constant, itself, or another

null value: ğœ‚ğ‘– â†¦â†’ ğ‘ ğ‘— | ğœ‚ğ‘– | ğœ‚ ğ‘—

(3) an âˆƒ-variable can be mapped to a constant, itself, a null value,

or another âˆƒ- or âˆ€-variable:
(a) ğ‘¦ğ‘– â†¦â†’ ğ‘ ğ‘— | ğœ‚ ğ‘— | ğ‘¦ğ‘– | ğ‘¥ ğ‘—

(b) ğ‘¦ğ‘– â†¦â†’ ğ‘ ğ‘— | ğ‘¦ğ‘– | ğ‘¦ ğ‘— | ğ‘¥ ğ‘—

(4) a âˆ€-variable can be mapped to a constant, a null value, itself,

or another âˆ€- or âˆƒ-variable:
(a) ğ‘¥ğ‘– â†¦â†’ ğ‘ ğ‘— | ğœ‚ ğ‘— | ğ‘¥ğ‘– | ğ‘¦ ğ‘—

(b) ğ‘¥ğ‘– â†¦â†’ ğ‘ ğ‘— | ğ‘¥ğ‘–

Now a homomorphism â„ : ğœ™ (x) â†’ ğ¼ğ‘‚1 is a mapping that satisfies
(1) and (4a); a homomorphism â„ : ğœ“ (x, y) â†’ ğ¼ğ‘‚2 is a mapping that
satisfies (1), (3a), and (4a); and a homomorphism â„ : ğ¼ğ‘‚1 â†’ ğ¼ğ‘‚2 is a
mapping that satisfies (1), (2), (3b), and (4b).

Tgds insert new tuples to instances or add atoms to a query body.
These changes are created by applying a particular homomorphism,
called trigger, from the tgd-body to the generalized instance. Egds
equate variables by applying a homomorphism from the egd-body
to the generalized instance. An active trigger is one that (1) creates

Figure 1: Constraints hierarchy and how they are formalized

new tuples or expressions by applying an (s-t) tgd, or (2) leads to a
new equation of variables or null values by applying an egd.

Definition 2.3. A trigger is a homomorphism â„ from a depen-
dency body to a generalized instance, i.e., â„ : ğœ™ (x) â†’ ğ¼ğ‘‚ . An active
trigger is a trigger that satisfies for a

(1) tgd: no extension of â„ to an homomorphism ğœ“ (x, y) â†’ ğ¼ğ‘‚ ,
(2) egd: â„(ğ‘¥1) â‰  â„(ğ‘¥2).

If no new tuples or equals are created during a Chase execution,
the trigger is not active. However, if an âˆƒ-variable is contained in
the tgd-head, we always have an active trigger. These variables will
map to new null values or âˆƒ-variables, depending on the type of
Chase object.

We extend the Standard Chase to generalized instances. This
new Chase version modifies a generalized instance by a sequence
of Chase steps until all dependencies are satisfied.

Definition 2.4. Let â„ : ğœ™ (x) â†’ ğ¼ğ‘‚ğ‘– be an active trigger for a
dependency ğœ and a generalized instance ğ¼ğ‘‚ğ‘– . The modification of
ğ¼ğ‘‚ğ‘– to ğ¼ğ‘‚ğ‘–+1 by applying ğœ under â„ is called Chase step.

Definition 2.5. Let Î£ be a set of dependencies and ğ¼ğ‘‚0 a general-
ized instance. The (finite) Chase for generalized instances is a finite
sequence of Chase steps ğ¼ğ‘‚ğ‘– â†’ ğ¼ğ‘‚ğ‘–+1 (0 â‰¤ ğ‘– â‰¤ ğ‘›) with

â€¢ ğ¼ğ‘‚ğ‘› = âŠ¥ (Chase fails),
â€¢ ğ¼ğ‘‚ğ‘› = ğ¼ğ‘‚ğ‘›+1 , i.e. exists an homomorphism â„ : ğ¼ğ‘‚ğ‘› â†’ ğ¼ğ‘‚ğ‘›+1

with â„(ğ‘§ ğ‘— ) = ğ‘§ ğ‘— and ğ‘§ ğ‘— âˆˆ {ğ‘ ğ‘— , ğœ‚ ğ‘— , ğ‘¥ ğ‘— , ğ‘¦ ğ‘— }.

Finally, the result calculated with the Chase on generalized
instances must be interpreted. Applying an egd, the Chase on in-
stances fails if different constants are matched to each other, and
returns âŠ¥, whereas the Chase on queries returns âˆ…. The Chase
result on ğ‘„ corresponds to the transformation of ğ¼ğ‘„ğ‘› into a new
query ğ‘„ â€². For this, the tuples of ğ¼ğ‘„ğ‘› form a conjunction of atoms in
the body of ğ‘„ â€². The query head is formed by applying the composi-
tion of all homomorphism collected during the Chase-execution.
Thus, the Chase implemented in ChaTEAU works on arbitrary s-t
tgds.

3 CHATEAU

ChaTEAU runs on different types of Chase parameters and objects,
which are automatically recognized and processed accordingly.
Different constraint and termination checks are applied. The results
of these tests and of the individual Chase steps are stored in a log.
Input and Output. Input and output of instances, queries, and
constraints to ChaTEAU is done through special XML files. The
input file defines the schema, consisting of the relation schemas
and dependencies (the Chase parameter), as well as an instance or
a query (the Chase object).

integrity constraintsqueriesviewss-t tgdtgdJDegdFDAlgorithm 1 Chase for generalized instances (Î£, ğ¼ğ‘‚0 )
Require: set of dependencies Î£, a database instance ğ¼ğ‘‚0
Ensure: modified database instance ğ¼ğ‘‚ğ‘›
1: while ğ¼ğ‘‚ ğ‘— â‰  âŠ¥ and ğ¼ğ‘‚ ğ‘— âˆ’1 â‰  ğ¼ğ‘‚ ğ‘— do
for all trigger â„ for ğœ âˆˆ Î£ do
2:

if â„ is an active trigger then

if ğœ is a tgd then

extending â„ and adding new tuples to instance ğ¼ğ‘‚ ğ‘—

else if ğœ is an egd then

if values compared are different constants then

ğ¼ğ‘‚ ğ‘— +1 = âŠ¥

else

substitute null values and variables by other null
values, variables, or constants

3:

4:

5:

6:

7:

8:

9:

10:

Termination. Inserting tuples that contain null values may
cause non-termination of execution. This happens whenever tgds
interact and trigger each other and generate new null values each
time they are used. Conditions that guarantee a fixed point of a
Chase sequence exists are called termination conditions, and several
of these can be found in [9]. ChaTEAU implements five of them:
rich acyclicity, weak acyclicity, safety, acyclicity, and acyclicity with
egd rewriting.

Acyclicity is a very powerful condition based on constraint
rewriting [9], which is extensible and easy to implement. Com-
monly found is the test for weak acyclicity, such as in Llunatic [8]
or Graal [3]. It can be expanded to rich acyclicity and safety with-
out much effort. Additionally, we decided to implement acyclicity
with egd rewriting to better handle the problem of egds which are
ignored in most termination criteria [9].

API. ChaTEAU is a stand-alone application for the Chase. It
is implemented as a Maven project and can easily be accessed
through the GUI presented in Section 4. In addition, ChaTEAU can

Figure 2: Overview of ChaTEAU (zoomable in pdf version)

be accessed via its API, making it easy to employ it as building
block or library for developing other Chase-based applications.

In our research project ProSA [2], e.g., we combine provenance
management with the Chase algorithm to compute the inverses
of evaluation queries. ProSA is a tool that employs a variant of the
Chase on instances, called Chase&Backchase, so ChaTEAU is
called twice: once for the Chase and once for the Backchase [1].

Further development of ChaTEAU. We extended ChaTEAU
further by adding additional features. For example, where-, why-,
and how-provenance [10] â€” as needed for ProSA â€” have already
been implemented. However, provenance is not part of the Chase
itself, but is required for integration into ProSA or other applica-
tions. Therefore, this feature can only be used via the API, and
not through the GUI. Other extensions such as a general attribute-
constant comparisons or the integration of negated atoms and
relations are still in progress. We are also continuing work on new
ChaTEAU applications, as presented in [2].

4 DEMONSTRATION

The ChaTEAU GUI (see Figure 2) is divided into four tabs: Start
( 1 ), Tests ( 2 ), Chase ( 3 ) and Log ( 4 ). The demo starts by open-
ing a special XML file called ChaTEAU file ( a ). It contains the
Chase parameters as a set of dependencies and the Chase object.
The ChaTEAU system automatically determines whether the object
is a query or an instance and adjusts the associated tags ( A and
B ) accordingly. Before executing the Chase in the third step ( 3 ),
termination and constraint checks are performed ( 2 ). A variety of
tests can be selected and executed sequentially. The relevant log
can be found on the last tab ( 4 ).

We will navigate in ChaTEAU using the two buttons Previous
step ( I ) and Next step ( II ) at the bottom of the window. Within
the upper right corner of each tab, there is an option to save or
execute something ( a â€“ e ).

4.1 Chase on Instances

Even though the Chase on instances and queries works the same
in ChaTEAU, we present them as separate use cases. We start with
an example for chasing instances. Both examples can be found in
the corresponding demo repository.

Start. Instead of manually entering formulas, the fields for the
Chase object (Input) and parameter (Dependencies) are automat-
ically generated from the selected XML file.

We consider an instance (object) and a query (parameter) for-
malized as an s-t tgd that generates a table of grades from a student
and a participant table. Thus, known attributes like id and mod-
ule are adopted and new null values for semester and score are
introduced. In addition, all students not named Max are filtered out.

Instance:

{participant(2,3,4), participant(7,3,#ğ‘ _semester_1),
student(3,â€™Maxâ€™,â€™Mathâ€™), student(#ğ‘ _id_1,â€™Maxâ€™,â€™Mathâ€™), student(7,â€™Miaâ€™,#ğ‘ _course_1) }

Dependencies:

participant(#ğ‘‰ _module_1,#ğ‘‰ _id_1,#ğ‘‰ _semester_1), student(#ğ‘‰ _id_1,â€™Maxâ€™,#ğ‘‰ _course_1)
âˆ’>grade(#ğ‘‰ _module_1,#ğ‘‰ _id_1,#ğ¸_semester_1,#ğ¸_score_1)

124Idceba2II14ABC3Result (query):

student(#ğ‘‰ _id_1,#ğ‘‰ _name_1,#ğ‘‰ _course_1), student(#ğ‘‰ _id_2,#ğ‘‰ _name_1,#ğ‘‰ _course_2) )
âˆ’> (#ğ‘‰ _id_1,#ğ‘‰ _name_1,#ğ‘‰ _course_1)

5 CONCLUSION

The Chase implemented in ChaTEAU can be applied to queries
and instances. ChaTEAU combines these two approaches by incor-
porating a set of views, queries, and dependencies formalized as
(s-t) tdgs and egds, called Chase parameter, into a general Chase
object. For this, queries can be interpreted as frozen instances. This
also means that a different treatment of queries and instances is no
longer needed. ChaTEAU thus offers a versatile implementation of
a family of reasoning algorithms, which can be easily integrated
into other Chase-based applications such as ProSA [2].

ACKNOWLEDGMENTS

We thank all the students who were involved in developing Cha-
TEAU. In particular, we would like to mention Martin Jurklies,
Fabian Renn, Florian Rose, Michael Albus, Eduard Buch, Lukas
GÃ¶rtz, Moritz Hanzig, Eric Maier, Rocco Flach and Chris RÃ¶hrs. We
also thank Bertram LudÃ¤scher for comments and suggestions.

REFERENCES
[1] Auge, T.: Extended Provenance Management for Data Science Applications. In:

PhD@VLDB, CEUR Workshop Proceedings, Vol. 2652, CEUR-WS.org (2020)

[2] Auge, T., Heuer, A.: ProSA - Using the CHASE for Provenance Management. In:

ADBIS, LNCS, Vol. 11695, pp. 357â€“372. Springer (2019)

[3] Baget, K.-F., LeclÃ¨re, M., Mugnier, M.-L., Rocher, S., Sipieter, C.: Graal: A Toolkit for
Query Answering with Existential Rules. In: RuleML, LNCS, Vol. 9202, pp. 328â€“344,
Springer (2015)

[4] Benedikt, M., Leblay, J., Tsamoura, E.: PDQ: Proof-driven Query Answering over

Web-based Data. In: PVLDB, 13(7), pp. 1553â€“1556 (2014)

[5] Benedikt, M., Konstantinidis, G., Mecca, G., Motik, B., Papotti, P., Santoro, D.,

Tsamoura, E.: Benchmarking the Chase. In: PODS, pp. 37â€“52, ACM (2017)

[6] Deutsch, A., Nash, A., Remmel, J. B.: The chase revisited. In: PODS, pp. 149â€“158,

ACM (2008)

[7] Deutsch, A., Popa, L., Tannen, V.: Physical Data Independence, Constraints, and
Optimization with Universal Plans. In: VLDB, pp. 459â€“470, Morgan Kaufmann
(1999)

[8] Geerts, F., Mecca, G., Papotti, P., Santoro, D.: Cleaning data with Llunatic. In: VLDB

J., 4(29), pp. 867â€“892 (2020)

[9] Greco, S., Spezzano, F., Trubitsyna, I.: Stratification Criteria and Rewriting Tech-
niques for Checking Chase Termination. In: Proc. VLDB Endow., 4(11), pp. 1158-1168
(2011)

[10] Herschel, M., DiestelkÃ¤mper, R., Ben Lahmar, H.: A survey on provenance â€“ What

for? What form? What from?. In: VLDB J., 26(6), 881â€“906 (2017)

Termination. ChaTEAU implements five common termination
tests, from which the user can choose. When the button Run select-
ed checks ( b ) is pressed, all checks will be run. The process can be
repeated as often as desired (e.g. with different termination checks).
In our example, the Chase terminates according to all five crite-

ria. Also the constraint check is successful.

tgds are richly acyclic -> Standard Chase will definitely terminate.
tgds are weakly acyclic -> Standard Chase will definitely terminate.
tgds are safe -> Standard Chase will definitely terminate.
Constraint rewriting shows that tgds are acyclic -> Chase will definitely terminate.
Constraint rewriting shows that tgds/egds are acyclic -> Chase will definitely terminate.
Constraints are defined correctly.

Chase Execution. The key part of ChaTEAU is the Chase ap-
plication in the third tab. In addition to the input ( A and B ), we
also see the Chase result ( C ) here, which can be saved ( d ). De-
spite negative termination tests, the Chase can still be executed.
In this case, an alert appears. If the Chase is still running, it can
be stopped by clicking the Start Chase button ( c ) again, which is
now labeled as a Stop button. The Chase steps can be reviewed in
the log ( 4 ).

Our result instance by applying Chase matches the result of the
SQL query SELECT * FROM participant NATURAL JOIN student
WHERE name = â€™Maxâ€™ to the instance defined above:

Result (instance):

grade(7,3,#ğ‘ _semester_2,#ğ‘ _score_1), grade(2,3,#ğ‘ _semester_3,#ğ‘ _score_2)

Logging. The Chase execution is finished after three steps ( 1 â€“
3 ). The log offers additional information such as the results of the
single Chase steps after application of a (s-t) tgd or egd and details
regarding the termination checks carried out. The log is especially
suitable for debugging and is saved using e .

4.2 Chase on Queries

Thus ChaTEAU provides, depending on the CHASE object âƒ an in-
stance or query extended by the specified parameter âˆ—. We continue
with an example for chasing queries.

Start. We consider a query (object) and a constraint (parame-
ter) formalized as egd. The egd replaces the âˆƒ-quantified variable
#ğ¸_course_1 with the âˆ€-quantified variable #ğ‘‰ _course_1 by equat-
ing the attributes #ğ‘‰ _course_1 and #ğ‘‰ _course_2.

Query:

student(#ğ‘‰ _id_1,#ğ‘‰ _name_1,#ğ¸_course_1), student(#ğ¸_id_1,#ğ‘‰ _name_1,#ğ‘‰ _course_1)
âˆ’> (#ğ‘‰ _id_1,#ğ‘‰ _name_1,#ğ‘‰ _course_1)

Dependencies:

student(#ğ‘‰ _id_1,#ğ‘‰ _name_1,#ğ‘‰ _course_1), student(#ğ‘‰ _id_1,#ğ‘‰ _name_1,#ğ‘‰ _course_2)
âˆ’> #ğ‘‰ _course_1 = #ğ‘‰ _course_2

Termination and Logging. Both termination and logging be-

have as for instances. All six checks are satisfied.

Chase Execution. Applying the CHASE provides the substi-
tution of #ğ¸_course_1 described above. As a result, the body has
changed, while the head remains the same.

