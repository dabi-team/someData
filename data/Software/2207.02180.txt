Many Fields Packet Classification Using R-Tree and 
Field Concatenation Technique 

1st  Aladdin  Abdulhassan 
Department of Computer Engineering,, Kermanshah, Iran 
Razi University 
Kermanshah, Iran 
alaaabbas069@gmail.com 

2nd  Mahmood  Ahmadi 
Department of Computer Engineering,, Kermanshah, Iran 
Razi University 
Kermanshah, Iran 
m.ahmadi@razi.ac.ir 

Abstract—Software Defined Networking is an approach which 
decouples  the  software  based  control  plane  from  the  hardware 
based  data  plane  proposed  for  enterprise  networks;  OpenFlow 
is  the  most  famous  flexible  protocol  that  can  manage  network 
traffic between the control and the data plane. Software Defined 
Networking (SDN) requires up to 18 fields of the packets header 
to  be  checked  against  a  big  many-fields  ruleset  to  categorize 
packets  into  flows,  the  process  of  categorizing  packets  into 
flows  is  called  packet  classification.  Network  switches  process 
all  packets  belonging  to  the  same  flow  in  a  similar  manner  by 
applying  the  same  actions  that  defined  in  the  corresponding 
rule.  Packet  classification  facilitates  supporting  a  new  services 
such  as  filtering,  blocking  unsafe  sites  traffic,  routing  packets 
based on the packet’s header information, and giving priority to 
specific flows. High performance algorithms for many-field packet 
classification  had  been  gained  much  interest  in  the  research 
communities.  This  paper  presents  a  new  method  to  implement 
the  many-fields  packet  classification  of  SDN  flow  table  using 
Rectangle Tree (R-Tree). In this method, source and destination 
IP addresses from each flow table entry have been converted to a 
two dimensional point. The remainders of rule’s fields have been 
concatenated into a single field by taking the most important bits 
with  rules’  ID  in  order  to  be  inserted  into  the  R-tree,  for  each 
rule  an  effective  small  binary  flag  used  to  indicate  the  field’s 
size,  type  and  ranges.  Subsequently,  searching  is  performed  on 
rectangle tree to find the matched rules according to the highest 
priority.  In  the  simulation  using  the  class-bench  databases,  the 
results  show  that  this  method  achieves  very  good  performance, 
classification speed and reduces the number of memory accesses 
significantly. 

Index  Terms—Software  Defined  Networking;  OpenFlow; 

Packet Classification; R-Tree. 

I.  INTRODUCTION 

Software-Defined Networks (SDNs) have gained a growing 
attention  in  recent  years.  In  SDNs,  the  packet  processing 
functionality is managed by a logically centralized controller, 
that  makes  it  easier  for  programmers  to  control  the  network 
behaviors directly by configuring the forwarding rules installed 
on  each  distributed  switch  [25].  For  scalability  and  fault 
tolerance  in  some  case  the  controller  is  often  replicated  and 
distributed [4], [9]. 
The  real  needs  for  SDNs  technologies  have  been  driven 
by  specific  network  requirements  such  as  advent  of  Cloud 
services,  the  mobile  devices  explosion,  and  server  virtualiza- 
tion  within  the  large  data  center  networks.  Outside  the  data 
center, however, SDNs could provide open APIs and network 

flexibility  to  support  a  dynamic  traffic  flows  that  can  reduce 
latency and guarantee Quality of Service for networks such as 
WANs and campus networks. 
The  most  famous  protocol  that  can  manage  SDNs  network 
traffic  called  OpenFlow,  which  facilitates  the  creation  and 
introducing a new network protocols and policies by providing 
an abstraction of  network devices and operations [25]. These 
protocols are proceed via the network controller. The network 
controller  works  as  a  compiler  that  can  take  abstract  policies 
provided  by  network  designers  and  generate  a  specific  rules 
in the table for each network switch [15]. 
One of the main issues for network community in recent years 
is  the  packet  classification,  it  is  the  ability  to  classify  the 
incoming  packets  to  specific  flows.  The  packet  classification 
is  needed  for  modern  routers  to  provide  different  qualities 
of  service  to  various  applications.  OpenFlow-based  software 
defined networking switches can support a new services such 
as filtering, blocking unsafe sites traffic, routing packets based 
on  the  packet’s  information,  and  giving  priority  to  specific 
flows.  Thus,  packet  classification  is  used  in  modern  network 
applications such as accounting, filtering, monitoring, security, 
etc. [13]. 
Packet  classification  is  based  on  rules  which  define  multiple 
fields  of  packet  headers,  the  value  of  each  field  can  be  an 
exact,  a  range,  or  a  prefix  value.  All  investigated  fields  of 
an  incoming  packet  are  compared  with  the  rules.  Each  rule 
is  associated  with  an  action  to  process  an  incoming  packet 
if  matches  a  rule,  that  means  each  field  of  the  rule  matches 
the corresponding field of the incoming packet. In fact, one of 
two matching types may be required, first type is single match 
packet classification, that type is required for services such as 
firewalls  and  quality  of  service  that  require  the  capability  to 
isolate  and  distinguish  traffic  in  different  flows  for  suitable 
processing,  this  type  of  packet  classification  yields  the  best 
matching  rule  (the  rule  with  the  highest  priority)[27].  The 
second type is the multi-match packet classification. This type 
is required for a services that produce all matching rules such 
as  traffic  accounting  and  intrusion  detection  [18],  [5].  It  can 
also  be  used  by  multifunction  devices  that  perform  single 
match  packet  classification  for  each  function  [7],  [33],  [34]. 
The  matching  process  in  packet  classification  requires  more 
than  15  fields  per  flow  to  be  compared  with  thousands  of 

 
 
 
 
 
 
rules  in  a  ruleset.  Hence,  it  is  a  great  challenge  to  design 
a  convenient  packet  classification  approach  that  can  consider 
the  growing  number  of  fields  and  rules  in  ruleset,  and  new 
fields updating capability. 
OpenFlow  Switches  required  a  high  throughput,  latency  and 
update cost, this requirements become harder with the growing 
complexity  of  a  ruleset.  Hence,  packet  classification  remains 
challenging problem for next development generation. Current 
solutions [1], [24], [17], [19], [29] generate good system per- 
formance for traditional 5-tuple packet classification problems, 
but  they  do  not  solve  the  many-field  packet  classification 
problems  that  can  deal  with  the  growing  fields  counts  and 
rulesets  size,  a  longer  processing  latency  and  bigger  space 
requirement.  Even  the  many-field  packet  classifications  with 
5-tuple  TCAM  solutions  required  high  implementation  cost 
because of the big rulesets size and arbitrary field types. 
In our proposed method the popular R-tree is used to present 
the  many-field  packet  classification  solution.  The  IP  source 
and destination addresses(SA, DA) prefixes are converted to a 
two-dimensional data to be inserted into R-tree, the remainders 
of rules fields are concatenated into a string and inserted into 
leaves  nodes  where  the  real  data  of  R-tree  is.  A  small  flag 
is  used  to  indicate  the  wild-card  and  range  fields  (source 
and  destination  ports  numbers).  In  the  querying  phase,  all 
overlapping rectangles are retrieved as search results, based on 
the previously stored information about rules priority of each 
rectangle, the rectangle containing highest priority is selected 
as matching result. Using R-tree, more than one rule is indexed 
in  each  rectangle;  therefore,  it  decreases  the  height  of  the 
tree and memory accesses, in the result, our proposed method 
shows a very good throughput for searching phase. 
The main contribution of this paper is as follows: 

•  Organizing  rulesets  as  a  rectangular  tree  data  structure 
by proposing a new algorithm based on R-tree algorithm 
and  using  the  most  effective  ruleset’s  fields  as  a  key  to 
construct that tree. 

•  Proposal  of  a  new  extendible  and  easy  implementation 
method  to  append  the  ruleset  fields  (static  length  and 
range fields) in the R-tree so that it will be easy to extract 
these fields to use them in the query phase. 

•  Generating  of  varying  15  fields  ruleset  types  and  sizes 

and a tracing data. 

The  remainder  of  this  work  is  organized  as  follows.  Sec- 
tion  2  gives  background  about  related  works  on  many-fields 
packet classification problem and discusses the motivation of 
this  paper.  Section  3  presents  a  background  about  the  R- 
tree.  Section  4  presents  and  describes  the  proposed  packet 
classification  algorithm.  In  Section  5,  we  discuss  about  the 
simulation results. Section 6, concludes the paper. 

A.  Related Works 

Several research groups observed many-field packet classifi- 
cation challenges and tried to come up with different solutions. 
Some groups tried to introduce new solutions such as tagging 
approach  [8]  that  classifies  packets  at  the  edge  switch  and 
inserts  tags  into  packets  for  a  fast  packet  forwarding  in  a 

network,  hashing  approach  [22]  classifies  the  first  packet 
in  a  flow  and  uses  hash  table  lookups  for  the  following 
packets  to  improve  the  performance  of  packet  forwarding, 
decomposition-based approach [28] uses bit vector  with hash 
tables,  decision-tree-based  approach  [14]  uses  2-d  pipeline 
architecture with tree-to-pipeline mapping scheme, and hybrid- 
based approach [11] uses effective bits with look-up tables to 
lower  the  computation  cost  and  improve  the  system  perfor- 
mance [12]. 
Other  research  groups  focus  on  avoid  the  previous  many- 
field packet classification algorithms  weaknesses, some solu- 
tions  avoid  the  repeated  packet  classifications  on  the  same 
packet  at  different  network  nodes  and  free  extra  process- 
ing  capacity  [12].  All  proposed  methods  have  been  widely 
studied  to  improve  their  time  complexity  and  memory  re- 
quirements.  The  researchers  try  to  optimize  both  time  and 
storage  complexities  as  much  as  possible.  In  general,  the 
existing  packet  classification  solutions  can  be  classified  to 
four  groups[23],  [6].  The  first  group  is  basic  data  structure 
group,  contain  the  simplest  solution  for  packet  classification 
such  as  Linear  Search,  Hierarchical  Tries,  and  Hierarchical 
Binary  Search  Tree  (HBST)  [31],  [20],  usually  this  group 
require  small  amount  of  memory  but  it  does  not  scale  well 
for  large  rulesets.  The  hierarchical  tries  [31]  is  a  binary  trie 
extension, it constructs a one dimensional trie for each prefix, 
it’s  drawback  is  it  needs  an  expensive  backtracking  search 
time. The second group is the geometry based methods group, 
this  group  contain  the  solutions  that  use  trees  to  solve  the 
many-field  packet  classification  problem  such  as  Splay  Tree 
based  Packet  Classification  (ST-PC),  and  Area-based  Quad 
Trie (AQT) [32], [3]. AQT is a 2-dimensional search trie that 
build a two-dimensional quad-trie by build a one-dimensional 
binary trie to source and destination prefixes at the same time. 
Each  node  in  quad  trie  has  four  children,  the  quad  trie  has 
its  weaknesses  because  it  has  much  empty  internal  nodes 
and  its  so  difficult  to  update  the  multiple  one-dimensional 
tables.  The  third  group  is  the  heuristic  methods  group,  the 
HyperCuts  [26]  is  the  most  well  known  heuristic  method,  it 
uses  a  preprocessing  to  the  filters  set  to  great  a  decision  tree 
which contain a small number of filter in its leaves, after that 
it  uses  a  cutting  techniques  to  eliminate  the  irrelevant  rules. 
The preprocessing classifiers require much time and that effect 
the  search  time  in  HiCuts.  The  fourth  group  is  the  hardware 
based  schemes  group,  this  group  contain  hardware  solutions 
such as Ternary CAM, and Bitmap Intersection [26]. Hardware 
solutions  usually  have  high  performance  but  they  experience 
a poor scalability and portability [23]. 
In  our  proposed  solution  we  use  the  R-tree  which  avoids  the 
most  essential  problem  of  the  trie  structures  by  reducing  the 
large  number  of  empty  nodes  which  is  not  associated  with 
rules. 

II.  R-TREE 

The R-tree dynamic index structure for spatial data proposed 
by Guttman in 1984 [10]; Spatial data is information about a 
physical object normally arise in numerous applications such 

as  computer-aided  design,  computer  vision,  geographical 
information  systems  and  robotics.  This  information  can  be 
represented  in  a  geographic  coordinate  system  as  numerical 
values.  R-trees  used  to  dynamically  organize  a  set  of  d- 
dimensional  geometric  objects,  these  objects  are  represented 
as minimum bounding d-dimensional rectangles(MBRs). Each 
MBR represented as node in R-tree and contain a pointers to 
its  children  except  the  leaves  node  which  contain  a  pointers 
to  the  database  objects.  The  R-tree  represents  a  very  useful 
filtering technique to minimize the costly direct inspection of 
geometric objects. 

The  original  R-tree  of  order  (m,  M)  has  the  following 

features: 

•  Each  leaf  node  (except  if  it  is  the  root)  can  contains  up 
to  M  entries,  the  minimum  possible  number  of  entries 
equal  m  M/2. Every entry is of the  form (mbr, oid), so 
that  mbr stand  for the  minimum bounded d-dimensional 
rectangle  that  contains  the  object  and  oid  is  the  objects 
ID. 

≥ 

•  Each  internal  node  can  store  between(m  M/2  and  M) 
entries of form (mbr, p), where p represent a pointer to a 
child of the node, and mbr is the MBR that contains the 
MBRs stored in this child. 

≥ 

•  Root node can store 2 entries as minimum, unless it is a 

leaf (can store zero or a single entry). 

•  R-tree  is  a  height-balanced  tree  (all  leaves  at  the  same 

level). 

As  mentioned  above  the  R-tree  is  a  height-balanced  tree, 
from  many dimensions R-tree involve a generalization of the 
B+-tree  structure  [16].  R-trees  are  dynamic  data  structures, 
i.e.,  to  handle  R-tree  insertions  or  deletions  operations,  the 
global reorganization is not necessary. Fig.1(a) shows a MBRs 
set  of  some  geometric  data.  These  MBRs  are  R4-R14,  these 
MBRs  are  stored  at  the  leaf  of  the  R-tree.  The  same  figure 
demonstrates the three MBRs (R1, R2, and R3) that organize 
the  above  mentioned  rectangles  into  an  internal  node  of  the 
R-tree.  Assuming  that  M  =  4  and  m  =  2,  Fig.2  depicts 
the  corresponding  R-tree.  It  is  explicit  to  mention  here  that 
different  R-trees  can  represent  the  same  data  rectangles  set 
because  of  the  resulting  R-tree  is  highly  depend  on  the  the 
insertion (and/or deletion) order of its entries. 
Assume  that  an  R-tree  stores  N  data  rectangles  then  the 
maximum value for its height h is: 

hmax =  logm N  − 1 
And  by  summing  the  maximum  possible  number  of  nodes 
per  level,  the  maximum  allowed  number  of  nodes  in  such 
R-tree is equal to: 

hmax 

  N/mi  =  N/m  +  N/m2  + ... + 1 

i=1 
A.  R-Tree variants 

The R-tree variants have the same structure and differ from 
each other only in considering different minimization criteria 

that  affect  on  insertion,  deletion  operations,  and  how  they 
perform splits during an insertion. 
One  of  the  most  R-tree  popular  variants  is  R+-trees  [30], 
objects in R+-tree may be divided into two or more MBRs and 
stored  in  different  nodes  to  prevent  overlapping  of  MBRs  at 
same level, that directly effect the point queries so that visiting 
multiple  paths  is  avoided.  The  second  most  popular  variant 
of  R-tree  is  R*-tree.  In  this  variant,  the  overlapping  between 
MBRs at the same level has been minimized, and the memory 
utilization has been maximized by using the concept of forced 
reinsertion  and  advanced  node  split  technique  [2].  The  R*- 
tree  differs  from  the  classical  R-tree  only  in  the  insertion 
algorithm.  However,  deletion  operation  and  search  queries 
remain  unchanged.  Also  there  are  many  unpopular  variants 
of  R-tree  (The  Hilbert  R-tree,  Compact  R-trees,  Priority  R- 
tree  and  Logarithmic  Dynamization  R-tree)  each  of  these 
variants  differs  from  the  original  R-tree  in  how  it  chooses 
the  appropriate  sub  tree  and  how  it  perform  splits  during  an 
insertion. 

III.  PROPOSED  PACKET  CLASSIFICATION  ALGORITHM 

New SDN applications that support non best-effort services 
need  to  examine  up  to  15  fields  in  large  lookup  tables  to 
classify  incoming  packets  into  different  flows  as  depicted  in 
Table I [16]. 

For  development  of  new  advanced  services  like  SDN 
and  NFV(  Network  Function  Virtualization),  more  packet 
header  fields  were  required.  However,  that  represents  new 
challenges  to  many-fields  packet  classification  problems 
in  term  of  storage  requirement  and  system  throughput.  To 
address  the  scalability  problem,  it  is  necessary  to  lower 
the  computation  complexity,  and  system  performance  of 
many-field packet classification problem need to be improved 
with the number of rules and fields in a ruleset. In this paper, 
the  proposed  many-field  packet  classification  using  R-tree 
algorithm  has  been  implemented  as  a  classification  system 
with  an  off-line  rule  programming  process  to  construct  the 
R-tree.  Most  significant  field’s  bits  are  offline  concluded 
and  concatenated  to  generate  a  single  field  for  each  rule  to 
lower  computation  complexity,  then  the  offline  R-tree  has 
been  build  by  inserting  this  MBRs  one  by  one  into  R-tree  to 
optimize  the  online  lookup  throughput.  a  small  binary  flag 
has  been  generated  to  store  useful  information  about  exact 
field’s size, type and range for each rule, these flags are also 
concatenated  at  the  end  of  created  fields  for  corresponding 
rules as two or three Byte. Fig. 2 depicts the proposed packet 
classification  structure,  this  figure  contains  two  main  parts, 
first  part  is  the  off-line  proposed  R-tree  construction  part,  in 
this part the ruleset rules have to convert to rectangular object 
form  by  using  the  effective  fields,  and  the  remainders  fields 
have  to  be  concatenated,  and  to  insert  it  to  newly  off-line 
constructed  R-tree.  The  second  part  is  the  on-line  packet 
classification  part.  This  part  is  where  the  incoming  packets 
classified  to  appropriate  rule  by  querying  the  previously 
off-line constructed R-tree. 

  
 
R5 

R4 

R6 

R11 

R10 

R9 

R13 

R7 

R8 

R12 

R1 

R2 

R3 

R14 

(a) 

R4  R5  R6  R7 

R8  R9  R10  R11 

R12  R13  R14  

(b) 

Fig. 1.  An example of a MBRs set of some geometric data(a), and their corresponding R-tree(b) 

TABLE I 
AN  EXAMPLE  OF  OPENFLOW  PACKET  CLASSIFICATION  RULESET  (4  RULES,  15  FIELDS). 

Field Name 

Priority 
Ingr 
Meta-data 
Eth-src 
Eth-dst 
Eth-typ 
VLAN-ID 
VLAN-priority 
MPLS-lable 
MPLS-tfc 
SA 
DA 
Prtl 
ToS 
SP 
DP 

Field 
Length 

Field 
Type 

Rule 0 

Rule 1 

Rule 2 

Rule 3 

32 
64 
48 
48 
16 
12 
3 
20 
3 
32 
32 
8 
6 
16 
16 

2 
5 
* 
00:13:A9:00:42:40 
00:13:08:C6:54:06 
0x0800 
* 
5 
0 
* 
001* 
* 
TCP 
0 
0:65535 
0:65535 

1 
* 
* 
8:00:69:02:FC:07 
FF:FF:FF:FF:FF:FF 
* 
100 
7 
16000 
0 
00* 
1011* 
UDP 
* 
0:65535 
123:123 

3 
* 
* 
* 
* 
0x8100 
4095 
7 
* 
* 
1* 
1011* 
* 
* 
2:2 
5:5 

4 
1 
* 
00:FF:FF:FF:FF:FF 
00:00:00:00:00:00 
* 
4095 
* 
* 
* 
1* 
1* 
* 
0 
7:7 
120:121 

E 
E 
E 
E 
E 
E 
E 
E 
E 
P 
P 
E 
E 
R 
R 

A.  Off-line R-tree construction 

Off-line  R-tree  construction  stage  shifts  the  computation 
cost of field traversals in many-field packet classification using 
the  pre-computed  data  rulesets.  It  uses  the  most  significant 
field’s  (SA,  DA)  of  a  ruleset  to  generate  MBRs  which  then 
used as a keys to build R-tree. 

1)  Minimum  bounded  rectangles(MBRs)  creation:  The 
value  of  each  field  in  the  ruleset  can  be  a  prefix,  a  range,  or 
an exact value, the SA and DA prefixes were used to generate 
the MBR’s of the R-tree. 
The  first  step  in  the  R-tee  construction  is  how  to  convert 
SA  and  DA  prefixes  into  2-dimensional  data  that  can  be 
inserted into the  R-tree. IP SA prefix  must be converted into 
2  components  xmin  and  xmax.  The  minimum  value  of  the 
prefix  is  used  for  the  xmin  component  and  the  maximum  is 
used  for  xmax.  The  same  steps  are  used  to  generate  ymin  and 
ymax  from  IP  DA  prefix,  the  value  of  xmin,  xmax,  ymin,  ymax 
were represented as MBRs in R-tree. 
Considering  maximum  length  of  prefixes  (L),  the  IP  prefix 
resulting MBRs are categorized into three different types: 

•  Dot:  If  the  SA  and  DA  lengths  are  exactly  equal  to 
L(maximum length) then the SA and DA ranges will be 

one value range and the corresponding MBR is assumed 
as a dot. 

•  Line:  If  the  prefix  length  is  less  than  L  for  SA  or  DA 
but not both, then one of these prefixes will be one value 
range  and  the  other  prefix  will  be  more  than  one  value 
range and the corresponding MBR is assumed as a line. 
•  Rectangle: If the prefix length is less than L for SA and 
DA prefixes then each of these prefixes will be more than 
one value range and the corresponding MBR is assumed 
as a rectangle. 

Table  II  shows  an  example  of  how  prefixes  are  converted 
into  2-dimensional  data  (L  is  set  to  8).  For  instance,  given 
rule  R5  SA  =  001*,  and  DA  =  00100110,  the  first  dimen- 
sion  x  component  bits  are  set  to  the  0-1  padded  (shown  as 
001xxxxx). The x component value results in a range (32-64), 
the second dimension y component bits results in exact value 
(38).  Therefore,  the  second  discussed  situation  happens  and 
the resulting type of data for R5 prefixes is a Line. 
For  each  rule  there  is  a  flag  to  show  the  type  and  status 
of  each  field  (wild-card,  range  and  exact  value)  and  there 
is  a  concatenated  data  field  (CDF)  that  contains  information 
collected from the  rule  fields  (up to  15  fields).  As explained 

  
 
 
 
 
 
 
 
 
 
 
 
 
 
Off-line proposed R-tree 

construction 

RuleSet 

Effective field's selection 
(SIP & DIP) 

MBR creation 

Remainders fields concatenation 

R-tree building 

R-tree 

R-tree query 

Incoming packets 

R-tree multi 
match 

R-tree single 
match 

Highest priority 
rule selection 

Rule fields extracting 

R-tree full fields match 

Action 

R-tree Update if necessary 

Online packet classification 

Fig. 2.  Proposed packet classification structure. 

TABLE II 
PREFIXES  TO  2-DIMENSIONAL  DATA  CONVERTING  AND  MBRS  CREATION  AND  CATEGORIZATION 

SA  Prefix 
DA Prefix 
X  Bits 
Y  Bits 
X  Range 
Y  Range 
Ingr 
Meta-data 
Eth-src 
Eth-dst 
Eth-type 
Vlan-ID 
Prtl 
ToS 
SP 
DP 
Flag 

DCF 
Type of data 

R4 
110* 
0001* 
110xxxxx 
0001xxxx 
192-223 
16-31 
5 
* 
40 
FF 
0x8100 
4095 
TCP 
0 
69:69 
161:161 
01000 
00000 
540FF8... 
Rectangle 

R5 
001* 
00100110 
001xxxxx 
00100110 
32-64 
38-38 
* 
1 
FC 
07 
* 
100 
UDP 
* 
80:80 
161:161 
10001 
00100 
1FC0F1... 
Line 

R6 
10* 
11101* 
10xxxxxx 
11101xxx 
128-191 
232-239 
* 
2 
* 
00 
0x8100 
4095 
* 
* 
53:53 
1433:1433 
10100 
01100 
200810... 
Rectangle 

R7 
11011101 
00110111 
11011101 
00110111 
221-221 
55-55 
1 
3 
00 
FF 
* 
4095 
* 
0 
5520:5520 
0:65535 
00001 
01001 
1300FF... 
Dot 

R8 
000* 
10110110 
000xxxxx 
10110110 
0-31 
182-182 
4 
1 
FF 
9F 
* 
2041 
* 
0 
1024:65535 
120:121 
00001 
01010 
41FF9F... 
Line 

R9 
0001* 
11* 
0001xxxx 
11xxxxxx 
16-31 
192-255 
3 
* 
30 
08 
0x8100 
4095 
TCP 
0 
0:65535 
53:53 
01000 
00010 
330088... 
Rectangle 

R10 
001* 
0011* 
001xxxxx 
0011xxxx 
32-64 
48-63 
1 
1 
FA 
11 
* 
100 
UDP 
* 
9003:9003 
0:65535 
00001 
00101 
11FA11... 
Rectangle 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
in  the  Table  II,  the  Fig.3  (a)  shows  how  R5  constructs 
a  straight  line  in  the  2-dimensional  area.  After  conversion 
of  IP  addresses,  they  are  inserted  into  the  rectangular-tree. 
These  new  data  are  inserted  into  leaf  nodes,  if  there  is  room 
for  new  data  they  will  be  inserted  into  the  relevant  entries. 
Otherwise, the overflowed node will be split into 2 pieces and 
old  data  will  be  distributed  between  these  new  nodes.  These 
changes will be propagated upward until the root node reached. 
The  insertion  algorithm  of  our  proposed  method  follows  the 
standard insertion method of R-tree. 

Fig.3 (b) show  simple prefixes of Table II form an  R-tree. 
Three additional nodes were created containing 2 to 3 entries. 
The similar rules such as R4(110*, 0001*)and R7(11011101, 
00110111)  were  located  at  the  same  node  because  of  their 
similarity. 

2)  Remainders  fields  concatenation:  The  second  step  in 
proposed R-tree construction is the remainders fields concate- 
nation.  In  this  step  the  rest  of  rule  fields  (without  SA,  and 
DA  prefixes)  were  concatenated  to  one  long  string  by  taking 
constant  length  of  the  most  significant  bits  length  from  each 
field. For the range fields it is a challenge to be concatenated 
to other fields and be still usable fields. To solve this problem 
a binary flag is used to indicate fields type and even the fields 
state, some fields state in some rules is a wild-card fields(wild- 
card fields are not required for packet matching), the wild-card 
fields and range fields have been mentioned in the binary flag 
as  ”1”,  and  the  wild-card  fields  size  has  been  set  to  ”1”  in 
the CDF, the source and destination port number fields are the 
only two fields in range form in the rulesets, when a source or 
destination port number(SP and DP) are the only range fields 
in  rulesets,  the  range  (0:65535)  means  wild-card  for  (SP  and 
DP)fields, and its not required to take care for those field that 
are  wild-card  and  rang  at  the  same  time  in  our  binary  flag 
because  it  is  a  range  at  the  two  cases.  The  binary  flags  are 
changed to character form and concatenated to the tale of the 
results fields. 

3)  R-Tree  building  and  description:  The  last  step  in  R- 
tree  construction  process  is  how  to  insert  that  2-dimensional 
data  into  the  R-tree.  The  algorithm  for  inserting  a  new  data 
rectangle in an R-tree is presented in Algorithm 1. 

To  insert  a  new  rule  R,  first  we  represent  the  new  rule  as 
rectangular  data  R.mbr,  then  append  the  concatenated  fields 
(with port number range PNR and flag F) in R.c, R.p denotes 
the corresponding pointer to the next level, if the node is a leaf, 
then R.p denotes the corresponding object identifier (oid)(line 
1-5).The  tree  will  is  traversed  recursively  from  root  node  to 
appropriate  leaf  (line  6).  At  each  level,  all  the  rectangles  in 
the current node examined and the rectangle that covers R.mbr 
with  minimum  area  is  selected  (line  7,  8).  and  continue  the 
search  until  the  leaf  reached.  In  case  of  selected  leaf  can 
accommodate  R.mbr  then  R  inserted  to  that  leaf  and  update 
all nodes from that leaf to root node so that all of them cover 
R.mbr (line 9-13). In case of the selected leaf is already full, 

R-tree construction. 

Require:  Type Rule R, Type Node RN  Inserts a new rule 

{ 

R in an R-tree with root node RN 

} 

1:  Let  Xmin=  R.SA-range  minimum  allowed  value 
2:  Let Xmax= R.SA-range maximum allowed value 
3:  Let  Ymin=  R.DA-range  minimum  allowed  value 
4:  Let Ymax= R.DA-range maximum allowed value 
5:  Let R.mbr denotes the corresponding 
MBR(Xmin, Xmax, Ymin, Ymax) 

6:  Traverse the tree from root RN to the appropriate leaf. 
7:  At each level, select the node, L, whose MBR will 

require the minimum area enlargement to cover R.mbr 

8:  In case of ties, select the node whose MBR has the 

minimum area 

9:  if the selected leaf L can accommodate R then 
10: 
11: 

Insert E into L 
for  each rule in the path from root to L do 

12: 

Call Update(MBRs) /*so that all of them cover 
R.mbr*/ 

end for 

13: 
14:  else 
15: 

Let ε be the set consisting of all Ls entries and the 
new entry R 
Select as seeds two entries r1, r2 
Form two nodes, L1 and L2, where the first contains 
r1 and the second r2 
Examine the remaining members of ε one by one 
assign them  to L1 or L2 
if  a tie occurs then 

∈ 

ε 

Assign the entry to the node whose MBR has the 
smaller area 

end if 
if  a tie occurs again  then 

Assign the entry to the node that contains the 
smaller number of entries 

end if 
if  during the assignment of entries, there remain γ 
entries  to  be  assigned  and  the  one  node  contains 
m  γ entries  then 

− 
for each remaining entries to this node  do 

Assign to this node without considering the 
aforementioned criteria 

end for 

end if 
for MBRs of nodes that are in the path from root to L 
do 

Call  Update(MBR)  to  cover  L1 and  accommodate 
L2 
Perform splits at the upper levels if necessary 
if root has to be split then 
Call create( a new root) 
Increase the height of the tree by one 

16: 

17: 

18: 
19: 
20: 
21: 

22: 
23: 
24: 

25: 
26: 

27: 
28: 

29: 
30: 
31: 

32: 

33: 
34: 
35: 
36: 

end if 
end for 

37: 
38: 
39:  end if 

 
 
 
 
e
g
n
a
R
s
s
e
r
d
d
A
n
o
i
t
a
n
i
t
s
e
D

240 

220 

200 

180 

160 

140 

120 

100 

80 

60 

40 

20 

0 

R9 

R2 

R8 

R6 

R10 

R1 

R5 

R3 

R4 

R7 

R1 

R2 

R3 

20    40    60    80  100  120  140  160  180  200  220  240  260 

R5 
CDF 

R10 
CDF 

R6 
CDF 

R8 
CDF 

R9 
CDF 

R4 
CDF 

R7 
CDF 

Source Address  Range 

(a) 

(b) 

Fig. 3.  (a) The corresponding MBRs for the rules in table 2, (b)The corresponding R-Tree for the rules in table 2. 

then  this  leaf  were  split  into  two  node  (L1,  L2)  by  selecting 
two  seeds  (r1,  r2)  from  the  set  consisting  of  all  Ls  entries 
and  the  new  entry  R  where  the  distance  between  r1  and  r2 
is  the  maximum  among  all  other  pairs  of  entries  from  ε(line 
13-16), and puts them as initial entries into (L1, L2)(line 17), 
examine  the  remaining  members  of  ε  one  by  one  to  assign 
them to  L1 or L2 depending on  which of the MBRs of these 
nodes  will  require  the  minimum  area  to  cover  this  entry.  If 
a  members  of  ε  can  be  assigned  to  L1  and  L2  at  the  same 
time, then it will be assigned to the node whose MBR has the 
smaller  area.  If  L1,  L2  MBRs  have  the  same  area  it  will  be 
assigned  to  node  that  contains  the  smaller  number  of  entries 
(line  19-25).  After  that  add  these  two  new  node(L1,  L2)  to 
the parent in the previous level, some time the previous level 
may overflowed too, and the overflows may propagate till the 
root node(line 31-33), when the root node also overflows, the 
root node has to split and a new root is created and height of 
the tree increased by one(line 34-37). 
The  above-mentioned  insertion  algorithm  uses  the  simplest 
split  algorithm  called  linear  split  algorithm  which  has  linear 
time complexity. The linear split algorithm can  minimize the 
probability  of  get  both  new  created  nodes  (L1  and  L2)  as 
results for the same query. It tries to minimize the total area of 
the two new created nodes. The linear split algorithm chooses 
the most two divergent entries as seeds for the two nodes. Then 
it considers each remaining entry to one seed that can require 
the  smallest  enlargement.  Consider  the  following  insertion 
scenarios  when  we  have  the  R-tree  in  Fig.  4  and  we  need 
to insert the new three nodes that have the following MBRs: 

•  MBR1(X=60-63, Y=31-64). 
•  MBR2=(X=280-290, Y=128-512). 
•  MBR3(X=10-12, Y=0-255). 

In  this  R-tree  of  degree  M=4,  the  red  squares  represent 
empty entries and black squares represents full entries, without 
considering  Y  ranges.  To  insert  the  first  MBR,  the  insertion 
function  will  examine  the  root  A  and  it  will  find  that  this 
MBR  belongs  to  the  first  entry  (X=0-255),  then  the  sreach 
will descends to examine B and then H node. After examining 
H,  the  insertion  function  will  find  that  H  is  a  leaf  node,  so 
it  represents  the  place  where  this  MBR  should  be  inserted. 
H  contains  3  node  entries  so  it  can  be  inserted  safely  in  H 
(maximum  node  entry  is  M=4)  by  creating  new  (X=60-63) 
entry and update the upper level entry to(X=32-63). To insert 
the second MBR, after examine the R-tree, it will take the path 
of  (A-C-J);  J  is  a  leaf  node,  so  it  represents  the  place  where 
this MBR should be inserted, but J is already full, the insertion 
function  will  call  split  function  to  create  new  two  nodes  L1, 
L2  and  assigns  first  entry  of  node  J  (X=256-206)  to  L1  and 
last  entry  (X=305-319)  to  L2,  assign  the  remaining  entries 
(X=270-279,  X=295-305,  X=280-290)  to  the  node  requiring 
the  smallest  enlargement  from  L1,  L2,  that  means  L1  range 
will  be  (X=256-279),  and  L2  range  will  be  (280-319),  then 
assign  L1,  L2  to  the  parent  in  the  previous  level  which  has 
enough place for them. To insert the last MBR, it will take the 
path (A-B-F), F is a leaf node, so it represents the right place 
where this MBR should insert, but F is already  full, the split 
function  will  create  new  two  nodes  L1,  L2  and  assigns  first 
entry of node F(X=0-2) to L1 and last entry (X=13-15) to L2, 
then considers each remaining entry (X=3-6,X=7-9,X=10-12) 
to  the  node  requiring  the  smallest  enlargement  from  L1,  L2, 
that  means  L1  range  will  be  (X=0-9),  and  L2  range  will  be 
(10-15). Then the old first entry of B will be replaced by L1, 
L2, again B is already full, then the same procedure of linear 
split  will  be  applied  on  B  and  then  on  the  root  A,  that  will 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Root A 

X=0-255 

X=256-511 

X=767-1023 

X=1024-2047 

Y=… 

Y=… 

Y=… 

Y=… 

B 

C 

D 

E 

X=0-15 

X=128-255 

X=256-319    X=320-511 

X=767-800    X=810-1023 

X=1024-1111 

X=1112-2047 

X=16-31 

X=32-50 

F 
X=0-2   

X=3-6 

G 

H 

I 

J 

K 

L 

M 

N 

O 

X=32-35 

X=36-40 

X=256-260  X=270-279 

X=7-9 

X=13-15 

X=41-50 

X=291-311 

X=312-319 

Fig. 4.  part of R-tree to represent insertion scenarios. 

lead to create new root contain the two parts of the old root. 

B.  Online packet classification 

The  on-line  packet  classification  contains  four  main  pro- 
cesses: the R-tree query, rule fields extraction, R-tree full fields 
match,  and  R-tree  updating.  Once  a  packet  arrives  it  will  go 
directly  to  the  R-tree  root  after  creating  its  corresponding 
MBR,  after  R-tree  querying  an  answer  set  is  collected,  if 
this  answer  set  contains  more  than  one  match  result  then  the 
highest priority matched rule is selected and the rest rule fields 
is  extracted  from  the  matched  rule’s  node  to  get  a  full  fields 
match. If a full  fields  match  success, a call for related action 
is  made,  otherwise  a  R-tree  update  is  needed.  More  details 
descriptions of these processes are listed in the next sections. 
1)  R-tree query: The algorithm that processes range queries 
in  an  R-tree  is  given  in  Algorithm  2.  For  a  rule  node  entry 
R,  R.mbr  denotes  the  corresponding  MBR,  C  corresponding 
Concatenated fields with (Port number range PNR and flag F) 
and R.p the corresponding pointer to the next level. If the node 
is a leaf, then R.p denotes the corresponding object identifier 
(oid), Q.mbr denotes the corresponding query MBR. In search 
step, the same procedure as insertion is performed on incoming 
packets prefixes in order to convert them into 2- dimensional 
data. After conversion, using standard searching procedure of 
R-tree,  all  overlapping  rectangles  with  query  rectangle  are 
found (if any). The the query will start from the root and finds 
all  rectangles  that  are  stored  in  an  R-tree  with  root  node  RN 
which  are  intersected  by  a  query  rectangle.  If  the  root  node 
is not leaf node then a recursive call to range search for each 
rule entry in that root that intersect the query MBR will made 
(line 1-5), otherwise(the root or the called node is a leaf node) 
the procedure of extracting fields will work here for each rule 
entry that leaf(line 6, 7, and 8). A lookup generates preliminary 

packet  classification  results  without  full  comparison  between 
rules  and  packets,  when  overlapping  rectangles  with  query 
rectangle  are  found.  There  are  another  matching  procedure 
(described  in  next  section)  in  order  to  make  sure  that  this 
rectangles are fully matched with query rectangle( line 9-14). 
If  the  answer  set  contains  more  than  one  matched  rule,  the 
rule with the highest priority selected. 

2)  Rule  fields  extraction:  In  the  search  algorithm  the  tree 
traverse to locate an appropriate leaf to accommodate the query 
MBR (Q.mbr), for each matched node. If it is not leaf node a 
recursive call for search algorithm are made, otherwise (it is a 
leaf  node) all entries in that  node are examined to  find those 
which R.mbr intersects the query Q.mbr, then, the port number 
range PNR and flag F should be extracted from that node and 
the query Q.mbr and a sequential matching is performed. For 
both R-tree leaf rule data nodes and the query Q.mbr, there are 
a stored string contains a collected information of each field’s 
characteristics,  by  knowing  each  field  length  its  so  easy  to 
extract it. For some fields that can be a wild-card fields a non 
standard length may be founded, a binary flag is stored in the 
tale  of  the  concatenated  fields  string  can  tell  us  about  those 
fields which contain non standard length. 

3)  R-tree  full  fields  match  and  R-tree  update:  The  full 
fields match step is designed to report a full matches between 
incoming  packets  and  rules.  It  extracts  both  incoming  packet 
data and rule data and then full match process compares them 
based on each field’s characteristics (exact, prefix, and range). 
During  the  full  match  process,  if  the  field’s  match  fails,  the 
full fields  match process  will  move to next search result rule 
immediately.  It  retrieves  the  search  result  according  to  their 
priority, if any match happen, it ignores the remainders results 
and reports this match. If there is no match (there are no rule 
match the incoming packet in the ruleset), the full fields match 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
TypeNodeRN,  TypeRegionQ,  TypeContatenatedf  ieldsC 
Finds all rectangles that are stored in an R-tree with 
{ 
root node RN, which are intersected by a query 
rectangle Q.mbr. Answers are stored in the set A 

} 

1:  if RN is not a leaf node then 
2: 

examine each rule entry r of RN to find those r.mbr 
that intersect Q.mbr 
for such rule entry r  do 

call RangeSearch(r.ptr, Q) 

Range search 
Require: 

3: 

4: 
5: 
6:  else 
7: 

end for 

examine all entries r and find those for which r.mbr 
intersects Q 
extract  Port-number-ranges(PNR),  Flag  F  from  C 
if (r.C.PN 

PNR)  then 

∈ 

for each charector in C  do 

if r.C[Counter] = 
C[Counter]orFlag[Counter]  =  1  then 
add these entries to the answer set A 

8: 
9: 
10: 

11: 

12: 

end if 
end for 

13: 
14: 
15: 
16:  end if 

end if 

process conducts the default action (contains a ruleset update 
in  most  case).  If  a  ruleset  update  is  needed,  the  controller 
will generate a new rule to get an action for such unmatched 
packets, and to made this update to the ruleset a new regular 
insertion call for this new rule have to made. 

C.  Theoretical Analysis 

In  this  section,  the  time  and  space  complexities  are  given 
for the proposed solution to show how our proposed solution 
reduces the complexity by using R-tree lookup. 
Assume  that  there  are  N  rules  in  a  ruleset  R,  and  each  rule 
has H fields in it. For this ruleset, and each field has up to K 
bits  in  it,  then  the  time  complexity  for  lookup  algorithm  for 
R-tree of M degree is: 

Time complexity = logM N + H ∗ K = O(logM N ) 

The  space  complexity  for  our  proposed  algorithm  for  the 
leaves nodes is: 

Space  complexity(leavesnodes)  = H ∗ K ∗ N. 

And  for  tree  inner  nodes  (each  node  contains  only  2  prefix 
fields): 

Space complexity(innernodes) = (logM −1 N ) ∗ N ∗ 2 ∗ K. 

Then the total space complexity for our propose tree structure 
equals: 

Space complexity(total) = H∗K∗N +(logM −1 N )∗N ∗2∗K =

O(NlogM−1N  ). 

TABLE III 
COMPLEXITY  COMPARISON  WITH  WELL  KNOWN  MANY-FIELDS  PACKET 
CLASSIFICATION    ALGORITHMS. 

algorithm 
Proposed 
H-trie 
HiCuts 
Tuple-space 
quad-tree 

Time complexity 
  O(logM N ) 
  O(Wd) 
F*log2N + 1 
O(Wd) 
O(nlogn) 

space complexity 
  O(NlogM−1N ) 
    O(NdW) 
O(NF ) 
O(d2W ) 
O((d+1)n) 

TABLE IV 
THE  SIMULATION  RULSET  AND  TRACING  DATA  TYPE,  SIZE,  AND 
SPECIFICATIONS. 

Ruleset type 
ACL 1 K 
ACL 5 K 
ACL 10 K 
IPC 1 K 
IPC 5 K 
IPC 10 K 
FW 1 K 
FW 5 K 
FW 10 K 
Input Tracing 
Packets 

NO. of  rule 
 916 
4417 
9602 
 937 
4459 
9037 
 790 
4652 
9602 
100,1k, 
10k,100k 

Specifications 
  medium overlapping 
,heigh wildcard 

low overlapping 
,low wildcard 

heigh overlapping 
,medium wildcard 

(H, K are constant values). 

As  a  comparison  to  the  other  packet  classification  algo- 
rithm,  these  complexity  is  a  reasonable,  Table  III  depicts  a 
complexity  comparison  with  well  known  many-fields  packet 
classification algorithms. 

IV.  RESULTS 

In  this  section,  the  experimental  results  are  given  to  show 
the feasibility and effectiveness of our proposed algorithm with 
the  comparison  along  with  other  existing  many-field  packet 
classification solutions. 

A.  Experimental results 

A  performance  evaluation  have  been  performed  on 
simulated  rulesets  created  by  Class-bench  tool,  which 
is  widely  used  in  evaluating  the  performance  of  packet 
classification  algorithms,  in  these  simulations,  two  prefix 
fields had been used for building the R-tree and the remaining 
fields  including  the  port  ranges  and  some  required  flags  had 
been  stored  as  a  single  field  of  string  type  and  appended  as 
a  node  entries  (only  on  the  leaves).  Three  types  of  15  fields 
rulesets  have  been  generated:  access  control  list  (ACL),  IP 
chain  (IPC),  and  firewall  (FW)  with  three  sets  for  each  type 
contain 1000, 5000, and 10000 rules respectively. All rulesets 
have  less  than  10%  wild-cards  ratio  which  is  the  normal 
rulesets  wild-cards  ratio.  All  experiments  are  conducted  on 
an Intel Core i7 CPU machine with 4GB DDR2 RAM as the 
main  memory.  This  machine  is  equipped  a  NVIDIA  Quadro 
FX  880M  GPU.  Table  IV  depicts  the  specification  of  our 
simulation data rulesets and tracing packets. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
45000 

40000 

35000 

30000 

25000 

20000 

15000 

10000 

5000 

0 

)
d
n
o
c
e
S
/
s
t
e
k
c
a
P
(

t
u
p
h
g
u
o
r
T

Ruleset type 

Fig. 5.  Proposed solution throughput for multi ruleset types and size. 

In our evaluation, we define the performance as the average 
number that our approach can classify in one second measured 
in packet per second(PPS), the latency as the average required 
time to classify a single packet, Table V depicts our approach 
average  latency  and  throughput  for  these  rulesets  for  up 
to  100000  tracing  packets  measured  by  using  Embarcadero 
RAD  Studio  2010  measurement  instruction,Fig  5  depicts  the 
throughput  of  our  proposed  system  for  different  rulsets  type 
and size. 

As  depicted  in  Table  IV,  our  semulation  rulesets  have 
varying  characteristic.  And  therefore,  our  proposed  approach 
performs  differently  on  different  rulset  type  as  depicted  in 
Fig. 5, that the highest throughput that our system is achieved 
when  working  on  IP  chain  (IPC)  rulesets  as  a  result  of  the 
low overlapping rules in that ruleset type , and the worst-case 
scenario  for  all  rulesets  type  is  when  working  on  firewall 
(FW)  rulesets  as  a  result  of  the  high  overlapping  rule  in  that 
ruleset type and low wild-cards ratio around of 7.9%. On the 
other  hand,  IPC  rulesets  have  more  wild-cards  ratio  around 
of  10%,  and  less  overlapping  rules.  The  R-tree  that  contains 
more  overlapping  rules  can  give  more  querying  results  and 
that  takes  more  lookup  time,  also  the  matching  rule  may 
exists  on  different  branch  of  the  tree  that  makes  the  less 
overlapping  rule  the  best  throughput  case.  Conversely,  the 
more  wild-card  ratio  the  best  throughput  case  because  of  the 
wild-cards  fields  need  no  extracting  and  matching  process, 
that  minimizes  the  total  matching  time  and  maximizes  the 
system  throughput.  Hence,  the  previous  reasons,  rulesets  of 
type  Firewall  have  up  to  37  microseconds  average  latency, 
which is  the  maximum latency, and rulesets of type IP chain 
requires  less  than  24  microseconds.  The  access  control  list 
(ACL)  rulesets  have  the  least  overlapping  rules  but  it  has 
least  wild-cards.  Hence,  the  results  show  that  the  R-tree  of 
ACL  rulesets  requires  average  lookup  time  and  has  average 
throughput. 

We had take increasing amount (100, 1000, 10000, 100000) 

of  tracing  packet  that  has  been  selected  randomly  from  pre- 
viously  generated  100,000  tracing  packets,  and  then  we  test 
our  system  when  lookup  for  this  varying  amount  of  tracing 
packets on our simulation varying type and size rulesets, and 
the results show as can be seen in Fig. 6(a), that the minimum 
average  required  lookup  time  was  for  looking-up  on  rulesets 
of  type  IPC  and  the  worst  was  for  looking-up  on  rulesets  of 
type FW. It is the same results as in Fig 6(b). 
Our proposed packet classification algorithm has developed to 
be to maintain scalability with the increasing rulesets size and 
field number in a ruleset, and designed to analyze the average 
number  of  memory  accesses  and  the  maximum  number  of 
memory accesses required to perform packet classification and 
to  calculate  the  memory  requirement.  We  have  evaluate  our 
proposed  system  required  memory  accesses  in  both  average 
and worst case on R-tree of degree (M =4, m=2) and perform 
a  comparison  with  other  many-fields  packet  classification 
algorithms such as (H-trie [31], AQT [32], PQT [3], bit-vector 
(BV)[19],  and  HyperCuts  [26]).  The  comparison  results  is 
depicted in Table VI, which show that our proposed algorithm 
has  the  almost  the  best  memory  access  in  both  average  and 
worst  cases(most  of  compared  algorithms  work  on  two  field 
ruleset, that makes our proposed 15 field packet classification 
algorithm seems bad in this aspect). 
Fig.  7  (a)  depicts  average  memory  access  per  packet  and 
Fig.  7(b)  depicts  memory  access  per  packet  (worst  case). 
The proposed algorithm is distinctly better or similar to other 
algorithms  for  all  rulesets  type  and  size  (Note  that  a  better 
result  can  obtain  by  using  R-tree  with  big  degree  M¿4  but 
that would cost more memory). 

As  can  be  seen  in  Fig  7  the  quad-tree  approaches(area- 
based(AQT),  priority-based(PQT))  and  bit-vectors  algorithm 
experience  bad  memory  access  when  working  on  big,  over- 
lapped rulesets, in quad-trees the two dimensional search space 
using the source and the destination prefix fields is recursively 
partitioned  into  four  equal  sized  spaces.  If  the  partitions  are 
repeated  by  L  times,  4L  equal  sized  spaces  are  obtained, 
and  each  space  is  represented  by  L-bit  prefix  pairs.  Each 
rectangular  search  space  is  mapped  into  a  node  in  a  quad- 
tree. In other  words, the entire space is  mapped into the root 
node  of  the  quad-tree,  and  four  equal-sized  quadrants  which 
partition the entire space are mapped into four children of the 
root  node,  and  so  on.  The  AQT  defines  a  crossing  filter  as 
a  rule  which  spans  at  least  one  dimension  of  the  rectangular 
space. The rules included in crossing filter set (CFS) are stored 
into the corresponding quad-tree node. Hence it required more 
memory access. The bit-vectors have N bits in  length,  where 
N  is  the  number  of  rules  in  a  given  ruleset.  If  M  is  the  size 
of  a  word  of  memory,  the  bit  operations  are  responsible  for 
(N * d)/M memory accesses in the worst case, where d is the 
number of header fields. 

V.  CONCLUSION 

In this paper, we propose a many field packet classification 
algorithm  by  using  R-tree  structure  to  improve  the  system 
performance. The proposed method converts a huge and biased 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
TABLE V 
THE  PROPOSED  APPROACH  THROUGHPUT  AND  LATENCY  FOR  DIFFERENT  TYPE  AND 
SIZE OF RULESETS. 

Ruleset 
type 

FW 100 
FW 1000 
FW 5000 
FW 10000 
IPC 100 
IPC 1000 
IPC 5000 
IPC 10000 
ACL 100 
ACL 1000 
ACL 5000 
ACL 10000 

100 incoming 
packets 
Average latency 
24.2378 
25.7154 
34.5191 
35.1021 
24.1243 
25.1123 
26.9427 
28.886 
25.9272 
27.5183 
27.4964 
29.9885 

1000 incoming 
packets 
Average latency 
24.06405 
30.44346 
34.51149 
34.2533 
24.17178 
26.48657 
26.7855 
29.96238 
26.65184 
27.20913 
28.40572 
31.65096 

10000 incoming 
packets 
Average latency 
23.619935 
32.648207 
35.154708 
34.17682 
25.318351 
27.033848 
26.040894 
33.976519 
26.073631 
26.896741 
28.665517 
29.018201 

100000 incoming 
packets 
Average latency 
26.7730916 
32.5784345 
34.6439483 
35.4241835 
24.6959593 
26.1348458 
26.8341595 
29.4033083 
26.3565623 
27.5367645 
28.914487 
29.1298734 

Throughput 
packet/s 

38832 
30692 
28865 
28229 
40492 
38263 
37265 
30559 
37343 
36315 
34584 
34329 

36 

34 

32 

30 

28 

26 

24 

)
s
n
(
e
m
T

i

100 incoming  packets 
1000 incoming packets 
10000 incoming packets 
100000 incoming packets 

36 

34 

32 

30 

28 

26 

)
s
n
(
e
m
T

i

IPC5K 
IPC1K 
FW5K 
FW1K 
ACL5K 
ACL1K 

22 

FW 100  FW 1K  FW 5K  IPC 100  IPC 1K 

IPC 5k  ACL 100 ACL 1K  ACL 5K 

Rulesets type & size 

24 

100 

1000 

10000 

100000 

Tracing data size 

(a) 

(b) 

Fig.  6.  (a)Latency  average  for  different  rulesets  types  and  size,  (b)  Required  lookup  time  for different amount 
of tracing data. 

rule  space  into  rectangular  data  and  organize  it  as  R-tree 
structure  in  a  way  so  that  each  branch  of  the  R-tree  contains 
a  group  of  rules  that  shares  the  same  specification  and  each 
group  is  refereed  to  M  subgroups  and  so  on,  that  gives  as 
a  way  to  fast  processing  and  easy  updating.  The  proposed 
data  structures  were  designed  to  improve  the  many  fields 
packet classification performance and give better latency task 
for  a  better  system  performance.  The  proposed  solution  was 
examined  with  simulated  class-bench  rulesets  with  all  key 
factors related to system performance. A comparison with well 
known many-fields packet classification algorithms have been 
made to show the effectiveness of our approach. 

REFERENCES 

[1]  F.  Baboescu,  G.  VargheseScalable  packet  classification,  ACM  SIG- 
COMM  Computer  Communication  Review  31,  no.  4  ,2001:  199-210. 
Harvard 

[2]  N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger, The R*-tree: an 
efficient  and  robust  access  method  for  points  and  rectangles.  Vol.  19, 
no. 2. ACM, 1990. 

[3]  M.  Buddhikot,  S.  Suri,  and  M.Waldvogel,  Space  decomposition  tech- 

niques for fast layer-4 switching. Springer US, 2000. 

[4]  M.  Casado,  N.  Gude,  J.  Stribling,  L.  Poutievski,  M.  Zhu,  and  R. 
Ramanathan,  Onix:  A  Distributed  Control  Platform  for  Large-scale 
Production Networks, In OSDI, vol. 10, pp. 1-6, 2010. 

[5]  R. Cohen, D. Raz Simple efficient TCAM based range classification, In 

INFOCOM, 2010 Proceedings IEEE, pp. 1-5. IEEE, 2010. 

[6]  M. Dixit, B. Barbadekar, and A. Barbadekar, Packet classification algo- 
rithms,  In  Industrial  Electronics,  2009.  ISIE  2009.  IEEE  International 
Symposium on, pp. 1407-1412. IEEE, 2009. 

[7]  M.  Faezipour,  M.  Nourani,  Wire-speed  TCAM-based  architectures  for 
multimatch packet classification, Computers, IEEE Transactions on 58, 
no. 1 ,2009: 5-17. 

[8]  H.  Farhadi,  A.  Nakao,  Rethinking  flow  classification  in  sdn,  In  Cloud 
Engineering  (IC2E),  2014  IEEE  International  Conference  on,  pp.  598- 
603. IEEE, 2014. 

[9]  N. Foster, A. Guha, M. Reitblatt, A. Story, M. Freedman, N. Katta, and 

C.Monsanto, Languages for software-defined networks, Communications 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
TABLE VI 
THE  PERFORMANCE  COMPARISON  TO  THE  OTHER  ALGORITHMS. 

Metrics 

Rulesets 

Memory 
requirement 
(Kbytes) 

Memory 
accesses 
per packet 
(average) 

Memory 
accesses 
per packet 
(worst case) 

ACL 1k 
ACL 5k 
ACL 10k 
IPC 1k 
IPC 5k 
IPC 10k 
FW 1k 
FW 5 k 
FW 10k 
ACL 1k 
ACL 5 k 
ACL 10k 
IPC 1k 
IPC 5 k 
IPC 10k 
FW 1k 
FW 5k 
FW 10k 
ACL 1k 
ACL 5k 
ACL 10k 
IPC 1k 
IPC 5k 
IPC 10k 
FW 1k 
FW 5k 
FW 10k 

No.of 
rules(N) 
902 
4,660 
9,600 
972 
4,468 
9,036 
852 
4,351 
9,309 
902 
4,660 
9,600 
972 
4,468 
9,036 
852 
4,351 
9,309 
902 
4,660 
9,600 
972 
4,468 
9,036 
852 
4,351 
9,309 

proposed 

TPBF 

TSP 

H-trie 

552 
2,648 
5,812 
604 
2,720 
5,548 
540 
2,864 
6,296 
6 
7 
8 
6 
7 
8 
6 
7 
8 
8 
10 
11 
8 
10 
10 
8 
10 
10 

22.1 
174.2 
— 
23.0 
172.7 
— 
22.0 
170.3 
— 
6.48 
11.4 
— 
7.90 
18.7 
— 
33.6 
39.5 
— 
55 
59 
— 
19 
40 
— 
75 
85 
— 

62.8 
273.2 
— 
63.8 
184.2 
— 
42.9 
172.1 
— 
17.5 
19.2 
— 
27.8 
36.3 
— 
45.4 
44.2 
— 
65 
59 
— 
42 
65 
— 
93 
89 
— 

82.9 
401.5 
— 
121.6 
224.7 
— 
39.4 
119.1 
— 
77.2 
84.0 
— 
71.9 
85.6 
— 
52.1 
69.2 
— 
124 
177 
— 
128 
192 
— 
117 
146 
— 

Area-based 
quad-trie 
56.4 
200.2 
— 
71.2 
234.3 
— 
35.2 
479.8 
— 
38.6 
50.1 
— 
94.5 
344.8 
— 
369.3 
660.5 
— 
64 
94 
— 
119 
415 
— 
444 
1193 
— 

Priority based 
quad-trie 
29.9 
145.6 
— 
30.9 
139.9 
— 
27.2 
136.0 
— 
35.6 
59.6 
— 
73.6 
202.1 
— 
197.9 
571.1 
— 
75 
113 
— 
106 
295 
— 
293 
999 
— 

Bit 
vector 
153.3 
2,793.0 
— 
154.3 
2,531.0 
— 
111.9 
2,340.0 
— 
66.0 
64.1 
— 
63.6 
151.9 
— 
196.6 
738.8 
— 
68 
76 
— 
80 
230 
— 
318 
1,044 
— 

Magazine, IEEE 51, no. 2 2013: 128-134. 

[10]  A.  Guttman,  R-trees:  a  dynamic  index  structure  for  spatial  searching. 

Vol. 14, no. 2. ACM, 1984. 

[11]  L.C. Hsieh, N. Weng, Scalable Many-Field Packet Classification using 
Multidimensional-Cutting  Via  Selective Bit-Concatenation,  In  Proceed- 
ings  of  the  Eleventh  ACM/IEEE  Symposium  on  Architectures  for 
networking and communications systems, pp. 187-188. IEEE Computer 
Society, 2015. 

[12]  L.C.  Hsieh,  N.  Weng,  Many-Field  Packet  Classification  for  Software- 
Defined  Networking  Switches,  In  Proceedings  of  the  2016  Symposium 
on Architectures for Networking and Communications Systems, pp. 13- 
24. ACM, 2016. 

[13]  B.  Jafarian,  N.  Yazdani,  B-tree  based  packet  classification  (B  2-PC). 
In  Communications,  Computers  and  Applications  (MIC-CCA),  2012 
Mosharaka International Conference on, pp. 47-52. IEEE, 2012. 

[14]  W.  Jiang,  V.  Prasanna,  Scalable  packet  classification  on  FPGA,  Very 
Large Scale  Integration  (VLSI)  Systems,  IEEE  Transactions  on  20,  no. 
9, 2012: 1668-1680. Harvard 

[15]  Y. Kanizo, D. Hay, I. Keslassy,Palette: Distributing tables in software- 
defined networks. In INFOCOM, 2013 Proceedings IEEE, pp. 545-549. 
IEEE, 2013. 

[16]  E.D.  Knuth,  The  Art  of  Computer  Programming,  Vol.  3:  Sorting  and 

Searching, 1973. 

[17]  K.  Kogan,  S.  Nikolenko,  O.  Rottenstreich,  W.  Culhane,  and  P.  Eu- 
gster,scalable  and  expressive  packet  classification,  ACM  SIGCOMM 
Computer Communication Review 44, no. 4, 2015: 15-26. Harvard 
[18]  K.  Lakshminarayanan,  A. Rangarajan,  Algorithms  for advanced  packet 
classification with ternary CAMs. In ACM SIGCOMM Computer Com- 
munication Review, vol. 35, no. 4, pp. 193-204. ACM, 2005. 

[19]  T.V. Lakshman, D. Stiliadis, High-speed policy-based packet forwarding 
using efficient multi-dimensional range matching, In ACM SIGCOMM 
Computer  Communication  Review,  vol.  28, no. 4, pp.  203-214.  ACM, 
1998. 

[20]  H. Lim, H. Chu, and C. Yim, Hierarchical binary search tree for packet 

classification., IEEE communications letters 11, no. 8, 2007: 689-691. 

[21]  H. LIM, M.Y. KANG, C. YIM, Two-dimensional packet classification 

algorithm  using  a  quad-tree.  Computer  Communications,  2007,  30.6: 
1396-1405. 

[22]  B.  Pfaff,  J.  Pettit,  T.  Koponen,  E.  Jackson,  A.  Zhou,  J.  Rajahalme,  J. 
Gross, The design and implementation of open vswitch, In 12th USENIX 
Symposium on Networked Systems Design and Implementation (NSDI 
15), pp. 117-130. 2015. 

[23]  N. McKeown, P. Gupta, Algorithms for packet classification, Network, 

iEEE 15, no. 2, 2001: 24-32. 

[24]  N. McKeown, P. Gupta, Classifying packets with hierarchical intelligent 

cuttings, Micro, IEEE 20, no. 1, 2000: 34-41. 

[25]  N. McKeon, T. Anderson, H. Balakrishnan OpenFlow: enabling innova- 
tion in campus networks. ACM SIGCOMM Computer Communication 
Review, 2008, 38.2: 59-74, 2014. 

[26]  N.  McKeown,  and  P.  Gupta,  Packet  classification  using  hierarchical 

intelligent cuttings, In Hot Interconnects VII, pp. 34-41. 1999. 

[27]  C.R. Meiners, A.X. Liu, E Torng, Bit weaving: A non-prefix approach 
to  compressing  packet  classifiers  in  TCAMs,  IEEE/ACM  Transactions 
on Networking (ToN) 20, no. 2 ,2012: 488-500. 

[28]  R.Y.  Qu,  H.  Zhang,  S.  Zhou,  and  V.  Prasanna,  Optimizing  Many-field 
Packet Classification on FPGA, Multi-core General Purpose Processor, 
and  GPU,  In  Proceedings  of  the  Eleventh  ACM/IEEE  Symposium  on 
Architectures  for  networking  and  communications  systems,  pp.  87-98. 
IEEE Computer Society, 2015. 

[29]  O. Rottenstreich, I. Keslassy, A. Hassidim, H. Kaplan, and E. Porat, On 
finding an optimal TCAM encoding scheme for packet classification, In 
INFOCOM, 2013 Proceedings IEEE, pp. 2049-2057. IEEE, 2013. 
[30]  T. Sellis, N. Roussopoulos, and C. Faloutsos, The R+-Tree: A Dynamic 

Index for Multi-Dimensional Objects, 1987. 

[31]  V. Srinivasan, G. Varghese, S. Suri, and M. Waldvogel, Fast and scalable 

layer four switching. Vol. 28, no. 4. ACM, 1998. 

[32]  T. Srinivasan, M. Nivedita, and V. Mahadevan, Efficient packet classifica- 
tion using splay tree models, IJCSNS International Journal of Computer 
Science and Network Security 6, no. 5, 2006: 28-35. 

[33]  P.C.  Wang,  Scalable  packet  classification  for  data  center  networks, 
Selected  Areas  in  Communications,  IEEE  Journal  on  32,  no.  1,  2014: 
124-137. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
)
e
g
a
r
e
v
a
(

t
e
k
c
a
p

r
e
p

s
e
s
s
e
c
c
a

y
r
o
m
e
M

Areabased 

Bitvector1 

Htrie 

Prioritybased 

TPBF 

TSP 

proposed 

800 

700 

600 

500 

400 

300 

200 

100 

0 
ACL 1K  ACL 5K  IPC 1K  IPC 5K  FW 1K  FW 5K 
Rulesets type & size 

)
e
s
a
c

t
s
r
o
w

(

t
e
k
c
a
p

r
e
p

s
e
s
s
e
c
c
a

y
r
o
m
e
M

Areabased 

Bitvector1 

Htrie 

Prioritybased 

TPBF 

TSP 

proposed 

1200 

1000 

800 

600 

400 

200 

0 
ACL 1K  ACL 5K  IPC 1K  IPC 5K  FW 1K  FW 5k 
Rulesets type & size 

(a) 

(b) 

Fig. 7.  Memory accesses per packet(average) comparison to the other algorithms.,Memory accesses per 
packet (worst case)comparison to the other algorithms. 

[34]  P. C. Wang, D. Y. Chang,  TCAM-Based Multi-Match Packet Classifica- 
tion Using Multidimensional Rule Layring,  IEEE/ACM Transaction on 
Networking, 2016, 24.2: 1125-1130. 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
