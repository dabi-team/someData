2
2
0
2

n
u
J

4
1

]

A
N
.
h
t
a
m

[

1
v
8
1
9
6
0
.
6
0
2
2
:
v
i
X
r
a

varFEM: variational formulation based programming

for ﬁnite element methods in Matlab

Yue Yu∗

School of Mathematical Sciences, Institute of Natural Sciences, MOE-LSC, Shanghai Jiao

Tong University, Shanghai, 200240, P. R. China.

This paper summarizes the development of varFEM, which provides a realization of the

programming style in FreeFEM by using the Matlab language.

Abstract

1 Introduction

FreeFEM is a popular 2D and 3D partial diﬀerential equations (PDE) solver based on ﬁnite

element methods (FEMs) [2], which has been used by thousands of researchers across the world.

The highlight is that the programming language is consistent with the variational formulation of

the underlying PDEs, referred to as the variational formulation based programming in this article.

We intend to develop an FEM package in a similar way of FreeFEM using the language of Matlab,

named varFEM. The similarity here only refers to the programming style of the main or test script,

not to the internal architecture of the software.

This programming paradigm is usually organized in an object-oriented language, which makes

it diﬃcult for readers or users to understand and modify the code, and further redevelop the

package (although it is a good way to develop softwares). Upon rethinking the process of ﬁnite

element programming, it becomes clear that the assembly of the stiﬀness matrix and load vector

essentially reduces to the numerical integration of some typical bilinear and linear forms with

respect to basis functions.

In this regard, the package iFEM, written in Matlab, has provided

robust, eﬃcient, and easy-following codes for many mathematical and physical problems in both

two and three dimensions [1]. On this basis, we successfully developed the variational formulation
based programming for the conforming Pk-Lagrange (k ≤ 3) FEMs in two dimensions by utilizing
the Matlab language. The underlying idea can be generalized to other types of ﬁnite elements

for both two- and three-dimensional problems on unstructured simplicial meshes. The package is

accessible on https://github.com/Terenceyuyue/varFEM (see the varFEM folder).

The article is organized as follows. In Section 2, we introduce the basic idea in varFEM through

a model problem. In Section 3, we demonstrate the use of varFEM for several typical examples,

∗terenceyuyue@sjtu.edu.cn

1

 
 
 
 
 
 
including a complete implementation of the model problem, the vector ﬁnite element for the linear

elasticity, the mixed FEMs for bihamonic equation and Stokes problem, and the iterative scheme

for the heat equation. We also demonstrate the ability of varFEM to solve complex problems in

Section 4.

2 Variational formulation based programming in varFEM

We introduce the variational formulation based programming in varFEM via a model problem,

so as to facilitate the underlying design idea.

2.1 Programming for a model problem

Let Ω = (0, 1)2 and consider the second-order elliptic problem:





−∇ · (a∇u) + cu = f

in Ω,

u = gD

gRu + a∂nu = gN

on ΓD,

on ΓR,

(2.1)

where ΓD and ΓR = ∂Ω\ΓD are the Dirichlet boundary and Robin boundary, respectively. For
brevity, we refer to gR as the Robin boundary data function and gN as the Neumann boundary
data function. For homogenous Dirichlet boundary condition, the variational problem is to ﬁnd
u ∈ V := H 1

0 (Ω) such that

where

a(v, u) =

(cid:90)

Ω

a(v, u) = (cid:96)(v),

v ∈ V,

a∇v · ∇udσ +

(cid:90)

cvudσ +

(cid:96)(v) =

(cid:90)

Ω

Ω
(cid:90)

f vdσ +

ΓR

gN vds.

(cid:90)

ΓR

gRvuds,

Here, the test function is placed in the ﬁrst entry of a(·, ·) since

a(v, u) = vT Au, A = (a(ϕi, φj))m×n,

where v = (v1, · · · , vm)T and u = (u1, · · · , un)T , with

v =

m
(cid:88)

i=1

viϕi,

u =

n
(cid:88)

i=1

uiφi.

2.1.1 The assembly of bilinear forms

The ﬁrst step is to obtain the stiﬀness matrix associated with the bilinear form

(cid:90)

Ω

a∇v · ∇udσ +

(cid:90)

Ω

cvudσ

on the approximated domain, where for simplicity we have used the original notation Ω to represent

a triangular mesh. The computation in varFEM reads

2

1 % Omega

2 Coef

= {a , c };
= { 'v . grad ' , 'v . val ' };
3 Test
4 Trial = { 'u . grad ' , 'u . val ' };
5 kk = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

Here, Th represents the triangular mesh, which provides some necessary auxiliary data structures.

We set up the triple (Coef,Test,Trial), for the coeﬃcients, test functions and trial functions

in variational form, respectively.

It is obvious that v.grad is for ∇v and v.val is for v itself.

The routine int2d.m computes the stiﬀness matrix corresponding to the bilinear form on the

two-dimensional region, i.e.

A = (aij),

aij = a(Φi, Φj),

where Φi are the global shape functions of the ﬁnite element space Vh. The integral of the bilin-
ear form, as (∇Φi, ∇Φj)Ω, will be approximated by using the Gaussian quadrature formula with
quadOrder being the order of accuracy.

The second step is to compute the stiﬀness matrix for the bilinear form on the Robin boundary

ΓR:

(cid:90)

ΓR

gRvuds.

The code can be written as follows.

1 % Gamma_R

2 Th . elem1d = Th . bdEdgeType {1};

3 Th . elem1dIdx = Th . bdEdgeIdxType {1};

4 Coef

= { g_R };
= { 'v . val ' };
5 Test
6 Trial = { 'u . val ' };
7 kk = kk + int1d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

Here, int1d.m gives the contribution to the stiﬀness matrix on the one-dimensional boundary edges

of the mesh. Note that we must provide the connectivity list elem1d of the boundary edges of ΓR
and the associated indices elem1dIdx in the data structure edge introduced later.

2.1.2 The assembly of linear forms

For the linear forms, we ﬁrst consider the integral for the source term:

(cid:90)

Ω

f vdσ.

The load vector can be assembled as

1 % Omega

2 Coef = pde . f ;

Test = 'v . val ';

3 ff = int2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

We set Trial = [] to indicate the linear form.

The computation of the load vector associated with the Neumann boundary data function gN ,

i.e.,

reads

(cid:90)

ΓR

gN vds

3

1 % Gamma_R

2 Coef = g_N ;

Test = 'v . val ';

3 ff = ff + int1d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

2.2 Data structures for triangular meshes

We adopt the data structures given in iFEM [1]. All related data are stored in the Matlab

structure Th, which is computed by using the subroutine FeMesh2d.m as

1 Th = FeMesh2d ( node , elem , bdStr ) ;

The triangular meshes are represented by two basic data structures node and elem, where

node is an N × 2 matrix with the ﬁrst and second columns contain x- and y-coordinates of the

nodes in the mesh, and elem is an NT × 3 matrix recording the vertex indices of each element in a

counterclockwise order, where N and NT are the numbers of the vertices and triangular elements.

In the current version, we only consider the Pk-Lagrange ﬁnite element spaces with k up to
In the matrix
In this case, there are two important data structures edge and elem2edge.

3.

edge(1:NE,1:2), the ﬁrst and second rows contain indices of the starting and ending points. The

column is sorted in the way that for the k-th edge, edge(k,1)<edge(k,2) for k = 1, 2, · · · , NE.

The matrix elem2edge establishes the map of local index of edges in each triangle to its global

index in matrix edge. By convention, we label three edges of a triangle such that the i-th edge

is opposite to the i-th vertex. We refer the reader to https://www.math.uci.edu/~chenlong/
ifemdoc/mesh/auxstructuredoc.html for some detailed information.

To deal with boundary integrals, we ﬁrst exact the boundary edges from edge and store them

in matrix bdEdge. In the input of FeMesh2d, the string bdStr is used to indicate the interested
boundary part in bdEdge. For example, for the unit square Ω = (0, 1)2,

• bdStr = 'x==1' divides bdEdge into two parts: bdEdgeType{1} gives the boundary edges

on x = 1, and bdEdgeType{2} stores the remaining part.

• bdStr = {'x==1','y==0'} separates the boundary data bdEdge into three parts: bdEdgeType{1}

and bdEdgeType{2} give the boundary edges on x = 1 and y = 0, respectively, and bdEdgeType{3}

stores the remaining part.

• bdStr = [] implies that bdEdgeType{1} = bdEdge.

We also use bdEdgeIdxType to record the index in matrix edge, and bdNodeIdxType to store

the nodes for respective boundary parts. Note that we determine the boundary of interest by

the coordinates of the midpoint of the edge, so 'x==1' can also be replaced by a statement like

'x>0.99'.

2.3 Code design of int2d.m and assem2d.m

In this article we only discuss the implementation of the bilinear forms in two dimensions.

4

2.3.1 The scalar case: assem2d.m

In this subsection we introduce the details of writing the subroutine assem2d.m to assemble a

two-dimensional scalar bilinear form

a(v, u),

v = ϕi, u = φj,

i = 1, · · · , m,

j = 1, · · · , n,

where the test function v and the trial function u are allowed to match diﬀerent ﬁnite element

spaces, which can be found in mixed ﬁnite element methods for Stokes problems. For the scalar

case, assem2d.m is essentially the same as int2d.m, while the later one can be used to deal with

vector cases like linear elasticity problems. To handle diﬀerent spaces, we write Vh = {'P1', ...

'P2'} for the input of assem2d.m, where Vh{1} is for v and Vh{2} is for u. For simplicity, it is

also allowed to write Vh = 'P1' when v and u are in the same space.

Let us discuss the case where v and u lie in the same space. Suppose that the bilinear form

contains only ﬁrst-order derivatives. Then the possible combinations are

(cid:90)

K

avudx,

(cid:90)

K

(cid:90)

K

avuxdσ,

avuydσ,

(cid:90)

K

(cid:90)

K

(cid:90)

K

avxudx,

avxuxdσ,

avxuydσ,

(cid:90)

K

(cid:90)

K

(cid:90)

K

avyudσ,

avyuxdσ,

avyuydσ.

Of course, we often encounter the gradient form

(cid:90)

K

a∇v · ∇udσ =

(cid:90)

K

a(vxux + vyuy)dσ.

We take the second bilinear form as an example. Let

aK(v, u) =

(cid:90)

K

avxudσ,

and consider the P1-Lagrange ﬁnite element. Denote the local basis functions to be φ1, φ2, φ3. Then
the local stiﬀness matrix is

AK =

(cid:90)

K

a







(cid:104)
φ1 φ2 φ3

(cid:105)

dσ.







∂xφ1
∂xφ2
∂xφ3

Let

Then

v1 = ∂xφ1, v2 = ∂xφ2, v3 = ∂xφ3;

u1 = φ1, u2 = φ2, u3 = φ3.

AK = (kij)3×3,

kij =

(cid:90)

K

aviujdσ.

The integral will be approximated by the Gaussian quadrature rule:

kij =

(cid:90)

K

aviujdσ = |K|

ng
(cid:88)

p=1

wpa(xp, yp)vi(xp, yp)uj(xp, yp),

5

where (xp, yp) is the p-th quadrature point. In the implementation, we in advance store the quadra-
ture weights and the values of basis functions or their derivatives in the following form:

wp,

vi(:, p) =










p,y1
p)

vi|(x1
vi|(x2
p,y2
p)
...
vi|(xNT

p ,yNT
p )










,

uj(:, p) =










p,y1
p)

uj|(x1
uj|(x2
p,y2
p)
...
uj|(xNT

p ,yNT
p )










,

p = 1, · · · , ng,

where vi associated with vi is of size NT × ng with the p-th column given by vi(:, p). Let weight =
[w1, w2, · · · , wng ] and ww = repmat(weight, NT, 1). Then kij for a = 1 can be computed as

1 k11 = sum ( ww .* v1 .* u1 ,2) ;

2 k12 = sum ( ww .* v1 .* u2 ,2) ;

3 k13 = sum ( ww .* v1 .* u3 ,2) ;

4 k21 = sum ( ww .* v2 .* u1 ,2) ;

5 k22 = sum ( ww .* v2 .* u2 ,2) ;

6 k23 = sum ( ww .* v2 .* u3 ,2) ;

7 k31 = sum ( ww .* v3 .* u1 ,2) ;

8 k32 = sum ( ww .* v3 .* u2 ,2) ;

9 k33 = sum ( ww .* v3 .* u3 ,2) ;

10 K = [ k11 , k12 , k13 , k21 , k22 , k23 , k31 , k32 , k33 ];

Here we have stored the local stiﬀness matrix AK in the form of [k11, k12, k13, k21, k22, k23, k31, k32, k33],
and stacked the results of all cells together. By adding the contribution of the area, one has

1 Ndof = 3;

2 K = repmat ( area ,1 , Ndof ^2) .* K ;

For the variable coeﬃcient case, such as a(x, y) = x + y, one can further introduce the coeﬃ-

cient matrix as

1 cf = @ ( pz ) pz (: ,1) + pz (: ,2) ; % x + y ;

2 cc = zeros ( NT , ng ) ;

3 for p = 1: ng

pz = lambda (p ,1) * z1 + lambda (p ,2) * z2 + lambda (p ,3) * z3 ;

cc (: , p ) = cf ( pz ) ;

4

5

6 end

where pz are the quadrature points on all elements. The above procedure can be implemented as

follows.

1 K = zeros ( NT , Ndof ^2) ;

2 s = 1;

3 v = { v1 , v2 , v3 }; u = { u1 , u2 , u3 };

4 for i = 1: Ndof

for j = 1: Ndof

vi = v { i }; uj = u { j };

K (: , s ) =

area .* sum ( ww .* cc .* vi .* uj ,2) ;

s = s +1;

end

5

6

7

8

9

10 end

The bilinear form is assembled by using the build-in function sparse.m as in iFEM. In this case,

the code is given as

1 ss = K (:) ;

2 kk = sparse ( ii , jj , ss , NNdof , NNdof ) ;

6

Here, the triple (ii, jj, ss) is called the sparse index. Please refer to the following link: https:
//www.math.uci.edu/~chenlong/ifemdoc/fem/femdoc.html.

Remark 2.1. For the case where v and u are in diﬀerent spaces, one just needs to modify the basis

functions and the number of local degrees of freedom accordingly. The code can be presented as

1 s = 1;

2 for i = 1: Ndofv

for j = 1: Ndofu

vi = vbase { i }; uj = ubase { j };

K (: , s ) =

K (: , s ) + area .* sum ( ww .* cc .* vi .* uj ,2) ;

s = s +1;

end

3

4

5

6

7

8 end

In varFEM, we use Base2d.m to load the information of vi and uj, for example, the following

code gives the values of ∂xφ, where φ is a local basis function.

1 v = 'v . dx ';
2 vbase = Base2d (v , node , elem , Vh {1} , quadOrder ) ; % v1 . dx , v2 . dx , v3 . dx

2.3.2 The vector case: int2d.m

Let us consider a typical bilinear form for linear elasticity problems, given as

aK(v, u) :=

(cid:90)

K

ε(v) : ε(u)dσ,

where v = (v1, v2)T , u = (u1, u2)T , and

ε(v) : ε(u) = v1,xu1,x + v2,yu2,y +

= v1,xu1,x + v2,yu2,y +

1
2
1
2

(v1,y + v2,x)(u1,y + u2,x)

(v1,yu1,y + v1,yu2,x + v2,xu1,y + v2,xu2,x).

(2.2)

(2.3)

The stiﬀness matrix can be assembled as

1 Coef

= {1 , 1 , 0.5 , 0.5 , 0.5 , 0.5};
= { ' v1 . dx ' , ' v2 . dy ' , ' v1 . dy ' , ' v1 . dy ' , ' v2 . dx ' , ' v2 . dx ' };
2 Test
3 Trial = { ' u1 . dx ' , ' u2 . dy ' , ' u1 . dy ' , ' u2 . dx ' , ' u1 . dy ' , ' u2 . dx ' };
4 kk = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

We also provide the subroutine getExtendedvarForm.m to get the extended combinations (2.3)

from (2.2), which has been included in int2d.m. Therefore, the bilinear form can be directly

assembled as

1 Coef = { 1 , 1 , 0.5 };

= { ' v1 . dx ' , ' v2 . dy ' , ' v1 . dy + v2 . dx ' };
2 Test
3 Trial = { ' u1 . dx ' , ' u2 . dy ' , ' u1 . dy + u2 . dx ' };
4 kk = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

In the rest of this subsection, we brieﬂy discuss the sparse index. Let v = (v1, v2, v3) and
u = (u1, u2, u3), and suppose that a(v, u) is a bilinear form. Note that, in general, vi(i = 1, 2, 3)
can be in diﬀerent spaces, but vi and ui are in the same space, otherwise the resulting stiﬀness

7

matrix is not a square matrix. The stiﬀness matrix after blocking has the following correspondence:

a(v, u)

↔

[v1, v2, v3]







A11 A12 A13
A21 A22 A23
A31 A32 A33



















,

u1
u2
u3

where ui is the vector of degrees of freedom of ui. It is easy to see that Aij can obtained as in
scalar case by assembling all pairs that contain (vi, uj) in a(v, u).

Let the sparse index for Aij be (iij, jij, sij). Let the numbers of rows and columns of Aij be
mi and nj, respectively. Then the ﬁnal sparse assembly index ii and jj can be written in block
matrix as







i11
i21 + m1
i31 + m2

i12
i22 + m1
i32 + m2

i13
i23 + m1
i33 + m2







and







j11
j21
j31

j12 + n1
j22 + n1
j32 + n1

j13 + n2
j23 + n2
j33 + n2







,

and obtained by straightening them as a column vector along the row vectors.

3 Tutorial examples

In this section, we present several examples to demonstrate the use of varFEM.

3.1 Poisson-type problems

We now provide the complete implementation of the model problem (2.1). The function ﬁle

reads

1 function uh = varPoisson ( Th , pde , Vh , quadOrder )

2

3 % % Assemble stiffness matrix

4 % Omega

5 Coef

= { pde .a , pde . c };
= { 'v . grad ' , 'v . val ' };
6 Test
7 Trial = { 'u . grad ' , 'u . val ' };
8 kk = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ; % or assem2d

9

10 % Robin data

11 bdStr = Th . bdStr ;

12 if ¬isempty ( bdStr )

Th . elem1d = Th . bdEdgeType {1};

Th . elem1dIdx = Th . bdEdgeIdxType {1};

Coef

= pde . g_R ;
= 'v . val ';
Test
Trial = 'u . val ';
kk = kk + assem1d ( Th , Coef , Test , Trial , Vh , quadOrder ) ; % or assem1d

13

14

15

16

17

18

19

20 end

21

22 % % Assemble the right hand side

23 % Omega

24 Coef = pde . f ;
25 Test = 'v . val ';
26 ff = int2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

8

27 % Neumann data

28 if ¬isempty ( bdStr )

% Coef = @ ( p ) pde . g_R ( p ) .* pde . uexact ( p ) + pde . a ( p ) .*( pde . Du ( p ) *n ') ;

fun = @ ( p ) pde . g_R ( p ) .* pde . uexact ( p ) ;

Cmat1 = interpEdgeMat ( fun , Th , quadOrder ) ;

fun = @ ( p ) repmat ( pde . a ( p ) ,1 ,2) .* pde . Du ( p ) ;

Cmat2 = interpEdgeMat ( fun , Th , quadOrder ) ;

Coef = Cmat1 + Cmat2 ;

ff = ff + assem1d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

29

30

31

32

33

34

35

36

37

38 end

39

40 % % Apply Dirichlet boundary conditions

41 g_D = pde . g_D ;
42 on = 2 - 1* isempty ( bdStr ) ; % 1 for bdStr = [] , 2 for bdStr = 'x ==0 '
43 uh = apply2d ( on , Th , kk , ff , Vh , g_D ) ;

In the above code, the structure pde stores the information of the PDE, including the exact

solution pde.uexact, the gradient pde.Du, etc. The Neumann data function is gN = gRu + a∂nu,
which varies on the boundary edges. For testing purposes, we compute this function by using the

exact solution. In Lines 31-35, we use the subroutine interpEdgeMat.m to derive the coeﬃcient

matrix as in Subsect. 2.3.1. We remark that the Coef has three forms:

1. A function handle or a constant.

2. The numerical degrees of freedom of a ﬁnite element function.

3. A coeﬃcient matrix resulting from the numerical integration.

In the computation, the ﬁrst two forms in fact will be transformed to the third one.

The boundary edges will be divided into at most two parts. For example, when bdStr = ...

'x==0', the Robin boundary part is given by elem1d = Th.bdEdgeType{1}. The remaining part

is for the Dirichlet boundary condition, with the index on = 1 given for Th.bdEdgeType.

The test script is presented as follows.

1 % % Parameters

2 maxIt = 5;

3 N = zeros ( maxIt ,1) ;

4 h = zeros ( maxIt ,1) ;

5 ErrL2 = zeros ( maxIt ,1) ;

6 ErrH1 = zeros ( maxIt ,1) ;

7

8 % % Generate an intitial mesh

9 [ node , elem ] = squaremesh ([0 1 0 1] ,0.5) ;
10 bdStr = 'x ==0 ';

11

12 % % Get PDE data

13 pde = Poissondatavar ;

14 g_R = @ ( p ) 1 + p (: ,1) + p (: ,2) ; % 1 + x + y

15 pde . g_R = g_R ;

16

17 % % Finite Element

18 i = 1; % 1 ,2 ,3

9

19 Vh = [ 'P ' , num2str ( i ) ];
20 quadOrder = i +2;

21 for k = 1: maxIt

% refine mesh

[ node , elem ] = uniformrefine ( node , elem ) ;

% get the mesh information

Th = FeMesh2d ( node , elem , bdStr ) ;

% solve the equation

uh = varPoisson ( Th , pde , Vh , quadOrder ) ;

% record and plot

N ( k ) = size ( elem ,1) ;

h ( k ) = 1/( sqrt ( size ( node ,1) ) -1) ;

if N ( k ) < 2 e3

% show mesh and solution for small size

figure (1) ;

showresult ( node , elem , pde . uexact , uh ) ;

drawnow ;

end

% compute error

ErrL2 ( k ) = varGetL2Error ( Th , pde . uexact , uh , Vh , quadOrder ) ;

ErrH1 ( k ) = varGetH1Error ( Th , pde . Du , uh , Vh , quadOrder ) ;

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39 end

40

41 % % Plot convergence rates and display error table

42 figure (2) ;

43 showrateh (h , ErrH1 , ErrL2 ) ;
44 fprintf ( '\ n ') ;
45 disp ( ' Table : Error ')
46 colname = { '# Dof ' , 'h ' , ' || u - u_h || ' , '|u - u_h | _1 ' };
47 disptable ( colname ,N ,[] , h , ' %0.3 e ' , ErrL2 , ' %0.5 e ' , ErrH1 , ' %0.5 e ') ;

In the for loop, we ﬁrst load or generate the mesh, which immediately returns the matrix

node and elem to the Matlab workspace. Then we set up the boundary conditions to get the

structural information. The subroutine varPoisson.m is the function ﬁle containing all source

code to implement the FEM as given before. When obtaining the numerical solutions, we can
visualize the solutions by using the subroutines showresult.m. We then calculate the discrete L2
and H 1 errors via the subroutines varGetL2Error.m and varGetH1Error.m. The procedure is

completed by verifying the rate of convergence through showrateh.m.

Fig. 1: The nodal values of exact and numerical solutions for the model problem

The test script can be easily used to compute Pi-Lagrange element for i = 1, 2, 3 (see Line 18
in the test script). The nodal values for the model problem are displayed in Fig. 1. The rates of

convergence are shown in Fig. 2, from which we observe the optimal convergence for all cases.

We also print the errors on the Matlab command window, with the results for P3 element given

below:

10

00.5100.20.40.60.811.81212.2uy2.40.5x0.5001.81212.2uy2.40.5x0.500(a) i = 1

(b) i = 2

(c) i = 3

Fig. 2: Convergence rates for the model problem.

Table: Error

#Dof

____

32

128

512

2048

8192

h

||u-u_h||

|u-u_h|_1

_________

___________

___________

2.500e-01

2.53816e-05

5.28954e-04

1.250e-01

1.53744e-06

6.50683e-05

6.250e-02

9.46298e-08

8.07922e-06

3.125e-02

5.87001e-09

1.00695e-06

1.562e-02

3.65444e-10

1.25698e-07

We next consider the example with a circular domain or an L-shaped domain. Such a domain

can be generated by using the pdetool as

1 % % Generate an intitial mesh
2 g = ' circleg '; % ' lshapeg ';
3 [p ,e , t ] = initmesh (g , ' hmax ' ,0.5) ;
4 node = p '; elem = t (1:3 ,:) ';
5 bdStr = 'x >0 '; % string for Neumann

The results are given in Fig. 3

Fig. 3: The nodal values of exact and numerical solutions on circular domain or L-shaped region.

11

101102log(1/h)10-510-410-310-210-1100|u-hh|1O (h1)||u-uh||O (h2)101102log(1/h)10-810-710-610-510-410-310-210-1|u-hh|1O (h2)||u-uh||O (h3)101102log(1/h)10-1010-910-810-710-610-510-410-3|u-hh|1O (h3)||u-uh||O (h4)3.2 Linear elasticity problems

The linear elasticity problem is





−divσ = f in Ω,

u = 0

σn = g

on Γ0,

on Γ1,

(3.1)

where n = (n1, n2)T denotes the outer unit vector normal to ∂Ω. The constitutive relation for
linear elasticity is

σ(u) = 2µε(u) + λ(divu)I,

where σ = (σij) and ε = (εij) are the second order stress and strain tensors, respectively, satisfying
εij = 1
2 (∂iuj + ∂jui), λ and µ are the Lam´e constants, I is the identity matrix, and divu =
∂1u1 + ∂2u2.

3.2.1 The programming in scalar form

The vector problem can be solved in block form by using assem2d.m as scalar cases. The

equilibrium equation in (3.1) can also be written in the form

− µ∆u − (λ + µ)grad(divu) = f in Ω,

(3.2)

which is referred to as the displacement type in what follows.

In this case, we only consider

Γ0 = Γ := ∂Ω. The ﬁrst term ∆u can be treated as the vector case of the Poisson equation. The
variational formulation is

(cid:90)

µ

Ω

∇u · ∇vdx + (λ + µ)

(cid:90)

Ω

(div u)(div v)dσ =

(cid:90)

Ω

f · vdσ.

The ﬁrst term of the bilinear form can be split into

(cid:90)

µ

Ω

∇u1 · ∇v1dσ and µ

(cid:90)

Ω

∇u2 · ∇v2dσ.

They generate the same matrix, denoted A, corresponding to the blocks A11 and A22, respectively.
The computation reads

1 % ( v1 . grad , u1 . grad ) , ( v2 . grad , u2 . grad )

2 cf = 1;

3 Coef

= cf ;

Test

= 'v . grad ';

Trial = 'u . grad ';

4 A = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

The second term of the bilinear form has the following combinations:

(cid:90)

Ω

v1,xu1,xdx,

(cid:90)

Ω

v1,xu2,ydx,

(cid:90)

Ω

v2,yu1,xdx

(cid:90)

Ω

v2,yu2,ydx,

which correspond to A11, A12, A21 and A22, respectively, and can be computed as follows.

1 % ( v1 . dx , u1 . dx )

2 cf = 1;

3 Coef

= cf ;

Test

= 'v . dx ';

Trial = 'u . dx ';

4 B1 = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

12

5 % ( v1 . dx , u2 . dy )

6 cf = 1;

7 Coef

= cf ;

Test

= 'v . dx ';

Trial = 'u . dy ';

8 B2 = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

9 % ( v2 . dy , u1 . dx )

10 cf = 1;

11 Coef

= cf ;

Test

= 'v . dy ';

Trial = 'u . dx ';

12 B3 = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

13 % ( v2 . dy , u2 . dy )

14 cf = 1;

15 Coef

= cf ;

Test

= 'v . dy ';

Trial = 'u . dy ';

16 B4 = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

The block matrix is then given by

1 % kk

2 kk = [

mu * A +( lambda + mu ) * B1 ,

( lambda + mu ) * B2 ;

3

( lambda + mu ) * B3 ,

mu * A +( lambda + mu ) * B4

];

4 kk = sparse ( kk ) ;

The right-hand side has two components:

(cid:90)

Ω

f1v1dx and

(cid:90)

Ω

f2v2dx.

The load vector is assembled in the following way:

1 % % Assemble right hand side

2 % F1

3 trf = eye (2) ;

4 Coef = @ ( pz ) pde . f ( pz ) * trf (: , 1) ;

Test = 'v . val ';

% f = [ f1 , f2 ]

5 F1 = assem2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

6 % F2

7 trf = eye (2) ;

8 Coef = @ ( pz ) pde . f ( pz ) * trf (: , 2) ;

Test = 'v . val ';

9 F2 = assem2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

10 % F

11 ff = [ F1 ; F2 ];

For the vector problem, we impose the Dirichlet boundary value conditions as follows.

1 % % Apply Dirichlet boundary conditions

2 g_D = pde . g_D ;

3 on = 1;

4 g_D1 = @ ( p ) g_D ( p ) *[1;0];

5 g_D2 = @ ( p ) g_D ( p ) *[0;1];

6 gBc = { g_D1 , g_D2 };

7 Vhvec = { Vh , Vh };

8 u = apply2d ( on , Th , kk , ff , Vhvec , gBc ) ; % note Vhvec

Here, g D1 is for u1 and g D2 is for u2. Note that the ﬁnite element spaces Vhvec must be given in
the same structure of gBc.

The solutions are displayed in Fig. 4.

13

Fig. 4: The nodal values of exact and numerical solutions for the elasticity problem of displacement

type.

3.2.2 The programming in vector form

The bilinear form is

a(v, u) = 2µ

(cid:90)

Ω

εij(v)εij(u)dσ + λ

(cid:90)

Ω

(∂ivi)(∂juj)dσ,

where the summation is ommited. The computation of the ﬁrst term has been given in Sub-

sect. 2.3.2, i.e.,

1 % ( Eij ( u ) : Eij ( v ) )

2 Coef = { 1 , 1 , 0.5 };

= { ' v1 . dx ' , ' v2 . dy ' , ' v1 . dy + v2 . dx ' };
3 Test
4 Trial = { ' u1 . dx ' , ' u2 . dy ' , ' u1 . dy + u2 . dx ' };
5 A = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

6 A = 2* mu * A ;

The second term can be computed as

1 % ( div u , div v )

2 Coef = 1;

= ' v1 . dx + v2 . dy ' ;

3 Test
4 Trial = ' u1 . dx + u2 . dy ';
5 B = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

6 B = lambda * B ;

7 % stiffness matrix

8 kk = A + B ;

The linear form is

(cid:96)(v) =

(cid:90)

Ω

f · vdσ +

(cid:90)

Γ1

g · vds.

For the ﬁrst term, one has

1 Coef = pde . f ;

Test = 'v . val ';

2 ff = int2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

Note that we have added the implementation for f · v by just setting Test = 'v.val'. For the

second term, we ﬁrst determine the one-dimensional edges:

1 % % Get 1 D mesh for boundary integrals

2 bdStr = Th . bdStr ;

3 if ¬isempty ( bdStr )

Th . elem1d = Th . bdEdgeType {1};

Th . elem1dIdx = Th . bdEdgeIdxType {1};

4

5

6 end

14

The coeﬃcient matrix for the boundary integral can be computed using interpEdgeMat.m and

the Neumann condition is then realized as

1 % % Assemble Neumann boundary conditions

2 if ¬isempty ( bdStr )

g_N = pde . g_N ; trg = eye (3) ;

g1 = @ ( p ) g_N ( p ) * trg (: ,[1 ,3]) ;

Cmat1 = interpEdgeMat ( g1 , Th , quadOrder ) ;

g2 = @ ( p ) g_N ( p ) * trg (: ,[3 ,2]) ;

Cmat2 = interpEdgeMat ( g2 , Th , quadOrder ) ;

Coef = { Cmat1 , Cmat2 };

Test = 'v . val ';

ff = ff + int1d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

3

4

5

6

7

8

9

10 end

Here, the data g N is stored as gN = [σ11, σ22, σ12] in the structure pde.

The Dirichlet condition can be handled as the displacement type:

1 % % Apply Dirichlet boundary conditions

2 on = 2 - 1* isempty ( bdStr ) ;

3 g_D1 = @ ( pz ) pde . g_D ( pz ) *[1;0];

4 g_D2 = @ ( pz ) pde . g_D ( pz ) *[0;1];

5 g_D = { g_D1 , g_D2 };

6 u = apply2d ( on , Th , kk , ff , Vh , g_D ) ;

Note that Vh is of vector form.

In the test script, we set bdStr = 'y==0 | x==1'. The errors for the P3 element are listed

in Tab. 1.

Tab. 1: The L2 and H 1 errors for the elasticity problem of tensor form (P3 element)

(cid:93)Dof

h

ErrL2

ErrH1

32

2.500e-01

6.82177e-04

1.34259e-02

128

512

1.250e-01

3.90894e-05

1.61503e-03

6.250e-02

2.32444e-06

1.97527e-04

2048

3.125e-02

1.42085e-07

2.44506e-05

8192

1.562e-02

8.79363e-09

3.04301e-06

3.3 Mixed FEMs for the biharmonic equation

3.3.1 The programming in scalar form

For the mixed ﬁnite element methods, we ﬁrst consider the biharmonic equation with Dirichlet

boundary conditions:




∆2u = f

in Ω ⊂ R2,



u = ∂nu = 0

on ∂Ω.

By introducing a new variable w = −∆u, the above problem can be written in a mixed form as





−∆u = w,

−∆w = f,

u = ∂nu = 0

on ∂Ω.

15

The associated variational problem is: Find (w, u) ∈ H 1(Ω) × H 1

0 (Ω) =: V × U such that

Let

One has





(cid:90)

Ω

(cid:90)

Ω

∇u · ∇φdσ =

(cid:90)

wφdσ,

φ ∈ H 1(Ω),

∇w · ∇ψdσ =

Ω
(cid:90)

Ω

f ψdσ, ψ ∈ H 1

0 (Ω).

a(w, φ) = −

(cid:90)

Ω

wφdσ and b(φ, u) =

(cid:90)

Ω

∇φ · ∇udσ.




a(w, φ) + b(φ, u) = 0, φ ∈ H 1(Ω) = V,



b(w, ψ) = (f, ψ),

ψ ∈ H 1

0 (Ω) = U,

(3.3)

where a(·, ·) : V × V → R and b(·, ·) : V × U → R.

The functions u and w will be approximated by P1-Lagrange elements. Let N be the vector

of global basis functions. One easily gets




φT Aw + φT Bu = 0,



ψT BT w = ψT f ,

where

(cid:90)

A = −

N T N dσ,

(cid:90)

B =

∇N T · ∇N dσ,

f =

Ω
The system can be written in block matrix form as
(cid:35)

(cid:35) (cid:34)

(cid:34)

Ω

A B
BT O

w

u

(cid:34)

(cid:35)

.

0

f

=

(cid:90)

Ω

N T f dσ.

Remark 3.1. If ∂nu does not vanish on ∂Ω, then the mixed variational formulation is






a(w, φ) + b(φ, u) =

(cid:90)

∂Ω

∂nuφds, φ ∈ V,

b(w, ψ) = (f, ψ), ψ ∈ U.

Here, ∂nu corresponds to the Neumann boundary data for u in the ﬁrst equation.

In block form, the stiﬀness matrix can be computed as follows.

1 % % Assemble stiffness matrix

2 % matrix A

Test = 'v . val ';

3 Coef = 1;
4 A = - assem2d ( Th , Coef , Test , Trial , ' P1 ' , quadOrder ) ;
5 % matrix B

Trial = 'u . val ';

Test = 'v . grad ';

6 Coef = 1;
7 B = assem2d ( Th , Coef , Test , Trial , ' P1 ' , quadOrder ) ;
8 % kk

Trial = 'u . grad ';

9 O = zeros ( size ( B ) ) ;

10 kk = [A ,

B ;

B ' , O ];

11 kk = sparse ( kk ) ;

The right-hand side is given by

1 % % Assemble right - hand side

Test = 'v . val ';
2 Coef = pde . f ;
3 ff = assem2d ( Th , Coef , Test ,[] , ' P1 ' , quadOrder ) ;
4 O = zeros ( size ( ff ) ) ;

5 ff = [ O ; ff ];

16

The computation of the Neumann boundary condition reads

1 % % Assemble Neumann boundary condition

2 Th . elem1d = Th . bdEdge ; % all boundary edges

3 % Th . bdEdgeIdx1 = Th . bdEdgeIdx ;

4 % Coef = @ ( p ) pde . Du ( p ) * n ;

5 Coef = interpEdgeMat ( pde . Du , Th , quadOrder ) ;
6 Test = 'v . val ';
7 ff (1: N ) = ff (1: N ) + assem1d ( Th , Coef , Test ,[] , ' P1 ' , quadOrder ) ;

We ﬁnally impose the Dirichlet boundary conation as

1 % % Apply Dirichlet boundary conditions

2 on = 1;

3 g_D = pde . g_D ;

4 gBc = {[] , g_D };
5 Vhvec = { ' P1 ' , ' P1 ' };
6 U = apply2d ( on , Th , kk , ff , Vhvec , gBc ) ; % note Vhvec

7 w = U (1: N ) ;

u = U ( N +1:end) ;

Note that the Dirichlet data is only for u, so we set gBc{1} = [] in Line 4.

The convergence rates for u and w are shown in Fig. 5, from which we clearly observe the

ﬁrst-order and the second-order convergence in the H 1 norm and L2 norm for both variables.

Fig. 5: The convergence rates of the mixed FEM for the biharmonic equation (P1 element)

3.3.2 The programming in vector form

Let u1 = w, u2 = u, v1 = φ and v2 = ψ. Then the problem (3.3) can be regarded as a
variational problem of vector form, with u = (u1, u2)T being the trial function and v = (v1, v2)T
being the test function. One easily ﬁnds that the mixed form (3.3) is equivalent to the following

vector form

(cid:90)

Ω

(−v1u1 + ∇v1 · ∇u2 + ∇v2 · ∇u1)dσ =

(cid:90)

Ω

f v2dx +

(cid:90)

∂Ω

g2v1ds,

which is obtained by adding the two equations.

Using int2d.m and int1d.m, we can compute the vector u as follows.

1 % % Assemble stiffness matrix

2 Coef = { -1 , 1 , 1 };

= { ' v1 . val ' , ' v1 . grad ' , ' v2 . grad ' };
3 Test
4 Trial = { ' u1 . val ' , ' u2 . grad ' , ' u1 . grad ' };
5 kk = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

17

101102log(1/h)10-310-210-1100|u-hh|1O (h1)||u-uh||O (h1.9)101log(1/h)10-1100101102103|w-wh|1O (h1)||w-wh||O (h1.9)6

7 % % Assemble right hand side
8 Coef = pde . f ; Test = ' v2 . val ';
9 ff = int2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

10

11 % % Assemble Neumann boundary conditions

12 % Get 1 D mesh for boundary integrals

13 Th . elem1d = Th . bdEdgeType {1};

14 Th . elem1dIdx = Th . bdEdgeIdxType {1};

15

16 % Coef = @ ( p ) pde . Du ( p ) * n ;

17 Coef = interpEdgeMat ( pde . Du , Th , quadOrder ) ;
18 Test = ' v1 . val ';
19 ff = ff + int1d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

20

21 % % Apply Dirichlet boundary conditions

22 g_D = { [] , pde . g_D };

23 on = 1;

24 U = apply2d ( on , Th , kk , ff , Vh , g_D ) ;

25 U = reshape (U ,[] ,2) ;

26 w = U (: ,1) ;

u = U (: ,2) ;

In the above code, Vh can be chosen as {'P1', 'P1'}, {'P2', 'P2'} and {'P3', 'P3'}.

The results are displayed in Fig. 6. We can ﬁnd that the rate of convergence for u is optimal but

for w is sub-optimal:

- For linear element, optimal order for w is also observed.

- For P2 element, the order for L2 is 1.5 and for H 1 is 0.5.

- For P3 element, the order for L2 is 2.5 and for H 1 is 1.5.

Note that our results are consistent with that given in iFEM. Obviously, for P2 and P3 elements,
the rate of w has the behaviour of ∆u, which is reasonable since w = −∆u.

(a) P1

(b) P2

(c) P3

Fig. 6: The convergence rates for the biharmonic equation.

18

101102log(1/h)10-410-310-210-1100101|u-hh|1O (h1)||u-uh||O (h1.9)101102log(1/h)10-210-1100101102103|u-hh|1O (h1)||u-uh||O (h1.9)101102log(1/h)10-610-510-410-310-210-1100|u-hh|1O (h2)||u-uh||O (h3.1)101102log(1/h)10-210-1100101102103|u-hh|1O (h0.47)||u-uh||O (h1.5)101102log(1/h)10-910-810-710-610-510-410-310-210-1|u-hh|1O (h3)||u-uh||O (h4.1)101102log(1/h)10-410-310-210-1100101102|u-hh|1O (h1.6)||u-uh||O (h2.5)3.4 Mixed FEMs for the Stokes problem

The Stokes problem with homogeneous Dirichlet boundary conditions is to ﬁnd (u, p) such

that





−ν∆u − ∇p = f in Ω,

divu = 0

u = 0

in Ω,

on ∂Ω.

Deﬁne V = H 1

0 (Ω) and P = L2

0(Ω). The mixed variational problem is: Find (u, p) ∈ V × Q such

that

where




a(u, v) + b(v, p) = (f , v),

v ∈ V ,



b(u, q)

= 0,

q ∈ P,

a(u, v) = (ν∇u, ∇v),

b(v, q) = (divv, q).

Let Th be a shape regular triangulation of Ω. We consider the conforming ﬁnite element
discretizations: Vh ⊂ V and Ph ⊂ P . Typical pairs (Vh, Ph) of stable ﬁnite element spaces include:
MINI element, Girault-Raviart element and Pk −Pk−1 elements. For the last one, a special example
is the P2−P1 element, also known as the Taylor-Hood element, which is the one under consideration.

The FEM is to ﬁnd (uh, ph) ∈ Vh × Ph such that




a(uh, v) + b(v, ph) = F (v), v ∈ Vh,



b(uh, q) = 0,

q ∈ Ph.

(3.4)

The problem (3.4) can be solved either by discretizing it directly into a system of equations (a

saddle point problem), or by adding the two equations, as done for the biharmonic equation. We
consider the latter one: Find (uh, ph) ∈ Vh × L2(Ω) such that

a(uh, v) + b(v, ph) + b(uh, q) − ε(ph, q) = F (v), v ∈ Vh, ∈ L2(Ω),

(3.5)

where ε is a small parameter to ensure stability.

The bilinear form can be assembled as follows.

1 Vh = { ' P2 ' , ' P2 ' , ' P1 ' }; quadOrder = 5;

2

3 % % Assemble stiffness matrix
4 vstr = { ' v1 ' , ' v2 ' , 'q ' }; ustr = { ' u1 ' , ' u2 ' , 'p ' };
5 % [ v1 , v2 , q ] = [ v1 , v2 , v3 ] , [ u1 , u2 , p ] = [ u1 , u2 , u3 ]

6 %

a1 ( v1 , u1 ) + a2 ( v2 , u2 )

7 % + b1 ( v1 , p )

+ b2 ( v2 , p )

8 % + b1 (q , u1 )

+ b2 (q , u2 ) - eps *( q , p )

9 eps = 1e -10;

10 Coef = { 1 , 1 ,

-1 , -1 ,

-1 , -1 ,

- eps };

= { ' v1 . grad ' , ' v2 . grad ' , ' v1 . dx ' ,
11 Test
12 Trial = { ' u1 . grad ' , ' u2 . grad ' , 'p . val ' ,
13 [ Test , Trial ] = getStdvarForm ( vstr , Test ,

' v2 . dy ' ,
'p . val ' , ' u1 . dx ' ,

'q . val ' , 'q . val ' , 'q . val ' };
' u2 . dy ' ,

'p . val ' };

ustr , Trial ) ; % [ u1 , u2 , p ] --> [ u1 , u2 , u3 ]

14 [ kk , info ] = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

Note that the symbols p and q correspond to u3 and v3, which is realized by using the subroutine

getStdvarForm.m.

The computation of the right-hand side reads
19

1 % % Assemble right hand side

2 trf = eye (2) ;

3 Coef1 = @ ( pz ) pde . f ( pz ) * trf (: , 1) ;

Coef2 = @ ( pz ) pde . f ( pz ) * trf (: , 2) ;

4 Coef = { Coef1 , Coef2 };
5 Test = { ' v1 . val ' , ' v2 . val ' };
6 ff = int2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

In this case, one can not use Coef = pde.f and Test = 'v.val' instead since v = [v1, v2, v3]T
has three components.

We impose the Dirichlet boundary conditions as follows.

1 % % Apply Dirichlet boundary conditions

2 tru = eye (2) ;

3 g_D1 = @ ( pz ) pde . g_D ( pz ) * tru (: , 1) ;

4 g_D2 = @ ( pz ) pde . g_D ( pz ) * tru (: , 2) ;

5 g_D = { g_D1 , g_D2 , []};

6 on = 1;

7 U = apply2d ( on , Th , kk , ff , Vh , g_D ) ;

8 NNdofu = info . NNdofu ;

9 id1 =

NNdofu (1) ;

id2 = NNdofu (1) + NNdofu (2) ;

10 uh = [ U (1: id1 ) , U ( id1 +1: id2 ) ]; % uh = [ u1h , u2h ]
11 ph = U ( id2 +1:end) ;

Note that g D{3} = [] since no constraints are imposed on p.

Example 3.1. Let Ω = (0, 1)2. We choose the load term f in such a way that the analytical

solution is

u(x, y) =

(cid:34)

−28(x2 − 2x3 + x4)(2y − 6y2 + 4y3)
28(2x − 6x2 + 4x3)(y2 − 2y3 + y4)

(cid:35)

and p(x, y) = −28(2 − 12x + 12x2)(y2 − 2y3 + y4).

The results are displayed in Fig. 7 and Tab. 2, from which we observe the optimal rates of

convergence both for u and p.

Fig. 7: Convergence rates of the Taylor-Hood element for the Stokes problem

20

101102log(1/h)10-510-410-310-210-1100101|u-hh|1O (h2)||u-uh||O (h3.1)101102log(1/h)10-310-210-1100101102|u-hh|1O (h1)||p-ph||O (h2.1)Tab. 2: The discrete errors for the Stokes problem

(cid:93)Dof

h

32

2.500e-01

(cid:107)u − uh(cid:107)
8.88464e-02

|u − uh|1
2.52940e+00

(cid:107)p − ph(cid:107)
1.59802e+00

128

512

1.250e-01

1.01868e-02

6.62003e-01

3.36224e-01

6.250e-02

1.21537e-03

1.67792e-01

7.88512e-02

2048

3.125e-02

1.50235e-04

4.21077e-02

1.94079e-02

8192

1.562e-02

1.87368e-05

1.05374e-02

4.83415e-03

3.5 Time-dependent problems

As an example, we consider the heat equation:






ut − ∆u = f

in Ω,

u(x, y, 0) = u0(x, y)

in Ω,

u = gD

∂nu = gN

on ΓD,

on ΓN .

After applying the backward Euler discretization in time, we shall seek un(x, y) satisfying for all
v ∈ H 1

0 (Ω):

(cid:90)

Ω

(cid:16) un − un−1
∆t

v + ∇un · ∇v

(cid:17)

dσ =

(cid:90)

(cid:90)

f nvdσ +

gn
N vds.

Ω

ΓN

We ﬁst generate a mesh and compute the mesh information.

1 % % Mesh

2 % generate mesh

3 Nx = 10;

4 [ node , elem ] = squaremesh ([0 1 0 1] ,1/ Nx ) ;

5 % mesh info
6 bdStr = 'x ==0 '; % Neumann
7 Th = FeMesh2d ( node , elem , bdStr ) ;

8 % time

9 Nt = Nx ^2;
10 t = linspace (0 ,1 , Nt +1) ';

dt = t (2) -t (1) ;

The PDE data is given by

1 % % PDE data

2 pde = heatData () ;

The exact solution is chosen as u = sin(πx) sin(y)e−t.

For ﬁxed ∆t, the bilinear form gives the same stiﬀness matrix in each iteration.

1 % % Backward Euler

2 u0 = @ ( p ) pde . uexact (p , t (1) ) ;

3 uh0 = interp2d ( u0 , Th , Vh ) ; % dof vector

4 uf = zeros ( Nt +1 ,2) ;

% record solutions at p - th point

5 p = 2* Nx ;

6 uf (1 ,:) = [ uh0 ( p ) , uh0 ( p ) ];

7 for n = 1: Nt

8

9

% Linear form

fun = @ ( p ) pde . f (p , t ( n +1) ) ;

21

Coef = fun ;

Test = 'v . val ';

ff = assem2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

Coef = uh0 / dt ;

ff = ff + assem2d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

% Neumann boundary condition

if ¬isempty ( bdStr )

Th . elem1d = Th . bdEdgeType {1};

Th . elem1dIdx = Th . bdEdgeIdxType {1};

fun = @ ( p ) pde . Du (p , t ( n +1) ) ;

Coef = interpEdgeMat ( fun , Th , quadOrder ) ;

ff = ff + assem1d ( Th , Coef , Test ,[] , Vh , quadOrder ) ;

end

% Dirichlet boundary condition

ue = @ ( p ) pde . uexact (p , t ( n +1) ) ;

on = 2 - 1* isempty ( bdStr ) ; % on = 1 for the whole boundary if bdStr = []

uh = apply2d ( on , Th , kk , ff , Vh , ue ) ;

% Record

uhe = interp2d ( ue , Th , Vh ) ;

uf ( n +1 ,:) = [ uhe ( p ) , uh ( p ) ];

% Update

uh0 = uh ;

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35 end

In the above code, we record solutions at p-th point, where p = 2Nx. The results are shown

in Fig. 8 and Fig. 9.

Fig. 8: Exact and numerical solutions for the heat equation

Fig. 9: Exact and numerical solutions at a ﬁxed point for the heat equation

It is well-known that the error behaves as O(∆t + hk+1) for the Pk-Lagrange element. To test
the convergence order w.r.t h, one can set ∆t = O(hk+1). The numerical results are consistent

22

00.20.40.60.81t0.020.0250.030.0350.040.0450.050.0550.06with the theoretical prediction as shown in Fig. 10.

(a) P1

(b) P2

(c) P3

Fig. 10: Convergence rates for the heat equation.

4 Examples in FreeFEM Documentation

We in this section present ﬁve examples given in FreeFEM. Many more examples can be found

or will be added in the example folder in varFEM.

4.1 Membrane

This is an exmple given in FreeFEM Documentation: Release 4.6 (see Subsection 2.3 - Mem-

brane).

The equation is simply the Laplace equation, where the region is an ellipse with the length of

the semimajor axis a = 2, and unitary the semiminor axis. The mesh on such a domain can be

generated by using the pdetool:

1 % % Mesh

2 % ellipse with a = 2 , b = 1

3 a = 2; b = 1;

4 g = ellipseg (a , b ) ;
5 [p ,e , t ] = initmesh (g , ' hmax ' ,0.2) ;
6 [p ,e , t ] = refinemesh (g ,p ,e , t ) ;
7 node = p '; elem = t (1:3 ,:) ';
8 figure ,

9 subplot (1 ,2 ,1) ,

10 showmesh ( node , elem ) ;

11 % bdStr
12 bdNeumann = 'y <0 & x > - sin ( pi /3) '; % string for Neumann
13 % mesh info

14 Th = FeMesh2d ( node , elem , bdNeumann ) ;

The Neumann boundary condition is imposed on

Γ2 = {(x, y) : x = a cos t, y = b sin t,

t ∈ (θ, 2π)},

θ = 4π/3,

which can be identiﬁed by setting bdStr = 'y<0 & x>-sin(pi/3)' as done in the code.

The remaining implementation is very simple, so we omit the details. The nodal values are

shown in Fig. 11a.

23

46810121416log(1/h)10-310-210-1100|u-hh|1O (h0.98)||u-uh||O (h2)46810121416log(1/h)10-510-410-310-210-1|u-hh|1O (h2)||u-uh||O (h3)46810121416log(1/h)10-710-610-510-410-310-2|u-hh|1O (h3)||u-uh||O (h4)(a) Nodal values

(b) Level lines

Fig. 11: Membrane deformation

We can also plot the level lines of the membrane deformation, as given in Fig. 11b. Note that

the contour ﬁgure is obtained by interpolating the ﬁnite element function to a two-dimensional

cartesian grid (within the mesh). The interpolated values can be created by using the Matlab build-

in function pdeInterpolant.m in the pdetool. However, the build-in function seems not eﬃcient.

For this reason, we provide a new realization of the interpolant, named varInterpolant2d.m.

With this function, we give a subroutine varcontourf.m to draw a contour plot.

4.2 Heat exchanger

Fig. 12: Heat exchanger geometry (see [2])

The geometry is shown in Fig. 12, where C1 and C2 are two thermal conductors within an

enclosure C0. The temperature u satisﬁes

∇ · (κ∇u) = 0

in Ω.

• The ﬁrst conductor is held at a constant temperature u1 = 100◦C, and the border of enclosure
C0 is held at temperature 20◦C. This means the domain is Ω = C0\C1, and the boundaries
consist of ∂C0 and ∂C1.

• The conductor C2 has a diﬀerent thermal conductivity than the enclosure C0: κ0 = 1 and

k2 = 3.

We use the mesh generated by FreeFEM, which is saved in a .msh ﬁle named meshdata heatex.msh.

The command in FreeFEM can be written as

1 savemesh ( Th , " meshdata_heat ex . msh ") ;

24

We read the basic data structures node and elem via a self-written function:

1 [ node , elem ] = getMeshFreeFEM ( ' mes hd at a_heatex . msh ') ;

Then the mesh data can be computed as

1 % bdStr
2 C0 = 'x .^2 + y .^2 > 3.8^2 '; % 1
3 bdStr = C0 ;

4 % mesh info

5 Th = FeMesh2d ( node , elem , bdStr ) ;

Note that the remaining boundary is ∂C1, hence the boundaries of C0 and the ﬁrst conductor are
labelled as 1 and 2, respectively.

The coeﬃcient κ can be written as

1 % % PDE data

2 kappa = @ ( p ) 1 + 2*( p (: ,1) < -1) .*( p (: ,1) > -2) .*( p (: ,2) <3) .*( p (: ,2) > -3) ;

% p = [x , y ]

And the bilinear form and the linear form are assembled as follows.

1 % % Bilinear form
2 Vh = ' P1 '; quadOrder = 5;
3 Coef = kappa ;
4 Test = { 'v . grad ' };
5 kk = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

Trial = { 'u . grad ' };

6

7 % % Linear form

8 ff = zeros ( size ( kk ,1) ,1) ;

The Dirichlet boundary conditions are imposed in the following way:

1 % % Dirichlet boundary conditions

2 on = [1 ,2];

3 gBc1 = @ ( p ) 20+0* p (: ,1) ;

4 gBc2 = @ ( p ) 100+0* p (: ,1) ;

5 uh = apply2d ( on , Th , kk , ff , Vh , gBc1 , gBc2 ) ;

Here, gBc1 is for ∂C0 or on(1), and gBc2 is for ∂C1 or on(2).

In FreeFEM, the numerical solution can be outputted using the command ofstream:

1 ofstream file (" sol_heatex . txt ") ;

2 file < < u [] < < endl ;

The saved information is then loaded by

1 uff = solFreeFEM ( ' sol_heatex . txt ') ;

The results are shown in Fig. 13, from which we observe that the varFEM solution is well

matched with the one given by FreeFEM.

25

(a) varFEM

(b) FreeFEM

(c) Level lines

Fig. 13: Numerical solutions given by varFEM and FreeFEM

4.3 Airfoil

This is an exmple given in FreeFem Documentation: Release 4.6 (Subsection 2.7 - Irrotational

Fan Blade Flow and Thermal eﬀects).

Consider a wing proﬁle S (the NACA0012 Airfoil) in a uniform ﬂow. Inﬁnity will be represented

by a large circle C where the ﬂow is assumed to be of uniform velocity. The domain is outside S,

with the mesh shown in Fig. 14. The NACA0012 airfoil is a classical wing proﬁle in aerodynamics,

whose equation for the upper surface is

y = 0.17735

√

x − 0.075597x − 0.212836x2 + 0.17363x3 − 0.06254x4.

With this equation, we can generate a mesh using the Matlab pdetool, as included in varFEM. The

function is mesh naca0012.m. For comparison, we use the mesh generated by FreeFEM.

Fig. 14: Mesh zoomed around the NACA0012 airfoil

The programming is very simple, given by

1 % % Parameters

2 theta = 8* pi /180;

3 lift = theta * 0 . 1 5 1 9 5 2 / 0 . 0 8 7 2 6 6 5 ; % lift approximation formula

4 uinfty1 = cos ( theta ) ;

uinfty2 = sin ( theta ) ;

5

6 % % Mesh
7 [ node , elem ] = getMeshFreeFEM ( ' meshd ata _a irf oil . msh ') ;
8 % mesh info
9 bdStr = 'x .^2 + y .^2 > 4.5^2 '; % 1 - C
10 Th = FeMesh2d ( node , elem , bdStr ) ;

11

12 % % Bilinear form
13 Vh = ' P2 ';
= 1;
14 Coef

quadOrder = 7;

26

-0.500.511.5-0.500.5= 'v . grad ';
15 Test
16 Trial = 'u . grad ';
17 kk = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

18

19 % % Linear form

20 ff = zeros ( size ( kk ,1) ,1) ;

21

22 % % Dirichlet boundary conditions

23 on = [1 ,2];

24 gBc1 = @ ( p ) uinfty1 * p (: ,2) - uinfty2 * p (: ,1) ; % on 1 - C

25 gBc2 = @ ( p ) - lift + 0* p (: ,1) ;

% on 2 - S

26 uh = apply2d ( on , Th , kk , ff , Vh , gBc1 , gBc2 ) ;

We refer the reader to the FreeFEM Documentation for more details (The code is potential.edp

in the software). The zoomed solutions of the streamlines are shown in Fig. 15, where the varFEM

solution is well matched with the one given by FreeFEM.

(a) varFEM solution

(b) FreeFEM solution

Fig. 15: Zoom around the NACA0012 airfoil showing the streamlines

4.4 Newton method for the steady Navier-Stokes equations

For the introduction of the problem, please refer to FreeFEM Documentation (Subsect. 2.12 -

Newton Method for the Steady Navier-Stokes equations).

In each iteration, one needs to solve the following variational problem: Find (δu, δp) such that

DF (δu, δp; u, p) = F (u, p),

where u and p are the solutions given in the last step, and
(cid:90)

DF (δu, δp; u, p) =

((δu · ∇)u) · v + ((u · ∇)δu) · v + ν∇δu : ∇v − q∇ · δu,

F (u, p) =

(cid:90)

Ω

Ω

((u · ∇)u) · v + ν∇u : ∇v − p∇u : ∇v − q · u,

where (v, q) are the test functions.

The ﬁnite element spaces and the quadrature rule are

1 Vh = { ' P2 ' , ' P2 ' , ' P1 ' }; % v = [ v1 , v2 , q ] --> [ v1 , v2 , v3 ]
2 quadOrder = 7;
3 vstr = { ' v1 ' , ' v2 ' , 'q ' }; ustr = { ' du1 ' , ' du2 ' , ' dp ' };

Here vstr and ustr are for the test and trial functions, respectively.

In the following, we only provide the detail for the assembly of the ﬁrst term of DF , i.e.,

(cid:90)

Ω

((δu · ∇)u) · v =

(cid:90)

Ω

u1,x · v1δu1 + u1,y · v1δu2 + u2,x · v2δu1 + u2,y · v2δu2.

(4.1)

27

In the iteration, u1,x, u1,y, u2,x and u2,y are the known coeﬃcients, which can be obtained from the
ﬁnite element function u in the last step. Let us discuss the implementation of varFEM:

• The initial data are

1 % initial data

2 u1 = @ ( p ) double ( ( p (: ,1) .^2 + p (: ,2) .^2 > 2) ) ;

3 u2 = @ ( p ) 0* p (: ,1) ;

4 p = @ ( p ) 0* p (: ,1) ;

We must convert them into the dof vectors in view of the iteration.

1 uh1 = interp2d ( u1 , Th , Vh {1}) ;

2 uh2 = interp2d ( u2 , Th , Vh {2}) ;

3 ph = interp2d (p , Th , Vh {3}) ;

• For numerical integration, it is preferable to provide the coeﬃcient matrices for these coeﬃ-

cient functions.

1 u1c = interp2dMat ( uh1 , ' u1 . val ' ,Th , Vh {1} , quadOrder ) ;
2 u2c = interp2dMat ( uh2 , ' u2 . val ' ,Th , Vh {2} , quadOrder ) ;
3 pc = interp2dMat ( ph , 'p . val ' ,Th , Vh {3} , quadOrder ) ;

4
5 u1xc = interp2dMat ( uh1 , ' u1 . dx ' ,Th , Vh {1} , quadOrder ) ;
6 u1yc = interp2dMat ( uh1 , ' u1 . dy ' ,Th , Vh {1} , quadOrder ) ;
7 u2xc = interp2dMat ( uh2 , ' u2 . dx ' ,Th , Vh {2} , quadOrder ) ;
8 u2yc = interp2dMat ( uh2 , ' u2 . dy ' ,Th , Vh {2} , quadOrder ) ;

Here, interp2dMat.m provides a way to get the coeﬃcient matrices only from the dof vectors.

• The triple (Coef,Test,Trial) for (4.1) is then given by

1 Coef = { u1xc , u1yc , u2xc , u2yc };

= { ' v1 . val ' , ' v1 . val ' , ' v2 . val ' , ' v2 . val ' };

2 Test
3 Trial = { ' du1 . val ' , ' du2 . val ' , ' du1 . val ' , ' du2 . val ' };

A complete correspondence of DF (δu, δp; u, p) can be listed in the following:

1 Coef = { u1xc , u1yc , u2xc , u2yc ,

... % term 1

2

3

4

5

6

7

u1c , u2c , u1c , u2c ,

... % term 2

nu , nu , nu , nu , ... % term 3

-1 , -1 , ... % term 4

-1 , -1 , ... % term 5

- eps ... % stablization term

};

8 Test

= { ' v1 . val ' , ' v1 . val ' , ' v2 . val ' , ' v2 . val ' , ... % term 1

9

10

11

12

13

' v1 . val ' , ' v1 . val ' , ' v2 . val ' , ' v2 . val ' , ... % term 2
' v1 . dx ' , ' v1 . dy ' , ' v2 . dx ' , ' v2 . dy ' , ... % term 3
' v1 . dx ' , ' v2 . dy ' , ... % term 4
'q . val ' , 'q . val ' , ... % term 5
'q . val ' ... % stablization term
};

14
15 Trial = { ' du1 . val ' , ' du2 . val ' , ' du1 . val ' , ' du2 . val ' ,... % term 1

16

17

18

19

' du1 . dx ' , ' du1 . dy ' , ' du2 . dx ' , ' du2 . dy ' , ... % term 2
' du1 . dx ' , ' du1 . dy ' , ' du2 . dx ' , ' du2 . dy ' , ... % term 3
' dp . val ' , ' dp . val ' , ... % term 4
' du1 . dx ' , ' du2 . dy ' , ... % term 5

28

20

21

' dp . val ' ... % stablization term
};

• The computation of the stiﬀness matrix reads

1 [ Test , Trial ] = getStdvarForm ( vstr , Test , ustr , Trial ) ;

2 [ kk , info ] = int2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

Here getStdvarForm.m transforms the user-deﬁned notation to the standard one.

The complete test script is available in test NSNewton.m. The varFEM solutions and the

FreeFEM solutions are shown in Fig. 16.

Fig. 16: The pressure p of a ﬂow

4.5 Optimal control

4.5.1 The gradient is not provided

This is an exmple given in FreeFem Documentation: Release 4.6 (Subsection 2.15 - Optimal

Control).

For a given target ud, the problem is to ﬁnd u such that
(cid:90)

(cid:90)

J(z) =

min
z∈R3

(u − ud)2 =

IE(u − ud)2,

z = (b, c, d),

E

Ω

where E ⊂ Ω, IE is an indication function, and u is the solution of the following PDE:




−∇(κ(b, c, d) · ∇u) = 0

in Ω,



u = uΓ

on Γ ⊂ ∂Ω.

Let B, C and D be the separated subsets of Ω. The coeﬃcient κ is deﬁned as

κ(x) = 1 + bIB(x) + cIC(x) + dID(x),

x ∈ Ω.

For ﬁxed z = (b, c, d), one can solve the PDE to obtain an approximate solution uh and the

approximate objective function:

Jh(z, uh, ud) :=

(cid:90)

Ω

IE(uh(z) − ud)2.

We use the build-in function fminunc.m in Matlab to ﬁnd the (local) minimizer. To this end, we

ﬁrst establish a function to get the PDE solution:
29

1 % % Problem for the PDE constraint

2 function uh = PDEcon (z , Th )

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24 end

% Parameters

Vh = Th . Vh ; quadOrder = Th . quadOrder ;

Ib = @ ( p ) ( p (: ,1) .^2 + p (: ,2) .^2 < 1.0001) ;

Ic = @ ( p ) ( ( p (: ,1) +3) .^2 + p (: ,2) .^2 < 1.0001) ;

Id = @ ( p ) ( p (: ,1) .^2 + ( p (: ,2) +3) .^2 < 1.0001) ;

% Bilinear form

Coef = @ ( p ) 1 + z (1) * Ib ( p ) + z (2) * Ic ( p ) + z (3) * Id ( p ) ;
Test = 'v . grad ';
Trial = 'u . grad ';
kk = assem2d ( Th , Coef , Test , Trial , Vh , quadOrder ) ;

% Linear form

ff = zeros ( size ( kk ,1) ,1) ;

% Dirichlet boundary condition

gD = @ ( p ) p (: ,1) .^3 - p (: ,2) .^3;

on = 1;

uh = apply2d ( on , Th , kk , ff , Vh , gD ) ;

The cost function is then given by

1 % % Cost function

2 function err = J (z , ud , Th )

Ie = @ ( p ) (( p (: ,1) -1) .^2 + p (: ,2) .^2 ≤4) ;

uh = PDEcon (z , Th ) ;

fh = Ie ( Th . node ) .*( uh - ud ) .^2;

err = integral2d ( Th , fh , Th . Vh , Th . quadOrder ) ;

3

4

5

6

7

8 end

Given a vector zd = [2, 3, 4], we can construct an “exact solution” solution ud by solving the

PDE. The minimizer is then given by

1 % % The constructed solution

2 zd = [2 , 3 , 4];

3 ud = PDEcon ( zd , Th ) ;

4

5 % % Find the mimimizer
6 options . LargeScale = ' off ';
7 options . HessUpdate = ' bfgs ';
8 options . Display = ' iter ';
9 z0 = [1 ,1 ,1];

10 zmin = fminunc ( @ ( z ) J (z , ud , Th ) , z0 , options )

In the Matlab command window, one can get the following information:

Iteration Func-count

0

1

2

3

4

5

6

4

8

12

16

20

24

28

f(x)

30.9874

9.87548

6.27654

4.76889

4.47092

3.46888

2.13699

Step-size

0.0129606

1

1

1

1

1

First-order

optimality

77.2

21.4

12.2

5.3

3.03

5.66

5.77

30

7

8

9

10

11

12

13

14

15

16

17

18

19

32

36

40

44

48

52

56

60

64

68

72

76

80

1.06649

0.542858

0.295327

0.179846

0.114221

0.063295

0.0242571

0.00729547

0.00170544

3.95891e-05

3.54227e-07

3.36066e-10

5.54979e-13

1

1

1

1

1

1

1

1

1

1

1

1

1

4.42

3.14

2.18

1.7

1.28

0.842

0.366

0.258

0.107

0.0257

0.00546

0.000159

3.88e-06

Local minimum found.

Optimization completed because the size of the gradient is less than

the value of the optimality tolerance.

<stopping criteria details>

zmin =

2.0000

3.0000

4.0000

We can observe that the minimizer is found after 19 iterations, with the solutions displayed in

Fig. 17.

Fig. 17: Numerical solutions of the optimal control problem

4.5.2 The gradient is provided

For the example given in FreeFEM, the optimization problem is solved by the quasi-Newton

BFGS method:

1 BFGS (J , DJ , z , eps =1. e -6 , nbiter =15 , nbiterline =20) ;

Here, DJ is the derivatives of J with respect to b, c, d. We also provide an implementation when

the gradient is available. In this case, the cost function should be modiﬁed as

1 function [ err , derr ] = J (z , ud , Th )

2 end

Here err and derr correspond J and DJ, respectively. For the details of the implementation, please

refer to the test script test optimalControlgrad.m in varFEM. The minimizer is then captured

as follows.

1 % % Find the mimimizer
2 options = optimoptions ( ' fminunc ' , ' Display ' , ' iter ' ,...

3

' S p e c i f y O b j e c t i v e G r a d i e n t ' , true ) ; % gradient is provided

31

4 z0 = [1 ,1 ,1];

5 zmin = fminunc ( @ ( z ) J (z , ud , Th ) , z0 , options )

Note that Line 3 indicates that the gradient is provided.

The minimizer is also found, with the printed information given as

Iteration Func-count

0

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

f(x)

30.9874

9.87549

6.27653

4.76889

4.47091

3.46888

2.137

1.06648

0.542849

0.295333

0.179846

0.114223

0.0632962

0.0242572

0.00729561

0.0017055

3.95888e-05

3.54191e-07

3.47621e-10

4.31601e-13

Step-size

optimality

0.0129606

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

77.2

21.4

12.2

5.3

3.03

5.66

5.77

4.42

3.14

2.18

1.7

1.28

0.842

0.366

0.258

0.107

0.0257

0.00546

0.000159

3.87e-06

Local minimum found.

Optimization completed because the size of the gradient is less than

the value of the optimality tolerance.

<stopping criteria details>

zmin =

2.0000

3.0000

4.0000

Compared with the previous implementation, one can ﬁnd that the latter approach has fewer

function calls (although we need to compute the gradient by solving a PDE problem).

5 Concluding remarks

In this paper, a Matlab software package for the ﬁnite element method was presented for

various typical problems, which realizes the programming style in FreeFEM. The usage of the

library, named varFEM, was demonstrated through several examples. Possible extensions of this

library that are of interest include three-dimensional problems and other types of ﬁnite elements.

References

[1] L. Chen. iFEM: an integrated ﬁnite element method package in MATLAB. Technical report,

University of California at Irvine, 2009.

[2] F. Hecht. New development in freefem++. J. Numer. Math., 20(3-4):251–265, 2012.

32

