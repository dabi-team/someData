2
2
0
2

g
u
A
9
2

]
E
S
.
s
c
[

1
v
0
7
8
3
1
.
8
0
2
2
:
v
i
X
r
a

Creating Interactive Visualizations of TopHat Programs

Mark Gerarts
Open University
Heerlen, The Netherlands
mark.gerarts@gmail.com

Nico Naus
Virginia Tech
Blacksburg, VA, United States
niconaus@vt.edu

Marc de Hoog
Open University
Heerlen, The Netherlands
mla.dehoog@studie.ou.nl

Tim Steenvoorden
Open University
Heerlen, The Netherlands
tim.steenvoorden@ou.nl

ABSTRACT
Many companies and institutions have automated their business
process in workflow management software. The novel program-
ming paradigm Task-Oriented Programming (TOP) provides an
abstraction for such software. The largest framework based on
TOP, iTasks, has been used to develop real-world software.

Workflow software often includes critical systems. In such cases
it is important to reason over the software to ascertain its correct-
ness. The lack of a formal iTasks semantics makes it unsuitable
for formal reasoning. To this end TopHat has been developed as a
TOP language with a formal semantics. However, TopHat lacks a
graphical user interface (GUI), making it harder to develop practical
TopHat systems.

In this paper we present TopHat UI. By combining an existing
server framework and user interface framework, we have developed
a fully functioning proof of concept implementation in Haskell, on
top of TopHat’s semantics. We show that implementing a TOP
framework is possible using a different host language than iTasks
uses. None of TopHat’s formal properties have been compromised,
since the UI framework is completely separate from TopHat. We
run several example programs and evaluate their generated GUI.
Having such a system improves the quality and verifiability of TOP
software in general.

KEYWORDS
task oriented programming, user interface, functional programming

1 INTRODUCTION
Workflow software is present in most businesses and institutions
nowadays. From health care and first responders, to commerce and
industrial processes. Businesses use workflow software to stream-
line their processes, increase efficiency and reduce costs. In these
sectors, reliability of software is crucial.

Previous research into workflow software in the functional pro-
gramming community aimed to improve reliability, while at the
same time reducing the effort of development. This led to the de-
velopment of Task-Oriented Programming (TOP), a programming
paradigm that aims to facilitate working with multiple people to-
wards a shared goal over the internet. TOP separates the what from
the how. This separation allows programmers to focus on the work
that has to be done (what) instead of paying attention to design
issues, implementation details, operating system limitations, and
environment requirements (how) [1, 20].

iTasks [1], implemented in the functional programming language
Clean [7], is the main TOP framework and has been around for a
long time. iTasks has been used to create real-world applications,
such as an incident coordination tool for the Dutch coast guard [14].
While this proves its practical usability, iTasks lacks in formaliza-
tion. The iTasks semantics are given by its implementation, making
it much harder to formally reason about iTasks programs. Previous
attempts to mitigate this issue by some of iTasks’ creators involved
developing a separate iTasks semantics, which allowed them to per-
form model-based testing, but no formal verification [13]. Formal
program verification is a very powerful tool to ensure the correct-
ness of critical software, like the incident coordination tool. TopHat
is a Domain-Specific Language (DSL) that paves the way to formally
reason about task-oriented programs [26], by defining a formal TOP
semantics. These semantics have been implemented in Haskell and
Idris 1. Idris is a programming language that features dependent
types and a totality checker, which is used to prove properties of
TopHat programs.

Motivation
In this paper, we develop an interactive UI for TopHat. Before the
development of TopHat, it was the case that iTasks, TOP and Clean
were tied together very strongly. Previous research even suggests
that certain specific Clean features are essential to the implemen-
tation of TOP[20]: uniqueness typing, data generic programming,
dynamics [30] and a sophisticated backend using interpreted ABC
bytecode on clients [18], to name a few. We want to show that none
of those features are essential in implementing a TOP framework
with a GUI. On top of that, we want to demonstrate that this can
be achieved without making any changes to the TopHat language
and its implementation in Haskell.

We expect this work to bring TOP to a bigger audience. The
current Clean user base is quite small. Haskell is being used in pro-
duction code, has a huge number of packages available online and
an active community. Task-oriented programming could benefit
from being ported to Haskell, making it available to a large commu-
nity of both developers and researchers. Developing an interactive
UI for TopHat brings this one step closer.

Motivated by the above, this paper presents a prototype frame-
work written on top of TopHat’s Haskell implementation that is able
to create interactive graphical user interfaces of TopHat programs.

1https://github.com/timjs/tophat-proofs

1

 
 
 
 
 
 
Structure
The remainder of this paper is structured as follows: we first pro-
vide some background about TOP, including iTasks and TopHat
in Section 2. Section 3 introduces our TopHat UI prototype. Sec-
tion 4 demonstrates the capabilities of our framework, including
formal reasoning, using several example TopHat programs. We
highlight related work in Section 5. Section ?? reflects on the goals
and research questions outlined above. Section 6 concludes.

2 TASK-ORIENTED PROGRAMMING
This paper builds upon previous TOP research [1, 20, 26]. In this
section we describe the basic idea of TOP and two TOP implemen-
tations: iTasks and TopHat.

2.1 Task-Oriented Programming
TOP is centered around the concept of tasks, which specify the work
a user or system has to perform with a high level of abstraction.
The smallest possible task represents the smallest amount of work
a user or system can perform [20].

Combining small tasks allows creating large and complex appli-
cations using simple building blocks. Tasks can be combined using
combinators: they can be executed sequentially, in parallel, or con-
ditionally. These combinators closely resemble how collaboration
happens in real life.

TOP aims to facilitate collaborating with multiple people towards
a shared goal, over the internet. Creating complex applications is
further facilitated because tasks are first-class citizens: they can be
used as input of functions, they can be returned from them, and
tasks can contain other tasks as value.

Tasks are interactive and input-driven. When a task receives
input it is reevaluated and results in a new task. A task’s value can
be observed at all times. Tasks can share information with each
other, either directly through shared data stores, or by passing task
values to continuations.

TOP itself focuses on the domain logic, with tasks providing
merely a description of the work that has to be performed. It is left
up to a TOP framework to do the heavy lifting, such as generat-
ing the user interface, storing and handling data, setting up a web
server, and authenticating users. iTasks [1] is such a framework,
implemented in the functional programming language Clean [7].
An example of a basic task in iTasks is presented in Listing 1. De-
velopers only have to specify that they want the user to enter some
information. Passing this task description to iTasks generates an
application that prompts the user for their name.

1 enterName :: Task String
2 enterName = Hint " What is your name ? " @ > > enterInformation []

Listing 1: A simple task prompting the user for their name
(Clean)

The TOP paradigm provides an abstraction over workflow soft-
ware. Instead of having to write a server, database, user interfaces,
etc, programmers just define what needs to be done. The complete
application is then derived from this specification by the TOP frame-
work. TOP is usually embedded in pure functional programming.

2

Figure 1: Entering your name (left) and the result after press-
ing continue (right)

To summarize, TOP is made up of the following three core con-

cepts:

Tasks that describe the work that has to be performed, provid-
ing an abstraction that separates the what from the how [1].
Composition of tasks through combinators, allowing the cre-

ation of arbitrarily large tasks.

Data that is being passed between tasks sequentially and glob-

ally.

2.2 iTasks
iTasks [19] is a TOP framework that uses Clean [5] as its host
language. It supplements Clean with a set of combinators, model
types, and algorithms that allow the construction of task-oriented
programs.

An example of a basic task was given in Listing 1. iTasks will
automatically generate an entire application for this task. It uses
generics to deduce that a task of type String requires a text input
field. In Listing 2 we combine the task with a view task using a
sequential step combinator. A user has to enter their name and is
greeted by the program after stepping to the next task. Figure 1
shows how these steps would look in iTasks.

1 greet :: Task String
2 greet = enterName >>!
3

\ result -> viewInformation [] (" Hello " +++ result )

Listing 2: Combining two tasks with a step combinator
(Clean)

iTasks is a work in progress, receiving constant updates and
improvements. For example, a recent addition is the usage of a
distributed, dynamic infrastructure [18]. iTasks has formed the
basis of further research as well. Tonic [28] facilitates the subject
for non-technical people by providing graphical blueprints of iTasks
specifications. It also provides a way to monitor the process while
end users are interacting with the application [27]. iTasks acted as
the starting point for research into declarative user interfaces, first
for SVG images [2] and later as a generalized solution [3].

2.3 TopHat
When software is used in critical applications, it is important that
its behavior can be verified and formally reasoned about. iTasks is
primarily focused on practical applicability, and therefore lacks this
formalization. Testing an iTasks application is time consuming and
often incomplete because of the many different execution paths.

TopHat [26] distills TOP’s core features to provide a way to
reason about task-oriented programs. By employing symbolic exe-
cution it is possible to formally verify TopHat programs [17]. Sym-
bolic execution has also been used to provide end-users of tasks
with additional feedback [16].

Our work is based on TopHat’s Haskell implementation. Listing 3
gives the TopHat implementation of the example introduced in Sec-
tion 2.2. Similar to the iTasks code, this task uses a step combinator
to ask a user their name and subsequently greet them.

1 greet :: Task h String
2 greet = enter >>? \ result -> view (" Hello " ++ result )

Listing 3: A TopHat task that greets the user (Haskell)

TopHat contains the following set of tasks and combinators:
Editors model user interaction. They are typed containers that
are either empty or hold a value. TopHat contains different
kinds of editors:
Update contains a predefined value.
View is an editor with a view-only value.
Enter is an editor that is initially empty. Filling it transforms

it into an Update editor.

Watch displays the value of a shared data store.
Change is an editor that allows to change the value of a

shared data store.

Done and Fail are success and failure end tasks.
Pair combines two tasks (parallel-and).
Choose makes a choice between two tasks (parallel-or).
Step sequentially moves from one task to another.
Share creates a shared data store.
Assign assigns a value to a reference in a shared data store.

2.4 Formal reasoning
iTasks defines tasks as a “state transforming function that reacts
to an event, rewrites itself to a reduct and accumulates responses
to users” [20]. For combinators, iTasks takes the swiss-army-knife-
approach. It defines two combinators that perform a multitude of ac-
tions. From these combinators, more simple ones can be constructed.
For example, the »* combinator performs sequential composition,
allows the user to choose from a list of tasks, allows automatic
progressing tasks, guarded tasks, and stepping on exception. Its
definition in the latest version of iTasks is about 100 lines of Clean
code, relying on many custom functions 2. While iTasks is certainly
an impressive engineering accomplishment, it is unfit for formal
reasoning.

TopHat on the other hand defines tasks as a simple datatype, with
three base cases and a small number of simple combinators [26].
The TopHat framework takes care of handling events, rewriting
and task rendering. The formal TopHat semantics fits on a single
page, and is largely straightforward.

To demonstrate the formal reasoning capabilities of TopHat, a
symbolic execution semantics has been developed [17]. For space
reasons, we will refrain from repeating syntax and semantics here,
but will revisit an example, to use thoughout this paper.

let today = 25 Sept 2020 in
let provideDocuments = ⊠ Amount ⊲⊳ ⊠ Date in
let companyConfirm = □ True ♢ □ False in
let officerApprove = 𝜆 invoiceDate. 𝜆 date. 𝜆 confirmed.
□ False ♢ if (date − invoiceDate < 365 ∧ confirmed)
then □ True
else

in

(cid:32)

provideDocuments ⊲⊳ companyConfirm ▶
𝜆 ⟨⟨invoiceAmount, invoiceDate⟩ , confirmed⟩ .
officerApprove invoiceDate today confirmed ▶ 𝜆 approved.
let subsidyAmount = if approved
then min 600 (invoiceAmount / 10) else 0 in
□ ⟨subsidyAmount, approved, confirmed, invoiceDate, today⟩

1

2

3

4

5

6

7

8

9

10

11

12

13

Listing 4: Subsidy request and approval workflow at the
Dutch tax office.

Listing 4 provides the code for a small example task, implement-
ing the process of applying for a tax subsidy. This example was
inspired by a collaboration with the Dutch Tax office. The user gets
asked to provide documents to back up their tax subsidy request
for solar panel installation (line 2). The installation company has to
confirm that they installed the panels (line 3), which can be done in
parallel (line 8). Finally, a tax officer can either approve or deny the
request (line 4), depending on certain conditions (line 5). After the
task has been completed, the subsidy amount is being calculated
(line 12), and the details are returned in a view (line 13).

For this task, symbolic execution allowed the authors to prove
correctness properties over the code, such as functional correctness.
In Section 4.4 we will take a look at generating a UI using the
framework presented in the coming section.

3 TOPHAT UI FRAMEWORK
In this section we describe our prototype TOP UI framework, which
is a proof-of-concept and not a fully fledged TOP framework. Our
application supports TopHat tasks as mentioned in Section 2.3.
We limit ourselves to a select number of datatypes: only integers,
booleans, and strings are supported. Advanced framework features
such as multi-user support are out of scope as well. We will reflect
on this in Section 6. The framework is written in Haskell, and we
use the following extensions.

OverloadedLists to allow for a more convenient HashMap

notation.

OverloadedStrings to allow for a more convenient way of

using Text.

PackageImport and NoImplicitPrelude to deal with the fact

that TopHat defines its own Prelude.

All source code is published on GitHub3, along with the examples
described below.

Key to our approach is that we leave the task specification of
TopHat untouched. This preserves the nice formal properties for
which TopHat has been developed in the first place. The proto-
type UI framework completely relies on the TopHat semantics for
handling input and rewriting tasks. The responsibility of the UI

2https://gitlab.com/clean-and-itasks/itasks-sdk/-/blob/master/Libraries/iTasks/WF/
Combinators/Core.icl

3https://github.com/mark-gerarts/ou-afstuderen-artefact

3

necessary. In this case, the user resets the application, which results
in the backend resetting back to the initial task.

The frontend is written in PureScript and the backend in Haskell.
We choose JSON as data interchange format, because JSON allows
custom data structures, it is easy to use, and both backend and
frontend support JSON out-of-the-box.

3.2 Backend
The backend is written in Haskell, using Servant [21] as the web
server. It has three main responsibilities, which is reflected in its
module structure, shown in Figure 2:

(1) The Application module loads the application, defines the

web server and configures the handlers.

(2) The Communication module handles JSON conversion, both
encoding tasks to their JSON representation and decoding
user input.

(3) The Visualize module is intended for the end user. It exposes
functions to start the framework, which is demonstrated in
Listing 5.

1 import Task ( Task , enter , view , ( > >?) )
2 import Visualize ( visualizeTask )
3
4 main :: IO ()
5 main = visualizeTask greet
6
7 greet :: Task h String
8 greet = enter >>? \ result -> view (" Hello " ++ result )

Listing 5: Starting the framework (Haskell)

Application module. We create an abstract web application (WAI-
application) in the Application module (see the application func-
tion in Listing 6). We define the endpoints, the request and the
response formats. For example, see the TaskAPI in Listing 6. The
server function provides handlers to serve the initial task, to han-
dle interaction with the frontend and to perform a reset. The remain-
der of the module consists of functions that expose functionality of
TopHat: initializing tasks, deconstructing tasks in a representation
that can be sent to the frontend, and interacting with tasks. We
have only added key signatures to Listing 6.

4

Figure 2: Architecture. Each box represents a main module.

Figure 3: Communication between frontend and backend.
Sequence diagram that displays requests (solid arrows) and
responses (dashed arrows). update value and reset are user
actions. Task and Input are JSON objects.

framework is to render the task in a web browser, and hand off
input that comes in from the user to the TopHat semantics.

The prototype framework is architecturally separated in two
parts: the backend and the frontend. Figure 2 shows the main mod-
ules of each part. The backend is responsible for initializing tasks
and handling communication with TopHat. The frontend renders
tasks and allows the user to interact with them. After a compara-
tive study of existing web server and UI frameworks [11], we have
selected Servant [21] as our webserver and Halogen [6] for the UI.
Other options are discussed in the Section 5. Section 3.1 illustrates
the communication between frontend and backend. Section 3.2 ex-
plains the working of the backend and the frontend is discussed in
Section 3.3.

3.1 Communication between backend and

frontend

Figure 3 shows the communication between frontend and back-
end. The frontend first requests the initial task, which the backend
returns using a JSON representation of this task. A user can now
interact with the system. In this example, the user updates a value.
The frontend sends the input as JSON to the backend, and the back-
end responds with the updated task. This step can be repeated as

{ currentTask :: TVar ( Task RealWorld t) ,

initialised :: Bool ,
originalTask :: Task RealWorld t

1 module Application ( application , State (..) ) where
2
3 data State h t = State
4
5
6
7
8
9 type TaskAPI =
10
11
12

" initial - task " :> Get '[ JSON ] TaskDescription
: <| > " interact "

:> ReqBody '[ JSON ] JsonInput :> Post '[ JSON ]

}

TaskDescription

: <| > " reset " :> Get '[ JSON ] TaskDescription

13
14
15 type StaticAPI = Get '[ HTML ] RawHtml : <| > Raw
16 type API = TaskAPI : <| > StaticAPI
17
18 interactIO :: Input Concrete -> Task RealWorld a -> IO ( Task

RealWorld a)

19 initialiseIO :: Task RealWorld a -> IO ( Task RealWorld a)
20 describeIO :: Task RealWorld a -> IO TaskDescription
21
22 server :: ToJSON t => State h t -> ServerT API ( AppM h t)
23
24 application :: ToJSON t => State h t -> Application

Listing 6: Application module (Haskell)

Communication module. In Listing 7 we show the core of the com-
munication module. We introduce a new datatype, TaskDescription,
that holds all data we need to render a task: the task itself (JsonTask)
and its possible inputs (InputDescription), along with the describe
function that extracts this data from a TopHat task. User input,
which is sent back and forth from the client to the server, is defined
in JsonInput.

1 module Communication ( JsonTask (..) , TaskDescription (..) ,

describe ) where

2
3 type JsonTask = Value
4
5 type InputDescriptions = List ( Input Abstract )
6
7 data TaskDescription where
8

TaskDescription :: JsonTask -> InputDescriptions ->

TaskDescription

9
10 instance ToJSON JsonTask
11
12 describe :: Members '[ Alloc h , Read h ] r = > Task h t -> Sem r

TaskDescription

13
14 data JsonInput where
15
16
17 instance FromJSON JsonInput

JsonInput :: Input Concrete -> JsonInput

Listing 7: Communication module (Haskell)

1 module Visualize ( visualizeTask , visualizeTaskDevel ) where
2
3 initApp :: ToJSON t => Task RealWorld t -> IO Application
4
5 visualizeTaskDevel :: ToJSON t => Task RealWorld t -> IO ()
6
7 visualizeTask :: ToJSON t => Task RealWorld t -> IO ()

Listing 8: Visualize module (Haskell)

3.3 Frontend
The frontend renders the UI and provides a way for the user to
interact with it. The code is written in PureScript using the Halogen
framework. The frontend consists of three main modules and some
auxiliary modules. We explain the main modules:

(1) The Client module is the communication layer with the
backend. It defines functions which send requests to the
backend and handles the responses.

(2) The Task module handles JSON encoding and decoding of

our domain’s datatypes (tasks and user input).

(3) The TaskLoader module is the starting point of Halogen and

is responsible for rendering the UI.

Client module. The client module is responsible for the com-
munication between frontend and backend. The backend sends
a response in JSON that consists of two parts: a Task and a de-
scription of possible inputs. We decode this JSON object into a
TaskResponse. See Listing 9.

1 module App . Client ( ApiError , TaskResponse (..) , getInitialTask ,

interact , reset ) where

= TaskResponse Task ( Array InputDescription )

2
3 data TaskResponse
4
5
6 instance decodeJsonTaskResponse :: DecodeJson TaskResponse
7
8 getInitialTask :: Aff ( Either ApiError TaskResponse )
9
10 interact :: Input -> Aff ( Either ApiError TaskResponse )
11
12 reset :: Aff ( Either ApiError TaskResponse )

Listing 9: Client module (PureScript)

Visualize module. In Listing 8 we show the signatures of the
visualize module. We use this module to run the web server in pro-
duction (visualizeTask) or development (visualizeTaskDevel)
mode. We differentiate between these modes because we imple-
mented live code reloading for development, which requires a bit of
additional setup. Both visualizeTask and visualizeTaskDevel
use the initApp function. InitApp on its turn invokes the application-
function of the Application Module.

5

Task module. In the Client module we defined a TaskResponse.
This TaskResponse consists of two parts: a Task and an array of
InputDescription. In the Task module we define the decoding
process of Task and InputDescription. See Listing 10.

= Edit Name Editor
| Select Name Task Labels
| Pair Task Task
| Choose Task Task
| Step Task
| Trans Task
| Done
| Fail

1 module App . Task where
2
3 data Task
4
5
6
7
8
9
10
11
12
13 instance showTask :: Show Task
14
15 instance decodeJsonTask :: DecodeJson Task
16
17 data Input
18
19
20
21 instance showInput :: Show Input
22
23 instance encodeInput :: EncodeJson Input
24
25 data InputDescription
26
27
28
29 instance showInputDescription :: Show InputDescription
30
31 instance decodeJsonInputDescription :: DecodeJson InputDescription
32

= InsertDescription Int String
| OptionDescription Int String

= Insert Int Value
| Decide Int String

Listing 10: Task module (PureScript)

TaskLoader module. The TaskLoader module renders the user
interface (the render function in Listing 11). The module also con-
tains logic to handle events (handleAction), for example when a
user modifies a value. Finally, the taskLoader function (see Listing
11) initializes the component.

1 module Component . TaskLoader ( taskLoader ) where
2
3 taskLoader :: forall query input output m . MonadAff m = > H.

Component query input output m

4
5 handleAction :: forall output m . MonadAff m => Action -> H.

HalogenM State Action Slots output m Unit

6
7 render :: forall m . MonadAff m => State -> HH . ComponentHTML Action

Slots m

Listing 11: TaskLoader module (PureScript)

4 EXAMPLES
We present a few examples to demonstrate how our framework han-
dles TopHat programs. The candy vending machine combines the
Select and View editor, the Step Task, and the Pair Task to construct
a candy machine (Section 4.1). The calorie calculator demonstrates
a real-world application of our framework (Section 4.2). The chat
sessions demonstrates the use of shared data stores (Section 4.3),
and finally Section 4.4 describes UI generation for the tax example
from Section 2.4

4.1 Candy vending machine
The candy machine allows a user to choose a chocolate bar and,
after the bill is paid, the candy machine returns the bar. The candy
machine combines the Edit, Pair and Step task. We have defined

6

different Edit tasks with View and Select editors. The implementa-
tion of the initial task is given in Listing 12. The Pair combinator is
denoted with the operator ><.

(1) After the candy machine is started, the machine displays
some introductory text and a selection of chocolate bars (see
Figure 4a). This is done using a Pair Task that consists of
two Edit tasks: an Edit task with a View editor and an Edit
Task with a Select editor.

(2) Select a chocolate bar. After choosing a bar, the candy ma-
chine displays the price of the bar (see Figure 4b). This is
done using another Pair Task that consists of an Edit task
with a View editor (“you need to pay:”) and a Step Task. The
Step task consists of two tasks: first a view editor is shown
(with the price) and after the step, a select editor is rendered
(see Figure 4c).

(3) Press the continue button.
(4) Insert coins until you have paid the bill (see Figure 4c). The

application alternates a view and a select editor.

(5) The application shows a view editor to indicate to the user

that the bill is paid (see Figure 4d).

( name , view " You need to pay :" >< ( view price >>? payCandy ))

]
where

entry :: Text -> Int -> ( Label , Task h ( Text , Text ))
entry name price =

bars . Pure Chocolate : It 's all in the name . IO
Chocolate : Chocolate with unpredictable side effects .
Sem Chocolate : don ' t try to understand , just eat
it !" >< select candyOptions

[ entry " Pure Chocolate " 8,
entry " IO Chocolate " 7,
entry " Sem Chocolate " 9

1 data CandyMachineMood = Fair | Evil
2
3 startCandyMachine :: ( Task h ( Text , ( Text , Text )))
4 startCandyMachine = view " We offer you three chocolate
5
6
7
8
9
10 candyOptions :: HashMap Label ( Task h ( Text , Text ))
11 candyOptions =
12
13
14
15
16
17
18
19
20
21 payCandy :: Int -> Task h Text
22 payCandy bill =
23
24
25
26
27
28
29 payCoin :: Int -> HashMap Label ( Task h Int )
30 payCoin bill =
31
32
33
34
35
36
37
38
39 dispenseCandy :: CandyMachineMood -> Task h Text
40 dispenseCandy Fair =
41
42 dispenseCandy Evil =
43

case compare billLeft 0 of
EQ -> dispenseCandy Fair
LT -> dispenseCandy Evil
GT -> payCandy billLeft

coinSize :: Int -> ( Label , Task h Int )
coinSize size = ( display size , view ( bill - size ))

view " You have paid . Here is your candy . Enjoy it !"

[ coinSize 5,
coinSize 2,
coinSize 1

select ( payCoin bill ) >>? \ billLeft ->

]
where

your candy ."

view " You have paid too much ! Sorry , no change , but here is

Listing 12: Initial Task of the candy vending machine
(Haskell)

(a) Step 1: Select a chocolate bar

(b) Step 2: Price of the selected candy is shown to the user

(c) Step 3: Insert a coin

(d) Step 4: You have paid the bill

Figure 4: Different stages of the candy vending machine

4.2 Calorie calculator
To demonstrate a more real-world application that incorporates
most task types, we created a calorie calculator. This application
calculates how many calories a person should eat per day in order to
maintain their weight. The calculation depends on several factors,
such as age, weight, and activity level. The application can be broken
down in several steps to prompt the user for input, and finally
calculating the result. The implementation of the task is given in
Listing 13.

(1) When started, the application presents the user with some
information about the calculation using a View editor.
(2) After pressing continue, the user is prompted to enter the
required data in different steps: height, weight, and age using
Enter editors, and gender and activity level using Select
editors. Each prompt is wrapped in a Pair task with a View
editor on the left side to act as the label. Such a prompt is
shown in Figure 5.

(3) In the last step the result is displayed using a View editor.

4.3 Chat session
This example uses shared data stores to model a chat session be-
tween two users, as displayed in Figure 6. Each user can write
messages to the chat history on the left hand side using their re-
spective inputs on the right hand side.

The implementation for this example is given in Listing 14. The
function share creates a data store that can be accessed by multiple
tasks, in this case the two chat tasks. The <<= operator is used to
transform the contents of the shared data store.

7

1 data Gender = Male | Female
2
3 data ActivityLevel = Sedentary | Low | Active | VeryActive
4
5 type Height = Int
6
7 type Weight = Int
8
9 type Age = Int
10
11 calculateCaloriesTask :: Task h Text
12 calculateCaloriesTask =
13
14
15
16
17
18
19

(_ , height ) <- promptHeight
(_ , weight ) <- promptWeight
(_ , age ) <- promptAge
(_ , gender ) <- promptGender
(_ , activityLevel ) <- promptActivityLevel
let calories = calculateCalories gender activityLevel

introduction >>? \_ -> do

height weight age

]

)

>< select

[ " Male " ~> Done Male ,

" Female " ~> Done Female

view " Select your gender :"

<> display calories
<> " calories per day ."

view
( " Your resting metabolic rate is : "

[ " This tool estimates your resting metabolic rate ," ,
calories you have to consume " ,

"i.e. the number of
" per day to maintain your weight ." ,
" Press \" Continue \" to start "

20
21
22
23
24
25
26 introduction :: Task h Text
27 introduction = view <| unlines
28
29
30
31
32
33
34 promptGender :: Task h ( Text , Gender )
35 promptGender =
36
37
38
39
40
41
42 promptHeight :: Task h ( Text , Height )
43 promptHeight = view " Enter your height in cm :" >< enter
44
45 promptWeight :: Task h ( Text , Weight )
46 promptWeight = view " Enter your weight in kg :" >< enter
47
48 promptAge :: Task h ( Text , Age )
49 promptAge = view " Enter your age :" >< enter
50
51 promptActivityLevel :: Task h ( Text , ActivityLevel )
52 promptActivityLevel =
53
54
55
56
57
58
59
60
61 -- We omit the actual calculation here since it is a bit lengthy .
62 calculateCalories :: Gender -> ActivityLevel -> Height -> Weight

" Low active " ~> Done Low ,
" Active " ~> Done Active ,
" Very Active " ~> Done VeryActive

view " What is your activity level ?"

[ " Sedentary " ~> Done Sedentary ,

>< select

]

]

-> Age -> Int

63 calculateCalories gender al h w age = ...

Listing 13: Task of the calorie calculator (Haskell)

Figure 5: Prompting the user to enter their height

Figure 6: A chat session using shared data stores.

(a) Step 1: The citizen enters the request info on the left, the installation com-
pany confirms on the right

history <- share ""
watch history ><

( chat " Tim " history >< chat " Nico " history )

where
chat :: Text -> Store h Text -> Task h ()
chat name history = repeat <|

1 chatSession :: Reflect h = > Task h ( Text , (() , () ))
2 chatSession = do
3
4
5
6
7
8
9
10
11
12
13
14
15
16

history <<= \h ->
( if h == " " then h else h ++ "\n")

enter >>* [ " Send " ~ > append history name ]

append :: Store h Text -> Text -> Text -> Task h ()
append history name msg = do

++ name ++ ": '"
++ msg ++ " '"

Listing 14: A chat Session using shared data stores (Haskell)

4.4 Tax example
For our final example, we revisit the tax program from Section 2.4.

officerApprove :: Date -> Date -> Bool -> Task h Bool
officerApprove invoiceDate date confirmed =

today = 100

let today :: Date

in ( provideDocuments >< companyConfirm )

view ( date - invoiceDate < 365 && confirmed )

companyConfirm :: Task h Bool
companyConfirm = enter

provideDocuments :: Task h ( Amount , Date )
provideDocuments = enter >< enter

1 tax :: Task h (((( Amount , Bool ) , Bool ) , Date ) , Date )
2 tax =
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

officerApprove invoiceDate today confirmed

let subsidyAmount =

> >? \ approved ->

if approved

<| unlines

" Approved : " ++ display approved ,
" Confirmed : " ++ display confirmed ,
" Invoice date : " ++ display invoiceDate ,
" Today : " ++ display today

then min 600 ( invoiceAmount `div ` 10)
else 0
in view

> >? \(( invoiceAmount , invoiceDate ) , confirmed ) ->

]

[ " Subsidy amount : " ++ display subsidyAmount ,

Listing 15: Tax example in Haskell

Listing 15 gives the Haskell code that implements the task. Com-
pared to the original definition as given in Listing 4, the task is
nearly identical. The only change made is to the final line, where
we have opted for a different presentation of the final result, for
simplicity’s sake.

Figure 7 lists the different stages of the UI for the tax subsidy
task. First, the user requesting the subsidy can enter in information
(first two tasks), while the company can confirm or deny. Then,

8

(b) Step 2: The tax office con-
firms or denies the request

(c) Step 3: The final out-
come of the request is
displayed

Figure 7: Different stages of the tax subsidy application

the tax officer can verify if the conditions are met, and approve the
request. Finally, the outcome is shown.

Since we did not have to modify the task at all, besides a minor
presentation detail, this task can still be proven correct using sym-
bolic execution. This example clearly illustrates the advantage of
TopHat with a UI over the current state-of-the-art in the form of
iTasks.

5 RELATED WORK
Section 2 presentend related work on TOP and iTasks. In this sec-
tion, we will briefly discuss Functional reactive programming as
an alternative to TOP, as well as alternatives for the UI framework
and web server we have used during the development of the UI for
TopHat.

5.1 Functional Reactive Programming
Functional Reactive programming (FRP) is another approach to UI
development using functional programming. FRP is a programming
paradigm centered around interactive event-based applications. It
has implementations in multiple programming languages, such as
Haskell and JavaScript [4].

FRP consists of two main concepts: behaviors and events. A be-
havior consists of a value and can be mapped to output, for example
a label. Behaviors can depend on other behaviors, so a change in a
behavior can propagate through a network of dependent behaviors.
An event only occurs at a certain point in time and contains a value.
Input is mapped to events, for example the pressing of a key or
the position of the mouse cursor. Events can trigger changes in
behaviors.

It is worth noting that, while they share some similarities, FRP
and TOP are conceptually different. FRP is a paradigm for reac-
tive programming, whereas TOP is a way to model collaboration
between users.

5.2 User Interface frameworks
We build upon the Halogen framework to create our prototype,
but many other UI frameworks exist in the domain of functional
programming. We discuss three of these briefly below.

Elm [9] refers to both Elm, a functional programming language
that compiles to JavasScript [8], and TEA [10], a programming
pattern that emerged from it. Elm’s ecosystem consists of a large
number of available libraries that help in creating web applications.
Miso [12] is a Haskell front-end framework inspired by Elm and
Redux. It relies on GHCJS [15], a Haskell-to-JavaScript compiler
based on GHC.

Reflex [29] is an FRP framework written in Haskell with sup-
port for a variety of platforms, including the web, desktop, and
mobile. Reflex applications are modular, which makes growing and
refactoring an application efficient and swift.

We have selected PureScript and Halogen because it is a power-
ful functional programming language that fits our problem domain.
Halogen provides an excellent developer experience, has a compo-
nent based architecture and builds upon PureScript’s power and
expressiveness.

5.3 Web servers
We have opted for Servant as our web server. Servant provides com-
binators to implement our features, which makes coding less error
prone and time-consuming. Servant is up-to-date, well-maintained,
well documented and it is easy to get a working prototype. Below
we discuss Yesod and Warp as possible alternatives for the server
used in our implementation.

The Yesod Web Framework [23] is a Haskell web framework
that allows for rapid development of type-safe, RESTful and high
performance web applications [24]. The Yesod Web Framework adds
the strengths of Haskell (like type safety) to the web. Especially on
the boundaries of Yesod and the world, for example a user enters
input or persistent data is loaded, Yesod adds mechanisms to define
the expected types [22]. We found that developing a prototype based
on Yesod is more difficult than developing a prototype based Servant.
We also found that the Yesod Web Framework is too extensive for
our purposes [11].

The Warp web server is a light-weight web server that supports
the Web Application Interface (WAI) [25]. It is meant to be easy
to use and provide easy composition of web services. Because of
the design choices to achieve this, the code of a Warp prototype is
low-level. This means that implementing all features in this way
will be error prone and time-consuming. Therefore, we have chosen
Servant. However, Servant also uses Warp as its web server [11].

6 CONCLUSION
We have demonstrated TopHat UI, a proof-of-concept framework
that implements a GUI for Tophat programs. None of the advanced
Clean features used by iTasks were required to do so, as expected.
On top of that, we were able to leave the TopHat language un-
touched, preserving its formal properties.

Our framework implements all basic requirements for a TOP
framework, by supporting tasks, shared data stores, combinators
and generics. The source code for our framework is available online,

and can thus be leveraged by developers and researchers to advance
the field of Task-Oriented Programming.

6.1 Future work
As mentioned in Section 3, TOP features such as multi-user sup-
port and richer datatypes are considered future work. We see no
technical or formal reason prohibiting them from being included
in future versions of the UI framework. As with iTasks, the ren-
dering of values, and editors of values, is generic in the type of
the value. Adding support for more complex datatypes would just
mean making instances for them for viewing and editing them,
similar to how this is done in iTasks. As for multi-user support, this
is a limitation in the current version of TopHat. Its developers are
already working on adding multi-user support. Once this feature
is released, we see no fundamental limitations in supporting this
in the UI. The server framework used in the current implementa-
tion, Servant, already has extensive support for user authentication,
which could be leveraged 4.

REFERENCES
[1] Peter Achten, Pieter Koopman, and Rinus Plasmeijer. 2015. An Introduction to
Task Oriented Programming. Springer International Publishing, Cham, 187–245.
[2] Peter Achten, Jurriën Stutterheim, László Domoszlai, and Rinus Plasmeijer. 2014.
Task Oriented Programming with Purely Compositional Interactive Scalable
Vector Graphics. ACM, 1–13.

[3] Peter Achten, Jurriën Stutterheim, Bas Lijnse, and Rinus Plasmeijer. 2016. Towards
the Layout of Things. ACM, 1–13. https://dl-acm-org.ezproxy.elib11.ub.unimaas.
nl/doi/pdf/10.1145/3064899.3064905

[4] Engineer Bainomugisha, Andoni Carreton, Tom Cutsem, Stijn Mostinckx, and
Wolfgang Meuter. 2013. A survey on Reactive Programming. ACM computing
surveys 45, 4 (2013), 1–34.

[5] TH Brus, Marko CJD van Eekelen, MO Van Leer, and Marinus J Plasmeijer. 1987.
Clean—A Language for Functional Graph Rewriting. In Conference on Functional
Programming Languages and Computer Architecture. Springer, 364–384.

[6] Burgess and Honeyman et al. 2021. Halogen. https://github.com/purescript-

halogen/purescript-halogen. Version 6.1.2.

[7] Clean 2021. Clean. https://clean.cs.ru.nl. Version 3.0.
[8] Czaplicki. 2012. Elm. https://elm-lang.org. Version 0.19.1.
[9] Czaplicki. 2012. Elm: Concurrent frp for functional guis. Senior thesis, Harvard

University 30 (2012).

[10] Elm Guide 2021. The Elm Architecture. https://guide.elm-lang.org/architecture.

Accessed at 2021-07-01.

[11] Mark Gerarts and Marc de Hoog. 2021. Creating Interactive Visualizations of

TopHat Programs.

[12] Johnson. 2020. Miso. https://haskell-miso.org. Version 1.7.1.
[13] Pieter W. M. Koopman, Rinus Plasmeijer, and Peter Achten. 2008. An Executable
and Testable Semantics for iTasks. In Implementation and Application of Functional
Languages - 20th International Symposium, IFL 2008, Hatfield, UK, September 10-12,
2008. Revised Selected Papers. 212–232. https://doi.org/10.1007/978-3-642-24452-
0_12

[14] Bas Lijnse, Jan Martin Jansen, Rinus Plasmeijer, et al. 2012. Incidone: A Task-
Oriented Incident Coordination Tool. In Proceedings of the 9th International
Conference on Information Systems for Crisis Response and Management, ISCRAM,
Vol. 12.

[15] Mackenzie et al. 2021. GHCJS. https://github.com/ghcjs/ghcjs. Version 8.6.
[16] Nico Naus and Tim Steenvoorden. 2020. Generating Next Step Hints for Task Ori-
ented Programs Using Symbolic Execution. In Trends in Functional Programming
- 21st International Symposium, TFP 2020, Krakow, Poland, February 13-14, 2020,
Revised Selected Papers. 47–68. https://doi.org/10.1007/978-3-030-57761-2_3
[17] Nico Naus, Tim Steenvoorden, and Markus Klinik. 2019. A symbolic execution
semantics for TopHat. In IFL ’19: Implementation and Application of Functional
Languages, Singapore, September 25-27, 2019. 1:1–1:11. https://doi.org/10.1145/
3412932.3412933

[18] Arjan Oortgiese, John van Groningen, Peter Achten, and Rinus Plasmeijer. 2017.
A Distributed Dynamic Architecture for Task Oriented Programming. ACM,
1–12. https://dl-acm-org.ezproxy.elib11.ub.unimaas.nl/doi/pdf/10.1145/3205368.
3205375

4https://docs.servant.dev/en/stable/tutorial/Authentication.html

9

[19] Rinus Plasmeijer, Peter Achten, and Pieter Koopman. 2007. iTasks: Executable
Specifications of Interactive Work Flow Systems for the Web. ACM SIGPLAN
Notices 42, 9 (2007), 141–152.

[20] Rinus Plasmeijer, Bas Lijnse, Steffen Michels, Peter Achten, and Pieter Koopman.
2012. Task-Oriented Programming in a Pure Functional Language. ACM, 195–
206.

[21] Servant Contributors. 2021. Servant – A Type-Level Web DSL. https://docs.

servant.dev/en/stable/index.html. Version 0.18.3.

[22] Snoyman. 2012. Developing Web Applications with Haskell and Yesod. O’Reilly

Media, Inc.

[23] Snoyman. 2020. The Abominable Snoyman). https://www.snoyman.com/.
[24] Snoyman. 2020. Yesod Web Framework. https://www.yesodweb.com/.
[25] M. Snoyman. 2011. Warp: A Haskell Web Server. IEEE internet computing 15, 3

(2011), 81–85.

[26] Tim Steenvoorden, Nico Naus, and Markus Klinik. 2019. TopHat: A formal
foundation for task-oriented programming. ACM, 1–13. https://dl-acm-org.
ezproxy.elib11.ub.unimaas.nl/doi/10.1145/3354166.3354182

[27] J. Stutterheim, P. Achten, R. Plasmeijer, V. Zsók, Z. Porkoláb, and Z. Horváth.
2019. Static and Dynamic Visualisations of Monadic Programs. Lecture notes in
computer science (2019), 341–379.

[28] Jurriën Stutterheim, Rinus Plasmeijer, and Peter Achten. 2014. Tonic: An In-
frastructure to Graphically Represent the Definition and Behaviour of Tasks. In
International Symposium on Trends in Functional Programming. Springer, 122–141.

[29] Trinkle et al. 2020. Reflex. https://reflex-frp.org/. Version 0.8.0.0.
[30] Martijn Vervoort and Marinus J. Plasmeijer. 2002. Lazy Dynamic Input/Output in
the Lazy Functional Language Clean. In Implementation of Functional Languages,
14th International Workshop, IFL 2002, Madrid, Spain, September 16-18, 2002, Revised
Selected Papers. 101–117. https://doi.org/10.1007/3-540-44854-3_7

10

