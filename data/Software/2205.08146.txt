2
2
0
2

y
a
M
7
1

]

Y
S
.
s
s
e
e
[

1
v
6
4
1
8
0
.
5
0
2
2
:
v
i
X
r
a

Formal veriﬁcation of an industrial UML-like
model using mCRL2 (extended version)

Anna Stramaglia and Jeroen J.A. Keiren[0000−0002−5772−9527]

Eindhoven University of Technology, the Netherlands
{a.stramaglia, j.j.a.keiren}@tue.nl

Abstract. Low-code development platforms are gaining popularity. Es-
sentially, such platforms allow to shift from coding to graphical model-
ing, helping to improve quality and reduce development time. The Cordis
SUITE is a low-code development platform that adopts the Uniﬁed Mod-
eling Language (UML) to design complex machine-control applications.
In this paper we introduce Cordis models and their semantics. To enable
formal veriﬁcation, we deﬁne an automatic translation of Cordis mod-
els to the process algebraic speciﬁcation language mCRL2. As a proof of
concept, we describe requirements of the control software of an industrial
cylinder model developed by Cordis, and show how these can be veriﬁed
using model checking. We show that our veriﬁcation approach is eﬀective
to uncover subtle issues in the industrial model and its implementation.

1

Introduction

Abstract models are commonly used during the design phase of software. For
example, class diagrams are used to describe the structure of a software sys-
tem, and behavioral models describe the possible executions. Model checking
can be used to verify that such a behavioral model satisﬁes its requirements.
While model checking is a promising technique, its industrial applications are
still limited. There are several reasons for this, of which we name two examples
here. First, it is considered tedious to create a detailed behavioral model prior to
implementing the system. Second, the available model checking tools primarily
use low-level, academic languages that require speciﬁc expertise not typically
acquired by engineers in industry.

Low-code development platforms (LCDPs) [21] are gaining popularity. Such
platforms focus on increasing the level of abstraction of software development,
shifting from coding to graphical modeling. Executable code is typically gener-
ated from low-code models. LCDPs allow us to address both issues described
above. First of all, the detailed behavioral model is now created during imple-
mentation of the the system: the model is the artifact from which the executable
code is automatically generated. Second, provided that the semantics of the
models are well-understood, the models are suﬃciently detailed that they can be
automatically translated to the input languages used by state-of-the-art model
checkers.

 
 
 
 
 
 
2

Anna Stramaglia and Jeroen J.A. Keiren

The Cordis SUITE1 is a complete LCDP for machine-control applications,
based on graphic Model-Driven Software Engineering, describing system struc-
ture and behavior in UML diagrams [17]. The development environment in the
Cordis SUITE is the Cordis Modeler, which uses Altova UModel2 as a front-end
for drawing the models. Cordis models use extensions of UML class diagrams for
describing the static structure and UML state machine diagrams for the behav-
ior. The features used in Cordis models are fairly rich: besides the standard UML
models, it comprises several Cordis speciﬁc extensions and a large fragment of
the Structured Text language [13]. Ultimately, using the Cordis SUITE, it is pos-
sible to generate source code for Programmable Logic Controllers (PLCs) or the
.NET platform directly from the Cordis models. Hence, the implementation of
Cordis models is consistent, in terms of execution, with their design. Cordis, the
company developing this LCDP, has shown an interest in extending the Cordis
SUITE with model checking capabilities.

Our contributions in this paper are as follows. To enable model checking
of Cordis models, we ﬁrst describe their structure and semantics. We describe
an automated translation from Cordis models to the mCRL2 speciﬁcation lan-
guage [10]. The use of mCRL2 is motivated by the availability of its associated
tool set with powerful veriﬁcation tools such as simulation, explicit model check-
ing and the veriﬁcation of modal µ-calculus formulae [4]. For veriﬁcation, we use
a ﬁrst-order extension of the modal µ-calculus [9]. We illustrate the feasibility of
modeling and veriﬁcation of Cordis models using a pneumatic cylinder. We spec-
ify, both informally and formally, two typical requirements of the cylinder, and
verify whether its model satisﬁes these requirements. One of the requirements is
not satisﬁed by the initial model. Using mCRL2 and its powerful counterexam-
ples, we analyze why this requirement is not satisﬁed. The analysis uncovers and
conﬁrms a subtle issue in the cylinder model, that can, indeed, be reproduced in
the PLC code of the implementation. We propose a ﬁx that has been integrated
into the model distributed by Cordis.

Related work. A large amount of work has been done in the application of
formal veriﬁcation to industrial domains. Most of this work focuses on speciﬁc
domains, such as railway infrastructure management [2,11,22] and medical appli-
cations [14,18,23]. More closely related to this paper are works on the modeling
and veriﬁcation of control software. For instance, CERN’s FSM language [12]
uses a strict hierarchical architecture of ﬁnite state machines tailored towards a
speciﬁc machine control application. The OIL language, developed and used by
Canon Production Printing, has a strong focus on separation of concerns during
the development [3].

Modeling languages such as SysML and UML can be used to model systems
that come from any domain. The veriﬁcation of these languages, in particu-
lar their state machine diagrams, has been studied extensively, see for exam-
ple [2,7,15,16,20,24,25]. Of these, the work by Bouwman et al. [2] is closest to

1 https://www.cordis-suite.com
2 https://www.altova.com

Title Suppressed Due to Excessive Length

3

ours. Their focus is on the veriﬁcation of SysML state machines in the railway
industrial domain. Like in our work, they describe a formal semantics for state
machines, and implement a translation to mCRL2 to allow formal veriﬁcation.
The semantics and execution model in that work focuses on distributed execu-
tion of state machines that communicate via queues, whereas our work focuses
on a strictly sequential execution where communication takes place via shared
variables. Lyazidi and Mouline in [16], deﬁne a transformation from UML state
machine diagrams to Petri nets. Santos et al. in [24], present an approach to
transform various UML behavioral diagrams into a single transition system for
the model checker NuSMV [6], in order to support model checking.

Outline. In Section 2 we explain the structure and semantics of Cordis models.
In Section 3 we present the cylinder model. In Section 4 we describe the mCRL2
speciﬁcation of Cordis models, and the requirements veriﬁed against the cylinder
model, and the results obtained from the veriﬁcation of the cylinder model.
Discussion and conclusions are presented in Section 5 and Section 6, respectively.

2 Cordis models

Cordis models are developed, tested and simulated in the Cordis SUITE. In this
section we give a brief introduction of the Cordis SUITE and subsequently we
describe the structure and semantics of Cordis models.

2.1 Cordis SUITE

The Cordis SUITE is a collection of integrated tools for developing, testing and
deploying system control software, with a particular focus on machine control.
The main components and their connections are shown in Figure 1.
The Cordis Modeler is an LCDP for creat-
ing machine-control applications. It uses
an extension of the Uniﬁed Modelling
Language (UML) such that every Cordis
model describes the structure and behav-
ior of a machine. In particular, the mod-
eler uses class diagrams for the static
structure, and state machine diagrams for
the behavior. Additionally, it can check
for design errors, and generate source
code for Programmable Logic Controllers
(PLCs) or the .NET platform.
The generated code can subsequently be compiled and executed on the target
platform. The Cordis Machine Control Server (MCS) loads model information
from the modeler, and connects to the PLC in order to exchange state informa-
tion and data with the running system. The Cordis Machine Control Dashboard
(MCD) is a Human-Machine Interface used to monitor the live system data and

Fig. 1: Main components of Cordis
SUITE and their connections.

MCSMCDMODELERPLC4

Anna Stramaglia and Jeroen J.A. Keiren

diagrams made available through the MCS, and to send inputs to the system.
In particular, the MCD shows live state machine diagrams when the PLC is
running, providing the user with real-time and historical information about the
execution of a state machine.

The Cordis SUITE’s core element is the Cordis Modeler, and the structure

and semantics of Cordis models is the focus of the following subsections.

2.2 Class diagrams

The static structure in a Cordis model is described using a class diagram. Classes
can be tagged with stereotypes <<Machine>>, denoting the machine that is con-
trolled by the system, and <<MachinePart>>, denoting components of the sys-
tem. A class has properties and operations. Class properties are the variables
stored in the class and are tagged with Cordis-speciﬁc stereotypes that describe
their role in the system. Stereotypes <<InputSignal>> and <<OutputSignal>>
are used to deﬁne shared variables that are used to communicate between ob-
jects within the model; <<Input>> and <<Output>> describe variables that are
used to interface with the environment, typically the hardware. Variables that
are only used from within the object have stereotype <<Var>>. Properties of
type <<Setting>> can be conﬁgured from the MCD; these are essentially con-
ﬁguration parameters of the system that are constant throughout the standard
execution. The system can provide feedback to the user using <<Message>>
properties. Only properties with stereotype <<Observer>>, <<Setting>> and
<<Message>> are visible in the MCD. All class operations are commands which
are issued (asynchronously) to the class, either by the environment or another
component in the system. This is described by stereotype <<Cmd>>.

Fig. 2: Pneumatic cylinder [1]

Example 1. In this paper we consider the Cordis model of a pneumatic cylinder
to illustrate the syntax and semantics of Cordis models, as well as their veriﬁca-
tion. Pneumatic cylinders are commonly used in factory automation systems for
mechanisms such as clamping, ejecting, blocking, and lifting, and in industrial
processes for materials handling and packaging. A pneumatic cylinder, see Fig-
ure 2, consists of a cylinder barrel, with a piston which moves back or forth. It is
powered using compressed air, whose ﬂow is controlled by electrically controlled
valves. The cylinder we consider in this paper moves the piston between the zero

Title Suppressed Due to Excessive Length

5

position and the end position, in which it is completely retracted or extended, re-
spectively. It is equipped with sensors, here ZeroPosSensor and EndPosSensor,
to detect the current position of the piston.

The cylinder is typically used as a machine part in a larger machine. For the
sake of simplicity, in this paper we consider the cylinder in isolation. Due to its
simplicity, its (trivial) class diagram consists of a single class, shown in Figure 3.

Fig. 3: Cylinder class

The cylinder has two inputs, iZeroPosSensor and iEndPosSensor that
detect whether the cylinder is at its zero or end position, respectively. It has
two outputs, oValveMoveToZeroPos and oValveMoveToEndPos that are used
to actuate the valves. Furthermore, it has a number of input signals, i.e., shared
variables that are written by other objects in the machine that uses the cylin-
der and that are read by the cylinder, and output signals, i.e., shared vari-
ables that are written by the cylinder, and used by other objects. Property
ToggleToZeroPosition is used internally to toggle the direction of movement

6

Anna Stramaglia and Jeroen J.A. Keiren

of the cylinder. The system also has a number of settings and messages that are
irrelevant to the veriﬁcation. We will ignore these in the rest of this paper.

The cylinder has ﬁve commands that can be used to control the cylinder.
The meaning of MOVE_TO_ZERO_POSITION, MOVE_TO_END_POSITION, TOGGLE,
and EmergencyStop are self-explanatory. Command CONDITIONING can be used
to force (re)initialization of the cylinder.

2.3 State machine diagrams

The behavior of an object is deﬁned using a hierarchy of state machine diagrams.
We ﬁrst describe the structure of such diagrams, and subsequently explain their
semantics.

State machine diagram structure Structurally, Cordis state machine dia-
grams are similar to those deﬁned in standard UML [17], but there are some
Cordis speciﬁc details.

At the highest level, a state machine diagram consists of top-level state ma-
chines. Each state machine diagram requires at least one top-level state machine.
A (top-level) state machine consists of a hierarchy of states and pseudo-states,
connected by transitions. States and pseudo-states capture the most commonly
used (pseudo-)state types described in the UML standard, e.g., simple states,
composite states, initial pseudo-states, ﬁnal states and choice nodes. A state
can contain entry and continuous behavior. A state can also be a reference to
a subdiagram, whose content can, essentially, be syntactically substituted in the
diagram that refers to it. If a state is a reference to a substatemachine, the sub-
statemachine that is referenced is executed separately from the statemachine
that references it; when a transition to a substatemachine is taken, control is
transferred to the substatemachine. So, the key diﬀerence between subdiagrams
and substatemachines is whether they are executed as part of the diagram that
references it (subdiagram) or not (substatemachine).

Transitions have a source and target state, and can optionally be labelled by
guards and actions. A guard is a Boolean condition that must be satisﬁed for
the condition to be enabled. An action typically represents a side eﬀect that is
executed upon taking the transition, e.g., updating the value of a class property.
For a transition without guard, the guard is assumed to be true if the source of
the transition is an initial state or an exit node, or the target of the transition
is a choice node. The guard of an unguarded transition whose source is a choice
node is treated as else, i.e., it is true only when the guards of all other transitions
of the same choice node are false. For all other transitions without guard, the
guard is assumed to be false.

Example 2. Consider the top-level statemachine Main of the cylinder from our
running example, shown in Figure 4. Its initial state is Disabled, indicated using
the initial pseudo-state •. State Disabled is a reference to a substatemachine.
This substatemachine has a number of states that are used to model diﬀerent

Title Suppressed Due to Excessive Length

7

Fig. 4: State machine Main.

ways out of the substatemachine (see Figure 9 for details), for instance, if the
substatemachine determines the cylinder is in its zero position it reaches state
CondInZero, and in state machine Main the transition to In_Zero_Pos is taken.
Most transitions have guards, e.g., Moving_To_Zero_Pos has a transition to
In_Zero_Pos with guard [State(Moving_To_Zero_Pos.FinalState)] which
only evaluates to true if substatemachine Moving_To_Zero_Pos is currently in
its ﬁnal state. Similarly, the guard [NOT InpSignal(iCompressedAirOk) OR
CmdChk(EmergencyStop)] is only satisﬁed if iCompressedAirOk is false, or
command EmergencyStop has been accepted by the cylinder.

Some behavior must be executed every time an object is allowed to execute a
step, regardless of its current states. This is modeled using pre- and poststates,
describing behavior that is executed before and after anything else in the object,
respectively. Pre- and poststates can either appear inside a state machine, or
at the top-level of the state machine diagram. A state machine diagram can
have more than one pre- and poststate, but the behavior of multiple pre- and
poststates is always combined into a single prestate and a single poststate by
taking the sequential composition of all pre- and poststates in a predeﬁned order.

Example 3. The cylinder model has a PostState that is shown in Figure 5. It
contains the code that is executed after all state machines in the cylinder have
executed one step. It updates the values of output signals oInZeroPosition,
oInEndPosition and oEnabled to reﬂect the current conﬁguration of the cylin-
der.

8

Anna Stramaglia and Jeroen J.A. Keiren

Fig. 5: Poststate of the cylinder

State machine execution Cordis models are executed using a cyclic execution
model. In every cycle all objects (i.e., machines and machine parts) take turns
executing in a predetermined order, following the hierarchical structure deﬁned
in the class diagram.

(a)

(b)

Fig. 6: Order of execution of (a) one object, and (b) a state machine within the object

The order of execution within an object is depicted as an activity diagram in
Figure 6a. First the inputs variables are read. This essentially caches the current
values of the inputs, input signals and commands in local variables. Second, the
(combined) prestate of the object is executed. If a new command was sent to the
object, the behavior associated to the command is executed. The execution of a
command consists of the following components. The guard condition is a Boolean

execute command behaviorcommandaccept/reject behavior.execute postate behaviorState machineread inputs[All state machines have executed][else]execute prestate behavior[A command is issued][No command is issued]write outputsexecute entry behavior target stateexecute transition action[some transition enabled][else]change configurationexecute continuous behavior current stateexecute continuous behavior target stateTitle Suppressed Due to Excessive Length

9

expression that determines whether the command can be accepted. If the guard
condition is true, the command action is executed, otherwise the reject action
is executed. The command ready condition determines whether, at the end of
the current cycle, the command has been fully processed and can be removed
from the interface of the command. If the command ready condition is false,
the command will remain on the interface; if it is not subsequently overwritten
by a new command, in the next cycle only the command ready condition will
be reevaluated, the guard condition and the accept and reject actions are not
executed again. After the command has executed, all state machines in the
object execute in a predetermined order and are allowed to execute one single
transition per turn. Finally, the (combined) poststate is executed and the outputs
are written.

Figure 6b depicts the execution of a single state machine using an activity
diagram. First, the continuous code of the current active state is executed. Sec-
ond, it is determined whether a transition is enabled in the current state of the
state machine. A transition is enabled if its guard is true. If multiple transitions
are enabled, only one is executed. Choosing the transition to be executed is done
as follows: if the source state of one enabled transition contains the source state
of another, the transition from the outermost state is executed. Transitions to
other states take priority over self-loop transitions to the same state. If, after
making this selection, still multiple transitions are enabled, the ﬁrst transition
from a predetermined order is executed.3 Finally, the current state is changed
to the target state and the behavior speciﬁed on the transition and the behavior
of the target state are executed. If no transition is enabled, the current state
remains unchanged.

For the sake of veriﬁcation, it is useful to consider the behavior of a subsystem
in isolation. To facilitate this, in addition to the inputs, we also consider the input
(and input/output) signals and commands as free variables. This allows setting
arbitrary values to these inputs and commands in the model.

3 Cylinder

In the remainder of this paper we focus on the veriﬁcation of the full model of
the pneumatic cylinder introduced as running example in Section 2. Its class
diagram and top-level state machine Main were introduced in Examples 1 and 2,
respectively. In this section, we introduce the remainder of the state machine
diagram of the cylinder.

State machine Main refers to substatemachines MovingToZeroPosition,
MovingToEndPosition, and Disabled. Furthermore, it contains subdiagrams
InZeroPosition, InEndPosition. We next elaborate the most important de-
tails of these.

Disabled. Initially, the cylinder model enters substatemachine Disabled. This
state machine is shown in Figure 7.

3 Currently, the implementation chooses the order of creation.

10

Anna Stramaglia and Jeroen J.A. Keiren

Fig. 7: Substatemachine Disabled

Fig. 8: Subdiagram EmergencyStop

From the initial state of Disabled, if command EmergencyStop was ac-
cepted, the system moves to subdiagram EmergencyStop, shown in Figure 8. In
EmergencyStop, if input signal iResetOutputsOnEStop is true, Reset_Outputs
is entered, and outputs oValeMoveToZeroPos and oValveMoveToEndPos are set
to false, stopping all movement of the cylinder. Once this code has ﬁnished exe-
cuting, the system moves to Wait_For_Conditioning. This state in Disabled
is also reached directly from the initial state if no EmergencyStop was issued.
Subdiagram Conditioning, shown in Figure 9, determines, based on the cur-
rent values of the inputsignals, inputs and outputs, which of the states in Main
reﬂects the current situation of the cylinder using a cascade of choice nodes.
The cascade of choice nodes can be interpreted as an if ... else if ...
else ... conditional. The states without outgoing transitions are used from
statemachine Main to determine the appropriate exit from Disabled.

Title Suppressed Due to Excessive Length

11

Fig. 9: State machine diagram Conditioning

MovingToEndPosition. The two substatemachines MovingToEndPosition and
MovingToZeroPosition, are symmetric. We therefore only explain the ﬁrst.
The substatemachine is shown in Figure 10.4

Fig. 10: Substatemachine MovingToEndPosition

4 For the sake of completeness, MovingToZeroPosition is included in Appendix B.

12

Anna Stramaglia and Jeroen J.A. Keiren

When MovingToEndPosition is entered, ﬁrst SetValves is reached. Here,
the valves are set such that the cylinder starts moving to the end position. From
state SetValves, if input signal iEndPosSensorConnected is true, composite
state SensorConnected is reached.

If iEndPosSensor is true, a transition can be taken to SensorActive. This
state can be left either if iEndPosSensor becomes false, or if the sensor value has
been stable suﬃciently long. In the latter case, SensorConnected.FinalState
is reached. This triggers the transition to the rightmost choice node in the di-
agram. From this node, the transition to BothSensorsActive is taken if not
only iEndPosSensor but also iZeroPosSensor is true (and connected); this
is an unexpected situation where the hardware indicates the cylinder is in its
zero position and its end position at the same time. The Main state machine
responds to this error situation through the transitions in Figure 4 with, e.g.,
guard State(Moving_To_End_Pos.BothSensorsActive). If this error situa-
tion does not happen, the ﬁnal state of MovingToEndPosition is reached. Note
that SensorConnected can be left to state Timeout whenever the system takes
too long to stably reach state sensor active.

InEndPosition. Subdiagrams InEndPosition and InZeroPosition are also
symmetric, and describe the behavior of the cylinder when it is completely ex-
tended or completely retracted, respectively. We here only describe the behavior
of InEndPosition shown in Figure 11.5

Fig. 11: State machine diagram InEndPosition

5 For the sake of completeness, InZeroPosition is included in Appendix B.

Title Suppressed Due to Excessive Length

13

Essentially this subdiagram keeps track of the current value of the input
iEndPosSensor, moving to state SensorActive if the iEndPosSensor is true,
and to SensorNotActive otherwise. The remainder of the diagram covers dif-
ferent error situations and their response. Whenever the diagram is in state
TimeoutSensorNotActive the logic in Main in Figure 4 can take a transition
to Moving_To_End_Pos. Similarly, if the diagram reaches BothSensorsActive
or ZeroSensorActive, state machine Main ensures that a transition to state
Position_Unknown is taken.

4 Model checking Cordis models using mCRL2

We enable formal veriﬁcation of Cordis models through an automatic translation
of the Cordis semantics to the modelling language mCRL2 [10]. The language
is based on proces algebra with data. Its associated tool set [4] can be used for
modelling, validating and verifying systems. Although mCRL2 allows the speci-
ﬁcation of communicating, parallel processes, the formalization of the semantics
of Cordis model we present in this work only uses sequential processes. In the
following subsections we describe our translation to mCRL2, see Section 4.1, and
the formalization of a number of properties, see Section 4.2. We again use the
model of a pneumatic cylinder (see Example 1) as a running example.

4.1 Translation to mCRL2

The mCRL2 speciﬁcation of Cordis models consists of a sequence of several
processes that model the behavior of the system. Essentially, each execution step
depicted in Figure 6 is represented by a process in the mCRL2 speciﬁcation.

The basic building block in a process is an action, such as a, b, that can be
parameterized with data, e.g., a(0), b(false). When p and q are processes, the
sequential composition p.q denotes the process in which ﬁrst p is executed, and
upon termination, q is executed. The alternative composition, or choice, p + q
denotes that either p or q is executed. Recursive processes can be deﬁned by
writing process equations of the form P = q, where P is the name of the process,
and q is a process expression in which named processes are referred to in the
same way as actions.

In the mCRL2 speciﬁcation of Cordis models, all processes are parameter-
ized with the current conﬁguration of the system, i.e. the current states of all
state machines, and the current values of all class properties and operations
(commands). In what follows we sometimes omit (part of) the parameters, and
write ... instead. Each state machine in the model is identiﬁed uniquely by a
nonnegative index.

Example 4. For the cylinder example discussed in this paper, the process de-
scribing the top-level of the system is as follows.

P_main(state_machine: Nat, s1: List(State), ..., cmd2: Command, cmd2_ready: Bool,

cmd2_accepted: Bool, behaviors: List(Int), ...,
M2’ToggleToZeroPosition: Bool, M2’iZeroPosSensor: Bool,

14

Anna Stramaglia and Jeroen J.A. Keiren

M2’iEndPosSensor: Bool, M2’oValveMoveToZeroPos: Bool,
M2’oValveMoveToEndPos: Bool, M2’iCompressedAirOK: Bool,
M2’iZeroPosSensorConnected: Bool, M2’iEndPosSensorConnected: Bool,
M2’iResetOutputsOnEStop: Bool, M2’iForceEnablingToZeroPos: Bool,
M2’iForceEnablingToEndPos: Bool, M2’oInZeroPosition: Bool,
M2’oInEndPosition: Bool, M2’oEnabled: Bool, ...) = P_set_inputs();

The state machine that is currently executing is tracked by the parameter
state_machine, which is a natural number. The current conﬁguration of the
system is tracked by, for every top-level statemachine, keeping a list of states.
This contains all states that are contained in the top-level state machine and the
subdiagrams and substatemachines it refers to, that are currently active. States
are deﬁned using sort State = struct State_(state: Nat, entry: List
(behavior), cont: List(behavior)) such that each state contains its unique
identiﬁer state, and its entry and continuous behavior, entry and cont. For
every machinepart i, again indexed by an integer, the command that is currently
on the interface (along with some additional information) is kept in cmdi. In the
example, the machinepart Cylinder has index 2. Furthermore, the class prop-
erties are stored as parameters. For instance, class property iEndPosSensor, an
input of the machinepart with index 2, is stored as M2’iEndPosSensor, were M2
refers to machinepart 2.

We next explain the parts of the mCRL2 speciﬁcation that are most relevant

for the Cylinder model, following the execution of the Cordis semantics.

At the beginning of each cycle, the values of the inputs are received by the
system. As the inputs are not controlled by the system, we model these by
receiving arbitrary values of the domain of the inputs.

Example 5. For the cylinder model this is formalized as follows.
P_set_inputs(..., M2’iZeroPosSensor: Bool, M2’iEndPosSensor: Bool, ...) =

sum M2’iZeroPosSensor’, M2’iEndPosSensor’: Bool
. inputs(M2’iZeroPosSensor’, M2’iEndPosSensor’)

. P_set_free_input_signals(M2’iZeroPosSensor = M2’iZeroPosSensor’,

M2’iEndPosSensor = M2’iEndPosSensor’);

In this equation P_set_inputs is a parameterized process. We focus in par-
ticular on the <<Input>> parameters from the class diagram. The sum denotes
a generalized alternative composition. Using bound variables iEndPosSensor’
and iZeroPosSensor’, it generates the choice between all four combinations
of values to the action inputs. Subsequently, P_set_free_input_signals is
called, where the new values of the inputs are assigned to the process parameters.
As the inputs are read in every cycle of the execution, a liveness analysis can be
performed, setting the value of the input parameters to a default value if it will
not be used in the current state. The process P_set_free_input_signals is
similar to P_set_inputs. For the sake of modelling, this allows to set arbitrary
values to the input signals.

This process in turn calls P_set_free_commands, which cycles through all
machineparts to model commands that are issued by the environment. Like
states, commands are indexed by a natural number. Issuing commands is mod-
eled by non-deterministic choice over the commands of the machinepart. If no
new command is issued this is indicated using action no_freecmd.

Title Suppressed Due to Excessive Length

15

Example 6. For the cylinder, an outline of the process that sets free commands
is the following.

P_set_free_commands_2(..., cmd2: Command, ...) =

freecmd(6) . P_machineparts(cmd2 = M2’MOVE_TO_ZERO_POSITION,

cmd2_ready = false, cmd2_accepted = false)

+ ...
+ no_freecmd . P_machineparts()

Once all external inputs to the system have been established, the cyclic execu-
tion of machineparts is performed. In the case of the cylinder, only machinepart
2 needs to execute. First, the prestate is executed (which is empty in case of the
cylinder). Subsequently, the command on the interface is executed.

Example 7. For instance, command MOVE_TO_ZERO_POSITION has index 6 in the
cylinder model. It is executed using the following code.

P_command_6(..., s1: List(State), ..., cmd2: Command,

cmd2_ready: Bool, cmd2_accepted: Bool, ...) =

(isCommand2_MOVE_TO_ZERO_POSITION(cmd2) && !cmd2_accepted)

-> command(6, true)

. P_command_6_exec(behaviors = accept(cmd2), cmd2_accepted = true,

cmd2_ready = S79 in s1 || S103 in s1 || S89 in s1 || S93 in s1)

+ (isCommand2_MOVE_TO_ZERO_POSITION(cmd2) && cmd2_accepted)
-> chk_ready . P_statemachines_M2(cmd2_ready = ...);

If the command is new on the interface, cmd2_accepted is currently false. If
the command guard evaluates to true, the second argument of the command
action is true, indicating the command is accepted, and otherwise it is false.
If the command is accepted, the command accept behavior is listed for exe-
cution, indicated by behaviors = accept(cmd2); if the command is rejected,
reject(cmd2) is assigned instead. Furthermore, the process records whether
the command was accepted, and the command ready condition is evaluated in
the assignment to cmd2_ready. In this case, the command ready condition is
true if the state machine is currently in one of four states. If the command was
accepted in a previous cycle, only the command ready condition is checked and
its valuation is updated in the same way as in the case of a new command. If
the command was not new, the state machines, in order, get the turn to take
one transition each. If a new command was accepted, ﬁrst the corresponding
behaviors are executed in P_command_6_exec, before moving on to the state
machine execution.

To execute the state machines, there is a separate process for each top-
level state machine. For instance, in the cylinder model, statemachine Main
has index 1, and the corresponding process is P_statemachine_S1. The pro-
cess cycles through all statemachines that are ancestors of the top-level state
machine in order, and allows each to take a transition. Transitions are deﬁned
by sort Transition = struct Transition_(source:List(State), dest:
List(State), behavior:List(behavior)) that is, its source states source,
its target states dest, and the behavior that is executed when taking the transi-
tion, behavior. The statemachine process oﬀers a non-deterministic choice over
all transitions in the statemachines.

16

Anna Stramaglia and Jeroen J.A. Keiren

Example 8. We give an example of one transition in the process of the cylinder.
The other transitions are similar.

P_transitions_S1(state_machine: Nat, s1: List(State),...) =

...

+ (state_machine == 1 && (head(source(t100)) in s1)

&& (!M2’iCompressedAirOK || isCommand2_EmergencyStop(cmd2) && cmd2_accepted))

-> trans(100)

.P_execute_behaviors_S1(behaviors = behavior(t100) ++ entry(head(dest(t100))),

s1 = dest(t100) ++ remove_prefix(s1, rhead(source(t100))), ...)

+ ...

In this excerpt, t100 refers to the transition with source state Main.Enabled
and target state Main.Disabled.InitialState in Figure 4 which is guarded
by [NOT InpSignal(iCompressedAirOK) OR CmdChk(EmergencyStop)].
The summand consists of a guard which says that statemachine Main is exe-
cuting, i.e., state_machine == 1, and source state Main.Enabled is part of
the current conﬁguration, i.e., (head(source(t100)) in s1). Furthermore, it
checks if command EmergencyStop was accepted using isCommand2_Emergency
Stop(cmd2) && cmd2_accepted.6 In case the condition is satisﬁed, the action
trans(100) is executed and P_execute_behaviors_S1 is called in order to
execute the behaviors labelling the transition (if any), behavior(t100), as
well as the entry behavior of the target state, entry(head(dest(t100))). The
next state reached in the statemachine is dest(t100) ++ remove_prefix(s1,
rhead(source(t100))), where dest(t100) describes the conﬁguration that
is reached after taking the transition, and remove_prefix(s1, rhead(source
(t100))) removes all the states that are left by taking the transition from the
conﬁguration.

If multiple transitions are enabled on diﬀerent levels in the hierarchy, for instance
both a state and its strict descendant could take a transition based on the current
conﬁguration and the guards, priority is given to the transition from the state
highest in the hierarchy. For transitions from substates and substatemachines
this is encoded in the mCRL2 translation by including, in the condition generated
for the transition, the negation of the guard of all transitions that take priority.
After all state machines have executed one transition and the corresponding
behavior, the poststate is executed. To this end, once the last state machine’s
behavior has executed, process P_poststate_M2 is called, with behaviors =
poststate(1), i.e., the behaviors that correspond to the poststate of top-level
state machine Main.

The execution of behaviors for the prestate, poststate and the transitions are
all executed in a similar fashion. We here explain the execution for the poststate
where behaviors are coded using structured text. The semantics of structured
text is translated to a sequence of mCRL2 processes, whose parameter updates
capture the semantics. The structured text itself is translated to a list of such
behaviors. Executing the behavior then amounts to looping through the list of
behaviors, and executing the corresponding processes.

Example 9. For the poststate of the cylinder, this is modelled as follows.

6 Note that in mCRL2, && (conjunction) binds stronger than || (disjunction).

Title Suppressed Due to Excessive Length

17

P_poststate_M2(..., behaviors: List(Int), ...) =

(behaviors == []) -> post_done.P_remove_command_M2()

+ (behaviors != [] && head(behaviors) == 3)

-> post(3).P_3(behaviors = tail(behaviors));

The actual updates done in P_3 are, in this case, simply updates to process
parameters, reﬂecting the assignments in the poststate. For the sake of brevity
we omit the details.

Once all behaviors have been executed, transition post_done is taken, and if
a command was on the interface and the command ready condition was true,
in process P_remove_command_M2, the command is removed from the interface,
and cmd2_accepted and cmd2_ready are reset to their default value. Execution
subsequently repeats from the beginning.

4.2 Formal veriﬁcation of requirements

One of the primary goals of formalizing Cordis models using mCRL2 is to enable
the formal veriﬁcation of requirements. In this section, we ﬁrst describe the
requirements. Subsequently we discuss their formalization.

Requirements In total, we have formulated 12 requirements for the cylinder,
and formalized and veriﬁed them. In this section, we describe two of these re-
quirements, one safety requirement and one liveness requirement. The remaining
requirements and their formalizations are included in Appendix A.

The requirements we consider are the following two:

1. Invariantly, if one of the output signals oInEndPosition or oInZeroPosi-

tion is true, also output signal oEnabled is true.

2. Whenever output signal oEnabled is false and input signal iCompressedAir
OK is true, inevitably output signal oEnabled becomes true unless command
CONDITIONING is accepted.

Formalization of requirements using the modal µ-calculus We describe
requirements using the ﬁrst order modal µ-calculus [9]. This is a very expressive
temporal logic that extends the µ-calculus with data.

In general, the requirements we are interested in refer to the interfaces of the
machine parts, that is, their inputs, input signals, commands, output signals, and
outputs. The ﬁrst three are visible in the transitions of the process we generate:
they are set explicitly. However, the output signals and outputs are only available
implicitly as part of the process parameters. In order to expose their values, we
have extended the translation with self-loops that are labelled with transitions
that show the current value of the outputs and output signals. For this, we use
actions such as state_M2’oInEndPosition(true), where state indicates this
is a state loop, M2 refers to the machinepart, oInEndPosition is the name of
the output, and true is the current value of the output. Using self-loops labelled
with action states, we also expose the current state of the system.

This is used to formalize the ﬁrst requirement as follows.

18

Anna Stramaglia and Jeroen J.A. Keiren

[true*](<state_M2’oInEndPosition(true)||state_M2’oInZeroPosition(true)>true

=> <state_M2’oEnabled(true)>true)

This formula should be read as follows. First, [true*] represents all sequences
consisting of zero or more actions. After each such sequence, i.e., in every reach-
able state of the system, the remainder of the formula should hold. For the
remainder, note that formula <a>true holds in every state with an outgoing a
transition. If we write action formula a || b inside a modality, this matches
the set of actions containing a, b; essentially, || here denotes the union of the
sets of action represented by a and b, which are the singleton sets containing
a and b, respectively. Hence, <state_M2’oInEndPosition(true)||state_M2’
oInZeroPosition(true)>true holds in every state that has an outgoing transi-
tion labelled state_M2’oInEndPosition(true), or it has a transition labelled
state_M2’oInZeroPosition(true). In each such state, the formula requires
that also <state_M2’oEnabled(true)>true holds, i.e., the state has an outgo-
ing transition labelled state_M2’oEnabled(true). We refer to [10] for a more
extensive introduction to the µ-calculus.

The second requirement is formalized as follows.

nu X(enabled: Bool = false, compressedAirOk: Bool = false) .

(forall e: Bool . <state_M2’oEnabled(e)>true =>

((forall c: Bool . [exists a2, a3, a4, a5, a6: Bool .

free_input_signals(c, a2, a3, a4, a5, a6)]X(e,c)) &&
[!exists a1, a2, a3, a4, a5, a6: Bool .

free_input_signals(a1, a2, a3, a4, a5, a6)]X(e,compressedAirOk))) &&

(forall e: Bool . [state_M2’oEnabled(e)]false =>

((forall c: Bool . [exists a2, a3, a4, a5, a6: Bool .

free_input_signals(c, a2, a3, a4, a5, a6)]X(enabled,c)) &&
[!exists a1, a2, a3, a4, a5, a6: Bool .

free_input_signals(a1, a2, a3, a4, a5, a6)]X(enabled,compressedAirOk))) &&

(val(!enabled && compressedAirOk) =>

mu X . [!((exists a2, a3, a4, a5, a6: Bool .

free_input_signals(false, a2, a3, a4, a5, a6)) ||
command(9, true) ||

(exists b: Bool . state_M2’oValveMoveToZeroPos(b) ||

state_M2’oValveMoveToEndPos(b) ||
state_M2’oInZeroPosition(b) ||
state_M2’oInEndPosition(b) ||
state_M2’oEnabled(b)) ||

(exists i: Nat, l: List(Nat) . states(i, l))

)]X || <state_M2’oEnabled(true)>true)

This formula uses a greatest ﬁxed point (nu) and a least ﬁxed point (mu). The
greatest ﬁxed point is parameterized by two Boolean variables, enabled and
compressedAirOk, that keep track of whether oEnabled or iCompressedAirOk
have become true, respectively. In order to keep track of these values, we dis-
tinguish two cases. If a transition state_M2’oEnabled(e) is enabled, denoted
by forall e: Bool. <state_M2’oEnabled(e)>true, we check if an action
free_input_signals is enabled. If so, we determine the value assigned to
iCompressedAirOk using forall c: Bool . [exists a2, a3, a4, a5, a6
: Bool .free_input_signals(c, a2, a3, a4, a5, a6)]X(e,c)). We use
exists inside the modality to represent generalised union, and match any value
for the rest of the input signals. We update enabled to the value observed by
the self-loop, and compressedAirOk to the value set in free_input_signals.
If free_input_signals is not enabled, only compressedAirOk is updated. The

Title Suppressed Due to Excessive Length

19

case where state_M2’oEnabled(e) is not enabled is handled in a similar way.
That is, if an action free_input_signals is enabled, we only update the value
of compressedAirOk by observing the values in free_input_signals. Other-
wise, the value of the parameters of X are unchanged. To summarize, the ﬁrst
part of the formula describes an invariant property, and it keeps track of the
most recent value of oEnabled and iCompressedAirOK.

Now, if enabled is false, and compressedAirOk is true, the least ﬁxed point
subformula needs to hold. To interpret this formula, we ﬁrst note that formula
mu Y . [!a]Y || <b>true captures that inevitably a state is reached where
a b transition is enabled, unless an a transition happens. So, in principle, the
following formula denotes that, as long as iCompressedAirOk, does not become
false, represented by the ﬁrst argument to free_input_signals, and com-
mand CONDITIONING is not accepted, represented by command(9, true), then
we inevitably end up in a state where oEnabled is true.

mu Y . [!((exists a2, a3, a4, a5, a6: Bool .

free_input_signals(false, a2, a3, a4, a5, a6)) ||

command(9, true))]Y ||

<state_M2’oEnabled(true)>true)

However, as we extended the model with self-loops to expose the current value
of output signals, by taking such self-loops we trivially end up in an inﬁnite
sequence on which no state where oEnabled holds is reached. We therefore need
to exclude paths through these self-loops.7

4.3 Results

We have veriﬁed the two properties from Section 4.2, as well as 10 additional re-
quirements. For our experiments we have used Cordis Modeler version 3.14.1630.
7156 and mCRL2 tool set Release 202106.0. The cylinder model described and
studied in this paper is relatively simple. This is reﬂected by the veriﬁcation
time: each of the properties can be veriﬁed in less than 5 seconds. Property 2
is false, and all of the other requirements are satisﬁed by the model. In case a
property does not hold, the mCRL2 tool set oﬀers a counterexample. In the next
section, we discuss the counterexample to property 2 in detail.

5 Discussion

As observed in the previous section, requirement 2 does not hold for the Cylinder
model. The mCRL2 tool set provides a counterexample that is a subset of the
labelled transition system that underlies the speciﬁcation of the cylinder, and
that contains suﬃcient information to prove that the property is violated [26].
The counterexample is a lasso, shown in Figure 12. It consists of a sequence
of transitions that leads to a cycle on which iCompressedAirOK remains true,

7 We here rely on the fact that the additional information is only exposed through
self-loop transitions. This avoids the need for introducing an additional greatest ﬁxed
point.

20

Anna Stramaglia and Jeroen J.A. Keiren

inputs(ff, tt)

τ

post(3 )

τ

trans(174 )

free input signals

(tt, ff, tt, ff, tt, tt)

trans(175 )

τ

inputs(tt, tt)

no freecmd chk ready

τ

command(9 , tt)

free input signals

(ff, tt, tt, tt, tt, tt)

no freecmd

freecmd(9 )

free input signals

(tt, ff, ff, tt, tt, ff)

command none trans(99 )

τ

trans(207 )

τ

post(3 )

τ

inputs(tt, tt)

Fig. 12: Counterexample found verifying Property 2

and command CONDITIONING is never accepted, but, oEnabled remains false. In
subsection 2.3, we have described the state machines execution, this same struc-
ture is found in the counterexample. In each cycle, after having updated inputs
and commands, the state machines are executed in turns in the predetermined
order: Main, MovingToZeroPosition, MovingToEndPosition and Disabled.
For the sake of readability, in Figure 12, the actions which are not essential
to describe the trace are labeled with τ ; a sequence of τ labeled transitions is
denoted by a dotted arrow labeled τ . We denote true and false as tt and ff
respectively.

The execution of the counterexample starts from the state with an unlabeled
arrow pointing to it. At the beginning of the ﬁrst cycle, action inputs(tt, tt)
indicates that inputs iZeroPosSensor and iEndPosSensor are both set to true;
input signal iCompressedAirOk is set false while the other input signals are set
to true, and no command is issued. The ﬁrst cycle continues with the execu-
tion of action trans(99 ). This indicates that in state machine Main the transi-
tion from Main.InitialState to Main.Disabled.InitialState is taken. As
MovingToZeroPosition and MovingToEndPosition are not currently active,
they do not take any transition, indicated by the dotted τ transition. Subse-
quently, state machine Disabled takes the transition from Main.Disabled.
InitialState to Main.Disabled.Wait_For_Conditioning, denoted by ac-
tion trans(207 ). The poststate concludes the ﬁrst cycle.

In the second cycle, the inputs remains true, iCompressedAirOK is set to
true and command CONDITIONING is issued and accepted, expressed by ac-
tions freecmd (9 ) and command (9 , tt), respectively. It follows that state ma-
chines Main, MovingToZeroPosition, and MovingToEndPosition do not per-
form transitions. In state machine Disabled action trans(174 ) is executed, that
is, the transition from state Main.Disabled.Wait_For_Conditioning to state
Main.Disabled.Conditioning.InitialState is taken. The remainder of this

Title Suppressed Due to Excessive Length

21

cycle executes the poststate, shown in the loop moving in counterclockwise di-
rection.

In the third cycle (and subsequent cycles) input signal iCompressedAirOK
remains true. No new command is issued, but the action chk ready expresses
that command CONDITIONING, issued in the second cycle, is still active on the
interface, and is not yet ready. State machines Main, MovingToZeroPosition,
and MovingToEndPosition do not perform transitions. Finally, in state machine
Disabled action trans(175 ) is executed. That is, the transition from state Main
.Disabled.Conditioning to Main.Disabled.Conditioning.InitialState
is taken. In the cylinder model this is the self-transition from and to subdia-
gram Conditioning in Figure 7. The subsequent cycles behave identically, such
that state Main.Disabled.Conditioning.InitialState is inﬁnitely often re-
entered.

Reproducing the counterexample. To ascertain that the problem identiﬁed by
our veriﬁcation also exists in the implementation, we have analyzed a running
implementation of the cylinder model. Recall that from a Cordis model PLC
code can be generated and executed. By loading the executing PLC code in a
debugger, the implementation can be simulated by stepping through the code.
In this way, setting the appropriate inputs and input signals, and issuing the
command CONDITIONING in accordance to the counterexample, we have been
able to reproduce the exact behavior of the counterexample.

This is interesting in two respects. First of all, this increases the conﬁdence in
the correctness of the translation of the Cordis model semantics to mCRL2. Sec-
ond, the counterexample contains suﬃcient information to eﬃciently reproduce
the counterexample in the running system.

Root cause analysis. Once it has been established that the counterexample can
be reproduced, we analyze it in the context of the cylinder model to understand
which part of the model causes this issue.

The system is able to loop in the self-transition from and to subdiagram
Conditioning in Figure 7 because of two reasons: (1) in Cordis models, the
outermost enabled transition gets priority over transitions that are more deeply
nested in the model, and (2) the command continuously remains active on the
interface. Hence, even if another transition, more deeply nested in subdiagram
Conditioning, would have been enabled, the self-transition always takes prior-
ity.

As the ﬁrst reason is an inherent part of the semantics of Cordis models, we
focus on the transition being enabled in the remainder of the analysis. Com-
mand CONDITIONING has guard condition State(Main.Disabled), command
ready condition NOT State(Main.Disabled), and no accept and reject actions.
Thus, command CONDITIONING is accepted if the system currently is in state
machine Disabled, and the command is ready if the system leaves state machine
Disabled.

In the counterexample, when command CONDITIONING is accepted, we are
indeed in state machine Disabled, so this condition is satisﬁed, and subdiagram

22

Anna Stramaglia and Jeroen J.A. Keiren

Conditioning is entered. As Conditioning is a subdiagram of Disabled, so the
command ready condition is not satisﬁed in this state, and due to the priorities
none of the transitions in Figure 9 can be taken.

Solution. Based on the analysis, we observe that issuing the CONDITIONING
command does not simply trigger the model once to look at the current state of
the system, but instead it behaves like a trigger that always remains high. The
solution to avoid this behavior is to modify the command ready condition from
NOT State(Main.Disabled) to true. This way, the command will indeed only
act as a trigger to enter state machine conditioning: when issued and accepted,
command CONDITIONING stays active on the interface for exactly one cycle.

This change does not aﬀect the relevant behavior of the cylinder model: if
the system is currently in a substate of subdiagram Conditioning, it can still
re-enter subdiagram Conditioning if command CONDITIONING is issued and
accepted again.

Changing the cylinder model accordingly, and re-verifying the requirements

shows that, indeed, requirement 2 holds.

6 Concluding remarks

In this paper we have discussed the semantics of Cordis models, an extension
of standard UML used for modelling complex machine-control applications, in
order to enable the veriﬁcation of these models. Even though Cordis models are
not primarily designed for the application of formal veriﬁcation, we were able to
characterize and implement an automatic translation to mCRL2. As a proof of
concept we have veriﬁed the behavior of an industrial cylinder model, formalized
a number of requirements for this model, and veriﬁed these. We have shown in
this paper that the veriﬁcation process is eﬀective to ﬁnd bugs, and that the
bugs can be reproduced in the actual system using a debugger.

There are some aspects to the formalization and veriﬁcation process that we
do not report on explicitly in this paper. In particular, using earlier versions of the
Cordis modeler and the translation to mCRL2 we have uncovered corner cases
that were treated diﬀerently in the PLC code generated by the Cordis SUITE and
in the mCRL2 model. This has resulted in modiﬁcations to both the semantics
in the Cordis modeler, improving the stability and quality of the generated PLC
code, as well as to the translation to mCRL2 to ensure that the semantics of the
mCRL2 models are consistent with the PLC code. In order to understand and
debug such issues, both having clear counterexamples in mCRL2, and the ability
to step through the PLC code using a debugger have proven indispensable.

Future work. Cordis models of complete industrial systems usually consists of
multiple interacting objects. To this end, the translator from Cordis models
to mCRL2 has been extended to deal with systems that consist of multiple
components.

Title Suppressed Due to Excessive Length

23

We are currently expanding our work to deal with more complex industrial
models. In particular, we are investigating the use of symbolic model check-
ing techniques [5] to deal with the large state spaces they induce. Furthermore,
compositional model checking [19] could help in the veriﬁcation of such large
models by incrementally generating state spaces of subsystems, reducing them,
and combining them into larger subsystems, prior to veriﬁcation. We are ad-
ditionally investigating improvements to static analysis tools that can optimize
mCRL2 models, resulting in smaller state spaces [8], and static analysis tech-
niques for Cordis models such as dead variable analysis. Finally, in our ongoing
collaboration with Cordis, we are integrating model checking into the Cordis
SUITE in such a way that mCRL2 is used as a veriﬁcation back-end, and veri-
ﬁcation is directly accessible from the Cordis modeller.

Acknowledgements This work was supported partially by the MACHINAIDE
project (ITEA3, No. 18030) and through EU regional development funding in the
context of the OP-Zuid program (No. 02541). We thank Wieger Wesselink and
Yousra Haﬁdi for contributions to the development of the mCRL2 translation,
and Cordis Automation B.V. for their feedback on earlier versions of this paper.

References

1. Hydraulic circuit, directional control. https://commons.wikimedia.org/
wiki/File:Hydraulic_circuit_directional_control.svg (2011),
[ac-
cessed: 2021-03-22]

2. Bouwman, M., Luttik, B., van der Wal, D.: A Formalisation of SysML State Ma-
chines in mCRL2. In: Peters, K., Willemse, T.A.C. (eds.) Formal Techniques for
Distributed Objects, Components, and Systems. pp. 42–59. LNCS, Springer Inter-
national Publishing, Cham (2021). https://doi.org/10.1007/978-3-030-78089-0 3
3. Bunte, O., van Gool, L.C.M., Willemse, T.A.C.: Formal Veriﬁcation of OIL Com-
ponent Speciﬁcations using mCRL2. In: ter Beek, M.H., Niˇckovi´c, D. (eds.)
FMICS. pp. 231–251. LNCS, Springer International Publishing, Cham (2020).
https://doi.org/10.1007/978-3-030-58298-2 10

4. Bunte, O., Groote, J.F., Keiren, J.J.A., Laveaux, M., Neele, T., de Vink, E.P., Wes-
selink, W., Wijs, A., Willemse, T.A.C.: The mCRL2 toolset for analysing concur-
rent systems. pp. 21–39. TACAS, Springer International Publishing, Cham (2019)
5. Burch, J.R., Clarke, E.M., McMillan, K.L., Dill, D.L., Hwang, L.J.: Symbolic model
checking: 1020 States and beyond. Information and Computation 98(2), 142–170
(Jun 1992). https://doi.org/10.1016/0890-5401(92)90017-A

6. Cimatti, A., Clarke, E., Giunchiglia, E., Giunchiglia, F., Pistore, M., Roveri, M.,
Sebastiani, R., Tacchella, A.: NuSMV 2: An OpenSource Tool for Symbolic Model
Checking. In: Goos, G., Hartmanis, J., van Leeuwen, J., Brinksma, E., Larsen, K.G.
(eds.) Computer Aided Veriﬁcation, LNCS, vol. 2404, pp. 359–364. Springer Berlin
Heidelberg, Berlin, Heidelberg (2002). https://doi.org/10.1007/3-540-45657-0 29
7. Dubrovin, J., Junttila, T.: Symbolic model checking of hierarchical UML
state machines.
In: 2008 8th International Conference on Application of
Concurrency to System Design. pp. 108–117. ISSN: 1550-4808 (Jun 2008).
https://doi.org/10.1109/ACSD.2008.4574602

24

Anna Stramaglia and Jeroen J.A. Keiren

8. Groote,

J.F., Lisser, B.: Computer

alge-
speciﬁcations. SIGPLAN Notices 37, 98–107 (Dec 2002).

assisted manipulation

of

braic process
https://doi.org/10.1145/636517.636531

9. Groote, J.F., Mateescu, R.: Veriﬁcation of Temporal Properties of Processes
in a Setting with Data. In: Haeberer, A.M. (ed.) Algebraic Methodology and
Software Technology. pp. 74–90. LNCS, Springer, Berlin, Heidelberg (1999).
https://doi.org/10.1007/3-540-49253-4 8

10. Groote, J.F., Mousavi, M.R.: Modeling and Analysis of Communicating Systems |
The MIT Press. The MIT Press (2014), https://mitpress.mit.edu/books/
modeling-and-analysis-communicating-systems

11. Hansen, H.H., Ketema, J., Luttik, B., Mousavi, M.R., van de Pol, J.:
Inno-
in Systems and Software Engineering 6(1-2), 83–90 (Mar 2010).

Towards model checking executable UML speciﬁcations in mCRL2.
vations
https://doi.org/10.1007/s11334-009-0116-1

12. Hwong, Y.L., Keiren, J.J.A., Kusters, V.J.J., Leemans, S., Willemse, T.A.C.: For-
malising and analysing the control software of the compact muon solenoid exper-
iment at the large hadron collider. Science of Computer Programming 78(12),
2435–2452 (Dec 2013). https://doi.org/10.1016/j.scico.2012.11.009

13. John, K.H., Tiegelkamp, M.: The Programming Languages of IEC 61131-3. In:
John, K.H., Tiegelkamp, M. (eds.) IEC 61131-3: Programming Industrial Automa-
tion Systems: Concepts and Programming Languages, Requirements for Program-
ming Systems, Decision-Making Aids, pp. 99–205. Springer, Berlin, Heidelberg
(2010). https://doi.org/10.1007/978-3-642-12015-2 4

14. Keiren, J.J.A., Klabbers, M.D.: Modelling and verifying IEEE Std 11073-20601
session setup using mCRL2. In: Proceedings of the workshop on Automated Ver-
iﬁcation of Critical Systems (AVoCS 2012). vol. X, pp. 1–15 (2012), http://
journal.ub.tu-berlin.de/eceasst/article/view/793, the models and
properties described are available in the mCRL2 gitlab repository

15. Liu, S., Liu, Y., Andre‘, ´E., Choppy, C., Sun, J., Wadhwa, B., Dong, J.S.: A
Formal Semantics for Complete UML State Machines with Communications. In:
Hutchison, D., Kanade, T., Kittler, J., Kleinberg, J.M., Mattern, F., Mitchell, J.C.,
Naor, M., Nierstrasz, O., Pandu Rangan, C., Steﬀen, B., Sudan, M., Terzopoulos,
D., Tygar, D., Vardi, M.Y., Weikum, G., Johnsen, E.B., Petre, L. (eds.) Integrated
Formal Methods, LNCS, vol. 7940, pp. 331–346. Springer Berlin Heidelberg, Berlin,
Heidelberg (2013). https://doi.org/10.1007/978-3-642-38613-8 23

16. Lyazidi, A., Mouline, S.: Formal Veriﬁcation of UML State Machine Dia-
grams Using Petri Nets. In: Atig, M.F., Schwarzmann, A.A. (eds.) Networked
Systems. pp. 67–74. LNCS, Springer International Publishing, Cham (2019).
https://doi.org/10.1007/978-3-030-31277-0 5

17. Object Management Group: OMG Uniﬁed Modelling Language (UML). Technical
Report Version 2.5.1 (2017), https://www.omg.org/spec/UML/2.5.1/PDF
18. Pore, A., Corsi, D., Marchesini, E., Dall’Alba, D., Casals, A., Farinelli, A., Fiorini,
P.: Safe reinforcement learning using formal veriﬁcation for tissue retraction in
autonomous robotic-assisted surgery. In: 2021 IEEE/RSJ IROS. pp. 4025–4031
(2021). https://doi.org/10.1109/IROS51168.2021.9636175

19. de Putter, S., Wijs, A.: Compositional Model Checking Is Lively. In: Proen¸ca, J.,
Lumpe, M. (eds.) FACS, LNCS, vol. 10487, pp. 117–136. Springer International
Publishing, Cham (2017). https://doi.org/10.1007/978-3-319-68034-7 7

20. Rodr´ıguez, R.J., Fredlund, L.˚A., Herranz, ˚A., Mari˜no, J.: Execution and Veriﬁ-
cation of UML State Machines with Erlang. In: Giannakopoulou, D., Sala¨un, G.

Title Suppressed Due to Excessive Length

25

(eds.) SEFM, LNCS, vol. 8702, pp. 284–289. Springer International Publishing,
Cham (2014). https://doi.org/10.1007/978-3-319-10431-7 22

21. Sahay, A.,

Indamutsa, A., Ruscio, D.D., Pierantonio, A.: Supporting the
understanding
In:
2020 46th Euromicro Conference on SEAA. pp. 171–178 (Aug 2020).
https://doi.org/10.1109/SEAA51224.2020.00036

low-code development platforms.

and comparison of

22. Salunkhe, S., Berglehner, R., Rasheeq, A.: Automatic Transformation of SysML
Model to Event-B Model for Railway CCS Application. In: Raschke, A., M´ery, D.
(eds.) Rigorous State-Based Methods. pp. 143–149. LNCS, Springer International
Publishing, Cham (2021). https://doi.org/10.1007/978-3-030-77543-8 14

23. Santone, A., Brunese, M.C., Donnarumma, F., Guerriero, P., Mercaldo, F.,
Reginelli, A., Miele, V., Giovagnoni, A., Brunese, L.: Radiomic features for prostate
cancer grade detection through formal veriﬁcation. La radiologia medica 126(5),
688–697 (May 2021). https://doi.org/10.1007/s11547-020-01314-8

24. Santos, L.B.R.d., J´unior, V.A.d.S., Vijaykumar, N.L.: Transformation of
UML Behavioral Diagrams to Support Software Model Checking. Electronic
Proceedings
in Theoretical Computer Science 147, 133–142 (Apr 2014).
https://doi.org/10.4204/EPTCS.147.10, arXiv: 1404.0855

25. Sch¨afer, T., Knapp, A., Merz, S.: Model Checking UML State Machines and Col-
laborations. Electronic Notes in Theoretical Computer Science 55(3), 357–369 (Oct
2001). https://doi.org/10.1016/S1571-0661(04)00262-2

26. Wesselink, W., Willemse, T.A.C.: Evidence extraction from parameterised boolean
equation systems. In: Benzm¨uller, C., Otten, J. (eds.) proc. ARQNL 2018 aﬃliated
with IJCAR 2018, Oxford, UK, July 18, 2018. CEUR, vol. 2095, pp. 86–100. CEUR-
WS.org (2018), http://ceur-ws.org/Vol-2095/paper6.pdf

A Additional requirements

Besides the two requirements described in the paper, we have formalized and
veriﬁed the 10 requirements presented in this appendix. All of these requirements
hold for the cylinder model described in this paper.

3. As long as command CONDITIONING has not been accepted and input signal

iCompressedAirOK is false, output signal oEnabled is false.
This is formalized in the µ-calculus as follows.

[!(command(9,true)||(exists iZSC,iESC,iR,iFZ,iFE:Bool.
free_input_signals(true,iZSC,iESC,iR,iFZ,iFE)))*}]

[state_M2’oEnabled(true)]false

The formula should be interpreted as follows. In the translation, command(9,
true) represents the acceptance of command CONDITIONING. Input signal
iCompressedAirOK is the ﬁrst parameter of action free_input_signals
, so free_input_signals(true,iZSC,iESC,iR,iFZ,iFE) expresses that
iCompressedAirOK becomes true, and the other input signals get an ar-
bitrary value. The ﬁrst part of the formula, [!(...)*], denotes all exe-
cutions on which command CONDITIONING is not accepted and on which
iCompressedAirOK does not become true. Along each such execution, the
value of oEnabled never becomes true, which is formalized by [state_M2’
oEnabled(true)]false.

26

Anna Stramaglia and Jeroen J.A. Keiren

4. Whenever command EmergencyStop is accepted, inevitably output signal
oEnabled becomes false unless a new command is issued. In the translation,
the acceptance of command EmergencyStop is encoded as command(10,
true). We would therefore like to express the requirements as

[true*.command(10,true)]mu X.([true]X || <state_M2’oEnabled(false)>true)

That is, whenever command EmergencyStop is accepted then, output signal
oEnabled will eventually become false. However, if another command is
issued, it overwrites the EmergencyStop command and removes it from the
interface. As a consequence, oEnabled does not necessarily become false. We
therefore exclude the situation where the command is overwritten by another
command. Furthermore, the self-loops need to be excluded in a similar way
to the formula for requirement 2 in Section 4.2.
Therefore, ultimately the requirement is formalized as follows.

[true* . command(10,true)]

mu X.([!((exists i: Nat, b:Bool. command(i,b)) ||

(exists b: Bool . state_M2’oValveMoveToZeroPos(b) ||

state_M2’oValveMoveToEndPos(b) ||
state_M2’oInZeroPosition(b) ||
state_M2’oInEndPosition(b) ||
state_M2’oEnabled(b)) ||

(exists i: Nat, l: List(Nat) . states(i,l)))]X ||

<state_M2’oEnabled(false)>true)

5. Whenever the system is enabled and command MOVE_TO_END_POSITION is
accepted, inevitably either output signal oInEndPosition becomes true or
output oValveMoveToEndPos becomes true, or the system becomes disabled,
unless another command is accepted or rejected.
On a high level, we would like to specify the requirement that says when-
ever command MOVE_TO_END_POSITION is accepted inevitably either output
signal oInEndPosition becomes true or output oValveMoveToEndPos be-
comes true, formalized as follows.

[true* . command(7,true)]

mu X. ([true]X ||

<state_M2’oInEndPosition(true) || state_M2’oValveMoveToEndPos(true)>true))

In the translation, command(7,true) encodes the acceptance of command
MOVE_TO_END_POSITION. Hence, the part of the requirement stating “when-
ever command MOVE_TO_END_POSITION is accepted” is encoded as [true*
. command(7,true)]. The least ﬁxed point subformula expresses that in-
evitably a state should be reached where either output oValveMoveToEndPos
or output signal oInEndPosition inevitably becomes true.
A complication that we have to deal with is that the requirement does not
hold if either currently the system is not enabled, i.e., oEnabled is false,
or it becomes false before reaching the desired state. In other words, the
property is not required to hold if we inﬁnitely often traverse a state where
oEnabled is false.
To this end, we replace the [true* . command(7,true)] with an outer
greatest ﬁxed point parameterized by a Boolean variable that keeps track of
whether the system is enabled when the command MOVE_TO_END_POSITION

Title Suppressed Due to Excessive Length

27

is issued. The inner ﬁxed point in entered whenever the system is enabled,
oEnabled is true, and the command MOVE_TO_END_POSITION is accepted.
The resulting formula is the following.

nu Y(enabled: Bool = false) .

(forall b: Bool . <state_M2’oEnabled(b)>true

([exists b: Bool . state_M2’oEnabled(b)]false

=> [!command(7,true)]Y(b)) &&

(val(enabled) && <state_M2’oEnabled(false)>true

=> [command(7,true)]Y(false)) &&

(val(enabled) && [state_M2’oEnabled(false)]false

=> [command(7,true)]

=> [!command(7,true)]Y(enabled)) &&

mu X.
[!(

(exists i: Nat, b: Bool . command(i, b)) ||
(exists b: Bool . state_M2’oValveMoveToZeroPos(b) ||

state_M2’oValveMoveToEndPos(b) ||
state_M2’oInZeroPosition(b) ||
state_M2’oInEndPosition(b) ||
state_M2’oEnabled(b)) ||

(exists i: Nat, l: List(Nat) . states(i, l))

)]X ||
<state_M2’oInEndPosition(true) || state_M2’oValveMoveToEndPos(true)>true ||

<state_M2’oEnabled(false)>true

)

In more detail, the formula is structured as follows. The outer greatest ﬁxed
point is parameterised by the Boolean variable enabled to keep track of
the value assigned to oEnabled. The greatest ﬁxed point is left only if
enabled is true and does not immediately become false, and if command
MOVE_TO_END_POSITION is accepted. The ﬁrst conjunct, forall b:Bool .
<state_M2’oEnabled(b)>true => [!command(7,true)]Y(b)) expresses
that, if an action state_M2’oEnabled(b) can be performed, and a tran-
sition other than MOVE_TO_END_POSITION is taken, we update the value
of enabled to the value observed in the self-loop. Similarly, if state_M2
’oEnabled(b) is not enabled, any transition that does not accept com-
mand MOVE_TO_END_POSITION keeps the current value of enabled. The lat-
ter is expressed by the conjunct ([exists b: Bool .state_M2’oEnabled
(b)]false => [!command(7,true)]Y(enabled)). The third conjunct ex-
presses that, if enabled is currently true but the state has a self-loop in in-
dicating oEnabled has become false, determined by <state_M2’oEnabled
(false)>true, and if then command MOVE_TO_END_POSITION is accepted,
we update the value of enabled to false and stay in the outer ﬁxed point,
as the condition for moving to the end position is not met. Finally, the
last conjunct, (val(enabled) && [state_M2’oEnabled(false)]false
=> [command(7,true)]mu X..., expresses that, if enabled is true and
oEnabled has not become false and command MOVE_TO_END_POSITION is
accepted, the least ﬁxed point subformula needs to hold.
The least ﬁxed point subformula is an extension of the following formula,
where additionally self-loops are excluded. In principle, the following sub-
formula denotes that, if no commands are accepted or rejected, indicated
by command(i, b), we inevitably end up in a state where oInEndPosition

28

Anna Stramaglia and Jeroen J.A. Keiren

is true or oValveMoveToEndPos is true, or the system becomes disabled,
oEnabled is false.

mu X.
[!((exists i: Nat, b:Bool . command(i, b)) )]X ||

<state_M2’oInEndPosition(true) || state_M2’oValveMoveToEndPos(true)>true ||

<state_M2’oEnabled(false)>true)

We exclude the acceptance and rejection of other commands since this would
aﬀect the behavior of the system in a such a way that, if the fourth conjunct
holds, neither oInEndPosition or oValveMoveToEndPos become true, or
the system does not become disabled, oEnabled becomes false.

6. Whenever the system is enabled and command MOVE_TO_ZERO_POSITION
is accepted, inevitably either output signal oInZeroPosition becomes true
or output oValveMoveToZeroPos becomes true, or the system becomes dis-
abled, unless another command is accepted or rejected.
This requirement and its formalization are completely symmetric to require-
ment 5. Note that, accepting command MOVE_TO_ZERO_POSITION is encoded
as command(6,true). The property is then formalized as follows.

nu Y(enabled: Bool = false) .

(forall b: Bool . <state_M2’oEnabled(b)>true

([exists b: Bool . state_M2’oEnabled(b)]false

=> [!command(6,true)]Y(b)) &&

(val(enabled) && <state_M2’oEnabled(false)>true

=> [command(6,true)]Y(false)) &&

(val(enabled) && [state_M2’oEnabled(false)]false

=> [command(6,true)]

=> [!command(6,true)]Y(enabled)) &&

mu X.
[!(

(exists i: Nat, b:Bool . command(i, b)) ||
(exists b: Bool . state_M2’oValveMoveToZeroPos(b) ||

state_M2’oValveMoveToEndPos(b) ||
state_M2’oInZeroPosition(b) ||
state_M2’oInEndPosition(b) ||
state_M2’oEnabled(b)) ||

(exists i: Nat, l: List(Nat) . states(i, l))

)]X ||
<state_M2’oInZeroPosition(true) ||

state_M2’oValveMoveToZeroPos(true)>true ||

<state_M2’oEnabled(false)>true

)

7. Whenever the system is enabled, and output oValveMoveToEndPos becomes
true, and as long as the system stays enabled, it is possible to reach the end
position (i.e., oInEndPosition becomes true), unless another command is
written on the interface.
This requirement is similar in nature to requirement 5. However, its formula-
tion is much weaker. Ideally, we may expect that stronger requirement that
inevitably oInEndPosition is reached also holds. Yet, in order to reach that
situation, the system depends on the values of the input and input signals.
In particular, it requires that eventually iEndPosSensor becomes true. We
have therefore weakened the requirement to say that oInEndPosition can
become true, but that this is not required.
This is formalized as follows.

Title Suppressed Due to Excessive Length

29

[true*](<state_M2’oValveMoveToEndPos(false)>true =>
[true*](([state_M2’oValveMoveToEndPos(true)]false

&& <state_M2’oEnabled(true)>true) =>

[true*](([state_M2’oEnabled(false)]false

&& <state_M2’oValveMoveToEndPos(true)>true) =>

([!(exists i: Nat. freecmd(i))*]

<!(exists i: Nat. freecmd(i))*.state_M2’oInEndPosition(true)>true))))

The formula can be explained as follows. The left-hand side of the ﬁrst im-
plication, [true*](<state_M2’oValveMoveToEndPos(false)>true, indi-
cates that for all sequences of zero or more actions, if oValveMoveToEndPos
is eventually set to false, then the second implication should hold. The second
implication is similar, stating that for all sequences of zero or more actions,
if there is no transition indicating that oValveMoveToEndPos is true and if
oEnabled is set to true, then the third implication should hold. The third
implication is, again, similar. If all three conditions have been met (in the
appropriate order), then along every execution on which no new command
has been issued to the cylinder, it is possible to reach the end position. This
is expressed by the last part of the formula.

8. Whenever the system is enabled, and oValveMoveToZeroPos becomes true,
and as long as the system stays enabled, it is possible to reach the zero
position (i.e., oInZeroPosition becomes true), unless another command is
written on the interface. This requirement and its formalization are com-
pletely symmetric to requirement 7 and is formalized as follows.

[true*](<state_M2’oValveMoveToZeroPos(false)>true =>
[true*](([state_M2’oValveMoveToZeroPos(true)]false

&& <state_M2’oEnabled(true)>true) =>

[true*](([state_M2’oEnabled(false)]false

&& <state_M2’oValveMoveToZeroPos(true)>true) =>

([!(exists i: Nat. freecmd(i))*]

<!(exists i: Nat. freecmd(i))*.state_M2’oInZeroPosition(true)>true))))

9. When the system initializes, the state InEndPosition should not be reached
spontaneously. We therefore require that output signal oInEndPosition
remains false, as long as both iForceEnablingToEndPos is false and ei-
ther iEndPosSensorConnected or iEndPosSensor is false, and commands
MOVE_TO_END_POSITION and TOGGLE have not been accepted. This is for-
malized as follows.

nu X(iEndPosSensor: Bool = false, iEndPosSensorConnected: Bool = false,

iForceEnablingToEndPos: Bool = false) .

(forall iEndPosSensor’: Bool .

[exists iZPS: Bool . inputs(iZPS, iEndPosSensor’)]

X(iEndPosSensor’, iEndPosSensorConnected, iForceEnablingToEndPos)) &&

(forall iForceEnablingToEndPos’, iEndPosSensorConnected’: Bool .

[exists iCAOK, iZPSC, iROOES, iFETZP: Bool .

free_input_signals(iCAOK, iZPSC, iEndPosSensorConnected’,

iROOES, iFETZP, iForceEnablingToEndPos’)]

X(iEndPosSensor, iEndPosSensorConnected’, iForceEnablingToEndPos’)) &&

(val(iForceEnablingToEndPos ||

(iEndPosSensorConnected && iEndPosSensor)) ||
([!((exists iZS, iES: Bool . inputs(iZS, iES)) ||
(exists iC, iZSC, iESC, iR, iFZ, iFEP: Bool .

free_input_signals(iC, iZSC, iESC, iR, iFZ, iFEP)) ||

command(7, true) ||
command(8, true))

]X(iEndPosSensor, iEndPosSensorConnected, iForceEnablingToEndPos) &&

30

Anna Stramaglia and Jeroen J.A. Keiren

[state_M2’oInEndPosition(true)]false))

Note that in the translation, command(7,true) and command(8,true) en-
code the acceptance of commands MOVE_TO_END_POSITION and TOGGLE, re-
spectively. As the condition that releases the obligation for oInEndPosition
to be false refers to both inputs and input signals, the invariant formula
keeps track of the most recent value these particular inputs and input signals
were assigned. The ﬁrst conjunct tracks this by, after every action inputs,
updating parameter iEndPosSensor with the value set in the action. The
second conjunct does the same for the input signals. The third conjunct is
the key to checking the actual requirement. It ﬁrst checks whether the most
recent values are such that the requirement has been fulﬁlled, i.e., either
iForceEnablingToEndPos has become true, or iEndPosSensorConnected
and iEndPosSensor are both true. If this is not the case, we need to en-
sure that oInEndPosition is not true, which is checked using [state_M2’
oInEndPosition(true)]false, and that for all executions other than those
accepting commands MOVE_TO_END_POSITION and TOGGLE, recursively the
requirement again holds.

10. When the system initializes, the state InZeroPosition should not be reached
spontaneously. We therefore require that output signal oInZeroPosition re-
mains false, as long as both iForceEnablingToZeroPos is false and either
iZeroPosSensorConnected or iZeroPosSensor is false, and commands
MOVE_TO_ZERO_POSITION and TOGGLE have not been accepted.
This requirement and its formalization are completely symmetric to require-
ment 9. It is formalized as follows.

nu X(iZeroPosSensor: Bool = false, iZeroPosSensorConnected: Bool = false,

iForceEnablingToZeroPos: Bool = false) .

(forall iZeroPosSensor’: Bool .

[exists iEPS: Bool . inputs(iZeroPosSensor’, iEPS)]

X(iZeroPosSensor’, iZeroPosSensorConnected, iForceEnablingToZeroPos)) &&

(forall iForceEnablingToZeroPos’, iZeroPosSensorConnected’: Bool .

[exists iCAOK, iEPSC, iROOES, iFETEP: Bool .

free_input_signals(iCAOK, iZeroPosSensorConnected’, iEPSC,

iROOES, iForceEnablingToZeroPos’, iFETEP)]

X(iZeroPosSensor, iZeroPosSensorConnected’,

iForceEnablingToZeroPos’)) &&

(val(iForceEnablingToZeroPos ||

(iZeroPosSensorConnected && iZeroPosSensor)) ||

([!((exists iZS, iES: Bool . inputs(iZS, iES)) ||
(exists iC, iZSC, iESC, iR, iFZ, iFEP: Bool .

free_input_signals(iC, iZSC, iESC, iR, iFZ, iFEP)) ||

command(6, true) ||
command(8, true))

]X(iZeroPosSensor, iZeroPosSensorConnected, iForceEnablingToZeroPos) &&
[state_M2’oInZeroPosition(true)]false))

11. Whenever output signal oInEndPosition is true, and input iEndPosSensor
and input iZeroPosSensor are both true, inevitably oInEndPosition be-
comes false unless input iZeroPosSensor becomes false or input signal
iZeroPosSensorConnected becomes false.
This is formalized as follows.

nu X(inEndPos: Bool = false, iZeroPos: Bool = false, iEndPos: Bool = false) .

(forall e: Bool . <state_M2’oInEndPosition(e)>true =>

Title Suppressed Due to Excessive Length

31

(forall b,c: Bool . [inputs(b, c)]X(e,b,c) &&
[!exists a1,a2: Bool .inputs(a1, a2)]X(e,iZeroPos,iEndPos))) &&

(forall e: Bool . [state_M2’oInEndPosition(e)]false =>
(forall b,c: Bool . [inputs(b, c)]X(inEndPos,b,c) &&
[!exists a1,a2: Bool .inputs(a1, a2)]X(inEndPos,iZeroPos,iEndPos))) &&

(val(inEndPos && iZeroPos && iEndPos) =>

mu X.[!((exists iESP:Bool . inputs(false,iESP)) ||

(exists a,c,d,e,f:Bool . free_input_signals(a,false,c,d,e,f)) ||
(exists b:Bool . state_M2’oValveMoveToZeroPos(b) ||

state_M2’oValveMoveToEndPos(b) ||
state_M2’oInZeroPosition(b) ||
state_M2’oInEndPosition(b) ||
state_M2’oEnabled(b)) ||
(exists i:Nat,l:List(Nat) . states(i,l))

)]X || <state_M2’oInEndPosition(false)>true)

This property is similar to requirements 2 and 5. The formula uses a great-
est ﬁxed point (nu) and a least ﬁxed point (mu). The greatest ﬁxed point is
parameterized by the Boolean variables inEndPos, iZeroPos and iEndPos
that are used to keep track of whether output signal oInEndPosition or
input iEndPosSensor or input iZeroPosSensor have become true, respec-
tively. In order to keep track of these values, we distinguish two cases as in Re-
quirement 2. Now, if oInEndPosition is true, and both iEndPosSensor and
iZeroPosSensor are true, the least ﬁxed point subformula needs to hold.
In the least ﬁxed point subformula we need to exclude the paths through
the self-loops and those in which input iZeroPosSensor or input signal
iZeroPosSensorConnected becomes false.

12. Invariantly, oValveMoveToZeroPos and oValveMoveToEndPos are not true

at the same time.
This formalized as follows.

[true*]!(<state_M2’oValveMoveToZeroPos(true)>true &&

<state_M2’oValveMoveToEndPos(true)>true)

This is a straightforward invariant that relies on the self-loops exposing the
values of the outputs.

B Additional state machine diagrams

For the sake of completeness, we here include the remaining two state machine
diagrams MovingToZeroPosition, in Figure 13, and InZeroPosition, in Fig-
ure 14.

Substatemachine MovingToZeroPosition is symmetric to substatemachine
MovingToEndPosition, in Figure 10. Subdiagram InZeroPosition is symmet-
ric to InEndPosition, which was shown in Figure 11. We refer to Section 3 for
an explanation of the state machine diagrams.

32

Anna Stramaglia and Jeroen J.A. Keiren

Fig. 13: Substatemachine MovingToZeroPosition

Fig. 14: State machine diagram InZeroPosition

