BFL: a Logic to Reason about Fault Trees

Stefano M. Nicoletti∗
E. Moritz Hahn∗
∗University of Twente, Formal Methods and Tools, Enschede, the Netherlands.
†Radboud University, Department of Software Science, Nijmegen, the Netherlands.
{s.m.nicoletti,e.m.hahn,m.i.a.stoelinga}@utwente.nl

Mariëlle Stoelinga∗†

Abstract—Safety-critical infrastructures must oper-
ate safely and reliably. Fault tree analysis is a wide-
spread method used to assess risks in these systems:
fault trees (FTs) are required — among others — by
the Federal Aviation Authority, the Nuclear Regulatory
Commission, in the ISO26262 standard for autonomous
driving and for software development in aerospace sys-
tems. Although popular both in industry and academia,
FTs lack a systematic way to formulate powerful and
understandable analysis queries. In this paper, we aim
to ﬁll this gap and introduce Boolean Fault tree Logic
(BFL), a logic to reason about FTs. BFL is a simple,
yet expressive logic that supports easier formulation of
complex scenarios and speciﬁcation of FT properties.
Alongside BFL, we present model checking algorithms
based on binary decision diagrams (BDDs) to analyse
speciﬁed properties in BFL, patterns and an algorithm
to construct counterexamples. Finally, we propose a
case-study application of BFL by analysing a COVID19-
related FT.

I. Introduction

Our self-driving cars, power plants, and transportation
systems must operate in a safe and reliable way. Risk as-
sessment is a key activity to identify, analyze and prioritize
the risk in a system, and come up with (cost-)eﬀective
countermeasures.

Fault tree analysis (FTA) [1, 2] is a widespread formal-
ism to support risk assessment. FTA is applied to many
safety-critical systems and the use of fault trees is required
for instance by the Federal Aviation Authority (FAA), the
Nuclear Regulatory Commission (NRC), in the ISO 26262
standard [3] for autonomous driving and for software de-
velopment in aerospace systems. A fault tree (ft) models
how component failures arise and propagate through the
system, eventually leading to system level failures. Leaves
in a ft represent basic events (bes), i.e. elements of the
tree that need not be further reﬁned. Once these fail,
the failure is propagated through the intermediate events
(ies) via gates, to eventually reach the top level event
(TLE), which symbolizes system failure. In the (sub)tree
represented in Fig. 1, the tle— Existence of COVID-19
Pathogens/Reservoir — is reﬁned by an OR-gate (CP/R).
For CP/R to fail, either pathogens must exist on the

partially
(PrimaVera),

by
the NWO grant
*This work was
the European Union’s
NWA.1160.18.238
Horizon 2020 research and innovation programme under
the
Marie Skłodowska-Curie grant agreement No 101008233, and the
ERC Consolidator Grant 864075 (CAESAR).

funded
and

Figure 1: A simple FT (excerpt from Fig. 2).

workplace, i.e., Existence of COVID-19 Pathogens (CP),
or there must be an infected object of some kind, i.e.,
Existence of COVID-19 Reservoir (CR) has to happen.
Both CP and CR are AND-gates: for them to fail, all
their respective children need to fail. For CP this means
that an Infected worker joining the team (IW ) and a
failure in detecting this, i.e., Detection error (H3 ) must
happen. For CR this means that an Infected object used
by the team (IT ) and a General disinfection error (H2 )
must happen. Fault tree analysis supports qualitative and
quantitative analysis. Qualitative analysis aims at pointing
out root causes and critical paths in the system. Typically,
one identiﬁes the minimal cut sets (mcss) of a ft, i.e.
minimal sets of bes that, when failed, cause the system
to fail. One can also identify minimal path sets (mpss), i.e.
minimal sets of bes that - when operational - guarantee
that the system will remain operational. Quantitative
analysis allows to compute relevant dependability metrics,
such as the system reliability, availability and mean time to
failure. A formal background on fts is provided in Sec. II.
In spite of their popularity, fts lack a systematic way
to formulate powerful yet understandable analysis quer-
ies. The qualitative and quantitative analysis questions
mentioned above are formulated by ad hoc means. In
particular, if scenarios are analysed, the fault tree has to
be altered, for instance if one likes to compute the system
reliability given that certain subsystems have failed.

Boolean Fault tree Logic:
In this paper, we aim to
ﬁll this gap and introduce BFL, a Boolean logic to reason
about fts. BFL is based on concrete insights and needs
gathered through series of questions targeted at a ft
practitioner from industry [4]. In this paper, we aim to
ﬁll this gap and introduce BFL, a Boolean logic to reason
about fts. BFL is based on concrete insights and needs

1

CP/RCRCPITH2IWH3Existence of COVID-19Pathogens/ReservoirExistence of COVID-19PathogensExistence of COVID-19Reservoirgathered through series of questions targeted at a ft
practitioner from industry [4]. The atomic propositions in
this logic are the ft elements, i.e., both the bes and the
ies. As usual, formulae can be combined through Boolean
connectives. Furthermore, we include operators for setting
evidence, and for mcss and mpss. In this way, we obtain
a simple, yet expressive logic to reason about fts that
supports easier formulation of scenarios. Among others:

• We can set evidence to analyse what-if scenarios. E.g.,
what are the mcss, given that be A or subsystem B
has failed? What are the mpss given that A or B
have not failed?

• We can check whether two elements are independent
or if they share a children that can inﬂuence their
status.

• We can check whether the failure of one (or more)

element E always leads to the failure of tle.

• We can set upper/lower boundaries for failed ele-
ments. E.g., would element E always fail if at most/at
least two out of A, B and C were to fail?

b

for which T, b

Moreover, if a property does not hold, BFL allows us to
generate counterexamples, to show why the property fails.
E.g., if some set S is not a mcs, we can generate additional
bes e1, ..en that need to fail in order for S to be a mcs.
Model checking: As a ﬁrst step, we focus on non-
probabilistic logic to set a robust baseline that can be
easily extended, focusing on useful algorithms and counter-
example generation. We present algorithms to answer two
model checking queries and we discuss a third scenario.
First, we propose an algorithm to check if T, b |= χ holds,
i.e. if a BFL formula χ holds for a given ft T and a status
vector b . The latter indicates, for each be in T, whether
that be has failed. Second, we present a procedure that
computes all status vectors
|= χ
holds. Finally, given b and χ, we reﬂect on procedures to
synthesize, if it exists, a ft T such that T, b |= χ holds.
The algorithms exploit clever manipulations of Binary
Decision Diagrams (bdds). In order to translate formulae
to bdds, we identify ft elements that appear in a given
formula. We then construct bdds only for these elements
and store the resulting bdds in case they are needed in
further computations. Finally, we manipulate these bdds
to reﬂect the semantics of the operators in BFL. Once the
bdd for the formula is obtained, we either walk down
from the root node following truth assignments given in a
speciﬁc vector b or — if no vector is given — we collect
every path that leads to the terminal 1 to compute all
for that formula. bdds are natur-
satisfying vectors
ally applicable to fts, since fts are essentially Boolean
functions and bdds provide compact representations of
Boolean functions. Thus, BDDs are heavily exploited in
fault tree analysis [1, 5, 6].

b
(cid:74)

(cid:75)

(cid:74)

(cid:75)

Counterexamples: Moreover, we provide an algorithm
and several patterns to construct counterexamples. We
showcase them by selecting some example formulae and we

2

represent resulting counterexamples. Given a status vector
b and a formula χ, if b does not satisfy χ we compute a
new b0 such that b0 |= χ for the given T. We then represent
how failures propagate through T in light of the newly
found vector.

Contributions: To summarize, in this work:
1) We develop a logic for fts that enables the con-
struction of complex queries, to express numerous
relevant scenarios.

2) We provide model checking algorithms to check

properties deﬁned in the logic.

3) We present an algorithm and patterns to construct

and represent useful counterexamples.

4) We showcase the potential of our logic by applying
it to a medium-sized COVID-19 related example.

Related work: Numerous well-known logics describe
properties of state-transition systems, such as labelled
transition systems and Markov models. Examples com-
prise CTL [7], LTL [8], and their variants for Markov
models, PCTL [9] and PLTL [10]. State-transition sys-
tems are usually not written by hand, but result as the
semantics of high-level description mechanisms, such as
AADL [11], the hardware description language VHDL [12]
or model description languages such as JANI [13] or
PRISM [14]. These logics are thus not used to reason about
the structure of such models (e.g. the placement of circuit
elements in a VHDL model or the structure of modules
in a PRISM model), but on the temporal behaviour of
the underlying state-transition system. Similarly, related
work on model checking on fts [15, 16, 17, 18] exhibits
signiﬁcant diﬀerences: these works perform model checking
by referring to states in the underlying Markov model,
not to events in the given ft. We develop a logic to
express properties over fts and present counterexamples
generation methods on the level of fts. Since existing
counterexample generation methods [19] works on the
underlying Markov models, it is diﬃcult to relate these
to the ft. Another related line of work are software spe-
ciﬁcation languages, such as the Java Modelling Language
(JML) [20]. JML uses Hoare style pre- and postconditions
and invariants, to prove the correctness of programs using
the design by contract paradigm. Logics operating on
the structure of high-level description mechanisms (other
than FTs) exist. The Object Constraint Language (OCL)
for UML is a textual query and description language
developed by IBM [21]. [22] uses description logic (DL) to
detect and resolve consistency conﬂicts between (diﬀerent
versions of) UML diagrams.
is involved with the
automatic analysis of UML class diagrams using DL. In
[24], the author provides a formulation of Pandora, a logic
for the qualitative analysis of temporal fts. In spite of
the use of logic to capture ft properties, [24] focuses on
the analysis of time, introducing gates that are diﬀerent
from the ones considered in this work: the Priority-AND-

[23]

gate (PAND), the Simultaneous-AND-gate (SAND), and
the Priority-OR gate (POR). In BFL we do not (yet)
consider time and we focus on AND, OR and VOT-gates
in order to create a ﬂexible yet powerful logic that can be
further extended in the future. Furthermore, [24] focuses
more on the algorithmic part of FTA while leaving out
any formalization of fts or the logic deﬁned upon. To
the best of our knowledge, no other work considers the
option of developing a logic speciﬁc to fts. Literature
related to fts and bdds is opportunely referenced and
contextualized in Sec. II and Sec. V.

Structure of the paper: Sec. II provides background
on fts, Sec. III showcases the logic, Sec. IV shows how
ft properties can be speciﬁed in BFL, Sec. V presents our
model checking algorithms, Sec. VI constructs and repres-
ents useful counterexamples, Sec. VII shows an application
of our logic to a medium-sized case study and Sec. VIII
concludes the paper and reﬂects on future work.

II. Fault Trees: Background
Developed in the early ’60s [25], fts are directed acyclic
graphs (dags) that model how low-level
failures can
propagate and cause a system-level failure. The overall
failure of a system is captured by a top level event (tle),
that is reﬁned through the use of gates. fts come with
diﬀerent gate types. For the purposes of our paper, we
will focus on static fault trees, featuring OR-gates, AND-
gates and VOT(k/N)-gates. In order for a low-level failure
to propagate, at least one child of an OR-gate has to fail,
all the children of an AND-gate must fail, and at least
k out of N elements must fail for a VOT(k/N )-gate to
fail. When gates can no longer be reﬁned, we reach the
basic events (bes) which are the leaves of the tree. fts
enable both qualitative and quantitative analyses. On the
qualitative side, minimal cut sets (mcss) and minimal
path sets (mpss) have a paramount role in highlighting
root causes of failures and critical paths in the system.
mcss are minimal sets of events that - when failed - cause
the failure of the tle. mpss are minimal sets of events
that - when remaining operational - guarantee that the
tle will remain operational.

Deﬁnition 1 (Fault Tree). A Fault Tree is a 4-tuple T =
hBE, IE, t, chi consisting of the following components:

• BE is the set of basic events.
• IE is the set of intermediate elements with BE∩IE = ∅.
Let etop ∈ IE be the top element of the fault tree.

• E = BE ∪ IE is the set of all the elements.
• t : IE → GateTypes is a function that maps each inter-
mediate element to its gate type, with GateTypes =
{AND, OR}.

• ch : IE → P(E)\∅ is a function that maps each
intermediate element to its children (its inputs). With
e ∈ IE, we require that ch(e) 6= ∅.

G = hE, chi must be acyclic with a unique root in etop
that is reachable from all other nodes.

We can extend GateTypes with any gate derived from
AND and OR-gates. E.g., we can add VOT(k/N ) by ex-
tending GateTypes as follows: GateTypes = {AND, OR} ∪
{VOT(k/N ) | k, N ∈ N>1, k ≤ N }. Furthermore, it suﬃces
to require that |ch(e)| = N if t(e) = VOT(k/N ). The
behaviour of a ft T can be rigorously expressed through
its structure function [1] - ΦT: if we assume the convention
that a be has value 1 if failed and 0 if operational, the
structure function indicates the status of the tle given
the status of all the bes of T.

Deﬁnition 2 (Structure Function). The structure func-
tion of a fault tree T is a function ΦT : Bn × E → B
that takes as input a status vector b = (b1, . . . , bk) of k
Booleans, where bi = 1 if the i-th be has failed and bi = 0
if it is operational, and an arbitrary element e ∈ E.

bi

ΦT(b , e0)

W
e0∈ch(e)
V
e0∈ch(e)

if e = ei ∈ BE
if e ∈ IE and t(e)=OR

ΦT(b , e) =



for each set of bes we can identify its char-
Thus,
acteristic vector b. Note that the semantics for e ∈
IE and t(e)=VOT(k/N ) is given by
(cid:18)

if e ∈ IE and t(e)=AND

ΦT(b , e0)

(cid:19)

Σ
e0∈ch(e)

ΦT(b , e0)

≥ k

Next we deﬁne the classical notions of minimal cut sets
and minimal path sets [1]. A cut set is any set of basic
events that causes the tle to occur, i.e., for which the
structure function evaluates to 1. A path set is any set of
basic events that does not cause the tle to occur, i.e.,
for which the structure function evaluates to 0.

Deﬁnition 3. A status vector b is a cut set (CS) for
element e ∈ E of a given tree T if ΦT(b , e) = 1. A
minimal cut set (MCS) is a cut set of which no subset
is a cut set. Formally: b is a MCS for e ∈ E of T if
ΦT(b , e) = 1 ∧ ∀b0 ⊂ b , ΦT(b , e) = 0.

Deﬁnition 4. A status vector b is a path set (PS) for
element e ∈ E of a given tree T if ΦT(b , e) = 0. A minimal
path set (MPS) is a path set of which no subset is a path
set. Formally: b is a MPS for e ∈ E of T if ΦT(b , e) =
0 ∧ ∀b0 ⊂ b , ΦT(b , e) = 1.
The ft in Fig. 1 has two minimal cut sets: {IW , H3 } and
{IT , H2 }. Its minimal paths sets are {IW , IT }, {IW , H2 },
{H3 , IT }, and {H3 , H2 }.

III. A Logic to Reason about FTs

A. Syntax

In order to be meaningful, FTs have to meet the fol-
lowing well-formedeness condition: the graph formed by

Below, we present the syntax of BFL. The atomic
propositions in BFL can be any ft element e. As usual,

3

formulae can be combined through Boolean connectives.
Furthermore, we can set evidence: φ[e 7→ 0] sets the
element e to 0, and φ[e 7→ 1] sets e to 1. Finally, BFL
allows reasoning about mcss.

We construct our logic on two syntactic layers, repres-
ented with φ and ψ. With χ we will refer to any formula
in either the ﬁrst or the second layer. Formulae in the ﬁrst
layer are evaluated on a single status vector, while for-
mulae in the second layer allow quantiﬁcation over status
vectors. Further, the IDP operator expresses whether two
formulae are independent, i.e. whether there is no event
which inﬂuences the truth value of both formulae.

φ ::= e | ¬φ | φ ∧ φ | φ[e 7→ 0] | φ[e 7→ 1] | MCS(φ)
ψ ::= ∃φ | ∀φ | IDP(φ, φ)

Note that φ[e 7→ 0] is not equivalent to φ ∧ ¬e. Taking
φ equal to ¬e, we will have that (¬e)[e 7→ 0] evaluates to
true, while (¬e)∧¬e is equivalent to ¬e. Moreover, we have
operators to express mcss for a given formula: in addition
to mcss for tle, we can evaluate whether a given status
vector is a mcs for an intermediate event (recall Def. 3).
Lastly, the second layer provides us with the possibility to
quantify over formulae and to check if two formulae (e.g.,
two intermediate events) are independent. We consider two
formulae to be independent whenever they do not share
any inﬂuencing basic event (IBE) i.e., any event the value
of which inﬂuences the truth value of the given formulae.
Syntactic sugar: We deﬁne several derived operators.
Apart from extra Boolean operators, mpss denotes the
minimal path sets, and SUP(e) means that event e ∈ E
is superﬂuous, i.e., its value does not inﬂuence the tle.
(φ1, . . . , φN ) holds if at
Finally, the voting operator Vot
≥k

least k of the formulae φ1, . . . , φN hold.

φ1 ∨ φ2 ::=¬(¬φ1 ∧ ¬φ2)
φ1 ⇒ φ2 ::=¬(φ1 ∧ ¬φ2)
φ1 ≡ φ2 ::=(φ1 ⇒ φ2) ∧ (φ2 ⇒ φ1)
φ1 6≡ φ2 ::=¬(φ1 ≡ φ2)
mps(φ) ::=mcs(¬φ)
SUP(e) ::=IDP(e, etop)

(φ1, . . . , φN ) ::=

Vot
./k

_

U ⊆{1,...,N }
|U |./k



!

φu

∧



^



¬φu



u∈{1,...,N }\U

^

u∈U

Here, we have k ≤ N and ./ ∈ {<, ≤, =, ≥, >}.

B. Semantics

The semantics of BFL is given by the satisfaction
relation |=, which expresses whether a formula φ holds
for a ft T under the status vector b = (b1, . . . , bk). The
satisfaction for events e, Boolean connectives and setting
evidence are straightforward. For the MCS operator, we
have b , T |= MCS(φ) iﬀ b is a minimal vector that satisﬁes
φ, i.e., b satisﬁes φ, but if we change some bi = 0 into

4

bi = 1, then the vector no longer satisﬁes φ. In particular,
b , T |= MCS(etop) means that b is a minimal cut set for
the tle of T .

b , T |= e

iﬀ ΦT(b , e) = 1
iﬀ b , T 6|= φ
b , T |= ¬φ
iﬀ b , T |= φ and b , T |= φ0
b , T |= φ ∧ φ0
b , T |= φ[ei 7→ 0] iﬀ b0 , T |= φ with b0 = (b0

1, . . . , b0

n) where

i = 0 and for j 6= i we have b0
b0

j = bj

b , T |= φ[ei 7→ 1] iﬀ b0 , T |= φ with b0 = (b0

1, . . . , b0

n) where

i = 1 and b0
b0

j = bj for j 6= i

b , T |= MCS(φ) iﬀ b , T |= φ ∧ (¬∃b0. b0 ⊂ b ∧ b0, T |= φ)

φ

we denote the satisfaction set of vectors for φ,
With
i.e., the set containing all status vectors that satisfy φ. We
deﬁne semantics for the second syntactic layer as:

(cid:75)

(cid:74)

T |= ∃φ

iﬀ ∃b. b , T |= φ

T |= ∀φ
T |= IDP(φ, φ0)

iﬀ ∀b. b , T |= φ
iﬀ IBE(φ) ∩ IBE(φ0) = ∅

Here IBE is the set of inﬂuencing basic events deﬁned as:

IBE(φ) ={e ∈ BE | ∃b. b , T |= φ[e 7→ 0] and

b , T 6|= φ[e 7→ 1] or vice-versa}

Thus, IBE(φ) returns the set of bes that inﬂuence the
truth value of φ. Two events are independent if they do
not share any IBEs.

Example 1. If we wanted to know whether the failure
of the AND-gate CP in Fig. 1 implies the failure of the
tle CP/R for every possible truth assignment on bes
we would write ∀(CP ⇒ CP/R). If we wanted to check
whether it exists an assignment such that both CP and
CR fail, we would write ∃(CP ∧ CR). The same holds for
∨. Finally, if we wanted to check whether a speciﬁc vector
b represents a mcs/mps for CP/R, given b we would
write MCS(CP/R)/MPS(CP/R).

IV. COVID Case Study: modeling

To illustrate our logic, we formulate several properties
for a ft that models COVID-19 infection risks at con-
struction sides. This FT is a slightly modiﬁed version of
[26], and is displayed in Fig. 2.
COVID-19 fault tree: The tle for this tree rep-
resents a COVID-19 infected worker on site, abbreviated
IWoS. As shown in Fig. 2, the ft considers events in
several categories: COVID-19 pathogens and reservoirs
(i.e., germs and objects carrying the virus); their mode of
transmissions; the presence of susceptible hosts, infected
objects and workers; physical contacts; the status, as well
as human errors. Note that Figure 2 contains several re-
peated basic events: IT , PP, H1 and IW occur at multiple
places in the tree and refer to the same basic event. This
tle IWoS is reﬁned via an AND-gate with three children.

 
Thus, for the TLE to occur the following must happen:
COVID pathogens/COVID infected objects must exist,
there has to be a susceptible host and COVID pathogens
must be transmitted in some way to this host. These
three events are captured by corresponding subtrees: the
purple
purple OR-gate CP/R reﬁnes the existence of COVID
pathogens/COVID infected objects, the OR-gate MoT in
teal reﬁnes modes of transmission and the AND-gate SH
teal
in orange
orange reﬁnes the presence of a susceptible host. In
order to further reﬁne these trees in a realistic way, the ft
contains duplicated leaves, e.g., Physical Proximity (PP)
occurs twice.

Properties: Following, we specify some properties us-
ing natural language and present the corresponding BFL
formulae:

• Is an infected surface suﬃcient for the transmission

of COVID?

∀(IS ⇒ MoT )

• Does the occurrence of Mode of Transmission require

human errors?

∀(MoT ⇒ (H1 ∨ H2 ∨ H3 ∨ H4 ∨ H5 ))

• Is an object disinfection error suﬃcient for the occur-

rence of tle?

∀(H4 ⇒ IWoS)

• Are at least 2 human errors suﬃcient for the occur-

rence of tle?

∀(Vot
≥2

(H1 , . . . , H5 ) ⇒ IWoS)

V. Model Checking Algorithms

We present two model checking procedures for BFL.
1) Given a speciﬁc vector b, a ft T and a formula χ,

check if b , T |= χ (Sec. V-C),

2) Given a ft T and a formula χ, compute all vectors

b such that b , T |= χ (Sec. V-D),

Furthermore, we oﬀer some observations on the following
problem: given a Boolean vector b and a formula χ,
compute a ft T such that b , T |= χ (Sec. V-E). Note that
the ﬁrst question, checking if b , T |= χ holds, is trivial if
χ = φ is a level-1 formula that does not contain an MCS
or MPS operator. In that case, we can simply substitute
the values of the b in φ and see if the Boolean expression
evaluates to true. For the other cases, the computation
becomes more complex, and we resort to binary decision
diagrams (bdds). Concretely, to translate formulae to
bdds, we identify ft elements that appear in a given
formula. We selectively construct bdds for these elements
and store the resulting bdds (see Algo. 1): by doing so,
we reduce computation time in case they are needed for
other formulae. Finally, we manipulate these bdds to
reﬂect semantics of the operators in BFL. This translation
to BDDs constitutes a formal ground that permits to
address the aforementioned procedures in a uniform way.
In particular, once the bdd for the formula is obtained, we
can address the ﬁrst and second scenarios. In the former,
we walk down the bdd from the root node following truth
assignments given in a speciﬁc vector b . In the latter —
where no vector is given — we collect every path that leads
to the terminal 1 to compute all satisfying vectors
for
the given formula.

b

(cid:74)

(cid:75)

• What are all the mcss for tle that include errors

A. Binary decision diagrams

in disinfecting objects?

MCS(IWoS) ∧ H4

(cid:74)

(cid:75)

• Is not committing any human error suﬃcient to pre-

vent the occurrence of tle?

∃MPS(IWoS)[H1 7→ 0, H2 7→ 0, H3 7→ 0,

ei∈BE\{H1 ,...,H5 }

H4 7→ 0, H5 7→ 0, ei 7→ 1]

• What are the minimal ways to prevent the tle?

• Are a contact with an infected object and a contact

MPS(IWoS)
(cid:75)
(cid:74)

with an infected surface independent scenarios?

IDP(CIO, CIS)

• Is physical proximity superﬂuous for the occurrence

of tle?

SUP(PP)

bdds are directed acyclic graphs (dags) that oﬀer
a compact way to represent Boolean functions [27] by
reducing redundancy. bdd’s size can grow linearly in the
number of variables and at worst exponentially, depending
on variable’s ordering. In practice, bdds are heavily used
in various application areas, including in ft analysis and
in their security-related counterpart, attack trees (ats)
[5, 28].
Formally, a bdd is a rooted dag Bf that represents
a Boolean function f : Bn → B over variables Vars =
{xi}n
i=1. The outcomes of f - 0 or 1 - are represented by
the terminal nodes of Bf . A non terminal node w ∈ W
represents a subfunction fw of f via its Shannon expan-
sion [27]. In other words, w is equipped with a variable
Lab(w) ∈ Vars and two children: Low(w) ∈ W , that
represents fw in case that the variable Lab(w) is set to
0; and High(w), representing fw if Lab(w) is set to 1.

Deﬁnition 5. A BDD is a tuple B = (W , Low, High, Lab)
over a set Vars where:

• The set of nodes W is partitioned into terminal nodes

A thorough analysis of these properties is conducted in
Sec. VII.

(Wt) and non terminal nodes (Wn);

• Low : Wn → W maps each node to its low child;

5

Figure 2: COVID-19 ft.

• High : Wn → W maps each node to its high child;
• Lab : W → {0, 1} ∪ Vars maps terminal nodes to

Booleans, and non terminal nodes to variables:
if w ∈ Wt,
if w ∈ Wn.

{0, 1}
Vars

Lab(w) ∈

(

Moreover, B satisﬁes the following constraints:

• (W , E) is a connected DAG, where

E = {(w, w0) ∈ W 2 | w0 ∈ Low(w) ∪ High(w)};

• B has a unique root, denoted RB:

∃! RB ∈ W . ∀w ∈ Wn. RB 6∈ Low(w) ∪ High(w).

Figure 3: A simple ft (OR-gate) and its bdd.

Reduced ordered BDDs: Conventionally, the term
bdds is often used as a shorthand acronym for reduced
ordered bdds, or ROBDDs [29, 30]. ROBDDs are bdds
in which the variables occur in a given order on all the
paths of the bdd, no two distinct nodes have the same
variable name and (high and low) successors, and no single
node has identical (high and low) successors [27]. As such,
a total order < over the variables is needed. Formally, this
means that:

• Vars are equipped with a total order, Bf is thus

previously mentioned, to translate formulae to bdds, we
ﬁrst identify ft elements that appear in a given formula.
We selectively construct bdds for these elements and
store them. This allows us to reduce computation time in
case they are needed to construct bdds for other formulae
that include the same ft elements. Finally, we manip-
ulate these bdds to reﬂect semantics of the operators
in BFL. Operations between bdds are represented by
bold operands e.g., ∧, ∨. Operands can be applied by
following Algo. 5.15 [29] Apply and subsequently applying
Algo. 5.3 Reduce [29] to ensure the resulting bdd is
reduced. Following, we assume to always apply Reduce
after Apply. Quantiﬁcation can be achieved by applying
Algo. 5.15 [29] Apply and Algo. 5.20 [29] Restrict as
shown in Theorem 5.23 [29]. In particular, given a set of
variables V = {v1, . . . , vn}, existential quantiﬁcation can
be deﬁned as follows:

∃v.B = Restrict(B, v, 0) ∨ Restrict(B, v, 1)
∃V.B = ∃v1.∃v2. . . . ∃vn.B

Translating FTs to BDDs: Firstly, we will deﬁne a
translation from fts to bdds. In the following paragraphs
we assume Vars = V ˙∪ V0, where the set of variables V = BE
and the set of primed variables V0 = {e0|e ∈ BE}. Further-
more, we deﬁne Var B : BDD → Vars to be a function that
returns variables occurring in a bdd. Let ΨFT : E → BDD
be a function that takes elements of a ft as input and
maps them to bdds. ΨFT is deﬁned as follows:

• the

variable

deﬁned over a pair hVars, <i;
node
∀ w

than
Lab(Low(w)), Lab(High(w));

of
a
children:

its

of

is
∈ Wn. Lab(w)

lower

order
<

Deﬁnition 6. The translation function of a FT T is a
function ΨFTT : E → BDD that takes as input an element
e ∈ E. With e0 ∈ ch(e), we can deﬁne ΨFTT:

• the children of non terminal nodes are distinct nodes;
• all terminal nodes are distinctly labelled.

ROBDDs exhibit the following characteristics: 1) there are
exactly two terminal nodes: Wt = {⊥,>}, with Lab(⊥) = 0
and Lab(>) = 1; 2) the label of the root node RB has the
lowest order; 3) in any two paths from RB to ⊥ or >,
variables appear in the same (increasing) order.

B. Algorithm 1: Translating FTs/formulae to BDDs
Translations: As a ﬁrst step, we will deﬁne bdd
translations for both fts and formulae in the logic. As

ΨFTT (e) =

B(e)
WWWΨFTT(e0)
VVVΨFTT(e0)
k
VVV
WWW
n1,...,nk
i=1
n1<...<nk




if e ∈ BE
if e ∈ IE and t(e) = OR
if e ∈ IE and t(e) = AND

ΨFTT (e0
ni

) if e ∈ IE and t(e)=VOT(k/N )

Where B(v) is a BDD with a single node in which
Low(v) = 0 and High(v) = 1.

6

IWoSCP/RSHMoTCRCTDTATCVTUTH1ITH2CIWCIOCISIWPPIWVWABIWH1MVITH1MH1H4ISH1MH2H5H1PPIWCPIWH3e1e2eTope110e2Fig. 3 represents a simple ft i.e., a single OR-gate, and
its translation to bdds.
Translating formulae: Knowing how to compute
bdds for fts, we can now show how to manipulate them
in order to mirror BFL operators. I.e., given ΨFT and a
ft T, for every BFL formula χ in the set of BFL formulae
X we can now show a translation to bdds BT : X → BDD
in Algo. 1. The implementation of this procedure would
abide the dynamic programming standards: by simple
caching, we would be able to reuse the translation of
(sub)trees and (sub)formulae between diﬀerent analyses
without recomputing them each time anew.

Algorithm 1 Given χ and T, compute BT(χ)

Input: ft T, formula χ
Output: BT(χ)
Method: Compute BT(χ) according to the recursion
scheme below. Store intermediate results BT(· · ·) and
ΨFTT (· · ·) in a cache in case they are used several times.

ΨF TT(e)
¬(BT(φ))
BT(φ) ∧ BT(φ0)

Recursion scheme:
BT(e) :
BT(¬φ) :
BT(φ ∧ φ0) :
BT(φ[ei 7→ 0]) : Restrict(BT(φ), ei, 0)
BT(φ[ei 7→ 1]) : Restrict(BT(φ), ei, 1)
BT(MCS(φ)) :

BT(φ) ∧ (¬∃V0.BT(V0 ⊂ V)∧
BT(φ)[V (cid:121) V0]) where:
^
v0
BT(V0 ⊂ V) ≡ BT(
k ⇒ vk)∧

_

BT(

v0
k 6= vk)

k

BT(∃φ) :
BT(∀φ) :
BT(IDP(φ, φ0)) :

k
∃V.BT(φ)
¬∃V.¬BT(φ)
1 iﬀ {Var B(BT(φ)) ∩Var B(BT(φ0))} = ∅

where BT(φ)[V (cid:121) V0] indicates the bdd BT(φ) in which
k ∈ V0.
every variable vk ∈ V is renamed to its primed v0
To perform existential and universal quantiﬁcation over
formulae in this translation - i.e., utilizing the second layer
in the syntax of BFL - it would also suﬃce to check if the
resulting bdd for the formula χ is not equivalent to the
terminal node 0 in the case of existential quantiﬁcation
and to check if the bdd for χ is equivalent to the bdd
for the terminal node 1 in case of universal quantiﬁcation.

C. Algorithm 2: Model checking BFL over a FT and a b
Overview: As mentioned, given a speciﬁc vector b, a ft
T and a formula χ, we want to check if b , T |= χ. To do
so, we translate the given formula to a bdd and then we
walk down the bdd from the root node following truth
assignments given in the speciﬁc vector b .

7

Algorithm 2 Check if b , T |= χ, given b, T and χ.
Input: Boolean vector b , ft T and a formula χ
Output: True iﬀ b , T |= χ, False otherwise
Method:
compute BT(χ) via Algo. 1
Starting from bdd root,
while current node wi of BT(χ) 6∈ Wt do:

if bi ∈ b = 0 then:
wi = Low(wi)

else if bi ∈ b = 1 then:
wi = High(wi)

end if
end while
if Lab(wi) = 0 then:
return False

else if Lab(wi) = 1 then:

return True

end if

Algo. 2: Algo. 2 shows an algorithm to check whether
b , T |= χ, given a status vector b , a ft T and a formula
χ. A bdd for the formula χ is computed with regard to
the structure function of the given ft T i.e., we compute
BT(χ) as per Algo. 1. Subsequently, the algorithm walks
down the bdd following the Boolean assignments given in
b : if the i-th element of b is set to 0 then the next node in
the path will be given by Low(wi), if it is set to 1 then the
next node will be High(wi). When the algorithm reaches
a terminal node it returns True if its value is one - i.e., if
b , T |= χ - and False otherwise.

Example 2. To showcase this pro-
cedure, we present the smallest pos-
sible example that still retains signi-
ﬁcance, by choosing a ft T with a
single OR-gate as a tle with two
bes as children. We will assume that
our formula χ is MCS(etop) and that
the given vector b is equal to (0, 1) for b1 and b2 respect-
ively. Fig. 3 shows a representation of this simple ft next
to its bdd. We then compute the bdd BT(MCS(etop))
for our formula and walk down the graph following the
low edge for w1 and the high edge for w2, as indicated
by the values in b . We end the algorithm in the terminal
node 1, thus knowing that b , T |= MCS(etop). The ﬁgure in
this paragraph represents the bdd for M CS(etop) for the
given ft: the path representing vector b is highlighted.

D. Algorithm 3: Computing all satisfying vectors

Overview:
In this subsection, we will address a diﬀerent
scenario: given a ft T and a formula χ, we want to
compute all vectors b such that b , T |= χ. In this scenario
no vector is given. Thus, we need to construct the bdd for
the given formula and then collect every path that leads
to the terminal 1 to compute all satisfying vectors
for
the given formula.

b

(cid:74)

(cid:75)

e11e2e110e2e2Algo. 3: To achieve the desired outcome we will con-
struct the bdd BT(χ) for the given formula following
Algo. 1. Then, the algorithm will walk down the bdd
and store all the paths that lead to the terminal node 1.
These paths represent all the status vectors that satisfy
our formula χ. The value for the elements of each vector
is set to 0 or 1 if the stored path follows respectively the
low or high edge of the collected elements of the bdd.
After computing the bdd for a given χ, AllSat [27]
will achieve the desider outcome. This algorithm returns
exactly all the satisfying assignments for a given bdd, i.e.,
in our case, all the vectors that satisfy our formula.

Example 3. To showcase this pro-
cedure,
let us present an example.
We consider the same ft presented
in Ex. 2, for which we do not have
a speciﬁc vector b to check against.
We choose again MCS(etop) as our
formula χ. In order to compute all the
mcss for etop, we ﬁrst construct the corresponding bdd
BT(MCS(etop)), then we apply AllSat [29]. We walk
down the bdd and collect all the nodes in paths that lead
to the terminal labelled with 1. By doing so, we obtain two
diﬀerent vectors b and b0 which respectively contain (0, 1)
and (1, 0) as the values for b1, b2 and b0
2, representing
the diﬀerent assignments that satisfy our formula given
the speciﬁc ft T. The ﬁgure in this paragraph represents
the bdd for MCS(etop): both the paths that represent
satisfying assignments for χ are highlighted.

1, b0

E. Computing a satisfying fault tree

In this section we will brieﬂy discuss the
Overview:
following problem: given a vector b and a formula χ, we
want to compute at least one ft T such that b , T |= χ.
Observations: A more trivial approach could consist in
trying to satisfy the given formula by keeping the values of
bes ﬁxed - as given in b - and trying out all possible truth
assignments for the other variables in the given χ, until
χ is satisﬁed. However, this procedure does not guarantee
that the resulting structure of the ft will be meaningful.
More complex procedures - out of the scope of this paper -
can infer the structure of a ft from given vector(s) b while
also considering other relevant properties of the tree, like
its complexity and the number of elements e.g., employing
genetic algorithms [31].

VI. Counterexamples

If a formula does not hold, it is important
Overview:
to know why this property fails. Counterexamples provide
such diagnostic information. Given a formula χ that is not
satisﬁed by the vector b , a counterexample is simply a new
vector b0 with minimal modiﬁcations s.t. it does satisfy χ.
We present an algorithm to compute such counterexamples
(see Algo. 4). In so doing, we can provide counterexamples
for signiﬁcant properties that can be captured by BFL.

Since the most common qualitative analyses on fts in-
volve mcss and mpss, we will focus on counterexamples
and present patterns for these operators. For example,
suppose we believe that the failure of {IW , H3 , IT } is a
mcs for the tle in T on the
right. Clearly, {IW , H3 , IT } is not
an mcs for T: it is a cut set but
not minimal. As highlighted in the
ﬁgure, a suitable counterexample is
a mcs contained in {IW , H3 , IT },
i.e., {IW , H3 }.
Counterexamples: We present our algorithm to com-
pute counterexamples and a corresponding deﬁnition:

Algorithm 4 Compute a counterexample b0 s.t.
b0, T |= χ, given b, T and χ, s.t. b , T 6|= χ.

Input: Boolean vector b, ft T and a formula χ
Output: counterexample vector b0
Method:
compute BT(χ) via Algo. 1
if 1 6∈ Wt then:
return

end if
Starting from bdd root,
while current node wi of BT(χ) 6∈ Wt do:

i = wi

w0
if bi ∈ b = 0 then:
wi = Low(wi)
b0
i = 0

else if bi ∈ b = 1 then:
wi = High(wi)
b0
i = 1
end if
if Lab(wi) = 0 then:
if bi ∈ b = 0 then:
wi = High(w0
i)
b0
i = 1

else if bi ∈ b = 1 then:

wi = Low(w0
i)
b0
i = 0
end if

end if
end while
set all values b0
values as according bi
return b0

i which have not been set to the same

Deﬁnition 7. Given a FT T, a Boolean vector b and a
formula χ such that b , T 6|= χ, a counterexample is a new
vector b0 such that b0, T |= χ. Further, for all b0
i 6= bi
we have that (b0
i+1, . . .), T 6|= χ.

i−1, bi, b0

i with b0

1, . . . , b0

The reason for Def. 7 is as follows: If we have a vector b
such that with this vector the ft and the formula are not
fulﬁlled, we want modify b to a b0 in such a way that the
ft and formula is indeed fulﬁlled. We also do not want to

8

e2e2e11e110e2e2CP/RCRCPITH2IWH3consider a completely diﬀerent vector b0, but one in which
the modiﬁcations performed are as small as possible. For
this reason, we require that we cannot change the value of
variables in b0 such that they are the same as in b without
invalidating the ft/formula combination. Algo. 4 works
as follows: We compute BT(χ) as per Algo. 1. Starting
with the ﬁrst variable in the variable order of the bdd,
we walk down the bdd. We follow the Low branch if
the according value in b is 0 and the High branch if it
is 1. If we do not end up at the 0 node, we continue
with the next variable. If however we end up at the 0
node, we revise our decision and instead take the other
branch of the bdd node. Decisions taken when descending
the bdd are stored in vector b0. For all bdds diﬀerent
from 0, we thus compute a b0 such that 1) it fulﬁls the
ft/formula combination and 2) the variable values where
it diﬀers from b cannot be changed without invalidating
the formula.

Deﬁnition 8. A pattern is a BFL formula where non-
terminal symbols might be present. A pattern matches a
formula whenever a valid BFL formula can be generated
from that pattern.

In light of Algo. 4 and making use of
patterns, we present a vector b , a tree T
— represented on the right — and one
or more example formulae χ. We then
construct a representation of failure
propagation of bes in T with respect to the truth as-
signments in b . In case b does not satisfy χ for T, we
present a new status vector that satisﬁes χ for T, via
Algo. 4. Furthermore, we represent this counterexample
and show how failure propagation on T diﬀers between the
example and its corresponding counterexample. Table I
collects example formulae, their visualization with respect
to given vectors, and corresponding counterexamples, both
visualized in T and represented as vectors. Let us consider
mcss and mpss. There are two general cases in which b
does not satisfy MCS(φ) or MPS(φ):

1) If b is a cut set/path set for χ, but is not minimal.
2) If b is not a mcs/mps for χ, i.e. it lacks elements.
Let pattern1 ::= MCS(φ) and
Patterns 1 and 2:
pattern2 ::= MPS(φ). Consider T and let the vector b
represent the ordered Boolean values for e2, e4, e5. For
χ = MCS(e1) and b representing respectively the failure
of e4 and e2, e4, e5 we would have the following vectors

Pattern

Example χ

Ex. vector

Ex. representation

Cex. vector

Cex. representation

pattern1 ::= MCS(φ)

MCS(e1)

b = (0, 1, 0)

b0 = (1, 1, 0)

b = (1, 1, 1)

b0 = (1, 0, 1)

pattern2 ::= MPS(φ)

MPS(e1)

b = (1, 0, 1)

b0 = (1, 0, 0)

b = (0, 0, 0)

b0 = (0, 1, 1)

pattern3 ::= MCS(φ1) ∧ . . . ∧ MCS(φn)

MCS(e1) ∧ MCS(e3)

b = (0, 1, 0)

b0 = (1, 1, 0)

pattern4 ::= MPS(φ1) ∧ . . . ∧ MPS(φn)

MPS(e1) ∧ MPS(e3)

b = (1, 0, 1)

b0 = (1, 0, 0)

Table I: A collection of patterns, exempliﬁcations through given χ and b, and the respective counterexamples.

9

e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3e4e5e2e1e3as counterexamples: b0 = (1, 1, 0) for the former and
b0 = (1, 0, 1) for the latter. While for χ = MPS(e1)
and b representing respectively events e4 and e2, e4, e5
being operational, we would have the following vectors
as counterexamples: b0 = (1, 0, 0) for the former and
b0 = (0, 1, 1) for the latter.
Patterns 3 and 4: Let pattern3 ::= MCS(φ1) ∧ . . . ∧
MCS(φn) and pattern4 ::= MPS(φ1) ∧ . . . ∧ MPS(φn).
Given a ft T and a vector b , these two patterns allow
us to check whether a given b represents a mcs/mps
for n gates in T. Given T and b representing the failure
of e4, we can check if b is a mcs for both e1 and e3 i.e.,
χ = MCS(e1)∧MCS(e3). The failure of e4 is not suﬃcient,
thus we present a counterexample vector b0 = (1, 1, 0).
The same procedure applied to mpss can be seen in
pattern4. Given the same ft and b representing e4 being
operational, we observe that b does not represent a mps
for both e1 and e3 i.e., χ = MPS(e1) ∧ MPS(e3). We
present a counterexample b0 = (1, 0, 0). Table I collects
these examples, alongside their graphical representations.

VII. COVID Case Study: Analysis

Overview:
In this section we discuss the case study of T
in Fig. 2 in light of the procedures described in Sec. V and
Sec. VI. For every property presented in Sec. IV, we discuss
whether it holds for the given tree in Fig. 2. Furthermore,
we present possible additional steps in the analysis of T
by leveraging the expressiveness of BFL. We then present
a meaningful excerpt of Fig. 2. Storm model checker [32]
is used in order to retrieve mcss/mpss whenever the cor-
responding operators appear in the following properties.
Analysis:

• Is an infected surface suﬃcient for the transmission

of COVID? ∀(IS ⇒ MoT )

This property does not
hold for the (sub)tree
we are considering (see
ﬁgure on the right). In
fact, the failure of IS
alone is not suﬃcient
for MoT to fail. We can
gather more informa-
tion about the role IS
has in the failure of MoT by computing mcss for MoT
and ﬁlter for IS:
. The result is a single
mcs containing {IS, H1 , H5 }. From this information we
can infer that an infected surface paired with a surface dis-
infection error and the non-respect of outbreak procedures
is suﬃcient for the transmission of COVID.

MCS(MoT ) ∧ IS

(cid:74)

(cid:75)

• Does the occurrence of Mode of Transmission require
human errors? ∀(MoT ⇒ (H1 ∨ H2 ∨ H3 ∨ H4 ∨ H5 ))
Checking this property would return False. In fact, there
are cases in which MoT would occur without the need of
any human error. E.g., in case of Droplet Transmission
(DT ) or Airborne Transmission (AT ).

10

• Is an object disinfection error suﬃcient for the occur-

rence of tle? ∀(H4 ⇒ IWoS)

This property does not hold for T. In fact, there are no
cases in which the failure of H4 alone is suﬃcient for the
failure of the tle (see Fig. 4).

Figure 4: (Sub)tree for property 3 (excerpt from Fig. 2).

• Are at least 2 human errors suﬃcient for the occur-

rence of tle? ∀(Vot
≥2

(H1 , . . . , H5 ) ⇒ IWoS)

Two or more human errors are not suﬃcient for the
occurrence of IWoS (see Fig. 5). However, we can further
investigate the role of human errors in the occurrence of
tle by asking which mcss require the presence of human
errors:
.
(MCS(IWoS) ∧ H1 ) ∨ . . . ∨ (MCS(IWoS) ∧ H5 )
By doing so we would obtain twelve mcss. In spite of
(cid:75)

(cid:74)

Figure 5: Tree for property 4 (excerpt from Fig. 2).

assessing the importance of human errors in the failure
of tle, the resulting number of mcss can be slightly
overwhelming to perform an accurate evaluation on. Thus,
we might focus our assessment on single human errors. Our
scope can be reﬁned by the following property:

• What are all the mcss for tle that include errors

in disinfecting objects?

MCS(IWoS) ∧ H4

(cid:75)

(cid:74)
Choosing a single error — e.g., H4 — allows us to narrow
our objective and better isolate failure causes. By this
query, we obtain all the mcss that include H4 ,
i.e.,
all the ways in which an infected worker can join the
workplace (tle) due to a series of actions containing a
disinfection error (see Fig. 4): {IW , H3 , IT , H1 , H4 , VW }
and {IT , H2 , H1 , H4 , VW }. This analysis uncovered a
potentially worrying mcs, heavy on human errors and
with only two other elements needed to trigger a system-
level failure,
i.e., the existence of a vulnerable worker
(VW ) and an infected object used by the team (IT ):

MoTCTDTATCVTCISISH1MH2H5IWoSCP/RSHMoTCRCPCTH1ITH2CIOVWIWH3ITH1MH1H4IWoSCP/RSHMoTCRCPCTDTATCVTH1ITH2CIWCIOCISVWIWH1MVIWH3ITH1MH1H4ISH1MH2H5H1PPIW{IT , H2 , H1 , H4 , VW }. Knowing this can prompt modi-
ﬁcations in the workplace to mitigate the uncovered risk.
error
human
the occurrence of tle?

not
suﬃcient

to prevent

committing

• Is

any

∃MPS(IWoS)[H1 7→ 0, H2 7→ 0, H3 7→ 0,

ei∈BE\{H1 ,...,H5 }

H4 7→ 0, H5 7→ 0, ei 7→ 1]

The path set we are trying to construct in the formula
above is not minimal, i.e., there are ways to prevent the
occurrence of tle by only addressing human errors (see
Fig. 5), but including all ﬁve of them is not a minimal way
to do so. In this setting, a counterexample would be con-
structed following pattern2. In this case, the two vectors
represented by the following mpss are constructed: {H1 }
and {H2 , H3 }. This means that if we can guarantee that
either H1 is not committed or H2 alongside H3 are not
committed we will be sure that IWoS will not fail, i.e., an
infected worker joining the team can be prevented either
by respecting the outbreak procedures or by operational
disinfection and detection of COVID on the workplace.

• What are all the minimal ways to prevent the occur-

rence of tle?
can further
to prevent

MPS(IWoS)
(cid:74)
(cid:75)
extend our
the tle to all
the mpss
for
{IW , H4 , IS, UT },
{H3 , H2 },

search on minimal
We
the mpss. This
ways
IWoS: {IW , IT },
query returns all
{IW , H4 , H5 , UT },
{IW , H2 },
{H3 , IT },
{IT , PP, IS, AB, MV , UT },
{IT , PP, H5 , AB, MV , UT }, {PP, H4 , IS, AB, MV , UT },
{PP, H4 , H5 , AB, MV , UT }, {H1 } and {VW }. In doing
so, we uncover interesting additional ways to prevent
the occurrence of tle, e.g., the mps with a single
element {VW } or the ones with only two bes {IW , H2 },
{IW , IT } and {H3 , IT }. Some of these mpss are of
particular interest since they do not depend on human
errors. This could further inform risk mitigation decisions,
e.g., trying to reduce the risk of a vulnerable worker
joining the team VW .

• Are a contact with an infected object and a contact
with an infected surface always independent scen-
arios? IDP(CIO, CIS)

As a last step, we might want to assess some events
in our tree for their independence. E.g., considering the
dependency between coming in contact with an infected

object and with an infected surface
(see excerpt on the right). By apply-
ing IDP we discover that CIO and
CIS are not independent. In fact, if
we return the inﬂuencing basic events
IBEs for the two elements it becomes
clear that their truth values both de-
pend on H1 , i.e., on the respect of
outbreak procedures.

11

• Is physical proximity superﬂuous for the occurrence

of tle? SUP(PP)

Finally, we can check whether physical proximity is su-
perﬂuous for tle (see Fig. 6). PP and IWoS are not
independent: in fact, there are cases in which the failure
of IWoS depends on the value of PP. Thus, PP is not a
superﬂuous element in T and must not be removed from
its leaves.

Figure 6: Tree for property 9 (excerpt from Fig. 2).

VIII. Conclusions and Future Work

Conclusions: We presented BFL, a Boolean logic for
fts that enables the construction of complex queries
that capture many relevant scenarios. BFL is a ﬂexible
yet powerful logic: as a testimony of this usefulness we
showcased an application of BFL to a COVID19-related
ft. Our logic can easily express properties and it can
query fts to account for diverse settings and what-if
situations: speciﬁed properties can then be checked via
the model checking algorithms we presented. Finally, we
presented an algorithm to generate counterexamples which
helps in narrowing the gap between the expressive power
of BFL and real-life usability.

Future work: Our work opens several relevant perspect-
ives for future research. First, it makes sense to extend
BFL to model probabilities. Fault trees analysis often
involves the computation of probabilistic dependability
metrics, such as the system reliability, availability and
mean time to failure, etc. A probabilistic fault tree logic
will allow users to perform such quantitative analysis.
Secondly,
it is foreseeable to extend BFL in order to
consider dynamic gates in fts. To handle dynamic gates
in dynamic fts it would be very natural to have a logic
that can express temporal properties, moving more in the
direction of LTL [8] or CTL [7] or their timed variants
TLTL [33] and TCTL [34]. Moreover, a step towards
usability can be achieved through the development of a
Domain Speciﬁc Language for BFL: in doing so, we would
near the gap between the theoretical development of our
logic and the need of practitioners for useful tools. Lastly,
applying an implementation of this logic to an industrial
case study could further propel the development of BFL
by providing hands-on feedback from engineers and risk
managers acquainted with FTA.

CTCIOCISITH1MH1H4ISH1MH2H5IWoSCP/RSHMoTCRCPCTDTATCVTUTH1ITH2CIWIWPPVWIWH3H1PPIW[21] OMG, OMG Uniﬁed Modeling Language (OMG UML),
Superstructure, Version 2.4.1, Object Management Group
Std., Rev. 2.4.1, August 2011.
[Online]. Available: http:
//www.omg.org/spec/UML/2.4.1

[22] J. Simmonds, R. V. D. Straeten, V. Jonckers, and T. Mens,
“Maintaining consistency between UML models using descrip-
tion logic,” Obj. Logiciel Base données Réseaux, vol. 10, no. 2-3,
pp. 231–244, 2004. DOI: 10.3166/objet.10.2-3.231-244

[23] D. Berardi, D. Calvanese, and G. D. Giacomo, “Reasoning on
UML class diagrams,” Artif. Intell., vol. 168, no. 1-2, pp. 70–
118, 2005. DOI: 10.1016/j.artint.2005.05.003

[24] M. D. Walker, “Pandora: a logic for the qualitative analysis of

temporal fault trees,” Ph.D. dissertation, Univ. of Hull, 2009.

[25] C. A. Ericson, “Fault tree analysis,” in Sys. Safety Conf., vol. 1,

pp. 1–9, 1999.

[26] T. Bakeli, A. A. Haﬁdi et al., “Covid-19 infection risk manage-
ment during construction activities: An approach based on fault
tree analysis (fta),” Journal of Emergency Management, vol. 18,
no. 7, pp. 161–176, 2020.

[27] H. R. Andersen, “An introduction to binary decision diagrams,”

Lecture notes, IT University of Copenhagen, p. 5, 1997.

[28] C. E. Budde and M. Stoelinga, “Eﬃcient algorithms for quant-
itative attack tree analysis,” in 2021 IEEE 34th Computer
Security Foundations Symposium (CSF), pp. 1–15, 2021. DOI:
10.1109/CSF51468.2021.00041

[29] M. Ben-Ari, Mathematical logic for computer science. Springer

Science & Business Media, 2012.

[30] K. Brace, R. Rudell, and R. Bryant, “Eﬃcient implementation
of a bdd package,” in 27th ACM/IEEE Design Automation
Conference, pp. 40–45, 1990. DOI: 10.1109/DAC.1990.114826

[31] L. Jimenez Roa, T. Heskes, T. Tinga, and M. Stoelinga, “Auto-
matic inference of fault tree models via multi-objective evolu-
tionary algorithms,” 2021, available at: http://arxiv.org/abs/
2204.03743.

[32] C. Dehnert, S. Junges, J. Katoen, and M. Volk, “A storm
is coming: A modern probabilistic model checker,” in CAV,
R. Majumdar and V. Kuncak, Eds., vol. 10427, pp. 592–600.
Springer, 2017. DOI: 10.1007/978-3-319-63390-9_31

[33] J.-F. Raskin, “Logics, automata and classical theories for decid-
ing real time,” Ph.D. dissertation, Facultés universitaires Notre-
Dame de la Paix, Namur, 1999.

[34] R. Alur, C. Courcoubetis, and D. Dill, “Model-checking in dense
real-time,” Information and computation, vol. 104, no. 1, pp. 2–
34, 1993.

References

[1] E. Ruijters and M. Stoelinga, “Fault tree analysis: A sur-
vey of the state-of-the-art in modeling, analysis and tools,”
Computer Science Review, vol. 15–16, pp. 29–62, 2015. DOI:
10.1016/j.cosrev.2015.03.001

[2] M. Stamatelatos, W. Vesely, J. Dugan, J. Fragola, J. Minarick,
and J. Railsback, “Fault tree handbook with aerospace applic-
ations,” NASA Oﬃce of Safety and Mission Assurance, 2002.

[3] International Standardization Organization, “ISO/DIS 26262:
https://www.iso.org/

functional

vehicles,

safety,”

Road
standard/68383.html, 2018.

[4] S. Nicoletti, M. Stoelinga, and E. Hahn, “A Logic to
Interview Report,” Available
reason about Fault Trees.
online, https://www.utwente.nl/en/eemcs/fmt/research/ﬁles/
ft-logic-interview-domain-expert.pdf.

[5] A. Rauzy, “New algorithms for fault trees analysis,” Reliability
Engineering & System Safety, vol. 40, no. 3, pp. 203–211, 1993.
DOI: 10.1016/0951-8320(93)90060-C

[6] M. Bouissou, “An ordering heuristic for building binary decision
diagrams from fault-trees,” in RAMS, pp. 208–214, 1996.
[7] E. Clarke and E. Emerson, “Design and synthesis of synchron-
isation skeletons using branching time temporal logic,” in Logic
of Programs, vol. 31, pp. 52–71, 1981.

[8] A. Pnueli, “The temporal logic of programs,” in FOCS, pp. 46–
57. IEEE Computer Society, 1977. DOI: 10.1109/SFCS.1977.32
[9] H. Hansson and B. Jonsson, “A logic for reasoning about time
and reliability,” Formal Aspects Comput., vol. 6, no. 5, pp. 512–
535, 1994. DOI: 10.1007/BF01211866

[10] Z. Ognjanovic, “Discrete linear-time probabilistic logics: Com-
pleteness, decidability and complexity,” J. Log. Comput.,
vol. 16, no. 2, pp. 257–285, 2006. DOI: 10.1093/logcom/exi077
[11] M. Bozzano, A. Cimatti, J. Katoen, V. Y. Nguyen, T. Noll, and
M. Roveri, “Safety, dependability and performance analysis of
extended AADL models,” Comput. J., vol. 54, no. 5, pp. 754–
775, 2011. DOI: 10.1093/comjnl/bxq024

[12] D. Déharbe, S. Shankar, and E. M. Clarke, “Model check-
ing VHDL with CV,” in Formal Methods in Computer-Aided
Design, ser. Lecture Notes in Computer Science, G. Go-
palakrishnan and P. J. Windley, Eds., vol. 1522, pp. 508–514.
Springer, 1998. DOI: 10.1007/3-540-49519-3_33

[13] C. E. Budde, C. Dehnert, E. M. Hahn, A. Hartmanns, S. Junges,
and A. Turrini, “JANI: Quantitative model and tool interac-
tion,” in TACAS, ser. LNCS, vol. 10206, pp. 151–168. Springer,
2017. DOI: 10.1007/978-3-662-54580-5_9

[14] M. Z. Kwiatkowska, G. Norman, and D. Parker, “PRISM
4.0: Veriﬁcation of probabilistic real-time systems,” in CAV,
ser. LNCS, vol. 6806, pp. 585–591.
Springer, 2011. DOI:
10.1007/978-3-642-22110-1_47

[15] A. Thums and G. Schellhorn, “Model checking FTA,” in FME
2003, ser. LNCS, K. Araki, S. Gnesi, and D. Mandrioli, Eds., vol.
2805, pp. 739–757, 2003. DOI: 10.1007/978-3-540-45236-2_40

[16] P. Bieber, C. Castel, and C. Seguin, “Combination of fault tree
analysis and model checking for safety assessment of complex
system,” in EDCC-4, vol. 2485, pp. 19–31.
Springer, 2002.
DOI: 10.1007/3-540-36080-8_3

[17] M. Volk, S. Junges, and J. Katoen, “Fast dynamic fault
tree analysis by model checking techniques,” IEEE Trans.
Ind. Informatics, vol. 14, no. 1, pp. 370–379, 2018. DOI:
10.1109/TII.2017.2710316

[18] H. Boudali, P. Crouzen, and M. Stoelinga, “Dynamic fault
tree analysis using input/output interactive markov chains,”
IEEE Computer Society, 2007. DOI:
in DSN, pp. 708–717.
10.1109/DSN.2007.37

[19] E. Ábrahám, B. Becker, C. Dehnert, N. Jansen, J. Katoen,
and R. Wimmer, “Counterexample generation for discrete-time
markov models: An introductory survey,” in Formal Methods
for Exec. Softw. Models, vol. 8483, pp. 65–121, 2014. DOI:
10.1007/978-3-319-07317-0_3

[20] G. T. Leavens, A. L. Baker, and C. Ruby, “JML: A notation for
detailed design,” in Behavioral Speciﬁcations of Businesses and
Systems. Springer, 1999, vol. 523, pp. 175–188.

12

