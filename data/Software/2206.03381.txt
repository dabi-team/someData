2
2
0
2

g
u
A
5
2

]

O
L
.
s
c
[

2
v
1
8
3
3
0
.
6
0
2
2
:
v
i
X
r
a

Software Veriﬁcation of Hyperproperties
Beyond k-Safety

Raven Beutner((cid:66))

and Bernd Finkbeiner

CISPA Helmholtz Center for Information Security,
Saarbr¨ucken, Germany
{raven.beutner, finkbeiner}@cispa.de

Abstract. Temporal hyperproperties are system properties that relate
multiple execution traces. For (ﬁnite-state) hardware, temporal hyper-
properties are supported by model checking algorithms, and tools for
general temporal logics like HyperLTL exist. For (inﬁnite-state) soft-
ware, the analysis of temporal hyperproperties has, so far, been limited
to k-safety properties, i.e., properties that stipulate the absence of a bad
interaction between any k traces. In this paper, we present an automated
method for the veriﬁcation of ∀k∃l-safety properties in inﬁnite-state sys-
tems. A ∀k∃l-safety property stipulates that for any k traces, there ex-
ist l traces such that the resulting k + l traces do not interact badly.
This combination of universal and existential quantiﬁcation enables us
to express many properties beyond k-safety, including, for example, gen-
eralized non-interference or program reﬁnement. Our method is based
on a strategy-based instantiation of existential trace quantiﬁcation com-
bined with a program reduction, both in the context of a ﬁxed predicate
abstraction. Notably, our framework allows for mutual dependence of
strategy and reduction.

Keywords: Hyperproperties · HyperLTL · Inﬁnite-state Systems · Pred-
icate Abstraction · Hyperliveness · Veriﬁcation · Program Reduction.

1

Introduction

Hyperproperties are system properties that relate multiple execution traces of
a system [21] and commonly arise, e.g., in information-ﬂow policies [34], the
veriﬁcation of code optimizations [6], and robustness of software [18]. Conse-
quently, many methods for the automated veriﬁcation of hyperproperties have
been developed [38,40,26,39]. Almost all previous approaches verify a class of hy-
perproperties called k-safety, i.e., properties that stipulate the absence of a bad
interaction between any k traces in the system. For example, we can express a
simple form of non-interference as a 2-safety property by stating that any two
traces that agree on the low-security inputs should produce the same observable
output.

The vast landscape of hyperproperties does, however, stretch far beyond k-
safety. The overarching limitation of k-safety (or, more generally, of hypersafety

AvailableCAVEvaluationArtifactReusableCAVEvaluationArtifact 
 
 
 
 
 
2

R. Beutner and B. Finkbeiner

[21]) is an implicit universal quantiﬁcation over all executions. By contrast, many
properties of interest, ranging from applications in information-ﬂow control to
robust cleanness, require a combination of universal and existential quantiﬁca-
tion. For example, consider the reactive program in Figure 1, where (cid:63)N denotes
a nondeterministic choice of a natural number. We assume that h, l, and o are
a high-security input, a low-security input, and a low-security output, respec-
tively. This program violates the simple 2-safety non-interference property given
above as the non-determinism inﬂuences the output. Nevertheless, the program
is “secure” in the sense that an attacker that observes low-security inputs and
outputs cannot deduce information about the high-security input. To capture
this formally, we use a relaxed notion of non-interference, in the literature of-
ten referred to as generalized non-interference (GNI) [34]. We can, informally,
express GNI in a temporal logic as follows:

∀π.∀π(cid:48).∃π(cid:48)(cid:48).

(cid:0)oπ = oπ(cid:48)(cid:48) ∧ lπ = lπ(cid:48)(cid:48) ∧ hπ(cid:48) = hπ(cid:48)(cid:48)

(cid:1)

This property requires that for any two traces π, π(cid:48), there exists some trace
π(cid:48)(cid:48) that, globally, agrees with the low-security inputs and outputs on π but
the high-security inputs on π(cid:48). Phrased diﬀerently, any observation on the low-
security input-output behavior is compatible with every possible high-security
input. The program in Figure 1 satisﬁes GNI. Crucially, GNI is no longer a
hypersafety property (and, in particular, no k-safety property for any k) as it
requires a combination of universal and existential quantiﬁcation.

1.1 Veriﬁcation Beyond k-Safety

Instead, GNI falls in the general class of ∀∗∃∗-safety prop-
erties. Concretely, a ∀k∃l-safety property (using k universal
and l existential quantiﬁers) stipulates that for any k traces,
there exist l traces such that the resulting k + l traces do
not interact badly. k-safety properties are the special case
where l = 0. We study the veriﬁcation of such properties in
inﬁnite-state systems arising, e.g., in software. In contrast to
k-safety, where a broad range of methods has been developed
[38,26,39,10,40], no method for the automated veriﬁcation of
temporal ∀∗∃∗ properties in inﬁnite-state systems exists (we
discuss related approaches in Section 8).

repeat

readInput(h, l)
if h > l then
o ← l + (cid:63)N

else

x ← (cid:63)N
if x ≥ l then

o ← x

else

o ← l

Fig. 1

Our novel veriﬁcation method is based on a game-based reading of existen-
tial quantiﬁcation combined with the search for a program reduction. The game-
based reading of existential quantiﬁcation instantiates existential trace quantiﬁ-
cation with an explicit strategy and constitutes the ﬁrst practicable method for
the veriﬁcation of ∀∗∃∗-properties in ﬁnite-state systems [22]. Program reduc-
tions are a well-established technique to align executions of independent program
fragments (such as the individual program copies in a self-composition) to obtain
proofs with easier invariants [33,38,26].

So far, both techniques are limited to their respective domain, i.e., the game-
based approach has only been applied to ﬁnite-state systems and synchronous

Software Veriﬁcation of Hyperproperties Beyond k-Safety

3

speciﬁcations, and reductions have (mostly) been used for the veriﬁcation of k-
safety. We combine both techniques yielding an eﬀective (and ﬁrst) veriﬁcation
technique for hyperproperties beyond k-safety in inﬁnite-state systems arising in
software. Notably, our search for reduction and strategy-based instantiation of
existential quantiﬁcation is mutually dependent, i.e., a particular strategy might
depend on a particular reduction and vice versa.

1.2 Contributions and Structure

The starting point of our work is a new temporal logic called Observation-based
HyperLTL (OHyperLTL for short). Our logic extends the existing hyperlogic
HyperLTL [20] with capabilities to reason about asynchronous properties (i.e.,
properties where the individual traces are traversed at diﬀerent speeds), and to
specify properties using assertions from arbitrary background theories (to reason
about the inﬁnite domains encountered in software) (Section 4).

To automatically verify ∀k∃l OHyperLTL properties, we combine program
reductions with a strategy-based instantiation of existential quantiﬁcation, both
in the context of a ﬁxed predicate abstraction. To facilitate this combination, we
ﬁrst present a game-based approach that automates the search for a reduction.
Concretely, we construct an abstract game where a winning strategy for the
veriﬁer directly corresponds to a reduction with accompanying proof. As a side
product, our game-based interpretation simpliﬁes the search for a reduction in
a given predicate abstraction as, e.g., studied by Shemer et al. [38] (Section 5).
Our strategic (game-based) view on reductions allows us to combine them
with a game-based instantiation of existential quantiﬁcation. Here, we view the
existentially quantiﬁed traces as being constructed by a strategy that, iteratively,
reacts to the universally quantiﬁed traces. As we phrase both the search for a
reduction and the search for existentially quantiﬁed traces as a game, we can
frame the search for both as a combined abstract game. We prove the sound-
ness of our approach, i.e., a winning strategy for the veriﬁer constitutes both
a strategy for the existentially quantiﬁed traces and accompanying (mutually
dependent) reduction. Despite its ﬁnite nature, constructing the abstract game
is expensive as it involves many SMT queries. We propose an inner reﬁnement
loop that determines the winner of the game (without constructing it explicitly)
by computing iterative approximations (Section 6).

We have implemented our veriﬁcation approach in a prototype tool called
HyPA (short for Hyperproperty Veriﬁcation with Predicate Abstraction) and
evaluate HyPA on k-safety properties (that can already be handled by existing
methods) and on ∀∗∃∗-safety benchmarks that cannot be handled by any existing
tool (Section 7).

Contributions. In short, our contributions include the following:

– We propose a temporal hyperlogic that can specify asynchronous hyperprop-

erties in inﬁnite-state systems;

4

R. Beutner and B. Finkbeiner

– We propose a game-based interpretation of a reduction (improving and sim-

plifying previous methods for k-safety [38]);

– We combine a strategy-based instantiation of existentially quantiﬁed traces
with the search for a reduction. This yields a ﬂexible (and ﬁrst) method for
the veriﬁcation of temporal ∀∗∃∗ properties. We propose an iterative method
to solve the abstract game that avoids an expensive explicit construction;

– We provide and evaluate a prototype implementation of our method.

2 Overview: Reductions and Quantiﬁcation as a Game

Our veriﬁcation approach hinges on the observation that we can express both
a reduction and existential trace quantiﬁcation as a game. In this section, we
provide an overview of our game-based interpretations. We begin by outlining
our game-based reading of a reduction (illustrating this in the simpler case of k-
safety) in Section 2.1 and then extend this to include a game-based interpretation
of existential quantiﬁcation in Section 2.2.

2.1 Reductions as a Game

Consider the two programs in Figure 2 and the speciﬁcation that both programs
produce the same output (on initially identical values for x). We can formalize
this in our logic OHyperLTL (formally deﬁned in Section 4) as follows:

∀P1π1 : (pc = 2). ∀P2π2 : (pc = 2). (xπ1 = xπ2 ) → (xπ1 = xπ2)

The property states that for all traces π1 in P1 and π2 in P2 the LTL speciﬁcation
(xπ1 = xπ2) → (xπ1 = xπ2 ) holds (where xπ refers to the value of x on trace
π). Additionally, the observation formula pc = 2 marks the positions at which
the LTL property is evaluated: We only observe a trace at steps where pc = 2
(i.e., where the program counter is at the output position).

The veriﬁcation of our property involves reasoning about two copies of our
system (in this case, one of P1 and one of P2) on disjoint state spaces. Conse-
quently, we can interleave the statements of both programs (between two obser-
vation points) without aﬀecting the behavior of the individual copies. We refer
to each interleaving of both copies as a reduction. The choice of a reduction
drastically inﬂuences the complexity of the needed invariants [26,38,33]. Given
an initial abstraction of the system [29,38], we aim to discover a suitable reduc-
tion automatically. Our ﬁrst observation is that we can phrase the search for a
reduction as a game as follows: In each step, the veriﬁer decides on a scheduling
(i.e., a non-empty subset M ⊆ {1, 2}) that indicates which of the copies should
take a step (i.e., i ∈ M iﬀ copy i should make a program step). Afterward, the
refuter can choose an abstract successor state compatible with that scheduling,
after which the process repeats. This naturally deﬁnes a ﬁnite-state two-player
safety game that we can solve eﬃciently.1 If the veriﬁer wins, a winning strategy

1 The LTL speciﬁcation is translated to a symbolic safety automaton that moves
alongside the game. For sake of readability, we omitted the automaton from the
following discussion.

Software Veriﬁcation of Hyperproperties Beyond k-Safety

5

y ← 2x

1: repeat
2: print(x)
3:
4: while y > 0 do
5:
6:

y ← y − 1
x ← 2x

1: repeat
2: print(x)
3:
y ← x
4: while y > 0 do
5:
6:

y ← y − 1
x ← 4x

(a) Program P1

(b) Program P2

{1}

{1, 2}

(2, 2)
x1 = x2

(3, 3)
x1 = x2

{1, 2}

{1, 2}

(4, 4)
x1 = x2
y1 = 2y2

{1, 2}

(5, 5)
x1 = x2
y1 = 2y2

{1}

{1, 2}

(6, 6)
x1 = x2
y1 = 2y2 + 1

(6, 4)
x1 = 2x2
y1 = 2y2

(5, 4)
x1 = 2x2
y1 = 2y2 + 1

(4, 4)
x1 = 2x2
y1 = 2y2 + 1

{1}

(c) Winning strategy for the veriﬁer.

Fig. 2: Two output-equivalent programs P1 and P2 are depicted in Figures 2a
and 2b. In Figure 2c a possible winning strategy for the veriﬁer is given. Each
abstract state contains the value of the program counter of both copies (given
as the pair at the top) and the predicates that hold in that state. For sake of
readability we omit the trace variables and write, e.g., x1 for xπ1. We mark the
initial state with an incoming arrow. The outer label at each state gives the
scheduling M ⊆ {1, 2} chosen by the strategy in that state.

directly corresponds to a reduction and accompanying inductive invariant for
the safety property within the given abstraction.

For our example, we give (parts of) a possible winning strategy in Figure 2c.
In each abstract state, the strategy chooses a scheduling (written next to the
state), and all abstract states compatible with that scheduling are listed as suc-
cessors. Note that whenever the program counter is (2, 2) (i.e., both programs
are at their output position), it holds that x1 = x2 (as required). The exam-
ple strategy schedules in lock-step for the most part (by choosing M = {1, 2})
but lets P1 take the inner loop twice, thereby maintaining the linear invariants
x1 = x2 and y1 = 2y2. In particular, the resulting reduction is property-based
[38] as the scheduling is based on the current (abstract) state. Note that the
program cannot be veriﬁed with only linear invariants in a sequential or parallel
(lock-step) reduction.

2.2 Beyond k-Safety: Quantiﬁcation as a Game

We build upon this game-based interpretation of a reduction to move beyond
k-safety. As a second example, consider the two programs Q1 and Q2 in Figure 3,
where (cid:63)τ denotes a nondeterministic choice of type τ ∈ {N, B}. We wish to check
that Q1 reﬁnes Q2, i.e., all output behavior of Q1 is also possible in Q2. We can
express this in our logic as follows:

∀Q1π1 : (pc = 2). ∃Q2π2 : (pc = 2).

(aπ1 = aπ2)

The property states that for every trace π1 in Q1 there exists a trace π2 in
Q2 that outputs the same value. The quantiﬁers range over inﬁnite traces of
variable assignments (with inﬁnite domains), making a direct veriﬁcation of the

6

R. Beutner and B. Finkbeiner

1: repeat
2: print(a)
3:
x ← (cid:63)N
4: while (cid:63)B do
x ← x + 1
5:
6:
7: while y > 0 do
8:
9:

a ← a + x
y ← y − 1

y ← x

(a) Program Q1

x ← (cid:63)N
y ← x

1: repeat
2: print(a)
3:
4:
5: while y > 0 do
a ← a + x + (cid:63)N
6:
y ← y − 1
7:

(b) Program Q2

α1 : (5, 3)
a1 = a2

α2 : (3, 3)
a1 = a2

α3 : (2, 2)
a1 = a2

{1}

{1}

{1, 2}

α4 : (4, 3)
a1 = a2

{1}

{2}, {α8}

α7 : (6, 3)
a1 = a2

α5 : (7, 5)
a1 = a2
x1 = x2
y1 = y2

{1, 2}

α8 : (6, 4)
a1 = a2
x1 = x2

{1, 2}

{1, 2}

α6 : (9, 7)
a1 = a2
x1 = x2
y1 = y2

{1, 2}, {α6}

α9 : (8, 6)
a1 = a2
x1 = x2
y1 = y2

(c) Winning strategy for the veriﬁer.

Fig. 3: Two programs Q1 and Q2 are given in Figures 3a and 3b. In Figure 3c a
possible winning strategy for the veriﬁer is depicted. The outer label gives the
scheduling M ⊆ {1, 2} and, if applicable, the restriction chosen by the witness
strategy.

quantiﬁer alternation challenging. In contrast to alternation-free formulas, we
cannot reduce the veriﬁcation to veriﬁcation on a self composition [8,27]. Instead,
we adopt (yet another) game-based interpretation by viewing the existentially
quantiﬁed traces as being resolved by a strategy (called the witness strategy)
[22]. That is, instead of trying to ﬁnd a witness traces π2 in Q2 when given the
entire trace π1, we interpret the ∀∃ property as a game between veriﬁer and
refuter. The refuter moves through the state space of Q1 (thereby producing
a trace π1), and the veriﬁer reacts to each move by choosing a successor in
the state space of Q2 (thereby producing a trace π2). If the veriﬁer can assure
that the resulting traces π1, π2 satisfy
(aπ1 = aπ2), the ∀∃ property holds.
However, this game-based interpretation fails in many instances. There might
exist a witness trace π2, but the trace cannot be produced by a witness strategy
as it requires knowledge of future moves of the refuter. Let us discuss this on
the example programs in Figure 3. A simple (informal) solution to construct a
witness trace π2 (when given the entire π1) would be to guarantee that in Q2:4
(meaning location 4 of Q2) and line Q1:6 the value of x in both programs agrees
(i.e., x1 = x2 holds) and then simply resolve the nondeterminism at Q2:6 with 0.
However, to follow this idea, the witness strategy for the veriﬁer, when at Q2:3,
would need to know the future value of x1 when Q1 is at location Q1:6.

Our insight in this paper is that we can turn the strategy-based interpretation
of the witness trace π2 into a useful veriﬁcation method by combining it with
a program reduction. As we express both searches strategically, we can phrase
the combined search as a combined game. In particular, both the reduction and
the witness strategy are controlled by the veriﬁer and can thus collaborate. In
the resulting game, the veriﬁer chooses a scheduling (as in Section 2.1) and,
additionally, whenever the existentially quantiﬁed copy is scheduled, the veriﬁer

Software Veriﬁcation of Hyperproperties Beyond k-Safety

7

also decides on the successor state of that copy. We depict a possible winning
strategy in Figure 3c. This strategy formalizes the interplay of reduction and
witness strategy. Initially, the veriﬁer only schedules {1} until Q1 has reached
program location Q1:6 (at which point the value of x is ﬁxed). Only then does
the veriﬁer schedule {2}, at which point the witness strategy can decide on a
successor state for Q2. In our case, the strategy chooses a value for x such that
x1 = x2 holds. As we work in an abstraction of the actual system, we formalize
this by restricting the abstract successor states. In particular, in state α7 the
veriﬁer schedules {2} and simultaneously restricts the successors to {α8} (i.e.,
the abstract state where x1 = x2 holds), even though abstract state [(6, 4), a1 =
a2, x1 (cid:54)= x2] is also a valid successors under scheduling {2}. We formalize when a
restriction is valid in Section 6. The resulting strategy is winning and therefore
denotes both a reduction and witness strategy for the existentially quantiﬁed
copy. Importantly, both reduction and witness strategy are mutually dependent.
Our tool HyPA is able to verify both properties (in Figure 2 and Figure 3) in a
matter of a few seconds (cf. Section 7).

3 Preliminaries

We begin by introducing basic preliminaries, including our basic model of com-
putation and background on (ﬁnite-state) safety games.

Symbolic Transition Systems. We assume some ﬁxed underlying ﬁrst-order the-
ory. A symbolic transition system (STS) is a tuple T = (X, init, step) where X
is a ﬁnite set of variables (possibly sorted), init is a formula over X describing
all initial states, and step is a formula over X (cid:93) X (cid:48) (where X (cid:48) := {x(cid:48) | x ∈ X} is
the set of primed variables) describing the transitions of the system. A concrete
state µ in T is an assignment to the variables in X. We write µ(cid:48) for the assign-
ment over X (cid:48) given by µ(cid:48)(x(cid:48)) := µ(x). A trace in T is an inﬁnite sequence of
assignment µ0µ1 · · · such that µ0 |= init and for every i ∈ N, µi (cid:93) µ(cid:48)
i+1 |= step.
We write Traces(T ) for the set of all traces in T . We can naturally interpret
programs as STS by making the program counter explicit.

Formula Transformations. For the remainder of this paper, we ﬁx the set of
system variables X. We also ﬁx a ﬁnite set of trace variables V = {π1, . . . , πk}.
For a trace variable π ∈ V we deﬁne Xπ := {xπ | x ∈ X} and write (cid:126)X for
Xπ1 ∪ · · · ∪ Xπk . For a formula θ over X, we deﬁne θ(cid:104)π(cid:105) as the formula over
Xπ obtained by replacing every variable x with xπ. Similarly, we deﬁne k fresh
disjoint copies (cid:126)X (cid:48) = X (cid:48)
π | x ∈ X}). For a formula
π1
θ over (cid:126)X, we deﬁne θ(cid:104)(cid:48)(cid:105) as the formula over (cid:126)X (cid:48) obtained by replacing every
variable xπ with x(cid:48)
π.

∪ · · · ∪ X (cid:48)
πk

(where X (cid:48)

π := {x(cid:48)

Safety Games. A safety game is a tuple G = (SSAFE, SREACH, S0, T, B) where S =
SSAFE (cid:93) sREACH is a set of game states, S0 ⊆ S a set of initial states, T ⊆ S × S
a transition relation, and B ⊆ S a set of bad states. We assume that for every

8

R. Beutner and B. Finkbeiner

s ∈ S there exists at least one s(cid:48) with (s, s(cid:48)) ∈ T . States in SSAFE are controlled by
player SAFE and those in SREACH by player REACH. A play is an inﬁnite sequence of
states s0s1 · · · such that s0 ∈ S0, and (si, si+1) ∈ T for every i ∈ N. A positional
strategy σ for player p ∈ {SAFE, REACH} is a function σ : Sp → S such that
(s, σ(s)) ∈ T for every s ∈ Sp. A play s0s1 · · · is compatible with strategy σ for
player p if si+1 = σ(si) whenever si ∈ Sp. The safety player wins G if there is a
strategy σ for SAFE such that all σ-compatible plays never visit a state in B. In
particular, SAFE needs to win from all initial states.

4 Observation-based HyperLTL

In this section, we present OHyperLTL (short for observation-based HyperLTL).
Our logic builds upon HyperLTL [20], which itself extends linear-time tempo-
ral logic (LTL) with explicit trace quantiﬁcation. In OHyperLTL, we include
predicates from the background theory (to reason about inﬁnite variable do-
mains) and explicit observations (to express asynchronous properties). Formulas
in OHyperLTL are given by the following grammar:2

ϕ := ∀π : ξ. ϕ | ∃π : ξ. ϕ | φ
φ := θ | ¬φ | φ1 ∧ φ2 | φ | φ1 U φ2

Here π ∈ V is a trace variable, θ is a formula over (cid:126)X, and ξ is a formula over
X (called the observation formula). For ease of notation, we assume that all
variables in V occur in the quantiﬁer preﬁx exactly once. We use the standard
Boolean connectives ∧, →, ↔, and constants (cid:62), ⊥, as well as the derived LTL
operators eventually

φ := (cid:62) U φ, and globally

φ := ¬ ¬φ.

Semantics. A trace t is an inﬁnite sequence µ0µ1 · · · of assignments to X. For
i ∈ N, we write t(i) to denote the ith value in t. A trace assignment Π is a partial
mapping of trace variables in V to traces. Given a trace assignment Π and i ∈ N,
we deﬁne Π(i) to be the assignment to (cid:126)X given by Π(i)(xπ) := Π(π)(i)(x), i..e,
the value of xπ is the value of x on the trace assigned to π. For the LTL body
of an OHyperLTL formula, we deﬁne:

Π, i |= θ

iﬀ Π(i) |= θ

Π, i |= ¬φ
Π, i |= φ1 ∧ φ2
Π, i |= φ
Π, i |= φ1 U φ2

iﬀ Π, i (cid:54)|= φ
iﬀ Π, i |= φ1 and Π, i |= φ2
iﬀ Π, i + 1 |= φ

iﬀ

∃j ≥ i. Π, j |= φ2 and ∀i ≤ k < j. Π, k |= φ1

The distinctive feature of OHyperLTL over HyperLTL are the explicit obser-
vations. Given an observation formula ξ and trace t, we say that ξ is a valid

2 For the examples in Section 2, we additionally annotated quantiﬁers with an STS if
we want to reason about diﬀerent STSs within the same formula. In the following, we
assume that all quantiﬁers range over traces in the same STS to simplify notation.

Software Veriﬁcation of Hyperproperties Beyond k-Safety

9

observation on t (written valid (t, ξ)) if there are inﬁnitely many i ∈ N such that
ξ for the trace obtained by projecting
t
t(i) |= ξ. If valid (t, ξ) holds, we write
(cid:77)
(cid:76)
ξ(i) := t(j) where j is the ith index
on those positions i where t(i) |= ξ, i.e.,
t
(cid:77)
(cid:76)
that satisﬁes ξ. Given a set of traces T we resolve trace quantiﬁcation as follows:

Π |=T φ

iﬀ Π, 0 |= φ

Π |=T ∀π : ξ. ϕ

Π |=T ∃π : ξ. ϕ

iﬀ

iﬀ

∀t ∈ {t ∈ T | valid (t, ξ)}. Π[π (cid:55)→
∃t ∈ {t ∈ T | valid (t, ξ)}. Π[π (cid:55)→

t
(cid:76)
t
(cid:76)

ξ] |=T ϕ
(cid:77)
ξ] |=T ϕ
(cid:77)

The semantics mostly agrees with that of HyperLTL[20] but projects each trace
to the positions where the observation holds. Given an STS T and OHyperLTL
formula ϕ, we write T |= ϕ if ∅ |=Traces(T ) ϕ where ∅ is the empty assignment.

The Power of Observations. The explicit observations in OHyperLTL facilitate
the speciﬁcation of asynchronous hyperproperties, i.e., properties where traces
are traversed at diﬀerent speeds. For the example in Section 2.1, the explicit
observations allow us to compare the output of both programs even though the
actual step at which the output occurs (in a synchronous semantics) diﬀers be-
tween both programs (as P1 takes the inner loop twice as often as P2). As the
observations are part of the speciﬁcation, we can model a broad spectrum of
properties ranging, e.g., from timing-insensitive properties (by placing observa-
tions only at output locations) to timing-sensitive speciﬁcations [28] (by plac-
ing observations at closer intervals). Functional (opposed to temporal) k-safety
properties speciﬁed by pre-and postcondition [10,38,40] can easily be encoded
as ∀k-OHyperLTL properties by placing observations at the start and end of
each program. By setting ξ = (cid:62), i.e., observing every step, we can express
synchronous properties. OHyperLTL thus subsumes HyperLTL.

Finite-State Model Checking. Many mechanisms used to express asynchronous
hyperproperties render ﬁnite-state model checking undecidable [30,16,9]. In con-
trast, the simple mechanism used in OHyperLTL maintains decidable ﬁnite-state
model checking. Detailed proofs can be found in the appendix.

Theorem 1. Assume an STS T with ﬁnite variable domains and decidable back-
ground theory and an OHyperLTL formula ϕ. It is decidable if T |= ϕ.

Proof sketch. Under the assumptions, we can view T as an explicit (instead of
symbolic) ﬁnite-state transition system. Given an observation formula ξ we can
eﬀectively compute an explicit ﬁnite-state system T (cid:48) such that Traces(T (cid:48)) =
ξ | t ∈ Traces(T ) ∧ valid (t, ξ)}. This reduces OHyperLTL model checking on
{
t
(cid:77)
(cid:76)
T to HyperLTL model checking on T (cid:48), which is decidable [27].
(cid:117)(cid:116)

Note that for inﬁnite-state (symbolic) systems, we cannot eﬀectively compute
T (cid:48) as in the proof of Theorem 1. In fact, there may not even exist a system T (cid:48)
with the desired property that is expressible in the same background theory.

The ﬁnite-state result in Theorem 1 is of little relevance for the present
paper. Nevertheless, it indicates that our logic is well suited for veriﬁcation of
inﬁnite-state (software) systems as the (inevitable) undecidability stems from
the inﬁnite domains in software programs and not already from the logic itself.

10

R. Beutner and B. Finkbeiner

Safety. In this paper, we assume that the hyperproperty is temporally safe [12],
i.e., the temporal body of any OHyperLTL formula denotes a safety property.
Note that, as we support quantiﬁer alternation, we can still express hyperliveness
properties [21,22]. For example, GNI is both temporally safe and hyperliveness.
We model the body of a formula by a symbolic safety automaton [23], which is a
tuple A = (Q, q0, δ, B) where Q is a ﬁnite set of states, q0 ∈ Q the initial state,
B ⊆ Q a set of bad-states, and δ a ﬁnite set of automaton edges of the form
(q, θ, q(cid:48)) where q, q(cid:48) ∈ Q are states and θ is a formula over (cid:126)X. Given a trace t
over assignments to (cid:126)X, a run of A on t is an inﬁnite sequence of states q0q1 · · ·
(starting in q0) such that for every i, there exists an edge (qi, θi, qi+1) ∈ δ such
that t(i) |= θi. A word is accepted by A if it has no run that visits a state in B.
The automaton is deterministic if for every q ∈ Q and every assignments µ to
(cid:126)X, there exists exactly one edge (q, θ, q(cid:48)) ∈ δ with µ |= θ.

5 Reductions as a Game

After having deﬁned our temporal logic, we turn our attention to the automatic
veriﬁcation of OHyperLTL formulas on STSs. In this section, we begin by for-
malizing our game-based interpretation of a reduction. To illustrate this, we
consider ∀k OHyperLTL formulas, which, as the body of the formula is a safety
property, always denote k-safety properties.

Predicate Abstraction. Our search for a reduction is based in the scope of a
ﬁxed predicate abstraction [29,32], i.e., we abstract our system by keeping track
of the truth value of a few selected predicates that (ideally) identify properties
that are relevant to prove the property in question. Let T = (X, init, step) be
an STS and let ϕ = ∀π1 : ξ1 . . . ∀πk : ξk. φ be the (k-safety) OHyperLTL we
wish to verify. Let Aφ = (Qφ, qφ,0, δφ, Bφ) be a deterministic safety automaton
for φ. A relational predicate p is a formula over (cid:126)X that identiﬁes a property of
the combined state space of k system copies. Let P = {p1, . . . , pn} be a ﬁnite
set of relational predicates. We say a formula over (cid:126)X is expressible in P if it is
equivalent to a boolean combination of the predicates in P. We assume that all
edge formulas in the automaton Aφ, and formulas init (cid:104)πi(cid:105) and (ξi)(cid:104)πi(cid:105) for πi ∈ V
are expressible in P. Note that we can always add missing predicates to P.

Given the set of predicates P, the state-space of the abstraction w.r.t. P is
given by Bn, where for each abstract state ˆs ∈ Bn, the ith position ˆs[i] ∈ B tracks
whether or not predicate pi holds. To simplify notation, we write ite(b, θ, θ(cid:48)) to
be formula θ if b = (cid:62), and θ(cid:48) otherwise. For each abstract state ˆs ∈ Bn, we
is a formula over (cid:126)X that captures
deﬁne
all concrete states that are abstracted to ˆs. To incorporate reductions in our
abstraction, we parametrize the abstract transition relation by a scheduling M ⊆
{π1, . . . , πk}. We lift the step formula from T by deﬁning

i=1 ite(cid:0)ˆs[i], pi, ¬pi

(cid:1), i.e.,

:= (cid:86)n

ˆs
(cid:75)

ˆs
(cid:75)

(cid:74)

(cid:74)

stepM :=

k
(cid:94)

i=1

(cid:16)
πi ∈ M, step(cid:104)πi(cid:105),

ite

(cid:94)

x(cid:48)
πi

= xπi

(cid:17)

.

x∈X

Software Veriﬁcation of Hyperproperties Beyond k-Safety

11

∧

ˆs1

That is all copies in M take a step while all other copies remain unchanged.
Given two abstract states ˆs1, ˆs2 we say that ˆs2 is an M -successor of ˆs1, written
(cid:104)(cid:48)(cid:105) ∧ stepM is satisﬁable, i.e., we can transition from ˆs1 to
ˆs1
ˆs2
(cid:74)
ˆs2 by only progressing the copies in M .

M−→ ˆs2, if

For an abstract state ˆs, we deﬁne obs(ˆs) ∈ Bk as the boolean vector that
indicates which copy (of π1, . . . , πk) is currently at an observation point, i.e.,
∧(ξi)(cid:104)πi(cid:105) is satisﬁable. Note that as (ξi)(cid:104)πi(cid:105) is, by assumption,
obs(ˆs)[i] = (cid:62) iﬀ
satisfy (ξi)(cid:104)πi(cid:105).
expressible in P, either all or none of the concrete states in

ˆs
(cid:75)
(cid:74)

(cid:75)

(cid:74)

(cid:75)

ˆs
(cid:75)

(cid:74)

Game Construction. Building on the parametrized abstract transition relation,
we can construct a (ﬁnite-state) safety game where winning strategies for the
veriﬁer correspond to valid reductions with accompanying proofs. The nodes in
our game have two forms: Either they are of the form (ˆs, q, b) where ˆs ∈ Bn is
an abstract state, q ∈ Qφ a state of the safety automaton, and b ∈ Bk a boolean
vector indicating which copy has moved since the last automaton step; Or of the
form (ˆs, q, b, M ) where ˆs, q, and b are as before and ∅ (cid:54)= M ⊆ {π1, . . . , πk} is a
scheduling. The initial states are all states (ˆs, qφ,0, (cid:62)k) where
i=1 init (cid:104)πi(cid:105)
is satisﬁable (recall that init (cid:104)πi(cid:105) is expressible in P). We mark a state (ˆs, q, b) or
(ˆs, q, b, M ) as losing iﬀ q ∈ Bφ. For automaton state q ∈ Qφ and abstract state ˆs,
we deﬁne δφ(q, ˆs) as the unique state q(cid:48) such that there is an edge (q, θ, q(cid:48)) ∈ δφ
such that
∧θ is satisﬁable. Uniqueness follows from the assumption that Aφ is
deterministic and all edge formulas are expressible in P. The transition relation
of our game is given by the following rules:

∧ (cid:86)k

ˆs
(cid:75)

ˆs
(cid:75)

(cid:74)

(cid:74)

∀πi ∈ M. ¬b[i] ∨ ¬obs(ˆs)[i]
(ˆs, q, b) (cid:32) (ˆs, q, b, M )

(1)

obs(ˆs) = (cid:62)k q(cid:48) = δφ(q, ˆs)
(ˆs, q, (cid:62)k) (cid:32) (ˆs, q(cid:48), ⊥k)

(2)

ˆs M−→ ˆs(cid:48) b(cid:48) = b[i (cid:55)→ (cid:62)]πi∈M
(ˆs, q, b, M ) (cid:32) (ˆs(cid:48), q, b(cid:48))

(3)

In rule (1), we select any scheduling that schedules only copies that have not
reached an observation point or have not moved since the last automaton step.
In particular, we cannot schedule any copy that has moved and already reached
an observation point. In rule (2), all copies reached an observation point and
have moved since the last update (i.e., b = (cid:62)k) so we progress the automaton
and reset b. Lastly, in rule (3), we select an M -successor of ˆs and update b for
all copies that take part in the step. In our game, player SAFE takes the role
of the veriﬁer, and player REACH that of the refuter. It is the safety player’s
responsibility to select a scheduling in each step, so we assign nodes of the form
(ˆs, q, b) to SAFE. Nodes of the form (ˆs, q, b, M ) are controlled by REACH who can
choose an abstract M -successor. Let G∀
(T ,ϕ,P) be the resulting (ﬁnite-state) safety
game. A winning strategy for SAFE in G∀
(T ,ϕ,P) picks, in each abstract state, a
valid scheduling that prevents a visit to a losing state. We can thus show:
Theorem 2. If player SAFE wins G∀

(T ,ϕ,P), then T |= ϕ.

Proof sketch. Assume σ is a winning strategy for SAFE in G∀
Traces(T ) be arbitrary. We, iteratively, construct stuttered versions t(cid:48)

(T ,ϕ,P). Let t1, . . . , tk ∈
k of

1, . . . , t(cid:48)

12

R. Beutner and B. Finkbeiner

(T ,ϕ,P) the stuttered traces t(cid:48)

t1, . . . , tk by querying σ on abstracted preﬁxes of t1, . . . , tk: Whenever σ sched-
ules copy i we take a proper step on ti; otherwise we stutter. By construction
of G∀
1, . . . , t(cid:48)
k align at observation points. In par-
ticular, we have [π1 (cid:55)→
ξ1 , . . . , πk (cid:55)→
tk
ξk ] |= φ iﬀ [π1 (cid:55)→
ξ1, . . . , πk (cid:55)→
t1
(cid:76)
(cid:77)
(cid:76)
(cid:77)
(cid:76)
ξk ] |= φ. Moreover, the sequence of abstract states in G∀
t(cid:48)
(T ,ϕ,P) forms an
k
(cid:76)
abstraction of t(cid:48)
k and shows that Aφ cannot reach a bad state when
reading
ξk (as σ is winning). This already shows that [π1 (cid:55)→
t(cid:48)
ξk ] |= φ.
t1
1
(cid:76)
(cid:77)
(cid:76)
As this holds for all traces t1, . . . , tk ∈ Traces(T ), we get T |= ϕ as required. (cid:117)(cid:116)

1, . . . , t(cid:48)
t(cid:48)
ξ1, . . . ,
k
(cid:76)
(cid:77)
t(cid:48)
ξk ] |= φ and thus [π1 (cid:55)→
k
(cid:76)

t(cid:48)
1
(cid:76)
ξ1, . . . , πk (cid:55)→
(cid:77)

ξ1, . . . , πk (cid:55)→

tk
(cid:76)

t(cid:48)
1

(cid:77)

(cid:77)

(cid:77)

(cid:77)

(cid:77)

Game Construction and Complexity.
If the background theory is decidable,
G∀
(T ,ϕ,P) can be constructed eﬀectively using at most 2|P|+1 · 2k queries to an
SMT solver. Checking if SAFE wins G∀
(T ,ϕ,P) can be done with a simple ﬁxpoint
computation of the attractor in linear time.

Our game-based method of ﬁnding a reduction in a given abstraction is
closely related to the notation of a property-directed self-composition [38]. The
previously only known algorithm for ﬁnding such a reduction is based on an op-
timized enumeration [38], which, in the worst case, requires O(2|P|+1 · 2k) many
enumerations. Our worst-case complexity thus matches the bounds inferred by
[38], but avoids the explicit enumeration of reductions (and the concomitant
repeated construction of the abstract state-space) and is, as we believe, concep-
tually simpler to comprehend. Moreover, our game-based technique is the key
stepping stone for extending our method beyond k-safety in Section 6.

6 Veriﬁcation Beyond k-Safety

Building on the game-based interpretation of a reduction, we extend our ver-
iﬁcation beyond ∀∗ properties to support ∀∗∃∗ properties. We accomplish this
by combining the game-based reading of a reduction (as discussed in the pre-
vious section) with a game-based reading of existential quantiﬁcation. For the
remainder of this section, ﬁx an STS T = (X, init, step) and let

ϕ = ∀π1 : ξ1 . . . ∀πl : ξl.∃πl+1 : ξl+1 . . . ∃πk : ξk. φ

be the OHyperLTL formula we wish to check, i.e., we universally quantify over
l traces followed by an existential quantiﬁcation over k − l traces. We assume
that for every existential quantiﬁcation ∃πi : ξi occurring in ϕ, valid (t, ξi) holds
for every t ∈ Traces(T ) (we discuss this later in Remark 1).

6.1 Existential Trace Quantiﬁcation as a Game

The idea of a game-based veriﬁcation of ∀∗∃∗ properties is to consider a ∀∗∃∗-
property as a game between veriﬁer and refuter [22]. The refuter controls the l
universally quantiﬁed traces by moving through l copies of the system (thereby
producing traces π1, . . . , πl) and the veriﬁer reacts by, incrementally, moving

Software Veriﬁcation of Hyperproperties Beyond k-Safety

13

through k − l copies of the system (thereby producing traces πl+1, . . . , πk). If the
veriﬁer has a strategy that ensures that the resulting traces satisfy φ, T |= ϕ
holds. We call such a strategy for the veriﬁer a witness strategy.

We combine this game-based reading of existential quantiﬁcation with our
game-based interpretation of a reduction by, additionally, letting the veriﬁer con-
trol the scheduling of the system. When played on the concrete state-space of
T the game proceeds in three stages as follows: 1) The veriﬁer selects a valid
scheduling M ⊆ {π1, . . . , πk}; 2) The refuter selects successor states for all uni-
versally quantiﬁed copies by ﬁxing an assignment to X (cid:48)
(only moving
π1
copies scheduled by M ); 3) The veriﬁer reacts by choosing successor states for the
existentially quantiﬁed copies by ﬁxing an assignment to X (cid:48)
, . . . , X (cid:48)
(again,
πk
only moving copies scheduled by M ). Afterward, the process repeats.

, . . . , X (cid:48)
πl

πl+1

As we work within a ﬁxed abstraction of T , the veriﬁer can, however, not
choose concrete successor states directly but only work in the precision captured
by the abstraction. Following the general scheme of abstract games, we, therefore,
underapproximate the moves available to the veriﬁer [2]. Formally, we abstract
the three-stage game outlined before (which was played at the level of concrete
states) to a simpler abstract game (consisting of only two stages). In the ﬁrst
stage, the veriﬁer selects both a scheduling M and a restriction on the set of
abstract successor states, i.e., a set of abstract states A. In the second stage,
the refuter cannot choose any abstract successor state (any M -successor in the
terminology from Section 5), but only successors contained in the restriction A.
To guarantee the soundness of this approach, we ensure that the veriﬁer can
only pick restrictions that are valid, i.e., restrictions that underapproximate the
possibilities of the veriﬁer on the level of concrete states.

Game Construction. We modify our game from Section 5 as follows. States are
either of the form (ˆs, q, b) (as in Section 5) or of the form (ˆs, q, b, M, A) where ˆs,
q, b, and M are as in Section 5, and A ⊆ Bn is a subset of abstract states (the
restriction). To reﬂect the restriction, we modify transition rules (1) and (3).
Rule (2) remains unchanged.

∀πi ∈ M. ¬b[i] ∨ ¬obs(ˆs)[i]

(ˆs, q, b) (cid:32) (ˆs, q, b, M, A)

validRes ˆs,M

A (1)

ˆs(cid:48) ∈ A b(cid:48) = b[i (cid:55)→ (cid:62)]i∈M
(ˆs, q, b, M, A) (cid:32) (ˆs(cid:48), q, b(cid:48))

(3)

In rule (1), the safety player (who, again, takes the role of the veriﬁer) selects
both a scheduling M and a restriction A such that validRes ˆs,M
holds (which we
deﬁne later). The reachability player (who takes the role of the refuter) can, in
rule (3), select any successor contained in A.

A

Valid Restriction. The above game construction depends on the deﬁnition of
validRes ˆs,M
A . Intuitively, A is a valid restriction if it underapproximates the pos-
sibilities of a witness strategy that can pick concrete successor states for all
existentially quantiﬁed traces. That is, for every concrete state in ˆs, a witness
strategy (on the level of concrete states) can guarantee a move to a concrete state
that is abstracted to an abstract state within A. Formally we deﬁne validRes ˆs,M
as follows:

A

14

R. Beutner and B. Finkbeiner

∀{Xπi}k

i=1.∀{X (cid:48)
πi

⇒ ∃{X (cid:48)
πi

}k
i=l+1.

l
(cid:94)

(cid:16)

ite

∧

πi ∈ M, step(cid:104)πi(cid:105),

i=1
(cid:16)
πi ∈ M, step(cid:104)πi(cid:105),

ite

ˆs
(cid:75)

}l
i=1.
(cid:74)
k
(cid:94)

i=l+1

(cid:17)

x(cid:48)
πi

= xπi

(cid:94)

x∈X

(cid:94)

x∈X

x(cid:48)
πi

= xπi

(cid:17)

∧

(cid:104)(cid:48)(cid:105)

ˆs(cid:48)

(cid:95)
ˆs(cid:48)∈A(cid:74)

(cid:75)

It expresses that for all concrete states in
i=1) and for
ˆs
(cid:75)
all concrete successor states for the universally quantiﬁed copies (assignments
to {X (cid:48)
}l
i=1), there exist successor states for the existentially quantiﬁed copies
πi
}k
({X (cid:48)
i=l+1) such that one of the abstract states in A is reached.
πi

(assignments to {Xπi}k

(cid:74)

Example 1. With this deﬁnition at hand, we can validate the restrictions cho-
sen by the strategy in Figure 3c. For example, in state α7 the strategy sched-
ules M = {2} and restricts the successor states to {α8} even though abstract
(cid:3) is also a {2}-successor of α7. If we spell out
state (cid:2)(6, 4), a1 = a2, x1 (cid:54)= x2
validRes α7,{2}
{α8} we get

(cid:16) (cid:94)

∧

(cid:17)

z(cid:48)
1 = z1

⇒ ∃X (cid:48)

∀X1 ∪X2 ∪X (cid:48)

1. a1 = a2
(cid:124) (cid:123)(cid:122) (cid:125)
α7
(cid:74)

(cid:125)
where X = {a, x, y}. Here we assume that step := (cid:0)a(cid:48) = a ∧ y(cid:48) = y(cid:1) is the update
performed on instruction x ← (cid:63)N from Q2:3 to Q2:4. The above formula is valid.

(cid:104)(cid:48) (cid:105)
(cid:75)

z∈X

(cid:75)

2. a(cid:48)
(cid:124)

2 = a2 ∧ y(cid:48)
(cid:123)(cid:122)
step(cid:104)2 (cid:105)

2 = y2
(cid:125)

1 = a(cid:48)

∧ (cid:0)a(cid:48)
(cid:124)

1 = x(cid:48)
2

(cid:1)

2 ∧ x(cid:48)
(cid:123)(cid:122)
α8
(cid:74)

Correctness. Call the resulting game G∀∃
(T ,ϕ,P). The game combines the search for
a reduction with that of a witness strategy (both within the precision captured
by P).3 We can show:

Theorem 3. If player SAFE wins G∀∃

(T ,ϕ,P), then T |= ϕ.

Proof sketch. Let σ be a winning strategy for SAFE in G∀∃
(T ,ϕ,P). Let t1, . . . , tl ∈
Traces(T ) be arbitrary. We use σ to incrementally construct witness traces
tl+1, . . . , tk by querying σ. In every abstract state ˆs, σ selects a scheduling M and
a restriction A such that validRes ˆs,M
holds. We plug the current concrete state
(reached in our construction of tl+1, . . . , tk) into the universal quantiﬁcation of
validRes ˆs,M
and get (concrete) witnesses for the existential quantiﬁcation that,
by deﬁnition of validRes ˆs,M
A , are valid successors for the existentially quantiﬁed
(cid:117)(cid:116)
copies in T .

A

A

Remark 1. Recall that we assume that for every existential quantiﬁcation ∃πi : ξi
occurring in ϕ and all t ∈ Traces(T ), valid (t, ξi) holds. This is important to
ensure that the safety player (the veriﬁer) cannot avoid observation points for-
ever. We could drop this assumption by strengthening the winning condition in
G∀∃
(T ,ϕ,P) and explicitly state that, in order to win, SAFE needs to visit observa-
tions points on existentially quantiﬁed traces inﬁnitely many times.

3 In particular, G∀∃

(T ,ϕ,P) (strictly) generalizes the construction of G∀
(T ,ϕ,P) from Sec-
tion 5: If k = l (i.e, the property is a ∀∗-property) the unique minimal valid restriction
from ˆs, M is {ˆs(cid:48) | ˆs M−→ ˆs(cid:48)}, i.e., the set of all M -successors of ˆs. The safety player
can thus not be more restrictive than allowing all M -successors (as in G∀

(T ,ϕ,P)).

Software Veriﬁcation of Hyperproperties Beyond k-Safety

15

Clairvoyance vs. Abstraction. The cooperation between reduction (the ability
of the veriﬁer to select schedulings) and witness strategy (the ability to select
restrictions on the successor) can be seen as a limited form of prophecy [1,14].
By ﬁrst scheduling the universal copies, the witness strategy can peek at future
moves before committing to a successor state, as we e.g., saw in Figure 3. The
“theoretically optimal” reduction is thus a sequential one that ﬁrst schedules
only the universally quantiﬁed traces (until an observation point is reached)
and thereby provides maximal information for the witness strategy. However,
in the context of a ﬁxed abstraction, this reduction is not always optimal. For
example, in Figure 3 the strategy schedules the loop in lock-step which is crucial
for generating a proof with simple (linear) invariants. In particular, Figure 3 does
not admit a witness strategy in the lock-step reduction and does not admit a
proof with linear invariants in a sequential reduction. Our veriﬁcation framework,
therefore, strikes a delicate balance between clairvoyance needed by the witness
strategy and precision captured in the abstraction, further emphasizing why the
searches for reduction and witness strategy need to be mutually dependent.

6.2 Constructing and Solving G∀∃

(T ,ϕ,P)

Constructing the game graph of
G∀∃
(T ,ϕ,P) requires the identiﬁcation
of all valid restrictions (of which
there are exponentially many in
the number of abstract states and
thus double exponentially many in
the number of predicates) each of
which requires to solve a quan-
tiﬁed SMT query. We propose
a more eﬀective algorithm that
solves G∀∃
(T ,ϕ,P) without construct-
ing it explicitly. Instead, we iter-
atively reﬁne an abstraction ˜G of
G∀∃
(T ,ϕ,P). Our method hinges on
the following easy observation:

Algorithm 1 Iterative solver for G∀∃

(T ,ϕ,P).

case REACH(σ): return REACH
case SAFE(σ):

1: Input: T , ϕ, P
2: ˜G := initialApproximation(T , ϕ, P)
3: repeat
4: match Solve( ˜G) with
5:
6:
7:
8:
9:
10:
11:
12:

then
for all A(cid:48) ⊆ A do

goto 4
return SAFE

if ¬validRes ˆs,M

A

˜G := Remove( ˜G, (ˆs, M, A(cid:48)))

for all (ˆs, M, A) ∈ Restrictions(σ) do

Lemma 1. For any ˆs and M , {A | validRes ˆs,M

A } is upwards closed (w.r.t. ⊆).

Our initial abstraction consists of all possible restrictions (even those that
might be invalid), i.e., we allow all restrictions of the form (ˆs, M, A) where A ⊆
{ˆs(cid:48) | ˆs M−→ ˆs(cid:48)}.4 This overapproximates the power of the safety player, i.e., a
winning strategy for SAFE in ˜G may not be valid in G∀∃
(T ,ϕ,P). To remedy this, we
propose the following inner reﬁnement loop: If we ﬁnd a winning strategy σ for

4 Note that {ˆs(cid:48) | ˆs M−→ ˆs(cid:48)} is always a valid restriction. Importantly, we can compute
{ˆs(cid:48) | ˆs M−→ ˆs(cid:48)} locally, i.e., by iterating over abstract states opposed to sets of abstract
states.

16

R. Beutner and B. Finkbeiner

SAFE in ˜G we check if all restrictions chosen by σ are valid. If this is the case, σ
is also winning for G∀∃
(T ,ϕ,P) and we can apply Theorem 3. If we ﬁnd an invalid
restriction (ˆs, M, A) used by σ, we reﬁne ˜G by removing not only the restriction
(ˆs, M, A) but all (ˆs, M, A(cid:48)) with A(cid:48) ⊆ A (which is justiﬁed by Lemma 1). The
algorithm is sketched in Algorithm 1. The subroutine Restrictions(σ) returns all
restrictions used by σ, i.e., all tuples (ˆs, M, A) such that σ uses an edge (ˆs, q, b) (cid:32)
(ˆs, q, b, M, A) for some q, b. Remove( ˜G, (ˆs, M, A(cid:48))) removes from ˜G all edges of the
form (ˆs, q, b) (cid:32) (ˆs, q, b, M, A(cid:48)) for some q, b, and Solve solves a ﬁnite-state safety
game. To improve the algorithm further, in line 4 we always compute a maximal
safety strategy, i.e., a strategy that selects maximal restrictions (w.r.t. ⊆) and
therefore allows us to eliminate many invalid restrictions from ˜G simultaneously.
For safety games, there always exists such a maximal winning strategy (see
e.g. [11]). Note that while ˜G is large, solving this ﬁnite-state game can be done
very eﬃciently. The running time of solving G∀∃
(T ,ϕ,P) is dominated by the SMT
queries of which our reﬁnement loop, in practice, requires very few.

7

Implementation and Evaluation

When combining Theorem 3 and our it-
erative solver from Section 6.2 we ob-
tain an algorithm to verify ∀∗∃∗-safety
properties within a given abstraction.
We have implemented a prototype of
our method in a tool we call HyPA. We
use Z3 [35] to discharge SMT queries.
The input of our tool is provided as an
arbitrary STS in the SMTLIB format
[5], making it language independent. In
our programs, we make the program
counter explicit, allowing us to track
predicates locally [31].

Table 1: Evaluation of HyPA on k-
safety instances. We give the size of
the abstract game-space (Size), the
time taken to compute the abstraction
(tabs ), and the overall time taken by
HyPA (t). Times are given in seconds.

Instance

Size

tabs

t

DoubleSquareNI

819

92.3

92.8

HalfSquareNI

1166

85.9

86.5

SquaresSum

ArrayInsert

286

213

29.8

29.9

28.2

28.2

Exp1x3

112

4.5

4.5

268

12.0

11.9

Fig3

DoubleSquareNIﬀ

Evaluation for k-Safety. As a special
case of ∀∗∃∗ properties, HyPA is also
applicable to k-safety veriﬁcation. We
collected an exemplifying suite of pro-
grams and k-safety properties from the
literature [38,26,40,39,40] and manu-
ally translated them into STS (this can
be automated easily). The results are
given in Table 1. As done by Shemer
et al. [38], we already provide a set of
predicates that is suﬃcient for some reduction (but not necessarily the lockstep
or sequential one), the search for which is then automated by HyPA. Our results

ColIitem-Symm

Counter-Det

MultEquiv

Figure 2

23.7

24.0

10.2

23.8

19.0

18.9

10.3

24.1

121

216

757

494

333

9.9

9.8

Software Veriﬁcation of Hyperproperties Beyond k-Safety

17

Table 2: Evaluation of HyPA on ∀∗∃∗-safety veriﬁcation instances. We give the
size and construction time of the initial abstraction (Size and tabs ). For both
the direct (explicit) and lazy (Algorithm 1) solver we give the time to construct
(and solve) the game (tsolve ) and the overall time (t = tabs + tsolve ). For the lazy
solver we, additionally, give the number of reﬁnement iterations (#Ref). Times
are given in seconds. TO indicates a timeout after 5 minutes.

Instance

Size

tabs

tsolve

t

#Ref

tsolve

t

Direct

Lazy

NonDetAdd

4568

CounterSum

AsynchGNI

CompilerOpt1

CompilerOpt2

Reﬁne

Reﬁne2

Smaller

CounterDiﬀ

479

437

354

338

1357

1476

327

959

3.5

5.3

6.1

2.4

2.8

6.1

5.6

2.3

8.5

TO TO

9.1

6.9

2.3

2.4

14.4

13.0

4.7

5.2

TO TO

TO TO

4.0

6.3

18.3

26.8

Figure 3

3180

11.1

TO TO

P1 (simple)

83

2.0

1.4

3.4

P1 (GNI)

P2 (GNI)

P3 (GNI)

P4 (GNI)

34793

17.0

TO TO

15753

10.2

TO TO

1429

6.6

20.9

27.5

7505

16.5

TO TO

4

17

1

2

2

4

5

11

19

22

1

72

7

7

72

1.0

0.9

0.1

0.2

0.2

0.7

0.6

0.4

1.1

2.9

0.1

4.5

6.2

6.2

2.6

3.0

6.8

6.2

2.7

9.6

14.0

2.1

95.7

112.7

5.1

0.6

15.3

7.2

13.2

29.7

show the game-based search for a reduction can verify interesting k-safety prop-
erties from the literature. We also note that, currently, the vast majority of time
is spent on the construction of the abstract system. If we would move to a ﬁxed
language, the computation time of the initial abstraction could be reduced by
using existing (heavily optimized) abstraction tools [31,17].

Evaluation Beyond k-Safety. The main novelty of HyPA lies in its ability to, for
the ﬁrst time, verify temporal properties beyond k-safety. As none of the existing
tools can verify such properties, we compiled a collection of very small example
programs and ∀∗∃∗-safety properties. Additionally, we modiﬁed the boolean pro-
grams from [13] (where they checked GNI on boolean programs) by including
data from inﬁnite domains. The properties we checked range from reﬁnement
properties for compiler optimizations, over general reﬁnement of nondeterminis-
tic programs, to generalized non-interference. Veriﬁcation often requires a non-

18

R. Beutner and B. Finkbeiner

trivial combination of reduction and witness strategy (as the reduction must,
e.g., compensate for branches of diﬀerent lengths). As before, we provide a set of
predicates and let HyPA automatically search for a witness strategy with accom-
panying reduction. We list the results in Table 2. To highlight the eﬀectiveness
of our inner reﬁnement loop, we apply both a direct (explicit) construction of
G∀∃
(T ,ϕ,P) and the lazy (iterative) solver in Algorithm 1. Our lazy solver (Al-
gorithm 1) clearly outperforms an explicit construction and is often the only
method to solve the game in reasonable time. In particular, we require very few
reﬁnement iterations and therefore also few expensive SMT queries. Unsurpris-
ingly, the problem of verifying properties beyond k-safety becomes much more
challenging (compared to k-safety veriﬁcation) as it involves the synthesis of a
witness function which is already 2EXPTIME-hard for ﬁnite-state systems [36,22].
We emphasize that no other existing tool can verify any of the benchmarks.

8 Related Work

Asynchronous Hyperproperties. Recently, many logics for the formal speciﬁca-
tion of asynchronous hyperproperties have been developed [9,30,16,13]. Our logic
OHyperLTL is closely related to stuttering HyperLTL (HyperLTLS) [16]. In
HyperLTLS each temporal operator is endowed with a set of temporal formulas
Γ and steps where the truth values of all formulas in Γ remain unchanged are
ignored during the operator’s evaluation. As for most mechanisms used to design
asynchronous hyperlogics [9,30,16], ﬁnite-state model checking of HyperLTLS is
undecidable. By contrast, in OHyperLTL, we always observe the trace at a ﬁxed
location, which is key for ensuring decidable ﬁnite-state model checking.

k-Safety Veriﬁcation. The literature on k-safety veriﬁcation is rich. Many ap-
proaches verify k-safety by using a form of self-composition [8,24,19,27] and
often employ reductions to obtain compositions that are easier to verify. Our
game-based interpretation of a reduction (Section 5) is related to Shemer et
al. [38], who study k-safety veriﬁcation within a given predicate abstraction us-
ing an enumeration-based solver (see Section 5 for a discussion). Farzan and
Vandikas [26] present a counterexample-guided reﬁnement loop that simulta-
neously searches for a reduction and a proof. Sousa and Dillig [39] facilitate
reductions at the source-code level in program logic.

∀∗∃∗-Veriﬁcation. Barthe et al. [7] describe an asymmetric product of the sys-
tem such that only a subset of the behavior of the second system is preserved,
thereby allowing the veriﬁcation of ∀∗∃∗ properties. Constructing an asymmetric
product and verifying its correctness (i.e., showing that the product preserves
all behavior of the ﬁrst, universally quantiﬁed, system) is challenging. Unno
et al. [40] present a constraint-based approach to verify functional (opposed to
temporal) ∀∃ properties in inﬁnite-state systems using an extension of constraint
Horn clauses called pfwCHC. The underlying veriﬁcation approach is orthogo-
nal to ours: pfwCHC allows for a clean separation of the actual veriﬁcation and

Software Veriﬁcation of Hyperproperties Beyond k-Safety

19

veriﬁcation conditions, whereas our approach combines both. For example, our
method can prove the existence of a witness strategy without ever formulating
precise constraints on the strategy (which seems challenging). Coenen et al. [22]
introduce the game-based reading of existential quantiﬁcation to verify temporal
∀∗∃∗ properties in a synchronous and ﬁnite-state setting. By contrast, our work
constitutes the ﬁrst veriﬁcation method for temporal ∀∗∃∗-safety properties in
inﬁnite-state systems. The key to our method is a careful integration of reduc-
tions which is not possible in a synchronous setting. For ﬁnite-state systems
(where the abstraction is precise) and synchronous speciﬁcations (where we ob-
serve every step), our method subsumes the one in [22]. Beutner and Finkbeiner
[14] use prophecy variables to ensure that the game-based reading of existential
quantiﬁcation is complete in a ﬁnite-state setting. Automatically constructing
prophecies for inﬁnite-state systems is interesting future work. Pommellet and
Touili [37] study the veriﬁcation of HyperLTL in inﬁnite-state systems arising
from pushdown systems. By contrast, we study veriﬁcation in inﬁnite-state sys-
tems that arise from the inﬁnite variables domains used in software.

Game Solving. Our game-based interpretations are naturally related to inﬁnite-
state game solving [25,4,41,15]. State-of-the-art solvers for inﬁnite-state games
unroll the game [25], use necessary subgoals to inductively split a game into
subgames [4], encode the game as a constraint system [15], and iteratively reﬁne
the controllable predecessor operator [41]. We tried to encode our veriﬁcation
approach directly as an inﬁnite-state linear-arithmetic game. However, existing
solvers (which, notably, work without a user-provided set of predicates) could not
solve the resulting game [25,4]. Our method for encoding the witness strategy us-
ing restrictions corresponds to hyper-must edges in general abstract games [2,3].
Our inner reﬁnement loop for solving a game with hyper-must edges without
explicitly identifying all edges (Algorithm 1) is thus also applicable in general
abstract games.

9 Conclusion

In this work, we have presented the ﬁrst veriﬁcation method for temporal hy-
perproperties beyond k-safety in inﬁnite-state systems arising in software. Our
method is based on a game-based interpretation of reductions and existential
quantiﬁcation and allows for mutual dependence of both. Interesting future di-
rections include the integration of our method in a counter-example guided re-
ﬁnement loop that automatically reﬁnes the abstraction and ways to lift the
current restriction to temporally safe speciﬁcations. Moreover, it is interesting
to study if, and to what extent, the numerous other methods developed for k-
safety veriﬁcation of inﬁnite-state systems (apart from reductions) are applicable
to the vast landscape of hyperproperties that lies beyond k-safety.

Acknowledgments This work was partially supported by the DFG in project
389792660 (Center for Perspicuous Systems, TRR 248). R. Beutner carried out
this work as a member of the Saarbr¨ucken Graduate School of Computer Science.

20

R. Beutner and B. Finkbeiner

References

1. Abadi, M., Lamport, L.: The existence of reﬁnement mappings. Theor. Comput.

Sci. 82(2) (1991). https://doi.org/10.1016/0304-3975(91)90224-P

2. de Alfaro, L., Godefroid, P., Jagadeesan, R.: Three-valued abstractions of games:
Uncertainty, but with precision. In: IEEE Symposium on Logic in Computer Sci-
ence, LICS 2004. IEEE (2004). https://doi.org/10.1109/LICS.2004.1319611

3. de Alfaro, L., Roy, P.: Solving games via three-valued abstraction reﬁnement. In: In-
ternational Conference on Concurrency Theory, CONCUR 2007. LNCS, vol. 4703.
Springer (2007). https://doi.org/10.1007/978-3-540-74407-8 6

4. Baier, C., Coenen, N., Finkbeiner, B., Funke, F., Jantsch, S., Siber, J.: Causality-
based game solving. In: International Conference on Computer Aided Veriﬁcation,
CAV 2021. LNCS, vol. 12759. Springer (2021). https://doi.org/10.1007/978-3-030-
81685-8 42

5. Barrett, C., Stump, A., Tinelli, C., et al.: The smt-lib standard: Version 2.0. In:

International Workshop on Satisﬁability Modulo Theories. vol. 13 (2010)

6. Barrett, C.W., Fang, Y., Goldberg, B., Hu, Y., Pnueli, A., Zuck, L.D.: TVOC:
A translation validator for optimizing compilers. In: International Conference
on Computer Aided Veriﬁcation, CAV 2005. LNCS, vol. 3576. Springer (2005).
https://doi.org/10.1007/11513988 29

7. Barthe, G., Crespo, J.M., Kunz, C.: Beyond 2-safety: Asymmetric product pro-
grams for relational program veriﬁcation. In: International Symposium on Log-
ical Foundations of Computer Science, LFCS 2013. vol. 7734. Springer (2013).
https://doi.org/10.1007/978-3-642-35722-0 3

8. Barthe, G., D’Argenio, P.R., Rezk, T.:

Secure

self-composition. Math.

by
https://doi.org/10.1017/S0960129511000193

Struct.

Comput.

Sci.

information
21(6)

ﬂow
(2011).

9. Baumeister, J., Coenen, N., Bonakdarpour, B., Finkbeiner, B., S´anchez, C.: A
temporal
logic for asynchronous hyperproperties. In: International Conference
on Computer Aided Veriﬁcation, CAV 2021. LNCS, vol. 12759. Springer (2021).
https://doi.org/10.1007/978-3-030-81685-8 33

10. Benton, N.: Simple relational correctness proofs for static analyses and program
transformations. In: ACM Symposium on Principles of Programming Languages,
POPL 2004. ACM (2004). https://doi.org/10.1145/964001.964003

11. Bernet, J., Janin, D., Walukiewicz,

I.: Permissive strategies:

Informatics Appl. 36(3)

from parity
(2002).

to safety games. RAIRO Theor.

games
https://doi.org/10.1051/ita:2002013

12. Beutner, R., Carral, D., Finkbeiner, B., Hofmann, J., Kr¨otzsch, M.: De-
In: Annual
ciding hyperproperties combined with functional speciﬁcations.
ACM/IEEE Symposium on Logic in Computer Science, LICS 2022. ACM (2022).
https://doi.org/10.1145/3531130.3533369

13. Beutner, R., Finkbeiner, B.: A temporal logic for strategic hyperproperties. In:
International Conference on Concurrency Theory, CONCUR 2021. LIPIcs, vol. 203.
Schloss Dagstuhl (2021). https://doi.org/10.4230/LIPIcs.CONCUR.2021.24
14. Beutner, R., Finkbeiner, B.: Prophecy variables for hyperproperty veriﬁcation.
In: IEEE Computer Security Foundations Symposium, CSF 2022. IEEE (2022).
https://doi.org/10.1109/CSF54842.2022.00030

15. Beyene, T.A., Chaudhuri, S., Popeea, C., Rybalchenko, A.: A constraint-
based approach to solving games on inﬁnite graphs. In: Annual ACM Sym-
posium on Principles of Programming Languages, POPL 2014. ACM (2014).
https://doi.org/10.1145/2535838.2535860

Software Veriﬁcation of Hyperproperties Beyond k-Safety

21

16. Bozzelli, L., Peron, A., S´anchez, C.: Asynchronous extensions of HyperLTL. In:
Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2021. IEEE
(2021). https://doi.org/10.1109/LICS52264.2021.9470583

17. Chaki, S., Clarke, E.M., Groce, A., Jha, S., Veith, H.: Modular veriﬁca-
tion of software components in C. IEEE Trans. Software Eng. 30(6) (2004).
https://doi.org/10.1109/TSE.2004.22

18. Chaudhuri, S., Gulwani, S., Lublinerman, R.: Continuity and robustness of pro-
grams. Commun. ACM 55(8) (2012). https://doi.org/10.1145/2240236.2240262
19. Churchill, B.R., Padon, O., Sharma, R., Aiken, A.: Semantic program align-
ment
In: ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation, PLDI 2019. ACM (2019).
https://doi.org/10.1145/3314221.3314596

for equivalence checking.

20. Clarkson, M.R., Finkbeiner, B., Koleini, M., Micinski, K.K., Rabe, M.N., S´anchez,
C.: Temporal logics for hyperproperties. In: International Conference on Prin-
ciples of Security and Trust, POST 2014. LNCS, vol. 8414. Springer (2014).
https://doi.org/10.1007/978-3-642-54792-8 15

21. Clarkson, M.R.,

Schneider, F.B.: Hyperproperties.

In:

puter
https://doi.org/10.1109/CSF.2008.7

Foundations

Security

Symposium, CSF

2008.

IEEE Com-
IEEE (2008).

22. Coenen, N., Finkbeiner, B., S´anchez, C., Tentrup, L.: Verifying hyperliveness. In:
International Conference on Computer Aided Veriﬁcation, CAV 2019. LNCS, vol.
11561. Springer (2019). https://doi.org/10.1007/978-3-030-25540-4 7

23. D’Antoni, L., Veanes, M.: The power of symbolic automata and transducers. In:
International Conference on Computer Aided Veriﬁcation, CAV 2017. LNCS, vol.
10426. Springer (2017). https://doi.org/10.1007/978-3-319-63387-9 3

24. Eilers, M., M¨uller, P., Hitz, S.: Modular product programs. ACM Trans. Program.

Lang. Syst. 42(1) (2020). https://doi.org/10.1145/3324783

25. Farzan, A., Kincaid, Z.: Strategy synthesis for linear arithmetic games. Proc. ACM

Program. Lang. 2(POPL) (2018). https://doi.org/10.1145/3158149

26. Farzan, A., Vandikas, A.: Automated hypersafety veriﬁcation. In: International
Conference on Computer Aided Veriﬁcation, CAV 2019. LNCS, vol. 11561. Springer
(2019). https://doi.org/10.1007/978-3-030-25540-4 11

27. Finkbeiner, B., Rabe, M.N., S´anchez, C.: Algorithms for model checking HyperLTL
and HyperCTL∗. In: International Conference on Computer Aided Veriﬁcation,
CAV 2015. LNCS, vol. 9206. Springer (2015). https://doi.org/10.1007/978-3-319-
21690-4 3

28. Ge, Q., Yarom, Y., Cock, D., Heiser, G.: A survey of microarchitectural timing
attacks and countermeasures on contemporary hardware. J. Cryptogr. Eng. 8(1)
(2018). https://doi.org/10.1007/s13389-016-0141-6

29. Graf, S., Sa¨ıdi, H.: Construction of abstract state graphs with PVS. In: Interna-
tional Conference on Computer Aided Veriﬁcation, CAV 1997. LNCS, vol. 1254.
Springer (1997). https://doi.org/10.1007/3-540-63166-6 10

30. Gutsfeld, J.O., M¨uller-Olm, M., Ohrem, C.: Automata and ﬁxpoints

for
asynchronous hyperproperties. Proc. ACM Program. Lang. 5(POPL) (2021).
https://doi.org/10.1145/3434319

31. Henzinger, T.A., Jhala, R., Majumdar, R., Sutre, G.: Lazy abstraction. In: ACM
Symposium on Principles of Programming Languages, POPL 2002. ACM (2002).
https://doi.org/10.1145/503272.503279

32. Jhala, R., Podelski, A., Rybalchenko, A.: Predicate abstraction for pro-
(2018).

In: Handbook of Model Checking. Springer

gram veriﬁcation.
https://doi.org/10.1007/978-3-319-10575-8 15

22

R. Beutner and B. Finkbeiner

33. Lipton, R.J.: Reduction: A method of proving properties of parallel programs.

Commun. ACM 18(12) (1975). https://doi.org/10.1145/361227.361234

34. McCullough, D.: Noninterference and the composability of security proper-
ties. In: IEEE Symposium on Security and Privacy, SP 1988. IEEE (1988).
https://doi.org/10.1109/SECPRI.1988.8110

35. de Moura, L.M., Bjørner, N.: Z3: an eﬃcient SMT solver. In: International Con-
ference on Tools and Algorithms for the Construction and Analysis of Systems,
TACAS 2008. LNCS, vol. 4963. Springer (2008). https://doi.org/10.1007/978-3-
540-78800-3 24

36. Pnueli, A., Rosner, R.: On the synthesis of a reactive module. In: Annual ACM
Symposium on Principles of Programming Languages, POPL 1989. ACM (1989).
https://doi.org/10.1145/75277.75293

37. Pommellet, A., Touili, T.: Model-checking HyperLTL for pushdown systems. In:
International Symposium on Model Checking Software, SPIN 2018. LNCS, vol.
10869. Springer (2018). https://doi.org/10.1007/978-3-319-94111-0 8

38. Shemer, R., Gurﬁnkel, A., Shoham, S., Vizel, Y.: Property directed self compo-
sition. In: International Conference on Computer Aided Veriﬁcation, CAV 2019.
LNCS, vol. 11561. Springer (2019). https://doi.org/10.1007/978-3-030-25540-4 9

39. Sousa, M., Dillig, I.: Cartesian hoare logic for verifying k-safety properties. In: ACM
SIGPLAN Conference on Programming Language Design and Implementation,
PLDI 2016. ACM (2016). https://doi.org/10.1145/2908080.2908092

40. Unno, H., Terauchi, T., Koskinen, E.: Constraint-based relational veriﬁcation. In:
International Conference on Computer Aided Veriﬁcation, CAV 2021. LNCS, vol.
12759. Springer (2021). https://doi.org/10.1007/978-3-030-81685-8 35

41. Walker, A., Ryzhyk, L.: Predicate abstraction for

reactive synthesis.

Formal Methods in Computer-Aided Design, FMCAD 2014.
https://doi.org/10.1109/FMCAD.2014.6987617

In:
IEEE (2014).

Software Veriﬁcation of Hyperproperties Beyond k-Safety

23

A Proofs for Section 4

Theorem 1. Assume an STS T with ﬁnite variable domains and decidable back-
ground theory and an OHyperLTL formula ϕ. It is decidable if T |= ϕ.

Proof. Let X be the set of variables in T and let D be the ﬁnite domain of
the variables (for simplicity we assume that the domain of all variables is the
same). An explicit state is then an assignment α : X → D. Let S be the (ﬁnite)
set of all explicit states. An (explicit) ﬁnite-state transition system is a tuple
T = (S, S0, ρ) where S ⊆ S is a set of explicit states, S0 ⊆ S is a set of initial
states, and ρ ⊆ S × S is the transition relation. The set of traces Traces(T ) is
deﬁned as expected.

Under the assumption on T , we can view it as a explicit (and computable)

ﬁnite-state transition system.

For any observation formula ξ let O(ξ) ⊆ S be the set of all states in which

ξ holds (which is computeable).

Given T = (S, S0, ρ) and ξ we construct an explicit ﬁnite-state transition
ξ | t ∈ Traces(T ) ∧ valid (t, ξ)}. We deﬁne
(cid:77)

system Tξ such that Traces(Tξ) = {
Tξ := (O(ξ) ∩ S, S(cid:48)

0, ρ(cid:48)) where

t
(cid:76)

0 := (cid:8)s ∈ O(ξ) ∩ S | ∃s0, s1, . . . , sn ∈ S. s0 ∈ S0 ∧ sn = s ∧
S(cid:48)

∀0 ≤ i ≤ n − 1. (si, si+1) ∈ ρ ∧
∀0 ≤ i ≤ n − 1. si (cid:54)∈ O(ξ)(cid:9).

That is all states where ξ holds that are reachable from some state in S0 in T
without passing through another state where ξ holds. Similarly we deﬁne

ρ(cid:48) := (cid:8)(s, s(cid:48)) ∈ (O(ξ) ∩ S)2 | ∃s0, s1, . . . , sn ∈ S. n ≥ 1 ∧ s0 = s ∧ sn = s(cid:48) ∧

∀0 ≤ i ≤ n − 1. (si, si+1) ∈ ρ ∧
∀1 ≤ i ≤ n − 1. si (cid:54)∈ O(ξ)(cid:9).

I.e., there is an edge (s, s(cid:48)) only if s and s(cid:48) are connected by a path of length at
least 1 of unobserved states in S.

t
(cid:77)

As Traces(Tξ) = {
(cid:76)

ξ | t ∈ Traces(T ) ∧ valid (t, ξ)} we can reduce OHyper-
LTL model checking on T to HyperLTL model checking on Tξ, which is decidable
[27]. Note that a OHyperLTL can use diﬀerent observation formulas for diﬀerent
quantiﬁers. In the resulting HyperLTL model checking instance we thus need to
resolve diﬀerent quantiﬁers on diﬀerent systems (as, in general, Tξ (cid:54)= Tξ(cid:48) when
ξ (cid:54)≡ ξ(cid:48)), which is easily done.
(cid:117)(cid:116)

24

R. Beutner and B. Finkbeiner

B Proofs for Section 5

Theorem 2. If player SAFE wins G∀

(T ,ϕ,P), then T |= ϕ.

Proof. Let T = (X, init, step) be the STS, let ϕ = ∀π1 : ξ1. . . . ∀πk : ξk. φ be the
OHyperLTL formula, and let Aφ be the deterministic safety automaton for φ
used in the construction of G∀
(T ,ϕ,P). Assume that σ is a winning strategy for SAFE
in G∀
(T ,ϕ,P). We show that T |= ϕ. For this, let t1, . . . , tk ∈ Traces(T ) be arbitrary
ξ1 , . . . , πk (cid:55)→
traces such that valid (ti, ξi) for every i. We show that [π1 (cid:55)→
(cid:77)
ξk ] |= φ.
tk
(cid:76)
(cid:77)
The idea is to (implicitly) stutter traces t1, . . . , tk between two observation
points and compute a pointwise abstraction for these stuttered traces. The stut-
tering is dictated by σ, i.e., we simulate preﬁxes in the game and query σ to
determine which scheduling to pick. All non-scheduled copies are stuttered. If σ
picks a scheduling M , the refuter can pick (in G∀
(T ,ϕ,P)) an abstract successor
state that is compatible with M . In our simulation we pick the exact abstract
states that arises when moving as deﬁned by traces t1, . . . , tk, which, by deﬁ-
nition of M -successor, is a valid step in the game. This simulation thus gives
an abstraction of the stuttered traces which (as σ is winning) avoids a visit to
losing states in Aφ. In the following we give a more detailed description of this
high-level strategy.

t1

(cid:76)

For k assignment to X, µ1, . . . , µk we write µ1 ⊗ · · · ⊗ µk for the assignment
over (cid:126)X deﬁned by (µ1 ⊗ · · · ⊗ µk)(xπi) := µi(x). For each assignment µ to (cid:126)X we
deﬁne Abstract(µ) as the unique abstract state ˆs such that µ |=
. We zip the
ξk into a single trace t over assignments to (cid:126)X by deﬁning
ξ1, . . . ,
t1
traces
(cid:77)
(cid:77)
(cid:76)
(cid:76)
t(j) :=
t1
ξ1(j)⊗· · ·⊗
ξk (j). To show that [π1 (cid:55)→
ξk ] |= φ
(cid:77)
(cid:76)
(cid:77)
it suﬃces to show that the unique run of Aφ on t does not visit a bad state.

ˆs
(cid:75)
ξ1, . . . , πk (cid:55)→

tk
(cid:76)

t1
(cid:76)

tk

tk

(cid:74)

(cid:76)

(cid:77)

(cid:77)

Consider the construction in Figure 4. Note that this construction will never
ξ1 , . . . , πk (cid:55)→
(cid:77)

ﬁnish but allows us to point to key steps showing that [π1 (cid:55)→
ξk ] |= φ.
tk
(cid:77)
(cid:76)
We maintain a concrete state µi for each copy 1 ≤ i ≤ k, initially set to the
initial state according to the ﬁxed traces (line 1). Additionally we maintain a
counter ci that tracks at which position of ti the current state is located. It will
always be the case that µi = ti(ci).

t1

(cid:76)

The construction then simulates a play in G∀

(T ,ϕ,P) using the winning strategy
σ to resolve choices made by player SAFE as follows: The simulation starts in state
(ˆs, q, b) where ˆs is the initial abstract state based on t1, . . . , tk, q the initial state
of Aφ, and b = (cid:62)k (lines 3 - 5). Note that, by construction, this is an initial
game state in G∀

(T ,ϕ,P).

The simulation then continuously advances the play. If b = (cid:62)k and obs(ˆs) =
(cid:62)k it applies transition rule (2) in lines 8-12. In particular, the concrete states
µi, counters ci and abstract state ˆs remain unchanged. Otherwise it queries σ on
the current state (ˆs, q, b). By transition rule (1), σ can only select a scheduling
M (and not change the other state components). In line 14 we write
to mark
that we do not care about a value. Each trace ti where πi ∈ M then takes a step,

Software Veriﬁcation of Hyperproperties Beyond k-Safety

25

else

if b = (cid:62)k ∧ obs(ˆs) = (cid:62)k then
µ(cid:48)
i ← µi for 1 ≤ i ≤ k
c(cid:48)
i ← ci for 1 ≤ i ≤ k
ˆs(cid:48) ← ˆs
q(cid:48) ← δφ(q, ˆs)
b(cid:48) ← ⊥k

1: µi ← ti(0) for 1 ≤ i ≤ k
2: ci ← 0 for 1 ≤ i ≤ k
3: ˆs ← Abstract(µ1 ⊗ · · · ⊗ µk)
4: q ← qφ,0
5: b ← (cid:62)k
6: while true do
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26: end while

end if
µi ← µ(cid:48)
ci ← c(cid:48)
ˆs ← ˆs(cid:48)
q ← q(cid:48)
b ← b(cid:48)

i for 1 ≤ i ≤ k
i for 1 ≤ i ≤ k

( , , , M ) ← σ(ˆs, q, b)
c(cid:48)
i ← ite(πi ∈ M, ci + 1, ci) for 1 ≤ i ≤ k
µ(cid:48)
i ← ite(πi ∈ M, ti(ci), µi) for 1 ≤ i ≤ k
ˆs(cid:48) ← Abstract(µ(cid:48)
1 ⊗ · · · ⊗ µ(cid:48)
q(cid:48) ← q
b(cid:48) ← b[i (cid:55)→ (cid:62)]πi∈M

k)

Fig. 4: Construction for the proof of Theorem 2.

i.e., we increment ci for those copies, and we update the current state µi (lines
15 and 16). For non-scheduled copies ci is left unchanged and so is the concrete
state µi. We compute the new abstract state ˆs(cid:48) and update b (as in transition
rule (3)).

We can establish a few basic properties:

.
ˆs
(cid:75)

(cid:74)

– P1: Whenever the loop is entered, µ1 ⊗ · · · ⊗ µk |=

This follows directly from the construction and the deﬁnition of Abstract(·).

– P2: Whenever the loop is entered, µi = ti(ci) for all 1 ≤ i ≤ k.

This follows directly from the construction and the updates performed in
lines 15 and 16.

– P3: Let (ˆs, q, b) be the current state at the beginning of a loop body and
(ˆs(cid:48), q(cid:48), b(cid:48)) after the loop body has executed once. Then, in G∀
(T ,ϕ,P), player
REACH can force a play from (ˆs, q, b) to (ˆs(cid:48), q(cid:48), b(cid:48)) when the safety player
follows strategy σ.
In case the conditional in line 7 is taken this is trivial as it directly corre-
sponds to transition rule (2) of the game (the only one that is applicable

26

R. Beutner and B. Finkbeiner

(cid:74)

ˆs
(cid:75)

in that case). The more interesting direction is thus the case where lines
14-19 are executed. So let (ˆs, q, b) be a game state and let µ1, . . . , µk be the
current concrete states at the beginning of a loop iteration. By P1 we get
that µ1 ⊗ · · · ⊗ µk |=
. As (ˆs, q, b, M ) = σ(ˆs, q, b), game state (ˆs, q, b, M ) is
reachable under σ (using transition rule (1)). By P2 we have that µi = ti(ci)
for each i. As each ti is a trace in T we get that ti(ci) (cid:93) (ti(ci + 1))(cid:48) |= step.
Now µ(cid:48)
i |= step for all
πi ∈ M . It is therefore easy to see that ˆs M−→ ˆs(cid:48) (follows directly from the
deﬁnition of M−→). The game state (ˆs(cid:48), q(cid:48), b(cid:48)) reached after the loop is thus a
successor state of (ˆs, q, b, M ) via transition rule (3). So (ˆs, q, b) can take a
step to (ˆs, q, b, M ) that is ﬁxed by σ and from (ˆs, q, b, M ) player REACH can
move the game to (ˆs(cid:48), q(cid:48), b(cid:48)) as required.

i = µi for all non-scheduled copies πi (cid:54)∈ M , and µi (cid:93) µ(cid:48)

(cid:77)

t1
(cid:76)

tk
(cid:76)

ξ1, . . . , πk (cid:55)→

To show that [π1 (cid:55)→

ξk ] |= φ (or equivalently, that the
(cid:77)
unique run of Aφ on t does not visit a bad state) consider the following: We
focus on those iterations where the conditional on line 7 is taken. We mark these
with a superscript. That is µj
i is the value of µi when conditional in line 7 was
taken for the jth time, and similarly cj
i , ˆsj, and qj (for the values of ci, ˆs and q,
respectively). The important observation is that cj
i is now exactly the jth index
where ti satisﬁes the observation formula ξi, i.e.,
i ). This holds
by the design of G∀
(T ,ϕ,P), i.e., player SAFE can only schedule copies that have
not moved yet or have reached an observation point (via transition rule (1)).
We thus get

ξi(j) = ti(cj
(cid:77)

ti
(cid:76)

t(j) =

(cid:77)

ξ1(j) ⊗ · · · ⊗

t1
(cid:76)
i and by P1 µj

tk
(cid:76)
1 ⊗ · · · ⊗ µj

ξk (j) = t1(cj
(cid:77)

1) ⊗ · · · ⊗ tk(cj
k)

ˆsj

k |=

i ) = µj

By P2, ti(cj
. So t(j) |= ˆsj for every j ∈ N,
(cid:75)
i.e., the sequence ˆs0, ˆs1, . . . forms a pointwise abstraction of t. Moreover q0, q1, . . .
is the unique run of Aφ on ˆs0, ˆs1, . . .. As σ is winning and the construction
simulates an actual game play allowed by σ (as stated in P3), we get that all
states q0, q1, . . . are not losing. This already concludes that t is accepted by Aφ
ξ1, . . . , πk (cid:55)→
(does not have a rejecting run to a losing state), and so [π1 (cid:55)→
(cid:77)
(cid:117)(cid:116)
tk
(cid:76)

ξk ] |= φ as required.

t1
(cid:76)

(cid:74)

(cid:77)

Software Veriﬁcation of Hyperproperties Beyond k-Safety

27

C Proofs for Section 6

Theorem 3. If player SAFE wins G∀∃

(T ,ϕ,P), then T |= ϕ.

Proof. Let T = (X, init, step) be the STS, let ϕ = ∀π1 : ξ1. . . . ∀πl : ξl.∃πl+1 :
ξl+1. · · · ∃πk : ξk. φ be the OHyperLTL formula, and let Aφ be the deterministic
safety automaton for φ used in the construction of G∀∃
(T ,ϕ,P). Assume that σ
is a winning strategy for SAFE in G∀∃
(T ,ϕ,P). We show that T |= ϕ. For this,
let t1, . . . , tl ∈ Traces(T ) be arbitrary traces such that valid (ti, ξi) for every
1 ≤ i ≤ l. We will construct traces tl+1, . . . , tk ∈ Traces(T ) such that [π1 (cid:55)→
ξ1, . . . , πk (cid:55)→
t1
(cid:76)
(cid:77)
To do so we follow the idea used in the proof of Theorem 2 and query σ to
select a scheduling. In addition, we need to actually construct traces tl+1, . . . , tk.
The idea is to use the deﬁnition of validRes ˆs,M
A : In each step, we plug the current
concrete states in the universal quantiﬁers of validRes ˆs,M
and obtain a concrete
witness for the existentially quantiﬁed variables. These correspond exactly to
the successor states for the traces tl+1, . . . , tk. In the following we give a more
detailed construction.

ξk ] |= φ.

tk

A

(cid:76)

(cid:77)

For simplicity we assume that there is a unique concrete state µinit that
satisﬁes µinit |= init. Note that this implies that ti(0) = µinit for all 1 ≤ i ≤ l.
Let ˆsinit be the resulting initial abstract state if all k copies are in µinit . Consider
the construction in Figure 5 (which, again, does never terminate but allows the
construction of witness traces in the limit).

The basic construction is similar to that in the proof of Theorem 2. We again
maintain ˆs, q, and b and simulate the game using σ to resolve choices made by
player SAFE. Additionally, we maintain a trace ti for each l + 1 ≤ i ≤ k, initially
set to the length-1-trace consisting of µinit .

In lines 9-13 we then perform transition step (2) whenever this is possible. If
not, we query σ to determine a scheduling M and restriction A (in line 15). We
update the concrete state of universally quantiﬁed executions that are scheduled
(line 16 and 17). So far, this is identical to the construction in the proof of
Theorem 2. The crucial point is that we need to ﬁx a next concrete state for
the existentially quantiﬁed traces that are scheduled. Here we make use of the
deﬁnition of validRes ˆs,M

A . Recall that validRes ˆs,M

is deﬁned as:

A

∀{Xπi}k

i=1.∀{X (cid:48)
πi

⇒ ∃{X (cid:48)
πi

}k
i=l+1.

l
(cid:94)

(cid:16)

ite

∧

πi ∈ M, step(cid:104)πi(cid:105),

i=1
(cid:16)
πi ∈ M, step(cid:104)πi(cid:105),

ite

ˆs
(cid:75)

}l
i=1.
(cid:74)
k
(cid:94)

i=l+1

(cid:17)

x(cid:48)
πi

= xπi

(cid:94)

x∈X

(cid:94)

x∈X

x(cid:48)
πi

= xπi

(cid:17)

∧

(cid:95)
ˆs(cid:48)∈A(cid:74)

ˆs(cid:48)

(cid:104)(cid:48)(cid:105)
(cid:75)

We now know that µ1 ⊗ · · · ⊗ µk |=

at all times (similar to P1 in the

proof of Theorem 2). Moreover when using assignments µ1, . . . , µk for {Xπi}k
and µ(cid:48)

(cid:74)
}l
i=1 we get a satisfying model for

1, . . . , µ(cid:48)

i=1

ˆs
(cid:75)

l for {X (cid:48)
πi
l
(cid:94)

(cid:16)

ite

πi ∈ M, step(cid:104)πi(cid:105),

x(cid:48)
πi

= xπi

(cid:17)

,

(cid:94)

x∈X

i=1

28

R. Beutner and B. Finkbeiner

if b = (cid:62)k ∧ obs(ˆs) = (cid:62)k then
µ(cid:48)
i ← µi for 1 ≤ i ≤ k
c(cid:48)
i ← ci for 1 ≤ i ≤ k
ˆs(cid:48) ← ˆs
q(cid:48) ← δφ(q, ˆs)
b(cid:48) ← ⊥k

else

1: µi ← µinit for 1 ≤ i ≤ k
2: ci ← 0 for 1 ≤ i ≤ l
3: ˆs ← ˆsinit
4: q ← qφ,0
5: b ← (cid:62)k
6: ti = [µinit ] for l + 1 ≤ i ≤ k
7: while true do
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29: end while

end if
µi ← µ(cid:48)
ci ← c(cid:48)
ˆs ← ˆs(cid:48)
q ← q(cid:48)
b ← b(cid:48)

i for 1 ≤ i ≤ k
i for 1 ≤ i ≤ l

( , , , M, A) ← σ(ˆs, q, b)
c(cid:48)
i ← ite(πi ∈ M, ci + 1, ci) for 1 ≤ i ≤ l
µ(cid:48)
i ← ite(πi ∈ M, ti(ci), µi) for 1 ≤ i ≤ l
k ← extractModel (validRes ˆs,M
l+1, . . . , µ(cid:48)
µ(cid:48)
ˆs(cid:48) ← Abstract(µ(cid:48)
q(cid:48) ← q
b(cid:48) ← b[i (cid:55)→ (cid:62)]πi∈M
ti = ti + [µ(cid:48)

i] for l + 1 ≤ i ≤ k with πi ∈ M

1 ⊗ · · · ⊗ µ(cid:48)

k)

A , {µi}k

i=1, {µ(cid:48)

i}l

i=1)

Fig. 5: Construction for the proof of Theorem 3.

i.e., the premise in validRes ˆs,M
A . This holds as t1, . . . , tl are actual traces and
lines 16 and 17 only move those universally quantiﬁed copies that are actually
scheduled (see the proof of Theorem 2).

As validRes ˆs,M
A
l+1, . . . , µ(cid:48)

ments µ(cid:48)

k to {X (cid:48)
πi

}k
i=l+1 that satisﬁes

holds (by transition rule (1)) we thus get a concrete assign-

k
(cid:94)

(cid:16)

ite

i=l+1

πi ∈ M, step(cid:104)πi(cid:105),

x(cid:48)
πi

= xπi

(cid:17)

∧

(cid:94)

x∈X

(cid:104)(cid:48)(cid:105)

ˆs(cid:48)

(cid:95)
ˆs(cid:48)∈A(cid:74)

(cid:75)

i.e., the conclusion of validRes ˆs,M
l). We extract these
assignments in line 18. That is, we plug in the concrete assignments µ1, . . . , µk
and µ(cid:48)
k. For each copy l + 1 ≤ i ≤ k
that was scheduled in M we then update the existentially quantiﬁed traces with

l and get assignments µ(cid:48)

(together with µ(cid:48)

l+1, . . . , µ(cid:48)

1, . . . , µ(cid:48)

1, . . . , µ(cid:48)

A

Software Veriﬁcation of Hyperproperties Beyond k-Safety

29

this newly obtained assignment (line 22). By deﬁnition of validRes ˆs,M
construct traces tl+1, . . . , tk that are contained in Traces(T ).

A

this will

We claim that, in the limit, the traces tl+1, . . . , tk constructed serve as wit-
ness traces for t1, . . . , tl. The crucial point is that the construction essentially
simulates a play in G∀∃
(T ,ϕ,P) that is compatible with σ. In particular, note that,
A we get that ˆs(cid:48)
by construction of the assignments µ(cid:48)
(as computed in line 19) satisﬁes ˆs(cid:48) ∈ A, i.e., the abstract state is contained in
the restriction chosen by A. The game state (ˆs(cid:48), q(cid:48), b(cid:48)) is thus a successor state
of (ˆs, q, b, M, A) by transition rule (3).

k from validRes ˆs,M

l+1, . . . , µ(cid:48)

The proof that [π1 (cid:55)→

proof of Theorem 2.

t1

ξ1 , . . . , πk (cid:55)→
(cid:77)

(cid:76)

tk
(cid:76)

ξk ] |= φ is then analogous to the
(cid:77)
(cid:117)(cid:116)

