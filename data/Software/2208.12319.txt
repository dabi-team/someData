2
2
0
2

g
u
A
5
2

]
E
S
.
s
c
[

1
v
9
1
3
2
1
.
8
0
2
2
:
v
i
X
r
a

Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for
heterogeneous data source integration

JURAJ DONČEVIĆ, University of Zagreb, Faculty of electrical engineering and computing, Department of applied

computing, Croatia

KREŠIMIR FERTALJ, University of Zagreb, Faculty of electrical engineering and computing, Department of applied

computing, Croatia

MARIO BRČIĆ, University of Zagreb, Faculty of electrical engineering and computing, Department of applied

computing, Croatia

AGNEZA KRAJNA, University of Zagreb, Faculty of electrical engineering and computing, Department of applied

computing, Croatia

This paper deals with the mediator-wrapper architecture. It is an important architectural pattern that enables a more flexible and

modular architecture in opposition to monolithic architectures for data source integration systems. This paper identifies certain realistic

and concrete scenarios where the mediator-wrapper architecture underperforms. These issues are addressed with the extension of the

architecture via the mask component type. The mask component is detailed so it can be reasoned about without prescribing a concrete

programming language or paradigm. The benefits of the new mask-mediator-wrapper architecture are analytically proven in relevant

scenarios. One of the applications of the new architecture is envisioned for modern data sources integration systems backing Big data

processing.

CCS Concepts: • Software and its engineering → n-tier architectures; • Information systems → Mediators and data inte-

gration.

Additional Key Words and Phrases: heterogeneous data source integration, system architecture, mediator-wrapper, quantitative

analysis

ACM Reference Format:

Juraj Dončević, Krešimir Fertalj, Mario Brčić, and Agneza Krajna. 2022. Mask-Mediator-Wrapper: A revised mediator-wrapper

architecture for heterogeneous data source integration. 1, 1 (August 2022), 28 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION

Research of data integration has been active for a very long time and remains ongoing to this day. It is not surprising that

data integration has been examined from a multitude of angles. It started with simple ideas of monolithic multi-database

systems, then evolved following the popularity of federated systems [43]. The trail continued into architecture-based

research with the mediator-wrapper (MW) architecture, which brought some concrete systems into existence [10, 37, 38].

Authors’ addresses: Juraj Dončević, juraj.doncevic@fer.hr, University of Zagreb, Faculty of electrical engineering and computing, Department of applied
computing, Unska 3, Zagreb, Croatia, 10000; Krešimir Fertalj, kresimir.fertalj@fer.hr, University of Zagreb, Faculty of electrical engineering and computing,
Department of applied computing, Unska 3, Zagreb, Croatia, 10000; Mario Brčić, mario.brcic@fer.hr, University of Zagreb, Faculty of electrical engineering
and computing, Department of applied computing, Unska 3, Zagreb, Croatia, 10000; Agneza Krajna, agneza.krajna@fer.hr, University of Zagreb, Faculty
of electrical engineering and computing, Department of applied computing, Unska 3, Zagreb, Croatia, 10000.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for third-party
components of this work must be honored. For all other uses, contact the owner/author(s).

© 2022 Copyright held by the owner/author(s).
Submitted version

1

 
 
 
 
 
 
2

Dončević, et al.

At that point the idea of NoSQL systems started to appear. As data was no longer just being stored in relational databases,

but also in schemaless formats in specialized DBMSs and even files, the research community started to express data

integration more in terms of data sources.

Data exchange/interchange between data sources was also presented as an idea later on [35]. In parallel, ETL

processes over multiple data sources for data warehousing also appeared and are to this day an active research topic

[15, 46].

Research has currently been exploring the idea of data lakes and how to process such large quantities of distributed,

unstructured, and heterogeneous data [5, 34]. The research landscape is also currently shifting towards graph-formatted

data [7, 9, 11, 12] and data acquired from the Web [2, 24, 30].

It is clear that research of data integration is very unlikely to abate, especially as new kinds of potential data sources

continue to be created [29, 30, 40, 47–49]. The research is yet to produce a concrete freely usable and open-ended data

source integration system. In the words of Golshan et al. [2017]:

"...it is time for data integration operators to break free of end-to-end data integration systems and be available in the

open source to speed up adoption and progress."

"The first challenge [. . . ] is that progress of data integration and its application in practice are hindered by the fact that

there are very few quality tools with which practitioners and researchers can freely experiment."

Looking at the research’s history in its entirety, it can be assessed that at a certain point researchers had taken a

well-meaning detour to incorporate more novel systems into the field, forsaking the essentials of tooling that Golshan

et al. [2017] mentioned. It can be observed that the last large enterprise-wide tools for data source integration were

created following the MW architecture [10, 37], and that this is a good restarting point.

Of course, the scientific landscape has greatly changed since the 1990s. Today there is also a shift of discussion about

the way in which views are created, or how data sources are represented. With reintroducing the MW architecture

great care is taken to conform it to modern and future requirements, making it the conduit for future scientific work

regarding data.

This paper is focused on the MW architecture for data source integration systems and some of its deficiencies.

These deficiencies will be presented through the translation of different types of schemas in the system and how the

allocation of these schemas affects the responsibilities of certain types of system components. This will show that

some components have additional responsibilities, intruding on a flexible and scalable architectural design and making

the system difficult to maintain and administrate. This paper then offers a solution to this quandary and presents

the need for an additional component in the MW architecture, which will allow for a flexible and scalable system

componentization and easier real-world use. Consequently, this paper introduces the mask component as this additional

component to the existing component types. This addition prompts us to introduce an extended architectural pattern

based on the MW architecture – the mask-mediator-wrapper (MMW) architecture.

2 THE MEDIATOR-WRAPPER ARCHITECTURE

The MW architecture was first envisioned as an information system architecture [45], allowing a modular architecture

for subtasking when numerous data sources are imposed, in opposition to monolithic architectures. This was specifically

intended for information and knowledge management systems for informed decision making.

Expanding on the idea of what is achievable using the MW architecture, Papakonstantinou et al. [1995] observed

its usage for exchange of data across heterogeneous information sources. Roth and Schwarz [1997] also observed

the mediator-wrapper architecture to uniformly access legacy stores through the GARLIC system [37]. Similarly, the

Submitted version

Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

3

mediator-wrapper architecture was used as a basis for the TSIMMIS project [10]. Garcia-Molina et al. [2008] put the

mediator-wrapper architecture firmly into the context of data source integration systems.

The MW architecture in the most general sense is an architectural pattern, consisting of mediator and wrapper

components, used to query and acquire data from multiple data sources.

The wrapper component is directly connected to a data source and acts as a standardized interface to that data source.

The wrapper wraps (or encapsulates) the data source for further use throughout the rest of the system, effectively

making it the only component in direct contact with the data source. To ensure such functionalities, the wrapper must

be able to translate queries, data and metadata coming to and from the data source, as well as the layers above.

The mediator component is architecturally situated above the wrappers. The mediator’s task is to connect multiple

wrappers and integrate their data and metadata. Because data, metadata and queries are logically intertwined, the

mediator also must have the ability decompose and allocate queries to its connected wrappers.

Certain aspects of the MW architecture can be clarified by following the top-to-bottom flow of data as shown in

Fig. 1. The mediator receives a query which is then propagated accordingly to its connected wrappers. Not all wrappers

need be included in a query, as all the data required by the query might not be in all the data sources. The queried

wrappers then translate the queries according to their data source’s schema and querying language. The returned result

is then translated back into the system standardized result format and propagated to the mediator and above.

Fig. 1. Relationship of mediator and wrapper components [16]

This pattern of interaction is the basis for the complete MW architecture. A more global view is shown in Fig. 2.

The data sources to be integrated are at the lowest layer. Each data source is covered by a single wrapper via a direct

connection. As an example, a system where each wrapper operates over a single data source is displayed (Fig. 2),

although Özsu and Valduriez [2011] display a possibility of a wrapper operating over multiple data sources. It can be

Submitted version

QueryQueryResultQueryMediatorResultQueryWrapperResultQueryWrapperResultDatasourceResultDatasource4

Dončević, et al.

observed that the “one wrapper – one data source” setting gives more agility for appending new data sources to the

integration system, as it allocates the responsibility of an overseeing data sources to each wrapper separately and thus

balances the workload. It is also interesting to comment that this component setting is better suited for systems being

built bottom-up [6, 50], where data sources are expected to be appended and the global data overview to change.

The first layer of mediators is located directly above the wrapper layer. Fig. 2 displays their relationship in a form

where each mediator in this layer can be connected to multiple wrappers and multiple wrappers can be connected to a

single mediator. This is in line with the MW architecture displayed in Özsu and Valduriez [2011]. Papakonstantinou

et al. [1995] and Jurczyk et al. [2012] displayed an architecture in which each mediator of the first mediator layer is

connected to just one wrapper and vice-versa; showing that this is also a feasible solution in cases where mediators are

only needed for translation. The first mediator layer can be used to mediate between wrappers over paradigmatically

similar data sources or data sources that have an overlapping or connected domain.

The second and upper layers of mediators can be used to raise the level of abstraction. The mediators of the upper

layers are used to mediate between mediators of the lower layers, thus possibly encompassing multiple different data

sources. Such a layering strategy is used by Moura et al. [2005] in a form of special and central mediators to organize

and distribute processing load, which can also be a beneficial effect if components are run on different machines. On the

other hand, Chawathe et al. [1994] uses layering to enable localized logical management of data sources. This layering

strategy is also proposed by Özsu and Valduriez [2011].

Fig. 2. MW architecture with layered mediators [50]

There are also proposed and implemented systems with one monolithic mediator [8, 17, 20, 38, 39, 42]. This can be

found to be an ample, quick, and expedient solution if the number of connected data sources is not large or expected

to rise. If the number of connected data sources rises, then the processing load on that single mediator is increased

and this can easily lead to increased latency when querying any of the connected data sources through the integration

system. These types of systems can be covariantly classified as multidatabase integration systems [13], taking note that

the data source component translation is distributed (assigned to the wrappers). It should also be noted that in these

cases the mediator component is not really a component, but rather a software module.

Submitted version

WrapperMediatorWrapperDSDSWrapperDSWrapperDSMediatorMediatorMediatorMediatorMediatorMediator layer 2Mediator layer 1Wrapper layerData sourcesMask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

5

Recently, Sethi et al. [2019] have also focused on creating and maintaining a concern-oriented architecture system.

Their workers each have a Data Source API in similarity with wrappers. The mediator’s functionalities are assigned to

a single coordinator acting as the query entry-point and planner, and another worker to join query results (akin to a

reducer node in MapReduce).

2.1 On the roles of mediator-wrapper components

Considering the previously mentioned roles and interactions of wrappers and mediators in the MW architecture, it

can be determined what kind of properties these components should have, or to which rules they should adhere. In a

general sense any system component should satisfy the following conditions [32]:

• It can be used by other software elements, its “clients”.
• It possesses an official usage description, which is sufficient for a client author to use it.
• It is not tied to any fixed set of clients.

This set of conditions can be expanded to determine what conditions should a wrapper or mediator specifically meet.

For wrappers in a data source integration system, by following the example of Roth et al. [1996] and Roth and Schwarz

[1997] (in their case the GARLIC system), the following rules (goals) are set:

RW1 The start-up cost to write a specific wrapper should be small. The wrapper itself can be constructed quickly with

little need for prior knowledge of the data source integration system internal structure. There is a basic service

upon which a specific wrapper is built upon.

RW2 Wrappers should be able to evolve. Incremental upgrades to the wrapper should be possible.

RW3 Wrappers should be modular and independent. Wrappers for new data sources can be integrated into the existing

data source integration system without disturbing user applications, and other wrappers or components.

RW4 Wrappers should be participants in query planning. The wrapper may use whatever knowledge it has about a

repository’s query and specialized search facilities to dynamically determine how much of a query the repository

is capable of handling.

For mediators in a data source integration system, following the ideas of Wiederhold [1992], the following rules are

set:

RMe1 Structuring mediators into hierarchies should not lead to problems.

RMe2 Mediators should drive transformations. Mediators are there to accommodate the need for data and metadata

restructuring. Queries are also affected by this restructuring.

2.2 On schema hierarchies in the mediator-wrapper architecture

One of the advantages of using a MW architecture is the ability to modularly translate schemas by using the architecture’s

components themselves. To better understand these specifics, a generic example of a schema type hierarchy is displayed

in Fig. 3, which shows all the possible schema types and their possible relationships. This is in multiple forms explained

by Özsu and Valduriez [2011].

Starting bottom-up, the first type of schema is a local internal schema (LIS). The LIS is the schema found in the

connected data source itself, defined in the data source’s native form. For the data source integration system to be

able to work on the connected data source it must translate the LIS to a more generic and adaptable form that is used

system-wide – this is the local conceptual schema (LCS). The LCS can then be translated into a local exported schema

(LES). The LES is for all intents and purposes a partial or transformed schematic view of the LCS. As the data source

Submitted version

6

Dončević, et al.

Fig. 3. A schema hierarchy [50]

integration system does not use the LES for its internal functioning, the LES can be described in an entirely different

form and presented to the user. The global conceptual schema (GCS) is created by integrating the local conceptual

schemas. In turn, the GCS can also be exported to the user in multiple forms, just like the LES. Such an exported schema

is called a global exported schema (GES).

In a multidatabase integration system these schemas are all found in the same integration component in the form of

metadata and are generated by modules. On the other hand, in a MW architecture data source integration system these

schemas are worked on gradually. This is done through the system’s wrapper and mediator layers; each layer creating a

more encompassing global schema or creating new forms of exported schemas.

As an example, a certain system-wide schema hierarchy is presented in Fig. 4; with the schemas’ relationships in

accordance with the former explanation. The arrows on top of the schemas in Fig. 4 demonstrate which of them can be

accessed by a user.

To set a concrete example this paper displays how schemas should be assigned to MW components. Setting this

example for the continuation of this paper, the schemas from the exemplified hierarchy (Fig. 4) can now be assigned to

MW architecture components. The first possible assignment of schemas is to a system where there is a single mediator

layer, as displayed in Fig. 5. The LISs are positioned in the connected data sources. The wrappers then form their

individual LCSs based on their connected data source’s LIS. The wrappers’ LCSs are then used by the mediators to create

their GCSs. In this example an aforementioned case of a mediator connected to a single wrapper is also displayed. This

mediator generates a LES, thus this mediator is only used for translation. The other mediators, along with their GCSs,

generate GESs. A mediator can be used to create GESs to remove the need for another architectural layer of mediators

above. Of course, this might decrease system latency, but will increase the complexity of mediator components as they

now must manage multiple user role access.

Another example of a schemas’ assignment is displayed in Fig. 6. In this example there is another mediator layer on

top of the architectural hierarchy. These mediators are used exclusively for exporting schemas; similar to the translating

mediator. In this alternative each mediator exports just one form of GES, thus reducing their task-base and reducing the

Submitted version

GES1GES2GES3GCSLES11LES12LES13LESn1LESn1LESn3LCS1LCSnLIS1LISn......Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

7

Fig. 4. An example of a system-wide schema hierarchy

Fig. 5. An exemplified assignment of schemas to a MW system with a single mediator layer

required complexity for multiple user role management. In other words, each mediator could have just one form of a

data-accessing user.

Submitted version

LIS1LIS2LIS3LIS4LCS1LCS2LCS3LCS4GCS12GCS123GCS234LES41GES121GES122GES2341GES2342DS1DS2DS3DS4MediatorWrapperWrapperWrapperWrapperMediatorMediatorMediatorLIS1LIS2LIS3LIS4LCS1LCS2LCS3LCS4GCS12GCS123GCS234LES41GES121GES122GES2341GES23428

Dončević, et al.

Fig. 6. An exemplified assignment of schemas to a MW system with an exporting mediator layer

3 PROBLEMS WITH THE MEDIATOR-WRAPPER ARCHITECTURE

So far, mentioning the way in which users connect and use these systems has been omitted. Multiple authors have opted

for connecting users to the system via specialized applications which are system-specific [8, 33, 42]. Such applications

connect directly to the highest mediator layer (or the integration layer in case of an alternative architecture).

This puts additional responsibilities on the mediators in the higher layers. These mediators not only have to mediate

schemas from lower layers, but also manage their GESs, as shown in the example of Fig. 5. Opposed to this, the exporting

mediators shown in Fig. 6 seem like a better solution due to the functional responsibility being shared among multiple

mediator components. This also has its issues. RMe1 prohibits the mediator from exporting data in a format that is not

internally used by the system itself. Meaning that data translation is going to have to be done in a user application.

This breaches the system’s separation of concerns, leading to client applications having to do the translations. It seems

that this responsibility cannot be shared among components of the mediator type. Therefore, we add a third rule for

mediators:

RMe3 Mediators should be used to mediate, not to represent.

This problem is further exacerbated when one takes notice of the user applications usually implemented alongside

these systems. Although user applications generally display just one format of data, it is interesting to notice the

variety of data formats that have been used as presentational in different systems – from JSON collections [3, 44], XML

documents [27], to tabular data [23, 26]. The way of access can also be varying – a JDBC API [26], web applications

built onto the system [44] and even a web API [3].

Submitted version

DS1DS2DS3DS4MediatorWrapperWrapperWrapperWrapperMediatorMediatorMediatorLIS1LIS2LIS3LIS4LCS1LCS2LCS3LCS4GCS12GCS123GCS234LES41MediatorMediatorMediatorMediatorGES121GES122GES2341GES2342Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

9

This is also the case with state-of-the-art databases and frameworks designed with specific representations of data

sources in mind. Some authors still show a preference for an SQL interface [1, 40, 41, 49], while others prefer a key-value

[29, 47, 48], graph [9, 11, 12], semantic web [2, 24], an XML [28], flattened data [25], or a plain-text interface [18]. Pang

et al. [2021] have also shown a system with three types of data representations: an object storage (REST API), file

storage, and NoSQL tablestore service. Benedikt et al., Qin et al. [2021, 2020] have also shown that data representation

(views) is becoming a key factor in data handling.

With the increase of data format variety, it is becoming more apparent that a data source integration system, as a

singular data source, will itself have to support data representation in different formats. It is important to note that data,

schemas, and queries face this same issue equally.

A more general point is that the MW architecture in its current state diverges from the idea of a clean system

architecture. The clean architecture principles of architectural layering, separation of concerns, managing dependencies,

control flow and testability are a solution to achieve a flexible and largely scalable system [21, 31]. Such a system is an

expected requirement for gathering and managing large amounts of data from multiple sources.

4 EXTENDING THE MEDIATOR-WRAPPER ARCHITECTURE

It is evident that currently in the MW architectural pattern the responsibility of representing data, schemas, and queries

cannot be assigned to any of the existing component types without assigning too much responsibility onto them. For

this reason, the system designer is forced to decide whether to assign this responsibility to the highest mediator layer

or a user application.

Due to the nature of the problem being the assignment of a system functionality to a component type, and all existing

component types being finely utilized via their given rules, it has become obvious that there is a componential gap in

the upper layer of the MW architecture. In other words, due to RMe3 there is a task that no component type is adequate

to additionally handle. Hence, there is a requirement for another type of system component that could take on the

responsibility of representing system data.

Therefore, in this article we propose a new theoretical component, which we name a mask. A mask masks the system

at a certain point in the schema hierarchy into a representational form that can be easily handled by users, effectively

taking on the responsibility of representing the system. The mask should be placed at the top of the architectural

hierarchy; positioned between the users and highest mediator layer. Placing the masks on top of the architectural

hierarchy effectively creates a mask layer. Consequently, this extended variant of the MW architecture is called a MMW

architecture (Fig. 7).

Using the mask, the system’s representational logic is decoupled from the system’s mediation logic and the user’s

application logic. Furthermore, by adding the mask as a system component type the system has a finer separation of

responsibility and gains benefits that help expand and simplify its usability. If a mask supporting a form of standardized

technological access to data is implemented, then access to the system becomes available to a wide variety of applications

implemented over that standard of access.

Observing the mask with an implementation example, one could implement a mask in the form of a web repre-

sentational state transfer (REST) service with requests over uniform resource locators (URL) returning resources in

JavaScript Object Notation (JSON), akin to the system access shown in [3]. In this way any application built to send

requests to a REST service and receive its responses can now be used as a client application.

Another interesting way to look at a mask component is to imagine it as an inversed wrapper Fig. 8. While the

wrappers concern themselves with adapting the source data from the outside world to accommodate the data source

Submitted version

10

Dončević, et al.

Fig. 7. The MMW architecture with layered mediators

integration system’s standard, the masks concern themselves with adapting the standardized data to accommodate the

outside world. Also, wrappers import data from multiple sources, while masks export data to multiple destinations.

Hence, the data source integration system can now be seen as a single logical point of collecting, transforming and

providing data in various formats.

Fig. 8. Stylistic view of the MMW architecture

As was the case with wrappers and mediators, the rules for masks are set as:

Submitted version

WrapperMediatorWrapperDSDSWrapperDSWrapperDSMediatorMediatorMediatorMediatorMediatorMaskMaskMaskMaskMaskMask layerMediator layer 2Mediator layer 1Wrapper layerData sourcesMediatorsWrappersMasksSource dataPresentational dataMask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

11

RMa1 A mask should be positioned at the top of the architecture.

RMa2 A mask only connects to a single mediator.

RMa3 A mask is used for representational purposes – representing a schema, querying data, representing result data.

RMa1 follows from the consensus that the presentation layer in system architectures is positioned at the top (furthest

on the user-side). The mask, its use being representation, is the system’s presentation layer.

RMa2 follows from the reversal of its statement. If the mask could connect to multiple mediators, then it would

need to also apply mediation – breaking the separation of responsibilities among the components. Hence, a mask is

allowed to connect to just one mediator, and all the mediation is left to the mediators.

RMa3 states a set of basic functional requirements that are expected of most data access systems. This rule articulates

that the mask component doesn’t in any way diminish the system’s functionality.

4.1 The mask’s effect on the system schema hierarchy

To show that the addition of masks affects only the mediators in the higher layers and decreases these mediators’

responsibilities, in Fig. 9 the assignment of schemas from the system-wide schema hierarchy from Fig. 4 is shown.

The wrappers themselves and their schemas have remained unchanged, but there is a significant difference above

the first mediator layer. It is important to note that the placement of prior existing components has not been changed –

all the mediators still connect to the same wrappers and the mediators all operate over the same GCSs. Analogous to

the examples shown in Fig. 5 and Fig. 6, the mediator components of the (now only existing) mediator layer operate

over their respective GCSs. The mask components have been assigned all the GESs.

There is a noteworthy schema rename in the example of Fig. 9, for what was originally GCS123. As the GCS123 itself
was an exported schema in prior examples, in this example the schema might be in a fundamentally different format.

Hence, the schema operated over in the mask cannot be named the same as the schema in the mediator. To mark this
change, what was once GCS123 used for exporting is now GES123 – a fully-fledged exported schema.

A similar effect can be seen in the case of the mediator that in Fig. 5 and Fig. 6 operated over the LES41. As this
mediator’s schema is not directly exported, it has been renamed as GCS41, although it currently only incorporates
LCS4. The mask component above this mediator has taken the responsibility of representation (exporting) and has
consequently been assigned LES41.

There is also an interesting case in Fig. 9 concerning the translation of schema LCS4 to the upper layers (via LCS4,
GCS41, LES41) and the components used for this task. The previously exporting mediator of LES4 from Fig. 5 and
Fig. 6 has been preserved. This mediator’s schema has also been renamed to GCS41, as stated earlier. For the moment
ignoring the RMa2, it can be questioned whether this purely translational mediator is even required. Rightly so, if it is

additionally considered that the system probably uses standardized interfaces for inter-component communication. It
could be concluded that the mask with LES41 could be connected directly to the wrapper with LCS4.

But this is not the case, as the mediator with GCS4 (formerly LES4) must be preserved. The reason for this statement
is two-fold from the angle of system design. Firstly, the mediator is not only used for translation, but also enables

transformations within the schema itself (as is stated by RMe2). Connecting the mask directly to the wrapper, although
feasible, would disable the system to apply further transformations on schema LCS4. Secondly, the benefit of using a
MW architecture, and by extension our own, is the ability to append data sources after the system has been set up.

Connecting the mask directly to the wrapper leaves the system without a mediator to mediate between the wrapper

Submitted version

12

Dončević, et al.

Fig. 9. An exemplified assignment of schemas to a MMW system

with LCS4 and any additional to-be-connected wrapper. Because of this the system would lose the beneficial property
of being (completely) appendable.

This is an example of how the RMa2 preserves not only the component hierarchy of the architecture, but also the

properties of the system itself.

4.2 On the implementation of a mask

The general practice in this paper up to this point was to analyze the mask as a generic black box component and

explain how it would work in synthesis with other system components. To expand the idea of the mask even further

it can no longer be observed just as a black box. The possible inner workings of a mask give the ability to distill this

architectural component even further in terms of design and development. As with most software systems, the mask, a

miniature system itself, can be internally elaborated by following some functional requirements.

Using the mask’s properties that have been introduced via its defined rules, relations to other components, and effect

on the architectural layout, we introduce some basic functional requirements:

F1 The mask must interface with the system via mediators. The mask connects to just one mediator, but it should in

general be able to connect to and communicate with any system mediator interchangeably. A connection with a

wrapper is feasible but, it is inadvisable and thus not of primary concern.

F2 The mask must provide a user access interface. The user access interface is the point of user system access. This

interface can take any implementational form, provided that the chosen form has presentational abilities for data

storage concerns. This interface is interchangeable and does not have effect on the general way in which data source

component translations take place.

Submitted version

DS1DS2DS3DS4MediatorWrapperWrapperWrapperWrapperMediatorMediatorMediatorLIS1LIS2LIS3LIS4LCS1LCS2LCS3LCS4GCS12GCS123GCS234GCS(LES)41MaskMaskMaskMaskGES121GES122GES2341GES2342MaskLES41MaskGES(GCS)123Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

13

F3 The mask must translate schemas from the system format to the user access (masked) format. The mask ascertains

the system schema provided by its connected mediator and adapts the schema to a defined mask format.

F4 The mask must translate queries from the user access (masked) format to the system format. The queries are given

by the user through the user access interface in a masked format and are translated to the system format. To

determine mask-to-system element mappings, the query translation can use the results of schema translations.

F5 The mask must translate results from the system format to the user access (masked) format. The results received

through the system must be adapted to the defined mask format. To determine certain metadata aspects (ex. the

naming of attributes) of data results, can use the results of schema translations.

The requirement F1 follows from RMa1, F2 from RMa2, and the requirements F3, F4 and F5 from RMa3.

Following these functional requirements, a conceptual depiction of the mask’s inner components is devised. This is

displayed in Fig. 10 as a conceptual model of functional components. These components present a generalized idea

of what kind of functionalities should a mask have and what should their relationships be in terms of data exchange

and dependency. These components do not present real-world components, but rather a possible grouping of some

real-world components providing a functionality.

This sketch allows the mask’s functionalities to be put into context. The schema, query, and result translators are

recognized as components with the task of translating data source components. The central role in translation is

given to the schema translator as queries and query results are translated by using schemas generated by the schema

translator. The system access interface is used to connect to the system via a mediator in the layer below. The outer

access interface is a generic component, able to accommodate an adequate form of an access interface.

A noticeable trademark of this model is that there is a focus on the flow of data and its conversion by the components.

A masked query is translated and sent (down) into the system. Reciprocally, the result of such a query is translated into

a masked format to be sent (up) to the user. Similar is the case of schema translation, the system specified schema is

translated into a masked schema for presentation to the user.

Such data transformations can only be achieved through processes, so in a general sense it is more sensical to discuss

the mask in terms of processes and the data that flows between them. To achieve a more detailed elaboration of the

mask, building upon the model from Fig. 10, a data flow diagram is constructed as displayed in in Fig. 11.

On the right-hand side of Fig. 11, the schema translator of Fig. 10 is decomposed as two processes: schema loading

and schema translation. The schema loading process is concerned with the acquisition of a system schema from a

connected mediator. This schema is also stored for other usage, besides schema translation, but it should be reacquired

frequently to maintain an up-to-date schema. For this reason, schema loading is considered a separate and independent

process. The schema translation process uses the currently acquired system schema and schema mapping rules from a

separate storage to create a masked schema. This masked schema is presented to the user.

The querying process in Fig. 11 is a complex process that concerns itself with querying over a mediator. It is closely

tied with processes of query translation and result translation. These processes are effectively subprocesses of querying

but have been extracted due to their importance and correlation with components in Fig. 10.

The query translation process translates a masked query into a system formatted query. It requires data about the

current system schema and schema mapping rules to determine the way in which they are reflected onto the current

query. This must be considered as the schema translation might change resources’ names or change their schematic, so

it becomes important to reverse those translations when constructing a system query. The query translation process

Submitted version

14

Dončević, et al.

Fig. 10. A conceptual model of the mask’s functional components

also requires query mapping rules. As a general example, and for the moment setting a simplified generic model for a

query – these rules might explain how a projection or selection in a query are to be translated.

The result translation process also requires data about the current system schema and schema mapping rules, as it is

also concerned with translating a small view-like portion of the schema with the addition of holding result data that

can also go through some masking transformations. Just like in other translational cases, result data translation also

requires some mapping rules for data results.

There is also a very interesting feature of the diagram in Fig. 11 regarding all the mapping (rules) data storages. The

result mapping, schema mapping, and result mapping data storages do not have any data inflows. These mappings are,

in the context of this diagram, then clearly provided by some other undefined source. In fact, these mappings can only

be provided by the developers of a certain mask component. These mappings are the exact point at which the system

can no longer be designed as generic or abstract, and some concrete implementation or empirical data describing the

masking of the system is required.

Submitted version

MASK COMPONENTMasked queryOuter access interfaceSystem specified queryUsesQuery translatorMasked schemaSchema translatorMasked resultUsesResult translatorSystem specified schemaSystem specified resultSystem access interfaceUsersMEDIATOR LAYERMediatorMediatorMediatorMask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

15

Fig. 11. Dataflow diagram following the mask’s functionalities

Considering the mentioned findings, a conceptual component design for a mask is proposed and shown in the

diagram of Fig. 12. The goal is to also think of the mask’s component design without reducing generality to avoid

prescribing any concrete programming paradigms, languages, or specific design patterns.

Following the process inference of the data flow diagram of Fig. 11, in Fig. 12 the schema manager and schema

translator (interface) are recognized as components – analogous to the schema loading and schema translation processes,

respectively. The schema manager observes the system schema and updates the stored system schema appropriately.

The inference of a general querying process in the data flow diagram leads to the recognition of the query manager

component. This component manages the underlying translations and query execution sequencing. In general, its

purpose is to produce a masked result for a masked query. This is achieved through the processes of query and data

result translation, which themselves in turn lead to the recognition of the query translator (interface) and data result

translator (interface) components.

Submitted version

Schema mappingSchematranslationMasked resultResulttranslationSchema mappingSchema mappingSchema mappingMasked resultQueryResultMasked queryQueryingSchemaResultMediatorMasked queryUsersSchemaSchema requestSchemaloadingSchemaSchemaSchemaSystem schemaResult mappingResult mappingQuery mappingQuery mappingMasked schemaQueryQuerytranslation16

Dončević, et al.

Fig. 12. Conceptual component design of the mask component

Regarding the mask’s communication abilities with the rest of the system – the mask sends system format queries

and results, just like mediators and wrappers. For this reason, the mask can use a standardized communication node

(module) used in all other component types. Due to the communication restrictions of the mask (allowing for a single

mediator connection), an extension of a basic communication node should also be implemented. This also allows the

addition of new message types if such a requirement should arise later.

Submitted version

Mask moduleSystem resultCommunication nodeSystem schemaMask communicationnode extensionMetadatastoreApplication interfaceSystem schemaSchema managerSchema mappingMasked schemaSchema translatorinterfaceSchema translatorimplementationMasked queryMasked queryMasked resultSystem querySystem resultQuery managerSystem queryQuery translatorinterfaceMasked resultResult translatorinterfaceQuery translatorimplementationResult translatorimplementationMediatorMask applicationMask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

17

To store all the data inferred for storage in Fig. 11, a metadata store should also be introduced to the component. Such

a store would be used by all components that require at least some schematic information or technical information. In

Fig. 12 this store is displayed, but the connections to other components are omitted for the sake of clarity.

On the other hand, the mappings (marked as data storages in Fig. 11) are not stored in the metadata database. They are

presented by the component implementations (marked gray) in Fig. 12. For the mask to remain as generic as possible, such

mapping rules are explicitly described by the schema, query, and result translator implementations. The aforementioned

interfaces are used to keep a level of abstraction towards the other inner components. The implementations are case

specific and created by the mask’s developers according to their respective interfaces. This allows the development of a

mask kind to be done without the need for extensive coding, as only the missing implementation pieces need to be

filled in. This, by consequence, not only simplifies the development process, but also decreases the time required to

develop a certain kind mask component.

It is important to note that the term “interface” is used in its broadest form here; not excluding the development

of the mask component in a non-object-oriented paradigm language (non OOP). Along with these interfaces being

implemented as standard OOP interfaces, they can also be implemented as high-order functions in a functional paradigm

or as separate implementations of function prototypes defined in library headers (to be linked before compilation) in

a structural-procedural paradigm. This is one of the beneficial results of generic and abstract reasoning about mask

components.

The inner components that have been elaborated up to this point are part of a mask module, or rather a library.

This is best understood from the point of another component marked gray in Fig. 12 – the mask application. The mask

application is the execution entry point of the mask component. In the continuation of previous possible use-case

examples, this component could be a web API or a TCP server listening for JDBC. Whichever the exemplified case, it

would use the mask module as a library to connect to the integration system. The interfacing of the mask application

and the module is achieved through the mask application interface, that provides a universal interface for data storage.

In essence the mask application interface provides:

• the acquisition of a mask schema
• querying via a masked query
• receiving masked results

A well-designed mask module allows developers to treat it as a simple native data provider without the need for

additional transformations. Of course, the achievement of such a property is also dependent on the developer’s ability

to provide schema, query, result translator implementations fitting well with the implemented mask application.

If such design generalizations were not considered, the development of each kind of mask component would create a

lot of excess repeated work and increase the overhead workload as all aspects of a mask would need to be reimplemented

and retested. Such development would also have an impact on the management of multiple mask kind codebases, as

none would conform to any design standard.

Keeping in form with the proposed design, the development of a mask type component is narrowed down to the

implementation of just four components:

• schema translator implementation
• query translator implementation
• result translator implementation
• mask application

Submitted version

18

Dončević, et al.

This obviously reduces the workload and time required to implement a mask component, removing the need for

reimplementation of core components. The development along the proposed design allows logical layering of the

mask component in the segment of the mask application, as the mask module can be treated as a provider or service.

Such standardization allows the mask components to be potentially built, tested, and maintained by a community of

developers in a form of an open-source software initiative.

4.3 Quantitative analysis on scenarios

To prove that the MMW architecture simplifies a MW-based data source integration system’s maintenance and change

management, a leveled quantitative analysis to compare the MMW and MW alternatives is needed. The following

analysis is based on an evolution-cost quantitative analysis for measuring software flexibility described by Eden and

Mens [2006].

Eden and Mens [2006] proposed that a software’s flexibility can be measured and compared to other designs by

approximating the cost of implementing anticipated changes – shifts. The cost of shifts is defined as the quantity of

software units that need to be changed, added, or removed. These software units are called modules in a general sense

but are exemplified with classes and methods in the paper.

To adjust this analysis for the level of architecture design in this paper, the modules are viewed as architectural

components. The analysis compares an isomorphic example (shown in Fig. 13) of a MW architecture with one mediator

layer (1LMW), a MW architecture with two mediator layers (2LMW), and a MMW architecture. In the cases of 1LMW

and 2LMW, mediators are considered to have functionalities of both mediation and representation.

Submitted version

Fig. 13. Architecture used in the analysis

W1W3W4W2Me'1/Me1Me'2/Me2Me'3/Me3Ma1/Me4Ma1/Me5Ma3/Me6Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

19

The analysis is done over four scenarios: adding a new representation type, adding a new representation, adding a

new mediator, and adding a new wrapper to a mediation. The symbolic nomenclature for this analysis is defined as

follows:

For a set of components 𝑆𝑐𝑜𝑚𝑝 of possible types 𝑆𝑐𝑜𝑚𝑝𝑡 𝑦𝑝𝑒𝑠 = {𝑀𝑎, 𝑀𝑒, 𝑀𝑒 ′,𝑊 } representing a mask, a
mediator with representational functionality, a mediator without representational functionality, and a
wrapper respectively, and a set of possible actions over those components 𝑆𝑎𝑐𝑡 = {𝑖𝑚𝑝𝑙, 𝑑𝑒𝑝𝑙 } representing
implementation and deployment respectively, 𝐶𝑌
𝑋 us the cost of performing an action 𝑌 ∈ 𝑆𝑎𝑐𝑡 over
component 𝑋 ∈ 𝑆𝑐𝑜𝑚𝑝 , with the addition of 𝐶𝑠𝑒𝑡
𝐶𝑜𝑛𝑛 signifying the cost of setting up a connection between
a pair of components {(𝑐1, 𝑐2) | 𝑐1, 𝑐2 ∈ 𝑆𝑐𝑜𝑚𝑝 }

Since a mediator with representational functionality is more complicated to implement than a mediator without

representational functionality, the cost of implementing the former is greater than the latter:

𝑀𝑒 > 𝐶𝑖𝑚𝑝𝑙
𝐶𝑖𝑚𝑝𝑙
Due to a greater number of functionalities that need to be supported by the surrounding system to which the

𝑀𝑒′

(1)

component is being deployed, the deployment of a mediator with representational functionality is also more costly

than that of a mediator without representational functionalities. This is because their deployment includes the tasks of

setting up system resource access permissions, component settings, and firewall rules; all of which are either increased

in quantity or complexity in the case of a representational mediator. Therefore, we conclude the following expression:

𝑀𝑒 > 𝐶𝑑𝑒𝑝𝑙
𝐶𝑑𝑒𝑝𝑙
As in the former statement, for the same reasons the deployment of a mask component is considered less costly

𝑀𝑒′

(2)

than a mediator with representational functionalities. In addition, the mediator has a communication node intended for

access to multiple sources. This is considered bloat, as the representational components connect to only one component

in the lower layer. The mask, on the other hand, has a communication node inherently allowing just one connection to

the lower layer (as per RMa2), making the connection configuration simpler. Therefore, we conclude the following

expression:

𝑀𝑒 > 𝐶𝑑𝑒𝑝𝑙
𝐶𝑑𝑒𝑝𝑙

𝑀𝑎

(3)

Scenario 1: Adding a new representation type. In this scenario, a requirement of for a new representation type on
4.3.1
top of combined schemas of wrappers 𝑊2, 𝑊3, and 𝑊4 is added. Since a new type of representation is required, in a
1LMW an entirely new mediator must be implemented. This new mediator also must be deployed and connected to
wrappers 𝑊2, 𝑊3, and 𝑊4. The outcome of the shift is displayed in Fig. 14 with the addition of 𝑀𝑒4 and its connections
to the required wrappers.

Thus, the cost of the shift is:

In a general case, with the number of connected wrappers being 𝑁 , the cost is:

1𝐿𝑀𝑊 = 𝐶𝑖𝑚𝑝𝑙
𝐶1

𝑀𝑒 + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑒 + 3 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

1𝐿𝑀𝑊 = 𝐶𝑖𝑚𝑝𝑙
𝐶1

𝑀𝑒 + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑒 + 𝑁 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

Submitted version

20

Dončević, et al.

Fig. 14. Scenario 1 outcome on a one-layer mediator MW architecture

It can be noticed that this architecture forms redundant connections between wrappers and mediators, adding to the

shift cost.

Again, the case of a 2LMW, a new mediator must be implemented and deployed (𝑀𝑒7). In this case mediator is
stacked on top of a mediator on the lower layer of mediators (𝑀𝑒3). Hence, the mediator 𝑀𝑒3 is reused for combining
wrappers 𝑊2, 𝑊3, and 𝑊4 and only one connection is set up. The outcome of the shift is displayed in Fig. 15.

Submitted version

Fig. 15. Scenario 1 outcome on a two-layer mediator MW architecture

W1W3W4W2Me1Me2Me3Me4W1W3W4W2Me1Me2Me3Me7Me4Me5Me6Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

21

The cost for this shift is:

2𝐿𝑀𝑊 = 𝐶𝑖𝑚𝑝𝑙
𝐶1

𝑀𝑒 + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑒 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛,

which remains true for any general case.

In the case of a MMW architecture. To create a new type of representation, a new mask (𝑀𝑎4) is required to be
implemented and deployed. Only one connection setup is required as the new mask only connects to one mediator in
the mediator layer (𝑀𝑒 ′
3). It is important to note that the mediators in this architecture don’t serve a representational
purpose, so they don’t have representational functionality. The outcome of the shift is displayed in Fig. 16.

Fig. 16. Scenario 1 outcome on a MMW architecture

The shift cost in this and general cases is:

𝑀𝑀𝑊 = 𝐶𝑖𝑚𝑝𝑙
𝐶1

𝑀𝑎 + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑎 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

Scenario 2: Adding a new representation. In this scenario a requirement for a new representation on top of
4.3.2
combined schemas of wrappers 𝑊1 and 𝑊2 is added. The representational component is already implemented, so none
of the cases will have an implementation cost, just the deployment cost and the cost of connection setup.

In a 1LMW the new mediator is deployed and two connections to the two wrappers 𝑊1 and 𝑊2 set up. The shift cost

is:

1𝐿𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶2

𝑀𝑒 + 2 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

Submitted version

W1W3W4W2Me'1Me'2Me'3Ma1Ma1Ma3Ma422

Dončević, et al.

In a general case the shift cost is determined by the number of required redundant connections to wrappers N:

1𝐿𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶2

𝑀𝑒 + 𝑁 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

In a 2LMW a new mediator is deployed and one connection to its underlying mediator (𝑀𝑒2) set up. The shift cost is:

2𝐿𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶2
In a MMW architecture a new mask is deployed and one connection to its underlying mediator (𝑀𝑒 ′

𝑀𝑒 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

2) set up. The

shift cost is:

𝑀𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶2

𝑀𝑎 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

4.3.3

Scenario 3: Adding a new mediator. In this scenario a requirement for a new mediator over wrappers 𝑊2 and 𝑊3

is added. It will be assumed that this type of mediator already exists, so there is no cost of implementation.

In a 1LMW a mediator is deployed and connected to the two wrappers. the shift cost is:

Again, for a general case where 𝑁 is the number of connected wrappers, the shift cost is:

1𝐿𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶3

𝑀𝑒 + 2 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

1𝐿𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶3

𝑀𝑒 + 𝑁 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

In a 2LMW a mediator must be deployed to the lower mediator layer to combine the wrappers and a mediator in the

upper mediator layer to provide the representation. The set-up connections also must be considered, as two connections

are set up towards the wrappers and a single connection between the mediators. The shift cost is:

In a general case, where 𝑁 is the number of connected wrappers, the shift cost is:

2𝐿𝑀𝑊 = 2 × 𝐶𝑑𝑒𝑝𝑙
𝐶3

𝑀𝑒 + 3 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

2𝐿𝑀𝑊 = 2 × 𝐶𝑑𝑒𝑝𝑙
𝐶3

𝑀𝑒 + (𝑁 + 1) × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

In a MMW architecture, together with deploying a mediator, a mask must be provided. The mask type is considered

as already implemented (analogous to the cases of MW architectures), so it has to only be deployed. Two connections

are set up towards the wrappers and a single connection between the mediator and mask. The shift cost is:

In a general case, where 𝑁 is the number of connected wrappers, the shift cost is:

𝑀𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶3

𝑀𝑒′ + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑎 + 3 × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

𝑀𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙
𝐶3

𝑀𝑒′ + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑎 + (𝑁 + 1) × 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

4.3.4

Scenario 4: Adding a new wrapper to an existing mediation. Additionally, to demonstrate that these architectures

are sound (the MMW architecture first and foremost), a scenario of adding a new wrapper can be analyzed. The

appending of wrappers to an existing mediator doesn’t impact the rest of the components, as the wrapper is deployed

and a single connection to the required mediator set up. Thus, the shift cost for all architectures is:

Submitted version

Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

23

Table 1. Shift costs for all scenarios and architectures

Sc.

1

2

3

4

𝑀𝑒 + 𝑁 × 𝐶𝑠𝑒𝑡
𝐶𝑜𝑛𝑛

1LMW
𝑀𝑒 + 𝐶𝑑𝑒𝑝𝑙
𝐶𝑖𝑚𝑝𝑙
𝐶𝑑𝑒𝑝𝑙
𝑀𝑒 + 𝑁 × 𝐶𝑠𝑒𝑡
𝐶𝑑𝑒𝑝𝑙
𝑀𝑒 + 𝑁 × 𝐶𝑠𝑒𝑡
𝐶𝑑𝑒𝑝𝑙
𝑊 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

𝐶𝑜𝑛𝑛

2LMW
𝑀𝑒 + 𝐶𝑑𝑒𝑝𝑙
𝐶𝑜𝑛𝑛 𝐶𝑖𝑚𝑝𝑙
𝐶𝑑𝑒𝑝𝑙
𝑀𝑒 + 𝐶𝑠𝑒𝑡
2 × 𝐶𝑑𝑒𝑝𝑙
𝐶𝑑𝑒𝑝𝑙
𝑊 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

𝑀𝑒 + 𝐶𝑠𝑒𝑡
𝐶𝑜𝑛𝑛

𝐶𝑜𝑛𝑛

𝑀𝑒 + (𝑁 + 1) × 𝐶𝑠𝑒𝑡

MMW
𝑀𝑎 + 𝐶𝑑𝑒𝑝𝑙
𝐶𝑖𝑚𝑝𝑙
𝐶𝑑𝑒𝑝𝑙
𝑀𝑎 + 𝐶𝑠𝑒𝑡
𝑀𝑒′ + 𝐶𝑑𝑒𝑝𝑙
𝐶𝑜𝑛𝑛 𝐶𝑑𝑒𝑝𝑙
𝐶𝑑𝑒𝑝𝑙
𝑊 + 𝐶𝑠𝑒𝑡

𝑀𝑎 + 𝐶𝑠𝑒𝑡
𝐶𝑜𝑛𝑛
𝑀𝑎 + (𝑁 + 1) × 𝐶𝑠𝑒𝑡
𝐶𝑜𝑛𝑛

𝐶𝑜𝑛𝑛

𝐶𝑜𝑛𝑛

1𝐿𝑀𝑊 = 𝐶4
𝐶4

2𝐿𝑀𝑊 𝐶4

𝑀𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙

𝑊 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

4.3.5 Analysis of the shift costs. With the shift costs evaluated, a more concise comparison of architectures can be

made. Table 1 displays all the shift costs for each scenario and architecture.

The first scenario demonstrates that in the MMW architecture the addition of a new type of representation is only

dependent on the implementation and deployment of a mask component. The other two architectures depend on

mediator components. The 1LMW’s shift cost noticeably depends on the number of connected wrappers – to emphasize:

for adding a representation type. The 2LMW and MMW architectures are not at such a disadvantage, their difference

being the type of component added to the system. Since a mask is less costly to implement and deploy than a mediator,

the overall shift cost in scenario 1 is lowest in the MMW case.

The second scenario also shows that the 1LMW shift cost is dependent on the number of wrappers. The cases of

2LMW and MMW are again analogous, but a mask is less costly to deploy than a representational mediator. This makes

the shift cost of the MMW case the lowest again. As it was discussed earlier in the text, using a mediator just for

representation, without using its mediation functionalities, is akin to killing a fly with a cannonball.

The third scenario shows the shift cost overhead the 2LMW and MMW have as opposed to the 1LMW when setting

up mediation. There is an obvious trade-off in these architectures between the shift cost of adding mediation or

representations. To maintain a less costly (and qualitatively simpler) representation addition, the overhead cost of

adding mediation is increased. This overhead can be quantified for 2LMW as:

𝐶𝑜𝑣𝑒𝑟ℎ𝑒𝑎𝑑
2𝐿𝑀𝑊 = 𝐶3

2𝐿𝑀𝑊 − 𝐶3

1𝐿𝑀𝑊 = 𝐶𝑑𝑒𝑝𝑙

𝑀𝑒 + 𝐶𝑆𝑒𝑡

𝐶𝑜𝑛𝑛,

and for the MMW:

𝐶𝑜𝑣𝑒𝑟ℎ𝑒𝑎𝑑
𝑀𝑀𝑊

= 𝐶3

𝑀𝑀𝑊 − 𝐶3

1𝐿𝑀𝑊 = (𝐶𝑑𝑒𝑝𝑙

𝑀𝑒′ − 𝐶𝑑𝑒𝑝𝑙

𝑀𝑒 ) + 𝐶𝑑𝑒𝑝𝑙

𝑀𝑎 + 𝐶𝑠𝑒𝑡

𝐶𝑜𝑛𝑛

Considering that the MMW mask and mediator are less costly to deploy than the 2LMW mediator, the overhead cost

is reduced in favor of the MMW.

The fourth scenario shows that the addition of a new wrapper to the MMW system has no effect on the rest of

the system hierarchy, as it is also expected of the other MW architectures. The MMW finds itself in no detrimental

opposition to the other architectures.

Submitted version

24

Dončević, et al.

4.4 Hypothetical implementational example

As referenced before, Atzeni et al. [2014] presented the SOS (Save Our Systems) as a system for uniform operations over

non-relational stores. The representational format of this system was a web API with URI-like resource identification,

serving result data as JSON objects. They have also defined generic wrappers (in their case as modules) which are

implemented per data store kind. The wrappers in their case also concern themselves with representing the underlying

systems. Although not a data source integration system itself, the SOS system could keep its raison d’être and be

conveniently extendable to the likes of a data source integration system if it were reimagined following the MMW

architecture. Additionally, using different mask kinds, the representational form of these data storages could be expanded

on.

A hypothetical example of such a system use case is presented in Fig. 17, where the revised SOS system provides

uniform access over a single HBase, Redis, and MongoDB database. At the top of the component hierarchy each database

must be converted to the SOS interface for application access, as is presented by Atzeni et al. [2014]. This interface can

be presented via mask components of the SOS mask kind.

Starting from the bottom of the Fig. 17 hierarchy, a wrapper is connected to each data source. Since it is not advisable

to connect masks directly to wrappers and following RMa2 stating that masks should only connect to mediators – a

single mediator is connected to each wrapper. A SOS mask is connected to each of these mediators, thus encompassing

the original SOS system’s functionalities. Also, these settings do not restrict the system to just using a SOS mask.

Additional mask kinds can be connected to these singular mediators to offer an alternative presentational form and

keep in line with the SOS’s use-case of uniform system access. Such an example is given in Fig. 17 with a JDBC mask

representing the Redis database.

The singular mediators are of a translational nature, but also enable the system hierarchy to be expanded. If, by

example shown in Fig. 17, a mediator connecting to each of the singular mediators is provided, then that part of the

system becomes a data source integration system. Consequently, the integrating mediator allows connections coming

from different masks.

Not only does the MMW architecture allow the emulation of a system such as the SOS, but also expands on it. If it

were not for the mask components taking on the responsibility of system representation, all mediators would have to

be adapted (redesigned and reimplemented) to the SOS interface standard to work as both the SOS system and a data

source integration system, which itself does not explicitly require adherence to the SOS interface standard.

5 CONCLUSION

The MW architecture has numerous advantages when it comes to implementing a data source integration system.

Especially if the system is expected to connect a larger number of data sources. It was also demonstrated that, when

certain rules are followed to keep the components well-formed, the maintenance of such systems also becomes easier.

In the case of appending new data sources, they are each assigned a wrapper and the wrappers are connected to

selected mediators. In the case of managing schemas, this management is modularized by the system architecture itself.

Workloads on hardware can also be balanced, as components can be setup on different machines.

Although it has been mentioned that some authors did not use the MW architecture in terms of system components,

most of them recognized these advantages and modeled their inner system modules to work in a similar fashion. This

allowed them to at least use the advantageous modularization of tasks and responsibilities in a data source integration

system.

Submitted version

Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

25

Fig. 17. The SOS system implemented in the MMW architecture

The architectural pattern’s idea has been agreed with up to a point. This point being the representation of data to

users and the responsibilities of upper layer mediators. It has been found that there is a responsibility of representing

data that usually has either been delegated to the upper layer of mediators or specialized user application. To keep this

responsibility inside the system, the idea of a new architectural component has been proposed – the mask. As with

mediators and wrappers, some basic rules for masks have been set to assure that they are well-formed and fit into a

MW architecture.

The mask takes on the responsibility of representing data and creating an interface for users to connect to. It has

also been reasoned that appending masks to a MW architecture technically creates a new architectural layer – the mask

layer.

By using the mask layer, a data source integration system increases its representational versatility and thus, its

usefulness. Now a data source integration system can be viewed as a singular source of data, but through multiple

masked sources. In addition, if masks adhere to a certain representational standard, then the data source integration

system becomes open to different kinds of user applications.

The mask component was internally detailed as much as possible in an abstract and generic form to prevent

any partiality to a specific programming language or paradigm. Reasoning about the mask’s hypothetical functional

requirements has progressed to a simple functional component structure. This basic model was then enriched by

recognizing processes that a mask should support, leading to a more detailed conceptual inner-component design. This

process also allowed thinking about a more concrete placement of the mask component in a real-life implementation,

which was concluded with the proposal that a mask should be implemented as a software module used by the mask

Submitted version

HBaseRedisMongoDBWrapperWrapperWrapperMediatorMediatorMediatorSOS maskSOS maskSOS maskMediatorX maskY maskJDBC mask26

Dončević, et al.

component’s application code. The mask’s software module requires partial implementation, per mask-kind, for it to be

used.

Because of the addition of a new architectural layer, it has been decided to name this a revision of the MW architecture

and name it as a MMW architecture. To show that the MMW architecture has benefits over other MW architectures,

a quantitative analysis over requirement shift costs was done on multiple scenarios. To showcase the possibilities of

a real-world use of the MMW architecture and its benefits, a hypothetical example emulating an existing system for

uniform data store access (SOS) was presented. This example showed the benefits garnered from the redistribution of

responsibility among component types in the MMW architecture, specifically the responsibilities assigned to the mask.

Further work is needed for additional detailing of the mask components and its interactions with other components

(mainly mediators). It would also be interesting to investigate if there is a possibility of further generalization of the

base implementation of a mask to achieve faster and standardized development of mask kinds. There is also a possible

outlook for research on constructing mask generators, akin to wrapper generators implemented in referenced work.

REFERENCES

[1] Firas Abuzaid, Peter Kraft, Sahaana Suri, Edward Gan, Eric Xu, Atul Shenoy, Asvin Ananthanarayan, John Sheu, Erik Meijer, Xi Wu, Jeff Naughton,
Peter Bailis, and Matei Zaharia. 2021. DIFF: a relational interface for large-scale data explanation. The VLDB Journal 30, 1 (Jan. 2021), 45–70.
https://doi.org/10.1007/s00778-020-00633-6

[2] Marcelo Arenas, Georg Gottlob, and Andreas Pieris. 2018. Expressive Languages for Querying the Semantic Web. ACM Transactions on Database

Systems 43, 3 (Nov. 2018), 13:1–13:45. https://doi.org/10.1145/3238304

[3] Paolo Atzeni, Francesca Bugiotti, and Luca Rossi. 2014. Uniform access to NoSQL systems. Information Systems 43 (July 2014), 117–133. https:

//doi.org/10.1016/j.is.2013.05.002

[4] Michael Benedikt, Pierre Bourhis, Louis Jachiet, and Efthymia Tsamoura. 2021. Balancing Expressiveness and Inexpressiveness in View Design.

ACM Transactions on Database Systems 46, 4 (Nov. 2021), 15:1–15:40. https://doi.org/10.1145/3488370

[5] Alex Bogatu, Alvaro A. A. Fernandes, Norman W. Paton, and Nikolaos Konstantinou. 2020. Dataset Discovery in Data Lakes. In 2020 IEEE 36th

International Conference on Data Engineering (ICDE). 709–720. https://doi.org/10.1109/ICDE48307.2020.00067 ISSN: 2375-026X.

[6] Susanne Busse, Ralf-Detlef Kutsche, Ulf Leser, and Herbert Weber. 1999. Federated Information Systems: Concepts, Terminology and Architectures.

Forschungsberichte Des Fachbereichs Informatik (1999), 41.

[7] Riccardo Cappuzzo, Paolo Papotti, and Saravanan Thirumuruganathan. 2020. Creating Embeddings of Heterogeneous Relational Datasets for Data

Integration Tasks. SIGMOD Conference (2020). https://doi.org/10.1145/3318464.3389742

[8] Y. Chang, C. Chang, and H. Cheng. 2011. Applying ontology to geographical scientific data extraction. In 2011 IEEE International Conference on

Systems, Man, and Cybernetics. 3397–3402. https://doi.org/10.1109/ICSMC.2011.6084194 ISSN: 1062-922X.

[9] Damianos Chatziantoniou and Verena Kantere. 2021. DataMingler: A Novel Approach to Data Virtualization. In Proceedings of the 2021 International
Conference on Management of Data. Association for Computing Machinery, New York, NY, USA, 2681–2685. https://doi.org/10.1145/3448016.3452752
[10] Sudarshan S. Chawathe, H. Garcia-Molina, J. Hammer, K. Ireland, Y. Papakonstantinou, J. Ullman, and J. Widom. 1994. The TSIMMIS Project:
Integration of Heterogeneous Information Sources. undefined (1994). /paper/The-TSIMMIS-Project%3A-Integration-of-Heterogeneous-Chawathe-
Garcia-Molina/14348170a14b4e2edca01521184cb2cd60b83200

[11] Joana M. F. da Trindade, Konstantinos Karanasos, Carlo Curino, Samuel Madden, and Julian Shun. 2020. Kaskade: Graph Views for Efficient Graph
Analytics. In 2020 IEEE 36th International Conference on Data Engineering (ICDE). 193–204. https://doi.org/10.1109/ICDE48307.2020.00024 ISSN:
2375-026X.

[12] Ariel Debrouvier, Eliseo Parodi, Matías Perazzo, Valeria Soliani, and Alejandro Vaisman. 2021. A model and query language for temporal graph

databases. The VLDB Journal 30, 5 (Sept. 2021), 825–858. https://doi.org/10.1007/s00778-021-00675-4

[13] J. Doncevic and K. Fertalj. 2020. Database Integration Systems. In 2020 43rd International Convention on Information, Communication and Electronic

Technology (MIPRO). IEEE, Opatija, Croatia, 1617–1622. https://doi.org/10.23919/MIPRO48935.2020.9245245

[14] A.H. Eden and T. Mens. 2006. Measuring software flexibility. IEE Proceedings - Software 153, 3 (2006), 113. https://doi.org/10.1049/ip-sen:20050045
[15] Chiara Forresi, Enrico Gallinucci, Matteo Golfarelli, and Hamdi Ben Hamadou. 2021. A dataspace-based framework for OLAP analyses in a

high-variety multistore. The VLDB Journal 30, 6 (Nov. 2021), 1017–1040. https://doi.org/10.1007/s00778-021-00682-5

[16] Hector Garcia-Molina, Jeffrey Ullman, and Jennifer Widom. 2008. Database Systems: The Complete Book (2nd edition ed.). Pearson, Upper Saddle

River, N.J.

[17] Binny Garg and Karamjit Kaur. 2015. Integration of heterogeneous databases. In 2015 International Conference on Advances in Computer Engineering

and Applications. IEEE, Ghaziabad, India, 1033–1038. https://doi.org/10.1109/ICACEA.2015.7164859

Submitted version

Mask-Mediator-Wrapper: A revised mediator-wrapper architecture for heterogeneous data source integration

27

[18] Orest Gkini, Theofilos Belmpas, Georgia Koutrika, and Yannis Ioannidis. 2021. An In-Depth Benchmarking of Text-to-SQL Systems. In Proceedings
https:

of the 2021 International Conference on Management of Data. Association for Computing Machinery, New York, NY, USA, 632–644.
//doi.org/10.1145/3448016.3452836

[19] Behzad Golshan, Alon Halevy, George Mihaila, and Wang-Chiew Tan. 2017. Data Integration: After the Teenage Years. In Proceedings of the 36th
ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems (PODS ’17). Association for Computing Machinery, New York, NY, USA,
101–106. https://doi.org/10.1145/3034786.3056124

[20] Hongzhi Wang, Jianzhong Li, and Zhenying He. 2003. An effective wrapper architecture to heterogeneous data source. In 17th International

Conference on Advanced Information Networking and Applications, 2003. AINA 2003. 565–568. https://doi.org/10.1109/AINA.2003.1192945

[21] Peter Ivanics. 2017. An Introduction to Clean Software Architecture. (2017). https://pivanics.users.cs.helsinki.fi/portfolio/docs/publications/Peter_

Ivanics-Clean_Software_Architecture.pdf

[22] P. Jurczyk, L. Xiong, and S. Goryczka. 2012. DObjects+: Enabling Privacy-Preserving Data Federation Services. In 2012 IEEE 28th International

Conference on Data Engineering. 1325–1328. https://doi.org/10.1109/ICDE.2012.138 ISSN: 2375-026X.

[23] H. Kozankiewicz, K. Stencel, and K. Subieta. 2004. Integration of heterogeneous resources through updatable views. In 13th IEEE International
Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises. 309–314. https://doi.org/10.1109/ENABL.2004.38 ISSN: 1524-4547.
[24] Maria Krommyda and Verena Kantere. 2020. Visualization Systems for Linked Datasets. In 2020 IEEE 36th International Conference on Data Engineering

(ICDE). 1790–1793. https://doi.org/10.1109/ICDE48307.2020.00171 ISSN: 2375-026X.

[25] Hoang Thanh Lam, Beat Buesser, Hong Min, Tran Ngoc Minh, Martin Wistuba, Udayan Khurana, Gregory Bramble, Theodoros Salonidis, Dakuo
Wang, and Horst Samulowitz. 2021. Automated Data Science for Relational Data. In 2021 IEEE 37th International Conference on Data Engineering
(ICDE). 2689–2692. https://doi.org/10.1109/ICDE51399.2021.00305 ISSN: 2375-026X.

[26] R. Lawrence. 2014. Integration and Virtualization of Relational SQL and NoSQL Systems Including MySQL and MongoDB. In 2014 International

Conference on Computational Science and Computational Intelligence, Vol. 1. 285–290. https://doi.org/10.1109/CSCI.2014.56

[27] R. Li, Z. Lu, W. Xiao, and W. Wu. 2005. XML-based integration data model and schema mapping in multidatabase systems. Journal of Systems

Engineering and Electronics 16, 2 (2005), 437–444.

[28] Yeting Li, Jialun Cao, Haiming Chen, Tingjian Ge, Zhiwu Xu, and Qiancheng Peng. 2020. FlashSchema: Achieving High Quality XML Schemas with
Powerful Inference Algorithms and Large-scale Schema Data. In 2020 IEEE 36th International Conference on Data Engineering (ICDE). 1962–1965.
https://doi.org/10.1109/ICDE48307.2020.00214 ISSN: 2375-026X.

[29] Junkai Liang and Yunpeng Chai. 2021. CruiseDB: An LSM-Tree Key-Value Store with Both Better Tail Throughput and Tail Latency. In 2021 IEEE

37th International Conference on Data Engineering (ICDE). 1032–1043. https://doi.org/10.1109/ICDE51399.2021.00094 ISSN: 2375-026X.

[30] Amr Magdy, Laila Abdelhafeez, Yunfan Kang, Eric Ong, and Mohamed F. Mokbel. 2020. Microblogs data management: a survey. The VLDB Journal

— The International Journal on Very Large Data Bases 29, 1 (Jan. 2020), 177–216. https://doi.org/10.1007/s00778-019-00569-6

[31] Robert Martin. 2017. Clean Architecture: A Craftsman’s Guide to Software Structure and Design (1st edition ed.). Pearson, London, England.
[32] B. Meyer. 2003. The grand challenge of trusted components. In 25th International Conference on Software Engineering, 2003. Proceedings. 660–667.

https://doi.org/10.1109/ICSE.2003.1201252 ISSN: 0270-5257.

[33] S. L. de Moura, F. Coutinho, S. W. M. Siqueira, R. N. Melo, and S. V. Nunes. 2005.

Integrating repositories of learning objects using Web-
services to implement mediators and wrappers. In International Conference on Next Generation Web Services Practices (NWeSP’05). 6 pp.–. https:
//doi.org/10.1109/NWESP.2005.49

[34] Zhu Pang, Qingda Lu, Shuo Chen, Rui Wang, Yikang Xu, and Jiesheng Wu. 2021. ArkDB: A Key-Value Engine for Scalable Cloud Storage Services.
In Proceedings of the 2021 International Conference on Management of Data. Association for Computing Machinery, New York, NY, USA, 2570–2583.
https://doi.org/10.1145/3448016.3457553

[35] Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. 1995. Object exchange across heterogeneous information sources. In Proceedings of the

Eleventh International Conference on Data Engineering. 251–260. https://doi.org/10.1109/ICDE.1995.380386

[36] Xuedi Qin, Yuyu Luo, Nan Tang, and Guoliang Li. 2020. Making data visualization more efficient and effective: a survey. The VLDB Journal 29, 1

(Jan. 2020), 93–117. https://doi.org/10.1007/s00778-019-00588-3

[37] M. Tork Roth, M. Arya, L. Haas, M. Carey, W. Cody, R. Fagin, P. Schwarz, J. Thomas, and E. Wimmers. 1996. The Garlic project. In Proceedings
of the 1996 ACM SIGMOD international conference on Management of data - SIGMOD ’96. ACM Press, Montreal, Quebec, Canada, 557. https:
//doi.org/10.1145/233269.280363

[38] Mary Tork Roth and Peter Schwarz. 1997. Don’t Scrap It, Wrap It! A Wrapper Architecture for Legacy Data Sources. In Proceedings of the 23rd VLDB

Conference. Athens, Greece, 10.

[39] K. Schmatz, K. Berwind, F. Engel, and M. L. Hemmje. 2018. An Interface to Heterogeneous Data Sources Based on the Mediator/Wrapper
Architecture in the Hadoop Ecosystem. In 2018 IEEE International Conference on Bioinformatics and Biomedicine (BIBM). 1838–1845. https:
//doi.org/10.1109/BIBM.2018.8621111

[40] Marc Seidemann, Nikolaus Glombiewski, Michael Körber, and Bernhard Seeger. 2019. ChronicleDB: A High-Performance Event Store. ACM

Transactions on Database Systems 44, 4 (Oct. 2019), 13:1–13:45. https://doi.org/10.1145/3342357

[41] Raghav Sethi, Martin Traverso, Dain Sundstrom, David Phillips, Wenlei Xie, Yutian Sun, Nezih Yegitbasi, Haozhun Jin, Eric Hwang, Nileema
Shingte, and Christopher Berner. 2019. Presto: SQL on Everything. In 2019 IEEE 35th International Conference on Data Engineering (ICDE). 1802–1813.
https://doi.org/10.1109/ICDE.2019.00196 ISSN: 2375-026X.

Submitted version

28

Dončević, et al.

[42] Y. Shao, L. Di, L. Kang, and Y. Bai. 2013. An integrated framework for geospatial data discovering and standardized processing. In 2013 Second
International Conference on Agro-Geoinformatics (Agro-Geoinformatics). 334–337. https://doi.org/10.1109/Argo-Geoinformatics.2013.6621932
[43] Ap Sheth and Ja Larson. 1990. Federated Database-Systems for Managing Distributed, Heterogeneous, and Autonomous Databases. Computing

Surveys 22, 3 (Sept. 1990), 183–236. WOS:A1990GL46000002.

[44] Ágnes Vathy-Fogarassy and Tamás Hugyák. 2017. Uniform data access platform for SQL and NoSQL database systems. Information Systems 69 (Sept.

2017), 93–105. https://doi.org/10.1016/j.is.2017.04.002

[45] G. Wiederhold. 1992. Mediators in the architecture of future information systems. Computer 25, 3 (March 1992), 38–49. https://doi.org/10.1109/2.

121508

[46] Yansong Zhang, Yu Zhang, Shan Wang, and Jiaheng Lu. 2019. Fusion OLAP: Fusing the Pros of MOLAP and ROLAP Together for In-memory OLAP
(Extended Abstract). In 2019 IEEE 35th International Conference on Data Engineering (ICDE). 2125–2126. https://doi.org/10.1109/ICDE.2019.00257
ISSN: 2375-026X.

[47] Xingsheng Zhao, Song Jiang, and Xingbo Wu. 2021. WipDB: A Write-in-place Key-value Store that Mimics Bucket Sort. In 2021 IEEE 37th International

Conference on Data Engineering (ICDE). 1404–1415. https://doi.org/10.1109/ICDE51399.2021.00125 ISSN: 2375-026X.

[48] Jingyu Zhou, Meng Xu, Alexander Shraer, Bala Namasivayam, Alex Miller, Evan Tschannen, Steve Atherton, Andrew J. Beamon, Rusty Sears, John
Leach, Dave Rosenthal, Xin Dong, Will Wilson, Ben Collins, David Scherer, Alec Grieser, Young Liu, Alvin Moore, Bhaskar Muppana, Xiaoge Su, and
Vishesh Yadav. 2021. FoundationDB: A Distributed Unbundled Transactional Key Value Store. In Proceedings of the 2021 International Conference on
Management of Data. Association for Computing Machinery, New York, NY, USA, 2653–2666. https://doi.org/10.1145/3448016.3457559

[49] Esteban Zimányi, Mahmoud Sakr, and Arthur Lesuisse. 2020. MobilityDB: A Mobility Database Based on PostgreSQL and PostGIS. ACM Transactions

on Database Systems 45, 4 (Dec. 2020), 19:1–19:42. https://doi.org/10.1145/3406534

[50] M. Tamer Özsu and Patrick Valduriez. 2011. Principles of distributed database systems (3rd ed ed.). Springer Science+Business Media, New York.

OCLC: ocn706920112.

Submitted version

