1

2
2
0
2

l
u
J

2
1

]
E
S
.
s
c
[

2
v
7
3
7
3
1
.
3
0
2
2
:
v
i
X
r
a

Dependency Solvers à la Carte

DONALD PINCKNEY, Northeastern University, USA
FEDERICO CASSANO, Northeastern University, USA
ARJUN GUHA, Northeastern University, USA
MASSIMILIANO CULPO, np-complete, S.r.l., Italy
TODD GAMBLIN, Lawrence Livermore National Laboratory, 94550

Package managers, such as NPM, are critical components of modern software development, allowing program-
mers to access large ecosystems full of useful packages. Given only a few lines of configuration, a package
manager automates the downloading and installation of perhaps hundreds of (transitive) dependencies on
behalf of the programmer. To achieve this, package managers perform dependency solving to choose which
concrete versions of dependencies to install. However, different solvers select dependency versions in very
different ways, which affects correctness, code size, and other factors of the final bundled software in ways
that are opaque and confusing to programmers. Moreover, the exact behaviors of dependency solvers are
defined by their implementations, rather than by specifications, which inhibits systematic comparisons of
dependency solvers, whether looking at formal properties or empirical evaluations.

We present PacSolve, a unifying formal semantics of dependency solving. PacSolve is parameterized
along several key axes, allowing it to compactly represent the key features and differences between NPM, PIP
and Cargo, and to express a wide variety of alternative semantics for dependency solving. We then formulate
dependency solving as solution graph synthesis, which yields an executable implementation in Rosette. Using
PacSolve we build a drop-in replacement for NPM called MinNPM. MinNPM allows the user to customize
the dependency solving semantics to choose between different objectives and consistency criteria. We show
empirically that MinNPM shrinks the footprint of 21% of the top 1,000 most downloaded NPM packages with
at least one dependency, and that it produces a newer set of dependencies for 14%. We also use MinNPM to
answer key empirical questions about dependency solver design. Notably, we show that NPM’s tree-solving
semantics is only necessary for 1.9% of its packages, and that MinNPM gives higher quality solutions while
taking only 2.6s longer than NPM on average.

1 INTRODUCTION

Package managers are essential for modern software engineering. With a few lines of configuration,
a programmer can use a package manager to download and install dependencies (including transitive
dependencies) and quickly start writing application code. Package managers also make it easy to
publish new packages and update existing packages, thus they free package authors from thinking
about distribution. In fact, contemporary package managers make publishing and consuming
packages so frictionless that it is not uncommon for a program to (transitively) depend on hundreds
of different packages. When this occurs, the bulk of the code in a program may come from its
dependencies. This paper focuses on package managers for programming languages, specifically
NPM (Javascript), PIP (Python), and Cargo (Rust), though operating system package managers
are closely related (Section 8). Contemporary package managers integrate a multitude of tools
that download, build, and even test packages. This paper focuses on dependency solvers that select
concrete package versions for every (transitive) dependency of a package.

The Design Space of Dependency Solvers. Dependency solvers have a rich and varied design space.
The core responsibility of any dependency solver is to find a compatible set of package versions that
satisfy the prerequisites, or dependencies, of some package(s) requested by the user. To determine

Authors’ addresses: Donald Pinckney, Northeastern University, Boston, MA, USA, pinckney.d@northeastern.edu; Federico
Cassano, Northeastern University, Boston, MA, USA, cassano.f@northeastern.edu; Arjun Guha, Northeastern University,
Boston, MA, USA, a.guha@northeastern.edu; Massimiliano Culpo, np-complete, S.r.l., Mantova, 46100, Italy, massimiliano.
culpo@googlemail.com; Todd Gamblin, Lawrence Livermore National Laboratory, Livermore, CA, 94550, tgamblin@llnl.gov.

 
 
 
 
 
 
1:2

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

what dependencies are required, most package solvers rely on a domain-specific language, or DSL,
for specifying constraints on dependencies. These DSLs vary not just in syntax, but in the semantics
of constraints. For example, “< 2.0” can mean different things to different package managers
(Section 2.1). Even when the semantics of an individual constraint is clear, sets of constraints can
produce conflicting requirements, and dependency solvers address conflicts in different ways. For
example, PIP simply fails when conflicts arise, while NPM and Cargo allow a program to load
several instances of the same package. This design allows more builds to succeed, but can also
produce surprising behavior when data flows between two versions of one package [Behel 2020].
Dependency solvers also handle cyclic dependencies in different ways. Since one version of a
package may have different dependencies from another version, cycles may only occur for particular
package versions. Only some programming languages support cyclic dependencies, and those that do
not may require the solver to select older package versions to break cycles. Finally, even when the
admissible solution space is well understood, dependency solvers have different objective functions
that lead to different solutions. Any sufficiently large package repository (e.g., crates.io, npmjs.com,
or pypi.org), will have several solutions for some sets of constraints, and the solver must select the
“best” according to some criterion. They may try to maximize “newness”, avoid multiple versions of
the same package, reuse existing packages, etc. Some of these objectives can be difficult to define
precisely, and hard to combine in meaningful ways. In fact, many dependency solvers use simple
greedy heuristics, and do not attempt to optimize for specific objectives.

To summarize, all dependency solvers are not created equal, and their behavior can affect
programmers in subtle ways: 1) a programmer who misunderstands the semantics of constraints
may get the wrong version of a package; 2) when a solver selects several versions of the same
package, a program may suffer code-size bloat and runtime bugs; 3) adding a new dependency may
accidentally force an existing dependency to downgrade to a version that has bugs or vulnerabilities;
or 4) a program may fail to build because of unsatisfiable constraints.

The Need for a Semantics of Dependency Solvers. Given the variety of dependency solvers, including
dependency solvers whose behavior has changed over time [Python Software Foundation 2020], one
may want to ask, “Do two dependency solvers (or two versions of a solver) produce different results on a
given set of constraints?”, or “Is an optimization to dependency solving algorithm semantics-preserving?”
However, these questions are difficult to ask or answer, because dependency solvers are defined
by their implementations. Moreover, the implementations are tightly coupled with the semantics
of particular programming languages. To precisely ask these questions, we need a semantics of
dependency solvers that is parameterized by core features like the semantics of constraints or the
objective function. Given a semantics for dependency solvers, we can also 1) determine whether
an unexpected result is merely surprising or a genuine bug in the solver; 2) precisely discuss the
expressiveness of various solver features; or 3) explore the design space of dependency solvers,
including new designs that have not been implemented before.

Empirical Questions about Package Repositories. One way also want to ask empirical questions
about package repositories. For example, there are several design decisions that were made in NPM
to address perceived shortcomings of other package managers. However, now that npmjs.com is
the largest package repository, we may wonder 1) “Do programmers really need several versions of a
single package at once?”; 2) “Do programmers actually need cyclic dependencies?”; or 3) “Can globally
optimizing solvers find significantly better solutions than greedy solvers such as NPM?”. To answer
these questions, we could try to tweak the semantics of NPM’s solver, and observe how it performs
on real-world packages. Unfortunately, NPM (and other solvers) are not amenable to this kind of
experiment: conceptually small changes to their semantics require significant rewrites. However
an executable semantics of dependency solving would enable us to ask these questions.

Dependency Solvers à la Carte

1:3

PacSolve. This paper presents PacSolve, an executable semantics for dependency solvers. Pac-
Solve is parameterized along key axes, e.g., the interpretation of version constraints, when package
versions are co-installable, and the global objectives of dependency solving. An instantiation of
PacSolve defines a relation between solution graphs, which are directed (possibly cyclic) graphs of
packages and their dependencies. This semantics lends itself to an implementation in Rosette [Tor-
lak and Bodik 2014], a solver-aided language that supports program synthesis, and PacSolve is an
executable semantics that formulates dependency solving as solution graph synthesis. We show that
PacSolve captures the essential features and differences between PIP, NPM, and Cargo.

MinNPM. We use PacSolve to build MinNPM, a drop-in replacement for NPM. MinNPM adds
optional command-line arguments to the NPM tool, which allow the user to customize the semantics
of dependency solving. For example, MinNPM allows the user to change how version conflicts are
handled, disallow cyclic dependencies, and customize the objectives of NPM. All of these policy
choices are simple changes to the PacSolve parameters, and require minimal customization.

Empirical Evaluation. We apply MinNPM in a variety of configurations to the top 1,000 NPM
packages. This allows us to draw several conclusions about the NPM package ecosystem and
showcase what customizability MinNPM affords. Our evaluation presents several results, including:

• By minimizing dependencies, MinNPM can shrink the footprint of 21% of packages with at

least one dependency.

• When optimizing for newer packages, MinNPM can find newer dependencies than NPM’s

greedy algorithm for 14% of packages with at least one dependency.

• Only 1.9% of packages need NPM’s support for loading several versions of the same package.

The remaining work with simpler, PIP-style semantics.

MinNPM takes on average 2.6s longer than NPM (though there are a few outliers that time out).

Contributions. This paper makes the following contributions:

(1) PacSolve: an executable semantics for dependency solvers, which are the key component
of package managers. PacSolve is parameterized along several key axes, which allows it to
capture the essential features of several package managers.

(2) MinNPM: a drop-in replacement for NPM that uses PacSolve under the hood. MinNPM

allows the user to customize dependency solving.

(3) An evaluation on the top 1,000 NPM packages that a) answers empirical questions about the

NPM package ecosystem, and b) showcases the flexibility of MinNPM.

The rest of this paper is organized as follows. Section 2 briefly tours the design space of depen-
dency solving by example; Section 3 presents PacSolve, our semantics of dependency solving;
Section 4 applies PacSolve to qualitatively compare and highlight the semantics of PIP, NPM
and Cargo; Section 5 presents our approach for turning our formal semantics into an executable
semantics; Section 6 presents MinNPM, a drop-in replacement for NPM built using the PacSolve
executable semantics; Section 7 presents our evaluation, which compares MinNPM to NPM on the
NPM ecosystem; Section 8 presents related work; and we summarize our conclusions in Section 9.

2 THE LANDSCAPE OF DEPENDENCY SOLVING

This section presents the design space of existing dependency solvers. We describe several features
that dependency solvers share, and highlight differences in their semantics. In particular, we show
that constraints that look similar can produce very different results in different solvers.

1:4

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

2.1 Versions and Constraints

Why do dependency solvers have DSLs for specifying constraints on dependencies? It is a lot
simpler to specify exact versions of dependencies. So, what could go wrong if a package foo
depends on exactly version 1.0.0 of package bar? If foo is an end-user application and cannot be
a dependency of another package, this may be acceptable. However, if the author of bar releases
a security update (version 1.0.1) then foo will not receive the update unless the programmer
manually updates the exact constraint. A second problem arises if foo is a library: specifying exact
dependencies can lead to code duplication (e.g., in NPM) or impossible builds (e.g., in PIP). Suppose
another package baz depends on exactly version 1.1.0 of bar. Given these two exact constraints,
it is not possible for foo and baz to share their dependency on bar within the same program.

To avoid these problems, programmers write constraints (typically ranges) that describe allowable
versions of dependencies. These constraints allow the dependency solver to semi-automatically
update dependencies and to unify dependencies to share code. Continuing the previous example,
suppose foo and baz both require bar and constrain the version to be 1.𝑛.𝑚 (𝑛, 𝑚 ∈ N). This kind
of constraint would allow the dependency solver to find a single version of bar for both packages.
This is a common type of constraint: version 2.0.0 may break compatibility with versions 1.𝑛.𝑚.
Unfortunately, it is not always straightforward to express this constraint to a dependency solver.
Each dependency solver has its own little DSL for specifying version constraints. However, these
DSLs can behave in surprising ways. In the NPM ecosystem, we can write 1.𝑛.𝑚 as follows (spaces
indicate conjunction):

" bar ": " >=1.0.0 <2.0.0"

This constraint works as expected. We can also write a range constraint in Maven, as a half-open
interval:

[1.0.0 , 2.0.0)

Unfortunately, this constraint does not work as expected. Suppose there is a pre-release version of
bar numbered 2.0.0-alpha-1 in the package repository. If so, Maven will install the incompatible
pre-release package, because 2.0.0-alpha-1 < 2.0.0. This interpretation of constraints makes it
difficult to use ranges in Maven [Kutz 2019]. In contrast, NPM interprets ranges differently and
would not install the pre-release version [NPM 2022].

2.2 Version Conflicts

What should a dependency solver do when conflicting constraints occur? Different dependency
solvers address conflicts in very different ways. To illustrate, we consider a tiny subset of the npmjs.
com repository (Figure 1a): three versions of the package ms (a collection of calendar functions),
and one version of the package debug, which depends on the latest version of ms. Suppose a
programmer requires both debug and ms, but notices a performance regression in the latest version
of ms. They may reason that their code should use an older version of ms, but it is okay for their
debugging code, which is not performance-sensitive, to continue to transitively require the latest
version that has the performance regression.

Given these constraints, NPM installs both versions 2.1.0 and 2.1.2 of ms (Figure 1b). In general,
NPM allows several versions of a package to be co-installed and loaded at runtime.1 However, this
behavior is not always desirable, and can lead to increased code size, and subtle runtime bugs.
Moreover, NPM does not guarantee that packages are only duplicated when strictly necessary.

Suppose NPM used PIP’s dependency solver that does not allow duplicate packages. Moreover, PIP
backtracks to find a solution if necessary. In this example, PIP would report that the dependencies

1The exception to this rule are peer dependencies, which are not automatically installed.

Dependency Solvers à la Carte

1:5

1 " dependencies ": {
"debug": "*",
2
"ms": "< 2.1.2"

3
4 }

context

ms
2.1.0

ms
1.0.0

ms
2.1.2

ms
2.1.0

debug
4.3.4

(a) Available packages

debug
4.3.4

ms
2.1.2

(b) JavaScript/NPM

requirements.txt:
1 debug
2 ms < 2.1.2

Unsolvable

(c) Python/PIP

1 [ dependencies ]
2 debug = "*"
3 ms = "< 2.1.2"

context

ms
1.0.0

debug
4.3.4

ms
2.1.2

(d) Rust/Cargo

Fig. 1. The debug package (a debug logging library) and ms package (a library to convert times values to
miliseconds) are available on npmjs.com, with 16.4 billion and 12.6 billion total downloads, respectively.
Figure 1a shows a subset of the versions of each package, and debug’s exact version constraint on ms.
Figures 1b to 1d illustrate the three different results generated by NPM, PIP, and Cargo if the programmer
were to ask for any version of debug and any version of ms strictly less than 2.1.2, supposing the versions
shown in Figure 1a are all the versions in the universe.

are unsolvable (Figure 1c). While this is an unfortunate outcome for the programmer, PIP behaves
this way because the Python module system cannot load multiple package versions of the same
package. However, an advantage of this approach is that it reduces code size and avoids compatibility
problems.

Cargo attempts to strike a balance between NPM and PIP, by disallowing two minor revisions of
the same package to be co-installed. In this case, versions 2.1.0 and 2.1.2 can’t be co-installed, so
Cargo would choose to co-install 1.0.0 and 2.1.2 (Figure 1d). Arguably, this solution is worse
than the NPM solution, since the program is forced to directly depend on a much older version of
ms. Like PIP, Cargo backtracks to find a solution, if one exists.

Unfortunately, it is not clear which (if any) of these policies are the best, and programmers in
different scenarios may want different policies. A goal of PacSolve is to make these choices more
transparent via a formal semantics (Section 3).

2.3 Optimization Objectives

Apart from satisfying dependency constraints, dependency solvers also try to optimize for some
goals. For example, dependency solvers prefer newer versions rather than older versions of a
package,. This behavior is typically determined heuristically by the order in which the dependency
solvers explores the solution space. For example, the NPM and PIP dependency solvers are sensitive
to the order in which developers list dependencies, whereas Cargo’s dependency solver is sensitive
to the lexicographic order of package names. Regardless, all of these dependency solvers optimize
greedily, and do not attempt to find globally optimal solutions.

A more fundamental problem is that what it means to be a newer package is not well defined.
Suppose package 𝐴 has versions 1.0.0 and 2.0.0, and then its author publishes a security update to
the older version numbered 1.0.1. What happens if a program depends on 𝐴 with no constraints?
Cargo and PIP will both prefer to choose 2.0.0 since it has a larger version number, whereas NPM
will choose 1.0.1 because it was uploaded last!

1:6

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

2.4 Solution Spaces

Dependency solvers use different data structures to represent the solution space. Linux system
package managers (e.g. APT), typically model installed packages as a set, e.g. libpng either is or
isn’t installed. PIP behaves in a similar way, and requires virtual environments to install multiple
versions of a package. Prior work on using SAT solvers for package management encoded a solution
space of installed package sets into SAT formulas [Tucker et al. 2007].

However, a set representation is inadequate for NPM and Cargo. Consider again the solution
presented in Figure 1b. The dependency solver has to keep track of not only that ms versions 2.1.2
and 2.1.0 are installed, but also ensure that each dependency on ms refers to the right version.
This naturally leads to modeling solutions as directed graphs, which generalizes the set model.

Unfortunately, a directed graph is still not expressive enough for Cargo, which allows a package
to explicitly and directly load several versions of the same dependency by giving each version a
alias name [Cargo 2022]. To support this behavior, the dependency solver must be able to match
each resolved dependency version with each constraint, and also handle the case where the two
constraints resolve to the same version. We can represent these solutions as directed multi-graphs,
generalizing the directed graph. Finally, an additional variable in solution space design is that Cargo
disallows cycles in the solution graph, whereas NPM freely allows cycles.

2.5 Why a Semantics?

Package managers evolve, and existing package managers have made significant changes to their
dependency solvers over time. It is easy to imagine building a new version of NPM that tries to find
globally optimal solutions, or unify dependencies in the style of PIP. But, we believe that this would
just be yet another point in the dependency solver design space, and not a principled approach to
the problem.

Instead, we next present a parameterized semantics for dependency solving that makes it possible
to compactly express a variety of different dependency solving policies. Moreover, the semantics is
executable, and we use it to build MinNPM, which is a drop-in replacement for NPM. We then use
MinNPM to evaluate several approaches to dependency solving with the NPM ecosystem. MinNPM
is also usable as a command-line tool, so a programmer can use it directly to solve dependencies
with a variety of different objectives and policies.

3 A SEMANTICS OF DEPENDENCY SOLVERS

This section first presents PacSolve. We then give some examples of dependency solver specifica-
tions for PacSolve.

3.1 A Relational Semantics of Dependency Solvers

In the abstract, a dependency solver can be thought of as a function that receives as input 1) metadata
about available packages from package repositories, and 2) a root package to install. Its output
is a solution graph whose nodes are particular package versions drawn from the set of available
packages. Hidden in this function are design decisions summarized in Section 2. In contrast, we
formulate PacSolve as a relation (Figure 2) to account for dependency solvers that may admit
multiple solutions. S is a ternary relation between package metadata (M), a dependency solver
specification (F ), and a solution graph (G).

Package Metadata. The package metadata (top of Figure 2) is a tuple that has 1) a set of package
name and version pairs (N ), and 2) a finite map (deps) from these name-version pairs to a list of
dependencies (D). Each dependency specifies a package name and a version constraint (C ) on
that package. The syntax of package versions (V) and version constraints (C ) varies between

Dependency Solvers à la Carte

1:7

Package Metadata
P ::= String
V is a set
C
is a set
D ::= P × C
N ⊆ P × V

fin
−−→ D∗

: N
deps
root ∈ N

M ::= ⟨N, deps⟩

Dependency Solver Specification

: C → V → Bool
: V → V → Bool

sat
consistent
cycles_ok ∈ Bool
minGoal

: G → R𝑛

Package Names
Version Numbers
Version Constraints
Dependencies
Package repository (finite set)

Dependencies per node
The root node of the solve
Package metadata

Constraint satisfaction semantics
Version consistency versions
If cycles are permitted in solution graphs
Objective functions

F ::= ⟨sat, consistent, cycles_ok, minGoal ⟩ Dependency solver specification

Solution Graph
𝑁𝑅 ⊆ N
𝐷𝑅 ∈ 𝑁𝑅 → 𝑁 ∗
𝑅
G ::= ⟨𝑁𝑅, 𝐷𝑅 ⟩

package versions in solution
Solved dependencies
Solution graphs

The PacSolve Relation
S ⊆ 2F × 2M × 2G
For all ( ⟨sat, consistent, cycles_ok, minGoal ⟩, ⟨N, deps⟩, ⟨𝑁𝑅, 𝐷𝑅 ⟩) ∈ S :

root ∈ 𝑁𝑅
⟨𝑁𝑅, 𝐷𝑅 ⟩ is connected
∀𝑛.𝑛 ∈ 𝑁𝑅 =⇒ |𝐷𝑅 (𝑛) | = |deps (𝑛) |
∀𝑛.𝑛 ∈ 𝑁𝑅 =⇒ ∀𝑖.0 ≤ 𝑖 < |𝐷𝑅 (𝑛) | =⇒ ∃𝑝, 𝑣, 𝑐. (𝑝, 𝑣) = 𝐷𝑅 (𝑛) [𝑖 ] ∧ (𝑝, 𝑐) = deps (𝑛) [𝑖 ] ∧ sat (𝑐, 𝑣)
∀𝑝, 𝑣, 𝑣′. (𝑝, 𝑣), (𝑝, 𝑣′) ∈ 𝑁𝑅 =⇒ consistent (𝑣, 𝑣′)

1.
2.
3.
4.
5.
6. ¬cycles_ok =⇒ ⟨𝑁𝑅, 𝐷𝑅 ⟩ is acyclic

Fig. 2. The PacSolve Model of Dependency Solving

dependency solvers, and their semantics is determined by the dependency solver specification,
which we describe below. Without loss of generality, we assume that all package names are strings
and that there is a distinguished root package (root ∈ N ).

Depedency Solver Specification. The dependency solver specification is a 4-tuple with the following

components:

(1) A constraint satisfaction predicate that consumes a constraint and a package version, and

determines if that version satisfies the constraint (sat);

(2) A version consistency predicate that consumes two package versions and determines if those

two versions of the same package may be co-installed (consistent);

(3) A flag that determines if the solution graph may have cycles (cycles_ok); and
(4) An objective function that consumes a solution graph and produces its cost (minGoal).

Solution Graphs. The result of a dependency solver is a solution graph (G). A solution graph is a
directed graph, where the nodes are package-version pairs, and each node has an ordered list of
edges. The order of edges corresponds to the order of dependencies in the package metadata. For
example, suppose the dependencies of root are the packages 𝐴, 𝐵, 𝐶 (with some constraints) in the
package metadata. If so, the outgoing edges from root in the solution graph would refer to specific
versions of 𝐴, 𝐵, 𝐶 in the solution graph.

1:8

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

Semantics. The semantics of PacSolve is a relation (S) that holds when a solution graph is valid
with respect to the package metadata and the dependency solver specification. The relation holds if
and only if the following six conditions are satisfied. First, the solution graph must include the root:
root ∈ 𝑁𝑅

(1)

Second, the solution graph must be connected, to ensure it does not have extraneous packages:
⟨𝑁𝑅, 𝐷𝑅⟩ is connected

(2)

Third, for all packages in the solution graph, every edge must correspond to a constraint in the
package metadata:

∀𝑛.𝑛 ∈ 𝑁𝑅 =⇒ |𝐷𝑅 (𝑛)| = |deps(𝑛)|
(3)
Fourth, for every edge in the solution graph that points to package 𝑝 with version 𝑣, the corre-
sponding constraint in the package metadata must refer to package 𝑝 with constraint 𝑐, where 𝑣
satisfies 𝑐:
∀𝑛.𝑛 ∈ 𝑁𝑅 =⇒ ∀𝑖.0 ≤ 𝑖 < |𝐷𝑅 (𝑛)| =⇒ ∃𝑝, 𝑣, 𝑐. (𝑝, 𝑣) = 𝐷𝑅 (𝑛) [𝑖] ∧ (𝑝, 𝑐) = deps(𝑛) [𝑖] ∧ sat (𝑐, 𝑣)
(4)
The criteria so far are adequate for many dependency solvers, but permits solutions that may
be unacceptable. For example, without further constraints, a solution graph may have several
versions of the same package. Thus the fifth condition ensures that if there are versions of a package
in the solution graph, then the two versions are consistent, as judged by the dependency solver
specification:

∀𝑝, 𝑣, 𝑣 ′. (𝑝, 𝑣), (𝑝, 𝑣 ′) ∈ 𝑁𝑅 =⇒ consistent (𝑣, 𝑣 ′)
(5)
NPM allows arbitrary versions to be co-installed (so consistent is the constant true function), Cargo
only allows semver-incompatible versions to be co-installed, and PIP only allows exactly one
version of a package to be installed at a time (so consistent requires 𝑣 = 𝑣 ′).

A final distinction between dependency solvers is whether or not they allow cyclic dependencies.
NPM and PIP support them, whereas Cargo does not. Thus the sixth condition uses the dependency
solver specification to determine whether or not cycles are permitted:

¬cycles_ok =⇒ ⟨𝑁𝑅, 𝐷𝑅⟩ is acyclic

(6)

These six conditions determine whether or not a solution graph is correct with respect to the

semantics of a particular dependency solver.

3.2 Example: A Fragment of NPM in PacSolve

We now present a dependency solver specification (F ) for a fragment of NPM. MinNPM is a
complete implementation that we discuss in Section 6 and use in evaluation.

In the concrete syntax of NPM, versions are represented as JSON strings. For example, the string
"x.y.z" represents the version 𝑥 .𝑦.𝑧 using semantic versioning (semver): each decimal represents a
major, minor, and bugfix version, respectively. Incrementing a major version indicates a break in
backward compatibility; incrementing a minor version indicates that features have been added, but
none break existing APIs; and patch version differences indicate bugfixes that have no effect on the
compatibility of two versions. NPM also uses strings to represent constraints, and supports a variety
of operators, including conjunction, disjunction, upper and lower bounds, and semver compatibility.
It is straightforward to translate these version and constraint strings to equivalent S-expressions:
we represent a version as a list of three numbers, (x y z) and constraints as shown in Figure 3a.
With both constraints and versions written as S-expressions, we can write the version-constraint
satisfaction predicate as a recursive function in Racket, which uses pattern matching to compactly
interpret ranges and semver compatibility (Figure 3b).

Dependency Solvers à la Carte

1:9

V (cid:66) (𝑥 𝑦 𝑧)
C (cid:66) (= 𝑥 𝑦 𝑧)

| *
|
|
|
|
|

(<= 𝑥 𝑦 𝑧)
(>= 𝑥 𝑦 𝑧)
(∧ 𝑥 𝑦 𝑧)
(and C1 C2)
(or C1 C2)

Version numbers
Exact
Any
At most
At least
Semver compatible with
Conjunction
Disjunction

(a) Example of V and C , allowing conjunction, disjunction, and range operators on semver-style versions.

1 (define (sat c v)
(match `(,v ,c)
2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

[`((,x ,y ,z) (= ,x ,y ,z))
#true]
[`(,_ *)
#true]
[`((,x ,y ,z1) (<= ,x ,y ,z2))
(<= z1 z2)]
[`((,x ,y1 ,z1) (<= ,x ,y2 ,z2))
(< y1 y2)]
[`((,x1 ,y1 ,z1) (<= ,x2 ,y2 ,z2)) (< x1 x2)]
[`((0 0 ,z1) (^ 0 0 ,z2))
(= z1 z2)]
[`((0 ,y ,z1) (^ 0 ,y ,z2))
(>= z1 z2)]
[`((0 ,y1 ,z1) (^ 0 ,y2 ,z2))
#false]
[`((,x ,y ,z1) (^ ,x ,y ,z2))
(>= z1 z2)]
[`((,x ,y1 ,z1) (^ ,x ,y2 ,z2))
(> y1 y2)]
[`(,_ (and ,c1 ,c2))
(and (sat c1 v) (sat c2 v))]
[`(,_ (or ,c1 ,c2))
(or (sat c1 v) (sat c2 v))]
[`((,x1 ,y1, z1) (>= ,x2 ,y2 ,z2)) (sat `(,x2 ,y2 ,z2) `(<= ,x1 ,y1 ,z1))]
[_

#false]))

(b) A sat interpretation function for V and C defined in Figure 3a.

Fig. 3. Example of V, C , and sat

3.3 Example: Objective Functions

The goal of a dependency solver is to find a solution that is not only correct, but also good by some
metric. Some dependency solvers prefer to install versions with larger version numbers, whereas
others prefer to install more recently uploaded versions. Other metrics are possible as well, such
as total download size or number of dependencies [Tucker et al. 2007] and multiple prioritized
objectives [Gamblin 2020; Gamblin et al. 2015]. PacSolve takes an objective function that maps a
solution graph to a sequence of numbers that represent a prioritized list of minimization criteria
(minGoal : G → R𝑛).

Figure 4, defines three examples of minimization functions, to give an example of concrete
criteria. The first example (Figure 4a) is the simplest: given a solution graph 𝐺, it returns how
many nodes are in 𝐺, thus minimizing the total number of dependencies. The second example
(Figure 4b) minimizes the co-installation of multiple versions of the same package. The function
first counts how many nodes there are in the graph for each package. Then, for each package, we
assign a cost of 1 for each extra node, and sum all the costs up. The third example (Figure 4c) is an
interpretation of the common goal that package managers have of trying to choose newer versions
of dependencies. In this example, each node in the graph is assigned an oldness, which is a linear
score between 0 (newest) and 1 (oldest) of that version’s rank in the total ordering of versions for
that package. These oldness scores are then summed up across the graph. There are two subtleties
with this definition. 1) The choice to perform minimization rather than maximization is important,
as a goal of maximizing a newness score, e.g. 1 meaning newest, 0 meaning oldest, would encourage

1:10

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

1 (define (minGoal-num-deps g)
(length (graph-nodes g)))
2

(a) Minimize the total number of installed dependencies.

1 (define (minGoal-duplicates g)
; we count how many times
2
; each package name occurs
(define package-counts (foldl

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

(lambda (n counts)

(define p (node-package n))
(hash-set counts p

(add1 (hash-ref counts p 0))))

(make-immutable-hash)
(graph-nodes g)))

; then assign a cost of 1
; for each duplicate
(apply +
(map

(lambda (c) (max 0 (sub1 c)))
(hash-values package-counts))))

(b) Minimize the total number of co-installed versions of
the same package.

3

4

5

6

7

8

12

13

14

15

16

17

18

1 (define (minGoal-oldness g)
2

(apply +
(map

(lambda (n)

(get-oldness

(node-package n)
(node-version n)))

(graph-nodes g))))

9
10 (define (get-oldness p v)
11

; The get-sorted-versions retrieves
; a list of all versions of p
(define all-vs

(get-sorted-versions p))
(if (= (length all-vs) 1)

0
(/ (index-of all-vs v)

(sub1 (length all-vs)))))

(c) Minimize the amount of “oldness” present in
the solution graph. Each resolved dependency con-
tributes an oldness proportional to its rank among
the total ordering of versions of that package

Fig. 4. Three different examples of PacSolve minimization objectives

the solver to find very large solution graphs so as to inflate the total newness. 2) The choice to sum
rather than average the oldness values likewise discourages the solver from adding in a lot of new
nodes so as to inflate the mean oldness.

4 REASONING ABOUT DEPENDENCY SOLVERS WITH PACSOLVE

PacSolve gives us a way to write down the (missing) formal specification of a dependency solver.
In this section, we sketch what a PacSolve-based semantics would look like for PIP, NPM, and
Cargo. We then state some simple, universal properties that we believe any dependency solvers
should satisfy. Notably, these are universal properties that are independent of an implementation.
Finally, we ask if the implementations of PIP, NPM, and Cargo satisfy these properties. Our testing
suggests that PIP satisfies two of three properties, while PIP and NPM only satisfy one property.

4.1 Specifying Versions and Version Constraints

A package manager can choose a syntax for version numbers that stores any data necessary to
disambiguate configurations of a package. For example, an accurate structure of version numbers
for NPM contains not only three numbers for a semver version, but an additional field for op-
tional release tags: e.g., 1.2.3-alpha1. Python’s PIP package manager uses version numbers that
are fully compatible with semantic versioning, with similar extensions for pre- and post-release
versions [Coghlan 2013].

Version numbers in Rust’s Cargo are more sophisticated. Cargo allows packages to contain
named features, which can be used to enable conditional compilation and enable otherwise disabled
dependencies. For example, an image processing package may contain the features “png” and
“jpeg”. To model this, we might choose elements of V to have the form (𝑥, 𝑦, 𝑧, 𝐹 ), where 𝐹 is a
subset of the listed features for version 𝑥 .𝑦.𝑧.

Dependency Solvers à la Carte

1:11

Similarly, constraints (C ) may be enriched to contain necessary data to model the package
manager. In Cargo’s case, for example, constraints would be extended to contain both version
range constraints similar to Figure 3a and a set of features that are required to be enabled in the
dependency. Based on how the sets of versions and constraints have been chosen, the constraint
satisfaction function (sat) needs to be adapted to model the package manager.

NPM’s semantics for matching prerelease versions is subtle. A prerelease version can only satisfy
a constraint if a sub-term of the constraint with the same semver version also has a prerelease. For
example, consider the following constraint (spaces indicate a conjunction):

>1.2.3-alpha.3 <1.5.2-alpha.8

It may be obvious that package versions v1.2.3-alpha.7 and v1.5.2-alpha.6 do satisfy the con-
straint. However, package version v1.3.4 also satisfies the constraint, and version v1.3.4-alpha.7
does not satisfy the constraint. This behavior prevents the unexpected outcome of Maven’s range
constraints (Section 2.1). As part of our implementation of MinNPM (Section 6) we have en-
coded these semantics in PacSolve, which works by having the sat function recursively check for
constraint terms which contain identical semver versions with prereleases.

The semantics of Cargo’s features requires a node in the solution graph to enable all the features
which dependents requested, and no more. Specifically, Cargo implements a unification semantics,
where the enabled features of a node 𝑁 should be the union of the requested features from all
predecessors of 𝑁 in the solution graph. These semantics can be encoded in PacSolve by making
use of both sat and minGoal. The sat function checks that the enabled features are a superset of the
requested features, and the minGoal function would minimize at the highest priority the number
of enabled features, so that no extras are included.

4.2 Consistency and Cycles

NPM, PIP, and Cargo all make different choices of consistency semantics, at different points along
a spectrum of consistency strictness. PIP is the strictest of these three package managers: it forbids
installation of different versions of the same package. This behavior is dictated by two factors. First,
Python’s module system identifies modules only by name, and if any two modules with the same
name are in Python’s module search path, one will always shadow the other. Second, at least when
installing modules into a single Python installation or virtual environment, two modules with the
same name will conflict on the filesystem.

Neither Rust nor JavaScript have Python’s single version restriction; they allow installation of
different versions of the same package. Node supports this because packages (JavaScript source files)
are laid out in a node_modules directory tree on disk. Any directory in the tree can have its own local
version of a dependency. Multi-versioning is possible in Rust because Rust binaries are statically
linked, and rely on symbol rewriting to differentiate two instances of the same package. Cargo
chooses to restrict this to only allow versions to be co-installed if they are not semver-compatible.
So, under Cargo’s semantics, 1.3.5 and 2.1.4 can be co-installed, but 1.3.5 and 1.4.2 cannot be
co-installed. In the most relaxed case, NPM allows any versions whatsoever to be co-installed. All
three of these consistency semantics can be encoded in PacSolve as shown in Figure 5.

In addition, the dependency solvers exhibit different semantics with regards to cycles: NPM and

PIP allow for cyclic solution graphs, but Cargo forces all solution graphs to be acyclic.

4.3 Some Desirable Properties of Dependency Solvers

We have sketched the main differences between PIP, NPM, and Cargo, and shown how these
differences can be encoded in PacSolve. We now ask the question: what are some properties that
all dependency solvers should satisfy? We claim that the following properties are desirable:

1:12

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

1 (define (npm-consistent v1 v2)
2

#true)

3
4 (define (pip-consistent v1 v2)
5

(equal? v1 v2))

6
7 (define (cargo-consistent v1 v2)
8

(match `(,v1 ,v2)

9

10

11

12

13

[`((0 0 ,z1) (0 0 ,z2))
[`((0 ,y ,z1) (0 ,y ,z2))
[`((0 ,y1 ,z1) (0 ,y2 ,z2))
[`((x ,y1 ,z1) (x ,y2 ,z2))
[_

#true]
(= z1 z2)]
#true]
(and (= y1 y2) (= z1 z2))]
#true]))

Fig. 5. Examples of three different consistency functions

(1) (Soundness) The solution graph should satisfy all constraints;
(2) (Completeness) The dependency solver should find a solution if one exists; and
(3) (Optimality) The dependency solver should produce the lowest cost solution.

PacSolve makes it possible to formally state these properties:
Definition 4.1 (Soundness). A dependency solver specified by F is sound if for all possible package
metadata (M) and all solutions that it produces (graphs 𝐺), we have (F , M, 𝐺) ∈ S.

In our testing, all three of PIP, NPM and Cargo returned correct solution graphs, for appropri-
ate choices of PacSolve semantics as outlined above. Note that this is a stronger property for
dependency solvers with strict notions of consistency (PIP, Cargo), and for dependency solvers
which disallow cycles (Cargo). We conjecture that PIP, NPM and Cargo all have sound dependency
solvers.

Unsoundness of Maven and NuGet. However, not all dependency solvers are sound. Maven
and NuGet are like PIP, where each package must resolve to exactly one version. Their version
constraints are also similar (and simpler) than PIP, NPM, and Cargo, so are easy to encode in
PacSolve. However, they do not guarantee that their solutions satisfy all package constraints.
Instead, when version consistency conflicts arise, they ignore all but the closest package constraints
to the root. Thus Maven and NuGet are unsound.
Definition 4.2 (Completeness). A dependency solver specified by F is complete if for all M, if
there exists a 𝐺 where (F , M, 𝐺) ∈ PacSolve, then the dependency solver produces a solution 𝐺 ′
such that (F , M, 𝐺 ′) ∈ S.

In our testing, PIP always managed to successfully return a solution graph, if a solution graph
exists according to PIP’s semantics. PIP backtracks upon finding either conflicting nodes, or version
constraints which cannot be satisfied by any package versions. Enough backtracking will eventually
find a solution, if one exists (even if that solution is far from optimal, as explained below). We
conjecture that PIP has a complete dependency solver. However, NPM and Cargo demonstrate
different ways in how completeness can go wrong.

Incompleteness of NPM. NPM implements a non-backtracking dependency solver. While NPM
cannot fail due to conflicts among version nodes, failure may occur when a version constraint
cannot be satisfied by any possible version. In this case, NPM is unable to backtrack, and gives up,
whereas PIP or Cargo can attempt finding other solutions. Consider a package A with two versions:

Dependency Solvers à la Carte

1:13

Av1.0.0 which has no dependencies, and Av2.0.0 which depends on exactly version Bv9.9.9.
Furthermore, suppose that Bv9.9.9 does not exist in the package repository. (This situation happens
in practice.) Now, suppose the root node then depends on any version of package A.

There exists a satisfying solution graph: the root node chooses Av1.0.0, which then has no
further dependencies. This is the solution that Cargo and PIP will find, after they both attempt and
backtrack away from Av2.0.0. However, NPM fails: it greedily commits to Av2.0.0 and then fails
to find Bv9.9.9.

Incompleteness of Cargo. Unlike NPM, Cargo performs backtracking similarly to PIP, so one
might expect Cargo to have a complete solver. However, Cargo also checks that the solution graph
is acyclic, but does not backtrack when a cycle is found. For example, suppose we have package A
with two versions, and a package B with one version, with the following dependencies: Av1.0.0
has no dependencies, Av2.0.0 depends on any version of B, and Bv1.0.0 depends on any version
of A. Finally, the root node depends on any version of A. There exists an acyclic solution: the root
node chooses Av1.0.0, which then has no further dependencies. However, in this situation Cargo
will find a cyclic solution first, recognize that it is cyclic, and fail with an error.
Definition 4.3 (Optimality). A dependency solver specified by F is optimal if for all M, for any
correct solution 𝐺 that it produces given M, there does not exist a 𝐺 ′ with (F , M, 𝐺 ′) ∈ S where
𝐺 ′ has lower cost than 𝐺, that is, minGoal(𝐺 ′) < minGoal(𝐺).

The property of optimality depends on the specific choice of minimization criteria (minGoal), in
addition to the other choices of semantics. A common optimization objective is to prefer newer
versions of packages when possible, but NPM, PIP and Cargo do not agree on what “newer” means:
PIP and Cargo prefer numerically larger version numbers, while NPM has a more complex strategy
of preferring the temporally most recently uploaded version and then falling back to largest version
numbers. More generally, a wide range of other optimization criteria are possible, as explained in
Section 3.3. NPM, PIP and Cargo all apply their preference for newer versions (for their choice of
newer) in a heuristic manner, guided by the order in which they explore solution graphs. All of
these package managers are not, in general, optimal.

5 SYNTHESIZING SOLUTION GRAPHS WITH PACSOLVE

Performing dependency solving in the face of potentially conflicting dependencies is known to be
NP-complete [Di Cosmo 2005]. Some package managers use polynomial-time algorithms by giving
up on various properties, such as disregarding conflicts (NPM) and eschewing completeness (NPM
and PIP’s old solver [Python Software Foundation 2020]). Since the PacSolve model includes a
generalized notion of conflicts (consistent), we make use of SMT solvers to implement PacSolve
efficiently.

We implement PacSolve in Rosette [Torlak and Bodik 2013], which is a solver-aided language
that facilitates building verification and synthesis tools for DSLs. In the PacSolve DSL, the program
is a solution graph. We implement a function that consumes (1) package metadata, (2) a dependency
solver specification (Figure 2) and (3) a solution graph, and then asserts that the solution graph is
correct. Since we use Rosette, with a little effort, we can feed the predicate a solution graph sketch
instead of a concrete solution graph. This allows us to use Rosette to perform angelic execution [Broy
and Wirsing 1981] to synthesize a solution graph that satisfies the correctness criteria. This section
describes the synthesis procedure in more detail, starting with how we build a sketch.

Sketching solution graphs. Before invoking the Rosette solver, we build a sketch of a solution
graph that has a node for every version of every package that is reachable from the set of root
dependencies. Every node in a sketch has the following fields: (1) a concrete name and version for

1:14

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

debug 4.3.4

included

depth

Package debug

Root

included

depth

ms 1.0.0

ms 2.1.0

ms 2.1.2

included

depth

included

depth

included

depth

Package ms

Fig. 6. A solution graph sketch corresponding to Figure 1

the package that it represents (or the distinguished root node); (2) a symbolic boolean included that
indicates whether or not the node is included in the solution graph; (3) a symbolic natural number
depth which we use to enforce acyclic solutions when desired; (4) a vector of concrete dependency
package names; (5) a vector of concrete version constraints for each dependency; and (6) a vector
of symbolic resolved versions for each dependency.

Figure 6 illustrates the solution graph sketch corresponding to the dependency solving problem
given in Figure 1. The combination of concrete dependency names and symbolic dependency
versions can be seen as representing symbolic edges in two parts: a concrete part which does not
need to be solved for (solid arrows), and a symbolic part which requires solving (dashed arrows).
This representation shrinks the solution space of graphs as outgoing edges can only point to nodes
with the correct package name.

Graph Sketch Solving. We define three assertion functions that check correctness criteria of a

solution graph:

(1) check-dependencies consumes a graph and a node, and asserts that if the node is included,
then all the dependencies of the node are (1) included in the graph; and (2) consistent with the
associated version constraints as judged by the constraint interpretation function (sat). We
run this assertion function on all nodes, and additionally assert that the root node is included.
(2) globally-consistent? consumes a graph and asserts that for all pairs of nodes that are
(a) included in the graph, and (b) have the same package name, their package versions are
allowed to be co-installed as given by the consistency function (consistent).

(3) acyclic? consumes a graph and a node, and asserts that the depth of the node is strictly less
than the depth of all its dependencies. If an acyclic solution is desired, we run this assertion
function on all nodes, and assert that the root node has depth zero.

We also use Rosette to execute the objective function (minGoal) on the graph sketch, yielding
a symbolic real-valued formula, and then instruct Rosette to minimize it when concretizing the
solution graph sketch. As a final step, to produce a solution graph, we traverse the concretized
solution graph sketch from the root node, and produce those nodes that are marked included.

6 MINNPM

Building on top of the executable semantics of PacSolve we implement a new dependency solver
for NPM: MinNPM. As a tool, MinNPM is used via the command line just as NPM would be

Dependency Solvers à la Carte

1:15

used, but offering user customization of consistency criteria and of global optimization objectives.
Specifically, MinNPM does the work of taking the flexible semantics of Figure 2, and implementing
the domain of versions (V), domain of constraints (C ), and constraint satisfaction semantics (sat)
to behave identically to NPM’s version numbering and constraint semantics.

6.1 MinNPM’s User Interface

MinNPM is implemented as a fork of NPM, adding support for a PacSolve-based solver which
users must opt-in to. When running an npm install command, users can now write npm install
--minnpm to enable the new dependency solver.

MinNPM’s semantics are configurable by the user. The user may choose both the consistency
semantics and the minimization objectives. Without customization, MinNPM will by default use
standard NPM’s notion of consistency (Figure 5) and minimize at the highest priority the presence
of older versions, and at lower priority the total number of resolved dependencies. To change
the consistency semantics, the user uses the --consistency <style> option, where <style> is
one of npm, pip or cargo. The minimization objectives can be specified by the user providing a
comma separated list of prioritized objectives, built from linear combinations of three pre-defined
objectives. The pre-defined objectives to choose from are:

• min_oldness: Minimizes the number of installed old versions.
• min_num_deps: Minimizes the number of installed dependencies.
• min_duplicates: Minimizes the number of co-installed different versions of the same pack-

age.

The precise meaning of each of the objectives is given in Figure 4. For example, the command:

1 npm install --minnpm --consistency pip --minimize min_oldness,min_num_deps

would force there to be no co-installation of different versions of the same package, while choosing
the least old versions possible, and then the smallest number of dependencies possible.

6.2 Applications of MinNPM

We believe that MinNPM is useful in several ways.

MinNPM As a Tool for Programmers. We envision MinNPM as a useful tool for JavaScript
programmers. We designed MinNPM to interoperate easily with standard NPM, so programmers
can easily transition to using MinNPM. Using MinNPM, programmers can solve dependencies in
several different ways, e.g., minimize total dependencies to decrease code size, or minimize oldness
to increase reliability and security. Programmers can use PIP’s stricter consistency semantics, to
avoid the pitfalls of having several versions of the same package. Our evaluation (Section 7.1) shows
that there are a few cases where MinNPM is significantly slower than NPM. However, it is always
possible to fallback to NPM if MinNPM fails.

As a Tool for Evaluating Depedency Solver Design Choices. While sections 3 and 4 discuss the
semantic differences between dependency solvers, it is also valuable to understand how design
choices affect dependency solutions in real-world package ecosystems. Since MinNPM is the first
package manager with configurable semantics, we can use MinNPM to perform apples-to-apples
comparisons of different design points in the space of dependency solvers within the same package
ecosystem. In Section 7.2 we run MinNPM in different configurations on the NPM ecosystem to
explore the effects of different dependency solver designs.

1:16

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

As a Template for Building Package Managers with PacSolve. We have designed PacSolve to serve
as a backend for dependency solving in arbitrary package managers. While most of MinNPM’s
code is NPM-specific and cannot be directly reused, the general steps and algorithms it took to
implement MinNPM are highly transferrable to other package managers. We view MinNPM as a
sample implementation of using PacSolve to build a package manager. In order to explore this
further, we discuss the implementation steps and details of MinNPM.

6.3 How to Build a Package Manager with PacSolve: MinNPM as an Example

To use PacSolve to implement a package manager, there are three main components to develop:
(1) Concrete choices of semantic properties, (2) a procedure for building PacSolve queries based
on dependencies and the package ecosystem, and (3) a procedure to decode a PacSolve result into
the correct structure on disk. We walk through these components in the case of MinNPM.

Setting Concrete Semantics. The concrete semantics that are specified in a PacSolve query are a
declarative specification of the dependency solver’s behavior. While PacSolve makes it easier to
get these correct compared to an ad-hoc implementation, one must be very careful to define them
carefully. When using PacSolve to build a package manager to interoperate with an existing package
manager (in the case of MinNPM and NPM), the existing package manager’s semantics provide
some formal guidance on how to choose the semantics. Specifically, the constraint satisfaction
semantics (sat) of the new package manager should align with the old package manager, though
the domain of versions and constraints need not be the same between the two. If we assume the old
package manager (not implemented, but modeled with PacSolve) has a domain of versions (V𝑜𝑙𝑑 ),
constraints (C𝑜𝑙𝑑 ), and satisfaction predicate (sat𝑜𝑙𝑑 : C𝑜𝑙𝑑 → V𝑜𝑙𝑑 → Bool), then the new package
manager must know how to translate versions and constraints into its choice of new domains
(encv : V𝑜𝑙𝑑 → V and encc : C𝑜𝑙𝑑 → C ), and define the semantics of constraint satisfaction
(sat : C → V → Bool) such that satisfaction in one package manager is equivalent to satisfaction
in the other:

∀𝑣𝑜𝑙𝑑 ∈ V𝑜𝑙𝑑, ∀𝑐𝑜𝑙𝑑 ∈ C𝑜𝑙𝑑,

sat𝑜𝑙𝑑 (𝑐𝑜𝑙𝑑, 𝑣𝑜𝑙𝑑 ) ⇐⇒ sat (encc (𝑐𝑜𝑙𝑑 ), encv (𝑣𝑜𝑙𝑑 ))

(7)

The motivation to choose new version and constraint domains to be different from old domains
is to encode version and constraint information in datatypes that are solvable or more efficiently
solvable by the PacSolve implementation. For example, in NPM’s implementation, versions are a
4-tuple N × N × N × String, where the last component is the prerelease string (e.g. alpha-3). In
the MinNPM implementation we encode this to be a natural number induced by the lexicographic
ordering of prerelease strings within a single PacSolve query, and likewise for prerelease strings
contained inside constraints. This ensures that prerelease ordering will be translated to Z3’s theory
of bitvectors.

Preparing Queries. MinNPM must decide at runtime what set of packages (N ) to include in the
PacSolve query. For the solver to be complete and optimal (Section 4.3), MinNPM must include
enough nodes in N such that if there exists a solution, then an optimal solution can be found using
only the nodes in N . A sound algorithm for this is a graph traversal starting at the root node, and
moving from node 𝑥 to node 𝑦 = (𝑝 ′, 𝑣) if for any (𝑝, 𝑐) ∈ deps(𝑥), 𝑝 = 𝑝 ′ and sat (𝑐, 𝑣) is true. Any
potentially useful node for the solve will be visited by the graph traversal. It can easily be seen that
any correct and consistent solution graph would be a subgraph of the graph traversal. This query
preparation is agnostic to the specific package manager, and would be applicable to other package
managers targeting PacSolve.

Dependency Solvers à la Carte

1:17

Decoding the Result. PacSolve will return a directed multigraph as a solution back to the package
manager when solving is complete. As a final step, the package manager must walk through the
solution graph to build an appropriate data structure specific to the package manager, and then
perform the actual package installation. In MinNPM, the solution graph must be turned into a
directory tree on disk, where directory nesting corresponds to graph edges. Vertices with an in-
degree larger than 1 must have symlinks point to them instead, which can be determined via a
traversal through the solution graph.

7 EVALUATION

In this section we run MinNPM on a dataset of the top 1000 most downloaded packages from
npmjs.com in order to explore three questions:

(1) Is MinNPM reliable and performant? NPM itself fails to solve dependencies for 47 packages.
In contrast, MinNPM fails on 26—28 packages, of which 25–27 are due to timing out. The
reason there are a range of failures is because we customize MinNPM in several ways. When
it succeeds, the MinNPM takes an additional 2.6s on average.

(2) Are certain dependency solver designs necessary? With MinNPM in hand, we can empirically

answer questions posed in Section 1:
(a) How many package need NPM’s support for multiple versions of the same dependency?
(b) How many package rely on cyclic dependencies?
We find that only 1.9% of packages require multiple versions of packages, and that no packages
require cyclic dependencies.

(3) Can MinNPM solve dependencies in new ways that are useful to programmers? Specifically,
can MinNPM be used to: (a) produce solutions with newer dependencies, and (b) produce
solutions with fewer dependencies? Among packages with at least one dependency, we
find that MinNPM (depending on configuration) produces newer dependencies for 14% of
packages, and decreases the number of dependencies for 21% of packages.

Dataset. We apply MinNPM and NPM to the top 1,000 most downloaded packages from npmjs.
com in August 2021. These packages have other dependencies, thus the full set of packages that we
build involves more than 1,000 packages.

Experimental setup. Our performance benchmarks are reported on Linux, with a 16-Core AMD
EPYC 7282 CPU and 64 GB RAM. We use NPM 7.20.1. MinNPM uses Racket 8.2, Rosette commit
1d042d1, and Z3 commit 05ec77c. NPM and MinNPM cache packages locally, and we warm the
cache before measuring running times. We also configure NPM to not run post-install scripts, not
install optional features, and not perform audits.2

The rest of this section presents these results in more depth, and highlights several illustrative

examples.

7.1 Reliability and Performance of MinNPM

7.1.1 Reliability. On the top 1,000 packages, Table 1 shows the number of packages on which
NPM and MinNPM fail. Overall, NPM itself fails to solve dependencies for 47 packages, whereas
MinNPM with NPM-style consistency fails on 26—28 packages. (We discuss failures with other
configurations in Section 7.2.1.)

It may come as a surprise that NPM itself fails to solve dependencies on some packages. Many
of these failures occur because NPM attempts to solve for broken peer-dependencies (a type of

2We use --no-audit, --prefer-offline, --ignore-scripts, --omit dev, --omit peer, --omit optional as flags for
NPM.

1:18

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

Consistency Allow cycles? Minimization

Solver
NPM
MinNPM npm
MinNPM npm
MinNPM npm
MinNPM pip
MinNPM cargo
MinNPM npm
MinNPM cargo
MinNPM pip

0
0
0
0
19
3
0
3
19
Table 1. Failures that occur on top 1000 downloaded Node packages.

min_oldness,min_num_deps
min_num_deps,min_oldness
min_oldness,min_duplicates
min_oldness,min_num_deps
min_oldness,min_num_deps
min_oldness,min_num_deps
min_oldness,min_num_deps
min_oldness,min_num_deps

Yes
Yes
Yes
Yes
Yes
No
No
No

Unsat Timeout Other
47
1
1
1
1
1
1
1
1

0
27
27
26
54
54
27
52
54

(a) A CDF of the additional time taken by Min-
NPM to solve and install packages compared to
NPM, including outliers.

(b) A CDF of the additional time taken by Min-
NPM to solve and install packages compared to
NPM, excluding outliers.

Fig. 7. CDFs of the additional time taken by MinNPM to solve and install packages compared to NPM,
ignoring timeouts and failures, with outliers (> 20s) included in Figure 7a and excluded in Figure 7b. The
outliers take up to 329s extra seconds, but the mean and median slowdowns are only 2.6s and 1.6s, respectively.
In this experiment MinNPM was configured with NPM-style consistency, allowing cycles, and minimizing
oldness first and then number of dependencies.

optional conflicting dependency in NPM). In contrast, MinNPM succeeds because these broken
dependencies are optional.3

Overall, MinNPM (with NPM-style consistency) fails on up to 28 packages. One failure arises
because the package requires macOS. This package fails on with NPM as well on our test system.
There are 18 cases where we kill the Z3 solver after a 10 minute timeout, but NPM succeeds.

3They are peerDependencies that aren’t necessary to build the project. However, NPM attempts to solve for them, even when
--omit-peer is specified.

0.000.250.500.751.000100200300Additional time taken with MinNPM (s)Percentage of packages0.000.250.500.751.0005101520Additional time taken with MinNPM (s)Percentage of packagesDependency Solvers à la Carte

1:19

7.1.2 Performance. On the packages that MinNPM (using NPM-style consistency) succeeds, we
compare its performance to NPM. Figure 7a is an empirical CDF of the amount of additional time
(in seconds) that MinNPM takes to solve dependencies on these packages. In a few outlier cases,
MinNPM takes up to 329s extra time, but only 2.6s more on average than NPM, and 1.6s more at
the median. Figure 7b shows an empirical CDF of the slowdown, but with outliers (> 20s) removed.
A significant portion of these two seconds is the time it takes to serialize the query from MinNPM
(JavaScript) to PacSolve, start PacSolve (Racket), and communicate with the solver (Z3). Rosette
relies on Racket, and allows us to prototype PacSolve, but this step could be eliminated in a
re-implementation that is focused on performance.

In addition, for a production tool, one could easily implement a variant which attempts to use
MinNPM first, and after some timeout (perhaps 30 seconds), reverts to a greedy solver which looses
optimality. Such a hypothetical tool is beyond the scope of this paper, but based on this performance
evaluation, would still provide the benefits of MinNPM to the vast majority of packages.

7.2 Empirical Evaluation of Package Manager Design Choices

7.2.1 The Effects of Consistency Semantics. NPM freely allows multiple versions of a package to
be co-installed which ensures that dependency solving cannot fail when two dependencies have
conflicting constraints (Section 2). When such a scenario occurs, NPM happily loads two versions
of the same dependency to avoid the conflict. However, this approach has its shortcomings. It is
obvious that it can lead to code bloat. But, more subtle errors can occur when two versions of the
same dependency need to communicate or share state. We can configure MinNPM to use either:
(1) NPM-style consistency, (2) a strictly PIP-style consistency model, which disallows multiple
versions of the same dependency, or (3) Cargo’s in-between consistency model, which allows
non-SemVer compatible versions to be co-installed.

Table 1 also lists failures for MinNPM in configurations using PIP and Cargo style consistency.
With NPM-consistency, no packages fail to due unsatisfiable constraints, as expected. However,
with PIP-style consistency, 19 packages (1.9%) produce unsatisfiable constraints, indicating that
they require co-installation of multiple versions in order to find a solution. In the middle, only 3
packages (0.3%) are unsolvable using Cargo’s consistency semantics. This indicates that across the
ecosystem, the requirement to depend on multiple versions of a package is heavily dominated by
needing different major versions, e.g. version 2.*.* and 3.*.*, rather than on different minor
versions. In addition, this indicates that Cargo can potentially partially reap the benefits of stricter
consistency, while avoiding most of the conflicts that occur with PIP.

Whether or not 19 more failures out of 1,000 packages is too many or negligible could be argued
either way. Instead, let’s examine a package that succeeds with NPM-style consistency, but fails
with PIP-style consistency.

Fixing a failure. The package terser@5.9.0 is a widely used JavaScript parser that fails with PIP-
style consistency. The package directly depends on version 0.7.𝑥 of source-map and version 0.5.𝑦 of
source-map-support. However, source-map-support depends on version 0.6.𝑧 of source-map.
This forces terser to include two versions of source-map: 0.7.𝑥 and 0.6.𝑧. This is an example
of a case that is unsatisfiable with PIP-style consistency, but would be allowed with Cargo-style
consistency. The ideal fix is to upgrade source-map-support to support 0.7.𝑥 of source-map,
which will allow terser to include only one version of source-map.

7.2.2 The Need for Cyclic Solutions. Some package managers (such as Cargo), disallow any cyclic
dependencies, while others (such as NPM) are happy to allow cycles. Comparing MinNPM when
configured to allow or disallow cycles (Table 1) reveals that out of 1,000 packages, zero packages

1:20

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

require cycles to find a solution. Even though the NPM ecosystem allows programmers to make
use of cycles, it appears that programmers rarely (never in this dataset) rely on this feature.

7.3 Can MinNPM Find More Optimal Solutions than NPM?

NPM uses a greedy algorithm that prefers newer versions of a dependency. In contrast, MinNPM is
configurable with a variety of objectives, including minimizing the total oldness of dependencies,
and the total number of dependencies. We now compare NPM to MinNPM with these two objectives,
in this order.
7.3.1 Minimizing Oldness. We define the oldness of a package version (old (𝑝, 𝑣)) as a function that
assigns the newest version the value 0, the oldest version the value 1, and other versions on a linear
scale in between. Given a solution graph we calculate its mean oldness:

𝑂 ((𝑁𝑅, 𝐷𝑅)) = {old (𝑛dst) | 𝑛src ∈ 𝑁𝑅, 𝑛dst ∈ 𝐷𝑅 (𝑛src)}
The metric is slightly different from the oldness minimization objective in MinNPM in two ways:
this metric counts multiple uses of the same package version, and takes the mean rather than sum.
This metric is more natural to interpret, as it gives the average oldness of dependencies, weighted
by how often those dependencies are depended upon.

(8)

Figure 8a shows a point for every package, with its mean oldness for NPM and MinNPM as the
𝑥 and 𝑦 coordinates. Points along the main diagonal (𝑦 = 𝑥) are packages whose dependencies are
just as old with both NPM and MinNPM. 14% of points excluding packages with zero dependencies
are below the diagonal and 5% are above the diagonal, which indicates that MinNPM produces
newer dependencies on average. This also provides evidence that programmers do in fact make use
of NPM’s flexible version constraints in practice, as otherwise MinNPM would not be able to find
better solutions.

An example of successful oldness minimization is the class-utils package (18M downloads).
MinNPM chooses a slightly older version of a direct dependency, which allows it to chose much
newer versions of transitive dependencies.

7.3.2 Minimizing the Number of Dependencies. Another objective function in MinNPM minimizes
the total number of dependencies. However, this objective must be used with care: older versions of
a package can have fewer dependencies, which can incentivize MinNPM to choose older versions! It
is best to combine this objective with another, which MinNPM supports by using either prioritized
objectives or linear combinations of objectives.

First, we analyze MinNPM configured to minimize total number of dependencies at the highest
priority, and total oldness second. The red line of Figure 8b shows an ECDF, where the 𝑥-axis
shows the fraction of dependencies with MinNPM instead of NPM, excluding packages with
zero dependencies. Thus for about 21% of packages, MinNPM is able to reduce the number of
dependencies. For the same set of packages, the total disk space required shrinks significantly
(Figure 8c). A quarter of the packages require 82% less disk space with MinNPM.

But what is the effect on dependency oldness? Figure 8d shows a scatterplot similar to Figure 8a,
but with the configuration of minimizing size first. While more points fall above the line, the loss is
not so severe: MinNPM produced older dependencies for 20% of the cases, and newer dependencies
for 7% of the cases. The increase in oldness is only moderate overall because MinNPM must still
choose new enough versions that satisfy programmer constraints. The additional oldness is in effect
bounded below by programmers’ version constraints.

An example of dependency size minimization is the assert package (13.5M downloads). For 3
direct dependencies, MinNPM chooses slightly older versions (same major and minor version),
which collectively eliminate 33 of 43 transitive dependencies.

Dependency Solvers à la Carte

1:21

(a) MinNPM is configured to minimize oldness
and the number of dependencies (in that order).
Each point represents a package, and those below
the line have newer dependencies, by the metric
in Equation (8). Overall, MinNPM finds newer
versions for dependencies.

(b) A CDF of the fraction of dependencies com-
pared to NPM, when MinNPM is configured
to a) minimize dependencies then oldness (red
CDF), or b) minimize oldness then dependencies
(blue CDF). MinNPM can reduce dependencies
in about 21% of packages.

(c) A CDF of the ratio of disk space of packages
solved using MinNPM (configured to minimize
number of dependencies, then oldness) vs NPM.
MinNPM can reduce space required.

(d) A scatterplot showing oldness of packages
solved with NPM compared to MinNPM, config-
ured to minimize number of dependenices first,
and then oldness. Oldness increases with 20% and
decreases with 7% of packages.

Fig. 8. Comparing NPM’s to MinNPM’s solution quality. These plots ignore failures in both solvers and have
MinNPM configured to use NPM-style consistency and allow cycles.

0.000.250.500.751.000.000.250.500.751.00Oldness with NPMOldness when minimizing oldness0.000.250.500.751.000.000.250.500.751.00Fraction of dependenciesPercentange of packagesMin DepsMin Oldness0.000.250.500.751.000.00.51.01.5Fraction of size on diskPercentage of packages0.000.250.500.751.000.000.250.500.751.00Oldness with NPMOldness when minimizing # dependencies1:22

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

Second, we consider MinNPM when configured to minimize total oldness at the highest priority,
and total number of dependencies second. In this case, MinNPM still manages to find smaller
solutions than NPM overall. The blue line of Figure 8b shows the empirical CDF for the fraction
of dependencies produced by MinNPM when prioritizing oldness minimization. For about 7% of
packages (excluding those with zero dependencies), MinNPM is able to reduce the number of
dependencies. While the shrinking effect is less than when prioritizing size minimization, we do
still achieve a modest reduction in size even when prioritizing oldness minimization.

8 RELATED WORK

Van der Hoek et al. first discussed the idea of “software release management” [Van Der Hoek
et al. 1997] for large numbers of independent packages in 1997, and the first package managers
for Linux distributions emerged at around the same time [Ewing and Troan 1995; Gunthorpe
1998]. The version selection problem was first shown to be NP-complete and encoded as a SAT
and Constraint Programming (CP) problem by Di Cosmo et al. [Di Cosmo 2005; Mancinelli et al.
2006] in 2005. This early work led to the Mancoosi project, which developed the idea of a modular
package manager with customizable solvers [Abate et al. 2012, 2013]. This work centers around the
Common Upgradeability Description Format (CUDF), an input format that can be generated by
package manager front-ends to describe a given upgradeability scenario to a back-end solver.

CUDF facilitated the development of solver implementations using Mixed-Integer Linear Pro-
gramming, Boolean Optimization, and Answer Set Programming [Argelich et al. 2010; Gebser et al.
2011a; Michel and Rueher 2010], and many modern Linux distributions have adopted CUDF-like
approaches [Abate et al. 2020]. OPIUM [Tucker et al. 2007] examined the use of ILP with weights
to minimize the number of bytes downloaded or the total number of packages installed.

While package managers have their roots in Linux distributions, they have evolved considerably
since the early days. Modern language ecosystems have evolved their own package managers [car
2014; Bicking 2011; Schlueter 2009; Weizenbaum 2018], with solver requirements distinct from
those of a traditional Linux distribution. Distribution package managers typically manage only
a single, global installation of each package, while language package managers are geared more
towards programmers and allow multiple installations of the same software package.

For the most part, language ecosystems have avoided using complete solvers. There are a number
of reasons for this. Solvers are complex, and they have a steep learning curve. Even on the Linux
distribution side, so-called functional Linux distributions [Courtès and Wurmus 2015; Dolstra
et al. 2004] eschew solving altogether, opting instead to focus on reproducibile configurations
maintained by humans. Most programmers do not know how to use solvers effectively, and fast,
high-quality solver implementations do not exist for new and especially interpreted languages.
Moreover, package managers are now fundamental to software ecosystems, and most language
communities prefer to write and maintain their core tooling in their own langage.

Despite this, developers are starting to realize the need for completeness and well defined depen-
dency resolution semantics [Abate et al. 2020]. The Python community, plagued by inconsistencies
in resolutions done by PIP has recently switched to a new resolver with a proper solver [Python
Software Foundation 2020]. Dart now uses a custom CDCL SAT solver called PubGrub [Weizenbaum
2018], and Rust’s Cargo [car 2014] package manager is moving towards this approach [pub 2020].
However, these solvers use ad-hoc techniques baked into the implementations to produce desirable
solutions, such as exploring package versions sorted by version number. These are not guaranteed
to be optimal, and it is unclear how to add or modify objectives to these types of solvers. In contrast,
PacSolve allows for a declarative specification of multiple prioritized optimization objectives

Solvers themselves are becoming more accessible through tools like Rosette [Torlak and Bodik
2013], which makes features of the Z3 [De Moura and Bjørner 2008] SMT solver accessible within

Dependency Solvers à la Carte

1:23

regular Racket [Felleisen et al. 2015] code. Spack [Gamblin et al. 2015] makes complex constraints
available in a Python DSL, and implements their semantics using Answer Set Programming [Gam-
blin 2020; Gebser et al. 2011b]. APT is moving towards using Z3 to implement more sophisticated
dependency semantics [Klode 2021].

The goal of our work is to further separate concerns away from package manager developers.
PacSolve focuses on consistency criteria and formalizes the guarantees that can be offered by
package solvers. NPM [Schlueter 2009]’s tree-based solver avoids the use of an NP-complete solver
by allowing multiple, potentially inconsistent versions of the same package in a tree. Tools like
Yarn [Yarn 2022] attempt to improve on this with post-hoc techniques like hoisting [Maier 2021] that
deduplicate the dependency graph after solving. However, they still do not guarantee consistent
semantics. PacSolve provides the best of all these worlds. It combines the flexibility of multi-version
resolution algorithms with the guarantees of complete package solvers, and it guarantees a minimal
dependency graph.

9 CONCLUSION

We present PacSolve, a semantics of dependency solving that we use to highlight the essential
features and differences between NPM, PIP, and Cargo. We use PacSolve to implement MinNPM, a
drop-in replacement for NPM that allows the user to customize dependency solving with a variety
of global objectives and consistency criteria. We use MinNPM to conduct an empirical evaluation
of dependency solving for the top 1,000 packages in the NPM ecosystem. We find that MinNPM
produces solutions with fewer dependencies and newer dependencies for many packages. For future
work, we hope to use PacSolve to build new dependency solvers for other package managers as
well.

REFERENCES

2014. Cargo: The Rust package manager. Online. https://github.com/rust-lang/cargo.
2020. PubGrub version solving algorithm implemented in Rust. Online. https://github.com/pubgrub-rs/pubgrub.
Pietro Abate, Roberto Di Cosmo, Georgios Gousios, and Stefano Zacchiroli. 2020. Dependency Solving Is Still Hard, but We
Are Getting Better at It. In 2020 IEEE 27th International Conference on Software Analysis, Evolution and Reengineering
(SANER). IEEE, 547–551.

Pietro Abate, Roberto Di Cosmo, Ralf Treinen, and Stefano Zacchiroli. 2012. Dependency solving: a separate concern in

component evolution management. Journal of Systems and Software 85, 10 (2012), 2228–2240.

Pietro Abate, Roberto Di Cosmo, Ralf Treinen, and Stefano Zacchiroli. 2013. A modular package manager architecture.
Information and Software Technology 55, 2 (2013), 459 – 474. https://doi.org/10.1016/j.infsof.2012.09.002 Special Section:
Component-Based Software Engineering (CBSE), 2011.

Josep Argelich, Daniel Le Berre, Inês Lynce, João P. Marques Silva, and Pascal Rapicault. 2010. Solving Linux Upgradeability
Problems Using Boolean Optimization. In Proceedings First International Workshop on Logics for Component Configuration,
LoCoCo 2010, Edinburgh, UK, 10th July 2010 (EPTCS, Vol. 29), Inês Lynce and Ralf Treinen (Eds.). 11–22. https://doi.org/
10.4204/EPTCS.29.2

Andrei Behel. 2020. GitHub Issue: React 17 support. https://github.com/atlassian/react-beautiful-dnd/issues/1993.
Ian Bicking. 2011. pip: Package Install tool for Python. github.com/pypa/pip.
Manfred Broy and Martin Wirsing. 1981. On the algebraic specification of nondeterministic programming languages. In

Colloquium on Trees in Algebra and Programming. Springer, 162–179.

Cargo 2022. The Cargo Book: Renaming Dependencies in cargo.toml. https://doc.rust-lang.org/cargo/reference/specifying-

dependencies.html#renaming-dependencies-in-cargotoml.

Nick Coghlan. 2013.

PEP 440 – Version Identification and Dependency Specification.

Online.

https://www.python.org/dev/peps/pep-0440.

Ludovic Courtès and Ricardo Wurmus. 2015. Reproducible and User-Controlled Software Environments in HPC with Guix.
In 2nd International Workshop on Reproducibility in Parallel Computing (RepPar). Vienne, Austria. https://hal.inria.fr/hal-
01161771

Leonardo De Moura and Nikolaj Bjørner. 2008. Z3: An efficient SMT solver. In International conference on Tools and

Algorithms for the Construction and Analysis of Systems. Springer, 337–340.

1:24

Donald Pinckney, Federico Cassano, Arjun Guha, Massimiliano Culpo, and Todd Gamblin

Roberto Di Cosmo. 2005. EDOS deliverable WP2-D2.1: Report on Formal Management of Software Dependencies. Technical

Report. INRIA. hal-00697463.

Eelco Dolstra, Merijn de Jonge, and Eelco Visser. 2004. Nix: A Safe and Policy-Free System for Software Deployment. In
Proceedings of the 18th Large Installation System Administration Conference (LISA XVIII) (Atlanta, GA) (LISA ’04). USENIX
Association, Berkeley, CA, USA, 79–92.

Marc Ewing and Erik Troan. 1995. RPM Timeline. Online. https://rpm.org/timeline.html.
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi, Eli Barzilay, Jay McCarthy, and Sam
Tobin-Hochstadt. 2015. The racket manifesto. In 1st Summit on Advances in Programming Languages (SNAPL 2015).
Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.

Todd Gamblin. 2020. Spack’s new Concretizer: Dependency solving is more than just SAT!. In Free and Open source Software

Developers’ European Meeting (FOSDEM’20). Brussels, Belgium.

Todd Gamblin, Matthew P. LeGendre, Michael R. Collette, Gregory L. Lee, Adam Moody, Bronis R. de Supinski, and W. Scott
Futral. 2015. The Spack Package Manager: Bringing order to HPC software chaos. In Supercomputing 2015 (SC’15). Austin,
Texas. LLNL-CONF-669890.

Martin Gebser, Roland Kaminski, and Torsten Schaub. 2011a. aspcud: A Linux Package Configuration Tool Based on Answer

Set Programming. Electronic Proceedings in Theoretical Computer Science 65 (Aug 2011), 12–25.

Martin Gebser, Benjamin Kaufmann, Roland Kaminski, Max Ostrowski, Torsten Schaub, and Marius Schneider. 2011b.

Potassco: The Potsdam answer set solving collection. AI Communications 24, 2 (2011), 107–124.
Jason Gunthorpe. 1998. APT User’s Guide. Online. https://www.debian.org/doc/manuals/apt-guide/.
Julian Andres Klode. 2021. APT Z3 Solver Basics. Online. https://blog.jak-linux.org/2021/11/21/apt-z3-solver-basics/.
Michael Kutz. 2019. Legit but Useless:Maven Version Ranges Explained. https://michakutz.medium.com/legit-but-useless-

maven-version-ranges-explained-d4ba66ac654.

Thilo Maier. 2021. A guide to understanding how Yarn hoists dependencies and handles conflicting packages. Online.
https://maier.tech/posts/a-guide-to-understanding-how-yarn-hoists-dependencies-and-handles-conflicting-packages.
F. Mancinelli, J. Boender, R. di Cosmo, J. Vouillon, B. Durak, X. Leroy, and R. Treinen. 2006. Managing the Complexity
of Large Free and Open Source Package-Based Software Distributions. In 21st IEEE/ACM International Conference on
Automated Software Engineering (ASE’06). 199–208.

Claude Michel and Michel Rueher. 2010. Handling software upgradeability problems with MILP solvers. In Proceedings
First International Workshop on Logics for Component Configuration, LoCoCo 2010, Edinburgh, UK, 10th July 2010 (EPTCS,
Vol. 29), Inês Lynce and Ralf Treinen (Eds.). 1–10. https://doi.org/10.4204/EPTCS.29.1

NPM. 2022. semver(1) – The semantic versioner for npm. https://github.com/npm/node-semver.
Python Software Foundation. 2020. New pip resolver to roll out this year. Online. https://pyfound.blogspot.com/2020/03/new-

pip-resolver-to-roll-out-this-year.html.

Isaac Z. Schlueter. 2009. NPM. Online. https://github.com/npm/npm.
Emina Torlak and Rastislav Bodik. 2013. Growing Solver-Aided Languages with Rosette. In Proceedings of the 2013 ACM
International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software (Indianapolis, Indiana,
USA) (Onward! 2013). Association for Computing Machinery, New York, NY, USA, 135–152. https://doi.org/10.1145/
2509578.2509586

Emina Torlak and Rastislav Bodik. 2014. A Lightweight Symbolic Virtual Machine for Solver-Aided Host Languages.
Chris Tucker, David Shuffelton, Ranjit Jhala, and Sorin Lerner. 2007. OPIUM: Optimal Package Install/Uninstall Manager.
In Proceedings of the 29th International Conference on Software Engineering (ICSE ’07). IEEE Computer Society, USA,
178–188.

Andre Van Der Hoek, Richard S Hall, Dennis Heimbigner, and Alexander L Wolf. 1997. Software release management. ACM

SIGSOFT Software Engineering Notes 22, 6 (1997), 159–175.

Natalie Weizenbaum. 2018. PubGrub: Next-Generation Version Solving. https://medium.com/@nex3/pubgrub-2fb6470504f.
Yarn 2022. Yarn: Yet Another Resource Negotiator (Javascript package manager). https://github.com/yarnpkg/yarn.

