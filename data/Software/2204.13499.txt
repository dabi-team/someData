2
2
0
2

r
p
A
8
2

]

R
C
.
s
c
[

1
v
9
9
4
3
1
.
4
0
2
2
:
v
i
X
r
a

FieldFuzz: Enabling vulnerability discovery in Industrial Control Systems
supply chain using stateful system-level fuzzing

Andrei Bytes1, Prashant Hari Narayan Rajput2, Michail Maniatakos3, and Jianying Zhou1

1Singapore University of Technology and Design
2NYU Tandon School of Engineering
3New York University Abu Dhabi

Abstract

With the advent of the fourth industrial revolution, Pro-
grammable Logic Controllers (PLCs) used as ﬁeld de-
vices, have been growing in their sophistication, offer-
ing extensive smart features, such as remote connectiv-
ity, support for standardized cryptography, and visual-
ization. Such computational platforms incorporate com-
ponents from various sources (vendor, platform provider,
open-source), bringing along their associated vulnerabil-
ities. This, combined with the increase in reliance on the
Industrial Internet of Things (IIoT) devices for automa-
tion and feedback, has opened previously airtight net-
works to remote attacks. Furthermore, modern PLCs of-
ten employ commodity software such as Linux on ARM,
further expanding the threat surface towards traditional
vulnerabilities. Security analysis of Operational Tech-
nology (OT) software, speciﬁcally, the control runtime
and IEC applications, remains relatively unexplored due
In this work, we implement
to its proprietary nature.
FieldFuzz, a methodology for discovering supply chain
vulnerabilities in every PLC component using stateful
black-box fuzzing without the requirement of a real de-
vice. FieldFuzz has been built using the Codesys v3 pro-
tocol, making it applicable to at least 80 industrial de-
vice vendors ranging from over 400 devices. Fuzzing
campaigns uncovered multiple vulnerabilities, leading to
three reported CVE IDs. To study the cross-platform ap-
plicability of FieldFuzz, we reproduce the ﬁndings on a
diverse set of Industrial Control System (ICS) devices,
showing a signiﬁcant improvement over the state-of-the-
art.

1

Introduction

Industrial Control Systems (ICS) is a collective term to
describe devices used to regulate automated industrial
processes. Critical infrastructure such as desalination
plants, smart grids, transportation systems, and the nu-

clear sector utilize ICS devices to control critical phys-
ical processes. Today, ICS devices and their associated
protocols are used in almost every industrial sector and
critical infrastructure. However, due to the increased re-
liance on such devices, a security vulnerability open to
exploitation can devastatingly impact human lives and
physical property.

The OT sector has been the target of several high-
proﬁle cyber attacks in the past. For instance, the 2016
attack on the Ukraine power grid, initiated with a suc-
cessful spear-phishing campaign and resulted in several
outages for approximately three hours [25]. Likewise, it
is also possible to attack the industrial control logic that
runs a physical process in critical infrastructure, studied
in literature at the source code level [44].

The control program (implemented with IEC 61131-3
programming language) runs an industrial physical pro-
cess by receiving inputs from sensors, performing arith-
metic operations, and sending output to actuators on a
ﬁeld device: the programmable logic controller (PLC),
executing cyclically. Modiﬁcation attacks against such
IEC binaries have been explored in [34] and [30] where
the authors reverse engineered the process structure and
operation to generate unsafe behavior by directly chang-
ing the variables. The Stuxnet incident also involved the
modiﬁcation of the PLC control logic, which acted as a
timebomb and scheduled sending malicious packets to
the controllers of the centrifuges of a nuclear fuel reﬁne-
ment system.

The Integrated Development Environments (IDEs),
compilers, program structure, and operation of these IEC
binaries have traditionally been a proprietary secret for
manufacturers. However, with the more uniform na-
ture of the ﬁeld devices and their growing computation
power, many device vendors are switching to generic
frameworks for both the device runtime and the engineer-
ing workstation by white-labeling. One of such Origi-
nal Equipment Manufacturer (OEM) generic frameworks
is the Codesys runtime, which is at the heart of ≈80

 
 
 
 
 
 
control applications. To the best of our knowledge,
ICSFuzz [47] is the only reported tool in literature for
fuzzing control applications. However, it suffers from
signiﬁcant drawbacks, such as losses in input delivery
synchronization, manual crash monitoring, and the re-
quirement of a physical device.

In order to create a uniﬁed approach for vulnerabil-
ity discovery throughout the PLC computational stack, in
this work, we propose FieldFuzz, a framework capable of
stateful fuzzing all PLC components, including the IEC
applications. FieldFuzz enables complete stateful control
over the execution of the IEC application binary, permit-
ting reliable and fast input delivery mechanism and scal-
able fuzzing by spawning virtual machines (VMs) due to
the lack of requirement to have a physical PLC. Further-
more, FieldFuzz also allows stateful fuzzing of critical
PLC components that are reachable by the network pack-
ets. This uncovered multiple vulnerabilities that were
disclosed to corresponding device vendors. Currently,
three CVE IDs have been assigned to vulnerabilities dis-
covered by FieldFuzz1.

In summary, our main contributions are the following:
1. We develop a driver to partially replicate the com-
munication between the IDE and the PLC runtime,
enabling the functionality needed to accurately apply
our fuzzing methodology over the network.

fuzzing campaigns.

2. Armed with the driver, we perform runtime system-
level
Our methodology is
fast, cross-architecture, and non-intrusive, enabling
fuzzing for both IEC 61131-3 control applications and
the runtime components, independent of the target
platform and device vendor.

3. We demonstrate improvement over the state-of-the-
art with higher performance, reliable scan cycle con-
trol,
input delivery, monitoring, breakpoint-based
coverage feedback, and no requirement to have a
physical device.

4. We discover three previously unknown vulnerabilities
and disclose them to the affected vendors with the
corresponding Common Vulnerability and Exposure
Identiﬁers (CVE IDs) assigned.

2 Related Work

Protocol fuzzing.
There is a considerable amount
of work on fuzzing network protocols. For instance,
AFLNET, a greybox fuzzer fed with a mutated corpus
of recorded network messages utilizing state-feedback
for guiding the fuzzer [42] and KiF for fuzzing session
In addition, Pulsar is a stateful
initiation protocol [3].

1The three CVE IDs assigned at the time of submission. We have
asked the numbering authority and the vendor to anonymize the credits
during the review phase.

Figure 1: Device manufacturers implement system com-
ponents represented by black boxes. In addition, a di-
verse set of organizations implement other communica-
tion, security, generic components, and IEC libraries.

industrial device vendors ranging over 400 devices, in-
cluding manufacturers such as Schneider Automation,
Bosch Rexroth, Wago, and Hitachi Europe [19]. Thus,
the transition to generic OEM runtime frameworks is ex-
pected to increase, as evident by the growing popularity
of Codesys. Authors in [47] estimate that currently, ac-
tive Codesys devices occupy a minimum of ≈20% of the
active PLCs worldwide.

At the same time, generic frameworks also allow
seamless inclusion of “smart” features to the ICS de-
vices, such as encrypted remote communication (by in-
cluding OpenSSL), advanced visualization capabilities
(by including web server support for engineers to con-
nect to the PLC through HTTP), database support (by
including SQLite), and more. Since a wealth of mature
open-source packages exist for these features, the ven-
dors can opt to integrate them into their environment in-
stead of developing their own version. This, however,
creates a supply chain risk, as the ﬁnal runtime is a col-
lection of components from various sources, as depicted
in Fig. 1: Components can be developed by Codesys, by
the vendor themselves, or can be adopted open-source
libraries. This mix of component sources further exacer-
bates the PLC security problem.

The restrictive proprietary nature of the automation
software for ICS and vendor-speciﬁc IEC application bi-
nary format and speciﬁcation is reﬂected in limited secu-
rity research on the topic. The published works in the do-
main utilize behavior modeling [4, 37, 35, 51, 50], gen-
eration of safety and security speciﬁcations [26, 6, 49],
and security veriﬁcation with model checking or theo-
rem proving [5, 38, 43]. Symbolic execution on a high-
level representation of the bytecode has also been pro-
posed [9, 21].

On the other hand, due to a lack of information on
execution control by the runtime and its real-time con-
straints, fuzzing remains relatively unexplored for IEC

2

SysFileSysMemSysComSysSocketSysTaskSysEventSysGraphic…SystemCmpOpenSSLCmpCryptMD5CmpX509CertSecurityOEMI/O DriverStandardI/O DriverApplicationOEM ComponentOEM ComponentOEM ComponentCmpCodemeterBlockDriverXXXCmpOPCUAServerCmpOPCUAClientCmpCAAFileCmpCAASerialComCommunicationComponentsIECLibrariesIIoTMQTTAzureMySQLHTTPOSCATblack-box fuzzing testing technique for proprietary net-
work protocols utilizing automatic protocol reverse en-
gineering and simulation [18]. There are ICS network
protocol-speciﬁc solutions such as Peach*, a coverage-
based improvement over the standard Peach fuzzer [33].
PropFuzz, which, unlike traditional fuzzing approaches,
monitors the behavior of the controller along with the
network connection to detect unexpectedly long jitters in
the control process [39]. Polar utilizes static analysis and
dynamic taint analysis to identify vulnerable operations
with semantic aware mutation to improve the fuzzing
procedure [32]. Finally, ICS3Fuzzer is a framework
for discovering implementation bugs on the supervisory
software by fuzzing the network communication proto-
col employed to communicate with the ﬁeld devices. It
synchronizes the controls of the GUI operation and net-
work communications to fuzz the entire supervisory soft-
It should be noted that ICS3Fuzzer fuzzes the
ware.
supervisor software by using the network communica-
tion protocol and is not concerned with fuzzing PLC de-
vices [14]. While FieldFuzz can also do protocol fuzzing
(as ICS communication is also a component), it focuses
on vulnerability discovery of any component integrated
into the PLC.
Control application security. Research on IEC applica-
tion binary focuses primarily on their safety veriﬁcation.
For instance, Canet et al. employ formal semantics for
Instruction List language deﬁned in IEC 61131-3 stan-
dard with a model checking tool to verify rich behaviors
and properties of PLC programs [8]. Other approaches
detect malicious inputs to the PLC by verifying against
temporal safety properties [16] and monitoring violation
against given speciﬁcation for runtime components [27].
In VetPLC, Zhang et al. utilize static analysis for creating
timed event graphs combined with invariant data traces to
detect hidden safety violations [50]. Guo et al. propose
an automated PLC control application testing software
that translates PLC source into C and performs symbolic
execution to generate test cases [21]. On the other hand,
AttkFinder uses information ﬂow-guided symbolic exe-
cution on an intermediate representation of PLC code to
detect attack vectors automatically [9]. Keliris et al. re-
verse engineered Codesys v2.3 ﬁle format for IEC appli-
cation binary to propose an automated on-the-ﬂy attack
formulation [30]. Similarly, CLIK automatically mod-
iﬁes control logic executing on a PLC and sends false
data to the engineering software using captured network
trafﬁc [29].

The closest work on directly fuzzing industrial bina-
ries is ICSFuzz [47], a fuzzing framework for PLC ap-
plications and system functions of the runtime. It sup-
plies inputs to the IEC binary by overwriting the value
at the memory-mapped GPIO, relayed to the runtime via
the KBUS subsystem. ICSFuzz patches the NOP instruc-

tions in the compiled control application code to obtain
coverage feedback. It detects multiple crashes for a syn-
thetic IEC application binary dataset and a limited sub-
set of runtime functions. However, it has speciﬁc limita-
tions:

• ICSFuzz utilizes the KBUS subsystem for input deliv-
ery to the control application, necessitating the use of
a physical WAGO PLC, making it non-scalable.

• Due to the loss of synchronization with the scan cycle
of the control application, ICSFuzz periodically drops
fuzzing inputs and is, consequently, slow.

• ICSFuzz lacks automation for observing the state of
the control program and involves manual crash moni-
toring.

• ICSFuzz also performs limited stateless fuzzing of the
shared library functions of the Codesys runtime on
WAGO PLC, discovering some crashes. However,
due to the stateless and out-of-context nature of the
fuzzing, it misses vulnerabilities requiring execution
context of the runtime.

FieldFuzz addresses all the above limitations as its
methodology is generic and IEC application fuzzing is
just an instance of component fuzzing, as was the case
with protocol fuzzing discussed earlier.

3 Preliminaries

3.1 Problem Formulation

The problem we address can be stated as follows: Can
fuzzing be used to uncover vulnerabilities in a PLC com-
putational stack efﬁciently? Fuzzing the PLC stack is a
challenging task for the following reasons:
• PLC runtimes are typically closed-source proprietary
software, thus fuzzing has to be performed in a black-
box manner or using extensive reverse engineering.
• PLC ﬁrmware rehosting is very challenging with some
recent efforts only achieving partial rehosting [11, 28].
At the same time, symbolic execution is also challeng-
ing, given the complexity of the ﬁrmware blob. There-
fore, comprehensive and accurate PLC fuzzing would
require actual hardware.

• The PLC runtime runs as a root process (on some plat-
forms, as a kernel module) and can be seen as a system-
on-a-system since it takes over signiﬁcant hardware re-
sources (timers, I/Os, etc.) to ensure its real-time oper-
ation. Controlling it can be as challenging as control-
ling a full-blown operating system.

• PLCs execute binaries developed in IEC 61131-3
programming languages that differ signiﬁcantly from
traditional software development languages, such as
C/C++/Java.

• IEC application binaries do not follow the known ex-

3

Table 1: Increasing number of Codesys CVEs [36].

Year
# CVEs

2011
4

2012
7

2013
1

2014
3

2015
3

2017
2

2018
6

2019
14

2020
5

2021
35

ecutable format (ELF or PE) thus fuzzing them has to
be done in a system-level context when the PLC run-
time loads and executes them. This adds an additional
layer that needs to be controlled in order to fuzz the
IEC binary.
At the same time, the increase in the occurrences
of traditional vulnerabilities in IEC applications follows
the evolution of the support of advanced external li-
braries. For instance, Codesys allows integrating ex-
ternal C modules with the IEC application [20], bring-
ing with it associated vulnerabilities such as buffer over-
ﬂows: CVE-2021-30188, CVE-2021-33485, also evi-
dent in the increase in the number of CVEs over the
year as shown in Table 1. As an example, consider
CVE-2020-6081 which exploits code execution vulner-
ability in PLC TASK functionality of Codesys runtime
triggerable by a specially crafted network
3.5.14.30,
packet, enabling remote code execution. Furthermore,
the runtime is also vulnerable to other classical vul-
nerabilities like out-of-bounds read (CVE-2021-30194),
write (CVE-2021-30193), NULL pointer dereference
(CVE-2021-29241), and more.

3.2 Threat Model

We assume that a ﬁeld device (PLC) operates in an in-
dustrial setting for regulating a physical process and con-
nects to the industrial control network enabling program
loading, monitoring, and access for the process engi-
neer through a Human Machine Interface (HMI). This
PLC receives input from connected sensors and exe-
cutes its control logic to determine the appropriate ac-
tion, communicated to an actuator for regulating a phys-
ical process. A knowledgeable adversary can compro-
mise an ICS node to monitor, intercept and modify net-
work communication to other critical devices, essentially
performing a man-in-the-middle (MITM) attack. There
are real-world instances of MITM, such as Stuxnet [31]
and IRONGATE [24]. Other similar research work such
as TCP veto [22] and CLIK [29] employ the same as-
sumption.

The adversary can deliver malicious input to the target

PLC through various approaches, such as:
• Compromising a sensor that provides input to the PLC,

explored in [48].

• Intercepting and modifying network communication
with the HMI terminal, which can allow data modi-
ﬁcation in the program [30] while supplying false data
to the HMI.

• A malicious insider can also manipulate and force new
input values to the PLC by leveraging an unsupervised
HMI terminal [13].

• Modiﬁcations to the ﬁrmware can also enable stealthy

manipulation of the inputs to the PLC [2].
Such attacks can crash the IEC application binary or
the control runtime leading to a Denial of Service (DoS)
attack [30]. They can further employ remote code exe-
cution (RCE) vulnerability to install malicious ﬁrmware,
control applications, and more [7]. The attacker can re-
motely exploit vulnerabilities in either the control appli-
cation or the runtime for the attack.

3.3

IEC 61131-3 Program Development

Process engineers develop the process control logic using
IEC 61131-3 compliant IDE running on an engineering
workstation. The compiled IEC binary is downloaded to
the PLC, and the PLC runtime handles the loading and
execution of the binary while also ensuring the real-time
constraints. The IDE can communicate with the PLC
runtime to enable debugging and monitoring of the IEC
binary execution.

IEC 61131-3 is a standard that encompasses ev-
erything concerning software architecture and sup-
ported languages for programming a PLC, including the
speciﬁcs on syntax, semantics, data types, variable at-
tributes, conﬁguration, and more. IEC 61131-3 deﬁnes
ﬁve types of programming languages for implementing
PLC logic: 1) Ladder Diagram (LD), 2) Structured Text
(ST), 3) Function Block Diagram (FBD), 4) Sequential
Function Chart (SFC), and 5) Instruction List (IL). LD,
FBD, and SFC are graphical diagram-based, whereas ST
is a high-level textual language, syntactically resembling
Pascal.
It should be noted that IL was deprecated in
2013 [46].

While certain ICS platforms interpret the intermediate
representation of the control program, others employ an
IEC compiler to produce a control binary. The IEC bina-
ries differ from known executable formats such as ELF
or PE and cannot execute independently. Therefore, they
are loaded and executed in the context of the ICS run-
time, which controls every aspect of its execution.

3.4 Codesys Environment

Codesys is a multi-platform software that includes the
development system and the runtime for target ICS de-
vices. The Codesys Development System allows the de-
velopment of control programs executed by the target de-
vice that runs Codesys Runtime. The runtime is a col-
lection of components with a modular architecture im-
plemented as statically compiled and dynamically linked
libraries necessary [1]. Components are integrated from

4

various sources, such as Codesys itself, the device ven-
dor, or open-source libraries. A Component Manager is
responsible for launching and initializing all other com-
ponents.

4 FieldFuzz Runtime Driver (FRD)

In order to enable stateful system-level fuzzing, in this
work, we have developed a runtime driver which enables
the functionality needed to support our fuzzing sessions.
The FieldFuzz Runtime Driver (FRD) is implemented as
a Python library and is the cornerstone of FieldFuzz. The
key capabilities of the FRD are the following:

1. Setting up the runtime to be in a suitable system state;
2. Delivering the fuzzing inputs to runtime components

of choice;

3. Receiving feedback for crash monitoring and analy-

sis;

4. Enabling exploit development through provided tem-

plates and extended debugging capabilities.

FieldFuzz leverages the proprietary communication
protocol utilized by Codesys to communicate with the
runtime and enable fuzzing over the network. This pro-
tocol facilitates hierarchical device-to-device communi-
cation between the engineering software (IDE) and the
target devices (PLC, HMI touch panels, Gateways). The
ﬂexible nature of the protocol allows its routing in a sin-
gle industrial network with diverse segments of Ethernet,
CAN, Serial, Sercos, and other mediums. Without loss of
generality, FieldFuzz connects to ﬁeld devices with TCP
over Ethernet.

To gain sufﬁcient knowledge for the development of
the FRD, we developed a complete Wireshark dissector
for the Codesys v3 communication protocol, written in
Lua. Assisted by the parsing and ﬁltering capabilities of
the dissector on the trafﬁc captures, in combination with
manual reverse engineering of the Codesys runtime and
the information published in [40], we extracted all the in-
formation needed to develop the FRD. This also allowed
us to collect a corpus of valid interactions with compo-
nents and communication patterns required for stateful
fuzzing.

Table 2 presents a subset of commands associated with
chosen components of the runtime. These are crucial for
our fuzzing routines. The commands replicated by the
FRD are denoted in bold and marked according to their
utilization in different stages of our fuzzing methodol-
ogy. While these are the commands whose input format
is pre-programmed and known to FRD, we show later
in Section 7 that FRD allows interaction with any com-
ponent of choice that is reachable from the network by
specifying an ID tuple for routing and the corpus to pro-
duce the input.

Figure 2:
Codesys v3 Protocol used by FieldFuzz.

Important ﬁelds at different layers of the

4.1 System Initialization

The runtime utilizes a proprietary network stack that we
will refer to as the Codesys v3 protocol to facilitate net-
work communication between nodes2. The Codesys v3
network stack consists of four layers:
Block driver layer. The component (CmpBlkDrvTcp)
at this layer is responsible for communication over the
It processes 1 a magic number
physical interfaces.
for veriﬁcation and 2 the total number of bytes in the
packet: length. CmpBlkDrvTcp transfers the rest of the
packet to CmpRouter component of the Datagram layer.
Datagram layer. The CmpRouter component detects
Codesys nodes in the network and routes the packets.
Its RouterHandleData function parses the following
ﬁelds: 1 One byte magic number (0xc5) inserted by
CmpRouter, 2 hop info bit structure, 3 packet set-
tings, 4 service id identifying the destination service
(service ID of 1 and 2 for request and response, respec-
tively), 6 lengths ﬁeld, 7 address of the sender and
receiver, and ﬁnally the optional padding. In Fig. 2 the
value of the service id is 0x40, so the packet is for-
warded to the CmpChannelManager component in the
channel layer.
Channel layer. This layer employs CmpChannelMgr
which ensures synchronized communication, integrity
veriﬁcation and delivery acknowledgement. Fig. 2 shows
its ﬁelds: 1 speciﬁes certain commands (command id)
for the communication channel manager. A dedicated
Layer 3 channel must be open, kept alive and closed
for successful communication. The command id of 0x1
(BLK) indicates the transfer of data to the next layer,
0x2 is ACK, and 0x3 for KEEPALIVE. Next, 2 the
ﬂag ﬁeld, 3 channel id for identifying the open chan-
nel, 4 blk id is the ID of the current BLK message, 5
ack id is the ID of the previous ACK message, 6 re-
maining data size ﬁeld is the size of the expected data
remaining in the packet, and 7 is the checksum ﬁeld
with the CRC32 checksum for the remaining data.

2Detailed information about the network stack is available in [40].

5

1213245671324567132451324Block Driver LayerDatagram LayerChannel LayerService LayerTags0000080027a9efdf0a002700000508004500001000b074ca4000800693c6c0a83801c0a800203865e81f2ddc081b0712ec2445ee501800302013242c0000000117e888000000c56b0040404000432ddcc0a838652ddfac1ec001005083010181a8125101000001010000580000600000d8d3ef5655cd10001b00020031ea007097af4400000000000000019480008748008024b216111e55000000000000000000000090000003a8800000000200000005001b0000a015100002ea390600171009041b06000100b0000017080908170c090404000000Table 2: Commands associated with components of our interest at the service layer. In bold the commands replicated
by our FRD that are crucial for the fuzzing routines. Markings denote the fuzzing stage they are required: ‘ I ’:
Initialization, ‘ D ’: Input delivery, ‘ E ’: Execution control, ‘ M ’: Monitoring.

Cmp

]
1
0
x
0
[

e
c
i
v
e
D
p
m
C

p
p
A
p
m
C

]
2
0
x
0
[

Command
GetTargetIdentI,M
LoginI
LogoutI
SessionCreateI
ResetOrigin
EchoService
SetOperatingMode
GetOperatingMode
InteractiveLogin
RenameNode
LoginI
LogoutI

CreateApp

ID
0x01
0x02
0x03
0x0A
0x04
0x05
0x06
0x07
0x08
0x09
0x01
0x02

0x03

Cmp

]
2
0
x
0
[
p
p
A
p
m
C

Command
DeleteApp
Download
OnlineChange
DeviceDownload
CreateDevApp
StartI
Stop
ResetI,E
SetBP
ReadStatusM
DeleteBP
ReadCallStack

GetAreaOffset

ID
0x04
0x05
0x06
0x07
0x08
0x10
0x11
0x12
0x13
0x14
0x15
0x16

0x17

Cmp

]
2
0
x
0
[
p
p
A
p
m
C

Command
ReadAppListI,M
SetNextStatement
ReleaseForceList
UploadForceList
SingleCycleD
CreateBootProject
ReInitApp
ReadAppStateList
LoadBootApp
RegisterBootApp
CheckFileConsistency
ReadAppInfoI

DownloadCompact

0x30

Cmp

ID
0x18
0x19
0x20
0x21
0x22
0x23
0x24
0x25
0x26
0x27
0x28 CmpMonitor2
0x29

]
2
0
x
0
[
p
p
A
p
m
C

[0x1B]
CmpPlcShell
[0x11]

Command
ReadProjectInfo
DeﬁneFlow
ReadFlowValues
DownloadEncrypted
ReadAppContent
SaveRetains
RestoreRetains
GetAreaAddressD
LeaveExecpointsActive
ClaimExecpointsForApp
Read
WriteD

ExecuteM,E

ID
0x31
0x32
0x33
0x34
0x35
0x36
0x37
0x38
0x39
0x40
0x01
0x02

0x01

Service layer. This layer is responsible for querying
the requested service and transmitting the operating set-
tings. The message consists of: 1 protocol id, 2
header size, 3 service group refers to the ID of the
queried service. Runtime has a unique ID for each avail-
able service and identiﬁes the corresponding component
for processing the service request. 4 service id refers
to the commands available for a speciﬁc service, 5
session id identifying the session, content size, addi-
tional data, and protocol data.

The FRD initiates communication with the runtime
over the network using the described protocol. Typically,
the runtime listens on multiple ports for connection re-
quests (TCP 1217, 11740, and UDP 1740 to 1743). The
FRD opens a new channel using the Layer 4 commands
0x40 and 0xC3 and stores the channel ID. Depending on
the requested service layer command, there is a need for
establishing sessions in at least two layers for properly
sending the commands to the components: The Device
and the Application login stage. The FRD utilizes the
CmpDevice Login command to retrieve a device-level
session handle from the runtime, which the runtime asso-
ciates with the channel in its mapping tables. It retrieves
a list of loaded applications from CmpApp. Finally, if the
application is loaded on the PLC, the FRD opens a sec-
ond session via the CmpApp Login command to obtain the
application Session ID and its handle. Finally, it imple-
ments a keepalive mechanism to keep the channel active
despite the timeout imposed by the runtime.

4.2

Input Delivery

In literature, often bare-metal IO modules are utilized as
the primary communication method for PLCs [47, 17].
However, such an approach is not scalable and is often
speciﬁc to the model or series of the PLC. Another ap-
proach would be to utilize the Modbus protocol from
the Fieldbus family of network communication proto-

cols. Such an approach would require the project to
include the Modbus client object to receive read and
write commands, requiring explicit declarations of such
exports in the control project, not enabled by default.
Commonly, the HMI displays and modiﬁes inputs to a
program using the OPC Uniﬁed Architecture (OPC UA)
protocol. However, for Codesys, its support is not com-
piled into all distributions and requires a license veri-
ﬁed by CmpOPCUAProviderIecVarAccess component;
otherwise, it shuts down the OPC UA server in 2 hours.
For symbolic access, a global variable list has to be
mapped in the project implicitly. In this case, the opera-
tor workstation would be able to access chosen variables
by name, assisted with CmpIecVarAccess [12] compo-
nent.

The approaches mentioned above require explicit
modiﬁcation of the conﬁguration in the control project
to support speciﬁc Fieldbus protocols and symbolic vari-
ables. To address this problem, the FRD utilizes a uni-
versal approach and does not require modiﬁcation of the
project while enabling read and write to any variable re-
gardless of their type and visibility scope. It utilizes tags,
a nested binary structure to send requests, command pay-
loads, and replies to the service layer of the runtime.
Each tag starts with its ID: 1 tag id, which often corre-
sponds to the type of payload or status code, the tag size,
and the tag data, and some additional data. Fig. 2 shows
the tag ﬁelds for writing to a variable. 2 data size is the
size of the data to be written, 3 write value is the value
to be written and 4 write offset is the offset of the vari-
able from the start of the data section.

The FRD utilizes the following to deliver inputs to
components and the IEC application: First, the FRD uses
the (Service Group ID, Command ID) tuple to identify
the appropriate component for routing the input. Then,
using the recursive tag encoder algorithm [41], a binary
tag structure is built to place the value into a correspond-
ing ﬁeld, based on the corpus of pre-known Tag IDs and

6

Figure 3: FRD methodology for fuzzing IEC applications and the control runtime.

their value formats. The resulting binary structure is in-
cluded in the body of a Service Layer packet. Next, FRD
calculates a CRC32 checksum for this data, constructs a
packet header, and encapsulates it with all the remaining
layers (see Subsection 4.1). It then sends this data to the
runtime over the active channel. The Block Driver of the
runtime receives the packet, processes it, and passes it to
CmpSrv. This component parses the Service Group ID
from the packet header and routes the packet to the tar-
get component. Finally, the communication handler of
the target component performs sanity checks for the data
format and passes the input binary stream to the function
that implements the corresponding Command ID. This
process provides inputs to target components of choice,
enabling stateful component fuzzing.

However, delivering inputs to an IEC application in-
volves several additional routines. FRD achieves this by
performing the write operation over the network to the
IEC application memory segment. Typically, runtime
separates data and IEC code (as compiled instructions)
into separate memory segments, referred to as Area0 and
Area3, respectively. The FRD reads and writes variables
using relative offset addresses in the Area0 memory seg-
ment. For this, the FRD constructs short bytecode pro-
grams expected by the CmpMonitor2 component as in-
puts, using a set of 58 opcodes speciﬁc to the runtime.
The opcodes can read inputs from the interpreter stack
and receive up to 4 inline arguments, depending on the
syntax. To implement this routine of the FRD, we ex-
tract the opcode table from the reverse-engineered run-
time binary and map their names and format with the
decompiled OnlineManager.plugin.dll dynamic li-

brary loaded by the Codesys IDE on the operator work-
station. The interpreter performs various checks and re-
turns the status code in the ﬁrst byte of the tag 0x41,
such as wrong pointer (0x05), buffer overrun (0x08),
and more. The FRD detects a successful read operation
with the presence of tag 0x40 in the reply and 0x41 for a
failed attempt. In contrast, the write operation requires a
more complex bytecode program and returns no data in
the reply for a successful attempt. However, FRD is still
able to verify a write attempt in a similar manner by the
presence of the tag 0x41. The complete process is shown
in Figure 3.

4.3 Stateful Fuzzing

To facilitate stateful fuzzing, FRD maintains the state of
blk id and ack id counters required for generating valid
subsequent packet headers. It also stores the application
Session ID and its handle. Identifying known states is
essential for uncovering vulnerabilities since the compo-
nents of the runtime are interconnected such that they call
functions and access structures belonging to other com-
ponents of the runtime system. Furthermore, these com-
ponents expect commands in a speciﬁc sequence, which
cannot be easily uncovered by black-box fuzzing.
Command discovery. Typically, Service Group IDs (2
bytes) for the vendor-added components speciﬁc to a
runtime variant are within a dedicated range beginning
from 0x100. This range can be enumerated, along with
the Command IDs (2 bytes). Using the FRD, FieldFuzz
sequentially enumerates the 2 bytes of the Command ID
and reads the returned status code to determine existing

7

Codesys Development SystemBlock DriverCmpRouterCmpChannel ServerCmpSrvStatusCorpusMonitoringBytecode InterpreterBytecode PRGCmpMonitor2Area 0Area 3RAMSysMemIECSysTaskCmpAppSingleCycleReadStatusCmpCmpCmpCmdExecuteCodesys RuntimeApp_HandleCmp_IdCmd_IdMutateWriteSingleCycleCrashed?LogResetFuzzerSession_IdApp_Session_IdApp_HandleBlk_IdAck_IdChannel_IdMonitoringBytecode AssemblerTag BuilderCmdCmdCmdShell FwdFieldFuzz Runtime DriverFieldFuzzIEC Application FuzzingComponent FuzzingTable 3: The status codes used by FieldFuzz to uncover system states.

Status
Ok
Failed
Parameter
NotInitialized
Version
Timeout
NoBuffer
Pending
NumPending
NotImplemented
InvalidId

Status
Overﬂow
BufferSize
NoObject
NoMemory
Duplicate

ID
0x00
0x01
0x02
0x03
0x04
0x05 MemoryOverwrite
0x06
0x0A
0x0B
0x0C
0x0D

InvalidHandle
EndOfObject
NoChange
InvalidInterface
NotSupported

ID
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18

Status
NoAccessRights
OutOfLimits
EntriesRemaining
InvalidSessionId
Exception
SignatureMismatch
VersionMismatch
TypeMismatch
IdMismatch
OperationDenied
SecurityChecksFailed

Status
InvalidSequence
TooManyRetries
AlignmentError

ID
0x19
0x1A
0x1B
0x1C PasswordChangeRequired
0x1D
0x1E
0x1F
0x20
0x21
0x27
0x39

Reauthenticate
Relogin
NotReadyYet
ActivateUserMgt
NoUserMgmt
NetFailed
NetNotConnected

ID
0x3A
0x3D
0x3E
0x3F
0x40
0x41
0x45
0x46
0x47
0x100
0x101 AppBPBreakpointNotSet

Status
NetMsgSize
NetNoRoute
NetTimeout
NetPkgInvalid
NetProtocolid
L7TagMissing
L7UnknownCmdGrp
L7UnknownCmd
AppNotLoaded
AppNoSessionId

ID
0x102
0x103
0x104
0x105
0x106
0x300
0x301
0x302
0x504
0x505
0x50E

commands. Some of the commands validate the device-
level and application-level session, or both. The stan-
dard status codes indicate which commands do not exist
for the enumerated Service Group ID. We save the valid
tuples as component interfaces for fuzzing.
Status code extraction. The architecture patterns en-
forced by the runtime provide hints for identifying func-
tions related to the components in the reverse-engineered
runtime binary. Furthermore, each component follows a
speciﬁc programming pattern to be integrated with the
runtime, as mentioned below:
• It contains an entry function with a standard C
struct passed as the argument. One example of
such entry function for CmpMonitor2 component
is shown in Listing 1, which we renamed as
CmpMonitor2 Entry.

• Declares its internal ID (in this case 50, or 0x32 in hex)

and passes a string literal of its name to the CM.

• Calls standardized import and export functions that en-

able inter-component communication (Line 4-5).

• Handles standardized create, delete event hooks and a

version identiﬁer function (Line 6, 8, and 9).

• Subscribes for custom events sent by other components
using a pointer to an event handler function (Line 7).

int STATUS CmpMonitor2 Entry(INIT STRUCT *init)

1
2 {

init−>CmpId = 50;
init−>ExportFunctions = CmpMonitor2 Export;
init−>ImportFunctions = CmpMonitor2 Import;
init−>GetVersion = CmpMonitor2 CmpGetVersion;
init−>HookFunction = CmpMonitor2 Hook;
init−>CreateInstance = CmpMonitor2 Create;
init−>DeleteInstance = CmpMonitor2 Delete;
[..]
return 0;

3

4

5

6

7

8

9

10

11
12 }

Listing 1: Pseudocode for CmpMonitor2 Entry.

We parse the device description (devdesc) ﬁle that the
IDE uses to communicate with the runtime, a ﬁle spe-
ciﬁc to each runtime variant to extract the set of en-
abled components and their IDs. These internal iden-
tiﬁers differ from Service Group IDs that are mapped
to the components. Then, utilizing the runtime binary

and the knowledge of architecture patterns, we deploy
IDA Pro scripting to automate the process of extract-
ing status codes.
It begins by locating the component
entry function that ﬁlls in a standardized initialization
structure for the component to be fuzzed. This func-
tion passes the initialization structure to the Component
Manager for communication with the component. Next,
we identify the event handler function among other stan-
dard declarations in the initialization structure. This
function always consists of a lengthy conditional state-
ment that checks for generic runtime-wide event codes.
Then we iterate through the event conditions to locate
the call to ServiceRegisterServiceHandler func-
tion. The event code that registers the service handler
can differ, but according to our observations, it is tied
to events 0x03 or 0x06. The second argument passed
to ServiceRegisterServiceHandler is the pointer to
the service handler function of the component. The script
tracks the path to the function call, which implements
the given Command ID. Finally, we recursively extract
all return conditions from the nested calls as these con-
tain the status codes that are later returned by the service
layer, depending on the executed path, and provide it to
the FRD for implementing code coverage feedback.

Path discovery. As a code path coverage mechanism for
component functions, the FRD maintains the status code
sequence during the fuzzing session. Based on the status
code sequence changes resulting from mutated inputs, it
is possible to understand and differentiate the execution
path inside the component function. The status codes
differ as the fuzzing input traverses through the lower
network layers. Essentially, a different part of the target
function returns a different status code due to a change in
the execution path. Therefore, every time fuzzing uncov-
ers a new execution path (by observing the status code),
FieldFuzz adds it to the list of known states and initiates
a new fuzzing campaign.

Execution feedback. For feedback, FRD watches for
layers of
the status codes returned by the different
the Codesys v3 network protocol stack in hexadeci-
mal form, as shown in Figure 3. For example, a re-
ply with only Layer 4 status codes indicates a failure

8

Table 4: Components and their Service Groups utilized
at the service layer.

Component
CmpAlarmManager
CmpApp
CmpAppBP
CmpAppForce
CmpCodeMeter
CmpCoreDump
CmpDevice
CmpFileTransfer
CmpIecVarAccess
CmpIoMgr

ID
0x18
0x02
0x12
0x13
0x1D
0x1F
0x10
0x08
0x09
0x0B

Component
CmpLog
CmpMonitor
CmpMonitor2
CmpOpenSSL
CmpSettings
CmpTraceMgr
CmpUserMgr
CmpVisuServer
CmpPlcShell
SysEthernet

ID
0x05
0x03
0x1B
0x22
0x06
0x0F
0x0C
0x04
0x11
0x07

of the runtime after a crash caused by FieldFuzz. We dis-
able the system-wide address space layout randomization
(ASLR) on these virtualized nodes to simplify the crash
investigation.
Scalability options. It should be noted that the use of
an additional physical device here is optional. FieldFuzz
can utilize virtual machines, any number of which can
be deployed to scale the fuzzing setup. On the other
hand, another potential possibility to scale the experi-
ment in a single VM is to utilize the ability of the chan-
nel layer of the runtime to handle multiple channels si-
multaneously. The FRD could achieve this by remotely
increasing the maximum number of active channels that
CmpChannelServer supports. This can be performed
over the network with the SettgSetIntValue (0x02)
command offered by the CmpSettings (0x06) compo-
nent. However, this adds to the complexity of the crash
monitoring mechanism to distinguish the crashes of the
runtime caused by parallel threads. The ﬂexible nature
of the used protocol allows it to be routed in a single in-
dustrial network with mixed segments of Ethernet, CAN,
Serial, Sercos, and other mediums. The devices can route
the packets over the industrial network based on the hier-
archy and the destination address speciﬁed by the FRD.
In this way, once FieldFuzz connects to a physical de-
vice (PLC, industrial gateway, or touch panel) through
the FRD, it enters the entire industrial network. While
FRD uses TCP over Ethernet, depending on the desti-
nation in the packet, it can fuzz any node in the plant
by relaying the packets through other devices, including
the nodes of the network that are not reachable by Ether-
net, such as those connected by serial interface or CAN
bus. By putting the devices in different states, FieldFuzz
could potentially fuzz the interaction of the control logic
between devices in the particular stage of a process seg-
ment or the entire plant.
Identifying fuzzing targets. As discussed earlier, the
runtime is a collection of components (including the
component responsible for executing IEC binaries), so
fuzzing the runtime implies interaction with the com-
ponents responsible for its functionality. However, as
was mentioned in Section 3, despite the runtime having

Figure 4: Experimental setup for fuzzing IEC applica-
tions and control runtime.

to reach the Service Layer for processing. The sta-
tus codes can determine whether the command reached
the target function or failed due to the lack of authenti-
cation, wrong Command ID, or incorrect payload for-
mat. Table 3 presents a list of common status codes
returned by the runtime components. As was already
done for the monitoring opcode names, we ﬁnd the status
codes in a decompiled OnlineManager.plugin.dll
shared library of the Codesys IDE. Some of the im-
portant status codes are L7TagMissing (768/0x300),
L7UnknownCmdGrp (769/0x301), and L7UnknownCmd
In the case of a non-existing Service
(770/0x302).
Group ID and Command ID, the runtime returns the sta-
tus code for L7UnknownCmdGrp and L7UnknownCmd, re-
spectively. To retrieve the status of the execution of
the IEC application binary, FieldFuzz utilizes the FRD
to survey the CmpApp and CmpPlcShell components.
Upon exception, a core dump and crash log from CmpLog
are retrieved from the controller remotely for further in-
vestigation. To detect crashes of the runtime, FRD con-
stantly monitors the latency in the channel and the con-
sistency of the BLK counter.

4.4 FRD Exploit Development Capabilities

The FRD is also an essential tool for crash analysis, aid-
ing with exploit development. A list of these capabilities
offered by the FRD appears in the Appendix A.

5 FieldFuzz Fuzzing Campaigns

5.1 Fuzzing Setup

Fig. 4 shows the basic experimental setup for fuzzing the
Codesys runtime and IEC application binaries. We uti-
lize two virtual machines with CODESYS Control for
Linux variant of the runtime, which runs on the Intel
Xeon hypervisor server. The runtime includes a stan-
dard init.d wrapper that facilitates the automatic restart

9

Fuzzing TargetsFieldFuzzUbuntu VMIECAppUbuntuIntel XeonUbuntu VMCodesys Runtime[Linux SL] Codesys Runtime[Linux SL x64] TCPTCPFuzzerFieldFuzz Runtime DriverFuzzer NodeCallsTCPvFuzzing IEC ApplicationsFuzzing Codesys Runtimea single generic codebase, its actual builds can signiﬁ-
cantly vary based on the target architecture, vendor mod-
iﬁcations, and hardware platform constraints. Therefore,
the ﬁrst step is to create a complete list of all instanti-
ated components. To achieve that, we start by extract-
ing the interfaces of components reachable from the net-
work. The component interfaces are deﬁned as the tuple:
(Service Group, Command), for the components reach-
able from layer 7. First, we identify the runtime com-
ponents loaded by the particular runtime from the boot
log of the device and its device description ﬁle used by
the IDE. Next, we identify the Service Group IDs of the
loaded components. For the generic set of components
developed by Codesys, we get this information from the
decompiled libraries of the IDE and the captured net-
work communication, assisted with the dissector. Table
4 presents a subset of components that are present in our
target runtime variant.
Fuzzing inputs. To collect a dataset of valid inputs, we
trigger commands with the Codesys IDE and capture its
communication with the runtime to extract the Service
Layer payloads, assisted by the dissector. More specif-
ically, we aim to decode the nested binary tag struc-
ture, shown in Figure 3. We then save the tag IDs,
structure, valid payloads for each (Service Group, Com-
mand) tuple. Next, we determine the packet ﬁelds de-
rived from the session identiﬁer to identify the variant
ﬁelds as these need to be tracked for maintaining state
information. Finally, we save these inputs as seeds with
the identiﬁed format for the current runtime distribution.
After creating an initial corpus of input seeds, we uti-
lize python bindings [23] for libradamsa mutators ported
from AFL++ [15] to mutate the byte payload inside the
tags without mutating the tag ID and preserving the re-
maining structure of the corpus. FieldFuzz then utilizes
FRD to deliver the input to the appropriate component.

As a proof of concept, we run fuzzing campaigns on
functions of three common components: CmpTraceMgr,
CmpPlcShell, and CmpDevice. FieldFuzz was able to
uncover a variety of crashes, which we then analyzed,
focusing on uncovering vulnerabilities. For brevity, we
provide extensive discussion for one CVE, and discus-
sions about the other two appear in the Appendix A.

5.2 Fuzzing CmpTraceMgr Component

(CVE-2021-34604)

The CmpTraceMgr component consists of eight critical
operations triggered by the service layer commands in
sequence. This default component is available in most
It is a back-
full-featured distributions of the runtime.
end for the Trace Program Organization Unit (POU) ob-
ject added to the IEC project for recording and visual-
izing variable trends in the physical process. Here, the

recordAdd operation causes SEGFAULT for two reasons:
• As the command is sent out-of-order, the component
enters an unexpected state where it operates on a
pointer to a structure of a packet object that is never
correctly initialized.

• Instead, it performs the offset calculation into this non-
existent structure based on the value supplied by Field-
Fuzz. The attacker can inﬂuence the calculation by
controlling this offset, leading the runtime to perform
mov operation on an invalid memory address.

Setup. We employ the corpus extracted from the com-
munication between the Codesys IDE and the runtime
and pass it to FieldFuzz. The corpus comprises Layer
7 payloads with removed headers consisting of Service
Group ID and Command ID. FieldFuzz reuses the seeds
by reconstructing the header while ensuring the correct
length, checksum, and the desired Service Group and
Command pair.
Crash analysis. FieldFuzz reported a crash for Service
Group 0x0F, command 0x0D, and upon veriﬁcation, the
Command ID is in the range of valid commands for the
particular component 0x01 to 0x13, CmpTraceMgr. We
look deeper into the original pcap ﬁle used for creating
the seed input for understanding the structure of the input
causing the crash. Using our dissector with a ﬁlter ex-
pression, we determine that the recordAdd (0x0D) com-
mand consisting of 148 bytes payload causes the crash.
This payload incorporates three levels of nested binary
tags.
Reproducing the crash. To investigate the crash, we
use FRD to generate a standalone exploit from a template
that establishes a connection with a SoftPLC node sup-
porting full-featured debugging capabilities and sends
the Layer 7 payload to the remote device. To observe
critical runtime errors, we enable core dumps and dis-
able the error handling behavior of SysExcept. Gen-
erally, the SysExcept component of the runtime inter-
cepts POSIX signals from the runtime process for in-
ternal interpretation. We modify CODESYSControl.cfg
to disable the internal exception handler and instruct the
runtime to append the logs to a ﬁle with a permissive
log ﬁltering mask. To record the core dumps, we adjust
the ulimit and launch the runtime binary (codesyscon-
trol.bin) standalone outside its init.d service wrapper,
provided with a -d ﬂag for detailed logging.
Call stack. At least 12 functions handle the packet of
the network stack before it ﬁnally reaches the function
related to CmpSrv, which is the top component of the
network stack. Finally, CmpSrv calls an exported hook
function of the CmpTraceMgr, which acts as a handler for
all Layer 7 commands for the Service Group 0x0F. The
hook function extracts the Command ID from the packet
header and jumps into the condition based on command
0x0D. Functions imported from the CmpBinTagUtil

10

Table 5: Codesys runtime binaries for different targets.

Device
WAGO PFC200
BeagleBone Black
Linux SoftPLC
Raspberry Pi
SIMATIC IOT2000
emPC-A/iMX6
Windows RTE

Arch
arm32
arm32
x64
arm32
x32
arm32
x32

Size (MB)
4.6
5.8
9.7
5.5
6.4
6
103.9

Packed
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:55)
(cid:51)
(cid:51)

component parse the fuzzing input and ﬁnally decode
the 17 binary tags. Among these, a tag 0x40 is pro-
cessed, which was an injection point selected by Field-
Fuzz. It calculates a memory address offset based on the
extracted value. Consequently, in the command handler
function for the recordAdd command, a SIGSEGV occurs,
which is caused by a mov instruction attempting to access
the nonexistent memory address. This is the offset from
a structure that stores a tracing packet, derived from the
value supplied by FieldFuzz.
Status codes. The component changes its returned status
codes based on the multiple execution path conditions.
The recordAdd function does several sanity checks for
the supplied value. A reply containing the tag 0xFF7F
with a status code 0x02 was caused by the payloads in
tag 0x40 that are outside the expected range, such as
0x0 and 0xFFFFFFFF. This prevents the crash as the read
operation is not reached. Another state of the compo-
nent, indicated by the returned status code 0x11, nei-
ther causes a crash nor forms a successful trace packet
processing result.
In this case, the payload falls into
the allowed range and passes the entry checks of the
recordAdd function. The read operation is reached,
resulting in a handled exception due to returned empty
packet data.

This vulnerability has been reported to the vendor,

with the CVE-2021-34604 assigned.

6 Cross-Architecture Generalization

While the runtime has a single generic codebase,
speciﬁcs for each target platform and architecture are re-
ﬂected in different build variants. Thus, on platforms
driven by VxWorks real-time operating system (RTOS),
the entire Codesys runtime is shipped as a kernel mod-
ule. The embedded bare-metal variant of the runtime
has a much smaller set of components but implements
more complex system components to interact with the
hardware.
In more modern ICS devices powered by
RTLinux (such as WAGO Touch Panel 600 series or
WAGO PFC200 PLC), it runs as root in the userspace
and reuses resources provided by the OS such as net-
work sockets, timers, and ﬁle descriptors. As shown in
Table 5, the size of the runtime binaries varies across var-
ious architecture from 4.6 MB to 103.9 MB. One rea-

11

Figure 5: Experimental setup for cross-architecture vali-
dation of the fuzzing results.

components

son is that the shared libraries can be linked dynami-
cally or statically depending on the variant. The num-
ber of components also differs. Some of the binaries
are packed and involve license management and anti-
tampering mechanisms. Thus, the primary distribution
of our choice in this work (CODESYS Control for Linux
x64) employs a packing mechanism which we have re-
versed dynamically by dumping the memory segments
of the live process. The runtime variant for Windows de-
vices (CODESYS Control RTE x32), on the other hand,
includes custom renamed and encrypted sections. From
the section names and the protection function, we have
noticed that these are managed by CodeMeter protection
software from Wibu-Systems [45], which has also been
utilized by Siemens and Rockwell [10].
The most hardware-dependent

are
SysMem, SysSocket, and SysCom. At some point in the
execution path, other components rely on the exported
functions provided by these lower-level Sys components,
which can affect the behavior of the crashes. Therefore,
to assess the applicability of our ﬁndings, we test the
attacks against different runtime variants by employing
physical devices, as shown in Figure 5. We utilize a
replayer node that
initiates communication with the
Gateway. The latter forwards the communications to
multiple platforms in parallel.
In this case, the Intel
Xeon server acts both as a VM hypervisor and the
Gateway to Wago PFC200, Raspberry PI4, Odroid C2.
This setup enables FieldFuzz to quickly test the same
payload across multiple architectures and variants of
the runtime. We observe the differences in the behavior
of the crashes to adjust the input payload and port it
between architectures. As a proof of concept, we replay
the fuzzing inputs for crashing CmpTraceMgr compo-
nent (CVE-2021-34604), which is available on all of the
tested devices. As was shown in Figure 4, the original
payloads replicated here were detected by FieldFuzz in
a virtualized environment (with ASLR disabled). The
payload corresponding to the input is passed through
the tag 0x40 and is four bytes long. On an x86 system
with ASLR disabled, the crash input causes a SIGSEGV.

Field DevicesGateway ServerFieldFuzzUbuntuIntel XeonRinetdTCPTCPFuzzerFieldFuzz Runtime DriverFuzzer NodeCallsTCPLinuxCodesys Runtime[Linux ARM SL x64]Odroid C2TCPLinuxCodesys Runtime[RPi SL x32]Raspberry PiTCPLinuxCodesys Runtime x32PFC 200TCPTable 6: Performance comparison with ICSFuzz. Speed
for FieldFuzz is when using 1 VM; Speed for ICSFuzz is
when using 1 PLC.

Control
Applications

Execution Speed
(inputs/sec)

First Crash
(seconds)

First Crash
(inputs)

Crashes

-

FieldFuzz

FieldFuzz
x642
148
898
4566
999
22
17
281
43216 43530

FieldFuzz
[47]
A83
A81
15270 8289
290
12172
145
18216
26645
847
13441 22200 18105
10906 21723 16085
4373
17554 4447
25

[47]
[47]
FieldFuzz
x642 A83 A81
A83 A81
x642
A81
6
234
0.25
70.88 0.014
593
294.6
bf mcpy 1
188
1.43
22
642.4
286.4
64.2 0.071
bf mcpy 6
279 5124
7.08
645.6 66.06 21.34
244.6
bf mcpy 8
181
426
1.95
526.2 62.11 0.584
320.6
bf mcpy 12
8
208
0.04
560.6 64.56 0.027
223.3
bf mset 1
8
174
0.03
571.2 62.68 0.063
268.6
bf mset 3
2
254
0.56
68.8 0.008
503.2
289.3
bf mset 5
-
623
584.8 69.76
314.3
74.53
bf mset 9
1
176
660.2 64.63 0.025 0.005
291.6
bf mmove 1
1
159
63.1 0.008 0.003
578.2
245.3
bf mmove 4
1
229
66.31 0.007 0.005
573
bf mmove 7
232
92456 50643
-
182.14 783
508.2 64.53
bf mmove 12 257.3
-
3880
556
55
0.14
598.8 71.86 2.06
278
oob 1 arr 1
8085
14
103
1.39
591
308
oob 1 arr 6
77.03 0.027
155938 7326
-
105
273.8
571.2 69.78
284.6
oob 1 arr 9
-
207 3564 49165 27241
75.2 12.11 97.86
507
297.2
oob 1 arr 13
80080
-
520.8 73.53
298.6
oob 2 arr 1
8558
80662 22759
-
326.6
oob 2 arr 5
71.1
520.4
60384 13366
-
oob 2 arr 8
295.5 592.64 69.8
48694 13401
-
oob 2 arr 13 312.25 502.2 70.95
1. Codesys Control for BeagleBone (ARM)
2. Codesys Control for Linux (Intel) 3. Codesys Control for PFC100 (ARM)

0
11245 20006 16749
10070 20146 15165
15317 17010 14493
0
6121
5541
0
254
0
0
0
0

[47]
x642 A83
32
7876
21
2384
17
359
9
977
21
24
16
7
28
24
15
6
39
28
27
19
35
27
22
19

154.42 117
155.62 165
102.97 188
192
97.86

15
6291
6600
12
686
12
16
12
17

83
821

2
1
3

-
-
-
-

However, with ASLR enabled, replaying the same value
does not lead to a stable SIGSEGV because the resulting
offset in the recordAdd function in most of the trials
points to an unexpected but valid memory address. As a
result, the command function of the component returns
a status code (0x11), preventing the crash. On an x64
system, even enumerating the entire 4-byte range did
not cause a crash. Nevertheless, such runtime variants
accept longer payloads (eight bytes), eventually leading
to the crash. It should be noted that the payload behaves
identically on Intel and ARM, causing the crash on both
the VM and physical devices; it only differs between the
32 vs. 64 bit architecture of the target device.

7 Fuzzing IEC Application Binaries

Fuzzing of IEC application binaries is a special case of
component fuzzing since dedicated components control
the execution of these binaries. The compiled control
application runs in the thread spawned by the SysTask
component, which is not exported to the network and
thus cannot be inﬂuenced directly.
Instead, FieldFuzz
fuzzes the binary inside the runtime context by control-
ling its execution through the CmpApp component. The
latter offers complete control over start, stop, cold reset,
and single-cycle operations with the runtime. Table 2
shows the IDs of the corresponding commands replicated
for CmpApp.

To set up the experiment, FieldFuzz utilizes the FRD
to login into the device and start the control application.
Next, FieldFuzz takes over the execution control while
providing fuzzing inputs for every scan cycle. Since
FieldFuzz has control over the scan cycle, it does not
drop any inputs due to a lack of synchronization with the

12

scan cycle. Finally, based on the status feedback received
from the runtime, FieldFuzz logs the crash input.

To test the performance of FieldFuzz, we use the same
dataset of synthetic applications as was used for the eval-
uation of ICSFuzz [47]. It comprises of the control ap-
plications written in Structured Text that contain intro-
duced vulnerabilities in their called functions, such as
buffer overﬂows and out-of-bounds write. These vulner-
abilities exist due to missing bound checks in imported
IEC 61131 library functions. Thus, the family of syn-
thetic applications labeled in the dataset as bf mmove
can cause a buffer overﬂow under certain conditions
due to insufﬁcient buffer size validation before calling a
SysMemMove library function. Similar to the control ap-
plication itself, this library is written in Structured Text.
By looking deeper into its implementation in the run-
time, we observe that the backend for this library is pro-
vided by the SysMem component of the runtime and is
written in C. The call of this wrapper, initiated by the
IEC program, ends up in C code which triggers the na-
tive memmove function. For this reason, the crash in a
vulnerable IEC application not only causes the failure
of its thread but affects the entire runtime process (ex-
ecuted with root privileges). Out-of-bounds write vul-
nerabilities involve an uninitialized array with a variable
index manipulated to write at an arbitrary location. The
numbers in the names of the vulnerable application bi-
naries correlate with the complexity of the code. For in-
stance, bf mmove 1 is the simplest initialization of the
SysMemMove, while bf mmove 12 consists of multiple
loops and conditional branching statements.

Table 6 shows the results of fuzzing the IEC applica-
tion binary and its comparison with ICSFuzz. As the ta-
ble demonstrates, FieldFuzz on an average is ≈4.1x, and
≈8.3x faster for arm32 and x64 (Intel) runtime variants,
respectively, compared to ICSFuzz. The performance
advantage of FieldFuzz comes from the communication
protocol-based input delivery and complete control over
the scan cycle. On the other hand, ICSFuzz incurs high
latency and drops inputs during fuzzing when it misses
the scan input cycle of the runtime.

It should also be emphasized that the measurements in
Table 6 are taken for a single fuzzing instance for Field-
Fuzz. ICSFuzz requires a vendor-speciﬁc KBUS IO sub-
system for input delivery, bounding itself to a physical
device. Therefore ICSFuzz requires a physical device for
fuzzing, which limits its scalability. FieldFuzz can paral-
lelize fuzzing sessions by just spawning multiple VMs.

Furthermore, FieldFuzz detects considerably more
crashes than ICSFuzz, allowing it to cover a wider in-
put space. On average, it detects ≈291x, and ≈262x
more crashes for the arm32 and x64 runtime variants, re-
spectively, in the same 1 hour fuzzing period. However,
FieldFuzz detects fewer crashes for a select few samples

across both variants. As mentioned previously, low-level
System components are implemented differently across
various devices, resulting in different bugs and vulnera-
bilities. For example, in our 32 bit runtime variant, we
observe that the SysMem component prevented the run-
time from crashing for some samples and instead wrote
“Operation not permitted” in the logs.

8 Discussion

Security mitigations by the runtime. The latest run-
time version enables the User Management feature by
default, thwarting unauthorized login into the PLC. How-
ever, out-of-the-box credentials are default and commu-
nication is not encrypted, unless manually changed. The
runtime also expects the client to perform the Login
action with CmpDevice for establishing a session, but
this process does not involve actual authentication. Fur-
thermore, the security mitigation properties of the run-
time executable differ among platforms. For instance,
the Wago PFC200 controller that shipped with ﬁrmware
03.00.39(12) used in our setup contains the runtime that
is compiled without all of the typical exploit mitigations
(no Relocation Read-Only (RELRO), stack canary, NX
bit, or Position Independent Executable (PIE)). Finally,
the Monitoring Bytecode interpreter, which is involved
in extensive operations with the memory, applies its own
memory access checks. For each execution, before load-
ing the bytecode, the interpreter sets a canary to ensure
the integrity of the stack. However, we found that this ca-
nary has a ﬁxed value of 0x5AF096A5 regardless of the
target platform and architecture, which defeats its pur-
pose.
Challenges of black-box fuzzing. FieldFuzz does not
require access to the controller or any modiﬁcation, en-
suring the universality and scalability of the approach.
However, this incurs limited code coverage information.
We rely on the retrieved status codes to partially address
this for runtime components for understanding the exe-
cution path. We have found that the debugging capabil-
ities of the full-featured VM can emulate the functional-
ity of Layer 7 without requiring actual network transmis-
sion. This requires pre-loading a harness in the form of a
shared library into the runtime and hooking the authen-
tication and packet processing functions in the runtime
process. This approach builds a more traditional and
comprehensive fuzzing approach combined with full-
featured code coverage. However, in the context of ICS,
such a white-box fuzzing approach has substantial limi-
tations:

1. The compiled harness and fuzzing instance is tied
to one speciﬁc target platform (architecture), while
some vulnerabilities are platform-speciﬁc, reducing

the generalization of the approach.

2. This approach is possible with a SoftPLC build of the
runtime on top of a typical desktop-grade VM. How-
ever, real-world COTS devices hardly have such ex-
tensive debugging and instrumentation capabilities.
3. It is rare to have a full-featured shell to control the
device as many of the ICS devices embed the runtime
on top of legacy RTOS or use the bare-metal variation
of the runtime. Gaining the necessary capabilities for
white-box fuzzing requires re-ﬂashing the controller
with a modiﬁed kernel image and relying on remote
debugging.

As future work, we aim to explore the combination of
these methodologies to leverage the advantages of both,
providing a precise code coverage mechanism while pre-
serving the black-box beneﬁts of the FieldFuzz.

9 Conclusion

While the PLC ﬁrmware is becoming more modular, its
update still relies on its entire image delivery, which does
not aid frequent patching and allows many vulnerabili-
ties to remain undiscovered on deployed PLCs. Further-
more, since the runtime is generic and plays a crucial
role in industrial device ﬁrmware, potential vulnerabili-
ties can signiﬁcantly impact the OT sector. In this paper,
we present FieldFuzz - a fuzzing framework for control
programs and industrial runtime, capable of discovering
vulnerabilities in more than 400 known ICS devices from
80 industrial device vendors. We successfully fuzz the
Codesys runtime, reporting three CVE IDs and IEC ap-
plication binaries with a speedup of ≈4.1x and ≈8.3x
with the increased crash discovery of ≈291x and ≈262x
for 32 and 64 bit runtime variants, respectively. We per-
form fuzzing on both physical and virtualized ICS de-
vices to prove its automation capabilities, reliability, and
performance improvements against the current state-of-
the-art in this domain. With FieldFuzz, we provide re-
searchers with an open-source tool to enable future re-
search in this direction.

Published Tools

We release FieldFuzz, FieldFuzz Runtime Driver, the
Wireshark dissector
for Codesys v3 protocol and
the disassembler for bytecode programs used by the
CmpMonitor2 component as open source tools with this
work.

Reported CVE IDs

As a result of this work, we report CVE-2021-34604,
CVE-2022-22508, and CVE-2022-22507.

13

References

[1] CODESYS Runtime (Brochure), Aug 2021.

[Online; accessed

25. Aug. 2021].

[2] ABBASI, A., AND HASHEMI, M. Ghost in the plc designing an
undetectable programmable logic controller rootkit via pin con-
trol attack. Black Hat Europe 2016 (2016), 1–35.

[3] ABDELNUR, H. J., STATE, R., AND FESTOR, O. Kif: a stateful
sip fuzzer. In Proceedings of the 1st international Conference on
Principles, Systems and Applications of IP Telecommunications
(2007), pp. 47–56.

[4] ADIEGO, B. F., DARVAS, D., VI ˜NUELA, E. B., TOURNIER,
J.-C., BLIUDZE, S., BLECH, J. O., AND SU ´AREZ, V. M. G.
Applying model checking to industrial-sized plc programs. IEEE
Transactions on Industrial Informatics 11, 6 (2015), 1400–1410.

[5] BAUER, N., ENGELL, S., HUUCK, R., LOHMANN, S.,
LUKOSCHUS, B., REMELHE, M., AND STURSBERG, O. Ver-
iﬁcation of plc programs given as sequential function charts. In
Integration of software speciﬁcation techniques for applications
in Engineering. Springer, 2004, pp. 517–540.

[6] BIHA, S. O. A formal semantics of plc programs in coq. In 2011
IEEE 35th Annual Computer Software and Applications Confer-
ence (2011), IEEE, pp. 118–127.

[7] BOSCH. Vulnerabilities in codesys v2 runtime systems. [Online

; Accessed: November 2021].

[8] CANET, G., COUFFIN, S., LESAGE, J.-J., PETIT, A., AND SCH-
NOEBELEN, P. Towards the automatic veriﬁcation of plc pro-
In Smc 2000 conference pro-
grams written in instruction list.
ceedings. 2000 ieee international conference on systems, man
and cybernetics. ’cybernetics evolving to systems, humans, or-
ganizations, and their complex interactions’ (cat. no.0 (2000),
vol. 4, pp. 2449–2454 vol.4.

[9] CASTELLANOS, J. H., OCHOA, M., CARDENAS, A. A., AR-
DEN, O., AND ZHOU, J. Attkﬁnder: Discovering attack vectors
in plc programs using information ﬂow analysis. In 24th Inter-
national Symposium on Research in Attacks, Intrusions and De-
fenses (2021), pp. 235–250.

[10] CISA. CodeMeter US-Cert. [Online; accessed 20. Aug. 2021].

[11] CLEMENTS, A. A., GUSTAFSON, E., SCHARNOWSKI, T.,
GROSEN, P., FRITZ, D., KRUEGEL, C., VIGNA, G., BAGCHI,
S., AND PAYER, M. HALucinator: Firmware re-hosting through
In 29th USENIX Security Sympo-
abstraction layer emulation.
sium (USENIX Security 20) (Aug. 2020), USENIX Association,
pp. 1201–1218.

[12] CODESYS. CmpIecVarAccess Interface Description. [Online;

accessed 20. Aug. 2021].

[13] F-SECURE. F-secure’s guide to evil maid attacks. [Online ; Ac-

cessed: September 2021].

[14] FANG, D., SONG, Z., GUAN, L., LIU, P., PENG, A., CHENG,
K., ZHENG, Y., LIU, P., ZHU, H., AND SUN, L. Ics3fuzzer: A
framework for discovering protocol implementation bugs in ics
supervisory software by fuzzing. In Annual Computer Security
Applications Conference (New York, NY, USA, 2021), ACSAC,
Association for Computing Machinery, p. 849–860.

[15] FIORALDI, A., MAIER, D., EISSFELDT, H., AND HEUSE, M.
AFL++: Combining incremental steps of fuzzing research.
In
14th USENIX Workshop on Offensive Technologies (WOOT 20)
(Aug. 2020), USENIX Association.

[16] GARCIA, L., ZONOUZ, S., WEI, D., AND DE AGUIAR, L. P.
Detecting plc control corruption via on-device runtime veriﬁca-
tion. In 2016 Resilience Week (RWS) (2016), IEEE, pp. 67–72.

[17] GARCIA, L. A., BRASSER, F., CINTUGLU, M. H., SADEGHI,
A.-R., AND ZONOUZ, S. A. Hey, My Malware Knows Physics!
Attacking PLCs with Physical Model Aware Rootkit. Research-
Gate (Jan 2017).

[18] GASCON, H., WRESSNEGGER, C., YAMAGUCHI, F., ARP, D.,
AND RIECK, K. Pulsar: Stateful black-box fuzzing of proprietary
network protocols. In International Conference on Security and
Privacy in Communication Systems (2015), Springer, pp. 330–
347.

[19] GROUP, C. Codesys device directory.

[Online ; Accessed:

September 2021].

[20] GROUP, C. Integrating c modules. [Online ; Accessed: Septem-

ber 2021].

[21] GUO, S., WU, M., AND WANG, C. Symbolic execution of pro-
In Proceedings of the 2017
grammable logic controller code.
11th Joint Meeting on Foundations of Software Engineering (New
York, NY, USA, 2017), ESEC/FSE 2017, Association for Com-
puting Machinery, p. 326–336.

[22] HAGEN, J. T., AND MULLINS, B. E. Tcp veto: A novel network
attack and its application to scada protocols. In 2013 IEEE PES
Innovative Smart Grid Technologies Conference (ISGT) (2013),
pp. 1–6.

[23] HELIN, A. Python bindings for libradamsa. [Online ; Accessed:

January 2022].

[24] HOMAN, J., MCBRIDE, S., AND CALDWELL, R. Irongate ics
malware: Nothing to see here... masking malicious activity on
scada systems. FireEye threat research blog (2016).

[25] HUANG, B., CARDENAS, A. A., AND BALDICK, R. Not ev-
erything is dark and gloomy: Power grid protections against iot
demand attacks. In 28th USENIX Security Symposium (USENIX
Security 19) (Santa Clara, CA, Aug. 2019), USENIX Associa-
tion, pp. 1115–1132.

[26] HUANG, Y., BU, X., ZHU, G., YE, X., ZHU, X., AND SHI, J.
Kst: Executable formal semantics of iec 61131-3 structured text
for veriﬁcation. IEEE Access 7 (2019), 14593–14602.

[27] JANICKE, H., NICHOLSON, A., WEBBER, S., AND CAU, A.
Runtime-monitoring for industrial control systems. Electronics
4, 4 (2015), 995–1017.

[28] JOHNSON, E., BLAND, M., ZHU, Y., MASON, J., CHECK-
OWAY, S., SAVAGE, S., AND LEVCHENKO, K. Jetset: Targeted
ﬁrmware rehosting for embedded systems. In 30th USENIX Se-
curity Symposium (USENIX Security 21) (Aug. 2021), USENIX
Association, pp. 321–338.

[29] KALLE, S., AMEEN, N., YOO, H., AND AHMED, I. Clik on
plcs! attacking control logic with decompilation and virtual plc.
In Binary Analysis Research (BAR) Workshop, Network and Dis-
tributed System Security Symposium (NDSS) (2019).

[30] KELIRIS, A., AND MANIATAKOS, M. Icsref: A framework for
automated reverse engineering of industrial control systems bina-
ries. arXiv preprint arXiv:1812.03478 (2018).

[31] LANGNER, R. Stuxnet: Dissecting a cyberwarfare weapon. IEEE

Security & Privacy 9, 3 (2011), 49–51.

[32] LUO, Z., ZUO, F., JIANG, Y., GAO, J., JIAO, X., AND SUN,
J. Polar: Function code aware fuzz testing of ics protocol. ACM
Transactions on Embedded Computing Systems (TECS) 18, 5s
(2019), 1–22.

[33] LUO, Z., ZUO, F., SHEN, Y., JIAO, X., CHANG, W., AND
Ics protocol fuzzing: coverage guided packet crack
In 2020 57th ACM/IEEE Design Automation

JIANG, Y.
and generation.
Conference (DAC) (2020), IEEE, pp. 1–6.

[34] MCLAUGHLIN, S. E. On dynamic malware payloads aimed at

programmable logic controllers. In HotSec (2011).

14

[35] MCLAUGHLIN, S. E., ZONOUZ, S. A., POHLY, D. J., AND MC-
DANIEL, P. D. A trusted safety veriﬁer for process controller
code. In NDSS (2014), vol. 14.

[36] MITRE. Cve list. [Online ; Accessed: January 2022].

[37] NEWELL, J., PANG, L., TREMAINE, D., WASSYNG, A., AND
LAWFORD, M. Translation of iec 61131-3 function block dia-
grams to pvs for formal veriﬁcation with real-time nuclear appli-
cation. Journal of Automated Reasoning 60, 1 (2018), 63–84.

[38] NIANG, M., PHILIPPOT, A., GELLOT, F., COUPAT, R., RIERA,
B., AND LEFEBVRE, S. Formal veriﬁcation for validation of
pseel’s plc program. In ICINCO (1) (2017), pp. 567–574.

[39] NIEDERMAIER, M., FISCHER, F., AND VON BODISCO, A.
Propfuzz—an it-security fuzzing framework for proprietary ics
In 2017 International Conference on Applied Elec-
protocols.
tronics (AE) (2017), IEEE, pp. 1–4.

[40] NOCHVAY, A. Security research: CODESYS Runtime, a PLC
control framework. Part 1, Sep 2019. [Online; accessed 20. Aug.
2021].

[41] NOCHVAY, A. Security research: CODESYS Runtime, a PLC
control framework. Part 2, Sep 2019. [Online; accessed 20. Aug.
2021].

[42] PHAM, V.-T., B ¨OHME, M., AND ROYCHOUDHURY, A. Aﬂnet:
a greybox fuzzer for network protocols. In 2020 IEEE 13th In-
ternational Conference on Software Testing, Validation and Veri-
ﬁcation (ICST) (2020), IEEE, pp. 460–465.

[43] RAWLINGS, B. C., WASSICK, J. M., AND YDSTIE, B. E. Ap-
plication of formal veriﬁcation and falsiﬁcation to large-scale
chemical plant automation systems. Computers & Chemical En-
gineering 114 (2018), 211–220.

[44] SERHANE, A., RAAD, M., RAAD, R., AND SUSILO, W. Plc
code-level vulnerabilities. In 2018 International Conference on
Computer and Applications (ICCA) (2018), pp. 348–352.

[45] SYSTEMS, W. CodeMeter from Wibu-Systems.

[Online; ac-

cessed 20. Aug. 2021].

[46] TIEGELKAMP, M., AND JOHN, K.-H. IEC 61131-3: Program-

ming industrial automation systems. Springer, 2010.

[47] TYCHALAS, D., BENKRAOUDA, H., AND MANIATAKOS, M.
Icsfuzz: Manipulating i/os and repurposing binary code to en-
In 30th
able instrumented fuzzing in ICS control applications.
USENIX Security Symposium (USENIX Security 21) (Aug. 2021),
USENIX Association, pp. 2847–2862.

[48] URBINA, D., GIRALDO, J., TIPPENHAUER, N. O., AND CAR-
DENAS, A. Attacking ﬁeldbus communications in ics: Applica-
tions to the swat testbed. In Proceedings of the Singapore Cyber-
Security Conference (SG-CRC) 2016 (2016), IOS Press, pp. 75–
89.

[49] XIE, Y., CHANG, R., AND JIANG, L. A malware detection
method using satisﬁability modulo theory model checking for the
programmable logic controller system. Concurrency and Com-
putation: Practice and Experience (2020), e5724.

[50] ZHANG, M., CHEN, C.-Y., KAO, B.-C., QAMSANE, Y., SHAO,
Y., LIN, Y., SHI, E., MOHAN, S., BARTON, K., MOYNE, J.,
AND MAO, Z. M. Towards automated safety vetting of plc code
in real-world plants. In 2019 IEEE Symposium on Security and
Privacy (SP) (2019), pp. 522–538.

[51] ZONOUZ, S., RRUSHI, J., AND MCLAUGHLIN, S. Detecting
industrial control malware using automated plc code analytics.
IEEE Security & Privacy 12, 6 (2014), 40–47.

A Appendix

A.1 FRD Exploit Development Capabili-

ties

The FRD is also an essential tool for crash analysis, aid-
ing exploit development. Speciﬁcally, it provides the fol-
lowing capabilities to the security analyst:
Interaction with each layer. During the exploit de-
bugging, it is common for some packets to cause errors
which prevent them from entirely being processed by the
runtime network stack. As a result, such packets fail to
reach the service layer and are rejected by the Channel
Server or Router for various reasons. To address this, the
FRD allows investigating such cases by interacting with
each layer and gradually testing the packet processing.
Wireshark dissector. The full-featured dissector for
Codesys v3 protocol enables the use of Wireshark with
advanced ﬁlter expressions and custom columns for ev-
ery aspect of the Codesys v3 stack. Based on the gained
knowledge in this work, we provide it with symbols to
translate the packet data into human-readable compo-
nents, command, and ﬁeld names. Despite the imple-
mentation in Lua, the resulting performance is adequate
for handling live capture sessions between FieldFuzz and
the target device for long periods. The dissector signiﬁ-
cantly streamlines the process of input corpus collection,
crash investigation, and exploit development.
Binary tag encoder. An interactive binary tag encoder
of the FRD allows to conveniently parse and craft the
binary tag payloads and display them in a readable form.
It is used in conjunction with the Wireshark dissector,
which pastes values from a packet ﬁeld to the encoder.
The latter allows its recursive printing, modiﬁcation, and
re-encoding in place.
Exploit generation. FRD provides multiple single-ﬁle
standalone exploit templates which embed the compact
implementation of a communication routine. These are
minimal features required to establish a connection and
send a payload to the components. We use these to gener-
ate standalone proof-of-concept exploits for the crashes
found in Section 7 that do not require the FRD.
Remote memory dumps. A handy feature of the FRD is
obtaining the hexdumps of the PLC memory regions via
the network. This is implemented by requesting CmpApp
(GetAreaAddress) and CmpPlcShell (Execute 0x1). To
avoid reply fragmentation while retrieving a long hex-
dump, FRD splits the requested address range and in-
stead requests 128-byte chunks.
Retrieving runtime logs.
Speciﬁc components of
the runtime use a standard logger to append messages
grouped into categories through an exported interface
which is part of CmpLog. The default behavior of the
runtime is to rotate the log buffer in a dedicated region

15

It can also perform diag-
revision and system load.
nosis of the device by sending string commands of a
particular format. An adversary can trigger Segmenta-
tion Fault, crashing all the runtime threads by sending a
specially crafted payload from the Codesys v3 network
stack. The vulnerability was reported to the vendor, and
CVE-2022-22508 was assigned.

The main command body is passed inside tag 0x10,
while an additional tag 0x12 is required by some com-
mands for handling the arguments. FieldFuzz detects
the crash for the tag 0x12 because the runtime performs
a memory read operation outside valid memory bound-
aries. By sending a sequence of packets, it is possible
to force the runtime to perform memory access opera-
tions and enumerate the valid address range with the off-
set increments. As the offset grows in each operation by
an internal loop, an unhandled SIGSEGV occurs once the
operation exceeds valid memory boundaries, crashing all
the runtime threads.

of the controller memory. The FRD can request logs
from this buffer by implementing LoggerList 0x03 and
GetEntries 0x01 commands of CmpLog, to scan for
exceptions, observe events and errors, or query invari-
ant runtime ﬁelds such as application name logged by
CmpApp.

A.2 Fuzzing

CmpDevice

Component

(CVE-2022-22508)

CmpDevice is an essential component responsible for
authentication and network discovery of the PLC. It
uses the SetNodeName (0x09) command for changing
an identiﬁcation string employed for in-network discov-
ery and initiating a connection with the PLC. A specially
crafted packet sent to the runtime prevents the IDE from
communicating with the PLC, resulting in a connection
error. Moreover, this issue is persistent even across re-
boot because the payload from the network packet ends
up in a persistent conﬁguration ﬁle of the runtime and
keeps restoring upon device boot. The vulnerability was
reported to the vendor, and CVE-2022-22508 was as-
signed.

The runtime becomes unresponsive due to a spe-
cially crafted packet sent to the Service Group 0x01
(CmpDevice), command 0x09 (SetNodeName) and the
tag 0x58 with a long bytestring consisting of non-
printable characters as Layer 7 payload. This crafted
bytestring is not sanitized properly by CmpDevice be-
fore passing it
to the local SysTarget component
(which might be vendor-speciﬁc, we tested with ofﬁ-
cial Codesys distributions) and then stored permanently
in the NodeNameUnicode property ﬁeld. The device is
not accessible even after a reboot. This is appended
to CODESYSControl.cfg conﬁguration ﬁle as a new
record. CmpSettings processes this ﬁle which is then
consumed by SysTarget. The connecting client at-
tempts to perform device discovery through Layer 4 and
calls CmpDevice again to perform GetTargetIdent,
and CreateSession commands. The system log mes-
sages suggest that CmpNameServiceServer processes
the bytestring, which is a Layer 4 component that exports
its functions to CmpRouter and implements a Codesys-
speciﬁc naming system protocol [40]. Consequently, the
device fails to respond to further scan requests and sev-
eral exceptions by the dynamic libraries of the Codesys
IDE. A manual remove of the SysTarget section from
the runtime conﬁguration ﬁle restores the operational
state of the device, after a reboot.

A.3 Fuzzing CmpPlcShell Component

(CVE-2022-22507)

CmpPlcShell is a default built-in component
that
fetches information from the device, such as ﬁrmware

16

