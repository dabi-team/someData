WebRobot: Web Robotic Process Automation using
Interactive Programming-by-Demonstration

Rui Dong
University of Michigan, USA

Zhicheng Huang
University of Michigan, USA

Ian Iong Lam
University of Michigan, USA

Yan Chen
University of Toronto, Canada

Xinyu Wang
University of Michigan, USA

Abstract

It is imperative to democratize robotic process automation
(RPA), as RPA has become a main driver of the digital trans-
formation but is still technically very demanding to construct,
especially for non-experts. In this paper, we study how to
automate an important class of RPA tasks, dubbed web RPA,
which are concerned with constructing software bots that au-
tomate interactions across data and a web browser. Our main
contributions are twofold. First, we develop a formal foun-
dation which allows semantically reasoning about web RPA
programs and formulate its synthesis problem in a principled
manner. Second, we propose a web RPA program synthesis
algorithm based on a new idea called speculative rewriting.
This leads to a novel speculate-and-validate methodology in
the context of rewrite-based program synthesis, which has
also shown to be both theoretically simple and practically
efficient for synthesizing programs from demonstrations. We
have built these ideas in a new interactive synthesizer called
WebRobot and evaluate it on 76 web RPA benchmarks. Our
results show that WebRobot automated a majority of them
effectively. Furthermore, we show that WebRobot compares
favorably with a conventional rewrite-based synthesis base-
line implemented using egg. Finally, we conduct a small user
study demonstrating WebRobot is also usable.

CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí Auto-
matic programming.

Keywords: Program Synthesis, Programming by Demonstra-
tion, Rewrite-based Synthesis, Robotic Process Automation,
Web Automation, Human-in-the-Loop

2
2
0
2

y
a
M
1
1

]
L
P
.
s
c
[

3
v
3
9
9
9
0
.
3
0
2
2
:
v
i
X
r
a

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear
this notice and the full citation on the first page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior specific permission and/or a fee. Request
permissions from permissions@acm.org.
PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9265-5/22/06. . . $15.00
https://doi.org/10.1145/3519939.3523711

ACM Reference Format:
Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu
Wang. 2022. WebRobot: Web Robotic Process Automation using
Interactive Programming-by-Demonstration. In Proceedings of the
43rd ACM SIGPLAN International Conference on Programming Lan-
guage Design and Implementation (PLDI ‚Äô22), June 13‚Äì17, 2022, San
Diego, CA, USA. ACM, New York, NY, USA, 16 pages. https://doi.
org/10.1145/3519939.3523711

1 Introduction

Robotic process automation (RPA) is a software technology
that aims to streamline the process of creating software robots
that emulate user interactions with digital applications such
as web browsers and spreadsheets [3, 5, 9, 25, 34, 35, 62, 65].
These robots are essentially programs: like humans, they can
perform tasks such as entering data, completing keystrokes,
navigating across pages, extracting data, etc. However, they,
once programmed, can perform tasks much faster with fewer
mistakes. Therefore, RPA has the potential to significantly
simplify business workflows and improve the productivity
for both organizations and individuals [7]. Gartner predicted
that RPA will remain the fastest-growing software market
in the next several years [50].

While RPA has become a main driver of the digital trans-
formation, it is still technically very demanding to construct
automation programs, and consequently, not everyone can
build software robots that suit their needs. For instance, it is
estimated that 3-7% of tasks deemed important by an organi-
zation have been automated, whereas a long tail of more than
40% of individual-driven tasks yet are still to be automated [7].
These tasks represent a high percentage of automation op-
portunities to scale RPA to individual non-expert end-users.
Web RPA. How to democratize RPA in order to foster its
adoption among non-experts is a broad, new but increasingly
important problem. In this paper, we consider an important
subset of RPA tasks, dubbed web RPA, and investigate how
to automate this class of tasks. As illustrated in Figure 1, web
RPA involves interactions between data and a web browser.
For example, it involves programmatically entering data (in
a semi-structured format), extracting data from webpages, as
well as navigating across multiple webpages. Conceptually,
web RPA is close to web/browser automation, where the key
distinction is that RPA emphasizes interactions across/within
applications, while browser automation has to do with web

 
 
 
 
 
 
PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

Figure 1. Illustration of web RPA.

Figure 2. A real-world web RPA problem from UiPath.

browsers. In other words, one can view web RPA as the ‚Äúin-
tersection‚Äù of RPA and web automation; hence the name.1
Let us consider a real-world scenario (shown in Figure 2)
from a recent webinar [6] by UiPath, a leading RPA company.
In this example, a manager working for a unicorn adoption
agency wanted to test a hypothesis that sending follow-up
emails with their unicorn names to customers would increase
the adoption rate. Unfortunately, the customer relationship
management system is disconnected from the web-based uni-
corn name generator. In other words, there is no easy way
to automatically generate a unicorn name for each customer.
The manager tried to seek help from the IT but was told that
creating an automation program for this job is expensive un-
less there is a provably sufficient return on it. In the end, they
had to manually perform this experiment: export customer
information into a spreadsheet, copy-paste every name from
the sheet, enter it in the unicorn generator, scrape the generated
name for each customer, and finally send emails with unicorn
names. This is very tedious. A key problem in this process is
how to create a program that interacts with the web-based
generator and the spreadsheet in order to create names for
all customers. This is exactly a web RPA problem.2

Web RPA sits at the intersection of multiple areas, such as
programming languages and human-computer interaction.
While it has been studied in different forms by different com-
munities, to the best of our knowledge, there is no principled
approach that automatically generates web RPA programs
in a comprehensive manner. For instance, while being able
to scrape data across webpages, Helena [17] has relatively
less support for programmatic data entry. Furthermore, it
may generate wrong programs which, in our experience, are
not always easy to ‚Äúcorrect‚Äù using Helena‚Äôs build-in features.
On the other hand, the HCI and databases communities have
proposed various interfaces [36, 38] and wrapper induction

1Web automation is a broad term. We note that web RPA is highly related
to web automation but in this work, we do not precisely distinguish them.
2This example involves one single webpage but we have many benchmarks
that involve navigating across multiple pages (see Section 7).

Figure 3. Schematic workflow of our approach.

techniques [10, 26, 51], which are even more restricted and
can automate only single-webpage tasks. Finally, while some
‚Äúlow-code‚Äù solutions based on record-and-replay exist on the
industrial market (such as iMacros [2]), they require signifi-
cant manual efforts (e.g., adding loops), which makes them
potentially less accessible to non-expert end-users.

Interactive programming-by-demonstration (PBD) for
web RPA. Our first contribution is a new approach that au-
tomates web RPA tasks from demonstrations interactively.
Compared to existing work, our approach is more automated,
resilient to ambiguity, and applicable for web RPA. Figure 3
shows the schematic workflow of our approach. To automate
a task, the user just needs to perform it as usual but using
our interface (step 1 ). All the user-demonstrated actions are
recorded and sent to our back-end synthesis engine. Then,
we synthesize a program ùëÉ that ‚Äúsatisfies‚Äù the demonstration
(step 2 ). That is, ùëÉ is guaranteed to reproduce the recorded
actions, but ùëÉ may also produce more actions afterwards. We
then ‚Äúexecute‚Äù ùëÉ to produce an action that the user may want
to perform next and visualize this predicted action via our
interface (step 3 ). Finally, the user inspects the prediction
and chooses to accept or reject it (step 4 ). This interactive
process repeats until there is sufficient confidence that the
synthesized program is intended (step 5 ); after that, it will
take over and automate the rest of the task (step 6 ). Note
that, if at any point the user spots anything abnormal, they
can still interrupt and enter the demonstration phase again.
We highlight several salient features of our approach. First,
it is automated: users only need to provide demonstrations,
without needing to write programs. Second, it is interactive:
whenever a synthesized program is not desired, the user can
simply interrupt and continue demonstrating more actions,
without having to edit programs. Finally, it could synthesize
programs effectively from an expressive language, thanks to
a systematic problem formulation and a new search algorithm.
Systematic formulation of PBD for web RPA. Our sec-
ond contribution is a systematic formulation for the problem
of synthesis from action-based demonstrations. In particular,
the question we aim to address here is: what does it mean
for a program to satisfy a trace of user-demonstrated actions?
This problem is extremely understudied in a formal context.
To the best of our knowledge, the latest work to date is the
seminal work [30‚Äì32] by Tessa Lau and their co-authors in
the 1990s. However, Lau‚Äôs work considers state-based demon-
strations; that is, in their work, a demonstration is defined as
a sequence of program states. In contrast, our work concerns
action-based demonstrations‚Äîa demonstration is a trace of

Webpage Navigation‚Ä¶Data EntryData ExtractionData  (e.g., spreadsheet)Web BrowserData (e.g., spreadsheet)‚Ä¶‚Ä¶ClickData ExtractionSpreadsheetWeb BrowserData EntrySpreadsheetAction‚Ä¶ActionPredicted ActionSynthesis EngineProgramInterpreter (our trace semantics)‚Ä¶Front-endBack-end1Demonstrate2Synthesize3Execute4Authorize5Repeat6Automate‚Ä¶WebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

actions. In this context, we are not aware of any prior work
that has formalized the semantic notion of satisfaction. As a
result, existing techniques [17, 18, 40, 41] resort to heuristics
and task-specific rules to detect patterns in the action trace
in order to generalize it to programs with loops. In this work,
we formulate the action-based PBD problem by formalizing
the trace semantics for an expressive web RPA language. In
a nutshell, our semantics ‚Äúexecutes‚Äù a program (with loops)
and produces its ‚Äúexecution trace‚Äù of actions by unrolling
loops and replacing variables with values. Therefore, with
our semantics, we can now check a program against a trace
of actions. Furthermore, this semantics also plays a pivotal
role in our search algorithm, which we will explain next.

Action-based PBD using speculative rewriting. Once
we can check a program against a trace of actions, the next
question we ask is: how to search for programs that satisfy
the given trace? This brings us to the third contribution of
our work, which is a novel rewrite-based synthesis algorithm
based on a new idea called speculative rewriting. The basic
idea is simple: we rewrite a slice of the trace into a (one-level)
loop which produces that slice, using a set of predefined rules;
if we do this iteratively, we can generate nested loops from
the inside out. The issue is, it is very hard to define a complete
set of correct-by-construction rules in our domain, because
our trace may result from executing loops (from an arbitrary
program) for arbitrarily many times. In other words, pattern-
matching the entire trace in a purely rule-based manner does
not scale. In order to scale to complex programs, our idea is to
combine rule-based pattern-matching and semantic validation
in the rewrite process via an intermediate speculation step.
More specifically, instead of pattern-matching all iterations
to directly generate true rewrites, our idea is to pattern-match
a couple of iterations and generate speculative rewrites, or s-
rewrites. While an s-rewrite might not be a true rewrite in
general, they over-approximate the set of true rewrites and
are much easier to generate. We then use our trace semantics
to validate s-rewrites and retain only those true rewrites.

Our method is closely related to two lines of work. First,
it builds upon the ‚Äúguess-and-check‚Äù idea introduced by the
counterexample-guided inductive synthesis (CEGIS) frame-
work [55], but we show how to extend this idea for rewrite-
based synthesis beyond the traditional application scenarios
with example-based and logical specifications. Second, our
method incorporates the idea of semantic rewrite rules from
recent work [43, 63], but we augment this standard correct-
by-construction, rule-based rewrite approach with a novel
guess-and-check step.3 We found this new idea to be both
theoretically simple and practically efficient in our domain.
We also believe this methodology is potentially useful in the
more general context of rewrite-based synthesis and in other
problem domains with similar trace generalization problems.

Human-in-the-loop interaction model. As a proof-of-
concept, we have also developed a user interface to facilitate
user interactions with our synthesizer. Our interface com-
bines programming-by-demonstration, action visualization,
and interactive authorization within a human-in-the-loop
model, which has shown to be useful in practice for reducing
the gulfs of execution and evaluation [45].

Implementation and evaluation. We have implemented
our proposed ideas in a tool called WebRobot and evaluate
it across four experiments. First, we evaluate WebRobot‚Äôs
synthesis engine on 76 real-world web RPA benchmarks and
show that it can synthesize programs effectively. Second, we
perform an ablation study and show that all of our proposed
ideas are important. Furthermore, we conduct a user study
with eight participants which shows that WebRobot can be
used by non-experts. Finally, we compare WebRobot with a
rewrite-based synthesis approach and our results show that
WebRobot significantly advances the state-of-the-art.

In summary, this paper makes the following contributions:

‚Ä¢ We identify the web RPA program synthesis problem.
‚Ä¢ We formalize a trace semantics of our web RPA language,
laying the formal foundation for its synthesis problem.
‚Ä¢ We present a novel programming-by-demonstration algo-
rithm based on a new idea called speculative rewriting.
‚Ä¢ We develop a new human-in-the-loop interaction model.
‚Ä¢ We implement our ideas in a new tool called WebRobot.
‚Ä¢ We evaluate WebRobot on 76 tasks and via a user study.

2 Overview of WebRobot

In this section, we highlight some key features of WebRobot
using a motivating example4 from the iMacros forum.

Motivating example. Given a list of zip codes, Ellie wants
to extract store information from the Subway website5. Since
Ellie is not familiar with programming, she has to manually
perform this task (shown in Figure 4): (a) enter the first zip in
the search box, (b) click the search button which then shows
five pages of search results, (c) scrape store information on
the first page, (d) click the ‚Äúnext page‚Äù button and repeat this
process for all pages and for all zip codes.

WebRobot. Ellie could use our tool to automate this task.
Once WebRobot is fired up, Ellie would first import the list
of zip codes and then perform the task using WebRobot.
This process is illustrated in Figure 5(a). In particular, Ellie
first drags the first zip and drops it in the search bar (action 1).
Then, she clicks the GO button and starts scraping informa-
tion of the first two stores on the first page: see actions 2-6 in
Figure 5(b), although we do not show them in Figure 5(a). All
these actions are recorded by WebRobot in an action trace,
which is shown in Figure 5(b). After six actions, WebRobot
is able to synthesize a program ùëÉ1, as shown in Figure 5(c),
which extracts the address and phone number for each store

3We will elaborate on this in the remainder of this paper.

4https://forum.imacros.net/viewtopic.php?f=7&t=21028
5http://www.subway.com/storelocator/

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

Satisfaction check using trace semantics. Consider ùëÉ1
from Figure 5(c) which is synthesized from the first 6 actions
ùëé1, ¬∑¬∑, ùëé6 in Figure 5(b). In other words, ùëÉ1 satisfies the action
trace [ùëé1, ¬∑¬∑, ùëé6]. To perform this satisfaction check, we simu-
late the execution of ùëÉ1 using our trace semantics. Note that
this is a simulated execution, rather than actually execut-
ing ùëÉ1 in the browser, because during the synthesis process,
programs might have side-effects that are not intended. Our
trace semantics would first execute the EnterData and Click
statements before the loop, which essentially reproduces
ùëé1, ùëé2. Then, we unroll the loop twice, reproducing ùëé3, ¬∑¬∑, ùëé6.
A subtle aspect here is that the actions produced by our sim-
ulated execution might not be syntactically the same as those
in the recorded trace, since ùëÉ1 might use selectors that are
different from those in the recorded action trace. Thus, we
check if an action produced by our semantics and an action
in the demonstrated trace refer to the same Document Object
Model (DOM) node; this is done by also recording a trace of
DOMs in tandem. We will explain this in detail in Section 3.
Rewrite-based PBD. How to synthesize programs from
an action trace? We take a rewrite-based approach. Consider
the trace [ùëé1, ¬∑¬∑, ùëé6] and ùëÉ1 in our previous example: the loop
in ùëÉ1 is rewritten from actions ùëé3, ¬∑¬∑, ùëé6. WebRobot can also
synthesize nested loops. For instance, the inner loop in ùëÉ3
corresponds to multiple slices of actions, such as 3-22, 24-43.
Once identified, these slices are rewritten to (multiple occur-
rences of) the same loop. Then, WebRobot will generate a
nested loop from the inside out by essentially treating the
(inner) loop as one action and rewriting again. In this case,
it rewrites actions 3-106 to the while loop in ùëÉ3.

Selector search. In addition to identifying iteration bound-
aries, WebRobot also considers other selectors, beyond full
XPath expressions that are recorded in the trace, since the de-
sired program may not use those recorded. For example, ùëé4 in
Figure 5(b) is a full XPath, whereas the corresponding state-
ment in ùëÉ1 (namely, the second statement in the loop) uses a
more general selector (with div[@class=‚ÄôlocatorPhone‚Äô]). Con-
sidering alternative selectors allows to induce more general
programs, but it also makes the problem more challenging.
Speculative rewriting. A standard rewrite-based synthe-
sis approach requires a set of correct-by-construction rewrite
rules [43, 63], meaning they always generate sound rewrites.
In our domain, if we follow this idea, we need to design rules
that pattern-match actions which result from an unknown
number of loop iterations and from arbitrarily complex loop
structures; this is hard to scale to complex web RPA tasks. Our
idea is to pattern-match actions from a couple of iterations. For
instance, given [ùëé1, ¬∑¬∑, ùëé22] in Figure 5(b) that corresponds to
ùëÉ1, instead of pattern-matching ùëé3, ¬∑¬∑, ùëé22, using rules, to syn-
thesize a true rewrite (i.e., a loop), we pattern-match ùëé3, ¬∑¬∑, ùëé6
and speculate a potential rewrite ùëÉùëô , assuming ùëé3, ¬∑¬∑, ùëé6 ‚Äúcome
from‚Äù the first two iterations of ùëÉl. This is conceptually sim-
pler and faster, but the downside is that ùëÉl might not be a true
rewrite, since it is inferred from only the first two iterations.

Figure 4. A motivating example: scrape address and phone
number for all stores across all pages and for all zip codes.

on the first page. Next, WebRobot performs an interactive
‚Äúauthorization‚Äù step: it executes ùëÉ1 to produce the next action
which is then visualized to Ellie (see Figure 5(a), action 7).
This is correct, so Ellie accepts it. After a couple of rounds,
WebRobot takes over and automates the scraping work on
the first page (Figure 5(a), actions 9-22).

WebRobot would terminate after action 22. Thus, Ellie
needs to click the ‚Äúnext page‚Äù button and extract information
for a couple of stores on the second page. These actions are
also recorded; see Figure 5(b), actions 23-27. At this point,
WebRobot infers a different program ùëÉ2 which has two loops
one after another, where the second loop extracts informa-
tion of all stores on the second page. Using ùëÉ2, WebRobot
is able to automatically scrape the second page; however, it
terminates, again, right before the ‚Äúnext page‚Äù button.

This time, once Ellie clicks ‚Äúnext page‚Äù (i.e., action 44), we
can synthesize ùëÉ3‚Äìsee Figure 5(c)‚Äìwhich contains an outer
while loop that first uses an inner loop for scraping and then
clicks ‚Äúnext page‚Äù at the end. ùëÉ3 now is able to automatically
scrape all store information for the remaining pages.

Since Ellie needs to repeat this scraping process for all zip
codes, she will enter the second zip code and click ‚ÄúGO‚Äù again
(actions 107-108), after which WebRobot can synthesize ùëÉ4
that has a three-level loop. ùëÉ4 first iterates over all zip codes
in the given list and then uses a doubly-nested loop to scrape
across all pages. At this point, Ellie is done.

We highlight some salient features of WebRobot below.
Interactive PBD to resolve ambiguity. WebRobot does
not need users to provide multiple small demonstrations as
in traditional PDB approaches [31]; instead, it synthesizes
programs while the user is performing the task. In case the
synthesized program is not intended, WebRobot does not
ask the user for an edit on the program as in program-centric
tools (such as Helena). Rather, it allows the user to take over
and correct the behavior. For instance, in the ‚Äúauthorization‚Äù
phase, WebRobot visualizes potentially multiple options for
the next action and let the user select the one that is desired.
This design aims to facilitate interactive disambiguation.

(a) Enter each zip code in search box(b) Click ‚ÄúGO‚Äù(c) Scrape address and phone number(d) Click ‚Äúnext page‚Äù WebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Figure 5. (a) User interactions with the web browser and WebRobot. (b) Action trace recorded by WebRobot, where a short
explanation is attached to the left of each action. (c) Programs synthesized by WebRobot at different points.

Semantic validation. Our next idea is to check if a spec-
ulative rewrite (or, s-rewrite) ùëÉùëô is a true rewrite by executing
ùëÉùëô under our trace semantics. The goals are twofold. First,
we check if ùëÉùëô can rewrite a longer slice of actions beyond
the first iteration; if not, we filter out ùëÉùëô . Second, if ùëÉùëô indeed
rewrites beyond the first iteration, semantic validation also
gives us the (longer) slice that ùëÉùëô could rewrite. As we can
see, building a formal semantic foundation allows us to not
only systematically formulate the synthesis problem for web
RPA, but also develop an effective algorithm to solving it.
3 Web RPA Language and Trace Semantics

This section lays the formal foundation for web RPA.
3.1 Syntax
Our syntax is shown in Figure 6. Intuitively, a program ùëÉ in
this language is a sequence of statements that emulates user
interactions with a web browser and a data source. Its input
variable ùë• is a data source ùêº represented in JSON-like format:

::= {key : value, ¬∑¬∑, key : value}

ùêº
key ::= string

value ::= string | integer | ùêº | [value, ¬∑¬∑, value]

This allows using any semi-structured data as our data source.

A statement ùëÜ, in the simplest case, performs an action on
the current webpage. For example, Click clicks a DOM node
located by a selector ùëõ. ScrapeText scrapes the text inside a
node specified by ùëõ. Some statements are parameterless (e.g.,
GoBack that goes back to the previous page and ExtractURL
that gives the URL of current webpage). Some statements
might take multiple parameters. For example, SendKeys types
a constant string ùë† into an editable field given by a selector ùëõ.
EnterData enters a value ùë£ from input data ùêº to a field located
by ùëõ. Note that ùë£ is represented using a value path, which is
essentially a sequence of keys and array indices in order to
access the value from ùêº . On the other hand, a selector ùëõ in our
language is essentially an XPath expression [8] but it may
contain a variable ùúö at the beginning. In particular, ùëõ/ùúô [ùëñ]
gives the ùëñ-th child of a DOM node ùëõ that satisfies a predicate
ùúô. ùëõ//ùúô [ùëñ] gives the ùëñ-th descendant which satisfies ùúô among
all nodes in the subtree rooted at ùëõ. Our language has multi-
ple types of predicates. The simplest one is an HTML tag ùë°.
For instance, ùëõ/span[1] returns the first child of ùëõ with tag
span. The next predicate ùë° [@ùúè = ùë†] means the desired DOM
node should have tag ùë° and its attribute ùúè should take value

EnterData /../input x[zips][1] Click /../bu9on ScrapeText /../div[1]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[1]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div ScrapeText /../div[2]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[2]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div ScrapeText /../div[3]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[3]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div /* Scrape informaFon of 4th, .., 9th stores on the page */ ScrapeText /../div[10]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[10]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div Click /../span ScrapeText /../div[1]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[1]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div ScrapeText /../div[2]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[2]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div /* Scrape informaFon of 3rd, .., 9th stores on the page */ ScrapeText /../div[10]/div[2]/div[1]/div[1]/div/h3 ScrapeText /../div[10]/div[2]/div[1]/div[2]/div[1]/div[4]/a/div Click /../span /* Scrape informaFon for all stores on 3rd, 4th, 5th pages */ EnterData /../input x[zips][2] Click /../bu9on /* Scrape for all remaining zip codes, all stores, on all pages */ Enter 1st zip Click ‚ÄúGO‚Äù 1st address 1st phone # 2nd address 2nd phone # 3rd address 3rd phone # .. Last address Last phone # ‚ÄúNext page‚Äù 1st address 1st phone # 2nd address 2nd phone # .. Last address Last phone # ‚ÄúNext page‚Äù .. Enter 2nd zip Click ‚ÄúGO‚Äù ..1 2 3 4 5 6 7 8 9-20 21 22 23 24 25 26 27 28-41 42 43 44 45-106 107 108 109-EnterData /../input x[zips][1] Click /../button foreach  in Dscts(, div[@class='rightContainer']) do    ScrapeText //h3   ScrapeText //div[@class=‚ÄòlocatorPhone‚Äô]      œ±œµœ±œ± (synthesized aYer acFon 6)P1 (synthesized aYer acFon 27)P2EnterData /../input x[zips][1] Click /../button foreach  in Dscts(, div[@class='rightContainer']) do    ScrapeText //h3   ScrapeText //div[@class=‚ÄòlocatorPhone']       Click /../span foreach  in Dscts(, div[@class='rightContainer']) do    ScrapeText //h3   ScrapeText //div[@class=‚ÄòlocatorPhone']      œ±œµœ±œ±œ±œµœ±œ±EnterData /../input x[zips][1] Click /../button while true do    foreach  in Dscts(, div[@class='rightContainer']) do      ScrapeText //h3     ScrapeText //div[@class=‚ÄòlocatorPhone']      Click //button[@class=‚Äòsprite-next-page-arrow‚Äô]/span[@class='far..']œ±œµœ±œ± (synthesized aYer acFon 44)P3foreach  in ValuePaths(x[zips]) do    EnterData /..//input[@name=‚Äòsearch‚Äô] v1   Click /..//button[@class=‚ÄòsquareButton buttonLarge btnDoSearch']   while true do      foreach  in Dscts(, div[@class='rightContainer']) do        ScrapeText //h3       ScrapeText //div[@class='locatorPhone']     Click //button[@class=‚Äòsprite-next-page-arrow‚Äô]/span[@class='far..']œëœ±œµœ±œ± (synthesized aYer acFon 108)P4DemoAuthAutoDemoAutoDemoAutoDemo(AcFon 1) Drag-and-drop 1st zip code(AcFon 7) Accept predicFon if correct‚Ä¶(AcFons 9-22) AutomaFcally scrape on 1st page(AcFon 23) Click ‚Äúnext page‚Äù bu9on(a) User interactions(b) Action trace(c) Synthesized programsAutoPLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

Program
Statement

ùëÉ
ùëÜ

::=
::=

ùëÜ; ¬∑¬∑; ùëÜ
Click(ùëõ) | ScrapeText(ùëõ) | ScrapeLink(ùëõ)

| Download(ùëõ) | GoBack | ExtractURL
SendKeys(ùëõ, ùë†) | EnterData(ùëõ, ùë£)
|
foreach ùúö in ùëÅ do ùëÉ
|
foreach ùúó in ùëâ do ùëÉ
|
while true do {ùëÉ ; Click(ùëõ) }
|
ùúñ | ùúö | ùëõ/ùúô [ùëñ ] | ùëõ//ùúô [ùëñ ]
ùëõ
::=
ùë• | ùúó | ùë£ [key] | ùë£ [ùëñ ]
ùë£
::=
Children(ùëõ, ùúô) | Dscts(ùëõ, ùúô)
ùëÅ ::=
ValuePaths(ùë£)
::=
ùë° | ùë° [@ùúè = ùë† ]
::=
ùëñ ::= integer

ùë° ::= HTML tag

Selector
Value Path
Selectors
Value Paths ùëâ
Predicate
ùúô

ùë† ::= string

ùúè ::= HTML attribute

(selectors loop)
(value path loop)
(while loop)

Figure 6. Syntax of our web RPA language.

ùë†. For instance, ùëõ//div[@class = ‚Äúùëé‚Äù] [2] returns the second
descendant of ùëõ that has tag div and whose class attribute
value is string ‚Äúa‚Äù.

Statements could also be loopy. The first type of loop is
selector loops which iterate over a list ùëÅ of DOM nodes on a
webpage. This construct is to emulate loopy user interactions
on webpages, such as scraping a list of elements. In particular,
ùëÅ returns a list of selectors. During the ùëñ-th iteration, the loop
variable ùúö binds to the ùëñ-th selector in ùëÅ under which the
loop body ùëÉ gets executed. Note that a statement in ùëÉ could
use ùúö and it may also be a loop. The next loop type is value
path loops, which are used to emulate loopy interactions with
input data. In this case, ùëâ evaluates to a list of value paths,
ùúó binds to each value path, and ùëÉ is executed in this context.
Our last type of loops is while loops, where the termination
condition is that the DOM node ùëõ in the last Click statement
no longer exists on the webpage. This construct is primarily
used to handle pagination where the user needs to repeatedly
click the ‚Äúnext page‚Äù button until there is no next page.

3.2 Trace Semantics

So far, we have seen the DSL syntax, which is new but fairly
standard. Now, in this section, we will formalize its semantics,
which is a key distinction of our paper from prior work.

Design rationale. Let us first briefly present our thought
process in designing this semantics. Recall that a program ùëÉ
in our language takes as input a data source ùêº and is executed
on an initial DOM; ùëÉ has side-effects that change the DOM,
eventually terminating at some browser state. Thus, one may
start with the following semantics definition.

ùúã, Œ£ ‚ä¢ ùëÉ : ùúã ‚Ä≤
Here, ùúã is the initial DOM, Œ£ is an environment that tracks
variable values, and ùúã ‚Ä≤ is the final DOM when ùëÉ terminates.
However, there is a gap between this semantics and our
specification: one is based on DOMs and the other is based on
actions. This brings us to our first key insight: the semantics
(for our synthesis technique) should incorporate actions that
the program executes. This is primarily because in synthesis,
we typically use semantics to validate candidate programs

against the specification. This leads to the following design.
ùúã, Œ£ ‚ä¢ ùëÉ : ùê¥‚Ä≤, ùúã ‚Ä≤
The key idea in this design is to track the trace ùê¥‚Ä≤ of actions
taken by ùëÉ during its execution. Here, ùê¥‚Ä≤ is a list [ùëé1, ¬∑¬∑, ùëéùëö]
of actions where an action is defined as follows.

ùëé ::= Click(ùúå) | ScrapeText(ùúå) | ScrapeLink(ùúå) | Download(ùúå)
| GoBack | ExtractURL | SendKeys(ùúå, ùë†) | EnterData(ùúå, ùúÉ )

ùúå ::= ùúñ | ùúå/ùúô [ùëñ] | ùúå//ùúô [ùëñ]

ùúÉ ::= ùë• | ùúÉ [key] | ùúÉ [ùëñ]

Note that, different from statement ùëÜ in Figure 6, an action ùëé
is loop-free and uses concrete selectors ùúå and value paths ùúÉ .
We further illustrate how action tracking works using the
following two simple rules (which include an environment
in the output). Other rules are fairly similar.

ùúã, Œ£ ‚ä¢ ùëÜ1 ‚áù ùê¥‚Ä≤, ùúã ‚Ä≤, Œ£‚Ä≤

ùúã ‚Ä≤, Œ£‚Ä≤ ‚ä¢ ùëÜ2, ¬∑¬∑, ùëÜùëö ‚áù ùê¥‚Ä≤‚Ä≤, ùúã ‚Ä≤‚Ä≤, Œ£‚Ä≤‚Ä≤

ùúã, Œ£ ‚ä¢ ùëÜ1; ¬∑¬∑; ùëÜùëö ‚áù ùê¥‚Ä≤++ùê¥‚Ä≤‚Ä≤, ùúã ‚Ä≤‚Ä≤, Œ£‚Ä≤‚Ä≤

(Seq)

Œ£ ‚ä¢ ùëõ ‚áù ùúå

ùúã ‚Ä≤ = Perform_Click(ùúå, ùúã )

ùúã, Œ£ ‚ä¢ Click(ùëõ) ‚áù [Click(ùúå) ], ùúã ‚Ä≤, Œ£

(Click)

The Seq rule is standard in that it executes ùëÜùëñ ‚Äôs in sequence;
however, note that it concatenates the action traces ùê¥‚Ä≤ and
ùê¥‚Ä≤‚Ä≤ in the output. The actual action tracking takes place in the
base rules, such as Click, but there is an issue: Click actually
performs the operation in the browser. This is problematic
because during synthesis, candidate programs might have
undesired side-effects (e.g., clicking a button that deletes the
database), which prevents us from actually running them.
This motivates our second key idea: we simulate the actual
semantics without actually running ùëÉ, in particular, by sim-
ulating ùëÉ‚Äôs DOM transition using a trace Œ† of DOMs.6 We
illustrate how this simulation works still on Seq and Click.

Œ†, Œ£ ‚ä¢ ùëÜ1 ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤

Œ†‚Ä≤, Œ£‚Ä≤ ‚ä¢ ùëÜ2, ¬∑¬∑, ùëÜùëö ‚áù ùê¥‚Ä≤‚Ä≤, Œ†‚Ä≤‚Ä≤, Œ£‚Ä≤‚Ä≤

Œ†, Œ£ ‚ä¢ ùëÜ1; ¬∑¬∑; ùëÜùëö ‚áù ùê¥‚Ä≤++ùê¥‚Ä≤‚Ä≤, Œ†‚Ä≤‚Ä≤, Œ£‚Ä≤‚Ä≤

(Seq)

Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ]

Œ£ ‚ä¢ ùëõ ‚áù ùúå

Œ†‚Ä≤ = [ùúã2, ¬∑¬∑, ùúãùëö ]

Œ†, Œ£ ‚ä¢ Click(ùëõ) ‚áù [Click(ùúå) ], Œ†‚Ä≤, Œ£

(Click)

Here, instead of tracking the resulting DOM ùúã ‚Ä≤, Click tracks
the resulting DOM trace Œ†‚Ä≤; the intuition is that Œ†‚Ä≤ contains
DOMs that future actions will be executed upon (instead of
only the next immediate action). The transition from Œ† to Œ†‚Ä≤
is ‚Äúangelic‚Äù in that Click always transitions to the next DOM
(by removing ùúã1 from Œ†), without actually doing the click on
ùúã1. But, what if performing the click on ùúã1 does not yield ùúã2?
This is indeed possible, especially given that our synthesis
algorithm often explores many wrong programs. However, if
the resulting action trace ùê¥‚Ä≤ matches the user-provided trace
ùê¥ (i.e., the specification), we know that every DOM transition
must be genuine, because that is what we had recorded from
the user demonstration (assuming deterministic replay). In
other words, evaluating ‚Äúthe right‚Äù program that corresponds
to Œ† guarantees to yield ùê¥‚Ä≤ that matches the specification ùê¥.

6We can obtain this DOM trace by recording intermediate DOMs in tandem
while recording the user-demonstrated actions.

WebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

(Eval)

(Term)

(Seq)

(Click)

Œ†, {ùë• ‚Ü¶‚Üí ùêº } ‚ä¢ ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤
Œ†, ùêº ‚ä¢ ùëÉ : ùê¥‚Ä≤

Œ† = []
Œ†, Œ£ ‚ä¢ ùëÉ ‚áù [], [], Œ£

Œ†, Œ£ ‚ä¢ ùëÜ1 ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤ Œ†‚Ä≤, Œ£‚Ä≤ ‚ä¢ ùëÜ2; ¬∑¬∑; ùëÜùëö ‚áù ùê¥‚Ä≤‚Ä≤, Œ†‚Ä≤‚Ä≤, Œ£‚Ä≤‚Ä≤
Œ†, Œ£ ‚ä¢ ùëÜ1; ¬∑¬∑; ùëÜùëö ‚áù ùê¥‚Ä≤++ùê¥‚Ä≤‚Ä≤, Œ†‚Ä≤‚Ä≤, Œ£‚Ä≤‚Ä≤

Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ] Œ£ ‚ä¢ ùëõ ‚áù ùúå
Œ†, Œ£ ‚ä¢ Click(ùëõ) ‚áù [Click(ùúå) ], [ùúã2, ¬∑¬∑, ùúãùëö ], Œ£

(EnterData)

Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ] Œ£ ‚ä¢ ùëõ ‚áù ùúå Œ£ ‚ä¢ ùë£ ‚áù ùúÉ
Œ†, Œ£ ‚ä¢ EnterData(ùëõ, ùë£) ‚áù [EnterData(ùúå, ùúÉ ) ], [ùúã2, ¬∑¬∑, ùúãùëö ], Œ£

(S-Init)

Œ†, Œ£ ‚ä¢ foreach ùúö in ùëÅ‚â•1 do ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤
Œ†, Œ£ ‚ä¢ foreach ùúö in ùëÅ do ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤

(S-Cont) Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ] Œ£ ‚ä¢ ùëÅ‚â•ùëñ ‚áù ùúå :: ùëÅ‚â•ùëñ+1

valid(ùúå, ùúã1)
Œ†, Œ£[ùúö ‚Ü¶‚Üí ùúå ] ‚ä¢ ùëÉ ; foreach ùúö in ùëÅ‚â•ùëñ+1 do ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤
Œ†, Œ£ ‚ä¢ foreach ùúö in ùëÅ‚â•ùëñ do ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤

(S-Term) Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ] Œ£ ‚ä¢ ùëÅ‚â•ùëñ ‚áù ùúå :: ùëÅ‚â•ùëñ+1 ¬¨valid(ùúå, ùúã1)

Œ†, Œ£ ‚ä¢ foreach ùúö in ùëÅ‚â•ùëñ do ùëÉ ‚áù [], Œ†, Œ£

(VP-Loop)

Œ£ ‚ä¢ ùëâ ‚áù [ùúÉ1, ¬∑¬∑, ùúÉùëö ] Œ†0 = Œ† Œ£0 = Œ£

Œ†ùëñ‚àí1, Œ£ùëñ‚àí1 [ùúó ‚Ü¶‚Üí ùúÉùëñ ] ‚ä¢ ùëÉ ‚áù ùê¥ùëñ, Œ†ùëñ, Œ£ùëñ

1 ‚â§ ùëñ ‚â§ ùëö

Œ†, Œ£ ‚ä¢ foreach ùúó in ùëâ do ùëÉ ‚áù ùê¥1++ ¬∑ ¬∑ ++ùê¥ùëö, Œ†ùëö, Œ£ùëö

(While-Init)
Œ†, Œ£ ‚ä¢ ùëÉ ; if valid(ùëõ) do (cid:8)Click(ùëõ); while true do {ùëÉ ; Click(ùëõ) }(cid:9) ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤
Œ†, Œ£ ‚ä¢ while true do {ùëÉ ; Click(ùëõ) } ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤

(While-Cont)

Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ] Œ£ ‚ä¢ ùëõ ‚áù ùúå valid(ùúå, ùúã1) Œ†, Œ£ ‚ä¢ ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤
Œ†, Œ£ ‚ä¢ if valid(ùëõ) do ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤

(While-Term)

Œ† = [ùúã1, ¬∑¬∑, ùúãùëö ] Œ£ ‚ä¢ ùëõ ‚áù ùúå ¬¨valid(ùúå, ùúã1)
Œ†, Œ£ ‚ä¢ if valid(ùëõ) do ùëÉ ‚áù [], Œ†, Œ£
Figure 7. Trace semantics of our web RPA language.

Our trace semantics. Let us now explain our simulation
semantics in detail. Our top-level judgment takes the form:
Œ†, ùêº ‚ä¢ ùëÉ : ùê¥‚Ä≤
where ùê¥‚Ä≤ is the action trace produced by ùëÉ, and Œ† is used to
guide the simulated execution (as we also briefly discussed
earlier). Our key rule is of the form:

Œ†, Œ£ ‚ä¢ ùëÉ ‚áù ùê¥‚Ä≤, Œ†‚Ä≤, Œ£‚Ä≤

which intuitively states:

Given DOM trace Œ† and environment Œ£, ùëÉ would execute
actions in ùê¥‚Ä≤, yielding environment Œ£‚Ä≤ and DOM trace Œ†‚Ä≤
(containing DOMs future actions will be executed upon).
Evaluating programs. The Term rule states that, if the
input DOM trace is empty (i.e., there is no DOM to execute
ùëÉ upon), then we terminate the entire execution. Otherwise,
we evaluate the statements sequentially using the Seq rule.
Evaluating loop-free statements. Figure 7 gives two ex-
ample rules; the other rules are very similar. The Click rule
first evaluates ùëõ to obtain a concrete selector ùúå and then pro-
duces a Click action. The EnterData rule is similar, except

(1)

(2)

(3)

(4)

Œ£ ‚ä¢ ùúñ ‚áù ùúñ

Œ£ ‚ä¢ ùúö ‚áù Œ£ [ùúö ]

Œ£ ‚ä¢ ùëõ ‚áù ùúå
Œ£ ‚ä¢ ùëõ/ùúô [ùëñ ] ‚áù ùúå/ùúô [ùëñ ]

Œ£ ‚ä¢ ùëõ ‚áù ùúå
Œ£ ‚ä¢ ùëõ//ùúô [ùëñ ] ‚áù ùúå//ùúô [ùëñ ]

(5)

(6)

(7)

(8)

Œ£ ‚ä¢ ùë• ‚áù ùë•

Œ£ ‚ä¢ ùúó ‚áù Œ£[ùúó ]

Œ£ ‚ä¢ ùë£ ‚áù ùúÉ
Œ£ ‚ä¢ ùë£ [key] ‚áù ùúÉ [key]

Œ£ ‚ä¢ ùë£ ‚áù ùúÉ
Œ£ ‚ä¢ ùë£ [ùëñ ] ‚áù ùúÉ [ùëñ ]

(9)

Œ£ ‚ä¢ ùëõ ‚áù ùúå Œ£ ‚ä¢ ùëõ ‚áù ùúå
Œ£ ‚ä¢ Children(ùëõ, ùúô)‚â•ùëñ ‚áù ùúå/ùúô [ùëñ ] :: Children(ùúå, ùúô)‚â•ùëñ+1

(10)

(11)

Œ£ ‚ä¢ ùëõ ‚áù ùúå
Œ£ ‚ä¢ Dscts(ùëõ, ùúô)‚â•ùëñ ‚áù ùúå//ùúô [ùëñ ] :: Dscts(ùúå, ùúô)‚â•ùëñ+1

Œ£ ‚ä¢ ùë£ ‚áù ùúÉ
arr = GetArray(Œ£ [ùë• ], ùúÉ )
Œ£ ‚ä¢ ValuePaths(ùë£) ‚áù (cid:2)ùúÉ [1], ¬∑¬∑, ùúÉ [ |arr |](cid:3)

Figure 8. Auxiliary rules for our trace semantics.
that it also evaluates the value path expression ùë£. As we can
see, these rules form the base cases of our semantics.

Evaluating loopy statements. The rest of the rules from
Figure 7 deal with loops. Amongst the first three rules that
handle selector loops, the most interesting one perhaps is
S-Cont: it unrolls the loop once if the first selector ùúå refers
to a DOM node that exists in ùúã1 (checked by valid). This is
another example for how we use DOMs to guide the simu-
lated execution: we use DOMs to handle branches in loops. If
ùúå exists in ùúã1 (e.g., the next element to be scraped exists), we
bind ùúö to ùúå and execute the loop body ùëÉ. Note that S-Cont
unrolls loops lazily. This is because many websites load more
DOM nodes while scrolling down a page: we cannot eagerly
fetch all DOM nodes at the beginning; instead, we have to
keep executing until all nodes are loaded. The next rule, VP-
Loop, handles value path loops. It is eager and it iterates over
all value paths in ùëâ . The last three rules handle while loops.
A key distinction here is the termination condition: while
loops are click-terminated. That is, if the selector in the last
Click is not valid, it terminates. As mentioned earlier, this is
mainly used to handle pagination using ‚Äúnext page‚Äù. Note
that, though not explicitly being defined, we use a standard
if construct in our rules to help formalize the semantics.

Auxiliary rules. Figure 8 presents the auxiliary rules for
evaluating symbolic selectors and value paths. They are fairly
straightforward. For instance, rules (1)-(4) handle selector ex-
pressions that may contain variables, by basically replacing
variables with concrete values. Rules (5)-(8) are conceptually
the same except that they are for symbolic value paths. Rules
(9)-(11) evaluate selectors expressions.
Example 3.1. Consider the following program ùëÉ, which is
an extremely simplified version of ùëÉ1 from Figure 5(c).
foreach ùúö in Dscts(ùúñ, a) do {Click(ùúö )}
Here, ùëÉ performs a Click (using variable ùúö ) in a selectors loop.
For simplicity, let us consider a DOM trace Œ† = [ùúã1, ùúã2]. Let
us also assume Œ† indeed corresponds to ùëÉ; that is, the ùëñ-th
click in ùëÉ executed on DOM ùúãùëñ transitions the page to ùúãùëñ+1.

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

{ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] } ‚ä¢ ùúö ‚áù //a[2]
[ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] } ‚ä¢ Click(ùúö ) ‚áù [Click(//a[2]) ], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

(Click)

[], ¬∑¬∑ ‚ä¢ ¬∑¬∑ ‚áù [], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

[ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] } ‚ä¢ Click(ùúö ); foreach ùúö in Dscts(ùúñ, a)‚â•3 do {Click(ùúö ) } ‚áù [Click(//a[2]) ], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

(Term)

(Seq)

{ùúö ‚Ü¶‚Üí //a[1] } ‚ä¢ Dscts(ùúñ, a)‚â•2 ‚áù //a[2] :: Dscts(ùúñ, a)‚â•3

valid(//a[2], ùúã2)

See above.

[ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[1] } ‚ä¢ foreach ùúö in Dscts(ùúñ, a)‚â•2 do {Click(ùúö ) } ‚áù [Click(//a[2]) ], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

(S-Cont)

{ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[1] } ‚ä¢ ùúö ‚áù //a[1]
[ùúã1, ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[1] } ‚ä¢ Click(ùúö ) ‚áù [Click(//a[1]) ], [ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[1] }

(Click)

See above.

[ùúã1, ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[1] } ‚ä¢ Click(ùúö ); foreach ùúö in Dscts(ùúñ, a)‚â•2 do {Click(ùúö ) } ‚áù [Click(//a[1]), Click(//a[2]) ], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

(Seq)

{ùë• ‚Ü¶‚Üí ‚ä•} ‚ä¢ Dscts(ùúñ, a)‚â•1 ‚áù //a[1] :: Dscts(ùúñ, a)‚â•2

valid(//a[1], ùúã1)

See above.

[ùúã1, ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•} ‚ä¢ foreach ùúö in Dscts(ùúñ, a)‚â•1 do {Click(ùúö ) } ‚áù [Click(//a[1]), Click(//a[2]) ], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

(S-Cont)

[ùúã1, ùúã2 ], {ùë• ‚Ü¶‚Üí ‚ä•} ‚ä¢ foreach ùúö in Dscts(ùúñ, a) do {Click(ùúö ) } ‚áù [Click(//a[1]), Click(//a[2]) ], [], {ùë• ‚Ü¶‚Üí ‚ä•, ùúö ‚Ü¶‚Üí //a[2] }

[ùúã1, ùúã2 ], ‚ä• ‚ä¢ foreach ùúö in Dscts(ùúñ, a) do {Click(ùúö ) } : [Click(//a[1]), Click(//a[2]) ]

(S-Init)

(Eval)

Figure 9. A derivation for the program in Example 3.1 using our trace semantics.

We illustrate our semantics on ùëÉ; Figure 9 shows its deriva-
tion. First of all, Eval returns two actions that are executed
in the first two iterations of ùëÉ, since Œ† has two DOMs. The
valid checks in S-Cont are used to guide our simulated exe-
cution. For ùëÉ, these checks all pass, as ùëÉ indeed produced Œ†.
However, consider the following ùëÉ ‚Ä≤:

foreach ùúö in Dscts(ùúñ, a) do {Click(ùúö /b)}

For ùëÉ ‚Ä≤, the checks may not pass as ‚Äú//a[1]/b‚Äù might not refer
to a valid node in DOM ùúã1. In that case, we will invoke the
S-Term rule, eventually producing a shorter action trace.

4 Web RPA Program Synthesis Problem

In this section, we formulate our program synthesis problem.

Definition 4.1. (Satisfaction). Given input data ùêº , an action
trace ùê¥ and a DOM trace Œ†, a web RPA program ùëÉ satisfies ùê¥,
if we have (1) Œ†, ùêº ‚ä¢ ùëÉ : ùê¥‚Ä≤ and (2) ùê¥ is consistent with a prefix
of ùê¥‚Ä≤ with respect to Œ†. In other words, ùëÉ can reproduce ùê¥.

Definition 4.1 requires checking consistency between two
traces of actions. To do this, we first define two actions ùëé1
and ùëé2 to be consistent, given a DOM ùúã, if ùëé1 and ùëé2 are of the
same type and their arguments match. Note that two XPath
arguments match each other, if they refer to the same DOM
node on ùúã. Then, two action traces ùê¥1 and ùê¥2 are consistent,
given a DOM trace Œ†, if the ùëñ-th action in ùê¥1 is consistent
with the ùëñ-th action in ùê¥2 given the ùëñ-th DOM in Œ†.

The reason that condition (2) uses ‚Äúprefix‚Äù, instead of re-
quiring ùê¥ to be consistent with ùê¥‚Ä≤ exactly, is because ùê¥ is in
general an incomplete trace. That is, ùê¥ may be a prefix of the
entire action trace of ùëÉ. In other words, our trace semantics
might produce a longer action trace than the demonstration.

Definition 4.2. (Generalization). Given input data ùêº , an ac-
tion trace ùê¥ and a DOM trace Œ†, a web RPA program ùëÉ
generalizes ùê¥, if we have (1) Œ†, ùêº ‚ä¢ ùëÉ : ùê¥‚Ä≤ and (2) ùê¥ is consis-
tent with a strict prefix of ùê¥‚Ä≤ given Œ†. In other words, ùëÉ not
only reproduces ùê¥ but also executes more actions after ùê¥.

Definition 4.2 requires ‚Äústrict prefix‚Äù, as our goal is to pre-
dict unseen actions beyond only reproducing those observed.
Definition 4.3. (Web RPA Program Synthesis Problem). Given
input data ùêº , an action trace ùê¥ = [ùëé1, ¬∑¬∑, ùëéùëö] and a DOM trace
Œ† = [ùúã1, ¬∑¬∑, ùúãùëö+1], find a web RPA program ùëÉ that generalizes
ùê¥, given ùêº and Œ†.

Intuitively, Definition 4.3 takes as input ùê¥ and Œ† where
ùëéùëñ is an action performed on ùúãùëñ , and it looks for a program
ùëÉ that can be used to predict an action ùëéùëö+1 that might be
performed on ùúãùëö+1. In general, we require Œ† be longer than
ùê¥; otherwise, we are not able find a program that generalizes.
In practice, we require Œ† have one more element than ùê¥,
because we can obtain the latest DOM without knowing the
user‚Äôs next action on it. Also note that, we may have multiple
programs that generalize ùê¥; therefore, we aim to synthesize
a smallest program in size.

5 Web RPA Program Synthesis Algorithm
5.1 Top-Level Rewrite-Based Synthesis Algorithm

Algorithm 1 shows the top-level synthesis algorithm. Our
key idea is to iteratively rewrite the action trace ùê¥ into a pro-
gram that generalizes ùê¥ given DOM trace Œ† and input data ùêº .
The algorithm is not destructive and maintains intermediate
rewrites; it heuristically picks a ‚Äúbest‚Äù program at the end.
Algorithm 1 maintains a worklist of tuples (ùëÉ, (cid:174)ùê¥, (cid:174)Œ†), where
ùëÉ = ùëÜ1; ¬∑¬∑; ùëÜùëô is a program rewritten from the input trace ùê¥.
(cid:174)ùê¥ = [ùê¥1, ¬∑¬∑, ùê¥ùëô ] is a list of action traces, and (cid:174)Œ† = [Œ†1, ¬∑¬∑, Œ†ùëô ]
is a list of DOM traces. We maintain the following invariant:
I1 : ùê¥1++ ¬∑ ¬∑ ++ùê¥ùëô = ùê¥ and Œ†1++ ¬∑ ¬∑ ++Œ†ùëô = [ùúã1, ¬∑¬∑, ùúãùëö]
Essentially, I1 says (cid:174)ùê¥ is a partition of ùê¥ and (cid:174)Œ† is a partition
of the first ùëö DOMs in Œ†. It is fairly easy to show I1 holds
for ùëÉ0, (cid:174)ùê¥0, (cid:174)Œ†0. The second invariant is:

I2 :

‚àÄùëñ ‚àà [1, ùëô], ùëÜùëñ satisfies ùê¥ùëñ given ùêº and Œ†ùëñ

which says that each ùëÜùëñ in ùëÉ satisfies the corresponding slice
ùê¥ùëñ . This is also trivially true for ùëÉ0, (cid:174)ùê¥0, (cid:174)Œ†0, as every ùëÜùëñ in ùëÉ0 is
a single loop-free statement. These invariants guarantee our

WebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

(cid:174)ùê¥0 := (cid:2) [ùëé1 ], ¬∑¬∑, [ùëéùëö ](cid:3); (cid:174)Œ†0 := (cid:2) [ùúã1 ], ¬∑¬∑, [ùúãùëö ](cid:3);

procedure Synthesize (ùê¥, Œ†, ùêº )
input: ùê¥ = [ùëé1, ¬∑¬∑, ùëéùëö ], Œ† = [ùúã1, ¬∑¬∑, ùúãùëö+1 ], and input data ùêº .
output: a program ùëÉ that generalizes ùê¥ given Œ† and ùêº .
1: ùëÉ0 := ùëé1; ¬∑¬∑; ùëéùëö;
2: ùëä := { (ùëÉ0, (cid:174)ùê¥0, (cid:174)Œ†0) }; (cid:101)ùëÉ := ‚àÖ;
3: while ùëä ‚â† ‚àÖ
4:
5:
6:
7: ùëä ‚Ä≤ := Validate(Œ©, ùëÉ, (cid:174)ùê¥, (cid:174)Œ†); ùëä := ùëä ‚à™ ùëä ‚Ä≤;
8: return Rank( (cid:101)ùëÉ );

(ùëÉ, (cid:174)ùê¥, (cid:174)Œ†) := ùëä .remove();
if ùëÉ generalizes ùê¥ given ùêº and Œ† then (cid:101)ùëÉ .add(ùëÉ );
Œ© := Speculate(ùëÉ );

Algorithm 1. Top-level synthesis algorithm.

rewrites always satisfy the specification ùê¥. Intuitively, this
is because every statement ùëÜùëñ in ùëÉ satisfies each slice ùê¥ùëñ in
ùê¥, thus the ‚Äúconcatenation‚Äù of all ùëÜùëñ ‚Äôs, that is ùëÉ, would also
satisfy the concatenation of all ùê¥ùëñ ‚Äôs, which is ùê¥.

The worklist algorithm maintains I1 and I2, too. It tracks
a worklist ùëä of programs that satisfy ùê¥ but only stores those
generalizable programs into (cid:101)ùëÉ. In particular, the algorithm
first removes a tuple (ùëÉ, (cid:174)ùê¥, (cid:174)Œ†) from ùëä (line 4). It then checks
if ùëÉ generalizes ùê¥; if so, it adds ùëÉ into (cid:101)ùëÉ (line 5). The algorithm
grows the worklist using our speculate-and-validate method
to rewrite ùëÉ into more programs all of which maintain I1
and I2 (lines 6-7). Intuitively, given ùëÉ = ùëÜ1; ¬∑¬∑; ùëÜùëô , this rewrite
process replaces a slice of statements ùëÜùëñ, ¬∑¬∑, ùëÜ ùëó in ùëÉ with a loop
statement ùëÜ ‚Ä≤ such that ùëÜ1; ¬∑¬∑; ùëÜùëñ‚àí1; ùëÜ ‚Ä≤; ùëÜ ùëó+1; ¬∑¬∑; ùëÜùëô also meets I1
and I2. Note that, because a statement in ùëÉ might itself be
loopy, we can generate nested loops (from the inside out).

Challenges. While conceptually simple, this idea is tech-
nically quite challenging to realize. A key challenge is that, it
is in general quite hard to encode all patterns as rules, if we
follow standard rewrite-based synthesis approaches [43, 63]:
our DSL has multiple types of loops, a loop body may have
multiple statements that may use loop variables in different
ways, loops could be nested, etc. There are too many cases.
Even if we can define these rules, it is not clear how efficient
this rule-based approach is, given the trace may correspond
to an arbitrarily complex program. Let us further illustrate
this challenge using the following example.
Example 5.1. Consider the following program ùëÉ, which is a
simplified version of ùëÉ2 in Figure 5(c). It scrapes information
from a list of items spanned across multiple pages.

while true do

foreach ùúö in Dscts(ùúñ, a) do

ScrapeText(ùúö )
ScrapeText(ùúö /b)

Click(c)

Suppose we are given the following action trace ùê¥ for ùëÉ:

[ ScrapeText(//a[1]), ScrapeText(//a[1]/b), ¬∑¬∑,
ScrapeText(//a[20]), ScrapeText(//a[20]/b),
Click(c),
ScrapeText(//a[1]), ScrapeText(//a[1]/b), ¬∑¬∑,
ScrapeText(//a[9]), ScrapeText(//a[9]/b) ]

(ùëé1, ¬∑¬∑, ùëé40)
(ùëé41)

(ùëé42, ¬∑¬∑, ùëé59)

(cid:12)
(cid:12) ùëÜ‚Ä≤

for (ùëÜ‚Ä≤

ùëù, ùúö, ùëÅ ) ‚àà Anti-Unify(ùëÜùëù, ùëÜùëû )

ùëò ‚àà Parametrize(ùëÜùëò , ùúö, ùúå), ùëò ‚àà [ùëñ, ùëó ] \{ùëù }(cid:9);

ùúå := FirstSelector(ùëÅ );
(cid:101)ùëÉ ‚Ä≤ := (cid:8)ùëÜ‚Ä≤
ùëù ; ¬∑¬∑; ùëÜ‚Ä≤
ùëñ ; ¬∑¬∑; ùëÜ‚Ä≤
ùëó
(cid:101)ùëÜ‚Ä≤ := (cid:8)foreach ùúö in ùëÅ do ùëÉ ‚Ä≤ | ùëÉ ‚Ä≤ ‚àà (cid:101)ùëÉ ‚Ä≤(cid:9);
Œ© := Œ© ‚à™ { (ùëÜ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ) | ùëÜ‚Ä≤ ‚àà (cid:101)ùëÜ‚Ä≤ };

procedure Speculate (ùëÉ )
input: ùëÉ = ùëÜ1; ¬∑¬∑; ùëÜùëô .
output: a set Œ© of speculative rewrites of the form (ùëÜ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ).
1: Œ© := ‚àÖ;
2: for ùëñ ‚â§ ùëù ‚â§ ùëó < ùëû s.t. [ùëÜùëñ, ¬∑¬∑, ùëÜùëù, ¬∑¬∑, ùëÜ ùëó , ¬∑¬∑, ùëÜùëû ] ‚äë [ùëÜ1, ¬∑¬∑, ùëÜùëô ] & ùëó ‚àíùëñ + 1 = ùëû ‚àíùëù
3:
4:
5:
6:
7:
8: for ùëñ ‚â§ ùëù ‚â§ ùëó < ùëû s.t. [ùëÜùëñ, ¬∑¬∑, ùëÜùëù, ¬∑¬∑, ùëÜ ùëó , ¬∑¬∑, ùëÜùëû ] ‚äë [ùëÜ1, ¬∑¬∑, ùëÜùëô ] & ùëó ‚àíùëñ + 1 = ùëû ‚àíùëù
9:
10:
11:
12:
13:
14: for ùëñ < ùëù < ùëû s.t. [ùëÜùëñ, ¬∑¬∑, ùëÜùëù, . . . , ùëÜùëû ] ‚äë [ùëÜ1, ¬∑¬∑, ùëÜùëô ] & ùëù ‚àí ùëñ + 1 = ùëû ‚àí ùëù
15:
16:
17: return Œ©;

ùúÉ := FirstValuePath(ùëâ );
(cid:12)
(cid:101)ùëÉ ‚Ä≤ := (cid:8)ùëÜ‚Ä≤
ùëñ ; ¬∑¬∑; ùëÜ‚Ä≤
(cid:12) ùëÜ‚Ä≤
(cid:101)ùëÜ‚Ä≤ := (cid:8)foreach ùúó in ùëâ do ùëÉ ‚Ä≤ (cid:12)
Œ© := Œ© ‚à™ { (ùëÜ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ) | ùëÜ‚Ä≤ ‚àà (cid:101)ùëÜ‚Ä≤ };

ùëÜ‚Ä≤ := while true do {ùëÜùëñ, ¬∑¬∑, ùëÜùëù }; Œ© := Œ© ‚à™ { (ùëÜ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ) };

ùëò ‚àà Parametrize(ùëÜùëô , ùúó, ùúÉ ), ùëò ‚àà [ùëñ, ùëó ] {ùëù }(cid:9);

ùëù, ùúó, ùëâ ) ‚àà Anti-Unify(ùëÜùëù, ùëÜùëû )

if ùëÜùëù = ùëÜùëû = Click(ùúå) then

(cid:12) ùëÉ ‚Ä≤ ‚àà (cid:101)ùëÉ ‚Ä≤(cid:9);

ùëù ; ¬∑¬∑; ùëÜ‚Ä≤
ùëó

for (ùëÜ‚Ä≤

Algorithm 2. Speculate procedure.

Here, ùëé1, ¬∑¬∑, ùëé41 correspond to all actions from the first itera-
tion of the while loop, including 40 actions from foreach.
The remaining actions ùëé42, ¬∑¬∑, ùëé59 correspond to a partial ex-
ecution of the second iteration of while. We also record a
DOM trace [ùúã1, ¬∑¬∑, ùúã60] as well, where ùëéùëñ is performed on ùúãùëñ
and ùúã60 is the latest DOM.

In order to generate ùëÉ from ùê¥, the standard rewrite-based
synthesis approaches [43, 63] apply a set of predefined sound
rewrite rules to rewrite ùê¥ to ùëÉ. Conceptually, it would use
these rules to essentially identify iteration boundaries and
repetitive patterns, in order to eventually ‚Äúreroll‚Äù the trace
back to the desired program with loops. That is an enormous
space which might contain only a few correct rewrites.

In this work, we take a different route which incorporates
the ‚Äúguess-and-check‚Äù idea into the overall rewrite process.
Our approach does not generate true rewrites directly using
sound rewrite rules; instead, it first speculates likely rewrites
which are then validated using our trace semantics.

5.2 Speculation

We first describe our speculation procedure; see Algorithm 2.
It takes as input a program ùëÉ = ùëÜ1; ¬∑¬∑; ùëÜùëô and returns a set Œ©
of speculative rewrites, or s-rewrites, of the form (ùëÜ ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ).
Here, ùëÜ ‚Ä≤ is a loop statement whose first iteration corresponds
to ùëÜùëñ ; ¬∑¬∑; ùëÜ ùëó from ùëÉ. That is, they yield the same trace (this
is guaranteed by construction). However, an s-rewrite may
not be a true rewrite: a true rewrite must have more than
one iterations exhibited in ùëÉ, but an s-rewrite is only guaran-
teed to have its first iteration exhibited in ùëÉ. Nevertheless,
s-rewrites have a very nice property: they are much easier to
generate, and they over-approximate the set of true rewrites.
Our technique makes use of this property.

To generate s-rewrites that tightly over-approximate the
set of true rewrites, we follow existing rule-based approaches
in prior work [43, 63]. However, our rules are designed to

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

(1)

(2)

(3)

(4)

ùúö fresh ùúö ‚ä¢ ùúå1 ‚äõ ùúå2 ‚Ü† (ùëõ, ùëÅ )
‚ä¢ Click(ùúå1) ‚äõ Click(ùúå2) ‚Ü† (Click(ùëõ), ùúö, ùëÅ )

ùúö ‚Ä≤ fresh ùúö ‚Ä≤ ‚ä¢ ùëÅ1 ‚äõ ùëÅ2 ‚Ü† (ùëÅ , ùëÅ ‚Ä≤) ùëÉ1, ùëÉ2 alpha equivalent
ùëà = (foreach ùúö 1 in ùëÅ do ùëÉ1, ùúö ‚Ä≤, ùëÅ ‚Ä≤)
‚ä¢ foreach ùúö 1 in ùëÅ1 do ùëÉ1 ‚äõ foreach ùúö 2 in ùëÅ2 do ùëÉ2 ‚Ü† ùëà

ùúó fresh ùúÉ1 = ùúÉ [1] [ùëú1 ]¬∑¬∑[ùëúùëü ] ùúÉ2 = ùúÉ [2] [ùëú1 ]¬∑¬∑[ùëúùëü ]
ùëà = (EnterData(ùúå, ùúó [ùëú1 ]¬∑¬∑[ùëúùëü ]), ùúó, ValuePaths(ùúÉ ))
‚ä¢ EnterData(ùúå, ùúÉ1) ‚äõ EnterData(ùúå, ùúÉ2) ‚Ü† ùëà

‚àÉùúå‚Ä≤
‚àÉùúå‚Ä≤

1 ‚àà AlternativeSelectors(ùúå1): ùúå‚Ä≤
2 ‚àà AlternativeSelectors(ùúå2): ùúå‚Ä≤

1 = ùëõ (cid:2)ùúö ‚Ü¶‚Üí ùúå/ùúô [1](cid:3)
2 = ùëõ (cid:2)ùúö ‚Ü¶‚Üí ùúå/ùúô [2](cid:3)

ùúö ‚ä¢ ùúå1 ‚äõ ùúå2 ‚Ü† (cid:0)ùëõ, Children(ùúå, ùúô)(cid:1)

(5)

ùúö ‚ä¢ ùúå1 ‚äõ ùúå2 ‚Ü† (ùëõ, ùëÅ )
ùúö ‚ä¢ Children(ùúå1, ùúô) ‚äõ Children(ùúå2, ùúô) ‚Ü† (Children(ùëõ, ùúô), ùëÅ )
Figure 10. Anti-Unify rules.
detect patterns partially, instead of completely. A key step
in our approach is to inspect two statements ùëÜùëù, ùëÜùëû in ùëÉ and
generate a loop ùëÜ ‚Ä≤ such that, ùëÜùëù, ùëÜùëû correspond to the same
statement from ùëÜ ‚Ä≤ but ùëÜùëù ‚Äúcomes‚Äù from its first iteration and
ùëÜùëû from its second. For example, lines 2-7 in Algorithm 2
generate selector loops. It first enumerates all slices ùëÜùëñ, ¬∑¬∑, ùëÜ ùëó
in ùëÉ assuming ùëÜùëñ and ùëÜ ùëó correspond to the start and end of
the first iteration (line 2). Then, it tries to ‚Äúmerge‚Äù ùëÜùëù, ùëÜùëû into
a parametrized statement ùëÜ ‚Ä≤
ùëù by calling Anti-Unify (line 3).
Similarly, lines 8-13 handle value path loops.

Anti-unification. In the context of logic programming,
anti-unification [13, 14] refers to the process of generating
two terms ùë°1 and ùë°2 into a least general template ùúè for which
there exists substitutions ùõº1 and ùõº2, such that ùúè (ùõº1) = ùë°1 and
ùúè (ùõº2) = ùë°2. It has been used in prior work [56] to generate
code fixes; in this work, we use anti-unification to synthesize
loops. Figure 10 gives some representative rules. In a nutshell,
our procedure returns a set of tuples (ùëÜ ‚Ä≤
ùëù is
a more general statement using loop variable ùúö in the target
loop ùëÜ ‚Ä≤, and ùëÅ is the selectors that ùëÜ ‚Ä≤ loops over.

ùëù, ùúö, ùëÅ ), where ùëÜ ‚Ä≤

Let us take rule (1) as an example. Here, it anti-unifies two
Click statements whose selectors differ at only one index in
their XPath expressions. Specifically, it calls rule (4) that anti-
unifies selectors ùúå1 and ùúå2 given a fresh variable ùúö . Intuitively,
it looks for a general selector ùëõ that uses variable ùúö such that
ùëõ instantiates to ùúå ‚Ä≤
2, respectively. Note that rule (4)
considers alternative selectors; this is necessary for inducing
more general programs. Rule (4) also returns Children(ùúå, ùúô)
which is the collection that the target loop statement ùëÜ ‚Ä≤ loops
over. We have a very similar rule that anti-unifies ùúå1, ùúå2 and
generates Dscts(ùúå, ùúô), though it is not shown here.

1 and ùúå ‚Ä≤

Rule (2) anti-unifies two selector loops by anti-unifying
their respective collections ùëÅ1 and ùëÅ2, which is conditional
on their loop bodies ùëÉ1, ùëÉ2 being alpha-equivalent. Rule (3)
performs anti-unification for EnterData statements.

Example 5.2. Consider the action trace ùê¥ from Example 5.1.
Line 2 of our Speculate procedure will consider all possible
tuples (ùëñ, ùëù, ùëó, ùëû), where ùëñ, ùëó are the start and end of the first
iteration of a loop to be generated. Consider (1, 1, 2, 3), which

(1)

ùëÜ = Click(ùúå)
ùúö, ùúå‚Ä≤ ‚ä¢ Click(ùúå) ‚Ü† ùëÜ

(2)

‚àÉùúå‚Ä≤‚Ä≤ ‚àà AlternativeSelectors(ùúå) : ùúå‚Ä≤‚Ä≤ = ùúå‚Ä≤/ùúå‚Ä≤‚Ä≤‚Ä≤
ùúö, ùúå‚Ä≤ ‚ä¢ Click(ùúå) ‚Ü† Click(ùúö /ùúå‚Ä≤‚Ä≤‚Ä≤)

(3)

ùëÜ = foreach ùúö in ùëÅ do ùëÉ
ùúö ‚Ä≤, ùúå ‚ä¢ foreach ùúö in ùëÅ do ùëÉ ‚Ü† ùëÜ

(4)

ùúö ‚Ä≤, ùúå ‚ä¢ ùëÅ ‚Ü† ùëÅ ‚Ä≤
ùúö ‚Ä≤, ùúå ‚ä¢ foreach ùúö in ùëÅ do ùëÉ ‚Ü† foreach ùúö in ùëÅ ‚Ä≤ do ùëÉ

(5)

ùëÅ = Children(ùúå, ùúô)
ùúö, ùúå‚Ä≤ ‚ä¢ Children(ùúå, ùúô) ‚Ü† ùëÅ

(6)

ùúå = ùúå‚Ä≤/ùúå‚Ä≤‚Ä≤ ùëÅ = Children(ùúö /ùúå‚Ä≤‚Ä≤, ùúô)
ùúö, ùúå‚Ä≤ ‚ä¢ Children(ùúå, ùúô) ‚Ü† ùëÅ

Figure 11. Parametrize rules.

corresponds to the first iteration of the foreach loop in ùëÉ.
Anti-Unify at line 3 generates (ScrapeText(ùúö ), ùúö, Dscts(ùúñ, a))
from ùëÜùëù, ùëÜùëû, which are ùëé1, ùëé3 in this case. Here, ScrapeText(ùúö )
is the desired statement in the foreach loop‚Äôs body. Further-
more, it also gives the selectors expression, Dscts(ùúñ, a), that
the target foreach loop iterates over. Yet, our Anti-Unify
procedure does not generate the rest of the body.

Parametrization Anti-Unify essentially creates a skele-
ton of the entire loop ùëÜ ‚Ä≤: it gives one statement in the loop
body but we still need to construct the rest. This is exactly
what Algorithm 2 does at lines 4-7. In particular, it first ob-
tains the binding ùúö ‚Ü¶‚Üí ùúå in the first iteration. Then, given this
binding, it uses the Parametrize procedure to construct the
entire loop. Figure 11 presents some representative rules. For
instance, rules (1) and (2) parametrize a Click statement. Rule
(1) keeps the Click as is, since it is possible that a statement
inside a loop does not use the variable. Rule (2) parametrizes
the Click if the selector ùúå ‚Ä≤ that variable ùúö binds to is a prefix
of some alternative selector for the argument ùúå in Click. Rules
(3) and (4) parametrize a selectors loop in a very similar way,
though it uses additional rules (5) and (6) to handle selectors.

Example 5.3. Consider the output of Anti-Unify, namely,
(ScrapeText(ùúö ), ùúö, Dscts(ùúñ, a)), in Example 5.2. Given this output,
line 4 of Algorithm 2 obtains the first selector ùúå of Dscts(ùúñ, a);
that is, ùúå = //a[1]. Then, we parametrize each of the remain-
ing statements within [ùëñ, ùëó]‚Äîin our case, only ùëé2. One state-
ment given by Parametrize is ScrapeText(ùúö /b), which is the
desired statement in ùëÉ. Therefore, (cid:101)ùëÜ ‚Ä≤ at line 6 of Algorithm 2
includes the desired foreach loop. Finally, line 7 adds the
following s-rewrite to Œ©.

(cid:16)

foreach ùúö in Dscts(ùúñ, a) do

ScrapeText(ùúö )
ScrapeText(ùúö /b)

, ùëé1, ùëé2

(cid:17)

While this loop corresponds to ùëé1, ¬∑¬∑, ùëé40, our Speculate pro-
cedure only guarantees its first iteration corresponds to ùëé1, ùëé2.

5.3 Validation

As we can see, s-rewrites are fairly easy to generate but may
be spurious. That is, they might not rewrite beyond the first
iteration. Can we filter them out, and if so, how? Our idea is to
validate them using our trace semantics; see Algorithm 3. In
a nutshell, given an s-rewrite ùëÜ ‚Ä≤ corresponding to ùëÜùëñ, ¬∑¬∑, ùëÜ ùëó , the

WebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

procedure Validate (Œ©, ùëÉ, (cid:174)ùê¥, (cid:174)Œ†)
input: a set Œ© of s-rewrites of the form (ùëÜ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ).
input: a program ùëÉ = ùëÜ1; ¬∑¬∑; ùëÜùëô that each s-rewrite in Œ© may apply to.
input: (cid:174)ùê¥ = [ùê¥1, ¬∑¬∑, ùê¥ùëô ], (cid:174)Œ† = [Œ†1, ¬∑¬∑, Œ†ùëô ].
output: a set ùëä of true rewrites of the form (ùëÉ ‚Ä≤, (cid:174)ùê¥‚Ä≤, (cid:174)Œ†‚Ä≤) s.t. I1, I2 hold.
1: ùëä := ‚àÖ;
2: for (ùëÜ‚Ä≤, ùëÜùëñ, ùëÜ ùëó ) ‚àà Œ©
3:
4:
5:
6:
7:
8:
9: return ùëä ;

ùëÉ ‚Ä≤ := ùëÜ1; ¬∑¬∑; ùëÜùëñ‚àí1; ùëÜ‚Ä≤; ùëÜùëü +1; ¬∑¬∑; ùëÜùëô ;
(cid:174)ùê¥‚Ä≤ := [ùê¥1, ¬∑¬∑, ùê¥ùëñ‚àí1, ùê¥‚Ä≤, ùê¥ùëü +1, ¬∑¬∑, ùê¥ùëô ];
(cid:174)Œ†‚Ä≤ := [Œ†1, ¬∑¬∑, Œ†ùëñ‚àí1, Œ†‚Ä≤, Œ†ùëü +1, ¬∑¬∑, Œ†ùëô ];
ùëä := ùëä ‚à™ { (ùëÉ ‚Ä≤, (cid:174)ùê¥‚Ä≤, (cid:174)Œ†‚Ä≤) };

ùê¥‚Ä≤ := Execute(ùëÜ‚Ä≤, Œ†ùëñ ++¬∑¬∑ ++Œ†ùëô , ùêº );
if ‚àÉùëü ‚àà [ ùëó + 1, ùëô ] : ùê¥‚Ä≤ = ùê¥ùëñ ++¬∑¬∑ ++ùê¥ùëü given Œ†ùëñ ++¬∑¬∑ ++Œ†ùëü then

Algorithm 3. Validate procedure.

algorithm checks whether it is a true rewrite or not; if so, it
returns a slice of statements ùëÜùëñ, ¬∑¬∑, ùëÜùëü in ùëÉ that can be rewritten
to ùëÜ ‚Ä≤. We require ùëü > ùëó, because we want ùëÜ ‚Ä≤ to rewrite a slice
of statements beyond ùëÜ ùëó (i.e., the first iteration). Towards this
goal, Validate first executes ùëÜ ‚Ä≤ against the concatenation of
DOM traces from ùëñ to ùëô, yielding an action trace ùê¥‚Ä≤ (line 3).
Then, line 4 checks if ùëÜ ‚Ä≤ is a true rewrite; if so, it obtains the
rewrite ùëÉ ‚Ä≤ (line 5) and the matching traces (lines 6-7), which
are then added to ùëä (line 8). Note that invariants I1, I2 hold
for this rewrite (ùëÉ ‚Ä≤, (cid:174)ùê¥‚Ä≤, (cid:174)Œ†‚Ä≤), as ùê¥‚Ä≤ is obtained by executing ùëÜ ‚Ä≤
using our trace semantics and is also checked at line 4.

Example 5.4. Consider the s-rewrite (ùëÜ ‚Ä≤, ùëé1, ùëé2) returned by
Speculate in Example 5.3. By construction, the first iteration
of ùëÜ ‚Ä≤ produces [ùëé1, ùëé2]. To validate this s-rewrite, we evaluate
ùëÜ ‚Ä≤ against [ùúã1, ¬∑¬∑, ùúã60] using our trace semantics, which gives
an action trace ùê¥‚Ä≤ = [ùëé1, ¬∑¬∑, ùëé40]. This is indeed a true rewrite;
thus, Validate returns ùëÜ ‚Ä≤ together with its matching action
trace [ùëé1, ¬∑¬∑, ùëé40], indicating ùëÜ ‚Ä≤ rewrites actions ùëé1, ¬∑¬∑, ùëé40.

5.4 Incremental Synthesis

Recall from Figure 3 that our synthesizer is used in an itera-
tive fashion: it predicts the next action given the current trace
with ùëö actions, where ùëö increases as the task progresses.
Therefore, we invoke our synthesis algorithm incrementally.
This is done by simply sharing the worklist in Algorithm 1
across synthesis runs. Suppose we want to synthesize from a
trace with ùëö actions, given the worklist ùëä from the previous
run. Instead of starting from scratch (line 2, Algorithm 1),
we resume from ùëä ‚à™ùëä ‚Ä≤, where ùëä ‚Ä≤ contains those programs
removed from ùëä (line 4) in the previous run. This essentially
makes the entire rewrite process across runs not destructive.

5.5 Soundness and Completeness
Theorem 5.5. Given action trace ùê¥, DOM trace Œ† and input
data ùêº , if there exists a web RPA program that generalizes ùê¥
and in which every loop has at least two iterations exhibited
in ùê¥, then our synthesis algorithm would return a program
that generalizes ùê¥ given Œ† and ùêº .

6 Human-in-the-Loop Interaction Model

In this section, we describe our system interaction design ra-
tionale and user interface. Our overall design goal is to reduce
the gulfs of execution and evaluation for novice users [45].
That is, through our interface, we aim to help users better un-
derstand what is going on in the system (i.e., evaluation) as
well as help them execute intended actions (i.e., execution).
To achieve this goal, we designed a user interaction model
that combines PBD and user interaction in a human-in-the-
loop process. We highlight some key features below.

Demo-auth-auto workflow. As illustrated in Section 2,
there are three phases when using our tool: (a) a demonstra-
tion phase where the user manually performs a few actions,
(b) an authorization phase where the user accepts or rejects
predictions, and (c) an automation phase where our tool auto-
matically executes the program. Our system could transition
from one phase to another (automatically or manually).

Data entry via drag-and-drop. Instead of manually typ-
ing strings from the input data source, our interface supports
drag-and-drop. This design not only simplifies the data entry
process but also makes synthesis easier.

Action highlighting. Each action performed on the page
is highlighted. In addition, during the demonstration phase,
our system also highlights DOM nodes that are hovered over.
These designs help users better interact with our system.

Prediction authorization. During the authorization phase,

each predicted action requires user approval before it is exe-
cuted. Our user interface visualizes predictions in an easy-to-
examine manner, which helps reduce the gulf of evaluation.
Navigating across multiple predictions. In case there
are multiple predictions, our interface will show a navigation
arrow which allows users to inspect each of them and accept
the desired one, which helps resolve ambiguity.

7 Evaluation

In this section, we describe a series of experiments that are
designed to answer the following research questions:
‚Ä¢ Q1: Can WebRobot‚Äôs synthesis engine effectively synthe-

size web RPA programs from demonstrations?

‚Ä¢ Q2: How important are the ideas proposed in Section 5?
‚Ä¢ Q3: How well does WebRobot work end-to-end (including

both front-end and back-end) in practice?

‚Ä¢ Q4: How does WebRobot‚Äôs performance compare against

existing rewrite-based synthesis approaches?
Implementation. WebRobot has been implemented with
the proposed ideas as well as several additional optimizations.
More details can be found in the extended version [22].

Benchmarks. We also constructed a suite of benchmarks
for web RPA. In particular, we first scraped all posts under
the ‚ÄúData Extraction and Web Screen Scraping‚Äù topic from
the iMacros forum. Then, we retained every post that cor-
responds to a web RPA task with a working URL (e.g., we
filter out posts regarding ‚Äúhow to use iMacros‚Äù).

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

Figure 12. Main results for Q1: (a) accuracy (bar chart), (b) synthesis time (box plot), and (c) whether the final synthesized
programs are intended (‚Ä¢/√ó marks near the top). In particular, benchmarks are sorted in ascending order based on accuracy.
For each benchmark, we report quartile statistics of the synthesis times across all tests for which we can produce a prediction
within the timeout (1 sec). If the final synthesized program is intended, we mark ‚Ä¢ at the top for that benchmark; otherwise, √ó.

Ground-truth programs. For each benchmark, we have
also manually written a program that can automate the cor-
responding task using the Selenium WebDriver framework.
These programs are treated as the ‚Äúground-truth‚Äù programs.
Statistics of benchmarks. In total, we collected 76 bench-
marks with their corresponding ground-truth programs. In
particular, all of these benchmarks involve data extraction,
29 of them involve data entry, 60 require navigation across
webpages, and 33 involve pagination. Some benchmarks may
involve multiple types of actions: for instance, 28 of them
involve data entry, data extraction, and webpage navigation.
The ground-truth programs consist of 36.3 lines of code on
average (max being 142). In general, it took us 30 minutes to
a few hours to implement a working Selenium program.

7.1 Q1: Evaluating WebRobot‚Äôs Synthesis Engine

Recall that our synthesizer takes as input (1) a demonstrated
action trace ùê¥ = [ùëé1, ¬∑¬∑, ùëéùëö], (2) a DOM trace Œ† = [ùúã1, ¬∑¬∑, ùúãùëö+1],
and (3) an optional data source ùêº . It returns a program ùëÉ that
generalizes ùê¥ given Œ† and ùêº . That is, ùëÉ not only reproduces
ùê¥ but also predicts a next action ùëéùëö+1. Thus, our synthesis
goal is to generate ùëéùëö+1 efficiently and accurately.

Setup. To evaluate our synthesis efficiency and accuracy,
we designed the following experiment. First, for each bench-
mark, we instrumented its ground-truth program ùëÉgt such
that ùëÉgt would record every action it executes as well as
all intermediate DOMs. Hence, we can obtain the entire ac-
tion trace ùê¥gt = [ùëé1, ¬∑¬∑, ùëéùëõ] and DOM trace Œ†gt = [ùúã1, ¬∑¬∑, ùúãùëõ]7.
Here, ùëé1 is the first action performed on ùúã1 and ùëéùëõ is the last
action on ùúãùëõ. We also ensure that the recorded actions are in
the same trace language defined in Section 3. We convert the
recorded selectors used in ùëÉgt to absolute XPath expressions.
The reason is because WebRobot‚Äôs front-end records actions
using absolute XPath during user interactions and we aim
to simulate that in this experiment. Note that this actually
makes synthesis more challenging since we necessarily need
to consider alternative selectors in order to synthesize ùëÉgt.
For those benchmarks involving programmatic data entry,
we manually constructed a data source ùêº with 100 entries.8

7We terminate ùëÉgt after 500 actions in case it unnecessarily takes long to
finish. That is, we may use a prefix of ùëÉgt‚Äôs entire trace in this experiment.
8Fun fact: we leveraged WebRobot when collecting these data sources.

Given ùê¥gt and Œ†gt, we generate ùëõ ‚àí1 tests for the synthesis
engine. That is, for the ùëòth test, we are given ùê¥ùëò = [ùëé1, ¬∑¬∑, ùëéùëò ]
with the first ùëò actions in ùê¥gt and Œ†k+1 = [ùúã1, ¬∑¬∑, ùúãùëò+1] with
the first ùëò + 1 DOMs in Œ†gt, and our goal is to synthesize a
program that predicts ùëéùëò+1. In this setting, we define accuracy
as the percentage of tests for which we can generate a correct
prediction that is equivalent to the ground-truth action. For
efficiency, we calculate the quartile statistics of the synthesis
times across all tests that we can generate predictions for. In
this experiment, we use 1 second as the timeout per test.

Main results. Overall, as shown in Figure 12, our synthe-
sis engine solved most benchmarks with both high accuracy
and efficiency. In particular, for 68% of the benchmarks, it
achieves at least 95% accuracy within 0.5 seconds per pre-
diction. Furthermore, it generates desired programs for 91%
of the benchmarks. We note that it does not need the entire
trace (with 500 actions) to generate those desired programs;
rather, it typically generalizes with a few dozens of actions
(and at most a couple hundreds). Also note that only a very
small number of these actions (typically around 10) are man-
ually demonstrated. Therefore, we believe our synthesis en-
gine can be used in practice to interactively automate web
RPA tasks. On average, the final synthesized programs have
6 statements and the largest program has 18. WebRobot can
also synthesize programs with complex nesting structures:
32 of them involve doubly-nested loops and 6 involve at least
three levels of nesting. Thus, we believe our synthesis engine
has the potential to scale to complex web RPA tasks.

In what follows, we discuss some interesting findings.
Ambiguity. The synthesis engine generated multiple pro-
grams for 59 of our benchmarks. For 21 of them, it generated
multiple predictions. The maximum numbers of synthesized
programs and predictions are 101 and 6 respectively. This
shows that web RPA is a domain with a fair amount of ambi-
guity, where there could exist multiple semantically different
programs satisfying the same specification.

Pagination beyond ‚Äúnext page‚Äù. Some websites use other
mechanisms for pagination. For instance, b9 involves a job
search site9 which performs pagination using page numbers
and a ‚Äúnext 10 pages‚Äù button. We do not support such pagina-
tion mechanisms yet. The reason b9 has an 88% accuracy is

9https://www.timesjobs.com/

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475760.00.20.40.60.81.0Synthesistime(s)0.00.20.40.60.81.0AccuracyWebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

because it synthesized a program with a sequence of selector
loops, which solved the tests but is not intended.

Complex selectors. Some benchmarks need selectors with
multiple attributes in order to be automated. For example, b6
involves scraping players information for matches that have
either ‚Äúmatch‚Äù or ‚Äúmatch highlight‚Äù class. Our DSL currently
does not support such ‚Äúdisjunctive logics‚Äù for selectors. Some
other benchmarks (such as b1-3) also have similar issues.

Others. The reason that b7 has a relatively low accuracy
(80%), albeit an intended program was synthesized, is because
its trace is relatively short (with 51 actions in total) and the
intended program was synthesized after the first 10 actions.
This is also the case for some benchmarks, such as b8, b10-12.

7.2 Q2: Ablation Studies of the Synthesis Engine
Setup. We performed ablation studies to quantify the impact
of our ideas. In particular, we consider the following variants.
‚Ä¢ No selector: We modified the AlternativeSelectors function
from Figures 10 and 11 to always return the input selector.
Effectively, this variant can only use full XPath expressions
from the trace without considering alternative selectors.
‚Ä¢ No incremental: This variant does not reuse rewrites from
prior synthesis runs. It always starts from scratch if the
program ùëÉùëò generated for the ùëòth test fails to predict ùëéùëò+1.
We conducted the same experiment described in Section 7.1
using these variants. Note that we do not include an ablation
for the idea of speculative rewriting. The reason is because
it is not easy to ‚Äúdisable‚Äù speculation without fundamentally
changing our algorithm. Instead, please see Section 7.4 for a
comparison against a baseline implemented using egg.

Main results. As shown in Table 1, our main take-away is
that it is important to perform selector search and incremen-
tal synthesis in order to synthesize programs both accurately
and efficiently. For instance, without considering alternative
selectors, it only solves 38 benchmarks and the average accu-
racy drops to 57%. In terms of synthesis time, all techniques
are fairly efficient (for tests that terminate within 1 second).

7.3 Q3: Evaluating WebRobot End-to-End
User study setup. To evaluate WebRobot end-to-end and
access whether it helps users complete web RPA tasks, we
conducted a user study involving 8 participants (avg. age 21)
from the lead author‚Äôs institution. All participants are under-
graduate students with an average of 4 years of programming
experience. Each participant was asked to complete 5 tasks
sampled from our benchmarks, divided in three phases.
‚Ä¢ Phase 1 has one single-page scraping task.
‚Ä¢ Phase 2 includes two scraping tasks that involve webpage

navigation and pagination.

‚Ä¢ Phase 3 has two tasks that involve data entry. In particular,
given a list of keywords, the user needs to perform search
on the website using each keyword and then scrape certain
information from the search result of each keyword.

Table 1. Main results for ablation studies in Q2.

Variants
Full-fledged
No selector
No incremental

# Benchmarks Accuracy Accuracy Time per test
(average)

(average)

(median)

solved

69
38
45

98%
88%
96%

90%
57%
72%

23ms
54ms
32ms

For each phase, participants started by watching a tutorial
and replicating a demo task. Then, they worked on the main
tasks. Each participant had one hour in total for all 5 tasks.
User study results. All participants were able to success-
fully automate all tasks using WebRobot. In particular, par-
ticipants demonstrated 6-10 actions before WebRobot could
automate the rest of the task. For each phase, the average
time it took them to provide demonstrations is (in seconds):
16.88 (SD=3.80, phase 1), 19.44 (SD=11.48, phase 2), and 64.44
(SD=22.58, phase 3). Furthermore, all participants were able
to use WebRobot to resolve ambiguity interactively. Finally,
according to a follow-up survey, all eight participants gave
positive feedback on the usability of our tool: for instance,
they thought WebRobot was ‚Äúquite decent‚Äù (P4), experience
was ‚Äúsmooth‚Äù (P8), and it ‚Äúcan apply to many scenarios‚Äù (P2).
More comprehensive end-to-end testing results. To gain
a more comprehensive understanding on how WebRobot
works end-to-end, we tested it on all of our 76 benchmarks.
While this experiment is inevitably biased because the testers
are developers of the tool, we believe it complements the user
study and hence is still valuable. A benchmark is counted as
‚Äúsolved‚Äù if we can use WebRobot to synthesize the intended
program which can automate the benchmark.10 Overall, we
solved 76% of the benchmarks by interactively demonstrating
around 10 actions. We also found it necessary to resolve ambi-
guity when solving these benchmarks. Among the remaining
18 benchmarks, 7 failed due to the issues from WebRobot‚Äôs
back-end (see Section 7.1), and 11 were due to limitations of
our front-end. For instance, our current front-end does not
fully support replaying certain actions in a few situations,
which accounts for 7 cases.

Discussion. Comparing the end-to-end testing conducted
by ourselves (i.e., WebRobot developers) and the user study
with novice users, a notable difference in use patterns is that
novice users make mistakes (e.g., mis-clicks on webpages and
mis-use of the UI). In this case, we assisted the participants
to restart WebRobot and perform the task again.

7.4 Q4: Comparison with Existing Rewrite-Based

Synthesis Techniques

The goal of this final experiment is to understand how our
speculative rewriting idea compares with existing rule-based
rewrite approaches that perform synthesis in a correct-by-
construction manner (without speculation). Specifically, we
implemented a baseline synthesizer using the egg library [63],
a state-of-the-art framework that was used to build many
high-performance rewrite-based synthesizers [43, 48, 58, 64].

10For long-running programs (>10 minutes), we ran them for 3 iterations.

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

Table 2. Main results for egg-based implementation in Q4. X/Y
gives synthesis time X (milliseconds) for (shortest) trace length Y.

b20
Baseline using egg 2√ó105/34 12/6 15/12
WebRobot

b12

b15

b48

6/8

186/34 11/6 22/12 12/8 950/204

b56 b73 b74 b75 b76

‚Äì/‚Äì 2/2
7/2

2/2
6/2

3/2
7/2

2/2
6/2

Our egg-based implementation. Our baseline consists
of two key rules: one that splits a trace into slices and another
that ‚Äúrerolls‚Äù a slice into a loop. We illustrate these rules using
Example 5.1, by showing one specific sequence of rules that
rewrites ùê¥ to ùëÉ. Conceptually, we first apply a Split rule that
splits ùê¥ to three slices:

[ùëé1, ¬∑¬∑, ùëé59] ‚Üí Unsplit([[ùëé1, ¬∑¬∑, ùëé40], [ùëé41], [ùëé42, ¬∑¬∑, ùëé59]])

Then, we use a Reroll rule that yields two rewrites:

[ùëé1, ¬∑¬∑, ùëé40] ‚Üí InnerLoop

[ùëé42, ¬∑¬∑, ùëé59] ‚Üí InnerLoop

In other words, these two slices are rewritten to two instances
of the inner loops of ùëÉ. Note that now the e-graph contains
Unsplit([[InnerLoop], [ùëé41], [InnerLoop]]). The third rule we
apply is Unsplit which does the following rewrite:
Unsplit([[InnerLoop], [ùëé41], [InnerLoop]]) ‚Üí

[InnerLoop, ùëé41, InnerLoop]

As one can imagine, we can apply the aforementioned rules
again to finally generate ùëÉ. While our current baseline only
supports selector loops without alternative selectors, it lever-
ages e-class analysis and is fairly optimized. Thus, we believe
it is still a good baseline to test the performance of a purely
rule-based, correct-by-construct synthesis approach.

Results and discussion. We evaluated this baseline on
all 9 benchmarks whose ground-truth programs involve only
selector loops and no alternative selectors. In particular, we
ran it on action traces of increasing length (from length 1).
Table 2 presents the synthesis time for the shortest trace, for
which it gives an intended program, across all benchmarks.
Our main take-away is that the baseline does not scale well.
In particular, it solved 7 tasks whose ground-truth programs
all have one single loop. b12, which requires synthesizing a
doubly-nested loop, took 200s. The most complex problem
is b56, which involves a three-level loop, and it did not ter-
minate in 5 minutes. On the other hand, WebRobot solved
all 9 benchmarks with at most 1 second.

8 Related Work

In this section, we briefly discuss some closely related work.
RPA. As a relatively new topic, there is little work on RPA
until very recently [9, 34, 35, 62, 65]. Existing work mainly fo-
cuses on formalizing key concepts and the routine discovery
problem. In contrast, our work targets a different problem of
how to help non-experts create automation programs, which
is also critical for fostering RPA adoption.

Web automation. Similar to web automation, WebRobot
emulates user interactions with a web browser and hence
can be viewed as a form of web automation. Our work differs

from prior web automation work [1, 2, 4, 11, 16‚Äì18, 25, 36, 38,
39] in several ways. One notable difference is that WebRobot
is based on interactive PBD whereas prior techniques are
either program-centric or programmer-centric.

Interactive program synthesis. Different from prior ap-
proaches [12, 23, 27, 29, 33, 60], which are mostly interactive
programming-by-example, WebRobot is based on interactive
programming-by-demonstration which is a natural approach
for web RPA. While action traces can be viewed as a form of
‚Äúexamples‚Äù, it introduces a new challenge in how to define
the correctness of a program against a trace. We use a form
of trace semantics for our language, which lays the formal
foundation for web RPA program synthesis.

Programming-by-demonstration (PBD). Existing PBD
techniques can be roughly categorized into two groups: those
that reason about user actions (e.g., Helena [18] and TELS [41])
and those that examine application states (e.g., Tinker [37]
and SMARTedit [30]). While almost all of them rely on heuris-
tic rules to generalize programs from demonstrations [31],
a notable exception is SMARTedit, which proposes a prin-
cipled approach based on version space algebras that could
generate programs from a short trace of states. Similarly, our
work contributes a principled approach but for action-based
trace generalization. In particular, we propose a rewrite-based
algorithm for synthesizing programs from a trace of actions.
Term rewriting. Term rewriting [21] has been used widely
in many important domains [15, 20, 28, 43, 48, 49, 54, 57,
59, 63]. Our work explores a new application for synthesiz-
ing web RPA programs from traces. Different from existing
rewrite-based synthesis techniques [43, 63] which are mostly
purely rule-based and correct-by-construction, we leverage
the idea of guess-and-check in the overall rewrite process.
This new speculate-and-validate methodology enables and
accelerates web RPA program synthesis.

Program synthesis with loop structures. WebRobot is
related to a line of work that aims to synthesize programs
with explicit loop structures [18, 23, 47, 53]. The key distinc-
tion is that we use demonstrations as specifications, whereas
prior approaches are mostly programming-by-example.

Human-in-the-loop. WebRobot adopts a human-in-the-
loop interaction model which has shown to be an effective
way to incorporate human inputs when training AI systems
in the HCI community [19, 46]. This model has been used in
the context of program synthesis, mostly interactive PBE [24,
42, 44, 52, 61, 66]. In contrast, our work incorporates human
inputs in PBD and proposes a new human-in-the-loop model.

Acknowledgments

We thank our shepherd, Calvin Smith, the PLDI anonymous
reviewers, Kostas Ferles, Cyrus Omar, Shankara Pailoor, Chen-
glong Wang, and Yuepeng Wang for their feedback. We also
thank Yiliang Liang and Minhao Li for their help with our
egg baseline implementation. This work was supported by
the National Science Foundation under Grant No. 2123654.

WebRobot: Web Robotic Process Automation using Interactive Programming-by-Demonstration

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

References

[1] Cypress Studio. https://docs.cypress.io/guides/core-concepts/cypress-

studio.

[2] iMacros. https://www.progress.com/imacros.
[3] Robotic Process Automation (RPA). https://searchcio.techtarget.com/

definition/RPA.

[4] Selenium IDE. https://www.selenium.dev/selenium-ide/.
[5] The Remarkable History of Robotic Process Automation (RPA). https:

//nandan.info/history-of-robotic-process-automation-rpa/.

[6] UiPath

Webinar.

https://www.uipath.com/

webinar-recording/your-own-idea-robot-studiox?
mkt_tok=OTk1LVhMVC04ODYAAAF8uBLrLqPW-
QJHu_Hj1dkXeqK4JMZymY9EGBLkwL_
2fSN8Kj2iwc09MVhHrBjf7PUkFUKBfYX-x-
85mrFVUXZf2LawwpNcRPLTEDaZ9NM1.

[7] UiPath Webinar Slides.

https://start.uipath.com/rs/995-XLT-886/

images/StudioX_Webinar.pdf.

[8] XPath. https://en.wikipedia.org/wiki/XPath.
[9] Simone Agostinelli, Andrea Marrella, and Massimo Mecella. 2020.
Towards Intelligent Robotic Process Automation for BPMers. arXiv
preprint arXiv:2001.00804 (2020).

[10] Tobias Anton. 2005. XPath-Wrapper Induction by Generalizing Tree
Traversal Patterns. In Lernen, Wissensentdeckung und Adaptivitt (LWA)
2005, GI Workshops, Saarbrcken. 126‚Äì133.

[11] Shaon Barman, Sarah Chasins, Rastislav Bodik, and Sumit Gulwani.
2016. Ringer: Web Automation by Demonstration. In Proceedings
of the 2016 ACM SIGPLAN international conference on object-oriented
programming, systems, languages, and applications. 748‚Äì764.

[12] Daniel W Barowy, Sumit Gulwani, Ted Hart, and Benjamin Zorn.
2015. FlashRelate: Extracting Relational Data from Semi-structured
Spreadsheets Using Examples. ACM SIGPLAN Notices 50, 6 (2015),
218‚Äì228.

[13] Alexander Baumgartner and Temur Kutsia. 2014. Unranked second-
order anti-unification. In International Workshop on Logic, Language,
Information, and Computation. Springer, 66‚Äì80.

[14] Alexander Baumgartner, Temur Kutsia, Jordi Levy, and Mateu Villaret.
2017. Higher-order pattern anti-unification in linear time. Journal of
Automated Reasoning 58, 2 (2017), 293‚Äì310.

[15] James M Boyle, Terence J Harmer, and Victor L Winter. 1997. The
TAMPR program transformation system: Simplifying the development
of numerical software. In Modern software tools for scientific computing.
Springer, 353‚Äì372.

[16] Sarah Chasins, Shaon Barman, Rastislav Bodik, and Sumit Gulwani.
2015. Browser Record and Replay as a Building Block for End-User Web
Automation Tools. In Proceedings of the 24th International Conference
on World Wide Web. 179‚Äì182.

[17] Sarah Elizabeth Chasins. 2019. Democratizing Web Automation: Pro-
gramming for Social Scientists and Other Domain Experts. Ph.D. Disser-
tation. UC Berkeley.

[18] Sarah E Chasins, Maria Mueller, and Rastislav Bodik. 2018. Rousillon:
Scraping Distributed Hierarchical Web Data. In Proceedings of the 31st
Annual ACM Symposium on User Interface Software and Technology.
963‚Äì975.

[19] Yan Chen, Jaylin Herskovitz, Walter S Lasecki, and Steve Oney. 2020.
Bashon: A Hybrid Crowd-Machine Workflow for Shell Command
Synthesis. In 2020 IEEE Symposium on Visual Languages and Human-
Centric Computing (VL/HCC). IEEE, 1‚Äì8.

[20] Miles Claver, Jordan Schmerge, Jackson Garner, Jake Vossen, and Je-
didiah McClurg. 2021. ReGiS: Regular Expression Simplification via
Rewrite-Guided Synthesis. arXiv preprint arXiv:2104.12039 (2021).
[21] Nachum Dershowitz and Jean-Pierre Jouannaud. 1990. Rewrite sys-

tems. In Formal models and semantics. Elsevier, 243‚Äì320.

[22] Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu
Wang. 2022. WebRobot: Web Robotic Process Automation us-
ing Interactive Programming-by-Demonstration (Extended Version).

http://arxiv.org/abs/2203.09993 (2022).

[23] Kasra Ferdowsifard, Shraddha Barke, Hila Peleg, Sorin Lerner, and
Nadia Polikarpova. 2021. LooPy: interactive program synthesis with
control structures. Proceedings of the ACM on Programming Languages
5, OOPSLA (2021), 1‚Äì29.

[24] Kasra Ferdowsifard, Allen Ordookhanians, Hila Peleg, Sorin Lerner,
and Nadia Polikarpova. 2020. Small-Step Live Programming by Ex-
ample. In Proceedings of the 33rd Annual ACM Symposium on User
Interface Software and Technology. 614‚Äì626.

[25] Michael H Fischer, Giovanni Campagna, Euirim Choi, and Monica S
Lam. 2021. DIY Assistant: A Multi-Modal End-User Programmable Vir-
tual Assistant. In Proceedings of the 42nd ACM SIGPLAN International
Conference on Programming Language Design and Implementation. 312‚Äì
327.

[26] Pankaj Gulhane, Amit Madaan, Rupesh Mehta, Jeyashankher Ra-
mamirtham, Rajeev Rastogi, Sandeep Satpal, Srinivasan H Sengamedu,
Ashwin Tengli, and Charu Tiwari. 2011. Web-scale information extrac-
tion with vertex. In 2011 IEEE 27th International Conference on Data
Engineering. IEEE, 1209‚Äì1220.

[27] Sumit Gulwani. 2011. Automating String Processing in Spreadsheets
Using Input-Output Examples. ACM Sigplan Notices 46, 1 (2011), 317‚Äì
330.

[28] Rajeev Joshi, Greg Nelson, and Keith Randall. 2002. Denali: A goal-
directed superoptimizer. ACM SIGPLAN Notices 37, 5 (2002), 304‚Äì314.
[29] Sean Kandel, Andreas Paepcke, Joseph Hellerstein, and Jeffrey Heer.
2011. Wrangler: Interactive Visual Specification of Data Transforma-
tion Scripts. In Proceedings of the SIGCHI Conference on Human Factors
in Computing Systems. 3363‚Äì3372.

[30] Tessa Lau, Steven A Wolfman, Pedro Domingos, and Daniel S Weld.
2003. Programming by Demonstration Using Version Space Algebra.
Machine Learning 53, 1 (2003), 111‚Äì156.

[31] Tessa Ann Lau. 2001. Programming by demonstration: a machine learn-

ing approach. University of Washington.

[32] Tessa A Lau and Daniel S Weld. 1998. Programming by Demonstra-
tion: An Inductive Learning Formulation. In Proceedings of the 4th
international conference on Intelligent user interfaces. 145‚Äì152.
[33] Vu Le and Sumit Gulwani. 2014. FlashExtract: A Framework for Data
Extraction by Examples. In Proceedings of the 35th ACM SIGPLAN
Conference on Programming Language Design and Implementation. 542‚Äì
553.

[34] Volodymyr Leno, Adriano Augusto, Marlon Dumas, Marcello La Rosa,
Fabrizio Maria Maggi, and Artem Polyvyanyy. 2021. Discovering
Executable Routine Specifications from User Interaction Logs. arXiv
preprint arXiv:2106.13446 (2021).

[35] Volodymyr Leno, Stanislav Deviatykh, Artem Polyvyanyy, Marcello
La Rosa, Marlon Dumas, and Fabrizio Maria Maggi. 2020. Robidium:
Automated Synthesis of Robotic Process Automation Scripts from UI
Logs. CEUR Workshop Proceedings.

[36] Gilly Leshed, Eben M Haber, Tara Matthews, and Tessa Lau. 2008.
CoScripter: Automating & Sharing How-To Knowledge in the Enter-
prise . In Proceedings of the SIGCHI Conference on Human Factors in
Computing Systems. 1719‚Äì1728.

[37] Henry Lieberman. 1993. Tinker: A programming by demonstration
system for beginning programmers. In Watch what I do: programming
by demonstration. 49‚Äì64.

[38] James Lin, Jeffrey Wong, Jeffrey Nichols, Allen Cypher, and Tessa A
Lau. 2009. End-User Programming of Mashups with Vegemite. In Pro-
ceedings of the 14th international conference on Intelligent user interfaces.
97‚Äì106.

[39] Greg Little, Tessa A Lau, Allen Cypher, James Lin, Eben M Haber, and
Eser Kandogan. 2007. Koala: Capture, Share, Automate, Personalize
Business Processes on the Web. In Proceedings of the SIGCHI conference
on Human factors in computing systems. 943‚Äì946.

PLDI ‚Äô22, June 13‚Äì17, 2022, San Diego, CA, USA

Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang

[40] Toshiyuki Masui and Ken Nakayama. 1994. Repeat and Predict - Two
Keys to Efficient Text Editing. In Proceedings of the SIGCHI Conference
on Human Factors in Computing Systems. 118‚Äì130.

[41] Dan Hua Mo. 1990. Learning Text Editing Procedures from Examples.

(1990).

[42] Aaditya Naik, Jonathan Mendelson, Nathaniel Sands, Yuepeng Wang,
Mayur Naik, and Mukund Raghothaman. 2021. Sporq: An Interactive
Environment for Exploring Code using Query-by-Example. In The 34th
Annual ACM Symposium on User Interface Software and Technology.
84‚Äì99.

[43] Chandrakana Nandi, Max Willsey, Adam Anderson, James R Wilcox,
Eva Darulova, Dan Grossman, and Zachary Tatlock. 2020. Synthe-
sizing structured CAD models with equality saturation and inverse
transformations. In Proceedings of the 41st ACM SIGPLAN Conference
on Programming Language Design and Implementation. 31‚Äì44.
[44] Julie L Newcomb and Rastislav Bodik. 2019. Using human-in-the-
loop synthesis to author functional reactive programs. arXiv preprint
arXiv:1909.11206 (2019).

[45] Don Norman. 2013. The design of everyday things: Revised and expanded

edition. Basic books.

[46] Besmira Nushi, Ece Kamar, Eric Horvitz, and Donald Kossmann. 2017.
On human intellect and machine failures: Troubleshooting integrative
machine learning systems. In Thirty-First AAAI Conference on Artificial
Intelligence.

[47] Shankara Pailoor, Yuepeng Wang, Xinyu Wang, and Isil Dillig. 2021.
Synthesizing data structure refinements from integrity constraints.
In Proceedings of the 42nd ACM SIGPLAN International Conference on
Programming Language Design and Implementation. 574‚Äì587.
[48] Pavel Panchekha, Alex Sanchez-Stern, James R Wilcox, and Zachary
Tatlock. 2015. Automatically improving accuracy for floating point
expressions. ACM SIGPLAN Notices 50, 6 (2015), 1‚Äì11.

[49] Varot Premtoon, James Koppel, and Armando Solar-Lezama. 2020.
Semantic code search via equational reasoning. In Proceedings of the
41st ACM SIGPLAN Conference on Programming Language Design and
Implementation. 1066‚Äì1082.

[50] Saikat Ray, Arthur Villa, Naved Rashid, Paul Vincent, Keith Guttridge,
and Melanie Alexander. 2021. Magic Quadrant for Robotic Process
Automation. https://www.gartner.com/doc/reprints?id=1-26Q65VFT&
ct=210706&st=sb.

[51] Mohammad Raza and Sumit Gulwani. 2020. Web Data Extraction using
Hybrid Program Synthesis: A Combination of Top-down and Bottom-
up Inference. In Proceedings of the 2020 ACM SIGMOD International
Conference on Management of Data. 1967‚Äì1978.

[52] Mark Santolucito, William T Hallahan, and Ruzica Piskac. 2019. Live
programming by example. In Extended Abstracts of the 2019 CHI Con-
ference on Human Factors in Computing Systems. 1‚Äì4.

[53] Kensen Shi, Jacob Steinhardt, and Percy Liang. 2019.

Frangel:
component-based synthesis with control structures. Proceedings of the
ACM on Programming Languages 3, POPL (2019), 1‚Äì29.

[54] Calvin Smith and Aws Albarghouthi. 2019. Program synthesis with
equivalence reduction. In International Conference on Verification,
Model Checking, and Abstract Interpretation. Springer, 24‚Äì47.

[55] Armando Solar-Lezama. 2008. Program synthesis by sketching. Univer-

sity of California, Berkeley.

[56] Reudismam Sousa, Gustavo Soares, Rohit Gheyi, Titus Barik, and Loris
D‚ÄôAntoni. 2021. Learning Quick Fixes from Code Repositories. In
Brazilian Symposium on Software Engineering. 74‚Äì83.

[57] Ross Tate, Michael Stepp, Zachary Tatlock, and Sorin Lerner. 2009.
Equality saturation: a new approach to optimization. In Proceedings
of the 36th annual ACM SIGPLAN-SIGACT symposium on Principles of
programming languages. 264‚Äì276.

[58] Alexa VanHattum, Rachit Nigam, Vincent T Lee, James Bornholt, and
Adrian Sampson. [n.d.]. Vectorization for Digital Signal Processors
via Equality Saturation Extended Abstract. ([n. d.]).

[59] Eelco Visser, Zine-el-Abidine Benaissa, and Andrew Tolmach. 1998.
Building program optimizers with rewriting strategies. ACM Sigplan
Notices 34, 1 (1998), 13‚Äì26.

[60] Chenglong Wang, Yu Feng, Rastislav Bodik, Alvin Cheung, and Isil
Dillig. 2019. Visualization by example. Proceedings of the ACM on
Programming Languages 4, POPL (2019), 1‚Äì28.

[61] Chenglong Wang, Yu Feng, Rastislav Bodik, Isil Dillig, Alvin Cheung,
and Amy J Ko. 2021. Falx: Synthesis-Powered Visualization Author-
ing. In Proceedings of the 2021 CHI Conference on Human Factors in
Computing Systems. 1‚Äì15.

[62] Judith Wewerka and Manfred Reichert. 2020.

Robotic Process
Automation‚ÄìA Systematic Literature Review and Assessment Frame-
work. arXiv preprint arXiv:2012.11951 (2020).

[63] Max Willsey, Chandrakana Nandi, Yisu Remy Wang, Oliver Flatt,
Zachary Tatlock, and Pavel Panchekha. 2021. egg: Fast and Exten-
sible Equality Saturation. Proceedings of the ACM on Programming
Languages 5, POPL (2021), 1‚Äì29.

[64] Yichen Yang, Phitchaya Phothilimthana, Yisu Wang, Max Willsey,
Sudip Roy, and Jacques Pienaar. 2021. Equality saturation for tensor
graph superoptimization. Proceedings of Machine Learning and Systems
3 (2021), 255‚Äì268.

[65] Dell Zhang, Alexander Kuhnle, Julian Richardson, and Murat Sensoy.
2020. Process Discovery for Structured Program Synthesis. arXiv
preprint arXiv:2008.05804 (2020).

[66] Tianyi Zhang, London Lowmanstone, Xinyu Wang, and Elena L Glass-
man. 2020. Interactive Program Synthesis by Augmented Examples.
In Proceedings of the 33rd Annual ACM Symposium on User Interface
Software and Technology. 627‚Äì648.

