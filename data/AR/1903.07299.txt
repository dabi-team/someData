Autoregressive Models for Sequences of Graphs

Daniele Zambon∗
Universit`a della Svizzera italiana, Lugano, Switzerland
daniele.zambon@usi.ch

Daniele Grattarola∗
Universit`a della Svizzera italiana, Lugano, Switzerland
daniele.grattarola@usi.ch

Lorenzo Livi
University of Manitoba, Winnipeg, Canada
University of Exeter, Exeter, United Kingdom

Cesare Alippi
Universit`a della Svizzera italiana, Lugano, Switzerland
Politecnico di Milano, Milano, Italy

9
1
0
2

r
a

M
8
1

]

G
L
.
s
c
[

1
v
9
9
2
7
0
.
3
0
9
1
:
v
i
X
r
a

Abstract—This paper proposes an autoregressive (AR) model
for sequences of graphs, which generalises traditional AR models.
A ﬁrst novelty consists in formalising the AR model for a very
general family of graphs, characterised by a variable topology,
and attributes associated with nodes and edges. A graph neural
network (GNN) is also proposed to learn the AR function associ-
ated with the graph-generating process (GGP), and subsequently
predict the next graph in a sequence. The proposed method is
compared with four baselines on synthetic GGPs, denoting a
signiﬁcantly better performance on all considered problems.

Index Terms—graph, structured data, stochastic process, re-
current neural network, graph neural network, autoregressive
model, prediction.

I. INTRODUCTION

Several physical systems can be described by means of
autoregressive (AR) models and their variants. In that case,
a system is represented as a discrete-time signal in which, at
every time step, the observation is modelled as a realisation of
a random variable that depends on preceding observations. In
this paper, we consider the problem of designing AR predictive
models where the observed entity is a graph.

In the traditional setting for AR predictive models, each
observation generated by the process is modelled as a vector,
intended as a realisation of random variable xt+1 ∈ Rd, so
that






xt+1 = f (xt, xt−1, . . . , xt−p+1) + (cid:15),
E[(cid:15)] = 0,
Var[(cid:15)] = σ2 < ∞.

(1)

where the expectation E(cid:15)[·] is with respect to noise at time
t + 1. The predictor from (2) is optimal when considering the
L2-norm loss between ˆxt+1 and xt+1.

Predicting the temporal evolution of a multivariate stochas-
tic process is a widely explored problem in system identiﬁ-
cation and machine learning. However, several recent works
have focused on problems where the vector representation of
a system can be augmented by also considering the relations
existing among variables [1], ending up with a structured
representation that can be naturally described by a graph.
Such structured information provides an important inductive
bias that the learning algorithms can take advantage of. For
instance, it is difﬁcult to predict the chemical properties of
a molecule by only looking at its atoms; on the other hand,
by explicitly representing the chemical bonds, the description
of the molecule becomes more complete, and the learning
algorithm can take advantage of that information. Similarly,
several other machine learning problems beneﬁt from a graph-
based representation, e.g., the understanding of visual scenes
[2], the modelling of interactions in physical and multi-agent
systems [3], [4], or the prediction of trafﬁc ﬂow [5]. In all
these problems (and many others [1]), the dependencies among
variables provide a strong prior that has been successfully
leveraged to signiﬁcantly surpass the previous state of the art.
In this paper, we consider attributed graphs where each node
and edge can be associated with a feature vector. As such, a
graph with N nodes can be seen as a tuple (V, E), where

V = {vi ∈ RF }i=1,...,N

In other terms, each observation xt+1 is obtained from the
regressor

xp

t = [xt, xt−1, . . . , xt−p+1]

through an AR function f (·) of order p affected by an additive
stationary random noise (cid:15). Given (1), the prediction of xt+1
is often taken as

ˆxt+1 = E(cid:15)[xt+1] = f (xt, xt−1, . . . , xt−p+1),

(2)

This research is funded by the Swiss National Science Foundation project
200021 172671. We gratefully acknowledge partial support of the Canada
Research Chairs program. We gratefully acknowledge the support of NVIDIA
Corporation with the donation of the Titan Xp GPU used for this research.

∗Equal contribution.

represents the set of nodes with F -dimensional attributes, and
E = {eij ∈ RS}vi,vj ∈V
models the set of S-dimensional edge attributes [6]. By this
formulation also categorical attributes can be represented, via
vector encoding. We denote with G the set of all possible
graphs with vector attributes. Graphs in G can have differ-
ent order and topology, as well as variable node and edge
attributes. Moreover, a correspondence among the nodes of
different graphs might not be present, or can be unknown; in
this case, we say that the nodes are non-identiﬁed.

Here we build on the classic AR model (1) operating on
discrete-time signals, and propose a generalised formulation

 
 
 
 
 
 
that allows us to consider sequences of generic attributed
graphs. The formulation is thus adapted by modelling a
graph-generating process (GGP) that produces a sequence
{g1, g2, . . . , gt, . . . } of graphs in G, where each graph gt+1
is obtained through an AR function

φ(·) : Gp → G.

(3)

on the space G of graphs. In order to formulate an AR model
equivalent to (1) for graphs, the AR function f (·) must be
deﬁned on the space of graphs, and the concept of additive
noise must also be suitably adapted to the graph representation.
Previous art on predictive autoregression in the space of
graphs is scarce, with [7] being the most notable contribution
to the best of out knowledge. However, the work in [7] only
considers binary graphs governed by a vector AR process of
order p = 1 on some graph features, and does not allow to
consider attributes or non-identiﬁed nodes.

The novel contribution of this work is therefore two-fold.
First, we formulate an AR system model generating graph-
valued signals as a generalisation of the numerical case. In
this formulation, we consider graphs in a very general form.
In particular, our model deals with graphs characterised by:

• directed and undirected edges;
• identiﬁed and non-identiﬁed nodes;
• variable topology (i.e., connectivity);
• variable order;
• node and edge attributes (not necessarily numerical vec-

tors, but also categorical data is possible).

Our model also accounts for the presence of an arbitrary sta-
tionary noise, which is formulated as a graph-valued random
variable that can act on the topology, node attributes, and edge
attributes of the graphs.

Second, we propose to learn the AR function (3) using
the recently proposed framework of graph neural networks
(GNNs) [1], a family of learnable functions that are designed
to operate directly on arbitrary graphs. This paper represents a
ﬁrst step towards modelling graph-valued stochastic processes,
and introduces a possible way of applying existing tools for
deep learning to this new class of prediction problems.

The rest of the paper is structured as follows: Section II-A
formulates the problem of deﬁning AR models in the space of
graphs and Section II-B introduces the proposed architecture
for the GNN; Section III reports the experimental analysis
performed to validate the methodology.

II. NEURAL GRAPH AUTOREGRESSION

A. Autoregressive Model for a GGP

Due to the lack of basic mathematical operators in the vast
family of graphs we consider here, the generalisation of model
(1) to account for graph data is non-trivial. For instance, we
have to deal with the fact that the sum between two graphs is
not deﬁned, although it can be formulated in some particular
cases, e.g., when two graphs have the same order, identiﬁed
nodes and numerical attributes [8].

Let {g1, g2, . . . , gt, . . . } be a discrete signal where each
sample is described by a graph data structure. As done for

the numerical case, we model each observation of the process
as a realisation of a random variable gt+1 ∈ G, dependent on
a graph-valued regressor

gp
t = [gt, gt−1, . . . , gt−p+1],

through an AR function φ(·) on the space of graphs. Similarly
to (1), gt+1 is modelled as

gt+1 = H(φ(gp

t ), η),

(4)

where

H : G × G → G.

is a function that models the effects of noise graph1 η ∈ G on
graph φ(gp
t ). Function H(·, ·) in (4) is necessary because, as
mentioned above, the sum between graphs φ(gp
t ) and η is not
generally deﬁned.

Assumptions made on the noise in (1) have to be adapted
as well. In the classic formulation (1),
the condition of
unbiased noise is formulated as E[(cid:15)] = 0 or, equivalently, as
f (xt, . . . , xt−p−1) = E(cid:15)[f (xt, . . . , xt−p−1) + (cid:15)]. In the space
of graphs the assumption of unbiased noise can be extended
as

φ(gp

t ) ∈ Ef

η[H(φ(gp

t ), η)],

(5)

where Ef [·] ∈ G is the set of mean graphs according to Fr´echet
[10], deﬁned as the set of graphs minimising:

Ef [g] = arg min

(cid:90)

g(cid:48)∈G

G

d(g, g(cid:48))2 dQg(g).

(6)

Function d(·, ·) in (6) is a pre-metric distance between two
graphs, and Qg is a graph distribution deﬁned on the Borel
sets of space (G, d). Examples of graph distances d(·, ·) that
can be adopted are the graph edit distances [11]–[13], or
any distance derived by positive semi-deﬁnite kernel functions
[14]. Depending on the graph distribution Qg, there can be
more than one graph minimising (6), hence ending up with
Ef [·] as a set. We stress that for a sufﬁciently small Fr´echet
variation of the noise graph η (see Eq. (7)) and a metric d(·, ·),
the Fr´echet mean graph exists and is unique.

Equation (6) holds only when
(cid:90)

d(g, g(cid:48))2 dQg(g) < ∞,

G

which can be interpreted as the graph counterpart of Var[(cid:15)] <
∞ in (1). The variance in the graph domain can be expressed
in terms of the Fr´echet variation:

Varf [g] := min
g(cid:48)∈G

(cid:90)

G

d(g, g(cid:48))2 dQg(g) < ∞.

(7)

The ﬁnal AR system model in the graph domain becomes






gt+1 = H(φ(gp
φ(gp
t ) ∈ Ef
Varf [η] < ∞.

t ), η),
η[H(φ(gp

t ), η)],

(8)

1In the present paper, with noise graph we mean a graph-valued random

variable distributed according to a stationary graph distribution [9].

Notice that the proposed graph autoregressive model (8) is
a proper generalisation of model (1). In fact, it can be shown
that (8) reduces to (1), when considering (R, |·|) – or more
generally, (Rd, |·|2) – in place of (G, d), and choosing H(a, b)
as the sum a + b (see Appendix A for a proof).

Given a GGP modelled by (8), we can predict graph at time

t + 1 as that graph ˆgt+1 minimising quantity

representation of the graphs takes into account the relational
information that characterises the GGP.

By applying φconv to each graph in the regressor gk

t (with

the same θconv), we obtain a sequence

[φconv(gt; θconv), . . . , φconv(gt−k+1; θconv)]

of l-dimensional vectors, which is then processed by block

(cid:104)

d (g, gt+1)2(cid:105)
where the expectation is taken with respect to gt+1. Therefore,
we obtain that the optimal prediction is attained at graph

E

E
ˆgt+1 = arg ming∈G
t ), η)] = φ(gp
η [H (φ(gp
= Ef
B. Learning the AR function with a Graph Neural Network

d (g, gt+1)2(cid:105)
(cid:104)
t ).

(9)

Given a GGP described by an AR model of order p, the task
of predicting the next graph in the sequence can be formulated
as that of approximating φ(·) in (8), as the optimal prediction
is given by (9). In order to approximate φ(·) we propose to
use a GNN, which can be seen as a family of models

φnn( · ; θ) : Gk → G

parametrised in vector θ. The family of models receives
regressor gk
t = [gt, . . . , gt−k+1] and outputs the predicted
graph ˆgt+1

ˆgt+1 = φnn(gk

t ; θ).

(10)

As the order p is usually unknown, the value k is a hyperpa-
rameter that must be appropriately chosen.

We propose a possible architecture for φnn, composed of

three main blocks:

1) each graph is mapped to an abstract vector represen-
tation, using graph convolutions [16]–[18] and graph
pooling [15], [19] layers;

2) a predictive model is applied to the resulting vector

sequence;

3) the predicted graph is obtained by mapping the predicted

vector back to the graph domain.

The full GNN φnn is therefore obtained by the composition
of three blocks, denoted φconv, φrnn, and φdense. Although
each block has its own parameters θconv, θrnn and θdense,
the network can be trained end-to-end as a single family of
models with θ = {θconv, θrnn, θdense}. The three blocks are
deﬁned as follows (see also Figure 1 for a schematic view of
the architecture).

The ﬁrst block of the network converts the input sequence
gk
t to a sequence of l-dimensional vectors. This operation can
be described by map:

φconv( · ; θconv) : G → Rl,

which is implemented as a GNN alternating graph convolu-
tional layers for extracting local patterns, and graph pooling
layers to eventually compress the representation down to a
single vector. By mapping graphs to a vector space, we go
back to the numerical setting of (1). Moreover, the vector

φrnn( · ; θrnn) : Rk×l → Rl.

The role of this block is to produce the vector representation
of the predicted graph, while also capturing the temporal
dependencies in the input sequences. Here, we formulate the
block as a recurrent network, but any method to map the
sequence to a prediction is suitable (e.g., fully connected
networks).

Finally, we convert the vector representation to the actual
prediction in the space of graphs, using a multi-head dense
network similar to the ones proposed in [20], [21]:

φdense( · ; θdense) : Rl → G.

Note that generating a graph by sampling its topology and
attributes with a dense network has known limitations and
implicitly assumes node identity and a maximum order. While
this solution is more than sufﬁcient for the experiments con-
ducted in this paper, and greatly simpliﬁes the implementation
of the GNN, other approaches can be used when dealing with
more complex graphs, like the GraphRNN decoder proposed
in [22].

III. EXPERIMENTS

The experimental section aims at showing that AR models
the
for graphs are effective. In particular, we show that
proposed neural graph autoregressive (NGAR) model can be
effectively trained, and that it provides graph predictions that
signiﬁcantly improve over simpler baselines.

The experiments are performed on sequences of attributed
graphs with N = 5 identiﬁed nodes and a variable topology.
Each node is associated with a vector attribute of dimension
F = 2, and no edge attributes; however, the extension to
graphs with edge attributes, as well as graphs of variable order
and non-identiﬁed nodes, is straightforward (e.g., see [20] for
an example). The sequences are produced by two synthetic
GGPs that we generate with a controlled memory order p
(details follow in Section III-B), allowing us to have a ground
truth for the analysis.

The comparative analysis of the tested methods is performed

by considering a graph edit distance (GED) [11]

d(gt+1, ˆgt+1)

(11)

between the ground truth and the prediction made by the
models2. We also analyse the performance of NGAR in terms
of prediction loss and accuracy, in order to show the relative

2Although the NGAR method was trained with a speciﬁc loss function (see
Sec.III-C), here we considered the GED measure instead, in order to provide
a fair comparison of the methods.

Figure 1. Schematic view of the proposed GNN. The network takes a sequence of k graphs up to time t as input (red box), and is trained to predict the graph
at time t + 1. The input sequence is processed by a graph convolutional network, which is applied in parallel to all graphs, followed by a global pooling layer
[15] that compresses the graphs down to vectors. The resulting sequence of vectors (yellow box) is processed by a recurrent neural network, which outputs a
vector representing the predicted graph. Finally, the predicted vector is transformed in a graph by a multi-layer perceptron with two parallel outputs: one for
producing the node features Xt+1, and one for the adjacency matrix At+1.

performance of the model on problems of different complexity.
Finally, we report a qualitative assessment of the predictions
of NGAR, by visualising the graphs predicted by the GNN
and the true observations from the GGP.

d) VAR: the fourth baseline is a vector AR model (VAR)
of order k, which treats each graph gt as the vectorisation of
its node features Xt and adjacency matrix At, concatenated
in a single vector:

The rest of this section introduces the baselines (Sec-
tion III-A), the synthetic GGPs (Section III-B) and the imple-
mentation details for the NGAR architecture (Section III-C).
Finally, we discuss the results of the experimental analysis in
Section III-D.

A. Baseline methods

We consider four baselines commonly applied in the numer-
ical case, that can be easily adapted to our setting. We denote
our proposed method as NGAR, while the four baselines as
Mean, Mart, Move, and VAR, respectively.

a) Mean:

the ﬁrst baseline assumes that the GGP is
stationary, with independent and identically distributed graphs.
In this case, the optimal prediction ˆgt+1 is the mean graph:

ˆgt+1 = Ef [g],

where g ∼ Q, and Q indicates here the distribution (supposed
stationary) of the graphs.

b) Mart: the second baseline assumes that the GGP is a

martingale, s.t. Ef [gt+1] = gt, and predicts gt+1 as:

ˆgt+1 = gt,

i.e., the graph at the previous time step.

c) Move: the third baseline considers the k preceding
t , and predicts gt+1 to be the Fr´echet sample mean

graphs gk
graph of gk
t

ˆgt+1 = arg min

g(cid:48)

d(g(cid:48), gi)2.

(cid:88)

gi∈gk
t

ut = [vec(Xt)(cid:62), vec(At)(cid:62)](cid:62) ∈ RN ·F +N 2

.

First, we compute a prediction ˆut+1 deﬁned by the linear
model

ˆut+1 = B0 +

Bi · ut−i+1,

k
(cid:88)

i=1

t = [ut, . . . , uk
from the regressor uk
t−k+1] and, subsequently,
the actual graph prediction ˆgt+1 is re-assembled from ˆut+1.
We mention that baseline VAR can be adopted in these
experiments only because we are considering graphs with
numerical attributes and ﬁxed order; in more general settings
this would not be possible.

B. Graph-sequence generation

We consider two different GGPs, both based on a common

framework where a multivariate AR model of the form
xt+1 = f (xp

t ) + (cid:15),

(12)

produces a sequence of vectors {x1, x2, . . . , xt, . . . }, which
are then used to generate the graph sequence. From each xt,
a node-feature matrix Xt ∈ RN ×F is built, and the adjacency
matrix At is created as the Delaunay triangulation of the
rows of Xt, interpreted as points in RF . Here, (cid:15) is a noise
term whose components are randomly drawn from a stationary
normal distribution N (0, σ2).

The result of

this process is a sequence of graphs
{g1, g2, . . . , gt, . . . }, where each graph depends on the previ-
ous p graphs. By choosing different implementations of f (xp
t ),
we are able to generate different GGPs. Note that the noise
η and function H(·, ·) in (8) are never made explicit in this
procedure, but instead they are determined by the Gaussian

...Graphconv.Graphconv.Graphconv.Graphconv.Sequence oftransformed graphsRNNPool.Pool. Pool. Pool. Sequence ofvectorsRNNRNNRNNPredictedvectorInput sequencetimeDensedecoderAXPredictedgraph=ϕconvϕrnnϕdenseFigure 2. Temporal evolution of the node attributes of a graph in the rotational
model of order 10. Each plot shows the dynamics of the F = 2 attributes of
each node in the graph.

Figure 3. Temporal evolution of the node attributes of a graph in PMLDS(10).
Each plot shows the dynamics of the F = 2 attributes of each node in the
graph.

noise perturbation introduced by (cid:15), which affects the node
attributes and, consequently, causes possible changes in the
topology. Section III-B1 and Section III-B2 describe the two
procedures.

1) Rotational model: the function f (xp

t ) in (12) is taken

of the form

f (xp

t ) = R(xp

t ) · xt

Table I
HYPERPARAMETER CONFIGURATION FOR THE GNN USED IN THE
EXPERIMENTS.

Hyperparameter

Value

Weight for L2
Learning rate
Batch size
Early stopping

0.0005
0.001
256
20 epochs

where xt ∈ RN ·F and R(xp
t ) is a rotation matrix depending
on the regressor. Matrix R is block-diagonal with blocks Rn,
n = 1, . . . , N , of size F × F deﬁned as:

Rn(xp

t ) =

(cid:20) cos(ω)
− sin(ω)

(cid:21)

sin(ω)
cos(ω)

ω = cn + α cos

xt−i(2n − 1) + xt−i(2n)

(cid:33)

(cid:32)p−1
(cid:88)

i=0

The parameters {cn}N
distribution in (−1, 1], while α is set to 0.01.

1 are randomly generated by a uniform

The node attribute matrices are ﬁnally obtained by arranging
each xt in a N × F matrix, and the regression function f (·)
can be interpreted as an independent and variable rotation of
each node feature (see Figure 2).

2) Partially Masked Linear Dynamical System: we consider

a discrete-time linear dynamical system

xt+1 = Rxt,
where xt ∈ Rc, and R ∈ Rc×c is an orthonormal random
correlation matrix computed with the method proposed by
Davies and Higham in [23].

(13)

Although the dynamical system (13) depends on exactly
one previous time step, the partial observation of the ﬁrst
N F < c components of xt results in a dynamical system of
order p ∝ (c − N · F ) [24]. Similarly to the rotational model,
then, node attributes Xt are obtained by reshaping the masked
vectors in RN F to N × F matrices (see Figure 3). We refer
to this setting as a partially masked linear dynamical system
of complexity c (PMLDS(c)).

The size c of the original linear system represents an index
of complexity of the problem, as the system’s memory is
dependent on it: given N , a higher c will result in more
complicated dynamics of xt, and vice versa (see Figure 4).
However, because the evolution of the GGP is controlled by
hidden variables that the NGAR model never sees at training
time,
the problem is closer to real-world scenarios where
processes are rarely fully observable.

C. Graph neural network architecture

We use the same GNN architecture for both settings. Input

graphs are represented by two matrices:

• a binary adjacency matrix, A ∈ {0, 1}N ×N ;

01002003004005000.50.00.5Node 001002003004005000.50.00.5Node 10100200300400500101Node 201002003004005000.50.00.5Node 30100200300400500timesteps101Node 401002003004005002.50.02.5Node 001002003004005002.50.02.5Node 101002003004005002.50.02.5Node 201002003004005002.50.02.5Node 30100200300400500timesteps2.50.02.5Node 4Table II
TEST PERFORMANCE OF NGAR ON THE ROTATIONAL MODEL OF ORDER
p. WE REPORT THE FULL PREDICTION LOSS (INCLUDING THE
REGULARISATION TERMS), AS WELL AS THE MSE AND LOG-LOSS ON THE
NODE FEATURES X AND ADJACENCY MATRICES A, RESPECTIVELY. FOR
A, WE ALSO REPORT THE ACCURACY ACHIEVED BY THE MODEL.

p

1
5
10
20
50
100

Loss MSE (X)

log-loss (A)

Accuracy (A)

1.108
0.341
0.326
0.336
0.479
0.541

0.715
0.076
0.090
0.105
0.193
0.250

0.334
0.227
0.197
0.194
0.244
0.246

0.86
0.92
0.92
0.92
0.90
0.90

Table III
TEST PERFORMANCE OF THE NGAR MODEL ON PMLDS(c). WE REPORT
THE FULL PREDICTION LOSS (INCLUDING THE REGULARISATION TERMS),
AS WELL AS THE MSE AND LOG-LOSS ON THE NODE FEATURES X AND
ADJACENCY MATRICES A, RESPECTIVELY. FOR A, WE ALSO REPORT THE
ACCURACY ACHIEVED BY THE MODEL.

c

11
15
20
30
60
110

Loss MSE (X)

log-loss (A)

Accuracy (A)

0.200
0.278
0.283
0.341
1.366
4.432

0.018
0.041
0.038
0.081
0.983
3.950

0.154
0.195
0.204
0.222
0.345
0.418

0.95
0.92
0.92
0.90
0.85
0.82

[27], monitoring the validation loss on a held-out 10% of the
training data for early stopping. We jointly minimise the mean
squared error for the predicted node attributes, and the log-
loss for the adjacency matrix. For each problem, we evolve
the GGPs for 105 steps and test the model on 10% of the
data.

D. Results

Tables II and III report the test performance of NGAR, in
terms of prediction loss and accuracy. We can see that as p
and c increase, the test performance gets worse, which is in
agreement with the fact that p and c can be seen as indexes
of complexity of the problem. In Table II, for the rotational
GGP with p = 1 we observe an unexpected high test loss,
which might be associated with overﬁtting. We also see from
Figure 5 that the test performance seems to be consistently
better when the complexity of the problem is lower than the

Figure 5. Test loss of NGAR for different levels of complexity on Rotational
and PMLDS.

Figure 4. Temporal evolution of the ﬁrst component of PMLDS, for different
values of c. As c increases, it becomes more and more difﬁcult to explain the
dynamics of the observed coordinate.

• a matrix representing the attributes of each node, X ∈

RN ×F .

All hyperparameters of φnn were found through a grid
search on the values commonly found in the literature, using
the validation loss as a metric, and are summarised in Table I.
All sub-networks were structured with two layers to provide
sufﬁcient nonlinearity in the computation, and in particular
φconv and φdense have been shown in the literature to be
effective architectures for processing small graphs [19], [20].
Our network consists of two graph convolutional layers with
128 channels, ReLU activations, and L2 regularization. Here,
we use convolutions based on a ﬁrst-order polynomial ﬁlter,
as proposed in [25], but any other method is suitable (e.g., we
could use the edge-conditioned convolutions proposed in [26]
in order to consider edge attributes). The graph convolutions
are followed by a gated global pooling layer [15], with soft
attention and 128 channels. The φconv block is applied in
parallel (i.e., with shared weights) to all k graphs in the
input sequence, and the resulting vector sequence is fed to
a 2-layer LSTM block with 256 units and hyperbolic tangent
activations. Note that we keep a ﬁxed k = 20 for NGAR,
Move, and VAR. The output of the LSTM block is fed to
a fully connected network of two layers with 256 and 512
units, with ReLU activations, and L2 regularisation. Finally,
the network has two parallel output layers with N · N and
N · F units respectively, to produce the adjacency matrix and
node attributes of the predicted graph. The output layer for
A has sigmoid activations, and the one for X is a linear
layer. The network is trained until convergence using Adam

020406080100101c=3020406080100202c=4020406080100101c=502040608010020c=10020406080100timesteps2.50.02.5c=3015102050100p0.500.751.00LossRotational1115203060110c024LossPMLDSFigure 6. Comparison of Mean (blue), Mart (orange), Move (green), VAR (red), and NGAR (purple) on different rotational GGPs. Each plot shows the
distribution of the residual GED (11) between the targets in the test set and the graphs predicted by each model respectively (best viewed in colour).

Figure 7. Comparison of Mean (blue), Mart (orange), Move (green), VAR (red), and NGAR (purple) on different PMLDS(c) GGPs. Each plot shows the
distribution of the residual GED (11) between the targets in the test set and the graphs predicted by each model respectively (best viewed in colour).

Figure 8. Comparison of a graph predicted by the NGAR model with the ground truth, on PMLDS(30) (best viewed in colour). Given a sequence of graphs
observed up to time t − 1, it is difﬁcult to intuitively predict the following graph in the sequence (marked “True” in the ﬁgure). However, the model is able
to predict the graph almost exactly (marked “Pred.” in the ﬁgure).

Figure 9. Comparison between randomly selected graphs in the test set of the PMLDS(30) GGP and the corresponding graphs predicted by the NGAR model
(best viewed in colour). Upper row: samples from the ground truth. Bottom row: graphs predicted by the GNN.

order of NGAR, i.e., p ≤ k and c − N · F ≤ k (c.f. Sec. III-B1
and Sec. III-B2).

The second part of the experimental analysis aims at
comparing the NGAR method with the baselines in terms
of prediction error, assessed as the GED between predicted
and ground-truth graphs; Figures 6 and 7 show a comparison
of the baselines on different levels of complexity (p and c).
Among the baselines, we cannot clearly identify one with
signiﬁcantly better performance. Given the performance of
Mean and Mart for all p and c, we see that neither GGP
can be modelled as stationary or a martingale. Mean and
Move performed almost the same in all experiments, while
and Mart in some cases performed signiﬁcantly better then
the other baselines, e.g., see the rotational GGP with p = 10.
Despite VAR being a method adapted from a widely used
model in multivariate AR problems, here it was not able to
result in relevant graph predictions. On the other hand, NGAR

consistently outperformed the baselines on almost all setting.
Finally, a qualitative assessment of the predictions is pre-
sented in Figures 8 and 9, which highlights a good perfor-
mance of NGAR even on sequences of graphs that cannot be
intuitively predicted.

IV. CONCLUSION AND FUTURE WORK

In this paper, we formalised an autoregressive framework for
a stochastic process in which the observations are graphs. The
framework considers a generic family of attributed graphs, in
which nodes and edges can be associated with numerical and
non-numerical attributes, the topology is allowed to change
over time, and non-identiﬁed nodes can be considered, as
well. We show that the proposed model for graphs is a non
trivial generalisation of the classic multivariate autoregressive
models, by introducing the Fr´echet statistics. We proposed
also to address the task of predicting the next graph in a

graph sequence with a GNN, hence leveraging deep learning
methods for processing structured data. The GNN implemen-
tation proposed here is based on graph convolutional layers
and recurrent connections, however when requested by the
application, different architectures can be adopted.

Finally, we performed an experimental campaign in which
we demonstrate the applicability of the proposed graph AR
model, as well as that the proposed GNN can be trained to
address prediction tasks. The proposed method is compared
with four baselines on synthetic GGPs, to rely on a ground-
truth for the analysis. The obtained results are promising,
showing that the GNN was able to learn a non-trivial AR
function, especially when compared to simpler, statistically
motivated baselines. Possible application scenarios to be ex-
plored in future works include the prediction of the dynamics
in social networks, load forecasting in power distribution grids,
and modelling the behaviour of brain networks.

As a possible extension of this work, we intend to formulate
the GNN architecture to work entirely on the space of graphs,
without mapping the representation to a vector space. This
would require a method for aggregating the graphs of a
sequence (e.g., via weighted sum). However, such an operation
is currently missing in the literature.

REFERENCES

[1] P. W. Battaglia, J. B. Hamrick, V. Bapst, A. Sanchez-Gonzalez, V. Zam-
baldi, M. Malinowski, A. Tacchetti, D. Raposo, A. Santoro, R. Faulkner
et al., “Relational inductive biases, deep learning, and graph networks,”
arXiv preprint arXiv:1806.01261, 2018.

[2] D. Raposo, A. Santoro, D. Barrett, R. Pascanu, T. Lillicrap, and
P. Battaglia, “Discovering objects and their relations from entangled
scene representations,” arXiv preprint arXiv:1702.05068, 2017.

[3] P. Battaglia, R. Pascanu, M. Lai, D. J. Rezende et al., “Interaction
networks for learning about objects, relations and physics,” in Advances
in neural information processing systems, 2016, pp. 4502–4510.

[4] T. Kipf, E. Fetaya, K.-C. Wang, M. Welling, and R. Zemel,
“Neural relational inference for interacting systems,” arXiv preprint
arXiv:1802.04687, 2018.

[5] Z. Cui, K. Henrickson, R. Ke, and Y. Wang, “High-order graph convolu-
tional recurrent neural network: A deep learning framework for network-
scale trafﬁc learning and forecasting,” arXiv preprint arXiv:1802.07007,
2018.

[6] L. Livi and A. Rizzi, “The graph matching problem,” Pattern Analysis

and Applications, vol. 16, no. 3, pp. 253–283, 2013.

[7] E. Richard, S. Ga¨ıffas, and N. Vayatis, “Link prediction in graphs with
autoregressive features,” The Journal of Machine Learning Research,
vol. 15, no. 1, pp. 565–593, 2014.

[8] L. W. Beineke, R. J. Wilson, and P. J. Cameron, Topics in algebraic

graph theory. Cambridge University Press, 2004, vol. 102.

[9] D. Zambon, C. Alippi, and L. Livi, “Concept drift and anomaly detection
in graph streams,” IEEE Transactions on Neural Networks and Learning
Systems, pp. 1–14, 2018.

[10] M. Fr´echet, “Les ´el´ements al´eatoires de nature quelconque dans un
espace distanci´e,” in Annales de l’Institut Henri Poincar´e, vol. 10, no. 4,
1948, pp. 215–310.

[11] Z. Abu-Aisheh, R. Raveaux, J.-Y. Ramel, and P. Martineau, “An exact
graph edit distance algorithm for solving pattern recognition problems,”
in 4th International Conference on Pattern Recognition Applications and
Methods 2015, 2015.

[12] S. Fankhauser, K. Riesen, and H. Bunke, “Speeding up graph edit
distance computation through fast bipartite matching,” in International
Workshop on Graph-Based Representations in Pattern Recognition.
Springer, 2011, pp. 102–111.

[13] S. Bougleux, L. Brun, V. Carletti, P. Foggia, B. Ga¨uz`ere, and M. Vento,
“Graph edit distance as a quadratic assignment problem,” Pattern
Recognition Letters, vol. 87, pp. 38–46, 2017.

[14] D. Sejdinovic, B. Sriperumbudur, A. Gretton, and K. Fukumizu, “Equiv-
alence of distance-based and rkhs-based statistics in hypothesis testing,”
The Annals of Statistics, pp. 2263–2291, 2013.

[15] Y. Li, D. Tarlow, M. Brockschmidt, and R. Zemel, “Gated graph
sequence neural networks,” arXiv preprint arXiv:1511.05493, 2015.
[16] M. Gori, G. Monfardini, and F. Scarselli, “A new model for learning
in graph domains,” in Neural Networks, 2005. IJCNN’05. Proceedings.
2005 IEEE International Joint Conference on, vol. 2.
IEEE, 2005, pp.
729–734.

[17] F. Scarselli, M. Gori, A. C. Tsoi, M. Hagenbuchner, and G. Monfardini,
“The graph neural network model,” IEEE Transactions on Neural
Networks, vol. 20, no. 1, pp. 61–80, 2009.

[18] J. Bruna, W. Zaremba, A. Szlam, and Y. LeCun, “Spectral networks and
locally connected networks on graphs,” arXiv preprint arXiv:1312.6203,
2013.

[19] M. Defferrard, X. Bresson, and P. Vandergheynst, “Convolutional neural
networks on graphs with fast localized spectral ﬁltering,” in Advances
in Neural Information Processing Systems, 2016, pp. 3844–3852.
[20] M. Simonovsky and N. Komodakis, “Graphvae: Towards genera-
tion of small graphs using variational autoencoders,” arXiv preprint
arXiv:1802.03480, 2018.

[21] N. De Cao and T. Kipf, “MolGAN: An implicit generative model
for small molecular graphs,” ICML 2018 workshop on Theoretical
Foundations and Applications of Deep Generative Models, 2018.
[22] J. You, R. Ying, X. Ren, W. Hamilton, and J. Leskovec, “Graphrnn:
Generating realistic graphs with deep auto-regressive models,” in Inter-
national Conference on Machine Learning, 2018, pp. 5694–5703.
[23] P. I. Davies and N. J. Higham, “Numerically stable generation of
correlation matrices and their factors,” BIT Numerical Mathematics,
vol. 40, no. 4, pp. 640–651, 2000.
[24] E. Ott, Chaos in Dynamical Systems.

Cambridge University Press,

2002.

[25] T. N. Kipf and M. Welling, “Semi-supervised classiﬁcation with graph
convolutional networks,” in International Conference on Learning Rep-
resentations (ICLR), 2016.

[26] M. Simonovsky and N. Komodakis, “Dynamic edge-conditioned ﬁlters
in convolutional neural networks on graphs,” in Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition, 2017.
[27] D. P. Kingma and J. Ba, “Adam: A method for stochastic optimization,”

arXiv preprint arXiv:1412.6980, 2014.

APPENDIX
A. Equivalence between (1) and (8).

Let (G, d) be the Euclidean space (R, |·|), and H(a, b) =

a + b, then

gt+1 = H(φ(gk

t ), η) = φ(gk

t ) + η.

Regarding assumption (5), we see that the integral in (6)
(known as Fr´echet function of Q) becomes

(cid:90)

G

d(g, g(cid:48))2dQ(g) =

(cid:90)

R

|g − g(cid:48)|2 dQ(g)

and
(cid:90)

G

=

(cid:110)

(cid:90)

R

d(H(φ(gp

t ), η), g(cid:48))2 dQ(η) =

(cid:90)

R

|φ(gp

t ) + η − g(cid:48)|2 dQ(η)

|φ(gp

t ) − g(cid:48)|2 + |η|2 − 2η(φ(gp

(cid:111)
t ) − g(cid:48))

dQ(η)

= |φ(gp

t ) − g(cid:48)|2 + Var[η] − 2E[η](φ(gp
We conclude that (1) and (8) are equivalent, in fact
t ), η)] ⇔ E[η] = 0.

t ) ∈ Ef [H(φ(gk

φ(gk

t ) − g(cid:48)).

and

Var[η] < ∞ ⇔ Varf [η] < ∞.

