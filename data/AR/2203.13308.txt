2
2
0
2

r
a

M
4
2

]

R
C
.
s
c
[

1
v
8
0
3
3
1
.
3
0
2
2
:
v
i
X
r
a

Proceedings on Privacy Enhancing Technologies ..; .. (..):1–18

Shaowei Zhu*, Hyo Jin Kim, Maurizio Monge, G. Edward Suh, Armin Alaghi, Brandon Reagen,
and Vincent Lee
Veriﬁable Access Control for Augmented
Reality Localization and Mapping

Abstract: Localization and mapping is a key technol-
ogy for bridging the virtual and physical worlds in aug-
mented reality (AR). Localization and mapping works
by creating and querying maps made of anchor points
that enable the overlay of these two worlds. As a result,
information about the physical world is captured in the
map and naturally gives rise to concerns around who can
map physical spaces as well as who can access or modify
the virtual ones. This paper discusses how we can pro-
vide access controls over virtual maps as a basic building
block to enhance security and privacy of AR systems.
In particular, we propose VACMaps: an access control
system for localization and mapping using formal meth-
ods. VACMaps deﬁnes a domain-speciﬁc language that
enables users to specify access control policies for virtual
spaces. Access requests to virtual spaces are then eval-
uated against relevant policies in a way that preserves
conﬁdentiality and integrity of virtual spaces owned by
the users. The precise semantics of the policies are de-
ﬁned by SMT formulas, which allow VACMaps to rea-
son about properties of access policies automatically. An
evaluation of VACMaps is provided using an AR testbed
of a single-family home. We show that VACMaps is scal-
able in that it can run at practical speeds and that it can
also reason about access control policies automatically
to detect potential policy misconﬁgurations.

Keywords: access control, privacy, augmented reality,
virtual reality, security, formal methods, SMT, localiza-
tion and mapping

DOI Editor to enter DOI
Received ..; revised ..; accepted ...

*Corresponding Author: Shaowei Zhu: Facebook Reality
Labs Research, E-mail: shaoweiz@fb.com
Hyo Jin Kim: Facebook Reality Labs Research, E-mail:
kimhyojin@fb.com
Maurizio Monge: Facebook Reality Labs Research, E-mail:
maurimo@fb.com
G. Edward Suh: Facebook AI Research and Cornell Univer-
sity, E-mail: edsuh@fb.com
Armin Alaghi: Facebook Reality Labs Research, E-mail:
alaghi@fb.com
Brandon Reagen: Facebook Reality Labs Research and New
York University, E-mail: reagen@fb.com

1 Introduction

Augmented reality (AR) is rapidly emerging as the next
generation of disruptive technology. Like the mobile
computing revolution, AR is similarly poised to change
how the physical and digital world connect and inter-
act. It provides immense opportunity for assisting and
improving how we interact with the physical world by
precisely overlaying just the right amount of relevant
information from the virtual one. Augmented reality
promises to provide a wide range of applications from
social teleportation [1, 2], e-commerce [3, 4], naviga-
tion [5], and contextualized artiﬁcial intelligence [6, 7].
There are countless exciting use cases for AR but
all are built upon localization and mapping. Localiza-
tion and mapping is responsible for determining where a
user is in physical space and aligning it with the virtual
world. Mapping is the process of sampling (physical)
data to build new maps or update existing ones. These
maps are the backbone of AR systems that bridge the
physical and virtual divide. A commonly used form of
a vision-based virtual map are 3D point clouds, which
are composed of points in 3D space and their associated
visual feature descriptors that describe the appearance
of each point location (Figure 2). This representation
contains the information necessary to associate a point
in physical space with one in the virtual world.

Once a virtual map equivalent to the physical envi-
ronment has been constructed, users interact with the
map to localize into the environment. Localization is
the process of querying existing maps using sensor in-
puts to determine where a user is in the environment.
This information is used to resolve the relative locations
of virtual and physical assets, enabling a precise over-
lay of the virtual world on top of the physical one. For
instance, suppose we want to place a virtual sticky note
on a physical refrigerator (assuming the physical space
has been mapped). To render the virtual sticky note in

Vincent Lee: Facebook Reality Labs Research, E-mail:
vtlee@fb.com

 
 
 
 
 
 
the right spot the AR system needs the following infor-
mation: (1) the physical location of the refrigerator, (2)
the virtual location of the sticky note, (3) the location
of the user in both physical and virtual space, and (4)
the relative distance between the note, refrigerator, and
user in both the physical and virtual world. Localization
and mapping provides all this information by aligning
the virtual world to the physical one.

While the virtual AR world has remarkable like-
ness to the physical world, there are important diﬀer-
ences with respect to accessing spaces, which now de-
pend on access to digital maps rather than just phys-
ical locations. This gives rise to the map access prob-
lem in AR. Speciﬁcally, unlike the physical world where
restricting access is intuitive and solutions are readily
available (e.g., locks and physical barriers), new sys-
tems and mechanisms are needed for controlling access
to virtual spaces for AR. Access control systems should
uphold and enforce notions of permission for map mod-
iﬁcations, analogous to the physical world. Imagine two
competing coﬀee shops. One shop should not be able
to place advertisements for their shop in the line of the
other, nor should it be able to artiﬁcially obstruct/close
the entryways in the virtual world. More questions arise
around who, when, and where a map can be used for lo-
calization. For example, if a map exists of a house, how
does one enforce who can interact with which parts and
when? Without restrictions, these digital spaces are ripe
to become overrun with unwanted behavior.

In this paper we propose and develop Veriﬁable Ac-
cess Controlled Maps (i.e., VACMaps) to address the
emerging challenges of access control in AR. VACMaps
is an access control system that uses formal methods to
implement a wide range of conﬁgurable access control
policies over maps, speciﬁcally targeting mapping and
localization use cases. It also maintains a hierarchy of
spaces enabling eﬃcient look-up of relevant spaces and
policies. We develop a new domain-speciﬁc language,
named VMAC Lang (Virtual Map Access Control Lan-
guage) to specify access control policies. The language
enables the owner of a space to detail precisely who
should have write (i.e., mapping) and read (i.e., localiza-
tion) access to a map and under what conditions (e.g.,
the time of day and a user’s current location). The se-
mantics of this language is given by a set of rules that
translate the human-readable policies to logical formu-
las. Once VACMaps receives an access request, it ef-
ﬁciently collects relevant spaces and their correspond-
ing access policies, and then evaluate the access request
against the logical formula representation of the policies.
Thanks to the logical formula representation of policies,

Veriﬁed Access Control for Localization and Mapping

2

VACMaps is able to formally prove claims such as “an
unauthorized user will not have access to this space”,
thereby protecting the victim’s private map contents.

VACMaps can verify access claims to map data
given a set of access policies but there is still possibil-
ity for users to unintentionally misconﬁgure the access
policies themselves (e.g., overly permissive access, etc.).
While VACMaps would not be able to ﬁgure out the
user’s real intent, it does provide a way to detect and
audit potential misconﬁgurations. This is only possible
because of the formula representation of policies that
VACMaps maintains. We can then craft queries ques-
tioning VACMaps “who has access to this room?” or “is
there a space in this house that no one has access to?”
or “would this new policy have any eﬀect at all?” An-
swers to these queries might be useful for users in order
for them to author policies in a more informed manner.
This paper makes the following contributions:
– We propose VACMaps: the ﬁrst system that im-
plements access control for modern AR localization
and mapping using formal methods.

– We develop VMAC Lang: a domain-speciﬁc language
for access policies whose semantics are deﬁned by
the SMT encodings.

– We evaluate VACMaps and show that it can run
in near real-time and can scale to large numbers of
spaces and access policies.

– We demonstrate how VACMaps can be used to au-
dit access rights and detect possible policy miscon-
ﬁgurations.

2 Background and Motivation

This section provides background on localization and
mapping and motivates the need for map access control.

2.1 Background: Maps, Mapping, and

Localization

Localization and mapping is a two part process as shown
in Figure 1. Mapping is the process of creating a 3D
model, usually in the form of 3D point clouds, of a phys-
ical space through computer vision algorithms, such as
Simultaneous Localization and Mapping (SLAM) [8–10]
or Structure-from-Motion (SfM) [11–13]. The mapping
process typically takes an image from the AR device as
input and generates a visual feature descriptor for each
interest point detected in the image. Each interest point

Veriﬁed Access Control for Localization and Mapping

3

Fig. 1. Localization and mapping is a two part process. In mapping, virtual 3D maps of physical spaces are created from the user’s
scanning of the space. These maps are stored on the server and also used to update the existing maps. Coarse-grained GPS location
information is used to reduce the map search space. During localization, a set of features are extracted from user’s device input stream
which are matched against map points to estimate the device’s pose in the environment.

is also associated with a location in physical 3D space
(i.e., x, y, and z coordinates). These map points are then
combined to create maps—the core data structure used
to represent the physical world in machine perception
algorithms. The mapping process eﬀectively provides a
binding between locations in a physical space and the
digital copy for AR, which is encoded in the map. We re-
fer to this digital copy of physical space encoded in map
data as virtual spaces. Each new map then is merged
into the map database on the server where GPS data
is used to provide a coarse grained estimate for roughly
where to align and merge the new map with.

Localization is responsible for using map data and
obtaining a high-precision estimate of where a user is in
both the physical and virtual world. Localization pro-
vides the 6 degree-of-freedom (DoF) pose of the user’s
device by querying an existing map. This is usually
achieved by registering a device’s input video stream
against the map (3D model) of the physical space; ad-
ditional signals, such as GPS, are also used to get a
coarse-grained position estimate in the world to reduce
the search space [14–16]. Speciﬁcally, localization uses a
set of visual descriptors extracted from user device’s in-
put video stream and matches them against the descrip-
tors that are associated with each 3D point in the map.
Without a coarse grained GPS estimate, this match-
ing step would search signiﬁcantly larger portions of

the database to get high quality matches for localiza-
tion. Once the correspondences have been established,
the pose is computed via a PnP algorithm [17–19]. In
this work, we assume that localization and mapping are
performed on the server. In this scenario, the user sends
visual information (e.g., visual descriptors) for localiza-
tion, the server performs localization and then sends the
6-DoF pose back to the user.

2.2 Access Control Considerations for

Virtual Spaces

We deﬁne a virtual space to be all map data associated
with a physical space, and a private space to be a space
with certain access restrictions. The focus of our work
is to protect private virtual spaces against unauthorized
access and tampering from adversaries. We assume users
will conﬁgure access control policies over the spaces they
own to protect them from unauthorized access by other
users, and that these policies are provided as input to
VACMaps.

In the physical world, private physical spaces are of-
ten associated with an owner or manager who poses ac-
cess restrictions on other users. We expect virtual space
to have similar concepts of access control and ownership
but without some of the physical limitations. Unlike in
the physical world, in AR users can move across vir-

Extract DescriptorsVisual InformationFeature DescriptorsServer-side LocalizationMap Databaseyxzβ g α yxzβ g α Correspondence search and pose estimationReturn pose estimate to userAR servicesRequests read access to relevant map pointsDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorDescriptorServer-side MappingMap DatabaseWrite to or update the map databaseExtract DescriptorsVisual InformationGenerate SubmapMap Merging and UpdateRead map pointsUser Conducts Mapping of the EnvironmentUser Issues Localization RequestsDevice-side ProcessingGPS InformationGPS InformationVeriﬁed Access Control for Localization and Mapping

4

Fig. 2. A point cloud visualization of map data for a single family home. Diﬀerent points in the map are associated with diﬀerent phys-
ical spaces and can leak information about the structure of surrounding objects and the environment.

tual spaces and establish digital presence as they inter-
act with AR services. If an unwanted user establishes
digital presence in virtual spaces, it raises conﬁdential-
ity and integrity concerns. Examples of harm caused by
unwanted access to maps via AR systems includes spy-
ing (conﬁdentiality concerns) and vandalism (integrity
concerns).

Conﬁdentiality There are two potential concerns
with conﬁdentiality in AR maps: accessing raw map
data and performing unauthorized localization.

First, map data captures information about object
structure that can be used to infer what is around the
user and general information about the surrounding en-
vironment [20–22]. To illustrate this concern more con-
cretely, Figure 2 shows a point cloud visualization of the
map for a canonical single-family home. In this visual-
ization, an observer can infer details about the house
layout [23, 24] and diﬀerent objects [20] using exist-
ing computer vision algorithms. Prior work [25–28] has
shown point clouds are not entirely secure and that
point cloud data from a stolen map can be reversed
to reproduce a surprisingly good visual reconstructions
of the environment. If accessed by an unauthorized ad-
versary, the map data can leak conﬁdential information
about what objects a user has or is in the surrounding
environment.

Second, the ability to localize into an unauthorized
virtual space using a map raises additional conﬁden-
tiality concerns. Once the adversary has localized to a
private space, they have access to a rich rendering of the
setting. This could, for example, enable passive spying

on objects in the space, e.g., a computer screen, with-
out being physical present similar to existing spyware.
Strong read access control over maps can rule out both
of these cases.

Vandalism and Integrity Unauthorized modiﬁ-
cation of map data for private virtual spaces is a concern
for similar reasons: tampering, adding, or deleting AR
objects compromises a virtual space’s integrity. When
mapping or updating a physical space, it is necessary
to prevent unauthorized adversaries from degrading in-
tegrity by deleting or modifying it. Prior work has shown
that degrading the integrity of point cloud models or
maps can negatively impact the accuracy of downstream
tasks or inject backdoor triggers [29–31]. Such attacks
are loosely the virtual analog of an adversary stealing
objects (deleting map data) from or posting/placing
items (tampering/adding map data) in one’s physical
space, respectively. Deleting or spamming map data di-
rectly degrades the quality of many AR services that
rely on map integrity.

Adversaries may also attempt to modify or delete
the map data of a victim. For instance, a shop may at-
tempt to override or modify the map of a competitor
to gain a commercial advantage by degrading map in-
tegrity. In a personal setting, without proper map write
access control, AR users would be vulnerable to ad-
versaries spontaneously adding objectionable content in
their spaces, which may not be easy to delete without
proper permissions.

3 Threat Model and System

Goals

This section deﬁnes the system assumptions, adversary
model, and objectives of VACMaps.

3.1 System Deﬁnition

We deﬁne our system as having two primary enti-
ties: AR device users (clients) and the service provider
(server or cloud). We assume each user in this sys-
tem owns an ego-centric (i.e., head-mounted) AR device
that is responsible for collecting the visual information
required for conducting server-based localization and
mapping. These user devices interface with a cloud ser-
vice provider that updates the virtual map of the world.
The service provider is assumed to be honest, since it is
incentivized to maintain accurate and up-to-date map
data and localization estimates for users; inaccurate lo-
calization estimates or stale map data would degrade
the quality of AR experiences that rely on the integrity
of the map.

The primary data asset in our system is map data,
which consists of 3D point locations and their asso-
ciated feature descriptors. In server-based localization
and mapping, the virtual map of the world is stored on
the service provider as it is impractical to store all of it
on any individual device; we assume that existing net-
work security protocols and best practices ensure the
channel between the device and the service provider is
secure. During mapping, when a user moves through
an unmapped space, the user device will generate map
data and upload it to the service provider. The service
provider will then attempt to merge that data into the
existing map as long the user has correct permissions to
write data for that physical space. If a user tries to lo-
calize into a mapped space, they will request read access
to the relevant map data for that physical space based
on GPS information. If the environment has changed
when a user moves through this space, they may also
provide updates to it which again requires write access.
Depending on the access control policies deﬁned over
the physical spaces a user is in, users may or may not
be able to map, update, or access this map data.

We assume that there is map data of shared spaces
that a user may want to share with others as well as
map data the user would like to restrict access to (e.g.,
their house or apartment). In our system architecture,
users cannot directly share maps with each other and all

Veriﬁed Access Control for Localization and Mapping

5

map updates and localization requests go through the
server. This also means that users cannot store entire
maps on their local devices. We also assume that users
may want to access maps to localize in spaces that an-
other user may have already mapped. This allows users
to amortize the cost of mapping the environment as a
shared map allows users to align their view of the world
with a crowd-sourced version to enable AR use cases.

3.2 Adversary Model

We assume that a subset of AR device users will be-
have maliciously and either attempt to perform unau-
thorized map accesses to either read private data or
modify/delete points of other users1. A malicious ad-
versary is able to manipulate the visual information and
GPS data that is captured on the AR device before it
is uploaded to the service provider. Falsifying GPS data
enables an adversary to potentially trick the localiza-
tion and mapping system into serving maps to localize
into areas a user may not physically be present. Falsi-
fying visual information allows an adversary to directly
fabricate feature points and hence map data that can
be combined with GPS spooﬁng to attempt to write in-
valid map data. However, an adversary need to model
precisely the visual information as if the adversary is
physically present in an environment to trick the map-
ping and localization system, which comes at a high
cost. Therefore, we assume that an adversary is able to
spoof GPS data but not visual information. Finally, we
assume that malicious devices are not able to further
compromise other devices in the systems, including the
datacenter service provider, and that the adversary is
not able to fake their identity.

3.3 System Objectives

The key objective of our system is to protect user map
data of their private spaces from unauthorized access by
adversaries; we deﬁne unauthorized access as any read,
modiﬁcation, or write request that is prohibited by a set
of access control policies (see section 4). We assume that
there are policies deﬁned over physical spaces that gov-
ern the mapping, sharing, and modiﬁcation of map data
over these spaces which the system must comply with.

1 We assume that the malicious user is from the public and is
not mentioned in any allow policy for the map, therefore does
not have permission to access the maps under any condition.

AR is still an emerging technology where the concrete
access control policies are still the subject of debate so
precisely deﬁning the “correct” policy over map data is
beyond the scope of this paper. Rather, we will assume
that there are some policies that exist which deﬁne how
spaces are mapped, read, and modiﬁed and that they
will potentially change over time2. This means that the
access control system should be suﬃciently ﬂexible to
support and enforce a range of reasonably practical poli-
cies over map data.

The objective of the system is to enforce access con-
trol over map data such that each access is compliant
with these access control policies. Our system should al-
low access requests to map data by users if it is permit-
ted under the deﬁned access control policies. However,
it should deny access for any user who may intend to
read, modify, or map spaces that are prohibited by the
access policies. For instance, if a user restricts all other
users’ access to the map of their apartment, an adver-
sary should not be able to read or modify that portion
of the map.

4 VACMaps System Architecture

and Language Deﬁnition

This section introduces VACMaps and describes how
it enforces access control over map data. We provide
a primer on formal methods and a high-level overview
of the VACMaps system. We then present the domain-
speciﬁc language VMAC Lang for access policies and for-
malize the semantics of VMAC Lang using SMT formu-
las, which enables automated reasoning about policies.
Additionally, we show how VACMaps leverages natural
spatial hierarchy in maps to improve performance.

4.1 Formal Methods Primer

Formal methods study techniques for speciﬁcation and
veriﬁcation [32]. Speciﬁcation involves deﬁning a system
or process and its desired properties using a mathemat-
ically deﬁned syntax and semantics. Veriﬁcation on the
other hand is a technique that proves that the system
or process satisﬁes certain properties. Formal methods

2 We assume that the spaces (corresponding to rooms in the
physical world) are ﬁxed in this work and the policy remains
unchanged when processing a single access request.

Veriﬁed Access Control for Localization and Mapping

6

are often used to prove the correctness of safety-critical
systems, e.g., a ﬂight collision avoidance system [33] or
systems that are much too complicated to verify by hand
(e.g, a modern compiler toolchain [34, 35]).

Formal method starts by representing a system
(e.g., a computer program) as formulas in Boolean logic
and deﬁnes a Boolean satisﬁability problem that en-
codes the property we wish to verify (e.g., reachabil-
ity, liveness, or correctness). The Boolean satisﬁability
solver (SAT solver) then tries to decide whether the
Boolean constraints combined with logical connectives
can be made true by choosing true or false values for
each variable. Depending on whether the answer is true
or false, this information can be used to make claims
about the system.

Boolean logic itself is often not expressive enough
to encode problem that requires domain knowledge.
As a result, the Boolean SAT problem is often aug-
mented to involve predicates on integers, reals, and
data structure in addition to Booleans using satiﬁa-
bility modulo theory (SMT) [36]. As an example, one
might ask whether there exist integers x, y, z such that
x > 2y ∧ y > z ∧ ¬(2z <= x) is true. The meaning
of predicates like x > 2y, i.e., given symbols x, y de-
cide if x > 2y should be true or false, is provided by
the theory of linear integer arithmetic which deﬁnes the
semantics of integer math. For the previous query, the
solver would verify that the formula is unsatisﬁable for
any values of x, y, and z. Other theories include theory
of uninterpreted functions, theory of strings, etc. In this
work, we focus on formulas within theory of linear real
arithmetic with equality for which there exists eﬃcient
decision procedures.

The underlying SAT problem itself is a well-known
NP-Complete problem; however, modern solvers imple-
ment sophisticated heuristics that exploit the power of
modern processors and the structure of formulas to ex-
plore the search space very eﬃciently. As a result, mod-
ern SMT solvers like CVC [37], Yices [38], and Z3 [39]
can often handle formulas with hundreds of thousands
of variables in a reasonable amount of time [36].

This also means SMT solvers are fast enough to
support practical sized problems in areas such as pro-
gram veriﬁcation and testing [40], compiler optimization
correctness [41], interactive theorem proving [42], and
program synthesis [43]. Problems in speciﬁc application
domains are translated into SMT formulas such that the
satisﬁability of the formulas implies that certain prop-
erties must hold. For example, we can over-approximate
the the states that a program could run into, i.e., main-
tain a set of states that is guaranteed to be a super set

Veriﬁed Access Control for Localization and Mapping

7

Fig. 3. Architecture of VACMaps. (a) A user’s device provides a set of user access control policies, approximate location determined by
GPS, and access request type (i.e, read or modify). (b) The VACMaps system checks the map database to extract relevant maps and
the 3D segmentation of the space, as well as relevant policies which are processed by formal reasoning to determine whether access
should be denied or granted. (c) If access is granted for the request, the user request is serviced appropriately.

of the actual reachable states. Then we might encode
the event that a particular error state is within this set
of reachable states as an SMT formula so that if the
formula is unsatisﬁable then the program is guaranteed
to never run into that error; and if the formula is satis-
ﬁable we could obtain from the SMT solver a concrete
example of an initial conﬁguration of the program that
may run into that error (since we maintain an over-
approximation of reachable states rather than the exact
set of reachable states).

In our work, we describe the semantics of access
policies formally using SMT formulas. Properties of the
access policy semantics imply the correctness of the ac-
cess control system given any combination of access poli-
cies and access requests. We will also encode certain
claims about access policies as queries to SMT solvers.
By examining the SMT solver output, we can then de-
tect possible policies misconﬁgurations and report it to
the users.

4.2 VACMaps Architecture Overview

Figure 3 depicts the VACMaps system. VACMaps pro-
vides access control for localization and mapping in the
client-server setting. We assume that users have AR de-
vices with cameras that capture visual observations of
the physical world that are converted to map points. We
further assume the user has deﬁned access policies over
the physical spaces they own/control and the virtual

maps they create. Together, the observed map points
and access policies serve as the input to VACMaps.

On the server side, localization and mapping ser-
vices compute the user’s exact current location and map
point coordinates using input from the user’s device. No-
tice that GPS, WiFi, and other measurements that pro-
vides the approximation location are not directly used
to decide the user’s location but only as an aid to the lo-
calization and mapping services. The server also checks
if the user’s observations match the database to en-
sure that the user is not spooﬁng its location. Addition-
ally, the server maintains a database of access policies
and the mapping between policies and spaces3. These
policies are either generic4 or user-deﬁned. The policy
database extracts the list of relevant policies needed to
determine the user’s access rights. These policies are
organized in a spatial hierarchy to make identifying rel-
evant policies eﬃcient (see subsection 4.4). VACMaps
takes the relevant access policies, and the calculated ex-
act location of the user to formulates a SMT problem.
The problem is ﬁnally presented to the formal veriﬁ-
cation engine to verify whether the map access request
should be granted or denied (see subsection 4.5).

3 We assume that in practice there will be a separate system
that manages the ownership of spaces which is able to decide
who is allowed to modify existing policies
4 Default policy conﬁgurations that are not user-speciﬁc (e.g.,
deny access to all private spaces by default).

Map access requests are modeled as read, write, and
localize in VACMaps. If the user has read access, a vir-
tual map is visible. If the user has write access, the 3D
feature points that the user observed can be used to up-
date the known map or create (write) a new one, which
is stored on the server. If the user has localize access,
the AR device could show the user’s relative location
with respect to the known map.

hpolicyi ::= (hnamei,

heﬀecti,

hprincipali?,

hactioni?,

hspacei, hconditioni?)

hnamei ::= ‘Name:’ hstringi

heﬀecti ::= ‘allow’ | ‘deny’

hprincipali ::= ‘Principal:’ hstringi

hactioni ::= ‘read’ | ‘write’ | ‘localize’

hspacei ::= ‘Space:’ hspace-expri

hspace-expri ::= hspace-idi | ¬ hspace-expri | hspace-expri

∧ hspace-expri | hspace-expri ∨ hspace-expri

hconditioni ::= ‘Condition:’ hcond-expri

hcond-expri ::= hatomi | ¬ hcond-expri | hcond-expri ∧

hcond-expri | hcond-expri ∨ hcond-expri

hatomi ::= ‘TODAfter:’ htimei |
‘WhenInside’ hspace-idi

‘TODBefore:’ htimei |

Fig. 4. Syntax for the policy language. Here a policy is an or-
dered tuple of ﬁelds, and “?” denotes an optional ﬁeld. If an
optional ﬁeld is missing, then the policy applies universally re-
gardless of the value of that ﬁeld. For example, a policy without a
“principal” statement applies to all principals.

4.3 VMAC Lang: A Domain-Speciﬁc

Language for Access Policies

VACMaps develops a domain-speciﬁc language (DSL),
named VMAC Lang, for access control policies that de-
ﬁnes access rights over virtual maps. Figure 4 shows the
abstract syntax for the VACMaps policy DSL.

In VMAC Lang, a policy contains one or more
statements. Each statement has a name, which we use
to refer to the policy when changing or deleting poli-
cies. Statements have effects that declare whether this
policy is granting or denying access. A statement also
contains a principal P that indicates the name or ID
of the user that the policy applies to. The principal
in a statement is optional; omitting the principal al-
lows one to specify a policy that applies to all users.
For instance, we might want to deny all access requests

Veriﬁed Access Control for Localization and Mapping

8

to private spaces such as restrooms (line 20-25 in Fig-
ure 5b).The action ﬁeld lists the access events granted
or denied by this policy and can be one of three types:
read – request map points for the space; write – update
the map of the space; localize – determine the user’s
location in this space.

Space speciﬁes the set of spaces that a policy applies
to. VMAC Lang allows policy designers to specify access
to spaces as (Boolean) logical expressions. For example,
one can say a policy grants access to “the ﬁrst ﬂoor of
the house except the bathroom; and the living room on
the second ﬂoor” or “third ﬂoor of the oﬃce building
and the lobby”. In VACMaps, we allow user (U ) access
to some space (S) if and only if there exists an allowing
policy (P ) that grants U access to S and that there
is no denying policy that prevents P from accessing S.
In other words, deny policies will always override allow
policies in VACMaps if there is a conﬂict. We assume a
space has deny access rights by default.

The condition ﬁeld is an optional qualiﬁer that de-
ﬁnes conditions under which the policy takes eﬀect. We
typically use conditions to determine access based on
a user’s current location and time of the day. For ex-
ample, you might allow your friends to map your house
only when they are in the house; similarly, a museum
might only allow visitors to localize into its exhibition
spaces only during business hours.

4.4 Access Control and Spatial Hierarchy

It is natural for us to think about access rights to objects
hierarchically. For example, when declaring a folder as
read-only one expects the ﬁles inside also become read-
only. Similarly, users might want to set certain policies
on their entire house and expect the rooms inside to
automatically “inherit” some of the policies. Deﬁning
policies in a way that is coherent with respect to the
natural hierarchy of spaces also relieves users’ burden
to deﬁne unique policies for each individual space they
control. Organizing policies according to the hierarchy
of spaces makes the VACMaps system more eﬃcient.
For example, fetching relevant policies from the policy
database based on the user’s current location would be
easier to implement given that we store the policies ac-
cording to the hierarchy of spaces.

We formalize the idea of an access control system
that respects spatial hierarchy as follows. We assume
that if space a and space b has a non-empty intersec-
tion, then either a is contained in b or b is contained
in a. We then construct a graph G = (V, E) such that

the node set V corresponds to the set of spaces, and an
edge (u, v) ∈ E if and only if space v is contained in
space u. Since any space u can have at most one parent,
G is a forest. We say an access control system is said
to be coherent with respect to spatial hierarchy G if a
policy deﬁned for space S is also enforced by the sys-
tem on space T if T is a descendant of S in forest G.
VACMaps is a system that is coherent with respect to
spatial hierarchies.

Figure 5a gives a visualization of the hierarchy of
rooms of a canonical single family home. For example,
the policies set on “house” will be forced on all ﬂoors
and all rooms that are descendants of the “house” node
in the graph; policies set on “Master suite” will also be
enforced on “Master bedroom” and “Master bathroom”
since these spaces are contained inside “Master suite”.
One could imagine that the management of an oﬃce
building could implement a similar hierarchy for diﬀer-
ent ﬂoors that belong to diﬀerent companies that have
oﬃces in the building.

Having a hierarchical structure of spaces also makes
access auditing process more intuitive for users. Users
and policy experts can look at the hierarchy diagram
and make queries like “who has access to this particu-
lar space” and “visualize spaces that this user access”
and compare the result against their access control ex-
pectations and/or social norms. We will introduce more
features of VACMaps that facilitates policy auditing in
subsection 4.5.

4.5 Processing Access Requests and

Reasoning about Policies

We now describe how VACMaps handles access requests
and caches them to improve performance. The server
maintains a mapping from spacial identiﬁers to policy
names that, given a space S, returns all allow and deny
policies that refer to S in the space-expr. Given a new
access request against map point p, VACMaps ﬁrst ﬁnds
all spaces S1 ⊆ S2 ⊆ ... ⊆ Sn in the spatial hierarchy
that contain the map point p. VACMaps then translates
all applicable policies to spaces S1, . . . , Sn into an SMT
formula F and combines them. Policies are translated
to SMT formulas in a lazy manner, i.e., they are only
translated into SMT formulas when there is an incoming
access request that involves space (or subspace) to which
this policy may apply. The access request is then eval-
uated against F resulting in an allow or deny decision.
To improve systems eﬃciency, VACMaps also maintains
an LRU cache for access permissions. The data for the

Veriﬁed Access Control for Localization and Mapping

9

cache is a tuple consisting of identiﬁer for the smallest
enclosing space S1 for point p, as well as current time of
day and other contextual information in the access re-
quest (with the exception of the map point coordinates)
and the access decision. Once VACMaps processed ac-
cess request for point p, other access requests against
map points in space S1 with the same contextual infor-
mation will be served using the cache.

Figure 5c shows how VACMaps translates VMAC
Lang policies to an SMT formula. First, we discuss the
translation for an allow policy. The formula transla-
tion of an allow policy is done by building a conjunc-
tion of the translation of each of its statements, ex-
cept for the eﬀect statement. To translate the principal
statement, we declare a string-typed variable sprincipal
and we translate principal: “Alice” into an equality
between the string-typed variable and a string literal:
sprincipal = “Alice”. The action statement is translated
similarly. Next, we translate the space statement. We
declare real-typed variables x, y, z representing the co-
ordinate of an incoming map point. To translate the
atomic expression, which consists of simply a space iden-
tiﬁer, we ﬁrst look up the boundaries of the space.
VACMaps assumes all spaces are axis-aligned bound-
ing boxes, so the boundaries can be represented as a
tuple hlx, rx, ly, ry, lz, rzi. The atomic expression then
becomes lx ≤ x ≤ rx ∧ ly ≤ y ≤ ry ∧ lz ≤ z ≤ rz. This
can naturally be lifted into a translation of an arbitrary
space statement. For the condition statement, we also
only need to specify how we translate the atoms. The
WhenInside atom could be translated in a way similar
to space expressions provided that we deﬁne real-typed
variables ux, uy, uz representing the user’s approximate
location where the access request is generated. We trans-
late the TODBefore and TODAfter atoms by introducing
a integer-typed variable t and translate an condition
that encodes “after 9 pm and before 1 am” into formula
(2100 ≤ t ≤ 2400) ∨ (0000 ≤ t ≤ 0100). To translate
a deny policy, we simply take the negation of the con-
junction of the translation for its statements. We give an
example of a policy in Figure 5b and its SMT formula
encoding in Figure 5c.

An access request hvprincipal, vaction, x, y, z, ux, uy,
uz, ti is a tuple that contains the name of the princi-
pal making the request, the action the principal wants
to perform, the coordinate of a map point (px, py, pz) in
3D space, the location of the user (lx, ly, lz), and cur-
rent time of day t. To evaluate an access request, we
ﬁnd all spaces that contain the map point being queried
and obtain a formula F encoding the combined policy
for all these spaces. We then perform a substitution

in F [sprincipal
7→ vprincipal, saction 7→ vaction, (x, y, z) 7→
(px, py, pz), (ux, uy, uz) 7→ (lx, ly, lz)] and then perform a
bottom-up simpliﬁcation of the resulting formula. The
result can only be true or false since every atom is
evaluated to either true or false and the resulting for-
mula are these Boolean values connected via logical con-
nectives ∧, ∨, ¬. We will introduce other analyses we do
on the SMT representation of the policies in section 5.

5 Methodology and Evaluation

This section outlines the implementation methodology
and evaluates VACMaps’s ﬂexibility, scalability, relia-
bility and performance.

5.1 Methodology

We implement VACMaps in Python using textX to im-
plement and parse our access control policy DSL. We use
intervaltree to deﬁne and maintain the spatial hierar-
chy relationship of spaces; we also use Z3 (z3-solver)
as our solver backend. All experiments were run on a
MacBook Pro 2019 with a 2.4 GHz 8-Core Intel Core i9
CPU and 32 GB RAM.

To our knowledge, there is no standardized bench-
mark for evaluating access policies for localization and
mapping or general AR/VR applications. We thus use a
synthetically generated dataset for a single family house
(Figure 6) that captures common scenarios that a user
would encounter when they interact with an AR device
at home.

The house has two stories and contains a set of
rooms shown in Figure 5a. We obtain the 3D segmen-
tation and the name of the rooms (Figure 6d) using the
ground truth ﬂoor plans used to construct the house.
In practice, this can be obtained using techniques like
PlaneRCNN [44]. The dataset also provides a video se-
quence of a tour or walk through (Figure 6e) of all the
rooms in the house to simulate what the camera at-
tached to the user’s AR device would capture. This ef-
fectively generates a sequence of accesses to the map
which VACMaps validates with respect to access poli-
cies.

The localization and mapping pipeline takes in as
input the simulated video sequence. For each frame in
the video sequence, the pipeline returns a list of fea-
ture points (both their 2D coordinates in the image and
their 3D coordinates in space) that are used to decide

Veriﬁed Access Control for Localization and Mapping

10

the user’s location or update the map database. The
pipeline also returns the user’s estimated location for
each frame.

We assume that users send access requests to the
access control system to request access rights to map
points for each frame of the simulated video. An access
request simply contains the user’s ID, all the feature
points that the user observes at this time instant, the
user’s current location, and other metadata the AR de-
vice generates (such as the timestamp) that are useful
in deciding access rights.

Access policies for rooms in the house are hand-
written (unless otherwise speciﬁed) to verify the cor-
rectness and evaluate the performance of VACMaps. We
will discuss how we create the policies in the following
subsections.

5.2 Basic Access Control Scenario

Evaluation

We ﬁrst evaluate the basic utility and functionality of
VACMaps for canonical use case scenarios. Each of these
basic scenarios that a user may encounter is brieﬂy de-
scribed in Table 1. We implement all these scenarios by
crafting a set of access control policies over the rooms
and using a subset of the frames in the tour that reﬂect
the test scenario. We then inspect that the access re-
quest decision (i.e., allow/deny) that VACMaps makes
is consistent with the expected result. We use these sce-
narios to validate the basic functionality of VACMaps
as an access control system.

The results for several of these scenarios is shown in
Figure 7 where RGB points denote points that the user
is granted access to while red Xs denote points to which
a user is denied access. Figure 7b illustrates the the sce-
nario of shared private spaces where a user is looking
into the bathroom. When a user tries to access these
map points VACMaps denies access to all map points
in the bathroom as indicated by the red map point anno-
tations in the diagram. In Figure 7d, the user is located
in a diﬀerent user’s private bedroom; similar to the pre-
vious bathroom scenario, VACMaps again denies access
to these map points because the user is not authorized
to view or use them. On the other hand, if the user
is located in their own private space VACMaps appro-
priately allows the user access to the map (Figure 7h).
Finally, Figure 7f illustrates the case where there is a
bystander space which may be private but is next to
a common area space which is not. In this case, both
the bystander space and common space are within the

Veriﬁed Access Control for Localization and Mapping

11

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

Begin
Name: "GrantAliceAllAccess"
Effect: allow
Principal: "Alice"
Action: read
Space:

"first_floor_all" Or "second_floor_all"

Or "staircase"

End

Begin
Name: "GrantBobAccessToGuestArea"
Effect: allow
Principal: "Bob"
Action: read
Space: recreation_area Or small_bedroom_2
Condition: UserInside: "second_floor_all"

And TODAfter: 0900

End

Begin
Name: "DenyAccessToBathroom"
Effect: deny
Space:

"guest_bathroom" Or "shared_bathroom"

Or "master_bathroom"

End

(a) Hierarchy of rooms and spaces in our
single-family home dataset. Shaded boxes
correspond to rooms/spaces for which we
want to implement certain access-control
mechanisms that prevent certain residents of
the house from mapping these rooms.

(b) An example set of access control policies
for the single-family house dataset. The ﬁrst
policy grants Alice read access to all spaces
in the house. The second policy gives Bob
read access to the recreation area and a small
bedroom on the second ﬂoor given that Bob
is in the house and the current time is after
9 am. The third policy prevents anyone from
accessing the bathrooms.

fﬁrst policy (cid:44) sprincipal = “Alice”

∧ saction = “read”

∧ ((x, y, z) ∈ Bﬁrst ﬂoor

∨ (x, y, z) ∈ Bsecond ﬂoor)

fsecond policy (cid:44)(sprincipal = “Bob”

∧ saction = “read”

∧ ((x, y, z) ∈ Bsmall bedroom 2

∨ (x, y, z) ∈ Brecreation area)

∧ (ux, uy , uz ) ∈ Bsecond ﬂoor

∧ 0900 ≤ t ≤ 2400)

fthird policy (cid:44) ¬(((x, y, z) ∈ Bguest bathroom
∨ (x, y, z) ∈ Bshared bathroom

∨ (x, y, z) ∈ Bmaster bathroom))

(c) Example SMT formula translation for the
policies over three rooms. Notice that each
room inherits the policy of its enclosing space.
Also, Alice still does not have access to the
bathroom since her access rights are “over-
ridden” by the deny policy on the bathroom
that applies universally to all principals. For a
query point on the second ﬂoor, its relevant
policies are represented as an SMT formula
(fﬁrst policy ∨ fsecond policy) ∧ fthird policy.

Fig. 5. Spatial hierarchy, access policy, and SMT formula translation of policy on the example house dataset. Here the master bedroom
is the rightmost bedroom on the second ﬂoor of the house, small bedroom 2 is one of the small bedrooms on the second ﬂoor, and
guest bathroom is the bathroom on the ﬁrst ﬂoor. For readability we use an abbreviation (x, y, z) ∈ B to represent the conjunctive
formula lx ≤ x ≤ rx ∧ . . . specifying 3D point with coordinate (x, y, z) must lie within an axis-aligned box B.

user’s ﬁeld of view so a user may request access to both
of them. VACMaps appropriately denies access to the
points located in the private bystander spaces while al-
lowing access to map points in the common area.

5.3 Performance and Scalability

We now evaluate VACMaps’s performance and show
how it scales to increasing numbers of policies and vir-
tual spaces.

The result is shown in Figure 8a. As the number
of extracted feature points increases, the total process-
ing time for each frame increases linearly. Since access
requests can essentially be handled in a parallel man-
ner, the optimized processing time can be much shorter
in practice. Since we expect to see many points within
the same space in a single frame, we also implement an
LRU cache that stores the results of recent access rights
queries. The performance gain of the cache denote by
red dots in Figure 8a shows the cache roughly halves
the processing time.

5.3.1 Can VACMaps Be Fast Enough in Practice?

5.3.2 Does VACMaps Scale to Handle Large Maps

and Complex Policies?

Ideally, access control should not add much overhead to
the run time of localization and mapping. In this ex-
periment, we evaluate the time needed for VACMaps
to handle access requests. We use the synthetic house
dataset (Figure 6) as the testing environment. We de-
ﬁne a series of access policies that allows a user access
to some of the rooms while denying the user access to
others. We then follow the simulated tour (Figure 6e)
and send access requests for all extracted feature points
within a frame as the user to VACMaps. We then mea-
sure the time it takes for VACMaps to process all access
request originating from each frame.

Localization and mapping must be a service that can
scale to potentially thousands of physical spaces with
arbitrarily complex access policies. To evaluate the scal-
ability of VACMaps, we evaluate the performance of
VACMaps for larger maps with many physical spaces,
spaces associated with lengthy access control policies,
and spaces whose access policy involves a lot of users.

First, we study the run time of VACMaps as the
total number of spaces n in the system increases (Fig-
ure 8b). We create n unit cubes as spaces and associate

HouseFirst floorStaircaseEntrywayDining roomGuest bedroomGuest bathroomGuest storageHallwayKitchenYardLiving roomSecond floorRecreation areaMaster suiteMaster bathroomMaster bedroomShared bathroomSecond floor hallwaySmall bedroom 1Small bedroom 2Veriﬁed Access Control for Localization and Mapping

12

(a) Outside look of the house.

(b) Floor plan for rooms on the ﬁrst ﬂoor.

(c) Floor plan for rooms on the second ﬂoor.

(d) 3D room segmentation of the house
where each 3D bounding box corresponds to a
room.

(e) A simulated tour through the house which
is used to generate access sequences to map
points. The tour starts on the ﬁrst ﬂoor, visits
every room on the ﬁrst ﬂoor, and then visits
every room on the second ﬂoor.

(f) A point cloud representing feature points
observed and captured during the simulated
tour. We want to decide the user’s access
rights to these points based on the policies
deﬁned for the house.

Fig. 6. Visualization of the single-family house dataset used to evaluate VACMaps. The dataset provides ground truth (b-c) ﬂoor
plans, (d) 3D space segmentation, (e) a simulated tour, and (f) a map of observed points observed during the tour.

with each cube a simple access policy. Then we measure
the time for VACMaps to serve an access request to a
random cube. The results in Figure 8b show that the run
time does not increase signiﬁcantly even if we have more
than 100, 000 spaces. We attribute this directly to an ef-
ﬁcient implementation of the spatial hierarchy organiza-
tion that VACMaps employs (subsection 4.4) using 3D
segment trees; this implementation enables VACMaps
to reduce the complexity of looking up relevant spaces
for a 3D point to O(log n) + m where m is the output
size, i.e., number of spaces actually containing the point.
As a result, because of the logarithmic complexity, the
resulting performance is eﬀectively the same even as the
number of space increases.

We also evaluate the performance of VACMaps as
the complexity of policies increases. We create n unit
cubes as spaces and associate cube n with a policy of
length O(n). This policy is a large disjunction of clauses
that all evaluates to false. The system needs to evalu-
ate each clause so we expect the processing time to be
O(n) for a single access request against cube n. The re-
sults in Figure 8c illustrate that the run time is roughly
linear as the number of policies increases.

Finally, we evaluate the performance of VACMaps
as the number of relevant users grow5. We create 1 unit
cube as the only space under consideration and asso-
ciate with it n policies, each mentions a diﬀerent user.
This in principle has the same eﬀect as increasing the
policy length and we indeed observe a similar trend in
Figure 8d.

Overall, we ﬁnd that the scalability of VACMaps
across number of features per frame, virtual spaces, pol-
icy count, and users is reasonable.

5.4 Auditing and Verifying Access

Permissions

While VACMaps takes access policies as input to verify
and enforce access control requests, it does not reason
about whether a user properly speciﬁed policies in the
ﬁrst place. This leaves it entirely up to the user to deﬁne
intended access policies. Specifying policies can be chal-
lenging as it requires meticulously combining conditions
across spaces, users, and time. While VACMaps cannot
infer user intent, it can aid users in properly setting and
debugging policies.

5 The set of relevant users with respect to a space contains all
principals mentioned in the policies for that space.

Veriﬁed Access Control for Localization and Mapping

13

Table 1. Description of common access control scenarios used to verify VACMap’s basic functionality and correctness.

Scenario

Description

Expected Access Behavior

Conservative default policy

Private spaces

A space does not have any deﬁned access policy
associated with it.
User A is inside their own private space.

Shared private spaces

A user is going to the restroom.

Bystander spaces

Localize with another user’s map

Denying friends of friends access

Private space map contamination

Changing or revoking access poli-
cies

User A is walking by user B’s house where the
windows are open and A can see into B’s private
space.
User A tries to localize himself into an environ-
ment using map points generated by user B.
User B wants to keep their map data private
though.
User A invites a friend user B who invites user C
who is a friend of B but not a friend of A. User
A trusts user B but not user C with mapping the
house.
User A uses a compromised device to inject map
points into user B’s private space.
User A wants to change the condition under
which a friend B can map A’s house, and wants
to revoke user C’s access to map A’s house.

All users are by default denied access to this
space.
Only user A should be allowed access to this
space.
User should be denied access for mapping and
localization.
User A should be denied the ability to map user
B’s private space.

User A should be denied access to user B’s map.

User B should be able to map and localize but
user C should be denied access.

Access requests by user A to modify user B’s
map should be denied.
Once the policy change request is handled, user
B and C’s access rights to A’s house are modiﬁed
and enforced through the access control system.

We enable auditing of privacy policies over spaces
leveraging the logic reasoning and SMT formula se-
mantics that VACMaps is built upon. At a high level,
the auditing of policy conﬁgurations of a space is done
by constructing (potentially a series of) SMT queries
against the formula representation of policies. This fea-
ture can detect potential policy misconﬁgurations in ex-
isting policies or prevent problematic policies from be-
ing introduced in the ﬁrst place. Table 2 shows a set
of common scenarios that a user may want to audit for
their virtual spaces and how we implement these audits
within VACMaps. For example, a user conﬁguring ac-
cess policies for their home may want to restrict access
to their living room to family members and thus want
to see who has access after entering the policy. If access
is overly permissive, this audit will reveal which other
users have access. The owner can then use this informa-
tion to ﬁx policy misconﬁgurations. As another exam-
ple, we consider the eﬀect of pre-existing deny policies.
Since deny policies override allow policies, new policies
that try to allow access to a subspace might not have
any eﬀect. In practice, it is likely that a space will be
subject to many policies and it can even inherit policies
from enclosing spaces, which will make it challenging for
most users to understand why their new allow policy is
not eﬀectual. Using VACMaps’s automated reasoning
we can detect these ineﬀective policies so that the user

will be prompted to review and modify the deny policy
in order for the new allow policy to work as expected.

6 Related Work

This section highlights related work across security and
privacy, computer vision, and formal methods.

6.1 Security and Privacy Approaches to

Access Control

AR security and privacy concerns are not a new con-
cept in the research literature. Roesner et al. [45] point
out that AR systems enable novel attacks against users
and pose new threats to users’ and bystanders’ privacy.
Similarly, De Guzman et al. [46] surveys recent devel-
opments in the security and privacy of mixed reality
(MR) systems by classifying them based on a data-
centric scheme. Chen et al. [47] demonstrates that an
attacker could use the video feed and depth information
captured by an AR device to recover victim’s password
input on a touch screen and proposes designing defenses
tailored to this. Lebeck et al. [48] perform a qualitative
lab study on AR headset users and identiﬁes the need
for access control among users to manage shared physi-

Veriﬁed Access Control for Localization and Mapping

14

(a) A picture taken
in the second ﬂoor
bathroom.

(b) Shared Private Spaces: VACMaps denies
access to map points localized to be in the
bathroom.

(c) A picture taken
in the second ﬂoor
master bedroom.

(d) Private Spaces: VACMaps denies access
to map points for a diﬀerent user’s bedroom.

(e) A picture
taken in the sec-
ond ﬂoor common
area

(f) Bystander Spaces: VACMaps only allows user
access to points that lie in the common area but
not in another user’s bedroom.

(g) A picture
taken in the user’s
bedroom.

(h) Private Spaces: VACMaps allows access to
points inside the user’s own bedroom.

Fig. 7. Visualization of access rights determined by VACMaps. Map points are marked with its RGB value if access is granted and are
displayed as a red cross otherwise. The yellow diamond denotes where the AR device is located.

cal spaces and virtual content in those spaces. However,
their work stops short of implementing an access control
system which our work does.

Roesner et al. [49] presents a general framework for
controlling access to a continuous stream of sensor data
(video and audio) based on policies speciﬁed for real-
world objects. Our work mainly addresses an orthogo-
nal problem of reasoning about policies themselves, to
detect potentially problematic policies.

6.2 Computer Vision Approaches to

Access Control

Recent work in computer vision [50, 51] studies how
photos and videos taken in public places might pose a
potential privacy risk to bystanders. The most relevant
work to ours in the vision community is by Temple-
man et al. [52] who present a technique based on image
classiﬁcation that identiﬁes where an image was taken
and recognizes if this image concerns sensitive spaces
like bathrooms or bedrooms. This oﬀers the AR device
user the capability to “blacklist” these spaces by deﬁn-
ing their own access control policies. However, this tech-
nique only supports simple policies as a list for forbidden
or blacklisted spaces.

6.3 Formal Methods and Access Control

Although there exist standardized frameworks for ac-
cess control languages, for example XACML([53]), vari-
ous domain-speciﬁc languages (along with formalization
of their semantics) are often designed to target diﬀer-
ent application domains. Guelev at al. [54] presents a
loop-free programming language and its formal seman-
tics which correspond to steps that a user could take
to try to gain access to a resource. The authors then
move on to reasoning about whether a program exists
to prove that whether or not a user could eventually get
access to a resource. Hughes and Bultan [55] formalizes
access policies written in XACML format as SAT formulas
and invokes a SAT solver to check if policies satisfy a
partial order relationship. Dougherty et al. [56] studies
access control policies in a dynamic environment and
identiﬁes a few decidable analyses in ﬁrst-order tempo-
ral logic. Backes et al. [57] formalizes semantics of the
Amazon Web Services (AWS) policy language and in-
troduces an analysis tool that encodes semantics of ac-
cess policies associated with AWS resources into SMT
formulas. The tool then invokes Z3 [58] (along with a
customized theory solver for strings) to verify properties
of AWS access policies. In contrast, our work is among
the ﬁrst to apply such access control and formal meth-
ods techniques to localization and mapping for AR.

Veriﬁed Access Control for Localization and Mapping

15

(a) Run time of VACMaps to process one frame as the number of ex-
tracted feature points increases in the image, with (red dots) and without
(blue dots) the LRU cache implementation.

(b) The spatial hierarchy implementation in VACMaps scales to handle a
large number of spaces: processing time does not change much even for
100k spaces.

(c) VACMaps scales to handle complex policies. Processing time
grows linearly when policy length is large enough. It is likely that the
reason for the smaller slope in the beginning is that solvers imple-
ment optimizations for short formulas that are not possible for long
formulas

(d) VACMaps scales linearly to handle a large number of relevant
users. Processing time is linear w.r.t. number of relevant users, as
expected.

Fig. 8. VACMaps performance and scalability with (a) more features per frame, (b) more virtual spaces, (c) longer policies, and (d)
more relevant users.

Table 2. Examples of auditing functionalities enabled by VACMaps. VACMaps can craft queries to the SMT engine to execute checks
for misconﬁgurations of interest. The results can then be used to help a user audit potential problems in policy conﬁgurations.

Query

Implementation

List all users who have access to a space
under certain conditions.

Are policies for a non-public space too
weak so that everyone could access it?
Are policies for a private space too strong
so that even the owner could not access
it?
Does a new “allow” policy really extend
access rights to some space?

Is there a user who is allowed access to
a space in some policy but denied access
to the same space by another policy?
Are policies for a space more permissive
than its enclosing spaces?

Query the solver for a satisfying assignments to the variables and output the principal,
add a blocking clause to the policy formula to prevent the same user being selected again.
Repeat until the formula becomes unsatisﬁable.
Check if the formula representing a weak policy stating that everyone can access this
space implies the formula encoding the existing policies for this space.
Check if the formula encoding the policy for the space conjuncted with a clause that
speciﬁes the principal equals the owner of the space is satisﬁable.

Check if the original policy formula conjuncted with the new policy formula is weaker than
the original formula. The check is non-trivial since deny policies override allow policies
regardless of the ordered in which they are added.
Collect the set S of all principals that appear in the allow policies for a space. Any deny
policy must have an SMT encoding with form ¬Q. We just check if any n ∈ S can make
the formula Q ∧ sprincipal = n satisﬁable.
Check if the formula representation for the space’s policies is weaker than that for en-
closing spaces.

7 Conclusion and Future Work

This work presents VACMaps which is an access con-
trol system that provides provably correct access de-
cisions for AR localization and mapping using formal
methods. VACMaps enables automated reasoning over
access policies by introducing a DSL for policy writers
and its corresponding semantics via the SMT encoding
of the policies. We also show that VACMaps is both
fast and scalable, and that it can also be used to audit
misconﬁgurations in access policies.

VACMaps focuses on localization and mapping
data, however we expect that similar access control
needs will arise for other AR data structures and use
cases in the future. Additionally, we hope to introduce
a DSL that allows users to write more robust access
policies against estimation errors that are inherent to
localization and mapping algorithms.

References

[1] S. Saito, T. Simon, J. Saragih, and H. Joo, “Pifuhd: Multi-

level pixel-aligned implicit function for high-resolution 3d hu-
man digitization,” in Proceedings of the IEEE/CVF Confer-
ence on Computer Vision and Pattern Recognition (CVPR),
June 2020.

[2] H. Kato, M. Billinghurst, I. Poupyrev, K. Imamoto, and

K. Tachibana, “Virtual object manipulation on a table-top ar
environment,” in Proceedings IEEE and ACM International
Symposium on Augmented Reality (ISAR 2000), pp. 111–
119, Ieee, 2000.

[3] X. Han, Z. Wu, Z. Wu, R. Yu, and L. S. Davis, “Viton: An
image-based virtual try-on network,” in Proceedings of the
IEEE conference on computer vision and pattern recognition,
pp. 7543–7552, 2018.

[4] Y. Lu and S. Smith, “Augmented reality e-commerce as-

sistant system: trying while shopping,” in International
Conference on Human-Computer Interaction, pp. 643–652,
Springer, 2007.

[5] W. Narzt, G. Pomberger, A. Ferscha, D. Kolb, R. Müller,
J. Wieghardt, H. Hörtner, and C. Lindinger, “Augmented
reality navigation systems,” Universal Access in the Informa-
tion Society, vol. 4, no. 3, pp. 177–187, 2006.
“Augmented reality leveraging ai to engage 200 million ac-
tive users by 2026.” Accessed: 11-17-2021.
“Working together: Computer vision, ai, and augmented
reality.” Accessed: 11-17-2021.

[7]

[6]

[8] R. Mur-Artal, J. M. M. Montiel, and J. D. Tardos, “ORB-
SLAM: A versatile and accurate monocular slam system,”
IEEE Transactions on Robotics, vol. 31, p. 1147–1163, Oct
2015.
J. Engel, T. Schöps, and D. Cremers, “Lsd-slam: Large-
scale direct monocular slam,” in European conference on
computer vision, pp. 834–849, Springer, 2014.

[9]

Veriﬁed Access Control for Localization and Mapping

16

[10] R. A. Newcombe, S. J. Lovegrove, and A. J. Davison,
“DTAM: Dense tracking and mapping in real-time,” in
ICCV, 2011.

[11] J. L. Schönberger and J.-M. Frahm, “Structure-from-motion

revisited,” in Proceedings of the IEEE conference on com-
puter vision and pattern recognition, 2016.

[12] C. Sweeney, T. Hollerer, and M. Turk, “Theia: A fast and
scalable structure-from-motion library,” in Proceedings of
the 23rd ACM International Conference on Multimedia, MM
’15, p. 693–696, 2015.

[13] S. Agarwal, Y. Furukawa, N. Snavely, I. Simon, B. Curless,

S. M. Seitz, and R. Szeliski, “Building rome in a day,” Com-
munications of the ACM, 2011.

[14] T. Sattler, A. Torii, J. Sivic, M. Pollefeys, H. Taira, M. Oku-
tomi, and T. Pajdla, “Are large-scale 3d models really neces-
sary for accurate visual localization?,” in Proceedings of the
IEEE Conference on Computer Vision and Pattern Recogni-
tion, pp. 1637–1646, 2017.

[15] B. Zeisl, T. Sattler, and M. Pollefeys, “Camera pose voting
for large-scale image-based localization,” in Proceedings
of the IEEE International Conference on Computer Vision,
pp. 2704–2712, 2015.

[16] D. M. Chen, G. Baatz, K. Köser, S. S. Tsai, R. Vedantham,
T. Pylvänäinen, K. Roimela, X. Chen, J. Bach, M. Polle-
feys, et al., “City-scale landmark identiﬁcation on mobile
devices,” in Proceedings of the IEEE conference on com-
puter vision and pattern recognition, pp. 737–744, IEEE,
2011.

[17] Z. Kukelova, M. Bujnak, and T. Pajdla, “Real-time solution
to the absolute pose problem with unknown radial distortion
and focal length,” in Proceedings of the IEEE International
Conference on Computer Vision, pp. 2816–2823, 2013.
[18] M. Bujnak, Z. Kukelova, and T. Pajdla, “New eﬃcient solu-
tion to the absolute pose problem for camera with unknown
focal length and radial distortion,” in Asian Conference on
Computer Vision, pp. 11–24, Springer, 2010.

[19] B. M. Haralick, C.-N. Lee, K. Ottenberg, and M. Nölle, “Re-

view and analysis of solutions of the three point perspective
pose estimation problem,” International journal of computer
vision, vol. 13, no. 3, pp. 331–356, 1994.

[20] H. Su, S. Maji, E. Kalogerakis, and E. Learned-Miller,

“Multi-view convolutional neural networks for 3d shape
recognition,” in Proceedings of the IEEE international con-
ference on computer vision, pp. 945–953, 2015.

[21] M. A. Uy, Q. Pham, B. Hua, D. T. Nguyen, and S. Yeung,
“Revisiting point cloud classiﬁcation: A new benchmark
dataset and classiﬁcation model on real-world data,” CoRR,
vol. abs/1908.04616, 2019.

[22] T. Hackel, N. Savinov, L. Ladicky, J. D. Wegner,

K. Schindler, and M. Pollefeys, “Semantic3d.net: A new
large-scale point cloud classiﬁcation benchmark,” CoRR,
vol. abs/1704.03847, 2017.

[23] A. Nguyen and B. Le, “3d point cloud segmentation: A sur-
vey,” in 2013 6th IEEE conference on robotics, automation
and mechatronics (RAM), pp. 225–230, IEEE, 2013.

[24] W. Wang, R. Yu, Q. Huang, and U. Neumann, “Sgpn: Sim-

ilarity group proposal network for 3d point cloud instance
segmentation,” in Proceedings of the IEEE Conference on
Computer Vision and Pattern Recognition (CVPR), June
2018.

Veriﬁed Access Control for Localization and Mapping

17

[25] F. Pittaluga, S. J. Koppal, S. B. Kang, and S. N. Sinha,

constructions. Springer Science & Business Media, 2013.

“Revealing scenes by inverting structure from motion recon-
structions,” in CVPR, 2019.

[26] D. Dangwal, V. T. Lee, H. J. Kim, T. Shen, M. Cowan,

R. Shah, C. Trippel, B. Reagen, T. Sherwood, V. Balntas,
A. Alaghi, and E. Ilg, “Analysis and mitigations of reverse
engineering attacks on local feature descriptors,” in BMVC,
2021.

[27] A. Mahendran and A. Vedaldi, “Understanding deep image
representations by inverting them,” in CVPR, 2015.

[43] S. Srivastava, S. Gulwani, and J. S. Foster, “From program
veriﬁcation to program synthesis,” in Proceedings of the
37th annual ACM SIGPLAN-SIGACT symposium on Princi-
ples of programming languages, pp. 313–326, 2010.
[44] C. Liu, K. Kim, J. Gu, Y. Furukawa, and J. Kautz, “Plan-
ercnn: 3d plane detection and reconstruction from a single
image,” in Proceedings of the IEEE/CVF Conference on
Computer Vision and Pattern Recognition, pp. 4450–4459,
2019.

[28] P. Weinzaepfel, H. Jégou, and P. Pérez, “Reconstructing an

[45] F. Roesner, T. Kohno, and D. Molnar, “Security and privacy

image from its local descriptors,” in CVPR, 2011.
[29] Y. Sun, F. Chen, Z. Chen, M. Wang, and R. Li, “Local

for augmented reality systems,” vol. 57, no. 4, pp. 88–96.
[46] J. A. De Guzman, K. Thilakarathna, and A. Seneviratne,

aggressive adversarial attacks on 3d point cloud,” CoRR,
vol. abs/2105.09090, 2021.

“Security and privacy approaches in mixed reality: A litera-
ture survey,” vol. 52, no. 6, pp. 110:1–110:37.

[30] X. Li, Z. Chen, Y. Zhao, Z. Tong, Y. Zhao, A. Lim, and

[47] S. Chen, Z. Li, F. Dangelo, C. Gao, and X. Fu, “A case

J. T. Zhou, “Pointba: Towards backdoor attacks in 3d point
cloud,” CoRR, vol. abs/2103.16074, 2021.

[31] M. Wicker and M. Kwiatkowska, “Robustness of 3d deep
learning in an adversarial setting,” in Proceedings of the
IEEE/CVF Conference on Computer Vision and Pattern
Recognition (CVPR), June 2019.

[32] E. M. Clarke and J. M. Wing, “Formal methods: State of

the art and future directions,” ACM Computing Surveys
(CSUR), vol. 28, no. 4, pp. 626–643, 1996.

[33] M. P. E. Heimdahl and N. G. Leveson, “Completeness

and consistency in hierarchical state-based requirements,”
IEEE transactions on Software Engineering, vol. 22, no. 6,
pp. 363–377, 1996.

[34] A. W. Appel, “Veriﬁed software toolchain,” in European
Symposium on Programming, pp. 1–17, Springer, 2011.

[35] D. Kästner, J. Barrho, U. Wünsche, M. Schlickling,

study of security and privacy threats from augmented reality
(AR),” in 2018 International Conference on Computing,
Networking and Communications (ICNC), pp. 442–446.

[48] K. Lebeck, K. Ruth, T. Kohno, and F. Roesner, “Towards

security and privacy for multi-user augmented reality: Foun-
dations with end users,” in 2018 IEEE Symposium on Secu-
rity and Privacy (SP), pp. 392–408. ISSN: 2375-1207.
[49] F. Roesner, D. Molnar, A. Moshchuk, T. Kohno, and H. J.

Wang, “World-driven access control for continuous sens-
ing,” in Proceedings of the 2014 ACM SIGSAC Confer-
ence on Computer and Communications Security, CCS ’14,
pp. 1169–1181, Association for Computing Machinery.

[50] T. Akter, B. Dosono, T. Ahmed, A. Kapadia, and B. Se-

maan, “"i am uncomfortable sharing what i can’t see": Pri-
vacy concerns of the visually impaired with camera based
assistive applications,” pp. 1929–1948.

B. Schommer, M. Schmidt, C. Ferdinand, X. Leroy, and
S. Blazy, “Compcert: Practical experience on integrating and
qualifying a formally veriﬁed optimizing compiler,” in ERTS2
2018-9th European Congress Embedded Real-Time Software
and Systems, pp. 1–9, 2018.

[51] R. Hasan, D. Crandall, M. Fritz, and A. Kapadia, “Auto-

matically detecting bystanders in photos to reduce privacy
risks,” in 2020 IEEE Symposium on Security and Privacy
(SP), pp. 318–335, IEEE.

[52] R. Templeman, M. Korayem, D. Crandall, and A. Kapadia,

[36] L. De Moura and N. Bjørner, “Satisﬁability modulo theo-

ries: introduction and applications,” Communications of the
ACM, vol. 54, no. 9, pp. 69–77, 2011.

[37] C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jo-
vanović, T. King, A. Reynolds, and C. Tinelli, “Cvc4,” in
International Conference on Computer Aided Veriﬁcation,
pp. 171–177, Springer, 2011.

[38] B. Dutertre and L. De Moura, “The yices smt solver,” Tool

paper at http://yices. csl. sri. com/tool-paper. pdf, vol. 2,
no. 2, pp. 1–2, 2006.

[39] L. De Moura and N. Bjørner, “Z3: An eﬃcient smt solver,”
in International conference on Tools and Algorithms for
the Construction and Analysis of Systems, pp. 337–340,
Springer, 2008.

[40] A. Farzan, M. Heizmann, J. Hoenicke, Z. Kincaid, and

A. Podelski, “Automated program veriﬁcation,” in Inter-
national Conference on Language and Automata Theory and
Applications, pp. 25–46, Springer, 2015.

[41] S. Kundu, Z. Tatlock, and S. Lerner, “Proving optimizations
correct using parameterized program equivalence,” ACM
Sigplan Notices, vol. 44, no. 6, pp. 327–337, 2009.

[42] Y. Bertot and P. Castéran, Interactive theorem proving and

program development: Coq’Art: the calculus of inductive

“PlaceAvoider: Steering ﬁrst-person cameras away from sen-
sitive spaces,” in Proceedings 2014 Network and Distributed
System Security Symposium, Internet Society.

[53] “eXtensible access control markup language (XACML) ver-

sion 3.0,” p. 154.

[54] D. P. Guelev, M. Ryan, and P. Y. Schobbens, “Model-

checking access control policies,” in Information Security
(K. Zhang and Y. Zheng, eds.), Lecture Notes in Computer
Science, pp. 219–230, Springer.

[55] G. Hughes and T. Bultan, “Automated veriﬁcation of access
control policies using a SAT solver,” vol. 10, no. 6, pp. 503–
520.

[56] D. J. Dougherty, K. Fisler, and S. Krishnamurthi, “Specify-
ing and reasoning about dynamic access-control policies,” in
Automated Reasoning (U. Furbach and N. Shankar, eds.),
Lecture Notes in Computer Science, pp. 632–646, Springer.

[57] J. Backes, P. Bolignano, B. Cook, C. Dodge, A. Gacek,

K. Luckow, N. Rungta, O. Tkachuk, and C. Varming,
“Semantic-based automated reasoning for AWS access poli-
cies using SMT,” in 2018 Formal Methods in Computer
Aided Design (FMCAD), pp. 1–9.

[58] L. de Moura and N. Bjørner, “Z3: An eﬃcient SMT solver,”
in Tools and Algorithms for the Construction and Analysis of

Systems (C. R. Ramakrishnan and J. Rehof, eds.), Lecture
Notes in Computer Science, pp. 337–340, Springer.

Veriﬁed Access Control for Localization and Mapping

18

