Autoregressive Policies for Continuous Control Deep Reinforcement Learning

Dmytro Korenkevych1 , A. Rupam Mahmood1 , Gautham Vasan1 , James Bergstra1
1Kindred AI
{dmytro.korenkevych, rupam, gautham.vasan, james}@kindred.ai

9
1
0
2

r
a

M
7
2

]

G
L
.
s
c
[

1
v
4
2
5
1
1
.
3
0
9
1
:
v
i
X
r
a

Abstract

Reinforcement learning algorithms rely on explo-
ration to discover new behaviors, which is typically
achieved by following a stochastic policy. In con-
tinuous control tasks, policies with a Gaussian dis-
tribution have been widely adopted. Gaussian ex-
ploration however does not result in smooth trajec-
tories that generally correspond to safe and reward-
ing behaviors in practical tasks. In addition, Gaus-
sian policies do not result in an effective explo-
ration of an environment and become increasingly
inefﬁcient as the action rate increases. This con-
tributes to a low sample efﬁciency often observed
in learning continuous control tasks. We introduce
a family of stationary autoregressive (AR) stochas-
tic processes to facilitate exploration in continuous
control domains. We show that proposed processes
possess two desirable features:
subsequent pro-
cess observations are temporally coherent with con-
tinuously adjustable degree of coherence, and the
process stationary distribution is standard normal.
We derive an autoregressive policy (ARP) that im-
plements such processes maintaining the standard
agent-environment interface. We show how ARPs
can be easily used with the existing off-the-shelf
learning algorithms. Empirically we demonstrate
that using ARPs results in improved exploration
and sample efﬁciency in both simulated and real
world domains, and, furthermore, provides smooth
exploration trajectories that enable safe operation
of robotic hardware.

1 Introduction
Reinforcement Learning (RL) is a promising approach to
solving complex real world tasks with physical robots, sup-
ported by recent successes [Andrychowicz et al., 2018;
Kalashnikov et al., 2018; Haarnoja et al., 2018]. Exploration
is an integral part of RL responsible for discovery of new
behaviors.
It is typically achieved by executing a stochas-
tic behavior policy [Sutton and Barto, 2018]. In continuous
control domain, for instance, policies with a parametrized
Gaussian distribution have been commonly used [Schul-
man et al., 2015; Levine et al., 2016; Mnih et al., 2016;

Schulman et al., 2017; Haarnoja et al., 2018]. The sam-
ples from such policies are temporally coherent only through
the distribution mean. In most environments this coherence
is not sufﬁcient to provide consistent and effective explo-
ration.
In early stages of learning in particular, with ran-
domly initialized policy parameters, exploration essentially
relies on a white noise process around zero mean. In envi-
ronments where actions represent low-level motion control,
e.g. velocity or torque, such exploration rarely produces a
consistent motion that could lead to discovery of reward-
ing behaviors. This contributes to low sample efﬁciency of
learning algorithms [Wawrzynski, 2015; Hoof et al., 2017;
Plappert et al., 2018]. For real world robotic applications a
short reaction time is often desirable, however, as action rate
increases, a white noise exploration model becomes even less
viable, effectively locking the robot in place [Plappert et al.,
2018]. In addition, temporally incoherent exploration results
in a jerky movement on physical robots leading to hardware
damage and safety concerns [Peters and Schaal, 2007].

In this work we observe that the parameters of policy distri-
bution typically exhibit high temporal coherence, particularly
at higher action rates. Speciﬁcally, in the case of Gaussian
policy distribution, the action can be represented as a sum
of deterministic parametrized mean and a scaled white noise
component. The mean part typically changes smoothly be-
tween subsequent states. It is the white noise part that results
in inconsistent exploration behavior. We propose to replace
the white noise component with a stationary autoregressive
Gaussian process that has stationary standard normal distri-
bution, while exhibiting temporal coherence between subse-
quent observations. We derive a general form of these pro-
cesses of an arbitrary order and show how the degree of tem-
poral coherence can be continuously adjusted with a scalar
parameter. We demonstrate an advantage of higher orders
processes compared to the ﬁrst order ones used in prior work.
Further, we propose an agent’s policy structure that directly
implements the autoregessive computation in such processes.
Temporal action smoothing mechanism therefore is not hid-
den from the agent but is made explicit through its policy
function. In order to achieve this, we require a ﬁxed length
history of past states and actions. However, the set of re-
sulting history-dependent policies contains the set of Markov
deterministic policies, and those contain the optimal policies
in many tasks [Puterman, 2014, Section 4.4]. We ﬁnd that,

 
 
 
 
 
 
in practical applications, the search for such optimal policies
can be more efﬁcient and safe in a space of history-dependent
stochastic policies with special structure, compared to con-
ventional search in a space of Markov stochastic policies.

Empirically we show that proposed autoregressive policies
can be used with off-the-shelf learning algorithms and result
in superior exploration and learning in sparse reward tasks
compared to conventional Gaussian policies, while achieving
similar or slightly better performance in tasks with dense re-
ward. We also show that the drop in learning performance
due to increasing action rate can be greatly mitigated by in-
creasing the degree of temporal coherence in the underlying
autoregressive process. In the real world robotic experiments
we demonstrate that the autoregressive policies result in a
smoother and safer movement. 1

2 Related Work

The problem of exploration in Reinforcement Learning has
been studied extensively. One approach has been to mod-
ify the environment by changing its reward function to make
it easier for an agent to obtain any rewards or to encourage
the agent to visit new environment states. This approach in-
cludes work on reward shaping [Ng et al., 1999] and auxiliary
reward components such as curiosity [Oudeyer et al., 2007;
Houthooft et al., 2016; Pathak et al., 2017; Burda et al.,
2018]. Note that regardless of chosen reward function tem-
porally consistent behavior would still be beneﬁcial in most
tasks as it would discover rewarding behaviors more efﬁ-
ciently. A randomly initialized agent is unaware of the reward
function and for example will not exhibit curiosity until after
some amount of learning, which already requires visiting new
states and discovering rewarding behaviors in the ﬁrst place.
A second approach, particularly common in practical
robotic applications, has been to directly enforce temporal
coherence between subsequent motion commands.
In the
most simple case a low-pass ﬁlter is applied, e.g. the agent
actions are exponentially averaged over the ﬁxed or inﬁnite
length window [Benbrahim and Franklin, 1997]. A similar
alternative is to employ a derivative control where agent’s ac-
tions represent higher order derivatives of the control signal
[Mahmood et al., 2018a]. Both of these approaches corre-
spond to acting in a modiﬁed MDP with different state and
action spaces and result in a less direct connection between
agent’s action and its consequence in the environment, which
can make the learning problem harder. They also make the
process less observable unless the agent has access to the his-
tory of past actions used in smoothing and to the structure
of a smoothing mechanism itself, which is typically not the
case. As in the case with modiﬁed reward function, the opti-
mal policies in the new MDP generally may not correspond
to the optimal policies in the original MDP.

A third approach has been to learn parameters of prede-
ﬁned parametrized controllers, such as motor primitives, in-
stead of learning control directly in the actuation space [Pe-
ters and Schaal, 2008]. This approach is attractive, as it al-
lows to ensure safe robot behaviour and often results in an

1See accompanying video at https://youtu.be/NCpyXBNqNmw

easier learning problem [ Hoof et al., 2017]. However, it re-
quires expert knowledge to deﬁne appropriate class of con-
trollers and limits possible policies to those, representable
within the selected class. In complex tasks [Andrychowicz
et al., 2018; Kalashnikov et al., 2018] it may be non-trivial to
design a sufﬁciently rich primitives set.

Several studies have considered applying exploration noise
to policy distribution parameters such as network weights and
hidden units activations. Plappert et al. [2017] applied Gaus-
sian exploration noise to policy parameters at the beginning
of each episode, demonstrating a more coherent and efﬁcient
exploration behavior compared to only adding Gaussian noise
[2017] similarly ap-
to the action itself. Fortunato et al.
plied independent Gaussian noise to policy parameters, where
the scale of the noise was also learned via gradient descent.
Both of these works demonstrated improved learning perfor-
mance compared to baseline Gaussian action space explo-
ration, in particular in tasks with sparse rewards. Our ap-
proach is fully complimentary to auxiliary rewards and para-
metric noise ideas, as both still rely on exploration noise in the
action space in addition to other noise sources and can beneﬁt
from consistent and temporally smooth exploration trajecto-
ries provided by our method.

In the context of continuous control deep RL our work is
most closely related to the use of temporally coherent Gaus-
sian noise during exploration. Wawrzynski [2015] used mov-
ing average process for exploration where temporal smooth-
ness of exploration trajectories was determined by the in-
They showed that
teger size of an averaging window.
learning with such process results in a similar ﬁnal perfor-
mance as with standard Gaussian exploration, while provid-
ing smoother behavior suitable for physical hardware appli-
cations. Hoof et al. [2017] proposed a stationary ﬁrst order
AR exploration process in parameters space. Lillicrap et al.
[2015] and Tallec et al.
[2019] used Ornstein–Uhlenbeck
(OU) process for exploration in off-policy learning. The lat-
ter work showed that adjusting process parameters according
to the time step duration helps to maintain exploration perfor-
mance at higher action rates. It can be shown that in a discrete
time form OU process is a ﬁrst order Gaussian AR process,
which makes it a particular case of our model. AR processes
derived in this work generalize the processes used in these
studies, providing a wider space of possible exploration tra-
jectories. In addition, the current work proposes policy struc-
ture that directly implements autoregressive computation, in
contrast to the above studies, where the agent was unaware
of the noise structure. Due to this explicit policy formulation,
autoregressive exploration can be used in both, on-policy and
off-policy learning.

Autoregressive architectures have been proposed in the
context of high-dimensional discrete or discretized continu-
ous action spaces [Metz et al., 2017; Vinyals et al., 2017]
with regression deﬁned over action components. The objec-
tive of such architectures was to reduce dimensionality of the
action space. In contrast, we draw on autoregressive stochas-
tic processes literature, and deﬁne regression over time steps
directly in a multidimensional continuous action space with
the objective of enforcing temporally coherent behaviour.

3 Background
Reinforcement Learning
Reinforcement Learning (RL) framework [Sutton and Barto,
2018] describes an agent interacting with an environment
at discrete time steps. At each step t the agent receives
the environment state st ∈ S and a scalar reward signal
rt ∈ R. The agent selects an action at ∈ A according
to a policy deﬁned by a probability distribution π(a|s) :=
P (cid:8)at = a|st = s(cid:9). At the next time step t + 1 in part
due to the agent’s action, the environment transitions to a
new state st+1 and produces a new reward rt+1 accord-
ing to a transition probability distribution p(s(cid:48), r|s, a) :=
Pr (cid:8)st+1 = s(cid:48), rt+1 = r|st = s, at = a(cid:9). The objective of
the agent is to ﬁnd a policy that maximizes the expected
:=
return deﬁned as the future accumulated rewards Gt
(cid:80)∞
k=t γk−trk+1, where γ ∈ [0, 1] is a discount factor.
In
practice, the agent observes the environment’s state partially
through a real-valued observation vector ot.

Autoregressive processes
An autoregressive process of order p ∈ N (AR-p) is deﬁned
as

Xt = (cid:80)p

k=1 φkXt−k + Zt,

(1)
where φk ∈ R, k = 1, . . . , p are real coefﬁcients, and
Zt is a white noise with zero mean and ﬁnite variance,
Zt ∼ WN(0, σ2

Z < ∞.

Z), σ2

An autoregressive process {Xt} is called weakly station-
ary, if its mean function µX (t) = E[Xt] is independent of
t and its covariance function γX (t + h, t) = cov(Xt+h, Xt)
is independent of t for each h. In the future we will use the
term stationary implying this deﬁnition. The process (1) is
stationary if the roots Gi, i = 1, . . . , p (possibly complex) of
its characteristic polynomial

P (z) := zp −

p
(cid:88)

i=1

φizp−i

lie within a unit circle, e.g. |Gi| < 1, i = 1, . . . , p (see e.g.
[Brockwell et al., 2002, Section 3.1]).

An autocovariance function γk is deﬁned as γk =
cov(Xt, Xt−k), k = 0, ±1, ±2, . . .. From deﬁnition, γ0 =
var(Xt) = σ2
X . For a stationary AR-p process a linear system
of Yule-Walker equations holds:










γ1
γ2
γ3
...
γp










=










γ0
γ1
γ2
...
γp−1

γ1
γ0
γ1
...
γp−2










. . . γp−1
. . . γp−2
. . . γp−3
...
. . .
γ0
. . .










φ1
φ2
φ3
...
φp










(2)

4 Stationary autoregressive Gaussian

processses

In this section we derive a family of stationary AR-p Gaussian
processes for any p ∈ N, such that Xt ∼ N (0, 1) ∀t, meaning
Xt has a marginal standard normal distribution at each t. We
also show how the degree of temporal smoothness of trajec-
tories formed by subsequent observations of such processes
can be continuously tuned with a scalar parameter.
Proposition 4.1. For any p ∈ N and for any αk ∈ [0, 1),
k = 1, . . . , p consider a set of coefﬁcients
k=0 = (−1)k+1 (cid:88)

αi1αi2 . . . αik .

{ ˜φk}p

(3)

1≤i1<i2···<ik≤p

The Yule-Walker system (2) with coefﬁcients { ˜φk} has a
unique solution with respect to (˜γ0, ˜γ1, . . . , ˜γp, ˜σ2
Z), such that
˜γ0 = 1 and ˜σ2
Z > 0. Furthermore, the autoregressive process

p
(cid:88)

Xt =

˜φkXt−k + Zt

k=1
Zt ∼ N (0, ˜σ2

Z),

(4)

is a stationary Gaussian process with zero mean and unit
variance, meaning Xt ∼ N (0, 1) ∀t.

Proof. The proof follows from the observation that { ˜φk} are
coefﬁcients of a polynomial P (z) = (z−α1)(z−α2) . . . (z−
αp) with roots {αk} that all lie within a unit circle. Since
P (z) is a characteristic polynomial of a process (4), the pro-
cess is stationary. The existence of a unique solution to the
system (2) with ˜γ0 = 1, ˜σ2
Z > 0 follows from the obser-
vation that for any ˜σ2
Z > 0 the system (2) has a unique so-
lution with respect to (˜γ0, ˜γ1, . . . , ˜γp), while it is homoge-
neous with respect to (˜γ0, ˜γ1, . . . , ˜γp, ˜σ2
Z). The result then
follows from observing that ˜γ0 > 0, and scaling the solution
(˜γ0, ˜γ1, . . . , ˜γp, ˜σ2
Z) by 1/˜γ0. A complete proof can be found
in Appendix A.

Corollary 4.1.1. For any p ∈ N and for any α ∈ [0, 1) let
{Xt} be the autoregressive process:

Xt =

p
(cid:88)

k=1

˜φkXt−k + Zt

˜φk = (−1)k+1

(cid:19)

(cid:18)p
k

αk

Zt ∼ N (0, ˜σ2

Z),

(5)

k

p!

k!(p−k)! is a binomial coefﬁcient, ˜σ2

(cid:1) =

where (cid:0)p
tion to the system (2) with {φk = ˜φk}p
Xt ∼ N (0, 1) ∀t.

Z is a solu-
k=1 and γ0 = 1. Then

and

γ0 =

p
(cid:88)

i=1

φiγi + σ2
Z.

The system (2) has a unique solution with respect to the

variables {γk}, k = 0, . . . , p.

Proof. Set αk = α ∀k in (3) and apply Proposition 4.1.

An example of a third order process AR-3 deﬁned by (4) is
given in Appendix B.

Proposition 4.1 allows to formulate stationary autoregres-
sive processes of an arbitrary order p for arbitrary values

We would like to build an agent that implements stochastic
policy with samples, deﬁned by (7). From deﬁnition (5) of
the process {Xt}, (7) can be expanded as

at = µθ(st) + σθ(st)

εt ∼ N (0, I).

p
(cid:88)

k=1

˜φkXt−k + σθ(st)˜σZεt,

(8)

From (7) also, Xt = (at − µθ(st))/σθ(st) ∀t, hence (8) can
be rewritten as

at = µθ(st) + σθ(st)

+ σθ(st)˜σZεt,

p
(cid:88)

k=1

˜φk

at−k − µθ(st−k)
σθ(st−k)

+

(9)

εt ∼ N (0, I).
Denote fθ,t = (cid:80)p
the auto-regressive
”history” term in (9). Note that fθ,t is a function of past p
states and actions, fθ,t = f ({st−k, at−k}p
k=1, θ). Then at
follows the distribution:

at−k−µθ(st−k)
σθ(st−k)

˜φk

k=1

at ∼ N (µθ(st) + σθ(st)fθ,t, σ2
˜φk, ˜σ2
Z are deﬁned by (5).

θ (st)˜σ2

Z · I),

(10)

t ), where hp

In order to implement such action distribution, we need to
deﬁne a history-dependent policy π(at|st, hp
t =
(st−p, at−p, . . . , st−1, at−1) is a history of past p states and
actions. In general, history-dependent policies do not induce
Markov stochastic processes, even if the environment tran-
sition probabilities are Markovian [Puterman, 2014, Section
2.1.6]. However when the dependence is only on a history of
a ﬁxed size, such policy induces a Markov stochastic process
in an extended state space, where states are deﬁned as pairs
(hp
t , st). In order to be able to lean on existing theoretical re-
sults, such as Policy Gradient Theorem [Sutton et al., 2000],
and to use existing learning algorithms, we will talk about
learning policies in this extended MDP.

More formally, let M = (S, A, P (·|a, s), r(s, a)) be a
given MDP with S and A denoting state and action sets, and
P and r denoting transition probability and reward functions
respectively. Let p be an arbitrary integer number. We deﬁne
a modiﬁed MDP ˜M p = ( ˜S, ˜A, ˜P (·|a, ˜s), ˜r(˜s, a)) with the el-
ements ˜S = {S × A}p × S, where {C}p denotes Cartesian
product of set C with itself p times, ˜A = A, and ˜P and ˜r
deﬁned as follows:

∀˜s, ˜s(cid:48) ∈ ˜S :

˜s = (s1, a1, . . . , sp, ap, sp+1), ak ∈ A, sk ∈ S ∀k
˜s(cid:48) = (s(cid:48)
p, s(cid:48)
k ∈ S ∀k


1, . . . , s(cid:48)

p, a(cid:48)

p+1|a, sp+1),

k ∈ A, s(cid:48)

p+1), a(cid:48)
if s(cid:48)
k = sk+1, k ≤ p
a(cid:48)
k = ak+1, k < p
a(cid:48)
p = a

˜P (˜s(cid:48)|a, ˜s) =

1, a(cid:48)
P (s(cid:48)



0

˜r(˜s, a) = r(sp+1, a)

otherwise

Figure 1: Realizations of processes (5) for different p and α and the
same set of 3 random seeds.

αk ∈ [0, 1), k = 1, . . . , p, such that the marginal distribu-
tions of realizations of these processes are standard normal at
each time step. This gives us great ﬂexibility and power in
deﬁning properties of these processes, such as the degree of
temporal coherence between process realizations at various
time lags. If we were to use these processes as a source of
exploration behavior in RL algorithms, this ﬂexibility would
translate into a ﬂexibility in deﬁning the shape and smooth-
ness of exploration trajectories. Note, that the process (4)
trivially generalizes to a vector form by deﬁning Zt a multi-
variate white noise with a diagonal covariance.

Autoregressive processes in the general form (4) possess a
number of interesting properties that can be utilized in rein-
forcement learning. However, for the purposes of the discus-
sion in the following sections, from now on we will consider
a simpler subfamily of processes, deﬁned by (5). Notice, that
α = 0 results in ˜φk = 0 ∀k, and Xt becomes a white Gaus-
sian noise. On the other hand, α → 1 results in σ2
Z → 0, and
Xt becomes a constant function. Therefore, tuning a single
scalar parameter α from 0 to 1 continuously adjusts tempo-
ral smoothness of Xt ranging from white noise to a constant
function. Figure 1 shows realizations of such processes at dif-
ferent values of p and α. The realizations are initialized from
the same set of 3 random seeds for each p, α pair.

5 Autoregressive policies
In continuous control RL a policy is often deﬁned as a
parametrized diagonal Gaussian distribution:

θ (st) · I),

pθ(at|st) = N (µθ(st), σ2

(6)
where st is a state at time t, µθ(st) and σ2
θ (st) are vectors
parametrized by deep neural networks. The actions, sampled
from such distribution, can be represented as at = µθ(st) +
σθ(st)εt, where εt ∼ N (0, I) is a white Gaussian noise. We
propose to replace εt with observations of an AR-p process
{Xt} deﬁned by (5) for some p ∈ N and α ∈ [0, 1):

at = µθ(st) + σθ(st)Xt.
(7)
Both εt and Xt follow marginal standard normal distribution
at each step t, therefore such substitution does not change
the network output to noise ratio in sampled actions, how-
ever for α > 0 the sequence {Xt} possesses temporal coher-
ence and can provide a more consistent exploration behavior.

050100202p = 1, = 0.0050100202p = 1, = 0.5050100202p = 1, = 0.8050100202p = 1, = 0.9050100202p = 3, = 0.0050100202p = 3, = 0.5050100202p = 3, = 0.8050100202p = 3, = 0.9050100202p = 5, = 0.0050100202p = 5, = 0.5050100202p = 5, = 0.8050100202p = 5, = 0.9In other words, transitions in a modiﬁed MDP ˜M p cor-
respond to transitions in the original MDP M with states
in ˜M p containing also the history of past p states and ac-
tions in M . The interaction between the agent and the en-
vironment, induced by ˜M p, occurs in the following way.
At each time t the agent is presented with the current state
˜st = (st−p, at−p, . . . , st−1, at−1, st). Based on this state and
its policy, it chooses an action at from the set A and sends it to
the environment. Internally, the environment propagates the
action at to the original MDP M , currently in state st, which
responds with a reward value rt+1 and transitions to a new
state st+1. At this moment, the MDP ˜M p transitions to a new
state ˜st+1 = (st−p+1, at−p+1, . . . , st, at, st+1) and presents
it to the agent together with the reward rt+1. Let s0 be an
element of the set of the initial states of M . A corresponding
initial state of ˜M p is deﬁned as ˜s0 = (s0, a0, . . . , s0, a0
, s0),
(cid:125)

(cid:124)

(cid:123)(cid:122)
p repetitions

where a0 is any element of an action set A, for example zero
vector in the case of continuous space. The particular choice
of a0 is immaterial, since it does not affect future transitions
and rewards (more details in Appendix E).
We deﬁne an autoregressive policy (ARP) over ˜M p as:
∀˜st = (st−p, at−p, . . . , st−1, at−1, st) :

πθ(at|˜st) = N (µθ(st) + σθ(st)fθ(˜st), σ2

θ (st)˜σ2

ZI),

fθ(˜st) =

p
(cid:88)

k=1

˜φk

at−k − µθ(st−k)
σθ(st−k)

,

˜φk, ˜σ2

Z are deﬁned by (5),

(11)

where µθ(·) and σθ(·) are parametrized function approxima-
tions, such as deep neural networks. For notation brevity,
we omitted dependence of policy πθ on { ˜φk} and ˜σZ, since
these values are constant once the autoregressive model {Xt}
is selected. In this parametrization, µθ(st−k), k = 0, . . . , p
should be thought of as the same parametrized function µθ(·)
applied to different parts of the state vector ˜st, therefore each
occurence of µθ(·) in (11) contributes to the gradient w.r.t.
parameters θ. Similarly, each occurence of σθ(·) contributes
to the gradient w.r.t. θ. Note, that including history of states
and actions does not affect the dimensionality of the input to
the function approximations, as both µθ(·) and σθ(·) accept
only states from the original space as inputs.

The history-dependent policy (11) results in the desired ac-
tion distribution (10) in the original MDP M , at the same time
with respect to ˜M p it is just a particular case of a Gaussian
policy (6). Formally, we will perform learning in ˜M p, where
πθ is Markov, and therefore all the related theoretical results
apply, and any off-the-shelf learning algorithm, applicable
to policies of type (6), can be used. In particular, the value
function in e.g. actor-critic architectures is learned with usual
methods. Empirically we found that conditioning value func-
tion only on a current state st from the original MDP instead
of an entire vector ˜st gives more stable learning performance.
It also helps to maintain the critic network size invariant to
the AR process order p.

By design, for each sample path (˜s0, a0, ˜s1, a1, . . .) in ˜M p
there is a corresponding sample path (s0, a0, s1, a1, . . .) in M

with identical rewards. Therefore, improving the policy and
the obtained rewards in ˜M p results in identical improvement
of a corresponding history-dependent policy in M . Notice
also, that if σθ(st) → 0 in (11), then πθ reduces to a Markov
deterministic policy at = µθ(st) in M . Therefore, the op-
timal policy in the set of ARPs deﬁned by (11) is at least as
good, as the best deterministic policy in the set of policies
at = µθ(st). This is in contrast with action averaging ap-
proaches, where temporal smoothing is typically imposed on
the entire action vector and not just on the exploration com-
ponent, limiting the space of possible deterministic policies.
It is important to point out that for any history-dependent
policy there exists an equivalent Markov stochastic policy
with identical expected returns [Puterman, 2014, Theorem
5.5.1]. For the policy (11), for example, it can be constructed
as πM
πθ(a|s, hp)p(hp|s, πθ) ∀(a, s), where

θ (a|s) = (cid:80)

hp∈H p

H p is a set of all histories of size p. However, πM
θ (a|s)
is a non-trivial function of a state s, unknown to us at the
beginning of learning.
It is certainly not given by a ran-
dom initialization of (6), while a random initialization of (11)
already provides consistent and smooth behavior. πM (a|s)
also cannot be derived analytically from (11), since comput-
ing p(hp|s, πθ) requires knowledge of environment transition
probabilities, which we cannot expect to have for each given
task. From these considerations, the particular form of pol-
icy parametrization deﬁned by (11) can also be thought of
as an additional structure, enforced upon the general class of
Markov policies, such as policies deﬁned by (6), restricting
possible behaviors to temporally coherent ones.

Although autoregressive term fθ(˜st) in (11) is formally a
part of the distribution mean, numerically it corresponds to a
stationary zero mean random process Ft = (cid:80)p
˜φkXt−k,
where {Xt} is an underlying AR process deﬁned by (5).
Therefore, fθ(˜st) can be thought of as a part of an action
exploration component around the ”true” mean, given by
µθ(st). It is this part that ensures a consistent and smooth
exploration, as will be demonstrated in the next section.

k=1

In principle, one could deﬁne πθ in (11) using arbitrary
values of coefﬁcients { ˜φk} and ˜σ2
Z. The role of particular
values of { ˜φk} computed according to (5) is to make sure,
that the underlying AR process {Xt} is stationary and the
autoregressive part fθ(˜st) does not explode. The role of ˜σ2
Z
computed by solving (2) with coefﬁcients {φk = ˜φk} and
γ0 = 1 is to make sure, that the variance of the underlying
process {Xt} is 1. The total variance around µθ(st) is then
conveniently deﬁned by an agent controlled σθ(st).

Since linear system (2) with coefﬁcients (3) and γ0 = 1 has
a unique solution according to the Proposition 4.1, its matrix
has a full rank, and therefore the system is well-determined
and can be solved numerically to an arbitrary precision. In
practice we solve it with numpy.linalg.solve function.

6 Experiments
We compared conventional Gaussian policy with ARPs on
a set of tasks with both, sparse and dense reward functions,
in simulation and the real world.
In the following learn-
ing experiments we used the Open AI Baselines PPO algo-

Figure 2: a) Autocorrelation function ρτ for autoregressive pro-
cesses (5) with different orders p but the same value of ρ1 = 0.99.
b) Realizations of processes (5) with the same ρ1 = 0.99.

rithm implementation [Schulman et al., 2017; Dhariwal et
al., 2017]. The results with Baselines TRPO [Schulman et
al., 2015] are provided in Appendix C. For each experiment
we used identical algorithm hyper-parameters and neural net-
work structures to parametrize µθ, σθ and the value networks
for both Gaussian and ARP policies. We used the same set of
random seeds to initialize neural networks and the same set
of random seeds to initialize environments that involve un-
certainty. Detailed parameters for each task are included in
Appendix D. We did not perform a hyper-parameter search
to optimize for ARP performance, as our primary objective
is to demonstrate the advantage of temporally coherent ex-
ploration even in the setting, tuned for a standard Gaussian
policy. The video of agent behaviors can be found at https:
//youtu.be/NCpyXBNqNmw. The code to reproduce experi-
ments is available at https://github.com/kindredresearch/arp.

The order of an autoregressive process
From Figure 1 one can notice that the temporal smoothness
of realizations of AR processes (5) empirically increases with
both, parameter α and order p. Why do we need higher order
processes if we can simply increase α to achieve a higher
degree of temporal coherence? To answer this question
it is helpful to consider an autocorrelation function (ARF)
ρτ = cov(Xt, Xt+τ )/var(Xt) = γτ /γ0 of these processes.
White Gaussian noise by deﬁnition has autocorrelation func-
tion equal to zero at any τ other than 0. An autoregressive
process with non-zero coefﬁcients generally has non-zero val-
ues of autocorrelation function at all τ .

One of the reasons we are interested in autoregressive pro-
cesses for exploration is that they provide smooth trajecto-
ries that do not result in jerky movement and do not damage
physical robot hardware. Intuitively, the smoothness of the
process realization is deﬁned by a correlation between subse-
quent observations corr(Xt, Xt+1) = ρ1, which for a given p
increases with increasing α. However, given the same value
ρ1, processes of different orders p behave differently. Fig-
ure 2a shows ARFs for different processes deﬁned by (5)
and their corresponding values of α with the same value of
ρ1 = 0.99, while Figure 2b shows realizations of these pro-
cesses. ARF values at higher orders p decrease much faster
with increasing time lag τ compared to the 1st order pro-
cess, where correlation between past and future observations

Figure 3: a) Average time to target in Square environment as a func-
tion of an action rate for Gaussian policy and ARPs with varied α.
b) 10 seconds long exploration trajectories at 10Hz (left column) and
100Hz (right column) action rate using Gaussian policy (top row)
and ARPs with p = 3 and α values 0.8 and 0.95 (bottom row).

lingers over long periods of time. As shown on Figure 2b,
the 1st order AR process produces nearly a constant func-
tion, while the 5th order process exhibits a much more diverse
exploratory behavior. Given the same value of correlation
between subsequent realizations, higher order autoregressive
processes exhibit lower correlation between observations dis-
tant in time, resulting in trajectories with better exploration
potential. In robotics applications where smoothness of the
trajectory can be critical, higher order autoregressive pro-
cesses may be a preferable choice. Empirically we found that
the 3-rd order processes provide sufﬁciently smooth trajecto-
ries while exhibiting a good exploratory behavior, and used
p = 3 in all our subsequent learning experiments varying
only the smoothing parameter α.

Toy environment with sparse reward

To demonstrate the advantage of temporally consistent ex-
ploration, in particular at high action rates, we designed a
toy Square environment with a 2D continuous state space
bounded by a 10x10 square arena. The agent controls a dot
through a continuous direct velocity control. The agent is ini-
tialized in the middle of the arena at the start of each episode
and receives a -1 reward at each time step scaled by time step
duration. The target is generated at a random location on a
circle of diameter 5 centered at the middle of the arena to
make episodes homogenous in difﬁculty. The episode is over
when the agent approaches the target to within a distance of
0.5. The action space is bounded within a two-dimensional
[−1, 1]2 interval. The observation vector contains the agent’s
position, velocity, and the vector difference between agent
position and the target position.

To compare exploration efﬁciency we ran random ARP
(p = 3) and Gaussian agents with µθ(·), σθ initialized to
(cid:126)0 and (cid:126)1 respectively for 10 million simulated seconds at dif-
ferent action rates. Figure 3a shows average time to reach the
target as a function of an action rate. The results show that
the optimal degree of temporal coherence depends on the en-
vironment properties, such as action rate. At low control fre-
quency a white Gaussian exploration is more effective than
ARPs with high α, as in the latter the agent quickly reaches

01020304050time lag 0.00.20.40.60.81.0a)p = 1,  = 0.99p = 2,  = 0.87p = 3,  = 0.79p = 5,  = 0.69050100202b)p = 1,  = 0.99050100202p = 2,  = 0.87050100202p = 3,  = 0.79050100202p = 5,  = 0.69125102050100Action rate, Hz104105Average time to target, sbad for exploration, bad for hardwarea)good for exploration, good for hardwareGaussian policyARP, =0.5ARP, =0.8ARP, =0.9ARP, =0.9555b)10Hz control5555()=1()=10100Hz control55Figure 6: Learning curves on a UR5 Reacher 2D environment with
sparse reward at 25Hz and 125Hz velocity control. Thick lines rep-
resent average across runs, thin lines show individual curves.

The advantage of ARPs in exploration translates into an ad-
vantage in learning. Figure 4 shows learning curves (averaged
over 5 random seeds) on Square environment at different ac-
tion rates ran for 50,000 seconds of total simulated time with
episodes limited to 1000 simulated seconds. Not only ARPs
exhibit better learning, but the initial random behaviour gives
much higher returns compared to initial Gaussian agent be-
haviour. At higher action rates ARPs with higher α produce
better results.

In the formulation of the AR-1 process used in Lillicrap
et al. [2015] and in Tallec et al. [2019], parameter α corre-
sponds to 1 − κdt, where dt is a time step duration. Hence,
in that formulation α naturally approaches 1 as dt approaches
zero. Note, that in order to achieve the best performance on
each given task, parameter κ still needs to be tuned, just as
parameter α needs to be tuned in our formulation. The op-
timal values of these parameters depend not only on action
rate, but also on environment properties, such as a size of a
state space relative to the typical size of an agent step.

Mujoco experiments
Figure 5 shows the learning results on standard OpenAI Gym
Mujoco environments [Brockman et al., 2016]. These en-
vironments have dense rewards, so consistent exploration is
less crucial here compared to tasks with sparse rewards. Nev-
ertheless, we found that ARPs perform similarly or slightly
better, than a standard Gaussian policy. On a Swimmer-v2 en-
vironment ARP resulted in a much better performance com-
pared to Gaussian policy, possibly because in this environ-
ment smooth trajectories are highly rewarded.

Physical robot experiments
On a UR5 robotic arm we were able to obtain results similar
to those in the toy environment. We designed a sparse reward
version of a UR5 Reacher 2D task introduced in [Mahmood et
al., 2018b]. In a modiﬁed task at each time step the agent re-
ceives a -1 reward scaled by a time step duration. The episode
is over when the agent reaches the target within a distance of
0.05. In order to provide sufﬁcient time for exploration in a
sparse reward setting we doubled the episode time duration to
8 seconds. Figure 6 shows the learning curves for 25Hz and
125Hz control. Each curve is an average across 4 random
seeds. The Gaussian policy fails to learn in a 125Hz control
setting within a 5 hours time limit, while ARP was able to ﬁnd
an effective policy in 50% of the runs, and the effectiveness
at higher α increased at a higher action rate.

Figure 4: On a toy 2D environment with sparse reward, white noise
exploration (Gaussian policy) leads to ineffective learning. Tempo-
rally smoother processes are effective at higher action rates.

the boundary of the state space and gets stuck there. The ef-
ﬁciency of Gaussian exploration drops dramatically with the
increase of action rate. However it is possible to recover the
same exploration performance in ARP by increasing accord-
ingly the α parameter. This effect is visualized on Figure 3b
which shows ﬁve 10 seconds long exploration trajectories at
10Hz and 100Hz control for Gaussian and ARP policies. Al-
though ran for the same amount of simulated time, Gaussian
exploration at 100Hz covers substantially smaller area of state
space compared to 10Hz control, while increasing α from 0.8
to 0.95 (the values were chosen empirically) results in ARP
trajectories covering similar space at both action rates. Note
that the issue with Gaussian policy can not be ﬁxed by simply
increasing the variance, as most actions will just be clipped
at the [−1, 1]2 boundary, resulting in a similarly poor explo-
ration. Figure 3b top right plot shows exploration trajectories
for σ(θ) = (cid:126)1 (blue) and σ(θ) = (cid:126)10 (gray). To the contrary of
the common intuition, in bounded action spaces Gaussian ex-
ploration with high variance does not produce a diverse state-
action visitation.

Figure 5: Learning curves in Mujoco-based environments.

0250005000010008006004002000Average return10Hz control02500050000Simulated time, s1000800600400200020Hz control02500050000Simulated time, s10008006004002000Average return50Hz controlGaussian policyARP, =0.5ARP, =0.8ARP, =0.901000000755025Reacher-v2010000000100200300Swimmer-v201000000010002000Hopper-v201000000010002000Walker2d-v20100000001000HalfCheetah-v2Gaussian policyARP, =0.3ARP, =0.5ARP, =0.8012345Time, hours100806040200Average return25Hz controlGaussian policyARP, =0.5ARP, =0.80123456Time, hours100806040200125Hz controlGaussian policyARP, =0.5ARP, =0.87 Conclusions

We introduced autoregressive Gaussian policies (ARPs) for
temporally coherent exploration in continuous control deep
reinforcement learning. The policy form is grounded in
the theory of stationary autoregressive stochastic processes.
We derived a family of stationary Gaussian autoregressive
stochastic processes for an arbitrary order p with continu-
ously adjustable degree of temporal coherence between sub-
sequent observations. We derived an agent policy that im-
plements these processes with a standard agent-environment
interface. Empirically we showed that ARPs result in a supe-
rior exploration and learning in sparse reward tasks and per-
form on par or better compared to standard Gaussian policies
in dense reward tasks. On physical hardware, ARPs result in
smooth trajectories that are safer to execute compared to the
trajectories provided by conventional Gaussian exploration.

References
[Andrychowicz et al., 2018] Marcin Andrychowicz, Bowen
Baker, Maciek Chociej, Rafal Jozefowicz, Bob McGrew,
Jakub Pachocki, Arthur Petron, Matthias Plappert, Glenn
Powell, Alex Ray, et al. Learning dexterous in-hand ma-
nipulation. arXiv preprint arXiv:1808.00177, 2018.

[Benbrahim and Franklin, 1997] Hamid Benbrahim and
Judy A Franklin. Biped dynamic walking using rein-
forcement learning. Robotics and Autonomous Systems,
22(3-4):283–302, 1997.

[Brockman et al., 2016] Greg Brockman, Vicki Cheung,
Ludwig Pettersson, Jonas Schneider, John Schulman, Jie
Tang, and Wojciech Zaremba. Openai gym, 2016.

[Brockwell et al., 2002] Peter J Brockwell, Richard A Davis,
Introduction to time series and

and Matthew V Calder.
forecasting, volume 2. Springer, 2002.

[Burda et al., 2018] Yuri Burda, Harri Edwards, Deepak
Pathak, Amos Storkey, Trevor Darrell, and Alexei A Efros.
arXiv
Large-scale study of curiosity-driven learning.
preprint arXiv:1808.04355, 2018.

[Dhariwal et al., 2017] Prafulla Dhariwal,

Christopher
Hesse, Oleg Klimov, Alex Nichol, Matthias Plappert,
Alec Radford, John Schulman, Szymon Sidor, and Yuhuai
Wu. Openai baselines. GitHub, GitHub repository, 2017.

Fortunato,

[Fortunato et al., 2017] Meire

Moham-
mad Gheshlaghi Azar, Bilal Piot, Jacob Menick, Ian
Osband, Alex Graves, Vlad Mnih, Remi Munos, Demis
Hassabis, Olivier Pietquin, et al. Noisy networks for
exploration. arXiv preprint arXiv:1706.10295, 2017.
[Haarnoja et al., 2018] Tuomas Haarnoja, Aurick Zhou,
Kristian Hartikainen, George Tucker, Sehoon Ha, Jie
Tan, Vikash Kumar, Henry Zhu, Abhishek Gupta, Pieter
Abbeel, et al. Soft actor-critic algorithms and applications.
arXiv preprint arXiv:1812.05905, 2018.

[van Hoof et al., 2017] Herke van Hoof, Daniel Tanneberg,
and Jan Peters. Generalized exploration in policy search.
Machine Learning, 106(9-10):1705–1724, 2017.

[Houthooft et al., 2016] Rein Houthooft, Xi Chen, Yan
Duan, John Schulman, Filip De Turck, and Pieter Abbeel.
Vime: Variational information maximizing exploration.
In Advances in Neural Information Processing Systems,
pages 1109–1117, 2016.

[Kalashnikov et al., 2018] Dmitry Kalashnikov, Alex Irpan,
Peter Pastor, Julian Ibarz, Alexander Herzog, Eric Jang,
Deirdre Quillen, Ethan Holly, Mrinal Kalakrishnan, Vin-
cent Vanhoucke, and Sergey Levine. Scalable deep rein-
forcement learning for vision-based robotic manipulation.
In Aude Billard, Anca Dragan, Jan Peters, and Jun Mo-
rimoto, editors, Proceedings of The 2nd Conference on
Robot Learning, volume 87 of Proceedings of Machine
Learning Research, pages 651–673. PMLR, 29–31 Oct
2018.

[Levine et al., 2016] Sergey Levine, Chelsea Finn, Trevor
Darrell, and Pieter Abbeel. End-to-end training of deep
visuomotor policies. The Journal of Machine Learning
Research, 17(1):1334–1373, 2016.

[Lillicrap et al., 2015] Timothy P Lillicrap, Jonathan J Hunt,
Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
Continuous con-
David Silver, and Daan Wierstra.
arXiv preprint
trol with deep reinforcement learning.
arXiv:1509.02971, 2015.

[Mahmood et al., 2018a] A Rupam Mahmood, Dmytro Ko-
renkevych, Brent J Komer, and James Bergstra. Setting
up a reinforcement learning task with a real-world robot.
In 2018 IEEE/RSJ International Conference on Intelli-
gent Robots and Systems (IROS), pages 4635–4640. IEEE,
2018.

[Mahmood et al., 2018b] A. Rupam Mahmood, Dmytro Ko-
renkevych, Gautham Vasan, William Ma, and James
Bergstra. Benchmarking reinforcement learning algo-
rithms on real-world robots. In CoRL, 2018.

[Metz et al., 2017] Luke Metz, Julian Ibarz, Navdeep Jaitly,
Discrete sequential prediction
arXiv preprint

and James Davidson.
of continuous actions for deep rl.
arXiv:1705.05035, 2017.

[Mnih et al., 2016] Volodymyr Mnih, Adria Puigdomenech
Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asyn-
chronous methods for deep reinforcement learning. In In-
ternational conference on machine learning, pages 1928–
1937, 2016.

[Ng et al., 1999] Andrew Y Ng, Daishi Harada, and Stuart
Russell. Policy invariance under reward transformations:
Theory and application to reward shaping. In ICML, vol-
ume 99, pages 278–287, 1999.

[Oudeyer et al., 2007] Pierre-Yves Oudeyer, Frdric Kaplan,
and Verena V Hafner. Intrinsic motivation systems for au-
tonomous mental development. IEEE transactions on evo-
lutionary computation, 11(2):265–286, 2007.

[Pathak et al., 2017] Deepak

Pulkit Agrawal,
Alexei A Efros, and Trevor Darrell. Curiosity-driven
exploration by self-supervised prediction. In International

Pathak,

Conference on Machine Learning (ICML), volume 2017,
2017.

[Peters and Schaal, 2007] Jan Peters and Stefan Schaal. Re-
inforcement learning by reward-weighted regression for
operational space control. In Proceedings of the 24th inter-
national conference on Machine learning, pages 745–750.
ACM, 2007.

[Peters and Schaal, 2008] Jan Peters and Stefan Schaal. Re-
inforcement learning of motor skills with policy gradients.
Neural networks, 21(4):682–697, 2008.

[Plappert et al., 2017] Matthias Plappert, Rein Houthooft,
Prafulla Dhariwal, Szymon Sidor, Richard Y Chen,
Xi Chen, Tamim Asfour, Pieter Abbeel, and Marcin
Andrychowicz. Parameter space noise for exploration.
arXiv preprint arXiv:1706.01905, 2017.

Plappert,

[Plappert et al., 2018] Matthias

Marcin
Andrychowicz, Alex Ray, Bob McGrew, Bowen Baker,
Glenn Powell, Jonas Schneider, Josh Tobin, Maciek
Chociej, Peter Welinder, et al. Multi-goal reinforcement
learning: Challenging robotics environments and request
for research. arXiv preprint arXiv:1802.09464, 2018.
[Puterman, 2014] Martin L Puterman. Markov decision pro-
cesses: discrete stochastic dynamic programming. John
Wiley & Sons, 2014.

[Schulman et al., 2015] John Schulman, Sergey Levine,
Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust
In International Conference
region policy optimization.
on Machine Learning, pages 1889–1897, 2015.

[Schulman et al., 2017] John Schulman, Filip Wolski, Pra-
fulla Dhariwal, Alec Radford, and Oleg Klimov. Prox-
arXiv preprint
imal policy optimization algorithms.
arXiv:1707.06347, 2017.

[Sutton and Barto, 2018] Richard S Sutton and Andrew G
Barto. Reinforcement learning: An introduction. MIT
press, 2018.

[Sutton et al., 2000] Richard S Sutton, David A McAllester,
Satinder P Singh, and Yishay Mansour. Policy gradient
methods for reinforcement learning with function approxi-
mation. In Advances in neural information processing sys-
tems, pages 1057–1063, 2000.

[Tallec et al., 2019] Corentin Tallec, L´eonard Blier, and
Yann Ollivier. Making deep q-learning methods robust
to time discretization. arXiv preprint arXiv:1901.09732,
2019.

[Vinyals et al., 2017] Oriol Vinyals, Timo Ewalds, Sergey
Bartunov, Petko Georgiev, Alexander Sasha Vezhnevets,
Michelle Yeo, Alireza Makhzani, Heinrich K¨uttler, John
Agapiou, Julian Schrittwieser, et al.
Starcraft ii: A
new challenge for reinforcement learning. arXiv preprint
arXiv:1708.04782, 2017.

[Wawrzynski, 2015] Pawel Wawrzynski.

Control policy
with autocorrelated noise in reinforcement learning for
robotics. International Journal of Machine Learning and
Computing, 5(2):91, 2015.

A Proof of Proposition 4.1
Lemma A.1. For any p ∈ N and for any αk ∈ [0, 1), k = 1, . . . , p the autoregressive process

is stationary.

Proof. Consider a polynomial

It can be written in a form

Xt =

p
(cid:88)

k=1

˜φkXt−k + Zt

˜φk = (−1)k+1 (cid:88)

Zt ∼ WN(0, σ2

1≤i1,i2,...,ik≤p
Z), σ2
Z < ∞,

αi1αi2 . . . αik , k = 1, . . . , p

P (z) = (z − α1)(z − α2) . . . (z − αp).

P (z) = zp −

p
(cid:88)

k=1

˜φkzp−k,

˜φk = (−1)k+1 (cid:88)

αi1αi2 . . . αik , k = 1, . . . , p

1≤i1,i2,...,ik≤p

(12)

(13)

consequently P (z) is a characteristic polynomial of the process (12). By design, P (z) has roots αk, k = 1, . . . , p which all lie
within a unit circle, therefore the process (12) is stationary.

Lemma A.2. Let {Xt} be an autoregressive process deﬁned in (12).
i.e. Zt ∼ N (0, σ2
var(Xt) = σ2

If its white noise component Zt is Gaussian,
Z), then Xt are identically distributed normal random variables with zero mean and ﬁnite variance

X < ∞ ∀t.

Proof. According to lemma A.1 the process (12) is stationary, meaning Xt are identically distributed random variables with
ﬁnite variance var(Xt) = σ2
X < ∞ ∀t. If Zt is Gaussian, then Xt are identically distributed normal variables. Let us denote
µX the mean of this distribution. Taking expectation of both sides of (12) gives

p
(cid:88)

k=1
p
(cid:88)

E[Xt] =

µX =

˜φkE[Xt−k] + E[Zt] ⇒

˜φkµX ⇒

k=1
p
(cid:88)

µX (1 −

k=1

˜φk) = 0.

(1 − (cid:80)p

k=1

˜φk) (cid:54)= 0 since polynomial (13) does not have a root z = 1, therefore µX = 0.

We established that under Gaussian white noise Zt the process (12) represents a series of identically distributed normal
X linearly
X by the same factor
X would have any desired positive value, in particular,

variables with zero mean and ﬁnite variance. From the linear form of the process it is clear that the variance σ2
depends on the variance σ2
β. Therefore, it should be possible to pick σZ such that the variance σ2
value of 1. The following lemma formalizes this observation.
Lemma A.3. For any p ∈ N let {φk, k = 0, . . . , p} be a set of coefﬁcients corresponding to a stationary AR-p process {Xt}
deﬁned in (1). Then the linear system

Z of a white noise component. Scaling σ2

Z by a factor β > 0 results in scaling σ2










γ1
γ2
γ3
...
γp










=










1
γ1
γ2
...
γp−1

γ1
1
γ1
...
γp−2

γ2
γ1
1
...
γp−3

. . . γp−1
. . . γp−2
. . . γp−3
...
. . .
1
. . .



















φ1
φ2
φ3
...
φp










(14)

and

1 =

p
(cid:88)

i=1

φiγi + σ2
Z,

has a unique solution (˜γ1, . . . , ˜γp, ˜σ2

Z), where ˜σ2

Z > 0. Furthermore, the autoregressive process

p
(cid:88)

˜Xt =

φk ˜Xt−k + ˜Zt,

k=1
var( ˜Zt) = ˜σ2
Z

(15)

is stationary with variance ˜σ2

X = var( ˜Xt) = 1.

Proof. For any ˜σ2
{φk}, and therefore, the same characteristic polynomial.

Z > 0 stationarity of { ˜Xt} follows from stationarity of {Xt}, since both processes share the same coefﬁcients

Since {Xt} is stationary, the corresponding system of Yule-Walker equations (2) has a unique solution with respect to
(γ0, γ1, . . . , γp) [Brockwell et al., 2002, Section 3.1]. Notice, however, that the system (2) is homogenous with respect to
the variables (γ0, γ1, . . . , γp, σ2
p, βσ(cid:48)2
1, . . . , βγ(cid:48)
Z ) is also a
2) such that ˜γ0 = 1. We can
solution ∀β ∈ R. Therefore, since γ0 = var(Xt) > 0, exists a unique solution (˜γ0, ˜γ1, . . . , ˜γp, ˜σZ
ﬁnd it by substituting γ0 = 1 into a linear system (2), resulting in (14). This solution corresponds to a stationary process { ˜Xt}
with var( ˜Xt) = ˜γ0 = 1 ∀t.

Z ) is a solution, then (βγ(cid:48)

Z), meaning that if (γ(cid:48)

1, . . . , γ(cid:48)

0, βγ(cid:48)

p, σ(cid:48)2

0, γ(cid:48)

Now the proof of proposition 4.1 is straightforward. By lemma A.1 coefﬁcients { ˜φk} correspond to a stationary autore-
gressive process, therefore by lemma A.3 the system (14) has a unique solution ˜σ2
Z > 0 and the process (4) is a stationary
process with unit variance. Since Zt is normal, by lemma (A.2) the process (4) is Gaussian with zero mean. Therefore,
Xt ∼ N (0, 1) ∀t.

B Example of an AR-3 Gaussian process
A third order process AR-3 deﬁned by (4) has a form:

Xt = (α1 + α2 + α3)Xt−1 − (α1α2 + α2α3 + α1α3)Xt−2 + α1α2α3Xt−3 + σZN (0, 1),

where σ2

Z is a solution of a system:



 =





γ1
γ2
γ3





1
γ1
γ2

γ1
1
γ1





γ2
γ1
1





φ1
φ2
φ3



 ,

φ1 = α1 + α2 + α3
φ2 = −(α1α2 + α2α3 + α1α3)
φ3 = α1α2α3

and

1 =

3
(cid:88)

i=1

φiγi + σ2
Z,

resulting in

σ2
Z =

(1 − α2

1)(1 − α2

2)(1 − α2

3)(1 − α1α2)(1 − α2α3)(1 − α1α3)

(1 + α1α2 + α2α3 + α1α3 − α1α2α3(α1α2α3 + α1 + α2 + α3))

.

For any α1, α2, α3 ∈ [0, 1) this process is stationary with Xt ∼ N (0, 1) ∀t.
If α1 = α2 = α3 = α, the process reduces to

Xt = 3αXt−1 − 3α2Xt−2 + α3Xt−3 + σZN (0, 1),

σ2
Z =

(1 − α2)6
1 + 3α2 − 3α4 − α6 .

C Learning results in simulation with ARPs and OpenAI Baselines TRPO
We ran a set of experiments with ARPs (p = 3) and OpenAI Baselines TRPO algorithm. Figures 7a and 7b show learning curves
in Mujoco and Square environments respectively. The hyper-parameters are speciﬁed in the Appendix D. TRPO delivered a
similar performance to PPO in Mujoco tasks (with a more stable performance on a Reacher-v2 task), however PPO produced
better results on a sparse reward Square environment.

(a)

(b)

Figure 7: Learning curves in (a) Mujoco-based, (b) Square environments with OpenAI Baselines TRPO.

D Algorithm parameters

In our experiments we used the default Open AI Baselines parameters speciﬁed in https://github.com/openai/baselines/blob/
master/baselines with the exception of γ and λ parameters, for which we used a larger value of 0.995. For experiments
in Square environment at 10Hz action rate we used 4 times larger batch and optimization batch sizes to account for longer
episodes. For Square and UR5 Reacher 2D environments at higher action rates we used the same parameter values as for basic
versions (10Hz and 25Hz respectively), but scaled the batch and the optimization batch sizes accordingly to make sure that the
data within a batch at all action rates corresponds to the same amount of simulated time (e.g. for UR5 Reacher 2D at 125Hz we
used 5 times bigger batch and optimization batch compared to those in UR5 Reacher 2D at 25Hz). In all experiments we used
fully connected networks with the same hidden sizes to parametrize policy and value networks. For each experiment identical
parameters and network architectures were used for standard Gaussian policy and ARP. The table below shows the parameters
values for basic versions of the environments:

PPO:

Hyper-parameter
batch size
step-size
opt. batch size
opt. epochs
γ
λ
clip. ε
hidden layers
hidden sizes

Square at 10Hz Mujoco and UR5 Reacher 2D at 25Hz

8192
4 × 10−3
256
10
0.995
0.995
0.2
2
64

2048
4 × 10−3
64
10
0.995
0.995
0.2
2
64

01000000604020Reacher-v2010000000100200300Swimmer-v201000000010002000Hopper-v201000000010002000Walker2d-v20100000005001000HalfCheetah-v2Gaussian policyARP, =0.3ARP, =0.5ARP, =0.802500050000Simulated time, s1000800600400200Average return10Hz control02500050000Simulated time, s100080060040020020Hz control02500050000Simulated time, s100080060040020050Hz controlGaussian policyARP, =0.5ARP, =0.8ARP, =0.9TRPO:

Hyper-parameter
batch size
max-kl
cg-iters
vf-iters
vf-step-size
γ
λ
hidden layers
hidden sizes

Square at 10Hz Mujoco

8192
0.01
10
5
10−3
0.995
0.995
2
64

1024
0.01
10
5
10−3
0.995
0.995
2
64

E Implementation details
The equation (11) in the main text, replicated for convenience below, deﬁnes a stationary autoregressive policy distribution in
˜M p under given parameters θ:

πθ(at|˜st) = N (µθ(st) + σθ(st)fθ(˜st), σ2

θ (st)˜σ2

ZI),

fθ(˜st) =

p
(cid:88)

k=1

˜φk

at−k − µθ(st−k)
σθ(st−k)

,

˜φk, ˜σ2

Z are deﬁned by (5).

The two aspects that need to be considered separately for a practical application are the initialization at the start of a roll-out
and the learning updates.

At t < p, we do not include in the model the terms ˜φk

where t − k < 0. This corresponds to having
Xt−k = 0, t − k < 0 in the underlying AR process. Initializing an AR process with zero values results in a well behaved
time-series that quickly equilibrates to the stationary distribution without large spikes in values. In contrast, initializing from
arbitrary values often results in temporal spikes of large values before the process equilibrates to its stationary behaviour. This
restriction can be expressed in the following policy formulation:

at−k−µθ(st−k)
σθ(st−k)

πθ(at|˜st) = N (µθ(st) + σθ(st)fθ(˜st), σ2

θ (st)˜σ2

ZI),

fθ(˜st) =

min(p,t)
(cid:88)

k=1

˜φk

at−k − µθ(st−k)
σθ(st−k)

,

˜φk, ˜σ2

Z are deﬁned by (5).

Formally, dependence on t makes the policy non-stationary, however the term t plays a role only within the ﬁrst p steps in each
sample path, and, as long as the exact action a0 is not encountered again in the sample path, which is the case for continuous
action spaces, the policy could be equivalently formulated by having the agent count number of occurences of a0 in each state
˜st and based on that decide on the number of terms in fθ(˜st). Such formulation would make the policy stationary, however
it would not allow a similarly compact representation and would unnecessarily burden the formulation. Notice, that proposed
formulation also means that a0 will never be part of policy computation, and therefore will not affect future transitions.

As we pointed out in the main text, if the learning updates are performed within an episode, the change in the parameters
change their values

at−k−µ(st−k,θnew)
σ(st−k,θnew)

θ can temporally distort stationarity of the underlying AR process, since the terms ˜φk
compared to ˜φk
avoid this, corresponding previously computed values of terms ˜φk
computing fθ for the next p steps after an update.

at−k−µ(st−k,θold)
σ(st−k,θold)

at−k−µ(st−k,θold)
σ(st−k,θold)

. This may cause temporal spikes in values of fθ(˜st) until the process equilibrates again. To

where t − k < tupdate should be used in

